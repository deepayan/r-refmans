<!DOCTYPE html><html><head><title>Help for package riskRegression</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {riskRegression}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#anova.ate'><p>Risk Comparison Over Time</p></a></li>
<li><a href='#as.data.table.ate'><p>Turn ate Object Into a <code>data.table</code></p></a></li>
<li><a href='#as.data.table.influenceTest'><p>Turn influenceTest Object Into a <code>data.table</code></p></a></li>
<li><a href='#as.data.table.predictCox'><p>Turn predictCox Object Into a <code>data.table</code></p></a></li>
<li><a href='#as.data.table.predictCSC'><p>Turn predictCSC Object Into a <code>data.table</code></p></a></li>
<li><a href='#ate'><p>Average Treatment Effects Computation</p></a></li>
<li><a href='#autoplot.ate'><p>Plot Average Risks</p></a></li>
<li><a href='#autoplot.predictCox'><p>Plot Predictions From a Cox Model</p></a></li>
<li><a href='#autoplot.predictCSC'><p>Plot Predictions From a Cause-specific Cox Proportional Hazard Regression</p></a></li>
<li><a href='#autoplot.Score'><p>ggplot AUC curve</p></a></li>
<li><a href='#baseHaz_cpp'><p>C++ Fast Baseline Hazard Estimation</p></a></li>
<li><a href='#boot2pvalue'><p>Compute the p.value from the distribution under H1</p></a></li>
<li><a href='#boxplot.Score'><p>Boxplot risk quantiles</p></a></li>
<li><a href='#calcSeCox'><p>Computation of standard errors for predictions</p></a></li>
<li><a href='#calcSeCSC'><p>Standard error of the absolute risk predicted from cause-specific Cox models</p></a></li>
<li><a href='#Cforest'><p>S3-wrapper function for cforest from the party package</p></a></li>
<li><a href='#coef.CauseSpecificCox'><p>Extract coefficients from a Cause-Specific Cox regression model</p></a></li>
<li><a href='#coef.riskRegression'><p>Extract coefficients from riskRegression model</p></a></li>
<li><a href='#colCenter_cpp'><p>Apply - by column</p></a></li>
<li><a href='#colCumSum'><p>Apply cumsum in each column</p></a></li>
<li><a href='#colMultiply_cpp'><p>Apply * by column</p></a></li>
<li><a href='#colScale_cpp'><p>Apply / by column</p></a></li>
<li><a href='#confint.ate'><p>Confidence Intervals and Confidence Bands for the Predicted Absolute Risk (Cumulative Incidence Function)</p></a></li>
<li><a href='#confint.influenceTest'><p>Confidence Intervals and Confidence Bands for the Difference Between Two Estimates</p></a></li>
<li><a href='#confint.predictCox'><p>Confidence Intervals and Confidence Bands for the predicted Survival/Cumulative Hazard</p></a></li>
<li><a href='#confint.predictCSC'><p>Confidence Intervals and Confidence Bands for the Predicted Absolute Risk (Cumulative Incidence Function)</p></a></li>
<li><a href='#coxBaseEstimator'><p>Extract the type of estimator for the baseline hazard</p></a></li>
<li><a href='#coxCenter'><p>Extract the mean value of the covariates</p></a></li>
<li><a href='#coxFormula'><p>Extract the formula from a Cox model</p></a></li>
<li><a href='#coxLP'><p>Compute the linear predictor of a Cox model</p></a></li>
<li><a href='#coxModelFrame'><p>Extract the design matrix used to train a Cox model</p></a></li>
<li><a href='#coxN'><p>Extract the number of observations from a Cox model</p></a></li>
<li><a href='#coxSpecial'><p>Special characters in Cox model</p></a></li>
<li><a href='#coxStrata'><p>Define the strata for a new dataset</p></a></li>
<li><a href='#coxStrataLevel'><p>Returns the name of the strata in Cox model</p></a></li>
<li><a href='#coxVarCov'><p>Extract the variance covariance matrix of the beta from a Cox model</p></a></li>
<li><a href='#coxVariableName'><p>Extract variable names from a model</p></a></li>
<li><a href='#CSC'><p>Cause-specific Cox proportional hazard regression</p></a></li>
<li><a href='#Ctree'><p>S3-Wrapper for ctree.</p></a></li>
<li><a href='#discreteRoot'><p>Dichotomic search for monotone function</p></a></li>
<li><a href='#FGR'><p>Formula wrapper for crr from cmprsk</p></a></li>
<li><a href='#getSplitMethod'><p>Input for data splitting algorithms</p></a></li>
<li><a href='#GLMnet'><p>Fitting GLMnet for use with predictRisk</p></a></li>
<li><a href='#Hal9001'><p>Fitting HAL for use with predictRisk</p></a></li>
<li><a href='#iid.wglm'><p>IID for IPCW Logistic Regressions</p></a></li>
<li><a href='#iidCox'><p>Extract iid decomposition from a Cox model</p></a></li>
<li><a href='#influenceTest'><p>Influence test [Experimental!!]</p></a></li>
<li><a href='#information.wglm'><p>Information for IPCW Logistic Regressions</p></a></li>
<li><a href='#IPA'><p>Explained variation for settings with binary, survival and competing risk outcome</p></a></li>
<li><a href='#ipcw'><p>Estimation of censoring probabilities</p></a></li>
<li><a href='#Melanoma'><p>Malignant melanoma data</p></a></li>
<li><a href='#model.matrix.cph'><p>Extract design matrix for cph objects</p></a></li>
<li><a href='#model.matrix.phreg'><p>Extract design matrix for phreg objects</p></a></li>
<li><a href='#Paquid'><p>Paquid sample</p></a></li>
<li><a href='#penalizedS3'><p>S3-wrapper for S4 function penalized</p></a></li>
<li><a href='#plot.riskRegression'><p>Plotting predicted risk</p></a></li>
<li><a href='#plotAUC'><p>Plot of time-dependent AUC curves</p></a></li>
<li><a href='#plotBrier'><p>Plot Brier curve</p></a></li>
<li><a href='#plotCalibration'><p>Plot Calibration curve</p></a></li>
<li><a href='#plotEffects'><p>Plotting time-varying effects from a risk regression model.</p></a></li>
<li><a href='#plotPredictRisk'><p>Plotting predicted risks curves.</p></a></li>
<li><a href='#plotRisk'><p>plot predicted risks</p></a></li>
<li><a href='#plotROC'><p>Plot ROC curves</p></a></li>
<li><a href='#predict.CauseSpecificCox'><p>Predicting Absolute Risk from Cause-Specific Cox Models</p></a></li>
<li><a href='#predict.FGR'><p>Predict subject specific risks (cumulative incidence) based on Fine-Gray regression model</p></a></li>
<li><a href='#predict.riskRegression'><p>Predict individual risk.</p></a></li>
<li><a href='#predictCox'><p>Fast computation of survival probabilities, hazards and cumulative hazards from Cox regression models</p></a></li>
<li><a href='#predictCoxPL'><p>Computation of survival probabilities from Cox regression models using the product limit estimator.</p></a></li>
<li><a href='#predictRisk'><p>Extrating predicting risks from regression models</p></a></li>
<li><a href='#print.ate'><p>Print Average Treatment Effects</p></a></li>
<li><a href='#print.CauseSpecificCox'><p>Print of a Cause-Specific Cox regression model</p></a></li>
<li><a href='#print.FGR'><p>Print of a Fine-Gray regression model</p></a></li>
<li><a href='#print.influenceTest'><p>Output of the DIfference Between Two Estimates</p></a></li>
<li><a href='#print.IPA'><p>Print IPA object</p></a></li>
<li><a href='#print.predictCox'><p>Print Predictions From a Cox Model</p></a></li>
<li><a href='#print.predictCSC'><p>Print Predictions From a Cause-specific Cox Proportional Hazard Regression</p></a></li>
<li><a href='#print.riskRegression'><p>Print function for riskRegression models</p></a></li>
<li><a href='#print.Score'><p>Print Score object</p></a></li>
<li><a href='#print.subjectWeights'><p>Print subject weights</p></a></li>
<li><a href='#reconstructData'><p>Reconstruct the original dataset</p></a></li>
<li><a href='#riskLevelPlot'><p>Level plots for risk prediction models</p></a></li>
<li><a href='#riskRegression'><p>Risk Regression</p>
Fits a regression model for the risk of an event &ndash; allowing for competing
risks.</a></li>
<li><a href='#riskRegression-package'><p>Risk Regression Models and Prediction Scores for Survival Analysis with Competing Risks</p></a></li>
<li><a href='#riskRegression.options'><p>Global options for <code>riskRegression</code></p></a></li>
<li><a href='#rowCenter_cpp'><p>Apply - by row</p></a></li>
<li><a href='#rowCumSum'><p>Apply cumsum in each row</p></a></li>
<li><a href='#rowMultiply_cpp'><p>Apply * by row</p></a></li>
<li><a href='#rowPaste'><p>Collapse Rows of Characters.</p></a></li>
<li><a href='#rowScale_cpp'><p>Apply / by row</p></a></li>
<li><a href='#rowSumsCrossprod'><p>Apply crossprod and rowSums</p></a></li>
<li><a href='#sampleData'><p>Simulate data with binary or time-to-event outcome</p></a></li>
<li><a href='#saveCoxConfidential'><p>Save confidential Cox objects</p></a></li>
<li><a href='#Score'><p>Score risk predictions</p></a></li>
<li><a href='#score.wglm'><p>Score for IPCW Logistic Regressions</p></a></li>
<li><a href='#selectCox'><p>Backward variable selection in the Cox regression model</p></a></li>
<li><a href='#selectJump'><p>Evaluate the influence function at selected times</p></a></li>
<li><a href='#simActiveSurveillance'><p>Simulate data of a hypothetical active surveillance prostate cancer study</p></a></li>
<li><a href='#simMelanoma'><p>Simulate data alike the Melanoma data</p></a></li>
<li><a href='#simPBC'><p>simulating data alike the pbc data</p></a></li>
<li><a href='#simsynth'><p>Simulating from a synthesized object</p></a></li>
<li><a href='#SmcFcs'><p>SmcFcs</p></a></li>
<li><a href='#splitStrataVar'><p>Reconstruct each of the strata variables</p></a></li>
<li><a href='#subjectWeights'><p>Estimation of censoring probabilities at subject specific times</p></a></li>
<li><a href='#subsetIndex'><p>Extract Specific Elements From An Object</p></a></li>
<li><a href='#summary.ate'><p>Summary Average Treatment Effects</p></a></li>
<li><a href='#summary.FGR'><p>Summary of a Fine-Gray regression model</p></a></li>
<li><a href='#summary.riskRegression'><p>Summary of a risk regression model</p></a></li>
<li><a href='#summary.Score'><p>Summary of prediction performance metrics</p></a></li>
<li><a href='#SuperPredictor'><p>Formula interface for SuperLearner::SuperLearner</p></a></li>
<li><a href='#SurvResponseVar'><p>Extract the time and event variable from a Cox model</p></a></li>
<li><a href='#synthesize'><p>Cooking and synthesizing survival data</p></a></li>
<li><a href='#terms.phreg'><p>Extract terms for phreg objects</p></a></li>
<li><a href='#transformCIBP'><p>Compute Confidence Intervals/Bands and P-values After a Transformation</p></a></li>
<li><a href='#wglm'><p>Logistic Regression Using IPCW</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Risk Regression Models and Prediction Scores for Survival
Analysis with Competing Risks</td>
</tr>
<tr>
<td>Version:</td>
<td>2023.12.21</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0),</td>
</tr>
<tr>
<td>Imports:</td>
<td>cmprsk, data.table (&ge; 1.12.2), doParallel, foreach, ggplot2
(&ge; 3.1.0), graphics, lattice, lava (&ge; 1.6.5), mets, mvtnorm,
parallel, plotrix, prodlim (&ge; 2018.4.18), Publish, ranger,
Rcpp, rms (&ge; 5.1.3), stats, survival (&ge; 2.44.1), timereg (&ge;
1.9.3)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>boot, smcfcs, casebase, glmnet, gbm, flexsurv, grpreg,
hal9001, mgcv, mstate, nnls, numDeriv, party, pec, penalized,
pROC, randomForest, randomForestSRC, rpart, scam, SuperLearner,
testthat, R.rsp</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas Alexander Gerds &lt;tag@biostat.ku.dk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of the following methods for event history analysis.
    Risk regression models for survival endpoints also in the presence of competing
    risks are fitted using binomial regression based on a time sequence of binary
    event status variables. A formula interface for the Fine-Gray regression model
    and an interface for the combination of cause-specific Cox regression models.
    A toolbox for assessing and comparing performance of risk predictions (risk
    markers and risk prediction models). Prediction performance is measured by the
    Brier score and the area under the ROC curve for binary possibly time-dependent
    outcome. Inverse probability of censoring weighting and pseudo values are used
    to deal with right censored data. Lists of risk markers and lists of risk models
    are assessed simultaneously. Cross-validation repeatedly splits the data, trains
    the risk prediction models on one part of each split and then summarizes and
    compares the performance across splits.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/tagteam/riskRegression">https://github.com/tagteam/riskRegression</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tagteam/riskRegression/issues">https://github.com/tagteam/riskRegression/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-19 16:10:58 UTC; tag</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas Alexander Gerds [aut, cre],
  Johan Sebastian Ohlendorff [aut],
  Paul Blanche [ctb],
  Rikke Mortensen [ctb],
  Marvin Wright [ctb],
  Nikolaj Tollenaar [ctb],
  John Muschelli [ctb],
  Ulla Brasch Mogensen [ctb],
  Brice Ozenne <a href="https://orcid.org/0000-0001-9694-2956"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-19 17:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='anova.ate'>Risk Comparison Over Time</h2><span id='topic+anova.ate'></span>

<h3>Description</h3>

<p>Comparison of risk differences or risk ratios over all timepoints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ate'
anova(
  object,
  allContrast = NULL,
  type = "diff",
  estimator = object$estimator[1],
  test = "CvM",
  transform = NULL,
  alternative = "two.sided",
  n.sim = 10000,
  print = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anova.ate_+3A_object">object</code></td>
<td>
<p>A <code>ate</code> object, i.e. output of the <code>ate</code> function.</p>
</td></tr>
<tr><td><code id="anova.ate_+3A_allcontrast">allContrast</code></td>
<td>
<p>[matrix] contrast for which the risks should be compared.
Matrix with two rows, the first being the sequence of reference treatments and the second the sequence of alternative treatments.</p>
</td></tr>
<tr><td><code id="anova.ate_+3A_type">type</code></td>
<td>
<p>[character vector] the functionnal used to compare the risks: <code>"diffRisk"</code> or <code>"ratioRisk"</code>.</p>
</td></tr>
<tr><td><code id="anova.ate_+3A_estimator">estimator</code></td>
<td>
<p>[character] The type of estimator relative to which the comparison should be performed.</p>
</td></tr>
<tr><td><code id="anova.ate_+3A_test">test</code></td>
<td>
<p>[character] The type of statistic used to compare the risks over times:
<code>"KM"</code> (extremum risk), <code>"CvM"</code> (sum of squares of the risk), or <code>"sum"</code> (sum of the risks).</p>
</td></tr>
<tr><td><code id="anova.ate_+3A_transform">transform</code></td>
<td>
<p>[character] Should a transformation be used, e.g. the test is performed after log-transformation of the estimate, standard error, and influence function.</p>
</td></tr>
<tr><td><code id="anova.ate_+3A_alternative">alternative</code></td>
<td>
<p>[character] a character string specifying the alternative hypothesis, must be one of <code>"two.sided"</code>, <code>"greater"</code> or <code>"less"</code>.</p>
</td></tr>
<tr><td><code id="anova.ate_+3A_n.sim">n.sim</code></td>
<td>
<p>[integer, &gt;0] the number of simulations used to compute the p-values.</p>
</td></tr>
<tr><td><code id="anova.ate_+3A_print">print</code></td>
<td>
<p>[logical] should the results be displayed?</p>
</td></tr>
<tr><td><code id="anova.ate_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Experimental!!!
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(survival)
library(data.table)

## Not run: 
## simulate data
set.seed(12)
n &lt;- 200
dtS &lt;- sampleData(n,outcome="survival")
dtS$X12 &lt;- LETTERS[as.numeric(as.factor(paste0(dtS$X1,dtS$X2)))]
dtS &lt;- dtS[dtS$X12!="D"]

## model fit
fit &lt;- cph(formula = Surv(time,event)~ X1+X6,data=dtS,y=TRUE,x=TRUE)
seqTime &lt;- 1:10
ateFit &lt;- ate(fit, data = dtS, treatment = "X1", contrasts = NULL,
              times = seqTime, B = 0, iid = TRUE, se = TRUE, verbose = TRUE, band = TRUE)

## display
autoplot(ateFit)

## inference (two sided)
statistic &lt;- ateFit$diffRisk$estimate/ateFit$diffRisk$se
confint(ateFit, p.value = TRUE, method.band = "bonferroni")$diffRisk
confint(ateFit, p.value = TRUE, method.band = "maxT-simulation")$diffRisk

anova(ateFit, test = "KS")
anova(ateFit, test = "CvM")
anova(ateFit, test = "sum")

## manual calculation (one sided)
n.sim &lt;- 1e4
statistic &lt;- ateFit$diffRisk[, estimate/se]
iid.norm &lt;- scale(ateFit$iid$GFORMULA[["1"]]-ateFit$iid$GFORMULA[["0"]],
                  scale = ateFit$diffRisk$se)

ls.out &lt;- lapply(1:n.sim, function(iSim){
iG &lt;- rnorm(NROW(iid.norm))
iCurve &lt;- t(iid.norm) %*% iG
data.table(max = max(iCurve), L2 = sum(iCurve^2), sum = sum(iCurve),
maxC = max(iCurve) - max(statistic),
L2C = sum(iCurve^2) - sum(statistic^2),
sumC = sum(iCurve) - sum(statistic),
sim = iSim)
})

dt.out &lt;- do.call(rbind,ls.out)
dt.out[,.(max = mean(.SD$maxC&gt;=0),
          L2 = mean(.SD$L2C&gt;=0),
          sum = mean(.SD$sumC&gt;=0))]

## permutation
n.sim &lt;- 250
stats.perm &lt;- vector(mode = "list", length = n.sim)
pb &lt;- txtProgressBar(max = n.sim, style=3)
treatVar &lt;- ateFit$variables["treatment"]

for(iSim in 1:n.sim){ ## iSim &lt;- 1
iData &lt;- copy(dtS)
iIndex &lt;- sample.int(NROW(iData), replace = FALSE)
iData[, c(treatVar) := .SD[[treatVar]][iIndex]]

iFit &lt;- update(fit, data = iData)
iAteSim &lt;- ate(iFit, data = iData, treatment = treatVar,
               times = seqTime, verbose = FALSE)
iStatistic &lt;- iAteSim$diffRisk[,estimate/se]
stats.perm[[iSim]] &lt;- cbind(iAteSim$diffRisk[,.(max = max(iStatistic),
                                                L2 = sum(iStatistic^2),
                                                sum = sum(iStatistic))],
                            sim = iSim)
stats.perm[[iSim]]$maxC &lt;- stats.perm[[iSim]]$max - max(statistic)
stats.perm[[iSim]]$L2C &lt;- stats.perm[[iSim]]$L2 - sum(statistic^2)
stats.perm[[iSim]]$sumC &lt;- stats.perm[[iSim]]$sum - sum(statistic)
setTxtProgressBar(pb, iSim)
}

dtstats.perm &lt;- do.call(rbind,stats.perm)
dtstats.perm[,.(max = mean(.SD$maxC&gt;=0),
                L2 = mean(.SD$L2C&gt;=0),
                sum = mean(.SD$sumC&gt;=0))]

## End(Not run)
</code></pre>

<hr>
<h2 id='as.data.table.ate'>Turn ate Object Into a <code>data.table</code></h2><span id='topic+as.data.table.ate'></span>

<h3>Description</h3>

<p>Turn ate object into a <code>data.table</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ate'
as.data.table(
  x,
  keep.rownames = FALSE,
  estimator = x$estimator,
  type = c("meanRisk", "diffRisk", "ratioRisk"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.table.ate_+3A_x">x</code></td>
<td>
<p>object obtained with function <code>ate</code></p>
</td></tr>
<tr><td><code id="as.data.table.ate_+3A_keep.rownames">keep.rownames</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="as.data.table.ate_+3A_estimator">estimator</code></td>
<td>
<p>[character] The type of estimator relative to which the estimates should be output.</p>
</td></tr>
<tr><td><code id="as.data.table.ate_+3A_type">type</code></td>
<td>
<p>[character vector] The type of risk to export.
Can be <code>"meanRisk"</code> to export the risks specific to each treatment group,
<code>"diffRisk"</code> to export the difference in risks between treatment groups,
or <code>"ratioRisk"</code> to export the ratio of risks between treatment groups.</p>
</td></tr>
<tr><td><code id="as.data.table.ate_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>

<hr>
<h2 id='as.data.table.influenceTest'>Turn influenceTest Object Into a <code>data.table</code></h2><span id='topic+as.data.table.influenceTest'></span>

<h3>Description</h3>

<p>Turn influenceTest object into a <code>data.table</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'influenceTest'
as.data.table(x, keep.rownames = FALSE, se = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.table.influenceTest_+3A_x">x</code></td>
<td>
<p>object obtained with function <code>influenceTest</code></p>
</td></tr>
<tr><td><code id="as.data.table.influenceTest_+3A_keep.rownames">keep.rownames</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="as.data.table.influenceTest_+3A_se">se</code></td>
<td>
<p>[logical] Should standard errors/quantile for confidence bands be displayed?</p>
</td></tr>
<tr><td><code id="as.data.table.influenceTest_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>

<hr>
<h2 id='as.data.table.predictCox'>Turn predictCox Object Into a <code>data.table</code></h2><span id='topic+as.data.table.predictCox'></span>

<h3>Description</h3>

<p>Turn predictCox object into a <code>data.table</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'predictCox'
as.data.table(x, keep.rownames = FALSE, se = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.table.predictCox_+3A_x">x</code></td>
<td>
<p>object obtained with function <code>predictCox</code></p>
</td></tr>
<tr><td><code id="as.data.table.predictCox_+3A_keep.rownames">keep.rownames</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="as.data.table.predictCox_+3A_se">se</code></td>
<td>
<p>[logical] Should standard errors/quantile for confidence bands be displayed?</p>
</td></tr>
<tr><td><code id="as.data.table.predictCox_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>

<hr>
<h2 id='as.data.table.predictCSC'>Turn predictCSC Object Into a <code>data.table</code></h2><span id='topic+as.data.table.predictCSC'></span>

<h3>Description</h3>

<p>Turn predictCSC object into a <code>data.table</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'predictCSC'
as.data.table(x, keep.rownames = FALSE, se = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.table.predictCSC_+3A_x">x</code></td>
<td>
<p>object obtained with function <code>predictCSC</code></p>
</td></tr>
<tr><td><code id="as.data.table.predictCSC_+3A_keep.rownames">keep.rownames</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="as.data.table.predictCSC_+3A_se">se</code></td>
<td>
<p>should standard errors/quantile for confidence bands be displayed?</p>
</td></tr>
<tr><td><code id="as.data.table.predictCSC_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>

<hr>
<h2 id='ate'>Average Treatment Effects Computation</h2><span id='topic+ate'></span>

<h3>Description</h3>

<p>Use the g-formula or the IPW or the double robust estimator
to estimate the average treatment
effect (absolute risk difference or ratio)
based on Cox regression with or without competing risks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ate(
  event,
  treatment,
  censor = NULL,
  data,
  data.index = NULL,
  formula = NULL,
  estimator = NULL,
  strata = NULL,
  contrasts = NULL,
  allContrasts = NULL,
  times,
  cause = NA,
  landmark = NULL,
  se = TRUE,
  iid = (B == 0) &amp;&amp; (se || band),
  known.nuisance = FALSE,
  band = FALSE,
  B = 0,
  seed,
  handler = "foreach",
  mc.cores = 1,
  cl = NULL,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ate_+3A_event">event</code></td>
<td>
<p>Outcome model which describes how the probability of experiencing a terminal event depends
on treatment and covariates. The object carry its own call and
have a <code>predictRisk</code> method. See examples.</p>
</td></tr>
<tr><td><code id="ate_+3A_treatment">treatment</code></td>
<td>
<p>Treatment model which describes how the probability of being allocated to a treatment group depends
on covariates. The object must be a <code>glm</code> object (logistic regression) or the name of the treatment variable.
See examples.</p>
</td></tr>
<tr><td><code id="ate_+3A_censor">censor</code></td>
<td>
<p>Censoring model which describes how the probability of being censored depends
on treatment and covariates. The object must be a <code>coxph</code> or <code>cph</code> object. See examples.</p>
</td></tr>
<tr><td><code id="ate_+3A_data">data</code></td>
<td>
<p>[data.frame or data.table] Data set in which to evaluate risk predictions
based on the outcome model</p>
</td></tr>
<tr><td><code id="ate_+3A_data.index">data.index</code></td>
<td>
<p>[numeric vector] Position of the observation in argument data relative to the dataset used to obtain the argument event, treatment, censor.
Only necessary for the standard errors when computing the Average Treatment Effects on a subset of the data set.</p>
</td></tr>
<tr><td><code id="ate_+3A_formula">formula</code></td>
<td>
<p>For analyses with time-dependent covariates, the response formula. See examples.</p>
</td></tr>
<tr><td><code id="ate_+3A_estimator">estimator</code></td>
<td>
<p>[character] The type of estimator used to compute the average treatment effect. 
Can be <code>"G-formula"</code>, <code>"IPTW"</code>, or <code>"AIPTW"</code>.
When using <code>estimator="G-formula"</code>, a model for the outcome should be provided (argument event).
When using <code>estimator="IPTW"</code>, a model for the treatment should be provided (argument treatment), as well as for the censoring (if any, argument censor).
When using <code>estimator="AIPTW"</code> (double robust estimator), a model for the outcome and the treatment should be provided (argument event and treatment), as well as for the censoring (if any, argument censor).</p>
</td></tr>
<tr><td><code id="ate_+3A_strata">strata</code></td>
<td>
<p>[character] Strata variable on which to compute the average risk.
Incompatible with treatment. Experimental.</p>
</td></tr>
<tr><td><code id="ate_+3A_contrasts">contrasts</code></td>
<td>
<p>[character vector] levels of the treatment variable for which the risks should be assessed and compared. Default is to consider all levels.</p>
</td></tr>
<tr><td><code id="ate_+3A_allcontrasts">allContrasts</code></td>
<td>
<p>[2-row character matrix] levels of the treatment variable to be compared. Default is to consider all pairwise comparisons.</p>
</td></tr>
<tr><td><code id="ate_+3A_times">times</code></td>
<td>
<p>[numeric vector] Time points at which to evaluate average treatment effects.</p>
</td></tr>
<tr><td><code id="ate_+3A_cause">cause</code></td>
<td>
<p>[integer/character] the cause of interest.</p>
</td></tr>
<tr><td><code id="ate_+3A_landmark">landmark</code></td>
<td>
<p>for models with time-dependent covariates the landmark time(s) of evaluation.
In this case, argument <code>time</code> may only be one value and for the prediction of risks
it is assumed that that the covariates do not change between landmark and landmark+time.</p>
</td></tr>
<tr><td><code id="ate_+3A_se">se</code></td>
<td>
<p>[logical] If <code>TRUE</code> compute and add the standard errors to the output.</p>
</td></tr>
<tr><td><code id="ate_+3A_iid">iid</code></td>
<td>
<p>[logical] If <code>TRUE</code> compute and add the influence function to the output.</p>
</td></tr>
<tr><td><code id="ate_+3A_known.nuisance">known.nuisance</code></td>
<td>
<p>[logical] If <code>FALSE</code> the uncertainty related to the estimation of the nuisance parameters is ignored.
This greatly simplifies computations but requires to use a double robust estimator.
The resulting standard error is known to be consistent when all event, treatment, and censoring models are valid.</p>
</td></tr>
<tr><td><code id="ate_+3A_band">band</code></td>
<td>
<p>[logical] If <code>TRUE</code> compute and add the quantiles for the confidence bands to the output.</p>
</td></tr>
<tr><td><code id="ate_+3A_b">B</code></td>
<td>
<p>[integer, &gt;0] the number of bootstrap replications used to compute the confidence intervals.
If it equals 0, then the influence function is used to compute Wald-type confidence intervals/bands.</p>
</td></tr>
<tr><td><code id="ate_+3A_seed">seed</code></td>
<td>
<p>[integer, &gt;0] sed number used to generate seeds for bootstrap
and to achieve reproducible results.</p>
</td></tr>
<tr><td><code id="ate_+3A_handler">handler</code></td>
<td>
<p>[character] Parallel handler for bootstrap. 
<code>"foreach"</code> is the default and the only option on Windows. It uses <code>parallel</code> to create a cluster.
Other operating systems can use <code>"mclapply"</code>.
This argument is ignored when <code>mc.cores=1</code> and <code>cl=NULL</code>.</p>
</td></tr>
<tr><td><code id="ate_+3A_mc.cores">mc.cores</code></td>
<td>
<p>[integer, &gt;0] The number of cores to use,
i.e., the upper limit for the number of child processes that run simultaneously.
Passed to <code>parallel::mclapply</code> or <code>parallel::makeCluster</code>.
The option is initialized from environment variable mc_cores if set.</p>
</td></tr>
<tr><td><code id="ate_+3A_cl">cl</code></td>
<td>
<p>A parallel socket cluster used to perform cluster calculation in parallel (output by <code>parallel::makeCluster</code>).
The packages necessary to run the computations (e.g. riskRegression) must already be loaded on each worker.
Only used when <code>handler="foreach"</code>.</p>
</td></tr>
<tr><td><code id="ate_+3A_verbose">verbose</code></td>
<td>
<p>[logical] If <code>TRUE</code> inform about estimated run time.</p>
</td></tr>
<tr><td><code id="ate_+3A_...">...</code></td>
<td>
<p>passed to predictRisk</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Brice Ozenne <a href="mailto:broz@sund.ku.dk">broz@sund.ku.dk</a>
and Thomas Alexander Gerds <a href="mailto:tag@biostat.ku.dk">tag@biostat.ku.dk</a>
</p>


<h3>References</h3>

<p>Brice Maxime Hugues Ozenne, Thomas Harder Scheike, Laila Staerk, and Thomas
Alexander Gerds. On the estimation of average treatment effects with right-
censored time to event outcome and competing risks. Biometrical Journal, 62
(3):751&ndash;763, 2020.
</p>


<h3>See Also</h3>

<p><code><a href="data.table.html#topic+as.data.table">as.data.table</a></code> to extract the estimates in a <code>data.table</code> object.
<code><a href="#topic+autoplot.ate">autoplot.ate</a></code> for a graphical representation the standardized risks.
<code><a href="#topic+confint.ate">confint.ate</a></code> to compute (pointwise/simultaneous) confidence intervals and (unadjusted/adjusted) p-values, possibly using a transformation.
<code><a href="#topic+summary.ate">summary.ate</a></code> for a table containing the standardized risks over time and treatment/strata.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(survival)
library(rms)
library(prodlim)
library(data.table)
set.seed(10)

#### Survival settings  ####
#### ATE with Cox model ####

## generate data
n &lt;- 100
dtS &lt;- sampleData(n, outcome="survival")
dtS$time &lt;- round(dtS$time,1)
dtS$X1 &lt;- factor(rbinom(n, prob = c(0.3,0.4) , size = 2), labels = paste0("T",0:2))

## estimate the Cox model
fit &lt;- cph(formula = Surv(time,event)~ X1+X2,data=dtS,y=TRUE,x=TRUE)

## compute the ATE at times 5, 6, 7, and 8 using X1 as the treatment variable
## standard error computed using the influence function
## confidence intervals / p-values based on asymptotic results
ateFit1a &lt;- ate(fit, data = dtS, treatment = "X1", times = 5:8)
summary(ateFit1a)
summary(ateFit1a, short = TRUE, type = "meanRisk")
summary(ateFit1a, short = TRUE, type = "diffRisk")
summary(ateFit1a, short = TRUE, type = "ratioRisk")

## Not run: 
## same as before with in addition the confidence bands / adjusted p-values
## (argument band = TRUE)
ateFit1b &lt;- ate(fit, data = dtS, treatment = "X1", times = 5:8,
                band = TRUE)
summary(ateFit1b)

## by default bands/adjuste p-values computed separately for each treatment modality
summary(ateFit1b, band = 1,
         se = FALSE, type = "diffRisk", short = TRUE, quantile = TRUE)
## adjustment over treatment and time using the band argument of confint
summary(ateFit1b, band = 2,
       se = FALSE, type = "diffRisk", short = TRUE, quantile = TRUE)

## confidence intervals / p-values computed using 1000 bootstrap samples
## (argument se = TRUE and B = 1000) 
ateFit1c &lt;- ate(fit, data = dtS, treatment = "X1",
                times = 5:8, se = TRUE, B = 50, handler = "mclapply")
## NOTE: for real applications 50 bootstrap samples is not enough 

## same but using 2 cpus for generating and analyzing the bootstrap samples
## (parallel computation, argument mc.cores = 2) 
ateFit1d &lt;- ate(fit, data = dtS, treatment = "X1",
                times = 5:8, se = TRUE, B = 50, mc.cores = 2)

## manually defining the cluster to be used
## useful when specific packages need to be loaded in each cluster
fit &lt;- cph(formula = Surv(time,event)~ X1+X2+rcs(X6),data=dtS,y=TRUE,x=TRUE)

cl &lt;- parallel::makeCluster(2)
parallel::clusterEvalQ(cl, library(rms))

ateFit1e &lt;- ate(fit, data = dtS, treatment = "X1",
                times = 5:8, se = TRUE, B = 50,
                handler = "foreach", cl = cl)

## End(Not run)

#### Survival settings without censoring ####
#### ATE with glm                        ####

## generate data
n &lt;- 100
dtB &lt;- sampleData(n, outcome="binary")
dtB[, X2 := as.numeric(X2)]

## estimate a logistic regression model
fit &lt;- glm(formula = Y ~ X1+X2, data=dtB, family = "binomial")

## compute the ATE using X1 as the treatment variable
## only point estimate (argument se = FALSE)
ateFit1a &lt;- ate(fit, data = dtB, treatment = "X1", se = FALSE)
ateFit1a

## Not run: 
## with confidence intervals
ateFit1b &lt;- ate(fit, data = dtB, treatment = "X1",
               times = 5) ## just for having a nice output not used in computations
summary(ateFit1b, short = TRUE)

## using the lava package
library(lava)
ateLava &lt;- estimate(fit, function(p, data){
a &lt;- p["(Intercept)"] ; b &lt;- p["X11"] ; c &lt;- p["X2"] ;
R.X11 &lt;- expit(a + b + c * data[["X2"]])
R.X10 &lt;- expit(a + c * data[["X2"]])
list(risk0=R.X10,risk1=R.X11,riskdiff=R.X11-R.X10)},
average=TRUE)
ateLava

## End(Not run)

## see wglm for handling right-censoring with glm

#### Competing risks settings               ####
#### ATE with cause specific Cox regression ####

## generate data
n &lt;- 500
set.seed(10)
dt &lt;- sampleData(n, outcome="competing.risks")
dt$X1 &lt;- factor(rbinom(n, prob = c(0.2,0.3) , size = 2), labels = paste0("T",0:2))

## estimate cause specific Cox model
fitCR &lt;-  CSC(Hist(time,event)~ X1+X8,data=dt,cause=1)

## compute the ATE at times 1, 5, 10 using X1 as the treatment variable
ateFit2a &lt;- ate(fitCR, data = dt, treatment = "X1", times = c(1,5,10),
                cause = 1, se = TRUE, band = TRUE)
summary(ateFit2a)
as.data.table(ateFit2a)

#### Double robust estimator ####
## Not run: 
## generate data
n &lt;- 500
set.seed(10)
dt &lt;- sampleData(n, outcome="competing.risks")
dt$time &lt;- round(dt$time,1)
dt$X1 &lt;- factor(rbinom(n, prob = c(0.4) , size = 1), labels = paste0("T",0:1))

## working models
m.event &lt;-  CSC(Hist(time,event)~ X1+X2+X3+X5+X8,data=dt)
m.censor &lt;-  coxph(Surv(time,event==0)~ X1+X2+X3+X5+X8,data=dt, x = TRUE, y = TRUE)
m.treatment &lt;-  glm(X1~X2+X3+X5+X8,data=dt,family=binomial(link="logit"))

## prediction + average
ateRobust &lt;- ate(event = m.event,
                 treatment = m.treatment,
                 censor = m.censor,
                 data = dt, times = 5:10, 
                 cause = 1, band = TRUE)

## compare various estimators
ateRobust3 &lt;- ate(event = m.event,
                 treatment = m.treatment,
                 censor = m.censor,
                 estimator = c("GFORMULA","IPTW","AIPTW"),
                 data = dt, times = c(5:10), 
                 cause = 1, se = TRUE)
print(setkeyv(as.data.table(ateRobust3, type = "meanRisk"),"time"))
print(setkeyv(as.data.table(ateRobust3, type = "diffRisk"),"time"))

## End(Not run)

#### time-dependent covariates ###
## Not run: 
library(survival)
fit &lt;- coxph(Surv(time, status) ~ celltype+karno + age + trt, veteran)
vet2 &lt;- survSplit(Surv(time, status) ~., veteran,
                       cut=c(60, 120), episode ="timegroup")
fitTD &lt;- coxph(Surv(tstart, time, status) ~ celltype +karno + age + trt,
               data= vet2,x=1)
set.seed(16)
resVet &lt;- ate(fitTD,formula=Hist(entry=tstart,time=time,event=status)~1,
          data = vet2, treatment = "celltype",
        times=5,verbose=1,
        landmark = c(0,30,60,90), cause = 1, B = 50, se = 1,
        band = FALSE, mc.cores=1)
summary(resVet)

## End(Not run)

## Not run: 
set.seed(137)
d=sampleDataTD(127)
library(survival)
d[,status:=1*(event==1)]
d[,X3:=as.factor(X3)]
## ignore competing risks
cox1TD &lt;- coxph(Surv(start,time, status,type="counting") ~ X3+X5+X6+X8,
                data=d, x = TRUE)
resTD1 &lt;- ate(cox1TD,formula=Hist(entry=start,time=time,event=status)~1,
        data = d, treatment = "X3", contrasts = NULL,
        times=.5,verbose=1,
        landmark = c(0,0.5,1), B = 20, se = 1,
        band = FALSE, mc.cores=1)
resTD1
## account for competing risks
cscTD &lt;- CSC(Hist(time=time, event=event,entry=start) ~ X3+X5+X6+X8, data=d)
set.seed(16)
resTD &lt;- ate(cscTD,formula=Hist(entry=start,time=time,event=event)~1,
        data = d, treatment = "X3", contrasts = NULL,
        times=.5,verbose=1,
        landmark = c(0,0.5,1), cause = 1, B = 20, se = 1,
        band = FALSE, mc.cores=1)
resTD

## End(Not run)
</code></pre>

<hr>
<h2 id='autoplot.ate'>Plot Average Risks</h2><span id='topic+autoplot.ate'></span>

<h3>Description</h3>

<p>Plot average risks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ate'
autoplot(
  object,
  type = "meanRisk",
  first.derivative = FALSE,
  estimator = object$estimator[1],
  ci = object$inference$ci,
  band = object$inference$band,
  plot.type = "1",
  plot = TRUE,
  smooth = FALSE,
  digits = 2,
  alpha = NA,
  ylab = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot.ate_+3A_object">object</code></td>
<td>
<p>Object obtained with the function <code>ate</code>.</p>
</td></tr>
<tr><td><code id="autoplot.ate_+3A_type">type</code></td>
<td>
<p>[character vector] what to displayed.
Can be <code>"meanRisk"</code> to display the risks specific to each treatment group,
<code>"diffRisk"</code> to display the difference in risks between treatment groups,
or <code>"ratioRisk"</code> to display the ratio of risks between treatment groups,.</p>
</td></tr>
<tr><td><code id="autoplot.ate_+3A_first.derivative">first.derivative</code></td>
<td>
<p>[logical] If <code>TRUE</code>, display the first derivative over time of the risks/risk differences/risk ratios.
(confidence intervals are obtained via simulation).</p>
</td></tr>
<tr><td><code id="autoplot.ate_+3A_estimator">estimator</code></td>
<td>
<p>[character] The type of estimator relative to which the risks should be displayed.</p>
</td></tr>
<tr><td><code id="autoplot.ate_+3A_ci">ci</code></td>
<td>
<p>[logical] If <code>TRUE</code> display the confidence intervals for the average risks.</p>
</td></tr>
<tr><td><code id="autoplot.ate_+3A_band">band</code></td>
<td>
<p>[logical] If <code>TRUE</code> display the confidence bands for the average risks.</p>
</td></tr>
<tr><td><code id="autoplot.ate_+3A_plot.type">plot.type</code></td>
<td>
<p>[character] Type of plot to be used.
<code>plot.type="2"</code> is useful when looking simulateneous at all eventtimes.
Otherwise use <code>plot.type="1"</code>.</p>
</td></tr>
<tr><td><code id="autoplot.ate_+3A_plot">plot</code></td>
<td>
<p>[logical] Should the graphic be plotted.</p>
</td></tr>
<tr><td><code id="autoplot.ate_+3A_smooth">smooth</code></td>
<td>
<p>[logical] Should a smooth version of the risk function be plotted instead of a simple function?</p>
</td></tr>
<tr><td><code id="autoplot.ate_+3A_digits">digits</code></td>
<td>
<p>[integer, &gt;0] Number of decimal places.</p>
</td></tr>
<tr><td><code id="autoplot.ate_+3A_alpha">alpha</code></td>
<td>
<p>[numeric, 0-1] Transparency of the confidence bands. Argument passed to <code>ggplot2::geom_ribbon</code>.</p>
</td></tr>
<tr><td><code id="autoplot.ate_+3A_ylab">ylab</code></td>
<td>
<p>[character] Label for the y axis.</p>
</td></tr>
<tr><td><code id="autoplot.ate_+3A_...">...</code></td>
<td>
<p>Additional parameters to cutomize the display.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisible. A list containing:
</p>

<ul>
<li><p> plot: the ggplot object.
</p>
</li>
<li><p> data: the data used to create the plot.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+ate">ate</a></code> to compute average risks.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(survival)
library(rms)
library(ggplot2)

#### simulate data ####
n &lt;- 1e2
set.seed(10)
dtS &lt;- sampleData(n,outcome="survival")
seqTimes &lt;- c(0,sort(dtS$time[dtS$event==1]),max(dtS$time))

#### Cox model ####
fit &lt;- cph(formula = Surv(time,event)~ X1+X2,data=dtS,y=TRUE,x=TRUE)

#### plot.type = 1: for few timepoints ####
ateFit &lt;- ate(fit, data = dtS, treatment = "X1",
              times = c(1,2,5,10), se = TRUE, band = TRUE)
ggplot2::autoplot(ateFit)
## Not run: 
ggplot2::autoplot(ateFit, band = FALSE)
ggplot2::autoplot(ateFit, type = "diffRisk")
ggplot2::autoplot(ateFit, type = "ratioRisk")

## End(Not run)

#### plot.type = 2: when looking at all jump times ####
## Not run: 
ateFit &lt;- ate(fit, data = dtS, treatment = "X1",
              times = seqTimes, se = TRUE, band = TRUE)

ggplot2::autoplot(ateFit, plot.type = "2")

## customize plot
outGG &lt;- ggplot2::autoplot(ateFit, plot.type = "2", alpha = 0.25)
outGG$plot + facet_wrap(~X1, labeller = label_both)


## Looking at the difference after smoothing
outGGS &lt;- ggplot2::autoplot(ateFit, plot.type = "2", alpha = NA, smooth = TRUE)
outGGS$plot + facet_wrap(~X1, labeller = label_both)

## first derivative
## (computation of the confidence intervals takes time)
## (based on simulation - n.sim parameter)
ggplot2::autoplot(ateFit, plot.type = "2", smooth = TRUE,
                  band = FALSE, type = "diffRisk")
ggplot2::autoplot(ateFit, plot.type = "2", smooth = TRUE, first.derivative = TRUE,
                  band = FALSE, type = "diffRisk")

## End(Not run)
</code></pre>

<hr>
<h2 id='autoplot.predictCox'>Plot Predictions From a Cox Model</h2><span id='topic+autoplot.predictCox'></span>

<h3>Description</h3>

<p>Plot predictions from a Cox model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'predictCox'
autoplot(
  object,
  type = NULL,
  ci = object$se,
  band = object$band,
  plot = TRUE,
  smooth = NULL,
  digits = 2,
  alpha = NA,
  group.by = "row",
  reduce.data = FALSE,
  ylab = NULL,
  first.derivative = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot.predictCox_+3A_object">object</code></td>
<td>
<p>Object obtained with the function <code>predictCox</code>.</p>
</td></tr>
<tr><td><code id="autoplot.predictCox_+3A_type">type</code></td>
<td>
<p>[character] The type of predicted value to display.
Choices are:
<code>"hazard"</code> the hazard function,
<code>"cumhazard"</code> the cumulative hazard function, 
or <code>"survival"</code> the survival function.</p>
</td></tr>
<tr><td><code id="autoplot.predictCox_+3A_ci">ci</code></td>
<td>
<p>[logical] If <code>TRUE</code> display the confidence intervals for the predictions.</p>
</td></tr>
<tr><td><code id="autoplot.predictCox_+3A_band">band</code></td>
<td>
<p>[logical] If <code>TRUE</code> display the confidence bands for the predictions.</p>
</td></tr>
<tr><td><code id="autoplot.predictCox_+3A_plot">plot</code></td>
<td>
<p>[logical] Should the graphic be plotted.</p>
</td></tr>
<tr><td><code id="autoplot.predictCox_+3A_smooth">smooth</code></td>
<td>
<p>[logical] Should a smooth version of the risk function be plotted instead of a simple function?</p>
</td></tr>
<tr><td><code id="autoplot.predictCox_+3A_digits">digits</code></td>
<td>
<p>[integer] Number of decimal places when displaying the values of the covariates in the caption.</p>
</td></tr>
<tr><td><code id="autoplot.predictCox_+3A_alpha">alpha</code></td>
<td>
<p>[numeric, 0-1] Transparency of the confidence bands. Argument passed to <code>ggplot2::geom_ribbon</code>.</p>
</td></tr>
<tr><td><code id="autoplot.predictCox_+3A_group.by">group.by</code></td>
<td>
<p>[character] The grouping factor used to color the prediction curves. Can be <code>"row"</code>, <code>"strata"</code>, or <code>"covariates"</code>.</p>
</td></tr>
<tr><td><code id="autoplot.predictCox_+3A_reduce.data">reduce.data</code></td>
<td>
<p>[logical] If <code>TRUE</code> only the covariates that does take indentical values for all observations are displayed.</p>
</td></tr>
<tr><td><code id="autoplot.predictCox_+3A_ylab">ylab</code></td>
<td>
<p>[character] Label for the y axis.</p>
</td></tr>
<tr><td><code id="autoplot.predictCox_+3A_first.derivative">first.derivative</code></td>
<td>
<p>[logical] If <code>TRUE</code>, display the first derivative over time of the risks/risk differences/risk ratios.
(confidence intervals are obtained via simulation).</p>
</td></tr>
<tr><td><code id="autoplot.predictCox_+3A_...">...</code></td>
<td>
<p>Additional parameters to cutomize the display.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisible. A list containing:
</p>

<ul>
<li><p> plot: the ggplot object.
</p>
</li>
<li><p> data: the data used to create the plot.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+predictCox">predictCox</a></code> to compute cumulative hazard and survival based on a Cox model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(survival)
library(ggplot2)

#### simulate data ####
set.seed(10)
d &lt;- sampleData(1e2, outcome = "survival")
seqTau &lt;- c(0,sort(unique(d$time[d$event==1])), max(d$time))

#### Cox model ####
m.cox &lt;- coxph(Surv(time,event)~ X1 + X2 + X3,
                data = d, x = TRUE, y = TRUE)

## display baseline hazard
e.basehaz &lt;- predictCox(m.cox)
autoplot(e.basehaz, type = "cumhazard")
## Not run: 
autoplot(e.basehaz, type = "cumhazard", size.point = 0) ## without points
autoplot(e.basehaz, type = "cumhazard", smooth = TRUE)
autoplot(e.basehaz, type = "cumhazard", smooth = TRUE, first.derivative = TRUE)

## End(Not run)

## display baseline hazard with type of event
## Not run: 
e.basehaz &lt;- predictCox(m.cox, keep.newdata = TRUE)
autoplot(e.basehaz, type = "cumhazard")
autoplot(e.basehaz, type = "cumhazard", shape.point = c(3,NA))

## End(Not run)

## display predicted survival
## Not run: 
pred.cox &lt;- predictCox(m.cox, newdata = d[1:2,],
  times = seqTau, type = "survival", keep.newdata = TRUE)
autoplot(pred.cox)
autoplot(pred.cox, smooth = TRUE)
autoplot(pred.cox, group.by = "covariates")
autoplot(pred.cox, group.by = "covariates", reduce.data = TRUE)
autoplot(pred.cox, group.by = "X1", reduce.data = TRUE)

## End(Not run)

## predictions with confidence interval/bands
## Not run: 
pred.cox &lt;- predictCox(m.cox, newdata = d[1:2,,drop=FALSE],
  times = seqTau, type = "survival", band = TRUE, se = TRUE, keep.newdata = TRUE)
res &lt;- autoplot(pred.cox, ci = TRUE, band = TRUE, plot = FALSE)
res$plot + facet_wrap(~row)
res2 &lt;- autoplot(pred.cox, ci = TRUE, band = TRUE, alpha = 0.1, plot = FALSE)
res2$plot + facet_wrap(~row)

## End(Not run)

#### Stratified Cox model ####
## Not run: 
m.cox.strata &lt;- coxph(Surv(time,event)~ strata(X1) + strata(X2) + X3 + X4,
                      data = d, x = TRUE, y = TRUE)

## baseline hazard
pred.baseline &lt;- predictCox(m.cox.strata, keep.newdata = TRUE, type = "survival")
res &lt;- autoplot(pred.baseline)
res$plot + facet_wrap(~strata, labeller = label_both)

## predictions
pred.cox.strata &lt;- predictCox(m.cox.strata, newdata = d[1:3,,drop=FALSE],
                              time = seqTau, keep.newdata = TRUE, se = TRUE)

res2 &lt;- autoplot(pred.cox.strata, type = "survival", group.by = "strata", plot = FALSE)
res2$plot + facet_wrap(~strata, labeller = label_both) + theme(legend.position="bottom")

## smooth version
autoplot(pred.cox.strata, type = "survival", group.by = "strata", smooth = TRUE, ci = FALSE)

## End(Not run)

#### Cox model with splines ####
## Not run: 
require(splines)
m.cox.spline &lt;- coxph(Surv(time,event)~ X1 + X2 + ns(X6,4),
                data = d, x = TRUE, y = TRUE)
grid &lt;- data.frame(X1 = factor(0,0:1), X2 = factor(0,0:1),
                   X6 = seq(min(d$X6),max(d$X6), length.out = 100))
pred.spline &lt;- predictCox(m.cox.spline, newdata = grid, keep.newdata = TRUE,
                          se = TRUE, band = TRUE, centered = TRUE, type = "lp")
autoplot(pred.spline, group.by = "X6")
autoplot(pred.spline, group.by = "X6", alpha = 0.5)

grid2 &lt;- data.frame(X1 = factor(1,0:1), X2 = factor(0,0:1),
                    X6 = seq(min(d$X6),max(d$X6), length.out = 100))
pred.spline &lt;- predictCox(m.cox.spline, newdata = rbind(grid,grid2), keep.newdata = TRUE,
                          se = TRUE, band = TRUE, centered = TRUE, type = "lp")
autoplot(pred.spline, group.by = c("X6","X1"), alpha = 0.5, plot = FALSE)$plot + facet_wrap(~X1)

## End(Not run)
</code></pre>

<hr>
<h2 id='autoplot.predictCSC'>Plot Predictions From a Cause-specific Cox Proportional Hazard Regression</h2><span id='topic+autoplot.predictCSC'></span>

<h3>Description</h3>

<p>Plot predictions from a Cause-specific Cox proportional hazard regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'predictCSC'
autoplot(
  object,
  ci = object$se,
  band = object$band,
  plot = TRUE,
  smooth = FALSE,
  digits = 2,
  alpha = NA,
  group.by = "row",
  reduce.data = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot.predictCSC_+3A_object">object</code></td>
<td>
<p>Object obtained with the function <code>predictCox</code>.</p>
</td></tr>
<tr><td><code id="autoplot.predictCSC_+3A_ci">ci</code></td>
<td>
<p>[logical] If <code>TRUE</code> display the confidence intervals for the predictions.</p>
</td></tr>
<tr><td><code id="autoplot.predictCSC_+3A_band">band</code></td>
<td>
<p>[logical] If <code>TRUE</code> display the confidence bands for the predictions.</p>
</td></tr>
<tr><td><code id="autoplot.predictCSC_+3A_plot">plot</code></td>
<td>
<p>[logical] Should the graphic be plotted.</p>
</td></tr>
<tr><td><code id="autoplot.predictCSC_+3A_smooth">smooth</code></td>
<td>
<p>[logical] Should a smooth version of the risk function be plotted instead of a simple function?</p>
</td></tr>
<tr><td><code id="autoplot.predictCSC_+3A_digits">digits</code></td>
<td>
<p>[integer] Number of decimal places.</p>
</td></tr>
<tr><td><code id="autoplot.predictCSC_+3A_alpha">alpha</code></td>
<td>
<p>[numeric, 0-1] Transparency of the confidence bands. Argument passed to <code>ggplot2::geom_ribbon</code>.</p>
</td></tr>
<tr><td><code id="autoplot.predictCSC_+3A_group.by">group.by</code></td>
<td>
<p>[character] The grouping factor used to color the prediction curves. Can be <code>"row"</code>, <code>"strata"</code>, or <code>"covariates"</code>.</p>
</td></tr>
<tr><td><code id="autoplot.predictCSC_+3A_reduce.data">reduce.data</code></td>
<td>
<p>[logical] If <code>TRUE</code> only the covariates that does take indentical values for all observations are displayed.</p>
</td></tr>
<tr><td><code id="autoplot.predictCSC_+3A_...">...</code></td>
<td>
<p>Additional parameters to cutomize the display.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisible. A list containing:
</p>

<ul>
<li><p> plot: the ggplot object.
</p>
</li>
<li><p> data: the data used to create the plot.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+predict.CauseSpecificCox">predict.CauseSpecificCox</a></code> to compute risks based on a CSC model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(survival)
library(rms)
library(ggplot2)
library(prodlim)

#### simulate data ####
set.seed(10)
d &lt;- sampleData(1e2, outcome = "competing.risks")
seqTau &lt;- c(0,unique(sort(d[d$event==1,time])), max(d$time))

#### CSC model ####
m.CSC &lt;- CSC(Hist(time,event)~ X1 + X2 + X6, data = d)

pred.CSC &lt;- predict(m.CSC, newdata = d[1:2,], time = seqTau, cause = 1, band = TRUE)
autoplot(pred.CSC, alpha = 0.2)

#### stratified CSC model ####
m.SCSC &lt;- CSC(Hist(time,event)~ strata(X1) + strata(X2) + X6,
              data = d)
pred.SCSC &lt;- predict(m.SCSC, time = seqTau, newdata = d[1:4,],
                     cause = 1, keep.newdata = TRUE, keep.strata = TRUE)
autoplot(pred.SCSC, group.by = "strata")
</code></pre>

<hr>
<h2 id='autoplot.Score'>ggplot AUC curve</h2><span id='topic+autoplot.Score'></span>

<h3>Description</h3>

<p>ggplot AUC curves
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Score'
autoplot(
  object,
  models,
  type = "score",
  lwd = 2,
  xlim,
  ylim,
  axes = TRUE,
  conf.int = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot.Score_+3A_object">object</code></td>
<td>
<p>Object obtained with <code>Score.list</code></p>
</td></tr>
<tr><td><code id="autoplot.Score_+3A_models">models</code></td>
<td>
<p>Choice of models to plot</p>
</td></tr>
<tr><td><code id="autoplot.Score_+3A_type">type</code></td>
<td>
<p>Character. Either <code>"score"</code> to show AUC or <code>"contrasts"</code> to show differences between AUC.</p>
</td></tr>
<tr><td><code id="autoplot.Score_+3A_lwd">lwd</code></td>
<td>
<p>Line width</p>
</td></tr>
<tr><td><code id="autoplot.Score_+3A_xlim">xlim</code></td>
<td>
<p>Limits for x-axis</p>
</td></tr>
<tr><td><code id="autoplot.Score_+3A_ylim">ylim</code></td>
<td>
<p>Limits for y-axis</p>
</td></tr>
<tr><td><code id="autoplot.Score_+3A_axes">axes</code></td>
<td>
<p>Logical. If <code>TRUE</code> draw axes.</p>
</td></tr>
<tr><td><code id="autoplot.Score_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical. If <code>TRUE</code> draw confidence shadows.</p>
</td></tr>
<tr><td><code id="autoplot.Score_+3A_...">...</code></td>
<td>
<p>Not yet used</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(survival)
library(ggplot2)
set.seed(10)
d=sampleData(100,outcome="survival")
nd=sampleData(100,outcome="survival")
f1=coxph(Surv(time,event)~X1+X6+X8,data=d,x=TRUE,y=TRUE)
f2=coxph(Surv(time,event)~X2+X5+X9,data=d,x=TRUE,y=TRUE)
xx=Score(list(f1,f2), formula=Surv(time,event)~1,
data=nd, metrics="auc", null.model=FALSE, times=seq(3:10))
g &lt;- autoplot(xx)
print(g)
aucgraph &lt;- plotAUC(xx)
plotAUC(xx,conf.int=TRUE)
plotAUC(xx,which="contrasts")
plotAUC(xx,which="contrasts",conf.int=TRUE)


</code></pre>

<hr>
<h2 id='baseHaz_cpp'>C++ Fast Baseline Hazard Estimation</h2><span id='topic+baseHaz_cpp'></span>

<h3>Description</h3>

<p>C++ function to estimate the baseline hazard from a Cox Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>baseHaz_cpp(
  starttimes,
  stoptimes,
  status,
  eXb,
  strata,
  predtimes,
  emaxtimes,
  nPatients,
  nStrata,
  cause,
  Efron
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="baseHaz_cpp_+3A_starttimes">starttimes</code></td>
<td>
<p>a vector of times (begin at risk period).</p>
</td></tr>
<tr><td><code id="baseHaz_cpp_+3A_stoptimes">stoptimes</code></td>
<td>
<p>a vector of times (end at risk period).</p>
</td></tr>
<tr><td><code id="baseHaz_cpp_+3A_status">status</code></td>
<td>
<p>a vector indicating  censoring or event.</p>
</td></tr>
<tr><td><code id="baseHaz_cpp_+3A_exb">eXb</code></td>
<td>
<p>a numeric vector (exponential of the linear predictor).</p>
</td></tr>
<tr><td><code id="baseHaz_cpp_+3A_strata">strata</code></td>
<td>
<p>a vector of integers (index of the strata for each observation).</p>
</td></tr>
<tr><td><code id="baseHaz_cpp_+3A_predtimes">predtimes</code></td>
<td>
<p>a vector of times (time at which to evaluate the hazard). Must be sorted.</p>
</td></tr>
<tr><td><code id="baseHaz_cpp_+3A_emaxtimes">emaxtimes</code></td>
<td>
<p>another vector of times, one per strata (last observation time in each strata).</p>
</td></tr>
<tr><td><code id="baseHaz_cpp_+3A_npatients">nPatients</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="baseHaz_cpp_+3A_nstrata">nStrata</code></td>
<td>
<p>number of strata</p>
</td></tr>
<tr><td><code id="baseHaz_cpp_+3A_cause">cause</code></td>
<td>
<p>the status value corresponding to event.</p>
</td></tr>
<tr><td><code id="baseHaz_cpp_+3A_efron">Efron</code></td>
<td>
<p>whether Efron or Breslow estimator should be used in presence of ties.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>WARNING stoptimes status eXb and strata must be sorted by strata, stoptimes, and status
</p>

<hr>
<h2 id='boot2pvalue'>Compute the p.value from the distribution under H1</h2><span id='topic+boot2pvalue'></span>

<h3>Description</h3>

<p>Compute the p.value associated with the estimated statistic
using a bootstrap sample of its distribution under H1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot2pvalue(
  x,
  null,
  estimate = NULL,
  alternative = "two.sided",
  FUN.ci = quantileCI,
  tol = .Machine$double.eps^0.5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot2pvalue_+3A_x">x</code></td>
<td>
<p>[numeric vector] a vector of bootstrap estimates of the statistic.</p>
</td></tr>
<tr><td><code id="boot2pvalue_+3A_null">null</code></td>
<td>
<p>[numeric] value of the statistic under the null hypothesis.</p>
</td></tr>
<tr><td><code id="boot2pvalue_+3A_estimate">estimate</code></td>
<td>
<p>[numeric] the estimated statistic.</p>
</td></tr>
<tr><td><code id="boot2pvalue_+3A_alternative">alternative</code></td>
<td>
<p>[character] a character string specifying the alternative hypothesis, must be one of &quot;two.sided&quot; (default), &quot;greater&quot; or &quot;less&quot;.</p>
</td></tr>
<tr><td><code id="boot2pvalue_+3A_fun.ci">FUN.ci</code></td>
<td>
<p>[function] the function used to compute the confidence interval.
Must take <code>x</code>, <code>alternative</code>, <code>conf.level</code> and <code>sign.estimate</code> as arguments
and only return the relevant limit (either upper or lower) of the confidence interval.</p>
</td></tr>
<tr><td><code id="boot2pvalue_+3A_tol">tol</code></td>
<td>
<p>[numeric] the absolute convergence tolerance.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For test statistic close to 0, this function returns 1. <br /> <br />
</p>
<p>For positive test statistic, this function search the quantile alpha such that:
</p>

<ul>
<li> <p><code>quantile(x, probs = alpha)=0</code> when the argument alternative is set to <code>"greater"</code>.
</p>
</li>
<li> <p><code>quantile(x, probs = 0.5*alpha)=0</code> when the argument alternative is set to <code>"two.sided"</code>.
</p>
</li></ul>

<p>If the argument alternative is set to <code>"less"</code>, it returns 1. <br /> <br />
</p>
<p>For negative test statistic, this function search the quantile alpha such that:
</p>

<ul>
<li> <p><code>quantile(x, probs = 1-alpha=0</code> when the argument alternative is set to <code>"less"</code>.
</p>
</li>
<li> <p><code>quantile(x, probs = 1-0.5*alpha=0</code> when the argument alternative is set to <code>"two.sided"</code>.
</p>
</li></ul>

<p>If the argument alternative is set to <code>"greater"</code>, it returns 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(10)

#### no effect ####
x &lt;- rnorm(1e3) 
boot2pvalue(x, null = 0, estimate = mean(x), alternative = "two.sided")
## expected value of 1
boot2pvalue(x, null = 0, estimate = mean(x), alternative = "greater")
## expected value of 0.5
boot2pvalue(x, null = 0, estimate = mean(x), alternative = "less")
## expected value of 0.5

#### positive effect ####
x &lt;- rnorm(1e3, mean = 1) 
boot2pvalue(x, null = 0, estimate = 1, alternative = "two.sided")
## expected value of 0.32 = 2*pnorm(q = 0, mean = -1) = 2*mean(x&lt;=0)
boot2pvalue(x, null = 0, estimate = 1, alternative = "greater")  
## expected value of 0.16 = pnorm(q = 0, mean = 1) = mean(x&lt;=0)
boot2pvalue(x, null = 0, estimate = 1, alternative = "less")
## expected value of 0.84 = 1-pnorm(q = 0, mean = 1) = mean(x&gt;=0)

#### negative effect ####
x &lt;- rnorm(1e3, mean = -1) 
boot2pvalue(x, null = 0, estimate = -1, alternative = "two.sided") 
## expected value of 0.32 = 2*(1-pnorm(q = 0, mean = -1)) = 2*mean(x&gt;=0)
boot2pvalue(x, null = 0, estimate = -1, alternative = "greater")
## expected value of 0.84 = pnorm(q = 0, mean = -1) = mean(x&lt;=0)
boot2pvalue(x, null = 0, estimate = -1, alternative = "less") # pnorm(q = 0, mean = -1)
## expected value of 0.16 = 1-pnorm(q = 0, mean = -1) = mean(x&gt;=0)
</code></pre>

<hr>
<h2 id='boxplot.Score'>Boxplot risk quantiles</h2><span id='topic+boxplot.Score'></span>

<h3>Description</h3>

<p>Retrospective boxplots of risk quantiles conditional on outcome
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Score'
boxplot(
  x,
  model,
  reference,
  type = "risk",
  timepoint,
  overall = 1L,
  lwd = 3,
  xlim,
  xlab = "",
  main,
  outcome.label,
  outcome.label.offset = 0,
  event.labels,
  refline = (type != "risk"),
  add = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boxplot.Score_+3A_x">x</code></td>
<td>
<p>Score object obtained by calling function <code>Score</code>.</p>
</td></tr>
<tr><td><code id="boxplot.Score_+3A_model">model</code></td>
<td>
<p>Choice of risk prediction model</p>
</td></tr>
<tr><td><code id="boxplot.Score_+3A_reference">reference</code></td>
<td>
<p>Choice of reference risk prediction model for
calculation of risk differences.</p>
</td></tr>
<tr><td><code id="boxplot.Score_+3A_type">type</code></td>
<td>
<p>Either <code>"risk"</code> for predicted risks or
<code>"diff"</code> for differences between predicted risks.</p>
</td></tr>
<tr><td><code id="boxplot.Score_+3A_timepoint">timepoint</code></td>
<td>
<p>time point specifying the prediction horizon</p>
</td></tr>
<tr><td><code id="boxplot.Score_+3A_overall">overall</code></td>
<td>
<p>Logical. Tag to be documented.</p>
</td></tr>
<tr><td><code id="boxplot.Score_+3A_lwd">lwd</code></td>
<td>
<p>line width</p>
</td></tr>
<tr><td><code id="boxplot.Score_+3A_xlim">xlim</code></td>
<td>
<p>x-axis limits</p>
</td></tr>
<tr><td><code id="boxplot.Score_+3A_xlab">xlab</code></td>
<td>
<p>x-axis label</p>
</td></tr>
<tr><td><code id="boxplot.Score_+3A_main">main</code></td>
<td>
<p>title of plot</p>
</td></tr>
<tr><td><code id="boxplot.Score_+3A_outcome.label">outcome.label</code></td>
<td>
<p>Title label for column which shows the outcome
status</p>
</td></tr>
<tr><td><code id="boxplot.Score_+3A_outcome.label.offset">outcome.label.offset</code></td>
<td>
<p>Vertical offset for outcome.label</p>
</td></tr>
<tr><td><code id="boxplot.Score_+3A_event.labels">event.labels</code></td>
<td>
<p>Labels for the different events (causes).</p>
</td></tr>
<tr><td><code id="boxplot.Score_+3A_refline">refline</code></td>
<td>
<p>Logical, for <code>type="diff"</code> only. If <code>TRUE</code>
draw a red vertical line at <code>0</code>.</p>
</td></tr>
<tr><td><code id="boxplot.Score_+3A_add">add</code></td>
<td>
<p>Logical. Tag to be documented.</p>
</td></tr>
<tr><td><code id="boxplot.Score_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># binary outcome
library(data.table)
library(prodlim)
set.seed(10)
db=sampleData(40,outcome="binary")
fitconv=glm(Y~X3+X5,data=db,family=binomial)
fitnew=glm(Y~X1+X3+X5+X6+X7,data=db,family=binomial)
x=Score(list(new=fitnew,conv=fitconv),
        formula=Y~1,contrasts=list(c(2,1)),
               data=db,plots="box",null.model=FALSE)
boxplot(x)

# survival outcome
library(survival)
ds=sampleData(40,outcome="survival")
fit=coxph(Surv(time,event)~X6+X9,data=ds,x=TRUE,y=TRUE)
## Not run:  
scoreobj=Score(list("Cox"=fit),
                formula=Hist(time,event)~1, data=ds,
                metrics=NULL, plots="box",
                times=c(1,5),null.model=FALSE)
boxplot(scoreobj,timepoint=5)
boxplot(scoreobj,timepoint=1)


## End(Not run)

# competing risks outcome
library(survival)
data(Melanoma, package = "riskRegression")
fit = CSC(Hist(time,event,cens.code="censored")~invasion+age+sex,data=Melanoma)
scoreobj=Score(list("CSC"=fit),
               formula=Hist(time,event,cens.code="censored")~1,
               data=Melanoma,plots="box",times=5*365.25,null.model=FALSE)
par(mar=c(4,12,4,4))
boxplot(scoreobj,timepoint=5*365.25)

# more than 2 competing risks
m=lava::lvm(~X1+X2+X3)
lava::distribution(m, "eventtime1") &lt;- lava::coxWeibull.lvm(scale = 1/100)
lava::distribution(m, "eventtime2") &lt;- lava::coxWeibull.lvm(scale = 1/100)
lava::distribution(m, "eventtime3") &lt;- lava::coxWeibull.lvm(scale = 1/100)
lava::distribution(m, "censtime") &lt;- lava::coxWeibull.lvm(scale = 1/100)
lava::regression(m,eventtime2~X3)=1.3
m &lt;- lava::eventTime(m,
time ~ min(eventtime1 = 1, eventtime2 = 2, eventtime3 = 3, censtime = 0), "event")
set.seed(101)
dcr=as.data.table(lava::sim(m,101))
fit = CSC(Hist(time,event)~X1+X2+X3,data=dcr)
scoreobj=Score(list("my model"=fit),
               formula=Hist(time,event)~1,
               data=dcr,plots="box",times=5,null.model=FALSE)
boxplot(scoreobj)


</code></pre>

<hr>
<h2 id='calcSeCox'>Computation of standard errors for predictions</h2><span id='topic+calcSeCox'></span>

<h3>Description</h3>

<p>Compute the standard error associated to the predictions from Cox regression model
using a first order von Mises expansion of the functional (cumulative hazard or survival).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcSeCox(
  object,
  times,
  nTimes,
  type,
  diag,
  Lambda0,
  object.n,
  object.time,
  object.eXb,
  object.strata,
  nStrata,
  new.n,
  new.eXb,
  new.LPdata,
  new.strata,
  new.survival,
  nVar.lp,
  export,
  store.iid
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcSeCox_+3A_object">object</code></td>
<td>
<p>The fitted Cox regression model object either
obtained with <code>coxph</code> (survival package) or <code>cph</code>
(rms package).</p>
</td></tr>
<tr><td><code id="calcSeCox_+3A_times">times</code></td>
<td>
<p>Vector of times at which to return the estimated
hazard/survival.</p>
</td></tr>
<tr><td><code id="calcSeCox_+3A_ntimes">nTimes</code></td>
<td>
<p>the length of the argument <code>times</code>.</p>
</td></tr>
<tr><td><code id="calcSeCox_+3A_type">type</code></td>
<td>
<p>One or several strings that match (either in lower or upper case or mixtures) one
or several of the strings <code>"hazard"</code>,<code>"cumhazard"</code>, <code>"survival"</code>.</p>
</td></tr>
<tr><td><code id="calcSeCox_+3A_diag">diag</code></td>
<td>
<p>[logical] when <code>FALSE</code> the hazard/cumlative hazard/survival for all observations at all times is computed,
otherwise it is only computed for the i-th observation at the i-th time.</p>
</td></tr>
<tr><td><code id="calcSeCox_+3A_lambda0">Lambda0</code></td>
<td>
<p>the baseline hazard estimate returned by <code>BaseHazStrata_cpp</code>.</p>
</td></tr>
<tr><td><code id="calcSeCox_+3A_object.n">object.n</code></td>
<td>
<p>the number of observations in the dataset used to estimate the object.</p>
</td></tr>
<tr><td><code id="calcSeCox_+3A_object.time">object.time</code></td>
<td>
<p>the time to event of the observations used to estimate the object.</p>
</td></tr>
<tr><td><code id="calcSeCox_+3A_object.exb">object.eXb</code></td>
<td>
<p>the exponential of the linear predictor relative to the observations used to estimate the object.</p>
</td></tr>
<tr><td><code id="calcSeCox_+3A_object.strata">object.strata</code></td>
<td>
<p>the strata index of the observations used to estimate the object.</p>
</td></tr>
<tr><td><code id="calcSeCox_+3A_nstrata">nStrata</code></td>
<td>
<p>the number of strata.</p>
</td></tr>
<tr><td><code id="calcSeCox_+3A_new.n">new.n</code></td>
<td>
<p>the number of observations for which the prediction was performed.</p>
</td></tr>
<tr><td><code id="calcSeCox_+3A_new.exb">new.eXb</code></td>
<td>
<p>the linear predictor evaluated for the new observations.</p>
</td></tr>
<tr><td><code id="calcSeCox_+3A_new.lpdata">new.LPdata</code></td>
<td>
<p>the variables involved in the linear predictor for the new observations.</p>
</td></tr>
<tr><td><code id="calcSeCox_+3A_new.strata">new.strata</code></td>
<td>
<p>the strata indicator for the new observations.</p>
</td></tr>
<tr><td><code id="calcSeCox_+3A_new.survival">new.survival</code></td>
<td>
<p>the survival evaluated for the new observations.</p>
</td></tr>
<tr><td><code id="calcSeCox_+3A_nvar.lp">nVar.lp</code></td>
<td>
<p>the number of variables that form the linear predictor.</p>
</td></tr>
<tr><td><code id="calcSeCox_+3A_export">export</code></td>
<td>
<p>can be &quot;iid&quot; to return the value of the influence function for each observation.
&quot;se&quot; to return the standard error for a given timepoint.
&quot;average.iid&quot; to return the value of the average influence function over the observations for which the prediction was performed.</p>
</td></tr>
<tr><td><code id="calcSeCox_+3A_store.iid">store.iid</code></td>
<td>
<p>Implementation used to estimate the influence function and the standard error.
Can be <code>"full"</code> or <code>"minimal"</code>. See the details section.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>store.iid="full"</code> compute the influence function for each observation at each time in the argument <code>times</code>
before computing the standard error / influence functions.
<code>store.iid="minimal"</code> recompute for each subject specific prediction the influence function for the baseline hazard.
This avoid to store all the influence functions but may lead to repeated evaluation of the influence function.
This solution is therefore more efficient in memory usage but may not be in terms of computation time.
</p>


<h3>Value</h3>

<p>A list optionally containing the standard error for the survival, cumulative hazard and hazard.
</p>


<h3>Author(s)</h3>

<p>Brice Ozenne broz@sund.ku.dk, Thomas A. Gerds tag@biostat.ku.dk
</p>

<hr>
<h2 id='calcSeCSC'>Standard error of the absolute risk predicted from cause-specific Cox models</h2><span id='topic+calcSeCSC'></span>

<h3>Description</h3>

<p>Standard error of the absolute risk predicted from cause-specific Cox models
using a first order von Mises expansion of the absolute risk functional.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcSeCSC(
  object,
  cif,
  hazard,
  cumhazard,
  survival,
  object.time,
  object.maxtime,
  eXb,
  new.LPdata,
  new.strata,
  times,
  surv.type,
  ls.infoVar,
  new.n,
  cause,
  nCause,
  nVar.lp,
  export,
  store.iid,
  diag
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcSeCSC_+3A_object">object</code></td>
<td>
<p>The fitted cause specific Cox model</p>
</td></tr>
<tr><td><code id="calcSeCSC_+3A_cif">cif</code></td>
<td>
<p>the cumulative incidence function at each prediction time for each individual.</p>
</td></tr>
<tr><td><code id="calcSeCSC_+3A_hazard">hazard</code></td>
<td>
<p>list containing the baseline hazard for each cause in a matrix form. Columns correspond to the strata.</p>
</td></tr>
<tr><td><code id="calcSeCSC_+3A_cumhazard">cumhazard</code></td>
<td>
<p>list containing the cumulative baseline hazard for each cause in a matrix form. Columns correspond to the strata.</p>
</td></tr>
<tr><td><code id="calcSeCSC_+3A_survival">survival</code></td>
<td>
<p>list containing the (all cause) survival in a matrix form at t-. Columns correspond to event times.</p>
</td></tr>
<tr><td><code id="calcSeCSC_+3A_object.time">object.time</code></td>
<td>
<p>a vector containing all the events regardless to the cause.</p>
</td></tr>
<tr><td><code id="calcSeCSC_+3A_object.maxtime">object.maxtime</code></td>
<td>
<p>a matrix containing the latest event in the strata of the observation for each cause.</p>
</td></tr>
<tr><td><code id="calcSeCSC_+3A_exb">eXb</code></td>
<td>
<p>a matrix containing the exponential of the linear predictor evaluated for the new observations (rows) for each cause (columns)</p>
</td></tr>
<tr><td><code id="calcSeCSC_+3A_new.lpdata">new.LPdata</code></td>
<td>
<p>a list of design matrices for the new observations for each cause.</p>
</td></tr>
<tr><td><code id="calcSeCSC_+3A_new.strata">new.strata</code></td>
<td>
<p>a matrix containing the strata indicator for each observation and each cause.</p>
</td></tr>
<tr><td><code id="calcSeCSC_+3A_times">times</code></td>
<td>
<p>the time points at which to evaluate the predictions.</p>
</td></tr>
<tr><td><code id="calcSeCSC_+3A_surv.type">surv.type</code></td>
<td>
<p>see the surv.type argument of <code><a href="#topic+CSC">CSC</a></code>.</p>
</td></tr>
<tr><td><code id="calcSeCSC_+3A_ls.infovar">ls.infoVar</code></td>
<td>
<p>A list containing the output of <code>coxVariableName</code> for each Cox model.</p>
</td></tr>
<tr><td><code id="calcSeCSC_+3A_new.n">new.n</code></td>
<td>
<p>the number of new observations.</p>
</td></tr>
<tr><td><code id="calcSeCSC_+3A_cause">cause</code></td>
<td>
<p>the cause of interest.</p>
</td></tr>
<tr><td><code id="calcSeCSC_+3A_ncause">nCause</code></td>
<td>
<p>the number of causes.</p>
</td></tr>
<tr><td><code id="calcSeCSC_+3A_nvar.lp">nVar.lp</code></td>
<td>
<p>the number of variables that form the linear predictor in each Cox model</p>
</td></tr>
<tr><td><code id="calcSeCSC_+3A_export">export</code></td>
<td>
<p>can be &quot;iid&quot; to return the value of the influence function for each observation
&quot;se&quot; to return the standard error for a given timepoint</p>
</td></tr>
<tr><td><code id="calcSeCSC_+3A_store.iid">store.iid</code></td>
<td>
<p>the method used to compute the influence function and the standard error.
Can be <code>"full"</code> or <code>"minimal"</code>. See the details section.</p>
</td></tr>
<tr><td><code id="calcSeCSC_+3A_diag">diag</code></td>
<td>
<p>[logical] when <code>FALSE</code> the absolute risk/survival for all observations at all times is computed,
otherwise it is only computed for the i-th observation at the i-th time.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Can also return the empirical influence function of the functionals cumulative hazard or survival
or the sum over the observations of the empirical influence function.
</p>
<p><code>store.iid="full"</code> compute the influence function for each observation at each time in the argument <code>times</code>
before computing the standard error / influence functions.
<code>store.iid="minimal"</code> recompute for each subject specific prediction the influence function for the baseline hazard.
This avoid to store all the influence functions but may lead to repeated evaluation of the influence function.
This solution is therefore efficient more efficient in memory usage but may not be in term of computation time.
</p>

<hr>
<h2 id='Cforest'>S3-wrapper function for cforest from the party package</h2><span id='topic+Cforest'></span>

<h3>Description</h3>

<p>S3-wrapper function for cforest from the party package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Cforest(formula, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Cforest_+3A_formula">formula</code></td>
<td>
<p>Passed on as is. See <code>cforest</code> of the <code>party</code> package</p>
</td></tr>
<tr><td><code id="Cforest_+3A_data">data</code></td>
<td>
<p>Passed on as is. See <code>cforest</code> of the <code>party</code> package</p>
</td></tr>
<tr><td><code id="Cforest_+3A_...">...</code></td>
<td>
<p>Passed on as they are. See <code>cforest</code> of the <code>party</code> package</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code>cforest</code> of the <code>party</code> package.
</p>


<h3>Value</h3>

<p>list with two elements: cforest and call
</p>


<h3>References</h3>

<p>Ulla B. Mogensen, Hemant Ishwaran, Thomas A. Gerds (2012).
Evaluating Random Forests for Survival Analysis Using Prediction Error
Curves. Journal of Statistical Software, 50(11), 1-23. URL
http://www.jstatsoft.org/v50/i11/.
</p>

<hr>
<h2 id='coef.CauseSpecificCox'>Extract coefficients from a Cause-Specific Cox regression model</h2><span id='topic+coef.CauseSpecificCox'></span>

<h3>Description</h3>

<p>Extract coefficients from a Cause-Specific Cox regression model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CauseSpecificCox'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.CauseSpecificCox_+3A_object">object</code></td>
<td>
<p>Object obtained with CSC</p>
</td></tr>
<tr><td><code id="coef.CauseSpecificCox_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>

<hr>
<h2 id='coef.riskRegression'>Extract coefficients from riskRegression model</h2><span id='topic+coef.riskRegression'></span>

<h3>Description</h3>

<p>Extract coefficients from riskRegression model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'riskRegression'
coef(object, digits = 3, eps = 10^-4, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.riskRegression_+3A_object">object</code></td>
<td>
<p>Object obtained with <code>ARR</code> or <code>LRR</code> or <code>riskRegression</code></p>
</td></tr>
<tr><td><code id="coef.riskRegression_+3A_digits">digits</code></td>
<td>
<p>Number of digits</p>
</td></tr>
<tr><td><code id="coef.riskRegression_+3A_eps">eps</code></td>
<td>
<p>P-values below this number are shown as <code>&lt;eps</code></p>
</td></tr>
<tr><td><code id="coef.riskRegression_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>

<hr>
<h2 id='colCenter_cpp'>Apply - by column</h2><span id='topic+colCenter_cpp'></span>

<h3>Description</h3>

<p>Fast computation of sweep(X, MARGIN = 1, FUN = &quot;-&quot;, STATS = center)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colCenter_cpp(X, center)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colCenter_cpp_+3A_x">X</code></td>
<td>
<p>A matrix.</p>
</td></tr>
<tr><td><code id="colCenter_cpp_+3A_center">center</code></td>
<td>
<p>a numeric vector of length equal to the number of rows of <code>x</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of same size as X.
</p>


<h3>Author(s)</h3>

<p>Brice Ozenne &lt;broz@sund.ku.dk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(1,6,5)
sweep(x, MARGIN = 1, FUN = "-", STATS = 1:6)
colCenter_cpp(x, 1:6 )
</code></pre>

<hr>
<h2 id='colCumSum'>Apply cumsum in each column</h2><span id='topic+colCumSum'></span>

<h3>Description</h3>

<p>Fast computation of apply(x,2,cumsum)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colCumSum(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colCumSum_+3A_x">x</code></td>
<td>
<p>A matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of same size as x.
</p>


<h3>Author(s)</h3>

<p>Thomas Alexander Gerds &lt;tag@biostat.ku.dk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(1:8,ncol=2)
colCumSum(x)
</code></pre>

<hr>
<h2 id='colMultiply_cpp'>Apply * by column</h2><span id='topic+colMultiply_cpp'></span>

<h3>Description</h3>

<p>Fast computation of sweep(X, MARGIN = 1, FUN = &quot;*&quot;, STATS = scale)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colMultiply_cpp(X, scale)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colMultiply_cpp_+3A_x">X</code></td>
<td>
<p>A matrix.</p>
</td></tr>
<tr><td><code id="colMultiply_cpp_+3A_scale">scale</code></td>
<td>
<p>a numeric vector of length equal to the number of rows of <code>x</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of same size as X.
</p>


<h3>Author(s)</h3>

<p>Brice Ozenne &lt;broz@sund.ku.dk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(1,6,5)
sweep(x, MARGIN = 1, FUN = "*", STATS = 1:6)
colMultiply_cpp(x, 1:6 )
</code></pre>

<hr>
<h2 id='colScale_cpp'>Apply / by column</h2><span id='topic+colScale_cpp'></span>

<h3>Description</h3>

<p>Fast computation of sweep(X, MARGIN = 1, FUN = &quot;/&quot;, STATS = scale)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colScale_cpp(X, scale)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colScale_cpp_+3A_x">X</code></td>
<td>
<p>A matrix.</p>
</td></tr>
<tr><td><code id="colScale_cpp_+3A_scale">scale</code></td>
<td>
<p>a numeric vector of length equal to the number of rows of <code>x</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of same size as X.
</p>


<h3>Author(s)</h3>

<p>Brice Ozenne &lt;broz@sund.ku.dk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(1,6,5)
sweep(x, MARGIN = 1, FUN = "/", STATS = 1:6)
colScale_cpp(x, 1:6 )
</code></pre>

<hr>
<h2 id='confint.ate'>Confidence Intervals and Confidence Bands for the Predicted Absolute Risk (Cumulative Incidence Function)</h2><span id='topic+confint.ate'></span>

<h3>Description</h3>

<p>Confidence intervals and confidence Bands for the predicted absolute risk (cumulative incidence function).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ate'
confint(
  object,
  parm = NULL,
  level = 0.95,
  n.sim = 10000,
  estimator = object$estimator,
  contrasts = object$contrasts,
  allContrasts = object$allContrasts,
  meanRisk.transform = "none",
  diffRisk.transform = "none",
  ratioRisk.transform = "none",
  seed = NA,
  ci = object$inference$se,
  band = object$inference$band,
  p.value = TRUE,
  method.band = "maxT-simulation",
  alternative = "two.sided",
  bootci.method = "perc",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint.ate_+3A_object">object</code></td>
<td>
<p>A <code>ate</code> object, i.e. output of the <code>ate</code> function.</p>
</td></tr>
<tr><td><code id="confint.ate_+3A_parm">parm</code></td>
<td>
<p>not used. For compatibility with the generic method.</p>
</td></tr>
<tr><td><code id="confint.ate_+3A_level">level</code></td>
<td>
<p>[numeric, 0-1] Level of confidence.</p>
</td></tr>
<tr><td><code id="confint.ate_+3A_n.sim">n.sim</code></td>
<td>
<p>[integer, &gt;0] the number of simulations used to compute the quantiles for the confidence bands and/or perform adjustment for multiple comparisons.</p>
</td></tr>
<tr><td><code id="confint.ate_+3A_estimator">estimator</code></td>
<td>
<p>[character] The type of estimator relative to which the estimates should be displayed.</p>
</td></tr>
<tr><td><code id="confint.ate_+3A_contrasts">contrasts</code></td>
<td>
<p>[character vector] levels of the treatment variable for which the risks should be assessed and compared. Default is to consider all levels.</p>
</td></tr>
<tr><td><code id="confint.ate_+3A_allcontrasts">allContrasts</code></td>
<td>
<p>[2-row character matrix] levels of the treatment variable to be compared. Default is to consider all pairwise comparisons.</p>
</td></tr>
<tr><td><code id="confint.ate_+3A_meanrisk.transform">meanRisk.transform</code></td>
<td>
<p>[character] the transformation used to improve coverage
of the confidence intervals for the mean risk in small samples.
Can be <code>"none"</code>, <code>"log"</code>, <code>"loglog"</code>, <code>"cloglog"</code>.</p>
</td></tr>
<tr><td><code id="confint.ate_+3A_diffrisk.transform">diffRisk.transform</code></td>
<td>
<p>[character] the transformation used to improve coverage
of the confidence intervals for the risk difference in small samples.
Can be <code>"none"</code>, <code>"atanh"</code>.</p>
</td></tr>
<tr><td><code id="confint.ate_+3A_ratiorisk.transform">ratioRisk.transform</code></td>
<td>
<p>[character] the transformation used to improve coverage
of the confidence intervals for the risk ratio in small samples.
Can be <code>"none"</code>, <code>"log"</code>.</p>
</td></tr>
<tr><td><code id="confint.ate_+3A_seed">seed</code></td>
<td>
<p>[integer, &gt;0] seed number set when performing simulation for the confidence bands.
If not given or NA no seed is set.</p>
</td></tr>
<tr><td><code id="confint.ate_+3A_ci">ci</code></td>
<td>
<p>[logical] should the confidence intervals be computed?</p>
</td></tr>
<tr><td><code id="confint.ate_+3A_band">band</code></td>
<td>
<p>[logical] should the confidence bands be computed?</p>
</td></tr>
<tr><td><code id="confint.ate_+3A_p.value">p.value</code></td>
<td>
<p>[logical] should the p-values/adjusted p-values be computed?
Requires argument <code>ci</code> and/or <code>band</code> to be <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="confint.ate_+3A_method.band">method.band</code></td>
<td>
<p>[character] method used to adjust for multiple comparisons.
Can be any element of <code>p.adjust.methods</code> (e.g. <code>"holm"</code>), <code>"maxT-integration"</code>, or <code>"maxT-simulation"</code>.</p>
</td></tr>
<tr><td><code id="confint.ate_+3A_alternative">alternative</code></td>
<td>
<p>[character] a character string specifying the alternative hypothesis,
must be one of <code>"two.sided"</code> (default), <code>"greater"</code> or <code>"less"</code>.</p>
</td></tr>
<tr><td><code id="confint.ate_+3A_bootci.method">bootci.method</code></td>
<td>
<p>[character] Method for constructing bootstrap confidence intervals.
Either &quot;perc&quot; (the default), &quot;norm&quot;, &quot;basic&quot;, &quot;stud&quot;, or &quot;bca&quot;.</p>
</td></tr>
<tr><td><code id="confint.ate_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Argument <code>ci</code>, <code>band</code>, <code>p.value</code>, <code>method.band</code>, <code>alternative</code>, <code>meanRisk.transform</code>, <code>diffRisk.transform</code>, <code>ratioRisk.transform</code> are only active when the <code>ate</code> object contains the influence function.
Argument <code>bootci.method</code> is only active when the <code>ate</code> object contains bootstrap samples.
</p>
<p><strong>Influence function</strong>: confidence bands and confidence intervals computed via the influence function are automatically restricted to the interval of definition of the parameter (e.g. [0;1] for the average risk).
Single step max adjustment for multiple comparisons, i.e. accounting for the correlation between the test statistics but not for the ordering of the tests, can be performed setting the arguemnt <code>method.band</code> to <code>"maxT-integration"</code> or <code>"maxT-simulation"</code>. The former uses numerical integration (<code>pmvnorm</code> and <code>qmvnorm</code> to perform the adjustment while the latter using simulation. Both assume that the test statistics are jointly normally distributed.
</p>
<p><strong>Bootstrap</strong>: confidence intervals obtained via bootstrap are computed
using the <code>boot.ci</code> function of the <code>boot</code> package.
p-value are obtained using test inversion method
(finding the smallest confidence level such that the interval contain the null hypothesis).
</p>


<h3>Author(s)</h3>

<p>Brice Ozenne
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(survival)
library(data.table)

## ## generate data ####
set.seed(10)
d &lt;- sampleData(70,outcome="survival")
d[, X1 := paste0("T",rbinom(.N, size = 2, prob = c(0.51)))]
## table(d$X1)

#### stratified Cox model ####
fit &lt;- coxph(Surv(time,event)~X1 + strata(X2) + X6,
             data=d, ties="breslow", x = TRUE, y = TRUE)

#### average treatment effect ####
fit.ate &lt;- ate(fit, treatment = "X1", times = 1:3, data = d,
               se = TRUE, iid = TRUE, band = TRUE)
summary(fit.ate)
dt.ate &lt;- as.data.table(fit.ate)

## manual calculation of se
dd &lt;- copy(d)
dd$X1 &lt;- rep(factor("T0", levels = paste0("T",0:2)), NROW(dd))
out &lt;- predictCox(fit, newdata = dd, se = TRUE, times = 1:3, average.iid = TRUE)
term1 &lt;- -out$survival.average.iid
term2 &lt;- sweep(1-out$survival, MARGIN = 2, FUN = "-", STATS = colMeans(1-out$survival))
sqrt(colSums((term1 + term2/NROW(d))^2)) 
## fit.ate$meanRisk[treatment=="T0",se]

## note
out2 &lt;- predictCox(fit, newdata = dd, se = TRUE, times = 1:3, iid = TRUE)
mean(out2$survival.iid[1,1,])
out$survival.average.iid[1,1]

## check confidence intervals (no transformation)
dt.ate[,.(lower = pmax(0,estimate + qnorm(0.025) * se),
          lower2 = lower,
          upper = estimate + qnorm(0.975) * se,
          upper2 = upper)]

## add confidence intervals computed on the log-log scale
## and backtransformed
outCI &lt;- confint(fit.ate,
                 meanRisk.transform = "loglog", diffRisk.transform = "atanh",
                 ratioRisk.transform = "log")
summary(outCI, type = "risk", short = TRUE)

dt.ate[type == "meanRisk", newse := se/(estimate*log(estimate))]
dt.ate[type == "meanRisk", .(lower = exp(-exp(log(-log(estimate)) - 1.96 * newse)),
                        upper = exp(-exp(log(-log(estimate)) + 1.96 * newse)))]
</code></pre>

<hr>
<h2 id='confint.influenceTest'>Confidence Intervals and Confidence Bands for the Difference Between Two Estimates</h2><span id='topic+confint.influenceTest'></span>

<h3>Description</h3>

<p>Confidence intervals and confidence Bands for the difference between two estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'influenceTest'
confint(
  object,
  parm = NULL,
  level = 0.95,
  n.sim = 10000,
  transform = "none",
  seed = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint.influenceTest_+3A_object">object</code></td>
<td>
<p>A <code>influenceTest</code> object, i.e. output of the <code>influenceTest</code> function.</p>
</td></tr>
<tr><td><code id="confint.influenceTest_+3A_parm">parm</code></td>
<td>
<p>not used. For compatibility with the generic method.</p>
</td></tr>
<tr><td><code id="confint.influenceTest_+3A_level">level</code></td>
<td>
<p>[numeric, 0-1] Level of confidence.</p>
</td></tr>
<tr><td><code id="confint.influenceTest_+3A_n.sim">n.sim</code></td>
<td>
<p>[integer, &gt;0] the number of simulations used to compute the quantiles for the confidence bands.</p>
</td></tr>
<tr><td><code id="confint.influenceTest_+3A_transform">transform</code></td>
<td>
<p>[character] the transformation used to improve coverage of the confidence intervals.
Can be <code>"none"</code> or <code>"atanh"</code>.</p>
</td></tr>
<tr><td><code id="confint.influenceTest_+3A_seed">seed</code></td>
<td>
<p>[integer, &gt;0] seed number set before performing simulations for the confidence bands.
If not given or NA no seed is set.</p>
</td></tr>
<tr><td><code id="confint.influenceTest_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Except for the cumulative hazard,
the confidence bands and confidence intervals are automatically restricted to the interval [-1;1].
</p>


<h3>Author(s)</h3>

<p>Brice Ozenne
</p>

<hr>
<h2 id='confint.predictCox'>Confidence Intervals and Confidence Bands for the predicted Survival/Cumulative Hazard</h2><span id='topic+confint.predictCox'></span>

<h3>Description</h3>

<p>Confidence intervals and confidence Bands for the predicted survival/cumulative Hazard.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'predictCox'
confint(
  object,
  parm = NULL,
  level = 0.95,
  n.sim = 10000,
  cumhazard.transform = "log",
  survival.transform = "loglog",
  seed = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint.predictCox_+3A_object">object</code></td>
<td>
<p>A <code>predictCox</code> object, i.e. output of the <code>predictCox</code> function.</p>
</td></tr>
<tr><td><code id="confint.predictCox_+3A_parm">parm</code></td>
<td>
<p>[character] the type of predicted value for which the confidence intervals should be output.
Can be <code>"survival"</code> or <code>"cumhazard"</code>.</p>
</td></tr>
<tr><td><code id="confint.predictCox_+3A_level">level</code></td>
<td>
<p>[numeric, 0-1] Level of confidence.</p>
</td></tr>
<tr><td><code id="confint.predictCox_+3A_n.sim">n.sim</code></td>
<td>
<p>[integer, &gt;0] the number of simulations used to compute the quantiles for the confidence bands.</p>
</td></tr>
<tr><td><code id="confint.predictCox_+3A_cumhazard.transform">cumhazard.transform</code></td>
<td>
<p>[character] the transformation used to improve coverage
of the confidence intervals for the cumlative hazard in small samples.
Can be <code>"none"</code>, <code>"log"</code>.</p>
</td></tr>
<tr><td><code id="confint.predictCox_+3A_survival.transform">survival.transform</code></td>
<td>
<p>[character] the transformation used to improve coverage
of the confidence intervals for the survival in small samples.
Can be <code>"none"</code>, <code>"log"</code>, <code>"loglog"</code>, <code>"cloglog"</code>.</p>
</td></tr>
<tr><td><code id="confint.predictCox_+3A_seed">seed</code></td>
<td>
<p>[integer, &gt;0] seed number set before performing simulations for the confidence bands.
If not given or NA no seed is set.</p>
</td></tr>
<tr><td><code id="confint.predictCox_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The confidence bands and confidence intervals are automatically restricted to the interval of definition of the statistic,
i.e. a confidence interval for the survival of [0.5;1.2] will become [0.5;1].
</p>


<h3>Author(s)</h3>

<p>Brice Ozenne
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(survival)

#### generate data ####
set.seed(10)
d &lt;- sampleData(40,outcome="survival") 

#### estimate a stratified Cox model ####
fit &lt;- coxph(Surv(time,event)~X1 + strata(X2) + X6,
             data=d, ties="breslow", x = TRUE, y = TRUE)

#### compute individual specific survival probabilities  
fit.pred &lt;- predictCox(fit, newdata=d[1:3], times=c(3,8), type = "survival",
                       se = TRUE, iid = TRUE, band = TRUE)
fit.pred

## check standard error
sqrt(rowSums(fit.pred$survival.iid[,,1]^2)) ## se for individual 1

## check confidence interval
newse &lt;- fit.pred$survival.se/(-fit.pred$survival*log(fit.pred$survival))
cbind(lower = as.double(exp(-exp(log(-log(fit.pred$survival)) + 1.96 * newse))),
      upper = as.double(exp(-exp(log(-log(fit.pred$survival)) - 1.96 * newse)))
)

#### compute confidence intervals without transformation
confint(fit.pred, survival.transform = "none")
cbind(lower = as.double(fit.pred$survival - 1.96 * fit.pred$survival.se),
      upper = as.double(fit.pred$survival + 1.96 * fit.pred$survival.se)
)

</code></pre>

<hr>
<h2 id='confint.predictCSC'>Confidence Intervals and Confidence Bands for the Predicted Absolute Risk (Cumulative Incidence Function)</h2><span id='topic+confint.predictCSC'></span>

<h3>Description</h3>

<p>Confidence intervals and confidence Bands for the predicted absolute risk (cumulative incidence function).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'predictCSC'
confint(
  object,
  parm = NULL,
  level = 0.95,
  n.sim = 10000,
  absRisk.transform = "loglog",
  seed = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint.predictCSC_+3A_object">object</code></td>
<td>
<p>A <code>predictCSC</code> object, i.e. output of the <code>predictCSC</code> function.</p>
</td></tr>
<tr><td><code id="confint.predictCSC_+3A_parm">parm</code></td>
<td>
<p>not used. For compatibility with the generic method.</p>
</td></tr>
<tr><td><code id="confint.predictCSC_+3A_level">level</code></td>
<td>
<p>[numeric, 0-1] Level of confidence.</p>
</td></tr>
<tr><td><code id="confint.predictCSC_+3A_n.sim">n.sim</code></td>
<td>
<p>[integer, &gt;0] the number of simulations used to compute the quantiles for the confidence bands.</p>
</td></tr>
<tr><td><code id="confint.predictCSC_+3A_absrisk.transform">absRisk.transform</code></td>
<td>
<p>[character] the transformation used to improve coverage
of the confidence intervals for the predicted absolute risk in small samples.
Can be <code>"none"</code>, <code>"log"</code>, <code>"loglog"</code>, <code>"cloglog"</code>.</p>
</td></tr>
<tr><td><code id="confint.predictCSC_+3A_seed">seed</code></td>
<td>
<p>[integer, &gt;0] seed number set before performing simulations for the confidence bands.
If not given or NA no seed is set.</p>
</td></tr>
<tr><td><code id="confint.predictCSC_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The confidence bands and confidence intervals are automatically restricted to the interval [0;1].
</p>


<h3>Author(s)</h3>

<p>Brice Ozenne
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(survival)
library(prodlim)
#### generate data ####
set.seed(10)
d &lt;- sampleData(100) 

#### estimate a stratified CSC model ###
fit &lt;- CSC(Hist(time,event)~ X1 + strata(X2) + X6, data=d)

#### compute individual specific risks
fit.pred &lt;- predict(fit, newdata=d[1:3], times=c(3,8), cause = 1,
                    se = TRUE, iid = TRUE, band = TRUE)
fit.pred

## check confidence intervals
newse &lt;- fit.pred$absRisk.se/(-fit.pred$absRisk*log(fit.pred$absRisk))
cbind(lower = as.double(exp(-exp(log(-log(fit.pred$absRisk)) + 1.96 * newse))),
      upper = as.double(exp(-exp(log(-log(fit.pred$absRisk)) - 1.96 * newse)))
)

#### compute confidence intervals without transformation
confint(fit.pred, absRisk.transform = "none")
cbind(lower = as.double(fit.pred$absRisk - 1.96 * fit.pred$absRisk.se),
      upper = as.double(fit.pred$absRisk + 1.96 * fit.pred$absRisk.se)
)


</code></pre>

<hr>
<h2 id='coxBaseEstimator'>Extract the type of estimator for the baseline hazard</h2><span id='topic+coxBaseEstimator'></span><span id='topic+coxBaseEstimator.coxph'></span><span id='topic+coxBaseEstimator.phreg'></span>

<h3>Description</h3>

<p>Extract the type of estimator for the baseline hazard
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coxBaseEstimator(object)

## S3 method for class 'coxph'
coxBaseEstimator(object)

## S3 method for class 'phreg'
coxBaseEstimator(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coxBaseEstimator_+3A_object">object</code></td>
<td>
<p>The fitted Cox regression model object either
obtained with <code>coxph</code> (survival package), <code>cph</code>
(rms package), or <code>phreg</code> (mets package).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Brice Ozenne broz@sund.ku.dk
</p>

<hr>
<h2 id='coxCenter'>Extract the mean value of the covariates</h2><span id='topic+coxCenter'></span><span id='topic+coxCenter.cph'></span><span id='topic+coxCenter.coxph'></span><span id='topic+coxCenter.phreg'></span>

<h3>Description</h3>

<p>Extract the mean value of the covariates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coxCenter(object)

## S3 method for class 'cph'
coxCenter(object)

## S3 method for class 'coxph'
coxCenter(object)

## S3 method for class 'phreg'
coxCenter(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coxCenter_+3A_object">object</code></td>
<td>
<p>The fitted Cox regression model object either
obtained with <code>coxph</code> (survival package), <code>cph</code>
(rms package), or <code>phreg</code> (mets package).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Brice Ozenne broz@sund.ku.dk
</p>

<hr>
<h2 id='coxFormula'>Extract the formula from a Cox model</h2><span id='topic+coxFormula'></span><span id='topic+coxFormula.cph'></span><span id='topic+coxFormula.coxph'></span><span id='topic+coxFormula.phreg'></span><span id='topic+coxFormula.glm'></span>

<h3>Description</h3>

<p>Extract the formula from a Cox model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coxFormula(object)

## S3 method for class 'cph'
coxFormula(object)

## S3 method for class 'coxph'
coxFormula(object)

## S3 method for class 'phreg'
coxFormula(object)

## S3 method for class 'glm'
coxFormula(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coxFormula_+3A_object">object</code></td>
<td>
<p>The fitted Cox regression model object either
obtained with <code>coxph</code> (survival package), <code>cph</code>
(rms package), or <code>phreg</code> (mets package).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Brice Ozenne broz@sund.ku.dk
</p>

<hr>
<h2 id='coxLP'>Compute the linear predictor of a Cox model</h2><span id='topic+coxLP'></span><span id='topic+coxLP.cph'></span><span id='topic+coxLP.coxph'></span><span id='topic+coxLP.phreg'></span>

<h3>Description</h3>

<p>Compute the linear predictor of a Cox model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coxLP(object, data, center)

## S3 method for class 'cph'
coxLP(object, data, center)

## S3 method for class 'coxph'
coxLP(object, data, center)

## S3 method for class 'phreg'
coxLP(object, data, center)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coxLP_+3A_object">object</code></td>
<td>
<p>The fitted Cox regression model object either
obtained with <code>coxph</code> (survival package), <code>cph</code>
(rms package), or <code>phreg</code> (mets package).</p>
</td></tr>
<tr><td><code id="coxLP_+3A_data">data</code></td>
<td>
<p>a <code>data.frame</code> or a <code>data.table</code></p>
</td></tr>
<tr><td><code id="coxLP_+3A_center">center</code></td>
<td>
<p>should the linear predictor be computed after centering the covariates</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In case of empty linear predictor returns a vector of 0 with the same length as the number of rows of the dataset
</p>


<h3>Author(s)</h3>

<p>Brice Ozenne broz@sund.ku.dk
</p>

<hr>
<h2 id='coxModelFrame'>Extract the design matrix used to train a Cox model</h2><span id='topic+coxModelFrame'></span><span id='topic+coxModelFrame.coxph'></span><span id='topic+coxModelFrame.cph'></span><span id='topic+coxModelFrame.phreg'></span>

<h3>Description</h3>

<p>Extract the design matrix used to train a Cox model. Should contain the time of event, the type of event, 
the variable for the linear predictor, the strata variables and the date of entry (in case of delayed entry).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coxModelFrame(object, center)

## S3 method for class 'coxph'
coxModelFrame(object, center = FALSE)

## S3 method for class 'cph'
coxModelFrame(object, center = FALSE)

## S3 method for class 'phreg'
coxModelFrame(object, center = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coxModelFrame_+3A_object">object</code></td>
<td>
<p>The fitted Cox regression model object either
obtained with <code>coxph</code> (survival package), <code>cph</code>
(rms package), or <code>phreg</code> (mets package).</p>
</td></tr>
<tr><td><code id="coxModelFrame_+3A_center">center</code></td>
<td>
<p>[logical] Should the variables of the linear predictor be added ?</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Brice Ozenne broz@sund.ku.dk
</p>

<hr>
<h2 id='coxN'>Extract the number of observations from a Cox model</h2><span id='topic+coxN'></span><span id='topic+coxN.cph'></span><span id='topic+coxN.coxph'></span><span id='topic+coxN.phreg'></span><span id='topic+coxN.CauseSpecificCox'></span><span id='topic+coxN.glm'></span>

<h3>Description</h3>

<p>Extract the number of observations from a Cox model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coxN(object)

## S3 method for class 'cph'
coxN(object)

## S3 method for class 'coxph'
coxN(object)

## S3 method for class 'phreg'
coxN(object)

## S3 method for class 'CauseSpecificCox'
coxN(object)

## S3 method for class 'glm'
coxN(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coxN_+3A_object">object</code></td>
<td>
<p>The fitted Cox regression model object either
obtained with <code>coxph</code> (survival package), <code>cph</code>
(rms package), or <code>phreg</code> (mets package).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Brice Ozenne broz@sund.ku.dk
</p>

<hr>
<h2 id='coxSpecial'>Special characters in Cox model</h2><span id='topic+coxSpecial'></span><span id='topic+coxSpecial.coxph'></span><span id='topic+coxSpecial.cph'></span><span id='topic+coxSpecial.phreg'></span>

<h3>Description</h3>

<p>Return the special character(s) of the Cox model, e.g. used to indicate the strata variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coxSpecial(object)

## S3 method for class 'coxph'
coxSpecial(object)

## S3 method for class 'cph'
coxSpecial(object)

## S3 method for class 'phreg'
coxSpecial(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coxSpecial_+3A_object">object</code></td>
<td>
<p>The fitted Cox regression model object either
obtained with <code>coxph</code> (survival package), <code>cph</code>
(rms package), or <code>phreg</code> (mets package).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Must return a list with at least one element strata
indicating the character in the formula marking the variable(s) defining the strata.
</p>


<h3>Author(s)</h3>

<p>Brice Ozenne broz@sund.ku.dk
</p>

<hr>
<h2 id='coxStrata'>Define the strata for a new dataset</h2><span id='topic+coxStrata'></span><span id='topic+coxStrata.cph'></span><span id='topic+coxStrata.coxph'></span><span id='topic+coxStrata.phreg'></span>

<h3>Description</h3>

<p>Define the strata in a dataset to match those of a stratified Cox model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coxStrata(object, data, sterms, strata.vars, strata.levels)

## S3 method for class 'cph'
coxStrata(object, data, sterms, strata.vars, strata.levels)

## S3 method for class 'coxph'
coxStrata(object, data, sterms, strata.vars, strata.levels)

## S3 method for class 'phreg'
coxStrata(object, data, sterms, strata.vars, strata.levels)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coxStrata_+3A_object">object</code></td>
<td>
<p>The fitted Cox regression model object either
obtained with <code>coxph</code> (survival package), <code>cph</code>
(rms package), or <code>phreg</code> (mets package).</p>
</td></tr>
<tr><td><code id="coxStrata_+3A_data">data</code></td>
<td>
<p>a <code>data.frame</code> or a <code>data.table</code></p>
</td></tr>
<tr><td><code id="coxStrata_+3A_sterms">sterms</code></td>
<td>
<p>terms in the formula corresponding to the strata variables</p>
</td></tr>
<tr><td><code id="coxStrata_+3A_strata.vars">strata.vars</code></td>
<td>
<p>the name of the variables used to define the strata</p>
</td></tr>
<tr><td><code id="coxStrata_+3A_strata.levels">strata.levels</code></td>
<td>
<p>a named list containing for each variable used to form the strata all its possible levels</p>
</td></tr>
<tr><td><code id="coxStrata_+3A_levels">levels</code></td>
<td>
<p>the strata levels that have been used to fit the Cox model</p>
</td></tr>
</table>


<h3>Details</h3>

<p>if no strata variables returns a vector of <code>"1"</code> (factor).
</p>


<h3>Author(s)</h3>

<p>Brice Ozenne broz@sund.ku.dk
</p>

<hr>
<h2 id='coxStrataLevel'>Returns the name of the strata in Cox model</h2><span id='topic+coxStrataLevel'></span><span id='topic+coxStrataLevel.coxph'></span><span id='topic+coxStrataLevel.cph'></span><span id='topic+coxStrataLevel.phreg'></span>

<h3>Description</h3>

<p>Return the name of the strata in Cox model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coxStrataLevel(object)

## S3 method for class 'coxph'
coxStrataLevel(object)

## S3 method for class 'cph'
coxStrataLevel(object)

## S3 method for class 'phreg'
coxStrataLevel(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coxStrataLevel_+3A_object">object</code></td>
<td>
<p>The fitted Cox regression model object either
obtained with <code>coxph</code> (survival package), <code>cph</code>
(rms package), or <code>phreg</code> (mets package).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Brice Ozenne broz@sund.ku.dk
</p>

<hr>
<h2 id='coxVarCov'>Extract the variance covariance matrix of the beta from a Cox model</h2><span id='topic+coxVarCov'></span><span id='topic+coxVarCov.cph'></span><span id='topic+coxVarCov.coxph'></span><span id='topic+coxVarCov.phreg'></span>

<h3>Description</h3>

<p>Extract the variance covariance matrix of the beta from a Cox model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coxVarCov(object)

## S3 method for class 'cph'
coxVarCov(object)

## S3 method for class 'coxph'
coxVarCov(object)

## S3 method for class 'phreg'
coxVarCov(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coxVarCov_+3A_object">object</code></td>
<td>
<p>The fitted Cox regression model object either
obtained with <code>coxph</code> (survival package), <code>cph</code>
(rms package), or <code>phreg</code> (mets package).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Should return <code>NULL</code> if the Cox model has no covariate. 
The rows and columns of the variance covariance matrix must be named with the names used in the design matrix.
</p>


<h3>Author(s)</h3>

<p>Brice Ozenne broz@sund.ku.dk
</p>

<hr>
<h2 id='coxVariableName'>Extract variable names from a model</h2><span id='topic+coxVariableName'></span>

<h3>Description</h3>

<p>Extract the name of the variables belonging to the linear predictor or used to form the strata
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coxVariableName(object, model.frame)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coxVariableName_+3A_object">object</code></td>
<td>
<p>The fitted Cox regression model object either
obtained with <code>coxph</code> (survival package) or <code>cph</code>
(rms package).</p>
</td></tr>
<tr><td><code id="coxVariableName_+3A_model.frame">model.frame</code></td>
<td>
<p>[data.frame] dataset containing all the relevant variables (entry, time to event, type of event, variables in the linear predictor, strata).
Output from <code>coxModelFrame</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Brice Ozenne broz@sund.ku.dk
</p>

<hr>
<h2 id='CSC'>Cause-specific Cox proportional hazard regression</h2><span id='topic+CSC'></span>

<h3>Description</h3>

<p>Interface for fitting cause-specific Cox proportional hazard regression
models in competing risk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CSC(formula, data, cause, surv.type = "hazard", fitter = "coxph", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CSC_+3A_formula">formula</code></td>
<td>
<p>Either a single <code>Hist</code> formula or a list of formulas.
If it is a list it must contain as many <code>Hist</code> formulas as there are
causes when <code>surv.type="hazard"</code> and exactly two formulas when <code>surv.type="survival"</code>.
If it is a list the first formula is used for the cause of interest specific Cox regression
and the other formula(s) either for the other cause specific Cox regression(s) or for the
Cox regression of the combined event where each cause counts as event. Note that when only one
formula is given the covariates enter in exactly the same way into all Cox regression analyses.</p>
</td></tr>
<tr><td><code id="CSC_+3A_data">data</code></td>
<td>
<p>A data in which to fit the models.</p>
</td></tr>
<tr><td><code id="CSC_+3A_cause">cause</code></td>
<td>
<p>The cause of interest. Defaults to the first cause (see Details).</p>
</td></tr>
<tr><td><code id="CSC_+3A_surv.type">surv.type</code></td>
<td>
<p>Either <code>"hazard"</code> (the default) or
<code>"survival"</code>.  If <code>"hazard"</code> fit cause-specific Cox
regression models for all causes.  If <code>"survival"</code> fit one
cause-specific Cox regression model for the cause of interest and
also a Cox regression model for event-free survival.</p>
</td></tr>
<tr><td><code id="CSC_+3A_fitter">fitter</code></td>
<td>
<p>Routine to fit the Cox regression models.
If <code>coxph</code> use <code>survival::coxph</code> else use <code>rms::cph</code>.</p>
</td></tr>
<tr><td><code id="CSC_+3A_...">...</code></td>
<td>
<p>Arguments given to <code>fitter</code>, e.g., <code>coxph</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The causes and their order
are determined by <code>prodlim::getStates()</code> applied to the Hist object.
</p>


<h3>Value</h3>

<table>
<tr><td><code>models</code></td>
<td>
<p>a list with the fitted (cause-specific) Cox
regression objects</p>
</td></tr> <tr><td><code>response</code></td>
<td>
<p>the event history response </p>
</td></tr>
<tr><td><code>eventTimes</code></td>
<td>
<p>the sorted (unique) event times </p>
</td></tr> <tr><td><code>surv.type</code></td>
<td>
<p>the
value of <code>surv.type</code></p>
</td></tr> <tr><td><code>theCause</code></td>
<td>
<p>the cause of interest. see
<code>cause</code></p>
</td></tr> <tr><td><code>causes</code></td>
<td>
<p>the other causes</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>Thomas A. Gerds <a href="mailto:tag@biostat.ku.dk">tag@biostat.ku.dk</a> and Ulla B. Mogensen
</p>


<h3>References</h3>

<p>B. Ozenne, A. L. Soerensen, T.H. Scheike, C.T. Torp-Pedersen,
and T.A. Gerds. riskregression: Predicting the risk
of an event using Cox regression models. R Journal, 9(2):440&ndash;460, 2017.
</p>
<p>J Benichou and Mitchell H Gail. Estimates of absolute cause-specific risk
in cohort studies. Biometrics, pages 813&ndash;826, 1990.
</p>
<p>T.A. Gerds, T.H. Scheike, and P.K. Andersen. Absolute risk regression for
competing risks: Interpretation, link functions, and prediction. Statistics
in Medicine, 31(29):3921&ndash;3930, 2012.
</p>


<h3>See Also</h3>

<p><code><a href="survival.html#topic+coxph">coxph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(prodlim)
library(survival)
data(Melanoma)
## fit two cause-specific Cox models
## different formula for the two causes
fit1 &lt;- CSC(list(Hist(time,status)~sex+age,Hist(time,status)~invasion+epicel+log(thick)),
            data=Melanoma)
print(fit1)
## Not run: 
library(Publish)
publish(fit1)

## End(Not run)

## model hazard of all cause mortality instead of hazard of type 2
fit1a &lt;- CSC(list(Hist(time,status)~sex+age,Hist(time,status)~invasion+epicel+log(thick)),
             data=Melanoma,
             surv.type="surv")

## the predicted probabilities are similar
plot(predictRisk(fit1,times=500,cause=1,newdata=Melanoma),
     predictRisk(fit1a,times=500,cause=1,newdata=Melanoma))

## special case where cause 2 has no covariates
fit1b &lt;- CSC(list(Hist(time,status)~sex+age,Hist(time,status)~1),
             data=Melanoma)
print(fit1b)
predict(fit1b,cause=1,times=100,newdata=Melanoma)


## same formula for both causes
fit2 &lt;- CSC(Hist(time,status)~invasion+epicel+age,
            data=Melanoma)
print(fit2)

## combine a cause-specific Cox regression model for cause 2
## and a Cox regression model for the event-free survival:
## different formula for cause 2 and event-free survival
fit3 &lt;- CSC(list(Hist(time,status)~sex+invasion+epicel+age,
                 Hist(time,status)~invasion+epicel+age),
            surv.type="surv",
            data=Melanoma)
print(fit3)

## same formula for both causes
fit4 &lt;- CSC(Hist(time,status)~invasion+epicel+age,
            data=Melanoma,
            surv.type="surv")
print(fit4)

## strata
fit5 &lt;- CSC(Hist(time,status)~invasion+epicel+age+strata(sex),
            data=Melanoma,
            surv.type="surv")
print(fit5)

## sanity checks

cox1 &lt;- coxph(Surv(time,status==1)~invasion+epicel+age+strata(sex),data=Melanoma)
cox2 &lt;- coxph(Surv(time,status!=0)~invasion+epicel+age+strata(sex),data=Melanoma)
all.equal(coef(cox1),coef(fit5$models[[1]]))
all.equal(coef(cox2),coef(fit5$models[[2]]))

## predictions
##
## surv.type = "hazard": predictions for both causes can be extracted
## from the same fit
fit2 &lt;- CSC(Hist(time,status)~invasion+epicel+age, data=Melanoma)
predict(fit2,cause=1,newdata=Melanoma[c(17,99,108),],times=c(100,1000,10000))
predictRisk(fit2,cause=1,newdata=Melanoma[c(17,99,108),],times=c(100,1000,10000))
predictRisk(fit2,cause=2,newdata=Melanoma[c(17,99,108),],times=c(100,1000,10000))
predict(fit2,cause=1,newdata=Melanoma[c(17,99,108),],times=c(100,1000,10000))
predict(fit2,cause=2,newdata=Melanoma[c(17,99,108),],times=c(100,1000,10000))

## surv.type = "surv" we need to change the cause of interest
library(survival)
fit5.2 &lt;- CSC(Hist(time,status)~invasion+epicel+age+strata(sex),
            data=Melanoma,
            surv.type="surv",cause=2)
## now this does not work
try(predictRisk(fit5.2,cause=1,newdata=Melanoma,times=4))

## but this does
predictRisk(fit5.2,cause=2,newdata=Melanoma,times=100)
predict(fit5.2,cause=2,newdata=Melanoma,times=100)
predict(fit5.2,cause=2,newdata=Melanoma[4,],times=100)

</code></pre>

<hr>
<h2 id='Ctree'>S3-Wrapper for ctree.</h2><span id='topic+Ctree'></span>

<h3>Description</h3>

<p>The call is added to an ctree object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ctree(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ctree_+3A_...">...</code></td>
<td>
<p>passed to ctree</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with two elements: ctree and call
</p>


<h3>Author(s)</h3>

<p>Thomas A. Gerds &lt;tag@biostat.ku.dk&gt;
</p>


<h3>See Also</h3>

<p>Cforest
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("party",quietly=TRUE)){
library(prodlim)
library(party)
library(survival)
set.seed(50)
d &lt;- SimSurv(50)
nd &lt;- data.frame(X1=c(0,1,0),X2=c(-1,0,1))
f &lt;- Ctree(Surv(time,status)~X1+X2,data=d)
predictRisk(f,newdata=nd,times=c(3,8))
}

</code></pre>

<hr>
<h2 id='discreteRoot'>Dichotomic search for monotone function</h2><span id='topic+discreteRoot'></span>

<h3>Description</h3>

<p>Find the root of a monotone function on a discrete grid of value using dichotomic search
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discreteRoot(
  fn,
  grid,
  increasing = TRUE,
  check = TRUE,
  tol = .Machine$double.eps^0.5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discreteRoot_+3A_fn">fn</code></td>
<td>
<p>[function] objective function to minimize in absolute value.</p>
</td></tr>
<tr><td><code id="discreteRoot_+3A_grid">grid</code></td>
<td>
<p>[vector] possible minimizers.</p>
</td></tr>
<tr><td><code id="discreteRoot_+3A_increasing">increasing</code></td>
<td>
<p>[logical] is the function fn increasing?</p>
</td></tr>
<tr><td><code id="discreteRoot_+3A_check">check</code></td>
<td>
<p>[logical] should the program check that fn takes a different sign for the first vs. the last value of the grid?</p>
</td></tr>
<tr><td><code id="discreteRoot_+3A_tol">tol</code></td>
<td>
<p>[numeric] the absolute convergence tolerance.</p>
</td></tr>
</table>

<hr>
<h2 id='FGR'>Formula wrapper for crr from cmprsk</h2><span id='topic+FGR'></span>

<h3>Description</h3>

<p>Formula interface for Fine-Gray regression competing risk models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FGR(formula, data, cause = 1, y = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FGR_+3A_formula">formula</code></td>
<td>
<p>A formula whose left hand side is a <code>Hist</code> object &ndash; see
<code><a href="prodlim.html#topic+Hist">Hist</a></code>.  The right hand side specifies (a linear combination of)
the covariates. See examples below.</p>
</td></tr>
<tr><td><code id="FGR_+3A_data">data</code></td>
<td>
<p>A data.frame in which all the variables of <code>formula</code> can be
interpreted.</p>
</td></tr>
<tr><td><code id="FGR_+3A_cause">cause</code></td>
<td>
<p>The failure type of interest. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="FGR_+3A_y">y</code></td>
<td>
<p>logical value: if <code>TRUE</code>, the response vector is returned in component <code>response</code>.</p>
</td></tr>
<tr><td><code id="FGR_+3A_...">...</code></td>
<td>
<p>...</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Formula interface for the function <code>crr</code> from the <code>cmprsk</code>
package.
</p>
<p>The function <code>crr</code> allows to multiply some covariates by time before
they enter the linear predictor. This can be achieved with the formula
interface, however, the code becomes a little cumbersome. See the examples.
Note that FGR does not allow for delayed entry (left-truncation).
The assumed value for indicating censored observations in the event variable
is <code>0</code>. The function <code>Hist</code> has an argument <code>cens.code</code>
which can change this (if you do not want to change the event variable).
</p>


<h3>Value</h3>

<p>See <code>crr</code>.
</p>


<h3>Author(s)</h3>

<p>Thomas Alexander Gerds <a href="mailto:tag@biostat.ku.dk">tag@biostat.ku.dk</a>
</p>


<h3>References</h3>

<p>Gerds, TA and Scheike, T and Andersen, PK (2011) Absolute risk
regression for competing risks: interpretation, link functions and
prediction Research report 11/7. Department of Biostatistics, University of
Copenhagen
</p>


<h3>See Also</h3>

<p><code><a href="#topic+riskRegression">riskRegression</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(prodlim)
library(survival)
library(cmprsk)
library(lava)
d &lt;- prodlim::SimCompRisk(100)
f1 &lt;- FGR(Hist(time,cause)~X1+X2,data=d)
print(f1)

## crr allows that some covariates are multiplied by
## a function of time (see argument tf of crr)
## by FGR uses the identity matrix
f2 &lt;- FGR(Hist(time,cause)~cov2(X1)+X2,data=d)
print(f2)

## same thing, but more explicit:
f3 &lt;- FGR(Hist(time,cause)~cov2(X1)+cov1(X2),data=d)
print(f3)

## both variables can enter cov2:
f4 &lt;- FGR(Hist(time,cause)~cov2(X1)+cov2(X2),data=d)
print(f4)

## change the function of time
qFun &lt;- function(x){x^2}
noFun &lt;- function(x){x}
sqFun &lt;- function(x){x^0.5}

## multiply X1 by time^2 and X2 by time:
f5 &lt;- FGR(Hist(time,cause)~cov2(X1,tf=qFun)+cov2(X2),data=d)
print(f5)
print(f5$crrFit)
## same results as crr
with(d,crr(ftime=time,
           fstatus=cause,
           cov2=d[,c("X1","X2")],
           tf=function(time){cbind(qFun(time),time)}))

## still same result, but more explicit
f5a &lt;- FGR(Hist(time,cause)~cov2(X1,tf=qFun)+cov2(X2,tf=noFun),data=d)
f5a$crrFit

## multiply X1 by time^2 and X2 by sqrt(time)
f5b &lt;- FGR(Hist(time,cause)~cov2(X1,tf=qFun)+cov2(X2,tf=sqFun),data=d,cause=1)

## additional arguments for crr
f6&lt;- FGR(Hist(time,cause)~X1+X2,data=d, cause=1,gtol=1e-5)
f6
f6a&lt;- FGR(Hist(time,cause)~X1+X2,data=d, cause=1,gtol=0.1)
f6a
</code></pre>

<hr>
<h2 id='getSplitMethod'>Input for data splitting algorithms</h2><span id='topic+getSplitMethod'></span>

<h3>Description</h3>

<p>Parse hyperparameters for data splitting algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSplitMethod(split.method, B, N, M, seed)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSplitMethod_+3A_split.method">split.method</code></td>
<td>
<p>A character string specifying the algorithm for data splitting:
</p>

<ul>
<li><p>&quot;loob&quot; leave one out bootstrap
</p>
</li>
<li><p>&quot;bootcv&quot; bootstrap cross validation
</p>
</li>
<li><p>&quot;cv5&quot; 5-fold cross validation
</p>
</li>
<li><p>&quot;loocv&quot; leave one out cross validation aka N-1 fold cross validation
</p>
</li>
<li><p>&quot;632plus&quot; Efron's .632+ bootstrap
</p>
</li></ul>
</td></tr>
<tr><td><code id="getSplitMethod_+3A_b">B</code></td>
<td>
<p>Number of repetitions of bootstrap or k-fold cross-validation</p>
</td></tr>
<tr><td><code id="getSplitMethod_+3A_n">N</code></td>
<td>
<p>Sample size</p>
</td></tr>
<tr><td><code id="getSplitMethod_+3A_m">M</code></td>
<td>
<p>Subsample size. Default is N (no subsampling).</p>
</td></tr>
<tr><td><code id="getSplitMethod_+3A_seed">seed</code></td>
<td>
<p>Integer passed to set.seed. If not given or NA no seed is set.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li><p>split.methodName: the print name of the algorithm
</p>
</li>
<li><p>split.method: the internal name of the algorithm
</p>
</li>
<li><p>index: the index for data splitting. For bootstrap splitting this
is a matrix with B columns and M rows identifying the in-bag subjects. For k-fold
cross-validation this is a matrix with B columns identifying the membership to the k groups.
</p>
</li>
<li><p>k: the k of k-fold cross-validation
</p>
</li>
<li><p>N: the sample size
</p>
</li>
<li><p>M: the subsample size
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Thomas A. Gerds &lt;tag@biostat.ku.dk&gt;
</p>


<h3>See Also</h3>

<p>Score
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 3-fold crossvalidation
getSplitMethod("cv3",B=4,N=37)

# bootstrap with replacement
getSplitMethod("loob",B=4,N=37)

# bootstrap without replacement
getSplitMethod("loob",B=4,N=37,M=20)

</code></pre>

<hr>
<h2 id='GLMnet'>Fitting GLMnet for use with predictRisk</h2><span id='topic+GLMnet'></span>

<h3>Description</h3>

<p>Fit GLMnet models via a formula and a data set for use with <code><a href="#topic+predictRisk">predictRisk</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GLMnet(
  formula,
  data,
  lambda = NULL,
  cv = TRUE,
  alpha = 1,
  nfolds = 10,
  type.measure = "deviance",
  family,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GLMnet_+3A_formula">formula</code></td>
<td>
<p>A formula.</p>
</td></tr>
<tr><td><code id="GLMnet_+3A_data">data</code></td>
<td>
<p>The data on which to fit the model.</p>
</td></tr>
<tr><td><code id="GLMnet_+3A_lambda">lambda</code></td>
<td>
<p>The tuning parameters for GLMnet. If set to NULL, then it the parameters are chosen for you.</p>
</td></tr>
<tr><td><code id="GLMnet_+3A_cv">cv</code></td>
<td>
<p>Whether to use cross-validation or not. Default is TRUE.</p>
</td></tr>
<tr><td><code id="GLMnet_+3A_alpha">alpha</code></td>
<td>
<p>The elasticnet mixing parameter. See the ?glmnet for more details.</p>
</td></tr>
<tr><td><code id="GLMnet_+3A_nfolds">nfolds</code></td>
<td>
<p>Number of folds for cross-validation. Default is 10.</p>
</td></tr>
<tr><td><code id="GLMnet_+3A_type.measure">type.measure</code></td>
<td>
<p>loss to use for cross-validation. Default is deviance.</p>
</td></tr>
<tr><td><code id="GLMnet_+3A_family">family</code></td>
<td>
<p>passed to <code>glmnet</code>. Defaults for binary outcome to <code>"binomial"</code> and for survival to <code>"cox"</code>.</p>
</td></tr>
<tr><td><code id="GLMnet_+3A_...">...</code></td>
<td>
<p>Additional arguments that are passed on to the glmnet.</p>
</td></tr>
</table>

<hr>
<h2 id='Hal9001'>Fitting HAL for use with predictRisk</h2><span id='topic+Hal9001'></span>

<h3>Description</h3>

<p>Fit HAL models via a formula and a data set for use with <code><a href="#topic+predictRisk">predictRisk</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Hal9001(formula, data, lambda = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Hal9001_+3A_formula">formula</code></td>
<td>
<p>A formula.</p>
</td></tr>
<tr><td><code id="Hal9001_+3A_data">data</code></td>
<td>
<p>The data on which to fit the model.</p>
</td></tr>
<tr><td><code id="Hal9001_+3A_lambda">lambda</code></td>
<td>
<p>The tuning parameters for HAL. If set to NULL, then it the parameters are chosen for you.</p>
</td></tr>
<tr><td><code id="Hal9001_+3A_...">...</code></td>
<td>
<p>Additional arguments that are passed on to the hal_fit.</p>
</td></tr>
</table>

<hr>
<h2 id='iid.wglm'>IID for IPCW Logistic Regressions</h2><span id='topic+iid.wglm'></span>

<h3>Description</h3>

<p>Compute the decomposition in iid elements of the ML estimor of IPCW logistic regressions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wglm'
iid(x, times = NULL, simplifies = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iid.wglm_+3A_x">x</code></td>
<td>
<p>a wglm object.</p>
</td></tr>
<tr><td><code id="iid.wglm_+3A_times">times</code></td>
<td>
<p>[numeric vector] time points at which the iid should be output.</p>
</td></tr>
<tr><td><code id="iid.wglm_+3A_simplifies">simplifies</code></td>
<td>
<p>[logical] should the ouput be converted to a matrix when only one timepoint is requested. Otherwise will always return a list.</p>
</td></tr>
<tr><td><code id="iid.wglm_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>

<hr>
<h2 id='iidCox'>Extract iid decomposition from a Cox model</h2><span id='topic+iidCox'></span><span id='topic+iidCox.coxph'></span><span id='topic+iidCox.cph'></span><span id='topic+iidCox.phreg'></span><span id='topic+iidCox.CauseSpecificCox'></span>

<h3>Description</h3>

<p>Compute the influence function for each observation used to estimate the model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iidCox(
  object,
  newdata,
  baseline.iid,
  tau.hazard,
  tau.max,
  store.iid,
  keep.times,
  return.object
)

## S3 method for class 'coxph'
iidCox(
  object,
  newdata = NULL,
  baseline.iid = TRUE,
  tau.hazard = NULL,
  tau.max = NULL,
  store.iid = "full",
  keep.times = TRUE,
  return.object = TRUE
)

## S3 method for class 'cph'
iidCox(
  object,
  newdata = NULL,
  baseline.iid = TRUE,
  tau.hazard = NULL,
  tau.max = NULL,
  store.iid = "full",
  keep.times = TRUE,
  return.object = TRUE
)

## S3 method for class 'phreg'
iidCox(
  object,
  newdata = NULL,
  baseline.iid = TRUE,
  tau.hazard = NULL,
  tau.max = NULL,
  store.iid = "full",
  keep.times = TRUE,
  return.object = TRUE
)

## S3 method for class 'CauseSpecificCox'
iidCox(
  object,
  newdata = NULL,
  baseline.iid = TRUE,
  tau.hazard = NULL,
  tau.max = NULL,
  store.iid = "full",
  keep.times = TRUE,
  return.object = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iidCox_+3A_object">object</code></td>
<td>
<p>object The fitted Cox regression model object either
obtained with <code>coxph</code> (survival package) or <code>cph</code>
(rms package).</p>
</td></tr>
<tr><td><code id="iidCox_+3A_newdata">newdata</code></td>
<td>
<p>[data.frame] Optional new data at which to do iid decomposition</p>
</td></tr>
<tr><td><code id="iidCox_+3A_baseline.iid">baseline.iid</code></td>
<td>
<p>[logical] Should the influence function for the baseline hazard be computed.</p>
</td></tr>
<tr><td><code id="iidCox_+3A_tau.hazard">tau.hazard</code></td>
<td>
<p>[numeric vector] the vector of times at which the i.i.d decomposition of the baseline hazard will be computed</p>
</td></tr>
<tr><td><code id="iidCox_+3A_tau.max">tau.max</code></td>
<td>
<p>[numeric] latest time at which the i.i.d decomposition of the baseline hazard will be computed. Alternative to <code>tau.hazard</code>.</p>
</td></tr>
<tr><td><code id="iidCox_+3A_store.iid">store.iid</code></td>
<td>
<p>[character] the method used to compute the influence function and the standard error.
Can be <code>"full"</code> or <code>"minimal"</code>. See the details section.</p>
</td></tr>
<tr><td><code id="iidCox_+3A_keep.times">keep.times</code></td>
<td>
<p>[logical] If <code>TRUE</code> add the evaluation times to the output.</p>
</td></tr>
<tr><td><code id="iidCox_+3A_return.object">return.object</code></td>
<td>
<p>[logical] If <code>TRUE</code> return the object where the iid decomposition has been added.
Otherwise return a list (see the return section)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements the first three formula (no number,10,11) of the subsection
&quot;Empirical estimates&quot; in Ozenne et al. (2017).
If there is no event in a strata, the influence function for the baseline hazard is set to 0. 
</p>
<p><b>Argument store.iid</b>:
If <code>n</code> denotes the sample size, <code>J</code> the number of jump times, and <code>p</code> the number of coefficients:
</p>

<ul>
<li> <p><code>store.iid="full"</code> exports the influence function for the coefficients and the baseline hazard at each event time.
</p>
</li>
<li> <p><code>store.iid="minimal"</code> exports the influence function for the coefficients. For the
baseline hazard it only computes the quantities necessary to compute the influence function in order to save memory. </p>
</li></ul>

<p>More details can be found in appendix B of Ozenne et al. (2017).
</p>


<h3>Value</h3>

<p>For Cox models, it returns the object with an additional iid slot (i.e. <code>object$iid</code>).
It is a list containing:
</p>

<ul>
<li><p> IFbeta: Influence function for the regression coefficient.
</p>
</li>
<li><p> IFhazard: Time differential of the influence function of the hazard.
</p>
</li>
<li><p> IFcumhazard: Influence function of the cumulative hazard.
</p>
</li>
<li><p> calcIFhazard: Elements used to compute the influence function at a given time.
</p>
</li>
<li><p> time: Times at which the influence function has been evaluated.
</p>
</li>
<li><p> etime1.min: Time of first event (i.e. jump) in each strata.
</p>
</li>
<li><p> etime.max: Last observation time (i.e. jump or censoring) in each strata.
</p>
</li>
<li><p> indexObs: Index of the observation in the original dataset.</p>
</li></ul>

<p>For Cause-Specific Cox models,
it returns the object with an additional iid slot for each model (e.g. <code>object$models[[1]]iid</code>).
</p>


<h3>References</h3>

<p>Brice Ozenne, Anne Lyngholm Sorensen, Thomas Scheike, Christian Torp-Pedersen and Thomas Alexander Gerds.
riskRegression: Predicting the Risk of an Event using Cox Regression Models.
The R Journal (2017) 9:2, pages 440-460.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(survival)
library(data.table)
library(prodlim)
set.seed(10)
d &lt;- sampleData(100, outcome = "survival")[,.(eventtime,event,X1,X6)]
setkey(d, eventtime)

m.cox &lt;- coxph(Surv(eventtime, event) ~ X1+X6, data = d, y = TRUE, x = TRUE)
system.time(IF.cox &lt;- iidCox(m.cox))

IF.cox.all &lt;- iidCox(m.cox, tau.hazard = sort(unique(c(7,d$eventtime))))
IF.cox.beta &lt;- iidCox(m.cox, baseline.iid = FALSE)

</code></pre>

<hr>
<h2 id='influenceTest'>Influence test [Experimental!!]</h2><span id='topic+influenceTest'></span><span id='topic+influenceTest.list'></span><span id='topic+influenceTest.default'></span>

<h3>Description</h3>

<p>Compare two estimates using their influence function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>influenceTest(object, ...)

## S3 method for class 'list'
influenceTest(
  object,
  newdata,
  times,
  type,
  cause,
  keep.newdata = TRUE,
  keep.strata = FALSE,
  ...
)

## Default S3 method:
influenceTest(object, object2, band = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="influenceTest_+3A_object">object</code></td>
<td>
<p>either a list of models or an object of class predictCox or predictCSC.</p>
</td></tr>
<tr><td><code id="influenceTest_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to lower level functions.</p>
</td></tr>
<tr><td><code id="influenceTest_+3A_newdata">newdata</code></td>
<td>
<p>[data.frame or data.table] Contain
the values of the predictor variables defining subject specific
predictions.</p>
</td></tr>
<tr><td><code id="influenceTest_+3A_times">times</code></td>
<td>
<p>[numeric vector] Time points at which to return
the estimated absolute risk.</p>
</td></tr>
<tr><td><code id="influenceTest_+3A_type">type</code></td>
<td>
<p>[character]the type of predicted value.</p>
</td></tr>
<tr><td><code id="influenceTest_+3A_cause">cause</code></td>
<td>
<p>[integer/character] Identifies the cause of interest among the competing
events.</p>
</td></tr>
<tr><td><code id="influenceTest_+3A_keep.newdata">keep.newdata</code></td>
<td>
<p>[logical] If <code>TRUE</code> add the value of the covariates
used to make the prediction in the output.</p>
</td></tr>
<tr><td><code id="influenceTest_+3A_keep.strata">keep.strata</code></td>
<td>
<p>[logical] If <code>TRUE</code> add the value of the strata
used to make the prediction in the output.</p>
</td></tr>
<tr><td><code id="influenceTest_+3A_object2">object2</code></td>
<td>
<p>same as predict1 but for another model.</p>
</td></tr>
<tr><td><code id="influenceTest_+3A_band">band</code></td>
<td>
<p>[logical] If <code>TRUE</code> add the influence function to the output
such that <code>confint</code> will be able to compute the confidence bands.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(lava)
library(survival)
library(prodlim)
library(data.table)
n &lt;- 100

#### Under H1
set.seed(1)
newdata &lt;- data.frame(X1=0:1)

## simulate non proportional hazard using lava
m &lt;- lvm()
regression(m) &lt;- y ~ 1
regression(m) &lt;- s ~ exp(-2*X1)
distribution(m,~X1) &lt;- binomial.lvm()
distribution(m,~cens) &lt;- coxWeibull.lvm(scale=1)
distribution(m,~y) &lt;- coxWeibull.lvm(scale=1,shape=~s)
eventTime(m) &lt;- eventtime ~ min(y=1,cens=0)
d &lt;- as.data.table(sim(m,n))
setkey(d, eventtime)

## fit cox models
m.cox &lt;- coxph(Surv(eventtime, status) ~ X1, 
               data = d, y = TRUE, x = TRUE)

mStrata.cox &lt;- coxph(Surv(eventtime, status) ~ strata(X1), 
                     data = d, y = TRUE, x = TRUE)

## compare models
# one time point
outIF &lt;- influenceTest(list(m.cox, mStrata.cox), 
              type = "survival", newdata = newdata, times = 0.5)
confint(outIF)
                                 
# several timepoints
outIF &lt;- influenceTest(list(m.cox, mStrata.cox), 
              type = "survival", newdata = newdata, times = c(0.5,1,1.5))
confint(outIF)

#### Under H0 (Cox) ####
set.seed(1)
## simulate proportional hazard using lava
m &lt;- lvm()
regression(m) &lt;- y ~ 1
distribution(m,~X1) &lt;- binomial.lvm()
distribution(m,~cens) &lt;- coxWeibull.lvm()
distribution(m,~y) &lt;- coxWeibull.lvm()
eventTime(m) &lt;- eventtime ~ min(y=1,cens=0)
d &lt;- as.data.table(sim(m,n))
setkey(d, eventtime)

## fit cox models
Utime &lt;- sort(unique(d$eventtime))
m.cox &lt;- coxph(Surv(eventtime, status) ~ X1, 
               data = d, y = TRUE, x = TRUE)

mStrata.cox &lt;- coxph(Surv(eventtime, status) ~ strata(X1), 
                     data = d, y = TRUE, x = TRUE)

p.cox &lt;- predictCox(m.cox, newdata = newdata, time = Utime, type = "survival")
p.coxStrata &lt;- predictCox(mStrata.cox, newdata = newdata, time = Utime, type = "survival")

## display
library(ggplot2)
autoplot(p.cox)
autoplot(p.coxStrata)
 
## compare models
outIF &lt;- influenceTest(list(m.cox, mStrata.cox), 
                       type = "survival", newdata = newdata, times = Utime[1:6])
confint(outIF)

#### Under H0 (CSC) ####
set.seed(1)
ff &lt;- ~ f(X1,2) + f(X2,-0.033)
ff &lt;- update(ff, ~ .+ f(X3,0) + f(X4,0) + f(X5,0))
ff &lt;- update(ff, ~ .+ f(X6,0) + f(X7,0) + f(X8,0) + f(X9,0))
d &lt;- sampleData(n, outcome = "competing.risk", formula = ff)
d[,X1:=as.numeric(as.character(X1))]
d[,X2:=as.numeric(as.character(X2))]
d[,X3:=as.numeric(as.character(X3))]
d[,X4:=as.numeric(as.character(X4))]
d[,X5:=as.numeric(as.character(X5))]
setkey(d, time)

Utime &lt;- sort(unique(d$time))

## fit cox models
m.CSC &lt;- CSC(Hist(time, event) ~ X1 + X2, data = d)
mStrata.CSC &lt;- CSC(Hist(time, event) ~ strata(X1) + X2 + X3, data = d)

## compare models
outIF &lt;- influenceTest(list(m.CSC, mStrata.CSC), 
             cause = 1, newdata = unique(d[,.(X1,X2,X3)]), times = Utime[1:5])
confint(outIF)
</code></pre>

<hr>
<h2 id='information.wglm'>Information for IPCW Logistic Regressions</h2><span id='topic+information.wglm'></span>

<h3>Description</h3>

<p>Compute the information (i.e. opposit of the expectation of the second derivative of the log-likelihood) for IPCW logistic regressions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wglm'
information(x, times = NULL, simplifies = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="information.wglm_+3A_x">x</code></td>
<td>
<p>a wglm object.</p>
</td></tr>
<tr><td><code id="information.wglm_+3A_times">times</code></td>
<td>
<p>[numeric vector] time points at which the score should be output.</p>
</td></tr>
<tr><td><code id="information.wglm_+3A_simplifies">simplifies</code></td>
<td>
<p>[logical] should the ouput be converted to a matrix when only one timepoint is requested. Otherwise will always return a list.</p>
</td></tr>
<tr><td><code id="information.wglm_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>

<hr>
<h2 id='IPA'>Explained variation for settings with binary, survival and competing risk outcome</h2><span id='topic+IPA'></span><span id='topic+rsquared'></span><span id='topic+rsquared.default'></span><span id='topic+rsquared.glm'></span><span id='topic+rsquared.coxph'></span><span id='topic+rsquared.CauseSpecificCox'></span><span id='topic+IPA.default'></span><span id='topic+IPA.glm'></span><span id='topic+IPA.coxph'></span><span id='topic+IPA.CauseSpecificCox'></span>

<h3>Description</h3>

<p>Index of Prediction Accuracy: General R^2 for binary outcome and right censored time to event (survival) outcome also with competing risks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsquared(object,...)
IPA(object,...)
## Default S3 method:
rsquared(object,formula,newdata,times,cause,...)
## S3 method for class 'glm'
rsquared(object,formula,newdata,...)
## S3 method for class 'coxph'
rsquared(object,formula,newdata,times,...)
## S3 method for class 'CauseSpecificCox'
rsquared(object,formula,newdata,times,cause,...)
## Default S3 method:
IPA(object,formula,newdata,times,cause,...)
## S3 method for class 'glm'
IPA(object,formula,newdata,...)
## S3 method for class 'coxph'
IPA(object,formula,newdata,times,...)
## S3 method for class 'CauseSpecificCox'
IPA(object,formula,newdata,times,cause,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IPA_+3A_object">object</code></td>
<td>
<p>Model for which we want IPA.</p>
</td></tr>
<tr><td><code id="IPA_+3A_...">...</code></td>
<td>
<p>passed to <code>riskRegression::Score</code></p>
</td></tr>
<tr><td><code id="IPA_+3A_newdata">newdata</code></td>
<td>
<p>Optional validation data set in which to compute IPA</p>
</td></tr>
<tr><td><code id="IPA_+3A_formula">formula</code></td>
<td>
<p>Formula passed to <code>Score</code>. If not provided, try to use the formula of the call of <code>object</code>, if any.</p>
</td></tr>
<tr><td><code id="IPA_+3A_cause">cause</code></td>
<td>
<p>For competing risk models the event of interest</p>
</td></tr>
<tr><td><code id="IPA_+3A_times">times</code></td>
<td>
<p>Vector of time points used as prediction horizon for the computation of Brier scores.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>IPA (R^2) is calculated based on the model's predicted risks. The Brier score of the model is compared to the Brier score of the null model.
</p>


<h3>Value</h3>

<p>Data frame with explained variation values for the full model.
</p>


<h3>Author(s)</h3>

<p>Thomas A. Gerds &lt;tag@biostat.ku.dk&gt;
</p>


<h3>See Also</h3>

<p>Score
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(prodlim)
library(data.table)
# binary outcome
library(lava)
set.seed(18)
learndat &lt;- sampleData(48,outcome="binary")
lr1 = glm(Y~X1+X2+X7+X9,data=learndat,family=binomial)
IPA(lr1)

## validation data
valdat=sampleData(94,outcome="binary")
IPA(lr1,newdata=valdat)

## predicted risks externally given
p1=predictRisk(lr1,newdata=valdat)
IPA(p1,formula=Y~1,valdat)

# survival
library(survival)
data(pbc)
pbc=na.omit(pbc)
pbctest=(1:NROW(pbc)) %in% sample(1:NROW(pbc),size=.632*NROW(pbc))
pbclearn=pbc[pbctest,]
cox1= coxph(Surv(time,status!=0)~age+sex+log(bili)+log(albumin)+log(protime),
      data=pbclearn,x=TRUE)

## same data
IPA(cox1,formula=Surv(time,status!=0)~1,times=1000)

## validation data
pbcval=pbc[!pbctest,]
IPA(cox1,formula=Surv(time,status!=0)~1,newdata=pbcval,times=1000)

## predicted risks externally given
p2=predictRisk(cox1,newdata=pbcval,times=1000)
IPA(cox1,formula=Surv(time,status!=0)~1,newdata=pbcval,times=1000)
 
# competing risks
data(Melanoma)
Melanomatest=(1:NROW(Melanoma)) %in% sample(1:NROW(Melanoma),size=.632*NROW(Melanoma))
Melanomalearn=Melanoma[Melanomatest,]
fit1 &lt;- CSC(list(Hist(time,status)~sex,
                 Hist(time,status)~invasion+epicel+age),
                 data=Melanoma)
IPA(fit1,times=1000,cause=2)

## validation data
Melanomaval=Melanoma[!Melanomatest,]
IPA(fit1,formula=Hist(time,status)~1,newdata=Melanomaval,times=1000)

## predicted risks externally given
p3= predictRisk(fit1,cause=1,newdata=Melanomaval,times=1000)
IPA(p3,formula=Hist(time,status)~1,cause=1,newdata=Melanomaval,times=1000)
 
</code></pre>

<hr>
<h2 id='ipcw'>Estimation of censoring probabilities</h2><span id='topic+ipcw'></span><span id='topic+ipcw.none'></span><span id='topic+ipcw.marginal'></span><span id='topic+ipcw.nonpar'></span><span id='topic+ipcw.cox'></span><span id='topic+ipcw.aalen'></span>

<h3>Description</h3>

<p>This function is used internally to obtain
inverse of the probability of censoring weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ipcw(
  formula,
  data,
  method,
  args,
  times,
  subject.times,
  lag = 1,
  what,
  keep = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ipcw_+3A_formula">formula</code></td>
<td>
<p>A survival formula like, <code>Surv(time,status)~1</code>, where
as usual status=0 means censored. The status variable is internally
reversed for estimation of censoring rather than survival
probabilities. Some of the available models (see argument
<code>model</code>) will use predictors on the right hand side of the
formula.</p>
</td></tr>
<tr><td><code id="ipcw_+3A_data">data</code></td>
<td>
<p>The data used for fitting the censoring model</p>
</td></tr>
<tr><td><code id="ipcw_+3A_method">method</code></td>
<td>
<p>Censoring model used for estimation of the
(conditional) censoring distribution.</p>
</td></tr>
<tr><td><code id="ipcw_+3A_args">args</code></td>
<td>
<p>A list of arguments which is passed to method</p>
</td></tr>
<tr><td><code id="ipcw_+3A_times">times</code></td>
<td>
<p>For <code>what="IPCW.times"</code> a vector of times at
which to compute the probabilities of not being censored.</p>
</td></tr>
<tr><td><code id="ipcw_+3A_subject.times">subject.times</code></td>
<td>
<p>For <code>what="IPCW.subject.times"</code> a vector of
individual times at which the probabilities of not being censored
are computed.</p>
</td></tr>
<tr><td><code id="ipcw_+3A_lag">lag</code></td>
<td>
<p>If equal to <code>1</code> then obtain
<code>G(T_i-|X_i)</code>, if equal to <code>0</code> estimate the conditional
censoring distribution at the subject.times,
i.e. (<code>G(T_i|X_i)</code>).</p>
</td></tr>
<tr><td><code id="ipcw_+3A_what">what</code></td>
<td>
<p>Decide about what to do: If equal to
<code>"IPCW.times"</code> then weights are estimated at given
<code>times</code>.  If equal to <code>"IPCW.subject.times"</code> then weights
are estimated at individual <code>subject.times</code>.  If missing then
produce both.</p>
</td></tr>
<tr><td><code id="ipcw_+3A_keep">keep</code></td>
<td>
<p>Which elements to add to the output. Any subset of the vector <code>c("times","fit","call")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Inverse of the probability of censoring weights (IPCW) usually refer to the
probabilities of not being censored at certain time points. These
probabilities are also the values of the conditional survival function of
the censoring time given covariates. The function ipcw estimates the
conditional survival function of the censoring times and derives the
weights.
</p>
<p>IMPORTANT: the data set should be ordered, <code>order(time,-status)</code> in
order to get the values <code>IPCW.subject.times</code> in the right order for some
choices of <code>method</code>.
</p>


<h3>Value</h3>

<p>A list with elements depending on argument <code>keep</code>. </p>
<table>
<tr><td><code>times</code></td>
<td>
<p>The times at which weights are estimated</p>
</td></tr>
<tr><td><code>IPCW.times</code></td>
<td>
<p>Estimated weights at <code>times</code></p>
</td></tr>
<tr><td><code>IPCW.subject.times</code></td>
<td>
<p>Estimated weights at individual time values
<code>subject.times</code></p>
</td></tr> <tr><td><code>fit</code></td>
<td>
<p>The fitted censoring model</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>The method for modelling the censoring distribution</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The call</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas A. Gerds <a href="mailto:tag@biostat.ku.dk">tag@biostat.ku.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(prodlim)
library(rms)
dat=SimSurv(30)

dat &lt;- dat[order(dat$time),]

# using the marginal Kaplan-Meier for the censoring times

WKM=ipcw(Hist(time,status)~X2,
  data=dat,
  method="marginal",
  times=sort(unique(dat$time)),
  subject.times=dat$time,keep=c("fit"))
plot(WKM$fit)
WKM$fit

# using the Cox model for the censoring times given X2
library(survival)
WCox=ipcw(Hist(time=time,event=status)~X2,
  data=dat,
  method="cox",
  times=sort(unique(dat$time)),
  subject.times=dat$time,keep=c("fit"))
WCox$fit

plot(WKM$fit)
lines(sort(unique(dat$time)),
      1-WCox$IPCW.times[1,],
      type="l",
      col=2,
      lty=3,
      lwd=3)
lines(sort(unique(dat$time)),
      1-WCox$IPCW.times[5,],
      type="l",
      col=3,
      lty=3,
      lwd=3)

# using the stratified Kaplan-Meier
# for the censoring times given X2

WKM2=ipcw(Hist(time,status)~X2,
  data=dat,
  method="nonpar",
  times=sort(unique(dat$time)),
  subject.times=dat$time,keep=c("fit"))
plot(WKM2$fit,add=FALSE)


</code></pre>

<hr>
<h2 id='Melanoma'>Malignant melanoma data</h2><span id='topic+Melanoma'></span>

<h3>Description</h3>

<p>In the period 1962-77, 205 patients with malignant melanoma (cancer of the
skin) had a radical operation performed at Odense University Hospital,
Denmark. All patients were followed until the end of 1977 by which time 134
were still alive while 71 had died (of out whom 57 had died from cancer and
14 from other causes).
</p>


<h3>Format</h3>

<p>A data frame with 205 observations on the following 12 variables.
</p>

<dl>
<dt>time</dt><dd><p> time in days from operation</p>
</dd>
<dt>status</dt><dd><p>a numeric with values <code>0=censored</code> <code>1=death.malignant.melanoma</code> <code>2=death.other.causes</code></p>
</dd>
<dt>event</dt><dd><p>a factor with levels <code>censored</code> <code>death.malignant.melanoma</code> <code>death.other.causes</code></p>
</dd>
<dt>invasion</dt><dd><p>a factor with levels <code>level.0</code>, <code>level.1</code>, <code>level.2</code></p>
</dd>
<dt>ici</dt><dd><p>inflammatory cell infiltration (IFI): 0, 1, 2 or 3</p>
</dd>
<dt>epicel</dt><dd><p>a factor with levels <code>not present</code> <code>present</code></p>
</dd>
<dt>ulcer</dt><dd><p>a factor with levels <code>not present</code> <code>present</code></p>
</dd>
<dt>thick</dt><dd><p>tumour thickness (in 1/100 mm)</p>
</dd>
<dt>sex</dt><dd><p>a factor with levels <code>Female</code> <code>Male</code></p>
</dd>
<dt>age</dt><dd><p>age at operation (years)</p>
</dd>
<dt>logthick</dt><dd><p>tumour thickness on log-scale</p>
</dd>
</dl>



<h3>Details</h3>

<p>The object of the study was to assess the effect of risk factors on
survival. Among such risk factors were the sex and age of the patients and
the histological variables tumor thickness and ulceration (absent vs.
present).
</p>


<h3>References</h3>

<p>Regression with linear predictors (2010)
</p>
<p>Andersen, P.K. and Skovgaard, L.T.
</p>
<p>Springer Verlag
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Melanoma)
</code></pre>

<hr>
<h2 id='model.matrix.cph'>Extract design matrix for cph objects</h2><span id='topic+model.matrix.cph'></span>

<h3>Description</h3>

<p>Extract design matrix for cph objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cph'
model.matrix(object, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.matrix.cph_+3A_object">object</code></td>
<td>
<p>a cph object.</p>
</td></tr>
<tr><td><code id="model.matrix.cph_+3A_data">data</code></td>
<td>
<p>a dataset.</p>
</td></tr>
<tr><td><code id="model.matrix.cph_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>

<hr>
<h2 id='model.matrix.phreg'>Extract design matrix for phreg objects</h2><span id='topic+model.matrix.phreg'></span>

<h3>Description</h3>

<p>Extract design matrix for phreg objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'phreg'
model.matrix(object, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.matrix.phreg_+3A_object">object</code></td>
<td>
<p>a phreg object.</p>
</td></tr>
<tr><td><code id="model.matrix.phreg_+3A_data">data</code></td>
<td>
<p>a dataset.</p>
</td></tr>
<tr><td><code id="model.matrix.phreg_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>mainly a copy paste of the begining of the <code>phreg</code> function.
</p>

<hr>
<h2 id='Paquid'>Paquid sample</h2><span id='topic+Paquid'></span>

<h3>Description</h3>

<p>PAQUID is a prospective cohort study initiated in 1988 in South Western
France to explore functional and cerebral ageing. This sample includes
n=2561 subjects. Data contains a time-to-event, a type of event and
two cognitive scores measured at baseline.
</p>


<h3>Format</h3>

<p>A data frame with 2561 observations on the following 4 variables.
</p>

<dl>
<dt><code>time</code></dt><dd><p>the time-to-event (in years).</p>
</dd>
<dt><code>status</code></dt><dd><p>the type of event <code>0</code> = censored, <code>1</code> = dementia onset and <code>2</code> = death without dementia.</p>
</dd>
<dt><code>DSST</code></dt><dd><p>score at the Digit Symbol Substitution Score Test. This test explores attention and psychomotor speed.</p>
</dd>
<dt><code>MMSE</code></dt><dd><p>score at the Mini Mental State Examination. This test is often used as an index of global cognitive performance.</p>
</dd>
</dl>



<h3>Source</h3>

<p>The data have been first made publicly available via the package timeROC.
</p>


<h3>References</h3>

<p>Dartigues, J., Gagnon, M., Barberger-Gateau, P., Letenneur, L., Commenges, D.,
Sauvel, C., Michel, P., and Salamon, R. (1992). The paquid epidemiological program
on brain ageing. Neuroepidemiology, 11(1):14&ndash;18.
</p>
<p>Blanche, P., Dartigues, J. F., &amp; Jacqmin-Gadda, H. (2013). Estimating and
comparing time-dependent areas under receiver operating characteristic curves
for censored event times with competing risks. Statistics in Medicine, 32(30),
5381-5397.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Paquid)
</code></pre>

<hr>
<h2 id='penalizedS3'>S3-wrapper for S4 function penalized</h2><span id='topic+penalizedS3'></span>

<h3>Description</h3>

<p>S3-wrapper for S4 function penalized
</p>


<h3>Usage</h3>

<pre><code class='language-R'>penalizedS3(formula, data, type = "elastic.net", lambda1, lambda2, fold, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="penalizedS3_+3A_formula">formula</code></td>
<td>
<p>Communicated outcome and explanatory variables. See examples.</p>
</td></tr>
<tr><td><code id="penalizedS3_+3A_data">data</code></td>
<td>
<p>Data set in which formula is to be interpreted</p>
</td></tr>
<tr><td><code id="penalizedS3_+3A_type">type</code></td>
<td>
<p>String specifying the type of penalization. Should match one of the following values:
<code>"ridge"</code>, <code>"lasso"</code>, <code>"elastic.net"</code>.</p>
</td></tr>
<tr><td><code id="penalizedS3_+3A_lambda1">lambda1</code></td>
<td>
<p>Lasso penalty</p>
</td></tr>
<tr><td><code id="penalizedS3_+3A_lambda2">lambda2</code></td>
<td>
<p>ridge penalty</p>
</td></tr>
<tr><td><code id="penalizedS3_+3A_fold">fold</code></td>
<td>
<p>passed to <code>penalized::profL1</code></p>
</td></tr>
<tr><td><code id="penalizedS3_+3A_...">...</code></td>
<td>
<p>Arguments passed to penalized</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(prodlim)
## Not run: 
## too slow
if (require("penalized",quietly=TRUE)){
library(penalized)
set.seed(8)
d &lt;- sampleData(200,outcome="binary")
newd &lt;- sampleData(80,outcome="binary")
fitridge &lt;- penalizedS3(Y~X1+X2+pen(7:8), data=d, type="ridge",
                standardize=TRUE, model="logistic",trace=FALSE)
fitlasso &lt;- penalizedS3(Y~X1+X2+pen(7:8), data=d, type="lasso",
                standardize=TRUE, model="logistic",trace=FALSE)
# fitnet &lt;- penalizedS3(Y~X1+X2+pen(7:8), data=d, type="elastic.net",
# standardize=TRUE, model="logistic",trace=FALSE)
predictRisk(fitridge,newdata=newd)
predictRisk(fitlasso,newdata=newd)
# predictRisk(fitnet,newdata=newd)
Score(list(fitridge),data=newd,formula=Y~1)
Score(list(fitridge),data=newd,formula=Y~1,split.method="bootcv",B=2)
data(nki70) ## S4 fit
fitS4 &lt;- penalized(Surv(time, event), penalized = nki70[,8:77],
                 unpenalized = ~ER+Age+Diam+N+Grade, data = nki70,
                 lambda1 = 1)
fitS3 &lt;- penalizedS3(Surv(time,event)~ER+Age+Diam+pen(8:77)+N+Grade,
                     data=nki70, lambda1=1)
## or
penS3 &lt;- penalizedS3(Surv(time,event)~ER+pen(TSPYL5,Contig63649_RC)+pen(10:77)+N+Grade,
                     data=nki70, lambda1=1)
## also this works
penS3 &lt;- penalizedS3(Surv(time,event)~ER+Age+pen(8:33)+Diam+pen(34:77)+N+Grade,
                    data=nki70, lambda1=1)
}
## End(Not run)
</code></pre>

<hr>
<h2 id='plot.riskRegression'>Plotting predicted risk</h2><span id='topic+plot.riskRegression'></span>

<h3>Description</h3>

<p>Show predicted risk obtained by a risk prediction model as a function of
time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'riskRegression'
plot(x,
  cause,
  newdata,
  xlab,
  ylab,
  xlim,
  ylim,
  lwd,
  col,
  lty,
  axes=TRUE,
  percent=TRUE,
  legend=TRUE,
  add=FALSE,
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.riskRegression_+3A_x">x</code></td>
<td>
<p>Fitted object obtained with one of <code>ARR</code>, <code>LRR</code>,
<code>riskRegression</code>.</p>
</td></tr>
<tr><td><code id="plot.riskRegression_+3A_cause">cause</code></td>
<td>
<p>For CauseSpecificCox models the cause of interest.</p>
</td></tr>
<tr><td><code id="plot.riskRegression_+3A_newdata">newdata</code></td>
<td>
<p>A data frame containing predictor variable combinations for
which to compute predicted risk.</p>
</td></tr>
<tr><td><code id="plot.riskRegression_+3A_xlab">xlab</code></td>
<td>
<p>See <code>plot</code></p>
</td></tr>
<tr><td><code id="plot.riskRegression_+3A_ylab">ylab</code></td>
<td>
<p>See <code>plot</code></p>
</td></tr>
<tr><td><code id="plot.riskRegression_+3A_xlim">xlim</code></td>
<td>
<p>See <code>plot</code></p>
</td></tr>
<tr><td><code id="plot.riskRegression_+3A_ylim">ylim</code></td>
<td>
<p>See <code>plot</code></p>
</td></tr>
<tr><td><code id="plot.riskRegression_+3A_lwd">lwd</code></td>
<td>
<p>A vector of line thicknesses for the regression coefficients.</p>
</td></tr>
<tr><td><code id="plot.riskRegression_+3A_col">col</code></td>
<td>
<p>A vector of colors for the regression coefficients.</p>
</td></tr>
<tr><td><code id="plot.riskRegression_+3A_lty">lty</code></td>
<td>
<p>A vector of line types for the regression coefficients.</p>
</td></tr>
<tr><td><code id="plot.riskRegression_+3A_axes">axes</code></td>
<td>
<p>Logical. If <code>FALSE</code> then do not draw axes.</p>
</td></tr>
<tr><td><code id="plot.riskRegression_+3A_percent">percent</code></td>
<td>
<p>If true the y-axis is labeled in percent.</p>
</td></tr>
<tr><td><code id="plot.riskRegression_+3A_legend">legend</code></td>
<td>
<p>If true draw a legend.</p>
</td></tr>
<tr><td><code id="plot.riskRegression_+3A_add">add</code></td>
<td>
<p>Logical. If <code>TRUE</code> then add lines to an existing plot.</p>
</td></tr>
<tr><td><code id="plot.riskRegression_+3A_...">...</code></td>
<td>
<p>Used for transclusion of smart arguments for <code>plot</code>,
<code>lines</code>, <code>axis</code> and <code>background</code>. See function
<code><a href="prodlim.html#topic+SmartControl">SmartControl</a></code> from prodlim.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Alexander Gerds &lt;tag@biostat.ku.dk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(survival)
library(prodlim)
data(Melanoma)
fit.arr &lt;- ARR(Hist(time,status)~invasion+age+strata(sex),data=Melanoma,cause=1)
plot(fit.arr,xlim=c(500,3000))


</code></pre>

<hr>
<h2 id='plotAUC'>Plot of time-dependent AUC curves</h2><span id='topic+plotAUC'></span>

<h3>Description</h3>

<p>Plot of time-dependent AUC curves
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotAUC(
  x,
  models,
  which = "score",
  xlim,
  ylim,
  xlab,
  ylab,
  col,
  lwd,
  lty = 1,
  cex = 1,
  pch = 1,
  type = "l",
  axes = 1L,
  percent = 1L,
  conf.int = 0L,
  legend = 1L,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotAUC_+3A_x">x</code></td>
<td>
<p>Object obtained with <code>Score.list</code></p>
</td></tr>
<tr><td><code id="plotAUC_+3A_models">models</code></td>
<td>
<p>Choice of models to plot</p>
</td></tr>
<tr><td><code id="plotAUC_+3A_which">which</code></td>
<td>
<p>Character. Either <code>"score"</code> to show AUC or
<code>"contrasts"</code> to show differences between AUC.</p>
</td></tr>
<tr><td><code id="plotAUC_+3A_xlim">xlim</code></td>
<td>
<p>Limits for x-axis</p>
</td></tr>
<tr><td><code id="plotAUC_+3A_ylim">ylim</code></td>
<td>
<p>Limits for y-axis</p>
</td></tr>
<tr><td><code id="plotAUC_+3A_xlab">xlab</code></td>
<td>
<p>Label for x-axis</p>
</td></tr>
<tr><td><code id="plotAUC_+3A_ylab">ylab</code></td>
<td>
<p>Label for y-axis</p>
</td></tr>
<tr><td><code id="plotAUC_+3A_col">col</code></td>
<td>
<p>line color</p>
</td></tr>
<tr><td><code id="plotAUC_+3A_lwd">lwd</code></td>
<td>
<p>line width</p>
</td></tr>
<tr><td><code id="plotAUC_+3A_lty">lty</code></td>
<td>
<p>line style</p>
</td></tr>
<tr><td><code id="plotAUC_+3A_cex">cex</code></td>
<td>
<p>point size</p>
</td></tr>
<tr><td><code id="plotAUC_+3A_pch">pch</code></td>
<td>
<p>point style</p>
</td></tr>
<tr><td><code id="plotAUC_+3A_type">type</code></td>
<td>
<p>line type</p>
</td></tr>
<tr><td><code id="plotAUC_+3A_axes">axes</code></td>
<td>
<p>Logical. If <code>TRUE</code> draw axes.</p>
</td></tr>
<tr><td><code id="plotAUC_+3A_percent">percent</code></td>
<td>
<p>Logical. If <code>TRUE</code> scale y-axis in percent.</p>
</td></tr>
<tr><td><code id="plotAUC_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical. If <code>TRUE</code> draw confidence shadows.</p>
</td></tr>
<tr><td><code id="plotAUC_+3A_legend">legend</code></td>
<td>
<p>Logical. If <code>TRUE</code> draw legend.</p>
</td></tr>
<tr><td><code id="plotAUC_+3A_...">...</code></td>
<td>
<p>Used for additional control of the subroutines: plot,</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(9)
library(survival)
library(prodlim)
set.seed(10)
d=sampleData(100,outcome="survival")
nd=sampleData(100,outcome="survival")
f1=coxph(Surv(time,event)~X1+X6+X8,data=d,x=TRUE,y=TRUE)
f2=coxph(Surv(time,event)~X2+X5+X9,data=d,x=TRUE,y=TRUE)
xx=Score(list("X1+X6+X8"=f1,"X2+X5+X9"=f2), formula=Surv(time,event)~1,
data=nd, metrics="auc", null.model=FALSE, times=seq(3:10))
aucgraph &lt;- plotAUC(xx)
plotAUC(xx,conf.int=TRUE)
## difference between
plotAUC(xx,which="contrasts",conf.int=TRUE)


</code></pre>

<hr>
<h2 id='plotBrier'>Plot Brier curve</h2><span id='topic+plotBrier'></span>

<h3>Description</h3>

<p>Plot Brier score curves
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotBrier(
  x,
  models,
  which = "score",
  xlim,
  ylim,
  xlab,
  ylab,
  col,
  lwd,
  lty = 1,
  cex = 1,
  pch = 1,
  type = "l",
  axes = 1L,
  percent = 1L,
  conf.int = 0L,
  legend = 1L,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotBrier_+3A_x">x</code></td>
<td>
<p>Object obtained with <code>Score</code></p>
</td></tr>
<tr><td><code id="plotBrier_+3A_models">models</code></td>
<td>
<p>Choice of models to plot</p>
</td></tr>
<tr><td><code id="plotBrier_+3A_which">which</code></td>
<td>
<p>Character. Either <code>"score"</code> to show AUC or
<code>"contrasts"</code> to show differences between AUC.</p>
</td></tr>
<tr><td><code id="plotBrier_+3A_xlim">xlim</code></td>
<td>
<p>Limits for x-axis</p>
</td></tr>
<tr><td><code id="plotBrier_+3A_ylim">ylim</code></td>
<td>
<p>Limits for y-axis</p>
</td></tr>
<tr><td><code id="plotBrier_+3A_xlab">xlab</code></td>
<td>
<p>Label for x-axis</p>
</td></tr>
<tr><td><code id="plotBrier_+3A_ylab">ylab</code></td>
<td>
<p>Label for y-axis</p>
</td></tr>
<tr><td><code id="plotBrier_+3A_col">col</code></td>
<td>
<p>line color</p>
</td></tr>
<tr><td><code id="plotBrier_+3A_lwd">lwd</code></td>
<td>
<p>line width</p>
</td></tr>
<tr><td><code id="plotBrier_+3A_lty">lty</code></td>
<td>
<p>line style</p>
</td></tr>
<tr><td><code id="plotBrier_+3A_cex">cex</code></td>
<td>
<p>point size</p>
</td></tr>
<tr><td><code id="plotBrier_+3A_pch">pch</code></td>
<td>
<p>point style</p>
</td></tr>
<tr><td><code id="plotBrier_+3A_type">type</code></td>
<td>
<p>line type</p>
</td></tr>
<tr><td><code id="plotBrier_+3A_axes">axes</code></td>
<td>
<p>Logical. If <code>TRUE</code> draw axes.</p>
</td></tr>
<tr><td><code id="plotBrier_+3A_percent">percent</code></td>
<td>
<p>Logical. If <code>TRUE</code> scale y-axis in percent.</p>
</td></tr>
<tr><td><code id="plotBrier_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical. If <code>TRUE</code> draw confidence shadows.</p>
</td></tr>
<tr><td><code id="plotBrier_+3A_legend">legend</code></td>
<td>
<p>Logical. If <code>TRUE</code> draw legend.</p>
</td></tr>
<tr><td><code id="plotBrier_+3A_...">...</code></td>
<td>
<p>Used for additional control of the subroutines: plot,
axis, lines, legend. See <code><a href="prodlim.html#topic+SmartControl">SmartControl</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># survival
library(survival)
library(prodlim)
set.seed(7)
ds1=sampleData(40,outcome="survival")
ds2=sampleData(40,outcome="survival")
f1 &lt;- coxph(Surv(time,event)~X1+X3+X5+X7+X9,data=ds1,x=TRUE)
f2 &lt;- coxph(Surv(time,event)~X2+X4+X6+X8+X10,data=ds1,x=TRUE)
xscore &lt;- Score(list(f1,f2),formula=Hist(time,event)~1,data=ds2,times=0:12,metrics="brier")
plotBrier(xscore)
</code></pre>

<hr>
<h2 id='plotCalibration'>Plot Calibration curve</h2><span id='topic+plotCalibration'></span>

<h3>Description</h3>

<p>Plot Calibration curves for risk prediction models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotCalibration(
  x,
  models,
  times,
  method = "nne",
  cens.method,
  round = TRUE,
  bandwidth = NULL,
  q = 10,
  bars = FALSE,
  hanging = FALSE,
  names = "quantiles",
  pseudo = FALSE,
  rug,
  show.frequencies = FALSE,
  plot = TRUE,
  add = FALSE,
  diag = !add,
  legend = !add,
  auc.in.legend,
  brier.in.legend,
  axes = !add,
  xlim = c(0, 1),
  ylim = c(0, 1),
  xlab = ifelse(bars, "Risk groups", "Predicted risk"),
  ylab,
  col,
  lwd,
  lty,
  pch,
  type,
  percent = TRUE,
  na.action = na.fail,
  cex = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotCalibration_+3A_x">x</code></td>
<td>
<p>Object obtained with function <code>Score</code></p>
</td></tr>
<tr><td><code id="plotCalibration_+3A_models">models</code></td>
<td>
<p>Choice of models to plot</p>
</td></tr>
<tr><td><code id="plotCalibration_+3A_times">times</code></td>
<td>
<p>Time point specifying the prediction horizon.</p>
</td></tr>
<tr><td><code id="plotCalibration_+3A_method">method</code></td>
<td>
<p>The method for estimating the calibration curve(s):
</p>

<ul>
<li> <p><code>"quantile"</code>: The observed proportion at predicted risk value 'p'
is obtained in groups
defined by quantiles of the predicted event probabilities of all subjects.
The number of groups is controlled by argument <code>q</code>.
</p>
</li>
<li> <p><code>"nne"</code>: The observed proportion at predicted risk value 'p' is obtained based
on the subjects whose predicted risk is inside a nearest
neighborhood around the value 'p'. The larger the
bandwidth the more subjects are included in the current neighborhood. </p>
</li></ul>
</td></tr>
<tr><td><code id="plotCalibration_+3A_cens.method">cens.method</code></td>
<td>
<p>For right censored data only. How observed proportions are calculated. Either <code>"jackknife"</code> or <code>"local"</code>:
</p>

<ul>
<li> <p><code>"jackknife"</code>: Compute a running mean of the jackknife pseudovalues across neighborhoods/groups of the predicted risks.
Here we rely on the
assumption that censoring is independent of the event time and the covariates, see References. 
</p>
</li>
<li> <p><code>"local"</code>: Compute the Kaplan-Meier estimator in absence of competing risks and the Aalen-Johansen estimator in presence of competing risks
locally like a running mean in neighborhoods of the predicted risks. The widths of the neighborhoods
are defined according to method. </p>
</li></ul>
</td></tr>
<tr><td><code id="plotCalibration_+3A_round">round</code></td>
<td>
<p>If <code>TRUE</code> predicted probabilities are rounded to
two digits before smoothing. This may have a considerable
effect on computing efficiency in large data sets.</p>
</td></tr>
<tr><td><code id="plotCalibration_+3A_bandwidth">bandwidth</code></td>
<td>
<p>The bandwidth for <code>method="nne"</code></p>
</td></tr>
<tr><td><code id="plotCalibration_+3A_q">q</code></td>
<td>
<p>The number of quantiles for <code>method="quantile"</code> and
<code>bars=TRUE</code>.</p>
</td></tr>
<tr><td><code id="plotCalibration_+3A_bars">bars</code></td>
<td>
<p>If <code>TRUE</code>, use barplots to show calibration.</p>
</td></tr>
<tr><td><code id="plotCalibration_+3A_hanging">hanging</code></td>
<td>
<p>Barplots only. If <code>TRUE</code>, hang bars
corresponding to observed frequencies (estimated actual risk)  at the value of the
corresponding prediction.</p>
</td></tr>
<tr><td><code id="plotCalibration_+3A_names">names</code></td>
<td>
<p>Barplots only. Names argument passed to
<code>names.arg</code> of <code>barplot</code>.</p>
</td></tr>
<tr><td><code id="plotCalibration_+3A_pseudo">pseudo</code></td>
<td>
<p>If <code>TRUE</code> show pseudo values (only for right
censored data).</p>
</td></tr>
<tr><td><code id="plotCalibration_+3A_rug">rug</code></td>
<td>
<p>If <code>TRUE</code> show rug plot at the predictions</p>
</td></tr>
<tr><td><code id="plotCalibration_+3A_show.frequencies">show.frequencies</code></td>
<td>
<p>Barplots only. If <code>TRUE</code>, show
frequencies above the bars.</p>
</td></tr>
<tr><td><code id="plotCalibration_+3A_plot">plot</code></td>
<td>
<p>If <code>FALSE</code>, do not plot the results, just return
a plottable object.</p>
</td></tr>
<tr><td><code id="plotCalibration_+3A_add">add</code></td>
<td>
<p>If <code>TRUE</code> the line(s) are added to an existing
plot.</p>
</td></tr>
<tr><td><code id="plotCalibration_+3A_diag">diag</code></td>
<td>
<p>If <code>FALSE</code> no diagonal line is drawn.</p>
</td></tr>
<tr><td><code id="plotCalibration_+3A_legend">legend</code></td>
<td>
<p>Logical. If <code>TRUE</code> draw legend.</p>
</td></tr>
<tr><td><code id="plotCalibration_+3A_auc.in.legend">auc.in.legend</code></td>
<td>
<p>Logical. If <code>TRUE</code> add AUC to legend.</p>
</td></tr>
<tr><td><code id="plotCalibration_+3A_brier.in.legend">brier.in.legend</code></td>
<td>
<p>Logical. If <code>TRUE</code> add Brier score to
legend.</p>
</td></tr>
<tr><td><code id="plotCalibration_+3A_axes">axes</code></td>
<td>
<p>If <code>FALSE</code> no axes are drawn.</p>
</td></tr>
<tr><td><code id="plotCalibration_+3A_xlim">xlim</code></td>
<td>
<p>Limits of x-axis.</p>
</td></tr>
<tr><td><code id="plotCalibration_+3A_ylim">ylim</code></td>
<td>
<p>Limits of y-axis.</p>
</td></tr>
<tr><td><code id="plotCalibration_+3A_xlab">xlab</code></td>
<td>
<p>Label for y-axis.</p>
</td></tr>
<tr><td><code id="plotCalibration_+3A_ylab">ylab</code></td>
<td>
<p>Label for x-axis.</p>
</td></tr>
<tr><td><code id="plotCalibration_+3A_col">col</code></td>
<td>
<p>Vector with colors, one for each element of
object. Passed to <code><a href="graphics.html#topic+lines">lines</a></code>.</p>
</td></tr>
<tr><td><code id="plotCalibration_+3A_lwd">lwd</code></td>
<td>
<p>Vector with line widths, one for each element of
object. Passed to <code><a href="graphics.html#topic+lines">lines</a></code>.</p>
</td></tr>
<tr><td><code id="plotCalibration_+3A_lty">lty</code></td>
<td>
<p>lwd Vector with line style, one for each element of
object.  Passed to <code><a href="graphics.html#topic+lines">lines</a></code>.</p>
</td></tr>
<tr><td><code id="plotCalibration_+3A_pch">pch</code></td>
<td>
<p>Passed to <code><a href="graphics.html#topic+lines">lines</a></code>.</p>
</td></tr>
<tr><td><code id="plotCalibration_+3A_type">type</code></td>
<td>
<p>Passed to <code><a href="graphics.html#topic+lines">lines</a></code>.</p>
</td></tr>
<tr><td><code id="plotCalibration_+3A_percent">percent</code></td>
<td>
<p>If TRUE axes labels are multiplied by 100 and thus
interpretable on a percent scale.</p>
</td></tr>
<tr><td><code id="plotCalibration_+3A_na.action">na.action</code></td>
<td>
<p>what to do with NA values. Passed to
<code><a href="stats.html#topic+model.frame">model.frame</a></code></p>
</td></tr>
<tr><td><code id="plotCalibration_+3A_cex">cex</code></td>
<td>
<p>Default cex used for legend and labels.</p>
</td></tr>
<tr><td><code id="plotCalibration_+3A_...">...</code></td>
<td>
<p>Used to control the subroutines: plot, axis, lines,
barplot, legend, addtable2plot, points (pseudo values), rug. See
<code><a href="prodlim.html#topic+SmartControl">SmartControl</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In uncensored data, the observed frequency of the outcome event is calculated locally at the predicted risk.
In right censored data with and without competing risks, the actual risk
is calculated using the Kaplan-Meier and the Aalen-Johansen method, respectively,
locally at the predicted risk.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(prodlim)
# binary
set.seed(10)
db=sampleData(100,outcome="binary")
fb1=glm(Y~X1+X5+X7,data=db,family="binomial")
fb2=glm(Y~X1+X3+X6+X7,data=db,family="binomial")
xb=Score(list(model1=fb1,model2=fb2),Y~1,data=db,
          plots="cal")
plotCalibration(xb,brier.in.legend=TRUE)
plotCalibration(xb,bars=TRUE,model="model1")
plotCalibration(xb,models=1,bars=TRUE,names.cex=1.3)

# survival
library(survival)
library(prodlim)
dslearn=sampleData(56,outcome="survival")
dstest=sampleData(100,outcome="survival")
fs1=coxph(Surv(time,event)~X1+X5+X7,data=dslearn,x=1)
fs2=coxph(Surv(time,event)~strata(X1)+X3+X6+X7,data=dslearn,x=1)
xs=Score(list(Cox1=fs1,Cox2=fs2),Surv(time,event)~1,data=dstest,
          plots="cal",metrics=NULL)
plotCalibration(xs)
plotCalibration(xs,cens.method="local",pseudo=1)
plotCalibration(xs,method="quantile")


# competing risks

## Not run: 
data(Melanoma)
f1 &lt;- CSC(Hist(time,status)~age+sex+epicel+ulcer,data=Melanoma)
f2 &lt;- CSC(Hist(time,status)~age+sex+logthick+epicel+ulcer,data=Melanoma)
x &lt;- Score(list(model1=f1,model2=f2),Hist(time,status)~1,data=Melanoma,
           cause= 2,times=5*365.25,plots="cal")
plotCalibration(x)

## End(Not run)

</code></pre>

<hr>
<h2 id='plotEffects'>Plotting time-varying effects from a risk regression model.</h2><span id='topic+plotEffects'></span>

<h3>Description</h3>

<p>Plot time-varying effects from a risk regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotEffects(
  x,
  formula,
  level,
  ref.line = TRUE,
  conf.int = 0.95,
  xlim,
  ylim,
  xlab = "Time",
  ylab = "Cumulative coefficient",
  col,
  lty,
  lwd,
  add = FALSE,
  legend,
  axes = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotEffects_+3A_x">x</code></td>
<td>
<p>Fitted object obtained with one of <code>ARR</code>, <code>LRR</code>,
<code>riskRegression</code>.</p>
</td></tr>
<tr><td><code id="plotEffects_+3A_formula">formula</code></td>
<td>
<p>A formula to specify the variable(s) whose regression
coefficients should be plotted.</p>
</td></tr>
<tr><td><code id="plotEffects_+3A_level">level</code></td>
<td>
<p>For categorical variables the level (group) whose contrast to
the reference level (group) should be plotted.</p>
</td></tr>
<tr><td><code id="plotEffects_+3A_ref.line">ref.line</code></td>
<td>
<p>Logical. If <code>TRUE</code> then add a horizontal line at zero.</p>
</td></tr>
<tr><td><code id="plotEffects_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical. If <code>TRUE</code> then add confidence limits.  Can be
controlled using smart arguments. See examples</p>
</td></tr>
<tr><td><code id="plotEffects_+3A_xlim">xlim</code></td>
<td>
<p>See <code>plot</code></p>
</td></tr>
<tr><td><code id="plotEffects_+3A_ylim">ylim</code></td>
<td>
<p>See <code>plot</code></p>
</td></tr>
<tr><td><code id="plotEffects_+3A_xlab">xlab</code></td>
<td>
<p>See <code>plot</code></p>
</td></tr>
<tr><td><code id="plotEffects_+3A_ylab">ylab</code></td>
<td>
<p>See <code>plot</code></p>
</td></tr>
<tr><td><code id="plotEffects_+3A_col">col</code></td>
<td>
<p>A vector of colors for the regression coefficients.</p>
</td></tr>
<tr><td><code id="plotEffects_+3A_lty">lty</code></td>
<td>
<p>A vector of line types for the regression coefficients.</p>
</td></tr>
<tr><td><code id="plotEffects_+3A_lwd">lwd</code></td>
<td>
<p>A vector of line thicknesses for the regression coefficients.</p>
</td></tr>
<tr><td><code id="plotEffects_+3A_add">add</code></td>
<td>
<p>Logical. If <code>TRUE</code> then add lines to an existing plot.</p>
</td></tr>
<tr><td><code id="plotEffects_+3A_legend">legend</code></td>
<td>
<p>Logical. If <code>TRUE</code> then add a legend. Can be controlled
using smart arguments. See examples.</p>
</td></tr>
<tr><td><code id="plotEffects_+3A_axes">axes</code></td>
<td>
<p>Logical. If <code>FALSE</code> then do not draw axes.</p>
</td></tr>
<tr><td><code id="plotEffects_+3A_...">...</code></td>
<td>
<p>Used for transclusion of smart arguments for <code>plot</code>,
<code>axis</code>. See function <code><a href="prodlim.html#topic+SmartControl">SmartControl</a></code> from prodlim.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas H. Scheike <a href="mailto:ts@biostat.ku.dk">ts@biostat.ku.dk</a>
</p>
<p>Thomas A. Gerds <a href="mailto:tag@biostat.ku.dk">tag@biostat.ku.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(survival)
library(prodlim)
data(Melanoma)

fit.tarr &lt;- ARR(Hist(time,status)~strata(sex),
                data=Melanoma,
                cause=1)
plotEffects(fit.tarr)

fit.tarr &lt;- ARR(Hist(time,status)~strata(sex)+strata(invasion),
                data=Melanoma,
                cause=1,
                times=seq(800,3000,20))
plotEffects(fit.tarr,formula=~sex)
plotEffects(fit.tarr,formula=~invasion)
plotEffects(fit.tarr,
            formula=~invasion,
            level="invasionlevel.1")

## legend arguments are transcluded:
plotEffects(fit.tarr,
            formula=~invasion,
            legend.bty="b",
            legend.cex=1)

## and other smart arguments too:
plotEffects(fit.tarr,
	    formula=~invasion,
	    legend.bty="b",
axis2.las=2,
	    legend.cex=1)


</code></pre>

<hr>
<h2 id='plotPredictRisk'>Plotting predicted risks curves.</h2><span id='topic+plotPredictRisk'></span>

<h3>Description</h3>

<p>Time-dependent event risk predictions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPredictRisk(
  x,
  newdata,
  times,
  cause = 1,
  xlim,
  ylim,
  xlab,
  ylab,
  axes = TRUE,
  col,
  density,
  lty,
  lwd,
  add = FALSE,
  legend = TRUE,
  percent = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPredictRisk_+3A_x">x</code></td>
<td>
<p>Object specifying an event risk prediction model.</p>
</td></tr>
<tr><td><code id="plotPredictRisk_+3A_newdata">newdata</code></td>
<td>
<p>A data frame with the same variable names as those that were
used to fit the model <code>x</code>.</p>
</td></tr>
<tr><td><code id="plotPredictRisk_+3A_times">times</code></td>
<td>
<p>Vector of times at which to return the estimated probabilities.</p>
</td></tr>
<tr><td><code id="plotPredictRisk_+3A_cause">cause</code></td>
<td>
<p>Show predicted risk of events of this cause</p>
</td></tr>
<tr><td><code id="plotPredictRisk_+3A_xlim">xlim</code></td>
<td>
<p>Plotting range on the x-axis.</p>
</td></tr>
<tr><td><code id="plotPredictRisk_+3A_ylim">ylim</code></td>
<td>
<p>Plotting range on the y-axis.</p>
</td></tr>
<tr><td><code id="plotPredictRisk_+3A_xlab">xlab</code></td>
<td>
<p>Label given to the x-axis.</p>
</td></tr>
<tr><td><code id="plotPredictRisk_+3A_ylab">ylab</code></td>
<td>
<p>Label given to the y-axis.</p>
</td></tr>
<tr><td><code id="plotPredictRisk_+3A_axes">axes</code></td>
<td>
<p>Logical. If <code>FALSE</code> no axes are drawn.</p>
</td></tr>
<tr><td><code id="plotPredictRisk_+3A_col">col</code></td>
<td>
<p>Vector of colors given to the survival curve.</p>
</td></tr>
<tr><td><code id="plotPredictRisk_+3A_density">density</code></td>
<td>
<p>Densitiy of the color &ndash; useful for showing many
(overlapping) curves.</p>
</td></tr>
<tr><td><code id="plotPredictRisk_+3A_lty">lty</code></td>
<td>
<p>Vector of lty's given to the survival curve.</p>
</td></tr>
<tr><td><code id="plotPredictRisk_+3A_lwd">lwd</code></td>
<td>
<p>Vector of lwd's given to the survival curve.</p>
</td></tr>
<tr><td><code id="plotPredictRisk_+3A_add">add</code></td>
<td>
<p>Logical. If <code>TRUE</code> only lines are added to an existing
device</p>
</td></tr>
<tr><td><code id="plotPredictRisk_+3A_legend">legend</code></td>
<td>
<p>Logical. If TRUE a legend is plotted by calling the function
legend.  Optional arguments of the function <code>legend</code> can be given in
the form <code>legend.x=val</code> where x is the name of the argument and val the
desired value. See also Details.</p>
</td></tr>
<tr><td><code id="plotPredictRisk_+3A_percent">percent</code></td>
<td>
<p>Logical. If <code>TRUE</code> the y-axis is labeled in percent.</p>
</td></tr>
<tr><td><code id="plotPredictRisk_+3A_...">...</code></td>
<td>
<p>Parameters that are filtered by <code><a href="prodlim.html#topic+SmartControl">SmartControl</a></code> and
then passed to the functions: <code><a href="graphics.html#topic+plot">plot</a></code>, <code><a href="graphics.html#topic+axis">axis</a></code>,
<code><a href="graphics.html#topic+legend">legend</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Arguments for the invoked functions <code>legend</code> and <code>axis</code> can be
specified as <code>legend.lty=2</code>. The specification is not case sensitive,
thus <code>Legend.lty=2</code> or <code>LEGEND.lty=2</code> will have the same effect.
The function <code>axis</code> is called twice, and arguments of the form
<code>axis1.labels</code>, <code>axis1.at</code> are used for the time axis whereas
<code>axis2.pos</code>, <code>axis1.labels</code>, etc., are used for the y-axis.
</p>
<p>These arguments are processed via <code>...{}</code> of
<code>plotPredictRisk</code> and inside by using the function
<code>SmartControl</code>.
</p>


<h3>Value</h3>

<p>The (invisible) object.
</p>


<h3>Author(s)</h3>

<p>Ulla B. Mogensen and Thomas A. Gerds <a href="mailto:tag@biostat.ku.dk">tag@biostat.ku.dk</a>
</p>


<h3>References</h3>

<p>Ulla B. Mogensen, Hemant Ishwaran, Thomas A. Gerds (2012).
Evaluating Random Forests for Survival Analysis Using Prediction Error
Curves. Journal of Statistical Software, 50(11), 1-23. URL
http://www.jstatsoft.org/v50/i11/.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotRisk">plotRisk</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(survival)
# generate survival data
# no effect
set.seed(8)
d &lt;- sampleData(80,outcome="survival",formula = ~f(X6, 0) + f(X7, 0))
d[,table(event)]
f &lt;- coxph(Surv(time,event)~X6+X7,data=d,x=1)
plotPredictRisk(f)

# large effect
set.seed(8)
d &lt;- sampleData(80,outcome="survival",formula = ~f(X6, 0.1) + f(X7, -0.1))
d[,table(event)]
f &lt;- coxph(Surv(time,event)~X6+X7,data=d,x=1)
plotPredictRisk(f)

# generate competing risk data
# small effect
set.seed(8)
d &lt;- sampleData(40,formula = ~f(X6, 0.01) + f(X7, -0.01))
d[,table(event)]
f &lt;- CSC(Hist(time,event)~X5+X6,data=d)
plotPredictRisk(f)

# large effect
set.seed(8)
d &lt;- sampleData(40,formula = ~f(X6, 0.1) + f(X7, -0.1))
d[,table(event)]
f &lt;- CSC(Hist(time,event)~X5+X6,data=d)
plotPredictRisk(f)
</code></pre>

<hr>
<h2 id='plotRisk'>plot predicted risks</h2><span id='topic+plotRisk'></span>

<h3>Description</h3>

<p>plot predicted risks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotRisk(
  x,
  models,
  times,
  xlim = c(0, 1),
  ylim = c(0, 1),
  xlab,
  ylab,
  col,
  pch,
  cex = 1,
  preclipse = 0,
  preclipse.shade = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotRisk_+3A_x">x</code></td>
<td>
<p>Object obtained with function <code>Score</code></p>
</td></tr>
<tr><td><code id="plotRisk_+3A_models">models</code></td>
<td>
<p>Choice of two models to plot. The predicted risks of
the first (second) are shown along the x-axis (y-axis).</p>
</td></tr>
<tr><td><code id="plotRisk_+3A_times">times</code></td>
<td>
<p>Time point specifying the prediction horizon.</p>
</td></tr>
<tr><td><code id="plotRisk_+3A_xlim">xlim</code></td>
<td>
<p>x-axis limits</p>
</td></tr>
<tr><td><code id="plotRisk_+3A_ylim">ylim</code></td>
<td>
<p>y-axis limits</p>
</td></tr>
<tr><td><code id="plotRisk_+3A_xlab">xlab</code></td>
<td>
<p>x-axis labels</p>
</td></tr>
<tr><td><code id="plotRisk_+3A_ylab">ylab</code></td>
<td>
<p>y-axis labels</p>
</td></tr>
<tr><td><code id="plotRisk_+3A_col">col</code></td>
<td>
<p>Colors used according to the outcome.
binary outcome (two colors: no event, event),
survival outcome (three colors: censored, event, no event)
competing risk outcome (4 or more colors: event, competing risk 1, ..., competing risk k, censored, no event)</p>
</td></tr>
<tr><td><code id="plotRisk_+3A_pch">pch</code></td>
<td>
<p>Symbols used according to the outcome
binary outcome (two symbols: no event, event),
survival outcome (three symbols: censored, event, no event)
competing risk outcome (4 or more symbols: event, competing risk 1, ..., competing risk k, censored, no event)</p>
</td></tr>
<tr><td><code id="plotRisk_+3A_cex">cex</code></td>
<td>
<p>point size</p>
</td></tr>
<tr><td><code id="plotRisk_+3A_preclipse">preclipse</code></td>
<td>
<p>Value between 0 and 1 defining the preclipse area</p>
</td></tr>
<tr><td><code id="plotRisk_+3A_preclipse.shade">preclipse.shade</code></td>
<td>
<p>Logical. If <code>TRUE</code> shade the area of clinically meaningful change.</p>
</td></tr>
<tr><td><code id="plotRisk_+3A_...">...</code></td>
<td>
<p>Used to control the subroutines: plot, axis, lines,
barplot, legend. See <code><a href="prodlim.html#topic+SmartControl">SmartControl</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two rival prediction models are applied to the same data.
</p>


<h3>Value</h3>

<p>a nice graph
</p>


<h3>Author(s)</h3>

<p>Thomas A. Gerds &lt;tag@biostat.ku.dk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(prodlim)
## uncensored
set.seed(10)
learndat = sampleData(40,outcome="binary")
testdat = sampleData(40,outcome="binary")
lr1 = glm(Y~X1+X2+X7+X9,data=learndat,family="binomial")
lr2 = glm(Y~X3+X5+X6,data=learndat,family="binomial")
xb=Score(list("LR(X1+X2+X7+X9)"=lr1,"LR(X3+X5+X6)"=lr2),formula=Y~1,
         data=testdat,summary="risks",null.model=0L)
plotRisk(xb)
## survival
library(survival)
set.seed(10)
learndat = sampleData(40,outcome="survival")
testdat = sampleData(40,outcome="survival")
cox1 = coxph(Surv(time,event)~X1+X2+X7+X9,data=learndat,x=TRUE)
cox2 = coxph(Surv(time,event)~X3+X5+X6,data=learndat,x=TRUE)
xs=Score(list("Cox(X1+X2+X7+X9)"=cox1,"Cox(X3+X5+X6)"=cox2),formula=Surv(time,event)~1,
         data=testdat,summary="risks",null.model=0L,times=c(3,5,6))
plotRisk(xs,times=5)
## competing risk
## Not run: 
library(prodlim)
library(survival)
set.seed(8)
learndat = sampleData(80,outcome="competing.risk")
testdat = sampleData(140,outcome="competing.risk")
m1 = FGR(Hist(time,event)~X2+X7+X9,data=learndat,cause=1)
m2 = CSC(Hist(time,event)~X2+X7+X9,data=learndat,cause=1)
xcr=Score(list("FGR"=m1,"CSC"=m2),formula=Hist(time,event)~1,
         data=testdat,summary="risks",null.model=0L,times=c(3,5))
plotRisk(xcr,times=3)

## End(Not run)
</code></pre>

<hr>
<h2 id='plotROC'>Plot ROC curves</h2><span id='topic+plotROC'></span>

<h3>Description</h3>

<p>Plot ROC curve
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotROC(
  x,
  models,
  times,
  xlab = "1-Specificity",
  ylab = "Sensitivity",
  col,
  lwd,
  lty = 1,
  cex = 1,
  pch = 1,
  legend = !add,
  auc.in.legend = TRUE,
  brier.in.legend = FALSE,
  add = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotROC_+3A_x">x</code></td>
<td>
<p>Object obtained with function <code>Score</code></p>
</td></tr>
<tr><td><code id="plotROC_+3A_models">models</code></td>
<td>
<p>Choice of models to plot</p>
</td></tr>
<tr><td><code id="plotROC_+3A_times">times</code></td>
<td>
<p>Time point(s) specifying the prediction horizon</p>
</td></tr>
<tr><td><code id="plotROC_+3A_xlab">xlab</code></td>
<td>
<p>Label for x-axis</p>
</td></tr>
<tr><td><code id="plotROC_+3A_ylab">ylab</code></td>
<td>
<p>Label for y-axis</p>
</td></tr>
<tr><td><code id="plotROC_+3A_col">col</code></td>
<td>
<p>line color</p>
</td></tr>
<tr><td><code id="plotROC_+3A_lwd">lwd</code></td>
<td>
<p>line width</p>
</td></tr>
<tr><td><code id="plotROC_+3A_lty">lty</code></td>
<td>
<p>line style</p>
</td></tr>
<tr><td><code id="plotROC_+3A_cex">cex</code></td>
<td>
<p>point size</p>
</td></tr>
<tr><td><code id="plotROC_+3A_pch">pch</code></td>
<td>
<p>point style</p>
</td></tr>
<tr><td><code id="plotROC_+3A_legend">legend</code></td>
<td>
<p>logical. If <code>1L</code> draw a legend with the values
of AUC.</p>
</td></tr>
<tr><td><code id="plotROC_+3A_auc.in.legend">auc.in.legend</code></td>
<td>
<p>Logical. If <code>TRUE</code> add AUC to legend.</p>
</td></tr>
<tr><td><code id="plotROC_+3A_brier.in.legend">brier.in.legend</code></td>
<td>
<p>Logical. If <code>TRUE</code> add Brier score to
legend.</p>
</td></tr>
<tr><td><code id="plotROC_+3A_add">add</code></td>
<td>
<p>logical. If <code>1L</code> add lines to an existing plot.</p>
</td></tr>
<tr><td><code id="plotROC_+3A_...">...</code></td>
<td>
<p>Used for additional control of the subroutines: plot,
axis, lines, legend, addtable2plot. See <code><a href="prodlim.html#topic+SmartControl">SmartControl</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## binary
set.seed(18)
if (require("randomForest",quietly=TRUE)){
library(randomForest)
library(prodlim)
bdl &lt;- sampleData(40,outcome="binary")
bdt &lt;- sampleData(58,outcome="binary")
bdl[,y:=factor(Y)]
bdt[,y:=factor(Y)]
fb1 &lt;- glm(y~X1+X2+X3+X4+X5+X6+X7+X8+X9+X10,data=bdl,family="binomial")
fb2 &lt;- randomForest(y~X1+X2+X3+X4+X5+X6+X7+X8+X9+X10,data=bdl)
xb &lt;- Score(list("glm"=fb1,"rf"=fb2),y~1,data=bdt,
            plots="roc",metrics=c("auc","brier"))
plotROC(xb,brier.in.legend=1L)

# with cross-validation
## Not run: 
xb3 &lt;- Score(list("glm"=fb1,"rf"=fb2),y~1,data=bdl,
            plots="roc",B=3,split.method="bootcv",
            metrics=c("auc"))

## End(Not run)
}
## survival
set.seed(18)
library(survival)
sdl &lt;- sampleData(40,outcome="survival")
sdt &lt;- sampleData(58,outcome="survival")
fs1 &lt;- coxph(Surv(time,event)~X3+X5+X6+X7+X8+X10,data=sdl,x=TRUE)
fs2 &lt;- coxph(Surv(time,event)~X1+X2+X9,data=sdl,x=TRUE)
xs &lt;- Score(list(model1=fs1,model2=fs2),Hist(time,event)~1,data=sdt,
            times=5,plots="roc",metrics="auc")
plotROC(xs)
## competing risks
data(Melanoma)
f1 &lt;- CSC(Hist(time,status)~age+sex+epicel+ulcer,data=Melanoma)
f2 &lt;- CSC(Hist(time,status)~age+sex+logthick+epicel+ulcer,data=Melanoma)
x &lt;- Score(list(model1=f1,model2=f2),Hist(time,status)~1,data=Melanoma,
            cause=1,times=5*365.25,plots="roc",metrics="auc")
plotROC(x)
</code></pre>

<hr>
<h2 id='predict.CauseSpecificCox'>Predicting Absolute Risk from Cause-Specific Cox Models</h2><span id='topic+predict.CauseSpecificCox'></span><span id='topic+predictBig.CauseSpecificCox'></span>

<h3>Description</h3>

<p>Apply formula to combine two or more Cox models into absolute risk (cumulative incidence function).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CauseSpecificCox'
predict(
  object,
  newdata,
  times,
  cause,
  type = "absRisk",
  landmark = NA,
  keep.times = 1L,
  keep.newdata = 1L,
  keep.strata = 1L,
  se = FALSE,
  band = FALSE,
  iid = FALSE,
  confint = (se + band) &gt; 0,
  average.iid = FALSE,
  product.limit = TRUE,
  store.iid = "full",
  diag = FALSE,
  max.time = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.CauseSpecificCox_+3A_object">object</code></td>
<td>
<p>The fitted cause specific Cox model</p>
</td></tr>
<tr><td><code id="predict.CauseSpecificCox_+3A_newdata">newdata</code></td>
<td>
<p>[data.frame or data.table]  Contain the values of the predictor variables
defining subject specific predictions relative to each cause.
Should have the same structure as the data set used to fit the <code>object</code>.</p>
</td></tr>
<tr><td><code id="predict.CauseSpecificCox_+3A_times">times</code></td>
<td>
<p>[numeric vector] Time points at which to return
the estimated absolute risk.</p>
</td></tr>
<tr><td><code id="predict.CauseSpecificCox_+3A_cause">cause</code></td>
<td>
<p>[integer/character] Identifies the cause of interest among the competing
events.</p>
</td></tr>
<tr><td><code id="predict.CauseSpecificCox_+3A_type">type</code></td>
<td>
<p>[character] Can be changed to <code>"survival"</code> if the event free survival should be output instead of the absolute risk.</p>
</td></tr>
<tr><td><code id="predict.CauseSpecificCox_+3A_landmark">landmark</code></td>
<td>
<p>[integer] The starting time for the computation of the cumulative risk.</p>
</td></tr>
<tr><td><code id="predict.CauseSpecificCox_+3A_keep.times">keep.times</code></td>
<td>
<p>[logical] If <code>TRUE</code> add the evaluation times to the output.</p>
</td></tr>
<tr><td><code id="predict.CauseSpecificCox_+3A_keep.newdata">keep.newdata</code></td>
<td>
<p>[logical] If <code>TRUE</code> add the value of the covariates used to make the prediction in the output list.</p>
</td></tr>
<tr><td><code id="predict.CauseSpecificCox_+3A_keep.strata">keep.strata</code></td>
<td>
<p>[logical] If <code>TRUE</code> add the value of the strata used to make the prediction in the output list.</p>
</td></tr>
<tr><td><code id="predict.CauseSpecificCox_+3A_se">se</code></td>
<td>
<p>[logical] If <code>TRUE</code> compute and add the standard errors to the output.</p>
</td></tr>
<tr><td><code id="predict.CauseSpecificCox_+3A_band">band</code></td>
<td>
<p>[logical] If <code>TRUE</code> compute and add the quantiles for the confidence bands to the output.</p>
</td></tr>
<tr><td><code id="predict.CauseSpecificCox_+3A_iid">iid</code></td>
<td>
<p>[logical] If <code>TRUE</code> compute and add the influence function to the output.</p>
</td></tr>
<tr><td><code id="predict.CauseSpecificCox_+3A_confint">confint</code></td>
<td>
<p>[logical] If <code>TRUE</code> compute and add the confidence intervals/bands to the output.
They are computed applying the <code>confint</code> function to the output.</p>
</td></tr>
<tr><td><code id="predict.CauseSpecificCox_+3A_average.iid">average.iid</code></td>
<td>
<p>[logical]. If <code>TRUE</code> add the average of the influence function over <code>newdata</code> to the output.</p>
</td></tr>
<tr><td><code id="predict.CauseSpecificCox_+3A_product.limit">product.limit</code></td>
<td>
<p>[logical]. If <code>TRUE</code> the survival is computed using the product limit estimator.
Otherwise the exponential approximation is used (i.e. exp(-cumulative hazard)).</p>
</td></tr>
<tr><td><code id="predict.CauseSpecificCox_+3A_store.iid">store.iid</code></td>
<td>
<p>[character] Implementation used to estimate the influence function and the standard error.
Can be <code>"full"</code> or <code>"minimal"</code>.</p>
</td></tr>
<tr><td><code id="predict.CauseSpecificCox_+3A_diag">diag</code></td>
<td>
<p>[logical] when <code>FALSE</code> the absolute risk/survival for all observations at all times is computed,
otherwise it is only computed for the i-th observation at the i-th time.</p>
</td></tr>
<tr><td><code id="predict.CauseSpecificCox_+3A_max.time">max.time</code></td>
<td>
<p>[numeric] maximum time of the response of the fitted data.  Only relevant if
model <code>response</code> element has been removed</p>
</td></tr>
<tr><td><code id="predict.CauseSpecificCox_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the absolute risk as given by formula 2 of (Ozenne et al., 2017).
Confidence intervals and confidence bands can be computed using a first order von Mises expansion.
See the section &quot;Construction of the confidence intervals&quot; in (Ozenne et al., 2017).
</p>
<p>A detailed explanation about the meaning of the argument <code>store.iid</code> can be found
in (Ozenne et al., 2017) Appendix B &quot;Saving the influence functions&quot;.
</p>
<p>Note: for Cox regression models with time varying
covariates it does not make sense to use this function, because
the predicted risk has to be a measurable function of the data
available at the time origin.
</p>
<p>The iid decomposition is output using an array containing the value of the influence
of each subject used to fit the object (dim 1),
for each subject in newdata (dim 3),
and each time (dim 2).
</p>


<h3>Author(s)</h3>

<p>Brice Ozenne broz@sund.ku.dk, Thomas A. Gerds
tag@biostat.ku.dk
</p>


<h3>References</h3>

<p>Brice Ozenne, Anne Lyngholm Sorensen, Thomas Scheike, Christian Torp-Pedersen and Thomas Alexander Gerds.
riskRegression: Predicting the Risk of an Event using Cox Regression Models.
The R Journal (2017) 9:2, pages 440-460.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+confint.predictCSC">confint.predictCSC</a></code> to compute confidence intervals/bands.
<code><a href="#topic+autoplot.predictCSC">autoplot.predictCSC</a></code> to display the predictions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(survival)
library(prodlim)
#### generate data ####
set.seed(5)
d &lt;- sampleData(80,outcome="comp") ## training dataset
nd &lt;- sampleData(4,outcome="comp") ## validation dataset
d$time &lt;- round(d$time,1) ## create tied events
ttt &lt;- sort(sample(x = unique(d$time), size = 10))

## estimate a CSC model based on the coxph function
CSC.fit &lt;- CSC(Hist(time,event)~ X3+X8, data=d, method = "breslow")

## compute the absolute risk of cause 1, in the validation dataset
## at time 1:10
CSC.risk &lt;-  predict(CSC.fit, newdata=nd, times=1:10, cause=1)
CSC.risk

## compute absolute risks with CI for cause 2
## (without displaying the value of the covariates)
predict(CSC.fit,newdata=nd,times=1:10,cause=2,se=TRUE,
        keep.newdata = FALSE)

## other example
library(survival)
CSC.fit.s &lt;- CSC(list(Hist(time,event)~ strata(X1)+X2+X9,
 Hist(time,event)~ X2+strata(X4)+X8+X7),data=d, method = "breslow")
predict(CSC.fit.s,cause=1,times=ttt,se=1L) ## note: absRisk&gt;1 due to small number of observations

## using the cph function instead of coxph
CSC.cph &lt;- CSC(Hist(time,event)~ X1+X2,data=d, method = "breslow", fitter = "cph")#' 
predict(CSC.cph, newdata = d, cause = 2, times = ttt)

## landmark analysis
T0 &lt;- 1
predCSC.afterT0 &lt;- predict(CSC.fit, newdata = d, cause = 2, times = ttt[ttt&gt;T0], landmark = T0)
predCSC.afterT0
</code></pre>

<hr>
<h2 id='predict.FGR'>Predict subject specific risks (cumulative incidence) based on Fine-Gray regression model</h2><span id='topic+predict.FGR'></span>

<h3>Description</h3>

<p>Predict subject specific risks (cumulative incidence) based on Fine-Gray regression model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'FGR'
predict(object, newdata, times, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.FGR_+3A_object">object</code></td>
<td>
<p>Result of call to <code>FGR</code></p>
</td></tr>
<tr><td><code id="predict.FGR_+3A_newdata">newdata</code></td>
<td>
<p>Predictor values of subjects for who to predict risks</p>
</td></tr>
<tr><td><code id="predict.FGR_+3A_times">times</code></td>
<td>
<p>Time points at which to evaluate the risks</p>
</td></tr>
<tr><td><code id="predict.FGR_+3A_...">...</code></td>
<td>
<p>passed to predict.crr</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(prodlim)
library(survival)
set.seed(10)
d &lt;- sampleData(101, outcome = "competing.risk")
tFun&lt;-function(t) {t}
fgr&lt;-FGR(Hist(time, event)~X1+strata(X2)+X6+cov2(X7, tf=tFun),
         data=d, cause=1)
predictRisk(fgr,times=5,newdata=d[1:10])
</code></pre>

<hr>
<h2 id='predict.riskRegression'>Predict individual risk.</h2><span id='topic+predict.riskRegression'></span>

<h3>Description</h3>

<p>Extract predictions from a risk prediction model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'riskRegression'
predict(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.riskRegression_+3A_object">object</code></td>
<td>
<p>Fitted object obtained with one of <code>ARR</code>, <code>LRR</code>,
<code>riskRegression</code>.</p>
</td></tr>
<tr><td><code id="predict.riskRegression_+3A_newdata">newdata</code></td>
<td>
<p>A data frame containing predictor variable combinations for
which to compute predicted risk.</p>
</td></tr>
<tr><td><code id="predict.riskRegression_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas H. Scheike <a href="mailto:ts@biostat.ku.dk">ts@biostat.ku.dk</a>
</p>
<p>Thomas A. Gerds <a href="mailto:tag@biostat.ku.dk">tag@biostat.ku.dk</a>
</p>


<h3>References</h3>

<p>Gerds, TA and Scheike, T and Andersen, PK (2011) Absolute risk
regression for competing risks: interpretation, link functions and
prediction Research report 11/8. Department of Biostatistics, University of
Copenhagen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Melanoma)
library(prodlim)
library(survival)

fit.tarr &lt;- ARR(Hist(time,status)~age+invasion+strata(sex),data=Melanoma,cause=1)
predict(fit.tarr,newdata=data.frame(age=48,
                     invasion=factor("level.1",
                         levels=levels(Melanoma$invasion)),
                     sex=factor("Female",levels=levels(Melanoma$sex))))
predict(fit.tarr,newdata=data.frame(age=48,
                     invasion=factor("level.1",
                         levels=levels(Melanoma$invasion)),
                     sex=factor("Male",levels=levels(Melanoma$sex))))
predict(fit.tarr,newdata=data.frame(age=c(48,58,68),
                     invasion=factor("level.1",
                         levels=levels(Melanoma$invasion)),
                     sex=factor("Male",levels=levels(Melanoma$sex))))
predict(fit.tarr,newdata=Melanoma[1:4,])

</code></pre>

<hr>
<h2 id='predictCox'>Fast computation of survival probabilities, hazards and cumulative hazards from Cox regression models</h2><span id='topic+predictCox'></span>

<h3>Description</h3>

<p>Fast routine to get baseline hazards and subject specific hazards
as well as survival probabilities from a <code>survival::coxph</code> or <code>rms::cph</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictCox(
  object,
  times,
  newdata = NULL,
  centered = TRUE,
  type = c("cumhazard", "survival"),
  keep.strata = TRUE,
  keep.times = TRUE,
  keep.newdata = FALSE,
  keep.infoVar = FALSE,
  se = FALSE,
  band = FALSE,
  iid = FALSE,
  confint = (se + band) &gt; 0,
  diag = FALSE,
  average.iid = FALSE,
  store.iid = "full"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictCox_+3A_object">object</code></td>
<td>
<p>The fitted Cox regression model object either
obtained with <code>coxph</code> (survival package) or <code>cph</code>
(rms package).</p>
</td></tr>
<tr><td><code id="predictCox_+3A_times">times</code></td>
<td>
<p>[numeric vector] Time points at which to return
the estimated hazard/cumulative hazard/survival.</p>
</td></tr>
<tr><td><code id="predictCox_+3A_newdata">newdata</code></td>
<td>
<p>[data.frame or data.table]  Contain the values of the predictor variables
defining subject specific predictions.
Should have the same structure as the data set used to fit the <code>object</code>.</p>
</td></tr>
<tr><td><code id="predictCox_+3A_centered">centered</code></td>
<td>
<p>[logical] If <code>TRUE</code> return prediction at the
mean values of the covariates <code>fit$mean</code>, if <code>FALSE</code>
return a prediction for all covariates equal to zero.  in the
linear predictor. Will be ignored if argument <code>newdata</code> is
used. For internal use.</p>
</td></tr>
<tr><td><code id="predictCox_+3A_type">type</code></td>
<td>
<p>[character vector] the type of predicted value. Choices are </p>

<ul>
<li> <p><code>"hazard"</code> the baseline hazard function when
argument <code>newdata</code> is not used and the hazard function
when argument <code>newdata</code> is used.  </p>
</li>
<li> <p><code>"cumhazard"</code>
the cumulative baseline hazard function when argument
<code>newdata</code> is not used and the cumulative hazard function
when argument <code>newdata</code> is used.  </p>
</li>
<li> <p><code>"survival"</code>
the survival baseline hazard function when argument
<code>newdata</code> is not used and the cumulative hazard function
when argument <code>newdata</code> is used.  </p>
</li></ul>
<p> Several choices can be
combined in a vector of strings that match (no matter the case)
strings <code>"hazard"</code>,<code>"cumhazard"</code>, <code>"survival"</code>.</p>
</td></tr>
<tr><td><code id="predictCox_+3A_keep.strata">keep.strata</code></td>
<td>
<p>[logical] If <code>TRUE</code> add the (newdata) strata
to the output. Only if there any.</p>
</td></tr>
<tr><td><code id="predictCox_+3A_keep.times">keep.times</code></td>
<td>
<p>[logical] If <code>TRUE</code> add the evaluation times
to the output.</p>
</td></tr>
<tr><td><code id="predictCox_+3A_keep.newdata">keep.newdata</code></td>
<td>
<p>[logical] If <code>TRUE</code> add the value of the
covariates used to make the prediction in the output list.</p>
</td></tr>
<tr><td><code id="predictCox_+3A_keep.infovar">keep.infoVar</code></td>
<td>
<p>[logical] For internal use.</p>
</td></tr>
<tr><td><code id="predictCox_+3A_se">se</code></td>
<td>
<p>[logical] If <code>TRUE</code> compute and add the standard errors to the output.</p>
</td></tr>
<tr><td><code id="predictCox_+3A_band">band</code></td>
<td>
<p>[logical] If <code>TRUE</code> compute and add the quantiles for the confidence bands to the output.</p>
</td></tr>
<tr><td><code id="predictCox_+3A_iid">iid</code></td>
<td>
<p>[logical] If <code>TRUE</code> compute and add the influence function to the output.</p>
</td></tr>
<tr><td><code id="predictCox_+3A_confint">confint</code></td>
<td>
<p>[logical] If <code>TRUE</code> compute and add the confidence intervals/bands to the output.
They are computed applying the <code>confint</code> function to the output.</p>
</td></tr>
<tr><td><code id="predictCox_+3A_diag">diag</code></td>
<td>
<p>[logical] when <code>FALSE</code> the hazard/cumlative hazard/survival for all observations at all times is computed,
otherwise it is only computed for the i-th observation at the i-th time.</p>
</td></tr>
<tr><td><code id="predictCox_+3A_average.iid">average.iid</code></td>
<td>
<p>[logical] If <code>TRUE</code> add the average of the influence function over <code>newdata</code> to the output.</p>
</td></tr>
<tr><td><code id="predictCox_+3A_store.iid">store.iid</code></td>
<td>
<p>[character] Implementation used to estimate the influence function and the standard error.
Can be <code>"full"</code> or <code>"minimal"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the argument <code>newdata</code> is not specified, the function computes the baseline hazard estimate.
See (Ozenne et al., 2017) section &quot;Handling of tied event times&quot;.
</p>
<p>Otherwise the function computes survival probabilities with confidence intervals/bands.
See (Ozenne et al., 2017) section &quot;Confidence intervals and confidence bands for survival probabilities&quot;.
The survival is computed using the exponential approximation (equation 3).
</p>
<p>A detailed explanation about the meaning of the argument <code>store.iid</code> can be found
in (Ozenne et al., 2017) Appendix B &quot;Saving the influence functions&quot;.
</p>
<p>The function is not compatible with time varying predictor variables.
</p>
<p>The centered argument enables us to reproduce the results obtained with the <code>basehaz</code>
function from the survival package but should not be modified by the user.
</p>
<p>The iid decomposition is output using an array containing the value of the influence
of each subject used to fit the object (dim 1),
for each subject in newdata (dim 3),
and each time (dim 2).
</p>


<h3>Author(s)</h3>

<p>Brice Ozenne broz@sund.ku.dk, Thomas A. Gerds tag@biostat.ku.dk
</p>


<h3>References</h3>

<p>Brice Ozenne, Anne Lyngholm Sorensen, Thomas Scheike, Christian Torp-Pedersen and Thomas Alexander Gerds.
riskRegression: Predicting the Risk of an Event using Cox Regression Models.
The R Journal (2017) 9:2, pages 440-460.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+confint.predictCox">confint.predictCox</a></code> to compute confidence intervals/bands.
<code><a href="#topic+autoplot.predictCox">autoplot.predictCox</a></code> to display the predictions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(survival)
library(data.table)

#### generate data ####
set.seed(10)
d &lt;- sampleData(40,outcome="survival") ## training dataset
nd &lt;- sampleData(4,outcome="survival") ## validation dataset
d$time &lt;- round(d$time,1) ## create tied events
# table(duplicated(d$time))

#### stratified Cox model ####
fit &lt;- coxph(Surv(time,event)~X1 + strata(X2) + X6,
             data=d, ties="breslow", x = TRUE, y = TRUE)

## compute the baseline cumulative hazard
fit.haz &lt;- predictCox(fit)
cbind(survival::basehaz(fit), fit.haz$cumhazard)

## compute individual specific cumulative hazard and survival probabilities 
fit.pred &lt;- predictCox(fit, newdata=nd, times=c(3,8), se = TRUE, band = TRUE)
fit.pred

####  other examples ####
# one strata variable
fitS &lt;- coxph(Surv(time,event)~strata(X1)+X2,
              data=d, ties="breslow", x = TRUE, y = TRUE)

predictCox(fitS)
predictCox(fitS, newdata=nd, times = 1)

# two strata variables
set.seed(1)
d$U=sample(letters[1:5],replace=TRUE,size=NROW(d))
d$V=sample(letters[4:10],replace=TRUE,size=NROW(d))
nd$U=sample(letters[1:5],replace=TRUE,size=NROW(nd))
nd$V=sample(letters[4:10],replace=TRUE,size=NROW(nd))
fit2S &lt;- coxph(Surv(time,event)~X1+strata(U)+strata(V)+X2,
              data=d, ties="breslow", x = TRUE, y = TRUE)

cbind(survival::basehaz(fit2S),predictCox(fit2S,type="cumhazard")$cumhazard)
predictCox(fit2S)
predictCox(fitS, newdata=nd, times = 3)

# left truncation
test2 &lt;- list(start=c(1,2,5,2,1,7,3,4,8,8), 
              stop=c(2,3,6,7,8,9,9,9,14,17), 
              event=c(1,1,1,1,1,1,1,0,0,0), 
              x=c(1,0,0,1,0,1,1,1,0,0)) 
m.cph &lt;- coxph(Surv(start, stop, event) ~ 1, test2, x = TRUE)
as.data.table(predictCox(m.cph))

basehaz(m.cph)
</code></pre>

<hr>
<h2 id='predictCoxPL'>Computation of survival probabilities from Cox regression models using the product limit estimator.</h2><span id='topic+predictCoxPL'></span>

<h3>Description</h3>

<p>Same as predictCox except that the survival is estimated using the product limit estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictCoxPL(
  object,
  times,
  newdata = NULL,
  type = c("cumhazard", "survival"),
  keep.strata = TRUE,
  keep.infoVar = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictCoxPL_+3A_object">object</code></td>
<td>
<p>The fitted Cox regression model object either
obtained with <code>coxph</code> (survival package) or <code>cph</code>
(rms package).</p>
</td></tr>
<tr><td><code id="predictCoxPL_+3A_times">times</code></td>
<td>
<p>[numeric vector] Time points at which to return
the estimated hazard/cumulative hazard/survival.</p>
</td></tr>
<tr><td><code id="predictCoxPL_+3A_newdata">newdata</code></td>
<td>
<p>[data.frame or data.table]  Contain the values of the predictor variables
defining subject specific predictions.
Should have the same structure as the data set used to fit the <code>object</code>.</p>
</td></tr>
<tr><td><code id="predictCoxPL_+3A_type">type</code></td>
<td>
<p>[character vector] the type of predicted value. Choices are </p>

<ul>
<li> <p><code>"hazard"</code> the baseline hazard function when
argument <code>newdata</code> is not used and the hazard function
when argument <code>newdata</code> is used.  </p>
</li>
<li> <p><code>"cumhazard"</code>
the cumulative baseline hazard function when argument
<code>newdata</code> is not used and the cumulative hazard function
when argument <code>newdata</code> is used.  </p>
</li>
<li> <p><code>"survival"</code>
the survival baseline hazard function when argument
<code>newdata</code> is not used and the cumulative hazard function
when argument <code>newdata</code> is used.  </p>
</li></ul>
<p> Several choices can be
combined in a vector of strings that match (no matter the case)
strings <code>"hazard"</code>,<code>"cumhazard"</code>, <code>"survival"</code>.</p>
</td></tr>
<tr><td><code id="predictCoxPL_+3A_keep.strata">keep.strata</code></td>
<td>
<p>[logical] If <code>TRUE</code> add the (newdata) strata
to the output. Only if there any.</p>
</td></tr>
<tr><td><code id="predictCoxPL_+3A_keep.infovar">keep.infoVar</code></td>
<td>
<p>[logical] For internal use.</p>
</td></tr>
<tr><td><code id="predictCoxPL_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to <code><a href="#topic+predictCox">predictCox</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: the iid and standard errors are computed using the exponential approximation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(survival)

#### generate data ####
set.seed(10)
d &lt;- sampleData(40,outcome="survival")
nd &lt;- sampleData(4,outcome="survival")
d$time &lt;- round(d$time,1)

#### Cox model ####
fit &lt;- coxph(Surv(time,event)~ X1 + X2 + X6,
             data=d, ties="breslow", x = TRUE, y = TRUE)

## exponential approximation
predictCox(fit, newdata = d, times = 1:5)

## product limit
predictCoxPL(fit, newdata = d, times = 1:5)

#### stratified Cox model ####
fitS &lt;- coxph(Surv(time,event)~ X1 + strata(X2) + X6,
             data=d, ties="breslow", x = TRUE, y = TRUE)

## exponential approximation
predictCox(fitS, newdata = d, times = 1:5)

## product limit
predictCoxPL(fitS, newdata = d, times = 1:5)

#### fully stratified Cox model ####
fitS &lt;- coxph(Surv(time,event)~ 1,
             data=d, ties="breslow", x = TRUE, y = TRUE)

## product limit
GS &lt;- survfit(Surv(time,event)~1, data = d)
range(predictCoxPL(fitS)$survival - GS$surv)

fitS &lt;- coxph(Surv(time,event)~ strata(X2),
             data=d, ties="breslow", x = TRUE, y = TRUE)

## product limit
GS &lt;- survfit(Surv(time,event)~X2, data = d)
range(predictCoxPL(fitS)$survival - GS$surv)

</code></pre>

<hr>
<h2 id='predictRisk'>Extrating predicting risks from regression models</h2><span id='topic+predictRisk'></span><span id='topic+predictRisk.CauseSpecificCox'></span><span id='topic+predictRisk.riskRegression'></span><span id='topic+predictRisk.FGR'></span><span id='topic+predictRisk.prodlim'></span><span id='topic+predictRisk.rfsrc'></span><span id='topic+predictRisk.aalen'></span><span id='topic+predictRisk.ARR'></span><span id='topic+predictRisk.cox.aalen'></span><span id='topic+predictRisk.coxph'></span><span id='topic+predictRisk.cph'></span><span id='topic+predictRisk.default'></span><span id='topic+predictRisk.matrix'></span><span id='topic+predictRisk.pecCtree'></span><span id='topic+predictRisk.pecCforest'></span><span id='topic+predictRisk.psm'></span><span id='topic+predictRisk.selectCox'></span><span id='topic+predictRisk.survfit'></span><span id='topic+predictRisk.randomForest'></span><span id='topic+predictRisk.lrm'></span><span id='topic+predictRisk.glm'></span><span id='topic+predictRisk.rpart'></span><span id='topic+predictRisk.gbm'></span><span id='topic+predictRisk.flexsurvreg'></span><span id='topic+predictRisk.double'></span><span id='topic+predictRisk.integer'></span><span id='topic+predictRisk.factor'></span><span id='topic+predictRisk.numeric'></span><span id='topic+predictRisk.multinom'></span><span id='topic+predictRisk.formula'></span><span id='topic+predictRisk.BinaryTree'></span><span id='topic+predictRisk.comprisk'></span><span id='topic+predictRisk.coxphTD'></span><span id='topic+predictRisk.CSCTD'></span><span id='topic+predictRisk.coxph.penal'></span><span id='topic+predictRisk.ranger'></span><span id='topic+predictRisk.penfitS3'></span><span id='topic+predictRisk.SuperPredictor'></span><span id='topic+predictRisk.Hal9001'></span><span id='topic+predictRisk.GLMnet'></span><span id='topic+predictRisk.singleEventCB'></span><span id='topic+predictRisk.CoxConfidential'></span><span id='topic+predictRisk.wglm'></span>

<h3>Description</h3>

<p>Extract event probabilities from fitted regression models and machine learning objects.
The function predictRisk is a generic function, meaning that it invokes
specifically designed functions depending on the 'class' of the first
argument. See <code><a href="#topic+predictRisk">predictRisk</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictRisk(object, newdata, ...)

## Default S3 method:
predictRisk(object, newdata, times, cause, ...)

## S3 method for class 'double'
predictRisk(object, newdata, times, cause, ...)

## S3 method for class 'integer'
predictRisk(object, newdata, times, cause, ...)

## S3 method for class 'factor'
predictRisk(object, newdata, times, cause, ...)

## S3 method for class 'numeric'
predictRisk(object, newdata, times, cause, ...)

## S3 method for class 'glm'
predictRisk(object, newdata, iid = FALSE, average.iid = FALSE, ...)

## S3 method for class 'multinom'
predictRisk(
  object,
  newdata,
  iid = FALSE,
  average.iid = FALSE,
  cause = NULL,
  ...
)

## S3 method for class 'formula'
predictRisk(object, newdata, ...)

## S3 method for class 'BinaryTree'
predictRisk(object, newdata, ...)

## S3 method for class 'lrm'
predictRisk(object, newdata, ...)

## S3 method for class 'rpart'
predictRisk(object, newdata, ...)

## S3 method for class 'randomForest'
predictRisk(object, newdata, ...)

## S3 method for class 'matrix'
predictRisk(object, newdata, times, cause, ...)

## S3 method for class 'aalen'
predictRisk(object, newdata, times, ...)

## S3 method for class 'cox.aalen'
predictRisk(object, newdata, times, ...)

## S3 method for class 'comprisk'
predictRisk(object, newdata, times, ...)

## S3 method for class 'coxph'
predictRisk(
  object,
  newdata,
  times,
  product.limit = FALSE,
  diag = FALSE,
  iid = FALSE,
  average.iid = FALSE,
  ...
)

## S3 method for class 'coxphTD'
predictRisk(object, newdata, times, landmark, ...)

## S3 method for class 'CSCTD'
predictRisk(object, newdata, times, cause, landmark, ...)

## S3 method for class 'coxph.penal'
predictRisk(object, newdata, times, ...)

## S3 method for class 'cph'
predictRisk(
  object,
  newdata,
  times,
  product.limit = FALSE,
  diag = FALSE,
  iid = FALSE,
  average.iid = FALSE,
  ...
)

## S3 method for class 'selectCox'
predictRisk(object, newdata, times, ...)

## S3 method for class 'prodlim'
predictRisk(object, newdata, times, cause, ...)

## S3 method for class 'survfit'
predictRisk(object, newdata, times, ...)

## S3 method for class 'psm'
predictRisk(object, newdata, times, ...)

## S3 method for class 'ranger'
predictRisk(object, newdata, times, cause, ...)

## S3 method for class 'rfsrc'
predictRisk(object, newdata, times, cause, ...)

## S3 method for class 'FGR'
predictRisk(object, newdata, times, cause, ...)

## S3 method for class 'riskRegression'
predictRisk(object, newdata, times, cause, ...)

## S3 method for class 'ARR'
predictRisk(object, newdata, times, cause, ...)

## S3 method for class 'CauseSpecificCox'
predictRisk(
  object,
  newdata,
  times,
  cause,
  product.limit = TRUE,
  diag = FALSE,
  iid = FALSE,
  average.iid = FALSE,
  truncate = FALSE,
  ...
)

## S3 method for class 'penfitS3'
predictRisk(object, newdata, times, ...)

## S3 method for class 'SuperPredictor'
predictRisk(object, newdata, ...)

## S3 method for class 'gbm'
predictRisk(object, newdata, times, ...)

## S3 method for class 'flexsurvreg'
predictRisk(object, newdata, times, ...)

## S3 method for class 'Hal9001'
predictRisk(object, newdata, times, cause, ...)

## S3 method for class 'GLMnet'
predictRisk(object, newdata, times = NA, ...)

## S3 method for class 'singleEventCB'
predictRisk(object, newdata, times, cause, ...)

## S3 method for class 'CoxConfidential'
predictRisk(object, newdata, ...)

## S3 method for class 'wglm'
predictRisk(
  object,
  newdata,
  times = NULL,
  product.limit = FALSE,
  diag = FALSE,
  iid = FALSE,
  average.iid = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictRisk_+3A_object">object</code></td>
<td>
<p>A fitted model from which to extract predicted event
probabilities.</p>
</td></tr>
<tr><td><code id="predictRisk_+3A_newdata">newdata</code></td>
<td>
<p>A data frame containing predictor variable combinations for
which to compute predicted event probabilities.</p>
</td></tr>
<tr><td><code id="predictRisk_+3A_...">...</code></td>
<td>
<p>Additional arguments that are passed on to the current method.</p>
</td></tr>
<tr><td><code id="predictRisk_+3A_times">times</code></td>
<td>
<p>A vector of times in the range of the response variable, for
which the cumulative incidences event probabilities are computed.</p>
</td></tr>
<tr><td><code id="predictRisk_+3A_cause">cause</code></td>
<td>
<p>Identifies the cause of interest among the competing events.</p>
</td></tr>
<tr><td><code id="predictRisk_+3A_iid">iid</code></td>
<td>
<p>Should the iid decomposition be output using an attribute?</p>
</td></tr>
<tr><td><code id="predictRisk_+3A_average.iid">average.iid</code></td>
<td>
<p>Should the average iid decomposition be output using an attribute?</p>
</td></tr>
<tr><td><code id="predictRisk_+3A_product.limit">product.limit</code></td>
<td>
<p>If <code>TRUE</code> the survival is computed using the product limit estimator.
Otherwise the exponential approximation is used (i.e. exp(-cumulative hazard)).</p>
</td></tr>
<tr><td><code id="predictRisk_+3A_diag">diag</code></td>
<td>
<p>when <code>FALSE</code> the hazard/cumlative hazard/survival for all observations at all times is computed,
otherwise it is only computed for the i-th observation at the i-th time.</p>
</td></tr>
<tr><td><code id="predictRisk_+3A_landmark">landmark</code></td>
<td>
<p>The starting time for the computation of the cumulative risk.</p>
</td></tr>
<tr><td><code id="predictRisk_+3A_truncate">truncate</code></td>
<td>
<p>If <code>TRUE</code> truncates the predicted risks to be in the range [0, 1]. For now only implemented for the Cause Specific Cox model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In uncensored binary outcome data there is no need to choose a time point.
</p>
<p>When operating on models for survival analysis (without competing risks) the function still
predicts the risk, as 1 - S(t|X) where S(t|X) is survival chance of a subject characterized
by X.
</p>
<p>When there are competing risks (and the data are right censored) one needs
to specify both the time horizon for prediction (can be a vector) and the
cause of the event. The function then extracts the absolute risks F_c(t|X)
aka the cumulative incidence of an event of type/cause c until time t for a
subject characterized by X. Depending on the model it may or not be possible
to predict the risk of all causes in a competing risks setting. For example. a
cause-specific Cox (CSC) object allows to predict both cases whereas a Fine-Gray regression
model (FGR) is specific to one of the causes.
</p>


<h3>Value</h3>

<p>For binary outcome a vector with predicted risks. For survival outcome with and without
competing risks
a matrix with as many rows as <code>NROW(newdata)</code> and as many
columns as <code>length(times)</code>. Each entry is a probability and in
rows the values should be increasing.
</p>


<h3>Author(s)</h3>

<p>Thomas A. Gerds <a href="mailto:tag@biostat.ku.dk">tag@biostat.ku.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## binary outcome
library(rms)
set.seed(7)
d &lt;- sampleData(80,outcome="binary")
nd &lt;- sampleData(80,outcome="binary")
fit &lt;- lrm(Y~X1+X8,data=d)
predictRisk(fit,newdata=nd)

## survival outcome
# generate survival data
library(prodlim)
set.seed(100)
d &lt;- sampleData(100,outcome="survival")
d[,X1:=as.numeric(as.character(X1))]
d[,X2:=as.numeric(as.character(X2))]
# then fit a Cox model
library(rms)
cphmodel &lt;- cph(Surv(time,event)~X1+X2,data=d,surv=TRUE,x=TRUE,y=TRUE)
# or via survival
library(survival)
coxphmodel &lt;- coxph(Surv(time,event)~X1+X2,data=d,x=TRUE,y=TRUE)

# Extract predicted survival probabilities
# at selected time-points:
ttt &lt;- quantile(d$time)
# for selected predictor values:
ndat &lt;- data.frame(X1=c(0.25,0.25,-0.05,0.05),X2=c(0,1,0,1))
# as follows
predictRisk(cphmodel,newdata=ndat,times=ttt)
predictRisk(coxphmodel,newdata=ndat,times=ttt)

## simulate learning and validation data
set.seed(10)
learndat &lt;- sampleData(80,outcome="survival")
valdat &lt;- sampleData(10,outcome="survival")
## use the learning data to fit a Cox model
library(survival)
fitCox &lt;- coxph(Surv(time,event)~X6+X2,data=learndat,x=TRUE,y=TRUE)
## suppose we want to predict the survival probabilities for all subjects
## in the validation data at the following time points:
## 0, 1, 2, 3, 4
psurv &lt;- predictRisk(fitCox,newdata=valdat,times=seq(0,4,1))
## This is a matrix with event probabilities (1-survival)
## one column for each of the 5 time points
## one row for each validation set individual

## competing risks
library(survival)
library(riskRegression)
library(prodlim)
set.seed(8)
train &lt;- sampleData(80)
test &lt;- sampleData(10)
cox.fit  &lt;- CSC(Hist(time,event)~X1+X6,data=train,cause=1)
predictRisk(cox.fit,newdata=test,times=seq(1:10),cause=1)

## with strata
cox.fit2  &lt;- CSC(list(Hist(time,event)~strata(X1)+X6,
                      Hist(time,cause)~X1+X6),data=train)
predictRisk(cox.fit2,newdata=test,times=seq(1:10),cause=1)

</code></pre>

<hr>
<h2 id='print.ate'>Print Average Treatment Effects</h2><span id='topic+print.ate'></span>

<h3>Description</h3>

<p>Print average treatment effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ate'
print(x, estimator = x$estimator, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.ate_+3A_x">x</code></td>
<td>
<p>object obtained with function <code>ate</code></p>
</td></tr>
<tr><td><code id="print.ate_+3A_estimator">estimator</code></td>
<td>
<p>[character] The type of estimator relative to which the risks should be output.</p>
</td></tr>
<tr><td><code id="print.ate_+3A_...">...</code></td>
<td>
<p>for internal use</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+summary.ate">summary.ate</a></code> to obtained a more detailed output
<code><a href="#topic+confint.ate">confint.ate</a></code> to compute confidence intervals/bands.
<code><a href="#topic+ate">ate</a></code> to compute the average treatment effects.
</p>

<hr>
<h2 id='print.CauseSpecificCox'>Print of a Cause-Specific Cox regression model</h2><span id='topic+print.CauseSpecificCox'></span>

<h3>Description</h3>

<p>Print of a Cause-Specific Cox regression model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CauseSpecificCox'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.CauseSpecificCox_+3A_x">x</code></td>
<td>
<p>Object obtained with CSC</p>
</td></tr>
<tr><td><code id="print.CauseSpecificCox_+3A_...">...</code></td>
<td>
<p>Passed to print</p>
</td></tr>
</table>

<hr>
<h2 id='print.FGR'>Print of a Fine-Gray regression model</h2><span id='topic+print.FGR'></span>

<h3>Description</h3>

<p>Print of a Fine-Gray regression model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'FGR'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.FGR_+3A_x">x</code></td>
<td>
<p>Object fitted with function FGR</p>
</td></tr>
<tr><td><code id="print.FGR_+3A_...">...</code></td>
<td>
<p>passed to cmprsk::summary.crr</p>
</td></tr>
</table>

<hr>
<h2 id='print.influenceTest'>Output of the DIfference Between Two Estimates</h2><span id='topic+print.influenceTest'></span>

<h3>Description</h3>

<p>Output of the difference between two estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'influenceTest'
print(x, digits = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.influenceTest_+3A_x">x</code></td>
<td>
<p>object obtained with the function <code>influenceTest</code>.</p>
</td></tr>
<tr><td><code id="print.influenceTest_+3A_digits">digits</code></td>
<td>
<p>[integer, &gt;0] indicating the number of decimal places.</p>
</td></tr>
<tr><td><code id="print.influenceTest_+3A_...">...</code></td>
<td>
<p>Passed to print.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>to display confidence intervals/bands,
the <code>confint</code> method needs to be applied on the object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+confint.influenceTest">confint.influenceTest</a></code> to compute confidence intervals/bands.
<code><a href="#topic+influenceTest">influenceTest</a></code> to perform the comparison.
</p>

<hr>
<h2 id='print.IPA'>Print IPA object</h2><span id='topic+print.IPA'></span>

<h3>Description</h3>

<p>Print method for IPA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'IPA'
print(x, digits = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.IPA_+3A_x">x</code></td>
<td>
<p>Object obtained with <code>IPA</code></p>
</td></tr>
<tr><td><code id="print.IPA_+3A_digits">digits</code></td>
<td>
<p>Number of digits</p>
</td></tr>
<tr><td><code id="print.IPA_+3A_...">...</code></td>
<td>
<p>passed to print</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas A. Gerds &lt;tag@biostat.ku.dk&gt;
</p>

<hr>
<h2 id='print.predictCox'>Print Predictions From a Cox Model</h2><span id='topic+print.predictCox'></span>

<h3>Description</h3>

<p>Print predictions from a Cox model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'predictCox'
print(x, digits = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.predictCox_+3A_x">x</code></td>
<td>
<p>object obtained with the function <code>predictCox</code>.</p>
</td></tr>
<tr><td><code id="print.predictCox_+3A_digits">digits</code></td>
<td>
<p>[integer, &gt;0] indicating the number of decimal places.</p>
</td></tr>
<tr><td><code id="print.predictCox_+3A_...">...</code></td>
<td>
<p>Passed to print.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>to display confidence intervals/bands,
the <code>confint</code> method needs to be applied on the object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+confint.predictCox">confint.predictCox</a></code> to compute confidence intervals/bands.
<code><a href="#topic+predictCox">predictCox</a></code> to compute the predicted cumulative hazard/survival.
</p>

<hr>
<h2 id='print.predictCSC'>Print Predictions From a Cause-specific Cox Proportional Hazard Regression</h2><span id='topic+print.predictCSC'></span>

<h3>Description</h3>

<p>Print predictions from a Cause-specific Cox proportional hazard regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'predictCSC'
print(x, digits = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.predictCSC_+3A_x">x</code></td>
<td>
<p>object obtained with the function <code>predictCox</code>.</p>
</td></tr>
<tr><td><code id="print.predictCSC_+3A_digits">digits</code></td>
<td>
<p>[integer, &gt;0] indicating the number of decimal places.</p>
</td></tr>
<tr><td><code id="print.predictCSC_+3A_...">...</code></td>
<td>
<p>Passed to print.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>to display confidence intervals/bands,
the <code>confint</code> method needs to be applied on the object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+confint.predictCSC">confint.predictCSC</a></code> to compute confidence intervals/bands.
<code><a href="#topic+predict.CauseSpecificCox">predict.CauseSpecificCox</a></code> to compute the predicted risks.
</p>

<hr>
<h2 id='print.riskRegression'>Print function for riskRegression models</h2><span id='topic+print.riskRegression'></span>

<h3>Description</h3>

<p>Print function for riskRegression models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'riskRegression'
print(x, times, digits = 3, eps = 10^-4, verbose = TRUE, conf.int = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.riskRegression_+3A_x">x</code></td>
<td>
<p>Object obtained with ARR, LRR or riskRegression</p>
</td></tr>
<tr><td><code id="print.riskRegression_+3A_times">times</code></td>
<td>
<p>Time points at which to show time-dependent
coefficients</p>
</td></tr>
<tr><td><code id="print.riskRegression_+3A_digits">digits</code></td>
<td>
<p>Number of digits for all numbers but p-values</p>
</td></tr>
<tr><td><code id="print.riskRegression_+3A_eps">eps</code></td>
<td>
<p>p-values smaller than this number are shown as such</p>
</td></tr>
<tr><td><code id="print.riskRegression_+3A_verbose">verbose</code></td>
<td>
<p>Level of verbosity</p>
</td></tr>
<tr><td><code id="print.riskRegression_+3A_conf.int">conf.int</code></td>
<td>
<p>level of confidence. default is 0.95</p>
</td></tr>
<tr><td><code id="print.riskRegression_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>

<hr>
<h2 id='print.Score'>Print Score object</h2><span id='topic+print.Score'></span>

<h3>Description</h3>

<p>Print method for risk prediction scores
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Score'
print(x, digits, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.Score_+3A_x">x</code></td>
<td>
<p>Object obtained with <code>Score.list</code></p>
</td></tr>
<tr><td><code id="print.Score_+3A_digits">digits</code></td>
<td>
<p>Number of digits</p>
</td></tr>
<tr><td><code id="print.Score_+3A_...">...</code></td>
<td>
<p>passed to print</p>
</td></tr>
</table>

<hr>
<h2 id='print.subjectWeights'>Print subject weights</h2><span id='topic+print.subjectWeights'></span>

<h3>Description</h3>

<p>Print subject weights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'subjectWeights'
print(x, digits = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.subjectWeights_+3A_x">x</code></td>
<td>
<p>Subject weights</p>
</td></tr>
<tr><td><code id="print.subjectWeights_+3A_digits">digits</code></td>
<td>
<p>Digits</p>
</td></tr>
<tr><td><code id="print.subjectWeights_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>

<hr>
<h2 id='reconstructData'>Reconstruct the original dataset</h2><span id='topic+reconstructData'></span>

<h3>Description</h3>

<p>Reconstruct the original dataset from the elements stored in the coxph object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reconstructData(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reconstructData_+3A_object">object</code></td>
<td>
<p>a coxph object.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Brice Ozenne broz@sund.ku.dk and Thomas A. Gerds tag@biostat.ku.dk
</p>

<hr>
<h2 id='riskLevelPlot'>Level plots for risk prediction models</h2><span id='topic+riskLevelPlot'></span>

<h3>Description</h3>

<p>Level plots for predicted risks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>riskLevelPlot(
  object,
  formula,
  data = parent.frame(),
  horizon = NULL,
  cause = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="riskLevelPlot_+3A_object">object</code></td>
<td>
<p>risk prediction model object</p>
</td></tr>
<tr><td><code id="riskLevelPlot_+3A_formula">formula</code></td>
<td>
<p>formula</p>
</td></tr>
<tr><td><code id="riskLevelPlot_+3A_data">data</code></td>
<td>
<p>data</p>
</td></tr>
<tr><td><code id="riskLevelPlot_+3A_horizon">horizon</code></td>
<td>
<p>time point</p>
</td></tr>
<tr><td><code id="riskLevelPlot_+3A_cause">cause</code></td>
<td>
<p>cause of interst</p>
</td></tr>
<tr><td><code id="riskLevelPlot_+3A_...">...</code></td>
<td>
<p>passed to lattice::levelplot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Level plots for predicted risks
</p>


<h3>Author(s)</h3>

<p>Thomas A. Gerds &lt;tag@biostat.ku.dk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# ---------- logistic regression --------------------
expit &lt;- function(x){exp(x)/(1+exp(x))}
partyData &lt;- function(N){
  Age &lt;- runif(N,.5,15)
  Parasites &lt;- rnorm(N,mean=3.5-0.03*Age)
  Fever &lt;- factor(rbinom(N,1,expit(-3.5-.3*Age+.55*Parasites+0.15*Age*Parasites)))
  data.frame(Fever,Age,Parasites)
}
d &lt;- partyData(100)
f &lt;- glm(Fever~Age+Parasites,data=d,family="binomial")
riskLevelPlot(f,Fever~Age+Parasites,d)
## Not run: 
if (require("randomForest",quietly=TRUE)){
rf &lt;- randomForest::randomForest(Fever~Age+Parasites,data=d)
riskLevelPlot(f,Fever~Age+Parasites,d)
riskLevelPlot(rf,Fever~Age+Parasites,d)
}

## End(Not run)

# ---------- survival analysis --------------------

# --simulate an artificial data frame
# with survival response and three predictors

library(survival)
library(prodlim)
set.seed(140515)
sdat &lt;- sampleData(43,outcome="survival")
# -- fit a Cox regression model 
survForm = Surv(time,event) ~ X8 + X9
cox &lt;- coxph(survForm, data = sdat,x=TRUE)

# --choose a time horizon for the predictions and plot the risks
timeHorizon &lt;- floor(median(sdat$time))
riskLevelPlot(cox, survForm, data = sdat, horizon = timeHorizon)

# ---------- competing risks --------------------

# -- simulate an artificial data frame
# with competing cause response and three predictors
library(cmprsk)
library(riskRegression)
set.seed(140515)
crdat &lt;- sampleData(49)

# -- fit a cause-specific Cox regression model
crForm &lt;- Hist(time,event)~X8+X9
csCox  &lt;- CSC(crForm, data=crdat)

# -- choose a time horizon and plot the risk for a given cause
timeHorizon &lt;- floor(median(crdat$time))
riskLevelPlot(csCox, crForm, data = crdat, horizon = timeHorizon, cause = 1)

</code></pre>

<hr>
<h2 id='riskRegression'>Risk Regression
Fits a regression model for the risk of an event &ndash; allowing for competing
risks.</h2><span id='topic+riskRegression'></span><span id='topic+ARR'></span><span id='topic+LRR'></span>

<h3>Description</h3>

<p>This is a wrapper for the function <code>comp.risk</code> from the timereg package.
The main difference is one marks variables in the formula that should have a
time-dependent effect whereas in <code>comp.risk</code> one marks variables that
should have a time constant (proportional) effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>riskRegression(
  formula,
  data,
  times,
  link = "relative",
  cause,
  conf.int = TRUE,
  cens.model,
  cens.formula,
  max.iter = 50,
  conservative = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="riskRegression_+3A_formula">formula</code></td>
<td>
<p>Formula where the left hand side specifies the event
history event.history and the right hand side the linear predictor.  See
examples.</p>
</td></tr>
<tr><td><code id="riskRegression_+3A_data">data</code></td>
<td>
<p>The data for fitting the model in which includes all
the variables included in formula.</p>
</td></tr>
<tr><td><code id="riskRegression_+3A_times">times</code></td>
<td>
<p>Vector of times. For each time point in <code>times</code>
estimate the baseline risk and the timevarying coefficients.</p>
</td></tr>
<tr><td><code id="riskRegression_+3A_link">link</code></td>
<td>
<p><code>"relative"</code> for the absolute risk regression
model.  <code>"logistic"</code> for the logistic risk regression model.
<code>"prop"</code> for the Fine-Gray regression model.</p>
</td></tr>
<tr><td><code id="riskRegression_+3A_cause">cause</code></td>
<td>
<p>The cause of interest.</p>
</td></tr>
<tr><td><code id="riskRegression_+3A_conf.int">conf.int</code></td>
<td>
<p>If <code>TRUE</code> return the iid decomposition, that
can be used to construct confidence bands for predictions.</p>
</td></tr>
<tr><td><code id="riskRegression_+3A_cens.model">cens.model</code></td>
<td>
<p>Specified the model for the (conditional)
censoring distribution used for deriving weights (IFPW). Defaults
to &quot;KM&quot; (the Kaplan-Meier method ignoring covariates) alternatively
it may be &quot;Cox&quot; (Cox regression).</p>
</td></tr>
<tr><td><code id="riskRegression_+3A_cens.formula">cens.formula</code></td>
<td>
<p>Right hand side of the formula used for fitting
the censoring model.  If not specified the right hand side of
<code>formula</code> is used.</p>
</td></tr>
<tr><td><code id="riskRegression_+3A_max.iter">max.iter</code></td>
<td>
<p>Maximal number of iterations.</p>
</td></tr>
<tr><td><code id="riskRegression_+3A_conservative">conservative</code></td>
<td>
<p>If <code>TRUE</code> use variance formula that ignores the contribution
by the estimate of the inverse of the probability of censoring weights</p>
</td></tr>
<tr><td><code id="riskRegression_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>comp.risk</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas A. Gerds <a href="mailto:tag@biostat.ku.dk">tag@biostat.ku.dk</a>, Thomas H. Scheike <a href="mailto:ts@biostat.ku.dk">ts@biostat.ku.dk</a>
</p>


<h3>References</h3>

<p>Thomas A Gerds, Thomas H Scheike, and Per K Andersen. Absolute risk
regression for competing risks: interpretation, link functions, and
prediction. Statistics in medicine, 31(29):3921&ndash;3930, 2012.
</p>
<p>Scheike, Zhang and Gerds (2008), Predicting cumulative incidence probability
by direct binomial regression, Biometrika, 95, 205-220.
</p>
<p>Scheike and Zhang (2007), Flexible competing risks regression modelling and
goodness of fit, LIDA, 14, 464-483.
</p>
<p>Martinussen and Scheike (2006), Dynamic regression models for survival data,
Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(prodlim)
data(Melanoma,package="riskRegression")
## tumor thickness on the log-scale
Melanoma$logthick &lt;- log(Melanoma$thick)

# Single binary factor

## absolute risk regression
library(survival)
library(prodlim)
fit.arr &lt;- ARR(Hist(time,status)~sex,data=Melanoma,cause=1)
print(fit.arr)
# show predicted cumulative incidences
plot(fit.arr,col=3:4,newdata=data.frame(sex=c("Female","Male")))

## compare with non-parametric Aalen-Johansen estimate
library(prodlim)
fit.aj &lt;- prodlim(Hist(time,status)~sex,data=Melanoma)
plot(fit.aj,conf.int=FALSE)
plot(fit.arr,add=TRUE,col=3:4,newdata=data.frame(sex=c("Female","Male")))

## with time-dependent effect
fit.tarr &lt;- ARR(Hist(time,status)~strata(sex),data=Melanoma,cause=1)
plot(fit.tarr,newdata=data.frame(sex=c("Female","Male")))

## logistic risk regression
fit.lrr &lt;- LRR(Hist(time,status)~sex,data=Melanoma,cause=1)
summary(fit.lrr)


# Single continuous factor

## tumor thickness on the log-scale
Melanoma$logthick &lt;- log(Melanoma$thick)

## absolute risk regression 
fit2.arr &lt;- ARR(Hist(time,status)~logthick,data=Melanoma,cause=1)
print(fit2.arr)
# show predicted cumulative incidences
plot(fit2.arr,col=1:5,newdata=data.frame(logthick=quantile(Melanoma$logthick)))

## comparison with nearest neighbor non-parametric Aalen-Johansen estimate
library(prodlim)
fit2.aj &lt;- prodlim(Hist(time,status)~logthick,data=Melanoma)
plot(fit2.aj,conf.int=FALSE,newdata=data.frame(logthick=quantile(Melanoma$logthick)))
plot(fit2.arr,add=TRUE,col=1:5,lty=3,newdata=data.frame(logthick=quantile(Melanoma$logthick)))

## logistic risk regression
fit2.lrr &lt;- LRR(Hist(time,status)~logthick,data=Melanoma,cause=1)
summary(fit2.lrr)

## change model for censoring weights
library(rms)
fit2a.lrr &lt;- LRR(Hist(time,status)~logthick,
                 data=Melanoma,
                 cause=1,
                 cens.model="cox",
                 cens.formula=~sex+epicel+ulcer+age+logthick)
summary(fit2a.lrr)

##  compare prediction performance
Score(list(ARR=fit2.arr,AJ=fit2.aj,LRR=fit2.lrr),formula=Hist(time,status)~1,data=Melanoma)


# multiple regression
library(riskRegression)
library(prodlim)
# absolute risk model
multi.arr &lt;- ARR(Hist(time,status)~logthick+sex+age+ulcer,data=Melanoma,cause=1)

# stratified model allowing different baseline risk for the two gender
multi.arr &lt;- ARR(Hist(time,status)~thick+strata(sex)+age+ulcer,data=Melanoma,cause=1)

# stratify by a continuous variable: strata(age)
multi.arr &lt;- ARR(Hist(time,status)~tp(thick,power=0)+strata(age)+sex+ulcer,
                 data=Melanoma,
                 cause=1)

fit.arr2a &lt;- ARR(Hist(time,status)~tp(thick,power=1),data=Melanoma,cause=1)
summary(fit.arr2a)
fit.arr2b &lt;- ARR(Hist(time,status)~timevar(thick),data=Melanoma,cause=1)
summary(fit.arr2b)

## logistic risk model
fit.lrr &lt;- LRR(Hist(time,status)~thick,data=Melanoma,cause=1)
summary(fit.lrr)





## nearest neighbor non-parametric Aalen-Johansen estimate
library(prodlim)
fit.aj &lt;- prodlim(Hist(time,status)~thick,data=Melanoma)
plot(fit.aj,conf.int=FALSE)

# prediction performance
x &lt;- Score(list(fit.arr2a,fit.arr2b,fit.lrr),
             data=Melanoma,
             formula=Hist(time,status)~1,
             cause=1,
             split.method="none")


</code></pre>

<hr>
<h2 id='riskRegression-package'>Risk Regression Models and Prediction Scores for Survival Analysis with Competing Risks</h2><span id='topic+riskRegression-package'></span>

<h3>Description</h3>

<p>Methods for evaluating risk predictions in censored event history analysis
</p>

<hr>
<h2 id='riskRegression.options'>Global options for <code>riskRegression</code></h2><span id='topic+riskRegression.options'></span>

<h3>Description</h3>

<p>Output and set global options for the <code>riskRegression</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>riskRegression.options(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="riskRegression.options_+3A_...">...</code></td>
<td>
<p>for now limited to <code>method.predictRisk</code> and <code>mehtod.predictRiskIID</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>only used by the <code>ate</code> function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>options &lt;- riskRegression.options()

## add new method.predictRiskIID
riskRegression.options(method.predictRiskIID = c(options$method.predictRiskIID,"xx"))

riskRegression.options()
</code></pre>

<hr>
<h2 id='rowCenter_cpp'>Apply - by row</h2><span id='topic+rowCenter_cpp'></span>

<h3>Description</h3>

<p>Fast computation of sweep(X, MARGIN = 2, FUN = &quot;-&quot;, STATS = center)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowCenter_cpp(X, center)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowCenter_cpp_+3A_x">X</code></td>
<td>
<p>A matrix.</p>
</td></tr>
<tr><td><code id="rowCenter_cpp_+3A_center">center</code></td>
<td>
<p>a numeric vector of length equal to the number of rows of <code>x</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of same size as X.
</p>


<h3>Author(s)</h3>

<p>Brice Ozenne &lt;broz@sund.ku.dk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(1,6,5)
sweep(x, MARGIN = 2, FUN = "-", STATS = 1:5)
rowCenter_cpp(x, 1:5 )

rowCenter_cpp(x, colMeans(x) )
</code></pre>

<hr>
<h2 id='rowCumSum'>Apply cumsum in each row</h2><span id='topic+rowCumSum'></span>

<h3>Description</h3>

<p>Fast computation of t(apply(x,1,cumsum))
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowCumSum(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowCumSum_+3A_x">x</code></td>
<td>
<p>A matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of same size as x.
</p>


<h3>Author(s)</h3>

<p>Thomas Alexander Gerds &lt;tag@biostat.ku.dk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(1:8,ncol=2)
rowCumSum(x)
</code></pre>

<hr>
<h2 id='rowMultiply_cpp'>Apply * by row</h2><span id='topic+rowMultiply_cpp'></span>

<h3>Description</h3>

<p>Fast computation of sweep(X, MARGIN = 2, FUN = &quot;*&quot;, STATS = scale)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowMultiply_cpp(X, scale)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowMultiply_cpp_+3A_x">X</code></td>
<td>
<p>A matrix.</p>
</td></tr>
<tr><td><code id="rowMultiply_cpp_+3A_scale">scale</code></td>
<td>
<p>a numeric vector of length equal to the number of rows of <code>x</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of same size as X.
</p>


<h3>Author(s)</h3>

<p>Brice Ozenne &lt;broz@sund.ku.dk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(1,6,5)
sweep(x, MARGIN = 2, FUN = "*", STATS = 1:5)
rowMultiply_cpp(x, 1:5 )

rowMultiply_cpp(x, 1/colMeans(x) )

</code></pre>

<hr>
<h2 id='rowPaste'>Collapse Rows of Characters.</h2><span id='topic+rowPaste'></span>

<h3>Description</h3>

<p>Collapse rows of characters. Fast alternative to apply(x,1,paste0,collapse=&quot;&quot;)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowPaste(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowPaste_+3A_object">object</code></td>
<td>
<p>A matrix/data.frame/list containing the characters.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
M &lt;- matrix(letters,nrow = 26, ncol = 2)
rowPaste(M)

## End(Not run)
</code></pre>

<hr>
<h2 id='rowScale_cpp'>Apply / by row</h2><span id='topic+rowScale_cpp'></span>

<h3>Description</h3>

<p>Fast computation of sweep(X, MARGIN = 2, FUN = &quot;/&quot;, STATS = scale)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowScale_cpp(X, scale)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowScale_cpp_+3A_x">X</code></td>
<td>
<p>A matrix.</p>
</td></tr>
<tr><td><code id="rowScale_cpp_+3A_scale">scale</code></td>
<td>
<p>a numeric vector of length equal to the number of rows of <code>x</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of same size as X.
</p>


<h3>Author(s)</h3>

<p>Brice Ozenne &lt;broz@sund.ku.dk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(1,6,5)
sweep(x, MARGIN = 2, FUN = "/", STATS = 1:5)
rowScale_cpp(x, 1:5 )

rowScale_cpp(x, colMeans(x) )
</code></pre>

<hr>
<h2 id='rowSumsCrossprod'>Apply crossprod and rowSums</h2><span id='topic+rowSumsCrossprod'></span>

<h3>Description</h3>

<p>Fast computation of crossprod(rowSums(X),Y)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowSumsCrossprod(X, Y, transposeY)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowSumsCrossprod_+3A_x">X</code></td>
<td>
<p>A matrix with dimensions n*k. Hence the result of <code>rowSums(X)</code> has length n.</p>
</td></tr>
<tr><td><code id="rowSumsCrossprod_+3A_y">Y</code></td>
<td>
<p>A matrix with dimenions n*m. Can be a matrix with dimension m*n but then <code>transposeY</code> should be <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="rowSumsCrossprod_+3A_transposey">transposeY</code></td>
<td>
<p>Logical. If <code>TRUE</code> transpose Y before matrix multiplication.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length m.
</p>


<h3>Author(s)</h3>

<p>Thomas Alexander Gerds &lt;tag@biostat.ku.dk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(1:10,nrow=5)
y &lt;- matrix(1:20,ncol=4)
rowSumsCrossprod(x,y,0)

x &lt;- matrix(1:10,nrow=5)
y &lt;- matrix(1:20,ncol=5)
rowSumsCrossprod(x,y,1)
</code></pre>

<hr>
<h2 id='sampleData'>Simulate data with binary or time-to-event outcome</h2><span id='topic+sampleData'></span><span id='topic+sampleDataTD'></span>

<h3>Description</h3>

<p>Simulate data with binary outcome and 10 covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleData(n,outcome="competing.risks",
formula= ~ f(X1,2)+f(X2,-0.033)+f(X3,0.4)+f(X6,.1)+f(X7,-.1)+f(X8,.5)+f(X9,-1),
          intercept=0)
sampleDataTD(n,n.intervals=5,outcome="competing.risks",
formula= ~ f(X1,2)+f(X2,-0.033)+f(X3,0.4)+f(X6,.1)+f(X7,-.1)+f(X8,.5)+f(X9,-1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampleData_+3A_n">n</code></td>
<td>
<p>Sample size</p>
</td></tr>
<tr><td><code id="sampleData_+3A_outcome">outcome</code></td>
<td>
<p>Character vector. Response variables are generated
according to keywords: <code>"binary"</code> = binary response,
<code>"survival"</code> = survival response, <code>"competing.risks"</code> =
competing risks response</p>
</td></tr>
<tr><td><code id="sampleData_+3A_formula">formula</code></td>
<td>
<p>Specify regression coefficients</p>
</td></tr>
<tr><td><code id="sampleData_+3A_intercept">intercept</code></td>
<td>
<p>For binary outcome the intercept of the logistic regression.</p>
</td></tr>
<tr><td><code id="sampleData_+3A_n.intervals">n.intervals</code></td>
<td>
<p><code>sampleDataTD</code> only: the maximum number of episodes in which the covariates are updated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the actual lava::regression parameters see the function definition.
</p>


<h3>Value</h3>

<p>Simulated data as data.table with n rows and the following columns:
Y (binary outcome), time (non-binary outcome), event (non-binary outcome),
X1-X5 (binary predictors), X6-X10 (continous predictors)
</p>


<h3>Author(s)</h3>

<p>Thomas A. Gerds &lt;tag@biostat.ku.dk&gt;
</p>


<h3>See Also</h3>

<p>lvm
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(10)
sampleData(10,outcome="binary")
sampleData(10,outcome="survival")
sampleData(10,outcome="competing.risks")
</code></pre>

<hr>
<h2 id='saveCoxConfidential'>Save confidential Cox objects</h2><span id='topic+saveCoxConfidential'></span>

<h3>Description</h3>

<p>Save confidential Cox objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saveCoxConfidential(object, times)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saveCoxConfidential_+3A_object">object</code></td>
<td>
<p>An object of class <code>coxph</code>.</p>
</td></tr>
<tr><td><code id="saveCoxConfidential_+3A_times">times</code></td>
<td>
<p>The times at which we want to predict risk.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can save <code>coxph</code> objects such that we do not need to export 
the data on which it was fitted at given times.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(survival)
library(lava)
set.seed(18)
trainSurv &lt;- sampleData(300,outcome="survival")
testSurv &lt;- sampleData(40,outcome="survival")
fit = coxph(Surv(time,event)~X1+X2+X3+X7+X9,data=trainSurv, y=TRUE, x = TRUE)
u=saveCoxConfidential(fit,times=3)
## Not run: 
# write object as plain text file
sink("~/tmp/u.R")
cat("U &lt;- ")
dput(u)
sink(NULL)
# reload object
source("~/tmp/u.R")
class(u) &lt;- "CoxConfidential"

## End(Not run)
predictRisk(u,newdata=testSurv)
cox1 = coxph(Surv(time,event)~strata(X1)+X2+X3+X7+X9,data=trainSurv, y=TRUE, x = TRUE)
z&lt;-saveCoxConfidential(cox1,c(2,5))

dput(z) ## get output to copy object

all.equal(predictRisk(z,newdata=testSurv),
          predictRisk(cox1,newdata=testSurv,times=c(2,5)))

cox2 = coxph(Surv(time,event)~X1+X2+X7+X9,data=trainSurv, y=TRUE, x = TRUE)
z&lt;-saveCoxConfidential(cox2,c(2,5))

all.equal(predictRisk(z,testSurv),predictRisk(z,testSurv,c(2,5)))
</code></pre>

<hr>
<h2 id='Score'>Score risk predictions</h2><span id='topic+Score'></span><span id='topic+Score.list'></span>

<h3>Description</h3>

<p>Methods to score the predictive performance of risk markers and risk prediction models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Score(object, ...)

## S3 method for class 'list'
Score(
  object,
  formula,
  data,
  metrics = c("auc", "brier"),
  summary = NULL,
  plots = NULL,
  cause,
  times,
  landmarks,
  use.event.times = FALSE,
  null.model = TRUE,
  se.fit = TRUE,
  conservative = FALSE,
  multi.split.test = FALSE,
  conf.int = 0.95,
  contrasts = TRUE,
  probs = c(0, 0.25, 0.5, 0.75, 1),
  cens.method = "ipcw",
  cens.model = "cox",
  split.method,
  B,
  M,
  seed,
  trainseeds,
  parallel = c("no", "multicore", "snow", "as.registered"),
  ncpus = 1,
  cl = NULL,
  progress.bar = 3,
  errorhandling = "pass",
  keep,
  predictRisk.args,
  debug = 0L,
  censoring.save.memory = FALSE,
  breaks = seq(0, 1, 0.01),
  roc.method = "vertical",
  roc.grid = switch(roc.method, vertical = seq(0, 1, 0.01), horizontal = seq(1, 0,
    -0.01)),
  cutpoints = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Score_+3A_object">object</code></td>
<td>
<p>List of risk predictions (see details and examples).</p>
</td></tr>
<tr><td><code id="Score_+3A_...">...</code></td>
<td>
<p>Named list containing additional arguments that are passed on to the <code>predictRisk</code> methods corresponding to object. See examples.</p>
</td></tr>
<tr><td><code id="Score_+3A_formula">formula</code></td>
<td>
<p>A formula which identifies the outcome (left hand
side). E.g., <code>Y ~ 1</code> for binary and <code>Hist(time,status) ~ 1</code> for time-to-event outcome.
In right censored data, the right hand side of the
formula is used to estimate the inverse probability of censoring weights (IPCW) model.</p>
</td></tr>
<tr><td><code id="Score_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>data.table</code> in which the formula can be
interpreted.</p>
</td></tr>
<tr><td><code id="Score_+3A_metrics">metrics</code></td>
<td>
<p>Character vector specifying which metrics to
apply. Case does not matter. Choices are <code>"AUC"</code> and <code>"Brier"</code>.</p>
</td></tr>
<tr><td><code id="Score_+3A_summary">summary</code></td>
<td>
<p>Character vector specifying which summary
statistics to apply to the predicted risks. Choices are <code>"risks"</code>, <code>"IPA"</code>,
<code>"riskQuantile"</code> and <code>"ibs"</code>. Can be all <code>c("risks","IPA","riskQuantile","ibs")</code> or a subset thereof.
</p>

<ul>
<li> <p><code>"risks"</code> adds the predicted risks to the output.
</p>
</li>
<li> <p><code>"ipa"</code> computes the index of prediction accuracy (AKA R-squared) based on Brier scores for model vs null model
</p>
</li>
<li> <p><code>"riskQuantile"</code> calculates
time-point specific boxplots for the
predicted risks (or biomarker values) conditional on the outcome at the time-point.
</p>
</li>
<li> <p><code>"ibs"</code> calculates integrated Brier scores across the time points at which the Brier score is computed. This works only with
time-to-event outcome and the results depend on the argument <code>times</code>.
</p>
</li></ul>

<p>Set to <code>NULL</code> to avoid estimation of summary statistics.</p>
</td></tr>
<tr><td><code id="Score_+3A_plots">plots</code></td>
<td>
<p>Character vector specifying for which plots to put data into the result.
Currently implemented are <code>"ROC"</code>, <code>"Calibration"</code> and <code>"boxplot"</code>.
In addition, one can plot AUC and Brier score as function of time as soon as
<code>times</code> has at least two different values.</p>
</td></tr>
<tr><td><code id="Score_+3A_cause">cause</code></td>
<td>
<p>Event of interest. Used for binary outcome <code>Y</code>
to specify that risks are risks of the event <code>Y=event</code>
and for competing risks outcome to specify the cause of
interest.</p>
</td></tr>
<tr><td><code id="Score_+3A_times">times</code></td>
<td>
<p>For survival and competing risks outcome: list of
prediction horizons. All times which are greater than the
maximal observed time in the data set are automatically removed.
Note that the object returned by the function may become huge when
the prediction performance is estimated at many prediction horizons.</p>
</td></tr>
<tr><td><code id="Score_+3A_landmarks">landmarks</code></td>
<td>
<p>Not yet implemented.</p>
</td></tr>
<tr><td><code id="Score_+3A_use.event.times">use.event.times</code></td>
<td>
<p>If <code>TRUE</code> merge all unique event times with
the vector given by argument <code>times</code>.</p>
</td></tr>
<tr><td><code id="Score_+3A_null.model">null.model</code></td>
<td>
<p>If <code>TRUE</code> fit a risk prediction model which ignores
the covariates and predicts the same value for all subjects. The model is fitted using <code>data</code>
and the left hand side of <code>formula</code>. For binary outcome this is just the empirical prevalence. For (right censored) time to event outcome, the null models are
equal to the Kaplan-Meier estimator (no competing risks) and the Aalen-Johansen estimator (with competing risks).</p>
</td></tr>
<tr><td><code id="Score_+3A_se.fit">se.fit</code></td>
<td>
<p>Logical or <code>0</code> or <code>1</code>. If <code>FALSE</code> or <code>0</code> do not calculate standard errors.</p>
</td></tr>
<tr><td><code id="Score_+3A_conservative">conservative</code></td>
<td>
<p>Logical, only relevant in right censored data. If <code>TRUE</code> ignore
variability of the estimate of the inverse probability of censoring weights when calculating standard
errors for prediction performance parameters. This can potentially reduce computation time and memory usage
at a usually very small expense of a slightly higher standard error.</p>
</td></tr>
<tr><td><code id="Score_+3A_multi.split.test">multi.split.test</code></td>
<td>
<p>Logical or <code>0</code> or <code>1</code>. If <code>FALSE</code> or <code>0</code> do not calculate multi-split tests. This argument is ignored when <code>split.method</code> is &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="Score_+3A_conf.int">conf.int</code></td>
<td>
<p>Either logical or a numeric value between 0 and 1. In right censored data,
confidence intervals are based on Blanche et al (see references). Setting <code>FALSE</code> prevents the
computation of confidence intervals. <code>TRUE</code> computes 95 percent confidence
intervals and corresponding p-values for AUC and Brier score. If set to 0.87, the
level of significance is 13 percent. So, do not set it to 0.87.</p>
</td></tr>
<tr><td><code id="Score_+3A_contrasts">contrasts</code></td>
<td>
<p>Either logical or a list of contrasts. A list of contrasts defines which risk prediction models (markers)
should be contrasted with respect to their prediction performance.
If <code>TRUE</code> do all possible comparisons. For
example, when <code>object</code> is a list with two risk prediction models and
<code>null.model=TRUE</code> setting <code>TRUE</code> is equivalent to
<code>list(c(0,1,2),c(1,2))</code> where <code>c(0,1,2)</code> codes for the
two comparisons: 1 vs 0 and 2 vs 0 (positive integers refer to
elements of <code>object</code>, 0 refers to the benchmark null
model which ignores the covariates).  This again is equivalent
to explicitly setting <code>list(c(0,1),c(0,2),c(1,2))</code>. A
more complex example: Suppose <code>object</code> has 7 elements and you
want to do the following 3 comparisons: 6 vs 3, 2 vs 5 and 2
vs 3, you should set <code>contrasts=c(6,3),c(2,5,3)</code>.</p>
</td></tr>
<tr><td><code id="Score_+3A_probs">probs</code></td>
<td>
<p>Quantiles for retrospective summary statistics of the
predicted risks. This affects the result of the function <code>boxplot.Score</code>.</p>
</td></tr>
<tr><td><code id="Score_+3A_cens.method">cens.method</code></td>
<td>
<p>Method for dealing with right censored
data. Either <code>"ipcw"</code> or <code>"pseudo"</code>.
Here IPCW refers to inverse probability of censoring weights and <code>pseudo</code> for jackknife pseudo values.
Right now pseudo values  are only used for calibration curves.</p>
</td></tr>
<tr><td><code id="Score_+3A_cens.model">cens.model</code></td>
<td>
<p>Model for estimating inverse probability of
censored weights (IPCW). Implemented are the Kaplan-Meier method (<code>"km"</code>) and
Cox regression (<code>"cox"</code>) both applied to the censored times. If the right hand side of <code>formula</code> does not specify covariates,
the Kaplan-Meier method is used even if this argument is set to <code>"cox"</code>. Also implemented is a template for users specifying other models to estimate the IPCW. Here the user
should be supply a function, taking as input a <code>"formula"</code> and <code>"data"</code>. This does come at the cost of only being able to calculate conservative confidence intervals.</p>
</td></tr>
<tr><td><code id="Score_+3A_split.method">split.method</code></td>
<td>
<p>Method for cross-validation. Right now the only choices are <code>bootcv</code>, <code>cvk</code> and <code>loob</code>. In the first case, bootstrap learning sets
are drawn with our without replacement (argument <code>M</code>) from <code>data</code>. The data not included in the current bootstrap learning
set are used as validation set to compute the prediction performance. In the second case, k-fold cross-validation is performed. Note that k has to be an explicit number, e.g. 5 or 10,
when passing this as an argument. In the third case, leave-one-out bootstrap cross-validation is performed for the Brier score and leave-pair-out bootstrap cross-validation is performed for the AUC.</p>
</td></tr>
<tr><td><code id="Score_+3A_b">B</code></td>
<td>
<p>Number of bootstrap sets for cross-validation. <code>B</code> should be set to 1, when k-fold cross-validation is used.</p>
</td></tr>
<tr><td><code id="Score_+3A_m">M</code></td>
<td>
<p>Size of subsamples for bootstrap cross-validation. If specified it
has to be an integer smaller than the size of <code>data</code>.</p>
</td></tr>
<tr><td><code id="Score_+3A_seed">seed</code></td>
<td>
<p>Super seed for setting training data seeds when
randomly splitting (bootstrapping) the data during cross-validation.</p>
</td></tr>
<tr><td><code id="Score_+3A_trainseeds">trainseeds</code></td>
<td>
<p>Seeds for training models during cross-validation.</p>
</td></tr>
<tr><td><code id="Score_+3A_parallel">parallel</code></td>
<td>
<p>The type of parallel operation to be used (if any). If missing, the default is <code>"no"</code>.</p>
</td></tr>
<tr><td><code id="Score_+3A_ncpus">ncpus</code></td>
<td>
<p>integer: number of processes to be used in parallel operation.</p>
</td></tr>
<tr><td><code id="Score_+3A_cl">cl</code></td>
<td>
<p>An optional <code>parallel</code> or <code>snow</code> cluster for use if <code>parallel = "snow"</code>. If not supplied, a cluster on the local machine is created for the duration of the <code>Score</code> call.</p>
</td></tr>
<tr><td><code id="Score_+3A_progress.bar">progress.bar</code></td>
<td>
<p>Style for <code>txtProgressBar</code>. Can be 1,2,3 see <code>help(txtProgressBar)</code> or NULL to avoid the progress bar.</p>
</td></tr>
<tr><td><code id="Score_+3A_errorhandling">errorhandling</code></td>
<td>
<p>Argument passed as <code>.errorhandling</code> to foreach. Default is <code>"pass"</code>.</p>
</td></tr>
<tr><td><code id="Score_+3A_keep">keep</code></td>
<td>
<p>list of characters (not case sensitive) which determines additional output.
<code>"residuals"</code> provides Brier score residuals and
<code>"splitindex"</code> provides sampling index used to split the data into training and validation sets. It is a function, whose argument is the bootstrap sample, which one wishes to look at.
<code>"vcov"</code> provides the variance-covariance matrix for the estimates.
<code>"iid"</code> provides the estimated influence function of the estimates.</p>
</td></tr>
<tr><td><code id="Score_+3A_predictrisk.args">predictRisk.args</code></td>
<td>
<p>A list of argument-lists to control how risks are predicted.
The names of the lists should be the S3-classes of the <code>object</code>.
The argument-lists are then passed on to the S3-class specific predictRisk method.
For example, if your object contains one or several random forest model fitted with the function randomForestSRC::rfsrc then you can
specify additional arguments for the function riskRegression::predictRisk.rfsrc which will pass
these on to the function randomForestSRC::predict.rfsrc. A specific example in this case would be
<code>list(rfsrc=list(na.action="na.impute"))</code>.
</p>
<p>A more flexible approach is to write a new predictRisk S3-method. See Details.</p>
</td></tr>
<tr><td><code id="Score_+3A_debug">debug</code></td>
<td>
<p>Logical. If <code>TRUE</code> indicate landmarks in progress of the program.</p>
</td></tr>
<tr><td><code id="Score_+3A_censoring.save.memory">censoring.save.memory</code></td>
<td>
<p>Only relevant in censored data where censoring weigths are obtained with
Cox regression and argument <code>conservative</code> is set to <code>FALSE</code>. If <code>TRUE</code>, save memory by not storing the influence function
of the cumulative hazard of the censoring as a matrix when calculating standard errors
with Cox censoring. This can allow one to use <code>Score</code> on larger test data sets,
but may be slower.</p>
</td></tr>
<tr><td><code id="Score_+3A_breaks">breaks</code></td>
<td>
<p>Break points for computing the Roc curve. Defaults to
<code>seq(0,1,.01)</code> when some form of crossvalidation is applied, otherwise
to all unique values of the predictive marker.</p>
</td></tr>
<tr><td><code id="Score_+3A_roc.method">roc.method</code></td>
<td>
<p>Method for averaging ROC curves across data splits.
If <code>'horizontal'</code> average crossvalidated specificities for fixed sensitivity values,
specified in <code>roc.grid</code>, otherwise, if  <code>'vertical'</code>,
average crossvalidated specificities for fixed sensitivity values.
See Fawcett, T. (2006) for details.</p>
</td></tr>
<tr><td><code id="Score_+3A_roc.grid">roc.grid</code></td>
<td>
<p>Grid points for the averaging of ROC curves.
A sequence of values at which to compute averages across the ROC curves
obtained for different data splits during crossvalidation.</p>
</td></tr>
<tr><td><code id="Score_+3A_cutpoints">cutpoints</code></td>
<td>
<p>If not <code>NULL</code>, estimates and standard errors of the TPR (True Positive Rate), 
FPR (False Positive Rate), PPV (Positive Predictive Value), and NPV (Negative Predictive Value) 
are given at the <code>cutpoints</code>. These values are saved in <code>object$AUC$res.cut</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function implements a toolbox for the risk prediction modeller:
all tools work for the three outcomes: (1) binary (uncensored),
(2) right censored time to event without competing risks,
(3) right censored time to event with competing risks
</p>
<p>Computed are the (time-dependent) Brier score and the (time-dependent)
area under the ROC curve for a list of risk prediction models either in
external validation data or in the learning data using bootstrap
cross-validation. The function optionally provides results for plotting (time-point specific)
ROC curves, for (time-point specific) calibration curves and for (time-point specific) retrospective boxplots.
</p>
<p>For uncensored binary outcome the Delong-Delong test is used to contrast AUC of rival models.
In right censored survival data (with and without competing risks)
the p-values correspond to Wald tests based on standard errors obtained with an estimate of the influence function
as described in detail in the appendix of Blanche et al. (2015).
</p>
<p>This function works with one or multiple models that predict the risk of an event R(t|X) for a subject
characterized by predictors X at time t.
With binary endpoints (outcome 0/1 without time component) the risk is simply R(X).
In case of a survival object
without competing risks the function still works with predicted event probabilities, i.e., R(t|X)=1-S(t|X) where
S(t|X) is the predicted survival chance for subject X at time t.
</p>
<p>The already existing predictRisk methods (see methods(predictRisk)) may not cover all models and methods
for predicting risks. But users can quickly extend the package as explained in detail in Mogensen et al. (2012) for
the predecessors <code>pec::predictSurvProb</code> and <code>pec::predictEventProb</code> which have been unified as
<code>riskRegression::predictRisk</code>.
</p>
<p>Bootstrap Crossvalidation (see also Gerds &amp; Schumacher 2007 and Mogensen et al. 2012)
</p>
<p>B=10, M (not specified or M=NROW(data))
Training of each of the models in each of 10 bootstrap data sets (learning data sets).
Learning data sets are obtained by sampling <code>NROW(data)</code> subjects of the data set
with replacement. There are roughly <code>.632*NROW(data)</code> subjects in the learning data (inbag)
and <code>.368*NROW(data)</code> subjects not in the validation data sets (out-of-bag).
</p>
<p>These are used to estimate the scores: AUC, Brier, etc. Reported are averages across the 10 splits.
</p>
<p>## Bootstrap with replacement
<code>
set.seed(13)
N=17
data = data.frame(id=1:N, y=rbinom(N,1,.3),x=rnorm(N))
boot.index = sample(1:N,size=N,replace=TRUE)
boot.index
inbag = 1:N 
outofbag = !inbag
learn.data = data[inbag]
val.data = data[outofbag]
riskRegression:::getSplitMethod("bootcv",B=10,N=17)$index
</code>
NOTE: the number .632 is the expected probability to draw one subject (for example subject 1) with
replacement from the data, which does not depend on the sample size:
<code>B=10000</code>
<code>N=137</code>
<code>mean(sapply(1:B, function(b){match(1,sample(1:N,size=N,replace=TRUE),nomatch=0)}))</code>
<code>N=30</code>
<code>mean(sapply(1:B, function(b){match(1,sample(1:N,size=N,replace=TRUE),nomatch=0)}))</code>
<code>N=300</code>
<code>mean(sapply(1:B, function(b){match(1,sample(1:N,size=N,replace=TRUE),nomatch=0)}))</code>
</p>
<p>## Bootstrap without replacement (training size set to be 70 percent of data)
B=10, M=.7
</p>
<p>Training of each of the models in each of 10 bootstrap data sets (learning data sets).
Learning data sets are obtained by sampling <code>round(.8*NROW(data))</code> subjects of the data set
without replacement. There are <code>NROW(data)-round(.8*NROW(data))</code> subjects not in the learning data sets.
These are used to estimate the scores: AUC, Brier, etc. Reported are averages across the 10 splits.
<code>
set.seed(13)
N=17
data = data.frame(id=1:N, y=rbinom(N,1,.3),x=rnorm(N))
boot.index = sample(1:N,size=M,replace=FALSE)
boot.index
inbag = 1:N 
outofbag = !inbag
learn.data = data[inbag]
val.data = data[outofbag]
riskRegression:::getSplitMethod("bootcv",B=10,N=17,M=.7)$index
</code>
</p>


<h3>Value</h3>

<p>List with scores and assessments of contrasts, i.e.,
tests and confidence limits for performance and difference in performance (AUC and Brier),
summaries and plots. Most elements are in<code>data.table</code> format.
</p>


<h3>Author(s)</h3>

<p>Thomas A Gerds <a href="mailto:tag@biostat.ku.dk">tag@biostat.ku.dk</a> and Paul Blanche <a href="mailto:paul.blanche@univ-ubs.fr">paul.blanche@univ-ubs.fr</a>
</p>


<h3>References</h3>

<p>Thomas A. Gerds and Michael W. Kattan (2021).
Medical Risk Prediction Models: With Ties to Machine Learning (1st ed.)
Chapman and Hall/CRC
https://doi.org/10.1201/9781138384484
</p>
<p>Ulla B. Mogensen, Hemant Ishwaran, Thomas A. Gerds (2012).
Evaluating Random Forests for Survival Analysis Using Prediction Error
Curves. Journal of Statistical Software, 50(11), 1-23. URL
http://www.jstatsoft.org/v50/i11/.
</p>
<p>Paul Blanche, Cecile Proust-Lima, Lucie Loubere, Claudine Berr, Jean- Francois Dartigues, and
Helene Jacqmin-Gadda. Quantifying and comparing dynamic predictive accuracy of joint models
for longitudinal marker and time-to-event in presence of censoring and competing risks.
Biometrics, 71 (1):102&ndash;113, 2015.
</p>
<p>P. Blanche, J-F Dartigues, and H. Jacqmin-Gadda. Estimating and comparing
time-dependent areas under receiver operating characteristic curves for
censored event times with competing risks. Statistics in Medicine,
32(30):5381&ndash;5397, 2013.
</p>
<p>E. Graf et al.  (1999), Assessment and comparison of prognostic
classification schemes for survival data. Statistics in Medicine, vol 18,
pp= 2529&ndash;2545.
</p>
<p>Efron, Tibshirani (1997) Journal of the American Statistical Association 92,
548&ndash;560 Improvement On Cross-Validation: The .632+ Bootstrap Method.
</p>
<p>Gerds, Schumacher (2006), Consistent estimation of the expected Brier score
in general survival models with right-censored event times. Biometrical
Journal, vol 48, 1029&ndash;1040.
</p>
<p>Thomas A. Gerds, Martin Schumacher (2007) Efron-Type Measures of Prediction
Error for Survival Analysis Biometrics, 63(4), 1283&ndash;1287
doi:10.1111/j.1541-0420.2007.00832.x
</p>
<p>Martin Schumacher, Harald Binder, and Thomas Gerds. Assessment of survival
prediction models based on microarray data. Bioinformatics, 23(14):1768-74,
2007.
</p>
<p>Mark A. van de Wiel, Johannes Berkhof, and Wessel N. van Wieringen Testing
the prediction error difference between 2 predictors Biostatistics (2009)
10(3): 550-560 doi:10.1093/biostatistics/kxp011
</p>
<p>Michael W Kattan and Thomas A Gerds. The index of prediction accuracy: an
intuitive measure useful for evaluating risk prediction models. Diagnostic
and Prognostic Research, 2(1):7, 2018.
</p>
<p>Fawcett, T. (2006). An introduction to ROC analysis. Pattern
Recognition Letters, 27, 861-874.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># binary outcome
library(lava)
set.seed(18)
learndat &lt;- sampleData(48,outcome="binary")
testdat &lt;- sampleData(40,outcome="binary")

## score logistic regression models
lr1 = glm(Y~X1+X2+X7+X9,data=learndat,family=binomial)
lr2 = glm(Y~X3+X5,data=learndat,family=binomial)
Score(list("LR(X1+X2+X7+X9)"=lr1,"LR(X3+X5)"=lr2),formula=Y~1,data=testdat)

## ROC curve and calibration plot
xb=Score(list("LR(X1+X2+X7+X9)"=lr1,"LR(X3+X5+X6)"=lr2),formula=Y~1,
         data=testdat,plots=c("calibration","ROC"))
## Not run: plotROC(xb)
plotCalibration(xb)

## End(Not run)

## compute AUC for a list of continuous markers
markers = as.list(testdat[,.(X6,X7,X8,X9,X10)])
Score(markers,formula=Y~1,data=testdat,metrics=c("auc"))

# cross-validation
## Not run: 
    set.seed(10)
    learndat=sampleData(400,outcome="binary")
    lr1a = glm(Y~X6,data=learndat,family=binomial)
    lr2a = glm(Y~X7+X8+X9,data=learndat,family=binomial)
    ## bootstrap cross-validation
    x1=Score(list("LR1"=lr1a,"LR2"=lr2a),formula=Y~1,data=learndat,split.method="bootcv",B=100)
    x1
    ## leave-one-out and leave-pair-out bootstrap
    x2=Score(list("LR1"=lr1a,"LR2"=lr2a),formula=Y~1,data=learndat,
             split.method="loob",
             B=100,plots="calibration")
    x2
    ## 5-fold cross-validation
    x3=Score(list("LR1"=lr1a,"LR2"=lr2a),formula=Y~1,data=learndat,
             split.method="cv5",
             B=1,plots="calibration")
    x3

## End(Not run)
# survival outcome

# Score Cox regression models
## Not run: library(survival)
library(rms)
library(prodlim)
set.seed(18)
trainSurv &lt;- sampleData(100,outcome="survival")
testSurv &lt;- sampleData(40,outcome="survival")
cox1 = coxph(Surv(time,event)~X1+X2+X7+X9,data=trainSurv, y=TRUE, x = TRUE)
cox2 = coxph(Surv(time,event)~X3+X5+X6,data=trainSurv, y=TRUE, x = TRUE)
x=Score(list("Cox(X1+X2+X7+X9)"=cox1,"Cox(X3+X5+X6)"=cox2),
         formula=Surv(time,event)~1,data=testSurv,conf.int=FALSE,times=c(5,8))
## Use Cox to estimate censoring weights
y=Score(list("Cox(X1+X2+X7+X9)"=cox1,"Cox(X3+X5+X6)"=cox2),
         formula=Surv(time,event)~X1+X8,data=testSurv,conf.int=FALSE,times=c(5,8)) 
## Use GLMnet to estimate censoring weights
z=Score(list("Cox(X1+X2+X7+X9)"=cox1,"Cox(X3+X5+X6)"=cox2),
         formula=Surv(time,event)~X1+X8,cens.model = "GLMnet",data=testSurv,
         conf.int=FALSE,times=c(5,8)) 
## Use hal9001 to estimate censoring weights
w=Score(list("Cox(X1+X2+X7+X9)"=cox1,"Cox(X3+X5+X6)"=cox2),
         formula=Surv(time,event)~X1+X8,cens.model = "Hal9001",data=testSurv,
         conf.int=FALSE,times=c(5,8)) 
x
y
z
w

## End(Not run)

## Not run: library(survival)
library(rms)
library(prodlim)
set.seed(18)
trainSurv &lt;- sampleData(100,outcome="survival")
testSurv &lt;- sampleData(40,outcome="survival")
cox1 = coxph(Surv(time,event)~X1+X2+X7+X9,data=trainSurv, y=TRUE, x = TRUE)
cox2 = coxph(Surv(time,event)~X3+X5+X6,data=trainSurv, y=TRUE, x = TRUE)
xs=Score(list("Cox(X1+X2+X7+X9)"=cox1,"Cox(X3+X5+X6)"=cox2),
         formula=Surv(time,event)~1,data=testSurv,conf.int=FALSE,times=c(5,8))
xs

## End(Not run)
# Integrated Brier score
## Not run: 
xs=Score(list("Cox(X1+X2+X7+X9)"=cox1,"Cox(X3+X5+X6)"=cox2),
         formula=Surv(time,event)~1,data=testSurv,conf.int=FALSE,
         summary="ibs",
         times=sort(unique(testSurv$time)))

## End(Not run)

# time-dependent AUC for list of markers
## Not run: survmarkers = as.list(testSurv[,.(X6,X7,X8,X9,X10)])
Score(survmarkers,
      formula=Surv(time,event)~1,metrics="auc",data=testSurv,
      conf.int=TRUE,times=c(5,8))

# compare models on test data
Score(list("Cox(X1+X2+X7+X9)"=cox1,"Cox(X3+X5+X6)"=cox2),
      formula=Surv(time,event)~1,data=testSurv,conf.int=TRUE,times=c(5,8))

## End(Not run)
# crossvalidation models in traindata
## Not run: 
    library(survival)
    set.seed(18)
    trainSurv &lt;- sampleData(400,outcome="survival")
    cox1 = coxph(Surv(time,event)~X1+X2+X7+X9,data=trainSurv, y=TRUE, x = TRUE)
    cox2 = coxph(Surv(time,event)~X3+X5+X6,data=trainSurv, y=TRUE, x = TRUE)
    x1 = Score(list("Cox(X1+X2+X7+X9)"=cox1,"Cox(X3+X5+X6)"=cox2),
               formula=Surv(time,event)~1,data=trainSurv,conf.int=TRUE,times=c(5,8),
               split.method="loob",B=100,plots="calibration")

    x2= Score(list("Cox(X1+X2+X7+X9)"=cox1,"Cox(X3+X5+X6)"=cox2),
              formula=Surv(time,event)~1,data=trainSurv,conf.int=TRUE,times=c(5,8),
              split.method="bootcv",B=100)

## End(Not run)

# restrict number of comparisons
## Not run: 
    Score(list("Cox(X1+X2+X7+X9)"=cox1,"Cox(X3+X5+X6)"=cox2),
          formula=Surv(time,event)~1,data=trainSurv,contrasts=TRUE,
          null.model=FALSE,conf.int=TRUE,times=c(5,8),split.method="bootcv",B=3)

    # competing risks outcome
    set.seed(18)
    trainCR &lt;- sampleData(400,outcome="competing.risks")
    testCR &lt;- sampleData(400,outcome="competing.risks")
    library(riskRegression)
    library(cmprsk)
    # Cause-specific Cox regression
    csc1 = CSC(Hist(time,event)~X1+X2+X7+X9,data=trainCR)
    csc2 = CSC(Hist(time,event)~X3+X5+X6,data=trainCR)
    # Fine-Gray regression
    fgr1 = FGR(Hist(time,event)~X1+X2+X7+X9,data=trainCR,cause=1)
    fgr2 = FGR(Hist(time,event)~X3+X5+X6,data=trainCR,cause=1)
    Score(list("CSC(X1+X2+X7+X9)"=csc1,"CSC(X3+X5+X6)"=csc2,
               "FGR(X1+X2+X7+X9)"=fgr1,"FGR(X3+X5+X6)"=fgr2),
          formula=Hist(time,event)~1,data=testCR,se.fit=1L,times=c(5,8))

## End(Not run)



## Not run: 
    # reproduce some results of Table IV of Blanche et al. Stat Med 2013
    data(Paquid)
    ResPaquid &lt;- Score(list("DSST"=-Paquid$DSST,"MMSE"=-Paquid$MMSE),
                       formula=Hist(time,status)~1,
                       data=Paquid,
                       null.model = FALSE,
                       conf.int=TRUE,
                       metrics=c("auc"),
                       times=c(3,5,10),
                       plots="ROC")
    ResPaquid
    plotROC(ResPaquid,time=5)

## End(Not run)
## Not run: 
# parallel options
# by erikvona: Here is a generic example of using future
# and doFuture, works great with the current version:
library(riskRegression)
library(future)
library(foreach)
library(doFuture)
library(survival)
# Register all available cores for parallel operation
plan(multiprocess, workers = availableCores())
registerDoFuture()
set.seed(10)
trainSurv &lt;- sampleData(400,outcome="survival")
cox1 = coxph(Surv(time,event)~X1+X2+X7+X9,data=trainSurv,
             y=TRUE, x = TRUE)
# Bootstrapping on multiple cores
x1 = Score(list("Cox(X1+X2+X7+X9)"=cox1),
     formula=Surv(time,event)~1,data=trainSurv, times=c(5,8),
     parallel = "as.registered", split.method="bootcv",B=100)

## End(Not run)



</code></pre>

<hr>
<h2 id='score.wglm'>Score for IPCW Logistic Regressions</h2><span id='topic+score.wglm'></span>

<h3>Description</h3>

<p>Compute the first derivative of the log-likelihood for IPCW logistic regressions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wglm'
score(x, indiv = FALSE, times = NULL, simplifies = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="score.wglm_+3A_x">x</code></td>
<td>
<p>a wglm object.</p>
</td></tr>
<tr><td><code id="score.wglm_+3A_indiv">indiv</code></td>
<td>
<p>[logical] should the individual score be output? Otherwise the total score (i.e. summed over all individuals will be output).</p>
</td></tr>
<tr><td><code id="score.wglm_+3A_times">times</code></td>
<td>
<p>[numeric vector] time points at which the score should be output.</p>
</td></tr>
<tr><td><code id="score.wglm_+3A_simplifies">simplifies</code></td>
<td>
<p>[logical] should the ouput be converted to a matrix when only one timepoint is requested. Otherwise will always return a list.</p>
</td></tr>
<tr><td><code id="score.wglm_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>

<hr>
<h2 id='selectCox'>Backward variable selection in the Cox regression model</h2><span id='topic+selectCox'></span>

<h3>Description</h3>

<p>This is a wrapper function which first selects variables in the Cox
regression model using <code>fastbw</code> from the <code>rms</code> package and then
returns a fitted Cox regression model with the selected variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selectCox(formula, data, rule = "aic")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selectCox_+3A_formula">formula</code></td>
<td>
<p>A formula object with a <code>Surv</code> object on the left-hand
side and all the variables on the right-hand side.</p>
</td></tr>
<tr><td><code id="selectCox_+3A_data">data</code></td>
<td>
<p>Name of an data frame containing all needed variables.</p>
</td></tr>
<tr><td><code id="selectCox_+3A_rule">rule</code></td>
<td>
<p>The method for selecting variables. See <code>fastbw</code> for
details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function first calls <code>cph</code> then <code>fastbw</code> and finally
<code>cph</code> again.
</p>


<h3>References</h3>

<p>Ulla B. Mogensen, Hemant Ishwaran, Thomas A. Gerds (2012).
Evaluating Random Forests for Survival Analysis Using Prediction Error
Curves. Journal of Statistical Software, 50(11), 1-23. URL
http://www.jstatsoft.org/v50/i11/.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(survival)
set.seed(74)
d &lt;- sampleData(89,outcome="survival")
f &lt;- selectCox(Surv(time,event)~X1+X2+X3+X4+X6+X7+X8+X9, data=d)

</code></pre>

<hr>
<h2 id='selectJump'>Evaluate the influence function at selected times</h2><span id='topic+selectJump'></span>

<h3>Description</h3>

<p>Evaluate the influence function at selected times
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selectJump(IF, times, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selectJump_+3A_if">IF</code></td>
<td>
<p>influence function returned by iidCox</p>
</td></tr>
<tr><td><code id="selectJump_+3A_times">times</code></td>
<td>
<p>the times at which the influence function should be assessed</p>
</td></tr>
<tr><td><code id="selectJump_+3A_type">type</code></td>
<td>
<p>can be <code>"hazard"</code> or/and <code>"cumhazard"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object with the same dimensions as IF
</p>


<h3>Author(s)</h3>

<p>Brice Ozenne broz@sund.ku.dk
</p>

<hr>
<h2 id='simActiveSurveillance'>Simulate data of a hypothetical active surveillance prostate cancer study</h2><span id='topic+simActiveSurveillance'></span>

<h3>Description</h3>

<p>Simulate data of a hypothetical active surveillance prostate cancer study
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simActiveSurveillance(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simActiveSurveillance_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is based on the functionality of <code>library(lava)</code>.
</p>


<h3>Value</h3>

<p>data table of size n
</p>


<h3>Author(s)</h3>

<p>Thomas A. Gerds &lt;tag@biostat.ku.dk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(71)
simActiveSurveillance(3)
</code></pre>

<hr>
<h2 id='simMelanoma'>Simulate data alike the Melanoma data</h2><span id='topic+simMelanoma'></span>

<h3>Description</h3>

<p>Simulate data alike the Melanoma data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simMelanoma(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simMelanoma_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is based on the functionality of <code>library(lava)</code>.
</p>


<h3>Value</h3>

<p>data table of size n
</p>


<h3>Author(s)</h3>

<p>Thomas A. Gerds &lt;tag@biostat.ku.dk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(71)
simMelanoma(3)
</code></pre>

<hr>
<h2 id='simPBC'>simulating data alike the pbc data</h2><span id='topic+simPBC'></span>

<h3>Description</h3>

<p>This function can be used to simulate data alike the pbc data from the survival package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simPBC(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simPBC_+3A_n">n</code></td>
<td>
<p>Sample size</p>
</td></tr>
</table>


<h3>Details</h3>

<p>using lava to synthesize data
</p>


<h3>Value</h3>

<p>The simulated data.
</p>


<h3>Author(s)</h3>

<p>Thomas A. Gerds &lt;tag@biostat.ku.dk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(survival)
library(lava)
# simulate data alike pbc data
set.seed(98)
d=simPBC(847)
d$protimegrp1 &lt;- d$protimegrp=="10-11"
d$protimegrp2 &lt;- d$protimegrp=="&gt;11"
d$sex &lt;- factor(d$sex,levels=0:1,labels=c("m","f"))
sF1 &lt;- survreg(Surv(time,status==1)~sex+age+logbili+protimegrp1+protimegrp2+stage3+stage4,
data=d)
coxF1 &lt;- coxph(Surv(time,status==1)~sex+age+logbili+protimegrp1+protimegrp2+stage3+stage4,
data=d)
# load real pbc data
data(pbc,package="survival")
pbc &lt;- na.omit(pbc[,c("time","status","age","sex","stage","bili","protime","trt")])
pbc$stage &lt;- factor(pbc$stage)
levels(pbc$stage) &lt;- list("1/2"=c(1,2),"3"=3,"4"=4)
pbc$logbili &lt;- log(pbc$bili)
pbc$logprotime &lt;- log(pbc$protime)
pbc$stage3 &lt;- 1*(pbc$stage=="3")
pbc$stage4 &lt;- 1*(pbc$stage=="4")
pbc$protimegrp &lt;- cut(pbc$protime,c(-Inf,10,11,Inf),labels=c("&lt;=10","10-11","&gt;11"))
pbc$protimegrp1 &lt;- pbc$protimegrp=="10-11"
pbc$protimegrp2 &lt;- pbc$protimegrp=="&gt;11"
form1=Surv(time,status==1)~sex+age+logbili+protimegrp1+protimegrp2+stage3+stage4
F1 &lt;- survival::survreg(form1,data=pbc)
form2=Surv(time,status==2)~sex+age+logbili+protimegrp1+protimegrp2+stage3+stage4
F2 &lt;- survival::survreg(form1,data=pbc)
sF2 &lt;- survreg(Surv(time,status==2)~sex+age+logbili+protimegrp1+protimegrp2+stage3+stage4,
data=d)
G &lt;- survreg(Surv(time,status==0)~sex+age+logbili+protimegrp1+protimegrp2+stage3+stage4,
data=pbc)
sG &lt;- survreg(Surv(time,status==0)~sex+age+logbili+protimegrp1+protimegrp2+stage3+stage4,
data=d)
# compare fits in real and simulated pbc data
cbind(coef(F1),coef(sF1))
cbind(coef(F2),coef(sF2))
cbind(coef(G),coef(sG))
cbind(coef(glm(protimegrp1~age+sex+logbili,data=pbc,family="binomial")),
coef(glm(protimegrp1~age+sex+logbili,data=d,family="binomial")))
cbind(coef(lm(logbili~age+sex,data=pbc)),coef(lm(logbili~age+sex,data=d)))
</code></pre>

<hr>
<h2 id='simsynth'>Simulating from a synthesized object</h2><span id='topic+simsynth'></span>

<h3>Description</h3>

<p>Simulating from a synthesized object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simsynth(object, n = 200, drop.latent = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simsynth_+3A_object">object</code></td>
<td>
<p>generated with <code>synthesize</code></p>
</td></tr>
<tr><td><code id="simsynth_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="simsynth_+3A_drop.latent">drop.latent</code></td>
<td>
<p>if <code>TRUE</code> remove the latent event times from the resulting data set.</p>
</td></tr>
<tr><td><code id="simsynth_+3A_...">...</code></td>
<td>
<p>additional arguments passed on to <code>lava::sim</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(survival)
m=synthesize(Surv(time,status)~sex+age+bili,data=pbc)
simsynth(m,10,drop.latent=TRUE)

</code></pre>

<hr>
<h2 id='SmcFcs'>SmcFcs</h2><span id='topic+SmcFcs'></span>

<h3>Description</h3>

<p>TODO
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SmcFcs(formula, data, m = 5, method, fitter = "glm", fit.formula, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SmcFcs_+3A_formula">formula</code></td>
<td>
<p>TODO</p>
</td></tr>
<tr><td><code id="SmcFcs_+3A_data">data</code></td>
<td>
<p>TODO</p>
</td></tr>
<tr><td><code id="SmcFcs_+3A_m">m</code></td>
<td>
<p>TODO</p>
</td></tr>
<tr><td><code id="SmcFcs_+3A_method">method</code></td>
<td>
<p>TODO</p>
</td></tr>
<tr><td><code id="SmcFcs_+3A_fitter">fitter</code></td>
<td>
<p>TODO</p>
</td></tr>
<tr><td><code id="SmcFcs_+3A_fit.formula">fit.formula</code></td>
<td>
<p>TODO</p>
</td></tr>
<tr><td><code id="SmcFcs_+3A_...">...</code></td>
<td>
<p>TODO
</p>
<p># @export</p>
</td></tr>
</table>

<hr>
<h2 id='splitStrataVar'>Reconstruct each of the strata variables</h2><span id='topic+splitStrataVar'></span>

<h3>Description</h3>

<p>Reconstruct each of the strata variables from the strata variable stored in the coxph object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitStrataVar(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splitStrataVar_+3A_object">object</code></td>
<td>
<p>a coxph object.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Brice Ozenne broz@sund.ku.dk and Thomas A. Gerds tag@biostat.ku.dk
</p>

<hr>
<h2 id='subjectWeights'>Estimation of censoring probabilities at subject specific times</h2><span id='topic+subjectWeights'></span><span id='topic+subjectWeights.none'></span><span id='topic+subjectWeights.km'></span><span id='topic+subjectWeights.marginal'></span><span id='topic+subjectWeights.nonpar'></span><span id='topic+subjectWeights.cox'></span><span id='topic+subjectWeights.aalen'></span>

<h3>Description</h3>

<p>This function is used internally to contruct pseudo values by inverse of the
probability of censoring weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subjectWeights(
  formula,
  data,
  method = c("cox", "marginal", "km", "nonpar", "forest", "none"),
  args,
  lag = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subjectWeights_+3A_formula">formula</code></td>
<td>
<p>A survival formula like, Surv(time,status)~1 or
Hist(time,status)~1 where status=0 means censored. The status
variable is internally reversed for estimation of censoring rather
than survival probabilities. Some of the available models, see
argument <code>model</code>, will use predictors on the right hand side
of the formula.</p>
</td></tr>
<tr><td><code id="subjectWeights_+3A_data">data</code></td>
<td>
<p>The data used for fitting the censoring model</p>
</td></tr>
<tr><td><code id="subjectWeights_+3A_method">method</code></td>
<td>
<p>Censoring model used for estimation of the
(conditional) censoring distribution.</p>
</td></tr>
<tr><td><code id="subjectWeights_+3A_args">args</code></td>
<td>
<p>Arguments passed to the fitter of the method.</p>
</td></tr>
<tr><td><code id="subjectWeights_+3A_lag">lag</code></td>
<td>
<p>If equal to <code>1</code> then obtain <code>G(T_i-|X_i)</code>, if
equal to <code>0</code> estimate the conditional censoring distribution
at the subject.times, i.e. (<code>G(T_i|X_i)</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Inverse of the probability of censoring weights usually refer to the
probabilities of not being censored at certain time points. These
probabilities are also the values of the conditional survival function of
the censoring time given covariates. The function subjectWeights estimates
the conditional survival function of the censoring times and derives the
weights.
</p>
<p>IMPORTANT: the data set should be ordered, <code>order(time,-status)</code> in
order to get the <code>weights</code> in the right order for some choices of
<code>method</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>times</code></td>
<td>
<p>The times at which weights are estimated</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>Estimated weights at individual time values
<code>subject.times</code></p>
</td></tr> <tr><td><code>lag</code></td>
<td>
<p>The time lag.</p>
</td></tr> <tr><td><code>fit</code></td>
<td>
<p>The fitted
censoring model</p>
</td></tr> <tr><td><code>method</code></td>
<td>
<p>The method for modelling the censoring
distribution</p>
</td></tr> <tr><td><code>call</code></td>
<td>
<p>The call</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas A. Gerds <a href="mailto:tag@biostat.ku.dk">tag@biostat.ku.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(prodlim)
library(survival)
dat=SimSurv(300)

dat &lt;- dat[order(dat$time,-dat$status),]

# using the marginal Kaplan-Meier for the censoring times

WKM=subjectWeights(Hist(time,status)~X2,data=dat,method="marginal")
plot(WKM$fit)
WKM$fit
WKM$weights

# using the Cox model for the censoring times given X2

WCox=subjectWeights(Surv(time,status)~X2,data=dat,method="cox")
WCox
plot(WCox$weights,WKM$weights)

# using the stratified Kaplan-Meier for the censoring times given X2

WKM2 &lt;- subjectWeights(Surv(time,status)~X2,data=dat,method="nonpar")
plot(WKM2$fit,add=FALSE)


</code></pre>

<hr>
<h2 id='subsetIndex'>Extract Specific Elements From An Object</h2><span id='topic+subsetIndex'></span><span id='topic+subsetIndex.default'></span><span id='topic+subsetIndex.matrix'></span>

<h3>Description</h3>

<p>Extract specific elements from an object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subsetIndex(object, index, default, ...)

## Default S3 method:
subsetIndex(object, index, default, ...)

## S3 method for class 'matrix'
subsetIndex(object, index, default, col = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subsetIndex_+3A_object">object</code></td>
<td>
<p>A vector or a matrix.</p>
</td></tr>
<tr><td><code id="subsetIndex_+3A_index">index</code></td>
<td>
<p>index of the elements to be extracted.
0 indicates that the column should be set to the default value.
NA indicates that the column should be set to NA.</p>
</td></tr>
<tr><td><code id="subsetIndex_+3A_default">default</code></td>
<td>
<p>the default value.</p>
</td></tr>
<tr><td><code id="subsetIndex_+3A_...">...</code></td>
<td>
<p>Only used by the generic method.</p>
</td></tr>
<tr><td><code id="subsetIndex_+3A_col">col</code></td>
<td>
<p>If object is a matrix, <code>TRUE</code> lead to extract the columns and <code>FALSE</code> the rows.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>M &lt;- matrix(rnorm(50),5,10)
subsetIndex(M, index = c(0,0,1), default = 0)
subsetIndex(M, index = c(0,2,3,NA), default = 0)
subsetIndex(M, index = c(0,NA,2,3,NA), default = 0)

C &lt;- 1:10
subsetIndex(C, index = c(0,0,1,5,NA), default = 0)
</code></pre>

<hr>
<h2 id='summary.ate'>Summary Average Treatment Effects</h2><span id='topic+summary.ate'></span>

<h3>Description</h3>

<p>Summary average treatment effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ate'
summary(
  object,
  estimator = object$estimator[1],
  short = FALSE,
  type = c("meanRisk", "diffRisk"),
  se = FALSE,
  quantile = FALSE,
  estimate.boot = TRUE,
  digits = 3,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.ate_+3A_object">object</code></td>
<td>
<p>object obtained with function <code>ate</code></p>
</td></tr>
<tr><td><code id="summary.ate_+3A_estimator">estimator</code></td>
<td>
<p>[character] The type of estimator relative to which the estimates should be displayed.</p>
</td></tr>
<tr><td><code id="summary.ate_+3A_short">short</code></td>
<td>
<p>[logical] If <code>TRUE</code>, only displays the estimated risks.</p>
</td></tr>
<tr><td><code id="summary.ate_+3A_type">type</code></td>
<td>
<p>[character vector] what to displayed.
Can be <code>"meanRisk"</code> to display the risks specific to each treatment group,
<code>"diffRisk"</code> to display the difference in risks between treatment groups,
or <code>"ratioRisk"</code> to display the ratio of risks between treatment groups,.</p>
</td></tr>
<tr><td><code id="summary.ate_+3A_se">se</code></td>
<td>
<p>[logical] should the standard error of the risks be displayed?</p>
</td></tr>
<tr><td><code id="summary.ate_+3A_quantile">quantile</code></td>
<td>
<p>[logical] should the quantile of the confidence bands be displayed?</p>
</td></tr>
<tr><td><code id="summary.ate_+3A_estimate.boot">estimate.boot</code></td>
<td>
<p>[logical] should the average estimate on the bootstrap samples be displayed?</p>
</td></tr>
<tr><td><code id="summary.ate_+3A_digits">digits</code></td>
<td>
<p>[integer, &gt;0] Number of digits.</p>
</td></tr>
<tr><td><code id="summary.ate_+3A_...">...</code></td>
<td>
<p>passed to confint</p>
</td></tr>
</table>


<h3>Details</h3>

<p>to display confidence intervals/bands and p.value,
the <code>confint</code> method needs to be applied on the object.
</p>


<h3>See Also</h3>

<p><code><a href="data.table.html#topic+as.data.table">as.data.table</a></code> to extract the estimates in a <code>data.table</code> object.
<code><a href="#topic+autoplot.ate">autoplot.ate</a></code> for a graphical representation the standardized risks.
<code><a href="#topic+confint.ate">confint.ate</a></code> to compute p-values and adjusted p-values
or perform statistical inference using a transformation.
<code><a href="#topic+confint.ate">confint.ate</a></code> to compute (pointwise/simultaneous) confidence intervals and (unadjusted/adjusted) p-values, possibly using a transformation.
</p>

<hr>
<h2 id='summary.FGR'>Summary of a Fine-Gray regression model</h2><span id='topic+summary.FGR'></span>

<h3>Description</h3>

<p>Summary of a Fine-Gray regression model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'FGR'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.FGR_+3A_object">object</code></td>
<td>
<p>Object fitted with function FGR</p>
</td></tr>
<tr><td><code id="summary.FGR_+3A_...">...</code></td>
<td>
<p>passed to cmprsk::summary.crr</p>
</td></tr>
</table>

<hr>
<h2 id='summary.riskRegression'>Summary of a risk regression model</h2><span id='topic+summary.riskRegression'></span>

<h3>Description</h3>

<p>Summary of a risk regression model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'riskRegression'
summary(
  object,
  times,
  digits = 3,
  pvalue.digits = 4,
  eps = 10^-4,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.riskRegression_+3A_object">object</code></td>
<td>
<p>Object obtained with ARR, LRR or riskRegression</p>
</td></tr>
<tr><td><code id="summary.riskRegression_+3A_times">times</code></td>
<td>
<p>Time points at which to show time-dependent coefficients</p>
</td></tr>
<tr><td><code id="summary.riskRegression_+3A_digits">digits</code></td>
<td>
<p>Number of digits for all numbers but p-values</p>
</td></tr>
<tr><td><code id="summary.riskRegression_+3A_pvalue.digits">pvalue.digits</code></td>
<td>
<p>Number of digits for p-values</p>
</td></tr>
<tr><td><code id="summary.riskRegression_+3A_eps">eps</code></td>
<td>
<p>p-values smaller than this number are shown as such</p>
</td></tr>
<tr><td><code id="summary.riskRegression_+3A_verbose">verbose</code></td>
<td>
<p>Level of verbosity</p>
</td></tr>
<tr><td><code id="summary.riskRegression_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>

<hr>
<h2 id='summary.Score'>Summary of prediction performance metrics</h2><span id='topic+summary.Score'></span>

<h3>Description</h3>

<p>Summarizing a Score object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Score'
summary(
  object,
  times,
  what = c("score", "contrasts"),
  models,
  digits = 1,
  pvalue.digits = 4,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.Score_+3A_object">object</code></td>
<td>
<p>Object obtained with <code>Score</code>.</p>
</td></tr>
<tr><td><code id="summary.Score_+3A_times">times</code></td>
<td>
<p>Select time points</p>
</td></tr>
<tr><td><code id="summary.Score_+3A_what">what</code></td>
<td>
<p>Either <code>"score"</code>, <code>"contrasts"</code> or both, i.e., <code>c("score","contrasts")</code></p>
</td></tr>
<tr><td><code id="summary.Score_+3A_models">models</code></td>
<td>
<p>Select which models to summarize. Need to be a subset of <code>object$models</code></p>
</td></tr>
<tr><td><code id="summary.Score_+3A_digits">digits</code></td>
<td>
<p>For rounding everything but p-values</p>
</td></tr>
<tr><td><code id="summary.Score_+3A_pvalue.digits">pvalue.digits</code></td>
<td>
<p>For rounding p-values</p>
</td></tr>
<tr><td><code id="summary.Score_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The AUC and the Brier score are put into tables
</p>


<h3>Value</h3>

<p>List of tables
</p>


<h3>Author(s)</h3>

<p>Thomas A. Gerds &lt;tag@biostat.ku.dk&gt;
</p>


<h3>See Also</h3>

<p>Score
</p>

<hr>
<h2 id='SuperPredictor'>Formula interface for SuperLearner::SuperLearner</h2><span id='topic+SuperPredictor'></span>

<h3>Description</h3>

<p>Formula interface for SuperLearner::SuperLearner
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SuperPredictor(
  formula,
  data,
  family = "binomial",
  SL.library = c("SL.glm", "SL.glm.interaction", "SL.ranger"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SuperPredictor_+3A_formula">formula</code></td>
<td>
<p>where the left hand side specifies the outcome and the right hand side the predictors</p>
</td></tr>
<tr><td><code id="SuperPredictor_+3A_data">data</code></td>
<td>
<p>data set in which formula can be evaluated</p>
</td></tr>
<tr><td><code id="SuperPredictor_+3A_family">family</code></td>
<td>
<p>the outcome family. default is binomial</p>
</td></tr>
<tr><td><code id="SuperPredictor_+3A_sl.library">SL.library</code></td>
<td>
<p>the SuperLearner libraries</p>
</td></tr>
<tr><td><code id="SuperPredictor_+3A_...">...</code></td>
<td>
<p>passed to SuperLearner::SuperLearner</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Formula interface for SuperLearner::SuperLearner
##' @param formula
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if(require("SuperLearner",quietly=TRUE)){
library(SuperLearner)
library(data.table)
set.seed(10)
d = sampleData(338, outcome="binary")
spfit = SuperPredictor(Y~X1+X2+X3+X4+X5+X6+X7+X8+X9+X10,data=d)
predictRisk(spfit)
x &lt;- Score(list(spfit),data=d,formula=Y~1)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='SurvResponseVar'>Extract the time and event variable from a Cox model</h2><span id='topic+SurvResponseVar'></span>

<h3>Description</h3>

<p>Extract the time and event variable from a Cox model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SurvResponseVar(formula)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SurvResponseVar_+3A_formula">formula</code></td>
<td>
<p>a formula</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Brice Ozenne broz@sund.ku.dk
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
SurvResponseVar(Surv(time,event)~X1+X2)
SurvResponseVar(Hist(time,event==0)~X1+X2)
SurvResponseVar(Surv(start,time, status,type="counting") ~ X3+X5)
SurvResponseVar(Surv(start,event=status, time2=time,type="counting") ~ X3+X5)

SurvResponseVar(survival::Surv(start,event=status, time2=time,type="counting") ~ X3+X5)
SurvResponseVar(status ~ X3+X5)
SurvResponseVar(I(status == 1) ~ X3+X5)
SurvResponseVar(list(Hist(time, event) ~ X1+X6,Hist(time, event) ~ X6))

## End(Not run)
</code></pre>

<hr>
<h2 id='synthesize'>Cooking and synthesizing survival data</h2><span id='topic+synthesize'></span><span id='topic+synthesize.formula'></span><span id='topic+synthesize.lvm'></span>

<h3>Description</h3>

<p>Fit parametric regression models to the outcome distribution and optionally
also parametric regression models for the joint distribution of the predictors
structural equation models. 
Then the function <code>sim.synth</code> can be called on the  resulting object to
to simulate from the parametric model based on the machinery of the <code>lava</code> package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>synthesize(object, data, ...)

## S3 method for class 'formula'
synthesize(
  object,
  data,
  recursive = FALSE,
  max.levels = 10,
  verbose = FALSE,
  ...
)

## S3 method for class 'lvm'
synthesize(
  object,
  data,
  max.levels = 10,
  logtrans = NULL,
  verbose = FALSE,
  fix.names = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="synthesize_+3A_object">object</code></td>
<td>
<p>Specification of the synthesizing model structures. Either a <code>formula</code> or a <code>lvm</code> object. See examples.</p>
</td></tr>
<tr><td><code id="synthesize_+3A_data">data</code></td>
<td>
<p>Data to be synthesized.</p>
</td></tr>
<tr><td><code id="synthesize_+3A_...">...</code></td>
<td>
<p>Not used yet.</p>
</td></tr>
<tr><td><code id="synthesize_+3A_recursive">recursive</code></td>
<td>
<p>Let covariates recursively depend on each other.</p>
</td></tr>
<tr><td><code id="synthesize_+3A_max.levels">max.levels</code></td>
<td>
<p>Integer used to guess which variables are categorical. When set to <code>10</code>, the default,
variables with less than 10 unique values in data are treated as categorical.</p>
</td></tr>
<tr><td><code id="synthesize_+3A_verbose">verbose</code></td>
<td>
<p>Logical. If <code>TRUE</code> then more messages and warnings are provided.</p>
</td></tr>
<tr><td><code id="synthesize_+3A_logtrans">logtrans</code></td>
<td>
<p>Vector of covariate names that should be log-transformed. This is primarily for internal use.</p>
</td></tr>
<tr><td><code id="synthesize_+3A_fix.names">fix.names</code></td>
<td>
<p>Fix possible problematic covariate names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Synthesizes survival data (also works for linear models and generalized linear models).
The idea is to be able to simulate new data sets that mimic the original data.
See the vignette <code>vignette("synthesize",package = "riskRegression")</code> for more details.
</p>
<p>The simulation engine is: lava.
</p>


<h3>Value</h3>

<p>lava object
</p>


<h3>Author(s)</h3>

<p>Thomas A. Gerds &lt;tag@biostat.ku.dk&gt;
</p>


<h3>See Also</h3>

<p>lvm
</p>


<h3>Examples</h3>

<pre><code class='language-R'># pbc data
library(survival)
library(lava)
data(pbc)
pbc &lt;- na.omit(pbc[,c("time","status","sex","age","bili")])
pbc$logbili &lt;- log(pbc$bili)
v_synt &lt;- synthesize(object=Surv(time,status)~sex+age+logbili,data=pbc)
d &lt;- simsynth(v_synt,1000)
fit_sim &lt;- coxph(Surv(time,status==1)~age+sex+logbili,data=d)
fit_real &lt;- coxph(Surv(time,status==1)~age+sex+logbili,data=pbc)
# compare estimated log-hazard ratios between simulated and real data
cbind(coef(fit_sim),coef(fit_real))

u &lt;- lvm()
distribution(u,~sex) &lt;- binomial.lvm()
distribution(u,~age) &lt;- normal.lvm()
distribution(u,~trt) &lt;- binomial.lvm()
distribution(u,~logbili) &lt;- normal.lvm()
u &lt;-eventTime(u,time~min(time.cens=0,time.transplant=1,time.death=2), "status")
lava::regression(u,logbili~age+sex) &lt;- 1
lava::regression(u,time.transplant~sex+age+logbili) &lt;- 1
lava::regression(u,time.death~sex+age+logbili) &lt;- 1
lava::regression(u,time.cens~1) &lt;- 1
transform(u,logbili~bili) &lt;- function(x){log(x)}
u_synt &lt;- synthesize(object=u, data=na.omit(pbc))
set.seed(8)
d &lt;- simsynth(u_synt,n=1000)
# note: synthesize may relabel status variable
fit_sim &lt;- coxph(Surv(time,status==1)~age+sex+logbili,data=d)
fit_real &lt;- coxph(Surv(time,status==1)~age+sex+log(bili),data=pbc)
# compare estimated log-hazard ratios between simulated and real data
cbind(coef(fit_sim),coef(fit_real))

#
# Cancer data
#
data(cancer)
b &lt;- lvm()
distribution(b,~rx) &lt;- binomial.lvm()
distribution(b,~age) &lt;- normal.lvm()
distribution(b,~resid.ds) &lt;- binomial.lvm()
distribution(b,~ecog.ps) &lt;- binomial.lvm()
lava::regression(b,time.death~age+rx+resid.ds) &lt;- 1
b&lt;-eventTime(b,futime~min(time.cens=0,time.death=1), "fustat")
b_synt &lt;- synthesize(object = b, data = ovarian)
D &lt;- simsynth(b_synt,1000)
fit_real &lt;- coxph(Surv(futime,fustat)~age+rx+resid.ds, data=ovarian)
fit_sim &lt;- coxph(Surv(futime,fustat)~age+rx+resid.ds, data=D)
cbind(coef(fit_sim),coef(fit_real))
w_synt &lt;- synthesize(object=Surv(futime,fustat)~age+rx+resid.ds, data=ovarian)
D &lt;- simsynth(w_synt,1000)
fit_sim &lt;- coxph(Surv(futime,fustat==1)~age+rx+resid.ds,data=D)
fit_real &lt;- coxph(Surv(futime,fustat==1)~age+rx+resid.ds,data=ovarian)
# compare estimated log-hazard ratios between simulated and real data
cbind(coef(fit_sim),coef(fit_real))


</code></pre>

<hr>
<h2 id='terms.phreg'>Extract terms for phreg objects</h2><span id='topic+terms.phreg'></span>

<h3>Description</h3>

<p>Extract terms for phreg objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'phreg'
terms(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="terms.phreg_+3A_x">x</code></td>
<td>
<p>a phreg object.</p>
</td></tr>
<tr><td><code id="terms.phreg_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>

<hr>
<h2 id='transformCIBP'>Compute Confidence Intervals/Bands and P-values After a Transformation</h2><span id='topic+transformCIBP'></span>

<h3>Description</h3>

<p>Compute confidence intervals/bands and p-values after a transformation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transformCIBP(
  estimate,
  se,
  iid,
  null,
  conf.level,
  alternative,
  ci,
  type,
  min.value,
  max.value,
  band,
  method.band,
  n.sim,
  seed,
  p.value,
  df = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transformCIBP_+3A_estimate">estimate</code></td>
<td>
<p>[numeric matrix] the estimate value before transformation.</p>
</td></tr>
<tr><td><code id="transformCIBP_+3A_se">se</code></td>
<td>
<p>[numeric matrix] the standard error before transformation.</p>
</td></tr>
<tr><td><code id="transformCIBP_+3A_iid">iid</code></td>
<td>
<p>[numeric array] the iid decomposition before transformation.</p>
</td></tr>
<tr><td><code id="transformCIBP_+3A_null">null</code></td>
<td>
<p>[numeric] the value of the estimate (before transformation) under the null hypothesis.</p>
</td></tr>
<tr><td><code id="transformCIBP_+3A_conf.level">conf.level</code></td>
<td>
<p>[numeric, 0-1] Level of confidence.</p>
</td></tr>
<tr><td><code id="transformCIBP_+3A_alternative">alternative</code></td>
<td>
<p>[character] a character string specifying the alternative hypothesis,
must be one of <code>"two.sided"</code> (default), <code>"greater"</code> or <code>"less"</code>.</p>
</td></tr>
<tr><td><code id="transformCIBP_+3A_ci">ci</code></td>
<td>
<p>[logical] should confidence intervals be computed.</p>
</td></tr>
<tr><td><code id="transformCIBP_+3A_type">type</code></td>
<td>
<p>[character] the transforamtion.
Can be <code>"log"</code>, <code>"loglog"</code>, <code>"cloglog"</code>, or <code>"atanh"</code> (Fisher transform), or <code>"atanh2"</code> (modified Fisher transform for [0-1] variable).</p>
</td></tr>
<tr><td><code id="transformCIBP_+3A_min.value">min.value</code></td>
<td>
<p>[numeric] if not <code>NULL</code> and the lower bound of the confidence interval is below <code>min</code>,
it will be set at <code>min</code>.</p>
</td></tr>
<tr><td><code id="transformCIBP_+3A_max.value">max.value</code></td>
<td>
<p>[numeric] if not <code>NULL</code> and the lower bound of the confidence interval is below <code>max</code>,
it will be set at <code>max</code>.</p>
</td></tr>
<tr><td><code id="transformCIBP_+3A_band">band</code></td>
<td>
<p>[integer 0,1,2] When non-0, the confidence bands are computed for each contrasts (<code>band=1</code>) or over all contrasts (<code>band=2</code>).</p>
</td></tr>
<tr><td><code id="transformCIBP_+3A_method.band">method.band</code></td>
<td>
<p>[character] method used to adjust for multiple comparisons.
Can be any element of <code>p.adjust.methods</code> (e.g. <code>"holm"</code>), <code>"maxT-integration"</code>, or <code>"maxT-simulation"</code>.</p>
</td></tr>
<tr><td><code id="transformCIBP_+3A_n.sim">n.sim</code></td>
<td>
<p>[integer, &gt;0] the number of simulations used to compute the quantiles for the confidence bands.</p>
</td></tr>
<tr><td><code id="transformCIBP_+3A_seed">seed</code></td>
<td>
<p>[integer, &gt;0] seed number set before performing simulations for the confidence bands.</p>
</td></tr>
<tr><td><code id="transformCIBP_+3A_p.value">p.value</code></td>
<td>
<p>[logical] should p-values and adjusted p-values be computed. Only active if <code>ci=TRUE</code> or <code>band&gt;0</code>.</p>
</td></tr>
<tr><td><code id="transformCIBP_+3A_df">df</code></td>
<td>
<p>[integer, &gt;0] optional. Degrees of freedom used for the student distribution of the test statistic. If not specified, use a normal distribution instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The iid decomposition must have dimensions [n.obs,time,n.prediction]
while estimate and se must have dimensions [n.prediction,time].
</p>
<p>Single step max adjustment for multiple comparisons, i.e. accounting for the correlation between the test statistics but not for the ordering of the tests, can be performed setting the arguemnt <code>method.band</code> to <code>"maxT-integration"</code> or <code>"maxT-simulation"</code>. The former uses numerical integration (<code>pmvnorm</code> and <code>qmvnorm</code> to perform the adjustment while the latter using simulation. Both assume that the test statistics are jointly normally distributed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(10)
n &lt;- 100
X &lt;- rnorm(n)

res2sided &lt;- transformCIBP(estimate = mean(X), se = cbind(sd(X)/sqrt(n)), null = 0,
              type = "none", ci = TRUE, conf.level = 0.95, alternative = "two.sided",
              min.value = NULL, max.value = NULL, band = FALSE,
              p.value = TRUE, seed = 10, df = n-1)

resLess &lt;- transformCIBP(estimate = mean(X), se = cbind(sd(X)/sqrt(n)), null = 0,
              type = "none", ci = TRUE, conf.level = 0.95, alternative = "less",
              min.value = NULL, max.value = NULL, band = FALSE,
              p.value = TRUE, seed = 10, df = n-1)

resGreater &lt;- transformCIBP(estimate = mean(X), se = cbind(sd(X)/sqrt(n)), null = 0,
              type = "none", ci = TRUE, conf.level = 0.95, alternative = "greater",
              min.value = NULL, max.value = NULL, band = FALSE,
              p.value = TRUE, seed = 10, df = n-1)


## comparison with t-test
GS &lt;- t.test(X, alternative = "two.sided")
res2sided$p.value - GS$p.value
unlist(res2sided[c("lower","upper")]) - GS$conf.int

GS &lt;- t.test(X, alternative = "less")
resLess$p.value - GS$p.value
unlist(resLess[c("lower","upper")]) - GS$conf.int

GS &lt;- t.test(X, alternative = "greater")
resGreater$p.value - GS$p.value
unlist(resGreater[c("lower","upper")]) - GS$conf.int

</code></pre>

<hr>
<h2 id='wglm'>Logistic Regression Using IPCW</h2><span id='topic+wglm'></span>

<h3>Description</h3>

<p>Logistic regression over multiple timepoints
where right-censoring is handled using inverse probability of censoring weighting (IPCW).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wglm(
  regressor.event,
  formula.censor,
  times,
  data,
  cause = NA,
  fitter = "coxph",
  product.limit = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wglm_+3A_regressor.event">regressor.event</code></td>
<td>
<p>[formula] a formula with empty left hand side and the covariates for the logistic regression on the right hand side.</p>
</td></tr>
<tr><td><code id="wglm_+3A_formula.censor">formula.censor</code></td>
<td>
<p>[formula] a formula used to fit the censoring model.</p>
</td></tr>
<tr><td><code id="wglm_+3A_times">times</code></td>
<td>
<p>[numeric vector] time points at which to model the probability of experiencing an event.</p>
</td></tr>
<tr><td><code id="wglm_+3A_data">data</code></td>
<td>
<p>[data.frame] dataset containing the time at which the event occured, the type of event, and regressors used to fit the censoring and logistic models.</p>
</td></tr>
<tr><td><code id="wglm_+3A_cause">cause</code></td>
<td>
<p>[character or numeric] the cause of interest. Defaults to the first cause.</p>
</td></tr>
<tr><td><code id="wglm_+3A_fitter">fitter</code></td>
<td>
<p>[character] routine to fit the Cox regression models.</p>
</td></tr>
<tr><td><code id="wglm_+3A_product.limit">product.limit</code></td>
<td>
<p>[logical] if <code>TRUE</code> the survival is computed using the product limit estimator.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>First, a Cox model is fitted (argument formula.censor)
and the censoring probabilities are computed relative to each timepoint (argument times) to obtain the censoring weights.
Then, for each timepoint, a logistic regression is fitted with the appropriate censoring weights
and where the outcome is the indicator of having experience the event of interest (argument cause) at or before the timepoint.
</p>


<h3>Value</h3>

<p>an object of class <code>"wglm"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(survival)

set.seed(10)
n &lt;- 250
tau &lt;- 1:5
d &lt;- sampleData(n, outcome = "competing.risks")
dFull &lt;- d[event!=0] ## remove censoring
dSurv &lt;- d[event!=2] ## remove competing risk

#### no censoring ####
e.wglm &lt;- wglm(regressor.event = ~ X1, formula.censor = Surv(time,event==0) ~ 1,
               times = tau, data = dFull, product.limit = TRUE)
e.wglm ## same as a logistic regression

summary(ate(e.wglm, data = dFull, times = tau, treatment = "X1", verbose = FALSE))

#### right-censoring ####
## no covariante in the censoring model (independent censoring)
eC.wglm &lt;- wglm(regressor.event = ~ X1, formula.censor = Surv(time,event==0) ~ 1,
               times = tau, data = dSurv, product.limit = TRUE)
eC.wglm

## with covariates in the censoring model
eC2.wglm &lt;- wglm(regressor.event = ~ X1 + X8,
                formula.censor = Surv(time,event==0) ~ X1*X8,
                 times = tau, data = dSurv)
eC2.wglm

#### Competing risks ####
## here Kaplan-Meier as censoring model
eCR.wglm &lt;- wglm(regressor.event = ~ X1,
                 formula.censor = Surv(time,event==0) ~ strata(X1),
                 times = tau, data = d, cause = 1, product.limit = TRUE)
eCR.wglm

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
