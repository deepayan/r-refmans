<!DOCTYPE html><html><head><title>Help for package kergp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {kergp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#kergp-package'>
<p>Gaussian Process Laboratory</p>
</p></a></li>
<li><a href='#as.list, covTP-method'><p>Coerce a <code>covTP</code> Object into a List</p></a></li>
<li><a href='#checkGrad'>
<p>Check the Gradient Provided in a <code>covMan</code> Object</p>
</p></a></li>
<li><a href='#checkPar'><p>Check Length and Names of a Vector of Values for Parameters or</p>
Bounds</a></li>
<li><a href='#checkX'>
<p>Generic function: Check the Compatibility of a Design Matrix with a</p>
Given Covariance Object
</p></a></li>
<li><a href='#checkX-methods'>
<p>Check the Compatibility of a Design with a Given</p>
Covariance Object
</p></a></li>
<li><a href='#coef-methods'>
<p>Extract Coefficients of a Covariance Kernel Object as Vector, List or</p>
Matrix
</p></a></li>
<li><a href='#coef&lt;-'>
<p>Generic Function: Replacement of Coefficient Values</p></a></li>
<li><a href='#coefLower'>
<p>Extract or Set Lower/Upper Bounds on Coefficients</p></a></li>
<li><a href='#contr.helmod'><p>Modified Helmert Contrast Matrix</p></a></li>
<li><a href='#corLevCompSymm'><p>Correlation Matrix for the Compound Symmetry Structure</p></a></li>
<li><a href='#corLevDiag'><p>Correlation or Covariance Matrix for a Diagonal Structure</p></a></li>
<li><a href='#corLevLowRank'>
<p>Correlation Matrix for a Low-Rank Structure</p>
</p></a></li>
<li><a href='#corLevSymm'>
<p>Correlation Matrix for a General Symmetric Correlation Structure</p>
</p></a></li>
<li><a href='#covAll-class'><p>Virtual Class <code>"covAll"</code></p></a></li>
<li><a href='#covANOVA'><p>Creator for the Class <code>"covANOVA"</code></p></a></li>
<li><a href='#covANOVA-class'><p>Class <code>"covANOVA"</code></p></a></li>
<li><a href='#covComp'><p>Creator for the Class <code>"covComp"</code> for Composite Covariance</p>
Kernels</a></li>
<li><a href='#covComp-class'>
<p>Class <code>"covComp"</code></p>
</p></a></li>
<li><a href='#covMan'><p> Creator Function for <code>covMan</code> Objects</p></a></li>
<li><a href='#covMan-class'><p>Class <code>"covMan"</code></p></a></li>
<li><a href='#covMat'>
<p>Generic Function: Covariance or Cross-Covariance</p>
Matrix Between two Sets of Locations
</p></a></li>
<li><a href='#covMat-methods'>
<p>Covariance Matrix for a Covariance Kernel Object</p></a></li>
<li><a href='#covOrd'><p>Warping-Based Covariance for an Ordinal Input</p></a></li>
<li><a href='#covOrd-class'>
<p>Class <code>"covOrd"</code></p></a></li>
<li><a href='#covQual-class'>
<p>Class <code>"covQual"</code></p></a></li>
<li><a href='#covQualNested'><p>Nested Qualitative Covariance</p></a></li>
<li><a href='#covQualNested-class'><p>Class <code>"covQualNested"</code></p></a></li>
<li><a href='#covRadial'><p>Creator for the Class <code>"covRadial"</code></p></a></li>
<li><a href='#covRadial-class'><p>Class <code>"covRadial"</code></p></a></li>
<li><a href='#covTP'><p>Creator for the Class <code>"covTP"</code></p></a></li>
<li><a href='#covTP-class'><p>Class <code>"covTP"</code></p></a></li>
<li><a href='#covTS'>
<p>Creator Function for <code>covTS</code> Objects</p></a></li>
<li><a href='#covTS-class'><p>Class <code>"covTS"</code></p></a></li>
<li><a href='#gls'>
<p>Generic Function: Generalized Least Squares Estimation</p>
with a Given Covariance Kernel
</p></a></li>
<li><a href='#gls-methods'>
<p>Generalized Least Squares Estimation with a Given Covariance Kernel</p></a></li>
<li><a href='#gp'>
<p>Gaussian Process Model</p></a></li>
<li><a href='#hasGrad'>
<p>Generic Function: Extract slot hasGrad of a Covariance Kernel</p>
</p></a></li>
<li><a href='#influence.gp'>
<p>Diagnostics for a Gaussian Process Model, Based on Leave-One-Out</p></a></li>
<li><a href='#inputNames'>
<p>Generic Function: Names of the Inputs of a Covariance Kernel</p>
</p></a></li>
<li><a href='#k1Exp'>
<p>Predefined covMan Objects for 1D Kernels</p>
</p></a></li>
<li><a href='#k1Matern3_2'>
<p>One-Dimensional Classical Covariance Kernel Functions</p>
</p></a></li>
<li><a href='#kernelName'>
<p>Name of the One-Dimensional Kernel in a Composite Kernel Object</p></a></li>
<li><a href='#kGauss'>
<p>Gauss (Squared-Exponential) Kernel</p>
</p></a></li>
<li><a href='#kMatern'>
<p>Matérn Kernels</p>
</p></a></li>
<li><a href='#mle'>
<p>Generic Function: Maximum Likelihood Estimation of a Gaussian Process</p>
Model</a></li>
<li><a href='#mle-methods'>
<p>Maximum Likelihood Estimation of Gaussian Process Model Parameters</p></a></li>
<li><a href='#npar'>
<p>Generic function: Number of Free Parameters in a Covariance Kernel</p></a></li>
<li><a href='#npar-methods'>
<p>Number of Parameters for a Covariance Kernel Object</p>
</p></a></li>
<li><a href='#optimMethods'><p>Optimization Methods (or Algorithms) for the <code>mle</code></p>
Method</a></li>
<li><a href='#parMap'>
<p>Generic Function: Map the Parameters of a Composite Covariance</p>
Kernel
</p></a></li>
<li><a href='#parMap-methods'>
<p>Map the Parameters of a Structure on the Inputs and Kernel Parameters</p></a></li>
<li><a href='#parNamesSymm'><p>Vector of Names for the General 'Symm' Parameterisation</p></a></li>
<li><a href='#parseCovFormula'><p>Parse a Formula or Expression Describing a Composite</p>
Covariance Kernel</a></li>
<li><a href='#plot'>
<p>Plot for a qualitative input</p></a></li>
<li><a href='#plot.gp'>
<p>Diagnostic Plot for the Validation of a <code>gp</code> Object</p>
</p></a></li>
<li><a href='#plot.simulate.gp'>
<p>Plot Simulations from a <code>gp</code> Object</p>
</p></a></li>
<li><a href='#predict.gp'>
<p>Prediction Method for the <code>"gp"</code> S3 Class</p></a></li>
<li><a href='#prinKrige'>
<p>Principal Kriging Functions</p>
</p></a></li>
<li><a href='#q1CompSymm'>
<p>Qualitative Correlation or Covariance Kernel with one Input and</p>
Compound Symmetric Correlation</a></li>
<li><a href='#q1Diag'>
<p>Qualitative Correlation or Covariance Kernel with one Input and</p>
Diagonal Structure</a></li>
<li><a href='#q1LowRank'>
<p>Qualitative Correlation or Covariance Kernel with one Input and</p>
Low-Rank Correlation
</p></a></li>
<li><a href='#q1Symm'>
<p>Qualitative Correlation or Covariance Kernel with one Input</p>
and General Symmetric Correlation</a></li>
<li><a href='#scores'>
<p>Generic Function: Scores for a Covariance Kernel Object</p></a></li>
<li><a href='#shapeSlot'>
<p>Extracts the Slots of a Structure</p></a></li>
<li><a href='#simulate, covAll-method'><p>Simulation of a <code>covAll</code> Object</p></a></li>
<li><a href='#simulate.gp'><p>Simulation of Paths from a <code>gp</code> Object</p></a></li>
<li><a href='#simulPar'>
<p>Generic function: Draw Random Values for the Parameters of a</p>
Covariance Kernel
</p></a></li>
<li><a href='#simulPar,covAll-method'>
<p>Draw Random Values for the Parameters of a Covariance Kernel</p>
</p></a></li>
<li><a href='#symIndices'>
<p>Vector of Indices Useful for Symmetric or Anti-Symmetric Matrices.</p>
</p></a></li>
<li><a href='#translude'><p>Make Translucent colors</p></a></li>
<li><a href='#varVec'>
<p>Generic Function: Variance of Gaussian Process at Specific Locations</p>
</p></a></li>
<li><a href='#varVec-methods'>
<p>Covariance Matrix for a Covariance Kernel Object</p></a></li>
<li><a href='#warpNorm'>
<p>Warpings for Ordinal Inputs</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Gaussian Process Laboratory</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.7</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-05</td>
</tr>
<tr>
<td>Author:</td>
<td>Yves Deville, David Ginsbourger, Olivier Roustant. Contributors: Nicolas Durrande.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Olivier Roustant &lt;roustant@insa-toulouse.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Gaussian process regression with an emphasis on kernels.
    Quantitative and qualitative inputs are accepted. Some pre-defined
    kernels are available, such as radial or tensor-sum for
    quantitative inputs, and compound symmetry, low rank, group kernel
    for qualitative inputs. The user can define new kernels and
    composite kernels through a formula mechanism. Useful methods
    include parameter estimation by maximum likelihood, simulation,
    prediction and leave-one-out validation.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>Rcpp (&ge; 0.10.5), methods, testthat, nloptr, lattice</td>
</tr>
<tr>
<td>Suggests:</td>
<td>DiceKriging, DiceDesign, inline, foreach, knitr, ggplot2,
reshape2, corrplot</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, numDeriv, stats4, doParallel, doFuture, utils</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>Collate:</td>
<td>'CovFormulas.R' 'allGenerics.R' 'checkGrad.R' 'covComp.R'
'covMan.R' 'covQual.R' 'q1CompSymm.R' 'q1Symm.R' 'q1LowRank.R'
'covQualNested.R' 'covQualOrd.R' 'covRadial.R' 'covTS.R'
'covTP.R' 'covANOVA.R' 'covZZAll.R' 'gp.R' 'kFuns.R'
'kernelNorm.R' 'kernels1d_Call.R' 'logLikFuns.R' 'methodGLS.R'
'methodMLE.R' 'miscUtils.R' 'prinKrige.R' 'q1Diag.R'
'simulate_gp.R' 'warpFuns.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-05 09:37:52 UTC; yves</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-05 12:30:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='kergp-package'>
Gaussian Process Laboratory 
</h2><span id='topic+kergp-package'></span><span id='topic+kergp'></span>

<h3>Description</h3>

<p>Laboratory Package for Gaussian Process interpolation, regression and
simulation, with an emphasis on user-defined covariance kernels.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> kergp</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Gaussian Process Laboratory</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.5.7</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-02-05</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Yves Deville, David Ginsbourger, Olivier Roustant. Contributors: Nicolas Durrande.</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Olivier Roustant &lt;roustant@insa-toulouse.fr&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Gaussian process regression with an emphasis on kernels.
    Quantitative and qualitative inputs are accepted. Some pre-defined
    kernels are available, such as radial or tensor-sum for
    quantitative inputs, and compound symmetry, low rank, group kernel
    for qualitative inputs. The user can define new kernels and
    composite kernels through a formula mechanism. Useful methods
    include parameter estimation by maximum likelihood, simulation,
    prediction and leave-one-out validation.</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> Rcpp (&gt;= 0.10.5), methods, testthat, nloptr, lattice</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> DiceKriging, DiceDesign, inline, foreach, knitr, ggplot2, reshape2, corrplot</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> MASS, numDeriv, stats4, doParallel, doFuture, utils</td>
</tr>
<tr>
 <td style="text-align: left;">
LinkingTo: </td><td style="text-align: left;"> Rcpp</td>
</tr>
<tr>
 <td style="text-align: left;">
RoxygenNote: </td><td style="text-align: left;"> 6.0.1</td>
</tr>
<tr>
 <td style="text-align: left;">
Collate: </td><td style="text-align: left;"> 'CovFormulas.R'
'allGenerics.R'
'checkGrad.R'
'covComp.R'
'covMan.R'
'covQual.R'
'q1CompSymm.R'
'q1Symm.R'
'q1LowRank.R'
'covQualNested.R'
'covQualOrd.R'
'covRadial.R'
'covTS.R'
'covTP.R'
'covANOVA.R'
'covZZAll.R'
'gp.R'
'kFuns.R'
'kernelNorm.R'
'kernels1d_Call.R'
'logLikFuns.R'
'methodGLS.R'
'methodMLE.R'
'miscUtils.R'
'prinKrige.R'
'q1Diag.R'
'simulate_gp.R'
'warpFuns.R'</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Warning</h3>

<p>As a lab, <span class="pkg">kergp</span> may strongly evolve in its future life. Users
interested in stable software for the Analysis of Computer Experiments
are encouraged to use other packages such as <span class="pkg">DiceKriging</span>
instead.
</p>


<h3>Note</h3>

<p>This package was developed within the frame of the ReDice Consortium,
gathering industrial partners (CEA, EDF, IFPEN, IRSN, Renault) and
academic partners (Mines Saint-Étienne, INRIA, and the University of
Bern) around advanced methods for Computer Experiments.
</p>


<h3>Author(s)</h3>

<p>Yves Deville (Alpestat), David Ginsbourger (University of Bern),
Olivier Roustant (INSA Toulouse), with contributions from
Nicolas Durrande (Mines Saint-Étienne).
</p>
<p>Maintainer: Olivier Roustant, &lt;roustant@insa-toulouse.fr&gt;
</p>


<h3>References</h3>

<p>Nicolas Durrande, David Ginsbourger, Olivier Roustant (2012).
&quot;Additive covariance kernels for high-dimensional gaussian process modeling&quot;.
<em>Annales de la Faculté des Sciences de Toulouse</em>, 21 (3):
481-499.
<a href="https://afst.centre-mersenne.org/item/AFST_2012_6_21_3_481_0">link</a>
</p>
<p>Nicolas Durrande, David Ginsbourger, Olivier Roustant, Laurent Carraro
(2013).
&quot;ANOVA kernels and RKHS of zero mean functions for model-based sensitivity analysis&quot;.
<em>Journal of Multivariate Analysis</em>, 115, 57-67.
<a href="https://www.sciencedirect.com/science/article/pii/S0047259X1200214X">link</a>
</p>
<p>David Ginsbourger, Xavier Bay, Olivier Roustant, Laurent Carraro
(2012).
&quot;Argumentwise invariant kernels for the approximation of invariant functions&quot;.
<em>Annales de la Faculté des Sciences de Toulouse</em>, 21 (3):
501-527.
<a href="https://afst.centre-mersenne.org/item/AFST_2012_6_21_3_501_0/">link</a>
</p>
<p>David Ginsbourger, Nicolas Durrande, Olivier Roustant (2013).
&quot;Kernels and designs for modelling invariant functions: From group invariance to additivity&quot;.
<em>mODa 10 - Advances in Model-Oriented Design and
Analysis. Contributions to Statistics</em>, 107-115.
<a href="https://link.springer.com/book/10.1007/978-3-319-00218-7">link</a>
</p>
<p>Olivier Roustant, David Ginsbourger, Yves Deville (2012).
&quot;DiceKriging, DiceOptim: Two R Packages for the Analysis of
Computer Experiments by Kriging-Based Metamodeling and Optimization&quot;.
<em>Journal of Statistical Software</em>, 51(1), 1-55.
<a href="https://doi.org/10.18637/jss.v051.i01">doi:10.18637/jss.v051.i01</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## ------------------------------------------------------------------
## Gaussian process modelling of function with invariance properties, 
## by using an argumentwise invariant kernel
## ------------------------------------------------------------------

## -- define manually an argumentwise invariant kernel --

kernFun &lt;- function(x1, x2, par) {
  h &lt;- (abs(x1) - abs(x2)) / par[1]
  S &lt;- sum(h^2)
  d2 &lt;- exp(-S)
  K &lt;- par[2] * d2
  d1 &lt;- 2 * K * S / par[1]   
  attr(K, "gradient") &lt;- c(theta = d1,  sigma2 = d2)
  return(K)
}

## ---------------------------------------------------------------
## quicker: with Rcpp; see also an example  with package inline
## in "gp" doc. file. Note that the Rcpp "sugar" fucntions are
## vectorized, so no for loops is required.
## ---------------------------------------------------------------

## Not run: 

    cppFunction('
        NumericVector cppKernFun(NumericVector x1, NumericVector x2, 
                                 NumericVector par){
        int n1 = x1.size();
        double S, d1, d2; 
        NumericVector K(1), h(n1);
        h = (abs(x1) - abs(x2)) / par[0];  // sugar function "abs"
        S = sum(h * h);                    // sugar "*" and "sum" 
        d2 = exp(-S);
        K[0] = par[1] * d2;
        d1 = 2 * K[0] * S / par[0];   
        K.attr("gradient") = NumericVector::create(Named("theta", d1),
                                                   Named("sigma2", d2));
        return K;
     }')


## End(Not run)

## ---------------------------------------------------------------
## Below: with the R-based code for the kernel namely 'kernFun'.
## You can also replace 'kernFun' by 'cppKernFun' for speed.
## ---------------------------------------------------------------

covSymGauss &lt;- covMan(kernel = kernFun,
                      hasGrad = TRUE,
                      label = "argumentwise invariant",
                      d = 2,
                      parLower = c(theta = 0.0, sigma2 = 0.0),
                      parUpper = c(theta = Inf, sigma2 = Inf),
                      parNames = c("theta", "sigma2"),
                      par = c(theta = 0.5, sigma2 = 2))

covSymGauss

## -- simulate a path from the corresponding GP --

nGrid &lt;- 24; n &lt;- nGrid^2; d &lt;- 2
xGrid &lt;- seq(from = -1, to = 1, length.out = nGrid)
Xgrid &lt;- expand.grid(x1 = xGrid, x2 = xGrid)

Kmat &lt;- covMat(object = covSymGauss, X = Xgrid,
               compGrad = FALSE, index = 1L)

library(MASS)
set.seed(1)
ygrid &lt;- mvrnorm(mu = rep(0, n), Sigma = Kmat)

## -- extract a design and the corr. response from the grid --

nDesign &lt;- 25
tab &lt;- subset(cbind(Xgrid, ygrid), x1 &gt; 0 &amp; x2 &gt; 0)
rowIndex &lt;- seq(1, nrow(tab), length = nDesign)
X &lt;- tab[rowIndex, 1:2]
y &lt;- tab[rowIndex, 3]

opar &lt;- par(mfrow = c(1, 3))
contour(x = xGrid, y = xGrid,
        z = matrix(ygrid, nrow = nGrid, ncol = nGrid), 
        nlevels = 15)
abline(h = 0, v = 0, col = "SpringGreen3")
points(x2 ~ x1, data = X, type = "p", pch = 21,
       col = "orangered", bg = "yellow", cex = 0.8)
title("GRF Simulation")


## -- Fit the Gaussian process model (trend + covariance parameters) -- 
covSymGauss
symgp &lt;- gp(formula = y ~ 1, data = data.frame(y, X),
            inputs = names(X),
            cov = covSymGauss,
            parCovIni = c(0.1, 2),
            varNoiseIni = 1.0e-8,
            varNoiseLower = 0.9e-8, varNoiseUpper = 1.1e-8)

# mind that the noise is not a symmetric kernel
# so varNoiseUpper should be chosen as small as possible.

summary(symgp)

## -- predict and compare --

predSymgp &lt;- predict(object = symgp, newdata = Xgrid, type = "UK")

contour(x = xGrid, y = xGrid,
        z = matrix(predSymgp$mean, nrow = nGrid, ncol = nGrid),
        nlevels = 15)
abline(h = 0, v = 0, col = "SpringGreen3")
points(x2 ~ x1, data = X, type = "p", pch = 21,
       col = "orangered", bg = "yellow", cex = 0.8)
title("Kriging mean")

contour(x = xGrid, y = xGrid,
        z = matrix(predSymgp$sd, nrow = nGrid, ncol = nGrid),
        nlevels = 15)
abline(h = 0, v = 0, col = "SpringGreen3")
points(x2 ~ x1, data = X, type = "p", pch = 21,
       col = "orangered", bg = "yellow", cex = 0.8)
title("Kriging s.d.")

par(opar)
</code></pre>

<hr>
<h2 id='as.list+2C+20covTP-method'>Coerce a <code>covTP</code> Object into a List</h2><span id='topic+as.list+2CcovTP-method'></span>

<h3>Description</h3>

<p>Coerce a <code>covTP</code> object representing a Tensor-Product
covariance kernel on the <code class="reqn">d</code>-dimensional Euclidean space
into a list containing <code class="reqn">d</code> one-dimensional kernels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'covTP'
as.list(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.list+2B2C+2B20covTP-method_+3A_x">x</code></td>
<td>

<p>A <code>covTP</code> object representing a Tensor-Product covariance
kernel.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with length <code>d</code> or <code>d + 1</code> where <code>d</code> is the
&quot;dimension&quot; slot <code>x@d</code> of the object <code>x</code>. The first <code>d</code>
elements of the list are one-dimensional <em>correlation</em> kernel
objects with class <code>"covTP"</code>. When <code>x</code> is a
<em>covariance</em> kernel (as opposed to a <em>correlation</em> kernel),
the list contains one more element which gives the variance.
</p>


<h3>Caution</h3>

<p>When <code>x</code> is not a correlation kernel the
<code>(d + 1)</code>-th element of the returned list may be different in
future versions: it may be a constant covariance kernel.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+covTP">covTP</a></code> and <code><a href="#topic+covTP-class">covTP-class</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
d &lt;- 6
myCov1 &lt;- covTP(d = d, cov = "corr")
coef(myCov1) &lt;- as.vector(simulPar(myCov1, nsim = 1))
as.list(myCov1)

## more examples and check the value of a 'covMat'
L &lt;- list()
myCov &lt;- list()

myCov[[1]] &lt;- covTP(d = d, cov = "corr")
coef(myCov[[1]]) &lt;- as.vector(simulPar(myCov[[1]], nsim = 1))
L[[1]] &lt;- as.list(myCov[[1]])

myCov[[2]] &lt;- covTP(k1Fun1 = k1Fun1PowExp, d = d, cov = "corr")
coef(myCov[[2]]) &lt;- as.vector(simulPar(myCov[[2]], nsim = 1))
L[[2]] &lt;- as.list(myCov[[2]])

myCov[[3]] &lt;- covTP(k1Fun1 = k1Fun1PowExp, d = d, iso1 = 0L, cov = "corr")
coef(myCov[[3]]) &lt;- as.vector(simulPar(myCov[[3]], nsim = 1))
L[[3]] &lt;- as.list(myCov[[3]])

n &lt;- 10
X &lt;- matrix(runif(n * d), nrow = n,
            dimnames = list(NULL, paste("x", 1:d, sep = "")))
for (iTest in 1:3) {
   C &lt;- covMat(L[[iTest]][[1]], X[ , 1, drop = FALSE])
   for (j in 2:d) {
      C &lt;- C * covMat(L[[iTest]][[j]], X[ , j, drop = FALSE])
   }
   CTest &lt;- covMat(myCov[[iTest]], X)
   print(max(abs(abs(C - CTest))))
}

</code></pre>

<hr>
<h2 id='checkGrad'>
Check the Gradient Provided in a <code>covMan</code> Object
</h2><span id='topic+checkGrad'></span>

<h3>Description</h3>

<p>Check the gradient provided in a <code>covMan</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkGrad(object, sym = TRUE,
          x1 = NULL, n1 = 10,
          x2 = NULL, n2 = NULL,
          XLower = NULL, XUpper = NULL,
          plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkGrad_+3A_object">object</code></td>
<td>

<p>A <code>covMan</code> object.
</p>
</td></tr>
<tr><td><code id="checkGrad_+3A_sym">sym</code></td>
<td>

<p>Logical. If <code>TRUE</code>, the check is done assuming that <code>x2</code>
is identical to <code>x1</code>, so the provided values for <code>x2</code> and
<code>n2</code> (if any) will be ignored.
</p>
</td></tr>
<tr><td><code id="checkGrad_+3A_x1">x1</code></td>
<td>

<p>Matrix to be used as the first argument of the kernel.
</p>
</td></tr>
<tr><td><code id="checkGrad_+3A_n1">n1</code></td>
<td>

<p>Number of rows for the matrix <code>x1</code>. Used only when <code>x1</code> is
not provided.
</p>
</td></tr>
<tr><td><code id="checkGrad_+3A_x2">x2</code></td>
<td>

<p>Matrix to be used as the second argument of the kernel.
</p>
</td></tr>
<tr><td><code id="checkGrad_+3A_n2">n2</code></td>
<td>

<p>Number of rows for the matrix <code>x2</code>. Used only when <code>x2</code> is
not provided.
</p>
</td></tr>
<tr><td><code id="checkGrad_+3A_xlower">XLower</code></td>
<td>

<p>Vector of lower bounds to draw <code>x1</code> and <code>x2</code> when needed.
</p>
</td></tr>
<tr><td><code id="checkGrad_+3A_xupper">XUpper</code></td>
<td>

<p>Vector of upper bounds to draw <code>x1</code> and <code>x2</code> when needed.
</p>
</td></tr>
<tr><td><code id="checkGrad_+3A_plot">plot</code></td>
<td>

<p><code>Logical</code>. If <code>TRUE</code>, a plot is shown comparing the two
arrays of gradients.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each of the two matrices <code>x1</code> and <code>x2</code> with <code>n1</code> and
<code>n2</code> rows can be given or instead be drawn at random. The matrix
of kernel values with dimension <code>c(n1, n2)</code> is computed, together
with its gradient with dimension <code>c(n1, n2, npar)</code> where
<code>npar</code> is the number of parameters of the kernel. A numerical
differentiation w.r.t. the kernel parameters is performed for the
kernel value at <code>x1</code> and <code>x2</code>, and the result is compared to
that provided by the kernel function (the function described in the
slot named <code>"kernel"</code> of <code>object</code>). Note that the value of
the parameter vector is the value provided by <code>coef(object)</code> and
it can be changed by using the replacement method <code>`coef&lt;-`</code> if
needed.
</p>


<h3>Value</h3>

<p>A list of results related to the Jacobians
</p>
<table>
<tr><td><code>test</code></td>
<td>
<p> Max of the absolute difference between
the gradient obtained by numeric differentiation and the
gradient provided by the kernel object. </p>
</td></tr>
<tr><td><code>Jnum</code>, <code>J</code></td>
<td>
<p> Jacobians (arrays) computed
with <code>numDeriv::jacobian</code> and provided by the kernel
object. </p>
</td></tr>
<tr><td><code>x1</code>, <code>x2</code>, <code>K</code></td>
<td>
<p> The matrices used
for the check, and the matrix of kernel values with
dimension <code>c(n1, n2)</code>. The element <code>x2</code> can be
<code>NULL</code> if the determination of the matrix <code>x2</code>
was not necessary. </p>
</td></tr>
</table>


<h3>Caution</h3>

<p>For now the function only works when <code>object</code> has class
<code>"covMan"</code>.
</p>


<h3>Note</h3>

<p>As a rule of thumb, a gradient coded without error gives a value of
<code>test</code> less than <code>1e-4</code>, and usually the value is much
smaller than that.
</p>


<h3>Author(s)</h3>

<p>Yves Deville
</p>

<hr>
<h2 id='checkPar'>Check Length and Names of a Vector of Values for Parameters or
Bounds</h2><span id='topic+checkPar'></span>

<h3>Description</h3>

<p>Check length/names for a vector of values for parameters or
bounds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkPar(value, parN, parNames, default)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkPar_+3A_value">value</code></td>
<td>
<p>Numeric vector of values.</p>
</td></tr>
<tr><td><code id="checkPar_+3A_parn">parN</code></td>
<td>
<p>Number of wanted values.</p>
</td></tr>
<tr><td><code id="checkPar_+3A_parnames">parNames</code></td>
<td>
<p>character. Names of the wanted values.</p>
</td></tr>
<tr><td><code id="checkPar_+3A_default">default</code></td>
<td>
<p>numeric. Default value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>checkPar(value = c(1, 2), parN = 2L, parNames = c("theta", "sigma2"),
         default = 1.0)
checkPar(value = NULL, parN = 2L, parNames = c("theta", "sigma2"),
         default = 1.0)
checkPar(value = c("sigma2" = 100, "theta" = 1),
         parN = 2L, parNames = c("theta", "sigma2"),
         default = 1.0)

</code></pre>

<hr>
<h2 id='checkX'>
Generic function: Check the Compatibility of a Design Matrix with a
Given Covariance Object
</h2><span id='topic+checkX'></span>

<h3>Description</h3>

<p>Generic function to check the compatibility of a design matrix with a
covariance object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
   checkX(object, X, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkX_+3A_object">object</code></td>
<td>

<p>A covariance kernel object.
</p>
</td></tr>
<tr><td><code id="checkX_+3A_x">X</code></td>
<td>

<p>A design matrix.
</p>
</td></tr>
<tr><td><code id="checkX_+3A_...">...</code></td>
<td>

<p>Other arguments for methods.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with columns taken from <code>X</code> and with column names
identical to <code>inputNames(object)</code>.
</p>


<h3>See Also</h3>

<p>The <code><a href="#topic+inputNames">inputNames</a></code> method.</p>

<hr>
<h2 id='checkX-methods'>
Check the Compatibility of a Design with a Given
Covariance Object
</h2><span id='topic+checkX+2CcovAll-method'></span>

<h3>Description</h3>

<p>Check the compatibility of a design matrix with a covariance object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
   ## S4 method for signature 'covAll'
checkX(object, X, strict = FALSE, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkX-methods_+3A_object">object</code></td>
<td>

<p>A covariance kernel object.
</p>
</td></tr>
<tr><td><code id="checkX-methods_+3A_x">X</code></td>
<td>

<p>A design matrix or data frame.
</p>
</td></tr>
<tr><td><code id="checkX-methods_+3A_strict">strict</code></td>
<td>

<p>Logical. If <code>TRUE</code>, the character vectors <code>colnames(X)</code>
and <code>inputNames(object)</code> must be the same sets, and hence have
the same length. If <code>FALSE</code> the vector
<code>inputNames(object)</code> must be a subset of <code>colnames(X)</code>
which then can have unused columns.
</p>
</td></tr>
<tr><td><code id="checkX-methods_+3A_...">...</code></td>
<td>

<p>Not used yet.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The matrix <code>X</code> must have the number of columns expected from the
covariance kernel object description, and it must have named columns
conforming to the kernel input names as returned by the
<code><a href="#topic+inputNames">inputNames</a></code> method. If the two sets of names are identical but
the names are in a different order, the columns are permuted in order
to be in the same order as the input names. If the names sets differ,
an error occurs.
</p>


<h3>Value</h3>

<p>A matrix with columns names identical to the input names attached with
the kernel object, i.e. <code>inputNames(object)</code>. The columns are
copies of those found under the same names in <code>X</code>, but are put in
the order of <code>inputNames(object)</code>.  When an input name does not
exist in <code>colnames(X)</code> an error occurs.
</p>


<h3>See Also</h3>

<p>The <code><a href="#topic+inputNames">inputNames</a></code> method.</p>

<hr>
<h2 id='coef-methods'>
Extract Coefficients of a Covariance Kernel Object as Vector, List or
Matrix
</h2><span id='topic+coef+2Cmethods'></span><span id='topic+coef+2CcovMan-method'></span><span id='topic+coef+2CcovTS-method'></span>

<h3>Description</h3>

<p>Extract some of or all the coefficients of a covariance kernel object as
vector, list or matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'covMan'
coef(object)

## S4 method for signature 'covTS'
coef(object, type = "all", as = "vector")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef-methods_+3A_object">object</code></td>
<td>

<p>An object representing a covariance kernel, the coefficient of which
will be extracted.
</p>
</td></tr>
<tr><td><code id="coef-methods_+3A_type">type</code></td>
<td>

<p>Character string or vector specifying which type(s) of coefficients in the
structure will be extracted. Can be <code>"all"</code> (all coefficients
are extracted) or any parameter name(s) of the corresponding kernel.
</p>
</td></tr>
<tr><td><code id="coef-methods_+3A_as">as</code></td>
<td>

<p>Character string specifying the output structure to be used.  The
default is <code>"vector"</code>, leading to a numeric vector. Using
<code>"list"</code> one gets a list of numeric vectors, one by kernel
parameter. Finally, using <code>"matrix"</code> one gets a matrix with one
row by input (or dimension) and one column by (selected) kernel
parameter.
</p>
</td></tr>

</table>


<h3>Value</h3>

<p>A numeric vector of coefficients or a structure as specified by
<code>as</code> containing the coefficients selected by <code>type</code>.
</p>


<h3>See Also</h3>

<p>The <code><a href="#topic+coef+3C-">coef&lt;-</a></code> replacement method which takes a vector of
replacement values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- 3
myCov1 &lt;- covTS(d = d, kernel = "k1Exp", dep = c(range = "input"),
                value = c(range = 1.1))
myCov1
## versatile 'coef' method
coef(myCov1)
coef(myCov1, as = "matrix")
coef(myCov1, as = "list")
coef(myCov1, as = "matrix", type = "range")
coef(myCov1) &lt;- c(0.2, 0.3, 0.4, 4, 16, 25)
coef(myCov1, as = "matrix")
</code></pre>

<hr>
<h2 id='coef+26lt+3B-'>
Generic Function: Replacement of Coefficient Values
</h2><span id='topic+coef+3C-'></span>

<h3>Description</h3>

<p>Generic function for the replacement of coefficient values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>`coef&lt;-`(object, ..., value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef+2B26lt+2B3B-_+3A_object">object</code></td>
<td>

<p>Object having a numeric vector of coefficients, typically a
covariance kernel object.
</p>
</td></tr>
<tr><td><code id="coef+2B26lt+2B3B-_+3A_...">...</code></td>
<td>

<p>Other arguments for methods.
</p>
</td></tr>
<tr><td><code id="coef+2B26lt+2B3B-_+3A_value">value</code></td>
<td>

<p>The value of the coefficients to be set.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified object.
</p>

<hr>
<h2 id='coefLower'>
Extract or Set Lower/Upper Bounds on Coefficients
</h2><span id='topic+coefLower'></span><span id='topic+coefLower+3C-'></span><span id='topic+coefUpper'></span><span id='topic+coefUpper+3C-'></span>

<h3>Description</h3>

<p>Extract or set lower/upper bounds on coefficients for covariance
kernel objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coefLower(object, ...)
coefUpper(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coefLower_+3A_object">object</code></td>
<td>

<p>A covariance kernel object.
</p>
</td></tr>
<tr><td><code id="coefLower_+3A_...">...</code></td>
<td>

<p>Other arguments for methods.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The lower or upper bounds on the covariance kernel parameters.
</p>

<hr>
<h2 id='contr.helmod'>Modified Helmert Contrast Matrix</h2><span id='topic+contr.helmod'></span>

<h3>Description</h3>

<p>Modified Helmert contrast (or coding) matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contr.helmod(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contr.helmod_+3A_n">n</code></td>
<td>
<p>Integer.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The returned matrix is a scaled version of <code>contr.helmert(A)</code>.
</p>


<h3>Value</h3>

<p>An orthogonal matrix with <code>n</code> rows and <code>n - 1</code> columns. The
columns form a basis of the subspace orthogonal to a vector of
<code>n</code> ones.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- contr.helmod(6)
crossprod(A)

</code></pre>

<hr>
<h2 id='corLevCompSymm'>Correlation Matrix for the Compound Symmetry Structure</h2><span id='topic+corLevCompSymm'></span>

<h3>Description</h3>

<p>Compute the correlation matrix for a the compound symmetry structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corLevCompSymm(par, nlevels, levels, lowerSQRT = FALSE, compGrad = TRUE,
  cov = FALSE, impl = c("C", "R"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corLevCompSymm_+3A_par">par</code></td>
<td>

<p>Numeric vector of length <code>1</code> if <code>cov</code> is
<code>TRUE</code> or with length <code>2</code> else. The first element is the
correlation coefficient and the second one (when it exists) is the
variance.
</p>
</td></tr>
<tr><td><code id="corLevCompSymm_+3A_nlevels">nlevels</code></td>
<td>

<p>Number of levels.
</p>
</td></tr>
<tr><td><code id="corLevCompSymm_+3A_levels">levels</code></td>
<td>

<p>Character representing the levels.
</p>
</td></tr>
<tr><td><code id="corLevCompSymm_+3A_lowersqrt">lowerSQRT</code></td>
<td>

<p>Logical. When <code>TRUE</code> the (lower) Cholesky
root <code class="reqn">\mathbf{L}</code> of the correlation matrix
<code class="reqn">\mathbf{C}</code> is returned instead of the correlation matrix.
</p>
</td></tr>
<tr><td><code id="corLevCompSymm_+3A_compgrad">compGrad</code></td>
<td>

<p>Logical. Should the gradient be computed?
</p>
</td></tr>
<tr><td><code id="corLevCompSymm_+3A_cov">cov</code></td>
<td>
<p>Logical.
</p>
<p>If <code>TRUE</code> the matrix is a covariance
matrix (or its Cholesky root) rather than a correlation matrix and
the last element in <code>par</code> is the variance.
</p>
</td></tr>
<tr><td><code id="corLevCompSymm_+3A_impl">impl</code></td>
<td>

<p>A character telling which of the C and R implementations
should be chosen.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A correlation matrix (or its Cholesky root) with the
optional <code>gradient</code> attribute.
</p>


<h3>Note</h3>

<p>When <code>lowerSQRT</code> is <code>FALSE</code>, the implementation
used is always in R because no gain would then result from an
implementation in C.
</p>


<h3>Author(s)</h3>

<p>Yves Deville
</p>


<h3>Examples</h3>

<pre><code class='language-R'>checkGrad &lt;- TRUE
lowerSQRT &lt;- FALSE
nlevels &lt;- 12
set.seed(1234)
par &lt;- runif(1L, min = 0, max = pi)

##============================================================================
## Compare R and C implementations for 'lowerSQRT = TRUE'
##============================================================================
tR &lt;- system.time(TR &lt;- corLevCompSymm(nlevels = nlevels, par = par,
                                       lowerSQRT = lowerSQRT, impl = "R"))
tC &lt;- system.time(T &lt;- corLevCompSymm(nlevels = nlevels, par = par,
                                      lowerSQRT = lowerSQRT))
tC2 &lt;- system.time(T2 &lt;- corLevCompSymm(nlevels = nlevels, par = par,
                                        lowerSQRT = lowerSQRT, compGrad = FALSE))
## time
rbind(R = tR, C = tC, C2 = tC2)

## results
max(abs(T - TR))
max(abs(T2 - TR))

##===========================================================================
## Compare the gradients
##===========================================================================

if (checkGrad) {

    library(numDeriv)

    ##=======================
    ## lower SQRT case only
    ##========================
    JR &lt;- jacobian(fun = corLevCompSymm, x = par, nlevels = nlevels,
                   lowerSQRT = lowerSQRT, impl = "R", method = "complex")
    J &lt;- attr(T, "gradient")

    ## redim and compare.
    dim(JR) &lt;- dim(J)
    max(abs(J - JR))
    nG &lt;- length(JR)
    plot(1:nG, as.vector(JR), type = "p", pch = 21, col = "SpringGreen3",
         cex = 0.8, ylim = range(J, JR),
         main = paste("gradient check, lowerSQRT =", lowerSQRT))
    points(x = 1:nG, y = as.vector(J), pch = 16, cex = 0.6, col = "orangered")
}

</code></pre>

<hr>
<h2 id='corLevDiag'>Correlation or Covariance Matrix for a Diagonal Structure</h2><span id='topic+corLevDiag'></span>

<h3>Description</h3>

<p>Compute the correlation or covariance matrix for a diagonal
structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corLevDiag(par, nlevels, levels, lowerSQRT = FALSE, compGrad = TRUE,
  cov = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corLevDiag_+3A_par">par</code></td>
<td>

<p>A numeric vector with length <code>npVar</code> where
<code>npVar</code> is the number of variance parameters, namely
<code>0</code>, <code>1</code> or <code>nlevels</code> corresponding to the values
of <code>cov</code>: <code>0</code>, <code>1</code> and <code>2</code>.
</p>
</td></tr>
<tr><td><code id="corLevDiag_+3A_nlevels">nlevels</code></td>
<td>

<p>Number of levels.
</p>
</td></tr>
<tr><td><code id="corLevDiag_+3A_levels">levels</code></td>
<td>

<p>Character representing the levels.
</p>
</td></tr>
<tr><td><code id="corLevDiag_+3A_lowersqrt">lowerSQRT</code></td>
<td>

<p>Logical. When <code>TRUE</code> the (lower) Cholesky
root <code class="reqn">\mathbf{L}</code> of the correlation or covariance matrix
<code class="reqn">\mathbf{C}</code> is returned instead of the correlation matrix.
</p>
</td></tr>
<tr><td><code id="corLevDiag_+3A_compgrad">compGrad</code></td>
<td>

<p>Logical. Should the gradient be computed?
</p>
</td></tr>
<tr><td><code id="corLevDiag_+3A_cov">cov</code></td>
<td>

<p>Integer <code>0</code>, <code>1</code> or <code>2</code>. If <code>cov</code>
is <code>0</code>, the matrix is a <em>correlation</em> matrix (or its
Cholesky root) i.e. an identity matrix. If <code>cov</code> is <code>1</code>
or <code>2</code>, the matrix is a <em>covariance</em> (or its square
root) with constant variance vector for <code>code = 1</code> and with
arbitrary variance vector for <code>code = 2</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A correlation matrix (or its Cholesky root) with the
optional <code>gradient</code> attribute.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
checkGrad &lt;- TRUE
nlevels &lt;- 12
sigma2 &lt;- rexp(n = nlevels)
T0 &lt;- corLevDiag(nlevels = nlevels, par = sigma2, cov = 2)
L0 &lt;- corLevDiag(nlevels = nlevels, par = sigma2, cov = 2,
                 lowerSQRT = TRUE)

</code></pre>

<hr>
<h2 id='corLevLowRank'>
Correlation Matrix for a Low-Rank Structure
</h2><span id='topic+corLevLowRank'></span>

<h3>Description</h3>

<p>Compute the correlation matrix for a low-rank structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
corLevLowRank(par, nlevels, rank, levels,
              lowerSQRT = FALSE, compGrad = TRUE,
              cov = 0, impl = c("C", "R"))

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corLevLowRank_+3A_par">par</code></td>
<td>

<p>A numeric vector with length <code>npCor + npVar</code> where
<code>npCor = (rank - 1) *</code> <code>(nlevels - rank / 2)</code> is the number of
correlation parameters, and <code>npVar</code> is the number of variance
parameters, which depends on the value of <code>cov</code>. The value of
<code>npVar</code> is <code>0</code>, <code>1</code> or <code>nlevels</code> corresponding
to the values of <code>cov</code>: <code>0</code>, <code>1</code> and <code>2</code>.  The
correlation parameters are assumed to be located at the head of
<code>par</code> i.e. at indices <code>1</code> to <code>npCor</code>. The variance
parameter(s) are assumed to be at the tail, i.e. at indices
<code>npCor +1 </code> to <code>npCor + npVar</code>.
</p>
</td></tr>
<tr><td><code id="corLevLowRank_+3A_nlevels">nlevels</code></td>
<td>

<p>Number of levels <code class="reqn">m</code>.
</p>
</td></tr>
<tr><td><code id="corLevLowRank_+3A_rank">rank</code></td>
<td>

<p>The rank, which must be <code>&gt;1</code> and <code>&lt; nlevels</code>.
</p>
</td></tr>
<tr><td><code id="corLevLowRank_+3A_levels">levels</code></td>
<td>

<p>Character representing the levels.
</p>
</td></tr>
<tr><td><code id="corLevLowRank_+3A_lowersqrt">lowerSQRT</code></td>
<td>

<p>Logical. When <code>TRUE</code> a lower-triangular root
<code class="reqn">\mathbf{L}</code> of the correlation or covariance matrix
<code class="reqn">\mathbf{C}</code> is returned instead of the correlation
matrix. Note that this matrix can have negative diagonal elements
hence is not a (pivoted) Cholesky root.
</p>
</td></tr>
<tr><td><code id="corLevLowRank_+3A_compgrad">compGrad</code></td>
<td>

<p>Logical. Should the gradient be computed? This is only possible for
the C implementation.
</p>
</td></tr>
<tr><td><code id="corLevLowRank_+3A_cov">cov</code></td>
<td>

<p>Integer <code>0</code>, <code>1</code> or <code>2</code>. If <code>cov</code> is <code>0</code>,
the matrix is a <em>correlation</em> matrix (or its root). If
<code>cov</code> is <code>1</code> or <code>2</code>, the matrix is a
<em>covariance</em> (or its root) with constant variance vector for
<code>code = 1</code> and with arbitrary variance for <code>code = 2</code>. The
variance parameters <code>par</code> are located at the tail of the
<code>par</code> vector, so at locations <code>npCor + 1</code> to <code>npCor +
    nlevels</code> when <code>code = 2</code> where <code>npCor</code> is the number of
correlation parameters.
</p>
</td></tr>
<tr><td><code id="corLevLowRank_+3A_impl">impl</code></td>
<td>

<p>A character telling which of the C and R implementations should be
chosen. The R implementation is only for checks and should not be
used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The correlation matrix with size <code class="reqn">m</code> is the general symmetric
correlation matrix with rank <code class="reqn">\leq r</code> where <code class="reqn">r</code> is
given, as described by Rapisarda et al.  It depends on <code class="reqn">(r - 1)
  \times (m - r / 2) / 2</code> parameters
<code class="reqn">\theta_{ij}</code> where the indices <code class="reqn">i</code> and <code class="reqn">j</code>
are such that <code class="reqn">1 \leq j &lt; i</code> for <code class="reqn">i \leq r</code> or such that <code class="reqn">1 \leq j &lt; r</code> for
<code class="reqn">r &lt; i \leq n</code>. The parameters <code class="reqn">\theta_{ij}</code> are angles
and are to be taken to be in <code class="reqn">[0, 2\pi)</code> if <code class="reqn">j =
    1</code> and in <code class="reqn">[0, \pi)</code> otherwise.
</p>


<h3>Value</h3>

<p>A correlation matrix (or its root) with the optional <code>gradient</code>
attribute.
</p>


<h3>Note</h3>

<p>This function is essentially for internal use and the corresponding
correlation or covariance kernels are created as <code>covQual</code>
objects by using the <code><a href="#topic+q1LowRank">q1LowRank</a></code> creator. 
</p>
<p>Here the parameters <code class="reqn">\theta_{ij}</code> are used <em>in
row order</em> rather than in the column order. This order simplifies the
computation of the gradient.
</p>


<h3>References</h3>

<p>Francesco Rapisarda, Damanio Brigo, Fabio Mercurio (2007).
&quot;Parameterizing Correlations a Geometric Interpretation&quot;.
<em>IMA Journal of Management Mathematics</em>, <b>18</b>(1):
55-73.
</p>
<p>Igor Grubišić, Raoul Pietersz
(2007). &quot;Efficient Rank Reduction of Correlation Matrices&quot;. <em>Linear
Algebra and its Applications</em>, <b>422</b>: 629-653.
</p>


<h3>See Also</h3>

<p>The <code><a href="#topic+q1LowRank">q1LowRank</a></code> creator of a corresponding kernel object
with class <code>"covQual"</code>, and the similar <code><a href="#topic+corLevSymm">corLevSymm</a></code>
function for the full-rank case.
</p>

<hr>
<h2 id='corLevSymm'>
Correlation Matrix for a General Symmetric Correlation Structure
</h2><span id='topic+corLevSymm'></span>

<h3>Description</h3>

<p>Compute the correlation matrix for a general symmetric correlation
structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
corLevSymm(par, nlevels, levels, lowerSQRT = FALSE, compGrad = TRUE,
           cov = 0, impl = c("C", "R"))

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corLevSymm_+3A_par">par</code></td>
<td>

<p>A numeric vector with length <code>npCor + npVar</code> where
<code>npCor = nlevels *</code> <code>(nlevels - 1) / 2</code> is the number of
correlation parameters, and <code>npVar</code> is the number of variance
parameters, which depends on the value of <code>cov</code>. The value of <code>npVar</code>
is <code>0</code>, <code>1</code> or <code>nlevels</code> corresponding to the values
of <code>cov</code>: <code>0</code>, <code>1</code> and <code>2</code>. The correlation
parameters are assumed to be located at the head of <code>par</code>
i.e. at indices <code>1</code> to <code>npCor</code>. The variance parameter(s)
are assumed to be at the tail, i.e. at indices <code>npCor + 1 </code> to
<code>npCor + npVar</code>.
</p>
</td></tr>
<tr><td><code id="corLevSymm_+3A_nlevels">nlevels</code></td>
<td>

<p>Number of levels.
</p>
</td></tr>
<tr><td><code id="corLevSymm_+3A_levels">levels</code></td>
<td>

<p>Character representing the levels.
</p>
</td></tr>
<tr><td><code id="corLevSymm_+3A_lowersqrt">lowerSQRT</code></td>
<td>

<p>Logical. When <code>TRUE</code> the (lower) Cholesky root
<code class="reqn">\mathbf{L}</code> of the correlation or covariance matrix
<code class="reqn">\mathbf{C}</code> is returned instead of the correlation matrix.
</p>
</td></tr>
<tr><td><code id="corLevSymm_+3A_compgrad">compGrad</code></td>
<td>

<p>Logical. Should the gradient be computed? This is only possible for
the C implementation.
</p>
</td></tr>
<tr><td><code id="corLevSymm_+3A_cov">cov</code></td>
<td>

<p>Integer <code>0</code>, <code>1</code> or <code>2</code>. If <code>cov</code> is <code>0</code>, the
matrix is a <em>correlation</em> matrix (or its Cholesky root). If
<code>cov</code> is <code>1</code> or <code>2</code>, the matrix is a <em>covariance</em>
(or its Cholesky root) with constant variance vector for
<code>code = 1</code> and with arbitrary variance for <code>code = 2</code>. The variance
parameters <code>par</code> are located at the tail of the <code>par</code>
vector, so at locations <code>npCor + 1</code> to <code>npCor + nlevels</code>
when <code>code = 2</code> where <code>npCor</code> is the number of correlation
parameters, i.e. <code>nlevels * (nlevels - 1) / 2</code>.
</p>
</td></tr>
<tr><td><code id="corLevSymm_+3A_impl">impl</code></td>
<td>

<p>A character telling which of the C and R implementations should be
chosen.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The correlation matrix with dimension <code class="reqn">n</code> is the <em>general
symmetric correlation matrix</em> as described by Pinheiro and Bates and
implemented in the <span class="pkg">nlme</span> package. It depends on <code class="reqn">n \times (n -
    1) / 2</code> parameters <code class="reqn">\theta_{ij}</code> where
the indices <code class="reqn">i</code> and <code class="reqn">j</code> are such that <code class="reqn">1 \leq j &lt; i \leq
    n</code>.  The parameters <code class="reqn">\theta_{ij}</code> are
angles and are to be taken to be in <code class="reqn">[0, \pi)</code> for a
one-to-one parameterisation.
</p>


<h3>Value</h3>

<p>A correlation matrix (or its Cholesky root) with the optional
<code>gradient</code> attribute.
</p>


<h3>Note</h3>

<p>This function is essentially for internal use and the corresponding
correlation or covariance kernels are created as <code>covQual</code>
objects by using the <code><a href="#topic+q1Symm">q1Symm</a></code> creator. 
</p>
<p>The parameters <code class="reqn">\theta_{ij}</code> are used <em>in
row order</em> rather than in the column order as in the reference or in the
<span class="pkg">nlme</span> package. This order simplifies the computation of the
gradients.
</p>


<h3>References</h3>

<p>Jose C. Pinheiro and Douglas M. Bates
(1996). &quot;Unconstrained Parameterizations for Variance-Covariance matrices&quot;.
<em>Statistics and Computing</em>, 6(3) pp. 289-296.
</p>
<p>Jose C. Pinheiro and Douglas M. Bates (2000) <em>Mixed-Effects
Models in S and S-PLUS</em>, Springer.
</p>


<h3>See Also</h3>

<p>The <code>corSymm</code> correlation structure in the <span class="pkg">nlme</span>
package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>checkGrad &lt;- TRUE
nlevels &lt;- 12
npar &lt;- nlevels * (nlevels - 1) / 2
par &lt;- runif(npar, min = 0, max = pi)
##============================================================================
## Compare R and C implementations for 'lowerSQRT = TRUE'
##============================================================================
tR &lt;- system.time(TR &lt;- corLevSymm(nlevels = nlevels,
                                   par = par, lowerSQRT = TRUE, impl = "R"))
tC &lt;- system.time(T &lt;- corLevSymm(nlevels = nlevels, par = par,
                                  lowerSQRT = TRUE))
tC2 &lt;- system.time(T2 &lt;- corLevSymm(nlevels = nlevels, par = par,
                                    lowerSQRT = TRUE, compGrad = FALSE))
## time
rbind(R = tR, C = tC, C2 = tC2)

## results
max(abs(T - TR))
max(abs(T2 - TR))

##============================================================================
## Compare R and C implementations for 'lowerSQRT = FALSE'
##============================================================================
tR &lt;- system.time(TRF &lt;- corLevSymm(nlevels = nlevels, par = par,
                                    lowerSQRT = FALSE, impl = "R"))
tC &lt;- system.time(TCF &lt;- corLevSymm(nlevels = nlevels, par = par,
                                    compGrad = FALSE, lowerSQRT = FALSE))
tC2 &lt;- system.time(TCF2 &lt;- corLevSymm(nlevels = nlevels, par = par,
                                      compGrad = TRUE, lowerSQRT = FALSE))
rbind(R = tR, C = tC, C2 = tC2)
max(abs(TCF - TRF))
max(abs(TCF2 - TRF))

##===========================================================================
## Compare the gradients
##===========================================================================

if (checkGrad) {

    library(numDeriv)

    ##==================
    ## lower SQRT case
    ##==================
    JR &lt;- jacobian(fun = corLevSymm, x = par, nlevels = nlevels,
                   lowerSQRT = TRUE, method = "complex", impl = "R")
    J &lt;- attr(T, "gradient")

    ## redim and compare.
    dim(JR) &lt;- dim(J)
    max(abs(J - JR))
    nG &lt;- length(JR)
    plot(1:nG, as.vector(JR), type = "p", pch = 21, col = "SpringGreen3",
         cex = 0.8, ylim = range(J, JR),
         main = "gradient check, lowerSQRT = TRUE")
    points(x = 1:nG, y = as.vector(J), pch = 16, cex = 0.6, col = "orangered")

    ##==================
    ## Symmetric case
    ##==================
    JR &lt;- jacobian(fun = corLevSymm, x = par, nlevels = nlevels,
                   lowerSQRT = FALSE, impl = "R", method = "complex")
    J &lt;- attr(TCF2, "gradient")

    ## redim and compare.
    dim(JR) &lt;- dim(J)
    max(abs(J - JR))
    nG &lt;- length(JR)
    plot(1:nG, as.vector(JR), type = "p", pch = 21, col = "SpringGreen3",
         cex = 0.8,
         ylim = range(J, JR),
         main = "gradient check, lowerSQRT = FALSE")
    points(x = 1:nG, y = as.vector(J), pch = 16, cex = 0.6, col = "orangered")
}
</code></pre>

<hr>
<h2 id='covAll-class'>Virtual Class <code>"covAll"</code></h2><span id='topic+covAll-class'></span><span id='topic+checkX+2CcovAll+2Cmatrix-method'></span><span id='topic+checkX+2CcovAll+2Cdata.frame-method'></span>

<h3>Description</h3>

<p>Virtual class <code>"covAll"</code>, union of classes including
<code>"covTS"</code>, <code>"covMan"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>checkX</dt><dd>
<p><code>signature(object = "covAll", X = "matrix")</code>: checks the
compatibility of a design with a given covariance object.
</p>
</dd>
<dt>checkX</dt><dd>
<p><code>signature(object = "covAll", X = "data.frame")</code>: checks the
compatibility of a design with a given covariance object.
</p>
</dd>
<dt>inputNames</dt><dd>
<p><code>signature(object = "covAll")</code>: returns the character
vector of input names.
</p>
</dd>
<dt>hasGrad</dt><dd>
<p><code>signature(object = "covAll")</code>: returns the logical slot hasGrad.
</p>
</dd>
<dt>simulPar</dt><dd>
<p><code>signature(object = "covTS")</code>: simulates random values for the parameters.
</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>showClass("covAll")
</code></pre>

<hr>
<h2 id='covANOVA'>Creator for the Class <code>"covANOVA"</code></h2><span id='topic+covANOVA'></span>

<h3>Description</h3>

<p>Creator for the class <code>"covANOVA"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covANOVA(k1Fun1 = k1Fun1Gauss,
      cov = c("corr", "homo"),
      iso = 0, iso1 = 1L,
      hasGrad = TRUE,
      inputs = NULL,
      d = NULL,
      parNames,
      par = NULL, parLower = NULL, parUpper = NULL,
      label = "ANOVA kernel",
      ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covANOVA_+3A_k1fun1">k1Fun1</code></td>
<td>

<p>A kernel function of a <em>scalar</em> numeric variable, and possibly
of an extra &quot;shape&quot; parameter. This function can also return the
first-order derivative or the two-first order derivatives as an
attribute with name <code>"der"</code> and with a matrix content. When an
extra shape parameter exists, the gradient can also be returned
as an attribute with name <code>"gradient"</code>, see <b>Examples</b>
later. The name of the function can be given as a character string.
</p>
</td></tr>
<tr><td><code id="covANOVA_+3A_cov">cov</code></td>
<td>

<p>A character string specifying the value of the variance parameter <code class="reqn">\delta</code> for the covariance kernel. Contrarily to other kernel classes, that parameter is not equal to the variance. Thus, mind that choosing (<code>"corr"</code>) corresponds to <code class="reqn">\delta=1</code> but <em>does not</em> correspond to a correlation kernel, see details below. Partial matching is allowed.
</p>
</td></tr>
<tr><td><code id="covANOVA_+3A_iso">iso</code></td>
<td>

<p>Integer. The value <code>1L</code> corresponds to an isotropic covariance,
with all the inputs sharing the same range value.
</p>
</td></tr>
<tr><td><code id="covANOVA_+3A_iso1">iso1</code></td>
<td>

<p>Integer. This applies only when <code>k1Fun1</code> contains one or more
parameters that can be called 'shape' parameters. At now, only one
such parameter can be found in <code>k1Fun1</code> and consequently
<code>iso1</code> must be of length one. With <code>iso1 = 0</code> the shape
parameter in <code>k1Fun1</code> will generate <code>d</code> parameters in the
<code>covANOVA</code> object with their name suffixed by the dimension. When
<code>iso1</code> is <code>1</code> only one shape parameter will be created in
the <code>covANOVA</code> object.
</p>
</td></tr>
<tr><td><code id="covANOVA_+3A_hasgrad">hasGrad</code></td>
<td>

<p>Integer or logical. Tells if the value returned by the function
<code>k1Fun1</code> has an attribute named <code>"der"</code> giving the
derivative(s).
</p>
</td></tr>
<tr><td><code id="covANOVA_+3A_inputs">inputs</code></td>
<td>

<p>Character. Names of the inputs.
</p>
</td></tr>
<tr><td><code id="covANOVA_+3A_d">d</code></td>
<td>

<p>Integer. Number of inputs.
</p>
</td></tr>
<tr><td><code id="covANOVA_+3A_parnames">parNames</code></td>
<td>

<p>Names of the parameters. By default, ranges are prefixed
<code>"theta_"</code> in the non-iso case and the range is named
<code>"theta"</code> in the iso case.
</p>
</td></tr>
<tr><td><code id="covANOVA_+3A_par">par</code></td>
<td>

<p>Numeric values for the parameters. Can be <code>NA</code>.
</p>
</td></tr>
<tr><td><code id="covANOVA_+3A_parlower">parLower</code></td>
<td>

<p>Numeric values for the lower bounds on the parameters. Can be
<code>-Inf</code>.
</p>
</td></tr>
<tr><td><code id="covANOVA_+3A_parupper">parUpper</code></td>
<td>

<p>Numeric values for the upper bounds on the parameters. Can be
<code>Inf</code>.
</p>
</td></tr>
<tr><td><code id="covANOVA_+3A_label">label</code></td>
<td>

<p>A short description of the kernel object.
</p>
</td></tr>
<tr><td><code id="covANOVA_+3A_...">...</code></td>
<td>

<p>Other arguments passed to the method <code>new</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A ANOVA kernel on the <code class="reqn">d</code>-dimensional Euclidean space
takes the form </p>
<p style="text-align: center;"><code class="reqn">K(\mathbf{x},\,\mathbf{x}') = \delta^2
    \prod_{\ell = 1}^d (1 + \tau_\ell^2 \kappa(r_\ell))</code>
</p>
<p> where <code class="reqn">\kappa(r)</code> is a suitable correlation kernel for a one-dimensional input, and <code class="reqn">r_\ell</code> is given by  <code class="reqn">r_\ell := [x_\ell - x'_\ell] / \theta_\ell</code> for <code class="reqn">\ell = 1</code> to <code class="reqn">d</code>.
</p>
<p>In this default form, the ANOVA kernel depends on <code class="reqn">2d + 1</code>
parameters: the <em>ranges</em> <code class="reqn">\theta_\ell &gt;0</code>, the
<em>variance ratios</em> <code class="reqn">\tau_\ell^2</code>, and the variance parameter <code class="reqn">\delta^2</code>.
</p>
<p>An <em>isotropic</em> form uses the same range <code class="reqn">\theta</code>
for all inputs, i.e. sets <code class="reqn">\theta_\ell =
    \theta</code> for all <code class="reqn">\ell</code>. This is obtained by
using <code>iso = TRUE</code>.
</p>
<p>A <em>correlation</em> version uses <code class="reqn">\delta^2 = 1</code>. This is obtained by using <code>cov = "corr"</code>. Mind that it does not correspond to a correlation kernel. Indeed, in general, the variance is equal to </p>
<p style="text-align: center;"><code class="reqn">K(\mathbf{x},\,\mathbf{x}) = \delta^2
    \prod_{\ell = 1}^d (1 + \tau_\ell^2).</code>
</p>

<p>Finally, the correlation kernel <code class="reqn">\kappa(r)</code> can depend on
a &quot;shape&quot; parameter, e.g. have the form
<code class="reqn">\kappa(r;\,\alpha)</code>. The extra shape parameter
<code class="reqn">\alpha</code> will be considered then as a parameter of the
resulting ANOVA kernel, making it possible to estimate it
by ML along with the range(s) and the variance.
</p>


<h3>Value</h3>

<p>An object with class <code>"covANOVA"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (require(DiceKriging)) {
    ## a 16-points factorial design and the corresponding response
    d &lt;- 2; n &lt;- 16; x &lt;- seq(from = 0.0, to = 1.0, length.out = 4)
    X &lt;- expand.grid(x1 = x, x2 = x)
    y &lt;- apply(X, 1, DiceKriging::branin)

    ## kriging model with matern5_2 covariance structure, constant
    ## trend. A crucial point is to set the upper bounds!
    mycov &lt;- covANOVA(k1Fun1 = k1Fun1Matern5_2, d = 2, cov = "homo")
    coefUpper(mycov) &lt;- c(2.0, 2.0, 5.0, 5.0, 1e10)
    mygp &lt;- gp(y ~ 1, data = data.frame(X, y),
               cov = mycov, multistart = 100, noise = TRUE)

    nGrid &lt;- 50; xGrid &lt;- seq(from = 0, to = 1, length.out = nGrid)
    XGrid &lt;- expand.grid(x1 = xGrid, x2 = xGrid)
    yGrid &lt;- apply(XGrid, 1, DiceKriging::branin)
    pgp &lt;- predict(mygp, XGrid)$mean

    mykm &lt;- km(design = X, response = y)
    pkm &lt;- predict(mykm, XGrid, "UK")$mean
    c("km" = sqrt(mean((yGrid - pkm)^2)),
      "gp" = sqrt(mean((yGrid - pgp)^2)))
    
}

## End(Not run)
</code></pre>

<hr>
<h2 id='covANOVA-class'>Class <code>"covANOVA"</code></h2><span id='topic+covANOVA-class'></span><span id='topic+coef+2CcovANOVA-method'></span><span id='topic+coef+3C-+2CcovANOVA+2Cnumeric-method'></span><span id='topic+coefLower+2CcovANOVA-method'></span><span id='topic+coefLower+3C-+2CcovANOVA-method'></span><span id='topic+coefUpper+2CcovANOVA-method'></span><span id='topic+coefUpper+3C-+2CcovANOVA-method'></span><span id='topic+covMat+2CcovANOVA-method'></span><span id='topic+npar+2CcovANOVA-method'></span><span id='topic+scores+2CcovANOVA-method'></span><span id='topic+show+2CcovANOVA-method'></span><span id='topic+varVec+2CcovANOVA-method'></span>

<h3>Description</h3>

<p>S4 class representing a Tensor Product (ANOVA) covariance kernel.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("covANOVA", ...)</code>
or by using the <code><a href="#topic+covANOVA">covANOVA</a></code> function.
</p>


<h3>Slots</h3>


<dl>
<dt><code>k1Fun1</code>:</dt><dd>
<p>Object of class <code>"function"</code> A function of a scalar numeric
variable.
</p>
</dd>
<dt><code>k1Fun1Char</code>:</dt><dd>
<p>Object of class <code>"character"</code> describing the function in the
slot <code>k1Fun1</code>.
</p>
</dd>
<dt><code>hasGrad</code>:</dt><dd>
<p>Object of class <code>"logical"</code>. Tells if the value returned by
the function <code>kern1Fun</code> has an attribute named <code>"der"</code>
giving the derivative(s).
</p>
</dd>
<dt><code>cov</code>:</dt><dd>
<p>Object of class <code>"integer"</code>. The value <code>1L</code> corresponds
to a general covariance kernel. The value of <code>0L</code> sets the variance parameter to <code>1</code>, which does <em>not</em> correspond to a correlation kernel. See Section 'details' of <code><a href="#topic+covANOVA">covANOVA</a></code>.</p>
</dd>
<dt><code>iso</code>:</dt><dd>
<p>Object of class <code>"integer"</code>. The value <code>1L</code> corresponds
to an isotropic covariance, with all the inputs sharing the same
range value.
</p>
</dd>
<dt><code>iso1</code>:</dt><dd>
<p>Object of class <code>"integer"</code> used only when the function in
the slot <code>k1Fun1</code> depends on parameters i.e. has more than
one formal argument. NOT IMPLEMENTED YET.  
</p>
</dd>
<dt><code>label</code>:</dt><dd>
<p>Object of class <code>"character"</code>. Short description of the
object.
</p>
</dd>
<dt><code>d</code>:</dt><dd>
<p>Object of class <code>"integer"</code>. Dimension, i.e. number of
inputs.
</p>
</dd>
<dt><code>inputNames</code>:</dt><dd>
<p>Object of class <code>"optCharacter"</code>. Names of the inputs.
</p>
</dd>
<dt><code>parLower</code>:</dt><dd>
<p>Object of class <code>"numeric"</code>. Numeric values for the lower
bounds on the parameters. Can be <code>-Inf</code>.
</p>
</dd>
<dt><code>parUpper</code>:</dt><dd>
<p>Object of class <code>"numeric"</code>. Numeric values for the upper
bounds on the parameters. Can be <code>Inf</code>.
</p>
</dd>
<dt><code>par</code>:</dt><dd>
<p>Object of class <code>"numeric"</code>. Numeric values for the
parameters. Can be <code>NA</code>.
</p>
</dd>
<dt><code>kern1ParN1</code>:</dt><dd>
<p>Object of class <code>"integer"</code>. The number of parameters in
<code>k1Fun1</code> (such as a shape).
</p>
</dd>
<dt><code>parN1</code>:</dt><dd>
<p>Object of class <code>"integer"</code>. Number of parameters of the
function <code>kern1Fun</code> (such as a shape).
</p>
</dd>
<dt><code>parN</code>:</dt><dd>
<p>Object of class <code>"integer"</code>. Number of parameters for the
object. The include: <em>direct</em> parameters in the function
<code>kern1Fun</code>, ranges, and variance.
</p>
</dd>
<dt><code>kern1ParNames</code>:</dt><dd>
<p>Object of class <code>"character"</code>. Names of the <em>direct</em>
parameters.
</p>
</dd>
<dt><code>kernParNames</code>:</dt><dd>
<p>Object of class <code>"character"</code>. Names of the parameters.
</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+covAll-class">covAll</a>"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>coef</dt><dd>
<p><code>signature(object = "covANOVA")</code>: Get the vector of values for
the parameters.
</p>
</dd>
<dt>coef&lt;-</dt><dd>
<p><code>signature(object = "covANOVA", value = "numeric")</code>: Set the
vector of values for the parameters.
</p>
</dd>
<dt>coefLower</dt><dd>
<p><code>signature(object = "covANOVA")</code>: Get the vector of
lower bounds on the parameters.
</p>
</dd>
<dt>coefLower&lt;-</dt><dd>
<p><code>signature(object = "covANOVA")</code>: Set the vector of lower
bounds on the parameters.
</p>
</dd>
<dt>coefUpper</dt><dd>
<p><code>signature(object = "covANOVA")</code>: Get the vector of upper
bounds on the parameters.
</p>
</dd>
<dt>coefUpper&lt;-</dt><dd>
<p><code>signature(object = "covANOVA")</code>: Set the vector of upper
bounds on the parameters. 
</p>
</dd>
<dt>covMat</dt><dd>
<p><code>signature(object = "covANOVA")</code>: Compute the covariance
matrix for given sites.
</p>
</dd>
<dt>npar</dt><dd>
<p><code>signature(object = "covANOVA")</code>: Get the number of
parameters.
</p>
</dd>
<dt>scores</dt><dd>
<p><code>signature(object = "covANOVA")</code>: Compute the scores
i.e. the derivatives w.r.t. the parameters of the contribution of
the covariance in the log-likelihood of a <code>gp</code>.
</p>
</dd>
<dt>show</dt><dd>
<p><code>signature(object = "covANOVA")</code>: Print or show the object.
</p>
</dd>
<dt>varVec</dt><dd>
<p><code>signature(object = "covANOVA")</code>: Compute the variance
vector for given sites.
</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+covTP">covTP</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("covANOVA")
</code></pre>

<hr>
<h2 id='covComp'>Creator for the Class <code>"covComp"</code> for Composite Covariance
Kernels</h2><span id='topic+covComp'></span>

<h3>Description</h3>

<p>Creator for the class &quot;covComp&quot; for Composite Covariance kernels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covComp(formula, where = .GlobalEnv, topParLower = NULL,
  topParUpper = NULL, trace = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covComp_+3A_formula">formula</code></td>
<td>
<p>A formula. See <b>Examples</b>.</p>
</td></tr>
<tr><td><code id="covComp_+3A_where">where</code></td>
<td>
<p>An environment where the covariance kernels objects
and top parameters will be looked for.</p>
</td></tr>
<tr><td><code id="covComp_+3A_topparlower">topParLower</code></td>
<td>
<p>A numeric vector of lower bounds for the &quot;top&quot;
parameters.</p>
</td></tr>
<tr><td><code id="covComp_+3A_topparupper">topParUpper</code></td>
<td>
<p>A numeric vector of upper bounds for the &quot;top&quot;
parameters.</p>
</td></tr>
<tr><td><code id="covComp_+3A_trace">trace</code></td>
<td>
<p>Integer level of verbosity.</p>
</td></tr>
<tr><td><code id="covComp_+3A_...">...</code></td>
<td>
<p>Not used yet. For passing other slot values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A covariance object is built using <code>formula</code> which involves
kernel objects inheriting from the class <code>"covAll"</code> and
possibly of other scalar numeric parameters called <em>top</em>
parameters. The formula can be thought of as involving the
covariance matrices rather than the kernel objects, each kernel
object say <code>obj</code> being replaced by <code>covMat(obj, X)</code> for
some design matrix or data frame <code>X</code>. Indeed, the sum or the
product of two kernel objects lead to a covariance which is simply
the sum or product of the kernel covariances. The top parameters
are considered as parameters of the covariance structure, as well
as the parameters of the covariance objects used in the
formula. Their value at the creation time will be used and thus
will serve as initial value in estimation.
</p>


<h3>Value</h3>

<p>An object with S4 class <code>"covComp"</code>.
</p>


<h3>Caution</h3>

<p>The class definition and its creator are to
regarded as a DRAFT, many changes being necessary until a stable
implementation will be reached. The functions relating to this
class are not for final users of GP models, but rather to those
interested in the conception and specification in view of a future
release of the <b>kergp</b> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## =========================================================================
## build some kernels (with their inputNames) in the global environment
## =========================================================================

myCovExp3 &lt;- kMatern(d = 3, nu = "1/2")
inputNames(myCovExp3) &lt;- c("x", "y", "z")

myCovGauss2 &lt;- kGauss(d = 2)
inputNames(myCovGauss2) &lt;- c("temp1", "temp2")

k &lt;- kMatern(d = 1)
inputNames(k) &lt;- "x"

ell &lt;- kMatern(d = 1)
inputNames(ell) &lt;- "y"

tau2 &lt;- 100
sigma2 &lt;- 4

myCovComp &lt;- covComp(formula = ~ tau2 * myCovGauss2() * myCovExp3() + sigma2 * k())

myCovComp1 &lt;- covComp(formula = ~ myCovGauss2() * myCovExp3() + k())

inputNames(myCovComp)
coef(myCovComp)

n &lt;- 5
set.seed(1234)
X &lt;- data.frame(x = runif(n), y = runif(n), z = runif(n),
                temp1 = runif(n), temp2 = runif(n))

C &lt;- covMat(myCovComp, X = X)

Cg &lt;- covMat(myCovComp, X = X, compGrad = TRUE)

## Simulation: purely formal example, not meaningful.

Y &lt;- simulate(myCovComp, X = X, nsim = 100)

</code></pre>

<hr>
<h2 id='covComp-class'>
Class <code>"covComp"</code>
</h2><span id='topic+covComp-class'></span><span id='topic+checkX+2CcovComp+2Cdata.frame-method'></span><span id='topic+coef+2CcovComp-method'></span><span id='topic+coef+3C-+2CcovComp+2Cnumeric-method'></span><span id='topic+coefLower+2CcovComp-method'></span><span id='topic+coefUpper+2CcovComp-method'></span><span id='topic+covMat+2CcovComp-method'></span><span id='topic+inputNames+3C-+2CcovComp+2Ccharacter-method'></span><span id='topic+show+2CcovComp-method'></span><span id='topic+scores+2CcovComp-method'></span><span id='topic+varVec+2CcovComp-method'></span><span id='topic+as.list+2CcovComp-method'></span>

<h3>Description</h3>

<p>Class <code>"covComp"</code> representing a composite kernel combining
several kernels objects inheriting from the class <code>"covAll"</code>.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("covComp",
    ...)</code> or by using <code>covComp</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>def</code>:</dt><dd>
<p>Object of class <code>"expression"</code> defining the
This is a parsed and cleaned version of the value
of the <code>formula</code> formal in <code><a href="#topic+covComp">covComp</a></code>.
</p>
</dd>
<dt><code>covAlls</code>:</dt><dd>
<p>Object of class <code>"list"</code> containing the kernel
objects used by the formula. The coefficients of these
kernels can be changed.
</p>
</dd>
<dt><code>hasGrad</code>:</dt><dd>
<p>Object of class <code>"logical"</code>: can we differentiate
the kernel w.r.t. all its parameters?
</p>
</dd>
<dt><code>label</code>:</dt><dd>
<p>Object of class <code>"character"</code> A label attached to the kernel
to describe it.
</p>
</dd>
<dt><code>d</code>:</dt><dd>
<p>Object of class <code>"integer"</code>: dimension (or number of inputs).
</p>
</dd>
<dt><code>parN</code>:</dt><dd>
<p>Object of class <code>"integer"</code>: number of parameters.
</p>
</dd>
<dt><code>parNames</code>:</dt><dd>
<p>Object of class <code>"character"</code>: vector of parameter names. Its
length is in slot <code>parN</code>.
</p>
</dd>
<dt><code>inputNames</code>:</dt><dd>
<p>Object of class <code>"character"</code>: names of the inputs used by
the kernel.
</p>
</dd>
<dt><code>topParN</code>:</dt><dd>
<p>Object of class <code>"integer"</code>: number of <em>top</em> parameters.
</p>
</dd>
<dt><code>topParNames</code>:</dt><dd>
<p>Object of class <code>"character"</code>. Names of the top parameters.
</p>
</dd>
<dt><code>topPar</code>:</dt><dd>
<p>Object of class <code>"numeric"</code>. Values of the top parameters.
</p>
</dd>
<dt><code>topParLower</code>:</dt><dd>
<p>Object of class <code>"numeric"</code>. Lower bounds for the top
parameters.
</p>
</dd>
<dt><code>topParUpper</code>:</dt><dd>
<p>Object of class <code>"numeric"</code>. Upper bounds for the top
parameters.
</p>
</dd>
<dt><code>parsedFormula</code>:</dt><dd>
<p>Object of class <code>"list"</code>. Ugly draft for some slots to be
added in the next versions.
</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+covAll-class">covAll</a>"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>as.list</dt><dd>
<p><code>signature(object = "covComp")</code>: coerce <code>object</code> into a
list of covariance kernels, each inheriting from the virual class
<code>"covAll"</code>. This is useful e.g., to extract the coefficients
or to plot a covariance component.
</p>
</dd>
<dt>checkX</dt><dd>
<p><code>signature(object = "covComp", X = "data.frame")</code>: check that
the inputs exist with suitable column names and suitable <em>factor</em>
content. The levels should match the prescribed levels. Returns a
matrix with the input columns in the order prescribed by
<code>object</code>.
</p>
</dd>
<dt>coef, coef&lt;-</dt><dd>
<p><code>signature(object = "covComp")</code>: extract or replace the
vector of coefficients.
</p>
</dd>
<dt>coefLower, coefUpper</dt><dd>
<p><code>signature(object = "covComp")</code>: extract the vector of Lower
or Upper bounds on the coefficients.
</p>
</dd>
<dt>scores</dt><dd>
<p><code>signature(object = "covComp")</code>: return the vector of
scores, i.e. the derivative of the log-likelihood w.r.t. the
parameter vector at the current parameter values.
</p>
</dd>
</dl>



<h3>See Also</h3>

<p>The <code><a href="#topic+covComp">covComp</a></code> creator.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
showClass("covComp")

</code></pre>

<hr>
<h2 id='covMan'> Creator Function for <code>covMan</code> Objects </h2><span id='topic+covMan'></span>

<h3>Description</h3>

<p>Creator function for <code>covMan</code> objects representing a covariance
kernel entered manually.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   covMan(kernel, hasGrad = FALSE, acceptMatrix = FALSE,
          inputs = paste("x", 1:d, sep = ""), 
          d = length(inputs), parNames,
          par = NULL, parLower = NULL, parUpper = NULL,
          label = "covMan", ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covMan_+3A_kernel">kernel</code></td>
<td>

<p>A (semi-)positive definite function. This must be an object of class
<code>"function"</code> with formal arguments named <code>"x1"</code>, <code>"x2"</code>
and <code>"par"</code>. The first two formal arguments are locations vectors
or matrices. The third formal is for the vector
<code class="reqn">\boldsymbol{\theta}</code> of <em>all</em> covariance
parameters. An analytical gradient can be computed and returned as an
attribute of the result with name <code>"gradient"</code>. See
<b>Details</b>.
</p>
</td></tr>
<tr><td><code id="covMan_+3A_hasgrad">hasGrad</code></td>
<td>

<p>Logical indicating whether the <code>kernel</code> function returns the
gradient w.r.t. the vector of parameters as a <code>"gradient"</code>
attribute of the result. See <b>Details</b>
</p>
</td></tr>
<tr><td><code id="covMan_+3A_acceptmatrix">acceptMatrix</code></td>
<td>

<p>Logical indicating whether <code>kernel</code> admits matrices as
arguments. Default is <code>FALSE</code>. See <b>Examples</b> below.
</p>
</td></tr>
<tr><td><code id="covMan_+3A_inputs">inputs</code></td>
<td>

<p>Character vector giving the names of the inputs used as arguments
of <code>kernel</code>. Optional if <code>d</code> is given.
</p>
</td></tr>
<tr><td><code id="covMan_+3A_d">d</code></td>
<td>

<p>Integer specifying the spatial dimension (equal to the number of
inputs). Optional if <code>inputs</code> is given.
</p>
</td></tr>
<tr><td><code id="covMan_+3A_parnames">parNames</code></td>
<td>

<p>Vector of character strings containing the parameter names.
</p>
</td></tr>
<tr><td><code id="covMan_+3A_par">par</code>, <code id="covMan_+3A_parlower">parLower</code>, <code id="covMan_+3A_parupper">parUpper</code></td>
<td>

<p>Optional numeric vectors containing the parameter values, lower
bounds and upper bounds.
</p>
</td></tr>
<tr><td><code id="covMan_+3A_label">label</code></td>
<td>

<p>Optional character string describing the kernel.
</p>
</td></tr>
<tr><td><code id="covMan_+3A_...">...</code></td>
<td>

<p>Not used at this stage.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The formals and the returned value of the <code>kernel</code> function
must be in accordance with the value of <code>acceptMatrix</code>. 
</p>

<ul>
<li>
<p>When <code>acceptMatrix</code> is <code>FALSE</code>, the formal arguments
<code>x1</code> and <code>x2</code> of <code>kernel</code> are numeric vectors with
length <code class="reqn">d</code>. The returned result is a numeric vector of length
<code class="reqn">1</code>.  The attribute named <code>"gradient"</code> of the returned
value (if provided in accordance with the value of <code>hasGrad</code>)
must then be a numeric vector with length equal to the number of
covariance parameters. It must contain the derivative of the
kernel value
<code class="reqn">K(\mathbf{x}_1,\,\mathbf{x}_2;\,\boldsymbol{\theta})</code> with respect to the parameter vector
<code class="reqn">\boldsymbol{\theta}</code>.
</p>

</li>
<li>
<p>When <code>acceptMatrix</code> is <code>TRUE</code>, the formals <code>x1</code> and
<code>x2</code> are matrices with <code class="reqn">d</code> columns and with <code class="reqn">n_1</code>
and <code class="reqn">n_2</code> rows. The result is then a covariance matrix
with <code class="reqn">n_1</code> rows and <code class="reqn">n_2</code> columns. The gradient
attribute (if provided in accordance with the value of
<code>hasGrad</code>) must be a list with length equal to the number of
covariance parameters. The list element <code class="reqn">\ell</code> must contain
a numeric matrix with dimension <code class="reqn">(n_1, n_2)</code>
which is the derivative of the covariance matrix w.r.t. the
covariance parameter <code class="reqn">\theta_\ell</code>. 
</p>
</li></ul>



<h3>Note</h3>

<p>The kernel function must be symmetric with respect to its
first two arguments, and it must be positive definite,
which is not checked. If the function returns an object
with a <code>"gradient"</code> attribute but <code>hasGrad</code> was
set to <code>FALSE</code>, the gradient will <em>not</em> be used
in optimization.
</p>
<p>The name of the class was motivated by earlier stages in the
development.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>myCovMan &lt;- 
      covMan(
         kernel = function(x1, x2, par) { 
         htilde &lt;- (x1 - x2) / par[1]
         SS2 &lt;- sum(htilde^2)
         d2 &lt;- exp(-SS2)
         kern &lt;- par[2] * d2
         d1 &lt;- 2 * kern * SS2 / par[1]            
         attr(kern, "gradient") &lt;- c(theta = d1,  sigma2 = d2)
         return(kern)
      },
      hasGrad = TRUE,    
      d = 1,
      label = "myGauss",
      parLower = c(theta = 0.0, sigma2 = 0.0),
      parUpper = c(theta = Inf, sigma2 = Inf),
      parNames = c("theta", "sigma2"),
      par = c(NA, NA)
      )
      
# Let us now code the same kernel in C
kernCode &lt;- "
       SEXP kern, dkern;
       int nprotect = 0, d;
       double SS2 = 0.0, d2, z, *rkern, *rdkern;

       d = LENGTH(x1);
       PROTECT(kern = allocVector(REALSXP, 1)); nprotect++;
       PROTECT(dkern = allocVector(REALSXP, 2)); nprotect++;
       rkern = REAL(kern);
       rdkern = REAL(dkern);

       for (int i = 0; i &lt; d; i++) {
         z = ( REAL(x1)[i] - REAL(x2)[i] ) / REAL(par)[0];
         SS2 += z * z; 
       }

       d2 = exp(-SS2);
       rkern[0] = REAL(par)[1] * d2;
       rdkern[1] =  d2; 
       rdkern[0] =  2 * rkern[0] * SS2 / REAL(par)[0];

       SET_ATTR(kern, install(\"gradient\"), dkern);
       UNPROTECT(nprotect);
       return kern;
     "
     
myCovMan  

## "inline" the C function into an R function: much more efficient! 

## Not run: 
require(inline)
kernC &lt;- cfunction(sig = signature(x1 = "numeric", x2 = "numeric",
                                   par = "numeric"),
                    body = kernCode)
myCovMan &lt;- covMan(kernel = kernC, hasGrad = TRUE, d = 1,
                   parNames = c("theta", "sigma2"))
myCovMan

## End(Not run)

## A kernel admitting matricial arguments
myCov &lt;- covMan(
    
    kernel = function(x1, x2, par) { 
      # x1 : matrix of size n1xd
      # x2 : matrix of size n2xd
            
      d &lt;- ncol(x1)
            
      SS2 &lt;- 0
      for (j in 1:d){
        Aj &lt;- outer(x1[, j], x2[, j], "-")
        Aj2 &lt;- Aj^2
        SS2 &lt;- SS2 + Aj2 / par[j]^2
      }
      D2 &lt;- exp(-SS2)
      kern &lt;- par[d + 1] * D2
    },
    acceptMatrix = TRUE,
    d = 2,
    label = "myGauss",
    parLower = c(theta1 = 0.0, theta2 = 0.0, sigma2 = 0.0),
    parUpper = c(theta1 = Inf, theta2 = Inf, sigma2 = Inf),
    parNames = c("theta1", "theta2", "sigma2"),
    par = c(NA, NA, NA)

)
      
coef(myCov) &lt;- c(0.5, 1, 4)
show(myCov)

## computing the covariance kernel between two points
X &lt;- matrix(c(0, 0), ncol = 2)
Xnew &lt;- matrix(c(0.5, 1), ncol = 2)
colnames(X) &lt;- colnames(Xnew) &lt;- inputNames(myCov)
covMat(myCov, X)            ## same points
covMat(myCov, X, Xnew)      ## two different points

# computing covariances between sets of given locations
X &lt;- matrix(c(0, 0.5, 0.7, 0, 0.5, 1), ncol = 2)
t &lt;- seq(0, 1, length.out = 3)
Xnew &lt;- as.matrix(expand.grid(t, t))
colnames(X) &lt;- colnames(Xnew) &lt;- inputNames(myCov)
covMat(myCov, X)         ## covariance matrix
covMat(myCov, X, Xnew)   ## covariances between design and new data

</code></pre>

<hr>
<h2 id='covMan-class'>Class <code>"covMan"</code></h2><span id='topic+covMan-class'></span><span id='topic+coef+3C-+2CcovMan+2Cnumeric-method'></span><span id='topic+coefLower+3C-+2CcovMan-method'></span><span id='topic+coefLower+2CcovMan-method'></span><span id='topic+coefUpper+3C-+2CcovMan-method'></span><span id='topic+coefUpper+2CcovMan-method'></span><span id='topic+coerce+2CcovMan+2Cfunction-method'></span><span id='topic+show+2CcovMan-method'></span><span id='topic+scores+2CcovMan-method'></span>

<h3>Description</h3>

<p>S4 class representing a covariance kernel defined manually by a
(semi-)positive definite function.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calling <code>new("covMan", ...)</code>
or by using the <code><a href="#topic+covMan">covMan</a></code> function.
</p>


<h3>Slots</h3>


<dl>
<dt><code>kernel</code>:</dt><dd>
<p>object of class <code>"function"</code> defining the kernel (supposed to
be (semi-)positive definite).
</p>
</dd>
<dt><code>hasGrad</code>:</dt><dd>
<p>logical indicating whether <code>kernel</code> returns the gradient
(w.r.t. the vector of parameters) as <code>"gradient"</code> attribute
of the result.
</p>
</dd>
<dt><code>acceptMatrix</code>:</dt><dd>
<p>logical indicating whether <code>kernel</code> admits matrix
arguments. Default is <code>FALSE</code>.
</p>
</dd>
<dt><code>label</code>:</dt><dd>
<p>object of class character, typically one or two words, used to
describe the kernel.
</p>
</dd>
<dt><code>d</code>:</dt><dd>
<p>object of class <code>"integer"</code>, the spatial dimension or number
of inputs of the covariance.
</p>
</dd>
<dt><code>inputNames</code>:</dt><dd>
<p>object of class <code>"character"</code>, vector of input names. Length
<code>d</code>.
</p>
</dd>
<dt><code>parLower</code>:</dt><dd><p>, </p>
</dd>
<dt><code>parUpper</code>:</dt><dd>
<p>object of class <code>"numeric"</code>, vector of (possibly infinite)
lower/upper bounds on parameters.
</p>
</dd>
<dt><code>par</code>:</dt><dd>
<p>object of class <code>"numeric"</code>, numeric vector of parameter
values.
</p>
</dd>
<dt><code>parN</code>:</dt><dd>
<p>object of class <code>"integer"</code>, total number of parameters.
</p>
</dd>
<dt><code>kernParNames</code>:</dt><dd>
<p>object of class <code>"character"</code>, name of the kernel
parameters. 

</p>
</dd>
</dl>



<h3>Methods</h3>





<dl>
<dt>coef&lt;-</dt><dd>
<p><code>signature(object = "covMan")</code>: replace the whole vector of
coefficients, as required during ML estimation.
</p>
</dd>
<dt>coefLower&lt;-</dt><dd>
<p><code>signature(object = "covMan")</code>: replacement method for lower
bounds on covMan coefficients.
</p>
</dd>
<dt>coefLower</dt><dd>
<p><code>signature(object = "covMan")</code>: extracts the numeric values of
the lower bounds.
</p>
</dd>
<dt>coef</dt><dd>
<p><code>signature(object = "covMan")</code>: extracts the numeric values
of the covariance parameters.


</p>
</dd>
<dt>coefUpper&lt;-</dt><dd>
<p><code>signature(object = "covMan")</code>: replacement method for upper
bounds on covMan coefficients.
</p>
</dd>
<dt>coefUpper</dt><dd>
<p><code>signature(object = "covMan")</code>: ...
</p>
</dd>
<dt>covMat</dt><dd>
<p><code>signature(object = "covMan")</code>: builds the covariance matrix
or the cross covariance matrix between two sets of locations for a
<code>covMan</code> object.
</p>
</dd>
<dt>scores</dt><dd>
<p><code>signature(object = "covMan")</code>: computes the scores
(derivatives of the log-likelihood w.r.t. the covariance
parameters.
</p>
</dd>
<dt>show</dt><dd>
<p><code>signature(object = "covMan")</code>: prints in a custom format.
</p>
</dd>
</dl>



<h3>Note</h3>

<p>While the <code>coef&lt;-</code> replacement method is typically intended for
internal use during likelihood maximization, the <code>coefLower&lt;-</code>
and <code>coefUpper&lt;-</code> replacement methods can be used when some
information is available on the possible values of the parameters.
</p>


<h3>Author(s)</h3>

<p>Y. Deville, O. Roustant, D. Ginsbourger and N. Durrande.
</p>


<h3>See Also</h3>

<p>The <code><a href="#topic+covMan">covMan</a></code> function providing a creator.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("covMan")
</code></pre>

<hr>
<h2 id='covMat'>
Generic Function: Covariance or Cross-Covariance
Matrix Between two Sets of Locations
</h2><span id='topic+covMat'></span>

<h3>Description</h3>

<p>Generic function returning a covariance or a cross-covariance matrix
between two sets of locations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
covMat(object, X, Xnew, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covMat_+3A_object">object</code></td>
<td>

<p>Covariance kernel object.
</p>
</td></tr>
<tr><td><code id="covMat_+3A_x">X</code></td>
<td>

<p>A matrix with <code>d</code> columns, where <code>d</code> is the number of inputs
of the covariance kernel. The <code class="reqn">n_1</code> rows define a first set of sites or
locations, typically used for learning.
</p>
</td></tr>
<tr><td><code id="covMat_+3A_xnew">Xnew</code></td>
<td>

<p>A matrix with <code>d</code> columns, where <code>d</code> is the number of inputs
of the covariance kernel. The <code class="reqn">n_2</code> rows define a second set of
sites or locations, typically used for testing or prediction.
If <code>Xnew = NULL</code> the same locations are used: <code>Xnew = X</code>.
</p>
</td></tr>
<tr><td><code id="covMat_+3A_...">...</code></td>
<td>

<p>Other arguments for methods.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A rectangular matrix with <code>nrow(X)</code> rows and <code>nrow(Xnew)</code>
columns containing the covariances <code class="reqn">K(\mathbf{x}_1,
    \mathbf{x}_2)</code> for all the couples of sites
<code class="reqn">\mathbf{x}_1</code> and <code class="reqn">\mathbf{x}_2</code>.
</p>

<hr>
<h2 id='covMat-methods'>
Covariance Matrix for a Covariance Kernel Object
</h2><span id='topic+covMat+2CcovMan-method'></span><span id='topic+covMat+2CcovTS-method'></span>

<h3>Description</h3>

<p>Covariance matrix for a covariance kernel object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'covMan'
covMat(object, X, Xnew, compGrad = hasGrad(object), 
       checkNames = NULL, index = 1L, ...)

## S4 method for signature 'covTS'
covMat(object, X, Xnew, compGrad = FALSE, 
       checkNames = TRUE, index = 1L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covMat-methods_+3A_object">object</code></td>
<td>

<p>An object with S4 class corresponding to a covariance kernel.
</p>
</td></tr>
<tr><td><code id="covMat-methods_+3A_x">X</code></td>
<td>

<p>The matrix (or data.frame) of design points, with <code class="reqn">n</code> rows and
<code class="reqn">d</code> cols where <code class="reqn">n</code> is the number of spatial points and
<code class="reqn">d</code> is the 'spatial' dimension.
</p>
</td></tr>
<tr><td><code id="covMat-methods_+3A_xnew">Xnew</code></td>
<td>

<p>An optional new matrix of spatial design points. If missing, the
same matrix is used: <code>Xnew = X</code>.
</p>
</td></tr>
<tr><td><code id="covMat-methods_+3A_compgrad">compGrad</code></td>
<td>

<p>Logical. If <code>TRUE</code> a derivative with respect to a parameter
will be computed and returned as an attribute of the result. For
the <code>covMan</code> class, this is possible only when the gradient
of the kernel is computed and returned as a <code>"gradient"</code>
attribute of the result.
</p>
</td></tr>
<tr><td><code id="covMat-methods_+3A_checknames">checkNames</code></td>
<td>

<p>Logical. If <code>TRUE</code> (default), check the compatibility of
<code>X</code> with <code>object</code>, see <code><a href="#topic+checkX">checkX</a></code>.
</p>
</td></tr>
<tr><td><code id="covMat-methods_+3A_index">index</code></td>
<td>

<p>Integer giving the index of the derivation parameter in the official
order. Ignored if <code>compGrad = FALSE</code>.
</p>
</td></tr>
<tr><td><code id="covMat-methods_+3A_...">...</code></td>
<td>

<p>not used yet.
</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>The covariance matrix is computed in a C program using the
<code>.Call</code> interface. The R kernel function is evaluated within the
C code using <code>eval</code>.
</p>


<h3>Value</h3>

<p>A <code class="reqn">n_1 \times n_2</code> matrix with general element
<code class="reqn">C_{ij} :=
  K(\mathbf{x}_{1,i},\,\mathbf{x}_{2,j};\,\boldsymbol{\theta})</code> where
<code class="reqn">K(\mathbf{x}_1,\,\mathbf{x}_2;\,\boldsymbol{\theta})</code> is the covariance kernel function.
</p>


<h3>Note</h3>

<p>The value of the parameter <code class="reqn">\boldsymbol{\theta}</code> can be
extracted from the object with the <code>coef</code> method.
</p>


<h3>Author(s)</h3>

<p>Y. Deville, O. Roustant, D. Ginsbourger, N. Durrande.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+coef">coef</a></code> method
</p>


<h3>Examples</h3>

<pre><code class='language-R'>myCov &lt;- covTS(inputs = c("Temp", "Humid", "Press"),
               kernel = "k1PowExp",
               dep = c(range = "cst", shape = "cst"),
               value = c(shape = 1.8, range = 1.1))
n &lt;- 100; X &lt;- matrix(runif(n*3), nrow = n, ncol = 3)
try(C1 &lt;- covMat(myCov, X)) ## bad colnames
colnames(X) &lt;- inputNames(myCov)
C2 &lt;- covMat(myCov, X)

Xnew &lt;- matrix(runif(n * 3), nrow = n, ncol = 3)
colnames(Xnew) &lt;- inputNames(myCov)
C2 &lt;- covMat(myCov, X, Xnew)

## check with the same matrix in 'X' and 'Xnew'
CMM &lt;- covMat(myCov, X, X)
CM &lt;- covMat(myCov, X)
max(abs(CM - CMM))
</code></pre>

<hr>
<h2 id='covOrd'>Warping-Based Covariance for an Ordinal Input</h2><span id='topic+covOrd'></span>

<h3>Description</h3>

<p>Creator function for the class <code><a href="#topic+covOrd-class">covOrd-class</a></code></p>


<h3>Usage</h3>

<pre><code class='language-R'>covOrd(ordered, 
       k1Fun1 = k1Fun1Matern5_2, 
       warpFun = c("norm", "unorm", "power", "spline1", "spline2"), 
       cov = c("corr", "homo"), 
       hasGrad = TRUE, inputs = "u", 
       par = NULL, parLower = NULL, parUpper = NULL, 
       warpKnots = NULL, nWarpKnots = NULL,
       label = "Ordinal kernel", 
       intAsChar = TRUE, 
       ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covOrd_+3A_ordered">ordered</code></td>
<td>

<p>An object coerced to <code><a href="base.html#topic+ordered">ordered</a></code> representing an ordinal input. 
Only the levels and their order will be used.
</p>
</td></tr>
<tr><td><code id="covOrd_+3A_k1fun1">k1Fun1</code></td>
<td>

<p>A function representing a 1-dimensional stationary kernel function, with no or fixed parameters.
</p>
</td></tr>
<tr><td><code id="covOrd_+3A_warpfun">warpFun</code></td>
<td>

<p>Character corresponding to an increasing warping function. See <code><a href="#topic+warpFun">warpFun</a></code>.
</p>
</td></tr>
<tr><td><code id="covOrd_+3A_cov">cov</code></td>
<td>

<p>Character indicating whether a correlation or homoscedastic kernel is used.
</p>
</td></tr>
<tr><td><code id="covOrd_+3A_hasgrad">hasGrad</code></td>
<td>

<p>Object of class <code>"logical"</code>. If <code>TRUE</code>, both <code>k1Fun1</code> and <code>warpFun</code> 
must return the gradient as an attribute of the result.
</p>
</td></tr>
<tr><td><code id="covOrd_+3A_inputs">inputs</code></td>
<td>

<p>Character: name of the ordinal input.
</p>
</td></tr>
<tr><td><code id="covOrd_+3A_par">par</code>, <code id="covOrd_+3A_parlower">parLower</code>, <code id="covOrd_+3A_parupper">parUpper</code></td>
<td>

<p>Numeric vectors containing covariance parameter values/bounds in the following order: 
warping, range and variance if required (<code>cov == "homo"</code>).
</p>
</td></tr>
<tr><td><code id="covOrd_+3A_warpknots">warpKnots</code></td>
<td>

<p>Numeric vector containing the knots used when a spline warping is chosen. 
The knots must be in [0, 1], and 0 and 1 are automatically added if not provided. 
The number of knots cannot be greater than the number of levels.
</p>
</td></tr>
<tr><td><code id="covOrd_+3A_nwarpknots">nWarpKnots</code></td>
<td>

<p>Number of knots when a spline warping is used. Ignored if <code>warpKnots</code> is given. 
<code>nWarpKnots</code> cannot be greater than the number of levels.
</p>
</td></tr>
<tr><td><code id="covOrd_+3A_label">label</code></td>
<td>

<p>Character giving a brief description of the kernel.
</p>
</td></tr>
<tr><td><code id="covOrd_+3A_intaschar">intAsChar</code></td>
<td>

<p>Logical. If <code>TRUE</code> (default), an integer-valued input will be coerced into a character. 
Otherwise, it will be coerced into a factor.
</p>
</td></tr>
<tr><td><code id="covOrd_+3A_...">...</code></td>
<td>

<p>Not used at this stage.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Covariance kernel for qualitative ordered inputs obtained by warping. 
</p>
<p>Let <code class="reqn">u</code> be an ordered factor with levels <code class="reqn">u_1, \dots, u_L</code>. 
Let <code class="reqn">k_1</code> be a 1-dimensional stationary kernel (with no or fixed parameters), 
<code class="reqn">F</code> a warping function i.e. an increasing function on the interval <code class="reqn">[0,1]</code> 
and <code class="reqn">\theta</code> a scale parameter. Then <code class="reqn">k</code> is defined by:
</p>
<p style="text-align: center;"><code class="reqn">k(u_i, u_j) = k_1([F(z_i) - F(z_{j})]/\theta)</code>
</p>

<p>where <code class="reqn">z_1, \dots, z_L</code> form a regular sequence from <code class="reqn">0</code> to <code class="reqn">1</code> (included). 
At this stage, the possible choices are:
</p>

<ul>
<li><p> A distribution function (cdf) truncated to <code class="reqn">[0,1]</code>, among the Power and Normal cdfs. 
</p>
</li>
<li><p> For the Normal distribution, an unnormalized version, corresponding to the restriction of the cdf on <code class="reqn">[0,1]</code>, is also implemented (<code>warp = "unorm"</code>).
</p>
</li>
<li><p> An increasing spline of degree 1 (piecewise linear function) or 2. In this case, <code class="reqn">F</code> is unnormalized. 
For degree 2, the implementation depends on scaling functions from DiceKriging package, which must be loaded here.
</p>
</li></ul>

<p>Notice that for unnormalized <code>F</code>, we set <code class="reqn">\theta</code> to 1, in order to avoid overparameterization.
</p>


<h3>Value</h3>

<p>An object of class <code>covOrd-class</code>, inheriting from <code>covQual-class</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+covOrd-class">covOrd-class</a></code>, <code><a href="#topic+warpFun">warpFun</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>u &lt;- ordered(1:6, labels = letters[1:6])

myCov &lt;- covOrd(ordered = u, cov = "homo", intAsChar = FALSE)
myCov
coef(myCov) &lt;- c(mean = 0.5, sd = 1, theta = 3, sigma2 = 2)
myCov

checkX(myCov, X = data.frame(u = c(1L, 3L)))
covMat(myCov, X = data.frame(u = c(1L, 3L)))

myCov2 &lt;- covOrd(ordered = u, k1Fun1 = k1Fun1Cos, warpFun = "power")
coef(myCov2) &lt;- c(pow = 1, theta = 1) 
myCov2

plot(myCov2, type = "cor", method = "ellipse")
plot(myCov2, type = "warp", col = "blue", lwd = 2)

myCov3 &lt;- covOrd(ordered = u, k1Fun1 = k1Fun1Cos, warpFun = "spline1")
coef(myCov3) &lt;- c(rep(0.5, 2), 2, rep(0.5, 2))
myCov3

plot(myCov3, type = "cor", method = "ellipse")
plot(myCov3, type = "warp", col = "blue", lwd = 2)


str(warpPower)  # details on the list describing the Power cdf
str(warpNorm)   # details on the list describing the Normal cdf
</code></pre>

<hr>
<h2 id='covOrd-class'>
Class <code>"covOrd"</code>
</h2><span id='topic+covOrd-class'></span><span id='topic+checkX+2CcovOrd+2Cmatrix-method'></span><span id='topic+checkX+2CcovOrd+2Cdata.frame-method'></span><span id='topic+coef+2CcovOrd-method'></span><span id='topic+coef+3C-+2CcovOrd+2Cnumeric-method'></span><span id='topic+coefLower+3C-+2CcovOrd-method'></span><span id='topic+coefLower+2CcovOrd-method'></span><span id='topic+coefUpper+3C-+2CcovOrd-method'></span><span id='topic+coefUpper+2CcovOrd-method'></span><span id='topic+coerce+2CcovOrd+2Cfunction-method'></span><span id='topic+covMat+2CcovOrd-method'></span><span id='topic+npar+2CcovOrd-method'></span><span id='topic+show+2CcovOrd-method'></span><span id='topic+scores+2CcovOrd-method'></span><span id='topic+simulate+2CcovOrd-method'></span><span id='topic+varVec+2CcovOrd-method'></span>

<h3>Description</h3>

<p>Covariance kernel for qualitative ordered inputs obtained by warping. 
</p>
<p>Let <code class="reqn">u</code> be an ordered factor with levels <code class="reqn">u_1, \dots, u_L</code>. 
Let <code class="reqn">k_1</code> be a 1-dimensional stationary kernel (with no or fixed parameters), <code class="reqn">F</code> a warping function i.e. an increasing function on the interval <code class="reqn">[0,1]</code> and <code class="reqn">\theta</code> a scale parameter. Then <code class="reqn">k</code> is defined by:
</p>
<p style="text-align: center;"><code class="reqn">k(u_i, u_j) = k_1([F(z_i) - F(z_{j})]/\theta)</code>
</p>

<p>where <code class="reqn">z_1, \dots, z_L</code> form a regular sequence from <code class="reqn">0</code> to <code class="reqn">1</code> (included). Notice that an example of warping is a distribution function (cdf) restricted to <code class="reqn">[0,1]</code>.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("covOrd", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>covLevels</code>:</dt><dd>
<p>Same as for <code><a href="#topic+covQual-class">covQual-class</a></code>. 
</p>
</dd>
<dt><code>covLevMat</code>:</dt><dd>
<p>Same as for <code><a href="#topic+covQual-class">covQual-class</a></code>.
</p>
</dd>
<dt><code>hasGrad</code>:</dt><dd>
<p>Same as for <code><a href="#topic+covQual-class">covQual-class</a></code>.
</p>
</dd>
<dt><code>acceptLowerSQRT</code>:</dt><dd>
<p>Same as for <code><a href="#topic+covQual-class">covQual-class</a></code>.
</p>
</dd>
<dt><code>label</code>:</dt><dd>
<p>Same as for <code><a href="#topic+covQual-class">covQual-class</a></code>.
</p>
</dd>
<dt><code>d</code>:</dt><dd>
<p>Same as for <code><a href="#topic+covQual-class">covQual-class</a></code>. Here equal to 1.
</p>
</dd>
<dt><code>inputNames</code>:</dt><dd>
<p>Same as for <code><a href="#topic+covQual-class">covQual-class</a></code>.
</p>
</dd>
<dt><code>nlevels</code>:</dt><dd>
<p>Same as for <code><a href="#topic+covQual-class">covQual-class</a></code>.
</p>
</dd>
<dt><code>levels</code>:</dt><dd>
<p>Same as for <code><a href="#topic+covQual-class">covQual-class</a></code>.
</p>
</dd>
<dt><code>parLower</code>:</dt><dd>
<p>Same as for <code><a href="#topic+covQual-class">covQual-class</a></code>.
</p>
</dd>
<dt><code>parUpper</code>:</dt><dd>
<p>Same as for <code><a href="#topic+covQual-class">covQual-class</a></code>.
</p>
</dd>
<dt><code>par</code>:</dt><dd>
<p>Same as for <code><a href="#topic+covQual-class">covQual-class</a></code>.
</p>
</dd>
<dt><code>parN</code>:</dt><dd>
<p>Same as for <code><a href="#topic+covQual-class">covQual-class</a></code>.
</p>
</dd>
<dt><code>kernParNames</code>:</dt><dd>
<p>Same as for <code><a href="#topic+covQual-class">covQual-class</a></code>.
</p>
</dd>
<dt><code>k1Fun1</code>:</dt><dd>
<p>A function representing a 1-dimensional stationary kernel function, with no or fixed parameters.
</p>
</dd>
<dt><code>warpFun</code>:</dt><dd>
<p>A cumulative density function representing a warping.
</p>
</dd>
<dt><code>cov</code>:</dt><dd>
<p>Object of class <code>"integer"</code>. The value <code>0L</code> corresponds
to a correlation kernel while <code>1L</code> is for a covariance
kernel.
</p>
</dd>
<dt><code>parNk1</code>:</dt><dd>
<p>Object of class <code>"integer"</code>. Number of parameters of <code>k1Fun1</code>. Equal to <code>0</code> at this stage.
</p>
</dd>
<dt><code>parNwarp</code>:</dt><dd>
<p>Object of class <code>"integer"</code>. Number of parameters of <code>warpFun</code>.
</p>
</dd>
<dt><code>k1ParNames</code>:</dt><dd>
<p>Object of class <code>"character"</code>. Parameter names of <code>k1Fun1</code>.
</p>
</dd>
<dt><code>warpParNames</code>:</dt><dd>
<p>Object of class <code>"character"</code>. Parameter names of <code>warpFun</code>.
</p>
</dd>
<dt><code>warpKnots</code>:</dt><dd>
<p>Object of class <code>"numeric"</code>. Parameters of <code>warpFun</code>.
</p>
</dd>
<dt><code>ordered</code>:</dt><dd>
<p>Object of class <code>"logical"</code>. <code>TRUE</code> for an ordinal input.
</p>
</dd>
<dt><code>intAsChar</code>:</dt><dd>
<p>Object of class <code>"logical"</code>. If <code>TRUE</code> (default), 
an integer-valued input will be coerced into a character.
Otherwise, it will be coerced into a factor.
</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>checkX</dt><dd>
<p><code>signature(object = "covOrd", X = "data.frame")</code>: check that
the inputs exist with suitable column names and suitable <em>factor</em>
content. The levels should match the prescribed levels. Returns a
matrix with the input columns in the order prescribed by
<code>object</code>.
</p>
<p><code>signature(object = "covOrd", X = "matrix")</code>: check that the
inputs exist with suitable column names and suitable <em>numeric</em>
content for coercion into a factor with the prescribed levels.
Returns a data frame with the input columns in the order
prescribed by <code>object</code>.
</p>
</dd>
<dt>coef&lt;-</dt><dd>
<p><code>signature(object = "covOrd")</code>: replace the whole vector of
coefficients, as required during ML estimation.
</p>
</dd>
<dt>coefLower&lt;-</dt><dd>
<p><code>signature(object = "covOrd")</code>: replacement method for lower
bounds on covOrd coefficients.
</p>
</dd>
<dt>coefLower</dt><dd>
<p><code>signature(object = "covOrd")</code>: extracts the numeric values of
the lower bounds.
</p>
</dd>
<dt>coef</dt><dd>
<p><code>signature(object = "covOrd")</code>: extracts the numeric values
of the covariance parameters.
</p>
</dd>
<dt>coefUpper&lt;-</dt><dd>
<p><code>signature(object = "covOrd")</code>: replacement method for upper
bounds on <code>covOrd</code> coefficients.
</p>
</dd>
<dt>coefUpper</dt><dd>
<p><code>signature(object = "covOrd")</code>: ...
</p>
</dd>
<dt>covMat</dt><dd>
<p><code>signature(object = "covOrd")</code>: build the covariance matrix
or the cross covariance matrix between two sets of locations for a
<code>covOrd</code> object.
</p>
</dd>
<dt>npar</dt><dd>
<p><code>signature(object = "covOrd")</code>: returns the number of
parameters.
</p>
</dd>
<dt>scores</dt><dd>
<p><code>signature(object = "covOrd")</code>: return the vector of
scores, i.e. the derivative of the log-likelihood w.r.t. the
parameter vector at the current parameter values.
</p>
</dd>
<dt>simulate</dt><dd>
<p><code>signature(object = "covOrd")</code>: simulate <code>nsim</code> paths
from a Gaussian Process having the covariance structure. The paths
are indexed by the finite set of levels of factor inputs, and they
are returned as columns of a matrix.
</p>
</dd>
<dt>varVec</dt><dd>
<p><code>signature(object = "covOrd")</code>: build the variance vector
corresponding to a set locations for a <code>covOrd</code> object.
</p>
</dd>
</dl>



<h3>Note</h3>

<p>This class is to be regarded as experimental. The slot names or list
may be changed in the future. The methods <code>npar</code>,
<code>inputNames</code> or <code>`inputNames&lt;-`</code> should provide a more
robust access to some slot values.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+covMan-class">covMan</a></code> for a comparable structure dedicated
to kernels with continuous inputs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
showClass("covOrd")

</code></pre>

<hr>
<h2 id='covQual-class'>
Class <code>"covQual"</code>
</h2><span id='topic+covQual-class'></span><span id='topic+checkX+2CcovQual+2Cmatrix-method'></span><span id='topic+checkX+2CcovQual+2Cdata.frame-method'></span><span id='topic+coef+2CcovQual-method'></span><span id='topic+coef+3C-+2CcovQual+2Cnumeric-method'></span><span id='topic+coefLower+3C-+2CcovQual-method'></span><span id='topic+coefLower+2CcovQual-method'></span><span id='topic+coefUpper+3C-+2CcovQual-method'></span><span id='topic+coefUpper+2CcovQual-method'></span><span id='topic+coerce+2CcovQual+2Cfunction-method'></span><span id='topic+covMat+2CcovQual-method'></span><span id='topic+npar+2CcovQual-method'></span><span id='topic+show+2CcovQual-method'></span><span id='topic+scores+2CcovQual-method'></span><span id='topic+simulate+2CcovQual-method'></span><span id='topic+varVec+2CcovQual-method'></span>

<h3>Description</h3>

<p>Covariance kernel for qualitative inputs.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("covQual", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>covLevels</code>:</dt><dd>
<p>Object of class <code>"function"</code>. This function has
arguments <code>'par'</code> and optional arguments <code>lowerSQRT</code> and
<code>compGrad</code>. It returns the covariance matrix for an input 
corresponding to all the levels. 
</p>
</dd>
<dt><code>covLevMat</code>:</dt><dd>
<p>Object of class <code>"matrix"</code>. This is the result returned by the 
function <code>covLevels</code> (former slot) with <code>lowerSQRT = FALSE</code>
and <code>gradient = FALSE</code>.
</p>
</dd>
<dt><code>hasGrad</code>:</dt><dd>
<p>Object of class <code>"logical"</code>.  When <code>TRUE</code>, the
covariance matrix returned by the function in slot
<code>covLevels</code> must compute the gradients. The returned 
covariance matrix must have a <code>"gradient"</code> attribute;
this must be an array with dimension <code>c(m, m, np)</code> where
<code>m</code> stands for the number of levels and <code class="reqn">np</code> is the
number of parameters.
</p>
</dd>
<dt><code>acceptLowerSQRT</code>:</dt><dd>
<p>Object of class <code>"logical"</code>. When <code>TRUE</code>, the function
in slot <code>covLevels</code> must have a formal <code>lowerSQRT</code>
which can receive a logical value. When the value is <code>TRUE</code>
the Cholesky (lower) root of the covariance is returned instead of
the covariance.
</p>
</dd>
<dt><code>label</code>:</dt><dd>
<p>Object of class <code>"character"</code>. A description of the kernel
which will remained attached with it.
</p>
</dd>
<dt><code>d</code>:</dt><dd>
<p>Object of class <code>"integer"</code>. The dimension or number of
(qualitative) inputs of the kernel.
</p>
</dd>
<dt><code>inputNames</code>:</dt><dd>
<p>Object of class <code>"character"</code>. The names of the (qualitative)
inputs. These will be matched against the columns of a data frame
when the kernel will be evaluated.
</p>
</dd>
<dt><code>nlevels</code>:</dt><dd>
<p>Object of class <code>"integer"</code>. A vector with length
<code>d</code> giving the number of levels for each of the <code>d</code>
inputs.
</p>
</dd>
<dt><code>levels</code>:</dt><dd>
<p>Object of class <code>"list"</code>. A list of length <code>d</code>
containing the <code>d</code> character vectors of levels for
the <code>d</code> (qualitative) inputs.
</p>
</dd>
<dt><code>parLower</code>:</dt><dd>
<p>Object of class <code>"numeric"</code>. Vector of <code>parN</code> lower
values for the parameters of the structure. The value
<code>-Inf</code> can be used when needed.
</p>
</dd>
<dt><code>parUpper</code>:</dt><dd>
<p>Object of class <code>"numeric"</code>. Vector of <code>parN</code> upper
values for the parameters of the structure. The value
<code>Inf</code> can be used when needed.
</p>
</dd>
<dt><code>par</code>:</dt><dd>
<p>Object of class <code>"numeric"</code>. Vector of <code>parN</code>
current values for the structure.
</p>
</dd>
<dt><code>parN</code>:</dt><dd>
<p>Object of class <code>"integer"</code>. Number of parameters for the
structure, as returned by the <code>npar</code> method.
</p>
</dd>
<dt><code>kernParNames</code>:</dt><dd>
<p>Object of class <code>"character"</code>. Vector of length <code>parN</code>
giving the names of the parameters. E.g. <code>"range"</code>,
<code>"var"</code>, <code>"sigma2"</code> are popular names.
</p>
</dd>
<dt><code>ordered</code>:</dt><dd>
<p>Vector of class <code>"logical"</code> indicating whether the factors
are ordered or not.
</p>
</dd>
<dt><code>intAsChar</code>:</dt><dd>
<p>Object of class <code>"logical"</code> indicating how to cope with an
integer input. When <code>intAsChar</code> is <code>TRUE</code> the input is
coerced into a character; the values taken by this character
vector should then match the levels in the <code>covQual</code> object
as given by <code>levels(object)[[1]]</code>. If instead
<code>intAsChar</code> is <code>FALSE</code>, the integer values are assumed
to correspond to the levels of the <code>covQual</code> object in the
same order.
</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>checkX</dt><dd>
<p><code>signature(object = "covQual", X = "data.frame")</code>: check that
the inputs exist with suitable column names and suitable <em>factor</em>
content. The levels should match the prescribed levels. Returns a
matrix with the input columns in the order prescribed by
<code>object</code>.
</p>
<p><code>signature(object = "covQual", X = "matrix")</code>: check that the
inputs exist with suitable column names and suitable <em>numeric</em>
content for coercion into a factor with the prescribed levels.
Returns a data frame with the input columns in the order
prescribed by <code>object</code>.
</p>
</dd>
<dt>coef&lt;-</dt><dd>
<p><code>signature(object = "covQual")</code>: replace the whole vector of
coefficients, as required during ML estimation.
</p>
</dd>
<dt>coefLower&lt;-</dt><dd>
<p><code>signature(object = "covQual")</code>: replacement method for lower
bounds on covQual coefficients.
</p>
</dd>
<dt>coefLower</dt><dd>
<p><code>signature(object = "covQual")</code>: extracts the numeric values of
the lower bounds.
</p>
</dd>
<dt>coef</dt><dd>
<p><code>signature(object = "covQual")</code>: extracts the numeric values
of the covariance parameters.
</p>
</dd>
<dt>coefUpper&lt;-</dt><dd>
<p><code>signature(object = "covQual")</code>: replacement method for upper
bounds on <code>covQual</code> coefficients.
</p>
</dd>
<dt>coefUpper</dt><dd>
<p><code>signature(object = "covQual")</code>: ...
</p>
</dd>
<dt>covMat</dt><dd>
<p><code>signature(object = "covQual")</code>: build the covariance matrix
or the cross covariance matrix between two sets of locations for a
<code>covQual</code> object.
</p>
</dd>
<dt>npar</dt><dd>
<p><code>signature(object = "covQual")</code>: returns the number of
parameters.
</p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "covQual")</code>: see <code><a href="#topic+plot+2CcovQual-method">plot,covQual-method</a></code>. </p>
</dd>
<dt>scores</dt><dd>
<p><code>signature(object = "covQual")</code>: return the vector of
scores, i.e. the derivative of the log-likelihood w.r.t. the
parameter vector at the current parameter values.
</p>
</dd>
<dt>simulate</dt><dd>
<p><code>signature(object = "covQual")</code>: simulate <code>nsim</code> paths
from a Gaussian Process having the covariance structure. The paths
are indexed by the finite set of levels of factor inputs, and they
are returned as columns of a matrix.
</p>
</dd>
<dt>varVec</dt><dd>
<p><code>signature(object = "covQual")</code>: build the variance vector
corresponding to a set locations for a <code>covQual</code> object.
</p>
</dd>
</dl>



<h3>Note</h3>

<p>This class is to be regarded as experimental. The slot names or list
may be changed in the future. The methods <code>npar</code>,
<code>inputNames</code> or <code>`inputNames&lt;-`</code> should provide a more
robust access to some slot values.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+covMan-class">covMan</a></code> for a comparable structure dedicated
to kernels with continuous inputs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
showClass("covQual")

</code></pre>

<hr>
<h2 id='covQualNested'>Nested Qualitative Covariance</h2><span id='topic+covQualNested'></span>

<h3>Description</h3>

<p>Nested Qualitative Covariance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
covQualNested(input = "x",
              groupList = NULL,
              group = NULL,
              nestedLevels = NULL,
              between = "Symm",
              within = "Diag",
              covBet = c("corr", "homo", "hete"), 
              covWith = c("corr", "homo", "hete"),
              compGrad = TRUE,
              contrasts = contr.helmod,
              intAsChar = TRUE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covQualNested_+3A_input">input</code></td>
<td>

<p>Name of the input, i.e. name of the column in the
data frame when the covariance kernel is evaluated with the
<code><a href="#topic+covMat+2CcovQual-method">covMat,covQual-method</a></code> method.
</p>
</td></tr>
<tr><td><code id="covQualNested_+3A_grouplist">groupList</code></td>
<td>

<p>A list giving the groups, see <b>Examples</b>. Groups of
size 1 are accepted. Note that the group values should be given in
some order, with no gap between repeated values, see <b>Examples</b>.
</p>
</td></tr>
<tr><td><code id="covQualNested_+3A_group">group</code></td>
<td>

<p>Inactive if <code>groupList</code> is used. 
A factor or vector giving the groups, see <b>Examples</b>. Groups of
size 1 are accepted. Note that the group values should be given in
some order, with no gap between repeated values, see
<b>Examples</b>.
</p>
</td></tr>
<tr><td><code id="covQualNested_+3A_nestedlevels">nestedLevels</code></td>
<td>

<p>Inactive if <code>groupList</code> is used. 
A factor or a vector giving the (nested) levels within the group for
each level of <code>group</code>. If this is missing, each element of
<code>group</code> is assumed to correspond to one nested level within the
group and the levels within the group are taken as integers in the order
of <code>group</code> elements.
</p>
</td></tr>
<tr><td><code id="covQualNested_+3A_between">between</code></td>
<td>

<p>Character giving the type of structure to use for the <em>between</em>
part. For now this can be one of the three choices <code>"Diag"</code>,
the diagonal structure of <code><a href="#topic+q1Diag">q1Diag</a></code>, <code>"Symm"</code> for
the general covariance of <code><a href="#topic+q1Symm">q1Symm</a></code>, or <code>"CompSymm"</code>
for the Compound Symmetry covariance of <code><a href="#topic+q1CompSymm">q1CompSymm</a></code>.
Default is <code>Symm</code>, corresponding to a specific correlation
value for each pair of groups. On the other hand, <code>Diag</code>
corresponds to a common correlation value for all pairs of groups.
</p>
</td></tr>
<tr><td><code id="covQualNested_+3A_within">within</code></td>
<td>

<p>Character vector giving the type of structure to use for the
<em>within</em> part. The choices are the same as for
<code>between</code>. The character vector is recycled to have length
<code class="reqn">G</code> so the <em>within</em> covariances can differ across groups.
Default is <code>"Diag"</code>, corresponding to a compound symmetry matrix.
</p>
</td></tr>
<tr><td><code id="covQualNested_+3A_covbet">covBet</code>, <code id="covQualNested_+3A_covwith">covWith</code></td>
<td>

<p>Character vector indicating the type of covariance matrix to be used
for the generator between- or within- matrices, 
as in <code><a href="#topic+q1Diag">q1Diag</a></code>, <code><a href="#topic+q1Symm">q1Symm</a></code> or <code><a href="#topic+q1CompSymm">q1CompSymm</a></code>:
correlation (&quot;corr&quot;), homoscedastic (&quot;homo&quot;) or heteroscedastic (&quot;hete&quot;).
Partial matching is allowed. 
This is different from the form of the resulting covariance matrix, see section
<b>Caution</b>.
</p>
</td></tr>
<tr><td><code id="covQualNested_+3A_compgrad">compGrad</code></td>
<td>

<p>Logical.
</p>
</td></tr>
<tr><td><code id="covQualNested_+3A_contrasts">contrasts</code></td>
<td>

<p>Object of class <code>"function"</code>. This function is similar to the
<code><a href="stats.html#topic+contr.helmert">contr.helmert</a></code> or
<code><a href="stats.html#topic+contr.treatment">contr.treatment</a></code> functions, but it must return
an <em>orthogonal</em> matrix. For a given integer <code>n</code>, it
returns a matrix with <code>n</code> rows and <code>n - 1</code> columns forming
a basis for the supplementary of a vector of ones in the
<code class="reqn">n</code>-dimensional Euclidean space. The <code><a href="#topic+contr.helmod">contr.helmod</a></code>
can be used to obtain an orthogonal matrix hence defining an
orthonormal basis.
</p>
</td></tr> <tr><td><code id="covQualNested_+3A_intaschar">intAsChar</code></td>
<td>

<p>Logical. If <code>TRUE</code> (default), an integer-valued input will be
coerced into a character. Otherwise, it will be coerced into a
factor.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object with class <code>"covQualNested"</code>.
</p>


<h3>Caution</h3>

<p>When <code>covBet</code> and <code>covWith</code> are zero, the resulting matrix
<em>is not a correlation matrix</em>, due to the mode of
construction. The &quot;between&quot; covariance matrix is a correlation but
diagonal blocks are added to the extended matrix obtained by re-sizing
the &quot;between&quot; covariance into a <code class="reqn">n \times n</code> matrix.
</p>


<h3>Note</h3>

<p>For now the replacement method such as <code>'coef&lt;-'</code> are inherited
from the class <code>covQuall</code>. Consequently when these methods are
used they do not update the covariance structure in the <code>between</code>
slot nor those in the <code>within</code> (list) slot.
</p>
<p>This covariance kernel involves <code>two</code> categorical (i.e. factor)
inputs, but these are nested. It could be aliased in the future as
<code>q1Nested</code> or <code>q2Nested</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Ex 1. See the vignette "groupKernel" for an example 
###       inspired from computer experiments.

### Ex 2. Below an example in data analysis.

country &lt;- c("B", "B", "B", "F", "F" ,"F", "D", "D", "D")
cities &lt;- c("AntWerp", "Ghent" , "Charleroi", "Paris", "Marseille",
            "Lyon", "Berlin", "Hamburg", "Munchen")
myGroupList &lt;- list(B = cities[1:3],
                    F = cities[4:6],
                    D = cities[7:9])

## create a nested covariance. 
# first way, with argument 'groupList':

nest1 &lt;- covQualNested(input = "ccities",
                       groupList = myGroupList,
                       between = "Symm", within = "Diag",
                       compGrad = TRUE,
                       covBet = "corr", covWith = "corr")

# second way, with arguments 'group' and 'nestedLevels'
nest2 &lt;- covQualNested(input = "ccities",
                       group = country, nestedLevels = cities,
                       between = "Symm", within = "Diag",
                       compGrad = TRUE,
                       covBet = "corr", covWith = "corr")


## 'show' and 'plot' method as automatically invocated
nest2
plot(nest2, type = "cor")

## check that the covariance matrices match for nest1 and nest2
max(abs(covMat(nest1) - covMat(nest2)))


## When the groups are not given in order, an error occurs!

countryBad &lt;- c("B", "B", "F", "F", "F", "D", "D", "D", "B")
cities &lt;- c("AntWerp", "Ghent", "Paris", "Marseille", "Lyon",
            "Berlin", "Hamburg", "Munchen", "Charleroi")

nestBad &lt;- try(covQualNested(input = "ccities",
                             group = countryBad, nestedLevels = cities,
                             between = "Symm", within = "Diag",
                             compGrad = TRUE,
                             covBet = "corr", covWith = "corr"))


</code></pre>

<hr>
<h2 id='covQualNested-class'>Class <code>"covQualNested"</code></h2><span id='topic+covQualNested-class'></span>

<h3>Description</h3>

<p>Correlation or covariance structure for qualitative inputs
(i.e. factors) obtained by nesting.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("covQualNested",
    ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>covLevels</code>:</dt><dd>
<p>Object of class <code>"function"</code> computing the covariance matrix
for the set of all levels.
</p>
</dd>
<dt><code>covLevMat</code>:</dt><dd>
<p>Object of class <code>"matrix"</code>. The matrix returned by the
function in slot <code>covLevels</code>. Since this matrix is often
needed, it can be stored rather than recomputed.
</p>
</dd>
<dt><code>hasGrad</code>:</dt><dd>
<p>Object of class <code>"logical"</code>. If <code>TRUE</code>, the analytical
gradient can be computed.
</p>
</dd>
<dt><code>acceptLowerSQRT</code>:</dt><dd>
<p>Object of class <code>"logical"</code>. If <code>TRUE</code>, the lower square
root of the matrix can be returned
</p>
</dd>
<dt><code>label</code>:</dt><dd>
<p>Object of class <code>"character"</code>. A label to describe the
kernel.
</p>
</dd>
<dt><code>d</code>:</dt><dd>
<p>Object of class <code>"integer"</code>. The number of inputs.
</p>
</dd>
<dt><code>inputNames</code>:</dt><dd>
<p>Object of class <code>"character"</code> Names of the inputs.
</p>
</dd>
<dt><code>nlevels</code>:</dt><dd>
<p>Object of class <code>"integer"</code> with length <code>d</code> give the
number of levels for the factors.
</p>
</dd>
<dt><code>levels</code>:</dt><dd>
<p>Object of class <code>"list"</code> with length <code>d</code>. Gives the
levels for the inputs.
</p>
</dd>
<dt><code>parLower</code>:</dt><dd>
<p>Object of class <code>"numeric"</code>. Lower bounds on the (hyper)
parameters.
</p>
</dd>
<dt><code>parUpper</code>:</dt><dd>
<p>Object of class <code>"numeric"</code>. Upper bounds on the (hyper)
parameters.
</p>
</dd>
<dt><code>par</code>:</dt><dd>
<p>Object of class <code>"numeric"</code>. Value of the (hyper) parameters.
</p>
</dd>
<dt><code>parN</code>:</dt><dd>
<p>Object of class <code>"integer"</code>. Number of (hyper) parameters.
</p>
</dd>
<dt><code>kernParNames</code>:</dt><dd>
<p>Object of class <code>"character"</code>. Name of the parameters.
</p>
</dd>
<dt><code>group</code>:</dt><dd>
<p>Object of class <code>"integer"</code>. Group numbers: one for each final
level.
</p>
</dd>
<dt><code>groupLevels</code>:</dt><dd>
<p>Object of class <code>"character"</code>. Vector of labels for the
groups.
</p>
</dd>
<dt><code>between</code>:</dt><dd>
<p>Object of class <code>"covQual"</code>. A covariance or correlation
structure that can be used between groups.
</p>
</dd>
<dt><code>within</code>:</dt><dd>
<p>Object of class <code>"list"</code>. A list of covariance or correlation
structures that are used within the groups. Each item has class
<code>"covQual"</code>.
</p>
</dd>
<dt><code>parNCum</code>:</dt><dd>
<p>Object of class <code>"integer"</code>. Cumulated number of
parameters. Used for technical computations.
</p>
</dd>
<dt><code>contrasts</code>:</dt><dd>
<p>Object of class <code>"function"</code>. A contrast function like
<code>contr.helmod</code>. This function must return a contrast matrix
with columns having unit norm.
</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+covQual-class">covQual</a>"</code>, directly.
Class <code>"<a href="#topic+covAll-class">covAll</a>"</code>, by class &quot;covQual&quot;, distance 2.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;covQualNested&quot; in the signature.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("covQualNested")
</code></pre>

<hr>
<h2 id='covRadial'>Creator for the Class <code>"covRadial"</code></h2><span id='topic+covRadial'></span>

<h3>Description</h3>

<p>Creator for the class <code>"covRadial"</code>, which describes <em>radial
kernels</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
   covRadial(k1Fun1 = k1Fun1Gauss,
             cov = c("corr", "homo"), 
             iso = 0, hasGrad = TRUE,
             inputs = NULL, d = NULL,
             parNames, par = NULL,
             parLower = NULL, parUpper = NULL,
             label = "Radial kernel",
             ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covRadial_+3A_k1fun1">k1Fun1</code></td>
<td>

<p>A function of a <em>scalar</em> numeric variable, and possibly of an
extra &quot;shape&quot; parameter. This function should return the first-order
derivative or the two-first order derivatives as an attribute with
name <code>"der"</code> and with a matrix content. When an extra shape
parameter exists, the gradient should also be returned as an
attribute with name <code>"gradient"</code>, see <b>Examples</b>
later. The name of the function can be given as a character string.
</p>
</td></tr>
<tr><td><code id="covRadial_+3A_cov">cov</code></td>
<td>

<p>A character string specifying the kind of covariance kernel:
correlation kernel (<code>"corr"</code>) or kernel of a homoscedastic GP
(<code>"homo"</code>).  Partial matching is allowed.
</p>
</td></tr>
<tr><td><code id="covRadial_+3A_iso">iso</code></td>
<td>

<p>Integer. The value <code>1L</code> corresponds to an isotropic covariance,
with all the inputs sharing the same range value.
</p>
</td></tr>
<tr><td><code id="covRadial_+3A_hasgrad">hasGrad</code></td>
<td>

<p>Integer or logical. Tells if the value returned by the function
<code>k1Fun1</code> has an attribute named <code>"der"</code> giving the
derivative(s).
</p>
</td></tr>
<tr><td><code id="covRadial_+3A_inputs">inputs</code></td>
<td>

<p>Character. Names of the inputs.
</p>
</td></tr>
<tr><td><code id="covRadial_+3A_d">d</code></td>
<td>

<p>Integer. Number of inputs.
</p>
</td></tr>
<tr><td><code id="covRadial_+3A_par">par</code>, <code id="covRadial_+3A_parlower">parLower</code>, <code id="covRadial_+3A_parupper">parUpper</code></td>
<td>

<p>Optional numeric values for the lower bounds on the parameters. Can be
<code>NA</code> for <code>par</code>, can be <code>-Inf</code> for <code>parLower</code> and
<code>Inf</code> for <code>parUpper</code>.
</p>
</td></tr>
<tr><td><code id="covRadial_+3A_parnames">parNames</code></td>
<td>

<p>Names of the parameters. By default, ranges are prefixed
<code>"theta_"</code> in the non-iso case and the range is named
<code>"theta"</code> in the iso case.
</p>
</td></tr>
<tr><td><code id="covRadial_+3A_label">label</code></td>
<td>

<p>A short description of the kernel object.
</p>
</td></tr>
<tr><td><code id="covRadial_+3A_...">...</code></td>
<td>

<p>Other arguments passed to the method <code>new</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A radial kernel on the <code class="reqn">d</code>-dimensional Euclidean space
takes the form 
</p>
<p style="text-align: center;"><code class="reqn">K(\mathbf{x},\,\mathbf{x}') = \sigma^2 k_1(r)</code>
</p>

<p>where <code class="reqn">k_1(r)</code> is a suitable correlation kernel for a
one-dimensional input, and <code class="reqn">r</code> is given by
</p>
<p style="text-align: center;"><code class="reqn">r = \left\{\sum_{\ell = 1}^d [x_\ell - x'_\ell]^2 / \theta_\ell^2
    \right\}^{1/2}.</code>
</p>

<p>In this default form, the radial kernel depends on <code class="reqn">d + 1</code> parameters:
the <em>ranges</em> <code class="reqn">\theta_\ell &gt;0</code>  and the
variance <code class="reqn">\sigma^2</code>.
</p>
<p>An <em>isotropic</em> form uses the same range <code class="reqn">\theta</code> for
all inputs, i.e. sets <code class="reqn">\theta_\ell =
      \theta</code> for all <code class="reqn">\ell</code>. This is obtained
by using <code>iso = TRUE</code>.
</p>
<p>A <em>correlation</em> version uses <code class="reqn">\sigma^2 = 1</code>. This
is obtained by using <code>cov = "corr"</code>.
</p>
<p>Finally, the correlation kernel <code class="reqn">k_1(r)</code> can depend on a
&quot;shape&quot; parameter, e.g. have the form <code class="reqn">k_1(r;\,\alpha)</code>. The extra shape parameter <code class="reqn">\alpha</code> will be
considered then as a parameter of the resulting radial kernel, making
it possible to estimate it by ML along with the range(s) and the
variance.
</p>


<h3>Value</h3>

<p>An object with class <code>"covRadial"</code>.
</p>


<h3>Note</h3>

<p>When <code>k1Fun1</code> has more than one formal argument, its arguments
with position <code>&gt; 1</code> are assumed to be &quot;shape&quot; parameters of the
model. Examples are functions with formals <code>function(x, shape =
  1.0)</code> or <code>function(x, alpha = 2.0, beta = 3.0)</code>, corresponding to
vector of parameter names <code>c("shape")</code> and <code>c("alpha",
  "beta")</code>.  Using more than one shape parameter has not been tested
yet.
</p>
<p>Remind that using a one-dimensional correlation kernel
<code class="reqn">k_1(r)</code> here <em>does not</em> warrant that a positive
semi-definite kernel will result for <em>any</em> dimension
<code class="reqn">d</code>. This question relates to Schoenberg's theorem and the concept
of completely monotone functions.
</p>


<h3>References</h3>

<p>Gregory Fassauher and Michael McCourt (2016) <em>Kernel-based
Approximation Methods using MATLAB</em>. World Scientific.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+k1Fun1Exp">k1Fun1Exp</a></code>, <code><a href="#topic+k1Fun1Matern3_2">k1Fun1Matern3_2</a></code>,
<code><a href="#topic+k1Fun1Matern5_2">k1Fun1Matern5_2</a></code> or <code><a href="#topic+k1Fun1Gauss">k1Fun1Gauss</a></code> for
examples of functions that can be used as values for the <code>k1Fun1</code>
formal.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
d &lt;- 2; ng &lt;- 20
xg &lt;- seq(from = 0, to = 1, length.out = ng)
X &lt;- as.matrix(expand.grid(x1 = xg, x2 = xg))

## ============================================================================
## A radial kernel using the power-exponential one-dimensional
## function
## ============================================================================

d &lt;- 2
myCovRadial &lt;- covRadial(k1Fun1 = k1Fun1PowExp, d = 2, cov = "homo", iso = 1)
coef(myCovRadial)
inputNames(myCovRadial) &lt;- colnames(X)
coef(myCovRadial) &lt;- c(alpha = 1.8, theta = 2.0, sigma2 = 4.0)
y &lt;- simulate(myCovRadial, X = X, nsim = 1)
persp(x = xg, y = xg, z = matrix(y, nrow = ng))

## ============================================================================
## Define the inverse multiquadric kernel function. We return the first two
## derivatives and the gradient as attributes of the result.
## ============================================================================

myk1Fun &lt;- function(x, beta = 2) {
    prov &lt;- 1 + x * x
    res &lt;- prov^(-beta)
    der &lt;- matrix(NA, nrow = length(x), ncol = 2)
    der[ , 1] &lt;- - beta * 2 * x * res / prov
    der[ , 2] &lt;- -2 * beta * (1 - (1 + 2 * beta) * x * x) * res / prov / prov
    grad &lt;- -log(prov) * res
    attr(res, "gradient") &lt;- grad
    attr(res, "der") &lt;- der
    res
}

myCovRadial1 &lt;- covRadial(k1Fun1 = myk1Fun, d = 2, cov = "homo", iso = 1)
coef(myCovRadial1)
inputNames(myCovRadial1) &lt;- colnames(X)
coef(myCovRadial1) &lt;- c(beta = 0.2, theta = 0.4, sigma2 = 4.0)
y1 &lt;- simulate(myCovRadial1, X = X, nsim = 1)
persp(x = xg, y = xg, z = matrix(y1, nrow = ng))


</code></pre>

<hr>
<h2 id='covRadial-class'>Class <code>"covRadial"</code></h2><span id='topic+covRadial-class'></span><span id='topic+coef+3C-+2CcovRadial+2Cnumeric-method'></span><span id='topic+coefLower+3C-+2CcovRadial-method'></span><span id='topic+coefLower+2CcovRadial-method'></span><span id='topic+coef+2CcovRadial-method'></span><span id='topic+coefUpper+3C-+2CcovRadial-method'></span><span id='topic+coefUpper+2CcovRadial-method'></span><span id='topic+covMat+2CcovRadial-method'></span><span id='topic+npar+2CcovRadial-method'></span><span id='topic+scores+2CcovRadial-method'></span><span id='topic+show+2CcovRadial-method'></span><span id='topic+varVec+2CcovRadial-method'></span>

<h3>Description</h3>

<p>Class of radial covariance kernels.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>covRadial(...)</code>  of
<code>new("covRadial", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>k1Fun1</code>:</dt><dd>
<p>Object of class <code>"function"</code> A function of a scalar numeric
variable. Note that using a one-dimensional kernel here <em>does
not</em> warrant that a positive semi-definite kernel results for any
dimension <code class="reqn">d</code>.
</p>
</dd>
<dt><code>k1Fun1Char</code>:</dt><dd>
<p>Object of class <code>"character"</code> describing the function in the
slot <code>k1Fun1</code>.
</p>
</dd>
<dt><code>hasGrad</code>:</dt><dd>
<p>Object of class <code>"logical"</code>. Tells if the value returned by
the function <code>kern1Fun</code> has an attribute named <code>"der"</code>
giving the derivative(s). 
</p>
</dd>
<dt><code>cov</code>:</dt><dd>
<p>Object of class <code>"integer"</code>. The value <code>0L</code> corresponds
to a correlation kernel while <code>1L</code> is for a covariance
kernel.
</p>
</dd>
<dt><code>iso</code>:</dt><dd>
<p>Object of class <code>"integer"</code>. The value <code>1L</code> corresponds
to an isotropic covariance, with all the inputs sharing the same
range value.
</p>
</dd>
<dt><code>label</code>:</dt><dd>
<p>Object of class <code>"character"</code>. Short description of the
object.
</p>
</dd>
<dt><code>d</code>:</dt><dd>
<p>Object of class <code>"integer"</code>. Dimension, i.e. number of
inputs.
</p>
</dd>
<dt><code>inputNames</code>:</dt><dd>
<p>Object of class <code>"optCharacter"</code>. Names of the inputs.
</p>
</dd>
<dt><code>parLower</code>:</dt><dd>
<p>Object of class <code>"numeric"</code>. Numeric values for the lower
bounds on the parameters. Can be <code>-Inf</code>.
</p>
</dd>
<dt><code>parUpper</code>:</dt><dd>
<p>Object of class <code>"numeric"</code>. Numeric values for the upper
bounds on the parameters. Can be <code>Inf</code>.
</p>
</dd>
<dt><code>par</code>:</dt><dd>
<p>Object of class <code>"numeric"</code>. Numeric values for the
parameters. Can be <code>NA</code>.
</p>
</dd>
<dt><code>parN1</code>:</dt><dd>
<p>Object of class <code>"integer"</code>. Number of parameters of the
function <code>kern1Fun</code> (such as a shape).
</p>
</dd> <dt><code>parN</code>:</dt><dd>
<p>Object of class <code>"integer"</code>. Number of parameters for the
object. The include: <em>direct</em> parameters in the function
<code>kern1Fun</code>, ranges, and variance.
</p>
</dd>
<dt><code>kern1ParNames</code>:</dt><dd>
<p>Object of class <code>"character"</code>. Names of the <em>direct</em>
parameters.
</p>
</dd>
<dt><code>kernParNames</code>:</dt><dd>
<p>Object of class <code>"character"</code>. Names of the parameters.
</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+covAll-class">covAll</a>"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>coef&lt;-</dt><dd>
<p><code>signature(object = "covRadial", value = "numeric")</code>: Set the
vector of values for the parameters.
</p>
</dd>
<dt>coefLower&lt;-</dt><dd>
<p><code>signature(object = "covRadial")</code>: Set the vector of lower
bounds on the parameters. 
</p>
</dd>
<dt>coefLower</dt><dd>
<p><code>signature(object = "covRadial")</code>: Get the vector of
lower bounds on the parameters.
</p>
</dd>
<dt>coef</dt><dd>
<p><code>signature(object = "covRadial")</code>: Get the vector of values
for the parameters.
</p>
</dd>
<dt>coefUpper&lt;-</dt><dd>
<p><code>signature(object = "covRadial")</code>: Set the vector of upper
bounds on the parameters. 
</p>
</dd>
<dt>coefUpper</dt><dd>
<p><code>signature(object = "covRadial")</code>: Get the vector of upper
bounds on the parameters. 
</p>
</dd>
<dt>covMat</dt><dd>
<p><code>signature(object = "covRadial")</code>: Compute the covariance
matrix for given sites.
</p>
</dd>
<dt>npar</dt><dd>
<p><code>signature(object = "covRadial")</code>: Get the number of
parameters.
</p>
</dd>
<dt>scores</dt><dd>
<p><code>signature(object = "covRadial")</code>: Compute the scores
i.e. the derivatives w.r.t. the parameters of the contribution of
the covariance in the log-likelihood of a <code>gp</code>.
</p>
</dd>
<dt>show</dt><dd>
<p><code>signature(object = "covRadial")</code>: Print or show the object.
</p>
</dd>
<dt>varVec</dt><dd>
<p><code>signature(object = "covRadial")</code>: Compute the variance
vector for given sites.
</p>
</dd>
</dl>



<h3>See Also</h3>

<p>The creator function <code><a href="#topic+covRadial">covRadial</a></code>, where some details are
given on the form of kernel.  <code><a href="#topic+covMan">covMan</a></code> and
<code><a href="#topic+covMan-class">covMan</a></code> for a comparable but more general class.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("covRadial")
</code></pre>

<hr>
<h2 id='covTP'>Creator for the Class <code>"covTP"</code></h2><span id='topic+covTP'></span>

<h3>Description</h3>

<p>Creator for the class <code>"covTP"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covTP(k1Fun1 = k1Fun1Gauss,
      cov = c("corr", "homo"),
      iso = 0, iso1 = 1L,
      hasGrad = TRUE,
      inputs = NULL,
      d = NULL,
      parNames,
      par = NULL, parLower = NULL, parUpper = NULL,
      label = "Tensor product kernel",
      ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covTP_+3A_k1fun1">k1Fun1</code></td>
<td>

<p>A kernel function of a <em>scalar</em> numeric variable, and possibly
of an extra &quot;shape&quot; parameter. This function can also return the
first-order derivative or the two-first order derivatives as an
attribute with name <code>"der"</code> and with a matrix content. When an
extra shape parameter exists, the gradient can also be returned
as an attribute with name <code>"gradient"</code>, see <b>Examples</b>
later. The name of the function can be given as a character string.
</p>
</td></tr>
<tr><td><code id="covTP_+3A_cov">cov</code></td>
<td>

<p>A character string specifying the kind of covariance kernel:
correlation kernel (<code>"corr"</code>) or kernel of a homoscedastic GP
(<code>"homo"</code>). Partial matching is allowed.
</p>
</td></tr>
<tr><td><code id="covTP_+3A_iso">iso</code></td>
<td>

<p>Integer. The value <code>1L</code> corresponds to an isotropic covariance,
with all the inputs sharing the same range value.
</p>
</td></tr>
<tr><td><code id="covTP_+3A_iso1">iso1</code></td>
<td>

<p>Integer. This applies only when <code>k1Fun1</code> contains one or more
parameters that can be called 'shape' parameters. At now, only one
such parameter can be found in <code>k1Fun1</code> and consequently
<code>iso1</code> must be of length one. With <code>iso1 = 0</code> the shape
parameter in <code>k1Fun1</code> will generate <code>d</code> parameters in the
<code>covTP</code> object with their name suffixed by the dimension. When
<code>iso1</code> is <code>1</code> only one shape parameter will be created in
the <code>covTP</code> object.
</p>
</td></tr>
<tr><td><code id="covTP_+3A_hasgrad">hasGrad</code></td>
<td>

<p>Integer or logical. Tells if the value returned by the function
<code>k1Fun1</code> has an attribute named <code>"der"</code> giving the
derivative(s).
</p>
</td></tr>
<tr><td><code id="covTP_+3A_inputs">inputs</code></td>
<td>

<p>Character. Names of the inputs.
</p>
</td></tr>
<tr><td><code id="covTP_+3A_d">d</code></td>
<td>

<p>Integer. Number of inputs.
</p>
</td></tr>
<tr><td><code id="covTP_+3A_parnames">parNames</code></td>
<td>

<p>Names of the parameters. By default, ranges are prefixed
<code>"theta_"</code> in the non-iso case and the range is named
<code>"theta"</code> in the iso case.
</p>
</td></tr>
<tr><td><code id="covTP_+3A_par">par</code></td>
<td>

<p>Numeric values for the parameters. Can be <code>NA</code>.
</p>
</td></tr>
<tr><td><code id="covTP_+3A_parlower">parLower</code></td>
<td>

<p>Numeric values for the lower bounds on the parameters. Can be
<code>-Inf</code>.
</p>
</td></tr>
<tr><td><code id="covTP_+3A_parupper">parUpper</code></td>
<td>

<p>Numeric values for the upper bounds on the parameters. Can be
<code>Inf</code>.
</p>
</td></tr>
<tr><td><code id="covTP_+3A_label">label</code></td>
<td>

<p>A short description of the kernel object.
</p>
</td></tr>
<tr><td><code id="covTP_+3A_...">...</code></td>
<td>

<p>Other arguments passed to the method <code>new</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tensor-product kernel on the <code class="reqn">d</code>-dimensional Euclidean space
takes the form </p>
<p style="text-align: center;"><code class="reqn">K(\mathbf{x},\,\mathbf{x}') = \sigma^2
    \prod_{\ell = 1}^d \kappa(r_\ell)</code>
</p>
<p> where <code class="reqn">\kappa(r)</code> is a suitable correlation
kernel for a one-dimensional input, and <code class="reqn">r_\ell</code> is given by
<code class="reqn">r_\ell := [x_\ell - x'_\ell] / \theta_\ell</code> for <code class="reqn">\ell = 1</code> to <code class="reqn">d</code>.
</p>
<p>In this default form, the tensor-product kernel depends on <code class="reqn">d + 1</code>
parameters: the <em>ranges</em> <code class="reqn">\theta_\ell &gt;0</code> and
the variance <code class="reqn">\sigma^2</code>.
</p>
<p>An <em>isotropic</em> form uses the same range <code class="reqn">\theta</code>
for all inputs, i.e. sets <code class="reqn">\theta_\ell =
    \theta</code> for all <code class="reqn">\ell</code>. This is obtained by
using <code>iso = TRUE</code>.
</p>
<p>A <em>correlation</em> version uses <code class="reqn">\sigma^2 = 1</code>. This is obtained by using <code>cov = "corr"</code>.
</p>
<p>Finally, the correlation kernel <code class="reqn">\kappa(r)</code> can depend on
a &quot;shape&quot; parameter, e.g. have the form
<code class="reqn">\kappa(r;\,\alpha)</code>. The extra shape parameter
<code class="reqn">\alpha</code> will be considered then as a parameter of the
resulting tensor-product kernel, making it possible to estimate it
by ML along with the range(s) and the variance.
</p>


<h3>Value</h3>

<p>An object with class <code>"covTP"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (require(DiceKriging)) {
    ## a 16-points factorial design and the corresponding response
    d &lt;- 2; n &lt;- 16; x &lt;- seq(from = 0.0, to = 1.0, length.out = 4)
    X &lt;- expand.grid(x1 = x, x2 = x)
    y &lt;- apply(X, 1, DiceKriging::branin)

    ## kriging model with matern5_2 covariance structure, constant
    ## trend. A crucial point is to set the upper bounds!
    mycov &lt;- covTP(k1Fun1 = k1Fun1Matern5_2, d = 2, cov = "homo")
    coefUpper(mycov) &lt;- c(2.0, 2.0, 1e10)
    mygp &lt;- gp(y ~ 1, data = data.frame(X, y),
               cov = mycov, multistart = 100, noise = FALSE)

    nGrid &lt;- 50; xGrid &lt;- seq(from = 0, to = 1, length.out = nGrid)
    XGrid &lt;- expand.grid(x1 = xGrid, x2 = xGrid)
    yGrid &lt;- apply(XGrid, 1, DiceKriging::branin)
    pgp &lt;- predict(mygp, XGrid)$mean

    mykm &lt;- km(design = X, response = y)
    pkm &lt;- predict(mykm, XGrid, "UK")$mean
    c("km" = sqrt(mean((yGrid - pkm)^2)),
      "gp" = sqrt(mean((yGrid - pgp)^2)))
    
}

## End(Not run)
</code></pre>

<hr>
<h2 id='covTP-class'>Class <code>"covTP"</code></h2><span id='topic+covTP-class'></span><span id='topic+coef+2CcovTP-method'></span><span id='topic+coef+3C-+2CcovTP+2Cnumeric-method'></span><span id='topic+coefLower+2CcovTP-method'></span><span id='topic+coefLower+3C-+2CcovTP-method'></span><span id='topic+coefUpper+2CcovTP-method'></span><span id='topic+coefUpper+3C-+2CcovTP-method'></span><span id='topic+covMat+2CcovTP-method'></span><span id='topic+npar+2CcovTP-method'></span><span id='topic+scores+2CcovTP-method'></span><span id='topic+show+2CcovTP-method'></span><span id='topic+varVec+2CcovTP-method'></span>

<h3>Description</h3>

<p>S4 class representing a Tensor Product (TP) covariance kernel.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("covTP", ...)</code>
or by using the <code><a href="#topic+covTP">covTP</a></code> function.
</p>


<h3>Slots</h3>


<dl>
<dt><code>k1Fun1</code>:</dt><dd>
<p>Object of class <code>"function"</code> A function of a scalar numeric
variable.
</p>
</dd>
<dt><code>k1Fun1Char</code>:</dt><dd>
<p>Object of class <code>"character"</code> describing the function in the
slot <code>k1Fun1</code>.
</p>
</dd>
<dt><code>hasGrad</code>:</dt><dd>
<p>Object of class <code>"logical"</code>. Tells if the value returned by
the function <code>kern1Fun</code> has an attribute named <code>"der"</code>
giving the derivative(s).
</p>
</dd>
<dt><code>cov</code>:</dt><dd>
<p>Object of class <code>"integer"</code>. The value <code>0L</code> corresponds
to a correlation kernel while <code>1L</code> is for a covariance
kernel.
</p>
</dd>
<dt><code>iso</code>:</dt><dd>
<p>Object of class <code>"integer"</code>. The value <code>1L</code> corresponds
to an isotropic covariance, with all the inputs sharing the same
range value.
</p>
</dd>
<dt><code>iso1</code>:</dt><dd>
<p>Object of class <code>"integer"</code> used only when the function in
the slot <code>k1Fun1</code> depends on parameters i.e. has more than
one formal argument. NOT IMPLEMENTED YET.  
</p>
</dd>
<dt><code>label</code>:</dt><dd>
<p>Object of class <code>"character"</code>. Short description of the
object.
</p>
</dd>
<dt><code>d</code>:</dt><dd>
<p>Object of class <code>"integer"</code>. Dimension, i.e. number of
inputs.
</p>
</dd>
<dt><code>inputNames</code>:</dt><dd>
<p>Object of class <code>"optCharacter"</code>. Names of the inputs.
</p>
</dd>
<dt><code>parLower</code>:</dt><dd>
<p>Object of class <code>"numeric"</code>. Numeric values for the lower
bounds on the parameters. Can be <code>-Inf</code>.
</p>
</dd>
<dt><code>parUpper</code>:</dt><dd>
<p>Object of class <code>"numeric"</code>. Numeric values for the upper
bounds on the parameters. Can be <code>Inf</code>.
</p>
</dd>
<dt><code>par</code>:</dt><dd>
<p>Object of class <code>"numeric"</code>. Numeric values for the
parameters. Can be <code>NA</code>.
</p>
</dd>
<dt><code>kern1ParN1</code>:</dt><dd>
<p>Object of class <code>"integer"</code>. The number of parameters in
<code>k1Fun1</code> (such as a shape).
</p>
</dd>
<dt><code>parN1</code>:</dt><dd>
<p>Object of class <code>"integer"</code>. Number of parameters of the
function <code>kern1Fun</code> (such as a shape).
</p>
</dd>
<dt><code>parN</code>:</dt><dd>
<p>Object of class <code>"integer"</code>. Number of parameters for the
object. The include: <em>direct</em> parameters in the function
<code>kern1Fun</code>, ranges, and variance.
</p>
</dd>
<dt><code>kern1ParNames</code>:</dt><dd>
<p>Object of class <code>"character"</code>. Names of the <em>direct</em>
parameters.
</p>
</dd>
<dt><code>kernParNames</code>:</dt><dd>
<p>Object of class <code>"character"</code>. Names of the parameters.
</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+covAll-class">covAll</a>"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>coef</dt><dd>
<p><code>signature(object = "covTP")</code>: Get the vector of values for
the parameters.
</p>
</dd>
<dt>coef&lt;-</dt><dd>
<p><code>signature(object = "covTP", value = "numeric")</code>: Set the
vector of values for the parameters.
</p>
</dd>
<dt>coefLower</dt><dd>
<p><code>signature(object = "covTP")</code>: Get the vector of
lower bounds on the parameters.
</p>
</dd>
<dt>coefLower&lt;-</dt><dd>
<p><code>signature(object = "covTP")</code>: Set the vector of lower
bounds on the parameters.
</p>
</dd>
<dt>coefUpper</dt><dd>
<p><code>signature(object = "covTP")</code>: Get the vector of upper
bounds on the parameters.
</p>
</dd>
<dt>coefUpper&lt;-</dt><dd>
<p><code>signature(object = "covTP")</code>: Set the vector of upper
bounds on the parameters. 
</p>
</dd>
<dt>covMat</dt><dd>
<p><code>signature(object = "covTP")</code>: Compute the covariance
matrix for given sites.
</p>
</dd>
<dt>npar</dt><dd>
<p><code>signature(object = "covTP")</code>: Get the number of
parameters.
</p>
</dd>
<dt>scores</dt><dd>
<p><code>signature(object = "covTP")</code>: Compute the scores
i.e. the derivatives w.r.t. the parameters of the contribution of
the covariance in the log-likelihood of a <code>gp</code>.
</p>
</dd>
<dt>show</dt><dd>
<p><code>signature(object = "covTP")</code>: Print or show the object.
</p>
</dd>
<dt>varVec</dt><dd>
<p><code>signature(object = "covTP")</code>: Compute the variance
vector for given sites.
</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+covRadial-class">covRadial</a></code> which is a similar covariance class and
<code><a href="#topic+covTP">covTP</a></code> which is intended to be the standard creator
function for this class.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("covTP")
</code></pre>

<hr>
<h2 id='covTS'>
Creator Function for <code>covTS</code> Objects
</h2><span id='topic+covTS'></span>

<h3>Description</h3>

<p>Creator function for <code>covTS</code> objects representing a Tensor Sum
covariance kernel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covTS(inputs = paste("x", 1:d, sep = ""),
      d = length(inputs), kernel = "k1Matern5_2",
      dep = NULL, value = NULL, var = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covTS_+3A_inputs">inputs</code></td>
<td>

<p>Character vector giving the names of the inputs used as arguments of
<code>kernel</code>. Optional if <code>d</code> is given.
</p>
</td></tr>
<tr><td><code id="covTS_+3A_d">d</code></td>
<td>
 
<p>Integer specifying the spatial dimension (equal to the number of
inputs). Optional if <code>inputs</code> is given.
</p>
</td></tr>
<tr><td><code id="covTS_+3A_kernel">kernel</code></td>
<td>

<p>Character, name of the one-dimensional kernel.
</p>
</td></tr>
<tr><td><code id="covTS_+3A_dep">dep</code></td>
<td>

<p>Character vector with elements <code>"cst"</code> or <code>"input"</code>
usually built using the concatenation <code><a href="base.html#topic+c">c</a></code>. The names
must correspond to parameters of the kernel specified with
<code>kernel</code>. When an element is <code>"cst"</code>, the corresponding
parameter of the 1d kernel will be the same for all inputs.  When
the element is <code>"input"</code>, the corresponding parameter of the 1d
kernel gives birth to <code>d</code> parameters in the <code>covTS</code>
object, one by input.
</p>
</td></tr>
<tr><td><code id="covTS_+3A_value">value</code></td>
<td>

<p>Named numeric vector. The names must correspond to the 1d kernel
parameters.
</p>
</td></tr>
<tr><td><code id="covTS_+3A_var">var</code></td>
<td>

<p>Numeric vector giving the variances <code class="reqn">\sigma^2_i</code>
that weight the <code class="reqn">d</code> components.
</p>
</td></tr>
<tr><td><code id="covTS_+3A_...">...</code></td>
<td>

<p>Not used at this stage.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code>covTS</code> object represents a <code class="reqn">d</code>-dimensional kernel object
<code class="reqn">K</code> of the form </p>
<p style="text-align: center;"><code class="reqn">K(\mathbf{x}, \mathbf{x}';
  \boldsymbol{\theta}) = \sum_{i=1}^d k(x_i,
  x_i';\boldsymbol{\theta}_{\mathbf{s}_i})</code>
</p>
<p> where <code class="reqn">k</code> is
the covariance kernel for a Gaussian Process <code class="reqn">Y_x</code> indexed by a scalar
<code class="reqn">x</code>. The <code class="reqn">d</code> numbers <code class="reqn">x_i</code> stand for the components of the
<code class="reqn">d</code>-dimensional location vector <code class="reqn">\mathbf{x}</code>. The length
<code class="reqn">p</code> of all the vectors <code class="reqn">\mathbf{s}_i</code> is the number of
parameters of the one-dimensional kernel <code class="reqn">k</code>, i.e. 2 or 3 for
classical covariance kernels.
</p>
<p>The package comes with the following covariance kernels which can
be given as <code>kernel</code> argument.
</p>

<table>
<tr>
 <td style="text-align: left;">

    <em>name</em> </td><td style="text-align: left;"> <em>description</em> </td><td style="text-align: left;"> <code class="reqn">p</code> </td><td style="text-align: left;"> <em>par. names</em> </td>
</tr>
<tr>
 <td style="text-align: left;">

    <code>k1Exp</code> </td><td style="text-align: left;"> exponential </td><td style="text-align: left;"> <code class="reqn">2</code> </td><td style="text-align: left;"> <code>range</code>,
    <code>var</code></td>
</tr>
<tr>
 <td style="text-align: left;">

    <code>k1Matern3_2</code> </td><td style="text-align: left;"> Matérn <code class="reqn">\nu = 3/2</code> </td><td style="text-align: left;"> <code class="reqn">2</code> </td><td style="text-align: left;">
    <code>range</code>, <code>var</code> </td>
</tr>
<tr>
 <td style="text-align: left;">

    <code>k1Matern5_2</code> </td><td style="text-align: left;"> Matérn <code class="reqn">\nu = 5/2</code></td><td style="text-align: left;"> <code class="reqn">2</code> </td><td style="text-align: left;">
    <code>range</code>, <code>var</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> 

    <code>k1PowExp</code> </td><td style="text-align: left;"> power exponential </td><td style="text-align: left;"> <code class="reqn">3</code> </td><td style="text-align: left;"> <code>range</code>,
    <code>shape</code>, <code>var</code> </td>
</tr>
<tr>
 <td style="text-align: left;">

    <code>k1Gauss</code> </td><td style="text-align: left;"> gaussian or "square exponential" </td><td style="text-align: left;"> <code class="reqn">2</code> </td><td style="text-align: left;">
    <code>range</code>, <code>var</code> </td>
</tr>
<tr>
 <td style="text-align: left;">

  </td>
</tr>

</table>

<p>Note that the exponential kernel of <code>k1Exp</code> is identical to the
Matérn kernel for <code class="reqn">\nu = 1/2</code>, and that the three Matérns kernels
provided here for <code class="reqn">\nu = 1/2</code>, <code class="reqn">\nu = 3/2</code> and <code class="reqn">\nu = 5/2</code>
are special cases of Continuous AutoRegressive (CAR) process
covariances, with respective order <code class="reqn">1</code>, <code class="reqn">2</code> and <code class="reqn">3</code>.
</p>


<h3>Value</h3>

<p>An object with S4 class <code>"covTS"</code>.
</p>


<h3>Caution</h3>

<p>The <code class="reqn">1d</code> kernel <code class="reqn">k</code> as given in <code>kernel</code> is always
assumed to have a variance parameter with name <code>var</code>. This
assumption may be relaxed in future versions.
</p>


<h3>Note</h3>

<p>Most arguments receive default values or are recycled if necessary.
</p>


<h3>Author(s)</h3>

<p>Y. Deville, O. Roustant D. Ginsbourger
</p>


<h3>References</h3>

<p>N. Durrande, D. Ginsbourger, and O. Roustant (2012) Additive
&quot;Covariance kernels for high-dimensional Gaussian Process modeling&quot;,
<em>Annales de la Faculté des Sciences de Toulouse</em> 21(3),
pp. 481–499.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>myCov1 &lt;- covTS(kernel = "k1Exp", inputs = c("v1", "v2", "v3"),
                dep = c(range = "input"))
coef(myCov1) &lt;- c(range = c(0.3, 0.7, 0.9), sigma2 = c(2, 2, 8))

myCov1
coef(myCov1)
coef(myCov1, as = "matrix")
coef(myCov1, as = "list")
coef(myCov1, as = "matrix", type = "range")

# with a common range parameter
myCov2 &lt;- covTS(kernel = "k1Exp", inputs = c("v1", "v2", "v3"), 
                dep = c(range = "cst"), value = c(range = 0.7),
                var = c(2, 2, 8))
myCov2

myCov3 &lt;- covTS(d = 3, kernel = "k1PowExp",
                dep = c(range = "cst", shape = "cst"),
                value = c(shape = 1.8, range = 1.1),
                var = c(2, 2, 8))
myCov3
</code></pre>

<hr>
<h2 id='covTS-class'>Class <code>"covTS"</code></h2><span id='topic+covTS-class'></span><span id='topic+coef+3C-+2CcovTS+2Cnumeric-method'></span><span id='topic+coefLower+2CcovTS-method'></span><span id='topic+coefLower+3C-+2CcovTS-method'></span><span id='topic+coefUpper+2CcovTS-method'></span><span id='topic+coefUpper+3C-+2CcovTS-method'></span><span id='topic+kernelName+2CcovTS-method'></span><span id='topic+scores+2CcovTS-method'></span><span id='topic+show+2CcovTS-method'></span>

<h3>Description</h3>

<p>S4 class representing a Tensor Sum (TS) covariance kernel.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by call of the form <code>new("covTS", ...)</code> or
by using the <code><a href="#topic+covTS">covTS</a></code> function.

</p>


<h3>Slots</h3>


<dl>
<dt><code>d</code>:</dt><dd>
<p>Object of class <code>"integer"</code>, the spatial dimension or number
of inputs of the covariance.
</p>
</dd>
<dt><code>inputNames</code>:</dt><dd>
<p>Object of class <code>"character"</code>, vector of input names. Length
<code>d</code>.
</p>
</dd>
<dt><code>kernel</code>:</dt><dd>
<p>Object of class <code>"covMan"</code> representing a 1d kernel.
</p>
</dd>
<dt><code>kernParNames</code>:</dt><dd>
<p>Object of class <code>"character"</code>, name of the kernel (among the
allowed ones).
</p>
</dd>
<dt><code>kernParCodes</code>:</dt><dd>
<p>Object of class <code>"integer"</code>, an integer code stating the
dependence of the parameter to the input.
</p>
</dd>
<dt><code>par</code>:</dt><dd>
<p>Object of class <code>"numeric"</code>, numeric vector of parameter
values.
</p>
</dd>
<dt><code>parN</code>:</dt><dd>
<p>Object of class <code>"integer"</code>, total number of parameters.
</p>
</dd>
<dt><code>parInput</code>:</dt><dd>
<p>Object of class <code>"integer"</code>, the number of the inputs for
each parameter. Same length as <code>par</code>, values between <code>1</code>
and <code>d</code>.
</p>
</dd>
<dt><code>parLower</code>:</dt><dd><p>, </p>
</dd>
<dt><code>parUpper</code>:</dt><dd>
<p>Object of class <code>"numeric"</code> numeric, vector of (possibly
infinite) lower/upper bounds on parameters.
</p>
</dd>
<dt><code>parBlock</code>:</dt><dd>
<p>Object of class <code>"integer"</code>
</p>
</dd>
</dl>



<h3>Methods</h3>




<dl>
<dt>coef</dt><dd>
<p><code>signature(object = "covTS")</code>: extracts the numeric values of
the covariance parameters.


</p>
</dd>
<dt>coef&lt;-</dt><dd>
<p><code>signature(object = "covTS")</code>: replaces the whole vector of
coefficients, as required during ML estimation.
</p>
</dd>
<dt>coefLower</dt><dd>
<p><code>signature(object = "covTS")</code>: extracts the numeric values of
the lower bounds.
</p>
</dd>
<dt>coefLower&lt;-</dt><dd>
<p><code>signature(object = "covTS")</code>: replacement method for lower
bounds on covTS coefficients.
</p>
</dd>
<dt>coefUpper</dt><dd>
<p><code>signature(object = "covTS")</code>: ...
</p>
</dd>
<dt>coefUpper&lt;-</dt><dd>
<p><code>signature(object = "covTS")</code>: replacement method for upper
bounds on covTS coefficients.
</p>
</dd>
<dt>covMat</dt><dd>
<p><code>signature(object = "covTS")</code>: builds the covariance matrix,
or the cross covariance matrix between two sets of locations for a <code>covTS</code> object.
</p>
</dd>
<dt>kernelName</dt><dd>
<p><code>signature(object = "covTS")</code>: return the character value of the kernel name.
</p>
</dd>
<dt>parMap</dt><dd>
<p><code>signature(object = "covTS")</code>: an integer matrix used to map
the <code>covTS</code> parameters on the inputs and kernel parameters
during the computations.
</p>
</dd>
<dt>scores</dt><dd>
<p><code>signature(object = "covTS")</code>: computes the scores.
</p>
</dd>
<dt>show</dt><dd>
<p><code>signature(object = "covTS")</code>: prints in a custom format.
</p>
</dd>
<dt>simulPar</dt><dd>
<p><code>signature(object = "covTS")</code>: simulates random values for
the covariance parameters.
</p>
</dd>
</dl>



<h3>Note</h3>

<p>The names of the methods strive to respect a
<a href="https://en.wikipedia.org/wiki/CamelCase">camelCase</a> naming
convention.
</p>
<p>While the <code>coef&lt;-</code> replacement method is typically intended
for internal use during likelihood maximization, the <code>coefLower&lt;-</code>
and <code>coefUpper&lt;-</code> replacement methods can be used when some
rough information exists on the possible values of the parameters.
</p>


<h3>Author(s)</h3>

<p>Y. Deville, O. Roustant, D. Ginsbourger.
</p>


<h3>See Also</h3>

<p>The <code><a href="#topic+covTS">covTS</a></code> function providing  a creator. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("covTS")
</code></pre>

<hr>
<h2 id='gls'>
Generic Function: Generalized Least Squares Estimation
with a Given Covariance Kernel
</h2><span id='topic+gls'></span>

<h3>Description</h3>

<p>Generic function computing a Generalized Least Squares estimation
with a given covariance kernel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gls(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gls_+3A_object">object</code></td>
<td>

<p>An object representing a covariance kernel.
</p>
</td></tr>
<tr><td><code id="gls_+3A_...">...</code></td>
<td>

<p>Other arguments for methods.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with several elements corresponding to the estimation results.
</p>

<hr>
<h2 id='gls-methods'>
Generalized Least Squares Estimation with a Given Covariance Kernel
</h2><span id='topic+gls+2CcovAll-method'></span><span id='topic+gls-methods'></span>

<h3>Description</h3>

<p>Generalized Least Squares (GLS) estimation for a linear model with
a covariance given by the covariance kernel object. The method gives
auxiliary variables as needed in many algebraic computations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S4 method for signature 'covAll'
gls(object,
    y, X, F = NULL, varNoise = NULL, 
    beta = NULL, checkNames = TRUE,
    ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gls-methods_+3A_object">object</code></td>
<td>

<p>An object with <code>"covAll"</code> class.
</p>
</td></tr>
<tr><td><code id="gls-methods_+3A_y">y</code></td>
<td>

<p>The response vector with length <code class="reqn">n</code>.
</p>
</td></tr>
<tr><td><code id="gls-methods_+3A_x">X</code></td>
<td>

<p>The input (or spatial design) matrix with <code class="reqn">n</code> rows and <code class="reqn">d</code>
columns. This matrix must be compatible with the given covariance
object, see <code><a href="#topic+checkX+2CcovAll+2Cmatrix-method">checkX,covAll,matrix-method</a></code>.
</p>
</td></tr>
<tr><td><code id="gls-methods_+3A_f">F</code></td>
<td>

<p>A trend design matrix with <code class="reqn">n</code> rows and <code class="reqn">p</code> columns. When
<code>F</code> is <code>NULL</code> no trend is used and the response <code>y</code>
is simply a realization of a centered Gaussian Process with covariance kernel given by <code>object</code>.
</p>
</td></tr>
<tr><td><code id="gls-methods_+3A_varnoise">varNoise</code></td>
<td>

<p>A known noise variance. When provided, must be a positive numeric
value.
</p>
</td></tr>
<tr><td><code id="gls-methods_+3A_beta">beta</code></td>
<td>

<p>A known vector of trend parameters. Default is <code>NULL</code>
indicating that the trend parameters must be estimated.
</p>
</td></tr>
<tr><td><code id="gls-methods_+3A_checknames">checkNames</code></td>
<td>

<p>Logical. If <code>TRUE</code> (default), check the compatibility of
<code>X</code> with <code>object</code>, see <code><a href="#topic+checkX">checkX</a></code>.
</p>
</td></tr>
<tr><td><code id="gls-methods_+3A_...">...</code></td>
<td>

<p>not used yet.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are two options: for unknown trend, this is the usual GLS
estimation with given covariance kernel; for a known trend, it returns
the corresponding auxiliary variables (see <code>value</code> below).
</p>


<h3>Value</h3>

<p>A list with several elements.
</p>
<table>
<tr><td><code>betaHat</code></td>
<td>

<p>Vector <code class="reqn">\widehat{\boldsymbol{\beta}}</code> of length <code class="reqn">p</code>
containing the estimated coefficients if <code>beta = NULL</code>, or the
known coefficients <code class="reqn">\boldsymbol{\beta}</code> either.
</p>
</td></tr>
<tr><td><code>L</code></td>
<td>

<p>The (lower) Cholesky root matrix <code class="reqn">\mathbf{L}</code> of the
covariance matrix <code class="reqn">\mathbf{C}</code>. This
matrix has <code class="reqn">n</code> rows and <code class="reqn">n</code> columns and <code class="reqn">\mathbf{C} =
    \mathbf{L} \mathbf{L}^\top</code>.
</p>
</td></tr>
<tr><td><code>eStar</code></td>
<td>

<p>Vector of length <code class="reqn">n</code>: <code class="reqn">\mathbf{e}^\star = \mathbf{L}^{-1}(\mathbf{y} -
    \mathbf{X} \widehat{\boldsymbol{\beta}})</code>.
</p>
</td></tr>
<tr><td><code>Fstar</code></td>
<td>

<p>Matrix <code class="reqn">n \times p</code>:  <code class="reqn">\mathbf{F}^\star :=
    \mathbf{L}^{-1}\mathbf{F}</code>.
</p>
</td></tr> 
<tr><td><code>sseStar</code></td>
<td>

<p>Sum of squared errors:
<code class="reqn">{\mathbf{e}^\star}^\top\mathbf{e}^\star</code>.
</p>
</td></tr>
<tr><td><code>RStar</code></td>
<td>

<p>The 'R' upper triangular <code class="reqn">p \times p</code> matrix in the QR
decomposition of <code>FStar</code>: <code class="reqn">\mathbf{F}^\star =
      \mathbf{Q}\mathbf{R}^\star</code>.
</p>
</td></tr>
</table>
<p>All objects having length <code class="reqn">p</code> or having one of their dimension
equal to <code class="reqn">p</code> will be <code>NULL</code> when <code>F</code> is <code>NULL</code>,
meaning that <code class="reqn">p = 0</code>.
</p>


<h3>Author(s)</h3>

<p>Y. Deville, O. Roustant
</p>


<h3>References</h3>

<p>Kenneth Lange (2010), <em>Numerical Analysis for Statisticians</em> 2nd ed.
pp. 102-103. Springer-Verlag,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a possible 'covTS'
myCov &lt;- covTS(inputs = c("Temp", "Humid"),
               kernel = "k1Matern5_2",
               dep = c(range = "input"),
               value = c(range = 0.4))
d &lt;- myCov@d; n &lt;- 100;
X &lt;- matrix(runif(n*d), nrow = n, ncol = d)
colnames(X) &lt;- inputNames(myCov)
## generate the 'GP part'  
C &lt;- covMat(myCov, X = X)
L &lt;- t(chol(C))
zeta &lt;- L %*% rnorm(n)
## trend matrix 'F' for Ordinary Kriging
F &lt;- matrix(1, nrow = n, ncol = 1)
varNoise &lt;- 0.5
epsilon &lt;- rnorm(n, sd = sqrt(varNoise))
beta &lt;- 10
y &lt;- F %*% beta + zeta + epsilon
fit &lt;- gls(myCov, X = X, y = y, F = F, varNoise = varNoise)

</code></pre>

<hr>
<h2 id='gp'>
Gaussian Process Model
</h2><span id='topic+gp'></span>

<h3>Description</h3>

<p>Gaussian Process model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
gp(formula, data, inputs = inputNames(cov), cov, estim = TRUE, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gp_+3A_formula">formula</code></td>
<td>

<p>A formula with a left-hand side specifying the response name, and the
right-hand side the trend covariates (see examples below). Factors
are not allowed neither as response nor as covariates.
</p>
</td></tr>
<tr><td><code id="gp_+3A_data">data</code></td>
<td>

<p>A data frame containing the response, the inputs specified in
<code>inputs</code>, and all the trend variables required in
<code>formula</code>.
</p>
</td></tr>
<tr><td><code id="gp_+3A_inputs">inputs</code></td>
<td>

<p>A character vector giving the names of the inputs.
</p>
</td></tr>
<tr><td><code id="gp_+3A_cov">cov</code></td>
<td>

<p>A covariance kernel object or call.
</p>
</td></tr>
<tr><td><code id="gp_+3A_estim">estim</code></td>
<td>

<p>Logical. If <code>TRUE</code>, the model parameters are estimated by
Maximum Likelihood. The initial values can then be specified using
the <code>parCovIni</code> and <code>varNoiseIni</code> arguments of
<code><a href="#topic+mle+2CcovAll-method">mle,covAll-method</a></code> passed though <code>dots</code>. If
<code>FALSE</code>, a simple Generalized Least Squares estimation will be
used, see <code><a href="#topic+gls+2CcovAll-method">gls,covAll-method</a></code>. Then the value of
<code>varNoise</code> must be given and passed through <code>dots</code> in case
<code>noise</code> is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="gp_+3A_...">...</code></td>
<td>

<p>Other arguments passed to the estimation method.  This will be the
<code><a href="#topic+mle+2CcovAll-method">mle,covAll-method</a></code> if <code>estim</code> is <code>TRUE</code> or
<code><a href="#topic+gls+2CcovAll-method">gls,covAll-method</a></code> if <code>estim</code> is <code>FALSE</code>. In
the first case, the arguments will typically include
<code>varNoiseIni</code>. In the second case, they will typically include
<code>varNoise</code>. Note that a logical <code>noise</code> can be used in the
<code>"mle"</code> case. In both cases, the arguments <code>y</code>, <code>X</code>,
<code>F</code> can not be used since they are automatically passed.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object which is given the S3 class <code>"gp"</code>. The list content
is very likely to change, and should be used through methods.
</p>


<h3>Note</h3>

<p>When <code>estim</code> is <code>TRUE</code>, the covariance object in <code>cov</code>
is expected to provide a gradient when used to compute a covariance
matrix, since the default value of <code>compGrad</code> it <code>TRUE</code>, 
see <code><a href="#topic+mle+2CcovAll-method">mle,covAll-method</a></code>.  
</p>


<h3>Author(s)</h3>

<p>Y. Deville, D. Ginsbourger, O. Roustant
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mle+2CcovAll-method">mle,covAll-method</a></code> for a detailed example of
maximum-likelihood estimation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## ==================================================================
## Example 1. Data sampled from a GP model with a known covTS object
## ==================================================================
set.seed(1234)
myCov &lt;- covTS(inputs = c("Temp", "Humid"),
               kernel = "k1Matern5_2",
               dep = c(range = "input"),
               value = c(range = 0.4))
## change coefficients (variances)
coef(myCov) &lt;- c(0.5, 0.8, 2, 16)
d &lt;- myCov@d; n &lt;- 20
## design matrix
X &lt;- matrix(runif(n*d), nrow = n, ncol = d)
colnames(X) &lt;- inputNames(myCov)
## generate the GP realization
myGp &lt;- gp(formula = y ~ 1, data = data.frame(y = rep(0, n), X), 
            cov = myCov, estim = FALSE,
            beta = 10, varNoise = 0.05)
y &lt;- simulate(myGp, cond = FALSE)$sim

## parIni: add noise to true parameters
parCovIni &lt;- coef(myCov)
parCovIni[] &lt;- 0.9 * parCovIni[] +  0.1 * runif(length(parCovIni))
coefLower(myCov) &lt;- rep(1e-2, 4)
coefUpper(myCov) &lt;- c(5, 5, 20, 20)
est &lt;- gp(y ~ 1, data = data.frame(y = y, X),
          cov = myCov, 
          noise = TRUE,
          varNoiseLower = 1e-2,
          varNoiseIni = 1.0,
          parCovIni = parCovIni) 
summary(est)
coef(est)

## =======================================================================
## Example 2. Predicting an additive function with an additive GP model
## =======================================================================

## Not run: 
    
    addfun6d &lt;- function(x){
       res &lt;- x[1]^3 + cos(pi * x[2]) + abs(x[3]) * sin(x[3]^2) +
           3 * x[4]^3 + 3 * cos(pi * x[5]) + 3 * abs(x[6]) * sin(x[6]^2)
    }

    ## 'Fit' is for the learning set, 'Val' for the validation set
    set.seed(123)
    nFit &lt;- 50   
    nVal &lt;- 200
    d &lt;- 6 
    inputs &lt;- paste("x", 1L:d, sep = "")

    ## create design matrices with DiceDesign package 
    require(DiceDesign)
    require(DiceKriging)
    set.seed(0)
    dataFitIni &lt;- DiceDesign::lhsDesign(nFit, d)$design 
    dataValIni &lt;- DiceDesign::lhsDesign(nVal, d)$design 
    dataFit &lt;- DiceDesign::maximinSA_LHS(dataFitIni)$design
    dataVal &lt;- DiceDesign::maximinSA_LHS(dataValIni)$design

    colnames(dataFit) &lt;- colnames(dataVal) &lt;- inputs
    testfun &lt;- addfun6d
    dataFit &lt;- data.frame(dataFit, y = apply(dataFit, 1, testfun))
    dataVal &lt;- data.frame(dataVal, y = apply(dataVal, 1, testfun))

    ## Creation of "CovTS" object with one range by input
    myCov &lt;- covTS(inputs = inputs, d = d, kernel = "k1Matern3_2", 
                   dep = c(range = "input"))

    ## Creation of a gp object
    fitgp &lt;- gp(formula = y ~ 1, data = dataFit, 
                cov = myCov, noise = TRUE, 
                parCovIni = rep(1, 2*d),
                parCovLower = c(rep(1e-4, 2*d)),
                parCovUpper = c(rep(5, d), rep(10,d)))
 
    predTS &lt;- predict(fitgp, newdata = as.matrix(dataVal[ , inputs]), type = "UK")$mean

    ## Classical tensor product kernel as a reference for comparison
    fitRef &lt;- DiceKriging::km(formula = ~1,
                              design = dataFit[ , inputs],
                              response = dataFit$y,  covtype="matern3_2")
    predRef &lt;- predict(fitRef,
                       newdata = as.matrix(dataVal[ , inputs]),
                       type = "UK")$mean
    ## Compare TS and Ref
    RMSE &lt;- data.frame(TS = sqrt(mean((dataVal$y - predTS)^2)),
                       Ref = sqrt(mean((dataVal$y - predRef)^2)),
                       row.names = "RMSE")
    print(RMSE)

    Comp &lt;- data.frame(y = dataVal$y, predTS, predRef)
    plot(predRef ~ y, data = Comp, col = "black", pch = 4,
         xlab = "True", ylab = "Predicted",
         main = paste("Prediction on a validation set (nFit = ",
                      nFit, ", nVal = ", nVal, ").", sep = ""))
    points(predTS ~ y, data = Comp, col = "red", pch = 20)
    abline(a = 0, b = 1, col = "blue", lty = "dotted")
    legend("bottomright", pch = c(4, 20), col = c("black", "red"),
           legend = c("Ref", "Tensor Sum"))

## End(Not run)

##=======================================================================
## Example 3: a 'covMan' kernel with 3 implementations
##=======================================================================

d &lt;- 4

## -- Define a 4-dimensional covariance structure with a kernel in R

myGaussFunR &lt;- function(x1, x2, par) { 
    h &lt;- (x1 - x2) / par[1]
    SS2 &lt;- sum(h^2)
    d2 &lt;- exp(-SS2)
    kern &lt;- par[2] * d2
    d1 &lt;- 2 * kern * SS2 / par[1]            
    attr(kern, "gradient") &lt;- c(theta = d1,  sigma2 = d2)
    return(kern)
}

myGaussR &lt;- covMan(kernel = myGaussFunR,
                   hasGrad = TRUE,
                   d = d,
                   parLower = c(theta = 0.0, sigma2 = 0.0),
                   parUpper = c(theta = Inf, sigma2 = Inf),
                   parNames = c("theta", "sigma2"),
                   label = "Gaussian kernel: R implementation")

## -- The same, still in R, but with a kernel admitting matrices as arguments

myGaussFunRVec &lt;- function(x1, x2, par) { 
    # x1, x2 : matrices with same number of columns 'd' (dimension)
    n &lt;- nrow(x1)
    d &lt;- ncol(x1)     
    SS2 &lt;- 0  
    for (j in 1:d){
        Aj &lt;- outer(x1[ , j], x2[ , j], "-")
        Hj2 &lt;- (Aj / par[1])^2
        SS2 &lt;- SS2 + Hj2
    }
    D2 &lt;- exp(-SS2)
    kern &lt;- par[2] * D2
    D1 &lt;- 2 * kern * SS2 / par[1] 
    attr(kern, "gradient") &lt;- list(theta = D1,  sigma2 = D2)
  
    return(kern)
}

myGaussRVec &lt;- covMan(
    kernel = myGaussFunRVec,
    hasGrad = TRUE,
    acceptMatrix = TRUE,
    d = d,
    parLower = c(theta = 0.0, sigma2 = 0.0),
    parUpper = c(theta = Inf, sigma2 = Inf),
    parNames = c("theta", "sigma2"),
    label = "Gaussian kernel: vectorised R implementation"
)

## -- The same, with inlined C code
## (see also another example with Rcpp by typing: ?kergp).

if (require(inline)) {

    kernCode &lt;- "
       SEXP kern, dkern;
       int nprotect = 0, d;
       double SS2 = 0.0, d2, z, *rkern, *rdkern;

       d = LENGTH(x1);
       PROTECT(kern = allocVector(REALSXP, 1)); nprotect++;
       PROTECT(dkern = allocVector(REALSXP, 2)); nprotect++;
       rkern = REAL(kern);
       rdkern = REAL(dkern);

       for (int i = 0; i &lt; d; i++) {
          z = ( REAL(x1)[i] - REAL(x2)[i] ) / REAL(par)[0];
          SS2 += z * z; 
       }

       d2 = exp(-SS2);
       rkern[0] = REAL(par)[1] * d2;
       rdkern[1] =  d2; 
       rdkern[0] =  2 * rkern[0] * SS2 / REAL(par)[0];

       SET_ATTR(kern, install(\"gradient\"), dkern);
       UNPROTECT(nprotect);
       return kern;
   "
    myGaussFunC &lt;- cfunction(sig = signature(x1 = "numeric", x2 = "numeric",
                                          par = "numeric"),
                             body = kernCode)

    myGaussC &lt;- covMan(kernel = myGaussFunC,
                       hasGrad = TRUE,
                       d = d,
                       parLower = c(theta = 0.0, sigma2 = 0.0),
                       parUpper = c(theta = Inf, sigma2 = Inf),
                       parNames = c("theta", "sigma2"),
                       label = "Gaussian kernel: C/inline implementation")

}

## == Simulate data for covMan and trend ==

n &lt;- 100; p &lt;- d + 1
X &lt;- matrix(runif(n * d), nrow = n)
colnames(X) &lt;- inputNames(myGaussRVec)
design &lt;- data.frame(X)
coef(myGaussRVec) &lt;- myPar &lt;- c(theta = 0.5, sigma2 = 2)
myGp &lt;- gp(formula = y ~ 1, data = data.frame(y = rep(0, n), design), 
            cov = myGaussRVec, estim = FALSE,
            beta = 0, varNoise = 1e-8)
y &lt;- simulate(myGp, cond = FALSE)$sim
F &lt;- matrix(runif(n * p), nrow = n, ncol = p)
beta &lt;- (1:p) / p
y &lt;- tcrossprod(F, t(beta)) + y

## == ML estimation. ==
tRVec &lt;- system.time(
    resRVec &lt;- gp(formula = y ~ ., data = data.frame(y = y, design),
                  cov = myGaussRVec,
                  compGrad = TRUE, 
                  parCovIni = c(0.5, 0.5), varNoiseLower = 1e-4,
                  parCovLower = c(1e-5, 1e-5), parCovUpper = c(Inf, Inf))
)

summary(resRVec)
coef(resRVec)
pRVec &lt;- predict(resRVec, newdata = design, type = "UK")    
tAll &lt;- tRVec
coefAll &lt;- coef(resRVec)
## compare time required by the 3 implementations
## Not run: 
    tR &lt;- system.time(
        resR &lt;- gp(formula = y ~ ., data = data.frame(y = y, design),
                   cov = myGaussR,
                   compGrad = TRUE, 
                   parCovIni = c(0.5, 0.5), varNoiseLower = 1e-4,
                   parCovLower = c(1e-5, 1e-5), parCovUpper = c(Inf, Inf))
    )
    tAll &lt;- rbind(tRVec = tAll, tR)
    coefAll &lt;- rbind(coefAll, coef(resR))
    if (require(inline)) {
        tC &lt;- system.time(
            resC &lt;- gp(formula = y ~ ., data = data.frame(y = y, design),
                       cov = myGaussC,
                       compGrad = TRUE, 
                       parCovIni = c(0.5, 0.5), varNoiseLower = 1e-4,
                       parCovLower = c(1e-5, 1e-5), parCovUpper = c(Inf, Inf))
        )
        tAll &lt;- rbind(tAll, tC)
        coefAll &lt;- rbind(coefAll, coef(resC))
    }

## End(Not run)
tAll

## rows must be identical 
coefAll

</code></pre>

<hr>
<h2 id='hasGrad'>
Generic Function: Extract slot hasGrad of a Covariance Kernel
</h2><span id='topic+hasGrad'></span><span id='topic+hasGrad+2CcovAll-method'></span>

<h3>Description</h3>

<p>Generic function returning the slot hasGrad of a Covariance Kernel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
hasGrad(object, ...)

## S4 method for signature 'covAll'
hasGrad(object, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hasGrad_+3A_object">object</code></td>
<td>

<p>A covariance kernel object.
</p>
</td></tr>
<tr><td><code id="hasGrad_+3A_...">...</code></td>
<td>

<p>Other arguments for methods.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical indicating whether the gradient is supplied in <code>object</code> (as indicated in the slot 'hasGrad').
</p>

<hr>
<h2 id='influence.gp'>
Diagnostics for a Gaussian Process Model, Based on Leave-One-Out
</h2><span id='topic+influence.gp'></span>

<h3>Description</h3>

<p>Cross Validation by leave-one-out for a <code>gp</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gp'
influence(model, type = "UK", trend.reestim = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="influence.gp_+3A_model">model</code></td>
<td>

<p>An object of class <code>"gp"</code>.
</p>
</td></tr>
<tr><td><code id="influence.gp_+3A_type">type</code></td>
<td>

<p>Character string corresponding to the GP &quot;kriging&quot; family, to be
chosen between simple kriging (<code>"SK"</code>), or universal kriging
(<code>"UK"</code>).
</p>
</td></tr>
<tr><td><code id="influence.gp_+3A_trend.reestim">trend.reestim</code></td>
<td>

<p>Should the trend be re-estimated when removing an observation?
Default to <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="influence.gp_+3A_...">...</code></td>
<td>

<p>Not used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Leave-one-out (LOO) consists in computing the prediction at a design
point when the corresponding observation is removed from the learning
set (and this, for all design points). A quick version of LOO based on
Dubrule's formula is also implemented; It is limited to 2 cases:
</p>

<ul>
<li><p><code>(type == "SK") &amp; !trend.reestim</code> and
</p>
</li>
<li><p><code>(type == "UK") &amp; trend.reestim</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>A list composed of the following elements, where <em>n</em> is the total
number of observations.
</p>
<table>
<tr><td><code>mean</code></td>
<td>

<p>Vector of length <em>n</em>. The <code class="reqn">i</code>-th element is the kriging
mean (including the trend) at the <code class="reqn">i</code>th observation number when
removing it from the learning set.
</p>
</td></tr>
<tr><td><code>sd</code></td>
<td>

<p>Vector of length <em>n</em>. The <code class="reqn">i</code>-th element is the kriging
standard deviation at the <code class="reqn">i</code>-th observation number when
removing it from the learning set.
</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>Only trend parameters are re-estimated when removing one
observation. When the number <code class="reqn">n</code> of observations is small, the
re-estimated values can be far away from those obtained with the
entire learning set.
</p>


<h3>Author(s)</h3>

<p>O. Roustant, D. Ginsbourger.
</p>


<h3>References</h3>

 
<p>F. Bachoc (2013), &quot;Cross Validation and Maximum Likelihood estimations of
hyper-parameters of Gaussian processes with model
misspecification&quot;. <em>Computational Statistics and Data Analysis</em>,
<b>66</b>, 55-69
<a href="https://www.sciencedirect.com/science/article/pii/S0167947313001187">link</a>

</p>
<p>N.A.C. Cressie (1993), <em>Statistics for spatial data</em>. Wiley series
in probability and mathematical statistics.
</p>
<p>O. Dubrule (1983), &quot;Cross validation of Kriging in a unique
neighborhood&quot;. <em>Mathematical Geology</em>, <b>15</b>, 687-699.
</p>
<p>J.D. Martin and T.W. Simpson (2005), &quot;Use of kriging models to
approximate deterministic computer models&quot;. <em>AIAA Journal</em>,
<b>43</b> no. 4, 853-863.
</p>
<p>M. Schonlau (1997), <em>Computer experiments and global optimization</em>.
Ph.D. thesis, University of Waterloo.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+predict.gp">predict.gp</a></code>,  <code><a href="#topic+plot.gp">plot.gp</a></code> </p>

<hr>
<h2 id='inputNames'>
Generic Function: Names of the Inputs of a Covariance Kernel
</h2><span id='topic+inputNames'></span><span id='topic+inputNames+2CcovAll-method'></span><span id='topic+inputNames+3C-'></span><span id='topic+inputNames+3C-+2CcovAll-method'></span><span id='topic+inputNames+3C-+2CcovAll+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Generic function returning or setting the names of the inputs attached
with a covariance kernel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
inputNames(object, ...)

## S4 replacement method for signature 'covAll'
inputNames(object, ...) &lt;- value

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inputNames_+3A_object">object</code></td>
<td>

<p>A covariance kernel object.
</p>
</td></tr>
<tr><td><code id="inputNames_+3A_value">value</code></td>
<td>

<p>A suitable character vector.
</p>
</td></tr>
<tr><td><code id="inputNames_+3A_...">...</code></td>
<td>

<p>Other arguments for methods.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector with <em>distinct</em> input names that are used
e.g. in prediction.
</p>


<h3>Note</h3>

<p>The input names are usually checked to control that they match the
colnames of a spatial design matrix. They play an important role since
in general the inputs are found among other columns of a data frame,
and their order is not fixed. For instance in a data frame used as
<code>newdata</code> formal in the <code>predict</code> method, the inputs are
generally found at positions which differ from those in the data frame
used at the creation of the object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+checkX">checkX</a></code>
</p>

<hr>
<h2 id='k1Exp'>
Predefined covMan Objects for 1D Kernels
</h2><span id='topic+k1Exp'></span><span id='topic+k1PowExp'></span><span id='topic+k1Gauss'></span><span id='topic+k1Matern3_2'></span><span id='topic+k1Matern5_2'></span>

<h3>Description</h3>

<p>Predefined kernel Objects as <code>covMan</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>k1Exp
k1Matern3_2
k1Matern5_2
k1Gauss
</code></pre>


<h3>Format</h3>

<p>Objects with class <code>"covMan"</code>.
</p>


<h3>Details</h3>

<p>These objects are provided mainly as examples. They are used
<code><a href="#topic+covTS">covTS</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
x &lt;- sort(runif(40))
X &lt;- cbind(x = x)
yExp &lt;- simulate(k1Exp, nsim = 20, X = X)
matplot(X, yExp, type = "l", col = "SpringGreen", ylab = "")
yGauss &lt;- simulate(k1Gauss, nsim = 20, X = X)
matlines(X, yGauss, col = "orangered")
title("Simulated paths from 'k1Exp' (green) and 'k1Gauss' (orange)")

## ============================================================================
## You can build a similar object using a creator of
## 'covMan'. Although the objects 'k1Gauss' and 'myk1Gauss' differ,
## they describe the same mathematical object.
## ============================================================================

myk1Gauss &lt;- kGauss(d = 1)


</code></pre>

<hr>
<h2 id='k1Matern3_2'>
One-Dimensional Classical Covariance Kernel Functions
</h2><span id='topic+k1FunExp'></span><span id='topic+k1FunPowExp'></span><span id='topic+k1FunGauss'></span><span id='topic+k1FunMatern3_2'></span><span id='topic+k1FunMatern5_2'></span><span id='topic+k1Fun1Cos'></span><span id='topic+k1Fun1Exp'></span><span id='topic+k1Fun1PowExp'></span><span id='topic+k1Fun1Gauss'></span><span id='topic+k1Fun1Matern3_2'></span><span id='topic+k1Fun1Matern5_2'></span>

<h3>Description</h3>

<p>One-dimensional classical covariance kernel Functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>k1FunExp(x1, x2, par)
k1FunGauss(x1, x2, par)
k1FunPowExp(x1, x2, par)
k1FunMatern3_2(x1, x2, par)
k1FunMatern5_2(x1, x2, par)

k1Fun1Cos(x)
k1Fun1Exp(x)
k1Fun1Gauss(x)
k1Fun1PowExp(x, alpha = 1.5)
k1Fun1Matern3_2(x)
k1Fun1Matern5_2(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="k1Matern3_2_+3A_x1">x1</code></td>
<td>

<p>First location vector.
</p>
</td></tr>
<tr><td><code id="k1Matern3_2_+3A_x2">x2</code></td>
<td>

<p>Second location vector. Must have the same length as <code>x1</code>. 
</p>
</td></tr>
<tr><td><code id="k1Matern3_2_+3A_x">x</code></td>
<td>

<p>For stationary covariance functions, the vector containing difference
of positions: <code>x = x1 - x2</code>.
</p>
</td></tr>  
<tr><td><code id="k1Matern3_2_+3A_alpha">alpha</code></td>
<td>

<p>Regularity parameter in <code class="reqn">(0, 2]</code> for Power Exponential
covariance function.
</p>
</td></tr>
<tr><td><code id="k1Matern3_2_+3A_par">par</code></td>
<td>

<p>Vector of parameters. The length and the meaning of the elements in
this vector depend on the chosen kernel. The first parameter is the
range parameter (if there is one), the last is the variance. So the
shape parameter of <code>k1FunPowExp</code> is the second one out of the
three parameters.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These kernel functions are described in the Roustant et al (2012),
table 1 p. 8. More details are given in chap. 4 of Rasmussen et al
(2006).
</p>


<h3>Value</h3>

<p>A matrix with a <code>"gradient"</code> attribute. This matrix has <code class="reqn">n_1</code>
rows and <code class="reqn">n_2</code> columns where <code class="reqn">n_1</code> and <code class="reqn">n_2</code> are the
length of <code>x1</code> and <code>x2</code>.  If <code>x1</code> and <code>x2</code> have
length 1, the attribute is a vector of the same length <code class="reqn">p</code> as
<code>par</code> and gives the derivative of the kernel with respect to the
parameters in the same order. If <code>x1</code> or <code>x2</code> have length
<code class="reqn">&gt; 1</code>, the attribute is an array with dimension <code class="reqn">(n_1, n_2,
  p)</code>.
</p>


<h3>Note</h3>

<p>The kernel functions are coded in C through the <code>.Call</code> interface
and are mainly intended for internal use. They are used by the
<code>covTS</code> class.
</p>
<p>Be aware that very few checks are done (length of objects, order of
the parameters, ...).
</p>


<h3>Author(s)</h3>

<p>Oivier Roustant, David Ginsbourger, Yves Deville
</p>


<h3>References</h3>

<p>C.E. Rasmussen and C.K.I. Williams (2006), <em>Gaussian Processes
for Machine Learning</em>, the MIT Press,
<a href="https://doi.org/10.7551/mitpress/3206.001.0001">doi:10.7551/mitpress/3206.001.0001</a>
</p>
<p>O. Roustant, D. Ginsbourger, Y. Deville (2012).
&quot;DiceKriging, DiceOptim: Two R Packages for the Analysis of
Computer Experiments by Kriging-Based Metamodeling and Optimization.&quot;
<em>Journal of Statistical Software</em>, 51(1), 1-55.
<a href="https://doi.org/10.18637/jss.v051.i01">doi:10.18637/jss.v051.i01</a>


</p>


<h3>Examples</h3>

<pre><code class='language-R'>## show the functions
n &lt;- 300
x0 &lt;- 0
x &lt;- seq(from = 0, to = 3, length.out = n)
kExpVal &lt;- k1FunExp(x0, x, par = c(range = 1, var = 2))
kGaussVal &lt;- k1FunGauss(x0, x, par = c(range = 1, var = 2))
kPowExpVal &lt;- k1FunPowExp(x0, x, par = c(range = 1, shape = 1.5, var = 2))
kMatern3_2Val &lt;- k1FunMatern3_2(x0, x, par = c(range = 1, var = 2))
kMatern5_2Val &lt;- k1FunMatern5_2(x0, x, par = c(range = 1, var = 2))
kerns &lt;- cbind(as.vector(kExpVal), as.vector(kGaussVal), as.vector(kPowExpVal),
               as.vector(kMatern3_2Val), as.vector(kMatern5_2Val))
matplot(x, kerns, type = "l", main = "five 'kergp' 1d-kernels", lwd = 2)

## extract gradient
head(attr(kPowExpVal, "gradient"))
</code></pre>

<hr>
<h2 id='kernelName'>
Name of the One-Dimensional Kernel in a Composite Kernel Object
</h2><span id='topic+kernelName'></span>

<h3>Description</h3>

<p>Name of the 1d kernel in a composite kernel object. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernelName(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernelName_+3A_object">object</code></td>
<td>

<p>A covariance kernel.
</p>
</td></tr>
<tr><td><code id="kernelName_+3A_...">...</code></td>
<td>

<p>Arguments for methods.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string giving the kernel name.
</p>

<hr>
<h2 id='kGauss'>
Gauss (Squared-Exponential) Kernel
</h2><span id='topic+kGauss'></span><span id='topic+kSE'></span>

<h3>Description</h3>

<p>Gauss (or squared exponential) covariance function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kGauss(d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kGauss_+3A_d">d</code></td>
<td>

<p>Dimension.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"covMan"</code> with default parameters: 1 for
ranges and variance values.
</p>


<h3>References</h3>

<p>C.E. Rasmussen and C.K.I. Williams (2006), <em>Gaussian Processes
for Machine Learning</em>, the MIT Press,
<a href="https://doi.org/10.7551/mitpress/3206.001.0001">doi:10.7551/mitpress/3206.001.0001</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kGauss()  # default: d = 1, nu = 5/2
myGauss &lt;- kGauss(d = 2)
coef(myGauss) &lt;- c(range = c(2, 5), sigma2 = 0.1)
myGauss
</code></pre>

<hr>
<h2 id='kMatern'>
Matérn Kernels
</h2><span id='topic+kMatern'></span><span id='topic+kExp'></span>

<h3>Description</h3>

<p>Matérn kernels, obtained by plugging the Euclidian norm into a
1-dimensional Matérn function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
   kMatern(d, nu = "5/2")

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kMatern_+3A_d">d</code></td>
<td>

<p>Dimension.
</p>
</td></tr>
<tr><td><code id="kMatern_+3A_nu">nu</code></td>
<td>

<p>Character corresponding to the smoothness parameter <code class="reqn">\nu</code> of
Matérn kernels. At this stage, the possible values are &quot;1/2&quot;
(exponential kernel), &quot;3/2&quot; or &quot;5/2&quot;.  </p>
</td></tr> </table>


<h3>Value</h3>

<p>An object of class <code>"covMan"</code> with default parameters: 1 for
ranges and variance values.
</p>


<h3>Note</h3>

<p>Notice that these kernels are NOT obtained by tensor product.
</p>


<h3>References</h3>

<p>C.E. Rasmussen and C.K.I. Williams (2006), <em>Gaussian Processes
for Machine Learning</em>, the MIT Press,
<a href="https://doi.org/10.7551/mitpress/3206.001.0001">doi:10.7551/mitpress/3206.001.0001</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kMatern()  # default: d = 1, nu = 5/2
kMatern(d = 2)
myMatern &lt;- kMatern(d = 5, nu = "3/2")
coef(myMatern) &lt;- c(range = 1:5, sigma2 = 0.1)
myMatern
try(kMatern(nu = 2))  # error
</code></pre>

<hr>
<h2 id='mle'>
Generic Function: Maximum Likelihood Estimation of a Gaussian Process
Model
</h2><span id='topic+mle'></span>

<h3>Description</h3>

<p>Generic function for the Maximum Likelihood estimation of a Gaussian Process
model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mle(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mle_+3A_object">object</code></td>
<td>

<p>An object representing a covariance kernel.
</p>
</td></tr>
<tr><td><code id="mle_+3A_...">...</code></td>
<td>

<p>Other arguments for methods, typically including a response, a
design, ...
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An estimated model, typically a list. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mle-methods">mle-methods</a></code> for examples.
</p>

<hr>
<h2 id='mle-methods'>
Maximum Likelihood Estimation of Gaussian Process Model Parameters
</h2><span id='topic+mle+2CcovAll-method'></span><span id='topic+mle-methods'></span>

<h3>Description</h3>

<p>Maximum Likelihood estimation of Gaussian Process models which
covariance structure is described in a covariance kernel object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S4 method for signature 'covAll'
mle(object, 
    y, X, F = NULL, beta = NULL,
    parCovIni = coef(object),
    parCovLower = coefLower(object), 
    parCovUpper = coefUpper(object),
    noise = TRUE, varNoiseIni = var(y) / 10,
    varNoiseLower = 0, varNoiseUpper = Inf,
    compGrad = hasGrad(object),
    doOptim = TRUE,
    optimFun = c("nloptr::nloptr", "stats::optim"),
    optimMethod = ifelse(compGrad, "NLOPT_LD_LBFGS", "NLOPT_LN_COBYLA"),
    optimCode = NULL,
    multistart = 1,
    parTrack = FALSE, trace  = 0, checkNames = TRUE,
    ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mle-methods_+3A_object">object</code></td>
<td>

<p>An object representing a covariance kernel.
</p>
</td></tr>
<tr><td><code id="mle-methods_+3A_y">y</code></td>
<td>

<p>Response vector.
</p>
</td></tr>
<tr><td><code id="mle-methods_+3A_x">X</code></td>
<td>

<p>Spatial (or input) design matrix.
</p>
</td></tr> 
<tr><td><code id="mle-methods_+3A_f">F</code></td>
<td>

<p>Trend matrix.
</p>
</td></tr>
<tr><td><code id="mle-methods_+3A_beta">beta</code></td>
<td>

<p>Vector of trend coefficients if known/fixed.
</p>
</td></tr>
<tr><td><code id="mle-methods_+3A_parcovini">parCovIni</code></td>
<td>

<p>Vector with named elements or matrix giving the initial values for the
parameters. See <b>Examples</b>. When this argument is omitted, the
vector of covariance parameters given in <code>object</code> is
used if <code>multistart == 1</code>; If <code>multistart &gt; 1</code>,
a matrix of parameters is simulated by using <code><a href="#topic+simulPar">simulPar</a></code>. 
Remind that you can use the <code>coef</code> and <code>coef&lt;-</code>
methods to get and set this slot of the covariance object.
</p>
</td></tr>
<tr><td><code id="mle-methods_+3A_parcovlower">parCovLower</code></td>
<td>

<p>Lower bounds for the parameters. When this argument is omitted, the
vector of parameters lower bounds in the covariance given in
<code>object</code> is used. You can use <code>coefLower</code> and
<code>coefLower&lt;-</code> methods to get and set this slot of the
covariance object.
</p>
</td></tr>  
<tr><td><code id="mle-methods_+3A_parcovupper">parCovUpper</code></td>
<td>

<p>Upper bounds for the parameters. When this argument is omitted, the
vector of parameters lower bounds in the covariance given in
<code>object</code> is used. You can use <code>coefUpper</code> and
<code>coefUpper&lt;-</code> methods to get and set this slot of the
covariance object.
</p>
</td></tr>
<tr><td><code id="mle-methods_+3A_noise">noise</code></td>
<td>

<p>Logical. Should a noise be added to the error term?
</p>
</td></tr>  
<tr><td><code id="mle-methods_+3A_varnoiseini">varNoiseIni</code></td>
<td>

<p>Initial value for the noise variance.
</p>
</td></tr>  
<tr><td><code id="mle-methods_+3A_varnoiselower">varNoiseLower</code></td>
<td>

<p>Lower bound for the noise variance. Should be <code>&lt;= varNoiseIni</code>.
</p>
</td></tr>  
<tr><td><code id="mle-methods_+3A_varnoiseupper">varNoiseUpper</code></td>
<td>

<p>Upper bound for the noise variance. Should be <code>&gt;= varNoiseIni</code>.
</p>
</td></tr>  




<tr><td><code id="mle-methods_+3A_compgrad">compGrad</code></td>
<td>

<p>Logical: compute and use the analytical gradient in optimization?
This is only possible when <code>object</code> provides the analytical
gradient.

</p>
</td></tr>
<tr><td><code id="mle-methods_+3A_dooptim">doOptim</code></td>
<td>

<p>Logical. If <code>FALSE</code> no optimization is done.
</p>
</td></tr>
<tr><td><code id="mle-methods_+3A_optimfun">optimFun</code></td>
<td>

<p>Function used for optimization. The two pre-defined choices are
<code>nloptr::nloptr</code> (default) and <code>stats::optim</code>, both in
combination with a few specific optimization methods. 
Ignored if <code>optimCode</code> is provided.
</p>
</td></tr>
<tr><td><code id="mle-methods_+3A_optimmethod">optimMethod</code></td>
<td>

<p>Name of the optimization method or algorithm. This is passed as the
<code>"algorithm"</code> element of the <code>opts</code> argument when
<code>nloptr::nloptr</code> is used (default), or to the <code>method</code>
argument when <code>stats::optim</code> is used. When another value of
<code>optimFun</code> is given, the value of <code>optimMethod</code> is
ignored. Ignored if <code>optimCode</code> is provided. Use
<code><a href="#topic+optimMethods">optimMethods</a></code> to obtain the list of usable values.
</p>
</td></tr>
<tr><td><code id="mle-methods_+3A_optimcode">optimCode</code></td>
<td>

<p>An object with class <code>"expression"</code> or <code>"character"</code>
representing a user-written R code to be parsed and performing the
log-likelihood maximization. Notice that this argument will bypass 
<code>optimFun</code> and <code>optimMethod</code>. The expression must define
an object named <code>"opt"</code>, which is either a list containing 
optimization results, either an object inheriting from <code>"try-error"</code> 
to cope with the case where a problem occurred during the optimization. 
</p>
</td></tr>
<tr><td><code id="mle-methods_+3A_multistart">multistart</code></td>
<td>

<p>Number of optimizations to perform from different starting points
(see <code>parCovIni</code>).  Parallel backend is encouraged.
</p>
</td></tr>







<tr><td><code id="mle-methods_+3A_partrack">parTrack</code></td>
<td>

<p>If <code>TRUE</code>, the parameter vectors used during the optimization
are tracked and returned as a matrix.
</p>
</td></tr>
<tr><td><code id="mle-methods_+3A_trace">trace</code></td>
<td>

<p>Integer level of verbosity.
</p>
</td></tr>
<tr><td><code id="mle-methods_+3A_checknames">checkNames</code></td>
<td>

<p>if <code>TRUE</code> (default), check the compatibility of <code>X</code> with
<code>object</code>, see <code><a href="#topic+checkX">checkX</a></code>.
</p>
</td></tr>
<tr><td><code id="mle-methods_+3A_...">...</code></td>
<td>

<p>Further arguments to be passed to the optimization function,
<code><a href="nloptr.html#topic+nloptr">nloptr</a></code> or
<code><a href="stats.html#topic+optim">optim</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The choice of optimization method is as follows.
</p>

<ul>
<li><p> When <code>optimFun</code> is <code>nloptr:nloptr</code>, it is assumed
that we are minimizing the negative log-likelihood <code class="reqn">- \log
    L</code>. Note that both predefined methods
<code>"NLOPT_LD_LBFGS"</code> and <code>"NLOPT_LN_COBYLA"</code> can cope with a
non-finite value of the objective, except for the initial value of
the parameter.  Non-finite values of <code class="reqn">- \log L</code> are
often met in practice during optimization steps. The method
<code>"NLOPT_LD_LBFGS"</code> used when <code>compGrad</code> is <code>TRUE</code>
requires that the gradient is provided by/with the covariance
object. You can try other values of <code>optimMethod</code> corresponding
to the possible choice of the <code>"algorithm"</code> element in the
<code>opts</code> argument of <code>nloptr:nloptr</code>. It may be useful to
give other options in order to control the optimization and its
stopping rule.
</p>
</li>
<li><p> When <code>optimFun</code> is <code>"stats:optim"</code>, it is assumed
that we are maximizing the log-likelihood <code class="reqn">\log L</code>.  We
suggest to use one of the methods <code>"L-BFGS-B"</code> or
<code>"BFGS"</code>.  Notice that <code>control</code> can be provided in
<code>...</code>, but <code>control$fnscale</code> is forced to be <code>- 1</code>,
corresponding to maximization.  Note that <code>"L-BFGS-B"</code> uses box
constraints, but the optimization stops as soon as the
log-likelihood is non-finite or <code>NA</code>. The method <code>"BFGS"</code>
does not use constraints but allows the log-likelihood to be
non-finite or <code>NA</code>. Both methods can be used without gradient
or with gradient if <code>object</code> allows this.
</p>
</li></ul>

<p>The vectors <code>parCovIni</code>, <code>parCovLower</code>, <code>parCovUpper</code>
must have elements corresponding to those of the vector of kernel
parameters given by <code>coef(object)</code>. These vectors should have
suitably named elements.
</p>


<h3>Value</h3>

<p>A list with elements hopefully having understandable names. 
</p>
<table>
<tr><td><code>opt</code></td>
<td>

<p>List of optimization results if it was successful, or an error
object otherwise.
</p>
</td></tr>
<tr><td><code>coef.kernel</code></td>
<td>

<p>The vector of 'kernel' coefficients. This will include one or
several variance parameters.
</p>
</td></tr>
<tr><td><code>coef.trend</code></td>
<td>

<p>Estimate of the vector <code class="reqn">\boldsymbol{\beta}</code> of the trend
coefficients.
</p>
</td></tr>
<tr><td><code>parTracked</code></td>
<td>

<p>A matrix with rows giving the successive iterates during
optimization if the <code>parTrack</code> argument was set to <code>TRUE</code>.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The checks concerning the parameter names, dimensions of provided
objects, ... are not fully implemented yet.
</p>
<p>Using the <code>optimCode</code> possibility requires a bit of programming
effort, although a typical code only contains a few lines.
</p>


<h3>Author(s)</h3>

<p>Y. Deville, O. Roustant
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gp">gp</a></code> for various examples, <code><a href="#topic+optimMethods">optimMethods</a></code>
to see the possible values of the argument <code>optimMethod</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(29770)

##=======================================================================
## Example. A 4-dimensional "covMan" kernel
##=======================================================================
d &lt;- 4
myCovMan &lt;- 
      covMan(
         kernel = function(x1, x2, par) { 
         htilde &lt;- (x1 - x2) / par[1]
         SS2 &lt;- sum(htilde^2)
         d2 &lt;- exp(-SS2)
         kern &lt;- par[2] * d2
         d1 &lt;- 2 * kern * SS2 / par[1]            
         attr(kern, "gradient") &lt;- c(theta = d1,  sigma2 = d2)
         return(kern)
      },
      label = "myGauss",
      hasGrad = TRUE,
      d = 4,    
      parLower = c(theta = 0.0, sigma2 = 0.0),
      parUpper = c(theta = +Inf, sigma2 = +Inf),
      parNames = c("theta", "sigma2"),
      par = c(NA, NA)
      )
kernCode &lt;- "
       SEXP kern, dkern;
       int nprotect = 0, d;
       double SS2 = 0.0, d2, z, *rkern, *rdkern;

       d = LENGTH(x1);
       PROTECT(kern = allocVector(REALSXP, 1)); nprotect++;
       PROTECT(dkern = allocVector(REALSXP, 2)); nprotect++;
       rkern = REAL(kern);
       rdkern = REAL(dkern);

       for (int i = 0; i &lt; d; i++) {
         z = ( REAL(x1)[i] - REAL(x2)[i] ) / REAL(par)[0];
         SS2 += z * z; 
       }

       d2 = exp(-SS2);
       rkern[0] = REAL(par)[1] * d2;
       rdkern[1] =  d2; 
       rdkern[0] =  2 * rkern[0] * SS2 / REAL(par)[0];

       SET_ATTR(kern, install(\"gradient\"), dkern);
       UNPROTECT(nprotect);
       return kern;
     "

## inline the C function into an R function: MUCH MORE EFFICIENT!!!
## Not run: 
require(inline)
kernC &lt;- cfunction(sig = signature(x1 = "numeric", x2 = "numeric",
                                   par = "numeric"),
                    body = kernCode)
myCovMan &lt;- covMan(kernel = kernC, hasGrad = TRUE, label = "myGauss", d = 4,
                   parNames = c("theta", "sigma2"),
                   parLower = c("theta" = 0.0, "sigma2" = 0.0),
                   parUpper = c("theta" = Inf, "sigma2" = Inf))

## End(Not run)

##=======================================================================
## Example (continued). Simulate data for covMan and trend
##=======================================================================
n &lt;- 100; 
X &lt;- matrix(runif(n * d), nrow = n)
colnames(X) &lt;- inputNames(myCovMan)

coef(myCovMan) &lt;- myPar &lt;- c(theta = 0.5, sigma2 = 2)
C &lt;- covMat(object = myCovMan, X = X,
            compGrad = FALSE,  index = 1L)

library(MASS)
set.seed(456)
y &lt;- mvrnorm(mu = rep(0, n), Sigma = C)
p &lt;- rpois(1, lambda = 4)
if (p &gt; 0) {
  F &lt;- matrix(runif(n * p), nrow = n, ncol = p)
  beta &lt;- rnorm(p)
  y &lt;- F %*% beta + y
} else F &lt;- NULL
par &lt;- parCovIni &lt;- c("theta" = 0.6, "sigma2" = 4)

##=======================================================================
## Example (continued). ML estimation. Note the 'partrack' argument
##=======================================================================           
est &lt;- mle(object = myCovMan,
           parCovIni = parCovIni,
           y = y, X = X, F = F,
           parCovLower = c(0.05, 0.05), parCovUpper = c(10, 100),
           parTrack = TRUE, noise = FALSE, checkNames = FALSE)
est$opt$value

## change the (constrained) optimization  method
## Not run: 
est1 &lt;- mle(object = myCovMan,
            parCovIni = parCovIni,
            optimFun = "stats::optim",
            optimMethod = "L-BFGS-B",
            y = y, X = X, F = F,
            parCovLower = c(0.05, 0.05), parCovUpper = c(10, 100),
            parTrack = TRUE, noise = FALSE, checkNames = FALSE)
est1$opt$value

## End(Not run)

##=======================================================================
## Example (continued). Grid for graphical analysis
##=======================================================================
## Not run: 
    theta.grid &lt;- seq(from = 0.1, to = 0.7, by = 0.2)
    sigma2.grid &lt;- seq(from = 0.3, to = 6, by = 0.4)
    par.grid &lt;- expand.grid(theta = theta.grid, sigma2 = sigma2.grid)
    ll &lt;- apply(as.matrix(par.grid), 1, est$logLikFun)
    llmat &lt;- matrix(ll, nrow = length(theta.grid),
                    ncol = length(sigma2.grid))

## End(Not run)                

##=======================================================================
## Example (continued). Explore the surface ?
##=======================================================================
## Not run: 
   require(rgl)
   persp3d(x = theta.grid, y = sigma2.grid, z = ll,
           xlab = "theta", ylab = "sigma2", zlab = "logLik",
           col = "SpringGreen3", alpha = 0.6)

## End(Not run)

##=======================================================================
## Example (continued). Draw a contour plot for the log-lik 
##                        and show iterates
##=======================================================================
## Not run: 
    contour(x = theta.grid, y = sigma2.grid, z = llmat,
            col = "SpringGreen3", xlab = "theta", ylab = "sigma2",
            main = "log-likelihood contours and iterates",
            xlim = range(theta.grid, est$parTracked[ , 1], na.rm = TRUE),
            ylim = range(sigma2.grid, est$parTracked[ , 2], na.rm = TRUE))
    abline(v = est$coef.kernel[1], h = est$coef.kernel[2], lty = "dotted")
    niter &lt;- nrow(est$parTracked)
    points(est$parTracked[1:niter-1, ],
           col = "orangered", bg = "yellow", pch = 21, lwd = 2, type = "o")
    points(est$parTracked[niter, , drop = FALSE],
           col = "blue", bg = "blue", pch = 21, lwd = 2, type = "o", cex = 1.5)
    ann &lt;- seq(from = 1, to = niter, by = 5)
    text(x = est$parTracked[ann, 1], y = est$parTracked[ann, 2],
         labels = ann - 1L, pos = 4, cex = 0.8, col = "orangered")
    points(x = myPar["theta"], y = myPar["sigma2"],
           bg = "Chartreuse3", col = "ForestGreen",
           pch = 22, lwd = 2, cex = 1.4)

    legend("topright", legend = c("optim", "optim (last)", "true"),
           pch = c(21, 21, 22), lwd = c(2, 2, 2), lty = c(1, 1, NA),
           col = c("orangered", "blue", "ForestGreen"),
           pt.bg = c("yellow", "blue", "Chartreuse3"))
 

## End(Not run)
</code></pre>

<hr>
<h2 id='npar'>
Generic function: Number of Free Parameters in a Covariance Kernel
</h2><span id='topic+npar'></span>

<h3>Description</h3>

<p>Generic function returning the number of free parameters in a
covariance kernel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>npar(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="npar_+3A_object">object</code></td>
<td>

<p>A covariance kernel object.
</p>
</td></tr>
<tr><td><code id="npar_+3A_...">...</code></td>
<td>

<p>Other arguments for methods.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of parameters.
</p>

<hr>
<h2 id='npar-methods'>
Number of Parameters for a Covariance Kernel Object
</h2><span id='topic+npar+2CcovMan-method'></span><span id='topic+npar+2CcovTS-method'></span><span id='topic+npar+2CcovMan-method'></span>

<h3>Description</h3>

<p>Number of parameters for a covariance kernel object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S4 method for signature 'covMan'
npar(object, ...)

## S4 method for signature 'covTS'
npar(object, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="npar-methods_+3A_object">object</code></td>
<td>

<p>An object with S4 class corresponding to a covariance kernel.
</p>
</td></tr>
<tr><td><code id="npar-methods_+3A_...">...</code></td>
<td>

<p>Not used yet.
</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>The number of parameters.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+coef">coef</a></code> method
</p>

<hr>
<h2 id='optimMethods'>Optimization Methods (or Algorithms) for the <code>mle</code>
Method</h2><span id='topic+optimMethods'></span>

<h3>Description</h3>

<p>Optimization methods (or algorithms) for the <code>mle</code> method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimMethods(optimMethod = NULL,
             optimFun = c("both", "nloptr::nloptr", "stats::optim"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimMethods_+3A_optimmethod">optimMethod</code></td>
<td>

<p>A character string used to find a method in a possible approximated
fashion, see <b>Examples</b>.
</p>
</td></tr>
<tr><td><code id="optimMethods_+3A_optimfun">optimFun</code></td>
<td>

<p>Value of the corresponding formal argument of the <code>mle</code> method,
or <code>"both"</code>. In the later case the full list of algorithms will
be obtained.
</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>A data frame with four character columns: <code>optimFun</code>,
<code>optimMethod</code>, <code>globLoc</code> and <code>derNo</code>. The column
<code>globLoc</code> indicate whether the method is global (<code>"G"</code>) or
local (<code>"L"</code>). The column <code>derNo</code> indicates whether the
method uses derivatives (<code>D</code>) or not (<code>"N"</code>) or
<em>possibly</em> uses it (<code>"P"</code>). Only methods corresponding the
<code>optimFun = "stats::optim"</code> can have the value <code>"P"</code> for
<code>derNo</code>. The data frame can be zero-row if <code>optimMethod</code> is
given and no method match.
</p>


<h3>Caution</h3>

<p>The optimization method given in the argument
<code>optimMethod</code> of the <code>mle</code> method should be compliant
with the <code>compGrad</code> argument. Only a small number of
possibilities have been tested, including the default values.
</p>


<h3>References</h3>

<p>See <a href="https://nlopt.readthedocs.io/en/latest/">The NLopt website</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mle-methods">mle-methods</a></code>, <code><a href="stats.html#topic+optim">optim</a></code>,
<code><a href="nloptr.html#topic+nloptr">nloptr</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>optimMethods()
optimMethods(optimMethod = "cobyla")
optimMethods(optimMethod = "nelder")
optimMethods(optimMethod = "BFGS")
optimMethods("CMAES")
</code></pre>

<hr>
<h2 id='parMap'>
Generic Function: Map the Parameters of a Composite Covariance
Kernel
</h2><span id='topic+parMap'></span>

<h3>Description</h3>

<p>Map the parameter of a composite covariance kernel on the inputs and
the parameters of the 1d kernel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parMap(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parMap_+3A_object">object</code></td>
<td>

<p>A composite covariance kernel.
</p>
</td></tr>
<tr><td><code id="parMap_+3A_...">...</code></td>
<td>

<p>Arguments for methods.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with one row by input and one column for each of the
parameters of the 1d kernel.
</p>

<hr>
<h2 id='parMap-methods'>
Map the Parameters of a Structure on the Inputs and Kernel Parameters
</h2><span id='topic+parMap+2CcovTS-method'></span>

<h3>Description</h3>

<p>Map the parameters of a structure on the inputs and kernel parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'covTS'
parMap(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parMap-methods_+3A_object">object</code></td>
<td>

<p>An object with class <code>"covTS"</code>.
</p>
</td></tr>
<tr><td><code id="parMap-methods_+3A_...">...</code></td>
<td>

<p>Not used yet.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with integer values. The rows correspond to the inputs of the
object and the columns to the <code class="reqn">1d</code> kernel parameters.
The matrix element is the number of the corresponding official
coefficient. The same parameter of the structure can be used for
several inputs but not (yet) for several kernel parameters. So
each row must have different integer elements, while the same
element can be repeated within a column.
</p>


<h3>Note</h3>

<p>This function is for internal use only.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>myCov &lt;- covTS(d = 3, kernel = "k1Gauss",
               dep = c(range = "input"), value = c(range = 1.1))
parMap(myCov)
</code></pre>

<hr>
<h2 id='parNamesSymm'>Vector of Names for the General 'Symm' Parameterisation</h2><span id='topic+parNamesSymm'></span>

<h3>Description</h3>

<p>Vector of names for the general 'Symm' parameterisation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parNamesSymm(nlev)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parNamesSymm_+3A_nlev">nlev</code></td>
<td>
<p>Number of levels.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector of names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parNamesSymm(nlev = 4)
</code></pre>

<hr>
<h2 id='parseCovFormula'>Parse a Formula or Expression Describing a Composite
Covariance Kernel</h2><span id='topic+parseCovFormula'></span>

<h3>Description</h3>

<p>Parse a formula (or expression) describing a composite covariance
kernel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parseCovFormula(formula, where = .GlobalEnv, trace = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parseCovFormula_+3A_formula">formula</code></td>
<td>
<p>A formula or expression describing a covariance
kernel. See <b>Examples</b>.</p>
</td></tr>
<tr><td><code id="parseCovFormula_+3A_where">where</code></td>
<td>
<p>An environment where kernel objects and top
parameters are searched for.</p>
</td></tr>
<tr><td><code id="parseCovFormula_+3A_trace">trace</code></td>
<td>
<p>Integer level of verbosity.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The formula involves existing covariance kernel objects and must
define a valid kernel composition rule. For instance the sum and
the product of kernels, the convex combination of kernels are
classically used. The kernels objects are used in the formula with
parentheses as is they where functions calls with no formal
arguments e.g. <code>obj( )</code>. Non-kernel objects used in the
formula must be numeric scalar parameters and are called <em>top</em>
parameters. The covariance objects must exist in the environment
defined by <code>where</code> because their slots will be used to
identify the inputs and the parameters of the composite kernel
defined by the formula.
</p>


<h3>Value</h3>

<p>A list with the results of parsing. Although the results
content is easy to understand, the function is not intended to be
used by the final user, and the results may change in future
versions.
</p>


<h3>Caution</h3>

<p>Only relatively simple formulas are correctly
parsed. So use only formulas having a structure similar to one of
those given in the examples. In case of problems, error messages
are likely to be difficult to understand.
</p>


<h3>Note</h3>

<p>The parsing separates covariance objects from top
parameters.  It retrieves information about the kernel inputs and
parameters from the slots. Obviously, any change in the
covariances objects after the parsing (e.g. change in the
parameters names or values) will not be reported in the results of
the parsing, so kernel any needed customization must be done prior
to the parsing.
</p>


<h3>Author(s)</h3>

<p>Yves Deville
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## =========================================================================
## build some kernels (with their inputNames) in the global environment
## =========================================================================

myCovExp3 &lt;- kMatern(d = 3, nu = "1/2")
inputNames(myCovExp3) &lt;- c("x", "y", "z")

myCovGauss2 &lt;- kGauss(d = 2)
inputNames(myCovGauss2) &lt;- c("temp1", "temp2")

k &lt;- kMatern(d = 1)
inputNames(k) &lt;- "x"

ell &lt;- kMatern(d = 1)
inputNames(ell) &lt;- "y"

## =========================================================================
## Parse a formula. This formula is stupid because 'myCovGauss2'
## and 'myCovExp3' should be CORRELATION kernels and not
## covariance kernels to produce an identifiable model.
## =========================================================================

cov &lt;- ~ tau2 * myCovGauss2() * myCovExp3() + sigma2 * k()
pf &lt;- parseCovFormula(cov, trace = 1)

## =========================================================================
## Parse a formula with ANOVA composition
## =========================================================================

cov1 &lt;- ~ tau2 * myCovGauss2() * myCovExp3() + sigma2 * (1 + k()) * (1 + ell())
pf1 &lt;- parseCovFormula(cov1, trace = 1) 

</code></pre>

<hr>
<h2 id='plot'>
Plot for a qualitative input
</h2><span id='topic+plot'></span><span id='topic+plot.covQual'></span><span id='topic+plot+2CcovQual-method'></span><span id='topic+plot+2CcovQual+2CANY-method'></span>

<h3>Description</h3>

<p>Plots of the covariance matrix or the correlation matrix of a qualitative input. 
For an ordinal factor, the warping function can also be plotted. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'covQual'
plot(x, y, type = c("cov", "cor", "warping"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_+3A_x">x</code></td>
<td>
<p> An object of class <code><a href="#topic+covQual-class">covQual-class</a></code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_y">y</code></td>
<td>
<p> Not used.</p>
</td></tr>
<tr><td><code id="plot_+3A_type">type</code></td>
<td>
<p> A character indicating the desired type of plot. Type <code>warping</code> only works for an ordinal input.</p>
</td></tr>
<tr><td><code id="plot_+3A_...">...</code></td>
<td>
<p> Other arguments passed to <code>corrplot::corrplot</code> or <code>plot</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Covariance / correlation plots are done with package <code>corrplot</code> if loaded, or <code>lattice</code> else.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+covOrd">covOrd</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>u &lt;- ordered(1:6, levels = letters[1:6])

myCov2 &lt;- covOrd(ordered = u, k1Fun1 = k1Fun1Cos, warpFun = "norm")
coef(myCov2) &lt;- c(mean = 0.5, sd = 0.05, theta = 0.1) 

plot(myCov2, type = "cor", method = "ellipse")
plot(myCov2, type = "warp", col = "blue", lwd = 2)
</code></pre>

<hr>
<h2 id='plot.gp'>
Diagnostic Plot for the Validation of a <code>gp</code> Object
</h2><span id='topic+plot.gp'></span>

<h3>Description</h3>

<p>Three plots are currently available, based on the <code>influence</code>
results: one plot of fitted values against response values, one plot
of standardized residuals, and one qqplot of standardized residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gp'
plot(x, y, kriging.type = "UK",
    trend.reestim = TRUE, which = 1:3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.gp_+3A_x">x</code></td>
<td>

<p>An object with S3 class <code>"gp"</code>.
</p>
</td></tr>
<tr><td><code id="plot.gp_+3A_y">y</code></td>
<td>

<p>Not used.
</p>
</td></tr>
<tr><td><code id="plot.gp_+3A_kriging.type">kriging.type</code></td>
<td>

<p>Optional character string corresponding to the GP &quot;kriging&quot; family,
to be chosen between simple kriging (<code>"SK"</code>) or universal
kriging (<code>"UK"</code>).
</p>
</td></tr>
<tr><td><code id="plot.gp_+3A_trend.reestim">trend.reestim</code></td>
<td>

<p>Should the trend be re-estimated when removing an observation?
Default to <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="plot.gp_+3A_which">which</code></td>
<td>

<p>A subset of <code class="reqn">\{1, 2, 3\}</code> indicating which figures to plot (see
<code>Description</code> above). Default is 1:3 (all figures).
</p>
</td></tr><tr><td><code id="plot.gp_+3A_...">...</code></td>
<td>

<p>No other argument for this method.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The standardized residuals are defined by <code class="reqn">[y(\mathbf{x}_i) -
  \widehat{y}_{-i}(\mathbf{x}_i)] /
  \widehat{\sigma}_{-i}(\mathbf{x}_i)</code>, where <code class="reqn">y(\mathbf{x}_i)</code> is the response at the
location <code class="reqn">\mathbf{x}_i</code>,
<code class="reqn">\widehat{y}_{-i}(\mathbf{x}_i)</code> is the fitted
value when the <code class="reqn">i</code>-th observation is omitted (see
<code><a href="#topic+influence.gp">influence.gp</a></code>), and
<code class="reqn">\widehat{\sigma}_{-i}(\mathbf{x}_i)</code> is the
corresponding kriging standard deviation.
</p>


<h3>Value</h3>

<p>A list composed of the following elements where <em>n</em> is the total
number of observations.
</p>
<table>
<tr><td><code>mean</code></td>
<td>

<p>A vector of length <em>n</em>. The <code class="reqn">i</code>-th element is the kriging
mean (including the trend) at the <code class="reqn">i</code>-th observation number when
removing it from the learning set.
</p>
</td></tr>
<tr><td><code>sd</code></td>
<td>

<p>A vector of length <em>n</em>. The <code class="reqn">i</code>-th element is the kriging
standard deviation at the <code class="reqn">i</code>-th observation number when removing it
from the learning set.
</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>Only trend parameters are re-estimated when removing one
observation. When the number <code class="reqn">n</code> of observations is small,
re-estimated values can substantially differ from those obtained with
the whole learning set.
</p>


<h3>References</h3>

 
<p>F. Bachoc (2013), &quot;Cross Validation and Maximum Likelihood estimations of
hyper-parameters of Gaussian processes with model
misspecification&quot;. <em>Computational Statistics and Data Analysis</em>,
<b>66</b>, 55-69.
</p>
<p>N.A.C. Cressie (1993), <em>Statistics for spatial data</em>. Wiley series
in probability and mathematical statistics.
</p>
<p>O. Dubrule (1983), &quot;Cross validation of Kriging in a unique
neighborhood&quot;. <em>Mathematical Geology</em>, <b>15</b>, 687-699.
</p>
<p>J.D. Martin and T.W. Simpson (2005), &quot;Use of kriging models to
approximate deterministic computer models&quot;. <em>AIAA Journal</em>,
<b>43</b> no. 4, 853-863.
</p>
<p>M. Schonlau (1997), <em>Computer experiments and global optimization</em>.
Ph.D. thesis, University of Waterloo.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.gp">predict.gp</a></code> and <code><a href="#topic+influence.gp">influence.gp</a></code>, the
<code>predict</code> and <code>influence</code> methods for <code>"gp"</code>.
</p>

<hr>
<h2 id='plot.simulate.gp'>
Plot Simulations from a <code>gp</code> Object
</h2><span id='topic+plot.simulate.gp'></span>

<h3>Description</h3>

<p>Function to plot simulations from a <code>gp</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'simulate.gp'
plot(x, y,
        col = list(sim = "SpringGreen3", trend = "orangered"),
        show = c(sim = TRUE, trend = TRUE, y = TRUE),
        ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.simulate.gp_+3A_x">x</code></td>
<td>

<p>An object containing simulations, produced by 'simulate' with
<code>output = "list"</code>.
</p>
</td></tr>
<tr><td><code id="plot.simulate.gp_+3A_y">y</code></td>
<td>

<p>Not used yet.
</p>
</td></tr>
<tr><td><code id="plot.simulate.gp_+3A_col">col</code></td>
<td>

<p>Named list of colors to be used, with elements <code>"sim"</code> and
<code>"trend"</code>.
</p>
</td></tr>
<tr><td><code id="plot.simulate.gp_+3A_show">show</code></td>
<td>

<p>A logical vector telling which elements must be shown.
</p>
</td></tr>
<tr><td><code id="plot.simulate.gp_+3A_...">...</code></td>
<td>

<p>Further argument passed to <code>plot</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing.
</p>


<h3>Note</h3>

<p>For now, this function can be used only when the number of inputs is
one.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate.gp">simulate.gp</a></code>.
</p>

<hr>
<h2 id='predict.gp'>
Prediction Method for the <code>"gp"</code> S3 Class
</h2><span id='topic+predict.gp'></span>

<h3>Description</h3>

<p>Prediction method for the <code>"gp"</code> S3 class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'gp'
predict(object, newdata,
        type = ifelse(object$trendKnown, "SK", "UK"), 
        seCompute = TRUE, covCompute = FALSE,
        lightReturn = FALSE, biasCorrect = FALSE,
        forceInterp,        
        ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.gp_+3A_object">object</code></td>
<td>

<p>An object with S3 class <code>"gp"</code>.
</p>
</td></tr>
<tr><td><code id="predict.gp_+3A_newdata">newdata</code></td>
<td>

<p>A data frame containing all the variables required for prediction: inputs and trend variables, if applicable.
</p>
</td></tr>
<tr><td><code id="predict.gp_+3A_type">type</code></td>
<td>

<p>A character string corresponding to the GP &quot;kriging&quot; family, to be chosen between simple kriging (<code>"SK"</code>), or universal kriging
(<code>"UK"</code>).
</p>
</td></tr>
<tr><td><code id="predict.gp_+3A_secompute">seCompute</code></td>
<td>

<p>Optional logical. If <code>FALSE</code>, only the kriging mean is computed.  If <code>TRUE</code>, the kriging variance (actually, the corresponding standard deviation) and prediction intervals are computed too.
</p>
</td></tr>
<tr><td><code id="predict.gp_+3A_covcompute">covCompute</code></td>
<td>

<p>Logical. If <code>TRUE</code> the covariance matrix is computed.
</p>
</td></tr>
<tr><td><code id="predict.gp_+3A_lightreturn">lightReturn</code></td>
<td>

<p>Optional logical. If <code>TRUE</code>, <code>c</code> and <code>cStar</code> are
not returned. This should be reserved to expert users who want to
save memory and know that they will not miss these values.
</p>
</td></tr>
<tr><td><code id="predict.gp_+3A_biascorrect">biasCorrect</code></td>
<td>

<p>Optional logical to correct bias in the UK variance and
covariances. Default is <code>FALSE</code>. See <b>Details</b>
below.
</p>
</td></tr>
<tr><td><code id="predict.gp_+3A_forceinterp">forceInterp</code></td>
<td>

<p>Logical used to force a nugget-type prediction. If <code>TRUE</code>,
the noise will be interpreted as a nugget effect. <em>This argument
is likely to be removed in the future</em>.
</p>
</td></tr>
<tr><td><code id="predict.gp_+3A_...">...</code></td>
<td>

<p>Not used yet.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The estimated (UK) variance and covariances are NOT multiplied by
<code class="reqn">n/(n-p)</code> by default (<code class="reqn">n</code> and <code class="reqn">p</code> denoting the number of
rows and columns of the trend matrix <code class="reqn">\mathbf{F}</code>). Recall that
this correction would contribute to limit bias: it would totally
remove it if the correlation parameters were known (which is not the
case here). However, this correction is often ignored in the context
of computer experiments, especially in adaptive strategies. It can be
activated by turning <code>biasCorrect</code> to <code>TRUE</code>, when
<code>type = "UK"</code>
</p>


<h3>Value</h3>

<p>A list with the following elements.
</p>
<table>
<tr><td><code>mean</code></td>
<td>

<p>GP mean (&quot;kriging&quot;) predictor (including the trend) computed at
<code>newdata</code>.
</p>
</td></tr>
<tr><td><code>sd</code></td>
<td>

<p>GP prediction (&quot;kriging&quot;) standard deviation computed at
<code>newdata</code>. Not computed if <code>seCompute</code> is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code>sdSK</code></td>
<td>

<p>Part of the above standard deviation corresponding to simple kriging
(coincides with <code>sd</code> when <code>type = "SK"</code>). Not computed if
<code>seCompute</code> is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code>trend</code></td>
<td>

<p>The computed trend function, evaluated at <code>newdata</code>.
</p>
</td></tr>
<tr><td><code>cov</code></td>
<td>

<p>GP prediction (&quot;kriging&quot;) conditional covariance matrix. Not
computed if <code>covCompute</code> is <code>FALSE</code> (default).
</p>
</td></tr>
<tr><td><code>lower95</code></td>
<td>
 </td></tr>
<tr><td><code>upper95</code></td>
<td>

<p>Bounds of the 95 % GP prediction interval computed at
<code>newdata</code> (to be interpreted with special care when parameters
are estimated, see description above). Not computed if
<code>seCompute</code> is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code>c</code></td>
<td>

<p>An auxiliary matrix <code class="reqn">\mathbf{c}</code>, containing all the
covariances between the points in <code>newdata</code> and those in the
initial design. Not returned if <code>lightReturn</code> is
<code>TRUE</code>.
</p>
</td></tr>
<tr><td><code>cStar</code></td>
<td>

<p>An auxiliary vector, equal to <code class="reqn">\mathbf{L}^{-1}\mathbf{c}</code> where <code class="reqn">\mathbf{L}</code> is the Cholesky root of the
covariance matrix <code class="reqn">\mathbf{C}</code> used in the estimation. Not
returned if <code>lightReturn</code> is <code>TRUE</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>O. Roustant, D. Ginsbourger, Y. Deville
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gp">gp</a></code> for the creation/estimation of a model. See
<code><a href="#topic+gls-methods">gls-methods</a></code> for the signification of the auxiliary variables.</p>

<hr>
<h2 id='prinKrige'>
Principal Kriging Functions
</h2><span id='topic+prinKrige'></span>

<h3>Description</h3>

<p>Principal Kriging Functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
prinKrige(object)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prinKrige_+3A_object">object</code></td>
<td>
<p>An object with class <code>"gp"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Principal Kriging Functions (PKF) are the eigenvectors of a
symmetric positive matrix <code class="reqn">\mathbf{B}</code> named the <em>Bending
Energy Matrix</em> which is met when combining a linear trend and a
covariance kernel as done in <code><a href="#topic+gp">gp</a></code>. This matrix has
dimension <code class="reqn">n \times n</code> and rank <code class="reqn">n - p</code>. The PKF are
given in the <em>ascending</em> order of the eigenvalues <code class="reqn">e_i</code>
</p>
<p style="text-align: center;"><code class="reqn">e_1 = e_2 = \dots = e_p = 0 &lt; e_{p+1} \leq e_{p+2} \leq \dots
  \leq e_n.</code>
</p>
<p> The <code class="reqn">p</code> first PKF generate the same space as do the
<code class="reqn">p</code> columns of the trend matrix <code class="reqn">\mathbf{F}</code>, say
<code class="reqn">\textrm{colspan}(\mathbf{F})</code>. The following
<code class="reqn">n-p</code> PKFs generate a supplementary of the subspace
<code class="reqn">\textrm{colspan}(\mathbf{F})</code>, and they have a decreasing
influence on the response. So the <code class="reqn">p +1</code>-th PKF can give a hint on
a possible deterministic trend functions that could be added to the
<code class="reqn">p</code> existing ones.
</p>
<p>The matrix <code class="reqn">\mathbf{B}</code> is such that <code class="reqn">\mathbf{B} \mathbf{F}
    = \mathbf{0}</code>, so the columns of <code class="reqn">\mathbf{F}</code> can be
thought of as the eigenvectors that are associated with the zero
eigenvalues <code class="reqn">e_1</code>, <code class="reqn">\dots</code>, <code class="reqn">e_p</code>.
</p>


<h3>Value</h3>

<p>A list 
</p>
<table>
<tr><td><code>values</code></td>
<td>

<p>The eigenvalues of the energy bending matrix in <em>ascending</em>
order. The first <code class="reqn">p</code> values must be very close to zero, but
will not be zero since they are provided by numerical linear
algebra.
</p>
</td></tr>
<tr><td><code>vectors</code></td>
<td>

<p>A matrix <code class="reqn">\mathbf{U}</code> with its columns
<code class="reqn">\mathbf{u}_i</code> equal to the eigenvectors of the
energy bending matrix, in correspondence with the eigenvalues
<code class="reqn">e_i</code>.
</p>
</td></tr>
<tr><td><code>B</code></td>
<td>

<p>The Energy Bending Matrix <code class="reqn">\mathbf{B}</code>. Remind that the
eigenvectors are used here in the ascending order of the
eigenvalues, which is the reverse of the usual order.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>When an eigenvalue <code class="reqn">e_i</code> is such that <code class="reqn">e_{i-1} &lt; e_i &lt;
    e_{i+1}</code> (which can happen only for <code class="reqn">i &gt;
    p</code>), the corresponding PKF is unique up to a change of sign. However a
run of <code class="reqn">r &gt; 1</code> identical eigenvalues is associated with a
<code class="reqn">r</code>-dimensional eigenspace and the corresponding PKFs have no
meaning when they are considered individually.
</p>


<h3>References</h3>

<p>Sahu S.K. and Mardia K.V. (2003).  A Bayesian kriged Kalman
model for short-term forecasting of air pollution levels.
<em>Appl. Statist.</em> 54 (1), pp. 223-244.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(kergp)
set.seed(314159)
n &lt;- 100
x &lt;- sort(runif(n))
y &lt;- 2 + 4 * x  + 2 * x^2 + 3 * sin(6 * pi * x ) + 1.0 * rnorm(n)
nNew &lt;- 60; xNew &lt;- sort(runif(nNew))
df &lt;- data.frame(x = x, y = y)

##-------------------------------------------------------------------------
## use a Matern 3/2 covariance and a mispecified trend. We should guess
## that it lacks a mainily linear and slightly quadratic part.
##-------------------------------------------------------------------------

myKern &lt;- k1Matern3_2
inputNames(myKern) &lt;- "x"
mygp &lt;- gp(formula = y ~ sin(6 * pi * x),
           data = df, 
           parCovLower = c(0.01, 0.01), parCovUpper = c(10, 100),
           cov = myKern, estim = TRUE, noise = TRUE)
PK &lt;- prinKrige(mygp)

## the third PKF suggests a possible linear trend term, and the
## fourth may suggest a possible quadratic linear trend

matplot(x, PK$vectors[ , 1:4], type = "l", lwd = 2)

</code></pre>

<hr>
<h2 id='q1CompSymm'>
Qualitative Correlation or Covariance Kernel with one Input and
Compound Symmetric Correlation
</h2><span id='topic+q1CompSymm'></span>

<h3>Description</h3>

<p>Qualitative correlation or covariance kernel with one input and
compound symmetric correlation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
q1CompSymm(factor, input = "x", cov = c("corr", "homo"), intAsChar = TRUE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="q1CompSymm_+3A_factor">factor</code></td>
<td>

<p>A factor with the wanted levels for the covariance kernel object.
</p>
</td></tr>
<tr><td><code id="q1CompSymm_+3A_input">input</code></td>
<td>

<p>Name of (qualitative) input for the kernel.
</p>
</td></tr>
<tr><td><code id="q1CompSymm_+3A_cov">cov</code></td>
<td>

<p>Character telling if the kernel is a correlation kernel or a
homoscedastic covariance kernel.
</p>
</td></tr>
<tr><td><code id="q1CompSymm_+3A_intaschar">intAsChar</code></td>
<td>

<p>Logical. If <code>TRUE</code> (default), an integer-valued input will be
coerced into a character. Otherwise, it will be coerced into a factor.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object with class <code>"covQual"</code> with <code>d = 1</code>
qualitative input.
</p>


<h3>Note</h3>

<p>Correlation kernels are needed in tensor products because
the tensor product of two covariance kernels each with unknown
variance would not be identifiable.
</p>


<h3>See Also</h3>

<p>The <code><a href="#topic+corLevCompSymm">corLevCompSymm</a></code> function used to compute
the correlation matrix and its gradients w.r.t. the correlation
parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>School &lt;- factor(1L:3L, labels = c("Bad", "Mean" , "Good"))
myCor &lt;- q1CompSymm(School, input = "School")
coef(myCor) &lt;- 0.26
plot(myCor, type = "cor")

## Use a data.frame with a factor
set.seed(246)
newSchool &lt;- factor(sample(1L:3L, size = 20, replace = TRUE),
                    labels = c("Bad", "Mean" , "Good"))
C1 &lt;- covMat(myCor, X = data.frame(School = newSchool),
             compGrad = FALSE, lowerSQRT = FALSE)

</code></pre>

<hr>
<h2 id='q1Diag'>
Qualitative Correlation or Covariance Kernel with one Input and
Diagonal Structure
</h2><span id='topic+q1Diag'></span>

<h3>Description</h3>

<p>Qualitative correlation or covariance kernel with one input and diagonal
structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
q1Diag(factor, input = "x", cov = c("corr", "homo", "hete"), intAsChar = TRUE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="q1Diag_+3A_factor">factor</code></td>
<td>

<p>A factor with the wanted levels for the covariance
kernel object.
</p>
</td></tr>
<tr><td><code id="q1Diag_+3A_input">input</code></td>
<td>

<p>Name of (qualitative) input for the kernel.
</p>
</td></tr>
<tr><td><code id="q1Diag_+3A_cov">cov</code></td>
<td>

<p>Character telling if the result is a correlation kernel, an
homoscedastic covariance kernel or an heteroscedastic covariance
kernel with an arbitrary variance vector.
</p>
</td></tr>
<tr><td><code id="q1Diag_+3A_intaschar">intAsChar</code></td>
<td>

<p>Logical. If <code>TRUE</code> (default), an integer-valued input will be
coerced into a character. Otherwise, it will be coerced into a factor.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object with class <code>"covQual"</code> with <code>d = 1</code> qualitative
input.
</p>


<h3>Note</h3>

<p>The correlation version obtained with <code>cov = "corr"</code> has no
parameters.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+q1Symm">q1Symm</a></code>, <code><a href="#topic+q1CompSymm">q1CompSymm</a></code> are other covariance
structures for one qualitative input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>School &lt;- factor(1L:3L, labels = c("Bad", "Mean" , "Good"))

## correlation: no parameter!
myCor &lt;- q1Diag(School, input = "School")

## covariance 
myCov &lt;- q1Diag(School, input = "School", cov = "hete")
coef(myCov) &lt;- c(1.1, 2.2, 3.3)

</code></pre>

<hr>
<h2 id='q1LowRank'>
Qualitative Correlation or Covariance Kernel with one Input and
Low-Rank Correlation
</h2><span id='topic+q1LowRank'></span>

<h3>Description</h3>

<p>Qualitative correlation or covariance kernel with one input and
low-rank correlation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
q1LowRank(factor, rank = 2L, input = "x",
          cov = c("corr", "homo", "hete"), intAsChar = TRUE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="q1LowRank_+3A_factor">factor</code></td>
<td>

<p>A factor with the wanted levels for the covariance kernel object.
</p>
</td></tr>
<tr><td><code id="q1LowRank_+3A_rank">rank</code></td>
<td>

<p>The wanted rank, which must be <code class="reqn">\geq 2</code> and <code class="reqn">&lt; m</code>
where <code class="reqn">m</code> is the number of levels.
</p>
</td></tr>
<tr><td><code id="q1LowRank_+3A_input">input</code></td>
<td>

<p>Name of (qualitative) input for the kernel.
</p>
</td></tr>
<tr><td><code id="q1LowRank_+3A_cov">cov</code></td>
<td>

<p>Character telling what variance structure will be chosen:
<em>correlation</em> with no variance parameter, <em>homoscedastic</em>
with one variance parameter or <em>heteroscedastic</em> with <code class="reqn">m</code>
variance parameters.
</p>
</td></tr>
<tr><td><code id="q1LowRank_+3A_intaschar">intAsChar</code></td>
<td>

<p>Logical. If <code>TRUE</code> (default), an integer-valued input will be
coerced into a character. Otherwise, it will be coerced into a factor.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The correlation structure involves <code class="reqn">(r - 1)(m - r /2)</code> parameters.
The parameterization of Rapisarda et al is used: the correlation
parameters are angles <code class="reqn">\theta_{i,j}</code> corresponding to
<code class="reqn">1 &lt; i \leq r</code> and <code class="reqn">1 \leq j &lt; i</code>
or to <code class="reqn">r &lt; i \leq m</code> and
<code class="reqn">1 \leq j &lt; r</code>. The
correlation matrix <code class="reqn">\mathbf{C}</code> for the levels, with size
<code class="reqn">m</code>, factors as
<code class="reqn">\mathbf{C} = \mathbf{L}\mathbf{L}^\top</code>
where <code class="reqn">\mathbf{L}</code> is a lower-triangular
matrix with dimension <code class="reqn">m \times r</code> with all its rows
having unit Euclidean norm. Note that the diagonal elements of
<code class="reqn">\mathbf{L}</code> can be negative and correspondingly the angles
<code class="reqn">\theta_{i,1}</code> are taken in the interval
<code class="reqn">[0, 2\pi)</code> for <code class="reqn">1 &lt; i \leq r</code>. The
matrix <code class="reqn">\mathbf{L}</code> is not unique. As explained in Grubišić and
Pietersz, the parameterization is surjective: any correlation with
rank <code class="reqn">\leq r</code> is obtained by choosing a suitable vector
of parameters, but this vector is not unique.
</p>
<p>Correlation kernels are needed in tensor products because the tensor
product of two covariance kernels each with unknown variance would not
be identifiable.
</p>


<h3>Value</h3>

<p>An object with class <code>"covQual"</code> with <code>d = 1</code> qualitative
input.
</p>


<h3>References</h3>

<p>Francesco Rapisarda, Damanio Brigo, Fabio Mercurio (2007).
&quot;Parameterizing Correlations a Geometric Interpretation&quot;.
<em>IMA Journal of Management Mathematics</em>, <b>18</b>(1):
55-73.
</p>
<p>Igor Grubišić, Raoul Pietersz
(2007). &quot;Efficient Rank Reduction of Correlation Matrices&quot;. <em>Linear
Algebra and its Applications</em>, <b>422</b>: 629-653.
</p>


<h3>See Also</h3>

<p>The <code><a href="#topic+q1Symm">q1Symm</a></code> function to create a kernel object for the
full-rank case and <code><a href="#topic+corLevLowRank">corLevLowRank</a></code> for the correlation
function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>myFact &lt;- factor(letters[1:8])
myCov &lt;- q1LowRank(factor = myFact, rank = 3)
## corrplot
plot(myCov)
## find the rank using a pivoted Cholesky
chol(covMat(myCov), pivot = TRUE)
</code></pre>

<hr>
<h2 id='q1Symm'>
Qualitative Correlation or Covariance Kernel with one Input
and General Symmetric Correlation
</h2><span id='topic+q1Symm'></span>

<h3>Description</h3>

<p>Qualitative correlation or covariance kernel with one input and
general symmetric correlation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
  q1Symm(factor, input = "x", cov = c("corr", "homo", "hete"), intAsChar = TRUE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="q1Symm_+3A_factor">factor</code></td>
<td>

<p>A factor with the wanted levels for the covariance kernel object.
</p>
</td></tr>
<tr><td><code id="q1Symm_+3A_input">input</code></td>
<td>

<p>Name of (qualitative) input for the kernel.
</p>
</td></tr>
<tr><td><code id="q1Symm_+3A_cov">cov</code></td>
<td>

<p>Character telling if the result is a correlation kernel, an
homoscedastic covariance kernel or an heteroscedastic covariance
kernel with an arbitrary variance vector.
</p>
</td></tr>
<tr><td><code id="q1Symm_+3A_intaschar">intAsChar</code></td>
<td>

<p>Logical. If <code>TRUE</code> (default), an integer-valued input will be
coerced into a character. Otherwise, it will be coerced into a factor.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object with class <code>"covQual"</code> with <code>d = 1</code> qualitative
input.
</p>


<h3>Note</h3>

<p>Correlation kernels are needed in tensor products because the tensor
product of two covariance kernels each with unknown variance would not
be identifiable.
</p>


<h3>See Also</h3>

<p>The <code><a href="#topic+corLevSymm">corLevSymm</a></code> function used to compute the
correlation matrix and its gradients w.r.t. the correlation
parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>School &lt;- factor(1L:3L, labels = c("Bad", "Mean" , "Good"))
myCor &lt;- q1Symm(School, input = "School")
coef(myCor) &lt;- c(theta_2_1 = pi / 3, theta_3_1 = pi / 4, theta_3_2 = pi / 8)
plot(myCor, type = "cor")

## Use a data.frame with a factor
set.seed(246)
newSchool &lt;- factor(sample(1L:3L, size = 20, replace = TRUE),
                    labels = c("Bad", "Mean" , "Good"))
C1 &lt;- covMat(myCor, X = data.frame(School = newSchool),
             compGrad = FALSE, lowerSQRT = FALSE)
</code></pre>

<hr>
<h2 id='scores'>
Generic Function: Scores for a Covariance Kernel Object
</h2><span id='topic+scores'></span>

<h3>Description</h3>

<p>Generic function returning the scores for a covariance kernel object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scores(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scores_+3A_object">object</code></td>
<td>

<p>A covariance object.
</p>
</td></tr>
<tr><td><code id="scores_+3A_...">...</code></td>
<td>

<p>Other arguments passed to methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compute the derivatives <code class="reqn">\partial_{\theta_k}\ell </code>
for the (possibly concentrated) log-likelihood <code class="reqn">\ell :=
  \log L</code> of a covariance object with parameter vector
<code class="reqn">\boldsymbol{\theta}</code>.  The score for
<code class="reqn">\theta_k</code> is obtained as a matrix scalar product
</p>
<p style="text-align: center;"><code class="reqn">
    \partial_{\theta_k} \ell
    = \textrm{trace}(\mathbf{W} \mathbf{D})
  </code>
</p>

<p>where <code class="reqn">\mathbf{D} := \partial_{\theta_k} \mathbf{C}</code>
and where  <code class="reqn">\mathbf{W}</code> is the matrix
<code class="reqn">
    \mathbf{W} := \mathbf{e}\mathbf{e}^\top - \mathbf{C}^{-1}
  </code>.
The vector <code class="reqn">\mathbf{e}</code> is the vector of residuals
and the matrix <code class="reqn">\mathbf{C}</code>
is the covariance computed for the design <code class="reqn">\mathbf{X}</code>.
</p>


<h3>Value</h3>

<p>A numeric vector of length <code>npar(object)</code> containing the scores.
</p>


<h3>Note</h3>

<p>The scores can be efficiently computed when the matrix
<code class="reqn">\mathbf{W}</code> has already been pre-computed.
</p>

<hr>
<h2 id='shapeSlot'>
Extracts the Slots of a Structure
</h2><span id='topic+shapeSlot'></span>

<h3>Description</h3>

<p>Extract the slot of a structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shapeSlot(object, slotName = "par", type = "all", as = "vector")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shapeSlot_+3A_object">object</code></td>
<td>

<p>An object to extract from, typically a covariance kernel.
</p>
</td></tr>
<tr><td><code id="shapeSlot_+3A_slotname">slotName</code></td>
<td>

<p>Name of the slot to be extracted.
</p>
</td></tr>
<tr><td><code id="shapeSlot_+3A_type">type</code></td>
<td>

<p>Type of slot to be extracted. Can be either a type of parameter,
<code>"var"</code> or <code>"all"</code>.
</p>
</td></tr>
<tr><td><code id="shapeSlot_+3A_as">as</code></td>
<td>

<p>Type of result wanted. Can be <code>"vector"</code>, <code>"list"</code>
or <code>"matrix"</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector, list or matrix containing the extraction.
</p>


<h3>Note</h3>

<p>This function is for internal use only.
</p>

<hr>
<h2 id='simulate+2C+20covAll-method'>Simulation of a <code>covAll</code> Object</h2><span id='topic+simulate+2CcovAll-method'></span>

<h3>Description</h3>

<p>Simulation of a <code>covAll</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S4 method for signature 'covAll'
simulate(object, nsim = 1, seed = NULL,
         X, mu = NULL, method = "mvrnorm", checkNames = TRUE,
         ...)  

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate+2B2C+2B20covAll-method_+3A_object">object</code></td>
<td>

<p>A covariance kernel object.
</p>
</td></tr>
<tr><td><code id="simulate+2B2C+2B20covAll-method_+3A_nsim">nsim</code></td>
<td>

<p>Number of simulated paths.
</p>
</td></tr>
<tr><td><code id="simulate+2B2C+2B20covAll-method_+3A_seed">seed</code></td>
<td>

<p>Not used yet.
</p>
</td></tr>
<tr><td><code id="simulate+2B2C+2B20covAll-method_+3A_x">X</code></td>
<td>

<p>A matrix with the needed inputs as its columns.
</p>
</td></tr>
<tr><td><code id="simulate+2B2C+2B20covAll-method_+3A_mu">mu</code></td>
<td>

<p>Optional vector with length <code>nrow(X)</code> giving the expectation
<code class="reqn">\mu(\mathbf{x})</code> of the Gaussian Process at the
simulation locations <code class="reqn">\mathbf{x}</code>.
</p>
</td></tr>
<tr><td><code id="simulate+2B2C+2B20covAll-method_+3A_method">method</code></td>
<td>

<p>Character used to choose the simulation method. For now the only
possible value is <code>"mvrnorm"</code> corresponding to the function
with this name in the <b>MASS</b> package.
</p>
</td></tr>
<tr><td><code id="simulate+2B2C+2B20covAll-method_+3A_checknames">checkNames</code></td>
<td>

<p>Logical. It <code>TRUE</code> the colnames of <code>X</code> and the input names
of <code>object</code> as given by <code>inputNames(object)</code> must be
identical sets.
</p>
</td></tr>  
<tr><td><code id="simulate+2B2C+2B20covAll-method_+3A_...">...</code></td>
<td>

<p>Other arguments for methods.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix with <code>nrow(X)</code> rows and <code>nsim</code> columns.
Each column is the vector of the simulated path at the simulation
locations.
</p>


<h3>Note</h3>

<p>The simulation is unconditional.
</p>


<h3>See Also</h3>

<p>The <code><a href="MASS.html#topic+mvrnorm">mvrnorm</a></code> function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## -- as in example(kergp) define an argumentwise invariant kernel --

kernFun &lt;- function(x1, x2, par) {
  h &lt;- (abs(x1) - abs(x2)) / par[1]
  S &lt;- sum(h^2)
  d2 &lt;- exp(-S)
  K &lt;- par[2] * d2
  d1 &lt;- 2 * K * S / par[1]   
  attr(K, "gradient") &lt;- c(theta = d1,  sigma2 = d2)
  return(K)
}

covSymGauss &lt;- covMan(kernel = kernFun,
                      hasGrad = TRUE,
                      label = "argumentwise invariant",
                      d = 2,
                      parNames = c("theta", "sigma2"),
                      par = c(theta = 0.5, sigma2 = 2))

## -- simulate a path from the corresponding GP --

nGrid &lt;- 24; n &lt;- nGrid^2; d &lt;- 2
xGrid &lt;- seq(from = -1, to = 1, length.out = nGrid)
Xgrid &lt;- expand.grid(x1 = xGrid, x2 = xGrid)

ySim &lt;- simulate(covSymGauss, X = Xgrid)
contour(x = xGrid, y = xGrid,
        z = matrix(ySim, nrow = nGrid, ncol = nGrid), 
        nlevels = 15)
</code></pre>

<hr>
<h2 id='simulate.gp'>Simulation of Paths from a <code>gp</code> Object</h2><span id='topic+simulate.gp'></span>

<h3>Description</h3>

<p>Simulation of paths from a <code>gp</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gp'
simulate(object, nsim = 1L, seed = NULL,
         newdata = NULL,
         cond = TRUE,
         trendKnown = FALSE,
         newVarNoise = NULL,
         nuggetSim = 1e-8,
         checkNames = TRUE,
         output = c("list", "matrix"),
         label = "y", unit = "",
         ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate.gp_+3A_object">object</code></td>
<td>

<p>An object with class <code>"gp"</code>.
</p>
</td></tr>
<tr><td><code id="simulate.gp_+3A_nsim">nsim</code></td>
<td>

<p>Number of paths wanted.
</p>
</td></tr>
<tr><td><code id="simulate.gp_+3A_seed">seed</code></td>
<td>

<p>Not used yet.
</p>
</td></tr>
<tr><td><code id="simulate.gp_+3A_newdata">newdata</code></td>
<td>

<p>A data frame containing the inputs values used for simulation as
well as the required trend covariates, if any. This is similar to
the <code>newdata</code> formal in <code><a href="#topic+predict.gp">predict.gp</a></code>.
</p>
</td></tr>
<tr><td><code id="simulate.gp_+3A_cond">cond</code></td>
<td>

<p>Logical. Should the simulations be conditional on the observations
used in the object or not?
</p>
</td></tr>
<tr><td><code id="simulate.gp_+3A_trendknown">trendKnown</code></td>
<td>

<p>Logical. If <code>TRUE</code> the vector of trend coefficients will be
regarded as known so all simulated paths share the same trend. When
<code>FALSE</code>, the trend must have been estimated so that its estimation
covariance is known. Then each path will have a different trend.
</p>
</td></tr>
<tr><td><code id="simulate.gp_+3A_newvarnoise">newVarNoise</code></td>
<td>

<p>Variance of the noise for the &quot;new&quot; simulated observations. For the
default <code>NULL</code>, the noise variance found in <code>object</code> is
used. Note that if a very small positive value is used, each
simulated path is the sum of the trend the smooth GP part and an
interval containing say <code class="reqn">95</code>% of the simulated responses can
be regarded as a confidence interval rather than a prediction
interval.
</p>
</td></tr>
<tr><td><code id="simulate.gp_+3A_nuggetsim">nuggetSim</code></td>
<td>

<p>Small positive number (&quot;nugget&quot;) added to the diagonal of conditional covariance matrices before computing a Cholesky decomposition, for numerical lack of positive-definiteness.
This may happen when the covariance kernel is not (either theoretically or numerically) positive definite.
</p>
</td></tr>
<tr><td><code id="simulate.gp_+3A_checknames">checkNames</code></td>
<td>

<p>Logical. It <code>TRUE</code> the colnames of <code>X</code> and the input names
of the covariance in <code>object</code> as given by
<code>inputNames(object)</code> must be identical sets.
</p>
</td></tr>  
<tr><td><code id="simulate.gp_+3A_output">output</code></td>
<td>

<p>The type of output wanted. A simple matrix as in standard simulation
methods may be quite poor, since interesting intermediate results
are then lost.
</p>
</td></tr>
<tr><td><code id="simulate.gp_+3A_label">label</code>, <code id="simulate.gp_+3A_unit">unit</code></td>
<td>

<p>A label and unit that will be copied into the output object
when <code>output</code> is <code>"list"</code>.
</p>
</td></tr>
<tr><td><code id="simulate.gp_+3A_...">...</code></td>
<td>

<p>Further arguments to be passed to the <code>simulate</code> method
of the <code>"covAll"</code> class.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the simulated paths as its columns or a more complete
list with more results. This list which is given the S3 class
<code>"simulate.gp"</code> has the following elements.
</p>
<table>
<tr><td><code>X</code>, <code>F</code>, <code>y</code></td>
<td>
<p> Inputs,
trend covariates and response. </p>
</td></tr> <tr><td><code>XNew</code>, <code>FNew</code></td>
<td>
<p> New inputs, new trend covariates. </p>
</td></tr>
<tr><td><code>sim</code></td>
<td>
<p> Matrix of simulated paths. </p>
</td></tr>
<tr><td><code>trend</code></td>
<td>
<p> Matrix of simulated trends. </p>
</td></tr>
<tr><td><code>trendKnown</code>, <code>noise</code>, <code>newVarNoise</code></td>
<td>

<p>Values of the formals. </p>
</td></tr> 
<tr><td><code>Call</code></td>
<td>
<p> The call. </p>
</td></tr> 
</table>


<h3>Note</h3>

<p>When <code>betaKnown</code> is <code>FALSE</code>, the <em>trend</em> and the
<em>smooth GP</em> parts of a simulation are usually correlated, and
their sum will show less dispersion than each of the two
components. The covariance of the vector
<code class="reqn">\widehat{\boldsymbol{\beta}}</code> can be regarded as the
posterior distribution corresponding to a non-informative prior, the
distribution from which a new path is drawn being the predictive
distribution.
</p>


<h3>Author(s)</h3>

<p>Yves Deville
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(314159)
n &lt;- 40
x &lt;- sort(runif(n))
y &lt;- 2 + 4 * x  + 2 * x^2 + 3 * sin(6 * pi * x ) + 1.0 * rnorm(n)
df &lt;- data.frame(x = x, y = y)

##-------------------------------------------------------------------------
## use a Matern 3/2 covariance. With model #2, the trend is mispecified,
## so the smooth GP part of the model captures a part of the trend.
##-------------------------------------------------------------------------

myKern &lt;- k1Matern3_2
inputNames(myKern) &lt;- "x"
mygp &lt;- list()
mygp[[1]] &lt;- gp(formula = y ~ x + I(x^2) + sin(6 * pi * x), data = df, 
                parCovLower = c(0.01, 0.01), parCovUpper = c(10, 100),
                cov = myKern, estim = TRUE, noise = TRUE)
mygp[[2]] &lt;- gp(formula = y ~ sin(6 * pi * x), data = df, 
                parCovLower = c(0.01, 0.01), parCovUpper = c(10, 100),
                cov = myKern, estim = TRUE, noise = TRUE)

##-------------------------------------------------------------------------
## New data
##-------------------------------------------------------------------------

nNew &lt;- 150
xNew &lt;- seq(from = -0.2, to= 1.2, length.out = nNew)
dfNew &lt;- data.frame(x = xNew)

opar &lt;- par(mfrow = c(2L, 2L))

nsim &lt;- 40
for (i in 1:2) {

    ##--------------------------------------------------------------------
    ## beta known or not, conditional
    ##--------------------------------------------------------------------

    simTU &lt;- simulate(object = mygp[[i]], newdata = dfNew,  nsim = nsim,
                      trendKnown = FALSE)
    plot(simTU, main = "trend unknown, conditional")

    simTK &lt;- simulate(object = mygp[[i]], newdata = dfNew, nsim = nsim,
                      trendKnown = TRUE)
    plot(simTK, main = "trend known, conditional")

    ##--------------------------------------------------------------------
    ## The same but UNconditional
    ##--------------------------------------------------------------------

    simTU &lt;- simulate(object = mygp[[i]], newdata = dfNew,  nsim = nsim,
                     trendKnown = FALSE, cond = FALSE)
    plot(simTU, main = "trend unknown, unconditional")
    simTK &lt;- simulate(object = mygp[[i]], newdata = dfNew, nsim = nsim,
                      trendKnown = TRUE, cond = FALSE)
    plot(simTK, main = "trend known, unconditional")
}

par(opar)
</code></pre>

<hr>
<h2 id='simulPar'>
Generic function: Draw Random Values for the Parameters of a
Covariance Kernel
</h2><span id='topic+simulPar'></span>

<h3>Description</h3>

<p>Generic function to draw random values for the parameters of a
covariance kernel object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  simulPar(object, nsim = 1L, seed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulPar_+3A_object">object</code></td>
<td>

<p>A covariance kernel.
</p>
</td></tr>
<tr><td><code id="simulPar_+3A_nsim">nsim</code></td>
<td>

<p>Number of drawings.
</p>
</td></tr>
<tr><td><code id="simulPar_+3A_seed">seed</code></td>
<td>

<p>Seed for the random generator.
</p>
</td></tr>
<tr><td><code id="simulPar_+3A_...">...</code></td>
<td>

<p>Other arguments for methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Draw random values for the parameters of a covariance kernel object
using the informations <code>coefLower</code> and <code>coefUpper</code>.
</p>


<h3>Value</h3>

<p>A matrix with <code>nsim</code> rows and <code>npar(object)</code> columns.
</p>

<hr>
<h2 id='simulPar+2CcovAll-method'>
Draw Random Values for the Parameters of a Covariance Kernel
</h2><span id='topic+simulPar+2CcovAll-method'></span>

<h3>Description</h3>

<p>Draw random values for the parameters of a covariance kernel
</p>
<p>object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S4 method for signature 'covAll'
simulPar(object, nsim = 1L, seed = NULL)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulPar+2B2CcovAll-method_+3A_object">object</code></td>
<td>

<p>A covariance kernel.
</p>
</td></tr>
<tr><td><code id="simulPar+2B2CcovAll-method_+3A_nsim">nsim</code></td>
<td>

<p>Number of drawings.
</p>
</td></tr>
<tr><td><code id="simulPar+2B2CcovAll-method_+3A_seed">seed</code></td>
<td>

<p>Seed for the random generator.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Draw random values for the parameters of a covariance kernel
object using the informations <code>coefLower</code> and
<code>coefUpper</code>.
</p>


<h3>Value</h3>

<p>A matrix with <code>nsim</code> rows and <code>npar(object)</code> columns.
</p>

<hr>
<h2 id='symIndices'>
Vector of Indices Useful for Symmetric or Anti-Symmetric Matrices.
</h2><span id='topic+symIndices'></span>

<h3>Description</h3>

<p>Vector of indices useful for symmetric or anti-symmetric matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
symIndices(n, diag = FALSE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="symIndices_+3A_n">n</code></td>
<td>

<p>Size of a square matrix.
</p>
</td></tr>
<tr><td><code id="symIndices_+3A_diag">diag</code></td>
<td>

<p>Logical. When <code>FALSE</code> the diagonal is omitted in the lower and
upper triangles.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is intended to provide computations which are faster than
<code>lower.tri</code> and <code>upper.tri</code>.
</p>


<h3>Value</h3>

<p>A list containing the following integer vectors, each with length
<code class="reqn">(n - 1) n / 2</code>. </p>
<table>
<tr><td><code>i</code>, <code>j</code></td>
<td>
<p> Row and column indices for the lower
triangle to be used in a two-index style. </p>
</td></tr> <tr><td><code>kL</code></td>
<td>
<p> Indices for the
lower triangle, to be used in single-index style. The elements are
picked in column order. So if <code>X</code> is a square matrix with size
<code>n</code>, then <code>X[kL]</code> is the vector containing the elements of the
lower triangle of <code>X</code> taken in column order. </p>
</td></tr> <tr><td><code>kU</code></td>
<td>
<p> Indices
for the upper triangle, to be used in a single-index style. The
elements are picked in row order. So if <code>X</code> is a square matrix with
size <code>n</code>, then <code>X[kU]</code> is the vector containing the elements
of the upper triangle of <code>X</code> taken in row order. </p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- rpois(1, lambda = 10)
L &lt;- symIndices(n)
X &lt;- matrix(1L:(n * n), nrow = n)
max(abs(X[lower.tri(X, diag = FALSE)] - L$kL))
max(abs(t(X)[lower.tri(X, diag = FALSE)] - L$kU))
cbind(row = L$i, col = L$j)
</code></pre>

<hr>
<h2 id='translude'>Make Translucent colors</h2><span id='topic+translude'></span>

<h3>Description</h3>

<p>Make translucent colors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
  translude(colors, alpha = 0.6)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="translude_+3A_colors">colors</code></td>
<td>

<p>A vector of colors in a format that can be understood by
<code><a href="grDevices.html#topic+col2rgb">col2rgb</a></code>.
</p>
</td></tr>
<tr><td><code id="translude_+3A_alpha">alpha</code></td>
<td>

<p>Level of opacity (&quot;0&quot; means fully transparent and &quot;max&quot; means
opaque).  After recycling to reach the required length, this value
or vector is used as <code>alpha</code> in <code><a href="grDevices.html#topic+rgb">rgb</a></code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of translucent (or semi-transparent) colors.
</p>

<hr>
<h2 id='varVec'>
Generic Function: Variance of Gaussian Process at Specific Locations
</h2><span id='topic+varVec'></span>

<h3>Description</h3>

<p>Generic function returning a variance vector 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
varVec(object, X, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varVec_+3A_object">object</code></td>
<td>

<p>Covariance kernel object.
</p>
</td></tr>
<tr><td><code id="varVec_+3A_x">X</code></td>
<td>

<p>A matrix with <code class="reqn">d</code> columns, where <code class="reqn">d</code> is the number of inputs
of the covariance kernel. The <code class="reqn">n</code> rows define a set of sites or
locations.
</p>
</td></tr>
<tr><td><code id="varVec_+3A_...">...</code></td>
<td>

<p>Other arguments for methods.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with length <code>nrow(X)</code> containing the variances
<code class="reqn">K(\mathbf{x}, \mathbf{x})</code> for all the sites
<code class="reqn">\mathbf{x}</code>.
</p>

<hr>
<h2 id='varVec-methods'>
Covariance Matrix for a Covariance Kernel Object
</h2><span id='topic+varVec+2CcovMan-method'></span><span id='topic+varVec+2CcovTS-method'></span>

<h3>Description</h3>

<p>Covariance matrix for a covariance kernel object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'covMan'
varVec(object, X, compGrad = FALSE, 
       checkNames = NULL, index = -1L, ...)

## S4 method for signature 'covTS'
varVec(object, X, compGrad = FALSE, 
       checkNames = TRUE, index = -1L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varVec-methods_+3A_object">object</code></td>
<td>

<p>An object with S4 class corresponding to a covariance kernel.
</p>
</td></tr>
<tr><td><code id="varVec-methods_+3A_x">X</code></td>
<td>

<p>The usual matrix of spatial design points, with <code class="reqn">n</code> rows and
<code class="reqn">d</code> cols where <code class="reqn">n</code> is the number of spatial points and
<code class="reqn">d</code> is the 'spatial' dimension.
</p>
</td></tr>
<tr><td><code id="varVec-methods_+3A_compgrad">compGrad</code></td>
<td>

<p>Logical. If <code>TRUE</code> a derivative with respect to the vector of
parameters will be computed and returned as an attribute of the
result. For the <code>covMan</code> class, this is possible only when the
gradient of the kernel is computed and returned as a
<code>"gradient"</code> attribute of the result.
</p>
</td></tr>
<tr><td><code id="varVec-methods_+3A_checknames">checkNames</code></td>
<td>

<p>Logical. If <code>TRUE</code> (default), check the compatibility of
<code>X</code> with <code>object</code>, see <code><a href="#topic+checkX">checkX</a></code>.
</p>
</td></tr>
<tr><td><code id="varVec-methods_+3A_index">index</code></td>
<td>

<p>Integer giving the index of the derivation parameter in the official
order.
</p>
</td></tr>
<tr><td><code id="varVec-methods_+3A_...">...</code></td>
<td>

<p>Not used yet.
</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>The variance vector is computed in a C program using the <code>.Call</code>
interface. The R kernel function is evaluated within the C code using
<code>eval</code>.
</p>


<h3>Value</h3>

<p>A vector of length <code>nrow(X)</code> with general element <code class="reqn">V_{i} :=
  K(\mathbf{x}_{i},\,\mathbf{x}_{i};\,\boldsymbol{\theta})</code> where
<code class="reqn">K(\mathbf{x}_1,\,\mathbf{x}_2;\,\boldsymbol{\theta})</code> is the covariance kernel function.
</p>


<h3>Note</h3>

<p>The value of the parameter <code class="reqn">\boldsymbol{\theta}</code> can be
extracted from the object with the <code>coef</code> method.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+coef">coef</a></code> method
</p>


<h3>Examples</h3>

<pre><code class='language-R'>myCov &lt;- covTS(inputs = c("Temp", "Humid", "Press"),
               kernel = "k1PowExp",
               dep = c(range = "cst", shape = "cst"),
               value = c(shape = 1.8, range = 1.1))
n &lt;- 100; X &lt;- matrix(runif(n*3), nrow = n, ncol = 3)
try(V1 &lt;- varVec(myCov, X = X)) ## bad colnames
colnames(X) &lt;- inputNames(myCov)
V2 &lt;- varVec(myCov, X = X)

Xnew &lt;- matrix(runif(n * 3), nrow = n, ncol = 3)
colnames(Xnew) &lt;- inputNames(myCov)
V2 &lt;- varVec(myCov, X = X)

</code></pre>

<hr>
<h2 id='warpNorm'>
Warpings for Ordinal Inputs
</h2><span id='topic+warpNorm'></span><span id='topic+warpPower'></span><span id='topic+warpUnorm'></span><span id='topic+warpSpline1'></span><span id='topic+warpSpline2'></span><span id='topic+warpFun'></span>

<h3>Description</h3>

<p>Given warpings for ordinal inputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>warpNorm
warpUnorm
warpPower
warpSpline1
warpSpline2
</code></pre>


<h3>Format</h3>

<p>The format is a list of 6:
</p>
<p>$ fun : the warping function. The second argument is the vector of
parameters. The function returns a numeric vector with an attribute
<code>"gradient"</code> giving the derivative w.r.t. the parameters.
</p>
<p>$ parNames  : names of warping parameters (character vector). 
</p>
<p>$ parDefault: default values of warping parameters (numeric vector).
</p>
<p>$ parLower  : lower bounds of warping parameters (numeric vector).
</p>
<p>$ parUpper  : upper bounds of warping parameters (numeric vector). 
</p>
<p>$ hasGrad : a boolean equal to <code>TRUE</code> if <code>gradient</code> is
supplied as an attribute of <code>fun</code>.
</p>


<h3>Details</h3>

<p>See <code><a href="#topic+covOrd">covOrd</a></code> for the definition of a warping in this
context.  At this stage, two warpings corresponding to cumulative
density functions (cdf) are implemented:
</p>

<ul>
<li><p> Normal distribution, truncated to <code class="reqn">[0,1]</code>: </p>
<p style="text-align: center;"><code class="reqn">F(x) = [N(x) -
      N(0)] / [N(1) - N(0)]</code>
</p>
<p> where <code class="reqn">N(x) = \Phi([x - \mu] /
      \sigma)</code> is the cdf of the normal
distribution with mean <code class="reqn">\mu</code> and standard deviation
<code class="reqn">\sigma</code>.
</p>
</li>
<li><p> Power distribution on <code class="reqn">[0, 1]</code>: <code class="reqn">F(x) = x^{pow}</code>.
</p>
</li></ul>

<p>Furthermore, a warping corresponding to unnormalized Normal cdf is implemented, 
as well as spline warpings of degree 1 and 2. 
Splines are defined by a sequence of <code>k</code> knots between 0 and 1. The first knot is 0, and the last is 1.
A spline warping of degree 1 is a continuous piecewise linear function. 
It is parameterized by a positive vector of length <code>k-1</code>, representing the increments at knots.
A spline warping of degree 2 is a non-decreasing quadratic spline. It is obtained by integrating a spline of degree 1.
Its parameters form a positive vector of length <code>k</code>, representing the derivatives at knots. The implementation relies on the function <code>scalingFun1d</code> of <code>DiceKriging</code> package.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
