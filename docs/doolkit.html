<!DOCTYPE html><html><head><title>Help for package doolkit</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {doolkit}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#angularity'><p>angularity</p></a></li>
<li><a href='#arc'><p>Average-Relative Curvature (ARC)</p></a></li>
<li><a href='#area2d'><p>2D surface area</p></a></li>
<li><a href='#dkborder'><p>dkborder</p></a></li>
<li><a href='#dkcrop'><p>crop a mesh</p></a></li>
<li><a href='#dkmap'><p>3d topographic map</p></a></li>
<li><a href='#dkmodel'><p>dkmodel</p></a></li>
<li><a href='#dkorigin'><p>dkorigin</p></a></li>
<li><a href='#dkpongo'><p>dkpongo</p></a></li>
<li><a href='#dkprofile'><p>cumulative profile, its slope and the area under its curve</p></a></li>
<li><a href='#dksetview'><p>preset orientations</p></a></li>
<li><a href='#dne'><p>Dirichlet normal energy</p></a></li>
<li><a href='#elev'><p>elevation</p></a></li>
<li><a href='#hypso'><p>hypso</p></a></li>
<li><a href='#inclin'><p>inclin</p></a></li>
<li><a href='#oedist'><p>Distance from outer enamel surface to enamel dentine junction</p></a></li>
<li><a href='#opc'><p>orientation patch count</p></a></li>
<li><a href='#opcr'><p>orientation patch count rotated</p></a></li>
<li><a href='#orient'><p>orientation of polygons</p></a></li>
<li><a href='#poly.network'><p>Identify polygon networks</p></a></li>
<li><a href='#polygon.network-class'><p>S4 class for polygon networks</p></a></li>
<li><a href='#rfi'><p>relief index</p></a></li>
<li><a href='#rrate'><p>relief rate</p></a></li>
<li><a href='#shape.index'><p>shape.index</p></a></li>
<li><a href='#slope'><p>slope</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Exploration of Dental Surface Topography</td>
</tr>
<tr>
<td>Version:</td>
<td>1.42.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for exploring the topography of 3d triangle meshes.
    The functions were developed with dental surfaces in mind, but could be 
    applied to any triangle mesh of class 'mesh3d'. More specifically, 'doolkit'
    allows to isolate the border of a mesh, or a subpart of the mesh using the 
    polygon networks method; crop a mesh; compute basic descriptors (elevation, 
    orientation, footprint area); compute slope, angularity and relief index
    (Ungar and Williamson (2000) <a href="https://palaeo-electronica.org/2000_1/gorilla/issue1_00.htm">https://palaeo-electronica.org/2000_1/gorilla/issue1_00.htm</a>;
    Boyer (2008) &lt;<a href="https://doi.org/10.1016%2Fj.jhevol.2008.08.002">doi:10.1016/j.jhevol.2008.08.002</a>&gt;), inclination and occlusal
    relief index or gamma (Guy et al. (2013) &lt;<a href="https://doi.org/10.1371%2Fjournal.pone.0066142">doi:10.1371/journal.pone.0066142</a>&gt;),
    OPC (Evans et al. (2007) &lt;<a href="https://doi.org/10.1038%2Fnature05433">doi:10.1038/nature05433</a>&gt;), OPCR (Wilson et al. 
    (2012) &lt;<a href="https://doi.org/10.1038%2Fnature10880">doi:10.1038/nature10880</a>&gt;), DNE (Bunn et al. (2011) &lt;<a href="https://doi.org/10.1002%2Fajpa.21489">doi:10.1002/ajpa.21489</a>&gt;;
    Pampush et al. (2016) &lt;<a href="https://doi.org/10.1007%2Fs10914-016-9326-0">doi:10.1007/s10914-016-9326-0</a>&gt;), form factor (Horton 
    (1932) &lt;<a href="https://doi.org/10.1029%2FTR013i001p00350">doi:10.1029/TR013i001p00350</a>&gt;), basin elongation (Schum (1956) 
    &lt;<a href="https://doi.org/10.1130%2F0016-7606%281956%2967%5B597%3AEODSAS%5D2.0.CO%3B2">doi:10.1130/0016-7606(1956)67[597:EODSAS]2.0.CO;2</a>&gt;), lemniscate ratio 
    (Chorley et al; (1957) &lt;<a href="https://doi.org/10.2475%2Fajs.255.2.138">doi:10.2475/ajs.255.2.138</a>&gt;), enamel-dentine distance
    (Guy et al. (2015) &lt;<a href="https://doi.org/10.1371%2Fjournal.pone.0138802">doi:10.1371/journal.pone.0138802</a>&gt;; Thiery et al. (2017) 
    &lt;<a href="https://doi.org/10.3389%2Ffphys.2017.00524">doi:10.3389/fphys.2017.00524</a>&gt;), absolute crown strength (Schwartz et al. 
    (2020) &lt;<a href="https://doi.org/10.1098%2Frsbl.2019.0671">doi:10.1098/rsbl.2019.0671</a>&gt;), relief rate (Thiery et al. (2019)
    &lt;<a href="https://doi.org/10.1002%2Fajpa.23916">doi:10.1002/ajpa.23916</a>&gt;) and area-relative curvature; draw cumulative
    profiles of a topographic variable; and map a variable over a 3d triangle 
    mesh.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2, igraph, Morpho, rgl, Rvcg, sp, MASS, tis, methods,
concaveman, usethis</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-02-06 01:56:25 UTC; ghisl</td>
</tr>
<tr>
<td>Author:</td>
<td>Ghislain Thiery [aut, cre],
  Franck Guy [aut],
  Vincent Lazzari [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ghislain Thiery &lt;ghislain.thiery@ntymail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-02-06 08:22:34 UTC</td>
</tr>
</table>
<hr>
<h2 id='angularity'>angularity</h2><span id='topic+angularity'></span>

<h3>Description</h3>

<p>Compute the angularity (delta slope).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>angularity(mesh, ratio = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="angularity_+3A_mesh">mesh</code></td>
<td>
<p>object of class mesh3d</p>
</td></tr>
<tr><td><code id="angularity_+3A_ratio">ratio</code></td>
<td>
<p>logical, if false standard angularity will be computed (default),
if true a relative angularity ratio will be computed (see below)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If ratio = FALSE, a numeric vector of angularity values i.e. delta slope of
each polygon compared to their adjacent polygons, for all the polygons of the
mesh.
If ratio = TRUE, a numeric vector of angularity ratio values. Ratio is computed
by dividing polygon slope by 90, replacing vertex elevation by the average
ratio of faces adjacent to the vertex, then dividing the slope of polygons from
this new mesh by 90. Although it is a non-standard variable, it was implemented because
it better discriminates sharp edges than basic angularity.
Warning: both options can take up a significant amount of time for large meshes.
</p>


<h3>References</h3>

<p><a href="https://palaeo-electronica.org/2000_1/gorilla/issue1_00.htm">Ungar and Williamson (2000)</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>delta_slope &lt;- angularity(dkmodel$complex, ratio = FALSE)
summary(delta_slope)
#angularity ratio:
delta_slope_ratio &lt;- angularity(dkmodel$complex, ratio = TRUE)
summary(delta_slope_ratio)

#render on a map:
dkmap(dkmodel$complex, delta_slope, col = "slope",
legend.lab = "Angularity (°)")
#angularity ratio:
dkmap(dkmodel$complex, delta_slope_ratio, col = "slope",
legend.lab = "Angularity ratio")

</code></pre>

<hr>
<h2 id='arc'>Average-Relative Curvature (ARC)</h2><span id='topic+arc'></span>

<h3>Description</h3>

<p>Compute a scale-free estimate of mean curvature.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arc(mesh, range = c(0.01, 0.99))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arc_+3A_mesh">mesh</code></td>
<td>
<p>object of class mesh3d</p>
</td></tr>
<tr><td><code id="arc_+3A_range">range</code></td>
<td>
<p>a numeric vector of the form c('minrange', 'maxrange') indicating
the set limits for extreme values, beyond which arc values will be truncated.
If 'minrange' and 'maxrange' are comprised between 0 and 1, they are used as
arc percentages. If 'minrange' and 'maxrange' are not comprised between 0 and 1,
they are used as raw arc values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Area-relative curvature (ARC) is obtained by dividing the mean curvature of each triangle
by the mean curvature of an hemisphere, the surface area of which is the same as the surface area
of the total mesh object. Coincidentally, the surface area of a hemisphere is linked to
its mean curvature by the following function: 2.4481 * 1 / square root(surface area)
As a result, ARC is a scale-free estimate of surface curvature. It can
be used to estimate the sharpness of a mesh.
</p>


<h3>Value</h3>

<p>A numeric vector of area-relative curvature values for all the polygons of the mesh.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>curvature &lt;- arc(dkmodel$complex)
summary(curvature)

#There is a default truncature of extreme values below 1% or above 99%.
#Without truncature:
curvature &lt;- arc(dkmodel$complex, range = c(0, 1))
summary(curvature)

#mean positive ARC:
parc &lt;- mean(curvature[curvature &gt;= 0])
#mean negative ARC:
narc &lt;- mean(curvature[curvature &lt; 0])

#render on a map:
dkmap(dkmodel$complex, curvature, col = "arc",
min.range = -20, max.range = 20)
#absolute truncature of the values above 20 or below -20:
dkmap(dkmodel$complex, curvature, col = "arc", min.range = -20, max.range = 20)
</code></pre>

<hr>
<h2 id='area2d'>2D surface area</h2><span id='topic+area2d'></span>

<h3>Description</h3>

<p>Compute the area of a 2d projection on the (xy) plane.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>area2d(mesh, method = "concave")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="area2d_+3A_mesh">mesh</code></td>
<td>
<p>object of class mesh3d</p>
</td></tr>
<tr><td><code id="area2d_+3A_method">method</code></td>
<td>
<p>the method used to compute the hull of the 2d projection, either
'convex' (see <code><a href="grDevices.html#topic+chull">chull</a></code>),
or 'concave' (see <code><a href="concaveman.html#topic+concaveman">concaveman</a></code>). The default method is 'concave'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can assess 2D surface area of the projection of a mesh on the (xy) plane.
The projection is assimilated to a hull, which can be a convex hull
(see <code><a href="grDevices.html#topic+chull">chull</a></code>) or a concave hull
(see <code><a href="concaveman.html#topic+concaveman">concaveman</a></code>). Note that if your mesh is a combination
of two or more discontinuous surfaces (e.g., isolated cusps), you should not use
either approach.
As of version 1.42.2, the concave hull fails intermittently on Mac systems, so the function
defaults to convex hulls (on other systems, it defaults to concave hulls)
</p>


<h3>Value</h3>

<p>A single 2D surface area value, corresponding to the footprint of the mesh.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rfi">rfi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#The following objects should have the exact same footprints:
area2d(dkmodel$basin)
area2d(dkmodel$complex)
area2d(dkmodel$cusp)
area2d(dkmodel$flat)

#Graphical rendering of convex hull
x &lt;- dkmodel$cusp
FootprintVerts &lt;- t(x$vb[1:2, ])
Hull &lt;- grDevices::chull(x = FootprintVerts[, 1], y = FootprintVerts[, 2])
plot(x$vb[1, ], x$vb[2, ], xlab = "x", ylab = "y")
points(x$vb[1, Hull], x$vb[2, Hull], col = "orange1")

#Graphical rendering of concave hull
x &lt;- dkmodel$cusp
FootprintVerts &lt;- t(x$vb[1:2, ])
FootprintVerts[, 1] &lt;- FootprintVerts[, 1] - min(FootprintVerts[, 1])
FootprintVerts[, 2] &lt;- FootprintVerts[, 2] - min(FootprintVerts[, 2])
Hull &lt;- concaveman::concaveman(points = FootprintVerts)
plot(x$vb[1, ] - min(x$vb[1, ]), x$vb[2, ] - min(x$vb[2, ]), xlab = "x", ylab = "y")
points(Hull, col = "green1")
</code></pre>

<hr>
<h2 id='dkborder'>dkborder</h2><span id='topic+dkborder'></span>

<h3>Description</h3>

<p>Selects the border of a 3d triangle mesh.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dkborder(mesh)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dkborder_+3A_mesh">mesh</code></td>
<td>
<p>object of class mesh3d</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of indices corresponding to the triangles with at least one vertex on the border of the mesh.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>border &lt;- dkborder(dkmodel$cusp)

# Map the border in orange:
is_border &lt;- rep(1, Rvcg::nfaces(dkmodel$cusp))
is_border[border] &lt;- 2
dkmap(dkmodel$cusp, is_border, col = c("white", "#E69F00"), col.levels = 2, legend = FALSE,
scalebar = FALSE, smooth = FALSE)

# Compare with vcgBorder from the R package Rvcg, in blue:
vcgborder &lt;- which(Rvcg::vcgBorder(dkmodel$cusp)$borderit == TRUE)
is_border[vcgborder] &lt;- 3
dkmap(dkmodel$cusp, is_border, col = c("white", "#E69F00", "#56B4E9"), col.levels = 3,
legend = FALSE, scalebar = FALSE, smooth = FALSE)
#As you can see, it all depends on what you want to select!

</code></pre>

<hr>
<h2 id='dkcrop'>crop a mesh</h2><span id='topic+dkcrop'></span>

<h3>Description</h3>

<p>Crop a 3d triangle mesh.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dkcrop(mesh, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dkcrop_+3A_mesh">mesh</code></td>
<td>
<p>object of class mesh3d</p>
</td></tr>
<tr><td><code id="dkcrop_+3A_y">y</code></td>
<td>
<p>numeric vector indicating which polygons should be cropped; or an object of class <code>polygon.network</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new object of class mesh3d for which all polygons out of y have been removed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Crop above a certain threshold:
mythreshold &lt;- quantile(elev(dkmodel$basin), 0.5)
mypolynetwork &lt;- poly.network(dkmodel$basin, elev(dkmodel$basin),
lwr.limit = mythreshold)
mynewmesh &lt;- dkcrop(dkmodel$basin, mypolynetwork)
dkmap(mynewmesh, elev(mynewmesh))

#Crop the sharpest dental elements:
sharpmesh &lt;- dkcrop(dkmodel$basin, poly.network(dkmodel$basin,
Rvcg::vcgCurve(dkmodel$basin)$meanitmax,
lwr.limit = quantile(Rvcg::vcgCurve(dkmodel$basin)$meanitmax, 0.8),
min.size = 50))
dkmap(sharpmesh, arc(sharpmesh), col = "arc", col.levels = 20,
min.range = -20, max.range = 20)
#Map of the sharpest elements' elevation, slope and orientation;
dkmap(sharpmesh, elev(sharpmesh), col = "elev")
dkmap(sharpmesh, slope(sharpmesh), col = "slope", col.levels = 9,
min.range = 0, max.range = 90)
dkmap(sharpmesh, orient(sharpmesh), col = "orient", col.levels = 8,
min.range = 0, max.range = 360)

</code></pre>

<hr>
<h2 id='dkmap'>3d topographic map</h2><span id='topic+dkmap'></span>

<h3>Description</h3>

<p>Map topographic variables on a 3d triangle mesh.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dkmap(
  mesh,
  y,
  alpha = 1,
  alpha.above = TRUE,
  alpha.faces = NULL,
  alpha.thresh = NULL,
  bg = "white",
  col = "slope",
  col.levels = 100,
  col.main = "black",
  col.lab = "black",
  col.sub = "black",
  col.axis = "black",
  max.range = NULL,
  min.range = NULL,
  lit = TRUE,
  cex = 2,
  cex.axis = 2,
  cex.main = 4,
  cex.sub = 3,
  cex.lab = 2,
  family = "sans",
  font.axis = 1,
  font.lab = 2,
  font.main = 3,
  font.sub = 2,
  main = "",
  sub = "",
  legend = TRUE,
  legend.lab = "y",
  legend.type = "stack",
  windowRect = NULL,
  orient = "current",
  bbox = FALSE,
  origin = TRUE,
  scalebar = FALSE,
  smooth = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dkmap_+3A_mesh">mesh</code></td>
<td>
<p>object of class mesh3d</p>
</td></tr>
<tr><td><code id="dkmap_+3A_y">y</code></td>
<td>
<p>a vector of values for each polygon of the mesh, usually a topographic variable</p>
</td></tr>
<tr><td><code id="dkmap_+3A_alpha">alpha</code></td>
<td>
<p>an integer between 0 and 1 corresponding to alpha value for the selected polygons
(see <code>alpha.above</code>, <code>alpha.faces</code> and <code>alpha.thresh</code>)</p>
</td></tr>
<tr><td><code id="dkmap_+3A_alpha.above">alpha.above</code></td>
<td>
<p>logical, if TRUE polygons affected by <code>alpha</code> should have a y value above <code>alpha.thresh</code>,
if FALSE their y value should be below <code>alpha.thresh</code></p>
</td></tr>
<tr><td><code id="dkmap_+3A_alpha.faces">alpha.faces</code></td>
<td>
<p>a numeric vector of indices indicating which faces affected by <code>alpha</code></p>
</td></tr>
<tr><td><code id="dkmap_+3A_alpha.thresh">alpha.thresh</code></td>
<td>
<p>a numeric value indicating a threshold for alpha</p>
</td></tr>
<tr><td><code id="dkmap_+3A_bg">bg</code></td>
<td>
<p>the color to be used for the background. Defaults to &quot;white&quot;.</p>
</td></tr>
<tr><td><code id="dkmap_+3A_col">col</code></td>
<td>
<p>a vector of colors for texturing the polygons according to y</p>
</td></tr>
<tr><td><code id="dkmap_+3A_col.levels">col.levels</code></td>
<td>
<p>the number of color levels</p>
</td></tr>
<tr><td><code id="dkmap_+3A_col.main">col.main</code></td>
<td>
<p>the color to be used for legend main titles. Defaults to &quot;black&quot;.</p>
</td></tr>
<tr><td><code id="dkmap_+3A_col.lab">col.lab</code></td>
<td>
<p>the color to be used for the legend labels. Defaults to &quot;black&quot;.</p>
</td></tr>
<tr><td><code id="dkmap_+3A_col.sub">col.sub</code></td>
<td>
<p>the color to be used for plot sub-titles. Defaults to &quot;black&quot;.</p>
</td></tr>
<tr><td><code id="dkmap_+3A_col.axis">col.axis</code></td>
<td>
<p>the color to be used for legend axis annotation. Defaults to &quot;black&quot;.</p>
</td></tr>
<tr><td><code id="dkmap_+3A_max.range">max.range</code></td>
<td>
<p>optional; the maximal range of the scale</p>
</td></tr>
<tr><td><code id="dkmap_+3A_min.range">min.range</code></td>
<td>
<p>optional; the minimal range of the scale</p>
</td></tr>
<tr><td><code id="dkmap_+3A_lit">lit</code></td>
<td>
<p>logical, specifying if lighting calculation should take place on geometry</p>
</td></tr>
<tr><td><code id="dkmap_+3A_cex">cex</code></td>
<td>
<p>a numerical value giving the amount by which plotting text and symbols should be magnified
relative to the default. This starts as 1 when a device is opened, and is reset when the layout is
changed, e.g. by setting mfrow.</p>
</td></tr>
<tr><td><code id="dkmap_+3A_cex.axis">cex.axis</code></td>
<td>
<p>the magnification to be used for legend axis annotation relative to the current setting of cex.</p>
</td></tr>
<tr><td><code id="dkmap_+3A_cex.main">cex.main</code></td>
<td>
<p>the magnification to be used for main titles relative to the current setting of cex.</p>
</td></tr>
<tr><td><code id="dkmap_+3A_cex.sub">cex.sub</code></td>
<td>
<p>the magnification to be used for sub-titles relative to the current setting of cex.</p>
</td></tr>
<tr><td><code id="dkmap_+3A_cex.lab">cex.lab</code></td>
<td>
<p>the magnification to be used for legend labels relative to the current setting of cex.</p>
</td></tr>
<tr><td><code id="dkmap_+3A_family">family</code></td>
<td>
<p>the name of a font family for drawing text. The maximum allowed length is 200
bytes.
This name gets mapped by each graphics device to a device-specific font description.
The default value is &quot;&quot; which means that the default device fonts will be used (and what those
are should be listed on the help page for the device).
Standard values are &quot;serif&quot;, &quot;sans&quot; and &quot;mono&quot;, and the Hershey font families are also
available.</p>
</td></tr>
<tr><td><code id="dkmap_+3A_font.axis">font.axis</code></td>
<td>
<p>the font to be used for axis annotation.</p>
</td></tr>
<tr><td><code id="dkmap_+3A_font.lab">font.lab</code></td>
<td>
<p>the font to be used for the legend axis</p>
</td></tr>
<tr><td><code id="dkmap_+3A_font.main">font.main</code></td>
<td>
<p>the font to be used for plot main titles.</p>
</td></tr>
<tr><td><code id="dkmap_+3A_font.sub">font.sub</code></td>
<td>
<p>the font to be used for plot sub-titles.</p>
</td></tr>
<tr><td><code id="dkmap_+3A_main">main</code></td>
<td>
<p>the main title (on top) using font, size (character expansion) and color par(c(&quot;font.main&quot;, &quot;cex.main&quot;, &quot;col.main&quot;))</p>
</td></tr>
<tr><td><code id="dkmap_+3A_sub">sub</code></td>
<td>
<p>sub-title (at bottom) using font, size and color par(c(&quot;font.sub&quot;, &quot;cex.sub&quot;, &quot;col.sub&quot;))</p>
</td></tr>
<tr><td><code id="dkmap_+3A_legend">legend</code></td>
<td>
<p>a logical indicating whether a legend should be displayed.</p>
</td></tr>
<tr><td><code id="dkmap_+3A_legend.lab">legend.lab</code></td>
<td>
<p>a label for the legend axis.</p>
</td></tr>
<tr><td><code id="dkmap_+3A_legend.type">legend.type</code></td>
<td>
<p>a character string specifying the type of legend to be used; default is
&quot;stack&quot;, which corresponds to a stacked vertical legend; &quot;pie&quot; generates a pie-shaped legend and &quot;log&quot; generates
a stacked vertical legend, but does a log transformation of the data (base: e=exp(1)). The &quot;log&quot; is mostly useful
for DNE maps.</p>
</td></tr>
<tr><td><code id="dkmap_+3A_windowrect">windowRect</code></td>
<td>
<p>the dimensions of the rgl window (default is the current size or, if size is below 1000*800, c(20, 20, 1020, 820))</p>
</td></tr>
<tr><td><code id="dkmap_+3A_orient">orient</code></td>
<td>
<p>the orientation of the view. For more details, see <code><a href="#topic+dksetview">dksetview</a></code></p>
</td></tr>
<tr><td><code id="dkmap_+3A_bbox">bbox</code></td>
<td>
<p>a logical, if TRUE a bounding box will be displayed around the surface object</p>
</td></tr>
<tr><td><code id="dkmap_+3A_origin">origin</code></td>
<td>
<p>logical, whether to set the z of the mesh's lowermost point to zero</p>
</td></tr>
<tr><td><code id="dkmap_+3A_scalebar">scalebar</code></td>
<td>
<p>A logical indicating whether a scalebar should be displayed</p>
</td></tr>
<tr><td><code id="dkmap_+3A_smooth">smooth</code></td>
<td>
<p>A logical indicating whether the color of polygons should blend with neighbor polygons for a smoother rendering</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An rgl window displaying the topography of a variable over a 3d mesh.
</p>


<h3>See Also</h3>

<p><code><a href="rgl.html#topic+rgl">rgl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Map of orientation:
orient &lt;- orient(dkmodel$complex)
dkmap(dkmodel$complex, orient, col.levels = 8, col = "orient",
legend.lab = "Orientation (degrees)",legend.type = "pie", min.range = 0,
max.range = 360, orient = "occlusal")

#Map of area-relative curvature:
arc &lt;- arc(dkmodel$complex)
dkmap(dkmodel$complex, arc, col = "arc", legend.lab = "ARC",
min.range = -20, max.range = 20, col.levels = 15, orient = "occlusal")

#Map of Dirichlet normal energy:
dne &lt;- dne(dkmodel$complex)
dkmap(dkmodel$complex, dne, col = "dne", legend.lab = "DNE",
legend.type = "log", orient = "occlusal")

#Map of 3d-Area of polygons (for surface checking):
dkmap(dkmodel$complex, Rvcg::vcgArea(dkmodel$complex, perface = TRUE)$pertriangle,
legend.lab = "3d Area (mm\U00B2)", orient = "occlusal")
</code></pre>

<hr>
<h2 id='dkmodel'>dkmodel</h2><span id='topic+dkmodel'></span>

<h3>Description</h3>

<p>A list containing theoretical model surfaces corresponding to a flat surface, a single cusp, a shallow basin and a complex surface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dkmodel
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 4.
</p>


<h3>Source</h3>

<p><a href="https://github.com/nialsiG/A-comparison-of-relief-estimates-used-in-3d-dental-topography">https://github.com/nialsiG/A-comparison-of-relief-estimates-used-in-3d-dental-topography</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Flat_surface &lt;- dkmodel$flat
Single_cusp &lt;- dkmodel$cusp
Shallow_basin &lt;- dkmodel$basin
Complex_surface &lt;- dkmodel$complex
</code></pre>

<hr>
<h2 id='dkorigin'>dkorigin</h2><span id='topic+dkorigin'></span>

<h3>Description</h3>

<p>Sets the lowermost point of the mesh to 0 on the Z-axis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dkorigin(mesh)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dkorigin_+3A_mesh">mesh</code></td>
<td>
<p>object of class mesh3d</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class mesh3d.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Map of elevation before using dkorigin:
dkmap(dkpongo$OES, doolkit::elev(dkpongo$OES), col = "elev", legend.lab = "Elevation (mm)")

#Map of elevation after dkorigin:
leveled &lt;- dkorigin(dkpongo$OES)
dkmap(leveled, doolkit::elev(leveled), col = "elev", legend.lab = "Elevation (mm)")
</code></pre>

<hr>
<h2 id='dkpongo'>dkpongo</h2><span id='topic+dkpongo'></span>

<h3>Description</h3>

<p>A dataset containing the OES and the EDJ surfaces of a <em>Pongo pygmaeus</em> upper second molar (SMF-1117)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dkpongo
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 2.
</p>


<h3>Source</h3>

<p><a href="https://www.morphosource.org/Detail/MediaDetail/Show/media_id/42357">https://www.morphosource.org/Detail/MediaDetail/Show/media_id/42357</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Pongo_OES &lt;- dkpongo$OES
Pongo_EDJ &lt;- dkpongo$EDJ
</code></pre>

<hr>
<h2 id='dkprofile'>cumulative profile, its slope and the area under its curve</h2><span id='topic+dkprofile'></span>

<h3>Description</h3>

<p>A function for drawing the cumulative profile of a variable, computing the area under the curve and
the slope of the profile at the arithmetic mean of the variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dkprofile(
  x,
  type = "cartesian",
  xlab = paste("cumulated frequency (%)"),
  ylab = "",
  main = "",
  col = "red",
  alpha = 1,
  size = 1,
  linetype = "solid"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dkprofile_+3A_x">x</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
<tr><td><code id="dkprofile_+3A_type">type</code></td>
<td>
<p>a character string indicating the type of coordinates to use
(&quot;cartesian&quot;, &quot;polar&quot; etc.). Currently only &quot;cartesian&quot; is supported.</p>
</td></tr>
<tr><td><code id="dkprofile_+3A_xlab">xlab</code></td>
<td>
<p>title of the x axis</p>
</td></tr>
<tr><td><code id="dkprofile_+3A_ylab">ylab</code></td>
<td>
<p>title of the y axis</p>
</td></tr>
<tr><td><code id="dkprofile_+3A_main">main</code></td>
<td>
<p>main title of the plot</p>
</td></tr>
<tr><td><code id="dkprofile_+3A_col">col</code></td>
<td>
<p>the color of data points</p>
</td></tr>
<tr><td><code id="dkprofile_+3A_alpha">alpha</code></td>
<td>
<p>numeric indicating the alpha value of data points</p>
</td></tr>
<tr><td><code id="dkprofile_+3A_size">size</code></td>
<td>
<p>the size of data points</p>
</td></tr>
<tr><td><code id="dkprofile_+3A_linetype">linetype</code></td>
<td>
<p>the type of line to be traced (see ggplot2)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing (1) the area under the curve of the profile, (2) the profile to be drawn,
and (3) the slope of the profile at the mean of the variable.
</p>


<h3>References</h3>

<p><a href="https://doi.org/10.3389/fphys.2017.00524">doi:10.3389/fphys.2017.00524</a>Thiery et al. (2017)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Elevation (hypsometric) profile (see Thiery et al., 2017):
dkprofile(elev(dkpongo$OES), main = "Elevation profile - Pongo pygmaeus",
ylab = "Elevation (%)", col = "#0072B2", linetype = "solid")

#Enamel-dentine distance (pachymetric) profile:
dkprofile(oedist(dkpongo$OES, dkpongo$EDJ),
main = "Elevation profile - Pongo pygmaeus", ylab = "Distance (%)",
col = "#F0E442", linetype = "dashed")

#Curvature (kurtometric) profile:
dkprofile(Rvcg::vcgCurve(dkpongo$OES)$meanitmax,
main = "Curvature profile - Pongo pygmaeus", ylab = "Curvature (%)",
col = "#D55E00", linetype = "dotted")

</code></pre>

<hr>
<h2 id='dksetview'>preset orientations</h2><span id='topic+dksetview'></span>

<h3>Description</h3>

<p>A function to orient 3d topographical maps using preset values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dksetview(orient = "occlusal")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dksetview_+3A_orient">orient</code></td>
<td>
<p>a character string indicating the targeted orientation (default is occlusal)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sets the orientation of the 'rgl' window.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dkmap">dkmap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>inclinCusp &lt;- inclin(dkmodel$cusp)
dkmap(dkmodel$cusp, inclinCusp, col = "inclin", min.range = 0, max.range = 180)
dksetview()
#possible orientations are "distal", "left", "occlusal", "mesial" and "right"
</code></pre>

<hr>
<h2 id='dne'>Dirichlet normal energy</h2><span id='topic+dne'></span>

<h3>Description</h3>

<p>Compute the Dirichlet normal energy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dne(mesh, range = 0.999, total = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dne_+3A_mesh">mesh</code></td>
<td>
<p>object of class mesh3d</p>
</td></tr>
<tr><td><code id="dne_+3A_range">range</code></td>
<td>
<p>an integer between 0 and 1 indicating the percentage of values
to consider for the computation. Following Pampush et al. (2016) default is
set to 0.999.</p>
</td></tr>
<tr><td><code id="dne_+3A_total">total</code></td>
<td>
<p>logical, should the result of the function be the total DNE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The current algorithm gives a different estimate of DNE when compared with the
values obtained using the molaR package. Albeit small, this difference likely comes from
different methods of border selection. The doolkit package uses the function dkborder,
which accurately selects every polygon sharing a vertex (or more) with the border.
</p>


<h3>Value</h3>

<p>If total = FALSE, a numeric vector of dne values for all the polygons of the
mesh. If total = TRUE, a single DNE value, calculated as the sum of the
products of polygon normal energies * polygon areas.
</p>


<h3>References</h3>

<p><a href="https://doi.org/10.1002/ajpa.21489">doi:10.1002/ajpa.21489</a>Bunn et al. (2011)
</p>
<p><a href="https://doi.org/10.1007/s10914-016-9326-0">doi:10.1007/s10914-016-9326-0</a>Pampush et al. (2016)
</p>


<h3>See Also</h3>

<p><code><a href="molaR.html#topic+DNE">DNE</a></code>
</p>
<p><code><a href="#topic+dkborder">dkborder</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dne &lt;- dne(dkmodel$complex)
summary(dkmodel$complex)

#total DNE value corresponds to the sum of products Dne * Area:
round(sum(dne*Rvcg::vcgArea(dkmodel$complex, perface = TRUE)$pertriangle), 3)
#can be directly computed using \code{dne}:
dne(dkmodel$complex, total = TRUE)

#render on a map:
dkmap(dkmodel$complex, dne, legend.type = "log", col = "dne")
</code></pre>

<hr>
<h2 id='elev'>elevation</h2><span id='topic+elev'></span>

<h3>Description</h3>

<p>Compute the elevation (z component of triangle barycenter).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elev(mesh, origin = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elev_+3A_mesh">mesh</code></td>
<td>
<p>object of class mesh3d</p>
</td></tr>
<tr><td><code id="elev_+3A_origin">origin</code></td>
<td>
<p>logical, if TRUE the z of the mesh is adjusted so that the lowest z = 0
(see <code><a href="#topic+dkorigin">dkorigin</a></code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of elevation values for all the polygons of the mesh.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+inclin">inclin</a></code>
</p>
<p><code><a href="#topic+rfi">rfi</a></code>
</p>
<p><code><a href="#topic+slope">slope</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>elev &lt;- elev(dkmodel$cusp)
summary(elev)

#render on a map:
dkmap(dkmodel$cusp, elev)
</code></pre>

<hr>
<h2 id='hypso'>hypso</h2><span id='topic+hypso'></span>

<h3>Description</h3>

<p>Compute the maximum height, length, width and corresponding
hypsodonty index (ratio of the maximum height over the maximum length)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hypso(mesh, origin = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hypso_+3A_mesh">mesh</code></td>
<td>
<p>object of class mesh3d</p>
</td></tr>
<tr><td><code id="hypso_+3A_origin">origin</code></td>
<td>
<p>logical, whether to set the z of the mesh's lowermost point
to zero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of values for hypsodonty index, height, length and width of
the mesh. The hypsodonty index is not expressed relative to 100 but to 1.
Note: the tooth surface is expected to be oriented such as the X-axis
is the bucco-lingual axis, the Y-axis is the mesio-distal axis, and the
occlusal plane is parallel to the (XY) plane and faces upward.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hypso(dkmodel$cusp)
</code></pre>

<hr>
<h2 id='inclin'>inclin</h2><span id='topic+inclin'></span>

<h3>Description</h3>

<p>Compute inclination i.e. the angle between triangles and the vertical plane in degrees, comprised
between 0 and 180.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inclin(mesh)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inclin_+3A_mesh">mesh</code></td>
<td>
<p>object of class mesh3d</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of inclination values for all the polygons of the mesh.
</p>


<h3>References</h3>

<p><a href="https://doi.org/10.1371/journal.pone.0066142">doi:10.1371/journal.pone.0066142</a>Guy et al. (2013)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+slope">slope</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>inclin &lt;- inclin(dkmodel$cusp)
summary(inclin)

#render on a map:
dkmap(dkmodel$cusp, inclin, col = "inclin",
min.range = 0, max.range = 180, legend = TRUE)
</code></pre>

<hr>
<h2 id='oedist'>Distance from outer enamel surface to enamel dentine junction</h2><span id='topic+oedist'></span>

<h3>Description</h3>

<p>Compute the distance from enamel vertices to dentine mesh.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oedist(oes, edj, ray = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oedist_+3A_oes">oes</code></td>
<td>
<p>object of class mesh3d; should be the outer enamel surface</p>
</td></tr>
<tr><td><code id="oedist_+3A_edj">edj</code></td>
<td>
<p>object of class mesh3d; should be the enamel-dentine junction</p>
</td></tr>
<tr><td><code id="oedist_+3A_ray">ray</code></td>
<td>
<p>logical, if TRUE the search is along vertex normals (default is FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of vertex-to-mesh distance values for all the polygons of the x mesh.
</p>


<h3>References</h3>

<p><a href="https://doi.org/10.1371/journal.pone.0066142">doi:10.1371/journal.pone.0066142</a>Guy et al. (2013)
</p>
<p><a href="https://doi.org/10.1371/journal.pone.0138802">doi:10.1371/journal.pone.0138802</a>Guy et al. (2015)
</p>
<p><a href="https://doi.org/10.3389/fphys.2017.00524">doi:10.3389/fphys.2017.00524</a>Thiery et al. (2017)
</p>
<p><a href="https://doi.org/10.1098/rsbl.2019.0671">doi:10.1098/rsbl.2019.0671</a>Schwartz et al. (2020)
</p>


<h3>See Also</h3>

<p><code><a href="Morpho.html#topic+meshDist">meshDist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>edd &lt;- oedist(dkmodel$cusp, dkmodel$flat)
summary(edd)
AETgeom &lt;- mean(edd)
#Geometric relative enamel thickness, obtained by dividing AETgeom by the
#square root of EDJ area
#Note: it is different from classic RET which requires the volume of the
#dentine inside the enamel cap (see Thiery et al., 2017)
AETgeom/sqrt(Rvcg::vcgArea(dkmodel$flat))
#Absolute crown strength:
edj_radius &lt;- max(dist(cbind(dkmodel$flat$vb[1,], dkmodel$flat$vb[2,])))/2
sqrt(mean(edd) * edj_radius)

#render on a map:
oedist &lt;- doolkit::oedist(dkmodel$cusp, dkmodel$flat)
dkmap(dkmodel$cusp, oedist)
#distance map can also be rendered on EDJ surface:
eodist &lt;- oedist(dkmodel$flat, dkmodel$cusp)
dkmap(dkmodel$flat, eodist)
</code></pre>

<hr>
<h2 id='opc'>orientation patch count</h2><span id='topic+opc'></span>

<h3>Description</h3>

<p>Count the number of orientation patches using <code><a href="#topic+poly.network">poly.network</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opc(mesh, bins = 8, min.size = 3, rotation = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opc_+3A_mesh">mesh</code></td>
<td>
<p>object of class mesh3d</p>
</td></tr>
<tr><td><code id="opc_+3A_bins">bins</code></td>
<td>
<p>the number of orientation bins to be defined (default set to 8)</p>
</td></tr>
<tr><td><code id="opc_+3A_min.size">min.size</code></td>
<td>
<p>the minimal amount of polygons defining a &quot;patch&quot; (default set to 3)</p>
</td></tr>
<tr><td><code id="opc_+3A_rotation">rotation</code></td>
<td>
<p>if applicable, the number of degrees to which bins are to be rotated.
By default the bins start from an angle of pi/2 and rotates clockwise.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame displaying the number of patches and their size (number of triangles)
for each orientation bin. Note: if you want the surface area of each patch, see<code><a href="#topic+poly.network">poly.network</a></code>
</p>


<h3>References</h3>

<p><a href="https://doi.org/10.1038/nature05433">doi:10.1038/nature05433</a>Evans et al. (2007)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+orient">orient</a></code>
</p>
<p><code><a href="#topic+opcr">opcr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#8 bins (default):
opc &lt;- opc(dkmodel$complex)
#8 bins starting from mesial, as in Evans et al. 2007:
opc &lt;- opc(dkmodel$complex, rotation = -(360/16))
#4 bins (mesial, buccal, distal and lingual):
opc &lt;- opc(dkmodel$complex, bins = 4, rotation = -(360/8))

</code></pre>

<hr>
<h2 id='opcr'>orientation patch count rotated</h2><span id='topic+opcr'></span>

<h3>Description</h3>

<p>Compute the orientation patch count rotated of a triangle mesh.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opcr(mesh, bins = 8, min.size = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opcr_+3A_mesh">mesh</code></td>
<td>
<p>object of class mesh3d</p>
</td></tr>
<tr><td><code id="opcr_+3A_bins">bins</code></td>
<td>
<p>the number of orientation bins to be defined (default set to 8)</p>
</td></tr>
<tr><td><code id="opcr_+3A_min.size">min.size</code></td>
<td>
<p>the minimal amount of polygons defining a &quot;patch&quot; (default set to 3)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame displaying the number of patches and their size (number of triangles)
for each orientation bin.
</p>


<h3>References</h3>

<p><a href="https://doi.org/10.1038/nature10880">doi:10.1038/nature10880</a>Wilson et al. (2012)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+opc">opc</a></code>
</p>
<p><code><a href="#topic+orient">orient</a></code>
</p>
<p><code><a href="molaR.html#topic+OPCr">OPCr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#8bins (default):
opcr &lt;- opcr(dkmodel$complex)
#16 bins (computation time increase exponentially):
opcr &lt;- opcr(dkmodel$complex, bins = 16)
</code></pre>

<hr>
<h2 id='orient'>orientation of polygons</h2><span id='topic+orient'></span>

<h3>Description</h3>

<p>Returns the occlusal orientation (exposure in GIS)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orient(mesh)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="orient_+3A_mesh">mesh</code></td>
<td>
<p>object of class mesh3d</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of occlusal orientation values in degrees for all
the polygons of the mesh.
Let the orientation from above be depicted as a trigonomical circle,
then for a tooth positioned as in Guy et al. (2015) an orientation of 0 (mesial) would
be located at an angle of pi/2, and an orientation of 90° (buccal) would
be located at an angle of 2*pi.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+opc">opc</a></code>
</p>
<p><code><a href="#topic+opcr">opcr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>orient &lt;- orient(dkmodel$complex)
summary(orient)

</code></pre>

<hr>
<h2 id='poly.network'>Identify polygon networks</h2><span id='topic+poly.network'></span>

<h3>Description</h3>

<p>From a selected variable y, identifies patches of adjacent polygons
that share a given range of y values. These patches are called ’polygon networks’.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poly.network(
  mesh,
  y,
  lwr.limit = stats::quantile(y, 0.75),
  upr.limit = stats::quantile(y, 1),
  min.size = 3
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="poly.network_+3A_mesh">mesh</code></td>
<td>
<p>object of class mesh3d</p>
</td></tr>
<tr><td><code id="poly.network_+3A_y">y</code></td>
<td>
<p>a vector of indices to be used to select polygons</p>
</td></tr>
<tr><td><code id="poly.network_+3A_lwr.limit">lwr.limit</code></td>
<td>
<p>the lower range of values to be selected from y</p>
</td></tr>
<tr><td><code id="poly.network_+3A_upr.limit">upr.limit</code></td>
<td>
<p>the upper range of values to be selected from y</p>
</td></tr>
<tr><td><code id="poly.network_+3A_min.size">min.size</code></td>
<td>
<p>the minimum amount of polygons defining a cluster. Default is set to 3.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"<a href="#topic+polygon.network-class">polygon.network</a>"</code> composed of
the face index and the membership of each triangle answering the set conditions. The function
makes patches of contiguous triangles, and each patch is indexed with a unique number corresponding
to its membership.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Isolate cusps using elevation:
mythreshold &lt;- quantile(elev(dkmodel$cusp), 0.65)
cusps &lt;- poly.network(dkmodel$cusp, elev(dkmodel$cusp), lwr.limit = mythreshold,
min.size = 100)
myvector &lt;- rep(0, Rvcg::nfaces(dkmodel$cusp))
myvector[cusps@faces] &lt;- cusps@membership[]
myvector &lt;- as.factor(myvector)
ncusps &lt;- length(levels(myvector)) - 1
levels(myvector) &lt;- c(0:ncusps + 1)
dkmap(dkmodel$cusp, as.numeric(myvector), col = cbPalette &lt;- c("#000000", "#E69F00",
"#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7"),
col.levels = ncusps + 1, legend.lab = "Elevation (mm)")

#Any other variables could be used to define the clusters
#Mean curvature:
crests &lt;- poly.network(dkmodel$complex, Rvcg::vcgCurve(dkmodel$complex)$meanitmax,
lwr.limit = quantile(Rvcg::vcgCurve(dkmodel$complex)$meanitmax, 0.8), min.size = 10)
doolkit::dkmap(mesh = dkmodel$complex, y = doolkit::arc(dkmodel$complex,
range = c(-20, 20)), col = "arc", col.levels = 256, min.range = -20,
max.range = 20, orient = "occlusal", legend.lab = "ARC",
alpha.thresh = quantile(doolkit::arc(dkmodel$complex), 0.8), alpha = 0.3,
alpha.above = FALSE)

#Orientation and surface of patches:
patch_orient &lt;- data.frame(bin = NULL, patch = NULL, size = NULL, surface = NULL)
for (i in 1:8) {
  Cluster &lt;- poly.network(dkmodel$complex, orient(dkmodel$complex),
  lwr.limit = 45 * (i - 1), upr.limit = 45 * i)
  Patches &lt;- levels(as.factor(Cluster@membership))
  Bins &lt;- rep(paste(45 * (i - 1), "-", 45 * i), length(Patches))
  Areas &lt;- rep(0, length(Patches))
  for (j in 1:length(Patches)) {
    test &lt;- Cluster@faces[Cluster@membership == Patches[j]]
    Areas[j] &lt;- round(sum(Rvcg::vcgArea(dkmodel$complex,
    perface = TRUE)$pertriangle[test]), 3)
  }
  patch_orient &lt;- data.frame(rbind(patch_orient,
  cbind.data.frame(Bins, Patches, Areas)))
}
#Since patches made of 3 or less polygons are discarded,
#sum of patch areas &lt; total surface area:
sum(patch_orient$Areas)
Rvcg::vcgArea(dkmodel$complex)

</code></pre>

<hr>
<h2 id='polygon.network-class'>S4 class for polygon networks</h2><span id='topic+polygon.network-class'></span><span id='topic+polygon.network'></span>

<h3>Description</h3>

<p>Polygon networks are subgraphs made of polygons
(i) sharing topographic features and
(ii) in contact with the rest of the subgraph by at least 1 polygon edge.
Objects of S4 class <code>polygon.network</code> are typically made using the function
<code><a href="#topic+poly.network">poly.network</a></code>
</p>


<h3>Slots</h3>


<dl>
<dt><code>membership</code></dt><dd><p>a vector of numeric values specifying, for each triangle, the
index number of the patch to which the triangle is assigned</p>
</dd>
<dt><code>faces</code></dt><dd><p>a vector of numeric values indicating the mesh triangle indexes</p>
</dd>
</dl>

<hr>
<h2 id='rfi'>relief index</h2><span id='topic+rfi'></span>

<h3>Description</h3>

<p>Compute the relief index of a  3d triangle mesh.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rfi(mesh, method = "Ungar", hull = "concave")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rfi_+3A_mesh">mesh</code></td>
<td>
<p>object of class mesh3d</p>
</td></tr>
<tr><td><code id="rfi_+3A_method">method</code></td>
<td>
<p>a character string indicating which method is to be used for the computation of
relief index</p>
</td></tr>
<tr><td><code id="rfi_+3A_hull">hull</code></td>
<td>
<p>the method used to compute the hull of the 2d projection, either 'convex' or 'concave'.
The default method is 'convex'. See <code><a href="#topic+area2d">area2d</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>As of version 1.42.2, the concave hull fails intermittently on Mac systems, so the function
defaults to convex hulls (on other systems, it defaults to concave hulls).
</p>


<h3>Value</h3>

<p>A single relief index value.
</p>


<h3>References</h3>

<p><a href="https://doi.org/10.1016/j.jhevol.2008.08.002">doi:10.1016/j.jhevol.2008.08.002</a>Boyer (2008)
<a href="https://doi.org/10.1371/journal.pone.0066142">doi:10.1371/journal.pone.0066142</a>Guy et al. (2013)
<a href="https://palaeo-electronica.org/2000_1/gorilla/issue1_00.htm">Ungar and Williamson (2000)</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+area2d">area2d</a></code>
</p>
<p><code><a href="molaR.html#topic+RFI">RFI</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rfi &lt;- rfi(dkmodel$cusp, method = "Ungar", hull = "convex")
lrfi &lt;- rfi(dkmodel$cusp, method = "Boyer", hull = "convex")
gamma &lt;- rfi(dkmodel$cusp, method = "Guy")
</code></pre>

<hr>
<h2 id='rrate'>relief rate</h2><span id='topic+rrate'></span>

<h3>Description</h3>

<p>Compute the relief rate from a sub-sample of a 3d triangle mesh.
For instance, the relief rate could be computed from the portion of a molar above
the lowermost point of its central basin, compared to the whole tooth.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rrate(uncropped, cropped, origin = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rrate_+3A_uncropped">uncropped</code></td>
<td>
<p>object of class mesh3d. Should entirely contain the 'cropped' argument.</p>
</td></tr>
<tr><td><code id="rrate_+3A_cropped">cropped</code></td>
<td>
<p>object of class mesh3d. Should be part of the 'uncropped' argument.</p>
</td></tr>
<tr><td><code id="rrate_+3A_origin">origin</code></td>
<td>
<p>logical, if TRUE both cropped and uncropped mesh are translated along the z-axis
so that the lowest z of the uncropped mesh = 0; see <code><a href="#topic+dkorigin">dkorigin</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single relief rate value.
</p>


<h3>References</h3>

<p><a href="https://doi.org/10.1002/ajpa.23916">doi:10.1002/ajpa.23916</a>Thiery et al. (2019)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>medelev &lt;- median(elev(dkmodel$cusp))
basins &lt;- dkcrop(dkmodel$cusp, which(elev(dkmodel$cusp) &lt; medelev))
cusps &lt;- dkcrop(dkmodel$cusp, which(elev(dkmodel$cusp) &gt; medelev))

rrate(dkmodel$cusp, basins)
rrate(dkmodel$cusp, cusps)
</code></pre>

<hr>
<h2 id='shape.index'>shape.index</h2><span id='topic+shape.index'></span>

<h3>Description</h3>

<p>Compute various shape indices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shape.index(mesh, origin = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shape.index_+3A_mesh">mesh</code></td>
<td>
<p>object of class mesh3d</p>
</td></tr>
<tr><td><code id="shape.index_+3A_origin">origin</code></td>
<td>
<p>logical, if TRUE the z of the mesh is adjusted so that the lowest z = 0;
see <code><a href="#topic+dkorigin">dkorigin</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>A handful of indices have been developed to characterize the shape of natural
landscapes, including drainage basins. While some indices are very scale-sensitive (e.g.,
Gravelius' compactness coefficient), others are dimensionless.
Horton (1932) introduced a form factor computed as the quotient of the basin's surface area
over the square of the maximum basin length. Schumm (1956) developed a basin elongation index
computed as the quotient of twice the square root of surface area over the product of basin
length and the squareroot of pi. Lastly, Chorley et al. (1957) developed a lemniscate ratio
which corresponds to the ratio between the surface of a lemniscate of same length over the
basin area,and computed as (pi*(Length^2))/(4*Area).
</p>


<h3>Value</h3>

<p>A list of indices:
</p>

<ul>
<li><p> Form factor (Horton, 1932)
</p>
</li>
<li><p> Basin elongation (Schum, 1956)
</p>
</li>
<li><p> Lemniscate ratio 'K' (Chorley et al., 1957)
</p>
</li></ul>



<h3>References</h3>

<p><a href="https://doi.org/10.1029/TR013i001p00350">doi:10.1029/TR013i001p00350</a>Horton (1932)
</p>
<p><a href="https://doi.org/10.1130/0016-7606%281956%2967%5B597%3AEODSAS%5D2.0.CO%3B2">doi:10.1130/0016-7606(1956)67[597:EODSAS]2.0.CO;2</a>Schumm (1956)
</p>
<p><a href="https://doi.org/10.2475/ajs.255.2.138">doi:10.2475/ajs.255.2.138</a>Chorley et al. (1957)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ShapInd &lt;- shape.index(dkmodel$basin)
ShapInd$FormFactor
ShapInd$Elongation
ShapInd$K
</code></pre>

<hr>
<h2 id='slope'>slope</h2><span id='topic+slope'></span>

<h3>Description</h3>

<p>Compute slope i.e. the angle between triangles and the horizontal plane in degrees, comprised
between 0 and 90.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slope(mesh)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slope_+3A_mesh">mesh</code></td>
<td>
<p>object of class mesh3d</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of slope values for all the polygons of the mesh.
</p>


<h3>References</h3>

<p><a href="https://palaeo-electronica.org/2000_1/gorilla/issue1_00.htm">Ungar and Williamson (2000)</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+inclin">inclin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>slope &lt;- slope(dkmodel$cusp)
summary(slope)

#render on a map:
dkmap(dkmodel$cusp, slope, col.levels = 9, col = "slope",
min.range = 0, max.range = 90, legend = TRUE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
