<!DOCTYPE html><html><head><title>Help for package gtfs2gps</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gtfs2gps}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adjust_arrival_departure'><p>Adjust the arrival and departure times of a GTFS data</p></a></li>
<li><a href='#adjust_speed'><p>Adjust the speeds of a gps-like table created with <code>gtfs2gps</code></p></a></li>
<li><a href='#append_height'><p>Add a column with height to GPS data</p></a></li>
<li><a href='#filter_single_trip'><p>Filter GTFS trips in order to have one trip per shape_id</p></a></li>
<li><a href='#filter_valid_stop_times'><p>Filter GTFS data using valid stop times</p></a></li>
<li><a href='#gps_as_sflinestring'><p>Converts a GPS-like data.table to a LineString Simple Feature (sf) object</p></a></li>
<li><a href='#gps_as_sfpoints'><p>Convert GPS-like data.table to a Simple Feature points object</p></a></li>
<li><a href='#gtfs_shapes_as_sf'><p>Convert GTFS shapes to simple feature object</p></a></li>
<li><a href='#gtfs_stops_as_sf'><p>Convert GTFS stops to simple feature object</p></a></li>
<li><a href='#gtfs2gps'><p>Convert GTFS to GPS-like data given a spatial resolution</p></a></li>
<li><a href='#read_gtfs'><p>Read GTFS data into a list of data.tables</p></a></li>
<li><a href='#remove_invalid'><p>Remove invalid objects from GTFS data</p></a></li>
<li><a href='#simplify_shapes'><p>Simplify shapes of a GTFS file</p></a></li>
<li><a href='#test_gtfs_freq'><p>Test whether a GTFS feed is frequency based</p></a></li>
<li><a href='#write_gtfs'><p>Write GTFS data into a zip file</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Converting Transport Data from GTFS Format to GPS-Like Records</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1-1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-04-28</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ipeaGIT/gtfs2gps">https://github.com/ipeaGIT/gtfs2gps</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ipeaGIT/gtfs2gps/issues">https://github.com/ipeaGIT/gtfs2gps/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Convert general transit feed specification (GTFS) data to global positioning system (GPS) records in 'data.table' format. It also has some functions to subset GTFS data in time and space and to convert both representations to simple feature format.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>magrittr, rmarkdown, markdown, knitr, testthat, dplyr, bit64</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table, furrr, future, gtfstools, Rcpp, units, sf, terra,
sfheaders, progressr, lwgeom, checkmate</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-28 17:35:48 UTC; pedro</td>
</tr>
<tr>
<td>Author:</td>
<td>Rafael H. M. Pereira
    <a href="https://orcid.org/0000-0003-2125-7465"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Pedro R. Andrade <a href="https://orcid.org/0000-0001-8675-4046"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Joao Bazzo <a href="https://orcid.org/0000-0003-4536-5006"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Daniel Herszenhut <a href="https://orcid.org/0000-0001-8066-1105"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Marcin Stepniak [ctb],
  Marcus Saraiva <a href="https://orcid.org/0000-0001-6218-2338"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Ipea - Institue for Applied Economic Research [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Pedro R. Andrade &lt;pedro.andrade@inpe.br&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-04-28 19:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='adjust_arrival_departure'>Adjust the arrival and departure times of a GTFS data</h2><span id='topic+adjust_arrival_departure'></span>

<h3>Description</h3>

<p>Some GTFS.zip data have issues related to arrival and departure
time on stops. This function makes sure the GTFS has dis/embarking times at
each stop. For each stop time row, this function applies the following steps:
</p>
<p>1. If there is 'arrival_time' but no 'departure_time', it creates a departure_time 
column by summing the arrival plus a pre-defined 'min_lag'.
</p>
<p>2. If there is 'departure_time' but no 'arrival_time', it creates an arrival_time 
column by subtracting a pre-defined 'min_lag' from the departure.
</p>
<p>3. If there is an 'arrival_time' and a 'departure_time' but their difference
is smaller than 'min_lag', it reduces the 'arrival_time' and increases
'departure_time' so that the difference will be exactly 'min_lag'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjust_arrival_departure(gtfs_data, min_lag = 20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjust_arrival_departure_+3A_gtfs_data">gtfs_data</code></td>
<td>
<p>A GTFS data created with <code><a href="#topic+read_gtfs">read_gtfs</a></code>.</p>
</td></tr>
<tr><td><code id="adjust_arrival_departure_+3A_min_lag">min_lag</code></td>
<td>
<p>Numeric. Minimum waiting time when a vehicle arrives 
at a stop. It can be a numeric or a units value that can be converted
to seconds. Default is 20s.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A GTFS with adjusted 'arrival_time' and 'departure_time' on
data.table 'stop_times'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>poa &lt;- read_gtfs(system.file("extdata/poa.zip", package="gtfs2gps"))

poa &lt;- adjust_arrival_departure(poa)
</code></pre>

<hr>
<h2 id='adjust_speed'>Adjust the speeds of a gps-like table created with <code><a href="#topic+gtfs2gps">gtfs2gps</a></code></h2><span id='topic+adjust_speed'></span>

<h3>Description</h3>

<p>Some GTFS.zip data sets might have quality issues, for example 
by assuming that a trip speed is unreasonably high (e.g. an urban bus running
over 100 Km/h), or in other cases the 'timestamp' information might be
missing for some route segments. This can lead a gps-like table to have 'NA'
or unrealistic 'speed' and 'timestamp' values. This function allows the
user to adjust the speed of trips and updates 'timestamp' values 
accordingly. The user can adjust the problematic speeds by either setting a
custom constant value, or by considering the average of all valid trips speed
(Default). The columns 'timestamp' and 'cumtime' are updated accordingly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjust_speed(
  gps_data,
  min_speed = 2,
  max_speed = 80,
  new_speed = NULL,
  clone = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjust_speed_+3A_gps_data">gps_data</code></td>
<td>
<p>A GPS-like data.table created with <code><a href="#topic+gtfs2gps">gtfs2gps</a></code>.</p>
</td></tr>
<tr><td><code id="adjust_speed_+3A_min_speed">min_speed</code></td>
<td>
<p>Minimum speed to be considered as valid. It can
be a numeric (in km/h) or a units value able to be converted to km/h. Values 
below minimum speed will be adjusted. Defaults to 2 km/h.</p>
</td></tr>
<tr><td><code id="adjust_speed_+3A_max_speed">max_speed</code></td>
<td>
<p>Maximum speed to be considered as valid. It can
be a numeric (in km/h) or a units value able to be converted to km/h. Values
above maximum speed will be adjusted. Defaults to 80 km/h.</p>
</td></tr>
<tr><td><code id="adjust_speed_+3A_new_speed">new_speed</code></td>
<td>
<p>Speed to replace missing values as well as values
outside min_speed and max_speed range. It can
be a numeric (in km/h) or a units value able to be converted to km/h.
By default, 'new_speed = NULL' and the
function considers the average speed of the entire gps data.</p>
</td></tr>
<tr><td><code id="adjust_speed_+3A_clone">clone</code></td>
<td>
<p>Use a copy of the gps_data? Defaults to TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A GPS-like data with adjusted 'speed' values. The columns
'timestamp' and 'cumtime' are also updated accordingly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)
poa &lt;- read_gtfs(system.file("extdata/poa.zip", package="gtfs2gps")) %&gt;%
  gtfstools::filter_by_shape_id("T2-1") %&gt;%
  gtfstools::filter_by_weekday(c("monday", "wednesday")) %&gt;%
  filter_single_trip()

poa_gps &lt;- gtfs2gps(poa)
poa_gps_new &lt;- adjust_speed(poa_gps)
</code></pre>

<hr>
<h2 id='append_height'>Add a column with height to GPS data</h2><span id='topic+append_height'></span>

<h3>Description</h3>

<p>Add a column named height to GPS data using a tif data as reference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>append_height(gps, heightfile)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="append_height_+3A_gps">gps</code></td>
<td>
<p>A GPS data created from gtfs2gps().</p>
</td></tr>
<tr><td><code id="append_height_+3A_heightfile">heightfile</code></td>
<td>
<p>The pathname of a tif file with height data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The GPS data with a new column named height.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# this example takes more than 10s to run
library(magrittr)

fortaleza &lt;- system.file("extdata/fortaleza.zip", package = "gtfs2gps")
srtmfile &lt;- system.file("extdata/fortaleza-srtm.tif", package = "gtfs2gps")

gtfs &lt;- read_gtfs(fortaleza) %&gt;%
  gtfstools::filter_by_shape_id("shape836-I") %&gt;%
  filter_single_trip() 

fortaleza_gps &lt;- gtfs2gps(gtfs, spatial_resolution = 500) %&gt;% append_height(srtmfile)

## End(Not run)
</code></pre>

<hr>
<h2 id='filter_single_trip'>Filter GTFS trips in order to have one trip per shape_id</h2><span id='topic+filter_single_trip'></span>

<h3>Description</h3>

<p>Filter a GTFS data by keeping only one trip per shape_id.
It also removes the unnecessary routes and stop_times accordingly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_single_trip(gtfs_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_single_trip_+3A_gtfs_data">gtfs_data</code></td>
<td>
<p>A list of data.tables read using gtfs2gps::reag_gtfs().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A filtered GTFS data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>poa &lt;- read_gtfs(system.file("extdata/poa.zip", package = "gtfs2gps"))

subset &lt;- filter_single_trip(poa)
</code></pre>

<hr>
<h2 id='filter_valid_stop_times'>Filter GTFS data using valid stop times</h2><span id='topic+filter_valid_stop_times'></span>

<h3>Description</h3>

<p>Filter a GTFS data read using gtfs2gps::read_gtfs(). It removes stop_times
with NA values in arrival_time, departure_time, and arrival_time_hms. It also filters
stops and routes accordingly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_valid_stop_times(gtfs_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_valid_stop_times_+3A_gtfs_data">gtfs_data</code></td>
<td>
<p>A list of data.tables read using gtfs2gps::reag_gtfs().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A filtered GTFS data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>poa &lt;- read_gtfs(system.file("extdata/poa.zip", package = "gtfs2gps"))

subset &lt;- filter_valid_stop_times(poa)
</code></pre>

<hr>
<h2 id='gps_as_sflinestring'>Converts a GPS-like data.table to a LineString Simple Feature (sf) object</h2><span id='topic+gps_as_sflinestring'></span>

<h3>Description</h3>

<p>Every interval of GPS data points between stops for each trip_id is
converted into a linestring segment. The output assumes constant average speed 
between consecutive stops.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gps_as_sflinestring(gps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gps_as_sflinestring_+3A_gps">gps</code></td>
<td>
<p>A data.table with timestamp data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A simple feature (sf) object with LineString data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(gtfs2gps)
library(magrittr)

poa &lt;- read_gtfs(system.file("extdata/poa.zip", package = "gtfs2gps"))
poa_subset &lt;- gtfstools::filter_by_shape_id(poa, c("T2-1", "A141-1")) %&gt;%
  filter_single_trip()

poa_gps &lt;- gtfs2gps(poa_subset)

poa_gps_sf &lt;- gps_as_sflinestring(poa_gps)
</code></pre>

<hr>
<h2 id='gps_as_sfpoints'>Convert GPS-like data.table to a Simple Feature points object</h2><span id='topic+gps_as_sfpoints'></span>

<h3>Description</h3>

<p>Convert a GPS data stored in a data.table into Simple Feature points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gps_as_sfpoints(gps, crs = 4326)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gps_as_sfpoints_+3A_gps">gps</code></td>
<td>
<p>A data.table with timestamp data.</p>
</td></tr>
<tr><td><code id="gps_as_sfpoints_+3A_crs">crs</code></td>
<td>
<p>A Coordinate Reference System. The default value is 4326 (latlong WGS84).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A simple feature (sf) object with point data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(gtfs2gps)
library(magrittr)

fortaleza &lt;- read_gtfs(system.file("extdata/fortaleza.zip", package = "gtfs2gps"))
srtmfile &lt;- system.file("extdata/fortaleza-srtm.tif", package="gtfs2gps")

subset &lt;- fortaleza %&gt;%
  gtfstools::filter_by_weekday(c("monday", "wednesday")) %&gt;%
  filter_single_trip() %&gt;%
  gtfstools::filter_by_shape_id("shape806-I")

for_gps &lt;- gtfs2gps(subset)
for_gps_sf_points &lt;- gps_as_sfpoints(for_gps)
</code></pre>

<hr>
<h2 id='gtfs_shapes_as_sf'>Convert GTFS shapes to simple feature object</h2><span id='topic+gtfs_shapes_as_sf'></span>

<h3>Description</h3>

<p>Convert a GTFS shapes data loaded using gtfs2gps::read_gtf()
into a line simple feature (sf).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gtfs_shapes_as_sf(gtfs, crs = 4326)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gtfs_shapes_as_sf_+3A_gtfs">gtfs</code></td>
<td>
<p>A GTFS data.</p>
</td></tr>
<tr><td><code id="gtfs_shapes_as_sf_+3A_crs">crs</code></td>
<td>
<p>The coordinate reference system represented as an EPSG code.
The default value is 4326 (latlong WGS84)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A simple feature (sf) object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>poa &lt;- read_gtfs(system.file("extdata/saopaulo.zip", package = "gtfs2gps"))
poa_sf &lt;- gtfs_shapes_as_sf(poa)
</code></pre>

<hr>
<h2 id='gtfs_stops_as_sf'>Convert GTFS stops to simple feature object</h2><span id='topic+gtfs_stops_as_sf'></span>

<h3>Description</h3>

<p>Convert a GTFS stops data loaded using gtfs2gps::read_gtf()
into a point simple feature (sf).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gtfs_stops_as_sf(gtfs, crs = 4326)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gtfs_stops_as_sf_+3A_gtfs">gtfs</code></td>
<td>
<p>A GTFS data.</p>
</td></tr>
<tr><td><code id="gtfs_stops_as_sf_+3A_crs">crs</code></td>
<td>
<p>The coordinate reference system represented as an EPSG code.
The default value is 4326 (latlong WGS84)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A simple feature (sf) object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>poa &lt;- read_gtfs(system.file("extdata/poa.zip", package = "gtfs2gps"))
poa_shapes &lt;- gtfs_shapes_as_sf(poa)
poa_stops &lt;- gtfs_stops_as_sf(poa)
</code></pre>

<hr>
<h2 id='gtfs2gps'>Convert GTFS to GPS-like data given a spatial resolution</h2><span id='topic+gtfs2gps'></span>

<h3>Description</h3>

<p>Convert GTFS data to GPS format by sampling points using a given
spatial resolution. This function creates additional points in order to
guarantee that two points in a same trip will have at most a given
distance, indicated as a spatial resolution. It is possible to use future package
to parallelize the execution (or use argument plan). This function also
uses progressr internally to show progress bars. See the example below on how
to show a progress bar while executing this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gtfs2gps(
  gtfs_data,
  spatial_resolution = 100,
  parallel = TRUE,
  ncores = NULL,
  strategy = NULL,
  filepath = NULL,
  compress = FALSE,
  snap_method = "nearest2",
  continue = FALSE,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gtfs2gps_+3A_gtfs_data">gtfs_data</code></td>
<td>
<p>A path to a GTFS file to be converted to GPS, or a GTFS data
represented as a list of data.tables.</p>
</td></tr>
<tr><td><code id="gtfs2gps_+3A_spatial_resolution">spatial_resolution</code></td>
<td>
<p>The spatial resolution in meters. Default is 100m.
This function only creates points in order to guarantee that the minimum
distance between two consecutive points will be at most the
spatial_resolution. If a given shape has two consecutive points with a
distance lower than the spatial resolution, the algorithm will not remove
such points.</p>
</td></tr>
<tr><td><code id="gtfs2gps_+3A_parallel">parallel</code></td>
<td>
<p>Decides whether the function should run in parallel. Defaults is FALSE.
When TRUE, it will use all cores available minus one using future::plan() with
strategy &quot;multisession&quot; internally.
Note that it is possible to create your own plan before calling gtfs2gps().
In this case, do not use this argument.</p>
</td></tr>
<tr><td><code id="gtfs2gps_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to be used in parallel execution. If parallel is</p>
</td></tr>
<tr><td><code id="gtfs2gps_+3A_strategy">strategy</code></td>
<td>
<p>This argument is deprecated. Please use argument plan instead or
use future::plan() directly.</p>
</td></tr>
<tr><td><code id="gtfs2gps_+3A_filepath">filepath</code></td>
<td>
<p>Output file path. As default, the output is returned when gtfs2gps finishes.
When this argument is set, each route is saved into a txt file within filepath,
with the name equals to its id. In this case, no output is returned. See argument
compress for another option.</p>
</td></tr>
<tr><td><code id="gtfs2gps_+3A_compress">compress</code></td>
<td>
<p>Argument that can be used only with filepath. When TRUE, it
compresses the output files by saving them using rds format. Default value is FALSE.
Note that compress guarantees that the data saved will be read in the same way as it
was created in R. If not compress, the txt extension requires the data to be converted
from ITime to string, and therefore they need to manually converted back to ITime to 
be properly handled by gtfs2gps.</p>
</td></tr>
<tr><td><code id="gtfs2gps_+3A_snap_method">snap_method</code></td>
<td>
<p>The method used to snap stops to the route geometry. There
are two available methods: 'nearest1' and 'nearest2'. Defaults to 
'nearest2'. See details for more info.</p>
</td></tr>
<tr><td><code id="gtfs2gps_+3A_continue">continue</code></td>
<td>
<p>Argument that can be used only with filepath. When TRUE, it
skips processing the shape identifiers that were already saved into 
files. It is useful to continue processing a GTFS file that was stopped
for some reason. Default value is FALSE.</p>
</td></tr>
<tr><td><code id="gtfs2gps_+3A_quiet">quiet</code></td>
<td>
<p>Hide messages while processing the data? Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>After creating geometry points for a given shape id, the 'gtfs2gps()'
function snaps the stops to the route geometry. Two strategies are implemented
to do this. 
- The 'nearest2' method (default) triangulates the distance between each stop 
and the two nearest points in the route geometry to decide which point the 
stop should be snapped to. If there is any stop that is further away to the 
route geometry  than 'spatial_resolution', the algorithm recursively doubles 
the 'spatial_resolution' to do the search/snap of all stops.
- The 'nearest1' method traverses the geometry points computing their 
distances to the first stop. Whenever it finds a distance to the stop smaller
than 'spatial_resolution', then the stop will be snapped to such point. The 
algorithm then applies the same strategy to the next stop until the vector of
stops end.
</p>
<p>The 'speed', 'cumdist', and 'cumtime' are based on the difference of distance 
and time between the current and previous row of the same trip. It means that 
the first data point at the first stop of each trip represens a stationary 
vehicle. The 'adjust_speed()' function can be used to post-process the output 
to replace eventual 'NA' values in the 'speed' column.
</p>
<p>Each stop is presented as two data points for each trip in the output. The 
'timestamp' value in the first data point represents the time when the 
vehicle arrived at that stop (corresponding the 'arrival_time' column in the
'stop_times.txt' file), while the 'timestamp' in the second data point 
represents the time when the vehicle departured from that stop (corresponding
the 'departure_time' column in the 'stop_times.txt' file). The second point 
considers that the vehicle is stationary at the stop, immediately before 
departing.
</p>
<p>Some GTFS feeds do not report embark/disembark times (so 'arrival_time' and 
'departure_time' are identical at the same stop). In this case, the user can
call the 'adjust_arrival_departure()' function to set the minimum time each 
vehicle will spend at stops to embark/disembark passengers.
</p>
<p>To avoid division by zero, the minimum speed of vehicles in the output is
1e-12 Km/h, so that vehicles are never completely stopped.
</p>


<h3>Value</h3>

<p>A 'data.table', where each row represents a GPS point. The following 
columns are returned (units of measurement in parenthesis): dist and cumdist 
(meters), cumtime (seconds), shape_pt_lon and shape_pt_lat (degrees), speed 
(km/h), timestamp (hh:mm:ss).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(gtfs2gps)
library(magrittr)

gtfs &lt;- read_gtfs(system.file("extdata/poa.zip", package = "gtfs2gps")) %&gt;%
  gtfstools::filter_by_shape_id("T2-1") %&gt;%
  filter_single_trip()
  
poa_gps &lt;- progressr::with_progress(gtfs2gps(gtfs, quiet=TRUE))

</code></pre>

<hr>
<h2 id='read_gtfs'>Read GTFS data into a list of data.tables</h2><span id='topic+read_gtfs'></span>

<h3>Description</h3>

<p>Read files of a zipped GTFS feed and load them to memory as a list of data.tables.
It will load the following files: &quot;shapes.txt&quot;, &quot;stop_times.txt&quot;, &quot;stops.txt&quot;, &quot;trips.txt&quot;,
&quot;agency.txt&quot;, &quot;calendar.txt&quot;, &quot;routes.txt&quot;, and &quot;frequencies.txt&quot;, with
this last four being optional. If one of the mandatory files does not exit,
this function will stop with an error message.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_gtfs(gtfszip, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_gtfs_+3A_gtfszip">gtfszip</code></td>
<td>
<p>A zipped GTFS data.</p>
</td></tr>
<tr><td><code id="read_gtfs_+3A_quiet">quiet</code></td>
<td>
<p>A logical. Whether to hide log messages and progress bars. 
Defaults to 'FALSE'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of data.tables, where each index represents the respective GTFS file name.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>poa &lt;- read_gtfs(system.file("extdata/poa.zip", package = "gtfs2gps"))
</code></pre>

<hr>
<h2 id='remove_invalid'>Remove invalid objects from GTFS data</h2><span id='topic+remove_invalid'></span>

<h3>Description</h3>

<p>Remove all objects from GTFS data that are not used in all relations
that they are required to be. That is,
agency-routes relation (agency_id), routes-trips relation (route_id), 
trips-shapes relation (shape_id), trips-frequencies relation (trip_id),
trips-stop_times relation (trip_id), stop_times-stops relation (stop_id),
and trips-calendar relation (service_id),
recursively, until GTFS data does not reduce its size anymore. For example,
if one agency_id belongs to routes but not to agency will be removed. This might
cause one cascade removal of objects in other relations that originally
did not have any inconsistency.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_invalid(gtfs_data, only_essential = TRUE, prompt_invalid = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_invalid_+3A_gtfs_data">gtfs_data</code></td>
<td>
<p>A list of data.tables read using gtfs2gps::reag_gtfs().</p>
</td></tr>
<tr><td><code id="remove_invalid_+3A_only_essential">only_essential</code></td>
<td>
<p>Remove only the essential files? The essential files are all but 
agency, calendar, and routes. Default is TRUE, which means that agency-routes,
routes-trips, and trips-calendar relations
will not be processed as restrictions to remove objects.</p>
</td></tr>
<tr><td><code id="remove_invalid_+3A_prompt_invalid">prompt_invalid</code></td>
<td>
<p>Show the invalid objects. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A subset of the input GTFS data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>poa &lt;- read_gtfs(system.file("extdata/poa.zip", package = "gtfs2gps"))
object.size(poa)
subset &lt;- remove_invalid(poa)
object.size(subset)
</code></pre>

<hr>
<h2 id='simplify_shapes'>Simplify shapes of a GTFS file</h2><span id='topic+simplify_shapes'></span>

<h3>Description</h3>

<p>Remove points from the shapes of a GTFS file in order to
reduce its size. It uses Douglas-Peucker algorithm internally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simplify_shapes(gtfs_data, tol = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simplify_shapes_+3A_gtfs_data">gtfs_data</code></td>
<td>
<p>A list of data.tables read using gtfs2gps::read_gtfs().</p>
</td></tr>
<tr><td><code id="simplify_shapes_+3A_tol">tol</code></td>
<td>
<p>Numerical tolerance value to be used by the Douglas-Peucker algorithm.
The default value is 0, which means that no data will be lost.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A GTFS data whose shapes is a subset of the input data.
</p>

<hr>
<h2 id='test_gtfs_freq'>Test whether a GTFS feed is frequency based</h2><span id='topic+test_gtfs_freq'></span>

<h3>Description</h3>

<p>Test whether a GTFS feed is frequency based or whether it
presents detailed time table for all routes and trip ids.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_gtfs_freq(gtfs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test_gtfs_freq_+3A_gtfs">gtfs</code></td>
<td>
<p>A GTFS data set stored in memory as a list of data.tables/data.frames.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string &quot;frequency&quot; or &quot;simple&quot;.
</p>

<hr>
<h2 id='write_gtfs'>Write GTFS data into a zip file</h2><span id='topic+write_gtfs'></span>

<h3>Description</h3>

<p>Write GTFS stored in memory as a list of data.tables into a zipped GTFS feed.
This function overwrites the zip file if it exists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_gtfs(gtfs, zipfile, overwrite = TRUE, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_gtfs_+3A_gtfs">gtfs</code></td>
<td>
<p>A GTFS data set stored in memory as a list of data.tables/data.frames.</p>
</td></tr>
<tr><td><code id="write_gtfs_+3A_zipfile">zipfile</code></td>
<td>
<p>The pathname of a .zip file to be saved with the GTFS data.</p>
</td></tr>
<tr><td><code id="write_gtfs_+3A_overwrite">overwrite</code></td>
<td>
<p>A logical. Whether to overwrite an existing <code>.zip</code> file.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="write_gtfs_+3A_quiet">quiet</code></td>
<td>
<p>A logical. Whether to hide log messages and progress bars. 
Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The status value returned by the external zip command, invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)

# read a gtfs.zip to memory
poa &lt;- read_gtfs(system.file("extdata/poa.zip", package = "gtfs2gps")) %&gt;%
  gtfstools::filter_by_shape_id("T2-1") %&gt;%
  filter_single_trip()

# write GTFS data into a zip file
write_gtfs(poa, paste0(tempdir(), "/mypoa.zip"))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
