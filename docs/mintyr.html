<!DOCTYPE html><html lang="en"><head><title>Help for package mintyr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mintyr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#c2p_nest'><p>Column to Pair Nested Transformation</p></a></li>
<li><a href='#convert_nest'><p>Convert Nested Columns Between <code>data.frame</code> and <code>data.table</code></p></a></li>
<li><a href='#export_list'><p>Export List with Advanced Directory Management</p></a></li>
<li><a href='#export_nest'><p>Export Nested Data with Advanced Grouping and Flexible Handling</p></a></li>
<li><a href='#fire'><p>fire</p></a></li>
<li><a href='#fires'><p>Update Fire Dataset with Current Date</p></a></li>
<li><a href='#format_digits'><p>Format Numeric Columns with Specified Digits</p></a></li>
<li><a href='#get_filename'><p>Extract Filenames from File Paths</p></a></li>
<li><a href='#get_path_segment'><p>Extract Specific Segments from File Paths</p></a></li>
<li><a href='#import_csv'><p>Flexible <code>CSV</code>/<code>TXT</code> File Import with Multiple Backend Support</p></a></li>
<li><a href='#import_xlsx'><p>Import Data from <code>XLSX</code> Files with Advanced Handling</p></a></li>
<li><a href='#mintyr_example'><p>Get path to mintyr examples</p></a></li>
<li><a href='#mintyr_examples'><p>List all available example files in mintyr package</p></a></li>
<li><a href='#nedap'><p>nedap</p></a></li>
<li><a href='#nedaps'><p>Update Nedap Dataset with Current Date</p></a></li>
<li><a href='#nest_cv'><p>Apply Cross-Validation to Nested Data</p></a></li>
<li><a href='#r2p_nest'><p>Row to Pair Nested Transformation</p></a></li>
<li><a href='#split_cv'><p>Cross-Validation Split Generator</p></a></li>
<li><a href='#top_perc'><p>Select Top Percentage of Data and Statistical Summarization</p></a></li>
<li><a href='#w2l_nest'><p>Reshape Wide Data to Long Format and Nest by Specified Columns</p></a></li>
<li><a href='#w2l_split'><p>Reshape Wide Data to Long Format and Split into List</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Streamlined Data Processing Tools for Genomic Selection</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>A toolkit for genomic selection in animal breeding with
    emphasis on multi-breed and multi-trait nested grouping operations.
    Streamlines iterative analysis workflows when working with 'ASReml-R'
    package.  Includes utility functions for phenotypic data processing
    commonly used by animal breeders.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://tony2015116.github.io/mintyr/">https://tony2015116.github.io/mintyr/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tony2015116/mintyr/issues">https://github.com/tony2015116/mintyr/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>arrow, data.table, dplyr, parallel, purrr, readxl, rlang,
rsample, rstatix, stats, tibble, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat, tidyr, tools</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/fusen/version:</td>
<td>0.6.0</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-12-12 01:59:42 UTC; Dell</td>
</tr>
<tr>
<td>Author:</td>
<td>Guo Meng [aut, cre],
  Guo Meng [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Guo Meng &lt;tony2015116@163.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-12-13 09:10:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='c2p_nest'>Column to Pair Nested Transformation</h2><span id='topic+c2p_nest'></span>

<h3>Description</h3>

<p>A sophisticated data transformation tool for generating column pair combinations
and creating nested data structures with advanced configuration options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c2p_nest(data, cols2bind, by = NULL, pairs_n = 2, sep = "-", nest_type = "dt")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="c2p_nest_+3A_data">data</code></td>
<td>
<p>Input <code style="white-space: pre;">&#8288;data frame&#8288;</code> or <code style="white-space: pre;">&#8288;data table&#8288;</code>
</p>

<ul>
<li><p> Must contain valid columns for transformation
</p>
</li>
<li><p> Supports multiple data types
</p>
</li></ul>
</td></tr>
<tr><td><code id="c2p_nest_+3A_cols2bind">cols2bind</code></td>
<td>
<p>Column specification for pair generation
</p>

<ul>
<li><p> Can be a <code>character</code> vector of column names
</p>
</li>
<li><p> Can be a <code>numeric</code> vector of column indices
</p>
</li>
<li><p> Must reference existing columns in the dataset
</p>
</li></ul>
</td></tr>
<tr><td><code id="c2p_nest_+3A_by">by</code></td>
<td>
<p>Optional grouping specification
</p>

<ul>
<li><p> Can be a <code>character</code> vector of column names
</p>
</li>
<li><p> Can be a <code>numeric</code> vector of column indices
</p>
</li>
<li><p> Enables hierarchical nested transformations
</p>
</li>
<li><p> Supports multi-level aggregation
</p>
</li>
<li><p> Default is <code>NULL</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="c2p_nest_+3A_pairs_n">pairs_n</code></td>
<td>
<p><code>numeric</code> indicating combination size
</p>

<ul>
<li><p> Minimum value: 2
</p>
</li>
<li><p> Maximum value: Length of <code>cols2bind</code>
</p>
</li>
<li><p> Controls column pair complexity
</p>
</li>
<li><p> Default is 2
</p>
</li></ul>
</td></tr>
<tr><td><code id="c2p_nest_+3A_sep">sep</code></td>
<td>
<p><code>character</code> separator for pair naming
</p>

<ul>
<li><p> Used in generating combination identifiers
</p>
</li>
<li><p> Must be a single character
</p>
</li>
<li><p> Default is &quot;-&quot;
</p>
</li></ul>
</td></tr>
<tr><td><code id="c2p_nest_+3A_nest_type">nest_type</code></td>
<td>
<p>Output nesting format
</p>

<ul>
<li> <p><code>"dt"</code>: Returns nested <code style="white-space: pre;">&#8288;data table&#8288;</code> (default)
</p>
</li>
<li> <p><code>"df"</code>: Returns nested <code style="white-space: pre;">&#8288;data frame&#8288;</code>
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>Advanced Transformation Mechanism:
</p>

<ol>
<li><p> Input validation and preprocessing
</p>
</li>
<li><p> Dynamic column combination generation
</p>
</li>
<li><p> Flexible pair transformation
</p>
</li>
<li><p> Nested data structure creation
</p>
</li></ol>

<p>Transformation Process:
</p>

<ul>
<li><p> Validate input parameters and column specifications
</p>
</li>
<li><p> Convert numeric indices to column names if necessary
</p>
</li>
<li><p> Generate column combinations
</p>
</li>
<li><p> Create subset data tables
</p>
</li>
<li><p> Merge and nest transformed data
</p>
</li></ul>

<p>Column Specification:
</p>

<ul>
<li><p> Supports both column names and numeric indices
</p>
</li>
<li><p> Numeric indices must be within valid range (1 to ncol)
</p>
</li>
<li><p> Column names must exist in the dataset
</p>
</li>
<li><p> Flexible specification for both cols2bind and by parameters
</p>
</li></ul>



<h3>Value</h3>

<p><code style="white-space: pre;">&#8288;data table&#8288;</code> containing nested transformation results
</p>

<ul>
<li><p> Includes <code>pairs</code> column identifying column combinations
</p>
</li>
<li><p> Contains <code>data</code> column storing nested data structures
</p>
</li>
<li><p> Supports optional grouping variables
</p>
</li></ul>



<h3>Note</h3>

<p>Key Operation Constraints:
</p>

<ul>
<li><p> Requires non-empty input data
</p>
</li>
<li><p> Column specifications must be valid (either names or indices)
</p>
</li>
<li><p> Supports flexible combination strategies
</p>
</li>
<li><p> Computational complexity increases with combination size
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li> <p><code><a href="utils.html#topic+combn">utils::combn()</a></code> Combination generation
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Example data preparation: Define column names for combination
col_names &lt;- c("Sepal.Length", "Sepal.Width", "Petal.Length")

# Example 1: Basic column-to-pairs nesting with custom separator
c2p_nest(
  iris,                   # Input iris dataset
  cols2bind = col_names,  # Columns to be combined as pairs
  pairs_n = 2,            # Create pairs of 2 columns
  sep = "&amp;"               # Custom separator for pair names
)
# Returns a nested data.table where:
# - pairs: combined column names (e.g., "Sepal.Length&amp;Sepal.Width")
# - data: list column containing data.tables with value1, value2 columns

# Example 2: Column-to-pairs nesting with numeric indices and grouping
c2p_nest(
  iris,                   # Input iris dataset
  cols2bind = 1:3,        # First 3 columns to be combined
  pairs_n = 2,            # Create pairs of 2 columns
  by = 5                  # Group by 5th column (Species)
)
# Returns a nested data.table where:
# - pairs: combined column names
# - Species: grouping variable
# - data: list column containing data.tables grouped by Species
</code></pre>

<hr>
<h2 id='convert_nest'>Convert Nested Columns Between <code>data.frame</code> and <code>data.table</code></h2><span id='topic+convert_nest'></span>

<h3>Description</h3>

<p>The <code>convert_nest</code> function transforms a <code>data.frame</code> or <code>data.table</code> by converting nested columns
to either <code>data.frame</code> or <code>data.table</code> format while preserving the original data structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_nest(data, to = c("df", "dt"), nest_cols = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert_nest_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> or <code>data.table</code> containing nested columns</p>
</td></tr>
<tr><td><code id="convert_nest_+3A_to">to</code></td>
<td>
<p>A <code>character</code> string specifying the target format.
Options are <code>"df"</code> (data frame) or <code>"dt"</code> (data table). Defaults to <code>"df"</code>.</p>
</td></tr>
<tr><td><code id="convert_nest_+3A_nest_cols">nest_cols</code></td>
<td>
<p>A <code>character</code> vector of column names containing nested data.
If <code>NULL</code>, the function automatically detects list columns.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Advanced Nested Column Conversion Features:
</p>

<ul>
<li><p> Intelligent automatic detection of nested columns
</p>
</li>
<li><p> Comprehensive conversion of entire data structure
</p>
</li>
<li><p> Selective conversion of specified nested columns
</p>
</li>
<li><p> Non-destructive transformation with data copying
</p>
</li></ul>

<p>Input Validation and Error Handling:
</p>

<ul>
<li><p> Validates existence of specified nested columns
</p>
</li>
<li><p> Verifies that specified columns are actually list columns
</p>
</li>
<li><p> Provides informative error messages for invalid inputs
</p>
</li>
<li><p> Ensures data integrity through comprehensive checks
</p>
</li></ul>

<p>Conversion Strategies:
</p>

<ol>
<li><p> Nested column identification based on <code>is.list()</code> detection
</p>
</li>
<li><p> Preservation of original data integrity
</p>
</li>
<li><p> Flexible handling of mixed data structures
</p>
</li>
<li><p> Consistent type conversion across nested elements
</p>
</li></ol>

<p>Nested Column Handling:
</p>

<ul>
<li><p> Supports conversion of <code>list</code> columns
</p>
</li>
<li><p> Handles <code>data.table</code>, <code>data.frame</code>, and generic <code>list</code> inputs
</p>
</li>
<li><p> Maintains original column structure and order
</p>
</li>
<li><p> Prevents in-place modification of source data
</p>
</li></ul>



<h3>Value</h3>

<p>A transformed <code>data.frame</code> or <code>data.table</code> with nested columns converted to the specified format.
</p>


<h3>Note</h3>

<p>Conversion Characteristics:
</p>

<ul>
<li><p> Non-destructive transformation of nested columns
</p>
</li>
<li><p> Supports flexible input and output formats
</p>
</li>
<li><p> Intelligent type detection and conversion
</p>
</li>
<li><p> Minimal performance overhead
</p>
</li></ul>

<p>Error Conditions:
</p>

<ul>
<li><p> Throws error if specified columns don't exist in the input data
</p>
</li>
<li><p> Throws error if specified columns are not list columns
</p>
</li>
<li><p> Provides clear error messages for troubleshooting
</p>
</li>
<li><p> Validates input parameters before processing
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Example 1: Create nested data structures
# Create single nested column
df_nest1 &lt;- iris |&gt; 
  dplyr::group_nest(Species)     # Group and nest by Species

# Create multiple nested columns
df_nest2 &lt;- iris |&gt;
  dplyr::group_nest(Species) |&gt;  # Group and nest by Species
  dplyr::mutate(
    data2 = purrr::map(          # Create second nested column
      data,
      dplyr::mutate, 
      c = 2
    )
  )

# Example 2: Convert nested structures
# Convert data frame to data table
convert_nest(
  df_nest1,                      # Input nested data frame
  to = "dt"                      # Convert to data.table
)

# Convert specific nested columns
convert_nest(
  df_nest2,                      # Input nested data frame
  to = "dt",                     # Convert to data.table
  nest_cols = "data"             # Only convert 'data' column
)

# Example 3: Convert data table to data frame
dt_nest &lt;- mintyr::w2l_nest(
  data = iris,                   # Input dataset
  cols2l = 1:2                   # Columns to nest
)
convert_nest(
  dt_nest,                       # Input nested data table
  to = "df"                      # Convert to data frame
)
</code></pre>

<hr>
<h2 id='export_list'>Export List with Advanced Directory Management</h2><span id='topic+export_list'></span>

<h3>Description</h3>

<p>The <code>export_list</code> function exports a list of <code>data.frame</code>, <code>data.table</code>, or compatible data structures
with sophisticated directory handling, flexible naming, and multiple file format support.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export_list(split_dt, export_path = tempdir(), file_type = "txt")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="export_list_+3A_split_dt">split_dt</code></td>
<td>
<p>A <code>list</code> of <code>data.frame</code>, <code>data.table</code>, or compatible data structures
to be exported.</p>
</td></tr>
<tr><td><code id="export_list_+3A_export_path">export_path</code></td>
<td>
<p>Base directory path for file export. Defaults to a temporary directory
created by <code>tempdir()</code>.</p>
</td></tr>
<tr><td><code id="export_list_+3A_file_type">file_type</code></td>
<td>
<p>File export format, either <code>"txt"</code> (tab-separated) or <code>"csv"</code>.
Defaults to <code>"txt"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Comprehensive List Export Features:
</p>

<ul>
<li><p> Advanced nested directory structure support based on list element names
</p>
</li>
<li><p> Intelligent handling of unnamed list elements
</p>
</li>
<li><p> Automatic conversion to <code>data.table</code> for consistent export
</p>
</li>
<li><p> Hierarchical directory creation with nested path names
</p>
</li>
<li><p> Multi-format file export with intelligent separator selection
</p>
</li>
<li><p> Robust error handling and input validation
</p>
</li></ul>

<p>File Export Capabilities:
</p>

<ul>
<li><p> Supports <code>"txt"</code> (tab-separated) and <code>"csv"</code> formats
</p>
</li>
<li><p> Intelligent file naming based on list element names
</p>
</li>
<li><p> Handles complex nested directory structures
</p>
</li>
<li><p> Efficient file writing using <code>data.table::fwrite()</code>
</p>
</li></ul>



<h3>Value</h3>

<p>An <code>integer</code> representing the total number of files exported successfully.
</p>


<h3>Note</h3>

<p>Key Capabilities:
</p>

<ul>
<li><p> Flexible list naming and directory management
</p>
</li>
<li><p> Comprehensive support for <code>data.frame</code> and <code>data.table</code> inputs
</p>
</li>
<li><p> Intelligent default naming for unnamed elements
</p>
</li>
<li><p> High-performance file writing mechanism
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Example: Export split data to files

# Step 1: Create split data structure
dt_split &lt;- w2l_split(
  data = iris,              # Input iris dataset
  cols2l = 1:2,             # Columns to be split
  by = "Species"            # Grouping variable
)

# Step 2: Export split data to files
export_list(
  split_dt = dt_split       # Input list of data.tables
)
# Returns the number of files created
# Files are saved in tempdir() with .txt extension

# Check exported files
list.files(
  path = tempdir(),         # Default export directory
  pattern = "txt",          # File type pattern to search
  recursive = TRUE          # Search in subdirectories
)

# Clean up exported files
files &lt;- list.files(
  path = tempdir(),         # Default export directory
  pattern = "txt",          # File type pattern to search
  recursive = TRUE,         # Search in subdirectories
  full.names = TRUE         # Return full file paths
)
file.remove(files)          # Remove all exported files
</code></pre>

<hr>
<h2 id='export_nest'>Export Nested Data with Advanced Grouping and Flexible Handling</h2><span id='topic+export_nest'></span>

<h3>Description</h3>

<p>The <code>export_list</code> function exports nested data from a <code>data.frame</code> or <code>data.table</code> with sophisticated grouping
capabilities, supporting multiple nested column types and flexible file export options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export_nest(
  nest_dt,
  group_cols = NULL,
  nest_col = NULL,
  export_path = tempdir(),
  file_type = "txt"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="export_nest_+3A_nest_dt">nest_dt</code></td>
<td>
<p>A <code>data.frame</code> or <code>data.table</code> containing nested columns of <code>data.frame</code>s,
<code>data.table</code>s, or lists to be exported.</p>
</td></tr>
<tr><td><code id="export_nest_+3A_group_cols">group_cols</code></td>
<td>
<p>Optional character vector specifying grouping columns.
If <code>NULL</code>, uses all non-nested columns as grouping variables.</p>
</td></tr>
<tr><td><code id="export_nest_+3A_nest_col">nest_col</code></td>
<td>
<p>Optional character string indicating the nested column to export.
If <code>NULL</code>, automatically selects the first nested column.</p>
</td></tr>
<tr><td><code id="export_nest_+3A_export_path">export_path</code></td>
<td>
<p>Base directory path for file export. Defaults to a temporary directory
created by <code>tempdir()</code>.</p>
</td></tr>
<tr><td><code id="export_nest_+3A_file_type">file_type</code></td>
<td>
<p>File export format, either <code>"txt"</code> (tab-separated) or <code>"csv"</code>.
Defaults to <code>"txt"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Comprehensive Nested Data Export Features:
</p>

<ul>
<li><p> Automatic detection and handling of different nested column types
</p>
</li>
<li><p> Flexible grouping strategies with intelligent column selection
</p>
</li>
<li><p> Hierarchical directory structure generation based on grouping columns
</p>
</li>
<li><p> Support for mixed nested column types (<code>data.frame</code>, <code>data.table</code>, <code>list</code>)
</p>
</li>
<li><p> Multi-threaded file writing for enhanced performance
</p>
</li>
<li><p> Informative messaging and warning system
</p>
</li></ul>

<p>Nested Column Detection Hierarchy:
</p>

<ol>
<li><p> Prioritizes <code>data.frame</code>/<code>data.table</code> nested columns
</p>
</li>
<li><p> Falls back to regular <code>list</code> columns if no <code>data.frame</code> columns exist
</p>
</li></ol>

<p>Grouping Column Selection Strategy:
</p>

<ol>
<li><p> When <code>group_cols</code> is <code>NULL</code>, uses all non-nested columns
</p>
</li>
<li><p> Provides warnings about unused non-nested columns
</p>
</li>
<li><p> Validates provided group columns
</p>
</li></ol>

<p>File Export Characteristics:
</p>

<ul>
<li><p> Supports <code>"txt"</code> (tab-separated) and <code>"csv"</code> formats
</p>
</li>
<li><p> Uses multi-threading via <code>parallel::detectCores()</code>
</p>
</li>
<li><p> Creates nested directory structure based on grouping variables
</p>
</li></ul>



<h3>Value</h3>

<p>An <code>integer</code> representing the total number of files exported successfully.
</p>


<h3>Note</h3>

<p>Key Capabilities:
</p>

<ul>
<li><p> Handles complex nested data structures
</p>
</li>
<li><p> Performs type conversion for nested content
</p>
</li>
<li><p> Utilizes multi-threaded file export for optimal performance
</p>
</li>
<li><p> Provides comprehensive column selection feedback
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Example 1: Basic nested data export workflow
# Step 1: Create nested data structure
dt_nest &lt;- w2l_nest(
  data = iris,              # Input iris dataset
  cols2l = 1:2,             # Columns to be nested
  by = "Species"            # Grouping variable
)

# Step 2: Export nested data to files
export_nest(
  nest_dt = dt_nest,        # Input nested data.table
  nest_col = "data",        # Column containing nested data
  group_cols = c("name", "Species")  # Columns to create directory structure
)
# Returns the number of files created
# Creates directory structure: tempdir()/name/Species/data.txt

# Check exported files
list.files(
  path = tempdir(),         # Default export directory
  pattern = "txt",          # File type pattern to search
  recursive = TRUE          # Search in subdirectories
)
# Returns list of created files and their paths

# Clean up exported files
files &lt;- list.files(
  path = tempdir(),         # Default export directory
  pattern = "txt",          # File type pattern to search
  recursive = TRUE,         # Search in subdirectories
  full.names = TRUE         # Return full file paths
)
file.remove(files)          # Remove all exported files
</code></pre>

<hr>
<h2 id='fire'>fire</h2><span id='topic+fire'></span>

<h3>Description</h3>

<p>Feeding behavior dataset from Fire system
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fire
</code></pre>


<h3>Format</h3>

<p>A data frame with 9794 rows and 10 variables:
</p>

<dl>
<dt><code>Location</code></dt><dd><p>integer Feeding station identification number</p>
</dd>
<dt><code>Tag</code></dt><dd><p>integer Animal electronic tag number</p>
</dd>
<dt><code>Date</code></dt><dd><p>character Date of feeding visit</p>
</dd>
<dt><code>Entry</code></dt><dd><p>character Time when animal entered feeding station</p>
</dd>
<dt><code>Exit</code></dt><dd><p>character Time when animal left feeding station</p>
</dd>
<dt><code>Ent Wt</code></dt><dd><p>double Feed weight at entry (kg)</p>
</dd>
<dt><code>Ext Wt</code></dt><dd><p>double Feed weight at exit (kg)</p>
</dd>
<dt><code>Consumed</code></dt><dd><p>double Amount of feed consumed (kg)</p>
</dd>
<dt><code>Weight</code></dt><dd><p>double Animal body weight (kg)</p>
</dd>
<dt><code>Topup Amount</code></dt><dd><p>double Amount of feed added to bin (kg)</p>
</dd>
</dl>


<hr>
<h2 id='fires'>Update Fire Dataset with Current Date</h2><span id='topic+fires'></span>

<h3>Description</h3>

<p>The <code>fires</code> function creates a copy of the fire dataset and adjusts the dates
to align with the current date while maintaining the original date patterns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fires()
</code></pre>


<h3>Details</h3>

<p>The function performs the following operations:
</p>

<ul>
<li><p> Creates a copy of the fire dataset from the mintyr package
</p>
</li>
<li><p> Calculates the number of days between the last recorded date and the previous day
</p>
</li>
<li><p> Shifts all dates forward by the calculated number of days
</p>
</li>
<li><p> Converts the updated dates back to character format
</p>
</li></ul>



<h3>Value</h3>

<p>A data.table with updated dates, shifted to the current date
</p>


<h3>Note</h3>


<ul>
<li><p> Requires the <code>data.table</code> and <code>mintyr</code> packages
</p>
</li>
<li><p> Uses the current system date as a reference for date shifting
</p>
</li>
<li><p> Maintains the original structure of the date column
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>head(fires())
</code></pre>

<hr>
<h2 id='format_digits'>Format Numeric Columns with Specified Digits</h2><span id='topic+format_digits'></span>

<h3>Description</h3>

<p>The <code>format_digits</code> function formats numeric columns in a data frame or data table by rounding numbers to a specified number of decimal places and converting them to character strings. It can optionally format the numbers as percentages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_digits(data, cols = NULL, digits = 2, percentage = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="format_digits_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> or <code>data.table</code>. The input data containing numeric columns to format.</p>
</td></tr>
<tr><td><code id="format_digits_+3A_cols">cols</code></td>
<td>
<p>An optional numeric or character vector specifying the columns to format. If <code>NULL</code> (default), all numeric columns are formatted.</p>
</td></tr>
<tr><td><code id="format_digits_+3A_digits">digits</code></td>
<td>
<p>A non-negative integer specifying the number of decimal places to use. Defaults to <code>2</code>.</p>
</td></tr>
<tr><td><code id="format_digits_+3A_percentage">percentage</code></td>
<td>
<p>A logical value indicating whether to format the numbers as percentages. If <code>TRUE</code>, the numbers are multiplied by 100 and a percent sign (<code style="white-space: pre;">&#8288;%&#8288;</code>) is appended. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function performs the following steps:
</p>

<ol>
<li><p> Validates the input parameters, ensuring that <code>data</code> is a <code>data.frame</code> or <code>data.table</code>, <code>cols</code> (if provided) are valid column names or indices, and <code>digits</code> is a non-negative integer.
</p>
</li>
<li><p> Converts <code>data</code> to a <code>data.table</code> if it is not already one.
</p>
</li>
<li><p> Creates a formatting function based on the <code>digits</code> and <code>percentage</code> parameters:
</p>

<ul>
<li><p> If <code>percentage = FALSE</code>, numbers are rounded to <code>digits</code> decimal places.
</p>
</li>
<li><p> If <code>percentage = TRUE</code>, numbers are multiplied by 100, rounded to <code>digits</code> decimal places, and a percent sign (<code style="white-space: pre;">&#8288;%&#8288;</code>) is appended.
</p>
</li></ul>

</li>
<li><p> Applies the formatting function to the specified columns:
</p>

<ul>
<li><p> If <code>cols</code> is <code>NULL</code>, the function formats all numeric columns in <code>data</code>.
</p>
</li>
<li><p> If <code>cols</code> is specified, only those columns are formatted.
</p>
</li></ul>

</li>
<li><p> Returns a new <code>data.table</code> with the formatted columns.
</p>
</li></ol>



<h3>Value</h3>

<p>A <code>data.table</code> with the specified numeric columns formatted as character strings with the specified number of decimal places. If <code>percentage = TRUE</code>, the numbers are shown as percentages.
</p>


<h3>Note</h3>


<ul>
<li><p> The input <code>data</code> must be a <code>data.frame</code> or <code>data.table</code>.
</p>
</li>
<li><p> If <code>cols</code> is specified, it must be a vector of valid column names or indices present in <code>data</code>.
</p>
</li>
<li><p> The <code>digits</code> parameter must be a single non-negative integer.
</p>
</li>
<li><p> The original <code>data</code> is not modified; a modified copy is returned.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Example: Number formatting demonstrations

# Setup test data
dt &lt;- data.table::data.table(
  a = c(0.1234, 0.5678),      # Numeric column 1
  b = c(0.2345, 0.6789),      # Numeric column 2
  c = c("text1", "text2")     # Text column
)

# Example 1: Format all numeric columns
format_digits(
  dt,                         # Input data table
  digits = 2                  # Round to 2 decimal places
)

# Example 2: Format specific column as percentage
format_digits(
  dt,                         # Input data table
  cols = c("a"),              # Only format column 'a'
  digits = 2,                 # Round to 2 decimal places
  percentage = TRUE           # Convert to percentage
)
</code></pre>

<hr>
<h2 id='get_filename'>Extract Filenames from File Paths</h2><span id='topic+get_filename'></span>

<h3>Description</h3>

<p>The <code>get_filename</code> function extracts filenames from file paths with options to remove file extensions
and/or directory paths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_filename(paths, rm_extension = TRUE, rm_path = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_filename_+3A_paths">paths</code></td>
<td>
<p>A <code>character</code> vector containing file system paths.
Must be valid and accessible path strings.</p>
</td></tr>
<tr><td><code id="get_filename_+3A_rm_extension">rm_extension</code></td>
<td>
<p>A <code>logical</code> flag controlling file extension removal:
</p>

<ul>
<li> <p><code>TRUE</code>: Strips file extensions from filenames
</p>
</li>
<li> <p><code>FALSE</code>: Preserves complete filename with extension
Default is <code>TRUE</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="get_filename_+3A_rm_path">rm_path</code></td>
<td>
<p>A <code>logical</code> flag managing directory path handling:
</p>

<ul>
<li> <p><code>TRUE</code>: Extracts only the filename, discarding directory information
</p>
</li>
<li> <p><code>FALSE</code>: Retains complete path information
Default is <code>TRUE</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>The function performs the following operations:
</p>

<ul>
<li><p> Validates input paths
</p>
</li>
<li><p> Handles empty input vectors
</p>
</li>
<li><p> Optionally removes directory paths using <code><a href="base.html#topic+basename">basename</a></code>
</p>
</li>
<li><p> Optionally removes file extensions using regex substitution
</p>
</li></ul>



<h3>Value</h3>

<p>A <code>character</code> vector of processed filenames with applied transformations.
</p>


<h3>Note</h3>


<ul>
<li><p> If both <code>rm_extension</code> and <code>rm_path</code> are FALSE,
a warning is issued and the original paths are returned
</p>
</li>
<li><p> Supports multiple file paths in the input vector
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li> <p><code><a href="base.html#topic+basename">base::basename()</a></code> for basic filename extraction
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Example: File path processing demonstrations

# Setup test files
xlsx_files &lt;- mintyr_example(
  mintyr_examples("xlsx_test")    # Get example Excel files
)

# Example 1: Extract filenames without extensions
get_filename(
  xlsx_files,                     # Input file paths
  rm_extension = TRUE,            # Remove file extensions
  rm_path = TRUE                  # Remove directory paths
)

# Example 2: Keep file extensions
get_filename(
  xlsx_files,                     # Input file paths
  rm_extension = FALSE,           # Keep file extensions
  rm_path = TRUE                  # Remove directory paths
)

# Example 3: Keep full paths without extensions
get_filename(
  xlsx_files,                     # Input file paths
  rm_extension = TRUE,            # Remove file extensions
  rm_path = FALSE                 # Keep directory paths
)
</code></pre>

<hr>
<h2 id='get_path_segment'>Extract Specific Segments from File Paths</h2><span id='topic+get_path_segment'></span>

<h3>Description</h3>

<p>The <code>get_path_segment</code> function extracts specific segments from file paths provided as character strings. Segments can be extracted from either the beginning or the end of the path, depending on the value of <code>n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_path_segment(paths, n = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_path_segment_+3A_paths">paths</code></td>
<td>
<p>A 'character vector' containing file system paths
</p>

<ul>
<li><p> Must be non-empty
</p>
</li>
<li><p> Path segments separated by forward slash <code>'/'</code>
</p>
</li>
<li><p> Supports absolute and relative paths
</p>
</li>
<li><p> Handles cross-platform path representations
</p>
</li>
<li><p> Supports paths with mixed separators (<code>'\\'</code> and <code>'/'</code>)
</p>
</li></ul>
</td></tr>
<tr><td><code id="get_path_segment_+3A_n">n</code></td>
<td>
<p>Numeric index for segment selection
</p>

<ul>
<li><p> Positive values: Select from path start
</p>
</li>
<li><p> Negative values: Select from path end
</p>
</li>
<li><p> Supports single index or range extraction
</p>
</li>
<li><p> Cannot be <code>0</code>
</p>
</li>
<li><p> Default is <code>1</code> (first segment)
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>Sophisticated Path Segment Extraction Mechanism:
</p>

<ol>
<li><p> Comprehensive input validation
</p>
</li>
<li><p> Path normalization and preprocessing
</p>
</li>
<li><p> Robust cross-platform path segmentation
</p>
</li>
<li><p> Flexible indexing with forward and backward navigation
</p>
</li>
<li><p> Intelligent segment retrieval
</p>
</li>
<li><p> Graceful handling of edge cases
</p>
</li></ol>

<p>Indexing Behavior:
</p>

<ul>
<li><p> Positive <code>n</code>: Forward indexing from path start
- <code>n = 1</code>: First segment
- <code>n = 2</code>: Second segment
</p>
</li>
<li><p> Negative <code>n</code>: Reverse indexing from path end
- <code>n = -1</code>: Last segment
- <code>n = -2</code>: Second-to-last segment
</p>
</li>
<li><p> Range extraction: Supports <code>c(start, end)</code> index specification
</p>
</li></ul>

<p>Path Parsing Characteristics:
</p>

<ul>
<li><p> Standardizes path separators to <code>'/'</code>
</p>
</li>
<li><p> Removes drive letters (e.g., <code>'C:'</code>)
</p>
</li>
<li><p> Ignores consecutive <code>'/'</code> delimiters
</p>
</li>
<li><p> Removes leading and trailing separators
</p>
</li>
<li><p> Returns <code>NA_character_</code> for non-existent segments
</p>
</li>
<li><p> Supports complex path structures
</p>
</li></ul>



<h3>Value</h3>

<p>'character vector' with extracted path segments
</p>

<ul>
<li><p> Matching segments for valid indices
</p>
</li>
<li> <p><code>NA_character_</code> for segments beyond path length
</p>
</li></ul>



<h3>Note</h3>

<p>Critical Operational Constraints:
</p>

<ul>
<li><p> Requires non-empty 'paths' input
</p>
</li>
<li> <p><code>n</code> must be non-zero numeric value
</p>
</li>
<li><p> Supports cross-platform path representations
</p>
</li>
<li><p> Minimal computational overhead
</p>
</li>
<li><p> Preserves path segment order
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li> <p><code><a href="tools.html#topic+fileutils">tools::file_path_sans_ext()</a></code> File extension manipulation
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Example: Path segment extraction demonstrations

# Setup test paths
paths &lt;- c(
  "C:/home/user/documents",   # Windows style path
  "/var/log/system",          # Unix system path
  "/usr/local/bin"            # Unix binary path
)

# Example 1: Extract first segment
get_path_segment(
  paths,                      # Input paths
  1                           # Get first segment
)
# Returns: c("home", "var", "usr")

# Example 2: Extract second-to-last segment
get_path_segment(
  paths,                      # Input paths
  -2                          # Get second-to-last segment
)
# Returns: c("user", "log", "local")

# Example 3: Extract from first to last segment
get_path_segment(
  paths,                      # Input paths
  c(1,-1)                     # Range from first to last
)
# Returns full paths without drive letters

# Example 4: Extract first three segments
get_path_segment(
  paths,                      # Input paths
  c(1,3)                      # Range from first to third
)
# Returns: c("home/user/documents", "var/log/system", "usr/local/bin")

# Example 5: Extract last two segments (reverse order)
get_path_segment(
  paths,                      # Input paths
  c(-1,-2)                    # Range from last to second-to-last
)
# Returns: c("documents/user", "system/log", "bin/local")

# Example 6: Extract first two segments
get_path_segment(
  paths,                      # Input paths
  c(1,2)                      # Range from first to second
)
# Returns: c("home/user", "var/log", "usr/local")
</code></pre>

<hr>
<h2 id='import_csv'>Flexible <code>CSV</code>/<code>TXT</code> File Import with Multiple Backend Support</h2><span id='topic+import_csv'></span>

<h3>Description</h3>

<p>A comprehensive <code>CSV</code> or <code>TXT</code> file import function offering advanced reading capabilities
through <code>data.table</code> and <code>arrow</code> packages with intelligent data combination strategies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import_csv(
  file,
  package = "data.table",
  rbind = TRUE,
  rbind_label = "_file",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="import_csv_+3A_file">file</code></td>
<td>
<p>A <code>character</code> vector of file paths to <code>CSV</code> files.
Must point to existing and accessible files.</p>
</td></tr>
<tr><td><code id="import_csv_+3A_package">package</code></td>
<td>
<p>A <code>character</code> string specifying the backend package:
</p>

<ul>
<li> <p><code>"data.table"</code>: Uses <code><a href="data.table.html#topic+fread">data.table::fread()</a></code> (default)
</p>
</li>
<li> <p><code>"arrow"</code>: Uses <code><a href="arrow.html#topic+read_delim_arrow">arrow::read_csv_arrow()</a></code>
Determines the underlying reading mechanism.
</p>
</li></ul>
</td></tr>
<tr><td><code id="import_csv_+3A_rbind">rbind</code></td>
<td>
<p>A <code>logical</code> value controlling data combination strategy:
</p>

<ul>
<li> <p><code>TRUE</code>: Combines all files into a single data object
</p>
</li>
<li> <p><code>FALSE</code>: Returns a list of individual data objects
Default is <code>TRUE</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="import_csv_+3A_rbind_label">rbind_label</code></td>
<td>
<p>A <code>character</code> string or <code>NULL</code> for source file tracking:
</p>

<ul>
<li> <p><code>character</code>: Specifies the column name for file source labeling
</p>
</li>
<li> <p><code>NULL</code>: Disables source file tracking
Default is <code>"_file"</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="import_csv_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to backend-specific reading functions
(e.g., <code>col_types</code>, <code>na.strings</code>, <code>skip</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function provides a unified interface for reading CSV files using either data.table
or arrow package. When reading multiple files, it can either combine them into a single
data object or return them as a list. File source tracking is supported through the
rbind_label parameter.
</p>


<h3>Value</h3>

<p>Depends on the <code>rbind</code> parameter:
</p>

<ul>
<li><p> If <code>rbind = TRUE</code>: A single data object (from chosen package)
containing all imported data
</p>
</li>
<li><p> If <code>rbind = FALSE</code>: A named list of data objects with names
derived from input file names (without extensions)
</p>
</li></ul>



<h3>Note</h3>

<p>Critical Import Considerations:
</p>

<ul>
<li><p> Requires all specified files to be accessible <code>CSV/TXT</code> files
</p>
</li>
<li><p> Supports flexible backend selection
</p>
</li>
<li> <p><code>rbind = TRUE</code> assumes compatible data structures
</p>
</li>
<li><p> Missing columns are automatically aligned
</p>
</li>
<li><p> File extensions are automatically removed in tracking columns
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li> <p><code><a href="data.table.html#topic+fread">data.table::fread()</a></code> for <code>data.table</code> backend
</p>
</li>
<li> <p><code><a href="arrow.html#topic+read_delim_arrow">arrow::read_csv_arrow()</a></code> for <code>arrow</code> backend
</p>
</li>
<li> <p><code><a href="data.table.html#topic+rbindlist">data.table::rbindlist()</a></code> for data combination
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Example: CSV file import demonstrations

# Setup test files
csv_files &lt;- mintyr_example(
  mintyr_examples("csv_test")     # Get example CSV files
)

# Example 1: Import and combine CSV files using data.table
import_csv(
  csv_files,                      # Input CSV file paths
  package = "data.table",         # Use data.table for reading
  rbind = TRUE,                   # Combine all files into one data.table
  rbind_label = "_file"           # Column name for file source
)

# Example 2: Import files separately using arrow
import_csv(
  csv_files,                      # Input CSV file paths
  package = "arrow",              # Use arrow for reading
  rbind = FALSE                   # Keep files as separate data.tables
)
</code></pre>

<hr>
<h2 id='import_xlsx'>Import Data from <code>XLSX</code> Files with Advanced Handling</h2><span id='topic+import_xlsx'></span>

<h3>Description</h3>

<p>A robust and flexible function for importing data from one or multiple
<code>XLSX</code> files, offering comprehensive options for sheet selection,
data combination, and source tracking.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import_xlsx(file, rbind = TRUE, sheet = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="import_xlsx_+3A_file">file</code></td>
<td>
<p>A <code>character</code> vector of file paths to <code>Excel</code> files.
Must point to existing <code>.xlsx</code> or <code>.xls</code> files.</p>
</td></tr>
<tr><td><code id="import_xlsx_+3A_rbind">rbind</code></td>
<td>
<p>A <code>logical</code> value controlling data combination strategy:
</p>

<ul>
<li> <p><code>TRUE</code>: Combines all data into a single <code>data.table</code>
</p>
</li>
<li> <p><code>FALSE</code>: Returns a list of <code>data.table</code>s
Default is <code>TRUE</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="import_xlsx_+3A_sheet">sheet</code></td>
<td>
<p>A <code>numeric</code> vector or <code>NULL</code> specifying sheet import strategy:
</p>

<ul>
<li> <p><code>NULL</code> (default): Imports all sheets
</p>
</li>
<li> <p><code>numeric</code>: Imports only specified sheet indices
</p>
</li></ul>
</td></tr>
<tr><td><code id="import_xlsx_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="readxl.html#topic+read_excel">readxl::read_excel()</a></code>,
such as <code>col_types</code>, <code>skip</code>, or <code>na</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function provides a comprehensive solution for importing Excel data with the
following features:
</p>

<ul>
<li><p> Supports multiple files and sheets
</p>
</li>
<li><p> Automatic source tracking for files and sheets
</p>
</li>
<li><p> Flexible combining options
</p>
</li>
<li><p> Handles missing columns across sheets when combining
</p>
</li>
<li><p> Preserves original data types through readxl
</p>
</li></ul>



<h3>Value</h3>

<p>Depends on the <code>rbind</code> parameter:
</p>

<ul>
<li><p> If <code>rbind = TRUE</code>: A single <code>data.table</code> with additional tracking columns:
- <code>excel_name</code>: Source file name (without extension)
- <code>sheet_name</code>: Source sheet name
</p>
</li>
<li><p> If <code>rbind = FALSE</code>: A named list of <code>data.table</code>s with format
<code>"filename_sheetname"</code>
</p>
</li></ul>



<h3>Note</h3>

<p>Critical Import Considerations:
</p>

<ul>
<li><p> Requires all specified files to be accessible <code>Excel</code> files
</p>
</li>
<li><p> Sheet indices must be valid across input files
</p>
</li>
<li> <p><code>rbind = TRUE</code> assumes compatible data structures
</p>
</li>
<li><p> Missing columns are automatically filled with <code>NA</code>
</p>
</li>
<li><p> File extensions are automatically removed in tracking columns
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li> <p><code><a href="readxl.html#topic+read_excel">readxl::read_excel()</a></code> for underlying Excel reading
</p>
</li>
<li> <p><code><a href="data.table.html#topic+rbindlist">data.table::rbindlist()</a></code> for data combination
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Example: Excel file import demonstrations

# Setup test files
xlsx_files &lt;- mintyr_example(
  mintyr_examples("xlsx_test")    # Get example Excel files
)

# Example 1: Import and combine all sheets from all files
import_xlsx(
  xlsx_files,                     # Input Excel file paths
  rbind = TRUE                    # Combine all sheets into one data.table
)

# Example 2: Import specific sheets separately
import_xlsx(
  xlsx_files,                     # Input Excel file paths
  rbind = FALSE,                  # Keep sheets as separate data.tables
  sheet = 2                       # Only import first sheet
)
</code></pre>

<hr>
<h2 id='mintyr_example'>Get path to mintyr examples</h2><span id='topic+mintyr_example'></span>

<h3>Description</h3>

<p><code>mintyr</code> comes bundled with a number of sample files in
its <code>inst/extdata</code> directory. Use <code>mintyr_example()</code> to retrieve the full file path to a
specific example file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mintyr_example(path = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mintyr_example_+3A_path">path</code></td>
<td>
<p>Name of the example file to locate. If NULL or missing,
returns the directory path containing the examples.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character string containing the full path to the requested example file.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mintyr_examples">mintyr_examples()</a></code> to list all available example files
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get path to an example file
mintyr_example("csv_test1.csv")
</code></pre>

<hr>
<h2 id='mintyr_examples'>List all available example files in mintyr package</h2><span id='topic+mintyr_examples'></span>

<h3>Description</h3>

<p><code>mintyr</code> comes bundled with a number of sample files in its <code>inst/extdata</code>
directory. This function lists all available example files, optionally filtered
by a pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mintyr_examples(pattern = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mintyr_examples_+3A_pattern">pattern</code></td>
<td>
<p>A regular expression to filter filenames. If <code>NULL</code> (default),
all available files are returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector containing the names of example files. If no files
match the pattern or if the example directory is empty, returns a zero-length
character vector.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mintyr_example">mintyr_example()</a></code> to get the full path of a specific example file
</p>


<h3>Examples</h3>

<pre><code class='language-R'># List all example files
mintyr_examples()
</code></pre>

<hr>
<h2 id='nedap'>nedap</h2><span id='topic+nedap'></span>

<h3>Description</h3>

<p>Dairy cow feeding behavior dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nedap
</code></pre>


<h3>Format</h3>

<p>A data frame with 31863 rows and 9 variables:
</p>

<dl>
<dt><code>animal_number</code></dt><dd><p>integer Animal identification number</p>
</dd>
<dt><code>lifenumber</code></dt><dd><p>logical Life number of the animal</p>
</dd>
<dt><code>responder</code></dt><dd><p>integer Responder identification number</p>
</dd>
<dt><code>location</code></dt><dd><p>integer Feeding station location</p>
</dd>
<dt><code>visit_time</code></dt><dd><p>double Time of feeding visit</p>
</dd>
<dt><code>duration</code></dt><dd><p>integer Duration of feeding visit (minutes)</p>
</dd>
<dt><code>state</code></dt><dd><p>integer Status code</p>
</dd>
<dt><code>weight</code></dt><dd><p>integer Body weight (kg)</p>
</dd>
<dt><code>feed_intake</code></dt><dd><p>integer Feed intake amount (kg)</p>
</dd>
</dl>


<hr>
<h2 id='nedaps'>Update Nedap Dataset with Current Date</h2><span id='topic+nedaps'></span>

<h3>Description</h3>

<p>The <code>nedaps</code> function creates a copy of the Nedap dataset and adjusts the visit times
to align with the current date while maintaining the original time patterns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nedaps()
</code></pre>


<h3>Details</h3>

<p>The function performs the following operations:
</p>

<ul>
<li><p> Creates a copy of the Nedap dataset from the mintyr package
</p>
</li>
<li><p> Calculates the number of days between the last recorded visit and the previous day
</p>
</li>
<li><p> Shifts all visit times forward by the calculated number of days
</p>
</li>
<li><p> Preserves the original time patterns of the visits
</p>
</li></ul>



<h3>Value</h3>

<p>A <code>data.table</code> with updated visit times, shifted to the current date
</p>


<h3>Note</h3>


<ul>
<li><p> Requires the <code>data.table</code> and <code>mintyr</code> packages
</p>
</li>
<li><p> Uses the current system date as a reference for date shifting
</p>
</li>
<li><p> Maintains the original time of day for each visit
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>head(nedaps())
</code></pre>

<hr>
<h2 id='nest_cv'>Apply Cross-Validation to Nested Data</h2><span id='topic+nest_cv'></span>

<h3>Description</h3>

<p>The <code>nest_cv</code> function applies cross-validation splits to nested data frames or data tables within a data table. It uses the <code>rsample</code> package's <code>vfold_cv</code> function to create cross-validation splits for predictive modeling and analysis on nested datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nest_cv(
  nest_dt,
  v = 10,
  repeats = 1,
  strata = NULL,
  breaks = 4,
  pool = 0.1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nest_cv_+3A_nest_dt">nest_dt</code></td>
<td>
<p>A <code>data.frame</code> or <code>data.table</code> containing at least one nested
<code>data.frame</code> or <code>data.table</code> column.
</p>

<ul>
<li><p> Supports multi-level nested structures
</p>
</li>
<li><p> Requires at least one nested data column
</p>
</li></ul>
</td></tr>
<tr><td><code id="nest_cv_+3A_v">v</code></td>
<td>
<p>The number of partitions of the data set.</p>
</td></tr>
<tr><td><code id="nest_cv_+3A_repeats">repeats</code></td>
<td>
<p>The number of times to repeat the V-fold partitioning.</p>
</td></tr>
<tr><td><code id="nest_cv_+3A_strata">strata</code></td>
<td>
<p>A variable in <code>data</code> (single character or name) used to conduct
stratified sampling. When not <code>NULL</code>, each resample is created within the
stratification variable. Numeric <code>strata</code> are binned into quartiles.</p>
</td></tr>
<tr><td><code id="nest_cv_+3A_breaks">breaks</code></td>
<td>
<p>A single number giving the number of bins desired to stratify a
numeric stratification variable.</p>
</td></tr>
<tr><td><code id="nest_cv_+3A_pool">pool</code></td>
<td>
<p>A proportion of data used to determine if a particular group is
too small and should be pooled into another group. We do not recommend
decreasing this argument below its default of 0.1 because of the dangers
of stratifying groups that are too small.</p>
</td></tr>
<tr><td><code id="nest_cv_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function performs the following steps:
</p>

<ol>
<li><p> Checks if the input <code>nest_dt</code> is non-empty and contains at least one nested column of <code>data.frame</code>s or <code>data.table</code>s.
</p>
</li>
<li><p> Identifies the nested columns and non-nested columns within <code>nest_dt</code>.
</p>
</li>
<li><p> Applies <code>rsample::vfold_cv</code> to each nested data frame in the specified nested column(s), creating the cross-validation splits.
</p>
</li>
<li><p> Expands the cross-validation splits and associates them with the non-nested columns.
</p>
</li>
<li><p> Extracts the training and validation data for each split and adds them to the output data table.
</p>
</li></ol>

<p>If the <code>strata</code> parameter is provided, stratified sampling is performed during the cross-validation. Additional arguments can be passed to <code>rsample::vfold_cv</code> via <code>...</code>.
</p>


<h3>Value</h3>

<p>A <code>data.table</code> containing the cross-validation splits for each nested dataset. It includes:
</p>

<ul>
<li><p> Original non-nested columns from <code>nest_dt</code>.
</p>
</li>
<li> <p><code>splits</code>: The cross-validation split objects returned by <code>rsample::vfold_cv</code>.
</p>
</li>
<li> <p><code>train</code>: The training data for each split.
</p>
</li>
<li> <p><code>validate</code>: The validation data for each split.
</p>
</li></ul>



<h3>Note</h3>


<ul>
<li><p> The <code>nest_dt</code> must contain at least one nested column of <code>data.frame</code>s or <code>data.table</code>s.
</p>
</li>
<li><p> The function converts <code>nest_dt</code> to a <code>data.table</code> internally to ensure efficient data manipulation.
</p>
</li>
<li><p> The <code>strata</code> parameter should be a column name present in the nested data frames.
</p>
</li>
<li><p> If <code>strata</code> is specified, ensure that the specified column exists in all nested data frames.
</p>
</li>
<li><p> The <code>breaks</code> and <code>pool</code> parameters are used when <code>strata</code> is a numeric variable and control how stratification is handled.
</p>
</li>
<li><p> Additional arguments passed through <code>...</code> are forwarded to <code>rsample::vfold_cv</code>.
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li> <p><code><a href="rsample.html#topic+vfold_cv">rsample::vfold_cv()</a></code> Underlying cross-validation function
</p>
</li>
<li> <p><code><a href="rsample.html#topic+initial_split">rsample::training()</a></code> Extract training set
</p>
</li>
<li> <p><code><a href="rsample.html#topic+initial_split">rsample::testing()</a></code> Extract test set
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Example: Cross-validation for nested data.table demonstrations

# Setup test data
dt_nest &lt;- w2l_nest(
  data = iris,                   # Input dataset
  cols2l = 1:2                   # Nest first 2 columns
)

# Example 1: Basic 2-fold cross-validation
nest_cv(
  nest_dt = dt_nest,             # Input nested data.table
  v = 2                          # Number of folds (2-fold CV)
)

# Example 2: Repeated 2-fold cross-validation
nest_cv(
  nest_dt = dt_nest,             # Input nested data.table
  v = 2,                         # Number of folds (2-fold CV)
  repeats = 2                    # Number of repetitions
)
</code></pre>

<hr>
<h2 id='r2p_nest'>Row to Pair Nested Transformation</h2><span id='topic+r2p_nest'></span>

<h3>Description</h3>

<p>A sophisticated data transformation tool for performing row pair conversion
and creating nested data structures with advanced configuration options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>r2p_nest(data, rows2bind, by, nest_type = "dt")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="r2p_nest_+3A_data">data</code></td>
<td>
<p>Input <code style="white-space: pre;">&#8288;data frame&#8288;</code> or <code style="white-space: pre;">&#8288;data table&#8288;</code>
</p>

<ul>
<li><p> Must contain valid columns for transformation
</p>
</li>
<li><p> Supports multiple data types
</p>
</li></ul>
</td></tr>
<tr><td><code id="r2p_nest_+3A_rows2bind">rows2bind</code></td>
<td>
<p>Row binding specification
</p>

<ul>
<li><p> Can be a <code>character</code> column name
</p>
</li>
<li><p> Can be a <code>numeric</code> column index
</p>
</li>
<li><p> Must be a single column identifier
</p>
</li></ul>
</td></tr>
<tr><td><code id="r2p_nest_+3A_by">by</code></td>
<td>
<p>Grouping specification for nested pairing
</p>

<ul>
<li><p> Can be a <code>character</code> vector of column names
</p>
</li>
<li><p> Can be a <code>numeric</code> vector of column indices
</p>
</li>
<li><p> Must specify at least one column
</p>
</li>
<li><p> Supports multi-column transformation
</p>
</li></ul>
</td></tr>
<tr><td><code id="r2p_nest_+3A_nest_type">nest_type</code></td>
<td>
<p>Output nesting format
</p>

<ul>
<li> <p><code>"dt"</code>: Returns nested <code style="white-space: pre;">&#8288;data table&#8288;</code> (default)
</p>
</li>
<li> <p><code>"df"</code>: Returns nested <code style="white-space: pre;">&#8288;data frame&#8288;</code>
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>Advanced Transformation Mechanism:
</p>

<ol>
<li><p> Input validation and preprocessing
</p>
</li>
<li><p> Dynamic column identification
</p>
</li>
<li><p> Flexible row pairing across specified columns
</p>
</li>
<li><p> Nested data structure generation
</p>
</li></ol>

<p>Transformation Process:
</p>

<ul>
<li><p> Validate input parameters and column specifications
</p>
</li>
<li><p> Convert numeric indices to column names if necessary
</p>
</li>
<li><p> Reshape data from wide to long format
</p>
</li>
<li><p> Perform column-wise nested transformation
</p>
</li>
<li><p> Generate final nested structure
</p>
</li></ul>

<p>Column Specification:
</p>

<ul>
<li><p> Supports both column names and numeric indices
</p>
</li>
<li><p> Numeric indices must be within valid range (1 to ncol)
</p>
</li>
<li><p> Column names must exist in the dataset
</p>
</li>
<li><p> Flexible specification for both rows2bind and by parameters
</p>
</li></ul>



<h3>Value</h3>

<p><code style="white-space: pre;">&#8288;data table&#8288;</code> containing nested transformation results
</p>

<ul>
<li><p> Includes <code>name</code> column identifying source columns
</p>
</li>
<li><p> Contains <code>data</code> column storing nested data structures
</p>
</li></ul>



<h3>Note</h3>

<p>Key Operation Constraints:
</p>

<ul>
<li><p> Requires non-empty input data
</p>
</li>
<li><p> Column specifications must be valid (either names or indices)
</p>
</li>
<li><p> By parameter must specify at least one column
</p>
</li>
<li><p> Low computational overhead
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li> <p><code><a href="data.table.html#topic+melt.data.table">data.table::melt()</a></code> Long format conversion
</p>
</li>
<li> <p><code><a href="data.table.html#topic+dcast.data.table">data.table::dcast()</a></code> Wide format conversion
</p>
</li>
<li> <p><code><a href="base.html#topic+cbind">base::rbind()</a></code> Row binding utility
</p>
</li>
<li> <p><code><a href="#topic+c2p_nest">c2p_nest()</a></code> Column to pair nested transformation
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Example 1: Row-to-pairs nesting with column names
r2p_nest(
  mtcars,                     # Input mtcars dataset
  rows2bind = "cyl",          # Column to be used as row values
  by = c("hp", "drat", "wt")  # Columns to be transformed into pairs
)
# Returns a nested data.table where:
# - name: variable names (hp, drat, wt)
# - data: list column containing data.tables with rows grouped by cyl values

# Example 2: Row-to-pairs nesting with numeric indices
r2p_nest(
  mtcars,                     # Input mtcars dataset
  rows2bind = 2,              # Use 2nd column (cyl) as row values
  by = 4:6                    # Use columns 4-6 (hp, drat, wt) for pairs
)
# Returns a nested data.table where:
# - name: variable names from columns 4-6
# - data: list column containing data.tables with rows grouped by cyl values
</code></pre>

<hr>
<h2 id='split_cv'>Cross-Validation Split Generator</h2><span id='topic+split_cv'></span>

<h3>Description</h3>

<p>A robust cross-validation splitting utility for multiple datasets with advanced stratification and configuration options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_cv(
  split_dt,
  v = 10,
  repeats = 1,
  strata = NULL,
  breaks = 4,
  pool = 0.1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="split_cv_+3A_split_dt">split_dt</code></td>
<td>
<p><code>list</code> of input datasets
</p>

<ul>
<li><p> Must contain <code>data.frame</code> or <code>data.table</code> elements
</p>
</li>
<li><p> Supports multiple dataset processing
</p>
</li>
<li><p> Cannot be empty
</p>
</li></ul>
</td></tr>
<tr><td><code id="split_cv_+3A_v">v</code></td>
<td>
<p>The number of partitions of the data set.</p>
</td></tr>
<tr><td><code id="split_cv_+3A_repeats">repeats</code></td>
<td>
<p>The number of times to repeat the V-fold partitioning.</p>
</td></tr>
<tr><td><code id="split_cv_+3A_strata">strata</code></td>
<td>
<p>A variable in <code>data</code> (single character or name) used to conduct
stratified sampling. When not <code>NULL</code>, each resample is created within the
stratification variable. Numeric <code>strata</code> are binned into quartiles.</p>
</td></tr>
<tr><td><code id="split_cv_+3A_breaks">breaks</code></td>
<td>
<p>A single number giving the number of bins desired to stratify a
numeric stratification variable.</p>
</td></tr>
<tr><td><code id="split_cv_+3A_pool">pool</code></td>
<td>
<p>A proportion of data used to determine if a particular group is
too small and should be pooled into another group. We do not recommend
decreasing this argument below its default of 0.1 because of the dangers
of stratifying groups that are too small.</p>
</td></tr>
<tr><td><code id="split_cv_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Advanced Cross-Validation Mechanism:
</p>

<ol>
<li><p> Input dataset validation
</p>
</li>
<li><p> Stratified or unstratified sampling
</p>
</li>
<li><p> Flexible fold generation
</p>
</li>
<li><p> Train-validate set creation
</p>
</li></ol>

<p>Sampling Strategies:
</p>

<ul>
<li><p> Supports multiple dataset processing
</p>
</li>
<li><p> Handles stratified and unstratified sampling
</p>
</li>
<li><p> Generates reproducible cross-validation splits
</p>
</li></ul>



<h3>Value</h3>

<p><code>list</code> of <code>data.table</code> objects containing:
</p>

<ul>
<li> <p><code>splits</code>: Cross-validation split objects
</p>
</li>
<li> <p><code>train</code>: Training dataset subsets
</p>
</li>
<li> <p><code>validate</code>: Validation dataset subsets
</p>
</li></ul>



<h3>Note</h3>

<p>Important Constraints:
</p>

<ul>
<li><p> Requires non-empty input datasets
</p>
</li>
<li><p> All datasets must be <code>data.frame</code> or <code>data.table</code>
</p>
</li>
<li><p> Strata column must exist if specified
</p>
</li>
<li><p> Computational resources impact large dataset processing
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li> <p><code><a href="rsample.html#topic+vfold_cv">rsample::vfold_cv()</a></code> Core cross-validation function
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Prepare example data: Convert first 3 columns of iris dataset to long format and split
dt_split &lt;- w2l_split(data = iris, cols2l = 1:3)
# dt_split is now a list containing 3 data tables for Sepal.Length, Sepal.Width, and Petal.Length

# Example 1: Single cross-validation (no repeats)
split_cv(
  split_dt = dt_split,  # Input list of split data
  v = 3,                # Set 3-fold cross-validation
  repeats = 1           # Perform cross-validation once (no repeats)
)
# Returns a list where each element contains:
# - splits: rsample split objects
# - id: fold numbers (Fold1, Fold2, Fold3)
# - train: training set data
# - validate: validation set data

# Example 2: Repeated cross-validation
split_cv(
  split_dt = dt_split,  # Input list of split data
  v = 3,                # Set 3-fold cross-validation
  repeats = 2           # Perform cross-validation twice
)
# Returns a list where each element contains:
# - splits: rsample split objects
# - id: repeat numbers (Repeat1, Repeat2)
# - id2: fold numbers (Fold1, Fold2, Fold3)
# - train: training set data
# - validate: validation set data
</code></pre>

<hr>
<h2 id='top_perc'>Select Top Percentage of Data and Statistical Summarization</h2><span id='topic+top_perc'></span>

<h3>Description</h3>

<p>The <code>top_perc</code> function selects the top percentage of data based on a specified trait and computes summary statistics.
It allows for grouping by additional columns and offers flexibility in the type of statistics calculated.
The function can also retain the selected data if needed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>top_perc(data, perc, trait, by = NULL, type = "mean_sd", keep_data = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="top_perc_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> containing the source dataset for analysis
</p>

<ul>
<li><p> Supports various data frame-like structures
</p>
</li>
<li><p> Automatically converts non-data frame inputs
</p>
</li></ul>
</td></tr>
<tr><td><code id="top_perc_+3A_perc">perc</code></td>
<td>
<p>Numeric vector of percentages for data selection
</p>

<ul>
<li><p> Range: <code>-1</code> to <code>1</code>
</p>
</li>
<li><p> Positive values: Select top percentiles
</p>
</li>
<li><p> Negative values: Select bottom percentiles
</p>
</li>
<li><p> Multiple percentiles supported
</p>
</li></ul>
</td></tr>
<tr><td><code id="top_perc_+3A_trait">trait</code></td>
<td>
<p>Character string specifying the 'selection column'
</p>

<ul>
<li><p> Must be a valid column name in the input <code>data</code>
</p>
</li>
<li><p> Used as the basis for top/bottom percentage selection
</p>
</li></ul>
</td></tr>
<tr><td><code id="top_perc_+3A_by">by</code></td>
<td>
<p>Optional character vector for 'grouping columns'
</p>

<ul>
<li><p> Default is <code>NULL</code>
</p>
</li>
<li><p> Enables stratified analysis
</p>
</li>
<li><p> Allows granular percentage selection within groups
</p>
</li></ul>
</td></tr>
<tr><td><code id="top_perc_+3A_type">type</code></td>
<td>
<p>Statistical summary type
</p>

<ul>
<li><p> Default: <code>"mean_sd"</code>
</p>
</li>
<li><p> Controls the type of summary statistics computed
</p>
</li>
<li><p> Supports various summary methods from <code>rstatix</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="top_perc_+3A_keep_data">keep_data</code></td>
<td>
<p>Logical flag for data retention
</p>

<ul>
<li><p> Default: <code>FALSE</code>
</p>
</li>
<li> <p><code>TRUE</code>: Return both summary statistics and selected data
</p>
</li>
<li> <p><code>FALSE</code>: Return only summary statistics
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A list or data frame:
</p>

<ul>
<li><p> If <code>keep_data</code> is FALSE, a data frame with summary statistics.
</p>
</li>
<li><p> If <code>keep_data</code> is TRUE, a list where each element is a list containing summary statistics (<code>stat</code>) and the selected top data (<code>data</code>).
</p>
</li></ul>



<h3>Note</h3>


<ul>
<li><p> The <code>perc</code> parameter accepts values between -1 and 1. Positive values select the top percentage, while negative values select the bottom percentage.
</p>
</li>
<li><p> The function performs initial checks to ensure required arguments are provided and valid.
</p>
</li>
<li><p> Grouping by additional columns (<code>by</code>) is optional and allows for more granular analysis.
</p>
</li>
<li><p> The <code>type</code> parameter specifies the type of summary statistics to compute, with &quot;mean_sd&quot; as the default.
</p>
</li>
<li><p> If <code>keep_data</code> is set to TRUE, the function will return both the summary statistics and the selected top data for each percentage.
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li> <p><code><a href="rstatix.html#topic+get_summary_stats">rstatix::get_summary_stats()</a></code> Statistical summary computation
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+top_n">dplyr::top_frac()</a></code> Percentage-based data selection
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Example 1: Basic usage with single trait
# This example selects the top 10% of observations based on Petal.Width
# keep_data=TRUE returns both summary statistics and the filtered data
top_perc(iris, 
         perc = 0.1,                # Select top 10%
         trait = c("Petal.Width"),  # Column to analyze
         keep_data = TRUE)          # Return both stats and filtered data

# Example 2: Using grouping with 'by' parameter
# This example performs the same analysis but separately for each Species
# Returns nested list with stats and filtered data for each group
top_perc(iris, 
         perc = 0.1,                # Select top 10%
         trait = c("Petal.Width"),  # Column to analyze
         by = "Species")            # Group by Species

# Example 3: Complex example with multiple percentages and grouping variables
# Reshape data from wide to long format for Sepal.Length and Sepal.Width
iris |&gt; 
  tidyr::pivot_longer(1:2,
                      names_to = "names", 
                      values_to = "values") |&gt; 
  mintyr::top_perc(
    perc = c(0.1, -0.2),
    trait = "values",
    by = c("Species", "names"),
    type = "mean_sd")
</code></pre>

<hr>
<h2 id='w2l_nest'>Reshape Wide Data to Long Format and Nest by Specified Columns</h2><span id='topic+w2l_nest'></span>

<h3>Description</h3>

<p>The <code>w2l_nest</code> function reshapes wide-format data into long-format and nests it by specified columns.
It handles both <code>data.frame</code> and <code>data.table</code> objects and provides options for grouping and nesting the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>w2l_nest(data, cols2l = NULL, by = NULL, nest_type = "dt")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="w2l_nest_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>data.table</code>
</p>

<ul>
<li><p> Input dataset in wide format
</p>
</li>
<li><p> Automatically converted to <code>data.table</code> if necessary
</p>
</li></ul>
</td></tr>
<tr><td><code id="w2l_nest_+3A_cols2l">cols2l</code></td>
<td>
<p><code>numeric</code> or <code>character</code> columns to transform
</p>

<ul>
<li><p> Specifies columns for wide-to-long conversion
</p>
</li>
<li><p> Can be column indices or column names
</p>
</li>
<li><p> Default is <code>NULL</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="w2l_nest_+3A_by">by</code></td>
<td>
<p><code>numeric</code> or <code>character</code> grouping variables
</p>

<ul>
<li><p> Optional columns for additional data stratification
</p>
</li>
<li><p> Can be column indices or column names
</p>
</li>
<li><p> Used to create hierarchical nested structures
</p>
</li>
<li><p> Default is <code>NULL</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="w2l_nest_+3A_nest_type">nest_type</code></td>
<td>
<p><code>character</code> output data type
</p>

<ul>
<li><p> Defines nested data object type
</p>
</li>
<li><p> Possible values:
</p>

<ul>
<li> <p><code>"dt"</code>: nested <code>data.table</code>
</p>
</li>
<li> <p><code>"df"</code>: nested <code>data.frame</code>
</p>
</li></ul>

</li>
<li><p> Default is <code>"dt"</code>
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>The function melts the specified wide columns into long format and nests the resulting data by the <code>name</code>
column and any additional grouping variables specified in <code>by</code>. The nested data can be in the form of
<code>data.table</code> or <code>data.frame</code> objects, controlled by the <code>nest_type</code> parameter.
</p>
<p>Both <code>cols2l</code> and <code>by</code> parameters accept either column indices or column names, providing flexible ways
to specify the columns for transformation and grouping.
</p>


<h3>Value</h3>

<p><code>data.table</code> with nested data in long format, grouped by specified columns if provided. Each row contains a nested <code>data.table</code> or <code>data.frame</code> under the column data, depending on nest_type.
</p>

<ul>
<li><p> If <code>by</code> is <code>NULL</code>, returns a <code>data.table</code> nested by <code>name</code>.
</p>
</li>
<li><p> If <code>by</code> is specified, returns a <code>data.table</code> nested by <code>name</code> and the grouping variables.
</p>
</li></ul>



<h3>Note</h3>


<ul>
<li><p> Both <code>cols2l</code> and <code>by</code> parameters can be specified using either numeric indices or character column names.
</p>
</li>
<li><p> When using numeric indices, they must be valid column positions in the data (1 to ncol(data)).
</p>
</li>
<li><p> When using character names, all specified columns must exist in the data.
</p>
</li>
<li><p> The function converts <code>data.frame</code> to <code>data.table</code> if necessary.
</p>
</li>
<li><p> The <code>nest_type</code> parameter controls whether nested data are <code>data.table</code> (<code>"dt"</code>) or <code>data.frame</code> (<code>"df"</code>) objects.
</p>
</li>
<li><p> If <code>nest_type</code> is not <code>"dt"</code> or <code>"df"</code>, the function will stop with an error.
</p>
</li></ul>



<h3>See Also</h3>

<p>Related functions and packages:
</p>

<ul>
<li> <p><code><a href="tidytable.html#topic+nest_by">tidytable::nest_by()</a></code> Nest data.tables by group
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Example: Wide to long format nesting demonstrations

# Example 1: Basic nesting by group
w2l_nest(
  data = iris,                    # Input dataset
  by = "Species"                  # Group by Species column
)

# Example 2: Nest specific columns with numeric indices
w2l_nest(
  data = iris,                    # Input dataset
  cols2l = 1:4,                   # Select first 4 columns to nest
  by = "Species"                  # Group by Species column
)

# Example 3: Nest specific columns with column names
w2l_nest(
  data = iris,                    # Input dataset
  cols2l = c("Sepal.Length",      # Select columns by name
             "Sepal.Width", 
             "Petal.Length"),
  by = 5                          # Group by column index 5 (Species)
)
# Returns similar structure to Example 2
</code></pre>

<hr>
<h2 id='w2l_split'>Reshape Wide Data to Long Format and Split into List</h2><span id='topic+w2l_split'></span>

<h3>Description</h3>

<p>The <code>w2l_split</code> function reshapes wide-format data into long-format and splits it into a list
by variable names and optional grouping columns. It handles both <code>data.frame</code> and <code>data.table</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>w2l_split(data, cols2l = NULL, by = NULL, split_type = "dt", sep = "_")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="w2l_split_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>data.table</code>
</p>

<ul>
<li><p> Input dataset in wide format
</p>
</li>
<li><p> Automatically converted to <code>data.table</code> if necessary
</p>
</li></ul>
</td></tr>
<tr><td><code id="w2l_split_+3A_cols2l">cols2l</code></td>
<td>
<p><code>numeric</code> or <code>character</code> columns to transform
</p>

<ul>
<li><p> Specifies columns for wide-to-long conversion
</p>
</li>
<li><p> Can be column indices or column names
</p>
</li>
<li><p> Default is <code>NULL</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="w2l_split_+3A_by">by</code></td>
<td>
<p><code>numeric</code> or <code>character</code> grouping variables
</p>

<ul>
<li><p> Optional columns for data splitting
</p>
</li>
<li><p> Can be column indices or column names
</p>
</li>
<li><p> Used to create hierarchical split structure
</p>
</li>
<li><p> Default is <code>NULL</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="w2l_split_+3A_split_type">split_type</code></td>
<td>
<p><code>character</code> output data type
</p>

<ul>
<li><p> Defines split data object type
</p>
</li>
<li><p> Possible values:
</p>

<ul>
<li> <p><code>"dt"</code>: split <code>data.table</code> objects
</p>
</li>
<li> <p><code>"df"</code>: split <code>data.frame</code> objects
</p>
</li></ul>

</li>
<li><p> Default is <code>"dt"</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="w2l_split_+3A_sep">sep</code></td>
<td>
<p><code>character</code> separator
</p>

<ul>
<li><p> Used for combining split names
</p>
</li>
<li><p> Default is <code>"_"</code>
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>The function melts the specified wide columns into long format and splits the resulting data
into a list based on the variable names and any additional grouping variables specified in <code>by</code>.
The split data can be in the form of <code>data.table</code> or <code>data.frame</code> objects, controlled by the
<code>split_type</code> parameter.
</p>
<p>Both <code>cols2l</code> and <code>by</code> parameters accept either column indices or column names, providing flexible ways
to specify the columns for transformation and splitting.
</p>


<h3>Value</h3>

<p>A list of <code>data.table</code> or <code>data.frame</code> objects (depending on <code>split_type</code>), split by variable
names and optional grouping columns.
</p>

<ul>
<li><p> If <code>by</code> is <code>NULL</code>, returns a list split by variable names only.
</p>
</li>
<li><p> If <code>by</code> is specified, returns a list split by both variable names and grouping variables.
</p>
</li></ul>



<h3>Note</h3>


<ul>
<li><p> Both <code>cols2l</code> and <code>by</code> parameters can be specified using either numeric indices or character column names.
</p>
</li>
<li><p> When using numeric indices, they must be valid column positions in the data (1 to ncol(data)).
</p>
</li>
<li><p> When using character names, all specified columns must exist in the data.
</p>
</li>
<li><p> The function converts <code>data.frame</code> to <code>data.table</code> if necessary.
</p>
</li>
<li><p> The <code>split_type</code> parameter controls whether split data are <code>data.table</code> (<code>"dt"</code>) or <code>data.frame</code> (<code>"df"</code>) objects.
</p>
</li>
<li><p> If <code>split_type</code> is not <code>"dt"</code> or <code>"df"</code>, the function will stop with an error.
</p>
</li></ul>



<h3>See Also</h3>

<p>Related functions and packages:
</p>

<ul>
<li> <p><code><a href="tidytable.html#topic+group_split">tidytable::group_split()</a></code> Split data frame by groups
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Example: Wide to long format splitting demonstrations

# Example 1: Basic splitting by Species
w2l_split(
  data = iris,                    # Input dataset
  by = "Species"                  # Split by Species column
) |&gt; 
  lapply(head)                    # Show first 6 rows of each split

# Example 2: Split specific columns using numeric indices
w2l_split(
  data = iris,                    # Input dataset
  cols2l = 1:3,                   # Select first 3 columns to split
  by = 5                          # Split by column index 5 (Species)
) |&gt; 
  lapply(head)                    # Show first 6 rows of each split

# Example 3: Split specific columns using column names
list_res &lt;- w2l_split(
  data = iris,                    # Input dataset
  cols2l = c("Sepal.Length",      # Select columns by name
             "Sepal.Width"),
  by = "Species"                  # Split by Species column
)
lapply(list_res, head)            # Show first 6 rows of each split
# Returns similar structure to Example 2
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
