<!DOCTYPE html><html lang="en"><head><title>Help for package spBayes</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {spBayes}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adaptMetropGibbs'><p>Adaptive Metropolis within Gibbs algorithm</p></a></li>
<li><a href='#bayesGeostatExact'><p>Simple Bayesian spatial linear model with fixed semivariogram parameters</p></a></li>
<li><a href='#bayesLMConjugate'><p>Simple Bayesian linear model via the Normal/inverse-Gamma conjugate</p></a></li>
<li><a href='#bayesLMRef'><p>Simple Bayesian linear model with non-informative priors</p></a></li>
<li><a href='#BEF.dat'><p>Bartlett Experimental Forest inventory data</p></a></li>
<li><a href='#FBC07.dat'><p>Synthetic multivariate data with spatial and non-spatial variance</p>
structures</a></li>
<li><a href='#FORMGMT.dat'><p>Data used for illustrations</p></a></li>
<li><a href='#iDist'><p>Euclidean distance matrix</p></a></li>
<li><a href='#mkMvX'><p>Make a multivariate design matrix</p></a></li>
<li><a href='#mkSpCov'><p>Function for calculating univariate and multivariate covariance matrices</p></a></li>
<li><a href='#NETemp.dat'><p>Monthly weather station temperature data across the Northeastern US</p></a></li>
<li><a href='#NYOzone.dat'><p>Observations of ozone concentration levels.</p></a></li>
<li><a href='#PM10.dat'><p>Observed and modeled PM10 concentrations across Europe</p></a></li>
<li><a href='#PM10.poly'><p>European countries used in PM10.dat</p></a></li>
<li><a href='#pointsInPoly'><p>Finds points in a polygon</p></a></li>
<li><a href='#spDiag'><p>Model fit diagnostics</p></a></li>
<li><a href='#spDynLM'><p>Function for fitting univariate Bayesian dynamic space-time regression models</p></a></li>
<li><a href='#spGLM'><p>Function for fitting univariate Bayesian generalized linear spatial regression models</p></a></li>
<li><a href='#spLM'><p>Function for fitting univariate Bayesian spatial regression models</p></a></li>
<li><a href='#spMisalignGLM'><p>Function for fitting multivariate generalized linear Bayesian spatial regression models to misaligned data</p></a></li>
<li><a href='#spMisalignLM'><p>Function for fitting multivariate Bayesian spatial regression</p>
models to misaligned data</a></li>
<li><a href='#spMvGLM'><p>Function for fitting multivariate Bayesian generalized linear spatial regression models</p></a></li>
<li><a href='#spMvLM'><p>Function for fitting multivariate Bayesian spatial regression models</p></a></li>
<li><a href='#spPredict'><p>Function for new locations given a model object</p></a></li>
<li><a href='#spRecover'><p>Function for recovering regression coefficients and spatial</p>
random effects for <code>spLM</code>, <code>spMvLM</code>,
<code>spMisalignLM</code>, <code>spSVC</code> using composition sampling</a></li>
<li><a href='#spSVC'><p>Function for fitting univariate Bayesian spatially-varying</p>
coefficient regression models</a></li>
<li><a href='#SVCMvData.dat'><p>Synthetic data from a space-varying coefficients model</p></a></li>
<li><a href='#WEF.dat'><p>Western Experimental Forest inventory data</p></a></li>
<li><a href='#Zurich.dat'><p>Zurichberg Forest inventory data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.4-8</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-09-23</td>
</tr>
<tr>
<td>Title:</td>
<td>Univariate and Multivariate Spatial-Temporal Modeling</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andrew Finley &lt;finleya@msu.edu&gt;</td>
</tr>
<tr>
<td>Author:</td>
<td>Andrew Finley [aut, cre],
  Sudipto Banerjee [aut]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 1.8.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>coda, sp, magic, Formula, Matrix</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MBA</td>
</tr>
<tr>
<td>Description:</td>
<td>Fits univariate and multivariate spatio-temporal
        random effects models for point-referenced data using Markov chain Monte Carlo (MCMC). Details are given in Finley, Banerjee, and Gelfand (2015) &lt;<a href="https://doi.org/10.18637%2Fjss.v063.i13">doi:10.18637/jss.v063.i13</a>&gt; and Finley and Banerjee &lt;<a href="https://doi.org/10.1016%2Fj.envsoft.2019.104608">doi:10.1016/j.envsoft.2019.104608</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.finley-lab.com">https://www.finley-lab.com</a></td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-23 17:31:03 UTC; andy</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-23 18:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='adaptMetropGibbs'>Adaptive Metropolis within Gibbs algorithm</h2><span id='topic+adaptMetropGibbs'></span>

<h3>Description</h3>

<p>Markov chain Monte Carlo for continuous random vector using an
adaptive Metropolis within Gibbs algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adaptMetropGibbs(ltd, starting, tuning=1, accept.rate=0.44,
                 batch = 1, batch.length=25, report=100,
                 verbose=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adaptMetropGibbs_+3A_ltd">ltd</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> function that evaluates the log target density of the
desired equilibrium distribution of the Markov chain. First argument is the
starting value vector of the Markov chain. Pass variables used in
the <code>ltd</code> via the ... argument of <code>aMetropGibbs</code>.</p>
</td></tr>
<tr><td><code id="adaptMetropGibbs_+3A_starting">starting</code></td>
<td>
<p>a real vector of parameter starting values. </p>
</td></tr>
<tr><td><code id="adaptMetropGibbs_+3A_tuning">tuning</code></td>
<td>
<p> a scalar or vector of initial Metropolis tuning values. The vector must be of <code>length(starting)</code>. If a scalar is passed then it is expanded to <code>length(starting)</code>.</p>
</td></tr>
<tr><td><code id="adaptMetropGibbs_+3A_accept.rate">accept.rate</code></td>
<td>
<p> a scalar or vector of target Metropolis acceptance
rates. The vector must be of <code>length(starting)</code>. If a scalar is passed then it is expanded to <code>length(starting)</code>.</p>
</td></tr>
<tr><td><code id="adaptMetropGibbs_+3A_batch">batch</code></td>
<td>
<p>the number of batches. </p>
</td></tr> 
<tr><td><code id="adaptMetropGibbs_+3A_batch.length">batch.length</code></td>
<td>
<p>the number of sampler iterations in each batch. </p>
</td></tr>
<tr><td><code id="adaptMetropGibbs_+3A_report">report</code></td>
<td>
<p>the number of batches between acceptance rate reports. </p>
</td></tr>
<tr><td><code id="adaptMetropGibbs_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, progress of the
sampler is printed to the screen. Otherwise, nothing is printed to
the screen.  </p>
</td></tr>
<tr><td><code id="adaptMetropGibbs_+3A_...">...</code></td>
<td>
<p>currently no additional arguments.  </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following tags:
</p>
<table role = "presentation">
<tr><td><code>p.theta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples for the parameters. </p>
</td></tr>
<tr><td><code>acceptance</code></td>
<td>
<p>the Metropolis acceptance rate at the end of each
batch. </p>
</td></tr>
<tr><td><code>ltd</code></td>
<td>
<p><code>ltd</code> </p>
</td></tr>
<tr><td><code>accept.rate</code></td>
<td>
<p><code>accept.rate</code> </p>
</td></tr>
<tr><td><code>batch</code></td>
<td>
<p><code>batch</code> </p>
</td></tr>
<tr><td><code>batch.length</code></td>
<td>
<p><code>batch.length</code> </p>
</td></tr>
<tr><td><code>proc.time</code></td>
<td>
<p>the elapsed CPU and wall time (in seconds). </p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is a rework of Rosenthal (2007) with some added
niceties. </p>


<h3>Author(s)</h3>

<p>Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>, <br />
Sudipto Banerjee <a href="mailto:sudiptob@biostat.umn.edu">sudiptob@biostat.umn.edu</a>
</p>


<h3>References</h3>

<p>Roberts G.O. and Rosenthal J.S. (2006). Examples of Adaptive MCMC. <a href="http://probability.ca/jeff/ftpdir/adaptex.pdf">http://probability.ca/jeff/ftpdir/adaptex.pdf</a> Preprint.
</p>
<p>Rosenthal J.S. (2007). AMCMC: An R interface for adaptive MCMC. <em>Computational
Statistics and Data Analysis</em>. 51:5467-5470.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
rmvn &lt;- function(n, mu=0, V = matrix(1)){
  p &lt;- length(mu)
  if(any(is.na(match(dim(V),p))))
    stop("Dimension problem!")
  D &lt;- chol(V)
  t(matrix(rnorm(n*p), ncol=p)%*%D + rep(mu,rep(n,p)))
}

###########################
##Fit a spatial regression
###########################
set.seed(1)
n &lt;- 50
x &lt;- runif(n, 0, 100)
y &lt;- runif(n, 0, 100)

D &lt;- as.matrix(dist(cbind(x, y)))

phi &lt;- 3/50
sigmasq &lt;- 50
tausq &lt;- 20
mu &lt;- 150

s &lt;- (sigmasq*exp(-phi*D))
w &lt;-  rmvn(1, rep(0, n), s)
Y &lt;- rmvn(1, rep(mu, n) + w, tausq*diag(n))
X &lt;- as.matrix(rep(1, length(Y)))

##Priors
##IG sigma^2 and tau^2
a.sig &lt;- 2 
b.sig &lt;- 100
a.tau &lt;- 2
b.tau &lt;- 100

##Unif phi
a.phi &lt;- 3/100
b.phi &lt;- 3/1

##Functions used to transform phi to continuous support.
logit &lt;- function(theta, a, b){log((theta-a)/(b-theta))}
logit.inv &lt;- function(z, a, b){b-(b-a)/(1+exp(z))}

##Metrop. target
target &lt;- function(theta){
  
  mu.cand &lt;- theta[1]
  sigmasq.cand &lt;- exp(theta[2])
  tausq.cand &lt;- exp(theta[3])
  phi.cand &lt;- logit.inv(theta[4], a.phi, b.phi)

  Sigma &lt;- sigmasq.cand*exp(-phi.cand*D)+tausq.cand*diag(n)
  SigmaInv &lt;- chol2inv(chol(Sigma))
  logDetSigma &lt;- determinant(Sigma, log=TRUE)$modulus[1]
  
  out &lt;- (
          ##Priors
          -(a.sig+1)*log(sigmasq.cand) - b.sig/sigmasq.cand
          -(a.tau+1)*log(tausq.cand) - b.tau/tausq.cand
          ##Jacobians
          +log(sigmasq.cand) + log(tausq.cand) 
          +log(phi.cand - a.phi) + log(b.phi -phi.cand) 
          ##Likelihood
          -0.5*logDetSigma-0.5*(t(Y-X%*%mu.cand)%*%SigmaInv%*%(Y-X%*%mu.cand))
          )
  
  return(out)
}


##Run a couple chains
n.batch &lt;- 500
batch.length &lt;- 25

inits &lt;- c(0, log(1), log(1), logit(3/10, a.phi, b.phi))
chain.1 &lt;- adaptMetropGibbs(ltd=target, starting=inits,
                            batch=n.batch, batch.length=batch.length, report=100)

inits &lt;- c(500, log(100), log(100), logit(3/90, a.phi, b.phi))
chain.2 &lt;- adaptMetropGibbs(ltd=target, starting=inits,
                            batch=n.batch, batch.length=batch.length, report=100)

##Check out acceptance rate just for fun
plot(mcmc.list(mcmc(chain.1$acceptance), mcmc(chain.2$acceptance)))

##Back transform
chain.1$p.theta.samples[,2] &lt;- exp(chain.1$p.theta.samples[,2])
chain.1$p.theta.samples[,3] &lt;- exp(chain.1$p.theta.samples[,3])
chain.1$p.theta.samples[,4] &lt;- 3/logit.inv(chain.1$p.theta.samples[,4], a.phi, b.phi)

chain.2$p.theta.samples[,2] &lt;- exp(chain.2$p.theta.samples[,2])
chain.2$p.theta.samples[,3] &lt;- exp(chain.2$p.theta.samples[,3])
chain.2$p.theta.samples[,4] &lt;- 3/logit.inv(chain.2$p.theta.samples[,4], a.phi, b.phi)

par.names &lt;- c("mu", "sigma.sq", "tau.sq", "effective range (-log(0.05)/phi)")
colnames(chain.1$p.theta.samples) &lt;- par.names
colnames(chain.2$p.theta.samples) &lt;- par.names

##Discard burn.in and plot and do some convergence diagnostics
chains &lt;- mcmc.list(mcmc(chain.1$p.theta.samples), mcmc(chain.2$p.theta.samples))
plot(window(chains, start=as.integer(0.5*n.batch*batch.length)))

gelman.diag(chains)

##########################
##Example of fitting a
##a non-linear model
##########################
##Example of fitting a non-linear model
set.seed(1)

########################################################
##Simulate some data.
########################################################
a &lt;- 0.1 #-Inf &lt; a &lt; Inf
b &lt;- 0.1 #b &gt; 0
c &lt;- 0.2 #c &gt; 0
tau.sq &lt;- 0.1 #tau.sq &gt; 0

fn &lt;- function(a,b,c,x){
  a+b*exp(x/c)
}

n &lt;- 200
x &lt;- seq(0,1,0.01)
y &lt;- rnorm(length(x), fn(a,b,c,x), sqrt(tau.sq))

##check out your data
plot(x, y)

########################################################
##The log target density
########################################################
##Define the log target density used in the Metrop.
ltd &lt;- function(theta){

  ##extract and transform as needed
  a &lt;- theta[1]
  b &lt;- exp(theta[2])
  c &lt;- exp(theta[3])
  tau.sq &lt;- exp(theta[4])

  y.hat &lt;- fn(a, b, c, x)

  ##likelihood
  logl &lt;- sum(dnorm(y, y.hat, sqrt(tau.sq), log=TRUE))

  ##priors IG on tau.sq and normal on a and transformed b, c, d
  logl &lt;- (logl
           -(IG.a+1)*log(tau.sq)-IG.b/tau.sq
           +sum(dnorm(theta[1:3], N.mu, N.v, log=TRUE))
           )
  
  ##Jacobian adjustment for tau.sq
  logl &lt;- logl+log(tau.sq)
  
  return(logl)  
}

########################################################
##The rest
########################################################

##Priors
IG.a &lt;- 2
IG.b &lt;- 0.01

N.mu &lt;- 0
N.v &lt;- 10

theta.tuning &lt;- c(0.01, 0.01, 0.005, 0.01)

##Run three chains with different starting values
n.batch &lt;- 1000
batch.length &lt;- 25

theta.starting &lt;- c(0, log(0.01), log(0.6), log(0.01))
run.1 &lt;- adaptMetropGibbs(ltd=ltd, starting=theta.starting, tuning=theta.tuning,
                          batch=n.batch, batch.length=batch.length, report=100)

theta.starting &lt;- c(1.5, log(0.05), log(0.5), log(0.05))
run.2 &lt;- adaptMetropGibbs(ltd=ltd, starting=theta.starting, tuning=theta.tuning,
                          batch=n.batch, batch.length=batch.length, report=100)

theta.starting &lt;- c(-1.5, log(0.1), log(0.4), log(0.1))
run.3 &lt;- adaptMetropGibbs(ltd=ltd, starting=theta.starting, tuning=theta.tuning,
                          batch=n.batch, batch.length=batch.length, report=100)

##Back transform
samples.1 &lt;- cbind(run.1$p.theta.samples[,1], exp(run.1$p.theta.samples[,2:4]))
samples.2 &lt;- cbind(run.2$p.theta.samples[,1], exp(run.2$p.theta.samples[,2:4]))
samples.3 &lt;- cbind(run.3$p.theta.samples[,1], exp(run.3$p.theta.samples[,2:4]))

samples &lt;- mcmc.list(mcmc(samples.1), mcmc(samples.2), mcmc(samples.3))

##Summary 
plot(samples, density=FALSE)
gelman.plot(samples)

burn.in &lt;- 5000

fn.pred &lt;- function(theta,x){
  a &lt;- theta[1]
  b &lt;- theta[2]
  c &lt;- theta[3]
  tau.sq &lt;- theta[4]
  
  rnorm(length(x), fn(a,b,c,x), sqrt(tau.sq))
}

post.curves &lt;- t(apply(samples.1[burn.in:nrow(samples.1),], 1, fn.pred, x))

post.curves.quants &lt;- summary(mcmc(post.curves))$quantiles

plot(x, y, pch=19, xlab="x", ylab="f(x)")
lines(x, post.curves.quants[,1], lty="dashed", col="blue")
lines(x, post.curves.quants[,3])
lines(x, post.curves.quants[,5], lty="dashed", col="blue")



## End(Not run)
</code></pre>

<hr>
<h2 id='bayesGeostatExact'>Simple Bayesian spatial linear model with fixed semivariogram parameters </h2><span id='topic+bayesGeostatExact'></span>

<h3>Description</h3>

<p>Given a observation coordinates and fixed semivariogram
parameters the <code>bayesGeostatExact</code> function fits a
simple Bayesian spatial linear model.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  bayesGeostatExact(formula, data = parent.frame(), n.samples,
                     beta.prior.mean, beta.prior.precision,
                     coords, cov.model="exponential", phi, nu, alpha,
                     sigma.sq.prior.shape, sigma.sq.prior.rate,
                     sp.effects=TRUE, verbose=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bayesGeostatExact_+3A_formula">formula</code></td>
<td>
<p>for a univariate model, this is a symbolic description of the regression model to be
fit. See example below. </p>
</td></tr>
<tr><td><code id="bayesGeostatExact_+3A_data">data</code></td>
<td>
<p>an optional data frame containing the variables in the
model. If not found in data, the variables are taken from
<code>environment(formula)</code>, typically the environment from which <code>spLM</code> is called.  </p>
</td></tr>
<tr><td><code id="bayesGeostatExact_+3A_n.samples">n.samples</code></td>
<td>
<p>the number of posterior samples to collect. </p>
</td></tr>
<tr><td><code id="bayesGeostatExact_+3A_beta.prior.mean">beta.prior.mean</code></td>
<td>
<p><code class="reqn">\beta</code> multivariate normal mean vector hyperprior. </p>
</td></tr>
<tr><td><code id="bayesGeostatExact_+3A_beta.prior.precision">beta.prior.precision</code></td>
<td>
<p><code class="reqn">\beta</code> multivariate normal precision
matrix hyperprior. </p>
</td></tr>
<tr><td><code id="bayesGeostatExact_+3A_coords">coords</code></td>
<td>
<p>an <code class="reqn">n \times 2</code> matrix of the observation coordinates
in <code class="reqn">R^2</code> (e.g., easting and northing). </p>
</td></tr>
<tr><td><code id="bayesGeostatExact_+3A_cov.model">cov.model</code></td>
<td>
<p>a quoted key word that specifies the covariance
function used to model the spatial dependence structure among the
observations.  Supported covariance model key words are:
<code>"exponential"</code>, <code>"matern"</code>, <code>"spherical"</code>, and
<code>"gaussian"</code>.  See below for details.  </p>
</td></tr>
<tr><td><code id="bayesGeostatExact_+3A_phi">phi</code></td>
<td>
<p>the fixed value of the spatial decay. </p>
</td></tr>
<tr><td><code id="bayesGeostatExact_+3A_nu">nu</code></td>
<td>
<p>if <code>cov.model</code> is <code>"matern"</code> then the fixed value
of the spatial process smoothness must be specified. </p>
</td></tr>
<tr><td><code id="bayesGeostatExact_+3A_alpha">alpha</code></td>
<td>
<p>the fixed value of the ratio between the nugget
<code class="reqn">\tau^2</code> and partial-sill <code class="reqn">\sigma^2</code>
parameters from the specified <code>cov.model</code>. </p>
</td></tr>  
<tr><td><code id="bayesGeostatExact_+3A_sigma.sq.prior.shape">sigma.sq.prior.shape</code></td>
<td>
<p><code class="reqn">\sigma^2</code> (i.e., partial-sill) inverse-Gamma shape
hyperprior. </p>
</td></tr>
<tr><td><code id="bayesGeostatExact_+3A_sigma.sq.prior.rate">sigma.sq.prior.rate</code></td>
<td>
<p><code class="reqn">\sigma^2</code> (i.e., partial-sill) inverse-Gamma 1/scale
hyperprior. </p>
</td></tr>
<tr><td><code id="bayesGeostatExact_+3A_sp.effects">sp.effects</code></td>
<td>
<p>a logical value indicating if spatial random effects
should be recovered. </p>
</td></tr>
<tr><td><code id="bayesGeostatExact_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, model specification and progress of the
sampler is printed to the screen. Otherwise, nothing is printed to
the screen.  </p>
</td></tr>
<tr><td><code id="bayesGeostatExact_+3A_...">...</code></td>
<td>
<p>currently no additional arguments.  </p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>bayesGeostatExact</code>, which is a list with the following tags:
</p>
<table role = "presentation">
<tr><td><code>p.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples for the defined
parameters. </p>
</td></tr>
<tr><td><code>sp.effects</code></td>
<td>
<p>a matrix that holds samples from the posterior
distribution of the spatial random effects. The rows of this matrix
correspond to the <code class="reqn">n</code> point observations and the columns are the
posterior samples. </p>
</td></tr>
<tr><td><code>args</code></td>
<td>
<p>a list with the initial function arguments.  </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sudipto Banerjee <a href="mailto:sudiptob@biostat.umn.edu">sudiptob@biostat.umn.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

data(FBC07.dat)
Y &lt;- FBC07.dat[1:150,"Y.2"]
coords &lt;- as.matrix(FBC07.dat[1:150,c("coord.X", "coord.Y")])

n.samples &lt;- 500
n = length(Y)
p = 1

phi &lt;- 0.15
nu &lt;- 0.5

beta.prior.mean &lt;- as.matrix(rep(0, times=p))
beta.prior.precision &lt;- matrix(0, nrow=p, ncol=p)

alpha &lt;- 5/5

sigma.sq.prior.shape &lt;- 2.0
sigma.sq.prior.rate &lt;- 5.0

##############################
##Simple linear model with
##the default exponential
##spatial decay function
##############################
set.seed(1)
m.1 &lt;- bayesGeostatExact(Y~1, n.samples=n.samples,
                          beta.prior.mean=beta.prior.mean,
                          beta.prior.precision=beta.prior.precision,
                          coords=coords, phi=phi, alpha=alpha,
                          sigma.sq.prior.shape=sigma.sq.prior.shape,
                          sigma.sq.prior.rate=sigma.sq.prior.rate)



print(summary(m.1$p.samples))

##Requires MBA package to
##make surfaces
library(MBA)
par(mfrow=c(1,2))
obs.surf &lt;-
  mba.surf(cbind(coords, Y), no.X=100, no.Y=100, extend=T)$xyz.est
image(obs.surf, xaxs = "r", yaxs = "r", main="Observed response")
points(coords)
contour(obs.surf, add=T)

w.hat &lt;- rowMeans(m.1$sp.effects)
w.surf &lt;-
  mba.surf(cbind(coords, w.hat), no.X=100, no.Y=100, extend=T)$xyz.est
image(w.surf, xaxs = "r", yaxs = "r", main="Estimated random effects")
points(coords)
contour(w.surf, add=T)


##############################
##Simple linear model with
##the matern spatial decay
##function. Note, nu=0.5 so
##should produce the same
##estimates as m.1
##############################
set.seed(1)
m.2 &lt;- bayesGeostatExact(Y~1, n.samples=n.samples,
                          beta.prior.mean=beta.prior.mean,
                          beta.prior.precision=beta.prior.precision,
                          coords=coords, cov.model="matern",
                          phi=phi, nu=nu, alpha=alpha,
                          sigma.sq.prior.shape=sigma.sq.prior.shape,
                          sigma.sq.prior.rate=sigma.sq.prior.rate)

print(summary(m.2$p.samples))

##############################
##This time with the
##spherical just for fun
##############################
m.3 &lt;- bayesGeostatExact(Y~1, n.samples=n.samples,
                          beta.prior.mean=beta.prior.mean,
                          beta.prior.precision=beta.prior.precision,
                          coords=coords, cov.model="spherical",
                          phi=phi, alpha=alpha,
                          sigma.sq.prior.shape=sigma.sq.prior.shape,
                          sigma.sq.prior.rate=sigma.sq.prior.rate)

print(summary(m.3$p.samples))

##############################
##Another example but this
##time with covariates
##############################
data(FORMGMT.dat)

n = nrow(FORMGMT.dat)
p = 5 ##an intercept an four covariates

n.samples &lt;- 50

phi &lt;- 0.0012

coords &lt;- cbind(FORMGMT.dat$Longi, FORMGMT.dat$Lat)
coords &lt;- coords*(pi/180)*6378

beta.prior.mean &lt;- rep(0, times=p)
beta.prior.precision &lt;- matrix(0, nrow=p, ncol=p)

alpha &lt;- 1/1.5

sigma.sq.prior.shape &lt;- 2.0
sigma.sq.prior.rate &lt;- 10.0

m.4 &lt;-
  bayesGeostatExact(Y~X1+X2+X3+X4, data=FORMGMT.dat, n.samples=n.samples,
                     beta.prior.mean=beta.prior.mean,
                     beta.prior.precision=beta.prior.precision,
                     coords=coords, phi=phi, alpha=alpha,
                     sigma.sq.prior.shape=sigma.sq.prior.shape,
                     sigma.sq.prior.rate=sigma.sq.prior.rate)

print(summary(m.4$p.samples))



##Requires MBA package to
##make surfaces
library(MBA)
par(mfrow=c(1,2))
obs.surf &lt;-
  mba.surf(cbind(coords, resid(lm(Y~X1+X2+X3+X4, data=FORMGMT.dat))),
                 no.X=100, no.Y=100, extend=TRUE)$xyz.est
image(obs.surf, xaxs = "r", yaxs = "r", main="Observed response")
points(coords)
contour(obs.surf, add=T)

w.hat &lt;- rowMeans(m.4$sp.effects)
w.surf &lt;-
  mba.surf(cbind(coords, w.hat), no.X=100, no.Y=100, extend=TRUE)$xyz.est
image(w.surf, xaxs = "r", yaxs = "r", main="Estimated random effects")
contour(w.surf, add=T)
points(coords, pch=1, cex=1)



## End(Not run)
</code></pre>

<hr>
<h2 id='bayesLMConjugate'>Simple Bayesian linear model via the Normal/inverse-Gamma conjugate </h2><span id='topic+bayesLMConjugate'></span>

<h3>Description</h3>

<p>Given an <code>lm</code> object, the <code>bayesLMConjugate</code> function fits a
simple Bayesian linear model with Normal and inverse-Gamma priors.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  bayesLMConjugate(formula, data = parent.frame(), n.samples,
                     beta.prior.mean, beta.prior.precision,
                     prior.shape, prior.rate, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bayesLMConjugate_+3A_formula">formula</code></td>
<td>
<p>for a univariate model, this is a symbolic description of the regression model to be
fit. See example below. </p>
</td></tr>
<tr><td><code id="bayesLMConjugate_+3A_data">data</code></td>
<td>
<p>an optional data frame containing the variables in the
model. If not found in data, the variables are taken from
<code>environment(formula)</code>, typically the environment from which <code>spLM</code> is called.  </p>
</td></tr>
<tr><td><code id="bayesLMConjugate_+3A_n.samples">n.samples</code></td>
<td>
<p>the number of posterior samples to collect. </p>
</td></tr>
<tr><td><code id="bayesLMConjugate_+3A_beta.prior.mean">beta.prior.mean</code></td>
<td>
<p><code class="reqn">\beta</code> multivariate normal mean vector hyperprior. </p>
</td></tr>
<tr><td><code id="bayesLMConjugate_+3A_beta.prior.precision">beta.prior.precision</code></td>
<td>
<p><code class="reqn">\beta</code> multivariate normal precision
matrix hyperprior. </p>
</td></tr>
<tr><td><code id="bayesLMConjugate_+3A_prior.shape">prior.shape</code></td>
<td>
<p><code class="reqn">\tau^2</code> inverse-Gamma shape
hyperprior. </p>
</td></tr>
<tr><td><code id="bayesLMConjugate_+3A_prior.rate">prior.rate</code></td>
<td>
<p><code class="reqn">\tau^2</code> inverse-Gamma 1/scale
hyperprior. </p>
</td></tr>
<tr><td><code id="bayesLMConjugate_+3A_...">...</code></td>
<td>
<p>currently no additional arguments.  </p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>bayesLMConjugate</code>, which is a list with at
least the following tag:
</p>
<table role = "presentation">
<tr><td><code>p.beta.tauSq.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples for the defined parameters. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sudipto Banerjee <a href="mailto:sudiptob@biostat.umn.edu">sudiptob@biostat.umn.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

data(FORMGMT.dat)

n &lt;- nrow(FORMGMT.dat)
p &lt;- 7 ##an intercept and six covariates

n.samples &lt;- 500

## Below we demonstrate the conjugate function in the special case
## with improper priors. The results are the same as for the above,
## up to MC error. 
beta.prior.mean &lt;- rep(0, times=p)
beta.prior.precision &lt;- matrix(0, nrow=p, ncol=p)

prior.shape &lt;- -p/2
prior.rate &lt;- 0

m.1 &lt;-
  bayesLMConjugate(Y ~ X1+X2+X3+X4+X5+X6, data = FORMGMT.dat,
                     n.samples, beta.prior.mean,
                     beta.prior.precision,
                     prior.shape, prior.rate)

summary(m.1$p.beta.tauSq.samples)

## End(Not run)
</code></pre>

<hr>
<h2 id='bayesLMRef'>Simple Bayesian linear model with non-informative priors </h2><span id='topic+bayesLMRef'></span>

<h3>Description</h3>

<p>Given a <code>lm</code> object, the <code>bayesLMRef</code> function fits a
simple Bayesian linear model with reference (non-informative) priors.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  bayesLMRef(lm.obj, n.samples, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bayesLMRef_+3A_lm.obj">lm.obj</code></td>
<td>
<p>an object returned by <code>lm</code>. </p>
</td></tr>
<tr><td><code id="bayesLMRef_+3A_n.samples">n.samples</code></td>
<td>
<p>the number of posterior samples to collect. </p>
</td></tr>
<tr><td><code id="bayesLMRef_+3A_...">...</code></td>
<td>
<p>currently no additional arguments.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>See page 355 in Gelman et al. (2004).
</p>


<h3>Value</h3>

<p>An object of class <code>bayesLMRef</code>, which is a list with at
least the following tag:
</p>
<table role = "presentation">
<tr><td><code>p.beta.tauSq.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples for the defined parameters. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sudipto Banerjee <a href="mailto:sudiptob@biostat.umn.edu">sudiptob@biostat.umn.edu</a>, <br />
Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>
</p>


<h3>References</h3>

<p>Gelman, A., Carlin, J.B., Stern, H.S., and Rubin, D.B. (2004). Bayesian Data Analysis. 2nd ed. Boca Raton, FL: Chapman and Hall/CRC Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(1)

n &lt;- 100
X &lt;- as.matrix(cbind(1, rnorm(n)))
B &lt;- as.matrix(c(1,5))
tau.sq &lt;- 0.1
y &lt;- rnorm(n, X%*%B, sqrt(tau.sq))

lm.obj &lt;- lm(y ~ X-1)

summary(lm.obj)

##Now with bayesLMRef
n.samples &lt;- 500

m.1 &lt;- bayesLMRef(lm.obj, n.samples)

summary(m.1$p.beta.tauSq.samples)

## End(Not run)
</code></pre>

<hr>
<h2 id='BEF.dat'>Bartlett Experimental Forest inventory data</h2><span id='topic+BEF.dat'></span>

<h3>Description</h3>

<p>Data generated in long-term research studies on the Bartlett
Experimental Forest, Bartlett, NH funded by the U.S. Department
of Agriculture, Forest Service, Northeastern Research Station.
</p>
<p>This dataset holds 1991 and 2002 forest inventory data for 437 points
on the BEF.dat. Variables include species specific basal area and biomass;
inventory plot coordinates; slope; elevation; and tasseled cap brightness (TC1),
greenness (TC2), and wetness (TC3) components from spring, summer,
and fall 2002 Landsat images.
</p>
<p>Species specific basal area and biomass are recorded as a fraction of totals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(BEF.dat)
</code></pre>


<h3>Format</h3>

<p>A data frame containing 437 rows and 208 columns.
</p>


<h3>Source</h3>

<p>BEF.dat inventory data provided by:
</p>
<p>Marie-Louise Smith
USDA Forest Service
Northeastern Research Station
<a href="mailto:marielouisesmith@fs.fed.us">marielouisesmith@fs.fed.us</a>
</p>
<p>Additional variables provided by:
</p>
<p>Andrew Lister
USDA Forest Service
Northeastern Research Station
<a href="mailto:alister@fs.fed.us">alister@fs.fed.us</a>
</p>

<hr>
<h2 id='FBC07.dat'>Synthetic multivariate data with spatial and non-spatial variance
structures</h2><span id='topic+FBC07.dat'></span>

<h3>Description</h3>

<p>The synthetic dataset describes a stationary and isotropic bivariate process. Please refer to the vignette Section 4.2 for specifics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(FBC07.dat)
</code></pre>


<h3>Format</h3>

<p>A data frame of 250 rows and 4 columns. Columns 1 and 2 are
coordinates and columns 3 and 4 are response variables.
</p>


<h3>Source</h3>

<p>Finley A.O., S. Banerjee, and B.P. Carlin (2007) spBayes: R package for Univariate and Multivariate
Hierarchical Point-referenced Spatial Models. Journal of Statistical Software.
</p>

<hr>
<h2 id='FORMGMT.dat'>Data used for illustrations</h2><span id='topic+FORMGMT.dat'></span>

<h3>Description</h3>

<p>Data used for illustrations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(FORMGMT.dat)
</code></pre>

<hr>
<h2 id='iDist'>Euclidean distance matrix</h2><span id='topic+iDist'></span>

<h3>Description</h3>

<p>Computes the inter-site Euclidean distance matrix for one or two sets of points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> iDist(coords.1, coords.2, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iDist_+3A_coords.1">coords.1</code></td>
<td>
<p>an <code class="reqn">n\times p</code> matrix with each row
corresponding to a point in <code class="reqn">p</code> dimensional space. </p>
</td></tr>
<tr><td><code id="iDist_+3A_coords.2">coords.2</code></td>
<td>
<p>an <code class="reqn">m\times p</code> matrix with each row
corresponding to a point in <code class="reqn">p</code> dimensional space. If this is
missing then <code>coords.1</code> is used. </p>
</td></tr>
<tr><td><code id="iDist_+3A_...">...</code></td>
<td>
<p>currently no additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code class="reqn">n\times n</code> or <code class="reqn">n\times m</code> inter-site Euclidean distance matrix.
</p>


<h3>Author(s)</h3>

<p>Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>, <br />
Sudipto Banerjee <a href="mailto:sudiptob@biostat.umn.edu">sudiptob@biostat.umn.edu</a>, <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
n &lt;- 10
p1 &lt;- cbind(runif(n),runif(n))

m &lt;- 5
p2 &lt;- cbind(runif(m),runif(m))

D &lt;- iDist(p1, p2)

## End(Not run)
</code></pre>

<hr>
<h2 id='mkMvX'>Make a multivariate design matrix</h2><span id='topic+mkMvX'></span>

<h3>Description</h3>

<p>Given <code class="reqn">q</code> univariate design matrices, the function
<code>mkMvX</code> creates a multivariate design matrix suitable for use in <code><a href="#topic+spPredict">spPredict</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  mkMvX(X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mkMvX_+3A_x">X</code></td>
<td>
<p>a list of <code class="reqn">q</code> univariate design matrices.  The
matrices must have the same number of rows (i.e., observations) but
may have different number of columns (i.e., regressors). </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A multivariate design matrix suitable for use in <code><a href="#topic+spPredict">spPredict</a></code>.
</p>


<h3>Author(s)</h3>

<p>Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>, <br />
Sudipto Banerjee <a href="mailto:sudiptob@biostat.umn.edu">sudiptob@biostat.umn.edu</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spPredict">spPredict</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
##Define some univariate model design matrices
##with intercepts.
X.1 &lt;- cbind(rep(1, 10), matrix(rnorm(50), nrow=10))
X.2 &lt;- cbind(rep(1, 10), matrix(rnorm(20), nrow=10))
X.3 &lt;- cbind(rep(1, 10), matrix(rnorm(30), nrow=10))

##Make a multivariate design matrix suitable
##for use in spPredict.
X.mv &lt;- mkMvX(list(X.1, X.2, X.3))

## End(Not run)
</code></pre>

<hr>
<h2 id='mkSpCov'>Function for calculating univariate and multivariate covariance matrices</h2><span id='topic+mkSpCov'></span>

<h3>Description</h3>

<p>The function <code>mkSpCov</code> calculates a spatial covariance matrix
given spatial locations and spatial covariance parameters. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mkSpCov(coords, K, Psi, theta, cov.model)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mkSpCov_+3A_coords">coords</code></td>
<td>
<p>an <code class="reqn">n \times 2</code> matrix of the observation coordinates
in <code class="reqn">R^2</code> (e.g., easting and northing). </p>
</td></tr>
<tr><td><code id="mkSpCov_+3A_k">K</code></td>
<td>
<p>the <code class="reqn">q \times q</code> spatial cross-covariance
matrix. For a univariate model this corresponds to the partial sill,
<code class="reqn">\sigma^2</code>.</p>
</td></tr>
<tr><td><code id="mkSpCov_+3A_psi">Psi</code></td>
<td>
<p>the <code class="reqn">q \times q</code> non-spatial covariance
matrix. For a univariate model this corresponds to the nugget,
<code class="reqn">\tau^2</code>.</p>
</td></tr>
<tr><td><code id="mkSpCov_+3A_theta">theta</code></td>
<td>
<p>a vector of <code class="reqn">q</code> spatial decay parameters. If
<code>cov.model</code> is <code>"matern"</code> then <code>theta</code> is a vector of
length <code class="reqn">2\times q</code> with the spatial decay parameters in the first
<code class="reqn">q</code> elements and the spatial smoothness parameters in the last
<code class="reqn">q</code> elements.</p>
</td></tr>
<tr><td><code id="mkSpCov_+3A_cov.model">cov.model</code></td>
<td>
<p>a quoted keyword that specifies the covariance
function used to model the spatial dependence structure among the
observations.  Supported covariance model key words are:
<code>"exponential"</code>, <code>"matern"</code>, <code>"spherical"</code>, and
<code>"gaussian"</code>.  See below for details.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Covariance functions return the covariance
<code class="reqn">C(h)</code> between a pair locations separated by distance <code class="reqn">h</code>. The covariance function can be written as a product of a variance parameter <code class="reqn">\sigma^2</code> and a positive definite <em>correlation function</em> <code class="reqn">\rho(h)</code>: <code class="reqn">C(h) = \sigma^2 \rho(h)</code>, see, e.g.,
Banerjee et al. (2004) p. 27 for more details. The expressions of the correlations functions available in <span class="pkg">spBayes</span> are given below. More will be added upon request.
</p>
<p>For all correlations functions, <code class="reqn">\phi</code> is the spatial <em>decay</em> parameter.
Some of the correlation functions will have an extra parameter
<code class="reqn">\nu</code>, the <em>smoothness</em> parameter.
<code class="reqn">K_\nu(x)</code> denotes the modified Bessel
function of the third kind of order <code class="reqn">\nu</code>. See
documentation of the function <code>besselK</code> for further details.
The following functions are valid for <code class="reqn">\phi&gt;0</code> and <code class="reqn">\nu&gt;0</code>, unless stated otherwise.
</p>
<p><b>gaussian</b><br />
</p>
<p style="text-align: center;"><code class="reqn">\rho(h) = \exp[-(\phi h)^2]</code>
</p>
 
<p><b>exponential</b><br />
</p>
<p style="text-align: center;"><code class="reqn">\rho(h) = \exp(-\phi h)</code>
</p>

<p><b>matern</b><br />
</p>
<p style="text-align: center;"><code class="reqn">\rho(h) =
    \frac{1}{2^{\nu-1}\Gamma(\nu)}(\phi h)^\nu
    K_{\nu}(\phi h)</code>
</p>
 
<p><b>spherical</b><br />
</p>
<p style="text-align: center;"><code class="reqn">\rho(h) = \left\{ \begin{array}{ll}
    1 - 1.5\phi h + 0.5(\phi h)^3
    \mbox{ , if $h$ &lt; $\frac{1}{\phi}$} \cr
    0    \mbox{ ,  otherwise}
    \end{array} \right.</code>
</p>



<h3>Value</h3>

<table role = "presentation">
<tr><td><code>C</code></td>
<td>
<p>the <code class="reqn">nq\times nq</code> spatial covariance matrix. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>, <br />
Sudipto Banerjee <a href="mailto:baner009@umn.edu">baner009@umn.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
##A bivariate spatial covariance matrix

n &lt;- 2 ##number of locations
q &lt;- 2 ##number of responses at each location
nltr &lt;- q*(q+1)/2 ##number of triangular elements in the cross-covariance matrix

coords &lt;- cbind(runif(n,0,1), runif(n,0,1))

##spatial decay parameters
theta &lt;- rep(6,q)

A &lt;- matrix(0,q,q)
A[lower.tri(A,TRUE)] &lt;- rnorm(nltr, 5, 1)
K &lt;- A%*%t(A)

Psi &lt;- diag(1,q)

C &lt;- mkSpCov(coords, K, Psi, theta, cov.model="exponential")

## End(Not run)
</code></pre>

<hr>
<h2 id='NETemp.dat'>Monthly weather station temperature data across the Northeastern US</h2><span id='topic+NETemp.dat'></span>

<h3>Description</h3>

<p>Monthly temperature data (Celsius) recorded across the Northeastern US
starting in January 2000. Station UTM coordinates and elevation are also included.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(NETemp.dat)
</code></pre>


<h3>Format</h3>

<p>A data frame containing 356 rows (weather stations) and 132 columns. 
</p>

<hr>
<h2 id='NYOzone.dat'>Observations of ozone concentration levels.</h2><span id='topic+NYOzone.dat'></span>

<h3>Description</h3>

<p>These data and subsequent description are drawn from the
<span class="pkg">spTimer</span> package (version 0.7). This data set contains values of daily 
8-hour maximum average ozone concentrations (ppb; O3.8HRMAX), maximum  temperature (degree Celsius; cMAXTMP), wind speed
(knots; WDSP), and 
relative humidity (RM), obtained from 28 monitoring sites in New
York, USA, between July 1 and August 31
in 2006. Each row represents a station and columns hold
consecutive daily values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(NYOzone.dat)
</code></pre>


<h3>Format</h3>

<p>Columns for NYdata:
</p>

<ul>
<li><p>   1st col = Longitude
</p>
</li>
<li><p>   2nd col = Latitude
</p>
</li>
<li><p>   3rd col = X coordinates in UTM projection
</p>
</li>
<li><p>   4th col = Y coordinates in UTM projection
</p>
</li>
<li><p>   5th col = Ozone July 1 (O3.8HRMAX.1) 
</p>
</li>
<li><p>   6th col = Ozone July 2 (O3.8HRMAX.2)
</p>
</li>
<li><p>   ...
</p>
</li>
<li><p>   66th col = Ozone August 31 (O3.8HRMAX.62)
</p>
</li>
<li><p>   remaining columns organize cMAXTMP, WDSP, and RH
identical to the 62 O3.8HRMAX measurements
</p>
</li></ul>



<h3>References</h3>

<p><span class="pkg">spTimer</span> Bakar, K.S. and S.K. Sahu. <a href="http://www.southampton.ac.uk/~sks/research/papers/spTimeRpaper.pdf">http://www.southampton.ac.uk/~sks/research/papers/spTimeRpaper.pdf</a>
</p>
<p>Sahu, S.K. and K.S. Bakar. (2012) A Comparison of Bayesian Models for Daily Ozone Concentration Levels. <em>Statistical Methodology</em>, 9, 144&ndash;157.
</p>

<hr>
<h2 id='PM10.dat'>Observed and modeled PM10 concentrations across Europe</h2><span id='topic+PM10.dat'></span>

<h3>Description</h3>

<p>The <code>PM10.dat</code> data frame is a subset of data analyzed in Hamm
et al. (2015) and Datta et al. (2016). Data comprise April 6, 2010
square root transformed PM10 measurements across
central Europe with corresponding output from the LOTOS-EUROS Schaap et
al. (2008) chemistry transport model (CTM). CTM data may differ
slightly from that considered in the studies noted above due to LOTOS-EUROS CTM
code updates. A <code>NA</code> value is given
at CTM output locations were PM10 is not
observed. Point coordinates are in
&quot;+proj=laea +lat_0=52 +lon_0=10 +x_0=4321000 +y_0=3210000 +ellps=GRS80 +units=km +no_defs&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(PM10.dat)
</code></pre>


<h3>Format</h3>

<p>Columns for PM10.dat:
</p>

<ul>
<li><p> x.coord = x coordinate (see projection information in the description)
</p>
</li>
<li><p> y.coord = y coordinate (see projection information in the description)
</p>
</li>
<li><p> pm10.obs = square root transformed PM10 measurements at
monitoring stations (<code>NA</code> means there is not a station at the
given location)
</p>
</li>
<li><p> pm10.ctm = square root transformed PM10 from CTM
</p>
</li></ul>



<h3>References</h3>

<p>Datta A., S. Banerjee, A.O. Finley, N. Hamm, and M. Schaap (2016). Nonseparable dynamic nearest neighbor Gaussian process models for large spatio-temporal data with an application to particulate matter analysis. <em>Annals of Applied Statistics</em>, 10(3), 1286&ndash;1316. ISSN 1932-6157. doi:10.1214/16-AOAS931.
</p>
<p>Hamm N. A.O. Finley, M. Schaap, A. Stein (2015). A Spatially Varying
Coefficient Model for Mapping PM10 Air Quality at the European scale. <em>Atmospheric Environment</em>, 102, 393&ndash;405.
</p>
<p>Schaap M., R.M.A Timmermans, M. Roemer, G.A.C. Boersen, P. Builtjes, F. Sauter, G. Velders, J. Beck (2008). The LOTOS-EUROS Model: Description, Validation and Latest Developments. <em>International Journal of Environment and Pollution</em>, 32(2), 270&ndash;290.
</p>

<hr>
<h2 id='PM10.poly'>European countries used in PM10.dat</h2><span id='topic+PM10.poly'></span>

<h3>Description</h3>

<p>European countries corresponding to <code>PM10.dat</code> locations and used in Hamm et al. (2015) and Datta et al. (2016). Polygon projection is &quot;+proj=laea +lat_0=52 +lon_0=10 +x_0=4321000 +y_0=3210000 +ellps=GRS80 +units=km +no_defs&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(PM10.poly)
</code></pre>


<h3>Format</h3>

<p>List of polygons. See example below to convert to a <code>SpatialPolygons</code> object.
</p>


<h3>References</h3>

<p>Datta A., S. Banerjee, A.O. Finley, N. Hamm, and M. Schaap (2016). Nonseparable dynamic nearest neighbor Gaussian process models for large spatio-temporal data with an application to particulate matter analysis. <em>Annals of Applied Statistics</em>, 10(3), 1286&ndash;1316. ISSN 1932-6157. doi:10.1214/16-AOAS931.
</p>
<p>Hamm N. A.O. Finley, M. Schaap, A. Stein (2015). A Spatially Varying
Coefficient Model for Mapping PM10 Air Quality at the European scale. <em>Atmospheric Environment</em>, 102, 393&ndash;405.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

library(sp)

prj &lt;- "+proj=laea +lat_0=52 +lon_0=10 +x_0=4321000 +y_0=3210000 +ellps=GRS80 +units=km +no_defs"

pm10.poly &lt;- SpatialPolygons(PM10.poly, pO = 1:length(PM10.poly), proj4string=CRS(prj))

## End(Not run)

</code></pre>

<hr>
<h2 id='pointsInPoly'>Finds points in a polygon</h2><span id='topic+pointsInPoly'></span>

<h3>Description</h3>

<p>Given a polygon and a set of points this function returns the subset
of points that are within the polygon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> pointsInPoly(poly, points, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pointsInPoly_+3A_poly">poly</code></td>
<td>
<p>an <code class="reqn">n\times 2</code> matrix of polygon vertices. Matrix
columns correspond to vertices' x and y coordinates, respectively. </p>
</td></tr>
<tr><td><code id="pointsInPoly_+3A_points">points</code></td>
<td>
<p>an <code class="reqn">m\times 2</code> matrix of points. Matrix
columns correspond to points' x and y coordinates, respectively.</p>
</td></tr>
<tr><td><code id="pointsInPoly_+3A_...">...</code></td>
<td>
<p>currently no additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is assumed that the polygon is to be closed by joining the last vertex to the first vertex.
</p>


<h3>Value</h3>

<p>If points are found with the polygon, then a vector is returned with
elements corresponding to the row indices of <code>points</code>, otherwise
<code>NA</code> is returned.
</p>


<h3>Author(s)</h3>

<p>Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>, <br />
Sudipto Banerjee <a href="mailto:sudiptob@biostat.umn.edu">sudiptob@biostat.umn.edu</a>, <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
##Example 1
points &lt;- cbind(runif(1000, 0, 10),runif(1000, 0, 10))

poly &lt;- cbind(c(1:9,8:1), c(1,2*(5:3),2,-1,17,9,8,2:9))

point.indx &lt;- pointsInPoly(poly, points)

plot(points, pch=19, cex=0.5, xlab="x", ylab="y", col="red")
points(points[point.indx,], pch=19, cex=0.5, col="blue")
polygon(poly)

##Example 2
##a function to partition the domain
tiles &lt;- function(points, x.cnt, y.cnt, tol = 1.0e-10){

  x.min &lt;- min(points[,1])-tol
  x.max &lt;- max(points[,1])+tol
  y.min &lt;- min(points[,2])-tol
  y.max &lt;- max(points[,2])+tol
  
  x.cnt &lt;- x.cnt+1
  y.cnt &lt;- y.cnt+1
  
  x &lt;- seq(x.min, x.max, length.out=x.cnt)
  y &lt;- seq(y.min, y.max, length.out=y.cnt)

  tile.list &lt;- vector("list", (length(y)-1)*(length(x)-1))

  l &lt;- 1
  for(i in 1:(length(y)-1)){
    for(j in 1:(length(x)-1)){
      tile.list[[l]] &lt;- rbind(c(x[j], y[i]),
                              c(x[j+1], y[i]),
                              c(x[j+1], y[i+1]),
                              c(x[j], y[i+1]))
       l &lt;- l+1
    }

  }

  tile.list
}

n &lt;- 1000
points &lt;- cbind(runif(n, 0, 10), runif(n, 0, 10))

grd &lt;- tiles(points, x.cnt=10, y.cnt=10)

plot(points, pch=19, cex=0.5, xlab="x", ylab="y")

sum.points &lt;- 0
for(i in 1:length(grd)){
  polygon(grd[[i]], border="red")
  
  point.indx &lt;- pointsInPoly(grd[[i]], points)
  
  if(!is.na(point.indx[1])){
    sum.points &lt;- length(point.indx)+sum.points
    
    text(mean(grd[[i]][,1]), mean(grd[[i]][,2]), length(point.indx), col="red")
  }
}
sum.points


## End(Not run)

</code></pre>

<hr>
<h2 id='spDiag'>Model fit diagnostics</h2><span id='topic+spDiag'></span>

<h3>Description</h3>

<p>The function <code>spDiag</code> calculates DIC, GP, GRS, and associated
statistics given a <code><a href="#topic+spLM">spLM</a></code>, <code><a href="#topic+spMvLM">spMvLM</a></code>,
<code><a href="#topic+spGLM">spGLM</a></code>, <code><a href="#topic+spMvGLM">spMvGLM</a></code>, <code><a href="#topic+spMvGLM">spMvGLM</a></code>, or
<code><a href="#topic+spSVC">spSVC</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  spDiag(sp.obj, start=1, end, thin=1, verbose=TRUE, n.report=100, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spDiag_+3A_sp.obj">sp.obj</code></td>
<td>
<p>an object returned by  <code><a href="#topic+spLM">spLM</a></code>,
<code><a href="#topic+spMvLM">spMvLM</a></code>, <code><a href="#topic+spGLM">spGLM</a></code>, <code><a href="#topic+spMvGLM">spMvGLM</a></code>. For <code><a href="#topic+spSVC">spSVC</a></code>, <code>sp.obj</code> is an object from <code><a href="#topic+spRecover">spRecover</a></code>.</p>
</td></tr>
<tr><td><code id="spDiag_+3A_start">start</code></td>
<td>
<p>specifies the first sample included in the computation. The <code>start</code>, <code>end</code>, and <code>thin</code> arguments only apply to <code><a href="#topic+spGLM">spGLM</a></code> or
<code><a href="#topic+spMvGLM">spMvGLM</a></code> objects. Sub-sampling for <code><a href="#topic+spLM">spLM</a></code> and <code><a href="#topic+spMvLM">spMvLM</a></code> is controlled using <code><a href="#topic+spRecover">spRecover</a></code> which
must be called prior to <code>spDiag</code>.</p>
</td></tr>
<tr><td><code id="spDiag_+3A_end">end</code></td>
<td>
<p>specifies the last sample included  in the computation.
The default is to use all posterior samples in <code>sp.obj</code>. See
<code>start</code> argument description.</p>
</td></tr>
<tr><td><code id="spDiag_+3A_thin">thin</code></td>
<td>
<p>a sample thinning factor.  The default of 1 considers all
samples between <code>start</code> and <code>end</code>.  For example, if <code>thin = 10</code> then 1 in 10 samples are considered between <code>start</code> and
<code>end</code>. </p>
</td></tr>
<tr><td><code id="spDiag_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> calculation progress is printed to the
screen; otherwise, nothing is printed to the screen.  </p>
</td></tr>
<tr><td><code id="spDiag_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report progress. </p>
</td></tr> 
<tr><td><code id="spDiag_+3A_...">...</code></td>
<td>
<p>currently no additional arguments.  </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with some of the following tags:
</p>
<table role = "presentation">
<tr><td><code>DIC</code></td>
<td>
<p>a matrix holding DIC and associated statistics, see
Banerjee et al. (2004) for details.</p>
</td></tr>
<tr><td><code>GP</code></td>
<td>
<p>a matrix holding GP and associated statistics, see Gelfand
and Ghosh (1998) for details. </p>
</td></tr>
<tr><td><code>GRS</code></td>
<td>
<p>a scoring rule, see Equation 27 in Gneiting and Raftery
(2007) for details.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>, <br />
Sudipto Banerjee <a href="mailto:sudipto@ucla.edu">sudipto@ucla.edu</a>
</p>


<h3>References</h3>

<p>Banerjee, S., Carlin, B.P., and Gelfand, A.E. (2004). Hierarchical
modeling and analysis for spatial data. Chapman and Hall/CRC Press,
Boca Raton,Fla.
</p>
<p>Finley, A.O. and S. Banerjee (2019) Efficient implementation of spatially-varying coefficients
models.
</p>
<p>Gelfand A.E. and Ghosh, S.K. (1998). Model choice: a minimum posterior
predictive loss approach. <em>Biometrika</em>. 85:1-11.
</p>
<p>Gneiting, T. and Raftery, A.E. (2007). Strictly proper scoring rules, prediction, and estimation.
<em>Journal of the American Statistical Association</em>. 102:359-378.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
rmvn &lt;- function(n, mu=0, V = matrix(1)){
  p &lt;- length(mu)
  if(any(is.na(match(dim(V),p))))
    stop("Dimension problem!")
  D &lt;- chol(V)
  t(matrix(rnorm(n*p), ncol=p)%*%D + rep(mu,rep(n,p)))
}

set.seed(1)

n &lt;- 100
coords &lt;- cbind(runif(n,0,1), runif(n,0,1))
X &lt;- as.matrix(cbind(1, rnorm(n)))

B &lt;- as.matrix(c(1,5))
p &lt;- length(B)

sigma.sq &lt;- 2
tau.sq &lt;- 0.1
phi &lt;- 3/0.5

D &lt;- as.matrix(dist(coords))
R &lt;- exp(-phi*D)
w &lt;- rmvn(1, rep(0,n), sigma.sq*R)
y &lt;- rnorm(n, X%*%B + w, sqrt(tau.sq))

n.samples &lt;- 1000

starting &lt;- list("phi"=3/0.5, "sigma.sq"=50, "tau.sq"=1)

tuning &lt;- list("phi"=0.1, "sigma.sq"=0.1, "tau.sq"=0.1)

##too restrictive of prior on beta
priors.1 &lt;- list("beta.Norm"=list(rep(0,p), diag(1,p)),
                 "phi.Unif"=c(3/1, 3/0.1), "sigma.sq.IG"=c(2, 2),
                 "tau.sq.IG"=c(2, 0.1))

##more reasonable prior for beta
priors.2 &lt;- list("beta.Norm"=list(rep(0,p), diag(1000,p)),
                 "phi.Unif"=c(3/1, 3/0.1), "sigma.sq.IG"=c(2, 2),
                 "tau.sq.IG"=c(2, 0.1))

cov.model &lt;- "exponential"

n.report &lt;- 500
verbose &lt;- TRUE

m.1 &lt;- spLM(y~X-1, coords=coords, starting=starting,
            tuning=tuning, priors=priors.1, cov.model=cov.model,
            n.samples=n.samples, verbose=verbose, n.report=n.report)

m.2 &lt;- spLM(y~X-1, coords=coords, starting=starting,
            tuning=tuning, priors=priors.2, cov.model=cov.model,
            n.samples=n.samples, verbose=verbose, n.report=n.report)

##non-spatial model
m.3 &lt;- spLM(y~X-1, n.samples=n.samples, verbose=verbose, n.report=n.report)

burn.in &lt;- 0.5*n.samples

##recover beta and spatial random effects
m.1 &lt;- spRecover(m.1, start=burn.in, verbose=FALSE)
m.2 &lt;- spRecover(m.2, start=burn.in, verbose=FALSE)

##lower is better for DIC, GPD, and GRS
print(spDiag(m.1))
print(spDiag(m.2))
print(spDiag(m.3))

## End(Not run)
</code></pre>

<hr>
<h2 id='spDynLM'>Function for fitting univariate Bayesian dynamic space-time regression models</h2><span id='topic+spDynLM'></span>

<h3>Description</h3>

<p>The function <code>spDynLM</code> fits Gaussian univariate Bayesian
dynamic space-time regression models for settings where space is viewed as continuous but time is taken
to be discrete.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spDynLM(formula, data = parent.frame(), coords, knots,
      starting, tuning, priors, cov.model, get.fitted=FALSE, 
      n.samples, verbose=TRUE, n.report=100, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spDynLM_+3A_formula">formula</code></td>
<td>
<p>a list of <code class="reqn">N_t</code> symbolic regression models to be fit. Each model represents a time step. See example below. </p>
</td></tr>
<tr><td><code id="spDynLM_+3A_data">data</code></td>
<td>
<p>an optional data frame containing the variables in the
model. If not found in data, the variables are taken from
<code>environment(formula)</code>, typically the environment from which <code>spDynLM</code> is called.  </p>
</td></tr>
<tr><td><code id="spDynLM_+3A_coords">coords</code></td>
<td>
<p>an <code class="reqn">n \times 2</code> matrix of the observation coordinates
in <code class="reqn">R^2</code> (e.g., easting and northing). </p>
</td></tr>
<tr><td><code id="spDynLM_+3A_starting">starting</code></td>
<td>
<p>a list with each tag corresponding to a
parameter name. Valid tags are <code>beta</code>, <code>sigma.sq</code>,
<code>tau.sq</code>, <code>phi</code>, <code>nu</code>, and <code>sigma.eta</code>.  The value portion of each tag is the parameter's starting value. </p>
</td></tr>
<tr><td><code id="spDynLM_+3A_knots">knots</code></td>
<td>
<p>either a <code class="reqn">m \times 2</code> matrix of the
<em>predictive process</em> knot coordinates in <code class="reqn">R^2</code> (e.g., easting and northing)
or a vector of length two or three with the first and second elements recording the
number of columns and rows in the desired knot grid. The third,
optional, element sets the offset of the outermost knots from the
extent of the <code>coords</code>. </p>
</td></tr> 
<tr><td><code id="spDynLM_+3A_tuning">tuning</code></td>
<td>
<p>a list with each tag corresponding to a
parameter name. Valid tags are <code>phi</code> and <code>nu</code>. The value portion of each tag defines the variance of the Metropolis sampler Normal proposal distribution.</p>
</td></tr>
<tr><td><code id="spDynLM_+3A_priors">priors</code></td>
<td>
<p>a list with tags <code>beta.0.norm</code>, <code>sigma.sq.ig</code>,
<code>tau.sq.ig</code>, <code>phi.unif</code>, <code>nu.unif</code>, and <code>sigma.eta.iw</code>. Variance parameters, <code>simga.sq</code> and
<code>tau.sq</code>, are assumed to follow an
inverse-Gamma distribution, whereas the spatial decay <code>phi</code>
and smoothness <code>nu</code> parameters are assumed to follow Uniform
distributions. The <code>beta.0.norm</code> is a multivariate Normal distribution with
hyperparameters passed as a list of length two with the first
and second elements corresponding to the mean vector and positive
definite covariance matrix, respectively. The hyperparameters of the inverse-Wishart, <code>sigma.eta.iw</code>,  are
passed as a list of length two, with the first and second elements corresponding
to the <code class="reqn">df</code> and <code class="reqn">p\times p</code> <em>scale</em> matrix,
respectively. The inverse-Gamma hyperparameters are passed in a list with two vectors that hold the <em>shape</em> and <em>scale</em>, respectively. The Uniform hyperparameters are passed in a list with two vectors that hold the lower and upper support values, respectively.</p>
</td></tr>
<tr><td><code id="spDynLM_+3A_cov.model">cov.model</code></td>
<td>
<p>a quoted keyword that specifies the covariance
function used to model the spatial dependence structure among the
observations.  Supported covariance model key words are:
<code>"exponential"</code>, <code>"matern"</code>, <code>"spherical"</code>, and
<code>"gaussian"</code>.  See below for details.  </p>
</td></tr>
<tr><td><code id="spDynLM_+3A_get.fitted">get.fitted</code></td>
<td>
<p>if <code>TRUE</code>, posterior predicted and fitted
values are collected. Note, posterior predicted samples are only
collected for those <code class="reqn">y_t(s)</code> that are <code>NA</code>.</p>
</td></tr>
<tr><td><code id="spDynLM_+3A_n.samples">n.samples</code></td>
<td>
<p>the number of MCMC iterations.</p>
</td></tr>
<tr><td><code id="spDynLM_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, model specification and progress of the
sampler is printed to the screen. Otherwise, nothing is printed to
the screen.  </p>
</td></tr>
<tr><td><code id="spDynLM_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report Metropolis sampler acceptance and MCMC progress. </p>
</td></tr>  
<tr><td><code id="spDynLM_+3A_...">...</code></td>
<td>
<p>currently no additional arguments.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suppose, <code class="reqn">y_t(s)</code> denotes the observation at location <code class="reqn">s</code> and time
<code class="reqn">t</code>. We model <code class="reqn">y_t(s)</code> through a <em>measurement equation</em> that
provides a regression specification with a space-time varying
intercept and  serially and spatially
uncorrelated zero-centered Gaussian disturbances as measurement error
<code class="reqn">\epsilon_t(s)</code>. Next a <em>transition equation</em>
introduces a <code class="reqn">p\times 1</code> coefficient vector, say <code class="reqn">\beta_t</code>, which is a purely
temporal component (i.e., time-varying regression parameters), and a
spatio-temporal component <code class="reqn">u_t(s)</code>. Both these are generated through
transition equations, capturing their Markovian dependence in
time. While the transition equation of the purely temporal component
is akin to usual state-space modeling, the spatio-temporal component is
generated using Gaussian spatial processes. The overall model is written
as
</p>
<p style="text-align: center;"><code class="reqn">y_t(s)  = x_t(s)'\beta_t + u_t(s) + \epsilon_t(s), t=1,2,\ldots,N_t</code>
</p>

<p style="text-align: center;"><code class="reqn">\epsilon_t(s) \sim N(0,\tau_{t}^2)</code>
</p>

<p style="text-align: center;"><code class="reqn">\beta_t  = \beta_{t-1} + \eta_t; \eta_t \sim
  N(0,\Sigma_{\eta})</code>
</p>

<p style="text-align: center;"><code class="reqn">u_t(s) = u_{t-1}(s) + w_t(s); w_t(s) \sim GP(0, C_t(\cdot,\theta_t))</code>
</p>

<p>Here <code class="reqn">x_t(s)</code> is a <code class="reqn">p\times 1</code> vector of predictors
and <code class="reqn">\beta_t</code> is a <code class="reqn">p\times 1</code> vector of
coefficients. In addition to an intercept, <code class="reqn">x_t(s)</code> can
include location specific variables useful for explaining the
variability in <code class="reqn">y_t(s)</code>. The <code class="reqn">GP(0,
  C_t(\cdot,\theta_t))</code> denotes a spatial
Gaussian process with covariance function
<code class="reqn">C_{t}(\cdot;\theta_t)</code>. We specify
<code class="reqn">C_{t}(s_1,s_2;\theta_t)=\sigma_t^2\rho(s_1,s_2;\phi_t)</code>, where <code class="reqn">\theta_t = \{\sigma_t^2,\phi_t,\nu_t\}</code> and <code class="reqn">\rho(\cdot;\phi)</code> is a
<em>correlation function</em> with <code class="reqn">\phi</code> controlling the
correlation decay and <code class="reqn">\sigma_t^2</code> represents the
spatial variance component. The spatial smoothness parameter,
<code class="reqn">\nu</code>, is used if the Matern spatial correlation function is chosen. We further assume <code class="reqn">\beta_0 \sim N(m_0, \Sigma_0)</code> and <code class="reqn">u_0(s) \equiv 0</code>, which completes the prior specifications leading to a well-identified Bayesian hierarhical model and also yield reasonable dependence structures. 
</p>


<h3>Value</h3>

<p>An object of class <code>spDynLM</code>, which is a list with the following
tags:
</p>
<table role = "presentation">
<tr><td><code>coords</code></td>
<td>
<p>the <code class="reqn">n \times 2</code> matrix specified by
<code>coords</code>.  </p>
</td></tr>
<tr><td><code>p.theta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples for
<code class="reqn">\tau^2_t</code>, <code class="reqn">\sigma^2_t</code>, <code class="reqn">\phi_t</code>, <code class="reqn">\nu_t</code>. </p>
</td></tr>
<tr><td><code>p.beta.0.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples for
<code class="reqn">\beta</code> at <code class="reqn">t=0</code>.</p>
</td></tr>
<tr><td><code>p.beta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples for
<code class="reqn">\beta_t</code>.</p>
</td></tr>
<tr><td><code>p.sigma.eta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples for
<code class="reqn">\Sigma_\eta</code>.</p>
</td></tr>
<tr><td><code>p.u.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples for
spatio-temporal random effects <code class="reqn">u</code>. Samples are over the
columns and time steps increase in blocks of <code class="reqn">n</code> down the
columns, e.g., the first <code class="reqn">n</code> rows correspond to locations
<code class="reqn">1,2, \ldots, n</code> in <code class="reqn">t=1</code> and the last <code class="reqn">n</code> rows correspond to locations
<code class="reqn">1,2, \ldots, n</code> in <code class="reqn">t=N_t</code>.</p>
</td></tr>
<tr><td><code>p.y.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples for
<code class="reqn">y</code>. If <code class="reqn">y_t(s)</code> is specified as <code>NA</code> the
<code>p.y.samples</code> hold the associated posterior predictive
samples. Samples are over the
columns and time steps increase in blocks of <code class="reqn">n</code> down the
columns, e.g., the first <code class="reqn">n</code> rows correspond to locations
<code class="reqn">1,2, \ldots, n</code> in <code class="reqn">t=1</code> and the last <code class="reqn">n</code> rows correspond to locations
<code class="reqn">1,2, \ldots, n</code> in <code class="reqn">t=N_t</code>.</p>
</td></tr> 	
</table>
<p>The return object might include additional data used for subsequent
prediction and/or model fit evaluation.
</p>


<h3>Author(s)</h3>

<p>Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>, <br />
Sudipto Banerjee <a href="mailto:baner009@umn.edu">baner009@umn.edu</a>
</p>


<h3>References</h3>

<p>Finley, A.O., S. Banerjee, and A.E. Gelfand. (2012) Bayesian dynamic modeling for large space-time datasets using Gaussian predictive processes. <em>Journal of Geographical Systems</em>, 14:29&ndash;47.
</p>
<p>Finley, A.O., S. Banerjee, and A.E. Gelfand. (2015) spBayes for large
univariate and multivariate point-referenced spatio-temporal data
models. <em>Journal of Statistical Software</em>, 63:1&ndash;28. <a href="https://www.jstatsoft.org/article/view/v063i13">https://www.jstatsoft.org/article/view/v063i13</a>.
</p>
<p>Gelfand, A.E., S. Banerjee, and D. Gamerman (2005) Spatial Process
Modelling for Univariate and Multivariate Dynamic Spatial Data,
<em>Environmetrics</em>, 16:465&ndash;479. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spLM">spLM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("NETemp.dat")
ne.temp &lt;- NETemp.dat

set.seed(1)

##take a chunk of New England
ne.temp &lt;- ne.temp[ne.temp[,"UTMX"] &gt; 5500000 &amp; ne.temp[,"UTMY"] &gt; 3000000,]

##subset first 2 years (Jan 2000 - Dec. 2002)
y.t &lt;- ne.temp[,4:27]
N.t &lt;- ncol(y.t) ##number of months
n &lt;- nrow(y.t) ##number of observation per months

##add some missing observations to illistrate prediction
miss &lt;- sample(1:N.t, 10)
holdout.station.id &lt;- 5
y.t.holdout &lt;- y.t[holdout.station.id, miss]
y.t[holdout.station.id, miss] &lt;- NA

##scale to km
coords &lt;- as.matrix(ne.temp[,c("UTMX", "UTMY")]/1000)
max.d &lt;- max(iDist(coords))

##set starting and priors
p &lt;- 2 #number of regression parameters in each month

starting &lt;- list("beta"=rep(0,N.t*p), "phi"=rep(3/(0.5*max.d), N.t),
                 "sigma.sq"=rep(2,N.t), "tau.sq"=rep(1, N.t),
                 "sigma.eta"=diag(rep(0.01, p)))

tuning &lt;- list("phi"=rep(5, N.t)) 

priors &lt;- list("beta.0.Norm"=list(rep(0,p), diag(1000,p)),
               "phi.Unif"=list(rep(3/(0.9*max.d), N.t), rep(3/(0.05*max.d), N.t)),
               "sigma.sq.IG"=list(rep(2,N.t), rep(10,N.t)),
               "tau.sq.IG"=list(rep(2,N.t), rep(5,N.t)),
               "sigma.eta.IW"=list(2, diag(0.001,p)))

##make symbolic model formula statement for each month
mods &lt;- lapply(paste(colnames(y.t),'elev',sep='~'), as.formula)

n.samples &lt;- 2000

m.1 &lt;- spDynLM(mods, data=cbind(y.t,ne.temp[,"elev",drop=FALSE]), coords=coords,
               starting=starting, tuning=tuning, priors=priors, get.fitted =TRUE,
               cov.model="exponential", n.samples=n.samples, n.report=25) 

burn.in &lt;- floor(0.75*n.samples)

quant &lt;- function(x){quantile(x, prob=c(0.5, 0.025, 0.975))}

beta &lt;- apply(m.1$p.beta.samples[burn.in:n.samples,], 2, quant)
beta.0 &lt;- beta[,grep("Intercept", colnames(beta))]
beta.1 &lt;- beta[,grep("elev", colnames(beta))]

plot(m.1$p.beta.0.samples)

par(mfrow=c(2,1))
plot(1:N.t, beta.0[1,], pch=19, cex=0.5, xlab="months", ylab="beta.0", ylim=range(beta.0))
arrows(1:N.t, beta.0[1,], 1:N.t, beta.0[3,], length=0.02, angle=90)
arrows(1:N.t, beta.0[1,], 1:N.t, beta.0[2,], length=0.02, angle=90)

plot(1:N.t, beta.1[1,], pch=19, cex=0.5, xlab="months", ylab="beta.1", ylim=range(beta.1))
arrows(1:N.t, beta.1[1,], 1:N.t, beta.1[3,], length=0.02, angle=90)
arrows(1:N.t, beta.1[1,], 1:N.t, beta.1[2,], length=0.02, angle=90)

theta &lt;- apply(m.1$p.theta.samples[burn.in:n.samples,], 2, quant)
sigma.sq &lt;- theta[,grep("sigma.sq", colnames(theta))]
tau.sq &lt;- theta[,grep("tau.sq", colnames(theta))]
phi &lt;- theta[,grep("phi", colnames(theta))]

par(mfrow=c(3,1))
plot(1:N.t, sigma.sq[1,], pch=19, cex=0.5, xlab="months", ylab="sigma.sq", ylim=range(sigma.sq))
arrows(1:N.t, sigma.sq[1,], 1:N.t, sigma.sq[3,], length=0.02, angle=90)
arrows(1:N.t, sigma.sq[1,], 1:N.t, sigma.sq[2,], length=0.02, angle=90)

plot(1:N.t, tau.sq[1,], pch=19, cex=0.5, xlab="months", ylab="tau.sq", ylim=range(tau.sq))
arrows(1:N.t, tau.sq[1,], 1:N.t, tau.sq[3,], length=0.02, angle=90)
arrows(1:N.t, tau.sq[1,], 1:N.t, tau.sq[2,], length=0.02, angle=90)

plot(1:N.t, 3/phi[1,], pch=19, cex=0.5, xlab="months", ylab="eff. range (km)", ylim=range(3/phi))
arrows(1:N.t, 3/phi[1,], 1:N.t, 3/phi[3,], length=0.02, angle=90)
arrows(1:N.t, 3/phi[1,], 1:N.t, 3/phi[2,], length=0.02, angle=90)

y.hat &lt;- apply(m.1$p.y.samples[,burn.in:n.samples], 1, quant)
y.hat.med &lt;- matrix(y.hat[1,], ncol=N.t)
y.hat.up &lt;- matrix(y.hat[3,], ncol=N.t)
y.hat.low &lt;- matrix(y.hat[2,], ncol=N.t)

y.obs &lt;- as.vector(as.matrix(y.t[-holdout.station.id, -miss]))
y.obs.hat.med &lt;- as.vector(y.hat.med[-holdout.station.id, -miss])
y.obs.hat.up &lt;- as.vector(y.hat.up[-holdout.station.id, -miss])
y.obs.hat.low &lt;- as.vector(y.hat.low[-holdout.station.id, -miss])

y.ho &lt;- as.matrix(y.t.holdout)
y.ho.hat.med &lt;- as.vector(y.hat.med[holdout.station.id, miss])
y.ho.hat.up &lt;- as.vector(y.hat.up[holdout.station.id, miss])
y.ho.hat.low &lt;- as.vector(y.hat.low[holdout.station.id, miss])

par(mfrow=c(2,1))
plot(y.obs, y.obs.hat.med, pch=19, cex=0.5, xlab="observed",
ylab="fitted", main="Observed vs. fitted")
arrows(y.obs, y.obs.hat.med, y.obs, y.obs.hat.up, length=0.02, angle=90)
arrows(y.obs, y.obs.hat.med, y.obs, y.obs.hat.low, length=0.02, angle=90)
lines(-50:50, -50:50, col="blue")

plot(y.ho, y.ho.hat.med, pch=19, cex=0.5, xlab="observed",
ylab="predicted", main="Observed vs. predicted")
arrows(y.ho, y.ho.hat.med, y.ho, y.ho.hat.up, length=0.02, angle=90)
arrows(y.ho, y.ho.hat.med, y.ho, y.ho.hat.low, length=0.02, angle=90)
lines(-50:50, -50:50, col="blue")

## End(Not run)
</code></pre>

<hr>
<h2 id='spGLM'>Function for fitting univariate Bayesian generalized linear spatial regression models</h2><span id='topic+spGLM'></span>

<h3>Description</h3>

<p>The function <code>spGLM</code> fits univariate Bayesian
generalized linear spatial regression models. Given a set of knots,
<code>spGLM</code> will also fit a <em>predictive process</em> model (see references below).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spGLM(formula, family="binomial", weights, data = parent.frame(),
      coords, knots, starting, tuning, priors, cov.model,
      amcmc, n.samples, verbose=TRUE,
      n.report=100, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spGLM_+3A_formula">formula</code></td>
<td>
<p>a symbolic description of the regression model to be
fit. See example below. </p>
</td></tr>
<tr><td><code id="spGLM_+3A_family">family</code></td>
<td>
<p>currently only supports <code>binomial</code> and
<code>poisson</code> data using the logit and log link functions,
respectively.</p>
</td></tr>
<tr><td><code id="spGLM_+3A_weights">weights</code></td>
<td>
<p>an optional vector of weights to be used in the fitting
process. Weights correspond to number of trials and <em>offset</em> for
each location for the <code>binomial</code> and <code>poisson</code> family,
respectively. </p>
</td></tr>
<tr><td><code id="spGLM_+3A_data">data</code></td>
<td>
<p>an optional data frame containing the variables in the
model. If not found in <code>data</code>, the variables are taken from
<code>environment(formula)</code>, typically the environment from which <code>spGLM</code> is called.  </p>
</td></tr>
<tr><td><code id="spGLM_+3A_coords">coords</code></td>
<td>
<p>an <code class="reqn">n \times 2</code> matrix of the observation coordinates
in <code class="reqn">R^2</code> (e.g., easting and northing). </p>
</td></tr>
<tr><td><code id="spGLM_+3A_knots">knots</code></td>
<td>
<p>either a <code class="reqn">m \times 2</code> matrix of the
<em>predictive process</em> knot coordinates in <code class="reqn">R^2</code> (e.g., easting and northing)
or a vector of length two or three with the first and second elements recording the
number of columns and rows in the desired knot grid. The third,
optional, element sets the offset of the outermost knots from the
extent of the <code>coords</code>. </p>
</td></tr>
<tr><td><code id="spGLM_+3A_starting">starting</code></td>
<td>
<p>a list with each tag corresponding to a
parameter name. Valid tags are <code>beta</code>, <code>sigma.sq</code>,
<code>phi</code>, <code>nu</code>, and <code>w</code>.  The value portion of each tag is the parameter's starting value. If the predictive
process is used then <code>w</code> must be of length <code class="reqn">m</code>; otherwise,
it must be of length <code class="reqn">n</code>. Alternatively, <code>w</code> can be set
as a scalar, in which case the value is repeated.</p>
</td></tr>
<tr><td><code id="spGLM_+3A_tuning">tuning</code></td>
<td>
<p>a list with each tag corresponding to a
parameter name. Valid tags are <code>beta</code>, <code>sigma.sq</code>,
<code>phi</code>, <code>nu</code>, and <code>w</code>. The value portion of each tag
defines the variance of the Metropolis sampler Normal proposal
distribution. 
</p>
<p>The tuning value for <code>beta</code> can be a
vector of length <code class="reqn">p</code> (where <code class="reqn">p</code> is the number of
regression coefficients) or, if an adaptive MCMC is not used,
i.e., <code>amcmc</code> is not specified, the lower-triangle of the
<code class="reqn">p\times p</code> Cholesky square-root of the desired proposal
covariance matrix. If the <em>predictive process</em> is used then <code>w</code> must be of length <code class="reqn">m</code>; otherwise,
it must be of length <code class="reqn">n</code>. Alternatively, <code>w</code> can be set
as a scalar, in which case the value is repeated.  </p>
</td></tr>
<tr><td><code id="spGLM_+3A_priors">priors</code></td>
<td>
<p>a list with each tag corresponding to a
parameter name. Valid tags are <code>sigma.sq.ig</code>,
<code>phi.unif</code>, <code>nu.unif</code>,
<code>beta.norm</code>,  and <code>beta.flat</code>. Variance parameter
<code>simga.sq</code> is assumed to follow an
inverse-Gamma distribution, whereas the spatial decay <code>phi</code>
and smoothness <code>nu</code> parameters are assumed to follow Uniform distributions. The
hyperparameters of the inverse-Gamma are
passed as a vector of length two, with the first and second elements corresponding
to the <em>shape</em> and <em>scale</em>, respectively. The hyperparameters
of the Uniform are also passed as a vector of length two with the first
and second elements corresponding to the lower and upper support,
respectively. If the regression coefficients are each assumed to follow a Normal distribution, i.e., <code>beta.norm</code>, then mean and variance hyperparameters are passed as the first and second list elements, respectively. If
<code>beta</code> is assumed flat then no arguments are passed. The default
is a flat prior.
</p>
</td></tr>  
<tr><td><code id="spGLM_+3A_cov.model">cov.model</code></td>
<td>
<p>a quoted keyword that specifies the covariance
function used to model the spatial dependence structure among the
observations.  Supported covariance model key words are:
<code>"exponential"</code>, <code>"matern"</code>, <code>"spherical"</code>, and
<code>"gaussian"</code>.  See below for details.  </p>
</td></tr>
<tr><td><code id="spGLM_+3A_amcmc">amcmc</code></td>
<td>
<p>a list with tags <code>n.batch</code>, <code>batch.length</code>, and
<code>accept.rate</code>. Specifying this argument invokes an adaptive MCMC
sampler, see Roberts and Rosenthal (2007) for an explanation.</p>
</td></tr>
<tr><td><code id="spGLM_+3A_n.samples">n.samples</code></td>
<td>
<p>the number of MCMC iterations. This argument is
ignored if <code>amcmc</code> is specified.</p>
</td></tr>
<tr><td><code id="spGLM_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, model specification and progress of the
sampler is printed to the screen. Otherwise, nothing is printed to
the screen.  </p>
</td></tr>
<tr><td><code id="spGLM_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report Metropolis sampler acceptance and MCMC progress. </p>
</td></tr>  
<tr><td><code id="spGLM_+3A_...">...</code></td>
<td>
<p>currently no additional arguments.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a <code>binomial</code> model is specified the response vector is the
number of successful trials at each location and <code>weights</code> is the
total number of trials at each location.
</p>
<p>For a <code>poisson</code> specification, the <code>weights</code> vector is the
count offset, e.g., population, at each location. This differs from
the <code><a href="stats.html#topic+glm">glm</a></code> <code>offset</code> argument which is passed as the
log of this value.  
</p>
<p>A non-spatial model is fit when <code>coords</code> is not specified. See
example below.
</p>


<h3>Value</h3>

<p>An object of class <code>spGLM</code>, which is a list with the following
tags:
</p>
<table role = "presentation">
<tr><td><code>coords</code></td>
<td>
<p>the <code class="reqn">n \times 2</code> matrix specified by
<code>coords</code>.  </p>
</td></tr>
<tr><td><code>knot.coords</code></td>
<td>
<p>the <code class="reqn">m \times 2</code> matrix as specified by <code>knots</code>.  </p>
</td></tr>
<tr><td><code>p.beta.theta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples for the defined
parameters. </p>
</td></tr>
<tr><td><code>acceptance</code></td>
<td>
<p>the Metropolis sampler
acceptance rate. If <code>amcmc</code> is used then this will be a matrix of
each parameter's acceptance rate at the end of each
batch. Otherwise, the sampler is a Metropolis with a joint proposal
of all parameters.</p>
</td></tr>
<tr><td><code>acceptance.w</code></td>
<td>
<p>if this is a non-predictive process model and
<code>amcmc</code> is used then this will be a matrix of the Metropolis sampler acceptance rate for each location's spatial random effect. </p>
</td></tr>
<tr><td><code>acceptance.w.knots</code></td>
<td>
<p>if this is a <em>predictive process</em> model and <code>amcmc</code> is used then this will be a matrix of
the Metropolis sampler acceptance rate for each knot's spatial random effect. </p>
</td></tr>
<tr><td><code>p.w.knots.samples</code></td>
<td>
<p>a matrix that holds samples from the posterior
distribution of the knots' spatial random effects. The rows of this matrix
correspond to the <code class="reqn">m</code> knot locations and the columns are the
posterior samples. This is only returned if a <em>predictive process</em> model
is used.</p>
</td></tr>
<tr><td><code>p.w.samples</code></td>
<td>
<p>a matrix that holds samples from the posterior
distribution of the locations' spatial random effects. The rows of this matrix
correspond to the <code class="reqn">n</code> point observations and the columns are the
posterior samples. </p>
</td></tr>
</table>
<p>The return object might include additional data used for subsequent
prediction and/or model fit evaluation.
</p>


<h3>Author(s)</h3>

<p>Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>, <br />
Sudipto Banerjee <a href="mailto:baner009@umn.edu">baner009@umn.edu</a>
</p>


<h3>References</h3>

<p>Banerjee, S., A.E. Gelfand, A.O. Finley, and H. Sang. (2008) Gaussian Predictive Process Models for Large Spatial Datasets. <em>Journal of the Royal Statistical Society Series B</em>, 70:825&ndash;848.
</p>
<p>Banerjee, S., Carlin, B.P., and Gelfand, A.E. (2004) Hierarchical modeling and analysis for spatial data. Chapman and Hall/CRC Press, Boca Raton, Fla.
</p>
<p>Finley, A.O., S. Banerjee, and A.E. Gelfand. (2015) spBayes for large
univariate and multivariate point-referenced spatio-temporal data
models. <em>Journal of Statistical Software</em>, 63:1&ndash;28. <a href="https://www.jstatsoft.org/article/view/v063i13">https://www.jstatsoft.org/article/view/v063i13</a>.
</p>
<p>Finley, A.O., S. Banerjee, and R.E. McRoberts. (2008) A Bayesian approach to quantifying uncertainty in multi-source forest area estimates. <em>Environmental and Ecological Statistics</em>, 15:241&ndash;258.
</p>
<p>Roberts G.O. and Rosenthal J.S. (2006) Examples of Adaptive MCMC. <a href="http://probability.ca/jeff/ftpdir/adaptex.pdf">http://probability.ca/jeff/ftpdir/adaptex.pdf</a> Preprint.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spMvGLM">spMvGLM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(MBA)
library(coda)

set.seed(1)

rmvn &lt;- function(n, mu=0, V = matrix(1)){
  p &lt;- length(mu)
  if(any(is.na(match(dim(V),p))))
    stop("Dimension problem!")
  D &lt;- chol(V)
  t(matrix(rnorm(n*p), ncol=p) %*% D + rep(mu,rep(n,p)))
}

################################
##Spatial binomial
################################

##Generate binary data
coords &lt;- as.matrix(expand.grid(seq(0,100,length.out=8), seq(0,100,length.out=8)))
n &lt;- nrow(coords)

phi &lt;- 3/50
sigma.sq &lt;- 2

R &lt;- sigma.sq*exp(-phi*as.matrix(dist(coords)))
w &lt;- rmvn(1, rep(0,n), R)

x &lt;- as.matrix(rep(1,n))
beta &lt;- 0.1
p &lt;- 1/(1+exp(-(x%*%beta+w)))

weights &lt;- rep(1, n)
weights[coords[,1]&gt;mean(coords[,1])] &lt;- 10

y &lt;- rbinom(n, size=weights, prob=p)

##Collect samples
fit &lt;- glm((y/weights)~x-1, weights=weights, family="binomial")
beta.starting &lt;- coefficients(fit)
beta.tuning &lt;- t(chol(vcov(fit)))

n.batch &lt;- 200
batch.length &lt;- 50
n.samples &lt;- n.batch*batch.length

m.1 &lt;- spGLM(y~1, family="binomial", coords=coords, weights=weights, 
             starting=list("beta"=beta.starting, "phi"=0.06,"sigma.sq"=1, "w"=0),
             tuning=list("beta"=beta.tuning, "phi"=0.5, "sigma.sq"=0.5, "w"=0.5),
             priors=list("beta.Normal"=list(0,10), "phi.Unif"=c(0.03, 0.3), "sigma.sq.IG"=c(2, 1)),
             amcmc=list("n.batch"=n.batch, "batch.length"=batch.length, "accept.rate"=0.43),
             cov.model="exponential", verbose=TRUE, n.report=10)

burn.in &lt;- 0.9*n.samples
sub.samps &lt;- burn.in:n.samples

print(summary(window(m.1$p.beta.theta.samples, start=burn.in)))

beta.hat &lt;- m.1$p.beta.theta.samples[sub.samps,"(Intercept)"]
w.hat &lt;- m.1$p.w.samples[,sub.samps]

p.hat &lt;- 1/(1+exp(-(x%*%beta.hat+w.hat)))

y.hat &lt;- apply(p.hat, 2, function(x){rbinom(n, size=weights, prob=p.hat)})

y.hat.mu &lt;- apply(y.hat, 1, mean)
y.hat.var &lt;- apply(y.hat, 1, var)

##Take a look
par(mfrow=c(1,2))
surf &lt;- mba.surf(cbind(coords,y.hat.mu),no.X=100, no.Y=100, extend=TRUE)$xyz.est
image(surf, main="Interpolated mean of posterior rate\n(observed rate)")
contour(surf, add=TRUE)
text(coords, label=paste("(",y,")",sep=""))

surf &lt;- mba.surf(cbind(coords,y.hat.var),no.X=100, no.Y=100, extend=TRUE)$xyz.est
image(surf, main="Interpolated variance of posterior rate\n(observed #
of trials)")
contour(surf, add=TRUE)
text(coords, label=paste("(",weights,")",sep=""))

###########################
##Spatial poisson
###########################
##Generate count data
set.seed(1)

n &lt;- 100

coords &lt;- cbind(runif(n,1,100),runif(n,1,100))

phi &lt;- 3/50
sigma.sq &lt;- 2

R &lt;- sigma.sq*exp(-phi*as.matrix(dist(coords)))
w &lt;- rmvn(1, rep(0,n), R)

x &lt;- as.matrix(rep(1,n))
beta &lt;- 0.1
y &lt;- rpois(n, exp(x%*%beta+w))

##Collect samples
beta.starting &lt;- coefficients(glm(y~x-1, family="poisson"))
beta.tuning &lt;- t(chol(vcov(glm(y~x-1, family="poisson"))))

n.batch &lt;- 500
batch.length &lt;- 50
n.samples &lt;- n.batch*batch.length

##Note tuning list is now optional

m.1 &lt;- spGLM(y~1, family="poisson", coords=coords,
             starting=list("beta"=beta.starting, "phi"=0.06,"sigma.sq"=1, "w"=0),
             tuning=list("beta"=0.1, "phi"=0.5, "sigma.sq"=0.5, "w"=0.5),
             priors=list("beta.Flat", "phi.Unif"=c(0.03, 0.3), "sigma.sq.IG"=c(2, 1)),
             amcmc=list("n.batch"=n.batch, "batch.length"=batch.length, "accept.rate"=0.43),
             cov.model="exponential", verbose=TRUE, n.report=10)

##Just for fun check out the progression of the acceptance
##as it moves to 43% (same can be seen for the random spatial effects).
plot(mcmc(t(m.1$acceptance)), density=FALSE, smooth=FALSE)

##Now parameter summaries, etc.
burn.in &lt;- 0.9*n.samples
sub.samps &lt;- burn.in:n.samples

m.1$p.samples[,"phi"] &lt;- 3/m.1$p.samples[,"phi"]

plot(m.1$p.beta.theta.samples)
print(summary(window(m.1$p.beta.theta.samples, start=burn.in)))

beta.hat &lt;- m.1$p.beta.theta.samples[sub.samps,"(Intercept)"]
w.hat &lt;- m.1$p.w.samples[,sub.samps]

y.hat &lt;- apply(exp(x%*%beta.hat+w.hat), 2, function(x){rpois(n, x)})

y.hat.mu &lt;- apply(y.hat, 1, mean)

##Take a look
par(mfrow=c(1,2))
surf &lt;- mba.surf(cbind(coords,y),no.X=100, no.Y=100, extend=TRUE)$xyz.est
image(surf, main="Observed counts")
contour(surf, add=TRUE)
text(coords, labels=y, cex=1)

surf &lt;- mba.surf(cbind(coords,y.hat.mu),no.X=100, no.Y=100, extend=TRUE)$xyz.est
image(surf, main="Fitted counts")
contour(surf, add=TRUE)
text(coords, labels=round(y.hat.mu,0), cex=1)

## End(Not run)
</code></pre>

<hr>
<h2 id='spLM'>Function for fitting univariate Bayesian spatial regression models</h2><span id='topic+spLM'></span>

<h3>Description</h3>

<p>The function <code>spLM</code> fits Gaussian univariate Bayesian
spatial regression models. Given a set of knots, <code>spLM</code> will also
fit a <em>predictive process</em> model (see references below).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spLM(formula, data = parent.frame(), coords, knots,
      starting, tuning, priors, cov.model,
      modified.pp = TRUE, amcmc, n.samples, 
      verbose=TRUE, n.report=100, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spLM_+3A_formula">formula</code></td>
<td>
<p>a symbolic description of the regression model to be
fit. See example below. </p>
</td></tr>
<tr><td><code id="spLM_+3A_data">data</code></td>
<td>
<p>an optional data frame containing the variables in the
model. If not found in <code>data</code>, the variables are taken from
<code>environment(formula)</code>, typically the environment from which <code>spLM</code> is called.  </p>
</td></tr>
<tr><td><code id="spLM_+3A_coords">coords</code></td>
<td>
<p>an <code class="reqn">n \times 2</code> matrix of the observation coordinates
in <code class="reqn">R^2</code> (e.g., easting and northing). </p>
</td></tr>
<tr><td><code id="spLM_+3A_knots">knots</code></td>
<td>
<p>either a <code class="reqn">m \times 2</code> matrix of the
<em>predictive process</em> knot coordinates in <code class="reqn">R^2</code> (e.g., easting and northing)
or a vector of length two or three with the first and second elements recording the
number of columns and rows in the desired knot grid. The third,
optional, element sets the offset of the outermost knots from the
extent of the <code>coords</code>. </p>
</td></tr> 
<tr><td><code id="spLM_+3A_starting">starting</code></td>
<td>
<p>a list with each tag corresponding to a
parameter name. Valid tags are <code>beta</code>, <code>sigma.sq</code>,
<code>tau.sq</code>, <code>phi</code>, and <code>nu</code>.  The value portion of each tag is the parameter's starting value. </p>
</td></tr>
<tr><td><code id="spLM_+3A_tuning">tuning</code></td>
<td>
<p>a list with each tag corresponding to a
parameter name. Valid tags are <code>sigma.sq</code>,
<code>tau.sq</code>, <code>phi</code>, and <code>nu</code>. The value portion of each tag defines the variance of the Metropolis sampler Normal proposal distribution.</p>
</td></tr>
<tr><td><code id="spLM_+3A_priors">priors</code></td>
<td>
<p>a list with each tag corresponding to a
parameter name. Valid tags are <code>sigma.sq.ig</code>,
<code>tau.sq.ig</code>, <code>phi.unif</code>, <code>nu.unif</code>,
<code>beta.norm</code>, and <code>beta.flat</code>. Variance parameters, <code>simga.sq</code> and
<code>tau.sq</code>, are assumed to follow an
inverse-Gamma distribution, whereas the spatial decay <code>phi</code>
and smoothness <code>nu</code> parameters are assumed to follow Uniform distributions. The
hyperparameters of the inverse-Gamma are
passed as a vector of length two, with the first and second elements corresponding
to the <em>shape</em> and <em>scale</em>, respectively. The hyperparameters
of the Uniform are also passed as a vector of length two with the first
and second elements corresponding to the lower and upper support,
respectively. If the regression coefficients, i.e., <code>beta</code>
vector, are assumed to follow a multivariate Normal distribution then pass the
hyperparameters as a list of length two with the first
and second elements corresponding to the mean vector and positive
definite covariance matrix, respectively. If
<code>beta</code> is assumed flat then no arguments are passed. The default
is a flat prior.
</p>
</td></tr>
<tr><td><code id="spLM_+3A_cov.model">cov.model</code></td>
<td>
<p>a quoted keyword that specifies the covariance
function used to model the spatial dependence structure among the
observations.  Supported covariance model key words are:
<code>"exponential"</code>, <code>"matern"</code>, <code>"spherical"</code>, and
<code>"gaussian"</code>.  See below for details.  </p>
</td></tr>
<tr><td><code id="spLM_+3A_modified.pp">modified.pp</code></td>
<td>
<p>a logical value indicating if the <em>modified
predictive process</em> should be used (see references below for
details). Note, if a predictive process model is not used (i.e., <code>knots</code> is not specified) then
this argument is ignored. </p>
</td></tr>
<tr><td><code id="spLM_+3A_amcmc">amcmc</code></td>
<td>
<p>a list with tags <code>n.batch</code>, <code>batch.length</code>, and
<code>accept.rate</code>. Specifying this argument invokes an adaptive MCMC
sampler, see Roberts and Rosenthal (2007) for an explanation.</p>
</td></tr>
<tr><td><code id="spLM_+3A_n.samples">n.samples</code></td>
<td>
<p>the number of MCMC iterations. This argument is
ignored if <code>amcmc</code> is specified.</p>
</td></tr>
<tr><td><code id="spLM_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, model specification and progress of the
sampler is printed to the screen. Otherwise, nothing is printed to
the screen.  </p>
</td></tr>
<tr><td><code id="spLM_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report Metropolis sampler acceptance and MCMC progress. </p>
</td></tr>  
<tr><td><code id="spLM_+3A_...">...</code></td>
<td>
<p>currently no additional arguments.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Model parameters can be fixed at their <code>starting</code> values by setting their
<code>tuning</code> values to zero.
</p>
<p>The <em>no nugget</em> model is specified by removing <code>tau.sq</code> from the <code>starting</code> list.
</p>


<h3>Value</h3>

<p>An object of class <code>spLM</code>, which is a list with the following
tags:
</p>
<table role = "presentation">
<tr><td><code>coords</code></td>
<td>
<p>the <code class="reqn">n \times 2</code> matrix specified by
<code>coords</code>.  </p>
</td></tr>
<tr><td><code>knot.coords</code></td>
<td>
<p>the <code class="reqn">m \times 2</code> matrix as specified by <code>knots</code>.  </p>
</td></tr>
<tr><td><code>p.theta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples for the defined
parameters. </p>
</td></tr>
<tr><td><code>acceptance</code></td>
<td>
<p>the Metropolis sampling
acceptance percent. Reported at <code>batch.length</code> or <code>n.report</code>
intervals for <code>amcmc</code> specified and non-specified, respectively.</p>
</td></tr>
</table>
<p>The return object might include additional data used for subsequent
prediction and/or model fit evaluation.
</p>


<h3>Author(s)</h3>

<p>Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>, <br />
Sudipto Banerjee <a href="mailto:baner009@umn.edu">baner009@umn.edu</a>
</p>


<h3>References</h3>

<p>Banerjee, S., A.E. Gelfand, A.O. Finley, and H. Sang. (2008) Gaussian Predictive Process Models for Large Spatial Datasets. <em>Journal of the Royal Statistical Society Series B</em>, 70:825&ndash;848.
</p>
<p>Banerjee, S., Carlin, B.P., and Gelfand, A.E. (2004). Hierarchical
modeling and analysis for spatial data. Chapman and Hall/CRC Press,
Boca Raton, FL.
</p>
<p>Finley, A.O., S. Banerjee, and A.E. Gelfand. (2015) spBayes for large
univariate and multivariate point-referenced spatio-temporal data
models. <em>Journal of Statistical Software</em>, 63:1&ndash;28. <a href="https://www.jstatsoft.org/article/view/v063i13">https://www.jstatsoft.org/article/view/v063i13</a>.
</p>
<p>Finley, A.O., H. Sang, S. Banerjee, and A.E. Gelfand. (2009) Improving the performance of predictive process modeling for large datasets. <em>Computational Statistics and Data Analysis</em>, 53:2873&ndash;2884.
</p>
<p>Roberts G.O. and Rosenthal J.S. (2006). Examples of Adaptive MCMC. <a href="http://probability.ca/jeff/ftpdir/adaptex.pdf">http://probability.ca/jeff/ftpdir/adaptex.pdf</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spMvLM">spMvLM</a></code>  <code><a href="#topic+spSVC">spSVC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(coda)

## Not run: 
rmvn &lt;- function(n, mu=0, V = matrix(1)){
  p &lt;- length(mu)
  if(any(is.na(match(dim(V),p))))
    stop("Dimension problem!")
  D &lt;- chol(V)
  t(matrix(rnorm(n*p), ncol=p)%*%D + rep(mu,rep(n,p)))
}

set.seed(1)

n &lt;- 100
coords &lt;- cbind(runif(n,0,1), runif(n,0,1))
X &lt;- as.matrix(cbind(1, rnorm(n)))

B &lt;- as.matrix(c(1,5))
p &lt;- length(B)

sigma.sq &lt;- 2
tau.sq &lt;- 0.1
phi &lt;- 3/0.5

D &lt;- as.matrix(dist(coords))
R &lt;- exp(-phi*D)
w &lt;- rmvn(1, rep(0,n), sigma.sq*R)
y &lt;- rnorm(n, X%*%B + w, sqrt(tau.sq))

n.samples &lt;- 2000

starting &lt;- list("phi"=3/0.5, "sigma.sq"=50, "tau.sq"=1)

tuning &lt;- list("phi"=0.1, "sigma.sq"=0.1, "tau.sq"=0.1)

priors.1 &lt;- list("beta.Norm"=list(rep(0,p), diag(1000,p)),
                 "phi.Unif"=c(3/1, 3/0.1), "sigma.sq.IG"=c(2, 2),
                 "tau.sq.IG"=c(2, 0.1))

priors.2 &lt;- list("beta.Flat", "phi.Unif"=c(3/1, 3/0.1),
                 "sigma.sq.IG"=c(2, 2), "tau.sq.IG"=c(2, 0.1))

cov.model &lt;- "exponential"

n.report &lt;- 500
verbose &lt;- TRUE

m.1 &lt;- spLM(y~X-1, coords=coords, starting=starting,
            tuning=tuning, priors=priors.1, cov.model=cov.model,
            n.samples=n.samples, verbose=verbose, n.report=n.report)

m.2 &lt;- spLM(y~X-1, coords=coords, starting=starting,
            tuning=tuning, priors=priors.2, cov.model=cov.model,
            n.samples=n.samples, verbose=verbose, n.report=n.report)

burn.in &lt;- 0.5*n.samples

##recover beta and spatial random effects
m.1 &lt;- spRecover(m.1, start=burn.in, verbose=FALSE)
m.2 &lt;- spRecover(m.2, start=burn.in, verbose=FALSE)

round(summary(m.1$p.theta.recover.samples)$quantiles[,c(3,1,5)],2)
round(summary(m.2$p.theta.recover.samples)$quantiles[,c(3,1,5)],2)

round(summary(m.1$p.beta.recover.samples)$quantiles[,c(3,1,5)],2)
round(summary(m.2$p.beta.recover.samples)$quantiles[,c(3,1,5)],2)

m.1.w.summary &lt;- summary(mcmc(t(m.1$p.w.recover.samples)))$quantiles[,c(3,1,5)]
m.2.w.summary &lt;- summary(mcmc(t(m.2$p.w.recover.samples)))$quantiles[,c(3,1,5)]

plot(w, m.1.w.summary[,1], xlab="Observed w", ylab="Fitted w",
     xlim=range(w), ylim=range(m.1.w.summary), main="Spatial random effects")
arrows(w, m.1.w.summary[,1], w, m.1.w.summary[,2], length=0.02, angle=90)
arrows(w, m.1.w.summary[,1], w, m.1.w.summary[,3], length=0.02, angle=90)
lines(range(w), range(w))

points(w, m.2.w.summary[,1], col="blue", pch=19, cex=0.5)
arrows(w, m.2.w.summary[,1], w, col="blue", m.2.w.summary[,2], length=0.02, angle=90)
arrows(w, m.2.w.summary[,1], w, col="blue", m.2.w.summary[,3], length=0.02, angle=90)

###########################
##Predictive process model
###########################
m.1 &lt;- spLM(y~X-1, coords=coords, knots=c(6,6,0.1), starting=starting,
            tuning=tuning, priors=priors.1, cov.model=cov.model,
            n.samples=n.samples, verbose=verbose, n.report=n.report)

m.2 &lt;- spLM(y~X-1, coords=coords, knots=c(6,6,0.1), starting=starting,
            tuning=tuning, priors=priors.2, cov.model=cov.model,
            n.samples=n.samples, verbose=verbose, n.report=n.report)

burn.in &lt;- 0.5*n.samples

round(summary(window(m.1$p.beta.samples, start=burn.in))$quantiles[,c(3,1,5)],2)
round(summary(window(m.2$p.beta.samples, start=burn.in))$quantiles[,c(3,1,5)],2)

round(summary(window(m.1$p.theta.samples, start=burn.in))$quantiles[,c(3,1,5)],2)
round(summary(window(m.2$p.theta.samples, start=burn.in))$quantiles[,c(3,1,5)],2)

## End(Not run)
</code></pre>

<hr>
<h2 id='spMisalignGLM'>Function for fitting multivariate generalized linear Bayesian spatial regression models to misaligned data</h2><span id='topic+spMisalignGLM'></span>

<h3>Description</h3>

<p>The function <code>spMisalignGLM</code> fits Gaussian multivariate Bayesian
generalized linear spatial regression models to misaligned data. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spMisalignGLM(formula, family="binomial", weights, data = parent.frame(), coords, 
      starting, tuning, priors, cov.model,
      amcmc, n.samples, verbose=TRUE, n.report=100, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spMisalignGLM_+3A_formula">formula</code></td>
<td>
<p>a list of <code class="reqn">q</code> symbolic regression models to be fit. See example below. </p>
</td></tr>
<tr><td><code id="spMisalignGLM_+3A_family">family</code></td>
<td>
<p>currently only supports <code>binomial</code> and
<code>poisson</code> data using the logit and log link functions,
respectively.</p>
</td></tr>
<tr><td><code id="spMisalignGLM_+3A_weights">weights</code></td>
<td>
<p>an optional list of weight vectors associated with each model
in the formula list. Weights correspond to number of trials and <em>offset</em> for
each location for the <code>binomial</code> and <code>poisson</code> family,
respectively.</p>
</td></tr>
<tr><td><code id="spMisalignGLM_+3A_data">data</code></td>
<td>
<p>an optional data frame containing the variables in the
model. If not found in <code>data</code>, the variables are taken from <code>environment(formula)</code>, typically the environment from which <code>spMisalignGLM</code> is called.  </p>
</td></tr>
<tr><td><code id="spMisalignGLM_+3A_coords">coords</code></td>
<td>
<p>a list of <code class="reqn">q</code> <code class="reqn">n_i \times 2</code>
matrices of the observation coordinates in <code class="reqn">R^2</code> (e.g.,
easting and northing) where <code class="reqn">i=(1,2,\ldots,q)</code>. </p>
</td></tr>
<tr><td><code id="spMisalignGLM_+3A_starting">starting</code></td>
<td>
<p>a list with tags corresponding to <code>A</code>,
<code>phi</code>, and <code>nu</code>. The value portion of each tag is a vector
that holds the parameter's starting values. <code>A</code> is of length <code class="reqn">\frac{q(q+1)}{2}</code> and holds the lower-triangle elements in column major ordering of the Cholesky square root
of the spatial cross-covariance matrix <code class="reqn">K=AA'</code>. <code>phi</code> and <code>nu</code> are
of length <code class="reqn">q</code>.</p>
</td></tr>
<tr><td><code id="spMisalignGLM_+3A_tuning">tuning</code></td>
<td>
<p>a list with tags <code>A</code>, <code>phi</code>, and <code>nu</code>. The value portion of each tag defines the
variance of the Metropolis sampler Normal proposal distribution.
<code>A</code> is of length <code class="reqn">\frac{q(q+1)}{2}</code> and <code>phi</code>
and <code>nu</code> are of length <code class="reqn">q</code>.</p>
</td></tr>
<tr><td><code id="spMisalignGLM_+3A_priors">priors</code></td>
<td>
<p>a list with each tag corresponding to a
parameter name. Valid tags are <code>beta.flat</code>,
<code>beta.norm</code>, <code>K.iw</code>, <code>phi.unif</code>, and
<code>nu.unif</code>. If the regression coefficients are each assumed to follow a Normal distribution, i.e., <code>beta.norm</code>, then mean and variance hyperparameters are passed as the first and second list elements, respectively. If
<code>beta</code> is assumed flat then no arguments are passed. The default
is a flat prior. The spatial cross-covariance matrix <code class="reqn">K=AA'</code> is assumed to follow an
inverse-Wishart distribution, whereas the spatial decay <code>phi</code>
and smoothness <code>nu</code> parameters are assumed to follow Uniform distributions. The
hyperparameters of the inverse-Wishart are
passed as a list of length two, with the first and second elements corresponding
to the <code class="reqn">df</code> and <code class="reqn">q\times q</code> <em>scale</em> matrix,
respectively. The hyperparameters of the Uniform are also passed as a list of vectors with the first and second list elements corresponding to the lower and upper
support, respectively. </p>
</td></tr>
<tr><td><code id="spMisalignGLM_+3A_cov.model">cov.model</code></td>
<td>
<p>a quoted keyword that specifies the covariance
function used to model the spatial dependence structure among the
observations.  Supported covariance model key words are:
<code>"exponential"</code>, <code>"matern"</code>, <code>"spherical"</code>, and
<code>"gaussian"</code>.  See below for details.  </p>
</td></tr>
<tr><td><code id="spMisalignGLM_+3A_amcmc">amcmc</code></td>
<td>
<p>a list with tags <code>n.batch</code>, <code>batch.length</code>, and
<code>accept.rate</code>. Specifying this argument invokes an adaptive MCMC
sampler see Roberts and Rosenthal (2007) for an explanation.</p>
</td></tr>
<tr><td><code id="spMisalignGLM_+3A_n.samples">n.samples</code></td>
<td>
<p>the number of MCMC iterations. This argument is
ignored if <code>amcmc</code> is specified. </p>
</td></tr>
<tr><td><code id="spMisalignGLM_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, model specification and progress of the
sampler is printed to the screen. Otherwise, nothing is printed to
the screen.  </p>
</td></tr>
<tr><td><code id="spMisalignGLM_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report Metropolis acceptance and MCMC progress. </p>
</td></tr>  
<tr><td><code id="spMisalignGLM_+3A_...">...</code></td>
<td>
<p>currently no additional arguments.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a <code>binomial</code> model is specified the response vector is the
number of successful trials at each location and <code>weights</code> is the
total number of trials at each location.
</p>
<p>For a <code>poisson</code> specification, the <code>weights</code> vector is the
count offset, e.g., population, at each location. This differs from
the <code><a href="stats.html#topic+glm">glm</a></code> <code>offset</code> argument which is passed as the
log of this value.  
</p>


<h3>Value</h3>

<p>An object of class <code>spMisalignGLM</code>, which is a list with the following
tags:
</p>
<table role = "presentation">
<tr><td><code>p.beta.theta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples for the defined
parameters. </p>
</td></tr>
<tr><td><code>acceptance</code></td>
<td>
<p>the Metropolis sampler
acceptance rate. If <code>amcmc</code> is used then this will be a matrix of
each parameter's acceptance rate at the end of each
batch. Otherwise, the sampler is a Metropolis with a joint proposal
of all parameters.</p>
</td></tr>
<tr><td><code>acceptance.w</code></td>
<td>
<p>if <code>amcmc</code> is used then this will be a matrix of the Metropolis sampler acceptance rate for each location's spatial random effect. </p>
</td></tr>
<tr><td><code>p.w.samples</code></td>
<td>
<p>a matrix that holds samples from the posterior
distribution of the locations' spatial random effects. Posterior samples are organized with the first response variable
<code class="reqn">n_1</code> locations held in rows <code class="reqn">1\ldots,n_1</code> rows, then the
next response variable samples held in the
<code class="reqn">(n_1+1),\ldots,(n_1+n_2)</code>, etc.</p>
</td></tr>
</table>
<p>The return object might include additional data used for subsequent
prediction and/or model fit evaluation.
</p>


<h3>Author(s)</h3>

<p>Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>, <br />
Sudipto Banerjee <a href="mailto:baner009@umn.edu">baner009@umn.edu</a>
</p>


<h3>References</h3>

<p>Banerjee, S., A.E. Gelfand, A.O. Finley, and H. Sang. (2008) Gaussian Predictive Process Models for Large Spatial Datasets. <em>Journal of the Royal Statistical Society Series B</em>, 70:825&ndash;848.
</p>
<p>Banerjee, S., Carlin, B.P., and Gelfand, A.E. (2004). Hierarchical modeling and analysis for spatial data. Chapman and Hall/CRC Press, Boca Raton, Fla.
</p>
<p>Finley, A.O., S. Banerjee, and B.D. Cook. (2014) Bayesian hierarchical models for spatially misaligned data. <em>Methods in Ecology and Evolution</em>, 5:514&ndash;523.
</p>
<p>Finley, A.O., H. Sang, S. Banerjee, and A.E. Gelfand. (2009) Improving the performance of predictive process modeling for large datasets. <em>Computational Statistics and Data Analysis</em>, 53:2873&ndash;2884.
</p>
<p>Finley, A.O., S. Banerjee, A.R. Ek, and R.E. McRoberts. (2008) Bayesian multivariate process modeling for prediction of forest attributes. <em>Journal of Agricultural, Biological, and Environmental Statistics</em>, 13:60&ndash;83.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spMvGLM">spMvGLM</a></code> <code><a href="#topic+spMisalignLM">spMisalignLM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
rmvn &lt;- function(n, mu=0, V = matrix(1)){
  p &lt;- length(mu)
  if(any(is.na(match(dim(V),p)))){stop("Dimension problem!")}
  D &lt;- chol(V)
  t(matrix(rnorm(n*p), ncol=p)%*%D + rep(mu,rep(n,p)))
}

set.seed(1)

##generate some data
n &lt;- 100 ##number of locations
q &lt;- 3 ##number of outcomes at each location
nltr &lt;- q*(q+1)/2 ##number of triangular elements in the cross-covariance matrix

coords &lt;- cbind(runif(n,0,1), runif(n,0,1))

##parameters for generating a multivariate spatial GP covariance matrix
theta &lt;- rep(3/0.5,q) ##spatial decay

A &lt;- matrix(0,q,q)
A[lower.tri(A,TRUE)] &lt;- c(1,1,-1,1,0.5,0.25)
K &lt;- A%*%t(A)
K ##spatial cross-covariance
cov2cor(K) ##spatial cross-correlation

C &lt;- mkSpCov(coords, K, diag(0,q), theta, cov.model="exponential")

w &lt;- rmvn(1, rep(0,nrow(C)), C) ##spatial random effects

w.a &lt;- w[seq(1,length(w),q)]
w.b &lt;- w[seq(2,length(w),q)]
w.c &lt;- w[seq(3,length(w),q)]

##covariate portion of the mean
x.a &lt;- cbind(1, rnorm(n))
x.b &lt;- cbind(1, rnorm(n))
x.c &lt;- cbind(1, rnorm(n))
x &lt;- mkMvX(list(x.a, x.b, x.c))

B.1 &lt;- c(1,-1)
B.2 &lt;- c(-1,1)
B.3 &lt;- c(-1,-1)
B &lt;- c(B.1, B.2, B.3)

y &lt;- rpois(nrow(C), exp(x%*%B+w))

y.a &lt;- y[seq(1,length(y),q)]
y.b &lt;- y[seq(2,length(y),q)]
y.c &lt;- y[seq(3,length(y),q)]

##subsample to make spatially misaligned data
sub.1 &lt;- 1:50
y.1 &lt;- y.a[sub.1]
w.1 &lt;- w.a[sub.1]
coords.1 &lt;- coords[sub.1,]
x.1 &lt;- x.a[sub.1,]

sub.2 &lt;- 25:75
y.2 &lt;- y.b[sub.2]
w.2 &lt;- w.b[sub.2]
coords.2 &lt;- coords[sub.2,]
x.2 &lt;- x.b[sub.2,]

sub.3 &lt;- 50:100
y.3 &lt;- y.c[sub.3]
w.3 &lt;- w.c[sub.3]
coords.3 &lt;- coords[sub.3,]
x.3 &lt;- x.c[sub.3,]

##call spMisalignGLM
q &lt;- 3
A.starting &lt;- diag(1,q)[lower.tri(diag(1,q), TRUE)]

n.batch &lt;- 200
batch.length &lt;- 25
n.samples &lt;- n.batch*batch.length

starting &lt;- list("beta"=rep(0,length(B)), "phi"=rep(3/0.5,q), "A"=A.starting, "w"=0)
                 
tuning &lt;- list("beta"=rep(0.1,length(B)), "phi"=rep(1,q), "A"=rep(0.1,length(A.starting)), "w"=1)

priors &lt;- list("phi.Unif"=list(rep(3/0.75,q), rep(3/0.25,q)),
               "K.IW"=list(q+1, diag(0.1,q)),  rep(0.1,q))

m.1 &lt;- spMisalignGLM(list(y.1~x.1-1, y.2~x.2-1, y.3~x.3-1), family="poisson",
                     coords=list(coords.1, coords.2, coords.3),
                     starting=starting, tuning=tuning, priors=priors,
                     amcmc=list("n.batch"=n.batch, "batch.length"=batch.length, "accept.rate"=0.43),
                     cov.model="exponential", n.report=10)

burn.in &lt;- floor(0.75*n.samples)

plot(m.1$p.beta.theta.samples, density=FALSE)

##predict for all locations, i.e., observed and not observed
out &lt;- spPredict(m.1, start=burn.in, thin=10, pred.covars=list(x.a, x.b, x.c), 
                 pred.coords=list(coords, coords, coords))

##summary and check
quants &lt;- function(x){quantile(x, prob=c(0.5,0.025,0.975))}

y.hat &lt;- apply(out$p.y.predictive.samples, 1, quants)

##unstack and plot
y.a.hat &lt;- y.hat[,1:n]
y.b.hat &lt;- y.hat[,(n+1):(2*n)]
y.c.hat &lt;- y.hat[,(2*n+1):(3*n)]

par(mfrow=c(1,3))
plot(y.a ,y.a.hat[1,], xlab="Observed y.a", ylab="Fitted &amp; predicted y.a")
plot(y.b, y.b.hat[1,], xlab="Observed y.b", ylab="Fitted &amp; predicted y.b")
plot(y.c, y.c.hat[1,], xlab="Observed y.c", ylab="Fitted &amp; predicted y.c")

  
## End(Not run)
</code></pre>

<hr>
<h2 id='spMisalignLM'>Function for fitting multivariate Bayesian spatial regression
models to misaligned data</h2><span id='topic+spMisalignLM'></span>

<h3>Description</h3>

<p>The function <code>spMisalignLM</code> fits Gaussian multivariate Bayesian
spatial regression models to misaligned data. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spMisalignLM(formula, data = parent.frame(), coords, 
      starting, tuning, priors, cov.model,
      amcmc, n.samples, verbose=TRUE, n.report=100, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spMisalignLM_+3A_formula">formula</code></td>
<td>
<p>a list of <code class="reqn">q</code> symbolic regression models to be fit. See example below. </p>
</td></tr>
<tr><td><code id="spMisalignLM_+3A_data">data</code></td>
<td>
<p>an optional data frame containing the variables in the
model. If not found in <code>data</code>, the variables are taken from <code>environment(formula)</code>, typically the environment from which <code>spMisalignLM</code> is called.  </p>
</td></tr>
<tr><td><code id="spMisalignLM_+3A_coords">coords</code></td>
<td>
<p>a list of <code class="reqn">q</code> <code class="reqn">n_i \times 2</code>
matrices of the observation coordinates in <code class="reqn">R^2</code> (e.g.,
easting and northing) where <code class="reqn">i=(1,2,\ldots,q)</code>. . </p>
</td></tr>
<tr><td><code id="spMisalignLM_+3A_starting">starting</code></td>
<td>
<p>a list with tags corresponding to <code>A</code>,
<code>phi</code>, <code>nu</code>, and <code>Psi</code>. The value portion of each tag is a vector
that holds the parameter's starting values.
</p>
<p><code>A</code> is of length <code class="reqn">\frac{q(q+1)}{2}</code> and holds the lower-triangle elements in column major ordering of the Cholesky square root
of the spatial cross-covariance matrix.
</p>
<p><code>phi</code> and <code>nu</code> are
of length <code class="reqn">q</code>. The vector of residual variances <code>Psi</code> is also of length <code class="reqn">q</code>.</p>
</td></tr>
<tr><td><code id="spMisalignLM_+3A_tuning">tuning</code></td>
<td>
<p>a list with tags <code>A</code>, <code>phi</code>, <code>nu</code>, and <code>Psi</code>. The value portion of each tag defines the
variance of the Metropolis sampler Normal proposal distribution.
<code>A</code> is of length <code class="reqn">\frac{q(q+1)}{2}</code> and <code>Psi</code>,
<code>phi</code>, and <code>nu</code> are of length <code class="reqn">q</code>.</p>
</td></tr>
<tr><td><code id="spMisalignLM_+3A_priors">priors</code></td>
<td>
<p>a list with tags <code>beta.flat</code>, <code>K.iw</code>, <code>Psi.ig</code>, <code>phi.unif</code>
and <code>nu.unif</code>. The hyperparameters of the inverse-Wishart for
the cross-covariance matrix <code class="reqn">K=AA'</code> are
passed as a list of length two, with the first and second elements corresponding
to the <code class="reqn">df</code> and <code class="reqn">q\times q</code> <em>scale</em> matrix,
respectively.  The inverse-Gamma hyperparameters for the non-spatial
residual variances are specified as a list <code>Psi.ig</code> of length two with the first and second list elements consisting of
vectors of the <code class="reqn">q</code> <em>shape</em> and <em>scale</em> hyperparameters,
respectively. The hyperparameters of the Uniform <code>phi.unif</code>,
and <code>nu.unif</code> are also passed as a list of vectors with the first
and second list elements corresponding to the lower and upper
support, respectively. 
</p>
</td></tr>
<tr><td><code id="spMisalignLM_+3A_cov.model">cov.model</code></td>
<td>
<p>a quoted keyword that specifies the covariance
function used to model the spatial dependence structure among the
observations.  Supported covariance model key words are:
<code>"exponential"</code>, <code>"matern"</code>, <code>"spherical"</code>, and
<code>"gaussian"</code>.  See below for details.  </p>
</td></tr>
<tr><td><code id="spMisalignLM_+3A_amcmc">amcmc</code></td>
<td>
<p>a list with tags <code>n.batch</code>, <code>batch.length</code>, and
<code>accept.rate</code>. Specifying this argument invokes an adaptive MCMC
sampler see Roberts and Rosenthal (2007) for an explanation.</p>
</td></tr>
<tr><td><code id="spMisalignLM_+3A_n.samples">n.samples</code></td>
<td>
<p>the number of MCMC iterations. This argument is
ignored if <code>amcmc</code> is specified. </p>
</td></tr>
<tr><td><code id="spMisalignLM_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, model specification and progress of the
sampler is printed to the screen. Otherwise, nothing is printed to
the screen.  </p>
</td></tr>
<tr><td><code id="spMisalignLM_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report Metropolis acceptance and MCMC progress. </p>
</td></tr>  
<tr><td><code id="spMisalignLM_+3A_...">...</code></td>
<td>
<p>currently no additional arguments.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Model parameters can be fixed at their <code>starting</code> values by setting their
<code>tuning</code> values to zero.
</p>


<h3>Value</h3>

<p>An object of class <code>spMisalignLM</code>, which is a list with the following
tags:
</p>
<table role = "presentation">
<tr><td><code>p.theta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples for the defined
parameters. </p>
</td></tr>
<tr><td><code>acceptance</code></td>
<td>
<p>the Metropolis sampling
acceptance percent. Reported at <code>batch.length</code> or <code>n.report</code>
intervals for <code>amcmc</code> specified and non-specified, respectively</p>
</td></tr>
</table>
<p>The return object might include additional data used for subsequent
prediction and/or model fit evaluation.
</p>


<h3>Author(s)</h3>

<p>Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>, <br />
Sudipto Banerjee <a href="mailto:baner009@umn.edu">baner009@umn.edu</a>
</p>


<h3>References</h3>

<p>Banerjee, S., A.E. Gelfand, A.O. Finley, and H. Sang. (2008) Gaussian Predictive Process Models for Large Spatial Datasets. <em>Journal of the Royal Statistical Society Series B</em>, 70:825&ndash;848.
</p>
<p>Banerjee, S., Carlin, B.P., and Gelfand, A.E. (2004). Hierarchical modeling and analysis for spatial data. Chapman and Hall/CRC Press, Boca Raton, Fla.
</p>
<p>Finley, A.O., S. Banerjee, and B.D. Cook. (2014) Bayesian hierarchical models for spatially misaligned data. <em>Methods in Ecology and Evolution</em>, 5:514&ndash;523.
</p>
<p>Finley, A.O., H. Sang, S. Banerjee, and A.E. Gelfand. (2009) Improving the performance of predictive process modeling for large datasets. <em>Computational Statistics and Data Analysis</em>, 53:2873&ndash;2884.
</p>
<p>Finley, A.O., S. Banerjee, A.R. Ek, and R.E. McRoberts. (2008) Bayesian multivariate process modeling for prediction of forest attributes. <em>Journal of Agricultural, Biological, and Environmental Statistics</em>, 13:60&ndash;83.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spMvLM">spMvLM</a></code><code><a href="#topic+spMisalignGLM">spMisalignGLM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
rmvn &lt;- function(n, mu=0, V = matrix(1)){
  p &lt;- length(mu)
  if(any(is.na(match(dim(V),p)))){stop("Dimension problem!")}
  D &lt;- chol(V)
  t(matrix(rnorm(n*p), ncol=p)%*%D + rep(mu,rep(n,p)))
}

set.seed(1)

##generate some data
n &lt;- 100 ##number of locations
q &lt;- 3 ##number of outcomes at each location
nltr &lt;- q*(q+1)/2 ##number of triangular elements in the cross-covariance matrix

coords &lt;- cbind(runif(n,0,1), runif(n,0,1))

##parameters for generating a multivariate spatial GP covariance matrix
theta &lt;- rep(3/0.5,q) ##spatial decay

A &lt;- matrix(0,q,q)
A[lower.tri(A,TRUE)] &lt;- c(1,1,-1,1,0.5,0.25)
K &lt;- A%*%t(A)
K ##spatial cross-covariance
cov2cor(K) ##spatial cross-correlation

C &lt;- mkSpCov(coords, K, diag(0,q), theta, cov.model="exponential")

w &lt;- rmvn(1, rep(0,nrow(C)), C) ##spatial random effects

w.a &lt;- w[seq(1,length(w),q)]
w.b &lt;- w[seq(2,length(w),q)]
w.c &lt;- w[seq(3,length(w),q)]

##covariate portion of the mean
x.a &lt;- cbind(1, rnorm(n))
x.b &lt;- cbind(1, rnorm(n))
x.c &lt;- cbind(1, rnorm(n))
x &lt;- mkMvX(list(x.a, x.b, x.c))

B.1 &lt;- c(1,-1)
B.2 &lt;- c(-1,1)
B.3 &lt;- c(-1,-1)
B &lt;- c(B.1, B.2, B.3)

Psi &lt;- c(0.1, 0.1, 0.1) ##non-spatial residual variance, i.e., nugget

y &lt;- rnorm(n*q, x%*%B+w, rep(sqrt(Psi),n))

y.a &lt;- y[seq(1,length(y),q)]
y.b &lt;- y[seq(2,length(y),q)]
y.c &lt;- y[seq(3,length(y),q)]

##subsample to make spatially misaligned data
sub.1 &lt;- 1:50
y.1 &lt;- y.a[sub.1]
w.1 &lt;- w.a[sub.1]
coords.1 &lt;- coords[sub.1,]
x.1 &lt;- x.a[sub.1,]

sub.2 &lt;- 25:75
y.2 &lt;- y.b[sub.2]
w.2 &lt;- w.b[sub.2]
coords.2 &lt;- coords[sub.2,]
x.2 &lt;- x.b[sub.2,]

sub.3 &lt;- 50:100
y.3 &lt;- y.c[sub.3]
w.3 &lt;- w.c[sub.3]
coords.3 &lt;- coords[sub.3,]
x.3 &lt;- x.c[sub.3,]

##call spMisalignLM
q &lt;- 3
A.starting &lt;- diag(1,q)[lower.tri(diag(1,q), TRUE)]
n.samples &lt;- 5000

starting &lt;- list("phi"=rep(3/0.5,q), "A"=A.starting, "Psi"=rep(1,q))
tuning &lt;- list("phi"=rep(0.5,q), "A"=rep(0.01,length(A.starting)), "Psi"=rep(0.1,q))
priors &lt;- list("phi.Unif"=list(rep(3/0.75,q), rep(3/0.25,q)),
               "K.IW"=list(q+1, diag(0.1,q)), "Psi.ig"=list(rep(2,q), rep(0.1,q)))

m.1 &lt;- spMisalignLM(list(y.1~x.1-1, y.2~x.2-1, y.3~x.3-1), 
                    coords=list(coords.1, coords.2, coords.3),
                    starting=starting, tuning=tuning, priors=priors, 
                    n.samples=n.samples, cov.model="exponential", n.report=100)

burn.in &lt;- floor(0.75*n.samples)

plot(m.1$p.theta.samples, density=FALSE)

##recover regression coefficients and random effects
m.1 &lt;- spRecover(m.1, start=burn.in)

round(summary(m.1$p.theta.recover.samples)$quantiles[,c(3,1,5)],2)
round(summary(m.1$p.beta.recover.samples)$quantiles[,c(3,1,5)],2)

##predict for all locations, i.e., observed and not observed
out &lt;- spPredict(m.1, start=burn.in, thin=10, pred.covars=list(x.a, x.b,
x.c), 
                 pred.coords=list(coords, coords, coords))

##summary and check
quants &lt;- function(x){quantile(x, prob=c(0.5,0.025,0.975))}

y.hat &lt;- apply(out$p.y.predictive.samples, 1, quants)

##unstack and plot
y.a.hat &lt;- y.hat[,1:n]
y.b.hat &lt;- y.hat[,(n+1):(2*n)]
y.c.hat &lt;- y.hat[,(2*n+1):(3*n)]

par(mfrow=c(1,3))
plot(y.a, y.a.hat[1,], xlab="Observed y.a", ylab="Fitted &amp; predicted y.a",
     xlim=range(y), ylim=range(y.hat), main="")
arrows(y.a[-sub.1], y.a.hat[1,-sub.1], y.a[-sub.1], y.a.hat[2,-sub.1], length=0.02, angle=90)
arrows(y.a[-sub.1], y.a.hat[1,-sub.1], y.a[-sub.1], y.a.hat[3,-sub.1], length=0.02, angle=90)
lines(range(y.a), range(y.a))

plot(y.b, y.b.hat[1,], xlab="Observed y.b", ylab="Fitted &amp; predicted y.b",
     xlim=range(y), ylim=range(y.hat), main="")
arrows(y.b[-sub.2], y.b.hat[1,-sub.2], y.b[-sub.2], y.b.hat[2,-sub.2], length=0.02, angle=90)
arrows(y.b[-sub.2], y.b.hat[1,-sub.2], y.b[-sub.2], y.b.hat[3,-sub.2], length=0.02, angle=90)
lines(range(y.b), range(y.b))

plot(y.c, y.c.hat[1,], xlab="Observed y.c", ylab="Fitted &amp; predicted y.c",
     xlim=range(y), ylim=range(y.hat), main="")
arrows(y.c[-sub.3], y.c.hat[1,-sub.3], y.c[-sub.3], y.c.hat[2,-sub.3], length=0.02, angle=90)
arrows(y.c[-sub.3], y.c.hat[1,-sub.3], y.c[-sub.3], y.c.hat[3,-sub.3], length=0.02, angle=90)
lines(range(y.c), range(y.c))

## End(Not run)
</code></pre>

<hr>
<h2 id='spMvGLM'>Function for fitting multivariate Bayesian generalized linear spatial regression models</h2><span id='topic+spMvGLM'></span>

<h3>Description</h3>

<p>The function <code>spMvGLM</code> fits multivariate Bayesian
generalized linear spatial regression models. Given a set of knots,
<code>spMvGLM</code> will also fit a <em>predictive process</em> model (see references below).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spMvGLM(formula, family="binomial", weights, data = parent.frame(), coords, knots,
      starting, tuning, priors, cov.model,
      amcmc, n.samples, 
      verbose=TRUE, n.report=100, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spMvGLM_+3A_formula">formula</code></td>
<td>
<p>a list of <code class="reqn">q</code> symbolic regression model descriptions to be fit. See example below. </p>
</td></tr>
<tr><td><code id="spMvGLM_+3A_family">family</code></td>
<td>
<p>currently only supports <code>binomial</code> and
<code>poisson</code> data using the logit and log link functions,
respectively.</p>
</td></tr>
<tr><td><code id="spMvGLM_+3A_weights">weights</code></td>
<td>
<p>an optional <code class="reqn">n \times q</code> matrix of weights
to be used in the fitting process. The order of the
columns correspond to the univariate models in the formula list. Weights correspond to number of trials and <em>offset</em> for
each location for the <code>binomial</code> and <code>poisson</code> family,
respectively.</p>
</td></tr>
<tr><td><code id="spMvGLM_+3A_data">data</code></td>
<td>
<p>an optional data frame containing the variables in the
model. If not found in <code>data</code>, the variables are taken from
<code>environment(formula)</code>, typically the environment from which <code>spMvGLM</code> is called.  </p>
</td></tr>
<tr><td><code id="spMvGLM_+3A_coords">coords</code></td>
<td>
<p>an <code class="reqn">n \times 2</code> matrix of the observation coordinates in <code class="reqn">R^2</code> (e.g., easting and northing). </p>
</td></tr>
<tr><td><code id="spMvGLM_+3A_knots">knots</code></td>
<td>
<p>either a <code class="reqn">m \times 2</code> matrix of the
<em>predictive process</em> knot coordinates in <code class="reqn">R^2</code> (e.g.,
easting and northing) or a vector of length two or three with the
first and second elements recording the  number of columns and rows in
the desired knot grid. The third, optional, element sets the offset of
the outermost knots from the extent of the <code>coords</code>. </p>
</td></tr>
<tr><td><code id="spMvGLM_+3A_starting">starting</code></td>
<td>
<p>a list with each tag corresponding to a parameter name. Valid tags are <code>beta</code>, <code>A</code>, <code>phi</code>,
<code>nu</code>, and <code>w</code>. The value portion of each tag is a vector
that holds the parameter's starting values and are of length
<code class="reqn">p</code> for <code>beta</code> (where <code class="reqn">p</code> is the total number of regression coefficients in the multivariate model), <code class="reqn">\frac{q(q+1)}{2}</code> for
<code>A</code>, and <code class="reqn">q</code> for <code>phi</code>, and <code>nu</code>. Here, <code>A</code> holds the the lower-triangle elements in column major ordering of the Cholesky square root
of the spatial cross-covariance matrix. If the
<em>predictive process</em> is used then <code>w</code> 
must be of length <code class="reqn">qm</code>; otherwise,
it must be of length <code class="reqn">qn</code>. Alternatively, <code>w</code> can be set
as a scalar, in which case the value is repeated. </p>
</td></tr>
<tr><td><code id="spMvGLM_+3A_tuning">tuning</code></td>
<td>
<p>a list with tags <code>beta</code>, <code>A</code>, <code>phi</code>,
<code>nu</code>, and <code>w</code>. The value portion of each tag defines the
variance of the Metropolis sampler Normal proposal distribution. The value portion of these tags is of length <code class="reqn">p</code> for <code>beta</code>, <code class="reqn">\frac{q(q+1)}{2}</code> for
<code>A</code>, and <code class="reqn">q</code> for <code>phi</code>, and <code>nu</code>. Here, <code>A</code>
holds the tuning values corresponding to the lower-triangle elements in column major ordering of the Cholesky square root
of the spatial cross-covariance matrix.   If the
<em>predictive process</em> is used then <code>w</code> 
must be of length <code class="reqn">qm</code>; otherwise,
it must be of length <code class="reqn">qn</code>. Alternatively, <code>w</code> can be set
as a scalar, in which case the value is repeated.  The tuning value for <code>beta</code> can be a vector of length <code class="reqn">p</code> or, if an adaptive MCMC is not used,
i.e., <code>amcmc</code> is not specified, the lower-triangle of the
<code class="reqn">p\times p</code> Cholesky square-root of the desired proposal
covariance matrix.
</p>
</td></tr>
<tr><td><code id="spMvGLM_+3A_priors">priors</code></td>
<td>
<p>a list with each tag corresponding to a
parameter name. Valid tags are <code>beta.flat</code>,
<code>beta.norm</code>, <code>K.iw</code>, <code>phi.unif</code>, and
<code>nu.unif</code>. If the regression coefficients are each assumed to follow a Normal distribution, i.e., <code>beta.norm</code>, then mean and variance hyperparameters are passed as the first and second list elements, respectively. If
<code>beta</code> is assumed flat then no arguments are passed. The default
is a flat prior. The spatial cross-covariance matrix <code>K</code> is assumed to follow an
inverse-Wishart distribution, whereas the spatial decay <code>phi</code>
and smoothness <code>nu</code> parameters are assumed to follow Uniform distributions. The
hyperparameters of the inverse-Wishart are
passed as a list of length two, with the first and second elements corresponding
to the <code class="reqn">df</code> and <code class="reqn">q\times q</code> <em>scale</em> matrix,
respectively. The hyperparameters of the Uniform are also passed as a list of vectors with the first and second list elements corresponding to the lower and upper
support, respectively. </p>
</td></tr>
<tr><td><code id="spMvGLM_+3A_cov.model">cov.model</code></td>
<td>
<p>a quoted keyword that specifies the covariance
function used to model the spatial dependence structure among the
observations.  Supported covariance model key words are:
<code>"exponential"</code>, <code>"matern"</code>, <code>"spherical"</code>, and
<code>"gaussian"</code>.  See below for details.  </p>
</td></tr>
<tr><td><code id="spMvGLM_+3A_amcmc">amcmc</code></td>
<td>
<p>a list with tags <code>n.batch</code>, <code>batch.length</code>, and
<code>accept.rate</code>. Specifying this argument invokes an adaptive MCMC
sampler see Roberts and Rosenthal (2007) for an explanation.</p>
</td></tr>
<tr><td><code id="spMvGLM_+3A_n.samples">n.samples</code></td>
<td>
<p>the number of MCMC iterations. This argument is
ignored if <code>amcmc</code> is specified. </p>
</td></tr>
<tr><td><code id="spMvGLM_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, model specification and progress of the
sampler is printed to the screen. Otherwise, nothing is printed to
the screen.  </p>
</td></tr>
<tr><td><code id="spMvGLM_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report Metropolis sampler acceptance and MCMC progress. </p>
</td></tr>  
<tr><td><code id="spMvGLM_+3A_...">...</code></td>
<td>
<p>currently no additional arguments.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a <code>binomial</code> model is specified the response vector is the
number of successful trials at each location and <code>weights</code> is the
total number of trials at each location.
</p>
<p>For a <code>poisson</code> specification, the <code>weights</code> vector is the
count offset, e.g., population, at each location. This differs from
the <code><a href="stats.html#topic+glm">glm</a></code> <code>offset</code> argument which is passed as the
log of this value.  
</p>
<p>A non-spatial model is fit when <code>coords</code> is not specified. See
example below.  
</p>


<h3>Value</h3>

<p>An object of class <code>spMvGLM</code>, which is a list with the following
tags:
</p>
<table role = "presentation">
<tr><td><code>coords</code></td>
<td>
<p>the <code class="reqn">n \times 2</code> matrix specified by
<code>coords</code>.  </p>
</td></tr>
<tr><td><code>knot.coords</code></td>
<td>
<p>the <code class="reqn">m \times 2</code> matrix as specified by <code>knots</code>.  </p>
</td></tr>
<tr><td><code>p.beta.theta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples for the defined
parameters. </p>
</td></tr>
<tr><td><code>acceptance</code></td>
<td>
<p>the Metropolis sampler
acceptance rate. If <code>amcmc</code> is used then this will be a matrix of
each parameter's acceptance rate at the end of each
batch. Otherwise, the sampler is a Metropolis with a joint proposal
of all parameters.</p>
</td></tr>
<tr><td><code>acceptance.w</code></td>
<td>
<p>if this is a non-predictive process model and
<code>amcmc</code> is used then this will be a matrix of the Metropolis sampler acceptance rate for each location's spatial random effect. </p>
</td></tr>
<tr><td><code>acceptance.w.knots</code></td>
<td>
<p>if this is a <em>predictive process</em> model and <code>amcmc</code> is used then this will be a matrix of
the Metropolis sampler acceptance rate for each knot's spatial random effect. </p>
</td></tr>
<tr><td><code>p.w.knots.samples</code></td>
<td>
<p>a matrix that holds samples from the posterior
distribution of the knots' spatial random effects. The rows of this matrix
correspond to the <code class="reqn">q\times m</code> knot locations and the columns are the
posterior samples. This is only returned if a <em>predictive process</em> model
is used.</p>
</td></tr>
<tr><td><code>p.w.samples</code></td>
<td>
<p>a matrix that holds samples from the posterior
distribution of the locations' spatial random effects. The rows of this matrix
correspond to the <code class="reqn">q\times n</code> point observations and the columns are the
posterior samples. </p>
</td></tr>
</table>
<p>The return object might include additional data used for subsequent
prediction and/or model fit evaluation.
</p>


<h3>Author(s)</h3>

<p>Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>, <br />
Sudipto Banerjee <a href="mailto:baner009@umn.edu">baner009@umn.edu</a>
</p>


<h3>References</h3>

<p>Finley, A.O., S. Banerjee, and R.E. McRoberts. (2008) A Bayesian
approach to quantifying uncertainty in multi-source forest area
estimates. <em>Environmental and Ecological Statistics</em>,
15:241&ndash;258.
</p>
<p>Banerjee, S., A.E. Gelfand, A.O. Finley, and H. Sang. (2008) Gaussian
Predictive Process Models for Large Spatial Datasets. <em>Journal of
the Royal Statistical Society Series B</em>, 70:825&ndash;848.
</p>
<p>Finley, A.O., H. Sang, S. Banerjee, and A.E. Gelfand. (2009) Improving the performance of predictive process modeling for large datasets. <em>Computational Statistics and Data Analysis</em>, 53:2873-2884.
</p>
<p>Finley, A.O., S. Banerjee, and A.E. Gelfand. (2015) spBayes for large
univariate and multivariate point-referenced spatio-temporal data
models. <em>Journal of Statistical Software</em>, 63:1&ndash;28. <a href="https://www.jstatsoft.org/article/view/v063i13">https://www.jstatsoft.org/article/view/v063i13</a>.
</p>
<p>Banerjee, S., Carlin, B.P., and Gelfand, A.E. (2004). Hierarchical modeling and analysis for spatial data. Chapman and Hall/CRC Press, Boca Raton, Fla.
</p>
<p>Roberts G.O. and Rosenthal J.S. (2006) Examples of Adaptive MCMC. <a href="http://probability.ca/jeff/ftpdir/adaptex.pdf">http://probability.ca/jeff/ftpdir/adaptex.pdf</a> Preprint. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spGLM">spGLM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(MBA)

##Some useful functions
rmvn &lt;- function(n, mu=0, V = matrix(1)){
  p &lt;- length(mu)
  if(any(is.na(match(dim(V),p)))){stop("Dimension problem!")}
  D &lt;- chol(V)
  t(matrix(rnorm(n*p), ncol=p)%*%D + rep(mu,rep(n,p)))
}

set.seed(1)

##Generate some data
n &lt;- 25 ##number of locations
q &lt;- 2 ##number of outcomes at each location
nltr &lt;- q*(q+1)/2 ##number of triangular elements in the cross-covariance matrix

coords &lt;- cbind(runif(n,0,1), runif(n,0,1))

##Parameters for the bivariate spatial random effects
theta &lt;- rep(3/0.5,q)

A &lt;- matrix(0,q,q)
A[lower.tri(A,TRUE)] &lt;- c(1,-1,0.25)
K &lt;- A%*%t(A)

Psi &lt;- diag(0,q)

C &lt;- mkSpCov(coords, K, Psi, theta, cov.model="exponential")

w &lt;- rmvn(1, rep(0,nrow(C)), C)

w.1 &lt;- w[seq(1,length(w),q)]
w.2 &lt;- w[seq(2,length(w),q)]

##Covariate portion of the mean
x.1 &lt;- cbind(1, rnorm(n))
x.2 &lt;- cbind(1, rnorm(n))
x &lt;- mkMvX(list(x.1, x.2))

B.1 &lt;- c(1,-1)
B.2 &lt;- c(-1,1)
B &lt;- c(B.1, B.2)

weight &lt;- 10 ##i.e., trials 
p &lt;- 1/(1+exp(-(x%*%B+w)))
y &lt;- rbinom(n*q, size=rep(weight,n*q), prob=p)

y.1 &lt;- y[seq(1,length(y),q)]
y.2 &lt;- y[seq(2,length(y),q)]

##Call spMvLM
fit &lt;- glm((y/weight)~x-1, weights=rep(weight, n*q), family="binomial")
beta.starting &lt;- coefficients(fit)
beta.tuning &lt;- t(chol(vcov(fit)))

A.starting &lt;- diag(1,q)[lower.tri(diag(1,q), TRUE)]

n.batch &lt;- 100
batch.length &lt;- 50
n.samples &lt;- n.batch*batch.length

starting &lt;- list("beta"=beta.starting, "phi"=rep(3/0.5,q), "A"=A.starting, "w"=0)
tuning &lt;- list("beta"=beta.tuning, "phi"=rep(1,q), "A"=rep(0.1,length(A.starting)),
               "w"=0.5)
priors &lt;- list("beta.Flat", "phi.Unif"=list(rep(3/0.75,q), rep(3/0.25,q)),
               "K.IW"=list(q+1, diag(0.1,q)))

m.1 &lt;- spMvGLM(list(y.1~x.1-1, y.2~x.2-1),
               coords=coords, weights=matrix(weight,n,q),
               starting=starting, tuning=tuning, priors=priors,
               amcmc=list("n.batch"=n.batch,"batch.length"=batch.length,"accept.rate"=0.43),
               cov.model="exponential", n.report=25)

burn.in &lt;- 0.75*n.samples
sub.samps &lt;- burn.in:n.samples

print(summary(window(m.1$p.beta.theta.samples, start=burn.in))$quantiles[,c(3,1,5)])

beta.hat &lt;- t(m.1$p.beta.theta.samples[sub.samps,1:length(B)])
w.hat &lt;- m.1$p.w.samples[,sub.samps]

p.hat &lt;- 1/(1+exp(-(x%*%beta.hat+w.hat)))

y.hat &lt;- apply(p.hat, 2, function(x){rbinom(n*q, size=rep(weight, n*q), prob=p)})

y.hat.mu &lt;- apply(y.hat, 1, mean)

##Unstack to get each response variable fitted values
y.hat.mu.1 &lt;- y.hat.mu[seq(1,length(y.hat.mu),q)]
y.hat.mu.2 &lt;- y.hat.mu[seq(2,length(y.hat.mu),q)]

##Take a look
par(mfrow=c(2,2))
surf &lt;- mba.surf(cbind(coords,y.1),no.X=100, no.Y=100, extend=TRUE)$xyz.est
image(surf, main="Observed y.1 positive trials")
contour(surf, add=TRUE)
points(coords)
zlim &lt;- range(surf[["z"]], na.rm=TRUE)

surf &lt;- mba.surf(cbind(coords,y.hat.mu.1),no.X=100, no.Y=100, extend=TRUE)$xyz.est
image(surf, zlim=zlim, main="Fitted y.1 positive trials")
contour(surf, add=TRUE)
points(coords)

surf &lt;- mba.surf(cbind(coords,y.2),no.X=100, no.Y=100, extend=TRUE)$xyz.est
image(surf, main="Observed y.2 positive trials")
contour(surf, add=TRUE)
points(coords)
zlim &lt;- range(surf[["z"]], na.rm=TRUE)

surf &lt;- mba.surf(cbind(coords,y.hat.mu.2),no.X=100, no.Y=100, extend=TRUE)$xyz.est
image(surf, zlim=zlim, main="Fitted y.2 positive trials")
contour(surf, add=TRUE)
points(coords)

## End(Not run)
</code></pre>

<hr>
<h2 id='spMvLM'>Function for fitting multivariate Bayesian spatial regression models</h2><span id='topic+spMvLM'></span>

<h3>Description</h3>

<p>The function <code>spMvLM</code> fits Gaussian multivariate Bayesian
spatial regression models. Given a set of knots, <code>spMvLM</code> will
also fit a <em>predictive process</em> model (see references below).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spMvLM(formula, data = parent.frame(), coords, knots,
      starting, tuning, priors, cov.model,
      modified.pp = TRUE, amcmc, n.samples, 
      verbose=TRUE, n.report=100, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spMvLM_+3A_formula">formula</code></td>
<td>
<p>a list of <code class="reqn">q</code> symbolic regression model descriptions to be fit. See example below. </p>
</td></tr>
<tr><td><code id="spMvLM_+3A_data">data</code></td>
<td>
<p>an optional data frame containing the variables in the
model. If not found in <code>data</code>, the variables are taken from <code>environment(formula)</code>, typically the environment from which <code>spMvLM</code> is called.  </p>
</td></tr>
<tr><td><code id="spMvLM_+3A_coords">coords</code></td>
<td>
<p>an <code class="reqn">n \times 2</code> matrix of the observation coordinates in <code class="reqn">R^2</code> (e.g., easting and northing). </p>
</td></tr>
<tr><td><code id="spMvLM_+3A_knots">knots</code></td>
<td>
<p>either a <code class="reqn">m \times 2</code> matrix of the <em>predictive process</em> knot coordinates in <code class="reqn">R^2</code> (e.g., easting and northing) or a vector of length two or three with the first and second elements recording the  number of columns and rows in the desired knot grid. The third, optional, element sets the offset of the outermost knots from the extent of the <code>coords</code>. </p>
</td></tr>
<tr><td><code id="spMvLM_+3A_starting">starting</code></td>
<td>
<p>a list with tags corresponding to <code>beta</code>, <code>A</code>, <code>phi</code>, and <code>nu</code>. Depending on the specification of the non-spatial residual, tags are <code>L</code> or <code>Psi</code>
for a block diagonal or diagonal covariance matrix, respectively.
</p>
<p>The value portion of each tag is a vector
that holds the parameter's starting values and are of length
<code class="reqn">p</code> for <code>beta</code> (where <code class="reqn">p</code> is the total number of regression coefficients in the multivariate model), <code class="reqn">\frac{q(q+1)}{2}</code> for
<code>A</code> and <code>L</code>, and <code class="reqn">q</code> for <code>Psi</code>, <code>phi</code>, and <code>nu</code>.  Here,
<code>A</code> and <code>L</code> hold the lower-triangle elements in column major ordering of the Cholesky square root
of the spatial and non-spatial cross-covariance matrices,
respectively. </p>
</td></tr>
<tr><td><code id="spMvLM_+3A_tuning">tuning</code></td>
<td>
<p>a list with tags <code>A</code>, <code>phi</code>, and <code>nu</code>. Depending on the specification of
the non-spatial residual, tags are <code>L</code> or <code>Psi</code>
for a block diagonal or diagonal covariance matrix, respectively. The value portion of each tag defines the
variance of the Metropolis sampler Normal proposal distribution.  For <code>A</code> and <code>L</code>
the vectors are of length <code class="reqn">\frac{q(q+1)}{2}</code> and <code class="reqn">q</code> for <code>Psi</code>, <code>phi</code>, and <code>nu</code>.</p>
</td></tr>
<tr><td><code id="spMvLM_+3A_priors">priors</code></td>
<td>
<p>a list with tags <code>beta.flat</code>,
<code>beta.norm</code>, <code>K.iw</code>, <code>Psi.iw</code>, <code>Psi.ig</code>, <code>phi.unif</code>,
and <code>nu.unif</code>. If the regression coefficients, i.e., <code>beta</code> vector, are
assumed to follow a multivariate Normal distribution then pass the
hyperparameters as a list of length two with the first
and second elements corresponding to the mean vector and positive
definite covariance matrix, respectively. If <code>beta</code> is assumed flat then no arguments are passed. The default is a flat prior.
Use <code>Psi.iw</code> if the non-spatial residual covariance matrix is assumed block diagonal.  Otherwise if the non-spatial residual covariance matrix is assumed diagonal then each of the <code class="reqn">q</code> diagonal element are assumed to
follow an inverse-Gamma in which case use <code>Psi.ig</code>. The hyperparameters of the inverse-Wishart, i.e., for
cross-covariance matrices <code class="reqn">AA'</code> <code>K.iw</code>
and <code class="reqn">LL'</code> <code>Psi.iw</code>,  are
passed as a list of length two, with the first and second elements corresponding
to the <code class="reqn">df</code> and <code class="reqn">q\times q</code> <em>scale</em> matrix,
respectively. If <code>Psi.ig</code> is specified, the inverse-Gamma
hyperparameters of the diagonal variance elements are pass using a
list of length two with the first and second list elements consisting of
vectors of the <code class="reqn">q</code> <em>shape</em> and <em>scale</em> hyperparameters,
respectively. The hyperparameters of the Uniform <code>phi.unif</code>,
and <code>nu.unif</code> are also passed as a list of vectors with the first
and second list elements corresponding to the lower and upper
support, respectively. 
</p>
</td></tr>
<tr><td><code id="spMvLM_+3A_cov.model">cov.model</code></td>
<td>
<p>a quoted keyword that specifies the covariance
function used to model the spatial dependence structure among the
observations.  Supported covariance model key words are:
<code>"exponential"</code>, <code>"matern"</code>, <code>"spherical"</code>, and
<code>"gaussian"</code>.  See below for details.  </p>
</td></tr>
<tr><td><code id="spMvLM_+3A_modified.pp">modified.pp</code></td>
<td>
<p>a logical value indicating if the <em>modified
predictive process</em> should be used (see references below for
details). Note, if a predictive process model is not used (i.e., <code>knots</code> is not specified) then
this argument is ignored. </p>
</td></tr>
<tr><td><code id="spMvLM_+3A_amcmc">amcmc</code></td>
<td>
<p>a list with tags <code>n.batch</code>, <code>batch.length</code>, and
<code>accept.rate</code>. Specifying this argument invokes an adaptive MCMC
sampler see Roberts and Rosenthal (2007) for an explanation.</p>
</td></tr>
<tr><td><code id="spMvLM_+3A_n.samples">n.samples</code></td>
<td>
<p>the number of MCMC iterations. This argument is
ignored if <code>amcmc</code> is specified. </p>
</td></tr>
<tr><td><code id="spMvLM_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, model specification and progress of the
sampler is printed to the screen. Otherwise, nothing is printed to
the screen.  </p>
</td></tr>
<tr><td><code id="spMvLM_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report Metropolis acceptance and MCMC progress. </p>
</td></tr>  
<tr><td><code id="spMvLM_+3A_...">...</code></td>
<td>
<p>currently no additional arguments.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Model parameters can be fixed at their <code>starting</code> values by setting their
<code>tuning</code> values to zero.
</p>
<p>The <em>no nugget</em> model is specified by removing <code>Psi</code> and <code>L</code> from the <code>starting</code> list.
</p>


<h3>Value</h3>

<p>An object of class <code>spMvLM</code>, which is a list with the following
tags:
</p>
<table role = "presentation">
<tr><td><code>coords</code></td>
<td>
<p>the <code class="reqn">n \times 2</code> matrix specified by
<code>coords</code>.  </p>
</td></tr>
<tr><td><code>knot.coords</code></td>
<td>
<p>the <code class="reqn">m \times 2</code> matrix as specified by <code>knots</code>.  </p>
</td></tr>
<tr><td><code>p.theta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples for the defined
parameters. </p>
</td></tr>
<tr><td><code>acceptance</code></td>
<td>
<p>the Metropolis sampling
acceptance percent. Reported at <code>batch.length</code> or <code>n.report</code>
intervals for <code>amcmc</code> specified and non-specified, respectively</p>
</td></tr>
</table>
<p>The return object might include additional data used for subsequent
prediction and/or model fit evaluation.
</p>


<h3>Author(s)</h3>

<p>Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>, <br />
Sudipto Banerjee <a href="mailto:baner009@umn.edu">baner009@umn.edu</a>
</p>


<h3>References</h3>

<p>Banerjee, S., A.E. Gelfand, A.O. Finley, and H. Sang. (2008) Gaussian Predictive Process Models for Large Spatial Datasets. <em>Journal of the Royal Statistical Society Series B</em>, 70:825&ndash;848.
</p>
<p>Banerjee, S., Carlin, B.P., and Gelfand, A.E. (2004). Hierarchical modeling and analysis for spatial data. Chapman and Hall/CRC Press, Boca Raton, Fla.
</p>
<p>Finley, A.O., S. Banerjee, and A.E. Gelfand. (2015) spBayes for large
univariate and multivariate point-referenced spatio-temporal data
models. <em>Journal of Statistical Software</em>, 63:1&ndash;28. <a href="https://www.jstatsoft.org/article/view/v063i13">https://www.jstatsoft.org/article/view/v063i13</a>.
</p>
<p>Finley, A.O., H. Sang, S. Banerjee, and A.E. Gelfand. (2009) Improving the performance of predictive process modeling for large datasets. <em>Computational Statistics and Data Analysis</em>, 53:2873&ndash;2884.
</p>
<p>Finley, A.O., S. Banerjee, A.R. Ek, and R.E. McRoberts. (2008) Bayesian multivariate process modeling for prediction of forest attributes. <em>Journal of Agricultural, Biological, and Environmental Statistics</em>, 13:60&ndash;83.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spLM">spLM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
rmvn &lt;- function(n, mu=0, V = matrix(1)){
  p &lt;- length(mu)
  if(any(is.na(match(dim(V),p)))){stop("Dimension problem!")}
  D &lt;- chol(V)
  t(matrix(rnorm(n*p), ncol=p)%*%D + rep(mu,rep(n,p)))
}

set.seed(1)

##Generate some data
n &lt;- 25 ##number of locations
q &lt;- 2 ##number of outcomes at each location
nltr &lt;- q*(q+1)/2 ##number of triangular elements in the cross-covariance matrix

coords &lt;- cbind(runif(n,0,1), runif(n,0,1))

##Parameters for the bivariate spatial random effects
theta &lt;- rep(3/0.5,q)

A &lt;- matrix(0,q,q)
A[lower.tri(A,TRUE)] &lt;- c(1,-1,0.25)
K &lt;- A%*%t(A)

Psi &lt;- diag(0,q)

C &lt;- mkSpCov(coords, K, Psi, theta, cov.model="exponential")

w &lt;- rmvn(1, rep(0,nrow(C)), C)

w.1 &lt;- w[seq(1,length(w),q)]
w.2 &lt;- w[seq(2,length(w),q)]

##Covariate portion of the mean
x.1 &lt;- cbind(1, rnorm(n))
x.2 &lt;- cbind(1, rnorm(n))
x &lt;- mkMvX(list(x.1, x.2))

B.1 &lt;- c(1,-1)
B.2 &lt;- c(-1,1)
B &lt;- c(B.1, B.2)

Psi &lt;- diag(c(0.1, 0.5))

y &lt;- rnorm(n*q, x%*%B+w, diag(n)%x%Psi)

y.1 &lt;- y[seq(1,length(y),q)]
y.2 &lt;- y[seq(2,length(y),q)]

##Call spMvLM
A.starting &lt;- diag(1,q)[lower.tri(diag(1,q), TRUE)]
n.samples &lt;- 1000

starting &lt;- list("phi"=rep(3/0.5,q), "A"=A.starting, "Psi"=rep(1,q))
tuning &lt;- list("phi"=rep(1,q), "A"=rep(0.01,length(A.starting)), "Psi"=rep(0.01,q))
priors &lt;- list("beta.Flat", "phi.Unif"=list(rep(3/0.75,q), rep(3/0.25,q)),
               "K.IW"=list(q+1, diag(0.1,q)), "Psi.ig"=list(c(2,2), c(0.1,0.1)))

m.1 &lt;- spMvLM(list(y.1~x.1-1, y.2~x.2-1), 
               coords=coords, starting=starting, tuning=tuning, priors=priors,
               n.samples=n.samples, cov.model="exponential", n.report=100)

burn.in &lt;- 0.75*n.samples

m.1 &lt;- spRecover(m.1, start=burn.in)

round(summary(m.1$p.theta.recover.samples)$quantiles[,c(3,1,5)],2)
round(summary(m.1$p.beta.recover.samples)$quantiles[,c(3,1,5)],2)

m.1.w.hat &lt;- summary(mcmc(t(m.1$p.w.recover.samples)))$quantiles[,c(3,1,5)]
m.1.w.1.hat &lt;- m.1.w.hat[seq(1, nrow(m.1.w.hat), q),]
m.1.w.2.hat &lt;- m.1.w.hat[seq(2, nrow(m.1.w.hat), q),]

par(mfrow=c(1,2))
plot(w.1, m.1.w.1.hat[,1], xlab="Observed w.1", ylab="Fitted w.1",
     xlim=range(w), ylim=range(m.1.w.hat), main="Spatial random effects w.1")
arrows(w.1, m.1.w.1.hat[,1], w.1, m.1.w.1.hat[,2], length=0.02, angle=90)
arrows(w.1, m.1.w.1.hat[,1], w.1, m.1.w.1.hat[,3], length=0.02, angle=90)
lines(range(w), range(w))

plot(w.2, m.1.w.2.hat[,1], xlab="Observed w.2", ylab="Fitted w.2",
     xlim=range(w), ylim=range(m.1.w.hat), main="Spatial random effects w.2")
arrows(w.2, m.1.w.2.hat[,1], w.2, m.1.w.2.hat[,2], length=0.02, angle=90)
arrows(w.2, m.1.w.2.hat[,1], w.2, m.1.w.2.hat[,3], length=0.02, angle=90)
lines(range(w), range(w))

## End(Not run)
</code></pre>

<hr>
<h2 id='spPredict'>Function for new locations given a model object
</h2><span id='topic+spPredict'></span>

<h3>Description</h3>

<p>The function <code>spPredict</code> collects posterior predictive samples
for a set of new locations given a <code><a href="#topic+spLM">spLM</a></code>, <code><a href="#topic+spMvLM">spMvLM</a></code>,
<code><a href="#topic+spGLM">spGLM</a></code>, <code><a href="#topic+spMvGLM">spMvGLM</a></code>,
<code><a href="#topic+spMisalignLM">spMisalignLM</a></code>, <code><a href="#topic+spMisalignGLM">spMisalignGLM</a></code>,
<code><a href="#topic+bayesGeostatExact">bayesGeostatExact</a></code>, <code><a href="#topic+bayesLMConjugate">bayesLMConjugate</a></code> <code><a href="#topic+bayesLMRef">bayesLMRef</a></code> or <code><a href="#topic+spSVC">spSVC</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spPredict(sp.obj, pred.coords, pred.covars, joint=FALSE, start=1, end, thin=1,
          verbose=TRUE, n.report=100, n.omp.threads=1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spPredict_+3A_sp.obj">sp.obj</code></td>
<td>
<p>an object returned by <code><a href="#topic+spLM">spLM</a></code>, <code><a href="#topic+spMvLM">spMvLM</a></code>,
<code><a href="#topic+spGLM">spGLM</a></code>, <code><a href="#topic+spMvGLM">spMvGLM</a></code>,
<code><a href="#topic+spMisalignLM">spMisalignLM</a></code>, <code><a href="#topic+spMisalignGLM">spMisalignGLM</a></code>,
<code><a href="#topic+bayesGeostatExact">bayesGeostatExact</a></code>, <code><a href="#topic+bayesLMConjugate">bayesLMConjugate</a></code> or
<code><a href="#topic+bayesLMRef">bayesLMRef</a></code>. For <code><a href="#topic+spSVC">spSVC</a></code>, <code>sp.obj</code> is an object from <code><a href="#topic+spRecover">spRecover</a></code>. </p>
</td></tr>
<tr><td><code id="spPredict_+3A_pred.coords">pred.coords</code></td>
<td>
<p>for <code><a href="#topic+spLM">spLM</a></code>, <code><a href="#topic+spMvLM">spMvLM</a></code>,
<code><a href="#topic+spGLM">spGLM</a></code>, <code><a href="#topic+spMvGLM">spMvGLM</a></code>, and <code><a href="#topic+bayesGeostatExact">bayesGeostatExact</a></code> <code>pred.coords</code> is a <code class="reqn">n^{\ast} \times 2</code> matrix of <code class="reqn">n^{\ast}</code> prediction
location coordinates in <code class="reqn">R^2</code> (e.g., easting and northing).
For <code><a href="#topic+spMisalignLM">spMisalignLM</a></code> and
<code><a href="#topic+spMisalignGLM">spMisalignGLM</a></code> <code>pred.coords</code> is a list of <code class="reqn">q</code> <code class="reqn">n^{\ast}_i \times 2</code>
matrices of prediction location coordinates where
<code class="reqn">i=(1,2,\ldots,q)</code>. For <code><a href="#topic+spSVC">spSVC</a></code>
<code>pred.coords</code> is an <code class="reqn">n^{\ast} \times m</code> matrix of <code class="reqn">n^{\ast}</code> prediction
location coordinates in <code class="reqn">R^m</code>.</p>
</td></tr>
<tr><td><code id="spPredict_+3A_pred.covars">pred.covars</code></td>
<td>
<p>for <code><a href="#topic+spLM">spLM</a></code>, <code><a href="#topic+spMvLM">spMvLM</a></code>,
<code><a href="#topic+spGLM">spGLM</a></code>, <code><a href="#topic+spMvGLM">spMvGLM</a></code>,
<code><a href="#topic+bayesGeostatExact">bayesGeostatExact</a></code>, <code><a href="#topic+bayesLMConjugate">bayesLMConjugate</a></code>,
<code><a href="#topic+bayesLMRef">bayesLMRef</a></code>, and <code><a href="#topic+spSVC">spSVC</a></code> <code>pred.covars</code> is a <code class="reqn">n^{\ast} \times p</code> design matrix associated
with the new locations (including the intercept if one is specified
in <code>sp.obj</code>'s formula argument).  If this is a multivariate prediction defined
by <code class="reqn">q</code> models, i.e., for <code><a href="#topic+spMvLM">spMvLM</a></code> or <code><a href="#topic+spMvGLM">spMvGLM</a></code>, the multivariate design matrix can be created
by passing a list of the <code class="reqn">q</code> univariate design matrices to
the <code><a href="#topic+mkMvX">mkMvX</a></code> function.  For <code><a href="#topic+spMisalignLM">spMisalignLM</a></code> and
<code><a href="#topic+spMisalignGLM">spMisalignGLM</a></code> <code>pred.covars</code> is a list of <code class="reqn">q</code> <code class="reqn">n^{\ast}_i \times p_i</code>
design matrices where <code class="reqn">i=(1,2,\ldots,q)</code></p>
</td></tr>
<tr><td><code id="spPredict_+3A_joint">joint</code></td>
<td>
<p>specifies whether posterior samples should be drawn
from the joint or point-wise predictive distribution. This argument is only
implemented for <code><a href="#topic+spSVC">spSVC</a></code>. Prediction for all other models
uses the point-wise posterior predictive distribution.</p>
</td></tr>
<tr><td><code id="spPredict_+3A_start">start</code></td>
<td>
<p>specifies the first sample included in the composition sampling.</p>
</td></tr>
<tr><td><code id="spPredict_+3A_end">end</code></td>
<td>
<p>specifies the last sample included in the composition.
The default is to use all posterior samples in <code>sp.obj</code>. </p>
</td></tr>
<tr><td><code id="spPredict_+3A_thin">thin</code></td>
<td>
<p>a sample thinning factor.  The default of 1 considers all
samples between <code>start</code> and <code>end</code>.  For example, if <code>thin = 10</code> then 1 in 10 samples are considered between <code>start</code> and
<code>end</code>. </p>
</td></tr>
<tr><td><code id="spPredict_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, model specification and progress of the
sampler is printed to the screen. Otherwise, nothing is printed to
the screen.  </p>
</td></tr>
<tr><td><code id="spPredict_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report sampling progress. </p>
</td></tr>  
<tr><td><code id="spPredict_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating
the number of threads to use for SMP parallel processing. The package must
be compiled for OpenMP support. For most Intel-based machines, we
recommend setting <code>n.omp.threads</code> up to the number of
hyperthreaded cores. This argument is only
implemented for <code><a href="#topic+spSVC">spSVC</a></code>.</p>
</td></tr>
<tr><td><code id="spPredict_+3A_...">...</code></td>
<td>
<p>currently no additional arguments.  </p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>p.y.predictive.samples</code></td>
<td>
<p>a matrix that holds the response variable(s) posterior
predictive samples. For multivariate models <code><a href="#topic+spMvLM">spMvLM</a></code> or
<code><a href="#topic+spMvGLM">spMvGLM</a></code> the rows of this matrix
correspond to the predicted locations and the columns are the posterior
predictive samples.  If prediction is for <code class="reqn">q</code> response
variables the <code>p.y.predictive.samples</code> matrix has
<code class="reqn">qn^{\ast}</code> rows, where <code class="reqn">n^{\ast}</code> is the number of
prediction locations.  The predictions for locations are held in rows
<code class="reqn">1:q, (q+1):2q, \ldots, ((n^{\ast}-1)q+1):qn^{\ast}</code> (i.e., the samples for the first location's <code class="reqn">q</code>
response variables are in rows <code class="reqn">1:q</code>, second location in rows <code class="reqn">(q+1):2q</code>,
etc.).
</p>
<p>For <code><a href="#topic+spMisalignLM">spMisalignLM</a></code> and <code><a href="#topic+spMisalignGLM">spMisalignGLM</a></code>
the posterior predictive samples are organized differently in
<code>p.y.predictive.samples</code> with the first response variable
<code class="reqn">n^{\ast}_1</code> locations held in rows <code class="reqn">1\ldots,n^{\ast}_1</code> rows, then the
next response variable samples held in the
<code class="reqn">(n^{\ast}_1+1),\ldots,(n^{\ast}_1+n^{\ast}_2)</code>, etc.
</p>
<p>For <code><a href="#topic+spSVC">spSVC</a></code> given the <code class="reqn">r</code> space-varying
coefficients, <code>p.y.predictive.samples</code> has
<code class="reqn">rn^{\ast}</code> rows and the columns are the posterior
predictive samples. The predictions for coefficient are held in rows
<code class="reqn">1:r, (r+1):2r, \ldots, ((n^{\ast}-1)r+1):rn^{\ast}</code> (i.e., the samples for the first location's
<code class="reqn">r</code> regression coefficients are in rows 1:r, second location in rows <code class="reqn">(r+1):2r</code>,
etc.).
</p>
<p>For <code><a href="#topic+spGLM">spGLM</a></code> and <code><a href="#topic+spMisalignGLM">spMisalignGLM</a></code> the <code>p.y.predictive.samples</code> matrix holds
posterior predictive samples <code class="reqn">\frac{1}{1+\exp(-x(s)'\beta-w(s))}</code> and
<code class="reqn">\exp(x(s)'\beta+w(s))</code> for
<code>family</code> binomial and poisson, respectively. Here <code class="reqn">s</code> indexes
the prediction location, <code class="reqn">\beta</code> is the vector of regression
coefficients, and <code class="reqn">w</code> is the associated spatial random
spatial effect. These values can be fed directly into <code>rbinom</code>
or <code>rpois</code> to generate the realization from the respective
distribution. </p>
</td></tr>
<tr><td><code>p.w.predictive.samples</code></td>
<td>
<p>a matrix organized the same as
<code>p.y.predictive.samples</code>, that holds the spatial random effects posterior
predictive samples. </p>
</td></tr>
<tr><td><code>p.w.predictive.samples.list</code></td>
<td>
<p>only returned for
<code><a href="#topic+spSVC">spSVC</a></code>. This provides <code>p.w.predictive.samples</code> in a
different (more convenient form). Elements in this list hold
samples for each of the <code class="reqn">r</code> coefficients. List element names
indicate either the coefficient index or name specified in
<code><a href="#topic+spSVC">spSVC</a></code>'s <code>svc.cols</code> argument. The sample matrices
are <code class="reqn">n^{\ast}</code> rows and predictive samples along the columns. </p>
</td></tr>
<tr><td><code>p.tilde.beta.predictive.samples.list</code></td>
<td>
<p>only returned for
<code><a href="#topic+spSVC">spSVC</a></code>. Like <code>p.w.predictive.samples.list</code> but with
the addition of the corresponding <code class="reqn">\beta</code> posterior
samples (i.e., <code class="reqn">\beta+w(s)</code>). </p>
</td></tr>
<tr><td><code>center.scale.pred.covars</code></td>
<td>
<p>only returned for the
<code><a href="#topic+spSVC">spSVC</a></code> when its <code>center.scale</code> argument is <code>TRUE</code>. This is the
prediction design matrix centered and scaled with respect to column means and variances of the design matrix used to estimate model
parameters, i.e., the one defined in <code><a href="#topic+spSVC">spSVC</a></code>'s formula argument.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>, <br />
Sudipto Banerjee <a href="mailto:sudipto@ucla.edu">sudipto@ucla.edu</a>
</p>


<h3>References</h3>

<p>Banerjee, S., Carlin, B.P., and Gelfand, A.E. (2004). Hierarchical
modeling and analysis for spatial data. Chapman and Hall/CRC Press,
Boca Raton, FL.
</p>
<p>Finley, A.O., S. Banerjee, and A.E. Gelfand. (2015) spBayes for large
univariate and multivariate point-referenced spatio-temporal data
models. <em>Journal of Statistical Software</em>,
63:1&ndash;28. <a href="https://www.jstatsoft.org/article/view/v063i13">https://www.jstatsoft.org/article/view/v063i13</a>.
</p>
<p>Finley, A.O. and S. Banerjee (2019) Bayesian spatially varying
coefficient models in the spBayes R package. <a href="https://arxiv.org/abs/1903.03028">https://arxiv.org/abs/1903.03028</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
rmvn &lt;- function(n, mu=0, V = matrix(1)){
  p &lt;- length(mu)
  if(any(is.na(match(dim(V),p))))
    stop("Dimension problem!")
  D &lt;- chol(V)
  t(matrix(rnorm(n*p), ncol=p)%*%D + rep(mu,rep(n,p)))
}

set.seed(1)

n &lt;- 200
coords &lt;- cbind(runif(n,0,1), runif(n,0,1))
X &lt;- as.matrix(cbind(1, rnorm(n)))

B &lt;- as.matrix(c(1,5))
p &lt;- length(B)
sigma.sq &lt;- 10
tau.sq &lt;- 0.01
phi &lt;- 3/0.5

D &lt;- as.matrix(dist(coords))
R &lt;- exp(-phi*D)
w &lt;- rmvn(1, rep(0,n), sigma.sq*R)
y &lt;- rnorm(n, X%*%B + w, sqrt(tau.sq))

##partition the data for out of sample prediction
mod &lt;- 1:100
y.mod &lt;- y[mod]
X.mod &lt;- X[mod,]
coords.mod &lt;- coords[mod,]

n.samples &lt;- 1000

starting &lt;- list("phi"=3/0.5, "sigma.sq"=50, "tau.sq"=1)
tuning &lt;- list("phi"=0.1, "sigma.sq"=0.1, "tau.sq"=0.1)
priors &lt;- list("beta.Flat", "phi.Unif"=c(3/1, 3/0.1),
               "sigma.sq.IG"=c(2, 5), "tau.sq.IG"=c(2, 0.01))
cov.model &lt;- "exponential"

m.1 &lt;- spLM(y.mod~X.mod-1, coords=coords.mod, starting=starting, tuning=tuning,
priors=priors, cov.model=cov.model, n.samples=n.samples)

m.1.pred &lt;- spPredict(m.1, pred.covars=X, pred.coords=coords,
start=0.5*n.samples)

y.hat &lt;- apply(m.1.pred$p.y.predictive.samples, 1, mean)

quant &lt;- function(x){quantile(x, prob=c(0.025, 0.5, 0.975))}

y.hat &lt;- apply(m.1.pred$p.y.predictive.samples, 1, quant)

plot(y, y.hat[2,], pch=19, cex=0.5, xlab="observed y", ylab="predicted y")
arrows(y[-mod], y.hat[2,-mod], y[-mod], y.hat[1,-mod], angle=90, length=0.05)
arrows(y[-mod], y.hat[2,-mod], y[-mod], y.hat[3,-mod], angle=90, length=0.05)

## End(Not run)
</code></pre>

<hr>
<h2 id='spRecover'>Function for recovering regression coefficients and spatial
random effects for <code><a href="#topic+spLM">spLM</a></code>, <code><a href="#topic+spMvLM">spMvLM</a></code>,
<code><a href="#topic+spMisalignLM">spMisalignLM</a></code>, <code><a href="#topic+spSVC">spSVC</a></code> using composition sampling
</h2><span id='topic+spRecover'></span>

<h3>Description</h3>

<p>Function for recovering regression coefficients and spatial random
effects for <code><a href="#topic+spLM">spLM</a></code>, <code><a href="#topic+spMvLM">spMvLM</a></code>, and
<code><a href="#topic+spMisalignLM">spMisalignLM</a></code> using composition sampling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spRecover(sp.obj, get.beta=TRUE, get.w=TRUE, start=1, end, thin=1,
          verbose=TRUE, n.report=100, n.omp.threads=1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spRecover_+3A_sp.obj">sp.obj</code></td>
<td>
<p>an object returned by <code><a href="#topic+spLM">spLM</a></code>,
<code><a href="#topic+spMvLM">spMvLM</a></code>, <code><a href="#topic+spMisalignLM">spMisalignLM</a></code>, or <code><a href="#topic+spSVC">spSVC</a></code>.</p>
</td></tr>
<tr><td><code id="spRecover_+3A_get.beta">get.beta</code></td>
<td>
<p>if <code>TRUE</code>, regression coefficients will be recovered.</p>
</td></tr>
<tr><td><code id="spRecover_+3A_get.w">get.w</code></td>
<td>
<p>if <code>TRUE</code>, spatial random effects will be recovered.</p>
</td></tr>
<tr><td><code id="spRecover_+3A_start">start</code></td>
<td>
<p>specifies the first sample included in the composition sampling.</p>
</td></tr>
<tr><td><code id="spRecover_+3A_end">end</code></td>
<td>
<p>specifies the last sample included in the composition.
The default is to use all posterior samples in <code>sp.obj</code>. </p>
</td></tr>
<tr><td><code id="spRecover_+3A_thin">thin</code></td>
<td>
<p>a sample thinning factor.  The default of 1 considers all
samples between <code>start</code> and <code>end</code>.  For example, if <code>thin = 10</code> then 1 in 10 samples are considered between <code>start</code> and
<code>end</code>. </p>
</td></tr>
<tr><td><code id="spRecover_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, model specification and progress of the
sampler is printed to the screen. Otherwise, nothing is printed to
the screen.  </p>
</td></tr>
<tr><td><code id="spRecover_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report sampling progress. </p>
</td></tr>
<tr><td><code id="spRecover_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating
the number of threads to use for SMP parallel processing. The package must
be compiled for OpenMP support. For most Intel-based machines, we
recommend setting <code>n.omp.threads</code> up to the number of
hyperthreaded cores. This argument is only
implemented for <code><a href="#topic+spSVC">spSVC</a></code>.</p>
</td></tr>
<tr><td><code id="spRecover_+3A_...">...</code></td>
<td>
<p>currently no additional arguments.  </p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input <code>sp.obj</code> with posterior samples of regression coefficients and/or spatial random effects appended. 
tags:
</p>
<table role = "presentation">
<tr><td><code>p.theta.recover.samples</code></td>
<td>
<p>those <code>p.theta.samples</code> used in the composition sampling. </p>
</td></tr>
<tr><td><code>p.beta.recover.samples</code></td>
<td>
<p>a <code>coda</code> object of regression coefficients posterior samples. </p>
</td></tr>
<tr><td><code>p.w.recover.samples</code></td>
<td>
<p>a <code>coda</code> object of spatial random
effects posterior samples. Rows correspond to locations' random
effects and columns are posterior samples. Given <code class="reqn">q</code> responses, the <code>p.w.recover.samples</code> matrix
for <code><a href="#topic+spMvLM">spMvLM</a></code> has <code class="reqn">qn</code> rows. The recovered
random effects for locations are held in rows
<code class="reqn">1:q, (q+1):2q, \ldots, ((n-1)q+1):qn</code> (i.e., the samples for the first location's <code class="reqn">q</code>
response variables are in rows 1:q, second location in rows <code class="reqn">(q+1):2q</code>,
etc.).
</p>
<p>For <code><a href="#topic+spSVC">spSVC</a></code> given the <code class="reqn">r</code> space-varying
coefficients, <code>p.w.recover.samples</code> has
<code class="reqn">rn</code> rows. The recovered
random effects for locations are held in rows
<code class="reqn">1:r, (r+1):2r, \ldots, ((n-1)r+1):rn</code> (i.e., the samples for the first location's
<code class="reqn">r</code> regression coefficients are in rows 1:r, second location in rows <code class="reqn">(r+1):2r</code>,
etc.).</p>
</td></tr>
<tr><td><code>p.w.recover.samples.list</code></td>
<td>
<p>only returned for
<code><a href="#topic+spSVC">spSVC</a></code>. This provides <code>p.w.recover.samples</code> in a
different (more convenient form). Elements in this list hold
samples for each of the <code class="reqn">r</code> coefficients. List element names
indicate either the coefficient index or name specified in
<code><a href="#topic+spSVC">spSVC</a></code>'s <code>svc.cols</code> argument. The sample matrices
are <code class="reqn">n</code> rows and predictive samples along the columns. </p>
</td></tr>
<tr><td><code>p.tilde.beta.recover.samples.list</code></td>
<td>
<p>only returned for
<code><a href="#topic+spSVC">spSVC</a></code>. Like <code>p.w.recover.samples.list</code> but with
the addition of the corresponding <code class="reqn">\beta</code> posterior
samples (i.e., <code class="reqn">\beta+w(s)</code>). </p>
</td></tr>
<tr><td><code>p.y.samples</code></td>
<td>
<p>only returned for
<code><a href="#topic+spSVC">spSVC</a></code>. These posterior are the fitted values with locations on
the rows and samples on the columns. For a given sample the fitted
value for the <code class="reqn">i^{th}</code> location is <code class="reqn">N(x(s_i)\beta +
    z(s_i)w(s_i), \tau^2)</code>. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>, <br />
Sudipto Banerjee <a href="mailto:sudipto@ucla.edu">sudipto@ucla.edu</a>
</p>


<h3>References</h3>

<p>Banerjee, S., Carlin, B.P., and Gelfand, A.E. (2004). Hierarchical
modeling and analysis for spatial data. Chapman and Hall/CRC Press,
Boca Raton, FL.
</p>
<p>Finley, A.O., S. Banerjee, and A.E. Gelfand. (2015) spBayes for large
univariate and multivariate point-referenced spatio-temporal data
models. <em>Journal of Statistical Software</em>,
63:1&ndash;28. <a href="https://www.jstatsoft.org/article/view/v063i13">https://www.jstatsoft.org/article/view/v063i13</a>.
</p>
<p>Finley, A.O. and S. Banerjee (2019) Bayesian spatially varying
coefficient models in the spBayes R package. <a href="https://arxiv.org/abs/1903.03028">https://arxiv.org/abs/1903.03028</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
rmvn &lt;- function(n, mu=0, V = matrix(1)){
  p &lt;- length(mu)
  if(any(is.na(match(dim(V),p))))
    stop("Dimension problem!")
  D &lt;- chol(V)
  t(matrix(rnorm(n*p), ncol=p)%*%D + rep(mu,rep(n,p)))
}

set.seed(1)

n &lt;- 50
coords &lt;- cbind(runif(n,0,1), runif(n,0,1))
X &lt;- as.matrix(cbind(1, rnorm(n)))

B &lt;- as.matrix(c(1,5))
p &lt;- length(B)
sigma.sq &lt;- 10
tau.sq &lt;- 0.01
phi &lt;- 3/0.5

D &lt;- as.matrix(dist(coords))
R &lt;- exp(-phi*D)
w &lt;- rmvn(1, rep(0,n), sigma.sq*R)
y &lt;- rnorm(n, X%*%B + w, sqrt(tau.sq))

n.samples &lt;- 1000

starting &lt;- list("phi"=3/0.5, "sigma.sq"=50, "tau.sq"=1)
tuning &lt;- list("phi"=0.1, "sigma.sq"=0.1, "tau.sq"=0.1)
priors &lt;- list("beta.Flat", "phi.Unif"=c(3/1, 3/0.1),
               "sigma.sq.IG"=c(2, 5), "tau.sq.IG"=c(2, 0.01))
cov.model &lt;- "exponential"

m.1 &lt;- spLM(y~X-1, coords=coords, starting=starting, tuning=tuning,
            priors=priors, cov.model=cov.model, n.samples=n.samples)

m.1 &lt;- spRecover(m.1, start=0.5*n.samples, thin=2)

summary(window(m.1$p.beta.recover.samples))

w.hat &lt;- apply(m.1$p.w.recover.samples, 1, mean)
plot(w, w.hat, xlab="Observed w", ylab="Fitted w")

## End(Not run)
</code></pre>

<hr>
<h2 id='spSVC'>Function for fitting univariate Bayesian spatially-varying
coefficient regression models</h2><span id='topic+spSVC'></span>

<h3>Description</h3>

<p>The function <code>spSVC</code> fits Gaussian univariate Bayesian spatially-varying
coefficient regression models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spSVC(formula, data = parent.frame(), svc.cols=1, coords, 
      priors, starting, tuning, cov.model, center.scale=FALSE,
      amcmc, n.samples, n.omp.threads = 1,
      verbose=TRUE, n.report=100, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spSVC_+3A_formula">formula</code></td>
<td>
<p>a symbolic description of the regression model to be
fit. See example below. </p>
</td></tr>
<tr><td><code id="spSVC_+3A_data">data</code></td>
<td>
<p>an optional data frame containing the variables in the
model. If not found in data, the variables are taken from
<code>environment(formula)</code>, typically the environment from which
<code>spSVC</code> is called. </p>
</td></tr>
<tr><td><code id="spSVC_+3A_svc.cols">svc.cols</code></td>
<td>
<p>a vector indicating which columns of the regression
design matrix <code class="reqn">X</code> should be space-varying. <code>svc.cols</code> can
be an integer vector with values indicating <code class="reqn">X</code> columns or a
character vector with values corresponding to <code class="reqn">X</code> column
names. <code>svc.cols</code> default argument
of 1 results in a space-varying intercept model (assuming an intercept
is specified in the first column of the design matrix).</p>
</td></tr>
<tr><td><code id="spSVC_+3A_coords">coords</code></td>
<td>
<p>an <code class="reqn">n \times m</code> matrix of the observation coordinates
in <code class="reqn">R^m</code> (e.g., <code class="reqn">R^2</code> might be easting and northing). </p>
</td></tr>
<tr><td><code id="spSVC_+3A_priors">priors</code></td>
<td>
<p>a list with each tag corresponding to a
parameter name. Valid tags are <code>sigma.sq.ig</code>, <code>k.iw</code>,
<code>tau.sq.ig</code>, <code>phi.unif</code>, <code>nu.unif</code>,
<code>beta.norm</code>, and <code>beta.flat</code>. Scalar variance parameters <code>simga.sq</code> and
<code>tau.sq</code> are assumed to follow an
inverse-Gamma distribution. Cross-covariance matrix parameter <code>K</code> is
assumed to follow an inverse-Wishart. The spatial decay <code>phi</code>
and smoothness <code>nu</code> parameters are assumed to follow Uniform
distributions. The regression coefficient priors can be either flat
or multivariate Normal. 
</p>
<p>There are two specification for the Gaussian Process (GP) on the <code>svc.cols</code> columns: 1)
univariate GPs on each column; 2) multivariate GP on the <code class="reqn">r</code>
columns (i.e., where <code class="reqn">r</code> equals <code>length(svc.cols)</code>). If
univariate GPs are desired, specify <code>sigma.sq.ig</code> as a
list of length two with the first and second elements corresponding
to the length <code class="reqn">r</code> <em>shape</em> and <em>scale</em>
hyperparameter vectors,
respectively. If a multivariate GP is desired, specify <code>k.iw</code>
as a list of length two with the first and second elements corresponding
to the degrees-of-freedom <code class="reqn">df</code> and <code class="reqn">r\times r</code> <em>scale</em> matrix,
respectively. This inverse-Wishart prior is on the <code class="reqn">r\times r</code> multivariate GP
cross-covariance matrix defined as <code class="reqn">K=AA'</code> where <code class="reqn">A</code> is the
lower-triangle Cholesky square root of <code class="reqn">K</code>.
</p>
<p>If the regression coefficients, i.e., <code>beta</code>
vector, are assumed to follow a multivariate Normal distribution then pass the
hyperparameters as a list of length two with the first
and second elements corresponding to the mean vector and positive
definite covariance matrix, respectively. If
<code>beta</code> is assumed flat then no arguments are passed. The default
is a flat prior. Similarly, <code>phi</code>
and <code>nu</code> are specified as lists of length two with
the first and second elements holding vectors of length <code class="reqn">r</code> lower
and upper bounds of the Uniforms' support, respectively.</p>
</td></tr>
<tr><td><code id="spSVC_+3A_starting">starting</code></td>
<td>
<p>a list with each tag corresponding to a
parameter name. Valid tags are <code>beta</code>, <code>sigma.sq</code>, <code>A</code>,
<code>tau.sq</code>, <code>phi</code>, and <code>nu</code>.  The value portion of each
tag is the parameter's starting value(s). Starting values must be
set for the <code class="reqn">r</code> univariate or multivariate GP <code>phi</code> and
<code>nu</code>. For univariate GPs <code>sigma.sq.ig</code> is
specified as a vector of length <code class="reqn">r</code> and for a multivariate GP <code>A</code> is specified as a vector of 
<code class="reqn">r\times(r+1)/2</code> that gives the lower-triangle elements in column major ordering of the Cholesky square root
of the cross-covaraince matrix <code class="reqn">K=AA'</code>. <code>tau.sq</code> is
a single value. See Finley and Banerjee (2019) for more details.</p>
</td></tr>
<tr><td><code id="spSVC_+3A_tuning">tuning</code></td>
<td>
<p>a list with each tag corresponding to a
parameter name. Valid tags are <code>sigma.sq</code>, <code>A</code>,
<code>tau.sq</code>, <code>phi</code>, and <code>nu</code>. The value portion of each
tag defines the variance of the Metropolis sampler Normal proposal
distribution. For <code>sigma.sq</code>, <code>phi</code>, and <code>nu</code> the
tuning value vectors are of length <code class="reqn">r</code> and <code>A</code> is of
length <code class="reqn">r\times(r+1)/2</code>. <code>tuning</code> vector elements correspond to <code>starting</code> vector elements. <code>tau.sq</code> is
a single value.</p>
</td></tr>
<tr><td><code id="spSVC_+3A_cov.model">cov.model</code></td>
<td>
<p>a quoted keyword that specifies the covariance
function used to model the spatial dependence structure among the
observations.  Supported covariance model key words are:
<code>"exponential"</code>, <code>"matern"</code>, <code>"spherical"</code>, and
<code>"gaussian"</code>.  See below for details.</p>
</td></tr>
<tr><td><code id="spSVC_+3A_center.scale">center.scale</code></td>
<td>
<p>if <code>TRUE</code>, non-constant columns of <code class="reqn">X</code>
are centered on zero and scaled to have variance one. If
<code>spPredict</code> is subsequently called this centering and scaling
is applied to <code>pred.covars</code>. </p>
</td></tr>
<tr><td><code id="spSVC_+3A_amcmc">amcmc</code></td>
<td>
<p>a list with tags <code>n.batch</code>, <code>batch.length</code>, and
<code>accept.rate</code>. Specifying this argument invokes an adaptive MCMC
sampler, see Roberts and Rosenthal (2007) for an explanation.</p>
</td></tr>
<tr><td><code id="spSVC_+3A_n.samples">n.samples</code></td>
<td>
<p>the number of MCMC iterations. This argument is
ignored if <code>amcmc</code> is specified.</p>
</td></tr>
<tr><td><code id="spSVC_+3A_n.omp.threads">n.omp.threads</code></td>
<td>
<p>a positive integer indicating
the number of threads to use for SMP parallel processing. The package must
be compiled for OpenMP support. For most Intel-based machines, we
recommend setting <code>n.omp.threads</code> up to the number of
hyperthreaded cores.</p>
</td></tr>
<tr><td><code id="spSVC_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, model specification and progress of the
sampler is printed to the screen. Otherwise, nothing is printed to
the screen.</p>
</td></tr>
<tr><td><code id="spSVC_+3A_n.report">n.report</code></td>
<td>
<p>the interval to report Metropolis sampler acceptance
and MCMC progress.</p>
</td></tr>  
<tr><td><code id="spSVC_+3A_...">...</code></td>
<td>
<p>currently no additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Model parameters can be fixed at their <code>starting</code> values by setting their
<code>tuning</code> values to zero.
</p>
<p>The <em>no nugget</em> model is specified by removing <code>tau.sq</code> from the <code>starting</code> list.
</p>


<h3>Value</h3>

<p>An object of class <code>spSVC</code>, which is a list comprising:
</p>
<table role = "presentation">
<tr><td><code>coords</code></td>
<td>
<p>the <code class="reqn">n \times m</code> matrix specified by
<code>coords</code>.  </p>
</td></tr>
<tr><td><code>p.theta.samples</code></td>
<td>
<p>a <code>coda</code> object of posterior samples for the defined
parameters. </p>
</td></tr>
<tr><td><code>acceptance</code></td>
<td>
<p>the Metropolis sampling
acceptance percent. Reported at <code>batch.length</code> or <code>n.report</code>
intervals for <code>amcmc</code> specified and non-specified, respectively.</p>
</td></tr>
</table>
<p>The return object will include additional objects used for subsequent
parameter recovery, prediction, and model fit evaluation using
<code><a href="#topic+spRecover">spRecover</a></code>, <code><a href="#topic+spPredict">spPredict</a></code>,
<code><a href="#topic+spDiag">spDiag</a></code>, respectively. 
</p>


<h3>Author(s)</h3>

<p>Andrew O. Finley <a href="mailto:finleya@msu.edu">finleya@msu.edu</a>, <br />
Sudipto Banerjee <a href="mailto:sudipto@ucla.edu">sudipto@ucla.edu</a>
</p>


<h3>References</h3>

<p>Finley, A.O., S. Banerjee, and A.E. Gelfand. (2015) spBayes for large
univariate and multivariate point-referenced spatio-temporal data
models. <em>Journal of Statistical Software</em>, 63:1&ndash;28. <a href="https://www.jstatsoft.org/article/view/v063i13">https://www.jstatsoft.org/article/view/v063i13</a>.
</p>
<p>Roberts G.O. and Rosenthal J.S. (2006). Examples of Adaptive MCMC. <a href="http://probability.ca/jeff/ftpdir/adaptex.pdf">http://probability.ca/jeff/ftpdir/adaptex.pdf</a>.
</p>
<p>Finley, A.O. and S. Banerjee (2019) Bayesian spatially varying
coefficient models in the spBayes R package. <a href="https://arxiv.org/abs/1903.03028">https://arxiv.org/abs/1903.03028</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spRecover">spRecover</a>, <a href="#topic+spDiag">spDiag</a>, <a href="#topic+spPredict">spPredict</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

library(Matrix)

rmvn &lt;- function(n, mu=0, V = matrix(1)){
  p &lt;- length(mu)
  if(any(is.na(match(dim(V),p))))
    stop("Dimension problem!")
  D &lt;- chol(V)
  t(matrix(rnorm(n*p), ncol=p)%*%D + rep(mu,rep(n,p)))
}


##Assume both columns of X are space-varying and the two GPs don't covary
set.seed(1)
n &lt;- 200
coords &lt;- cbind(runif(n,0,1), runif(n,0,1))

X &lt;- as.matrix(cbind(1, rnorm(n)))
colnames(X) &lt;- c("x.1", "x.2")

Z &lt;- t(bdiag(as.list(as.data.frame(t(X)))))

B &lt;- as.matrix(c(1,5))
p &lt;- length(B)

sigma.sq &lt;- c(1,5)
tau.sq &lt;- 1
phi &lt;- 3/0.5

D &lt;- as.matrix(dist(coords))

C &lt;- exp(-phi*D)%x%diag(sigma.sq)

w &lt;- rmvn(1, rep(0,p*n), C)

mu &lt;- as.vector(X%*%B + Z%*%w)

y &lt;- rnorm(n, mu, sqrt(tau.sq))

##fit a model to the simulated dat
starting &lt;- list("phi"=rep(3/0.5, p), "sigma.sq"=rep(1, p), "tau.sq"=1)

tuning &lt;- list("phi"=rep(0.1, p), "sigma.sq"=rep(0.1, p), "tau.sq"=0.1)

cov.model &lt;- "exponential"

priors &lt;- list("phi.Unif"=list(rep(3/2, p), rep(3/0.0001, p)),
               "sigma.sq.IG"=list(rep(2, p), rep(2, p)),
               "tau.sq.IG"=c(2, 1))

##fit model
n.samples &lt;- 2000

m.1 &lt;- spSVC(y~X-1, coords=coords, starting=starting, svc.cols=c(1,2),
             tuning=tuning, priors=priors, cov.model=cov.model,
             n.samples=n.samples, n.omp.threads=4)

plot(m.1$p.theta.samples, density=FALSE)

##recover posterior samples
m.1 &lt;- spRecover(m.1, start=floor(0.75*n.samples), thin=2, n.omp.threads=4)

summary(m.1$p.beta.recover.samples)
summary(m.1$p.theta.recover.samples)

##check fitted values
quant &lt;- function(x){quantile(x, prob=c(0.025, 0.5, 0.975))}

##fitted y
y.hat &lt;- apply(m.1$p.y.samples, 1, quant)

rng &lt;- c(-15, 20)
plot(y, y.hat[2,], pch=19, cex=0.5, xlab="Fitted y", ylab="Observed y",
     xlim=rng, ylim=rng)
arrows(y, y.hat[2,], y, y.hat[1,], angle=90, length=0.05)
arrows(y, y.hat[2,], y, y.hat[3,], angle=90, length=0.05)
lines(rng, rng, col="blue")

##recovered w
w.hat &lt;- apply(m.1$p.w.recover.samples, 1, quant)

w.1.indx &lt;- seq(1, p*n, p)
w.2.indx &lt;- seq(2, p*n, p)

par(mfrow=c(1,2))

rng &lt;- c(-5,5)
plot(w[w.1.indx], w.hat[2,w.1.indx], pch=19, cex=0.5, xlab="Fitted w.1", ylab="Observed w.1",
     xlim=rng, ylim=rng)
arrows(w[w.1.indx], w.hat[2,w.1.indx], w[w.1.indx], w.hat[1,w.1.indx], angle=90, length=0.05)
arrows(w[w.1.indx], w.hat[2,w.1.indx], w[w.1.indx], w.hat[3,w.1.indx], angle=90, length=0.05)
lines(rng, rng, col="blue")

rng &lt;- c(-10,10)
plot(w[w.2.indx], w.hat[2,w.2.indx], pch=19, cex=0.5, xlab="Fitted w.2", ylab="Observed w.2",
     xlim=rng, ylim=rng)
arrows(w[w.2.indx], w.hat[2,w.2.indx], w[w.2.indx], w.hat[1,w.2.indx], angle=90, length=0.05)
arrows(w[w.2.indx], w.hat[2,w.2.indx], w[w.2.indx], w.hat[3,w.2.indx], angle=90, length=0.05)
lines(rng, rng, col="blue")

## End(Not run)
</code></pre>

<hr>
<h2 id='SVCMvData.dat'>Synthetic data from a space-varying coefficients model</h2><span id='topic+SVCMvData.dat'></span>

<h3>Description</h3>

<p>Data simulated from a space-varying coefficients model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(SVCMvData.dat)
</code></pre>


<h3>Format</h3>

<p>The data frame generated from the code in the example section below.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
##The dataset was generated with the code below.

library(Matrix)

rmvn &lt;- function(n, mu=0, V = matrix(1)){
  p &lt;- length(mu)
  if(any(is.na(match(dim(V),p))))
    stop("Dimension problem!")
  D &lt;- chol(V)
  t(matrix(rnorm(n*p), ncol=p)%*%D + rep(mu,rep(n,p)))
}

set.seed(1)
n &lt;- 200

coords &lt;- cbind(runif(n,0,1), runif(n,0,1))
colnames(coords) &lt;- c("x.coords","y.coords")

X &lt;- as.matrix(cbind(1, rnorm(n), rnorm(n)))
colnames(X) &lt;- c("intercept","a","b")

Z &lt;- t(bdiag(as.list(as.data.frame(t(X)))))

beta &lt;- c(1, 10, -10)
p &lt;- length(beta)

q &lt;- 3
A &lt;- matrix(0, q, q)
A[lower.tri(A, T)] &lt;- c(1, -1, 0, 1, 1, 0.1)
K &lt;- A
K
cov2cor(K)

phi &lt;- c(3/0.75, 3/0.5, 3/0.5)

Psi &lt;- diag(0,q)
C &lt;- mkSpCov(coords, K, Psi, phi, cov.model="exponential")

tau.sq &lt;- 0.1

w &lt;- rmvn(1, rep(0,q*n), C)

y &lt;- rnorm(n, as.vector(X%*%beta + Z%*%w), sqrt(tau.sq))

w.0 &lt;- w[seq(1, length(w), by=q)]
w.a &lt;- w[seq(2, length(w), by=q)]
w.b &lt;- w[seq(3, length(w), by=q)]

SVCMvData &lt;- data.frame(cbind(coords, y, X[,2:3], w.0, w.a, w.b))


## End(Not run)
</code></pre>

<hr>
<h2 id='WEF.dat'>Western Experimental Forest inventory data</h2><span id='topic+WEF.dat'></span>

<h3>Description</h3>

<p>Data generated as part of a long-term research study on an experimental forest
in central Oregon.  This dataset holds the coordinates for all trees in the experimental forest. The typical stem measurements are recorded for each tree. Crown radius was measured at the cardinal directions for a subset of trees. Mean crown radius was calculated for all trees using a simple relationship between DBH, Height, and observed crown dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(WEF.dat)
</code></pre>


<h3>Format</h3>

<p>A data frame containing 2422 rows and 15 columns.
</p>

<hr>
<h2 id='Zurich.dat'>Zurichberg Forest inventory data</h2><span id='topic+Zurich.dat'></span>

<h3>Description</h3>

<p>Inventory data of the Zurichberg Forest,
Switzerland (see Mandallaz 2008 for details). These data are provided
with the kind authorization of the Forest Service of the Caton of
Zurich.
</p>
<p>This dataset holds the coordinates for all trees in the Zurichberg
Forest. Species (SPP), basal area (BAREA) diameter at breast height (DBH),
and volume (VOL) are recorded for each tree. See species codes below. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Zurich.dat)
</code></pre>


<h3>Format</h3>

<p>A data frame containing 4954 rows and 6 columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(Zurich.dat)

coords &lt;- Zurich.dat[,c("X_TREE", "Y_TREE")]

spp.name &lt;- c("beech","maple","ash","other broadleaves",
              "spruce","silver fir", "larch", "other coniferous")

spp.col &lt;- c("yellow","red","orange","pink",
             "green","dark green","black","gray")
                 
plot(coords, col=spp.col[Zurich.dat$SPP+1],
     pch=19, cex=0.5, ylab="Northing", xlab="Easting")

legend.coords &lt;- c(23,240)

legend(legend.coords, pch=19, legend=spp.name,
       col=spp.col, bty="n")



## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
