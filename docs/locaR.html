<!DOCTYPE html><html><head><title>Help for package locaR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {locaR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#checkSettings'><p>Check the validity of a settings file or data.frame.</p></a></li>
<li><a href='#createSettings'><p>Create settings file (csv) or data frame by defining the localization settings.</p></a></li>
<li><a href='#createWavList'><p>Create a list of Wave objects.</p></a></li>
<li><a href='#getFilepaths'><p>Get filepath information for a date and time.</p></a></li>
<li><a href='#layoutMatrix'><p>Specify the spatial layout of microphones.</p></a></li>
<li><a href='#localize'><p>Localize detected sounds</p></a></li>
<li><a href='#localizeSingle'><p>Localize detected sounds</p></a></li>
<li><a href='#locaR'><p>locaR: A Set of Tools for Sound Localization.</p></a></li>
<li><a href='#locHeatmap'><p>Create a heatmap to visualize localization output.</p></a></li>
<li><a href='#makeSearchMap'><p>Create a grid over which to search for sound sources.</p></a></li>
<li><a href='#MSRP_Init'><p>Create InitData.</p></a></li>
<li><a href='#MSRP_RIJ_HT'><p>Internal function for localization.</p></a></li>
<li><a href='#omniSpectro'><p>Generate grid of spectrograms for detecting sounds of interest.</p></a></li>
<li><a href='#parseWAFileNames'><p>Parse Wildlife Acoustics-type file names.</p></a></li>
<li><a href='#processSettings'><p>Process settings file to extract relevant information.</p></a></li>
<li><a href='#Rij_GCC'><p>Generalized cross-correlation.</p></a></li>
<li><a href='#setupSurvey'><p>Set up a new &quot;survey&quot; with a standardized structure recognized by the package.</p></a></li>
<li><a href='#surveyPaths'><p>Get paths for standardized survey workflow.</p></a></li>
<li><a href='#validationSpec'><p>Create validation spectrograms.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Set of Tools for Sound Localization</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Richard Hedley &lt;rwhedley@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A set of functions and tools to conduct acoustic source localization, as well as organize and check localization data and results. The localization functions implement the modified steered response power algorithm described by Cobos et al. (2010) &lt;<a href="https://doi.org/10.1109%2FLSP.2010.2091502">doi:10.1109/LSP.2010.2091502</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/rhedley/locaR">https://github.com/rhedley/locaR</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/rhedley/locaR/issues">https://github.com/rhedley/locaR/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>seewave, tuneR, matrixStats, oce, signal, SynchWave</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.0.0), knitr, rmarkdown</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-02-16 00:25:02 UTC; Richard Hedley</td>
</tr>
<tr>
<td>Author:</td>
<td>Richard Hedley [cre],
  Marcus Becker [aut],
  Tim Huang [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-02-16 15:40:04 UTC</td>
</tr>
</table>
<hr>
<h2 id='checkSettings'>Check the validity of a settings file or data.frame.</h2><span id='topic+checkSettings'></span>

<h3>Description</h3>

<p>Several checks are run:
</p>

<ol>
<li> <p><code>settings</code> is either a valid file or a data.frame.
</p>
</li>
<li><p> That the adjustments file is either an existing file or &quot;&quot;
</p>
</li>
<li><p> That the channels file is either an existing file or NULL.
</p>
</li>
<li><p> That the coordinates file exists.
</p>
</li>
<li><p> That the detections file exists.
</p>
</li>
<li><p> That the siteWavsFolder exists.
</p>
</li>
<li><p> That buffer, margin, resolution, date, time, zMin, zMax and surveyLength
can all be recognized as numbers.
</p>
</li>
<li><p> That tempC or soundSpeed have been defined.
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>checkSettings(settings)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkSettings_+3A_settings">settings</code></td>
<td>
<p>Character or data.frame. Either the path to a settingsFile (csv)
or a data.frame containing settings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical, indicating whether all checks were passed or not.
</p>

<hr>
<h2 id='createSettings'>Create settings file (csv) or data frame by defining the localization settings.</h2><span id='topic+createSettings'></span>

<h3>Description</h3>

<p><code>createSettings</code> takes a series of arguments and creates a data
frame (or csv) with standard structure that can be read by other functions in
the locaR package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createSettings(
  projectName,
  run = 1,
  detectionsFile,
  coordinatesFile,
  siteWavsFolder,
  adjustmentsFile,
  channelsFile,
  date,
  time,
  tempC = 15,
  soundSpeed,
  surveyLength,
  margin = 10,
  zMin = -1,
  zMax = 10,
  resolution = 1,
  buffer = 0.2,
  write.csv = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createSettings_+3A_projectname">projectName</code></td>
<td>
<p>Character. A string specifying the name of a project.</p>
</td></tr>
<tr><td><code id="createSettings_+3A_run">run</code></td>
<td>
<p>Numeric. Within each survey, start with run = 1, then count
upwards. So, run 2 would be used to re-localize sounds that were poorly
localized in run 1, etc. Running them again with slightly different
settings (e.g. start/end times or low/high frequencies)
can improve results.</p>
</td></tr>
<tr><td><code id="createSettings_+3A_detectionsfile">detectionsFile</code></td>
<td>
<p>Character. File path to the detections file (csv).</p>
</td></tr>
<tr><td><code id="createSettings_+3A_coordinatesfile">coordinatesFile</code></td>
<td>
<p>Character. File path to the coordinates file (csv).</p>
</td></tr>
<tr><td><code id="createSettings_+3A_sitewavsfolder">siteWavsFolder</code></td>
<td>
<p>Character. Folder path of the directory containing
audio files. The folder path will be searched recursively if using
<code><a href="#topic+localizeSingle">localizeSingle</a></code> or <code><a href="#topic+localizeMultiple">localizeMultiple</a></code>.</p>
</td></tr>
<tr><td><code id="createSettings_+3A_adjustmentsfile">adjustmentsFile</code></td>
<td>
<p>Character. File path to the adjustments file (csv). Not required to
be specified.</p>
</td></tr>
<tr><td><code id="createSettings_+3A_channelsfile">channelsFile</code></td>
<td>
<p>Character. File path to the channels file (csv),
specifying which channel (1 or 2) to use for each recording unit.</p>
</td></tr>
<tr><td><code id="createSettings_+3A_date">date</code></td>
<td>
<p>Numeric. Eight digit number representing a date in the format
YYYYMMDD.</p>
</td></tr>
<tr><td><code id="createSettings_+3A_time">time</code></td>
<td>
<p>Numeric. Five or six digit number representing the start time
of a recording session (90000 = 09:00:00, and 160000 = 16:00:00).</p>
</td></tr>
<tr><td><code id="createSettings_+3A_tempc">tempC</code></td>
<td>
<p>Numeric. Temperature in degrees C, which is used to calculate
the speed of sound in air using the equation 331.45*sqrt(1+tempC/273.15).</p>
</td></tr>
<tr><td><code id="createSettings_+3A_soundspeed">soundSpeed</code></td>
<td>
<p>Numeric. The speed of sound in meters per second. If missing,
the speed of sound is calculated based on the specified
temperature (assuming the transmission medium is air). If soundSpeed is
specified, the tempC value is over-ridden.</p>
</td></tr>
<tr><td><code id="createSettings_+3A_surveylength">surveyLength</code></td>
<td>
<p>Numeric. Length of the survey, in seconds.</p>
</td></tr>
<tr><td><code id="createSettings_+3A_margin">margin</code></td>
<td>
<p>distance (in meters) to extend the search grid
beyond the x-y limits of the microphone locations. The same buffer is
applied to x and y coordinates.</p>
</td></tr>
<tr><td><code id="createSettings_+3A_zmin">zMin</code></td>
<td>
<p>distance (in meters) to begin grid search relative to the
microphone with the lowest elevation. Typically a small negative number
to ensure that the grid search begins slightly below the lowest
microphone.</p>
</td></tr>
<tr><td><code id="createSettings_+3A_zmax">zMax</code></td>
<td>
<p>distance (in meters) to end search relative to the microphone
with the highest elevation. Typically a positive number to ensure
that the grid search ends well above the highest microphone.</p>
</td></tr>
<tr><td><code id="createSettings_+3A_resolution">resolution</code></td>
<td>
<p>resolution of the search map, in meters.</p>
</td></tr>
<tr><td><code id="createSettings_+3A_buffer">buffer</code></td>
<td>
<p>Amount of time (in seconds) to expand each detection. This
accounts for imprecise time boundaries, and also the differences imposed
by time delays between different microphones (e.g. two microphones
separated by some amount will receive the same sound at different times).</p>
</td></tr>
<tr><td><code id="createSettings_+3A_write.csv">write.csv</code></td>
<td>
<p>Logical. Whether or not to write a settingsFile csv. The
csv will be written to the same directory as the detections file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with columns Setting and Value specifying the value
of each setting needed for localization.
</p>

<hr>
<h2 id='createWavList'>Create a list of Wave objects.</h2><span id='topic+createWavList'></span>

<h3>Description</h3>

<p>This function reads in portions of a set of synchronized .wav files. It is intended to be used to load
sounds of interest for localization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createWavList(
  paths,
  names,
  from,
  to,
  buffer,
  adjustments,
  channels,
  index = "unknown"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createWavList_+3A_paths">paths</code></td>
<td>
<p>Character vector. File paths to the set of .wav files to be read.</p>
</td></tr>
<tr><td><code id="createWavList_+3A_names">names</code></td>
<td>
<p>Character vector. Station names for the files. Must have the same length and
the names must occur in the same order as the <code>paths</code> variable.</p>
</td></tr>
<tr><td><code id="createWavList_+3A_from">from</code></td>
<td>
<p>Numeric. Start time, in seconds, of the sound of interest, relative to
the start of the file.</p>
</td></tr>
<tr><td><code id="createWavList_+3A_to">to</code></td>
<td>
<p>Numeric. End time, in seconds, of the sound of interest, relative to
the start of the file.</p>
</td></tr>
<tr><td><code id="createWavList_+3A_buffer">buffer</code></td>
<td>
<p>Numeric. Amount of blank space around each sound of interest to be read.</p>
</td></tr>
<tr><td><code id="createWavList_+3A_adjustments">adjustments</code></td>
<td>
<p>Numeric vector. Amount, in seconds, to adjust the start times of recordings,
if not already synchronized. Vector must be of the same length as the
<code>paths</code> variable. If not specified, default is no adjustment.</p>
</td></tr>
<tr><td><code id="createWavList_+3A_channels">channels</code></td>
<td>
<p>Numeric vector. The channel to be read from each .wav file. Left = 1, Right = 2. If
missing, default is left channel (channel 1) for all recordings.</p>
</td></tr>
<tr><td><code id="createWavList_+3A_index">index</code></td>
<td>
<p>Numeric. If using this function within a loop, pass the index i to the function, which
can help with troubleshooting if an error occurs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named list of Wave objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    #list example mp3 files.
    wavs &lt;- list.files(system.file('extdata', package = 'locaR'),
                       pattern = 'mp3$', full.names = TRUE)
    #get names of mp3 locations.
    nms &lt;- substr(basename(wavs), 1, 4)
    #create wave list.
    wl &lt;- createWavList(paths = wavs, names = nms, from = 1, to = 2, buffer = 0.1)
</code></pre>

<hr>
<h2 id='getFilepaths'>Get filepath information for a date and time.</h2><span id='topic+getFilepaths'></span>

<h3>Description</h3>

<p><code>getFilepaths</code> reads information from a settings file (csv) or a
settings list and returns the file paths and other information as a
dataframe. It undertakes a recursive search within the site folder for files
matching the date and time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFilepaths(settings, types = "wav")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getFilepaths_+3A_settings">settings</code></td>
<td>
<p>Either a filepath to a settings file (csv) or a settings
list. If a filepath, the filepath will first be passed to
<code><a href="#topic+processSettings">processSettings</a></code>.</p>
</td></tr>
<tr><td><code id="getFilepaths_+3A_types">types</code></td>
<td>
<p>Character, specifying the file type to be searched for. Either 'wav' or 'mp3'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with station names, coordinates, filepaths, and any
recording start-time adjustments.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    #Read example data
    settings &lt;- read.csv(system.file('extdata',
                   'Ex_20200617_090000_Settings.csv', package = 'locaR'),
                   stringsAsFactors = FALSE)

    #Over-write default values for SiteWavsFolder, CoordinatesFile, and ChannelsFile
    settings$Value[settings$Setting == 'SiteWavsFolder'] &lt;-
                  system.file('extdata', package = 'locaR')
    settings$Value[settings$Setting == 'CoordinatesFile'] &lt;-
                   system.file('extdata', 'Vignette_Coordinates.csv',
                               package = 'locaR')
    settings$Value[settings$Setting == 'ChannelsFile'] &lt;-
                   system.file('extdata', 'Vignette_Channels.csv',
                               package = 'locaR')

    #Run processSettings() function
    st &lt;- processSettings(settings = settings, getFilepaths = FALSE)

    #Get filepaths.
    fp &lt;- getFilepaths(settings = st, types = 'mp3')
</code></pre>

<hr>
<h2 id='layoutMatrix'>Specify the spatial layout of microphones.</h2><span id='topic+layoutMatrix'></span>

<h3>Description</h3>

<p><code>layoutMatrix</code> creates a matrix of station names, which correspond to
the layout of stations in space.This is passed to the <code>omniSpectro</code> function
for the purposes of generating spectrograms that align with the spatial
orientation of stations. The four user-specified arguments indicate where
the first station occurs (e.g. topleft means the first
station is in the northwest; the &quot;first&quot; station means the one with the name
that would appear first when sorted alphabetically). byrow means the stations
increase along rows (either left to right or right to left) and nrow and
ncol indicate how many rows and columns of microphones there are
(assuming the array has a rectangular shape).
Note that this layout function is provided for convenience, but users can easily
specify their own custom layouts manually.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layoutMatrix(
  st,
  stationNames = NULL,
  start = c("topleft", "topright", "bottomleft", "bottomright"),
  byrow = TRUE,
  nrow,
  ncol
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layoutMatrix_+3A_st">st</code></td>
<td>
<p>List. Localization settings object generated using
<code><a href="#topic+processSettings">processSettings</a></code>.</p>
</td></tr>
<tr><td><code id="layoutMatrix_+3A_stationnames">stationNames</code></td>
<td>
<p>Character vector. Vector of station names. Not required if st is provided.</p>
</td></tr>
<tr><td><code id="layoutMatrix_+3A_start">start</code></td>
<td>
<p>Character. When sorted alphabetically, the location of the first station name.</p>
</td></tr>
<tr><td><code id="layoutMatrix_+3A_byrow">byrow</code></td>
<td>
<p>Logical. An indicator of whether station names increase along
rows (TRUE) or along columns (FALSE)</p>
</td></tr>
<tr><td><code id="layoutMatrix_+3A_nrow">nrow</code></td>
<td>
<p>Numeric. The number of rows of microphones in the layout.</p>
</td></tr>
<tr><td><code id="layoutMatrix_+3A_ncol">ncol</code></td>
<td>
<p>Numeric. The number of columns of microphones in the layout.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix, containing the station names within the array. If done correctly,
the matrix rows and columns should align with the spatial layout of the stations
in the field.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
    #Vector of station names, Ex-1 to Ex-9.
    stationNames &lt;- paste0('Ex-',1:9)

    #All options shown below.
    #layoutMatrix starting from top left (NW) to bottom right (SE) by row.
    layoutMatrix(stationNames = stationNames,
                 start = 'topleft', byrow = TRUE, ncol = 3, nrow = 3)

    #layoutMatrix starting from top left (NW) to bottom right (SE) by column.
    layoutMatrix(stationNames = stationNames,
                 start = 'topleft', byrow = FALSE, ncol = 3, nrow = 3)

    #layoutMatrix starting from top right (NE) to bottom left (SW) by row.
    layoutMatrix(stationNames = stationNames,
                 start = 'topright', byrow = TRUE, ncol = 3, nrow = 3)

    #layoutMatrix starting from top right (NE) to bottom left (SW) by column.
    layoutMatrix(stationNames = stationNames,
                 start = 'topright', byrow = FALSE, ncol = 3, nrow = 3)

    #layoutMatrix starting from bottom left (SW) to top right (NE) by row.
    layoutMatrix(stationNames = stationNames,
                 start = 'bottomleft', byrow = TRUE, ncol = 3, nrow = 3)

    #layoutMatrix starting from bottom left (SW) to top right (NE) by column.
    layoutMatrix(stationNames = stationNames,
                 start = 'bottomleft', byrow = FALSE, ncol = 3, nrow = 3)

    #layoutMatrix starting from bottom right (SE) to top left (NW) by row.
    layoutMatrix(stationNames = stationNames,
                 start = 'bottomright', byrow = TRUE, ncol = 3, nrow = 3)

    #layoutMatrix starting from bottom right (SE) to top left (NW) by column.
    layoutMatrix(stationNames = stationNames,
                 start = 'bottomright', byrow = FALSE, ncol = 3, nrow = 3)
</code></pre>

<hr>
<h2 id='localize'>Localize detected sounds</h2><span id='topic+localize'></span><span id='topic+localizeMultiple'></span>

<h3>Description</h3>

<p><code>localize</code> and the related function <code>localizeMultiple</code>
are the basic functions for localizing sounds. They take audio data as inputs, alongside relevant
metadata (e.g. coordinates and a variety of settings), and estimate the location of the
dominant sound source. The <code>localize</code> function takes as arguments the minimal
amount of information needed for localization. Localization is conducted on the
full duration of the Wave objects in wavList. Effectively this means the user
must wrangle the data and clip the audio themselves, but this affords the greatest
flexibility in terms of how the user chooses to organize their data.
The <code>localizeMultiple</code> function, in contrast,
automates much of the data wrangling process, but requires data to be organized in a
very specific way (e.g. folder structure, file structures). Thus, the latter
function trades off flexibility for increased automation. Both functions use the
same underlying localization algorithm - <code>localizeMultiple</code>
passes its data to <code>localize</code> after the data has been wrangled.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>localize(
  wavList,
  coordinates,
  margin = 10,
  zMin = -1,
  zMax = 20,
  resolution = 1,
  F_Low = 2000,
  F_High = 8000,
  tempC = 15,
  soundSpeed,
  plot = TRUE,
  locFolder,
  jpegName = "000.jpeg",
  InitData = NULL,
  keep.InitData = TRUE,
  keep.SearchMap = FALSE
)

localizeMultiple(st, indices = "all", plot = TRUE, InitData = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="localize_+3A_wavlist">wavList</code></td>
<td>
<p>list of Wave objects. The name of the Wave objects MUST be
present in the coordinates data.frame.</p>
</td></tr>
<tr><td><code id="localize_+3A_coordinates">coordinates</code></td>
<td>
<p>data.frame. Must contain four required columns:
column Station contains a character string with names of each recording
station, while Easting, Northing and Elevation contain the x, y, and z
coordinates of the station, in meters (E.g. UTM coordinates).</p>
</td></tr>
<tr><td><code id="localize_+3A_margin">margin</code>, <code id="localize_+3A_zmin">zMin</code>, <code id="localize_+3A_zmax">zMax</code>, <code id="localize_+3A_resolution">resolution</code></td>
<td>
<p>Arguments describing the area to be searched
for sound sources. Passed to <code><a href="#topic+makeSearchMap">makeSearchMap</a></code>.</p>
</td></tr>
<tr><td><code id="localize_+3A_f_low">F_Low</code>, <code id="localize_+3A_f_high">F_High</code></td>
<td>
<p>Numeric. The low and high frequency, in Hz, of the sound
to be localized.</p>
</td></tr>
<tr><td><code id="localize_+3A_tempc">tempC</code></td>
<td>
<p>Numeric. Temperature in degrees C, which is used to calculate
the speed of sound in air using the equation 331.45*sqrt(1+tempC/273.15).</p>
</td></tr>
<tr><td><code id="localize_+3A_soundspeed">soundSpeed</code></td>
<td>
<p>Numeric. The speed of sound in meters per second. If missing,
the speed of sound is calculated based on the specified
temperature (assuming the transmission medium is air). If soundSpeed is
specified, the tempC value is over-ridden.</p>
</td></tr>
<tr><td><code id="localize_+3A_plot">plot</code></td>
<td>
<p>Logical. Whether to plot jpegs.</p>
</td></tr>
<tr><td><code id="localize_+3A_locfolder">locFolder</code></td>
<td>
<p>Character. File path to the folder where localization jpegs
(heatmaps and spectrograms) are to be created. Only required if plot = TRUE.</p>
</td></tr>
<tr><td><code id="localize_+3A_jpegname">jpegName</code></td>
<td>
<p>Character. Name of the jpeg, ending in extension .jpeg.
Only required if plot = TRUE.</p>
</td></tr>
<tr><td><code id="localize_+3A_initdata">InitData</code></td>
<td>
<p>List. An InitData list created by running localization with
keep.InitData = TRUE. Providing an InitData list saves computation time,
but is only possible if the SearchGrid and stations used for localization
remain unchanged. Default is NULL, which means the InitData will be
calculated anew.</p>
</td></tr>
<tr><td><code id="localize_+3A_keep.initdata">keep.InitData</code></td>
<td>
<p>Logical. Whether to store the InitData list.</p>
</td></tr>
<tr><td><code id="localize_+3A_keep.searchmap">keep.SearchMap</code></td>
<td>
<p>Logical. Whether to keep the SearchMap list with
power estimates and coordinates of each grid cell.
Should only be set to TRUE if the SearchMap is needed
for some other reason (e.g. making a publication-ready figure or
conducting more involved analysis with overlapping sources, etc.).</p>
</td></tr>
<tr><td><code id="localize_+3A_st">st</code></td>
<td>
<p>List. Localization settings object generated using
<code><a href="#topic+processSettings">processSettings</a></code>. Only needed for <code>localizeSingle</code> or
<code>localizeMultiple</code>.</p>
</td></tr>
<tr><td><code id="localize_+3A_indices">indices</code></td>
<td>
<p>Numeric or 'all'. Indices to be localized within a detection file.
Setting to 1 localizes the first row, c(7:10) localizes rows 7-10, and 'all'
localizes all rows (ignoring rows that have no entry in the Station1 column).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List, containing the location of the sound source (global maximum),
and optionally the InitData and SearchMap lists.
</p>


<h3>References</h3>

<p>Cobos, M., Martí, A., &amp; J.J. López. 2011. A modified SRP-PHAT functional for robust real-time sound source localization with scalable spatial sampling. IEEE Signal Processing Letters. 18:71-74. doi:10.1109/LSP.2010.2091502.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    
    ## example for localize()
    #Get filepaths for example data.
    fp &lt;- list.files(system.file('extdata', package = 'locaR'), pattern = '.mp3', full.names = TRUE)
    #Add names.
    names(fp) &lt;- sapply(strsplit(basename(fp), '_'), '[[', 1)
    #Load first row of detection data.
    row &lt;- read.csv(system.file('extdata',
         'Vignette_Detections_20200617_090000.csv', package = 'locaR'),
          stringsAsFactors = FALSE)[1,]
    #Get non-empty Station columns.
    stationSubset &lt;- unlist(row[1,paste0('Station',1:6)])
    stationSubset &lt;- stationSubset[!is.na(stationSubset) &amp; stationSubset != '']
    #Create wav list.
    wl &lt;- createWavList(paths = fp[stationSubset], names = stationSubset,
           from = row$From, to = row$To, buffer = 0.2, index=1)
    #Read coordinates.
    coordinates &lt;- read.csv(system.file('extdata', 'Vignette_Coordinates.csv',
                                        package = 'locaR'), stringsAsFactors = FALSE)
    row.names(coordinates) &lt;- coordinates$Station
    #Subset coordinates.
    crd &lt;- coordinates[stationSubset,]
    #Localize.
    loc &lt;- localize(wavList = wl, coordinates = crd, locFolder = tempdir(),
               F_Low = row$F_Low, F_High = row$F_High,
               jpegName = '0001.jpeg', keep.SearchMap = TRUE)

    ## Example for localizeMultiple().
    #list mp3 files.
    f.in &lt;- list.files(system.file('extdata', package = 'locaR'), full.names = TRUE, pattern='mp3$')
    #create wav names.
    f.out &lt;- file.path(tempdir(), basename(f.in))
    #change extension.
    substr(f.out, nchar(f.out)-2, nchar(f.out)) &lt;- 'wav'
    #Convert mp3 to wav, as required for this particular example.
    for(i in 1:length(f.in)) {
      y &lt;- tuneR::readMP3(f.in[i])
      tuneR::writeWave(y, filename = f.out[i])
    }
    #Set up survey.
    survey &lt;- setupSurvey(folder = tempdir(), projectName = 'Ex', run = 1,
               coordinatesFile = system.file('extdata', 'Vignette_Coordinates.csv',
                                             package = 'locaR'),
               siteWavsFolder = tempdir(), date = '20200617', time = '090000', surveyLength = 7)
    #read example detections.
    dets &lt;- read.csv(system.file('extdata', 'Vignette_Detections_20200617_090000.csv',
                                 package = 'locaR'))
    #over-write empty detections file.
    write.csv(dets, file.path(tempdir(), '20200617_090000',
              'Run1', 'Ex_20200617_090000_Run1_Detections.csv'), row.names = FALSE)
    #Process settings.
    st &lt;- processSettings(settings = survey, getFilepaths = TRUE, types = 'wav')
    #localize
    locs &lt;- localizeMultiple(st = st, indices = 1:2)
    
</code></pre>

<hr>
<h2 id='localizeSingle'>Localize detected sounds</h2><span id='topic+localizeSingle'></span>

<h3>Description</h3>

<p><code>localizeSingle</code> is an internal function implemented within <code>localizeMultipe</code>. Its basic function is to take an index value corresponding to a detection, extract that detection, extract the relevant coordinates, and feed all relevant metadata into the 'localize()' function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>localizeSingle(
  st,
  index,
  plot = TRUE,
  InitData = NULL,
  keep.InitData = TRUE,
  keep.SearchMap = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="localizeSingle_+3A_st">st</code></td>
<td>
<p>List. Localization settings object generated using
<code><a href="#topic+processSettings">processSettings</a></code>.</p>
</td></tr>
<tr><td><code id="localizeSingle_+3A_index">index</code></td>
<td>
<p>Numeric. Index to be localized within a detection file.</p>
</td></tr>
<tr><td><code id="localizeSingle_+3A_plot">plot</code></td>
<td>
<p>Logical. Whether to plot jpegs.</p>
</td></tr>
<tr><td><code id="localizeSingle_+3A_initdata">InitData</code></td>
<td>
<p>List. An InitData list created by running localization with
keep.InitData = TRUE. Providing an InitData list saves computation time,
but is only possible if the SearchGrid and stations used for localization
remain unchanged. Default is NULL, which means the InitData will be
calculated anew.</p>
</td></tr>
<tr><td><code id="localizeSingle_+3A_keep.initdata">keep.InitData</code></td>
<td>
<p>Logical. Whether to store the InitData list.</p>
</td></tr>
<tr><td><code id="localizeSingle_+3A_keep.searchmap">keep.SearchMap</code></td>
<td>
<p>Logical. Whether to keep the SearchMap list with
power estimates and coordinates of each grid cell.
Should only be set to TRUE if the SearchMap is needed
for some other reason (e.g. making a publication-ready figure or
conducting more involved analysis with overlapping sources, etc.).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List, containing the location of the sound source (global maximum),
and optionally the InitData and SearchMap lists.
</p>

<hr>
<h2 id='locaR'>locaR: A Set of Tools for Sound Localization.</h2><span id='topic+locaR'></span>

<h3>Description</h3>

<p>The locaR package contains functions for localizing sounds using R.
Localizations are carried out using the modified steered response power
algorithm of Cobos et al. (2011) which carries out a grid-search to find
the location in three dimensions where a sound was most likely to have
originated.
</p>


<h3>References</h3>

<p>Cobos, M., Martí, A., &amp; J.J. López. 2011. A modified SRP-PHAT functional for robust real-time sound source localization with scalable spatial sampling. IEEE Signal Processing Letters. 18:71-74. doi:10.1109/LSP.2010.2091502.
</p>

<hr>
<h2 id='locHeatmap'>Create a heatmap to visualize localization output.</h2><span id='topic+locHeatmap'></span>

<h3>Description</h3>

<p>This function can be used to create a heatmap from the localization grid search. In general,
this function should only be used internally, but it could be useful for making customized figures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>locHeatmap(SearchMap, SMap, NodeInfo, location, mar)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="locHeatmap_+3A_searchmap">SearchMap</code></td>
<td>
<p>An array created by the localize() function containing x, y and z coordinates.
Created by setting keep.SearchMap = TRUE when running the localize() function.</p>
</td></tr>
<tr><td><code id="locHeatmap_+3A_smap">SMap</code></td>
<td>
<p>An array created by the localize() function containing the power values.
Created by setting keep.SearchMap = TRUE when running the localize() function.</p>
</td></tr>
<tr><td><code id="locHeatmap_+3A_nodeinfo">NodeInfo</code></td>
<td>
<p>A list with two elements. First element Num is numeric, specifying the number of
microphones used for localization. Second element Pos is a matrix of coordinates with column names
Easting, Northing and Elevation, and row names corresponding to the Station (i.e. location) names.</p>
</td></tr>
<tr><td><code id="locHeatmap_+3A_location">location</code></td>
<td>
<p>Data frame. The location estimate of the sound source. Four columns: Easting, Northing,
Elevation, Power. Data frame should only contain one row.</p>
</td></tr>
<tr><td><code id="locHeatmap_+3A_mar">mar</code></td>
<td>
<p>Numeric vector with four elements. Passed to <code>oce::imagep()</code> for plotting.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    
    #Get filepaths for example data.
    fp &lt;- list.files(system.file('extdata', package = 'locaR'), pattern = '.mp3', full.names = TRUE)
    #Add names.
    names(fp) &lt;- sapply(strsplit(basename(fp), '_'), '[[', 1)
    #Load first row of detection data.
    row &lt;- read.csv(system.file('extdata',
         'Vignette_Detections_20200617_090000.csv', package = 'locaR'),
          stringsAsFactors = FALSE)[1,]
    #Get non-empty Station columns.
    stationSubset &lt;- unlist(row[1,paste0('Station',1:6)])
    stationSubset &lt;- stationSubset[!is.na(stationSubset) &amp; stationSubset != '']
    #Create wav list.
    wl &lt;- createWavList(paths = fp[stationSubset], names = stationSubset,
           from = row$From, to = row$To, buffer = 0.2, index=1)
    #Read coordinates.
    coordinates &lt;- read.csv(system.file('extdata',
                            'Vignette_Coordinates.csv', package = 'locaR'),
                             stringsAsFactors = FALSE)
    row.names(coordinates) &lt;- coordinates$Station
    #Subset coordinates.
    crd &lt;- coordinates[stationSubset,]
    #Localize.
    loc &lt;- localize(wavList = wl, coordinates = crd, locFolder = tempdir(),
               F_Low = row$F_Low, F_High = row$F_High,
               jpegName = '0001.jpeg', keep.SearchMap = TRUE)
    #Convert crd (coordinates) to matrix called NodePos.
    NodePos &lt;- as.matrix(crd[,c('Easting', 'Northing', 'Elevation')])
    colnames(NodePos) &lt;- c('Easting', 'Northing', 'Elevation')
    row.names(NodePos) &lt;- crd$Station
    #Plot heatmap with locHeatmap().
    locHeatmap(SearchMap = loc$SearchMap, SMap = loc$SMap,
                NodeInfo = list(Num = 5, Pos = NodePos), location = loc$location,
                mar = c(0,0,0,0))
    
</code></pre>

<hr>
<h2 id='makeSearchMap'>Create a grid over which to search for sound sources.</h2><span id='topic+makeSearchMap'></span>

<h3>Description</h3>

<p><code>makeSearchMap</code> creates the three-dimensional array over which to search
for sound sources.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeSearchMap(
  easting,
  northing,
  elevation,
  margin = 10,
  zMin = -1,
  zMax = 10,
  resolution = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeSearchMap_+3A_easting">easting</code></td>
<td>
<p>vector of x coordinates of microphones.</p>
</td></tr>
<tr><td><code id="makeSearchMap_+3A_northing">northing</code></td>
<td>
<p>vector of y coordinates of microphones.</p>
</td></tr>
<tr><td><code id="makeSearchMap_+3A_elevation">elevation</code></td>
<td>
<p>vector of z coordinates of microphones.</p>
</td></tr>
<tr><td><code id="makeSearchMap_+3A_margin">margin</code></td>
<td>
<p>distance (in meters) to extend the search grid
beyond the x-y limits of the microphone locations. The same buffer is
applied to x and y coordinates.</p>
</td></tr>
<tr><td><code id="makeSearchMap_+3A_zmin">zMin</code></td>
<td>
<p>distance (in meters) to begin search relative to the microphone
with the lowest elevation. Typically a small negative number to ensure
that the grid search begins slightly below the lowest microphone.</p>
</td></tr>
<tr><td><code id="makeSearchMap_+3A_zmax">zMax</code></td>
<td>
<p>distance (in meters) to end search relative to the microphone
with the highest elevation. Typically a positive number to ensure
that the grid search ends well above the highest microphone.</p>
</td></tr>
<tr><td><code id="makeSearchMap_+3A_resolution">resolution</code></td>
<td>
<p>resolution of the search map, in meters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The localization algorithms used in this package can search for sound sources
over areas with arbitrary size and with arbitrary resolution. However, speed
can sometimes be slow. Generally speaking, the speed of localization
calculations correlates directly with the number of grid cells to be
searched. Speed can therefore be increased by searching a smaller area
(i.e. by reducing the margin, increasing zMin, or decreasing zMax),
or by searching with a coarser grain (i.e. by increasing the resolution).
</p>
<p>The final list defining the search map includes three arrays containing
x, y and z coordinates of
each grid cell, as well as the resolution and range of values in the x,
y and z directions. This list is passed to other functions for localization.
</p>


<h3>Value</h3>

<p>A list defining the search map.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    #read coordinates.
    coords &lt;- read.csv(system.file('extdata', 'Vignette_Coordinates.csv', package = 'locaR'),
       stringsAsFactors = FALSE)
    #make search map.
    sm &lt;- makeSearchMap(easting = coords$Easting,
                       northing = coords$Northing,
                       elevation = coords$Elevation)
</code></pre>

<hr>
<h2 id='MSRP_Init'>Create InitData.</h2><span id='topic+MSRP_Init'></span>

<h3>Description</h3>

<p>Internal function which creates the InitData list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MSRP_Init(NodeInfo, SearchMap, Para, LevelFlag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MSRP_Init_+3A_nodeinfo">NodeInfo</code></td>
<td>
<p>List with elements Num, Pos.</p>
</td></tr>
<tr><td><code id="MSRP_Init_+3A_searchmap">SearchMap</code></td>
<td>
<p>List with elements XDen, YDen, ZDen, XMap, YMap, ZMap</p>
</td></tr>
<tr><td><code id="MSRP_Init_+3A_para">Para</code></td>
<td>
<p>List with Fs, Vc (speed of sound), and DataLen</p>
</td></tr>
<tr><td><code id="MSRP_Init_+3A_levelflag">LevelFlag</code></td>
<td>
<p>Integer. Only value currently supported is 2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List.
</p>


<h3>Author(s)</h3>

<p>Tim Huang.
</p>

<hr>
<h2 id='MSRP_RIJ_HT'>Internal function for localization.</h2><span id='topic+MSRP_RIJ_HT'></span><span id='topic+MSRP_HT_Level2'></span>

<h3>Description</h3>

<p>This function uses the InitData and other info to calculate the likelihood of sound
sources coming from each location. Note: the LevelFlag argument is currently redundant because
there is only one option. Similarly, the MSRP_HT_Level2 function could be rolled into
the MSRP_RIJ_HT function in the future, but for now is kept separate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MSRP_RIJ_HT(NodeInfo, SearchMap, Data, Para, LevelFlag, InitData)

MSRP_HT_Level2(NodeInfo, SearchMap, Data, Para, InitData)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MSRP_RIJ_HT_+3A_nodeinfo">NodeInfo</code></td>
<td>
<p>List with elements Num, Pos.</p>
</td></tr>
<tr><td><code id="MSRP_RIJ_HT_+3A_searchmap">SearchMap</code></td>
<td>
<p>List with elements XDen, YDen, ZDen, XMap, YMap, ZMap</p>
</td></tr>
<tr><td><code id="MSRP_RIJ_HT_+3A_data">Data</code></td>
<td>
<p>Matrix containing the wave samples.</p>
</td></tr>
<tr><td><code id="MSRP_RIJ_HT_+3A_para">Para</code></td>
<td>
<p>List with Fs, Vc (speed of sound), and DataLen</p>
</td></tr>
<tr><td><code id="MSRP_RIJ_HT_+3A_levelflag">LevelFlag</code></td>
<td>
<p>Integer. Only value currently supported is 2.</p>
</td></tr>
<tr><td><code id="MSRP_RIJ_HT_+3A_initdata">InitData</code></td>
<td>
<p>List. Created with the MSRP_Init function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List.
</p>


<h3>Author(s)</h3>

<p>Tim Huang.
</p>

<hr>
<h2 id='omniSpectro'>Generate grid of spectrograms for detecting sounds of interest.</h2><span id='topic+omniSpectro'></span>

<h3>Description</h3>

<p><code>omniSpectro</code> creates a grid of time-synchronized spectrograms, to
facilitate the manual detection of birds across a microphone array. By opening
the resulting jpeg images in an image viewing program (e.g. the standard Microsoft Photos app),
short clips of sounds can be viewed across an entire microphone array at once.
The authors of this package have found this to be an efficient way to view spectrograms,
while effectively eliminating the likelihood of double-counting sound sources that
may be clearly detectable on many microphones at the same time. At the present time,
this function only works when a settings object, st, is provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>omniSpectro(st, lm, intervalLength = 5, intervals = "all")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="omniSpectro_+3A_st">st</code></td>
<td>
<p>List. Localization settings object generated using
<code><a href="#topic+processSettings">processSettings</a></code>.</p>
</td></tr>
<tr><td><code id="omniSpectro_+3A_lm">lm</code></td>
<td>
<p>layout matrix generated using the 'layoutMatrix()' function, or a
user-generated matrix in the same format. This matrix controls how the spectrograms
from each station are mapped to rows and columns.</p>
</td></tr>
<tr><td><code id="omniSpectro_+3A_intervallength">intervalLength</code></td>
<td>
<p>Integer The length of each view interval to be generated, in seconds.
Consecutive windows overlap, by default by 1 second. Setting intervalLength = 5 will therefore
create 6-second spectrogram views, with one second overlap (e.g.
0 to 6, then 5 to 11, 10 to 16, etc.).</p>
</td></tr>
<tr><td><code id="omniSpectro_+3A_intervals">intervals</code></td>
<td>
<p>Integer or 'all'. Which intervals to write to jpeg. For testing
purposes, it is often desirable to set this to, e.g. intervals = 1:5, which
will create only the first five view windows, to ensure the function is working.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    
    #First need to convert mp3 example data to wav.
    #list mp3 files.
    f.in &lt;- list.files(system.file('extdata', package = 'locaR'), full.names = TRUE, pattern='mp3$')
    #create wav names.
    f.out &lt;- file.path(tempdir(), basename(f.in))
    #change extension.
    substr(f.out, nchar(f.out)-2, nchar(f.out)) &lt;- 'wav'
    #Convert mp3 to wav, as required for this particular example.
    for(i in 1:length(f.in)) {
      y &lt;- tuneR::readMP3(f.in[i])
      tuneR::writeWave(y, filename = f.out[i])
    }
    #Set up survey.
    survey &lt;- setupSurvey(folder = tempdir(), projectName = 'Ex', run = 1,
               coordinatesFile = system.file('extdata', 'Vignette_Coordinates.csv',
                                             package = 'locaR'),
               siteWavsFolder = tempdir(), date = '20200617', time = '090000', surveyLength = 7)
    #Process settings.
    st &lt;- processSettings(settings = survey, getFilepaths = TRUE, types = 'wav')
    #Set up layout matrix.
    lm &lt;- layoutMatrix(st = st, start = 'topleft', byrow = TRUE, nrow = 3, ncol = 3)
    #create detection spectrograms.
    omniSpectro(st, lm, intervalLength = 7)
    
</code></pre>

<hr>
<h2 id='parseWAFileNames'>Parse Wildlife Acoustics-type file names.</h2><span id='topic+parseWAFileNames'></span>

<h3>Description</h3>

<p>This function parses the information in file names that are structured according to Wildlife Acoustics'
naming convention. Specifically, the format prefix_date_time.wav or prefix_mic_date_time.wav.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parseWAFileNames(filenames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parseWAFileNames_+3A_filenames">filenames</code></td>
<td>
<p>Character vector of file names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with prefix, channels, date, time and extension information.
</p>

<hr>
<h2 id='processSettings'>Process settings file to extract relevant information.</h2><span id='topic+processSettings'></span>

<h3>Description</h3>

<p><code>processSettings</code> reads information from a settings file (csv) and
combines them into a list for subsequent localization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>processSettings(settingsFile, settings, getFilepaths = FALSE, types = "wav")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="processSettings_+3A_settingsfile">settingsFile</code></td>
<td>
<p>Filepath to the settings file (csv).</p>
</td></tr>
<tr><td><code id="processSettings_+3A_settings">settings</code></td>
<td>
<p>data.frame created either by reading a settings file (csv) or
using the <code><a href="#topic+createSettings">createSettings</a></code> function. Not needed if settingsFile is specified.</p>
</td></tr>
<tr><td><code id="processSettings_+3A_getfilepaths">getFilepaths</code></td>
<td>
<p>Logical, indicating whether to add filepath information
using <code><a href="#topic+getFilepaths">getFilepaths</a></code>.</p>
</td></tr>
<tr><td><code id="processSettings_+3A_types">types</code></td>
<td>
<p>Character. If getFilepaths is TRUE, which types of files to look for ('wav' or 'mp3').</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with information needed for sound localization, including
microphone coordinates, the existing detections, channels to use
for each recording unit, and information specifying the size and
resolution of the grid within which to localize sound sources.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    #Read example data
    settings &lt;- read.csv(system.file('extdata', 'Ex_20200617_090000_Settings.csv',
                                     package = 'locaR'), stringsAsFactors = FALSE)

    #Over-write default values for SiteWavsFolder, CoordinatesFile, and ChannelsFile
    settings$Value[settings$Setting == 'SiteWavsFolder'] &lt;-
                   system.file('extdata', package = 'locaR')
    settings$Value[settings$Setting == 'CoordinatesFile'] &lt;-
                   system.file('extdata', 'Vignette_Coordinates.csv', package = 'locaR')
    settings$Value[settings$Setting == 'ChannelsFile'] &lt;-
                   system.file('extdata', 'Vignette_Channels.csv', package = 'locaR')

    #Run processSettings() function
    st &lt;- processSettings(settings = settings, getFilepaths = FALSE)
</code></pre>

<hr>
<h2 id='Rij_GCC'>Generalized cross-correlation.</h2><span id='topic+Rij_GCC'></span>

<h3>Description</h3>

<p>Internal function that calculates the generalized cross correlation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rij_GCC(data1, data2, Para)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rij_GCC_+3A_data1">data1</code>, <code id="Rij_GCC_+3A_data2">data2</code></td>
<td>
<p>Wave samples.</p>
</td></tr>
<tr><td><code id="Rij_GCC_+3A_para">Para</code></td>
<td>
<p>List with GCCMethod, FL, FH, Fs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector.
</p>


<h3>Author(s)</h3>

<p>Tim Huang
</p>

<hr>
<h2 id='setupSurvey'>Set up a new &quot;survey&quot; with a standardized structure recognized by the package.</h2><span id='topic+setupSurvey'></span>

<h3>Description</h3>

<p><code>setupSurvey</code> sets up the folder structure for a new &quot;survey&quot;, which
corresponds to a single recording session. By setting up
a standardized folder structure, the package functions can carry out much of the
data wrangling automatically using the <code>localizeSingle</code> and <code>localizeMultiple</code>
functions. The extra work required to set up surveys in a standard format can
save time later on.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setupSurvey(
  folder,
  projectName,
  run = 1,
  coordinatesFile,
  siteWavsFolder,
  adjustmentsFile,
  channelsFile,
  date,
  time,
  tempC = 15,
  soundSpeed,
  surveyLength,
  margin = 10,
  zMin = -1,
  zMax = 20,
  resolution = 1,
  buffer = 0.2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setupSurvey_+3A_folder">folder</code></td>
<td>
<p>Character. Path to the directory where the survey will be created.</p>
</td></tr>
<tr><td><code id="setupSurvey_+3A_projectname">projectName</code>, <code id="setupSurvey_+3A_run">run</code>, <code id="setupSurvey_+3A_coordinatesfile">coordinatesFile</code>, <code id="setupSurvey_+3A_sitewavsfolder">siteWavsFolder</code></td>
<td>
<p>Arguments passed to
<code><a href="#topic+createSettings">createSettings</a></code></p>
</td></tr>
<tr><td><code id="setupSurvey_+3A_adjustmentsfile">adjustmentsFile</code></td>
<td>
<p>Character. File path to the adjustments file (csv).
Optional argument.</p>
</td></tr>
<tr><td><code id="setupSurvey_+3A_channelsfile">channelsFile</code></td>
<td>
<p>Character. File path to the adjustments file (csv). If missing,
an empty channels file (csv) will be created.</p>
</td></tr>
<tr><td><code id="setupSurvey_+3A_date">date</code></td>
<td>
<p>Numeric. Eight digit number representing a date in the format
YYYYMMDD.</p>
</td></tr>
<tr><td><code id="setupSurvey_+3A_time">time</code></td>
<td>
<p>Numeric. Five or six digit number representing the start time
of a recording session (90000 = 09:00:00, and 160000 = 16:00:00).</p>
</td></tr>
<tr><td><code id="setupSurvey_+3A_tempc">tempC</code></td>
<td>
<p>Numeric. Temperature in degrees C, which is used to calculate
the speed of sound in air using the equation 331.45*sqrt(1+tempC/273.15).</p>
</td></tr>
<tr><td><code id="setupSurvey_+3A_soundspeed">soundSpeed</code></td>
<td>
<p>Numeric. The speed of sound in meters per second. If missing,
the speed of sound is calculated based on the specified
temperature (assuming the transmission medium is air). If soundSpeed is
specified, the tempC value is over-ridden.</p>
</td></tr>
<tr><td><code id="setupSurvey_+3A_surveylength">surveyLength</code>, <code id="setupSurvey_+3A_margin">margin</code>, <code id="setupSurvey_+3A_zmin">zMin</code>, <code id="setupSurvey_+3A_zmax">zMax</code>, <code id="setupSurvey_+3A_resolution">resolution</code>, <code id="setupSurvey_+3A_buffer">buffer</code></td>
<td>
<p>Arguments describing the area to be searched
for sound sources. Passed to <code><a href="#topic+createSettings">createSettings</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame containing the settings generated using <code><a href="#topic+createSettings">createSettings</a></code>.
This data.frame is identical to that produced by reading the settingsFile csv, which
is also written to file.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    survey &lt;- setupSurvey(folder = tempdir(), projectName = 'Ex', run = 1,
        coordinatesFile = system.file('extdata', 'Vignette_Coordinates.csv', package = 'locaR'),
        siteWavsFolder = tempdir(),
        date = '20200617', time = '090000', surveyLength = 7)
</code></pre>

<hr>
<h2 id='surveyPaths'>Get paths for standardized survey workflow.</h2><span id='topic+surveyPaths'></span>

<h3>Description</h3>

<p>Function that takes arguments of a base folder and a project name, date, time,
and run, and returns the appropriate filepaths for a standardized survey
workflow.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surveyPaths(folder, projectName, date, time, run)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="surveyPaths_+3A_folder">folder</code></td>
<td>
<p>Character. Path to the directory where the survey is to be created.</p>
</td></tr>
<tr><td><code id="surveyPaths_+3A_projectname">projectName</code></td>
<td>
<p>Character. A string specifying the name of a project.</p>
</td></tr>
<tr><td><code id="surveyPaths_+3A_date">date</code></td>
<td>
<p>Numeric. Eight digit number representing a date in the format
YYYYMMDD.</p>
</td></tr>
<tr><td><code id="surveyPaths_+3A_time">time</code></td>
<td>
<p>Numeric. Five or six digit number representing the start time
of a recording session (90000 = 09:00:00, and 160000 = 16:00:00).</p>
</td></tr>
<tr><td><code id="surveyPaths_+3A_run">run</code></td>
<td>
<p>Numeric. Within each survey, start with run = 1, then count
upwards. So, run 2 would be used to re-localize sounds that were poorly
localized in run 1, etc. Running them again with slightly different
settings (e.g. start/end times or low/high frequencies)
can improve results.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named vector of paths to surveyFolder, runFolder, specFolder,
locFolder, detectionsFile, channelsFile, and settingsFile.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    surveyPaths(folder = tempdir(), projectName = 'Ex', date = '20200617', time = '090000', run = 1)
</code></pre>

<hr>
<h2 id='validationSpec'>Create validation spectrograms.</h2><span id='topic+validationSpec'></span>

<h3>Description</h3>

<p>This function is used inside the <code>localize</code> function to create the panels of
synchronized spectrograms for manual review.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validationSpec(
  wavList,
  coordinates,
  locationEstimate,
  from,
  to,
  tempC = 15,
  soundSpeed,
  F_Low,
  F_High
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validationSpec_+3A_wavlist">wavList</code></td>
<td>
<p>list of Wave objects. The name of the Wave objects MUST be
present in the coordinates data.frame.</p>
</td></tr>
<tr><td><code id="validationSpec_+3A_coordinates">coordinates</code></td>
<td>
<p>data.frame. Must contain four required columns:
column Station contains a character string with names of each recording
station, while Easting, Northing and Elevation contain the x, y, and z
coordinates of the station, in meters (E.g. UTM coordinates).</p>
</td></tr>
<tr><td><code id="validationSpec_+3A_locationestimate">locationEstimate</code></td>
<td>
<p>Dataframe with one row containing columns Easting, Northing and Elevation,
specifying the estimated location of the sound source.</p>
</td></tr>
<tr><td><code id="validationSpec_+3A_from">from</code>, <code id="validationSpec_+3A_to">to</code></td>
<td>
<p>Numeric. The portion of the wavs to plot. If missing, the whole wav will be plotted.</p>
</td></tr>
<tr><td><code id="validationSpec_+3A_tempc">tempC</code></td>
<td>
<p>Numeric. The ambient temperature in celsius, which is used to calculate the speed
of sound in air if none is specified.</p>
</td></tr>
<tr><td><code id="validationSpec_+3A_soundspeed">soundSpeed</code></td>
<td>
<p>Numeric. The speed of sound. If missing, tempC will be used to calculate
the speed of sound in air.</p>
</td></tr>
<tr><td><code id="validationSpec_+3A_f_low">F_Low</code>, <code id="validationSpec_+3A_f_high">F_High</code></td>
<td>
<p>Numeric. The low and high frequency, in Hz, of the sound
to be localized.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    
    #Get filepaths for example data.
    fp &lt;- list.files(system.file('extdata', package = 'locaR'),
                      pattern = '.mp3', full.names = TRUE)
    #Add names.
    names(fp) &lt;- sapply(strsplit(basename(fp), '_'), '[[', 1)
    #Load first row of detection data.
    row &lt;- read.csv(system.file('extdata',
         'Vignette_Detections_20200617_090000.csv', package = 'locaR'),
          stringsAsFactors = FALSE)[1,]
    #Get non-empty Station columns.
    stationSubset &lt;- unlist(row[1,paste0('Station',1:6)])
    stationSubset &lt;- stationSubset[!is.na(stationSubset) &amp; stationSubset != '']
    #Create wav list.
    wl &lt;- createWavList(paths = fp[stationSubset], names = stationSubset,
           from = row$From, to = row$To, buffer = 0.2, index=1)
    #Read coordinates.
    coordinates &lt;- read.csv(system.file('extdata', 'Vignette_Coordinates.csv',
                            package = 'locaR'), stringsAsFactors = FALSE)
    row.names(coordinates) &lt;- coordinates$Station
    #Subset coordinates.
    crd &lt;- coordinates[stationSubset,]
    #Localize.
    loc &lt;- localize(wavList = wl, coordinates = crd, locFolder = tempdir(),
               F_Low = row$F_Low, F_High = row$F_High, jpegName = '0001.jpeg',
               keep.SearchMap = TRUE)
    #Create validation spectrogram.
    #Store old par
    oldpar &lt;- par()$mfrow
    par(mfrow = c(6,1))
    validationSpec(wavList = wl, coordinates = crd, locationEstimate = loc$location,
                                 F_Low = row$F_Low, F_High = row$F_High)
    #Reset old par values.
    par(mfrow = oldpar)
    
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
