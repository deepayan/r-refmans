<!DOCTYPE html><html><head><title>Help for package plsRglm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {plsRglm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#plsRglm-package'><p>plsRglm-package</p></a></li>
<li><a href='#aic.dof'><p>Akaike and Bayesian Information Criteria and Generalized minimum description</p>
length</a></li>
<li><a href='#AICpls'><p>AIC function for plsR models</p></a></li>
<li><a href='#aze'><p>Microsatellites Dataset</p></a></li>
<li><a href='#aze_compl'><p>As aze without missing values</p></a></li>
<li><a href='#bootpls'><p>Non-parametric Bootstrap for PLS models</p></a></li>
<li><a href='#bootplsglm'><p>Non-parametric Bootstrap for PLS generalized linear models</p></a></li>
<li><a href='#bordeaux'><p>Quality of wine dataset</p></a></li>
<li><a href='#bordeauxNA'><p>Quality of wine dataset</p></a></li>
<li><a href='#boxplots.bootpls'><p>Boxplot bootstrap distributions</p></a></li>
<li><a href='#coef.plsRglmmodel'><p>coef method for plsR models</p></a></li>
<li><a href='#coef.plsRmodel'><p>coef method for plsR models</p></a></li>
<li><a href='#coefs.plsR'><p>Coefficients for bootstrap computations of PLSR models</p></a></li>
<li><a href='#coefs.plsR.raw'><p>Raw coefficients for bootstrap computations of PLSR models</p></a></li>
<li><a href='#coefs.plsRglm'><p>Coefficients for bootstrap computations of PLSGLR models</p></a></li>
<li><a href='#coefs.plsRglm.raw'><p>Raw coefficients for bootstrap computations of PLSGLR models</p></a></li>
<li><a href='#coefs.plsRglmnp'><p>Coefficients for bootstrap computations of PLSGLR models</p></a></li>
<li><a href='#coefs.plsRnp'><p>Coefficients for bootstrap computations of PLSR models</p></a></li>
<li><a href='#confints.bootpls'><p>Bootstrap confidence intervals</p></a></li>
<li><a href='#CorMat'><p>Correlation matrix for simulating plsR datasets</p></a></li>
<li><a href='#Cornell'><p>Cornell dataset</p></a></li>
<li><a href='#cv.plsR'><p>Partial least squares regression models with k-fold cross-validation</p></a></li>
<li><a href='#cv.plsRglm'><p>Partial least squares regression glm models with k-fold cross validation</p></a></li>
<li><a href='#cvtable'><p>Table method for summary of cross validated PLSR and PLSGLR models</p></a></li>
<li><a href='#dicho'><p>Dichotomization</p></a></li>
<li><a href='#fowlkes'><p>Fowlkes dataset</p></a></li>
<li><a href='#infcrit.dof'><p>Information criteria</p></a></li>
<li><a href='#kfolds2Chisq'><p>Computes Predicted Chisquare for k-fold cross-validated partial least</p>
squares regression models.</a></li>
<li><a href='#kfolds2Chisqind'><p>Computes individual Predicted Chisquare for k-fold cross validated partial</p>
least squares regression models.</a></li>
<li><a href='#kfolds2coeff'><p>Extracts coefficients from k-fold cross validated partial least squares</p>
regression models</a></li>
<li><a href='#kfolds2CVinfos_glm'><p>Extracts and computes information criteria and fits statistics for k-fold</p>
cross validated partial least squares glm models</a></li>
<li><a href='#kfolds2CVinfos_lm'><p>Extracts and computes information criteria and fits statistics for k-fold</p>
cross validated partial least squares models</a></li>
<li><a href='#kfolds2Mclassed'><p>Number of missclassified individuals for k-fold cross validated partial</p>
least squares regression models.</a></li>
<li><a href='#kfolds2Mclassedind'><p>Number of missclassified individuals per group for k-fold cross validated</p>
partial least squares regression models.</a></li>
<li><a href='#kfolds2Press'><p>Computes PRESS for k-fold cross validated partial least squares regression</p>
models.</a></li>
<li><a href='#kfolds2Pressind'><p>Computes individual PRESS for k-fold cross validated partial least squares</p>
regression models.</a></li>
<li><a href='#loglikpls'><p>loglikelihood function for plsR models</p></a></li>
<li><a href='#permcoefs.plsR'><p>Coefficients for permutation bootstrap computations of PLSR models</p></a></li>
<li><a href='#permcoefs.plsR.raw'><p>Raw coefficients for permutation bootstrap computations of PLSR models</p></a></li>
<li><a href='#permcoefs.plsRglm'><p>Coefficients for permutation bootstrap computations of PLSGLR models</p></a></li>
<li><a href='#permcoefs.plsRglm.raw'><p>Raw coefficients for permutation bootstrap computations of PLSGLR models</p></a></li>
<li><a href='#permcoefs.plsRglmnp'><p>Coefficients for permutation bootstrap computations of PLSGLR models</p></a></li>
<li><a href='#permcoefs.plsRnp'><p>Coefficients computation for permutation bootstrap</p></a></li>
<li><a href='#pine'><p>Pine dataset</p></a></li>
<li><a href='#pine_full'><p>Complete Pine dataset</p></a></li>
<li><a href='#pine_sup'><p>Complete Pine dataset</p></a></li>
<li><a href='#pineNAX21'><p>Incomplete dataset from the pine caterpillars example</p></a></li>
<li><a href='#plot.table.summary.cv.plsRglmmodel'><p>Plot method for table of summary of cross validated plsRglm models</p></a></li>
<li><a href='#plot.table.summary.cv.plsRmodel'><p>Plot method for table of summary of cross validated plsR models</p></a></li>
<li><a href='#plots.confints.bootpls'><p>Plot bootstrap confidence intervals</p></a></li>
<li><a href='#PLS_glm_wvc'><p>Light version of PLS_glm for cross validation purposes</p></a></li>
<li><a href='#PLS_lm_wvc'><p>Light version of PLS_lm for cross validation purposes</p></a></li>
<li><a href='#plsR'><p>Partial least squares Regression models with leave one out cross validation</p></a></li>
<li><a href='#plsR.dof'><p>Computation of the Degrees of Freedom</p></a></li>
<li><a href='#plsRglm'><p>Partial least squares Regression generalized linear models</p></a></li>
<li><a href='#predict.plsRglmmodel'><p>Print method for plsRglm models</p></a></li>
<li><a href='#predict.plsRmodel'><p>Print method for plsR models</p></a></li>
<li><a href='#print.coef.plsRglmmodel'><p>Print method for plsRglm models</p></a></li>
<li><a href='#print.coef.plsRmodel'><p>Print method for plsR models</p></a></li>
<li><a href='#print.cv.plsRglmmodel'><p>Print method for plsRglm models</p></a></li>
<li><a href='#print.cv.plsRmodel'><p>Print method for plsR models</p></a></li>
<li><a href='#print.plsRglmmodel'><p>Print method for plsRglm models</p></a></li>
<li><a href='#print.plsRmodel'><p>Print method for plsR models</p></a></li>
<li><a href='#print.summary.plsRglmmodel'><p>Print method for summaries of plsRglm models</p></a></li>
<li><a href='#print.summary.plsRmodel'><p>Print method for summaries of plsR models</p></a></li>
<li><a href='#signpred'><p>Graphical assessment of the stability of selected variables</p></a></li>
<li><a href='#simul_data_complete'><p>Data generating detailed process for multivariate plsR models</p></a></li>
<li><a href='#simul_data_UniYX'><p>Data generating function for univariate plsR models</p></a></li>
<li><a href='#simul_data_UniYX_binom'><p>Data generating function for univariate binomial plsR models</p></a></li>
<li><a href='#simul_data_YX'><p>Data generating function for multivariate plsR models</p></a></li>
<li><a href='#summary.cv.plsRglmmodel'><p>Summary method for plsRglm models</p></a></li>
<li><a href='#summary.cv.plsRmodel'><p>Summary method for plsR models</p></a></li>
<li><a href='#summary.plsRglmmodel'><p>Summary method for plsRglm models</p></a></li>
<li><a href='#summary.plsRmodel'><p>Summary method for plsR models</p></a></li>
<li><a href='#tilt.bootpls'><p>Non-parametric tilted bootstrap for PLS regression models</p></a></li>
<li><a href='#tilt.bootplsglm'><p>Non-parametric tilted bootstrap for PLS generalized linear regression models</p></a></li>
<li><a href='#XbordeauxNA'><p>Incomplete dataset for the quality of wine dataset</p></a></li>
<li><a href='#XpineNAX21'><p>Incomplete dataset from the pine caterpillars example</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.5.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-03-14</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>mvtnorm, boot, bipartite, car, MASS</td>
</tr>
<tr>
<td>Enhances:</td>
<td>pls</td>
</tr>
<tr>
<td>Suggests:</td>
<td>plsdof, R.rsp, chemometrics, plsdepot</td>
</tr>
<tr>
<td>Title:</td>
<td>Partial Least Squares Regression for Generalized Linear Models</td>
</tr>
<tr>
<td>Author:</td>
<td>Frederic Bertrand <a href="https://orcid.org/0000-0002-0837-8281"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut],
  Myriam Maumy-Bertrand
    <a href="https://orcid.org/0000-0002-4615-1512"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Frederic Bertrand &lt;frederic.bertrand@utt.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides (weighted) Partial least squares Regression for generalized linear models and repeated k-fold cross-validation of such models using various criteria &lt;<a href="https://doi.org/10.48550/arXiv.1810.01005">doi:10.48550/arXiv.1810.01005</a>&gt;. It allows for missing data in the explanatory variables. Bootstrap confidence intervals constructions are also available.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://fbertran.github.io/plsRglm/">https://fbertran.github.io/plsRglm/</a>,
<a href="https://github.com/fbertran/plsRglm/">https://github.com/fbertran/plsRglm/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/fbertran/plsRglm/issues/">https://github.com/fbertran/plsRglm/issues/</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>Classification/MSC:</td>
<td>62J12, 62J99</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-14 20:38:36 UTC; fbertran</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-14 22:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='plsRglm-package'>plsRglm-package</h2><span id='topic+plsRglm-package'></span>

<h3>Description</h3>

<p>Provides (weighted) Partial least squares Regression for generalized linear models and repeated k-fold cross-validation of such models using various criteria &lt;arXiv:1810.01005&gt;. It allows for missing data in the explanatory variables. Bootstrap confidence intervals constructions are also available.
</p>


<h3>References</h3>

<p>A short paper that sums up some of features of the package is available on <a href="https://arxiv.org/">https://arxiv.org/</a>, Frédéric Bertrand and Myriam Maumy-Bertrand (2018), &quot;plsRglm: Partial least squares linear and generalized linear regression for processing incomplete datasets by cross-validation and bootstrap techniques with R&quot;, *arxiv*, <a href="https://arxiv.org/abs/1810.01005">https://arxiv.org/abs/1810.01005</a>, <a href="https://github.com/fbertran/plsRglm/">https://github.com/fbertran/plsRglm/</a> et <a href="https://fbertran.github.io/plsRglm/">https://fbertran.github.io/plsRglm/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(314)
library(plsRglm)
data(Cornell)
cv.modpls&lt;-cv.plsR(Y~.,data=Cornell,nt=6,K=6)
res.cv.modpls&lt;-cvtable(summary(cv.modpls))

</code></pre>

<hr>
<h2 id='aic.dof'>Akaike and Bayesian Information Criteria and Generalized minimum description
length</h2><span id='topic+aic.dof'></span><span id='topic+bic.dof'></span><span id='topic+gmdl.dof'></span>

<h3>Description</h3>

<p>This function computes the Akaike and Bayesian Information Criteria and the
Generalized minimum description length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aic.dof(RSS, n, DoF, sigmahat)

bic.dof(RSS, n, DoF, sigmahat)

gmdl.dof(sigmahat, n, DoF, yhat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aic.dof_+3A_rss">RSS</code></td>
<td>
<p>vector of residual sum of squares.</p>
</td></tr>
<tr><td><code id="aic.dof_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="aic.dof_+3A_dof">DoF</code></td>
<td>
<p>vector of Degrees of Freedom. The length of <code>DoF</code> is the
same as the length of <code>RSS</code>.</p>
</td></tr>
<tr><td><code id="aic.dof_+3A_sigmahat">sigmahat</code></td>
<td>
<p>Estimated model error. The length of <code>sigmahat</code> is the
same as the length of <code>RSS</code>.</p>
</td></tr>
<tr><td><code id="aic.dof_+3A_yhat">yhat</code></td>
<td>
<p>vector of squared norm of Yhat. The length of <code>yhat</code> is the
same as the length of <code>sigmahat</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The gmdl criterion is defined as
</p>
<p style="text-align: center;"><code class="reqn">gmdl=\frac{n}{2}log(S)+\frac{DoF}{2}log(F)+\frac{1}{2}log(n)</code>
</p>

<p>with </p>
<p style="text-align: center;"><code class="reqn">S=\hat\sigma^2</code>
</p>



<h3>Value</h3>

<table>
<tr><td><code>vector</code></td>
<td>
<p>numerical values of the requested AIC, BIC or GMDL.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>References</h3>

<p>M. Hansen, B. Yu. (2001). Model Selection and Minimum Descripion
Length Principle, <em>Journal of the American Statistical Association</em>,
96, 746-774.<br /> N. Kraemer, M. Sugiyama. (2011). The Degrees of Freedom of
Partial Least Squares Regression. <em>Journal of the American Statistical
Association</em>, 106(494), 697-705.<br /> N. Kraemer, M.L. Braun, Kernelizing PLS,
Degrees of Freedom, and Efficient Model Selection, <em>Proceedings of the
24th International Conference on Machine Learning</em>, Omni Press, (2007)
441-448.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plsR.dof">plsR.dof</a></code> for degrees of freedom computation and
<code><a href="#topic+infcrit.dof">infcrit.dof</a></code> for computing information criteria directly from a
previously fitted plsR model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Cornell)
XCornell&lt;-Cornell[,1:7]
yCornell&lt;-Cornell[,8]
modpls &lt;- plsR(yCornell,XCornell,4)
dof.object &lt;- plsR.dof(modpls)
aic.dof(modpls$RSS,modpls$nr,dof.object$DoF,dof.object$sigmahat)
bic.dof(modpls$RSS,modpls$nr,dof.object$DoF,dof.object$sigmahat)
gmdl.dof(dof.object$sigmahat,modpls$nr,dof.object$DoF,dof.object$yhat)
naive.object &lt;- plsR.dof(modpls,naive=TRUE)
aic.dof(modpls$RSS,modpls$nr,naive.object$DoF,naive.object$sigmahat)
bic.dof(modpls$RSS,modpls$nr,naive.object$DoF,naive.object$sigmahat)
gmdl.dof(naive.object$sigmahat,modpls$nr,naive.object$DoF,naive.object$yhat)

</code></pre>

<hr>
<h2 id='AICpls'>AIC function for plsR models</h2><span id='topic+AICpls'></span>

<h3>Description</h3>

<p>This function provides AIC computation for an univariate plsR model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AICpls(ncomp, residpls, weights = rep.int(1, length(residpls)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AICpls_+3A_ncomp">ncomp</code></td>
<td>
<p>Number of components</p>
</td></tr>
<tr><td><code id="AICpls_+3A_residpls">residpls</code></td>
<td>
<p>Residuals of a fitted univariate plsR model</p>
</td></tr>
<tr><td><code id="AICpls_+3A_weights">weights</code></td>
<td>
<p>Weights of observations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>AIC function for plsR models with univariate response.
</p>


<h3>Value</h3>

<table>
<tr><td><code>real</code></td>
<td>
<p>AIC value</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>References</h3>

<p>Baibing Li, Julian Morris, Elaine B. Martin, Model selection for
partial least squares regression, Chemometrics and Intelligent Laboratory
Systems 64 (2002) 79-89, <a href="https://doi.org/10.1016/S0169-7439%2802%2900051-5">doi:10.1016/S0169-7439(02)00051-5</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+loglikpls">loglikpls</a></code> for loglikelihood computations for plsR
models and <code><a href="stats.html#topic+AIC">AIC</a></code> for AIC computation for a linear models
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(pine)
ypine &lt;- pine[,11]
Xpine &lt;- pine[,1:10]
(Pinscaled &lt;- as.data.frame(cbind(scale(ypine),scale(as.matrix(Xpine)))))
colnames(Pinscaled)[1] &lt;- "yy"

lm(yy~x1+x2+x3+x4+x5+x6+x7+x8+x9+x10,data=Pinscaled)

modpls &lt;- plsR(ypine,Xpine,10)
modpls$Std.Coeffs
lm(yy~x1+x2+x3+x4+x5+x6+x7+x8+x9+x10,data=Pinscaled)

AIC(lm(yy~x1+x2+x3+x4+x5+x6+x7+x8+x9+x10,data=Pinscaled))
print(logLik(lm(yy~x1+x2+x3+x4+x5+x6+x7+x8+x9+x10,data=Pinscaled)))

sum(dnorm(modpls$RepY, modpls$Std.ValsPredictY, sqrt(mean(modpls$residY^2)), log=TRUE))
sum(dnorm(Pinscaled$yy,fitted(lm(yy~x1+x2+x3+x4+x5+x6+x7+x8+x9+x10,data=Pinscaled)),
sqrt(mean(residuals(lm(yy~x1+x2+x3+x4+x5+x6+x7+x8+x9+x10,data=Pinscaled))^2)), log=TRUE))
loglikpls(modpls$residY)
loglikpls(residuals(lm(yy~x1+x2+x3+x4+x5+x6+x7+x8+x9+x10,data=Pinscaled)))
AICpls(10,residuals(lm(yy~x1+x2+x3+x4+x5+x6+x7+x8+x9+x10,data=Pinscaled)))
AICpls(10,modpls$residY)

</code></pre>

<hr>
<h2 id='aze'>Microsatellites Dataset</h2><span id='topic+aze'></span>

<h3>Description</h3>

<p>This database was collected on patients carrying a colon adenocarcinoma. It
has 104 observations on 33 binary qualitative explanatory variables and one
response variable <code>y</code> representing the cancer stage according to the to
Astler-Coller classification (Astler and Coller, 1954). This dataset has
some missing data due to technical limits. A microsattelite is a non-coding
DNA sequence.
</p>


<h3>Format</h3>

<p>A data frame with 104 observations on the following 34 variables.
</p>
 <dl>
<dt>y</dt><dd><p>the response: a binary vector (Astler-Coller
score).</p>
</dd> <dt>D2S138</dt><dd><p>a binary vector that indicates whether this
microsatellite is altered or not.</p>
</dd> <dt>D18S61</dt><dd><p>a binary vector
that indicates whether this microsatellite is altered or not.</p>
</dd>
<dt>D16S422</dt><dd><p>a binary vector that indicates whether this
microsatellite is altered or not.</p>
</dd> <dt>D17S794</dt><dd><p>a binary vector
that indicates whether this microsatellite is altered or not.</p>
</dd>
<dt>D6S264</dt><dd><p>a binary vector that indicates whether this
microsatellite is altered or not.</p>
</dd> <dt>D14S65</dt><dd><p>a binary vector
that indicates whether this microsatellite is altered or not.</p>
</dd>
<dt>D18S53</dt><dd><p>a binary vector that indicates whether this
microsatellite is altered or not.</p>
</dd> <dt>D17S790</dt><dd><p>a binary vector
that indicates whether this microsatellite is altered or not.</p>
</dd>
<dt>D1S225</dt><dd><p>a binary vector that indicates whether this
microsatellite is altered or not.</p>
</dd> <dt>D3S1282</dt><dd><p>a binary vector
that indicates whether this microsatellite is altered or not.</p>
</dd>
<dt>D9S179</dt><dd><p>a binary vector that indicates whether this
microsatellite is altered or not.</p>
</dd> <dt>D5S430</dt><dd><p>a binary vector
that indicates whether this microsatellite is altered or not.</p>
</dd>
<dt>D8S283</dt><dd><p>a binary vector that indicates whether this
microsatellite is altered or not.</p>
</dd> <dt>D11S916</dt><dd><p>a binary vector
that indicates whether this microsatellite is altered or not.</p>
</dd>
<dt>D2S159</dt><dd><p>a binary vector that indicates whether this
microsatellite is altered or not.</p>
</dd> <dt>D16S408</dt><dd><p>a binary vector
that indicates whether this microsatellite is altered or not.</p>
</dd>
<dt>D5S346</dt><dd><p>a binary vector that indicates whether this
microsatellite is altered or not.</p>
</dd> <dt>D10S191</dt><dd><p>a binary vector
that indicates whether this microsatellite is altered or not.</p>
</dd>
<dt>D13S173</dt><dd><p>a binary vector that indicates whether this
microsatellite is altered or not.</p>
</dd> <dt>D6S275</dt><dd><p>a binary vector
that indicates whether this microsatellite is altered or not.</p>
</dd>
<dt>D15S127</dt><dd><p>a binary vector that indicates whether this
microsatellite is altered or not.</p>
</dd> <dt>D1S305</dt><dd><p>a binary vector
that indicates whether this microsatellite is altered or not.</p>
</dd>
<dt>D4S394</dt><dd><p>a binary vector that indicates whether this
microsatellite is altered or not.</p>
</dd> <dt>D20S107</dt><dd><p>a binary vector
that indicates whether this microsatellite is altered or not.</p>
</dd>
<dt>D1S197</dt><dd><p>a binary vector that indicates whether this
microsatellite is altered or not.</p>
</dd> <dt>D1S207</dt><dd><p>a binary vector
that indicates whether this microsatellite is altered or not.</p>
</dd>
<dt>D10S192</dt><dd><p>a binary vector that indicates whether this
microsatellite is altered or not.</p>
</dd> <dt>D3S1283</dt><dd><p>a binary vector
that indicates whether this microsatellite is altered or not.</p>
</dd>
<dt>D4S414</dt><dd><p>a binary vector that indicates whether this
microsatellite is altered or not.</p>
</dd> <dt>D8S264</dt><dd><p>a binary vector
that indicates whether this microsatellite is altered or not.</p>
</dd>
<dt>D22S928</dt><dd><p>a binary vector that indicates whether this
microsatellite is altered or not.</p>
</dd> <dt>TP53</dt><dd><p>a binary vector that
indicates whether this microsatellite is altered or not.</p>
</dd>
<dt>D9S171</dt><dd><p>a binary vector that indicates whether this
microsatellite is altered or not.</p>
</dd> </dl>



<h3>Source</h3>

<p>Weber <em>et al.</em> (2007). Allelotyping analyzes of synchronous
primary and metastasis CIN colon cancers identified different subtypes.
<em>Int J Cancer</em>, 120(3), pages 524-32.
</p>


<h3>References</h3>

<p>Nicolas Meyer, Myriam Maumy-Bertrand et
Frédéric Bertrand (2010). Comparing the linear and the
logistic PLS regression with qualitative predictors: application to
allelotyping data. <em>Journal de la Société Française de Statistique</em>,
151(2), pages 1-18.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(aze)
str(aze)

</code></pre>

<hr>
<h2 id='aze_compl'>As aze without missing values</h2><span id='topic+aze_compl'></span>

<h3>Description</h3>

<p>This is a single imputation of the <code><a href="#topic+aze">aze</a></code> dataset which was
collected on patients carrying a colon adenocarcinoma. It has 104
observations on 33 binary qualitative explanatory variables and one response
variable <code>y</code> representing the cancer stage according to the to
Astler-Coller classification (Astler and Coller, 1954). A microsattelite is
a non-coding DNA sequence.
</p>


<h3>Format</h3>

<p>A data frame with 104 observations on the following 34 variables.
</p>
 <dl>
<dt>y</dt><dd><p>the response: a binary vector (Astler-Coller
score).</p>
</dd> <dt>D2S138</dt><dd><p>a binary vector that indicates whether this
microsatellite is altered or not.</p>
</dd> <dt>D18S61</dt><dd><p>a binary vector
that indicates whether this microsatellite is altered or not.</p>
</dd>
<dt>D16S422</dt><dd><p>a binary vector that indicates whether this
microsatellite is altered or not.</p>
</dd> <dt>D17S794</dt><dd><p>a binary vector
that indicates whether this microsatellite is altered or not.</p>
</dd>
<dt>D6S264</dt><dd><p>a binary vector that indicates whether this
microsatellite is altered or not.</p>
</dd> <dt>D14S65</dt><dd><p>a binary vector
that indicates whether this microsatellite is altered or not.</p>
</dd>
<dt>D18S53</dt><dd><p>a binary vector that indicates whether this
microsatellite is altered or not.</p>
</dd> <dt>D17S790</dt><dd><p>a binary vector
that indicates whether this microsatellite is altered or not.</p>
</dd>
<dt>D1S225</dt><dd><p>a binary vector that indicates whether this
microsatellite is altered or not.</p>
</dd> <dt>D3S1282</dt><dd><p>a binary vector
that indicates whether this microsatellite is altered or not.</p>
</dd>
<dt>D9S179</dt><dd><p>a binary vector that indicates whether this
microsatellite is altered or not.</p>
</dd> <dt>D5S430</dt><dd><p>a binary vector
that indicates whether this microsatellite is altered or not.</p>
</dd>
<dt>D8S283</dt><dd><p>a binary vector that indicates whether this
microsatellite is altered or not.</p>
</dd> <dt>D11S916</dt><dd><p>a binary vector
that indicates whether this microsatellite is altered or not.</p>
</dd>
<dt>D2S159</dt><dd><p>a binary vector that indicates whether this
microsatellite is altered or not.</p>
</dd> <dt>D16S408</dt><dd><p>a binary vector
that indicates whether this microsatellite is altered or not.</p>
</dd>
<dt>D5S346</dt><dd><p>a binary vector that indicates whether this
microsatellite is altered or not.</p>
</dd> <dt>D10S191</dt><dd><p>a binary vector
that indicates whether this microsatellite is altered or not.</p>
</dd>
<dt>D13S173</dt><dd><p>a binary vector that indicates whether this
microsatellite is altered or not.</p>
</dd> <dt>D6S275</dt><dd><p>a binary vector
that indicates whether this microsatellite is altered or not.</p>
</dd>
<dt>D15S127</dt><dd><p>a binary vector that indicates whether this
microsatellite is altered or not.</p>
</dd> <dt>D1S305</dt><dd><p>a binary vector
that indicates whether this microsatellite is altered or not.</p>
</dd>
<dt>D4S394</dt><dd><p>a binary vector that indicates whether this
microsatellite is altered or not.</p>
</dd> <dt>D20S107</dt><dd><p>a binary vector
that indicates whether this microsatellite is altered or not.</p>
</dd>
<dt>D1S197</dt><dd><p>a binary vector that indicates whether this
microsatellite is altered or not.</p>
</dd> <dt>D1S207</dt><dd><p>a binary vector
that indicates whether this microsatellite is altered or not.</p>
</dd>
<dt>D10S192</dt><dd><p>a binary vector that indicates whether this
microsatellite is altered or not.</p>
</dd> <dt>D3S1283</dt><dd><p>a binary vector
that indicates whether this microsatellite is altered or not.</p>
</dd>
<dt>D4S414</dt><dd><p>a binary vector that indicates whether this
microsatellite is altered or not.</p>
</dd> <dt>D8S264</dt><dd><p>a binary vector
that indicates whether this microsatellite is altered or not.</p>
</dd>
<dt>D22S928</dt><dd><p>a binary vector that indicates whether this
microsatellite is altered or not.</p>
</dd> <dt>TP53</dt><dd><p>a binary vector that
indicates whether this microsatellite is altered or not.</p>
</dd>
<dt>D9S171</dt><dd><p>a binary vector that indicates whether this
microsatellite is altered or not.</p>
</dd> </dl>



<h3>Source</h3>

<p>Weber <em>et al.</em> (2007). Allelotyping analyzes of synchronous
primary and metastasis CIN colon cancers identified different subtypes.
<em>Int J Cancer</em>, 120(3), pages 524-32.
</p>


<h3>References</h3>

<p>Nicolas Meyer, Myriam Maumy-Bertrand et
Frédéric Bertrand (2010). Comparing the linear and the
logistic PLS regression with qualitative predictors: application to
allelotyping data. <em>Journal de la Société Française de Statistique</em>,
151(2), pages 1-18.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(aze_compl)
str(aze_compl)

</code></pre>

<hr>
<h2 id='bootpls'>Non-parametric Bootstrap for PLS models</h2><span id='topic+bootpls'></span>

<h3>Description</h3>

<p>Provides a wrapper for the bootstrap function <code>boot</code> from the
<code>boot</code> R package.<br /> Implements non-parametric bootstraps for PLS
Regression models by either (Y,X) or (Y,T) resampling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootpls(
  object,
  typeboot = "plsmodel",
  R = 250,
  statistic = NULL,
  sim = "ordinary",
  stype = "i",
  stabvalue = 1e+06,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootpls_+3A_object">object</code></td>
<td>
<p>An object of class <code>plsRmodel</code> to bootstrap</p>
</td></tr>
<tr><td><code id="bootpls_+3A_typeboot">typeboot</code></td>
<td>
<p>The type of bootstrap. Either (Y,X) boostrap
(<code>typeboot="plsmodel"</code>) or (Y,T) bootstrap
(<code>typeboot="fmodel_np"</code>). Defaults to (Y,X) resampling.</p>
</td></tr>
<tr><td><code id="bootpls_+3A_r">R</code></td>
<td>
<p>The number of bootstrap replicates. Usually this will be a single
positive integer. For importance resampling, some resamples may use one set
of weights and others use a different set of weights. In this case <code>R</code>
would be a vector of integers where each component gives the number of
resamples from each of the rows of weights.</p>
</td></tr>
<tr><td><code id="bootpls_+3A_statistic">statistic</code></td>
<td>
<p>A function which when applied to data returns a vector
containing the statistic(s) of interest. <code>statistic</code> must take at least
two arguments. The first argument passed will always be the original data.
The second will be a vector of indices, frequencies or weights which define
the bootstrap sample. Further, if predictions are required, then a third
argument is required which would be a vector of the random indices used to
generate the bootstrap predictions. Any further arguments can be passed to
statistic through the <code>...</code> argument.</p>
</td></tr>
<tr><td><code id="bootpls_+3A_sim">sim</code></td>
<td>
<p>A character string indicating the type of simulation required.
Possible values are <code>"ordinary"</code> (the default), <code>"balanced"</code>,
<code>"permutation"</code>, or <code>"antithetic"</code>.</p>
</td></tr>
<tr><td><code id="bootpls_+3A_stype">stype</code></td>
<td>
<p>A character string indicating what the second argument of
<code>statistic</code> represents. Possible values of stype are <code>"i"</code>
(indices - the default), <code>"f"</code> (frequencies), or <code>"w"</code> (weights).</p>
</td></tr>
<tr><td><code id="bootpls_+3A_stabvalue">stabvalue</code></td>
<td>
<p>A value to hard threshold bootstrap estimates computed from
atypical resamplings. Especially useful for Generalized Linear Models.</p>
</td></tr>
<tr><td><code id="bootpls_+3A_verbose">verbose</code></td>
<td>
<p>should info messages be displayed ?</p>
</td></tr>
<tr><td><code id="bootpls_+3A_...">...</code></td>
<td>
<p>Other named arguments for <code>statistic</code> which are passed
unchanged each time it is called. Any such arguments to <code>statistic</code>
should follow the arguments which <code>statistic</code> is required to have for
the simulation. Beware of partial matching to arguments of <code>boot</code>
listed above.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>More details on bootstrap techniques are available in the help of the
<code><a href="boot.html#topic+boot">boot</a></code> function.
</p>


<h3>Value</h3>

<p>An object of class <code>"boot"</code>. See the Value part of the help of
the function <code><a href="boot.html#topic+boot">boot</a></code>.
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>References</h3>

<p>A. Lazraq, R. Cleroux, and J.-P. Gauchi. (2003). Selecting both
latent and explanatory variables in the PLS1 regression model.
<em>Chemometrics and Intelligent Laboratory Systems</em>, 66(2):117-126.<br /> P.
Bastien, V. Esposito-Vinzi, and M. Tenenhaus. (2005). PLS generalised linear
regression. <em>Computational Statistics &amp; Data Analysis</em>, 48(1):17-46.<br />
A. C. Davison and D. V. Hinkley. (1997). <em>Bootstrap Methods and Their
Applications</em>. Cambridge University Press, Cambridge.
</p>


<h3>See Also</h3>

<p><code><a href="boot.html#topic+boot">boot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Cornell)
XCornell&lt;-Cornell[,1:7]
yCornell&lt;-Cornell[,8]

# Lazraq-Cleroux PLS ordinary bootstrap
set.seed(250)
modpls &lt;- plsR(yCornell,XCornell,3)

#(Y,X) resampling
Cornell.bootYX &lt;- bootpls(modpls, R=250, verbose=FALSE)

#(Y,T) resampling
Cornell.bootYT &lt;- bootpls(modpls, typeboot="fmodel_np", R=250, verbose=FALSE)

# Using the boxplots.bootpls function
boxplots.bootpls(Cornell.bootYX,indices=2:8)
# Confidence intervals plotting
confints.bootpls(Cornell.bootYX,indices=2:8)
plots.confints.bootpls(confints.bootpls(Cornell.bootYX,indices=2:8))
# Graph similar to the one of Bastien et al. in CSDA 2005
boxplot(as.vector(Cornell.bootYX$t[,-1])~factor(rep(1:7,rep(250,7))), 
main="Bootstrap distributions of standardised bj (j = 1, ..., 7).")
points(c(1:7),Cornell.bootYX$t0[-1],col="red",pch=19)



library(boot)
boot.ci(Cornell.bootYX, conf = c(0.90,0.95), type = c("norm","basic","perc","bca"), index=2)
plot(Cornell.bootYX,index=2)
jack.after.boot(Cornell.bootYX, index=2, useJ=TRUE, nt=3)
plot(Cornell.bootYX,index=2,jack=TRUE)

car::dataEllipse(Cornell.bootYX$t[,2], Cornell.bootYX$t[,3], cex=.3, 
levels=c(.5, .95, .99), robust=TRUE)
rm(Cornell.bootYX)


# PLS balanced bootstrap

set.seed(225)
Cornell.bootYX &lt;- bootpls(modpls, sim="balanced", R=250, verbose=FALSE)
boot.array(Cornell.bootYX, indices=TRUE)

# Using the boxplots.bootpls function
boxplots.bootpls(Cornell.bootYX,indices=2:8)
# Confidence intervals plotting
confints.bootpls(Cornell.bootYX,indices=2:8)
plots.confints.bootpls(confints.bootpls(Cornell.bootYX,indices=2:8))
# Graph similar to the one of Bastien et al. in CSDA 2005
boxplot(as.vector(Cornell.bootYX$t[,-1])~factor(rep(1:7,rep(250,7))), 
main="Bootstrap distributions of standardised bj (j = 1, ..., 7).")
points(c(1:7),Cornell.bootYX$t0[-1],col="red",pch=19)


library(boot)
boot.ci(Cornell.bootYX, conf = c(0.90,0.95), type = c("norm","basic","perc","bca"), 
index=2, verbose=FALSE)
plot(Cornell.bootYX,index=2)
jack.after.boot(Cornell.bootYX, index=2, useJ=TRUE, nt=3)
plot(Cornell.bootYX,index=2,jack=TRUE)

rm(Cornell.bootYX)

# PLS permutation bootstrap

set.seed(500)
Cornell.bootYX &lt;- bootpls(modpls, sim="permutation", R=1000, verbose=FALSE)
boot.array(Cornell.bootYX, indices=TRUE)


# Graph of bootstrap distributions
boxplot(as.vector(Cornell.bootYX$t[,-1])~factor(rep(1:7,rep(1000,7))),
main="Bootstrap distributions of standardised bj (j = 1, ..., 7).")
points(c(1:7),Cornell.bootYX$t0[-1],col="red",pch=19)
# Using the boxplots.bootpls function
boxplots.bootpls(Cornell.bootYX,indices=2:8)


library(boot)
plot(Cornell.bootYX,index=2)

qqnorm(Cornell.bootYX$t[,2],ylim=c(-1,1))
abline(h=Cornell.bootYX$t0[2],lty=2)
(sum(abs(Cornell.bootYX$t[,2])&gt;=abs(Cornell.bootYX$t0[2]))+1)/(length(Cornell.bootYX$t[,2])+1)

rm(Cornell.bootYX)


</code></pre>

<hr>
<h2 id='bootplsglm'>Non-parametric Bootstrap for PLS generalized linear models</h2><span id='topic+bootplsglm'></span>

<h3>Description</h3>

<p>Provides a wrapper for the bootstrap function <code>boot</code> from the
<code>boot</code> R package.<br /> Implements non-parametric bootstraps for PLS
Generalized Linear Regression models by either (Y,X) or (Y,T) resampling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootplsglm(
  object,
  typeboot = "fmodel_np",
  R = 250,
  statistic = NULL,
  sim = "ordinary",
  stype = "i",
  stabvalue = 1e+06,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootplsglm_+3A_object">object</code></td>
<td>
<p>An object of class <code>plsRglmmodel</code> to bootstrap</p>
</td></tr>
<tr><td><code id="bootplsglm_+3A_typeboot">typeboot</code></td>
<td>
<p>The type of bootstrap. Either (Y,X) boostrap
(<code>typeboot="plsmodel"</code>) or (Y,T) bootstrap
(<code>typeboot="fmodel_np"</code>). Defaults to (Y,T) resampling.</p>
</td></tr>
<tr><td><code id="bootplsglm_+3A_r">R</code></td>
<td>
<p>The number of bootstrap replicates. Usually this will be a single
positive integer. For importance resampling, some resamples may use one set
of weights and others use a different set of weights. In this case <code>R</code>
would be a vector of integers where each component gives the number of
resamples from each of the rows of weights.</p>
</td></tr>
<tr><td><code id="bootplsglm_+3A_statistic">statistic</code></td>
<td>
<p>A function which when applied to data returns a vector
containing the statistic(s) of interest. <code>statistic</code> must take at least
two arguments. The first argument passed will always be the original data.
The second will be a vector of indices, frequencies or weights which define
the bootstrap sample. Further, if predictions are required, then a third
argument is required which would be a vector of the random indices used to
generate the bootstrap predictions. Any further arguments can be passed to
statistic through the <code>...</code> argument.</p>
</td></tr>
<tr><td><code id="bootplsglm_+3A_sim">sim</code></td>
<td>
<p>A character string indicating the type of simulation required.
Possible values are <code>"ordinary"</code> (the default), <code>"balanced"</code>,
<code>"permutation"</code>, or <code>"antithetic"</code>.</p>
</td></tr>
<tr><td><code id="bootplsglm_+3A_stype">stype</code></td>
<td>
<p>A character string indicating what the second argument of
<code>statistic</code> represents. Possible values of stype are <code>"i"</code>
(indices - the default), <code>"f"</code> (frequencies), or <code>"w"</code> (weights).</p>
</td></tr>
<tr><td><code id="bootplsglm_+3A_stabvalue">stabvalue</code></td>
<td>
<p>A value to hard threshold bootstrap estimates computed from
atypical resamplings. Especially useful for Generalized Linear Models.</p>
</td></tr>
<tr><td><code id="bootplsglm_+3A_verbose">verbose</code></td>
<td>
<p>should info messages be displayed ?</p>
</td></tr>
<tr><td><code id="bootplsglm_+3A_...">...</code></td>
<td>
<p>Other named arguments for <code>statistic</code> which are passed
unchanged each time it is called. Any such arguments to <code>statistic</code>
should follow the arguments which <code>statistic</code> is required to have for
the simulation. Beware of partial matching to arguments of <code>boot</code>
listed above.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>More details on bootstrap techniques are available in the help of the
<code><a href="boot.html#topic+boot">boot</a></code> function.
</p>


<h3>Value</h3>

<p>An object of class <code>"boot"</code>. See the Value part of the help of
the function <code><a href="boot.html#topic+boot">boot</a></code>.
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>References</h3>

<p>A. Lazraq, R. Cleroux, and J.-P. Gauchi. (2003). Selecting both
latent and explanatory variables in the PLS1 regression model.
<em>Chemometrics and Intelligent Laboratory Systems</em>, 66(2):117-126.<br /> P.
Bastien, V. Esposito-Vinzi, and M. Tenenhaus. (2005). PLS generalised linear
regression. <em>Computational Statistics &amp; Data Analysis</em>, 48(1):17-46.<br />
A. C. Davison and D. V. Hinkley. (1997). <em>Bootstrap Methods and Their
Applications</em>. Cambridge University Press, Cambridge.
</p>


<h3>See Also</h3>

<p><code><a href="boot.html#topic+boot">boot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Imputed aze dataset
data(aze_compl)
Xaze_compl&lt;-aze_compl[,2:34]
yaze_compl&lt;-aze_compl$y

dataset &lt;- cbind(y=yaze_compl,Xaze_compl)
modplsglm &lt;- plsRglm(y~.,data=dataset,3,modele="pls-glm-logistic")

library(boot)
# Bastien (Y,T) PLS bootstrap
aze_compl.bootYT &lt;- bootplsglm(modplsglm, R=250, verbose=FALSE)
boxplots.bootpls(aze_compl.bootYT)
confints.bootpls(aze_compl.bootYT)
plots.confints.bootpls(confints.bootpls(aze_compl.bootYT))


# (Y,X) PLS bootstrap
aze_compl.bootYX &lt;- bootplsglm(modplsglm, R=250, verbose=FALSE, 
typeboot = "plsmodel")
boxplots.bootpls(aze_compl.bootYX)
confints.bootpls(aze_compl.bootYX)
plots.confints.bootpls(confints.bootpls(aze_compl.bootYX))

# (Y,X) PLS bootstrap raw coefficients
aze_compl.bootYX.raw &lt;- bootplsglm(modplsglm, R=250, verbose=FALSE, 
typeboot = "plsmodel", statistic=coefs.plsRglm.raw)
boxplots.bootpls(aze_compl.bootYX.raw)
confints.bootpls(aze_compl.bootYX.raw)
plots.confints.bootpls(confints.bootpls(aze_compl.bootYX.raw))

plot(aze_compl.bootYT,index=2)
jack.after.boot(aze_compl.bootYT, index=2, useJ=TRUE, nt=3)
plot(aze_compl.bootYT, index=2,jack=TRUE)
aze_compl.tilt.boot &lt;- tilt.bootplsglm(modplsglm, statistic=coefs.plsRglm, 
R=c(499, 100, 100), alpha=c(0.025, 0.975), sim="ordinary", stype="i", index=1)

# PLS bootstrap balanced
aze_compl.bootYT &lt;- bootplsglm(modplsglm, sim="balanced", R=250, verbose=FALSE)
boxplots.bootpls(aze_compl.bootYT)
confints.bootpls(aze_compl.bootYT)
plots.confints.bootpls(confints.bootpls(aze_compl.bootYT))


plot(aze_compl.bootYT)
jack.after.boot(aze_compl.bootYT, index=1, useJ=TRUE, nt=3)
plot(aze_compl.bootYT,jack=TRUE)
aze_compl.tilt.boot &lt;- tilt.bootplsglm(modplsglm, statistic=coefs.plsR,
R=c(499, 100, 100), alpha=c(0.025, 0.975), sim="balanced", stype="i", index=1)


# PLS permutation bootstrap

aze_compl.bootYT &lt;- bootplsglm(modplsglm, sim="permutation", R=250, verbose=FALSE)
boxplots.bootpls(aze_compl.bootYT)
plot(aze_compl.bootYT)


#Original aze dataset with missing values
data(aze)
Xaze&lt;-aze[,2:34]
yaze&lt;-aze$y

library(boot)
modplsglm2 &lt;- plsRglm(yaze,Xaze,3,modele="pls-glm-logistic")
aze.bootYT &lt;- bootplsglm(modplsglm2, R=250, verbose=FALSE)
boxplots.bootpls(aze.bootYT)
confints.bootpls(aze.bootYT)
plots.confints.bootpls(confints.bootpls(aze.bootYT))




#Ordinal logistic regression
data(bordeaux)
Xbordeaux&lt;-bordeaux[,1:4]
ybordeaux&lt;-factor(bordeaux$Quality,ordered=TRUE)
dataset &lt;- cbind(y=ybordeaux,Xbordeaux)
options(contrasts = c("contr.treatment", "contr.poly"))
modplsglm3 &lt;- plsRglm(ybordeaux,Xbordeaux,1,modele="pls-glm-polr")
bordeaux.bootYT&lt;- bootplsglm(modplsglm3, sim="permutation", R=250, verbose=FALSE)
boxplots.bootpls(bordeaux.bootYT)
boxplots.bootpls(bordeaux.bootYT,ranget0=TRUE)

bordeaux.bootYT2&lt;- bootplsglm(modplsglm3, sim="permutation", R=250, 
strata=unclass(ybordeaux), verbose=FALSE)
boxplots.bootpls(bordeaux.bootYT2,ranget0=TRUE)


if(require(chemometrics)){
data(hyptis)
hyptis
yhyptis &lt;- factor(hyptis$Group,ordered=TRUE)
Xhyptis &lt;- as.data.frame(hyptis[,c(1:6)])
dataset &lt;- cbind(y=yhyptis,Xhyptis)
options(contrasts = c("contr.treatment", "contr.poly"))
modplsglm4 &lt;- plsRglm(yhyptis,Xhyptis,3,modele="pls-glm-polr")
hyptis.bootYT3&lt;- bootplsglm(modplsglm4, sim="permutation", R=250, verbose=FALSE)
rownames(hyptis.bootYT3$t0)&lt;-c("Sabi\nnene","Pin\nene",
"Cine\nole","Terpi\nnene","Fenc\nhone","Terpi\nnolene")
boxplots.bootpls(hyptis.bootYT3)
boxplots.bootpls(hyptis.bootYT3,xaxisticks=FALSE)
boxplots.bootpls(hyptis.bootYT3,ranget0=TRUE)
boxplots.bootpls(hyptis.bootYT3,ranget0=TRUE,xaxisticks=FALSE)
}


</code></pre>

<hr>
<h2 id='bordeaux'>Quality of wine dataset</h2><span id='topic+bordeaux'></span>

<h3>Description</h3>

<p>Quality of Bordeaux wines (<code>Quality</code>) and four potentially predictive
variables (<code>Temperature</code>, <code>Sunshine</code>, <code>Heat</code> and
<code>Rain</code>).
</p>


<h3>Format</h3>

<p>A data frame with 34 observations on the following 5 variables.
</p>
 <dl>
<dt>Temperature</dt><dd><p>a numeric vector</p>
</dd>
<dt>Sunshine</dt><dd><p>a numeric vector</p>
</dd> <dt>Heat</dt><dd><p>a numeric
vector</p>
</dd> <dt>Rain</dt><dd><p>a numeric vector</p>
</dd> <dt>Quality</dt><dd><p>an
ordered factor with levels <code>1</code> &lt; <code>2</code> &lt; <code>3</code></p>
</dd> </dl>



<h3>Source</h3>

<p>P. Bastien, V. Esposito-Vinzi, and M. Tenenhaus. (2005). PLS
generalised linear regression. <em>Computational Statistics &amp; Data
Analysis</em>, 48(1):17-46.
</p>


<h3>References</h3>

<p>M. Tenenhaus. (2005). La regression logistique PLS. In J.-J.
Droesbeke, M. Lejeune, and G. Saporta, editors, Modeles statistiques pour
donnees qualitatives. Editions Technip, Paris.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(bordeaux)
str(bordeaux)

</code></pre>

<hr>
<h2 id='bordeauxNA'>Quality of wine dataset</h2><span id='topic+bordeauxNA'></span>

<h3>Description</h3>

<p>Quality of Bordeaux wines (<code>Quality</code>) and four potentially predictive
variables (<code>Temperature</code>, <code>Sunshine</code>, <code>Heat</code> and
<code>Rain</code>).
</p>


<h3>Format</h3>

<p>A data frame with 34 observations on the following 5 variables.
</p>
 <dl>
<dt>Temperature</dt><dd><p>a numeric vector</p>
</dd>
<dt>Sunshine</dt><dd><p>a numeric vector</p>
</dd> <dt>Heat</dt><dd><p>a numeric
vector</p>
</dd> <dt>Rain</dt><dd><p>a numeric vector</p>
</dd> <dt>Quality</dt><dd><p>an
ordered factor with levels <code>1</code> &lt; <code>2</code> &lt; <code>3</code></p>
</dd> </dl>



<h3>Details</h3>

<p>The value of x1 for the first observation was removed from the matrix of
predictors on purpose.
</p>
<p>The <code>bordeauxNA</code> is a dataset with a missing value for testing purpose.
</p>


<h3>Source</h3>

<p>P. Bastien, V. Esposito-Vinzi, and M. Tenenhaus. (2005). PLS
generalised linear regression. <em>Computational Statistics &amp; Data
Analysis</em>, 48(1):17-46.
</p>


<h3>References</h3>

<p>M. Tenenhaus. (2005). La regression logistique PLS. In J.-J.
Droesbeke, M. Lejeune, and G. Saporta, editors, Modeles statistiques pour
donnees qualitatives. Editions Technip, Paris.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(bordeauxNA)
str(bordeauxNA)

</code></pre>

<hr>
<h2 id='boxplots.bootpls'>Boxplot bootstrap distributions</h2><span id='topic+boxplots.bootpls'></span>

<h3>Description</h3>

<p>Boxplots for bootstrap distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boxplots.bootpls(
  bootobject,
  indices = NULL,
  prednames = TRUE,
  articlestyle = TRUE,
  xaxisticks = TRUE,
  ranget0 = FALSE,
  las = par("las"),
  mar,
  mgp,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boxplots.bootpls_+3A_bootobject">bootobject</code></td>
<td>
<p>a object of class <code>"boot"</code></p>
</td></tr>
<tr><td><code id="boxplots.bootpls_+3A_indices">indices</code></td>
<td>
<p>vector of indices of the variables to plot. Defaults to
<code>NULL</code>: all the predictors will be used.</p>
</td></tr>
<tr><td><code id="boxplots.bootpls_+3A_prednames">prednames</code></td>
<td>
<p>do the original names of the predictors shall be plotted ?
Defaults to <code>TRUE</code>: the names are plotted.</p>
</td></tr>
<tr><td><code id="boxplots.bootpls_+3A_articlestyle">articlestyle</code></td>
<td>
<p>do the extra blank zones of the margin shall be removed
from the plot ? Defaults to <code>TRUE</code>: the margins are removed.</p>
</td></tr>
<tr><td><code id="boxplots.bootpls_+3A_xaxisticks">xaxisticks</code></td>
<td>
<p>do ticks for the x axis shall be plotted ? Defaults to
<code>TRUE</code>: the ticks are plotted.</p>
</td></tr>
<tr><td><code id="boxplots.bootpls_+3A_ranget0">ranget0</code></td>
<td>
<p>does the vertival range of the plot shall be computed to
include the initial estimates of the coefficients ? Defaults to
<code>FALSE</code>: the vertical range is calculated only using the bootstrapped
values of the statistics. Especially using for permutation bootstrap.</p>
</td></tr>
<tr><td><code id="boxplots.bootpls_+3A_las">las</code></td>
<td>
<p>numeric in 0,1,2,3; the style of axis labels. 0: always parallel
to the axis [default], 1: always horizontal, 2: always perpendicular to the
axis, 3: always vertical.</p>
</td></tr>
<tr><td><code id="boxplots.bootpls_+3A_mar">mar</code></td>
<td>
<p>A numerical vector of the form <code>c(bottom, left, top, right)</code>
which gives the number of lines of margin to be specified on the four sides
of the plot. The default is <code>c(5, 4, 4, 2) + 0.1.</code></p>
</td></tr>
<tr><td><code id="boxplots.bootpls_+3A_mgp">mgp</code></td>
<td>
<p>The margin line (in mex units) for the axis title, axis labels
and axis line. Note that <code>mgp[1]</code> affects title whereas <code>mgp[2:3]</code>
affect axis. The default is <code>c(3, 1, 0)</code>.</p>
</td></tr>
<tr><td><code id="boxplots.bootpls_+3A_...">...</code></td>
<td>
<p>further options to pass to the
<code><a href="graphics.html#topic+boxplot">boxplot</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bootpls">bootpls</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Cornell)
XCornell&lt;-Cornell[,1:7]
yCornell&lt;-Cornell[,8]

# Lazraq-Cleroux PLS ordinary bootstrap
set.seed(250)
modpls &lt;- plsR(yCornell,XCornell,3)
Cornell.bootYX &lt;- bootpls(modpls, R=250)

# Graph similar to the one of Bastien et al. in CSDA 2005
boxplots.bootpls(Cornell.bootYX,indices=2:8)


data(aze_compl)
modplsglm&lt;-plsRglm(y~.,data=aze_compl,3,modele="pls-glm-logistic")
aze_compl.boot3 &lt;- bootplsglm(modplsglm, R=250, verbose=FALSE)
boxplots.bootpls(aze_compl.boot3)
boxplots.bootpls(aze_compl.boot3,las=3,mar=c(5,2,1,1))
boxplots.bootpls(aze_compl.boot3,indices=c(2,4,6),prednames=FALSE)


</code></pre>

<hr>
<h2 id='coef.plsRglmmodel'>coef method for plsR models</h2><span id='topic+coef.plsRglmmodel'></span>

<h3>Description</h3>

<p>This function provides a coef method for the class <code>"plsRglmmodel"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'plsRglmmodel'
coef(object, type = c("scaled", "original"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.plsRglmmodel_+3A_object">object</code></td>
<td>
<p>an object of the class <code>"plsRglmmodel"</code></p>
</td></tr>
<tr><td><code id="coef.plsRglmmodel_+3A_type">type</code></td>
<td>
<p>if <code>scaled</code>, the coefficients of the predictors are given
for the scaled predictors, if <code>original</code> the coefficients are to be
used with the predictors on their original scale.</p>
</td></tr>
<tr><td><code id="coef.plsRglmmodel_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>coef.plsRglmmodel</code>.<br />
</p>
<table>
<tr><td><code>CoeffC</code></td>
<td>
<p>Coefficients of the components.</p>
</td></tr>
<tr><td><code>Std.Coeffs</code></td>
<td>
<p>Coefficients of the scaled predictors in the regression
function.</p>
</td></tr> <tr><td><code>Coeffs</code></td>
<td>
<p>Coefficients of the untransformed predictors (on
their original scale).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+coef">coef</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Cornell)
XCornell&lt;-Cornell[,1:7]
yCornell&lt;-Cornell[,8]
modpls &lt;- plsRglm(yCornell,XCornell,3,modele="pls-glm-family",family=gaussian())
class(modpls)
coef(modpls)
coef(modpls,type="scaled")
rm(list=c("XCornell","yCornell","modpls"))

</code></pre>

<hr>
<h2 id='coef.plsRmodel'>coef method for plsR models</h2><span id='topic+coef.plsRmodel'></span>

<h3>Description</h3>

<p>This function provides a coef method for the class <code>"plsRmodel"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'plsRmodel'
coef(object, type = c("scaled", "original"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.plsRmodel_+3A_object">object</code></td>
<td>
<p>an object of the class <code>"plsRmodel"</code></p>
</td></tr>
<tr><td><code id="coef.plsRmodel_+3A_type">type</code></td>
<td>
<p>if <code>scaled</code>, the coefficients of the predictors are given
for the scaled predictors, if <code>original</code> the coefficients are to be
used with the predictors on their original scale.</p>
</td></tr>
<tr><td><code id="coef.plsRmodel_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>coef.plsRmodel</code>.<br />
</p>
<table>
<tr><td><code>CoeffC</code></td>
<td>
<p>Coefficients of the components.</p>
</td></tr>
<tr><td><code>Std.Coeffs</code></td>
<td>
<p>Coefficients of the scaled predictors.</p>
</td></tr>
<tr><td><code>Coeffs</code></td>
<td>
<p>Coefficients of the untransformed predictors (on their
original scale).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+coef">coef</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Cornell)
XCornell&lt;-Cornell[,1:7]
yCornell&lt;-Cornell[,8]
modpls &lt;- plsRglm(yCornell,XCornell,3,modele="pls")
class(modpls)
coef(modpls)
coef(modpls,type="scaled")
rm(list=c("XCornell","yCornell","modpls"))

</code></pre>

<hr>
<h2 id='coefs.plsR'>Coefficients for bootstrap computations of PLSR models</h2><span id='topic+coefs.plsR'></span>

<h3>Description</h3>

<p>A function passed to <code>boot</code> to perform bootstrap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coefs.plsR(dataset, ind, nt, modele, maxcoefvalues, ifbootfail, verbose)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coefs.plsR_+3A_dataset">dataset</code></td>
<td>
<p>dataset to resample</p>
</td></tr>
<tr><td><code id="coefs.plsR_+3A_ind">ind</code></td>
<td>
<p>indices for resampling</p>
</td></tr>
<tr><td><code id="coefs.plsR_+3A_nt">nt</code></td>
<td>
<p>number of components to use</p>
</td></tr>
<tr><td><code id="coefs.plsR_+3A_modele">modele</code></td>
<td>
<p>type of modele to use, see <a href="#topic+plsR">plsR</a></p>
</td></tr>
<tr><td><code id="coefs.plsR_+3A_maxcoefvalues">maxcoefvalues</code></td>
<td>
<p>maximum values allowed for the estimates of the
coefficients to discard those coming from singular bootstrap samples</p>
</td></tr>
<tr><td><code id="coefs.plsR_+3A_ifbootfail">ifbootfail</code></td>
<td>
<p>value to return if the estimation fails on a bootstrap
sample</p>
</td></tr>
<tr><td><code id="coefs.plsR_+3A_verbose">verbose</code></td>
<td>
<p>should info messages be displayed ?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>estimates on a bootstrap sample or <code>ifbootfail</code> value if the
bootstrap computation fails.
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+bootpls">bootpls</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Cornell)
XCornell&lt;-Cornell[,1:7]
yCornell&lt;-Cornell[,8]

# Lazraq-Cleroux PLS (Y,X) bootstrap
# statistic=coefs.plsR is the default for (Y,X) resampling of PLSR models.
set.seed(250)
modpls &lt;- plsR(yCornell,XCornell,1)
Cornell.bootYX &lt;- bootpls(modpls, R=250, statistic=coefs.plsR, verbose=FALSE)

</code></pre>

<hr>
<h2 id='coefs.plsR.raw'>Raw coefficients for bootstrap computations of PLSR models</h2><span id='topic+coefs.plsR.raw'></span>

<h3>Description</h3>

<p>A function passed to <code>boot</code> to perform bootstrap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coefs.plsR.raw(dataset, ind, nt, modele, maxcoefvalues, ifbootfail, verbose)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coefs.plsR.raw_+3A_dataset">dataset</code></td>
<td>
<p>dataset to resample</p>
</td></tr>
<tr><td><code id="coefs.plsR.raw_+3A_ind">ind</code></td>
<td>
<p>indices for resampling</p>
</td></tr>
<tr><td><code id="coefs.plsR.raw_+3A_nt">nt</code></td>
<td>
<p>number of components to use</p>
</td></tr>
<tr><td><code id="coefs.plsR.raw_+3A_modele">modele</code></td>
<td>
<p>type of modele to use, see <a href="#topic+plsR">plsR</a></p>
</td></tr>
<tr><td><code id="coefs.plsR.raw_+3A_maxcoefvalues">maxcoefvalues</code></td>
<td>
<p>maximum values allowed for the estimates of the
coefficients to discard those coming from singular bootstrap samples</p>
</td></tr>
<tr><td><code id="coefs.plsR.raw_+3A_ifbootfail">ifbootfail</code></td>
<td>
<p>value to return if the estimation fails on a bootstrap
sample</p>
</td></tr>
<tr><td><code id="coefs.plsR.raw_+3A_verbose">verbose</code></td>
<td>
<p>should info messages be displayed ?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>estimates on a bootstrap sample or <code>ifbootfail</code> value if the
bootstrap computation fails.
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+bootpls">bootpls</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Cornell)
XCornell&lt;-Cornell[,1:7]
yCornell&lt;-Cornell[,8]

# Lazraq-Cleroux PLS (Y,X) bootstrap
set.seed(250)
modpls &lt;- coefs.plsR.raw(Cornell[,-8],1:nrow(Cornell),nt=3,
maxcoefvalues=1e5,ifbootfail=rep(0,3),verbose=FALSE)

</code></pre>

<hr>
<h2 id='coefs.plsRglm'>Coefficients for bootstrap computations of PLSGLR models</h2><span id='topic+coefs.plsRglm'></span>

<h3>Description</h3>

<p>A function passed to <code>boot</code> to perform bootstrap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coefs.plsRglm(
  dataset,
  ind,
  nt,
  modele,
  family = NULL,
  maxcoefvalues,
  ifbootfail,
  verbose
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coefs.plsRglm_+3A_dataset">dataset</code></td>
<td>
<p>dataset to resample</p>
</td></tr>
<tr><td><code id="coefs.plsRglm_+3A_ind">ind</code></td>
<td>
<p>indices for resampling</p>
</td></tr>
<tr><td><code id="coefs.plsRglm_+3A_nt">nt</code></td>
<td>
<p>number of components to use</p>
</td></tr>
<tr><td><code id="coefs.plsRglm_+3A_modele">modele</code></td>
<td>
<p>type of modele to use, see <a href="#topic+plsRglm">plsRglm</a></p>
</td></tr>
<tr><td><code id="coefs.plsRglm_+3A_family">family</code></td>
<td>
<p>glm family to use, see <a href="#topic+plsRglm">plsRglm</a></p>
</td></tr>
<tr><td><code id="coefs.plsRglm_+3A_maxcoefvalues">maxcoefvalues</code></td>
<td>
<p>maximum values allowed for the estimates of the
coefficients to discard those coming from singular bootstrap samples</p>
</td></tr>
<tr><td><code id="coefs.plsRglm_+3A_ifbootfail">ifbootfail</code></td>
<td>
<p>value to return if the estimation fails on a bootstrap
sample</p>
</td></tr>
<tr><td><code id="coefs.plsRglm_+3A_verbose">verbose</code></td>
<td>
<p>should info messages be displayed ?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>estimates on a bootstrap sample or <code>ifbootfail</code> value if the
bootstrap computation fails.
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+bootplsglm">bootplsglm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Cornell)

# (Y,X) bootstrap of a PLSGLR model
# statistic=coefs.plsRglm is the default for (Y,X) bootstrap of a PLSGLR models.
set.seed(250)
modplsglm &lt;- plsRglm(Y~.,data=Cornell,1,modele="pls-glm-family",family=gaussian)
Cornell.bootYX &lt;- bootplsglm(modplsglm, R=250, typeboot="plsmodel", 
statistic=coefs.plsRglm, verbose=FALSE)

</code></pre>

<hr>
<h2 id='coefs.plsRglm.raw'>Raw coefficients for bootstrap computations of PLSGLR models</h2><span id='topic+coefs.plsRglm.raw'></span>

<h3>Description</h3>

<p>A function passed to <code>boot</code> to perform bootstrap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coefs.plsRglm.raw(
  dataset,
  ind,
  nt,
  modele,
  family = NULL,
  maxcoefvalues,
  ifbootfail,
  verbose
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coefs.plsRglm.raw_+3A_dataset">dataset</code></td>
<td>
<p>dataset to resample</p>
</td></tr>
<tr><td><code id="coefs.plsRglm.raw_+3A_ind">ind</code></td>
<td>
<p>indices for resampling</p>
</td></tr>
<tr><td><code id="coefs.plsRglm.raw_+3A_nt">nt</code></td>
<td>
<p>number of components to use</p>
</td></tr>
<tr><td><code id="coefs.plsRglm.raw_+3A_modele">modele</code></td>
<td>
<p>type of modele to use, see <a href="#topic+plsRglm">plsRglm</a></p>
</td></tr>
<tr><td><code id="coefs.plsRglm.raw_+3A_family">family</code></td>
<td>
<p>glm family to use, see <a href="#topic+plsRglm">plsRglm</a></p>
</td></tr>
<tr><td><code id="coefs.plsRglm.raw_+3A_maxcoefvalues">maxcoefvalues</code></td>
<td>
<p>maximum values allowed for the estimates of the
coefficients to discard those coming from singular bootstrap samples</p>
</td></tr>
<tr><td><code id="coefs.plsRglm.raw_+3A_ifbootfail">ifbootfail</code></td>
<td>
<p>value to return if the estimation fails on a bootstrap
sample</p>
</td></tr>
<tr><td><code id="coefs.plsRglm.raw_+3A_verbose">verbose</code></td>
<td>
<p>should info messages be displayed ?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>estimates on a bootstrap sample or <code>ifbootfail</code> value if the
bootstrap computation fails.
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+bootplsglm">bootplsglm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Cornell)

# (Y,X) bootstrap of a PLSGLR model
set.seed(250)
modplsglm &lt;- coefs.plsRglm.raw(Cornell[,-8],1:nrow(Cornell),nt=3,
modele="pls-glm-family",family=gaussian,maxcoefvalues=1e5,
ifbootfail=rep(0,3),verbose=FALSE)

</code></pre>

<hr>
<h2 id='coefs.plsRglmnp'>Coefficients for bootstrap computations of PLSGLR models</h2><span id='topic+coefs.plsRglmnp'></span>

<h3>Description</h3>

<p>A function passed to <code>boot</code> to perform bootstrap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coefs.plsRglmnp(
  dataRepYtt,
  ind,
  nt,
  modele,
  family = NULL,
  maxcoefvalues,
  wwetoile,
  ifbootfail
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coefs.plsRglmnp_+3A_datarepytt">dataRepYtt</code></td>
<td>
<p>components' coordinates to bootstrap</p>
</td></tr>
<tr><td><code id="coefs.plsRglmnp_+3A_ind">ind</code></td>
<td>
<p>indices for resampling</p>
</td></tr>
<tr><td><code id="coefs.plsRglmnp_+3A_nt">nt</code></td>
<td>
<p>number of components to use</p>
</td></tr>
<tr><td><code id="coefs.plsRglmnp_+3A_modele">modele</code></td>
<td>
<p>type of modele to use, see <a href="#topic+plsRglm">plsRglm</a></p>
</td></tr>
<tr><td><code id="coefs.plsRglmnp_+3A_family">family</code></td>
<td>
<p>glm family to use, see <a href="#topic+plsRglm">plsRglm</a></p>
</td></tr>
<tr><td><code id="coefs.plsRglmnp_+3A_maxcoefvalues">maxcoefvalues</code></td>
<td>
<p>maximum values allowed for the estimates of the
coefficients to discard those coming from singular bootstrap samples</p>
</td></tr>
<tr><td><code id="coefs.plsRglmnp_+3A_wwetoile">wwetoile</code></td>
<td>
<p>values of the Wstar matrix in the original fit</p>
</td></tr>
<tr><td><code id="coefs.plsRglmnp_+3A_ifbootfail">ifbootfail</code></td>
<td>
<p>value to return if the estimation fails on a bootstrap
sample</p>
</td></tr>
</table>


<h3>Value</h3>

<p>estimates on a bootstrap sample or <code>ifbootfail</code> value if the
bootstrap computation fails.
</p>


<h3>Note</h3>

<p>~~some notes~~
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+bootplsglm">bootplsglm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Cornell)

# (Y,X) bootstrap of a PLSGLR model
# statistic=coefs.plsRglm is the default for (Y,X) bootstrap of a PLSGLR models.
set.seed(250)
modplsglm &lt;- plsRglm(Y~.,data=Cornell,1,modele="pls-glm-family",family=gaussian)
Cornell.bootYT &lt;- bootplsglm(modplsglm, R=250, statistic=coefs.plsRglmnp, verbose=FALSE)

</code></pre>

<hr>
<h2 id='coefs.plsRnp'>Coefficients for bootstrap computations of PLSR models</h2><span id='topic+coefs.plsRnp'></span>

<h3>Description</h3>

<p>A function passed to <code>boot</code> to perform bootstrap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coefs.plsRnp(dataRepYtt, ind, nt, modele, maxcoefvalues, wwetoile, ifbootfail)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coefs.plsRnp_+3A_datarepytt">dataRepYtt</code></td>
<td>
<p>components' coordinates to bootstrap</p>
</td></tr>
<tr><td><code id="coefs.plsRnp_+3A_ind">ind</code></td>
<td>
<p>indices for resampling</p>
</td></tr>
<tr><td><code id="coefs.plsRnp_+3A_nt">nt</code></td>
<td>
<p>number of components to use</p>
</td></tr>
<tr><td><code id="coefs.plsRnp_+3A_modele">modele</code></td>
<td>
<p>type of modele to use, see <a href="#topic+plsRglm">plsRglm</a></p>
</td></tr>
<tr><td><code id="coefs.plsRnp_+3A_maxcoefvalues">maxcoefvalues</code></td>
<td>
<p>maximum values allowed for the estimates of the
coefficients to discard those coming from singular bootstrap samples</p>
</td></tr>
<tr><td><code id="coefs.plsRnp_+3A_wwetoile">wwetoile</code></td>
<td>
<p>values of the Wstar matrix in the original fit</p>
</td></tr>
<tr><td><code id="coefs.plsRnp_+3A_ifbootfail">ifbootfail</code></td>
<td>
<p>value to return if the estimation fails on a bootstrap
sample</p>
</td></tr>
</table>


<h3>Value</h3>

<p>estimates on a bootstrap sample or <code>ifbootfail</code> value if the
bootstrap computation fails.
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+bootpls">bootpls</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Cornell)
XCornell&lt;-Cornell[,1:7]
yCornell&lt;-Cornell[,8]

# Lazraq-Cleroux PLS (Y,X) bootstrap
# statistic=coefs.plsR is the default for (Y,X) resampling of PLSR models.
set.seed(250)
modpls &lt;- plsR(yCornell,XCornell,1)
Cornell.bootYT &lt;- bootpls(modpls, R=250, typeboot="fmodel_np",
statistic=coefs.plsRnp, verbose=FALSE)

</code></pre>

<hr>
<h2 id='confints.bootpls'>Bootstrap confidence intervals</h2><span id='topic+confints.bootpls'></span>

<h3>Description</h3>

<p>This function is a wrapper for <code><a href="boot.html#topic+boot.ci">boot.ci</a></code> to derive
bootstrap-based confidence intervals from a <code>"boot"</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>confints.bootpls(bootobject, indices = NULL, typeBCa = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confints.bootpls_+3A_bootobject">bootobject</code></td>
<td>
<p>an object of class <code>"boot"</code></p>
</td></tr>
<tr><td><code id="confints.bootpls_+3A_indices">indices</code></td>
<td>
<p>the indices of the predictor for which CIs should be
calculated. Defaults to <code>NULL</code>: all the predictors will be used.</p>
</td></tr>
<tr><td><code id="confints.bootpls_+3A_typebca">typeBCa</code></td>
<td>
<p>shall BCa bootstrap based CI derived ? Defaults to
<code>TRUE</code>. This is a safety option since sometimes computing BCa bootstrap
based CI fails whereas the other types of CI can still be derived.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix with the limits of bootstrap based CI for all (defaults) or
only the selected predictors (<code>indices</code> option). The limits are given
in that order: Normal Lower then Upper Limit, Basic Lower then Upper Limit,
Percentile Lower then Upper Limit, BCa Lower then Upper Limit.
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+bootpls">bootpls</a></code> and <code><a href="#topic+bootplsglm">bootplsglm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(Cornell)

#Lazraq-Cleroux PLS (Y,X) bootstrap
set.seed(250)
modpls &lt;- plsR(Y~.,data=Cornell,3)
Cornell.bootYX &lt;- bootpls(modpls, R=250, verbose=FALSE)
confints.bootpls(Cornell.bootYX,2:8)
confints.bootpls(Cornell.bootYX,2:8,typeBCa=FALSE)


</code></pre>

<hr>
<h2 id='CorMat'>Correlation matrix for simulating plsR datasets</h2><span id='topic+CorMat'></span>

<h3>Description</h3>

<p>A correlation matrix to simulate datasets
</p>


<h3>Format</h3>

<p>A data frame with 17 observations on the following 17 variables.
</p>
 <dl>
<dt>y</dt><dd><p>a numeric vector</p>
</dd> <dt>x11</dt><dd><p>a numeric
vector</p>
</dd> <dt>x12</dt><dd><p>a numeric vector</p>
</dd> <dt>x13</dt><dd><p>a numeric
vector</p>
</dd> <dt>x21</dt><dd><p>a numeric vector</p>
</dd> <dt>x22</dt><dd><p>a numeric
vector</p>
</dd> <dt>x31</dt><dd><p>a numeric vector</p>
</dd> <dt>x32</dt><dd><p>a numeric
vector</p>
</dd> <dt>x33</dt><dd><p>a numeric vector</p>
</dd> <dt>x34</dt><dd><p>a numeric
vector</p>
</dd> <dt>x41</dt><dd><p>a numeric vector</p>
</dd> <dt>x42</dt><dd><p>a numeric
vector</p>
</dd> <dt>x51</dt><dd><p>a numeric vector</p>
</dd> <dt>x61</dt><dd><p>a numeric
vector</p>
</dd> <dt>x62</dt><dd><p>a numeric vector</p>
</dd> <dt>x63</dt><dd><p>a numeric
vector</p>
</dd> <dt>x64</dt><dd><p>a numeric vector</p>
</dd> </dl>



<h3>Source</h3>

<p>Handmade.
</p>


<h3>References</h3>

<p>Nicolas Meyer, Myriam Maumy-Bertrand et
Frédéric Bertrand (2010). Comparing the linear and the
logistic PLS regression with qualitative predictors: application to
allelotyping data. <em>Journal de la Societe Francaise de Statistique</em>,
151(2), pages 1-18.
<a href="http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47">http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(CorMat)
str(CorMat)

</code></pre>

<hr>
<h2 id='Cornell'>Cornell dataset</h2><span id='topic+Cornell'></span>

<h3>Description</h3>

<p>The famous Cornell dataset. A mixture experiment on <code>X1</code>, <code>X2</code>,
<code>X3</code>, <code>X4</code>, <code>X5</code>, <code>X6</code> and <code>X7</code> to analyse octane
degree (<code>Y</code>) in gazoline.
</p>


<h3>Format</h3>

<p>A data frame with 12 observations on the following 8 variables.
</p>
 <dl>
<dt>X1</dt><dd><p>a numeric vector</p>
</dd> <dt>X2</dt><dd><p>a numeric
vector</p>
</dd> <dt>X3</dt><dd><p>a numeric vector</p>
</dd> <dt>X4</dt><dd><p>a numeric
vector</p>
</dd> <dt>X5</dt><dd><p>a numeric vector</p>
</dd> <dt>X6</dt><dd><p>a numeric
vector</p>
</dd> <dt>X7</dt><dd><p>a numeric vector</p>
</dd> <dt>Y</dt><dd><p>response value:
a numeric vector</p>
</dd> </dl>



<h3>Source</h3>

<p>M. Tenenhaus. (1998). <em>La regression PLS, Theorie et pratique</em>.
Editions Technip, Paris.
</p>


<h3>References</h3>

<p>N. Kettaneh-Wold. Analysis of mixture data with partial least
squares. (1992). <em>Chemometrics and Intelligent Laboratory Systems</em>,
14(1):57-69.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Cornell)
str(Cornell)

</code></pre>

<hr>
<h2 id='cv.plsR'>Partial least squares regression models with k-fold cross-validation</h2><span id='topic+cv.plsR'></span><span id='topic+cv.plsRmodel.default'></span><span id='topic+cv.plsRmodel.formula'></span><span id='topic+PLS_lm_kfoldcv'></span><span id='topic+PLS_lm_kfoldcv_formula'></span>

<h3>Description</h3>

<p>This function implements k-fold cross-validation on complete or incomplete datasets for partial least squares regression models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.plsR(object, ...)
## Default S3 method:
cv.plsRmodel(object,dataX,nt=2,limQ2set=.0975,modele="pls", 
K=5, NK=1, grouplist=NULL, random=TRUE, scaleX=TRUE, 
scaleY=NULL, keepcoeffs=FALSE, keepfolds=FALSE, keepdataY=TRUE, 
keepMclassed=FALSE, tol_Xi=10^(-12), weights, verbose=TRUE,...)
## S3 method for class 'formula'
cv.plsRmodel(object,data=NULL,nt=2,limQ2set=.0975,modele="pls", 
K=5, NK=1, grouplist=NULL, random=TRUE, scaleX=TRUE, 
scaleY=NULL, keepcoeffs=FALSE, keepfolds=FALSE, keepdataY=TRUE, 
keepMclassed=FALSE, tol_Xi=10^(-12), weights,subset,contrasts=NULL, verbose=TRUE,...)
PLS_lm_kfoldcv(dataY, dataX, nt = 2, limQ2set = 0.0975, modele = "pls", 
K = 5, NK = 1, grouplist = NULL, random = TRUE, scaleX = TRUE, 
scaleY = NULL, keepcoeffs = FALSE, keepfolds = FALSE, keepdataY = TRUE, 
keepMclassed=FALSE, tol_Xi = 10^(-12), weights, verbose=TRUE)
PLS_lm_kfoldcv_formula(formula,data=NULL,nt=2,limQ2set=.0975,modele="pls", 
K=5, NK=1, grouplist=NULL, random=TRUE, scaleX=TRUE, 
scaleY=NULL, keepcoeffs=FALSE, keepfolds=FALSE, keepdataY=TRUE, 
keepMclassed=FALSE, tol_Xi=10^(-12), weights,subset,contrasts=NULL,verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv.plsR_+3A_object">object</code></td>
<td>
<p>response (training) dataset or an object of class &quot;<code><a href="stats.html#topic+formula">formula</a></code>&quot; (or one that can be coerced to that class): a symbolic description of the model to be fitted. The details of model specification are given under 'Details'.</p>
</td></tr>
<tr><td><code id="cv.plsR_+3A_datay">dataY</code></td>
<td>
<p>response (training) dataset</p>
</td></tr>
<tr><td><code id="cv.plsR_+3A_datax">dataX</code></td>
<td>
<p>predictor(s) (training) dataset</p>
</td></tr>
<tr><td><code id="cv.plsR_+3A_formula">formula</code></td>
<td>
<p>an object of class &quot;<code><a href="stats.html#topic+formula">formula</a></code>&quot; (or one that can be coerced to that class): a symbolic description of the model to be fitted. The details of model specification are given under 'Details'.</p>
</td></tr>
<tr><td><code id="cv.plsR_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a data frame) containing the variables in the model. If not found in <code>data</code>, the variables are taken from <code>environment(formula)</code>, typically the environment from which <code>plsRglm</code> is called.</p>
</td></tr>  
<tr><td><code id="cv.plsR_+3A_nt">nt</code></td>
<td>
<p>number of components to be extracted</p>
</td></tr>
<tr><td><code id="cv.plsR_+3A_limq2set">limQ2set</code></td>
<td>
<p>limit value for the Q2</p>
</td></tr>
<tr><td><code id="cv.plsR_+3A_modele">modele</code></td>
<td>
<p>name of the PLS model to be fitted, only (<code>"pls"</code> available for this fonction.</p>
</td></tr>
<tr><td><code id="cv.plsR_+3A_k">K</code></td>
<td>
<p>number of groups. Defaults to 5.</p>
</td></tr>
<tr><td><code id="cv.plsR_+3A_nk">NK</code></td>
<td>
<p>number of times the group division is made</p>
</td></tr>
<tr><td><code id="cv.plsR_+3A_grouplist">grouplist</code></td>
<td>
<p>to specify the members of the <code>K</code> groups</p>
</td></tr>
<tr><td><code id="cv.plsR_+3A_random">random</code></td>
<td>
<p>should the <code>K</code> groups be made randomly. Defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="cv.plsR_+3A_scalex">scaleX</code></td>
<td>
<p>scale the predictor(s) : must be set to TRUE for <code>modele="pls"</code> and should be for glms pls.</p>
</td></tr>
<tr><td><code id="cv.plsR_+3A_scaley">scaleY</code></td>
<td>
<p>scale the response : Yes/No. Ignored since non always possible for glm responses.</p>
</td></tr>
<tr><td><code id="cv.plsR_+3A_keepcoeffs">keepcoeffs</code></td>
<td>
<p>shall the coefficients for each model be returned</p>
</td></tr>
<tr><td><code id="cv.plsR_+3A_keepfolds">keepfolds</code></td>
<td>
<p>shall the groups' composition be returned</p>
</td></tr>
<tr><td><code id="cv.plsR_+3A_keepdatay">keepdataY</code></td>
<td>
<p>shall the observed value of the response for each one of the predicted value be returned</p>
</td></tr>
<tr><td><code id="cv.plsR_+3A_keepmclassed">keepMclassed</code></td>
<td>
<p>shall the number of miss classed be returned</p>
</td></tr>
<tr><td><code id="cv.plsR_+3A_tol_xi">tol_Xi</code></td>
<td>
<p>minimal value for Norm2(Xi) and <code class="reqn">\mathrm{det}(pp' \times pp)</code> if there is any missing value in the <code>dataX</code>. It defaults to <code class="reqn">10^{-12}</code></p>
</td></tr>
<tr><td><code id="cv.plsR_+3A_weights">weights</code></td>
<td>
<p>an optional vector of 'prior weights' to be used in the fitting process. Should be <code>NULL</code> or a numeric vector.</p>
</td></tr>
<tr><td><code id="cv.plsR_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="cv.plsR_+3A_contrasts">contrasts</code></td>
<td>
<p>an optional list. See the <code>contrasts.arg</code> of <code>model.matrix.default</code>.</p>
</td></tr>
<tr><td><code id="cv.plsR_+3A_verbose">verbose</code></td>
<td>
<p>should info messages be displayed ?</p>
</td></tr>
<tr><td><code id="cv.plsR_+3A_...">...</code></td>
<td>
<p>arguments to pass to <code>cv.plsRmodel.default</code> or to <code>cv.plsRmodel.formula</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Predicts 1 group with the <code>K-1</code> other groups. Leave one out cross validation is thus obtained for <code>K==nrow(dataX)</code>.
</p>
<p>A typical predictor has the form response ~ terms where response is the (numeric) response vector and terms is a series of terms which specifies a linear predictor for response. A terms specification of the form first + second indicates all the terms in first together with all the terms in second with any duplicates removed. 
</p>
<p>A specification of the form first:second indicates the the set of terms obtained by taking the interactions of all terms in first with all terms in second. The specification first*second indicates the cross of first and second. This is the same as first + second + first:second. 
</p>
<p>The terms in the formula will be re-ordered so that main effects come first, followed by the interactions, all second-order, all third-order and so on: to avoid this pass a terms object as the formula. 
</p>
<p>Non-NULL weights can be used to indicate that different observations have different dispersions (with the values in weights being inversely proportional to the dispersions); or equivalently, when the elements of weights are positive integers w_i, that each response y_i is the mean of w_i unit-weight observations. 
</p>


<h3>Value</h3>

<p>An object of class <code>"cv.plsRmodel"</code>.<br /> 
</p>
<table>
<tr><td><code>results_kfolds</code></td>
<td>
<p>list of <code>NK</code>. Each element of the list sums up the results for a group division:
</p>

<dl>
<dt>list</dt><dd><p> of <code>K</code> matrices of size about <code>nrow(dataX)/K * nt</code> with the predicted values for a growing number of components</p>
</dd>
<dt>...</dt><dd><p>...</p>
</dd>
<dt>list</dt><dd><p> of <code>K</code> matrices of size about <code>nrow(dataX)/K * nt</code> with the predicted values for a growing number of components</p>
</dd>
</dl>

</td></tr>
<tr><td><code>folds</code></td>
<td>
<p>list of <code>NK</code>. Each element of the list sums up the results for a group division:
</p>

<dl>
<dt>list</dt><dd><p> of <code>K</code> vectors of length about <code>nrow(dataX)</code> with the numbers of the rows of <code>dataX</code> that were used as a training set</p>
</dd>
<dt>...</dt><dd><p>...</p>
</dd>
<dt>list</dt><dd><p> of <code>K</code> vectors of length about <code>nrow(dataX)</code> with the numbers of the rows of <code>dataX</code> that were used as a training set</p>
</dd>
</dl>

</td></tr>
<tr><td><code>dataY_kfolds</code></td>
<td>
<p>list of <code>NK</code>. Each element of the list sums up the results for a group division:
</p>

<dl>
<dt>list</dt><dd><p> of <code>K</code> matrices of size about <code>nrow(dataX)/K * 1</code> with the observed values of the response</p>
</dd>
<dt>...</dt><dd><p>...</p>
</dd>
<dt>list</dt><dd><p> of <code>K</code> matrices of size about <code>nrow(dataX)/K * 1</code> with the observed values of the response</p>
</dd>
</dl>

</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the call of the function</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Work for complete and incomplete datasets.</p>


<h3>Author(s)</h3>

<p>Frederic Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>References</h3>

<p>Nicolas Meyer, Myriam Maumy-Bertrand et Frederic Bertrand (2010). Comparing the linear and the logistic PLS regression with qualitative predictors: application to allelotyping data. <em>Journal de la Societe Francaise de Statistique</em>, 151(2), pages 1-18.
<a href="http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47">http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47</a>
</p>


<h3>See Also</h3>

<p>Summary method <code>summary.cv.plsRmodel</code>. <code><a href="#topic+kfolds2coeff">kfolds2coeff</a></code>, <code><a href="#topic+kfolds2Pressind">kfolds2Pressind</a></code>, <code><a href="#topic+kfolds2Press">kfolds2Press</a></code>, <code><a href="#topic+kfolds2Mclassedind">kfolds2Mclassedind</a></code>, <code><a href="#topic+kfolds2Mclassed">kfolds2Mclassed</a></code> and <code><a href="#topic+kfolds2CVinfos_lm">kfolds2CVinfos_lm</a></code> to extract and transform results from k-fold cross-validation.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Cornell)
XCornell&lt;-Cornell[,1:7]
yCornell&lt;-Cornell[,8]

#Leave one out CV (K=nrow(Cornell)) one time (NK=1)
bbb &lt;- cv.plsR(object=yCornell,dataX=XCornell,nt=6,K=nrow(Cornell),NK=1)
bbb2 &lt;- cv.plsR(Y~.,data=Cornell,nt=6,K=12,NK=1,verbose=FALSE)
(sum1&lt;-summary(bbb2))

#6-fold CV (K=6) two times (NK=2)
#use random=TRUE to randomly create folds for repeated CV
bbb3 &lt;- cv.plsR(object=yCornell,dataX=XCornell,nt=6,K=6,NK=2)
bbb4 &lt;- cv.plsR(Y~.,data=Cornell,nt=6,K=6,NK=2,verbose=FALSE)
(sum3&lt;-summary(bbb4))

cvtable(sum1)
cvtable(sum3)
rm(list=c("XCornell","yCornell","bbb","bbb2","bbb3","bbb4"))
</code></pre>

<hr>
<h2 id='cv.plsRglm'>Partial least squares regression glm models with k-fold cross validation</h2><span id='topic+cv.plsRglm'></span><span id='topic+cv.plsRglmmodel.default'></span><span id='topic+cv.plsRglmmodel.formula'></span><span id='topic+PLS_glm_kfoldcv'></span><span id='topic+PLS_glm_kfoldcv_formula'></span>

<h3>Description</h3>

<p>This function implements k-fold cross-validation on complete or incomplete datasets for partial least squares regression generalized linear models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.plsRglm(object, ...)
## Default S3 method:
cv.plsRglmmodel(object,dataX,nt=2,limQ2set=.0975,
modele="pls", family=NULL, K=5, NK=1, grouplist=NULL, random=TRUE, 
scaleX=TRUE, scaleY=NULL, keepcoeffs=FALSE, keepfolds=FALSE, 
keepdataY=TRUE, keepMclassed=FALSE, tol_Xi=10^(-12), weights, method,
verbose=TRUE,...)
## S3 method for class 'formula'
cv.plsRglmmodel(object,data=NULL,nt=2,limQ2set=.0975,
modele="pls", family=NULL, K=5, NK=1, grouplist=NULL, random=TRUE, 
scaleX=TRUE, scaleY=NULL, keepcoeffs=FALSE, keepfolds=FALSE, 
keepdataY=TRUE, keepMclassed=FALSE, tol_Xi=10^(-12),weights,subset,
start=NULL,etastart,mustart,offset,method,control= list(),contrasts=NULL,
verbose=TRUE,...)
PLS_glm_kfoldcv(dataY, dataX, nt = 2, limQ2set = 0.0975, modele = "pls", 
family = NULL, K = 5, NK = 1, grouplist = NULL, random = TRUE, 
scaleX = TRUE, scaleY = NULL, keepcoeffs = FALSE, keepfolds = FALSE, 
keepdataY = TRUE, keepMclassed=FALSE, tol_Xi = 10^(-12), weights, method,
verbose=TRUE)
PLS_glm_kfoldcv_formula(formula,data=NULL,nt=2,limQ2set=.0975,modele="pls",
family=NULL, K=5, NK=1, grouplist=NULL, random=TRUE, 
scaleX=TRUE, scaleY=NULL, keepcoeffs=FALSE, keepfolds=FALSE, keepdataY=TRUE, 
keepMclassed=FALSE, tol_Xi=10^(-12),weights,subset,start=NULL,etastart,
mustart,offset,method,control= list(),contrasts=NULL, verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv.plsRglm_+3A_object">object</code></td>
<td>
<p>response (training) dataset or an object of class &quot;<code><a href="stats.html#topic+formula">formula</a></code>&quot; (or one that can be coerced to that class): a symbolic description of the model to be fitted. The details of model specification are given under 'Details'.</p>
</td></tr>
<tr><td><code id="cv.plsRglm_+3A_datay">dataY</code></td>
<td>
<p>response (training) dataset</p>
</td></tr>
<tr><td><code id="cv.plsRglm_+3A_datax">dataX</code></td>
<td>
<p>predictor(s) (training) dataset</p>
</td></tr>
<tr><td><code id="cv.plsRglm_+3A_formula">formula</code></td>
<td>
<p>an object of class &quot;<code><a href="stats.html#topic+formula">formula</a></code>&quot; (or one that can be coerced to that class): a symbolic description of the model to be fitted. The details of model specification are given under 'Details'.</p>
</td></tr>
<tr><td><code id="cv.plsRglm_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a data frame) containing the variables in the model. If not found in <code>data</code>, the variables are taken from <code>environment(formula)</code>, typically the environment from which <code>plsRglm</code> is called.</p>
</td></tr>  
<tr><td><code id="cv.plsRglm_+3A_nt">nt</code></td>
<td>
<p>number of components to be extracted</p>
</td></tr>
<tr><td><code id="cv.plsRglm_+3A_limq2set">limQ2set</code></td>
<td>
<p>limit value for the Q2</p>
</td></tr>
<tr><td><code id="cv.plsRglm_+3A_modele">modele</code></td>
<td>
<p>name of the PLS glm model to be fitted (<code>"pls"</code>, <code>"pls-glm-Gamma"</code>, <code>"pls-glm-gaussian"</code>, <code>"pls-glm-inverse.gaussian"</code>, <code>"pls-glm-logistic"</code>, <code>"pls-glm-poisson"</code>, <code>"pls-glm-polr"</code>). Use <code>"modele=pls-glm-family"</code> to enable the <code>family</code> option.</p>
</td></tr>
<tr><td><code id="cv.plsRglm_+3A_family">family</code></td>
<td>
<p>a description of the error distribution and link function to be used in the model. This can be a character string naming a family function, a family function or the result of a call to a family function. (See <code><a href="stats.html#topic+family">family</a></code> for details of family functions.) To use the family option, please set <code>modele="pls-glm-family"</code>. User defined families can also be defined. See details.</p>
</td></tr>
<tr><td><code id="cv.plsRglm_+3A_k">K</code></td>
<td>
<p>number of groups. Defaults to 5.</p>
</td></tr>
<tr><td><code id="cv.plsRglm_+3A_nk">NK</code></td>
<td>
<p>number of times the group division is made</p>
</td></tr>
<tr><td><code id="cv.plsRglm_+3A_grouplist">grouplist</code></td>
<td>
<p>to specify the members of the <code>K</code> groups</p>
</td></tr>
<tr><td><code id="cv.plsRglm_+3A_random">random</code></td>
<td>
<p>should the <code>K</code> groups be made randomly. Defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="cv.plsRglm_+3A_scalex">scaleX</code></td>
<td>
<p>scale the predictor(s) : must be set to TRUE for <code>modele="pls"</code> and should be for glms pls.</p>
</td></tr>
<tr><td><code id="cv.plsRglm_+3A_scaley">scaleY</code></td>
<td>
<p>scale the response : Yes/No. Ignored since non always possible for glm responses.</p>
</td></tr>
<tr><td><code id="cv.plsRglm_+3A_keepcoeffs">keepcoeffs</code></td>
<td>
<p>shall the coefficients for each model be returned</p>
</td></tr>
<tr><td><code id="cv.plsRglm_+3A_keepfolds">keepfolds</code></td>
<td>
<p>shall the groups' composition be returned</p>
</td></tr>
<tr><td><code id="cv.plsRglm_+3A_keepdatay">keepdataY</code></td>
<td>
<p>shall the observed value of the response for each one of the predicted value be returned</p>
</td></tr>
<tr><td><code id="cv.plsRglm_+3A_keepmclassed">keepMclassed</code></td>
<td>
<p>shall the number of miss classed be returned (unavailable)</p>
</td></tr>
<tr><td><code id="cv.plsRglm_+3A_tol_xi">tol_Xi</code></td>
<td>
<p>minimal value for Norm2(Xi) and <code class="reqn">\mathrm{det}(pp' \times pp)</code> if there is any missing value in the <code>dataX</code>. It defaults to <code class="reqn">10^{-12}</code></p>
</td></tr>
<tr><td><code id="cv.plsRglm_+3A_weights">weights</code></td>
<td>
<p>an optional vector of 'prior weights' to be used in the fitting process. Should be <code>NULL</code> or a numeric vector.</p>
</td></tr>
<tr><td><code id="cv.plsRglm_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="cv.plsRglm_+3A_start">start</code></td>
<td>
<p>starting values for the parameters in the linear predictor.</p>
</td></tr>
<tr><td><code id="cv.plsRglm_+3A_etastart">etastart</code></td>
<td>
<p>starting values for the linear predictor.</p>
</td></tr>
<tr><td><code id="cv.plsRglm_+3A_mustart">mustart</code></td>
<td>
<p>starting values for the vector of means.</p>
</td></tr>
<tr><td><code id="cv.plsRglm_+3A_offset">offset</code></td>
<td>
<p>this can be used to specify an <em>a priori</em> known component to be included in the linear predictor during fitting. This should be <code>NULL</code> or a numeric vector of length equal to the number of cases. One or more <code><a href="stats.html#topic+offset">offset</a></code> terms can be included in the formula instead or as well, and if more than one is specified their sum is used. See <code><a href="stats.html#topic+model.offset">model.offset</a></code>.</p>
</td></tr>
<tr><td><code id="cv.plsRglm_+3A_method">method</code></td>
<td>

<dl>
<dt>for fitting glms with glm (<code>"pls-glm-Gamma"</code>, <code>"pls-glm-gaussian"</code>, <code>"pls-glm-inverse.gaussian"</code>, <code>"pls-glm-logistic"</code>, <code>"pls-glm-poisson"</code>, <code>"modele=pls-glm-family"</code>)</dt><dd><p>the method to be used in fitting the model. The default method <code>"glm.fit"</code> uses iteratively reweighted least squares (IWLS). User-supplied fitting functions can be supplied either as a function or a character string naming a function, with a function which takes the same arguments as <code>glm.fit</code>. If &quot;model.frame&quot;, the model frame is returned.</p>
</dd>
<dt><code>pls-glm-polr</code></dt><dd><p>logistic, probit, complementary log-log or cauchit (corresponding to a Cauchy latent variable).</p>
</dd></dl>
</td></tr>
<tr><td><code id="cv.plsRglm_+3A_control">control</code></td>
<td>
<p>a list of parameters for controlling the fitting process. For <code>glm.fit</code> this is passed to <code><a href="stats.html#topic+glm.control">glm.control</a></code>.</p>
</td></tr>
<tr><td><code id="cv.plsRglm_+3A_contrasts">contrasts</code></td>
<td>
<p>an optional list. See the <code>contrasts.arg</code> of <code>model.matrix.default</code>.</p>
</td></tr>
<tr><td><code id="cv.plsRglm_+3A_verbose">verbose</code></td>
<td>
<p>should info messages be displayed ?</p>
</td></tr>
<tr><td><code id="cv.plsRglm_+3A_...">...</code></td>
<td>
<p>arguments to pass to <code>cv.plsRglmmodel.default</code> or to <code>cv.plsRglmmodel.formula</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Predicts 1 group with the <code>K-1</code> other groups. Leave one out cross validation is thus obtained for <code>K==nrow(dataX)</code>.
</p>
<p>There are seven different predefined models with predefined link functions available :
</p>

<dl>
<dt><code>"pls"</code></dt><dd><p>ordinary pls models</p>
</dd>
<dt><code>"pls-glm-Gamma"</code></dt><dd><p>glm gaussian with inverse link pls models</p>
</dd>
<dt><code>"pls-glm-gaussian"</code></dt><dd><p>glm gaussian with identity link pls models</p>
</dd>
<dt><code>"pls-glm-inverse-gamma"</code></dt><dd><p>glm binomial with square inverse link pls models</p>
</dd>
<dt><code>"pls-glm-logistic"</code></dt><dd><p>glm binomial with logit link pls models</p>
</dd>
<dt><code>"pls-glm-poisson"</code></dt><dd><p>glm poisson with log link pls models</p>
</dd>
<dt><code>"pls-glm-polr"</code></dt><dd><p>glm polr with logit link pls models</p>
</dd>
</dl>

<p>Using the <code>"family="</code> option and setting <code>"modele=pls-glm-family"</code> allows changing the family and link function the same way as for the <code><a href="stats.html#topic+glm">glm</a></code> function. As a consequence user-specified families can also be used. 
</p>

<dl>
<dt>The <code>gaussian</code> family</dt><dd><p>accepts the links (as names) <code>identity</code>, <code>log</code> and <code>inverse</code>.</p>
</dd>
<dt>The <code>binomial</code> family</dt><dd><p>accepts the links <code>logit</code>, <code>probit</code>, <code>cauchit</code>, (corresponding to logistic, normal and Cauchy CDFs respectively) <code>log</code> and <code>cloglog</code> (complementary log-log).</p>
</dd> 
<dt>The <code>Gamma</code> family</dt><dd><p>accepts the links <code>inverse</code>, <code>identity</code> and <code>log</code>.</p>
</dd>
<dt>The <code>poisson</code> family</dt><dd><p>accepts the links <code>log</code>, <code>identity</code>, and <code>sqrt</code>.</p>
</dd>
<dt>The <code>inverse.gaussian</code> family</dt><dd><p>accepts the links <code>1/mu^2</code>, <code>inverse</code>, <code>identity</code> and <code>log</code>.</p>
</dd>
<dt>The <code>quasi</code> family</dt><dd><p>accepts the links <code>logit</code>, <code>probit</code>, <code>cloglog</code>, <code>identity</code>, <code>inverse</code>, <code>log</code>, <code>1/mu^2</code> and <code>sqrt</code>.</p>
</dd>
<dt>The function <code>power</code></dt><dd><p>can be used to create a power link function.</p>
</dd> 
<dt>...</dt><dd><p>arguments to pass to <code>cv.plsRglmmodel.default</code> or to <code>cv.plsRglmmodel.formula</code></p>
</dd>
</dl>

<p>A typical predictor has the form response ~ terms where response is the (numeric) response vector and terms is a series of terms which specifies a linear predictor for response. A terms specification of the form first + second indicates all the terms in first together with all the terms in second with any duplicates removed. 
</p>
<p>A specification of the form first:second indicates the the set of terms obtained by taking the interactions of all terms in first with all terms in second. The specification first*second indicates the cross of first and second. This is the same as first + second + first:second. 
</p>
<p>The terms in the formula will be re-ordered so that main effects come first, followed by the interactions, all second-order, all third-order and so on: to avoid this pass a terms object as the formula. 
</p>
<p>Non-NULL weights can be used to indicate that different observations have different dispersions (with the values in weights being inversely proportional to the dispersions); or equivalently, when the elements of weights are positive integers w_i, that each response y_i is the mean of w_i unit-weight observations. 
</p>


<h3>Value</h3>

<p>An object of class <code>"cv.plsRglmmodel"</code>.<br /> 
</p>
<table>
<tr><td><code>results_kfolds</code></td>
<td>
<p>list of <code>NK</code>. Each element of the list sums up the results for a group division:
</p>

<dl>
<dt>list</dt><dd><p> of <code>K</code> matrices of size about <code>nrow(dataX)/K * nt</code> with the predicted values for a growing number of components</p>
</dd>
<dt>...</dt><dd><p>...</p>
</dd>
<dt>list</dt><dd><p> of <code>K</code> matrices of size about <code>nrow(dataX)/K * nt</code> with the predicted values for a growing number of components</p>
</dd>
</dl>
</td></tr>
<tr><td><code>folds</code></td>
<td>
<p>list of <code>NK</code>. Each element of the list sums up the informations for a group division:
</p>

<dl>
<dt>list</dt><dd><p> of <code>K</code> vectors of length about <code>nrow(dataX)</code> with the numbers of the rows of <code>dataX</code> that were used as a training set</p>
</dd>
<dt>...</dt><dd><p>...</p>
</dd>
<dt>list</dt><dd><p> of <code>K</code> vectors of length about <code>nrow(dataX)</code> with the numbers of the rows of <code>dataX</code> that were used as a training set</p>
</dd>
</dl>

</td></tr>
<tr><td><code>dataY_kfolds</code></td>
<td>
<p>list of <code>NK</code>. Each element of the list sums up the results for a group division:
</p>

<dl>
<dt>list</dt><dd><p> of <code>K</code> matrices of size about <code>nrow(dataX)/K * 1</code> with the observed values of the response</p>
</dd>
<dt>...</dt><dd><p>...</p>
</dd>
<dt>list</dt><dd><p> of <code>K</code> matrices of size about <code>nrow(dataX)/K * 1</code> with the observed values of the response</p>
</dd>
</dl>

</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the call of the function</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Work for complete and incomplete datasets.</p>


<h3>Author(s)</h3>

<p>Frederic Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>References</h3>

<p>Nicolas Meyer, Myriam Maumy-Bertrand et Frederic Bertrand (2010). Comparing the linear and the logistic PLS regression with qualitative predictors: application to allelotyping data. <em>Journal de la Societe Francaise de Statistique</em>, 151(2), pages 1-18.
</p>


<h3>See Also</h3>

<p>Summary method <code>summary.cv.plsRglmmodel</code>. <code><a href="#topic+kfolds2coeff">kfolds2coeff</a></code>, <code><a href="#topic+kfolds2Pressind">kfolds2Pressind</a></code>, <code><a href="#topic+kfolds2Press">kfolds2Press</a></code>, <code><a href="#topic+kfolds2Mclassedind">kfolds2Mclassedind</a></code>, <code><a href="#topic+kfolds2Mclassed">kfolds2Mclassed</a></code> and <code><a href="base.html#topic+summary">summary</a></code> to extract and transform results from k-fold cross validation.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Cornell)
bbb &lt;- cv.plsRglm(Y~.,data=Cornell,nt=10)
(sum1&lt;-summary(bbb))
cvtable(sum1)

bbb2 &lt;- cv.plsRglm(Y~.,data=Cornell,nt=3,
modele="pls-glm-family",family=gaussian(),K=12,verbose=FALSE)
(sum2&lt;-summary(bbb2))
cvtable(sum2)


#random=TRUE is the default to randomly create folds for repeated CV
bbb3 &lt;- cv.plsRglm(Y~.,data=Cornell,nt=3,
modele="pls-glm-family",family=gaussian(),K=6,NK=10, verbose=FALSE)
(sum3&lt;-summary(bbb3))
plot(cvtable(sum3))

data(aze_compl)
bbb &lt;- cv.plsRglm(y~.,data=aze_compl,nt=10,K=10,modele="pls",keepcoeffs=TRUE, verbose=FALSE)

#For Jackknife computations
kfolds2coeff(bbb)
bbb2 &lt;- cv.plsRglm(y~.,data=aze_compl,nt=10,K=10,modele="pls-glm-family",
family=binomial(probit),keepcoeffs=TRUE, verbose=FALSE)
bbb2 &lt;- cv.plsRglm(y~.,data=aze_compl,nt=10,K=10,
modele="pls-glm-logistic",keepcoeffs=TRUE, verbose=FALSE)
summary(bbb,MClassed=TRUE)
summary(bbb2,MClassed=TRUE)
kfolds2coeff(bbb2)

kfolds2Chisqind(bbb2)
kfolds2Chisq(bbb2)
summary(bbb2)
rm(list=c("bbb","bbb2"))



data(pine)
Xpine&lt;-pine[,1:10]
ypine&lt;-pine[,11]
bbb &lt;- cv.plsRglm(round(x11)~.,data=pine,nt=10,modele="pls-glm-family",
family=poisson(log),K=10,keepcoeffs=TRUE,keepfolds=FALSE,verbose=FALSE)
bbb &lt;- cv.plsRglm(round(x11)~.,data=pine,nt=10,
modele="pls-glm-poisson",K=10,keepcoeffs=TRUE,keepfolds=FALSE,verbose=FALSE)

#For Jackknife computations
kfolds2coeff(bbb)
boxplot(kfolds2coeff(bbb)[,1])

kfolds2Chisqind(bbb)
kfolds2Chisq(bbb)
summary(bbb)
PLS_lm(ypine,Xpine,10,typeVC="standard")$InfCrit

data(pineNAX21)
bbb2 &lt;- cv.plsRglm(round(x11)~.,data=pineNAX21,nt=10,
modele="pls-glm-family",family=poisson(log),K=10,keepcoeffs=TRUE,keepfolds=FALSE,verbose=FALSE)
bbb2 &lt;- cv.plsRglm(round(x11)~.,data=pineNAX21,nt=10,
modele="pls-glm-poisson",K=10,keepcoeffs=TRUE,keepfolds=FALSE,verbose=FALSE)

#For Jackknife computations
kfolds2coeff(bbb2)
boxplot(kfolds2coeff(bbb2)[,1])

kfolds2Chisqind(bbb2)
kfolds2Chisq(bbb2)
summary(bbb2)

data(XpineNAX21)
PLS_lm(ypine,XpineNAX21,10,typeVC="standard")$InfCrit
rm(list=c("Xpine","XpineNAX21","ypine","bbb","bbb2"))



data(pine)
Xpine&lt;-pine[,1:10]
ypine&lt;-pine[,11]
bbb &lt;- cv.plsRglm(x11~.,data=pine,nt=10,modele="pls-glm-family",
family=Gamma,K=10,keepcoeffs=TRUE,keepfolds=FALSE,verbose=FALSE)
bbb &lt;- cv.plsRglm(x11~.,data=pine,nt=10,modele="pls-glm-Gamma",
K=10,keepcoeffs=TRUE,keepfolds=FALSE,verbose=FALSE)

#For Jackknife computations
kfolds2coeff(bbb)
boxplot(kfolds2coeff(bbb)[,1])

kfolds2Chisqind(bbb)
kfolds2Chisq(bbb)
summary(bbb)
PLS_lm(ypine,Xpine,10,typeVC="standard")$InfCrit

data(pineNAX21)
bbb2 &lt;- cv.plsRglm(x11~.,data=pineNAX21,nt=10,
modele="pls-glm-family",family=Gamma(),K=10,keepcoeffs=TRUE,keepfolds=FALSE,verbose=FALSE)
bbb2 &lt;- cv.plsRglm(x11~.,data=pineNAX21,nt=10,
modele="pls-glm-Gamma",K=10,keepcoeffs=TRUE,keepfolds=FALSE,verbose=FALSE)

#For Jackknife computations
kfolds2coeff(bbb2)
boxplot(kfolds2coeff(bbb2)[,1])

kfolds2Chisqind(bbb2)
kfolds2Chisq(bbb2)
summary(bbb2)
XpineNAX21 &lt;- Xpine
XpineNAX21[1,2] &lt;- NA
PLS_lm(ypine,XpineNAX21,10,typeVC="standard")$InfCrit
rm(list=c("Xpine","XpineNAX21","ypine","bbb","bbb2"))



data(Cornell)
XCornell&lt;-Cornell[,1:7]
yCornell&lt;-Cornell[,8]
bbb &lt;- cv.plsRglm(Y~.,data=Cornell,nt=10,NK=1,modele="pls",verbose=FALSE)
summary(bbb)

cv.plsRglm(object=yCornell,dataX=XCornell,nt=3,modele="pls-glm-inverse.gaussian",K=12,verbose=FALSE)
cv.plsRglm(object=yCornell,dataX=XCornell,nt=3,modele="pls-glm-family",
family=inverse.gaussian,K=12,verbose=FALSE)
cv.plsRglm(object=yCornell,dataX=XCornell,nt=3,modele="pls-glm-inverse.gaussian",K=6,
NK=2,verbose=FALSE)$results_kfolds
cv.plsRglm(object=yCornell,dataX=XCornell,nt=3,modele="pls-glm-family",family=inverse.gaussian(),
K=6,NK=2,verbose=FALSE)$results_kfolds
cv.plsRglm(object=yCornell,dataX=XCornell,nt=3,modele="pls-glm-inverse.gaussian",K=6,
NK=2,verbose=FALSE)$results_kfolds
cv.plsRglm(object=yCornell,dataX=XCornell,nt=3,modele="pls-glm-family",
family=inverse.gaussian(link = "1/mu^2"),K=6,NK=2,verbose=FALSE)$results_kfolds

bbb2 &lt;- cv.plsRglm(Y~.,data=Cornell,nt=10,
modele="pls-glm-inverse.gaussian",keepcoeffs=TRUE,verbose=FALSE)

#For Jackknife computations
kfolds2coeff(bbb2)
boxplot(kfolds2coeff(bbb2)[,1])

kfolds2Chisqind(bbb2)
kfolds2Chisq(bbb2)
summary(bbb2)
PLS_lm(yCornell,XCornell,10,typeVC="standard")$InfCrit
rm(list=c("XCornell","yCornell","bbb","bbb2"))

data(Cornell)
bbb &lt;- cv.plsRglm(Y~.,data=Cornell,nt=10,NK=1,modele="pls")
summary(bbb)

cv.plsRglm(Y~.,data=Cornell,nt=3,modele="pls-glm-family",family=gaussian(),K=12)


cv.plsRglm(Y~.,data=Cornell,nt=3,modele="pls-glm-family",family=gaussian(),K=6,
NK=2,random=TRUE,keepfolds=TRUE,verbose=FALSE)$results_kfolds

#Different ways of model specifications
cv.plsRglm(Y~.,data=Cornell,nt=3,modele="pls-glm-family",family=gaussian(),K=6,
NK=2,verbose=FALSE)$results_kfolds
cv.plsRglm(Y~.,data=Cornell,nt=3,modele="pls-glm-family",family=gaussian,
K=6,NK=2,verbose=FALSE)$results_kfolds
cv.plsRglm(Y~.,data=Cornell,nt=3,modele="pls-glm-family",family=gaussian(),
K=6,NK=2,verbose=FALSE)$results_kfolds
cv.plsRglm(Y~.,data=Cornell,nt=3,modele="pls-glm-family",family=gaussian(link=log),
K=6,NK=2,verbose=FALSE)$results_kfolds

bbb2 &lt;- cv.plsRglm(Y~.,data=Cornell,nt=10,
modele="pls-glm-gaussian",keepcoeffs=TRUE,verbose=FALSE)
bbb2 &lt;- cv.plsRglm(Y~.,data=Cornell,nt=3,modele="pls-glm-family",
family=gaussian(link=log),K=6,keepcoeffs=TRUE,verbose=FALSE)

#For Jackknife computations
kfolds2coeff(bbb2)
boxplot(kfolds2coeff(bbb2)[,1])

kfolds2Chisqind(bbb2)
kfolds2Chisq(bbb2)
summary(bbb2)
PLS_lm_formula(Y~.,data=Cornell,10,typeVC="standard")$InfCrit
rm(list=c("bbb","bbb2"))


data(pine)
bbb &lt;- cv.plsRglm(x11~.,data=pine,nt=10,modele="pls-glm-family",
family=gaussian(log),K=10,keepcoeffs=TRUE,keepfolds=FALSE,verbose=FALSE)
bbb &lt;- cv.plsRglm(x11~.,data=pine,nt=10,modele="pls-glm-family",family=gaussian(),
K=10,keepcoeffs=TRUE,keepfolds=FALSE,verbose=FALSE)

#For Jackknife computations
kfolds2coeff(bbb)
boxplot(kfolds2coeff(bbb)[,1])

kfolds2Chisqind(bbb)
kfolds2Chisq(bbb)
summary(bbb)
PLS_lm_formula(x11~.,data=pine,nt=10,typeVC="standard")$InfCrit

data(pineNAX21)
bbb2 &lt;- cv.plsRglm(x11~.,data=pineNAX21,nt=10,
modele="pls-glm-family",family=gaussian(log),K=10,keepcoeffs=TRUE,keepfolds=FALSE,verbose=FALSE)
bbb2 &lt;- cv.plsRglm(x11~.,data=pineNAX21,nt=10,
modele="pls-glm-gaussian",K=10,keepcoeffs=TRUE,keepfolds=FALSE,verbose=FALSE)

#For Jackknife computations
kfolds2coeff(bbb2)
boxplot(kfolds2coeff(bbb2)[,1])

kfolds2Chisqind(bbb2)
kfolds2Chisq(bbb2)
summary(bbb2)
PLS_lm_formula(x11~.,data=pineNAX21,nt=10,typeVC="standard")$InfCrit
rm(list=c("bbb","bbb2"))


data(aze_compl)
bbb &lt;- cv.plsRglm(y~.,data=aze_compl,nt=10,K=10,modele="pls",
keepcoeffs=TRUE,verbose=FALSE)

#For Jackknife computations
kfolds2coeff(bbb)
bbb2 &lt;- cv.plsRglm(y~.,data=aze_compl,nt=3,K=10,
modele="pls-glm-family",family=binomial(probit),keepcoeffs=TRUE,verbose=FALSE)
bbb2 &lt;- cv.plsRglm(y~.,data=aze_compl,nt=3,K=10,
modele="pls-glm-logistic",keepcoeffs=TRUE,verbose=FALSE)
summary(bbb,MClassed=TRUE)
summary(bbb2,MClassed=TRUE)
kfolds2coeff(bbb2)

kfolds2Chisqind(bbb2)
kfolds2Chisq(bbb2)
summary(bbb2)
rm(list=c("bbb","bbb2"))



data(pine)
bbb &lt;- cv.plsRglm(round(x11)~.,data=pine,nt=10,
modele="pls-glm-family",family=poisson(log),K=10,keepcoeffs=TRUE,keepfolds=FALSE,verbose=FALSE)
bbb &lt;- cv.plsRglm(round(x11)~.,data=pine,nt=10,
modele="pls-glm-poisson",K=10,keepcoeffs=TRUE,keepfolds=FALSE,verbose=FALSE)

#For Jackknife computations
kfolds2coeff(bbb)
boxplot(kfolds2coeff(bbb)[,1])

kfolds2Chisqind(bbb)
kfolds2Chisq(bbb)
summary(bbb)
PLS_lm_formula(x11~.,data=pine,10,typeVC="standard")$InfCrit

data(pineNAX21)
bbb2 &lt;- cv.plsRglm(round(x11)~.,data=pineNAX21,nt=10,
modele="pls-glm-family",family=poisson(log),K=10,keepcoeffs=TRUE,keepfolds=FALSE,verbose=FALSE)
bbb2 &lt;- cv.plsRglm(round(x11)~.,data=pineNAX21,nt=10,
modele="pls-glm-poisson",K=10,keepcoeffs=TRUE,keepfolds=FALSE,verbose=FALSE)

#For Jackknife computations
kfolds2coeff(bbb2)
boxplot(kfolds2coeff(bbb2)[,1])

kfolds2Chisqind(bbb2)
kfolds2Chisq(bbb2)
summary(bbb2)
PLS_lm_formula(x11~.,data=pineNAX21,10,typeVC="standard")$InfCrit
rm(list=c("bbb","bbb2"))



data(pine)
bbb &lt;- cv.plsRglm(x11~.,data=pine,nt=10,modele="pls-glm-family",
family=Gamma,K=10,keepcoeffs=TRUE,keepfolds=FALSE,verbose=FALSE)
bbb &lt;- cv.plsRglm(x11~.,data=pine,nt=10,modele="pls-glm-Gamma",
K=10,keepcoeffs=TRUE,keepfolds=FALSE,verbose=FALSE)

#For Jackknife computations
kfolds2coeff(bbb)
boxplot(kfolds2coeff(bbb)[,1])

kfolds2Chisqind(bbb)
kfolds2Chisq(bbb)
summary(bbb)
PLS_lm_formula(x11~.,data=pine,10,typeVC="standard")$InfCrit

data(pineNAX21)
bbb2 &lt;- cv.plsRglm(x11~.,data=pineNAX21,nt=10,
modele="pls-glm-family",family=Gamma(),K=10,keepcoeffs=TRUE,keepfolds=FALSE,verbose=FALSE)
bbb2 &lt;- cv.plsRglm(x11~.,data=pineNAX21,nt=10,
modele="pls-glm-Gamma",K=10,keepcoeffs=TRUE,keepfolds=FALSE,verbose=FALSE)

#For Jackknife computations
kfolds2coeff(bbb2)
boxplot(kfolds2coeff(bbb2)[,1])

kfolds2Chisqind(bbb2)
kfolds2Chisq(bbb2)
summary(bbb2)
PLS_lm_formula(x11~.,data=pineNAX21,10,typeVC="standard")$InfCrit
rm(list=c("bbb","bbb2"))



data(Cornell)
summary(cv.plsRglm(Y~.,data=Cornell,nt=10,NK=1,modele="pls",verbose=FALSE))

cv.plsRglm(Y~.,data=Cornell,nt=3,
modele="pls-glm-inverse.gaussian",K=12,verbose=FALSE)
cv.plsRglm(Y~.,data=Cornell,nt=3,modele="pls-glm-family",family=inverse.gaussian,K=12,verbose=FALSE)
cv.plsRglm(Y~.,data=Cornell,nt=3,modele="pls-glm-inverse.gaussian",K=6,
NK=2,verbose=FALSE)$results_kfolds
cv.plsRglm(Y~.,data=Cornell,nt=3,modele="pls-glm-family",
family=inverse.gaussian(),K=6,NK=2,verbose=FALSE)$results_kfolds
cv.plsRglm(Y~.,data=Cornell,nt=3,modele="pls-glm-inverse.gaussian",K=6,
NK=2,verbose=FALSE)$results_kfolds
cv.plsRglm(Y~.,data=Cornell,nt=3,modele="pls-glm-family",
family=inverse.gaussian(link = "1/mu^2"),K=6,NK=2,verbose=FALSE)$results_kfolds

bbb2 &lt;- cv.plsRglm(Y~.,data=Cornell,nt=10,
modele="pls-glm-inverse.gaussian",keepcoeffs=TRUE,verbose=FALSE)

#For Jackknife computations
kfolds2coeff(bbb2)
boxplot(kfolds2coeff(bbb2)[,1])

kfolds2Chisqind(bbb2)
kfolds2Chisq(bbb2)
summary(bbb2)
PLS_lm_formula(Y~.,data=Cornell,10,typeVC="standard")$InfCrit
rm(list=c("bbb","bbb2"))


data(bordeaux)
summary(cv.plsRglm(Quality~.,data=bordeaux,10,
modele="pls-glm-polr",K=7))

data(bordeauxNA)
summary(cv.plsRglm(Quality~.,data=bordeauxNA,
10,modele="pls-glm-polr",K=10,verbose=FALSE))

summary(cv.plsRglm(Quality~.,data=bordeaux,nt=2,K=7,
modele="pls-glm-polr",method="logistic",verbose=FALSE))
summary(cv.plsRglm(Quality~.,data=bordeaux,nt=2,K=7,
modele="pls-glm-polr",method="probit",verbose=FALSE))
summary(cv.plsRglm(Quality~.,data=bordeaux,nt=2,K=7,
modele="pls-glm-polr",method="cloglog",verbose=FALSE))
suppressWarnings(summary(cv.plsRglm(Quality~.,data=bordeaux,nt=2,K=7,
modele="pls-glm-polr",method="cauchit",verbose=FALSE)))

</code></pre>

<hr>
<h2 id='cvtable'>Table method for summary of cross validated PLSR and PLSGLR models</h2><span id='topic+cvtable'></span><span id='topic+cvtable.plsR'></span><span id='topic+cvtable.plsRglm'></span>

<h3>Description</h3>

<p>The function <code>cvtable</code> is wrapper of <code>cvtable.plsR</code> and
<code>cvtable.plsRglm</code> that provides a table summary for the classes
<code>"summary.cv.plsRmodel"</code> and <code>"summary.cv.plsRglmmodel"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cvtable(x, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cvtable_+3A_x">x</code></td>
<td>
<p>an object of the class <code>"summary.cv.plsRmodel"</code></p>
</td></tr>
<tr><td><code id="cvtable_+3A_verbose">verbose</code></td>
<td>
<p>should results be displayed ?</p>
</td></tr>
<tr><td><code id="cvtable_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>list</code>List of Information Criteria computed for each fold.
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>References</h3>

<p>Nicolas Meyer, Myriam Maumy-Bertrand et
Frédéric Bertrand (2010). Comparing the linear and the
logistic PLS regression with qualitative predictors: application to
allelotyping data. <em>Journal de la Societe Francaise de Statistique</em>,
151(2), pages 1-18.
<a href="http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47">http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Cornell)
cv.modpls &lt;- cv.plsR(Y~.,data=Cornell,nt=6,K=6,NK=5)
res.cv.modpls &lt;- cvtable(summary(cv.modpls))
plot(res.cv.modpls) #defaults to type="CVQ2"
rm(list=c("cv.modpls","res.cv.modpls"))


data(Cornell)
cv.modpls &lt;- cv.plsR(Y~.,data=Cornell,nt=6,K=6,NK=25,verbose=FALSE)
res.cv.modpls &lt;- cvtable(summary(cv.modpls))
plot(res.cv.modpls) #defaults to type="CVQ2"
rm(list=c("cv.modpls","res.cv.modpls"))
	
data(Cornell)
cv.modpls &lt;- cv.plsR(Y~.,data=Cornell,nt=6,K=6,NK=100,verbose=FALSE)
res.cv.modpls &lt;- cvtable(summary(cv.modpls))
plot(res.cv.modpls) #defaults to type="CVQ2"
rm(list=c("cv.modpls","res.cv.modpls"))

data(Cornell)
cv.modplsglm &lt;- cv.plsRglm(Y~.,data=Cornell,nt=6,K=6,
modele="pls-glm-gaussian",NK=100,verbose=FALSE)
res.cv.modplsglm &lt;- cvtable(summary(cv.modplsglm))
plot(res.cv.modplsglm) #defaults to type="CVQ2Chi2"
rm(list=c("res.cv.modplsglm"))


</code></pre>

<hr>
<h2 id='dicho'>Dichotomization</h2><span id='topic+dicho'></span>

<h3>Description</h3>

<p>This function takes a real value and converts it to 1 if it is positive and
else to 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dicho(val)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dicho_+3A_val">val</code></td>
<td>
<p>A real value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>0 or 1.
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+ifelse">ifelse</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dimX &lt;- 6
Astar &lt;- 4
(dataAstar4 &lt;- t(replicate(10,simul_data_YX(dimX,Astar))))

dicho(dataAstar4)

rm(list=c("dimX","Astar"))

</code></pre>

<hr>
<h2 id='fowlkes'>Fowlkes dataset</h2><span id='topic+fowlkes'></span>

<h3>Description</h3>

<p>A classic dataset from Fowlkes.
</p>


<h3>Format</h3>

<p>A data frame with 9949 observations on the following 13 variables.
</p>
 <dl>
<dt>Y</dt><dd><p>binary response</p>
</dd> <dt>MA</dt><dd><p>a numeric
vector</p>
</dd> <dt>MW</dt><dd><p>a numeric vector</p>
</dd> <dt>NE</dt><dd><p>a numeric
vector</p>
</dd> <dt>NW</dt><dd><p>a numeric vector</p>
</dd> <dt>PA</dt><dd><p>a numeric
vector</p>
</dd> <dt>SO</dt><dd><p>a numeric vector</p>
</dd> <dt>SW</dt><dd><p>a numeric
vector</p>
</dd> <dt>color</dt><dd><p>a numeric vector</p>
</dd> <dt>age1</dt><dd><p>a numeric
vector</p>
</dd> <dt>age2</dt><dd><p>a numeric vector</p>
</dd> <dt>age3</dt><dd><p>a numeric
vector</p>
</dd> <dt>sexe</dt><dd><p>a numeric vector</p>
</dd> </dl>



<h3>Examples</h3>

<pre><code class='language-R'>
data(fowlkes)
str(fowlkes)

</code></pre>

<hr>
<h2 id='infcrit.dof'>Information criteria</h2><span id='topic+infcrit.dof'></span>

<h3>Description</h3>

<p>This function computes information criteria for existing plsR model using
Degrees of Freedom estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>infcrit.dof(modplsR, naive = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="infcrit.dof_+3A_modplsr">modplsR</code></td>
<td>
<p>A plsR model i.e. an object returned by one of the functions
<code>plsR</code>, <code>plsRmodel.default</code>, <code>plsRmodel.formula</code>,
<code>PLS_lm</code> or <code>PLS_lm_formula</code>.</p>
</td></tr>
<tr><td><code id="infcrit.dof_+3A_naive">naive</code></td>
<td>
<p>A boolean.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>naive=FALSE</code> returns AIC, BIC and gmdl values for estimated and
naive degrees of freedom. If <code>naive=TRUE</code> returns <code>NULL</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>matrix</code></td>
<td>
<p>AIC, BIC and gmdl values or <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>References</h3>

<p>M. Hansen, B. Yu. (2001). Model Selection and Minimum Descripion
Length Principle, <em>Journal of the American Statistical Association</em>,
96, 746-774.<br /> N. Kraemer, M. Sugiyama. (2011). The Degrees of Freedom of
Partial Least Squares Regression. <em>Journal of the American Statistical
Association</em>, 106(494), 697-705.<br /> N. Kraemer, M. Sugiyama, M.L. Braun.
(2009). Lanczos Approximations for the Speedup of Kernel Partial Least
Squares Regression, <em>Proceedings of the Twelfth International
Conference on Artificial Intelligence and Statistics (AISTATS)</em>, 272-279.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plsR.dof">plsR.dof</a></code> for degrees of freedom computation and
<code><a href="#topic+infcrit.dof">infcrit.dof</a></code> for computing information criteria directly from a
previously fitted plsR model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Cornell)
XCornell&lt;-Cornell[,1:7]
yCornell&lt;-Cornell[,8]
modpls &lt;- plsR(yCornell,XCornell,4)
infcrit.dof(modpls)

</code></pre>

<hr>
<h2 id='kfolds2Chisq'>Computes Predicted Chisquare for k-fold cross-validated partial least
squares regression models.</h2><span id='topic+kfolds2Chisq'></span>

<h3>Description</h3>

<p>This function computes Predicted Chisquare for k-fold cross validated
partial least squares regression models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kfolds2Chisq(pls_kfolds)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kfolds2Chisq_+3A_pls_kfolds">pls_kfolds</code></td>
<td>
<p>a k-fold cross validated partial least squares regression
glm model</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>list</code></td>
<td>
<p>Total Predicted Chisquare vs number of components for
the first group partition</p>
</td></tr> <tr><td><code>list()</code></td>
<td>
<p>...</p>
</td></tr> <tr><td><code>list</code></td>
<td>
<p>Total
Predicted Chisquare vs number of components for the last group partition</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Use <code><a href="#topic+cv.plsRglm">cv.plsRglm</a></code> to create k-fold cross validated partial
least squares regression glm models.
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>References</h3>

<p>Nicolas Meyer, Myriam Maumy-Bertrand et
Frédéric Bertrand (2010). Comparing the linear and the
logistic PLS regression with qualitative predictors: application to
allelotyping data. <em>Journal de la Societe Francaise de Statistique</em>,
151(2), pages 1-18.
<a href="http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47">http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kfolds2coeff">kfolds2coeff</a></code>, <code><a href="#topic+kfolds2Press">kfolds2Press</a></code>,
<code><a href="#topic+kfolds2Pressind">kfolds2Pressind</a></code>, <code><a href="#topic+kfolds2Chisqind">kfolds2Chisqind</a></code>,
<code><a href="#topic+kfolds2Mclassedind">kfolds2Mclassedind</a></code> and <code><a href="#topic+kfolds2Mclassed">kfolds2Mclassed</a></code> to
extract and transforms results from k-fold cross validation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Cornell)
XCornell&lt;-Cornell[,1:7]
yCornell&lt;-Cornell[,8]
bbb &lt;- cv.plsRglm(object=yCornell,dataX=XCornell,nt=3,modele="pls-glm-gaussian",K=16,verbose=FALSE)
bbb2 &lt;- cv.plsRglm(object=yCornell,dataX=XCornell,nt=3,modele="pls-glm-gaussian",K=5,verbose=FALSE)
kfolds2Chisq(bbb)
kfolds2Chisq(bbb2)
rm(list=c("XCornell","yCornell","bbb","bbb2"))


data(pine)
Xpine&lt;-pine[,1:10]
ypine&lt;-pine[,11]
bbb &lt;- cv.plsRglm(object=ypine,dataX=Xpine,nt=4,modele="pls-glm-gaussian",verbose=FALSE)
bbb2 &lt;- cv.plsRglm(object=ypine,dataX=Xpine,nt=10,modele="pls-glm-gaussian",K=10,verbose=FALSE)
kfolds2Chisq(bbb)
kfolds2Chisq(bbb2)
                  
XpineNAX21 &lt;- Xpine
XpineNAX21[1,2] &lt;- NA
bbbNA &lt;- cv.plsRglm(object=ypine,dataX=XpineNAX21,nt=10,modele="pls",K=10,verbose=FALSE)
kfolds2Press(bbbNA)
kfolds2Chisq(bbbNA)
bbbNA2 &lt;- cv.plsRglm(object=ypine,dataX=XpineNAX21,nt=4,modele="pls-glm-gaussian",verbose=FALSE)
bbbNA3 &lt;- cv.plsRglm(object=ypine,dataX=XpineNAX21,nt=10,modele="pls-glm-gaussian",K=10,
verbose=FALSE)
kfolds2Chisq(bbbNA2)
kfolds2Chisq(bbbNA3)
rm(list=c("Xpine","XpineNAX21","ypine","bbb","bbb2","bbbNA","bbbNA2","bbbNA3"))


data(aze_compl)
Xaze_compl&lt;-aze_compl[,2:34]
yaze_compl&lt;-aze_compl$y
kfolds2Chisq(cv.plsRglm(object=yaze_compl,dataX=Xaze_compl,nt=4,modele="pls-glm-family",
family="binomial",verbose=FALSE))
kfolds2Chisq(cv.plsRglm(object=yaze_compl,dataX=Xaze_compl,nt=4,modele="pls-glm-logistic",
verbose=FALSE))
kfolds2Chisq(cv.plsRglm(object=yaze_compl,dataX=Xaze_compl,nt=10,modele="pls-glm-family",
family=binomial(),K=10,verbose=FALSE))
kfolds2Chisq(cv.plsRglm(object=yaze_compl,dataX=Xaze_compl,nt=10,modele="pls-glm-logistic",
K=10,verbose=FALSE))
rm(list=c("Xaze_compl","yaze_compl"))


</code></pre>

<hr>
<h2 id='kfolds2Chisqind'>Computes individual Predicted Chisquare for k-fold cross validated partial
least squares regression models.</h2><span id='topic+kfolds2Chisqind'></span>

<h3>Description</h3>

<p>This function computes individual Predicted Chisquare for k-fold cross
validated partial least squares regression models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kfolds2Chisqind(pls_kfolds)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kfolds2Chisqind_+3A_pls_kfolds">pls_kfolds</code></td>
<td>
<p>a k-fold cross validated partial least squares regression
glm model</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>list</code></td>
<td>
<p>Individual PChisq vs number of components for the first
group partition</p>
</td></tr> <tr><td><code>list()</code></td>
<td>
<p>...</p>
</td></tr> <tr><td><code>list</code></td>
<td>
<p>Individual PChisq vs
number of components for the last group partition</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Use <code><a href="#topic+cv.plsRglm">cv.plsRglm</a></code> to create k-fold cross validated partial
least squares regression glm models.
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>References</h3>

<p>Nicolas Meyer, Myriam Maumy-Bertrand et
Frédéric Bertrand (2010). Comparing the linear and the
logistic PLS regression with qualitative predictors: application to
allelotyping data. <em>Journal de la Societe Francaise de Statistique</em>,
151(2), pages 1-18.
<a href="http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47">http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kfolds2coeff">kfolds2coeff</a></code>, <code><a href="#topic+kfolds2Press">kfolds2Press</a></code>,
<code><a href="#topic+kfolds2Pressind">kfolds2Pressind</a></code>, <code><a href="#topic+kfolds2Chisq">kfolds2Chisq</a></code>,
<code><a href="#topic+kfolds2Mclassedind">kfolds2Mclassedind</a></code> and <code><a href="#topic+kfolds2Mclassed">kfolds2Mclassed</a></code> to
extract and transforms results from k-fold cross-validation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Cornell)
XCornell&lt;-Cornell[,1:7]
yCornell&lt;-Cornell[,8]
bbb &lt;- cv.plsRglm(object=yCornell,dataX=XCornell,nt=3,modele="pls-glm-gaussian",K=16,verbose=FALSE)
bbb2 &lt;- cv.plsRglm(object=yCornell,dataX=XCornell,nt=3,modele="pls-glm-gaussian",K=5,verbose=FALSE)
kfolds2Chisqind(bbb)
kfolds2Chisqind(bbb2)
rm(list=c("XCornell","yCornell","bbb","bbb2"))


data(pine)
Xpine&lt;-pine[,1:10]
ypine&lt;-pine[,11]
bbb &lt;- cv.plsRglm(object=ypine,dataX=Xpine,nt=4,modele="pls-glm-gaussian",verbose=FALSE)
bbb2 &lt;- cv.plsRglm(object=ypine,dataX=Xpine,nt=10,modele="pls-glm-gaussian",K=10,verbose=FALSE)
kfolds2Chisqind(bbb)
kfolds2Chisqind(bbb2)
                  
XpineNAX21 &lt;- Xpine
XpineNAX21[1,2] &lt;- NA
bbbNA &lt;- cv.plsRglm(object=ypine,dataX=XpineNAX21,nt=10,modele="pls",K=10,verbose=FALSE)
kfolds2Pressind(bbbNA)
kfolds2Chisqind(bbbNA)
bbbNA2 &lt;- cv.plsRglm(object=ypine,dataX=XpineNAX21,nt=4,modele="pls-glm-gaussian",verbose=FALSE)
bbbNA3 &lt;- cv.plsRglm(object=ypine,dataX=XpineNAX21,nt=10,modele="pls-glm-gaussian",
K=10,verbose=FALSE)
kfolds2Chisqind(bbbNA2)
kfolds2Chisqind(bbbNA3)
rm(list=c("Xpine","XpineNAX21","ypine","bbb","bbb2","bbbNA","bbbNA2","bbbNA3"))


data(aze_compl)
Xaze_compl&lt;-aze_compl[,2:34]
yaze_compl&lt;-aze_compl$y
kfolds2Chisqind(cv.plsRglm(object=yaze_compl,dataX=Xaze_compl,nt=4,modele="pls-glm-family",
family=binomial(),verbose=FALSE))
kfolds2Chisqind(cv.plsRglm(object=yaze_compl,dataX=Xaze_compl,nt=4,modele="pls-glm-logistic",
verbose=FALSE))
kfolds2Chisqind(cv.plsRglm(object=yaze_compl,dataX=Xaze_compl,nt=10,modele="pls-glm-family",
family=binomial(),K=10,verbose=FALSE))
kfolds2Chisqind(cv.plsRglm(object=yaze_compl,dataX=Xaze_compl,nt=10,
modele="pls-glm-logistic",K=10,verbose=FALSE))
rm(list=c("Xaze_compl","yaze_compl"))


</code></pre>

<hr>
<h2 id='kfolds2coeff'>Extracts coefficients from k-fold cross validated partial least squares
regression models</h2><span id='topic+kfolds2coeff'></span>

<h3>Description</h3>

<p>This fonction extracts coefficients from k-fold cross validated partial
least squares regression models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kfolds2coeff(pls_kfolds)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kfolds2coeff_+3A_pls_kfolds">pls_kfolds</code></td>
<td>
<p>an object that is a k-fold cross validated partial least
squares regression models either lm or glm</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This fonctions works for plsR and plsRglm models.
</p>


<h3>Value</h3>

<table>
<tr><td><code>coef.all</code></td>
<td>
<p>matrix with the values of the coefficients for each
leave one out step or <code>NULL</code> if another type of cross validation was
used.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Only for <code>NK=1</code> and leave one out CV
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>References</h3>

<p>Nicolas Meyer, Myriam Maumy-Bertrand et
Frédéric Bertrand (2010). Comparing the linear and the
logistic PLS regression with qualitative predictors: application to
allelotyping data. <em>Journal de la Societe Francaise de Statistique</em>,
151(2), pages 1-18.
<a href="http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47">http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kfolds2Pressind">kfolds2Pressind</a></code>, <code><a href="#topic+kfolds2Press">kfolds2Press</a></code>,
<code><a href="#topic+kfolds2Mclassedind">kfolds2Mclassedind</a></code>, <code><a href="#topic+kfolds2Mclassed">kfolds2Mclassed</a></code> and
<code><a href="#topic+summary.plsRmodel">summary</a></code> to extract and transform
results from k-fold cross validation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Cornell)
XCornell&lt;-Cornell[,1:7]
yCornell&lt;-Cornell[,8]
bbb &lt;- PLS_lm_kfoldcv(dataY=yCornell,dataX=XCornell,nt=3,K=nrow(XCornell),keepcoeffs=TRUE,
verbose=FALSE)
kfolds2coeff(bbb)
boxplot(kfolds2coeff(bbb)[,2])
rm(list=c("XCornell","yCornell","bbb"))

data(pine)
Xpine&lt;-pine[,1:10]
ypine&lt;-pine[,11]
bbb2 &lt;- cv.plsR(object=ypine,dataX=Xpine,nt=4,K=nrow(Xpine),keepcoeffs=TRUE,verbose=FALSE)
kfolds2coeff(bbb2)
boxplot(kfolds2coeff(bbb2)[,1])
rm(list=c("Xpine","ypine","bbb2"))

</code></pre>

<hr>
<h2 id='kfolds2CVinfos_glm'>Extracts and computes information criteria and fits statistics for k-fold
cross validated partial least squares glm models</h2><span id='topic+kfolds2CVinfos_glm'></span>

<h3>Description</h3>

<p>This function extracts and computes information criteria and fits statistics
for k-fold cross validated partial least squares glm models for both formula
or classic specifications of the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kfolds2CVinfos_glm(pls_kfolds, MClassed = FALSE, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kfolds2CVinfos_glm_+3A_pls_kfolds">pls_kfolds</code></td>
<td>
<p>an object computed using <code><a href="#topic+cv.plsRglm">cv.plsRglm</a></code></p>
</td></tr>
<tr><td><code id="kfolds2CVinfos_glm_+3A_mclassed">MClassed</code></td>
<td>
<p>should number of miss classed be computed ?</p>
</td></tr>
<tr><td><code id="kfolds2CVinfos_glm_+3A_verbose">verbose</code></td>
<td>
<p>should infos be displayed ?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Mclassed option should only set to <code>TRUE</code> if the response is
binary.
</p>


<h3>Value</h3>

<table>
<tr><td><code>list</code></td>
<td>
<p>table of fit statistics for first group partition</p>
</td></tr>
<tr><td><code>list()</code></td>
<td>
<p>...</p>
</td></tr> <tr><td><code>list</code></td>
<td>
<p>table of fit statistics for last group
partition</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Use <code><a href="base.html#topic+summary">summary</a></code> and <code><a href="#topic+cv.plsRglm">cv.plsRglm</a></code> instead.
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>References</h3>

<p>Nicolas Meyer, Myriam Maumy-Bertrand et
Frédéric Bertrand (2010). Comparing the linear and the
logistic PLS regression with qualitative predictors: application to
allelotyping data. <em>Journal de la Societe Francaise de Statistique</em>,
151(2), pages 1-18.
<a href="http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47">http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kfolds2coeff">kfolds2coeff</a></code>, <code><a href="#topic+kfolds2Pressind">kfolds2Pressind</a></code>,
<code><a href="#topic+kfolds2Press">kfolds2Press</a></code>, <code><a href="#topic+kfolds2Mclassedind">kfolds2Mclassedind</a></code> and
<code><a href="#topic+kfolds2Mclassed">kfolds2Mclassed</a></code> to extract and transforms results from k-fold
cross-validation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(Cornell)
summary(cv.plsRglm(Y~.,data=Cornell,
nt=6,K=12,NK=1,keepfolds=FALSE,keepdataY=TRUE,modele="pls",verbose=FALSE),MClassed=TRUE)


data(aze_compl)
summary(cv.plsR(y~.,data=aze_compl,nt=10,K=8,modele="pls",verbose=FALSE),
MClassed=TRUE,verbose=FALSE)
summary(cv.plsRglm(y~.,data=aze_compl,nt=10,K=8,modele="pls",verbose=FALSE),
MClassed=TRUE,verbose=FALSE)
summary(cv.plsRglm(y~.,data=aze_compl,nt=10,K=8,
modele="pls-glm-family",
family=gaussian(),verbose=FALSE),
MClassed=TRUE,verbose=FALSE)
summary(cv.plsRglm(y~.,data=aze_compl,nt=10,K=8,
modele="pls-glm-logistic",
verbose=FALSE),MClassed=TRUE,verbose=FALSE)
summary(cv.plsRglm(y~.,data=aze_compl,nt=10,K=8,
modele="pls-glm-family",
family=binomial(),verbose=FALSE),
MClassed=TRUE,verbose=FALSE)


if(require(chemometrics)){
data(hyptis)
hyptis
yhyptis &lt;- factor(hyptis$Group,ordered=TRUE)
Xhyptis &lt;- as.data.frame(hyptis[,c(1:6)])
options(contrasts = c("contr.treatment", "contr.poly"))
modpls2 &lt;- plsRglm(yhyptis,Xhyptis,6,modele="pls-glm-polr")
modpls2$Coeffsmodel_vals
modpls2$InfCrit
modpls2$Coeffs
modpls2$std.coeffs

table(yhyptis,predict(modpls2$FinalModel,type="class"))

modpls3 &lt;- PLS_glm(yhyptis[-c(1,2,3)],Xhyptis[-c(1,2,3),],3,modele="pls-glm-polr",
dataPredictY=Xhyptis[c(1,2,3),],verbose=FALSE)

summary(cv.plsRglm(factor(Group,ordered=TRUE)~.,data=hyptis[,-c(7,8)],nt=4,K=10,
random=TRUE,modele="pls-glm-polr",keepcoeffs=TRUE,verbose=FALSE),
MClassed=TRUE,verbose=FALSE)
}


</code></pre>

<hr>
<h2 id='kfolds2CVinfos_lm'>Extracts and computes information criteria and fits statistics for k-fold
cross validated partial least squares models</h2><span id='topic+kfolds2CVinfos_lm'></span>

<h3>Description</h3>

<p>This function extracts and computes information criteria and fits statistics
for k-fold cross validated partial least squares models for both formula or
classic specifications of the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kfolds2CVinfos_lm(pls_kfolds, MClassed = FALSE, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kfolds2CVinfos_lm_+3A_pls_kfolds">pls_kfolds</code></td>
<td>
<p>an object computed using <code><a href="#topic+PLS_lm_kfoldcv">PLS_lm_kfoldcv</a></code></p>
</td></tr>
<tr><td><code id="kfolds2CVinfos_lm_+3A_mclassed">MClassed</code></td>
<td>
<p>should number of miss classed be computed</p>
</td></tr>
<tr><td><code id="kfolds2CVinfos_lm_+3A_verbose">verbose</code></td>
<td>
<p>should infos be displayed ?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Mclassed option should only set to <code>TRUE</code> if the response is
binary.
</p>


<h3>Value</h3>

<table>
<tr><td><code>list</code></td>
<td>
<p>table of fit statistics for first group partition</p>
</td></tr>
<tr><td><code>list()</code></td>
<td>
<p>...</p>
</td></tr> <tr><td><code>list</code></td>
<td>
<p>table of fit statistics for last group
partition</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Use <code><a href="base.html#topic+summary">summary</a></code> and <code><a href="#topic+cv.plsR">cv.plsR</a></code> instead.
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>References</h3>

<p>Nicolas Meyer, Myriam Maumy-Bertrand et
Frédéric Bertrand (2010). Comparing the linear and the
logistic PLS regression with qualitative predictors: application to
allelotyping data. <em>Journal de la Societe Francaise de Statistique</em>,
151(2), pages 1-18.
<a href="http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47">http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kfolds2coeff">kfolds2coeff</a></code>, <code><a href="#topic+kfolds2Pressind">kfolds2Pressind</a></code>,
<code><a href="#topic+kfolds2Press">kfolds2Press</a></code>, <code><a href="#topic+kfolds2Mclassedind">kfolds2Mclassedind</a></code> and
<code><a href="#topic+kfolds2Mclassed">kfolds2Mclassed</a></code> to extract and transforms results from k-fold
cross-validation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Cornell)
summary(cv.plsR(Y~.,data=Cornell,nt=10,K=6,verbose=FALSE))


data(pine)
summary(cv.plsR(x11~.,data=pine,nt=10,NK=3,verbose=FALSE),verbose=FALSE)
data(pineNAX21)
summary(cv.plsR(x11~.,data=pineNAX21,nt=10,NK=3,
verbose=FALSE),verbose=FALSE)


data(aze_compl)
summary(cv.plsR(y~.,data=aze_compl,nt=10,K=8,NK=3,
verbose=FALSE),MClassed=TRUE,verbose=FALSE)


</code></pre>

<hr>
<h2 id='kfolds2Mclassed'>Number of missclassified individuals for k-fold cross validated partial
least squares regression models.</h2><span id='topic+kfolds2Mclassed'></span>

<h3>Description</h3>

<p>This function indicates the total number of missclassified individuals for
k-fold cross validated partial least squares regression models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kfolds2Mclassed(pls_kfolds)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kfolds2Mclassed_+3A_pls_kfolds">pls_kfolds</code></td>
<td>
<p>a k-fold cross validated partial least squares regression
model used on binary data</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>list</code></td>
<td>
<p>Total number of missclassified individuals vs number of
components for the first group partition</p>
</td></tr> <tr><td><code>list()</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code>list</code></td>
<td>
<p>Total number of missclassified individuals vs number of
components for the last group partition</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Use <code><a href="#topic+cv.plsR">cv.plsR</a></code> to create k-fold cross validated partial
least squares regression models.
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>References</h3>

<p>Nicolas Meyer, Myriam Maumy-Bertrand et
Frédéric Bertrand (2010). Comparing the linear and the
logistic PLS regression with qualitative predictors: application to
allelotyping data. <em>Journal de la Societe Francaise de Statistique</em>,
151(2), pages 1-18.
<a href="http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47">http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kfolds2coeff">kfolds2coeff</a></code>, <code><a href="#topic+kfolds2Press">kfolds2Press</a></code>,
<code><a href="#topic+kfolds2Pressind">kfolds2Pressind</a></code> and <code><a href="#topic+kfolds2Mclassedind">kfolds2Mclassedind</a></code> to
extract and transforms results from k-fold cross validation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(aze_compl)
Xaze_compl&lt;-aze_compl[,2:34]
yaze_compl&lt;-aze_compl$y
kfolds2Mclassed(cv.plsR(object=yaze_compl,dataX=Xaze_compl,nt=10,K=8,NK=1,verbose=FALSE))
kfolds2Mclassed(cv.plsR(object=yaze_compl,dataX=Xaze_compl,nt=10,K=8,NK=2,verbose=FALSE))
rm(list=c("Xaze_compl","yaze_compl"))


</code></pre>

<hr>
<h2 id='kfolds2Mclassedind'>Number of missclassified individuals per group for k-fold cross validated
partial least squares regression models.</h2><span id='topic+kfolds2Mclassedind'></span>

<h3>Description</h3>

<p>This function indicates the number of missclassified individuals per group
for k-fold cross validated partial least squares regression models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kfolds2Mclassedind(pls_kfolds)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kfolds2Mclassedind_+3A_pls_kfolds">pls_kfolds</code></td>
<td>
<p>a k-fold cross validated partial least squares regression
model used on binary data</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>list</code></td>
<td>
<p>Number of missclassified individuals per group vs number
of components for the first group partition</p>
</td></tr> <tr><td><code>list()</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code>list</code></td>
<td>
<p>Number of missclassified individuals per group vs number of
components for the last group partition</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Use <code><a href="#topic+cv.plsR">cv.plsR</a></code> or <code><a href="#topic+cv.plsRglm">cv.plsRglm</a></code> to create k-fold
cross validated partial least squares regression models or generalized
linear ones.
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>References</h3>

<p>Nicolas Meyer, Myriam Maumy-Bertrand et
Frédéric Bertrand (2010). Comparing the linear and the
logistic PLS regression with qualitative predictors: application to
allelotyping data. <em>Journal de la Societe Francaise de Statistique</em>,
151(2), pages 1-18.
<a href="http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47">http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kfolds2coeff">kfolds2coeff</a></code>, <code><a href="#topic+kfolds2Press">kfolds2Press</a></code>,
<code><a href="#topic+kfolds2Pressind">kfolds2Pressind</a></code> and <code><a href="#topic+kfolds2Mclassed">kfolds2Mclassed</a></code> to extract
and transforms results from k-fold cross-validation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(aze_compl)
Xaze_compl&lt;-aze_compl[,2:34]
yaze_compl&lt;-aze_compl$y
kfolds2Mclassedind(cv.plsR(object=yaze_compl,dataX=Xaze_compl,nt=10,K=8,NK=1,verbose=FALSE))
kfolds2Mclassedind(cv.plsR(object=yaze_compl,dataX=Xaze_compl,nt=10,K=8,NK=2,verbose=FALSE))
rm(list=c("Xaze_compl","yaze_compl"))


</code></pre>

<hr>
<h2 id='kfolds2Press'>Computes PRESS for k-fold cross validated partial least squares regression
models.</h2><span id='topic+kfolds2Press'></span>

<h3>Description</h3>

<p>This function computes PRESS for k-fold cross validated partial least
squares regression models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kfolds2Press(pls_kfolds)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kfolds2Press_+3A_pls_kfolds">pls_kfolds</code></td>
<td>
<p>a k-fold cross validated partial least squares regression
model</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>list</code></td>
<td>
<p>Press vs number of components for the first group
partition</p>
</td></tr> <tr><td><code>list()</code></td>
<td>
<p>...</p>
</td></tr> <tr><td><code>list</code></td>
<td>
<p>Press vs number of components
for the last group partition</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Use <code><a href="#topic+cv.plsR">cv.plsR</a></code> to create k-fold cross validated partial
least squares regression models.
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>References</h3>

<p>Nicolas Meyer, Myriam Maumy-Bertrand et
Frédéric Bertrand (2010). Comparing the linear and the
logistic PLS regression with qualitative predictors: application to
allelotyping data. <em>Journal de la Societe Francaise de Statistique</em>,
151(2), pages 1-18.
<a href="http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47">http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kfolds2coeff">kfolds2coeff</a></code>, <code><a href="#topic+kfolds2Pressind">kfolds2Pressind</a></code>,
<code><a href="#topic+kfolds2Mclassedind">kfolds2Mclassedind</a></code> and <code><a href="#topic+kfolds2Mclassed">kfolds2Mclassed</a></code> to
extract and transforms results from k-fold cross validation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Cornell)
XCornell&lt;-Cornell[,1:7]
yCornell&lt;-Cornell[,8]
kfolds2Press(cv.plsR(object=yCornell,dataX=data.frame(scale(as.matrix(XCornell))[,]),
nt=6,K=12,NK=1,verbose=FALSE))
kfolds2Press(cv.plsR(object=yCornell,dataX=data.frame(scale(as.matrix(XCornell))[,]),
nt=6,K=6,NK=1,verbose=FALSE))
rm(list=c("XCornell","yCornell"))


data(pine)
Xpine&lt;-pine[,1:10]
ypine&lt;-pine[,11]
kfolds2Press(cv.plsR(object=ypine,dataX=Xpine,nt=10,NK=1,verbose=FALSE))
kfolds2Press(cv.plsR(object=ypine,dataX=Xpine,nt=10,NK=2,verbose=FALSE))

XpineNAX21 &lt;- Xpine
XpineNAX21[1,2] &lt;- NA
kfolds2Press(cv.plsR(object=ypine,dataX=XpineNAX21,nt=10,NK=1,verbose=FALSE))
kfolds2Press(cv.plsR(object=ypine,dataX=XpineNAX21,nt=10,NK=2,verbose=FALSE))
rm(list=c("Xpine","XpineNAX21","ypine"))


</code></pre>

<hr>
<h2 id='kfolds2Pressind'>Computes individual PRESS for k-fold cross validated partial least squares
regression models.</h2><span id='topic+kfolds2Pressind'></span>

<h3>Description</h3>

<p>This function computes individual PRESS for k-fold cross validated partial
least squares regression models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kfolds2Pressind(pls_kfolds)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kfolds2Pressind_+3A_pls_kfolds">pls_kfolds</code></td>
<td>
<p>a k-fold cross validated partial least squares regression
model</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>list</code></td>
<td>
<p>Individual Press vs number of components for the first
group partition</p>
</td></tr> <tr><td><code>list()</code></td>
<td>
<p>...</p>
</td></tr> <tr><td><code>list</code></td>
<td>
<p>Individual Press vs
number of components for the last group partition</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Use <code><a href="#topic+cv.plsR">cv.plsR</a></code> to create k-fold cross validated partial
least squares regression models.
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>References</h3>

<p>Nicolas Meyer, Myriam Maumy-Bertrand et
Frédéric Bertrand (2010). Comparing the linear and the
logistic PLS regression with qualitative predictors: application to
allelotyping data. <em>Journal de la Societe Francaise de Statistique</em>,
151(2), pages 1-18.
<a href="http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47">http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kfolds2coeff">kfolds2coeff</a></code>, <code><a href="#topic+kfolds2Press">kfolds2Press</a></code>,
<code><a href="#topic+kfolds2Mclassedind">kfolds2Mclassedind</a></code> and <code><a href="#topic+kfolds2Mclassed">kfolds2Mclassed</a></code> to
extract and transforms results from k-fold cross validation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Cornell)
XCornell&lt;-Cornell[,1:7]
yCornell&lt;-Cornell[,8]
kfolds2Pressind(cv.plsR(object=yCornell,dataX=data.frame(scale(as.matrix(XCornell))[,]),
nt=6,K=12,NK=1))
kfolds2Pressind(cv.plsR(object=yCornell,dataX=data.frame(scale(as.matrix(XCornell))[,]),
nt=6,K=6,NK=1))
rm(list=c("XCornell","yCornell"))


data(pine)
Xpine&lt;-pine[,1:10]
ypine&lt;-pine[,11]
kfolds2Pressind(cv.plsR(object=ypine,dataX=Xpine,nt=10,NK=1,verbose=FALSE))
kfolds2Pressind(cv.plsR(object=ypine,dataX=Xpine,nt=10,NK=2,verbose=FALSE))

XpineNAX21 &lt;- Xpine
XpineNAX21[1,2] &lt;- NA
kfolds2Pressind(cv.plsR(object=ypine,dataX=XpineNAX21,nt=10,NK=1,verbose=FALSE))
kfolds2Pressind(cv.plsR(object=ypine,dataX=XpineNAX21,nt=10,NK=2,verbose=FALSE))
rm(list=c("Xpine","XpineNAX21","ypine"))


</code></pre>

<hr>
<h2 id='loglikpls'>loglikelihood function for plsR models</h2><span id='topic+loglikpls'></span>

<h3>Description</h3>

<p>This function provides loglikelihood computation for an univariate plsR
model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglikpls(residpls, weights = rep.int(1, length(residpls)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loglikpls_+3A_residpls">residpls</code></td>
<td>
<p>Residuals of a fitted univariate plsR model</p>
</td></tr>
<tr><td><code id="loglikpls_+3A_weights">weights</code></td>
<td>
<p>Weights of observations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Loglikelihood functions for plsR models with univariate response.
</p>


<h3>Value</h3>

<table>
<tr><td><code>real</code></td>
<td>
<p>Loglikelihood value</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>References</h3>

<p>Baibing Li, Julian Morris, Elaine B. Martin, Model selection for
partial least squares regression, Chemometrics and Intelligent Laboratory
Systems 64 (2002) 79-89, <a href="https://doi.org/10.1016/S0169-7439%2802%2900051-5">doi:10.1016/S0169-7439(02)00051-5</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AICpls">AICpls</a></code> for AIC computation and <code><a href="stats.html#topic+logLik">logLik</a></code>
for loglikelihood computations for linear models
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(pine)
ypine &lt;- pine[,11]
Xpine &lt;- pine[,1:10]
(Pinscaled &lt;- as.data.frame(cbind(scale(ypine),scale(as.matrix(Xpine)))))
colnames(Pinscaled)[1] &lt;- "yy"

lm(yy~x1+x2+x3+x4+x5+x6+x7+x8+x9+x10,data=Pinscaled)

modpls &lt;- plsR(ypine,Xpine,10)
modpls$Std.Coeffs
lm(yy~x1+x2+x3+x4+x5+x6+x7+x8+x9+x10,data=Pinscaled)

AIC(lm(yy~x1+x2+x3+x4+x5+x6+x7+x8+x9+x10,data=Pinscaled))
print(logLik(lm(yy~x1+x2+x3+x4+x5+x6+x7+x8+x9+x10,data=Pinscaled)))

sum(dnorm(modpls$RepY, modpls$Std.ValsPredictY, sqrt(mean(modpls$residY^2)), log=TRUE))
sum(dnorm(Pinscaled$yy,fitted(lm(yy~x1+x2+x3+x4+x5+x6+x7+x8+x9+x10,data=Pinscaled)),
sqrt(mean(residuals(lm(yy~x1+x2+x3+x4+x5+x6+x7+x8+x9+x10,data=Pinscaled))^2)), log=TRUE))
loglikpls(modpls$residY)
loglikpls(residuals(lm(yy~x1+x2+x3+x4+x5+x6+x7+x8+x9+x10,data=Pinscaled)))
AICpls(10,residuals(lm(yy~x1+x2+x3+x4+x5+x6+x7+x8+x9+x10,data=Pinscaled)))
AICpls(10,modpls$residY)

</code></pre>

<hr>
<h2 id='permcoefs.plsR'>Coefficients for permutation bootstrap computations of PLSR models</h2><span id='topic+permcoefs.plsR'></span>

<h3>Description</h3>

<p>A function passed to <code>boot</code> to perform bootstrap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permcoefs.plsR(dataset, ind, nt, modele, maxcoefvalues, ifbootfail, verbose)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permcoefs.plsR_+3A_dataset">dataset</code></td>
<td>
<p>dataset to resample</p>
</td></tr>
<tr><td><code id="permcoefs.plsR_+3A_ind">ind</code></td>
<td>
<p>indices for resampling</p>
</td></tr>
<tr><td><code id="permcoefs.plsR_+3A_nt">nt</code></td>
<td>
<p>number of components to use</p>
</td></tr>
<tr><td><code id="permcoefs.plsR_+3A_modele">modele</code></td>
<td>
<p>type of modele to use, see <a href="#topic+plsR">plsR</a></p>
</td></tr>
<tr><td><code id="permcoefs.plsR_+3A_maxcoefvalues">maxcoefvalues</code></td>
<td>
<p>maximum values allowed for the estimates of the
coefficients to discard those coming from singular bootstrap samples</p>
</td></tr>
<tr><td><code id="permcoefs.plsR_+3A_ifbootfail">ifbootfail</code></td>
<td>
<p>value to return if the estimation fails on a bootstrap
sample</p>
</td></tr>
<tr><td><code id="permcoefs.plsR_+3A_verbose">verbose</code></td>
<td>
<p>should info messages be displayed ?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>estimates on a bootstrap sample or <code>ifbootfail</code> value if the
bootstrap computation fails.
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+bootpls">bootpls</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Cornell)
XCornell&lt;-Cornell[,1:7]
yCornell&lt;-Cornell[,8]

# Lazraq-Cleroux PLS (Y,X) bootstrap
# statistic=permcoefs.plsR is the default for (Y,X) permutation resampling of PLSR models.
set.seed(250)
modpls &lt;- plsR(yCornell,XCornell,1)
Cornell.bootYX &lt;- bootpls(modpls, sim="permutation", R=250, statistic=permcoefs.plsR, verbose=FALSE)

</code></pre>

<hr>
<h2 id='permcoefs.plsR.raw'>Raw coefficients for permutation bootstrap computations of PLSR models</h2><span id='topic+permcoefs.plsR.raw'></span>

<h3>Description</h3>

<p>A function passed to <code>boot</code> to perform bootstrap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permcoefs.plsR.raw(
  dataset,
  ind,
  nt,
  modele,
  maxcoefvalues,
  ifbootfail,
  verbose
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permcoefs.plsR.raw_+3A_dataset">dataset</code></td>
<td>
<p>dataset to resample</p>
</td></tr>
<tr><td><code id="permcoefs.plsR.raw_+3A_ind">ind</code></td>
<td>
<p>indices for resampling</p>
</td></tr>
<tr><td><code id="permcoefs.plsR.raw_+3A_nt">nt</code></td>
<td>
<p>number of components to use</p>
</td></tr>
<tr><td><code id="permcoefs.plsR.raw_+3A_modele">modele</code></td>
<td>
<p>type of modele to use, see <a href="#topic+plsR">plsR</a></p>
</td></tr>
<tr><td><code id="permcoefs.plsR.raw_+3A_maxcoefvalues">maxcoefvalues</code></td>
<td>
<p>maximum values allowed for the estimates of the
coefficients to discard those coming from singular bootstrap samples</p>
</td></tr>
<tr><td><code id="permcoefs.plsR.raw_+3A_ifbootfail">ifbootfail</code></td>
<td>
<p>value to return if the estimation fails on a bootstrap
sample</p>
</td></tr>
<tr><td><code id="permcoefs.plsR.raw_+3A_verbose">verbose</code></td>
<td>
<p>should info messages be displayed ?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>estimates on a bootstrap sample or <code>ifbootfail</code> value if the
bootstrap computation fails.
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+bootpls">bootpls</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Cornell)
XCornell&lt;-Cornell[,1:7]
yCornell&lt;-Cornell[,8]

# Lazraq-Cleroux PLS (Y,X) bootstrap
set.seed(250)
modpls &lt;- permcoefs.plsR.raw(Cornell[,-8],1:nrow(Cornell),nt=3,
maxcoefvalues=1e5,ifbootfail=rep(0,3),verbose=FALSE)

</code></pre>

<hr>
<h2 id='permcoefs.plsRglm'>Coefficients for permutation bootstrap computations of PLSGLR models</h2><span id='topic+permcoefs.plsRglm'></span>

<h3>Description</h3>

<p>A function passed to <code>boot</code> to perform bootstrap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permcoefs.plsRglm(
  dataset,
  ind,
  nt,
  modele,
  family = NULL,
  maxcoefvalues,
  ifbootfail,
  verbose
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permcoefs.plsRglm_+3A_dataset">dataset</code></td>
<td>
<p>dataset to resample</p>
</td></tr>
<tr><td><code id="permcoefs.plsRglm_+3A_ind">ind</code></td>
<td>
<p>indices for resampling</p>
</td></tr>
<tr><td><code id="permcoefs.plsRglm_+3A_nt">nt</code></td>
<td>
<p>number of components to use</p>
</td></tr>
<tr><td><code id="permcoefs.plsRglm_+3A_modele">modele</code></td>
<td>
<p>type of modele to use, see <a href="#topic+plsRglm">plsRglm</a></p>
</td></tr>
<tr><td><code id="permcoefs.plsRglm_+3A_family">family</code></td>
<td>
<p>glm family to use, see <a href="#topic+plsRglm">plsRglm</a></p>
</td></tr>
<tr><td><code id="permcoefs.plsRglm_+3A_maxcoefvalues">maxcoefvalues</code></td>
<td>
<p>maximum values allowed for the estimates of the
coefficients to discard those coming from singular bootstrap samples</p>
</td></tr>
<tr><td><code id="permcoefs.plsRglm_+3A_ifbootfail">ifbootfail</code></td>
<td>
<p>value to return if the estimation fails on a bootstrap
sample</p>
</td></tr>
<tr><td><code id="permcoefs.plsRglm_+3A_verbose">verbose</code></td>
<td>
<p>should info messages be displayed ?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>estimates on a bootstrap sample or <code>ifbootfail</code> value if the
bootstrap computation fails.
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+bootplsglm">bootplsglm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Cornell)

# (Y,X) bootstrap of a PLSGLR model
# statistic=coefs.plsRglm is the default for (Y,X) bootstrap of a PLSGLR models.
set.seed(250)
modplsglm &lt;- plsRglm(Y~.,data=Cornell,1,modele="pls-glm-family",family=gaussian)
Cornell.bootYX &lt;- bootplsglm(modplsglm, R=250, typeboot="plsmodel", 
sim="permutation", statistic=permcoefs.plsRglm, verbose=FALSE)

</code></pre>

<hr>
<h2 id='permcoefs.plsRglm.raw'>Raw coefficients for permutation bootstrap computations of PLSGLR models</h2><span id='topic+permcoefs.plsRglm.raw'></span>

<h3>Description</h3>

<p>A function passed to <code>boot</code> to perform bootstrap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permcoefs.plsRglm.raw(
  dataset,
  ind,
  nt,
  modele,
  family = NULL,
  maxcoefvalues,
  ifbootfail,
  verbose
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permcoefs.plsRglm.raw_+3A_dataset">dataset</code></td>
<td>
<p>dataset to resample</p>
</td></tr>
<tr><td><code id="permcoefs.plsRglm.raw_+3A_ind">ind</code></td>
<td>
<p>indices for resampling</p>
</td></tr>
<tr><td><code id="permcoefs.plsRglm.raw_+3A_nt">nt</code></td>
<td>
<p>number of components to use</p>
</td></tr>
<tr><td><code id="permcoefs.plsRglm.raw_+3A_modele">modele</code></td>
<td>
<p>type of modele to use, see <a href="#topic+plsRglm">plsRglm</a></p>
</td></tr>
<tr><td><code id="permcoefs.plsRglm.raw_+3A_family">family</code></td>
<td>
<p>glm family to use, see <a href="#topic+plsRglm">plsRglm</a></p>
</td></tr>
<tr><td><code id="permcoefs.plsRglm.raw_+3A_maxcoefvalues">maxcoefvalues</code></td>
<td>
<p>maximum values allowed for the estimates of the
coefficients to discard those coming from singular bootstrap samples</p>
</td></tr>
<tr><td><code id="permcoefs.plsRglm.raw_+3A_ifbootfail">ifbootfail</code></td>
<td>
<p>value to return if the estimation fails on a bootstrap
sample</p>
</td></tr>
<tr><td><code id="permcoefs.plsRglm.raw_+3A_verbose">verbose</code></td>
<td>
<p>should info messages be displayed ?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>estimates on a bootstrap sample or <code>ifbootfail</code> value if the
bootstrap computation fails.
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+bootplsglm">bootplsglm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Cornell)

# (Y,X) bootstrap of a PLSGLR model
set.seed(250)
modplsglm &lt;- permcoefs.plsRglm.raw(Cornell[,-8],1:nrow(Cornell),nt=3,
modele="pls-glm-family",family=gaussian,maxcoefvalues=1e5,
ifbootfail=rep(0,3),verbose=FALSE)

</code></pre>

<hr>
<h2 id='permcoefs.plsRglmnp'>Coefficients for permutation bootstrap computations of PLSGLR models</h2><span id='topic+permcoefs.plsRglmnp'></span>

<h3>Description</h3>

<p>A function passed to <code>boot</code> to perform bootstrap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permcoefs.plsRglmnp(
  dataRepYtt,
  ind,
  nt,
  modele,
  family = NULL,
  maxcoefvalues,
  wwetoile,
  ifbootfail
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permcoefs.plsRglmnp_+3A_datarepytt">dataRepYtt</code></td>
<td>
<p>components' coordinates to bootstrap</p>
</td></tr>
<tr><td><code id="permcoefs.plsRglmnp_+3A_ind">ind</code></td>
<td>
<p>indices for resampling</p>
</td></tr>
<tr><td><code id="permcoefs.plsRglmnp_+3A_nt">nt</code></td>
<td>
<p>number of components to use</p>
</td></tr>
<tr><td><code id="permcoefs.plsRglmnp_+3A_modele">modele</code></td>
<td>
<p>type of modele to use, see <a href="#topic+plsRglm">plsRglm</a></p>
</td></tr>
<tr><td><code id="permcoefs.plsRglmnp_+3A_family">family</code></td>
<td>
<p>glm family to use, see <a href="#topic+plsRglm">plsRglm</a></p>
</td></tr>
<tr><td><code id="permcoefs.plsRglmnp_+3A_maxcoefvalues">maxcoefvalues</code></td>
<td>
<p>maximum values allowed for the estimates of the
coefficients to discard those coming from singular bootstrap samples</p>
</td></tr>
<tr><td><code id="permcoefs.plsRglmnp_+3A_wwetoile">wwetoile</code></td>
<td>
<p>values of the Wstar matrix in the original fit</p>
</td></tr>
<tr><td><code id="permcoefs.plsRglmnp_+3A_ifbootfail">ifbootfail</code></td>
<td>
<p>value to return if the estimation fails on a bootstrap
sample</p>
</td></tr>
</table>


<h3>Value</h3>

<p>estimates on a bootstrap sample or <code>ifbootfail</code> value if the
bootstrap computation fails.
</p>


<h3>Note</h3>

<p>~~some notes~~
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+bootplsglm">bootplsglm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Cornell)

# (Y,X) bootstrap of a PLSGLR model
# statistic=coefs.plsRglm is the default for (Y,X) bootstrap of a PLSGLR models.
set.seed(250)
modplsglm &lt;- plsRglm(Y~.,data=Cornell,1,modele="pls-glm-family",family=gaussian)
Cornell.bootYT &lt;- bootplsglm(modplsglm, R=250, statistic=permcoefs.plsRglmnp, verbose=FALSE)

</code></pre>

<hr>
<h2 id='permcoefs.plsRnp'>Coefficients computation for permutation bootstrap</h2><span id='topic+permcoefs.plsRnp'></span>

<h3>Description</h3>

<p>A function passed to <code>boot</code> to perform bootstrap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permcoefs.plsRnp(
  dataRepYtt,
  ind,
  nt,
  modele,
  maxcoefvalues,
  wwetoile,
  ifbootfail
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permcoefs.plsRnp_+3A_datarepytt">dataRepYtt</code></td>
<td>
<p>components' coordinates to bootstrap</p>
</td></tr>
<tr><td><code id="permcoefs.plsRnp_+3A_ind">ind</code></td>
<td>
<p>indices for resampling</p>
</td></tr>
<tr><td><code id="permcoefs.plsRnp_+3A_nt">nt</code></td>
<td>
<p>number of components to use</p>
</td></tr>
<tr><td><code id="permcoefs.plsRnp_+3A_modele">modele</code></td>
<td>
<p>type of modele to use, see <a href="#topic+plsRglm">plsRglm</a></p>
</td></tr>
<tr><td><code id="permcoefs.plsRnp_+3A_maxcoefvalues">maxcoefvalues</code></td>
<td>
<p>maximum values allowed for the estimates of the
coefficients to discard those coming from singular bootstrap samples</p>
</td></tr>
<tr><td><code id="permcoefs.plsRnp_+3A_wwetoile">wwetoile</code></td>
<td>
<p>values of the Wstar matrix in the original fit</p>
</td></tr>
<tr><td><code id="permcoefs.plsRnp_+3A_ifbootfail">ifbootfail</code></td>
<td>
<p>value to return if the estimation fails on a bootstrap
sample</p>
</td></tr>
</table>


<h3>Value</h3>

<p>estimates on a bootstrap sample or <code>ifbootfail</code> value if the
bootstrap computation fails.
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+bootpls">bootpls</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Cornell)
XCornell&lt;-Cornell[,1:7]
yCornell&lt;-Cornell[,8]

# Lazraq-Cleroux PLS (Y,X) bootstrap
# statistic=coefs.plsR is the default for (Y,X) resampling of PLSR models.
set.seed(250)
modpls &lt;- plsR(yCornell,XCornell,1)
Cornell.bootYT &lt;- bootpls(modpls, R=250, typeboot="fmodel_np", sim="permutation",
statistic=permcoefs.plsRnp, verbose=FALSE)

</code></pre>

<hr>
<h2 id='pine'>Pine dataset</h2><span id='topic+pine'></span>

<h3>Description</h3>

<p>The caterpillar dataset was extracted from a 1973 study on pine
processionary caterpillars. It assesses the influence of some forest
settlement characteristics on the development of caterpillar colonies. The
response variable is the logarithmic transform of the average number of
nests of caterpillars per tree in an area of 500 square meters (<code>x11</code>).
There are k=10 potentially explanatory variables defined on n=33 areas.
</p>


<h3>Format</h3>

<p>A data frame with 33 observations on the following 11 variables.
</p>
 <dl>
<dt>x1</dt><dd><p>altitude (in meters)</p>
</dd> <dt>x2</dt><dd><p>slope
(en degrees)</p>
</dd> <dt>x3</dt><dd><p>number of pines in the area</p>
</dd>
<dt>x4</dt><dd><p>height (in meters) of the tree sampled at the center of
the area</p>
</dd> <dt>x5</dt><dd><p>diameter (in meters) of the tree sampled at the
center of the area</p>
</dd> <dt>x6</dt><dd><p>index of the settlement density</p>
</dd>
<dt>x7</dt><dd><p>orientation of the area (from 1 if southbound to 2
otherwise)</p>
</dd> <dt>x8</dt><dd><p>height (in meters) of the dominant tree</p>
</dd>
<dt>x9</dt><dd><p>number of vegetation strata</p>
</dd> <dt>x10</dt><dd><p>mix
settlement index (from 1 if not mixed to 2 if mixed)</p>
</dd>
<dt>x11</dt><dd><p>logarithmic transform of the average number of nests of
caterpillars per tree</p>
</dd> </dl>



<h3>Details</h3>

<p>These caterpillars got their names from their habit of moving over the
ground in incredibly long head-to-tail processions when leaving their nest
to create a new colony.<br />
</p>
<p>The <code>pine_sup</code> dataset can be used as a test set to assess model
prediction error of a model trained on the <code>pine</code> dataset.
</p>


<h3>Source</h3>

<p>Tomassone R., Audrain S., Lesquoy-de Turckeim E., Millier C. (1992),
&ldquo;La régression, nouveaux regards sur une ancienne
méthode statistique&rdquo;, INRA,
<em>Actualités Scientifiques et Agronomiques</em>, Masson,
Paris.
</p>


<h3>References</h3>

<p>J.-M. Marin, C. Robert. (2007). <em>Bayesian Core: A Practical
Approach to Computational Bayesian Statistics</em>. Springer, New-York, pages
48-49.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(pine)
str(pine)

</code></pre>

<hr>
<h2 id='pine_full'>Complete Pine dataset</h2><span id='topic+pine_full'></span>

<h3>Description</h3>

<p>This is the complete caterpillar dataset from a 1973 study on pine_full
processionary caterpillars. It assesses the influence of some forest
settlement characteristics on the development of caterpillar colonies. The
response variable is the logarithmic transform of the average number of
nests of caterpillars per tree in an area of 500 square meters (<code>x11</code>).
There are k=10 potentially explanatory variables defined on n=55 areas.
</p>


<h3>Format</h3>

<p>A data frame with 55 observations on the following 11 variables.
</p>
 <dl>
<dt>x1</dt><dd><p>altitude (in meters)</p>
</dd> <dt>x2</dt><dd><p>slope
(en degrees)</p>
</dd> <dt>x3</dt><dd><p>number of pine_fulls in the area</p>
</dd>
<dt>x4</dt><dd><p>height (in meters) of the tree sampled at the center of
the area</p>
</dd> <dt>x5</dt><dd><p>diameter (in meters) of the tree sampled at the
center of the area</p>
</dd> <dt>x6</dt><dd><p>index of the settlement density</p>
</dd>
<dt>x7</dt><dd><p>orientation of the area (from 1 if southbound to 2
otherwise)</p>
</dd> <dt>x8</dt><dd><p>height (in meters) of the dominant tree</p>
</dd>
<dt>x9</dt><dd><p>number of vegetation strata</p>
</dd> <dt>x10</dt><dd><p>mix
settlement index (from 1 if not mixed to 2 if mixed)</p>
</dd>
<dt>x11</dt><dd><p>logarithmic transform of the average number of nests of
caterpillars per tree</p>
</dd> </dl>



<h3>Details</h3>

<p>These caterpillars got their names from their habit of moving over the
ground in incredibly long head-to-tail processions when leaving their nest
to create a new colony.
</p>


<h3>Source</h3>

<p>Tomassone R., Audrain S., Lesquoy-de Turckeim E., Millier C. (1992),
&ldquo;La régression, nouveaux regards sur une ancienne
méthode statistique&rdquo;, INRA,
<em>Actualités Scientifiques et Agronomiques</em>, Masson,
Paris.
</p>


<h3>References</h3>

<p>J.-M. Marin, C. Robert. (2007). <em>Bayesian Core: A Practical
Approach to Computational Bayesian Statistics</em>. Springer, New-York, pages
48-49.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(pine_full)
str(pine_full)

</code></pre>

<hr>
<h2 id='pine_sup'>Complete Pine dataset</h2><span id='topic+pine_sup'></span>

<h3>Description</h3>

<p>This is a supplementary dataset (used as a test set for the <code>pine</code>
dataset) that was extracted from a 1973 study on pine_sup processionary
caterpillars. It assesses the influence of some forest settlement
characteristics on the development of caterpillar colonies. The response
variable is the logarithmic transform of the average number of nests of
caterpillars per tree in an area of 500 square meters (<code>x11</code>). There
are k=10 potentially explanatory variables defined on n=22 areas.
</p>


<h3>Format</h3>

<p>A data frame with 22 observations on the following 11 variables.
</p>
 <dl>
<dt>x1</dt><dd><p>altitude (in meters)</p>
</dd> <dt>x2</dt><dd><p>slope
(en degrees)</p>
</dd> <dt>x3</dt><dd><p>number of pine_sups in the area</p>
</dd>
<dt>x4</dt><dd><p>height (in meters) of the tree sampled at the center of
the area</p>
</dd> <dt>x5</dt><dd><p>diameter (in meters) of the tree sampled at the
center of the area</p>
</dd> <dt>x6</dt><dd><p>index of the settlement density</p>
</dd>
<dt>x7</dt><dd><p>orientation of the area (from 1 if southbound to 2
otherwise)</p>
</dd> <dt>x8</dt><dd><p>height (in meters) of the dominant tree</p>
</dd>
<dt>x9</dt><dd><p>number of vegetation strata</p>
</dd> <dt>x10</dt><dd><p>mix
settlement index (from 1 if not mixed to 2 if mixed)</p>
</dd>
<dt>x11</dt><dd><p>logarithmic transform of the average number of nests of
caterpillars per tree</p>
</dd> </dl>



<h3>Details</h3>

<p>These caterpillars got their names from their habit of moving over the
ground in incredibly long head-to-tail processions when leaving their nest
to create a new colony.<br />
</p>
<p>The <code>pine_sup</code> dataset can be used as a test set to assess model
prediction error of a model trained on the <code>pine</code> dataset.
</p>


<h3>Source</h3>

<p>Tomassone R., Audrain S., Lesquoy-de Turckeim E., Millier C. (1992),
&ldquo;La régression, nouveaux regards sur une ancienne
méthode statistique&rdquo;, INRA,
<em>Actualités Scientifiques et Agronomiques</em>, Masson,
Paris.
</p>


<h3>References</h3>

<p>J.-M. Marin, C. Robert. (2007). <em>Bayesian Core: A Practical
Approach to Computational Bayesian Statistics</em>. Springer, New-York, pages
48-49.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(pine_sup)
str(pine_sup)

</code></pre>

<hr>
<h2 id='pineNAX21'>Incomplete dataset from the pine caterpillars example</h2><span id='topic+pineNAX21'></span>

<h3>Description</h3>

<p>The caterpillar dataset was extracted from a 1973 study on pine
processionary caterpillars. It assesses the influence of some forest
settlement characteristics on the development of caterpillar colonies. There
are k=10 potentially explanatory variables defined on n=33 areas.<br /> The
value of x2 for the first observation was removed from the matrix of
predictors on purpose.
</p>


<h3>Format</h3>

<p>A data frame with 33 observations on the following 11 variables and
one missing value.  </p>
 <dl>
<dt>x1</dt><dd><p>altitude (in meters)</p>
</dd>
<dt>x2</dt><dd><p>slope (en degrees)</p>
</dd> <dt>x3</dt><dd><p>number of pines in
the area</p>
</dd> <dt>x4</dt><dd><p>height (in meters) of the tree sampled at the
center of the area</p>
</dd> <dt>x5</dt><dd><p>diameter (in meters) of the tree
sampled at the center of the area</p>
</dd> <dt>x6</dt><dd><p>index of the settlement
density</p>
</dd> <dt>x7</dt><dd><p>orientation of the area (from 1 if southbound to
2 otherwise)</p>
</dd> <dt>x8</dt><dd><p>height (in meters) of the dominant tree</p>
</dd>
<dt>x9</dt><dd><p>number of vegetation strata</p>
</dd> <dt>x10</dt><dd><p>mix
settlement index (from 1 if not mixed to 2 if mixed)</p>
</dd>
<dt>x11</dt><dd><p>logarithmic transform of the average number of nests of
caterpillars per tree</p>
</dd> </dl>



<h3>Details</h3>

<p>These caterpillars got their names from their habit of moving over the
ground in incredibly long head-to-tail processions when leaving their nest
to create a new colony.<br /> The <code>pineNAX21</code> is a dataset with a missing
value for testing purpose.
</p>


<h3>Source</h3>

<p>Tomassone R., Audrain S., Lesquoy-de Turckeim E., Millier C. (1992).
&ldquo;La régression, nouveaux regards sur une ancienne
méthode statistique&rdquo;, INRA,
<em>Actualités Scientifiques et Agronomiques</em>, Masson,
Paris.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(pineNAX21)
str(pineNAX21)

</code></pre>

<hr>
<h2 id='plot.table.summary.cv.plsRglmmodel'>Plot method for table of summary of cross validated plsRglm models</h2><span id='topic+plot.table.summary.cv.plsRglmmodel'></span>

<h3>Description</h3>

<p>This function provides a table method for the class
<code>"summary.cv.plsRglmmodel"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'table.summary.cv.plsRglmmodel'
plot(x, type = c("CVMC", "CVQ2Chi2", "CVPreChi2"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.table.summary.cv.plsRglmmodel_+3A_x">x</code></td>
<td>
<p>an object of the class <code>"table.summary.cv.plsRglmmodel"</code></p>
</td></tr>
<tr><td><code id="plot.table.summary.cv.plsRglmmodel_+3A_type">type</code></td>
<td>
<p>the type of cross validation criterion to plot.</p>
</td></tr>
<tr><td><code id="plot.table.summary.cv.plsRglmmodel_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>References</h3>

<p>Nicolas Meyer, Myriam Maumy-Bertrand et
Frédéric Bertrand (2010). Comparing the linear and the
logistic PLS regression with qualitative predictors: application to
allelotyping data. <em>Journal de la Societe Francaise de Statistique</em>,
151(2), pages 1-18.
<a href="http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47">http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Cornell)
bbb &lt;- cv.plsRglm(Y~.,data=Cornell,nt=10,NK=1,
modele="pls-glm-family",family=gaussian(), verbose=FALSE)
plot(cvtable(summary(bbb,verbose=FALSE)),type="CVQ2Chi2")
rm(list=c("bbb"))


data(Cornell)
plot(cvtable(summary(cv.plsRglm(Y~.,data=Cornell,nt=10,NK=100,
modele="pls-glm-family",family=gaussian(), verbose=FALSE),
verbose=FALSE)),type="CVQ2Chi2")


</code></pre>

<hr>
<h2 id='plot.table.summary.cv.plsRmodel'>Plot method for table of summary of cross validated plsR models</h2><span id='topic+plot.table.summary.cv.plsRmodel'></span>

<h3>Description</h3>

<p>This function provides a table method for the class
<code>"summary.cv.plsRmodel"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'table.summary.cv.plsRmodel'
plot(x, type = c("CVMC", "CVQ2", "CVPress"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.table.summary.cv.plsRmodel_+3A_x">x</code></td>
<td>
<p>an object of the class <code>"table.summary.cv.plsRmodel"</code></p>
</td></tr>
<tr><td><code id="plot.table.summary.cv.plsRmodel_+3A_type">type</code></td>
<td>
<p>the type of cross validation criterion to plot.</p>
</td></tr>
<tr><td><code id="plot.table.summary.cv.plsRmodel_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>References</h3>

<p>Nicolas Meyer, Myriam Maumy-Bertrand et
Frédéric Bertrand (2010). Comparing the linear and the
logistic PLS regression with qualitative predictors: application to
allelotyping data. <em>Journal de la Societe Francaise de Statistique</em>,
151(2), pages 1-18.
<a href="http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47">http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Cornell)
bbb &lt;- cv.plsR(Y~.,data=Cornell,nt=6,K=6,NK=5, verbose=FALSE)
plot(cvtable(summary(bbb)),type="CVQ2")
rm(list=c("bbb"))


data(Cornell)
plot(cvtable(summary(cv.plsR(Y~.,data=Cornell,nt=6,K=6,NK=100, verbose=FALSE))),type="CVQ2")


</code></pre>

<hr>
<h2 id='plots.confints.bootpls'>Plot bootstrap confidence intervals</h2><span id='topic+plots.confints.bootpls'></span>

<h3>Description</h3>

<p>This function plots the confidence intervals derived using the function
<code>confints.bootpls</code> from from a <code>bootpls</code> based object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plots.confints.bootpls(
  ic_bootobject,
  indices = NULL,
  legendpos = "topleft",
  prednames = TRUE,
  articlestyle = TRUE,
  xaxisticks = TRUE,
  ltyIC = c(2, 4, 5, 1),
  colIC = c("darkgreen", "blue", "red", "black"),
  typeIC,
  las = par("las"),
  mar,
  mgp,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plots.confints.bootpls_+3A_ic_bootobject">ic_bootobject</code></td>
<td>
<p>an object created with the <code>confints.bootpls</code>
function.</p>
</td></tr>
<tr><td><code id="plots.confints.bootpls_+3A_indices">indices</code></td>
<td>
<p>vector of indices of the variables to plot. Defaults to
<code>NULL</code>: all the predictors will be used.</p>
</td></tr>
<tr><td><code id="plots.confints.bootpls_+3A_legendpos">legendpos</code></td>
<td>
<p>position of the legend as in
<code><a href="graphics.html#topic+legend">legend</a></code>, defaults to <code>"topleft"</code></p>
</td></tr>
<tr><td><code id="plots.confints.bootpls_+3A_prednames">prednames</code></td>
<td>
<p>do the original names of the predictors shall be plotted ?
Defaults to <code>TRUE</code>: the names are plotted.</p>
</td></tr>
<tr><td><code id="plots.confints.bootpls_+3A_articlestyle">articlestyle</code></td>
<td>
<p>do the extra blank zones of the margin shall be removed
from the plot ? Defaults to <code>TRUE</code>: the margins are removed.</p>
</td></tr>
<tr><td><code id="plots.confints.bootpls_+3A_xaxisticks">xaxisticks</code></td>
<td>
<p>do ticks for the x axis shall be plotted ? Defaults to
<code>TRUE</code>: the ticks are plotted.</p>
</td></tr>
<tr><td><code id="plots.confints.bootpls_+3A_ltyic">ltyIC</code></td>
<td>
<p>lty as in <code><a href="graphics.html#topic+plot">plot</a></code></p>
</td></tr>
<tr><td><code id="plots.confints.bootpls_+3A_colic">colIC</code></td>
<td>
<p>col as in <code><a href="graphics.html#topic+plot">plot</a></code></p>
</td></tr>
<tr><td><code id="plots.confints.bootpls_+3A_typeic">typeIC</code></td>
<td>
<p>type of CI to plot. Defaults to <code>typeIC=c("Normal",
"Basic", "Percentile", "BCa")</code> if BCa intervals limits were computed and to
<code>typeIC=c("Normal", "Basic", "Percentile")</code> otherwise.</p>
</td></tr>
<tr><td><code id="plots.confints.bootpls_+3A_las">las</code></td>
<td>
<p>numeric in 0,1,2,3; the style of axis labels. 0: always parallel
to the axis [default], 1: always horizontal, 2: always perpendicular to the
axis, 3: always vertical.</p>
</td></tr>
<tr><td><code id="plots.confints.bootpls_+3A_mar">mar</code></td>
<td>
<p>A numerical vector of the form <code>c(bottom, left, top, right)</code>
which gives the number of lines of margin to be specified on the four sides
of the plot. The default is <code>c(5, 4, 4, 2) + 0.1.</code></p>
</td></tr>
<tr><td><code id="plots.confints.bootpls_+3A_mgp">mgp</code></td>
<td>
<p>The margin line (in mex units) for the axis title, axis labels
and axis line. Note that <code>mgp[1]</code> affects title whereas <code>mgp[2:3]</code>
affect axis. The default is <code>c(3, 1, 0)</code>.</p>
</td></tr>
<tr><td><code id="plots.confints.bootpls_+3A_...">...</code></td>
<td>
<p>further options to pass to the
<code><a href="graphics.html#topic+plot">plot</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+confints.bootpls">confints.bootpls</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Cornell)
modpls &lt;- plsR(Y~.,data=Cornell,3)

# Lazraq-Cleroux PLS (Y,X) bootstrap
set.seed(250)
Cornell.bootYX &lt;- bootpls(modpls, R=250, verbose=FALSE)
temp.ci &lt;- confints.bootpls(Cornell.bootYX,2:8)

plots.confints.bootpls(temp.ci)
plots.confints.bootpls(temp.ci,prednames=FALSE)
plots.confints.bootpls(temp.ci,prednames=FALSE,articlestyle=FALSE,
main="Bootstrap confidence intervals for the bj")
plots.confints.bootpls(temp.ci,indices=1:3,prednames=FALSE)
plots.confints.bootpls(temp.ci,c(2,4,6),"bottomright")
plots.confints.bootpls(temp.ci,c(2,4,6),articlestyle=FALSE,
main="Bootstrap confidence intervals for some of the bj")

temp.ci &lt;- confints.bootpls(Cornell.bootYX,typeBCa=FALSE)
plots.confints.bootpls(temp.ci)
plots.confints.bootpls(temp.ci,2:8)
plots.confints.bootpls(temp.ci,prednames=FALSE)


# Bastien CSDA 2005 (Y,T) bootstrap
Cornell.boot &lt;- bootpls(modpls, typeboot="fmodel_np", R=250, verbose=FALSE)
temp.ci &lt;- confints.bootpls(Cornell.boot,2:8)

plots.confints.bootpls(temp.ci)
plots.confints.bootpls(temp.ci,prednames=FALSE)
plots.confints.bootpls(temp.ci,prednames=FALSE,articlestyle=FALSE,
main="Bootstrap confidence intervals for the bj")
plots.confints.bootpls(temp.ci,indices=1:3,prednames=FALSE)
plots.confints.bootpls(temp.ci,c(2,4,6),"bottomright")
plots.confints.bootpls(temp.ci,c(2,4,6),articlestyle=FALSE,
main="Bootstrap confidence intervals for some of the bj")

temp.ci &lt;- confints.bootpls(Cornell.boot,typeBCa=FALSE)
plots.confints.bootpls(temp.ci)
plots.confints.bootpls(temp.ci,2:8)
plots.confints.bootpls(temp.ci,prednames=FALSE)



data(aze_compl)
modplsglm &lt;- plsRglm(y~.,data=aze_compl,3,modele="pls-glm-logistic")

# Lazraq-Cleroux PLS (Y,X) bootstrap
# should be run with R=1000 but takes much longer time
aze_compl.bootYX3 &lt;- bootplsglm(modplsglm, typeboot="plsmodel", R=250, verbose=FALSE)
temp.ci &lt;- confints.bootpls(aze_compl.bootYX3)

plots.confints.bootpls(temp.ci)
plots.confints.bootpls(temp.ci,prednames=FALSE)
plots.confints.bootpls(temp.ci,prednames=FALSE,articlestyle=FALSE,
main="Bootstrap confidence intervals for the bj")
plots.confints.bootpls(temp.ci,indices=1:33,prednames=FALSE)
plots.confints.bootpls(temp.ci,c(2,4,6),"bottomleft")
plots.confints.bootpls(temp.ci,c(2,4,6),articlestyle=FALSE,
main="Bootstrap confidence intervals for some of the bj")
plots.confints.bootpls(temp.ci,indices=1:34,prednames=FALSE)
plots.confints.bootpls(temp.ci,indices=1:33,prednames=FALSE,ltyIC=1,colIC=c(1,2))
 
temp.ci &lt;- confints.bootpls(aze_compl.bootYX3,1:34,typeBCa=FALSE)
plots.confints.bootpls(temp.ci,indices=1:33,prednames=FALSE)


# Bastien CSDA 2005 (Y,T) Bootstrap
# much faster
aze_compl.bootYT3 &lt;- bootplsglm(modplsglm, R=1000, verbose=FALSE)
temp.ci &lt;- confints.bootpls(aze_compl.bootYT3)

plots.confints.bootpls(temp.ci)
plots.confints.bootpls(temp.ci,typeIC="Normal")
plots.confints.bootpls(temp.ci,typeIC=c("Normal","Basic"))
plots.confints.bootpls(temp.ci,typeIC="BCa",legendpos="bottomleft")
plots.confints.bootpls(temp.ci,prednames=FALSE)
plots.confints.bootpls(temp.ci,prednames=FALSE,articlestyle=FALSE,
main="Bootstrap confidence intervals for the bj")
plots.confints.bootpls(temp.ci,indices=1:33,prednames=FALSE)
plots.confints.bootpls(temp.ci,c(2,4,6),"bottomleft")
plots.confints.bootpls(temp.ci,c(2,4,6),articlestyle=FALSE,
main="Bootstrap confidence intervals for some of the bj")
plots.confints.bootpls(temp.ci,prednames=FALSE,ltyIC=c(2,1),colIC=c(1,2))
 
temp.ci &lt;- confints.bootpls(aze_compl.bootYT3,1:33,typeBCa=FALSE)
plots.confints.bootpls(temp.ci,prednames=FALSE)


</code></pre>

<hr>
<h2 id='PLS_glm_wvc'>Light version of PLS_glm for cross validation purposes</h2><span id='topic+PLS_glm_wvc'></span>

<h3>Description</h3>

<p>Light version of <code>PLS_glm</code> for cross validation purposes either on
complete or incomplete datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PLS_glm_wvc(
  dataY,
  dataX,
  nt = 2,
  dataPredictY = dataX,
  modele = "pls",
  family = NULL,
  scaleX = TRUE,
  scaleY = NULL,
  keepcoeffs = FALSE,
  keepstd.coeffs = FALSE,
  tol_Xi = 10^(-12),
  weights,
  method = "logistic",
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PLS_glm_wvc_+3A_datay">dataY</code></td>
<td>
<p>response (training) dataset</p>
</td></tr>
<tr><td><code id="PLS_glm_wvc_+3A_datax">dataX</code></td>
<td>
<p>predictor(s) (training) dataset</p>
</td></tr>
<tr><td><code id="PLS_glm_wvc_+3A_nt">nt</code></td>
<td>
<p>number of components to be extracted</p>
</td></tr>
<tr><td><code id="PLS_glm_wvc_+3A_datapredicty">dataPredictY</code></td>
<td>
<p>predictor(s) (testing) dataset</p>
</td></tr>
<tr><td><code id="PLS_glm_wvc_+3A_modele">modele</code></td>
<td>
<p>name of the PLS glm model to be fitted (<code>"pls"</code>,
<code>"pls-glm-Gamma"</code>, <code>"pls-glm-gaussian"</code>,
<code>"pls-glm-inverse.gaussian"</code>, <code>"pls-glm-logistic"</code>,
<code>"pls-glm-poisson"</code>, <code>"pls-glm-polr"</code>). Use
<code>"modele=pls-glm-family"</code> to enable the <code>family</code> option.</p>
</td></tr>
<tr><td><code id="PLS_glm_wvc_+3A_family">family</code></td>
<td>
<p>a description of the error distribution and link function to
be used in the model. This can be a character string naming a family
function, a family function or the result of a call to a family function.
(See <code><a href="stats.html#topic+family">family</a></code> for details of family functions.) To use
the family option, please set <code>modele="pls-glm-family"</code>. User defined
families can also be defined. See details.</p>
</td></tr>
<tr><td><code id="PLS_glm_wvc_+3A_scalex">scaleX</code></td>
<td>
<p>scale the predictor(s) : must be set to TRUE for
<code>modele="pls"</code> and should be for glms pls.</p>
</td></tr>
<tr><td><code id="PLS_glm_wvc_+3A_scaley">scaleY</code></td>
<td>
<p>scale the response : Yes/No. Ignored since non always possible
for glm responses.</p>
</td></tr>
<tr><td><code id="PLS_glm_wvc_+3A_keepcoeffs">keepcoeffs</code></td>
<td>
<p>whether the coefficients of the linear fit on link scale
of unstandardized eXplanatory variables should be returned or not.</p>
</td></tr>
<tr><td><code id="PLS_glm_wvc_+3A_keepstd.coeffs">keepstd.coeffs</code></td>
<td>
<p>whether the coefficients of the linear fit on link
scale of standardized eXplanatory variables should be returned or not.</p>
</td></tr>
<tr><td><code id="PLS_glm_wvc_+3A_tol_xi">tol_Xi</code></td>
<td>
<p>minimal value for Norm2(Xi) and <code class="reqn">\mathrm{det}(pp' \times
pp)</code> if there is any missing value in the <code>dataX</code>. It
defaults to <code class="reqn">10^{-12}</code></p>
</td></tr>
<tr><td><code id="PLS_glm_wvc_+3A_weights">weights</code></td>
<td>
<p>an optional vector of 'prior weights' to be used in the
fitting process. Should be <code>NULL</code> or a numeric vector.</p>
</td></tr>
<tr><td><code id="PLS_glm_wvc_+3A_method">method</code></td>
<td>
<p>logistic, probit, complementary log-log or cauchit
(corresponding to a Cauchy latent variable).</p>
</td></tr>
<tr><td><code id="PLS_glm_wvc_+3A_verbose">verbose</code></td>
<td>
<p>should info messages be displayed ?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is called by <code><a href="#topic+PLS_glm_kfoldcv_formula">PLS_glm_kfoldcv_formula</a></code> in order to
perform cross-validation either on complete or incomplete datasets.
</p>
<p>There are seven different predefined models with predefined link functions
available : </p>
 <dl>
<dt>list(&quot;\&quot;pls\&quot;&quot;)</dt><dd><p>ordinary pls models</p>
</dd>
<dt>list(&quot;\&quot;pls-glm-Gamma\&quot;&quot;)</dt><dd><p>glm gaussian with inverse link pls models</p>
</dd>
<dt>list(&quot;\&quot;pls-glm-gaussian\&quot;&quot;)</dt><dd><p>glm gaussian with identity link pls
models</p>
</dd> <dt>list(&quot;\&quot;pls-glm-inverse-gamma\&quot;&quot;)</dt><dd><p>glm binomial with square
inverse link pls models</p>
</dd> <dt>list(&quot;\&quot;pls-glm-logistic\&quot;&quot;)</dt><dd><p>glm binomial
with logit link pls models</p>
</dd> <dt>list(&quot;\&quot;pls-glm-poisson\&quot;&quot;)</dt><dd><p>glm poisson
with log link pls models</p>
</dd> <dt>list(&quot;\&quot;pls-glm-polr\&quot;&quot;)</dt><dd><p>glm polr with
logit link pls models</p>
</dd> </dl>
<p> Using the <code>"family="</code> option and setting
<code>"modele=pls-glm-family"</code> allows changing the family and link function
the same way as for the <code><a href="stats.html#topic+glm">glm</a></code> function. As a consequence
user-specified families can also be used.  </p>
 <dl>
<dt>The </dt><dd><p>accepts
the links (as names) <code>identity</code>, <code>log</code> and
<code>inverse</code>.</p>
</dd><dt>list(&quot;gaussian&quot;)</dt><dd><p>accepts the links (as names)
<code>identity</code>, <code>log</code> and <code>inverse</code>.</p>
</dd><dt> family</dt><dd><p>accepts the
links (as names) <code>identity</code>, <code>log</code> and <code>inverse</code>.</p>
</dd> <dt>The
</dt><dd><p>accepts the links <code>logit</code>, <code>probit</code>, <code>cauchit</code>,
(corresponding to logistic, normal and Cauchy CDFs respectively) <code>log</code>
and <code>cloglog</code> (complementary log-log).</p>
</dd><dt>list(&quot;binomial&quot;)</dt><dd><p>accepts
the links <code>logit</code>, <code>probit</code>, <code>cauchit</code>, (corresponding to
logistic, normal and Cauchy CDFs respectively) <code>log</code> and <code>cloglog</code>
(complementary log-log).</p>
</dd><dt> family</dt><dd><p>accepts the links <code>logit</code>,
<code>probit</code>, <code>cauchit</code>, (corresponding to logistic, normal and Cauchy
CDFs respectively) <code>log</code> and <code>cloglog</code> (complementary log-log).</p>
</dd>
<dt>The </dt><dd><p>accepts the links <code>inverse</code>, <code>identity</code> and
<code>log</code>.</p>
</dd><dt>list(&quot;Gamma&quot;)</dt><dd><p>accepts the links <code>inverse</code>,
<code>identity</code> and <code>log</code>.</p>
</dd><dt> family</dt><dd><p>accepts the links
<code>inverse</code>, <code>identity</code> and <code>log</code>.</p>
</dd> <dt>The </dt><dd><p>accepts the
links <code>log</code>, <code>identity</code>, and
<code>sqrt</code>.</p>
</dd><dt>list(&quot;poisson&quot;)</dt><dd><p>accepts the links <code>log</code>,
<code>identity</code>, and <code>sqrt</code>.</p>
</dd><dt> family</dt><dd><p>accepts the links
<code>log</code>, <code>identity</code>, and <code>sqrt</code>.</p>
</dd> <dt>The </dt><dd><p>accepts the links
<code>1/mu^2</code>, <code>inverse</code>, <code>identity</code> and
<code>log</code>.</p>
</dd><dt>list(&quot;inverse.gaussian&quot;)</dt><dd><p>accepts the links <code>1/mu^2</code>,
<code>inverse</code>, <code>identity</code> and <code>log</code>.</p>
</dd><dt> family</dt><dd><p>accepts the
links <code>1/mu^2</code>, <code>inverse</code>, <code>identity</code> and <code>log</code>.</p>
</dd>
<dt>The </dt><dd><p>accepts the links <code>logit</code>, <code>probit</code>, <code>cloglog</code>,
<code>identity</code>, <code>inverse</code>, <code>log</code>, <code>1/mu^2</code> and
<code>sqrt</code>.</p>
</dd><dt>list(&quot;quasi&quot;)</dt><dd><p>accepts the links <code>logit</code>,
<code>probit</code>, <code>cloglog</code>, <code>identity</code>, <code>inverse</code>, <code>log</code>,
<code>1/mu^2</code> and <code>sqrt</code>.</p>
</dd><dt> family</dt><dd><p>accepts the links
<code>logit</code>, <code>probit</code>, <code>cloglog</code>, <code>identity</code>,
<code>inverse</code>, <code>log</code>, <code>1/mu^2</code> and <code>sqrt</code>.</p>
</dd> <dt>The
function </dt><dd><p>can be used to create a power link
function.</p>
</dd><dt>list(&quot;power&quot;)</dt><dd><p>can be used to create a power link function.</p>
</dd>
</dl>

<p>Non-NULL weights can be used to indicate that different observations have
different dispersions (with the values in weights being inversely
proportional to the dispersions); or equivalently, when the elements of
weights are positive integers w_i, that each response y_i is the mean of w_i
unit-weight observations.
</p>


<h3>Value</h3>

<table>
<tr><td><code>valsPredict</code></td>
<td>
<p><code>nrow(dataPredictY) * nt</code> matrix of the
predicted values</p>
</td></tr> <tr><td><code>list("coeffs")</code></td>
<td>
<p> If the coefficients of the
eXplanatory variables were requested:<br /> i.e. <code>keepcoeffs=TRUE</code>.<br />
<code>ncol(dataX) * 1</code> matrix of the coefficients of the the eXplanatory
variables</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>References</h3>

<p>Nicolas Meyer, Myriam Maumy-Bertrand et
Frédéric Bertrand (2010). Comparing the linear and the
logistic PLS regression with qualitative predictors: application to
allelotyping data. <em>Journal de la Societe Francaise de Statistique</em>,
151(2), pages 1-18.
<a href="http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47">http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PLS_glm">PLS_glm</a></code> for more detailed results,
<code><a href="#topic+PLS_glm_kfoldcv">PLS_glm_kfoldcv</a></code> for cross-validating models and
<code><a href="#topic+PLS_lm_wvc">PLS_lm_wvc</a></code> for the same function dedicated to plsR models
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Cornell)
XCornell&lt;-Cornell[,1:7]
yCornell&lt;-Cornell[,8]
PLS_glm_wvc(dataY=yCornell,dataX=XCornell,nt=3,modele="pls-glm-gaussian",
dataPredictY=XCornell[1,])
PLS_glm_wvc(dataY=yCornell,dataX=XCornell,nt=3,modele="pls-glm-family",
family=gaussian(),dataPredictY=XCornell[1,], verbose=FALSE)
PLS_glm_wvc(dataY=yCornell[-1],dataX=XCornell[-1,],nt=3,modele="pls-glm-gaussian",
dataPredictY=XCornell[1,], verbose=FALSE)
PLS_glm_wvc(dataY=yCornell[-1],dataX=XCornell[-1,],nt=3,modele="pls-glm-family",
family=gaussian(),dataPredictY=XCornell[1,], verbose=FALSE)
rm("XCornell","yCornell")


## With an incomplete dataset (X[1,2] is NA)
data(pine)
ypine &lt;- pine[,11]
data(XpineNAX21)
PLS_glm_wvc(dataY=ypine,dataX=XpineNAX21,nt=10,modele="pls-glm-gaussian")
rm("XpineNAX21","ypine")

data(pine)
Xpine&lt;-pine[,1:10]
ypine&lt;-pine[,11]
PLS_glm_wvc(ypine,Xpine,10,modele="pls", verbose=FALSE)
PLS_glm_wvc(ypine,Xpine,10,modele="pls-glm-Gamma", verbose=FALSE)
PLS_glm_wvc(ypine,Xpine,10,modele="pls-glm-family",family=Gamma(), verbose=FALSE)
PLS_glm_wvc(ypine,Xpine,10,modele="pls-glm-gaussian", verbose=FALSE)
PLS_glm_wvc(ypine,Xpine,10,modele="pls-glm-family",family=gaussian(log), verbose=FALSE)
PLS_glm_wvc(round(ypine),Xpine,10,modele="pls-glm-poisson", verbose=FALSE)
PLS_glm_wvc(round(ypine),Xpine,10,modele="pls-glm-family",family=poisson(log), verbose=FALSE)
rm(list=c("pine","ypine","Xpine"))


data(Cornell)
XCornell&lt;-Cornell[,1:7]
yCornell&lt;-Cornell[,8]
PLS_glm_wvc(yCornell,XCornell,10,modele="pls-glm-inverse.gaussian", verbose=FALSE)
PLS_glm_wvc(yCornell,XCornell,10,modele="pls-glm-family",
family=inverse.gaussian(), verbose=FALSE)
rm(list=c("XCornell","yCornell"))


data(Cornell)
XCornell&lt;-Cornell[,1:7]
yCornell&lt;-Cornell[,8]
PLS_glm_wvc(dataY=yCornell,dataX=XCornell,nt=3,modele="pls-glm-gaussian",
dataPredictY=XCornell[1,], verbose=FALSE)
PLS_glm_wvc(dataY=yCornell[-1],dataX=XCornell[-1,],nt=3,modele="pls-glm-gaussian",
dataPredictY=XCornell[1,], verbose=FALSE)
rm("XCornell","yCornell")

data(aze_compl)
Xaze_compl&lt;-aze_compl[,2:34]
yaze_compl&lt;-aze_compl$y
PLS_glm(yaze_compl,Xaze_compl,10,modele="pls-glm-logistic",typeVC="none", verbose=FALSE)$InfCrit
PLS_glm_wvc(yaze_compl,Xaze_compl,10,modele="pls-glm-logistic", keepcoeffs=TRUE, verbose=FALSE)
rm("Xaze_compl","yaze_compl")


</code></pre>

<hr>
<h2 id='PLS_lm_wvc'>Light version of PLS_lm for cross validation purposes</h2><span id='topic+PLS_lm_wvc'></span>

<h3>Description</h3>

<p>Light version of <code>PLS_lm</code> for cross validation purposes either on
complete or incomplete datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PLS_lm_wvc(
  dataY,
  dataX,
  nt = 2,
  dataPredictY = dataX,
  modele = "pls",
  scaleX = TRUE,
  scaleY = NULL,
  keepcoeffs = FALSE,
  keepstd.coeffs = FALSE,
  tol_Xi = 10^(-12),
  weights,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PLS_lm_wvc_+3A_datay">dataY</code></td>
<td>
<p>response (training) dataset</p>
</td></tr>
<tr><td><code id="PLS_lm_wvc_+3A_datax">dataX</code></td>
<td>
<p>predictor(s) (training) dataset</p>
</td></tr>
<tr><td><code id="PLS_lm_wvc_+3A_nt">nt</code></td>
<td>
<p>number of components to be extracted</p>
</td></tr>
<tr><td><code id="PLS_lm_wvc_+3A_datapredicty">dataPredictY</code></td>
<td>
<p>predictor(s) (testing) dataset</p>
</td></tr>
<tr><td><code id="PLS_lm_wvc_+3A_modele">modele</code></td>
<td>
<p>name of the PLS model to be fitted, only (<code>"pls"</code>
available for this fonction.</p>
</td></tr>
<tr><td><code id="PLS_lm_wvc_+3A_scalex">scaleX</code></td>
<td>
<p>scale the predictor(s) : must be set to TRUE for
<code>modele="pls"</code> and should be for glms pls.</p>
</td></tr>
<tr><td><code id="PLS_lm_wvc_+3A_scaley">scaleY</code></td>
<td>
<p>scale the response : Yes/No. Ignored since non always possible
for glm responses.</p>
</td></tr>
<tr><td><code id="PLS_lm_wvc_+3A_keepcoeffs">keepcoeffs</code></td>
<td>
<p>whether the coefficients of unstandardized eXplanatory
variables should be returned or not.</p>
</td></tr>
<tr><td><code id="PLS_lm_wvc_+3A_keepstd.coeffs">keepstd.coeffs</code></td>
<td>
<p>whether the coefficients of standardized eXplanatory
variables should be returned or not.</p>
</td></tr>
<tr><td><code id="PLS_lm_wvc_+3A_tol_xi">tol_Xi</code></td>
<td>
<p>minimal value for Norm2(Xi) and <code class="reqn">\mathrm{det}(pp' \times
pp)</code> if there is any missing value in the <code>dataX</code>. It
defaults to <code class="reqn">10^{-12}</code></p>
</td></tr>
<tr><td><code id="PLS_lm_wvc_+3A_weights">weights</code></td>
<td>
<p>an optional vector of 'prior weights' to be used in the
fitting process. Should be <code>NULL</code> or a numeric vector.</p>
</td></tr>
<tr><td><code id="PLS_lm_wvc_+3A_verbose">verbose</code></td>
<td>
<p>should info messages be displayed ?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is called by <code><a href="#topic+PLS_lm_kfoldcv">PLS_lm_kfoldcv</a></code> in order to perform
cross-validation either on complete or incomplete datasets.
</p>
<p>Non-NULL weights can be used to indicate that different observations have
different dispersions (with the values in weights being inversely
proportional to the dispersions); or equivalently, when the elements of
weights are positive integers w_i, that each response y_i is the mean of w_i
unit-weight observations.
</p>


<h3>Value</h3>

<table>
<tr><td><code>valsPredict</code></td>
<td>
<p><code>nrow(dataPredictY) * nt</code> matrix of the
predicted values</p>
</td></tr> <tr><td><code>list("coeffs")</code></td>
<td>
<p> If the coefficients of the
eXplanatory variables were requested:<br /> i.e. <code>keepcoeffs=TRUE</code>.<br />
<code>ncol(dataX) * 1</code> matrix of the coefficients of the the eXplanatory
variables</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Use <code><a href="#topic+PLS_lm_kfoldcv">PLS_lm_kfoldcv</a></code> for a wrapper in view of
cross-validation.
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>References</h3>

<p>Nicolas Meyer, Myriam Maumy-Bertrand et
Frédéric Bertrand (2010). Comparing the linear and the
logistic PLS regression with qualitative predictors: application to
allelotyping data. <em>Journal de la Societe Francaise de Statistique</em>,
151(2), pages 1-18.
<a href="http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47">http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PLS_lm">PLS_lm</a></code> for more detailed results,
<code><a href="#topic+PLS_lm_kfoldcv">PLS_lm_kfoldcv</a></code> for cross-validating models and
<code><a href="#topic+PLS_glm_wvc">PLS_glm_wvc</a></code> for the same function dedicated to plsRglm models
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Cornell)
XCornell&lt;-Cornell[,1:7]
yCornell&lt;-Cornell[,8]
PLS_lm_wvc(dataY=yCornell,dataX=XCornell,nt=3,dataPredictY=XCornell[1,])
PLS_lm_wvc(dataY=yCornell[-c(1,2)],dataX=XCornell[-c(1,2),],nt=3,dataPredictY=XCornell[c(1,2),],
verbose=FALSE)
PLS_lm_wvc(dataY=yCornell[-c(1,2)],dataX=XCornell[-c(1,2),],nt=3,dataPredictY=XCornell[c(1,2),],
keepcoeffs=TRUE, verbose=FALSE)
rm("XCornell","yCornell")

## With an incomplete dataset (X[1,2] is NA)
data(pine)
ypine &lt;- pine[,11]
data(XpineNAX21)
PLS_lm_wvc(dataY=ypine[-1],dataX=XpineNAX21[-1,],nt=3, verbose=FALSE)
PLS_lm_wvc(dataY=ypine[-1],dataX=XpineNAX21[-1,],nt=3,dataPredictY=XpineNAX21[1,], verbose=FALSE)
PLS_lm_wvc(dataY=ypine[-2],dataX=XpineNAX21[-2,],nt=3,dataPredictY=XpineNAX21[2,], verbose=FALSE)
PLS_lm_wvc(dataY=ypine,dataX=XpineNAX21,nt=3, verbose=FALSE)
rm("ypine")

</code></pre>

<hr>
<h2 id='plsR'>Partial least squares Regression models with leave one out cross validation</h2><span id='topic+plsR'></span><span id='topic+plsRmodel.default'></span><span id='topic+plsRmodel.formula'></span><span id='topic+PLS_lm'></span><span id='topic+PLS_lm_formula'></span>

<h3>Description</h3>

<p>This function implements Partial least squares Regression models with leave one out cross validation for complete or incomplete datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plsR(object, ...)
## Default S3 method:
plsRmodel(object, dataX, nt = 2, limQ2set = 0.0975, 
dataPredictY = dataX, modele = "pls", family = NULL, typeVC = "none", 
EstimXNA = FALSE, scaleX = TRUE, scaleY = NULL, pvals.expli = FALSE, 
alpha.pvals.expli = 0.05, MClassed = FALSE, tol_Xi = 10^(-12), weights,
sparse = FALSE, sparseStop = TRUE, naive = FALSE,verbose=TRUE,...)
## S3 method for class 'formula'
plsRmodel(object, data, nt = 2, limQ2set = 0.0975,
dataPredictY, modele = "pls", family = NULL, typeVC = "none",
EstimXNA = FALSE, scaleX = TRUE, scaleY = NULL, pvals.expli = FALSE, 
alpha.pvals.expli = 0.05, MClassed = FALSE, tol_Xi = 10^(-12), weights,
subset, contrasts = NULL, sparse = FALSE, sparseStop = TRUE, naive = FALSE,
verbose=TRUE,...)
PLS_lm(dataY, dataX, nt = 2, limQ2set = 0.0975, dataPredictY = dataX, 
modele = "pls", family = NULL, typeVC = "none", EstimXNA = FALSE, 
scaleX = TRUE, scaleY = NULL, pvals.expli = FALSE, 
alpha.pvals.expli = 0.05, MClassed = FALSE, tol_Xi = 10^(-12),
weights,sparse=FALSE,sparseStop=FALSE,naive=FALSE,verbose=TRUE)
PLS_lm_formula(formula,data=NULL,nt=2,limQ2set=.0975,dataPredictY=dataX,
modele="pls",family=NULL,typeVC="none",EstimXNA=FALSE,scaleX=TRUE,
scaleY=NULL,pvals.expli=FALSE,alpha.pvals.expli=.05,MClassed=FALSE,
tol_Xi=10^(-12),weights,subset,contrasts=NULL,sparse=FALSE,
sparseStop=FALSE,naive=FALSE,verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plsR_+3A_object">object</code></td>
<td>
<p>response (training) dataset or an object of class &quot;<code><a href="stats.html#topic+formula">formula</a></code>&quot; (or one that can be coerced to that class): a symbolic description of the model to be fitted. The details of model specification are given under 'Details'.</p>
</td></tr>
<tr><td><code id="plsR_+3A_datay">dataY</code></td>
<td>
<p>response (training) dataset</p>
</td></tr>
<tr><td><code id="plsR_+3A_datax">dataX</code></td>
<td>
<p>predictor(s) (training) dataset</p>
</td></tr>
<tr><td><code id="plsR_+3A_formula">formula</code></td>
<td>
<p>an object of class &quot;<code><a href="stats.html#topic+formula">formula</a></code>&quot; (or one that can be coerced to that class): a symbolic description of the model to be fitted. The details of model specification are given under 'Details'.</p>
</td></tr>
<tr><td><code id="plsR_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a data frame) containing the variables in the model. If not found in <code>data</code>, the variables are taken from <code>environment(formula)</code>, typically the environment from which <code>plsR</code> is called.</p>
</td></tr>  
<tr><td><code id="plsR_+3A_nt">nt</code></td>
<td>
<p>number of components to be extracted</p>
</td></tr>
<tr><td><code id="plsR_+3A_limq2set">limQ2set</code></td>
<td>
<p>limit value for the Q2</p>
</td></tr>
<tr><td><code id="plsR_+3A_datapredicty">dataPredictY</code></td>
<td>
<p>predictor(s) (testing) dataset</p>
</td></tr>
<tr><td><code id="plsR_+3A_modele">modele</code></td>
<td>
<p>name of the PLS model to be fitted, only (<code>"pls"</code> available for this fonction.</p>
</td></tr>
<tr><td><code id="plsR_+3A_family">family</code></td>
<td>
<p>for the present moment the family argument is ignored and set thanks to the value of modele.</p>
</td></tr>
<tr><td><code id="plsR_+3A_typevc">typeVC</code></td>
<td>
<p>type of leave one out cross validation. Several procedures are available. If cross validation is required, one needs to selects the way of predicting the response for left out observations. For complete rows, without any missing value, there are two different ways of computing these predictions. As a consequence, for mixed datasets, with complete and incomplete rows, there are two ways of computing prediction : either predicts any row as if there were missing values in it (<code>missingdata</code>) or selects the prediction method accordingly to the completeness of the row (<code>adaptative</code>).
</p>

<dl>
<dt><code>none</code></dt><dd><p>no cross validation</p>
</dd>
<dt><code>standard</code></dt><dd><p>as in SIMCA for datasets without any missing value. For datasets with any missing value, it is the as using <code>missingdata</code></p>
</dd>
<dt><code>missingdata</code></dt><dd><p>all values predicted as those with missing values for datasets with any missing values</p>
</dd>
<dt><code>adaptative</code></dt><dd><p>predict a response value for an x with any missing value as those with missing values and for an x without any missing value as those without missing values.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="plsR_+3A_estimxna">EstimXNA</code></td>
<td>
<p>only for <code>modele="pls"</code>. Set whether the missing X values have to be estimated.</p>
</td></tr>
<tr><td><code id="plsR_+3A_scalex">scaleX</code></td>
<td>
<p>scale the predictor(s) : must be set to TRUE for <code>modele="pls"</code> and should be for glms pls.</p>
</td></tr>
<tr><td><code id="plsR_+3A_scaley">scaleY</code></td>
<td>
<p>scale the response : Yes/No. Ignored since non always possible for glm responses.</p>
</td></tr>
<tr><td><code id="plsR_+3A_pvals.expli">pvals.expli</code></td>
<td>
<p>should individual p-values be reported to tune model selection ?</p>
</td></tr>
<tr><td><code id="plsR_+3A_alpha.pvals.expli">alpha.pvals.expli</code></td>
<td>
<p>level of significance for predictors when pvals.expli=TRUE</p>
</td></tr>
<tr><td><code id="plsR_+3A_mclassed">MClassed</code></td>
<td>
<p>number of missclassified cases, should only be used for binary responses</p>
</td></tr>
<tr><td><code id="plsR_+3A_tol_xi">tol_Xi</code></td>
<td>
<p>minimal value for Norm2(Xi) and <code class="reqn">\mathrm{det}(pp' \times pp)</code> if there is any missing value in the <code>dataX</code>. It defaults to <code class="reqn">10^{-12}</code></p>
</td></tr>
<tr><td><code id="plsR_+3A_weights">weights</code></td>
<td>
<p>an optional vector of 'prior weights' to be used in the fitting process. Should be <code>NULL</code> or a numeric vector.</p>
</td></tr>
<tr><td><code id="plsR_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="plsR_+3A_contrasts">contrasts</code></td>
<td>
<p>an optional list. See the <code>contrasts.arg</code> of <code>model.matrix.default</code>.</p>
</td></tr>
<tr><td><code id="plsR_+3A_sparse">sparse</code></td>
<td>
<p>should the coefficients of non-significant predictors (&lt;<code>alpha.pvals.expli</code>) be set to 0</p>
</td></tr>
<tr><td><code id="plsR_+3A_sparsestop">sparseStop</code></td>
<td>
<p>should component extraction stop when no significant predictors (&lt;<code>alpha.pvals.expli</code>) are found</p>
</td></tr>
<tr><td><code id="plsR_+3A_naive">naive</code></td>
<td>
<p>Use the naive estimates for the Degrees of Freedom in plsR? Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plsR_+3A_verbose">verbose</code></td>
<td>
<p>should info messages be displayed ?</p>
</td></tr>
<tr><td><code id="plsR_+3A_...">...</code></td>
<td>
<p>arguments to pass to <code>plsRmodel.default</code> or to <code>plsRmodel.formula</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are several ways to deal with missing values that leads to different computations of leave one out cross validation criteria.
</p>
<p>A typical predictor has the form response ~ terms where response is the (numeric) response vector and terms is a series of terms which specifies a linear predictor for response. A terms specification of the form first + second indicates all the terms in first together with all the terms in second with any duplicates removed. 
</p>
<p>A specification of the form first:second indicates the the set of terms obtained by taking the interactions of all terms in first with all terms in second. The specification first*second indicates the cross of first and second. This is the same as first + second + first:second. 
</p>
<p>The terms in the formula will be re-ordered so that main effects come first, followed by the interactions, all second-order, all third-order and so on: to avoid this pass a terms object as the formula. 
</p>
<p>Non-NULL weights can be used to indicate that different observations have different dispersions (with the values in weights being inversely proportional to the dispersions); or equivalently, when the elements of weights are positive integers w_i, that each response y_i is the mean of w_i unit-weight observations. 
</p>
<p>The default estimator for Degrees of Freedom is the Kramer and Sugiyama's one. Information criteria are computed accordingly to these estimations. Naive Degrees of Freedom and Information Criteria are also provided for comparison purposes. For more details, see N. Kraemer and M. Sugiyama. (2011). The Degrees of Freedom of Partial Least Squares Regression. <em>Journal of the American Statistical Association</em>, 106(494), 697-705, 2011. 
</p>


<h3>Value</h3>

<table>
<tr><td><code>nr</code></td>
<td>
<p>Number of observations</p>
</td></tr>
<tr><td><code>nc</code></td>
<td>
<p>Number of predictors</p>
</td></tr>
<tr><td><code>nt</code></td>
<td>
<p>Number of requested components</p>
</td></tr>
<tr><td><code>ww</code></td>
<td>
<p>raw weights (before L2-normalization)</p>
</td></tr>
<tr><td><code>wwnorm</code></td>
<td>
<p>L2 normed weights (to be used with deflated matrices of predictor variables)</p>
</td></tr>
<tr><td><code>wwetoile</code></td>
<td>
<p>modified weights (to be used with original matrix of predictor variables)</p>
</td></tr>
<tr><td><code>tt</code></td>
<td>
<p>PLS components</p>
</td></tr>
<tr><td><code>pp</code></td>
<td>
<p>loadings of the predictor variables</p>
</td></tr>
<tr><td><code>CoeffC</code></td>
<td>
<p>coefficients of the PLS components</p>
</td></tr>
<tr><td><code>uscores</code></td>
<td>
<p>scores of the response variable</p>
</td></tr>
<tr><td><code>YChapeau</code></td>
<td>
<p>predicted response values for the dataX set</p>
</td></tr>
<tr><td><code>residYChapeau</code></td>
<td>
<p>residuals of the deflated response on the standardized scale</p>
</td></tr>
<tr><td><code>RepY</code></td>
<td>
<p>scaled response vector</p>
</td></tr>
<tr><td><code>na.miss.Y</code></td>
<td>
<p>is there any NA value in the response vector</p>
</td></tr>
<tr><td><code>YNA</code></td>
<td>
<p>indicatrix vector of missing values in RepY</p>
</td></tr>
<tr><td><code>residY</code></td>
<td>
<p>deflated scaled response vector</p>
</td></tr>
<tr><td><code>ExpliX</code></td>
<td>
<p>scaled matrix of predictors</p>
</td></tr>
<tr><td><code>na.miss.X</code></td>
<td>
<p>is there any NA value in the predictor matrix</p>
</td></tr>
<tr><td><code>XXNA</code></td>
<td>
<p>indicator of non-NA values in the predictor matrix</p>
</td></tr>
<tr><td><code>residXX</code></td>
<td>
<p>deflated predictor matrix</p>
</td></tr>
<tr><td><code>PredictY</code></td>
<td>
<p>response values with NA replaced with 0</p>
</td></tr>
<tr><td><code>press.ind</code></td>
<td>
<p>individual PRESS value for each observation (scaled scale)</p>
</td></tr>
<tr><td><code>press.tot</code></td>
<td>
<p>total PRESS value for all observations (scaled scale)</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>glm family used to fit PLSGLR model</p>
</td></tr>
<tr><td><code>ttPredictY</code></td>
<td>
<p>PLS components for the dataset on which prediction was requested</p>
</td></tr>
<tr><td><code>typeVC</code></td>
<td>
<p>type of leave one out cross-validation used</p>
</td></tr>
<tr><td><code>dataX</code></td>
<td>
<p>predictor values</p>
</td></tr>
<tr><td><code>dataY</code></td>
<td>
<p>response values</p>
</td></tr>
<tr><td><code>computed_nt</code></td>
<td>
<p>number of components that were computed</p>
</td></tr>
<tr><td><code>CoeffCFull</code></td>
<td>
<p>matrix of the coefficients of the predictors</p>
</td></tr>
<tr><td><code>CoeffConstante</code></td>
<td>
<p>value of the intercept (scaled scale)</p>
</td></tr>
<tr><td><code>Std.Coeffs</code></td>
<td>
<p>Vector of standardized regression coefficients</p>
</td></tr>
<tr><td><code>press.ind2</code></td>
<td>
<p>individual PRESS value for each observation (original scale)</p>
</td></tr>
<tr><td><code>RSSresidY</code></td>
<td>
<p>residual sum of squares (scaled scale)</p>
</td></tr>
<tr><td><code>Coeffs</code></td>
<td>
<p>Vector of regression coefficients (used with the original data scale)</p>
</td></tr>
<tr><td><code>Yresidus</code></td>
<td>
<p>residuals of the PLS model</p>
</td></tr>
<tr><td><code>RSS</code></td>
<td>
<p>residual sum of squares (original scale)</p>
</td></tr>
<tr><td><code>residusY</code></td>
<td>
<p>residuals of the deflated response on the standardized scale</p>
</td></tr>
<tr><td><code>AIC.std</code></td>
<td>
<p>AIC.std vs number of components (AIC computed for the standardized model</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>AIC vs number of components</p>
</td></tr>
<tr><td><code>optional</code></td>
<td>
<p>If the response is assumed to be binary:<br />
i.e. <code>MClassed=TRUE</code>.    
</p>

<dl>
<dt><code>MissClassed</code></dt><dd><p>Number of miss classed results</p>
</dd>
<dt><code>Probs</code></dt><dd><p>&quot;Probability&quot; predicted by the model. These are not true probabilities since they may lay outside of [0,1]</p>
</dd>
<dt><code>Probs.trc</code></dt><dd><p>Probability predicted by the model and constrained to belong to [0,1]</p>
</dd>
</dl>

</td></tr>
<tr><td><code>ttPredictFittedMissingY</code></td>
<td>
<p>Description of 'comp2'</p>
</td></tr>
<tr><td><code>optional</code></td>
<td>
<p>If cross validation was requested:<br />
i.e. <code>typeVC="standard"</code>, <code>typeVC="missingdata"</code> or <code>typeVC="adaptative"</code>.
</p>

<dl>
<dt><code>R2residY</code></dt><dd><p>R2 coefficient value on the standardized scale</p>
</dd>
<dt><code>R2</code></dt><dd><p>R2 coefficient value on the original scale</p>
</dd>
<dt><code>press.tot2</code></dt><dd><p>total PRESS value for all observations (original scale)</p>
</dd>
<dt><code>Q2</code></dt><dd><p>Q2 value (standardized scale)</p>
</dd>
<dt><code>limQ2</code></dt><dd><p>limit of the Q2 value</p>
</dd>
<dt><code>Q2_2</code></dt><dd><p>Q2 value (original scale)</p>
</dd>
<dt><code>Q2cum</code></dt><dd><p>cumulated Q2 (standardized scale)</p>
</dd>
<dt><code>Q2cum_2</code></dt><dd><p>cumulated Q2 (original scale)</p>
</dd>
</dl>

</td></tr>
<tr><td><code>InfCrit</code></td>
<td>
<p>table of Information Criteria</p>
</td></tr>
<tr><td><code>Std.ValsPredictY</code></td>
<td>
<p>predicted response values for supplementary dataset (standardized scale)</p>
</td></tr>
<tr><td><code>ValsPredictY</code></td>
<td>
<p>predicted response values for supplementary dataset (original scale)</p>
</td></tr>
<tr><td><code>Std.XChapeau</code></td>
<td>
<p>estimated values for missing values in the predictor matrix (standardized scale)</p>
</td></tr>
<tr><td><code>XXwotNA</code></td>
<td>
<p>predictor matrix with missing values replaced with 0</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Use <code><a href="#topic+cv.plsR">cv.plsR</a></code> to cross-validate the plsRglm models and <code><a href="#topic+bootpls">bootpls</a></code> to bootstrap them.</p>


<h3>Author(s)</h3>

<p>Frederic Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>References</h3>

<p>Nicolas Meyer, Myriam Maumy-Bertrand et Frederic Bertrand (2010). Comparing the linear and the logistic PLS regression with qualitative predictors: application to allelotyping data. <em>Journal de la Societe Francaise de Statistique</em>, 151(2), pages 1-18.
<a href="http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47">http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47</a>
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+plsRglm">plsRglm</a></code> to fit PLSGLR models.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Cornell)
XCornell&lt;-Cornell[,1:7]
yCornell&lt;-Cornell[,8]

#maximum 6 components could be extracted from this dataset
#trying 10 to trigger automatic stopping criterion
modpls10&lt;-plsR(yCornell,XCornell,10)
modpls10

#With iterated leave one out CV PRESS
modpls6cv&lt;-plsR(Y~.,data=Cornell,6,typeVC="standard")
modpls6cv
cv.modpls&lt;-cv.plsR(Y~.,data=Cornell,6,NK=100, verbose=FALSE)
res.cv.modpls&lt;-cvtable(summary(cv.modpls))
plot(res.cv.modpls)

rm(list=c("XCornell","yCornell","modpls10","modpls6cv"))


#A binary response example
data(aze_compl)
Xaze_compl&lt;-aze_compl[,2:34]
yaze_compl&lt;-aze_compl$y
modpls.aze &lt;- plsR(yaze_compl,Xaze_compl,10,MClassed=TRUE,typeVC="standard")
modpls.aze

#Direct access to not cross-validated values
modpls.aze$AIC
modpls.aze$AIC.std
modpls.aze$MissClassed

#Raw predicted values (not really probabily since not constrained in [0,1]
modpls.aze$Probs
#Truncated to [0;1] predicted values (true probabilities)
modpls.aze$Probs.trc
modpls.aze$Probs-modpls.aze$Probs.trc

#Repeated cross validation of the model (NK=100 times)
cv.modpls.aze&lt;-cv.plsR(y~.,data=aze_compl,10,NK=100, verbose=FALSE)
res.cv.modpls.aze&lt;-cvtable(summary(cv.modpls.aze,MClassed=TRUE))
#High discrepancy in the number of component choice using repeated cross validation
#and missclassed criterion
plot(res.cv.modpls.aze)

rm(list=c("Xaze_compl","yaze_compl","modpls.aze","cv.modpls.aze","res.cv.modpls.aze"))

#24 predictors
dimX &lt;- 24
#2 components
Astar &lt;- 2
simul_data_UniYX(dimX,Astar)
dataAstar2 &lt;- data.frame(t(replicate(250,simul_data_UniYX(dimX,Astar))))
modpls.A2&lt;- plsR(Y~.,data=dataAstar2,10,typeVC="standard")
modpls.A2
cv.modpls.A2&lt;-cv.plsR(Y~.,data=dataAstar2,10,NK=100, verbose=FALSE)
res.cv.modpls.A2&lt;-cvtable(summary(cv.modpls.A2,verbose=FALSE))
#Perfect choice for the Q2 criterion in PLSR
plot(res.cv.modpls.A2)

#Binarized data.frame
simbin1 &lt;- data.frame(dicho(dataAstar2))
modpls.B2 &lt;- plsR(Y~.,data=simbin1,10,typeVC="standard",MClassed=TRUE, verbose=FALSE)
modpls.B2
modpls.B2$Probs
modpls.B2$Probs.trc
modpls.B2$MissClassed
plsR(simbin1$Y,dataAstar2[,-1],10,typeVC="standard",MClassed=TRUE,verbose=FALSE)$InfCrit
cv.modpls.B2&lt;-cv.plsR(Y~.,data=simbin1,2,NK=100,verbose=FALSE)
res.cv.modpls.B2&lt;-cvtable(summary(cv.modpls.B2,MClassed=TRUE))
#Only one component found by repeated CV missclassed criterion
plot(res.cv.modpls.B2)

rm(list=c("dimX","Astar","dataAstar2","modpls.A2","cv.modpls.A2",
"res.cv.modpls.A2","simbin1","modpls.B2","cv.modpls.B2","res.cv.modpls.B2"))

</code></pre>

<hr>
<h2 id='plsR.dof'>Computation of the Degrees of Freedom</h2><span id='topic+plsR.dof'></span>

<h3>Description</h3>

<p>This function computes the Degrees of Freedom using the Krylov
representation of PLS and other quantities that are used to get information
criteria values. For the time present, it only works with complete datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dof'
plsR(modplsR, naive = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plsR.dof_+3A_modplsr">modplsR</code></td>
<td>
<p>A plsR model i.e. an object returned by one of the functions
<code>plsR</code>, <code>plsRmodel.default</code>, <code>plsRmodel.formula</code>,
<code>PLS_lm</code> or <code>PLS_lm_formula</code>.</p>
</td></tr>
<tr><td><code id="plsR.dof_+3A_naive">naive</code></td>
<td>
<p>A boolean.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>naive=FALSE</code> returns values for estimated degrees of freedom and
error dispersion. If <code>naive=TRUE</code> returns returns values for naive
degrees of freedom and error dispersion. The original code from Nicole
Kraemer and Mikio L. Braun was unable to handle models with only one
component.
</p>


<h3>Value</h3>

<table>
<tr><td><code>DoF</code></td>
<td>
<p>Degrees of Freedom</p>
</td></tr> <tr><td><code>sigmahat</code></td>
<td>
<p>Estimates of
dispersion</p>
</td></tr> <tr><td><code>Yhat</code></td>
<td>
<p>Predicted values</p>
</td></tr> <tr><td><code>yhat</code></td>
<td>
<p>Square Euclidean norms
of the predicted values</p>
</td></tr> <tr><td><code>RSS</code></td>
<td>
<p>Residual Sums of Squares</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nicole Kraemer, Mikio L. Braun with improvements from
Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>References</h3>

<p>N. Kraemer, M. Sugiyama. (2011). The Degrees of Freedom of
Partial Least Squares Regression. <em>Journal of the American Statistical
Association</em>, 106(494), 697-705.<br /> N. Kraemer, M. Sugiyama, M.L. Braun.
(2009). Lanczos Approximations for the Speedup of Kernel Partial Least
Squares Regression, <em>Proceedings of the Twelfth International
Conference on Artificial Intelligence and Statistics (AISTATS)</em>, 272-279.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aic.dof">aic.dof</a></code> and <code><a href="#topic+infcrit.dof">infcrit.dof</a></code> for computing
information criteria directly from a previously fitted plsR model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Cornell)
XCornell&lt;-Cornell[,1:7]
yCornell&lt;-Cornell[,8]
modpls &lt;- plsR(yCornell,XCornell,4)
plsR.dof(modpls) 
plsR.dof(modpls,naive=TRUE) 

</code></pre>

<hr>
<h2 id='plsRglm'>Partial least squares Regression generalized linear models</h2><span id='topic+plsRglm'></span><span id='topic+plsRglmmodel.default'></span><span id='topic+plsRglmmodel.formula'></span><span id='topic+PLS_glm'></span><span id='topic+PLS_glm_formula'></span>

<h3>Description</h3>

<p>This function implements Partial least squares Regression generalized linear models complete or incomplete datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plsRglm(object, ...)
## Default S3 method:
plsRglmmodel(object,dataX,nt=2,limQ2set=.0975,
dataPredictY=dataX,modele="pls",family=NULL,typeVC="none",
EstimXNA=FALSE,scaleX=TRUE,scaleY=NULL,pvals.expli=FALSE,
alpha.pvals.expli=.05,MClassed=FALSE,tol_Xi=10^(-12),weights,
sparse=FALSE,sparseStop=TRUE,naive=FALSE,verbose=TRUE,...)
## S3 method for class 'formula'
plsRglmmodel(object,data=NULL,nt=2,limQ2set=.0975,
dataPredictY,modele="pls",family=NULL,typeVC="none",
EstimXNA=FALSE,scaleX=TRUE,scaleY=NULL,pvals.expli=FALSE,
alpha.pvals.expli=.05,MClassed=FALSE,tol_Xi=10^(-12),weights,subset,
start=NULL,etastart,mustart,offset,method="glm.fit",control= list(),
contrasts=NULL,sparse=FALSE,sparseStop=TRUE,naive=FALSE,verbose=TRUE,...)
PLS_glm(dataY, dataX, nt = 2, limQ2set = 0.0975, dataPredictY = dataX, 
modele = "pls", family = NULL, typeVC = "none", EstimXNA = FALSE, 
scaleX = TRUE, scaleY = NULL, pvals.expli = FALSE, 
alpha.pvals.expli = 0.05, MClassed = FALSE, tol_Xi = 10^(-12), weights, 
method, sparse = FALSE, sparseStop=FALSE, naive=FALSE,verbose=TRUE)
PLS_glm_formula(formula,data=NULL,nt=2,limQ2set=.0975,dataPredictY=dataX,
modele="pls",family=NULL,typeVC="none",EstimXNA=FALSE,scaleX=TRUE,
scaleY=NULL,pvals.expli=FALSE,alpha.pvals.expli=.05,MClassed=FALSE,
tol_Xi=10^(-12),weights,subset,start=NULL,etastart,mustart,offset,method,
control= list(),contrasts=NULL,sparse=FALSE,sparseStop=FALSE,naive=FALSE,verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plsRglm_+3A_object">object</code></td>
<td>
<p>response (training) dataset or an object of class &quot;<code><a href="stats.html#topic+formula">formula</a></code>&quot; (or one that can be coerced to that class): a symbolic description of the model to be fitted. The details of model specification are given under 'Details'.</p>
</td></tr>
<tr><td><code id="plsRglm_+3A_datay">dataY</code></td>
<td>
<p>response (training) dataset</p>
</td></tr>
<tr><td><code id="plsRglm_+3A_datax">dataX</code></td>
<td>
<p>predictor(s) (training) dataset</p>
</td></tr>
<tr><td><code id="plsRglm_+3A_formula">formula</code></td>
<td>
<p>an object of class &quot;<code><a href="stats.html#topic+formula">formula</a></code>&quot; (or one that can be coerced to that class): a symbolic description of the model to be fitted. The details of model specification are given under 'Details'.</p>
</td></tr>
<tr><td><code id="plsRglm_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a data frame) containing the variables in the model. If not found in <code>data</code>, the variables are taken from <code>environment(formula)</code>, typically the environment from which <code>plsRglm</code> is called.</p>
</td></tr>  
<tr><td><code id="plsRglm_+3A_nt">nt</code></td>
<td>
<p>number of components to be extracted</p>
</td></tr>
<tr><td><code id="plsRglm_+3A_limq2set">limQ2set</code></td>
<td>
<p>limit value for the Q2</p>
</td></tr>
<tr><td><code id="plsRglm_+3A_datapredicty">dataPredictY</code></td>
<td>
<p>predictor(s) (testing) dataset</p>
</td></tr>
<tr><td><code id="plsRglm_+3A_modele">modele</code></td>
<td>
<p>name of the PLS glm model to be fitted (<code>"pls"</code>, <code>"pls-glm-Gamma"</code>, <code>"pls-glm-gaussian"</code>, <code>"pls-glm-inverse.gaussian"</code>, <code>"pls-glm-logistic"</code>, <code>"pls-glm-poisson"</code>, <code>"pls-glm-polr"</code>). Use <code>"modele=pls-glm-family"</code> to enable the <code>family</code> option.</p>
</td></tr>
<tr><td><code id="plsRglm_+3A_family">family</code></td>
<td>
<p>a description of the error distribution and link function to be used in the model. This can be a character string naming a family function, a family function or the result of a call to a family function. (See <code><a href="stats.html#topic+family">family</a></code> for details of family functions.) To use the family option, please set <code>modele="pls-glm-family"</code>. User defined families can also be defined. See details.</p>
</td></tr>
<tr><td><code id="plsRglm_+3A_typevc">typeVC</code></td>
<td>
<p>type of leave one out cross validation. For back compatibility purpose.
</p>

<dl>
<dt><code>none</code></dt><dd><p>no cross validation</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="plsRglm_+3A_estimxna">EstimXNA</code></td>
<td>
<p>only for <code>modele="pls"</code>. Set whether the missing X values have to be estimated.</p>
</td></tr>
<tr><td><code id="plsRglm_+3A_scalex">scaleX</code></td>
<td>
<p>scale the predictor(s) : must be set to TRUE for <code>modele="pls"</code> and should be for glms pls.</p>
</td></tr>
<tr><td><code id="plsRglm_+3A_scaley">scaleY</code></td>
<td>
<p>scale the response : Yes/No. Ignored since non always possible for glm responses.</p>
</td></tr>
<tr><td><code id="plsRglm_+3A_pvals.expli">pvals.expli</code></td>
<td>
<p>should individual p-values be reported to tune model selection ?</p>
</td></tr>
<tr><td><code id="plsRglm_+3A_alpha.pvals.expli">alpha.pvals.expli</code></td>
<td>
<p>level of significance for predictors when pvals.expli=TRUE</p>
</td></tr>
<tr><td><code id="plsRglm_+3A_mclassed">MClassed</code></td>
<td>
<p>number of missclassified cases, should only be used for binary responses</p>
</td></tr>
<tr><td><code id="plsRglm_+3A_tol_xi">tol_Xi</code></td>
<td>
<p>minimal value for Norm2(Xi) and <code class="reqn">\mathrm{det}(pp' \times pp)</code> if there is any missing value in the <code>dataX</code>. It defaults to <code class="reqn">10^{-12}</code></p>
</td></tr>
<tr><td><code id="plsRglm_+3A_weights">weights</code></td>
<td>
<p>an optional vector of 'prior weights' to be used in the fitting process. Should be <code>NULL</code> or a numeric vector.</p>
</td></tr>
<tr><td><code id="plsRglm_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="plsRglm_+3A_start">start</code></td>
<td>
<p>starting values for the parameters in the linear predictor.</p>
</td></tr>
<tr><td><code id="plsRglm_+3A_etastart">etastart</code></td>
<td>
<p>starting values for the linear predictor.</p>
</td></tr>
<tr><td><code id="plsRglm_+3A_mustart">mustart</code></td>
<td>
<p>starting values for the vector of means.</p>
</td></tr>
<tr><td><code id="plsRglm_+3A_offset">offset</code></td>
<td>
<p>this can be used to specify an <em>a priori</em> known component to be included in the linear predictor during fitting. This should be <code>NULL</code> or a numeric vector of length equal to the number of cases. One or more <code><a href="stats.html#topic+offset">offset</a></code> terms can be included in the formula instead or as well, and if more than one is specified their sum is used. See <code><a href="stats.html#topic+model.offset">model.offset</a></code>.</p>
</td></tr>
<tr><td><code id="plsRglm_+3A_method">method</code></td>
<td>
<p>For a glm model (<code>modele="pls-glm-family"</code>), the method to be used in fitting the model. The default method <code>"glm.fit"</code> uses iteratively reweighted least squares (IWLS). User-supplied fitting functions can be supplied either as a function or a character string naming a function, with a function which takes the same arguments as <code>glm.fit</code>.
For a polr model (<code>modele="pls-glm-polr"</code>), <code>logistic</code> or <code>probit</code> or (complementary) log-log (<code>loglog</code> or <code>cloglog</code>) or <code>cauchit</code> (corresponding to a Cauchy latent variable).</p>
</td></tr>
<tr><td><code id="plsRglm_+3A_control">control</code></td>
<td>
<p>a list of parameters for controlling the fitting process. For <code>glm.fit</code> this is passed to <code><a href="stats.html#topic+glm.control">glm.control</a></code>.</p>
</td></tr>
<tr><td><code id="plsRglm_+3A_contrasts">contrasts</code></td>
<td>
<p>an optional list. See the <code>contrasts.arg</code> of <code>model.matrix.default</code>.</p>
</td></tr>
<tr><td><code id="plsRglm_+3A_sparse">sparse</code></td>
<td>
<p>should the coefficients of non-significant predictors (&lt;<code>alpha.pvals.expli</code>) be set to 0</p>
</td></tr>
<tr><td><code id="plsRglm_+3A_sparsestop">sparseStop</code></td>
<td>
<p>should component extraction stop when no significant predictors (&lt;<code>alpha.pvals.expli</code>) are found</p>
</td></tr>
<tr><td><code id="plsRglm_+3A_naive">naive</code></td>
<td>
<p>Use the naive estimates for the Degrees of Freedom in plsR? Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plsRglm_+3A_verbose">verbose</code></td>
<td>
<p>Should details be displayed ?</p>
</td></tr>
<tr><td><code id="plsRglm_+3A_...">...</code></td>
<td>
<p>arguments to pass to <code>plsRmodel.default</code> or to <code>plsRmodel.formula</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are seven different predefined models with predefined link functions available :
</p>

<dl>
<dt><code>"pls"</code></dt><dd><p>ordinary pls models</p>
</dd>
<dt><code>"pls-glm-Gamma"</code></dt><dd><p>glm gaussian with inverse link pls models</p>
</dd>
<dt><code>"pls-glm-gaussian"</code></dt><dd><p>glm gaussian with identity link pls models</p>
</dd>
<dt><code>"pls-glm-inverse-gamma"</code></dt><dd><p>glm binomial with square inverse link pls models</p>
</dd>
<dt><code>"pls-glm-logistic"</code></dt><dd><p>glm binomial with logit link pls models</p>
</dd>
<dt><code>"pls-glm-poisson"</code></dt><dd><p>glm poisson with log link pls models</p>
</dd>
<dt><code>"pls-glm-polr"</code></dt><dd><p>glm polr with logit link pls models</p>
</dd>
</dl>

<p>Using the <code>"family="</code> option and setting <code>"modele=pls-glm-family"</code> allows changing the family and link function the same way as for the <code><a href="stats.html#topic+glm">glm</a></code> function. As a consequence user-specified families can also be used. 
</p>

<dl>
<dt>The <code>gaussian</code> family</dt><dd><p>accepts the links (as names) <code>identity</code>, <code>log</code> and <code>inverse</code>.</p>
</dd>
<dt>The <code>binomial</code> family</dt><dd><p>accepts the links <code>logit</code>, <code>probit</code>, <code>cauchit</code>, (corresponding to logistic, normal and Cauchy CDFs respectively) <code>log</code> and <code>cloglog</code> (complementary log-log).</p>
</dd> 
<dt>The <code>Gamma</code> family</dt><dd><p>accepts the links <code>inverse</code>, <code>identity</code> and <code>log</code>.</p>
</dd>
<dt>The <code>poisson</code> family</dt><dd><p>accepts the links <code>log</code>, <code>identity</code>, and <code>sqrt</code>.</p>
</dd>
<dt>The <code>inverse.gaussian</code> family</dt><dd><p>accepts the links <code>1/mu^2</code>, <code>inverse</code>, <code>identity</code> and <code>log</code>.</p>
</dd>
<dt>The <code>quasi</code> family</dt><dd><p>accepts the links <code>logit</code>, <code>probit</code>, <code>cloglog</code>, <code>identity</code>, <code>inverse</code>, <code>log</code>, <code>1/mu^2</code> and <code>sqrt</code>.</p>
</dd>
<dt>The function <code>power</code></dt><dd><p>can be used to create a power link function.</p>
</dd> 
</dl>

<p>A typical predictor has the form response ~ terms where response is the (numeric) response vector and terms is a series of terms which specifies a linear predictor for response. A terms specification of the form first + second indicates all the terms in first together with all the terms in second with any duplicates removed. 
</p>
<p>A specification of the form first:second indicates the the set of terms obtained by taking the interactions of all terms in first with all terms in second. The specification first*second indicates the cross of first and second. This is the same as first + second + first:second. 
</p>
<p>The terms in the formula will be re-ordered so that main effects come first, followed by the interactions, all second-order, all third-order and so on: to avoid this pass a terms object as the formula. 
</p>
<p>Non-NULL weights can be used to indicate that different observations have different dispersions (with the values in weights being inversely proportional to the dispersions); or equivalently, when the elements of weights are positive integers w_i, that each response y_i is the mean of w_i unit-weight observations. 
</p>
<p>The default estimator for Degrees of Freedom is the Kramer and Sugiyama's one which only works for classical plsR models. For these models, Information criteria are computed accordingly to these estimations. Naive Degrees of Freedom and Information Criteria are also provided for comparison purposes. For more details, see N. Kraemer and M. Sugiyama. (2011). The Degrees of Freedom of Partial Least Squares Regression. <em>Journal of the American Statistical Association</em>, 106(494), 697-705, 2011.
</p>


<h3>Value</h3>

<p>Depends on the model that was used to fit the model. You can generally at least find these items.<br />
</p>
<table>
<tr><td><code>nr</code></td>
<td>
<p>Number of observations</p>
</td></tr>
<tr><td><code>nc</code></td>
<td>
<p>Number of predictors</p>
</td></tr>
<tr><td><code>nt</code></td>
<td>
<p>Number of requested components</p>
</td></tr>
<tr><td><code>ww</code></td>
<td>
<p>raw weights (before L2-normalization)</p>
</td></tr>
<tr><td><code>wwnorm</code></td>
<td>
<p>L2 normed weights (to be used with deflated matrices of predictor variables)</p>
</td></tr>
<tr><td><code>wwetoile</code></td>
<td>
<p>modified weights (to be used with original matrix of predictor variables)</p>
</td></tr>
<tr><td><code>tt</code></td>
<td>
<p>PLS components</p>
</td></tr>
<tr><td><code>pp</code></td>
<td>
<p>loadings of the predictor variables</p>
</td></tr>
<tr><td><code>CoeffC</code></td>
<td>
<p>coefficients of the PLS components</p>
</td></tr>
<tr><td><code>uscores</code></td>
<td>
<p>scores of the response variable</p>
</td></tr>
<tr><td><code>YChapeau</code></td>
<td>
<p>predicted response values for the dataX set</p>
</td></tr>
<tr><td><code>residYChapeau</code></td>
<td>
<p>residuals of the deflated response on the standardized scale</p>
</td></tr>
<tr><td><code>RepY</code></td>
<td>
<p>scaled response vector</p>
</td></tr>
<tr><td><code>na.miss.Y</code></td>
<td>
<p>is there any NA value in the response vector</p>
</td></tr>
<tr><td><code>YNA</code></td>
<td>
<p>indicatrix vector of missing values in RepY</p>
</td></tr>
<tr><td><code>residY</code></td>
<td>
<p>deflated scaled response vector</p>
</td></tr>
<tr><td><code>ExpliX</code></td>
<td>
<p>scaled matrix of predictors</p>
</td></tr>
<tr><td><code>na.miss.X</code></td>
<td>
<p>is there any NA value in the predictor matrix</p>
</td></tr>
<tr><td><code>XXNA</code></td>
<td>
<p>indicator of non-NA values in the predictor matrix</p>
</td></tr>
<tr><td><code>residXX</code></td>
<td>
<p>deflated predictor matrix</p>
</td></tr>
<tr><td><code>PredictY</code></td>
<td>
<p>response values with NA replaced with 0</p>
</td></tr>
<tr><td><code>RSS</code></td>
<td>
<p>residual sum of squares (original scale)</p>
</td></tr>
<tr><td><code>RSSresidY</code></td>
<td>
<p>residual sum of squares (scaled scale)</p>
</td></tr>
<tr><td><code>R2residY</code></td>
<td>
<p>R2 coefficient value on the standardized scale</p>
</td></tr>
<tr><td><code>R2</code></td>
<td>
<p>R2 coefficient value on the original scale</p>
</td></tr>
<tr><td><code>press.ind</code></td>
<td>
<p>individual PRESS value for each observation (scaled scale)</p>
</td></tr>
<tr><td><code>press.tot</code></td>
<td>
<p>total PRESS value for all observations (scaled scale)</p>
</td></tr>
<tr><td><code>Q2cum</code></td>
<td>
<p>cumulated Q2 (standardized scale)</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>glm family used to fit PLSGLR model</p>
</td></tr>
<tr><td><code>ttPredictY</code></td>
<td>
<p>PLS components for the dataset on which prediction was requested</p>
</td></tr>
<tr><td><code>typeVC</code></td>
<td>
<p>type of leave one out cross-validation used</p>
</td></tr>
<tr><td><code>dataX</code></td>
<td>
<p>predictor values</p>
</td></tr>
<tr><td><code>dataY</code></td>
<td>
<p>response values</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>weights of the observations</p>
</td></tr>
<tr><td><code>computed_nt</code></td>
<td>
<p>number of components that were computed</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>AIC vs number of components</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>BIC vs number of components</p>
</td></tr>
<tr><td><code>Coeffsmodel_vals</code></td>
<td>
</td></tr>
<tr><td><code>ChisqPearson</code></td>
<td>
</td></tr>
<tr><td><code>CoeffCFull</code></td>
<td>
<p>matrix of the coefficients of the predictors</p>
</td></tr>
<tr><td><code>CoeffConstante</code></td>
<td>
<p>value of the intercept (scaled scale)</p>
</td></tr>
<tr><td><code>Std.Coeffs</code></td>
<td>
<p>Vector of standardized regression coefficients</p>
</td></tr>
<tr><td><code>Coeffs</code></td>
<td>
<p>Vector of regression coefficients (used with the original data scale)</p>
</td></tr>
<tr><td><code>Yresidus</code></td>
<td>
<p>residuals of the PLS model</p>
</td></tr>
<tr><td><code>residusY</code></td>
<td>
<p>residuals of the deflated response on the standardized scale</p>
</td></tr>
<tr><td><code>InfCrit</code></td>
<td>
<p>table of Information Criteria:<br />
</p>

<dl>
<dt><code>AIC</code></dt><dd><p>AIC vs number of components</p>
</dd>
<dt><code>BIC</code></dt><dd><p>BIC vs number of components</p>
</dd>
<dt><code>MissClassed</code></dt><dd><p>Number of miss classed results</p>
</dd>
<dt><code>Chi2_Pearson_Y</code></dt><dd><p>Q2 value (standardized scale)</p>
</dd>
<dt><code>RSS</code></dt><dd><p>residual sum of squares (original scale)</p>
</dd>
<dt><code>R2</code></dt><dd><p>R2 coefficient value on the original scale</p>
</dd>
<dt><code>R2residY</code></dt><dd><p>R2 coefficient value on the standardized scale</p>
</dd>
<dt><code>RSSresidY</code></dt><dd><p>residual sum of squares (scaled scale)</p>
</dd>
</dl>

</td></tr>
<tr><td><code>Std.ValsPredictY</code></td>
<td>
<p>predicted response values for supplementary dataset (standardized scale)</p>
</td></tr>
<tr><td><code>ValsPredictY</code></td>
<td>
<p>predicted response values for supplementary dataset (original scale)</p>
</td></tr>
<tr><td><code>Std.XChapeau</code></td>
<td>
<p>estimated values for missing values in the predictor matrix (standardized scale)</p>
</td></tr>
<tr><td><code>FinalModel</code></td>
<td>
<p>final GLR model on the PLS components</p>
</td></tr>
<tr><td><code>XXwotNA</code></td>
<td>
<p>predictor matrix with missing values replaced with 0</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>call</p>
</td></tr>
<tr><td><code>AIC.std</code></td>
<td>
<p>AIC.std vs number of components (AIC computed for the standardized model</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Use <code><a href="#topic+cv.plsRglm">cv.plsRglm</a></code> to cross-validate the plsRglm models and <code><a href="#topic+bootplsglm">bootplsglm</a></code> to bootstrap them.</p>


<h3>Author(s)</h3>

<p>Frederic Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>References</h3>

<p>Nicolas Meyer, Myriam Maumy-Bertrand et Frederic Bertrand (2010). Comparaison de la regression PLS et de la regression logistique PLS : application aux donnees d'allelotypage. <em>Journal de la Societe Francaise de Statistique</em>, 151(2), pages 1-18.
<a href="http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47">http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47</a>
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+plsR">plsR</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Cornell)
XCornell&lt;-Cornell[,1:7]
yCornell&lt;-Cornell[,8]

modplsglm &lt;- plsRglm(yCornell,XCornell,10,modele="pls-glm-gaussian")

#To retrieve the final GLR model on the PLS components
finalmod &lt;- modplsglm$FinalModel
#It is a glm object.
plot(finalmod)


#Cross validation
cv.modplsglm&lt;-cv.plsRglm(Y~.,data=Cornell,6,NK=100,modele="pls-glm-gaussian", verbose=FALSE)
res.cv.modplsglm&lt;-cvtable(summary(cv.modplsglm))
plot(res.cv.modplsglm)

#If no model specified, classic PLSR model
modpls &lt;- plsRglm(Y~.,data=Cornell,6)
modpls
modpls$tt
modpls$uscores
modpls$pp
modpls$Coeffs

#rm(list=c("XCornell","yCornell",modpls,cv.modplsglm,res.cv.modplsglm))


data(aze_compl)
Xaze_compl&lt;-aze_compl[,2:34]
yaze_compl&lt;-aze_compl$y
plsRglm(yaze_compl,Xaze_compl,nt=10,modele="pls",MClassed=TRUE, verbose=FALSE)$InfCrit
modpls &lt;- plsRglm(yaze_compl,Xaze_compl,nt=10,modele="pls-glm-logistic",
MClassed=TRUE,pvals.expli=TRUE, verbose=FALSE)
modpls
colSums(modpls$pvalstep)
modpls$Coeffsmodel_vals

plot(plsRglm(yaze_compl,Xaze_compl,4,modele="pls-glm-logistic")$FinalModel)
plsRglm(yaze_compl[-c(99,72)],Xaze_compl[-c(99,72),],4,
modele="pls-glm-logistic",pvals.expli=TRUE)$pvalstep
plot(plsRglm(yaze_compl[-c(99,72)],Xaze_compl[-c(99,72),],4,
modele="pls-glm-logistic",pvals.expli=TRUE)$FinalModel)
rm(list=c("Xaze_compl","yaze_compl","modpls"))


data(bordeaux)
Xbordeaux&lt;-bordeaux[,1:4]
ybordeaux&lt;-factor(bordeaux$Quality,ordered=TRUE)
modpls &lt;- plsRglm(ybordeaux,Xbordeaux,10,modele="pls-glm-polr",pvals.expli=TRUE)
modpls
colSums(modpls$pvalstep)


XbordeauxNA&lt;-Xbordeaux
XbordeauxNA[1,1] &lt;- NA
modplsNA &lt;- plsRglm(ybordeaux,XbordeauxNA,10,modele="pls-glm-polr",pvals.expli=TRUE)
modpls
colSums(modpls$pvalstep)
rm(list=c("Xbordeaux","XbordeauxNA","ybordeaux","modplsNA"))


data(pine)
Xpine&lt;-pine[,1:10]
ypine&lt;-pine[,11]
modpls1 &lt;- plsRglm(ypine,Xpine,1)
modpls1$Std.Coeffs
modpls1$Coeffs
modpls4 &lt;- plsRglm(ypine,Xpine,4)
modpls4$Std.Coeffs
modpls4$Coeffs
modpls4$PredictY[1,]
plsRglm(ypine,Xpine,4,dataPredictY=Xpine[1,])$PredictY[1,]

XpineNAX21 &lt;- Xpine
XpineNAX21[1,2] &lt;- NA
modpls4NA &lt;- plsRglm(ypine,XpineNAX21,4)
modpls4NA$Std.Coeffs
modpls4NA$YChapeau[1,]
modpls4$YChapeau[1,]
modpls4NA$CoeffC
plsRglm(ypine,XpineNAX21,4,EstimXNA=TRUE)$XChapeau
plsRglm(ypine,XpineNAX21,4,EstimXNA=TRUE)$XChapeauNA

# compare pls-glm-gaussian with classic plsR
modplsglm4 &lt;- plsRglm(ypine,Xpine,4,modele="pls-glm-gaussian")
cbind(modpls4$Std.Coeffs,modplsglm4$Std.Coeffs)

# without missing data
cbind(ypine,modpls4$ValsPredictY,modplsglm4$ValsPredictY)

# with missing data
modplsglm4NA &lt;- plsRglm(ypine,XpineNAX21,4,modele="pls-glm-gaussian")
cbind((ypine),modpls4NA$ValsPredictY,modplsglm4NA$ValsPredictY)
rm(list=c("Xpine","ypine","modpls4","modpls4NA","modplsglm4","modplsglm4NA"))

data(fowlkes)
Xfowlkes &lt;- fowlkes[,2:13]
yfowlkes &lt;- fowlkes[,1]
modpls &lt;- plsRglm(yfowlkes,Xfowlkes,4,modele="pls-glm-logistic",pvals.expli=TRUE)
modpls
colSums(modpls$pvalstep)
rm(list=c("Xfowlkes","yfowlkes","modpls"))


if(require(chemometrics)){
data(hyptis)
yhyptis &lt;- factor(hyptis$Group,ordered=TRUE)
Xhyptis &lt;- as.data.frame(hyptis[,c(1:6)])
options(contrasts = c("contr.treatment", "contr.poly"))
modpls2 &lt;- plsRglm(yhyptis,Xhyptis,6,modele="pls-glm-polr")
modpls2$Coeffsmodel_vals
modpls2$InfCrit
modpls2$Coeffs
modpls2$Std.Coeffs

table(yhyptis,predict(modpls2$FinalModel,type="class"))
rm(list=c("yhyptis","Xhyptis","modpls2"))
}

dimX &lt;- 24
Astar &lt;- 6
dataAstar6 &lt;- t(replicate(250,simul_data_UniYX(dimX,Astar)))
ysimbin1 &lt;- dicho(dataAstar6)[,1]
Xsimbin1 &lt;- dicho(dataAstar6)[,2:(dimX+1)]
modplsglm &lt;- plsRglm(ysimbin1,Xsimbin1,10,modele="pls-glm-logistic")
modplsglm

simbin=data.frame(dicho(dataAstar6))
cv.modplsglm &lt;- suppressWarnings(cv.plsRglm(Y~.,data=simbin,nt=10,
modele="pls-glm-logistic",NK=100, verbose=FALSE))
res.cv.modplsglm &lt;- cvtable(summary(cv.modplsglm,MClassed=TRUE,
verbose=FALSE))
plot(res.cv.modplsglm) #defaults to type="CVMC"

rm(list=c("dimX","Astar","dataAstar6","ysimbin1","Xsimbin1","modplsglm","cv.modplsglm",
"res.cv.modplsglm"))

</code></pre>

<hr>
<h2 id='predict.plsRglmmodel'>Print method for plsRglm models</h2><span id='topic+predict.plsRglmmodel'></span>

<h3>Description</h3>

<p>This function provides a predict method for the class <code>"plsRglmmodel"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'plsRglmmodel'
predict(
  object,
  newdata,
  comps = object$computed_nt,
  type = c("link", "response", "terms", "scores", "class", "probs"),
  se.fit = FALSE,
  weights,
  dispersion = NULL,
  methodNA = "adaptative",
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.plsRglmmodel_+3A_object">object</code></td>
<td>
<p>An object of the class <code>"plsRmodel"</code>.</p>
</td></tr>
<tr><td><code id="predict.plsRglmmodel_+3A_newdata">newdata</code></td>
<td>
<p>An optional data frame in which to look for variables with
which to predict. If omitted, the fitted values are used.</p>
</td></tr>
<tr><td><code id="predict.plsRglmmodel_+3A_comps">comps</code></td>
<td>
<p>A value with a single value of component to use for prediction.</p>
</td></tr>
<tr><td><code id="predict.plsRglmmodel_+3A_type">type</code></td>
<td>
<p>Type of predicted value. Available choices are the glms ones
(&quot;<code>link</code>&quot;, &quot;<code>response</code>&quot;, &quot;<code>terms</code>&quot;), the polr ones
(&quot;<code>class</code>&quot;, &quot;<code>probs</code>&quot;) or the scores (&quot;<code>scores</code>&quot;).</p>
</td></tr>
<tr><td><code id="predict.plsRglmmodel_+3A_se.fit">se.fit</code></td>
<td>
<p>If TRUE, pointwise standard errors are produced for the
predictions using the Cox model.</p>
</td></tr>
<tr><td><code id="predict.plsRglmmodel_+3A_weights">weights</code></td>
<td>
<p>Vector of case weights. If <code>weights</code> is a vector of
integers, then the estimated coefficients are equivalent to estimating the
model from data with the individual <code>cases</code> replicated as many times as
indicated by <code>weights</code>.</p>
</td></tr>
<tr><td><code id="predict.plsRglmmodel_+3A_dispersion">dispersion</code></td>
<td>
<p>the dispersion of the GLM fit to be assumed in computing
the standard errors. If omitted, that returned by summary applied to the
object is used.</p>
</td></tr>
<tr><td><code id="predict.plsRglmmodel_+3A_methodna">methodNA</code></td>
<td>
<p>Selects the way of predicting the response or the scores of
the new data. For complete rows, without any missing value, there are two
different ways of computing the prediction. As a consequence, for mixed
datasets, with complete and incomplete rows, there are two ways of computing
prediction : either predicts any row as if there were missing values in it
(<code>missingdata</code>) or selects the prediction method accordingly to the
completeness of the row (<code>adaptative</code>).</p>
</td></tr>
<tr><td><code id="predict.plsRglmmodel_+3A_verbose">verbose</code></td>
<td>
<p>should info messages be displayed ?</p>
</td></tr>
<tr><td><code id="predict.plsRglmmodel_+3A_...">...</code></td>
<td>
<p>Arguments to be passed on to <code>stats::glm</code> and
<code>plsRglm::plsRglm</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>When type is &quot;<code>response</code>&quot;, a matrix of predicted response
values is returned.<br /> When type is &quot;<code>scores</code>&quot;, a score matrix is
returned.
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>References</h3>

<p>Nicolas Meyer, Myriam Maumy-Bertrand et
Frédéric Bertrand (2010). Comparing the linear and the
logistic PLS regression with qualitative predictors: application to
allelotyping data. <em>Journal de la Societe Francaise de Statistique</em>,
151(2), pages 1-18.
<a href="http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47">http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47</a>
</p>


<h3>See Also</h3>

<p>See Also <code><a href="stats.html#topic+predict.glm">predict.glm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(pine)
Xpine&lt;-pine[,1:10]
ypine&lt;-pine[,11]
data(pine_sup)
Xpine_sup&lt;-pine_sup[,1:10]
Xpine_supNA&lt;-Xpine_sup
Xpine_supNA[1,1]&lt;-NA

modpls=plsRglm(object=ypine,dataX=Xpine,nt=6,modele="pls-glm-family",family="gaussian",
verbose=FALSE)
modplsform=plsRglm(x11~.,data=pine,nt=6,modele="pls-glm-family",family="gaussian", verbose=FALSE)
modpls2=plsRglm(object=ypine,dataX=Xpine,nt=6,modele="pls-glm-family",
dataPredictY=Xpine_sup,family="gaussian", verbose=FALSE)
modpls2NA=plsRglm(object=ypine,dataX=Xpine,nt=6,modele="pls-glm-family",
dataPredictY=Xpine_supNA,family="gaussian", verbose=FALSE)

#Identical to predict(modpls,type="link") or modpls$Std.ValsPredictY
cbind(modpls$Std.ValsPredictY,modplsform$Std.ValsPredictY,
predict(modpls),predict(modplsform))

#Identical to predict(modpls,type="response") or modpls$ValsPredictY
cbind(modpls$ValsPredictY,modplsform$ValsPredictY,
predict(modpls,type="response"),predict(modplsform,type="response"))

#Identical to modpls$ttPredictY
predict(modpls,type="scores")
predict(modplsform,type="scores")


#Identical to modpls2$ValsPredictY
cbind(predict(modpls,newdata=Xpine_sup,type="response"),
predict(modplsform,newdata=Xpine_sup,type="response"))

#Select the number of components to use to derive the prediction
predict(modpls,newdata=Xpine_sup,type="response",comps=1)    
predict(modpls,newdata=Xpine_sup,type="response",comps=3)    
predict(modpls,newdata=Xpine_sup,type="response",comps=6)    
try(predict(modpls,newdata=Xpine_sup,type="response",comps=8))

#Identical to modpls2$ttValsPredictY
predict(modpls,newdata=Xpine_sup,type="scores")    

#Select the number of components in the scores matrix
predict(modpls,newdata=Xpine_sup,type="scores",comps=1)    
predict(modpls,newdata=Xpine_sup,type="scores",comps=3)    
predict(modpls,newdata=Xpine_sup,type="scores",comps=6)    
try(predict(modpls,newdata=Xpine_sup,type="scores",comps=8))

#Identical to modpls2NA$ValsPredictY
predict(modpls,newdata=Xpine_supNA,type="response",methodNA="missingdata")    

cbind(predict(modpls,newdata=Xpine_supNA,type="response"),
predict(modplsform,newdata=Xpine_supNA,type="response"))

predict(modpls,newdata=Xpine_supNA,type="response",comps=1)    
predict(modpls,newdata=Xpine_supNA,type="response",comps=3)    
predict(modpls,newdata=Xpine_supNA,type="response",comps=6)    
try(predict(modpls,newdata=Xpine_supNA,type="response",comps=8))

#Identical to modpls2NA$ttPredictY
predict(modpls,newdata=Xpine_supNA,type="scores",methodNA="missingdata")
predict(modplsform,newdata=Xpine_supNA,type="scores",methodNA="missingdata")

predict(modpls,newdata=Xpine_supNA,type="scores")    
predict(modplsform,newdata=Xpine_supNA,type="scores")    
predict(modpls,newdata=Xpine_supNA,type="scores",comps=1)    
predict(modpls,newdata=Xpine_supNA,type="scores",comps=3)    
predict(modpls,newdata=Xpine_supNA,type="scores",comps=6)    
try(predict(modpls,newdata=Xpine_supNA,type="scores",comps=8))
    

</code></pre>

<hr>
<h2 id='predict.plsRmodel'>Print method for plsR models</h2><span id='topic+predict.plsRmodel'></span>

<h3>Description</h3>

<p>This function provides a predict method for the class <code>"plsRmodel"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'plsRmodel'
predict(
  object,
  newdata,
  comps = object$computed_nt,
  type = c("response", "scores"),
  weights,
  methodNA = "adaptative",
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.plsRmodel_+3A_object">object</code></td>
<td>
<p>An object of the class <code>"plsRmodel"</code>.</p>
</td></tr>
<tr><td><code id="predict.plsRmodel_+3A_newdata">newdata</code></td>
<td>
<p>An optional data frame in which to look for variables with
which to predict. If omitted, the fitted values are used.</p>
</td></tr>
<tr><td><code id="predict.plsRmodel_+3A_comps">comps</code></td>
<td>
<p>A value with a single value of component to use for prediction.</p>
</td></tr>
<tr><td><code id="predict.plsRmodel_+3A_type">type</code></td>
<td>
<p>Type of predicted value. Available choices are the response
values (&quot;<code>response</code>&quot;) or the scores (&quot;<code>scores</code>&quot;).</p>
</td></tr>
<tr><td><code id="predict.plsRmodel_+3A_weights">weights</code></td>
<td>
<p>Vector of case weights. If <code>weights</code> is a vector of
integers, then the estimated coefficients are equivalent to estimating the
model from data with the individual <code>cases</code> replicated as many times as
indicated by <code>weights</code>.</p>
</td></tr>
<tr><td><code id="predict.plsRmodel_+3A_methodna">methodNA</code></td>
<td>
<p>Selects the way of predicting the response or the scores of
the new data. For complete rows, without any missing value, there are two
different ways of computing the prediction. As a consequence, for mixed
datasets, with complete and incomplete rows, there are two ways of computing
prediction : either predicts any row as if there were missing values in it
(<code>missingdata</code>) or selects the prediction method accordingly to the
completeness of the row (<code>adaptative</code>).</p>
</td></tr>
<tr><td><code id="predict.plsRmodel_+3A_verbose">verbose</code></td>
<td>
<p>should info messages be displayed ?</p>
</td></tr>
<tr><td><code id="predict.plsRmodel_+3A_...">...</code></td>
<td>
<p>Arguments to be passed on to <code>plsRglm::plsR</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>When type is &quot;<code>response</code>&quot;, a matrix of predicted response
values is returned.<br /> When type is &quot;<code>scores</code>&quot;, a score matrix is
returned.
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>References</h3>

<p>Nicolas Meyer, Myriam Maumy-Bertrand et
Frédéric Bertrand (2010). Comparing the linear and the
logistic PLS regression with qualitative predictors: application to
allelotyping data. <em>Journal de la Societe Francaise de Statistique</em>,
151(2), pages 1-18.
<a href="http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47">http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(pine)
Xpine&lt;-pine[,1:10]
ypine&lt;-pine[,11]
data(pine_sup)
Xpine_sup&lt;-pine_sup[,1:10]
Xpine_supNA&lt;-Xpine_sup
Xpine_supNA[1,1]&lt;-NA

modpls=plsR(object=ypine,dataX=Xpine,nt=6,modele="pls", verbose=FALSE)
modplsform=plsR(x11~.,data=pine,nt=6,modele="pls", verbose=FALSE)
modpls2=plsR(object=ypine,dataX=Xpine,nt=6,modele="pls",dataPredictY=Xpine_sup, verbose=FALSE)
modpls2NA=plsR(object=ypine,dataX=Xpine,nt=6,modele="pls",dataPredictY=Xpine_supNA, verbose=FALSE)

#Identical to predict(modpls,type="response") or modpls$ValsPredictY
cbind(predict(modpls),predict(modplsform))

#Identical to modpls$ttPredictY
predict(modpls,type="scores")
predict(modplsform,type="scores")


#Identical to modpls2$ValsPredictY
cbind(predict(modpls,newdata=Xpine_sup,type="response"),
predict(modplsform,newdata=Xpine_sup,type="response"))

#Select the number of components to use to derive the prediction
predict(modpls,newdata=Xpine_sup,type="response",comps=1)    
predict(modpls,newdata=Xpine_sup,type="response",comps=3)    
predict(modpls,newdata=Xpine_sup,type="response",comps=6)    
try(predict(modpls,newdata=Xpine_sup,type="response",comps=8))

#Identical to modpls2$ttValsPredictY
predict(modpls,newdata=Xpine_sup,type="scores")    

#Select the number of components in the scores matrix
predict(modpls,newdata=Xpine_sup,type="scores",comps=1)    
predict(modpls,newdata=Xpine_sup,type="scores",comps=3)    
predict(modpls,newdata=Xpine_sup,type="scores",comps=6)    
try(predict(modpls,newdata=Xpine_sup,type="scores",comps=8))

#Identical to modpls2NA$ValsPredictY
predict(modpls,newdata=Xpine_supNA,type="response",methodNA="missingdata")    

cbind(predict(modpls,newdata=Xpine_supNA,type="response"),
predict(modplsform,newdata=Xpine_supNA,type="response"))

predict(modpls,newdata=Xpine_supNA,type="response",comps=1)    
predict(modpls,newdata=Xpine_supNA,type="response",comps=3)    
predict(modpls,newdata=Xpine_supNA,type="response",comps=6)    
try(predict(modpls,newdata=Xpine_supNA,type="response",comps=8))

#Identical to modpls2NA$ttPredictY
predict(modpls,newdata=Xpine_supNA,type="scores",methodNA="missingdata")
predict(modplsform,newdata=Xpine_supNA,type="scores",methodNA="missingdata")

predict(modpls,newdata=Xpine_supNA,type="scores")    
predict(modplsform,newdata=Xpine_supNA,type="scores")    
predict(modpls,newdata=Xpine_supNA,type="scores",comps=1)    
predict(modpls,newdata=Xpine_supNA,type="scores",comps=3)    
predict(modpls,newdata=Xpine_supNA,type="scores",comps=6)    
try(predict(modpls,newdata=Xpine_supNA,type="scores",comps=8))
    

</code></pre>

<hr>
<h2 id='print.coef.plsRglmmodel'>Print method for plsRglm models</h2><span id='topic+print.coef.plsRglmmodel'></span>

<h3>Description</h3>

<p>This function provides a print method for the class
<code>"coef.plsRglmmodel"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coef.plsRglmmodel'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.coef.plsRglmmodel_+3A_x">x</code></td>
<td>
<p>an object of the class <code>"coef.plsRglmmodel"</code></p>
</td></tr>
<tr><td><code id="print.coef.plsRglmmodel_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>References</h3>

<p>Nicolas Meyer, Myriam Maumy-Bertrand et
Frédéric Bertrand (2010). Comparing the linear and the
logistic PLS regression with qualitative predictors: application to
allelotyping data. <em>Journal de la Societe Francaise de Statistique</em>,
151(2), pages 1-18.
<a href="http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47">http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+print">print</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Cornell)
XCornell&lt;-Cornell[,1:7]
yCornell&lt;-Cornell[,8]
modplsglm &lt;- plsRglm(yCornell,XCornell,3,modele="pls-glm-family",family=gaussian())
class(modplsglm)
print(coef(modplsglm))
rm(list=c("XCornell","yCornell","modplsglm"))

</code></pre>

<hr>
<h2 id='print.coef.plsRmodel'>Print method for plsR models</h2><span id='topic+print.coef.plsRmodel'></span>

<h3>Description</h3>

<p>This function provides a print method for the class <code>"coef.plsRmodel"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coef.plsRmodel'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.coef.plsRmodel_+3A_x">x</code></td>
<td>
<p>an object of the class <code>"coef.plsRmodel"</code></p>
</td></tr>
<tr><td><code id="print.coef.plsRmodel_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>References</h3>

<p>Nicolas Meyer, Myriam Maumy-Bertrand et
Frédéric Bertrand (2010). Comparing the linear and the
logistic PLS regression with qualitative predictors: application to
allelotyping data. <em>Journal de la Societe Francaise de Statistique</em>,
151(2), pages 1-18.
<a href="http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47">http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+print">print</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Cornell)
XCornell&lt;-Cornell[,1:7]
yCornell&lt;-Cornell[,8]
modpls &lt;- plsRglm(yCornell,XCornell,3,modele="pls")
class(modpls)
print(coef(modpls))
rm(list=c("XCornell","yCornell","modpls"))

</code></pre>

<hr>
<h2 id='print.cv.plsRglmmodel'>Print method for plsRglm models</h2><span id='topic+print.cv.plsRglmmodel'></span>

<h3>Description</h3>

<p>This function provides a print method for the class <code>"cv.plsRglmmodel"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.plsRglmmodel'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.cv.plsRglmmodel_+3A_x">x</code></td>
<td>
<p>an object of the class <code>"cv.plsRglmmodel"</code></p>
</td></tr>
<tr><td><code id="print.cv.plsRglmmodel_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>References</h3>

<p>Nicolas Meyer, Myriam Maumy-Bertrand et
Frédéric Bertrand (2010). Comparaison de la
régression PLS et de la régression
logistique PLS : application aux données
d'allélotypage. <em>Journal de la Société Française
de Statistique</em>, 151(2), pages 1-18.
<a href="http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47">http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+print">print</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Cornell)
XCornell&lt;-Cornell[,1:7]
yCornell&lt;-Cornell[,8]
print(cv.plsRglm(object=yCornell,dataX=XCornell,nt=10,NK=1,
modele="pls-glm-family",family=gaussian(), verbose=FALSE))
rm(list=c("XCornell","yCornell","bbb"))

</code></pre>

<hr>
<h2 id='print.cv.plsRmodel'>Print method for plsR models</h2><span id='topic+print.cv.plsRmodel'></span>

<h3>Description</h3>

<p>This function provides a print method for the class <code>"cv.plsRmodel"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.plsRmodel'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.cv.plsRmodel_+3A_x">x</code></td>
<td>
<p>an object of the class <code>"cv.plsRmodel"</code></p>
</td></tr>
<tr><td><code id="print.cv.plsRmodel_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>References</h3>

<p>Nicolas Meyer, Myriam Maumy-Bertrand et
Frédéric Bertrand (2010). Comparing the linear and the
logistic PLS regression with qualitative predictors: application to
allelotyping data. <em>Journal de la Societe Francaise de Statistique</em>,
151(2), pages 1-18.
<a href="http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47">http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+print">print</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Cornell)
XCornell&lt;-Cornell[,1:7]
yCornell&lt;-Cornell[,8]
print(cv.plsR(object=yCornell,dataX=XCornell,nt=10,K=6, verbose=FALSE))
rm(list=c("XCornell","yCornell","bbb"))

</code></pre>

<hr>
<h2 id='print.plsRglmmodel'>Print method for plsRglm models</h2><span id='topic+print.plsRglmmodel'></span>

<h3>Description</h3>

<p>This function provides a print method for the class <code>"plsRglmmodel"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'plsRglmmodel'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.plsRglmmodel_+3A_x">x</code></td>
<td>
<p>an object of the class <code>"plsRglmmodel"</code></p>
</td></tr>
<tr><td><code id="print.plsRglmmodel_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>References</h3>

<p>Nicolas Meyer, Myriam Maumy-Bertrand et
Frédéric Bertrand (2010). Comparaison de la
régression PLS et de la régression
logistique PLS : application aux données
d'allélotypage. <em>Journal de la Société Française
de Statistique</em>, 151(2), pages 1-18.
<a href="http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47">http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+print">print</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Cornell)
XCornell&lt;-Cornell[,1:7]
yCornell&lt;-Cornell[,8]
modplsglm &lt;- plsRglm(yCornell,XCornell,3,modele="pls-glm-gaussian")
class(modplsglm)
print(modplsglm)
rm(list=c("XCornell","yCornell","modplsglm"))

</code></pre>

<hr>
<h2 id='print.plsRmodel'>Print method for plsR models</h2><span id='topic+print.plsRmodel'></span>

<h3>Description</h3>

<p>This function provides a print method for the class <code>"plsRmodel"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'plsRmodel'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.plsRmodel_+3A_x">x</code></td>
<td>
<p>an object of the class <code>"plsRmodel"</code></p>
</td></tr>
<tr><td><code id="print.plsRmodel_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>References</h3>

<p>Nicolas Meyer, Myriam Maumy-Bertrand et
Frédéric Bertrand (2010). Comparaison de la
régression PLS et de la régression
logistique PLS : application aux données
d'allélotypage. <em>Journal de la Société Française
de Statistique</em>, 151(2), pages 1-18.
<a href="http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47">http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+print">print</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Cornell)
XCornell&lt;-Cornell[,1:7]
yCornell&lt;-Cornell[,8]
modpls &lt;- plsRglm(yCornell,XCornell,3,modele="pls")
class(modpls)
print(modpls)
rm(list=c("XCornell","yCornell","modpls"))

</code></pre>

<hr>
<h2 id='print.summary.plsRglmmodel'>Print method for summaries of plsRglm models</h2><span id='topic+print.summary.plsRglmmodel'></span>

<h3>Description</h3>

<p>This function provides a print method for the class
<code>"summary.plsRglmmodel"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.plsRglmmodel'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.plsRglmmodel_+3A_x">x</code></td>
<td>
<p>an object of the class <code>"summary.plsRglmmodel"</code></p>
</td></tr>
<tr><td><code id="print.summary.plsRglmmodel_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>language</code></td>
<td>
<p>call of the model</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>References</h3>

<p>Nicolas Meyer, Myriam Maumy-Bertrand et
Frédéric Bertrand (2010). Comparaison de la
régression PLS et de la régression
logistique PLS : application aux données
d'allélotypage. <em>Journal de la Société Française
de Statistique</em>, 151(2), pages 1-18.
<a href="http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47">http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+print">print</a></code> and <code><a href="base.html#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Cornell)
XCornell&lt;-Cornell[,1:7]
yCornell&lt;-Cornell[,8]
modplsglm &lt;- plsRglm(yCornell,XCornell,3,modele="pls-glm-gaussian")
class(modplsglm)
print(summary(modplsglm))
rm(list=c("XCornell","yCornell","modplsglm"))

</code></pre>

<hr>
<h2 id='print.summary.plsRmodel'>Print method for summaries of plsR models</h2><span id='topic+print.summary.plsRmodel'></span>

<h3>Description</h3>

<p>This function provides a print method for the class
<code>"summary.plsRmodel"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.plsRmodel'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.plsRmodel_+3A_x">x</code></td>
<td>
<p>an object of the class <code>"summary.plsRmodel"</code></p>
</td></tr>
<tr><td><code id="print.summary.plsRmodel_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>language</code></td>
<td>
<p>call of the model</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>References</h3>

<p>Nicolas Meyer, Myriam Maumy-Bertrand et
Frédéric Bertrand (2010). Comparaison de la
régression PLS et de la régression
logistique PLS : application aux données
d'allélotypage. <em>Journal de la Société Française
de Statistique</em>, 151(2), pages 1-18.
<a href="http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47">http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+print">print</a></code> and <code><a href="base.html#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Cornell)
XCornell&lt;-Cornell[,1:7]
yCornell&lt;-Cornell[,8]
modpls &lt;- plsRglm(yCornell,XCornell,3,modele="pls")
class(modpls)
print(summary(modpls))
rm(list=c("XCornell","yCornell","modpls"))

</code></pre>

<hr>
<h2 id='signpred'>Graphical assessment of the stability of selected variables</h2><span id='topic+signpred'></span>

<h3>Description</h3>

<p>This fonctions plots, for each of the model, the
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signpred(
  matbin,
  pred.lablength = max(sapply(rownames(matbin), nchar)),
  labsize = 1,
  plotsize = 12
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="signpred_+3A_matbin">matbin</code></td>
<td>
<p>Matrix with 0 or 1 entries. Each row per predictor and a
column for every model. 0 means the predictor is not significant in the
model and 1 that, on the contrary, it is significant.</p>
</td></tr>
<tr><td><code id="signpred_+3A_pred.lablength">pred.lablength</code></td>
<td>
<p>Maximum length of the predictors labels. Defaults to
full label length.</p>
</td></tr>
<tr><td><code id="signpred_+3A_labsize">labsize</code></td>
<td>
<p>Size of the predictors labels.</p>
</td></tr>
<tr><td><code id="signpred_+3A_plotsize">plotsize</code></td>
<td>
<p>Global size of the graph.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is based on the <code><a href="bipartite.html#topic+visweb">visweb</a></code> function from
the bipartite package.
</p>


<h3>Value</h3>

<p>A plot window.
</p>


<h3>Author(s)</h3>

<p>Bernd Gruber with minor modifications from
Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>References</h3>

<p>Vazquez, P.D., Chacoff, N.,P. and Cagnolo, L. (2009) Evaluating
multiple determinants of the structure of plant-animal mutualistic networks.
<em>Ecology</em>, 90:2039-2046.
</p>


<h3>See Also</h3>

<p>See Also <code><a href="bipartite.html#topic+visweb">visweb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
signpred(matrix(rbinom(160,1,.2),ncol=8,dimnames=list(as.character(1:20),as.character(1:8))))

</code></pre>

<hr>
<h2 id='simul_data_complete'>Data generating detailed process for multivariate plsR models</h2><span id='topic+simul_data_complete'></span>

<h3>Description</h3>

<p>This function generates a single multivariate response value
<code class="reqn">\boldsymbol{Y}</code> and a vector of explinatory variables
<code class="reqn">(X_1,\ldots,X_{totdim})</code> drawn from a model with a given number of
latent components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simul_data_complete(totdim, ncomp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simul_data_complete_+3A_totdim">totdim</code></td>
<td>
<p>Number of columns of the X vector (from <code>ncomp</code> to
hardware limits)</p>
</td></tr>
<tr><td><code id="simul_data_complete_+3A_ncomp">ncomp</code></td>
<td>
<p>Number of latent components in the model (from 2 to 6)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function should be combined with the replicate function to give rise to
a larger dataset. The algorithm used is a port of the one described in the
article of Li which is a multivariate generalization of the algorithm of
Naes and Martens.
</p>


<h3>Value</h3>

<table>
<tr><td><code>simX</code></td>
<td>
<p>Vector of explanatory variables</p>
</td></tr> <tr><td><code>HH</code></td>
<td>
<p>Dimension of
the response <code class="reqn">\boldsymbol{Y}</code></p>
</td></tr> <tr><td><code>eta</code></td>
<td>
<p>See Li et al.</p>
</td></tr> <tr><td><code>r</code></td>
<td>
<p>See Li
et al.</p>
</td></tr> <tr><td><code>epsilon</code></td>
<td>
<p>See Li et al.</p>
</td></tr> <tr><td><code>ksi</code></td>
<td>
<p>See Li et al.</p>
</td></tr> <tr><td><code>f</code></td>
<td>
<p>See
Li et al.</p>
</td></tr> <tr><td><code>z</code></td>
<td>
<p>See Li et al.</p>
</td></tr> <tr><td><code>Y</code></td>
<td>
<p>See Li et al.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The value of <code class="reqn">r</code> depends on the value of <code>ncomp</code> :
</p>

<table>
<tr>
 <td style="text-align: center;"> <code>ncomp</code> </td><td style="text-align: center;"> <code class="reqn">r</code> </td>
</tr>
<tr>
 <td style="text-align: center;"> 2 </td><td style="text-align: center;"> 3 </td>
</tr>
<tr>
 <td style="text-align: center;"> 3 </td><td style="text-align: center;"> 3 </td>
</tr>
<tr>
 <td style="text-align: center;"> 4 </td><td style="text-align: center;">
4 </td>
</tr>
<tr>
 <td style="text-align: center;"> </td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>References</h3>

<p>T. Naes, H. Martens, Comparison of prediction methods for
multicollinear data, Commun. Stat., Simul. 14 (1985) 545-576.<br />
Morris, Elaine B. Martin, Model selection for partial least squares
regression, Chemometrics and Intelligent Laboratory 
Systems 64 (2002) 79-89, <a href="https://doi.org/10.1016/S0169-7439%2802%2900051-5">doi:10.1016/S0169-7439(02)00051-5</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simul_data_YX">simul_data_YX</a></code> for data simulation purpose
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
simul_data_complete(20,6)                          

dimX &lt;- 6
Astar &lt;- 2
simul_data_complete(dimX,Astar)


dimX &lt;- 6
Astar &lt;- 3
simul_data_complete(dimX,Astar)


dimX &lt;- 6
Astar &lt;- 4
simul_data_complete(dimX,Astar)

rm(list=c("dimX","Astar"))

</code></pre>

<hr>
<h2 id='simul_data_UniYX'>Data generating function for univariate plsR models</h2><span id='topic+simul_data_UniYX'></span>

<h3>Description</h3>

<p>This function generates a single univariate response value <code class="reqn">Y</code> and a
vector of explanatory variables <code class="reqn">(X_1,\ldots,X_{totdim})</code> drawn from a
model with a given number of latent components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simul_data_UniYX(totdim, ncomp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simul_data_UniYX_+3A_totdim">totdim</code></td>
<td>
<p>Number of columns of the X vector (from <code>ncomp</code> to
hardware limits)</p>
</td></tr>
<tr><td><code id="simul_data_UniYX_+3A_ncomp">ncomp</code></td>
<td>
<p>Number of latent components in the model (from 2 to 6)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function should be combined with the replicate function to give rise to
a larger dataset. The algorithm used is a port of the one described in the
article of Li which is a multivariate generalization of the algorithm of
Naes and Martens.
</p>


<h3>Value</h3>

<table>
<tr><td><code>vector</code></td>
<td>
<p><code class="reqn">(Y,X_1,\ldots,X_{totdim})</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>References</h3>

<p>T. Naes, H. Martens, Comparison of prediction methods for
multicollinear data, Commun. Stat., Simul. 14 (1985) 545-576.<br />
Morris, Elaine B. Martin, Model selection for partial least squares
regression, Chemometrics and Intelligent Laboratory Systems 64 (2002)
79-89, <a href="https://doi.org/10.1016/S0169-7439%2802%2900051-5">doi:10.1016/S0169-7439(02)00051-5</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simul_data_YX">simul_data_YX</a></code> and <code><a href="#topic+simul_data_complete">simul_data_complete</a></code>
for generating multivariate data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
simul_data_UniYX(20,6)                          


dimX &lt;- 6
Astar &lt;- 2
simul_data_UniYX(dimX,Astar)
(dataAstar2 &lt;- data.frame(t(replicate(50,simul_data_UniYX(dimX,Astar)))))
cvtable(summary(cv.plsR(Y~.,data=dataAstar2,5,NK=100, verbose=FALSE)))

dimX &lt;- 6
Astar &lt;- 3
simul_data_UniYX(dimX,Astar)
(dataAstar3 &lt;- data.frame(t(replicate(50,simul_data_UniYX(dimX,Astar)))))
cvtable(summary(cv.plsR(Y~.,data=dataAstar3,5,NK=100, verbose=FALSE)))

dimX &lt;- 6
Astar &lt;- 4
simul_data_UniYX(dimX,Astar)
(dataAstar4 &lt;- data.frame(t(replicate(50,simul_data_UniYX(dimX,Astar)))))
cvtable(summary(cv.plsR(Y~.,data=dataAstar4,5,NK=100, verbose=FALSE)))

rm(list=c("dimX","Astar","dataAstar2","dataAstar3","dataAstar4"))


</code></pre>

<hr>
<h2 id='simul_data_UniYX_binom'>Data generating function for univariate binomial plsR models</h2><span id='topic+simul_data_UniYX_binom'></span>

<h3>Description</h3>

<p>This function generates a single univariate binomial response value <code class="reqn">Y</code>
and a vector of explanatory variables <code class="reqn">(X_1,\ldots,X_{totdim})</code> drawn
from a model with a given number of latent components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simul_data_UniYX_binom(totdim, ncomp, link = "logit", offset = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simul_data_UniYX_binom_+3A_totdim">totdim</code></td>
<td>
<p>Number of columns of the X vector (from <code>ncomp</code> to
hardware limits)</p>
</td></tr>
<tr><td><code id="simul_data_UniYX_binom_+3A_ncomp">ncomp</code></td>
<td>
<p>Number of latent components in the model (from 2 to 6)</p>
</td></tr>
<tr><td><code id="simul_data_UniYX_binom_+3A_link">link</code></td>
<td>
<p>Character specification of the link function in the mean model
(mu). Currently, &quot;<code>logit</code>&quot;, &quot;<code>probit</code>&quot;, &quot;<code>cloglog</code>&quot;,
&quot;<code>cauchit</code>&quot;, &quot;<code>log</code>&quot;, &quot;<code>loglog</code>&quot; are supported.
Alternatively, an object of class &quot;link-glm&quot; can be supplied.</p>
</td></tr>
<tr><td><code id="simul_data_UniYX_binom_+3A_offset">offset</code></td>
<td>
<p>Offset on the linear scale</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function should be combined with the replicate function to give rise to
a larger dataset. The algorithm used is a modification of a port of the one
described in the article of Li which is a multivariate generalization of the
algorithm of Naes and Martens.
</p>


<h3>Value</h3>

<table>
<tr><td><code>vector</code></td>
<td>
<p><code class="reqn">(Y,X_1,\ldots,X_{totdim})</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>References</h3>

<p>T. Naes, H. Martens, Comparison of prediction methods for
multicollinear data, Commun. Stat., Simul. 14 (1985) 545-576.<br />
Morris, Elaine B. Martin, Model selection for partial least squares
regression, Chemometrics and Intelligent Laboratory Systems 64 (2002), 
79-89, <a href="https://doi.org/10.1016/S0169-7439%2802%2900051-5">doi:10.1016/S0169-7439(02)00051-5</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simul_data_UniYX">simul_data_UniYX</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

layout(matrix(1:6,nrow=2))
# logit link
hist(t(replicate(100,simul_data_UniYX_binom(4,4)))[,1])
# probit link
hist(t(replicate(100,simul_data_UniYX_binom(4,4,link="probit")))[,1])
# cloglog link
hist(t(replicate(100,simul_data_UniYX_binom(4,4,link="cloglog")))[,1])
# cauchit link
hist(t(replicate(100,simul_data_UniYX_binom(4,4,link="cauchit")))[,1])
# loglog link
hist(t(replicate(100,simul_data_UniYX_binom(4,4,link="loglog")))[,1])
# log link
hist(t(replicate(100,simul_data_UniYX_binom(4,4,link="log")))[,1])
layout(1)


layout(matrix(1:6,nrow=2))
# logit link
hist(t(replicate(100,simul_data_UniYX_binom(4,4,offset=5)))[,1])
# probit link
hist(t(replicate(100,simul_data_UniYX_binom(4,4,link="probit",offset=5)))[,1])
# cloglog link
hist(t(replicate(100,simul_data_UniYX_binom(4,4,link="cloglog",offset=5)))[,1])
# cauchit link
hist(t(replicate(100,simul_data_UniYX_binom(4,4,link="cauchit",offset=5)))[,1])
# loglog link
hist(t(replicate(100,simul_data_UniYX_binom(4,4,link="loglog",offset=5)))[,1])
# log link
hist(t(replicate(100,simul_data_UniYX_binom(4,4,link="log",offset=5)))[,1])
layout(1)


layout(matrix(1:6,nrow=2))
# logit link
hist(t(replicate(100,simul_data_UniYX_binom(4,4,offset=-5)))[,1])
# probit link
hist(t(replicate(100,simul_data_UniYX_binom(4,4,link="probit",offset=-5)))[,1])
# cloglog link
hist(t(replicate(100,simul_data_UniYX_binom(4,4,link="cloglog",offset=-5)))[,1])
# cauchit link
hist(t(replicate(100,simul_data_UniYX_binom(4,4,link="cauchit",offset=-5)))[,1])
# loglog link
hist(t(replicate(100,simul_data_UniYX_binom(4,4,link="loglog",offset=-5)))[,1])
# log link
hist(t(replicate(100,simul_data_UniYX_binom(4,4,link="log",offset=-5)))[,1])
layout(1)


</code></pre>

<hr>
<h2 id='simul_data_YX'>Data generating function for multivariate plsR models</h2><span id='topic+simul_data_YX'></span>

<h3>Description</h3>

<p>This function generates a single multivariate response value
<code class="reqn">\boldsymbol{Y}</code> and a vector of explinatory variables
<code class="reqn">(X_1,\ldots,X_{totdim})</code> drawn from a model with a given number of
latent components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simul_data_YX(totdim, ncomp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simul_data_YX_+3A_totdim">totdim</code></td>
<td>
<p>Number of column of the X vector (from <code>ncomp</code> to
hardware limits)</p>
</td></tr>
<tr><td><code id="simul_data_YX_+3A_ncomp">ncomp</code></td>
<td>
<p>Number of latent components in the model (from 2 to 6)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function should be combined with the replicate function to give rise to
a larger dataset. The algorithm used is a port of the one described in the
article of Li which is a multivariate generalization of the algorithm of
Naes and Martens.
</p>


<h3>Value</h3>

<table>
<tr><td><code>vector</code></td>
<td>
<p><code class="reqn">(Y_1,\ldots,Y_r,X_1,\ldots,X_{totdim})</code></p>
</td></tr>
</table>


<h3>Note</h3>

<p>The value of <code class="reqn">r</code> depends on the value of <code>ncomp</code> :
</p>

<table>
<tr>
 <td style="text-align: center;"> <code>ncomp</code> </td><td style="text-align: center;"> <code class="reqn">r</code> </td>
</tr>
<tr>
 <td style="text-align: center;"> 2 </td><td style="text-align: center;"> 3 </td>
</tr>
<tr>
 <td style="text-align: center;"> 3 </td><td style="text-align: center;"> 3 </td>
</tr>
<tr>
 <td style="text-align: center;"> 4
</td><td style="text-align: center;"> 4 </td>
</tr>
<tr>
 <td style="text-align: center;"> </td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>References</h3>

<p>T. Naes, H. Martens, Comparison of prediction methods for
multicollinear data, Commun. Stat., Simul. 14 (1985) 545-576.<br />
Morris, Elaine B. Martin, Model selection for partial least squares
regression, Chemometrics and Intelligent Laboratory Systems 64 (2002)
79-89, <a href="https://doi.org/10.1016/S0169-7439%2802%2900051-5">doi:10.1016/S0169-7439(02)00051-5</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simul_data_complete">simul_data_complete</a></code> for highlighting the simulations
parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
simul_data_YX(20,6)                          


if(require(plsdepot)){
dimX &lt;- 6
Astar &lt;- 2
(dataAstar2 &lt;- t(replicate(50,simul_data_YX(dimX,Astar))))
library(plsdepot)
resAstar2 &lt;- plsreg2(dataAstar2[,4:9],dataAstar2[,1:3],comps=5)
resAstar2$Q2
resAstar2$Q2[,4]&gt;0.0975

dimX &lt;- 6
Astar &lt;- 3
(dataAstar3 &lt;- t(replicate(50,simul_data_YX(dimX,Astar))))
library(plsdepot)
resAstar3 &lt;- plsreg2(dataAstar3[,4:9],dataAstar3[,1:3],comps=5)
resAstar3$Q2
resAstar3$Q2[,4]&gt;0.0975

dimX &lt;- 6
Astar &lt;- 4
(dataAstar4 &lt;- t(replicate(50,simul_data_YX(dimX,Astar))))
library(plsdepot)
resAstar4 &lt;- plsreg2(dataAstar4[,5:10],dataAstar4[,1:4],comps=5)
resAstar4$Q2
resAstar4$Q2[,5]&gt;0.0975

rm(list=c("dimX","Astar"))
}


</code></pre>

<hr>
<h2 id='summary.cv.plsRglmmodel'>Summary method for plsRglm models</h2><span id='topic+summary.cv.plsRglmmodel'></span>

<h3>Description</h3>

<p>This function provides a summary method for the class
<code>"cv.plsRglmmodel"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.plsRglmmodel'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.cv.plsRglmmodel_+3A_object">object</code></td>
<td>
<p>an object of the class <code>"cv.plsRglmmodel"</code></p>
</td></tr>
<tr><td><code id="summary.cv.plsRglmmodel_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"summary.cv.plsRmodel"</code> if <code>model</code> is
missing or <code>model="pls"</code>. Otherwise an object of class
<code>"summary.cv.plsRglmmodel"</code>.
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>References</h3>

<p>Nicolas Meyer, Myriam Maumy-Bertrand et
Frédéric Bertrand (2010). Comparing the linear and the
logistic PLS regression with qualitative predictors: application to
allelotyping data. <em>Journal de la Societe Francaise de Statistique</em>,
151(2), pages 1-18.
<a href="http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47">http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Cornell)
XCornell&lt;-Cornell[,1:7]
yCornell&lt;-Cornell[,8]
summary(cv.plsRglm(Y~.,data=Cornell,nt=10,NK=1,
modele="pls-glm-family",family=gaussian(), verbose=FALSE))
rm(list=c("XCornell","yCornell","bbb"))

</code></pre>

<hr>
<h2 id='summary.cv.plsRmodel'>Summary method for plsR models</h2><span id='topic+summary.cv.plsRmodel'></span>

<h3>Description</h3>

<p>This function provides a summary method for the class <code>"cv.plsRmodel"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.plsRmodel'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.cv.plsRmodel_+3A_object">object</code></td>
<td>
<p>an object of the class <code>"cv.plsRmodel"</code></p>
</td></tr>
<tr><td><code id="summary.cv.plsRmodel_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"summary.cv.plsRglmmodel"</code>.
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>References</h3>

<p>Nicolas Meyer, Myriam Maumy-Bertrand et
Frédéric Bertrand (2010). Comparing the linear and the
logistic PLS regression with qualitative predictors: application to
allelotyping data. <em>Journal de la Societe Francaise de Statistique</em>,
151(2), pages 1-18.
<a href="http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47">http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Cornell)
summary(cv.plsR(Y~.,data=Cornell,nt=10,K=6, verbose=FALSE), verbose=FALSE)

</code></pre>

<hr>
<h2 id='summary.plsRglmmodel'>Summary method for plsRglm models</h2><span id='topic+summary.plsRglmmodel'></span>

<h3>Description</h3>

<p>This function provides a summary method for the class <code>"plsRglmmodel"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'plsRglmmodel'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.plsRglmmodel_+3A_object">object</code></td>
<td>
<p>an object of the class <code>"plsRglmmodel"</code></p>
</td></tr>
<tr><td><code id="summary.plsRglmmodel_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>call</code></td>
<td>
<p>function call of plsRglmmodel</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>References</h3>

<p>Nicolas Meyer, Myriam Maumy-Bertrand et
Frédéric Bertrand (2010). Comparing the linear and the
logistic PLS regression with qualitative predictors: application to
allelotyping data. <em>Journal de la Societe Francaise de Statistique</em>,
151(2), pages 1-18.
<a href="http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47">http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Cornell)
XCornell&lt;-Cornell[,1:7]
yCornell&lt;-Cornell[,8]
modplsglm &lt;- plsRglm(yCornell,XCornell,3,modele="pls-glm-gaussian")
class(modplsglm)
summary(modplsglm)
rm(list=c("XCornell","yCornell","modplsglm"))

</code></pre>

<hr>
<h2 id='summary.plsRmodel'>Summary method for plsR models</h2><span id='topic+summary.plsRmodel'></span>

<h3>Description</h3>

<p>This function provides a summary method for the class <code>"plsRmodel"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'plsRmodel'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.plsRmodel_+3A_object">object</code></td>
<td>
<p>an object of the class <code>"plsRmodel"</code></p>
</td></tr>
<tr><td><code id="summary.plsRmodel_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>call</code></td>
<td>
<p>function call of plsRmodel</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>References</h3>

<p>Nicolas Meyer, Myriam Maumy-Bertrand et
Frédéric Bertrand (2010). Comparing the linear and the
logistic PLS regression with qualitative predictors: application to
allelotyping data. <em>Journal de la Societe Francaise de Statistique</em>,
151(2), pages 1-18.
<a href="http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47">http://publications-sfds.math.cnrs.fr/index.php/J-SFdS/article/view/47</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Cornell)
XCornell&lt;-Cornell[,1:7]
yCornell&lt;-Cornell[,8]
modpls &lt;- plsR(yCornell,XCornell,3,modele="pls")
class(modpls)
summary(modpls)
rm(list=c("XCornell","yCornell","modpls"))

</code></pre>

<hr>
<h2 id='tilt.bootpls'>Non-parametric tilted bootstrap for PLS regression models</h2><span id='topic+tilt.bootpls'></span>

<h3>Description</h3>

<p>Provides a wrapper for the bootstrap function <code>tilt.boot</code> from the
<code>boot</code> R package.<br /> Implements non-parametric tilted bootstrap for PLS
regression models by case resampling : the <code>tilt.boot</code> function will
run an initial bootstrap with equal resampling probabilities (if required)
and will use the output of the initial run to find resampling probabilities
which put the value of the statistic at required values. It then runs an
importance resampling bootstrap using the calculated probabilities as the
resampling distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tilt.bootpls(
  object,
  typeboot = "plsmodel",
  statistic = coefs.plsR,
  R = c(499, 250, 250),
  alpha = c(0.025, 0.975),
  sim = "ordinary",
  stype = "i",
  index = 1,
  stabvalue = 1e+06,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tilt.bootpls_+3A_object">object</code></td>
<td>
<p>An object of class <code>plsRmodel</code> to bootstrap</p>
</td></tr>
<tr><td><code id="tilt.bootpls_+3A_typeboot">typeboot</code></td>
<td>
<p>The type of bootstrap. Either (Y,X) boostrap
(<code>typeboot="plsmodel"</code>) or (Y,T) bootstrap
(<code>typeboot="fmodel_np"</code>). Defaults to (Y,T) resampling.</p>
</td></tr>
<tr><td><code id="tilt.bootpls_+3A_statistic">statistic</code></td>
<td>
<p>A function which when applied to data returns a vector
containing the statistic(s) of interest. <code>statistic</code> must take at least
two arguments. The first argument passed will always be the original data.
The second will be a vector of indices, frequencies or weights which define
the bootstrap sample. Further, if predictions are required, then a third
argument is required which would be a vector of the random indices used to
generate the bootstrap predictions. Any further arguments can be passed to
statistic through the <code>...</code> argument.</p>
</td></tr>
<tr><td><code id="tilt.bootpls_+3A_r">R</code></td>
<td>
<p>The number of bootstrap replicates. Usually this will be a single
positive integer. For importance resampling, some resamples may use one set
of weights and others use a different set of weights. In this case <code>R</code>
would be a vector of integers where each component gives the number of
resamples from each of the rows of weights.</p>
</td></tr>
<tr><td><code id="tilt.bootpls_+3A_alpha">alpha</code></td>
<td>
<p>The alpha level to which tilting is required. This parameter is
ignored if <code>R[1]</code> is 0 or if <code>theta</code> is supplied, otherwise it is
used to find the values of <code>theta</code> as quantiles of the initial uniform
bootstrap. In this case <code>R[1]</code> should be large enough that
<code>min(c(alpha, 1-alpha))*R[1] &gt; 5</code>, if this is not the case then a
warning is generated to the effect that the <code>theta</code> are extreme values
and so the tilted output may be unreliable.</p>
</td></tr>
<tr><td><code id="tilt.bootpls_+3A_sim">sim</code></td>
<td>
<p>A character string indicating the type of simulation required.
Possible values are <code>"ordinary"</code> (the default), <code>"balanced"</code>,
<code>"permutation"</code>, or <code>"antithetic"</code>.</p>
</td></tr>
<tr><td><code id="tilt.bootpls_+3A_stype">stype</code></td>
<td>
<p>A character string indicating what the second argument of
<code>statistic</code> represents. Possible values of stype are <code>"i"</code>
(indices - the default), <code>"f"</code> (frequencies), or <code>"w"</code> (weights).</p>
</td></tr>
<tr><td><code id="tilt.bootpls_+3A_index">index</code></td>
<td>
<p>The index of the statistic of interest in the output from
<code>statistic</code>. By default the first element of the output of
<code>statistic</code> is used.</p>
</td></tr>
<tr><td><code id="tilt.bootpls_+3A_stabvalue">stabvalue</code></td>
<td>
<p>Upper bound for the absolute value of the coefficients.</p>
</td></tr>
<tr><td><code id="tilt.bootpls_+3A_...">...</code></td>
<td>
<p>ny further arguments can be passed to <code>statistic</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;boot&quot;.
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>See Also</h3>

<p><code><a href="boot.html#topic+boot">tilt.boot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data(Cornell)
XCornell&lt;-Cornell[,1:7]
yCornell&lt;-Cornell[,8]

set.seed(1385)
Cornell.tilt.boot &lt;- tilt.bootpls(plsR(yCornell,XCornell,1), statistic=coefs.plsR, 
typeboot="fmodel_np", R=c(499, 100, 100), alpha=c(0.025, 0.975), sim="ordinary", 
stype="i", index=1)
Cornell.tilt.boot
str(Cornell.tilt.boot)

boxplots.bootpls(Cornell.tilt.boot,indices=2:7)

rm(Cornell.tilt.boot)

## End(Not run)

</code></pre>

<hr>
<h2 id='tilt.bootplsglm'>Non-parametric tilted bootstrap for PLS generalized linear regression models</h2><span id='topic+tilt.bootplsglm'></span>

<h3>Description</h3>

<p>Provides a wrapper for the bootstrap function <code>tilt.boot</code> from the
<code>boot</code> R package.<br /> Implements non-parametric tilted bootstrap for PLS
generalized linear regression models by case resampling : the
<code>tilt.boot</code> function will run an initial bootstrap with equal
resampling probabilities (if required) and will use the output of the
initial run to find resampling probabilities which put the value of the
statistic at required values. It then runs an importance resampling
bootstrap using the calculated probabilities as the resampling distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tilt.bootplsglm(
  object,
  typeboot = "fmodel_np",
  statistic = coefs.plsRglm,
  R = c(499, 250, 250),
  alpha = c(0.025, 0.975),
  sim = "ordinary",
  stype = "i",
  index = 1,
  stabvalue = 1e+06,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tilt.bootplsglm_+3A_object">object</code></td>
<td>
<p>An object of class <code>plsRbetamodel</code> to bootstrap</p>
</td></tr>
<tr><td><code id="tilt.bootplsglm_+3A_typeboot">typeboot</code></td>
<td>
<p>The type of bootstrap. Either (Y,X) boostrap
(<code>typeboot="plsmodel"</code>) or (Y,T) bootstrap
(<code>typeboot="fmodel_np"</code>). Defaults to (Y,T) resampling.</p>
</td></tr>
<tr><td><code id="tilt.bootplsglm_+3A_statistic">statistic</code></td>
<td>
<p>A function which when applied to data returns a vector
containing the statistic(s) of interest. <code>statistic</code> must take at least
two arguments. The first argument passed will always be the original data.
The second will be a vector of indices, frequencies or weights which define
the bootstrap sample. Further, if predictions are required, then a third
argument is required which would be a vector of the random indices used to
generate the bootstrap predictions. Any further arguments can be passed to
statistic through the <code>...</code> argument.</p>
</td></tr>
<tr><td><code id="tilt.bootplsglm_+3A_r">R</code></td>
<td>
<p>The number of bootstrap replicates. Usually this will be a single
positive integer. For importance resampling, some resamples may use one set
of weights and others use a different set of weights. In this case <code>R</code>
would be a vector of integers where each component gives the number of
resamples from each of the rows of weights.</p>
</td></tr>
<tr><td><code id="tilt.bootplsglm_+3A_alpha">alpha</code></td>
<td>
<p>The alpha level to which tilting is required. This parameter is
ignored if <code>R[1]</code> is 0 or if <code>theta</code> is supplied, otherwise it is
used to find the values of <code>theta</code> as quantiles of the initial uniform
bootstrap. In this case <code>R[1]</code> should be large enough that
<code>min(c(alpha, 1-alpha))*R[1] &gt; 5</code>, if this is not the case then a
warning is generated to the effect that the <code>theta</code> are extreme values
and so the tilted output may be unreliable.</p>
</td></tr>
<tr><td><code id="tilt.bootplsglm_+3A_sim">sim</code></td>
<td>
<p>A character string indicating the type of simulation required.
Possible values are <code>"ordinary"</code> (the default), <code>"balanced"</code>,
<code>"permutation"</code>, or <code>"antithetic"</code>.</p>
</td></tr>
<tr><td><code id="tilt.bootplsglm_+3A_stype">stype</code></td>
<td>
<p>A character string indicating what the second argument of
<code>statistic</code> represents. Possible values of stype are <code>"i"</code>
(indices - the default), <code>"f"</code> (frequencies), or <code>"w"</code> (weights).</p>
</td></tr>
<tr><td><code id="tilt.bootplsglm_+3A_index">index</code></td>
<td>
<p>The index of the statistic of interest in the output from
<code>statistic</code>. By default the first element of the output of
<code>statistic</code> is used.</p>
</td></tr>
<tr><td><code id="tilt.bootplsglm_+3A_stabvalue">stabvalue</code></td>
<td>
<p>Upper bound for the absolute value of the coefficients.</p>
</td></tr>
<tr><td><code id="tilt.bootplsglm_+3A_...">...</code></td>
<td>
<p>ny further arguments can be passed to <code>statistic</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;boot&quot;.
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="https://fbertran.github.io/homepage/">https://fbertran.github.io/homepage/</a>
</p>


<h3>See Also</h3>

<p><code><a href="boot.html#topic+boot">tilt.boot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(aze_compl)
Xaze_compl&lt;-aze_compl[,2:34]
yaze_compl&lt;-aze_compl$y

dataset &lt;- cbind(y=yaze_compl,Xaze_compl)

# Lazraq-Cleroux PLS bootstrap Classic

aze_compl.tilt.boot &lt;- tilt.bootplsglm(plsRglm(yaze_compl,Xaze_compl,3, 
modele="pls-glm-logistic", family=NULL), statistic=coefs.plsRglm, R=c(499, 100, 100), 
alpha=c(0.025, 0.975), sim="ordinary", stype="i", index=1)
boxplots.bootpls(aze_compl.tilt.boot,1:2)

aze_compl.tilt.boot2 &lt;- tilt.bootplsglm(plsRglm(yaze_compl,Xaze_compl,3, 
modele="pls-glm-logistic"), statistic=coefs.plsRglm, R=c(499, 100, 100), 
alpha=c(0.025, 0.975), sim="ordinary", stype="i", index=1)
boxplots.bootpls(aze_compl.tilt.boot2,1:2)

aze_compl.tilt.boot3 &lt;- tilt.bootplsglm(plsRglm(yaze_compl,Xaze_compl,3, 
modele="pls-glm-family", family=binomial), statistic=coefs.plsRglm, R=c(499, 100, 100), 
alpha=c(0.025, 0.975), sim="ordinary", stype="i", index=1)
boxplots.bootpls(aze_compl.tilt.boot3,1:2)


# PLS bootstrap balanced

aze_compl.tilt.boot4 &lt;- tilt.bootplsglm(plsRglm(yaze_compl,Xaze_compl,3, 
modele="pls-glm-logistic"), statistic=coefs.plsRglm, R=c(499, 100, 100), 
alpha=c(0.025, 0.975), sim="balanced", stype="i", index=1)
boxplots.bootpls(aze_compl.tilt.boot4,1:2)


</code></pre>

<hr>
<h2 id='XbordeauxNA'>Incomplete dataset for the quality of wine dataset</h2><span id='topic+XbordeauxNA'></span>

<h3>Description</h3>

<p>Quality of Bordeaux wines (<code>Quality</code>) and four potentially predictive
variables (<code>Temperature</code>, <code>Sunshine</code>, <code>Heat</code> and
<code>Rain</code>).<br /> The value of Temperature for the first observation was
remove from the matrix of predictors on purpose.
</p>


<h3>Format</h3>

<p>A data frame with 34 observations on the following 4 variables.
</p>
 <dl>
<dt>Temperature</dt><dd><p>a numeric vector</p>
</dd>
<dt>Sunshine</dt><dd><p>a numeric vector</p>
</dd> <dt>Heat</dt><dd><p>a numeric
vector</p>
</dd> <dt>Rain</dt><dd><p>a numeric vector</p>
</dd> </dl>



<h3>Source</h3>

<p>P. Bastien, V. Esposito-Vinzi, and M. Tenenhaus. (2005). PLS
generalised linear regression. <em>Computational Statistics &amp; Data
Analysis</em>, 48(1):17-46.
</p>


<h3>References</h3>

<p>M. Tenenhaus. (2005). La regression logistique PLS. In J.-J.
Droesbeke, M. Lejeune, and G. Saporta, editors, Modeles statistiques pour
donnees qualitatives. Editions Technip, Paris.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(XbordeauxNA)
str(XbordeauxNA)

</code></pre>

<hr>
<h2 id='XpineNAX21'>Incomplete dataset from the pine caterpillars example</h2><span id='topic+XpineNAX21'></span>

<h3>Description</h3>

<p>The caterpillar dataset was extracted from a 1973 study on pine
processionary caterpillars. It assesses the influence of some forest
settlement characteristics on the development of caterpillar colonies. There
are k=10 potentially explanatory variables defined on n=33 areas.<br /> The
value of x2 for the first observation was remove from the matrix of
predictors on purpose.
</p>


<h3>Format</h3>

<p>A data frame with 33 observations on the following 10 variables and
one missing value.  </p>
 <dl>
<dt>x1</dt><dd><p>altitude (in meters)</p>
</dd>
<dt>x2</dt><dd><p>slope (en degrees)</p>
</dd> <dt>x3</dt><dd><p>number of pines in
the area</p>
</dd> <dt>x4</dt><dd><p>height (in meters) of the tree sampled at the
center of the area</p>
</dd> <dt>x5</dt><dd><p>diameter (in meters) of the tree
sampled at the center of the area</p>
</dd> <dt>x6</dt><dd><p>index of the settlement
density</p>
</dd> <dt>x7</dt><dd><p>orientation of the area (from 1 if southbound to
2 otherwise)</p>
</dd> <dt>x8</dt><dd><p>height (in meters) of the dominant tree</p>
</dd>
<dt>x9</dt><dd><p>number of vegetation strata</p>
</dd> <dt>x10</dt><dd><p>mix
settlement index (from 1 if not mixed to 2 if mixed)</p>
</dd> </dl>



<h3>Details</h3>

<p>These caterpillars got their names from their habit of moving over the
ground in incredibly long head-to-tail processions when leaving their nest
to create a new colony.<br /> The <code>XpineNAX21</code> is a dataset with a missing
value for testing purpose.
</p>


<h3>Source</h3>

<p>Tomassone R., Audrain S., Lesquoy-de Turckeim E., Millier C. (1992).
&ldquo;La régression, nouveaux regards sur une ancienne
méthode statistique&rdquo;, INRA,
<em>Actualités Scientifiques et Agronomiques</em>, Masson,
Paris.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(XpineNAX21)
str(XpineNAX21)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
