<!DOCTYPE html><html><head><title>Help for package storr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {storr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#driver_redis_api'><p>Defunct functions</p></a></li>
<li><a href='#driver_remote'><p>Remote storr</p></a></li>
<li><a href='#encode64'><p>Base64 encoding and decoding</p></a></li>
<li><a href='#fetch_hook_read'><p>Hook to fetch a resource from a file.</p></a></li>
<li><a href='#join_key_namespace'><p>Recycle key and namespace</p></a></li>
<li><a href='#storr'><p>Object cache</p></a></li>
<li><a href='#storr_dbi'><p>DBI storr driver</p></a></li>
<li><a href='#storr_environment'><p>Environment object cache driver</p></a></li>
<li><a href='#storr_external'><p>Storr that looks for external resources</p></a></li>
<li><a href='#storr_multistorr'><p>Storr with multiple storage drivers</p></a></li>
<li><a href='#storr_rds'><p>rds object cache driver</p></a></li>
<li><a href='#test_driver'><p>Test a storr driver</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Simple Key Value Stores</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.5</td>
</tr>
<tr>
<td>Description:</td>
<td>Creates and manages simple key-value stores.  These can
    use a variety of approaches for storing the data.  This package
    implements the base methods and support for file system, in-memory
    and DBI-based database stores.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/richfitz/storr">https://github.com/richfitz/storr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/richfitz/storr/issues">https://github.com/richfitz/storr/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>R6 (&ge; 2.1.0), digest</td>
</tr>
<tr>
<td>Suggests:</td>
<td>DBI (&ge; 0.6), RSQLite (&ge; 1.1-2), RPostgres, knitr, mockr,
parallel, progress, rbenchmark, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-12-01 14:24:18 UTC; rich</td>
</tr>
<tr>
<td>Author:</td>
<td>Rich FitzJohn [aut, cre],
  William Michael Landau
    <a href="https://orcid.org/0000-0003-1878-3253"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Rich FitzJohn &lt;rich.fitzjohn@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-12-01 17:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='driver_redis_api'>Defunct functions</h2><span id='topic+driver_redis_api'></span><span id='topic+storr_redis_api'></span>

<h3>Description</h3>

<p>Defunct functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>driver_redis_api(...)

storr_redis_api(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="driver_redis_api_+3A_...">...</code></td>
<td>
<p>parameters (now all dropped as dots)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The redis functions (<code>driver_redis_api</code> and
<code>storr_redis_api</code>) have been moved out of this package and
into Redis.  I don't believe anyone is using them at the time of
the move so this is being done fairly abruptly - this is
unfortunate, but necessary to avoid a circular dependency!  The
new functions are simply <code>redux::driver_redis_api</code> and
<code>redux::storr_redis_api</code>, along with a helper function
<code>redux::storr_hiredis</code> which also creates the connection.
</p>

<hr>
<h2 id='driver_remote'>Remote storr</h2><span id='topic+driver_remote'></span>

<h3>Description</h3>

<p>Create a storr that keeps rds-serialised objects on a remote
location.  This is the abstract interface (which does not do
anything useful) but which can be used with file operation driver
to store files elsewhere.  This is not intended for end-user use
so there is no <code>storr_remote</code> function.  Instead this
function is designed to support external packages that implement
the details.  For a worked example, see the package tests
(<code>helper-remote.R</code>).  In the current implementation these
build off of the <code><a href="#topic+driver_rds">driver_rds</a></code> driver by copying files
to some remote location.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>driver_remote(ops, ..., path_local = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="driver_remote_+3A_ops">ops</code></td>
<td>
<p>A file operations object.  See tests for now to see
what is required to implement one.</p>
</td></tr>
<tr><td><code id="driver_remote_+3A_...">...</code></td>
<td>
<p>Arguments to pass through to <code><a href="#topic+driver_rds">driver_rds</a></code>,
including <code>compress</code>, <code>mangle_key</code>,
<code>mangle_key_pad</code> and <code>hash_algorithm</code>.</p>
</td></tr>
<tr><td><code id="driver_remote_+3A_path_local">path_local</code></td>
<td>
<p>Path to a local cache.  This can be left as
<code>NULL</code>, in which case a per-session cache will be used.
Alternatively, explicitly set to a path and the cache can be
reused over sessions.  Only storr <em>values</em> (i.e., objects)
are cached - the key-to-value mapping is always fetched from the
remote storage.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rich FitzJohn
</p>

<hr>
<h2 id='encode64'>Base64 encoding and decoding</h2><span id='topic+encode64'></span><span id='topic+decode64'></span>

<h3>Description</h3>

<p>Base64 encoding.  By default uses the RFC 4648 dialect (file/url
encoding) where characters 62 and 63 are &quot;-&quot; and &quot;_&quot;.  Pass in &quot;+&quot;
and &quot;/&quot; to get the RFC 1421 variant (as in other R packages that
do base64 encoding).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>encode64(x, char62 = "-", char63 = "_", pad = TRUE)

decode64(x, char62 = "-", char63 = "_", error = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="encode64_+3A_x">x</code></td>
<td>
<p>A string or vector of strings to encode/decode</p>
</td></tr>
<tr><td><code id="encode64_+3A_char62">char62</code></td>
<td>
<p>Character to use for the 62nd index</p>
</td></tr>
<tr><td><code id="encode64_+3A_char63">char63</code></td>
<td>
<p>Character to use for the 63rd index</p>
</td></tr>
<tr><td><code id="encode64_+3A_pad">pad</code></td>
<td>
<p>Logical, indicating if strings should be padded with
<code>=</code> characters (as RFC 4648 requires)</p>
</td></tr>
<tr><td><code id="encode64_+3A_error">error</code></td>
<td>
<p>Throw an error if the decoding fails.  If
<code>FALSE</code> then <code>NA_character_</code> values are returned for
failures.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- encode64("hello")
x
decode64(x)

# Encoding things into filename-safe strings is the reason for
# this function:
encode64("unlikely/to be @ valid filename")
</code></pre>

<hr>
<h2 id='fetch_hook_read'>Hook to fetch a resource from a file.</h2><span id='topic+fetch_hook_read'></span>

<h3>Description</h3>

<p>Hook to fetch a resource from a file, for use with
driver_external.  We take two functions as arguments: the first
converts a key/namespace pair into a filename, and the second
reads from that filename.  Because many R functions support
reading from URLs <code>fetch_hook_read</code> can be used to read from
remote resources.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fetch_hook_read(fpath, fread)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fetch_hook_read_+3A_fpath">fpath</code></td>
<td>
<p>Function to convert <code>key, namespace</code> into a file
path</p>
</td></tr>
<tr><td><code id="fetch_hook_read_+3A_fread">fread</code></td>
<td>
<p>Function for converting <code>filename</code> into an R
pobject</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more information about using this, see
<code><a href="#topic+storr_external">storr_external</a></code> (this can be used as a
<code>fetch_hook</code> argument) and the vignette:
<code>vignette("external")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hook &lt;- fetch_hook_read(
    function(key, namespace) paste0(key, ".csv"),
    function(filename) read.csv(filename, stringsAsFactors = FALSE))
</code></pre>

<hr>
<h2 id='join_key_namespace'>Recycle key and namespace</h2><span id='topic+join_key_namespace'></span>

<h3>Description</h3>

<p>Utility function for driver authors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>join_key_namespace(key, namespace)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="join_key_namespace_+3A_key">key</code></td>
<td>
<p>A vector of keys</p>
</td></tr>
<tr><td><code id="join_key_namespace_+3A_namespace">namespace</code></td>
<td>
<p>A vector of namespace</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This exists to join, predictably, keys and namespaces for
operations like <code>mget</code>.  Given a vector or scalar for
<code>key</code> and <code>namespace</code> we work out what the required
length is and recycle <code>key</code> and <code>namespace</code> to the
appropriate length.
</p>


<h3>Value</h3>

<p>A list with elements <code>n</code>, <code>key</code> and <code>namespace</code>
</p>

<hr>
<h2 id='storr'>Object cache</h2><span id='topic+storr'></span>

<h3>Description</h3>

<p>Create an object cache; a &quot;storr&quot;.  A storr is a simple key-value
store where the actual content is stored in a content-addressible
way (so that duplicate objects are only stored once) and with a
caching layer so that repeated lookups are fast even if the
underlying storage driver is slow.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>storr(driver, default_namespace = "objects")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="storr_+3A_driver">driver</code></td>
<td>
<p>A driver object</p>
</td></tr>
<tr><td><code id="storr_+3A_default_namespace">default_namespace</code></td>
<td>
<p>Default namespace to store objects in.
By default <code>"objects"</code> is used, but this might be useful to
have two diffent <code>storr</code> objects pointing at the same
underlying storage, but storing things in different namespaces.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To create a storr you need to provide a &quot;driver&quot; object.  There
are three in this package: <code><a href="#topic+driver_environment">driver_environment</a></code> for
ephemeral in-memory storage, <code><a href="#topic+driver_rds">driver_rds</a></code> for
serialized storage to disk, and <code><a href="#topic+driver_dbi">driver_dbi</a></code> for use
with DBI-compliant database interfaces.  The <code>redux</code> package
(on CRAN) provides a storr driver that uses Redis.
</p>
<p>There are convenience functions (e.g.,
<code><a href="#topic+storr_environment">storr_environment</a></code> and <code><a href="#topic+storr_rds">storr_rds</a></code>) that
may be more convenient to use than this function.
</p>
<p>Once a storr has been made it provides a number of methods.
Because storr uses <code>R6</code> (<code><a href="R6.html#topic+R6Class">R6Class</a></code>) objects, each
method is accessed by using <code>$</code> on a storr object (see the
examples).  The methods are described below in the &quot;Methods&quot;
section.
</p>
<p>The <code>default_namespace</code> affects all methods of the storr
object that refer to namespaces; if a namespace is not given, then
the action (get, set, del, list, import, export) will affect the
<code>default_namespace</code>.  By default this is <code>"objects"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt><code>destroy</code></dt><dd>
<p>Totally destroys the storr by telling the driver to destroy all the data and then deleting the driver.  This will remove all data and cannot be undone.
</p>
<p><em>Usage:</em>
<code>destroy()</code>
</p>
</dd>
<dt><code>flush_cache</code></dt><dd>
<p>Flush the temporary cache of objects that accumulates as the storr is used.  Should not need to be called often.
</p>
<p><em>Usage:</em>
<code>flush_cache()</code>
</p>
</dd>
<dt><code>set</code></dt><dd>
<p>Set a key to a value.
</p>
<p><em>Usage:</em>
<code>set(key, value, namespace = self$default_namespace, use_cache = TRUE)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>key</code>:   The key name.  Can be any string.

</p>
</li>
<li><p><code>value</code>:   Any R object to store.  The object will generally be serialized (this is not actually true for the environment storr) so only objects that would usually be expected to survive a <code>saveRDS</code>/<code>readRDS</code> roundtrip will work.  This excludes Rcpp modules objects, external pointers, etc.  But any &quot;normal&quot; R object will work fine.

</p>
</li>
<li><p><code>namespace</code>:   An optional namespace.  By default the default namespace that the storr was created with will be used (by default that is &quot;objects&quot;).  Different namespaces allow different types of objects to be stored without risk of names colliding.  Use of namespaces is optional, but if used they must be a string.

</p>
</li>
<li><p><code>use_cache</code>:   Use the internal cache to avoid reading or writing to the underlying storage if the data has already been seen (i.e., we have seen the hash of the object before).

</p>
</li></ul>

<p><em>Value</em>:
Invisibly, the hash of the saved object.
</p>
</dd>
<dt><code>set_by_value</code></dt><dd>
<p>Like <code>set</code> but saves the object with a key that is the same as the hash of the object.  Equivalent to <code>$set(digest::digest(value), value)</code>.
</p>
<p><em>Usage:</em>
<code>set_by_value(value, namespace = self$default_namespace, use_cache = TRUE)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>value</code>:   An R object to save, with the same limitations as <code>set</code>.

</p>
</li>
<li><p><code>namespace</code>:   Optional namespace to save the key into.

</p>
</li>
<li><p><code>use_cache</code>:   Use the internal cache to avoid reading or writing to the underlying storage if the data has already been seen (i.e., we have seen the hash of the object before).

</p>
</li></ul>

</dd>
<dt><code>get</code></dt><dd>
<p>Retrieve an object from the storr.  If the requested value is not found then a <code>KeyError</code> will be raised (an R error, but can be caught with <code>tryCatch</code>; see the &quot;storr&quot; vignette).
</p>
<p><em>Usage:</em>
<code>get(key, namespace = self$default_namespace, use_cache = TRUE)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>key</code>:   The name of the key to get.

</p>
</li>
<li><p><code>namespace</code>:   Optional namespace to look for the key within.

</p>
</li>
<li><p><code>use_cache</code>:   Use the internal cache to avoid reading or writing to the underlying storage if the data has already been seen (i.e., we have seen the hash of the object before).

</p>
</li></ul>

</dd>
<dt><code>get_hash</code></dt><dd>
<p>Retrieve the hash of an object stored in the storr (rather than the object itself).
</p>
<p><em>Usage:</em>
<code>get_hash(key, namespace = self$default_namespace)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>key</code>:   The name of the key to get.

</p>
</li>
<li><p><code>namespace</code>:   Optional namespace to look for the key within.

</p>
</li></ul>

</dd>
<dt><code>del</code></dt><dd>
<p>Delete an object fom the storr.
</p>
<p><em>Usage:</em>
<code>del(key, namespace = self$default_namespace)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>key</code>:   A vector of names of keys

</p>
</li>
<li><p><code>namespace</code>:   The namespace of the key.

</p>
</li></ul>

<p><em>Value</em>:
A logical vector the same length as the recycled length of key/namespace, with each element being <code>TRUE</code> if an object was deleted, <code>FALSE</code> otherwise.
</p>
</dd>
<dt><code>duplicate</code></dt><dd>
<p>Duplicate the value of a set of keys into a second set of keys. Because the value stored against a key is just the hash of its content, this operation is very efficient - it does not make a copy of the data, just the pointer to the data (for more details see the storr vignette which explains the storage model in more detail).  Multiple keys (and/or namespaces) can be provided, with keys and nmespaces recycled as needed.  However, the number of source and destination keys must be the same.  The order of operation is not defined, so if the sets of keys are overlapping it is undefined behaviour.
</p>
<p><em>Usage:</em>
<code>duplicate(key_src, key_dest, namespace = self$default_namespace,
      namespace_src = namespace, namespace_dest = namespace)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>key_src</code>:   The source key (or vector of keys)

</p>
</li>
<li><p><code>key_dest</code>:   The destination key

</p>
</li>
<li><p><code>namespace</code>:   The namespace to copy keys within (used only of <code>namespace_src</code> and <code>namespace_dest</code> are not provided

</p>
</li>
<li><p><code>namespace_src</code>:   The source namespace - use this where keys are duplicated across namespaces.

</p>
</li>
<li><p><code>namespace_dest</code>:   The destination namespace - use this where keys are duplicated across namespaces.

</p>
</li></ul>

</dd>
<dt><code>fill</code></dt><dd>
<p>Set one or more keys (potentially across namespaces) to the same value, without duplication effort serialisation, or duplicating data.
</p>
<p><em>Usage:</em>
<code>fill(key, value, namespace = self$default_namespace, use_cache = TRUE)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>key</code>:   A vector of keys to get; zero to many valid keys

</p>
</li>
<li><p><code>value</code>:   A single value to set all keys to

</p>
</li>
<li><p><code>namespace</code>:   A vector of namespaces (either a single namespace or a vector)

</p>
</li>
<li><p><code>use_cache</code>:   Use the internal cache to avoid reading or writing to the underlying storage if the data has already been seen (i.e., we have seen the hash of the object before).

</p>
</li></ul>

</dd>
<dt><code>clear</code></dt><dd>
<p>Clear a storr.  This function might be slow as it will iterate over each key.  Future versions of storr might allow drivers to implement a bulk clear method that will allow faster clearing.
</p>
<p><em>Usage:</em>
<code>clear(namespace = self$default_namespace)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>namespace</code>:   A namespace, to clear a single namespace, or <code>NULL</code> to clear all namespaces.

</p>
</li></ul>

</dd>
<dt><code>exists</code></dt><dd>
<p>Test if a key exists within a namespace
</p>
<p><em>Usage:</em>
<code>exists(key, namespace = self$default_namespace)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>key</code>:   A vector of names of keys

</p>
</li>
<li><p><code>namespace</code>:   The namespace of the key.

</p>
</li></ul>

<p><em>Value</em>:
A logical vector the same length as the recycled length of key/namespace, with each element being <code>TRUE</code> if the object exists and <code>FALSE</code> otherwise.
</p>
</dd>
<dt><code>exists_object</code></dt><dd>
<p>Test if an object with a given hash exists within the storr
</p>
<p><em>Usage:</em>
<code>exists_object(hash)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>hash</code>:   Hash to test

</p>
</li></ul>

</dd>
<dt><code>mset</code></dt><dd>
<p>Set multiple elements at once
</p>
<p><em>Usage:</em>
<code>mset(key, value, namespace = self$default_namespace, use_cache = TRUE)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>key</code>:   A vector of keys to set; zero to many valid keys

</p>
</li>
<li><p><code>value</code>:   A vector of values

</p>
</li>
<li><p><code>namespace</code>:   A vector of namespaces (either a single namespace or a vector)

</p>
</li>
<li><p><code>use_cache</code>:   Use the internal cache to avoid reading or writing to the underlying storage if the data has already been seen (i.e., we have seen the hash of the object before).

</p>
</li></ul>

<p><em>Details:</em>
The arguments <code>key</code> and <code>namespace</code> are recycled such that either can be given as a scalar if the other is a vector. Other recycling is not allowed.
</p>
</dd>
<dt><code>mget</code></dt><dd>
<p>Get multiple elements at once
</p>
<p><em>Usage:</em>
<code>mget(key, namespace = self$default_namespace, use_cache = TRUE,
      missing = NULL)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>key</code>:   A vector of keys to get; zero to many valid keys

</p>
</li>
<li><p><code>namespace</code>:   A vector of namespaces (either a single namespace or a vector)

</p>
</li>
<li><p><code>use_cache</code>:   Use the internal cache to avoid reading or writing to the underlying storage if the data has already been seen (i.e., we have seen the hash of the object before).

</p>
</li>
<li><p><code>missing</code>:   Value to use for missing elements; by default <code>NULL</code> will be used.  IF <code>NULL</code> is a value that you might have stored in the storr you might want to use a different value here to distinguish &quot;missing&quot; from &quot;set to NULL&quot;.  In addition, the <code>missing</code> attribute will indicate which values were missing.

</p>
</li></ul>

<p><em>Details:</em>
The arguments <code>key</code> and <code>namespace</code> are recycled such that either can be given as a scalar if the other is a vector. Other recycling is not allowed.
</p>
<p><em>Value</em>:
A list with a length of the recycled length of <code>key</code> and <code>namespace</code>.  If any elements are missing, then an attribute <code>missing</code> will indicate the elements that are missing (this will be an integer vector with the indices of values were not found in the storr).
</p>
</dd>
<dt><code>mset_by_value</code></dt><dd>
<p>Set multiple elements at once, by value.  A cross between <code>mset</code> and <code>set_by_value</code>.
</p>
<p><em>Usage:</em>
<code>mset_by_value(value, namespace = self$default_namespace, use_cache = TRUE)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>value</code>:   A list or vector of values to set into the storr.

</p>
</li>
<li><p><code>namespace</code>:   A vector of namespaces

</p>
</li>
<li><p><code>use_cache</code>:   Use the internal cache to avoid reading or writing to the underlying storage if the data has already been seen (i.e., we have seen the hash of the object before).

</p>
</li></ul>

</dd>
<dt><code>gc</code></dt><dd>
<p>Garbage collect the storr.  Because keys do not directly map to objects, but instead map to hashes which map to objects, it is possible that hash/object pairs can persist with nothing pointing at them.  Running <code>gc</code> will remove these objects from the storr.
</p>
<p><em>Usage:</em>
<code>gc()</code>
</p>
</dd>
<dt><code>get_value</code></dt><dd>
<p>Get the content of an object given its hash.
</p>
<p><em>Usage:</em>
<code>get_value(hash, use_cache = TRUE)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>hash</code>:   The hash of the object to retrieve.

</p>
</li>
<li><p><code>use_cache</code>:   Use the internal cache to avoid reading or writing to the underlying storage if the data has already been seen (i.e., we have seen the hash of the object before).

</p>
</li></ul>

<p><em>Value</em>:
The object if it is present, otherwise throw a <code>HashError</code>.
</p>
</dd>
<dt><code>set_value</code></dt><dd>
<p>Add an object value, but don't add a key.  You will not need to use this very often, but it is used internally.
</p>
<p><em>Usage:</em>
<code>set_value(value, use_cache = TRUE)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>value</code>:   An R object to set.

</p>
</li>
<li><p><code>use_cache</code>:   Use the internal cache to avoid reading or writing to the underlying storage if the data has already been seen (i.e., we have seen the hash of the object before).

</p>
</li></ul>

<p><em>Value</em>:
Invisibly, the hash of the object.
</p>
</dd>
<dt><code>mset_value</code></dt><dd>
<p>Add a vector of object values, but don't add keys.  You will not need to use this very often, but it is used internally.
</p>
<p><em>Usage:</em>
<code>mset_value(values, use_cache = TRUE)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>values</code>:   A list of R objects to set

</p>
</li>
<li><p><code>use_cache</code>:   Use the internal cache to avoid reading or writing to the underlying storage if the data has already been seen (i.e., we have seen the hash of the object before).

</p>
</li></ul>

</dd>
<dt><code>list</code></dt><dd>
<p>List all keys stored in a namespace.
</p>
<p><em>Usage:</em>
<code>list(namespace = self$default_namespace)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>namespace</code>:   The namespace to list keys within.

</p>
</li></ul>

<p><em>Value</em>:
A sorted character vector (possibly zero-length).
</p>
</dd>
<dt><code>list_hashes</code></dt><dd>
<p>List all hashes stored in the storr
</p>
<p><em>Usage:</em>
<code>list_hashes()</code>
</p>
<p><em>Value</em>:
A sorted character vector (possibly zero-length).
</p>
</dd>
<dt><code>list_namespaces</code></dt><dd>
<p>List all namespaces known to the database
</p>
<p><em>Usage:</em>
<code>list_namespaces()</code>
</p>
<p><em>Value</em>:
A sorted character vector (possibly zero-length).
</p>
</dd>
<dt><code>import</code></dt><dd>
<p>Import R objects from an environment.
</p>
<p><em>Usage:</em>
<code>import(src, list = NULL, namespace = self$default_namespace,
      skip_missing = FALSE)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>src</code>:   Object to import objects from; can be a list, environment or another storr.

</p>
</li>
<li><p><code>list</code>:   Names of of objects to import (or <code>NULL</code> to import all objects in <code>envir</code>.  If given it must be a character vector.  If named, the names of the character vector will be the names of the objects as created in the storr.

</p>
</li>
<li><p><code>namespace</code>:   Namespace to get objects from, and to put objects into.  If <code>NULL</code>, all namespaces from <code>src</code> will be imported. If named, then the same rule is followed as <code>list</code>; <code>namespace = c(a = b)</code> will import the contents of namespace <code>b</code> as namespace <code>a</code>.

</p>
</li>
<li><p><code>skip_missing</code>:   Logical, indicating if missing keys (specified in <code>list</code>) should be skipped over, rather than being treated as an error (the default).

</p>
</li></ul>

</dd>
<dt><code>export</code></dt><dd>
<p>Export objects from the storr into something else.
</p>
<p><em>Usage:</em>
<code>export(dest, list = NULL, namespace = self$default_namespace,
      skip_missing = FALSE)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>dest</code>:   A target destination to export objects to; can be a list, environment, or another storr.  Use <code>list()</code> to export to a brand new list, or use <code>as.list(object)</code> for a shorthand.

</p>
</li>
<li><p><code>list</code>:   Names of objects to export, with the same rules as <code>list</code> in <code>$import</code>.

</p>
</li>
<li><p><code>namespace</code>:   Namespace to get objects from, and to put objects into.  If <code>NULL</code>, then this will export namespaces from this (source) storr into the destination; if there is more than one namespace,this is only possible if <code>dest</code> is a storr (otherwise there will be an error).

</p>
</li>
<li><p><code>skip_missing</code>:   Logical, indicating if missing keys (specified in <code>list</code>) should be skipped over, rather than being treated as an error (the default).

</p>
</li></ul>

<p><em>Value</em>:
Invisibly, <code>dest</code>, which allows use of <code>e &lt;- st$export(new.env())</code> and <code>x &lt;- st$export(list())</code>.
</p>
</dd>
<dt><code>archive_export</code></dt><dd>
<p>Export objects from the storr into a special &quot;archive&quot; storr, which is an <code><a href="#topic+storr_rds">storr_rds</a></code> with name mangling turned on (which encodes keys with base64 so that they do not voilate filesystem naming conventions).
</p>
<p><em>Usage:</em>
<code>archive_export(path, names = NULL, namespace = NULL)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>path</code>:   Path to create the storr at; can exist already.

</p>
</li>
<li><p><code>names</code>:   As for <code>$export</code>

</p>
</li>
<li><p><code>namespace</code>:   Namespace to get objects from.  If <code>NULL</code>, then exports all namespaces found in this (source) storr.

</p>
</li></ul>

</dd>
<dt><code>archive_import</code></dt><dd>
<p>Inverse of <code>archive_export</code>; import objects from a storr that was created by <code>archive_export</code>.
</p>
<p><em>Usage:</em>
<code>archive_import(path, names = NULL, namespace = NULL)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>path</code>:   Path of the exported storr.

</p>
</li>
<li><p><code>names</code>:   As for <code>$import</code>

</p>
</li>
<li><p><code>namespace</code>:   Namespace to import objects into.  If <code>NULL</code>, then imports all namespaces from the source storr.

</p>
</li></ul>

</dd>
<dt><code>index_export</code></dt><dd>
<p>Generate a data.frame with an index of objects present in a storr. This can be saved (for an rds storr) in lieu of the keys/ directory and re-imported with <code>index_import</code>.  It will provide a more version control friendly export of the data in a storr.
</p>
<p><em>Usage:</em>
<code>index_export(namespace = NULL)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>namespace</code>:   Optional character vector of namespaces to export.  The default is to export all namespaces.

</p>
</li></ul>

</dd>
<dt><code>index_import</code></dt><dd>
<p>Import an index.
</p>
<p><em>Usage:</em>
<code>index_import(index)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li><p><code>index</code>:   Must be a data.frame with columns 'namespace', 'key' and 'hash' (in any order).  It is an error if not all hashes are present in the storr.

</p>
</li></ul>

</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>st &lt;- storr(driver_environment())
## Set "mykey" to hold the mtcars dataset:
st$set("mykey", mtcars)
## and get the object:
st$get("mykey")
## List known keys:
st$list()
## List hashes
st$list_hashes()
## List keys in another namespace:
st$list("namespace2")
## We can store things in other namespaces:
st$set("x", mtcars, "namespace2")
st$set("y", mtcars, "namespace2")
st$list("namespace2")
## Duplicate data do not cause duplicate storage: despite having three
## keys we only have one bit of data:
st$list_hashes()
st$del("mykey")

## Storr objects can be created that have a default namespace that is
## not "objects" by using the \code{default_namespace} argument (this
## one also points at the same memory as the first storr).
st2 &lt;- storr(driver_environment(st$driver$envir),
             default_namespace = "namespace2")
## All functions now use "namespace2" as the default namespace:
st2$list()
st2$del("x")
st2$del("y")
</code></pre>

<hr>
<h2 id='storr_dbi'>DBI storr driver</h2><span id='topic+storr_dbi'></span><span id='topic+driver_dbi'></span>

<h3>Description</h3>

<p>Object cache driver using the &quot;DBI&quot; package interface for storage.
This means that storr can work for any supported &quot;DBI&quot; driver
(though practically this works only for SQLite and Postgres until
some MySQL dialect translation is done).  To connect, you must
provide the <em>driver</em> object (e.g., <code>RSQLite::SQLite()</code>,
or <code>RPostgres::Postgres()</code> as the first argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>storr_dbi(tbl_data, tbl_keys, con, args = NULL, binary = NULL,
  hash_algorithm = NULL, default_namespace = "objects")

driver_dbi(tbl_data, tbl_keys, con, args = NULL, binary = NULL,
  hash_algorithm = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="storr_dbi_+3A_tbl_data">tbl_data</code></td>
<td>
<p>Name for the table that maps hashes to values</p>
</td></tr>
<tr><td><code id="storr_dbi_+3A_tbl_keys">tbl_keys</code></td>
<td>
<p>Name for the table that maps keys to hashes</p>
</td></tr>
<tr><td><code id="storr_dbi_+3A_con">con</code></td>
<td>
<p>Either A DBI connection or a DBI driver (see example)</p>
</td></tr>
<tr><td><code id="storr_dbi_+3A_args">args</code></td>
<td>
<p>Arguments to pass, along with the driver, to
<code>DBI::dbConnect</code> if <code>con</code> is a driver.</p>
</td></tr>
<tr><td><code id="storr_dbi_+3A_binary">binary</code></td>
<td>
<p>Optional logical indicating if the values should be
stored in binary.  If possible, this is both (potentially
faster) and more accurate.  However, at present it is supported
only under very recent DBI and RSQLite packages, and for no
other DBI drivers, and is not actually any faster.  If not given
(i.e., <code>NULL</code>), then binary storage will be used where
possible when creating new tables, and where tables exist, we
use whatever was used in the existing tables.</p>
</td></tr>
<tr><td><code id="storr_dbi_+3A_hash_algorithm">hash_algorithm</code></td>
<td>
<p>Name of the hash algorithm to use.  Possible
values are &quot;md5&quot;, &quot;sha1&quot;, and others supported by
<code><a href="digest.html#topic+digest">digest</a></code>.  If not given, then we will default to
&quot;md5&quot;.</p>
</td></tr>
<tr><td><code id="storr_dbi_+3A_default_namespace">default_namespace</code></td>
<td>
<p>Default namespace (see
<code><a href="#topic+storr">storr</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Because the DBI package specifies a uniform interface for the
using DBI compliant databases, you need only to provide a
connection object.  storr does not do anything to help create the
connection object itself.
</p>
<p>The DBI storr driver works by using two tables; one mapping keys
to hashes, and one mapping hashes to values.  Two table names need
to be provided here; they must be different and they should be
treated as opaque (don't use them for anything else - reading or
writing).  Apart from that the names do not matter.
</p>
<p>Because of treatment of binary data by the underlying DBI drivers,
binary serialistion is not any faster (and might be slightly
slower than) string serialisation, in contrast with my experience
with other backends.
</p>
<p>storr uses DBI's &quot;prepared query&quot; approach to safely interpolate
keys, namespaces and values into the database - this should allow
odd characters without throwing SQL syntax errors.  Table names
can't be interpolated in the same way - these storr simply quotes,
but validates beforehand to ensure that <code>tbl_data</code> and
<code>tbl_keys</code> do not contain quotes.
</p>
<p>Be aware that <code>$destroy()</code> will close the connection to the
database.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("RSQLite", quietly = TRUE)) {
  st &lt;- storr::storr_dbi("tblData", "tblKeys", RSQLite::SQLite(),
                         ":memory:")

  # Set some data:
  st$set("foo", runif(10))
  st$list()

  # And retrieve the data:
  st$get("foo")

  # These are the data tables; treat these as read only
  DBI::dbListTables(st$driver$con)

  # With recent RSQLite you'll get binary storage here:
  st$driver$binary

  # The entire storr part of the database can be removed using
  # "destroy"; this will also close the connection to the database
  st$destroy()

  # If you have a connection you want to reuse (which will the the
  # case if you are using an in-memory SQLite database for
  # multiple things within an application) it may be useful to
  # pass the connection object instead of the driver:
  con &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
  st &lt;- storr::storr_dbi("tblData", "tblKeys", con)
  st$set("foo", runif(10))

  # You can then connect a different storr to the same underlying
  # storage
  st2 &lt;- storr::storr_dbi("tblData", "tblKeys", con)
  st2$get("foo")
}
</code></pre>

<hr>
<h2 id='storr_environment'>Environment object cache driver</h2><span id='topic+storr_environment'></span><span id='topic+driver_environment'></span>

<h3>Description</h3>

<p>Fast but transient environment driver.  This driver saves objects
in a local R environment, without serialisation.  This makes
lookup fast but it cannot be saved across sesssions.  The
environment storr can be made persistent by saving it out as a
file storr though.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>storr_environment(envir = NULL, hash_algorithm = NULL,
  default_namespace = "objects")

driver_environment(envir = NULL, hash_algorithm = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="storr_environment_+3A_envir">envir</code></td>
<td>
<p>The environment to point the storr at.  The default
creates an new empty environment which is generally the right
choice.  However, if you want multiple environment storrs
pointing at the same environment then pass the <code>envir</code>
argument along.</p>
</td></tr>
<tr><td><code id="storr_environment_+3A_hash_algorithm">hash_algorithm</code></td>
<td>
<p>Name of the hash algorithm to use.  Possible
values are &quot;md5&quot;, &quot;sha1&quot;, and others supported by
<code><a href="digest.html#topic+digest">digest</a></code>.  If not given, then we will default to
&quot;md5&quot;.</p>
</td></tr>
<tr><td><code id="storr_environment_+3A_default_namespace">default_namespace</code></td>
<td>
<p>Default namespace (see <code><a href="#topic+storr">storr</a></code>).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create an environment and stick some random numbers into it:
st &lt;- storr_environment()
st$set("foo", runif(10))
st$get("foo")

# To make this environment persistent we can save it to disk:
path &lt;- tempfile()
st2 &lt;- st$archive_export(path)
# st2 is now a storr_rds (see ?storr_rds), and will persist across
# sessions.

# or export to a new list:
lis &lt;- st$export(list())
lis
</code></pre>

<hr>
<h2 id='storr_external'>Storr that looks for external resources</h2><span id='topic+storr_external'></span>

<h3>Description</h3>

<p>storr for fetching external resources.  This driver is used where
will try to fetch from an external data source if a resource can
not be found locally.  This works by checking to see if a key is
present in the storr (and if so returning it).  If it is not
found, then the function <code>fetch_hook</code> is run to fetch it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>storr_external(storage_driver, fetch_hook, default_namespace = "objects")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="storr_external_+3A_storage_driver">storage_driver</code></td>
<td>
<p>Another <code>storr</code> driver to handle the
actual storage.</p>
</td></tr>
<tr><td><code id="storr_external_+3A_fetch_hook">fetch_hook</code></td>
<td>
<p>A function to run to fetch data when a key is
not found in the store.  This function must take arguments
<code>key</code> and <code>namespace</code> and return an R object.  It must
throw an error if the external resource cannot be resolved.</p>
</td></tr>
<tr><td><code id="storr_external_+3A_default_namespace">default_namespace</code></td>
<td>
<p>Default namespace (see
<code><a href="#topic+storr">storr</a></code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the vignette <code>vignette("external")</code> for much more detail.
This function is likely most useful for things like caching
resources from websites, or computing long-running quantities on
demand.
</p>

<hr>
<h2 id='storr_multistorr'>Storr with multiple storage drivers</h2><span id='topic+storr_multistorr'></span>

<h3>Description</h3>

<p>Create a special storr that uses separate storage drivers for the
keys (which tend to be numerous and small in size) and the data
(which tends to be somewhat less numerous and much larger in
size).  This might be useful to use storage models with different
characteristics (in memory/on disk, etc).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>storr_multistorr(keys, data, default_namespace = "objects")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="storr_multistorr_+3A_keys">keys</code></td>
<td>
<p>Driver for the keys</p>
</td></tr>
<tr><td><code id="storr_multistorr_+3A_data">data</code></td>
<td>
<p>Driver for the data</p>
</td></tr>
<tr><td><code id="storr_multistorr_+3A_default_namespace">default_namespace</code></td>
<td>
<p>Default namespace (see
<code><a href="#topic+storr">storr</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an experimental feature and somewhat subject to change.
In particular, the driver may develop the ability to store small
data in the same storr as the keys (say, up to 1kb) based on some
tunable parameter.
</p>
<p>You can attach another storr to either the data or the key storage
(see the example), but it will not be able to see keys or data
(respectively).  If you garbage collect the data half, all the
data will be lost!
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a storr that is stores keys in an environment and data in
# an rds
path &lt;- tempfile()
st &lt;- storr::storr_multistorr(driver_environment(),
                              driver_rds(path))
st$set("a", runif(10))
st$get("a")

# The data can be also seen by connecting to the rds store
rds &lt;- storr::storr_rds(path)
rds$list() # empty
rds$list_hashes() # here's the data
rds$get_value(rds$list_hashes())

st$destroy()
</code></pre>

<hr>
<h2 id='storr_rds'>rds object cache driver</h2><span id='topic+storr_rds'></span><span id='topic+driver_rds'></span>

<h3>Description</h3>

<p>Object cache driver that saves objects using R's native
serialized file format (see <code><a href="base.html#topic+saveRDS">saveRDS</a></code>) on the
filesystem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>storr_rds(path, compress = NULL, mangle_key = NULL,
  mangle_key_pad = NULL, hash_algorithm = NULL,
  default_namespace = "objects")

driver_rds(path, compress = NULL, mangle_key = NULL,
  mangle_key_pad = NULL, hash_algorithm = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="storr_rds_+3A_path">path</code></td>
<td>
<p>Path for the store.  <code>tempdir()</code> is a good choice
for ephemeral storage, The <code>rappdirs</code> package (on CRAN)
might be nice for persistent application data.</p>
</td></tr>
<tr><td><code id="storr_rds_+3A_compress">compress</code></td>
<td>
<p>Compress the generated file?  This saves a small
amount of space for a reasonable amount of time.</p>
</td></tr>
<tr><td><code id="storr_rds_+3A_mangle_key">mangle_key</code></td>
<td>
<p>Mangle keys?  If TRUE, then the key is encoded
using base64 before saving to the filesystem.  See Details.</p>
</td></tr>
<tr><td><code id="storr_rds_+3A_mangle_key_pad">mangle_key_pad</code></td>
<td>
<p>Logical indicating if the filenames created
when using <code>mangle_key</code> should also be &quot;padded&quot; with the
<code>=</code> character to make up a round number of bytes.  Padding
is required to satisfy the document that describes base64
encoding (RFC 4648) but can cause problems in some applications
(see <a href="https://github.com/richfitz/storr/issues/43">this
issue</a>.  The default is to not pad <em>new</em> storr archives.
This should be generally safe to leave alone.</p>
</td></tr>
<tr><td><code id="storr_rds_+3A_hash_algorithm">hash_algorithm</code></td>
<td>
<p>Name of the hash algorithm to use.  Possible
values are &quot;md5&quot;, &quot;sha1&quot;, and others supported by
<code><a href="digest.html#topic+digest">digest</a></code>.  If not given, then we will default to
&quot;md5&quot;.</p>
</td></tr>
<tr><td><code id="storr_rds_+3A_default_namespace">default_namespace</code></td>
<td>
<p>Default namespace (see
<code><a href="#topic+storr">storr</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>mangle_key</code> argument will run each key that is created
through a &quot;base 64&quot; encoding.  This means that keys that include
symbols that are invalid on filesystems (e.g, &quot;/&quot;, &quot;:&quot;) will be
replaced by harmless characters.  The RFC 4648 dialect is used
where &quot;-&quot; and &quot;_&quot; are used for character 62 and 63 (this differs
from most R base64 encoders).  This mangling is designed to be
transparent to the user &ndash; the storr will appear to store things
with unmangled keys but the names of the stored files will be
different.
</p>
<p>Note that the <em>namespace</em> is not mangled (at least not yet)
so needs to contain characters that are valid in a filename.
</p>
<p>Because the actual file will be stored with mangled names it is
not safe to use the same path for a storr with and without
mangling.  So once an rds storr has been created its &quot;mangledness&quot;
is set.  Using <code>mangle_key = NULL</code> uses whatever mangledness
exists (or no mangledness if creating a new storr).
</p>


<h3>Corrupt keys</h3>

<p>Some file synchronisation utilities like dropbox can create file
that confuse an rds storr (e.g.,
<code>"myobject (Someone's conflicted copy)"</code>.  If
<code>mangle_key</code> is <code>FALSE</code> these cannot be detected but at
the same time are not a real problem for storr.  However, if
<code>mangle_key</code> is <code>TRUE</code> and keys are base64 encoded then
these conflicted copies can break parts of storr.
</p>
<p>If you see a warning asking you to deal with these files, please
delete the offending files; the path will be printed along with
the files that are causing the problem.
</p>
<p>Alternatively, you can try (assuming a storr object <code>st</code>)
running
</p>
<pre>
st$driver$purge_corrupt_keys()
</pre>
<p>which will delete corrupted keys with no confirmation.  The
messages that are printed to screen will be printed by default at
most once per minute per namespace.  You can control this by
setting the R option <code>storr.corrupt.notice.period</code> - setting
this to <code>NA</code> suppresses the notice and otherwise it is
interpreted as the number of seconds.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create an rds storr in R's temporary directory:
st &lt;- storr_rds(tempfile())

# Store some data (10 random numbers against the key "foo")
st$set("foo", runif(10))
st$list()

# And retrieve the data:
st$get("foo")

# Keys that are not valid filenames will cause issues.  This will
# cause an error:
## Not run: 
st$set("foo/bar", letters)

## End(Not run)

# The solution to this is to "mangle" the key names.  Storr can do
# this for you:
st2 &lt;- storr_rds(tempfile(), mangle_key = TRUE)
st2$set("foo/bar", letters)
st2$list()
st2$get("foo/bar")

# Behind the scenes, storr is safely encoding the filenames with base64:
dir(file.path(st2$driver$path, "keys", "objects"))

# Clean up the two storrs:
st$destroy()
st2$destroy()
</code></pre>

<hr>
<h2 id='test_driver'>Test a storr driver</h2><span id='topic+test_driver'></span>

<h3>Description</h3>

<p>Test that a driver passes all storr tests.  This page is only of
interest to people developing storr drivers; nothing here is
required for using storr.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_driver(create)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test_driver_+3A_create">create</code></td>
<td>
<p>A function with one arguments that when run with
<code>NULL</code> as the argument will create a new driver instance.
It will also be called with a driver (of the same type) as an
argument - in this case, you must create a new driver object
pointing at the same underlying storage (see the examples).
Depending on your storage model, temporary directories,
in-memory locations, or random-but-unique prefixes may help
create isolated locations for the test (the tests assume that a
storr created with <code>create</code> is entirely empty).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This will run through a suite of functions to test that a driver
is likely to behave itself.  As bugs are found they will be added
to the test suite to guard against regressions.
</p>
<p>The test suite is included in the package as
<code>system.file("spec", package = "storr")</code>.
</p>
<p>The procedure for each test block is:
</p>

<ol>
<li><p>Create a new driver by running <code>dr &lt;- create()</code>.
</p>
</li>
<li><p>Run a number of tests.
</p>
</li>
<li><p>Destroy the driver by running <code>dr$destroy()</code>.
</p>
</li></ol>

<p>So before running this test suite, make sure this will not harm
any precious data!
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Testing the environment driver is nice and fast:
if (requireNamespace("testthat")) {
  create_env &lt;- function(dr = NULL, ...) {
    driver_environment(dr$envir, ...)
  }
  test_driver(create_env)
}

# To test things like the rds driver, I would run:
## Not run: 
if (requireNamespace("testthat")) {
  create_rds &lt;- function(dr = NULL) {
    driver_rds(if (is.null(dr)) tempfile() else dr$path)
  }
  test_driver(create_rds)
}

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
