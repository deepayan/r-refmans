<!DOCTYPE html><html lang="en"><head><title>Help for package statespacer</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {statespacer}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#statespacer-package'><p>statespacer: A package for state space modelling in R.</p></a></li>
<li><a href='#BlockMatrix'><p>Combine Matrices into a Block Diagonal Matrix</p></a></li>
<li><a href='#Cholesky'><p>Construct a Valid Variance - Covariance Matrix</p></a></li>
<li><a href='#CoeffARMA'><p>Transform arbitrary matrices into ARMA coefficient matrices</p></a></li>
<li><a href='#FedYieldCurve'><p>Federal Reserve Interest Rates</p></a></li>
<li><a href='#predict.statespacer'><p>State Space Model Forecasting</p></a></li>
<li><a href='#SimSmoother'><p>Generating Random Samples using the Simulation Smoother</p></a></li>
<li><a href='#statespacer'><p>State Space Model Fitting</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.5.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-01-27</td>
</tr>
<tr>
<td>Title:</td>
<td>State Space Modelling in 'R'</td>
</tr>
<tr>
<td>Description:</td>
<td>A tool that makes estimating models in state space form 
    a breeze. See "Time Series Analysis by State Space Methods" by 
    Durbin and Koopman (2012, ISBN: 978-0-19-964117-8) for details 
    about the algorithms implemented.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://DylanB95.github.io/statespacer/">https://DylanB95.github.io/statespacer/</a>,
<a href="https://github.com/DylanB95/statespacer/">https://github.com/DylanB95/statespacer/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/DylanB95/statespacer/issues/">https://github.com/DylanB95/statespacer/issues/</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rdpack, stats, Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>datasets, graphics, knitr, numDeriv (&ge; 2016.8-1.1), optimx
(&ge; 2020-4.2), rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-27 22:43:43 UTC; Dylan</td>
</tr>
<tr>
<td>Author:</td>
<td>Dylan Beijers [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dylan Beijers &lt;dylanbeijers@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-27 23:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='statespacer-package'>statespacer: A package for state space modelling in R.</h2><span id='topic+statespacer-package'></span><span id='topic+_PACKAGE'></span>

<h3>Description</h3>

<p>The statespacer package provides functions that make estimating models in
State Space form a breeze. This package implements state-of-the-art
algorithms developed by various time series practitioners such as J. Durbin
and S.J. Koopman. Details about the algorithms can be found in their book,
&quot;Time Series Analysis by State Space Methods&quot;.
</p>


<h3>State Space Components</h3>

<p>This package supports numerous state space components:
</p>

<ul>
<li><p> The Local Level
</p>
</li>
<li><p> The Local Level + Slope
</p>
</li>
<li><p> Smoothing Splines
</p>
</li>
<li><p> Trigonometric Seasonality, BSM
</p>
</li>
<li><p> (Business) Cycles
</p>
</li>
<li><p> Explanatory Variables
</p>
</li>
<li><p> Explanatory Variables with time-varying coefficients
</p>
</li>
<li><p> Explanatory Variables in the Local Level
</p>
</li>
<li><p> Explanatory Variables in the Local Level + Slope
</p>
</li>
<li><p> ARIMA
</p>
</li>
<li><p> SARIMA
</p>
</li>
<li><p> Moreover, you can specify a component yourself!
</p>
</li></ul>

<p>These components can be used for both univariate, and multivariate models.
The components can be combined in order to get more extensive models.
Moreover, the user can control the format of the variance - covariance
matrices of each of the components. This way, one could specify the
components to be deterministic instead of stochastic. In the multivariate
case, one could impose rank restrictions on the variance - covariance
matrices such that commonalities in the components are estimated, like
common levels, common slopes, etc.
</p>


<h3>Fitting Procedure</h3>

<p>The package employs a univariate treatment, and an exact initialisation for
diffuse elements, to estimate the state parameters and compute the
loglikelihood. Collapsing large observation vectors is supported as well.
Moreover, missing observations are readily dealt with by putting the models
in State Space form!
</p>


<h3>Author(s)</h3>

<p>Dylan Beijers, <a href="mailto:dylanbeijers@gmail.com">dylanbeijers@gmail.com</a>
</p>


<h3>References</h3>

<p>Durbin J, Koopman SJ (2012).
<em>Time series analysis by state space methods</em>.
Oxford university press.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://DylanB95.github.io/statespacer/">https://DylanB95.github.io/statespacer/</a>
</p>
</li>
<li> <p><a href="https://github.com/DylanB95/statespacer/">https://github.com/DylanB95/statespacer/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/DylanB95/statespacer/issues/">https://github.com/DylanB95/statespacer/issues/</a>
</p>
</li></ul>


<hr>
<h2 id='BlockMatrix'>Combine Matrices into a Block Diagonal Matrix</h2><span id='topic+BlockMatrix'></span>

<h3>Description</h3>

<p>Creates a block diagonal matrix with its arguments as the blocks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BlockMatrix(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BlockMatrix_+3A_...">...</code></td>
<td>
<p>Matrices that should be put on the diagonal.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>BlockMatrix()</code> tries to coerce its arguments to a matrix,
using <code><a href="base.html#topic+matrix">as.matrix</a></code>.
</p>


<h3>Value</h3>

<p>Block diagonal matrix having the specified matrices on its diagonal.
</p>


<h3>Author(s)</h3>

<p>Dylan Beijers, <a href="mailto:dylanbeijers@gmail.com">dylanbeijers@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>BlockMatrix(diag(ceiling(9 * stats::runif(5))), matrix(1:8, 4, 2), c(14, 8))
</code></pre>

<hr>
<h2 id='Cholesky'>Construct a Valid Variance - Covariance Matrix</h2><span id='topic+Cholesky'></span>

<h3>Description</h3>

<p>Constructs a valid variance - covariance matrix by using the Cholesky LDL
decomposition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Cholesky(param = NULL, format = NULL, decompositions = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Cholesky_+3A_param">param</code></td>
<td>
<p>Vector containing the parameters used to construct the
variance - covariance matrix.</p>
</td></tr>
<tr><td><code id="Cholesky_+3A_format">format</code></td>
<td>
<p>Matrix representing the format for the Loading matrix L
and Diagonal matrix D. The lower triangular part of the format is used
as the format for the Loading matrix L. The diagonal of the format is
used as the format for the Diagonal matrix D. Must be a matrix.</p>
</td></tr>
<tr><td><code id="Cholesky_+3A_decompositions">decompositions</code></td>
<td>
<p>Boolean indicating whether the loading and diagonal
matrix of the Cholesky decomposition, and the correlation matrix and
standard deviations should be returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>format</code> is used to specify which elements of the loading and diagonal
matrix should be non-zero. The elements of <code>param</code> are then distributed
along the non-zero elements of the loading and diagonal matrix.
The parameters for the diagonal matrix are transformed using <code>exp(2 * x)</code>.
</p>


<h3>Value</h3>

<p>A valid variance - covariance matrix.
If <code>decompositions = TRUE</code> then it returns a list containing:
</p>

<ul>
<li> <p><code>cov_mat</code>: The variance - covariance matrix.
</p>
</li>
<li> <p><code>loading_matrix</code>: The loading matrix of the Cholesky decomposition.
</p>
</li>
<li> <p><code>diagonal_matrix</code>: The diagonal matrix of the Cholesky decomposition.
</p>
</li>
<li> <p><code>correlation_matrix</code>: Matrix containing the correlations.
</p>
</li>
<li> <p><code>stdev_matrix</code>: Matrix containing the standard deviations on the diagonal.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Dylan Beijers, <a href="mailto:dylanbeijers@gmail.com">dylanbeijers@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>format &lt;- diag(1, 2, 2)
format[2, 1] &lt;- 1
Cholesky(param = c(2, 4, 1), format = format, decompositions = TRUE)
</code></pre>

<hr>
<h2 id='CoeffARMA'>Transform arbitrary matrices into ARMA coefficient matrices</h2><span id='topic+CoeffARMA'></span>

<h3>Description</h3>

<p>Creates coefficient matrices for which the characteristic polynomial
corresponds to a stationary process.
See Ansley and Kohn (1986) for details about
the transformation used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CoeffARMA(A, variance = NULL, ar = 1, ma = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CoeffARMA_+3A_a">A</code></td>
<td>
<p>An array of arbitrary square matrices in the multivariate case,
or a vector of arbitrary numbers in the univariate case.</p>
</td></tr>
<tr><td><code id="CoeffARMA_+3A_variance">variance</code></td>
<td>
<p>A variance - covariance matrix.
Note: <code>variance</code> not needed for the univariate case!</p>
</td></tr>
<tr><td><code id="CoeffARMA_+3A_ar">ar</code></td>
<td>
<p>The order of the AR part.</p>
</td></tr>
<tr><td><code id="CoeffARMA_+3A_ma">ma</code></td>
<td>
<p>The order of the MA part.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If multivariate, a list containing:
</p>

<ul>
<li><p> An array of coefficient matrices for the AR part.
</p>
</li>
<li><p> An array of coefficient matrices for the MA part.
</p>
</li></ul>

<p>If univariate, a list containing:
</p>

<ul>
<li><p> A vector of coefficients for the AR part.
</p>
</li>
<li><p> A vector of coefficients for the MA part.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Dylan Beijers, <a href="mailto:dylanbeijers@gmail.com">dylanbeijers@gmail.com</a>
</p>


<h3>References</h3>

<p>Ansley CF, Kohn R (1986).
&ldquo;A note on reparameterizing a vector autoregressive moving average model to enforce stationarity.&rdquo;
<em>Journal of Statistical Computation and Simulation</em>, <b>24</b>(2), 99&ndash;106.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CoeffARMA(A = stats::rnorm(2), ar = 1, ma = 1)
</code></pre>

<hr>
<h2 id='FedYieldCurve'>Federal Reserve Interest Rates</h2><span id='topic+FedYieldCurve'></span>

<h3>Description</h3>

<p>A dataset containing the interest rates of the Federal Reserve, from January
1982 up to April 2022. The interest rates are market yields on United States
Treasury securities with constant maturity (CMT). The maturities contained
in this dataset are the 3 months, 6 months, 1 year, 2 years, 3 years,
5 years, 7 years, and 10 years maturities. Each interest rate is quoted on
investment basis, and are reported monthly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FedYieldCurve
</code></pre>


<h3>Format</h3>

<p>A data frame with 484 rows and 9 variables:
</p>

<dl>
<dt>Month</dt><dd><p>The month of the quoted interest rates, format is yyyy-mm-dd</p>
</dd>
<dt>M3</dt><dd><p>Market yield on U.S. Treasury securities at 3-month constant
maturity, quoted on investment basis, in percent per year.</p>
</dd>
<dt>M6</dt><dd><p>Market yield on U.S. Treasury securities at 6-month constant
maturity, quoted on investment basis, in percent per year.</p>
</dd>
<dt>Y1</dt><dd><p>Market yield on U.S. Treasury securities at 1-year constant
maturity, quoted on investment basis, in percent per year.</p>
</dd>
<dt>Y2</dt><dd><p>Market yield on U.S. Treasury securities at 2-year constant
maturity, quoted on investment basis, in percent per year.</p>
</dd>
<dt>Y3</dt><dd><p>Market yield on U.S. Treasury securities at 3-year constant
maturity, quoted on investment basis, in percent per year.</p>
</dd>
<dt>Y5</dt><dd><p>Market yield on U.S. Treasury securities at 5-year constant
maturity, quoted on investment basis, in percent per year.</p>
</dd>
<dt>Y7</dt><dd><p>Market yield on U.S. Treasury securities at 7-year constant
maturity, quoted on investment basis, in percent per year.</p>
</dd>
<dt>Y10</dt><dd><p>Market yield on U.S. Treasury securities at 10-year constant
maturity, quoted on investment basis, in percent per year.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.federalreserve.gov/datadownload/Build.aspx?rel=H15">https://www.federalreserve.gov/datadownload/Build.aspx?rel=H15</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(FedYieldCurve)
</code></pre>

<hr>
<h2 id='predict.statespacer'>State Space Model Forecasting</h2><span id='topic+predict.statespacer'></span>

<h3>Description</h3>

<p>Produces forecasts and out of sample simulations using a fitted State Space Model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'statespacer'
predict(
  object,
  addvar_list_fc = NULL,
  level_addvar_list_fc = NULL,
  self_spec_list_fc = NULL,
  forecast_period = 1,
  nsim = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.statespacer_+3A_object">object</code></td>
<td>
<p>A statespacer object as returned by <code><a href="#topic+statespacer">statespacer</a></code>.</p>
</td></tr>
<tr><td><code id="predict.statespacer_+3A_addvar_list_fc">addvar_list_fc</code></td>
<td>
<p>A list containing the explanatory variables for each
of the dependent variables. The list should contain p (number of dependent
variables) elements. Each element of the list should be a
<code>forecast_period</code> x k_p matrix, with k_p being the number of explanatory
variables for the pth dependent variable. If no explanatory variables
should be added for one of the dependent variables, then set the
corresponding element to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="predict.statespacer_+3A_level_addvar_list_fc">level_addvar_list_fc</code></td>
<td>
<p>A list containing the explanatory variables
for each of the dependent variables. The list should contain p
(number of dependent variables) elements. Each element of the list should
be a <code>forecast_period</code> x k_p matrix, with k_p being the number of
explanatory variables for the pth dependent variable. If no explanatory
variables should be added for one of the dependent variables, then set
the corresponding element to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="predict.statespacer_+3A_self_spec_list_fc">self_spec_list_fc</code></td>
<td>
<p>A list containing the specification of the self
specified component. Does not have to be specified if it does not differ
from <code>self_spec_list</code> as passed on to <code><a href="#topic+statespacer">statespacer</a></code>. If some
system matrices are time-varying then you should specify this argument.
See <code><a href="#topic+statespacer">statespacer</a></code> for details about the format that must be
followed for this argument.</p>
</td></tr>
<tr><td><code id="predict.statespacer_+3A_forecast_period">forecast_period</code></td>
<td>
<p>Number of time steps to forecast ahead.</p>
</td></tr>
<tr><td><code id="predict.statespacer_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulations to generate over the forecast period.</p>
</td></tr>
<tr><td><code id="predict.statespacer_+3A_...">...</code></td>
<td>
<p>Arguments passed on to the <code>predict</code> generic. Should not be used!</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the forecasts and corresponding uncertainties.
In addition, it returns the components of the forecasts, as specified
by the State Space model.
</p>


<h3>Author(s)</h3>

<p>Dylan Beijers, <a href="mailto:dylanbeijers@gmail.com">dylanbeijers@gmail.com</a>
</p>


<h3>References</h3>

<p>Durbin J, Koopman SJ (2012).
<em>Time series analysis by state space methods</em>.
Oxford university press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Fit a SARIMA model on the AirPassengers data
library(datasets)
Data &lt;- matrix(log(AirPassengers))
sarima_list &lt;- list(list(s = c(12, 1), ar = c(0, 0), i = c(1, 1), ma = c(1, 1)))
fit &lt;- statespacer(y = Data, 
                   H_format = matrix(0), 
                   sarima_list = sarima_list, 
                   initial = c(0.5*log(var(diff(Data))), 0, 0))

# Obtain forecasts for 100 steps ahead using the fitted model
fc &lt;- predict(fit, forecast_period = 100, nsim = 10)

# Plot the forecasts and one of the simulation paths
plot(fc$y_fc, type = 'l')
lines(fc$sim$y[, 1, 1], type = 'p')
</code></pre>

<hr>
<h2 id='SimSmoother'>Generating Random Samples using the Simulation Smoother</h2><span id='topic+SimSmoother'></span>

<h3>Description</h3>

<p>Draws random samples of the specified model conditional
on the observed data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SimSmoother(object, nsim = 1, components = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SimSmoother_+3A_object">object</code></td>
<td>
<p>A statespacer object as returned by <code><a href="#topic+statespacer">statespacer</a></code>.</p>
</td></tr>
<tr><td><code id="SimSmoother_+3A_nsim">nsim</code></td>
<td>
<p>Number of random samples to draw. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="SimSmoother_+3A_components">components</code></td>
<td>
<p>Boolean indicating whether the components of
the model should be extracted in each of the random samples.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the simulated state parameters and disturbances.
In addition, it returns the components as specified by the State Space model
if <code>components = TRUE</code>. Each of the objects are arrays, where the first
dimension equals the number of time points, the second dimension the number
of state parameters, disturbances, or dependent variables, and the third
dimension equals the number of random samples <code>nsim</code>.
</p>


<h3>Author(s)</h3>

<p>Dylan Beijers, <a href="mailto:dylanbeijers@gmail.com">dylanbeijers@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Fits a local level model for the Nile data
library(datasets)
y &lt;- matrix(Nile)
fit &lt;- statespacer(initial = 10, y = y, local_level_ind = TRUE)

# Obtain random sample using the fitted model
sim &lt;- SimSmoother(fit, nsim = 1, components = TRUE)

# Plot the simulated level against the smoothed level of the original data
plot(sim$level[, 1, 1], type = 'p')
lines(fit$smoothed$level, type = 'l')
</code></pre>

<hr>
<h2 id='statespacer'>State Space Model Fitting</h2><span id='topic+statespacer'></span>

<h3>Description</h3>

<p>Fits a State Space model as specified by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>statespacer(
  y,
  H_format = NULL,
  local_level_ind = FALSE,
  slope_ind = FALSE,
  BSM_vec = NULL,
  cycle_ind = FALSE,
  addvar_list = NULL,
  level_addvar_list = NULL,
  arima_list = NULL,
  sarima_list = NULL,
  self_spec_list = NULL,
  exclude_level = NULL,
  exclude_slope = NULL,
  exclude_BSM_list = lapply(BSM_vec, function(x) 0),
  exclude_cycle_list = list(0),
  exclude_arima_list = lapply(arima_list, function(x) 0),
  exclude_sarima_list = lapply(sarima_list, function(x) 0),
  damping_factor_ind = rep(TRUE, length(exclude_cycle_list)),
  format_level = NULL,
  format_slope = NULL,
  format_BSM_list = lapply(BSM_vec, function(x) NULL),
  format_cycle_list = lapply(exclude_cycle_list, function(x) NULL),
  format_addvar = NULL,
  format_level_addvar = NULL,
  fit = TRUE,
  initial = 0,
  method = "BFGS",
  control = list(),
  collapse = FALSE,
  diagnostics = TRUE,
  standard_errors = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="statespacer_+3A_y">y</code></td>
<td>
<p>N x p matrix containing the N observations of the p
dependent variables.</p>
</td></tr>
<tr><td><code id="statespacer_+3A_h_format">H_format</code></td>
<td>
<p>Format of the H system matrix,
the variance - covariance matrix of the observation equation.</p>
</td></tr>
<tr><td><code id="statespacer_+3A_local_level_ind">local_level_ind</code></td>
<td>
<p>Boolean indicating whether a local level should
be added to the state space model.</p>
</td></tr>
<tr><td><code id="statespacer_+3A_slope_ind">slope_ind</code></td>
<td>
<p>Boolean indicating whether a local level + slope should
be added to the state space model.</p>
</td></tr>
<tr><td><code id="statespacer_+3A_bsm_vec">BSM_vec</code></td>
<td>
<p>Vector containing the BSM seasonalities that have to be added
to the state space model.</p>
</td></tr>
<tr><td><code id="statespacer_+3A_cycle_ind">cycle_ind</code></td>
<td>
<p>Boolean indicating whether a cycle has to be added
to the state space model.</p>
</td></tr>
<tr><td><code id="statespacer_+3A_addvar_list">addvar_list</code></td>
<td>
<p>A list containing the explanatory variables for each of
the dependent variables. The list should contain p (number of dependent
variables) elements. Each element of the list should be a N x k_p matrix,
with k_p being the number of explanatory variables for the pth
dependent variable. If no explanatory variables should be added for one
of the dependent variables, then set the corresponding element to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="statespacer_+3A_level_addvar_list">level_addvar_list</code></td>
<td>
<p>A list containing the explanatory variables for
each of the dependent variables. The list should contain p (number of
dependent variables) elements. Each element of the list should be a
N x k_p matrix, with k_p being the number of explanatory variables
for the pth dependent variable. If no explanatory variables should be
added for one of the dependent variables, then set the corresponding
element to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="statespacer_+3A_arima_list">arima_list</code></td>
<td>
<p>Specifications of the ARIMA components, should be a list
containing vectors of length 3 with the following format: <code>c(AR, I, MA)</code>.
Should be a list to allow different ARIMA models for different sets of
dependent variables. Note: The AR and MA coefficients are
constrained such that the AR component is stationary, and the MA
component is invertible.
See Ansley and Kohn (1986) for details about
the transformation used.</p>
</td></tr>
<tr><td><code id="statespacer_+3A_sarima_list">sarima_list</code></td>
<td>
<p>Specifications of the SARIMA components, should be a list
containing lists that contain 4 named vectors. Vectors should be named:
&quot;s&quot;, &quot;ar&quot;, &quot;i&quot;, &quot;ma&quot;. Should be a list of lists to allow different SARIMA
models for different sets of dependent variables. Note: The AR and MA
coefficients are constrained such that the AR components are stationary,
and the MA components are invertible.
See Ansley and Kohn (1986) for details about
the transformation used. Note: For multivariate models, the order of &quot;s&quot;
matters, as matrix multiplication is not commutative!</p>
</td></tr>
<tr><td><code id="statespacer_+3A_self_spec_list">self_spec_list</code></td>
<td>
<p>A list containing the specification of the self
specified component. See the Details section for extensive details about
the format that must be followed for this argument.</p>
</td></tr>
<tr><td><code id="statespacer_+3A_exclude_level">exclude_level</code></td>
<td>
<p>Vector containing the dependent variables that should
not get a local level.</p>
</td></tr>
<tr><td><code id="statespacer_+3A_exclude_slope">exclude_slope</code></td>
<td>
<p>Vector containing the dependent variables that should
not get a slope.</p>
</td></tr>
<tr><td><code id="statespacer_+3A_exclude_bsm_list">exclude_BSM_list</code></td>
<td>
<p>List of vectors, each vector containing the
dependent variables that should not get the corresponding BSM component.</p>
</td></tr>
<tr><td><code id="statespacer_+3A_exclude_cycle_list">exclude_cycle_list</code></td>
<td>
<p>The dependent variables that should not get the
corresponding cycle component. Should be a list of vectors to allow
different dependent variables to be excluded for different cycles.</p>
</td></tr>
<tr><td><code id="statespacer_+3A_exclude_arima_list">exclude_arima_list</code></td>
<td>
<p>The dependent variables that should not be
involved in the corresponding ARIMA component. Should be a list of
vectors to allow different dependent variables to be excluded for
different ARIMA components.</p>
</td></tr>
<tr><td><code id="statespacer_+3A_exclude_sarima_list">exclude_sarima_list</code></td>
<td>
<p>The dependent variables that should not be
involved in the corresponding SARIMA component. Should be a list of
vectors to allow different dependent variables to be excluded for
different SARIMA components.</p>
</td></tr>
<tr><td><code id="statespacer_+3A_damping_factor_ind">damping_factor_ind</code></td>
<td>
<p>Boolean indicating whether a damping factor should
be included. Must be a vector if multiple cycles are included,
to indicate which cycles should include a damping factor.</p>
</td></tr>
<tr><td><code id="statespacer_+3A_format_level">format_level</code></td>
<td>
<p>Format of the Q_level system matrix
the variance - covariance matrix of the level state equation.</p>
</td></tr>
<tr><td><code id="statespacer_+3A_format_slope">format_slope</code></td>
<td>
<p>Format of the Q_slope system matrix,
the variance - covariance matrix of the slope state equation.</p>
</td></tr>
<tr><td><code id="statespacer_+3A_format_bsm_list">format_BSM_list</code></td>
<td>
<p>Format of the Q_BSM system matrix,
the variance - covariance matrix of the BSM state equation. Should be a
list to allow different formats for different seasonality periods.</p>
</td></tr>
<tr><td><code id="statespacer_+3A_format_cycle_list">format_cycle_list</code></td>
<td>
<p>Format of the Q_cycle system matrix,
the variance - covariance matrix of the cycle state equation. Should be a
list to allow different formats for different cycles.</p>
</td></tr>
<tr><td><code id="statespacer_+3A_format_addvar">format_addvar</code></td>
<td>
<p>Format of the Q_addvar system matrix, the
variance - covariance matrix of the explanatory variables state equation.</p>
</td></tr>
<tr><td><code id="statespacer_+3A_format_level_addvar">format_level_addvar</code></td>
<td>
<p>Format of the Q_level_addvar system matrix, the
variance - covariance matrix of the explanatory variables of the level
state equation.</p>
</td></tr>
<tr><td><code id="statespacer_+3A_fit">fit</code></td>
<td>
<p>Boolean indicating whether the model should be fit by an
iterative optimisation procedure. If <code>FALSE</code>, the model is only evaluated
at the initial values.</p>
</td></tr>
<tr><td><code id="statespacer_+3A_initial">initial</code></td>
<td>
<p>Vector of initial values for the parameter search.
The initial values are recycled or truncated if too few or too many values
have been specified.</p>
</td></tr>
<tr><td><code id="statespacer_+3A_method">method</code></td>
<td>
<p>Method that should be used by the <code><a href="stats.html#topic+optim">optim</a></code>
or <code><a href="optimx.html#topic+optimr">optimr</a></code> function to estimate the parameters. Only
used if <code>fit = TRUE</code>.</p>
</td></tr>
<tr><td><code id="statespacer_+3A_control">control</code></td>
<td>
<p>A list of control parameters for the
<code><a href="stats.html#topic+optim">optim</a></code> or <code><a href="optimx.html#topic+optimr">optimr</a></code> function. Only
used if <code>fit = TRUE</code>.</p>
</td></tr>
<tr><td><code id="statespacer_+3A_collapse">collapse</code></td>
<td>
<p>Boolean indicating whether the observation vector should be
collapsed. Should only be set to <code>TRUE</code> if the dimensionality of the
observation vector exceeds the dimensionality of the state vector.
If this is the case, computational gains can be achieved by collapsing
the observation vector.</p>
</td></tr>
<tr><td><code id="statespacer_+3A_diagnostics">diagnostics</code></td>
<td>
<p>Boolean indicating whether diagnostical tests should be
computed. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="statespacer_+3A_standard_errors">standard_errors</code></td>
<td>
<p>Boolean indicating whether standard errors should be
computed. <span class="pkg">numDeriv</span> must be installed in order to compute the
standard errors! Defaults to <code>TRUE</code> if <span class="pkg">numDeriv</span> is available.</p>
</td></tr>
<tr><td><code id="statespacer_+3A_verbose">verbose</code></td>
<td>
<p>Boolean indicating whether the progress of the optimisation
procedure should be printed. Only used if <code>fit = TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To fit the specified State Space model, one occasionally has to pay careful
attention to the initial values supplied. See
<code>vignette("dictionary", "statespacer")</code> for details.
Initial values should not be too large, as some parameters use the
transformation exp(2x) to ensure non-negative values, they should also not
be too small as some variances might become relatively too close to 0,
relative to the magnitude of y.
</p>
<p>If a component is specified without a <code>format</code>, then the format defaults to a
diagonal <code>format</code>.
</p>
<p><code>self_spec_list</code> provides a means to incorporate a self-specified component
into the State Space model. This argument can only contain any of the
following items, of which some are mandatory:
</p>

<ul>
<li> <p><code>H_spec</code>: Boolean indicating whether the H matrix is self-specified.
Should be <code>TRUE</code>, if you want to specify the H matrix yourself.
</p>
</li>
<li> <p><code>state_num</code> (mandatory): The number of state parameters introduced by the
self-specified component. Must be 0 if only <code>H</code> is self-specified.
</p>
</li>
<li> <p><code>param_num</code>: The number of parameters needed by the self-specified
component. Must be specified and greater than 0 if parameters are needed.
</p>
</li>
<li> <p><code>sys_mat_fun</code>: A function returning a list of system matrices that are
constructed using the parameters. Must have <code>param</code> as an argument. The
items in the list returned should have any of the following names: Z,
Tmat, R, Q, a1, P_star, H. Note: Only the system matrices that depend on
the parameters should be returned by the function!
</p>
</li>
<li> <p><code>sys_mat_input</code>: A list containing additional arguments to <code>sys_mat_fun</code>.
</p>
</li>
<li> <p><code>Z</code>: The Z system matrix if it does not depend on the parameters.
</p>
</li>
<li> <p><code>Tmat</code>: The T system matrix if it does not depend on the parameters.
</p>
</li>
<li> <p><code>R</code>: The R system matrix if it does not depend on the parameters.
</p>
</li>
<li> <p><code>Q</code>: The Q system matrix if it does not depend on the parameters.
</p>
</li>
<li> <p><code>a1</code>: The initial guess of the state vector. Must be a matrix
with one column.
</p>
</li>
<li> <p><code>P_inf</code>: The initial diffuse part of the variance - covariance
matrix of the initial state vector. Must be a matrix.
</p>
</li>
<li> <p><code>P_star</code>: The initial non-diffuse part of the variance - covariance
matrix of the initial state vector if it does not depend on the
parameters. Must be a matrix.
</p>
</li>
<li> <p><code>H</code>: The H system matrix if it does not depend on the parameters.
</p>
</li>
<li> <p><code>transform_fun</code>: Function that returns transformed parameters for which
standard errors have to be computed. Must have <code>param</code> as an argument.
</p>
</li>
<li> <p><code>transform_input</code>: A list containing additional arguments to
<code>transform_fun.</code>
</p>
</li>
<li> <p><code>state_only</code>: The indices of the self specified state that do not play a
role in the observation equations, but only in the state equations. Should
only be used if you want to use <code>collapse = TRUE</code> and have some state
parameters that do not play a role in the observation equations. Does not
have to be specified for <code>collapse = FALSE</code>.
</p>
</li></ul>

<p>Note: System matrices should only be specified once and need to be
specified once! That is, system matrices that are returned by <code>sys_mat_fun</code>
should not be specified directly, and vice versa. So, system matrices need
to be either specified directly, or be returned by <code>sys_mat_fun</code>. An
exception holds for the case where you <strong>only</strong> want to specify <code>H</code>
yourself. This will not be checked, so be aware of erroneous output if you
do not follow the guidelines of specifying <code>self_spec_list</code>. If time-varying
system matrices are required, return an array for the time-varying system
matrix instead of a matrix.
</p>


<h3>Value</h3>

<p>A statespacer object containing:
</p>

<ul>
<li> <p><code>function_call</code>: A list containing the input to the function.
</p>
</li>
<li> <p><code>system_matrices</code>: A list containing the system matrices of
the State Space model.
</p>
</li>
<li> <p><code>predicted</code>: A list containing the predicted components of
the State Space model.
</p>
</li>
<li> <p><code>filtered</code>: A list containing the filtered components of
the State Space model.
</p>
</li>
<li> <p><code>smoothed</code>: A list containing the smoothed components of
the State Space model.
</p>
</li>
<li> <p><code>diagnostics</code>: A list containing items useful for diagnostical tests.
</p>
</li>
<li> <p><code>optim</code> (if <code>fit = TRUE</code>): A list containing the variables that are returned
by the <code><a href="stats.html#topic+optim">optim</a></code> or <code><a href="optimx.html#topic+optimr">optimr</a></code> function.
</p>
</li>
<li> <p><code>loglik_fun</code>: Function that returns the loglikelihood of the
specified State Space model, as a function of its parameters.
</p>
</li>
<li> <p><code>standard_errors</code> (if <code>standard_errors = TRUE</code>): A list containing the
standard errors of the parameters of the State Space model.
</p>
</li></ul>

<p>For extensive details about the object returned,
see <code>vignette("dictionary", "statespacer")</code>.
</p>


<h3>Author(s)</h3>

<p>Dylan Beijers, <a href="mailto:dylanbeijers@gmail.com">dylanbeijers@gmail.com</a>
</p>


<h3>References</h3>

<p>Durbin J, Koopman SJ (2012).
<em>Time series analysis by state space methods</em>.
Oxford university press.
</p>
<p>Ansley CF, Kohn R (1986).
&ldquo;A note on reparameterizing a vector autoregressive moving average model to enforce stationarity.&rdquo;
<em>Journal of Statistical Computation and Simulation</em>, <b>24</b>(2), 99&ndash;106.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Fits a local level model for the Nile data
library(datasets)
y &lt;- matrix(Nile)
fit &lt;- statespacer(initial = 10, y = y, local_level_ind = TRUE)

# Plots the filtered estimates
plot(
  1871:1970, fit$function_call$y,
  type = "p", ylim = c(500, 1400),
  xlab = NA, ylab = NA
)
lines(1871:1970, fit$filtered$level, type = "l")
lines(
  1871:1970, fit$filtered$level +
    1.644854 * sqrt(fit$filtered$P[1, 1, ]),
  type = "l", col = "gray"
)
lines(
  1871:1970, fit$filtered$level -
    1.644854 * sqrt(fit$filtered$P[1, 1, ]),
  type = "l", col = "gray"
)

# Plots the smoothed estimates
plot(
  1871:1970, fit$function_call$y,
  type = "p", ylim = c(500, 1400),
  xlab = NA, ylab = NA
)
lines(1871:1970, fit$smoothed$level, type = "l")
lines(
  1871:1970, fit$smoothed$level +
    1.644854 * sqrt(fit$smoothed$V[1, 1, ]),
  type = "l", col = "gray"
)
lines(
  1871:1970, fit$smoothed$level -
    1.644854 * sqrt(fit$smoothed$V[1, 1, ]),
  type = "l", col = "gray"
)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
