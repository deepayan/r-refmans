<!DOCTYPE html><html lang="en"><head><title>Help for package facmodTS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {facmodTS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#facmodTS-package'><p>facmodTS: Time Series Factor Models for Asset Returns</p></a></li>
<li><a href='#fitTsfm'><p>Fit a time series factor model using time series regression</p></a></li>
<li><a href='#fitTsfm.control'><p>List of control parameters for <code>fitTsfm</code></p></a></li>
<li><a href='#fitTsfmLagLeadBeta'><p>Fit a lagged and lead Betas factor model using time series regression</p></a></li>
<li><a href='#fitTsfmMT'><p>Fit a market timing time series factor model</p></a></li>
<li><a href='#fitTsfmUpDn'><p>Fit a up and down market factor model using time series regression</p></a></li>
<li><a href='#fmCov'><p>Covariance Matrix for assets' returns from fitted factor model.</p></a></li>
<li><a href='#fmEsDecomp'><p>Decompose ES into individual factor contributions</p></a></li>
<li><a href='#fmSdDecomp'><p>Decompose standard deviation into individual factor contributions</p></a></li>
<li><a href='#fmVaRDecomp'><p>Decompose VaR into individual factor contributions</p></a></li>
<li><a href='#paFm'><p>Compute cumulative mean attribution for factor models</p></a></li>
<li><a href='#plot.pafm'><p>plot <code>"pafm"</code> object</p></a></li>
<li><a href='#plot.tsfm'><p>Plots from a fitted time series factor model</p></a></li>
<li><a href='#plot.tsfmUpDn'><p>Plot actual against fitted values of up and down market time series factor model</p></a></li>
<li><a href='#predict.tsfm'><p>Predicts asset returns based on a fitted time series factor model</p></a></li>
<li><a href='#predict.tsfmUpDn'><p>Predicts asset returns based on a fitted up and down market time series factor model</p></a></li>
<li><a href='#print.pafm'><p>Print object of class <code>"pafm"</code>.</p></a></li>
<li><a href='#print.tsfm'><p>Prints a fitted time series factor model</p></a></li>
<li><a href='#print.tsfmUpDn'><p>Prints out a fitted up and down market time series factor model object</p></a></li>
<li><a href='#summary.pafm'><p>summary <code>"pafm"</code> object.</p></a></li>
<li><a href='#summary.tsfm'><p>Summarizing a fitted time series factor model</p></a></li>
<li><a href='#summary.tsfmUpDn'><p>Summarizing a fitted up and down market time series factor model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Time Series Factor Models for Asset Returns</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-27</td>
</tr>
<tr>
<td>Description:</td>
<td>Supports teaching methods of estimating and testing time series
    factor models for use in robust portfolio construction and analysis. Unique
    in providing not only classical least squares, but also modern robust model
    fitting methods which are not much influenced by outliers. Includes
    returns and risk decompositions, with user choice of  standard deviation,
    value-at-risk, and expected shortfall risk measures. "Robust Statistics
    Theory and Methods (with R)", R. A. Maronna, R. D. Martin, V. J. Yohai, 
    M. Salibian-Barrera (2019) &lt;<a href="https://doi.org/10.1002%2F9781119214656">doi:10.1002/9781119214656</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>boot, data.table, lars, lattice, leaps, PerformanceAnalytics,
PortfolioAnalytics, R.cache, corpcor, methods, quadprog,
RobStatTM, robustbase, sandwich, sn, xts, zoo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>corrplot, HH, lmtest, R.rsp, rugarch, strucchange, tinytest</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/robustport/facmodTS">https://github.com/robustport/facmodTS</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-08 21:25:50 UTC; marti</td>
</tr>
<tr>
<td>Author:</td>
<td>Doug Martin [cre, aut],
  Eric Zivot [aut],
  Sangeetha Srinivasan [aut],
  Avinash Acharya [ctb],
  Yi-An Chen [ctb],
  Kirk Li [ctb],
  Lingjie Yi [ctb],
  Justin Shea [ctb],
  Mido Shammaa [ctb],
  Jon Spinney [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Doug Martin &lt;martinrd3d@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-09 07:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='facmodTS-package'>facmodTS: Time Series Factor Models for Asset Returns</h2><span id='topic+facmodTS'></span><span id='topic+facmodTS-package'></span>

<h3>Description</h3>

<p>Supports teaching methods of estimating and testing time series factor models for use in robust portfolio construction and analysis. Unique in providing not only classical least squares, but also modern robust model fitting methods which are not much influenced by outliers. Includes returns and risk decompositions, with user choice of standard deviation, value-at-risk, and expected shortfall risk measures. &quot;Robust Statistics Theory and Methods (with R)&quot;, R. A. Maronna, R. D. Martin, V. J. Yohai, M. Salibian-Barrera (2019) <a href="https://doi.org/10.1002/9781119214656">doi:10.1002/9781119214656</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Doug Martin <a href="mailto:martinrd3d@gmail.com">martinrd3d@gmail.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Eric Zivot
</p>
</li>
<li><p> Sangeetha Srinivasan
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Avinash Acharya [contributor]
</p>
</li>
<li><p> Yi-An Chen [contributor]
</p>
</li>
<li><p> Kirk Li [contributor]
</p>
</li>
<li><p> Lingjie Yi [contributor]
</p>
</li>
<li><p> Justin Shea [contributor]
</p>
</li>
<li><p> Mido Shammaa [contributor]
</p>
</li>
<li><p> Jon Spinney [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/robustport/facmodTS">https://github.com/robustport/facmodTS</a>
</p>
</li></ul>


<hr>
<h2 id='fitTsfm'>Fit a time series factor model using time series regression</h2><span id='topic+fitTsfm'></span><span id='topic+coef.tsfm'></span><span id='topic+fitted.tsfm'></span><span id='topic+residuals.tsfm'></span>

<h3>Description</h3>

<p>Fits a time series (a.k.a. macroeconomic) factor model for one 
or more asset returns or excess returns using time series regression. 
Users can choose between ordinary least squares-LS, discounted least 
squares-DLS (or) robust regression. Several variable selection options  
including Stepwise, Subsets, Lars are available as well. An object of class 
<code>"tsfm"</code> is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitTsfm(
  asset.names,
  factor.names,
  mkt.name = NULL,
  rf.name = NULL,
  data = data,
  fit.method = c("LS", "DLS", "Robust"),
  variable.selection = c("none", "stepwise", "subsets", "lars"),
  control = fitTsfm.control(),
  ...
)

## S3 method for class 'tsfm'
coef(object, ...)

## S3 method for class 'tsfm'
fitted(object, ...)

## S3 method for class 'tsfm'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitTsfm_+3A_asset.names">asset.names</code></td>
<td>
<p>vector of syntactically valid asset names, whose returns are the dependent 
variable in the factor model.</p>
</td></tr>
<tr><td><code id="fitTsfm_+3A_factor.names">factor.names</code></td>
<td>
<p>vector containing syntactically valid names of the factors.</p>
</td></tr>
<tr><td><code id="fitTsfm_+3A_mkt.name">mkt.name</code></td>
<td>
<p>syntactically valid name of the column for market returns. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="fitTsfm_+3A_rf.name">rf.name</code></td>
<td>
<p>syntactically valid name of the column for the risk free rate; if excess returns 
should be calculated for all assets and factors. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="fitTsfm_+3A_data">data</code></td>
<td>
<p>vector, matrix, data.frame, xts, timeSeries or zoo object
containing the columns <code>asset.names</code>, <code>factor.names</code>, and 
optionally, <code>mkt.name</code> and <code>rf.name</code>.</p>
</td></tr>
<tr><td><code id="fitTsfm_+3A_fit.method">fit.method</code></td>
<td>
<p>the estimation method, one of &quot;LS&quot;, &quot;DLS&quot; or &quot;Robust&quot;. 
See details. Default is &quot;LS&quot;.</p>
</td></tr>
<tr><td><code id="fitTsfm_+3A_variable.selection">variable.selection</code></td>
<td>
<p>the variable selection method, one of &quot;none&quot;, 
&quot;stepwise&quot;,&quot;subsets&quot;,&quot;lars&quot;. See details. Default is &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="fitTsfm_+3A_control">control</code></td>
<td>
<p>list of control parameters. Refer to 
<code><a href="#topic+fitTsfm.control">fitTsfm.control</a></code> for details.</p>
</td></tr>
<tr><td><code id="fitTsfm_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+fitTsfm.control">fitTsfm.control</a></code></p>
</td></tr>
<tr><td><code id="fitTsfm_+3A_object">object</code></td>
<td>
<p>a fit object of class <code>tsfm</code> which is returned by 
<code>fitTsfm</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Typically, factor models are fit using excess returns. <code>rf.name</code> gives 
the option to supply a risk free rate variable to subtract from each asset 
return and factor to compute excess returns. 
</p>
<p>Estimation method &quot;LS&quot; corresponds to ordinary least squares using 
<code><a href="stats.html#topic+lm">lm</a></code>, &quot;DLS&quot; is discounted least squares (weighted least 
squares with exponentially declining weights that sum to unity), and, 
&quot;Robust&quot; is robust regression (using <code><a href="RobStatTM.html#topic+lmrobdetMM">lmrobdetMM</a></code>). 
</p>
<p>If <code>variable.selection="none"</code>, uses all the factors and performs no 
variable selection. Whereas, &quot;stepwise&quot; performs traditional stepwise 
LS or Robust regression (using <code><a href="stats.html#topic+step">step</a></code> or 
<code><a href="RobStatTM.html#topic+step.lmrobdetMM">step.lmrobdetMM</a></code>), that starts from the initial set of 
factors and adds/subtracts factors only if the regression fit, as measured 
by the Bayesian Information Criterion (BIC) or Akaike Information Criterion 
(AIC), improves. And, &quot;subsets&quot; enables subsets selection using 
<code><a href="leaps.html#topic+regsubsets">regsubsets</a></code>; chooses the best performing subset of any 
given size or within a range of subset sizes. Different methods such as 
exhaustive search (default), forward or backward stepwise, or sequential 
replacement can be employed. See <code><a href="#topic+fitTsfm.control">fitTsfm.control</a></code> for more 
details on the control arguments.
</p>
<p><code>variable.selection="lars"</code> corresponds to least angle regression 
using <code><a href="lars.html#topic+lars">lars</a></code> with variants &quot;lasso&quot; (default), &quot;lar&quot;, 
&quot;stepwise&quot; or &quot;forward.stagewise&quot;. Note: If <code>variable.selection="lars"</code>, 
<code>fit.method</code> will be ignored.
</p>
<p>Argument <code>mkt.name</code> can be used to add market-timing factors to any of 
the above methods. Please refer to <code><a href="#topic+fitTsfmMT">fitTsfmMT</a></code>, a wrapper to 
<code>fitTsfm</code> for details.  
</p>


<h4>Data Processing</h4>

<p>Note about NAs: Before model fitting, incomplete cases are removed for 
every asset (return data combined with respective factors' return data) 
using <code><a href="stats.html#topic+na.omit">na.omit</a></code>. Otherwise, all observations in 
<code>data</code> are included.
</p>
<p>Note about <code>asset.names</code> and <code>factor.names</code>: Spaces in column 
names of <code>data</code> will be converted to periods as <code>fitTsfm</code> works 
with <code>xts</code> objects internally and colnames won't be left as they are.
</p>



<h3>Value</h3>

<p><code>fitTsfm</code> returns an object of class <code>"tsfm"</code> for which 
<code>print</code>, <code>plot</code>, <code>predict</code> and <code>summary</code> methods exist. 
</p>
<p>The generic functions <code>coef</code>, <code>fitted</code> and  <code>residuals</code> 
extract various useful features of the fit object. 
Additionally, <code>fmCov</code> computes the covariance matrix for asset returns 
based on the fitted factor model.
</p>
<p>An object of class <code>"tsfm"</code> is a list containing the following 
components:
</p>
<table role = "presentation">
<tr><td><code>asset.fit</code></td>
<td>
<p>list of fitted objects for each asset. Each object is of 
class <code>lm</code> if <code>fit.method="LS" or "DLS"</code>, class <code>lmrobdetMM</code> if 
the <code>fit.method="Robust"</code>, or class <code>lars</code> if 
<code>variable.selection="lars"</code>.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>N x 1 data.frame of estimated alphas.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>N x K data.frame of estimated betas.</p>
</td></tr>
<tr><td><code>r2</code></td>
<td>
<p>length-N vector of R-squared values.</p>
</td></tr>
<tr><td><code>resid.sd</code></td>
<td>
<p>length-N vector of residual standard deviations.</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>xts data object of fitted values; iff 
<code>variable.selection="lars"</code></p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched function call.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>xts data object containing the asset(s) and factor(s) returns.</p>
</td></tr>
<tr><td><code>asset.names</code></td>
<td>
<p>syntactically valid asset.names as input.</p>
</td></tr>
<tr><td><code>factor.names</code></td>
<td>
<p>syntactically valid factor.names as input.</p>
</td></tr>
<tr><td><code>mkt.name</code></td>
<td>
<p>syntactically valid mkt.name as input</p>
</td></tr>
<tr><td><code>fit.method</code></td>
<td>
<p>fit.method as input.</p>
</td></tr>
<tr><td><code>variable.selection</code></td>
<td>
<p>variable.selection as input.</p>
</td></tr>
</table>
<p>Where N is the number of assets, K is the number of factors and T is the 
number of time periods.
</p>


<h3>Author(s)</h3>

<p>Eric Zivot, Sangeetha Srinivasan and Yi-An Chen.
</p>


<h3>References</h3>

<p>Christopherson, J. A., Carino, D. R., &amp; Ferson, W. E. (2009). Portfolio 
performance measurement and benchmarking. McGraw Hill Professional.
</p>
<p>Efron, B., Hastie, T., Johnstone, I., &amp; Tibshirani, R. (2004). Least angle 
regression. The Annals of statistics, 32(2), 407-499. 
</p>
<p>Hastie, T., Tibshirani, R., Friedman, J., Hastie, T., Friedman, J., &amp; 
Tibshirani, R. (2009). The elements of statistical learning (Vol. 2, No. 1). 
New York: Springer.
</p>


<h3>See Also</h3>

<p>The <code>tsfm</code> methods for generic functions: 
<code><a href="#topic+plot.tsfm">plot.tsfm</a></code>, <code><a href="#topic+predict.tsfm">predict.tsfm</a></code>, 
<code><a href="#topic+print.tsfm">print.tsfm</a></code> and <code><a href="#topic+summary.tsfm">summary.tsfm</a></code>. 
</p>
<p>And, the following extractor functions: <code><a href="stats.html#topic+coef">coef</a></code>, 
<code><a href="stats.html#topic+fitted">fitted</a></code>, <code><a href="stats.html#topic+residuals">residuals</a></code>,
<code><a href="#topic+fmCov">fmCov</a></code>, <code><a href="#topic+fmSdDecomp">fmSdDecomp</a></code>, <code><a href="#topic+fmVaRDecomp">fmVaRDecomp</a></code> 
and <code><a href="#topic+fmEsDecomp">fmEsDecomp</a></code>.
</p>
<p><code><a href="#topic+paFm">paFm</a></code> for Performance Attribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # load data
data(managers, package = 'PerformanceAnalytics')

fit &lt;- fitTsfm(asset.names = colnames(managers[,(1:6)]),
               factor.names = colnames(managers[,(7:9)]), 
               data=managers)
summary(fit)
fitted(fit)

# example using "subsets" variable selection
fit.sub &lt;- fitTsfm(asset.names=colnames(managers[,(1:6)]),
                   factor.names=colnames(managers[,(7:9)]), 
                   data=managers, 
                   variable.selection="subsets", 
                   method="exhaustive", 
                   nvmin=2) 

# example using "lars" variable selection and subtracting risk-free rate
fit.lar &lt;- fitTsfm(asset.names=colnames(managers[,(1:6)]),
                   factor.names=colnames(managers[,(7:9)]), 
                   rf.name="US 3m TR", 
                   data=managers, 
                   variable.selection="lars", 
                   lars.criterion="cv") 
</code></pre>

<hr>
<h2 id='fitTsfm.control'>List of control parameters for <code>fitTsfm</code></h2><span id='topic+fitTsfm.control'></span>

<h3>Description</h3>

<p>Creates a list of control parameters for <code><a href="#topic+fitTsfm">fitTsfm</a></code>. 
All control parameters that are not passed to this function are set to 
default values. This function is meant for internal use only!!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitTsfm.control(
  decay = 0.95,
  weights,
  model = TRUE,
  x = FALSE,
  y = FALSE,
  qr = TRUE,
  nrep = NULL,
  bb = 0.5,
  efficiency = 0.95,
  family = "mopt",
  tuning.psi,
  tuning.chi,
  compute.rd = FALSE,
  corr.b = TRUE,
  split.type = "f",
  initial = "S",
  max.it = 100,
  refine.tol = 1e-07,
  rel.tol = 1e-07,
  refine.PY = 10,
  solve.tol = 1e-07,
  trace.lev = 0,
  psc_keep = 0.5,
  resid_keep_method = "threshold",
  resid_keep_thresh = 2,
  resid_keep_prop = 0.2,
  py_maxit = 20,
  py_eps = 1e-05,
  mscale_maxit = 50,
  mscale_tol = 1e-06,
  mscale_rho_fun = "bisquare",
  scope,
  scale,
  direction,
  steps = 1000,
  k = 2,
  nvmin = 1,
  nvmax = 8,
  force.in = NULL,
  force.out = NULL,
  method,
  really.big = FALSE,
  type,
  normalize = TRUE,
  eps = .Machine$double.eps,
  max.steps,
  plot.it = FALSE,
  lars.criterion = "Cp",
  K = 10
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitTsfm.control_+3A_decay">decay</code></td>
<td>
<p>a scalar in (0, 1] to specify the decay factor for &quot;DLS&quot;. 
Default is 0.95.</p>
</td></tr>
<tr><td><code id="fitTsfm.control_+3A_weights">weights</code></td>
<td>
<p>an optional vector of weights to be used in the fitting 
process for <code>fit.method="LS","Robust"</code>, or 
<code>variable.selection="subsets"</code>. Should be <code>NULL</code> or a numeric 
vector. The length of <code>weights</code> must be the same as the number of 
observations. The weights must be nonnegative and it is strongly 
recommended that they be strictly positive.</p>
</td></tr>
<tr><td><code id="fitTsfm.control_+3A_model">model</code>, <code id="fitTsfm.control_+3A_x">x</code>, <code id="fitTsfm.control_+3A_y">y</code>, <code id="fitTsfm.control_+3A_qr">qr</code></td>
<td>
<p>logicals passed to <code>lm</code> for 
<code>fit.method="LS"</code>. If <code>TRUE</code> the corresponding components of the 
fit (the model frame, the model matrix, the response, the QR decomposition) 
are returned.</p>
</td></tr>
<tr><td><code id="fitTsfm.control_+3A_nrep">nrep</code></td>
<td>
<p>the number of random subsamples to be drawn for 
<code>fit.method="Robust"</code>. If the data set is small and &quot;Exhaustive&quot; 
resampling is being used, the value of <code>nrep</code> is ignored.</p>
</td></tr>
<tr><td><code id="fitTsfm.control_+3A_bb">bb</code></td>
<td>
<p>tuning constant (between 0 and 1/2) for the M-scale used to compute the initial S-estimator. It
determines the robustness (breakdown point) of the resulting MM-estimator, which is
<code>bb</code>. Defaults to 0.5.</p>
</td></tr>
<tr><td><code id="fitTsfm.control_+3A_efficiency">efficiency</code></td>
<td>
<p>desired asymptotic efficiency of the final regression M-estimator. Defaults to 0.85.</p>
</td></tr>
<tr><td><code id="fitTsfm.control_+3A_family">family</code></td>
<td>
<p>string specifying the name of the family of loss function to be used (current valid
options are &quot;bisquare&quot;, &quot;optimal&quot; and &quot;modopt&quot; from the RobStatTM package). Incomplete entries will be matched to
the current valid options.</p>
</td></tr>
<tr><td><code id="fitTsfm.control_+3A_tuning.psi">tuning.psi</code></td>
<td>
<p>tuning parameters for the regression M-estimator computed with a rho function
as specified with argument <code>family</code>. If missing, it is computed inside <code>lmrobdet.control</code> to match
the value of <code>efficiency</code> according to the family of rho functions specified in <code>family</code>.
Appropriate values for <code>tuning.psi</code> for a given desired efficiency for Gaussian errors
can be constructed using the functions <code><a href="RobStatTM.html#topic+bisquare">bisquare</a></code>, <code><a href="RobStatTM.html#topic+mopt">mopt</a></code> and <code><a href="RobStatTM.html#topic+opt">opt</a></code>.</p>
</td></tr>
<tr><td><code id="fitTsfm.control_+3A_tuning.chi">tuning.chi</code></td>
<td>
<p>tuning constant for the function used to compute the M-scale
used for the initial S-estimator. If missing, it is computed inside <code>lmrobdet.control</code> to match
the value of <code>bb</code> according to the family of rho functions specified in <code>family</code>.</p>
</td></tr>
<tr><td><code id="fitTsfm.control_+3A_compute.rd">compute.rd</code></td>
<td>
<p>logical value indicating whether robust leverage distances need to be computed.</p>
</td></tr>
<tr><td><code id="fitTsfm.control_+3A_corr.b">corr.b</code></td>
<td>
<p>logical value indicating whether a finite-sample correction should be applied
to the M-scale parameter <code>bb</code>.</p>
</td></tr>
<tr><td><code id="fitTsfm.control_+3A_split.type">split.type</code></td>
<td>
<p>determines how categorical and continuous variables are split. See
<code><a href="robustbase.html#topic+splitFrame">splitFrame</a></code>.</p>
</td></tr>
<tr><td><code id="fitTsfm.control_+3A_initial">initial</code></td>
<td>
<p>string specifying the initial value for the M-step of the MM-estimator. Valid
options are <code>'S'</code>, for an S-estimator and <code>'MS'</code> for an M-S estimator which is
appropriate when there are categorical explanatory variables in the model.</p>
</td></tr>
<tr><td><code id="fitTsfm.control_+3A_max.it">max.it</code></td>
<td>
<p>maximum number of IRWLS iterations for the MM-estimator</p>
</td></tr>
<tr><td><code id="fitTsfm.control_+3A_refine.tol">refine.tol</code></td>
<td>
<p>relative convergence tolerance for the S-estimator</p>
</td></tr>
<tr><td><code id="fitTsfm.control_+3A_rel.tol">rel.tol</code></td>
<td>
<p>relative convergence tolerance for the IRWLS iterations for the MM-estimator</p>
</td></tr>
<tr><td><code id="fitTsfm.control_+3A_refine.py">refine.PY</code></td>
<td>
<p>number of refinement steps for the Pen~a-Yohai candidates</p>
</td></tr>
<tr><td><code id="fitTsfm.control_+3A_solve.tol">solve.tol</code></td>
<td>
<p>relative tolerance for inversion</p>
</td></tr>
<tr><td><code id="fitTsfm.control_+3A_trace.lev">trace.lev</code></td>
<td>
<p>positive values (increasingly) provide details on the progress of the MM-algorithm</p>
</td></tr>
<tr><td><code id="fitTsfm.control_+3A_psc_keep">psc_keep</code></td>
<td>
<p>For pyinit, proportion of observations to remove based on PSCs. The effective proportion of removed
observations is adjusted according to the sample size to be <code>prosac*(1-p/n)</code>. See <code><a href="pyinit.html#topic+pyinit">pyinit</a></code>.</p>
</td></tr>
<tr><td><code id="fitTsfm.control_+3A_resid_keep_method">resid_keep_method</code></td>
<td>
<p>For pyinit, how to clean the data based on large residuals. If
<code>"threshold"</code>, all observations with scaled residuals larger than <code>C.res</code> will
be removed, if <code>"proportion"</code>, observations with the largest <code>prop</code> residuals will
be removed. See <code><a href="pyinit.html#topic+pyinit">pyinit</a></code>.</p>
</td></tr>
<tr><td><code id="fitTsfm.control_+3A_resid_keep_thresh">resid_keep_thresh</code></td>
<td>
<p>See parameter <code>resid_keep_method</code> above. See <code><a href="pyinit.html#topic+pyinit">pyinit</a></code>.</p>
</td></tr>
<tr><td><code id="fitTsfm.control_+3A_resid_keep_prop">resid_keep_prop</code></td>
<td>
<p>See parameter <code>resid_keep_method</code> above. See <code><a href="pyinit.html#topic+pyinit">pyinit</a></code>.</p>
</td></tr>
<tr><td><code id="fitTsfm.control_+3A_py_maxit">py_maxit</code></td>
<td>
<p>Maximum number of iterations. See <code><a href="pyinit.html#topic+pyinit">pyinit</a></code>.</p>
</td></tr>
<tr><td><code id="fitTsfm.control_+3A_py_eps">py_eps</code></td>
<td>
<p>Relative tolerance for convergence.  See <code><a href="pyinit.html#topic+pyinit">pyinit</a></code>.</p>
</td></tr>
<tr><td><code id="fitTsfm.control_+3A_mscale_maxit">mscale_maxit</code></td>
<td>
<p>Maximum number of iterations for the M-scale algorithm. See <code><a href="pyinit.html#topic+pyinit">pyinit</a></code>.</p>
</td></tr>
<tr><td><code id="fitTsfm.control_+3A_mscale_tol">mscale_tol</code></td>
<td>
<p>Convergence tolerance for the M-scale algorithm. See <code><a href="pyinit.html#topic+pyinit">pyinit</a></code>.</p>
</td></tr>
<tr><td><code id="fitTsfm.control_+3A_mscale_rho_fun">mscale_rho_fun</code></td>
<td>
<p>String indicating the loss function used for the M-scale. See <code><a href="pyinit.html#topic+pyinit">pyinit</a></code>.</p>
</td></tr>
<tr><td><code id="fitTsfm.control_+3A_scope">scope</code></td>
<td>
<p>defines the range of models examined in the <code>"stepwise"</code> 
search. This should be either a single formula, or a list containing 
components <code>upper</code> and <code>lower</code>, both formulae. See 
<code><a href="stats.html#topic+step">step</a></code> for how to specify the formulae and usage.</p>
</td></tr>
<tr><td><code id="fitTsfm.control_+3A_scale">scale</code></td>
<td>
<p>optional parameter for <code>variable.selection="stepwise"</code>. 
The argument is passed to <code><a href="stats.html#topic+step">step</a></code> or 
<code><a href="RobStatTM.html#topic+step.lmrobdetMM">step.lmrobdetMM</a></code> as appropriate.</p>
</td></tr>
<tr><td><code id="fitTsfm.control_+3A_direction">direction</code></td>
<td>
<p>the mode of <code>"stepwise"</code> search, can be one of &quot;both&quot;, 
&quot;backward&quot;, or &quot;forward&quot;, with a default of &quot;both&quot;. If the <code>scope</code> 
argument is missing the default for <code>direction</code> is &quot;backward&quot;.</p>
</td></tr>
<tr><td><code id="fitTsfm.control_+3A_steps">steps</code></td>
<td>
<p>the maximum number of steps to be considered for 
<code>"stepwise"</code>. Default is 1000 (essentially as many as required). It is 
typically used to stop the process early.</p>
</td></tr>
<tr><td><code id="fitTsfm.control_+3A_k">k</code></td>
<td>
<p>the multiple of the number of degrees of freedom used for the 
penalty in <code>"stepwise"</code>. Only <code>k = 2</code> gives the genuine AIC. 
<code>k = log(n)</code> is sometimes referred to as BIC or SBC. Default is 2.</p>
</td></tr>
<tr><td><code id="fitTsfm.control_+3A_nvmin">nvmin</code></td>
<td>
<p>minimum size of subsets to examine for <code>"subsets"</code>. 
Default is 1.</p>
</td></tr>
<tr><td><code id="fitTsfm.control_+3A_nvmax">nvmax</code></td>
<td>
<p>maximum size of subsets to examine for <code>"subsets"</code>. 
Default is 8.</p>
</td></tr>
<tr><td><code id="fitTsfm.control_+3A_force.in">force.in</code></td>
<td>
<p>index to columns of design matrix that should be in all 
models for <code>"subsets"</code>. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="fitTsfm.control_+3A_force.out">force.out</code></td>
<td>
<p>index to columns of design matrix that should be in no 
models for <code>"subsets"</code>. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="fitTsfm.control_+3A_method">method</code></td>
<td>
<p>one of &quot;exhaustive&quot;, &quot;forward&quot;, &quot;backward&quot; or &quot;seqrep&quot; 
(sequential replacement) to specify the type of subset search/selection. 
Required if <code>variable selection="subsets"</code> is chosen. Default is 
&quot;exhaustive&quot;.</p>
</td></tr>
<tr><td><code id="fitTsfm.control_+3A_really.big">really.big</code></td>
<td>
<p>option for <code>"subsets"</code>; Must be <code>TRUE</code> to 
perform exhaustive search on more than 50 variables.</p>
</td></tr>
<tr><td><code id="fitTsfm.control_+3A_type">type</code></td>
<td>
<p>option for <code>"lars"</code>. One of &quot;lasso&quot;, &quot;lar&quot;, 
&quot;forward.stagewise&quot; or &quot;stepwise&quot;. The names can be abbreviated to any 
unique substring. Default is &quot;lasso&quot;.</p>
</td></tr>
<tr><td><code id="fitTsfm.control_+3A_normalize">normalize</code></td>
<td>
<p>option for <code>"lars"</code>. If <code>TRUE</code>, each variable is 
standardized to have unit L2 norm, otherwise they are left alone. Default 
is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="fitTsfm.control_+3A_eps">eps</code></td>
<td>
<p>option for <code>"lars"</code>; An effective zero.</p>
</td></tr>
<tr><td><code id="fitTsfm.control_+3A_max.steps">max.steps</code></td>
<td>
<p>Limit the number of steps taken for <code>"lars"</code>; the 
default is <code>8 * min(m, n-intercept)</code>, with <code>m</code> the number of 
variables, and <code>n</code> the number of samples. For <code>type="lar"</code> or 
<code>type="stepwise"</code>, the maximum number of steps is 
<code>min(m,n-intercept)</code>. For <code>type="lasso"</code> and especially 
<code>type="forward.stagewise"</code>, there can be many more terms, because 
although no more than <code>min(m,n-intercept)</code> variables can be active 
during any step, variables are frequently droppped and added as the 
algorithm proceeds. Although the default usually guarantees that the 
algorithm has proceeded to the saturated fit, users should check.</p>
</td></tr>
<tr><td><code id="fitTsfm.control_+3A_plot.it">plot.it</code></td>
<td>
<p>option to plot the output for <code><a href="lars.html#topic+cv.lars">cv.lars</a></code>. 
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fitTsfm.control_+3A_lars.criterion">lars.criterion</code></td>
<td>
<p>an option to assess model selection for the 
<code>"lars"</code> method; one of &quot;Cp&quot; or &quot;cv&quot;. See details. Default is &quot;Cp&quot;.</p>
</td></tr>
<tr><td><code id="fitTsfm.control_+3A_k">K</code></td>
<td>
<p>number of folds for computing the K-fold cross-validated mean 
squared prediction error for <code>"lars"</code>. Default is 10.</p>
</td></tr>
<tr><td><code id="fitTsfm.control_+3A_trace">trace</code></td>
<td>
<p>If positive (or, not <code>FALSE</code>), info is printed during the 
running of  <code><a href="stats.html#topic+step">step</a></code>, <code><a href="lars.html#topic+lars">lars</a></code> or 
<code><a href="lars.html#topic+cv.lars">cv.lars</a></code> as relevant. Larger values may give more 
detailed information. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This control function is used to process optional arguments passed 
via <code>...</code> to <code>fitTsfm</code>. These arguments are validated and defaults
are set if necessary before being passed internally to one of the following
functions: <code><a href="stats.html#topic+lm">lm</a></code>, <code><a href="RobStatTM.html#topic+lmrobdetMM">lmrobdetMM</a></code>, 
<code><a href="stats.html#topic+step">step</a></code>, <code><a href="leaps.html#topic+regsubsets">regsubsets</a></code>, 
<code><a href="lars.html#topic+lars">lars</a></code> and <code><a href="lars.html#topic+cv.lars">cv.lars</a></code>. See their 
respective help files for more details. The arguments to each of these 
functions are listed above in approximately the same order for user 
convenience.
</p>
<p>The scalar <code>decay</code> is used by <code><a href="#topic+fitTsfm">fitTsfm</a></code> to compute 
exponentially decaying weights for <code>fit.method="DLS"</code>. Alternately, one 
can directly specify <code>weights</code>, a weights vector, to be used with 
&quot;LS&quot; or &quot;Robust&quot;. Especially when fitting multiple assets, care should be 
taken to ensure that the length of the weights vector matches the number of
observations (excluding cases ignored due to NAs).
</p>
<p><code>lars.criterion</code> selects the criterion (one of &quot;Cp&quot; or &quot;cv&quot;) to 
determine the best fitted model for <code>variable.selection="lars"</code>. The 
&quot;Cp&quot; statistic (defined in page 17 of Efron et al. (2004)) is calculated 
using <code><a href="lars.html#topic+summary.lars">summary.lars</a></code>. While, &quot;cv&quot; computes the K-fold 
cross-validated mean squared prediction error using 
<code><a href="lars.html#topic+cv.lars">cv.lars</a></code>.
</p>


<h3>Value</h3>

<p>A list of the above components. This is only meant to be used by 
<code>fitTsfm</code>.
</p>


<h3>Author(s)</h3>

<p>Sangeetha Srinivasan
</p>


<h3>References</h3>

<p>Efron, B., Hastie, T., Johnstone, I., &amp; Tibshirani, R. (2004). Least angle 
regression. The Annals of statistics, 32(2), 407-499.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitTsfm">fitTsfm</a></code>, <code><a href="stats.html#topic+lm">lm</a></code>, 
<code><a href="RobStatTM.html#topic+lmrobdetMM">lmrobdetMM</a></code>, <code><a href="stats.html#topic+step">step</a></code>, 
<code><a href="leaps.html#topic+regsubsets">regsubsets</a></code>, <code><a href="lars.html#topic+lars">lars</a></code> and 
<code><a href="lars.html#topic+cv.lars">cv.lars</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# check argument list passed by fitTsfm.control
tsfm.ctrl &lt;- fitTsfm.control(method="exhaustive", nvmin=2)
print(tsfm.ctrl)


# used internally by fitTsfm in the example below
 # load data
data(managers, package = 'PerformanceAnalytics')
 # Make syntactically valid column names
colnames(managers)
colnames(managers) &lt;- make.names( colnames(managers))
colnames(managers)

fit &lt;- fitTsfm(asset.names=colnames(managers[,(1:6)]),
               factor.names=colnames(managers[,(7:9)]), 
               data=managers, variable.selection="subsets", 
               method="exhaustive", nvmin=2)

</code></pre>

<hr>
<h2 id='fitTsfmLagLeadBeta'>Fit a lagged and lead Betas factor model using time series regression</h2><span id='topic+fitTsfmLagLeadBeta'></span>

<h3>Description</h3>

<p>This is a wrapper function to fits a time series lagged Betas factor model for one 
or more asset returns or excess returns using time series regression. 
Users can choose between ordinary least squares-LS, discounted least 
squares-DLS (or) robust regression like <code>fitTsfm</code>.An object of class 
<code>"tsfm"</code> is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitTsfmLagLeadBeta(
  asset.names,
  mkt.name,
  rf.name = NULL,
  data = data,
  fit.method = c("LS", "DLS", "Robust"),
  LagLeadBeta = 1,
  LagOnly = FALSE,
  control = fitTsfm.control(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitTsfmLagLeadBeta_+3A_asset.names">asset.names</code></td>
<td>
<p>vector containing names of assets, whose returns or 
excess returns are the dependent variable.</p>
</td></tr>
<tr><td><code id="fitTsfmLagLeadBeta_+3A_mkt.name">mkt.name</code></td>
<td>
<p>name of the column for market returns. It 
is required for a lagged Betas factor model.</p>
</td></tr>
<tr><td><code id="fitTsfmLagLeadBeta_+3A_rf.name">rf.name</code></td>
<td>
<p>name of the column of risk free rate variable to calculate 
excess returns for all assets (in <code>asset.names</code>) and the market factor (in 
<code>mkt.name</code>).Default is NULL, and no action is taken.</p>
</td></tr>
<tr><td><code id="fitTsfmLagLeadBeta_+3A_data">data</code></td>
<td>
<p>vector, matrix, data.frame, xts, timeSeries or zoo object
containing column(s) named in <code>asset.names</code>, <code>factor.names</code> and 
optionally, <code>mkt.name</code> and <code>rf.name</code>.</p>
</td></tr>
<tr><td><code id="fitTsfmLagLeadBeta_+3A_fit.method">fit.method</code></td>
<td>
<p>the estimation method, one of &quot;LS&quot;, &quot;DLS&quot; or &quot;Robust&quot;. 
See details. Default is &quot;LS&quot;.</p>
</td></tr>
<tr><td><code id="fitTsfmLagLeadBeta_+3A_lagleadbeta">LagLeadBeta</code></td>
<td>
<p>A integer number to specify numbers of lags (and leads when LagOnly is FALSE) 
of Betas to 
include in the model. The Default is 1.</p>
</td></tr>
<tr><td><code id="fitTsfmLagLeadBeta_+3A_lagonly">LagOnly</code></td>
<td>
<p>Flag variable to only include the lags (or have both lags and leads). 
The Default is FALSE (both lags and leads).</p>
</td></tr>
<tr><td><code id="fitTsfmLagLeadBeta_+3A_control">control</code></td>
<td>
<p>list of control parameters. The default is constructed by 
the function <code><a href="#topic+fitTsfm.control">fitTsfm.control</a></code>. See the documentation for 
<code><a href="#topic+fitTsfm.control">fitTsfm.control</a></code> for details.</p>
</td></tr>
<tr><td><code id="fitTsfmLagLeadBeta_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+fitTsfm.control">fitTsfm.control</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The lagged and lead returns model estimates lagged and lead market Beta. Specifically, 
</p>
<p style="text-align: center;"><code class="reqn">r_t = \alpha + \beta_0 MKT_t + \beta^-_1 MKT_t-1 + \ldots + \beta^-_K+1 MKT_t-K 
+  \beta^+_1 MKT_t+1 + \ldots + \beta^+_K MKT_t+K \epsilon_t, t=1 \ldots T</code>
</p>

<p>where <code class="reqn">r_t</code> is the asset returns, and MKT is the market factor. It is usually 
needed for illiquid securities with stale prices. One can also report the sum of 
the lagged and lead Betas: 
</p>
<p style="text-align: center;"><code class="reqn">\beta = \beta_0 + \beta^+_1 + \beta^+_1 + \ldots + \beta^+_K + 
\beta^-_1 + \ldots + \beta^-_K </code>
</p>



<h3>Value</h3>

<p><code>fitTsfmLagLeadBeta</code> also returns an object of class <code>"tsfm"</code> like 
<code>fitTsfm</code>. The generic function such as <code>print</code>, <code>plot</code>, <code>predict</code> 
and <code>summary</code> methods exist. Also, the generic accessor functions <code>coef</code>, 
<code>fitted</code>, <code>residuals</code> and  <code>fmCov</code> can be applied as well.
</p>
<p>An object of class <code>"tsfm"</code> is a list containing the following 
components:
</p>
<table role = "presentation">
<tr><td><code>asset.fit</code></td>
<td>
<p>list of fitted objects for each asset. Each object is of 
class <code>lm</code> if <code>fit.method="LS" or "DLS"</code>, class <code>lmRob</code> if 
the <code>fit.method="Robust"</code>.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>length-N vector of estimated alphas.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>N x (L+1) matrix of estimated betas.</p>
</td></tr>
<tr><td><code>r2</code></td>
<td>
<p>length-N vector of R-squared values.</p>
</td></tr>
<tr><td><code>resid.sd</code></td>
<td>
<p>length-N vector of residual standard deviations.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched function call.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>xts data object containing the assets and factors.</p>
</td></tr>
<tr><td><code>asset.names</code></td>
<td>
<p>asset.names as input.</p>
</td></tr>
<tr><td><code>fit.method</code></td>
<td>
<p>fit.method as input.</p>
</td></tr>
</table>
<p>Where N is the number of assets, L is the number of lagged and lead market Betas and T is the 
number of time periods.
</p>


<h3>Author(s)</h3>

<p>Yi-An Chen.
</p>


<h3>References</h3>

<p>Scholes, M. and Williams, J. T. (1977). Estimating betas from non-synchronous
data, Journal of Financial Economics, vol. 5, 1977, pp. 309-327
</p>


<h3>See Also</h3>

<p>The original time series function <code><a href="#topic+fitTsfm">fitTsfm</a></code> and its generic functions
application.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## A lagged Betas model with LS fit
 
 # load data
data(managers, package = 'PerformanceAnalytics')

fit &lt;- fitTsfmLagLeadBeta(asset.names = names(managers[,(1:6)]),
                          mkt.name = "SP500 TR", rf.name = "US 3m TR", 
                          data = managers, LagLeadBeta = 2, LagOnly = TRUE)
summary(fit)
fitted(fit)

</code></pre>

<hr>
<h2 id='fitTsfmMT'>Fit a market timing time series factor model</h2><span id='topic+fitTsfmMT'></span>

<h3>Description</h3>

<p>This is a wrapper function to fit a market timing time series 
factor model for one or more asset returns or excess returns using time 
series regression. Users can choose between ordinary least squares-LS, 
discounted least squares-DLS (or) robust regression. An object of class 
<code>"tsfm"</code> is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitTsfmMT(
  asset.names,
  mkt.name,
  rf.name = NULL,
  data = data,
  fit.method = c("LS", "DLS", "Robust"),
  control = fitTsfm.control(...),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitTsfmMT_+3A_asset.names">asset.names</code></td>
<td>
<p>vector containing syntactically valid names of assets, whose returns or 
excess returns are the dependent variable.</p>
</td></tr>
<tr><td><code id="fitTsfmMT_+3A_mkt.name">mkt.name</code></td>
<td>
<p>syntactically valid name of the column for market returns (required).</p>
</td></tr>
<tr><td><code id="fitTsfmMT_+3A_rf.name">rf.name</code></td>
<td>
<p>syntactically valid name of the column of risk free rate variable to calculate 
excess returns for all assets (in <code>asset.names</code>) and the market factor 
(in <code>mkt.name</code>). Default is NULL, and no action is taken.</p>
</td></tr>
<tr><td><code id="fitTsfmMT_+3A_data">data</code></td>
<td>
<p>vector, matrix, data.frame, xts, timeSeries or zoo object
containing column(s) named in <code>asset.names</code>, <code>factor.names</code> and 
optionally, <code>mkt.name</code> and <code>rf.name</code>.</p>
</td></tr>
<tr><td><code id="fitTsfmMT_+3A_fit.method">fit.method</code></td>
<td>
<p>the estimation method, one of &quot;LS&quot;, &quot;DLS&quot; or &quot;Robust&quot;. 
See details. Default is &quot;LS&quot;.</p>
</td></tr>
<tr><td><code id="fitTsfmMT_+3A_control">control</code></td>
<td>
<p>list of control parameters passed to <code><a href="#topic+fitTsfm">fitTsfm</a></code>. 
Refer to <code><a href="#topic+fitTsfm.control">fitTsfm.control</a></code> for details.</p>
</td></tr>
<tr><td><code id="fitTsfmMT_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+fitTsfm.control">fitTsfm.control</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Market timing accounts for the price movement of the general stock market 
relative to fixed income securities. A market-timing factor is added to the 
time series regression, following Henriksson &amp; Merton (1981). Here, we use 
down.market = max(0, R_f-R_m), where Rm is the (excess) return on the market. 
The coefficient of this down-market factor can be interpreted as the number 
of &quot;free&quot; put options on the market provided by the manager's market-timings 
skills.
</p>


<h3>Value</h3>

<p>Similar to <code>fitTsfm</code>, <code>fitTsfmMT</code> also returns an object 
of class <code>"tsfm"</code>, for which <code>print</code>, <code>plot</code>, <code>predict</code> 
and <code>summary</code> methods exist. The generic accessor functions <code>coef</code>, 
<code>fitted</code>, <code>residuals</code> and <code>fmCov</code> can be applied as well.
</p>
<p>An object of class <code>"tsfm"</code> is a list containing the following 
components:
</p>
<table role = "presentation">
<tr><td><code>asset.fit</code></td>
<td>
<p>list of fitted objects for each asset. Each object is of 
class <code>lm</code> if <code>fit.method="LS" or "DLS"</code>, class <code>lmRob</code> if 
the <code>fit.method="Robust"</code>.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>length-N vector of estimated alphas.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>N x 2 matrix of estimated betas.</p>
</td></tr>
<tr><td><code>r2</code></td>
<td>
<p>length-N vector of R-squared values.</p>
</td></tr>
<tr><td><code>resid.sd</code></td>
<td>
<p>length-N vector of residual standard deviations.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched function call.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>xts data object containing the asset(s) and factor(s) returns.</p>
</td></tr>
<tr><td><code>asset.names</code></td>
<td>
<p>asset.names as input.</p>
</td></tr>
<tr><td><code>factor.names</code></td>
<td>
<p>vector containing the names of the market-timing factor 
and the market factor</p>
</td></tr>
<tr><td><code>mkt.name</code></td>
<td>
<p>mkt.name as input</p>
</td></tr>
<tr><td><code>fit.method</code></td>
<td>
<p>fit.method as input.</p>
</td></tr>
</table>
<p>Where N is the number of assets and T is the number of time periods.
</p>


<h3>Author(s)</h3>

<p>Yi-An Chen, Sangeetha Srinivasan.
</p>


<h3>References</h3>

<p>Christopherson, J. A., Carino, D. R., &amp; Ferson, W. E. (2009). Portfolio 
performance measurement and benchmarking. McGraw Hill Professional. pp.127-133
</p>
<p>Henriksson, R. D., &amp; Merton, R. C. (1981). On market timing and investment 
performance. II. Statistical procedures for evaluating forecasting skills. 
Journal of business, 513-533.
</p>
<p>Treynor, J., &amp; Mazuy, K. (1966). Can mutual funds outguess the market. 
Harvard business review, 44(4), 131-136.
</p>


<h3>See Also</h3>

<p>The original time series factor model fitting function <code><a href="#topic+fitTsfm">fitTsfm</a></code> 
and related methods.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # load data
data(managers, package = 'PerformanceAnalytics')

# example: Market-timing time series factor model with LS fit
fit &lt;- fitTsfmMT(asset.names=colnames(managers[,(1:6)]), 
                 mkt.name="SP500 TR", rf.name="US 3m TR", 
                 data=managers)
summary(fit)

</code></pre>

<hr>
<h2 id='fitTsfmUpDn'>Fit a up and down market factor model using time series regression</h2><span id='topic+fitTsfmUpDn'></span>

<h3>Description</h3>

<p>This is a wrapper function to fits a up and down market model 
for one or more asset returns or excess returns using time series regression. 
Users can choose between ordinary least squares-LS, discounted least 
squares-DLS (or) robust regression. An object of class 
<code>"tsfmUpDn"</code> is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitTsfmUpDn(
  asset.names,
  mkt.name,
  rf.name = NULL,
  data = data,
  fit.method = c("LS", "DLS", "Robust"),
  control = fitTsfm.control(...),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitTsfmUpDn_+3A_asset.names">asset.names</code></td>
<td>
<p>Vector containing syntactically valid names of assets, 
whose returns or excess returns are the dependent variable.</p>
</td></tr>
<tr><td><code id="fitTsfmUpDn_+3A_mkt.name">mkt.name</code></td>
<td>
<p>Syntactically valid name for market returns. Required for an
up/down market model.</p>
</td></tr>
<tr><td><code id="fitTsfmUpDn_+3A_rf.name">rf.name</code></td>
<td>
<p>Syntactically valid name of the risk free rate to calculate 
excess returns for all assets (in <code>asset.names</code>) and the market factor 
(in <code>mkt.name</code>). Default is <code>NULL</code>, and no action is taken.</p>
</td></tr>
<tr><td><code id="fitTsfmUpDn_+3A_data">data</code></td>
<td>
<p>vector, matrix, data.frame, xts, timeSeries or zoo object
containing column(s) named in <code>asset.names</code>, <code>factor.names</code> and 
optionally, <code>mkt.name</code> and <code>rf.name</code>.</p>
</td></tr>
<tr><td><code id="fitTsfmUpDn_+3A_fit.method">fit.method</code></td>
<td>
<p>the estimation method, one of &quot;LS&quot;, &quot;DLS&quot; or &quot;Robust&quot;. 
See details. Default is &quot;LS&quot;.</p>
</td></tr>
<tr><td><code id="fitTsfmUpDn_+3A_control">control</code></td>
<td>
<p>list of control parameters. The default is constructed by 
the function <code><a href="#topic+fitTsfm.control">fitTsfm.control</a></code>. See the documentation for 
<code><a href="#topic+fitTsfm.control">fitTsfm.control</a></code> for details.</p>
</td></tr>
<tr><td><code id="fitTsfmUpDn_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+fitTsfm.control">fitTsfm.control</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>fitTsfmUpDn</code> will use <code>fitTsfm</code> to fit a time series model for up 
and down market respectively. If risk free rate is provided, the up market is 
the excess market returns which is no less than 0.
The goal of up and down market model is to capture two different market Betas 
in the up and down markets.
</p>


<h3>Value</h3>

<p><code>fitTsfmUpDn</code> returns an object <code>tsfmUpDn</code>. It supports generic 
function such as <code>summary</code>, <code>predict</code>, <code>plot</code> and <code>print</code>.
</p>
<p>It is also a list object containing <code>Up</code> and <code>Dn</code>. Both <code>Up</code> 
and <code>Dn</code> are class of <code>"tsfm"</code>. As a result, for each list 
object, The generic function such as <code>print</code>, <code>plot</code>, <code>predict</code> 
and <code>summary</code> methods exist for both <code>Up</code> and <code>Dn</code>. Also, the 
generic accessor functions <code>coef</code>, <code>fitted</code>, <code>residuals</code> and  
<code>fmCov</code> can be applied as well.
</p>
<p>An object of class <code>"tsfmUpDn"</code> is a list containing <code>Up</code> and <code>Dn</code>:
</p>
<table role = "presentation">
<tr><td><code>Up</code></td>
<td>
<p>An object of <code>tsfm</code> fitted by <code>fitTsfm</code> for the up market;</p>
</td></tr>
<tr><td><code>Dn</code></td>
<td>
<p>An object of <code>tsfm</code> fitted by <code>fitTsfm</code> for the down market;</p>
</td></tr>
</table>
<p>and others useful items: 
</p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>
<p>Function call.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>Original data used but converted to <code>xts</code> class.</p>
</td></tr>
</table>
<p>Each object of <code>tsfm</code> contains : 
</p>
<table role = "presentation">
<tr><td><code>asset.fit</code></td>
<td>
<p>list of fitted objects for each asset. Each object is of 
class <code>lm</code> if <code>fit.method="LS" or "DLS"</code>, class <code>lmRob</code> if 
the <code>fit.method="Robust"</code></p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>length-N vector of estimated alphas.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>N x 1 matrix of estimated betas.</p>
</td></tr>
<tr><td><code>r2</code></td>
<td>
<p>length-N vector of R-squared values.</p>
</td></tr>
<tr><td><code>resid.sd</code></td>
<td>
<p>length-N vector of residual standard deviations.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched function call.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>xts data object containing the assets and factors.</p>
</td></tr>
<tr><td><code>asset.names</code></td>
<td>
<p>asset.names as input.</p>
</td></tr>
<tr><td><code>factor.names</code></td>
<td>
<p>factor.names as input.</p>
</td></tr>
<tr><td><code>fit.method</code></td>
<td>
<p>fit.method as input.</p>
</td></tr>
</table>
<p>Where N is the number of assets and T is the 
number of time periods.
</p>


<h3>Author(s)</h3>

<p>Yi-An Chen.
</p>


<h3>References</h3>

<p>Christopherson, J. A., Carino, D. R., &amp; Ferson, W. E. (2009). Portfolio 
performance measurement and benchmarking. McGraw Hill Professional.
</p>


<h3>See Also</h3>

<p>The <code>tsfmUpDn</code> methods for generic functions: 
<code><a href="#topic+plot.tsfmUpDn">plot.tsfmUpDn</a></code>, <code><a href="#topic+predict.tsfmUpDn">predict.tsfmUpDn</a></code>, 
<code><a href="#topic+print.tsfmUpDn">print.tsfmUpDn</a></code> and <code><a href="#topic+summary.tsfmUpDn">summary.tsfmUpDn</a></code>. 
</p>
<p>The original time series function <code><a href="#topic+fitTsfm">fitTsfm</a></code> and its generic 
functions application.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # load data
data(managers, package = 'PerformanceAnalytics')

# example: Up and down market factor model with LS fit
fitUpDn &lt;- fitTsfmUpDn(asset.names = colnames(managers[,(1:6)]),
                       mkt.name = "SP500 TR",
                       data = managers, 
                       fit.method = "LS")
 
 print(fitUpDn)
 summary(fitUpDn)
 
 # A list object
 fitUpDn
 summary(fitUpDn$Up)
 summary(fitUpDn$Dn)

</code></pre>

<hr>
<h2 id='fmCov'>Covariance Matrix for assets' returns from fitted factor model.</h2><span id='topic+fmCov'></span><span id='topic+fmCov.tsfm'></span><span id='topic+fmCov.sfm'></span><span id='topic+fmCov.ffm'></span>

<h3>Description</h3>

<p>Computes the covariance matrix for assets' returns based on a 
fitted factor model. This is a generic function with methods for classes 
<code>tsfm</code>, <code>sfm</code> and <code>ffm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmCov(object, ...)

## S3 method for class 'tsfm'
fmCov(object, factor.cov, use = "pairwise.complete.obs", ...)

## S3 method for class 'sfm'
fmCov(object, use = "pairwise.complete.obs", ...)

## S3 method for class 'ffm'
fmCov(object, use = "pairwise.complete.obs", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fmCov_+3A_object">object</code></td>
<td>
<p>fit object of class <code>tsfm</code>, <code>sfm</code> or <code>ffm</code>.</p>
</td></tr>
<tr><td><code id="fmCov_+3A_...">...</code></td>
<td>
<p>optional arguments passed to <code><a href="stats.html#topic+cov">cov</a></code>.</p>
</td></tr>
<tr><td><code id="fmCov_+3A_factor.cov">factor.cov</code></td>
<td>
<p>factor covariance matrix (optional); defaults to the 
sample covariance matrix.</p>
</td></tr>
<tr><td><code id="fmCov_+3A_use">use</code></td>
<td>
<p>method for computing covariances in the presence of missing 
values; one of &quot;everything&quot;, &quot;all.obs&quot;, &quot;complete.obs&quot;, &quot;na.or.complete&quot;, or 
&quot;pairwise.complete.obs&quot;. Default is &quot;pairwise.complete.obs&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>R(i, t)</code>, the return on asset <code>i</code> at time <code>t</code>, 
is assumed to follow a factor model of the form, <br /> <br /> 
<code>R(i,t) = alpha(i) + beta(i)*f(t) + e(i,t)</code>, <br /> <br />  
where, <code>alpha(i)</code> is the intercept, <code>f(t)</code> is a <code>K x 1</code> vector of 
factor returns at time <code>t</code>, <code>beta(i)</code> is a <code>1 x K</code> vector of 
factor exposures and the error terms <code>e(i,t)</code> are serially 
uncorrelated across time and contemporaneously uncorrelated across assets 
so that <code>e(i,t) ~ iid(0,sig(i)^2)</code>. Thus, the variance of asset 
<code>i</code>'s return is given by <br /> <br />
<code>var(R(i)) = beta(i)*cov(F)*tr(beta(i)) + sig(i)^2</code>. <br /> <br />
And, the <code>N x N</code> covariance matrix of asset returns is <br /> <br />
<code>var(R) = B*cov(F)*tr(B) + D</code>, <br /> <br /> 
where, B is the <code>N x K</code> matrix of factor betas and <code>D</code> is a 
diagonal matrix with <code>sig(i)^2</code> along the diagonal.
</p>
<p>The method for computing covariance can be specified via the ... 
argument. Note that the default of <code>use="pairwise.complete.obs"</code> for 
handling NAs restricts the method to &quot;pearson&quot;.
</p>


<h3>Value</h3>

<p>The computed <code>N x N</code> covariance matrix for asset returns based 
on the fitted factor model.
</p>


<h3>Author(s)</h3>

<p>Eric Zivot, Yi-An Chen and Sangeetha Srinivasan.
</p>


<h3>References</h3>

<p>Zivot, E., &amp; Jia-hui, W. A. N. G. (2006). Modeling Financial Time 
Series with S-Plus Springer-Verlag.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitTsfm">fitTsfm</a></code>
</p>
<p><code><a href="stats.html#topic+cov">cov</a></code> for more details on arguments <code>use</code> and 
<code>method</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Time Series Factor model example
 # load data
data(managers, package = 'PerformanceAnalytics')
 # Make syntactically valid column names
colnames(managers)
colnames(managers) &lt;- make.names( colnames(managers))
colnames(managers)

fit &lt;- fitTsfm(asset.names = colnames(managers[, (1:6)]), 
               factor.names = c("EDHEC.LS.EQ","SP500.TR"), 
               data = managers)                              
fmCov(fit)

</code></pre>

<hr>
<h2 id='fmEsDecomp'>Decompose ES into individual factor contributions</h2><span id='topic+fmEsDecomp'></span><span id='topic+fmEsDecomp.tsfm'></span><span id='topic+fmEsDecomp.sfm'></span><span id='topic+fmEsDecomp.ffm'></span>

<h3>Description</h3>

<p>Compute the factor contributions to Expected Tail Loss or 
Expected Shortfall (ES) of assets' returns  based on Euler's theorem, given 
the fitted factor model. The partial derivative of ES with respect to factor 
beta is computed as the expected factor return given fund return is less 
than or equal to its value-at-risk (VaR). Option to choose between 
non-parametric and Normal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmEsDecomp(object, ...)

## S3 method for class 'tsfm'
fmEsDecomp(
  object,
  factor.cov,
  p = 0.05,
  type = c("np", "normal"),
  use = "pairwise.complete.obs",
  ...
)

## S3 method for class 'sfm'
fmEsDecomp(
  object,
  factor.cov,
  p = 0.05,
  type = c("np", "normal"),
  use = "pairwise.complete.obs",
  ...
)

## S3 method for class 'ffm'
fmEsDecomp(
  object,
  factor.cov,
  p = 0.05,
  type = c("np", "normal"),
  use = "pairwise.complete.obs",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fmEsDecomp_+3A_object">object</code></td>
<td>
<p>fit object of class <code>tsfm</code>, <code>sfm</code> or <code>ffm</code>.</p>
</td></tr>
<tr><td><code id="fmEsDecomp_+3A_...">...</code></td>
<td>
<p>other optional arguments passed to <code><a href="stats.html#topic+quantile">quantile</a></code>.</p>
</td></tr>
<tr><td><code id="fmEsDecomp_+3A_factor.cov">factor.cov</code></td>
<td>
<p>optional user specified factor covariance matrix with 
named columns; defaults to the sample covariance matrix.</p>
</td></tr>
<tr><td><code id="fmEsDecomp_+3A_p">p</code></td>
<td>
<p>tail probability for calculation. Default is 0.05.</p>
</td></tr>
<tr><td><code id="fmEsDecomp_+3A_type">type</code></td>
<td>
<p>one of &quot;np&quot; (non-parametric) or &quot;normal&quot; for calculating VaR. 
Default is &quot;np&quot;.</p>
</td></tr>
<tr><td><code id="fmEsDecomp_+3A_use">use</code></td>
<td>
<p>method for computing covariances in the presence of missing 
values; one of &quot;everything&quot;, &quot;all.obs&quot;, &quot;complete.obs&quot;, &quot;na.or.complete&quot;, or 
&quot;pairwise.complete.obs&quot;. Default is &quot;pairwise.complete.obs&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The factor model for an asset's return at time <code>t</code> has the 
form <br /> <br /> <code>R(t) = beta'f(t) + e(t) = beta.star'f.star(t)</code> <br /> <br /> 
where, <code>beta.star=(beta,sig.e)</code> and <code>f.star(t)=[f(t)',z(t)]'</code>. By 
Euler's theorem, the ES of the asset's return is given by:
<br /> <br /> <code>ES.fm = sum(cES_k) = sum(beta.star_k*mES_k)</code> <br /> <br />
where, summation is across the <code>K</code> factors and the residual, 
<code>cES</code> and <code>mES</code> are the component and marginal 
contributions to <code>ES</code> respectively. The marginal contribution to ES is
defined as the expected value of <code>F.star</code>, conditional on the loss 
being less than or equal to <code>VaR.fm</code>. This is estimated as a sample 
average of the observations in that data window. 
</p>
<p>Refer to Eric Zivot's slides (referenced) for formulas pertaining to the 
calculation of Normal ES (adapted from a portfolio context to factor models).
</p>


<h3>Value</h3>

<p>A list containing 
</p>
<table role = "presentation">
<tr><td><code>ES.fm</code></td>
<td>
<p>length-N vector of factor model ES of N-asset returns.</p>
</td></tr>
<tr><td><code>mES</code></td>
<td>
<p>N x (K+1) matrix of marginal contributions to VaR.</p>
</td></tr>
<tr><td><code>cES</code></td>
<td>
<p>N x (K+1) matrix of component contributions to VaR.</p>
</td></tr>
<tr><td><code>pcES</code></td>
<td>
<p>N x (K+1) matrix of percentage component contributions to VaR.</p>
</td></tr>
</table>
<p>Where, <code>K</code> is the number of factors and N is the number of assets.
</p>


<h3>Author(s)</h3>

<p>Eric Zviot, Sangeetha Srinivasan and Yi-An Chen
</p>


<h3>References</h3>

<p>Epperlein, E., &amp; Smillie, A. (2006). Portfolio risk analysis Cracking VAR 
with kernels. RISK-LONDON-RISK MAGAZINE LIMITED-, 19(8), 70.
</p>
<p>Hallerback (2003). Decomposing Portfolio Value-at-Risk: A General Analysis. 
The Journal of Risk, 5(2), 1-18.
</p>
<p>Meucci, A. (2007). Risk contributions from generic user-defined factors. 
RISK-LONDON-RISK MAGAZINE LIMITED-, 20(6), 84. 
</p>
<p>Yamai, Y., &amp; Yoshiba, T. (2002). Comparative analyses of expected shortfall 
and value-at-risk: their estimation error, decomposition, and optimization. 
Monetary and economic studies, 20(1), 87-121.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitTsfm">fitTsfm</a></code>
for the different factor model fitting functions.
</p>
<p><code><a href="#topic+fmSdDecomp">fmSdDecomp</a></code> for factor model SD decomposition.
<code><a href="#topic+fmVaRDecomp">fmVaRDecomp</a></code> for factor model VaR decomposition.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # Time Series Factor Model
 # load data
data(managers, package = 'PerformanceAnalytics')

fit.macro &lt;- fitTsfm(asset.names=colnames(managers[,(1:6)]),
                     factor.names=colnames(managers[,(7:8)]), 
                     data=managers)
                     
ES.decomp &lt;- fmEsDecomp(fit.macro)

# get the component contributions
ES.decomp$cES


</code></pre>

<hr>
<h2 id='fmSdDecomp'>Decompose standard deviation into individual factor contributions</h2><span id='topic+fmSdDecomp'></span><span id='topic+fmSdDecomp.tsfm'></span><span id='topic+fmSdDecomp.sfm'></span><span id='topic+fmSdDecomp.ffm'></span>

<h3>Description</h3>

<p>Compute the factor contributions to standard deviation (SD) of 
assets' returns based on Euler's theorem, given the fitted factor model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmSdDecomp(object, ...)

## S3 method for class 'tsfm'
fmSdDecomp(object, factor.cov, use = "pairwise.complete.obs", ...)

## S3 method for class 'sfm'
fmSdDecomp(object, factor.cov, use = "pairwise.complete.obs", ...)

## S3 method for class 'ffm'
fmSdDecomp(object, factor.cov, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fmSdDecomp_+3A_object">object</code></td>
<td>
<p>fit object of class <code>tsfm</code> or <code>ffm</code>.</p>
</td></tr>
<tr><td><code id="fmSdDecomp_+3A_...">...</code></td>
<td>
<p>optional arguments passed to <code><a href="stats.html#topic+cov">cov</a></code>.</p>
</td></tr>
<tr><td><code id="fmSdDecomp_+3A_factor.cov">factor.cov</code></td>
<td>
<p>optional user specified factor covariance matrix with 
named columns; defaults to the sample covariance matrix.</p>
</td></tr>
<tr><td><code id="fmSdDecomp_+3A_use">use</code></td>
<td>
<p>method for computing covariances in the presence of missing 
values; one of &quot;everything&quot;, &quot;all.obs&quot;, &quot;complete.obs&quot;, &quot;na.or.complete&quot;, or 
&quot;pairwise.complete.obs&quot;. Default is &quot;pairwise.complete.obs&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The factor model for an asset's return at time <code>t</code> has the 
form <br /> <br /> <code>R(t) = beta'f(t) + e(t) = beta.star'f.star(t)</code> <br /> <br /> 
where, <code>beta.star=(beta,sig.e)</code> and <code>f.star(t)=[f(t)',z(t)]'</code>. 
<br /> <br /> By Euler's theorem, the standard deviation of the asset's return 
is given as: <br /> <br /> 
<code>Sd.fm = sum(cSd_k) = sum(beta.star_k*mSd_k)</code> <br /> <br /> 
where, summation is across the <code>K</code> factors and the residual, 
<code>cSd</code> and <code>mSd</code> are the component and marginal 
contributions to <code>SD</code> respectively. Computing <code>Sd.fm</code> and 
<code>mSd</code> is very straight forward. The formulas are given below and 
details are in the references. The covariance term is approximated by the 
sample covariance. <br /> <br />
<code>Sd.fm = sqrt(beta.star''cov(F.star)beta.star)</code> <br /> 
<code>mSd = cov(F.star)beta.star / Sd.fm</code>
</p>


<h3>Value</h3>

<p>A list containing 
</p>
<table role = "presentation">
<tr><td><code>Sd.fm</code></td>
<td>
<p>length-N vector of factor model SDs of N-asset returns.</p>
</td></tr>
<tr><td><code>mSd</code></td>
<td>
<p>N x (K+1) matrix of marginal contributions to SD.</p>
</td></tr>
<tr><td><code>cSd</code></td>
<td>
<p>N x (K+1) matrix of component contributions to SD.</p>
</td></tr>
<tr><td><code>pcSd</code></td>
<td>
<p>N x (K+1) matrix of percentage component contributions to SD.</p>
</td></tr>
</table>
<p>Where, <code>K</code> is the number of factors and N is the number of assets.
</p>


<h3>Author(s)</h3>

<p>Eric Zivot, Yi-An Chen and Sangeetha Srinivasan
</p>


<h3>References</h3>

<p>Hallerback (2003). Decomposing Portfolio Value-at-Risk: A General Analysis. 
The Journal of Risk, 5(2), 1-18.
</p>
<p>Meucci, A. (2007). Risk contributions from generic user-defined factors. 
RISK-LONDON-RISK MAGAZINE LIMITED-, 20(6), 84. 
</p>
<p>Yamai, Y., &amp; Yoshiba, T. (2002). Comparative analyses of expected shortfall 
and value-at-risk: their estimation error, decomposition, and optimization. 
Monetary and economic studies, 20(1), 87-121.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitTsfm">fitTsfm</a></code>
for the different factor model fitting functions.
</p>
<p><code><a href="#topic+fmCov">fmCov</a></code> for factor model covariance.
<code><a href="#topic+fmVaRDecomp">fmVaRDecomp</a></code> for factor model VaR decomposition.
<code><a href="#topic+fmEsDecomp">fmEsDecomp</a></code> for factor model ES decomposition.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Time Series Factor Model

 # load data
data(managers, package = 'PerformanceAnalytics')
colnames(managers)
 # Make syntactically valid column names
colnames(managers) &lt;- make.names( colnames(managers))
colnames(managers)

fit.macro &lt;- fitTsfm(asset.names=colnames(managers[,(1:6)]),
                     factor.names=colnames(managers[,(7:9)]),
                     rf.name="US.3m.TR", data=managers)
decomp &lt;- fmSdDecomp(fit.macro)
# get the percentage component contributions
decomp$pcSd

</code></pre>

<hr>
<h2 id='fmVaRDecomp'>Decompose VaR into individual factor contributions</h2><span id='topic+fmVaRDecomp'></span><span id='topic+fmVaRDecomp.tsfm'></span><span id='topic+fmVaRDecomp.sfm'></span><span id='topic+fmVaRDecomp.ffm'></span>

<h3>Description</h3>

<p>Compute the factor contributions to Value-at-Risk (VaR) of 
assets' returns based on Euler's theorem, given the fitted factor model. 
The partial derivative of VaR w.r.t. factor beta is computed as the expected 
factor return given fund return is equal to its VaR and approximated by a
kernel estimator. Option to choose between non-parametric and Normal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmVaRDecomp(object, ...)

## S3 method for class 'tsfm'
fmVaRDecomp(
  object,
  factor.cov,
  p = 0.05,
  type = c("np", "normal"),
  use = "pairwise.complete.obs",
  ...
)

## S3 method for class 'sfm'
fmVaRDecomp(
  object,
  factor.cov,
  p = 0.05,
  type = c("np", "normal"),
  use = "pairwise.complete.obs",
  ...
)

## S3 method for class 'ffm'
fmVaRDecomp(
  object,
  factor.cov,
  p = 0.05,
  type = c("np", "normal"),
  use = "pairwise.complete.obs",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fmVaRDecomp_+3A_object">object</code></td>
<td>
<p>fit object of class <code>tsfm</code>, <code>sfm</code> or <code>ffm</code>.</p>
</td></tr>
<tr><td><code id="fmVaRDecomp_+3A_...">...</code></td>
<td>
<p>other optional arguments passed to <code><a href="stats.html#topic+quantile">quantile</a></code>.</p>
</td></tr>
<tr><td><code id="fmVaRDecomp_+3A_factor.cov">factor.cov</code></td>
<td>
<p>optional user specified factor covariance matrix with 
named columns; defaults to the sample covariance matrix.</p>
</td></tr>
<tr><td><code id="fmVaRDecomp_+3A_p">p</code></td>
<td>
<p>tail probability for calculation. Default is 0.05.</p>
</td></tr>
<tr><td><code id="fmVaRDecomp_+3A_type">type</code></td>
<td>
<p>one of &quot;np&quot; (non-parametric) or &quot;normal&quot; for calculating VaR. 
Default is &quot;np&quot;.</p>
</td></tr>
<tr><td><code id="fmVaRDecomp_+3A_use">use</code></td>
<td>
<p>method for computing covariances in the presence of missing 
values; one of &quot;everything&quot;, &quot;all.obs&quot;, &quot;complete.obs&quot;, &quot;na.or.complete&quot;, or 
&quot;pairwise.complete.obs&quot;. Default is &quot;pairwise.complete.obs&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The factor model for an asset's return at time <code>t</code> has the 
form <br /> <br /> <code>R(t) = beta'f(t) + e(t) = beta.star'f.star(t)</code> <br /> <br /> 
where, <code>beta.star=(beta,sig.e)</code> and <code>f.star(t)=[f(t)',z(t)]'</code>. By 
Euler's theorem, the VaR of the asset's return is given by: 
<br /> <br /> <code>VaR.fm = sum(cVaR_k) = sum(beta.star_k*mVaR_k)</code> <br /> <br /> 
where, summation is across the <code>K</code> factors and the residual, 
<code>cVaR</code> and <code>mVaR</code> are the component and marginal 
contributions to <code>VaR</code> respectively. The marginal contribution to VaR 
is defined as the expectation of <code>F.star</code>, conditional on the loss 
being equal to <code>VaR.fm</code>. This is approximated as described in 
Epperlein &amp; Smillie (2006); a triangular smoothing kernel is used here. 
</p>
<p>Refer to Eric Zivot's slides (referenced) for formulas pertaining to the 
calculation of Normal VaR (adapted from a portfolio context to factor models)
</p>


<h3>Value</h3>

<p>A list containing 
</p>
<table role = "presentation">
<tr><td><code>VaR.fm</code></td>
<td>
<p>length-N vector of factor model VaRs of N-asset returns.</p>
</td></tr>
<tr><td><code>n.exceed</code></td>
<td>
<p>length-N vector of number of observations beyond VaR for 
each asset.</p>
</td></tr>
<tr><td><code>idx.exceed</code></td>
<td>
<p>list of numeric vector of index values of exceedances.</p>
</td></tr>
<tr><td><code>mVaR</code></td>
<td>
<p>N x (K+1) matrix of marginal contributions to VaR.</p>
</td></tr>
<tr><td><code>cVaR</code></td>
<td>
<p>N x (K+1) matrix of component contributions to VaR.</p>
</td></tr>
<tr><td><code>pcVaR</code></td>
<td>
<p>N x (K+1) matrix of percentage component contributions to VaR.</p>
</td></tr>
</table>
<p>Where, <code>K</code> is the number of factors and N is the number of assets.
</p>


<h3>Author(s)</h3>

<p>Eric Zivot, Yi-An Chen and Sangeetha Srinivasan
</p>


<h3>References</h3>

<p>Hallerback (2003). Decomposing Portfolio Value-at-Risk: A General Analysis. 
The Journal of Risk, 5(2), 1-18.
</p>
<p>Meucci, A. (2007). Risk contributions from generic user-defined factors. 
RISK-LONDON-RISK MAGAZINE LIMITED-, 20(6), 84. 
</p>
<p>Yamai, Y., &amp; Yoshiba, T. (2002). Comparative analyses of expected shortfall 
and value-at-risk: their estimation error, decomposition, and optimization. 
Monetary and economic studies, 20(1), 87-121.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitTsfm">fitTsfm</a></code>
for the different factor model fitting functions.
</p>
<p><code><a href="#topic+fmSdDecomp">fmSdDecomp</a></code> for factor model SD decomposition.
<code><a href="#topic+fmEsDecomp">fmEsDecomp</a></code> for factor model ES decomposition.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Time Series Factor Model

 # load data
data(managers, package = 'PerformanceAnalytics')
colnames(managers)
 # Make syntactically valid column names
colnames(managers) &lt;- make.names( colnames(managers))
colnames(managers)

fit.macro &lt;- fitTsfm(asset.names=colnames(managers[,(1:6)]),
                     factor.names=colnames(managers[,(7:8)]), 
                     data=managers)
                     
VaR.decomp &lt;- fmVaRDecomp(fit.macro)

# get the component contributions
VaR.decomp$cVaR

</code></pre>

<hr>
<h2 id='paFm'>Compute cumulative mean attribution for factor models</h2><span id='topic+paFm'></span>

<h3>Description</h3>

<p>Decompose total returns into returns attributed to factors and 
specific returns. An object of class <code>"pafm"</code> is generated, with 
methods for generic functions <code>plot</code>, <code>summary</code> and <code>print</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paFm(fit, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="paFm_+3A_fit">fit</code></td>
<td>
<p>an object of class <code>tsfm</code>, <code>sfm</code> or <code>ffm</code>.</p>
</td></tr>
<tr><td><code id="paFm_+3A_...">...</code></td>
<td>
<p>other arguments/controls passed to the fit methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Total returns can be decomposed into returns attributed to factors 
and specific returns. <br /> <code class="reqn">R_t = \sum  b_k * f_kt + u_t, t=1...T</code> <br />
<code>b_k</code> is exposure to factor k and <code>f_kt</code> is factor k's return at 
time t. The return attributed to factor k is <code>b_k * f_kt</code> and specific 
return is <code>u_t</code>.
</p>


<h3>Value</h3>

<p>The returned object is of class <code>"pafm"</code> containing
</p>
<table role = "presentation">
<tr><td><code>cum.ret.attr.f</code></td>
<td>
<p>N X K matrix of cumulative return attributed to
factors.</p>
</td></tr>
<tr><td><code>cum.spec.ret</code></td>
<td>
<p>length-N vector of cumulative specific returns.</p>
</td></tr>
<tr><td><code>attr.list</code></td>
<td>
<p>list of time series of attributed returns for every
portfolio.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yi-An Chen and Sangeetha Srinivasan
</p>


<h3>References</h3>

<p>Grinold, R. and Kahn, R. (1999) Active Portfolio Management: A 
Quantitative Approach for Producing Superior Returns and Controlling Risk. 
McGraw-Hill.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitTsfm">fitTsfm</a></code>
for the factor model fitting functions.
</p>
<p>The <code>pafm</code> methods for generic functions: 
<code><a href="#topic+plot.pafm">plot.pafm</a></code>, <code><a href="#topic+print.pafm">print.pafm</a></code> and 
<code><a href="#topic+summary.pafm">summary.pafm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(managers, package = 'PerformanceAnalytics')
fit &lt;- fitTsfm(asset.names=colnames(managers[, (1:6)]), 
               factor.names=c("EDHEC LS EQ","SP500 TR"), 
               data=managers)
# without benchmark
paFm(fit)

</code></pre>

<hr>
<h2 id='plot.pafm'>plot <code>"pafm"</code> object</h2><span id='topic+plot.pafm'></span>

<h3>Description</h3>

<p>Generic function of plot method for paFm.
Either plot all assets or choose a single asset to plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pafm'
plot(
  x,
  which.plot = c("none", "1L", "2L", "3L"),
  max.show = 6,
  date = NULL,
  plot.single = FALSE,
  fundName,
  which.plot.single = c("none", "1L", "2L", "3L"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.pafm_+3A_x">x</code></td>
<td>
<p>object of class <code>"pafm"</code> created by
<code>paFm</code>.</p>
</td></tr>
<tr><td><code id="plot.pafm_+3A_which.plot">which.plot</code></td>
<td>
<p>Integer indicates which plot to create: &quot;none&quot; will
create a menu to choose. Defualt is none.<br />
1 = attributed cumulative returns,<br />
2 = attributed returns on date selected by user,<br />
3 = time series of attributed returns</p>
</td></tr>
<tr><td><code id="plot.pafm_+3A_max.show">max.show</code></td>
<td>
<p>Maximum assets to plot. Default is 6.</p>
</td></tr>
<tr><td><code id="plot.pafm_+3A_date">date</code></td>
<td>
<p>Indicates for attributed returns, the date format should be
xts compatible.</p>
</td></tr>
<tr><td><code id="plot.pafm_+3A_plot.single">plot.single</code></td>
<td>
<p>Plot a single asset of lm class. Defualt is FALSE.</p>
</td></tr>
<tr><td><code id="plot.pafm_+3A_fundname">fundName</code></td>
<td>
<p>Name of the portfolio to be plotted.</p>
</td></tr>
<tr><td><code id="plot.pafm_+3A_which.plot.single">which.plot.single</code></td>
<td>
<p>Integer indicates which plot to create: &quot;none&quot;
will create a menu to choose. Defualt is none.<br />
1 = attributed cumulative returns,<br />
2 = attributed returns on date selected by user, <br />
3 = time series of attributed returns</p>
</td></tr>
<tr><td><code id="plot.pafm_+3A_...">...</code></td>
<td>
<p>more arguements for <code>chart.TimeSeries</code> used for plotting
time series</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>plot.pafm</code> returns a plot for an object of class <code>pafm</code>.
</p>


<h3>Author(s)</h3>

<p>Yi-An Chen.
</p>

<hr>
<h2 id='plot.tsfm'>Plots from a fitted time series factor model</h2><span id='topic+plot.tsfm'></span>

<h3>Description</h3>

<p>Generic <code>plot</code> method for object of class <code>tsfm</code>. 
Plots chosen characteristic(s) for one or more assets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tsfm'
plot(
  x,
  which = NULL,
  f.sub = 1:2,
  a.sub = 1:6,
  plot.single = FALSE,
  asset.name,
  colorset = c("royalblue", "dimgray", "olivedrab", "firebrick", "goldenrod",
    "mediumorchid", "deepskyblue", "chocolate", "darkslategray"),
  legend.loc = "topleft",
  las = 1,
  lwd = 2,
  maxlag = 15,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.tsfm_+3A_x">x</code></td>
<td>
<p>an object of class <code>tsfm</code> produced by <code>fitTsfm</code>.</p>
</td></tr>
<tr><td><code id="plot.tsfm_+3A_which">which</code></td>
<td>
<p>a number to indicate the type of plot. If a subset of the plots 
is required, specify a subset of the numbers 1:12 for group plots and 1:19 
for individual plots. If <code>which=NULL</code> (default), the following menu 
appears: <br /> <br />
For plots of a group of assets: <br />
1 = Factor model coefficients: Alpha, <br />
2 = Factor model coefficients: Betas, <br />
3 = Actual and fitted, <br />
4 = R-squared, <br />
5 = Residual volatility,<br />
6 = Scatterplot matrix of residuals, with histograms, density overlays, correlations and significance stars, <br />
7 = Factor model residual correlation <br />
8 = Factor model return correlation,<br />
9 = Factor contribution to SD,<br />
10 = Factor contribution to ES,<br />
11 = Factor contribution to VaR, <br />
12 = Asset returns vs factor returns (single factor model) <br /> <br />
For individual asset plots:<br />
1 = Actual and fitted,<br />
2 = Actual vs fitted,<br />
3 = Residuals vs fitted, <br />
4 = Sqrt. of modified residuals vs fitted, <br />
5 = Residuals with standard error bands, <br />
6 = Time series of squared residuals, <br />
7 = Time series of absolute residuals,<br />
8 = SACF and PACF of residuals,<br />
9 = SACF and PACF of squared residuals,<br />
10 = SACF and PACF of absolute residuals,<br />
11 = Non-parametric density of residuals with normal overlaid, <br />
12 = Non-parametric density of residuals with skew-t overlaid, <br /> 
13 = Histogram of residuals with non-parametric density and normal overlaid,<br />
14 = QQ-plot of residuals,<br />
15 = CUSUM test-Recursive residuals, requires strucchange package,<br />
16 = CUSUM test-LS residuals, requires strucchange package,<br />
17 = Recursive estimates (RE) test of LS regression coefficients, requires strucchange package,<br />
18 = Rolling regression over a 24-period observation window, <br />
19 = Asset returns vs factor returns (single factor model)</p>
</td></tr>
<tr><td><code id="plot.tsfm_+3A_f.sub">f.sub</code></td>
<td>
<p>numeric/character vector; subset of indexes/names of factors to 
include for group plots. Default is 1:2.</p>
</td></tr>
<tr><td><code id="plot.tsfm_+3A_a.sub">a.sub</code></td>
<td>
<p>numeric/character vector; subset of indexes/names of assets to 
include for group plots. At least 2 assets must be selected. Default is 1:6.</p>
</td></tr>
<tr><td><code id="plot.tsfm_+3A_plot.single">plot.single</code></td>
<td>
<p>logical; If <code>TRUE</code> plots the characteristics of an 
individual asset's factor model. The type of plot is given by 
<code>which</code>. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.tsfm_+3A_asset.name">asset.name</code></td>
<td>
<p>name of the individual asset to be plotted. Is necessary 
if <code>x</code> contains multiple asset fits and <code>plot.single=TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.tsfm_+3A_colorset">colorset</code></td>
<td>
<p>color palette to use for all the plots. The 1st element will 
be used for individual time series plots or the 1st object plotted, the 2nd 
element for the 2nd object in the plot and so on.</p>
</td></tr>
<tr><td><code id="plot.tsfm_+3A_legend.loc">legend.loc</code></td>
<td>
<p>places a legend into one of nine locations on the chart: 
&quot;bottomright&quot;, &quot;bottom&quot;, &quot;bottomleft&quot;, &quot;left&quot;, &quot;topleft&quot;, &quot;top&quot;, &quot;topright&quot;, 
&quot;right&quot;, or &quot;center&quot;. Default is &quot;bottomright&quot;. Use <code>legend.loc=NULL</code> 
to suppress the legend.</p>
</td></tr>
<tr><td><code id="plot.tsfm_+3A_las">las</code></td>
<td>
<p>one of <code>0, 1, 2, 3</code> to set the direction of axis labels, same as 
in <code>plot</code>. Default is 1.</p>
</td></tr>
<tr><td><code id="plot.tsfm_+3A_lwd">lwd</code></td>
<td>
<p>set the line width, same as in <code><a href="base.html#topic+plot">plot</a></code>. Default is 2.</p>
</td></tr>
<tr><td><code id="plot.tsfm_+3A_maxlag">maxlag</code></td>
<td>
<p>optional number of lags to be calculated for ACF. Default is 15.</p>
</td></tr>
<tr><td><code id="plot.tsfm_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to other plotting functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function can be used for group plots and individual plots. User can 
select the type of plot either from the menu prompt (default) or directly 
via argument <code>which</code>.
</p>
<p>In case multiple plots are needed, the menu is repeated after each plot 
(enter 0 to exit). User can also input a numeric vector of plot options via 
<code>which</code>.
</p>
<p>Group plots are the default. The selected assets in <code>a.sub</code> and 
selected factors in <code>f.sub</code> are plotted depending on the 
characteristic chosen. The default is to show the first 2 factors and first 
6 assets.
</p>
<p>Setting <code>plot.single=TRUE</code> enables individual plots. If there is more 
than one asset fit by <code>x</code>, <code>asset.name</code> should be specified. 
In case the <code>tsfm</code> object <code>x</code> contains only a single asset fit, 
plot.tsfm can infer <code>asset.name</code> without user input. 
</p>
<p>CUSUM plots (individual asset plot options 15, 16 and 17) are applicable 
only for <code>fit.method="LS"</code>.
</p>
<p>Modified residuals, rolling regression and single factor model plots 
(individual asset plot options 4, 18 and 19) are not applicable for 
<code>variable.selection="lars"</code>.
</p>
<p>The last option for plotting asset returns vs. factor returns (individual 
asset plot option 19 and group plot 12) are only applicable for single factor
models.
</p>


<h3>Value</h3>

<p><code>plot.tsfm</code> returns a plot for an object of class <code>tsfm</code>.
</p>


<h3>Author(s)</h3>

<p>Eric Zivot, Sangeetha Srinivasan and Yi-An Chen
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitTsfm">fitTsfm</a></code>, <code><a href="#topic+residuals.tsfm">residuals.tsfm</a></code>, 
<code><a href="#topic+fitted.tsfm">fitted.tsfm</a></code>, <code><a href="#topic+fmCov.tsfm">fmCov.tsfm</a></code> and 
<code><a href="#topic+summary.tsfm">summary.tsfm</a></code> for time series factor model fitting and related 
S3 methods. Refer to <code><a href="#topic+fmSdDecomp">fmSdDecomp</a></code>, <code><a href="#topic+fmEsDecomp">fmEsDecomp</a></code>, 
<code><a href="#topic+fmVaRDecomp">fmVaRDecomp</a></code> for factor model risk measures.
</p>
<p>Here is a list of plotting functions used. (I=individual, G=Group)
I(1,5,6,7), G(3) - <code><a href="PerformanceAnalytics.html#topic+chart.TimeSeries">chart.TimeSeries</a></code>, 
I(2,3,4,19), G(12) - <code><a href="graphics.html#topic+plot.default">plot.default</a></code>,
I(3,4) - <code><a href="graphics.html#topic+panel.smooth">panel.smooth</a></code>,
I(8,9,10) - <code><a href="PerformanceAnalytics.html#topic+chart.ACFplus">chart.ACFplus</a></code>, 
I(11,12) - <code><a href="stats.html#topic+plot.density">plot.density</a></code>,
I(13) - <code><a href="PerformanceAnalytics.html#topic+chart.Histogram">chart.Histogram</a></code>,
I(14) - <code><a href="PerformanceAnalytics.html#topic+chart.QQPlot">chart.QQPlot</a></code>, 
I(15,16,17) - <code><a href="strucchange.html#topic+plot.efp">plot.efp</a></code> (requires strucchange package),
I(18) - <code><a href="zoo.html#topic+plot.zoo">plot.zoo</a></code>,
G(1,2,4,5,9,10,11) - <code><a href="lattice.html#topic+barchart">barchart</a></code>,
G(6) - <code><a href="PerformanceAnalytics.html#topic+chart.Correlation">chart.Correlation</a></code> and
G(7,8) - <code><a href="corrplot.html#topic+corrplot.mixed">corrplot.mixed</a></code> (requires corrplot package).
</p>

<hr>
<h2 id='plot.tsfmUpDn'>Plot actual against fitted values of up and down market time series factor model</h2><span id='topic+plot.tsfmUpDn'></span>

<h3>Description</h3>

<p>Generic <code>plot</code> method for object of class <code>tsfmUpDn</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tsfmUpDn'
plot(
  x,
  asset.name = NULL,
  SFM.line = FALSE,
  LSandRob = FALSE,
  line.color = c("blue", "purple"),
  line.type = c("dashed", "solid"),
  line.width = c(1, 2),
  sfm.line.type = "dashed",
  add.legend = TRUE,
  legend.loc = "topleft",
  legend.cex = 0.9,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.tsfmUpDn_+3A_x">x</code></td>
<td>
<p>an object of class <code>tsfmUpDn</code> produced by <code>fitTsfmUpDn</code>.</p>
</td></tr>
<tr><td><code id="plot.tsfmUpDn_+3A_asset.name">asset.name</code></td>
<td>
<p>A vector of character to show single or multiple assets names. The defualt if 
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plot.tsfmUpDn_+3A_sfm.line">SFM.line</code></td>
<td>
<p>A logic flag to add a fitted single factor model. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.tsfmUpDn_+3A_lsandrob">LSandRob</code></td>
<td>
<p>A logic flag to add a comparison Up/Down factor model. If the original model
is <code>"LS"</code>, the comparison model is <code>"Robust"</code> and vice versa. The default is <code>FALSE</code>.
The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.tsfmUpDn_+3A_line.color">line.color</code></td>
<td>
<p>A vector of color codes of up/dn fitted line. The first element is for the object fitted
line and the second for the comparison fitted line. The default is <code>c("blue","purple")</code>.</p>
</td></tr>
<tr><td><code id="plot.tsfmUpDn_+3A_line.type">line.type</code></td>
<td>
<p>A vector of line types of up/dn fitted line. The first is for the object fitted
line and the second for the comparison fitted line. The default is <code>c("dashed","solid"</code>.</p>
</td></tr>
<tr><td><code id="plot.tsfmUpDn_+3A_line.width">line.width</code></td>
<td>
<p>A vector of line width of up/dn fitted line. The first element is for the object fitted
line and the second element for the comparison fitted line. The default is <code>c(1,2</code>.</p>
</td></tr>
<tr><td><code id="plot.tsfmUpDn_+3A_sfm.line.type">sfm.line.type</code></td>
<td>
<p>SFM line type. The default is <code>"dashed"</code></p>
</td></tr>
<tr><td><code id="plot.tsfmUpDn_+3A_add.legend">add.legend</code></td>
<td>
<p>A logic flag to add a legend. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.tsfmUpDn_+3A_legend.loc">legend.loc</code></td>
<td>
<p>The default is <code>"topleft"</code>.</p>
</td></tr>
<tr><td><code id="plot.tsfmUpDn_+3A_legend.cex">legend.cex</code></td>
<td>
<p><code>cex</code> of <code>legend</code>.</p>
</td></tr>
<tr><td><code id="plot.tsfmUpDn_+3A_...">...</code></td>
<td>
<p>Other arguments can be used in <code>plot</code>. Please refer to <code>plot</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method plots actual values against fitted value of up and down market time series
factor model. The dots are actual values and the dashed lines are fitted values. Users can 
choose to add a single market factor model and a robust up and down model for comaprsion. 
</p>
<p>For other types of plots, use the list objects <code>Up</code> and <code>Dn</code> of class <code>tsfmUpDn</code>. 
The <code>plot.tsfm</code> can be applied.
</p>


<h3>Value</h3>

<p><code>plot.tsfmUpDn</code> returns a plot for an object of class <code>tsfmUpDn</code>.
</p>


<h3>Author(s)</h3>

<p>Yi-An Chen
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitTsfmUpDn">fitTsfmUpDn</a></code>
</p>

<hr>
<h2 id='predict.tsfm'>Predicts asset returns based on a fitted time series factor model</h2><span id='topic+predict.tsfm'></span>

<h3>Description</h3>

<p>S3 <code>predict</code> method for object of class <code>tsfm</code>. It 
calls the <code>predict</code> method for fitted objects of class <code>lm</code>, 
<code>lmRob</code> or <code>lars</code> as appropriate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tsfm'
predict(object, newdata = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.tsfm_+3A_object">object</code></td>
<td>
<p>an object of class <code>tsfm</code> produced by <code>fitTsfm</code>.</p>
</td></tr>
<tr><td><code id="predict.tsfm_+3A_newdata">newdata</code></td>
<td>
<p>a vector, matrix, data.frame, xts, timeSeries or zoo object 
containing the variables with which to predict.</p>
</td></tr>
<tr><td><code id="predict.tsfm_+3A_...">...</code></td>
<td>
<p>optional arguments passed to <code>predict.lm</code> or
<code><a href="robustbase.html#topic+predict.lmrob">predict.lmrob</a></code>, such as <code>se.fit</code>, or, to 
<code><a href="lars.html#topic+predict.lars">predict.lars</a></code> such as <code>mode</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>predict.tsfm</code> produces a matrix of return predictions, if all assets 
have equal history. If not, a list of predicted return vectors of unequal 
length is produced.
</p>


<h3>Author(s)</h3>

<p>Yi-An Chen and Sangeetha Srinivasan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitTsfm">fitTsfm</a></code>, <code><a href="#topic+summary.tsfm">summary.tsfm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data from the database
data(managers, package = 'PerformanceAnalytics')

# fit the factor model with LS
fit &lt;- fitTsfm(asset.names = colnames(managers[,(1:6)]),
               factor.names = c("EDHEC LS EQ","SP500 TR"), 
               data = managers)

predict_fit &lt;- predict(fit)

newdata &lt;- data.frame(rnorm(n=NROW(fit$data)), rnorm(n=NROW(fit$data)))
colnames(newdata) &lt;- c("EDHEC LS EQ", "SP500 TR")
rownames(newdata) &lt;- zoo::index(fit$data)

predict_fit_2 &lt;- predict(fit, newdata, interval = "confidence")

</code></pre>

<hr>
<h2 id='predict.tsfmUpDn'>Predicts asset returns based on a fitted up and down market time series factor model</h2><span id='topic+predict.tsfmUpDn'></span>

<h3>Description</h3>

<p>S3 <code>predict</code> method for object of class <code>tsfmUpDn</code>. It 
calls the <code>predict.tsfm</code> method for a list object of <code>Up</code> and <code>Dn</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tsfmUpDn'
predict(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.tsfmUpDn_+3A_object">object</code></td>
<td>
<p>an object of class <code>tsfmUpDn</code> produced by <code>fitTsfmUpDn</code>.</p>
</td></tr>
<tr><td><code id="predict.tsfmUpDn_+3A_...">...</code></td>
<td>
<p>optional arguments passed to <code>predict.lm</code> or
<code><a href="robustbase.html#topic+predict.lmrob">predict.lmrob</a></code>, such as <code>se.fit</code>, or, to 
<code><a href="lars.html#topic+predict.lars">predict.lars</a></code> such as <code>mode</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>predict.tsfmUpDm</code> produces a list of <code>Up</code> and <code>Dn</code>. Both <code>Up</code> and <code>Dn</code> contain a 
vector or a matrix of predictions.
</p>


<h3>Author(s)</h3>

<p>Yi-An Chen and Sangeetha Srinivasan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.tsfm">predict.tsfm</a></code>,<code><a href="#topic+fitTsfmUpDn">fitTsfmUpDn</a></code>, <code><a href="#topic+summary.tsfmUpDn">summary.tsfmUpDn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # load data
data(managers, package = 'PerformanceAnalytics')

# fit the factor model with LS. example: Up and down market factor model with LS fit
fitUpDn &lt;- fitTsfmUpDn(asset.names = colnames(managers[,(1:6)]),
                       mkt.name = "SP500 TR",
                       data = managers, 
                       fit.method = "LS")
 
predict(fitUpDn)

</code></pre>

<hr>
<h2 id='print.pafm'>Print object of class <code>"pafm"</code>.</h2><span id='topic+print.pafm'></span>

<h3>Description</h3>

<p>Generic function of print method for <code>paFm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pafm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.pafm_+3A_x">x</code></td>
<td>
<p>object of class <code>"pafm"</code> created by
<code>paFm</code>.</p>
</td></tr>
<tr><td><code id="print.pafm_+3A_...">...</code></td>
<td>
<p>Other arguments for <code>print</code> methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>print.pafm</code> prints a brief summary of an object of class 
<code>pafm</code>.
</p>


<h3>Author(s)</h3>

<p>Yi-An Chen.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data from the database
 data(managers, package = 'PerformanceAnalytics')
# fit the factor model with LS
fit &lt;- fitTsfm(asset.names=colnames(managers[,(1:6)]),
               factor.names=c("EDHEC LS EQ", "SP500 TR"), 
               data=managers)
fm.attr &lt;- paFm(fit)
print(fm.attr)

</code></pre>

<hr>
<h2 id='print.tsfm'>Prints a fitted time series factor model</h2><span id='topic+print.tsfm'></span>

<h3>Description</h3>

<p>S3 <code>print</code> method for object of class <code>tsfm</code>. Prints 
the call, factor model dimension, regression coefficients, r-squared and 
residual volatilities from the fitted object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tsfm'
print(x, digits = max(3, .Options$digits - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.tsfm_+3A_x">x</code></td>
<td>
<p>an object of class <code>tsfm</code> produced by <code>fitTsfm</code>.</p>
</td></tr>
<tr><td><code id="print.tsfm_+3A_digits">digits</code></td>
<td>
<p>an integer value, to indicate the required number of 
significant digits. Default is 3.</p>
</td></tr>
<tr><td><code id="print.tsfm_+3A_...">...</code></td>
<td>
<p>optional arguments passed to the <code>print</code> method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>print.tsfm</code> prints a brief summary of an object of class 
<code>tsfm</code>.
</p>


<h3>Author(s)</h3>

<p>Yi-An Chen and Sangeetha Srinivasan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitTsfm">fitTsfm</a></code>, <code><a href="#topic+summary.tsfm">summary.tsfm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(managers, package = 'PerformanceAnalytics')
fit &lt;- fitTsfm(asset.names=colnames(managers[,(1:6)]),
               factor.names=colnames(managers[,7:9]), 
               mkt.name="SP500.TR", data=managers)
print(fit)

</code></pre>

<hr>
<h2 id='print.tsfmUpDn'>Prints out a fitted up and down market time series factor model object</h2><span id='topic+print.tsfmUpDn'></span>

<h3>Description</h3>

<p>S3 <code>print</code> method for object of class <code>tsfmUpDn</code>. Prints 
the call, factor model dimension, regression coefficients, r-squared and 
residual volatilities from the fitted object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tsfmUpDn'
print(x, digits = max(3, .Options$digits - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.tsfmUpDn_+3A_x">x</code></td>
<td>
<p>an object of class <code>tsfmUpDn</code> produced by <code>fitTsfmUpDn</code>.</p>
</td></tr>
<tr><td><code id="print.tsfmUpDn_+3A_digits">digits</code></td>
<td>
<p>an integer value, to indicate the required number of 
significant digits. Default is 3.</p>
</td></tr>
<tr><td><code id="print.tsfmUpDn_+3A_...">...</code></td>
<td>
<p>optional arguments passed to the <code>print</code> method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>print.tsfmUpDn</code> prints a brief summary of an object of class 
<code>tsfmUpDn</code>.
</p>


<h3>Author(s)</h3>

<p>Yi-An Chen and Sangeetha Srinivasan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitTsfmUpDn">fitTsfmUpDn</a></code>, <code><a href="#topic+summary.tsfmUpDn">summary.tsfmUpDn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # load data
data(managers, package = 'PerformanceAnalytics')
colnames(managers)
 # Make syntactically valid column names
colnames(managers) &lt;- make.names( colnames(managers))
colnames(managers)

# example: Up and down market factor model with LS fit
fitUpDn &lt;- fitTsfmUpDn(asset.names=colnames(managers[,(1:6)]),
                       mkt.name="SP500.TR",
                       data=managers, 
                       fit.method="LS")
 
print(fitUpDn)

</code></pre>

<hr>
<h2 id='summary.pafm'>summary <code>"pafm"</code> object.</h2><span id='topic+summary.pafm'></span>

<h3>Description</h3>

<p>Generic function of summary method for <code>paFm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pafm'
summary(object, digits = max(3, .Options$digits - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.pafm_+3A_object">object</code></td>
<td>
<p><code>"pafm"</code> object created by
<code>paFm</code>.</p>
</td></tr>
<tr><td><code id="summary.pafm_+3A_digits">digits</code></td>
<td>
<p>integer indicating the number of decimal places. Default is 3.</p>
</td></tr>
<tr><td><code id="summary.pafm_+3A_...">...</code></td>
<td>
<p>Other arguments for <code>print</code> methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>summary.pafm</code>. 
The print method for class <code>summary.pafm</code> outputs the means of the
specific returns of the factors.
</p>


<h3>Author(s)</h3>

<p>Yi-An Chen.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data from the database
data(managers, package = 'PerformanceAnalytics')

# fit the factor model with LS
fit.ts &lt;- fitTsfm(asset.names = colnames(managers[,(1:6)]), 
                  factor.names = c("EDHEC LS EQ","SP500 TR"),
                  data = managers)
  
fm.attr &lt;- paFm(fit.ts)
summary(fm.attr)

</code></pre>

<hr>
<h2 id='summary.tsfm'>Summarizing a fitted time series factor model</h2><span id='topic+summary.tsfm'></span><span id='topic+print.summary.tsfm'></span>

<h3>Description</h3>

<p><code>summary</code> method for object of class <code>tsfm</code>. 
Returned object is of class <code>summary.tsfm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tsfm'
summary(object, se.type = c("Default", "HC", "HAC"), ...)

## S3 method for class 'summary.tsfm'
print(x, digits = 3, labels = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.tsfm_+3A_object">object</code></td>
<td>
<p>an object of class <code>tsfm</code> returned by <code>fitTsfm</code>.</p>
</td></tr>
<tr><td><code id="summary.tsfm_+3A_se.type">se.type</code></td>
<td>
<p>one of &quot;Default&quot;, &quot;HC&quot; or &quot;HAC&quot; option for computing HC/HAC 
standard errors and t-statistics. Default is &quot;Default&quot;. If &quot;HC&quot; or &quot;HAC&quot; 
options are selected, you will need to first load the suggested 'lmtest' 
package.</p>
</td></tr>
<tr><td><code id="summary.tsfm_+3A_...">...</code></td>
<td>
<p>futher arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary.tsfm_+3A_x">x</code></td>
<td>
<p>an object of class <code>summary.tsfm</code>.</p>
</td></tr>
<tr><td><code id="summary.tsfm_+3A_digits">digits</code></td>
<td>
<p>number of significant digits to use when printing. 
Default is 3.</p>
</td></tr>
<tr><td><code id="summary.tsfm_+3A_labels">labels</code></td>
<td>
<p>option to print labels and legend in the summary. Default is 
<code>TRUE</code>. When <code>FALSE</code>, only the coefficient matrx with standard 
errors is printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default <code>summary</code> method for a fitted <code>lm</code> object 
computes the standard errors and t-statistics under the assumption of 
homoskedasticty. Argument <code>se.type</code> gives the option to compute 
heteroskedasticity-consistent (HC) or 
heteroskedasticity-autocorrelation-consistent (HAC) standard errors and 
t-statistics using <code><a href="lmtest.html#topic+coeftest">coeftest</a></code>. This option is meaningful 
only if <code>fit.method = "LS" or "DLS"</code>.
</p>
<p>Standard errors are currently not available for 
<code>variable.selection="lars"</code> as there seems to be no consensus on a 
statistically valid method of calculating standard errors for the lasso 
predictions.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>summary.tsfm</code>. 
The print method for class <code>summary.tsfm</code> outputs the call, 
coefficients (with standard errors and t-statistics), r-squared and 
residual volatilty (under the homoskedasticity assumption) for all assets. 
</p>
<p>Object of class <code>summary.tsfm</code> is a list of length N + 2 containing:
</p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>
<p>the function call to <code>fitTsfm</code></p>
</td></tr>
<tr><td><code>se.type</code></td>
<td>
<p>standard error type as input</p>
</td></tr> 
<tr><td><code>sum.list</code></td>
<td>
<p>list of summaries of the N fit objects (of class <code>lm</code>, 
<code>lmRob</code> or <code>lars</code>) for each asset in the factor model.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sangeetha Srinivasan &amp; Yi-An Chen.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitTsfm">fitTsfm</a></code>, <code><a href="stats.html#topic+summary.lm">summary.lm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # load data
data(managers, package = 'PerformanceAnalytics')

# fit for first 3 assets
fit &lt;- fitTsfm(asset.names=colnames(managers[,1:3]),
               factor.names=colnames(managers[,7:9]), 
               data=managers)

# summary of factor model fit for all assets
summary(fit)

# summary of factor model fit for the second of three
summary(fit$asset.fit[[2]])

</code></pre>

<hr>
<h2 id='summary.tsfmUpDn'>Summarizing a fitted up and down market time series factor model</h2><span id='topic+summary.tsfmUpDn'></span><span id='topic+print.summary.tsfmUpDn'></span>

<h3>Description</h3>

<p><code>summary</code> method for object of class <code>tsfmUpDn</code>. 
Returned object is of class <code>summary.tsfmUpDn</code>. This function provides a <code>summary</code>
method to an object returned by a wrapper function <code>fitTsfmUpDn</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tsfmUpDn'
summary(object, ...)

## S3 method for class 'summary.tsfmUpDn'
print(x, digits = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.tsfmUpDn_+3A_object">object</code></td>
<td>
<p>an object of class <code>tsfmUpDn</code> returned by <code>fitTsfmUpDn</code>.</p>
</td></tr>
<tr><td><code id="summary.tsfmUpDn_+3A_...">...</code></td>
<td>
<p>futher arguments passed to or from <code>summary.tsfm</code> methods.</p>
</td></tr>
<tr><td><code id="summary.tsfmUpDn_+3A_x">x</code></td>
<td>
<p>an object of class <code>summary.tsfmUpDn</code>.</p>
</td></tr>
<tr><td><code id="summary.tsfmUpDn_+3A_digits">digits</code></td>
<td>
<p>number of significants digits to use when printing. 
Default is 3.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Since <code>fitTsfmUpDn</code> fits both up market and down market,
<code>summary.tsfmUpDn</code> applies <code>summary.tsfm</code> for both markets fitted 
objects and combines the coefficients interested together.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>summary.tsfmUpDn</code>. This object contains 
a list object of <code>Up</code> and <code>Dn</code> for up market and down market respectively.
</p>
<p>The print method for class <code>summary.tsfmUpDn</code> outputs the call, 
coefficients (with standard errors and t-statistics), r-squared and 
residual volatilty (under the homoskedasticity assumption) for all assets in up and 
down market. 
</p>
<p>Object of class <code>summary.tsfmUpDn</code> is a list of 2 containing:
</p>
<table role = "presentation">
<tr><td><code>Up</code></td>
<td>
<p>A list of the up market fitted object. It is a class of <code>summary.tsfm</code></p>
</td></tr>
<tr><td><code>Dn</code></td>
<td>
<p>A list of the down market fitted object. It is a class of <code>summary.tsfm</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yi-An Chen and Sangeetha Srinivasan.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitTsfmUpDn">fitTsfmUpDn</a></code>, <code><a href="#topic+summary.tsfm">summary.tsfm</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
