<!DOCTYPE html><html lang="en"><head><title>Help for package SpatEntropy</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SpatEntropy}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#SpatEntropy'><p>SpatEntropy: a package for computing spatial entropy measures.</p></a></li>
<li><a href='#altieri'><p>Altieri's spatial entropy.</p></a></li>
<li><a href='#areapart'><p>Area partition.</p></a></li>
<li><a href='#batty'><p>Batty's entropy.</p></a></li>
<li><a href='#bologna'><p>Bologna urban data.</p></a></li>
<li><a href='#bolognaTess'><p>Municipalities' administrative borders for Bologna urban data.</p></a></li>
<li><a href='#bolognaW'><p>Observation window for Bologna urban data.</p></a></li>
<li><a href='#contagion'><p>Li and Reynolds' relative contagion index.</p></a></li>
<li><a href='#karlstrom'><p>Karlstrom and Ceccato's entropy.</p></a></li>
<li><a href='#leibovici'><p>Leibovici's entropy.</p></a></li>
<li><a href='#oneill'><p>O'Neill's entropy.</p></a></li>
<li><a href='#parredw'><p>Parresol and Edwards' entropy.</p></a></li>
<li><a href='#raintrees'><p>Rainforest tree data 1.</p></a></li>
<li><a href='#raintrees2'><p>Rainforest tree data 2.</p></a></li>
<li><a href='#raintreesCOV'><p>Covariates for the rainforest tree data.</p></a></li>
<li><a href='#shannon'><p>Shannon's entropy.</p></a></li>
<li><a href='#shannonZ'><p>Shannon's entropy of the transformed variable <code class="reqn">Z</code>.</p></a></li>
<li><a href='#turin'><p>Turin urban data.</p></a></li>
<li><a href='#turinTess'><p>Municipalities' administrative borders for Turin urban data.</p></a></li>
<li><a href='#turinW'><p>Observation window for Turin urban data.</p></a></li>
<li><a href='#varshannon'><p>Estimated variance of Shannon's entropy.</p></a></li>
<li><a href='#varshannonZ'><p>Estimated variance of Shannon's entropy of <code class="reqn">Z</code>.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Spatial Entropy Measures</td>
</tr>
<tr>
<td>Version:</td>
<td>2.2-4</td>
</tr>
<tr>
<td>Author:</td>
<td>L. Altieri, D. Cocchi, G. Roli</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Altieri Linda &lt;linda.altieri@unibo.it&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0), spatstat (&ge; 3.0-2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>spatstat.geom, spatstat.random, graphics, grDevices</td>
</tr>
<tr>
<td>Description:</td>
<td>The heterogeneity of spatial data presenting a finite number of categories can be measured via computation of spatial entropy. Functions are available for the computation of the main entropy and spatial entropy measures in the literature. They include the traditional version of Shannon's entropy (Shannon, 1948 &lt;<a href="https://doi.org/10.1002%2Fj.1538-7305.1948.tb01338.x">doi:10.1002/j.1538-7305.1948.tb01338.x</a>&gt;), Batty's spatial entropy (Batty, 1974 &lt;<a href="https://doi.org/10.1111%2Fj.1538-4632.1974.tb01014.x">doi:10.1111/j.1538-4632.1974.tb01014.x</a>&gt;), O'Neill's entropy (O'Neill et al., 1998 &lt;<a href="https://doi.org/10.1007%2FBF00162741">doi:10.1007/BF00162741</a>&gt;), Li and Reynolds' contagion index (Li and Reynolds, 1993 &lt;<a href="https://doi.org/10.1007%2FBF00125347">doi:10.1007/BF00125347</a>&gt;), Karlstrom and Ceccato's entropy (Karlstrom and Ceccato, 2002 <a href="https://urn.kb.se/resolve?urn=urn:nbn:se:kth:diva-61351">https://urn.kb.se/resolve?urn=urn:nbn:se:kth:diva-61351</a>), Leibovici's entropy (Leibovici, 2009 &lt;<a href="https://doi.org/10.1007%2F978-3-642-03832-7_24">doi:10.1007/978-3-642-03832-7_24</a>&gt;), Parresol and Edwards' entropy (Parresol and Edwards, 2014 &lt;<a href="https://doi.org/10.3390%2Fe16041842">doi:10.3390/e16041842</a>&gt;) and Altieri's entropy (Altieri et al., 2018, &lt;<a href="https://doi.org/10.1007%2Fs10651-017-0383-1">doi:10.1007/s10651-017-0383-1</a>&gt;). Full references for all measures can be found under the topic 'SpatEntropy'. The package is able to work with lattice and point data. The updated version works with the updated 'spatstat' package (&gt;= 3.0-2). </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-17 12:04:03 UTC; linda.altieri4</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-17 12:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='SpatEntropy'>SpatEntropy: a package for computing spatial entropy measures.</h2><span id='topic+SpatEntropy'></span><span id='topic+SpatEntropy-package'></span>

<h3>Description</h3>

<p>The heterogeneity of spatial data presenting a finite number of categories
can be measured via computation of spatial entropy. Functions are available
for the computation of the main entropy and spatial entropy measures in the
literature. They include the traditional version of Shannon's entropy,
Batty's spatial entropy, O'Neill's entropy, Li and Reynolds' contagion index,
Karlstrom and Ceccato's entropy, Leibovici's entropy, Parresol and Edwards'
entropy and Altieri's entropy.
The package is able to work with lattice and point data. A step-by-step guide
for new users can be found in the first referenced article.
</p>


<h3>Details</h3>

<p>References:
</p>
<p>ALTIERI L., COCCHI D., ROLI G. (2021). Spatial entropy for biodiversity and environmental data: The
R-package SpatEntropy. Environmental Modelling and Software
</p>
<p>ALTIERI L., COCCHI D., ROLI G. (2019). Advances in spatial entropy measures.
Stochastic Environmental Research and Risk Assessment
</p>
<p>ALTIERI L., COCCHI D., ROLI G. (2019). Measuring heterogeneity in urban expansion via spatial entropy.
Environmetrics, 30(2), e2548
</p>
<p>ALTIERI L., COCCHI D., ROLI G. (2018). A new approach to spatial entropy measures.
Environmental and Ecological Statistics, 25(1), 95-110
</p>
<p>Altieri, L., D. Cocchi, and G. Roli (2017). The use of spatial information in entropy measures.
arXiv:1703.06001
</p>
<p>Batty, M. (1974). Spatial entropy. Geographical Analysis 6, 1-31.
</p>
<p>Batty, M. (1976). Entropy in spatial aggregation. Geographical Analysis 8, 1-21.
</p>
<p>EEA (2011). Corine land cover 2000 raster data. Technical Report, downloadable at
http://www.eea.europa.eu/data-and-maps/ data/corine-land-cover-2000-raster-1.
</p>
<p>Karlstrom, A. and V. Ceccato (2002). A new information theoretical measure of global and local
spatial association. The Review of Regional Research 22, 13-40.
</p>
<p>Leibovici, D. (2009). Defining spatial entropy from multivariate distributions of co-occurrences.
Berlin, Springer: In K. S. Hornsby et al. (eds.): 9th International Conference on Spatial Information
Theory 2009, Lecture Notes in Computer Science 5756, 392-404.
</p>
<p>Li, H. and J. Reynolds (1993). A new contagion index to quantify spatial patterns of landscapes.
Landscape Ecology 8(3), 155-162.
</p>
<p>O'Neill, R., J. Krummel, R. Gardner, G. Sugihara, B. Jackson, D. DeAngelis, B. Milne, M. Turner,
B. Zygmunt, S. Christensen, V. Dale, and R. Graham (1988). Indices of landscape pattern. Landscape
Ecology 1(3), 153-162.
</p>
<p>Parresol, B. and L. Edwards (2014). An entropy-based contagion index and its sampling properties
for landscape analysis. Entropy 16(4), 1842-1859.
</p>
<p>Shannon, C. (1948). A mathematical theory of communication. Bell Dyditem Technical Journal 27,
379-423, 623-656.
</p>

<hr>
<h2 id='altieri'>Altieri's spatial entropy.</h2><span id='topic+altieri'></span>

<h3>Description</h3>

<p>This function computes spatial mutual information and spatial residual entropy as in Altieri et al (2017) and following works.
References can be found at <code>SpatEntropy</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>altieri(data, cell.size = 1, distbreak = "default", verbose = F, plotout = T)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="altieri_+3A_data">data</code></td>
<td>
<p>If data are lattice, a data matrix, which can be numeric, factor, character, ...
If the dataset is a point pattern, <code>data</code> is a <code>ppp</code> object.</p>
</td></tr>
<tr><td><code id="altieri_+3A_cell.size">cell.size</code></td>
<td>
<p>A single number or a vector of length two, only needed if data are lattice. It gives the length of the side of each pixel;
if the pixel is rectangular, the first number gives the horizontal side and the second number gives the vertical side. Default to 1. Ignored if data are points.</p>
</td></tr>
<tr><td><code id="altieri_+3A_distbreak">distbreak</code></td>
<td>
<p>Numeric. The chosen distance breaks for selecting pairs of pixels/points within the observation area.
The default option is <code>c(cell.size[1], 2*cell.size[1])</code> for lattice data, and
<code>c(mindist, 2*mindist)</code> for point data,
where <code>mindist</code> is the first decile of the nearest neighbour distance distribution.
Only the internal breaks have to be specified, the first and last break are automatically added as 0 and the maximum distance within the observation area, respectively.</p>
</td></tr>
<tr><td><code id="altieri_+3A_verbose">verbose</code></td>
<td>
<p>Logical. If <code>TRUE</code> an output is printed in order to follow the progress of the work (recommended for large dataset).
Default set to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="altieri_+3A_plotout">plotout</code></td>
<td>
<p>Logical. Default to <code>TRUE</code>, produces an informative plot as part of the function output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The computation of Altieri's entropy starts from a point or areal dataset, for which
Shannon's entropy of the transformed variable <code class="reqn">Z</code> (for details see <code><a href="#topic+shannonZ">shannonZ</a></code>)
</p>
<p style="text-align: center;"><code class="reqn">H(Z)=\sum p(z_r)\log(1/p(z_r))</code>
</p>

<p>is computed using all
possible pairs within the observation area. Then, its two components
spatial mutual information
</p>
<p style="text-align: center;"><code class="reqn">SMI(Z,W)=\sum p(w_k) \sum p(z_r|w_k)\log(p(z_r|w_k)/p(z_r))</code>
</p>

<p>and spatial residual entropy
</p>
<p style="text-align: center;"><code class="reqn">H(Z)_W=\sum p(w_k) \sum p(z_r|w_k)\log(1/p(z_r|w_k))</code>
</p>

<p>are calculated
in order to account for the overall role of space in determining
the data heterogeneity. Besides, starting from a partition into distance
classes, a list of adjacency matrices is
built, which identifies what pairs of units
must be considered for each class. Spatial mutual information and spatial residual
entropy are split into local terms according to the chosen distance breaks, so that the role of space
can be investigated both in absolute and relative terms. In the function output, the relative partial terms
are returned so that they sum to 1 for each distance class: e.g. if the relative SPI terms is 0.3 and
the relative residual term is 0.7, the interpretation is that, at the specific distance class, 30% of
the entropy is due to the role of space as a source of heterogeneity.
The function is able to work with lattice data with missing data, as long as they are specified as NAs:
missing data are ignored in the computations.
The function is able to work with grids containing missing data, specified as NA values.
All NAs are ignored in the computation and only couples of non-NA observations are considered.
</p>


<h3>Value</h3>

<p>A list with elements:
</p>

<ul>
<li> <p><code>distance.breaks</code> a two column matrix with the lower and upper extreme of each distance class
</p>
</li>
<li> <p><code>SPI.terms</code> the spatial partial information terms
</p>
</li>
<li> <p><code>rel.SPI.terms</code> the relative version of spatial partial information terms (see the details)
</p>
</li>
<li> <p><code>RES.terms</code> the spatial partial residual entropies
</p>
</li>
<li> <p><code>rel.RES.terms</code> the relative version of spatial partial residual entropies (see the details)
</p>
</li>
<li> <p><code>SMI</code> the spatial mutual information
</p>
</li>
<li> <p><code>RES</code> the global residual entropy
</p>
</li>
<li> <p><code>ShannonZ</code> Shannon's entropy of <code class="reqn">Z</code> in the same format as the output of <code><a href="#topic+shannonZ">shannonZ()</a></code>
</p>
</li>
<li> <p><code>W.distribution</code> the spatial weights for each distance range
</p>
</li>
<li> <p><code>total.pairs</code> the total number of pairs over the area (realizations of <code class="reqn">Z</code>)
</p>
</li>
<li> <p><code>class.pairs</code> the number of pairs for each distance range.
</p>
</li>
<li> <p><code>cond.Z.distribution</code> a list with the conditional absolute and relative frequencies of <code class="reqn">Z</code> for each distance range
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>#lattice data
data=matrix(sample(1:5, 100, replace=TRUE), nrow=10)
outp=altieri(data)
outp=altieri(data, cell.size=2) #same result
outp=altieri(data, cell.size=2, distbreak=c(2, 5))
#plot data
plot(as.im(data, W=square(nrow(data))),
     col=grDevices::gray(seq(1,0,l=length(unique(c(data))))),
     main="", ribbon=TRUE)

#lattice data with missing values
data=matrix(sample(1:5, 100, replace=TRUE), nrow=10)
data=rbind(rep(NA, ncol(data)), data, rep(NA, ncol(data)))
outp=altieri(data)
#plot data
plot(as.im(data, W=square(nrow(data))),
     col=topo.colors(length(unique(c(data)[!is.na(c(data))]))),
     main="", ribbon=TRUE)

#point data
data=ppp(x=runif(400), y=runif(400), window=square(1),
         marks=(sample(c("a","b","c"), 400, replace=TRUE)))
outp=altieri(data)
outp=altieri(data, verbose=TRUE)
#plot data
plot(data, cols=1:length(unique(marks(data))), main="", pch=16)
#check what happens for badly specified distance breaks
#outp=altieri(data, distbreak=c(1,1.4))
#outp=altieri(data, distbreak=c(1,2))

</code></pre>

<hr>
<h2 id='areapart'>Area partition.</h2><span id='topic+areapart'></span>

<h3>Description</h3>

<p>This function partitions the observation area in a number of sub-areas,
and assigns the data points/pixels to the areas. This function is useful either
when a random partition wants to be created, or when the user wants to set the
area's centroids and is happy with an area tessellation in Voronoi polygons according
to the defined centroids.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>areapart(data, G, cell.size = 1, win = NULL, plotout = T)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="areapart_+3A_data">data</code></td>
<td>
<p>If data are lattice, a data matrix, which can be numeric, factor, character, ...
If the dataset is a point pattern, <code>data</code> is a <code>ppp</code> object.</p>
</td></tr>
<tr><td><code id="areapart_+3A_g">G</code></td>
<td>
<p>An integer if sub-areas are randomly generated, determining the number <code class="reqn">G</code> of sub-areas.
Alternatively, a 2-column matrix with the sub-areas centroids' coordinates.</p>
</td></tr>
<tr><td><code id="areapart_+3A_cell.size">cell.size</code></td>
<td>
<p>A single number. If data are lattice, the length of the side of each pixel.
Default to 1. Ignored if data are points.</p>
</td></tr>
<tr><td><code id="areapart_+3A_win">win</code></td>
<td>
<p>Optional, the observation area given as a <code>owin</code> object. If
data are a point pattern <code>ppp</code> object, this argument is ignored
and the observation area is extracted from the object. If data are
given as a matrix and the area is not specified, the default is a
rectangle with x range from 0 to the number of columns of the data, and
y range from 0 to the number of rows of the data.</p>
</td></tr>
<tr><td><code id="areapart_+3A_plotout">plotout</code></td>
<td>
<p>Logical. Default to <code>TRUE</code>, produces an informative plot as part of the function output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is preliminary to the computation of Batty's or Karlstrom and Ceccato's entropy.
An event of interest (in the form of a point or binary areal dataset) occurs
over an observation area divided into sub-areas. If the partition is random,
this function generates the sub-areas by randomly drawing the areas' centroids
over the observation window. Then, data points/pixels are assigned to the area with
the closest centroid. When data are pixels, each pixel is assigned to an area according to
the coordinates of its own centroid.
The function also works for non-binary datasets and marked ppp objects.
</p>


<h3>Value</h3>

<p>A list with elements:
</p>

<ul>
<li> <p><code>G.pp</code> a point pattern containing the <code class="reqn">G</code> areas' centroids
</p>
</li>
<li> <p><code>data.assign</code> a four column matrix, with all pairs of data coordinates and data values
matched to one of the <code class="reqn">G</code> areas (numbered 1 to <code class="reqn">G</code>). If the dataset is an unmarked ppp
object, the data category column is a vector of 1s.
</p>
</li></ul>

<p>Moreover, a plot is produced showing the data and the area partition.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#LATTICE DATA

data=matrix(sort(sample(c("a","b","c"), 100, replace=TRUE)), nrow=10)
partition=areapart(data, G=5)
partition=areapart(data, G=5, cell.size=2)

#providing a pre-fixed area partition
data=matrix(sort(sample(c("a","b","c"), 100, replace=TRUE)), nrow=10)
win=square(nrow(data))
GG=cbind(runif(5, win$xrange[1], win$xrange[2]),
         runif(5, win$yrange[1], win$yrange[2]))
partition=areapart(data, G=GG)

#POINT DATA

data=ppp(x=runif(100), y=runif(100), window=square(1))
partition=areapart(data, 10)

#with marks
data=ppp(x=runif(100), y=runif(100), window=square(1),
         marks=(sample(c("a","b","c"), 100, replace=TRUE)))
GG=cbind(runif(10, data$window$xrange[1], data$window$xrange[2]),
         runif(10, data$window$yrange[1], data$window$yrange[2]))
partition=areapart(data, G=GG)

</code></pre>

<hr>
<h2 id='batty'>Batty's entropy.</h2><span id='topic+batty'></span>

<h3>Description</h3>

<p>This function computes Batty's spatial entropy, following Batty (1976), see also Altieri et al (2017 and following)
(references are under the topic <code><a href="#topic+SpatEntropy">SpatEntropy</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>batty(
  data,
  category = 1,
  cell.size = 1,
  partition = 10,
  win = NULL,
  rescale = T,
  plotout = T
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="batty_+3A_data">data</code></td>
<td>
<p>If data are lattice, a data matrix, which can be numeric, factor, character, ...
If the dataset is a point pattern, <code>data</code> is a <code>ppp</code> object.</p>
</td></tr>
<tr><td><code id="batty_+3A_category">category</code></td>
<td>
<p>A single value matching the data category of interest for computing Batty's entropy.
Default to 1. If the dataset is an unmarked point pattern, this argument must not be changed from the default.
In the plot, only data belonging to the selected category are displayed.</p>
</td></tr>
<tr><td><code id="batty_+3A_cell.size">cell.size</code></td>
<td>
<p>A single number or a vector of length two, only needed if data are lattice. It gives the length of the side of each pixel;
if the pixel is rectangular, the first number gives the horizontal side and the second number gives the vertical side. Default to 1. Ignored if data are points.</p>
</td></tr>
<tr><td><code id="batty_+3A_partition">partition</code></td>
<td>
<p>Input defining the partition into subareas. If an integer, it defines the
number of sub-areas that are randomly generated by <a href="#topic+areapart">areapart</a>; if a two column matrix
with coordinates, they are the centroids of the subareas built by <a href="#topic+areapart">areapart</a>. Alternatively,
it can be the output of <a href="#topic+areapart">areapart</a>, a <code>tess</code> object built by the user, a <code>list</code> object
with arguments <code>tiles</code>, i.e. a list of <code>owin</code> objects defining the partition, and <code>n</code>, the number of subareas.
Lastly, it can be an <code>im</code> object, i.e. a factor- or character-valued pixel image on the
same observation window as the data, so that the partition is defined according to the values
of the image.
The default option is <code>partition=areapart(data, G=10)</code>, which generates 10 random sub-areas.</p>
</td></tr>
<tr><td><code id="batty_+3A_win">win</code></td>
<td>
<p>Optional, the observation area given as a <code>owin</code> object. If
data are a point pattern <code>ppp</code> object, this argument is ignored
and the observation area is extracted from the object. If data are
given as a matrix, the area should be specified; the default is a
rectangle with x range from 0 to the number of columns of the data, and
y range from 0 to the number of rows of the data.</p>
</td></tr>
<tr><td><code id="batty_+3A_rescale">rescale</code></td>
<td>
<p>Logical. Default to <code>TRUE</code>, checks whether the size of the observation area or of any of the
sub-areas is smaller than 1. If so, computational issues may arise due to negative logarithms, therefore the
function automatically performs a rescaling of all sub-areas, computes the entropy over the rescaled area and
then transforms it back to the entropy of the original dataset. In such case, a warning is produced to make the user
aware of such operation.</p>
</td></tr>
<tr><td><code id="batty_+3A_plotout">plotout</code></td>
<td>
<p>Logical. Default to <code>TRUE</code>, produces an informative plot as part of the function output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Batty's spatial entropy measures the heterogeneity in the spatial distribution
of a phenomenon of interest, with regard to an area partition. It is high
when the phenomenon is equally intense over the sub-areas, and low when
it concentrates in one or few sub-areas. This function allows to compute Batty's entropy as
</p>
<p style="text-align: center;"><code class="reqn">H_B=\sum p_g \log(T_g/p_g)</code>
</p>

<p>where <code class="reqn">p_g</code> is the probability of occurrence of the phenomenon over sub-area <code class="reqn">g</code>,
and <code class="reqn">T_g</code> is the sub-area size.
When data are categorical, the phenomenon of interest corresponds to
one category, which must be specified. If data are an unmarked
point pattern, a fake mark vector is be created with the same category for all points.
For comparison purposes, the relative version of Batty's entropy is also returned, i.e.
Batty's entropy divided by its maximum <code class="reqn">\log(\sum T_g)</code>.
Note that when the total observation area is 1, then <code class="reqn">\log(\sum T_g)=0</code>, therefore
in that case during the computation all <code class="reqn">T_g</code>s are multiplied by 100 and a warning is produced.
The function is able to work with grids containing missing data, specified as NA values.
All NAs are ignored in the computation.
</p>


<h3>Value</h3>

<p>A list of five elements:
</p>

<ul>
<li> <p><code>batty</code> Batty's entropy
</p>
</li>
<li> <p><code>range</code> The theoretical range of Batty's entropy
</p>
</li>
<li> <p><code>rel.batty</code> Batty's entropy divided by <code class="reqn">\log(\sum Tg)</code> for comparison across observation areas.
</p>
</li>
<li> <p><code>areas</code> a dataframe giving, for each sub-area of the partition, the absolute and relative frequency of
the points/pixels of interest, the sub-area size and the intensity defined as <code class="reqn">pg/Tg</code>
</p>
</li>
<li> <p><code>area.tess</code> a <code>tess</code> object with the area partition
</p>
</li></ul>

<p>Moreover, a plot is produced showing the data and the area partition.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#LATTICE DATA

data=matrix((sample(c("a","b","c"), 100, replace=TRUE)), nrow=10)
batty.entropy=batty(data, category="a")

#POINT DATA

#unmarked pp
data=ppp(x=runif(100, 0, 10), y=runif(100, 0, 10), window=square(10))
batty.entropy=batty(data)

#smaller window so that some areas' size are smaller than 1
data=ppp(x=runif(100, 0, 3), y=runif(100, 0, 3), window=square(3))
batty.entropy=batty(data)

#marked pp
data=ppp(x=runif(100, 0, 10), y=runif(100, 0, 10), window=square(10),
         marks=(sample(1:5, 100, replace=TRUE)))
plot(data) #see ?plot.ppp for options
#if you want to compute the entropy on all points
batty.entropy=batty(unmark(data))
#if you want to compute the entropy on a category, say 3
batty.entropy=batty(data, category=3)

</code></pre>

<hr>
<h2 id='bologna'>Bologna urban data.</h2><span id='topic+bologna'></span>

<h3>Description</h3>

<p>A lattice dataset with Bologna's Urban Morphological Zones (UMZ, see EEA, 2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bologna
</code></pre>


<h3>Format</h3>

<p>A <code>matrix</code> with 135 rows and 124 columns. Values are either 0 (non-urban) or 1 (urban). Pixels
outside the administrative borders are classified as NA.
</p>


<h3>Details</h3>

<p>This raster/pixel/lattice dataset comes from the EU CORINE Land Cover project (EEA, 2011) and is dated 2011.
It is the result of classifying the original
land cover data into urbanised and non-urbanised zones, known as 'Urban
Morphological Zones' (UMZ, see EEA, 2011). UMZ data are useful to identify shapes
and patterns of urban areas, and thus to detect what is known as urban sprawl.
Bologna's metropolitan area is extracted from the European dataset and is
composed by the municipality of Bologna and the surrounding municipalities: .
The dataset is made of 135x124 pixels of size 250x250 metres.
</p>


<h3>Source</h3>

<p>EEA (2011). Corine land cover 2000 raster data. Technical Report, downloadable at
http://www.eea.europa.eu/data-and-maps/ data/corine-land-cover-2000-raster-1
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bologna)
#plot(as.im(bologna), main="", col=gray(c(0.8,0)), ribbon=FALSE)

#shannon's entropy
shannon(bologna)

#shannon's entropy of Z (urban/non-urban pairs)
shannonZ(bologna)

#oneill's entropy
oneill(bologna)

#leibovici's entropy on a subset of the window
bolsub=bologna[30:70,45:85]
plot(as.im(bolsub), main="", col=gray(c(0.8,0)), ribbon=FALSE)
leibovici(bolsub, cell.size=250, ccdist=400, verbose=TRUE)

#altieri's entropy
bolsub=bologna[30:70,45:85]
plot(as.im(bolsub), main="", col=gray(c(0.8,0)), ribbon=FALSE)
altieri(bolsub, cell.size=250, distbreak=c(250, 500), verbose=TRUE)

#batty's entropy
#on all points, with a random partition in 10 sub-areas
batty.ent=batty(bologna, cell.size=250, partition=10, win=bolognaW)
#plot with partition
data(bolognaW)
#plot(as.im(bologna, W=bolognaW), main="", col=gray(c(0.8,0)), ribbon=FALSE)
#plot(batty.ent$area.tess, add=TRUE, border=2)

#batty's entropy with a partition based on the administrative areas
data(bolognaTess)
batty.ent=batty(bologna, cell.size=250, partition=bolognaTess, win=bolognaW)
#plot(as.im(bologna, W=bolognaW), main="", col=gray(c(0.8,0)), ribbon=FALSE)
#for(i in 1:bolognaTess$n) plot(bolognaTess$tiles[[i]], add=TRUE, border=2)

#karlstrom and ceccato's entropy
data(bolognaW)
KC.ent=karlstrom(bologna, cell.size=250, partition=15, win=bolognaW, neigh=3)
#plot with partition
#plot(as.im(bologna, W=bolognaW), main="", col=gray(c(0.8,0)), ribbon=FALSE)
#plot(KC.ent$area.tess, add=TRUE, border=2)

#karlstrom and ceccato's entropy with a partition based on the administrative
#areas
data(bolognaTess)
KC.ent=karlstrom(bologna, cell.size=250, partition=bolognaTess, win=bolognaW,
neigh=10000, method="distance")
#plot(as.im(bologna, W=bolognaW), main="", col=gray(c(0.8,0)), ribbon=FALSE)
#for(i in 1:bolognaTess$n) plot(bolognaTess$tiles[[i]], add=TRUE, border=2)

</code></pre>

<hr>
<h2 id='bolognaTess'>Municipalities' administrative borders for Bologna urban data.</h2><span id='topic+bolognaTess'></span>

<h3>Description</h3>

<p>City borders of all municipalities included in the Bologna dataset, in the format of polyognal windows <code>owin</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bolognaTess
</code></pre>


<h3>Format</h3>

<p>A <code>list</code> of three:
</p>

<ul>
<li> <p><code>tiles</code> a <code>list</code> of 11, each element is a <code>owin</code> object with the
administrative border of one municipality of Bologna's dataset
</p>
</li>
<li> <p><code>n</code> the number of municipalities
</p>
</li>
<li> <p><code>names</code> the names of the 11 municipalities, in the same order as the windows
</p>
</li></ul>



<h3>Details</h3>

<p>The object contains a list of 11 observation windows created as <code>owin</code> objects based on the coordinates of the border polygons, for each municipality.
See <code>?owin</code> for details.
The object also contains the names of the municipalities, in Italian.
Examples on the usefulness of the administrative borders can be found at the topic <a href="#topic+bologna">bologna</a>.
</p>


<h3>Source</h3>

<p>EEA (2011). Corine land cover 2000 raster data. Technical Report, downloadable at
http://www.eea.europa.eu/data-and-maps/ data/corine-land-cover-2000-raster-1
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bologna); data(bolognaW); data(bolognaTess)
plot(bolognaW, main="")
plot(bolognaTess$tiles[[1]],border=2, add=TRUE, lwd=2)
for(ll in 2:bolognaTess$n) plot(bolognaTess$tiles[[ll]],border=2, add=TRUE, lwd=2)

plot(as.im(bologna, W=bolognaW), main="", col=gray(c(0.85,0.4)), ribbon=FALSE)
plot(bolognaTess$tiles[[1]],border=1, add=TRUE, lwd=2)
for(ll in 2:bolognaTess$n) plot(bolognaTess$tiles[[ll]],border=1, add=TRUE, lwd=2)

#see examples under the topic "bologna"
</code></pre>

<hr>
<h2 id='bolognaW'>Observation window for Bologna urban data.</h2><span id='topic+bolognaW'></span>

<h3>Description</h3>

<p>An <code>owin</code> object with the rectangle circumscribing the city border for the Bologna dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bolognaW
</code></pre>


<h3>Format</h3>

<p>An <code>owin</code> object. The basic spatial unit is a 250x250 metres pixels.
</p>


<h3>Details</h3>

<p>This observation window is an <code>owin</code> object with margins given by the CORINE project coordinates.
See <code>?owin</code> for details.
Examples on the usefulness of the window can be found at the topic <a href="#topic+bologna">bologna</a>.
</p>


<h3>Source</h3>

<p>EEA (2011). Corine land cover 2000 raster data. Technical Report, downloadable at
http://www.eea.europa.eu/data-and-maps/ data/corine-land-cover-2000-raster-1
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bolognaW)
plot(bolognaW, main="")
plot(as.im(bologna, W=bolognaW), main="", col=gray(c(0.8,0)), ribbon=FALSE, add=TRUE)

#see examples under the topic "bologna"
</code></pre>

<hr>
<h2 id='contagion'>Li and Reynolds' relative contagion index.</h2><span id='topic+contagion'></span>

<h3>Description</h3>

<p>This function computes Li and Reynold's contagion index, following Li and Reynolds (1993),
starting from a data matrix. References can be found at <code>SpatEntropy</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contagion(
  data,
  win = spatstat.geom::owin(xrange = c(0, ncol(data)), yrange = c(0, nrow(data))),
  plotout = T
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="contagion_+3A_data">data</code></td>
<td>
<p>A data matrix or vector, can be numeric, factor, character, ...</p>
</td></tr>
<tr><td><code id="contagion_+3A_win">win</code></td>
<td>
<p>Optional, an object of class <code>owin</code>, the observation window for data plotting</p>
</td></tr>
<tr><td><code id="contagion_+3A_plotout">plotout</code></td>
<td>
<p>Logical. Default to <code>TRUE</code>, produces an informative plot as part of the function output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This index is based on the transformed variable <code class="reqn">Z</code> identifying couples of realizations
of the variable of interest. A distance of interest is fixed: the contagion index is
originally thought for areas sharing a border, as O'Neill's entropy. Then, all contiguous couples
of realizations of the variable of interest are counted
and their relative frequencies are used to compute the index, which is <code class="reqn">1-NO</code> where <code class="reqn">NO</code>
is the relative version of O'Neill's entropy, i.e. O'Neill's entropy divided by its maximum <code class="reqn">\log(I^2)</code>,
<code class="reqn">I</code> being the number of categories of the variable under study. The relative contagion index ranges
from 0 (no contagion, maximum entropy) to 1 (maximum contagion).
The function is able to work with grids containing missing data, specified as NA values.
All NAs are ignored in the computation and only couples of non-NA observations are considered.
</p>


<h3>Value</h3>

<p>a list of two elements:
</p>

<ul>
<li> <p><code>contagion</code> Li and Reynold's relative contagion index
</p>
</li>
<li> <p><code>probabilities</code> a table with absolute frequencies and estimated probabilities (relative frequencies) for all couple categories
</p>
</li></ul>

<p>Moreover, a plot of the dataset is produced.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#numeric data, square grid
data=matrix(sample(1:5, 100, replace=TRUE), nrow=10)
contagion(data)
#plot data
plot(as.im(data, W=square(nrow(data))),
     col=grDevices::gray(seq(1,0,length.out=length(unique(c(data))))),
     main="", ribbon=TRUE)

#character data, rectangular grid
data=matrix(sample(c("a","b","c"), 300, replace=TRUE), nrow=30)
contagion(data)
#plot data
plot(as.im(data, W=owin(xrange=c(0,ncol(data)), yrange=c(0,nrow(data)))),
     col=terrain.colors(length(unique(c(data)))),
     main="", ribbon=TRUE)

</code></pre>

<hr>
<h2 id='karlstrom'>Karlstrom and Ceccato's entropy.</h2><span id='topic+karlstrom'></span><span id='topic+battyLISA'></span>

<h3>Description</h3>

<p>This function computes Karlstrom and Ceccato's spatial entropy for a
chosen neighbourhood distance,
following Karlstrom and Ceccato (2002), see also Altieri et al (2017) and following works
(references are under the topic <code><a href="#topic+SpatEntropy">SpatEntropy</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>karlstrom(
  data,
  category = 1,
  cell.size = 1,
  partition = 10,
  win = NULL,
  neigh = 4,
  method = "number",
  plotout = T
)

battyLISA(
  data,
  category = 1,
  cell.size = 1,
  partition = 10,
  win = NULL,
  neigh = 4,
  method = "number",
  plotout = T
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="karlstrom_+3A_data">data</code></td>
<td>
<p>If data are lattice, a data matrix, which can be numeric, factor, character, ...
If the dataset is a point pattern, <code>data</code> is a <code>ppp</code> object.</p>
</td></tr>
<tr><td><code id="karlstrom_+3A_category">category</code></td>
<td>
<p>A single value matching the data category of interest for computing Batty's entropy.
Default to 1. If the dataset is an unmarked point pattern, this argument must not be changed from the default.</p>
</td></tr>
<tr><td><code id="karlstrom_+3A_cell.size">cell.size</code></td>
<td>
<p>A single number or a vector of length two, only needed if data are lattice. It gives the length of the side of each pixel;
if the pixel is rectangular, the first number gives the horizontal side and the second number gives the vertical side. Default to 1. Ignored if data are points.</p>
</td></tr>
<tr><td><code id="karlstrom_+3A_partition">partition</code></td>
<td>
<p>Input defining the partition into subareas. If an integer, it defines the
number of sub-areas that are randomly generated by <a href="#topic+areapart">areapart</a>; if a two column matrix
with coordinates, they are the centroids of the subareas built by <a href="#topic+areapart">areapart</a>. Alternatively,
it can be the output of <a href="#topic+areapart">areapart</a>, a <code>tess</code> object built by the user, a <code>list</code> object
with arguments <code>tiles</code>, i.e. a list of <code>owin</code> objects defining the partition, and <code>n</code>, the number of subareas.
Lastly, it can be an <code>im</code> object, i.e. a factor- or character-valued pixel image on the
same observation window as the data, so that the partition is defined according to the values
of the image.
The default option is <code>partition=areapart(data, G=10)</code>, which generates 10 random sub-areas.</p>
</td></tr>
<tr><td><code id="karlstrom_+3A_win">win</code></td>
<td>
<p>Optional, the observation area given as a <code>owin</code> object. If
data are a point pattern <code>ppp</code> object, this argument is ignored
and the observation area is extracted from the object. If data are
given as a matrix and the area is not specified, the default is a
rectangle with x range from 0 to the number of columns of the data, and
y range from 0 to the number of rows of the data.</p>
</td></tr>
<tr><td><code id="karlstrom_+3A_neigh">neigh</code></td>
<td>
<p>A single number. It can be either the number of neighbours for each sub-area
(including the area itself). or the Euclidean distance to define which sub-areas are neighbours,
based on their centroids. Default to 4 neighbours.</p>
</td></tr>
<tr><td><code id="karlstrom_+3A_method">method</code></td>
<td>
<p>Character, it guides the interpretation of <code>neigh</code>. Either &quot;number&quot; (the default)
or &quot;distance&quot;.</p>
</td></tr>
<tr><td><code id="karlstrom_+3A_plotout">plotout</code></td>
<td>
<p>Logical. Default to <code>TRUE</code>, produces an informative plot as part of the function output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Karlstrom and Ceccato's spatial entropy measures the heterogeneity in the spatial distribution
of a phenomenon of interest, with regard to an area partition and accounting for the neighbourhood.
It is similar to Batty's entropy (see <a href="#topic+batty">batty</a>) discarding the sub-area size,
with the difference that the probability of occurrence of the phenomenon over area <code class="reqn">g</code>
is actually a weighted sum of the neighbouring probabilities.
</p>
<p style="text-align: center;"><code class="reqn">H_{KC}=\sum p_g \log(1/ \tilde{p}_g)</code>
</p>

<p>where <code class="reqn">p_g</code> is the probability of occurrence of the phenomenon over sub-area <code class="reqn">g</code>,
and <code class="reqn">\tilde{p}_g</code> is the averaged probability over the neighbouring areas (including the g-th area itself).
When data are categorical, the phenomenon of interest corresponds to
one category, which must be specified. If data are an unmarked
point pattern, a fake mark vector is be created with the same category for all points.
For comparison purposes, the relative version of Karlstrom and Ceccato's entropy is also returned, i.e.
Karlstrom and Ceccato's entropy divided by its maximum log(number of sub-areas).
The function is able to work with grids containing missing data, specified as NA values.
All NAs are ignored in the computation.
</p>


<h3>Value</h3>

<p>A list of five elements:
</p>

<ul>
<li> <p><code>karlstrom</code> Karlstrom and Ceccato's entropy
</p>
</li>
<li> <p><code>range</code> The theoretical range of Karlstrom and Ceccato's entropy
</p>
</li>
<li> <p><code>rel.karl</code> Karlstrom and Ceccato's entropy divided by <code class="reqn">\log(G)</code> (number og sub-areas) for comparison across observation areas.
</p>
</li>
<li> <p><code>areas</code> a dataframe giving, for each sub-area, the absolute and relative frequency of
the points/pixels of interest, the weighted probabilities of the neighbours and the sub-area size
</p>
</li>
<li> <p><code>area.tess</code> a <code>tess</code> object with the area partition
</p>
</li></ul>

<p>Moreover, a plot is produced showing the data and the area partition.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#LATTICE DATA

data=matrix((sample(c("a","b","c"), 100, replace=TRUE)), nrow=10)
KC.entropy=karlstrom(data, category="a")
KC.entropy=karlstrom(data, category="a", neigh=3.5, method="distance")
##to plot
data.binary=matrix(as.numeric(data=="a"), nrow(data))
plot(as.im(data.binary, W=KC.entropy$area.tess$window), main="",
     col=grDevices::gray(seq(1,0,l=length(unique(c(data.binary))))), ribbon=FALSE)
plot(KC.entropy$area.tess, add=TRUE, border=2)

#POINT DATA

#unmarked pp
data=ppp(x=runif(100, 0, 10), y=runif(100, 0, 10), window=square(10))
KC.entropy=karlstrom(data)
##to plot
plot(data)
plot(KC.entropy$area.tess, add=TRUE, border=2)

#marked pp
data=ppp(x=runif(100, 0, 10), y=runif(100, 0, 10), window=square(10),
         marks=(sample(1:5, 100, replace=TRUE)))
#if you want to compute the entropy on all points
KC.entropy=karlstrom(unmark(data))
#if you want to compute the entropy on a category, say 3
KC.entropy=karlstrom(data, category=3)
##to plot using the selected category
ind=which(spatstat.geom::marks(data)==3)
data.binary=unmark(data[ind])
plot(data.binary)
plot(KC.entropy$area.tess, add=TRUE, border=2)

</code></pre>

<hr>
<h2 id='leibovici'>Leibovici's entropy.</h2><span id='topic+leibovici'></span>

<h3>Description</h3>

<p>This function computes Leibovici's entropy according to a chosen distance <code class="reqn">d</code>
(with O'Neill's entropy as a special case)
following Leibovici (2009), see also Altieri et al (2017). References can be found at <code>SpatEntropy</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>leibovici(
  data,
  cell.size = 1,
  ccdist = cell.size[1],
  win = NULL,
  verbose = F,
  plotout = T
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="leibovici_+3A_data">data</code></td>
<td>
<p>If data are lattice, a data matrix, which can be numeric, factor, character, ...
If the dataset is a point pattern, <code>data</code> is a <code>ppp</code> object.</p>
</td></tr>
<tr><td><code id="leibovici_+3A_cell.size">cell.size</code></td>
<td>
<p>A single number or a vector of length two, only needed if data are lattice. It gives the length of the side of each pixel;
if the pixel is rectangular, the first number gives the horizontal side and the second number gives the vertical side. Default to 1. Ignored if data are points.</p>
</td></tr>
<tr><td><code id="leibovici_+3A_ccdist">ccdist</code></td>
<td>
<p>A single number. The chosen distance for selecting couples of pixels/points within the observation area. Default to <code>cell.size[1]</code>.</p>
</td></tr>
<tr><td><code id="leibovici_+3A_win">win</code></td>
<td>
<p>Optional, an object of class <code>owin</code>, the observation window for data plotting</p>
</td></tr>
<tr><td><code id="leibovici_+3A_verbose">verbose</code></td>
<td>
<p>Logical. If <code>TRUE</code> an output is printed in order to follow the progress of the work (recommended for large dataset).
Default set to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="leibovici_+3A_plotout">plotout</code></td>
<td>
<p>Logical. Default to <code>TRUE</code>, produces an informative plot as part of the function output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This index is based on the transformed variable <code class="reqn">Z</code> identifying couples of realizations
of the variable of interest. A distance of interest is fixed, which in the case of O'Neill's
entropy is the contiguity, i.e. sharing a border for lattice data. Then, all couples
of realizations of the variable of interest lying at a distance smaller or equal to the distance of interest
are counted, and their relative frequencies are used to compute the index with the traditional Shannon's
formula.
#'</p>
<p style="text-align: center;"><code class="reqn">H_L(Z)=\sum p(z_r|d) \log(1/p(z_r|d))</code>
</p>

<p>where <code class="reqn">z_r=(x_i, x_{i'})</code> is a generic couple of realizations of the study variable <code class="reqn">X</code>.
The conditioning on <code class="reqn">d</code> means that only couples within a predefined distance are considered.
The maximum value for Leibovici's entropy is
<code class="reqn">\log(I^2)</code> where <code class="reqn">I</code> is the number of categories of the study variable <code class="reqn">X</code>.
The relative version of Leibovici's entropy is obtained by dividing the entropy value by its maximum, and is useful for comparison across datasets with
a different number of categories.
The function is able to work with grids containing missing data, specified as NA values.
All NAs are ignored in the computation and only couples of non-NA observations are considered.
</p>


<h3>Value</h3>

<p>a list of four elements:
</p>

<ul>
<li> <p><code>leib</code> Leibovici's entropy
</p>
</li>
<li> <p><code>range</code> the theoretical range of Leibovici's entropy, from 0 to <code class="reqn">\log(I^2)</code>
</p>
</li>
<li> <p><code>rel.leib</code> Leibovici's relative entropy
</p>
</li>
<li> <p><code>probabilities</code> a table with absolute frequencies and estimated probabilities (relative frequencies) for all couple categories
</p>
</li></ul>

<p>Moreover, a plot of the dataset is produced. Over the plot, a random point is displayed as a red star, and a circle is plotted
around that point. The radius of the circle is set by <code>ccdist</code>, so that a visual idea is given about the
choice of the distance for building co-occurrences.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#random grid data - high entropy
data=matrix(sample(c("a","b","c"), 400, replace=TRUE), nrow=20)
leibovici(data, cell.size=1, ccdist=2)
#plot data
plot(as.im(data, W=square(nrow(data))),
     col=grDevices::gray(seq(1,0,length.out=length(unique(c(data))))),
     main="", ribbon=TRUE)

#compact grid data - low entropy
data=matrix(sort(sample(c("a","b","c"), 400, replace=TRUE)), nrow=20)
#Note: with sorted data, only some couple categories will be present
leibovici(data, cell.size=1, ccdist=1.5)
#plot data
plot(as.im(data, W=square(nrow(data))),
     col=heat.colors(length(unique(c(data)))),
     main="", ribbon=TRUE)

#point data
data=ppp(x=runif(400), y=runif(400),
window=square(1), marks=sample(1:4, 400, replace=TRUE))
leibovici(data, ccdist=0.1)
#plot data
plot(data)

</code></pre>

<hr>
<h2 id='oneill'>O'Neill's entropy.</h2><span id='topic+oneill'></span>

<h3>Description</h3>

<p>This function computes O'Neill's entropy for a data matrix (see O'Neill et al, 1988).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oneill(
  data,
  win = spatstat.geom::owin(xrange = c(0, ncol(data)), yrange = c(0, nrow(data))),
  plotout = T
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="oneill_+3A_data">data</code></td>
<td>
<p>A data matrix, can be numeric, factor, character, ...</p>
</td></tr>
<tr><td><code id="oneill_+3A_win">win</code></td>
<td>
<p>Optional, an object of class <code>owin</code>, the observation window for data plotting</p>
</td></tr>
<tr><td><code id="oneill_+3A_plotout">plotout</code></td>
<td>
<p>Logical. Default to <code>TRUE</code>, produces an informative plot as part of the function output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>O'Neill's entropy index is based on the transformed variable <code class="reqn">Z</code>, identifying couples of realizations
of the variable of interest:
</p>
<p style="text-align: center;"><code class="reqn">H_O(Z)=\sum p(z_r|C) \log(1/p(z_r|C))</code>
</p>

<p>where <code class="reqn">z_r=(x_i, x_{i'})</code> is a generic couple of realizations of the study variable <code class="reqn">X</code>.
The conditioning on <code class="reqn">C</code> for grid data means that only contiguous couples are considered, i.e.
couples of pixels sharing a border.
All contiguous couples of realizations of the variable of interest are counted
and their relative frequencies are used to compute the index. The maximum value for O'Neill's entropy is
<code class="reqn">\log(I^2)</code> where <code class="reqn">I</code> is the number of categories of <code class="reqn">X</code>. The relative version of O'Neill's entropy
is obtained by dividing the entropy value by its maximum, and is useful for comparison across datasets with
a different number of categories.
The function is able to work with grids containing missing data, specified as NA values.
All NAs are ignored in the computation and only couples of non-NA observations are considered.
</p>


<h3>Value</h3>

<p>a list of four elements:
</p>

<ul>
<li> <p><code>oneill</code> O'Neill's entropy
</p>
</li>
<li> <p><code>range</code> the theoretical range of O'Neill's entropy, from 0 to <code class="reqn">\log(I^2)</code>
</p>
</li>
<li><p><code>rel.oneill</code> O'Neill's relative entropy
</p>
</li>
<li> <p><code>probabilities</code> a table with absolute frequencies and estimated probabilities (relative frequencies) for all couple categories
</p>
</li></ul>

<p>Moreover, a plot of the dataset is produced.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#numeric data, square grid
data=matrix(sample(1:5, 100, replace=TRUE), nrow=10)
oneill(data)
#plot data
plot(as.im(data, W=square(nrow(data))),
     col=grDevices::gray(seq(1,0,length.out=length(unique(c(data))))),
     main="", ribbon=TRUE)

#character data, rectangular grid
data=matrix(sample(c("a","b","c"), 300, replace=TRUE), nrow=30)
oneill(data)
#plot data
plot(as.im(data, W=owin(xrange=c(0,ncol(data)), yrange=c(0,nrow(data)))),
     col=terrain.colors(length(unique(c(data)))),
     main="", ribbon=TRUE)

#data with missing values
data=matrix(sample(1:5, 100, replace=TRUE), nrow=10)
data=rbind(rep(NA, ncol(data)), data, rep(NA, ncol(data)))
oneill(data)

</code></pre>

<hr>
<h2 id='parredw'>Parresol and Edwards' entropy.</h2><span id='topic+parredw'></span>

<h3>Description</h3>

<p>Compute Parresol and Edwards' entropy, following Parresol and Edwards (2014),
starting from data. References can be found at <code>SpatEntropy</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parredw(
  data,
  win = spatstat.geom::owin(xrange = c(0, ncol(data)), yrange = c(0, nrow(data))),
  plotout = T
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parredw_+3A_data">data</code></td>
<td>
<p>A data matrix or vector, can be numeric, factor, character, ...</p>
</td></tr>
<tr><td><code id="parredw_+3A_win">win</code></td>
<td>
<p>Optional, an object of class <code>owin</code>, the observation window for data plotting</p>
</td></tr>
<tr><td><code id="parredw_+3A_plotout">plotout</code></td>
<td>
<p>Logical. Default to <code>TRUE</code>, produces an informative plot as part of the function output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This index is based on the transformed variable <code class="reqn">Z</code> identifying couples of realizations
of the variable of interest. A distance of interest is fixed: Parresol and Edwards' entropy is
thought for areas sharing a border, as O'Neill's entropy. All contiguous couples
of realizations of the variable of interest are counted
and their relative frequencies are used to compute the index, which is the opposite of O'Neill's entropy.
The function is able to work with grids containing missing data, specified as NA values.
All NAs are ignored in the computation and only couples of non-NA observations are considered.
</p>


<h3>Value</h3>

<p>a list of four elements:
</p>

<ul>
<li> <p><code>parredw</code> Parresol and Edwards' entropy
</p>
</li>
<li> <p><code>range</code> the theoretical range of Parresol and Edwards' entropy, from <code class="reqn">-\log(I^2)</code> to 0
</p>
</li>
<li><p><code>rel.parredw</code> Parresol and Edwards' relative entropy (with the same interpretation as O'Neill's relative entropy)
</p>
</li>
<li> <p><code>probabilities</code> a table with absolute frequencies and estimated probabilities (relative frequencies) for all couple categories
</p>
</li></ul>

<p>Moreover, a plot of the dataset is produced.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#numeric data, square grid
data=matrix(sample(1:5, 100, replace=TRUE), nrow=10)
parredw(data)
#plot data
plot(as.im(data, W=square(nrow(data))),
     col=grDevices::gray(seq(1,0,length.out=length(unique(c(data))))),
     main="", ribbon=TRUE)

#character data, rectangular grid
data=matrix(sample(c("a","b","c"), 300, replace=TRUE), nrow=30)
parredw(data)
#plot data
plot(as.im(data, W=owin(xrange=c(0,ncol(data)), yrange=c(0,nrow(data)))),
     col=terrain.colors(length(unique(c(data)))),
     main="", ribbon=TRUE)

</code></pre>

<hr>
<h2 id='raintrees'>Rainforest tree data 1.</h2><span id='topic+raintrees'></span>

<h3>Description</h3>

<p>A marked point pattern dataset about four rainforest tree species:
Acalypha diversifolia, Chamguava schippii,
Inga pezizifera and Rinorea sylvatica
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raintrees
</code></pre>


<h3>Format</h3>

<p>A <code>ppp</code> object (see package <code>spatstat</code>) with 7251 points, containing:
</p>

<dl>
<dt>window</dt><dd><p>An object of type <code>owin</code> (see package <code>spatstat</code>), the 1000x500 metres observation area</p>
</dd>
<dt>x, y</dt><dd><p>Numeric vectors with points' coordinates</p>
</dd>
<dt>marks</dt><dd><p>A character vector matching the tree species to the data points</p>
</dd>
</dl>



<h3>Details</h3>

<p>This dataset documents the presence of tree species over Barro Colorado Island, Panama.
Barro Colorado Island has been the focus of intensive research on lowland tropical
rainforest since 1923 (http://www.ctfs.si.edu). Research identified several tree species
over a rectangular observation window of size 1000x500 metres; the tree species
constitute the point data categorical mark. This dataset presents 4 species with
different spatial configurations: Acalypha diversifolia, Chamguava schippii,
Inga pezizifera and Rinorea sylvatica. The overall dataset has a total number of 7251 points.
The dataset is analyzed with spatial entropy measures in Altieri et al (2018) (references can be
found at <code>SpatEntropy</code>).
</p>


<h3>Source</h3>

<p>http://www.ctfs.si.edu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(raintrees)
#plot(raintrees, main="", pch=16, cols=1:4)

#shannon's entropy of the four trees
shannon(raintrees)

#shannon's entropy of Z (tree pairs)
shannonZ(raintrees)

#leibovici's entropy
raintrees$window #to check size and unit of measurement
#example run on a subset of the data to speed up computations
subdata=raintrees[owin(c(0,200),c(0,100))]; plot(subdata)
outp=leibovici(subdata, ccdist=10, verbose=TRUE)
#do not worry about warnings like "data contain duplicated points": since
#coordinates are rounded to the first decimal place, it looks like
#some trees are overlapping when they are just very close.
#Entropy computation works properly anyway

#altieri's entropy
#example run on a subset of the data to speed up computations
subdata=raintrees[owin(c(0,200),c(0,100))]; plot(subdata)
outp=altieri(subdata, distbreak=c(1,2,5,10), verbose=TRUE)

#batty's entropy
#on all points, with a random partition in 10 sub-areas
batty.ent=batty(unmark(raintrees), partition=10)
#plot with partition
#plot(unmark(raintrees), pch=16, cex=0.6, main="")
#plot(batty.ent$area.tess, add=TRUE, border=2, lwd=2)
#on a specific tree species, with a random partition in 6 sub-areas
unique(marks(raintrees)) #to check the species' names
#plot(split.ppp(raintrees), main="") #to plot by species
batty.ent=batty(raintrees, category="cha2sc", partition=6)
#plot with partition
#plot(split.ppp(raintrees)$cha2sc, pch=16, cex=0.6, main="")
#plot(batty.ent$area.tess, add=TRUE, border=2)

#batty's entropy with a partition based on the covariate,
#exploiting spatstat functions
data(raintreesCOV)
#plot(raintreesCOV$grad, main="", col=gray(seq(1,0,l=100)))
data=split.ppp(raintrees)$acaldi
#plot(data, add=TRUE, pch=16, cex=0.6, main="")
#discretize the covariate
slopecut=cut(raintreesCOV$grad,
                breaks = quantile(raintreesCOV$grad, probs = (0:4)/4),
                labels = 1:4)
maskv=tiles=list()
for(ii in 1:nlevels(slopecut))
{
maskv[[ii]]=as.logical(c(slopecut$v)==levels(slopecut)[ii])
tiles[[ii]]=owin(xrange=data$window$xrange,
                 yrange=data$window$yrange,
                 mask=matrix(maskv[[ii]],nrow(slopecut$v)))
}
slopetess=list(tiles=tiles, n=nlevels(slopecut))
#plot(slopecut, main = "", col=gray(seq(1,0.4,l=4)))
#plot(data, add=TRUE, pch=16, cex=0.6, main="", col=1)

batty(data, partition=slopetess)

#karlstrom and ceccato's entropy
#on a specific tree species, with a random partition in 6 sub-areas
unique(marks(raintrees)) #to check the species' names
#plot(split.ppp(raintrees), main="") #to plot by species
KC.ent=karlstrom(raintrees, category="rinosy", partition=6, neigh=3)
#plot with partition
#plot(split.ppp(raintrees)$rinosy, pch=16, cex=0.6, main="")
#plot(KC.ent$area.tess, add=TRUE, border=2)
</code></pre>

<hr>
<h2 id='raintrees2'>Rainforest tree data 2.</h2><span id='topic+raintrees2'></span>

<h3>Description</h3>

<p>A marked point pattern dataset about four rainforest tree species:
Astronium graveolens, Beilschmiedia pendula, Heisteria concinna and Inga sapindoides.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raintrees2
</code></pre>


<h3>Format</h3>

<p>A <code>ppp</code> object (see package <code>spatstat</code>) with 5639 points, containing:
</p>

<dl>
<dt>window</dt><dd><p>An object of type <code>owin</code> (see package <code>spatstat</code>), the 1000x500 metres observation area</p>
</dd>
<dt>x, y</dt><dd><p>Numeric vectors with points' coordinates</p>
</dd>
<dt>marks</dt><dd><p>A character vector matching the tree species to the data points</p>
</dd>
</dl>



<h3>Details</h3>

<p>This dataset documents the presence of tree species over Barro Colorado Island, Panama.
Barro Colorado Island has been the focus of intensive research on lowland tropical
rainforest since 1923 (http://www.ctfs.si.edu). Research identified several tree species
over a rectangular observation window of size 1000x500 metres; the tree species
constitute the point data categorical mark. This dataset presents 4 species with
different spatial configurations: Astronium graveolens, Beilschmiedia pendula, Heisteria concinna and Inga sapindoides. The overall dataset has a total number of 5639 points.
</p>


<h3>Source</h3>

<p>http://www.ctfs.si.edu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(raintrees2)
#plot(raintrees2, main="", pch=16, cols=1:4)

#shannon's entropy of the four trees
shannon(raintrees2)

#shannon's entropy of Z (tree pairs)
shannonZ(raintrees2)

#leibovici's entropy
raintrees2$window #to check size and unit of measurement
#example run on a subset of the data to speed up computations
subdata=raintrees2[owin(c(0,200),c(0,100))]; plot(subdata)
outp=leibovici(subdata, ccdist=10, verbose=TRUE)
#do not worry about warnings like "data contain duplicated points": since
#coordinates are rounded to the first decimal place, it looks like
#some trees are overlapping when they are just very close.
#Entropy computation works properly anyway

#altieri's entropy
#example run on a subset of the data to speed up computations
subdata=raintrees2[owin(c(0,200),c(0,100))]; plot(subdata)
outp=altieri(subdata, distbreak=c(1,2,5,10), verbose=TRUE)

#batty's entropy
#on all points, with a random partition in 10 sub-areas
batty.ent=batty(unmark(raintrees2), partition=10)
#plot with partition
#plot(unmark(raintrees2), pch=16, cex=0.6, main="")
#plot(batty.ent$area.tess, add=TRUE, border=2, lwd=2)
#on a specific tree species, with a random partition in 6 sub-areas
unique(marks(raintrees2)) #to check the species' names
#plot(split.ppp(raintrees2), main="") #to plot by species
batty.ent=batty(raintrees2, category=levels(marks(raintrees2))[1], partition=6)
#plot with partition
#plot(split.ppp(raintrees2)[[1]], pch=16, cex=0.6, main="")
#plot(batty.ent$area.tess, add=TRUE, border=2)

#batty's entropy with a partition based on the covariate,
#exploiting spatstat functions
data(raintreesCOV)
#plot(raintreesCOV$grad, main="", col=gray(seq(1,0,l=100)))
data=split.ppp(raintrees2)[[1]]
#plot(data, add=TRUE, pch=16, cex=0.6, main="")
#discretize the covariate
slopecut=cut(raintreesCOV$grad,
                breaks = quantile(raintreesCOV$grad, probs = (0:4)/4),
                labels = 1:4)
maskv=tiles=list()
for(ii in 1:nlevels(slopecut))
{
maskv[[ii]]=as.logical(c(slopecut$v)==levels(slopecut)[ii])
tiles[[ii]]=owin(xrange=data$window$xrange,
                 yrange=data$window$yrange,
                 mask=matrix(maskv[[ii]],nrow(slopecut$v)))
}
slopetess=list(tiles=tiles, n=nlevels(slopecut))
#plot(slopecut, main = "", col=gray(seq(1,0.4,l=4)))
#plot(data, add=TRUE, pch=16, cex=0.6, main="", col=1)

batty(data, partition=slopetess)

#karlstrom and ceccato's entropy
#on a specific tree species, with a random partition in 6 sub-areas
unique(marks(raintrees2)) #to check the species' names
#plot(split.ppp(raintrees2), main="") #to plot by species
KC.ent=karlstrom(raintrees2, category=levels(marks(raintrees2))[2], partition=6, neigh=3)
#plot with partition
#plot(split.ppp(raintrees2)[[2]], pch=16, cex=0.6, main="")
#plot(KC.ent$area.tess, add=TRUE, border=2)
</code></pre>

<hr>
<h2 id='raintreesCOV'>Covariates for the rainforest tree data.</h2><span id='topic+raintreesCOV'></span>

<h3>Description</h3>

<p>A list of two pixel images with covariates altitude and soil slope for the rainforest tree data 1 and 2,
i.e. <a href="#topic+raintrees">raintrees</a> and <a href="#topic+raintrees2">raintrees2</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raintreesCOV
</code></pre>


<h3>Format</h3>

<p>A <code>list</code> of two elements:
</p>

<dl>
<dt>elev</dt><dd><p>An object of type <code>im</code> (see package <code>spatstat</code>), the soil elevation</p>
</dd>
<dt>grad</dt><dd><p>An object of type <code>im</code> (see package <code>spatstat</code>), the soil slope (gradient of elevation)</p>
</dd>
</dl>



<h3>Details</h3>

<p>For details of the point datasets, see <a href="#topic+raintrees">raintrees</a> and <a href="#topic+raintrees2">raintrees2</a>. This accompanying dataset
gives information about the elevation in the study region.
It is a list containing two pixel images, elev (elevation in metres)
and grad (norm of elevation gradient). These pixel images are objects of class <code>im</code>.
Covariate values are continuous. Once discretized as wished, they can turn into categorical datasets
for the computation of all entropy measures. Moreover, they can be used
to build sensible sub-areas for Batty's and Karlstrom and Ceccato's entropies
(see the examples).
</p>


<h3>Source</h3>

<p>http://www.ctfs.si.edu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(raintreesCOV)
plot(raintreesCOV, main="")

</code></pre>

<hr>
<h2 id='shannon'>Shannon's entropy.</h2><span id='topic+shannon'></span>

<h3>Description</h3>

<p>This function computes Shannon's entropy of a variable <code class="reqn">X</code> with a finite number of categories. Shannon's entropy is a non-spatial measure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shannon(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shannon_+3A_data">data</code></td>
<td>
<p>A data matrix or vector, can be numeric, factor, character, ...
Alternatively, a marked <code>ppp</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Shannon's entropy measures the heterogeneity of a set of categorical data. It
is computed as </p>
<p style="text-align: center;"><code class="reqn">H(X)=\sum p(x_i) \log(1/p(x_i))</code>
</p>
<p> where <code class="reqn">p(x_i)</code> is the
probability of occurrence of the <code class="reqn">i</code>-th category, here estimated, as usual, by its relative
frequency. This is both the non parametric and the maximum likelihood estimator for entropy.
Shannon's entropy varies between 0 and <code class="reqn">\log(I)</code>, <code class="reqn">I</code> being the
number of categories of the variable under study. The relative version of Shannon's entropy, i.e. the entropy divided by
<code class="reqn">\log(I)</code>, is also computed, under the assumption that all data categories are present in the dataset.
The relative entropy is useful for comparison across datasets with differen <code class="reqn">I</code>.
The function is able to work with lattice data with missing data, as long as they are specified as NAs:
missing data are ignored in the computations.
</p>


<h3>Value</h3>

<p>a list of four elements:
</p>

<ul>
<li> <p><code>shann</code> Shannon's entropy
</p>
</li>
<li> <p><code>range</code> The theoretical range of Shannon's entropy, from 0 to <code class="reqn">\log(I)</code>
</p>
</li>
<li> <p><code>rel.shann</code> Shannon's relative entropy
</p>
</li>
<li> <p><code>probabilities</code> a table with absolute frequencies and estimated probabilities (relative frequencies) for all data categories
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>#NON SPATIAL DATA
shannon(sample(1:5, 50, replace=TRUE))

#POINT DATA
#requires marks with a finite number of categories
data.pp=runifpoint(100, win=square(10))
marks(data.pp)=sample(c("a","b","c"), 100, replace=TRUE)
shannon(marks(data.pp))

#LATTICE DATA
data.lat=matrix(sample(c("a","b","c"), 100, replace=TRUE), nrow=10)
shannon(data.lat)

</code></pre>

<hr>
<h2 id='shannonZ'>Shannon's entropy of the transformed variable <code class="reqn">Z</code>.</h2><span id='topic+shannonZ'></span>

<h3>Description</h3>

<p>This function computes Shannon's entropy of variable <code class="reqn">Z</code>,
where <code class="reqn">Z</code> identifies pairs of realizations of the variable of interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shannonZ(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shannonZ_+3A_data">data</code></td>
<td>
<p>A data matrix or vector, can be numeric, factor, character, ...
Alternatively, a marked <code>ppp</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Many spatial entropy indices are based on the trasformation <code class="reqn">Z</code> of the study variable,
i.e. on pairs (unordered couples) of realizations of the variable of interest. 'Unordered couples'
means that the relative spatial location is irrelevant, i.e. that a couple
where category <code class="reqn">i</code> occurs at the left of category <code class="reqn">j</code> is identical to a couple
where category <code class="reqn">j</code> occurs at the left of category <code class="reqn">i</code>.
When all possible pairs occurring within the observation areas are considered,
Shannon's entropy of the variable <code class="reqn">Z</code> may be computed as
</p>
<p style="text-align: center;"><code class="reqn">H(Z)=\sum p(z_r)\log(1/p(z_r))</code>
</p>

<p>where <code class="reqn">p(z_r)</code> is the probability of the <code class="reqn">r</code>-th pair of realizations, here
estimated by its relative frequency.
Shannon's entropy of <code class="reqn">Z</code> varies between 0 and <code class="reqn">\log(R)</code>, <code class="reqn">R=binom(n+1,2)</code> (where <code class="reqn">n</code> is the number of observations) being the
number of possible pairs of categories of the variable under study.
The function is able to work with lattice data with missing data, as long as they are specified as NAs:
missing data are ignored in the computations.
</p>


<h3>Value</h3>

<p>a list of three elements:
</p>

<ul>
<li> <p><code>shannZ</code> Shannon's entropy of <code class="reqn">Z</code>
</p>
</li>
<li> <p><code>range</code> The theoretical range of Shannon's entropy of <code class="reqn">Z</code>,
from 0 to <code class="reqn">\log(R)</code>
</p>
</li>
<li> <p><code>rel.shannZ</code> Shannon's relative entropy of <code class="reqn">Z</code>
</p>
</li>
<li> <p><code>probabilities</code> a table with absolute frequencies and estimated probabilities (relative frequencies) for all <code class="reqn">Z</code> categories (data pairs)
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>#NON SPATIAL DATA
shannonZ(sample(1:5, 50, replace=TRUE))

#POINT DATA
data.pp=runifpoint(100, win=square(10))
marks(data.pp)=sample(c("a","b","c"), 100, replace=TRUE)
shannonZ(marks(data.pp))

#LATTICE DATA
data.lat=matrix(sample(c("a","b","c"), 100, replace=TRUE), nrow=10)
shannonZ(data.lat)

</code></pre>

<hr>
<h2 id='turin'>Turin urban data.</h2><span id='topic+turin'></span>

<h3>Description</h3>

<p>A lattice dataset with Turin's Urban Morphological Zones (UMZ, see EEA, 2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>turin
</code></pre>


<h3>Format</h3>

<p>A <code>matrix</code> with 111 rows and 113 columns. Values are either 0 (non-urban) or 1 (urban). Pixels
outside the administrative borders are classified as NA.
</p>


<h3>Details</h3>

<p>This raster/pixel/lattice dataset comes from the EU CORINE Land Cover project (EEA, 2011) and is dated 2011.
It is the result of classifying the original
land cover data into urbanised and non-urbanised zones, known as 'Urban
Morphological Zones' (UMZ, see EEA, 2011). UMZ data are useful to identify shapes
and patterns of urban areas, and thus to detect what is known as urban sprawl.
Turin's metropolitan area is extracted from the European dataset and is
composed by the municipality of Turin and the surrounding municipalities: Beinasco, Venaria Reale,
San Mauro Torinese, Grugliasco, Borgaro Torinese, Collegno, Pecetto Torinese, Pino Torinese,
Moncalieri, Nichelino, Settimo Torinese, Baldissero Torinese, Rivoli, Orbassano.
The dataset is made of 111x113 pixels of size 250x250 metres.
</p>


<h3>Source</h3>

<p>EEA (2011). Corine land cover 2000 raster data. Technical Report, downloadable at
http://www.eea.europa.eu/data-and-maps/ data/corine-land-cover-2000-raster-1
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(turin)
#plot(as.im(turin), main="", col=gray(c(0.8,0)), ribbon=FALSE)

#shannon's entropy
shannon(turin)

#shannon's entropy of Z (urban/non-urban pairs)
shannonZ(turin)

#oneill's entropy
oneill(turin)

#leibovici's entropy only on Collegno's municipality
data(turinTess)
cell.size=250; ncl=ncol(turin); nrw=nrow(turin)
coords=expand.grid(rev(seq(cell.size/2, (nrw*cell.size-cell.size/2), l=nrw)),
                   seq(cell.size/2, (ncl*cell.size-cell.size/2), l=ncl))
data.pp=ppp(x=coords[which(!is.na(c(turin))),2],
            y=coords[which(!is.na(c(turin))),1],
            window=owin(xrange=c(0, ncl*cell.size), yrange=c(0,nrw*cell.size)),
            marks=c(turin)[which(!is.na(c(turin)))])
data=data.pp[turinTess$tiles[[which(turinTess$names=="Collegno")]]]
#plot(data, pch=16, cex=0.4)
outp=leibovici(data, cell.size=250, ccdist=400, verbose=TRUE)

#altieri's entropy only on Collegno's municipality
outp=altieri(data, cell.size=250, distbreak=c(cell.size, 2*cell.size), verbose=TRUE)

#batty's entropy
#on all points, with a random partition in 10 sub-areas
batty.ent=batty(turin, cell.size=250, partition=10)
#plot with partition
data(turinW)
#plot(as.im(turin, W=turinW), main="", col=gray(c(0.8,0)), ribbon=FALSE)
#plot(batty.ent$area.tess, add=TRUE, border=2)

#batty's entropy with a partition based on the administrative areas
data(turinTess)
batty.ent=batty(turin, cell.size=250, partition=turinTess)
#plot(as.im(turin, W=turinW), main="", col=gray(c(0.8,0)), ribbon=FALSE)
#for(i in 1:turinTess$n) plot(turinTess$tiles[[i]], add=TRUE, border=2)

#karlstrom and ceccato's entropy
data(turinW)
KC.ent=karlstrom(turin, cell.size=250, partition=15, neigh=3)
#plot with partition
#plot(as.im(turin, W=turinW), main="", col=gray(c(0.8,0)), ribbon=FALSE)
#plot(KC.ent$area.tess, add=TRUE, border=2)

#karlstrom and ceccato's entropy with a partition based on the administrative areas
data(turinTess)
KC.ent=karlstrom(turin, cell.size=250, partition=turinTess, neigh=5000, method="distance")
#plot(as.im(turin, W=turinW), main="", col=gray(c(0.8,0)), ribbon=FALSE)
#for(i in 1:turinTess$n) plot(turinTess$tiles[[i]], add=TRUE, border=2)

</code></pre>

<hr>
<h2 id='turinTess'>Municipalities' administrative borders for Turin urban data.</h2><span id='topic+turinTess'></span>

<h3>Description</h3>

<p>City borders of all municipalities included in the Turin dataset, in the format of polyognal windows <code>owin</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>turinTess
</code></pre>


<h3>Format</h3>

<p>A <code>list</code> of three:
</p>

<ul>
<li> <p><code>tiles</code> a <code>list</code> of 15, each element is a <code>owin</code> object with the
administrative border of one municipality of Turin's dataset
</p>
</li>
<li> <p><code>n</code> the number of municipalities
</p>
</li>
<li> <p><code>names</code> the names of the 15 municipalities, in the same order as the windows
</p>
</li></ul>



<h3>Details</h3>

<p>The object contains a list of 15 observation windows created as <code>owin</code> objects based on the coordinates of the border polygons, for each municipality.
See <code>?owin</code> for details.
The object also contains the names of the municipalities, in Italian.
Examples on the usefulness of the administrative borders can be found at the topic <a href="#topic+turin">turin</a>.
</p>


<h3>Source</h3>

<p>EEA (2011). Corine land cover 2000 raster data. Technical Report, downloadable at
http://www.eea.europa.eu/data-and-maps/ data/corine-land-cover-2000-raster-1
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(turin); data(turinW); data(turinTess)
plot(turinW, col=c("black", "white"), main="")
plot(turinTess$tiles[[1]],border=2, add=TRUE, lwd=2)
for(ll in 2:turinTess$n) plot(turinTess$tiles[[ll]],border=2, add=TRUE, lwd=2)

plot(as.im(turin, W=turinW), main="", col=gray(c(0.85,0.4)), ribbon=FALSE)
plot(turinTess$tiles[[1]],border=1, add=TRUE, lwd=2)
for(ll in 2:turinTess$n) plot(turinTess$tiles[[ll]],border=1, add=TRUE, lwd=2)

#see examples under the topic "turin"
</code></pre>

<hr>
<h2 id='turinW'>Observation window for Turin urban data.</h2><span id='topic+turinW'></span>

<h3>Description</h3>

<p>An <code>owin</code> object with the city border for the Turin dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>turinW
</code></pre>


<h3>Format</h3>

<p>An <code>owin</code> object. Units are given in metres; the basic image unit is a 250x250 metres pixels.
</p>


<h3>Details</h3>

<p>This observation window is an <code>owin</code> object created as a binary mask. See <code>?owin</code> for details.
Examples on the usefulness of the window can be found at the topic <a href="#topic+turin">turin</a>.
</p>


<h3>Source</h3>

<p>EEA (2011). Corine land cover 2000 raster data. Technical Report, downloadable at
http://www.eea.europa.eu/data-and-maps/ data/corine-land-cover-2000-raster-1
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(turinW)
plot(turinW, col=c("red", "white"), main="")
plot(as.im(turin, W=turinW), main="", col=gray(c(0.8,0)), ribbon=FALSE, add=TRUE)

#see examples under the topic "turin"
</code></pre>

<hr>
<h2 id='varshannon'>Estimated variance of Shannon's entropy.</h2><span id='topic+varshannon'></span>

<h3>Description</h3>

<p>This function estimates the variance of Shannon's entropy of a variable <code class="reqn">X</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varshannon(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="varshannon_+3A_data">data</code></td>
<td>
<p>A data matrix or vector, can be numeric, factor, character, ...
Alternatively, a marked <code>ppp</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><a href="#topic+varshannon">varshannon</a> estimates the
variance of the maximum likelihood estimator of Shannon's entropy given by
<a href="#topic+shannon">shannon</a>. The variance is </p>
<p style="text-align: center;"><code class="reqn">V(H(X))=H(X)_2- H(X)^2</code>
</p>
<p>, where <code class="reqn">H(X)_2</code> is
a version of Shannon's entropy (see <a href="#topic+shannon">shannon</a>) where
the information function <code class="reqn">\log(1/p(x_i))</code> is squared:
</p>
<p style="text-align: center;"><code class="reqn">H(X)_2=\sum p(x_i) \log(1/p(x_i))^2</code>
</p>
<p>.
The function is able to work with lattice data with missing data, as long as they are specified as NAs:
missing data are ignored in the computations.
</p>


<h3>Value</h3>

<p>the estimated variance of Shannon's entropy.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#NON SPATIAL DATA
varshannon(sample(1:5, 50, replace=TRUE))

#POINT DATA
data.pp=runifpoint(100, win=square(10))
marks(data.pp)=sample(c("a","b","c"), 100, replace=TRUE)
varshannon(marks(data.pp))

#LATTICE DATA
data.lat=matrix(sample(c("a","b","c"), 100, replace=TRUE), nrow=10)
varshannon(data.lat)

</code></pre>

<hr>
<h2 id='varshannonZ'>Estimated variance of Shannon's entropy of <code class="reqn">Z</code>.</h2><span id='topic+varshannonZ'></span>

<h3>Description</h3>

<p>This function estimates the variance of Shannon's entropy of <code class="reqn">Z</code>, where <code class="reqn">Z</code> identifies pairs of categories of the original study variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varshannonZ(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="varshannonZ_+3A_data">data</code></td>
<td>
<p>A data matrix or vector, can be numeric, factor, character, ...
Alternatively, a marked <code>ppp</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><a href="#topic+varshannonZ">varshannonZ</a> estimates the
variance of the maximum likelihood estimator of Shannon's entropy of <code class="reqn">Z</code> given by
<a href="#topic+shannonZ">shannonZ</a>. The variance is </p>
<p style="text-align: center;"><code class="reqn">V(H(Z))=H(Z)_2- H(Z)^2</code>
</p>
<p>, where
</p>
<p style="text-align: center;"><code class="reqn">H(Z)_2=\sum p(z_r)\log(1/p(z_r))^2</code>
</p>
<p>.
The function is able to work with lattice data with missing data, as long as they are specified as NAs:
missing data are ignored in the computations.
</p>


<h3>Value</h3>

<p>the estimated variance of Shannon's entropy of <code class="reqn">Z</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#NON SPATIAL DATA
data=sample(1:5, 50, replace=TRUE)
varshannonZ(data)

#POINT DATA
data.pp=runifpoint(100, win=square(10))
marks(data.pp)=sample(c("a","b","c"), 100, replace=TRUE)
varshannonZ(marks(data.pp))

#LATTICE DATA
data.lat=matrix(sample(c("a","b","c"), 100, replace=TRUE), nrow=10)
varshannonZ(data.lat)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
