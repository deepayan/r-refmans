<!DOCTYPE html><html lang="en"><head><title>Help for package cds</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cds}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cds-package'><p>Constrained Dual Scaling for Successive Categories</p></a></li>
<li><a href='#addbounds'><p>Augment with Boundaries Between Rating Scale Categories and Rank</p></a></li>
<li><a href='#approxloads'><p>Low Rank Approximation LL' of a Square Symmetrix Matrix R</p></a></li>
<li><a href='#calc.wt.bubbles'><p>Calculate the Weights for Bubble Plots</p></a></li>
<li><a href='#cds'><p>Constrained Dual Scaling for Successive Categories with Groups</p></a></li>
<li><a href='#cds.sim'><p>Grouped Simulation with Response Styles</p></a></li>
<li><a href='#cl_class_ids.cds'><p>S3 Methods for Integration into <span class="pkg">clue</span> Framework</p></a></li>
<li><a href='#clean.scales'><p>Impute Optimal Scores for Rating Categories</p></a></li>
<li><a href='#create.ind'><p>Create Indicator Matrix</p></a></li>
<li><a href='#create.rs'><p>Create a response style</p></a></li>
<li><a href='#createcdsdata'><p>Create a cdsdata Object</p></a></li>
<li><a href='#datsim'><p>Simulate Data for a Single Response Style</p></a></li>
<li><a href='#G.start'><p>Constrained Dual Scaling for a Single Random G Start</p></a></li>
<li><a href='#gen.cop'><p>Generate a Copula</p></a></li>
<li><a href='#genPCA'><p>Generate PCA data and Calculates Correlation Matrices</p></a></li>
<li><a href='#group.ALS'><p>Alternating Least Squares with Groups for Constrained Dual Scaling</p></a></li>
<li><a href='#indmat'><p>Create an Indicator Matrix</p></a></li>
<li><a href='#ispline'><p>Quadratic monotone spline basis function for given knots.</p></a></li>
<li><a href='#Lfun'><p>Calculate Constrained Dual Scaling Loss</p></a></li>
<li><a href='#Lfun.G.upd'><p>Calculate Loss for G Update</p></a></li>
<li><a href='#orthprocr'><p>Orthogonal Procrustes Analysis</p></a></li>
<li><a href='#plot.cds'><p>Plot cds Objects</p></a></li>
<li><a href='#plot.cdslist'><p>Plot a <code>cdslist</code> Object</p></a></li>
<li><a href='#print.cds'><p>Print cds Object</p></a></li>
<li><a href='#print.cdsdata'><p>Print dsdata Objects</p></a></li>
<li><a href='#rcormat'><p>Randomly Generate Low-Rank Correlation Matrix</p></a></li>
<li><a href='#rcovmat'><p>Construct a Structured Covariance Matrix for Simulations</p></a></li>
<li><a href='#sensory'><p>sensory Data</p></a></li>
<li><a href='#sensory.aux'><p>Auxiliary Information for <code>sensory</code> Data</p></a></li>
<li><a href='#simpca'><p>Simulate Data with a Specific Principal Components Structure and Response</p>
Style Contamination</a></li>
<li><a href='#trQnorm'><p>Truncated Normal Quantiles</p></a></li>
<li><a href='#trRnorm'><p>Truncated Normal Sampling</p></a></li>
<li><a href='#updateG'><p>Update the Grouping Matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Constrained Dual Scaling for Detecting Response Styles</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2016-01-05</td>
</tr>
<tr>
<td>Author:</td>
<td>Pieter Schoonees [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Pieter Schoonees &lt;schoonees@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>This is an implementation of constrained dual scaling for
    detecting response styles in categorical data, including utility functions. The
    procedure involves adding additional columns to the data matrix representing the
    boundaries between the rating categories. The resulting matrix is then doubled
    and analyzed by dual scaling. One-dimensional solutions are sought which provide
    optimal scores for the rating categories. These optimal scores are constrained
    to follow monotone quadratic splines. Clusters are introduced within which the
    response styles can vary. The type of response style present in a cluster can
    be diagnosed from the optimal scores for said cluster, and this can be used to
    construct an imputed version of the data set which adjusts for response styles.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.2.3), parallel</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, limSolve, clue, colorspace, copula, graphics, methods,
stats</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>5.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2016-01-05 10:19:33 UTC; pieter</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2016-01-05 14:29:39</td>
</tr>
</table>
<hr>
<h2 id='cds-package'>Constrained Dual Scaling for Successive Categories</h2><span id='topic+cds-package'></span>

<h3>Description</h3>

<p>Fit constrained dual scaling for detecting response styles.
</p>


<h3>Author(s)</h3>

<p>Pieter C. Schoonees
</p>


<h3>References</h3>

<p>Departmental report available
</p>
<p>Schoonees, P.C., Velden, M. van de &amp; Groenen, P.J.F. (2013).
Constrained Dual Scaling for Detecting Response Styles in Categorical Data.
(EI report series EI 2013-10). Rotterdam: Econometric Institute.
</p>

<hr>
<h2 id='addbounds'>Augment with Boundaries Between Rating Scale Categories and Rank</h2><span id='topic+addbounds'></span>

<h3>Description</h3>

<p>Adds <code>q - 1</code> boundaries between the <code>q</code> ratings to the columns of
matrix <code>x</code>, and convert the rows to rankings, starting with 0 for the
lowest ranking. Ties are handled by averaging the total rank for all 
tied observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addbounds(x, q = max(x), ties = "average")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addbounds_+3A_x">x</code></td>
<td>
<p>matrix (or data frame) of <code>n</code> rows and <code>m</code> columns, or an
object that can be coerced to a matrix via <code><a href="base.html#topic+as.matrix">as.matrix</a></code>.</p>
</td></tr>
<tr><td><code id="addbounds_+3A_q">q</code></td>
<td>
<p>scalar; the number of rating scale categories. Defaults to the
maximum entry in <code>x</code>.</p>
</td></tr>
<tr><td><code id="addbounds_+3A_ties">ties</code></td>
<td>
<p>character; handling of ties in <code>rank</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Any <code>x</code> which is not a matrix or data frame will cause an error.
</p>


<h3>Value</h3>

<p>A matrix of size <code>n</code> by <code>m + q - 1</code>
</p>


<h3>Author(s)</h3>

<p>Pieter C. Schoonees
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
mat &lt;- matrix(sample(1:9, 12, replace = TRUE), nrow = 4, ncol = 3)
addbounds(mat, q = 9)
</code></pre>

<hr>
<h2 id='approxloads'>Low Rank Approximation LL' of a Square Symmetrix Matrix R</h2><span id='topic+approxloads'></span>

<h3>Description</h3>

<p>Uses the eigendecomposition of a square, symmetrix matrix R to obtain the
loadings matrix L such that R is approximated by LL', with L restricted to
have <code>r</code> columns. Hence LL' is a rank <code>r</code> approximation of R. The
eigendecomposition of R is used to obtain L from the first <code>r</code>
eigenvectors and eigenvalues. In case <code>procr.target</code> is not
<code>NULL</code>, L is further rotated through orthogonal Procrustes analysis to
match as closely as possible the matrix <code>procr.target</code> through
<code><a href="#topic+orthprocr">orthprocr</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>approxloads(R, r = 3, procr.target = NULL, refl.target = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="approxloads_+3A_r">R</code></td>
<td>
<p>Square, symmetric matrix R to be approximated</p>
</td></tr>
<tr><td><code id="approxloads_+3A_r">r</code></td>
<td>
<p>The required rank of the approximation</p>
</td></tr>
<tr><td><code id="approxloads_+3A_procr.target">procr.target</code></td>
<td>
<p>Optional; the target matrix for L in the orthogonal
Procrustes analysis</p>
</td></tr>
<tr><td><code id="approxloads_+3A_refl.target">refl.target</code></td>
<td>
<p>Optional; the matrix to check against for possible
reflections of the loading vectors.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>R &lt;- rcormat(10, r = 3)
all.equal(R$L, approxloads(R$R, r = 3, procr.target = R$L))
</code></pre>

<hr>
<h2 id='calc.wt.bubbles'>Calculate the Weights for Bubble Plots</h2><span id='topic+calc.wt.bubbles'></span>

<h3>Description</h3>

<p>Calculate weights for the bubbles in the plot method of <code>cds</code> objects. The relative 
frequencies within a dset of groups are used to calculate the size of the bubble so that the area
of the bubble is proportional to the relative frequency of the rating category within that group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc.wt.bubbles(dat, grp, q, fact = 0.12)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc.wt.bubbles_+3A_dat">dat</code></td>
<td>
<p>A data set from which to derive the relative frequencies</p>
</td></tr>
<tr><td><code id="calc.wt.bubbles_+3A_grp">grp</code></td>
<td>
<p>A vector giving the group memberships.</p>
</td></tr>
<tr><td><code id="calc.wt.bubbles_+3A_q">q</code></td>
<td>
<p>An integer such that the rating scale is <code>1:q</code>.</p>
</td></tr>
<tr><td><code id="calc.wt.bubbles_+3A_fact">fact</code></td>
<td>
<p>A schrinkage factor.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Pieter Schoonees
</p>

<hr>
<h2 id='cds'>Constrained Dual Scaling for Successive Categories with Groups</h2><span id='topic+cds'></span>

<h3>Description</h3>

<p>Uses an alternating nonnegative least squares algorithm combined with a
k-means-type algorithm to optimize the constrained group dual scaling
criterion outlined in the reference. Parallel computations for random starts
of the grouping matrix is supported via package <span class="pkg">parallel</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cds(x, K = 4, q = NULL, eps.ALS = 0.001, eps.G = 1e-07,
  nr.starts.G = 20, nr.starts.a = 5, maxit.ALS = 20, maxit = 50,
  Gstarts = NULL, astarts = NULL, parallel = FALSE, random.G = FALSE,
  times.a.multistart = 1, info.level = 1, mc.preschedule = TRUE,
  seed = NULL, LB = FALSE, reorder.grps = TRUE, rescale.a = TRUE,
  tol = sqrt(.Machine$double.eps), update.G = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cds_+3A_x">x</code></td>
<td>
<p>an object of class <code>"dsdata"</code> (see <code>cds.sim()</code>),
or a matrix (or object coercible to a matrix) containing the data for n
individuals on m objects. The data does not yet contain any additional
columns for the rating scale.</p>
</td></tr>
<tr><td><code id="cds_+3A_k">K</code></td>
<td>
<p>The number of response style groups to look for. If a vector of 
length greater than one is given, the algorithm is run for each element
and a list of class <code>cdslist</code> is returned.</p>
</td></tr>
<tr><td><code id="cds_+3A_q">q</code></td>
<td>
<p>The maximum rating (the scale is assumed to be <code>1:q</code>).</p>
</td></tr>
<tr><td><code id="cds_+3A_eps.als">eps.ALS</code></td>
<td>
<p>Numerical convergence criterion for the alternating least
squares part of the algorithm (updates for row and column scores).</p>
</td></tr>
<tr><td><code id="cds_+3A_eps.g">eps.G</code></td>
<td>
<p>Numerical convergence criterion for the k-means part of the
algorithm.</p>
</td></tr>
<tr><td><code id="cds_+3A_nr.starts.g">nr.starts.G</code></td>
<td>
<p>Number of random starts for the grouping matrix.</p>
</td></tr>
<tr><td><code id="cds_+3A_nr.starts.a">nr.starts.a</code></td>
<td>
<p>Number of random starts for the row scores.</p>
</td></tr>
<tr><td><code id="cds_+3A_maxit.als">maxit.ALS</code></td>
<td>
<p>Maximum number of iterations for the ALS part of the
algorithm. A warning is given if this maximum is reached. Often it is not a
concern if this maximum is reached.</p>
</td></tr>
<tr><td><code id="cds_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations for the k-means part of the
algorithm.</p>
</td></tr>
<tr><td><code id="cds_+3A_gstarts">Gstarts</code></td>
<td>
<p>Facility to supply a list of explicit starting values for the
grouping matrix G. Each start consists of a two element list: <code>i</code> giving
and integer number the start, and <code>G</code> giving the starting configuration
as an indicator matrix.</p>
</td></tr>
<tr><td><code id="cds_+3A_astarts">astarts</code></td>
<td>
<p>Supply explicit starts for the a vectors, as a list.</p>
</td></tr>
<tr><td><code id="cds_+3A_parallel">parallel</code></td>
<td>
<p>logical. Should parallelization over starts for the grouping
matrix be used?</p>
</td></tr>
<tr><td><code id="cds_+3A_random.g">random.G</code></td>
<td>
<p>logical. Should the k-means part consider the individuals in
a random order?</p>
</td></tr>
<tr><td><code id="cds_+3A_times.a.multistart">times.a.multistart</code></td>
<td>
<p>The number of times that random starts for the row
scores are used. If == 1, then random starts are only used once for each
start of the grouping matrix.</p>
</td></tr>
<tr><td><code id="cds_+3A_info.level">info.level</code></td>
<td>
<p>Verbosity of the output. Options are 1, 2, 3 and 4.</p>
</td></tr>
<tr><td><code id="cds_+3A_mc.preschedule">mc.preschedule</code></td>
<td>
<p>Argument to mclapply under Unix.</p>
</td></tr>
<tr><td><code id="cds_+3A_seed">seed</code></td>
<td>
<p>Random seed for random number generators. Only partially
implemented.</p>
</td></tr>
<tr><td><code id="cds_+3A_lb">LB</code></td>
<td>
<p>logical. Load-balancing used in parallelization or not? Windows only.</p>
</td></tr>
<tr><td><code id="cds_+3A_reorder.grps">reorder.grps</code></td>
<td>
<p>logical. Use the Hungarian algorithm to reorder group
names so that the trace of the confusion matrix is maximized.</p>
</td></tr>
<tr><td><code id="cds_+3A_rescale.a">rescale.a</code></td>
<td>
<p>logical. Rescale row score to length sqrt(2n) if TRUE
(after the algorithm has converged).</p>
</td></tr>
<tr><td><code id="cds_+3A_tol">tol</code></td>
<td>
<p>tolerance <code>tol</code> passed to <code>lsei</code> of the
<span class="pkg">limSolve</span> package. Defaults to <code>sqrt(.Machine$double.eps)</code></p>
</td></tr>
<tr><td><code id="cds_+3A_update.g">update.G</code></td>
<td>
<p>Logical indicating whether or not to update the G matrix
from its starting configuration. Useful when clustering is known apriori or
not desired.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the reference for more details.
</p>


<h3>Value</h3>

<p>Object of class <code>ds</code> with elements: </p>
<table role = "presentation">
<tr><td><code>G</code></td>
<td>
<p>Grouping indicator
matrix.</p>
</td></tr> <tr><td><code>K</code></td>
<td>
<p>Number of groups K.</p>
</td></tr> <tr><td><code>opt.crit</code></td>
<td>
<p>Optimum value of the
criterion.</p>
</td></tr> <tr><td><code>a</code></td>
<td>
<p>The 2n-vector of row scores.</p>
</td></tr> <tr><td><code>bstar</code></td>
<td>
<p>The m-vector
of object scores.</p>
</td></tr> <tr><td><code>bkmat</code></td>
<td>
<p>The matrix of group-specific boundary scores
for the ratings.</p>
</td></tr> <tr><td><code>alphamat</code></td>
<td>
<p>The estimated spline coefficients for each
group.</p>
</td></tr> <tr><td><code>iter</code></td>
<td>
<p>The number of iterations used for the optimal random
start wrt the grouping matrix.</p>
</td></tr> <tr><td><code>time.G.start</code></td>
<td>
<p>The number of seconds it
took for the algorithm to converge for this optimal random start.</p>
</td></tr>
<tr><td><code>grp</code></td>
<td>
<p>The grouping of the individuals as obtained by the algorithm.</p>
</td></tr>
<tr><td><code>kloss</code></td>
<td>
<p>Loss value from G update (not equivalent to that of ALS
updates).</p>
</td></tr> <tr><td><code>hitrate</code>, <code>confusion</code></td>
<td>
<p>Confusion and hitrates of original data
object contained a grouping vector.</p>
</td></tr> <tr><td><code>loss.G</code></td>
<td>
<p>Optimality criterion
values for the random starts of G.</p>
</td></tr> <tr><td><code>q</code></td>
<td>
<p>The number of ratings in the
Likert scale <code>1:q</code></p>
</td></tr> <tr><td><code>time.total</code></td>
<td>
<p>Total time taken for the
algorithm over all random starts</p>
</td></tr> <tr><td><code>call</code></td>
<td>
<p>The function call.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>The input data object.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Pieter C. Schoonees
</p>


<h3>References</h3>

<p>Schoonees, P.C., Velden, M. van de &amp; Groenen, P.J.F. (2013).
Constrained Dual Scaling for Detecting Response Styles in Categorical Data.
(EI report series EI 2013-10). Rotterdam: Econometric Institute.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1234)
dat &lt;- cds.sim()
out &lt;- cds(dat)

</code></pre>

<hr>
<h2 id='cds.sim'>Grouped Simulation with Response Styles</h2><span id='topic+cds.sim'></span>

<h3>Description</h3>

<p>Simulate response data for a group of response styles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cds.sim(nr.indv = c(100, 100, 100), m = 25, scales = 1:7,
  err.coeff = 0.1, alphamat = rbind(c(4, 4, 1), c(1, 4, 4), c(1, 2, 1)),
  true.mu = NULL, random = TRUE, same.mu = TRUE, use.copula = FALSE,
  reverse.thresh = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cds.sim_+3A_nr.indv">nr.indv</code></td>
<td>
<p>A vector giving the number of respondents in each group.</p>
</td></tr>
<tr><td><code id="cds.sim_+3A_m">m</code></td>
<td>
<p>The number of objects.</p>
</td></tr>
<tr><td><code id="cds.sim_+3A_scales">scales</code></td>
<td>
<p>The rating scale used, 1:q.</p>
</td></tr>
<tr><td><code id="cds.sim_+3A_err.coeff">err.coeff</code></td>
<td>
<p>The standard error used in the underlying normal noise.</p>
</td></tr>
<tr><td><code id="cds.sim_+3A_alphamat">alphamat</code></td>
<td>
<p>The matrix of spline parameters defining the response styles, with each
row containing a response style. No intercepts should be included.</p>
</td></tr>
<tr><td><code id="cds.sim_+3A_true.mu">true.mu</code></td>
<td>
<p>Optional; a matrix or vector giving the true underlying preferences for the objects.</p>
</td></tr>
<tr><td><code id="cds.sim_+3A_random">random</code></td>
<td>
<p>Logical indicating whether to apply the response styles in random order</p>
</td></tr>
<tr><td><code id="cds.sim_+3A_same.mu">same.mu</code></td>
<td>
<p>Logical indicating whether a universal value for mu should be assumed.</p>
</td></tr>
<tr><td><code id="cds.sim_+3A_use.copula">use.copula</code></td>
<td>
<p>Logical indicating whether to use a correlated dependence structure 
through a copula.</p>
</td></tr>
<tr><td><code id="cds.sim_+3A_reverse.thresh">reverse.thresh</code></td>
<td>
<p>A numeric value giving the proportion of observations for which the 
dependece structure should be reversed. Only applicable when <code>copula</code> is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>cdsdata</code>, inheriting from class <code>icdsdata</code>, which is a 
list with the following slots:
</p>

<dl>
<dt>prers</dt><dd><p>The pre-response style simulated data</p>
</dd>
<dt>postrs</dt><dd><p>The data after adding the response styles</p>
</dd>
<dt>postbl</dt><dd><p>The same as <code>postrs</code> in this case</p>
</dd>
<dt>Fr.cent.rs</dt><dd><p>The centred Fr matrix for <code>postrs</code></p>
</dd>
<dt>Fr.rs</dt><dd><p>The Fr matrix for <code>postrs</code></p>
</dd>
<dt>Fr.cent.bl</dt><dd><p>The same as <code>Fr.cent.rs</code>, for compatibility with <code>icds</code></p>
</dd>
<dt>Fr.bl</dt><dd><p>The same as <code>Fr.rs</code>, for compatibility with <code>icds</code></p>
</dd>
<dt>mu</dt><dd><p>Matrix of the true underlying preference structure for the obects</p>
</dd>
<dt>block</dt><dd><p>Numeric vector identifying the different blocks for incompleteness, in this case a vector
of ones</p>
</dd>
<dt>grp.rs</dt><dd><p>The response style grouping vector</p>
</dd>
<dt>alphamat</dt><dd><p>Matrix of spline parameters for the response styles</p>
</dd>
<dt>scales</dt><dd><p>The rating scale 1:q used</p>
</dd>
<dt>m</dt><dd><p>Number of objects</p>
</dd>
<dt>munique</dt><dd><p>The number of objects seen within each block - equal to zero in this case</p>
</dd>
<dt>m0</dt><dd><p>The number of objects seen by all subjects - equal to <code>m</code> in this case</p>
</dd>
<dt>true.tau</dt><dd><p>Actual tau used in the simulation with copulae</p>
</dd>
<dt>call</dt><dd><p>The function call</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+createcdsdata">createcdsdata</a></code>
</p>

<hr>
<h2 id='cl_class_ids.cds'>S3 Methods for Integration into <span class="pkg">clue</span> Framework</h2><span id='topic+cl_class_ids.cds'></span><span id='topic+cl_class_ids.cdsdata'></span><span id='topic+is.cl_hard_partition.cds'></span><span id='topic+is.cl_hard_partition.cdsdata'></span><span id='topic+is.cl_partition.cds'></span><span id='topic+is.cl_partition.cdsdata'></span>

<h3>Description</h3>

<p>These methods integrate the class <code>cds</code> into the framwork set out in
package <span class="pkg">clue</span>. Use can therefore by made of <code>cl_agreement</code> to
calculate concordance measures between different solutions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cds'
cl_class_ids(x)

## S3 method for class 'cds'
is.cl_partition(x)

## S3 method for class 'cds'
is.cl_hard_partition(x)

## S3 method for class 'cdsdata'
cl_class_ids(x)

## S3 method for class 'cdsdata'
is.cl_partition(x)

## S3 method for class 'cdsdata'
is.cl_hard_partition(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cl_class_ids.cds_+3A_x">x</code></td>
<td>
<p>An object of class <code>cds</code></p>
</td></tr>
</table>

<hr>
<h2 id='clean.scales'>Impute Optimal Scores for Rating Categories</h2><span id='topic+clean.scales'></span><span id='topic+clean.scales.cds'></span><span id='topic+clean.scales.cdslist'></span>

<h3>Description</h3>

<p>Replace original ratings with optimal scores based on <code><a href="#topic+cds">cds</a></code> output..
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean.scales(object, data, K, col.subset = NULL, ...)

## S3 method for class 'cds'
clean.scales(object, data, K, col.subset = NULL, ...)

## S3 method for class 'cdslist'
clean.scales(object, data, K, col.subset = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clean.scales_+3A_object">object</code></td>
<td>
<p>An object of class <code>cds</code></p>
</td></tr>
<tr><td><code id="clean.scales_+3A_data">data</code></td>
<td>
<p>An object of class <code>cdsdata</code> to be cleaned, or the original data.</p>
</td></tr>
<tr><td><code id="clean.scales_+3A_k">K</code></td>
<td>
<p>The number of classes in the solution that must be kept.</p>
</td></tr>
<tr><td><code id="clean.scales_+3A_col.subset">col.subset</code></td>
<td>
<p>An optional subset</p>
</td></tr>
<tr><td><code id="clean.scales_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>

<hr>
<h2 id='create.ind'>Create Indicator Matrix</h2><span id='topic+create.ind'></span>

<h3>Description</h3>

<p>Create an indicator matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create.ind(grp)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create.ind_+3A_grp">grp</code></td>
<td>
<p>A grouping vector.</p>
</td></tr>
</table>

<hr>
<h2 id='create.rs'>Create a response style</h2><span id='topic+create.rs'></span>

<h3>Description</h3>

<p>Creates a response style by cutting up a quadratic monotone spline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create.rs(alpha = matrix(c(1, 2, 1), nrow = 1), nr.scale = 7, tvec = c(0,
  0.5, 1), xvec = 0:nr.scale/nr.scale, scale = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create.rs_+3A_alpha">alpha</code></td>
<td>
<p>vector of spline coefficients</p>
</td></tr>
<tr><td><code id="create.rs_+3A_nr.scale">nr.scale</code></td>
<td>
<p>number of rating categories; numeric</p>
</td></tr>
<tr><td><code id="create.rs_+3A_tvec">tvec</code></td>
<td>
<p>knots for spline functions</p>
</td></tr>
<tr><td><code id="create.rs_+3A_xvec">xvec</code></td>
<td>
<p>evaluation points for basis functions</p>
</td></tr>
<tr><td><code id="create.rs_+3A_scale">scale</code></td>
<td>
<p>logical; scale or not</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Pieter C. Schoonees
</p>

<hr>
<h2 id='createcdsdata'>Create a cdsdata Object</h2><span id='topic+createcdsdata'></span>

<h3>Description</h3>

<p>Create a cdsdata object from a data frame or matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createcdsdata(x, q = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createcdsdata_+3A_x">x</code></td>
<td>
<p>A data frame or matrix containing the data.</p>
</td></tr>
<tr><td><code id="createcdsdata_+3A_q">q</code></td>
<td>
<p>Optional; the maximum rating category, so that the rating scale used for all 
items are <code>1:q</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='datsim'>Simulate Data for a Single Response Style</h2><span id='topic+datsim'></span>

<h3>Description</h3>

<p>Simulate data containing a single repsponse style.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>datsim(nr.indv = 100, m = 5, scales = 1:7, err.coeff = 0.1,
  resp.style = c(-Inf, 1/7, 2/7, 3/7, 4/7, 5/7, 6/7, Inf), true.mu = NULL,
  a = 0, b = 1, plot.graph = FALSE, use.copula = FALSE,
  reverse.thresh = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="datsim_+3A_nr.indv">nr.indv</code></td>
<td>
<p>Integer giving the number of individuals required in the sample.</p>
</td></tr>
<tr><td><code id="datsim_+3A_m">m</code></td>
<td>
<p>The number of items.</p>
</td></tr>
<tr><td><code id="datsim_+3A_scales">scales</code></td>
<td>
<p>The rating scale used for all items.</p>
</td></tr>
<tr><td><code id="datsim_+3A_err.coeff">err.coeff</code></td>
<td>
<p>The standard error used in simulating the truncated normal distribution.</p>
</td></tr>
<tr><td><code id="datsim_+3A_resp.style">resp.style</code></td>
<td>
<p>A set of cut points across the interval [0, 1] defining the response style
transformation.</p>
</td></tr>
<tr><td><code id="datsim_+3A_true.mu">true.mu</code></td>
<td>
<p>Optional vector of length <code>m</code> giving the true preferences for the items.</p>
</td></tr>
<tr><td><code id="datsim_+3A_a">a</code></td>
<td>
<p>Lower boundary of the truncation interval for the simulated true preferences.</p>
</td></tr>
<tr><td><code id="datsim_+3A_b">b</code></td>
<td>
<p>Upper boundary for the truncation interval for the simulated true preferences.</p>
</td></tr>
<tr><td><code id="datsim_+3A_plot.graph">plot.graph</code></td>
<td>
<p>Logical indicating whether to visualize the response style in a plot.</p>
</td></tr>
<tr><td><code id="datsim_+3A_use.copula">use.copula</code></td>
<td>
<p>Logical indicating whether to simulate dependent items using a copula.</p>
</td></tr>
<tr><td><code id="datsim_+3A_reverse.thresh">reverse.thresh</code></td>
<td>
<p>A proportion giving the proportion of item preferences which should be
reversed to induce a negative association.</p>
</td></tr>
<tr><td><code id="datsim_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Pieter C. Schoonees
</p>


<h3>References</h3>

<p>Schoonees, P.C., Velden, M. van de &amp; Groenen, P.J.F. (2013).
Constrained Dual Scaling for Detecting Response Styles in Categorical Data.
(EI report series EI 2013-10). Rotterdam: Econometric Institute.
</p>

<hr>
<h2 id='G.start'>Constrained Dual Scaling for a Single Random G Start</h2><span id='topic+G.start'></span>

<h3>Description</h3>

<p>Run algorithm for a single G matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>G.start(X, nr.starts.a, astarts, maxit, n, m, q, Fr.cent, maxit.ALS, Mmat,
  eps.G, info.level, times.a.multistart, eps.ALS, const, K, random.G, tol,
  update.G)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="G.start_+3A_x">X</code></td>
<td>
<p>List of two elements, namely <code>i</code> giving the number of the start
and <code>G</code> given the starting configuration</p>
</td></tr>
<tr><td><code id="G.start_+3A_nr.starts.a">nr.starts.a</code></td>
<td>
<p>The number or random starts for <code>a</code> to use in the ALS.</p>
</td></tr>
<tr><td><code id="G.start_+3A_astarts">astarts</code></td>
<td>
<p>Explicit starts for a, if applicable.</p>
</td></tr>
<tr><td><code id="G.start_+3A_maxit">maxit</code></td>
<td>
<p>The maximum number of iterations with respect to G.</p>
</td></tr>
<tr><td><code id="G.start_+3A_n">n</code></td>
<td>
<p>The number of respondents.</p>
</td></tr>
<tr><td><code id="G.start_+3A_m">m</code></td>
<td>
<p>The number of items.</p>
</td></tr>
<tr><td><code id="G.start_+3A_q">q</code></td>
<td>
<p>The maximum rating category such that the rating scale is <code>1:q</code>.</p>
</td></tr>
<tr><td><code id="G.start_+3A_fr.cent">Fr.cent</code></td>
<td>
<p>The centred Fr matrix.</p>
</td></tr>
<tr><td><code id="G.start_+3A_maxit.als">maxit.ALS</code></td>
<td>
<p>The maximum number of ALS iterations.</p>
</td></tr>
<tr><td><code id="G.start_+3A_mmat">Mmat</code></td>
<td>
<p>The basis matrix for the quadratic monotone splines.</p>
</td></tr>
<tr><td><code id="G.start_+3A_eps.g">eps.G</code></td>
<td>
<p>The absolute error tolerance for the G updates.</p>
</td></tr>
<tr><td><code id="G.start_+3A_info.level">info.level</code></td>
<td>
<p>Integer controlling the amount of information printed.</p>
</td></tr>
<tr><td><code id="G.start_+3A_times.a.multistart">times.a.multistart</code></td>
<td>
<p>The number of times random starts for <code>a</code> is used.</p>
</td></tr>
<tr><td><code id="G.start_+3A_eps.als">eps.ALS</code></td>
<td>
<p>The absolute error tolerance for the ALS.</p>
</td></tr>
<tr><td><code id="G.start_+3A_const">const</code></td>
<td>
<p>The constant part of the loss function.</p>
</td></tr>
<tr><td><code id="G.start_+3A_k">K</code></td>
<td>
<p>The number of groups.</p>
</td></tr>
<tr><td><code id="G.start_+3A_random.g">random.G</code></td>
<td>
<p>The <code>random</code> argument passed to <code><a href="#topic+updateG">updateG</a></code>.</p>
</td></tr>
<tr><td><code id="G.start_+3A_tol">tol</code></td>
<td>
<p>tolerance <code>tol</code> passed to <code>lsei</code> of the
<span class="pkg">limSolve</span> package)</p>
</td></tr>
<tr><td><code id="G.start_+3A_update.g">update.G</code></td>
<td>
<p>Logical indicating whether or not to update the starting configuration
<code>G</code> in <code>X</code></p>
</td></tr>
</table>

<hr>
<h2 id='gen.cop'>Generate a Copula</h2><span id='topic+gen.cop'></span>

<h3>Description</h3>

<p>Generate correlated data multivariate categorical data via a copula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.cop(n, tauvek = c(0.2, 0.35), nr.cols = c(10, 10),
  true.mu = runif(sum(nr.cols)), err.coeff = 0.1, random = FALSE,
  reverse = TRUE, reverse.thresh = 0.75)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gen.cop_+3A_n">n</code></td>
<td>
<p>Integer; the number of samples to draw.</p>
</td></tr>
<tr><td><code id="gen.cop_+3A_tauvek">tauvek</code></td>
<td>
<p>A vector of association parameters for each of the Clayton copulae 
(see <code>copClayton</code>), of the same length as <code>nr.cols</code>.</p>
</td></tr>
<tr><td><code id="gen.cop_+3A_nr.cols">nr.cols</code></td>
<td>
<p>A vector giving the number of columns to draw from each of the copulae.</p>
</td></tr>
<tr><td><code id="gen.cop_+3A_true.mu">true.mu</code></td>
<td>
<p>A vector giving the mean for each of the columns in the data.</p>
</td></tr>
<tr><td><code id="gen.cop_+3A_err.coeff">err.coeff</code></td>
<td>
<p>The standard errors for underlying normal distribution.</p>
</td></tr>
<tr><td><code id="gen.cop_+3A_random">random</code></td>
<td>
<p>Logical indicating whether or not the samples should be presented in 
random order.</p>
</td></tr>
<tr><td><code id="gen.cop_+3A_reverse">reverse</code></td>
<td>
<p>Logical indicating whether some of the simulated variables should be reversed to 
have negative association or not.</p>
</td></tr>
<tr><td><code id="gen.cop_+3A_reverse.thresh">reverse.thresh</code></td>
<td>
<p>The proportion of columns to reverse.</p>
</td></tr>
</table>

<hr>
<h2 id='genPCA'>Generate PCA data and Calculates Correlation Matrices</h2><span id='topic+genPCA'></span>

<h3>Description</h3>

<p>Generate a response style data set from a specific correlation matrix, clean
the data with constrained dual scaling and report the original, cleaned and
contaminated correlation matrices in a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genPCA(nr.indv = rep(100, 5), m = 10, q = 7, r = 3, err.coeff = 0.1,
  alphamat = rbind(c(0.5, 2, 4), c(10, 2, 10), c(1, 2, 1), c(4, 2, 0.5),
  c(0.1, 2, 0.1))[1:length(nr.indv), ], randomize = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genPCA_+3A_nr.indv">nr.indv</code></td>
<td>
<p>Vector; number of individuals in each response style group.
It is passed to <code><a href="#topic+simpca">simpca</a></code>.</p>
</td></tr>
<tr><td><code id="genPCA_+3A_m">m</code></td>
<td>
<p>scalar; Number of items.</p>
</td></tr>
<tr><td><code id="genPCA_+3A_q">q</code></td>
<td>
<p>scalar; Number of rating categories, such that the rating scale is
<code>1:q</code>.</p>
</td></tr>
<tr><td><code id="genPCA_+3A_r">r</code></td>
<td>
<p>scalar; Rank of simulated correlation matrices.</p>
</td></tr>
<tr><td><code id="genPCA_+3A_err.coeff">err.coeff</code></td>
<td>
<p>scalar; Standard deviation used in simulations that is
passed on to <code><a href="#topic+simpca">simpca</a></code>.</p>
</td></tr>
<tr><td><code id="genPCA_+3A_alphamat">alphamat</code></td>
<td>
<p>matrix; Contains the spline parameters for the different
response styles that is passed to <code><a href="#topic+simpca">simpca</a></code>.</p>
</td></tr>
<tr><td><code id="genPCA_+3A_randomize">randomize</code></td>
<td>
<p>logical; See <code><a href="#topic+simpca">simpca</a></code>.</p>
</td></tr>
<tr><td><code id="genPCA_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+cds">cds</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components: </p>
<table role = "presentation">
<tr><td><code>Rsim</code></td>
<td>
<p>Correlation matrix from which
the sample was generated</p>
</td></tr> <tr><td><code>Rclean</code></td>
<td>
<p>Correlation matrix for the cleaned
data</p>
</td></tr> <tr><td><code>Rcont</code></td>
<td>
<p>Correlation matrix for the contaminated data</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Pieter C. Schoonees
</p>

<hr>
<h2 id='group.ALS'>Alternating Least Squares with Groups for Constrained Dual Scaling</h2><span id='topic+group.ALS'></span>

<h3>Description</h3>

<p>Alternating least-sqaures for estimating row and column scores in constrained
dual scaling, where different groups are allowed for.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group.ALS(a, m, q, G, Fr.cent, eps = 0.1, maxit = 50, Mmat,
  info.level = 2, const, K, n, tol)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="group.ALS_+3A_a">a</code></td>
<td>
<p>A <code>2n</code>-vector of row scores.</p>
</td></tr>
<tr><td><code id="group.ALS_+3A_m">m</code></td>
<td>
<p>Integer; the number of items.</p>
</td></tr>
<tr><td><code id="group.ALS_+3A_q">q</code></td>
<td>
<p>Integer; the rating scale from <code>1:q</code>.</p>
</td></tr>
<tr><td><code id="group.ALS_+3A_g">G</code></td>
<td>
<p>An indicator matrix of size <code>n</code> by <code>K</code>.</p>
</td></tr>
<tr><td><code id="group.ALS_+3A_fr.cent">Fr.cent</code></td>
<td>
<p>The centred F_r matrix.</p>
</td></tr>
<tr><td><code id="group.ALS_+3A_eps">eps</code></td>
<td>
<p>The numerical tolerance level for the loss.</p>
</td></tr>
<tr><td><code id="group.ALS_+3A_maxit">maxit</code></td>
<td>
<p>Integer; the maximum number of iterations allowed.</p>
</td></tr>
<tr><td><code id="group.ALS_+3A_mmat">Mmat</code></td>
<td>
<p>Matrix of spline basis functions.</p>
</td></tr>
<tr><td><code id="group.ALS_+3A_info.level">info.level</code></td>
<td>
<p>Integer controlling the amount of information printed.</p>
</td></tr>
<tr><td><code id="group.ALS_+3A_const">const</code></td>
<td>
<p>The constant part of the loss function.</p>
</td></tr>
<tr><td><code id="group.ALS_+3A_k">K</code></td>
<td>
<p>The number of latent classes.</p>
</td></tr>
<tr><td><code id="group.ALS_+3A_n">n</code></td>
<td>
<p>The number of samples.</p>
</td></tr>
<tr><td><code id="group.ALS_+3A_tol">tol</code></td>
<td>
<p>tolerance <code>tol</code> passed to <code>lsei</code> of the
<span class="pkg">limSolve</span> package</p>
</td></tr>
</table>

<hr>
<h2 id='indmat'>Create an Indicator Matrix</h2><span id='topic+indmat'></span>

<h3>Description</h3>

<p>Creates an indicator matrix from a grouping vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indmat(grp.vec, K = length(unique(grp.vec)))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="indmat_+3A_grp.vec">grp.vec</code></td>
<td>
<p>Numeric vector giving the group membership.</p>
</td></tr>
<tr><td><code id="indmat_+3A_k">K</code></td>
<td>
<p>Scalar indicating the number of groups. Defaults to the number of
unique elements in <code>grp.vec</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='ispline'>Quadratic monotone spline basis function for given knots.</h2><span id='topic+ispline'></span>

<h3>Description</h3>

<p>Calculate basis functions for monotone quadratic splines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ispline(xvec, tvec = c(0, 0.5, 1), intercept = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ispline_+3A_xvec">xvec</code></td>
<td>
<p>Vector at which to evaluate the basis functions.</p>
</td></tr>
<tr><td><code id="ispline_+3A_tvec">tvec</code></td>
<td>
<p>Vector of spline knots: lower endpoint, interior knot, upper endpoint.</p>
</td></tr>
<tr><td><code id="ispline_+3A_intercept">intercept</code></td>
<td>
<p>Logical; should an intercept be included or not?</p>
</td></tr>
</table>

<hr>
<h2 id='Lfun'>Calculate Constrained Dual Scaling Loss</h2><span id='topic+Lfun'></span>

<h3>Description</h3>

<p>Calculate the loss function for constrained dual scaling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Lfun(a.cur, bkmat, G, Fr.cent, n, m, q, const, K)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Lfun_+3A_a.cur">a.cur</code></td>
<td>
<p>The current value for a.</p>
</td></tr>
<tr><td><code id="Lfun_+3A_bkmat">bkmat</code></td>
<td>
<p>Current value of bkmat.</p>
</td></tr>
<tr><td><code id="Lfun_+3A_g">G</code></td>
<td>
<p>Current value G.</p>
</td></tr>
<tr><td><code id="Lfun_+3A_fr.cent">Fr.cent</code></td>
<td>
<p>Current value of the centred Fr.</p>
</td></tr>
<tr><td><code id="Lfun_+3A_n">n</code></td>
<td>
<p>Number of respondents.</p>
</td></tr>
<tr><td><code id="Lfun_+3A_m">m</code></td>
<td>
<p>Number of items.</p>
</td></tr>
<tr><td><code id="Lfun_+3A_q">q</code></td>
<td>
<p>Number for rating scale categories so that the rating scale is <code>1:q</code>.</p>
</td></tr>
<tr><td><code id="Lfun_+3A_const">const</code></td>
<td>
<p>Constant part of the loss function</p>
</td></tr>
<tr><td><code id="Lfun_+3A_k">K</code></td>
<td>
<p>Number of response style groups.</p>
</td></tr>
</table>

<hr>
<h2 id='Lfun.G.upd'>Calculate Loss for G Update</h2><span id='topic+Lfun.G.upd'></span>

<h3>Description</h3>

<p>Loss function used for updating G. This is not equivalent to the original loss function, as 
only a part of the total loss depends on G.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Lfun.G.upd(G, a.cur, bwts2, Fr.bk, n, m, q, K)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Lfun.G.upd_+3A_g">G</code></td>
<td>
<p>The current value for G.</p>
</td></tr>
<tr><td><code id="Lfun.G.upd_+3A_a.cur">a.cur</code></td>
<td>
<p>The current value for a.</p>
</td></tr>
<tr><td><code id="Lfun.G.upd_+3A_bwts2">bwts2</code></td>
<td>
<p>The current value of the squared b weights.</p>
</td></tr>
<tr><td><code id="Lfun.G.upd_+3A_fr.bk">Fr.bk</code></td>
<td>
<p>Current product between Fr.cent and bk.</p>
</td></tr>
<tr><td><code id="Lfun.G.upd_+3A_n">n</code></td>
<td>
<p>Number of respondents.</p>
</td></tr>
<tr><td><code id="Lfun.G.upd_+3A_m">m</code></td>
<td>
<p>Number of items.</p>
</td></tr>
<tr><td><code id="Lfun.G.upd_+3A_q">q</code></td>
<td>
<p>Number for rating scale categories so that the rating scale is <code>1:q</code>.</p>
</td></tr>
<tr><td><code id="Lfun.G.upd_+3A_k">K</code></td>
<td>
<p>Number of response style groups.</p>
</td></tr>
</table>

<hr>
<h2 id='orthprocr'>Orthogonal Procrustes Analysis</h2><span id='topic+orthprocr'></span>

<h3>Description</h3>

<p>Simple function to rotate matrix X so that it matches the target matrix Z as
closely as possible, by minimizing ||Z - XQ|| where Z and X are of the same
size and Q is an orthogonal matrix. The algorithm is based on the singular
value decomposition (SVD) (see e.g. the reference).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orthprocr(Z, X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orthprocr_+3A_z">Z</code></td>
<td>
<p>The target matrix</p>
</td></tr>
<tr><td><code id="orthprocr_+3A_x">X</code></td>
<td>
<p>The matrix to be rotated, which must be of the same size as Z.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following 2 elements: </p>
<table role = "presentation">
<tr><td><code>Q</code></td>
<td>
<p>The rotation matrix</p>
</td></tr>
<tr><td><code>XQ</code></td>
<td>
<p>The matrix X after rotation</p>
</td></tr>
</table>


<h3>References</h3>

<p>Gower, J. C. and Hand, D.J. (1996). Biplots (Vol. 54). CRC Press.
</p>

<hr>
<h2 id='plot.cds'>Plot cds Objects</h2><span id='topic+plot.cds'></span>

<h3>Description</h3>

<p>Plot method for <code>cds</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cds'
plot(x, which = 1L:3L, type = "l", lty = 1, lwd = 2,
  show.legend = TRUE, col = colorspace::rainbow_hcl(nr), bty.legend = "n",
  intercept = ncol(x$alphamat) == 4, scale = FALSE, add = FALSE,
  exp.factor = 1.2, bubble.fact = 0.12, cont.factor = 0.01, pch = 15,
  ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.cds_+3A_x">x</code></td>
<td>
<p>An object of class <code>cds</code>.</p>
</td></tr>
<tr><td><code id="plot.cds_+3A_which">which</code></td>
<td>
<p>A numeric vector: a subset of <code>1:3</code> specifying the plots to produce.</p>
</td></tr>
<tr><td><code id="plot.cds_+3A_type">type</code></td>
<td>
<p>Passed to <code><a href="graphics.html#topic+matplot">matplot</a></code>.</p>
</td></tr>
<tr><td><code id="plot.cds_+3A_lty">lty</code></td>
<td>
<p>Passed to <code><a href="graphics.html#topic+matplot">matplot</a></code>.</p>
</td></tr>
<tr><td><code id="plot.cds_+3A_lwd">lwd</code></td>
<td>
<p>Passed to <code><a href="graphics.html#topic+matplot">matplot</a></code>.</p>
</td></tr>
<tr><td><code id="plot.cds_+3A_show.legend">show.legend</code></td>
<td>
<p>Logical; should a legend be added to the plot or not.</p>
</td></tr>
<tr><td><code id="plot.cds_+3A_col">col</code></td>
<td>
<p>Passed to <code><a href="graphics.html#topic+matplot">matplot</a></code>.</p>
</td></tr>
<tr><td><code id="plot.cds_+3A_bty.legend">bty.legend</code></td>
<td>
<p>Passed to <code><a href="graphics.html#topic+legend">legend</a></code>.</p>
</td></tr>
<tr><td><code id="plot.cds_+3A_intercept">intercept</code></td>
<td>
<p>Logical indicating whether to plot the intercept.</p>
</td></tr>
<tr><td><code id="plot.cds_+3A_scale">scale</code></td>
<td>
<p>Logical indicating whether an intercept should be included or not.</p>
</td></tr>
<tr><td><code id="plot.cds_+3A_add">add</code></td>
<td>
<p>Logical; add to plot or not?</p>
</td></tr>
<tr><td><code id="plot.cds_+3A_exp.factor">exp.factor</code></td>
<td>
<p>Factor for expanding the x- and y-limits.</p>
</td></tr>
<tr><td><code id="plot.cds_+3A_bubble.fact">bubble.fact</code></td>
<td>
<p>Passed to <code><a href="#topic+calc.wt.bubbles">calc.wt.bubbles</a></code> as argument <code>fact</code>.</p>
</td></tr>
<tr><td><code id="plot.cds_+3A_cont.factor">cont.factor</code></td>
<td>
<p>Continuity correction to apply in case one of the alpha's are
equal to zero.</p>
</td></tr>
<tr><td><code id="plot.cds_+3A_pch">pch</code></td>
<td>
<p>Plotting character to use.</p>
</td></tr>
<tr><td><code id="plot.cds_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="graphics.html#topic+points">points</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='plot.cdslist'>Plot a <code>cdslist</code> Object</h2><span id='topic+plot.cdslist'></span>

<h3>Description</h3>

<p>Create a scree plot and bubble plots for all elements in a <code>cdslist</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cdslist'
plot(x, which = 2L, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.cdslist_+3A_x">x</code></td>
<td>
<p>An object of class <code>cdslist</code>.</p>
</td></tr>
<tr><td><code id="plot.cdslist_+3A_which">which</code></td>
<td>
<p>The which argument passed to <code><a href="#topic+plot.cds">plot.cds</a></code>.</p>
</td></tr>
<tr><td><code id="plot.cdslist_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+plot.cds">plot.cds</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='print.cds'>Print cds Object</h2><span id='topic+print.cds'></span>

<h3>Description</h3>

<p>Print method for <code>cds</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cds'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.cds_+3A_x">x</code></td>
<td>
<p>A <code>cds</code> object.</p>
</td></tr>
<tr><td><code id="print.cds_+3A_...">...</code></td>
<td>
<p>Unimplemented.</p>
</td></tr>
</table>

<hr>
<h2 id='print.cdsdata'>Print dsdata Objects</h2><span id='topic+print.cdsdata'></span>

<h3>Description</h3>

<p>This is a simple print method  for object that inherits from the class <code>cdsdata</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cdsdata'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.cdsdata_+3A_x">x</code></td>
<td>
<p>A <code>cdsdata</code> object</p>
</td></tr>
<tr><td><code id="print.cdsdata_+3A_...">...</code></td>
<td>
<p>Unimplemented.</p>
</td></tr>
</table>

<hr>
<h2 id='rcormat'>Randomly Generate Low-Rank Correlation Matrix</h2><span id='topic+rcormat'></span>

<h3>Description</h3>

<p>Generate a correlation matrix as R = LL' where the rows of L are of length
1, L is of rank <code>r</code> and the matrix L is sparse (depending on
<code>sparse.prop</code>. The loadings in L are sampled from a standard normal
distribution, after which <code>sparse.prop</code> is used to set a randomly
chosen number of loadings in each row equal to zero. To ensure that a
correlation matrix results, the rows are normalized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcormat(m, r = 3L, sparse.prop = 0.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rcormat_+3A_m">m</code></td>
<td>
<p>integer; the number of variables.</p>
</td></tr>
<tr><td><code id="rcormat_+3A_r">r</code></td>
<td>
<p>integer; the required rank.</p>
</td></tr>
<tr><td><code id="rcormat_+3A_sparse.prop">sparse.prop</code></td>
<td>
<p>the proportion of zeros in the rows of the matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components: </p>
<table role = "presentation">
<tr><td><code>R</code></td>
<td>
<p>The sampled
correlation matrix</p>
</td></tr> <tr><td><code>L</code></td>
<td>
<p>The loading matrix</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>R &lt;- rcormat(m = 10)$R
eigen(R)
</code></pre>

<hr>
<h2 id='rcovmat'>Construct a Structured Covariance Matrix for Simulations</h2><span id='topic+rcovmat'></span>

<h3>Description</h3>

<p>Construct a low-rank covariance matrix with specified eigenvalues, where the
eigenvectors are simulated from uniform distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcovmat(eigs = k:1, m = 10, k = 2, perc = list(c(0.4, 0.2, 0.4), c(0.2,
  0.4, 0.4)), limits = list(l1 = c(0.5, 1), l2 = c(-1, -0.5), l3 = c(-0.1,
  0.1)), random = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rcovmat_+3A_eigs">eigs</code></td>
<td>
<p>Vector of $k$ eigenvalues.</p>
</td></tr>
<tr><td><code id="rcovmat_+3A_m">m</code></td>
<td>
<p>Integer; the number of rows and columns of the matrix.</p>
</td></tr>
<tr><td><code id="rcovmat_+3A_k">k</code></td>
<td>
<p>Integer; the rank of the matrix.</p>
</td></tr>
<tr><td><code id="rcovmat_+3A_perc">perc</code></td>
<td>
<p>List of $k$ vectors giving the sampling proportions for the
uniform sampling of the eigenvectors, for each dimension.</p>
</td></tr>
<tr><td><code id="rcovmat_+3A_limits">limits</code></td>
<td>
<p>List of length 2 vectors, one for each uniform sample, giving
the lower and upper bounds of the uniform distribution.</p>
</td></tr>
<tr><td><code id="rcovmat_+3A_random">random</code></td>
<td>
<p>Logical; randomize the order of the loading per dimension or
not.</p>
</td></tr>
</table>

<hr>
<h2 id='sensory'>sensory Data</h2><span id='topic+sensory'></span>

<h3>Description</h3>

<p>Data from 268 panellists rating each of 20 different products on 7 attributes. It is presented
in a <code>data.frame</code> with 268 observations on 140 variables. Each observation 
represents a different trained panellist. The columns correspond to products and items.
The 20 different products are coded by alphabetic letters from A to T, and the items are coded
from 1 to 7. So item C5 corresponds to product C being rated on item 5.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sensory)

</code></pre>

<hr>
<h2 id='sensory.aux'>Auxiliary Information for <code><a href="#topic+sensory">sensory</a></code> Data</h2><span id='topic+sensory.aux'></span>

<h3>Description</h3>

<p>Auxiliary Information for <code><a href="#topic+sensory">sensory</a></code> Data
</p>


<h3>Format</h3>

<p>A data frame with 268 observations on the following 3 variables.
</p>
 <dl>
<dt>Gender</dt><dd><p>a factor with levels <code>F</code> for females
and <code>M</code> for males</p>
</dd> <dt>Age</dt><dd><p>a factor for age with levels
<code>14 to 24</code>,<code>25 to 34</code>, <code>35 to 44</code>, and <code>45 to 55</code></p>
</dd>
<dt>Consumption</dt><dd><p>a factor for consumption with levels <code>Heavy
consumer</code>, <code>Light consumer</code>, and <code>Medium consumer</code></p>
</dd> </dl>


<h3>Source</h3>

<p>obtained ~~
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sensory.aux)

</code></pre>

<hr>
<h2 id='simpca'>Simulate Data with a Specific Principal Components Structure and Response
Style Contamination</h2><span id='topic+simpca'></span>

<h3>Description</h3>

<p>Simulate normally distributed data with specific covariance structure and
randomly sampled means. Adds response style contamination.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simpca(nr.indv = rep(200, 5), m = 10, q = 7, R = rcormat(m = m),
  err.coeff = 0.1, alphamat = rbind(c(0.5, 2, 4), c(10, 2, 10), c(1, 2, 1),
  c(4, 2, 0.5), c(0.1, 2, 0.1))[1:length(nr.indv), ], randomize = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simpca_+3A_nr.indv">nr.indv</code></td>
<td>
<p>Numeric vector of group sizes.</p>
</td></tr>
<tr><td><code id="simpca_+3A_m">m</code></td>
<td>
<p>Integer; then number of variables to simulate.</p>
</td></tr>
<tr><td><code id="simpca_+3A_q">q</code></td>
<td>
<p>Integer; the rating scale used <code>1:q</code>.</p>
</td></tr>
<tr><td><code id="simpca_+3A_r">R</code></td>
<td>
<p>List with entry named 'R' which is the simulated correlation matrix</p>
</td></tr>
<tr><td><code id="simpca_+3A_err.coeff">err.coeff</code></td>
<td>
<p>Standard error for each variable, added unto <code>R</code>.</p>
</td></tr>
<tr><td><code id="simpca_+3A_alphamat">alphamat</code></td>
<td>
<p>Matrix containing splines coefficients for te construction
of respone styles.</p>
</td></tr>
<tr><td><code id="simpca_+3A_randomize">randomize</code></td>
<td>
<p>logical; should the rows of the data be randomly permuted
or not?</p>
</td></tr>
</table>

<hr>
<h2 id='trQnorm'>Truncated Normal Quantiles</h2><span id='topic+trQnorm'></span>

<h3>Description</h3>

<p>Quantile function of the truncated normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trQnorm(p, mean = 1, sd = 1, a = 0, b = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trQnorm_+3A_p">p</code></td>
<td>
<p>Vector of probabilities.</p>
</td></tr>
<tr><td><code id="trQnorm_+3A_mean">mean</code></td>
<td>
<p>The mean of the distribution.</p>
</td></tr>
<tr><td><code id="trQnorm_+3A_sd">sd</code></td>
<td>
<p>The standard deviation.</p>
</td></tr>
<tr><td><code id="trQnorm_+3A_a">a</code></td>
<td>
<p>Lower truncation point.</p>
</td></tr>
<tr><td><code id="trQnorm_+3A_b">b</code></td>
<td>
<p>Upper truncation point.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Pieter C. Schoonees
</p>

<hr>
<h2 id='trRnorm'>Truncated Normal Sampling</h2><span id='topic+trRnorm'></span>

<h3>Description</h3>

<p>Random numbers from truncated univariate normal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trRnorm(n, mu = 0, sd = 1, a = -Inf, b = Inf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trRnorm_+3A_n">n</code></td>
<td>
<p>The number of points to sample.</p>
</td></tr>
<tr><td><code id="trRnorm_+3A_mu">mu</code></td>
<td>
<p>The mean of the distribution.</p>
</td></tr>
<tr><td><code id="trRnorm_+3A_sd">sd</code></td>
<td>
<p>The standard deviation.</p>
</td></tr>
<tr><td><code id="trRnorm_+3A_a">a</code></td>
<td>
<p>The lower truncation point.</p>
</td></tr>
<tr><td><code id="trRnorm_+3A_b">b</code></td>
<td>
<p>The upper truncation point.</p>
</td></tr>
</table>

<hr>
<h2 id='updateG'>Update the Grouping Matrix</h2><span id='topic+updateG'></span>

<h3>Description</h3>

<p>Updates the grouping matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updateG(G, a, bwts2, Fr.bk, const, n, m, q, random = FALSE, info.level = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="updateG_+3A_g">G</code></td>
<td>
<p>Grouping matrix.</p>
</td></tr>
<tr><td><code id="updateG_+3A_a">a</code></td>
<td>
<p>Current value of the row scores.</p>
</td></tr>
<tr><td><code id="updateG_+3A_bwts2">bwts2</code></td>
<td>
<p>Squared column weights.</p>
</td></tr>
<tr><td><code id="updateG_+3A_fr.bk">Fr.bk</code></td>
<td>
<p>Product of Fr and bkmat.</p>
</td></tr>
<tr><td><code id="updateG_+3A_const">const</code></td>
<td>
<p>Constant part of the loss function.</p>
</td></tr>
<tr><td><code id="updateG_+3A_n">n</code></td>
<td>
<p>The number of observations.</p>
</td></tr>
<tr><td><code id="updateG_+3A_m">m</code></td>
<td>
<p>The number of items.</p>
</td></tr>
<tr><td><code id="updateG_+3A_q">q</code></td>
<td>
<p>The number of rating categories.</p>
</td></tr>
<tr><td><code id="updateG_+3A_random">random</code></td>
<td>
<p>Logical indicating whether to randomize the observations.</p>
</td></tr>
<tr><td><code id="updateG_+3A_info.level">info.level</code></td>
<td>
<p>Integer controlling the amount of printed.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Pieter Schoonees
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
