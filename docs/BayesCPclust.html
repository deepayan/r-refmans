<!DOCTYPE html><html lang="en"><head><title>Help for package BayesCPclust</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BayesCPclust}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#data'><p>Error free data for all examples.</p></a></li>
<li><a href='#data_a'><p>Error free data for all examples.</p></a></li>
<li><a href='#full_cond'><p>Full conditional for lambda</p></a></li>
<li><a href='#gibbs_alg'><p>Gibbs sampler algorithm for simulated scenarios or real datasets</p></a></li>
<li><a href='#logsumexp'><p>Transfor a vector with over- or underflow</p></a></li>
<li><a href='#Mode'><p>Compute the mode of a numerical vector</p></a></li>
<li><a href='#pk'><p>Probability mass function for truncated poisson</p></a></li>
<li><a href='#possigma2n'><p>Full conditional function for sigma2</p></a></li>
<li><a href='#postalpha0'><p>Posterior for alpha0</p></a></li>
<li><a href='#postalphak'><p>Full conditional for alphak</p></a></li>
<li><a href='#postK'><p>Marginal probability of K</p></a></li>
<li><a href='#postK_mk'><p>Marginal probability of K per bin</p></a></li>
<li><a href='#postmk'><p>Marginal probability of m1,m2,m3,...,mk+1</p></a></li>
<li><a href='#qn0'><p>Mixing probability for creating new cluster</p></a></li>
<li><a href='#qn0_mk'><p>Mixing probability for creating new cluster per bin</p></a></li>
<li><a href='#qnj'><p>Mixing probability for getting assigned to an existing cluster</p></a></li>
<li><a href='#run_gibbs'><p>Runs the Gibbs sampler algorithm using using initial values for the parameters</p></a></li>
<li><a href='#update_lambda'><p>Update equation for lambda</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>A Bayesian Approach for Clustering Constant-Wise Change-Point
Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>A Gibbs sampler algorithm was developed to estimate change points in constant-wise data sequences while performing clustering simultaneously. The algorithm is described in da Cruz, A. C. and de Souza, C. P. E "A Bayesian Approach for Clustering Constant-wise Change-point Data" &lt;<a href="https://doi.org/10.48550%2FarXiv.2305.17631">doi:10.48550/arXiv.2305.17631</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>extraDistr, RcppAlgos, stats</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-24 13:11:21 UTC; carol</td>
</tr>
<tr>
<td>Author:</td>
<td>Ana Carolina da Cruz [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ana Carolina da Cruz &lt;adacruz@uwo.ca&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-29 16:50:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='data'>Error free data for all examples.</h2><span id='topic+data'></span>

<h3>Description</h3>

<p>A dataset generated for examplification of Gibbs sampler using the model proposed
in the paper &quot;BayesCPclust: A Bayesian Approach for Clustering Constant-Wise Change-Point Data&quot;.
The generation process is described in the paper with N = 5, M = 50, w = 10, d = 2, K = 2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data
</code></pre>


<h3>Format</h3>

<p>A matrix with 50 rows and 5 columns
</p>


<h3>References</h3>

<p>A.C. da Cruz, C.P.E. de Souza.
&quot;BayesCPclust: A Bayesian Approach for Clustering Constant-Wise Change-Point Data&quot;
arXiv, arXiv:2305.17631v3 .
</p>

<hr>
<h2 id='data_a'>Error free data for all examples.</h2><span id='topic+data_a'></span>

<h3>Description</h3>

<p>A dataset generated for examplification of Gibbs sampler using the model proposed
in the paper &quot;BayesCPclust: A Bayesian Approach for Clustering Constant-Wise Change-Point Data&quot;.
The generation process is described in the paper with N = 5, M = 50, w = 10, d = 2, K = 2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_a
</code></pre>


<h3>Format</h3>

<p>A list with three components: a matrix with 50 rows and 5 columns,
a vector with the cluster assignments, a vector with variance components
</p>


<h3>References</h3>

<p>A.C. da Cruz, C.P.E. de Souza.
&quot;BayesCPclust: A Bayesian Approach for Clustering Constant-Wise Change-Point Data&quot;
arXiv, arXiv:2305.17631v3 .
</p>

<hr>
<h2 id='full_cond'>Full conditional for lambda</h2><span id='topic+full_cond'></span>

<h3>Description</h3>

<p>Full conditional for lambda
</p>


<h3>Usage</h3>

<pre><code class='language-R'>full_cond(kstar, lambda, cluster, al, bl, K, N)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="full_cond_+3A_kstar">kstar</code></td>
<td>
<p>A scalar with the number maximum of change points in all clusters</p>
</td></tr>
<tr><td><code id="full_cond_+3A_lambda">lambda</code></td>
<td>
<p>A scalar defining the parameter for the Truncate Poisson distribution
that controls the number of change points (or its initial values)</p>
</td></tr>
<tr><td><code id="full_cond_+3A_cluster">cluster</code></td>
<td>
<p>A vector containing the cluster assignments for the data sequences (or its initial values)</p>
</td></tr>
<tr><td><code id="full_cond_+3A_al">al</code></td>
<td>
<p>The hyperparameter value for the shape parameter in the gamma prior for lambda</p>
</td></tr>
<tr><td><code id="full_cond_+3A_bl">bl</code></td>
<td>
<p>The hyperparameter value for the scale parameter in the gamma prior for lambda</p>
</td></tr>
<tr><td><code id="full_cond_+3A_k">K</code></td>
<td>
<p>A vector containing the number of change points for each cluster (or its initial values)</p>
</td></tr>
<tr><td><code id="full_cond_+3A_n">N</code></td>
<td>
<p>A scalar representing the number of data sequences</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'full_cond' returns a numerical value corresponding to a sample from the full conditional for lambda
</p>


<h3>Note</h3>

<p>This function is used within the Gibbs sampler, it is not expected to be used alone.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Using hypothetical values to exemplification purposes
clusters &lt;- c(1,1,2,1,2)
full_cond(kstar = 2, lambda = 3, cluster = clusters, al = 2, bl = 1000, K = c(2, 2), N = 5)
</code></pre>

<hr>
<h2 id='gibbs_alg'>Gibbs sampler algorithm for simulated scenarios or real datasets</h2><span id='topic+gibbs_alg'></span>

<h3>Description</h3>

<p>Gibbs sampler algorithm for simulated scenarios or real datasets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gibbs_alg(
  N,
  w,
  M,
  K,
  Tl,
  cluster,
  alpha,
  sigma2,
  bs = 1000,
  as = 2,
  al = 2,
  bl = 1000,
  a = 2,
  b = 1000,
  alpha0 = 1/100,
  kstar,
  lambda,
  Y,
  d,
  maxIter = 10000
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gibbs_alg_+3A_n">N</code></td>
<td>
<p>A scalar representing the number of observations</p>
</td></tr>
<tr><td><code id="gibbs_alg_+3A_w">w</code></td>
<td>
<p>A scalar representing the minimum number of points in each interval between two change points</p>
</td></tr>
<tr><td><code id="gibbs_alg_+3A_m">M</code></td>
<td>
<p>A scalar representing the number of points available for each observation</p>
</td></tr>
<tr><td><code id="gibbs_alg_+3A_k">K</code></td>
<td>
<p>A vector containing the number of change points for each cluster (or its initial values)</p>
</td></tr>
<tr><td><code id="gibbs_alg_+3A_tl">Tl</code></td>
<td>
<p>A list containing a vector for each cluster determining the change-point positions in each
cluster  (or its initial values)</p>
</td></tr>
<tr><td><code id="gibbs_alg_+3A_cluster">cluster</code></td>
<td>
<p>A vector containing the cluster assignments for the observations (or its initial values)</p>
</td></tr>
<tr><td><code id="gibbs_alg_+3A_alpha">alpha</code></td>
<td>
<p>A list containing a vector for each cluster determining the constant level values
for each interval between change points in each cluster (or its initial values)</p>
</td></tr>
<tr><td><code id="gibbs_alg_+3A_sigma2">sigma2</code></td>
<td>
<p>A vector with the variances of observations (or its initial values)</p>
</td></tr>
<tr><td><code id="gibbs_alg_+3A_bs">bs</code></td>
<td>
<p>The hyperparameter value for the scale parameter in the inverse-gamma prior for the variance
component</p>
</td></tr>
<tr><td><code id="gibbs_alg_+3A_as">as</code></td>
<td>
<p>The hyperparameter value for the shape parameter in the inverse-gamma prior for the variance
component</p>
</td></tr>
<tr><td><code id="gibbs_alg_+3A_al">al</code></td>
<td>
<p>The hyperparameter value for the shape parameter in the gamma prior for lambda</p>
</td></tr>
<tr><td><code id="gibbs_alg_+3A_bl">bl</code></td>
<td>
<p>The hyperparameter value for the scale parameter in the gamma prior for lambda</p>
</td></tr>
<tr><td><code id="gibbs_alg_+3A_a">a</code></td>
<td>
<p>The hyperparameter value for the shape parameter in the gamma prior for alpha0</p>
</td></tr>
<tr><td><code id="gibbs_alg_+3A_b">b</code></td>
<td>
<p>The hyperparameter value for the scale parameter in the gamma prior for alpha0</p>
</td></tr>
<tr><td><code id="gibbs_alg_+3A_alpha0">alpha0</code></td>
<td>
<p>A scalar defining the parameter for the Dirichlet process prior
that controls the number of clusters (or its initial values)</p>
</td></tr>
<tr><td><code id="gibbs_alg_+3A_kstar">kstar</code></td>
<td>
<p>A scalar with the number maximum of change points in all clusters</p>
</td></tr>
<tr><td><code id="gibbs_alg_+3A_lambda">lambda</code></td>
<td>
<p>A scalar defining the parameter for the Truncate Poisson distribution
that controls the number of change points (or its initial values)</p>
</td></tr>
<tr><td><code id="gibbs_alg_+3A_y">Y</code></td>
<td>
<p>A matrix M x N with the data sequences</p>
</td></tr>
<tr><td><code id="gibbs_alg_+3A_d">d</code></td>
<td>
<p>A scalar representing the number of clusters.</p>
</td></tr>
<tr><td><code id="gibbs_alg_+3A_maxiter">maxIter</code></td>
<td>
<p>A scalar for the number of iteration to run in the Gibbs sampler</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with each component representing the estimates
for each iteration of the Gibbs sampler for each parameter
</p>


<h3>See Also</h3>

<p>[run_gibbs()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(data)
# initial values for each paramter and each cluster
par.values &lt;- list(K = c(0, 0), Tl = list(50, 50), alpha = list(5, 10))
#cluster assignment for each data sequence
cluster &lt;- kmeans(t(data), 2)$cluster
# variance for each data sequence
sigma2 &lt;- apply(data, 2, var)
res &lt;- gibbs_alg(alpha0 = 1/100, N = 5, w = 10, M = 50, K = par.values$K,
Tl = par.values$Tl, cluster = cluster, alpha = par.values$alpha, sigma2 = sigma2,
bs = 1000, as = 2, al = 2, bl = 1000, a = 2, b = 1000, kstar = 2, lambda = 2,
Y = data, d = 2, maxIter = 10)

</code></pre>

<hr>
<h2 id='logsumexp'>Transfor a vector with over- or underflow</h2><span id='topic+logsumexp'></span>

<h3>Description</h3>

<p>Transfor a vector with over- or underflow
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logsumexp(x, min_x = Inf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logsumexp_+3A_x">x</code></td>
<td>
<p>A vector with numbers</p>
</td></tr>
<tr><td><code id="logsumexp_+3A_min_x">min_x</code></td>
<td>
<p>A numerical value to represent the minimum value
to perform comparison with the actual minimum value of 'x'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'logsumexp' returns each element of the vector 'x' transformed using the Log-Sum-Exp trick.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Transforming all elements in a vector using the Log-Sum-Exp trick
x &lt;- c(1, 2, 3, 4, 5, 6)
logsumexp(x)
</code></pre>

<hr>
<h2 id='Mode'>Compute the mode of a numerical vector</h2><span id='topic+Mode'></span>

<h3>Description</h3>

<p>Compute the mode of a numerical vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mode(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Mode_+3A_x">x</code></td>
<td>
<p>A vector with numbers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'Mode' returns a value representing the most frequent numerical value in the vector 'x'
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Finding the mode of a vector of numbers
x &lt;- c(1, 2, 2, 3, 5, 8, 10)
Mode(x)
</code></pre>

<hr>
<h2 id='pk'>Probability mass function for truncated poisson</h2><span id='topic+pk'></span>

<h3>Description</h3>

<p>Probability mass function for truncated poisson
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pk(k, kstar, lambda)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pk_+3A_k">k</code></td>
<td>
<p>A scalar for the number of changes points in a cluster</p>
</td></tr>
<tr><td><code id="pk_+3A_kstar">kstar</code></td>
<td>
<p>A scalar with the number maximum of change points in all clusters</p>
</td></tr>
<tr><td><code id="pk_+3A_lambda">lambda</code></td>
<td>
<p>A scalar defining the parameter for the Truncate Poisson distribution
that controls the number of change points (or its initial values)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'pk' returns a numerical value representing the marginal probability for a given k
</p>


<h3>Note</h3>

<p>This function is used within the Gibbs sampler, it is not expected to be used alone.
</p>


<h3>See Also</h3>

<p>[gibbs_alg()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Hypothetical values
pk(k = 2, kstar = 3, lambda = 2)

</code></pre>

<hr>
<h2 id='possigma2n'>Full conditional function for sigma2</h2><span id='topic+possigma2n'></span>

<h3>Description</h3>

<p>Full conditional function for sigma2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>possigma2n(as, bs, M, Yn, k, Tln, alphan)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="possigma2n_+3A_as">as</code></td>
<td>
<p>The hyperparameter value for the shape parameter in the inverse-gamma prior for the variance
component</p>
</td></tr>
<tr><td><code id="possigma2n_+3A_bs">bs</code></td>
<td>
<p>The hyperparameter value for the scale parameter in the inverse-gamma prior for the variance
component</p>
</td></tr>
<tr><td><code id="possigma2n_+3A_m">M</code></td>
<td>
<p>A scalar representing the number of points available for each data sequence</p>
</td></tr>
<tr><td><code id="possigma2n_+3A_yn">Yn</code></td>
<td>
<p>A vector or matrix with data sequences for a cluster</p>
</td></tr>
<tr><td><code id="possigma2n_+3A_k">k</code></td>
<td>
<p>A scalar for the number of changes points in a cluster</p>
</td></tr>
<tr><td><code id="possigma2n_+3A_tln">Tln</code></td>
<td>
<p>A vector with the change-point positions for a cluster</p>
</td></tr>
<tr><td><code id="possigma2n_+3A_alphan">alphan</code></td>
<td>
<p>A vector with the constant level values for each interval between change points for a cluster</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numerical value corresponding to a sampled value from the full conditional of the variance component
</p>


<h3>Note</h3>

<p>This function is called within the Gibbs sampler, but it can be used separately as well.
</p>


<h3>See Also</h3>

<p>[gibbs_alg()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(data)
possigma2n(as = 2, bs = 1000, M = 50, Yn = data[,1], k = 0, Tln = 50, alphan = 15)

</code></pre>

<hr>
<h2 id='postalpha0'>Posterior for alpha0</h2><span id='topic+postalpha0'></span>

<h3>Description</h3>

<p>Posterior for alpha0
</p>


<h3>Usage</h3>

<pre><code class='language-R'>postalpha0(alpha0, a, b, N, cluster)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="postalpha0_+3A_alpha0">alpha0</code></td>
<td>
<p>A scalar defining the parameter for the Dirichlet process prior
that controls the number of clusters (or its initial values)</p>
</td></tr>
<tr><td><code id="postalpha0_+3A_a">a</code></td>
<td>
<p>The hyperparameter value for the shape parameter in the gamma prior for alpha0</p>
</td></tr>
<tr><td><code id="postalpha0_+3A_b">b</code></td>
<td>
<p>The hyperparameter value for the scale parameter in the gamma prior for alpha0</p>
</td></tr>
<tr><td><code id="postalpha0_+3A_n">N</code></td>
<td>
<p>A scalar representing the number of data sequences</p>
</td></tr>
<tr><td><code id="postalpha0_+3A_cluster">cluster</code></td>
<td>
<p>A vector containing the cluster assignments for the data sequences (or its initial values)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numerical value corresponding to a sample from the posterior of alpha0
</p>


<h3>Note</h3>

<p>This function is called within the Gibbs sampler, but it can be called seperately.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>postalpha0(alpha0 = 1/100, a = 2, b = 1000, N = 5, cluster = c(1,1,2,1,1))

</code></pre>

<hr>
<h2 id='postalphak'>Full conditional for alphak</h2><span id='topic+postalphak'></span>

<h3>Description</h3>

<p>Full conditional for alphak
</p>


<h3>Usage</h3>

<pre><code class='language-R'>postalphak(M, Y, sigma2, K, Tl, cluster, clusteri)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="postalphak_+3A_m">M</code></td>
<td>
<p>A scalar representing the number of points available for each data sequence</p>
</td></tr>
<tr><td><code id="postalphak_+3A_y">Y</code></td>
<td>
<p>A matrix M x N with the data sequences</p>
</td></tr>
<tr><td><code id="postalphak_+3A_sigma2">sigma2</code></td>
<td>
<p>A vector with the variances of the data sequences (or its initial values)</p>
</td></tr>
<tr><td><code id="postalphak_+3A_k">K</code></td>
<td>
<p>A vector containing the number of change points for each cluster (or its initial values)</p>
</td></tr>
<tr><td><code id="postalphak_+3A_tl">Tl</code></td>
<td>
<p>A list containing a vector for each cluster determining the change-point positions in each cluster
(or its initial values)</p>
</td></tr>
<tr><td><code id="postalphak_+3A_cluster">cluster</code></td>
<td>
<p>A vector containing the cluster assignments for the data sequences (or its initial values)</p>
</td></tr>
<tr><td><code id="postalphak_+3A_clusteri">clusteri</code></td>
<td>
<p>A scalar with the index of a cluster</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numerical vector of size 'K' + 1 with sampled values from the full conditional of alphak for a given cluster 'clusteri'
</p>


<h3>Note</h3>

<p>This function is called within the Gibbs sampler, but it can be called separately as well.
</p>


<h3>See Also</h3>

<p>[gibbs_alg()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(data)
postalphak(M = 50, Y = data, sigma2 = 0.05, K = c(0, 0), Tl = c(50, 50),
 cluster = c(1,1,2,1,2), clusteri = 1)

</code></pre>

<hr>
<h2 id='postK'>Marginal probability of K</h2><span id='topic+postK'></span>

<h3>Description</h3>

<p>Marginal probability of K
</p>


<h3>Usage</h3>

<pre><code class='language-R'>postK(kstar, w, M, Y, cluster, sigma2, lambda, clusteri)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="postK_+3A_kstar">kstar</code></td>
<td>
<p>A scalar with the number maximum of change points in all clusters</p>
</td></tr>
<tr><td><code id="postK_+3A_w">w</code></td>
<td>
<p>A scalar representing the minimum number of points in each interval between two change points</p>
</td></tr>
<tr><td><code id="postK_+3A_m">M</code></td>
<td>
<p>A scalar representing the number of points available for each data sequence</p>
</td></tr>
<tr><td><code id="postK_+3A_y">Y</code></td>
<td>
<p>A matrix M x N with the data sequences</p>
</td></tr>
<tr><td><code id="postK_+3A_cluster">cluster</code></td>
<td>
<p>A vector containing the cluster assignments for the data sequences (or its initial values)</p>
</td></tr>
<tr><td><code id="postK_+3A_sigma2">sigma2</code></td>
<td>
<p>A vector with the variances of the data sequences (or its initial values)</p>
</td></tr>
<tr><td><code id="postK_+3A_lambda">lambda</code></td>
<td>
<p>A scalar defining the parameter for the Truncate Poisson distribution
that controls the number of change points (or its initial values)</p>
</td></tr>
<tr><td><code id="postK_+3A_clusteri">clusteri</code></td>
<td>
<p>A scalar with the index of a cluster</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numerical value corresponding to the sampled number of change points, k, for a given cluster
</p>


<h3>Note</h3>

<p>This function is called within the Gibbs sampler, but it can also de called separately.
</p>


<h3>See Also</h3>

<p>[gibbs_alg()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>postK(kstar = 2, w = 10, M = 50, Y = data, cluster = c(1,1,2,1,2),
sigma2 = apply(data, 2, var), lambda = 2, clusteri = 1)

</code></pre>

<hr>
<h2 id='postK_mk'>Marginal probability of K per bin</h2><span id='topic+postK_mk'></span>

<h3>Description</h3>

<p>Marginal probability of K per bin
</p>


<h3>Usage</h3>

<pre><code class='language-R'>postK_mk(k, m0, w, M, Yn, sigma2n, cellsn, mk, Cr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="postK_mk_+3A_k">k</code></td>
<td>
<p>A scalar for the number of changes points in a cluster</p>
</td></tr>
<tr><td><code id="postK_mk_+3A_m0">m0</code></td>
<td>
<p>A scalar for the number of positions available to define change-points positions</p>
</td></tr>
<tr><td><code id="postK_mk_+3A_w">w</code></td>
<td>
<p>A scalar representing the minimum number of points in each interval between two change points</p>
</td></tr>
<tr><td><code id="postK_mk_+3A_m">M</code></td>
<td>
<p>A scalar representing the number of points available for each data sequence</p>
</td></tr>
<tr><td><code id="postK_mk_+3A_yn">Yn</code></td>
<td>
<p>A vector or matrix with data sequences for a cluster</p>
</td></tr>
<tr><td><code id="postK_mk_+3A_sigma2n">sigma2n</code></td>
<td>
<p>A vector with the variance of the data sequences in a cluster</p>
</td></tr>
<tr><td><code id="postK_mk_+3A_cellsn">cellsn</code></td>
<td>
<p>A vector with the indices of the data sequences in a cluster</p>
</td></tr>
<tr><td><code id="postK_mk_+3A_mk">mk</code></td>
<td>
<p>A matrix with all possible values to distribute between change points</p>
</td></tr>
<tr><td><code id="postK_mk_+3A_cr">Cr</code></td>
<td>
<p>A scalar with the number of data sequences in a cluster</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'postK_mk' returns a numerical value representing the non-normalized probability for a given bin, given k, and a given cluster
</p>


<h3>Note</h3>

<p>This function is called within [postK()]. It should not be called alone.
</p>


<h3>See Also</h3>

<p>[postK()], [gibbs_alg()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(data)
M &lt;- 50; k &lt;- 0; w &lt;- 10;
m0 &lt;- M - 1 -(k+1)*w
for(k in 0:2){
mk &lt;- RcppAlgos::permuteGeneral(0:m0, k + 1,
constraintFun = "sum",
comparisonFun = "==", limitConstraints = m0,
repetition = TRUE)}
out &lt;- postK_mk(k = 0, m0 = m0, w = 10, M = 50, Yn = data[,c(1,2,4)],
 sigma2n = rep(0.05, 3), cellsn = c(1,2,4), mk = mk[1,], Cr = 3)
</code></pre>

<hr>
<h2 id='postmk'>Marginal probability of m1,m2,m3,...,mk+1</h2><span id='topic+postmk'></span>

<h3>Description</h3>

<p>Marginal probability of m1,m2,m3,...,mk+1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>postmk(w, M, Y, K, cluster, sigma2, clusteri)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="postmk_+3A_w">w</code></td>
<td>
<p>A scalar representing the minimum number of points in each interval between two change points</p>
</td></tr>
<tr><td><code id="postmk_+3A_m">M</code></td>
<td>
<p>A scalar representing the number of points available for each data sequence</p>
</td></tr>
<tr><td><code id="postmk_+3A_y">Y</code></td>
<td>
<p>A matrix M x N with the data sequences</p>
</td></tr>
<tr><td><code id="postmk_+3A_k">K</code></td>
<td>
<p>A vector containing the number of change points for each cluster (or its initial values)</p>
</td></tr>
<tr><td><code id="postmk_+3A_cluster">cluster</code></td>
<td>
<p>A vector containing the cluster assignments for the data sequences (or its initial values)</p>
</td></tr>
<tr><td><code id="postmk_+3A_sigma2">sigma2</code></td>
<td>
<p>A vector with the variances of the data sequences (or its initial values)</p>
</td></tr>
<tr><td><code id="postmk_+3A_clusteri">clusteri</code></td>
<td>
<p>A scalar with the index of a cluster</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numerical vector of size k + 1 with the sampled number of observations (or bin size, mk) between each change point for a given cluster
</p>


<h3>Note</h3>

<p>This function is called within the Gibbs sampler, but it can also be called separately.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(data)
postmk(w = 10, M = 50, Y = data, K = c(1, 1), cluster = c(2,1,1,1,1), sigma2 = apply(data, 2, var),
clusteri = 1)

</code></pre>

<hr>
<h2 id='qn0'>Mixing probability for creating new cluster</h2><span id='topic+qn0'></span>

<h3>Description</h3>

<p>Mixing probability for creating new cluster
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qn0(alpha0, w, N, M, bs, as, kstar, lambda, Yn)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qn0_+3A_alpha0">alpha0</code></td>
<td>
<p>A scalar defining the parameter for the Dirichlet process prior
that controls the number of clusters (or its initial values)</p>
</td></tr>
<tr><td><code id="qn0_+3A_w">w</code></td>
<td>
<p>A scalar representing the minimum number of points in each interval between two change points</p>
</td></tr>
<tr><td><code id="qn0_+3A_n">N</code></td>
<td>
<p>A scalar representing the number of data sequences</p>
</td></tr>
<tr><td><code id="qn0_+3A_m">M</code></td>
<td>
<p>A scalar representing the number of points available for each data sequence</p>
</td></tr>
<tr><td><code id="qn0_+3A_bs">bs</code></td>
<td>
<p>The hyperparameter value for the scale parameter in the inverse-gamma prior for the variance
component</p>
</td></tr>
<tr><td><code id="qn0_+3A_as">as</code></td>
<td>
<p>The hyperparameter value for the shape parameter in the inverse-gamma prior for the variance
component</p>
</td></tr>
<tr><td><code id="qn0_+3A_kstar">kstar</code></td>
<td>
<p>A scalar with the number maximum of change points in all clusters</p>
</td></tr>
<tr><td><code id="qn0_+3A_lambda">lambda</code></td>
<td>
<p>A scalar defining the parameter for the Truncate Poisson distribution
that controls the number of change points (or its initial values)</p>
</td></tr>
<tr><td><code id="qn0_+3A_yn">Yn</code></td>
<td>
<p>A vector or matrix with data sequences for a cluster</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numerical value representing the mixing value term used to compute the probability that the given data sequence should be a singleton cluster
</p>


<h3>Note</h3>

<p>This function is called within [gibbs_alg()]. It should not be called alone.
</p>


<h3>See Also</h3>

<p>[gibbs_alg()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>qn0(alpha0 = 1/100, w = 10, N = 5, M = 50, bs = 1000, as = 2, kstar = 2, lambda = 2, Yn = data[,1])

</code></pre>

<hr>
<h2 id='qn0_mk'>Mixing probability for creating new cluster per bin</h2><span id='topic+qn0_mk'></span>

<h3>Description</h3>

<p>Mixing probability for creating new cluster per bin
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qn0_mk(w, m0, bs, as, M, km, lambda, mk, Yn, kstar)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qn0_mk_+3A_w">w</code></td>
<td>
<p>A scalar representing the minimum number of points in each interval between two change points</p>
</td></tr>
<tr><td><code id="qn0_mk_+3A_m0">m0</code></td>
<td>
<p>A scalar for the number of positions available to define change-points positions</p>
</td></tr>
<tr><td><code id="qn0_mk_+3A_bs">bs</code></td>
<td>
<p>The hyperparameter value for the scale parameter in the inverse-gamma prior for the variance
component</p>
</td></tr>
<tr><td><code id="qn0_mk_+3A_as">as</code></td>
<td>
<p>The hyperparameter value for the shape parameter in the inverse-gamma prior for the variance
component</p>
</td></tr>
<tr><td><code id="qn0_mk_+3A_m">M</code></td>
<td>
<p>A scalar representing the number of points available for each data sequence</p>
</td></tr>
<tr><td><code id="qn0_mk_+3A_km">km</code></td>
<td>
<p>A scalar for the number of changes points in a cluster</p>
</td></tr>
<tr><td><code id="qn0_mk_+3A_lambda">lambda</code></td>
<td>
<p>A scalar defining the parameter for the Truncate Poisson distribution
that controls the number of change points (or its initial values)</p>
</td></tr>
<tr><td><code id="qn0_mk_+3A_mk">mk</code></td>
<td>
<p>A matrix with all possible values to distribute between change points</p>
</td></tr>
<tr><td><code id="qn0_mk_+3A_yn">Yn</code></td>
<td>
<p>A vector with a data sequence</p>
</td></tr>
<tr><td><code id="qn0_mk_+3A_kstar">kstar</code></td>
<td>
<p>A scalar with the number maximum of change points in all clusters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numerical value representing the mixing value term used to compute the probability that the given data sequence should be a singleton cluster for a given bin size.
</p>


<h3>Note</h3>

<p>This function is called within [qn0()]. It should not be called alone.
</p>


<h3>See Also</h3>

<p>[qn0()], [gibbs_alg()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(data)
M &lt;- 50; k &lt;- 0; w &lt;- 10;
m0 &lt;- M - 1 -(k+1)*w
for(k in 0:2){
mk &lt;- RcppAlgos::permuteGeneral(0:m0, k + 1,
constraintFun = "sum",
comparisonFun = "==", limitConstraints = m0,
repetition = TRUE)}
out &lt;- qn0_mk(w = 10, m0 = m0, bs = 1000, as = 2, M = 50, km = 1,
 lambda = 2, mk = mk[1,], Yn = data[,1], kstar = 2)
</code></pre>

<hr>
<h2 id='qnj'>Mixing probability for getting assigned to an existing cluster</h2><span id='topic+qnj'></span>

<h3>Description</h3>

<p>Mixing probability for getting assigned to an existing cluster
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qnj(N, M, as, bs, Yn, alpha, cluster, Tl, K)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qnj_+3A_n">N</code></td>
<td>
<p>A scalar representing the number of data sequences</p>
</td></tr>
<tr><td><code id="qnj_+3A_m">M</code></td>
<td>
<p>A scalar representing the number of points available for each data sequence</p>
</td></tr>
<tr><td><code id="qnj_+3A_as">as</code></td>
<td>
<p>The hyperparameter value for the shape parameter in the inverse-gamma prior for the variance
component</p>
</td></tr>
<tr><td><code id="qnj_+3A_bs">bs</code></td>
<td>
<p>The hyperparameter value for the scale parameter in the inverse-gamma prior for the variance
component</p>
</td></tr>
<tr><td><code id="qnj_+3A_yn">Yn</code></td>
<td>
<p>A vector or matrix with data sequences for a cluster</p>
</td></tr>
<tr><td><code id="qnj_+3A_alpha">alpha</code></td>
<td>
<p>A list containing a vector for each cluster determining the constant level values
for each interval between change points in each cluster (or its initial values)</p>
</td></tr>
<tr><td><code id="qnj_+3A_cluster">cluster</code></td>
<td>
<p>A vector containing the cluster assignments for the data sequences (or its initial values)</p>
</td></tr>
<tr><td><code id="qnj_+3A_tl">Tl</code></td>
<td>
<p>A list containing a vector for each cluster determining the change-point positions in each cluster
(or its initial values)</p>
</td></tr>
<tr><td><code id="qnj_+3A_k">K</code></td>
<td>
<p>A vector containing the number of change points for each cluster (or its initial values)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of same size as the vector 'cluster' corresponding to the mixing term value used to compute the probability that the given data sequence 'Yn' should be part of each existing cluster
</p>


<h3>Note</h3>

<p>This function is called within the Gibbs sampler. It should not be called alone.
</p>


<h3>See Also</h3>

<p>[gibbs_alg()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>qnj(N = 5, M = 50, as = 2, bs = 1000, Yn = data[,1], alpha = c(10, 10),
 cluster = c(1,1,2,1,2), Tl = c(50,50), K = c(0,0))

</code></pre>

<hr>
<h2 id='run_gibbs'>Runs the Gibbs sampler algorithm using using initial values for the parameters</h2><span id='topic+run_gibbs'></span>

<h3>Description</h3>

<p>Runs the Gibbs sampler algorithm using using initial values for the parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_gibbs(
  M,
  N,
  w,
  d,
  as = 2,
  bs = 100,
  al = 2,
  bl = 1000,
  a = 2,
  b = 1000,
  alpha0 = 1/100,
  lambda = 2,
  maxIter = 10000,
  par.values,
  data,
  cluster,
  sigma2
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="run_gibbs_+3A_m">M</code></td>
<td>
<p>A scalar representing the number of points available for each observation</p>
</td></tr>
<tr><td><code id="run_gibbs_+3A_n">N</code></td>
<td>
<p>A scalar representing the number of observations</p>
</td></tr>
<tr><td><code id="run_gibbs_+3A_w">w</code></td>
<td>
<p>A scalar representing the minimum number of points in each interval between two change points</p>
</td></tr>
<tr><td><code id="run_gibbs_+3A_d">d</code></td>
<td>
<p>A scalar representing the number of clusters.</p>
</td></tr>
<tr><td><code id="run_gibbs_+3A_as">as</code></td>
<td>
<p>The hyperparameter value for the shape parameter in the inverse-gamma prior for the variance
component</p>
</td></tr>
<tr><td><code id="run_gibbs_+3A_bs">bs</code></td>
<td>
<p>The hyperparameter value for the scale parameter in the inverse-gamma prior for the variance
component</p>
</td></tr>
<tr><td><code id="run_gibbs_+3A_al">al</code></td>
<td>
<p>The hyperparameter value for the shape parameter in the gamma prior for lambda</p>
</td></tr>
<tr><td><code id="run_gibbs_+3A_bl">bl</code></td>
<td>
<p>The hyperparameter value for the scale parameter in the gamma prior for lambda</p>
</td></tr>
<tr><td><code id="run_gibbs_+3A_a">a</code></td>
<td>
<p>The hyperparameter value for the shape parameter in the gamma prior for alpha0</p>
</td></tr>
<tr><td><code id="run_gibbs_+3A_b">b</code></td>
<td>
<p>The hyperparameter value for the scale parameter in the gamma prior for alpha0</p>
</td></tr>
<tr><td><code id="run_gibbs_+3A_alpha0">alpha0</code></td>
<td>
<p>A scalar defining the parameter for the Dirichlet process prior
that controls the number of clusters (or its initial values)</p>
</td></tr>
<tr><td><code id="run_gibbs_+3A_lambda">lambda</code></td>
<td>
<p>A scalar defining the parameter for the Truncate Poisson distribution
that controls the number of change points (or its initial values)</p>
</td></tr>
<tr><td><code id="run_gibbs_+3A_maxiter">maxIter</code></td>
<td>
<p>A scalar for the number of iteration to run in the Gibbs sampler</p>
</td></tr>
<tr><td><code id="run_gibbs_+3A_par.values">par.values</code></td>
<td>
<p>A list with lists with parameters for each cluster.
The first argument in each list is the number of change points,
then the positions for the change points,
where T_1 = 1, T_last = M + 1, and for each interval between change points
you need to specify a value for the constant level. If running the
Gibbs sampler for a dataset with unknown number of change points,
we suggest setting the number of change points for each cluster to be zero.
Check example in README file.</p>
</td></tr>
<tr><td><code id="run_gibbs_+3A_data">data</code></td>
<td>
<p>a matrix of size M x N with data sequences in the columns</p>
</td></tr>
<tr><td><code id="run_gibbs_+3A_cluster">cluster</code></td>
<td>
<p>a vector with cluster assignments for each data sequence</p>
</td></tr>
<tr><td><code id="run_gibbs_+3A_sigma2">sigma2</code></td>
<td>
<p>a vector with variance components for each data sequence</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with estimates for each iteration of the Gibbs sampler for each parameter
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
d = 2 # two clusters
N = 5 # 5 data sequences
M = 50 # 50 observations for each data sequence
maxIter = 10 # number of Gibbs sampler iterations

data(data)
# initial values for each paramter and each cluster
par.values &lt;- list(K = c(0, 0), Tl = list(50, 50), alpha = list(5, 10))
#cluster assignment for each data sequence
cluster &lt;- kmeans(t(data), 2)$cluster
# variance for each data sequence
sigma2 &lt;- apply(data, 2, var)
res &lt;- run_gibbs(M, N, w = 10, d, as = 2, bs = 100, al = 2, bl = 1000, a = 2,
 b = 1000, alpha0 = 1/100, lambda = 2, maxIter = 10, par.values, data,
 cluster, sigma2)

</code></pre>

<hr>
<h2 id='update_lambda'>Update equation for lambda</h2><span id='topic+update_lambda'></span>

<h3>Description</h3>

<p>Update equation for lambda
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_lambda(a = 4, b = 2, kstar, lambda, cluster, al, bl, K, N)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update_lambda_+3A_a">a</code></td>
<td>
<p>The hyperparameter value for the shape parameter in the gamma prior for alpha0</p>
</td></tr>
<tr><td><code id="update_lambda_+3A_b">b</code></td>
<td>
<p>The hyperparameter value for the scale parameter in the gamma prior for alpha0</p>
</td></tr>
<tr><td><code id="update_lambda_+3A_kstar">kstar</code></td>
<td>
<p>A scalar with the number maximum of change points in all clusters</p>
</td></tr>
<tr><td><code id="update_lambda_+3A_lambda">lambda</code></td>
<td>
<p>A scalar defining the parameter for the Truncate Poisson distribution
that controls the number of change points (or its initial values)</p>
</td></tr>
<tr><td><code id="update_lambda_+3A_cluster">cluster</code></td>
<td>
<p>A vector containing the cluster assignments for the data sequences (or its initial values)</p>
</td></tr>
<tr><td><code id="update_lambda_+3A_al">al</code></td>
<td>
<p>The hyperparameter value for the shape parameter in the gamma prior for lambda</p>
</td></tr>
<tr><td><code id="update_lambda_+3A_bl">bl</code></td>
<td>
<p>The hyperparameter value for the scale parameter in the gamma prior for lambda</p>
</td></tr>
<tr><td><code id="update_lambda_+3A_k">K</code></td>
<td>
<p>A vector containing the number of change points for each cluster (or its initial values)</p>
</td></tr>
<tr><td><code id="update_lambda_+3A_n">N</code></td>
<td>
<p>A scalar representing the number of data sequences</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numerical value corresponding to a sample from the posterior of the parameter lambda
</p>


<h3>Note</h3>

<p>This function is called within the Gibbs sampler, but it can also be called separately.
</p>


<h3>See Also</h3>

<p>[gibbs_alg()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>update_lambda(a = 4, b = 2, kstar = 2, lambda = 2, cluster = c(1,1,2,1,2),
 al = 2, bl = 1000, K = c(2,2), N = 5)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
