<!DOCTYPE html><html><head><title>Help for package BTYD</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BTYD}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BTYD-package'><p>This project was funded and sponsored by</p>
<a href="https://wca.wharton.upenn.edu">Wharton Customer Analytics</a>.</a></li>
<li><a href='#addLogs'><p>Add Logs</p></a></li>
<li><a href='#bgbb.ConditionalExpectedTransactions'><p>BG/BB Conditional Expected Transactions</p></a></li>
<li><a href='#bgbb.DERT'><p>BG/BB Discounted Expected Residual Transactions</p></a></li>
<li><a href='#bgbb.EstimateParameters'><p>BG/BB Parameter estimation</p></a></li>
<li><a href='#bgbb.Expectation'><p>BG/BB Expectation</p></a></li>
<li><a href='#bgbb.HeatmapHoldoutExpectedTrans'><p>BG/BB Heatmap of Holdout Period Expected Transactions</p></a></li>
<li><a href='#bgbb.LL'><p>BG/BB Log-Likelihood</p></a></li>
<li><a href='#bgbb.PAlive'><p>BG/BB P(Alive)</p></a></li>
<li><a href='#bgbb.PlotDropoutRateHeterogeneity'><p>BG/BB Plot Dropout Rate Heterogeneity</p></a></li>
<li><a href='#bgbb.PlotFrequencyInCalibration'><p>BG/BB Plot Frequency in Calibration Period</p></a></li>
<li><a href='#bgbb.PlotFrequencyInHoldout'><p>BG/BB Plot Frequency in Holdout</p></a></li>
<li><a href='#bgbb.PlotFreqVsConditionalExpectedFrequency'><p>BG/BB Plot Frequency vs Conditional Expected Frequency</p></a></li>
<li><a href='#bgbb.PlotRecVsConditionalExpectedFrequency'><p>BG/BB Plot Recency vs Conditional Expected Frequency</p></a></li>
<li><a href='#bgbb.PlotTrackingCum'><p>BG/BB Tracking Cumulative Transactions Plot</p></a></li>
<li><a href='#bgbb.PlotTrackingInc'><p>BG/BB Tracking Incremental Transactions Plot</p></a></li>
<li><a href='#bgbb.PlotTransactionRateHeterogeneity'><p>BG/BB Plot Transaction Rate Heterogeneity</p></a></li>
<li><a href='#bgbb.pmf'><p>BG/BB Probability Mass Function</p></a></li>
<li><a href='#bgbb.pmf.General'><p>BG/BB General Probability Mass Function</p></a></li>
<li><a href='#bgbb.PosteriorMeanDropoutRate'><p>BG/BB Posterior Mean Dropout Rate</p></a></li>
<li><a href='#bgbb.PosteriorMeanLmProductMoment'><p>BG/BB Posterior Mean (l,m)th Product Moment</p></a></li>
<li><a href='#bgbb.PosteriorMeanTransactionRate'><p>BG/BB Posterior Mean Transaction Rate</p></a></li>
<li><a href='#bgbb.rf.matrix.DERT'><p>BG/BB Discounted Expected Residual Transactions using a recency-frequency matrix</p></a></li>
<li><a href='#bgbb.rf.matrix.LL'><p>BG/BB Log-Likelihood using a recency-frequency matrix</p></a></li>
<li><a href='#bgbb.rf.matrix.PosteriorMeanDropoutRate'><p>BG/BB Posterior Mean Dropout Rate using a recency-frequency matrix</p></a></li>
<li><a href='#bgbb.rf.matrix.PosteriorMeanTransactionRate'><p>BG/BB Posterior Mean Transaction Rate using a recency-frequency matrix</p></a></li>
<li><a href='#bgnbd.cbs.LL'><p>BG/NBD Log-Likelihood Wrapper</p></a></li>
<li><a href='#bgnbd.ConditionalExpectedTransactions'><p>BG/NBD Conditional Expected Transactions</p></a></li>
<li><a href='#bgnbd.EstimateParameters'><p>BG/NBD Parameter Estimation</p></a></li>
<li><a href='#bgnbd.Expectation'><p>BG/NBD Expectation</p></a></li>
<li><a href='#bgnbd.ExpectedCumulativeTransactions'><p>BG/NBD Expected Cumulative Transactions</p></a></li>
<li><a href='#bgnbd.generalParams'><p>Define general parameters</p></a></li>
<li><a href='#bgnbd.LL'><p>BG/NBD Log-Likelihood</p></a></li>
<li><a href='#bgnbd.PAlive'><p>BG/NBD P(Alive)</p></a></li>
<li><a href='#bgnbd.PlotDropoutRateHeterogeneity'><p>BG/NBD Plot Dropout Probability Heterogeneity</p></a></li>
<li><a href='#bgnbd.PlotFrequencyInCalibration'><p>BG/NBD Plot Frequency in Calibration Period</p></a></li>
<li><a href='#bgnbd.PlotFreqVsConditionalExpectedFrequency'><p>BG/NBD Plot Frequency vs. Conditional Expected Frequency</p></a></li>
<li><a href='#bgnbd.PlotRecVsConditionalExpectedFrequency'><p>BG/NBD Plot Actual vs. Conditional Expected Frequency by Recency</p></a></li>
<li><a href='#bgnbd.PlotTrackingCum'><p>BG/NBD Tracking Cumulative Transactions Plot</p></a></li>
<li><a href='#bgnbd.PlotTrackingInc'><p>BG/NBD Tracking Incremental Transactions Comparison</p></a></li>
<li><a href='#bgnbd.PlotTransactionRateHeterogeneity'><p>BG/NBD Plot Transaction Rate Heterogeneity</p></a></li>
<li><a href='#bgnbd.pmf'><p>BG/NBD Probability Mass Function</p></a></li>
<li><a href='#bgnbd.pmf.General'><p>Generalized BG/NBD Probability Mass Function</p></a></li>
<li><a href='#cdnowElog'><p>CDNOW event log data</p></a></li>
<li><a href='#cdnowSummary'><p>CDNOW repeat transaction data summary</p></a></li>
<li><a href='#dc.BuildCBSFromCBTAndDates'><p>Build CBS matrix from CBT matrix</p></a></li>
<li><a href='#dc.BuildCBTFromElog'><p>Build Customer-by-Time Matrix from Event Log</p></a></li>
<li><a href='#dc.check.model.params'><p>Check model params</p></a></li>
<li><a href='#dc.compress.cbs'><p>Compress Customer-by-Sufficient-Statistic (CBS) Matrix</p></a></li>
<li><a href='#dc.CreateFreqCBT'><p>Create Frequency Customer-by-Time Matrix</p></a></li>
<li><a href='#dc.CreateReachCBT'><p>Create Reach Customer-by-Time Matrix</p></a></li>
<li><a href='#dc.CreateSpendCBT'><p>Create Spend Customer-by-Time Matrix</p></a></li>
<li><a href='#dc.CumulativeToIncremental'><p>Cumulative to Incremental</p></a></li>
<li><a href='#dc.DissipateElog'><p>Dissipate Event Log</p></a></li>
<li><a href='#dc.ElogToCbsCbt'><p>Convert Event Log to CBS and CBT Matrices</p></a></li>
<li><a href='#dc.FilterCustByBirth'><p>Filter Customer by Birth</p></a></li>
<li><a href='#dc.GetFirstPurchasePeriodsFromCBT'><p>Get First Purchase Periods from Customer-by-Time Matrix</p></a></li>
<li><a href='#dc.GetLastPurchasePeriodsFromCBT'><p>Get Last Purchase Periods from Customer-by-Time Matrix</p></a></li>
<li><a href='#dc.InputCheck'><p>Check the inputs to functions that use this common pattern</p></a></li>
<li><a href='#dc.MakeRFmatrixCal'><p>Make Calibration Period Recency-Frequency Matrix</p></a></li>
<li><a href='#dc.MakeRFmatrixHoldout'><p>Make Holdout Period Recency-Frequency Matrix</p></a></li>
<li><a href='#dc.MakeRFmatrixSkeleton'><p>Make Recency-Frequency Matrix Skeleton</p></a></li>
<li><a href='#dc.MergeCustomers'><p>Merge Customers</p></a></li>
<li><a href='#dc.MergeTransactionsOnSameDate'><p>Merge Transactions on Same Day</p></a></li>
<li><a href='#dc.PlotLogLikelihoodContour'><p>Plot Log-Likelihood Contour</p></a></li>
<li><a href='#dc.PlotLogLikelihoodContours'><p>Plot Log-Likelihood Contours</p></a></li>
<li><a href='#dc.ReadLines'><p>Read Lines</p></a></li>
<li><a href='#dc.RemoveTimeBetween'><p>Remove Time Between</p></a></li>
<li><a href='#dc.SplitUpElogForRepeatTrans'><p>Split Up Event Log for Repeat Transactions</p></a></li>
<li><a href='#dc.WriteLine'><p>Write Line</p></a></li>
<li><a href='#discreteSimElog'><p>Discrete simulated annual event log data</p></a></li>
<li><a href='#donationsSummary'><p>Discrete donation data summary</p></a></li>
<li><a href='#h2f1'><p>Use Bruce Hardie's Gaussian hypergeometric implementation</p></a></li>
<li><a href='#pnbd.cbs.LL'><p>Pareto/NBD Log-Likelihood</p></a></li>
<li><a href='#pnbd.ConditionalExpectedTransactions'><p>Pareto/NBD Conditional Expected Transactions</p></a></li>
<li><a href='#pnbd.DERT'><p>Pareto/NBD Discounted Expected Residual Transactions</p></a></li>
<li><a href='#pnbd.EstimateParameters'><p>Pareto/NBD Parameter Estimation</p></a></li>
<li><a href='#pnbd.Expectation'><p>Pareto/NBD Expectation</p></a></li>
<li><a href='#pnbd.ExpectedCumulativeTransactions'><p>Pareto/NBD Expected Cumulative Transactions</p></a></li>
<li><a href='#pnbd.generalParams'><p>Define general parameters</p></a></li>
<li><a href='#pnbd.LL'><p>Pareto/NBD Log-Likelihood</p></a></li>
<li><a href='#pnbd.PAlive'><p>Pareto/NBD P(Alive)</p></a></li>
<li><a href='#pnbd.Plot.DERT'><p>Pareto/NBD Plot Discounted Expected Residual Transactions</p></a></li>
<li><a href='#pnbd.PlotDropoutRateHeterogeneity'><p>Pareto/NBD Plot Dropout Rate Heterogeneity</p></a></li>
<li><a href='#pnbd.PlotFrequencyInCalibration'><p>Pareto/NBD Plot Frequency in Calibration Period</p></a></li>
<li><a href='#pnbd.PlotFreqVsConditionalExpectedFrequency'><p>Pareto/NBD Plot Frequency vs. Conditional Expected Frequency</p></a></li>
<li><a href='#pnbd.PlotRateHeterogeneity'><p>Plot Pareto/NBD Rate Heterogeneity</p></a></li>
<li><a href='#pnbd.PlotRecVsConditionalExpectedFrequency'><p>Pareto/NBD Plot Actual vs. Conditional Expected Frequency by Recency</p></a></li>
<li><a href='#pnbd.PlotTrackingCum'><p>Pareto/NBD Tracking Cumulative Transactions Plot</p></a></li>
<li><a href='#pnbd.PlotTrackingInc'><p>Pareto/NBD Tracking Incremental Transactions Comparison</p></a></li>
<li><a href='#pnbd.PlotTransactionRateHeterogeneity'><p>Pareto/NBD Plot Transaction Rate Heterogeneity</p></a></li>
<li><a href='#pnbd.pmf'><p>Pareto/NBD Probability Mass Function</p></a></li>
<li><a href='#pnbd.pmf.General'><p>Generalized Pareto/NBD Probability Mass Function</p></a></li>
<li><a href='#spend.EstimateParameters'><p>Spend Parameter Estimation</p></a></li>
<li><a href='#spend.expected.value'><p>Conditional expected transaction value</p></a></li>
<li><a href='#spend.generalParams'><p>Define general parameters</p></a></li>
<li><a href='#spend.LL'><p>Spend Log-Likelihood</p></a></li>
<li><a href='#spend.marginal.likelihood'><p>Gamma-gamma marginal likelihood</p></a></li>
<li><a href='#spend.plot.average.transaction.value'><p>Plot Actual vs. Expected Average Transaction Value</p></a></li>
<li><a href='#subLogs'><p>Subtract Logs</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Implementing BTYD Models with the Log Sum Exp Patch</td>
</tr>
<tr>
<td>Version:</td>
<td>2.4.3</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gabi Huiber &lt;ghuiber@gmail.com&gt;</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ghuiber/BTYD/issues">https://github.com/ghuiber/BTYD/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for data preparation, parameter estimation, scoring, and plotting for the 
    BG/BB (Fader, Hardie, and Shang 2010 &lt;<a href="https://doi.org/10.1287%2Fmksc.1100.0580">doi:10.1287/mksc.1100.0580</a>&gt;), 
    BG/NBD (Fader, Hardie, and Lee 2005 &lt;<a href="https://doi.org/10.1287%2Fmksc.1040.0098">doi:10.1287/mksc.1040.0098</a>&gt;) and 
    Pareto/NBD and Gamma/Gamma (Fader, Hardie, and Lee 2005 &lt;<a href="https://doi.org/10.1509%2Fjmkr.2005.42.4.415">doi:10.1509/jmkr.2005.42.4.415</a>&gt;) models.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Collate:</td>
<td>'data.R' 'BTYD.R' 'bgbb.R' 'bgnbd.R' 'pnbd.R' 'dc.R' 'spend.R'</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.5), hypergeo, optimx, dplyr</td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>Author:</td>
<td>Lukasz Dziurzynski [aut],
  Edward Wadsworth [aut],
  Peter Fader [ctb],
  Elea McDonnell Feit [ctb],
  Daniel McCarthy [aut, ctb],
  Bruce Hardie [ctb],
  Arun Gopalakrishnan [ctb],
  Eric Schwartz [ctb],
  Yao Zhang [ctb],
  Gabi Huiber [ctb, cre]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-11-17 19:01:20 UTC; ghuiber</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-11-17 19:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='BTYD-package'>This project was funded and sponsored by
<a href="https://wca.wharton.upenn.edu">Wharton Customer Analytics</a>.</h2><span id='topic+BTYD'></span><span id='topic+BTYD-package'></span>

<h3>Description</h3>

<p>This package implements the BG/BB, BG/NBD and Pareto/NBD models, which
capture/project customer purchase patterns in a typical
non-contractual setting.
</p>


<h3>Details</h3>

<p>While these models are developed on a customer-by-customer basis, they
do not necessarily require data at such a granular level. The
Pareto/NBD requires a &quot;customer-by-sufficient-statistic&quot; matrix
(CBS), which consists of each customer's frequency, recency (the time
of their last transactions) and total time observed - but the timing
of each and every transaction (other than the last) is not needed by
the model. If, however, you do have the granular data in the form of
an event log (which contains at least columns for customer
identification and the time of each transaction, and potentially more
columns such as transaction amount), this package provides functions
to convert it to a CBS. You can use <code><a href="#topic+dc.ReadLines">dc.ReadLines</a></code> to get
your event log from a comma-delimited file to an event log usable by
this package; it is possible to use read.table or read.csv, but
formatting will be required afterwards. You can then convert the event
log directly to a CBS (for both the calibration and holdout periods)
using <code><a href="#topic+dc.ElogToCbsCbt">dc.ElogToCbsCbt</a></code>. As the name suggests, this
function also produces a customer-by-time matrix (CBT). This matrix
consists of a row for every customer and a column for every date, and
is populated by a statistic of your choice (reach, frequency, or
spend). It is not necessary for any of the models presented in this
package, but is used as a building block to produce the CBS.
</p>
<p>The BG/NBD model requires all the same inputs as the Pareto/NBD model.
</p>
<p>The BG/BB model requires the same information as the Pareto/NBD model,
but as it models discrete transaction opportunities, this information
can be condensed into a recency-frequency matrix. A recency-frequency
matrix contains a row for every recency/frequency combination in the
given time period, and each row contains the number of customers with
that recency/frequency combination. Since frequency will always be
less than or equal to recency, this matrix will contain (n)(n-1)/2 + 1
rows at most, with n as the number of transaction opportunities (of
course, the maximum number of rows for pooled data - for customers
with varying numbers of transaction opportunities - will be the sum of
the above equation for each unique number of transaction
opportunities). You can convert a CBS to recency-frequency matrices
using <code><a href="#topic+dc.MakeRFmatrixCal">dc.MakeRFmatrixCal</a></code> and
<code><a href="#topic+dc.MakeRFmatrixHoldout">dc.MakeRFmatrixHoldout</a></code>.
</p>
<p>If you want to test the data contained in the package, or have data
formatted as a customer-by-sufficient-statistic or recency-frequency
matrix, a good starting place would be
<code><a href="#topic+pnbd.EstimateParameters">pnbd.EstimateParameters</a></code>,
<code><a href="#topic+bgnbd.EstimateParameters">bgnbd.EstimateParameters</a></code>, or
<code><a href="#topic+bgbb.EstimateParameters">bgbb.EstimateParameters</a></code>.
</p>
<p>Following that, <code><a href="#topic+pnbd.PlotFrequencyInCalibration">pnbd.PlotFrequencyInCalibration</a></code>,
<code><a href="#topic+bgnbd.PlotFrequencyInCalibration">bgnbd.PlotFrequencyInCalibration</a></code> and
<code><a href="#topic+bgbb.PlotFrequencyInCalibration">bgbb.PlotFrequencyInCalibration</a></code> will give a check that
the model fits the data in-sample. Further plotting functions,
comparing actual and expected results, are labelled
&quot;pnbd.Plot...&quot;, &quot;bgnbd.Plot...&quot; and &quot;bgbb.Plot...&quot;.
The building blocks of these functions are also provided:
<code><a href="#topic+pnbd.LL">pnbd.LL</a></code>, <code><a href="#topic+bgnbd.LL">bgnbd.LL</a></code>
<code><a href="#topic+bgbb.LL">bgbb.LL</a></code>, <code><a href="#topic+pnbd.pmf">pnbd.pmf</a></code>,
<code><a href="#topic+bgnbd.pmf">bgnbd.pmf</a></code>, <code><a href="#topic+bgbb.pmf">bgbb.pmf</a></code>,
<code><a href="#topic+pnbd.Expectation">pnbd.Expectation</a></code>, <code><a href="#topic+bgnbd.Expectation">bgnbd.Expectation</a></code>,
<code><a href="#topic+bgbb.Expectation">bgbb.Expectation</a></code>,
<code><a href="#topic+pnbd.ConditionalExpectedTransactions">pnbd.ConditionalExpectedTransactions</a></code>,
<code><a href="#topic+bgnbd.ConditionalExpectedTransactions">bgnbd.ConditionalExpectedTransactions</a></code>, and
<code><a href="#topic+bgbb.ConditionalExpectedTransactions">bgbb.ConditionalExpectedTransactions</a></code> may be of
particular interest.
</p>
<p>This package uses the following conventions:
</p>
<p>The time period used to estimate the model parameters is called the
<em>calibration period</em>. Users may be accustomed to this being
called the estimation period, or simply being referred to as
&quot;in-sample&quot;. Function parameter names generally follow this
convention: for example, &quot;n.cal&quot; is used to refer to the number
of transaction opportunities in the calibration period.
</p>
<p>The time period used to validate model performance is called the
<em>holdout period</em>. Users may be accustomed to this being called
the validation period, or simply being referred to as
&quot;out-of-sample&quot;. Function parameters relating to this time
period are generally appended with &quot;.star&quot;. For example, n.star
is used to refer to the number of transaction opportunities in the
holdout period.
</p>
<p>As described in the papers referenced below, the BG/BB, BG/NBD and
Pareto/NBD   models are generally concerned with repeat transactions,
not total transactions. This means that a customer's first transaction
in the   calibration period is usually not part of the data being
modeled - this is due to the fact that a new customer generally does
not show up &quot;on the company's radar&quot; until after their first
purchase has taken place. This means that the modal number of repeat
purchases tends to be zero. If your data does not have a relatively large
number of customers with zero transactions, but does have a relatively large
number of customers with one transaction, and the estimation functions
are struggling, the problem is most likely that you are including
customers' very first transactions. Some of the data-conversion
functions have examples illustrating how to work with data that
includes this very first transaction. Note that this does not apply to
the holdout period; in the holdout period, we already know about the
customer and take all of their previous transactions into account.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Gabi Huiber <a href="mailto:ghuiber@gmail.com">ghuiber@gmail.com</a> [contributor]
</p>
<p>Authors:
</p>

<ul>
<li><p> Lukasz Dziurzynski
</p>
</li>
<li><p> Edward Wadsworth
</p>
</li>
<li><p> Daniel McCarthy [contributor]
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Peter Fader [contributor]
</p>
</li>
<li><p> Elea McDonnell Feit [contributor]
</p>
</li>
<li><p> Bruce Hardie [contributor]
</p>
</li>
<li><p> Arun Gopalakrishnan [contributor]
</p>
</li>
<li><p> Eric Schwartz [contributor]
</p>
</li>
<li><p> Yao Zhang [contributor]
</p>
</li></ul>



<h3>References</h3>

<p>See <a href="https://www.brucehardie.com">https://www.brucehardie.com</a> for papers, notes, and datasets relating to applied probability models in marketing.
</p>
<p>Fader, Peter S., and Bruce G.S. Hardie. &ldquo;A Note on Deriving the Pareto/NBD Model and Related Expressions.&rdquo; November. 2005. Web. <a href="http://www.brucehardie.com/notes/008/">http://www.brucehardie.com/notes/008/</a>
</p>
<p>Fader, Peter S., Bruce G.S. Hardie, and Ka L. Lee. &ldquo;RFM and CLV: Using Iso-Value Curves for Customer Base Analysis.&rdquo; <em>Journal of Marketing Research</em> Vol.42, pp.415-430. November. 2005. <a href="http://www.brucehardie.com/papers.html">http://www.brucehardie.com/papers.html</a>
</p>
<p>Fader, Peter S., and Bruce G.S. Hardie. &ldquo;Deriving an Expression for P (X(t) = x) Under the Pareto/NBD Model.&rdquo; September. 2006. Web. <a href="http://www.brucehardie.com/notes/012/">http://www.brucehardie.com/notes/012/</a>
</p>
<p>Fader, Peter S., and Bruce G.S. Hardie. &ldquo;Creating an RFM summary using Excel.&rdquo; December. 2008. Web. <a href="http://www.brucehardie.com/notes/022/">http://www.brucehardie.com/notes/022/</a>
</p>
<p>Fader, Peter S., Bruce G.S. Hardie, and Jen Shang. &ldquo;Customer-Base Analysis in a Discrete-Time Noncontractual Setting.&rdquo; <em>Marketing Science</em> 29(6), pp. 1086-1108. 2010. INFORMS. <a href="http://www.brucehardie.com/papers/020/">http://www.brucehardie.com/papers/020/</a>
</p>
<p>Jerath, Kinshuk, Peter S. Fader, and Bruce G.S. Hardie. &ldquo;Customer-Base Analysis on a 'Data Diet': Model Inference Using Repeated Cross-Sectional Summary (RCSS) Data.&rdquo; June. 2011. Available at SSRN: <a href="https://papers.ssrn.com/sol3/papers.cfm?abstract_id=1708562">https://papers.ssrn.com/sol3/papers.cfm?abstract_id=1708562</a> or doi: <a href="https://doi.org/10.2139/ssrn.1708562">10.2139/ssrn.1708562</a>
</p>
<p>Fader, Peter S., Bruce G.S. Hardie, and Ka L. Lee. &ldquo;&ldquo;Counting Your Customers&rdquo; the Easy Way: An Alternative to the Pareto/NBD Model.&rdquo; <em>Marketing Science</em> Vol.24, pp.275-284. Spring. 2005. <a href="http://www.brucehardie.com/papers.html">http://www.brucehardie.com/papers.html</a>
</p>
<p>Fader, Peter S., Hardie, Bruce G.S., and Lee, Ka Lok. &ldquo;Computing P(alive) Using the BG/NBD Model.&rdquo; December. 2008. Web. <a href="http://www.brucehardie.com/notes/021/palive_for_BGNBD.pdf">http://www.brucehardie.com/notes/021/palive_for_BGNBD.pdf</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li><p> Report bugs at <a href="https://github.com/ghuiber/BTYD/issues">https://github.com/ghuiber/BTYD/issues</a>
</p>
</li></ul>


<hr>
<h2 id='addLogs'>Add Logs</h2><span id='topic+addLogs'></span>

<h3>Description</h3>

<p>Given log(a) and log(b), returns log(a + b)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addLogs(loga, logb)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addLogs_+3A_loga">loga</code></td>
<td>
<p>first number in log space.</p>
</td></tr>
<tr><td><code id="addLogs_+3A_logb">logb</code></td>
<td>
<p>first number in log space.</p>
</td></tr>
</table>

<hr>
<h2 id='bgbb.ConditionalExpectedTransactions'>BG/BB Conditional Expected Transactions</h2><span id='topic+bgbb.ConditionalExpectedTransactions'></span>

<h3>Description</h3>

<p>Calculates the number of expected transactions in the holdout period,
conditional on a customer's behavior in the calibration period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bgbb.ConditionalExpectedTransactions(params, n.cal, n.star, x, t.x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bgbb.ConditionalExpectedTransactions_+3A_params">params</code></td>
<td>
<p>BG/BB parameters - a vector with alpha, beta, gamma, and
delta, in that order. Alpha and beta are unobserved parameters for the
beta-Bernoulli transaction process. Gamma and delta are unobserved
parameters for the beta-geometric dropout process.</p>
</td></tr>
<tr><td><code id="bgbb.ConditionalExpectedTransactions_+3A_n.cal">n.cal</code></td>
<td>
<p>number of transaction opportunities in the calibration
period. Can also be a vector of calibration period transaction
opportunities - see details.</p>
</td></tr>
<tr><td><code id="bgbb.ConditionalExpectedTransactions_+3A_n.star">n.star</code></td>
<td>
<p>number of transaction opportunities in the holdout period, or a
vector of holdout period transaction opportunities.</p>
</td></tr>
<tr><td><code id="bgbb.ConditionalExpectedTransactions_+3A_x">x</code></td>
<td>
<p>the number of repeat transactions made by the customer in the
calibration period. Can also be vector of frequencies - see details.</p>
</td></tr>
<tr><td><code id="bgbb.ConditionalExpectedTransactions_+3A_t.x">t.x</code></td>
<td>
<p>recency - the transaction opportunity in which the customer made
their last transaction. Can also be a vector of recencies - see details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>E(X(n, n+n*) | alpha, beta, gamma, delta, x, t.x, n). This function requires
the holdout period to immediately follow the calibration period.
</p>
<p><code>n.cal</code>, <code>n.star</code>, <code>x</code>, and <code>t.x</code> may be vectors. The standard rules for
vector operations apply - if they are not of the same length, shorter vectors
will be recycled (start over at the first element) until they are as long as
the longest vector. It is advisable to keep vectors to the same length and to
use single values for parameters that are to be the same for all
calculations. If one of these parameters has a length greater than one, the
output will be a vector of probabilities.
</p>


<h3>Value</h3>

<p>The number of transactions a customer is expected to make in the
<code>n.star</code> transaction opportunities following the calibration period,
conditional on their behavior during the calibration period.
</p>


<h3>References</h3>

<p>Fader, Peter S., Bruce G.S. Hardie, and Jen Shang.
&quot;Customer-Base Analysis in a Discrete-Time Noncontractual Setting.&quot;
<em>Marketing Science</em> 29(6), pp. 1086-1108. 2010. INFORMS.
<a href="http://www.brucehardie.com/papers/020/">Web.</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
params &lt;- c(1.20, 0.75, 0.66, 2.78)
# the number of transactions a customer is expected
# to make in the 10 transaction opportunities
# following the calibration period, which consisted
# of 6 transaction opportunities (during which they
# made 3 transactions, the last of which occurred
# in the 4th opportunity)
bgbb.ConditionalExpectedTransactions(params, n.cal=6, n.star=10, x=3, t.x=4)

# We can also use vectors as input:
bgbb.ConditionalExpectedTransactions(params, n.cal=6, n.star=1:10, x=3, t.x=4)
bgbb.ConditionalExpectedTransactions(params, n.cal=6, n.star=10, x=1:4, t.x=4)
</code></pre>

<hr>
<h2 id='bgbb.DERT'>BG/BB Discounted Expected Residual Transactions</h2><span id='topic+bgbb.DERT'></span>

<h3>Description</h3>

<p>Computes the number of discounted expected residual transactions by a
customer, conditional on their behavior in the calibration period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bgbb.DERT(params, x, t.x, n.cal, d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bgbb.DERT_+3A_params">params</code></td>
<td>
<p>BG/BB parameters - a vector with alpha, beta, gamma, and
delta, in that order. Alpha and beta are unobserved parameters for the
beta-Bernoulli transaction process. Gamma and delta are unobserved
parameters for the beta-geometric dropout process.</p>
</td></tr>
<tr><td><code id="bgbb.DERT_+3A_x">x</code></td>
<td>
<p>the number of repeat transactions made by the customer in the
calibration period. Can also be vector of frequencies - see details.</p>
</td></tr>
<tr><td><code id="bgbb.DERT_+3A_t.x">t.x</code></td>
<td>
<p>recency - the transaction opportunity in which the customer made
their last transaction. Can also be a vector of recencies - see details.</p>
</td></tr>
<tr><td><code id="bgbb.DERT_+3A_n.cal">n.cal</code></td>
<td>
<p>number of transaction opportunities in the calibration
period. Can also be a vector of calibration period transaction
opportunities - see details.</p>
</td></tr>
<tr><td><code id="bgbb.DERT_+3A_d">d</code></td>
<td>
<p>discount rate.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>DERT(d | alpha, beta, gamma, delta, x, t.x, n). This is the present value of
the expected future transaction stream for a customer with x transactions and
a recency of t.x in n.cal transaction opportunities, discounted by a rate d.
</p>
<p><code>x</code>, <code>t.x</code>, and <code>n.cal</code> may be vectors. The standard rules for vector
operations apply - if they are not of the same length, shorter vectors will
be recycled (start over at the first element) until they are as long as the
longest vector. It is advisable to keep vectors to the same length and to use
single values for parameters that are to be the same for all calculations. If
one of these parameters has a length greater than one, the output will be
also be a vector.
</p>


<h3>Value</h3>

<p>The present value of the expected future transaction stream for a particular customer.
</p>


<h3>References</h3>

<p>Fader, Peter S., Bruce G.S. Hardie, and Jen Shang.
&quot;Customer-Base Analysis in a Discrete-Time Noncontractual Setting.&quot;
<em>Marketing Science</em> 29(6), pp. 1086-1108. 2010. INFORMS.
<a href="http://www.brucehardie.com/papers/020/">Web.</a>
See equation 14.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>params &lt;- c(1.20, 0.75, 0.66, 2.78)
# Compute DERT for a customer who made 3 transactions
# in the calibration period(consisting of 6 transaction
# opportunities), with the last transaction occurring
# during the 4th transaction opportunity, discounted at
# 10%.
bgbb.DERT(params, x=3, t.x=4, n.cal=6, d=0.1)

# We can also compare DERT for several customers:
bgbb.DERT(params, x=1:6, t.x=6, n.cal=6, d=0.1)
</code></pre>

<hr>
<h2 id='bgbb.EstimateParameters'>BG/BB Parameter estimation</h2><span id='topic+bgbb.EstimateParameters'></span>

<h3>Description</h3>

<p>Estimates parameters for the BG/BB model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bgbb.EstimateParameters(
  rf.matrix,
  par.start = c(1, 1, 1, 1),
  max.param.value = 1000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bgbb.EstimateParameters_+3A_rf.matrix">rf.matrix</code></td>
<td>
<p>recency-frequency matrix. It must contain columns for
frequency (&quot;x&quot;), recency (&quot;t.x&quot;), number of transaction opportunities in
the calibration period (&quot;n.cal&quot;), and the number of customers with this
combination of recency, frequency and transaction opportunities in the
calibration period (&quot;custs&quot;). Note that recency must be the time between
the start of the calibration period and the customer's last transaction,
not the time between the customer's last transaction and the end of the
calibration period.</p>
</td></tr>
<tr><td><code id="bgbb.EstimateParameters_+3A_par.start">par.start</code></td>
<td>
<p>initial BG/BB parameters - a vector with alpha, beta, gamma,
and delta, in that order. Alpha and beta are unobserved parameters for the
beta-Bernoulli transaction process. Gamma and delta are unobserved
parameters for the beta-geometric dropout process.</p>
</td></tr>
<tr><td><code id="bgbb.EstimateParameters_+3A_max.param.value">max.param.value</code></td>
<td>
<p>the upper bound on parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The best-fitting parameters are determined using the <code><a href="#topic+bgbb.rf.matrix.LL">bgbb.rf.matrix.LL</a></code>
function. The sum of the log-likelihood for each customer (for a set of
parameters) is maximized in order to estimate paramaters.
</p>
<p>A set of starting parameters must be provided for this method. If no
parameters are provided, (1,1,1,1) is used as a default. It may be useful to
use starting values for parameters that represent your best guess of the
heterogeneity in the transaction and dropout rates of customers. It may be
necessary to run the estimation from multiple starting points to ensure that
it converges. To compare the log-likelihoods of different parameters, use
<code><a href="#topic+bgbb.rf.matrix.LL">bgbb.rf.matrix.LL</a></code>.
</p>
<p>The lower bound on the parameters to be estimated is always zero, since BG/BB
parameters cannot be negative. The upper bound can be set with the
max.param.value parameter.
</p>


<h3>Value</h3>

<p>Vector of estimated paramaters.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bgbb.rf.matrix.LL">bgbb.rf.matrix.LL</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(donationsSummary)

rf.matrix &lt;- donationsSummary$rf.matrix
# donationsSummary$rf.matrix already has appropriate column names

# starting-point parameters
startingparams &lt;- c(1, 1, 0.5, 3)
# estimated parameters
est.params &lt;- bgbb.EstimateParameters(rf.matrix, startingparams)
# log-likelihood of estimated parameters
bgbb.rf.matrix.LL(est.params, rf.matrix)
</code></pre>

<hr>
<h2 id='bgbb.Expectation'>BG/BB Expectation</h2><span id='topic+bgbb.Expectation'></span>

<h3>Description</h3>

<p>Returns the number of transactions that a randomly chosen customer (for whom
we have no prior information) is expected to make in the first n transaction
opportunities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bgbb.Expectation(params, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bgbb.Expectation_+3A_params">params</code></td>
<td>
<p>BG/BB parameters - a vector with alpha, beta, gamma, and delta,
in that order. Alpha and beta are unobserved parameters for the
beta-Bernoulli transaction process. Gamma and delta are unobserved
parameters for the beta-geometric dropout process.</p>
</td></tr>
<tr><td><code id="bgbb.Expectation_+3A_n">n</code></td>
<td>
<p>number of transaction opportunities; may also be a vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>E(X(n) | alpha, beta, gamma, delta)
</p>


<h3>Value</h3>

<p>Mean of the BG/BB probability mass function.
</p>


<h3>References</h3>

<p>Fader, Peter S., Bruce G.S. Hardie, and Jen Shang.
&quot;Customer-Base Analysis in a Discrete-Time Noncontractual Setting.&quot;
<em>Marketing Science</em> 29(6), pp. 1086-1108. 2010. INFORMS.
<a href="http://www.brucehardie.com/papers/020/">Web.</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>params &lt;- c(1.20, 0.75, 0.66, 2.78)
# Expected number of transactions that a randomly chosen customer
# will make in the first 10 transaction opportunities.
bgbb.Expectation(params, n=10)

# We can also compare expected transactions over time:
bgbb.Expectation(params, n=1:10)
</code></pre>

<hr>
<h2 id='bgbb.HeatmapHoldoutExpectedTrans'>BG/BB Heatmap of Holdout Period Expected Transactions</h2><span id='topic+bgbb.HeatmapHoldoutExpectedTrans'></span>

<h3>Description</h3>

<p>Plots a heatmap based on the conditional expected holdout period frequency
for each recency-frequency combination in the calibration period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bgbb.HeatmapHoldoutExpectedTrans(
  params,
  n.cal,
  n.star,
  xlab = "Recency",
  ylab = "Frequency",
  xticklab = NULL,
  title = "Heatmap of Conditional Expected Transactions"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bgbb.HeatmapHoldoutExpectedTrans_+3A_params">params</code></td>
<td>
<p>BG/BB parameters - a vector with alpha, beta, gamma, and delta,
in that order. Alpha and beta are unobserved parameters for the
beta-Bernoulli transaction process. Gamma and delta are unobserved
parameters for the beta-geometric dropout process.</p>
</td></tr>
<tr><td><code id="bgbb.HeatmapHoldoutExpectedTrans_+3A_n.cal">n.cal</code></td>
<td>
<p>number of transaction opportunities in the calibration period.</p>
</td></tr>
<tr><td><code id="bgbb.HeatmapHoldoutExpectedTrans_+3A_n.star">n.star</code></td>
<td>
<p>number of transaction opportunities in the holdout period.</p>
</td></tr>
<tr><td><code id="bgbb.HeatmapHoldoutExpectedTrans_+3A_xlab">xlab</code></td>
<td>
<p>descriptive label for the x axis.</p>
</td></tr>
<tr><td><code id="bgbb.HeatmapHoldoutExpectedTrans_+3A_ylab">ylab</code></td>
<td>
<p>descriptive label for the y axis.</p>
</td></tr>
<tr><td><code id="bgbb.HeatmapHoldoutExpectedTrans_+3A_xticklab">xticklab</code></td>
<td>
<p>vector containing a label for each tick mark on the x axis.</p>
</td></tr>
<tr><td><code id="bgbb.HeatmapHoldoutExpectedTrans_+3A_title">title</code></td>
<td>
<p>title placed on the top-center of the plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>E(X(n, n+n*) | alpha, beta, gamma, delta, x, t.x, n). This function requires
the holdout period to immediately follow the calibration period.
</p>


<h3>Value</h3>

<p>A matrix containing the conditional expected transactions in the
holdout period for each recency-frequency combination in the calibration
period. The rows represent calibration period frequencies, and the columns
represent calibration period recencies.
</p>


<h3>References</h3>

<p>Fader, Peter S., Bruce G.S. Hardie, and Jen Shang.
&quot;Customer-Base Analysis in a Discrete-Time Noncontractual Setting.&quot;
<em>Marketing Science</em> 29(6), pp. 1086-1108. 2010. INFORMS.
<a href="http://www.brucehardie.com/papers/020/">Web.</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bgbb.ConditionalExpectedTransactions">bgbb.ConditionalExpectedTransactions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(donationsSummary)

rf.matrix &lt;- donationsSummary$rf.matrix
# donationsSummary$rf.matrix already has appropriate column names

# starting-point parameters
startingparams &lt;- c(1, 1, 0.5, 3)
# estimated parameters
est.params &lt;- bgbb.EstimateParameters(rf.matrix, startingparams)

# Plot a heatmap of conditional expected transactions in
# a holdout period of 5 transaction opportunities, given
# that the calibration period consisted of 6 transaction
# opportunities.
bgbb.HeatmapHoldoutExpectedTrans(est.params, n.cal=6, n.star=5)
</code></pre>

<hr>
<h2 id='bgbb.LL'>BG/BB Log-Likelihood</h2><span id='topic+bgbb.LL'></span>

<h3>Description</h3>

<p>Calculates the log-likelihood of the BG/BB model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bgbb.LL(params, x, t.x, n.cal)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bgbb.LL_+3A_params">params</code></td>
<td>
<p>BG/BB parameters - a vector with alpha, beta, gamma, and
delta, in that order. Alpha and beta are unobserved parameters for the
beta-Bernoulli transaction process. Gamma and delta are unobserved
parameters for the beta-geometric dropout process.</p>
</td></tr>
<tr><td><code id="bgbb.LL_+3A_x">x</code></td>
<td>
<p>the number of repeat transactions made by the customer in the
calibration period. Can also be vector of frequencies - see details.</p>
</td></tr>
<tr><td><code id="bgbb.LL_+3A_t.x">t.x</code></td>
<td>
<p>recency - the transaction opportunity in which the customer made
their last transaction. Can also be a vector of recencies - see details.</p>
</td></tr>
<tr><td><code id="bgbb.LL_+3A_n.cal">n.cal</code></td>
<td>
<p>number of transaction opportunities in the calibration
period. Can also be a vector of calibration period transaction
opportunities - see details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>x, t.x, and n.cal may be vectors. The standard rules for vector operations
apply - if they are not of the same length, shorter vectors will be recycled
(start over at the first element) until they are as long as the longest
vector. It is advisable to keep vectors to the same length and to use single
values for parameters that are to be the same for all calculations. If one of
these parameters has a length greater than one, the output will be also be a
vector.
</p>


<h3>Value</h3>

<p>A vector of log-likelihoods as long as the longest input vector (x,
t.x, or n.cal).
</p>


<h3>References</h3>

<p>Fader, Peter S., Bruce G.S. Hardie, and Jen Shang.
&quot;Customer-Base Analysis in a Discrete-Time Noncontractual Setting.&quot;
<em>Marketing Science</em> 29(6), pp. 1086-1108. 2010. INFORMS.
<a href="http://www.brucehardie.com/papers/020/">Web.</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>params &lt;- c(1.20, 0.75, 0.66, 2.78)

# Returns the log likelihood of the parameters for a customer who
# made 3 transactions in a calibration period with 6 transaction opportunities,
# with the last transaction occurring during the 4th transaction opportunity.
bgbb.LL(params, x=3, t.x=4, n.cal=6)

# We can also give vectors as function parameters:
set.seed(7)
x &lt;- sample(1:3, 10, replace = TRUE)
t.x &lt;- sample(3:5, 10, replace = TRUE)
n.cal &lt;- rep(5, 10)
bgbb.LL(params, x, t.x, n.cal)  
</code></pre>

<hr>
<h2 id='bgbb.PAlive'>BG/BB P(Alive)</h2><span id='topic+bgbb.PAlive'></span>

<h3>Description</h3>

<p>Uses BG/BB model parameters and a customer's past transaction behavior to
return the probability that they will be alive in the transaction opportunity
following the calibration period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bgbb.PAlive(params, x, t.x, n.cal)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bgbb.PAlive_+3A_params">params</code></td>
<td>
<p>BG/BB parameters - a vector with alpha, beta, gamma, and
delta, in that order. Alpha and beta are unobserved parameters for the
beta-Bernoulli transaction process. Gamma and delta are unobserved
parameters for the beta-geometric dropout process.</p>
</td></tr>
<tr><td><code id="bgbb.PAlive_+3A_x">x</code></td>
<td>
<p>the number of repeat transactions made by the customer in the
calibration period. Can also be vector of frequencies - see details.</p>
</td></tr>
<tr><td><code id="bgbb.PAlive_+3A_t.x">t.x</code></td>
<td>
<p>recency - the transaction opportunity in which the customer made
their last transaction. Can also be a vector of recencies - see details.</p>
</td></tr>
<tr><td><code id="bgbb.PAlive_+3A_n.cal">n.cal</code></td>
<td>
<p>number of transaction opportunities in the calibration
period. Can also be a vector of calibration period transaction
opportunities - see details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>x</code>, <code>t.x</code>, and <code>n.cal</code> may be vectors. The standard rules for vector
operations apply - if they are not of the same length, shorter vectors will
be recycled (start over at the first element) until they are as long as the
longest vector. It is advisable to keep vectors to the same length and to use
single values for parameters that are to be the same for all calculations. If
one of these parameters has a length greater than one, the output will be a
vector of probabilities.
</p>
<p>P(alive at n+1 | alpha, beta, gamma, delta, x, t.x, n)
</p>


<h3>Value</h3>

<p>Probability that the customer is alive at the (n+1)th transaction
opportunity. If <code>x</code>, <code>t.x</code>, and/or <code>n.cal</code> are of length greater than one,
then this will be a vector of probabilities (containing one element
matching each element of the longest input vector).
</p>


<h3>References</h3>

<p>Fader, Peter S., Bruce G.S. Hardie, and Jen Shang.
&quot;Customer-Base Analysis in a Discrete-Time Noncontractual Setting.&quot;
<em>Marketing Science</em> 29(6), pp. 1086-1108. 2010. INFORMS.
<a href="http://www.brucehardie.com/papers/020/">Web.</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>params &lt;- c(1.20, 0.75, 0.66, 2.78)

# The probability that a customer who made 3 transactions in
# the calibration period (which consisted of 6 transaction
# opportunities), with the last transaction occurring at the
# 4th transaction opportunity, is alive at the 7th transaction
# opportunity
bgbb.PAlive(params, x=3, t.x=4, n.cal=6)

# The input parameters may also be vectors:
bgbb.PAlive(params, x=1, t.x=1:6, n.cal=6)
</code></pre>

<hr>
<h2 id='bgbb.PlotDropoutRateHeterogeneity'>BG/BB Plot Dropout Rate Heterogeneity</h2><span id='topic+bgbb.PlotDropoutRateHeterogeneity'></span>

<h3>Description</h3>

<p>Plots and returns the estimated beta distribution of Theta (customers' propensities to drop out).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bgbb.PlotDropoutRateHeterogeneity(params)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bgbb.PlotDropoutRateHeterogeneity_+3A_params">params</code></td>
<td>
<p>BG/BB parameters - a vector with alpha, beta, gamma, and delta,
in that order. Alpha and beta are unobserved parameters for the
beta-Bernoulli transaction process. Gamma and delta are unobserved
parameters for the beta-geometric dropout process.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This returns the distribution of each customer's geometric parameter that determines their lifetime (using the BG/BB assumption that a customer's lifetime can be modeled with a geometric distribution).
</p>


<h3>Value</h3>

<p>Distribution of customers' propensities to drop out.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>params &lt;- c(1.2, 0.75, 0.66, 2.78)
bgbb.PlotDropoutRateHeterogeneity(params)
params &lt;- c(0.2, 1.5, 3.2, 6)
bgbb.PlotDropoutRateHeterogeneity(params)
</code></pre>

<hr>
<h2 id='bgbb.PlotFrequencyInCalibration'>BG/BB Plot Frequency in Calibration Period</h2><span id='topic+bgbb.PlotFrequencyInCalibration'></span>

<h3>Description</h3>

<p>Plots the actual and expected number of customers who made a certain number
of repeat transactions in the calibration period. Also returns a matrix with
this comparison.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bgbb.PlotFrequencyInCalibration(
  params,
  rf.matrix,
  censor = NULL,
  plotZero = TRUE,
  xlab = "Calibration period transactions",
  ylab = "Customers",
  title = "Frequency of Repeat Transactions"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bgbb.PlotFrequencyInCalibration_+3A_params">params</code></td>
<td>
<p>BG/BB parameters - a vector with alpha, beta, gamma, and delta,
in that order. Alpha and beta are unobserved parameters for the
beta-Bernoulli transaction process. Gamma and delta are unobserved
parameters for the beta-geometric dropout process.</p>
</td></tr>
<tr><td><code id="bgbb.PlotFrequencyInCalibration_+3A_rf.matrix">rf.matrix</code></td>
<td>
<p>recency-frequency matrix. It must contain columns for
frequency (&quot;x&quot;), recency (&quot;t.x&quot;), number of transaction opportunities in
the calibration period (&quot;n.cal&quot;), and the number of customers with this
combination of recency, frequency and transaction opportunities in the
calibration period (&quot;custs&quot;). Note that recency must be the time between
the start of the calibration period and the customer's last transaction,
not the time between the customer's last transaction and the end of the
calibration period.</p>
</td></tr>
<tr><td><code id="bgbb.PlotFrequencyInCalibration_+3A_censor">censor</code></td>
<td>
<p>optional. Any calibration period frequency at this number, or
above it, will be binned together. If the censor number is greater than the
maximum recency in the recency-frequency matrix, the maximum recency will
be used as the censor number.</p>
</td></tr>
<tr><td><code id="bgbb.PlotFrequencyInCalibration_+3A_plotzero">plotZero</code></td>
<td>
<p>If FALSE, the histogram will exclude the zero bin.</p>
</td></tr>
<tr><td><code id="bgbb.PlotFrequencyInCalibration_+3A_xlab">xlab</code></td>
<td>
<p>descriptive label for the x axis.</p>
</td></tr>
<tr><td><code id="bgbb.PlotFrequencyInCalibration_+3A_ylab">ylab</code></td>
<td>
<p>descriptive label for the y axis.</p>
</td></tr>
<tr><td><code id="bgbb.PlotFrequencyInCalibration_+3A_title">title</code></td>
<td>
<p>title placed on the top-center of the plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Calibration period repeat transaction frequency comparison matrix,
actual vs. expected.
</p>


<h3>References</h3>

<p>Fader, Peter S., Bruce G.S. Hardie, and Jen Shang.
&quot;Customer-Base Analysis in a Discrete-Time Noncontractual Setting.&quot;
<em>Marketing Science</em> 29(6), pp. 1086-1108. 2010. INFORMS.
<a href="http://www.brucehardie.com/papers/020/">Web.</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(donationsSummary)

rf.matrix &lt;- donationsSummary$rf.matrix
# donationsSummary$rf.matrix already has appropriate column names

# starting-point parameters
startingparams &lt;- c(1, 1, 0.5, 3)
# estimated parameters
est.params &lt;- bgbb.EstimateParameters(rf.matrix, startingparams)

# plot actual vs. expected frequencies in the calibration period
bgbb.PlotFrequencyInCalibration(est.params, rf.matrix)
</code></pre>

<hr>
<h2 id='bgbb.PlotFrequencyInHoldout'>BG/BB Plot Frequency in Holdout</h2><span id='topic+bgbb.PlotFrequencyInHoldout'></span>

<h3>Description</h3>

<p>Plots the actual and expected number of customers who made a certain number
of transactions in the holdout period, binned according to holdout period
frequencies. Also returns a matrix with this comparison and the number of
customers in each bin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bgbb.PlotFrequencyInHoldout(
  params,
  n.cal,
  rf.matrix.holdout,
  censor = NULL,
  plotZero = TRUE,
  title = "Frequency of Repeat Transactions",
  xlab = "Holdout period transactions",
  ylab = "Customers"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bgbb.PlotFrequencyInHoldout_+3A_params">params</code></td>
<td>
<p>BG/BB parameters - a vector with alpha, beta, gamma, and delta,
in that order. Alpha and beta are unobserved parameters for the
beta-Bernoulli transaction process. Gamma and delta are unobserved
parameters for the beta-geometric dropout process.</p>
</td></tr>
<tr><td><code id="bgbb.PlotFrequencyInHoldout_+3A_n.cal">n.cal</code></td>
<td>
<p>number of transaction opportunities in the calibration period.</p>
</td></tr>
<tr><td><code id="bgbb.PlotFrequencyInHoldout_+3A_rf.matrix.holdout">rf.matrix.holdout</code></td>
<td>
<p>holdout period recency-frequency matrix. It must
contain columns for frequency in the holdout period (&quot;x.star&quot;), the number
of transaction opportunities in the holdout period (&quot;n.star&quot;), and the
number of customers with each frequency (&quot;custs&quot;).</p>
</td></tr>
<tr><td><code id="bgbb.PlotFrequencyInHoldout_+3A_censor">censor</code></td>
<td>
<p>optional. Any calibration period frequency at this number, or
above it, will be binned together. If the censor number is greater than the
maximum recency in the recency-frequency matrix, the maximum recency will
be used as the censor number.</p>
</td></tr>
<tr><td><code id="bgbb.PlotFrequencyInHoldout_+3A_plotzero">plotZero</code></td>
<td>
<p>If FALSE, the histogram will exclude the zero bin.</p>
</td></tr>
<tr><td><code id="bgbb.PlotFrequencyInHoldout_+3A_title">title</code></td>
<td>
<p>title placed on the top-center of the plot.</p>
</td></tr>
<tr><td><code id="bgbb.PlotFrequencyInHoldout_+3A_xlab">xlab</code></td>
<td>
<p>descriptive label for the x axis.</p>
</td></tr>
<tr><td><code id="bgbb.PlotFrequencyInHoldout_+3A_ylab">ylab</code></td>
<td>
<p>descriptive label for the y axis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Holdout period repeat transaction frequency comparison matrix (actual vs. expected).
</p>


<h3>References</h3>

<p>Fader, Peter S., Bruce G.S. Hardie, and Jen Shang.
&quot;Customer-Base Analysis in a Discrete-Time Noncontractual Setting.&quot;
<em>Marketing Science</em> 29(6), pp. 1086-1108. 2010. INFORMS.
<a href="http://www.brucehardie.com/papers/020/">Web.</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(donationsSummary)

rf.matrix &lt;- donationsSummary$rf.matrix
rf.matrix.holdout &lt;- donationsSummary$rf.matrix.holdout
# donationsSummary$rf.matrix and donationsSummary$rf.matrix.holdout already
# have appropriate column names

# starting-point parameters
startingparams &lt;- c(1, 1, 0.5, 3)
# estimated parameters
est.params &lt;- bgbb.EstimateParameters(rf.matrix, startingparams)

# number of periods in the calibration period
n.cal = max(rf.matrix[,"n.cal"])

bgbb.PlotFrequencyInHoldout(est.params, n.cal, rf.matrix.holdout)
</code></pre>

<hr>
<h2 id='bgbb.PlotFreqVsConditionalExpectedFrequency'>BG/BB Plot Frequency vs Conditional Expected Frequency</h2><span id='topic+bgbb.PlotFreqVsConditionalExpectedFrequency'></span>

<h3>Description</h3>

<p>Plots the actual and conditional expected number of transactions made by
customers in the holdout period, binned according to calibration period
frequencies. Also returns a matrix with this comparison and the number of
customers in each bin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bgbb.PlotFreqVsConditionalExpectedFrequency(
  params,
  n.star,
  rf.matrix,
  x.star,
  trunc = NULL,
  xlab = "Calibration period transactions",
  ylab = "Holdout period transactions",
  xticklab = NULL,
  title = "Conditional Expectation"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bgbb.PlotFreqVsConditionalExpectedFrequency_+3A_params">params</code></td>
<td>
<p>BG/BB parameters - a vector with alpha, beta, gamma, and delta,
in that order. Alpha and beta are unobserved parameters for the
beta-Bernoulli transaction process. Gamma and delta are unobserved
parameters for the beta-geometric dropout process.</p>
</td></tr>
<tr><td><code id="bgbb.PlotFreqVsConditionalExpectedFrequency_+3A_n.star">n.star</code></td>
<td>
<p>number of transaction opportunities in the holdout period.</p>
</td></tr>
<tr><td><code id="bgbb.PlotFreqVsConditionalExpectedFrequency_+3A_rf.matrix">rf.matrix</code></td>
<td>
<p>recency-frequency matrix. It must contain columns for
frequency (&quot;x&quot;), recency (&quot;t.x&quot;), number of transaction opportunities in
the calibration period (&quot;n.cal&quot;), and the number of customers with this
combination of recency, frequency and transaction opportunities in the
calibration period (&quot;custs&quot;). Note that recency must be the time between
the start of the calibration period and the customer's last transaction,
not the time between the customer's last transaction and the end of the
calibration period.</p>
</td></tr>
<tr><td><code id="bgbb.PlotFreqVsConditionalExpectedFrequency_+3A_x.star">x.star</code></td>
<td>
<p>a vector containing the number of transactions made in the
holdout period by the groups of customers with the same recency and
frequency in the calibration period. It must be in the same order as the
rf.matrix.</p>
</td></tr>
<tr><td><code id="bgbb.PlotFreqVsConditionalExpectedFrequency_+3A_trunc">trunc</code></td>
<td>
<p>optional integer used to truncate the plot. In the plot, all
calibration period frequencies above the truncation number will be removed.
If the truncation number is greater than the maximum frequency, R will warn
you and change it to the maximum frequency.</p>
</td></tr>
<tr><td><code id="bgbb.PlotFreqVsConditionalExpectedFrequency_+3A_xlab">xlab</code></td>
<td>
<p>descriptive label for the x axis.</p>
</td></tr>
<tr><td><code id="bgbb.PlotFreqVsConditionalExpectedFrequency_+3A_ylab">ylab</code></td>
<td>
<p>descriptive label for the y axis.</p>
</td></tr>
<tr><td><code id="bgbb.PlotFreqVsConditionalExpectedFrequency_+3A_xticklab">xticklab</code></td>
<td>
<p>vector containing a label for each tick mark on the x axis.</p>
</td></tr>
<tr><td><code id="bgbb.PlotFreqVsConditionalExpectedFrequency_+3A_title">title</code></td>
<td>
<p>title placed on the top-center of the plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Holdout period transaction frequency comparison matrix (actual vs.
expected), binned by calibration period frequency.
</p>


<h3>References</h3>

<p>Fader, Peter S., Bruce G.S. Hardie, and Jen Shang.
&quot;Customer-Base Analysis in a Discrete-Time Noncontractual Setting.&quot;
<em>Marketing Science</em> 29(6), pp. 1086-1108. 2010. INFORMS.
<a href="http://www.brucehardie.com/papers/020/">Web.</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(donationsSummary)

rf.matrix &lt;- donationsSummary$rf.matrix
# donationsSummary$rf.matrix already has appropriate column names

# starting-point parameters
startingparams &lt;- c(1, 1, 0.5, 3)
# estimated parameters
est.params &lt;- bgbb.EstimateParameters(rf.matrix, startingparams)

# get the holdout period transactions
x.star &lt;- donationsSummary$x.star

# number of transaction opportunities in the holdout period
n.star &lt;- 5

# Plot holdout period transactions
bgbb.PlotFreqVsConditionalExpectedFrequency(est.params, n.star, rf.matrix, x.star, trunc=6)
</code></pre>

<hr>
<h2 id='bgbb.PlotRecVsConditionalExpectedFrequency'>BG/BB Plot Recency vs Conditional Expected Frequency</h2><span id='topic+bgbb.PlotRecVsConditionalExpectedFrequency'></span>

<h3>Description</h3>

<p>Plots the actual and conditional expected number of transactions made by
customers in the holdout period, binned according to calibration period
recencies. Also returns a matrix with this comparison and the number of
customers in each bin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bgbb.PlotRecVsConditionalExpectedFrequency(
  params,
  n.star,
  rf.matrix,
  x.star,
  trunc = NULL,
  xlab = "Calibration period recency",
  ylab = "Holdout period transactions",
  xticklab = NULL,
  title = "Conditional Expected Transactions by Recency"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bgbb.PlotRecVsConditionalExpectedFrequency_+3A_params">params</code></td>
<td>
<p>BG/BB parameters - a vector with alpha, beta, gamma, and delta,
in that order. Alpha and beta are unobserved parameters for the
beta-Bernoulli transaction process. Gamma and delta are unobserved
parameters for the beta-geometric dropout process.</p>
</td></tr>
<tr><td><code id="bgbb.PlotRecVsConditionalExpectedFrequency_+3A_n.star">n.star</code></td>
<td>
<p>number of transaction opportunities in the holdout period.</p>
</td></tr>
<tr><td><code id="bgbb.PlotRecVsConditionalExpectedFrequency_+3A_rf.matrix">rf.matrix</code></td>
<td>
<p>recency-frequency matrix. It must contain columns for
frequency (&quot;x&quot;), recency (&quot;t.x&quot;), number of transaction opportunities in
the calibration period (&quot;n.cal&quot;), and the number of customers with this
combination of recency, frequency and transaction opportunities in the
calibration period (&quot;custs&quot;). Note that recency must be the time between
the start of the calibration period and the customer's last transaction,
not the time between the customer's last transaction and the end of the
calibration period.</p>
</td></tr>
<tr><td><code id="bgbb.PlotRecVsConditionalExpectedFrequency_+3A_x.star">x.star</code></td>
<td>
<p>a vector containing the number of transactions made in the
holdout period by the groups of customers with the same recency and
frequency in the calibration period. It must be in the same order as the
rf.matrix.</p>
</td></tr>
<tr><td><code id="bgbb.PlotRecVsConditionalExpectedFrequency_+3A_trunc">trunc</code></td>
<td>
<p>optional integer used to truncate the plot. In the plot, all
calibration period frequencies above the truncation number will be removed.
If the truncation number is greater than the maximum frequency, R will warn
you and change it to the maximum frequency.</p>
</td></tr>
<tr><td><code id="bgbb.PlotRecVsConditionalExpectedFrequency_+3A_xlab">xlab</code></td>
<td>
<p>descriptive label for the x axis.</p>
</td></tr>
<tr><td><code id="bgbb.PlotRecVsConditionalExpectedFrequency_+3A_ylab">ylab</code></td>
<td>
<p>descriptive label for the y axis.</p>
</td></tr>
<tr><td><code id="bgbb.PlotRecVsConditionalExpectedFrequency_+3A_xticklab">xticklab</code></td>
<td>
<p>vector containing a label for each tick mark on the x axis.</p>
</td></tr>
<tr><td><code id="bgbb.PlotRecVsConditionalExpectedFrequency_+3A_title">title</code></td>
<td>
<p>title placed on the top-center of the plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Holdout period transaction frequency comparison matrix (actual vs.
expected), binned by calibration period recency.
</p>


<h3>References</h3>

<p>Fader, Peter S., Bruce G.S. Hardie, and Jen Shang.
&quot;Customer-Base Analysis in a Discrete-Time Noncontractual Setting.&quot;
<em>Marketing Science</em> 29(6), pp. 1086-1108. 2010. INFORMS.
<a href="http://www.brucehardie.com/papers/020/">Web.</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(donationsSummary)

rf.matrix &lt;- donationsSummary$rf.matrix
# donationsSummary$rf.matrix already has appropriate column names

# starting-point parameters
startingparams &lt;- c(1, 1, 0.5, 3)
# estimated parameters
est.params &lt;- bgbb.EstimateParameters(rf.matrix, startingparams)

# get the holdout period transactions
x.star &lt;- donationsSummary$x.star

# number of transaction opportunities in the holdout period
n.star &lt;- 5

# Compare holdout period transactions.
bgbb.PlotRecVsConditionalExpectedFrequency(est.params, n.star, rf.matrix, x.star, trunc=6)
</code></pre>

<hr>
<h2 id='bgbb.PlotTrackingCum'>BG/BB Tracking Cumulative Transactions Plot</h2><span id='topic+bgbb.PlotTrackingCum'></span>

<h3>Description</h3>

<p>Plots the actual and expected cumulative total repeat transactions by all
customers for the calibration and holdout periods. Also returns a matrix with
this comparison.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bgbb.PlotTrackingCum(
  params,
  rf.matrix,
  actual.cum.repeat.transactions,
  xlab = "Time",
  ylab = "Cumulative Transactions",
  xticklab = NULL,
  title = "Tracking Cumulative Transactions"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bgbb.PlotTrackingCum_+3A_params">params</code></td>
<td>
<p>BG/BB parameters - a vector with alpha, beta, gamma, and delta,
in that order. Alpha and beta are unobserved parameters for the
beta-Bernoulli transaction process. Gamma and delta are unobserved
parameters for the beta-geometric dropout process.</p>
</td></tr>
<tr><td><code id="bgbb.PlotTrackingCum_+3A_rf.matrix">rf.matrix</code></td>
<td>
<p>recency-frequency matrix. It must contain columns for
frequency (&quot;x&quot;), recency (&quot;t.x&quot;), number of transaction opportunities in
the calibration period (&quot;n.cal&quot;), and the number of customers with this
combination of recency, frequency and transaction opportunities in the
calibration period (&quot;custs&quot;). Note that recency must be the time between
the start of the calibration period and the customer's last transaction,
not the time between the customer's last transaction and the end of the
calibration period.</p>
</td></tr>
<tr><td><code id="bgbb.PlotTrackingCum_+3A_actual.cum.repeat.transactions">actual.cum.repeat.transactions</code></td>
<td>
<p>vector containing the cumulative number
of repeat transactions made by customers in all transaction opportunities
(both calibration and holdout periods). Its unit of time should be the same
as the units of the recency-frequency matrix used to estimate the model
parameters.</p>
</td></tr>
<tr><td><code id="bgbb.PlotTrackingCum_+3A_xlab">xlab</code></td>
<td>
<p>descriptive label for the x axis.</p>
</td></tr>
<tr><td><code id="bgbb.PlotTrackingCum_+3A_ylab">ylab</code></td>
<td>
<p>descriptive label for the y axis.</p>
</td></tr>
<tr><td><code id="bgbb.PlotTrackingCum_+3A_xticklab">xticklab</code></td>
<td>
<p>vector containing a label for each tick mark on the x axis.</p>
</td></tr>
<tr><td><code id="bgbb.PlotTrackingCum_+3A_title">title</code></td>
<td>
<p>title placed on the top-center of the plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The holdout period should immediately follow the calibration period. This
function assumes that all customers' calibration periods end on the same date,
rather than starting on the same date (thus customers' birth periods are
determined using <code>max(n.cal) - n.cal</code> rather than assuming that they are all 0).
</p>


<h3>Value</h3>

<p>Matrix containing actual and expected cumulative repeat transactions.
</p>


<h3>References</h3>

<p>Fader, Peter S., Bruce G.S. Hardie, and Jen Shang.
&quot;Customer-Base Analysis in a Discrete-Time Noncontractual Setting.&quot;
<em>Marketing Science</em> 29(6), pp. 1086-1108. 2010. INFORMS.
<a href="http://www.brucehardie.com/papers/020/">Web.</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(donationsSummary)
# donationsSummary$rf.matrix already has appropriate column names
rf.matrix &lt;- donationsSummary$rf.matrix

# starting-point parameters
startingparams &lt;- c(1, 1, 0.5, 3)
# estimated parameters
est.params &lt;- bgbb.EstimateParameters(rf.matrix, startingparams)

# get the annual repeat transactions, and transform them into
# a cumulative form
actual.inc.repeat.transactions &lt;- donationsSummary$annual.trans
actual.cum.repeat.transactions &lt;- cumsum(actual.inc.repeat.transactions)

# set appropriate x-axis
x.tickmarks &lt;- c( "'96","'97","'98","'99","'00","'01","'02","'03","'04","'05","'06" )

# plot actual vs. expected transactions. The calibration period was 6 periods long.
bgbb.PlotTrackingCum(est.params, rf.matrix, actual.cum.repeat.transactions, xticklab=x.tickmarks)
</code></pre>

<hr>
<h2 id='bgbb.PlotTrackingInc'>BG/BB Tracking Incremental Transactions Plot</h2><span id='topic+bgbb.PlotTrackingInc'></span>

<h3>Description</h3>

<p>Plots the actual and expected incremental total repeat transactions by all
customers for the calibration and holdout periods. Also returns a matrix of
this comparison.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bgbb.PlotTrackingInc(
  params,
  rf.matrix,
  actual.inc.repeat.transactions,
  xlab = "Time",
  ylab = "Transactions",
  xticklab = NULL,
  title = "Tracking Incremental Transactions"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bgbb.PlotTrackingInc_+3A_params">params</code></td>
<td>
<p>BG/BB parameters - a vector with alpha, beta, gamma, and delta,
in that order. Alpha and beta are unobserved parameters for the
beta-Bernoulli transaction process. Gamma and delta are unobserved
parameters for the beta-geometric dropout process.</p>
</td></tr>
<tr><td><code id="bgbb.PlotTrackingInc_+3A_rf.matrix">rf.matrix</code></td>
<td>
<p>recency-frequency matrix. It must contain columns for
frequency (&quot;x&quot;), recency (&quot;t.x&quot;), number of transaction opportunities in
the calibration period (&quot;n.cal&quot;), and the number of customers with this
combination of recency, frequency and transaction opportunities in the
calibration period (&quot;custs&quot;). Note that recency must be the time between
the start of the calibration period and the customer's last transaction,
not the time between the customer's last transaction and the end of the
calibration period.</p>
</td></tr>
<tr><td><code id="bgbb.PlotTrackingInc_+3A_actual.inc.repeat.transactions">actual.inc.repeat.transactions</code></td>
<td>
<p>vector containing the incremental
number of repeat transactions made by customers in all transaction
opportunities (both calibration and holdout periods). Its unit of time
should be the same as the units of the recency-frequency matrix used to
estimate the model parameters.</p>
</td></tr>
<tr><td><code id="bgbb.PlotTrackingInc_+3A_xlab">xlab</code></td>
<td>
<p>descriptive label for the x axis.</p>
</td></tr>
<tr><td><code id="bgbb.PlotTrackingInc_+3A_ylab">ylab</code></td>
<td>
<p>descriptive label for the y axis.</p>
</td></tr>
<tr><td><code id="bgbb.PlotTrackingInc_+3A_xticklab">xticklab</code></td>
<td>
<p>vector containing a label for each tick mark on the x axis.</p>
</td></tr>
<tr><td><code id="bgbb.PlotTrackingInc_+3A_title">title</code></td>
<td>
<p>title placed on the top-center of the plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The holdout period should immediately follow the calibration period. This
function assumes that all customers' calibration periods end on the same date,
rather than starting on the same date (thus customers' birth periods are
determined using <code>max(n.cal) - n.cal</code> rather than assuming that they are all 0).
</p>


<h3>Value</h3>

<p>Matrix containing actual and expected incremental repeat transactions.
</p>


<h3>References</h3>

<p>Fader, Peter S., Bruce G.S. Hardie, and Jen Shang.
&quot;Customer-Base Analysis in a Discrete-Time Noncontractual Setting.&quot;
<em>Marketing Science</em> 29(6), pp. 1086-1108. 2010. INFORMS.
<a href="http://www.brucehardie.com/papers/020/">Web.</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(donationsSummary)
# donationsSummary$rf.matrix already has appropriate column names
rf.matrix &lt;- donationsSummary$rf.matrix

# starting-point parameters
startingparams &lt;- c(1, 1, 0.5, 3)
# estimated parameters
est.params &lt;- bgbb.EstimateParameters(rf.matrix, startingparams)

# get the annual repeat transactions
actual.inc.repeat.transactions &lt;- donationsSummary$annual.trans

# Set appropriate x-axis
x.tickmarks &lt;- c( "'96","'97","'98","'99","'00","'01","'02","'03","'04","'05","'06" )

# Plot actual vs. expected transactions. The calibration period was 6 periods long.
bgbb.PlotTrackingInc(est.params, rf.matrix, actual.inc.repeat.transactions, xticklab=x.tickmarks)
</code></pre>

<hr>
<h2 id='bgbb.PlotTransactionRateHeterogeneity'>BG/BB Plot Transaction Rate Heterogeneity</h2><span id='topic+bgbb.PlotTransactionRateHeterogeneity'></span>

<h3>Description</h3>

<p>Plots and returns the estimated beta distribution of P (customers' propensities to purchase).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bgbb.PlotTransactionRateHeterogeneity(params)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bgbb.PlotTransactionRateHeterogeneity_+3A_params">params</code></td>
<td>
<p>BG/BB parameters - a vector with alpha, beta, gamma, and delta,
in that order. Alpha and beta are unobserved parameters for the
beta-Bernoulli transaction process. Gamma and delta are unobserved
parameters for the beta-geometric dropout process.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This returns the distribution of each customer's Bernoulli parameter, which determines the level of their purchasing (using the BG/BB assumption that purchasing on the individual level can be modeled with a Bernoulli distribution).
</p>


<h3>Value</h3>

<p>Distribution of customers' propensities to purchase.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>params &lt;- c(1.2, 0.75, 0.66, 2.78)
bgbb.PlotTransactionRateHeterogeneity(params)
params &lt;- c(0.2, 1.5, 3.2, 6)
bgbb.PlotTransactionRateHeterogeneity(params)
</code></pre>

<hr>
<h2 id='bgbb.pmf'>BG/BB Probability Mass Function</h2><span id='topic+bgbb.pmf'></span>

<h3>Description</h3>

<p>Probability mass function for the BG/BB.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bgbb.pmf(params, n, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bgbb.pmf_+3A_params">params</code></td>
<td>
<p>BG/BB parameters - a vector with alpha, beta, gamma, and delta,
in that order. Alpha and beta are unobserved parameters for the
beta-Bernoulli transaction process. Gamma and delta are unobserved
parameters for the beta-geometric dropout process.</p>
</td></tr>
<tr><td><code id="bgbb.pmf_+3A_n">n</code></td>
<td>
<p>number of transaction opportunities; may also be a vector.</p>
</td></tr>
<tr><td><code id="bgbb.pmf_+3A_x">x</code></td>
<td>
<p>number of transactions; may also be a vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>P(X(n)=x | alpha, beta, gamma, delta). Returns the probability that a
customer makes x transactions in the first n transaction opportunities.
</p>
<p>Parameters <code>n</code> and <code>x</code> may be vectors. The standard rules for vector
operations apply - if they are not of the same length, the shorter vector
will be recycled (start over at the first element) until it is as long as the
longest vector. It is advisable to keep vectors to the same length and to use
single values for parameters that are to be the same for all calculations. If
one of these parameters has a length greater than one, the output will be a
vector of probabilities.
</p>


<h3>Value</h3>

<p>Probability of X(n)=x, conditional on model parameters.
</p>


<h3>References</h3>

<p>Fader, Peter S., Bruce G.S. Hardie, and Jen Shang.
&quot;Customer-Base Analysis in a Discrete-Time Noncontractual Setting.&quot;
<em>Marketing Science</em> 29(6), pp. 1086-1108. 2010. INFORMS.
<a href="http://www.brucehardie.com/papers/020/">Web.</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bgbb.pmf.General">bgbb.pmf.General</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>params &lt;- c(1.20, 0.75, 0.66, 2.78)
# The probability that a customer made 3 transactions in the first
# 6 transaction opportunities.
bgbb.pmf(params, n=6, x=3)

# Vectors may also be used as arguments:
bgbb.pmf(params, n=6, x=0:6)
</code></pre>

<hr>
<h2 id='bgbb.pmf.General'>BG/BB General Probability Mass Function</h2><span id='topic+bgbb.pmf.General'></span>

<h3>Description</h3>

<p>Calculates the probability that a customer will make <code>x.star</code> transactions in
the first <code>n.star</code> transaction opportunities following the calibration
period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bgbb.pmf.General(params, n.cal, n.star, x.star)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bgbb.pmf.General_+3A_params">params</code></td>
<td>
<p>BG/BB parameters - a vector with alpha, beta, gamma, and
delta, in that order. Alpha and beta are unobserved parameters for the
beta-Bernoulli transaction process. Gamma and delta are unobserved
parameters for the beta-geometric dropout process.</p>
</td></tr>
<tr><td><code id="bgbb.pmf.General_+3A_n.cal">n.cal</code></td>
<td>
<p>number of transaction opportunities in the calibration
period. Can also be a vector of calibration period transaction
opportunities - see details.</p>
</td></tr>
<tr><td><code id="bgbb.pmf.General_+3A_n.star">n.star</code></td>
<td>
<p>number of transaction opportunities in the holdout period, or a
vector of holdout period transaction opportunities.</p>
</td></tr>
<tr><td><code id="bgbb.pmf.General_+3A_x.star">x.star</code></td>
<td>
<p>number of transactions in the holdout period, or a vector of
transaction frequencies.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>P(X(n, n + n*) = x* | alpha, beta, gamma, delta). This is a more generalized
version of the bgbb.pmf. Setting <code>n.cal</code> to 0 reduces this function to the
probability mass function in its usual format - the probability that a user
will make x.star transactions in the first n.star transaction opportunities.
</p>
<p>It is impossible for a customer to make a negative number of transactions, or
to make more transactions than there are transaction opportunities. This
function will throw an error if such inputs are provided.
</p>
<p><code>n.cal</code>, <code>n.star</code>, and <code>x.star</code> may be vectors. The standard rules for vector
operations apply - if they are not of the same length, shorter vectors will
be recycled (start over at the first element) until they are as long as the
longest vector. It is advisable to keep vectors to the same length and to use
single values for parameters that are to be the same for all calculations. If
one of these parameters has a length greater than one, the output will be a
vector of probabilities.
</p>


<h3>Value</h3>

<p>Probability of X(n, n + n*) = x*, given BG/BB model parameters.
</p>


<h3>References</h3>

<p>Fader, Peter S., Bruce G.S. Hardie, and Jen Shang.
&quot;Customer-Base Analysis in a Discrete-Time Noncontractual Setting.&quot;
<em>Marketing Science</em> 29(6), pp. 1086-1108. 2010. INFORMS.
<a href="http://www.brucehardie.com/papers/020/">Web.</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bgbb.pmf">bgbb.pmf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>params &lt;- c(1.20, 0.75, 0.66, 2.78)
# Probability that a customer will make 3 transactions in the 10
# transaction opportunities following the 6 transaction opportunities
# in the calibration period, given BG/BB parameters.
bgbb.pmf.General(params, n.cal=6, n.star=10, x.star=3)

# Vectors may also be provided as input:
# Comparison between different frequencies:
bgbb.pmf.General(params, n.cal=6, n.star=10, x.star=1:10)
# Comparison between different holdout transaction opportunities:
bgbb.pmf.General(params, n.cal=6, n.star=5:15, x.star=3)
</code></pre>

<hr>
<h2 id='bgbb.PosteriorMeanDropoutRate'>BG/BB Posterior Mean Dropout Rate</h2><span id='topic+bgbb.PosteriorMeanDropoutRate'></span>

<h3>Description</h3>

<p>Computes the mean value of the marginal posterior value of Theta, the geometric dropout process parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bgbb.PosteriorMeanDropoutRate(params, x, t.x, n.cal)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bgbb.PosteriorMeanDropoutRate_+3A_params">params</code></td>
<td>
<p>BG/BB parameters - a vector with alpha, beta, gamma, and
delta, in that order. Alpha and beta are unobserved parameters for the
beta-Bernoulli transaction process. Gamma and delta are unobserved
parameters for the beta-geometric dropout process.</p>
</td></tr>
<tr><td><code id="bgbb.PosteriorMeanDropoutRate_+3A_x">x</code></td>
<td>
<p>the number of repeat transactions made by the customer in the
calibration period. Can also be vector of frequencies - see details.</p>
</td></tr>
<tr><td><code id="bgbb.PosteriorMeanDropoutRate_+3A_t.x">t.x</code></td>
<td>
<p>recency - the transaction opportunity in which the customer made
their last transaction. Can also be a vector of recencies - see details.</p>
</td></tr>
<tr><td><code id="bgbb.PosteriorMeanDropoutRate_+3A_n.cal">n.cal</code></td>
<td>
<p>number of transaction opportunities in the calibration
period. Can also be a vector of calibration period transaction
opportunities - see details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>E(Theta | alpha, beta, gamma, delta, x, t.x, n). This is calculated by setting <code>l = 0</code> and <code>m = 1</code> in <code><a href="#topic+bgbb.PosteriorMeanLmProductMoment">bgbb.PosteriorMeanLmProductMoment</a></code>.
</p>
<p><code>x</code>, <code>t.x</code>, and <code>n.cal</code> may be vectors. The standard rules for vector operations apply - if they are not of the same length, shorter vectors will be recycled (start over at the first element) until they are as long as the longest vector. It is advisable to keep vectors to the same length and to use single values for parameters that are to be the same for all calculations. If one of these parameters has a length greater than one, the output will be also be a vector.
</p>


<h3>Value</h3>

<p>The posterior mean dropout rate.
</p>


<h3>References</h3>

<p>Fader, Peter S., Bruce G.S. Hardie, and Jen Shang.
&quot;Customer-Base Analysis in a Discrete-Time Noncontractual Setting.&quot;
<em>Marketing Science</em> 29(6), pp. 1086-1108. 2010. INFORMS.
<a href="http://www.brucehardie.com/papers/020/">Web.</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bgbb.rf.matrix.PosteriorMeanDropoutRate">bgbb.rf.matrix.PosteriorMeanDropoutRate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
data(donationsSummary)

rf.matrix &lt;- donationsSummary$rf.matrix
# donationsSummary$rf.matrix already has appropriate column names

# starting-point parameters
startingparams &lt;- c(1, 1, 0.5, 3)
# estimated parameters
est.params &lt;- bgbb.EstimateParameters(rf.matrix, startingparams)

# return the posterior mean dropout rate vector
bgbb.rf.matrix.PosteriorMeanDropoutRate(est.params, rf.matrix)
</code></pre>

<hr>
<h2 id='bgbb.PosteriorMeanLmProductMoment'>BG/BB Posterior Mean (l,m)th Product Moment</h2><span id='topic+bgbb.PosteriorMeanLmProductMoment'></span>

<h3>Description</h3>

<p>Computes the <code style="white-space: pre;">&#8288;(l,m)&#8288;</code>th product moment of the joint posterior distribution of
P (the Bernoulli transaction process parameter) and Theta (the geometric
dropout process parameter).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bgbb.PosteriorMeanLmProductMoment(params, l, m, x, t.x, n.cal)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bgbb.PosteriorMeanLmProductMoment_+3A_params">params</code></td>
<td>
<p>BG/BB parameters - a vector with alpha, beta, gamma, and
delta, in that order. Alpha and beta are unobserved parameters for the
beta-Bernoulli transaction process. Gamma and delta are unobserved
parameters for the beta-geometric dropout process.</p>
</td></tr>
<tr><td><code id="bgbb.PosteriorMeanLmProductMoment_+3A_l">l</code></td>
<td>
<p>moment degree of P</p>
</td></tr>
<tr><td><code id="bgbb.PosteriorMeanLmProductMoment_+3A_m">m</code></td>
<td>
<p>moment degree of Theta</p>
</td></tr>
<tr><td><code id="bgbb.PosteriorMeanLmProductMoment_+3A_x">x</code></td>
<td>
<p>the number of repeat transactions made by the customer in the
calibration period. Can also be vector of frequencies - see details.</p>
</td></tr>
<tr><td><code id="bgbb.PosteriorMeanLmProductMoment_+3A_t.x">t.x</code></td>
<td>
<p>recency - the transaction opportunity in which the customer made
their last transaction. Can also be a vector of recencies - see details.</p>
</td></tr>
<tr><td><code id="bgbb.PosteriorMeanLmProductMoment_+3A_n.cal">n.cal</code></td>
<td>
<p>number of transaction opportunities in the calibration
period. Can also be a vector of calibration period transaction
opportunities - see details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>E((P)^l(Theta)^m | alpha, beta, gamma, delta, x, t.x, n)
</p>
<p><code>x</code>, <code>t.x</code>, and <code>n.cal</code> may be vectors. The standard rules for vector
operations apply - if they are not of the same length, shorter vectors will
be recycled (start over at the first element) until they are as long as the
longest vector. It is advisable to keep vectors to the same length and to use
single values for parameters that are to be the same for all calculations. If
one of these parameters has a length greater than one, the output will be
also be a vector.
</p>


<h3>Value</h3>

<p>The expected posterior <code style="white-space: pre;">&#8288;(l,m)&#8288;</code>th product moment.
</p>


<h3>References</h3>

<p>Fader, Peter S., Bruce G.S. Hardie, and Jen Shang.
&quot;Customer-Base Analysis in a Discrete-Time Noncontractual Setting.&quot;
<em>Marketing Science</em> 29(6), pp. 1086-1108. 2010. INFORMS.
<a href="http://www.brucehardie.com/papers/020/">Web.</a>
</p>
<p>See equation 17.
</p>

<hr>
<h2 id='bgbb.PosteriorMeanTransactionRate'>BG/BB Posterior Mean Transaction Rate</h2><span id='topic+bgbb.PosteriorMeanTransactionRate'></span>

<h3>Description</h3>

<p>Computes the mean value of the marginal posterior value of P, the Bernoulli
transaction process parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bgbb.PosteriorMeanTransactionRate(params, x, t.x, n.cal)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bgbb.PosteriorMeanTransactionRate_+3A_params">params</code></td>
<td>
<p>BG/BB parameters - a vector with alpha, beta, gamma, and
delta, in that order. Alpha and beta are unobserved parameters for the
beta-Bernoulli transaction process. Gamma and delta are unobserved
parameters for the beta-geometric dropout process.</p>
</td></tr>
<tr><td><code id="bgbb.PosteriorMeanTransactionRate_+3A_x">x</code></td>
<td>
<p>the number of repeat transactions made by the customer in the
calibration period. Can also be vector of frequencies - see details.</p>
</td></tr>
<tr><td><code id="bgbb.PosteriorMeanTransactionRate_+3A_t.x">t.x</code></td>
<td>
<p>recency - the transaction opportunity in which the customer made
their last transaction. Can also be a vector of recencies - see details.</p>
</td></tr>
<tr><td><code id="bgbb.PosteriorMeanTransactionRate_+3A_n.cal">n.cal</code></td>
<td>
<p>number of transaction opportunities in the calibration
period. Can also be a vector of calibration period transaction
opportunities - see details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>E(P | alpha, beta, gamma, delta, x, t.x, n). This is calculated by setting <code>l = 1</code> and <code>m = 0</code> in <code><a href="#topic+bgbb.PosteriorMeanLmProductMoment">bgbb.PosteriorMeanLmProductMoment</a></code>.
</p>
<p><code>x</code>, <code>t.x</code>, and <code>n.cal</code> may be vectors. The standard rules for vector
operations apply - if they are not of the same length, shorter vectors will
be recycled (start over at the first element) until they are as long as the
longest vector. It is advisable to keep vectors to the same length and to use
single values for parameters that are to be the same for all calculations. If
one of these parameters has a length greater than one, the output will be
also be a vector.
</p>


<h3>Value</h3>

<p>The posterior mean transaction rate.
</p>


<h3>References</h3>

<p>Fader, Peter S., Bruce G.S. Hardie, and Jen Shang.
&quot;Customer-Base Analysis in a Discrete-Time Noncontractual Setting.&quot;
<em>Marketing Science</em> 29(6), pp. 1086-1108. 2010. INFORMS.
<a href="http://www.brucehardie.com/papers/020/">Web.</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bgbb.rf.matrix.PosteriorMeanTransactionRate">bgbb.rf.matrix.PosteriorMeanTransactionRate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
data(donationsSummary)

rf.matrix &lt;- donationsSummary$rf.matrix
# donationsSummary$rf.matrix already has appropriate column names

# starting-point parameters
startingparams &lt;- c(1, 1, 0.5, 3)
# estimated parameters
est.params &lt;- bgbb.EstimateParameters(rf.matrix, startingparams)

# return the posterior mean transaction rate vector
bgbb.rf.matrix.PosteriorMeanTransactionRate(est.params, rf.matrix)
</code></pre>

<hr>
<h2 id='bgbb.rf.matrix.DERT'>BG/BB Discounted Expected Residual Transactions using a recency-frequency matrix</h2><span id='topic+bgbb.rf.matrix.DERT'></span>

<h3>Description</h3>

<p>Computes the number of discounted expected residual transactions by a
customer, conditional on their behavior in the calibration period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bgbb.rf.matrix.DERT(params, rf.matrix, d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bgbb.rf.matrix.DERT_+3A_params">params</code></td>
<td>
<p>BG/BB parameters - a vector with alpha, beta, gamma, and
delta, in that order. Alpha and beta are unobserved parameters for the
beta-Bernoulli transaction process. Gamma and delta are unobserved
parameters for the beta-geometric dropout process.</p>
</td></tr>
<tr><td><code id="bgbb.rf.matrix.DERT_+3A_rf.matrix">rf.matrix</code></td>
<td>
<p>recency-frequency matrix. It must contain columns for
frequency (&quot;x&quot;), recency (&quot;t.x&quot;), number of transaction opportunities in
the calibration period (&quot;n.cal&quot;), and the number of customers with this
combination of recency, frequency and transaction opportunities in the
calibration period (&quot;custs&quot;). Note that recency must be the time between
the start of the calibration period and the customer's last transaction,
not the time between the customer's last transaction and the end of the
calibration period.</p>
</td></tr>
<tr><td><code id="bgbb.rf.matrix.DERT_+3A_d">d</code></td>
<td>
<p>discount rate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The present value of the expected future transaction stream for a particular customer.
</p>


<h3>References</h3>

<p>Fader, Peter S., Bruce G.S. Hardie, and Jen Shang.
&quot;Customer-Base Analysis in a Discrete-Time Noncontractual Setting.&quot;
<em>Marketing Science</em> 29(6), pp. 1086-1108. 2010. INFORMS.
<a href="http://www.brucehardie.com/papers/020/">Web.</a>
See equation 14.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bgbb.DERT">bgbb.DERT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(donationsSummary)

rf.matrix &lt;- donationsSummary$rf.matrix
# donationsSummary$rf.matrix already has appropriate column names

# starting-point parameters
startingparams &lt;- c(1, 1, 0.5, 3)
# estimated parameters
est.params &lt;- bgbb.EstimateParameters(rf.matrix, startingparams)

# compute DERT for a customer from every row in rf.matrix,
# discounted at 10%.
bgbb.rf.matrix.DERT(est.params, rf.matrix, d = 0.1)
</code></pre>

<hr>
<h2 id='bgbb.rf.matrix.LL'>BG/BB Log-Likelihood using a recency-frequency matrix</h2><span id='topic+bgbb.rf.matrix.LL'></span>

<h3>Description</h3>

<p>Calculates the log-likelihood of the BG/BB model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bgbb.rf.matrix.LL(params, rf.matrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bgbb.rf.matrix.LL_+3A_params">params</code></td>
<td>
<p>BG/BB parameters - a vector with alpha, beta, gamma, and delta,
in that order. Alpha and beta are unobserved parameters for the
beta-Bernoulli transaction process. Gamma and delta are unobserved
parameters for the beta-geometric dropout process.</p>
</td></tr>
<tr><td><code id="bgbb.rf.matrix.LL_+3A_rf.matrix">rf.matrix</code></td>
<td>
<p>recency-frequency matrix. It must contain columns for
frequency (&quot;x&quot;), recency (&quot;t.x&quot;), number of transaction opportunities in
the calibration period (&quot;n.cal&quot;), and the number of customers with this
combination of recency, frequency and transaction opportunities in the
calibration period (&quot;custs&quot;). Note that recency must be the time between
the start of the calibration period and the customer's last transaction,
not the time between the customer's last transaction and the end of the
calibration period.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The total log-likelihood of the provided data in rf.matrix.
</p>


<h3>References</h3>

<p>Fader, Peter S., Bruce G.S. Hardie, and Jen Shang.
&quot;Customer-Base Analysis in a Discrete-Time Noncontractual Setting.&quot;
<em>Marketing Science</em> 29(6), pp. 1086-1108. 2010. INFORMS.
<a href="http://www.brucehardie.com/papers/020/">Web.</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bgbb.LL">bgbb.LL</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(donationsSummary)

rf.matrix &lt;- donationsSummary$rf.matrix
# donationsSummary$rf.matrix already has appropriate column names

params &lt;- c(1.20, 0.75, 0.66, 2.78)
bgbb.rf.matrix.LL(params, rf.matrix)
</code></pre>

<hr>
<h2 id='bgbb.rf.matrix.PosteriorMeanDropoutRate'>BG/BB Posterior Mean Dropout Rate using a recency-frequency matrix</h2><span id='topic+bgbb.rf.matrix.PosteriorMeanDropoutRate'></span>

<h3>Description</h3>

<p>Computes the mean value of the marginal posterior value of Theta, the geometric dropout process parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bgbb.rf.matrix.PosteriorMeanDropoutRate(params, rf.matrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bgbb.rf.matrix.PosteriorMeanDropoutRate_+3A_params">params</code></td>
<td>
<p>BG/BB parameters - a vector with alpha, beta, gamma, and delta,
in that order. Alpha and beta are unobserved parameters for the
beta-Bernoulli transaction process. Gamma and delta are unobserved
parameters for the beta-geometric dropout process.</p>
</td></tr>
<tr><td><code id="bgbb.rf.matrix.PosteriorMeanDropoutRate_+3A_rf.matrix">rf.matrix</code></td>
<td>
<p>recency-frequency matrix. It must contain columns for
frequency (&quot;x&quot;), recency (&quot;t.x&quot;), number of transaction opportunities in
the calibration period (&quot;n.cal&quot;), and the number of customers with this
combination of recency, frequency and transaction opportunities in the
calibration period (&quot;custs&quot;). Note that recency must be the time between
the start of the calibration period and the customer's last transaction,
not the time between the customer's last transaction and the end of the
calibration period.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>E(Theta | alpha, beta, gamma, delta, x, t.x, n). This is calculated by setting <code>l = 0</code> and <code>m = 1</code> in <code><a href="#topic+bgbb.PosteriorMeanLmProductMoment">bgbb.PosteriorMeanLmProductMoment</a></code>.
</p>
<p><code>rf.matrix</code> has columns x<code style="white-space: pre;">&#8288;, &#8288;</code>t.x<code style="white-space: pre;">&#8288;, and &#8288;</code>n.cal'.
</p>


<h3>Value</h3>

<p>The posterior mean dropout rate.
</p>


<h3>References</h3>

<p>Fader, Peter S., Bruce G.S. Hardie, and Jen Shang.
&quot;Customer-Base Analysis in a Discrete-Time Noncontractual Setting.&quot;
<em>Marketing Science</em> 29(6), pp. 1086-1108. 2010. INFORMS.
<a href="http://www.brucehardie.com/papers/020/">Web.</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bgbb.PosteriorMeanDropoutRate">bgbb.PosteriorMeanDropoutRate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(donationsSummary)

rf.matrix &lt;- donationsSummary$rf.matrix
# donationsSummary$rf.matrix already has appropriate column names

# starting-point parameters
startingparams &lt;- c(1, 1, 0.5, 3)
# estimated parameters
est.params &lt;- bgbb.EstimateParameters(rf.matrix, startingparams)

# return the posterior mean dropout rate vector
bgbb.rf.matrix.PosteriorMeanDropoutRate(est.params, rf.matrix)
</code></pre>

<hr>
<h2 id='bgbb.rf.matrix.PosteriorMeanTransactionRate'>BG/BB Posterior Mean Transaction Rate using a recency-frequency matrix</h2><span id='topic+bgbb.rf.matrix.PosteriorMeanTransactionRate'></span>

<h3>Description</h3>

<p>Computes the mean value of the marginal posterior value of P, the Bernoulli
transaction process parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bgbb.rf.matrix.PosteriorMeanTransactionRate(params, rf.matrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bgbb.rf.matrix.PosteriorMeanTransactionRate_+3A_params">params</code></td>
<td>
<p>BG/BB parameters - a vector with alpha, beta, gamma, and delta,
in that order. Alpha and beta are unobserved parameters for the
beta-Bernoulli transaction process. Gamma and delta are unobserved
parameters for the beta-geometric dropout process.</p>
</td></tr>
<tr><td><code id="bgbb.rf.matrix.PosteriorMeanTransactionRate_+3A_rf.matrix">rf.matrix</code></td>
<td>
<p>recency-frequency matrix. It must contain columns for
frequency (&quot;x&quot;), recency (&quot;t.x&quot;), number of transaction opportunities in
the calibration period (&quot;n.cal&quot;), and the number of customers with this
combination of recency, frequency and transaction opportunities in the
calibration period (&quot;custs&quot;). Note that recency must be the time between
the start of the calibration period and the customer's last transaction,
not the time between the customer's last transaction and the end of the
calibration period.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>rf.matrix</code> has columns x<code style="white-space: pre;">&#8288;, &#8288;</code>t.x<code style="white-space: pre;">&#8288;, and &#8288;</code>n.cal'.
</p>


<h3>Value</h3>

<p>The posterior mean transaction rate.
</p>


<h3>References</h3>

<p>Fader, Peter S., Bruce G.S. Hardie, and Jen Shang.
&quot;Customer-Base Analysis in a Discrete-Time Noncontractual Setting.&quot;
<em>Marketing Science</em> 29(6), pp. 1086-1108. 2010. INFORMS.
<a href="http://www.brucehardie.com/papers/020/">Web.</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bgbb.PosteriorMeanTransactionRate">bgbb.PosteriorMeanTransactionRate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
data(donationsSummary)

rf.matrix &lt;- donationsSummary$rf.matrix
# donationsSummary$rf.matrix already has appropriate column names

# starting-point parameters
startingparams &lt;- c(1, 1, 0.5, 3)
# estimated parameters
est.params &lt;- bgbb.EstimateParameters(rf.matrix, startingparams)

# return the posterior mean transaction rate vector
bgbb.rf.matrix.PosteriorMeanTransactionRate(est.params, rf.matrix)
</code></pre>

<hr>
<h2 id='bgnbd.cbs.LL'>BG/NBD Log-Likelihood Wrapper</h2><span id='topic+bgnbd.cbs.LL'></span>

<h3>Description</h3>

<p>Calculates the log-likelihood sum of the BG/NBD model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bgnbd.cbs.LL(params, cal.cbs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bgnbd.cbs.LL_+3A_params">params</code></td>
<td>
<p>BG/NBD parameters - a vector with r, alpha, a, and b, in that
order. r and alpha are unobserved parameters for the NBD transaction
process. a and b are unobserved parameters for the Beta geometric dropout
process.</p>
</td></tr>
<tr><td><code id="bgnbd.cbs.LL_+3A_cal.cbs">cal.cbs</code></td>
<td>
<p>calibration period CBS (customer by sufficient statistic). It
must contain columns for frequency (&quot;x&quot;), recency (&quot;t.x&quot;), and total time
observed (&quot;T.cal&quot;). Note that recency must be the time between the start of
the calibration period and the customer's last transaction, not the time
between the customer's last transaction and the end of the calibration
period. If your data is compressed (see <code><a href="#topic+dc.compress.cbs">dc.compress.cbs</a></code>),
a fourth column labeled &quot;custs&quot; (number of customers with a specific
combination of recency, frequency and length of calibration period) is
available.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: do not use a compressed <code>cal.cbs</code> matrix. It makes quicker work
for Pareto/NBD estimation as implemented in this package, but the opposite is
true for BG/NBD. For proof, compare the definition of the
<code><a href="#topic+bgnbd.cbs.LL">bgnbd.cbs.LL</a></code> to that of <code><a href="#topic+pnbd.cbs.LL">pnbd.cbs.LL</a></code>.
</p>


<h3>Value</h3>

<p>The total log-likelihood of the provided data.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bgnbd.EstimateParameters">bgnbd.EstimateParameters</a></code>
</p>
<p><code><a href="#topic+bgnbd.LL">bgnbd.LL</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cdnowSummary)

cal.cbs &lt;- cdnowSummary$cbs
# cal.cbs already has column names required by method

# random assignment of parameters
params &lt;- c(0.5, 6, 1.2, 3.3)
# returns the log-likelihood of the given parameters
bgnbd.cbs.LL(params, cal.cbs)

# compare the speed and results to the following:
cal.cbs.compressed &lt;- dc.compress.cbs(cal.cbs)
bgnbd.cbs.LL (params, cal.cbs.compressed)

# Returns the log likelihood of the parameters for a customer who
# made 3 transactions in a calibration period that ended at t=6,
# with the last transaction occurring at t=4.
bgnbd.LL(params, x=3, t.x=4, T.cal=6)

# We can also give vectors as function parameters:
set.seed(7)
x &lt;- sample(1:4, 10, replace = TRUE)
t.x &lt;- sample(1:4, 10, replace = TRUE)
T.cal &lt;- rep(4, 10)
bgnbd.LL(params, x, t.x, T.cal)
</code></pre>

<hr>
<h2 id='bgnbd.ConditionalExpectedTransactions'>BG/NBD Conditional Expected Transactions</h2><span id='topic+bgnbd.ConditionalExpectedTransactions'></span>

<h3>Description</h3>

<p>E[X(T.cal, T.cal + T.star) | x, t.x, r, alpha, a, b]
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bgnbd.ConditionalExpectedTransactions(
  params,
  T.star,
  x,
  t.x,
  T.cal,
  hardie = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bgnbd.ConditionalExpectedTransactions_+3A_params">params</code></td>
<td>
<p>BG/NBD parameters - a vector with r, alpha, a, and b, in that
order. r and alpha are unobserved parameters for the NBD transaction
process. a and b are unobserved parameters for the Beta geometric dropout
process.</p>
</td></tr>
<tr><td><code id="bgnbd.ConditionalExpectedTransactions_+3A_t.star">T.star</code></td>
<td>
<p>length of time for which we are calculating the expected number
of transactions.</p>
</td></tr>
<tr><td><code id="bgnbd.ConditionalExpectedTransactions_+3A_x">x</code></td>
<td>
<p>number of repeat transactions in the calibration period T.cal, or a
vector of transaction frequencies.</p>
</td></tr>
<tr><td><code id="bgnbd.ConditionalExpectedTransactions_+3A_t.x">t.x</code></td>
<td>
<p>time of most recent repeat transaction, or a vector of recencies.</p>
</td></tr>
<tr><td><code id="bgnbd.ConditionalExpectedTransactions_+3A_t.cal">T.cal</code></td>
<td>
<p>length of calibration period, or a vector of calibration period
lengths.</p>
</td></tr>
<tr><td><code id="bgnbd.ConditionalExpectedTransactions_+3A_hardie">hardie</code></td>
<td>
<p>if TRUE, use <code><a href="#topic+h2f1">h2f1</a></code> instead of
<code><a href="hypergeo.html#topic+hypergeo">hypergeo</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>T.star</code>, <code>x</code>, <code>t.x</code> and <code>T.cal</code> may be vectors. The
standard rules for vector operations apply - if they are not of the same
length, shorter vectors will be recycled (start over at the first element)
until they are as long as the longest vector. It is advisable to keep vectors
to the same length and to use single values for parameters that are to be the
same for all calculations. If one of these parameters has a length greater
than one, the output will be a vector of probabilities.
</p>


<h3>Value</h3>

<p>Number of transactions a customer is expected to make in a time
period of length t, conditional on their past behavior. If any of the input
parameters has a length greater than 1, this will be a vector of expected
number of transactions.
</p>


<h3>References</h3>

<p>Fader, Peter S.; Hardie, Bruce G.S.and Lee, Ka Lok. “Computing
P(alive) Using the BG/NBD Model.” December. 2008. Web.
<a href="http://www.brucehardie.com/notes/021/palive_for_BGNBD.pdf">http://www.brucehardie.com/notes/021/palive_for_BGNBD.pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bgnbd.Expectation">bgnbd.Expectation</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>params &lt;- c(0.243, 4.414, 0.793, 2.426)
# Number of transactions a customer is expected to make in 2 time
# intervals, given that they made 10 repeat transactions in a time period
# of 39 intervals, with the 10th repeat transaction occurring in the 35th
# interval.
bgnbd.ConditionalExpectedTransactions(params, T.star=2, x=10, t.x=35, T.cal=39)

# We can also compare expected transactions across different
# calibration period behaviors:
bgnbd.ConditionalExpectedTransactions(params, T.star=2, x=5:20, t.x=25, T.cal=39)
</code></pre>

<hr>
<h2 id='bgnbd.EstimateParameters'>BG/NBD Parameter Estimation</h2><span id='topic+bgnbd.EstimateParameters'></span>

<h3>Description</h3>

<p>Estimates parameters for the BG/NBD model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bgnbd.EstimateParameters(
  cal.cbs,
  par.start = c(1, 3, 1, 3),
  max.param.value = 10000,
  method = "L-BFGS-B",
  hessian = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bgnbd.EstimateParameters_+3A_cal.cbs">cal.cbs</code></td>
<td>
<p>calibration period CBS (customer by sufficient statistic). It
must contain columns for frequency (&quot;x&quot;), recency (&quot;t.x&quot;), and total time
observed (&quot;T.cal&quot;). Note that recency must be the time between the start of
the calibration period and the customer's last transaction, not the time
between the customer's last transaction and the end of the calibration
period.</p>
</td></tr>
<tr><td><code id="bgnbd.EstimateParameters_+3A_par.start">par.start</code></td>
<td>
<p>initial BG/NBD parameters - a vector with r, alpha, a, and
b, in that order. r and alpha are unobserved parameters for the NBD
transaction process. a and b are unobserved parameters for the Beta
geometric dropout process.</p>
</td></tr>
<tr><td><code id="bgnbd.EstimateParameters_+3A_max.param.value">max.param.value</code></td>
<td>
<p>the upper bound on parameters.</p>
</td></tr>
<tr><td><code id="bgnbd.EstimateParameters_+3A_method">method</code></td>
<td>
<p>the optimization method(s) passed along to
<code><a href="optimx.html#topic+optimx">optimx</a></code>.</p>
</td></tr>
<tr><td><code id="bgnbd.EstimateParameters_+3A_hessian">hessian</code></td>
<td>
<p>set it to TRUE if you want the Hessian matrix, and then you
might as well have the complete  <code><a href="optimx.html#topic+optimx">optimx</a></code> object
returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The best-fitting parameters are determined using the
<code><a href="#topic+bgnbd.cbs.LL">bgnbd.cbs.LL</a></code> function. The sum of the log-likelihood for each
customer (for a set of parameters) is maximized in order to estimate
parameters.
</p>
<p>A set of starting parameters must be provided for this method. If no
parameters are provided, (1,3,1,3) is used as a default. These values are
used because they provide good convergence across data sets. It may be useful
to use starting values for r and alpha that represent your best guess of the
heterogeneity in the buy and die rate of customers. It may be necessary to
run the estimation from multiple starting points to ensure that it converges.
To compare the log-likelihoods of different parameters, use
<code><a href="#topic+bgnbd.cbs.LL">bgnbd.cbs.LL</a></code>.
</p>
<p>The lower bound on the parameters to be estimated is always zero, since
BG/NBD parameters cannot be negative. The upper bound can be set with the
max.param.value parameter.
</p>
<p>This function may take some time to run.
</p>


<h3>Value</h3>

<p>Vector of estimated parameters.
</p>


<h3>References</h3>

<p>Fader, Peter S.; Hardie, and Bruce G.S.. &quot;Overcoming the BG/NBD
Model's #NUM! Error Problem.&quot; December. 2013. Web.
<a href="http://brucehardie.com/notes/027/bgnbd_num_error.pdf">http://brucehardie.com/notes/027/bgnbd_num_error.pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bgnbd.cbs.LL">bgnbd.cbs.LL</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cdnowSummary)

cal.cbs &lt;- cdnowSummary$cbs
# cal.cbs already has column names required by method

# starting-point parameters
startingparams &lt;- c(1.0, 3, 1.0, 3)

# estimated parameters
est.params &lt;- bgnbd.EstimateParameters(cal.cbs = cal.cbs,
                                       par.start = startingparams)

# complete object returned by \code{\link[optimx]{optimx}}
optimx.set &lt;- bgnbd.EstimateParameters(cal.cbs = cal.cbs,
                                       par.start = startingparams,
                                       hessian = TRUE)

# log-likelihood of estimated parameters
bgnbd.cbs.LL(est.params, cal.cbs)
</code></pre>

<hr>
<h2 id='bgnbd.Expectation'>BG/NBD Expectation</h2><span id='topic+bgnbd.Expectation'></span>

<h3>Description</h3>

<p>Returns the number of repeat transactions that a randomly chosen customer
(for whom we have no prior information) is expected to make in a given time
period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bgnbd.Expectation(params, t, hardie = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bgnbd.Expectation_+3A_params">params</code></td>
<td>
<p>BG/NBD parameters - a vector with r, alpha, a, and b, in that
order. r and alpha are unobserved parameters for the NBD transaction
process. a and b are unobserved parameters for the Beta geometric dropout
process.</p>
</td></tr>
<tr><td><code id="bgnbd.Expectation_+3A_t">t</code></td>
<td>
<p>length of time for which we are calculating the expected number of
repeat transactions.</p>
</td></tr>
<tr><td><code id="bgnbd.Expectation_+3A_hardie">hardie</code></td>
<td>
<p>if TRUE, use <code><a href="#topic+h2f1">h2f1</a></code> instead of
<code><a href="hypergeo.html#topic+hypergeo">hypergeo</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>E(X(t) | r, alpha, a, b)
</p>


<h3>Value</h3>

<p>Number of repeat transactions a customer is expected to make in a
time period of length t.
</p>


<h3>References</h3>

<p>Fader, Peter S.; Hardie, Bruce G.S.and Lee, Ka Lok. “Computing
P(alive) Using the BG/NBD Model.” December. 2008. Web.
<a href="http://www.brucehardie.com/notes/021/palive_for_BGNBD.pdf">http://www.brucehardie.com/notes/021/palive_for_BGNBD.pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bgnbd.ConditionalExpectedTransactions">bgnbd.ConditionalExpectedTransactions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>params &lt;- c(0.243, 4.414, 0.793, 2.426)

# Number of repeat transactions a customer is expected to make in 2 time intervals.
bgnbd.Expectation(params, t=2, hardie = FALSE)

# We can also compare expected transactions over time:
bgnbd.Expectation(params, t=1:10)
</code></pre>

<hr>
<h2 id='bgnbd.ExpectedCumulativeTransactions'>BG/NBD Expected Cumulative Transactions</h2><span id='topic+bgnbd.ExpectedCumulativeTransactions'></span>

<h3>Description</h3>

<p>Calculates the expected cumulative total repeat transactions by all customers
for the calibration and holdout periods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bgnbd.ExpectedCumulativeTransactions(
  params,
  T.cal,
  T.tot,
  n.periods.final,
  hardie = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bgnbd.ExpectedCumulativeTransactions_+3A_params">params</code></td>
<td>
<p>BG/NBD parameters - a vector with r, alpha, a, and b, in that
order. r and alpha are unobserved parameters for the NBD transaction
process. a and b are unobserved parameters for the Beta geometric dropout
process.</p>
</td></tr>
<tr><td><code id="bgnbd.ExpectedCumulativeTransactions_+3A_t.cal">T.cal</code></td>
<td>
<p>a vector to represent customers' calibration period lengths
(in other words, the &quot;T.cal&quot; column from a customer-by-sufficient-statistic
matrix).</p>
</td></tr>
<tr><td><code id="bgnbd.ExpectedCumulativeTransactions_+3A_t.tot">T.tot</code></td>
<td>
<p>end of holdout period. Must be a single value, not a vector.</p>
</td></tr>
<tr><td><code id="bgnbd.ExpectedCumulativeTransactions_+3A_n.periods.final">n.periods.final</code></td>
<td>
<p>number of time periods in the calibration and
holdout periods. See details.</p>
</td></tr>
<tr><td><code id="bgnbd.ExpectedCumulativeTransactions_+3A_hardie">hardie</code></td>
<td>
<p>if TRUE, use h2f1 instead of hypergeo.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function automatically divides the total period up into n.periods.final
time intervals. n.periods.final does not have to be in the same unit of time
as the T.cal data. For example: - if your T.cal data is in weeks, and you
want cumulative transactions per week, n.periods.final would equal T.star. -
if your T.cal data is in weeks, and you want cumulative transactions per day,
n.periods.final would equal T.star * 7.
</p>
<p>The holdout period should immediately follow the calibration period. This
function assume that all customers' calibration periods end on the same date,
rather than starting on the same date (thus customers' birth periods are
determined using max(T.cal) - T.cal rather than assuming that it is 0).
</p>


<h3>Value</h3>

<p>Vector of expected cumulative total repeat transactions by all
customers.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bgnbd.Expectation">bgnbd.Expectation</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cdnowSummary)

cal.cbs &lt;- cdnowSummary$cbs
# cal.cbs already has column names required by method

params &lt;- c(0.243, 4.414, 0.793, 2.426)

# Returns a vector containing cumulative repeat transactions for 273 days.
# All parameters are in weeks; the calibration period lasted 39 weeks.
bgnbd.ExpectedCumulativeTransactions(params,
                                     T.cal = cal.cbs[,"T.cal"],
                                     T.tot = 39,
                                     n.periods.final = 273,
                                     hardie = TRUE)
</code></pre>

<hr>
<h2 id='bgnbd.generalParams'>Define general parameters</h2><span id='topic+bgnbd.generalParams'></span>

<h3>Description</h3>

<p>This is to ensure consistency across all functions that require common bits
and bobs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bgnbd.generalParams(params, func, x, t.x, T.cal, T.star = NULL, hardie = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bgnbd.generalParams_+3A_params">params</code></td>
<td>
<p>BG/NBD parameters - a vector with r, alpha, a, and b, in that
order. r and alpha are unobserved parameters for the NBD transaction
process. a and b are unobserved parameters for the Beta geometric dropout
process.</p>
</td></tr>
<tr><td><code id="bgnbd.generalParams_+3A_func">func</code></td>
<td>
<p>function calling dc.InputCheck</p>
</td></tr>
<tr><td><code id="bgnbd.generalParams_+3A_x">x</code></td>
<td>
<p>number of repeat transactions in the calibration period T.cal, or a
vector of transaction frequencies.</p>
</td></tr>
<tr><td><code id="bgnbd.generalParams_+3A_t.x">t.x</code></td>
<td>
<p>time of most recent repeat transaction, or a vector of recencies.</p>
</td></tr>
<tr><td><code id="bgnbd.generalParams_+3A_t.cal">T.cal</code></td>
<td>
<p>length of calibration period, or a vector of calibration period
lengths.</p>
</td></tr>
<tr><td><code id="bgnbd.generalParams_+3A_t.star">T.star</code></td>
<td>
<p>length of time for which we are calculating the expected number
of transactions.</p>
</td></tr>
<tr><td><code id="bgnbd.generalParams_+3A_hardie">hardie</code></td>
<td>
<p>if TRUE, use <code><a href="#topic+h2f1">h2f1</a></code> instead of
<code><a href="hypergeo.html#topic+hypergeo">hypergeo</a></code> when you call this function from within
<code><a href="#topic+bgnbd.ConditionalExpectedTransactions">bgnbd.ConditionalExpectedTransactions</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with things you need for <code><a href="#topic+bgnbd.LL">bgnbd.LL</a></code>,
<code><a href="#topic+bgnbd.PAlive">bgnbd.PAlive</a></code> and
<code><a href="#topic+bgnbd.ConditionalExpectedTransactions">bgnbd.ConditionalExpectedTransactions</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bgnbd.LL">bgnbd.LL</a></code>
</p>
<p><code><a href="#topic+bgnbd.PAlive">bgnbd.PAlive</a></code>
</p>
<p><code><a href="#topic+bgnbd.ConditionalExpectedTransactions">bgnbd.ConditionalExpectedTransactions</a></code>
</p>

<hr>
<h2 id='bgnbd.LL'>BG/NBD Log-Likelihood</h2><span id='topic+bgnbd.LL'></span>

<h3>Description</h3>

<p>Calculates the log-likelihood of the BG/NBD model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bgnbd.LL(params, x, t.x, T.cal)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bgnbd.LL_+3A_params">params</code></td>
<td>
<p>BG/NBD parameters - a vector with r, alpha, a, and b, in that
order. r and alpha are unobserved parameters for the NBD transaction
process. a and b are unobserved parameters for the Beta geometric dropout
process.</p>
</td></tr>
<tr><td><code id="bgnbd.LL_+3A_x">x</code></td>
<td>
<p>number of repeat transactions in the calibration period T.cal, or a
vector of transaction frequencies.</p>
</td></tr>
<tr><td><code id="bgnbd.LL_+3A_t.x">t.x</code></td>
<td>
<p>time of most recent repeat transaction, or a vector of recencies.</p>
</td></tr>
<tr><td><code id="bgnbd.LL_+3A_t.cal">T.cal</code></td>
<td>
<p>length of calibration period, or a vector of calibration period
lengths.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>x</code>, <code>t.x</code> and <code>T.cal</code> may be vectors. The standard rules for
vector operations apply - if they are not of the same length, shorter vectors
will be recycled (start over at the first element) until they are as long as
the longest vector. It is advisable to keep vectors to the same length and to
use single values for parameters that are to be the same for all
calculations. If one of these parameters has a length greater than one, the
output will be also be a vector.
</p>


<h3>Value</h3>

<p>A vector of log-likelihoods as long as the longest input vector (x,
t.x, or T.cal).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bgnbd.EstimateParameters">bgnbd.EstimateParameters</a></code>
</p>
<p><code><a href="#topic+bgnbd.cbs.LL">bgnbd.cbs.LL</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cdnowSummary)

cal.cbs &lt;- cdnowSummary$cbs
# cal.cbs already has column names required by method

# random assignment of parameters
params &lt;- c(0.5, 6, 1.2, 3.3)
# returns the log-likelihood of the given parameters
bgnbd.cbs.LL (params, cal.cbs)

# compare the speed and results to the following:
cal.cbs.compressed &lt;- dc.compress.cbs(cal.cbs)
bgnbd.cbs.LL(params, cal.cbs.compressed)

# Returns the log likelihood of the parameters for a customer who
# made 3 transactions in a calibration period that ended at t=6,
# with the last transaction occurring at t=4.
bgnbd.LL(params, x=3, t.x=4, T.cal=6)

# We can also give vectors as function parameters:
set.seed(7)
x &lt;- sample(1:4, 10, replace = TRUE)
t.x &lt;- sample(1:4, 10, replace = TRUE)
T.cal &lt;- rep(4, 10)
bgnbd.LL(params, x, t.x, T.cal)
</code></pre>

<hr>
<h2 id='bgnbd.PAlive'>BG/NBD P(Alive)</h2><span id='topic+bgnbd.PAlive'></span>

<h3>Description</h3>

<p>Uses BG/NBD model parameters and a customer's past transaction behavior to
return the probability that they are still alive at the end of the
calibration period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bgnbd.PAlive(params, x, t.x, T.cal)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bgnbd.PAlive_+3A_params">params</code></td>
<td>
<p>BG/NBD parameters - a vector with r, alpha, a, and b, in that
order. r and alpha are unobserved parameters for the NBD transaction
process. a and b are unobserved parameters for the Beta geometric dropout
process.</p>
</td></tr>
<tr><td><code id="bgnbd.PAlive_+3A_x">x</code></td>
<td>
<p>number of repeat transactions in the calibration period T.cal, or a
vector of transaction frequencies.</p>
</td></tr>
<tr><td><code id="bgnbd.PAlive_+3A_t.x">t.x</code></td>
<td>
<p>time of most recent repeat transaction, or a vector of recencies.</p>
</td></tr>
<tr><td><code id="bgnbd.PAlive_+3A_t.cal">T.cal</code></td>
<td>
<p>length of calibration period, or a vector of calibration period
lengths.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>P(Alive | X=x, t.x, T.cal, r, alpha, a, b)
</p>
<p>x, t.x, and T.cal may be vectors. The standard rules for vector operations
apply - if they are not of the same length, shorter vectors will be recycled
(start over at the first element) until they are as long as the longest
vector. It is advisable to keep vectors to the same length and to use single
values for parameters that are to be the same for all calculations. If one of
these parameters has a length greater than one, the output will be a vector
of probabilities.
</p>


<h3>Value</h3>

<p>Probability that the customer is still alive at the end of the
calibration period. If x, t.x, and/or T.cal has a length greater than one,
then this will be a vector of probabilities (containing one element
matching each element of the longest input vector).
</p>


<h3>References</h3>

<p>Fader, Peter S.; Hardie, Bruce G.S.and Lee, Ka Lok. “Computing
P(alive) Using the BG/NBD Model.” December. 2008.
<a href="http://www.brucehardie.com/notes/021/palive_for_BGNBD.pdf">Web.</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>params &lt;- c(0.243, 4.414, 0.793, 2.426)

bgnbd.PAlive(params, x=23, t.x=39, T.cal=39)
# P(Alive) of a customer who has the same recency and total
# time observed.

bgnbd.PAlive(params, x=5:20, t.x=30, T.cal=39)
# Note the "increasing frequency paradox".

# To visualize the distribution of P(Alive) across customers:

data(cdnowSummary)
cbs &lt;- cdnowSummary$cbs
params &lt;- bgnbd.EstimateParameters(cbs, par.start = c(0.243, 4.414, 0.793, 2.426))
p.alives &lt;- bgnbd.PAlive(params, cbs[,"x"], cbs[,"t.x"], cbs[,"T.cal"])
plot(density(p.alives))
</code></pre>

<hr>
<h2 id='bgnbd.PlotDropoutRateHeterogeneity'>BG/NBD Plot Dropout Probability Heterogeneity</h2><span id='topic+bgnbd.PlotDropoutRateHeterogeneity'></span>

<h3>Description</h3>

<p>Plots and returns the estimated gamma distribution of p (customers'
probability of dropping out immediately after a transaction).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bgnbd.PlotDropoutRateHeterogeneity(params, lim = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bgnbd.PlotDropoutRateHeterogeneity_+3A_params">params</code></td>
<td>
<p>BG/NBD parameters - a vector with r, alpha, a, and b, in that
order. r and alpha are unobserved parameters for the NBD transaction
process. a and b are unobserved parameters for the Beta geometric dropout
process.</p>
</td></tr>
<tr><td><code id="bgnbd.PlotDropoutRateHeterogeneity_+3A_lim">lim</code></td>
<td>
<p>upper-bound of the x-axis. A number is chosen by the function if
none is provided.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Distribution of customers' probabilities of dropping out.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>params &lt;- c(0.243, 4.414, 0.793, 2.426)
bgnbd.PlotDropoutRateHeterogeneity(params)
params &lt;- c(0.243, 4.414, 1.33, 2.426)
bgnbd.PlotDropoutRateHeterogeneity(params)
</code></pre>

<hr>
<h2 id='bgnbd.PlotFrequencyInCalibration'>BG/NBD Plot Frequency in Calibration Period</h2><span id='topic+bgnbd.PlotFrequencyInCalibration'></span>

<h3>Description</h3>

<p>Plots a histogram and returns a matrix comparing the actual and expected
number of customers who made a certain number of repeat transactions in the
calibration period, binned according to calibration period frequencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bgnbd.PlotFrequencyInCalibration(
  params,
  cal.cbs,
  censor,
  plotZero = TRUE,
  xlab = "Calibration period transactions",
  ylab = "Customers",
  title = "Frequency of Repeat Transactions"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bgnbd.PlotFrequencyInCalibration_+3A_params">params</code></td>
<td>
<p>BG/NBD parameters - a vector with r, alpha, a, and b, in that
order. r and alpha are unobserved parameters for the NBD transaction
process. a and b are unobserved parameters for the Beta geometric dropout
process.</p>
</td></tr>
<tr><td><code id="bgnbd.PlotFrequencyInCalibration_+3A_cal.cbs">cal.cbs</code></td>
<td>
<p>calibration period CBS (customer by sufficient statistic). It
must contain columns for frequency (&quot;x&quot;) and total time observed (&quot;T.cal&quot;).</p>
</td></tr>
<tr><td><code id="bgnbd.PlotFrequencyInCalibration_+3A_censor">censor</code></td>
<td>
<p>integer used to censor the data. See details.</p>
</td></tr>
<tr><td><code id="bgnbd.PlotFrequencyInCalibration_+3A_plotzero">plotZero</code></td>
<td>
<p>If FALSE, the histogram will exclude the zero bin.</p>
</td></tr>
<tr><td><code id="bgnbd.PlotFrequencyInCalibration_+3A_xlab">xlab</code></td>
<td>
<p>descriptive label for the x axis.</p>
</td></tr>
<tr><td><code id="bgnbd.PlotFrequencyInCalibration_+3A_ylab">ylab</code></td>
<td>
<p>descriptive label for the y axis.</p>
</td></tr>
<tr><td><code id="bgnbd.PlotFrequencyInCalibration_+3A_title">title</code></td>
<td>
<p>title placed on the top-center of the plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function requires a censor number, which cannot be higher than the
highest frequency in the calibration period CBS. The output matrix will have
(censor + 1) bins, starting at frequencies of 0 transactions and ending at a
bin representing calibration period frequencies at or greater than the censor
number. The plot may or may not include a bin for zero frequencies, depending
on the plotZero parameter.
</p>


<h3>Value</h3>

<p>Calibration period repeat transaction frequency comparison matrix
(actual vs. expected).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cdnowSummary)

cal.cbs &lt;- cdnowSummary$cbs 
# cal.cbs already has column names required by method

# parameters estimated using bgnbd.EstimateParameters 
est.params &lt;- c(0.243, 4.414, 0.793, 2.426) 
# the maximum censor number that can be used
max(cal.cbs[,"x"])

bgnbd.PlotFrequencyInCalibration(est.params, cal.cbs, censor=7)
</code></pre>

<hr>
<h2 id='bgnbd.PlotFreqVsConditionalExpectedFrequency'>BG/NBD Plot Frequency vs. Conditional Expected Frequency</h2><span id='topic+bgnbd.PlotFreqVsConditionalExpectedFrequency'></span>

<h3>Description</h3>

<p>Plots the actual and conditional expected number transactions made by
customers in the holdout period, binned according to calibration period
frequencies. Also returns a matrix with this comparison and the number of
customers in each bin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bgnbd.PlotFreqVsConditionalExpectedFrequency(
  params,
  T.star,
  cal.cbs,
  x.star,
  censor,
  xlab = "Calibration period transactions",
  ylab = "Holdout period transactions",
  xticklab = NULL,
  title = "Conditional Expectation"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bgnbd.PlotFreqVsConditionalExpectedFrequency_+3A_params">params</code></td>
<td>
<p>BG/NBD parameters - a vector with r, alpha, a, and b, in that
order. r and alpha are unobserved parameters for the NBD transaction
process. a and b are unobserved parameters for the Beta geometric dropout
process.</p>
</td></tr>
<tr><td><code id="bgnbd.PlotFreqVsConditionalExpectedFrequency_+3A_t.star">T.star</code></td>
<td>
<p>length of then holdout period.</p>
</td></tr>
<tr><td><code id="bgnbd.PlotFreqVsConditionalExpectedFrequency_+3A_cal.cbs">cal.cbs</code></td>
<td>
<p>calibration period CBS (customer by sufficient statistic).
It must contain columns for frequency (&quot;x&quot;), recency (&quot;t.x&quot;), and total
time observed (&quot;T.cal&quot;). Note that recency must be the time between the
start of the calibration period and the customer's last transaction, not
the time between the customer's last transaction and the end of the
calibration period.</p>
</td></tr>
<tr><td><code id="bgnbd.PlotFreqVsConditionalExpectedFrequency_+3A_x.star">x.star</code></td>
<td>
<p>vector of transactions made by each customer in the holdout
period.</p>
</td></tr>
<tr><td><code id="bgnbd.PlotFreqVsConditionalExpectedFrequency_+3A_censor">censor</code></td>
<td>
<p>integer used to censor the data. See details.</p>
</td></tr>
<tr><td><code id="bgnbd.PlotFreqVsConditionalExpectedFrequency_+3A_xlab">xlab</code></td>
<td>
<p>descriptive label for the x axis.</p>
</td></tr>
<tr><td><code id="bgnbd.PlotFreqVsConditionalExpectedFrequency_+3A_ylab">ylab</code></td>
<td>
<p>descriptive label for the y axis.</p>
</td></tr>
<tr><td><code id="bgnbd.PlotFreqVsConditionalExpectedFrequency_+3A_xticklab">xticklab</code></td>
<td>
<p>vector containing a label for each tick mark on the x axis.</p>
</td></tr>
<tr><td><code id="bgnbd.PlotFreqVsConditionalExpectedFrequency_+3A_title">title</code></td>
<td>
<p>title placed on the top-center of the plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function requires a censor number, which cannot be higher than the
highest frequency in the calibration period CBS. The output matrix will have
(censor + 1) bins, starting at frequencies of 0 transactions and ending at a
bin representing calibration period frequencies at or greater than the censor
number.
</p>


<h3>Value</h3>

<p>Holdout period transaction frequency comparison matrix (actual vs.
expected).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cdnowSummary)

cal.cbs &lt;- cdnowSummary$cbs
# cal.cbs already has column names required by method

# number of transactions by each customer in the 39 weeks
# following the calibration period
x.star &lt;- cal.cbs[,"x.star"]

# parameters estimated using bgnbd.EstimateParameters
est.params &lt;- c(0.243, 4.414, 0.793, 2.426)
# the maximum censor number that can be used
max(cal.cbs[,"x"])

# plot conditional expected holdout period frequencies,
# binned according to calibration period frequencies
bgnbd.PlotFreqVsConditionalExpectedFrequency(est.params, 
                                             T.star = 39, 
                                             cal.cbs, 
                                             x.star, 
                                             censor = 7)
</code></pre>

<hr>
<h2 id='bgnbd.PlotRecVsConditionalExpectedFrequency'>BG/NBD Plot Actual vs. Conditional Expected Frequency by Recency</h2><span id='topic+bgnbd.PlotRecVsConditionalExpectedFrequency'></span>

<h3>Description</h3>

<p>Plots the actual and conditional expected number of transactions made by
customers in the holdout period, binned according to calibration period
recencies. Also returns a matrix with this comparison and the number of
customers in each bin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bgnbd.PlotRecVsConditionalExpectedFrequency(
  params,
  cal.cbs,
  T.star,
  x.star,
  xlab = "Calibration period recency",
  ylab = "Holdout period transactions",
  xticklab = NULL,
  title = "Actual vs. Conditional Expected Transactions by Recency"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bgnbd.PlotRecVsConditionalExpectedFrequency_+3A_params">params</code></td>
<td>
<p>BG/NBD parameters - a vector with r, alpha, a, and b, in that
order. r and alpha are unobserved parameters for the NBD transaction
process. a and b are unobserved parameters for the Beta geometric dropout
process.</p>
</td></tr>
<tr><td><code id="bgnbd.PlotRecVsConditionalExpectedFrequency_+3A_cal.cbs">cal.cbs</code></td>
<td>
<p>calibration period CBS (customer by sufficient statistic).
It must contain columns for frequency (&quot;x&quot;), recency (&quot;t.x&quot;), and total
time observed (&quot;T.cal&quot;). Note that recency must be the time between the
start of the calibration period and the customer's last transaction, not
the time between the customer's last transaction and the end of the
calibration period.</p>
</td></tr>
<tr><td><code id="bgnbd.PlotRecVsConditionalExpectedFrequency_+3A_t.star">T.star</code></td>
<td>
<p>length of then holdout period.</p>
</td></tr>
<tr><td><code id="bgnbd.PlotRecVsConditionalExpectedFrequency_+3A_x.star">x.star</code></td>
<td>
<p>vector of transactions made by each customer in the holdout
period.</p>
</td></tr>
<tr><td><code id="bgnbd.PlotRecVsConditionalExpectedFrequency_+3A_xlab">xlab</code></td>
<td>
<p>descriptive label for the x axis.</p>
</td></tr>
<tr><td><code id="bgnbd.PlotRecVsConditionalExpectedFrequency_+3A_ylab">ylab</code></td>
<td>
<p>descriptive label for the y axis.</p>
</td></tr>
<tr><td><code id="bgnbd.PlotRecVsConditionalExpectedFrequency_+3A_xticklab">xticklab</code></td>
<td>
<p>vector containing a label for each tick mark on the x axis.</p>
</td></tr>
<tr><td><code id="bgnbd.PlotRecVsConditionalExpectedFrequency_+3A_title">title</code></td>
<td>
<p>title placed on the top-center of the plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function does bin customers exactly according to recency; it bins
customers according to integer units of the time period of cal.cbs.
Therefore, if you are using weeks in your data, customers will be binned as
follows: customers with recencies between the start of the calibration period
(inclusive) and the end of week one (exclusive); customers with recencies
between the end of week one (inclusive) and the end of week two (exclusive);
etc.
</p>
<p>The matrix and plot will contain the actual number of transactions made by
each bin in the holdout period, as well as the expected number of
transactions made by that bin in the holdout period, conditional on that
bin's behavior during the calibration period.
</p>


<h3>Value</h3>

<p>Matrix comparing actual and conditional expected transactions in the
holdout period.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cdnowSummary)

cal.cbs &lt;- cdnowSummary$cbs 
# cal.cbs already has column names required by method

# number of transactions by each customer in the 39 weeks following 
# the calibration period 
x.star &lt;- cal.cbs[,"x.star"]

# parameters estimated using bgnbd.EstimateParameters 
est.params &lt;- c(0.243, 4.414, 0.793, 2.426)

# plot conditional expected holdout period transactions, 
# binned according to calibration period recencies
bgnbd.PlotRecVsConditionalExpectedFrequency(est.params, 
                                            cal.cbs, 
                                            T.star = 39,
                                            x.star)
</code></pre>

<hr>
<h2 id='bgnbd.PlotTrackingCum'>BG/NBD Tracking Cumulative Transactions Plot</h2><span id='topic+bgnbd.PlotTrackingCum'></span>

<h3>Description</h3>

<p>Plots the actual and expected cumulative total repeat transactions by all
customers for the calibration and holdout periods, and returns this
comparison in a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bgnbd.PlotTrackingCum(
  params,
  T.cal,
  T.tot,
  actual.cu.tracking.data,
  n.periods.final = NA,
  hardie = TRUE,
  xlab = "Week",
  ylab = "Cumulative Transactions",
  xticklab = NULL,
  title = "Tracking Cumulative Transactions"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bgnbd.PlotTrackingCum_+3A_params">params</code></td>
<td>
<p>BG/NBD parameters - a vector with r, alpha, a, and b, in that
order. r and alpha are unobserved parameters for the NBD transaction
process. a and b are unobserved parameters for the Beta geometric dropout
process.</p>
</td></tr>
<tr><td><code id="bgnbd.PlotTrackingCum_+3A_t.cal">T.cal</code></td>
<td>
<p>a vector to represent customers' calibration period lengths
(in other words, the &quot;T.cal&quot; column from a customer-by-sufficient-statistic
matrix).</p>
</td></tr>
<tr><td><code id="bgnbd.PlotTrackingCum_+3A_t.tot">T.tot</code></td>
<td>
<p>end of holdout period. Must be a single value, not a vector.</p>
</td></tr>
<tr><td><code id="bgnbd.PlotTrackingCum_+3A_actual.cu.tracking.data">actual.cu.tracking.data</code></td>
<td>
<p>vector containing the cumulative number of
repeat transactions made by customers for each period in the total time
period (both calibration and holdout periods). See details.</p>
</td></tr>
<tr><td><code id="bgnbd.PlotTrackingCum_+3A_n.periods.final">n.periods.final</code></td>
<td>
<p>number of time periods in the calibration and
holdout periods. See details.</p>
</td></tr>
<tr><td><code id="bgnbd.PlotTrackingCum_+3A_hardie">hardie</code></td>
<td>
<p>if TRUE, use h2f1 instead of hypergeo.</p>
</td></tr>
<tr><td><code id="bgnbd.PlotTrackingCum_+3A_xlab">xlab</code></td>
<td>
<p>descriptive label for the x axis.</p>
</td></tr>
<tr><td><code id="bgnbd.PlotTrackingCum_+3A_ylab">ylab</code></td>
<td>
<p>descriptive label for the y axis.</p>
</td></tr>
<tr><td><code id="bgnbd.PlotTrackingCum_+3A_xticklab">xticklab</code></td>
<td>
<p>vector containing a label for each tick mark on the x axis.</p>
</td></tr>
<tr><td><code id="bgnbd.PlotTrackingCum_+3A_title">title</code></td>
<td>
<p>title placed on the top-center of the plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>actual.cu.tracking.data does not have to be in the same unit of time as the
T.cal data. T.tot will automatically be divided into periods to match the
length of actual.cu.tracking.data. See
<a href="#topic+bgnbd.ExpectedCumulativeTransactions">bgnbd.ExpectedCumulativeTransactions</a>.
</p>
<p>The holdout period should immediately follow the calibration period. This
function assume that all customers' calibration periods end on the same date,
rather than starting on the same date (thus customers' birth periods are
determined using max(T.cal) - T.cal rather than assuming that it is 0).
</p>


<h3>Value</h3>

<p>Matrix containing actual and expected cumulative repeat transactions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cdnowSummary)

cal.cbs &lt;- cdnowSummary$cbs
# cal.cbs already has column names required by method

# Cumulative repeat transactions made by all customers across calibration
# and holdout periods
cu.tracking &lt;- cdnowSummary$cu.tracking

# parameters estimated using bgnbd.EstimateParameters
est.params &lt;- c(0.243, 4.414, 0.793, 2.426)

# All parameters are in weeks; the calibration period lasted 39
# weeks and the holdout period another 39.
bgnbd.PlotTrackingCum(est.params, 
                      T.cal = cal.cbs[,"T.cal"], 
                      T.tot = 78, 
                      actual.cu.tracking.data = cu.tracking, 
                      hardie = TRUE)
</code></pre>

<hr>
<h2 id='bgnbd.PlotTrackingInc'>BG/NBD Tracking Incremental Transactions Comparison</h2><span id='topic+bgnbd.PlotTrackingInc'></span>

<h3>Description</h3>

<p>Plots the actual and expected incremental total repeat transactions by all
customers for the calibration and holdout periods, and returns this
comparison in a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bgnbd.PlotTrackingInc(
  params,
  T.cal,
  T.tot,
  actual.inc.tracking.data,
  n.periods.final = NA,
  hardie = TRUE,
  xlab = "Week",
  ylab = "Transactions",
  xticklab = NULL,
  title = "Tracking Weekly Transactions"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bgnbd.PlotTrackingInc_+3A_params">params</code></td>
<td>
<p>BG/NBD parameters - a vector with r, alpha, a, and b, in that
order. r and alpha are unobserved parameters for the NBD transaction
process. a and b are unobserved parameters for the Beta geometric dropout
process.</p>
</td></tr>
<tr><td><code id="bgnbd.PlotTrackingInc_+3A_t.cal">T.cal</code></td>
<td>
<p>a vector to represent customers' calibration period lengths
(in other words, the &quot;T.cal&quot; column from a customer-by-sufficient-statistic
matrix).</p>
</td></tr>
<tr><td><code id="bgnbd.PlotTrackingInc_+3A_t.tot">T.tot</code></td>
<td>
<p>end of holdout period. Must be a single value, not a vector.</p>
</td></tr>
<tr><td><code id="bgnbd.PlotTrackingInc_+3A_actual.inc.tracking.data">actual.inc.tracking.data</code></td>
<td>
<p>vector containing the incremental number of
repeat transactions made by customers for each period in the total time
period (both calibration and holdout periods). See details.</p>
</td></tr>
<tr><td><code id="bgnbd.PlotTrackingInc_+3A_n.periods.final">n.periods.final</code></td>
<td>
<p>number of time periods in the calibration and
holdout periods. See details.</p>
</td></tr>
<tr><td><code id="bgnbd.PlotTrackingInc_+3A_hardie">hardie</code></td>
<td>
<p>if TRUE, use h2f1 instead of hypergeo.</p>
</td></tr>
<tr><td><code id="bgnbd.PlotTrackingInc_+3A_xlab">xlab</code></td>
<td>
<p>descriptive label for the x axis.</p>
</td></tr>
<tr><td><code id="bgnbd.PlotTrackingInc_+3A_ylab">ylab</code></td>
<td>
<p>descriptive label for the y axis.</p>
</td></tr>
<tr><td><code id="bgnbd.PlotTrackingInc_+3A_xticklab">xticklab</code></td>
<td>
<p>vector containing a label for each tick mark on the x axis.</p>
</td></tr>
<tr><td><code id="bgnbd.PlotTrackingInc_+3A_title">title</code></td>
<td>
<p>title placed on the top-center of the plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>actual.inc.tracking.data does not have to be in the same unit of time as the
T.cal data. T.tot will automatically be divided into periods to match the
length of actual.inc.tracking.data. See
<a href="#topic+bgnbd.ExpectedCumulativeTransactions">bgnbd.ExpectedCumulativeTransactions</a>.
</p>
<p>The holdout period should immediately follow the calibration period. This
function assume that all customers' calibration periods end on the same date,
rather than starting on the same date (thus customers' birth periods are
determined using max(T.cal) - T.cal rather than assuming that it is 0).
</p>


<h3>Value</h3>

<p>Matrix containing actual and expected incremental repeat
transactions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cdnowSummary)
cal.cbs &lt;- cdnowSummary$cbs
# cal.cbs already has column names required by method

# Cumulative repeat transactions made by all customers across calibration
# and holdout periods
cu.tracking &lt;- cdnowSummary$cu.tracking
# make the tracking data incremental
inc.tracking &lt;- dc.CumulativeToIncremental(cu.tracking)

# parameters estimated using bgnbd.EstimateParameters
est.params &lt;- c(0.243, 4.414, 0.793, 2.426)

# All parameters are in weeks; the calibration period lasted 39
# weeks and the holdout period another 39.
bgnbd.PlotTrackingInc(est.params, ,
                      T.cal = cal.cbs[,"T.cal"],
                      T.tot = 78,
                      actual.inc.tracking.data = inc.tracking, 
                      hardie = TRUE)
</code></pre>

<hr>
<h2 id='bgnbd.PlotTransactionRateHeterogeneity'>BG/NBD Plot Transaction Rate Heterogeneity</h2><span id='topic+bgnbd.PlotTransactionRateHeterogeneity'></span>

<h3>Description</h3>

<p>Plots and returns the estimated gamma distribution of lambda (customers'
propensities to purchase).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bgnbd.PlotTransactionRateHeterogeneity(params, lim = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bgnbd.PlotTransactionRateHeterogeneity_+3A_params">params</code></td>
<td>
<p>BG/NBD parameters - a vector with r, alpha, a, and b, in that
order. r and alpha are unobserved parameters for the NBD transaction
process. a and b are unobserved parameters for the Beta geometric dropout
process.</p>
</td></tr>
<tr><td><code id="bgnbd.PlotTransactionRateHeterogeneity_+3A_lim">lim</code></td>
<td>
<p>upper-bound of the x-axis. A number is chosen by the function if
none is provided.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This returns the distribution of each customer's Poisson parameter, which
determines the rate at which each customer buys.
</p>


<h3>Value</h3>

<p>Distribution of customers' propensities to purchase.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>params &lt;- c(0.243, 4.414, 0.793, 2.426)
bgnbd.PlotTransactionRateHeterogeneity(params)
params &lt;- c(0.53, 4.414, 0.793, 2.426)
bgnbd.PlotTransactionRateHeterogeneity(params)
</code></pre>

<hr>
<h2 id='bgnbd.pmf'>BG/NBD Probability Mass Function</h2><span id='topic+bgnbd.pmf'></span>

<h3>Description</h3>

<p>Probability mass function for the BG/NBD.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bgnbd.pmf(params, t, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bgnbd.pmf_+3A_params">params</code></td>
<td>
<p>BG/NBD parameters - a vector with r, alpha, a, and b, in that
order. r and alpha are unobserved parameters for the NBD transaction
process. a and b are unobserved parameters for the Beta geometric dropout
process.</p>
</td></tr>
<tr><td><code id="bgnbd.pmf_+3A_t">t</code></td>
<td>
<p>length end of time period for which probability is being computed.
May also be a vector.</p>
</td></tr>
<tr><td><code id="bgnbd.pmf_+3A_x">x</code></td>
<td>
<p>number of repeat transactions by a random customer in the period
defined by t. May also be a vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>P(X(t)=x | r, alpha, a, b). Returns the probability that a customer makes x
repeat transactions in the time interval (0, t].
</p>
<p>Parameters t and x may be vectors. The standard rules for vector operations
apply - if they are not of the same length, the shorter vector will be
recycled (start over at the first element) until it is as long as the longest
vector. It is advisable to keep vectors to the same length and to use single
values for parameters that are to be the same for all calculations. If one of
these parameters has a length greater than one, the output will be a vector
of probabilities.
</p>


<h3>Value</h3>

<p>Probability of X(t)=x conditional on model parameters. If t and/or x
has a length greater than one, a vector of probabilities will be returned.
</p>


<h3>References</h3>

<p>Fader, Peter S.; Hardie, Bruce G.S.and Lee, Ka Lok. “Computing
P(alive) Using the BG/NBD Model.” December. 2008.
<a href="http://www.brucehardie.com/notes/021/palive_for_BGNBD.pdf">Web.</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>params &lt;- c(0.243, 4.414, 0.793, 2.426)
# probability that a customer will make 10 repeat transactions in the
# time interval (0,2]
bgnbd.pmf(params, t=2, x=10)
# probability that a customer will make no repeat transactions in the
# time interval (0,39]
bgnbd.pmf(params, t=39, x=0)

# Vectors may also be used as arguments:
bgnbd.pmf(params, t=30, x=11:20)
</code></pre>

<hr>
<h2 id='bgnbd.pmf.General'>Generalized BG/NBD Probability Mass Function</h2><span id='topic+bgnbd.pmf.General'></span>

<h3>Description</h3>

<p>Generalized probability mass function for the BG/NBD.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bgnbd.pmf.General(params, t.start, t.end, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bgnbd.pmf.General_+3A_params">params</code></td>
<td>
<p>BG/NBD parameters - a vector with r, alpha, a, and b, in that
order. r and alpha are unobserved parameters for the NBD transaction
process. a and b are unobserved parameters for the Beta geometric dropout
process.</p>
</td></tr>
<tr><td><code id="bgnbd.pmf.General_+3A_t.start">t.start</code></td>
<td>
<p>start of time period for which probability is being
calculated. It can also be a vector of values.</p>
</td></tr>
<tr><td><code id="bgnbd.pmf.General_+3A_t.end">t.end</code></td>
<td>
<p>end of time period for which probability is being calculated.
It can also be a vector of values.</p>
</td></tr>
<tr><td><code id="bgnbd.pmf.General_+3A_x">x</code></td>
<td>
<p>number of repeat transactions by a random customer in the period
defined by (t.start, t.end]. It can also be a vector of values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>P(X(t.start, t.end)=x | r, alpha, a, b). Returns the probability that a
customer makes x repeat transactions in the time interval (t.start, t.end].
</p>
<p>It is impossible for a customer to make a negative number of repeat
transactions. This function will return an error if it is given negative
times or a negative number of repeat transactions. This function will also
return an error if t.end is less than t.start.
</p>
<p>t.start, t.end, and x may be vectors. The standard rules for vector
operations apply - if they are not of the same length, shorter vectors will
be recycled (start over at the first element) until they are as long as the
longest vector. It is advisable to keep vectors to the same length and to use
single values for parameters that are to be the same for all calculations. If
one of these parameters has a length greater than one, the output will be a
vector of probabilities.
</p>


<h3>Value</h3>

<p>Probability of x transaction occuring between t.start and t.end
conditional on model parameters. If t.start, t.end, and/or x has a length
greater than one, a vector of probabilities will be returned.
</p>


<h3>References</h3>

<p>Fader, Peter S.; Hardie, Bruce G.S.and Lee, Ka Lok. “Computing
P(alive) Using the BG/NBD Model.” December. 2008.
<a href="http://www.brucehardie.com/notes/021/palive_for_BGNBD.pdf">Web.</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>params &lt;- c(0.243, 4.414, 0.793, 2.426)
# probability that a customer will make 10 repeat transactions in the
# time interval (1,2]
bgnbd.pmf.General(params, t.start=1, t.end=2, x=10)
# probability that a customer will make no repeat transactions in the
# time interval (39,78]
bgnbd.pmf.General(params, t.start=39, t.end=78, x=0)
</code></pre>

<hr>
<h2 id='cdnowElog'>CDNOW event log data</h2><span id='topic+cdnowElog'></span>

<h3>Description</h3>

<p>Data representing the purchasing behavior of 2,357 CDNOW customers between
January 1997 and June 1998, in event log format.
</p>


<h3>Format</h3>

<p>A comma-delimited file representing an event log with 6,919 entries.
It has 5 columns: The customer's ID in the master dataset, the customer's
ID in this dataset (which represents 1/10th of the master dataset), the
date of the transaction in the format &quot;%Y%m%d&quot; (e.g. 19970225), the number
of CDs purchased, and the dollar value of the transaction.
</p>


<h3>Details</h3>

<p>The customers in this data represent 1/10th of the cohort of customers who
made their first transactions with CDNOW in the first quarter of 1997. CDNOW
was an online retailer, selling music and related products on the web since
1994.
</p>


<h3>Source</h3>

<p>Can be found <a href="https://www.brucehardie.com/datasets/">online</a>.
</p>

<hr>
<h2 id='cdnowSummary'>CDNOW repeat transaction data summary</h2><span id='topic+cdnowSummary'></span>

<h3>Description</h3>

<p>Data representing the purchasing behavior of 2,357 CDNOW customers between
January 1997 and June 1998, summarized as a customer-by-time matrix and a
vector of cumulative weekly transactions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cdnowSummary)
</code></pre>


<h3>Format</h3>

<p>A named list of four elements:
</p>

<ul>
<li> <p><code>cbs</code>  A customer-by-time matrix with four columns: frequency (&quot;x&quot;), recency
(&quot;t.x&quot;), length of observation in the calibration period (&quot;T.cal&quot;), and
number of transactions in the holdout period (&quot;x.star&quot;). Each row represents
a customer.
</p>
</li>
<li> <p><code>cu.tracking</code>  A vector containing cumulative transactions for
every week in both the calibration and estimating periods (78 weeks total).
This vector contains the sum of transactions across all customers.
</p>
</li>
<li> <p><code>est.params</code>   A vector containing estimated values for the four Pareto/NBD
parameters: r, alpha, s, and beta, in that order. This estimation was made
using <code><a href="#topic+pnbd.EstimateParameters">pnbd.EstimateParameters</a></code>, and is included here to avoid having to
run the relatively time-consuming parameter estimation function in examples.
</p>
</li>
<li> <p><code>m.x</code>  A vector containing the average value of each customer's repeat
transactions. Used in examples for spend functions.
</p>
</li></ul>



<h3>Details</h3>

<p>The customers in this data represent 1/10th of the cohort of customers who
made their first transactions with CDNOW in the first quarter of 1997. CDNOW
was an online retailer, selling music and related products on the web since
1994.
</p>


<h3>Source</h3>

<p>The data was put together using data conversion functions included in
this package. The original event log is included (see <code><a href="#topic+cdnowElog">cdnowElog</a></code>).
</p>

<hr>
<h2 id='dc.BuildCBSFromCBTAndDates'>Build CBS matrix from CBT matrix</h2><span id='topic+dc.BuildCBSFromCBTAndDates'></span>

<h3>Description</h3>

<p>Given a customer-by-time matrix, yields the resulting
customer-by-sufficient-statistic matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dc.BuildCBSFromCBTAndDates(cbt, dates, per, cbt.is.during.cal.period = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dc.BuildCBSFromCBTAndDates_+3A_cbt">cbt</code></td>
<td>
<p>customer-by-time matrix. This is a matrix consisting of a row per
customer and a column per time period. It should contain numeric
information about a customer's transactions in every time period - either
the number of transactions in that time period (frequency), a 1 to indicate
that at least 1 transaction occurred (reach), or the average/total amount
spent in that time period.</p>
</td></tr>
<tr><td><code id="dc.BuildCBSFromCBTAndDates_+3A_dates">dates</code></td>
<td>
<p>if cbt.is.during.cal.period is TRUE, then dates is a data
frame with three columns: 1. the dates when customers made their first
purchases 2. the dates when customers made their last purchases 3. the date
of the end of the calibration period. if cbt.is.during.cal.period is FALSE,
then dates is a vector with two elements: 1. the date of the beginning of
the holdout period 2. the date of the end of the holdout period.</p>
</td></tr>
<tr><td><code id="dc.BuildCBSFromCBTAndDates_+3A_per">per</code></td>
<td>
<p>interval of time for customer-by-sufficient-statistic matrix.
May be &quot;day&quot;, &quot;week&quot;, &quot;month&quot;, &quot;quarter&quot;, or &quot;year&quot;.</p>
</td></tr>
<tr><td><code id="dc.BuildCBSFromCBTAndDates_+3A_cbt.is.during.cal.period">cbt.is.during.cal.period</code></td>
<td>
<p>if TRUE, indicates the customer-by-time
matrix is from the calibration period. If FALSE, indicates the
customer-by-time matrix is from the holdout period.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The customer-by-sufficient statistic matrix will contain the sum of the
statistic included in the customer-by-time matrix (see the cbt parameter),
the customer's last transaction date, and the total time period for which the
customer was observed.
</p>


<h3>Value</h3>

<p>Customer-by-sufficient-statistic matrix, with three columns:
frequency(&quot;x&quot;), recency(&quot;t.x&quot;) and total time observed(&quot;T.cal&quot;). See
details. Frequency is total transactions, not repeat transactions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>elog &lt;- dc.ReadLines(system.file("data/cdnowElog.csv", package="BTYD"),2,3,5)
elog[,"date"] &lt;- as.Date(elog[,"date"], "%Y%m%d")

# Transaction-flow models are about interpurchase times. Since we
# only know purchase times to the day, we merge all transaction on
# the same day. This example uses dc.MergeTransactionsOnSameDate
# to illustrate this; however, we could have simply used dc.CreateReachCBT
# instead of dc.CreateFreqCBT to obtain the same result.
merged.elog &lt;- dc.MergeTransactionsOnSameDate(elog)
cutoff.date &lt;- as.Date("1997-09-30")
freq.cbt &lt;- dc.CreateFreqCBT(merged.elog)
cal.freq.cbt &lt;- freq.cbt[,as.Date(colnames(freq.cbt)) &lt;= cutoff.date]
holdout.freq.cbt &lt;- freq.cbt[,as.Date(colnames(freq.cbt)) &gt; cutoff.date]

cal.start.dates.indices &lt;- dc.GetFirstPurchasePeriodsFromCBT(cal.freq.cbt)
cal.start.dates &lt;- as.Date(colnames(cal.freq.cbt)[cal.start.dates.indices])
cal.end.dates.indices &lt;- dc.GetLastPurchasePeriodsFromCBT(cal.freq.cbt)
cal.end.dates &lt;- as.Date(colnames(cal.freq.cbt)[cal.end.dates.indices])
T.cal.total &lt;- rep(cutoff.date, nrow(cal.freq.cbt))
cal.dates &lt;- data.frame(cal.start.dates, 
                        cal.end.dates, 
                        T.cal.total)

# Create calibration period customer-by-sufficient-statistic data frame,
# using weeks as the unit of time.
cal.cbs &lt;- dc.BuildCBSFromCBTAndDates(cal.freq.cbt, 
                                      cal.dates,
                                      per="week", 
                                      cbt.is.during.cal.period=TRUE)
# Force the calibration period customer-by-sufficient-statistic to only contain
# repeat transactions (required by BG/BB and Pareto/NBD models)
cal.cbs[,"x"] &lt;- cal.cbs[,"x"] - 1

holdout.start &lt;- cutoff.date+1
holdout.end &lt;- as.Date(colnames(holdout.freq.cbt)[ncol(holdout.freq.cbt)])
holdout.dates &lt;- c(holdout.start, holdout.end)

# Create holdout period customer-by-sufficient-statistic data frame, using weeks
# as the unit of time.
holdout.cbs &lt;- dc.BuildCBSFromCBTAndDates(holdout.freq.cbt, 
                                          holdout.dates,
                                          per="week", 
                                          cbt.is.during.cal.period=FALSE)                        
</code></pre>

<hr>
<h2 id='dc.BuildCBTFromElog'>Build Customer-by-Time Matrix from Event Log</h2><span id='topic+dc.BuildCBTFromElog'></span>

<h3>Description</h3>

<p>Creates a customer-by-time matrix from an event log.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dc.BuildCBTFromElog(elog, statistic = "freq")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dc.BuildCBTFromElog_+3A_elog">elog</code></td>
<td>
<p>event log, which is a data frame with columns for customer ID
(&quot;cust&quot;), date (&quot;date&quot;), and optionally other columns such as &quot;sales&quot;. Each
row represents an event, such as a transaction.. For the total spend and
average spend matrices, the event log must have a &quot;sales&quot; column. If the
dates are not formatted to be in the order year-month-day, the columns of
the customer-by-time matrix may not be ordered chronologically if the
&quot;date&quot; column does not consist of date objects (R will order them
alphabetically). This will cause problems with other functions, so it is
better to convert the date column to date objects before running this
function.</p>
</td></tr>
<tr><td><code id="dc.BuildCBTFromElog_+3A_statistic">statistic</code></td>
<td>
<p>either &quot;freq&quot;, &quot;reach&quot;, &quot;total.spend&quot;, or
&quot;average.spend&quot;. This determines what type of customer-by-time matrix is
returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Customer-by-time matrix.
</p>

<hr>
<h2 id='dc.check.model.params'>Check model params</h2><span id='topic+dc.check.model.params'></span>

<h3>Description</h3>

<p>Check model parameters for correctness.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dc.check.model.params(printnames, params, func)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dc.check.model.params_+3A_printnames">printnames</code></td>
<td>
<p>Names to print parameter errors.</p>
</td></tr>
<tr><td><code id="dc.check.model.params_+3A_params">params</code></td>
<td>
<p>Model parameters.</p>
</td></tr>
<tr><td><code id="dc.check.model.params_+3A_func">func</code></td>
<td>
<p>Function calling dc.check.model.params.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Stops the program if there is something wrong with the parameters.
</p>

<hr>
<h2 id='dc.compress.cbs'>Compress Customer-by-Sufficient-Statistic (CBS) Matrix</h2><span id='topic+dc.compress.cbs'></span>

<h3>Description</h3>

<p>Combines all customers with the same combination of recency, frequency and
length of calibration period in the customer-by-sufficient-statistic matrix,
and adds a fourth column labelled &quot;custs&quot; (with the number of customers
belonging in each row).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dc.compress.cbs(cbs, rounding = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dc.compress.cbs_+3A_cbs">cbs</code></td>
<td>
<p>calibration period CBS (customer by sufficient statistic). It
must contain columns for frequency (&quot;x&quot;), recency (&quot;t.x&quot;), and total time
observed (&quot;T.cal&quot;). Note that recency must be the time between the start of
the calibration period and the customer's last transaction, not the time
between the customer's last transaction and the end of the calibration
period.</p>
</td></tr>
<tr><td><code id="dc.compress.cbs_+3A_rounding">rounding</code></td>
<td>
<p>the function tries to ensure that there are similar
customers by rounding the customer-by-sufficient-statistic matrix first.
This parameter determines how many decimal places are left in the data.
Negative numbers are allowed; see the documentation for round in the base
package. As of the time of writing, that documentation states: &quot;Rounding to
a negative number of digits means rounding to a power of ten, so for
example round(x, digits = -2) rounds to the nearest hundred.&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is meant to be used to speed up log-likelihood and
parameter estimation functions in the Pareto/NBD (pnbd) set of functions.
How much faster those function run depends on how similar customers are.
You can used compressed CBS matrices in BG/NBD estimation too, but there
will be no speed gains there over using un-compressed CBS data.
</p>
<p>This function only takes columns &quot;x&quot;, &quot;t.x&quot;, and &quot;T.cal&quot; into account. All
other columns will be added together - for example, if you have a spend
column, the output's spend column will contain the total amount spent by all
customers with an identical recency, frequency, and time observed.
</p>


<h3>Value</h3>

<p>A customer-by-sufficient-statistic matrix with an additional column
&quot;custs&quot;, which contains the number of customers with each combination of
recency, frequency and length of calibration period.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a sample customer-by-sufficient-statistic matrix:
set.seed(7)
x &lt;- sample(1:4, 10, replace = TRUE)
t.x &lt;- sample(1:4, 10, replace = TRUE)
T.cal &lt;- rep(4, 10)
ave.spend &lt;- sample(10:20, 10, replace = TRUE)
cbs &lt;- cbind(x, t.x, T.cal, ave.spend)
cbs

# If cbs is printed, you would note that the following
# sets of rows have the same x, t.x and T.cal:
# (1, 6, 8); (3, 9)

dc.compress.cbs(cbs, 0)   # No rounding necessary

# Note that all additional columns (in this case, ave.spend)
# are aggregated by sum.
</code></pre>

<hr>
<h2 id='dc.CreateFreqCBT'>Create Frequency Customer-by-Time Matrix</h2><span id='topic+dc.CreateFreqCBT'></span>

<h3>Description</h3>

<p>Creates a customer-by-time matrix with total number of transactions per time period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dc.CreateFreqCBT(elog)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dc.CreateFreqCBT_+3A_elog">elog</code></td>
<td>
<p>event log, which is a data frame with columns for customer ID
(&quot;cust&quot;), date (&quot;date&quot;), and optionally other columns such as &quot;sales&quot;. Each
row represents an event, such as a transaction. If the dates are not
formatted to be in the order year-month-day, the columns of the
customer-by-time matrix may not be ordered chronologically if the &quot;date&quot;
column does not consist of date objects (R will order them alphabetically).
This will cause problems with other functions, so it is better to convert
the date column to date objects before running this function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Frequency customer-by-time matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create event log from file "cdnowElog.csv", which has
# customer IDs in the second column, dates in the third column, and
# sales numbers in the fifth column.
elog &lt;- dc.ReadLines(system.file("data/cdnowElog.csv", package="BTYD"),2,3,5)

# Given that the dates are in the order year-month-day,
# it is not strictly necessary to convert the date column
# to date formats. However, it is good practice:
elog[,"date"] &lt;- as.Date(elog[,"date"], "%Y%m%d")

freq.cbt &lt;- dc.CreateFreqCBT(elog)
</code></pre>

<hr>
<h2 id='dc.CreateReachCBT'>Create Reach Customer-by-Time Matrix</h2><span id='topic+dc.CreateReachCBT'></span>

<h3>Description</h3>

<p>Creates a customer-by-time matrix with 1's in periods that a customer made a
transaction and 0's otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dc.CreateReachCBT(elog)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dc.CreateReachCBT_+3A_elog">elog</code></td>
<td>
<p>event log, which is a data frame with columns for customer ID
(&quot;cust&quot;), date (&quot;date&quot;), and optionally other columns such as &quot;sales&quot;. Each
row represents an event, such as a transaction. If the dates are not
formatted to be in the order year-month-day, the columns of the
customer-by-time matrix may not be ordered chronologically if the &quot;date&quot;
column does not consist of date objects (R will order them alphabetically).
This will cause problems with other functions, so it is better to convert
the date column to date objects before running this function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Reach customer-by-time matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create event log from file "cdnowElog.csv", which has
# customer IDs in the second column, dates in the third column, and
# sales numbers in the fifth column.
elog &lt;- dc.ReadLines(system.file("data/cdnowElog.csv", package="BTYD"),2,3,5)

# Given that the dates are in the order year-month-day,
# it is not strictly necessary to convert the date column
# to date formats. However, it is good practice:
elog[,"date"] &lt;- as.Date(elog[,"date"], "%Y%m%d")

reach.cbt &lt;- dc.CreateReachCBT(elog)
</code></pre>

<hr>
<h2 id='dc.CreateSpendCBT'>Create Spend Customer-by-Time Matrix</h2><span id='topic+dc.CreateSpendCBT'></span>

<h3>Description</h3>

<p>Creates a customer-by-time matrix with spend per time period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dc.CreateSpendCBT(elog, is.avg.spend = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dc.CreateSpendCBT_+3A_elog">elog</code></td>
<td>
<p>event log, which is a data frame with columns for customer ID
(&quot;cust&quot;), date (&quot;date&quot;), and optionally other columns such as &quot;sales&quot;. Each
row represents an event, such as a transaction. If the dates are not
formatted to be in the order year-month-day, the columns of the
customer-by-time matrix may not be ordered chronologically if the &quot;date&quot;
column does not consist of date objects (R will order them alphabetically).
This will cause problems with other functions, so it is better to convert
the date column to date objects before running this function.</p>
</td></tr>
<tr><td><code id="dc.CreateSpendCBT_+3A_is.avg.spend">is.avg.spend</code></td>
<td>
<p>if TRUE, return average spend customer-by-time matrix;
else, return total spend customer-by-time matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Spend customer-by-time matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create event log from file "cdnowElog.csv", which has
# customer IDs in the second column, dates in the third column, and
# sales numbers in the fifth column.
elog &lt;- dc.ReadLines(system.file("data/cdnowElog.csv", package="BTYD"),2,3,5);

# Given that the dates are in the order year-month-day,
# it is not strictly necessary to convert the date column
# to date formats. However, it is good practice:
elog[,"date"] &lt;- as.Date(elog[,"date"], "%Y%m%d")

spend.cbt &lt;- dc.CreateSpendCBT(elog)
</code></pre>

<hr>
<h2 id='dc.CumulativeToIncremental'>Cumulative to Incremental</h2><span id='topic+dc.CumulativeToIncremental'></span>

<h3>Description</h3>

<p>Converts a vector of cumulative transactions to a vector of incremental transactions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dc.CumulativeToIncremental(cu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dc.CumulativeToIncremental_+3A_cu">cu</code></td>
<td>
<p>A vector containing cumulative transactions over time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of incremental transactions.
</p>

<hr>
<h2 id='dc.DissipateElog'>Dissipate Event Log</h2><span id='topic+dc.DissipateElog'></span>

<h3>Description</h3>

<p>Filters an event log, keeping a fraction of the original event log.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dc.DissipateElog(elog, dissipate.factor)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dc.DissipateElog_+3A_elog">elog</code></td>
<td>
<p>event log, which is a data frame with columns for customer ID
(&quot;cust&quot;), date (&quot;date&quot;), and optionally other columns such as &quot;sales&quot;. Each
row represents an event, such as a transaction.</p>
</td></tr>
<tr><td><code id="dc.DissipateElog_+3A_dissipate.factor">dissipate.factor</code></td>
<td>
<p>integer indicating how much of the dataset to
eliminate. It must be greater than 1 for the function to work.
(dissipate.factor-1)/(dissipate.factor) events will be removed from the
event log. For example, if 2 is provided, 1/2 of the event log is
eliminated, and if 10 is provided, 9/10 of the event log is eliminated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Reduced event log.
</p>

<hr>
<h2 id='dc.ElogToCbsCbt'>Convert Event Log to CBS and CBT Matrices</h2><span id='topic+dc.ElogToCbsCbt'></span>

<h3>Description</h3>

<p>Uses an event log to return calibration period CBT and CBS, holdout period
CBT and CBS, and summary data for each customer (including times of first and
last transactions).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dc.ElogToCbsCbt(
  elog,
  per = "week",
  T.cal = max(elog$date),
  T.tot = max(elog$date),
  merge.same.date = TRUE,
  cohort.birth.per = T.cal,
  dissipate.factor = 1,
  statistic = "freq"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dc.ElogToCbsCbt_+3A_elog">elog</code></td>
<td>
<p>event log, which is a data frame with columns for customer ID
(&quot;cust&quot;), date (&quot;date&quot;), and optionally other columns such as &quot;sales&quot;. Each
row represents an event, such as a transaction. The &quot;date&quot; column must
contain date objects, not character strings or factors.</p>
</td></tr>
<tr><td><code id="dc.ElogToCbsCbt_+3A_per">per</code></td>
<td>
<p>interval of time for customer-by-sufficient-statistic matrix.
May be &quot;day&quot;, &quot;week&quot;, &quot;month&quot;, &quot;quarter&quot;, or &quot;year&quot;.</p>
</td></tr>
<tr><td><code id="dc.ElogToCbsCbt_+3A_t.cal">T.cal</code></td>
<td>
<p>R date object indicating when the calibration period ends.</p>
</td></tr>
<tr><td><code id="dc.ElogToCbsCbt_+3A_t.tot">T.tot</code></td>
<td>
<p>T.tot    R date object indicating when holdout period ends.</p>
</td></tr>
<tr><td><code id="dc.ElogToCbsCbt_+3A_merge.same.date">merge.same.date</code></td>
<td>
<p>If TRUE, transactions from the same period count as
a single transaction instead of counting as multiple transactions.</p>
</td></tr>
<tr><td><code id="dc.ElogToCbsCbt_+3A_cohort.birth.per">cohort.birth.per</code></td>
<td>
<p>Time interval used to filter the event log. Can be
specified as a Date object or a vector of two Dates. If one date object is
used, the birth period is from the minimum date in the dataset through the
given date. If two dates are given, the birth period is set between
(inclusive) the two dates.</p>
</td></tr>
<tr><td><code id="dc.ElogToCbsCbt_+3A_dissipate.factor">dissipate.factor</code></td>
<td>
<p>integer indicating how much of the dataset to
eliminate. If left as 1, none of the dataset is eliminated.
(dissipate.factor-1)/(dissipate.factor) events will be removed from the
event log. For example, if 2 is provided, 1/2 of the event log is
eliminated, and if 10 is provided, 9/10 of the event log is eliminated.</p>
</td></tr>
<tr><td><code id="dc.ElogToCbsCbt_+3A_statistic">statistic</code></td>
<td>
<p>Determines type of CBT returned: can be: &quot;reach&quot;,
&quot;freq&quot;, &quot;total.spend&quot;, or &quot;average.spend.&quot; (note: spend requires $sales
column in elog)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function automatically removes customers' first transactions, meaning
that the output matrices will only contain repeat transaction information.
</p>


<h3>Value</h3>

<p>A list of items: - <code style="white-space: pre;">&#8288;$cal&#8288;</code> list with CBS and CBT from the calibration
period - <code style="white-space: pre;">&#8288;$holdout&#8288;</code> list with CBS and CBT from holdout period -
<code style="white-space: pre;">&#8288;$cust.data&#8288;</code> data frame with each customer's first and last transaction
details
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
# Create event log from file "cdnowElog.csv", which has
# customer IDs in the second column, dates in the third column, and
# sales numbers in the fifth column.
elog &lt;- dc.ReadLines(system.file("data/cdnowElog.csv", package="BTYD"),2,3,5)

elog[,"date"] &lt;- as.Date(elog[,"date"], "%Y%m%d")

data &lt;- dc.ElogToCbsCbt(elog, per="week", T.cal=as.Date("1997-09-30"))
</code></pre>

<hr>
<h2 id='dc.FilterCustByBirth'>Filter Customer by Birth</h2><span id='topic+dc.FilterCustByBirth'></span>

<h3>Description</h3>

<p>Filters an event log, keeping all transactions made by customers who made
their first transactions in the given time interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dc.FilterCustByBirth(elog, cohort.birth.per)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dc.FilterCustByBirth_+3A_elog">elog</code></td>
<td>
<p>event log, which is a data frame with columns for customer ID
(&quot;cust&quot;), date (&quot;date&quot;), and optionally other columns such as &quot;sales&quot;. Each
row represents an event, such as a transaction. The date column must be
formatted as Date objects.</p>
</td></tr>
<tr><td><code id="dc.FilterCustByBirth_+3A_cohort.birth.per">cohort.birth.per</code></td>
<td>
<p>Time interval used to filter the event log. Can be
specified as a Date object or a vector of two Dates. If one date object is
used, the birth period is from the minimum date in the dataset through the
given date. If two dates are given, the birth period is set between
(inclusive) the two dates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>event log with only rows from customers who made their first
transaction within the birth period.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create event log from file "cdnowElog.csv", which has
# customer IDs in the second column, dates in the third column, and
# sales numbers in the fifth column.
elog &lt;- dc.ReadLines(system.file("data/cdnowElog.csv", package="BTYD"),2,3,5)

# converting the date column to Date objects is
# necessary for this function.
elog$date &lt;- as.Date(elog$date, "%Y%m%d")

# starting date. Note that it must be a Date object.
start.date &lt;- as.Date("1997-01-01")
# ending date. Note that it must be a Date object.
end.date &lt;- as.Date("1997-01-31")

# Filter the elog to include only customers who made their
# first transaction in January 1997
filtered.elog &lt;- dc.FilterCustByBirth(elog, c(start.date, end.date))
</code></pre>

<hr>
<h2 id='dc.GetFirstPurchasePeriodsFromCBT'>Get First Purchase Periods from Customer-by-Time Matrix</h2><span id='topic+dc.GetFirstPurchasePeriodsFromCBT'></span>

<h3>Description</h3>

<p>Uses a customer-by-time matrix to return a vector containing the periods in
which customers made their first purchase.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dc.GetFirstPurchasePeriodsFromCBT(cbt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dc.GetFirstPurchasePeriodsFromCBT_+3A_cbt">cbt</code></td>
<td>
<p>customer-by-time matrix. This is a matrix consisting of a row
per customer and a column per time period. It should contain numeric
information about a customer's transactions in every time period - either
the number of transactions in that time period (frequency), a 1 to indicate
that at least 1 transaction occurred (reach), or the average/total amount
spent in that time period.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector containing the indices of periods in which customers made
their first transactions. To convert to actual dates (if your
customer-by-time matrix has dates as column names), use
colnames(cbt)[RESULT]
</p>

<hr>
<h2 id='dc.GetLastPurchasePeriodsFromCBT'>Get Last Purchase Periods from Customer-by-Time Matrix</h2><span id='topic+dc.GetLastPurchasePeriodsFromCBT'></span>

<h3>Description</h3>

<p>Uses a customer-by-time matrix to return a vector containing the periods in
which customers made their last purchase.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dc.GetLastPurchasePeriodsFromCBT(cbt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dc.GetLastPurchasePeriodsFromCBT_+3A_cbt">cbt</code></td>
<td>
<p>customer-by-time matrix. This is a matrix consisting of a row
per customer and a column per time period. It should contain numeric
information about a customer's transactions in every time period - either
the number of transactions in that time period (frequency), a 1 to indicate
that at least 1 transaction occurred (reach), or the average/total amount
spent in that time period.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector containing the indices of periods in which customers made
their last transactions. To convert to actual dates (if your
customer-by-time matrix has dates as column names), use
colnames(cbt)[RESULT]
</p>

<hr>
<h2 id='dc.InputCheck'>Check the inputs to functions that use this common pattern</h2><span id='topic+dc.InputCheck'></span>

<h3>Description</h3>

<p>A bunch of functions whose names start with <code>pnbd</code> take a set of four
parameters as their first argument, and then a set of vectors or scalars such
as <code>x</code> or <code>T.cal</code> as their subsequent arguments. This function
started out as pnbd.InputCheck() and it was meant to run input checks for any
number of such subsequent vector arguments, as long as they all met the same
requirements as <code>x</code>, <code>t.x</code> and <code>T.cal</code> in
<code><a href="#topic+pnbd.LL">pnbd.LL</a></code>: meaning, the length of the longest of these vectors is
a multiple of the lengths of all others, and all vectors are numeric and
positive.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dc.InputCheck(params, func, printnames = c("r", "alpha", "s", "beta"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dc.InputCheck_+3A_params">params</code></td>
<td>
<p>If used by <code>pnbd.[...]</code> functions, Pareto/NBD parameters
&ndash; a vector with r, alpha, s, and beta, in that order. See
<code><a href="#topic+pnbd.LL">pnbd.LL</a></code>. If used by <code>bgnbd.[...]</code> functions, BG/NBD
parameters &ndash; a vector with r, alpha, a, and b, in that order. See
<code><a href="#topic+bgnbd.LL">bgnbd.LL</a></code>. If used by <code>bgbb.[...]</code> functions, BG/BB
parameters &ndash; a vector with alpha, beta, gamma, and delta, in that order.
See <code><a href="#topic+bgbb.LL">bgbb.LL</a></code>. If used by <code>spend.[...]</code> functions, a
vector of gamma-gamma parameters &ndash; p, q, and gamma, in that order. See
<code><a href="#topic+spend.LL">spend.LL</a></code>.</p>
</td></tr>
<tr><td><code id="dc.InputCheck_+3A_func">func</code></td>
<td>
<p>Function calling dc.InputCheck</p>
</td></tr>
<tr><td><code id="dc.InputCheck_+3A_printnames">printnames</code></td>
<td>
<p>a string vector with the names of parameters to pass to
<code><a href="#topic+dc.check.model.params">dc.check.model.params</a></code></p>
</td></tr>
<tr><td><code id="dc.InputCheck_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With an extra argument, <code>printnames</code>, pnbd.InputCheck() could also
accommodate input checks for functions whose names start with <code>bgbb</code>,
<code>bgnbd</code>, and <code>spend</code> so it was basically useful everywhere. That's
when it became <code>dc.InputCheck()</code>. <code>params</code> can have any length as
long as that length is the same as the length of <code>printnames</code>, so
<code>dc.InputCheck()</code> can probably handle mixtures of distributions for
modeling BTYD behavior that are not yet implemented.
</p>
<p>By other arguments ... here we mean a bunch of named vectors that are used by
functions that call <code>dc.InputCheck</code>, such as x, t.x, T.cal, etc. The
standard rules for vector operations apply - if they are not of the same
length, shorter vectors will be recycled (start over at the first element)
until they are as long as the longest vector. Vector recycling is a good way
to get into trouble. Keep vectors to the same length and use single values
for parameters that are to be the same for all calculations. If one of these
parameters has a length greater than one, the output will be a vector of
probabilities.
</p>


<h3>Value</h3>

<p>If all is well, a data frame with everything you need in it, with
nrow() equal to the length of the longest vector in <code>...</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pnbd.LL">pnbd.LL</a></code>
<code><a href="#topic+pnbd.ConditionalExpectedTransactions">pnbd.ConditionalExpectedTransactions</a></code>
</p>

<hr>
<h2 id='dc.MakeRFmatrixCal'>Make Calibration Period Recency-Frequency Matrix</h2><span id='topic+dc.MakeRFmatrixCal'></span>

<h3>Description</h3>

<p>Make a calibration period recency-frequency matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dc.MakeRFmatrixCal(
  frequencies,
  periods.of.final.purchases,
  num.of.purchase.periods,
  holdout.frequencies = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dc.MakeRFmatrixCal_+3A_frequencies">frequencies</code></td>
<td>
<p>vector which indicates the number of repeat transactions
made by customers in the calibration period.</p>
</td></tr>
<tr><td><code id="dc.MakeRFmatrixCal_+3A_periods.of.final.purchases">periods.of.final.purchases</code></td>
<td>
<p>a vector indicating in which period
customers made their final purchases.</p>
</td></tr>
<tr><td><code id="dc.MakeRFmatrixCal_+3A_num.of.purchase.periods">num.of.purchase.periods</code></td>
<td>
<p>the number of transaction opportunities in
the calibration period.</p>
</td></tr>
<tr><td><code id="dc.MakeRFmatrixCal_+3A_holdout.frequencies">holdout.frequencies</code></td>
<td>
<p>an optional vector indicating the number of
transactions made by customers in the holdout period.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with all possible frequency-recency combinations, and the
number of customers with each combination. It contains columns for
frequency (&quot;x&quot;), recency (&quot;t.x&quot;), number of transaction opportunities in
the calibration period (&quot;n.cal&quot;), number of customers with this combination
of recency, frequency, and number of periods observed (&quot;custs&quot;), and
optionally, number of transactions in the holdout period (&quot;x.star&quot;).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>elog &lt;- dc.ReadLines(system.file("data/discreteSimElog.csv", package="BTYD"),1,2)
elog[,"date"] &lt;- as.Date(elog[,"date"])

cutoff.date &lt;- as.Date("1977-01-01")
cbt &lt;- dc.CreateReachCBT(elog)
cal.cbt &lt;- cbt[,as.Date(colnames(cbt)) &lt;= cutoff.date]
holdout.cbt &lt;- cbt[,as.Date(colnames(cbt)) &gt; cutoff.date]

cal.start.dates.indices &lt;- dc.GetFirstPurchasePeriodsFromCBT(cal.cbt)
cal.start.dates &lt;- as.Date(colnames(cal.cbt)[cal.start.dates.indices])
cal.end.dates.indices &lt;- dc.GetLastPurchasePeriodsFromCBT(cal.cbt)
cal.end.dates &lt;- as.Date(colnames(cal.cbt)[cal.end.dates.indices])
T.cal.total &lt;- rep(cutoff.date, nrow(cal.cbt))
cal.dates &lt;- data.frame(cal.start.dates, cal.end.dates, T.cal.total)

# Create calibration period customer-by-sufficient-statistic data frame,
# using years as the unit of time.
cal.cbs &lt;- dc.BuildCBSFromCBTAndDates(cal.cbt,
                                      cal.dates,
                                      per="year",
                                      cbt.is.during.cal.period=TRUE)

holdout.start &lt;- as.Date(colnames(holdout.cbt)[1])
holdout.end &lt;- as.Date(tail(colnames(holdout.cbt),n=1))
# The (-1) below is to remove the effect of the birth period - we are only
# interested in repeat transactions in the calibration period.
frequencies &lt;- (cal.cbs[,"x"] - 1)
periods.of.final.purchases &lt;- cal.cbs[,"t.x"]
num.of.purchase.periods &lt;- ncol(cal.cbt) - 1

# Create a calibration period recency-frequency matrix
cal.rf.matrix &lt;- dc.MakeRFmatrixCal(frequencies,
                                    periods.of.final.purchases,
                                    num.of.purchase.periods)
</code></pre>

<hr>
<h2 id='dc.MakeRFmatrixHoldout'>Make Holdout Period Recency-Frequency Matrix</h2><span id='topic+dc.MakeRFmatrixHoldout'></span>

<h3>Description</h3>

<p>Creates a recency-frequency matrix for the holdout period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dc.MakeRFmatrixHoldout(holdout.cbt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dc.MakeRFmatrixHoldout_+3A_holdout.cbt">holdout.cbt</code></td>
<td>
<p>holdout period frequency customer-by-time matrix. This
is a matrix consisting of a row per customer and a column per time period.
It should contain the number of transactions each customer made per time
period.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>recency-frequency matrix for the holdout period, with three columns:
frequency (&quot;x.star&quot;), recency (&quot;t.x.star&quot;), number of transaction
opportunities in the holdout period (&quot;n.star&quot;), and the number of customers
with each frequency-recency combination (&quot;custs&quot;).
</p>

<hr>
<h2 id='dc.MakeRFmatrixSkeleton'>Make Recency-Frequency Matrix Skeleton</h2><span id='topic+dc.MakeRFmatrixSkeleton'></span>

<h3>Description</h3>

<p>Creates a matrix with all possible recency and frequency combinations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dc.MakeRFmatrixSkeleton(n.periods)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dc.MakeRFmatrixSkeleton_+3A_n.periods">n.periods</code></td>
<td>
<p>number of transaction opportunities in the calibration
period.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Makes the structure in which to input data for recency-frequency matrices.
</p>


<h3>Value</h3>

<p>Matrix with two columns: frequency (&quot;x&quot;) and recency (&quot;t.x&quot;). All
possible recency-frequency combinations in the calibration period are
represented.
</p>

<hr>
<h2 id='dc.MergeCustomers'>Merge Customers</h2><span id='topic+dc.MergeCustomers'></span>

<h3>Description</h3>

<p>Takes two CBT or CBS matrices and ensures that the second one has the same
row names as the first.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dc.MergeCustomers(data.correct, data.to.correct)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dc.MergeCustomers_+3A_data.correct">data.correct</code></td>
<td>
<p>CBT or CBS with the correct customer IDs as row names.
Usually from the calibration period.</p>
</td></tr>
<tr><td><code id="dc.MergeCustomers_+3A_data.to.correct">data.to.correct</code></td>
<td>
<p>CBT or CBS which needs to be fixed (customer IDs
inserted). Usually from the holdout period.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Care should be taken in using this function. It inserts zero values in all
rows that were not in the original holdout period data. This behavior does
not cause a problem if using CBT matrices, but will cause a problem if using
CBS matrices (for example, the output will report all customers with a
holdout period length of zero). However, this particular issue is easily
fixed (see examples) and should not cause problems.
</p>
<p>A work-around to avoid using this function is presented in the example for
<code><a href="#topic+dc.BuildCBSFromCBTAndDates">dc.BuildCBSFromCBTAndDates</a></code> - build the full CBT and only use the columns
applying to each particular time period to construct separate CBTs, and from
them, CBSs. That is a much cleaner and less error-prone method; however, on
occasion the data will not be available in event log format and you may not
be able to construct a CBT for both time periods together.
</p>


<h3>Value</h3>

<p>Updated holdout period CBT or CBS.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>elog &lt;- dc.ReadLines(system.file("data/cdnowElog.csv", package="BTYD"),2,3,5)
elog[,"date"] &lt;- as.Date(elog[,"date"], "%Y%m%d")
cutoff.date &lt;- as.Date("1997-09-30")
cal.elog &lt;- elog[which(elog[,"date"] &lt;= cutoff.date),]
holdout.elog &lt;- elog[which(elog[,"date"] &gt; cutoff.date),]

# Create calibration period CBT from cal.elog
cal.reach.cbt &lt;- dc.CreateReachCBT(cal.elog)
# Create holdout period CBT from holdout.elog
holdout.reach.cbt &lt;- dc.CreateReachCBT(holdout.elog)

# Note the difference:
nrow(cal.reach.cbt)            # 2357 customers
nrow(holdout.reach.cbt)        # 684 customers

# Create a "fixed" holdout period CBT, with the same number
# of customers in the same order as the calibration period CBT
fixed.holdout.reach.cbt &lt;- dc.MergeCustomers(cal.reach.cbt, holdout.reach.cbt)
nrow(fixed.holdout.reach.cbt)  # 2357 customers

# You can verify that the above is correct by turning these into a CBS
# (see \code{\link{dc.BuildCBSFromCBTAndDates}} and using
# \code{\link{pnbd.PlotFreqVsConditionalExpectedFrequency}}, for example

# Alternatively, we can fix the CBS, instead of the CBS:

cal.start.dates.indices &lt;- dc.GetFirstPurchasePeriodsFromCBT(cal.reach.cbt)
cal.start.dates &lt;- as.Date(colnames(cal.reach.cbt)[cal.start.dates.indices])
cal.end.dates.indices &lt;- dc.GetLastPurchasePeriodsFromCBT(cal.reach.cbt)
cal.end.dates &lt;- as.Date(colnames(cal.reach.cbt)[cal.end.dates.indices])
T.cal.total &lt;- rep(cutoff.date, nrow(cal.reach.cbt))
cal.dates &lt;- data.frame(cal.start.dates, cal.end.dates, T.cal.total)

# Create calibration period customer-by-sufficient-statistic data frame,
# using weeks as the unit of time.
cal.cbs &lt;- dc.BuildCBSFromCBTAndDates(cal.reach.cbt,
                                      cal.dates,
                                      per="week",
                                      cbt.is.during.cal.period=TRUE)

# Force the calibration period customer-by-sufficient-statistic to only
# 	contain repeat transactions (required by BG/BB and Pareto/NBD models)
cal.cbs[,"x"] &lt;- cal.cbs[,"x"] - 1

holdout.start &lt;- cutoff.date+1
holdout.end &lt;- as.Date(colnames(fixed.holdout.reach.cbt)[ncol(fixed.holdout.reach.cbt)])
holdout.dates &lt;- c(holdout.start, holdout.end)

# Create holdout period customer-by-sufficient-statistic data frame,
# using weeks as the unit of time.
holdout.cbs &lt;- dc.BuildCBSFromCBTAndDates(holdout.reach.cbt,
                                          holdout.dates,
                                          per="week",
                                          cbt.is.during.cal.period=FALSE)

# Note the difference:
nrow(cal.cbs)            # 2357 customers
nrow(holdout.cbs)        # 684 customers

# Create a "fixed" holdout period CBS, with the same number
# of customers in the same order as the calibration period CBS
fixed.holdout.cbs &lt;- dc.MergeCustomers(cal.cbs, holdout.cbs)
nrow(fixed.holdout.cbs)  # 2357 customers

# Furthermore, this function will assign a zero value to all fields
# that were not in the original holdout period CBS. Since T.star is the
# same for all customers in the holdout period, we should fix that:
fixed.holdout.cbs[,"T.star"] &lt;- rep(max(fixed.holdout.cbs[,"T.star"]),nrow(fixed.holdout.cbs))
</code></pre>

<hr>
<h2 id='dc.MergeTransactionsOnSameDate'>Merge Transactions on Same Day</h2><span id='topic+dc.MergeTransactionsOnSameDate'></span>

<h3>Description</h3>

<p>Updates an event log; any transactions made by the same customer on the same
day are combined into one transaction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dc.MergeTransactionsOnSameDate(elog)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dc.MergeTransactionsOnSameDate_+3A_elog">elog</code></td>
<td>
<p>event log, which is a data frame with columns for customer ID
(&quot;cust&quot;), date (&quot;date&quot;), and optionally other columns such as &quot;sales&quot;. Each
row represents an event, such as a transaction.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Event log with transactions made by the same customer on the same
day merged into one transaction.
</p>

<hr>
<h2 id='dc.PlotLogLikelihoodContour'>Plot Log-Likelihood Contour</h2><span id='topic+dc.PlotLogLikelihoodContour'></span>

<h3>Description</h3>

<p>Makes a contour plot of a loglikelihood function that varies over two
designated parameters, centered around a set of previously estimated
parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dc.PlotLogLikelihoodContour(
  loglikelihood.fcn,
  vary.or.fix.param,
  predicted.params,
  ...,
  n.divs = 3,
  new.dev = FALSE,
  num.contour.lines = 10,
  zoom.percent = 0.9,
  allow.neg.params = FALSE,
  param.names = c("param 1", "param 2", "param 3", "param 4")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dc.PlotLogLikelihoodContour_+3A_loglikelihood.fcn">loglikelihood.fcn</code></td>
<td>
<p>log-likelihood function to plot.</p>
</td></tr>
<tr><td><code id="dc.PlotLogLikelihoodContour_+3A_vary.or.fix.param">vary.or.fix.param</code></td>
<td>
<p>a vector of strings containing either &quot;vary&quot; or
&quot;fix&quot;. The parameters in the same indices as &quot;vary&quot; will be plotted while
the other parameters will remain fixed at the estimated values. See
details.</p>
</td></tr>
<tr><td><code id="dc.PlotLogLikelihoodContour_+3A_predicted.params">predicted.params</code></td>
<td>
<p>estimated parameters.</p>
</td></tr>
<tr><td><code id="dc.PlotLogLikelihoodContour_+3A_...">...</code></td>
<td>
<p>all additional arguments required by the log-likelihood
function. For example, <code><a href="#topic+bgbb.rf.matrix.LL">bgbb.rf.matrix.LL</a></code> requires rf.matrix;
<code><a href="#topic+pnbd.cbs.LL">pnbd.cbs.LL</a></code> requires cal.cbs and hardie (defaults to TRUE); and <code><a href="#topic+bgnbd.cbs.LL">bgnbd.cbs.LL</a></code> requires
cal.cbs.</p>
</td></tr>
<tr><td><code id="dc.PlotLogLikelihoodContour_+3A_n.divs">n.divs</code></td>
<td>
<p>integer representing how fine-grained the contour plot is. A
higher value will produce a higher resolution plot with smoother contour
lines, but will take longer to plot. n.divs also affects the boundaries of
the contour plot; see details.</p>
</td></tr>
<tr><td><code id="dc.PlotLogLikelihoodContour_+3A_new.dev">new.dev</code></td>
<td>
<p>if TRUE, makes a new window for each contour plot.</p>
</td></tr>
<tr><td><code id="dc.PlotLogLikelihoodContour_+3A_num.contour.lines">num.contour.lines</code></td>
<td>
<p>number of contour lines to plot in the window.</p>
</td></tr>
<tr><td><code id="dc.PlotLogLikelihoodContour_+3A_zoom.percent">zoom.percent</code></td>
<td>
<p>determines boundaries of contour plot. See details.</p>
</td></tr>
<tr><td><code id="dc.PlotLogLikelihoodContour_+3A_allow.neg.params">allow.neg.params</code></td>
<td>
<p>if FALSE, the contour plot will not include negative
values (see details). This should be set to false for the BG/BB and
Pareto/NBD models.</p>
</td></tr>
<tr><td><code id="dc.PlotLogLikelihoodContour_+3A_param.names">param.names</code></td>
<td>
<p>a vector containing parameter names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The contour plot will have the first parameter labelled &quot;vary&quot; on the x-axis,
and the second parameter labelled &quot;vary&quot; on the y-axis. It will extend out by
(n.divs * zoom.percent) in both directions and both dimensions from the
estimated parameter values. The exception is if allow.neg.params is FALSE. In
this case, the contour plot will end at zero if it would have extended into
negative parameter values.
</p>
<p>The estimated parameter values will be indicated by the intersection of two
red lines.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dc.PlotLogLikelihoodContours">dc.PlotLogLikelihoodContours</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># **Examples for BG/BB model:
data(donationsSummary)
rf.matrix &lt;- donationsSummary$rf.matrix

# starting-point parameters
bgbb.startingparams &lt;- c(1, 1, 0.5, 3)
# estimated parameters
bgbb.est.params &lt;- bgbb.EstimateParameters(rf.matrix, bgbb.startingparams)

# set up parameter names for a more descriptive result
bgbb.param.names &lt;- c("alpha", "beta", "gamma", "delta")

# plot a log-likelihood contour of alpha and beta, the unobserved
# parameters for the beta-Bernoulli transaction process of the BG/BB.
# Note that allow.neg.params has been set to false as BG/BB parameters
# cannot be negative:
dc.PlotLogLikelihoodContour(bgbb.rf.matrix.LL, 
                            c("vary", "vary", "fix", "fix"), 
                            bgbb.est.params, 
                            rf.matrix = rf.matrix, 
                            n.divs = 15, 
                            num.contour.lines = 15, 
                            zoom.percent = 0.2, 
                            allow.neg.params = FALSE, 
                            param.names = bgbb.param.names)

# plot a log-likelihood contour of gamma and delta, the unobserved
# parameters for the beta-geometric dropout process of the BG/BB.
# Note that allow.neg.params has been set to false as BG/BB parameters
# cannot be negative:
dc.PlotLogLikelihoodContour(bgbb.rf.matrix.LL, 
                            c("fix", "fix", "vary", "vary"), 
                            bgbb.est.params, 
                            rf.matrix = rf.matrix, 
                            n.divs = 15, 
                            num.contour.lines = 15, 
                            zoom.percent = 0.2, 
                            allow.neg.params = FALSE, 
                            param.names = bgbb.param.names)

# **Example for Pareto/NBD model:
data(cdnowSummary)
cbs &lt;- cdnowSummary$cbs

# Speed up calculations:
cbs &lt;- dc.compress.cbs(cbs)

# parameters estimated using pnbd.EstimateParameters
pnbd.est.params &lt;- cdnowSummary$est.params

# set up parameter names for a more descriptive result
pnbd.param.names &lt;- c("r", "alpha", "s", "beta")

# plot a log-likelihood contour of r and s, the shape parameters
# of the transaction and dropout process models (respectively).
# Note that allow.neg.params has been set to false as Pareto/NBD
# parameters cannot be negative:
dc.PlotLogLikelihoodContour(pnbd.cbs.LL, 
                            c("vary", "fix", "vary", "fix"), 
                            pnbd.est.params, 
                            cal.cbs = cbs, 
                            hardie = TRUE,
                            n.divs = 20, 
                            num.contour.lines = 20, 
                            zoom.percent = 0.1, 
                            allow.neg.params = FALSE, 
                            param.names = pnbd.param.names)

# **Example for BG/NBD model:
data(cdnowSummary)
cbs &lt;- cdnowSummary$cbs

# parameters estimated using bgnbd.EstimateParameters
bgnbd.est.params &lt;- cdnowSummary$est.params

# set up parameter names for a more descriptive result
bgnbd.param.names &lt;- c("r", "alpha", "s", "beta")

# plot a log-likelihood contour of r and s, the shape parameters
# of the transaction and dropout process models (respectively).
# Note that allow.neg.params has been set to false as BG/NBD
# parameters cannot be negative:
dc.PlotLogLikelihoodContour(bgnbd.cbs.LL, 
                            c("vary", "fix", "vary", "fix"), 
                            bgnbd.est.params, 
                            cal.cbs = cbs, 
                            n.divs = 20, 
                            num.contour.lines = 20, 
                            zoom.percent = 0.1, 
                            allow.neg.params = FALSE, 
                            param.names = bgnbd.param.names)
</code></pre>

<hr>
<h2 id='dc.PlotLogLikelihoodContours'>Plot Log-Likelihood Contours</h2><span id='topic+dc.PlotLogLikelihoodContours'></span>

<h3>Description</h3>

<p>Creates a set of contour plots, such that there is a contour plot for every
pair of parameters varying.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dc.PlotLogLikelihoodContours(
  loglikelihood.fcn,
  predicted.params,
  ...,
  n.divs = 2,
  multiple.screens = FALSE,
  num.contour.lines = 10,
  zoom.percent = 0.9,
  allow.neg.params = FALSE,
  param.names = c("param 1", "param 2", "param 3", "param 4")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dc.PlotLogLikelihoodContours_+3A_loglikelihood.fcn">loglikelihood.fcn</code></td>
<td>
<p>log-likelihood function to plot.</p>
</td></tr>
<tr><td><code id="dc.PlotLogLikelihoodContours_+3A_predicted.params">predicted.params</code></td>
<td>
<p>estimated parameters.</p>
</td></tr>
<tr><td><code id="dc.PlotLogLikelihoodContours_+3A_...">...</code></td>
<td>
<p>all additional arguments required by the log-likelihood
function. For example, <code><a href="#topic+bgbb.rf.matrix.LL">bgbb.rf.matrix.LL</a></code> requires rf.matrix;
<code><a href="#topic+pnbd.cbs.LL">pnbd.cbs.LL</a></code> requires cal.cbs and hardie (defaults to TRUE); and <code><a href="#topic+bgnbd.cbs.LL">bgnbd.cbs.LL</a></code> requires
cal.cbs.</p>
</td></tr>
<tr><td><code id="dc.PlotLogLikelihoodContours_+3A_n.divs">n.divs</code></td>
<td>
<p>integer representing how fine-grained the contour plot is. A
higher value will produce a higher resolution plot with smoother contour
lines, but will take longer to plot. n.divs also affects the boundaries of
the contour plot; see details.</p>
</td></tr>
<tr><td><code id="dc.PlotLogLikelihoodContours_+3A_multiple.screens">multiple.screens</code></td>
<td>
<p>if TRUE, plots each contour plot on a separate R graphics window.</p>
</td></tr>
<tr><td><code id="dc.PlotLogLikelihoodContours_+3A_num.contour.lines">num.contour.lines</code></td>
<td>
<p>number of contour lines to plot in the window.</p>
</td></tr>
<tr><td><code id="dc.PlotLogLikelihoodContours_+3A_zoom.percent">zoom.percent</code></td>
<td>
<p>determines boundaries of contour plot. See details.</p>
</td></tr>
<tr><td><code id="dc.PlotLogLikelihoodContours_+3A_allow.neg.params">allow.neg.params</code></td>
<td>
<p>if FALSE, the contour plot will not include negative
values (see details). This should be set to false for the BG/BB and
Pareto/NBD models.</p>
</td></tr>
<tr><td><code id="dc.PlotLogLikelihoodContours_+3A_param.names">param.names</code></td>
<td>
<p>a vector containing parameter names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each contour plot, the non-varying parameters are kept constant at the
predicted values.
</p>
<p>The contour will extend out by (n.divs * zoom.percent) in both directions and
both dimensions from the estimated parameter values. The exception is if
allow.neg.params is FALSE. In this case, the contour plot will end at zero if
it would have extended into negative parameter values.
</p>
<p>The estimated parameter values will be indicated by the intersection of two
red lines.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dc.PlotLogLikelihoodContour">dc.PlotLogLikelihoodContour</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># **Example for BG/BB model:
data(donationsSummary)
rf.matrix &lt;- donationsSummary$rf.matrix

# starting-point parameters
bgbb.startingparams &lt;- c(1, 1, 0.5, 3)
# estimated parameters
bgbb.est.params &lt;- bgbb.EstimateParameters(rf.matrix, bgbb.startingparams)

# set up parameter names for a more descriptive result
bgbb.param.names &lt;- c("alpha", "beta", "gamma", "delta")

# plot-log likelihood contours:
dc.PlotLogLikelihoodContours(bgbb.rf.matrix.LL,
                             bgbb.est.params, 
                             rf.matrix = rf.matrix, 
                             n.divs = 5, 
                             num.contour.lines = 8, 
                             zoom.percent = 0.3, 
                             allow.neg.params = FALSE, 
                             param.names = bgbb.param.names)

# **Example for Pareto/NBD model:
data(cdnowSummary)
cbs &lt;- cdnowSummary$cbs

# Speed up calculations:
cbs &lt;- dc.compress.cbs(cbs)

# parameters estimated using pnbd.EstimateParameters
pnbd.est.params &lt;- cdnowSummary$est.params

# set up parameter names for a more descriptive result
pnbd.param.names &lt;- c("r", "alpha", "s", "beta")

# plot log-likelihood contours:
dc.PlotLogLikelihoodContours(pnbd.cbs.LL, 
                             pnbd.est.params, 
                             cal.cbs = cbs, 
                             hardie = TRUE,
                             n.divs = 5, 
                             num.contour.lines = 15, 
                             zoom.percent = 0.3, 
                             allow.neg.params = FALSE, 
                             param.names = pnbd.param.names)

# **Example for BG/NBD model:
data(cdnowSummary)
cbs &lt;- cdnowSummary$cbs

# parameters estimated using bgnbd.EstimateParameters
bgnbd.est.params &lt;- cdnowSummary$est.params

# set up parameter names for a more descriptive result
bgnbd.param.names &lt;- c("r", "alpha", "s", "beta")

# plot log-likelihood contours:
dc.PlotLogLikelihoodContours(bgnbd.cbs.LL, 
                             bgnbd.est.params, 
                             cal.cbs = cbs, 
                             n.divs = 5, 
                             num.contour.lines = 15, 
                             zoom.percent = 0.3, 
                             allow.neg.params = FALSE, 
                             param.names = bgnbd.param.names)
</code></pre>

<hr>
<h2 id='dc.ReadLines'>Read Lines</h2><span id='topic+dc.ReadLines'></span>

<h3>Description</h3>

<p>Given a .csv file that throws errors when read in by the usual read.csv and read.table methods,
loops through the file line-by-line and picks out the customer, date, and sales (optional)
transaction data to return an event log.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dc.ReadLines(csv.filename, cust.idx, date.idx, sales.idx = -1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dc.ReadLines_+3A_csv.filename">csv.filename</code></td>
<td>
<p>The name of the comma-delimited file to be read. This file must contain headers.</p>
</td></tr>
<tr><td><code id="dc.ReadLines_+3A_cust.idx">cust.idx</code></td>
<td>
<p>The index of the customer ID column in the comma-delimited file.</p>
</td></tr>
<tr><td><code id="dc.ReadLines_+3A_date.idx">date.idx</code></td>
<td>
<p>The index of the date column in the comma-delimited file.</p>
</td></tr>
<tr><td><code id="dc.ReadLines_+3A_sales.idx">sales.idx</code></td>
<td>
<p>The index of the sales column in the comma-delimited file.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Once this function has been run, you may need to convert the date column to Date objects for
the event log to work with other functions in this library. See the as.Date function in the
<code>base</code> R package for more details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create event log from file "cdnowElog.csv", which has
# customer IDs in the second column, dates in the third column, and
# sales numbers in the fifth column.
elog &lt;- dc.ReadLines(system.file("data/cdnowElog.csv", package="BTYD"),2,3,5)

# convert date column to date objects, as required by some other functions
elog$date &lt;- as.Date(elog$date, "$Y%m%d")
</code></pre>

<hr>
<h2 id='dc.RemoveTimeBetween'>Remove Time Between</h2><span id='topic+dc.RemoveTimeBetween'></span>

<h3>Description</h3>

<p>This function creates a new event log, with time in the middle removed. Used,
for example, in sports with off-seasons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dc.RemoveTimeBetween(elog, day1, day2, day3, day4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dc.RemoveTimeBetween_+3A_elog">elog</code></td>
<td>
<p>event log, which is a data frame with columns for customer ID
(&quot;cust&quot;), date (&quot;date&quot;), and optionally other columns such as &quot;sales&quot;. Each
row represents an event, such as a transaction. The &quot;date&quot; column must
consist of date objects, not character strings.</p>
</td></tr>
<tr><td><code id="dc.RemoveTimeBetween_+3A_day1">day1</code></td>
<td>
<p>date of beginning of first period. Must be a date object.</p>
</td></tr>
<tr><td><code id="dc.RemoveTimeBetween_+3A_day2">day2</code></td>
<td>
<p>date of end of first period. Must be a date object.</p>
</td></tr>
<tr><td><code id="dc.RemoveTimeBetween_+3A_day3">day3</code></td>
<td>
<p>date of beginning of second period. Must be a date object.</p>
</td></tr>
<tr><td><code id="dc.RemoveTimeBetween_+3A_day4">day4</code></td>
<td>
<p>date of third period. Must be a date object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The four date parameters must be in ascending order.
</p>


<h3>Value</h3>

<p>list - <code>elog1</code> the event log with all elog$date entries between day1
and day2 - <code>elog2</code> the event with all elog$date entries between day3 and
day4 - <code>elog3</code> elog1 combined with elog2, with all dates from elog2 reduced
by the time removed between elog1 and elog2
</p>


<h3>Examples</h3>

<pre><code class='language-R'>elog &lt;- dc.ReadLines(system.file("data/cdnowElog.csv", package="BTYD"),2,3,5)
elog[,"date"] &lt;- as.Date(elog[,"date"], "%Y%m%d")

# Use the cdnow data to return a 6 month event log for January, February,
# March, October, November, December.
period.one.start &lt;- as.Date("1997-01-01")
period.one.end &lt;- as.Date("1997-03-31")
period.two.start &lt;- as.Date("1997-10-01")
period.two.end &lt;- as.Date("1997-12-31")
reduced.elog &lt;- dc.RemoveTimeBetween(elog, period.one.start, period.one.end,
                                     period.two.start, period.two.end)

# Note that the new elog will go up to June 30 at a maximum, since we
# are only using 6 months of data starting on January 1
max(reduced.elog$elog3$date)  # "1997-06-30"
</code></pre>

<hr>
<h2 id='dc.SplitUpElogForRepeatTrans'>Split Up Event Log for Repeat Transactions</h2><span id='topic+dc.SplitUpElogForRepeatTrans'></span>

<h3>Description</h3>

<p>Turns an event log into a repeat transaction event log, removing customers'
first transactions. Also returns a data frame with information about
customers' first and last transactions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dc.SplitUpElogForRepeatTrans(elog)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dc.SplitUpElogForRepeatTrans_+3A_elog">elog</code></td>
<td>
<p>event log, which is a data frame with columns for customer ID
(&quot;cust&quot;), date (&quot;date&quot;), and optionally other columns such as &quot;sales&quot;. Each
row represents an event, such as a transaction. The &quot;date&quot; column must
contain date objects, not character strings or factors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list: - <code>repeat.trans.elog</code>  an event log containing only
repeat transactions - <code>cust.data</code>  data frame containing the first and last
transaction information for each customer
</p>

<hr>
<h2 id='dc.WriteLine'>Write Line</h2><span id='topic+dc.WriteLine'></span>

<h3>Description</h3>

<p>Writes any number of arguments to the console.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dc.WriteLine(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dc.WriteLine_+3A_...">...</code></td>
<td>
<p>objects to print to the R console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The code is literally: cat(..., fill=TRUE); flush.console();
</p>

<hr>
<h2 id='discreteSimElog'>Discrete simulated annual event log data</h2><span id='topic+discreteSimElog'></span>

<h3>Description</h3>

<p>Data simulated using BG/BB model assumptions. Contains annual transaction
behavior for a period of 14 years, for a cohort of 10,000 customers who made
their first transactions in 1970.
</p>


<h3>Format</h3>

<p>A comma-delimited file representing an event log with 52,432 entries.
It has 2 columns: The customer's ID and the date of the transaction in
standard R date format.
</p>


<h3>Details</h3>

<p>This dataset was simulated in order to illustrate certain data-conversion
functions (see <code><a href="#topic+dc.MakeRFmatrixCal">dc.MakeRFmatrixCal</a></code>).
</p>

<hr>
<h2 id='donationsSummary'>Discrete donation data summary</h2><span id='topic+donationsSummary'></span>

<h3>Description</h3>

<p>This dataset contains a recency-frequency matrix capturing the discrete
transaction behavior of 11,104 customers over 6 transaction opportunities,
summarized as a recency-frequency matrix and a vector of annual transactions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(donationsSummary)
</code></pre>


<h3>Format</h3>

<p>A named list:
</p>

<dl>
<dt>$rf.matrix</dt><dd><p>A matrix with 22 rows (for each possible
recency-frequency combination in 6 calibration period transaction
opportunities) and 4 columns: number of transactions during the calibration
period (&quot;x&quot;), recency in the calibration period (&quot;t.x&quot;), number of
transaction opportunities in the calibration period (&quot;n.cal&quot;), and number
of customers with this recency-frequency combination in the calibration
period (&quot;custs&quot;).</p>
</dd>
<dt>$rf.matrix.holdout</dt><dd><p>A matrix with 15 rows (for each possible
recency-frequency combination in 5 holdout period transaction
opportunities) and 4 columns: number of transactions during the holdout
period (&quot;x.star&quot;), recency in the holdout period (&quot;t.x.star&quot;), number of
transaction opportunities in the holdout period (&quot;n.star&quot;), and number of
customers with the recency-frequency combination in the holdout period
(&quot;custs&quot;).</p>
</dd>
<dt>$x.star</dt><dd><p>A vector with 22 elements, containing the number
of transactions made by each calibration period recency-frequency bin in
the holdout period. It is in the same order as <code>$rf.matrix.</code></p>
</dd>
<dt>$annual.sales</dt><dd><p>A vector with 11 elements, containing the number of
transactions made by all customers in each time period in both the
calibration and holdout periods.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Data from &quot;a major nonprofit organization located in the midwestern United
States that is funded in large part by donations from individuals. In 1995
the organization &quot;acquired&quot; 11,104 first-time supporters; in each of the
following six years, these individuals either did or did not support the
organization.&quot;
</p>
<p>This dataset contains, for each possible in-sample recency/frequency
combination in the 1995 cohort, the number of customers and the number of
transactions they made during the validation period.
</p>


<h3>Source</h3>

<p>Data can be found online at <a href="http://www.brucehardie.com/notes/010/">http://www.brucehardie.com/notes/010/</a>
(Associated Excel spreadsheet)
</p>


<h3>References</h3>

<p>Fader, Peter S., Bruce G.S. Hardie, and Jen Shang. “Customer-Base
Analysis in a Discrete-Time Noncontractual Setting.” <em>Marketing Science</em>
29(6), pp. 1086-1108. 2010. INFORMS. <a href="http://www.brucehardie.com/notes/020/">http://www.brucehardie.com/notes/020/</a>
</p>

<hr>
<h2 id='h2f1'>Use Bruce Hardie's Gaussian hypergeometric implementation</h2><span id='topic+h2f1'></span>

<h3>Description</h3>

<p>In benchmarking <code><a href="#topic+pnbd.LL">pnbd.LL</a></code> runs more quickly and
it returns the same results if it uses this helper instead of
<code><a href="hypergeo.html#topic+hypergeo">hypergeo</a></code>, which is the default. But <code>h2f1</code>
is such a barebones function that in some edge cases it will keep
going until you get a segfault, where <code><a href="hypergeo.html#topic+hypergeo">hypergeo</a></code>
would have failed with a proper error message.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h2f1(a, b, c, z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="h2f1_+3A_a">a</code></td>
<td>
<p>counterpart to A in <code><a href="hypergeo.html#topic+hypergeo">hypergeo</a></code></p>
</td></tr>
<tr><td><code id="h2f1_+3A_b">b</code></td>
<td>
<p>counterpart to B in <code><a href="hypergeo.html#topic+hypergeo">hypergeo</a></code></p>
</td></tr>
<tr><td><code id="h2f1_+3A_c">c</code></td>
<td>
<p>counterpart to C in <code><a href="hypergeo.html#topic+hypergeo">hypergeo</a></code></p>
</td></tr>
<tr><td><code id="h2f1_+3A_z">z</code></td>
<td>
<p>counterpart to z in <code><a href="hypergeo.html#topic+hypergeo">hypergeo</a></code></p>
</td></tr>
</table>


<h3>References</h3>

<p>Fader, Peter S., and Bruce G.S. Hardie. &quot;A Note on Deriving the Pareto/NBD Model and
Related Expressions.&quot; November. 2005. Web. <a href="http://www.brucehardie.com/notes/008/">http://www.brucehardie.com/notes/008/</a>
</p>


<h3>See Also</h3>

<p><code><a href="hypergeo.html#topic+hypergeo">hypergeo</a></code>
</p>

<hr>
<h2 id='pnbd.cbs.LL'>Pareto/NBD Log-Likelihood</h2><span id='topic+pnbd.cbs.LL'></span>

<h3>Description</h3>

<p>Calculates the log-likelihood of the Pareto/NBD model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pnbd.cbs.LL(params, cal.cbs, hardie = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pnbd.cbs.LL_+3A_params">params</code></td>
<td>
<p>Pareto/NBD parameters - a vector with r, alpha, s, and beta, in
that order. r and alpha are unobserved parameters for the NBD transaction
process. s and beta are unobserved parameters for the Pareto (exponential
gamma) dropout process.</p>
</td></tr>
<tr><td><code id="pnbd.cbs.LL_+3A_cal.cbs">cal.cbs</code></td>
<td>
<p>calibration period CBS (customer by sufficient statistic). It
must contain columns for frequency (&quot;x&quot;), recency (&quot;t.x&quot;), and total time
observed (&quot;T.cal&quot;). Note that recency must be the time between the start of
the calibration period and the customer's last transaction, not the time
between the customer's last transaction and the end of the calibration
period. If your data is compressed (see <code><a href="#topic+dc.compress.cbs">dc.compress.cbs</a></code>), a
fourth column labelled &quot;custs&quot; (number of customers with a specific
combination of recency, frequency and length of calibration period) will
make this function faster.</p>
</td></tr>
<tr><td><code id="pnbd.cbs.LL_+3A_hardie">hardie</code></td>
<td>
<p>if TRUE, use <code><a href="#topic+h2f1">h2f1</a></code> instead of
<code><a href="hypergeo.html#topic+hypergeo">hypergeo</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The log-likelihood of the provided data.
</p>


<h3>References</h3>

<p>Fader, Peter S., and Bruce G.S. Hardie. &quot;A Note on Deriving the
Pareto/NBD Model and Related Expressions.&quot; November. 2005. Web.
<a href="http://www.brucehardie.com/notes/008/">http://www.brucehardie.com/notes/008/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pnbd.EstimateParameters">pnbd.EstimateParameters</a></code>
</p>
<p><code><a href="#topic+pnbd.LL">pnbd.LL</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cdnowSummary)
cal.cbs &lt;- cdnowSummary$cbs
# cal.cbs already has column names required by method

# random assignment of parameters
params &lt;- c(0.5, 8, 0.7, 10)
# returns the log-likelihood of the given parameters
pnbd.cbs.LL (params, cal.cbs, TRUE)

# compare the speed and results to the following:
cal.cbs.compressed &lt;- dc.compress.cbs(cal.cbs)
pnbd.cbs.LL (params, cal.cbs.compressed, TRUE)
</code></pre>

<hr>
<h2 id='pnbd.ConditionalExpectedTransactions'>Pareto/NBD Conditional Expected Transactions</h2><span id='topic+pnbd.ConditionalExpectedTransactions'></span>

<h3>Description</h3>

<p>Uses Pareto/NBD model parameters and a customer's past transaction behavior
to return the number of transactions they are expected to make in a given
time period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pnbd.ConditionalExpectedTransactions(
  params,
  T.star,
  x,
  t.x,
  T.cal,
  hardie = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pnbd.ConditionalExpectedTransactions_+3A_params">params</code></td>
<td>
<p>Pareto/NBD parameters - a vector with r, alpha, s, and beta, in
that order. r and alpha are unobserved parameters for the NBD transaction
process. s and beta are unobserved parameters for the Pareto (exponential
gamma) dropout process.</p>
</td></tr>
<tr><td><code id="pnbd.ConditionalExpectedTransactions_+3A_t.star">T.star</code></td>
<td>
<p>length of time for which we are calculating the expected number
of transactions.</p>
</td></tr>
<tr><td><code id="pnbd.ConditionalExpectedTransactions_+3A_x">x</code></td>
<td>
<p>number of repeat transactions in the calibration period T.cal, or a
vector of calibration period frequencies.</p>
</td></tr>
<tr><td><code id="pnbd.ConditionalExpectedTransactions_+3A_t.x">t.x</code></td>
<td>
<p>time of most recent repeat transaction, or a vector of recencies.</p>
</td></tr>
<tr><td><code id="pnbd.ConditionalExpectedTransactions_+3A_t.cal">T.cal</code></td>
<td>
<p>length of calibration period, or a vector of calibration period
lengths.</p>
</td></tr>
<tr><td><code id="pnbd.ConditionalExpectedTransactions_+3A_hardie">hardie</code></td>
<td>
<p>if TRUE, have <code><a href="#topic+pnbd.PAlive">pnbd.PAlive</a></code> use <code><a href="#topic+h2f1">h2f1</a></code>
instead of <code><a href="hypergeo.html#topic+hypergeo">hypergeo</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>E[X(T.cal, T.cal + T.star) | x, t.x, r, alpha, s, beta]
</p>
<p><code>T.star</code>, <code>x</code>, <code>t.x</code>, and <code>T.cal</code> may be vectors. The
standard rules for vector operations apply - if they are not of the same
length, shorter vectors will be recycled (start over at the first element)
until they are as long as the longest vector. It is advisable to keep vectors
to the same length and to use single values for parameters that are to be the
same for all calculations. If one of these parameters has a length greater
than one, the output will be a vector of probabilities.
</p>


<h3>Value</h3>

<p>Number of transactions a customer is expected to make in a time
period of length t, conditional on their past behavior. If any of the input
parameters has a length greater than 1, this will be a vector of expected
number of transactions.
</p>


<h3>References</h3>

<p>Fader, Peter S., and Bruce G.S. Hardie. &quot;A Note on Deriving the
Pareto/NBD Model and Related Expressions.&quot; November. 2005. Web.
<a href="http://www.brucehardie.com/notes/008/">http://www.brucehardie.com/notes/008/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pnbd.Expectation">pnbd.Expectation</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>params &lt;- c(0.55, 10.56, 0.61, 11.64)
# Number of transactions a customer is expected to make in 2 time
# intervals, given that they made 10 repeat transactions in a time period
# of 39 intervals, with the 10th repeat transaction occurring in the 35th
# interval.
pnbd.ConditionalExpectedTransactions(params, 
                                     T.star = 2, 
                                     x = 10, 
                                     t.x = 35, 
                                     T.cal = 39, 
                                     hardie = TRUE)

# We can also compare expected transactions across different
# calibration period behaviors:
pnbd.ConditionalExpectedTransactions(params, 
                                     T.star = 2, 
                                     x = 5:20, 
                                     t.x = 25, 
                                     T.cal = 39, 
                                     hardie = TRUE)
</code></pre>

<hr>
<h2 id='pnbd.DERT'>Pareto/NBD Discounted Expected Residual Transactions</h2><span id='topic+pnbd.DERT'></span>

<h3>Description</h3>

<p>Calculates the discounted expected residual transactions of a customer, given
their behavior during the calibration period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pnbd.DERT(params, x, t.x, T.cal, d, hardie = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pnbd.DERT_+3A_params">params</code></td>
<td>
<p>Pareto/NBD parameters - a vector with r, alpha, s, and beta, in
that order. r and alpha are unobserved parameters for the NBD transaction
process. s and beta are unobserved parameters for the Pareto (exponential
gamma) dropout process.</p>
</td></tr>
<tr><td><code id="pnbd.DERT_+3A_x">x</code></td>
<td>
<p>number of repeat transactions in the calibration period T.cal, or a
vector of transaction frequencies.</p>
</td></tr>
<tr><td><code id="pnbd.DERT_+3A_t.x">t.x</code></td>
<td>
<p>time of most recent repeat transaction, or a vector of recencies.</p>
</td></tr>
<tr><td><code id="pnbd.DERT_+3A_t.cal">T.cal</code></td>
<td>
<p>length of calibration period, or a vector of calibration period
lengths.</p>
</td></tr>
<tr><td><code id="pnbd.DERT_+3A_d">d</code></td>
<td>
<p>the discount rate to be used. Make sure that it matches up with your
chosen time period (do not use an annual rate for monthly data, for
example).</p>
</td></tr>
<tr><td><code id="pnbd.DERT_+3A_hardie">hardie</code></td>
<td>
<p>if TRUE, use <code><a href="#topic+h2f1">h2f1</a></code> instead of
<code><a href="hypergeo.html#topic+hypergeo">hypergeo</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>DERT(d | r, alpha, s, beta, X = x, t.x, T.cal)
</p>
<p>x, t.x, T.cal may be vectors. The standard rules for vector operations apply
</p>

<ul>
<li><p> if they are not of the same length, shorter vectors will be recycled (start
over at the first element) until they are as long as the longest vector. It
is advisable to keep vectors to the same length and to use single values for
parameters that are to be the same for all calculations. If one of these
parameters has a length greater than one, the output will be also be a
vector.
</p>
</li></ul>



<h3>Value</h3>

<p>The number of discounted expected residual transactions for a
customer with a particular purchase pattern during the calibration period.
</p>


<h3>References</h3>

<p>Fader, Peter S., Bruce G.S. Hardie, and Ka L. Lee. &quot;RFM and CLV:
Using Iso-Value Curves for Customer Base Analysis.&quot; Journal of Marketing
Research Vol.42, pp.415-430. November. 2005.
<a href="http://www.brucehardie.com/papers.html">http://www.brucehardie.com/papers.html</a>
</p>
<p>See equation 2.
</p>
<p>Note that this paper refers to what this package is calling
discounted expected residual transactions (DERT) simply as discounted
expected transactions (DET).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># elog &lt;- dc.ReadLines(system.file("data/cdnowElog.csv", package="BTYD2"),2,3)
# elog[, 'date'] &lt;- as.Date(elog[, 'date'], format = '%Y%m%d')
# cal.cbs &lt;- dc.ElogToCbsCbt(elog)$cal$cbs
# params &lt;- pnbd.EstimateParameters(cal.cbs, hardie = TRUE)
params &lt;- c(0.5629966, 12.5590370, 0.4081095, 10.5148048)

# 15% compounded annually has been converted to 0.0027 compounded continuously,
# as we are dealing with weekly data and not annual data.
d &lt;- 0.0027

# calculate the discounted expected residual transactions of a customer
# who made 7 transactions in a calibration period that was 77.86
# weeks long, with the last transaction occurring at the end of
# the 35th week.
pnbd.DERT(params, 
          x = 7, 
          t.x = 35, 
          T.cal = 77.86, 
          d, 
          hardie = TRUE)

# We can also use vectors to compute DERT for several customers:
pnbd.DERT(params, 
          x = 1:10, 
          t.x = 30, 
          T.cal = 77.86, 
          d, 
          hardie = TRUE)
</code></pre>

<hr>
<h2 id='pnbd.EstimateParameters'>Pareto/NBD Parameter Estimation</h2><span id='topic+pnbd.EstimateParameters'></span>

<h3>Description</h3>

<p>The best-fitting parameters are determined using the
<code><a href="#topic+pnbd.cbs.LL">pnbd.cbs.LL</a></code> function. The sum of the log-likelihood for each
customer (for a set of parameters) is maximized in order to estimate
parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pnbd.EstimateParameters(
  cal.cbs,
  par.start = c(1, 1, 1, 1),
  max.param.value = 10000,
  method = "L-BFGS-B",
  hardie = TRUE,
  hessian = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pnbd.EstimateParameters_+3A_cal.cbs">cal.cbs</code></td>
<td>
<p>calibration period CBS (customer by sufficient statistic). It
must contain columns for frequency (&quot;x&quot;), recency (&quot;t.x&quot;), and total time
observed (&quot;T.cal&quot;). Note that recency must be the time between the start of
the calibration period and the customer's last transaction, not the time
between the customer's last transaction and the end of the calibration
period. If your data is compressed (see <code><a href="#topic+dc.compress.cbs">dc.compress.cbs</a></code>), a
fourth column labelled &quot;custs&quot; (number of customers with a specific
combination of recency, frequency and length of calibration period) will
make this function faster.</p>
</td></tr>
<tr><td><code id="pnbd.EstimateParameters_+3A_par.start">par.start</code></td>
<td>
<p>initial Pareto/NBD parameters - a vector with r, alpha, s,
and beta, in that order. r and alpha are unobserved parameters for the NBD
transaction process. s and beta are unobserved parameters for the Pareto
(exponential gamma) dropout process.</p>
</td></tr>
<tr><td><code id="pnbd.EstimateParameters_+3A_max.param.value">max.param.value</code></td>
<td>
<p>the upper bound on parameters.</p>
</td></tr>
<tr><td><code id="pnbd.EstimateParameters_+3A_method">method</code></td>
<td>
<p>the optimization method(s).</p>
</td></tr>
<tr><td><code id="pnbd.EstimateParameters_+3A_hardie">hardie</code></td>
<td>
<p>if TRUE, have <code><a href="#topic+pnbd.LL">pnbd.LL</a></code> use <code><a href="#topic+h2f1">h2f1</a></code>
instead of <code><a href="hypergeo.html#topic+hypergeo">hypergeo</a></code>.</p>
</td></tr>
<tr><td><code id="pnbd.EstimateParameters_+3A_hessian">hessian</code></td>
<td>
<p>set it to TRUE if you want the Hessian matrix, and then you
might as well have the complete  <code><a href="optimx.html#topic+optimx">optimx</a></code> object
returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A set of starting parameters must be provided for this method. If no
parameters are provided, (1,1,1,1) is used as a default. It may be useful to
use starting values for r and s that represent your best guess of the
heterogeneity in the buy and die rate of customers. It may be necessary to
run the estimation from multiple starting points to ensure that it converges.
To compare the log-likelihoods of different parameters, use
<code><a href="#topic+pnbd.cbs.LL">pnbd.cbs.LL</a></code>.
</p>
<p>The lower bound on the parameters to be estimated is always zero, since
Pareto/NBD parameters cannot be negative. The upper bound can be set with the
max.param.value parameter.
</p>
<p>This function may take some time to run. It uses <code><a href="optimx.html#topic+optimx">optimx</a></code>
for maximum likelihood estimation, not <code><a href="stats.html#topic+optim">optim</a></code>.
</p>


<h3>Value</h3>

<p>Unnamed vector of estimated parameters by default, <code>optimx</code>
object with everything if <code>hessian</code> is TRUE.
</p>


<h3>References</h3>

<p>Fader, Peter S.; Hardie, and Bruce G.S.. &quot;Overcoming the BG/NBD
Model's #NUM! Error Problem.&quot; December. 2013. Web.
<a href="http://brucehardie.com/notes/027/bgnbd_num_error.pdf">http://brucehardie.com/notes/027/bgnbd_num_error.pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pnbd.cbs.LL">pnbd.cbs.LL</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cdnowSummary)

cal.cbs &lt;- cdnowSummary$cbs
# cal.cbs already has column names required by method

# starting-point parameters
startingparams &lt;- c(0.5, 6, 0.9, 8)

# estimated parameters
est.params &lt;- pnbd.EstimateParameters(cal.cbs = cal.cbs, 
                                      par.start = startingparams, 
                                      method = 'L-BFGS-B',
                                      hardie = TRUE)
                                      
# complete object returned by \code{\link[optimx]{optimx}}
optimx.set &lt;- pnbd.EstimateParameters(cal.cbs = cal.cbs, 
                                      par.start = startingparams, 
                                      hardie = TRUE, 
                                      hessian = TRUE)

# log-likelihood of estimated parameters
pnbd.cbs.LL(est.params, cal.cbs, TRUE)
</code></pre>

<hr>
<h2 id='pnbd.Expectation'>Pareto/NBD Expectation</h2><span id='topic+pnbd.Expectation'></span>

<h3>Description</h3>

<p>Returns the number of repeat transactions that a randomly chosen customer
(for whom we have no prior information) is expected to make in a given time
period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pnbd.Expectation(params, t)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pnbd.Expectation_+3A_params">params</code></td>
<td>
<p>Pareto/NBD parameters - a vector with r, alpha, s, and beta, in
that order. r and alpha are unobserved parameters for the NBD transaction
process. s and beta are unobserved parameters for the Pareto (exponential
gamma) dropout process.</p>
</td></tr>
<tr><td><code id="pnbd.Expectation_+3A_t">t</code></td>
<td>
<p>The length of time for which we are calculating the expected number
of repeat transactions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>E(X(t) | r, alpha, s, beta)
</p>


<h3>Value</h3>

<p>Number of repeat transactions a customer is expected to make in a
time period of length t.
</p>


<h3>References</h3>

<p>Fader, Peter S., and Bruce G.S. Hardie. &quot;A Note on Deriving the
Pareto/NBD Model and Related Expressions.&quot; November. 2005. Web.
<a href="http://www.brucehardie.com/notes/008/">http://www.brucehardie.com/notes/008/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pnbd.ConditionalExpectedTransactions">pnbd.ConditionalExpectedTransactions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>params &lt;- c(0.55, 10.56, 0.61, 11.64)

# Number of repeat transactions a customer is expected to make in 2 time intervals.
pnbd.Expectation(params = params, 
                 t = 2)

# We can also compare expected transactions over time:
pnbd.Expectation(params = params, 
                 t = 1:10)
</code></pre>

<hr>
<h2 id='pnbd.ExpectedCumulativeTransactions'>Pareto/NBD Expected Cumulative Transactions</h2><span id='topic+pnbd.ExpectedCumulativeTransactions'></span>

<h3>Description</h3>

<p>Calculates the expected cumulative total repeat transactions by all customers
for the calibration and holdout periods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pnbd.ExpectedCumulativeTransactions(params, T.cal, T.tot, n.periods.final)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pnbd.ExpectedCumulativeTransactions_+3A_params">params</code></td>
<td>
<p>Pareto/NBD parameters - a vector with r, alpha, s, and beta, in
that order. r and alpha are unobserved parameters for the NBD transaction
process. s and beta are unobserved parameters for the Pareto (exponential
gamma) dropout process.</p>
</td></tr>
<tr><td><code id="pnbd.ExpectedCumulativeTransactions_+3A_t.cal">T.cal</code></td>
<td>
<p>length of calibration period, or a vector of calibration period
lengths.</p>
</td></tr>
<tr><td><code id="pnbd.ExpectedCumulativeTransactions_+3A_t.tot">T.tot</code></td>
<td>
<p>End of holdout period. Must be a single value, not a vector.</p>
</td></tr>
<tr><td><code id="pnbd.ExpectedCumulativeTransactions_+3A_n.periods.final">n.periods.final</code></td>
<td>
<p>Number of time periods in the calibration and holdout
periods. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function automatically divides the total period up into n.periods.final
time intervals. n.periods.final does not have to be in the same unit of time
as the T.cal data. For example: - if your T.cal data is in weeks, and you
want cumulative transactions per week, n.periods.final would equal T.star. -
if your T.cal data is in weeks, and you want cumulative transactions per day,
n.periods.final would equal T.star * 7.
</p>
<p>The holdout period should immediately follow the calibration period. This
function assume that all customers' calibration periods end on the same date,
rather than starting on the same date (thus customers' birth periods are
determined using max(T.cal) - T.cal rather than assuming that it is 0).
</p>


<h3>Value</h3>

<p>Vector of expected cumulative total repeat transactions by all
customers.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pnbd.Expectation">pnbd.Expectation</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cdnowSummary)

cal.cbs &lt;- cdnowSummary$cbs
# cal.cbs already has column names required by method

params &lt;- c(0.55, 10.56, 0.61, 11.64)

# Returns a vector containing cumulative repeat transactions for 546 days.
# All parameters are in weeks; the calibration period lasted 39 weeks
# and the holdout period another 39.
pnbd.ExpectedCumulativeTransactions(params = params, 
                                    T.cal = cal.cbs[,"T.cal"], 
                                    T.tot = 78, 
                                    n.periods.final = 546)
</code></pre>

<hr>
<h2 id='pnbd.generalParams'>Define general parameters</h2><span id='topic+pnbd.generalParams'></span>

<h3>Description</h3>

<p>This is to ensure consistency across all functions that require the
likelihood function, or the log of it, and to make sure that the same
implementation of the hypergeometric function is used everywhere for building
<code>A0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pnbd.generalParams(params, x, t.x, T.cal, func, hardie = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pnbd.generalParams_+3A_params">params</code></td>
<td>
<p>Pareto/NBD parameters - a vector with r, alpha, s, and beta, in
that order. r and alpha are unobserved parameters for the NBD transaction
process. s and beta are unobserved parameters for the Pareto (exponential
gamma) dropout process.</p>
</td></tr>
<tr><td><code id="pnbd.generalParams_+3A_x">x</code></td>
<td>
<p>number of repeat transactions in the calibration period T.cal, or a
vector of transaction frequencies.</p>
</td></tr>
<tr><td><code id="pnbd.generalParams_+3A_t.x">t.x</code></td>
<td>
<p>time of most recent repeat transaction, or a vector of recencies.</p>
</td></tr>
<tr><td><code id="pnbd.generalParams_+3A_t.cal">T.cal</code></td>
<td>
<p>length of calibration period, or a vector of calibration period
lengths.</p>
</td></tr>
<tr><td><code id="pnbd.generalParams_+3A_func">func</code></td>
<td>
<p>name of the function calling dc.InputCheck; either <code>pnbd.LL</code>
or <code>pnbd.PAlive</code>.</p>
</td></tr>
<tr><td><code id="pnbd.generalParams_+3A_hardie">hardie</code></td>
<td>
<p>if TRUE, use <code><a href="#topic+h2f1">h2f1</a></code> instead of
<code><a href="hypergeo.html#topic+hypergeo">hypergeo</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is only ever called by either <code><a href="#topic+pnbd.LL">pnbd.LL</a></code> or
<code><a href="#topic+pnbd.PAlive">pnbd.PAlive</a></code> so it returns directly the output that is expected
from those calling functions: either the log likelihood for a set of
customers, or the probability that a set of customers with characteristics
given by <code>x</code>, <code>t.x</code> and <code>T.cal</code>, having estimated a set of
<code>params</code>, is still alive. Either set of customers can be of size 1.
</p>


<h3>Value</h3>

<p>A vector of log likelihood values if <code>func</code> is <code>pnbd.LL</code>,
or a vector of probabilities that a customer is still alive if <code>func</code>
is <code>pnbd.PAlive</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pnbd.LL">pnbd.LL</a></code>
</p>
<p><code><a href="#topic+pnbd.PAlive">pnbd.PAlive</a></code>
</p>
<p><code><a href="#topic+pnbd.DERT">pnbd.DERT</a></code>
</p>

<hr>
<h2 id='pnbd.LL'>Pareto/NBD Log-Likelihood</h2><span id='topic+pnbd.LL'></span>

<h3>Description</h3>

<p>Calculates the log-likelihood of the Pareto/NBD model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pnbd.LL(params, x, t.x, T.cal, hardie = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pnbd.LL_+3A_params">params</code></td>
<td>
<p>Pareto/NBD parameters - a vector with r, alpha, s, and beta, in
that order. r and alpha are unobserved parameters for the NBD transaction
process. s and beta are unobserved parameters for the Pareto (exponential
gamma) dropout process.</p>
</td></tr>
<tr><td><code id="pnbd.LL_+3A_x">x</code></td>
<td>
<p>number of repeat transactions in the calibration period T.cal, or a
vector of transaction frequencies.</p>
</td></tr>
<tr><td><code id="pnbd.LL_+3A_t.x">t.x</code></td>
<td>
<p>time of most recent repeat transaction, or a vector of recencies.</p>
</td></tr>
<tr><td><code id="pnbd.LL_+3A_t.cal">T.cal</code></td>
<td>
<p>length of calibration period, or a vector of calibration period
lengths.</p>
</td></tr>
<tr><td><code id="pnbd.LL_+3A_hardie">hardie</code></td>
<td>
<p>if TRUE, use <code><a href="#topic+h2f1">h2f1</a></code> instead of
<code><a href="hypergeo.html#topic+hypergeo">hypergeo</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of log-likelihoods as long as the longest input vector (x,
t.x, or T.cal).
</p>


<h3>References</h3>

<p>Fader, Peter S., and Bruce G.S. Hardie. &quot;A Note on Deriving the
Pareto/NBD Model and Related Expressions.&quot; November. 2005. Web.
<a href="http://www.brucehardie.com/notes/008/">http://www.brucehardie.com/notes/008/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pnbd.EstimateParameters">pnbd.EstimateParameters</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Returns the log likelihood of the parameters for a customer who
# made 3 transactions in a calibration period that ended at t=6,
# with the last transaction occurring at t=4.
pnbd.LL(params, x=3, t.x=4, T.cal=6, hardie = TRUE)

# We can also give vectors as function parameters:
set.seed(7)
x &lt;- sample(1:4, 10, replace = TRUE)
t.x &lt;- sample(1:4, 10, replace = TRUE)
T.cal &lt;- rep(4, 10)
pnbd.LL(params, x, t.x, T.cal, hardie = TRUE)
</code></pre>

<hr>
<h2 id='pnbd.PAlive'>Pareto/NBD P(Alive)</h2><span id='topic+pnbd.PAlive'></span>

<h3>Description</h3>

<p>Uses Pareto/NBD model parameters and a customer's past transaction behavior
to return the probability that they are still alive at the end of the
calibration period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pnbd.PAlive(params, x, t.x, T.cal, hardie = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pnbd.PAlive_+3A_params">params</code></td>
<td>
<p>Pareto/NBD parameters - a vector with r, alpha, s, and beta, in
that order. r and alpha are unobserved parameters for the NBD transaction
process. s and beta are unobserved parameters for the Pareto (exponential
gamma) dropout process.</p>
</td></tr>
<tr><td><code id="pnbd.PAlive_+3A_x">x</code></td>
<td>
<p>number of repeat transactions in the calibration period T.cal, or a
vector of transaction frequencies.</p>
</td></tr>
<tr><td><code id="pnbd.PAlive_+3A_t.x">t.x</code></td>
<td>
<p>time of most recent repeat transaction, or a vector of recencies.</p>
</td></tr>
<tr><td><code id="pnbd.PAlive_+3A_t.cal">T.cal</code></td>
<td>
<p>length of calibration period, or a vector of calibration period
lengths.</p>
</td></tr>
<tr><td><code id="pnbd.PAlive_+3A_hardie">hardie</code></td>
<td>
<p>if TRUE, use <code><a href="#topic+h2f1">h2f1</a></code> instead of
<code><a href="hypergeo.html#topic+hypergeo">hypergeo</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>P(Alive | X=x, t.x, T.cal, r, alpha, s, beta)
</p>
<p>x, t.x, and T.cal may be vectors. The standard rules for vector operations
apply - if they are not of the same length, shorter vectors will be recycled
(start over at the first element) until they are as long as the longest
vector. It is advisable to keep vectors to the same length and to use single
values for parameters that are to be the same for all calculations. If one of
these parameters has a length greater than one, the output will be a vector
of probabilities.
</p>


<h3>Value</h3>

<p>Probability that the customer is still alive at the end of the
calibration period. If x, t.x, and/or T.cal has a length greater than one,
then this will be a vector of probabilities (containing one element
matching each element of the longest input vector).
</p>


<h3>References</h3>

<p>Fader, Peter S., and Bruce G.S. Hardie. &quot;A Note on Deriving the
Pareto/NBD Model and Related Expressions.&quot; November. 2005. Web.
<a href="http://www.brucehardie.com/notes/008/">http://www.brucehardie.com/notes/008/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cdnowSummary)
cbs &lt;- cdnowSummary$cbs
params &lt;- pnbd.EstimateParameters(cbs, hardie = TRUE)

pnbd.PAlive(params, x=0, t.x=0, T.cal=39, TRUE)
# 0.2941633; P(Alive) of a customer who made no repeat transactions.

pnbd.PAlive(params, x=23, t.x=39, T.cal=39, TRUE)
# 1; P(Alive) of a customer who has the same recency and total
# time observed.

pnbd.PAlive(params, x=5:20, t.x=30, T.cal=39, TRUE)
# Note the "increasing frequency paradox".

# To visualize the distribution of P(Alive) across customers:
p.alives &lt;- pnbd.PAlive(params, cbs[,"x"], cbs[,"t.x"], cbs[,"T.cal"], TRUE)
plot(density(p.alives))
</code></pre>

<hr>
<h2 id='pnbd.Plot.DERT'>Pareto/NBD Plot Discounted Expected Residual Transactions</h2><span id='topic+pnbd.Plot.DERT'></span>

<h3>Description</h3>

<p>Plots discounted expected residual transactions for different combinations of
calibration period frequency and recency.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pnbd.Plot.DERT(params, x, t.x, T.cal, d, hardie = TRUE, type = "persp")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pnbd.Plot.DERT_+3A_params">params</code></td>
<td>
<p>Pareto/NBD parameters - a vector with r, alpha, s, and beta, in
that order. r and alpha are unobserved parameters for the NBD transaction
process. s and beta are unobserved parameters for the Pareto (exponential
gamma) dropout process.</p>
</td></tr>
<tr><td><code id="pnbd.Plot.DERT_+3A_x">x</code></td>
<td>
<p>number of repeat transactions in the calibration period T.cal, or a
vector of transaction frequencies.</p>
</td></tr>
<tr><td><code id="pnbd.Plot.DERT_+3A_t.x">t.x</code></td>
<td>
<p>time of most recent repeat transaction, or a vector of recencies.</p>
</td></tr>
<tr><td><code id="pnbd.Plot.DERT_+3A_t.cal">T.cal</code></td>
<td>
<p>length of calibration period, or a vector of calibration period
lengths.</p>
</td></tr>
<tr><td><code id="pnbd.Plot.DERT_+3A_d">d</code></td>
<td>
<p>the discount rate to be used. Make sure that it matches up with your
chosen time period (do not use an annual rate for monthly data, for
example).</p>
</td></tr>
<tr><td><code id="pnbd.Plot.DERT_+3A_hardie">hardie</code></td>
<td>
<p>if TRUE, use <code><a href="#topic+h2f1">h2f1</a></code> instead of
<code><a href="hypergeo.html#topic+hypergeo">hypergeo</a></code>.</p>
</td></tr>
<tr><td><code id="pnbd.Plot.DERT_+3A_type">type</code></td>
<td>
<p>must be either &quot;persp&quot; (perspective - 3 dimensional) or
&quot;contour&quot;. Determines the type of plot produced by this function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The length of the calibration period <code>T.cal</code> must be a single value, not
a vector.
</p>


<h3>Value</h3>

<p>A matrix with discounted expected residual transaction values for
every combination of calibration period frequency <code>x</code> and calibration
period recency <code>t.x</code>.
</p>


<h3>References</h3>

<p>Fader, Peter S., Bruce G.S. Hardie, and Ka L. Lee. &quot;RFM and CLV:
Using Iso-Value Curves for Customer Base Analysis.&quot; Journal of Marketing
Research Vol.42, pp.415-430. November. 2005.
<a href="http://www.brucehardie.com/papers.html">http://www.brucehardie.com/papers.html</a>
</p>
<p>Note that this paper refers to what this package is calling
discounted expected residual transactions (DERT) simply as discounted
expected transactions (DET).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The RFM and CLV paper uses all 78 weeks of the cdnow data to
# estimate parameters. These parameters can be estimated as follows:
# elog &lt;- dc.ReadLines(system.file("data/cdnowElog.csv", package="BTYD2"),2,3)
# elog[, 'date'] &lt;- as.Date(elog[, 'date'], format = '%Y%m%d')
# cal.cbs &lt;- dc.ElogToCbsCbt(elog)$cal$cbs
# pnbd.EstimateParameters(cal.cbs, hardie = TRUE)

# (The final function was run several times with its own output as
# input for starting parameters, to ensure that the result converged).

params &lt;- c(0.5629966, 12.5590370, 0.4081095, 10.5148048)

# 15% compounded annually has been converted to 0.0027 compounded continously,
# as we are dealing with weekly data and not annual data.
d &lt;- 0.0027

pnbd.Plot.DERT(params = params, 
               x = 0:14, 
               t.x = 0:77, 
               T.cal = 77.86, 
               d = d, 
               hardie = TRUE, 
               type = "persp")
pnbd.Plot.DERT(params = params, 
               x = 0:14, 
               t.x = 0:77, 
               T.cal = 77.86, 
               d = d, 
               hardie = TRUE, 
               type="contour")
</code></pre>

<hr>
<h2 id='pnbd.PlotDropoutRateHeterogeneity'>Pareto/NBD Plot Dropout Rate Heterogeneity</h2><span id='topic+pnbd.PlotDropoutRateHeterogeneity'></span>

<h3>Description</h3>

<p>Plots and returns the estimated gamma distribution of mu (customers'
propensities to drop out).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pnbd.PlotDropoutRateHeterogeneity(params, lim = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pnbd.PlotDropoutRateHeterogeneity_+3A_params">params</code></td>
<td>
<p>Pareto/NBD parameters - a vector with r, alpha, s, and beta, in
that order. r and alpha are unobserved parameters for the NBD transaction
process. s and beta are unobserved parameters for the Pareto (exponential
gamma) dropout process.</p>
</td></tr>
<tr><td><code id="pnbd.PlotDropoutRateHeterogeneity_+3A_lim">lim</code></td>
<td>
<p>The upper-bound of the x-axis. A number is chosen by the function
if none is provided.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This returns the distribution of each customer's exponential parameter that
determines their lifetime (using the Pareto/NBD assumption that a customer's
lifetime can be modeled with an exponential distribution).
</p>


<h3>Value</h3>

<p>Distribution of customers' propensities to drop out.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>params &lt;- c(0.55, 10.56, 0.61, 11.64)
pnbd.PlotDropoutRateHeterogeneity(params)
params &lt;- c(0.55, 10.56, 3, 11.64)
pnbd.PlotDropoutRateHeterogeneity(params)
</code></pre>

<hr>
<h2 id='pnbd.PlotFrequencyInCalibration'>Pareto/NBD Plot Frequency in Calibration Period</h2><span id='topic+pnbd.PlotFrequencyInCalibration'></span>

<h3>Description</h3>

<p>Plots a histogram and returns a matrix comparing the actual and expected
number of customers who made a certain number of repeat transactions in the
calibration period, binned according to calibration period frequencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pnbd.PlotFrequencyInCalibration(
  params,
  cal.cbs,
  censor,
  hardie = TRUE,
  plotZero = TRUE,
  xlab = "Calibration period transactions",
  ylab = "Customers",
  title = "Frequency of Repeat Transactions"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pnbd.PlotFrequencyInCalibration_+3A_params">params</code></td>
<td>
<p>Pareto/NBD parameters - a vector with r, alpha, s, and beta, in
that order. r and alpha are unobserved parameters for the NBD transaction
process. s and beta are unobserved parameters for the Pareto (exponential
gamma) dropout process.</p>
</td></tr>
<tr><td><code id="pnbd.PlotFrequencyInCalibration_+3A_cal.cbs">cal.cbs</code></td>
<td>
<p>calibration period CBS (customer by sufficient statistic). It
must contain columns for frequency (&quot;x&quot;) and total time observed (&quot;T.cal&quot;).</p>
</td></tr>
<tr><td><code id="pnbd.PlotFrequencyInCalibration_+3A_censor">censor</code></td>
<td>
<p>integer used to censor the data. See details.</p>
</td></tr>
<tr><td><code id="pnbd.PlotFrequencyInCalibration_+3A_hardie">hardie</code></td>
<td>
<p>if TRUE, have <code><a href="#topic+pnbd.pmf">pnbd.pmf</a></code> use <code><a href="#topic+h2f1">h2f1</a></code>
instead of <code><a href="hypergeo.html#topic+hypergeo">hypergeo</a></code>.</p>
</td></tr>
<tr><td><code id="pnbd.PlotFrequencyInCalibration_+3A_plotzero">plotZero</code></td>
<td>
<p>if FALSE, the histogram will exclude the zero bin.</p>
</td></tr>
<tr><td><code id="pnbd.PlotFrequencyInCalibration_+3A_xlab">xlab</code></td>
<td>
<p>descriptive label for the x axis.</p>
</td></tr>
<tr><td><code id="pnbd.PlotFrequencyInCalibration_+3A_ylab">ylab</code></td>
<td>
<p>descriptive label for the y axis.</p>
</td></tr>
<tr><td><code id="pnbd.PlotFrequencyInCalibration_+3A_title">title</code></td>
<td>
<p>title placed on the top-center of the plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function requires a censor number, which cannot be higher than the
highest frequency in the calibration period CBS. The output matrix will have
(censor + 1) bins, starting at frequencies of 0 transactions and ending at a
bin representing calibration period frequencies at or greater than the censor
number. The plot may or may not include a bin for zero frequencies, depending
on the plotZero parameter.
</p>


<h3>Value</h3>

<p>Calibration period repeat transaction frequency comparison matrix
(actual vs. expected).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cdnowSummary)
cal.cbs &lt;- cdnowSummary$cbs
# cal.cbs already has column names required by method

# parameters estimated using pnbd.EstimateParameters
est.params &lt;- cdnowSummary$est.params
# the maximum censor number that can be used
max(cal.cbs[,"x"])

pnbd.PlotFrequencyInCalibration(params = est.params, 
                                cal.cbs = cal.cbs, 
                                censor = 7, 
                                hardie = TRUE)
</code></pre>

<hr>
<h2 id='pnbd.PlotFreqVsConditionalExpectedFrequency'>Pareto/NBD Plot Frequency vs. Conditional Expected Frequency</h2><span id='topic+pnbd.PlotFreqVsConditionalExpectedFrequency'></span>

<h3>Description</h3>

<p>Plots the actual and conditional expected number transactions made by
customers in the holdout period, binned according to calibration period
frequencies. Also returns a matrix with this comparison and the number of
customers in each bin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pnbd.PlotFreqVsConditionalExpectedFrequency(
  params,
  T.star,
  cal.cbs,
  x.star,
  censor,
  hardie = TRUE,
  xlab = "Calibration period transactions",
  ylab = "Holdout period transactions",
  xticklab = NULL,
  title = "Conditional Expectation"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pnbd.PlotFreqVsConditionalExpectedFrequency_+3A_params">params</code></td>
<td>
<p>Pareto/NBD parameters - a vector with r, alpha, s, and beta, in
that order. r and alpha are unobserved parameters for the NBD transaction
process. s and beta are unobserved parameters for the Pareto (exponential
gamma) dropout process.</p>
</td></tr>
<tr><td><code id="pnbd.PlotFreqVsConditionalExpectedFrequency_+3A_t.star">T.star</code></td>
<td>
<p>length of the holdout period. It must be a scalar for this
plot's purposes: you have one holdout period of a given length.</p>
</td></tr>
<tr><td><code id="pnbd.PlotFreqVsConditionalExpectedFrequency_+3A_cal.cbs">cal.cbs</code></td>
<td>
<p>calibration period CBS (customer by sufficient statistic). It
must contain columns for frequency (&quot;x&quot;), recency (&quot;t.x&quot;), and total time
observed (&quot;T.cal&quot;). Note that recency must be the time between the start of
the calibration period and the customer's last transaction, not the time
between the customer's last transaction and the end of the calibration
period.</p>
</td></tr>
<tr><td><code id="pnbd.PlotFreqVsConditionalExpectedFrequency_+3A_x.star">x.star</code></td>
<td>
<p>vector of transactions made by each customer in the holdout
period.</p>
</td></tr>
<tr><td><code id="pnbd.PlotFreqVsConditionalExpectedFrequency_+3A_censor">censor</code></td>
<td>
<p>integer used to censor the data. See details.</p>
</td></tr>
<tr><td><code id="pnbd.PlotFreqVsConditionalExpectedFrequency_+3A_hardie">hardie</code></td>
<td>
<p>if TRUE, have
<code><a href="#topic+pnbd.ConditionalExpectedTransactions">pnbd.ConditionalExpectedTransactions</a></code> use <code><a href="#topic+h2f1">h2f1</a></code>
instead of <code><a href="hypergeo.html#topic+hypergeo">hypergeo</a></code>.</p>
</td></tr>
<tr><td><code id="pnbd.PlotFreqVsConditionalExpectedFrequency_+3A_xlab">xlab</code></td>
<td>
<p>descriptive label for the x axis.</p>
</td></tr>
<tr><td><code id="pnbd.PlotFreqVsConditionalExpectedFrequency_+3A_ylab">ylab</code></td>
<td>
<p>descriptive label for the y axis.</p>
</td></tr>
<tr><td><code id="pnbd.PlotFreqVsConditionalExpectedFrequency_+3A_xticklab">xticklab</code></td>
<td>
<p>vector containing a label for each tick mark on the x axis.</p>
</td></tr>
<tr><td><code id="pnbd.PlotFreqVsConditionalExpectedFrequency_+3A_title">title</code></td>
<td>
<p>title placed on the top-center of the plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function requires a censor number, which cannot be higher than the
highest frequency in the calibration period CBS. The output matrix will have
(censor + 1) bins, starting at frequencies of 0 transactions and ending at a
bin representing calibration period frequencies at or greater than the censor
number.
</p>


<h3>Value</h3>

<p>Holdout period transaction frequency comparison matrix (actual vs. expected).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cdnowSummary)

cal.cbs &lt;- cdnowSummary$cbs
# cal.cbs already has column names required by method

# number of transactions by each customer in the 39 weeks
# following the calibration period
x.star &lt;- cal.cbs[,"x.star"]

# parameters estimated using pnbd.EstimateParameters
est.params &lt;- cdnowSummary$est.params
# the maximum censor number that can be used
max(cal.cbs[,"x"])

# plot conditional expected holdout period frequencies,
# binned according to calibration period frequencies
pnbd.PlotFreqVsConditionalExpectedFrequency(params = est.params, 
                                            T.star = 39, 
                                            cal.cbs = cal.cbs, 
                                            x.star = x.star, 
                                            censor = 7, 
                                            hardie = TRUE)
</code></pre>

<hr>
<h2 id='pnbd.PlotRateHeterogeneity'>Plot Pareto/NBD Rate Heterogeneity</h2><span id='topic+pnbd.PlotRateHeterogeneity'></span>

<h3>Description</h3>

<p>A helper for plotting either the estimated gamma distribution of mu
(customers' propensities to drop out), or the estimated gamma distribution of
lambda (customers' propensities to purchase).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pnbd.PlotRateHeterogeneity(params, func, lim = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pnbd.PlotRateHeterogeneity_+3A_params">params</code></td>
<td>
<p>Pareto/NBD parameters - a vector with r, alpha, s, and beta, in
that order. r and alpha are unobserved parameters for the NBD transaction
process. s and beta are unobserved parameters for the Pareto (exponential
gamma) dropout process.</p>
</td></tr>
<tr><td><code id="pnbd.PlotRateHeterogeneity_+3A_func">func</code></td>
<td>
<p>A string that is either &quot;pnbd.PlotDropoutRateHeterogeneity&quot; or
&quot;pnbd.PlotTransactionRateHeterogeneity&quot;.</p>
</td></tr>
<tr><td><code id="pnbd.PlotRateHeterogeneity_+3A_lim">lim</code></td>
<td>
<p>The upper-bound of the x-axis. A number is chosen by the function
if none is provided.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on the value of <code>func</code>, either the distribution of
customers' propensities to purchase or the distribution of customers'
propensities to drop out.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pnbd.PlotDropoutRateHeterogeneity">pnbd.PlotDropoutRateHeterogeneity</a></code>
</p>
<p><code><a href="#topic+pnbd.PlotTransactionRateHeterogeneity">pnbd.PlotTransactionRateHeterogeneity</a></code>
</p>

<hr>
<h2 id='pnbd.PlotRecVsConditionalExpectedFrequency'>Pareto/NBD Plot Actual vs. Conditional Expected Frequency by Recency</h2><span id='topic+pnbd.PlotRecVsConditionalExpectedFrequency'></span>

<h3>Description</h3>

<p>Plots the actual and conditional expected number of transactions made by
customers in the holdout period, binned according to calibration period
recencies. Also returns a matrix with this comparison and the number of
customers in each bin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pnbd.PlotRecVsConditionalExpectedFrequency(
  params,
  cal.cbs,
  T.star,
  x.star,
  hardie = TRUE,
  xlab = "Calibration period recency",
  ylab = "Holdout period transactions",
  xticklab = NULL,
  title = "Actual vs. Conditional Expected Transactions by Recency"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pnbd.PlotRecVsConditionalExpectedFrequency_+3A_params">params</code></td>
<td>
<p>Pareto/NBD parameters - a vector with r, alpha, s, and beta, in
that order. r and alpha are unobserved parameters for the NBD transaction
process. s and beta are unobserved parameters for the Pareto (exponential
gamma) dropout process.</p>
</td></tr>
<tr><td><code id="pnbd.PlotRecVsConditionalExpectedFrequency_+3A_cal.cbs">cal.cbs</code></td>
<td>
<p>calibration period CBS (customer by sufficient statistic). It
must contain columns for frequency (&quot;x&quot;), recency (&quot;t.x&quot;), and total time
observed (&quot;T.cal&quot;). Note that recency must be the time between the start of
the calibration period and the customer's last transaction, not the time
between the customer's last transaction and the end of the calibration
period.</p>
</td></tr>
<tr><td><code id="pnbd.PlotRecVsConditionalExpectedFrequency_+3A_t.star">T.star</code></td>
<td>
<p>length of the holdout period. It must be a scalar for this
plot's purposes: you have one holdout period of a given length.</p>
</td></tr>
<tr><td><code id="pnbd.PlotRecVsConditionalExpectedFrequency_+3A_x.star">x.star</code></td>
<td>
<p>vector of transactions made by each customer in the holdout
period.</p>
</td></tr>
<tr><td><code id="pnbd.PlotRecVsConditionalExpectedFrequency_+3A_hardie">hardie</code></td>
<td>
<p>if TRUE, have
<code><a href="#topic+pnbd.ConditionalExpectedTransactions">pnbd.ConditionalExpectedTransactions</a></code> use <code><a href="#topic+h2f1">h2f1</a></code>
instead of <code><a href="hypergeo.html#topic+hypergeo">hypergeo</a></code>.</p>
</td></tr>
<tr><td><code id="pnbd.PlotRecVsConditionalExpectedFrequency_+3A_xlab">xlab</code></td>
<td>
<p>descriptive label for the x axis.</p>
</td></tr>
<tr><td><code id="pnbd.PlotRecVsConditionalExpectedFrequency_+3A_ylab">ylab</code></td>
<td>
<p>descriptive label for the y axis.</p>
</td></tr>
<tr><td><code id="pnbd.PlotRecVsConditionalExpectedFrequency_+3A_xticklab">xticklab</code></td>
<td>
<p>vector containing a label for each tick mark on the x axis.</p>
</td></tr>
<tr><td><code id="pnbd.PlotRecVsConditionalExpectedFrequency_+3A_title">title</code></td>
<td>
<p>title placed on the top-center of the plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function does bin customers exactly according to recency; it bins
customers according to integer units of the time period of cal.cbs.
Therefore, if you are using weeks in your data, customers will be binned as
follows: customers with recencies between the start of the calibration period
(inclusive) and the end of week one (exclusive); customers with recencies
between the end of week one (inclusive) and the end of week two (exlusive);
etc.
</p>
<p>The matrix and plot will contain the actual number of transactions made by
each bin in the holdout period, as well as the expected number of
transactions made by that bin in the holdout period, conditional on that
bin's behavior during the calibration period.
</p>


<h3>Value</h3>

<p>Matrix comparing actual and conditional expected transactions in the holdout period.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cdnowSummary)

cal.cbs &lt;- cdnowSummary$cbs
# cal.cbs already has column names required by method

# number of transactions by each customer in the 39 weeks following
# the calibration period
x.star &lt;- cal.cbs[,"x.star"]

# parameters estimated using pnbd.EstimateParameters
est.params &lt;- cdnowSummary$est.params

# plot conditional expected holdout period transactions, binned according to
# calibration period recencies
pnbd.PlotRecVsConditionalExpectedFrequency(params = est.params, 
                                           cal.cbs = cal.cbs, 
                                           T.star = 39, 
                                           x.star = x.star, 
                                           hardie = TRUE)
</code></pre>

<hr>
<h2 id='pnbd.PlotTrackingCum'>Pareto/NBD Tracking Cumulative Transactions Plot</h2><span id='topic+pnbd.PlotTrackingCum'></span>

<h3>Description</h3>

<p>Plots the actual and expected cumulative total repeat transactions by all
customers for the calibration and holdout periods, and returns this
comparison in a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pnbd.PlotTrackingCum(
  params,
  T.cal,
  T.tot,
  actual.cu.tracking.data,
  n.periods.final = NA,
  xlab = "Week",
  ylab = "Cumulative Transactions",
  xticklab = NULL,
  title = "Tracking Cumulative Transactions"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pnbd.PlotTrackingCum_+3A_params">params</code></td>
<td>
<p>Pareto/NBD parameters - a vector with r, alpha, s, and beta, in
that order. r and alpha are unobserved parameters for the NBD transaction
process. s and beta are unobserved parameters for the Pareto (exponential
gamma) dropout process.</p>
</td></tr>
<tr><td><code id="pnbd.PlotTrackingCum_+3A_t.cal">T.cal</code></td>
<td>
<p>length of calibration period, or a vector of calibration period
lengths.</p>
</td></tr>
<tr><td><code id="pnbd.PlotTrackingCum_+3A_t.tot">T.tot</code></td>
<td>
<p>End of holdout period. Must be a single value, not a vector.</p>
</td></tr>
<tr><td><code id="pnbd.PlotTrackingCum_+3A_actual.cu.tracking.data">actual.cu.tracking.data</code></td>
<td>
<p>A vector containing the cumulative number of
repeat transactions made by customers for each period in the total time
period (both calibration and holdout periods). See details.</p>
</td></tr>
<tr><td><code id="pnbd.PlotTrackingCum_+3A_n.periods.final">n.periods.final</code></td>
<td>
<p>Number of time periods in the calibration and holdout
periods. See details.</p>
</td></tr>
<tr><td><code id="pnbd.PlotTrackingCum_+3A_xlab">xlab</code></td>
<td>
<p>Descriptive label for the x axis.</p>
</td></tr>
<tr><td><code id="pnbd.PlotTrackingCum_+3A_ylab">ylab</code></td>
<td>
<p>Descriptive label for the y axis.</p>
</td></tr>
<tr><td><code id="pnbd.PlotTrackingCum_+3A_xticklab">xticklab</code></td>
<td>
<p>Vector containing a label for each tick mark on the x axis.</p>
</td></tr>
<tr><td><code id="pnbd.PlotTrackingCum_+3A_title">title</code></td>
<td>
<p>Title placed on the top-center of the plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>actual.cu.tracking.data does not have to be in the same unit of time as the
T.cal data. T.tot will automatically be divided into periods to match the
length of actual.cu.tracking.data. See
<code><a href="#topic+pnbd.ExpectedCumulativeTransactions">pnbd.ExpectedCumulativeTransactions</a></code>.
</p>
<p>The holdout period should immediately follow the calibration period. This
function assume that all customers' calibration periods end on the same date,
rather than starting on the same date (thus customers' birth periods are
determined using max(T.cal) - T.cal rather than assuming that it is 0).
</p>


<h3>Value</h3>

<p>Matrix containing actual and expected cumulative repeat transactions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cdnowSummary)

cal.cbs &lt;- cdnowSummary$cbs
# cal.cbs already has column names required by method

# Cumulative repeat transactions made by all customers across calibration
# and holdout periods
cu.tracking &lt;- cdnowSummary$cu.tracking

# parameters estimated using pnbd.EstimateParameters
est.params &lt;- cdnowSummary$est.params

# All parameters are in weeks; the calibration period lasted 39
# weeks and the holdout period another 39.
pnbd.PlotTrackingCum(params = est.params, 
                     T.cal = cal.cbs[,"T.cal"], 
                     T.tot = 78, 
                     actual.cu.tracking.data = cu.tracking)
</code></pre>

<hr>
<h2 id='pnbd.PlotTrackingInc'>Pareto/NBD Tracking Incremental Transactions Comparison</h2><span id='topic+pnbd.PlotTrackingInc'></span>

<h3>Description</h3>

<p>Plots the actual and expected incremental total repeat transactions by all
customers for the calibration and holdout periods, and returns this
comparison in a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pnbd.PlotTrackingInc(
  params,
  T.cal,
  T.tot,
  actual.inc.tracking.data,
  n.periods.final = NA,
  xlab = "Week",
  ylab = "Transactions",
  xticklab = NULL,
  title = "Tracking Weekly Transactions"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pnbd.PlotTrackingInc_+3A_params">params</code></td>
<td>
<p>Pareto/NBD parameters - a vector with r, alpha, s, and beta, in
that order. r and alpha are unobserved parameters for the NBD transaction
process. s and beta are unobserved parameters for the Pareto (exponential
gamma) dropout process.</p>
</td></tr>
<tr><td><code id="pnbd.PlotTrackingInc_+3A_t.cal">T.cal</code></td>
<td>
<p>length of calibration period, or a vector of calibration period
lengths.</p>
</td></tr>
<tr><td><code id="pnbd.PlotTrackingInc_+3A_t.tot">T.tot</code></td>
<td>
<p>End of holdout period. Must be a single value, not a vector.</p>
</td></tr>
<tr><td><code id="pnbd.PlotTrackingInc_+3A_actual.inc.tracking.data">actual.inc.tracking.data</code></td>
<td>
<p>A vector containing the incremental number of
repeat transactions made by customers for each period in the total time
period (both calibration and holdout periods). See details.</p>
</td></tr>
<tr><td><code id="pnbd.PlotTrackingInc_+3A_n.periods.final">n.periods.final</code></td>
<td>
<p>Number of time periods in the calibration and holdout
periods. See details.</p>
</td></tr>
<tr><td><code id="pnbd.PlotTrackingInc_+3A_xlab">xlab</code></td>
<td>
<p>Descriptive label for the x axis.</p>
</td></tr>
<tr><td><code id="pnbd.PlotTrackingInc_+3A_ylab">ylab</code></td>
<td>
<p>Descriptive label for the y axis.</p>
</td></tr>
<tr><td><code id="pnbd.PlotTrackingInc_+3A_xticklab">xticklab</code></td>
<td>
<p>Vector containing a label for each tick mark on the x axis.</p>
</td></tr>
<tr><td><code id="pnbd.PlotTrackingInc_+3A_title">title</code></td>
<td>
<p>Title placed on the top-center of the plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>actual.inc.tracking.data does not have to be in the same unit of time as the
T.cal data. T.tot will automatically be divided into periods to match the
length of actual.inc.tracking.data. See
<code><a href="#topic+pnbd.ExpectedCumulativeTransactions">pnbd.ExpectedCumulativeTransactions</a></code>.
</p>
<p>The holdout period should immediately follow the calibration period. This
function assume that all customers' calibration periods end on the same date,
rather than starting on the same date (thus customers' birth periods are
determined using max(T.cal) - T.cal rather than assuming that it is 0).
</p>


<h3>Value</h3>

<p>Matrix containing actual and expected incremental repeat transactions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cdnowSummary)
cal.cbs &lt;- cdnowSummary$cbs
# cal.cbs already has column names required by method

# Cumulative repeat transactions made by all customers across calibration
# and holdout periods
cu.tracking &lt;- cdnowSummary$cu.tracking
# make the tracking data incremental
inc.tracking &lt;- dc.CumulativeToIncremental(cu.tracking)

# parameters estimated using pnbd.EstimateParameters
est.params &lt;- cdnowSummary$est.params

# All parameters are in weeks; the calibration period lasted 39
# weeks and the holdout period another 39.
pnbd.PlotTrackingInc(params = est.params, 
                     T.cal = cal.cbs[,"T.cal"], 
                     T.tot = 78, 
                     actual.inc.tracking.data = inc.tracking)
</code></pre>

<hr>
<h2 id='pnbd.PlotTransactionRateHeterogeneity'>Pareto/NBD Plot Transaction Rate Heterogeneity</h2><span id='topic+pnbd.PlotTransactionRateHeterogeneity'></span>

<h3>Description</h3>

<p>Plots and returns the estimated gamma distribution of lambda (customers'
propensities to purchase).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pnbd.PlotTransactionRateHeterogeneity(params, lim = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pnbd.PlotTransactionRateHeterogeneity_+3A_params">params</code></td>
<td>
<p>Pareto/NBD parameters - a vector with r, alpha, s, and beta, in
that order. r and alpha are unobserved parameters for the NBD transaction
process. s and beta are unobserved parameters for the Pareto (exponential
gamma) dropout process.</p>
</td></tr>
<tr><td><code id="pnbd.PlotTransactionRateHeterogeneity_+3A_lim">lim</code></td>
<td>
<p>The upper-bound of the x-axis. A number is chosen by the function
if none is provided.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This returns the distribution of each customer's Poisson parameter, which
determines the level of their purchasing (using the Pareto/NBD assumption
that purchasing on the individual level can be modeled with a Poisson
distribution).
</p>


<h3>Value</h3>

<p>Distribution of customers' propensities to purchase.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>params &lt;- c(0.55, 10.56, 0.61, 11.64)
pnbd.PlotTransactionRateHeterogeneity(params)
params &lt;- c(3, 10.56, 0.61, 11.64)
pnbd.PlotTransactionRateHeterogeneity(params)
</code></pre>

<hr>
<h2 id='pnbd.pmf'>Pareto/NBD Probability Mass Function</h2><span id='topic+pnbd.pmf'></span>

<h3>Description</h3>

<p>Probability mass function for the Pareto/NBD.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pnbd.pmf(params, t, x, hardie = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pnbd.pmf_+3A_params">params</code></td>
<td>
<p>Pareto/NBD parameters - a vector with r, alpha, s, and beta, in
that order. r and alpha are unobserved parameters for the NBD transaction
process. s and beta are unobserved parameters for the Pareto (exponential
gamma) dropout process.</p>
</td></tr>
<tr><td><code id="pnbd.pmf_+3A_t">t</code></td>
<td>
<p>length end of time period for which probability is being computed.
May also be a vector.</p>
</td></tr>
<tr><td><code id="pnbd.pmf_+3A_x">x</code></td>
<td>
<p>number of repeat transactions by a random customer in the period
defined by t. May also be a vector.</p>
</td></tr>
<tr><td><code id="pnbd.pmf_+3A_hardie">hardie</code></td>
<td>
<p>if TRUE, have <code><a href="#topic+pnbd.pmf.General">pnbd.pmf.General</a></code> use
<code><a href="#topic+h2f1">h2f1</a></code> instead of <code><a href="hypergeo.html#topic+hypergeo">hypergeo</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>P(X(t)=x | r, alpha, s, beta). Returns the probability that a customer makes
x repeat transactions in the time interval (0, t].
</p>
<p>Parameters <code>t</code> and <code>x</code> may be vectors. The standard rules for
vector operations apply - if they are not of the same length, the shorter
vector will be recycled (start over at the first element) until it is as long
as the longest vector. It is advisable to keep vectors to the same length and
to use single values for parameters that are to be the same for all
calculations. If one of these parameters has a length greater than one, the
output will be a vector of probabilities.
</p>


<h3>Value</h3>

<p>Probability of X(t)=x conditional on model parameters. If t and/or x
has a length greater than one, a vector of probabilities will be returned.
</p>


<h3>References</h3>

<p>Fader, Peter S., and Bruce G.S. Hardie. “Deriving an Expression
for P (X(t) = x) Under the Pareto/NBD Model.” Sept. 2006. Web.
<a href="http://www.brucehardie.com/notes/012/">http://www.brucehardie.com/notes/012/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>params &lt;- c(0.55, 10.56, 0.61, 11.64)
# probability that a customer will make 10 repeat transactions in the
# time interval (0,2]
pnbd.pmf(params, t=2, x=10, hardie = TRUE)
# probability that a customer will make no repeat transactions in the
# time interval (0,39]
pnbd.pmf(params, t=39, x=0, hardie = TRUE)

# Vectors may also be used as arguments:
pnbd.pmf(params = params, 
         t = 30, 
         x = 11:20, 
         hardie = TRUE)
</code></pre>

<hr>
<h2 id='pnbd.pmf.General'>Generalized Pareto/NBD Probability Mass Function</h2><span id='topic+pnbd.pmf.General'></span>

<h3>Description</h3>

<p>Generalized probability mass function for the Pareto/NBD.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pnbd.pmf.General(params, t.start, t.end, x, hardie = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pnbd.pmf.General_+3A_params">params</code></td>
<td>
<p>Pareto/NBD parameters - a vector with r, alpha, s, and beta, in
that order. r and alpha are unobserved parameters for the NBD transaction
process. s and beta are unobserved parameters for the Pareto (exponential
gamma) dropout process.</p>
</td></tr>
<tr><td><code id="pnbd.pmf.General_+3A_t.start">t.start</code></td>
<td>
<p>start of time period for which probability is being
calculated. It can also be a vector of values.</p>
</td></tr>
<tr><td><code id="pnbd.pmf.General_+3A_t.end">t.end</code></td>
<td>
<p>end of time period for which probability is being calculated. It
can also be a vector of values.</p>
</td></tr>
<tr><td><code id="pnbd.pmf.General_+3A_x">x</code></td>
<td>
<p>number of repeat transactions by a random customer in the period
defined by (t.start, t.end]. It can also be a vector of values.</p>
</td></tr>
<tr><td><code id="pnbd.pmf.General_+3A_hardie">hardie</code></td>
<td>
<p>if TRUE, use <code><a href="#topic+h2f1">h2f1</a></code> instead of
<code><a href="hypergeo.html#topic+hypergeo">hypergeo</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>P(X(t.start, t.end)=x | r, alpha, s, beta). Returns the probability that a
customer makes x repeat transactions in the time interval (t.start, t.end].
</p>
<p>It is impossible for a customer to make a negative number of repeat
transactions. This function will return an error if it is given negative
times or a negative number of repeat transactions. This function will also
return an error if t.end is less than t.start.
</p>
<p><code>t.start</code>, <code>t.end</code>, and <code>x</code> may be vectors. The standard rules
for vector operations apply - if they are not of the same length, shorter
vectors will be recycled (start over at the first element) until they are as
long as the longest vector. It is advisable to keep vectors to the same
length and to use single values for parameters that are to be the same for
all calculations. If one of these parameters has a length greater than one,
the output will be a vector of probabilities.
</p>


<h3>Value</h3>

<p>Probability of x transaction occuring between t.start and t.end
conditional on model parameters. If t.start, t.end, and/or x has a length
greater than one, a vector of probabilities will be returned.
</p>


<h3>References</h3>

<p>Fader, Peter S., and Bruce G.S. Hardie. &quot;Deriving an Expression
for P (X(t) = x) Under the Pareto/NBD Model.&quot; Sept. 2006. Web.
<a href="http://www.brucehardie.com/notes/012/">http://www.brucehardie.com/notes/012/</a>
</p>
<p>Fader, Peter S., Bruce G.S. Hardie, and Kinshuk Jerath. &quot;Deriving
an Expression for P (X(t, t + tau) = x) Under the Pareto/NBD Model.&quot; Sept.
2006. Web. <a href="http://www.brucehardie.com/notes/013/">http://www.brucehardie.com/notes/013/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># probability that a customer will make 10 repeat transactions in the
# time interval (1,2]
data("cdnowSummary")
cal.cbs &lt;- cdnowSummary$cbs
params &lt;- pnbd.EstimateParameters(cal.cbs = cal.cbs, 
                                  method = "L-BFGS-B",
                                  hardie = TRUE)
pnbd.pmf.General(params, t.start=1, t.end=2, x=10, hardie = TRUE)
# probability that a customer will make no repeat transactions in the
# time interval (39,78]
pnbd.pmf.General(params, 
                 t.start = 39, 
                 t.end = 78, 
                 x = 0, 
                 hardie = TRUE)
</code></pre>

<hr>
<h2 id='spend.EstimateParameters'>Spend Parameter Estimation</h2><span id='topic+spend.EstimateParameters'></span>

<h3>Description</h3>

<p>Estimates parameters for the gamma-gamma spend model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spend.EstimateParameters(
  m.x.vector,
  x.vector,
  par.start = c(1, 1, 1),
  max.param.value = 10000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spend.EstimateParameters_+3A_m.x.vector">m.x.vector</code></td>
<td>
<p>a vector with each customer's average observed transaction
value in the calibration period.</p>
</td></tr>
<tr><td><code id="spend.EstimateParameters_+3A_x.vector">x.vector</code></td>
<td>
<p>a vector with the number of transactions each customer made
in the calibration period. Must correspond to m.x.vector in terms of
ordering of customers and length of the vector.</p>
</td></tr>
<tr><td><code id="spend.EstimateParameters_+3A_par.start">par.start</code></td>
<td>
<p>initial vector of gamma-gamma parameters: p, q, and gamma,
in that order. p is the shape parameter for each transaction. The scale
parameter for each transaction is distributed across customers according to
a gamma distribution with parameters q (shape) and gamma (scale).</p>
</td></tr>
<tr><td><code id="spend.EstimateParameters_+3A_max.param.value">max.param.value</code></td>
<td>
<p>the upper bound on parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The best-fitting parameters are determined using the spend.LL function. The
sum of the log-likelihood for each customer (for a set of parameters) is
maximized in order to estimate parameters.
</p>
<p>A set of starting parameters must be provided for this method. If no
parameters are provided, (1,1,1,1) is used as a default. It may be necessary
to run the estimation from multiple starting points to ensure that it
converges. To compare the log-likelihoods of different parameters, use
<a href="#topic+spend.LL">spend.LL</a>.
</p>
<p>The lower bound on the parameters to be estimated is always zero, since
gamma-gamma parameters cannot be negative. The upper bound can be set with
the max.param.value parameter.
</p>


<h3>Value</h3>

<p>Vector of estimated parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(cdnowSummary)
ave.spend &lt;- cdnowSummary$m.x
tot.trans &lt;- cdnowSummary$cbs[,"x"]

# There will be many warnings due to the zeroes that are
# included in the data above. To avoid them, use the following:
# (see example for spend.LL)

ave.spend &lt;- ave.spend[which(tot.trans &gt; 0)]
tot.trans &lt;- tot.trans[which(tot.trans &gt; 0)]

# We will let the spend function use default starting parameters
spend.EstimateParameters(ave.spend, tot.trans)

## End(Not run)
</code></pre>

<hr>
<h2 id='spend.expected.value'>Conditional expected transaction value</h2><span id='topic+spend.expected.value'></span>

<h3>Description</h3>

<p>Calculates the expected transaction value for a customer, conditional on the
number of transaction and average transaction value during the calibration
period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spend.expected.value(params, m.x, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spend.expected.value_+3A_params">params</code></td>
<td>
<p>a vector of gamma-gamma parameters: p, q, and gamma, in that
order. p is the shape parameter for each transaction. The scale parameter
for each transaction is distributed across customers according to a gamma
distribution with parameters q (shape) and gamma (scale).</p>
</td></tr>
<tr><td><code id="spend.expected.value_+3A_m.x">m.x</code></td>
<td>
<p>the customer's average observed transaction value in the
calibration period. May also be a vector of average observed transaction
values - see details.</p>
</td></tr>
<tr><td><code id="spend.expected.value_+3A_x">x</code></td>
<td>
<p>the number of transactions the customer made in the calibration
period. May also be a vector of frequencies - see details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>E(M | p, q, gamma, m.x, x).
</p>
<p>m.x and x may be vectors. The standard rules for vector operations apply - if
they are not of the same length, the shorter vector will be recycled (start
over at the first element) until it is as long as the longest vector. It is
advisable to keep vectors to the same length and to use single values for
parameters that are to be the same for all calculations. If one of these
parameters has a length greater than one, the output will be a vector of
probabilities.
</p>


<h3>Value</h3>

<p>The expected transaction value for a customer conditional on their
transaction behavior during the calibration period. If m.x or x has a
length greater than one, then a vector of expected transaction values will
be returned.
</p>


<h3>References</h3>

<p>Fader, Peter S., Bruce G.S. Hardie, and Ka L. Lee. “RFM and CLV:
Using Iso-Value Curves for Customer Base Analysis.” Journal of Marketing
Research Vol.42, pp.415-430. November. 2005.
<a href="http://www.brucehardie.com/papers/rfm_clv_2005-02-16.pdf">Web.</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(cdnowSummary)
ave.spend &lt;- cdnowSummary$m.x
tot.trans &lt;- cdnowSummary$cbs[,"x"]
# params &lt;- c(6, 4, 16); # in original documentation. rounded values of:
params &lt;- spend.EstimateParameters(m.x.vector = ave.spend, x.vector = tot.trans);
# calculate the expected transaction value of a customer
# who spent an average of $35 over 3 transactions.
spend.expected.value(params, m.x=35, x=3)

# m.x and x may be vectors:
spend.expected.value(params, m.x=30:40, x=3)
spend.expected.value(params, m.x=35, x=1:10)
spend.expected.value(params, m.x=30:40, x=1:11)

## End(Not run)
</code></pre>

<hr>
<h2 id='spend.generalParams'>Define general parameters</h2><span id='topic+spend.generalParams'></span>

<h3>Description</h3>

<p>This is to ensure consistency across all spend functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spend.generalParams(params, func, m.x, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spend.generalParams_+3A_params">params</code></td>
<td>
<p>a vector of gamma-gamma parameters: p, q, and gamma, in that
order. p is the shape parameter for each transaction. The scale parameter
for each transaction is distributed across customers according to a gamma
distribution with parameters q (shape) and gamma (scale).</p>
</td></tr>
<tr><td><code id="spend.generalParams_+3A_func">func</code></td>
<td>
<p>name of the function calling <code><a href="#topic+dc.InputCheck">dc.InputCheck</a></code>.</p>
</td></tr>
<tr><td><code id="spend.generalParams_+3A_m.x">m.x</code></td>
<td>
<p>the customer's average observed transaction value in the
calibration period. May also be a vector of average observed transaction
values - see details.</p>
</td></tr>
<tr><td><code id="spend.generalParams_+3A_x">x</code></td>
<td>
<p>the number of transactions the customer made in the calibration
period. May also be a vector of frequencies - see details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is only ever called by functions defined in the original BTYD
package, such as <code><a href="#topic+spend.LL">spend.LL</a></code>, <code><a href="#topic+spend.marginal.likelihood">spend.marginal.likelihood</a></code> or
<code><a href="#topic+spend.expected.value">spend.expected.value</a></code> so it returns directly the output that is expected
from those calling functions.
</p>


<h3>Value</h3>

<p>That depends on <code>func</code>: 1. If <code>func</code> is <code>spend.marginal.likelihood</code>,
the marginal distribution of a customer's average transaction value (if m.x
or x has a length greater than 1, a vector of marginal likelihoods will be
returned). 2. If <code>func</code> is <code>spend.LL</code>, the log-likelihood of the
gamma-gamma model; if m.x or x has a length greater than 1, this is a
vector of log-likelihoods. 3. If <code>func</code> is <code>spend.expected.value</code>, the
expected transaction value for a customer conditional on their transaction
behavior during the calibration period. If m.x or x has a length greater
than one, then a vector of expected transaction values will be returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spend.LL">spend.LL</a></code>
</p>
<p><code><a href="#topic+spend.marginal.likelihood">spend.marginal.likelihood</a></code>
</p>

<hr>
<h2 id='spend.LL'>Spend Log-Likelihood</h2><span id='topic+spend.LL'></span>

<h3>Description</h3>

<p>Calculates the log-likelihood of the gamma-gamma model for customer spending.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spend.LL(params, m.x, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spend.LL_+3A_params">params</code></td>
<td>
<p>a vector of gamma-gamma parameters: p, q, and gamma, in that
order. p is the shape parameter for each transaction. The scale parameter
for each transaction is distributed across customers according to a gamma
distribution with parameters q (shape) and gamma (scale).</p>
</td></tr>
<tr><td><code id="spend.LL_+3A_m.x">m.x</code></td>
<td>
<p>the customer's average observed transaction value in the
calibration period. May also be a vector of average observed transaction
values - see details.</p>
</td></tr>
<tr><td><code id="spend.LL_+3A_x">x</code></td>
<td>
<p>the number of transactions the customer made in the calibration
period. May also be a vector of frequencies - see details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>m.x and x may be vectors. The standard rules for vector operations apply - if
they are not of the same length, the shorter vector will be recycled (start
over at the first element) until it is as long as the longest vector. It is
advisable to keep vectors to the same length and to use single values for
parameters that are to be the same for all calculations. If one of these
parameters has a length greater than one, the output will be a vector of
log-likelihoods.
</p>


<h3>Value</h3>

<p>The log-likelihood of the gamma-gamma model. If m.x or x has a length
greater than 1, this is a vector of log-likelihoods.
</p>


<h3>References</h3>

<p>Fader, Peter S., Bruce G.S. Hardie, and Ka L. Lee. “RFM and CLV:
Using Iso-Value Curves for Customer Base Analysis.” Journal of Marketing
Research Vol.42, pp.415-430. November. 2005.
<a href="http://www.brucehardie.com/papers/rfm_clv_2005-02-16.pdf">Web.</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(cdnowSummary)
ave.spend &lt;- cdnowSummary$m.x
tot.trans &lt;- cdnowSummary$cbs[,"x"]
# params &lt;- c(6.25, 3.74, 15.44) # in original documentation. check below:
params &lt;- spend.EstimateParameters(m.x.vector = ave.spend, x.vector = tot.trans)
# get the total log-likelihood of the data and parameters
# above. There will be many warnings due to the zeroes that are
# included in the data. If you wish to avoid these warnings, use:

# ave.spend &lt;- ave.spend[which(tot.trans &gt; 0)]
# tot.trans &lt;- tot.trans[which(tot.trans &gt; 0)]

# Note that we used tot.trans to remove the zeroes from ave.spend.
# This is because we need the vectors to be the same length, and it
# is possible that your data include customers who made transactions
# worth zero dollars (in which case the vector lengths would differ
# if we used ave.spend to remove the zeroes from ave.spend).

sum(spend.LL(params, ave.spend, tot.trans))

# This log-likelihood may be different than mentioned in the
# referenced paper; in the paper, a slightly different function
# which relies on total spend (not average spend) is used.

## End(Not run)
</code></pre>

<hr>
<h2 id='spend.marginal.likelihood'>Gamma-gamma marginal likelihood</h2><span id='topic+spend.marginal.likelihood'></span>

<h3>Description</h3>

<p>Calculates the marginal likelihood of a customer's average transaction value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spend.marginal.likelihood(params, m.x, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spend.marginal.likelihood_+3A_params">params</code></td>
<td>
<p>a vector of gamma-gamma parameters: p, q, and gamma, in that
order. p is the shape parameter for each transaction. The scale parameter
for each transaction is distributed across customers according to a gamma
distribution with parameters q (shape) and gamma (scale).</p>
</td></tr>
<tr><td><code id="spend.marginal.likelihood_+3A_m.x">m.x</code></td>
<td>
<p>the customer's average observed transaction value in the
calibration period. May also be a vector of average observed transaction
values - see details.</p>
</td></tr>
<tr><td><code id="spend.marginal.likelihood_+3A_x">x</code></td>
<td>
<p>the number of transactions the customer made in the calibration
period. May also be a vector of frequencies - see details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>m.x and x may be vectors. The standard rules for vector operations apply - if
they are not of the same length, the shorter vector will be recycled (start
over at the first element) until it is as long as the longest vector. It is
advisable to keep vectors to the same length and to use single values for
parameters that are to be the same for all calculations. If one of these
parameters has a length greater than one, the output will be a vector of
probabilities.
</p>
<p>This function will issue a warning if any of m.x or x is 0, and will return a
marginal likelihood of 0 for those values.
</p>
<p>f(m.x | p, q, gamma, x).
</p>


<h3>Value</h3>

<p>The marginal distribution of a customer's average transaction value.
If m.x or x has a length greater than 1, a vector of marginal likelihoods
will be returned.
</p>


<h3>References</h3>

<p>Fader, Peter S., Bruce G.S. Hardie, and Ka L. Lee. “RFM and CLV:
Using Iso-Value Curves for Customer Base Analysis.” Journal of Marketing
Research Vol.42, pp.415-430. November. 2005.
<a href="http://www.brucehardie.com/papers/rfm_clv_2005-02-16.pdf">Web.</a>
</p>
<p>See equation 3.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>params &lt;- c(6, 4, 16)

# calculate the marginal distribution of the average transaction value
# of a customer who spent an average of $35 over 3 transactions.
spend.marginal.likelihood(params, m.x=35, x=3)

# Several values can also be computed at once:
spend.marginal.likelihood(params, m.x=30:40, x=3)
spend.marginal.likelihood(params, m.x=35, x=1:10)
spend.marginal.likelihood(params, m.x=30:40, x=1:11)
</code></pre>

<hr>
<h2 id='spend.plot.average.transaction.value'>Plot Actual vs. Expected Average Transaction Value</h2><span id='topic+spend.plot.average.transaction.value'></span>

<h3>Description</h3>

<p>Plots the actual and expected densities of average transaction values, and
returns a vector with each customer's average transaction value probability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spend.plot.average.transaction.value(
  params,
  m.x.vector,
  x.vector,
  xlab = "Average Transaction Value",
  ylab = "Marginal Distribution of Average Transaction Value",
  title = "Actual vs. Expected Average Transaction Value Across Customers"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spend.plot.average.transaction.value_+3A_params">params</code></td>
<td>
<p>a vector of gamma-gamma parameters: p, q, and gamma, in that
order. p is the shape parameter for each transaction. The scale parameter
for each transaction is distributed across customers according to a gamma
distribution with parameters q (shape) and gamma (scale).</p>
</td></tr>
<tr><td><code id="spend.plot.average.transaction.value_+3A_m.x.vector">m.x.vector</code></td>
<td>
<p>a vector with each customer's average observed transaction
value in the calibration period.</p>
</td></tr>
<tr><td><code id="spend.plot.average.transaction.value_+3A_x.vector">x.vector</code></td>
<td>
<p>a vector with the number of transactions each customer made
in the calibration period. Must correspond to m.x.vector in terms of
ordering of customers and length of the vector.</p>
</td></tr>
<tr><td><code id="spend.plot.average.transaction.value_+3A_xlab">xlab</code></td>
<td>
<p>descriptive label for the x axis.</p>
</td></tr>
<tr><td><code id="spend.plot.average.transaction.value_+3A_ylab">ylab</code></td>
<td>
<p>descriptive label for the y axis.</p>
</td></tr>
<tr><td><code id="spend.plot.average.transaction.value_+3A_title">title</code></td>
<td>
<p>title placed on the top-center of the plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector with the probability of each customer's average transaction
value.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spend.marginal.likelihood">spend.marginal.likelihood</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(cdnowSummary)
ave.spend &lt;- cdnowSummary$m.x
tot.trans &lt;- cdnowSummary$cbs[,"x"]
# params &lt;- c(6.25, 3.74, 15.44) # in original documentation. check below:
params &lt;- spend.EstimateParameters(m.x.vector = ave.spend, x.vector = tot.trans)

# Plot the actual and expected average transaction value across customers.
f.m.x &lt;- spend.plot.average.transaction.value(params, ave.spend, tot.trans)

## End(Not run)
</code></pre>

<hr>
<h2 id='subLogs'>Subtract Logs</h2><span id='topic+subLogs'></span>

<h3>Description</h3>

<p>Given log(a) and log(b), returns log(a - b)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subLogs(loga, logb)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subLogs_+3A_loga">loga</code></td>
<td>
<p>first number in log space.</p>
</td></tr>
<tr><td><code id="subLogs_+3A_logb">logb</code></td>
<td>
<p>first number in log space.</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
