<!DOCTYPE html><html><head><title>Help for package revpref</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {revpref}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bronars'><p>Computes the Bronars power index for a given axiom at a given efficiency level</p></a></li>
<li><a href='#ccei'><p>Computes the critical cost efficiency index</p></a></li>
<li><a href='#garp'><p>Tests consistency with the Generalized Axiom of Revealed Preference at efficiency <code class="reqn">e</code></p></a></li>
<li><a href='#mpi'><p>Computes the minimum and maximum money pump index</p></a></li>
<li><a href='#sarp'><p>Tests consistency with the Strong Axiom of Revealed Preference at efficiency <code class="reqn">e</code></p></a></li>
<li><a href='#warp'><p>Tests consistency with the Weak Axiom of Revealed Preference at efficiency <code class="reqn">e</code></p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Tools for Computational Revealed Preference Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Khushboo Surana &lt;khushboo.surana@york.ac.uk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools to (i) check consistency of a finite set of consumer demand observations with a number of revealed preference axioms at a given efficiency level, (ii) compute goodness-of-fit indices when the data do not obey the axioms, and (iii) compute power against uniformly random behavior.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ksurana21/revpref">https://github.com/ksurana21/revpref</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ksurana21/revpref/issues">https://github.com/ksurana21/revpref/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>gtools</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-07-05 11:03:31 UTC; ks1779</td>
</tr>
<tr>
<td>Author:</td>
<td>Khushboo Surana <a href="https://orcid.org/0000-0002-0453-6182"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-07-07 08:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bronars'>Computes the Bronars power index for a given axiom at a given efficiency level</h2><span id='topic+bronars'></span>

<h3>Description</h3>

<p>The power of the revealed preference test of a given axiom captures the probability of rejecting the
axiom if the data set is generated by irrational behavior. Following Bronars' (1987) approach, we measure power using
Becker's (1962) notion of irrational behavior. More specifically, we generate irrational behavior by
simulating a consumer who makes consumption choices randomly from his or her budget set such that the budget set is
exhausted. The Bronars power index captures the probability of rejecting the null hypothesis that the random choices are utility
maximizing. Essentially, Bronars' power index is the number of times a violation is detected in the
simulated data sets divided by the number of repetitions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bronars(p, q, simulation = 1000, model = "GARP", efficiency = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bronars_+3A_p">p</code></td>
<td>
<p>A <code class="reqn">T X N</code> matrix of observed prices where each row corresponds to an observation and each column
corresponds to a consumption category. <code class="reqn">T</code> is the number of observations and <code class="reqn">N</code> is the number of consumption
categories.</p>
</td></tr>
<tr><td><code id="bronars_+3A_q">q</code></td>
<td>
<p>A <code class="reqn">T X N</code> matrix of observed quantities where each row corresponds to an observation and each column
corresponds to a consumption category.<code class="reqn">T</code> is the number of observations and <code class="reqn">N</code> is the number of consumption
categories.</p>
</td></tr>
<tr><td><code id="bronars_+3A_simulation">simulation</code></td>
<td>
<p>Specifies the number of repetitions required of the simulated random data. The default
value is 1000.</p>
</td></tr>
<tr><td><code id="bronars_+3A_model">model</code></td>
<td>
<p>Specifies which axiom (GARP, SARP, or WARP) should be used to compute the power. The default option
is &quot;GARP&quot;.</p>
</td></tr>
<tr><td><code id="bronars_+3A_efficiency">efficiency</code></td>
<td>
<p>The efficiency level <code class="reqn">e</code> is a real number between 0 and 1 and allows for a
small margin of error. The default value is 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns the power of a given axiom against uniformly random behavior at a given efficiency level.
</p>


<h3>References</h3>


<ul>
<li><p> Becker, Gary S. &quot;Irrational behavior and economic theory.&quot; Journal of political economy 70,
no. 1 (1962): 1-13.
</p>
</li>
<li><p> Bronars, Stephen G. &quot;The power of nonparametric tests of preference maximization.&quot; Econometrica:
Journal of the Econometric Society (1987): 693-698.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># define a price matrix
p = matrix(c(4,4,4,1,9,3,2,8,3,1,
8,4,3,1,9,3,2,8,8,4,
1,4,1,8,9,3,1,8,3,2),
nrow = 10, ncol = 3, byrow = TRUE)

# define a quantity matrix
q = matrix(c( 1.81,0.19,10.51,17.28,2.26,4.13,12.33,2.05,2.99,6.06,
5.19,0.62,11.34,10.33,0.63,4.33,8.08,2.61,4.36,1.34,
9.76,1.37,36.35, 1.02,3.21,4.97,6.20,0.32,8.53,10.92),
nrow = 10, ncol = 3, byrow = TRUE)

# compute Bronars power index for GARP at full efficiency
bronars(p,q)

# compute Bronars power index for SARP at e = 0.99
bronars(p,q, model = "SARP", efficiency = 0.99)

</code></pre>

<hr>
<h2 id='ccei'>Computes the critical cost efficiency index</h2><span id='topic+ccei'></span>

<h3>Description</h3>

<p>The nonparametric tests of rationality axioms (<code><a href="#topic+garp">garp</a>, <a href="#topic+sarp">sarp</a></code>, and <code><a href="#topic+warp">warp</a></code>) are &quot;sharp&quot; in nature.
This means that the tests will only tell us whether the observed data set passed the rationality axioms.
However, when the data set fails, it is often useful to know how close the observed behavior is to
satisfying the rationality restrictions (see Varian (1990) for an extensive motivation). Over the years, several
measures (called goodness-of-fit indices) have been introduced to evaluate the degree to which the data set is consistent
with the rationality axiom(s). The most popular goodness-of-fit index is the Critical Cost Efficiency Index;
CCEI (also known as the Afriat Efficiency Index; AEI) proposed by Afriat (1973). The CCEI is defined as the maximal value of
the efficiency level <code class="reqn">e</code> such that the data set is consistent with GARP. Intuitively, this measure indicates the degree
to which the set of demand observations is consistent with GARP. This function computes the CCEI following the binary
search algorithm described in Varian (1990). Optionally, the user can specify the axiom (WARP, SARP, or GARP) for which
the CCEI needs to be computed. When no axiom is specified, the function takes the default option as GARP.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ccei(p, q, model = "GARP")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ccei_+3A_p">p</code></td>
<td>
<p>A <code class="reqn">T X N</code> matrix of observed prices where each row corresponds to an observation
and each column corresponds to a consumption category. <code class="reqn">T</code> is the number of observations
and <code class="reqn">N</code> is the number of consumption categories.</p>
</td></tr>
<tr><td><code id="ccei_+3A_q">q</code></td>
<td>
<p>A <code class="reqn">T X N</code> matrix of observed quantities where each row corresponds to an observation
and each column corresponds to a consumption category.<code class="reqn">T</code> is the number of observations
and <code class="reqn">N</code> is the number of consumption categories.</p>
</td></tr>
<tr><td><code id="ccei_+3A_model">model</code></td>
<td>
<p>Specifies which axiom (GARP, SARP, or WARP) should be used to compute the CCEI. The default value
is &quot;GARP&quot; which computes the usual CCEI (also known as the Afriat efficiency index, AEI) proposed by Afriat (1973).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns <code class="reqn">e^*</code> which is the highest efficiency level at which the data satisfy the
given axiom. For instance, if the given model is &quot;GARP&quot;, the function returns the maximal value of the efficiency
level <code class="reqn">e</code> such that the data satisfy <code class="reqn">e</code>GARP.
</p>


<h3>References</h3>


<ul>
<li><p> Afriat, Sydney N. &quot;On a system of inequalities in demand analysis: an extension of the classical method.&quot;
International economic review (1973): 460-472.
</p>
</li>
<li><p> Varian, Hal R. &quot;Goodness-of-fit in optimizing models.&quot; Journal of Econometrics 46, no. 1-2 (1990): 125-140.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+mpi">mpi</a></code> for the money pump index.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># define a price matrix
p = matrix(c(4,4,4,1,9,3,2,8,3,1,
8,4,3,1,9,3,2,8,8,4,
1,4,1,8,9,3,1,8,3,2),
nrow = 10, ncol = 3, byrow = TRUE)

# define a quantity matrix
q = matrix(c( 1.81,0.19,10.51,17.28,2.26,4.13,12.33,2.05,2.99,6.06,
5.19,0.62,11.34,10.33,0.63,4.33,8.08,2.61,4.36,1.34,
9.76,1.37,36.35, 1.02,3.21,4.97,6.20,0.32,8.53,10.92),
nrow = 10, ncol = 3, byrow = TRUE)

# compute ccei for GARP
ccei(p,q, model = "GARP")

# compute ccei for SARP
ccei(p,q, model = "SARP")

</code></pre>

<hr>
<h2 id='garp'>Tests consistency with the Generalized Axiom of Revealed Preference at efficiency <code class="reqn">e</code></h2><span id='topic+garp'></span>

<h3>Description</h3>

<p>This function allows the user to check whether a given data set is consistent with the Generalized Axiom of Revealed Preference
at efficiency <code class="reqn">e</code> (<code class="reqn">e</code>GARP) and computes the number of <code class="reqn">e</code>GARP violations. We say that a data set
satisfies GARP at efficiency level <code class="reqn">e</code> if <code class="reqn">q_t R_e q_s</code> implies <code class="reqn">ep_s'q_s \le p_s'q_t</code>.
It is clear that by setting <code class="reqn">e = 1</code>, we obtain the standard version of GARP as defined in Varian (1982).
While if <code class="reqn">e &lt; 1</code>, we allow for some optimization error in the choices to make the data set consistent with GARP.
The smaller the <code class="reqn">e</code> is, the larger will be the optimization error allowed in the test.
It is well known that GARP is a necessary and sufficient condition for a data set to be rationalized
by a continuous, strictly increasing, and concave preference function (see Afriat (1967) and Varian (1982)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>garp(p, q, efficiency = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="garp_+3A_p">p</code></td>
<td>
<p>A <code class="reqn">T X N</code> matrix of observed prices where each row corresponds to an observation
and each column corresponds to a consumption category. <code class="reqn">T</code> is the number of observations
and <code class="reqn">N</code> is the number of consumption categories.</p>
</td></tr>
<tr><td><code id="garp_+3A_q">q</code></td>
<td>
<p>A <code class="reqn">T X N</code> matrix of observed quantities where each row corresponds to an observation
and each column corresponds to a consumption category.<code class="reqn">T</code> is the number of observations
and <code class="reqn">N</code> is the number of consumption categories.</p>
</td></tr>
<tr><td><code id="garp_+3A_efficiency">efficiency</code></td>
<td>
<p>The efficiency level <code class="reqn">e</code>, is a real number between 0 and 1, which allows for a
small margin of error when checking for consistency with the axiom. The default value is 1, which corresponds to the
test of consistency with the exact GARP.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns two elements. The first element (<code>passgarp</code>) is a binary indicator telling us whether
the data set is consistent with GARP at efficiency level <code class="reqn">e</code>. It takes a value 1 if the data set is <code class="reqn">e</code>GARP
consistent and a value 0 if the data set is <code class="reqn">e</code>GARP inconsistent. The second element (<code>nviol</code>) reports the
number of <code class="reqn">e</code>GARP violations. If the data set is <code class="reqn">e</code>GARP consistent, <code>nviol</code> is 0. Note that the maximum
number of violations in an <code class="reqn">e</code>GARP inconsistent data is <code class="reqn">T(T-1)</code>.
</p>


<h3>Definitions</h3>

<p>For a given efficiency level <code class="reqn">0 \le e \le 1</code>, we say that:
</p>

<ul>
<li><p> bundle <code class="reqn">q_t</code> is directly revealed preferred to bundle <code class="reqn">q_s</code> at efficiency level <code class="reqn">e</code> (denoted as
<code class="reqn">q_t R^D_e q_s</code>) if <code class="reqn">ep_t'q_t \ge p_t'q_s</code>.
</p>
</li>
<li><p> bundle <code class="reqn">q_t</code> is strictly directly revealed preferred to bundle <code class="reqn">q_s</code> at efficiency level <code class="reqn">e</code>
(denoted as <code class="reqn">q_t P^D_e q_s</code>) if <code class="reqn">ep_t'q_t &gt; p_t'q_s</code>.
</p>
</li>
<li><p> bundle <code class="reqn">q_t</code> is revealed preferred to bundle <code class="reqn">q_s</code> at efficiency level <code class="reqn">e</code> (denoted as
<code class="reqn">q_t R_e q_s</code>) if there exists a (possibly empty) sequence of observations (<code class="reqn">t,u,v,\cdots,w,s</code>) such that
<code class="reqn">q_t R^D_e q_u</code>, <code class="reqn">q_u R^D_e q_v</code>, <code class="reqn">\cdots, q_w R^D_e q_s</code>.
</p>
</li></ul>



<h3>References</h3>


<ul>
<li><p> Afriat, Sydney N. &quot;The construction of utility functions from expenditure data.&quot;
International economic review 8, no. 1 (1967): 67-77.
</p>
</li>
<li><p> Varian, Hal R. &quot;The nonparametric approach to demand analysis.&quot; Econometrica:
Journal of the Econometric Society (1982): 945-973.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+sarp">sarp</a></code> for the Strong Axiom of Revealed Preference and <code><a href="#topic+warp">warp</a></code> for
the Weak Axiom of Revealed Preference.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># define a price matrix
p = matrix(c(4,4,4,1,9,3,2,8,3,1,
8,4,3,1,9,3,2,8,8,4,
1,4,1,8,9,3,1,8,3,2),
nrow = 10, ncol = 3, byrow = TRUE)

# define a quantity matrix
q = matrix(c( 1.81,0.19,10.51,17.28,2.26,4.13,12.33,2.05,2.99,6.06,
5.19,0.62,11.34,10.33,0.63,4.33,8.08,2.61,4.36,1.34,
9.76,1.37,36.35, 1.02,3.21,4.97,6.20,0.32,8.53,10.92),
nrow = 10, ncol = 3, byrow = TRUE)

# Test consistency with GARP and compute the number of GARP violations
garp(p,q)

# Test consistency with GARP and compute the number of GARP violations at e = 0.95
garp(p,q, efficiency = 0.95)

</code></pre>

<hr>
<h2 id='mpi'>Computes the minimum and maximum money pump index</h2><span id='topic+mpi'></span>

<h3>Description</h3>

<p>The nonparametric GARP test is &quot;sharp&quot; in nature. This means that the test will only tell us whether the observed data
set is consistent with GARP. However, when the data set fails, it is often useful to know how close the observed behavior is to
satisfying the rationality restrictions (see Varian (1990) for an extensive motivation). Over the years, several measures (called
goodness-of-fit indices) have been introduced to evaluate the degree to which the observed data set is consistent with the
rationality axiom. Echenique et al. (2011) proposed the money pump index (MPI) as a measure of the severity of a GARP violation.
The MPI is defined as the amount of money that an arbitrageur can pump from the consumer. The higher is
the MPI value, the more severe is the violation of rationality. While the MPI measure is conceptually appealing, it may
be computationally challenging to determine this index for data sets with a large number of observations. In particular,
Smeulders et al. (2013) showed that computing the mean and median MPI is an NP-hard problem. As easy-to-apply
alternatives, they proposed the minimum and maximum MPI which can be computed efficiently (in polynomial time).
This function implements the algorithm provided by these authors to measure the minimum and maximum MPI values for the
given data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpi(p, q)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mpi_+3A_p">p</code></td>
<td>
<p>A <code class="reqn">T X N</code> matrix of observed prices where each row corresponds to an observation and each column
corresponds to a consumption category. <code class="reqn">T</code> is the number of observations and <code class="reqn">N</code> is the number of consumption
categories.</p>
</td></tr>
<tr><td><code id="mpi_+3A_q">q</code></td>
<td>
<p>A <code class="reqn">T X N</code> matrix of observed quantities where each row corresponds to an observation and each column
corresponds to a consumption category.<code class="reqn">T</code> is the number of observations and <code class="reqn">N</code> is the number of consumption
categories.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns two elements. The first element (<code>minimum_MPI</code>) is the minimum MPI and the second
element (<code>maximum_MPI</code>) is the maximum MPI.
</p>


<h3>References</h3>


<ul>
<li><p> Echenique, Federico, Sangmok Lee, and Matthew Shum. &quot;The money pump as a measure of revealed preference
violations.&quot; Journal of Political Economy 119, no. 6 (2011): 1201-1223.
</p>
</li>
<li><p> Smeulders, Bart, Laurens Cherchye, Frits CR Spieksma, and Bram De Rock. &quot;The money pump as a measure of
revealed preference violations: A comment.&quot; Journal of Political Economy 121, no. 6 (2013): 1248-1258.
</p>
</li>
<li><p> Varian, Hal R. &quot;Goodness-of-fit in optimizing models.&quot; Journal of Econometrics 46, no. 1-2 (1990): 125-140.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+ccei">ccei</a></code> for the critical cost efficiency index.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># define a price matrix
p = matrix(c(4,4,4,1,9,3,2,8,3,1,
8,4,3,1,9,3,2,8,8,4,
1,4,1,8,9,3,1,8,3,2),
nrow = 10, ncol = 3, byrow = TRUE)

# define a quantity matrix
q = matrix(c( 1.81,0.19,10.51,17.28,2.26,4.13,12.33,2.05,2.99,6.06,
5.19,0.62,11.34,10.33,0.63,4.33,8.08,2.61,4.36,1.34,
9.76,1.37,36.35, 1.02,3.21,4.97,6.20,0.32,8.53,10.92),
nrow = 10, ncol = 3, byrow = TRUE)


# compute the minimum and maximum MPI
mpi(p,q)

</code></pre>

<hr>
<h2 id='sarp'>Tests consistency with the Strong Axiom of Revealed Preference at efficiency <code class="reqn">e</code></h2><span id='topic+sarp'></span>

<h3>Description</h3>

<p>This function allows the user to check whether a given data set is consistent with the Strong Axiom of Revealed Preference
at efficiency level <code class="reqn">e</code> (<code class="reqn">e</code>SARP) and computes the number of <code class="reqn">e</code>SARP violations.
We say that a data set satisfies SARP at efficiency level <code class="reqn">e</code> if <code class="reqn">q_t R_e q_s</code> implies <code class="reqn">ep_s'q_s &lt; p_s'q_t</code>
(see the definition of <code class="reqn">R_e</code> below). It is clear that by setting <code class="reqn">e = 1</code>, we obtain the standard version of SARP.
While if <code class="reqn">e &lt; 1</code>, we allow for some optimization error in the choices to make the data set consistent with SARP.
The smaller the <code class="reqn">e</code> is, the larger will be the optimization error allowed in the test.
It is well known that SARP is a necessary and sufficient condition for a data set to be rationalized
by a continuous, strictly increasing, and strictly concave preference function (see Matzkin and Richter (1991)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sarp(p, q, efficiency = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sarp_+3A_p">p</code></td>
<td>
<p>A <code class="reqn">T X N</code> matrix of observed prices where each row corresponds to an observation
and each column corresponds to a consumption category. <code class="reqn">T</code> is the number of observations
and <code class="reqn">N</code> is the number of consumption categories.</p>
</td></tr>
<tr><td><code id="sarp_+3A_q">q</code></td>
<td>
<p>A <code class="reqn">T X N</code> matrix of observed quantities where each row corresponds to an observation
and each column corresponds to a consumption category.<code class="reqn">T</code> is the number of observations
and <code class="reqn">N</code> is the number of consumption categories.</p>
</td></tr>
<tr><td><code id="sarp_+3A_efficiency">efficiency</code></td>
<td>
<p>The efficiency level <code class="reqn">e</code>, is a real number between 0 and 1, which allows for a
small margin of error when checking for consistency with the axiom. The default value is 1, which corresponds to the
test of consistency with the exact SARP.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns two elements. The first element (<code>passsarp</code>) is a binary indicator telling us whether
the data set is consistent with SARP at a given efficiency level <code class="reqn">e</code>. It takes a value 1 if the data set
is <code class="reqn">e</code>SARP consistent and a value 0 if the data set is <code class="reqn">e</code>SARP inconsistent.
The second element (<code>nviol</code>) reports the number of <code class="reqn">e</code>SARP violations. If the data is <code class="reqn">e</code>SARP
consistent, <code>nviol</code> is 0. Note that the maximum number of violations in an <code class="reqn">e</code>SARP inconsistent data is
<code class="reqn">T(T-1)</code>.
</p>


<h3>Definitions</h3>

<p>For a given efficiency level <code class="reqn">0 \le e \le 1</code>, we say that:
</p>

<ul>
<li><p> bundle <code class="reqn">q_t</code> is directly revealed preferred to bundle <code class="reqn">q_s</code> at efficiency level <code class="reqn">e</code> (denoted as
<code class="reqn">q_t R^D_e q_s</code>) if <code class="reqn">ep_t'q_t \ge p_t'q_s</code>.
</p>
</li>
<li><p> bundle <code class="reqn">q_t</code> is strictly directly revealed preferred to bundle <code class="reqn">q_s</code> at efficiency level <code class="reqn">e</code>
(denoted as <code class="reqn">q_t P^D_e q_s</code>) if <code class="reqn">ep_t'q_t &gt; p_t'q_s</code>.
</p>
</li>
<li><p> bundle <code class="reqn">q_t</code> is revealed preferred to bundle <code class="reqn">q_s</code> at efficiency level <code class="reqn">e</code> (denoted as
<code class="reqn">q_t R_e q_s</code>) if there exists a (possibly empty) sequence of observations (<code class="reqn">t,u,v,\cdots,w,s</code>) such that
<code class="reqn">q_t R^D_e q_u</code>, <code class="reqn">q_u R^D_e q_v</code>, <code class="reqn">\cdots, q_w R^D_e q_s</code>.
</p>
</li></ul>



<h3>References</h3>


<ul>
<li><p> Matzkin, Rosa L., and Marcel K. Richter. &quot;Testing strictly concave rationality.&quot;
Journal of Economic Theory 53, no. 2 (1991): 287-303.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+garp">garp</a></code> for the Generalized Axiom of Revealed Preference and <code><a href="#topic+warp">warp</a></code> for
the Weak Axiom of Revealed Preference.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># define a price matrix
p = matrix(c(4,4,4,1,9,3,2,8,3,1,
8,4,3,1,9,3,2,8,8,4,
1,4,1,8,9,3,1,8,3,2),
nrow = 10, ncol = 3, byrow = TRUE)

# define a quantity matrix
q = matrix(c( 1.81,0.19,10.51,17.28,2.26,4.13,12.33,2.05,2.99,6.06,
5.19,0.62,11.34,10.33,0.63,4.33,8.08,2.61,4.36,1.34,
9.76,1.37,36.35, 1.02,3.21,4.97,6.20,0.32,8.53,10.92),
nrow = 10, ncol = 3, byrow = TRUE)

# Test consistency with SARP and compute the number of SARP violations
sarp(p,q)

# Test consistency with SARP and compute the number of SARP violations at e = 0.95
sarp(p,q, efficiency = 0.95)


</code></pre>

<hr>
<h2 id='warp'>Tests consistency with the Weak Axiom of Revealed Preference at efficiency <code class="reqn">e</code></h2><span id='topic+warp'></span>

<h3>Description</h3>

<p>This function allows the user to check whether a given data set is consistent with the Weak Axiom of Revealed
Preference at efficiency level <code class="reqn">e</code> (<code class="reqn">e</code>WARP) and computes the number of <code class="reqn">e</code>WARP violations.
We say that a data set satisfies WARP at efficiency level <code class="reqn">e</code> if <code class="reqn">q_t R^D_e q_s</code> and <code class="reqn">q_t \neq q_s</code>
implies <code class="reqn">ep_s'q_s &lt; p_s'q_t</code> (see the definition of R^D_e below). The exact WARP, with <code class="reqn">e = 1</code>, is a necessary and sufficient
condition for a data set to be rationalizable by a continuous, strictly increasing, piecewise strictly concave,
and skew-symmetric preference function (see Aguiar et al. (2020)). Moreover, Rose (1958) showed that for the case
of two goods (<code class="reqn">N = 2</code>), WARP is equivalent to the Strong Axiom of Revealed Preference (SARP). In other words,
when there are only two consumption categories, transitivity has no empirical bite.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>warp(p, q, efficiency = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="warp_+3A_p">p</code></td>
<td>
<p>A <code class="reqn">T \times N</code> matrix of observed prices where each row corresponds to an observation
and each column corresponds to a consumption category. <code class="reqn">T</code> is the number of observations
and <code class="reqn">N</code> is the number of consumption categories.</p>
</td></tr>
<tr><td><code id="warp_+3A_q">q</code></td>
<td>
<p>A <code class="reqn">T \times N</code> matrix of observed quantities where each row corresponds to an observation
and each column corresponds to a consumption category.<code class="reqn">T</code> is the number of observations
and <code class="reqn">N</code> is the number of consumption categories.</p>
</td></tr>
<tr><td><code id="warp_+3A_efficiency">efficiency</code></td>
<td>
<p>The efficiency level <code class="reqn">e</code>, is a real number between 0 and 1, which allows for a
small margin of error when checking for consistency with the axiom. The default value is 1, which corresponds to the
test of consistency with the exact WARP.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns two elements. The first element (<code>passwarp</code>) is a binary indicator telling us
whether the data set is consistent with WARP at a given efficiency level <code class="reqn">e</code>. It takes a value 1 if the data set
is <code class="reqn">e</code>WARP consistent and a value 0 if the data set is <code class="reqn">e</code>WARP inconsistent.
The second element (<code>nviol</code>) reports the number of <code class="reqn">e</code>WARP violations. If the data set is <code class="reqn">e</code>WARP
consistent, <code>nviol</code> is 0. Note that the maximum number of violations in an <code class="reqn">e</code>WARP inconsistent data is
<code class="reqn">T(T-1)/2</code>.
</p>


<h3>Definitions</h3>

<p>For a given efficiency level <code class="reqn">0 \le e \le 1</code>, we say that:
</p>

<ul>
<li><p> bundle <code class="reqn">q_t</code> is directly revealed preferred to bundle <code class="reqn">q_s</code> at efficiency level <code class="reqn">e</code> (denoted as
<code class="reqn">q_t R^D_e q_s</code>) if <code class="reqn">ep_t'q_t \ge p_t'q_s</code>.
</p>
</li></ul>



<h3>References</h3>


<ul>
<li><p> Aguiar, Victor, Per Hjertstrand, and Roberto Serrano. &quot;A Rationalization of the Weak Axiom of Revealed
Preference.&quot; (2020).
</p>
</li>
<li><p> Rose, Hugh. &quot;Consistency of preference: the two-commodity case.&quot; The Review of Economic Studies 25,
no. 2 (1958): 124-125.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+sarp">sarp</a></code> for the Strong Axiom of Revealed Preference and <code><a href="#topic+garp">garp</a></code> for
the Generalized Axiom of Revealed Preference.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# define a price matrix
p = matrix(c(4,4,4,1,9,3,2,8,3,1,
8,4,3,1,9,3,2,8,8,4,
1,4,1,8,9,3,1,8,3,2),
nrow = 10, ncol = 3, byrow = TRUE)

# define a quantity matrix
q = matrix(c( 1.81,0.19,10.51,17.28,2.26,4.13,12.33,2.05,2.99,6.06,
5.19,0.62,11.34,10.33,0.63,4.33,8.08,2.61,4.36,1.34,
9.76,1.37,36.35, 1.02,3.21,4.97,6.20,0.32,8.53,10.92),
nrow = 10, ncol = 3, byrow = TRUE)

# Test consistency with WARP and compute the number of WARP violations
warp(p,q)

# Test consistency with WARP and compute the number of WARP violations at e = 0.95
warp(p,q, efficiency = 0.95)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
