<!DOCTYPE html><html lang="en"><head><title>Help for package BinNonNor</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BinNonNor}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BinNonNor-package'><p>Data Generation with Binary and Continuous Non-Normal Components</p></a></li>
<li><a href='#Biserial.Corr.BN'><p>Computes the biserial correlation matrix for binary and continuous non-normal variables given the specified correlation matrix</p></a></li>
<li><a href='#correlation.bound.check'><p>Checks if the pairwise correlation among variables are within the feasible range</p></a></li>
<li><a href='#correlation.limits'><p>Computes lower and upper correlation bounds for each pair of variables</p></a></li>
<li><a href='#fleishman.coef'><p>Computes the coefficients of Fleishman third order polynomials</p></a></li>
<li><a href='#gen.Bin.NonNor'><p>Simulates a sample of size n from a set of multivariate binary and continuous non-normal variables</p></a></li>
<li><a href='#Int.Corr.NN'><p>Computes an intermediate correlation matrix for continuous non-normal variables given the specified correlation</p>
matrix</a></li>
<li><a href='#overall.corr.mat'><p>Computes the final correlation matrix</p></a></li>
<li><a href='#Tetra.Corr.BB'><p>Computes the tetrachoric correlation matrix for binary variables given the specified correlation matrix</p></a></li>
<li><a href='#validation.bin'><p>Validates the marginal specification of the binary variables</p></a></li>
<li><a href='#validation.corr'><p>Validates the specified correlation matrix</p></a></li>
<li><a href='#validation.skewness.kurtosis'><p>Validates the marginal specification of the continuous non-normal variables</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Data Generation with Binary and Continuous Non-Normal Components</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-03-21</td>
</tr>
<tr>
<td>Author:</td>
<td>Gul Inan, Hakan Demirtas, Ran Gao</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ran Gao &lt;rgao8@uic.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Generation of multiple binary and continuous non-normal variables simultaneously 
             given the marginal characteristics and association structure based on the methodology 
             proposed by Demirtas et al. (2012) &lt;<a href="https://doi.org/10.1002%2Fsim.5362">doi:10.1002/sim.5362</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>BB, corpcor, mvtnorm, Matrix</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-03-22 01:56:42 UTC; rangao</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-03-22 05:40:32 UTC</td>
</tr>
</table>
<hr>
<h2 id='BinNonNor-package'>Data Generation with Binary and Continuous Non-Normal Components</h2><span id='topic+BinNonNor-package'></span><span id='topic+BinNonNor'></span>

<h3>Description</h3>

<p>Provides R functions for generation of multiple binary and continuous non-normal variables
simultaneously given the marginal characteristics and association structure based on the methodology proposed by Demirtas et al. (2012).</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> BinNonNor</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.5.3</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2021-03-21</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2 | GPL-3 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>This package consists of eleven functions. The functions <code><a href="#topic+validation.bin">validation.bin</a></code>,
<code><a href="#topic+validation.corr">validation.corr</a></code>, and <code><a href="#topic+validation.skewness.kurtosis">validation.skewness.kurtosis</a></code> validate the specified quantities to avoid obvious specification errors. The function
<code><a href="#topic+fleishman.coef">fleishman.coef</a></code> computes the coefficients of the third order Fleishman polynomials that are used to simulate the continuous non-normal variables. 
<code><a href="#topic+correlation.limits">correlation.limits</a></code> returns the lower and upper bounds of the pairwise correlation of binary and binary
and binary and continuous non-normal, and continuous non-normal and continuous non-normal pairs given their marginal distributions,
i.e. returns the range of feasible pairwise correlations. The function <code><a href="#topic+correlation.bound.check">correlation.bound.check</a></code>
checks the validity of the values of pairwise correlations. The functions <code><a href="#topic+Int.Corr.NN">Int.Corr.NN</a></code>, <code><a href="#topic+Tetra.Corr.BB">Tetra.Corr.BB</a></code>, and  <code><a href="#topic+Biserial.Corr.BN">Biserial.Corr.BN</a></code> 
computes intermediate correlation matrix for continuous non-normal and continuous non-normal combinations, 
tetrachoric correlations for binary and binary combinations, and biserial correlations for binary and continuous non-normal combinations, respectively. 
The function <code><a href="#topic+overall.corr.mat">overall.corr.mat</a></code> assembles the final correlation matrix. The engine function <code><a href="#topic+gen.Bin.NonNor">gen.Bin.NonNor</a></code>
generates mixed data in accordance with the specified marginal and correlational quantities. Throughout the package, 
variables are supposed to be inputted in a certain order, namely, first binary variables, and then continuous variables should be placed. 
</p>


<h3>Author(s)</h3>

<p>Gul Inan, Hakan Demirtas, Ran Gao 
</p>
<p>Maintainer: Ran Gao &lt;rgao8@uic.edu&gt;</p>


<h3>References</h3>

<p>Demirtas, H., Hedeker, D., and Mermelstein, R.J. (2012). Simulation of massive public health data by power polynomials. 
Statistics in Medicine, 31(27), 3337-3346.</p>

<hr>
<h2 id='Biserial.Corr.BN'>Computes the biserial correlation matrix for binary and continuous non-normal variables given the specified correlation matrix</h2><span id='topic+Biserial.Corr.BN'></span>

<h3>Description</h3>

<p>This function computes the biserial correlation matrix for binary-continuous non-normal combinations as formulated in Demirtas et al.
(2012).</p>


<h3>Usage</h3>

<pre><code class='language-R'>Biserial.Corr.BN(n.BB, n.NN, prop.vec, corr.vec = NULL, corr.mat = NULL, coef.mat)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Biserial.Corr.BN_+3A_n.bb">n.BB</code></td>
<td>
<p>Number of binary variables.</p>
</td></tr>
<tr><td><code id="Biserial.Corr.BN_+3A_n.nn">n.NN</code></td>
<td>
<p>Number of continuous non-normal variables.</p>
</td></tr>
<tr><td><code id="Biserial.Corr.BN_+3A_prop.vec">prop.vec</code></td>
<td>
<p>Probability vector for binary variables.</p>
</td></tr>
<tr><td><code id="Biserial.Corr.BN_+3A_corr.vec">corr.vec</code></td>
<td>
<p>Vector of elements below the diagonal of correlation matrix ordered columnwise.</p>
</td></tr>
<tr><td><code id="Biserial.Corr.BN_+3A_corr.mat">corr.mat</code></td>
<td>
<p>Specified correlation matrix.</p>
</td></tr>
<tr><td><code id="Biserial.Corr.BN_+3A_coef.mat">coef.mat</code></td>
<td>
<p>Matrix of coefficients produced from <code><a href="#topic+fleishman.coef">fleishman.coef</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of size n.BB*n.NN.</p>


<h3>References</h3>

<p>Demirtas, H., Hedeker, D., and Mermelstein, R.J. (2012). Simulation of massive public health data by power polynomials. 
Statistics in Medicine, 31(27), 3337-3346.</p>


<h3>See Also</h3>

<p><code><a href="#topic+fleishman.coef">fleishman.coef</a></code>, <code><a href="#topic+Tetra.Corr.BB">Tetra.Corr.BB</a></code>, <code><a href="#topic+Int.Corr.NN">Int.Corr.NN</a></code>, <code><a href="#topic+overall.corr.mat">overall.corr.mat</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>n.BB=2
n.NN=4
prop.vec=c(0.4,0.7)
corr.vec=NULL
corr.mat=matrix(c(1.0,-0.3,-0.3,-0.3,-0.3,-0.3,
-0.3,1.0,-0.3,-0.3,-0.3,-0.3,
-0.3,-0.3,1.0,0.4,0.5,0.6,
-0.3,-0.3,0.4,1.0,0.7,0.8,
-0.3,-0.3,0.5,0.7,1.0,0.9,
-0.3,-0.3,0.6,0.8,0.9,1.0),6,byrow=TRUE)

coef.mat=matrix(c(
 -0.31375,  0.00000,  0.10045, -0.10448,
  0.82632,  1.08574,  1.10502,  0.98085,
  0.31375,  0.00000, -0.10045,  0.10448,
  0.02271, -0.02945, -0.04001,  0.00272),4,byrow=TRUE)

bicor.mat=Biserial.Corr.BN(n.BB,n.NN,prop.vec,corr.vec=NULL,corr.mat,coef.mat)

n.BB=1
n.NN=1
prop.vec=0.6
corr.vec=NULL
corr.mat=matrix(c(1,-0.3,-0.3,1),2,2)
coef.mat=matrix(c(-0.31375,0.82632,0.31375,0.02271),4,1)
bicor.mat=Biserial.Corr.BN(n.BB,n.NN,prop.vec,corr.vec=NULL,corr.mat,coef.mat)
</code></pre>

<hr>
<h2 id='correlation.bound.check'>Checks if the pairwise correlation among variables are within the feasible range</h2><span id='topic+correlation.bound.check'></span>

<h3>Description</h3>

<p>This function checks if there are range violations among correlation of binary-binary, binary-continuous, and continuous-continuous combinations.</p>


<h3>Usage</h3>

<pre><code class='language-R'>correlation.bound.check(n.BB, n.NN, prop.vec = NULL, corr.vec = NULL, 
       corr.mat = NULL, coef.mat = NULL)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="correlation.bound.check_+3A_n.bb">n.BB</code></td>
<td>
<p>Number of binary variables.</p>
</td></tr>
<tr><td><code id="correlation.bound.check_+3A_n.nn">n.NN</code></td>
<td>
<p>Number of continuous non-normal variables.</p>
</td></tr>
<tr><td><code id="correlation.bound.check_+3A_prop.vec">prop.vec</code></td>
<td>
<p>Probability vector for binary variables.</p>
</td></tr>
<tr><td><code id="correlation.bound.check_+3A_corr.vec">corr.vec</code></td>
<td>
<p>Specified correlation vector.</p>
</td></tr>
<tr><td><code id="correlation.bound.check_+3A_corr.mat">corr.mat</code></td>
<td>
<p>Specified correlation matrix.</p>
</td></tr>
<tr><td><code id="correlation.bound.check_+3A_coef.mat">coef.mat</code></td>
<td>
<p>Matrix of coefficients produced from <code><a href="#topic+fleishman.coef">fleishman.coef</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns TRUE if no specification problem is encountered. Otherwise, it returns an error message.</p>


<h3>References</h3>

<p>Demirtas, H. and Hedeker, D. (2011). A practical way for computing approximate lower and upper
correlation bounds. The American Statistician, 65(2), 104-109.
</p>
<p>Demirtas, H., Hedeker, D., and Mermelstein, R.J. (2012). Simulation of massive public health data by power polynomials. 
Statistics in Medicine, 31(27), 3337-3346.</p>


<h3>See Also</h3>

<p><code><a href="#topic+fleishman.coef">fleishman.coef</a></code>, <code><a href="#topic+correlation.limits">correlation.limits</a></code>, <code><a href="#topic+validation.corr">validation.corr</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>prop.vec=c(0.4,0.7)
n.BB=2
n.NN=4
corr.vec=NULL
corr.mat=matrix(c(1.0,-0.3,-0.3,-0.3,-0.3,-0.3,
-0.3,1.0,-0.3,-0.3,-0.3,-0.3,
-0.3,-0.3,1.0,0.4,0.5,0.6,
-0.3,-0.3,0.4,1.0,0.7,0.8,
-0.3,-0.3,0.5,0.7,1.0,0.9,
-0.3,-0.3,0.6,0.8,0.9,1.0),6,byrow=TRUE)

coef.mat=matrix(c(
 -0.31375,  0.00000,  0.10045, -0.10448,
  0.82632,  1.08574,  1.10502,  0.98085,
  0.31375,  0.00000, -0.10045,  0.10448,
  0.02271, -0.02945, -0.04001,  0.00272),4,byrow=TRUE)

correlation.bound.check(n.BB,n.NN,prop.vec,corr.vec=NULL,corr.mat,coef.mat)

cor.mat.BB=corr.mat[1:2,1:2]
correlation.bound.check(n.BB,n.NN=0,prop.vec,corr.vec=NULL,corr.mat=cor.mat.BB,
coef.mat=NULL)

cor.mat.NN=corr.mat[3:6,3:6]
correlation.bound.check(n.BB=0,n.NN,prop.vec=NULL,corr.vec=NULL,corr.mat=cor.mat.NN,
coef.mat)

n.BB=1
prop.vec=0.5
corr.mat=diag(n.BB)
correlation.bound.check(n.BB,n.NN=0,prop.vec,corr.vec=NULL,corr.mat=corr.mat,
coef.mat=NULL)

## Not run: 
cor.mat.NNnew=cor.mat.NN
cor.mat.NNnew[1,2]=0.92
cor.mat.NNnew[2,1]=0.92
correlation.bound.check(n.BB=0,n.NN,prop.vec=NULL,corr.vec=NULL,corr.mat=cor.mat.NNnew,
coef.mat)

## End(Not run)
</code></pre>

<hr>
<h2 id='correlation.limits'>Computes lower and upper correlation bounds for each pair of variables</h2><span id='topic+correlation.limits'></span>

<h3>Description</h3>

<p>This function computes lower and upper limits for pairwise correlation of binary-binary, binary-continuous non-normal,
and continuous non-normal-continuous non-normal combinations.</p>


<h3>Usage</h3>

<pre><code class='language-R'>correlation.limits(n.BB, n.NN, prop.vec = NULL, coef.mat = NULL)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="correlation.limits_+3A_n.bb">n.BB</code></td>
<td>
<p>Number of binar variables.</p>
</td></tr>
<tr><td><code id="correlation.limits_+3A_n.nn">n.NN</code></td>
<td>
<p>Number of continuous non-normal variables.</p>
</td></tr>
<tr><td><code id="correlation.limits_+3A_prop.vec">prop.vec</code></td>
<td>
<p>Probability vector for binary variables.</p>
</td></tr>
<tr><td><code id="correlation.limits_+3A_coef.mat">coef.mat</code></td>
<td>
<p>Matrix of coefficients produced from <code><a href="#topic+fleishman.coef">fleishman.coef</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>While the function computes the exact lower and upper bounds for pairwise correlations among binary-binary variables 
as formulated in Demirtas et al. (2012), it computes approximate lower and upper bounds for pairwise correlations among binary-continuous non-normal 
and continuous non-normal-continuous non-normal variables through the method suggested by Demirtas and Hedeker (2011).</p>


<h3>Value</h3>

<p>The function returns a matrix of size (n.BB + n.NN)*(n.BB + n.NN), where the lower triangular part of the matrix contains the lower bounds and the upper triangular part of the matrix contains the upper bounds of the feasible correlations.</p>


<h3>References</h3>

<p>Demirtas, H. and Hedeker, D. (2011). A practical way for computing approximate lower and upper
correlation bounds. The American Statistician, 65(2), 104-109.
</p>
<p>Demirtas, H., Hedeker, D., and Mermelstein, R.J. (2012). Simulation of massive public health data by power polynomials. 
Statistics in Medicine, 31(27), 3337-3346.</p>


<h3>See Also</h3>

<p><code><a href="#topic+fleishman.coef">fleishman.coef</a></code>, <code><a href="#topic+correlation.bound.check">correlation.bound.check</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
n.BB=2
n.NN=4
prop.vec=c(0.4,0.7)
coef.mat=matrix(c(
 -0.31375,  0.00000,  0.10045, -0.10448,
  0.82632,  1.08574,  1.10502,  0.98085,
  0.31375,  0.00000, -0.10045,  0.10448,
  0.02271, -0.02945, -0.04001,  0.00272),4,byrow=TRUE)

limits=correlation.limits(n.BB,n.NN,prop.vec,coef.mat)
limits.bin=correlation.limits(n.BB,n.NN=0,prop.vec,coef.mat=NULL)
limits.nonnor=correlation.limits(n.BB=0,n.NN,prop.vec=NULL,coef.mat)

## Not run: 
n.BB=1
prop.vec=0.5
limits=correlation.limits(n.BB,n.NN,prop.vec,coef.mat=NULL)

## End(Not run)
</code></pre>

<hr>
<h2 id='fleishman.coef'>Computes the coefficients of Fleishman third order polynomials</h2><span id='topic+fleishman.coef'></span>

<h3>Description</h3>

<p>Computes the coefficients of Fleishman third order polynomials given the marginal skewness and kurtosis parameters of
continuous variables.</p>


<h3>Usage</h3>

<pre><code class='language-R'>fleishman.coef(n.NN, skewness.vec = NULL, kurtosis.vec = NULL)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fleishman.coef_+3A_n.nn">n.NN</code></td>
<td>
<p>Number of  continuous non-normal variables.</p>
</td></tr>
<tr><td><code id="fleishman.coef_+3A_skewness.vec">skewness.vec</code></td>
<td>
<p>Skewness vector for continuous non-normal variables.</p>
</td></tr>
<tr><td><code id="fleishman.coef_+3A_kurtosis.vec">kurtosis.vec</code></td>
<td>
<p>Kurtosis vector for continuous non-normal variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The execution of the function may take some time since it uses multiple starting points to solve the system of nonlinear equations based on the third order
Fleishman polynomials. However, since users need to run it only once for a given set of specifications, it does not constitute a problem.</p>


<h3>Value</h3>

<p>A matrix of coefficients. The columns represent the variables and rows represent the corresponding a,b,c, and d coefficients.</p>


<h3>References</h3>

<p>Demirtas, H., Hedeker, D., and Mermelstein, R.J. (2012). Simulation of massive public health data by power polynomials. 
Statistics in Medicine, 31(27), 3337-3346.<br />
<br />
Fleishman, A.I. (1978). A method for simulating non-normal distributions. Psychometrika, 43(4), 521-532.</p>


<h3>See Also</h3>

<p><code><a href="#topic+validation.skewness.kurtosis">validation.skewness.kurtosis</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
#Consider four nonnormal continuous variables, which come from
#Exp(1),Beta(4,4),Beta(4,2) and Gamma(10,10), respectively.
#Skewness and kurtosis values of these variables are as follows:
n.NN=4
skewness.vec=c(2,0,-0.4677,0.6325)
kurtosis.vec=c(6,-0.5455,-0.3750,0.6)
coef.mat=fleishman.coef(n.NN,skewness.vec,kurtosis.vec)

n.NN=1
skewness.vec=c(0)
kurtosis.vec=c(-1.2)
coef.mat=fleishman.coef(n.NN,skewness.vec,kurtosis.vec)

n.NN=1
skewness.vec1=c(3)
kurtosis.vec1=c(5)
coef.mat=fleishman.coef(n.NN,skewness.vec1,kurtosis.vec1)

## End(Not run)
</code></pre>

<hr>
<h2 id='gen.Bin.NonNor'>Simulates a sample of size n from a set of multivariate binary and continuous non-normal variables</h2><span id='topic+gen.Bin.NonNor'></span>

<h3>Description</h3>

<p>This function simulates a multivariate data set with binary and continuous components with pre-specified marginals and a correlation matrix. Setting n.NN=0 and quantities that are pertinent to the continuous part to NULL results in simulation of a sample of size n from a set of multivariate binary variables. Similarly, setting n.BB=0
and prop.vec=NULL results in simulation of a sample of size n from a set of multivariate continuous non-normal variables.</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.Bin.NonNor(n, n.BB, n.NN, prop.vec = NULL, mean.vec = NULL, variance.vec = NULL, 
skewness.vec = NULL, kurtosis.vec = NULL, final.corr.mat, coef.mat = NULL)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gen.Bin.NonNor_+3A_n">n</code></td>
<td>
<p>Number of variates.</p>
</td></tr>
<tr><td><code id="gen.Bin.NonNor_+3A_n.bb">n.BB</code></td>
<td>
<p>Number of binary variables.</p>
</td></tr>
<tr><td><code id="gen.Bin.NonNor_+3A_n.nn">n.NN</code></td>
<td>
<p>Number of continuous non-normal variables.</p>
</td></tr>
<tr><td><code id="gen.Bin.NonNor_+3A_prop.vec">prop.vec</code></td>
<td>
<p>Probability vector for binary variables.</p>
</td></tr>
<tr><td><code id="gen.Bin.NonNor_+3A_mean.vec">mean.vec</code></td>
<td>
<p>Mean vector for continuous non-normal variables.</p>
</td></tr>
<tr><td><code id="gen.Bin.NonNor_+3A_variance.vec">variance.vec</code></td>
<td>
<p>Variance vector for continuous non-normal variables.</p>
</td></tr>
<tr><td><code id="gen.Bin.NonNor_+3A_skewness.vec">skewness.vec</code></td>
<td>
<p>Skewness vector for continuous non-normal variables.</p>
</td></tr>
<tr><td><code id="gen.Bin.NonNor_+3A_kurtosis.vec">kurtosis.vec</code></td>
<td>
<p>Kurtosis vector for continuous non-normal variables.</p>
</td></tr>
<tr><td><code id="gen.Bin.NonNor_+3A_final.corr.mat">final.corr.mat</code></td>
<td>
<p>Final correlation matrix produced from <code><a href="#topic+overall.corr.mat">overall.corr.mat</a></code>.</p>
</td></tr>
<tr><td><code id="gen.Bin.NonNor_+3A_coef.mat">coef.mat</code></td>
<td>
<p>Matrix of coefficients produced from <code><a href="#topic+fleishman.coef">fleishman.coef</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of size n*(n.BB + n.NN) of which the first n.BB 
columns are binary variables and the last n.NN columns are continuous variables.</p>


<h3>References</h3>

<p>Demirtas, H., Hedeker, D., and Mermelstein, R.J. (2012). Simulation of massive public health data by power polynomials. 
Statistics in Medicine, 31(27), 3337-3346.
</p>
<p>Vale, C.D. and Maurelli, V.A. (1983). Simulating multivariate nonnormal distributions. Psychometrika, 48(3), 465-471.</p>


<h3>See Also</h3>

<p><code><a href="#topic+validation.bin">validation.bin</a></code>, <code><a href="#topic+validation.skewness.kurtosis">validation.skewness.kurtosis</a></code>,<code><a href="#topic+overall.corr.mat">overall.corr.mat</a></code>, <code><a href="#topic+fleishman.coef">fleishman.coef</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
n=1
n.BB=2
n.NN=4
prop.vec=c(0.4,0.7)
mean.vec=c(1,0.5,4/6,100)
variance.vec=c(1,0.02777778,0.03174603,1000)
skewness.vec=c(2,0,-0.4677,0.6325)
kurtosis.vec=c(6,-0.5455,-0.3750,0.6)
corr.mat=matrix(c(1.0,-0.3,-0.3,-0.3,-0.3,-0.3,
-0.3,1.0,-0.3,-0.3,-0.3,-0.3,
-0.3,-0.3,1.0,0.4,0.5,0.6,
-0.3,-0.3,0.4,1.0,0.7,0.8,
-0.3,-0.3,0.5,0.7,1.0,0.9,
-0.3,-0.3,0.6,0.8,0.9,1.0),6,byrow=TRUE)

coef.mat=fleishman.coef(n.NN,skewness.vec,kurtosis.vec)

coef.mat=matrix(c(
 -0.31375,  0.00000,  0.10045, -0.10448,
  0.82632,  1.08574,  1.10502,  0.98085,
  0.31375,  0.00000, -0.10045,  0.10448,
  0.02271, -0.02945, -0.04001,  0.00272),4,byrow=TRUE)

intcor.mat=Int.Corr.NN(n.NN,corr.vec=NULL,corr.mat,coef.mat) 

intcor.mat=matrix(c(
1.0000000, 0.4487800, 0.5940672, 0.6471184,
0.4487800, 1.0000000, 0.7099443, 0.8112701,
0.5940672, 0.7099443, 1.0000000, 0.9436195,
0.6471184, 0.8112701, 0.9436195, 1.0000000),4,byrow=TRUE)

tetcor.mat=Tetra.Corr.BB(n.BB,prop.vec,corr.vec=NULL,corr.mat)
tetcor.mat=matrix(c(
 1.0000000, -0.4713861,
-0.4713861,  1.0000000),2,byrow=TRUE)

bicor.mat=Biserial.Corr.BN(n.BB,n.NN,prop.vec,corr.vec=NULL,corr.mat,coef.mat)
bicor.mat=matrix(c(
-0.4253059, -0.3814058, -0.3862068, -0.3846430,
-0.4420613, -0.3964317, -0.4014219, -0.3997964),2,byrow=TRUE)

final.corr.mat=overall.corr.mat(n.BB,n.NN,prop.vec,corr.vec=NULL,corr.mat,coef.mat)

final.corr.mat=matrix(c(
  1.0000000, -0.4713861, -0.4253059, -0.3814058, -0.3862068, -0.3846430,
 -0.4713861,  1.0000000, -0.4420613, -0.3964317, -0.4014219, -0.3997964,
 -0.4253059, -0.4420613,  1.0000000,  0.4487800,  0.5940672,  0.6471184,
 -0.3814058, -0.3964317,  0.4487800,  1.0000000,  0.7099443,  0.8112701,
 -0.3862068, -0.4014219,  0.5940672,  0.7099443,  1.0000000,  0.9436195,
 -0.3846430, -0.3997964,  0.6471184,  0.8112701,  0.9436195,  1.0000000),6, byrow=TRUE)

data=gen.Bin.NonNor(n,n.BB,n.NN,prop.vec,mean.vec,variance.vec,skewness.vec, 
kurtosis.vec,final.corr.mat,coef.mat)

amat=final.corr.mat[1:2,1:2]
multibin=gen.Bin.NonNor(n=1000,n.BB,n.NN=0,prop.vec,mean.vec=NULL,variance.vec=NULL, 
skewness.vec=NULL,kurtosis.vec=NULL,final.corr.mat=amat,coef.mat=NULL)

apply(multibin,2,mean)

bmat=final.corr.mat[3:6,3:6]
multinonnor=gen.Bin.NonNor(n=100,n.BB=0,n.NN,prop.vec=NULL,mean.vec,variance.vec, 
skewness.vec,kurtosis.vec,final.corr.mat=bmat,coef.mat)
apply(multinonnor,2,mean)
apply(multinonnor,2,var)


n=1000
n.BB=1
n.NN=1
prop.vec=0.6
mean.vec=1
variance.vec=1
skewness.vec=2
kurtosis.vec=6
corr.vec=NULL
corr.mat=matrix(c(1,-0.3,-0.3,1),2,2)
coef.mat=matrix(c(-0.31375,0.82632,0.31375,0.02271),4,1)
final.corr.mat=overall.corr.mat(n.BB,n.NN,prop.vec,corr.vec=NULL,corr.mat,coef.mat)
data=gen.Bin.NonNor(n,n.BB,n.NN,prop.vec,mean.vec,variance.vec,skewness.vec,
kurtosis.vec,final.corr.mat,coef.mat)


n=1000
n.BB=1
n.NN=0
prop.vec=0.6
mean.vec=1
variance.vec=NULL
skewness.vec=NULL
kurtosis.vec=NULL
corr.vec=NULL
corr.mat=diag(1)
coef.mat=NULL

final.corr.mat=overall.corr.mat(n.BB,n.NN,prop.vec,corr.vec=NULL,corr.mat,coef.mat)

data=gen.Bin.NonNor(n,n.BB,n.NN,prop.vec,mean.vec,variance.vec,skewness.vec, 
kurtosis.vec,final.corr.mat,coef.mat)

## End(Not run)
</code></pre>

<hr>
<h2 id='Int.Corr.NN'>Computes an intermediate correlation matrix for continuous non-normal variables given the specified correlation 
matrix</h2><span id='topic+Int.Corr.NN'></span>

<h3>Description</h3>

<p>This function computes the intermediate correlation matrix for continuous non-normal-continuous non-normal combinations as formulated in Demirtas et al.
(2012).</p>


<h3>Usage</h3>

<pre><code class='language-R'>Int.Corr.NN(n.NN, corr.vec = NULL, corr.mat = NULL, coef.mat)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Int.Corr.NN_+3A_n.nn">n.NN</code></td>
<td>
<p>Number of continuous non-normal variables.</p>
</td></tr>
<tr><td><code id="Int.Corr.NN_+3A_corr.vec">corr.vec</code></td>
<td>
<p>Vector of elements below the diagonal of correlation matrix ordered columnwise.</p>
</td></tr>
<tr><td><code id="Int.Corr.NN_+3A_corr.mat">corr.mat</code></td>
<td>
<p>Specified correlation matrix.</p>
</td></tr>
<tr><td><code id="Int.Corr.NN_+3A_coef.mat">coef.mat</code></td>
<td>
<p>Matrix of coefficients produced from <code><a href="#topic+fleishman.coef">fleishman.coef</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A correlation matrix of size n.NN*n.NN.</p>


<h3>References</h3>

<p>Demirtas, H., Hedeker, D., and Mermelstein, R.J. (2012). Simulation of massive public health data by power polynomials. 
Statistics in Medicine, 31(27), 3337-3346.</p>


<h3>See Also</h3>

<p><code><a href="#topic+fleishman.coef">fleishman.coef</a></code>, <code><a href="#topic+Tetra.Corr.BB">Tetra.Corr.BB</a></code>, <code><a href="#topic+Biserial.Corr.BN">Biserial.Corr.BN</a></code>, <code><a href="#topic+overall.corr.mat">overall.corr.mat</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>n.NN=4
corr.vec=NULL
corr.mat=matrix(c(1.0,-0.3,-0.3,-0.3,-0.3,-0.3,
-0.3,1.0,-0.3,-0.3,-0.3,-0.3,
-0.3,-0.3,1.0,0.4,0.5,0.6,
-0.3,-0.3,0.4,1.0,0.7,0.8,
-0.3,-0.3,0.5,0.7,1.0,0.9,
-0.3,-0.3,0.6,0.8,0.9,1.0),6,byrow=TRUE)

coef.mat=matrix(c(
 -0.31375,  0.00000,  0.10045, -0.10448,
  0.82632,  1.08574,  1.10502,  0.98085,
  0.31375,  0.00000, -0.10045,  0.10448,
  0.02271, -0.02945, -0.04001,  0.00272),4,byrow=TRUE)

intcor.mat=Int.Corr.NN(n.NN,corr.vec=NULL,corr.mat,coef.mat) 
</code></pre>

<hr>
<h2 id='overall.corr.mat'>Computes the final correlation matrix</h2><span id='topic+overall.corr.mat'></span>

<h3>Description</h3>

<p>This function computes the final correlation matrix by combining tetrachoric correlation for binary-binary combinations, 
biserial correlations for binary-continuous combinations, and intermediate correlation matrix for continuous-continuous combinations.</p>


<h3>Usage</h3>

<pre><code class='language-R'>overall.corr.mat(n.BB, n.NN, prop.vec = NULL, corr.vec = NULL, corr.mat = NULL, 
coef.mat = NULL)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="overall.corr.mat_+3A_n.bb">n.BB</code></td>
<td>
<p>Number of binary variables.</p>
</td></tr>
<tr><td><code id="overall.corr.mat_+3A_n.nn">n.NN</code></td>
<td>
<p>Number of continuous non-normal variables.</p>
</td></tr>
<tr><td><code id="overall.corr.mat_+3A_prop.vec">prop.vec</code></td>
<td>
<p>Probability vector for binary variables.</p>
</td></tr>
<tr><td><code id="overall.corr.mat_+3A_corr.vec">corr.vec</code></td>
<td>
<p>Vector of elements below the diagonal of correlation matrix ordered columnwise.</p>
</td></tr>
<tr><td><code id="overall.corr.mat_+3A_corr.mat">corr.mat</code></td>
<td>
<p>Specified correlation matrix.</p>
</td></tr>
<tr><td><code id="overall.corr.mat_+3A_coef.mat">coef.mat</code></td>
<td>
<p>Matrix of coefficients produced from <code><a href="#topic+fleishman.coef">fleishman.coef</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of size (n.BB+n.NN)*(n.BB+n.NN).</p>


<h3>References</h3>

<p>Demirtas, H., Hedeker, D., and Mermelstein, R.J. (2012). Simulation of massive public health data by power polynomials. 
Statistics in Medicine, 31(27), 3337-3346.</p>


<h3>See Also</h3>

<p><code><a href="#topic+fleishman.coef">fleishman.coef</a></code>, <code><a href="#topic+Tetra.Corr.BB">Tetra.Corr.BB</a></code>, <code><a href="#topic+Int.Corr.NN">Int.Corr.NN</a></code>, <code><a href="#topic+Biserial.Corr.BN">Biserial.Corr.BN</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>n.BB=2
n.NN=4
prop.vec=c(0.4,0.7)
corr.vec=NULL
corr.mat=matrix(c(1.0,-0.3,-0.3,-0.3,-0.3,-0.3,
-0.3,1.0,-0.3,-0.3,-0.3,-0.3,
-0.3,-0.3,1.0,0.4,0.5,0.6,
-0.3,-0.3,0.4,1.0,0.7,0.8,
-0.3,-0.3,0.5,0.7,1.0,0.9,
-0.3,-0.3,0.6,0.8,0.9,1.0),6,byrow=TRUE)

coef.mat=matrix(c(
 -0.31375,  0.00000,  0.10045, -0.10448,
  0.82632,  1.08574,  1.10502,  0.98085,
  0.31375,  0.00000, -0.10045,  0.10448,
  0.02271, -0.02945, -0.04001,  0.00272),4,byrow=TRUE)

final.corr.mat=overall.corr.mat(n.BB,n.NN,prop.vec,corr.vec=NULL,corr.mat,
coef.mat)

corr.mat.BB=corr.mat[1:2,1:2]
final.corr.mat=overall.corr.mat(n.BB,n.NN=0,prop.vec,corr.vec=NULL,
corr.mat=corr.mat.BB,coef.mat=NULL)

corr.mat.NN=corr.mat[3:6,3:6]
final.corr.mat=overall.corr.mat(n.BB=0,n.NN,prop.vec=NULL,corr.vec=NULL, 
corr.mat=corr.mat.NN,coef.mat)


n.BB=1
n.NN=1
prop.vec=0.6
corr.vec=NULL
corr.mat=matrix(c(1,-0.3,-0.3,1),2,2)
coef.mat=matrix(c(-0.31375,0.82632,0.31375,0.02271),4,1)
final.corr.mat=overall.corr.mat(n.BB,n.NN,prop.vec,corr.vec=NULL,corr.mat,
coef.mat)
</code></pre>

<hr>
<h2 id='Tetra.Corr.BB'>Computes the tetrachoric correlation matrix for binary variables given the specified correlation matrix</h2><span id='topic+Tetra.Corr.BB'></span>

<h3>Description</h3>

<p>This function computes the tetrachoric correlation matrix for binary-binary combinations as formulated in Demirtas et al.
(2012).</p>


<h3>Usage</h3>

<pre><code class='language-R'>Tetra.Corr.BB(n.BB, prop.vec, corr.vec = NULL, corr.mat = NULL)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Tetra.Corr.BB_+3A_n.bb">n.BB</code></td>
<td>
<p>Number of binary variables.</p>
</td></tr>
<tr><td><code id="Tetra.Corr.BB_+3A_prop.vec">prop.vec</code></td>
<td>
<p>Probability vector for binary variables.</p>
</td></tr>
<tr><td><code id="Tetra.Corr.BB_+3A_corr.vec">corr.vec</code></td>
<td>
<p>Vector of elements below the diagonal of correlation matrix ordered columnwise.</p>
</td></tr>
<tr><td><code id="Tetra.Corr.BB_+3A_corr.mat">corr.mat</code></td>
<td>
<p>Specified correlation matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A correlation matrix of size n.BB*n.BB.</p>


<h3>References</h3>

<p>Demirtas, H., Hedeker, D., and Mermelstein, R.J. (2012). Simulation of massive public health data by power polynomials. 
Statistics in Medicine, 31(27), 3337-3346.</p>


<h3>See Also</h3>

<p><code><a href="#topic+Tetra.Corr.BB">Tetra.Corr.BB</a></code>, <code><a href="#topic+Biserial.Corr.BN">Biserial.Corr.BN</a></code>, <code><a href="#topic+overall.corr.mat">overall.corr.mat</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>n.BB=2
prop.vec=c(0.4,0.7)
corr.vec=NULL
corr.mat=matrix(c(1.0,-0.3,-0.3,-0.3,-0.3,-0.3,
-0.3,1.0,-0.3,-0.3,-0.3,-0.3,
-0.3,-0.3,1.0,0.4,0.5,0.6,
-0.3,-0.3,0.4,1.0,0.7,0.8,
-0.3,-0.3,0.5,0.7,1.0,0.9,
-0.3,-0.3,0.6,0.8,0.9,1.0),6,by=TRUE)

tetcor.mat=Tetra.Corr.BB(n.BB,prop.vec,corr.vec=NULL,corr.mat)
</code></pre>

<hr>
<h2 id='validation.bin'>Validates the marginal specification of the binary variables</h2><span id='topic+validation.bin'></span>

<h3>Description</h3>

<p>Checks whether the marginal specification of the binary part is valid and consistent.</p>


<h3>Usage</h3>

<pre><code class='language-R'>validation.bin(n.BB, prop.vec = NULL)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validation.bin_+3A_n.bb">n.BB</code></td>
<td>
<p>Number of binary variables.</p>
</td></tr>
<tr><td><code id="validation.bin_+3A_prop.vec">prop.vec</code></td>
<td>
<p>Probability vector for binary variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns TRUE if no specification problem is encountered. Otherwise, it returns an error message.</p>


<h3>Examples</h3>

<pre><code class='language-R'>n.B&lt;-2
prop.vec=c(0.5,0.6)
validation.bin(n.B,prop.vec)

## Not run: 
n.B&lt;-3
prop.vec=c(0.5,0.6)
validation.bin(n.B,prop.vec)

n.B&lt;-3
prop.vec=c(0.5,0.6)
validation.bin(n.B)

n.B&lt;-0
prop.vec=c(0.5,0.6)
validation.bin(n.B,prop.vec)

n.B&lt;-3
prop.vec=c(0.5,0.6)
validation.bin(n.B,prop.vec)

n.B&lt;-3
prop.vec=NULL
validation.bin(n.B,prop.vec)

n.B&lt;-3
prop.vec=c(1,1.5,-1.5)
validation.bin(n.B,prop.vec)

## End(Not run)
</code></pre>

<hr>
<h2 id='validation.corr'>Validates the specified correlation matrix</h2><span id='topic+validation.corr'></span>

<h3>Description</h3>

<p>This function validates the specified correlation vector and/or matrix for appropriate dimension, symmetry,
range, and positive definiteness. If both correlation matrix and correlation vector are supplied, it
checks whether the matrix and vector are conformable.</p>


<h3>Usage</h3>

<pre><code class='language-R'>validation.corr(n.BB, n.NN, corr.vec = NULL, corr.mat = NULL)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validation.corr_+3A_n.bb">n.BB</code></td>
<td>
<p>Number of binary variables.</p>
</td></tr>
<tr><td><code id="validation.corr_+3A_n.nn">n.NN</code></td>
<td>
<p>Number of continuous non-normal variables.</p>
</td></tr>
<tr><td><code id="validation.corr_+3A_corr.vec">corr.vec</code></td>
<td>
<p>Vector of elements below the diagonal of correlation matrix ordered columnwise.</p>
</td></tr>
<tr><td><code id="validation.corr_+3A_corr.mat">corr.mat</code></td>
<td>
<p>Specified correlation matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns TRUE if no specification problem is encountered. Otherwise, it returns an error message.</p>


<h3>See Also</h3>

<p><code><a href="#topic+correlation.limits">correlation.limits</a></code>, <code><a href="#topic+correlation.bound.check">correlation.bound.check</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>n.BB=2
n.NN=4
corr.vec=NULL
corr.mat=matrix(c(1.0,-0.3,-0.3,-0.3,-0.3,-0.3,
-0.3,1.0,-0.3,-0.3,-0.3,-0.3,
-0.3,-0.3,1.0,0.4,0.5,0.6,
-0.3,-0.3,0.4,1.0,0.7,0.8,
-0.3,-0.3,0.5,0.7,1.0,0.9,
-0.3,-0.3,0.6,0.8,0.9,1.0),6,byrow=TRUE)

validation.corr(n.BB,n.NN,corr.vec=NULL,corr.mat)

n.BB=2
n.NN=4
corr.vec=c(-0.3,-0.3,-0.3,-0.3,-0.3,-0.3,-0.3,-0.3,-0.3,0.4,0.5,0.6,0.7,0.8,0.9)
validation.corr(n.BB,n.NN,corr.vec,corr.mat=NULL)

## Not run: 
n.BB=0
n.NN=4
validation.corr(n.BB,n.NN,corr.vec=NULL,corr.mat)

n.BB=2
n.NN=0
validation.corr(n.BB,n.NN=0,corr.vec=NULL,corr.mat)

corr.matc=corr.mat[3:6,3:6]
validation.corr(n.BB=0,n.NN=4,corr.vec=NULL,corr.mat=corr.matc)

corr.mat[2,1]=0.5
validation.corr(n.BB,n.NN,corr.vec=NULL,corr.mat)

corr.mat[1,2]=0.5
corr.mat[3,1]=1.5
corr.mat[1,3]=1.5
validation.corr(n.BB,n.NN,corr.vec=NULL,corr.mat)

npd&lt;-matrix(c(1,     0.477, 0.644, 0.478, 0.651, 0.826,
               0.477, 1,     0.516, 0.233, 0.682, 0.75,
               0.644, 0.516, 1,     0.599, 0.581, 0.742,
               0.478, 0.233, 0.599, 1,     0.741, 0.8,
               0.651, 0.682, 0.581, 0.741, 1,     0.798,
               0.826, 0.75,  0.742, 0.8,   0.798, 1),
               nrow = 6, ncol = 6)

validation.corr(n.BB,n.NN,corr.vec=NULL,corr.mat=npd)

n.BB=1
n.NN=0
corr.mat&lt;-diag(1)
validation.corr(n.BB,n.NN,corr.vec=NULL,corr.mat)


## End(Not run)
</code></pre>

<hr>
<h2 id='validation.skewness.kurtosis'>Validates the marginal specification of the continuous non-normal variables</h2><span id='topic+validation.skewness.kurtosis'></span>

<h3>Description</h3>

<p>Checks whether the marginal specification of the continuous non-normal part is valid and consistent.</p>


<h3>Usage</h3>

<pre><code class='language-R'>validation.skewness.kurtosis(n.NN, skewness.vec = NULL, kurtosis.vec = NULL)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validation.skewness.kurtosis_+3A_n.nn">n.NN</code></td>
<td>
<p>Number of continuous non-normal variables.</p>
</td></tr>
<tr><td><code id="validation.skewness.kurtosis_+3A_skewness.vec">skewness.vec</code></td>
<td>
<p>Skewness vector for continuous non-normal variables.</p>
</td></tr>
<tr><td><code id="validation.skewness.kurtosis_+3A_kurtosis.vec">kurtosis.vec</code></td>
<td>
<p>Kurtosis vector for continuous non-normal variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns TRUE if no specification problem is encountered. Otherwise, it returns an error message.</p>


<h3>References</h3>

<p>Demirtas, H., Hedeker, D., and Mermelstein, R.J. (2012). Simulation of massive public health data by power polynomials. 
Statistics in Medicine, 31(27), 3337-3346.</p>


<h3>Examples</h3>

<pre><code class='language-R'>n.NN&lt;-3
skewness.vec=c(0,2,3)
kurtosis.vec=c(-1.2,6,8)
validation.skewness.kurtosis(n.NN,skewness.vec,kurtosis.vec)

## Not run: 
n.NN&lt;--1
skewness.vec=c(0)
kurtosis.vec=c(-1.2)
validation.skewness.kurtosis(n.NN,skewness.vec,kurtosis.vec)

n.NN&lt;-3
skewness.vec=c(0,2,3)
kurtosis.vec=c(-1.2,6,5)
validation.skewness.kurtosis(3)

n.NN&lt;-3
skewness.vec=c(0,2,3)
kurtosis.vec=c(-1.2,6,5)
validation.skewness.kurtosis(n.NN,skewness.vec)
validation.skewness.kurtosis(n.NN,kurtosis.vec)

n.NN&lt;-0
skewness.vec=c(0,2,3)
kurtosis.vec=c(-1.2,6,8)
validation.skewness.kurtosis(n.NN,skewness.vec,kurtosis.vec)

n.NN&lt;-2
skewness.vec=c(0,2,3)
kurtosis.vec=c(-1.2,6,8)
validation.skewness.kurtosis(n.NN,skewness.vec,kurtosis.vec)

n.NN&lt;-2
skewness.vec=c(0,2,3)
kurtosis.vec=c(-1.2,6)
validation.skewness.kurtosis(n.NN,skewness.vec,kurtosis.vec)

skewness.vec=c(2,3)
kurtosis.vec=c(1,5)
validation.skewness.kurtosis(n.NN,skewness.vec,kurtosis.vec)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
