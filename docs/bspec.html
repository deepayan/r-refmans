<!DOCTYPE html><html lang="en"><head><title>Help for package bspec</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bspec}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bspec-package'>
<p>Bayesian Spectral Inference</p></a></li>
<li><a href='#acf.bspec'><p>Posterior autocovariances</p></a></li>
<li><a href='#bspec'><p>Computing the spectrum's posterior distribution</p></a></li>
<li><a href='#empiricalSpectrum'><p>Compute the &quot;empirical&quot; spectrum of a time series.</p></a></li>
<li><a href='#expectation'><p>Expectations and variances of distributions</p></a></li>
<li><a href='#likelihood'><p>Prior, likelihood and posterior</p></a></li>
<li><a href='#matchedfilter'><p>Filter a noisy time series for a signal of given shape</p></a></li>
<li><a href='#one.sided'><p>Conversion between one- and two-sided spectra</p></a></li>
<li><a href='#ppsample'><p>Posterior predictive sampling</p></a></li>
<li><a href='#quantile.bspec'><p>Quantiles of the posterior spectrum</p></a></li>
<li><a href='#sample.bspec'><p>Posterior sampling</p></a></li>
<li><a href='#snr'><p>Compute the signal-to-noise ratio (SNR) of a signal</p></a></li>
<li><a href='#temper'><p>Tempering of (posterior) distributions</p></a></li>
<li><a href='#temperature'><p>Querying the tempering parameter</p></a></li>
<li><a href='#tukeywindow'><p>Compute windowing functions for spectral time series analysis.</p></a></li>
<li><a href='#welchPSD'><p>Power spectral density estimation using Welch's method.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Spectral Inference</td>
</tr>
<tr>
<td>Version:</td>
<td>1.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-04-20</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Christian Roever &lt;christian.roever@med.uni-goettingen.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Bayesian inference on the (discrete) power spectrum of time series.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-04-20 13:35:01 UTC; christian</td>
</tr>
<tr>
<td>Author:</td>
<td>Christian Roever <a href="https://orcid.org/0000-0002-6911-698X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-04-20 14:42:30 UTC</td>
</tr>
</table>
<hr>
<h2 id='bspec-package'>
Bayesian Spectral Inference
</h2><span id='topic+bspec-package'></span>

<h3>Description</h3>

<p>This package functions to derive posterior distributions of spectral
parameters of a time series.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
    Package: </td><td style="text-align: left;"> bspec</td>
</tr>
<tr>
 <td style="text-align: left;">
    Type:    </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
    Version: </td><td style="text-align: left;"> 1.6</td>
</tr>
<tr>
 <td style="text-align: left;">
    Date:    </td><td style="text-align: left;"> 2022-04-20</td>
</tr>
<tr>
 <td style="text-align: left;">
    License: </td><td style="text-align: left;"> GPL (&gt;=2)
  </td>
</tr>

</table>

<p>The main functionality is provided by the <code><a href="#topic+bspec">bspec</a>()</code>
function. .
</p>


<h3>Author(s)</h3>

<p>Christian Roever &lt;christian.roever@med.uni-goettingen.de&gt;
</p>


<h3>References</h3>

<p>Roever, C., Meyer, R., Christensen, N.
Modelling coloured residual noise in gravitational-wave signal processing.
<em>Classical and Quantum Gravity</em>, <b>28</b>(1):015010, 2011.
doi: <a href="https://doi.org/10.1088/0264-9381/28/1/015010">10.1088/0264-9381/28/1/015010</a>.
See also <a href="https://arxiv.org/abs/0804.3853">arXiv preprint 0804.3853</a>.</p>

<hr>
<h2 id='acf.bspec'>Posterior autocovariances</h2><span id='topic+acf.bspec'></span><span id='topic+acf.default'></span><span id='topic+acf'></span><span id='topic+plot.bspecACF'></span><span id='topic+print.bspecACF'></span><span id='topic+is.bspecACF'></span>

<h3>Description</h3>

<p>Deriving (posterior) autocovariances or autocorrelations
from the spectrum's posterior distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bspec'
acf(x, spec = NULL,
   type = c("covariance", "correlation"),
   two.sided = x$two.sided, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="acf.bspec_+3A_x">x</code></td>
<td>
<p>a <code>bspec</code> object.</p>
</td></tr>
<tr><td><code id="acf.bspec_+3A_spec">spec</code></td>
<td>
<p>(optional) a <code>numeric</code> vector giving <em>fixed</em>
values of the spectral parameters (e.g. derived by the
<code><a href="#topic+sample.bspec">sample</a></code> function) for which the
autocovariances then are deterministic.</p>
</td></tr>
<tr><td><code id="acf.bspec_+3A_type">type</code></td>
<td>
<p>a <code>character</code> string specifying the desired type of
output.</p>
</td></tr>
<tr><td><code id="acf.bspec_+3A_two.sided">two.sided</code></td>
<td>
<p>a <code>logical</code> flag indicating whether the
<code>spec</code> values are to be interpreted as <em>one-sided</em> or
<em>two-sided</em>.</p>
</td></tr>
<tr><td><code id="acf.bspec_+3A_...">...</code></td>
<td>
<p>currently unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>spec</code> is supplied, the autocovariance (or autocorrelation)
function corresponding to that specific spectrum will be returned.
As this is a completely deterministic relationship, the
&ldquo;<code>stderr</code>&rdquo; slot of the result will be zero in this case.
</p>
<p>If <code>spec</code> is <em>not</em> supplied, the <em>(posterior) expected
autocovariance</em> is returned in the &ldquo;<code>acf</code>&rdquo; element, and its
<em>(posterior) standard deviation</em> is returned in the
&ldquo;<code>stderr</code>&rdquo; element.
The posterior expectation of the autocovariance is only finite if
<em>all (!)</em> posterior degrees-of-freedom parameters in the
<code>bspec</code> object are <code class="reqn">&gt;2</code>. The posterior
variance (and with that the <code>stderr</code> element) is only finite if all
these are <code class="reqn">&gt;4</code>.
</p>
<p>Autocorrelations are only returned if <code>spec</code> is supplied.
</p>


<h3>Value</h3>

<p>A list of class <code>bspecACF</code> containing the following components:
</p>
<table role = "presentation">
<tr><td><code>lag</code></td>
<td>
<p>a <code>numeric</code> vector giving the lags
corresponding to the (discrete) autocovariance / autocorrelation
values.</p>
</td></tr>
<tr><td><code>acf</code></td>
<td>
<p>a <code>numeric</code> vector giving the values of the
autocovariance / autocorrelation function correponding to the
above lags.</p>
</td></tr>
<tr><td><code>stderr</code></td>
<td>
<p>a <code>numeric</code> vector giving the standard
errors (posterior standard deviations) of the above autocovariance
values.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>a <code>character</code> string giving the
nature of the above <code>acf</code> element: either <code>"covariance"</code>
or <code>"correlation"</code>.</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>an <code>integer</code> giving the sample
size of the original time series.</p>
</td></tr>
<tr><td><code>bspec</code></td>
<td>
<p>a <code>character</code> string giving the
name of the <code>bspec</code> object the <code>bspecACF</code> object was
generated from.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>(Posterior) expectation and standard deviation of the spectrum may in
many cases not be finite (see above).
Autocorrelations are only returned if <code>spec</code> is supplied.
</p>


<h3>Author(s)</h3>

<p>Christian Roever, <a href="mailto:christian.roever@med.uni-goettingen.de">christian.roever@med.uni-goettingen.de</a></p>


<h3>References</h3>

<p>Roever, C., Meyer, R., Christensen, N.
Modelling coloured residual noise in gravitational-wave signal processing.
<em>Classical and Quantum Gravity</em>, <b>28</b>(1):015010, 2011.
doi: <a href="https://doi.org/10.1088/0264-9381/28/1/015010">10.1088/0264-9381/28/1/015010</a>.
See also <a href="https://arxiv.org/abs/0804.3853">arXiv preprint 0804.3853</a>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+bspec.default">bspec</a></code>,
<code><a href="#topic+expectation.bspecACF">expectation</a></code>,
<code><a href="#topic+sample.bspec">sample.bspec</a></code>,
<code><a href="stats.html#topic+acf">acf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lhspec1 &lt;- bspec(lh)

# without any prior specifications,
# autocovariances are not finite:
print(acf(lhspec1))
str(acf(lhspec1))

# for given values of the spectral parameters,
# the autocovariances are fixed:
str(acf(lhspec1, spec=sample(lhspec1)))

# for all the prior degrees-of-freedom greater than one,
# the expected autocovariance is finite, its variance isn't:
lhspec2 &lt;- bspec(lh, priordf=2, priorscale=0.6, intercept=FALSE)
print(acf(lhspec2))
str(acf(lhspec2))
plot(acf(lhspec2))
</code></pre>

<hr>
<h2 id='bspec'>Computing the spectrum's posterior distribution</h2><span id='topic+bspec'></span><span id='topic+bspec.default'></span><span id='topic+print.bspec'></span><span id='topic+plot.bspec'></span><span id='topic+is.bspec'></span>

<h3>Description</h3>

<p>Derives the posterior distribution of the spectrum
of one or several time series,
based on data and prior specifications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  bspec(x, ...)
  ## Default S3 method:
bspec(x, priorscale=1, priordf=0, intercept=TRUE,
    two.sided=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bspec_+3A_x">x</code></td>
<td>
<p>a time series object of the data to be analysed.
May be a univariate (<code><a href="stats.html#topic+ts">ts</a></code> object) or multivariate
(<code><a href="stats.html#topic+ts">mts</a></code> object) time series.</p>
</td></tr>
<tr><td><code id="bspec_+3A_priorscale">priorscale</code></td>
<td>
<p><em>either</em> a <code>numeric</code> vector giving the
scale parameters of the spectrum's prior distribution; recycled if
of length 1.
</p>
<p><em>Or</em> a <code>function</code> of frequency.</p>
</td></tr>
<tr><td><code id="bspec_+3A_priordf">priordf</code></td>
<td>
<p><em>either</em> a <code>numeric</code> vector giving the
degrees-of-freedom parameters of the spectrum's prior distribution;
recycled if of length 1.
</p>
<p><em>Or</em> a <code>function</code> of frequency.</p>
</td></tr>
<tr><td><code id="bspec_+3A_intercept">intercept</code></td>
<td>
<p>a <code>logical</code> flag indicating whether to include
the &lsquo;intercept&rsquo; (zero frequency) term.</p>
</td></tr>
<tr><td><code id="bspec_+3A_two.sided">two.sided</code></td>
<td>
<p>a <code>logical</code> flag indicating whether to refer to
a one-sided or a two-sided spectrum. In particular affects the
interpretation of the prior scale parameters, and sets the default
for some methods applied to the resulting <code>bspec</code> object via
its <code>two.sided</code> element.</p>
</td></tr>
<tr><td><code id="bspec_+3A_...">...</code></td>
<td>
<p>currently unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Based on the assumptions of a zero mean and a finite spectrum,
the posterior distribution of the (discrete) spectrum is derived.
The data are modeled using the <em>Maximum Entropy</em> (Normal)
distribution for the above constraints, and based on the
prior information about the spectrum specified in terms of the
(conjugate) <em>scaled inverse <code class="reqn">\chi^2</code> distribution</em>.
</p>
<p>For more details, see the references.
</p>


<h3>Value</h3>

<p>A list of class <code>bspec</code> containing the following elements:
</p>
<table role = "presentation">
<tr><td><code>freq</code></td>
<td>
<p>a <code>numeric</code> vector giving the
(Fourier-) frequencies that the spectral parameters
correspond to.</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>a <code>numeric</code> vector giving the scale
parameters of the posterior distributions of the spectral
parameters corresponding to the above frequencies.
These -internally- always correspond to the <em>one-sided</em>
spectrum, regardless of the <code>two.sided</code> flag (see below).</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>a <code>numeric</code> vector giving the
degrees-of-freedom parameters of the posterior distributions of
the spectral parameters corresponding to the above frequencies.</p>
</td></tr>
<tr><td><code>priorscale</code></td>
<td>
<p>a <code>numeric</code> vector giving the
prior scale parameters.</p>
</td></tr>
<tr><td><code>priordf</code></td>
<td>
<p>a <code>numeric</code> vector giving the
prior degrees-of-freedom parameters.</p>
</td></tr>
<tr><td><code>datassq</code></td>
<td>
<p>a <code>numeric</code> vector giving the
sum-of-squares contributed by the data.</p>
</td></tr>
<tr><td><code>datadf</code></td>
<td>
<p>a <code>numeric</code> vector giving the
degrees-of-freedom contributed by the data.</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>the sample size of the original time series.</p>
</td></tr>
<tr><td><code>deltat</code></td>
<td>
<p>the sampling interval of the original time series.</p>
</td></tr>
<tr><td><code>deltaf</code></td>
<td>
<p>the frequency interval of the Fourier-transformed time series.</p>
</td></tr>
<tr><td><code>start</code></td>
<td>
<p>the time of the first observation in the original time series.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>an object of class <code>call</code> giving the
function call that generated the <code>bspec</code> object.</p>
</td></tr>
<tr><td><code>two.sided</code></td>
<td>
<p>a <code>logical</code> flag indicating
whether the spectrum is to be interpreted as one-sided or two-sided.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christian Roever, <a href="mailto:christian.roever@med.uni-goettingen.de">christian.roever@med.uni-goettingen.de</a></p>


<h3>References</h3>

<p>Roever, C., Meyer, R., Christensen, N.
Modelling coloured residual noise in gravitational-wave signal processing.
<em>Classical and Quantum Gravity</em>, <b>28</b>(1):015010, 2011.
doi: <a href="https://doi.org/10.1088/0264-9381/28/1/015010">10.1088/0264-9381/28/1/015010</a>.
See also <a href="https://arxiv.org/abs/0804.3853">arXiv preprint 0804.3853</a>.
</p>
<p>Roever, C.
<a href="https://dcc.ligo.org/LIGO-T1100497/public">Degrees-of-freedom
estimation in the Student-t noise model</a>.
Technical Report LIGO-T1100497, LIGO-Virgo Collaboration, 2011.
</p>
<p>Roever, C.
A Student-t based filter for robust signal detection.
<em>Physical Review D</em>, <b>84</b>(12):122004, 2011.
doi: <a href="https://doi.org/10.1103/PhysRevD.84.122004">10.1103/PhysRevD.84.122004</a>.
See also <a href="https://arxiv.org/abs/1109.0442">arXiv preprint 1109.0442</a>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+expectation.bspec">expectation</a></code>,
<code><a href="#topic+quantile.bspec">quantile.bspec</a></code>,
<code><a href="#topic+sample.bspec">sample.bspec</a></code>,
<code><a href="#topic+ppsample.bspec">ppsample</a></code>,
<code><a href="#topic+acf.bspec">acf.bspec</a></code>,
<code><a href="stats.html#topic+spectrum">spectrum</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># determine spectrum's posterior distribution
# (for noninformative prior):
lhspec &lt;- bspec(lh)
print(lhspec)

# show some more details:
str(lhspec)

# plot 95 percent central intervals and medians:
plot(lhspec)

# draw and plot a sample from posterior distribution:
lines(lhspec$freq, sample(lhspec), type="b", pch=20)

########

# compare the default outputs of "bspec()" and "spectrum()":
bspec1    &lt;- bspec(lh)
spectrum1 &lt;- spectrum(lh, plot=FALSE)
plot(bspec1) 
lines(spectrum1$freq, spectrum1$spec, col="blue")
# (note -among others- the factor 2 difference)

# match the outputs:
# Need to suppress  tapering, padding and de-trending
# (see help for "spec.pgram()"):
spectrum2 &lt;- spectrum(lh, taper=0, fast=FALSE, detrend=FALSE, plot=FALSE)
# Need to drop intercept (zero frequency) term:
bspec2    &lt;- bspec(lh, intercept=FALSE)
# plot the "spectrum()" output:
plot(spectrum2)
# draw the "bspec()" scale parameters, adjusted
# by the corresponding degrees-of-freedom,
# so they correspond to one-sided spectrum:
lines(bspec2$freq, bspec2$scale/bspec2$datadf,
      type="b", col="green", lty="dashed")

########

# handle several time series at once...
data(sunspots)
# extract three 70-year segments:
spots1 &lt;- window(sunspots, 1750, 1819.99)
spots2 &lt;- window(sunspots, 1830, 1899.99)
spots3 &lt;- window(sunspots, 1910, 1979.99)
# align their time scales:
tsp(spots3) &lt;- tsp(spots2) &lt;- tsp(spots1)
# combine to multivariate time series:
spots &lt;- ts.union(spots1, spots2, spots3)
# infer spectrum:
plot(bspec(spots))
</code></pre>

<hr>
<h2 id='empiricalSpectrum'>Compute the &quot;empirical&quot; spectrum of a time series.</h2><span id='topic+empiricalSpectrum'></span>

<h3>Description</h3>

<p>Computes the &quot;empirical power&quot; of a time series via a discrete Fourier
transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>empiricalSpectrum(x, two.sided=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="empiricalSpectrum_+3A_x">x</code></td>
<td>
<p>a time series (<code><a href="stats.html#topic+ts">ts</a></code> object).</p>
</td></tr>
<tr><td><code id="empiricalSpectrum_+3A_two.sided">two.sided</code></td>
<td>
<p>a <code>logical</code> flag indicating whether the output
is supposed to correspond to the <em>one-sided</em> (default) or
<em>two-sided</em> spectrum.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Performs a Fourier transform, and then derives (based on the
additional information on sampling rate etc. provided via the time
series' attributes) the spectral power as a function of frequency.
The result is simpler (in a way) than the <code><a href="stats.html#topic+spectrum">spectrum</a>()</code>
function's output, see also the example below. What is returned is the
real-valued frequency series
</p>
<p style="text-align: center;"><code class="reqn">\kappa_j\frac{\Delta_t}{N}\bigl|\tilde{x}(f_j)\bigr|^2</code>
</p>

<p>where <code class="reqn">j=0,...,N/2+1</code>,
and <code class="reqn">f_j=\frac{j}{N \Delta_t}</code> are the
Fourier frequencies. <code class="reqn">\Delta_t</code> is the time series'
sampling interval and <code class="reqn">N</code> is its
length. <code class="reqn">\kappa_j</code> is =1 for zero and Nyquist
frequencies, and =2 otherwise, and denotes the number of (by
definition) non-zero Fourier coefficients. In case
<code>two.sided=TRUE</code>, the <code class="reqn">\kappa_j</code> prefactor is
omitted.
</p>
<p>For actual spectral estimation purposes, the use of a windowing
function (see e.g. the <code><a href="#topic+tukeywindow">tukeywindow</a>()</code> function) is highly
recommended.
</p>


<h3>Value</h3>

<p>A list containing the following elements:
</p>
<table role = "presentation">
<tr><td><code>frequency</code></td>
<td>
<p>the Fourier frequencies.</p>
</td></tr>
<tr><td><code>power</code></td>
<td>
<p>the spectral power.</p>
</td></tr>
<tr><td><code>kappa</code></td>
<td>
<p>the number of (by definition) non-zero imaginary
components of the Fourier series.</p>
</td></tr>
<tr><td><code>two.sided</code></td>
<td>
<p>a <code>logical</code> flag indicating one- or
two-sidedness.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christian Roever, <a href="mailto:christian.roever@med.uni-goettingen.de">christian.roever@med.uni-goettingen.de</a></p>


<h3>References</h3>

<p>Roever, C., Meyer, R., Christensen, N.
Modelling coloured residual noise in gravitational-wave signal processing.
<em>Classical and Quantum Gravity</em>, <b>28</b>(1):015010, 2011.
doi: <a href="https://doi.org/10.1088/0264-9381/28/1/015010">10.1088/0264-9381/28/1/015010</a>.
See also <a href="https://arxiv.org/abs/0804.3853">arXiv preprint 0804.3853</a>.</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+fft">fft</a></code>,
<code><a href="stats.html#topic+spectrum">spectrum</a></code>,
<code><a href="#topic+tukeywindow">tukeywindow</a></code>,
<code><a href="#topic+welchPSD">welchPSD</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load example data:
data(lh)

# compute spectrum:
spec1 &lt;- empiricalSpectrum(lh)
plot(spec1$frequency, spec1$power, log="y", type="b")

# plot "spectrum()" function's result in comparison:
spec2 &lt;- spectrum(lh, plot=FALSE)
lines(spec2$freq, spec2$spec, col="red")

# make both spectra match:
spec3 &lt;- empiricalSpectrum(lh, two.sided=TRUE)
spec4 &lt;- spectrum(lh, plot=FALSE, taper=0, fast=FALSE, detrend=FALSE)
plot(spec3$frequency, spec3$power, log="y", type="b")
lines(spec4$freq, spec4$spec, col="green")
</code></pre>

<hr>
<h2 id='expectation'>Expectations and variances of distributions</h2><span id='topic+expectation'></span><span id='topic+variance'></span><span id='topic+expectation.bspec'></span><span id='topic+expectation.bspecACF'></span><span id='topic+variance.bspec'></span><span id='topic+variance.bspecACF'></span>

<h3>Description</h3>

<p>Functions to compute (posterior) expectations or variances of the
distributions specified as arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  expectation(x, ...)
  variance(x, ...)
  ## S3 method for class 'bspec'
expectation(x, two.sided=x$two.sided, ...)
  ## S3 method for class 'bspec'
variance(x, two.sided=x$two.sided, ...)
  ## S3 method for class 'bspecACF'
expectation(x, ...)
  ## S3 method for class 'bspecACF'
variance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expectation_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+bspec.default">bspec</a></code> or
<code><a href="#topic+acf.bspec">bspecACF</a></code> object.</p>
</td></tr>
<tr><td><code id="expectation_+3A_two.sided">two.sided</code></td>
<td>
<p>A <code>logical</code> flag to indicate whether to compute
expectation / variance of one- or two-sided spectrum, <em>if</em>
the argument <code>x</code> is a <code>bspec</code> object.</p>
</td></tr>
<tr><td><code id="expectation_+3A_...">...</code></td>
<td>
<p>currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>numeric</code> vector giving the expectations/variances
corresponding to the frequencies or lags of the argument.
</p>


<h3>Author(s)</h3>

<p>Christian Roever, <a href="mailto:christian.roever@med.uni-goettingen.de">christian.roever@med.uni-goettingen.de</a></p>


<h3>References</h3>

<p>Roever, C., Meyer, R., Christensen, N.
Modelling coloured residual noise in gravitational-wave signal processing.
<em>Classical and Quantum Gravity</em>, <b>28</b>(1):015010, 2011.
doi: <a href="https://doi.org/10.1088/0264-9381/28/1/015010">10.1088/0264-9381/28/1/015010</a>.
See also <a href="https://arxiv.org/abs/0804.3853">arXiv preprint 0804.3853</a>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+bspec.default">bspec</a></code>, <code><a href="#topic+acf.bspec">acf.bspec</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># note the changing expectation
# with increasing prior/posterior degrees-of-freedom:
expectation(bspec(lh))
expectation(bspec(lh, priordf=1, priorscale=0.6))
expectation(bspec(lh, priordf=2, priorscale=0.6))

# similar for variance:
variance(bspec(lh, priordf=2, priorscale=0.6))
variance(bspec(lh, priordf=3, priorscale=0.6))

# and again similar for autocovariances:
expectation(acf(bspec(lh)))
expectation(acf(bspec(lh, priordf=2, priorscale=0.6)))
variance(acf(bspec(lh)))
variance(acf(bspec(lh, priordf=4, priorscale=0.6)))
</code></pre>

<hr>
<h2 id='likelihood'>Prior, likelihood and posterior</h2><span id='topic+dprior'></span><span id='topic+likelihood'></span><span id='topic+marglikelihood'></span><span id='topic+dposterior'></span><span id='topic+dprior.bspec'></span><span id='topic+likelihood.bspec'></span><span id='topic+marglikelihood.bspec'></span><span id='topic+dposterior.bspec'></span>

<h3>Description</h3>

<p>Prior density, likelihood, posterior density, and marginal likelihood
functions for the posterior distributions specified through a
<code>bspec</code> object. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dprior(x, ...)
likelihood(x, ...)
marglikelihood(x, ...)
dposterior(x, ...)
## S3 method for class 'bspec'
dprior(x, theta, two.sided=x$two.sided, log=FALSE, ...)
## S3 method for class 'bspec'
likelihood(x, theta, two.sided=x$two.sided, log=FALSE, ...)
## S3 method for class 'bspec'
marglikelihood(x, log=FALSE, ...)
## S3 method for class 'bspec'
dposterior(x, theta, two.sided=x$two.sided, log=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="likelihood_+3A_x">x</code></td>
<td>
<p>a <code>bspec</code> object.</p>
</td></tr>
<tr><td><code id="likelihood_+3A_theta">theta</code></td>
<td>
<p>a <code>numeric</code> vector of parameter values,
corresponding to the Fourier frequencies in the <code>x$freq</code> element.</p>
</td></tr>
<tr><td><code id="likelihood_+3A_two.sided">two.sided</code></td>
<td>
<p>a <code>logical</code> flag indicating whether the
parameters <code>theta</code> correspond to the <em>one-sided</em> or
<em>two-sided</em> spectrum.</p>
</td></tr>
<tr><td><code id="likelihood_+3A_log">log</code></td>
<td>
<p>a <code>logical</code> flag indicating whether to return
logarithmic density (or likelihood) values.</p>
</td></tr>
<tr><td><code id="likelihood_+3A_...">...</code></td>
<td>
<p>currently unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prior and posterior are both <em>scaled inverse
<code class="reqn">\chi^2</code> distributions</em>,
and the likelihood is Normal.
</p>


<h3>Value</h3>

<p>A <code>numeric</code> function value.
</p>


<h3>Author(s)</h3>

<p>Christian Roever, <a href="mailto:christian.roever@med.uni-goettingen.de">christian.roever@med.uni-goettingen.de</a></p>


<h3>References</h3>

<p>Roever, C., Meyer, R., Christensen, N.
Modelling coloured residual noise in gravitational-wave signal processing.
<em>Classical and Quantum Gravity</em>, <b>28</b>(1):015010, 2011.
doi: <a href="https://doi.org/10.1088/0264-9381/28/1/015010">10.1088/0264-9381/28/1/015010</a>.
See also <a href="https://arxiv.org/abs/0804.3853">arXiv preprint 0804.3853</a>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+bspec.default">bspec</a></code>,
<code><a href="#topic+quantile.bspec">quantile.bspec</a></code>,
<code><a href="#topic+expectation.bspec">expectation</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>lhspec &lt;- bspec(lh, priordf=1, priorscale=0.6)

# draw sample from posterior:
posteriorsample &lt;- sample(lhspec)

# plot the sample:
plot(lhspec)
lines(lhspec$freq, posteriorsample, type="b", col="red")

# compute prior, likelihood, posterior:
print(c("prior"              = dprior(lhspec, posteriorsample),
        "likelihood"         = likelihood(lhspec, posteriorsample),
        "posterior"          = dposterior(lhspec, posteriorsample),
        "marginal likelihood"= marglikelihood(lhspec)))
</code></pre>

<hr>
<h2 id='matchedfilter'>Filter a noisy time series for a signal of given shape</h2><span id='topic+matchedfilter'></span><span id='topic+studenttfilter'></span>

<h3>Description</h3>

<p>Computes the maximized likelihood ratio (as a test- or
detection-statistic) of &quot;<em>signal</em>&quot; vs. &quot;<em>noise only</em>&quot;
hypotheses. The signal is modelled as a linear combination of
orthogonal basis vectors of unknown amplitude and arrival time. The
noise is modelled either as Gaussian or Student-t-distributed, and
coloured.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matchedfilter(data, signal, noisePSD, timerange = NA,
    reconstruct = TRUE, two.sided = FALSE)

studenttfilter(data, signal, noisePSD, df = 10, timerange = NA,
    deltamax = 1e-06, itermax = 100,
    reconstruct = TRUE, two.sided = FALSE) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="matchedfilter_+3A_data">data</code></td>
<td>
<p>the data to be filtered, a time series (<code><a href="stats.html#topic+ts">ts</a></code>) object.</p>
</td></tr>
<tr><td><code id="matchedfilter_+3A_signal">signal</code></td>
<td>
<p>the signal waveform to be filtered for. May be a vector,
a matrix, a time series (<code><a href="stats.html#topic+ts">ts</a></code>) or a multivariate time
series (<code><a href="stats.html#topic+ts">mts</a></code>) object.</p>
</td></tr>
<tr><td><code id="matchedfilter_+3A_noisepsd">noisePSD</code></td>
<td>
<p>the noise power spectral density. May be a vector of
appropriate length (<code>length(data)/2+1</code>) or a function of frequency.</p>
</td></tr>
<tr><td><code id="matchedfilter_+3A_df">df</code></td>
<td>
<p>the number of degrees-of-freedom (<code class="reqn">\nu_j</code>) for
each frequency bin. May be a vector of appropriate length
(<code>length(data)/2+1</code>) or a function of frequency.</p>
</td></tr>
<tr><td><code id="matchedfilter_+3A_timerange">timerange</code></td>
<td>
<p>the range of times (with respect to the <code>data</code>
argument's time scale) to maximize the likelihood ratio over.</p>
</td></tr>
<tr><td><code id="matchedfilter_+3A_deltamax">deltamax</code></td>
<td>
<p>the minimal difference in logarithmic likelihoods to
be aimed for in the EM-iterations (termination criterion).</p>
</td></tr>
<tr><td><code id="matchedfilter_+3A_itermax">itermax</code></td>
<td>
<p>the maximum number of EM-iterations to be performed.</p>
</td></tr>
<tr><td><code id="matchedfilter_+3A_reconstruct">reconstruct</code></td>
<td>
<p>a <code>logical</code> flag indicating whether the
output is supposed to include the best-fitting signal waveform.</p>
</td></tr>
<tr><td><code id="matchedfilter_+3A_two.sided">two.sided</code></td>
<td>
<p>a <code>logical</code> flag indicating whether the
<code>noisePSD</code> argument is to be interpreted as a one-sided or a
two-sided spectrum.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The time series data <code class="reqn">d(t)</code> is modelled as a
superposition of signal <code class="reqn">s(\beta,t_0,t)</code> and noise
<code class="reqn">n(t)</code>:
</p>
<p style="text-align: center;"><code class="reqn">d(t)=s(\beta,t-t_0)+n(t),</code>
</p>

<p>where the signal is a linear combination of orthogonal (!) basis
vectors <code class="reqn">s_i(t)</code>, and whose time-of-arrival is given by
the parameter <code class="reqn">t_0</code>:
</p>
<p style="text-align: center;"><code class="reqn">s(\beta,t-t_0)=\sum_{i=1}^k \beta_i s_i(t-t_0).</code>
</p>

<p>The noise is modelled as either Gaussian (<code>matchedfilter()</code>) or
Student-t distributed (<code>studenttfilter()</code>) with given power
spectral density and, for the latter model only, degrees-of-freedom
parameters.
</p>
<p>The filtering functions perform a likelihood maximization over the
time-of-arrival <code class="reqn">t_0</code> and coefficients <code class="reqn">\beta</code>. In
the Gaussian model, the conditional likelihood, conditional on
<code class="reqn">t_0</code>, can be maximized analytically, while the maximization
over <code class="reqn">t_0</code> is done numerically via a brute-force search. In
the Student-t model, likelihood maximization is implemented using an
EM-algorithm. The maximization over <code class="reqn">t_0</code> is restricted to the
range specified via the <code>timerange</code> argument.
</p>
<p>What is returned is the maximized (logarithmic)
likelihood ratio of &quot;signal&quot; versus &quot;noise-only&quot; hypotheses (the
result's <code>$maxLLR</code> component), and the corresponding
ML-estimates <code class="reqn">\hat{t}_0</code> and
<code class="reqn">\hat{\beta}</code>, as well as the ML-fitted signal
(&quot;<code>$reconstruction</code>&quot;).
</p>


<h3>Value</h3>

<p>A list containing the following elements:
</p>
<table role = "presentation">
<tr><td><code>maxLLR</code></td>
<td>
<p>the maximized likelihood ratio of <em>signal</em>
vs. <em>noise only</em> hypotheses.</p>
</td></tr>
<tr><td><code>timerange</code></td>
<td>
<p>the range of times to maximize the likelihood ratio
over (see the <code>timerange</code> input argument).</p>
</td></tr>
<tr><td><code>betaHat</code></td>
<td>
<p>the ML-estimated vector of coefficients.</p>
</td></tr>
<tr><td><code>tHat</code></td>
<td>
<p>the ML-estimated signal arrival time.</p>
</td></tr>
<tr><td><code>reconstruction</code></td>
<td>
<p>the ML-fitted signal (a time series
(<code><a href="stats.html#topic+ts">ts</a></code>) object).</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>an object of class <code>call</code> giving the
function call that generated the result.</p>
</td></tr>
</table>
<p>elements only for the <code>matchedfilter()</code> function:
</p>
<table role = "presentation">
<tr><td><code>maxLLRseries</code></td>
<td>
<p>the time series of (conditionally) maximized
likelihood ratio for each given time point (the <em>profile
likelihood</em>).</p>
</td></tr>
</table>
<p>elements only for the <code>studenttfilter()</code> function:
</p>
<table role = "presentation">
<tr><td><code>EMprogress</code></td>
<td>
<p>a <code>matrix</code> indicating the progress of the EM-fitting.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christian Roever, <a href="mailto:christian.roever@med.uni-goettingen.de">christian.roever@med.uni-goettingen.de</a></p>


<h3>References</h3>

<p>  Roever, C.
A Student-t based filter for robust signal detection.
<em>Physical Review D</em>, <b>84</b>(12):122004, 2011.
doi: <a href="https://doi.org/10.1103/PhysRevD.84.122004">10.1103/PhysRevD.84.122004</a>.
See also <a href="https://arxiv.org/abs/1109.0442">arXiv preprint 1109.0442</a>.
</p>
<p>Roever, C., Meyer, R., Christensen, N.
Modelling coloured residual noise in gravitational-wave signal processing.
<em>Classical and Quantum Gravity</em>, <b>28</b>(1):015010, 2011.
doi: <a href="https://doi.org/10.1088/0264-9381/28/1/015010">10.1088/0264-9381/28/1/015010</a>.
See also <a href="https://arxiv.org/abs/0804.3853">arXiv preprint 0804.3853</a>.</p>


<h3>Examples</h3>

<pre><code class='language-R'># sample size and sampling resolution:
deltaT  &lt;- 0.001
N       &lt;- 1000

# For the coloured noise, use some AR(1) process;
# AR noise process parameters:
sigmaAR &lt;- 1.0
phiAR   &lt;- 0.9

# generate non-white noise
# (autoregressive AR(1) low-frequency noise):
noiseSample &lt;- rnorm(10*N)
for (i in 2:length(noiseSample))
  noiseSample[i] &lt;- phiAR*noiseSample[i-1] + noiseSample[i]
noiseSample &lt;- ts(noiseSample, deltat=deltaT)

# estimate the noise spectrum:
PSDestimate &lt;- welchPSD(noiseSample, seglength=1,
                        windowingPsdCorrection=FALSE)

# show noise and noise PSD:
par(mfrow=c(2,1))
  plot(noiseSample, main="noise sample")
  plot(PSDestimate$freq, PSDestimate$pow, log="y", type="l",
       main="noise PSD", xlab="frequency", ylab="power")
par(mfrow=c(1,1))

# generate actual data:
noise &lt;- rnorm(N)
for (i in 2:length(noise))
  noise[i] &lt;- phiAR*noise[i-1] + noise[i]
noise &lt;- ts(noise, start=0, deltat=deltaT)

# the "sine-Gaussian" signal to be injected into the noise:
t0    &lt;- 0.6
phase &lt;- 1.0
signal &lt;- exp(-(time(noise)-t0)^2/(2*0.01^2)) * sin(2*pi*150*(time(noise)-t0)+phase)
plot(signal)

t &lt;- seq(-0.1, 0.1, by=deltaT)
# the signal's orthogonal (sine- and cosine-) basis waveforms:
signalSine   &lt;- exp(-t^2/(2*0.01^2)) * sin(2*pi*150*t)
signalCosine &lt;- exp(-t^2/(2*0.01^2)) * sin(2*pi*150*t+pi/2)
signalBasis &lt;- ts(cbind("sine"=signalSine, "cosine"=signalCosine),
                  start=-0.1, deltat=deltaT)
plot(signalBasis[,1], col="red", main="the signal basis")
lines(signalBasis[,2], col="green")
# (the sine- and cosine- components allow to span
#  signals of arbitrary phase)
# Note that "signalBasis" may be shorter than "data",
# but must be of the same time resolution.


# compute the signal's signal-to-noise ration (SNR):
signalSnr &lt;- snr(signal, psd=PSDestimate$pow)

# scale signal to SNR = 6:
rho &lt;- 6
data &lt;- noise + signal * (rho/signalSnr)
data &lt;- data * tukeywindow(length(data))
# Note that the data has (and should have!)
# the same resolution, size, and windowing applied
# as in the PSD estimation step.

# compute filters:
f1 &lt;- matchedfilter(data, signalBasis, PSDestimate$power)
f2 &lt;- studenttfilter(data, signalBasis, PSDestimate$power)

# illustrate the results:
par(mfrow=c(3,1))
  plot(data, ylab="", main="data")
  lines(signal* (rho/signalSnr), col="green")
  legend(0,max(data),c("noise + signal","signal only"),
         lty="solid", col=c("black","green"), bg="white")

  plot(signal * (rho/signalSnr), xlim=c(0.55, 0.65), ylab="",
       main="original &amp; recovered signals")
  lines(f1$reconstruction, col="red")
  lines(f2$reconstruction, col="blue")
  abline(v=c(f1$tHat,f2$tHat), col=c("red", "blue"), lty="dashed")
  legend(0.55, max(signal*(rho/signalSnr)),
         c("injected signal","best-fitting signal (Gaussian model)",
           "best-fitting signal (Student-t model)"),
         lty="solid", col=c("black","red","blue"), bg="white")

  plot(f1$maxLLRseries, type="n", ylim=c(0, f1$maxLLR),
       main="profile likelihood (Gaussian model)",
       ylab="maximized (log-) likelihood ratio")
  lines(f1$maxLLRseries, col="grey")
  lines(window(f1$maxLLRseries, start=f1$timerange[1], end=f1$timerange[2]))
  abline(v=f1$timerange, lty="dotted")
  lines(c(f1$tHat,f1$tHat,-1), c(0,f1$maxLLR,f1$maxLLR), col="red", lty="dashed")
par(mfrow=c(1,1))
</code></pre>

<hr>
<h2 id='one.sided'>Conversion between one- and two-sided spectra</h2><span id='topic+one.sided'></span><span id='topic+two.sided'></span><span id='topic+one.sided.bspec'></span><span id='topic+two.sided.bspec'></span>

<h3>Description</h3>

<p>Functions to convert between one- and two-sided
<code>bspec</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>one.sided(x, ...)
two.sided(x, ...)
## S3 method for class 'bspec'
one.sided(x, ...)
## S3 method for class 'bspec'
two.sided(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="one.sided_+3A_x">x</code></td>
<td>
<p>a <code>bspec</code> object.</p>
</td></tr>
<tr><td><code id="one.sided_+3A_...">...</code></td>
<td>
<p>currently unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The conversion only means that the <code>$two.sided</code> element of the
returned <code>bspec</code> object is set correspondingly, as internally always
the same (one-sided) spectrum is used.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+bspec.default">bspec</a></code> object
(see the help for the <code><a href="#topic+bspec.default">bspec</a></code> function).
</p>


<h3>Author(s)</h3>

<p>Christian Roever, <a href="mailto:christian.roever@med.uni-goettingen.de">christian.roever@med.uni-goettingen.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+bspec.default">bspec</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>lhspec &lt;- bspec(lh)

# compare distributions visually:
par(mfrow=c(2,1))
  plot(lhspec)
  plot(two.sided(lhspec))
par(mfrow=c(1,1))

# ...and numerically:
print(cbind("frequency"=lhspec$freq,
            "median-1sided"=quantile(lhspec,0.5),
            "median-2sided"=quantile(two.sided(lhspec),0.5)))
</code></pre>

<hr>
<h2 id='ppsample'>Posterior predictive sampling</h2><span id='topic+ppsample'></span><span id='topic+ppsample.bspec'></span>

<h3>Description</h3>

<p>Draws a sample from the posterior predictive distribution specified by
the supplied <code>bspec</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ppsample(x, ...)
## S3 method for class 'bspec'
ppsample(x, start=x$start, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ppsample_+3A_x">x</code></td>
<td>
<p>a <code>bspec</code> object specifying the posterior
distribution from which to sample.</p>
</td></tr>
<tr><td><code id="ppsample_+3A_start">start</code></td>
<td>
<p>the start time of the resulting time series.</p>
</td></tr>
<tr><td><code id="ppsample_+3A_...">...</code></td>
<td>
<p>currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A time series (<code>ts</code>) object of the same kind (with respect to
sampling rate and sample size) as the data the posterior distribution
is based on.
</p>


<h3>Author(s)</h3>

<p>Christian Roever, <a href="mailto:christian.roever@med.uni-goettingen.de">christian.roever@med.uni-goettingen.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+bspec.default">bspec</a></code>, <code><a href="#topic+sample.bspec">sample.bspec</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
par(mfrow=c(2,1))
plot(lh, main="'lh' data")
plot(ppsample(bspec(lh)), main="posterior predictive sample")
par(mfrow=c(1,1))
</code></pre>

<hr>
<h2 id='quantile.bspec'>Quantiles of the posterior spectrum</h2><span id='topic+quantile.bspec'></span>

<h3>Description</h3>

<p>Function to compute quantiles of the spectrum's posterior
distribution specified through the supplied <code>bspec</code>
object argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bspec'
quantile(x, probs = c(0.025, 0.5, 0.975),
  two.sided = x$two.sided, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quantile.bspec_+3A_x">x</code></td>
<td>
<p>a <code>bspec</code> object.</p>
</td></tr>
<tr><td><code id="quantile.bspec_+3A_probs">probs</code></td>
<td>
<p>a <code>numerical</code> vector of probabilities.</p>
</td></tr>
<tr><td><code id="quantile.bspec_+3A_two.sided">two.sided</code></td>
<td>
<p>a <code>logical</code> flag indicating whether quantiles
are supposed to correspond to the <em>one-sided</em> or
<em>two-sided</em> spectrum.</p>
</td></tr>
<tr><td><code id="quantile.bspec_+3A_...">...</code></td>
<td>
<p>currently unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The posterior distribution is a product of independent <em>scaled inverse
<code class="reqn">\chi^2</code> distributions</em>.
</p>


<h3>Value</h3>

<p>A matrix with columns corresponding to elements of <code>probs</code>, and
rows corresponding to the Fourier frequencies <code>x$freq</code>.
If <code>probs</code> is of length 1, a vector is returned instead.
</p>


<h3>Author(s)</h3>

<p>Christian Roever, <a href="mailto:christian.roever@med.uni-goettingen.de">christian.roever@med.uni-goettingen.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+bspec.default">bspec</a></code>, <code><a href="stats.html#topic+quantile">quantile</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>lhspec &lt;- bspec(lh)

# posterior medians:
print(cbind("frequency"=lhspec$freq,
            "median"=quantile(lhspec, 0.5)))
</code></pre>

<hr>
<h2 id='sample.bspec'>Posterior sampling</h2><span id='topic+sample.bspec'></span><span id='topic+sample.default'></span><span id='topic+sample'></span>

<h3>Description</h3>

<p>Function to generate samples from the spectrum's posterior
distribution specified through the supplied <code>bspec</code>
object argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'bspec'
sample(x, size = 1, two.sided = x$two.sided, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample.bspec_+3A_x">x</code></td>
<td>
<p>a <code>bspec</code> object.</p>
</td></tr>
<tr><td><code id="sample.bspec_+3A_size">size</code></td>
<td>
<p>the sample size.</p>
</td></tr>
<tr><td><code id="sample.bspec_+3A_two.sided">two.sided</code></td>
<td>
<p>a <code>logical</code> flag indicating whether the drawn
samples are supposed to correspond to the <em>one-sided</em> or
<em>two-sided</em> spectrum.</p>
</td></tr>
<tr><td><code id="sample.bspec_+3A_...">...</code></td>
<td>
<p>currently unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The posterior distribution is a product of independent <em>scaled inverse
<code class="reqn">\chi^2</code> distributions</em>.
</p>


<h3>Value</h3>

<p>A (<code>numerical</code>) vector of samples from the posterior distribution
of the spectral parameters, of the same length as and corresponding to
the <code>$freq</code> element of the supplied <code>bspec</code> object.
</p>


<h3>Author(s)</h3>

<p>Christian Roever, <a href="mailto:christian.roever@med.uni-goettingen.de">christian.roever@med.uni-goettingen.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+bspec.default">bspec</a></code>,
<code><a href="#topic+ppsample.bspec">ppsample</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># determine spectrum's posterior distribution:
lhspec &lt;- bspec(lh)

# plot 95 percent central intervals and medians:
plot(lhspec)

# draw and plot two samples from posterior distribution:
lines(lhspec$freq, sample(lhspec), type="b", pch=20, col="red")
lines(lhspec$freq, sample(lhspec), type="b", pch=20, col="green")
</code></pre>

<hr>
<h2 id='snr'>Compute the signal-to-noise ratio (SNR) of a signal</h2><span id='topic+snr'></span>

<h3>Description</h3>

<p>Compute the SNR for a given signal and noise power spectral density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snr(x, psd, two.sided = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="snr_+3A_x">x</code></td>
<td>
<p>the signal waveform, a time series (<code><a href="stats.html#topic+ts">ts</a></code>) object.</p>
</td></tr>
<tr><td><code id="snr_+3A_psd">psd</code></td>
<td>
<p>the noise power spectral density. May be a vector of
appropriate length (<code>length(x)/2+1</code>) or a function of frequency.</p>
</td></tr>
<tr><td><code id="snr_+3A_two.sided">two.sided</code></td>
<td>
<p>a <code>logical</code> flag indicating whether the
<code>psd</code> argument is to be interpreted as a one-sided or a
two-sided spectrum.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a signal <code class="reqn">s(t)</code>, the complex-valued discrete
Fourier transform <code class="reqn">\tilde{s}(f)</code> is computed along the Fourier
frequencies <code class="reqn">f_j=\frac{j}{N \Delta_t} |
    j=0,\ldots,N/2+1</code>, where
<code class="reqn">N</code> is the sample size, and <code class="reqn">\Delta_t</code> is the
sampling interval.
The SNR, as a measure of &quot;signal strength&quot; relative to the noise, then
is given by
</p>
<p style="text-align: center;"><code class="reqn">\varrho=\sqrt{\sum_{j=0}^{N/2+1}\frac{\bigl|\tilde{s(f_j)}\bigr|^2}{\frac{N}{4\Delta_t} S_1(f_j)}},</code>
</p>

<p>where <code class="reqn">S_1(f)</code> is the noise's one-sided power spectral
density. For more on its interpretation, see e.g. Sec. II.C.4 in the
reference below.
</p>


<h3>Value</h3>

<p>The SNR <code class="reqn">\varrho</code>.
</p>


<h3>Author(s)</h3>

<p>Christian Roever, <a href="mailto:christian.roever@med.uni-goettingen.de">christian.roever@med.uni-goettingen.de</a></p>


<h3>References</h3>

<p>  Roever, C.
A Student-t based filter for robust signal detection.
<em>Physical Review D</em>, <b>84</b>(12):122004, 2011.
doi: <a href="https://doi.org/10.1103/PhysRevD.84.122004">10.1103/PhysRevD.84.122004</a>.
See also <a href="https://arxiv.org/abs/1109.0442">arXiv preprint 1109.0442</a>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+matchedfilter">matchedfilter</a></code>, <code><a href="#topic+studenttfilter">studenttfilter</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># sample size and sampling resolution:
N       &lt;- 1000
deltaT  &lt;- 0.001

# For the coloured noise, use some AR(1) process;
# AR noise process parameters:
sigmaAR &lt;- 1.0
phiAR   &lt;- 0.9

# generate non-white noise
# (autoregressive AR(1) low-frequency noise):
noiseSample &lt;- rnorm(10*N)
for (i in 2:length(noiseSample))
  noiseSample[i] &lt;- phiAR*noiseSample[i-1] + noiseSample[i]
noiseSample &lt;- ts(noiseSample, deltat=deltaT)

# estimate the noise spectrum:
PSDestimate &lt;- welchPSD(noiseSample, seglength=1,
                        windowingPsdCorrection=FALSE)

# generate a (sine-Gaussian) signal:
t0    &lt;- 0.6
phase &lt;- 1.0
t &lt;- ts((0:(N-1))*deltaT, deltat=deltaT, start=0)
signal &lt;- exp(-(t-t0)^2/(2*0.01^2)) * sin(2*pi*150*(t-t0)+phase)
plot(signal)

# compute the signal's SNR:
snr(signal, psd=PSDestimate$power)
</code></pre>

<hr>
<h2 id='temper'>Tempering of (posterior) distributions</h2><span id='topic+temper'></span><span id='topic+temper.bspec'></span>

<h3>Description</h3>

<p>Setting the tempering parameter of (&lsquo;tempered&rsquo;)
<code>bspec</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  temper(x, ...)
  ## S3 method for class 'bspec'
temper(x, temperature = 2, likelihood.only = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="temper_+3A_x">x</code></td>
<td>
<p>a <code>bspec</code> object.</p>
</td></tr>
<tr><td><code id="temper_+3A_temperature">temperature</code></td>
<td>
<p>a (positive) &lsquo;temperature&rsquo; value.</p>
</td></tr>
<tr><td><code id="temper_+3A_likelihood.only">likelihood.only</code></td>
<td>
<p>a <code>logical</code> flag indicating whether to
apply the tempering to the &lsquo;complete&rsquo; posterior density, or
to the likelihood only (default).</p>
</td></tr>
<tr><td><code id="temper_+3A_...">...</code></td>
<td>
<p>currently unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the context of Markov chain Monte Carlo (MCMC) applications it is
often desirable to apply <em>tempering</em> to the distribution of
interest, as it is supposed to make the distribution more easily
tractable. Examples where tempering is utilised are <em>simulated
annealing</em>, <em>parallel tempering</em> or <em>evolutionary MCMC</em>
algorithms. In the context of Bayesian inference, tempering may be
done by specifying a &lsquo;temperature&rsquo; <code class="reqn">T</code> and then
manipulating the original posterior distribution
<code class="reqn">p(\theta|y)</code> by applying an exponent
<code class="reqn">\frac{1}{T}</code> either to the complete posterior distribution:
</p>
<p style="text-align: center;"><code class="reqn">p_T(\theta) \propto p(\theta|y)^\frac{1}{T}%
        = (p(y|\theta)p(\theta))^\frac{1}{T}</code>
</p>

<p>or to the likelihood part only:
</p>
<p style="text-align: center;"><code class="reqn">p_T(\theta) \propto p(y|\theta)^\frac{1}{T}p(\theta).</code>
</p>

<p>In this context, where the posterior distribution is a product of
<em>scaled inverse <code class="reqn">\chi^2</code> distributions</em>, the
tempered distributions in both cases turn out to be again of the same
family, just with different parameters. For more details see also the
references.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+bspec.default">bspec</a></code>
(see the help for the <code><a href="#topic+bspec.default">bspec</a></code> function),
but with an additional <code>temperature</code> element.
</p>


<h3>Note</h3>

<p>Tempering with the <code>likelihood.only</code> flag set to <code>FALSE</code>
only works as long as the <code>temperature</code> is less than
<code>min((x$df+2)/2)</code>.
</p>


<h3>Author(s)</h3>

<p>Christian Roever, <a href="mailto:christian.roever@med.uni-goettingen.de">christian.roever@med.uni-goettingen.de</a></p>


<h3>References</h3>

<p>Roever, C.
<a href="http://hdl.handle.net/2292/2356">Bayesian inference on
astrophysical binary inspirals based on gravitational-wave
measurements</a>.
PhD thesis, Department of Statistics, The University of Auckland,
New Zealand, 2007.</p>


<h3>See Also</h3>

<p><code><a href="#topic+temperature.bspec">temperature</a></code>,
<code><a href="#topic+bspec.default">bspec</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>lhspec &lt;- bspec(lh, priorscale=0.6, priordf=1)

# details of the regular posterior distribution:
str(lhspec)

# details of the tempered distribution
# (note the differing scale and degrees-of-freedom):
str(temper(lhspec, 1.23))
</code></pre>

<hr>
<h2 id='temperature'>Querying the tempering parameter</h2><span id='topic+temperature'></span><span id='topic+temperature.bspec'></span>

<h3>Description</h3>

<p>Retrieving the &ldquo;temperature&rdquo; parameter of (&lsquo;tempered&rsquo;)
<code>bspec</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  temperature(x, ...)
  ## S3 method for class 'bspec'
temperature(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="temperature_+3A_x">x</code></td>
<td>
<p>a <code>bspec</code> object.</p>
</td></tr>
<tr><td><code id="temperature_+3A_...">...</code></td>
<td>
<p>currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The (<code>numeric</code>) value of the <code>temperature</code> element of the
supplied <code><a href="#topic+bspec.default">bspec</a></code> object, if present, and 1
otherwise.
</p>


<h3>Author(s)</h3>

<p>Christian Roever, <a href="mailto:christian.roever@med.uni-goettingen.de">christian.roever@med.uni-goettingen.de</a></p>


<h3>References</h3>

<p>Roever, C.
<a href="http://hdl.handle.net/2292/2356">Bayesian inference on
astrophysical binary inspirals based on gravitational-wave
measurements</a>.
PhD thesis, Department of Statistics, The University of Auckland,
New Zealand, 2007.</p>


<h3>See Also</h3>

<p><code><a href="#topic+temper.bspec">temper</a></code>,
<code><a href="#topic+bspec.default">bspec</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>lhspec1 &lt;- bspec(lh)
lhspec2 &lt;- temper(lhspec1, 1.23)

print(lhspec2$temperature)
print(lhspec1$temperature)

print(temperature(lhspec2))
print(temperature(lhspec1))
</code></pre>

<hr>
<h2 id='tukeywindow'>Compute windowing functions for spectral time series analysis.</h2><span id='topic+tukeywindow'></span><span id='topic+squarewindow'></span><span id='topic+hannwindow'></span><span id='topic+welchwindow'></span><span id='topic+trianglewindow'></span><span id='topic+hammingwindow'></span><span id='topic+cosinewindow'></span><span id='topic+kaiserwindow'></span>

<h3>Description</h3>

<p>Several windowing functions for spectral or Fourier analysis of time
series data are provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tukeywindow(N, r = 0.1)
squarewindow(N)
hannwindow(N)
welchwindow(N)
trianglewindow(N)
hammingwindow(N, alpha=0.543478261)
cosinewindow(N, alpha=1)
kaiserwindow(N, alpha=3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tukeywindow_+3A_n">N</code></td>
<td>
<p>the length of the time series to be windowed</p>
</td></tr>
<tr><td><code id="tukeywindow_+3A_r">r</code></td>
<td>
<p>the Tukey window's parameter, denoting the its &quot;non-flat&quot;
fraction.</p>
</td></tr>
<tr><td><code id="tukeywindow_+3A_alpha">alpha</code></td>
<td>
<p>additional parameter for Hamming-, cosine-, and Kaiser-windows.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><em>Windowing</em> of time series data, i.e., multiplication with a tapering
function, is often useful in spectral or Fourier analysis in order to
reduce &quot;leakage&quot; effects due to the discrete and finite
sampling. These functions provide windowing coefficients for a given
sample size <code>N</code>.
</p>


<h3>Value</h3>

<p>A vector (of length <code>N</code>) of windowing coefficients.
</p>


<h3>Author(s)</h3>

<p>Christian Roever, <a href="mailto:christian.roever@med.uni-goettingen.de">christian.roever@med.uni-goettingen.de</a></p>


<h3>References</h3>

<p>Harris, F. J.
On the use of windows for harmonic analysis
with the discrete Fourier transform.
<em>Proceedings of the IEEE</em>, <b>66</b>(1):51&ndash;83, 1978.
doi: <a href="https://doi.org/10.1109/PROC.1978.10837">10.1109/PROC.1978.10837</a>
</p>
<p>Press, W. H., Teukolsky, S. A., Vetterling, W. T., Flannery,
B. P. <em>Numerical recipes in C</em>. Cambridge University
Press, 1992.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+welchPSD">welchPSD</a></code>, <code><a href="#topic+empiricalSpectrum">empiricalSpectrum</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># illustrate the different windows' shapes:
N &lt;- 100
matplot(1:N,
        cbind(cosinewindow(N),
              hammingwindow(N),
              hannwindow(N),
              kaiserwindow(N),
              squarewindow(N),
              trianglewindow(N),
              tukeywindow(N,r=0.5),
              welchwindow(N)),
        type="l", lty="solid", col=1:8)
legend(N, 0.99, legend=c("cosine","hamming","hann","kaiser",
                         "square","triangle","tukey","welch"),
       col=1:8, lty="solid", xjust=1, yjust=1, bg="white")

# show their effect on PSD estimation:
data(sunspots)



spec1 &lt;- welchPSD(sunspots, seglength=10, windowfun=squarewindow)
plot(spec1$frequency, spec1$power, log="y", type="l")

spec2 &lt;- welchPSD(sunspots, seglength=10, windowfun=tukeywindow, r=0.25)
lines(spec2$frequency, spec2$power, log="y", type="l", col="red")

spec3 &lt;- welchPSD(sunspots, seglength=10, windowfun=trianglewindow)
lines(spec3$frequency, spec3$power, log="y", type="l", col="green")
</code></pre>

<hr>
<h2 id='welchPSD'>Power spectral density estimation using Welch's method.</h2><span id='topic+welchPSD'></span>

<h3>Description</h3>

<p>Estimates a time series' power spectral density using <em>Welch's
method</em>, i.e., by subdividing the data into segments, computing
spectra for each, and averaging over the results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>welchPSD(x, seglength, two.sided = FALSE, windowfun = tukeywindow,
         method = c("mean", "median"), windowingPsdCorrection = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="welchPSD_+3A_x">x</code></td>
<td>
<p>a time series (<code><a href="stats.html#topic+ts">ts</a></code> object).</p>
</td></tr>
<tr><td><code id="welchPSD_+3A_seglength">seglength</code></td>
<td>
<p>the length of the subsegments to be used (in units of
time relative to <code>x</code>).</p>
</td></tr>
<tr><td><code id="welchPSD_+3A_two.sided">two.sided</code></td>
<td>
<p>a <code>logical</code> flag indicating whether the result is
supposed to be one-sided (default) or two-sided.</p>
</td></tr>
<tr><td><code id="welchPSD_+3A_windowfun">windowfun</code></td>
<td>
<p>The windowing function to be used.</p>
</td></tr>
<tr><td><code id="welchPSD_+3A_method">method</code></td>
<td>
<p>The &quot;averaging&quot; method to be used &ndash; either
<code>"mean"</code> or <code>"median"</code>.</p>
</td></tr>
<tr><td><code id="welchPSD_+3A_windowingpsdcorrection">windowingPsdCorrection</code></td>
<td>
<p>a <code>logical</code> flag indicating whether
an overall correction for the windowing is supposed to be applied to
the result &ndash; this essentially specifies whether the result is
supposed to reflect the PSD of the <em>windowed</em> or of the
&quot;<em>un-windowed&quot;</em> time series.</p>
</td></tr>
<tr><td><code id="welchPSD_+3A_...">...</code></td>
<td>
<p>other parameters passed to the windowing function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The time series will be divided into overlapping sub-segments, each
segment is windowed and its &quot;empirical&quot; spectrum is computed. The
average of these spectra is the resulting PSD estimate. For
robustness, the median may also be used instead of the mean.
</p>


<h3>Value</h3>

<p>A list containing the following elements:
</p>
<table role = "presentation">
<tr><td><code>frequency</code></td>
<td>
<p>the Fourier frequencies.</p>
</td></tr>
<tr><td><code>power</code></td>
<td>
<p>the estimated spectral power.</p>
</td></tr>
<tr><td><code>kappa</code></td>
<td>
<p>the number of (by definition) non-zero imaginary
components of the Fourier series.</p>
</td></tr>
<tr><td><code>two.sided</code></td>
<td>
<p>a <code>logical</code> flag indicating one- or
two-sidedness.</p>
</td></tr>
<tr><td><code>segments</code></td>
<td>
<p>the number of (overlapping) segments used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christian Roever, <a href="mailto:christian.roever@med.uni-goettingen.de">christian.roever@med.uni-goettingen.de</a></p>


<h3>References</h3>

<p>Welch, P. D.
The use of Fast Fourier Transform for the estimation of Power Spectra:
A method based on time averaging over short, modified periodograms.
<em>IEEE Transactions on Audio and Electroacoustics</em>,
<b>AU-15</b>(2):70&ndash;73, 1967.
doi: <a href="https://doi.org/10.1109/TAU.1967.1161901">10.1109/TAU.1967.1161901</a>.
</p>
<p>Press, W. H., Teukolsky, S. A., Vetterling, W. T., Flannery,
B. P. <em>Numerical recipes in C</em>. Cambridge University
Press, 1992.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+empiricalSpectrum">empiricalSpectrum</a></code>,
<code><a href="#topic+tukeywindow">tukeywindow</a></code>,
<code><a href="stats.html#topic+spectrum">spectrum</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load example data:
data(sunspots)
# compute and plot the "plain" spectrum:
spec1 &lt;- empiricalSpectrum(sunspots)
plot(spec1$frequency, spec1$power, log="y", type="l")

# plot Welch spectrum using segments of length 10 years:
spec2 &lt;- welchPSD(sunspots, seglength=10)
lines(spec2$frequency, spec2$power, col="red")

# use 20-year segments and a flatter Tukey window:
spec3 &lt;- welchPSD(sunspots, seglength=20, r=0.2)
lines(spec3$frequency, spec3$power, col="blue")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
