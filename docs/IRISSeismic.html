<!DOCTYPE html><html><head><title>Help for package IRISSeismic</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {IRISSeismic}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#IRISSeismic-package'><p>Classes and methods for seismic data analysis</p></a></li>
<li><a href='#basicStats'><p>Length, Max, Mean, Median, Min and Standard Deviation</p></a></li>
<li><a href='#butterworth'><p>Apply Butterworth filter</p></a></li>
<li><a href='#crossSpectrum'><p>Cross-Spectral Analysis</p></a></li>
<li><a href='#DDT'><p>Apply demean, detrend, cosine taper</p></a></li>
<li><a href='#envelope'><p>Envelope of a seismic signal</p></a></li>
<li><a href='#eventWindow'><p>Return a portion of a trace surrounding an event.</p></a></li>
<li><a href='#getAvailability'><p>Retrieve Channel metadata from IRIS DMC</p></a></li>
<li><a href='#getChannel'><p>Retrieve Channel metadata from IRIS DMC</p></a></li>
<li><a href='#getDataAvailability'><p>Retrieve miniseed trace extents from IRIS DMC</p></a></li>
<li><a href='#getDataselect'><p>Retrieve seismic data from IRIS DMC</p></a></li>
<li><a href='#getDistaz'><p>Retrieve great circle distance information from IRIS DMC</p></a></li>
<li><a href='#getEvalresp'><p>Retrieve instrument response information from IRIS DMC</p></a></li>
<li><a href='#getEvent'><p>Retrieve seismic event information from the USGS NEIC</p></a></li>
<li><a href='#getGaps'><p>Gap analysis</p></a></li>
<li><a href='#getNetwork'><p>Retrieve Network metadata from IRIS DMC</p></a></li>
<li><a href='#getRotation'><p>Retrieve rotated seismic data from IRIS DMC</p></a></li>
<li><a href='#getSNCL'><p>Retrieve seismic data from IRIS DMC</p></a></li>
<li><a href='#getStation'><p>Retrieve Station metadata from IRIS DMC</p></a></li>
<li><a href='#getTimeseries'><p>Retrieve seismic data from IRIS DMC</p></a></li>
<li><a href='#getTraveltime'><p>Retrieve seismic traveltime information from IRIS DMC</p></a></li>
<li><a href='#getUnavailability'><p>Retrieve Channel metadata from IRIS DMC</p></a></li>
<li><a href='#getUpDownTimes'><p>Determine times when a channel starts/stops collecting data</p></a></li>
<li><a href='#hilbert'><p>Hilbert of a seismic signal</p></a></li>
<li><a href='#hilbertFFT'><p>Hilbert FFT</p></a></li>
<li><a href='#IrisClient-class'><p> Class <code>"IrisClient"</code></p></a></li>
<li><a href='#McNamaraBins'><p>McNamara Binning</p></a></li>
<li><a href='#McNamaraPSD'><p>Power Spectral Density</p></a></li>
<li><a href='#mergeTraces'><p>Merge multiple traces into a single trace</p></a></li>
<li><a href='#mergeUpDownTimes'><p>Determine overlaps in two sets of upDownTimes.</p></a></li>
<li><a href='#miniseed2Stream'><p>Convert miniSEED bytes to <code>Stream</code> object</p></a></li>
<li><a href='#multiplyBy'><p>Multiplication by a constant</p></a></li>
<li><a href='#noiseMatrix2PdfMatrix'><p>Convert matrix of PSDs to matrix of Probability Density Functions</p></a></li>
<li><a href='#noiseModels'><p>Generate NHNM and NLNM noise models</p></a></li>
<li><a href='#psdDF2NoiseMatrix'><p>Apply instrument correction to PSDs</p></a></li>
<li><a href='#psdList'><p>Apply McNamara PSD algorithm to a seismic signal</p></a></li>
<li><a href='#psdList2NoiseMatrix'><p>Apply instrument correction to PSDs</p></a></li>
<li><a href='#psdPlot'><p>Generate plots from a set of PSDs</p></a></li>
<li><a href='#psdStatistics'><p>Return statistics for a set of PSDs</p></a></li>
<li><a href='#readMiniseedFile'><p>Convert miniSEED file to <code>Stream</code> object</p></a></li>
<li><a href='#rms'><p>Root Mean Square and RMS Variance</p></a></li>
<li><a href='#rotate2D'><p>Rotate horizontal components of a seismic signal</p></a></li>
<li><a href='#slice'><p>Slice a section out of a <code>Trace</code> or <code>Stream</code></p></a></li>
<li><a href='#STALTA'><p>STA/LTA</p></a></li>
<li><a href='#Stream-class'><p> Class <code>"Stream"</code></p></a></li>
<li><a href='#surfaceDistance'><p>Earth surface distance between two points</p></a></li>
<li><a href='#Trace-class'><p>Class <code>"Trace"</code></p></a></li>
<li><a href='#TraceHeader-class'><p> Class <code>"TraceHeader"</code></p></a></li>
<li><a href='#transferFunctionSpectra'><p>function to retrieve response values to use for input to the IRISMustangMetrics::transferFunctionMetric</p></a></li>
<li><a href='#triggerOnset'><p>Event onset triggering</p></a></li>
<li><a href='#unHistogram'><p>Histogram to Vector</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>1.6.6</td>
</tr>
<tr>
<td>Title:</td>
<td>Classes and Methods for Seismic Data Analysis</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, pracma, RCurl, seismicRoll (&ge; 1.1.0), signal,
stringr, XML, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr,rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides classes and methods for seismic data analysis. The
             base classes and methods are inspired by the python code found in
             the 'ObsPy' python toolbox <a href="https://github.com/obspy/obspy">https://github.com/obspy/obspy</a>. Additional classes and 
             methods support data returned by web services provided by the 'IRIS DMC'
             <a href="http://service.iris.edu/">http://service.iris.edu/</a>.</td>
</tr>
<tr>
<td>Collate:</td>
<td>Class-Trace.R Class-Stream.R Class-IrisClient.R
mseedWrappers.R Utils.R spectralUtils.R</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-10-14 19:36:37 UTC; gilliansharer</td>
</tr>
<tr>
<td>Author:</td>
<td>Jonathan Callahan [aut],
  Rob Casey [aut],
  Gillian Sharer [aut, cre],
  Mary Templeton [aut],
  Chad Trabant [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gillian Sharer &lt;gillian@iris.washington.edu&gt;</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-10-16 00:26:27 UTC</td>
</tr>
</table>
<hr>
<h2 id='IRISSeismic-package'>Classes and methods for seismic data analysis</h2><span id='topic+IRISSeismic-package'></span><span id='topic+IRISSeismic'></span>

<h3>Description</h3>

<p>This package provides S4 classes for downloading and processing seismological 
data available from the IRIS Data Management Center (DMC) (<a href="http://ds.iris.edu/ds/nodes/dmc/">http://ds.iris.edu/ds/nodes/dmc/</a>).
Core classes <code>Trace</code>, <code>Stream</code> and <code>IrisClient</code> and their associated methods
are inspired by the functionality available in the python ObsPy package (<a href="http://obspy.org/">http://obspy.org/</a>).
</p>


<h3>Introduction</h3>

<p>The &quot;IRISSeismic-intro&quot; vignette gives introductory examples on using the package.
</p>


<h3>History</h3>

<p>version 1.6.6
</p>

<ul>
<li><p> for web service calls that support the nodata=&lt;204|404&gt; option, use nodata=204 
</p>
</li>
<li><p> corrected the crossSpectrum documentation, Pxy is the cross-periodogram for ts1 and ts2 
</p>
</li></ul>

<p>version 1.6.5
</p>

<ul>
<li><p> examples and vignette updated for better error handling when accessing internet resources
</p>
</li></ul>

<p>version 1.6.4
</p>

<ul>
<li><p> updated to (modified version of) libmseed-2.19.8 
</p>
</li></ul>

<p>version 1.6.3
</p>

<ul>
<li><p> Stream object @ timing_quality now averages the values of the miniSEED blockette 1001 timing quality values, instead of summing the blockette 1001 values and dividing by the number of records
</p>
</li></ul>

<p>version 1.6.2
</p>

<ul>
<li><p> getDataselect, modified default time out values 
</p>
</li>
<li><p> fixed url in documentation 
</p>
</li></ul>

<p>version 1.6.0
</p>

<ul>
<li><p> irisNetrc definition moved inside getDataselect function
</p>
</li>
<li><p> restored getTimeseries function 
</p>
</li>
<li><p> default values for class Trace InstrumentSensitivity and SensitivityFrequency changed to NA from 1.0 
</p>
</li>
<li><p> added transferFunctionSpectra function 
</p>
</li></ul>

<p>version 1.5.2
</p>

<ul>
<li><p> updated getDataAvailablity to use new fdsnws availability web service specification
http://service.iris.edu/fdsnws/availability/1/ 
</p>
</li>
<li><p> fixed bug in getDataAvailability when mergequality=FALSE 
</p>
</li>
<li><p> fixed bug in getDataAvailability affecting start/end times, introduced in version 1.5.1 
</p>
</li>
<li><p>fixed bug in mergeTraces when trace has gap at end, introduced in version 1.5.1
</p>
</li></ul>

<p>version 1.5.1
</p>

<ul>
<li><p> changed a subset of time format OS to OS6
</p>
</li>
<li><p> fixed bug in mergeTraces when fdsnws/dataselect implementation cuts
on records instead of sample 
</p>
</li></ul>

<p>version 1.5.0
</p>

<ul>
<li><p> added spacing as an option to getEvalresp 
</p>
</li>
<li><p> modified getEvalresp to use IrisClient service_type 
</p>
</li>
<li><p> new getDataAvailability() to return dataframe of
miniseed data extents in the IRIS archive using 
IRIS web service http://service.iris.edu/irisws/availability/1/ 
</p>
</li>
<li><p> minor change to src code to pass CRAN checks  
</p>
</li></ul>

<p>version 1.4.9
</p>

<ul>
<li><p> additional error handling 
</p>
</li>
<li><p> minor updates to the plot.Trace and plot.Stream functions 
</p>
</li>
<li><p> updated src/libmseed to version 2.19.6 
</p>
</li></ul>

<p>version 1.4.8
</p>

<ul>
<li><p> updated src/libmseed to version 2.19.5 
</p>
</li>
<li><p> fix bug related to leap seconds 
</p>
</li>
<li><p> functions that call web services now follow redirects 
</p>
</li>
<li><p> some error outputs have changed slightly 
</p>
</li>
<li><p> rmsVariance function, na.rm=TRUE calculates data length minus NA values 
</p>
</li>
<li><p> rmsVariance.Stream now honors na.rm=TRUE 
</p>
</li>
<li><p> getGaps() error handling now checks for negative sample rates 
</p>
</li>
<li><p> getEvent, getEvalresp now truncates start and end input times to seconds 
(time format OS0 instead of OS) to fix error when user set options(digits.secs=) &gt; 3  
</p>
</li></ul>

<p>version 1.4.7
</p>

<ul>
<li><p> additional error handling for getDistaz 
</p>
</li>
<li><p> added input service_type to IrisClient, defaults to fdsnws
</p>
</li>
<li><p> plot.Trace x-axis labels are &quot;MM dd&quot; instead of days of week for traces &gt; 1 day and &lt; 1 week
</p>
</li>
<li><p> getDataselect will retry once if it encounters http code 401
</p>
</li>
<li><p> additional error handling for spectralUtils 
</p>
</li></ul>

<p>version 1.4.6
</p>

<ul>
<li><p>bug fix for IRISSeismic::slice
</p>
</li></ul>

<p>version 1.4.5
</p>

<ul>
<li><p>fixed bug in noiseModels for low noise model results at periods &gt; 10000 seconds
</p>
</li>
<li><p>retry if getEvent returns a service unavailable message
</p>
</li></ul>

<p>version 1.4.4
</p>

<ul>
<li><p>modified error messages for getEvalresp() and getDistaz()
</p>
</li></ul>

<p>version 1.4.3
</p>

<ul>
<li><p>changed getEvent default url from http://earthquake.usgs.gov/fdsnws/event/1/ to https://earthquake.usgs.gov/fdsnws/event/1/
</p>
</li></ul>

<p>version 1.4.2
</p>

<ul>
<li><p>updated libmseed version to 2.19
</p>
</li></ul>

<p>version 1.4.1
</p>

<ul>
<li><p>updated libmseed version to 2.18
</p>
</li>
<li><p>fix for reading miniseed with out of order records
</p>
</li></ul>

<p>version 1.4.0
</p>

<ul>
<li><p>addition of repository argument to getDataselect and getSNCL, to match change in fdsnws-dataselect web service
</p>
</li></ul>

<p>version 1.3.9
</p>

<ul>
<li><p>fixes compile warning generated by clang
</p>
</li>
<li><p>removes followlocation=TRUE from getDataselect RCurl options
</p>
</li></ul>

<p>version 1.3.8
</p>

<ul>
<li><p><code>getDataselect</code> does not add a quality indicator to url by default. IRIS webservices itself defaults to quality=&quot;M&quot;
</p>
</li>
<li><p><code>getStation</code> and <code>getChannel</code> do not add includerestricted indicator to url by default. IRIS webservices itself defaults to <code>TRUE</code>
</p>
</li>
<li><p>better handling of textConnections
</p>
</li></ul>

<p>version 1.3.7
</p>

<ul>
<li><p>users can now supply instrument response information in the form of frequency, amplitude, phase
to the functions <code>psdStatistics</code>, <code>psdList2NoiseMatrix</code>, <code>psdPlot</code>, 
in place of the getEvalresp webservice call. Function argument order for <code>psdPlot</code> is changed.
</p>
</li>
<li><p>added <code>showMedian</code> option to <code>psdPlot</code>
</p>
</li></ul>

<p>version 1.3.5 
</p>

<ul>
<li><p>added ignoreEpoch option to getDataselect
</p>
</li></ul>

<p>version 1.3.4 &ndash; webservices and plotting
</p>

<ul>
<li><p><code>getEvent</code> forwards http://service.iris.edu/fdsnws/event/1/ calls to http://earthquake.usgs.gov/fdsnws/event/1/
</p>
</li>
<li><p><code>getDistaz</code> changes output dataframe column name ellipsoid..attrs to ellipsoid.name
</p>
</li>
<li><p><code>plot.Trace</code> allows for user supplied ylab and xlab input
</p>
</li></ul>

<p>version 1.3.3 &ndash; documentation
</p>

<ul>
<li><p>Updated documentation and corrected outdated links
</p>
</li></ul>

<p>version 1.3.2 &ndash; bug fix
</p>

<ul>
<li><p>noiseModels(), minor correction to the New High Noise Model
</p>
</li></ul>

<p>version 1.3.1 &ndash; bug fixes
</p>

<ul>
<li><p>psdStatistics() correctly handles NA values when calculating high and low PDF bin limits
and returns pct_above and pct_below vectors of correct length
</p>
</li></ul>

<p>version 1.3.0 &ndash; compatibility with IRIS webservices
</p>

<ul>
<li><p>getDistaz() returns new variables from output of http://services.iris.edu/irisws/distaz/1/
</p>
</li></ul>

<p>version 1.2.2 &ndash; PDF bug fix
</p>

<ul>
<li><p>psdList2NoiseMatrix() adds 1 second to start time in getEvalresp call to work around a quirk in http://services.iris.edu/irisws/evalresp/1/ 
webservice that will not return a response if the start time is exactly on a metadata epoch boundary.
</p>
</li></ul>

<p>version 1.2.1 &ndash; PDF
</p>

<ul>
<li><p>psdPlot() now compatible with changes to psdStatistics() in previous version. Adds ylo, yhi arguments to customize y-axis limits in plot.
</p>
</li></ul>

<p>version 1.2.0 &ndash; PDF
</p>

<ul>
<li><p>psdStatistics() changes method of setting PDF bins from fixed values to bins based on the high and low PSD values 
and shifts bin centers by 0.5 dB. The result now matches output from http://services.iris.edu/mustang/noise-pdf.
</p>
</li></ul>

<p>verison 1.1.7 &ndash; improved error handling
</p>

<ul>
<li><p>getDataselect(), getNetwork(),  getStation(), getChannel(), getAvailability(), getEvalresp(), getTraveltime() error handling 
now report unexpected http status codes.
</p>
</li></ul>

<p>version 1.1.6 &ndash; bug fixes
</p>

<ul>
<li><p>getGaps() fixes issues with multiple sample rates and setting minimum gap length.
</p>
</li>
<li><p>mergeTraces.Stream() relaxes criteria for acceptable sample rate jitter.
</p>
</li></ul>

<p>version 1.1.5 &ndash; trace rotation
</p>

<ul>
<li><p>rotate2D() changes orthogonality test tolerance from 5 degrees to 3 degrees.
</p>
</li></ul>

<p>version 1.1.4 &ndash; trace rotation
</p>

<ul>
<li><p>rotate2D() exits if traces are not orthogonal.
</p>
</li></ul>

<p>version 1.1.3 &ndash; bug fix
</p>

<ul>
<li><p>psdStatistics() fixes bug in calculation of pct_above and pct_below.
</p>
</li></ul>

<p>version 1.1.1 &ndash; bug fixes
</p>

<ul>
<li><p>getGaps() minor bug fix.
</p>
</li>
<li><p>mergeTraces.Stream() minor bug fix.
</p>
</li></ul>

<p>version 1.0.10 &ndash; new data request argument and bug fixes
</p>

<ul>
<li><p>Imports seismicRoll (&gt;= 1.1.0).
</p>
</li>
<li><p>getGaps() fixes bugs in calculation of initial and final gap of Trace.
</p>
</li>
<li><p>getDataselect(), getSNCL() adds &quot;inclusiveEnd&quot; argument, a logical that determines whether a data point that falls exactly on the requested endtime 
is included in the Trace.
</p>
</li>
<li><p>libmseed change, when multiple sample rates exist in miniseed records use the mode of all sample rates instead of using the sample rate in the first record.
</p>
</li>
<li><p>psdList() added rule for octave generation for channel codes that start with &quot;V&quot;.
</p>
</li></ul>

<p>version 1.0.9 &ndash; Trace class expansion and bug fixes
</p>

<ul>
<li><p>Improved error handling for getAvailability(), getChannel(), getDataselect(), getEvalresp(), miniseed2Stream().
</p>
</li>
<li><p>parseMiniSEED.c, unpackdata.c  updated. Fixes protection stack overflow issue.
</p>
</li>
<li><p>getGaps() includes a 0.5/sampling_rate tolerance factor.
</p>
</li>
<li><p>miniseed2Stream() uses endtime from parseMiniSEED instead of calculating from the sample rate.
</p>
</li>
<li><p>Trace class now contains slots for optional metadata &quot;latitude&quot;, &quot;longitude&quot;, &quot;elevation&quot;, &quot;depth&quot;, &quot;azimuth&quot;, &quot;dip&quot;, &quot;SensitivityFrequency&quot;.
</p>
</li>
<li><p>rotate2D() uses Trace class &quot;azimuth&quot; slot information to identify channel orientation before rotation instead of assuming lead and lag channel 
from trace input order.
</p>
</li></ul>

<p>version 1.0.8 &ndash; fixes required by ISPAQ
</p>

<ul>
<li><p>Removed 'maps' and 'mapdata' from Suggested: packages.
</p>
</li>
<li><p>Changed URL syntax for FDSN web services to use &quot;format=...&quot; instead of &quot;output=...&quot;.
</p>
</li>
<li><p>Fixed bug in getSNCL() so that it works when the &quot;quality&quot; argument is missing.
</p>
</li></ul>

<p>version 1.0.6 &ndash; CRAN updates required
</p>

<ul>
<li><p>Removed &quot;mode&quot; argument form Trace.as.vector() signature.
</p>
</li></ul>

<p>version 1.0.4 &ndash; name change to IRISSeismic
</p>

<ul>
<li><p>Name change required because 'seismic' was recently taken.
</p>
</li>
<li><p>Using explicit references for 'utils' and 'stats' package functions as this is now required for CRAN.
</p>
</li></ul>

<p>version 1.0.3 &ndash; cleanup for submission to CRAN
</p>

<ul>
<li><p>Updated libmseed to version 2.16
</p>
</li></ul>

<p>version 0.2.8.0 &ndash; minor tweaks to 0.2.7
</p>

<ul>
<li><p>Updated links to IRIS web services in the documentation.
</p>
</li>
<li><p>McNamaraBins() ignores bin #0 (~= DC)
</p>
</li>
<li><p>McNamaraPSD() conversion to dB occurs <strong>after</strong> binning, not before
</p>
</li></ul>

<p>version 0.2.7.0 &ndash; hilbert transform
</p>

<ul>
<li><p>New hilbertFFT() function.
</p>
</li>
<li><p>New hilbert() trace method.
</p>
</li></ul>

<p>version 0.2.6.0 &ndash; cross correlation
</p>

<ul>
<li><p>Added surfaceDistance() function.
</p>
</li>
<li><p>Added rotate2D() function.
</p>
</li></ul>

<p>version 0.2.5.0 &ndash; channel orientation
</p>

<ul>
<li><p>Jumping to version 0.2.5 to match project milestone names.
</p>
</li>
<li><p>Added getSNCL() convenience wrapper for getDataselect() method.
</p>
</li>
<li><p>Added getDistaz() method of IrisClient.
</p>
</li>
<li><p>Added miniseed2Stream() and readMiniseedFile() functions.
</p>
</li>
<li><p>Added getRotation() method of IrisClient.
</p>
</li></ul>

<p>version 0.2.3.0 &ndash; cross spectrum
</p>

<ul>
<li><p>Moved McNamaraPSD() from trace method to spectral utility function.
</p>
</li>
<li><p>Added spectral utility functions:
</p>

<ul>
<li><p>crossSpectrum()
</p>
</li>
<li><p>McNamaraBins()
</p>
</li></ul>


</li>
<li><p>All get~ methods that return dataframes now guarantee a default ordering of rows.
</p>
</li></ul>

<p>version 0.2.2.0 &ndash; PSD and friends
</p>

<ul>
<li><p>Add dependency on pracma package.
</p>
</li>
<li><p>Use pracma::detrend() function in DDT.Trace().
</p>
</li>
<li><p>Added &quot;increment&quot; parameter to STALTA.Trace().
</p>
</li>
<li><p>Removed STALTA.Trace() algorithm &quot;classic_LR2&quot;.
</p>
</li>
<li><p>Fixed URL generation for getEvalresp() when location=&quot;&quot;.
</p>
</li>
<li><p>Added NamaraPSD.Trace() method.
</p>
</li>
<li><p>Added PSD/PDF utility functions:
</p>

<ul>
<li><p>noiseMatrix2PdfMatrix()
</p>
</li>
<li><p>noiseModels()
</p>
</li>
<li><p>psdDF2NoiseMatrix()
</p>
</li>
<li><p>psdList()
</p>
</li>
<li><p>psdList2NoiseMatrix()
</p>
</li>
<li><p>psdStatistics()
</p>
</li>
<li><p>psdPlot()
</p>
</li></ul>


</li></ul>

<p>version 0.2.1.1 &ndash; Bug fix release
</p>

<ul>
<li><p>Removed dependcy on signal, XML packages.
</p>
</li></ul>

<p>version 0.2.1.0 &ndash; FDSN web services
</p>

<ul>
<li><p>Conversion to FDSN web services including the following new/rewritten methods:
<code>getNetwork</code>, <code>getStation</code>, <code>getChannel</code>, <code>getAvailability</code>, <code>getUnavailability</code>
</p>
</li>
<li><p>Updated version of <code>getEvent</code> to return a dataframe with columns named &quot;latitude&quot; and &quot;longitude&quot;
for consistency with all other web services
</p>
</li>
<li><p>Updated documentation and Rscripts to match the API changes in the conversion to FDSN web services.
</p>
</li>
<li><p>Removal of all <code>StationXML</code> classes in favor of storing that information in slots of the <code>Trace</code> class.
</p>
</li>
<li><p>Updates to <code>Trace</code> object slots <code>@Sensor</code>, <code>@InstrumentSensitivity</code> and <code>@InputUnits</code>
to store information as <code>character</code>, <code>numeric</code> and <code>character</code> instead of <code>StationXML</code> classes.
</p>
</li>
<li><p>The <code>TraceHeader@quality</code> slot now reflects the data quality returned in the miniSEED record
rather than the quality that was requested by getDataselect. (Requests with <code>quality=B</code> for &quot;Best&quot; typically return
<code>quality=M</code>.)
</p>
</li>
<li><p>Improved <code>STALTA.Trace()</code> method removes experimental algorithms and now uses C++ code from package 
<code>rollSeismic</code> to calculate rolling means.
</p>
</li>
<li><p>Updated <code>IrisClient</code> now uses web services from <a href="http://service.iris.edu">http://service.iris.edu</a> for the following methods:
<code>getDataselect</code>, <code>getEvalresp</code>, <code>getEvent</code>
</p>
</li></ul>

<p>version 0.2.0.0
</p>

<ul>
<li><p>Removed PSD methods of <code>Stream</code> and <code>Trace</code>. PSD algorithms are now part of the PSD metric.
</p>
</li>
<li><p>Improved <code>mergeTraces.Stream()</code> method now accepts <code>fillMethod="fillZero"</code>.
</p>
</li></ul>

<p>version 0.1.9.0 
</p>

<ul>
<li><p>New <span class="pkg">rollSeismic</span> package for fast rolling algorithms implemented in C++/Rcpp.
</p>
</li>
<li><p>New <code>num_spikes</code> metric based on <code>seismicRoll::roll_hampel</code> outlier detection.
</p>
</li>
<li><p>New <code>correlation</code> metric.
</p>
</li>
<li><p>New scripts <code>glitchMetrics.Rscript</code>, <code>correlationMetric.Rscript</code>, <code>pressureCorrelation.Rscript</code>
</p>
</li>
<li><p>New <code>trace@stats@processing</code> slot for data processing information.
</p>
</li>
<li><p>New <code>Stream</code> methods: <code>mergeTraces</code>, <code>plot</code>
</p>
</li>
<li><p>Improved <code>getGaps.Stream()</code> method properly handles initial and final gaps.
</p>
</li>
<li><p>Improved MCR error messing.
</p>
</li></ul>

<p>version 0.1.8.0 &ndash; IrisClient methods getEvent and getTraveltime, improved SNR metric
</p>
<p>version 0.1.7.0 &ndash; PSD
</p>
<p>version 0.1.6.0 &ndash; improved errors, miniSEED parser
</p>
<p>version 0.1.5.0 &ndash; code cleanup, improved errors, package vignette
</p>
<p>version 0.1.4.0 &ndash; STA/LTA, upDownTimes, basic plotting
</p>
<p>version 0.1.3.0 &ndash; SNR, memory profiling
</p>
<p>version 0.1.2.0 &ndash; ...
</p>
<p>version 0.1.1.0 &ndash; ...
</p>


<h3>Author(s)</h3>

<p>Jonathan Callahan <a href="mailto:jonathan@mazamascience.com">jonathan@mazamascience.com</a>
</p>


<h3>References</h3>

<p>ObsPy: <a href="http://obspy.org/">http://obspy.org/</a>
</p>
<p>IRIS DMC web services: <a href="https://service.iris.edu/">https://service.iris.edu/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IrisClient-class">IrisClient-class</a></code>, 
<code><a href="#topic+Trace-class">Trace-class</a></code>, 
<code><a href="#topic+Stream-class">Stream-class</a></code>, 
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Open a connection to IRIS DMC webservices
iris &lt;- new("IrisClient", debug=TRUE)

starttime &lt;- as.POSIXct("2010-02-27 06:45:00", tz="GMT")
endtime &lt;- as.POSIXct("2010-02-27 07:45:00", tz="GMT")

# Get the seismic data
result &lt;- try(st &lt;- getDataselect(iris,"IU","ANMO","00","BHZ",starttime,endtime))
if (inherits(result,"try-error")) {
  message(geterrmessage())
} else {

# Extract the first trace, display the metadata and plot it
  tr1 &lt;- st@traces[[1]]
  show(tr1@stats)
  plot(tr1)
}
</code></pre>

<hr>
<h2 id='basicStats'>Length, Max, Mean, Median, Min and Standard Deviation</h2><span id='topic+length'></span><span id='topic+max'></span><span id='topic+mean'></span><span id='topic+median'></span><span id='topic+min'></span><span id='topic+sd'></span><span id='topic+length+2CTrace-method'></span><span id='topic+max+2CTrace-method'></span><span id='topic+mean+2CTrace-method'></span><span id='topic+median+2CTrace+2Clogical-method'></span><span id='topic+median+2CTrace+2Cmissing-method'></span><span id='topic+min+2CTrace-method'></span><span id='topic+sd+2CTrace+2Clogical-method'></span><span id='topic+sd+2CTrace+2Cmissing-method'></span><span id='topic+length+2CStream-method'></span><span id='topic+max+2CStream-method'></span><span id='topic+mean+2CStream-method'></span><span id='topic+median+2CStream+2Clogical-method'></span><span id='topic+median+2CStream+2Cmissing-method'></span><span id='topic+min+2CStream-method'></span><span id='topic+rms+2CStream+2Clogical-method'></span><span id='topic+rms+2CStream+2Cmissing-method'></span><span id='topic+rmsVariance+2CStream+2Clogical-method'></span><span id='topic+rmsVariance+2CStream+2Cmissing-method'></span><span id='topic+sd+2CStream+2Clogical-method'></span><span id='topic+sd+2CStream+2Cmissing-method'></span><span id='topic+parallelLength'></span><span id='topic+parallelMax'></span><span id='topic+parallelMean'></span><span id='topic+parallelMedian'></span><span id='topic+parallelMin'></span><span id='topic+parallelSd'></span><span id='topic+parallelLength+2CStream-method'></span><span id='topic+parallelMax+2CStream+2Clogical-method'></span><span id='topic+parallelMax+2CStream+2Cmissing-method'></span><span id='topic+parallelMean+2CStream+2Clogical-method'></span><span id='topic+parallelMean+2CStream+2Cmissing-method'></span><span id='topic+parallelMedian+2CStream+2Clogical-method'></span><span id='topic+parallelMedian+2CStream+2Cmissing-method'></span><span id='topic+parallelMin+2CStream+2Clogical-method'></span><span id='topic+parallelMin+2CStream+2Cmissing-method'></span><span id='topic+parallelRmsVariance+2CStream+2Clogical-method'></span><span id='topic+parallelRmsVariance+2CStream+2Cmissing-method'></span><span id='topic+parallelSd+2CStream+2Clogical-method'></span><span id='topic+parallelSd+2CStream+2Cmissing-method'></span>

<h3>Description</h3>

<p>Basic statistics on the data in <code>Trace</code> and <code>Stream</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># length(x)
# max(x, ...)
mean(x, ...)
# median(x, na.rm)
# min(x, ...)
sd(x, na.rm)
parallelLength(x)
parallelMax(x, na.rm)
parallelMean(x, na.rm)
parallelMedian(x, na.rm)
parallelMin(x, na.rm)
parallelSd(x, na.rm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="basicStats_+3A_x">x</code></td>
<td>
<p>a <code>Trace</code> or <code>Stream</code> object </p>
</td></tr>
<tr><td><code id="basicStats_+3A_na.rm">na.rm</code></td>
<td>
<p> a logical specifying whether missing values should be removed </p>
</td></tr>
<tr><td><code id="basicStats_+3A_...">...</code></td>
<td>
<p> arguments to be passed to underlying methods, e.g. the <code>mean</code> function:
</p>

<ul>
<li><p><code>na.rm</code> &ndash; as above (default=<code>FALSE</code>) 
</p>
</li></ul>

</td></tr>
</table>


<h3>Details</h3>

<p><b>Trace methods</b>
</p>
<p>When <code>x</code> is a <code>Trace</code> object, methods <code>length</code>, <code>max</code>, <code>mean</code>, <code>median</code>,
<code>min</code> and <code>sd</code> operate on the <code>data</code> slot of the <code>Trace</code> and are 
equivalent to, e.g., <code>max(x@data, na.rm=FALSE)</code>.
</p>
<p><b>Stream methods</b>
</p>
<p>When <code>x</code> is a <code>Stream</code> object, methods <code>length</code>, <code>max</code>, <code>mean</code>, <code>median</code>,
<code>min</code> and <code>sd</code> are applied to the concatenation of data from every 
<code>Trace</code> in the <code>Stream</code>, treating this as a single data series.
</p>
<p>The <code>parallel~</code> versions of these methods are available only on <code>Stream</code> objects
and return a vector of values, one for each <code>Trace</code>.
</p>
<p>By default, the <code>Stream-method</code> versions of these methods use <code>na.rm=FALSE</code> as there
should be no missing datapoints in each <code>Trace</code>. The <code>Trace</code> methods default to 
<code>na.rm=TRUE</code> to accommodate merged traces where gaps have been filled with <code>NA</code>s.
</p>


<h3>Value</h3>

<p>For the simple statistics, a single numeric value is returned or <code>NA</code> if the <code>Trace</code> or <code>Stream</code>
has no data.
</p>
<p>For the <code>parallel~</code> versions of these methods, available on <code>Stream</code> objects,
a numeric vector is returned of the same length as <code>Stream@traces</code>.
</p>


<h3>Note</h3>

<p>See the R documentation on the respective base functions for further details.
</p>
<p>The <code>length.Stream</code> method only counts the number of actual data values in the individual
<code>Traces</code> in the <code>Stream</code> object. Missing values associated with the gaps
between <code>Traces</code> are not counted.
</p>


<h3>Author(s)</h3>

<p>Jonathan Callahan <a href="mailto:jonathan@mazamascience.com">jonathan@mazamascience.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Open a connection to IRIS DMC webservices
iris &lt;- new("IrisClient")

starttime &lt;- as.POSIXct("2012-01-24", tz="GMT")
endtime &lt;- as.POSIXct("2012-01-25", tz="GMT")

# Get the waveform
st &lt;- getDataselect(iris,"AK","PIN","","BHZ",starttime,endtime)

# Get the first trace and generate some statistics
tr1 &lt;- st@traces[[1]]
length(tr1)
max(tr1)
mean(tr1)
sd(tr1)

## End(Not run)
</code></pre>

<hr>
<h2 id='butterworth'>Apply Butterworth filter</h2><span id='topic+butterworth'></span><span id='topic+butterworth+2CTrace+2Cnumeric+2Cmissing+2Cnumeric+2Cmissing-method'></span><span id='topic+butterworth+2CTrace+2Cnumeric+2Cnumeric+2Cmissing+2Cmissing-method'></span><span id='topic+butterworth+2CTrace+2Cnumeric+2Cnumeric+2Cnumeric+2Ccharacter-method'></span><span id='topic+butterworth+2CTrace+2Cnumeric+2Cnumeric+2Cnumeric+2Cmissing-method'></span>

<h3>Description</h3>

<p>The <code>butterworth</code> method of <code>Trace</code> objects returns a new <code>Trace</code>
where data in the <code>@data</code> slot have been modified by applying a Butterworth filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>butterworth(x, n, low, high, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="butterworth_+3A_x">x</code></td>
<td>
<p>a <code>Trace</code> object</p>
</td></tr>
<tr><td><code id="butterworth_+3A_n">n</code></td>
<td>
<p>filter order</p>
</td></tr>
<tr><td><code id="butterworth_+3A_low">low</code></td>
<td>
<p>frequency used in low- or stop/band-pass filters</p>
</td></tr>
<tr><td><code id="butterworth_+3A_high">high</code></td>
<td>
<p>frequency used in high or stop/band-pass filters</p>
</td></tr>
<tr><td><code id="butterworth_+3A_type">type</code></td>
<td>
<p>type of filter &ndash; <code>'low', 'high', 'pass'</code> or <code>'stop'</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method creates a Butterworth filter with the specified characteristics and applies
it to the Trace data.
</p>
<p>When only <code>n</code> and <code>low</code> are specified, a high pass filter is applied.
When only <code>n</code> and <code>high</code> are specified, a low pass filter is applied.
When <code>n</code> and both <code>low</code> and <code>high</code> are specified, a band pass filter is applied.
To apply a band stop filter you must specify <code>n</code>, <code>low</code>, <code>high</code> and <code>type='stop'</code>
</p>


<h3>Value</h3>

<p>A new <code>Trace</code> object is returned.
</p>


<h3>Author(s)</h3>

<p>Jonathan Callahan <a href="mailto:jonathan@mazamascience.com">jonathan@mazamascience.com</a>
</p>


<h3>See Also</h3>

<p>signal::butter, signal::filter
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Open a connection to IRIS DMC webservices
iris &lt;- new("IrisClient")

# Compare to the results in figure 2a of
#
# "Determination of New Zealand Ocean Bottom Seismometer Orientation
#  via Rayleigh-Wave Polarization", Stachnik et al. 
#
# http://srl.geoscienceworld.org/content/83/4/704
#
# (note: since publication, ZU.NZ19..BH1 has been renamed BH2 and ZU.NZ19..BH2 has been renamed BH1)

starttime &lt;- as.POSIXct("2009-02-18 22:01:07",tz="GMT")
endtime &lt;- starttime + 630
verticalLines &lt;- starttime + seq(30,630,100)

# Get data
stZ &lt;- getSNCL(iris,"ZU.NZ19..BHZ",starttime,endtime)
st2 &lt;- getSNCL(iris,"ZU.NZ19..BH2",starttime,endtime)
st1 &lt;- getSNCL(iris,"ZU.NZ19..BH1",starttime,endtime)

# Demean, Detrend, Taper
trZ &lt;- DDT(stZ@traces[[1]],TRUE,TRUE,0.05)
tr2 &lt;- DDT(st2@traces[[1]],TRUE,TRUE,0.05)
tr1 &lt;- DDT(st1@traces[[1]],TRUE,TRUE,0.05)

# Bandpass filter
trZ_f &lt;- butterworth(trZ,2,0.02,0.04,type='pass')
tr2_f &lt;- butterworth(tr2,2,0.02,0.04,type='pass')
tr1_f &lt;- butterworth(tr1,2,0.02,0.04,type='pass')

# 3 rows
layout(matrix(seq(3)))

# Plot
plot(trZ_f)
abline(v=verticalLines,col='gray50',lty=2)
plot(tr2_f)
abline(v=verticalLines,col='gray50',lty=2)
plot(tr1_f)
abline(v=verticalLines,col='gray50',lty=2)

# Restore default layout
layout(1)

## End(Not run)
</code></pre>

<hr>
<h2 id='crossSpectrum'>Cross-Spectral Analysis</h2><span id='topic+crossSpectrum'></span>

<h3>Description</h3>

<p>The crossSpectrum() function is based on <span class="rlang"><b>R</b></span>'s spec.pgram() function and attempts to provide
complete results of cross-spectral FFT analysis in a programmer-friendly fashion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crossSpectrum(x, spans = NULL, kernel = NULL, taper = 0.1,
                           pad = 0, fast = TRUE,
                           demean = FALSE, detrend = TRUE,
                           na.action = stats::na.fail)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crossSpectrum_+3A_x">x</code></td>
<td>
<p>multivariate time series</p>
</td></tr>
<tr><td><code id="crossSpectrum_+3A_spans">spans</code></td>
<td>
<p>vector of odd integers giving the widths of modified Daniell smoothers to be used to smooth the periodogram</p>
</td></tr>
<tr><td><code id="crossSpectrum_+3A_kernel">kernel</code></td>
<td>
<p>alternatively, a kernel smoother of class &quot;tskernel&quot;</p>
</td></tr>
<tr><td><code id="crossSpectrum_+3A_taper">taper</code></td>
<td>
<p>specifies the proportion of data to taper. A split cosine bell taper is applied to this proportion of the data at the beginning and end of the series</p>
</td></tr>
<tr><td><code id="crossSpectrum_+3A_pad">pad</code></td>
<td>
<p>proportion of data to pad. Zeros are added to the end of the series to increase its length by the proportion pad</p>
</td></tr>
<tr><td><code id="crossSpectrum_+3A_fast">fast</code></td>
<td>
<p>logical. if TRUE, pad the series to a highly composite length</p>
</td></tr>
<tr><td><code id="crossSpectrum_+3A_demean">demean</code></td>
<td>
<p>logical. If TRUE, subtract the mean of the series</p>
</td></tr>
<tr><td><code id="crossSpectrum_+3A_detrend">detrend</code></td>
<td>
<p>logical. If TRUE, remove a linear trend from the series. This will also remove the mean</p>
</td></tr>
<tr><td><code id="crossSpectrum_+3A_na.action">na.action</code></td>
<td>
<p>NA action function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The multivariate timeseries passed in as the first argument should be a union of two separate timeseries with the same sampling rate created in the following manner:
</p>
<pre>
  ts1 &lt;- ts(data1,frequency=sampling_rate)
  ts2 &lt;- ts(data2,frequency=sampling_rate)
  x &lt;- ts.union(ts1,ts2)
</pre>
<p>The crossSpectrum() function borrows most of its code from <span class="rlang"><b>R</b></span>'s spec.pgram() function. It omits any plotting
functionality and returns a programmer-friendly dataframe of all cross-spectral components generated during
Fourier analysis for use in calculating transfer functions.
</p>
<p>The naming of cross-spectral components is borrowed from the Octave version of MATLAB's pwelch() function.
</p>


<h3>Value</h3>

<p>A dataframe with the following columns:
</p>
<table>
<tr><td><code>freq</code></td>
<td>
<p>spectral frequencies</p>
</td></tr>
<tr><td><code>spec1</code></td>
<td>
<p>'two-sided' spectral amplitudes for ts1</p>
</td></tr>
<tr><td><code>spec2</code></td>
<td>
<p>'two-sided' spectral amplitudes for ts2</p>
</td></tr>
<tr><td><code>coh</code></td>
<td>
<p>magnitude squared coherence between ts1 and ts2</p>
</td></tr>
<tr><td><code>phase</code></td>
<td>
<p>cross-spectral phase between ts1 and ts2</p>
</td></tr>
<tr><td><code>Pxx</code></td>
<td>
<p>periodogram for ts1</p>
</td></tr>
<tr><td><code>Pyy</code></td>
<td>
<p>periodogram for ts2</p>
</td></tr>
<tr><td><code>Pxy</code></td>
<td>
<p>cross-periodogram for ts1 and ts2</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan Callahan <a href="mailto:jonathan@mazamascience.com">jonathan@mazamascience.com</a>
</p>


<h3>References</h3>

<p><a href="https://sourceforge.net/p/octave/signal/ci/default/tree/inst/pwelch.m">Octave pwelch() source code</a>
</p>
<p><a href="https://CRAN.R-project.org/package=psd/vignettes/normalization.pdf">Normalization of Power Spectral Density estimates</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+McNamaraPSD">McNamaraPSD</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Create a new IrisClient
iris &lt;- new("IrisClient")

# Get seismic data
starttime &lt;- as.POSIXct("2011-05-01", tz="GMT")
endtime &lt;- starttime + 3600

st1 &lt;- getDataselect(iris,"CI","PASC","00","BHZ",starttime,endtime)
st2 &lt;- getDataselect(iris,"CI","PASC","10","BHZ",starttime,endtime)
tr1 &lt;- st1@traces[[1]]
tr2 &lt;- st2@traces[[1]]

# Both traces have a sampling rate of 40 Hz
sampling_rate &lt;- tr1@stats@sampling_rate

ts1 &lt;- ts(tr1@data,frequency=sampling_rate)
ts2 &lt;- ts(tr2@data,frequency=sampling_rate)

# Calculate the cross spectrum
DF &lt;- crossSpectrum(ts.union(ts1,ts2),spans=c(3,5,7,9))

# Calculate the transfer function
transferFunction &lt;- DF$Pxy / DF$Pxx
transferAmp &lt;- Mod(transferFunction)
transferPhase &lt;- pracma::mod(Arg(transferFunction) * 180/pi,360)

# 2 rows
layout(matrix(seq(2)))

# Plot
plot(1/DF$freq,transferAmp,type='l',log='x',
     xlab="Period (sec)",
     main="Transfer Function Amplitude")

plot(1/DF$freq,transferPhase,type='l',log='x',
     xlab="Period (sec)", ylab="degrees",
     main="Transfer Function Phase")

# Restore default layout
layout(1)

## End(Not run)
</code></pre>

<hr>
<h2 id='DDT'>Apply demean, detrend, cosine taper</h2><span id='topic+DDT'></span><span id='topic+DDT+2CTrace+2Clogical+2Clogical+2Cnumeric-method'></span><span id='topic+DDT+2CTrace+2Cmissing+2Cmissing+2Cmissing-method'></span>

<h3>Description</h3>

<p>The <code>DDT</code> method of <code>Trace</code> objects returns a new <code>Trace</code>
where data in the <code>@data</code> slot have been modified.  This is typically required before 
peforming any kind of spectral analysis on the seismic trace.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DDT(x, demean, detrend, taper)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DDT_+3A_x">x</code></td>
<td>
<p>a <code>Trace</code> object</p>
</td></tr>
<tr><td><code id="DDT_+3A_demean">demean</code></td>
<td>
<p>logical specifying whether to deman (default=<code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="DDT_+3A_detrend">detrend</code></td>
<td>
<p>logical specifying whether to detrend (default=<code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="DDT_+3A_taper">taper</code></td>
<td>
<p>proportion of the signal to be tapered at each end (default=0.1)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use <code>taper=0</code> for no tapering.
</p>


<h3>Value</h3>

<p>A new <code>Trace</code> object is returned.
</p>


<h3>Author(s)</h3>

<p>Jonathan Callahan <a href="mailto:jonathan@mazamascience.com">jonathan@mazamascience.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Open a connection to IRIS DMC webservices
iris &lt;- new("IrisClient")

# P-wave onset for a big quake
starttime &lt;- as.POSIXct("2010-02-27 06:30:00", tz="GMT")
endtime &lt;- as.POSIXct("2010-02-27 07:00:00", tz="GMT")
result &lt;- try(st &lt;- getDataselect(iris,"IU","ANMO","00","BHZ",starttime,endtime))
if (inherits(result,"try-error")) {
  message(geterrmessage())
} else {
  tr &lt;- st@traces[[1]]
  trClean &lt;- DDT(tr,TRUE,TRUE,0.1)
  layout(matrix(seq(2)))
  plot(tr)
  abline(h=0,col='gray60')
  mtext("Raw",side=3,line=-2,adj=0.05,col='red')
  plot(trClean)
  abline(h=0,col='gray60')
  mtext("Demean - Detrend - Cosine Taper",line=-2,side=3,adj=0.05,col='red')
}

# Restore default layout
layout(1)
</code></pre>

<hr>
<h2 id='envelope'>Envelope of a seismic signal</h2><span id='topic+envelope'></span><span id='topic+envelope+2CTrace-method'></span>

<h3>Description</h3>

<p>The <code>envelope</code> method of <code>Trace</code> objects returns a <code>Trace</code>
whose data have been replaced with the envelope of the seismic signal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>envelope(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="envelope_+3A_x">x</code></td>
<td>
<p>a <code>Trace</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Before calculating the envelope, the seismic trace is 'cleaned up' by removing the mean,
the trend and by applying a cosine taper.  See <a href="#topic+DDT">DDT</a> for more details.
</p>
<p>The seismic envelope is defined as:
</p>
<p style="text-align: center;"><code class="reqn"> E(t) = \sqrt{T^2(t) + H^2(t)} </code>
</p>

<p>where <code class="reqn">T(t)</code> is the seismic trace and <code class="reqn">H(t)</code> is the Hilbert transform of <code class="reqn">T(t)</code>.
</p>


<h3>Value</h3>

<p>A <code>Trace</code>
whose data have been replaced with the envelope of the seismic signal.
</p>


<h3>Note</h3>

<p>This algorithm is adapted from code in the <span class="pkg">seewave</span> package.
</p>


<h3>Author(s)</h3>

<p>Jonathan Callahan <a href="mailto:jonathan@mazamascience.com">jonathan@mazamascience.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Open a connection to IRIS DMC webservices
iris &lt;- new("IrisClient")

starttime &lt;- as.POSIXct("2010-02-27 06:00:00", tz="GMT")
endtime &lt;- as.POSIXct("2010-02-27 09:00:00", tz="GMT")

# Get the waveform
st &lt;- getDataselect(iris,"IU","ANMO","00","BHZ",starttime,endtime)
tr &lt;- st@traces[[1]]

# Demean, detrend, cosine taper
tr &lt;- DDT(tr)

# Create envelope version of the trace
trenv &lt;- envelope(tr)

# Plot signal data and envelope data
plot(tr@data, type='l', col='gray80')
points(trenv@data, type='l', col='blue')

## End(Not run)
</code></pre>

<hr>
<h2 id='eventWindow'>Return a portion of a trace surrounding an event.</h2><span id='topic+eventWindow'></span><span id='topic+eventWindow+2CTrace+2Cnumeric+2Cmissing+2Cmissing-method'></span><span id='topic+eventWindow+2CTrace+2Cnumeric+2Cmissing+2Cnumeric-method'></span><span id='topic+eventWindow+2CTrace+2Cnumeric+2Cnumeric+2Cmissing-method'></span><span id='topic+eventWindow+2CTrace+2Cnumeric+2Cnumeric+2Cnumeric-method'></span>

<h3>Description</h3>

<p>The <code>eventWindow</code> method of <code>Trace</code> uses the picker returned by the <code>STALTA()</code> method
to center a window around the the event detected by the picker.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eventWindow(x, picker, threshold, windowSecs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eventWindow_+3A_x">x</code></td>
<td>

<p>a <code>Trace</code> object
</p>
</td></tr>
<tr><td><code id="eventWindow_+3A_picker">picker</code></td>
<td>

<p>a picker as returned by the <code>STALTA()</code> method applied to this <code>Trace</code>
</p>
</td></tr>
<tr><td><code id="eventWindow_+3A_threshold">threshold</code></td>
<td>

<p>the threshold at which the picker is 'triggered'
</p>
</td></tr>
<tr><td><code id="eventWindow_+3A_windowsecs">windowSecs</code></td>
<td>

<p>the size of the window in secs
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This utility function uses the trace method <code>triggerOnset()</code> to determine
p-wave onset followed by the <code>slice()</code> method to return a new <code>Trace</code> object of
the desired size centered <em>near</em> the event onset.
</p>
<p>When no threshold value is supplied, the default value is calculated as:
</p>
<p><code>threshold=quantile(picker,0.999,na.rm=TRUE)</code>
</p>


<h3>Value</h3>

<p>A new <code>Trace</code> object is returned.
</p>


<h3>Author(s)</h3>

<p>Jonathan Callahan <a href="mailto:jonathan@mazamascience.com">jonathan@mazamascience.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+STALTA">STALTA</a></code>, 
<code><a href="#topic+triggerOnset">triggerOnset</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Open a connection to IRIS DMC webservices
iris &lt;- new("IrisClient")

starttime &lt;- as.POSIXct("2002-04-20", tz="GMT")
endtime &lt;- as.POSIXct("2002-04-21", tz="GMT")

# Get the waveform
st &lt;- getDataselect(iris,"US","OXF","","BHZ",starttime,endtime)

# Seismic signal in third trace
tr &lt;- st@traces[[3]]

# Create a picker
picker &lt;- STALTA(tr,3,30)
threshold &lt;- quantile(picker,0.99999,na.rm=TRUE)

# 3 rows
layout(matrix(seq(3)))

# Plot trace and p-wave closeups
closeup1 &lt;- eventWindow(tr,picker,threshold,3600)
closeup2 &lt;- eventWindow(tr,picker,threshold,600)
plot(tr)
plot(closeup1,subsampling=1)
abline(v=length(closeup1)/2, col='red')
plot(closeup2,subsampling=1)
abline(v=length(closeup2)/2, col='red')

# Restore default layout
layout(1)

## End(Not run)
</code></pre>

<hr>
<h2 id='getAvailability'>Retrieve Channel metadata from IRIS DMC</h2><span id='topic+getAvailability'></span><span id='topic+getAvailability+2CIrisClient+2Ccharacter+2Ccharacter+2Ccharacter+2Ccharacter+2CPOSIXct+2CPOSIXct+2Clogical-method'></span><span id='topic+getAvailability+2CIrisClient+2Ccharacter+2Ccharacter+2Ccharacter+2Ccharacter+2CPOSIXct+2CPOSIXct+2Cmissing-method'></span>

<h3>Description</h3>

<p>The <code>getAvailability</code> method obtains channel metadata for available channels from the IRIS DMC
<code>station</code> web service and returns it in a dataframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAvailability(obj, network, station, location, channel,
                starttime, endtime, includerestricted,
                latitude, longitude, minradius, maxradius)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getAvailability_+3A_obj">obj</code></td>
<td>
 <p><code>IrisClient</code> object </p>
</td></tr>
<tr><td><code id="getAvailability_+3A_network">network</code></td>
<td>
<p> character string with the two letter seismic network code </p>
</td></tr>
<tr><td><code id="getAvailability_+3A_station">station</code></td>
<td>
<p> character string with the station code </p>
</td></tr>
<tr><td><code id="getAvailability_+3A_location">location</code></td>
<td>
<p> character string with the location code </p>
</td></tr>
<tr><td><code id="getAvailability_+3A_channel">channel</code></td>
<td>
<p> character string with the three letter channel code </p>
</td></tr>
<tr><td><code id="getAvailability_+3A_starttime">starttime</code></td>
<td>
<p> POSIXct class specifying the starttime (GMT) </p>
</td></tr>
<tr><td><code id="getAvailability_+3A_endtime">endtime</code></td>
<td>
<p> POSIXct class specifying the endtime (GMT) </p>
</td></tr>
<tr><td><code id="getAvailability_+3A_includerestricted">includerestricted</code></td>
<td>
<p> optional logical identifying whether to report on restricted data (default=<code>FALSE</code>) </p>
</td></tr>
<tr><td><code id="getAvailability_+3A_latitude">latitude</code></td>
<td>
<p> optional latitude used when specifying a location and radius </p>
</td></tr>
<tr><td><code id="getAvailability_+3A_longitude">longitude</code></td>
<td>
<p> optional longitude used when specifying a location and radius </p>
</td></tr>
<tr><td><code id="getAvailability_+3A_minradius">minradius</code></td>
<td>
<p> optional minimum radius used when specifying a location and radius </p>
</td></tr>
<tr><td><code id="getAvailability_+3A_maxradius">maxradius</code></td>
<td>
<p> optional maximum radius used when specifying a location and radius </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>getAvailability</code> method uses the station web service to obtain data for all
available channels that meet the criteria defined by the arguments
and returns that data in a dataframe. Each row of the dataframe represents a unique channel-epoch. 
This method is equivalent to the <code>getChannel</code>
method with the following additional parameters attached to the url:
</p>
<pre>&amp;includeavailability=true&amp;matchtimeseries=true</pre>
<p>Each of the arguments <code>network</code>, <code>station</code>, <code>location</code> or <code>channel</code> may contain
a valid code or a wildcard expression, e.g. &quot;BH?&quot; or &quot;*&quot;. Empty strings are converted to &quot;*&quot;.
Otherwise the ascii string that is used for
these values is simply inserted into the web service request URL.
(For non-available channels use <code><a href="#topic+getUnavailability">getUnavailability</a></code>.)
</p>
<p>For more details see the <a href="https://service.iris.edu/fdsnws/station/1/">web service documentation</a>.
</p>


<h3>Value</h3>

<p>A dataframe with the following columns:
</p>
<pre>
network, station, location, channel, latitude, longitude, elevation,
  depth, azimuth, dip, instrument, scale, scalefreq, scaleunits, 
  samplerate, starttime, endtime, snclId
</pre>
<p>Rows are ordered by <code>snclId</code>.
</p>
<p>The snclId column, eg. &quot;US.OCWA..BHE&quot;, is generated as a convenience. It is not part of
the normal return from the station web service.
</p>
<p><b>Note:</b>  The <code>snclId</code> is not a unique identifier. If the time span of interest
crosses an epoch boundary where instrumentation was changed then multiple records (rows)
will share the same <code>snclId</code>.
</p>


<h3>Author(s)</h3>

<p>Jonathan Callahan <a href="mailto:jonathan@mazamascience.com">jonathan@mazamascience.com</a>
</p>


<h3>References</h3>

<p>The IRIS DMC station web service:
</p>
<p><a href="https://service.iris.edu/fdsnws/station/1/">https://service.iris.edu/fdsnws/station/1/</a>
</p>
<p>This implementation was inspired by the functionality in the obspy get_stations() method.
</p>
<p><a href="https://docs.obspy.org/packages/autogen/obspy.clients.fdsn.client.Client.get_stations.html">https://docs.obspy.org/packages/autogen/obspy.clients.fdsn.client.Client.get_stations.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IrisClient-class">IrisClient-class</a></code>, <code><a href="#topic+getChannel">getChannel</a></code>, <code><a href="#topic+getUnavailability">getUnavailability</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Open a connection to IRIS DMC webservices
iris &lt;- new("IrisClient")

# Date of Nisqually quake
starttime &lt;- as.POSIXct("2001-02-28",tz="GMT")
endtime &lt;- starttime + 2*24*3600

# Use  getEvent web service to retrieve events in this time period
result &lt;- try(events &lt;- getEvent(iris,starttime,endtime,6.0))
if (inherits(result,"try-error")) {
  message(geterrmessage())
} else {
  events

# biggest event is Nisqually
  eIndex &lt;- which(events$magnitude == max(events$magnitude))
  e &lt;- events[eIndex[1],]

# Find all BHZ channels collecting data at the time of the quake and within 
# 5 degrees of the quake epicenter
  result &lt;- try(channels &lt;- getAvailability(iris,"*","*","*","BHZ",starttime,endtime,
                            lat=e$latitude,long=e$longitude,maxradius=5))
  if (inherits(result,"try-error")) {
    message(geterrmessage())
  } else {
    channels
  }
}
</code></pre>

<hr>
<h2 id='getChannel'>Retrieve Channel metadata from IRIS DMC</h2><span id='topic+getChannel'></span><span id='topic+getChannel+2CIrisClient+2Ccharacter+2Ccharacter+2Ccharacter+2Ccharacter+2CPOSIXct+2CPOSIXct+2Clogical-method'></span><span id='topic+getChannel+2CIrisClient+2Ccharacter+2Ccharacter+2Ccharacter+2Ccharacter+2CPOSIXct+2CPOSIXct+2Cmissing-method'></span>

<h3>Description</h3>

<p>The <code>getChannel</code> method obtains channel metadata from the IRIS DMC <code>station</code> web service
and returns it in a dataframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getChannel(obj, network, station, location, channel,
           starttime, endtime, includerestricted,
           latitude, longitude, minradius, maxradius)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getChannel_+3A_obj">obj</code></td>
<td>
 <p><code>IrisClient</code> object </p>
</td></tr>
<tr><td><code id="getChannel_+3A_network">network</code></td>
<td>
<p> character string with the two letter seismic network code </p>
</td></tr>
<tr><td><code id="getChannel_+3A_station">station</code></td>
<td>
<p> character string with the station code </p>
</td></tr>
<tr><td><code id="getChannel_+3A_location">location</code></td>
<td>
<p> character string with the location code </p>
</td></tr>
<tr><td><code id="getChannel_+3A_channel">channel</code></td>
<td>
<p> character string with the three letter channel code </p>
</td></tr>
<tr><td><code id="getChannel_+3A_starttime">starttime</code></td>
<td>
<p> POSIXct class specifying the starttime (GMT) </p>
</td></tr>
<tr><td><code id="getChannel_+3A_endtime">endtime</code></td>
<td>
<p> POSIXct class specifying the endtime (GMT) </p>
</td></tr>
<tr><td><code id="getChannel_+3A_includerestricted">includerestricted</code></td>
<td>
<p> optional logical identifying whether to report on restricted data </p>
</td></tr>
<tr><td><code id="getChannel_+3A_latitude">latitude</code></td>
<td>
<p> optional latitude used when specifying a location and radius </p>
</td></tr>
<tr><td><code id="getChannel_+3A_longitude">longitude</code></td>
<td>
<p> optional longitude used when specifying a location and radius </p>
</td></tr>
<tr><td><code id="getChannel_+3A_minradius">minradius</code></td>
<td>
<p> optional minimum radius used when specifying a location and radius </p>
</td></tr>
<tr><td><code id="getChannel_+3A_maxradius">maxradius</code></td>
<td>
<p> optional maximum radius used when specifying a location and radius </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>getChannel</code> method uses the station web service to obtain data for all channels that meet the criteria defined by the arguments
and returns that data in a dataframe. Each row of the dataframe represents a unique channel-epoch. 
</p>
<p>Each of the arguments <code>network</code>, <code>station</code>, <code>location</code> or <code>channel</code> may contain
a valid code or a wildcard expression, e.g. &quot;BH?&quot; or &quot;*&quot;. Empty strings are converted to &quot;*&quot;.
Otherwise the ascii string that is used for
these values is simply inserted into the web service request URL.
</p>
<p>For more details see the <a href="https://service.iris.edu/fdsnws/station/1/">webservice documentation</a>.
</p>


<h3>Value</h3>

<p>A dataframe with the following columns:
</p>
<pre>
network, station, location, channel, latitude, longitude, elevation,
  depth, azimuth, dip, instrument, scale, scalefreq, scaleunits, 
  samplerate, starttime, endtime, snclId
</pre>
<p>Rows are ordered by <code>snclId</code>.
</p>
<p>The snclId column, eg. &quot;US.OCWA..BHE&quot;, is generated as a convenience. It is not part of
the normal return from the station web service.
</p>
<p><b>Note:</b>  The <code>snclId</code>s is not a unique identifier. If the time span of interest
crosses an epoch boundary where instrumentation was changed then multiple records (rows)
will share the same <code>snclId</code>.
</p>


<h3>Author(s)</h3>

<p>Jonathan Callahan <a href="mailto:jonathan@mazamascience.com">jonathan@mazamascience.com</a>
</p>


<h3>References</h3>

<p>The IRIS DMC station webservice:
</p>
<p><a href="https://service.iris.edu/fdsnws/station/1/">https://service.iris.edu/fdsnws/station/1/</a>
</p>
<p>This implementation was inspired by the functionality in the obspy get_stations() method.
</p>
<p><a href="https://docs.obspy.org/packages/autogen/obspy.clients.fdsn.client.Client.get_stations.html">https://docs.obspy.org/packages/autogen/obspy.clients.fdsn.client.Client.get_stations.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IrisClient-class">IrisClient-class</a></code>, <code><a href="#topic+getAvailability">getAvailability</a></code>, <code><a href="#topic+getUnavailability">getUnavailability</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Open a connection to IRIS DMC webservices
iris &lt;- new("IrisClient")

# Date of Nisqually quake
starttime &lt;- as.POSIXct("2001-02-28",tz="GMT")
endtime &lt;- starttime + 2*24*3600

# Use the getEvent web service to determine what events happened in this time period
result &lt;- try(events &lt;- getEvent(iris,starttime,endtime,6.0))
if (inherits(result,"try-error")) {
  message(geterrmessage())
} else {
  events

# biggest event is Nisqually
  eIndex &lt;- which(events$magnitude == max(events$magnitude))
  e &lt;- events[eIndex[1],]
}

# Which stations in the US network are within 5 degrees of the quake epicenter?
result &lt;- try(stations &lt;- getStation(iris,"US","*","*","BHZ",starttime,endtime,
                          lat=e$latitude,long=e$longitude,maxradius=5))
if (inherits(result,"try-error")) {
  message(geterrmessage())
} else {
  stations
}

# Get some detailed information on any BHZ channels at the "Octopus Mountain" station
result &lt;- try(channels &lt;- getChannel(iris,"US","OCWA","*","BHZ",starttime,endtime))
if (inherits(result,"try-error")) {
  message(geterrmessage())
} else {
  channels
}
</code></pre>

<hr>
<h2 id='getDataAvailability'>Retrieve miniseed trace extents from IRIS DMC</h2><span id='topic+getDataAvailability'></span><span id='topic+getDataAvailability+2CIrisClient+2Ccharacter+2Ccharacter+2Ccharacter+2Ccharacter+2CPOSIXct+2CPOSIXct-method'></span>

<h3>Description</h3>

<p>The <code>getDataAvailability</code> method obtains miniseed time extents from the IRIS DMC 
<code>availability</code> web service and returns it in a dataframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDataAvailability(obj, network, station, location, channel,starttime, endtime,
                     mergequality, mergesamplerate, mergeoverlap, mergetolerance, 
                     includerestricted, excludetoolarge)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getDataAvailability_+3A_obj">obj</code></td>
<td>
 <p><code>IrisClient</code> object </p>
</td></tr>
<tr><td><code id="getDataAvailability_+3A_network">network</code></td>
<td>
<p> character string with the two letter seismic network code </p>
</td></tr>
<tr><td><code id="getDataAvailability_+3A_station">station</code></td>
<td>
<p> character string with the station code </p>
</td></tr>
<tr><td><code id="getDataAvailability_+3A_location">location</code></td>
<td>
<p> character string with the location code </p>
</td></tr>
<tr><td><code id="getDataAvailability_+3A_channel">channel</code></td>
<td>
<p> character string with the three letter channel code </p>
</td></tr>
<tr><td><code id="getDataAvailability_+3A_starttime">starttime</code></td>
<td>
<p> POSIXct class specifying the starttime (GMT) </p>
</td></tr>
<tr><td><code id="getDataAvailability_+3A_endtime">endtime</code></td>
<td>
<p> POSIXct class specifying the endtime (GMT) </p>
</td></tr>
<tr><td><code id="getDataAvailability_+3A_mergequality">mergequality</code></td>
<td>
<p>optional logical identifying if timespans with differing qualities are grouped together 
(default=<code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="getDataAvailability_+3A_mergesamplerate">mergesamplerate</code></td>
<td>
<p>optional logical identifying if timespans from data with differing sample rates are grouped 
together (default=<code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="getDataAvailability_+3A_mergeoverlap">mergeoverlap</code></td>
<td>
<p>optional logical identifying if overlapping timespans are merged together (default=<code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="getDataAvailability_+3A_mergetolerance">mergetolerance</code></td>
<td>
<p>optional numeric. Time spans separated by less than or equal to the mergetolerance value
in seconds are merged together. To have an effect, the mergetolerance value must be larger 
than 1.5 times the sample period. This implements the mergegaps option in the fdsnws availability 
web service specification. </p>
</td></tr> 
<tr><td><code id="getDataAvailability_+3A_includerestricted">includerestricted</code></td>
<td>
<p> optional logical identifying whether to report on restricted data (default=<code>FALSE</code>) </p>
</td></tr>
<tr><td><code id="getDataAvailability_+3A_excludetoolarge">excludetoolarge</code></td>
<td>
<p> optional logical, if TRUE sets the fdsnws availability web service option &quot;limit=500000&quot;. default=<code>TRUE</code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>getDataAvailability</code> method uses the FDSNWS availability service to obtain start and endtimes for all continuous trace 
segments in the IRIS (or other) archive for the requested network, station, location, channels and returns that data in a dataframe. 
Each row of the dataframe represents a unique data trace extent. 
</p>
<p>Each of the arguments <code>network</code>, <code>station</code>, <code>location</code> or <code>channel</code> may contain
a valid code or a wildcard expression, e.g. &quot;BH?&quot; or &quot;*&quot;. Empty strings are converted to &quot;*&quot;.
Otherwise the ascii string that is used for these values is simply inserted into the web service request URL.
</p>
<p>For more details see the <a href="https://service.iris.edu/fdsnws/availability/1/">web service documentation</a>.
</p>


<h3>Value</h3>

<p>A dataframe with the following columns:
</p>
<p>mergequality=TRUE and mergesamplerate=FALSE (defaults):

</p>
<pre>
  network, station, location, channel, samplerate, starttime, endtime, snclId 
  </pre>
<p>mergequality=TRUE and mergesamplerate=TRUE:
</p>
<pre>
  network, station, location, channel, starttime, endtime, snclId
  </pre>
<p>mergequality=FALSE and mergesamplerate=FALSE:
</p>
<pre>
  network, station, location, channel, quality, samplerate, starttime, endtime, snclId            
  </pre>
<p>mergequality=FALSE and mergesamplerate=TRUE:
</p>
<pre>
  network, station, location, channel, quality, starttime, endtime, snclId
  </pre>
<p>Rows are ordered by <code>snclId</code>.
</p>
<p>The snclId column, eg. &quot;US.OCWA..BHE&quot;, is generated as a convenience. It is not part of
the normal return from the station web service.
</p>


<h3>Author(s)</h3>

<p>Gillian Sharer <a href="mailto:gillian@iris.washington.edu">gillian@iris.washington.edu</a>
</p>


<h3>References</h3>

<p>The IRIS DMC station web service:
</p>
<p><a href="https://service.iris.edu/fdsnws/availability/1/">https://service.iris.edu/fdsnws/availability/1/</a>
<a href="https://service.iris.edu/ph5ws/availability/1/">https://service.iris.edu/ph5ws/availability/1/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IrisClient-class">IrisClient-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Open a connection to IRIS DMC webservices
iris &lt;- new("IrisClient")

starttime &lt;- as.POSIXct("2018-01-01",tz="GMT")
endtime &lt;- as.POSIXct("2019-01-01",tz="GMT")
network &lt;- "TA"
station &lt;- "M22K"
channel &lt;- "BHZ"

result &lt;- try(traceList &lt;- getDataAvailability(iris,network,station,"*",channel,starttime,endtime))
if (inherits(result,"try-error")) {
  message(geterrmessage())
} else {
  traceList
}
</code></pre>

<hr>
<h2 id='getDataselect'>Retrieve seismic data from IRIS DMC</h2><span id='topic+getDataselect'></span><span id='topic+getDataselect+2CIrisClient+2Ccharacter+2Ccharacter+2Ccharacter+2Ccharacter+2CPOSIXct+2CPOSIXct-method'></span>

<h3>Description</h3>

<p>The <code>getDataselect</code> method makes a request of the IRIS DMC <code>dataselect</code> 
webservice and returns a <code>Stream</code> object in which individual <code>Traces</code>
have been sorted by start time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDataselect(obj, network, station, location, channel, 
              starttime, endtime, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getDataselect_+3A_obj">obj</code></td>
<td>
 <p><code>IrisClient</code> object</p>
</td></tr>
<tr><td><code id="getDataselect_+3A_network">network</code></td>
<td>
<p>character string with the two letter seismic network code</p>
</td></tr>
<tr><td><code id="getDataselect_+3A_station">station</code></td>
<td>
<p>character string with the station code</p>
</td></tr>
<tr><td><code id="getDataselect_+3A_location">location</code></td>
<td>
<p>character string with the location code</p>
</td></tr>
<tr><td><code id="getDataselect_+3A_channel">channel</code></td>
<td>
<p>character string with the three letter channel code</p>
</td></tr>
<tr><td><code id="getDataselect_+3A_starttime">starttime</code></td>
<td>
<p>POSIXct class specifying the starttime (GMT)</p>
</td></tr>
<tr><td><code id="getDataselect_+3A_endtime">endtime</code></td>
<td>
<p>POSIXct class specifying the endtime (GMT)</p>
</td></tr>
<tr><td><code id="getDataselect_+3A_...">...</code></td>
<td>
<p>optional arguments
<code>quality</code> optional character string identifying the quality. IRIS webservices defaults to quality=&quot;M&quot;.
<code>repository</code> optional character string identifying whether to exclusively search primary archive or realtime collection buffers.
Acceptable values are &quot;primary&quot; or &quot;realtime&quot;. If not specified, IRIS webservices defaults to both repositories.
<code>inclusiveEnd</code> optional logical determining whether the endtime is inclusive (default = TRUE)
<code>ignoreEpoch</code> optional logical defining behavior when multiple epochs are encountered (default = FALSE)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the primary method for retrieving seismic data.  Data requests are made through
the <code>dataselect</code> webservice and returned data are parsed using the internal miniseed2Stream() function.
</p>
<p>If the location argument contains an empty string to specify a 'blank' location code, a location
code of <code>"--"</code> will be used in the dataselect request URL.
(See <a href="https://service.iris.edu/fdsnws/dataselect/1/">dataselect documentation</a>.)
</p>
<p>If <code>inclusiveEnd=FALSE</code>, then <code>getDataselect</code> will subtract 0.000001 seconds from the endtime before passing the 
value to the <code>dataselect</code> webservice. An endtime of, e.g., <code>as.POSIXct("2016-01-03", tz="GMT")</code> will be passed 
into <code>dataselect</code> as <code>end=2016-01-02T23:59:59.999999</code>. A data sample at time 2016-01-03T00:00:00 will not be returned
unless <code>inclusiveEnd=TRUE</code>.
</p>
<p>Error returns from the webservice will stop evaluation and generate an error message.
</p>
<p>Sometimes the station webservice will return multiple records for the same SNCL,
each with a different scale or starttime.  These represent different <em>epochs</em> with
potentially different metadata parameters for the SNCL and, by default, will cause
a 'Multiple epochs' error message to be generated.
</p>
<p>Handling all possible metadata differences so that the data may be merged is beyond the scope of this
package. Instead, to avoid errors, users may specify <code>ignoreEpoch=TRUE</code> in which case
the very first SNCL-epoch encountered will be used and all others will be discarded.
</p>
<p>For access to restricted data, getDataselect will look for system environmental variable &quot;IrisClient_netrc&quot;
which should point to a .netrc authentication file.
</p>


<h3>Value</h3>

<p>A new <code>Stream</code> object is returned.
</p>


<h3>Author(s)</h3>

<p>Jonathan Callahan <a href="mailto:jonathan@mazamascience.com">jonathan@mazamascience.com</a>
</p>


<h3>References</h3>

<p>The IRIS DMC dataselect webservice:
</p>
<p><a href="https://service.iris.edu/fdsnws/dataselect/1/">https://service.iris.edu/fdsnws/dataselect/1/</a>
</p>
<p>This implementation is similar in functionality to the obspy dataselect function:
</p>
<p><a href="https://docs.obspy.org/_modules/obspy/clients/fdsn/client.html">https://docs.obspy.org/_modules/obspy/clients/fdsn/client.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getSNCL">getSNCL</a></code>, 
<code><a href="#topic+IrisClient-class">IrisClient-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
## Not run: 
# Open a connection to IRIS DMC webservices
iris &lt;- new("IrisClient")
options("nanotimeFormat"="%Y-%m-%dT%H-%M-%E9S")

# Use getDataselect to request data for II.JTS.00.BHZ
starttime &lt;- as.POSIXct("2001-02-28",tz="GMT")
endtime &lt;- as.POSIXct("2001-03-01",tz="GMT")

st &lt;- getDataselect(iris, "II","JTS","00","BHZ",starttime, endtime, 
                    inclusiveEnd=FALSE,ignoreEpoch=TRUE)

# Display structure of trace(s)

str(st)

# Plot trace
plot(st)

## End(Not run)
</code></pre>

<hr>
<h2 id='getDistaz'>Retrieve great circle distance information from IRIS DMC</h2><span id='topic+getDistaz'></span><span id='topic+getDistaz+2CIrisClient+2Cnumeric+2Cnumeric+2Cnumeric+2Cnumeric-method'></span>

<h3>Description</h3>

<p>The <code>getDistaz</code> method obtains great circle distance data from
the IRIS DMC <code>distaz</code> web service.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDistaz(obj, latitude, longitude, staLatitude, staLongitude)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getDistaz_+3A_obj">obj</code></td>
<td>
<p> an <code>IrisClient</code> object </p>
</td></tr>
<tr><td><code id="getDistaz_+3A_latitude">latitude</code></td>
<td>
<p> latitude of seismic event </p>
</td></tr>
<tr><td><code id="getDistaz_+3A_longitude">longitude</code></td>
<td>
<p> longitude of seismic event </p>
</td></tr>
<tr><td><code id="getDistaz_+3A_stalatitude">staLatitude</code></td>
<td>
<p> latitude of seismic station </p>
</td></tr>
<tr><td><code id="getDistaz_+3A_stalongitude">staLongitude</code></td>
<td>
<p> longitude of seismic station </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The distance-azimuth service will calculate the great-circle angular distance, azimuth,
and back azimuth between two geographic coordinate pairs. Azimuth and back azimuth are measured clockwise from North.
</p>


<h3>Value</h3>

<p>A dataframe with the following columns:
</p>
<pre>
ellipsoid.semiMajorAxis, ellipsoid.flattening, ellipsoid.name, fromlat, fromlon, tolat, tolon,
  azimuth,backAzimuth, distance, distanceMeters
</pre>
<p>Where <code>fromlat</code> is the event latitude, <code>fromlon</code> is the event longitude, <code>tolat</code> is the station latitude, and <code>tolon</code>
is the station longitude. <code>azimuth</code>, <code>backAzimuth</code>, and <code>distance</code> are measured in degrees. <code>distanceMeters</code> is distance in meters.
<code>ellipsoid.semiMajorAxis</code>, <code>ellipsoid.flattening</code>, and <code>ellipsoid.name</code> refer to the World Geodetic System standard coordinate system version used to correct for ellipticity when converting to geocentric latitudes.
</p>
<p>Only a single row is returned.
</p>


<h3>Author(s)</h3>

<p>Jonathan Callahan <a href="mailto:jonathan@mazamascience.com">jonathan@mazamascience.com</a>
</p>


<h3>References</h3>

<p>The IRIS DMC distaz webservice:
</p>
<p><a href="https://service.iris.edu/irisws/distaz/1/">https://service.iris.edu/irisws/distaz/1/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IrisClient-class">IrisClient-class</a></code>
</p>

<hr>
<h2 id='getEvalresp'>Retrieve instrument response information from IRIS DMC</h2><span id='topic+getEvalresp'></span><span id='topic+getEvalresp+2CIrisClient+2Ccharacter+2Ccharacter+2Ccharacter+2Ccharacter+2CPOSIXct-method'></span>

<h3>Description</h3>

<p>The <code>getEvalresp</code> method obtains instrument response data from
the IRIS DMC <code>evalresp</code> webservice.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getEvalresp(obj, network, station, location, channel,
            time, minfreq, maxfreq, nfreq, units, output, spacing)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getEvalresp_+3A_obj">obj</code></td>
<td>
<p> an <code>IrisClient</code> object </p>
</td></tr>
<tr><td><code id="getEvalresp_+3A_network">network</code></td>
<td>
<p> character string with the two letter seismic network code </p>
</td></tr>
<tr><td><code id="getEvalresp_+3A_station">station</code></td>
<td>
<p> character string with the station code </p>
</td></tr>
<tr><td><code id="getEvalresp_+3A_location">location</code></td>
<td>
<p> character string with the location code </p>
</td></tr>
<tr><td><code id="getEvalresp_+3A_channel">channel</code></td>
<td>
<p> character string with the three letter channel code </p>
</td></tr>
<tr><td><code id="getEvalresp_+3A_time">time</code></td>
<td>
<p> POSIXct class specifying the time at which response is evaluated (GMT) </p>
</td></tr>
<tr><td><code id="getEvalresp_+3A_minfreq">minfreq</code></td>
<td>
<p> optional minimum frequency at which response will be evaluated </p>
</td></tr>
<tr><td><code id="getEvalresp_+3A_maxfreq">maxfreq</code></td>
<td>
<p> optional maximum frequency at which response will be evaluated </p>
</td></tr>
<tr><td><code id="getEvalresp_+3A_nfreq">nfreq</code></td>
<td>
<p> optional  number of frequencies at which response will be evaluated </p>
</td></tr>
<tr><td><code id="getEvalresp_+3A_units">units</code></td>
<td>
<p> optional code specifying unit conversion </p>
</td></tr>
<tr><td><code id="getEvalresp_+3A_output">output</code></td>
<td>
<p> optional code specifying output type (default=&quot;fap&quot;)</p>
</td></tr>
<tr><td><code id="getEvalresp_+3A_spacing">spacing</code></td>
<td>
<p> optional code specifying spacing, accepted values are &quot;lin&quot; or &quot;linear&quot;,
&quot;log&quot; or &quot;logarithmic&quot; (default=&quot;log&quot;)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>evalresp</code> webservice responds to requests with data that can be used to
remove instrument response from a seismic signal.
</p>
<p>Each of <code>network</code>, <code>station</code> or <code>channel</code> should contain
a valid code without wildcards. The ascii string that is used for
these values is simply passed through to <code>evalresp</code>.
</p>
<p>If the <code>location</code> argument contains an empty string to specify a 'blank' location code, a location
code of <code>"--"</code> will be used in the dataselect request URL.
(See <a href="https://service.iris.edu/fdsnws/dataselect/1/">dataselect documentation</a>.)
</p>
<p>The response from <code>evalresp</code> is converted into a dataframe with rows in order of increasing frequency.
</p>


<h3>Value</h3>

<p>For <code>output="fap"</code>, a dataframe with columns named:
</p>
<pre>freq, amp, phase</pre>
<p>For <code>output="cs"</code>, a dataframe with columns named:
</p>
<pre>freq, real, imag</pre>


<h3>Author(s)</h3>

<p>Jonathan Callahan <a href="mailto:jonathan@mazamascience.com">jonathan@mazamascience.com</a>
</p>


<h3>References</h3>

<p>The IRIS DMC evalresp webservice:
</p>
<p><a href="https://service.iris.edu/irisws/evalresp/1/">https://service.iris.edu/irisws/evalresp/1/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IrisClient-class">IrisClient-class</a></code>,
</p>

<hr>
<h2 id='getEvent'>Retrieve seismic event information from the USGS NEIC</h2><span id='topic+getEvent'></span><span id='topic+getEvent+2CIrisClient+2CPOSIXct+2CPOSIXct-method'></span>

<h3>Description</h3>

<p>The <code>getEvent</code> method obtains seismic event data from
the USGS NEIC <code>event</code> webservice.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getEvent(obj, starttime, endtime, minmag, maxmag, magtype,
         mindepth, maxdepth)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getEvent_+3A_obj">obj</code></td>
<td>
<p> an <code>IrisClient</code> object </p>
</td></tr>
<tr><td><code id="getEvent_+3A_starttime">starttime</code></td>
<td>
<p> POSIXct class limiting results to events occurring after starttime (GMT) </p>
</td></tr>
<tr><td><code id="getEvent_+3A_endtime">endtime</code></td>
<td>
<p> POSIXct class limiting results to events occurring before endtime (GMT) </p>
</td></tr>
<tr><td><code id="getEvent_+3A_minmag">minmag</code></td>
<td>
<p> optional minimum magnitude </p>
</td></tr>
<tr><td><code id="getEvent_+3A_maxmag">maxmag</code></td>
<td>
<p> optional maximum magnitude </p>
</td></tr>
<tr><td><code id="getEvent_+3A_magtype">magtype</code></td>
<td>
<p> optional magnitude type </p>
</td></tr>
<tr><td><code id="getEvent_+3A_mindepth">mindepth</code></td>
<td>
<p> optional minimum depth (km) </p>
</td></tr>
<tr><td><code id="getEvent_+3A_maxdepth">maxdepth</code></td>
<td>
<p> optional maximum depth (km) </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>getEvent</code> method uses the event web service to obtain data for all events that meet the criteria defined by the arguments
and returns that data in a dataframe. Each row of the dataframe represents a unique event.
</p>
<p><code>getEvent</code> calls to the IRIS event webservice now go to https://earthquake.usgs.gov/fdsnws/event/1/. If <code>obj@site</code> is something
other than &quot;https://service.iris.edu&quot;, getEvent will point to <code>obj@site</code>/fdsnws/event/1/. The event service must be able to output
format=text.
</p>


<h3>Value</h3>

<p>A dataframe with the following columns:
</p>
<pre>
eventId ,time, latitude, longitude, depth, author, cCatalog, contributor,
  contributorId, magType, magnitude, magAuthor, eventLocationName 
</pre>
<p>Rows are ordered by <code>time</code>.
</p>
<p><strong>NOTE:</strong> column names are identical to the names returned from the event web service
with the exception of &quot;latitude&quot; for &quot;lat&quot; and &quot;longitude&quot; for &quot;lon&quot;. The longer names are
used for internal consistency &ndash; all other web services return columns named &quot;latitude&quot; and &quot;longitude&quot;.
</p>


<h3>Author(s)</h3>

<p>Jonathan Callahan <a href="mailto:jonathan@mazamascience.com">jonathan@mazamascience.com</a>
</p>


<h3>References</h3>

<p>The USGS event webservice:
<a href="https://earthquake.usgs.gov/fdsnws/event/1/">https://earthquake.usgs.gov/fdsnws/event/1/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IrisClient-class">IrisClient-class</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
# NOTE:  'maps' and 'mapdata' packages must be installed
#require(maps)
#require(mapdata)

# Open a connection to IRIS DMC webservices
iris &lt;- new("IrisClient")

# Get events &gt; mag 5.0 over a week in June of 2012
starttime &lt;- as.POSIXct("2012-06-21", tz="GMT")
endtime &lt;- starttime + 3600 * 24 * 7
result &lt;- try(events &lt;- getEvent(iris, starttime, endtime, minmag=5.0))
if (inherits(result,"try-error")) {
  message(geterrmessage())
} else {

# Look at all events
  print(paste(nrow(events),"earthquakes found with magnitude &gt; 5.0"))
  
# Plot events on a map
  #map('world')
  #points(events$longitude, events$latitude, pch=16, cex=1.5, col='red')
  #labels &lt;- paste(" ", as.character(round(events$magnitude,1)), sep="")
  #text(events$longitude, events$latitude, labels=labels, pos=4, cex=1.2, col='red3')
  }

## End(Not run)
</code></pre>

<hr>
<h2 id='getGaps'>Gap analysis</h2><span id='topic+getGaps'></span><span id='topic+getGaps+2CStream+2Cmissing-method'></span><span id='topic+getGaps+2CStream+2Cnumeric-method'></span>

<h3>Description</h3>

<p>The <code>getGaps</code> method calculates data dropouts that occur within the requested time
range associated with a <code>Stream</code>.
</p>
<p>A <code>Stream</code> object returned by <code><a href="#topic+getDataselect">getDataselect</a></code> contains a list of individual
<code>Trace</code> objects, each of which is guaranteed to contain a continuous array of 
data in each <code>Trace@data</code> slot. Each <code>TraceHeader</code> also contains a <code>starttime</code> and
an <code>endtime</code> defining a period of uninterrupted data collection.
</p>
<p>Data dropouts are determined by examining the <code>requestedStartime</code> and <code>requestedEndtime</code>
slots associated with the <code>Stream</code> and the <code>starttime</code> and <code>endtime</code> slots
found in the each <code>TraceHeader</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getGaps(x, min_gap)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getGaps_+3A_x">x</code></td>
<td>
 <p><code>Stream</code> object </p>
</td></tr>
<tr><td><code id="getGaps_+3A_min_gap">min_gap</code></td>
<td>
<p> minimum gap (sec) below which gaps will be ignored (default=1/sampling_rate) </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method first checks the SNCL id of each <code>Trace</code> to make sure they are identical
and generates an error if they are not. Mismatches in the <code>sampling_rate</code> will also generate
an error.
</p>
<p>The data gaps (in seconds) within a <code>Stream</code> are
determined and the associated <code>sampling_rate</code> is used to calculate the number of
missing values in each gap. The length of the <code>gaps</code> and <code>nsamples</code> vectors
in the returned list will be one more than the number of <code>Traces</code>
(inital gap + gaps between traces + final gap).
</p>
<p>Gaps smaller than <code>min_gap</code> are set to <code>0</code>. Values of <code>min_gap</code> smaller
than <code>1/sampling_rate</code> will be ignored and the default value will be used instead.
</p>
<p>Overlaps will appear as gaps with negative values.
</p>


<h3>Value</h3>

<p>A list is returned with the following elements:
</p>

<ul>
<li><p><code>gaps</code> numeric vector of data gaps within a <code>Stream</code>
</p>
</li>
<li><p><code>nsamples</code> number of missing samples associated with each gap
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Jonathan Callahan <a href="mailto:jonathan@mazamascience.com">jonathan@mazamascience.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Open a connection to IRIS DMC webservices
iris &lt;- new("IrisClient")

starttime &lt;- as.POSIXct("2012-01-24", tz="GMT")
endtime &lt;- as.POSIXct("2012-01-25", tz="GMT")

# Get the waveform
st &lt;- getDataselect(iris,"AK","PIN","","BHZ",starttime,endtime)

# Save the gap analysis in a variable
gapInfo &lt;- getGaps(st)

# See what information is availble
names(gapInfo)

# Look at a histogram of data dropouts
hist(gapInfo$nsamples, breaks=50, 
     main="Data Gaps in AK.PIN..BHZ Jan 24, 2012",
     xlab="number of missing samples per gap")

## End(Not run)
</code></pre>

<hr>
<h2 id='getNetwork'>Retrieve Network metadata from IRIS DMC</h2><span id='topic+getNetwork'></span><span id='topic+getNetwork+2CIrisClient+2Ccharacter+2Ccharacter+2Ccharacter+2Ccharacter+2CPOSIXct+2CPOSIXct+2Clogical-method'></span><span id='topic+getNetwork+2CIrisClient+2Ccharacter+2Ccharacter+2Ccharacter+2Ccharacter+2CPOSIXct+2CPOSIXct+2Cmissing-method'></span>

<h3>Description</h3>

<p>The <code>getNetwork</code> method obtains network metadata from the IRIS DMC station web service
and returns it in a dataframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getNetwork(obj, network, station, location, channel,
           starttime, endtime, includerestricted,
           latitude, longitude, minradius, maxradius)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getNetwork_+3A_obj">obj</code></td>
<td>
 <p><code>IrisClient</code> object </p>
</td></tr>
<tr><td><code id="getNetwork_+3A_network">network</code></td>
<td>
<p> character string with the two letter seismic network code </p>
</td></tr>
<tr><td><code id="getNetwork_+3A_station">station</code></td>
<td>
<p> character string with the station code </p>
</td></tr>
<tr><td><code id="getNetwork_+3A_location">location</code></td>
<td>
<p> character string with the location code </p>
</td></tr>
<tr><td><code id="getNetwork_+3A_channel">channel</code></td>
<td>
<p> character string with the three letter channel code </p>
</td></tr>
<tr><td><code id="getNetwork_+3A_starttime">starttime</code></td>
<td>
<p> POSIXct class specifying the starttime (GMT) </p>
</td></tr>
<tr><td><code id="getNetwork_+3A_endtime">endtime</code></td>
<td>
<p> POSIXct class specifying the endtime (GMT) </p>
</td></tr>
<tr><td><code id="getNetwork_+3A_includerestricted">includerestricted</code></td>
<td>
<p> optional logical identifying whether to report on restricted data (default=<code>FALSE</code>) </p>
</td></tr>
<tr><td><code id="getNetwork_+3A_latitude">latitude</code></td>
<td>
<p> optional latitude used when specifying a location and radius </p>
</td></tr>
<tr><td><code id="getNetwork_+3A_longitude">longitude</code></td>
<td>
<p> optional longitude used when specifying a location and radius </p>
</td></tr>
<tr><td><code id="getNetwork_+3A_minradius">minradius</code></td>
<td>
<p> optional minimum radius used when specifying a location and radius </p>
</td></tr>
<tr><td><code id="getNetwork_+3A_maxradius">maxradius</code></td>
<td>
<p> optional maximum radius used when specifying a location and radius </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>getNetwork</code> method utilizes the station web service to return data for all stations that meet the criteria defined by the arguments
and returns that data in a dataframe. Each row of the dataframe represents a unique network.
</p>
<p>Each of the arguments <code>network</code>, <code>station</code>, <code>location</code> or <code>channel</code> may contain
a valid code or a wildcard expression, e.g. &quot;BH?&quot; or &quot;*&quot;.  Empty strings are converted to &quot;*&quot;.
Otherwise, the ascii string that is used for
these values is simply inserted into the web service request URL.
</p>
<p>For more details see the <a href="https://service.iris.edu/fdsnws/station/1/">web service documentation</a>.
</p>


<h3>Value</h3>

<p>A dataframe with the following columns:
</p>
<pre>
network, description, starttime, endtime, totalstations
</pre>
<p>Rows are ordered by <code>network</code>.
</p>


<h3>Author(s)</h3>

<p>Jonathan Callahan <a href="mailto:jonathan@mazamascience.com">jonathan@mazamascience.com</a>
</p>


<h3>References</h3>

<p>The IRIS DMC station web service:
</p>
<p><a href="https://service.iris.edu/fdsnws/station/1/">https://service.iris.edu/fdsnws/station/1/</a>
</p>
<p>This implementation was inspired by the functionality in the obspy get_stations() method.
</p>
<p><a href="https://docs.obspy.org/packages/autogen/obspy.clients.fdsn.client.Client.get_stations.html">https://docs.obspy.org/packages/autogen/obspy.clients.fdsn.client.Client.get_stations.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IrisClient-class">IrisClient-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Open a connection to IRIS DMC webservices
iris &lt;- new("IrisClient")

# Date of Nisqually quake
starttime &lt;- as.POSIXct("2001-02-28",tz="GMT")
endtime &lt;- starttime + 2*24*3600

# Use the getEvent web service to determine what events happened in this time period
result &lt;- try(events &lt;- getEvent(iris,starttime,endtime,6.0))
if (inherits(result,"try-error")) {
  message(geterrmessage())
} else {
  events

# biggest event is Nisqually
  eIndex &lt;- which(events$magnitude == max(events$magnitude))
  e &lt;- events[eIndex[1],]


# Which seismic networks have BHZ stations within 5 degrees of the quake epicenter?
  result &lt;- try(networks &lt;- getNetwork(iris,"*","*","*","BHZ",starttime,endtime,
                            lat=e$latitude,lon=e$longitude,maxradius=5))
  if (inherits(result,"try-error")) {
    message(geterrmessage())
  } else {
    networks
  }
}
</code></pre>

<hr>
<h2 id='getRotation'>Retrieve rotated seismic data from IRIS DMC</h2><span id='topic+getRotation'></span><span id='topic+getRotation+2CIrisClient+2Ccharacter+2Ccharacter+2Ccharacter+2Ccharacter+2CPOSIXct+2CPOSIXct+2Ccharacter-method'></span>

<h3>Description</h3>

<p>The <code>getRotation</code> method makes a request of the IRIS DMC <code>rotation</code> 
web service and returns a list of 3 <code>Stream</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRotation(obj, network, station, location, channelSet, 
              starttime, endtime, processing)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getRotation_+3A_obj">obj</code></td>
<td>
 <p><code>IrisClient</code> object</p>
</td></tr>
<tr><td><code id="getRotation_+3A_network">network</code></td>
<td>
<p>character string with the two letter seismic network code</p>
</td></tr>
<tr><td><code id="getRotation_+3A_station">station</code></td>
<td>
<p>character string with the station code</p>
</td></tr>
<tr><td><code id="getRotation_+3A_location">location</code></td>
<td>
<p>character string with the location code</p>
</td></tr>
<tr><td><code id="getRotation_+3A_channelset">channelSet</code></td>
<td>
<p>the first two characters of the selected source channels</p>
</td></tr>
<tr><td><code id="getRotation_+3A_starttime">starttime</code></td>
<td>
<p>POSIXct class specifying the starttime (GMT)</p>
</td></tr>
<tr><td><code id="getRotation_+3A_endtime">endtime</code></td>
<td>
<p>POSIXct class specifying the endtime (GMT)</p>
</td></tr>
<tr><td><code id="getRotation_+3A_processing">processing</code></td>
<td>
<p>optional character string with processing commands </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>rotation</code> web service returns a triplet of seismic Streams, rotated according
to the processing commands.
</p>
<p>If the location argument contains an empty string to specify a 'blank' location code, a location
code of <code>"--"</code> will be used in the dataselect request URL.
</p>
<p>The <code>processing</code> parameter can be used to specify any type of processing supported by the
<code>rotation</code> webs service.  This string must begin with an ampersand and be ready to be appended to the request url, e.g.
<code>processing="&amp;components=ZRT&amp;azimuth=23.1"</code>.  This gives the user complete control over the number
and order of processing commands.
(See <a href="https://service.iris.edu/irisws/rotation/1/">rotation documentation</a>.)
</p>
<p>Error returns from the web service will stop evaluation and generate an error message.
</p>


<h3>Value</h3>

<p>A list of three <code>Stream</code> objects is returned.
</p>


<h3>Author(s)</h3>

<p>Jonathan Callahan <a href="mailto:jonathan@mazamascience.com">jonathan@mazamascience.com</a>
</p>


<h3>References</h3>

<p>The IRIS DMC rotation web service:
</p>
<p><a href="https://service.iris.edu/irisws/rotation/1/">https://service.iris.edu/irisws/rotation/1/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IrisClient-class">IrisClient-class</a></code>
</p>

<hr>
<h2 id='getSNCL'>Retrieve seismic data from IRIS DMC</h2><span id='topic+getSNCL'></span><span id='topic+getSNCL+2CIrisClient+2Ccharacter+2CPOSIXct+2CPOSIXct-method'></span>

<h3>Description</h3>

<p>The getSNCL() method is a convenience wrapper for the getSNCL() method
and returns a <code>Stream</code> object in which individual <code>Traces</code>
have been sorted by start time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSNCL(obj, sncl, starttime, endtime, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSNCL_+3A_obj">obj</code></td>
<td>
 <p><code>IrisClient</code> object </p>
</td></tr>
<tr><td><code id="getSNCL_+3A_sncl">sncl</code></td>
<td>
<p> character string with the SNCL code </p>
</td></tr>
<tr><td><code id="getSNCL_+3A_starttime">starttime</code></td>
<td>
<p> POSIXct class specifying the starttime (GMT) </p>
</td></tr>
<tr><td><code id="getSNCL_+3A_endtime">endtime</code></td>
<td>
<p> POSIXct class specifying the endtime (GMT) </p>
</td></tr>
<tr><td><code id="getSNCL_+3A_...">...</code></td>
<td>
<p>optional arguments   
<code>quality</code> optional character string identifying the quality. IRIS webservices defaults to quality=&quot;M&quot;.
<code>repository</code> optional character string identifying whether to exclusively search primary archive or realtime collection buffers.
Acceptable values are &quot;primary&quot; or &quot;realtime&quot;. If not specified, IRIS webservices defaults to both repositories.
<code>inclusiveEnd</code> optional logical determining whether the endtime is inclusive (default = TRUE)
<code>ignoreEpoch</code> optional logical defining behavior when multiple epochs are encountered (default = FALSE)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The SNCL argument should be ordered network-station-location channel, e.g. <code>IU.ANMO.00.LHZ</code>.
This argument is split into component parts which are then used in a call to the
getSNCL() method.
</p>


<h3>Value</h3>

<p>A new <code>Stream</code> object is returned.
</p>


<h3>Author(s)</h3>

<p>Jonathan Callahan <a href="mailto:jonathan@mazamascience.com">jonathan@mazamascience.com</a>
</p>


<h3>References</h3>

<p>The IRIS DMC dataselect web service:
</p>
<p><a href="https://service.iris.edu/fdsnws/dataselect/1/">https://service.iris.edu/fdsnws/dataselect/1/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getDataselect">getDataselect</a></code>, 
<code><a href="#topic+IrisClient-class">IrisClient-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
## Not run: 
# Open a connection to IRIS DMC webservices
iris &lt;- new("IrisClient")

# Use getSNCL to request data for II.JTS.00.BHZ
starttime &lt;- as.POSIXct("2001-02-28",tz="GMT")
endtime &lt;- as.POSIXct("2001-03-01",tz="GMT")

st &lt;- getSNCL(iris, "II.JTS.00.BHZ",starttime, endtime, quality="M",
              repository="primary",inclusiveEnd=FALSE,ignoreEpoch=TRUE)

# Display structure of trace(s)

str(st)

# Plot trace
plot(st)

## End(Not run)
</code></pre>

<hr>
<h2 id='getStation'>Retrieve Station metadata from IRIS DMC</h2><span id='topic+getStation'></span><span id='topic+getStation+2CIrisClient+2Ccharacter+2Ccharacter+2Ccharacter+2Ccharacter+2CPOSIXct+2CPOSIXct+2Clogical-method'></span><span id='topic+getStation+2CIrisClient+2Ccharacter+2Ccharacter+2Ccharacter+2Ccharacter+2CPOSIXct+2CPOSIXct+2Cmissing-method'></span>

<h3>Description</h3>

<p>The <code>getStation</code> method obtains station metadata from the IRIS DMC station web service
and returns it in a dataframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getStation(obj, network, station, location, channel,
           starttime, endtime, includerestricted,
           latitude, longitude, minradius, maxradius)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getStation_+3A_obj">obj</code></td>
<td>
 <p><code>IrisClient</code> object </p>
</td></tr>
<tr><td><code id="getStation_+3A_network">network</code></td>
<td>
<p> character string with the two letter seismic network code </p>
</td></tr>
<tr><td><code id="getStation_+3A_station">station</code></td>
<td>
<p> character string with the station code </p>
</td></tr>
<tr><td><code id="getStation_+3A_location">location</code></td>
<td>
<p> character string with the location code </p>
</td></tr>
<tr><td><code id="getStation_+3A_channel">channel</code></td>
<td>
<p> character string with the three letter channel code </p>
</td></tr>
<tr><td><code id="getStation_+3A_starttime">starttime</code></td>
<td>
<p> POSIXct class specifying the starttime (GMT) </p>
</td></tr>
<tr><td><code id="getStation_+3A_endtime">endtime</code></td>
<td>
<p> POSIXct class specifying the endtime (GMT) </p>
</td></tr>
<tr><td><code id="getStation_+3A_includerestricted">includerestricted</code></td>
<td>
<p> optional logical identifying whether to report on restricted data </p>
</td></tr>
<tr><td><code id="getStation_+3A_latitude">latitude</code></td>
<td>
<p> optional latitude used when specifying a location and radius </p>
</td></tr>
<tr><td><code id="getStation_+3A_longitude">longitude</code></td>
<td>
<p> optional longitude used when specifying a location and radius </p>
</td></tr>
<tr><td><code id="getStation_+3A_minradius">minradius</code></td>
<td>
<p> optional minimum radius used when specifying a location and radius </p>
</td></tr>
<tr><td><code id="getStation_+3A_maxradius">maxradius</code></td>
<td>
<p> optional maximum radius used when specifying a location and radius </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>getStation</code> method utilizes the station web service to obtain data for all stations that meet the criteria defined by the arguments
and returns that data in a dataframe. Each row of the dataframe represents a unique station.
</p>
<p>Each of the arguments <code>network</code>, <code>station</code>, <code>location</code> or <code>channel</code> may contain
a valid code or a wildcard expression, e.g. &quot;BH?&quot; or &quot;*&quot;. Empty strings are converted to &quot;*&quot;.
Otherwise, the ascii string that is used for
these values is simply inserted into the web service request URL.
</p>
<p>For more details see the <a href="https://service.iris.edu/fdsnws/station/1/">web service documentation</a>.
</p>


<h3>Value</h3>

<p>A dataframe with the following columns:
</p>
<pre>
network, station, latitude, longitude, elevation, sitename, starttime, endtime
</pre>
<p>Rows are ordered by <code>network-station</code>.
</p>


<h3>Author(s)</h3>

<p>Jonathan Callahan <a href="mailto:jonathan@mazamascience.com">jonathan@mazamascience.com</a>
</p>


<h3>References</h3>

<p>The IRIS DMC station web service:
</p>
<p><a href="https://service.iris.edu/fdsnws/station/1/">https://service.iris.edu/fdsnws/station/1/</a>
</p>
<p>This implementation was inspired by the functionality in the obspy get_stations() method.
</p>
<p><a href="https://docs.obspy.org/packages/autogen/obspy.clients.fdsn.client.Client.get_stations.html">https://docs.obspy.org/packages/autogen/obspy.clients.fdsn.client.Client.get_stations.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IrisClient-class">IrisClient-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Open a connection to IRIS DMC webservices
iris &lt;- new("IrisClient")

# Date of Nisqually quake
starttime &lt;- as.POSIXct("2001-02-28",tz="GMT")
endtime &lt;- starttime + 2*24*3600

# Use the getEvent web service to determine what events happened in this time period
result &lt;- try(events &lt;- getEvent(iris,starttime,endtime,6.0))
if (inherits(result,"try-error")) {
  message(geterrmessage())
} else {
  events

# biggest event is Nisqually
  eIndex &lt;- which(events$magnitude == max(events$magnitude))
  e &lt;- events[eIndex[1],]

# Which stations in the US network are within 5 degrees of the quake epicenter?
  result &lt;- try(stations &lt;- getStation(iris,"US","*","*","BHZ",starttime,endtime,
                            lat=e$latitude,long=e$longitude,maxradius=5))
  if (inherits(result,"try-error")) {
    message(geterrmessage())
  } else {
    stations
  }
}
</code></pre>

<hr>
<h2 id='getTimeseries'>Retrieve seismic data from IRIS DMC</h2><span id='topic+getTimeseries'></span><span id='topic+getTimeseries+2CIrisClient+2Ccharacter+2Ccharacter+2Ccharacter+2Ccharacter+2CPOSIXct+2CPOSIXct-method'></span>

<h3>Description</h3>

<p>The <code>getTimeseries</code> method makes a request of the IRIS DMC <code>timeseries</code> 
webservice and returns a <code>Stream</code> object in which individual <code>Traces</code>
have been sorted by start time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTimeseries(obj, network, station, location, channel, 
              starttime, endtime,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTimeseries_+3A_obj">obj</code></td>
<td>
<p><code>IrisClient</code> object </p>
</td></tr>
<tr><td><code id="getTimeseries_+3A_network">network</code></td>
<td>
<p>character string with the two letter seismic network code </p>
</td></tr>
<tr><td><code id="getTimeseries_+3A_station">station</code></td>
<td>
<p>character string with the station code </p>
</td></tr>
<tr><td><code id="getTimeseries_+3A_location">location</code></td>
<td>
<p>character string with the location code </p>
</td></tr>
<tr><td><code id="getTimeseries_+3A_channel">channel</code></td>
<td>
<p>character string with the three letter channel code </p>
</td></tr>
<tr><td><code id="getTimeseries_+3A_starttime">starttime</code></td>
<td>
<p>POSIXct class specifying the starttime (GMT) </p>
</td></tr>
<tr><td><code id="getTimeseries_+3A_endtime">endtime</code></td>
<td>
<p>POSIXct class specifying the endtime (GMT) </p>
</td></tr>
<tr><td><code id="getTimeseries_+3A_...">...</code></td>
<td>
<p>optional arguments
<code>repository</code> optional character string identifying whether to exclusively search primary archive or realtime collection buffers.
Acceptable values are &quot;primary&quot; or &quot;realtime&quot;. If not specified, IRIS webservices defaults to both repositories.
<code>processing</code>optional character string with processing commands 
<code>inclusiveEnd</code> optional logical determining whether the endtime is inclusive (default = TRUE)
<code>ignoreEpoch</code> optional logical defining behavior when multiple epochs are encountered (default = FALSE)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an alternative method for retreiving seismic data that accepts optional processing commands.
Data requests are made through
the <code>timeseries</code> webservice and returned data are parsed using
the internal miniseed2Stream() function.
</p>
<p>If the location argument contains an empty string to specify a 'blank' location code, a location
code of <code>"--"</code> will be used in the dataselect request URL.
</p>
<p>The <code>processing</code> parameter can be used to specify any type of processing supported by the
<code>timeseries</code> webs service.  This string must begin with an ampersand and be ready to be appended to the request url, e.g.
<code>processing="&amp;demean=true&amp;taper0.2,HANNING"</code>.  This gives the user complete control over the number
and order of processing commands.
(See <a href="https://service.iris.edu/irisws/timeseries/1/">timeseries documentation</a>.)
</p>
<p>If <code>inclusiveEnd=FALSE</code>, then <code>getDataselect</code> will subtract 0.000001 seconds from the endtime before passing the 
value to the <code>dataselect</code> webservice. An endtime of, e.g., <code>as.POSIXct("2016-01-03", tz="GMT")</code> will be passed 
into <code>dataselect</code> as <code>end=2016-01-02T23:59:59.999999</code>. A data sample at time 2016-01-03T00:00:00 will not be returned
unless <code>inclusiveEnd=TRUE</code>.
</p>
<p>Sometimes the station webservice will return multiple records for the same SNCL,
each with a different scale or starttime.  These represent different <em>epochs</em> with
potentially different metadata parameters for the SNCL and, by default, will cause
a 'Multiple epochs' error message to be generated.
</p>
<p>Handling all possible metadata differences so that the data may be merged is beyond the scope of this
package. Instead, to avoid errors, users may specify <code>ignoreEpoch=TRUE</code> in which case
the very first SNCL-epoch encountered will be used and all others will be discarded.
</p>
<p>For access to restricted data, getDataselect will look for system environmental variable &quot;IrisClient_netrc&quot;
which should point to a .netrc authentication file.
</p>
<p>Error returns from the webservice will stop evaluation and generate an error message.
</p>


<h3>Value</h3>

<p>A new <code>Stream</code> object is returned.
</p>


<h3>Author(s)</h3>

<p>Jonathan Callahan <a href="mailto:jonathan.s.callahan@gmail.com">jonathan.s.callahan@gmail.com</a>
</p>


<h3>References</h3>

<p>The IRIS DMC timeseries webservice:
</p>
<p><a href="https://service.iris.edu/irisws/timeseries/1/">https://service.iris.edu/irisws/timeseries/1/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getDataselect">getDataselect</a></code>, 
<code><a href="#topic+getSNCL">getSNCL</a></code>, 
<code><a href="#topic+IrisClient-class">IrisClient-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Open a connection to IRIS DMC webservices (use debug=TRUE so we can see the URLs generated)
iris &lt;- new("IrisClient",debug=TRUE)

starttime &lt;- as.POSIXct("2013-06-01",tz="GMT")
endtime &lt;- starttime + 24*3600

# Get raw data and processed data
st1 &lt;- getDataselect(iris,"IU","ANMO","00","LHZ",starttime,endtime)
st2 &lt;- getTimeseries(iris,"IU","ANMO","00","LHZ",starttime,endtime,"&amp;demean=true&amp;taper=0.2,HANNING")

layout(matrix(seq(2)))
plot(st1)
plot(st2)

## End(Not run)
</code></pre>

<hr>
<h2 id='getTraveltime'>Retrieve seismic traveltime information from IRIS DMC</h2><span id='topic+getTraveltime'></span><span id='topic+getTraveltime+2CIrisClient+2Cnumeric+2Cnumeric+2Cnumeric+2Cnumeric+2Cnumeric-method'></span>

<h3>Description</h3>

<p>The <code>getTraveltime</code> method obtains seismic traveltime data from
the IRIS DMC <code>traveltime</code> web service and returns it in a dataframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTraveltime(obj, latitude, longitude, depth, staLatitude, staLongitude)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTraveltime_+3A_obj">obj</code></td>
<td>
<p> an <code>IrisClient</code> object </p>
</td></tr>
<tr><td><code id="getTraveltime_+3A_latitude">latitude</code></td>
<td>
<p> latitude of seismic event </p>
</td></tr>
<tr><td><code id="getTraveltime_+3A_longitude">longitude</code></td>
<td>
<p> longitude of seismic event </p>
</td></tr>
<tr><td><code id="getTraveltime_+3A_depth">depth</code></td>
<td>
<p> depth of seismic event </p>
</td></tr>
<tr><td><code id="getTraveltime_+3A_stalatitude">staLatitude</code></td>
<td>
<p> latitude of seismic station </p>
</td></tr>
<tr><td><code id="getTraveltime_+3A_stalongitude">staLongitude</code></td>
<td>
<p> longitude of seismic station </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>traveltime</code> web service calculates travel-times for seismic phases using a 1-D spherical earth model.
</p>


<h3>Value</h3>

<p>A dataframe with the following columns:
</p>
<pre>
distance, depth, phaseName, travelTime, rayParam, takeoff, incident
  puristDistance, puristName
</pre>
<p>Rows are ordered by <code>travelTime</code>.
</p>


<h3>Author(s)</h3>

<p>Jonathan Callahan <a href="mailto:jonathan@mazamascience.com">jonathan@mazamascience.com</a>
</p>


<h3>References</h3>

<p>The IRIS DMC traveltime web service:
</p>
<p><a href="https://service.iris.edu/irisws/traveltime/1/">https://service.iris.edu/irisws/traveltime/1/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IrisClient-class">IrisClient-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Open a connection to IRIS DMC webservices
iris &lt;- new("IrisClient")

# Two days around the "Nisqually Quake"
starttime &lt;- as.POSIXct("2001-02-27", tz="GMT")
endtime &lt;- starttime + 3600 * 24 * 2

# Find biggest seismic event over these two days -- it's the "Nisqually"
events &lt;- getEvent(iris, starttime, endtime, minmag=5.0)
bigOneIndex &lt;- which(events$magnitude == max(events$magnitude))
bigOne &lt;- events[bigOneIndex[1],]

# Find US stations that are available within an hour of the event
start &lt;- bigOne$time
end &lt;- start + 3600
availability &lt;- getAvailability(iris, "US", "", "", "BHZ",
                                starttime=start, endtime=end,
                                latitude=bigOne$latitude, longitude=bigOne$longitude,
                                minradius=0, maxradius=10)
    
# Get the station the furthest East
minLonIndex &lt;- which(availability$longitude == max(availability$longitude))
snclE &lt;- availability[minLonIndex,]

# Plot the BHZ signal from this station
st &lt;- getDataselect(iris,snclE$network,snclE$station,snclE$location,snclE$channel,
                    start,end)

# Check that there is only a single trace and then plot it
length(st@traces)
tr &lt;- st@traces[[1]]
plot(tr, subsampling=1) # need subsmpling=1 to add vertical lines with abline()

# Find travel times to this station
traveltimes &lt;- getTraveltime(iris, bigOne$latitude, bigOne$longitude, bigOne$depth,
                             snclE$latitude, snclE$longitude)

# Look at the list                             
traveltimes

# mark the P and S arrival times
pArrival &lt;- start + traveltimes$travelTime[traveltimes$phaseName=="P"]
sArrival &lt;- start + traveltimes$travelTime[traveltimes$phaseName=="S"] 
abline(v=pArrival, col='red')
abline(v=sArrival, col='blue')

## End(Not run)
</code></pre>

<hr>
<h2 id='getUnavailability'>Retrieve Channel metadata from IRIS DMC</h2><span id='topic+getUnavailability'></span><span id='topic+getUnavailability+2CIrisClient+2Ccharacter+2Ccharacter+2Ccharacter+2Ccharacter+2CPOSIXct+2CPOSIXct+2Clogical-method'></span><span id='topic+getUnavailability+2CIrisClient+2Ccharacter+2Ccharacter+2Ccharacter+2Ccharacter+2CPOSIXct+2CPOSIXct+2Cmissing-method'></span>

<h3>Description</h3>

<p>The <code>getUnavailability</code> method obtains metadata for channels that are not available from the IRIS DMC station web service
and returns it in a dataframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getUnavailability(obj, network, station, location, channel,
                  starttime, endtime, includerestricted,
                  latitude, longitude, minradius, maxradius)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getUnavailability_+3A_obj">obj</code></td>
<td>
 <p><code>IrisClient</code> object </p>
</td></tr>
<tr><td><code id="getUnavailability_+3A_network">network</code></td>
<td>
<p> character string with the two letter seismic network code </p>
</td></tr>
<tr><td><code id="getUnavailability_+3A_station">station</code></td>
<td>
<p> character string with the station code </p>
</td></tr>
<tr><td><code id="getUnavailability_+3A_location">location</code></td>
<td>
<p> character string with the location code </p>
</td></tr>
<tr><td><code id="getUnavailability_+3A_channel">channel</code></td>
<td>
<p> character string with the three letter channel code </p>
</td></tr>
<tr><td><code id="getUnavailability_+3A_starttime">starttime</code></td>
<td>
<p> POSIXct class specifying the starttime (GMT) </p>
</td></tr>
<tr><td><code id="getUnavailability_+3A_endtime">endtime</code></td>
<td>
<p> POSIXct class specifying the endtime (GMT) </p>
</td></tr>
<tr><td><code id="getUnavailability_+3A_includerestricted">includerestricted</code></td>
<td>
<p> optional logical identifying whether to report on restricted data (default=<code>FALSE</code>) </p>
</td></tr>
<tr><td><code id="getUnavailability_+3A_latitude">latitude</code></td>
<td>
<p> optional latitude used when specifying a location and radius </p>
</td></tr>
<tr><td><code id="getUnavailability_+3A_longitude">longitude</code></td>
<td>
<p> optional longitude used when specifying a location and radius </p>
</td></tr>
<tr><td><code id="getUnavailability_+3A_minradius">minradius</code></td>
<td>
<p> optional minimum radius used when specifying a location and radius </p>
</td></tr>
<tr><td><code id="getUnavailability_+3A_maxradius">maxradius</code></td>
<td>
<p> optional maximum radius used when specifying a location and radius </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>getUnavailability</code> method compares the results of the <code>getAvailability</code> and <code>getChannel</code>
methods and returns those records found only in the output of <code>getChannel</code>.
</p>
<p>Each of the arguments <code>network</code>, <code>station</code>, <code>location</code> or <code>channel</code> may contain
a valid code or a wildcard expression, e.g. &quot;BH?&quot; or &quot;*&quot;. Empty strings are converted to &quot;*&quot;.
Otherwise the ascii string that is used for
these values is simply inserted into the web service request URL.
</p>
<p>For more details see the <a href="https://service.iris.edu/fdsnws/station/1/">webservice documentation</a>.
</p>


<h3>Value</h3>

<p>A dataframe with the following columns:
</p>
<pre>
network, station, location, channel, latitude, longitude, elevation, depth,
  azimuth, dip, instrument, scale, scalefreq, scaleunits, samplerate, 
  starttime, endtime
</pre>


<h3>Author(s)</h3>

<p>Jonathan Callahan <a href="mailto:jonathan@mazamascience.com">jonathan@mazamascience.com</a>
</p>


<h3>References</h3>

<p>The IRIS DMC station webservice:
</p>
<p><a href="https://service.iris.edu/fdsnws/station/1/">https://service.iris.edu/fdsnws/station/1/</a>
</p>
<p>This implementation was inspired by the functionality in the obspy get_stations() method.
</p>
<p><a href="https://docs.obspy.org/packages/autogen/obspy.clients.fdsn.client.Client.get_stations.html">https://docs.obspy.org/packages/autogen/obspy.clients.fdsn.client.Client.get_stations.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IrisClient-class">IrisClient-class</a></code>, <code><a href="#topic+getAvailability">getAvailability</a></code>, <code><a href="#topic+getChannel">getChannel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Open a connection to IRIS DMC webservices
iris &lt;- new("IrisClient")

# Date of Nisqually quake
starttime &lt;- as.POSIXct("2001-02-28",tz="GMT")
endtime &lt;- starttime + 2*24*3600

# Use the getEvent web service to determine what events happened in this time period
result &lt;- try(events &lt;- getEvent(iris,starttime,endtime,6.0))
if (inherits(result,"try-error")) {
  message(geterrmessage())
} else {
  events

# biggest event is Nisqually
  eIndex &lt;- which(events$magnitude == max(events$magnitude))
  e &lt;- events[eIndex[1],]

# Find all BHZ channels that were NOT collecting data at the time of the quake 
# and within 5 degrees of the quake epicenter (or are otherwise unavailable from IRIS).
  result &lt;- try(channels &lt;- getUnavailability(iris,"*","*","*","BHZ",starttime,endtime,
                            lat=e$latitude,long=e$longitude,maxradius=5))
  if (inherits(result,"try-error")) {
    message(geterrmessage())
  } else {
    channels
  }
}
</code></pre>

<hr>
<h2 id='getUpDownTimes'>Determine times when a channel starts/stops collecting data</h2><span id='topic+getUpDownTimes'></span><span id='topic+getUpDownTimes+2CStream+2Cmissing+2Cmissing-method'></span><span id='topic+getUpDownTimes+2CStream+2Cnumeric+2Cnumeric-method'></span>

<h3>Description</h3>

<p>The <code>getUpDownTimes</code> method determines the on/off times for data collection within a <code>Stream</code>
and returns a list containing these times, ignoring <code>Trace</code>s with a duration less than <code>min_signal</code> as well as data dropouts that are less than <code>min_gap</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getUpDownTimes(x, min_signal, min_gap)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getUpDownTimes_+3A_x">x</code></td>
<td>
 <p><code>Stream</code> object </p>
</td></tr>
<tr><td><code id="getUpDownTimes_+3A_min_signal">min_signal</code></td>
<td>
<p> minimum <code>Trace</code> duration in seconds (default=30)</p>
</td></tr>
<tr><td><code id="getUpDownTimes_+3A_min_gap">min_gap</code></td>
<td>
<p> minimum gap in seconds (default=60)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code>Stream</code> object returned by <code><a href="#topic+getDataselect">getDataselect</a></code> contains a list of individual
<code>Trace</code> objects, each of which is guaranteed to contain a continuous array of 
data in the <code>Trace@data</code> slot. Each <code>Trace</code> also contains a <code>starttime</code> and an <code>endtime</code> representing
a period of uninterrupted data collection. Data dropouts are determined by first rejecting any <code>Trace</code>s of duration less than <code>min_signal</code>.
The temporal spacing between <code>Trace</code>s is then analyzed, ignoring spaces shorter than <code>min_gap</code>.
</p>
<p>This method first checks the SNCL id of each <code>Trace</code> to make sure they are identical
and throws an error if they are not.
</p>
<p>The first element returned is always the <code>starttime</code> associated the first <code>Trace</code>.  The last element is always the
<code>endtime</code> associated with the last trace.  Thus, when the first element is identical to the <code>starttime</code> of the web services data request this does not necessarily mean that the channel was down before this.
</p>
<p><b>NOTE: </b> Even when data are complete for the duration of the requested timespan, the last element returned may be earlier than the <code>endtime</code> of the web services data request by up to a second.
</p>


<h3>Value</h3>

<p>A vector of <code>POSIXct</code> datetimes associated with on/off transitions.
</p>


<h3>Author(s)</h3>

<p>Jonathan Callahan <a href="mailto:jonathan@mazamascience.com">jonathan@mazamascience.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotUpDownTimes">plotUpDownTimes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Open a connection to IRIS DMC webservices
iris &lt;- new("IrisClient")

starttime &lt;- as.POSIXct("2012-01-24", tz="GMT")
endtime &lt;- as.POSIXct("2012-01-25", tz="GMT")

# Get the waveform
st &lt;- getDataselect(iris,"AK","PIN","","BHZ",starttime,endtime)

# Determine up/down transitions, ignoring Traces &lt; 3 min and gaps &lt; 5 min
upDownTimes &lt;- getUpDownTimes(st, min_signal=180, min_gap=300)

# Or just plot them directly
plotUpDownTimes(st, min_signal=180, min_gap=300)

## End(Not run)
</code></pre>

<hr>
<h2 id='hilbert'>Hilbert of a seismic signal</h2><span id='topic+hilbert'></span><span id='topic+hilbert+2CTrace-method'></span>

<h3>Description</h3>

<p>The <code>hilbert</code> method of <code>Trace</code> objects returns a <code>Trace</code>
whose data have been replaced with the Hilbert transform of the seismic signal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hilbert(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hilbert_+3A_x">x</code></td>
<td>
<p>a <code>Trace</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Before calculating the Hilbert transform, the seismic trace is 'cleaned up' by removing the mean,
the trend and by applying a cosine taper.  See <a href="#topic+DDT">DDT</a> for more details.
</p>


<h3>Value</h3>

<p>A <code>Trace</code>
whose data have been replaced with the Hilbert transform of the seismic signal.
</p>


<h3>Note</h3>

<p>This algorithm is adapted from code in the <span class="pkg">seewave</span> package.
</p>


<h3>Author(s)</h3>

<p>Jonathan Callahan <a href="mailto:jonathan@mazamascience.com">jonathan@mazamascience.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Open a connection to IRIS DMC webservices
iris &lt;- new("IrisClient")

starttime &lt;- as.POSIXct("2010-02-27 06:00:00", tz="GMT")
endtime &lt;- as.POSIXct("2010-02-27 09:00:00", tz="GMT")

# Get the waveform
st &lt;- getDataselect(iris,"IU","ANMO","00","BHZ",starttime,endtime)
tr &lt;- st@traces[[1]]

# Create Hilbert transform of the trace
trh &lt;- hilbert(tr)

# Plot signal data and hilbert data
plot(tr@data, type='l', col='gray80')
points(trh@data, type='l', col='blue')

## End(Not run)
</code></pre>

<hr>
<h2 id='hilbertFFT'>Hilbert FFT</h2><span id='topic+hilbertFFT'></span>

<h3>Description</h3>

<p>The <code>hilbertFFT</code> function returns the complex Hilbert FFT of a timeseries signal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hilbertFFT(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hilbertFFT_+3A_x">x</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is intended for internal use by the hilbert() and envelope() methods of 
<code>Trace</code> objects.
</p>


<h3>Value</h3>

<p>A complex vector containing the Hilbert FFT of <code>x</code>.
</p>


<h3>Note</h3>

<p>This algorithm is adapted from code in the <span class="pkg">seewave</span> package.
</p>


<h3>Author(s)</h3>

<p>Jonathan Callahan <a href="mailto:jonathan@mazamascience.com">jonathan@mazamascience.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Open a connection to IRIS DMC webservices
iris &lt;- new("IrisClient")

starttime &lt;- as.POSIXct("2010-02-27 06:00:00", tz="GMT")
endtime &lt;- as.POSIXct("2010-02-27 09:00:00", tz="GMT")

# Get the waveform
st &lt;- getDataselect(iris,"IU","ANMO","00","BHZ",starttime,endtime)
tr &lt;- st@traces[[1]]

# Demean, detrend, cosine taper
tr &lt;- DDT(tr)

# Calculate Hilbert FFT of the trace data
hfft &lt;- hilbertFFT(tr@data)

# Plot signal, with Hilbert envelope
layout(1)
plot(tr@data, type='l', col='gray80', main="Signal and Envelope")
points(Mod(hfft), type='l', col='blue')

# 2 rows
layout(matrix(seq(2)))

# Show that Imaginary component of Hilbert transform has the
# original signal shifted by 90 degrees
ccf(tr@data,tr@data,lag.max=200,main="Auto-correlation of signal data")
ccf(tr@data,Im(hfft),lag.max=200,main="90 deg phase shift with Hilber transform")

# Restore default layout
layout(1)

## End(Not run)
</code></pre>

<hr>
<h2 id='IrisClient-class'> Class <code>"IrisClient"</code> </h2><span id='topic+IrisClient-class'></span><span id='topic+initialize+2CIrisClient-method'></span>

<h3>Description</h3>

<p>A class for making data and metadata requests from IRIS DMC web services.
</p>


<h3>Slots</h3>


<dl>
<dt><code>site</code>:</dt><dd><p>Object of class <code>"character"</code>:
this is the first part of the url that the web service will be pointed to, defaults to <code>https://service.iris.edu</code> </p>
</dd>
<dt><code>service_type</code>:</dt><dd><p>Object of class <code>"character"</code>:
defaults to <code>fdsnws</code>; for data retrieval from the IRIS PH5 repository, set this to <code>ph5ws</code>; </p>
</dd>
<dt><code>debug</code>:</dt><dd><p>Object of class <code>"logical"</code>:
when set to TRUE will cause any web service requestURL to be printed </p>
</dd>
<dt><code>useragent</code>:</dt><dd><p>Object of class <code>"character"</code>:
client identification string </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>getAvailability</dt><dd>
<p>makes a channel request of the station web service and returns the result as a dataframe; see <code><a href="#topic+getAvailability">getAvailability</a></code> </p>
</dd>
<dt>getChannel</dt><dd>
<p>makes a channel request of the station web service and returns the result as a dataframe; see <code><a href="#topic+getChannel">getChannel</a></code> </p>
</dd>
<dt>getDataAvailability</dt><dd>
<p>makes a channel request of the irisws availability web service and returns the result as a dataframe; see <code><a href="#topic+getDataAvailability">getDataAvailability</a></code></p>
</dd>
<dt>getDataselect</dt><dd>
<p>makes a request of the dataselect web service and returns a <code>Stream</code> object; see <code><a href="#topic+getDataselect">getDataselect</a></code> </p>
</dd>
<dt>getDistaz</dt><dd>
<p>makes a request of the distaz web service and returns a the information as a dataframe; see <code><a href="#topic+getDistaz">getDistaz</a></code> </p>
</dd>
<dt>getEvalresp</dt><dd>
<p>makes a request of the instrument response web service and returns the information as a dataframe; see <code><a href="#topic+getEvalresp">getEvalresp</a></code> </p>
</dd>
<dt>getEvent</dt><dd>
<p>makes a request of the event web service and returns the information as a dataframe,
if <code>site</code>='https://service.iris.edu' then <code>getEvent</code> will direct to &quot;https://earthquake.usgs.gov/fdsnws/event/1/query?&quot;; 
see <code><a href="#topic+getEvent">getEvent</a></code> </p>
</dd>
<dt>getNetwork</dt><dd>
<p>makes a network request of the station web service and returns the result as a dataframe; see <code><a href="#topic+getNetwork">getNetwork</a></code> </p>
</dd>
<dt>getSNCL:</dt><dd>
<p>calls the <code>getDataselect</code> method and returns a <code>Stream</code> object; see <code><a href="#topic+getSNCL">getSNCL</a></code> </p>
</dd>
<dt>getStation</dt><dd>
<p>makes a station request of the station web service and returns the result as a dataframe; see <code><a href="#topic+getStation">getStation</a></code> </p>
</dd>
<dt>getTraveltime</dt><dd>
<p>makes a request of the traveltime web service and returns the information as a dataframe; see <code><a href="#topic+getTraveltime">getTraveltime</a></code> </p>
</dd>
<dt>getUnavailability</dt><dd>
<p>makes a channel request of the station web service and returns the result as a dataframe; see <code><a href="#topic+getUnavailability">getUnavailability</a></code> </p>
</dd>
</dl>



<h3>Note</h3>

<p>The <code>IrisClient</code> object is inspired by the <code>clients.fdsn.client.Client</code> class found in the
python ObsPy package (<a href="https://docs.obspy.org/packages/autogen/obspy.clients.fdsn.client.Client.html">https://docs.obspy.org/packages/autogen/obspy.clients.fdsn.client.Client.html</a>).
</p>


<h3>Author(s)</h3>

<p>Jonathan Callahan <a href="mailto:jonathan@mazamascience.com">jonathan@mazamascience.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Open a connection to IRIS DMC webservices
iris &lt;- new("IrisClient", debug=TRUE)

starttime &lt;- as.POSIXct("2012-01-24", tz="GMT")
endtime &lt;- as.POSIXct("2012-01-25", tz="GMT")

# Get the waveform
st &lt;- getDataselect(iris,"AK","PIN","","BHZ",starttime,endtime)
mean(st)

## End(Not run)
</code></pre>

<hr>
<h2 id='McNamaraBins'>McNamara Binning</h2><span id='topic+McNamaraBins'></span>

<h3>Description</h3>

<p>The McNamaraBins() function implements the binning algorithm specified in
the &quot;Data Preparation and Processing&quot; section of
<a href="http://pubs.usgs.gov/of/2005/1438/pdf/OFR-1438.pdf">Seismic Noise Analysis System Using Power Spectral Density Probability Density Functions</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>McNamaraBins(df, loFreq, hiFreq, alignFreq)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="McNamaraBins_+3A_df">df</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> <code>dataframe</code> object</p>
</td></tr>
<tr><td><code id="McNamaraBins_+3A_lofreq">loFreq</code></td>
<td>
<p>optional lo end of frequency binning range (default=.005)</p>
</td></tr>
<tr><td><code id="McNamaraBins_+3A_hifreq">hiFreq</code></td>
<td>
<p>optional hi end of frequency binning range (default=10)</p>
</td></tr>
<tr><td><code id="McNamaraBins_+3A_alignfreq">alignFreq</code></td>
<td>
<p>optional alignment frequency for determining frequency bins (default=0.1)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The McNamaraBins() function accepts a dataframe with an arbitrary number of columns. At least one
of the columns must be named 'freq' and must contain frequency values. These frequencies will be used to assign all associated
values into appropriate bins according to the McNamara algorithm:
</p>
<p>Frequencies for binning are generated at 1/8 octave intervals aligned to <code>alignFreq</code>.
Binned values associated with each frequency bin are calculated by averaging incoming values over an entire octave
centered on that frequency.
</p>


<h3>Value</h3>

<p>A dataframe containing binned values is returned with the same column names as the incoming <code>df</code> argument.
</p>


<h3>Author(s)</h3>

<p>Jonathan Callahan <a href="mailto:jonathan@mazamascience.com">jonathan@mazamascience.com</a>
</p>


<h3>References</h3>

<p><a href="http://pubs.usgs.gov/of/2005/1438/pdf/OFR-1438.pdf">Seismic Noise Analysis System Using Power Spectral Density Probability Density Functions</a> (McNamara and Boaz 2005)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+McNamaraPSD">McNamaraPSD</a></code>
</p>

<hr>
<h2 id='McNamaraPSD'>Power Spectral Density</h2><span id='topic+McNamaraPSD'></span>

<h3>Description</h3>

<p>The McNamaraPSD() function implements the spectral density algorithm specified in
the &quot;Data Preparation and Processing&quot; section of
<a href="http://pubs.usgs.gov/of/2005/1438/pdf/OFR-1438.pdf">Seismic Noise Analysis System Using Power Spectral Density Probability Density Functions</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>McNamaraPSD(tr, loFreq=.005, hiFreq=10, alignFreq=0.1, binned=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="McNamaraPSD_+3A_tr">tr</code></td>
<td>
<p>a <code>Trace</code> object</p>
</td></tr>
<tr><td><code id="McNamaraPSD_+3A_lofreq">loFreq</code></td>
<td>
<p>optional lo end of frequency binning range</p>
</td></tr>
<tr><td><code id="McNamaraPSD_+3A_hifreq">hiFreq</code></td>
<td>
<p>optional hi end of frequency binning range</p>
</td></tr>
<tr><td><code id="McNamaraPSD_+3A_alignfreq">alignFreq</code></td>
<td>
<p>optional alignment frequency for determining frequency bins</p>
</td></tr>
<tr><td><code id="McNamaraPSD_+3A_binned">binned</code></td>
<td>
<p>logical determining whether the return spectrum is binned</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This PSD algorithm is designed to be used on one to three hour segments of seismic data and will return a <code>PSD</code> object
containing the (potentially binned) spectrum for that segment. See the <code><a href="#topic+psdList">psdList</a></code> function for
automatic segmenting of longer <code>Stream</code> objects.
</p>
<p>The McNamara PSD algorithm is similar to MATLAB's pwelch() function and has the following steps:
</p>

<ol>
<li><p>Calculate averaged spectrum
</p>
<pre>
# Truncate incoming segment of trace data to nearest power of 2 samples.
# Divide each truncated segment into 13 chunks with 75% overlap. The first
# chunk begins at 0/16 and ends at 4/16.  The 13'th chunk begins at 12/16
# and ends at 16/16.  The chunks overlap like this:
#   
#   1---5---9---3---
#    2---6---0---
#     3---7---1---
#      4---8---2---
# 
# Deman, detrend and taper the chunk.
# Calculate the 'one-sided' spectrum for the chunk.
#
# Average together all 13 spectra to get an averaged spectrum.
</pre>
</li>
<li><p>Create smoothed version of spectrum with binning
</p>
<p>When <code>binned=TRUE</code>, McNamara style binning is 
turned on and a smoothed spectrum is returned that contains many fewer points than the full spectrum.
When these arguments are not specified, binning is automatically turned off and the full spectrum is returned.
</p>
<p>Frequencies for binning are generated at 1/8 octave intervals aligned to <code>alignFreq</code>.
The power (dB) associated with each frequency bin is calculated by averaging over an entire octave
centered on that frequency.
</p>
<p><b>Note:</b> The spectra returned by McNamaraPSD() have not had instrument correction applied.
Use <code><a href="#topic+getEvalresp">getEvalresp</a></code> to get instrument correction values for specific frequencies.
</p>
</li>
<li><p>convert binned spectra to decibels
</p>
</li></ol>
 


<h3>Value</h3>

<p>An <span class="rlang"><b>R</b></span> <code>list</code> object with the following named elements:
</p>
<pre>
freq, spec, snclq, starttime, endtime
</pre>
<p>Elements <code>freq</code> and <code>spec</code> are numeric vectors while <code>snclq</code>, <code>starttime</code>
and <code>endtime</code> are single values.
</p>


<h3>Note</h3>

<p>During the binning process, an arithmetic mean is used to average together power levels in decibels.
This is equivalent to averaging of power levels before conversion to dB using a geometric mean.
</p>


<h3>Author(s)</h3>

<p>Jonathan Callahan <a href="mailto:jonathan@mazamascience.com">jonathan@mazamascience.com</a>
</p>


<h3>References</h3>

<p><a href="http://pubs.usgs.gov/of/2005/1438/pdf/OFR-1438.pdf">Seismic Noise Analysis System Using Power Spectral Density Probability Density Functions</a> (McNamara and Boaz 2005)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+McNamaraBins">McNamaraBins</a></code>,
<code><a href="#topic+psdList">psdList</a></code>
</p>

<hr>
<h2 id='mergeTraces'>Merge multiple traces into a single trace</h2><span id='topic+mergeTraces'></span><span id='topic+mergeTraces+2CStream+2Ccharacter-method'></span><span id='topic+mergeTraces+2CStream+2Cmissing-method'></span>

<h3>Description</h3>

<p>The <code>mergeTraces</code> method of <code>Stream</code> objects returns a new <code>Stream</code>
where all <code>Traces</code> have been merged into a single <code>Trace</code>. Gaps between
traces are replaced with values determined by the <code>fillMethod</code> parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeTraces(x, fillMethod)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergeTraces_+3A_x">x</code></td>
<td>
<p><code>Stream</code> object</p>
</td></tr>
<tr><td><code id="mergeTraces_+3A_fillmethod">fillMethod</code></td>
<td>
<p>method to use when filling gaps between <code>Traces</code> (default=<code>"fillNA"</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Available values for <code>fillMethod</code> include:
</p>

<ul>
<li><p><code>fillNA</code> &ndash; gaps are filled with <code>NA</code> (<span class="rlang"><b>R</b></span>'s missing value flag)
</p>
</li>
<li><p><code>fillZero</code> &ndash; gaps are filled with <code>0.0</code>
</p>
</li></ul>



<h3>Value</h3>

<p>A new <code>Stream</code> object containing a single <code>Trace</code> is returned.
</p>


<h3>Author(s)</h3>

<p>Jonathan Callahan <a href="mailto:jonathan@mazamascience.com">jonathan@mazamascience.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Open a connection to IRIS DMC webservices
iris &lt;- new("IrisClient")

starttime &lt;- as.POSIXct("2002-04-20", tz="GMT")
endtime &lt;- as.POSIXct("2002-04-21", tz="GMT")
st4 &lt;- getDataselect(iris,"US","OXF","","BHZ",starttime,endtime)
stm4 &lt;- mergeTraces(st4)

# plot merged trace
plot(stm4@traces[[1]])
mtext(paste(length(st4@traces),"traces"), side=3, line=0.5, adj=0.05, cex=1.5)      

## End(Not run)
</code></pre>

<hr>
<h2 id='mergeUpDownTimes'>Determine overlaps in two sets of upDownTimes.</h2><span id='topic+mergeUpDownTimes'></span><span id='topic+mergeUpDownTimes+2CNULL+2CPOSIXct+2Clogical-method'></span><span id='topic+mergeUpDownTimes+2CNULL+2CPOSIXct+2Cmissing-method'></span><span id='topic+mergeUpDownTimes+2CPOSIXct+2CNULL+2Clogical-method'></span><span id='topic+mergeUpDownTimes+2CPOSIXct+2CNULL+2Cmissing-method'></span><span id='topic+mergeUpDownTimes+2CPOSIXct+2CPOSIXct+2Clogical-method'></span><span id='topic+mergeUpDownTimes+2CPOSIXct+2CPOSIXct+2Cmissing-method'></span>

<h3>Description</h3>

<p>The <code>mergeUpDownTimes</code> function determines the overlaps in two sets of times representing up/down (on/off) periods for a single
or a set of channels.  This function can be used to determine overall station up/down periods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeUpDownTimes(udt1, udt2, bothOn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergeUpDownTimes_+3A_udt1">udt1</code></td>
<td>
<p>vector of <code>POSIXct</code> times representing up/down transitions</p>
</td></tr>
<tr><td><code id="mergeUpDownTimes_+3A_udt2">udt2</code></td>
<td>
<p>vector of <code>POSIXct</code> times representing up/down transitions</p>
</td></tr>
<tr><td><code id="mergeUpDownTimes_+3A_bothon">bothOn</code></td>
<td>
<p>logical specifying whether overlaps are determined with <code>AND</code> or <code>OR</code>
(default=FALSE: <code>udt1 OR udt2</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>bothOn=FALSE</code>, the default, this function returns the times of transitions from &quot;either to neither&quot; and back.
When <code>bothOn=TRUE</code>, this function returns the times of transitions from &quot;both to either&quot; and back.
</p>
<p>If an empty vector is passed in for <code>udt1</code> or <code>udt2</code> then the other vector is returned unchanged.  This can be useful
when merging the upDownTimes for multiple channels.  See the example below.
</p>


<h3>Value</h3>

<p>A vector of <code>POSIXct</code> datetimes associated with on/off transitions.
</p>


<h3>Note</h3>

<p>The vector of times in <code>udt1</code> and <code>udt2</code> has no information on the values of <code>min_signal</code> or <code>min_gap</code> that
were used to generate the timeseries.  It is up to the user to make sure that the incoming vectors are appropriate for comparison.
See <code><a href="#topic+getUpDownTimes">getUpDownTimes</a></code>.
</p>


<h3>Author(s)</h3>

<p>Jonathan Callahan <a href="mailto:jonathan@mazamascience.com">jonathan@mazamascience.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getUpDownTimes">getUpDownTimes</a></code>,
<code><a href="#topic+plotUpDownTimes">plotUpDownTimes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Open a connection to IRIS DMC webservices
iris &lt;- new("IrisClient")

# Three Streams, each with different upDownTimes
starttime &lt;- as.POSIXct("2012-07-01", tz="GMT")
endtime &lt;- as.POSIXct("2012-07-02", tz="GMT")
stE &lt;- getDataselect(iris,"IU","XMAS","10","BHE",starttime,endtime)
stN &lt;- getDataselect(iris,"IU","XMAS","10","BHN",starttime,endtime)
stZ &lt;- getDataselect(iris,"IU","XMAS","10","BHZ",starttime,endtime)
udtE &lt;- getUpDownTimes(stE)
udtN &lt;- getUpDownTimes(stN)
udtZ &lt;- getUpDownTimes(stZ)

udtAll &lt;- c()
udtAny &lt;- c()
for (udt in list(udtE, udtN, udtZ)) {
  udtAll &lt;- mergeUpDownTimes(udtAll,udt,bothOn=TRUE)
  udtAny &lt;- mergeUpDownTimes(udtAny,udt,bothOn=FALSE)
}

# 5 rows
layout(matrix(seq(5)))

# Plot the results
par(mar=c(3,4,3,2)) # adjust margins
plotUpDownTimes(udtE); title("BHE")
plotUpDownTimes(udtN); title("BHN")
plotUpDownTimes(udtZ); title("BHZ")
plotUpDownTimes(udtAll); title("ALL channels up")
plotUpDownTimes(udtAny); title("ANY channel up")

# Restore default layout
layout(1)

## End(Not run)
</code></pre>

<hr>
<h2 id='miniseed2Stream'>Convert miniSEED bytes to <code>Stream</code> object</h2><span id='topic+miniseed2Stream'></span>

<h3>Description</h3>

<p>The <code>miniseed2Stream</code> function converts raw miniSEED bytes into a <code>Stream</code>
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>miniseed2Stream(miniseed,url,requestedStarttime,requestedEndtime,
                sensor,scale,scalefreq,scaleunits,latitude,longitude,
                elevation, depth, azimuth,dip)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="miniseed2Stream_+3A_miniseed">miniseed</code></td>
<td>
<p>a vector of raw bytes read from a miniSEED file</p>
</td></tr>
<tr><td><code id="miniseed2Stream_+3A_url">url</code></td>
<td>
<p>character source location (see <a href="#topic+getDataselect">getDataselect</a>)</p>
</td></tr>
<tr><td><code id="miniseed2Stream_+3A_requestedstarttime">requestedStarttime</code></td>
<td>
<p><code>POSIXct</code> time associated with the requested starttime (see <a href="#topic+getDataselect">getDataselect</a>)</p>
</td></tr>
<tr><td><code id="miniseed2Stream_+3A_requestedendtime">requestedEndtime</code></td>
<td>
<p><code>POSIXct</code> time associated with the requested endtime (see <a href="#topic+getDataselect">getDataselect</a>)</p>
</td></tr>
<tr><td><code id="miniseed2Stream_+3A_sensor">sensor</code></td>
<td>
<p>character description of the Sensor type associated with this Station-Network-Channel-Location (SNCL) (see <a href="#topic+Trace">Trace</a>)</p>
</td></tr>
<tr><td><code id="miniseed2Stream_+3A_scale">scale</code></td>
<td>
<p>character description of the InstrumentSensitivity associated with this SNCL (see <a href="#topic+Trace">Trace</a>)</p>
</td></tr>
<tr><td><code id="miniseed2Stream_+3A_scalefreq">scalefreq</code></td>
<td>
<p>numeric description of frequency at which the InstrumentSensitivity is correct, the SensitivityFrequency (see <a href="#topic+Trace">Trace</a>)</p>
</td></tr>
<tr><td><code id="miniseed2Stream_+3A_scaleunits">scaleunits</code></td>
<td>
<p>character description of the InputUnits associated with this SNCL (see <a href="#topic+Trace">Trace</a>)</p>
</td></tr>
<tr><td><code id="miniseed2Stream_+3A_latitude">latitude</code></td>
<td>
<p>numeric latitude associated with this SNCL (see <a href="#topic+Trace">Trace</a>)</p>
</td></tr>
<tr><td><code id="miniseed2Stream_+3A_longitude">longitude</code></td>
<td>
<p>numeric longitude associated with this SNCL (see <a href="#topic+Trace">Trace</a>)</p>
</td></tr>
<tr><td><code id="miniseed2Stream_+3A_elevation">elevation</code></td>
<td>
<p>numeric elevation associated with this SNCL (see <a href="#topic+Trace">Trace</a>)</p>
</td></tr>
<tr><td><code id="miniseed2Stream_+3A_depth">depth</code></td>
<td>
<p>numeric depth associated with this SNCL (see <a href="#topic+Trace">Trace</a>)</p>
</td></tr>
<tr><td><code id="miniseed2Stream_+3A_azimuth">azimuth</code></td>
<td>
<p>numeric channel azimuth associated with this SNCL (see <a href="#topic+Trace">Trace</a>)</p>
</td></tr>
<tr><td><code id="miniseed2Stream_+3A_dip">dip</code></td>
<td>
<p>numeric channel dip associated with this SNCL (see <a href="#topic+Trace">Trace</a>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes raw bytes read in from a file or URL and converts them to a <code>Stream</code> object. Metadata information is optional.
This function is primarily for internal use.
</p>


<h3>Value</h3>

<p>A <code>Stream</code> object.</p>


<h3>Author(s)</h3>

<p>Jonathan Callahan <a href="mailto:jonathan@mazamascience.com">jonathan@mazamascience.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+readMiniseedFile">readMiniseedFile</a></code>
</p>

<hr>
<h2 id='multiplyBy'>Multiplication by a constant</h2><span id='topic+multiplyBy'></span><span id='topic+multiplyBy+2CStream+2Cnumeric-method'></span><span id='topic+multiplyBy+2CTrace+2Cnumeric-method'></span>

<h3>Description</h3>

<p>The <code>multiplyBy</code> methods of <code>Trace</code> and <code>Stream</code> objects return like objects
where all <code>@data</code> slots have been multiplied by a constant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiplyBy(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiplyBy_+3A_x">x</code></td>
<td>

<p>a <code>Trace</code> or <code>Stream</code> object
</p>
</td></tr>
<tr><td><code id="multiplyBy_+3A_y">y</code></td>
<td>

<p>a numeric multiplier
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new <code>Trace</code> or <code>Stream</code> object is returned.
</p>


<h3>Author(s)</h3>

<p>Jonathan Callahan <a href="mailto:jonathan@mazamascience.com">jonathan@mazamascience.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Open a connection to IRIS DMC webservices
iris &lt;- new("IrisClient")

starttime &lt;- as.POSIXct("2011-01-24", tz="GMT")
endtime &lt;- as.POSIXct("2011-01-25", tz="GMT")

# Get the waveform
stRaw &lt;- getDataselect(iris,"AK","PIN","","BHZ",starttime,endtime)

# obtain an instrument sensitivity value with getChannel metadata)
c &lt;- getChannel(iris, "AK","PIN","","BHZ",starttime, endtime)
sensitivityValue &lt;- c$scale

# convert raw data
st &lt;- multiplyBy(stRaw, 1/sensitivityValue)
rmsVariance(st)

# plot trace
plot(st, ylab=c$scaleunits)

## End(Not run)
</code></pre>

<hr>
<h2 id='noiseMatrix2PdfMatrix'>Convert matrix of PSDs to matrix of Probability Density Functions</h2><span id='topic+noiseMatrix2PdfMatrix'></span>

<h3>Description</h3>

<p>This function converts a <code>noiseMatrix</code> returned by either <code>psdList2NoiseMatrix</code> or <code>psdDF2NoiseMatrix</code>
into a matrix of Probability Density values as defined by McNamara and Boaz 2005.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>noiseMatrix2PdfMatrix(noiseMatrix, lo, hi, binSize)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="noiseMatrix2PdfMatrix_+3A_noisematrix">noiseMatrix</code></td>
<td>
<p>a <code>noiseMatrx</code> returned from either <code>psdList2NoiseMatrix</code> or <code>psdDF2NoiseMatrix</code></p>
</td></tr>
<tr><td><code id="noiseMatrix2PdfMatrix_+3A_lo">lo</code></td>
<td>
<p>lowest frequency bin (power level in dB) for the PDF y-axis (default=-200)</p>
</td></tr>
<tr><td><code id="noiseMatrix2PdfMatrix_+3A_hi">hi</code></td>
<td>
<p>highest frequency bin (power level in dB) for the PDF y-axis (default=-50)</p>
</td></tr>
<tr><td><code id="noiseMatrix2PdfMatrix_+3A_binsize">binSize</code></td>
<td>
<p>size in dB of each bin (default=1)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The McNamara and Boaz paper describes creating histograms of the discretized power levels at each frequency
bin associated with a set of PSDs. The value in each cell of the PDF matrix is the fraction of the corrected PSDs that
have that power level at that frequency bin.
</p>
<p>To return a PDF matrix that matches those in the McNamara paper, use the default settings.
</p>


<h3>Value</h3>

<p>A <code>matrix</code> is returned with one row for each power level (-250:-50 dB) and one column for each frequency bin.
</p>


<h3>Author(s)</h3>

<p>Jonathan Callahan <a href="mailto:jonathan@mazamascience.com">jonathan@mazamascience.com</a>
</p>


<h3>References</h3>

<p><a href="http://pubs.usgs.gov/of/2005/1438/pdf/OFR-1438.pdf">Seismic Noise Analysis System Using Power Spectral Density Probability Density Functions</a> (McNamara and Boaz 2005)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+McNamaraPSD">McNamaraPSD</a></code>,
<code><a href="#topic+psdDF2NoiseMatrix">psdDF2NoiseMatrix</a></code>,
<code><a href="#topic+psdList">psdList</a></code>,
<code><a href="#topic+psdPlot">psdPlot</a></code>,
<code><a href="#topic+psdStatistics">psdStatistics</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Create a new IrisClient
iris &lt;- new("IrisClient", debug=TRUE)

# Get seismic data
starttime &lt;- as.POSIXct("2011-05-05", tz="GMT") # 2011.125
endtime &lt;- starttime + 1*24*3600
st &lt;- getDataselect(iris,"IU","GRFO","--","BHE",starttime,endtime)

# Generate power spectral density for each hour long segment
psdList &lt;- psdList(st)

# Convert into corrected "noiseMatrix"
noiseMatrix &lt;- psdList2NoiseMatrix(psdList)

# Convert into McNamara "pdfMatrix"
pdfMatrix &lt;- noiseMatrix2PdfMatrix(noiseMatrix)

# NOTE:  Data need to be flipped and tranposed for the XY axes in the
# NOTE:  image() function to match rows and columns in our pdfMatrix
# Plot pdfMatrix
image(t(pdfMatrix[,ncol(pdfMatrix):1]),
      col=c('gray90',rainbow(9)),
      axes=FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='noiseModels'>Generate NHNM and NLNM noise models</h2><span id='topic+noiseModels'></span>

<h3>Description</h3>

<p>The <code>noiseModels</code> function returns the New High Noise Model and New Low Noise Model
from the Peterson paper referenced below. Values are returned for the specific frequencies specified in
the <code>freq</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>noiseModels(freq)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="noiseModels_+3A_freq">freq</code></td>
<td>
<p>a vector of frequencies at which to generate noise model values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list is returned with elements <code>nhnm</code> and <code>nlnm</code> containing the high and
low noise models, respectively.
</p>


<h3>Author(s)</h3>

<p>Jonathan Callahan <a href="mailto:jonathan@mazamascience.com">jonathan@mazamascience.com</a>
</p>


<h3>References</h3>

<p><a href="https://pubs.er.usgs.gov/publication/ofr93322">Observations of Modeling and Seismic Background Noise</a> (Peterson 1993)
<a href="https://pubs.usgs.gov/of/2005/1438/pdf/OFR-1438.pdf">Seismic Noise Analysis System Using Power Spectral Density Probability Density Functions</a> (McNamara and Boaz 2005)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+psdStatistics">psdStatistics</a></code>,
</p>

<hr>
<h2 id='psdDF2NoiseMatrix'>Apply instrument correction to PSDs</h2><span id='topic+psdDF2NoiseMatrix'></span>

<h3>Description</h3>

<p>The <code>psdDF2NoiseMatrix</code> function uses the <code>snclq</code> identifier associated with the
first PSD in the dataframe to obtain instrument correction information at the specified frequencies
from the <code><a href="#topic+getEvalresp">getEvalresp</a></code> web service if instrumentation correction information is
not supplied as an argument. This correction is applied to every PSD in 
the dataframe and the now corrected PSD values are returned as a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psdDF2NoiseMatrix(DF, evalresp=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psdDF2NoiseMatrix_+3A_df">DF</code></td>
<td>
<p>a dataframe of PSDs obtained from the <code>getPSDMeasurements</code> method of <code>IrisClient</code>.</p>
</td></tr>
<tr><td><code id="psdDF2NoiseMatrix_+3A_evalresp">evalresp</code></td>
<td>
<p>dataframe of freq, amp, phase information matching output of <code>getEvalresp</code>, optional.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is identical in behavior to <code><a href="#topic+psdList2NoiseMatrix">psdList2NoiseMatrix</a></code> except that the input object
is a dataframe of PSD values obtained from the MUSTANG Backend Storage System.
</p>


<h3>Value</h3>

<p>A <code>matrix</code> is returned with one row for each instrument-corrected PSD and one column for each frequency bin.
</p>


<h3>Note</h3>

<p>The incoming dataframe is checked to make sure that it represents only a single SNCL (Station-Network-Channel-Location). An error is generated if
more than one is found.  However, the <code>psdDF</code> is not checked to make sure that no changes to the
instrument correction happened during the time period covered by the <code>psdDF</code>. This occurs at an 'epoch'
boundary when an instrument is replaced.
</p>


<h3>Author(s)</h3>

<p>Jonathan Callahan <a href="mailto:jonathan@mazamascience.com">jonathan@mazamascience.com</a>
</p>


<h3>References</h3>

<p><a href="http://pubs.usgs.gov/of/2005/1438/pdf/OFR-1438.pdf">Seismic Noise Analysis System Using Power Spectral Density Probability Density Functions</a> (McNamara and Boaz 2005)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+McNamaraPSD">McNamaraPSD</a></code>,
<code><a href="#topic+psdList">psdList</a></code>,
<code><a href="#topic+psdList2NoiseMatrix">psdList2NoiseMatrix</a></code>,
<code><a href="#topic+psdPlot">psdPlot</a></code>,
<code><a href="#topic+psdStatistics">psdStatistics</a></code>
</p>

<hr>
<h2 id='psdList'>Apply McNamara PSD algorithm to a seismic signal</h2><span id='topic+psdList'></span>

<h3>Description</h3>

<p>The <code>psdList</code> function subsets a seismic <code>Stream</code> object into a series of
shorter segments with 50% overlap and uses the <code>McNamaraPSD</code> method to return a smoothed (aka binned)
Power Spectral Density (PSD) for each segment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psdList(st)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psdList_+3A_st">st</code></td>
<td>
<p>a <code>Stream</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code>Stream</code> will be subset into segments depending upon the channel identifier (@stats@channel) associated
with this seismic data.  The binning frequencies are also channel dependent as exemplified in 
this code extract where <code>Z</code> is the segment length in seconds:
</p>
<pre>
alignFreq &lt;- 0.1
  
if (stringr::str_detect(channel,"^L")) {
  Z &lt;- 3 * 3600
  loFreq &lt;- 0.001
  hiFreq &lt;- 0.5 * tr_merged@stats@sampling_rate
} else if (stringr::str_detect(channel,"^M")) {
  Z &lt;- 2 * 3600
  loFreq &lt;- 0.0025
  hiFreq &lt;- 0.5 * tr_merged@stats@sampling_rate
} else {
  Z &lt;- 3600
  loFreq &lt;- 0.005
  hiFreq &lt;- 0.5 * tr_merged@stats@sampling_rate
}
</pre>
<p>Each new segment starts half way through the previous segment. (50% overlap)
</p>


<h3>Value</h3>

<p>A list of <code>PSD</code> objects is returned. Each element of the list is
an <span class="rlang"><b>R</b></span> <code>list</code> object with the following elements:
</p>
<pre>
freq, spec, snclq, starttime, endtime
</pre>
<p><b>Note:</b> Individual PSDs have not had instrument correction applied.
</p>


<h3>Author(s)</h3>

<p>Jonathan Callahan <a href="mailto:jonathan@mazamascience.com">jonathan@mazamascience.com</a>
</p>


<h3>References</h3>

<p><a href="http://pubs.usgs.gov/of/2005/1438/pdf/OFR-1438.pdf">Seismic Noise Analysis System Using Power Spectral Density Probability Density Functions</a> (McNamara and Boaz 2005)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+McNamaraPSD">McNamaraPSD</a></code>,
<code><a href="#topic+psdList2NoiseMatrix">psdList2NoiseMatrix</a></code>,
<code><a href="#topic+psdPlot">psdPlot</a></code>,
<code><a href="#topic+psdStatistics">psdStatistics</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Create a new IrisClient
iris &lt;- new("IrisClient", debug=TRUE)

# Get seismic data
starttime &lt;- as.POSIXct("2011-05-05", tz="GMT") # 2011.125
endtime &lt;- starttime + 1*24*3600
st &lt;- getDataselect(iris,"IU","GRFO","--","BHE",starttime,endtime)

# Generate power spectral density for each hour long segment
psdList &lt;- psdList(st)

# Plot uncorrected PSDs
period &lt;- 1/psdList[[1]]$freq
plot(period, psdList[[1]]$spec, log='x', type='l',
     xlab="Period (Sec)", ylab="Power (dB)",
     main="Uncorrected PSDs")
     
for (i in seq(2:length(psdList))) {
  points(period, psdList[[i]]$spec, type='l')
}

## End(Not run)
</code></pre>

<hr>
<h2 id='psdList2NoiseMatrix'>Apply instrument correction to PSDs</h2><span id='topic+psdList2NoiseMatrix'></span>

<h3>Description</h3>

<p>The <code>psdList2NoiseMatrix</code> function uses the <code>snclq</code> identifier associated with the
first PSD in the list to obtain instrument correction information at the specified frequencies
from the <code><a href="#topic+getEvalresp">getEvalresp</a></code> web service if instrumentation correction information is
not supplied as an argument. This correction is applied to every PSD in 
the list and the now corrected PSD values are returned as a matrix. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psdList2NoiseMatrix(psdList, evalresp=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psdList2NoiseMatrix_+3A_psdlist">psdList</code></td>
<td>
<p>a list of PSDs generated by the <code>psdList</code> function</p>
</td></tr>
<tr><td><code id="psdList2NoiseMatrix_+3A_evalresp">evalresp</code></td>
<td>
<p>dataframe of freq, amp, phase information matching output of <code>getEvalresp</code>, optional</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>matrix</code> is returned with one row for each instrument-corrected PSD and one column for each frequency bin.
</p>


<h3>Note</h3>

<p>The <code>psdList</code> function generates a <code>psdList</code> from a single <code>Stream</code> of data and should thus only 
contain data for a single SNCL (Station-Network-Channel-Location). However, the <code>psdList</code> is not checked to make sure that no changes to the
instrument correction happened during the time period covered by the <code>psdList</code>.  This occurs at an 'epoch'
boundary when an instrument is replaced.
</p>


<h3>Author(s)</h3>

<p>Jonathan Callahan <a href="mailto:jonathan@mazamascience.com">jonathan@mazamascience.com</a>
</p>


<h3>References</h3>

<p><a href="http://pubs.usgs.gov/of/2005/1438/pdf/OFR-1438.pdf">Seismic Noise Analysis System Using Power Spectral Density Probability Density Functions</a> (McNamara and Boaz 2005)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+McNamaraPSD">McNamaraPSD</a></code>,
<code><a href="#topic+psdDF2NoiseMatrix">psdDF2NoiseMatrix</a></code>,
<code><a href="#topic+psdList">psdList</a></code>,
<code><a href="#topic+psdPlot">psdPlot</a></code>,
<code><a href="#topic+psdStatistics">psdStatistics</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Create a new IrisClient
iris &lt;- new("IrisClient", debug=TRUE)

# Get seismic data
starttime &lt;- as.POSIXct("2011-05-05", tz="GMT") # 2011.125
endtime &lt;- starttime + 1*24*3600
st &lt;- getDataselect(iris,"IU","GRFO","--","BHE",starttime,endtime)

# Generate power spectral density for each hour long segment
psdList &lt;- psdList(st)

# Convert into corrected "noiseMatrix"
noiseMatrix &lt;- psdList2NoiseMatrix(psdList)

# Plot corrected PSDs
period &lt;- 1/psdList[[1]]$freq
plot(period, noiseMatrix[1,], log='x', type='l',
     ylim=c(-200,-50),
     xlab="Period (Sec)", ylab="Power (dB)",
     main="Corrected PSDs")
     
for (i in seq(2:nrow(noiseMatrix))) {
  points(period, noiseMatrix[i,], type='l')
}

## End(Not run)
</code></pre>

<hr>
<h2 id='psdPlot'>Generate plots from a set of PSDs</h2><span id='topic+psdPlot'></span>

<h3>Description</h3>

<p>The <code>psdPlot</code> function is used to generate plots from the data in a <code>psdList</code>
or <code>psdDF</code> dataframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psdPlot(PSDs, style='psd', evalresp=NULL, ylo=-200, yhi=-50, showNoiseModel=TRUE, 
        showMaxMin=TRUE, showMode=TRUE, showMean=FALSE, showMedian=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psdPlot_+3A_psds">PSDs</code></td>
<td>
<p>either a list as returned by <code>psdList</code> or a dataframe of PSD values obtained from the BSS</p>
</td></tr>
<tr><td><code id="psdPlot_+3A_style">style</code></td>
<td>
<p>character identifier of plot type: <code>'psd'</code> plots PSD lines, <code>'pdf'</code> plots the <code>pdfMatrix</code></p>
</td></tr>
<tr><td><code id="psdPlot_+3A_evalresp">evalresp</code></td>
<td>
<p>dataframe of freq, amp, phase information matching output of <code>getEvalresp</code>, optional</p>
</td></tr>
<tr><td><code id="psdPlot_+3A_ylo">ylo</code></td>
<td>
<p>numeric setting lower limit of plot y-axis (default=<code>-200</code>)</p>
</td></tr>
<tr><td><code id="psdPlot_+3A_yhi">yhi</code></td>
<td>
<p>numeric setting upper limit of plot y-axis (default=<code>-50</code>)</p>
</td></tr>
<tr><td><code id="psdPlot_+3A_shownoisemodel">showNoiseModel</code></td>
<td>
<p>logical controlling plotting of noise model lines (default=<code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="psdPlot_+3A_showmaxmin">showMaxMin</code></td>
<td>
<p>logical controlling plotting of PSD max and min lines (default=<code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="psdPlot_+3A_showmode">showMode</code></td>
<td>
<p>logical controlling plotting of PDF mode line (default=<code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="psdPlot_+3A_showmean">showMean</code></td>
<td>
<p>logical controlling plotting of PSD mean line (default=<code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="psdPlot_+3A_showmedian">showMedian</code></td>
<td>
<p>logical controlling plotting of PSD median line (default=<code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="psdPlot_+3A_...">...</code></td>
<td>
<p>arguments to be passed to plotting methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>psdPlot</code> function creates visualizations for sets of PSDs. Plots generated with <code>style='pdf'</code>
mimic the plots presented in the McNamara paper.
</p>


<h3>Author(s)</h3>

<p>Jonathan Callahan <a href="mailto:jonathan@mazamascience.com">jonathan@mazamascience.com</a>
</p>


<h3>References</h3>

<p><a href="http://pubs.usgs.gov/of/2005/1438/pdf/OFR-1438.pdf">Seismic Noise Analysis System Using Power Spectral Density Probability Density Functions</a> (McNamara and Boaz 2005)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+McNamaraPSD">McNamaraPSD</a></code>,
<code><a href="#topic+psdList">psdList</a></code>,
<code><a href="#topic+psdStatistics">psdStatistics</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Create a new IrisClient
iris &lt;- new("IrisClient", debug=TRUE)

# Get seismic data
starttime &lt;- as.POSIXct("2011-05-05", tz="GMT") # 2011.125
endtime &lt;- starttime + 1*24*3600
st &lt;- getDataselect(iris,"IU","GRFO","--","BHE",starttime,endtime)

# Generate power spectral density for each hour long segment
psdList &lt;- psdList(st)

# 'psd' line plot
psdPlot(psdList,style='psd',type='l',col=adjustcolor('black',0.3))

# McNamara 'pdf' plot
psdPlot(psdList,style='pdf')

## End(Not run)
</code></pre>

<hr>
<h2 id='psdStatistics'>Return statistics for a set of PSDs</h2><span id='topic+psdStatistics'></span>

<h3>Description</h3>

<p>The <code>psdStatistics</code> function calculates a variety of information associated with the incoming set of PSDs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psdStatistics(PSDs, evalresp=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psdStatistics_+3A_psds">PSDs</code></td>
<td>
<p>either a list as returned by <code>psdList</code> or a dataframe of PSD values obtained from the BSS</p>
</td></tr>
<tr><td><code id="psdStatistics_+3A_evalresp">evalresp</code></td>
<td>
<p>dataframe of freq, amp, phase information matching output of <code>getEvalresp</code>, optional</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of elements:
</p>

<ul>
<li><p><code>noiseMatrix</code> &ndash; matrix of corrected power levels; rows=PSDs, columns=frequencies
</p>
</li>
<li><p><code>pdfMatrix</code> &ndash; matrix of probability density values; rows=dB level, columns=frequencies
</p>
</li>
<li><p><code>freq</code> &ndash; vector of frequencies associated statistics vectors and with matrix columns
</p>
</li>
<li><p><code>pdfBins</code> &ndash; vector of power values (dB) associated with <code>pdfMatrix</code> rows
</p>
</li>
<li><p><code>max</code> &ndash; maximum power level at each frequency
</p>
</li>
<li><p><code>min</code> &ndash; minimum power level at each frequency
</p>
</li>
<li><p><code>mean</code> &ndash; mean power level at each frequency
</p>
</li>
<li><p><code>median</code> &ndash; median power level at each frequency
</p>
</li>
<li><p><code>mode</code> &ndash; mode of power level at each frequency (obtained from <code>pdfMatrix</code>)
</p>
</li>
<li><p><code>nlnm</code> &ndash; low noise model power level at each frequency
</p>
</li>
<li><p><code>nhnm</code> &ndash; high noise model power level at each frequency
</p>
</li>
<li><p><code>pct_above</code> &ndash; percent of PSDs above the high noise model at each frequency
</p>
</li>
<li><p><code>pct_below</code> &ndash; percent of PSDS below the low noise model at each frequency
</p>
</li></ul>

<p>A variety of plots can be generated form the information in this list.
</p>


<h3>Author(s)</h3>

<p>Jonathan Callahan <a href="mailto:jonathan@mazamascience.com">jonathan@mazamascience.com</a>
</p>


<h3>References</h3>

<p><a href="http://pubs.usgs.gov/of/2005/1438/pdf/OFR-1438.pdf">Seismic Noise Analysis System Using Power Spectral Density Probability Density Functions</a> (McNamara and Boaz 2005)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+McNamaraPSD">McNamaraPSD</a></code>,
<code><a href="#topic+psdList">psdList</a></code>,
<code><a href="#topic+psdPlot">psdPlot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Create a new IrisClient
iris &lt;- new("IrisClient", debug=TRUE)

# Get seismic data
starttime &lt;- as.POSIXct("2011-05-05", tz="GMT") # 2011.125
endtime &lt;- starttime + 1*24*3600
st &lt;- getDataselect(iris,"IU","GRFO","--","BHE",starttime,endtime)

# Generate power spectral density for each hour long segment
psdList &lt;- psdList(st)

# Generate Statistics
stats &lt;- psdStatistics(psdList)

# Just for fun plot
logPeriod &lt;- log10(1/stats$freq)
plot(logPeriod,stats$max,ylim=c(-200,-50), las=1,
     xlab="log10(period)", ylab="Power (dB)",
     main="Model 'normal background noise' area and area of seismic signal.")
points(logPeriod,stats$min)

# Overlay a polygon showing the range between the noise models
x &lt;- c(logPeriod,rev(logPeriod),logPeriod[1])
y &lt;- c(stats$nhnm,rev(stats$nlnm),stats$nhnm[1])
transparentBlack &lt;- adjustcolor('black',0.4)
polygon(x,y,col=transparentBlack)

# Overlay a polygon showing the range of measured values
y &lt;- c(stats$max,rev(stats$min),stats$max[1])
transparentBlue &lt;- adjustcolor('blue',0.6)
polygon(x,y,col=transparentBlue)  

## End(Not run)
</code></pre>

<hr>
<h2 id='readMiniseedFile'>Convert miniSEED file to <code>Stream</code> object</h2><span id='topic+readMiniseedFile'></span>

<h3>Description</h3>

<p>The <code>readMiniseedFile</code> function converts a raw miniSEED file into a <code>Stream</code>
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readMiniseedFile(file,sensor,scale,scalefreq,scaleunits,
                 latitude,longitude,elevation,depth,azimuth,dip)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readMiniseedFile_+3A_file">file</code></td>
<td>
<p>character path of a miniSEED file</p>
</td></tr>
<tr><td><code id="readMiniseedFile_+3A_sensor">sensor</code></td>
<td>
<p>character description of the Sensor associated with this Station-Network-Channel-Location (SNCL) (see <a href="#topic+Trace">Trace</a>)</p>
</td></tr>
<tr><td><code id="readMiniseedFile_+3A_scale">scale</code></td>
<td>
<p>numeric description of the InstrumentSensitivity associated with this SNCL (see <a href="#topic+Trace">Trace</a>)</p>
</td></tr>
<tr><td><code id="readMiniseedFile_+3A_scalefreq">scalefreq</code></td>
<td>
<p>numeric description of frequency at which the InstrumentSensitivity is correct, the SensitivityFrequency (see <a href="#topic+Trace">Trace</a>)</p>
</td></tr>
<tr><td><code id="readMiniseedFile_+3A_scaleunits">scaleunits</code></td>
<td>
<p>character description of the InputUnits associated with this SNCL (see <a href="#topic+Trace">Trace</a>)</p>
</td></tr>
<tr><td><code id="readMiniseedFile_+3A_latitude">latitude</code></td>
<td>
<p>numeric latitude associated with this SNCL (see <a href="#topic+Trace">Trace</a>)</p>
</td></tr>
<tr><td><code id="readMiniseedFile_+3A_longitude">longitude</code></td>
<td>
<p>numeric longitude associated with this SNCL (see <a href="#topic+Trace">Trace</a>)</p>
</td></tr>
<tr><td><code id="readMiniseedFile_+3A_elevation">elevation</code></td>
<td>
<p>numeric elevation associated with this SNCL (see <a href="#topic+Trace">Trace</a>)</p>
</td></tr>
<tr><td><code id="readMiniseedFile_+3A_depth">depth</code></td>
<td>
<p>numeric depth associated with this SNCL (see <a href="#topic+Trace">Trace</a>)</p>
</td></tr>
<tr><td><code id="readMiniseedFile_+3A_azimuth">azimuth</code></td>
<td>
<p>numeric channel azimuth associated with this SNCL (see <a href="#topic+Trace">Trace</a>)</p>
</td></tr>
<tr><td><code id="readMiniseedFile_+3A_dip">dip</code></td>
<td>
<p>numeric channel dip associated with this SNCL (see <a href="#topic+Trace">Trace</a>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function reads in a raw miniSEED file and converts it to a <code>Stream</code> object. Metadata information is optional.
</p>


<h3>Value</h3>

<p>A <code>Stream</code> object.</p>


<h3>Author(s)</h3>

<p>Jonathan Callahan <a href="mailto:jonathan@mazamascience.com">jonathan@mazamascience.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+miniseed2Stream">miniseed2Stream</a></code>
</p>

<hr>
<h2 id='rms'>Root Mean Square and RMS Variance</h2><span id='topic+rms'></span><span id='topic+rms+2CTrace+2Clogical-method'></span><span id='topic+rms+2CTrace+2Cmissing-method'></span><span id='topic+rmsVariance+2CTrace+2Clogical-method'></span><span id='topic+rmsVariance+2CTrace+2Cmissing-method'></span><span id='topic+parallelRms'></span><span id='topic+rmsVariance'></span><span id='topic+parallelRmsVariance'></span>

<h3>Description</h3>

<p>The <code>rms</code> and <code>rmsVariance</code> methods of <code>Trace</code> and <code>Stream</code> objects compute the 
Root Mean Square (RMS) amplitude or RMS variance of the associated data in each object.
RMS variance removes the DC level from the seismic signal so that the zero line
is consistent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rms(x, na.rm)
parallelRms(x, na.rm)
rmsVariance(x, na.rm)
parallelRmsVariance(x, na.rm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rms_+3A_x">x</code></td>
<td>
<p> a <code>Trace</code> or <code>Stream</code> object </p>
</td></tr>
<tr><td><code id="rms_+3A_na.rm">na.rm</code></td>
<td>
<p> a logical specifying whether missing values should be removed </p>
</td></tr>
</table>


<h3>Details</h3>

<p><b>Trace method</b>
</p>
<p>The RMS amplitude of a single <code>Trace</code> is calculated as:
</p>
<p style="text-align: center;"><code class="reqn">rms(x) = \sqrt{ \frac{\sum_1^n{(x_i)^2}}{n} } </code>
</p>

<p>The RMS variance of a single <code>Trace</code> is calculated as:
</p>
<p style="text-align: center;"><code class="reqn">rmsVariance(x) = \sqrt{ \frac{\sum_1^n{(x_i - \bar{x})^2}}{n} } </code>
</p>

<p>where <code class="reqn">x</code> is the vector of data values and <code class="reqn">n</code> is the length of that vector.
</p>
<p><b>Stream methods</b>
</p>
<p>For <code>Stream</code> objects, data from all <code>Trace</code>s in the stream
are first extracted and concatenated into a single numeric vector after which the
algorithm is applied.
</p>
<p>The <code>parallel~</code> version of this method is only available on <code>Stream</code> objects
and returns a vector of values, one for each <code>Trace</code>.
</p>
<p>By default, the <code>Stream</code> versions of these methods use <code>na.rm=FALSE</code> as there
should be no missing datapoints in each <code>Trace</code>. The <code>Trace</code> methods default to 
<code>na.rm=TRUE</code> to accommodate merged traces where gaps between traces have been
filled with <code>NA</code>s.
</p>


<h3>Value</h3>

<p>A single numeric value is returned or <code>NA</code> if the trace has no data.
</p>
<p>A numeric vector is returned for <code>parallelRmsVariance</code>.
</p>


<h3>Author(s)</h3>

<p>Jonathan Callahan <a href="mailto:jonathan@mazamascience.com">jonathan@mazamascience.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# Open a connection to IRIS DMC webservices
iris &lt;- new("IrisClient")

starttime &lt;- as.POSIXct("2012-01-24", tz="GMT")
endtime &lt;- as.POSIXct("2012-01-25", tz="GMT")

# Get the waveform
st &lt;- getDataselect(iris,"AK","PIN","","BHZ",starttime,endtime)

# Get the first trace and generate some statistics
tr &lt;- st@traces[[1]]
rmsVariance(tr)

## End(Not run)
</code></pre>

<hr>
<h2 id='rotate2D'>Rotate horizontal components of a seismic signal</h2><span id='topic+rotate2D'></span>

<h3>Description</h3>

<p>The rotate2D() function rotates the two horizontal components of a
seismic signal into Radial and Transverse components returned as a list of 2 <code>Stream</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotate2D(st1, st2, angle)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotate2D_+3A_st1">st1</code></td>
<td>
<p>horizontal <code>Stream</code> from a channel set (channel name usually ending in &quot;N&quot;, &quot;E&quot;, &quot;1&quot;, or &quot;2&quot;)</p>
</td></tr>
<tr><td><code id="rotate2D_+3A_st2">st2</code></td>
<td>
<p>horizontal <code>Stream</code> from a channel set, complementary to st1</p>
</td></tr>
<tr><td><code id="rotate2D_+3A_angle">angle</code></td>
<td>
<p>angle (degrees) of the rotation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>rotation</code> web service returns Radial and Transverse seismic Streams, generated by
rotating <code>st1</code> and <code>st2</code> by <code>angle</code> degrees.
</p>
<p>The rotation service uses the following transformation matrix to change the output vectors for 2-D horizontal transformations
</p>
<p style="text-align: center;"><code class="reqn"> M_{2D} = \left[ \begin{array}{cc} cos \alpha &amp; sin \alpha \cr -sin \alpha &amp; cos \alpha \end{array} \right] </code>
</p>

<p style="text-align: center;"><code class="reqn"> \left[ \begin{array}{c} R \cr T \end{array} \right] = M_{2D} \left[ \begin{array}{c} N \cr E \end{array} \right] </code>
</p>

<p>where :
</p>
<pre>
   N and E represent data from the original (horizontal) orientations.
   R and T represent the Radial and Transverse components.
   \eqn{\alpha} is the azimuth angle measured clockwise from north.
  </pre>


<h3>Value</h3>

<p>A list of two <code>Stream</code> objects <code>stR</code> and <code>stT</code> is returned.
</p>


<h3>Note</h3>

<p>N and E are determined by the <code>Stream</code> @stats@azimuth values. If <code>Stream</code> @stats@azimuth values are not defined, 
st1 is assumed to be N and st2 is assumed to be E. Orthogonality is also assumed to be correct.
</p>


<h3>Author(s)</h3>

<p>Jonathan Callahan <a href="mailto:jonathan@mazamascience.com">jonathan@mazamascience.com</a>
</p>


<h3>References</h3>

<p>IRIS DMC rotation web service:
</p>
<p><a href="https://service.iris.edu/irisws/rotation/1/">https://service.iris.edu/irisws/rotation/1/</a>
</p>

<hr>
<h2 id='slice'>Slice a section out of a <code>Trace</code> or <code>Stream</code></h2><span id='topic+slice'></span><span id='topic+slice+2CTrace+2CPOSIXct+2CPOSIXct-method'></span>

<h3>Description</h3>

<p>The <code>slice</code> methods of <code>Trace</code> and <code>Stream</code> objects return like objects
that are subsets of the original.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slice(x, starttime, endtime)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slice_+3A_x">x</code></td>
<td>
<p> a <code>Trace</code> or <code>Stream</code> object</p>
</td></tr>
<tr><td><code id="slice_+3A_starttime">starttime</code></td>
<td>
<p> time at which the slice should begin </p>
</td></tr>
<tr><td><code id="slice_+3A_endtime">endtime</code></td>
<td>
<p> time at which the slice should end </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The returned object will always be a subset of the <code>x</code> argument whose time range is the
intersection of the original time range and the requested range.  When there is no intersection
or when <code>starttime &gt; endtime</code> an error is generated.
</p>
<p>All metadata associated with the returned <code>Trace</code> or <code>Stream</code> will reflect
the new object, rather than the original.
</p>


<h3>Value</h3>

<p>A new <code>Trace</code> or <code>Stream</code> object is returned.
</p>


<h3>Author(s)</h3>

<p>Jonathan Callahan <a href="mailto:jonathan@mazamascience.com">jonathan@mazamascience.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Open a connection to IRIS DMC webservices
iris &lt;- new("IrisClient")

starttime &lt;- as.POSIXct("2002-04-20", tz="GMT")
endtime &lt;- as.POSIXct("2002-04-21", tz="GMT")

# Get the waveform
st &lt;- getDataselect(iris,"US","OXF","","BHZ",starttime,endtime)

# This Stream object consists of 5 Traces
length(st@traces)

# Plotting the third trace shows a small quake
plot(st@traces[[3]])

# We can slice out the hour that has the quake signal
sliceStart &lt;- as.POSIXct("2002-04-20 10:30:00", tz="GMT")
sliceEnd &lt;- as.POSIXct("2002-04-20 11:30:00", tz="GMT")
stSlice &lt;- slice(st, sliceStart, sliceEnd)

# Now we only have one Trace of an hour duration
length(stSlice@traces)
stSlice@traces[[1]]@stats
# And a better look at the quake signal
plot(stSlice@traces[[1]])

## End(Not run)
</code></pre>

<hr>
<h2 id='STALTA'>STA/LTA</h2><span id='topic+STALTA'></span><span id='topic+STALTA+2CTrace+2Cmissing+2Cmissing+2Cmissing+2Cmissing+2Cmissing+2Cmissing+2Cmissing-method'></span><span id='topic+STALTA+2CTrace+2Cnumeric+2Cnumeric+2Ccharacter+2Clogical+2Clogical+2Cnumeric+2Cnumeric-method'></span><span id='topic+STALTA+2CTrace+2Cnumeric+2Cnumeric+2Ccharacter+2Cmissing+2Cmissing+2Cmissing+2Cmissing-method'></span><span id='topic+STALTA+2CTrace+2Cnumeric+2Cnumeric+2Cmissing+2Cmissing+2Cmissing+2Cmissing+2Cmissing-method'></span>

<h3>Description</h3>

<p>The <code>STALTA</code> method of <code>Trace</code> objects applies one of several STA/LTA
&quot;first break picking&quot; algorithms to <code>Trace</code> data in order to automatically
detect seismic events.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>STALTA(x, staSecs, ltaSecs, algorithm, demean, detrend, taper, increment)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="STALTA_+3A_x">x</code></td>
<td>
<p>a <code>Trace</code> object</p>
</td></tr>
<tr><td><code id="STALTA_+3A_stasecs">staSecs</code></td>
<td>
<p>length of the <b>S</b>hort averaging window in secs (default=3)</p>
</td></tr>
<tr><td><code id="STALTA_+3A_ltasecs">ltaSecs</code></td>
<td>
<p>length of the <b>L</b>ong averaging windowin secs (default=30)</p>
</td></tr>
<tr><td><code id="STALTA_+3A_algorithm">algorithm</code></td>
<td>
<p>algorithm to be used (default=&quot;classic_LR&quot;)</p>
</td></tr>
<tr><td><code id="STALTA_+3A_demean">demean</code></td>
<td>
<p>boolean flag determining whether to demean the data before applying the algorithm (default=<code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="STALTA_+3A_detrend">detrend</code></td>
<td>
<p>boolean flag determining whether to detrend the data before applying the algorithm (default=<code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="STALTA_+3A_taper">taper</code></td>
<td>
<p>proportion of the signal to be tapered at each end before applying the algorithm (default=0.0)</p>
</td></tr>
<tr><td><code id="STALTA_+3A_increment">increment</code></td>
<td>
<p>the increment to use when sliding the averaging windows to the next location (default=1).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, this method uses the &quot;classic_LR&quot; algorithm which calculates the average power in the <code>Trace</code> 
data over a short window (STA) and a long window (LTA). With this algorithm, windows are &quot;left/right aligned&quot; meaning 
that the point for which STA/LTA is calculated is at the lefttmost edge of the STA window
and the rightmost edge of the LTA window.
The resulting STA/LTA ratio thus has the same number of points as the original data.  This is a standard method
of &quot;first break picking&quot; and can be used to identify the onset of a seismic event.
</p>
<p>Three different algorithms are currently available:
</p>
<p><b>1) <code>algorithm="classic_RR"</code></b> This is the original STA/LTA algorithm with &quot;right alignment&quot;.
</p>
<p style="text-align: center;"><code class="reqn"> STA(x_i) = \frac{1}{ns}\sum_{j=i-ns}^{i}{x_i^2} </code>
</p>

<p style="text-align: center;"><code class="reqn"> LTA(x_i) = \frac{1}{nl}\sum_{j=i-nl}^{i}{x_i^2} </code>
</p>

<p style="text-align: center;"><code class="reqn"> r_i = \frac{STA_i}{LTA_i} </code>
</p>

<pre>
[---------- LTA ---------*]
                [-- STA -*]
</pre>
<p><b>2) <code>algorithm="classic_LR"</code></b> (default) This algorithm has the index at the left edge of the STA window
and the right edge of the LTA window
</p>
<p style="text-align: center;"><code class="reqn"> STA(x_i) = \frac{1}{ns}\sum_{j=i}^{i+ns}{x_i^2} </code>
</p>

<p style="text-align: center;"><code class="reqn"> LTA(x_i) = \frac{1}{nl}\sum_{j=i-nl}^{i}{x_i^2} </code>
</p>

<p style="text-align: center;"><code class="reqn"> r_i = \frac{STA_i}{LTA_i} </code>
</p>

<pre>
[---------- LTA --------*]
                       [*- STA --]
</pre>
<p><b>3) <code>algorithm="EarleAndShearer_envelope"</code></b>
</p>
<p style="text-align: center;"><code class="reqn"> STA(x_i) = \frac{1}{ns} \sum_{j=i}^{i+ns}{Mod(H(x))_i} </code>
</p>

<p style="text-align: center;"><code class="reqn"> LTA(x_i)= \frac{1}{nl} \sum_{j=i-nl}^{i}{Mod(H(x))_i} </code>
</p>

<p style="text-align: center;"><code class="reqn"> r_i = \frac{STA_i}{LTA_i} </code>
</p>

<pre>
[---------- LTA ---------*]
                        [*- STA --]
</pre>
<p>where <code class="reqn">H(x)</code> is the Hilbert transform of the data and <code class="reqn">Mod(H(x))</code> is the 'envelope' of the seismic signal.
<em>Note that because the Hilbert transform involves performing an FFT of the data it can take significantly longer
than the &quot;classic&quot; algorithms for longer seismic signals (&gt;500K pts).</em>
</p>


<h3>Value</h3>

<p>A vector of values is returned of the same length as the data in the <code>Trace</code>.
</p>


<h3>Note</h3>

<p>The returned vector will contain <code>NA</code> near the edges of the trace where insufficient data are available to fill the windows.
Additional <code>NA</code> values will appear for every index that is <em>skipped over</em> when the <code>increment</code> parameter is greater than one.
</p>
<p>For higher resolution channels, picking an increment of <code>2/sampling_rate</code> can greatly speed up processing times and still generate reasonable results.
</p>


<h3>Author(s)</h3>

<p>Jonathan Callahan <a href="mailto:jonathan@mazamascience.com">jonathan@mazamascience.com</a>
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/First_break_picking">First break picking</a> (Wikipedia)
</p>
<p><a href="https://www.crewes.org/Documents/ResearchReports/2014/CRR201476.pdf">Automatic time-picking of first arrivals on large seismic datasets</a>
</p>
<p><a href="http://www.fcaglp.unlp.edu.ar/~velis/papers/PickingGeop10.pdf">Automatic first-breaks picking: New strategies and algorithms</a> (Sabbione and Velis 2010)
</p>
<p><a href="https://geoconvention.com/wp-content/uploads/abstracts/2012/279_GC2012_Adaptive_Microseismic_Event_Detection.pdf">Adaptive microseismic event detection and automatic time picking</a> (Akram and Eaton 2012)
</p>
<p>&quot;Characterization of Global Seismograms Using an Automatic-Picking Algorithm&quot;
Bulletin of the Seismological Society of America, Vol. 84, No. 2, pp. 366-376, April 1994 (Earle and Shearer)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+triggerOnset">triggerOnset</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Open a connection to IRIS DMC webservices
iris &lt;- new("IrisClient")

starttime &lt;- as.POSIXct("2010-02-27",tz="GMT")
endtime &lt;- as.POSIXct("2010-02-28",tz="GMT")
  
# Get the waveform
st &lt;- getDataselect(iris,"IU","ANMO","00","BHZ",starttime,endtime)
tr &lt;- st@traces[[1]]
picker &lt;- STALTA(tr,3,30)

# Plot the trace and overlay the picker
plot(tr)
par(new=TRUE)
plot(picker, type='l', col='red', axes=FALSE, xlab="", ylab="")
mtext("Picker", side=1, line=-8, adj=0.05, col='red')
par(new=FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='Stream-class'> Class <code>"Stream"</code> </h2><span id='topic+Stream-class'></span><span id='topic+Stream'></span><span id='topic+plot+2CStream-method'></span><span id='topic+plotUpDownTimes'></span><span id='topic+plotUpDownTimes+2CStream+2Cmissing+2Cmissing-method'></span><span id='topic+plotUpDownTimes+2CStream+2Cmissing+2Cnumeric-method'></span><span id='topic+plotUpDownTimes+2CStream+2Cnumeric+2Cmissing-method'></span><span id='topic+plotUpDownTimes+2CStream+2Cnumeric+2Cnumeric-method'></span><span id='topic+plotUpDownTimes+2CPOSIXct+2Cmissing+2Cmissing-method'></span><span id='topic+plotUpDownTimes+2CPOSIXct+2Cmissing+2Cnumeric-method'></span><span id='topic+plotUpDownTimes+2CPOSIXct+2Cnumeric+2Cmissing-method'></span><span id='topic+plotUpDownTimes+2CPOSIXct+2Cnumeric+2Cnumeric-method'></span><span id='topic+slice+2CStream+2CPOSIXct+2CPOSIXct-method'></span><span id='topic+uniqueIds'></span><span id='topic+uniqueIds+2CStream-method'></span>

<h3>Description</h3>

<p>A <code>Stream</code> object containing a list of <code>Trace</code> objects.
</p>


<h3>Objects from the Class</h3>

<p>Objects are typically created by calls to <a href="#topic+getDataselect">getDataselect</a>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>url</code>:</dt><dd><p>Object of class <code>"character"</code>:
URL request used to generate this <code>Stream</code>. </p>
</dd>
<dt><code>requestedStarttime</code>:</dt><dd><p>Object of class <code>"POSIXct"</code>:
starttime used when requesting data with <code><a href="#topic+getDataselect">getDataselect</a></code>. </p>
</dd>
<dt><code>requestedEndtime</code>:</dt><dd><p>Object of class <code>"POSIXct"</code>:
endtime used when requesting data with <code><a href="#topic+getDataselect">getDataselect</a></code>. </p>
</dd>
<dt><code>act_flags</code>:</dt><dd><p>Object of class <code>"integer"</code>:
Accumulators for the act_flags bits in each miniSEED record. </p>
</dd>
<dt><code>io_flags</code>:</dt><dd><p>Object of class <code>"integer"</code>:
Accumulators for the io_flags bits in each miniSEED record. </p>
</dd>
<dt><code>dq_flags</code>:</dt><dd><p>Object of class <code>"integer"</code>:
Accumulators for the dq_flags bits in each miniSEED record. </p>
</dd>
<dt><code>timing_qual</code>:</dt><dd><p>Object of class <code>"numeric"</code>:
Average timing quality associated with miniSEED records.</p>
</dd>
<dt><code>traces</code>:</dt><dd><p>Object of class <code>"list"</code>:
List of <code>Trace</code> objects. </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>getGaps</dt><dd><p><code>signature(x="Stream")</code>: 
returns information on data dropouts between <code>Traces</code>; see <a href="#topic+getGaps">getGaps</a> </p>
</dd>
<dt>getUpDownTimes</dt><dd><p><code>signature(x="Stream", min_signal="numeric", min_gap="numeric")</code>: 
returns a vector of datetimes associated with channel up/down transitions; see <a href="#topic+getUpDownTimes">getUpDownTimes</a> </p>
</dd>
<dt>length</dt><dd><p><code>signature(x="Stream")</code>: 
returns the total number of data points in all <code>Traces</code> </p>
</dd>
<dt>max</dt><dd><p><code>signature(x="Stream")</code>: 
returns the overall data maximum for all data in all <code>Traces</code> </p>
</dd>
<dt>median</dt><dd><p><code>signature(x="Stream", na.rm= "logical")</code>: 
returns the overall data median for all data in all <code>Traces</code> </p>
</dd>
<dt>mean</dt><dd><p><code>signature(x="Stream")</code>: 
returns the overall data mean for all data in all <code>Traces</code> </p>
</dd>
<dt>mergeTraces</dt><dd><p><code>signature(x="Stream", fillMethod="fillNA")</code>: 
returns a new <code>Stream</code> object where all <code>Traces</code> have been merged into a single <code>Trace</code> <a href="#topic+mergeTraces">mergeTraces</a> </p>
</dd>
<dt>min</dt><dd><p><code>signature(x="Stream")</code>: 
returns the overall data minimum for all data in all <code>Traces</code> </p>
</dd>
<dt>multiplyBy</dt><dd><p><code>signature(x="Stream", y="numeric")</code>: 
returns a new <code>Stream</code> object where the data in every <code>Trace</code> have been multiplied by y; see <a href="#topic+multiplyBy">multiplyBy</a> </p>
</dd>
<dt>parallelLength</dt><dd><p><code>signature(x="Stream")</code>: 
returns a vector of data lengths, one for each <code>Trace</code> </p>
</dd>
<dt>parallelMax</dt><dd><p><code>signature(x="Stream")</code>: 
returns a vector of data maxima, one for each <code>Trace</code> </p>
</dd>
<dt>parallelMedian</dt><dd><p><code>signature(x="Stream", na.rm= "logical")</code>: 
returns a vector of data medians, one for each <code>Trace</code> </p>
</dd>
<dt>parallelMean</dt><dd><p><code>signature(x="Stream")</code>: 
returns a vector of data means, one for each <code>Trace</code> </p>
</dd>
<dt>parallelMin</dt><dd><p><code>signature(x="Stream")</code>: 
returns a vector of data minima, one for each <code>Trace</code> </p>
</dd>
<dt>parallelRms</dt><dd><p><code>signature(x="Stream")</code>: 
returns a vector of RMS calculations, one for each <code>Trace</code>; see <a href="#topic+rmsVariance">rmsVariance</a> </p>
</dd>
<dt>parallelRmsVariance</dt><dd><p><code>signature(x="Stream")</code>: 
returns a vector of RMS variance calculations, one for each <code>Trace</code>; see <a href="#topic+rmsVariance">rmsVariance</a> </p>
</dd>
<dt>parallelSd</dt><dd><p><code>signature(x="Stream", na.rm="logical")</code>: 
returns a vector of standard deviation calculations, one for each <code>Trace</code> </p>
</dd>
<dt>plot</dt><dd><p><code>signature(x="Stream")</code>: 
default plot of the merged <code>Traces</code> in a <code>Stream</code> with appropriate labeling</p>
</dd>
<dt>plotUpDownTimes</dt><dd><p><code>signature(x="Stream", min_signal="numeric", min_gap="numeric")</code>: 
plots the times at which a <code>Stream</code> transitions from data collection to non-collection (on/off); see <a href="#topic+getUpDownTimes">getUpDownTimes</a></p>
</dd>
<dt>rms</dt><dd><p><code>signature(x="Stream")</code>: 
returns the overall Root Mean Square amplitude for all data in all <code>Traces</code>; see <a href="#topic+rmsVariance">rmsVariance</a> </p>
</dd>
<dt>rmsVariance</dt><dd><p><code>signature(x="Stream")</code>: 
returns the overall RMS variance for all data in all <code>Traces</code>; see <a href="#topic+rmsVariance">rmsVariance</a> </p>
</dd>
<dt>sd</dt><dd><p><code>signature(x="Stream", na.rm="logical")</code>: 
returns the overall standard deviations for all data in all <code>Traces</code> </p>
</dd>
<dt>slice</dt><dd><p><code>signature(x="Stream", starttime="POSIXct", endtime="POSIXct")</code>: 
returns a new <code>Stream</code> sliced out of an existing <code>Stream</code> (see <a href="#topic+slice">slice</a>)</p>
</dd>
<dt>uniqueIds</dt><dd><p><code>signature(x="Stream")</code>: 
returns a vector of SNCLQ identifiers, one for each <code>Trace</code> </p>
</dd>
</dl>



<h3>Note</h3>

<p>The <code>Stream</code> object is inspired by the <code>Stream</code> class found in the
python ObsPy package (<a href="https://docs.obspy.org/packages/autogen/obspy.core.stream.Stream.html">https://docs.obspy.org/packages/autogen/obspy.core.stream.Stream.html</a>).
</p>
<p>The miniSEED flags and timing_qual values are described in the SEED manual
(<a href="http://www.fdsn.org/seed_manual/SEEDManual_V2.4.pdf">http://www.fdsn.org/seed_manual/SEEDManual_V2.4.pdf</a>).  The &quot;accumulators&quot; contain
counts of the number of times each bit flag was set during the parsing of a miniSEED file.
These attributes are retained primarily for assessing data quality issues within the IRIS DMC.
</p>
<p>The following code documentation describes how each of the flags is used within miniSEED files:
</p>
<pre>
  # act_flags
  # [1] Calibration signals present
  # [2] Time correction applied
  # [3] Beginning of an event, station trigger
  # [4] End of an event, station detrigger
  # [5] A positive leap second happened in this record
  # [6] A negative leap second happened in this record
  # [7] Event in progress
  # [8] Undefined bit set

  # io_flags
  # [1] Station volume parity error possibly present
  # [2] Long record read (possibly no problem)
  # [3] Short record read (record padded)
  # [4] Start of time series
  # [5] End of time series
  # [6] Clock locked
  # [7] Undefined bit set
  # [8] Undefined bit set

  # dq_flags
  # [1] Amplifier saturation detected
  # [2] Digitizer clipping detected
  # [3] Spikes detected
  # [4] Glitches detected
  # [5] Missing/padded data present
  # [6] Telemetry synchronization error
  # [7] A digital filter may be charging
  # [8] Time tag is questionable
</pre>


<h3>Author(s)</h3>

<p>Jonathan Callahan <a href="mailto:jonathan@mazamascience.com">jonathan@mazamascience.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Open a connection to IRIS DMC webservices
iris &lt;- new("IrisClient")

starttime &lt;- as.POSIXct("2012-01-24", tz="GMT")
endtime &lt;- as.POSIXct("2012-01-25", tz="GMT")

# Get the waveform
st &lt;- getDataselect(iris,"AK","PIN","","BHZ",starttime,endtime)
min(st)
median(st)
mean(st)
max(st)
sd(st)
rms(st)
rmsVariance(st)

## End(Not run)
</code></pre>

<hr>
<h2 id='surfaceDistance'>Earth surface distance between two points</h2><span id='topic+surfaceDistance'></span>

<h3>Description</h3>

<p>The surfaceDistance() function calculates the distance in kilometers between any two lat-lon pairs
using the Haversine equation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surfaceDistance(lat1_deg, lon1_deg, lat2_deg, lon2_deg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="surfaceDistance_+3A_lat1_deg">lat1_deg</code></td>
<td>
<p>latitude 1 (degrees)</p>
</td></tr>
<tr><td><code id="surfaceDistance_+3A_lon1_deg">lon1_deg</code></td>
<td>
<p>longitude 1 (degrees)</p>
</td></tr>
<tr><td><code id="surfaceDistance_+3A_lat2_deg">lat2_deg</code></td>
<td>
<p>latitude 2 (degrees)</p>
</td></tr>
<tr><td><code id="surfaceDistance_+3A_lon2_deg">lon2_deg</code></td>
<td>
<p>longitude 2 (degrees)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Distance in kilometers
</p>


<h3>Author(s)</h3>

<p>Jonathan Callahan <a href="mailto:jonathan@mazamascience.com">jonathan@mazamascience.com</a>
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Haversine_formula">https://en.wikipedia.org/wiki/Haversine_formula</a>
</p>

<hr>
<h2 id='Trace-class'>Class <code>"Trace"</code></h2><span id='topic+Trace-class'></span><span id='topic+Trace'></span><span id='topic+as.vector+2CTrace-method'></span><span id='topic+initialize+2CTrace-method'></span><span id='topic+isDC'></span><span id='topic+isDC+2CTrace-method'></span><span id='topic+plot+2CTrace-method'></span>

<h3>Description</h3>

<p>A <code>Trace</code> object containing a seismic trace &ndash; a continuous timeseries.
</p>


<h3>Objects from the Class</h3>

<p>Objects occupy the <code>traces</code> slot of a <a href="#topic+Stream-class">Stream-class</a> object and are typically
populated by calls to <a href="#topic+getDataselect">getDataselect</a>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>id</code>:</dt><dd><p>Object of class <code>"character"</code>: 
Unique &quot;SNCL&quot; identifier specifying the Network, Station, Location, Channel and Quality factor
associated with this trace: eg. <code>AK.PIN..VEA.M</code>. The <code>id</code> is generated automatically
when the trace is first created and is intended for read only.</p>
</dd>
<dt><code>Sensor</code>:</dt><dd><p>Object of class <code>"character"</code>:
Instrument name.</p>
</dd>
<dt><code>InstrumentSensitivity</code>:</dt><dd><p>Object of class <code>"numeric"</code>:
The total sensitivity for a channel, representing the complete acquisition system expressed as a scalar.
Equivalent to SEED stage 0 gain.</p>
</dd>
<dt><code>SensitivityFrequency</code>:</dt><dd><p>Object of class <code>"numeric"</code>:
The frequency at which the total sensitivity is correct.</p>
</dd>
<dt><code>InputUnits</code>:</dt><dd><p>Object of class <code>"character"</code>:
The units of the data as input from the perspective of data acquisition.
After correcting data for this response, these would be the resulting units.</p>
</dd>
<dt><code>stats</code>:</dt><dd><p>Object of class <code>"TraceHeader"</code>: 
Container with metadata information describing the trace. (see <a href="#topic+TraceHeader-class">TraceHeader-class</a>) </p>
</dd>
<dt><code>data</code>:</dt><dd><p>Object of class <code>"numeric"</code>: Vector of data values. </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>as.vector</dt><dd><p><code>signature(x="Trace")</code>: 
returns the data slot; equivalent to <code>x@data</code> </p>
</dd>
<dt>DDT</dt><dd><p><code>signature(x="Trace", demean="logical", detrend="logical", taper="numeric")</code>: 
returns a new trace that has been 'cleaned up' for further processing by applying demean, detrend, and taper techniques (see <a href="#topic+DDT">DDT</a>) </p>
</dd>
<dt>envelope</dt><dd><p><code>signature(x="Trace")</code>: 
returns the envelope of the seismic signal (see <a href="#topic+envelope">envelope</a>) </p>
</dd>
<dt>isDC</dt><dd><p><code>signature(x="Trace")</code>: 
returns <code>TRUE</code> if trace data consist of a DC signal </p>
</dd>
<dt>length</dt><dd><p><code>signature(x="Trace")</code>: 
returns the length of the data; equivalent to <code>length(x@data)</code> </p>
</dd>
<dt>max</dt><dd><p><code>signature(x="Trace")</code>: 
returns the maximum value of the data; equivalent to <code>max(x@data)</code> </p>
</dd>
<dt>median</dt><dd><p><code>signature(x="Trace", na.rm="logical")</code>: 
returns the median value of the data; equivalent to <code>median(x@data)</code> </p>
</dd>
<dt>mean</dt><dd><p><code>signature(x="Trace")</code>: 
returns the mean value of the data; equivalent to <code>mean(x@data)</code> </p>
</dd>
<dt>min</dt><dd><p><code>signature(x="Trace")</code>: 
returns the minimum value of the data; equivalent to <code>min(x@data)</code> </p>
</dd>
<dt>multiplyBy</dt><dd><p><code>signature(x="Trace", y="numeric")</code>: 
returns a new <code>Trace</code> where the data have been multiplied by y (see <a href="#topic+multiplyBy">multiplyBy</a>)</p>
</dd>
<dt>plot</dt><dd><p><code>signature(x="Trace")</code>: 
default plot of the <code>Trace</code> data with appropriate labeling</p>
</dd>
<dt>rms</dt><dd><p><code>signature(x="Trace")</code>: 
returns the Root Mean Square amplitude of the data (see <a href="#topic+rms">rms</a>) </p>
</dd>
<dt>rmsVariance</dt><dd><p><code>signature(x="Trace")</code>: 
returns the RMS variance of the data (see <a href="#topic+rmsVariance">rmsVariance</a>) </p>
</dd>
<dt>sd</dt><dd><p><code>signature(x="Trace", na.rm="logical")</code>: 
returns the standard deviation of the data; equivalent to <code>sd(x@data)</code> </p>
</dd>
<dt>slice</dt><dd><p><code>signature(x="Trace", starttime="POSIXct", endtime="POSIXct")</code>: 
returns a new <code>Trace</code> subset of an existing <code>Trace</code> (see <a href="#topic+slice">slice</a>)</p>
</dd>
<dt>STALTA</dt><dd><p><code>signature(x="Trace",staSecs="numeric",ltaSecs="numeric",algorithm="character", ...)</code>: 
returns the STALTA picker result (see <a href="#topic+STALTA">STALTA</a>)</p>
</dd>
<dt>triggerOnset</dt><dd><p><code>signature(x="Trace", picker="numeric", threshold="numeric", ...)</code>: 
returns the time or index of an event onset as determined by the STALTA picker (see <a href="#topic+triggerOnset">triggerOnset</a>)</p>
</dd>
</dl>



<h3>Note</h3>

<p>The <code>Trace</code> object is inspired by the <code>Trace</code> class found in the
python ObsPy package (<a href="https://docs.obspy.org/packages/autogen/obspy.core.trace.Trace.html">https://docs.obspy.org/packages/autogen/obspy.core.trace.Trace.html</a>).
</p>


<h3>Author(s)</h3>

<p>Jonathan Callahan <a href="mailto:jonathan@mazamascience.com">jonathan@mazamascience.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Open a connection to IRIS DMC webservices
iris &lt;- new("IrisClient")

# Set the starttime and endtime
starttime &lt;- as.POSIXct("2012-01-24", tz="GMT")
endtime &lt;- as.POSIXct("2012-01-25", tz="GMT")

# Get the waveform
st &lt;- getDataselect(iris,"AK","PIN","","BHZ",starttime,endtime)

# Get the first trace and generate some statistics
tr1 &lt;- st@traces[[1]]
min(tr1)
median(tr1)
mean(tr1)
max(tr1)
sd(tr1)
rms(tr1)
rmsVariance(tr1)

## End(Not run)
</code></pre>

<hr>
<h2 id='TraceHeader-class'> Class <code>"TraceHeader"</code> </h2><span id='topic+TraceHeader-class'></span><span id='topic+TraceHeader'></span><span id='topic+as.headerLine+2CTraceHeader-method'></span><span id='topic+as.headerLine'></span><span id='topic+initialize+2CTraceHeader-method'></span><span id='topic+show+2CTraceHeader-method'></span>

<h3>Description</h3>

<p>A container for metadata associated with a <code>Trace</code> object. Originally populated by information in the miniseed trace header; it now has the option of including additional station and channel metadata.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("TraceHeader", headerList, headerLine, ...)</code>.
The <code>stats</code> slot of a <code>Trace</code> object will contain a <code>TraceHeader</code> object,
typically populated by a webservice request. (see <a href="#topic+IrisClient-class">IrisClient-class</a>)
</p>


<h3>Slots</h3>


<dl>
<dt><code>sampling_rate</code>:</dt><dd><p>Object of class <code>"numeric"</code>: Sampling rate in hertz.</p>
</dd>
<dt><code>delta</code>:</dt><dd><p>Object of class <code>"numeric"</code>: Sample interval in seconds.</p>
</dd>
<dt><code>calib</code>:</dt><dd><p>Object of class <code>"numeric"</code>: Calibration factor.</p>
</dd>
<dt><code>npts</code>:</dt><dd><p>Object of class <code>"integer"</code>: Number of sample points.</p>
</dd>
<dt><code>network</code>:</dt><dd><p>Object of class <code>"character"</code>: Seismic network name.</p>
</dd>
<dt><code>location</code>:</dt><dd><p>Object of class <code>"character"</code>: Location code.</p>
</dd>
<dt><code>station</code>:</dt><dd><p>Object of class <code>"character"</code>: Station name.</p>
</dd>
<dt><code>channel</code>:</dt><dd><p>Object of class <code>"character"</code>: Channel code.</p>
</dd>
<dt><code>quality</code>:</dt><dd><p>Object of class <code>"character"</code>: Data quality code.</p>
</dd>
<dt><code>starttime</code>:</dt><dd><p>Object of class <code>"POSIXct"</code>: Start time.</p>
</dd>
<dt><code>endtime</code>:</dt><dd><p>Object of class <code>"POSIXct"</code>: End time.</p>
</dd>
<dt><code>latitude</code>:</dt><dd><p>Object of class <code>"numeric"</code>: Latitude.</p>
</dd>
<dt><code>longitude</code>:</dt><dd><p>Object of class <code>"numeric"</code>: Longitude.</p>
</dd>
<dt><code>elevation</code>:</dt><dd><p>Object of class <code>"numeric"</code>: Elevation.</p>
</dd>
<dt><code>depth</code>:</dt><dd><p>Object of class <code>"numeric"</code>: Depth.</p>
</dd>
<dt><code>azimuth</code>:</dt><dd><p>Object of class <code>"numeric"</code>: Azimuth.</p>
</dd>
<dt><code>dip</code>:</dt><dd><p>Object of class <code>"numeric"</code>: Dip.</p>
</dd>
<dt><code>processing</code>:</dt><dd><p>Object of class <code>"list"</code>: Information strings describing processing applied to this trace. </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>as.headerLine</dt><dd><p><code>signature(obj = "TraceHeader")</code>: 
Prints out the information in the <code>TraceHeader</code> as an ascii header line, not including any station and channel metadata not found in the miniseed trace header, e.g.,
</p>
<pre>
    TIMESERIES LD_POTS__HHZ_M, 351 samples, 100.503 sps, \
    2012-01-29T00:00:00.006000, SLIST, INTEGER, COUNTS</pre></dd>

<dt>show</dt><dd><p><code>signature(object = "TraceHeader")</code>: Prettyprints the information in the <code>TraceHeader</code> </p>
</dd>
</dl>



<h3>Note</h3>

<p>The <code>TraceHeader</code> object is inspired by the <code>Stats</code> class found in the
python ObsPy package (<a href="https://docs.obspy.org/packages/autogen/obspy.core.trace.Stats.html">https://docs.obspy.org/packages/autogen/obspy.core.trace.Stats.html</a>).
</p>
<p>Retaining the ObsPy class name <code>Stats</code> would have generated a tremendous amount of 
confusion in the context of R. Instead, the name
<code>TraceHeader</code> has been adopted. Nevertheless, the <code>TraceHeader</code> object still lives in the 
<code>Trace@stats</code> slot to retain as much similarity to ObsPy as possible.
</p>


<h3>Author(s)</h3>

<p>Jonathan Callahan <a href="mailto:jonathan@mazamascience.com">jonathan@mazamascience.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Open a connection to IRIS DMC webservices
iris &lt;- new("IrisClient")

starttime &lt;- as.POSIXct("2012-01-24", tz="GMT")
endtime &lt;- as.POSIXct("2012-01-25", tz="GMT")

# Get the waveform
st &lt;- getDataselect(iris,"AK","PIN","","BHZ",starttime,endtime)

# Get the first trace and show the associated metadata
tr1 &lt;- st@traces[[1]]
show(tr1@stats)

## End(Not run)
</code></pre>

<hr>
<h2 id='transferFunctionSpectra'>function to retrieve response values to use for input to the IRISMustangMetrics::transferFunctionMetric</h2><span id='topic+transferFunctionSpectra'></span>

<h3>Description</h3>

<p>The <code>transferFunctionSpectra</code> function returns a frequency-amplitude-phase response from the service.iris.edu/iris/ws/evalresp web service for a seismic <code>Stream</code> object
using sampling_rate to determine frequency limits. The IRISMustangMetrics::transferFunctionMetric expects this output as evalresp input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transferFunctionSpectra(st,sampling_rate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transferFunctionSpectra_+3A_st">st</code></td>
<td>
<p>a <code>Stream</code> object</p>
</td></tr>
<tr><td><code id="transferFunctionSpectra_+3A_sampling_rate">sampling_rate</code></td>
<td>
<p>sample rate</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>transferFunctionSpectra</code> /determines the minfreq, maxfreq, and nfreq for input to the 
<code>getEvalresp</code> function based on input sample rate. Other getEvalresp inputs are units='def' (default)
and output='fap' (frequency-amplitude-phase).  
</p>
<p><code>transferFunctionSpectra</code> will always call <code>getEvalresp</code> using the service.iris.edu/irisws/evalresp 
web service. The IRISMustangMetrics::transferFunctionMetric expects this output as evalresp input.
</p>


<h3>Value</h3>

<p>Output is a dataframe with columns named:
</p>
<pre>freq, amp, phase</pre>


<h3>Author(s)</h3>

<p>Mary Templeton <a href="mailto:met@iris.washington.edu">met@iris.washington.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getEvalresp">getEvalresp</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Create a new IrisClient
iris &lt;- new("IrisClient", debug=TRUE)

# Get seismic data
starttime &lt;- as.POSIXct("2011-05-05", tz="GMT") 
endtime &lt;- starttime + 1*24*3600
st &lt;- getDataselect(iris,"IU","GRFO","--","BHE",starttime,endtime)
sampling_rate &lt;- 20

# Generate power spectral density for each hour long segment
evalresp  &lt;- transferFunctionSpectra(st,sampling_rate)


## End(Not run)
</code></pre>

<hr>
<h2 id='triggerOnset'>Event onset triggering</h2><span id='topic+triggerOnset'></span><span id='topic+triggerOnset+2CTrace+2Cnumeric-method'></span>

<h3>Description</h3>

<p>The <code>triggerOnset</code> method of <code>Trace</code> objects uses the numeric vector returned by
the <code>STALTA</code> &quot;first break picking&quot; method and a user selected threshold to determine the
arrival time of a seismic event.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>triggerOnset(x, picker, threshold, index)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="triggerOnset_+3A_x">x</code></td>
<td>
<p> a <code>Trace</code> object </p>
</td></tr>
<tr><td><code id="triggerOnset_+3A_picker">picker</code></td>
<td>
<p> results from applying the <code>STALTA</code> method to this trace </p>
</td></tr>
<tr><td><code id="triggerOnset_+3A_threshold">threshold</code></td>
<td>
<p> optional numeric value of the threshold at which triggering should occur </p>
</td></tr>
<tr><td><code id="triggerOnset_+3A_index">index</code></td>
<td>
<p> optional logical to return the index (rather than the time) of event onset (default=<code>FALSE</code>) </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method simply identifies the point at which the <code>picker</code> first rises above the <code>threshold</code>.
</p>
<p>When no <code>threshold</code> is supplied, an appropriate value is calculated from the picker with:
</p>
<p><code>threshold &lt;- quantile(picker,0.999,na.rm=TRUE)</code>.
</p>


<h3>Value</h3>

<p>A single value is returned identifying the onset of the seismic event or <code>NA</code> if none is detected.
The returned value wil be a <code>POSIXct</code> time by defult or a numeric index if <code>index=TRUE</code>.
</p>


<h3>Note</h3>

<p>The appropriate value for the threshold will depend upon the exact STA/LTA algorithm used and the noise level in the
signal.
</p>


<h3>Author(s)</h3>

<p>Jonathan Callahan <a href="mailto:jonathan@mazamascience.com">jonathan@mazamascience.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+STALTA">STALTA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Open a connection to IRIS DMC webservices
iris &lt;- new("IrisClient")

starttime &lt;- as.POSIXct("2010-02-27 06:00:00",tz="GMT")
endtime &lt;- as.POSIXct("2010-02-27 09:00:00",tz="GMT")
  
# Get the waveform
st &lt;- getDataselect(iris,"IU","ANMO","00","BHZ",starttime,endtime)
tr &lt;- st@traces[[1]]
picker &lt;- STALTA(tr,3,30)

# Identify the onset of the event
to &lt;- triggerOnset(tr,picker)

plot(tr)
abline(v=to, col='red', lwd=2)

## End(Not run)
</code></pre>

<hr>
<h2 id='unHistogram'>Histogram to Vector</h2><span id='topic+unHistogram'></span>

<h3>Description</h3>

<p>If <code>vec</code> represents a set of binned counts of incrementing values (ascending)
return a vector of associated bin values with the proper count of each value. Intended 
for internal use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unHistogram(vec, startVal, incr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unHistogram_+3A_vec">vec</code></td>
<td>
<p>a histogram vector or ordered set of binned counts</p>
</td></tr>
<tr><td><code id="unHistogram_+3A_startval">startVal</code></td>
<td>
<p>the initial value of the first bin element</p>
</td></tr>
<tr><td><code id="unHistogram_+3A_incr">incr</code></td>
<td>
<p>the increment rate of each subsequent bin value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of bin values with appropriate counts of each.
</p>


<h3>Author(s)</h3>

<p>Rob Casey <a href="mailto:rob@iris.washington.edu">rob@iris.washington.edu</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
