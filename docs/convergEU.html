<!DOCTYPE html><html lang="en"><head><title>Help for package convergEU</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {convergEU}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#convergEU-package'><p>convergEU: Monitoring Convergence of EU Countries</p></a></li>
<li><a href='#abso_change'><p>Absolute change</p></a></li>
<li><a href='#average_clust'><p>Unweighted average of countries</p></a></li>
<li><a href='#beta_conv'><p>Beta-convergence statistic</p></a></li>
<li><a href='#beta_conv_graph'><p>Graphical representation based on beta convergence</p></a></li>
<li><a href='#check_country'><p>Check a dataset (tibble) for the presence of countries</p></a></li>
<li><a href='#check_data'><p>Make tests on a dataset (dataframe and tibbles)</p></a></li>
<li><a href='#coeu_grad'><p>Auxiliary function for gradients  and delta2</p></a></li>
<li><a href='#coeu_gradV'><p>Auxiliary function to provide a different object as input</p></a></li>
<li><a href='#compo_cond_EUS'><p>Auxiliary function compo_cond_EUS</p></a></li>
<li><a href='#convergEU_glb'><p>Global objects for convergEU package</p></a></li>
<li><a href='#country_ranking'><p>Ranking of EU countries by time</p></a></li>
<li><a href='#dbEUF2018meta'><p>Metainformation on Eurofound dataset</p></a></li>
<li><a href='#dbEurofound'><p>Eurofound dataset</p></a></li>
<li><a href='#dbMetaEUStat'><p>Eurostat metainformation</p></a></li>
<li><a href='#delta_conv'><p>Delta-convergence statistic</p></a></li>
<li><a href='#demea_change'><p>Calculate changes of deviations from the mean</p></a></li>
<li><a href='#departure_best'><p>Departures from the best country</p></a></li>
<li><a href='#departure_best_plot'><p>Plot of deviations from the best performer</p></a></li>
<li><a href='#departure_mean'><p>Departures from an average</p></a></li>
<li><a href='#dev_mean_plot'><p>Plot of deviations from the mean</p></a></li>
<li><a href='#dow_soc_scor_boa'><p>Downloader of social scoreboard indicators</p></a></li>
<li><a href='#down_lo_EUS'><p>Download  a dataset (tibble) from Eurostat.</p></a></li>
<li><a href='#download_indicator_EUS'><p>Download  a dataset (tibble) from Eurostat.</p></a></li>
<li><a href='#emp_20_64_MS'><p>Dataset emp_20_64_MS</p></a></li>
<li><a href='#extract_indicator_ECG'><p>Create a dataset (tibble) for an ECG indicator.</p></a></li>
<li><a href='#extract_indicator_EIGE'><p>Create a dataset (tibble) for an EIGE indicator.</p></a></li>
<li><a href='#extract_indicator_EUF'><p>Create a dataset (tibble) for an indicator.</p></a></li>
<li><a href='#gamma_conv'><p>Gamma convergence</p></a></li>
<li><a href='#gamma_conv_msteps'><p>Gamma convergence iterated on several years in pairs</p></a></li>
<li><a href='#go_indica_fi'><p>Create an indicator fiche for a given aggregation of countries.</p></a></li>
<li><a href='#go_ms_fi'><p>Create a country fiche for an indicator</p></a></li>
<li><a href='#gra_de2_patt'><p>Values to patterns</p></a></li>
<li><a href='#graph_departure'><p>Graphical representation based on sigma convergence</p></a></li>
<li><a href='#impu_det_lin'><p>Imputation of  missing values</p></a></li>
<li><a href='#impute_dataset'><p>Imputation to make a dataset complete</p></a></li>
<li><a href='#ma_dataset'><p>Smoother based on moving average</p></a></li>
<li><a href='#map_2_patt_39'><p>Values to patterns</p></a></li>
<li><a href='#map_2_patt_59'><p>Values to patterns</p></a></li>
<li><a href='#ms_dynam'><p>Member state dynamics</p></a></li>
<li><a href='#ms_pattern_39'><p>Find patterns for all countries</p></a></li>
<li><a href='#ms_pattern_59'><p>Find patterns for all countries</p></a></li>
<li><a href='#ms_pattern_ori'><p>Find patterns for all countries</p></a></li>
<li><a href='#not_in'><p>Auxiliary function for membership</p></a></li>
<li><a href='#patt_legend'><p>Graphical legend about time patterns</p></a></li>
<li><a href='#patt_legend_39'><p>Graphical legend about time patterns</p></a></li>
<li><a href='#points2par'><p>From points to parameters of a straight line</p></a></li>
<li><a href='#pop_var'><p>Population variance and standard deviation</p></a></li>
<li><a href='#scoreb_yrs'><p>Scoreboard of countries</p></a></li>
<li><a href='#sigma_conv'><p>Sigma-convergence statistic</p></a></li>
<li><a href='#sigma_conv_graph'><p>Graphical representation based on sigma convergence</p></a></li>
<li><a href='#smoo_dataset'><p>Smoother based on weighting</p></a></li>
<li><a href='#ts_parlin'><p>Time-indicator serie to straight lines parameters</p></a></li>
<li><a href='#upDo_CoDi'><p>Upward-downward convergence declaration</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Monitoring Convergence of EU Countries</td>
</tr>
<tr>
<td>Version:</td>
<td>0.7.3.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Eleonora Peruffo &lt;eleonora.peruffo@eurofound.europa.eu&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf">https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf</a>,
<a href="https://www.eurofound.europa.eu/en/publications/eurofound-paper/2020/monitoring-upward-convergence-eu-r-convergeu-package">https://www.eurofound.europa.eu/en/publications/eurofound-paper/2020/monitoring-upward-convergence-eu-r-convergeu-package</a>,
<a href="https://www.eurofound.europa.eu/en/publications/2018/upward-convergence-eu-concepts-measurements-and-indicators">https://www.eurofound.europa.eu/en/publications/2018/upward-convergence-eu-concepts-measurements-and-indicators</a>,
<a href="https://www.ajs.or.at/index.php/ajs/article/view/1468">https://www.ajs.or.at/index.php/ajs/article/view/1468</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Indicators and measures by country and time describe
    what happens at economic and social levels. This package provides
    functions to calculate several measures of convergence after imputing
    missing values. The automated downloading of Eurostat data,
    followed by the production of country fiches and indicator fiches,
    makes possible to produce automated reports.
    The Eurofound report (&lt;<a href="https://doi.org/10.2806%2F68012">doi:10.2806/68012</a>&gt;)
    "Upward convergence in the EU: Concepts, measurements and indicators", 
    2018, is a detailed  presentation of  convergence.</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, tibble, ggplot2, eurostat, tidyr, rlang, utils, purrr,
caTools, broom, stringr, rmarkdown, ggpubr, leaflet, tidyselect</td>
</tr>
<tr>
<td>Suggests:</td>
<td>devtools, formattable, gridExtra, knitr, kableExtra,
magrittr, readr, readxl, tidyverse, rvest, testthat, utf8</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | <a href="https://opensource.org/licenses/BSD-3-Clause">BSD_3_clause</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.0</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-21 17:41:31 UTC; epe</td>
</tr>
<tr>
<td>Author:</td>
<td>Federico M. Stefanini [arc, aut],
  Massimiliano Mascherini [arc],
  Eleonora Peruffo [cre],
  Nedka Nikiforova [ctb],
  Chiara Litardi [ctb],
  Berta Mizsei [ctb],
  Ricardo Simon-Carbajo [ctb],
  Romila Ghosh [ctb],
  Andres Suarez-Cetrulo [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-21 22:12:54 UTC</td>
</tr>
</table>
<hr>
<h2 id='convergEU-package'>convergEU: Monitoring Convergence of EU Countries</h2><span id='topic+convergEU'></span><span id='topic+convergEU-package'></span>

<h3>Description</h3>

<p>Indicators and measures by country and time describe what happens at economic and social levels. This package provides functions to calculate several measures of convergence after imputing missing values. The automated downloading of Eurostat data, followed by the production of country fiches and indicator fiches, makes possible to produce automated reports. The Eurofound report (<a href="https://doi.org/10.2806/68012">doi:10.2806/68012</a>) &quot;Upward convergence in the EU: Concepts, measurements and indicators&quot;, 2018, is a detailed presentation of convergence.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Eleonora Peruffo <a href="mailto:eleonora.peruffo@eurofound.europa.eu">eleonora.peruffo@eurofound.europa.eu</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Federico M. Stefanini <a href="mailto:federico.stefanini@unimi.it">federico.stefanini@unimi.it</a> [architect]
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Massimiliano Mascherini <a href="mailto:massimiliano.mascherini@eurofound.europa.eu">massimiliano.mascherini@eurofound.europa.eu</a> [architect]
</p>
</li>
<li><p> Nedka Nikiforova [contributor]
</p>
</li>
<li><p> Chiara Litardi [contributor]
</p>
</li>
<li><p> Berta Mizsei [contributor]
</p>
</li>
<li><p> Ricardo Simon-Carbajo [contributor]
</p>
</li>
<li><p> Romila Ghosh [contributor]
</p>
</li>
<li><p> Andres Suarez-Cetrulo [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf">https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf</a>
</p>
</li>
<li> <p><a href="https://www.eurofound.europa.eu/en/publications/eurofound-paper/2020/monitoring-upward-convergence-eu-r-convergeu-package">https://www.eurofound.europa.eu/en/publications/eurofound-paper/2020/monitoring-upward-convergence-eu-r-convergeu-package</a>
</p>
</li>
<li> <p><a href="https://www.eurofound.europa.eu/en/publications/2018/upward-convergence-eu-concepts-measurements-and-indicators">https://www.eurofound.europa.eu/en/publications/2018/upward-convergence-eu-concepts-measurements-and-indicators</a>
</p>
</li>
<li> <p><a href="https://www.ajs.or.at/index.php/ajs/article/view/1468">https://www.ajs.or.at/index.php/ajs/article/view/1468</a>
</p>
</li></ul>


<hr>
<h2 id='abso_change'>Absolute change</h2><span id='topic+abso_change'></span>

<h3>Description</h3>

<p>Given a dataframe of quantitative indicators along time,
the absolute change is calculated.
A time variable must be present and sorted.
Missing values are not allowed. All other columns are indicator values
in each considered country.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abso_change(tavDes, time_0, time_t, all_within = TRUE, timeName = "time")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="abso_change_+3A_tavdes">tavDes</code></td>
<td>
<p>the sorted dataframe time by countries.
No other variables besides time and countries' indicator
must be present.</p>
</td></tr>
<tr><td><code id="abso_change_+3A_time_0">time_0</code></td>
<td>
<p>reference time</p>
</td></tr>
<tr><td><code id="abso_change_+3A_time_t">time_t</code></td>
<td>
<p>focus time strictly larger than time_0</p>
</td></tr>
<tr><td><code id="abso_change_+3A_all_within">all_within</code></td>
<td>
<p>is TRUE is several times are considered within the
specified interval (default), otherwise FALSE; the reference time remains
time_0.</p>
</td></tr>
<tr><td><code id="abso_change_+3A_timename">timeName</code></td>
<td>
<p>the name of the variable that contains time information</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of absolute changes for each country, the sum of absolute values and the average per pairs
of years.
</p>


<h3>References</h3>

 <p><a href="https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf">https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example 1
# Sorted dataframe in the format years by countries:
require(tibble)
testTB &lt;- dplyr::tribble(
~years, ~countryA ,  ~countryB,  ~countryC,
2000,     0.8,   2.7,    3.9,
2001,     1.2,   3.2,    4.2,
2002,     0.9,   2.9,    4.1,
2003,     1.3,   2.9,    4.0,
2004,     1.2,   3.1,    4.1,
2005,     1.2,   3.0,    4.0)

# Absolute change for each country with time_0=2000 and time_t=2005:
mySTB&lt;-abso_change(tavDes=testTB,time_0=2000, time_t=2005, timeName ="years")

# The component "res" is a list of absolute changes for each country,
# the sum of absolute values and the average per pairs of years:
names(mySTB$res)

# Absolute change for each country with time_0=2002 and time_t=2005:
mySTB1&lt;-abso_change(tavDes=testTB,time_0=2002, time_t=2005, timeName="years")

# If all_within is FALSE, only times 2002 and 2005 are considered:
mySTB2&lt;-abso_change(tavDes=testTB,time_0=2002, time_t=2005, all_within =FALSE, timeName="years")

# Example 2
# Absolute changes of Member States for the emp_20_64_MS Eurofound dataset:
data(emp_20_64_MS)
mySTB3 &lt;- abso_change(emp_20_64_MS,time_0 = 2005,time_t = 2010,timeName = "time")
mySTB4 &lt;- abso_change(emp_20_64_MS,time_0 = 2007,time_t = 2012,timeName = "time")



</code></pre>

<hr>
<h2 id='average_clust'>Unweighted average of countries</h2><span id='topic+average_clust'></span>

<h3>Description</h3>

<p>The computation is based on clusters defined in a objects
created by invoking *convergEU_glb()*.
At now only cluster labels contained into *convergEU_glb()* are possible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>average_clust(myTB, timeName = "time", cluster = "EU27")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="average_clust_+3A_mytb">myTB</code></td>
<td>
<p>time by member states dataset.</p>
</td></tr>
<tr><td><code id="average_clust_+3A_timename">timeName</code></td>
<td>
<p>name of the variable that contains time.</p>
</td></tr>
<tr><td><code id="average_clust_+3A_cluster">cluster</code></td>
<td>
<p>the label defining a cluster; one string selected within
the following: &quot;EU12&quot; , &quot;EU15&quot; ,&quot;EU19&quot;,&quot;EU25&quot; ,&quot;EU27_2007&quot;, &quot;EU28&quot;, &quot;EU27_2020&quot;,
&quot;Eurozone&quot;,&quot;EA&quot;, &quot;all&quot; (for all countries in the dataset).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The cluster specification is based on labels:  &quot;EU27_2020&quot;, &quot;EU27_2007&quot;, &quot;EU25&quot;, &quot;EU19&quot;,
&quot;EU15&quot;, &quot;EU12&quot;,&quot;EA&quot;, &quot;Eurozone&quot;, &quot;all&quot;.
The option cluster = &quot;all&quot;  indicates that all countries in the dataset
have to be considered.
</p>


<h3>Value</h3>

<p>The dataset with the average of clustered countries.
</p>


<h3>References</h3>

 <p><a href="https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf">https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example 1
# Unweighted average of Member States for cluster "EU12":
myAC1&lt;-average_clust(emp_20_64_MS,timeName = "time",cluster = "EU12")

#  Visualize results for Italy:
myAC1$res[,c(1,17)]

# Visualize results for the first five member states:
myAC1$res[,c(1:6)]

# Example 2
# Unweighted average of Member States for cluster "EU25":
myAC2&lt;-average_clust(emp_20_64_MS,timeName = "time",cluster = "EU25")

# Visualize results for France:
myAC2$res[,c(1,13)]

# Visualize results for the first six member states:
myAC2$res[,c(1:7)]

# Example 3
# Unweighted average of countries for cluster "EU27":
myAC&lt;-average_clust(emp_20_64_MS,timeName = "time",cluster = "EU27")

# Visualize results for Germany:
myAC$res[,c(1,7)]

# Visualize results for the first five member states:
myAC$res[,c(1:6)]

</code></pre>

<hr>
<h2 id='beta_conv'>Beta-convergence statistic</h2><span id='topic+beta_conv'></span>

<h3>Description</h3>

<p>Given a dataframe of quantitative indicators along time,
the unconditional beta convergence is a statistic
capturing some important features.
A time variable must be present and sorted.
Missing values are not allowed. All other columns are indicator values
in each considered country.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beta_conv(
  tavDes,
  time_0,
  time_t,
  all_within = FALSE,
  timeName = "time",
  useTau = TRUE,
  useCon = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="beta_conv_+3A_tavdes">tavDes</code></td>
<td>
<p>the sorted dataframe time by countries on the original scale.
No other variable besides time and countries' indicator
must be present.</p>
</td></tr>
<tr><td><code id="beta_conv_+3A_time_0">time_0</code></td>
<td>
<p>reference time.</p>
</td></tr>
<tr><td><code id="beta_conv_+3A_time_t">time_t</code></td>
<td>
<p>target time strictly larger than time_0.</p>
</td></tr>
<tr><td><code id="beta_conv_+3A_all_within">all_within</code></td>
<td>
<p>is FALSE if just two different years are considered (default);
if  more than two years  are desired within the
specified interval then it must be  TRUE ; the reference time remains
time_0.</p>
</td></tr>
<tr><td><code id="beta_conv_+3A_timename">timeName</code></td>
<td>
<p>the name of the variable that contains time information.</p>
</td></tr>
<tr><td><code id="beta_conv_+3A_usetau">useTau</code></td>
<td>
<p>if TRUE the log ratio of indicator values is divided for
the elapsed time (years).</p>
</td></tr>
<tr><td><code id="beta_conv_+3A_usecon">useCon</code></td>
<td>
<p>if TRUE replaces 0 with a minimum constant value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the value of beta-conv, by OLS (least-squares), the
transformed data and standard statistical tests.
</p>


<h3>References</h3>

 <p><a href="https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf">https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example 1:
# Dataframe in the format years by countries:
require(tibble)
myTB1  &lt;- tibble::tribble(
  ~years, ~UK, ~DE, ~IT,
  1990,   998,  1250, 332,
  1988,   1201, 868, 578,
  1989,   1150, 978, 682,
  1991,  1600,  1350, 802
)

# Sort the time variable:
newdata &lt;- myTB1[order(myTB1$years),]

# Beta convergence statistic by considering just two times, e.g. 1989 and 1991:
myBC1 &lt;- beta_conv(newdata,1989,1991,timeName="years")

# Visualize the summary of the results (estimated coefficients, standard errors, p-values):
myBC1$res$summary

# Visualize the adjusted R-squared:
myBC1$res$adj.r.squared

# Beta convergence statistic by considering more than two times:
myBC2 &lt;- beta_conv(newdata,1988,1991,all_within=TRUE,timeName="years")

# Example 2:
# Dataframe in the format years by countries, time variable already sorted:
testTB &lt;- tribble(
    ~time, ~countryA ,  ~countryB,  ~countryC,
    2000,     0.8,   2.7,    3.9,
    2001,     1.2,   3.2,    4.2,
    2002,     0.9,   2.9,    4.1,
    2003,     1.3,   2.9,    4.0,
    2004,     1.2,   3.1,    4.1,
    2005,     1.2,   3.0,    4.0
    )
myBC3 &lt;- beta_conv(testTB, time_0 = 2000, time_t = 2005, timeName = "time")
myBC4 &lt;- beta_conv(testTB, time_0 = 2000, time_t = 2005, all_within = TRUE, timeName = "time")

# Example 3
# Beta convergence for the emp_20_64_MS Eurofound dataset:
data(emp_20_64_MS)
empBC &lt;- beta_conv(emp_20_64_MS, time_0 = 2002, time_t = 2006, timeName = "time")

# Summary of the model results:
empBC$res$summary

# Adjusted R-squared:
empBC$res$adj.r.squared


</code></pre>

<hr>
<h2 id='beta_conv_graph'>Graphical representation based on beta convergence</h2><span id='topic+beta_conv_graph'></span>

<h3>Description</h3>

<p>A ggplot of transformed data and a straight line for the results obtained for beta-convergence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beta_conv_graph(betaRes, indiName = NA, time_0 = NA, time_t = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="beta_conv_graph_+3A_betares">betaRes</code></td>
<td>
<p>the output obtained from beta_conv function.</p>
</td></tr>
<tr><td><code id="beta_conv_graph_+3A_indiname">indiName</code></td>
<td>
<p>name of the  considered indicator as a string.</p>
</td></tr>
<tr><td><code id="beta_conv_graph_+3A_time_0">time_0</code></td>
<td>
<p>starting time.</p>
</td></tr>
<tr><td><code id="beta_conv_graph_+3A_time_t">time_t</code></td>
<td>
<p>ending time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot object to be displayed of saved using ggsave.
</p>


<h3>References</h3>

 <p><a href="https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf">https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Example 1
# Beta convergence for the emp_20_64_MS Eurofound dataset in the period 2002-2006:
data(emp_20_64_MS)
empBC &lt;- beta_conv(emp_20_64_MS, time_0 = 2002, time_t = 2006, timeName = "time")

# Graphical plot based on the results for beta-convergence
empBCgraph &lt;- beta_conv_graph(empBC,2002,2006,indiName = 'Employment rate')
empBCgraph

# Example 2
# Beta convergence for the emp_20_64_MS Eurofound dataset in the period 2008-2016:
empBC1 &lt;- beta_conv(emp_20_64_MS, time_0 = 2008, time_t = 2016, timeName = "time")

# Graphical plot based on the results for beta-convergence
empBCgraph1 &lt;- beta_conv_graph(empBC1,2008,2016,indiName = 'Employment rate')
empBCgraph1


</code></pre>

<hr>
<h2 id='check_country'>Check a dataset (tibble) for the presence of countries</h2><span id='topic+check_country'></span>

<h3>Description</h3>

<p>A given list of countries is contained into a dataset (tibble).
If not, an object  signaling this error is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_country(myTB, clusterCode = "EU27")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_country_+3A_mytb">myTB</code></td>
<td>
<p>dataset (tibble) to be checked</p>
</td></tr>
<tr><td><code id="check_country_+3A_clustercode">clusterCode</code></td>
<td>
<p>string to denote  which countries should be in the dataset</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if they are inside, FALSE otherwise
</p>


<h3>References</h3>

 <p><a href="https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf">https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Check the dataset "emp_20_64_MS" for the presence of countries in cluster EU27:
check_country(emp_20_64_MS, clusterCode="EU27")

# Check absence for EU27:
check_country(emp_20_64_MS[,-(6:8)], clusterCode="EU27")

# Check the dataset "emp_20_64_MS" for the presence of countries in cluster EU25:
check_country(emp_20_64_MS, clusterCode="EU25")

# Check the dataset "emp_20_64_MS" for the presence of countries in cluster EU12:
check_country(emp_20_64_MS, clusterCode="EU12")

</code></pre>

<hr>
<h2 id='check_data'>Make tests on a dataset (dataframe and tibbles)</h2><span id='topic+check_data'></span>

<h3>Description</h3>

<p>A dataset can't have qualitative variables, neither vector of strings
nor missing values for computing convergence measures.
A time variable should also be present, and if the name is passed
then a check on the time order is performed.
The object returned states if the dataset is ready for calculations, and
if it is not, the error component states why checking failed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_data(tavDes, timeName = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_data_+3A_tavdes">tavDes</code></td>
<td>
<p>the dataframe under examination</p>
</td></tr>
<tr><td><code id="check_data_+3A_timename">timeName</code></td>
<td>
<p>a string with the name of the time  variable, optional</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object stating if errors are present
</p>


<h3>References</h3>

 <p><a href="https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf">https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example 1
# Tibble dataset with missing values:
require(tibble)
myTB1  &lt;- tibble::tribble(
~time, ~veval,
1988,   1201,
1989,    NA,
1990,   998,
1991,    NA
)
# Check dataset:
check_data(myTB1)

# Example 2
# Dataset with no missing values, no qualitative variables, and variable time present:
myTB2  &lt;- tibble::tribble(
~time, ~veval,
1988,   1201,
1989,    450,
1990,   998,
1991,   675
)
check_data(myTB2)

# Check the "emp_20_64_MS" Eurofound dataset:
data(emp_20_64_MS)
check_data(emp_20_64_MS, timeName="time")

</code></pre>

<hr>
<h2 id='coeu_grad'>Auxiliary function for gradients  and delta2</h2><span id='topic+coeu_grad'></span>

<h3>Description</h3>

<p>Intermediate calculation to define patterns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coeu_grad(mEU2, mEU1, mMS2, mMS1, time2, time1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coeu_grad_+3A_meu2">mEU2</code></td>
<td>
<p>average at time 2, EU</p>
</td></tr>
<tr><td><code id="coeu_grad_+3A_meu1">mEU1</code></td>
<td>
<p>average at time 1, EU</p>
</td></tr>
<tr><td><code id="coeu_grad_+3A_mms2">mMS2</code></td>
<td>
<p>average at time 2, Member State</p>
</td></tr>
<tr><td><code id="coeu_grad_+3A_mms1">mMS1</code></td>
<td>
<p>average at time 1, Member State</p>
</td></tr>
<tr><td><code id="coeu_grad_+3A_time2">time2</code></td>
<td>
<p>time 2</p>
</td></tr>
<tr><td><code id="coeu_grad_+3A_time1">time1</code></td>
<td>
<p>time 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with components time length, grad of member state,
grad of EU average and the delta squared difference at a pair
of times.
</p>

<hr>
<h2 id='coeu_gradV'>Auxiliary function to provide a different object as input</h2><span id='topic+coeu_gradV'></span>

<h3>Description</h3>

<p>See  function coeu_grad for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coeu_gradV(mEU, mMS, time)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coeu_gradV_+3A_meu">mEU</code></td>
<td>
<p>averages at time1 and time 2</p>
</td></tr>
<tr><td><code id="coeu_gradV_+3A_mms">mMS</code></td>
<td>
<p>indicator for a member country at time1 and time2</p>
</td></tr>
<tr><td><code id="coeu_gradV_+3A_time">time</code></td>
<td>
<p>the two times considered, sorted in ascending order</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with components time length, grad of member state,
grad of EU average and the delta squared difference at a pair
of times.
</p>

<hr>
<h2 id='compo_cond_EUS'>Auxiliary function compo_cond_EUS</h2><span id='topic+compo_cond_EUS'></span>

<h3>Description</h3>

<p>Not exported
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compo_cond_EUS(myScarica)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compo_cond_EUS_+3A_myscarica">myScarica</code></td>
<td>
<p>a bulk downloaded tibble from Eurostat</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a tag based on indicator-specific  conditioning variables
</p>

<hr>
<h2 id='convergEU_glb'>Global objects for convergEU package</h2><span id='topic+convergEU_glb'></span>

<h3>Description</h3>

<p>This is a list of constants and setups for the package. In this function that generates global static objects
and tables, cluster of countries are stored with their corresponding labels as well as indicators information
and labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convergEU_glb()
</code></pre>


<h3>Details</h3>

<p>Note that EU27 refers to Member States after the 1st February 2020, while EU28 is a valid
tag up to 31 March 2020. String EU27_2020 and EU27_2007 as defined by Eurofound are also
available.
</p>
<p>The following clusters of countries are stored: EU12, EU15, EU25,
EU27, EA, Euroarea. Current Member States are elements of EU27_2020.
The cluster geoRefEUF is composed of both Member States and other countries
(neighboring countries). The component &quot;metaEUstat&quot; contains the indicators'
information, while the component &quot;paralintags&quot; is for defining patterns for the Member States.
</p>


<h3>Value</h3>

<p>a list of constants and objects for package convergEU
</p>


<h3>References</h3>

 <p><a href="https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf">https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Member States in the cluster Euroarea:
convergEU_glb()$Euroarea

# Cluster EU12 of Member States:
convergEU_glb()$EU12

# Cluster EU27 of Member States after 31 jan 2020:
convergEU_glb()$EU27

# Cluster EU28 of Member States up to jan 2020:
convergEU_glb()$EU28

# The countries in the cluster geoRefEUF:
convergEU_glb()$geoRefEUF

# Metainformation on indicators of the European Union:
convergEU_glb()$metaEUStat

</code></pre>

<hr>
<h2 id='country_ranking'>Ranking of EU countries by time</h2><span id='topic+country_ranking'></span>

<h3>Description</h3>

<p>Countries are ranked for each time according to two types of indicators: higher is the best (highBest)
or lower is the best (lowBest).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>country_ranking(
  myTB,
  timeName = "time",
  time_0 = NA,
  time_t = NA,
  typeInd = "highBest"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="country_ranking_+3A_mytb">myTB</code></td>
<td>
<p>the dataframe time by countries (complete and sorted by
increasing time).</p>
</td></tr>
<tr><td><code id="country_ranking_+3A_timename">timeName</code></td>
<td>
<p>the name of the variable that contains time information.</p>
</td></tr>
<tr><td><code id="country_ranking_+3A_time_0">time_0</code></td>
<td>
<p>starting time to consider; if NA all times considered.</p>
</td></tr>
<tr><td><code id="country_ranking_+3A_time_t">time_t</code></td>
<td>
<p>last time to consider; if NA all times considered.</p>
</td></tr>
<tr><td><code id="country_ranking_+3A_typeind">typeInd</code></td>
<td>
<p>&quot;highBest&quot; is the default, &quot;lowBest&quot; is the alternative</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list  with component res which contains ranking by each considered year
</p>


<h3>References</h3>

<p><a href="https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf">https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example 1
# Sorted dataframe in the format years by countries:
require(tibble)
myTB  &lt;- tibble::tribble(
~years, ~UK, ~DE, ~IT,
1988,   1201, 868, 578,
1989,   1150, 978, 682,
1990,   998,  1250, 332,
1991,  1600,  1350, 802
)

# Country ranking according to the indicator higher is the best:
res &lt;- country_ranking(myTB,timeName="years")

# Country ranking according to the indicator lower is the best:
res1 &lt;- country_ranking(myTB,timeName="years", typeInd="lowBest")

# Country ranking for some years only:
myres &lt;- country_ranking(myTB,timeName="years", time_0=1989,time_t=1990,typeInd="lowBest" )

# Example 2
# Ranking of the Member States for the "emp_20_64_MS" dataset
data(emp_20_64_MS)
myCR&lt;-country_ranking(emp_20_64_MS,timeName = "time", time_0 = 2007, time_t = 2010)

# Visualize the results for the first five countries:
myCR$res[1:6]


</code></pre>

<hr>
<h2 id='dbEUF2018meta'>Metainformation on Eurofound dataset</h2><span id='topic+dbEUF2018meta'></span>

<h3>Description</h3>

<p>Metainformation about data provided by Eurofound currently up to 2018.
Metainformation is provided for two dimensions: quality of life and working conditions.
For each dimension, metainformation for several indicators is reported, e.g. coding in database, official code,
measurement unit, source organization, disaggregation and bookmark URL.
Variable names often end with characters denoting scales:
The following convention holds for names of variables:
&quot;_p&quot;	percentage, &quot;_i&quot; index, &quot;_pop&quot; persons, &quot;_h&quot; hours,
&quot;_eur&quot; euros, &quot;_pps&quot;	purchasing power standards,
&quot;_y&quot;	years.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dbEUF2018meta)
</code></pre>


<h3>Format</h3>

<p>A dataset  with 13 rows and 10 columns
</p>


<h3>Source</h3>

<p><a href="https://www.eurofound.europa.eu/en/surveys/about-eurofounds-surveys/data-availability">https://www.eurofound.europa.eu/en/surveys/about-eurofounds-surveys/data-availability</a>
</p>


<h3>References</h3>

<p><a href="https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf">https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(dbEUF2018meta)
names(dbEUF2018meta)

## Not run: 
View(dbEUF2018meta)

## End(Not run)

# Visualize metainformation on the indicators stored in the dataset:
dbEUF2018meta$INDICATOR

# Visualize the indicators coding in database:
dbEUF2018meta$Code_in_database

# Visuazlize the indicators official code:
dbEUF2018meta$Official_code


</code></pre>

<hr>
<h2 id='dbEurofound'>Eurofound dataset</h2><span id='topic+dbEurofound'></span>

<h3>Description</h3>

<p>Source data provided by Eurofound currently up to 2018.
Variable names often end with characters denoting scales.
The following convention holds for names of variables:
&quot;_p&quot;	percentage, &quot;_i&quot; index, &quot;_pop&quot; persons, &quot;_h&quot; hours,
&quot;_eur&quot; euros, &quot;_pps&quot;	purchasing power standards,
&quot;_y&quot;	years.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dbEurofound)
</code></pre>


<h3>Format</h3>

<p>A tibble dataset  with 17 columns
</p>

<dl>
<dt>time</dt><dd><p> time </p>
</dd>
<dt>geo</dt><dd><p> geo </p>
</dd>
<dt>geo_label</dt><dd><p> geo_label </p>
</dd>
<dt>sex</dt><dd><p> gender </p>
</dd>
<dt>lifesatisf</dt><dd><p> Mean_life_satisfaction </p>
</dd>
<dt>health</dt><dd><p> Mean_health_status </p>
</dd>
<dt>goodhealth_p</dt><dd><p> Percentage_of_people_with_good_or_very_good_health </p>
</dd>
<dt>trustlocal</dt><dd><p> Mean_level_of_trust_in_local_government </p>
</dd>
<dt>volunt</dt><dd><p> Level_of_involvement_in_volunteering </p>
</dd>
<dt>volunt_p</dt><dd><p> Percentage_of_people_involved_in_volunteering </p>
</dd>
<dt>caring_h</dt><dd><p> Hours_per_week_spent_in_informal_care </p>
</dd>
<dt>socialexc_i</dt><dd><p> Social_Exclusion_Index </p>
</dd>
<dt>JQIskill_i</dt><dd><p> JQI_Skills_and_discretion_index </p>
</dd>
<dt>JQIenviron_i</dt><dd><p> JQI_Physical_environment_index </p>
</dd>
<dt>JQIintensity_i</dt><dd><p> JQI_Intensity_index </p>
</dd>
<dt>JQItime_i</dt><dd><p> JQI_Working_time_quality_index </p>
</dd>
<dt>exposdiscr_p</dt><dd><p> Exposition_to_discrimination </p>
</dd>
</dl>



<h3>Details</h3>

<p>Further details and metainformation on these data are contained into
the dataset *dbEUF2018meta*, say *data(dbEUF2018meta)* in R.
</p>


<h3>Source</h3>

<p><a href="https://www.eurofound.europa.eu/en/surveys/about-eurofounds-surveys/data-availability">https://www.eurofound.europa.eu/en/surveys/about-eurofounds-surveys/data-availability</a>
</p>


<h3>References</h3>

<p><a href="https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf">https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("dbEurofound")
head(dbEurofound)

# Variable names:
names(dbEurofound)

# time ranges interval:
c(min(dbEurofound$time), max(dbEurofound$time))


</code></pre>

<hr>
<h2 id='dbMetaEUStat'>Eurostat metainformation</h2><span id='topic+dbMetaEUStat'></span>

<h3>Description</h3>

<p>Metainformation about data from Eurostat processed at Eurofound. More precisely,
metainformation is provided for three dimensions: employment, socio economic and quality of life.
For each dimension, metainformation for several indicators is reported, e.g. coding in database, official code,
measurement unit, source organization, disaggregation and bookmark URL.
Variable names often end with characters denoting scales.
The following convention holds for names of variables:
&quot;_p&quot;	percentage, &quot;_i&quot; index, &quot;_pop&quot; persons, &quot;_h&quot; hours,
&quot;_eur&quot; euros, &quot;_pps&quot;	purchasing power standards,
&quot;_y&quot;	years.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dbMetaEUStat)
</code></pre>


<h3>Format</h3>

<p>A tibble dataset with 56 rows and 10 columns
</p>


<h3>Source</h3>

<p><a href="https://ec.europa.eu/eurostat/data/database">https://ec.europa.eu/eurostat/data/database</a>
</p>


<h3>References</h3>

<p><a href="https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf">https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(dbMetaEUStat)
names(dbMetaEUStat)


# Visualize indicators' information:
dbMetaEUStat$INDICATOR

# Visualize the indicators' coding in database:
dbMetaEUStat$Code_in_database

# Visualize the indicators' official coding:
dbMetaEUStat$Official_code


</code></pre>

<hr>
<h2 id='delta_conv'>Delta-convergence statistic</h2><span id='topic+delta_conv'></span>

<h3>Description</h3>

<p>Given a dataframe of quantitative indicators along time,
the delta convergence is a statistic describing departures from best performer.
A time variable may be present or not, but if it is not present
then rows must be already sorted. Missing values are not allowed.
If the time variable is omitted, subsequent rows are separated
by one time unit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delta_conv(
  tavDes,
  timeName = "time",
  indiType = "highBest",
  time_0 = NA,
  time_t = NA,
  extended = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="delta_conv_+3A_tavdes">tavDes</code></td>
<td>
<p>the dataframe time by countries.</p>
</td></tr>
<tr><td><code id="delta_conv_+3A_timename">timeName</code></td>
<td>
<p>the name of the variable that contains time information;
if it is set to NA then no time information is exploited.</p>
</td></tr>
<tr><td><code id="delta_conv_+3A_inditype">indiType</code></td>
<td>
<p>the indicator type; the default is &quot;highBest&quot;, otherwise
it is equal to &quot;lowBest&quot;.</p>
</td></tr>
<tr><td><code id="delta_conv_+3A_time_0">time_0</code></td>
<td>
<p>starting time to consider; if NA all times considered.</p>
</td></tr>
<tr><td><code id="delta_conv_+3A_time_t">time_t</code></td>
<td>
<p>last time to consider; if NA all times considered.</p>
</td></tr>
<tr><td><code id="delta_conv_+3A_extended">extended</code></td>
<td>
<p>if FALSE only  measures of convergence are produced, otherwise
the declaration of convergence is also provided.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a tibble with the value of delta-conv (called delta) along time,
which is called 'time'.
</p>


<h3>References</h3>

<p><a href="https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf">https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example 1
# Delta convergence with time present
# Dataframe in the format time by countries:
myTB  &lt;- tibble::tribble(
~time, ~UK, ~DE, ~IT,
1988,   1201, 868, 578,
1989,   1150, 978, 682,
1990,   998,  1250, 332
)
resDelta &lt;- delta_conv(myTB)

# Example 2
# Delta convergence with scrambled time order (time present):
myTB2  &lt;- tibble::tribble(
~time, ~UK, ~DE, ~IT,
1990,   998,  1250, 332,
1988,   1201, 868, 578,
1989,   1150, 978, 682
)
resDelta1&lt;-delta_conv(myTB2)

# Example 3
# Delta convergence, scrambled time and different name for the time variable:
myTB2  &lt;- tibble::tribble(
~years, ~UK, ~DE, ~IT,
90,   998,  1250, 332,
88,   1201, 868, 578,
89,   1150, 978, 682
)
resDelta2 &lt;- delta_conv(myTB2,timeName="years")

# Example 4
# Delta convergence for the emp_20_64_MS Eurofound dataset:
data("emp_20_64_MS")
# check name of the time variable:
names(emp_20_64_MS)

# Calculate delta convergence:
resDelta3&lt;-delta_conv(emp_20_64_MS)

# Obtain measures of delta-convergence and the declaration of convergence:
resDelta4&lt;-delta_conv(emp_20_64_MS, extended = TRUE)

</code></pre>

<hr>
<h2 id='demea_change'>Calculate changes of deviations from the mean</h2><span id='topic+demea_change'></span>

<h3>Description</h3>

<p>Deviations from the mean of a collection of countries is calculated for
each year. Then differences at subsequent times are calculated within
each member state. Finally negative differences are added over years within
member state, and similarly  positive differences are added over years
within member state.
The output is made by  datasets with intermediate calculations,
and by the component statistics which is  member state by statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>demea_change(
  myTB,
  timeName = "time",
  time_0 = NA,
  time_t = NA,
  sele_countries = NA,
  doplot = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="demea_change_+3A_mytb">myTB</code></td>
<td>
<p>a dataset time by countries</p>
</td></tr>
<tr><td><code id="demea_change_+3A_timename">timeName</code></td>
<td>
<p>name of the variable representing time</p>
</td></tr>
<tr><td><code id="demea_change_+3A_time_0">time_0</code></td>
<td>
<p>starting time</p>
</td></tr>
<tr><td><code id="demea_change_+3A_time_t">time_t</code></td>
<td>
<p>ending time</p>
</td></tr>
<tr><td><code id="demea_change_+3A_sele_countries">sele_countries</code></td>
<td>
<p>selection of countries to display;
NA means all countries</p>
</td></tr>
<tr><td><code id="demea_change_+3A_doplot">doplot</code></td>
<td>
<p>if a ggplot2 graphical object desired then TRUE, otherwise
it is FALSE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let </p>
<p style="text-align: center;"><code class="reqn">Y_{i,t,m}</code>
</p>
<p> be the indicator value i at time t for
country m.
Let </p>
<p style="text-align: center;"><code class="reqn">D_{i,t,m} = Y_{i,t,m} - M_{i,t,m}</code>
</p>
<p> be the departure from the mean
at time t.
Let </p>
<p style="text-align: center;"><code class="reqn">d_{i,t,m} = | D_{i,t,m}| - | D_{i,t,m}|</code>
</p>
<p> be the difference of
absolute values within country m at time t.
Then the overall negative and positive changes   are
</p>
<p style="text-align: center;"><code class="reqn">Cn(i,t,m) = \sum_{t} d_{i,t,m} I_{d&lt;=0}(d)</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">Cp(i,t,m) = \sum_{t} d_{i,t,m} I_{d&gt;0}(d)</code>
</p>



<h3>Value</h3>

<p>A list with intermediate and final statistics; list component res_graph
is a ggplot2 object if the argument doplot = TRUE; to plot the object
use function plot().
</p>


<h3>References</h3>

<p><a href="https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf">https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Example 1
# A dataset in the format time by countries:
require(tibble)
testTB &lt;- dplyr::tribble(
~time, ~countryA ,  ~countryB,  ~countryC,
2000,     0.8,   2.7,    3.9,
2001,     1.2,   3.2,    4.2,
2002,     0.9,   2.9,    4.1,
2003,     1.3,   2.9,    4.0,
2004,     1.2,   3.1,    4.1,
2005,     1.2,   3.0,    4.0
)
res &lt;- demea_change(testTB,
             timeName="time",
             time_0 = 2000,
             time_t = 2005,
             sele_countries= NA,
             doplot=TRUE)


plot(res$res$res_graph)


# Example 2
# Deviations from the mean for the emp_20_64_MS Eurofound dataset
data(emp_20_64_MS)

# Calculate deviations from the mean from 2013 to 2016 for Italy, France and Germany
res1&lt;-demea_change(emp_20_64_MS,
      timeName="time",
      time_0 = 2013,
      time_t = 2016,
      sele_countries= c('IT','FR','DE'),
      doplot=TRUE)

plot(res1$res$res_graph)



</code></pre>

<hr>
<h2 id='departure_best'>Departures from the best country</h2><span id='topic+departure_best'></span>

<h3>Description</h3>

<p>For each country the departure from the best performing Member State  is calculated.
Then, differences are cumulated over years.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>departure_best(oriTB, timeName = "time", indiType = "highBest")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="departure_best_+3A_oritb">oriTB</code></td>
<td>
<p>original dataset (tibble) with time by country values.</p>
</td></tr>
<tr><td><code id="departure_best_+3A_timename">timeName</code></td>
<td>
<p>string with the name of the time variable in oriTB.</p>
</td></tr>
<tr><td><code id="departure_best_+3A_inditype">indiType</code></td>
<td>
<p>the type of indicator 'highBest' (default) or 'lowBest'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with component res which contains the departures from the best performer (for each country and for each year)
and the cumulated differences over years.
</p>


<h3>References</h3>

 <p><a href="https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf">https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example 1
# Sorted dataframe in the format years by countries:
require(tibble)
testTB &lt;- dplyr::tribble(
~time, ~countryA ,  ~countryB,  ~countryC,
2000,     0.8,   2.7,    3.9,
2001,     1.2,   3.2,    4.2,
2002,     0.9,   2.9,    0.1,
2003,     1.3,   2.9,    1.0,
2004,     1.2,   3.1,    4.1,
2005,     1.2,   3.0,    4.0
)

# Departures from the best country according to the indicator higher is the best:
mySTB &lt;- departure_best(testTB,timeName="time",indiType = "highBest")
# Differences from the best country for each year:
mySTB$res$raw_departures
# Sum of the cumulated differences for each country:
mySTB$res$cumulated_dif

# Departures from the best country according to the indicator lower is the best:
mySTB1 &lt;- departure_best(testTB,timeName="time",indiType = "lowBest")

# Example 2
# Departures from the best country for the emp_20_64_MS Eurofound dataset:
mySTB2 &lt;- departure_best(emp_20_64_MS,timeName="time",indiType = "highBest")
mySTB3 &lt;- departure_best(emp_20_64_MS,timeName="time",indiType = "lowBest")


</code></pre>

<hr>
<h2 id='departure_best_plot'>Plot of deviations from the best performer</h2><span id='topic+departure_best_plot'></span>

<h3>Description</h3>

<p>Deviations from the best performer  are added over years
and plotted by country.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>departure_best_plot(
  cumulaDifVector,
  mainCountry = NA,
  countries = c(NA, NA),
  displace = 0.25,
  axis_name_y = "Countries",
  val_alpha = 0.95,
  debug = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="departure_best_plot_+3A_cumuladifvector">cumulaDifVector</code></td>
<td>
<p>a vector of cumulated differences, say from
a call to departure_best()$res$cumulated_dif, with named elements.</p>
</td></tr>
<tr><td><code id="departure_best_plot_+3A_maincountry">mainCountry</code></td>
<td>
<p>the main country of interest.</p>
</td></tr>
<tr><td><code id="departure_best_plot_+3A_countries">countries</code></td>
<td>
<p>selection of countries to display; NA means all countries</p>
</td></tr>
<tr><td><code id="departure_best_plot_+3A_displace">displace</code></td>
<td>
<p>graphical displacement</p>
</td></tr>
<tr><td><code id="departure_best_plot_+3A_axis_name_y">axis_name_y</code></td>
<td>
<p>name of the axis</p>
</td></tr>
<tr><td><code id="departure_best_plot_+3A_val_alpha">val_alpha</code></td>
<td>
<p>transparency value in (0,1].</p>
</td></tr>
<tr><td><code id="departure_best_plot_+3A_debug">debug</code></td>
<td>
<p>a flag to get debug information as msg component</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with ggplot2 graphical object within res component
</p>


<h3>References</h3>

<p><a href="https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf">https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example 1
# Sorted dataframe in the format years by countries:
require(tibble)
testTB &lt;- dplyr::tribble(
~time, ~countryA ,  ~countryB,  ~countryC,
2000,     0.8,   2.7,    3.9,
2001,     1.2,   3.2,    4.2,
2002,     0.9,   2.9,    0.1,
2003,     1.3,   2.9,    1.0,
2004,     1.2,   3.1,    4.1,
2005,     1.2,   3.0,    4.0
)

# Departures from the best country according to the "highBest" indicator:
mySTB &lt;- departure_best(testTB,timeName="time",indiType = "highBest")

# Plot of deviations from the best performer:
departure_best_plot(cumulaDifVector = mySTB$res$cumulated_dif, mainCountry = "countryC",
countries = c("countryA","countryB"),displace = 0.25,
axis_name_y = "Countries",val_alpha  = 0.95,debug=FALSE)

# Departures from the best country according to the "lowBest" indicator:
mySTB1 &lt;- departure_best(testTB,timeName="time",indiType = "lowBest")
departure_best_plot(cumulaDifVector = mySTB1$res$cumulated_dif, mainCountry = "countryC",
countries = c("countryA","countryB"),displace = 0.25,
axis_name_y = "Countries",val_alpha  = 0.95,debug=FALSE)

# Example 2
# Departures from the best country for the emp_20_64_MS Eurofound dataset:
mySTB2 &lt;- departure_best(emp_20_64_MS,timeName="time",indiType = "highBest")
# Plot of deviations from the best performer with Italy as the country of interest:
departure_best_plot(mySTB2$res$cumulated_dif,
  mainCountry = "IT",
  countries=c("AT", "DE", "FR","SE","SK"),
  displace = 0.25,
  axis_name_y = "Countries",
  val_alpha  = 0.95,
  debug=FALSE)

 mySTB3 &lt;- departure_best(emp_20_64_MS,timeName="time",indiType = "lowBest")
 # Plot of deviations from the best performer with Germany as the country of interest:
 departure_best_plot(mySTB3$res$cumulated_dif,
 mainCountry = "DE",
 countries=c("AT", "SE", "FR","IT","SK"),
 displace = 0.25,
 axis_name_y = "Countries",
 val_alpha  = 0.95,
 debug=FALSE)
 
</code></pre>

<hr>
<h2 id='departure_mean'>Departures from an average</h2><span id='topic+departure_mean'></span>

<h3>Description</h3>

<p>For each country the departure from the average is calculated
and a numerical label is created: -1 if smaller than one standard deviation
from the mean, +1 if above one standard deviation from the mean, 0 otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>departure_mean(oriTB, sigmaTB, timeName = "time")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="departure_mean_+3A_oritb">oriTB</code></td>
<td>
<p>original dataset (tibble) with time by country values.</p>
</td></tr>
<tr><td><code id="departure_mean_+3A_sigmatb">sigmaTB</code></td>
<td>
<p>result from sigma_convergence called on oriTB.</p>
</td></tr>
<tr><td><code id="departure_mean_+3A_timename">timeName</code></td>
<td>
<p>string with the name of the time variable in oriTB.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of tibbles containing  labelled departures from the mean, square difference from the mean,
and percentage of deviance.
</p>


<h3>References</h3>

<p><a href="https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf">https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example 1
# The original dataset in the format time by countries:
require(tibble)
testTB &lt;- dplyr::tribble(
~time, ~countryA ,  ~countryB,  ~countryC,
2000,     0.8,   2.7,    3.9,
2001,     1.2,   3.2,    4.2,
2002,     0.9,   2.9,    4.1,
2003,     1.3,   2.9,    4.0,
2004,     1.2,   3.1,    4.1,
2005,     1.2,   3.0,    4.0
)

# Calculate sigma_convergence on the original dataset:
mySTB &lt;- sigma_conv(testTB)

# Calculate departures from the average for each country:
resDM &lt;-  departure_mean(oriTB=testTB, sigmaTB=mySTB$res)
names(resDM$res)

# Example 2: Departures from the average for the Eurofound dataset "emp_20_64_MS"
data(emp_20_64_MS)
# Sigma convergence on the original dataset:
mySC &lt;- sigma_conv(emp_20_64_MS)

# Calculate departures from the mean for each country:
resDMeur &lt;- departure_mean(oriTB = emp_20_64_MS, sigmaTB = mySC$res)

# Results for labelled departures from the mean:
resDMeur$res$departures

# Results for square difference from the mean:
resDMeur$res$squaredContrib

# Results for the percentage of deviance:
resDMeur$res$devianceContrib

</code></pre>

<hr>
<h2 id='dev_mean_plot'>Plot of deviations from the mean</h2><span id='topic+dev_mean_plot'></span>

<h3>Description</h3>

<p>Negative deviations and positive deviations are added over years
and plotted by country.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dev_mean_plot(
  myTB,
  timeName = "time",
  time_0 = NA,
  time_t = NA,
  countries = c(NA, NA),
  indiType = "highBest",
  displace = 0.25,
  axis_name_y = "Countries",
  val_alpha = 0.95,
  debug = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dev_mean_plot_+3A_mytb">myTB</code></td>
<td>
<p>a dataset time by countries</p>
</td></tr>
<tr><td><code id="dev_mean_plot_+3A_timename">timeName</code></td>
<td>
<p>name of the variable representing time</p>
</td></tr>
<tr><td><code id="dev_mean_plot_+3A_time_0">time_0</code></td>
<td>
<p>starting time</p>
</td></tr>
<tr><td><code id="dev_mean_plot_+3A_time_t">time_t</code></td>
<td>
<p>ending time</p>
</td></tr>
<tr><td><code id="dev_mean_plot_+3A_countries">countries</code></td>
<td>
<p>selection of countries to display; NA means all countries</p>
</td></tr>
<tr><td><code id="dev_mean_plot_+3A_inditype">indiType</code></td>
<td>
<p>the type of indicator  &quot;highBest&quot; or &quot;lowBest&quot;</p>
</td></tr>
<tr><td><code id="dev_mean_plot_+3A_displace">displace</code></td>
<td>
<p>graphical displacement</p>
</td></tr>
<tr><td><code id="dev_mean_plot_+3A_axis_name_y">axis_name_y</code></td>
<td>
<p>name of the axis</p>
</td></tr>
<tr><td><code id="dev_mean_plot_+3A_val_alpha">val_alpha</code></td>
<td>
<p>transparency value in (0,1].</p>
</td></tr>
<tr><td><code id="dev_mean_plot_+3A_debug">debug</code></td>
<td>
<p>a flag to get debug information as msg component</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with ggplot2 graphical object within res component
</p>


<h3>References</h3>

<p><a href="https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf">https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# Example 1
# A dataset in the format time by countries:
require(tibble)
testTB &lt;- dplyr::tribble(
~time, ~countryA ,  ~countryB,  ~countryC,
2000,     0.8,   2.7,    3.9,
2001,     1.2,   3.2,    4.2,
2002,     0.9,   2.9,    4.1,
2003,     1.3,   2.9,    4.0,
2004,     1.2,   3.1,    4.1,
2005,     1.2,   3.0,    4.0
)
# Plot the deviations from the mean for all countries:
resDMP &lt;- dev_mean_plot(testTB,
                        timeName="time",
                        displace = 0.25,
                        axis_name_y = "Countries")
resDMP

# Plot by considering only some of the years:
resDMP1 &lt;- dev_mean_plot(testTB,
                       timeName="time",
                       time_0 = 2002,
                       time_t = 2004,
                       displace = 0.25,
                       axis_name_y = "Countries")
resDMP1

# Example 2
# The Eurofound dataset "emp_20_64_MS":
myTB1 &lt;- emp_20_64_MS

# Plot the deviations from the mean only for some of the member states:
resDMP2 &lt;- dev_mean_plot(myTB1,
                       timeName="time",
                       time_0 = 2005,
                       time_t = 2010,
                       countries= c("AT","BE","IT"),
                       displace = 0.25,
                       axis_name_y = "Countries")
resDMP2

## End(Not run)

</code></pre>

<hr>
<h2 id='dow_soc_scor_boa'>Downloader of social scoreboard indicators</h2><span id='topic+dow_soc_scor_boa'></span>

<h3>Description</h3>

<p>This is an &quot;envelope function&quot; to automate the download from Eurostat
of all the indicators involved in the social scoreboard.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dow_soc_scor_boa(fromTime = 1999, toTime = 2018, rm.EU = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dow_soc_scor_boa_+3A_fromtime">fromTime</code></td>
<td>
<p>starting time</p>
</td></tr>
<tr><td><code id="dow_soc_scor_boa_+3A_totime">toTime</code></td>
<td>
<p>ending time</p>
</td></tr>
<tr><td><code id="dow_soc_scor_boa_+3A_rm.eu">rm.EU</code></td>
<td>
<p>is TRUE remove all variables (columns) starting with
&quot;EU&quot; and &quot;EA&quot;, that is averages for different groups of countries.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the downloaded datasets may have auxiliary columns to be later removed
and they may contain missing values, thus before further calculation taking place,
imputation or truncation of missing values must be performed.
Extra columns include EU12 and other similar weighted averages.
</p>


<h3>Value</h3>

<p>a list with as many components as indicators.
</p>


<h3>References</h3>

 <p><a href="https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf">https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf</a>
</p>

<hr>
<h2 id='down_lo_EUS'>Download  a dataset (tibble) from Eurostat.</h2><span id='topic+down_lo_EUS'></span>

<h3>Description</h3>

<p>From the Eurostat web site, a dataset is created whose structure is
time by countries, possibly conditioned to  gender, age class and other
variables. All indicators are supported and, after  downloading, data are not
filtered by country members (geo) and/or EU clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>down_lo_EUS(
  indicator_code,
  fromTime,
  toTime,
  gender = c(NA, "T", "F", "M")[1],
  ageInterv = NA,
  rawDump = FALSE,
  uniqueIdentif = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="down_lo_EUS_+3A_indicator_code">indicator_code</code></td>
<td>
<p>defined by Eurostat as id.</p>
</td></tr>
<tr><td><code id="down_lo_EUS_+3A_fromtime">fromTime</code></td>
<td>
<p>first year to be considered.</p>
</td></tr>
<tr><td><code id="down_lo_EUS_+3A_totime">toTime</code></td>
<td>
<p>last year to be considered.</p>
</td></tr>
<tr><td><code id="down_lo_EUS_+3A_gender">gender</code></td>
<td>
<p>if available, the gender of interest
c(&quot;T&quot;,&quot;F&quot;,&quot;M&quot;) for Total, Females, Males.</p>
</td></tr>
<tr><td><code id="down_lo_EUS_+3A_ageinterv">ageInterv</code></td>
<td>
<p>if available,
a string of character representing the age class to
be considered as coded by Eurostat, for example 'Y15-74'.</p>
</td></tr>
<tr><td><code id="down_lo_EUS_+3A_rawdump">rawDump</code></td>
<td>
<p>if TRUE raw downloaded data are returned, otherwise
filtered values are provided.</p>
</td></tr>
<tr><td><code id="down_lo_EUS_+3A_uniqueidentif">uniqueIdentif</code></td>
<td>
<p>identifiers of further conditional variables (1,2,...).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is up to the user to proceed with further filtering/selection
so that the desired
collection of member states is obtained.
</p>


<h3>Value</h3>

<p>a dataset (tibble) years by countries, possibly conditioned
to gender, within the  list  as  component named res.
If rawDump is TRUE then bulk data are provided. The list component
msg may contain auxiliary information on conditioning variables.
</p>


<h3>References</h3>

<p><a href="https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf">https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
myDF1 &lt;- down_lo_EUS(indicator_code = "lfsa_ergaed",
                    fromTime = 2005,
                    toTime = 2015,
                    gender=  "F",
                    ageInterv = NA,
                    rawDump=FALSE,
                    uniqueIdentif = 1)

myDF2 &lt;- down_lo_EUS(indicator_code = "lfsa_ergaed",
                    fromTime = 2005,
                    toTime = 2015,
                    gender=  "M",
                    ageInterv = "Y15-64",
                    rawDump=FALSE,
                    uniqueIdentif = 3)


## End(Not run)
</code></pre>

<hr>
<h2 id='download_indicator_EUS'>Download  a dataset (tibble) from Eurostat.</h2><span id='topic+download_indicator_EUS'></span>

<h3>Description</h3>

<p>From the Eurostat web site, a dataset is created whose structure is
years by countries, possibly conditioned to  gender, age class and other
variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>download_indicator_EUS(
  indicator_code,
  fromTime,
  toTime,
  gender = c(NA, "T", "F", "M")[1],
  ageInterv = NA,
  countries = c("BE", "DK", "FR", "DE", "EL", "IE", "IT", "LU", "NL", "PT", "ES", "AT",
    "FI", "SE", "CY", "CZ", "EE", "HU", "LV", "LT", "MT", "PL", "SK", "SI", "BG", "RO",
    "HR"),
  rawDump = FALSE,
  uniqueIdentif = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="download_indicator_EUS_+3A_indicator_code">indicator_code</code></td>
<td>
<p>the variable describing countries, chosen within
the collection   convergEU_glb()$metaEUStat$selectorUser.</p>
</td></tr>
<tr><td><code id="download_indicator_EUS_+3A_fromtime">fromTime</code></td>
<td>
<p>first year to be considered.</p>
</td></tr>
<tr><td><code id="download_indicator_EUS_+3A_totime">toTime</code></td>
<td>
<p>last year to be considered.</p>
</td></tr>
<tr><td><code id="download_indicator_EUS_+3A_gender">gender</code></td>
<td>
<p>which gender, one of  c(&quot;T&quot;,&quot;F&quot;,&quot;M&quot;) for Total, Females, Males.</p>
</td></tr>
<tr><td><code id="download_indicator_EUS_+3A_ageinterv">ageInterv</code></td>
<td>
<p>a string of character representing the age class to
be considered as coded by Eurostat, for example 'Y15-74'.</p>
</td></tr>
<tr><td><code id="download_indicator_EUS_+3A_countries">countries</code></td>
<td>
<p>a collection of strings representing countries
in the standard two letters format; the most important
sets are stored as a  global function
convergEU_glb(), for example convergEU_glb()$EU27;
if countries = NA, then all available countries are
downloaded.</p>
</td></tr>
<tr><td><code id="download_indicator_EUS_+3A_rawdump">rawDump</code></td>
<td>
<p>if TRUE raw downloaded data are returned, otherwise
filtered values are provided.</p>
</td></tr>
<tr><td><code id="download_indicator_EUS_+3A_uniqueidentif">uniqueIdentif</code></td>
<td>
<p>identifiers of further conditional variables (1,2,...).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataset (tibble) years by countries, possibly conditioned
to gender, within the  list  as  component named res.
If rawDump is TRUE then bulk data are provided. The list component
msg may contain auxiliary information on conditioning variables.
</p>


<h3>References</h3>

<p><a href="https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf">https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf</a>
</p>

<hr>
<h2 id='emp_20_64_MS'>Dataset emp_20_64_MS</h2><span id='topic+emp_20_64_MS'></span>

<h3>Description</h3>

<p>Source data provided by Eurofound, and
reshaped so that the first column is time
and all the other 28 columns are employment values of Member States. The first column refers to the time variable
(e.g. years); the remaining 28 columns refer to the Member States; each Member State is identified through its
corresponding country code accessible by invoking *convergEU_glb()$Eurozone$memberStates*.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(emp_20_64_MS)
</code></pre>


<h3>Format</h3>

<p>A data frame with 17 rows and 29 variables
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(emp_20_64_MS)
head(emp_20_64_MS)
names(emp_20_64_MS)

</code></pre>

<hr>
<h2 id='extract_indicator_ECG'>Create a dataset (tibble) for an ECG indicator.</h2><span id='topic+extract_indicator_ECG'></span>

<h3>Description</h3>

<p>From the ECG database, a dataset is created whose structure is
years by countries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_indicator_ECG(
  indicator_code,
  fromTime,
  toTime,
  countries = convergEU_glb()$EU27$memberStates$codeMS,
  type_flag = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_indicator_ECG_+3A_indicator_code">indicator_code</code></td>
<td>
<p>one of the following strings:&quot;dataset2&quot;, &quot;demo_magec_AND_demo_pjan&quot;</p>
</td></tr>
<tr><td><code id="extract_indicator_ECG_+3A_fromtime">fromTime</code></td>
<td>
<p>first year to be considered</p>
</td></tr>
<tr><td><code id="extract_indicator_ECG_+3A_totime">toTime</code></td>
<td>
<p>last year to be considered</p>
</td></tr>
<tr><td><code id="extract_indicator_ECG_+3A_countries">countries</code></td>
<td>
<p>a collection of strings representing countries
in the standard two letters format</p>
</td></tr>
<tr><td><code id="extract_indicator_ECG_+3A_type_flag">type_flag</code></td>
<td>
<p>if FALSE data are returned, otherwise the type of indicator
is returned; if METADATA_ECG is selected, NA is returned</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the indicator_code is equal to &quot;METADATA_ECG&quot; then information on
available indicators is provided as a dataframe (tibble):
names of indicators are contained in the variable &quot;Worksheet name&quot;.
</p>


<h3>Value</h3>

<p>a dataset (tibble) years by countries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Extract metadata:
myTB1 &lt;- extract_indicator_ECG(
    indicator_code = "METADATA_ECG" #Code_in_database
    )

# Extract indicator "dataset2" from 2010 to 2021:
myTB2 &lt;- extract_indicator_ECG(
    indicator_code = "dataset2", #Code_in_database
    fromTime=2010,
    toTime=2021)



</code></pre>

<hr>
<h2 id='extract_indicator_EIGE'>Create a dataset (tibble) for an EIGE indicator.</h2><span id='topic+extract_indicator_EIGE'></span>

<h3>Description</h3>

<p>From the EIGE database, a dataset is created whose structure is
years by countries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_indicator_EIGE(
  indicator_code,
  fromTime,
  toTime,
  countries = convergEU_glb()$EU27$memberStates$codeMS,
  type_flag = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_indicator_EIGE_+3A_indicator_code">indicator_code</code></td>
<td>
<p>one of the following strings:&quot;INDEX&quot;,  &quot;WORK&quot;,
&quot;MONEY&quot;, &quot;KNOWLEDGE&quot;,  &quot;TIME&quot;, &quot;POWER&quot;,
&quot;HEALTH&quot;,  &quot;FTE&quot;, &quot;DWL&quot;, &quot;SEGRE&quot;, &quot;INCOME&quot;,
&quot;TERTIARY&quot;, &quot;CARE&quot;, &quot;HOUSE&quot;,  &quot;MINISTER&quot;,
&quot;PARLIAMENT&quot;, &quot;BOARD&quot;, &quot;HLY&quot;,&quot;METADATA&quot;</p>
</td></tr>
<tr><td><code id="extract_indicator_EIGE_+3A_fromtime">fromTime</code></td>
<td>
<p>first year to be considered</p>
</td></tr>
<tr><td><code id="extract_indicator_EIGE_+3A_totime">toTime</code></td>
<td>
<p>last year to be considered</p>
</td></tr>
<tr><td><code id="extract_indicator_EIGE_+3A_countries">countries</code></td>
<td>
<p>a collection of strings representing countries
in the standard two letters format</p>
</td></tr>
<tr><td><code id="extract_indicator_EIGE_+3A_type_flag">type_flag</code></td>
<td>
<p>if FALSE data are returned, otherwise the type of indicator
is returned; if METADATA is selected, NA is returned</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the indicator_code is equal to &quot;METADATA&quot; then information on
available indicators is provided as a dataframe (tibble):
names of indicators are contained in the variable &quot;Worksheet name&quot;.
</p>


<h3>Value</h3>

<p>a dataset (tibble) years by countries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Extract metadata:
myTB1 &lt;- extract_indicator_EIGE(
    indicator_code = "METADATA" #Code_in_database
    )

# Extract indicator "HOUSE" from 2010 to 2015:
myTB2 &lt;- extract_indicator_EIGE(
    indicator_code = "HOUSE", #Code_in_database
    fromTime=2010,
    toTime=2015)



</code></pre>

<hr>
<h2 id='extract_indicator_EUF'>Create a dataset (tibble) for an indicator.</h2><span id='topic+extract_indicator_EUF'></span>

<h3>Description</h3>

<p>From the Eurofound database, a dataset is created whose structure is
years by countries, possibly conditioned to  gender.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_indicator_EUF(
  indicator_code,
  fromTime,
  toTime,
  gender = c("Total", "Females", "Males")[1],
  countries = convergEU_glb()$EU27$memberStates$codeMS
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_indicator_EUF_+3A_indicator_code">indicator_code</code></td>
<td>
<p>the variable describing countries</p>
</td></tr>
<tr><td><code id="extract_indicator_EUF_+3A_fromtime">fromTime</code></td>
<td>
<p>first year to be considered</p>
</td></tr>
<tr><td><code id="extract_indicator_EUF_+3A_totime">toTime</code></td>
<td>
<p>last year to be considered</p>
</td></tr>
<tr><td><code id="extract_indicator_EUF_+3A_gender">gender</code></td>
<td>
<p>which gender, one of  c(&quot;Total&quot;,&quot;Females&quot;,&quot;Males&quot;)</p>
</td></tr>
<tr><td><code id="extract_indicator_EUF_+3A_countries">countries</code></td>
<td>
<p>a collection of strings representing countries
in the standard two letters format</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataset (tibble) years by countries, possibly conditioned to gender
</p>


<h3>References</h3>

<p><a href="https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf">https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Extract indicator labelled "lifesatisf" and accessible from "dbEUF2018meta" data:
print(dbEUF2018meta, n=20, width=100)
dbEUF2018meta$Code_in_database
myTB1 &lt;- extract_indicator_EUF(
    indicator_code = "lifesatisf", #Code_in_database
    fromTime=2003,
    toTime=2015,
    gender= c("Total","Females","Males")[1])

# Extract indicator "exposdiscr_p" (Code_in_database) from 2003 to 2016:
myTB2 &lt;- extract_indicator_EUF(
    indicator_code = "exposdiscr_p", #Code_in_database
    fromTime=2003,
    toTime=2016,
    gender= c("Total","Females","Males")[1])

# Extract indicator "lifesatisf" from 1998 to 2016 for females:
myTB3 &lt;- extract_indicator_EUF(
    indicator_code = "lifesatisf", #Code_in_database
    fromTime = 1998,
    toTime = 2016,
    gender = c("Total","Females","Males")[2])

# Extract indicator "lifesatisf" from 1960 to 2016 for males of EU12:
myTB4 &lt;- extract_indicator_EUF(
    indicator_code = "lifesatisf", #Code_in_database
    fromTime=1960,
    toTime=2016,
   gender= c("Total","Females","Males")[3],
   countries= convergEU_glb()$EU12$memberStates$codeMS)


</code></pre>

<hr>
<h2 id='gamma_conv'>Gamma convergence</h2><span id='topic+gamma_conv'></span>

<h3>Description</h3>

<p>Given a dataframe (tibble) of times by countries indicator,
the gamma convergence is calculated. A time index is required.
Missing values are not allowed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gamma_conv(rawDat, ref = NA, last = NA, timeName = "time", printRanks = F)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gamma_conv_+3A_rawdat">rawDat</code></td>
<td>
<p>the tibble made by  times and countries.</p>
</td></tr>
<tr><td><code id="gamma_conv_+3A_ref">ref</code></td>
<td>
<p>the reference time, typically zero.</p>
</td></tr>
<tr><td><code id="gamma_conv_+3A_last">last</code></td>
<td>
<p>the last time  to be considered.</p>
</td></tr>
<tr><td><code id="gamma_conv_+3A_timename">timeName</code></td>
<td>
<p>the name of the variable that contains time information.</p>
</td></tr>
<tr><td><code id="gamma_conv_+3A_printranks">printRanks</code></td>
<td>
<p>logical flag for printing ranks based on data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>gamma convergence  (indicated as KIt in Eurofound 2018 paper).
</p>


<h3>References</h3>

 <p><a href="https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf">https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example 1
# Dataframe in the format time by countries:
require(tibble)
myTB  &lt;- tibble::tribble(
    ~years, ~UK, ~DE, ~IT,
    1990,   998,  1250, 332,
    1988,   1201, 868, 578,
    1989,   1150, 978, 682,
    1991,  1600,  1350, 802
    )

# Gamma convergence,  scrambled time and different time name:
resGamma &lt;- gamma_conv(myTB,ref=1988, last=1991, timeName="years")

# Example 2
myTB1  &lt;- tibble::tribble(
    ~time, ~UK, ~DE, ~IT,
    1990,   998,  1250, 332,
    1988,   1201, 868, 578,
    1989,   1150, 978, 682,
    1991,  1600,  1350, 802
    )
resGamma1 &lt;- gamma_conv(myTB1, ref=1989,last=1990)

# Example 3
# Gamma convergence for the emp_20_64_MS Eurofound dataset:
data("emp_20_64_MS")

# check name of the time variable
names(emp_20_64_MS)
resGamma2&lt;-gamma_conv(emp_20_64_MS,ref=2002,last=2005)
resGamma3&lt;-gamma_conv(emp_20_64_MS,ref=2002,last=2018)
# Print also ranks based on data:
resGamma4&lt;-gamma_conv(emp_20_64_MS,ref=2002,last=2018,printRanks=TRUE)

</code></pre>

<hr>
<h2 id='gamma_conv_msteps'>Gamma convergence iterated on several years in pairs</h2><span id='topic+gamma_conv_msteps'></span>

<h3>Description</h3>

<p>Given a dataframe (tibble) of sorted times by countries indicator,
the gamma convergence is calculated between pairs of subsequent years.
A time index is required. Missing values are not allowed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gamma_conv_msteps(rawDat, startTime, endTime, timeName = "time")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gamma_conv_msteps_+3A_rawdat">rawDat</code></td>
<td>
<p>the tibble made by  times and countries.</p>
</td></tr>
<tr><td><code id="gamma_conv_msteps_+3A_starttime">startTime</code></td>
<td>
<p>the first year  to  consider, included.</p>
</td></tr>
<tr><td><code id="gamma_conv_msteps_+3A_endtime">endTime</code></td>
<td>
<p>the last year to consider, included.</p>
</td></tr>
<tr><td><code id="gamma_conv_msteps_+3A_timename">timeName</code></td>
<td>
<p>the name of the variable that contains time information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataset of gamma values  (indicated as KIt in Eurofound 2018 paper).
</p>


<h3>References</h3>

<p><a href="https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf">https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example 1
# Dataframe in the format time by countries:
require(tibble)
myTB  &lt;- tibble::tribble(
~time, ~UK, ~DE, ~IT,
 1988,   1201, 868, 578,
 1989,   1150, 978, 682,
 1990,   998,  1250, 332,
 1991,  1600,  1350, 802
 )
 resGammaST &lt;- gamma_conv_msteps(myTB,startTime = 1988,endTime=1991, timeName = "time")

# Example 2
# Gamma convergence iterated for several pairs of years for the emp_20_64_MS Eurofound dataset
data("emp_20_64_MS")
# check name of the time variable
names(emp_20_64_MS)
resGammaST2&lt;-gamma_conv_msteps(emp_20_64_MS,startTime=2002,endTime=2006, timeName = "time")
resGammaST3&lt;-gamma_conv_msteps(emp_20_64_MS,startTime=2002,endTime=2018, timeName = "time")
resGammaST4&lt;-gamma_conv_msteps(emp_20_64_MS,startTime=2007,endTime=2012, timeName = "time")

</code></pre>

<hr>
<h2 id='go_indica_fi'>Create an indicator fiche for a given aggregation of countries.</h2><span id='topic+go_indica_fi'></span>

<h3>Description</h3>

<p>An auxiliary function to compile a rmarkdown file to produce the indicator fiche in
html format within the output directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>go_indica_fi(
  time_0 = NA,
  time_t = NA,
  timeName = NA,
  workDF = NA,
  indicaT = NA,
  indiType = c("highBest", "lowBest")[1],
  seleMeasure = "all",
  seleAggre = "EU27",
  x_angle = 45,
  data_res_download = FALSE,
  auth = "A.Student",
  dataNow = Sys.time(),
  outFile = NA,
  outDir = NA,
  pdf_out = FALSE,
  workTB = NULL,
  selfContained = FALSE,
  eige_layout = FALSE,
  memStates = "quintiles"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="go_indica_fi_+3A_time_0">time_0</code></td>
<td>
<p>starting time.</p>
</td></tr>
<tr><td><code id="go_indica_fi_+3A_time_t">time_t</code></td>
<td>
<p>ending time.</p>
</td></tr>
<tr><td><code id="go_indica_fi_+3A_timename">timeName</code></td>
<td>
<p>name of the variable containing times (years).</p>
</td></tr>
<tr><td><code id="go_indica_fi_+3A_workdf">workDF</code></td>
<td>
<p>name (string) of the dataset in the global environment containing
all countries contributing to average.</p>
</td></tr>
<tr><td><code id="go_indica_fi_+3A_indicat">indicaT</code></td>
<td>
<p>name of the  considered indicator.</p>
</td></tr>
<tr><td><code id="go_indica_fi_+3A_inditype">indiType</code></td>
<td>
<p>type of indicator &quot;lowBest&quot; or &quot;highBest&quot; (default).</p>
</td></tr>
<tr><td><code id="go_indica_fi_+3A_selemeasure">seleMeasure</code></td>
<td>
<p>set of measures of convergence; this is a
subset of the following collection of strings: &quot;beta&quot;,&quot;delta&quot;,
&quot;gamma&quot;,&quot;sigma&quot;; &quot;all&quot; is a shortcut for the whole set.</p>
</td></tr>
<tr><td><code id="go_indica_fi_+3A_seleaggre">seleAggre</code></td>
<td>
<p>selection of member states, default 'EU27' ('custom'
if not pre-coded).</p>
</td></tr>
<tr><td><code id="go_indica_fi_+3A_x_angle">x_angle</code></td>
<td>
<p>axis orientation for time labels, default 45.</p>
</td></tr>
<tr><td><code id="go_indica_fi_+3A_data_res_download">data_res_download</code></td>
<td>
<p>should data and results be downloaded, default FALSE.</p>
</td></tr>
<tr><td><code id="go_indica_fi_+3A_auth">auth</code></td>
<td>
<p>author of this report, default 'A.Student'.</p>
</td></tr>
<tr><td><code id="go_indica_fi_+3A_datanow">dataNow</code></td>
<td>
<p>date of production of this country fiche, default is
current time.</p>
</td></tr>
<tr><td><code id="go_indica_fi_+3A_outfile">outFile</code></td>
<td>
<p>name of the output file (without path), without extension.</p>
</td></tr>
<tr><td><code id="go_indica_fi_+3A_outdir">outDir</code></td>
<td>
<p>output directory, eventually not existing (only one level allowed).</p>
</td></tr>
<tr><td><code id="go_indica_fi_+3A_pdf_out">pdf_out</code></td>
<td>
<p>should the output be saved as PDF file? The default is  FALSE.</p>
</td></tr>
<tr><td><code id="go_indica_fi_+3A_worktb">workTB</code></td>
<td>
<p>a tibble containing data.</p>
</td></tr>
<tr><td><code id="go_indica_fi_+3A_selfcontained">selfContained</code></td>
<td>
<p>TRUE if just one file is desired</p>
</td></tr>
<tr><td><code id="go_indica_fi_+3A_eige_layout">eige_layout</code></td>
<td>
<p>TRUE if the EIGE layout is desired</p>
</td></tr>
<tr><td><code id="go_indica_fi_+3A_memstates">memStates</code></td>
<td>
<p>Member States visualizations, default is set as quintiles.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that most of function arguments are passed as strings of characters
instead of object names. For example, if the object of a dataset
in the workspace is myTB, the parameter is set like  workDF='myTB'
instead of workDF=myTB as one may expect.
Furthermore, the dataset must be complete, that is without missing values.
Note also that Internet connection should be available when invoking the function
to properly rendering the results in the html file. The fiches have been tested with
the browsers Mozilla Firefox and Google Chrome.
</p>


<h3>References</h3>

<p><a href="https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf">https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf</a>
</p>

<hr>
<h2 id='go_ms_fi'>Create a country fiche for an indicator</h2><span id='topic+go_ms_fi'></span>

<h3>Description</h3>

<p>An auxiliary function to compile a rmarkdown file to produce a country fiche in
html format within the output directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>go_ms_fi(
  workDF = NA,
  countryRef = NA,
  otherCountries = c(NA, NA),
  time_0 = NA,
  time_t = NA,
  tName = NA,
  indiType = NA,
  aggregation = NA,
  x_angle = NA,
  dataNow = NA,
  author = NA,
  outFile = NA,
  outDir = NA,
  indiName = NA,
  workTB = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="go_ms_fi_+3A_workdf">workDF</code></td>
<td>
<p>name (string) of the dataset  with all countries
contributing to average</p>
</td></tr>
<tr><td><code id="go_ms_fi_+3A_countryref">countryRef</code></td>
<td>
<p>country of main interest</p>
</td></tr>
<tr><td><code id="go_ms_fi_+3A_othercountries">otherCountries</code></td>
<td>
<p>other countries for comparison</p>
</td></tr>
<tr><td><code id="go_ms_fi_+3A_time_0">time_0</code></td>
<td>
<p>starting time</p>
</td></tr>
<tr><td><code id="go_ms_fi_+3A_time_t">time_t</code></td>
<td>
<p>ending time</p>
</td></tr>
<tr><td><code id="go_ms_fi_+3A_tname">tName</code></td>
<td>
<p>name of the variable containing times (years)</p>
</td></tr>
<tr><td><code id="go_ms_fi_+3A_inditype">indiType</code></td>
<td>
<p>type of indicator &quot;lowBest&quot; or &quot;highBest&quot;</p>
</td></tr>
<tr><td><code id="go_ms_fi_+3A_aggregation">aggregation</code></td>
<td>
<p>label indicator the reference group of countries ('custom'
if not pre-coded)</p>
</td></tr>
<tr><td><code id="go_ms_fi_+3A_x_angle">x_angle</code></td>
<td>
<p>axis orientation for time labels</p>
</td></tr>
<tr><td><code id="go_ms_fi_+3A_datanow">dataNow</code></td>
<td>
<p>date of production of this country fiche</p>
</td></tr>
<tr><td><code id="go_ms_fi_+3A_author">author</code></td>
<td>
<p>author of this report</p>
</td></tr>
<tr><td><code id="go_ms_fi_+3A_outfile">outFile</code></td>
<td>
<p>name of the output file (without path)</p>
</td></tr>
<tr><td><code id="go_ms_fi_+3A_outdir">outDir</code></td>
<td>
<p>output directory, eventually not existing (only one level allowed)</p>
</td></tr>
<tr><td><code id="go_ms_fi_+3A_indiname">indiName</code></td>
<td>
<p>name of the considered indicator</p>
</td></tr>
<tr><td><code id="go_ms_fi_+3A_worktb">workTB</code></td>
<td>
<p>tibble containing data, optional, as alternative to a global object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that most of function arguments are passed as strings of characters
instead of object names. For example, if the object of a dataset
in the workspace is myTB, the parameter is set like  workDF='myTB'
instead of workDF=myTB as one may expect.
Furthermore, the dataset must be complete, that is without missing values.
Note also that connection to Internet should be available when invoking the
function to properly rendering the results in the html file. A tibble object
containing data can be passed with the argument workTB instead of a string.
</p>


<h3>References</h3>

<p><a href="https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf">https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf</a>
</p>

<hr>
<h2 id='gra_de2_patt'>Values to patterns</h2><span id='topic+gra_de2_patt'></span>

<h3>Description</h3>

<p>Gradients values and Delta2 are mapped to one pattern (string and number).
See Eurofound 2018 report.
In the mapping table within this function
+1 means greater than zero, 0 means equal to zero,
-1 means smaller than 0.
For column EU_vs_MS,
if  graEU &gt; graMS then  EU_vs_MS = +1;
if  graEU &lt; graMS then  EU_vs_MS = -1;
if  graEU == graMS then  EU_vs_MS = 0.
Code NA is left to indicate not relevant features.
Further codes are added here from 13 to 18 for parallelism;
codes 19 and 20 are for crossed lines joining the EU pair and the MS pair.
Code 21 stands for &quot;to be visually inspected&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gra_de2_patt(vaEU, vaMS, vaTime)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gra_de2_patt_+3A_vaeu">vaEU</code></td>
<td>
<p>EU values sorted in ascending order by time.</p>
</td></tr>
<tr><td><code id="gra_de2_patt_+3A_vams">vaMS</code></td>
<td>
<p>member state values  sorted in ascending order by time.</p>
</td></tr>
<tr><td><code id="gra_de2_patt_+3A_vatime">vaTime</code></td>
<td>
<p>sorted pair of times.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a number referring to  pattern whose label depends on the
indicator type
</p>


<h3>References</h3>

<p><a href="https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf">https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example 1
vaEU &lt;- c(5,7)
vaMS &lt;- c(6,8)
vaTime &lt;- c(1999,2000)
resG1 &lt;- gra_de2_patt(vaEU,vaMS,vaTime)

# Example 2:
vaEU &lt;- c(7,2)
vaMS &lt;- c(9,4)
vaTime &lt;- c(2009,2010)
resG2 &lt;- gra_de2_patt(vaEU,vaMS,vaTime)

# Example 3:
vaTime &lt;- c(2009,2010)
vaEU &lt;- c(100 , 120)
vaMS &lt;- c( 50, 90)
resG3 &lt;- gra_de2_patt(vaEU,vaMS,vaTime)

</code></pre>

<hr>
<h2 id='graph_departure'>Graphical representation based on sigma convergence</h2><span id='topic+graph_departure'></span>

<h3>Description</h3>

<p>A ggplot object countries by time where coloured rectangles show if in that
time unit the indicator is below one standard deviation (-1) from the mean,
above one standard deviation (-1) from the mean or within 2 standard
deviations around the mean.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_departure(
  myTB,
  timeName = "time",
  indiType = "highBest",
  displace = 0.25,
  displaceh = 0.45,
  dimeFontNum = 6,
  myfont_scale = 1.35,
  x_angle = 45,
  color_rect = c(`-1` = "red1", `0` = "gray80", `1` = "lightskyblue1"),
  axis_name_y = "Countries",
  axis_name_x = "Time",
  alpha_color = 0.9
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph_departure_+3A_mytb">myTB</code></td>
<td>
<p>the component $res$departure of an object created by
<code>departure_mean()</code></p>
</td></tr>
<tr><td><code id="graph_departure_+3A_timename">timeName</code></td>
<td>
<p>name of the time variable</p>
</td></tr>
<tr><td><code id="graph_departure_+3A_inditype">indiType</code></td>
<td>
<p>indicator type, one among &quot;highBest&quot; and &quot;lowBest&quot;</p>
</td></tr>
<tr><td><code id="graph_departure_+3A_displace">displace</code></td>
<td>
<p>rectangle half height</p>
</td></tr>
<tr><td><code id="graph_departure_+3A_displaceh">displaceh</code></td>
<td>
<p>rectangle half base</p>
</td></tr>
<tr><td><code id="graph_departure_+3A_dimefontnum">dimeFontNum</code></td>
<td>
<p>size of font</p>
</td></tr>
<tr><td><code id="graph_departure_+3A_myfont_scale">myfont_scale</code></td>
<td>
<p>axes magnification</p>
</td></tr>
<tr><td><code id="graph_departure_+3A_x_angle">x_angle</code></td>
<td>
<p>angle of x axis labels</p>
</td></tr>
<tr><td><code id="graph_departure_+3A_color_rect">color_rect</code></td>
<td>
<p>colors within rectangles; the default for a &quot;highBest&quot; indicator type is red for
&quot;-1&quot;, grey for &quot;0&quot; and light sky blue for &quot;1&quot;; the default for a &quot;lowBest&quot; indicator type is light
sky blue for &quot;-1&quot;, grey for &quot;0&quot; and red for &quot;1&quot;</p>
</td></tr>
<tr><td><code id="graph_departure_+3A_axis_name_y">axis_name_y</code></td>
<td>
<p>name of y axis</p>
</td></tr>
<tr><td><code id="graph_departure_+3A_axis_name_x">axis_name_x</code></td>
<td>
<p>name of x axis</p>
</td></tr>
<tr><td><code id="graph_departure_+3A_alpha_color">alpha_color</code></td>
<td>
<p>transparency</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that  calculation of departure must be already performed by invoking
<code><a href="#topic+departure_mean">departure_mean</a></code>.
</p>


<h3>Value</h3>

<p>a list with component $res made by a ggplot object to be displayed
or saved using ggsave function.
</p>


<h3>References</h3>

<p><a href="https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf">https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Example 1: "lowBest" indicator type:
# Dataframe in the format time by countries:
require(tibble)
testTB &lt;- dplyr::tribble(
   ~time, ~countryA ,  ~countryB,  ~countryC,
   2000,     0.8,   2.7,    3.9,
   2001,     1.2,   3.2,    4.2,
   2002,     0.9,   2.9,    4.1,
   2003,     1.3,   2.9,    4.0,
   2004,     1.2,   3.1,    4.1,
   2005,     1.2,   3.0,    4.0
   )
mySTB &lt;- sigma_conv(testTB)
resDM &lt;-  departure_mean(oriTB=testTB, sigmaTB=mySTB$res)
myG &lt;- NULL
myG &lt;- graph_departure(resDM$res$departures,
                       timeName = "time",
                       indiType = "lowBest",
                       displace = 0.25,
                       displaceh = 0.45,
                       dimeFontNum = 6,
                       myfont_scale = 1.35,
                       x_angle = 45,
                       axis_name_y = "Countries",
                       axis_name_x = "Time",
                       alpha_color = 0.9)
# Change the colour of rectangles:
myGG &lt;- graph_departure(resDM$res$departures,
                       timeName = "time",
                       indiType = "lowBest",
                       displace = 0.25,
                       displaceh = 0.45,
                       dimeFontNum = 6,
                       myfont_scale = 1.35,
                       x_angle = 45,
                       color_rect = c("-1"='green4', "0"='yellow',"1"='red'),
                       axis_name_y = "Countries",
                       axis_name_x = "Time",
                       alpha_color = 0.9)

# Example 2: "highBest" type of indicator:
# Graphical plot of sigma convergence for the emp_20_64_MS Eurofound dataset:
data(emp_20_64_MS)
mySC &lt;- sigma_conv(emp_20_64_MS)
resDMeur &lt;- departure_mean(oriTB = emp_20_64_MS, sigmaTB = mySC$res)
myG1 &lt;- NULL
myG1 &lt;- graph_departure(resDMeur$res$departures,
                        timeName = "time",
                        indiType = "highBest",
                        displace = 0.25,
                        displaceh = 0.45,
                        dimeFontNum = 6,
                        myfont_scale = 1.35,
                        x_angle = 45,
                        axis_name_y = "Countries",
                        axis_name_x = "Time",
                        alpha_color = 0.9)

# Plot mean departures for selected countries only and change the colour of rectangles:
myG2 &lt;- NULL
myG2 &lt;- graph_departure(resDMeur$res$departures[,1:8],
                        timeName = "time",
                        indiType = "highBest",
                        displace = 0.25,
                        displaceh = 0.45,
                        dimeFontNum = 6,
                        myfont_scale = 1.35,
                        x_angle = 45,
                        color_rect = c("-1"='red', "0"='yellow',"1"='green4'),
                        axis_name_y = "Countries",
                        axis_name_x = "Time",
                        alpha_color = 0.9)

</code></pre>

<hr>
<h2 id='impu_det_lin'>Imputation of  missing values</h2><span id='topic+impu_det_lin'></span>

<h3>Description</h3>

<p>Imputation is deterministic and based on a straight line between two
points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impu_det_lin(timeIni, timeEnd, timeDelta, indicIni, indicFin)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="impu_det_lin_+3A_timeini">timeIni</code></td>
<td>
<p>starting time</p>
</td></tr>
<tr><td><code id="impu_det_lin_+3A_timeend">timeEnd</code></td>
<td>
<p>ending time</p>
</td></tr>
<tr><td><code id="impu_det_lin_+3A_timedelta">timeDelta</code></td>
<td>
<p>collection of times where missing values are located</p>
</td></tr>
<tr><td><code id="impu_det_lin_+3A_indicini">indicIni</code></td>
<td>
<p>observed value at timeIni</p>
</td></tr>
<tr><td><code id="impu_det_lin_+3A_indicfin">indicFin</code></td>
<td>
<p>observed value at timeEnd</p>
</td></tr>
</table>


<h3>Value</h3>

<p>imputed tibble with   an indicator of missingness (wasMissing).
</p>


<h3>References</h3>

<p><a href="https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf">https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example 1
# Simplest Imputation of one missing value between two observed values:
res1 &lt;- impu_det_lin(timeIni= 88,
    timeEnd = 90,
    timeDelta = 89,
    indicIni = 120,
    indicFin = 100)

# Example 2
# Multiple Imputation of  missing values:
    res2 &lt;-impu_det_lin(timeIni= 90,
    timeEnd = 93,
    timeDelta=c(91,92),
    indicIni = 100,
    indicFin = 108)

# Multiple Imputation of  missing values with delta &gt; 1:
res3 &lt;- impu_det_lin(timeIni= 2000,
    timeEnd = 2015,
    timeDelta=seq(2005,2010,5),
    indicIni = 100,
    indicFin = 108)



</code></pre>

<hr>
<h2 id='impute_dataset'>Imputation to make a dataset complete</h2><span id='topic+impute_dataset'></span>

<h3>Description</h3>

<p>For initial and final missing values there are two options: they could be completely
cancelled or, otherwise
propagated. For all other missing values within the dataset,
deterministic linear imputation is applied in order to obtain
complete data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impute_dataset(
  myTB,
  countries,
  timeName = "time",
  tailMiss = c("cut", "constant")[2],
  headMiss = c("cut", "constant")[1]
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="impute_dataset_+3A_mytb">myTB</code></td>
<td>
<p>a dataset (tibble) time by countries for a given indicator,
sorted by time. Note that times corresponding to missing data
must be contained in the dataset.</p>
</td></tr>
<tr><td><code id="impute_dataset_+3A_countries">countries</code></td>
<td>
<p>the collection of labels representing countries to process.</p>
</td></tr>
<tr><td><code id="impute_dataset_+3A_timename">timeName</code></td>
<td>
<p>the string that represent the name of the time variable.</p>
</td></tr>
<tr><td><code id="impute_dataset_+3A_tailmiss">tailMiss</code></td>
<td>
<p>what should be done with subsequent missing values
starting at  the oldest year: cut those years, or input constant
values equal to the first observed year.</p>
</td></tr>
<tr><td><code id="impute_dataset_+3A_headmiss">headMiss</code></td>
<td>
<p>what should be done with subsequent missing values
ending at  the last year: cut those years, or input constant
values equal to the first observed year.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with three components: &quot;res&quot;: the dataset (tibble) without
missing values; &quot;msg&quot; and &quot;err&quot;
</p>


<h3>References</h3>

<p><a href="https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf">https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Example 1
# Dataset in the format time by countries with missing values:
myTB2  &lt;- tibble::tribble(
    ~time, ~UK, ~DE, ~IT,
    1988,   998,  1250, 332,
    1989,   NA, 868, NA,
    1990,   1150, 978, NA,
    1991,  1600,  NA, 802
    )
toBeProcessed &lt;- c( "UK","DE","IT")
# Simplest Imputation using option "cut":
resImpu &lt;- impute_dataset(myTB2, countries=toBeProcessed,
                         timeName = "time",
                         tailMiss = c("cut", "constant")[1],
                         headMiss = c("cut", "constant")[1])


# Imputation using option "constant":
resImpu1 &lt;- impute_dataset(myTB2, countries=toBeProcessed,
    timeName = "time",
    tailMiss = c("cut", "constant")[2],
    headMiss = c("cut", "constant")[2])

# Imputation using both options "cut" and "constant":
resImput &lt;- impute_dataset(myTB2, countries=toBeProcessed,
    timeName = "time",
    tailMiss = c("cut", "constant")[2],
    headMiss = c("cut", "constant")[1])

# Example 2
# dataset time by countries for the indicator "JQIintensity_i":
myTB &lt;- extract_indicator_EUF(
    indicator_code = "JQIintensity_i", #Code_in_database
    fromTime= 1965,
    toTime=2016,
    gender= c("Total","Females","Males")[1],
    countries= convergEU_glb()$EU27$memberStates$codeMS)

# Imputation of missing values, option "cut":
myTBinp &lt;- impute_dataset(myTB$res, timeName = "time",
    countries=convergEU_glb()$EU27$memberStates$codeMS,
    tailMiss = c("cut", "constant")[1],
    headMiss = c("cut", "constant")[1])

# Imputation of missing values, option "constant":
myTBinp1 &lt;- impute_dataset(myTB$res, timeName = "time",
    countries=convergEU_glb()$EU27$memberStates$codeMS,
    tailMiss = c("cut", "constant")[2],
    headMiss = c("cut", "constant")[2])

</code></pre>

<hr>
<h2 id='ma_dataset'>Smoother based on moving average</h2><span id='topic+ma_dataset'></span>

<h3>Description</h3>

<p>The smoother change each value into the average of values around it spanning
a window of size kappa.
Missing values are not allowed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ma_dataset(myTB, kappa = 2, timeName = "time")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ma_dataset_+3A_mytb">myTB</code></td>
<td>
<p>a complete dataset (tibble) time by countries, with just
time column and    country columns.</p>
</td></tr>
<tr><td><code id="ma_dataset_+3A_kappa">kappa</code></td>
<td>
<p>integer greater than 1 as smoothed value, to set the time window of
the moving average.</p>
</td></tr>
<tr><td><code id="ma_dataset_+3A_timename">timeName</code></td>
<td>
<p>name of the time variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataset  of smoothed values.
</p>


<h3>References</h3>

<p><a href="https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf">https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example 1
# Smoother based on moving average with k=1.5:
require(tibble)

# Dataset in the format time by countries
myTB  &lt;- tibble::tibble(
    time = 2010:2001,
    IT = c(10,14,13,12,9,11,13,17,15,25),
    DE = c(10,11,12,9,14,17,23,29,26,23)
   )
resMA1 &lt;- ma_dataset(myTB, kappa=1.5)

# Smoother based on moving average with k=3:
resMA2&lt;-ma_dataset(myTB, kappa=3)

# Example 2
# Smoother based on moving average for the emp_20_64_MS Eurofound dataset:

myTB1 &lt;-  emp_20_64_MS[,c("time","IT","DE", "FR")]
# Smoother based on moving average with k=2:
resMAeu&lt;-ma_dataset(myTB1, kappa=2, timeName= "time")

# Smoother based on moving average with k=3:
resMAeu1&lt;-ma_dataset(myTB1, kappa=3, timeName= "time")

</code></pre>

<hr>
<h2 id='map_2_patt_39'>Values to patterns</h2><span id='topic+map_2_patt_39'></span>

<h3>Description</h3>

<p>Gradients values and Delta2 are mapped to one pattern (string and number).
See Eurofound 2018 report.
</p>
<p>In the mapping table within this function
+1 means greater than zero, 0 means equal to zero,
-1 means smaller than 0.
For column EU_vs_MS,
if  graEU &gt; graMS then  EU_vs_MS = +1;
if  graEU &lt; graMS then  EU_vs_MS = -1;
if  graEU == graMS then  EU_vs_MS = 0.
Code NA is left to indicate not relevant features.
Further codes are added here from 13 to 18 for parallelism;
codes 19 and 20 are for crossed lines joining the EU pair and the MS pair.
Code 21 stands for &quot;to be visually inspected&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map_2_patt_39(vaMS, vaEU, vaT, remap = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="map_2_patt_39_+3A_vams">vaMS</code></td>
<td>
<p>member state values  sorted in ascending order by time.</p>
</td></tr>
<tr><td><code id="map_2_patt_39_+3A_vaeu">vaEU</code></td>
<td>
<p>EU values sorted in ascending order by time.</p>
</td></tr>
<tr><td><code id="map_2_patt_39_+3A_vat">vaT</code></td>
<td>
<p>sorted pair of times.</p>
</td></tr>
<tr><td><code id="map_2_patt_39_+3A_remap">remap</code></td>
<td>
<p>is FALSE for the original numerical labelling of patterns
otherwise TRUE to map to old numerical correspondence.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a number referring to  pattern whose label depends on the
indicator type as originally produced in the technical report.
</p>

<hr>
<h2 id='map_2_patt_59'>Values to patterns</h2><span id='topic+map_2_patt_59'></span>

<h3>Description</h3>

<p>Gradients values and Delta2 are mapped to one pattern (string and number).
See Eurofound 2018 report.
</p>
<p>In the mapping table within this function
a pattern number 1-59 is assigned for each combination of EU 
average vs MS average and their differences called delta_endpoints.
Code NA is left to indicate not relevant features.
In version 0.6.4The patterns have been updated from the original 12 to 59 
to cover all possibile combinations.
Code 60 stands for &quot;to be visually inspected&quot;. See vignette for further info.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map_2_patt_59(vaMS, vaEU, vaT, remap = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="map_2_patt_59_+3A_vams">vaMS</code></td>
<td>
<p>member state values  sorted in ascending order by time.</p>
</td></tr>
<tr><td><code id="map_2_patt_59_+3A_vaeu">vaEU</code></td>
<td>
<p>EU values sorted in ascending order by time.</p>
</td></tr>
<tr><td><code id="map_2_patt_59_+3A_vat">vaT</code></td>
<td>
<p>sorted pair of times.</p>
</td></tr>
<tr><td><code id="map_2_patt_59_+3A_remap">remap</code></td>
<td>
<p>is FALSE for the original numerical labelling of patterns
otherwise TRUE to map to old numerical correspondence.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a number referring to  pattern whose label depends on the
indicator type as originally produced in the technical report.
</p>

<hr>
<h2 id='ms_dynam'>Member state dynamics</h2><span id='topic+ms_dynam'></span>

<h3>Description</h3>

<p>A ggplot object time by countries where coloured rectangles show the departure
from the mean after partitioning into intervals (-Inf, m-1 s, m-0.5 s, m+0.5 s, m+1 s, Inf).
Note that the following convention is adopted where the colour of labels changes depending on the type of indicator,
i.e. &quot;lowBest&quot; or &quot;highBest&quot;:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ms_dynam(
  myTB,
  timeName = "time",
  displace = 0.25,
  displaceh = 0.45,
  dimeFontNum = 5,
  myfont_scale = 1.35,
  x_angle = 45,
  axis_name_y = "Countries",
  axis_name_x = "Time",
  alpha_color = 0.9,
  indiType = "highBest"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ms_dynam_+3A_mytb">myTB</code></td>
<td>
<p>dataset time by countries.</p>
</td></tr>
<tr><td><code id="ms_dynam_+3A_timename">timeName</code></td>
<td>
<p>a string, name of the time variable.</p>
</td></tr>
<tr><td><code id="ms_dynam_+3A_displace">displace</code></td>
<td>
<p>rectangle half height.</p>
</td></tr>
<tr><td><code id="ms_dynam_+3A_displaceh">displaceh</code></td>
<td>
<p>rectangle half base.</p>
</td></tr>
<tr><td><code id="ms_dynam_+3A_dimefontnum">dimeFontNum</code></td>
<td>
<p>size of font.</p>
</td></tr>
<tr><td><code id="ms_dynam_+3A_myfont_scale">myfont_scale</code></td>
<td>
<p>axes magnification.</p>
</td></tr>
<tr><td><code id="ms_dynam_+3A_x_angle">x_angle</code></td>
<td>
<p>angle of x axis labels.</p>
</td></tr>
<tr><td><code id="ms_dynam_+3A_axis_name_y">axis_name_y</code></td>
<td>
<p>name of y axis.</p>
</td></tr>
<tr><td><code id="ms_dynam_+3A_axis_name_x">axis_name_x</code></td>
<td>
<p>name of x axis.</p>
</td></tr>
<tr><td><code id="ms_dynam_+3A_alpha_color">alpha_color</code></td>
<td>
<p>transparency.</p>
</td></tr>
<tr><td><code id="ms_dynam_+3A_inditype">indiType</code></td>
<td>
<p>is a string: &quot;highBest&quot; or &quot;lowBest&quot; to define the type
of indicator.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>* (-Inf, m -1 s] is labelled as -1; it is coloured in dark green for &quot;lowBest&quot; type of indicator
and in red for &quot;highBest&quot; type of indicator;
* (m -1 s, m -0.5 s] is labelled as -0.5; it is coloured in pale green for &quot;lowBest&quot; type of indicator
and in yellow (ocra) for &quot;highBest&quot; type of indicator;
* (m -0.5 s,m +0.5 s ] is labelled as 0; it is coloured in pale yellow for both &quot;lowBest&quot; and &quot;highBest
types of indicators;
* (m +0.5 s, m +1 s] is labelled as 0.5; it is coloured in  yellow (ocra) for &quot;lowBest&quot; type of indicator
and in pale green for &quot;highBest&quot; type of indicator;
* (m +1 s, Inf] is labelled as 1; it is coloured in red for &quot;lowBest&quot; type of indicator
and in dark green for &quot;highBest&quot; type of indicator.
</p>


<h3>Value</h3>

<p>a ggplot object to be displayed or saved using ggsave.
</p>


<h3>References</h3>

<p><a href="https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf">https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


# Example 1: "lowBest" type of indicator:
# Dataset in the format time by countries:
require(tibble)
testTB &lt;- dplyr::tribble(
    ~time, ~countryA ,  ~countryB,  ~countryC,
    2000,     0.8,   2.7,    3.9,
    2001,     1.2,   3.2,    4.2,
    2002,     0.9,   2.9,    4.1,
    2003,     1.3,   2.9,    4.0,
    2004,     1.2,   3.1,    4.1,
    2005,     1.2,   3.0,    4.0
    )

# Calculate scoreboards for countries:
res&lt;-scoreb_yrs(testTB, timeName = "time")

# Extract the component "sco_level_num" from "res"
resTB&lt;-res$res$sco_level_num

# Plot the departures from the mean for each country:
ms_dynam ( resTB,
    timeName = "time",
    displace = 0.25,
    displaceh = 0.45,
    dimeFontNum = 5,
    myfont_scale = 1.35,
    x_angle = 45,
    axis_name_y = "Countries",
    axis_name_x = "Time",
    alpha_color = 0.9,
    indiType = "lowBest")

# Plot the departures from the mean for some years only:
# Extract results from sco_level_num" for some years only:
estrattore &lt;- resTB[["time"]] &gt;= 2001 &amp; resTB[["time"]] &lt;= 2004
scobelvl &lt;- dplyr::filter(resTB, estrattore)

# Plot the countries dynamics
ms_dynam ( scobelvl,
    timeName = "time",
    displace = 0.25,
    displaceh = 0.45,
    dimeFontNum = 5,
    myfont_scale = 1.35,
    x_angle = 45,
    axis_name_y = "Countries",
    axis_name_x = "Time",
    alpha_color = 0.9,
    indiType = "lowBest"
    )

# Example 2: "highBest" type of indicator:
# Scoreboards of Member States for the emp_20_64_MS Eurofound dataset:
data(emp_20_64_MS)

# Extract the component "sco_level_num
sco_lvl &lt;- scoreb_yrs(emp_20_64_MS,timeName = "time")$res$sco_level_num

# Extract the results from 2009 to 2016
estrattore1 &lt;- sco_lvl[["time"]] &gt;= 2009 &amp; sco_lvl[["time"]] &lt;= 2016
scobelvl1 &lt;- dplyr::filter(sco_lvl, estrattore1)
# Plot the departures from the mean for the EU Member States:
ms_dynam( scobelvl1,
    timeName = "time",
    displace = 0.25,
    displaceh = 0.45,
    dimeFontNum = 3,
    myfont_scale = 1.35,
    x_angle = 45,
    axis_name_y = "Countries",
    axis_name_x = "Time",
    alpha_color = 0.9,
    indiType = "highBest")

# Extract the results for Member States from 2007 to 2012:
estrattore2 &lt;- sco_lvl[["time"]] &gt;= 2007 &amp; sco_lvl[["time"]] &lt;= 2012
scobelvl2 &lt;- dplyr::filter(sco_lvl, estrattore2)

# Plot the departures from the mean:
ms_dynam( scobelvl2,
    timeName = "time",
    displace = 0.25,
    displaceh = 0.45,
    dimeFontNum = 3,
    myfont_scale = 1.35,
    x_angle = 45,
    axis_name_y = "Countries",
    axis_name_x = "Time",
    alpha_color = 0.9,
    indiType = "highBest")



</code></pre>

<hr>
<h2 id='ms_pattern_39'>Find patterns for all countries</h2><span id='topic+ms_pattern_39'></span>

<h3>Description</h3>

<p>The input is a time by countries dataset where all countries contributing
to the average must be present. The expanded set of qualitative equivalence
classes is made by 39 patterns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ms_pattern_39(myTB, timeName = "time")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ms_pattern_39_+3A_mytb">myTB</code></td>
<td>
<p>a dataset (tibble) for an indicator, time by countries.
The first and last time are respectively the first
and last rows of the dataset,
which must be  time sorted.</p>
</td></tr>
<tr><td><code id="ms_pattern_39_+3A_timename">timeName</code></td>
<td>
<p>a string with name of the time variable</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an expanded  implementation recently submitted for publications.
</p>


<h3>Value</h3>

<p>the type of pattern
</p>

<hr>
<h2 id='ms_pattern_59'>Find patterns for all countries</h2><span id='topic+ms_pattern_59'></span>

<h3>Description</h3>

<p>The input is a time by countries dataset where all countries contributing
to the average must be present. The expanded set of qualitative equivalence
classes is made by 39 patterns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ms_pattern_59(myTB, timeName = "time")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ms_pattern_59_+3A_mytb">myTB</code></td>
<td>
<p>a dataset (tibble) for an indicator, time by countries.
The first and last time are respectively the first
and last rows of the dataset,
which must be  time sorted.</p>
</td></tr>
<tr><td><code id="ms_pattern_59_+3A_timename">timeName</code></td>
<td>
<p>a string with name of the time variable</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an expanded  implementation recently submitted for publications.
</p>


<h3>Value</h3>

<p>the type of pattern
</p>

<hr>
<h2 id='ms_pattern_ori'>Find patterns for all countries</h2><span id='topic+ms_pattern_ori'></span>

<h3>Description</h3>

<p>The input is a time by countries dataset where all countries contributing
to the average must be present.
Indicators of type 'low is better' are transformed
(highestRef - Y), thus the distance from the maximum value
for each original observation is calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ms_pattern_ori(myTB, timeName = "time", typeIn = c("highBest", "lowBest")[1])
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ms_pattern_ori_+3A_mytb">myTB</code></td>
<td>
<p>a dataset (tibble) for an indicator, time by countries.
The first and last time are respectively the first
and last rows of the dataset,
which must be  time sorted.</p>
</td></tr>
<tr><td><code id="ms_pattern_ori_+3A_timename">timeName</code></td>
<td>
<p>a string with name of the time variable</p>
</td></tr>
<tr><td><code id="ms_pattern_ori_+3A_typein">typeIn</code></td>
<td>
<p>the type of indicator considered 'highBest' (default)
or 'lowBest'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the reference implementation as described  by the Eurofound  report
&quot;Monitoring convergence in the European Union
Upward convergence in the EU: Concepts, measurements and indicators&quot;, 2018.
</p>


<h3>Value</h3>

<p>the type of pattern
</p>


<h3>References</h3>

<p><a href="https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf">https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf</a>
</p>

<hr>
<h2 id='not_in'>Auxiliary function for membership</h2><span id='topic+not_in'></span>

<h3>Description</h3>

<p>A fast check if one or more values are outside a set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>not_in(values, set_collection)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="not_in_+3A_values">values</code></td>
<td>
<p>one or more values</p>
</td></tr>
<tr><td><code id="not_in_+3A_set_collection">set_collection</code></td>
<td>
<p>a collection of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if not within or FALSE otherwise
</p>


<h3>References</h3>

<p><a href="https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf">https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
val&lt;-c(1,2,3,5)
mycol&lt;-c(7,8)
not_in(val,mycol)

val1&lt;-c(1,2,3,5)
mycol1&lt;-c(3,5)
not_in(val1,mycol1)

val2&lt;-c("FR", "IT", "LU")
mycol2&lt;-c("FR", "ES")
not_in(val2,mycol2)

</code></pre>

<hr>
<h2 id='patt_legend'>Graphical legend about time patterns</h2><span id='topic+patt_legend'></span>

<h3>Description</h3>

<p>A 5 by 4 plot showing patterns of change along time is made
and returned a ggplot object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>patt_legend(indiType = "highBest")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="patt_legend_+3A_inditype">indiType</code></td>
<td>
<p>a string equal to &quot;highBest&quot; or &quot;lowBest&quot;
to select a type of indicator.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot object to be plotted using grid.arrange()
function.
</p>


<h3>References</h3>

<p><a href="https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf">https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(gridExtra)
refGGpat2 &lt;- patt_legend(indiType="lowBest")

refGGpat3 &lt;- patt_legend(indiType="highBest")



</code></pre>

<hr>
<h2 id='patt_legend_39'>Graphical legend about time patterns</h2><span id='topic+patt_legend_39'></span>

<h3>Description</h3>

<p>A plot showing patterns of change along time is made
and returned as a list of ggplot objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>patt_legend_39()
</code></pre>


<h3>Value</h3>

<p>a list of 2 ggplot objects 20 plus 19 patterns.
</p>


<h3>References</h3>

<p><a href="https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf">https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(ggplot2)
refGGpat &lt;- patt_legend_39()

 

</code></pre>

<hr>
<h2 id='points2par'>From points to parameters of a straight line</h2><span id='topic+points2par'></span>

<h3>Description</h3>

<p>Given two points on a plane, parameters of a straight line are calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>points2par(point1, point2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="points2par_+3A_point1">point1</code></td>
<td>
<p>collection abscissa ,ordinate.</p>
</td></tr>
<tr><td><code id="points2par_+3A_point2">point2</code></td>
<td>
<p>collection abscissa ,ordinate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>collection made by (intercept, slope)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example 1
require(tibble)
myTB &lt;- tribble(
    ~time , ~indic,
    1    ,   25,
    10   ,   5,
    1,       10,
    10,       3
    )
resparamIT1 &lt;- points2par(as.numeric(myTB[1,]),as.numeric(myTB[2,]))

# Example 2
myTB1 &lt;- tribble(
    ~time , ~indic,
    2    ,   25,
    16   ,   5,
    1,       9,
    10,       3,
    34,       4
    )
resparamIT2 &lt;- points2par(as.numeric(myTB1[1,]),as.numeric(myTB1[2,]))

# Example 3
myTB2 &lt;- tribble(
    ~time , ~indic,
    5    ,   2,
    1   ,   15,
    11,       19,
    20,       33,
    25,       14
    )
resparamIT3 &lt;- points2par(as.numeric(myTB2[1,]),as.numeric(myTB2[2,]))

</code></pre>

<hr>
<h2 id='pop_var'>Population variance and standard deviation</h2><span id='topic+pop_var'></span>

<h3>Description</h3>

<p>The denominator in n instead of n-1, like in the R base function.
Note that missing values are deleted by default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pop_var(veval)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pop_var_+3A_veval">veval</code></td>
<td>
<p>vector of data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the second argument, if assigned,  causes only one summary
of object returned.
</p>


<h3>Value</h3>

<p>the variance and standard deviation
</p>


<h3>References</h3>

<p><a href="https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf">https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

myvec&lt;-c(5,2,3,NA,4)
pop_var(myvec)

vec1&lt;-c(10, 20, 15,60,32)
pop_var(vec1)

vec2&lt;-c(NA,NA, 13, 19, 20)
pop_var(vec2)

vec4&lt;-c(seq(from = 5, to = 100, by = 5))
pop_var(vec4)

</code></pre>

<hr>
<h2 id='scoreb_yrs'>Scoreboard of countries</h2><span id='topic+scoreb_yrs'></span>

<h3>Description</h3>

<p>A scoreboard of countries shows the departure of an indicator level
from the average, for each year in the dataset.
It also considers one-year changes and the inherent average (and departure)
for  each year.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scoreb_yrs(myTB, timeName = "time")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scoreb_yrs_+3A_mytb">myTB</code></td>
<td>
<p>original complete dataset (tibble) time by country,
ordered by time; only time and countries variables must be present,
no average or auxiliary variables at all.
Only years of interest must be present and only countries
contributing to the average of each year.</p>
</td></tr>
<tr><td><code id="scoreb_yrs_+3A_timename">timeName</code></td>
<td>
<p>string with the name of the time variable in myTB</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of tibbles containing   departures and integer labels. Integer
values in the result refers to the partition
(-Inf, m-1 s, m-0.5 s, m+0.5 s, m+1 s, Inf) where m is the average
and s the standard deviation at a given time t; in particular
the ordinal is 1 if the interval (-Inf, m -1 s) contains the indicator,
it is 2 if the interval ( m-1 s, m-0.5 s) contains the indicator, and so on
up to the value 5 that means an indicator value above m + 1 s.
</p>


<h3>References</h3>

<p><a href="https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf">https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example 1
# Dataset in the format years by countries:
require(tibble)
testTB &lt;- dplyr::tribble(
    ~time, ~countryA ,  ~countryB,  ~countryC,
    2000,     0.8,   2.7,    3.9,
    2001,     1.2,   3.2,    4.2,
    2002,     0.9,   2.9,    4.1,
    2003,     1.3,   2.9,    4.0,
    2004,     1.2,   3.1,    4.1,
    2005,     1.2,   3.0,    4.0
    )
resTB1&lt;-scoreb_yrs(testTB, timeName = "time")

# Example 2
# Scoreboard of countries for the emp_20_64_MS Eurofound dataset:
data("emp_20_64_MS")
resTB2 &lt;- scoreb_yrs(emp_20_64_MS,timeName = "time")

</code></pre>

<hr>
<h2 id='sigma_conv'>Sigma-convergence statistic</h2><span id='topic+sigma_conv'></span>

<h3>Description</h3>

<p>Given a dataframe of quantitative indicators along time,
the sigma convergence is a statistic capturing some convergence features.
A time variable must be present whether sorted or not.
Missing values are not allowed.
Here it is calculated at each observed time.
All countries belonging to the reference mean must be included into the
dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sigma_conv(tavDes, timeName = "time", time_0 = NA, time_t = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sigma_conv_+3A_tavdes">tavDes</code></td>
<td>
<p>the dataframe time by countries.</p>
</td></tr>
<tr><td><code id="sigma_conv_+3A_timename">timeName</code></td>
<td>
<p>the name of the variable that contains time information.</p>
</td></tr>
<tr><td><code id="sigma_conv_+3A_time_0">time_0</code></td>
<td>
<p>starting time to consider; if NA all times considered.</p>
</td></tr>
<tr><td><code id="sigma_conv_+3A_time_t">time_t</code></td>
<td>
<p>last time to consider; if NA all times considered.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a tibble with the value of sigma convergence (called stdDev or CV)
along time, where the original *timeName* is preserved.
</p>


<h3>References</h3>

<p><a href="https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf">https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example 1
# Dataframe in the format time by countries:
require(tibble)
myTB  &lt;- tibble::tribble(
    ~years, ~UK, ~DE, ~IT,
    1990,   998,  1250, 332,
    1988,   1201, 868, 578,
    1989,   1150, 978, 682
    )
reSigConv &lt;- sigma_conv(myTB,timeName="years")

# Results for the sigma convergence:
reSigConv$res

# Example 2
# Sigma convergence, scrambled time, different name, subset of times:
myTB1  &lt;- tibble::tribble(
    ~years, ~UK, ~DE, ~IT,
    1990,   998,  1250, 332,
    1988,   1201, 868, 578,
    1989,   1150, 978, 682,
    1991,   232, 225, 227,
    1987,   122, 212, 154
    )
reSigConv1 &lt;- sigma_conv(myTB1,timeName="years", time_0 = 1988,time_t = 1990)

# Example 3
# Sigma convergence for the emp_20_64_MS Eurofound dataset:
data("emp_20_64_MS")
reSigConv2 &lt;- sigma_conv(emp_20_64_MS)
reSigConv3 &lt;- sigma_conv(emp_20_64_MS, timeName = "time", time_0 = 2002,time_t = 2004)
reSigConv4 &lt;- sigma_conv(emp_20_64_MS, timeName = "time", time_0 = 2002,time_t = 2016)

</code></pre>

<hr>
<h2 id='sigma_conv_graph'>Graphical representation based on sigma convergence</h2><span id='topic+sigma_conv_graph'></span>

<h3>Description</h3>

<p>A ggplot of the standard deviation and the coefficient of variation based on the results obtained for sigma-convergence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sigma_conv_graph(
  sigmaconvOut,
  time_0 = NA,
  time_t = NA,
  aggregation = NA,
  x_angle = 45
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sigma_conv_graph_+3A_sigmaconvout">sigmaconvOut</code></td>
<td>
<p>the output obtained from sigma_conv function.</p>
</td></tr>
<tr><td><code id="sigma_conv_graph_+3A_time_0">time_0</code></td>
<td>
<p>starting time.</p>
</td></tr>
<tr><td><code id="sigma_conv_graph_+3A_time_t">time_t</code></td>
<td>
<p>ending time.</p>
</td></tr>
<tr><td><code id="sigma_conv_graph_+3A_aggregation">aggregation</code></td>
<td>
<p>the name of the set of member states for which the sigma-convergence is calculated.</p>
</td></tr>
<tr><td><code id="sigma_conv_graph_+3A_x_angle">x_angle</code></td>
<td>
<p>axis orientation for time labels, default 45.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot object to be displayed of saved using ggsave.
</p>


<h3>References</h3>

<p><a href="https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf">https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example 1
# Sigma convergence for the emp_20_64_MS Eurofound dataset in the period 2002-2006:
data(emp_20_64_MS)
reSigConv &lt;- sigma_conv(emp_20_64_MS, timeName = "time", time_0 = 2002,time_t = 2006)

# Graphical plot based on the results for sigma-convergence
reSiggraph&lt;-sigma_conv_graph(reSigConv,2002,2006,aggregation = 'EU27')

# Example 2
# Sigma-convergence for the emp_20_64_MS Eurofound dataset in the period 2008-2016:
reSigConv1 &lt;- sigma_conv(emp_20_64_MS, timeName = "time", time_0 = 2008,time_t = 2016)

# Graphical plot based on the results for sigma-convergence
reSiggraph1&lt;-sigma_conv_graph(reSigConv1,2008,2016,aggregation = 'EU27')

# Select different time windows, e.g. 2012-2016 and change x_angle:
reSiggraph2&lt;-sigma_conv_graph(reSigConv1,2012,2016,aggregation = 'EU27', x_angle=90)

</code></pre>

<hr>
<h2 id='smoo_dataset'>Smoother based on weighting</h2><span id='topic+smoo_dataset'></span>

<h3>Description</h3>

<p>The smoother substitutes an original raw value
Y(m,i,t)
of country m
indicator i at time t with the weighted average
y(m,i,t) = y(m,i,t-1) (1-w)/2 + w y(m,i,t) + y(m,i,t+1) (1-w)/2
where 0 &lt; w &lt; 1.
The special case w=1 corresponds to no smoothing.
In case of missing values an NA is returned. If the weight is outside
the interval (0,1] then a NA is returned.
The first and last values are smoothed using weights $w$ and $1-w$.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smoo_dataset(myTB, leadW = 1, timeTB = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smoo_dataset_+3A_mytb">myTB</code></td>
<td>
<p>a complete dataset time by countries, with just country columns.</p>
</td></tr>
<tr><td><code id="smoo_dataset_+3A_leadw">leadW</code></td>
<td>
<p>leading positive weight less or equal to 1.</p>
</td></tr>
<tr><td><code id="smoo_dataset_+3A_timetb">timeTB</code></td>
<td>
<p>a dataset with the time variable, if a dataset is desired as output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of dataset  of smoothed values
</p>


<h3>References</h3>

<p><a href="https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf">https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example 1
# Dataset in the format time by countries:
myTB  &lt;- tibble::tibble(
    time = 2001:2010,
    IT = c(10,14,13,12,9,11,13,17,15,25),
    DE = c(10,11,12,9,14,17,23,29,26,23)
    )

# Remove the time variable in order to obtain just country columns and compute smoothed values:
reSMO &lt;- smoo_dataset(myTB[,-1], leadW=1)
reSMO1 &lt;- smoo_dataset(myTB[,-1], leadW=0.5)

# Add the time variable for tibble in output:
reSMO2 &lt;- smoo_dataset(myTB[,-1], leadW=.5,timeTB= dplyr::select(myTB,time))

# Example 2
# Smoother based on weighting for the emp_20_64_MS Eurofound dataset:
data(emp_20_64_MS)
# Select countries:
myTB &lt;- dplyr::select(emp_20_64_MS, time, IT,DE,FR)
# Compute smoothed values by also adding the time variable to the output:
resSM &lt;- smoo_dataset(dplyr::select(myTB,-time), leadW = 0.2, timeTB= dplyr::select(myTB,time))

</code></pre>

<hr>
<h2 id='ts_parlin'>Time-indicator serie to straight lines parameters</h2><span id='topic+ts_parlin'></span>

<h3>Description</h3>

<p>Given a dataset with first column times and second column the indicator values
parameters of time-spliced straight lines are calculated. No checking is
performed in input.
Time values must differ by a positive  constant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts_parlin(dataMat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ts_parlin_+3A_datamat">dataMat</code></td>
<td>
<p>two columns (times, indicator) dataset</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataset(tibble) where each row is  (times, intercept, slope)
</p>


<h3>References</h3>

<p><a href="https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf">https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(tibble)
testTB &lt;- dplyr::tribble(
    ~time, ~countryA ,  ~countryB,  ~countryC,
    2000,     0.8,   2.7,    3.9,
    2001,     1.2,   3.2,    4.2,
    2002,     0.9,   2.9,    4.1,
    2003,     1.3,   2.9,    4.0,
    2004,     1.2,   3.1,    4.1,
    2005,     1.2,   3.0,    4.0
    )

curcountry &lt;- 2
resPAR &lt;- ts_parlin(testTB[,c(1,curcountry)])

curcountry &lt;- 4
resPAR1 &lt;- ts_parlin(testTB[,c(1,curcountry)])

</code></pre>

<hr>
<h2 id='upDo_CoDi'>Upward-downward convergence declaration</h2><span id='topic+upDo_CoDi'></span>

<h3>Description</h3>

<p>Convergence and divergence may be strict or weak, upward or
downward. The interpretation depends on the type of indicator,
that is &quot;highBest&quot; or &quot;lowBest&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>upDo_CoDi(
  myTB,
  timeName = "time",
  indiType = "highBest",
  time_0 = NA,
  time_t = NA,
  heter_fun = "pop_var"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="upDo_CoDi_+3A_mytb">myTB</code></td>
<td>
<p>time by member states dataset. No other variables can
be in the dataset.</p>
</td></tr>
<tr><td><code id="upDo_CoDi_+3A_timename">timeName</code></td>
<td>
<p>name of the variable that contains time.</p>
</td></tr>
<tr><td><code id="upDo_CoDi_+3A_inditype">indiType</code></td>
<td>
<p>a string, &quot;lowBest&quot; or &quot;highBest&quot;.</p>
</td></tr>
<tr><td><code id="upDo_CoDi_+3A_time_0">time_0</code></td>
<td>
<p>reference time.</p>
</td></tr>
<tr><td><code id="upDo_CoDi_+3A_time_t">time_t</code></td>
<td>
<p>target time strictly larger than time_0.</p>
</td></tr>
<tr><td><code id="upDo_CoDi_+3A_heter_fun">heter_fun</code></td>
<td>
<p>function to summarize dispersion, like var(),
sd(); user-developed function
are allowed; pop_var is the variance with denominator n.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that if the argument heter_fun is set to sd or var,
then those statistics use a denominator which is n-1, i.e.
the number of observations decreased by 1.
This is not typically what one wants here, thus
the function pop_var may be used instead, because it adopts n as denominator.
It is also possible to map a summary of dispersion with a
monotonic function, like sqrt (see examples).
</p>
<p>All the Member states contributing to the mean must be columns
of the dataset given as input.
</p>


<h3>Value</h3>

<p>list of declarations.
</p>


<h3>References</h3>

<p><a href="https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf">https://www.eurofound.europa.eu/system/files/2022-04/introduction-to-the-convergeu-package-0.6.4-tutorial-v2-apr2022.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# using the standard deviation
upDo_CoDi(emp_20_64_MS,
         timeName = "time",
         indiType = "highBest",
         time_0 = 2010,
         time_t = 2015,
         heter_fun = "var" # watchout the denominator here is n-1
         )


# using the standard pop_var function
upDo_CoDi(emp_20_64_MS,
         timeName = "time",
         indiType = "highBest",
         time_0 = 2010,
         time_t = 2015,
         heter_fun = "pop_var" # the denominator here is n
         )



# using personalized summary of dispersion
diffQQmu &lt;-  function(vettore){
   (quantile(vettore,0.75)-quantile(vettore,0.25))/mean(vettore)
   }

upDo_CoDi(emp_20_64_MS,
         timeName = "time",
         indiType = "highBest",
         time_0 = 2010,
         time_t = 2015,
         heter_fun = "diffQQmu"
         )

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
