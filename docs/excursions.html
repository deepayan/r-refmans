<!DOCTYPE html><html><head><title>Help for package excursions</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {excursions}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#excursions-package'><p>Excursions: Excursion Sets and Contour Credibility Regions for Random Fields</p></a></li>
<li><a href='#continuous'><p>Calculate continuous domain excursion and credible contour sets</p></a></li>
<li><a href='#contourmap'><p>Contour maps and contour map quality measures for latent Gaussian models</p></a></li>
<li><a href='#contourmap.colors'><p>Define a color map for displaying contour maps.</p></a></li>
<li><a href='#contourmap.inla'><p>Contour maps and contour map quality measures for latent Gaussian models</p></a></li>
<li><a href='#contourmap.mc'><p>Contour maps and contour map quality measures using Monte Carlo samples</p></a></li>
<li><a href='#exc_safe_inla'><p>Load INLA safely for examples and tests</p></a></li>
<li><a href='#excursions'><p>Excursion Sets and Contour Credibility Regions for Random Fields</p></a></li>
<li><a href='#excursions.inla'><p>Excursion sets and contour credible regions for latent Gaussian models</p></a></li>
<li><a href='#excursions.mc'><p>Excursion sets and contour credible regions using Monte Carlo samples</p></a></li>
<li><a href='#excursions.variances'><p>Calculate variances from a sparse precision matrix</p></a></li>
<li><a href='#gaussint'><p>Sequential estimation of Gaussian integrals</p></a></li>
<li><a href='#local_exc_testthat'><p>Unit test helpers</p></a></li>
<li><a href='#require.nowarnings'><p>Warnings free loading of add-on packages</p></a></li>
<li><a href='#simconf'><p>Simultaneous confidence regions for Gaussian models</p></a></li>
<li><a href='#simconf.inla'><p>Simultaneous confidence regions for latent Gaussian models</p></a></li>
<li><a href='#simconf.mc'><p>Simultaneous confidence regions using Monte Carlo samples</p></a></li>
<li><a href='#simconf.mixture'><p>Simultaneous confidence regions for Gaussian mixture models</p></a></li>
<li><a href='#submesh.grid'><p>Extract a part of a grid</p></a></li>
<li><a href='#submesh.mesh'><p>Extract a part of a mesh</p></a></li>
<li><a href='#summary.excurobj'><p>Summarise excurobj objects</p></a></li>
<li><a href='#tricontour'><p>Calculate contour curves on a triangulation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Excursion Sets and Contour Credibility Regions for Random Fields</td>
</tr>
<tr>
<td>Version:</td>
<td>2.5.8</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions that compute probabilistic excursion sets, contour credibility regions, contour avoiding regions, and simultaneous confidence bands for latent Gaussian random processes and fields. The package also contains functions that calculate these quantities for models estimated with the INLA package. The main references for excursions are Bolin and Lindgren (2015) &lt;<a href="https://doi.org/10.1111%2Frssb.12055">doi:10.1111/rssb.12055</a>&gt;, Bolin and Lindgren (2017) &lt;<a href="https://doi.org/10.1080%2F10618600.2016.1228537">doi:10.1080/10618600.2016.1228537</a>&gt;, and Bolin and Lindgren (2018) &lt;<a href="https://doi.org/10.18637%2Fjss.v086.i05">doi:10.18637/jss.v086.i05</a>&gt;. These can be generated by the citation function in R.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5), Matrix, sp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>INLA (&ge; 21.08.31), testthat (&ge; 3.0.0), sf</td>
</tr>
<tr>
<td>Imports:</td>
<td>fmesher (&ge; 0.1.2), graphics, methods, stats, withr</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>Gnu Scientific Library version &gt;= 2.1</td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://inla.r-inla-download.org/R/testing">https://inla.r-inla-download.org/R/testing</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/davidbolin/excursions/issues">https://github.com/davidbolin/excursions/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/davidbolin/excursions">https://github.com/davidbolin/excursions</a></td>
</tr>
<tr>
<td>Copyright:</td>
<td>The R package and code, and the main programs, were written
by and are Copyright by David Bolin and Finn Lindgren, and are
redistributable under the GNU Public License, version 3 or
later.  The package also includes code from the libraries CAMD
from the SuiteSparse collection of Tim Davis, and the
RngStreams library by Pierre L'Ecuyer.  For details see the
COPYRIGHTS file.</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>true</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-29 18:06:47 UTC; bolinjd</td>
</tr>
<tr>
<td>Author:</td>
<td>David Bolin <a href="https://orcid.org/0000-0003-2361-5465"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [cre,
    aut],
  Finn Lindgren <a href="https://orcid.org/0000-0002-5833-2011"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Suen Man Ho [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David Bolin &lt;davidbolin@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-30 08:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='excursions-package'>Excursions: Excursion Sets and Contour Credibility Regions for Random Fields</h2><span id='topic+excursions-package'></span><span id='topic+_PACKAGE'></span>

<h3>Description</h3>

<p><code>excursions</code> contains functions that compute probabilistic excursion sets,
contour credibility regions, contour avoiding regions, contour map quality measures,
and simultaneous confidence bands for latent Gaussian
random processes and fields. A detailed manual can be found in the paper 
Bolin, D and Lindgren, F  (2018) 
<em>Calculating Probabilistic Excursion Sets and Related Quantities Using excursions</em>,
Journal of Statistical Software, 86(5), 1&ndash;20.
</p>


<h3>Details</h3>

<p>The main functions in the package fall into three different categories described below.
</p>
<p><strong>Excursion sets, contour credibility regions, and contour avoiding regions</strong>
</p>
<p>The main functions for computing excursion sets, contour credibility regions, and
contour avoiding regions are
</p>

<dl>
<dt><code><a href="#topic+excursions">excursions</a></code> </dt><dd><p>The main function for Gaussian models.</p>
</dd>
<dt><code><a href="#topic+excursions.inla">excursions.inla</a></code> </dt><dd><p>Interface for latent Gaussian models estimated using INLA.</p>
</dd>
<dt><code><a href="#topic+excursions.mc">excursions.mc</a></code> </dt><dd><p>Function for analyzing models that have been
estimated using Monte Carlo methods.</p>
</dd>
</dl>

<p>The output from the functions above provides a discrete domain estimate of the regions.
Based on this estimate, the function <code><a href="#topic+continuous">continuous</a></code> computes a continuous
domain estimate.
</p>
<p>The main reference for these functions is Bolin, D. and Lindgren, F. (2015)
<em>Excursion and contour uncertainty regions for latent Gaussian models</em>,
JRSS-series B, vol 77, no 1, pp 85-106.
</p>
<p><strong>Contour map quality measures</strong>
</p>
<p>The package provides several functions for computing contour maps and their quality
measures. These quality measures can be used to decide on an appropriate number of
contours to use for the contour map.
</p>
<p>The main functions for computing contour maps and the corresponding quality measures
are
</p>

<dl>
<dt><code><a href="#topic+contourmap">contourmap</a></code> </dt><dd><p>The main function for Gaussian models.</p>
</dd>
<dt><code><a href="#topic+contourmap.inla">contourmap.inla</a></code> </dt><dd><p>Interface for latent Gaussian models estimated
using INLA.</p>
</dd>
<dt><code><a href="#topic+contourmap.mc">contourmap.mc</a></code> </dt><dd><p>Function for analyzing models that have been
estimated using Monte Carlo methods.</p>
</dd>
</dl>

<p>Other noteworthy functions relating to contourmaps are <code><a href="#topic+tricontour">tricontour</a></code> and
<code><a href="#topic+tricontourmap">tricontourmap</a></code>, which compute contour curves for functinos defined on
triangulations, as well as <code><a href="#topic+contourmap.colors">contourmap.colors</a></code> which can be used to
compute appropriate colors for displaying contour maps.
</p>
<p>The main reference for these functions is Bolin, D. and Lindgren, F. (2017)
<em>Quantifying the uncertainty of contour maps</em>, Journal of Computational and
Graphical Statistics, 26:3, 513-524.
</p>
<p><strong>Simultaneous confidence bands</strong>
</p>
<p>The main functions for computing simultaneous confidence bands are
</p>

<dl>
<dt><code><a href="#topic+simconf">simconf</a></code> </dt><dd><p>Function for analyzing Gaussian models.</p>
</dd>
<dt><code><a href="#topic+simconf.inla">simconf.inla</a></code> </dt><dd><p>Function for analyzing latent Gaussian models
estimated using INLA.</p>
</dd>
<dt><code><a href="#topic+simconf.mc">simconf.mc</a></code> </dt><dd><p>Function for analyzing models estimated using Monte
Carlo methods.</p>
</dd>
<dt><code><a href="#topic+simconf.mixture">simconf.mixture</a></code> </dt><dd><p>Function for analyzing Gaussian mixture models.</p>
</dd>
</dl>

<p>The main reference for these functions is Bolin et al. (2015)
<em>Statistical prediction of global sea level
from global temperature</em>, Statistica Sinica, Vol 25, pp 351-367.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: David Bolin <a href="mailto:davidbolin@gmail.com">davidbolin@gmail.com</a> (<a href="https://orcid.org/0000-0003-2361-5465">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a> (<a href="https://orcid.org/0000-0002-5833-2011">ORCID</a>)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Suen Man Ho <a href="mailto:M.H.Suen@sms.ed.ac.uk">M.H.Suen@sms.ed.ac.uk</a> [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/davidbolin/excursions">https://github.com/davidbolin/excursions</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/davidbolin/excursions/issues">https://github.com/davidbolin/excursions/issues</a>
</p>
</li></ul>


<hr>
<h2 id='continuous'>Calculate continuous domain excursion and credible contour sets</h2><span id='topic+continuous'></span>

<h3>Description</h3>

<p>Calculates continuous domain excursion and credible contour sets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>continuous(
  ex,
  geometry,
  alpha,
  method = c("log", "linear", "step"),
  output = c("sp", "fm", "inla"),
  subdivisions = 1,
  calc.credible = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="continuous_+3A_ex">ex</code></td>
<td>
<p>An <code>excurobj</code> object generated by a call to <code><a href="#topic+excursions">excursions</a></code>
or <code><a href="#topic+contourmap">contourmap</a></code>.</p>
</td></tr>
<tr><td><code id="continuous_+3A_geometry">geometry</code></td>
<td>
<p>Specification of the lattice or triangulation geometry of the input.
One of <code>list(x, y)</code>, <code>list(loc, dims)</code>, <code>fm_lattice_2d</code>,
<code>inla.mesh.lattice</code>, <code>fm_mesh_2d</code>, or
<code>inla.mesh</code>, where <code>x</code> and <code>y</code> are vectors, <code>loc</code> is
a two-column matrix of coordinates, and <code>dims</code> is the lattice size vector.
The first three versions are all treated topologically as lattices, and the
lattice boxes are assumed convex.</p>
</td></tr>
<tr><td><code id="continuous_+3A_alpha">alpha</code></td>
<td>
<p>The target error probability.  A warning is given if it is detected
that the information <code>ex</code> isn't sufficient for the given <code>alpha</code>.
Defaults to the value used when calculating <code>ex</code>.</p>
</td></tr>
<tr><td><code id="continuous_+3A_method">method</code></td>
<td>
<p>The spatial probability interpolation transformation method to use.
One of <code>log</code>, <code>linear</code>, or <code>step</code>.  For <code>log</code>, the probabilities
are interpolated linearly in the transformed scale. For <code>step</code>, a conservative
step function is used.</p>
</td></tr>
<tr><td><code id="continuous_+3A_output">output</code></td>
<td>
<p>Specifies what type of object should be generated. <code>sp</code> gives a
<code>SpatialPolygons</code> object, and <code>fm</code> or <code>inla</code> gives a <code>fm_segm</code> object.</p>
</td></tr>
<tr><td><code id="continuous_+3A_subdivisions">subdivisions</code></td>
<td>
<p>The number of mesh triangle subdivisions to perform for the
interpolation of the excursions or contour function. 0 is no subdivision.
The setting has a small effect on the evaluation of <code>P0</code> for the <code>log</code>
method (higher values giving higher accuracy) but the main effect is on the visual
appearance of the interpolation. Default=1.</p>
</td></tr>
<tr><td><code id="continuous_+3A_calc.credible">calc.credible</code></td>
<td>
<p>Logical, if TRUE (default), calculate credible contour region
objects in addition to avoidance sets.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements
</p>
<table>
<tr><td><code>M</code></td>
<td>
<p><code>SpatialPolygons</code> or <code>inla.mesh.segment</code> object. The subsets
are tagged, so that credible regions are tagged <code>"-1"</code>, and regions between
levels are tagged <code>as.character(0:nlevels)</code>.</p>
</td></tr>
<tr><td><code>F</code></td>
<td>
<p>Interpolated F function.</p>
</td></tr>
<tr><td><code>G</code></td>
<td>
<p>Contour and inter-level set indices for the interpolation.</p>
</td></tr>
<tr><td><code>F.geometry</code></td>
<td>
<p>Mesh geometry for the interpolation.</p>
</td></tr>
<tr><td><code>P0</code></td>
<td>
<p>P0 measure based on interpolated F function (only for <code>contourmap</code>
input).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>References</h3>

<p>Bolin, D. and Lindgren, F. (2017) <em>Quantifying the uncertainty of contour maps</em>, Journal of Computational and Graphical Statistics, vol 26, no 3, pp 513-524.
</p>
<p>Bolin, D. and Lindgren, F. (2018), <em>Calculating Probabilistic Excursion Sets and Related Quantities Using excursions</em>, Journal of Statistical Software, vol 86, no 1, pp 1-20.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (require("fmesher")) {
  # Generate mesh and SPDE model
  n.lattice &lt;- 10 # Increase for more interesting, but slower, examples
  x &lt;- seq(from = 0, to = 10, length.out = n.lattice)
  lattice &lt;- fm_lattice_2d(x = x, y = x)
  mesh &lt;- fm_rcdt_2d_inla(lattice = lattice, extend = FALSE, refine = FALSE)

  # Generate an artificial sample
  sigma2.e &lt;- 0.1
  n.obs &lt;- 100
  obs.loc &lt;- cbind(
    runif(n.obs) * diff(range(x)) + min(x),
    runif(n.obs) * diff(range(x)) + min(x)
  )
  Q &lt;- fm_matern_precision(mesh, alpha = 2, rho = 3, sigma = 1)
  x &lt;- fm_sample(n = 1, Q = Q)
  A &lt;- fm_basis(mesh, loc = obs.loc)
  Y &lt;- as.vector(A %*% x + rnorm(n.obs) * sqrt(sigma2.e))

  ## Calculate posterior
  Q.post &lt;- (Q + (t(A) %*% A) / sigma2.e)
  mu.post &lt;- as.vector(solve(Q.post, (t(A) %*% Y) / sigma2.e))
  vars.post &lt;- excursions.variances(chol(Q.post))

  ## Calculate contour map with two levels
  map &lt;- contourmap(
    n.levels = 2, mu = mu.post, Q = Q.post,
    alpha = 0.1, F.limit = 0.1, max.threads = 1
  )

  ## Calculate the continuous representation
  sets &lt;- continuous(map, mesh, alpha = 0.1)

  ## Plot the results
  reo &lt;- mesh$idx$lattice
  cols &lt;- contourmap.colors(map,
    col = heat.colors(100, 1, rev = TRUE),
    credible.col = grey(0.5, 1)
  )
  names(cols) &lt;- as.character(-1:2)

  par(mfrow = c(2, 2))
  image(matrix(mu.post[reo], n.lattice, n.lattice),
    main = "mean", axes = FALSE, asp = 1
  )
  image(matrix(sqrt(vars.post[reo]), n.lattice, n.lattice),
    main = "sd", axes = FALSE, asp = 1
  )
  image(matrix(map$M[reo], n.lattice, n.lattice),
    col = cols, axes = FALSE, asp = 1
  )
  idx.M &lt;- setdiff(names(sets$M), "-1")
  plot(sets$M[idx.M], col = cols[idx.M])
}

## End(Not run)

</code></pre>

<hr>
<h2 id='contourmap'>Contour maps and contour map quality measures for latent Gaussian models</h2><span id='topic+contourmap'></span>

<h3>Description</h3>

<p><code>contourmap</code> is used for calculating contour maps and quality measures for contour maps for Gaussian models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contourmap(
  mu,
  Q,
  vars,
  n.levels,
  ind,
  levels,
  type = c("standard", "pretty", "equalarea", "P0-optimal", "P1-optimal", "P2-optimal"),
  compute = list(F = TRUE, measures = NULL),
  use.marginals = TRUE,
  alpha,
  F.limit,
  n.iter = 10000,
  verbose = FALSE,
  max.threads = 0,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contourmap_+3A_mu">mu</code></td>
<td>
<p>Expectation vector.</p>
</td></tr>
<tr><td><code id="contourmap_+3A_q">Q</code></td>
<td>
<p>Precision matrix.</p>
</td></tr>
<tr><td><code id="contourmap_+3A_vars">vars</code></td>
<td>
<p>Precomputed marginal variances (optional).</p>
</td></tr>
<tr><td><code id="contourmap_+3A_n.levels">n.levels</code></td>
<td>
<p>Number of levels in contour map.</p>
</td></tr>
<tr><td><code id="contourmap_+3A_ind">ind</code></td>
<td>
<p>Indices of the nodes that should be analyzed (optional).</p>
</td></tr>
<tr><td><code id="contourmap_+3A_levels">levels</code></td>
<td>
<p>Levels to use in contour map.</p>
</td></tr>
<tr><td><code id="contourmap_+3A_type">type</code></td>
<td>
<p>Type of contour map. One of:
</p>

<dl>
<dt>'standard' </dt><dd><p>Equidistant levels between smallest and largest value of the posterior mean (default).</p>
</dd>
<dt>'pretty' </dt><dd><p>Equally spaced 'round' values which cover the range of the values in the posterior mean.</p>
</dd>
<dt>'equalarea' </dt><dd><p>Levels such that different spatial regions are approximately equal in size.</p>
</dd>
<dt>'P0-optimal' </dt><dd><p>Levels chosen to maximize the P0 measure.</p>
</dd>
<dt>'P1-optimal' </dt><dd><p>Levels chosen to maximize the P1 measure.</p>
</dd>
<dt>'P2-optimal' </dt><dd><p>Levels chosen to maximize the P2 measure.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="contourmap_+3A_compute">compute</code></td>
<td>
<p>A list with quality indices to compute
</p>

<dl>
<dt>'F': </dt><dd><p>TRUE/FALSE indicating whether the contour map function should be computed (default TRUE).</p>
</dd>
<dt>'measures': </dt><dd><p>A list with the quality measures to compute (&quot;P0&quot;, &quot;P1&quot;, &quot;P2&quot;) or corresponding bounds based only on the marginal probabilities (&quot;P0-bound&quot;, &quot;P1-bound&quot;, &quot;P2-bound&quot;).</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="contourmap_+3A_use.marginals">use.marginals</code></td>
<td>
<p>Only marginal distributions are used when finding P-optimal maps (default TRUE).</p>
</td></tr>
<tr><td><code id="contourmap_+3A_alpha">alpha</code></td>
<td>
<p>Maximal error probability in contour map function (default=1).</p>
</td></tr>
<tr><td><code id="contourmap_+3A_f.limit">F.limit</code></td>
<td>
<p>The limit value for the computation of the F function. F is set to NA for all nodes where F&lt;1-F.limit. Default is F.limit = <code>alpha</code>.</p>
</td></tr>
<tr><td><code id="contourmap_+3A_n.iter">n.iter</code></td>
<td>
<p>Number or iterations in the MC sampler that is used for calculating the quantities in <code>compute</code>. The default value is 10000.</p>
</td></tr>
<tr><td><code id="contourmap_+3A_verbose">verbose</code></td>
<td>
<p>Set to TRUE for verbose mode (optional).</p>
</td></tr>
<tr><td><code id="contourmap_+3A_max.threads">max.threads</code></td>
<td>
<p>Decides the number of threads the program can use. Set to 0 for using the maximum number of threads allowed by the system (default).</p>
</td></tr>
<tr><td><code id="contourmap_+3A_seed">seed</code></td>
<td>
<p>Random seed (optional).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Gaussian model is specified using the mean <code>mu</code> and the precision matrix
<code>Q</code>. The contour map is then computed for the mean, using either the contour
levels specified in <code>levels</code>, or <code>n.levels</code> contours that are placed according
to the argument <code>type</code>.
</p>
<p>A number of quality measures can be computed based based on the specified contour map
and the Gaussian distribution. What should be computed is specified using the
<code>compute</code> argument. For details on these quanties, see the reference below.
</p>


<h3>Value</h3>

<p><code>contourmap</code> returns an object of class &quot;excurobj&quot; with the following elements
</p>
<table>
<tr><td><code>u</code></td>
<td>
<p>Contour levels used in the contour map.</p>
</td></tr>
<tr><td><code>n.levels</code></td>
<td>
<p>The number of contours used.</p>
</td></tr>
<tr><td><code>u.e</code></td>
<td>
<p>The values associated with the level sets G_k.</p>
</td></tr>
<tr><td><code>G</code></td>
<td>
<p>A vector which shows which of the level sets G_k each node belongs to.</p>
</td></tr>
<tr><td><code>map</code></td>
<td>
<p>Representation of the contour map with map[i]=u.e[k] if i is in G_k.</p>
</td></tr>
<tr><td><code>F</code></td>
<td>
<p>The contour map function (if computed).</p>
</td></tr>
<tr><td><code>M</code></td>
<td>
<p>Contour avoiding sets (if <code>F</code> is computed). <code class="reqn">M=-1</code> for all non-significant nodes and  <code class="reqn">M=k</code> for nodes that belong to <code class="reqn">M_k</code>.</p>
</td></tr>
<tr><td><code>P0/P1/P2</code></td>
<td>
<p>Calculated quality measures (if computed).</p>
</td></tr>
<tr><td><code>P0bound/P1bound/P2bound</code></td>
<td>
<p>Calculated upper bounds quality measures (if computed).</p>
</td></tr>
<tr><td><code>meta</code></td>
<td>
<p>A list containing various information about the calculation.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Bolin <a href="mailto:davidbolin@gmail.com">davidbolin@gmail.com</a>
</p>


<h3>References</h3>

<p>Bolin, D. and Lindgren, F. (2017) <em>Quantifying the uncertainty of contour maps</em>, Journal of Computational and Graphical Statistics, vol 26, no 3, pp 513-524.
</p>
<p>Bolin, D. and Lindgren, F. (2018), <em>Calculating Probabilistic Excursion Sets and Related Quantities Using excursions</em>, Journal of Statistical Software, vol 86, no 1, pp 1-20.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+contourmap.inla">contourmap.inla</a></code>, <code><a href="#topic+contourmap.mc">contourmap.mc</a></code>, <code><a href="#topic+contourmap.colors">contourmap.colors</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 10
Q &lt;- Matrix(toeplitz(c(1, -0.5, rep(0, n - 2))))
mu &lt;- seq(-5, 5, length = n)
lp &lt;- contourmap(mu, Q,
  n.levels = 2,
  compute = list(F = FALSE, measures = c("P1", "P2")),
  max.threads = 1
)
# Plot the contourmap
plot(lp$map)
# Display the quality measures
cat(c(lp$P1, lp$P2))
</code></pre>

<hr>
<h2 id='contourmap.colors'>Define a color map for displaying contour maps.</h2><span id='topic+contourmap.colors'></span>

<h3>Description</h3>

<p><code>contourmap.colors</code> calculates suitable colours for displaying contour maps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contourmap.colors(lp, zlim, col, credible.col)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contourmap.colors_+3A_lp">lp</code></td>
<td>
<p>A contourmap calculated by <code>contourmap</code>, <code>contourmap.inla</code>, or <code>contourmap.mc</code></p>
</td></tr>
<tr><td><code id="contourmap.colors_+3A_zlim">zlim</code></td>
<td>
<p>The range that should be used (optional). The default is the range of the mean value function used when creating the contourmap.</p>
</td></tr>
<tr><td><code id="contourmap.colors_+3A_col">col</code></td>
<td>
<p>The colormap that the colours should be taken from.</p>
</td></tr>
<tr><td><code id="contourmap.colors_+3A_credible.col">credible.col</code></td>
<td>
<p>The color that should be used for displaying the credible regions for the contour curves (optional).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A color map.
</p>


<h3>Author(s)</h3>

<p>David Bolin <a href="mailto:davidbolin@gmail.com">davidbolin@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 10
Q &lt;- Matrix(toeplitz(c(1, -0.5, rep(0, n - 2))))
map &lt;- contourmap(
  mu = seq(-5, 5, length = n), Q, n.levels = 2,
  compute = list(F = FALSE), max.threads = 1
)
cols &lt;- contourmap.colors(map,
  col = heat.colors(100, 1),
  credible.col = grey(0.5, 1)
)
</code></pre>

<hr>
<h2 id='contourmap.inla'>Contour maps and contour map quality measures for latent Gaussian models</h2><span id='topic+contourmap.inla'></span>

<h3>Description</h3>

<p>An interface to the <code>contourmap</code> function for latent Gaussian models
calculated using the INLA method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contourmap.inla(
  result.inla,
  stack,
  name = NULL,
  tag = NULL,
  method = "QC",
  n.levels,
  type = c("standard", "pretty", "equalarea"),
  compute = list(F = TRUE, measures = NULL),
  alpha,
  F.limit,
  n.iter = 10000,
  verbose = FALSE,
  max.threads = 0,
  compressed = TRUE,
  seed = NULL,
  ind,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contourmap.inla_+3A_result.inla">result.inla</code></td>
<td>
<p>Result object from INLA call.</p>
</td></tr>
<tr><td><code id="contourmap.inla_+3A_stack">stack</code></td>
<td>
<p>The stack object used in the INLA call.</p>
</td></tr>
<tr><td><code id="contourmap.inla_+3A_name">name</code></td>
<td>
<p>The name of the component for which to do the calculation. This
argument should only be used if a stack object is not provided, use the tag
argument otherwise.</p>
</td></tr>
<tr><td><code id="contourmap.inla_+3A_tag">tag</code></td>
<td>
<p>The tag of the component in the stack for which to do the
calculation. This argument should only be used if a stack object is provided,
use the name argument otherwise.</p>
</td></tr>
<tr><td><code id="contourmap.inla_+3A_method">method</code></td>
<td>
<p>Method for handeling the latent Gaussian structure. Currently
only Empirical Bayes (EB) and Quantile corrections (QC) are supported.</p>
</td></tr>
<tr><td><code id="contourmap.inla_+3A_n.levels">n.levels</code></td>
<td>
<p>Number of levels in contour map.</p>
</td></tr>
<tr><td><code id="contourmap.inla_+3A_type">type</code></td>
<td>
<p>Type of contour map. One of:
</p>

<dl>
<dt>'standard' </dt><dd><p>Equidistant levels between smallest and largest value
of the posterior mean (default).</p>
</dd>
<dt>'pretty' </dt><dd><p>Equally spaced 'round' values which cover the range of
the values in the posterior mean.</p>
</dd>
<dt>'equalarea' </dt><dd><p>Levels such that different spatial regions are
approximately equal in size.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="contourmap.inla_+3A_compute">compute</code></td>
<td>
<p>A list with quality indices to compute
</p>

<dl>
<dt>'F': </dt><dd><p>TRUE/FALSE indicating whether the contour map function
should be computed (default TRUE)</p>
</dd>
<dt>'measures': </dt><dd><p>A list with the quality measures to compute (&quot;P0&quot;,
&quot;P1&quot;, &quot;P2&quot;) or corresponding bounds based only on the marginal
probabilities (&quot;P0-bound&quot;, &quot;P1-bound&quot;, &quot;P2-bound&quot;)</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="contourmap.inla_+3A_alpha">alpha</code></td>
<td>
<p>Maximal error probability in contour map function (default=1)</p>
</td></tr>
<tr><td><code id="contourmap.inla_+3A_f.limit">F.limit</code></td>
<td>
<p>The limit value for the computation of the F function. F is
set to NA for all nodes where F&lt;1-F.limit. Default is F.limit = <code>alpha</code>.</p>
</td></tr>
<tr><td><code id="contourmap.inla_+3A_n.iter">n.iter</code></td>
<td>
<p>Number or iterations in the MC sampler that is used for
calculating the quantities in <code>compute</code>. The default value is 10000.</p>
</td></tr>
<tr><td><code id="contourmap.inla_+3A_verbose">verbose</code></td>
<td>
<p>Set to TRUE for verbose mode (optional)</p>
</td></tr>
<tr><td><code id="contourmap.inla_+3A_max.threads">max.threads</code></td>
<td>
<p>Decides the number of threads the program can use. Set to
0 for using the maximum number of threads allowed by the system (default).</p>
</td></tr>
<tr><td><code id="contourmap.inla_+3A_compressed">compressed</code></td>
<td>
<p>If INLA is run in compressed mode and a part of the linear
predictor is to be used, then only add the relevant part. Otherwise the
entire linear predictor is added internally (default TRUE).</p>
</td></tr>
<tr><td><code id="contourmap.inla_+3A_seed">seed</code></td>
<td>
<p>Random seed (optional).</p>
</td></tr>
<tr><td><code id="contourmap.inla_+3A_ind">ind</code></td>
<td>
<p>If only a part of a component should be used in the calculations,
this argument specifies the indices for that part (optional).</p>
</td></tr>
<tr><td><code id="contourmap.inla_+3A_...">...</code></td>
<td>
<p>Additional arguments to the contour map function. See the
documentation for <code>contourmap</code> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The INLA approximation of the quantity of interest is in general a weighted
sum of Gaussian distributions with different parameters. If
<code>method = 'EB'</code> is used, then the contour map is computed for the mean
of the component in the weighted sum that has parameters with the highest
likelihood. If on the other hand <code>method='QC'</code>, then the contour map is
computed for the posterior mean reported by INLA. If the EB method also is
used in INLA, then this reported posterior mean is equal to the mean of the
component with the highest likelihood. Therefore, <code>method='EB'</code> is
appropriate if the EB method also is used in INLA, but <code>method='QC'</code>
should be used in general.
</p>
<p>The <code>n.levels</code> contours in the contour map are are placed according
to the argument <code>type</code>. A number of quality measures can be computed
based based on the specified contour map and the distribution of the
component of interest. What should be computed is specified using the
<code>compute</code> argument. For details on these quanties, see the reference
below.
</p>


<h3>Value</h3>

<p><code>contourmap.inla</code> returns an object of class &quot;excurobj&quot; with the
same elements as returned by <code>contourmap</code>.
</p>


<h3>Note</h3>

<p>This function requires the <code>INLA</code> package, which is not a CRAN
package.  See <a href="https://www.r-inla.org/download-install">https://www.r-inla.org/download-install</a> for easy
installation instructions.
</p>


<h3>Author(s)</h3>

<p>David Bolin <a href="mailto:davidbolin@gmail.com">davidbolin@gmail.com</a>
</p>


<h3>References</h3>

<p>Bolin, D. and Lindgren, F. (2017) <em>Quantifying the
uncertainty of contour maps</em>, Journal of Computational and Graphical
Statistics, 26:3, 513-524.
</p>
<p>Bolin, D. and Lindgren, F. (2018), <em>Calculating Probabilistic Excursion
Sets and Related Quantities Using excursions</em>, Journal of Statistical
Software, vol 86, no 1, pp 1-20.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+contourmap">contourmap</a></code>, <code><a href="#topic+contourmap.mc">contourmap.mc</a></code>,
<code><a href="#topic+contourmap.colors">contourmap.colors</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (require.nowarnings("INLA")) {
  # Generate mesh and SPDE model
  n.lattice &lt;- 10 # increase for more interesting, but slower, examples
  x &lt;- seq(from = 0, to = 10, length.out = n.lattice)
  lattice &lt;- fmesher::fm_lattice_2d(x = x, y = x)
  mesh &lt;- fmesher::fm_rcdt_2d_inla(lattice = lattice, extend = FALSE, refine = FALSE)
  spde &lt;- inla.spde2.matern(mesh, alpha = 2)

  # Generate an artificial sample
  sigma2.e &lt;- 0.01
  n.obs &lt;- 100
  obs.loc &lt;- cbind(
    runif(n.obs) * diff(range(x)) + min(x),
    runif(n.obs) * diff(range(x)) + min(x)
  )
  Q &lt;- inla.spde2.precision(spde, theta = c(log(sqrt(0.5)), log(sqrt(1))))
  x &lt;- inla.qsample(Q = Q)
  A &lt;- fmesher::fm_basis(mesh = mesh, loc = obs.loc)
  Y &lt;- as.vector(A %*% x + rnorm(n.obs) * sqrt(sigma2.e))

  ## Estimate the parameters using INLA
  mesh.index &lt;- inla.spde.make.index(name = "field", n.spde = spde$n.spde)
  ef &lt;- list(c(mesh.index, list(Intercept = 1)))

  s.obs &lt;- inla.stack(data = list(y = Y), A = list(A), effects = ef, tag = "obs")
  s.pre &lt;- inla.stack(data = list(y = NA), A = list(1), effects = ef, tag = "pred")
  stack &lt;- inla.stack(s.obs, s.pre)
  formula &lt;- y ~ -1 + Intercept + f(field, model = spde)
  result &lt;- inla(
    formula = formula, family = "normal", data = inla.stack.data(stack),
    control.predictor = list(
      A = inla.stack.A(stack),
      compute = TRUE
    ),
    control.compute = list(
      config = TRUE,
      return.marginals.predictor = TRUE
    ),
    num.threads = 1
  )

  ## Calculate contour map with two levels
  map &lt;- contourmap.inla(result,
    stack = stack, tag = "pred",
    n.levels = 2, alpha = 0.1, F.limit = 0.1,
    max.threads = 1
  )

  ## Plot the results
  cols &lt;- contourmap.colors(map,
    col = heat.colors(100, 1),
    credible.col = grey(0.5, 1)
  )
  image(matrix(map$M[mesh$idx$lattice], n.lattice, n.lattice), col = cols)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='contourmap.mc'>Contour maps and contour map quality measures using Monte Carlo samples</h2><span id='topic+contourmap.mc'></span>

<h3>Description</h3>

<p><code>contourmap.mc</code> is used for calculating contour maps and quality measures for contour maps based on Monte Carlo samples of a model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contourmap.mc(
  samples,
  n.levels,
  ind,
  levels,
  type = c("standard", "equalarea", "P0-optimal", "P1-optimal", "P2-optimal"),
  compute = list(F = TRUE, measures = NULL),
  alpha,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contourmap.mc_+3A_samples">samples</code></td>
<td>
<p>Matrix with model Monte Carlo samples. Each column contains a sample of the model.</p>
</td></tr>
<tr><td><code id="contourmap.mc_+3A_n.levels">n.levels</code></td>
<td>
<p>Number of levels in contour map.</p>
</td></tr>
<tr><td><code id="contourmap.mc_+3A_ind">ind</code></td>
<td>
<p>Indices of the nodes that should be analyzed (optional).</p>
</td></tr>
<tr><td><code id="contourmap.mc_+3A_levels">levels</code></td>
<td>
<p>Levels to use in contour map.</p>
</td></tr>
<tr><td><code id="contourmap.mc_+3A_type">type</code></td>
<td>
<p>Type of contour map. One of:
</p>

<dl>
<dt>'standard' </dt><dd><p>Equidistant levels between smallest and largest value of the posterior mean (default).</p>
</dd>
<dt>'pretty' </dt><dd><p>Equally spaced 'round' values which cover the range of the values in the posterior mean.</p>
</dd>
<dt>'equalarea' </dt><dd><p>Levels such that different spatial regions are approximately equal in size.</p>
</dd>
<dt>'P0-optimal' </dt><dd><p>Levels chosen to maximize the P0 measure.</p>
</dd>
<dt>'P1-optimal' </dt><dd><p>Levels chosen to maximize the P1 measure.</p>
</dd>
<dt>'P2-optimal' </dt><dd><p>Levels chosen to maximize the P2 measure.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="contourmap.mc_+3A_compute">compute</code></td>
<td>
<p>A list with quality indices to compute
</p>

<dl>
<dt>'F': </dt><dd><p>TRUE/FALSE indicating whether the contour map function should be computed (default TRUE).</p>
</dd>
<dt>'measures': </dt><dd><p>A list with the quality measures to compute (&quot;P0&quot;, &quot;P1&quot;, &quot;P2&quot;) or corresponding bounds based only on the marginal probabilities (&quot;P0-bound&quot;, &quot;P1-bound&quot;, &quot;P2-bound&quot;).</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="contourmap.mc_+3A_alpha">alpha</code></td>
<td>
<p>Maximal error probability in contour map function (default=0.1).</p>
</td></tr>
<tr><td><code id="contourmap.mc_+3A_verbose">verbose</code></td>
<td>
<p>Set to TRUE for verbose mode (optional).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The contour map is computed for the empirical mean of the samples.
See <code><a href="#topic+contourmap">contourmap</a></code> and <code><a href="#topic+contourmap.inla">contourmap.inla</a></code> for further details.
</p>


<h3>Value</h3>

<p><code>contourmap</code> returns an object of class &quot;excurobj&quot; with the following elements
</p>
<table>
<tr><td><code>u</code></td>
<td>
<p>Contour levels used in the contour map.</p>
</td></tr>
<tr><td><code>n.levels</code></td>
<td>
<p>The number of contours used.</p>
</td></tr>
<tr><td><code>u.e</code></td>
<td>
<p>The values associated with the level sets G_k.</p>
</td></tr>
<tr><td><code>G</code></td>
<td>
<p>A vector which shows which of the level sets G_k each node belongs to.</p>
</td></tr>
<tr><td><code>map</code></td>
<td>
<p>Representation of the contour map with map[i]=u.e[k] if i is in G_k.</p>
</td></tr>
<tr><td><code>F</code></td>
<td>
<p>The contour map function (if computed).</p>
</td></tr>
<tr><td><code>M</code></td>
<td>
<p>Contour avoiding sets (if <code>F</code> is computed). <code class="reqn">M=-1</code> for all non-significant nodes and  <code class="reqn">M=k</code> for nodes that belong to <code class="reqn">M_k</code>.</p>
</td></tr>
<tr><td><code>P0/P1/P2</code></td>
<td>
<p>Calculated quality measures (if computed).</p>
</td></tr>
<tr><td><code>P0bound/P1bound/P2bound</code></td>
<td>
<p>Calculated upper bounds quality measures (if computed).</p>
</td></tr>
<tr><td><code>meta</code></td>
<td>
<p>A list containing various information about the calculation.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Bolin <a href="mailto:davidbolin@gmail.com">davidbolin@gmail.com</a>
</p>


<h3>References</h3>

<p>Bolin, D. and Lindgren, F. (2017) <em>Quantifying the uncertainty of contour maps</em>, Journal of Computational and Graphical Statistics, 26:3, 513-524.
</p>
<p>Bolin, D. and Lindgren, F. (2018), <em>Calculating Probabilistic Excursion Sets and Related Quantities Using excursions</em>, Journal of Statistical Software, 86(5), 1&ndash;20.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+contourmap">contourmap</a></code>, <code><a href="#topic+contourmap.inla">contourmap.inla</a></code>, <code><a href="#topic+contourmap.colors">contourmap.colors</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
Q &lt;- Matrix(toeplitz(c(1, -0.5, rep(0, n - 2))))
mu &lt;- seq(-5, 5, length = n)
## Sample the model 100 times (increase for better estimate)
X &lt;- mu + solve(chol(Q), matrix(rnorm(n = n * 100), nrow = n, ncol = 100))

lp &lt;- contourmap.mc(X, n.levels = 2, compute = list(F = FALSE, measures = c("P1", "P2")))

# plot contourmap
plot(lp$map)
# display quality measures
c(lp$P1, lp$P2)
</code></pre>

<hr>
<h2 id='exc_safe_inla'>Load INLA safely for examples and tests</h2><span id='topic+exc_safe_inla'></span>

<h3>Description</h3>

<p>Loads the INLA package with 'requireNamespace(&quot;INLA&quot;, quietly = TRUE)', and
optionally checks and sets the multicore 'num.threads' INLA option.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exc_safe_inla(multicore = NULL, quietly = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exc_safe_inla_+3A_multicore">multicore</code></td>
<td>
<p>logical; if 'TRUE', multiple cores are allowed, and the
INLA 'num.threads' option is not checked or altered.
If 'FALSE', forces 'num.threads=&quot;1:1&quot;'. Default: NULL, checks
if running in testthat or non-interactively, in which case sets
'multicore=FALSE', otherwise 'TRUE'.</p>
</td></tr>
<tr><td><code id="exc_safe_inla_+3A_quietly">quietly</code></td>
<td>
<p>logical; if 'TRUE', prints diagnostic messages. Default: FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical; 'TRUE' if INLA was loaded safely, otherwise FALSE
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (exc_safe_inla()) {
  # Run inla dependent calculations
}

## End(Not run)

</code></pre>

<hr>
<h2 id='excursions'>Excursion Sets and Contour Credibility Regions for Random Fields</h2><span id='topic+excursions'></span>

<h3>Description</h3>

<p><code>excursions</code> is one of the main functions in the package with the same name.
For an introduction to the package, see <code><a href="#topic+excursions-package">excursions-package</a></code>. 
The function is used for calculating excursion sets, contour credible regions,
and contour avoiding sets for latent Gaussian models. Details on the function and the
package are given in the sections below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>excursions(
  alpha,
  u,
  mu,
  Q,
  type,
  n.iter = 10000,
  Q.chol,
  F.limit,
  vars,
  rho,
  reo,
  method = "EB",
  ind,
  max.size,
  verbose = 0,
  max.threads = 0,
  seed
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="excursions_+3A_alpha">alpha</code></td>
<td>
<p>Error probability for the excursion set.</p>
</td></tr>
<tr><td><code id="excursions_+3A_u">u</code></td>
<td>
<p>Excursion or contour level.</p>
</td></tr>
<tr><td><code id="excursions_+3A_mu">mu</code></td>
<td>
<p>Expectation vector.</p>
</td></tr>
<tr><td><code id="excursions_+3A_q">Q</code></td>
<td>
<p>Precision matrix.</p>
</td></tr>
<tr><td><code id="excursions_+3A_type">type</code></td>
<td>
<p>Type of region:
</p>

<dl>
<dt>'&gt;'</dt><dd><p>positive excursion region</p>
</dd>
<dt>'&lt;'</dt><dd><p>negative excursion region</p>
</dd>
<dt>'!='</dt><dd><p>contour avoiding region</p>
</dd>
<dt>'='</dt><dd><p>contour credibility region</p>
</dd></dl>
</td></tr>
<tr><td><code id="excursions_+3A_n.iter">n.iter</code></td>
<td>
<p>Number or iterations in the MC sampler that is used for approximating probabilities. The default value is 10000.</p>
</td></tr>
<tr><td><code id="excursions_+3A_q.chol">Q.chol</code></td>
<td>
<p>The Cholesky factor of the precision matrix (optional).</p>
</td></tr>
<tr><td><code id="excursions_+3A_f.limit">F.limit</code></td>
<td>
<p>The limit value for the computation of the F function. F is set to NA for all nodes where F&lt;1-F.limit. Default is F.limit = <code>alpha</code>.</p>
</td></tr>
<tr><td><code id="excursions_+3A_vars">vars</code></td>
<td>
<p>Precomputed marginal variances (optional).</p>
</td></tr>
<tr><td><code id="excursions_+3A_rho">rho</code></td>
<td>
<p>Marginal excursion probabilities (optional). For contour regions, provide <code class="reqn">P(X&gt;u)</code>.</p>
</td></tr>
<tr><td><code id="excursions_+3A_reo">reo</code></td>
<td>
<p>Reordering (optional).</p>
</td></tr>
<tr><td><code id="excursions_+3A_method">method</code></td>
<td>
<p>Method for handeling the latent Gaussian structure:
</p>

<dl>
<dt>'EB'</dt><dd><p>Empirical Bayes (default)</p>
</dd>
<dt>'QC'</dt><dd><p>Quantile correction, rho must be provided if QC is used.</p>
</dd></dl>
</td></tr>
<tr><td><code id="excursions_+3A_ind">ind</code></td>
<td>
<p>Indices of the nodes that should be analysed (optional).</p>
</td></tr>
<tr><td><code id="excursions_+3A_max.size">max.size</code></td>
<td>
<p>Maximum number of nodes to include in the set of interest (optional).</p>
</td></tr>
<tr><td><code id="excursions_+3A_verbose">verbose</code></td>
<td>
<p>Set to TRUE for verbose mode (optional).</p>
</td></tr>
<tr><td><code id="excursions_+3A_max.threads">max.threads</code></td>
<td>
<p>Decides the number of threads the program can use. Set to 0 for using the maximum number of threads allowed by the system (default).</p>
</td></tr>
<tr><td><code id="excursions_+3A_seed">seed</code></td>
<td>
<p>Random seed (optional).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The estimation of the region is done using sequential importance sampling with
<code>n.iter</code> samples. The procedure requires computing the marginal variances of
the field, which should be supplied if available. If not, they are computed using
the Cholesky factor of the precision matrix. The cost of this step can therefore be
reduced by supplying the Cholesky factor if it is available.
</p>
<p>The latent structure in the latent Gaussian model can be handled in several different
ways. The default strategy is the EB method, which is
exact for problems with Gaussian posterior distributions. For problems with
non-Gaussian posteriors, the QC method can be used for improved results. In order to use
the QC method, the true marginal excursion probabilities must be supplied using the
argument <code>rho</code>.
Other more
complicated methods for handling non-Gaussian posteriors must be implemented manually
unless <code>INLA</code> is used to fit the model. If the model is fitted using <code>INLA</code>,
the method <code>excursions.inla</code> can be used. See the Package section for further details
about the different options.
</p>


<h3>Value</h3>

<p><code>excursions</code> returns an object of class &quot;excurobj&quot; with the following elements
</p>
<table>
<tr><td><code>E</code></td>
<td>
<p>Excursion set, contour credible region, or contour avoiding set</p>
</td></tr>
<tr><td><code>G</code></td>
<td>
<p>Contour map set. <code class="reqn">G=1</code> for all nodes where the <code class="reqn">mu &gt; u</code>.</p>
</td></tr>
<tr><td><code>M</code></td>
<td>
<p>Contour avoiding set. <code class="reqn">M=-1</code> for all non-significant nodes. <code class="reqn">M=0</code> for nodes where the process is significantly below <code>u</code> and <code class="reqn">M=1</code> for all nodes where the field is significantly above <code>u</code>. Which values that should be present depends on what type of set that is calculated.</p>
</td></tr>
<tr><td><code>F</code></td>
<td>
<p>The excursion function corresponding to the set <code>E</code> calculated or values up to <code>F.limit</code></p>
</td></tr>
<tr><td><code>rho</code></td>
<td>
<p>Marginal excursion probabilities</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>
<p>The mean <code>mu</code>.</p>
</td></tr>
<tr><td><code>vars</code></td>
<td>
<p>Marginal variances.</p>
</td></tr>
<tr><td><code>meta</code></td>
<td>
<p>A list containing various information about the calculation.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Bolin <a href="mailto:davidbolin@gmail.com">davidbolin@gmail.com</a> and Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>References</h3>

<p>Bolin, D. and Lindgren, F. (2015) <em>Excursion and contour uncertainty regions for latent Gaussian models</em>, JRSS-series B, vol 77, no 1, pp 85-106.
</p>
<p>Bolin, D. and Lindgren, F. (2018), <em>Calculating Probabilistic Excursion Sets and Related Quantities Using excursions</em>, Journal of Statistical Software, vol 86, no 1, pp 1-20.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+excursions-package">excursions-package</a></code>, <code><a href="#topic+excursions.inla">excursions.inla</a></code>, <code><a href="#topic+excursions.mc">excursions.mc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create a tridiagonal precision matrix
n &lt;- 21
Q.x &lt;- sparseMatrix(
  i = c(1:n, 2:n), j = c(1:n, 1:(n - 1)), x = c(rep(1, n), rep(-0.1, n - 1)),
  dims = c(n, n), symmetric = TRUE
)
## Set the mean value function
mu.x &lt;- seq(-5, 5, length = n)

## calculate the level 0 positive excursion function
res.x &lt;- excursions(
  alpha = 1, u = 0, mu = mu.x, Q = Q.x,
  type = "&gt;", verbose = 1, max.threads = 2
)

## Plot the excursion function and the marginal excursion probabilities
plot(res.x$F,
  type = "l",
  main = "Excursion function (black) and marginal probabilites (red)"
)
lines(res.x$rho, col = 2)
</code></pre>

<hr>
<h2 id='excursions.inla'>Excursion sets and contour credible regions for latent Gaussian models</h2><span id='topic+excursions.inla'></span>

<h3>Description</h3>

<p>Excursion sets and contour credible regions for latent Gaussian models
calculated using the INLA method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>excursions.inla(
  result.inla,
  stack,
  name = NULL,
  tag = NULL,
  ind = NULL,
  method,
  alpha = 1,
  F.limit,
  u,
  u.link = FALSE,
  type,
  n.iter = 10000,
  verbose = 0,
  max.threads = 0,
  compressed = TRUE,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="excursions.inla_+3A_result.inla">result.inla</code></td>
<td>
<p>Result object from INLA call.</p>
</td></tr>
<tr><td><code id="excursions.inla_+3A_stack">stack</code></td>
<td>
<p>The stack object used in the INLA call.</p>
</td></tr>
<tr><td><code id="excursions.inla_+3A_name">name</code></td>
<td>
<p>The name of the component for which to do the calculation. This
argument should only be used if a stack object is not provided, use the tag
argument otherwise.</p>
</td></tr>
<tr><td><code id="excursions.inla_+3A_tag">tag</code></td>
<td>
<p>The tag of the component in the stack for which to do the calculation.
This argument should only be used if a stack object is provided, use the name
argument otherwise.</p>
</td></tr>
<tr><td><code id="excursions.inla_+3A_ind">ind</code></td>
<td>
<p>If only a part of a component should be used in the calculations,
this argument specifies the indices for that part.</p>
</td></tr>
<tr><td><code id="excursions.inla_+3A_method">method</code></td>
<td>
<p>Method for handeling the latent Gaussian structure:
</p>

<dl>
<dt>'EB' </dt><dd><p>Empirical Bayes</p>
</dd>
<dt>'QC' </dt><dd><p>Quantile correction</p>
</dd>
<dt>'NI' </dt><dd><p>Numerical integration</p>
</dd>
<dt>'NIQC' </dt><dd><p>Numerical integration with quantile correction</p>
</dd>
<dt>'iNIQC' </dt><dd><p>Improved integration with quantile correction</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="excursions.inla_+3A_alpha">alpha</code></td>
<td>
<p>Error probability for the excursion set of interest. The default
value is 1.</p>
</td></tr>
<tr><td><code id="excursions.inla_+3A_f.limit">F.limit</code></td>
<td>
<p>Error probability for when to stop the calculation of the
excursion function. The default value is <code>alpha</code>, and the value cannot
be smaller than <code>alpha</code>. A smaller value of <code>F.limit</code> results in a
smaller computation time.</p>
</td></tr>
<tr><td><code id="excursions.inla_+3A_u">u</code></td>
<td>
<p>Excursion or contour level.</p>
</td></tr>
<tr><td><code id="excursions.inla_+3A_u.link">u.link</code></td>
<td>
<p>If u.link is TRUE, <code>u</code> is assumed to be in the scale of the
data and is then transformed to the scale of the linear predictor (default FALSE).</p>
</td></tr>
<tr><td><code id="excursions.inla_+3A_type">type</code></td>
<td>
<p>Type of region:
</p>

<dl>
<dt>'&gt;' </dt><dd><p>positive excursions</p>
</dd>
<dt>'&lt;' </dt><dd><p>negative excursions</p>
</dd>
<dt>'!=' </dt><dd><p>contour avoiding function</p>
</dd>
<dt>'=' </dt><dd><p>contour credibility function</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="excursions.inla_+3A_n.iter">n.iter</code></td>
<td>
<p>Number or iterations in the MC sampler that is used for
approximating probabilities. The default value is 10000.</p>
</td></tr>
<tr><td><code id="excursions.inla_+3A_verbose">verbose</code></td>
<td>
<p>Set to TRUE for verbose mode (optional).</p>
</td></tr>
<tr><td><code id="excursions.inla_+3A_max.threads">max.threads</code></td>
<td>
<p>Decides the number of threads the program can use. Set to
0 for using the maximum number of threads allowed by the system (default).</p>
</td></tr>
<tr><td><code id="excursions.inla_+3A_compressed">compressed</code></td>
<td>
<p>If INLA is run in compressed mode and a part of the linear
predictor is to be used, then only add the relevant part. Otherwise the
entire linear predictor is added internally (default TRUE).</p>
</td></tr>
<tr><td><code id="excursions.inla_+3A_seed">seed</code></td>
<td>
<p>Random seed (optional).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The different methods for handling the latent Gaussian structure are
listed in order of accuracy and computational cost. The <code>EB</code> method is
the simplest and is based on a Gaussian approximation of the posterior of the
quantity of interest. The <code>QC</code> method uses the same Gaussian approximation
but improves the accuracy by modifying the limits in the integrals that are
computed in order to find the region. The other three methods are intended for
Bayesian models where the posterior distribution for the quantity of  interest
is obtained by integrating over the parameters in the model. The <code>NI</code>
method approximates this integration in the same way as is done in INLA, and
the <code>NIQC</code> and <code>iNIQC</code> methods combine this apprximation with the
QC method for improved accuracy.
</p>
<p>If the main purpose of the analysis is to construct excursion or contour sets
for low values of <code>alpha</code>, we recommend using <code>QC</code> for problems with
Gaussian likelihoods and <code>NIQC</code> for problems with non-Gaussian likelihoods.
The reason for this is that the more accurate methods also have higher
computational costs.
</p>


<h3>Value</h3>

<p><code>excursions.inla</code> returns an object of class &quot;excurobj&quot; with the 
following elements
</p>
<table>
<tr><td><code>E</code></td>
<td>
<p>Excursion set, contour credible region, or contour avoiding set</p>
</td></tr>
<tr><td><code>F</code></td>
<td>
<p>The excursion function corresponding to the set <code>E</code> calculated
for values up to <code>F.limit</code></p>
</td></tr>
<tr><td><code>G</code></td>
<td>
<p> Contour map set. <code class="reqn">G=1</code> for all nodes where the <code class="reqn">mu &gt; u</code>.</p>
</td></tr>
<tr><td><code>M</code></td>
<td>
<p> Contour avoiding set. <code class="reqn">M=-1</code> for all non-significant nodes.
<code class="reqn">M=0</code> for nodes where the process is significantly below <code>u</code> and
<code class="reqn">M=1</code> for all nodes where the field is significantly above <code>u</code>.
Which values that should be present depends on what type of set that is
calculated.</p>
</td></tr>
<tr><td><code>rho</code></td>
<td>
<p>Marginal excursion probabilities</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>
<p>Posterior mean</p>
</td></tr>
<tr><td><code>vars</code></td>
<td>
<p>Marginal variances</p>
</td></tr>
<tr><td><code>meta</code></td>
<td>
<p>A list containing various information about the calculation.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function requires the <code>INLA</code> package, which is not a CRAN
package.  See <a href="https://www.r-inla.org/download-install">https://www.r-inla.org/download-install</a> for easy
installation instructions.
</p>


<h3>Author(s)</h3>

<p>David Bolin <a href="mailto:davidbolin@gmail.com">davidbolin@gmail.com</a> and Finn Lindgren
<a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>References</h3>

<p>Bolin, D. and Lindgren, F. (2015) <em>Excursion and contour
uncertainty regions for latent Gaussian models</em>, JRSS-series B, vol 77, no 1,
pp 85-106.
</p>
<p>Bolin, D. and Lindgren, F. (2018), <em>Calculating Probabilistic Excursion
Sets and Related Quantities Using excursions</em>, Journal of Statistical Software,
vol 86, no 1, pp 1-20.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+excursions">excursions</a></code>, <code><a href="#topic+excursions.mc">excursions.mc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## In this example, we calculate the excursion function
## for a partially observed AR process.
## Not run: 
if (require.nowarnings("INLA")) {
  ## Sample the process:
  rho &lt;- 0.9
  tau &lt;- 15
  tau.e &lt;- 1
  n &lt;- 100
  x &lt;- 1:n
  mu &lt;- 10 * ((x &lt; n / 2) * (x - n / 2) + (x &gt;= n / 2) * (n / 2 - x) + n / 4) / n
  Q &lt;- tau * sparseMatrix(
    i = c(1:n, 2:n), j = c(1:n, 1:(n - 1)),
    x = c(1, rep(1 + rho^2, n - 2), 1, rep(-rho, n - 1)),
    dims = c(n, n), symmetric = TRUE
  )
  X &lt;- mu + solve(chol(Q), rnorm(n))

  ## measure the sampled process at n.obs random locations
  ## under Gaussian measurement noise.
  n.obs &lt;- 50
  obs.loc &lt;- sample(1:n, n.obs)
  A &lt;- sparseMatrix(
    i = 1:n.obs, j = obs.loc, x = rep(1, n.obs),
    dims = c(n.obs, n)
  )
  Y &lt;- as.vector(A %*% X + rnorm(n.obs) / sqrt(tau.e))

  ## Estimate the parameters using INLA
  ef &lt;- list(c(list(ar = x), list(cov = mu)))
  s.obs &lt;- inla.stack(data = list(y = Y), A = list(A), effects = ef, tag = "obs")
  s.pre &lt;- inla.stack(data = list(y = NA), A = list(1), effects = ef, tag = "pred")
  stack &lt;- inla.stack(s.obs, s.pre)
  formula &lt;- y ~ -1 + cov + f(ar, model = "ar1")
  result &lt;- inla(
    formula = formula, family = "normal", data = inla.stack.data(stack),
    control.predictor = list(A = inla.stack.A(stack), compute = TRUE),
    control.compute = list(
      config = TRUE,
      return.marginals.predictor = TRUE
    )
  )

  ## calculate the level 0 positive excursion function
  res.qc &lt;- excursions.inla(result,
    stack = stack, tag = "pred", alpha = 0.99, u = 0,
    method = "QC", type = "&gt;", max.threads = 2
  )
  ## plot the excursion function and marginal probabilities
  plot(res.qc$rho,
    type = "l",
    main = "marginal probabilities (black) and excursion function (red)"
  )
  lines(res.qc$F, col = 2)
}

## End(Not run)

</code></pre>

<hr>
<h2 id='excursions.mc'>Excursion sets and contour credible regions using Monte Carlo samples</h2><span id='topic+excursions.mc'></span>

<h3>Description</h3>

<p><code>excursions.mc</code> is used for calculating excursion sets, contour credible
regions, and contour avoiding sets based on Monte Carlo samples of models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>excursions.mc(
  samples,
  alpha,
  u,
  type,
  rho,
  reo,
  ind,
  max.size,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="excursions.mc_+3A_samples">samples</code></td>
<td>
<p>Matrix with model Monte Carlo samples. Each column contains a
sample of the model.</p>
</td></tr>
<tr><td><code id="excursions.mc_+3A_alpha">alpha</code></td>
<td>
<p>Error probability for the excursion set.</p>
</td></tr>
<tr><td><code id="excursions.mc_+3A_u">u</code></td>
<td>
<p>Excursion or contour level.</p>
</td></tr>
<tr><td><code id="excursions.mc_+3A_type">type</code></td>
<td>
<p>Type of region:
</p>

<dl>
<dt>'&gt;' </dt><dd><p>positive excursions</p>
</dd>
<dt>'&lt;' </dt><dd><p>negative excursions</p>
</dd>
<dt>'!=' </dt><dd><p>contour avoiding function</p>
</dd>
<dt>'=' </dt><dd><p>contour credibility function</p>
</dd></dl>
</td></tr>
<tr><td><code id="excursions.mc_+3A_rho">rho</code></td>
<td>
<p>Marginal excursion probabilities (optional). For contour regions,
provide <code class="reqn">P(X&gt;u)</code>.</p>
</td></tr>
<tr><td><code id="excursions.mc_+3A_reo">reo</code></td>
<td>
<p>Reordering (optional).</p>
</td></tr>
<tr><td><code id="excursions.mc_+3A_ind">ind</code></td>
<td>
<p>Indices of the nodes that should be analysed (optional).</p>
</td></tr>
<tr><td><code id="excursions.mc_+3A_max.size">max.size</code></td>
<td>
<p>Maximum number of nodes to include in the set of interest (optional).</p>
</td></tr>
<tr><td><code id="excursions.mc_+3A_verbose">verbose</code></td>
<td>
<p>Set to TRUE for verbose mode (optional).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>excursions.mc</code> returns an object of class &quot;excurobj&quot; with the 
following elements
</p>
<table>
<tr><td><code>E</code></td>
<td>
<p>Excursion set, contour credible region, or contour avoiding set.</p>
</td></tr>
<tr><td><code>G</code></td>
<td>
<p> Contour map set. <code class="reqn">G=1</code> for all nodes where the <code class="reqn">mu &gt; u</code>.</p>
</td></tr>
<tr><td><code>M</code></td>
<td>
<p> Contour avoiding set. <code class="reqn">M=-1</code> for all non-significant nodes.
<code class="reqn">M=0</code> for nodes where the process is significantly below <code>u</code> and
<code class="reqn">M=1</code> for all nodes where the field is significantly above <code>u</code>.
Which values that should be present depends on what type of set that is calculated.</p>
</td></tr>
<tr><td><code>F</code></td>
<td>
<p>The excursion function corresponding to the set <code>E</code> calculated
for values up to <code>F.limit</code></p>
</td></tr>
<tr><td><code>rho</code></td>
<td>
<p>Marginal excursion probabilities</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>
<p>The mean <code>mu</code>.</p>
</td></tr>
<tr><td><code>vars</code></td>
<td>
<p>Marginal variances.</p>
</td></tr>
<tr><td><code>meta</code></td>
<td>
<p>A list containing various information about the calculation.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Bolin <a href="mailto:davidbolin@gmail.com">davidbolin@gmail.com</a> and Finn Lindgren
<a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>References</h3>

<p>Bolin, D. and Lindgren, F. (2015) <em>Excursion and contour
uncertainty regions for latent Gaussian models</em>, JRSS-series B, vol 77, no 1,
pp 85-106.
</p>
<p>Bolin, D. and Lindgren, F. (2018), <em>Calculating Probabilistic Excursion Sets and Related Quantities Using excursions</em>, Journal of Statistical Software, vol 86, no 1, pp 1-20.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+excursions">excursions</a></code>, <code><a href="#topic+excursions.inla">excursions.inla</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create mean and a tridiagonal precision matrix
n &lt;- 101
mu.x &lt;- seq(-5, 5, length = n)
Q.x &lt;- Matrix(toeplitz(c(1, -0.1, rep(0, n - 2))))
## Sample the model 100 times (increase for better estimate)
X &lt;- mu.x + solve(chol(Q.x), matrix(rnorm(n = n * 1000), nrow = n, ncol = 1000))
## calculate the positive excursion function
res.x &lt;- excursions.mc(X, alpha = 0.05, type = "&gt;", u = 0)
## Plot the excursion function and the marginal excursion probabilities
plot(res.x$F,
  type = "l",
  main = "Excursion function (black) and marginal probabilites (red)"
)
lines(res.x$rho, col = 2)
</code></pre>

<hr>
<h2 id='excursions.variances'>Calculate variances from a sparse precision matrix</h2><span id='topic+excursions.variances'></span>

<h3>Description</h3>

<p><code>excursions.variances</code> calculates the diagonal of the inverse of a sparse
symmetric positive definite matrix <code>Q</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>excursions.variances(L, Q, max.threads = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="excursions.variances_+3A_l">L</code></td>
<td>
<p>Cholesky factor of precision matrix.</p>
</td></tr>
<tr><td><code id="excursions.variances_+3A_q">Q</code></td>
<td>
<p>Precision matrix.</p>
</td></tr>
<tr><td><code id="excursions.variances_+3A_max.threads">max.threads</code></td>
<td>
<p>Decides the number of threads the program can use. Set to 0 for using
the maximum number of threads allowed by the system (default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method for calculating the
diagonal requires the Cholesky factor, <code>L</code>, of <code>Q</code>, which should be supplied if
available. If <code>Q</code> is provided, the cholesky factor is
calculated and the variances are then returned in the same ordering as <code>Q</code>.
If <code>L</code> is provided, the variances are returned in the same ordering as <code>L</code>,
even if <code>L@invpivot</code> exists.
</p>


<h3>Value</h3>

<p>A vector with the variances.
</p>


<h3>Author(s)</h3>

<p>David Bolin <a href="mailto:davidbolin@gmail.com">davidbolin@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create a tridiagonal precision matrix
n &lt;- 21
Q &lt;- Matrix(toeplitz(c(1, -0.1, rep(0, n - 2))))
v2 &lt;- excursions.variances(Q = Q, max.threads = 2)
## var2 should be the same as:
v1 &lt;- diag(solve(Q))
</code></pre>

<hr>
<h2 id='gaussint'>Sequential estimation of Gaussian integrals</h2><span id='topic+gaussint'></span>

<h3>Description</h3>

<p><code>gaussint</code> is used for calculating <code class="reqn">n</code>-dimensional Gaussian integrals
</p>
<p style="text-align: center;"><code class="reqn">\int_a^b \frac{|Q|^{1/2}}{(2\pi)^{n/2}}
\exp(-\frac1{2}(x-\mu)^{T}Q(x-\mu)) dx</code>
</p>

<p>A limit value <code class="reqn">lim</code> can be used to stop the integration if the sequential
estimate goes below the limit, which can result in substantial computational
savings in cases when one only is interested in testing if the integral is above
the limit value. The integral is calculated sequentially, and estimates for
all subintegrals are also returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaussint(
  mu,
  Q.chol,
  Q,
  a,
  b,
  lim = 0,
  n.iter = 10000,
  ind,
  use.reordering = c("natural", "sparsity", "limits"),
  max.size,
  max.threads = 0,
  seed
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gaussint_+3A_mu">mu</code></td>
<td>
<p>Expectation vector for the Gaussian distribution.</p>
</td></tr>
<tr><td><code id="gaussint_+3A_q.chol">Q.chol</code></td>
<td>
<p>The Cholesky factor of the precision matrix (optional).</p>
</td></tr>
<tr><td><code id="gaussint_+3A_q">Q</code></td>
<td>
<p>Precision matrix for the Gaussian distribution. If Q is supplied but not Q.chol,
the cholesky factor is computed before integrating.</p>
</td></tr>
<tr><td><code id="gaussint_+3A_a">a</code></td>
<td>
<p>Lower limit in integral.</p>
</td></tr>
<tr><td><code id="gaussint_+3A_b">b</code></td>
<td>
<p>Upper limit in integral.</p>
</td></tr>
<tr><td><code id="gaussint_+3A_lim">lim</code></td>
<td>
<p>If this argument is used, the integration is stopped and 0 is returned
if the estimated value goes below <code class="reqn">lim</code>.</p>
</td></tr>
<tr><td><code id="gaussint_+3A_n.iter">n.iter</code></td>
<td>
<p>Number or iterations in the MC sampler that is used for approximating
probabilities. The default value is 10000.</p>
</td></tr>
<tr><td><code id="gaussint_+3A_ind">ind</code></td>
<td>
<p>Indices of the nodes that should be analyzed (optional).</p>
</td></tr>
<tr><td><code id="gaussint_+3A_use.reordering">use.reordering</code></td>
<td>
<p>Determines what reordering to use:
</p>

<dl>
<dt>&quot;natural&quot; </dt><dd><p>No reordering is performed.</p>
</dd>
<dt>&quot;sparsity&quot; </dt><dd><p>Reorder for sparsity in the cholesky factor (MMD reordering
is used).</p>
</dd>
<dt>&quot;limits&quot; </dt><dd><p>Reorder by moving all nodes with a=-Inf and b=Inf first and
then reordering for sparsity (CAMD reordering is used).</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="gaussint_+3A_max.size">max.size</code></td>
<td>
<p>The largest number of sub-integrals to compute. Default is the total
dimension of the distribution.</p>
</td></tr>
<tr><td><code id="gaussint_+3A_max.threads">max.threads</code></td>
<td>
<p>Decides the number of threads the program can use. Set to 0 for
using the maximum number of threads allowed by the system (default).</p>
</td></tr>
<tr><td><code id="gaussint_+3A_seed">seed</code></td>
<td>
<p>The random seed to use (optional).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses sequential importance sampling to estimate the
Gaussian integral, and returns all computed sub-integrals. This means that if, for
example, the function is used to compute <code class="reqn">P(x&gt;0)</code> for an n-dimensional Gaussian
variable <code class="reqn">x</code>, then all integrals <code class="reqn">P(x_1&gt;0,\ldots,x_i&gt;0)</code> for <code class="reqn">i=1,\ldots,n</code> are
computed.
</p>
<p>If one is only interested in whether <code class="reqn">P(x&gt;0)&gt;\alpha</code> or not, then one can
stop the integration as soon as <code class="reqn">P(x_1&gt;0,\ldots,x_i&gt;0)&lt;\alpha</code>. This can save a lot of
computation time if <code class="reqn">P(x_1&gt;0,\ldots,x_i&gt;0)&lt; \alpha</code> for <code class="reqn">i</code> much smaller than
<code class="reqn">n</code>. This limit value is specified by the <code>lim</code> argument.
</p>
<p>Which reordering to use depends on what the purpose of the calculation is and what
the integration limits are. However, in general the <code>limits</code> reordering is typically
most appropriate since this combines sparisty (which improves accuracy and reduces
computational cost) with automatic handling of dimensions with limits <code>a=-Inf</code> and
<code>b=Inf</code>, which do not affect the probability but affect the computation time
if they are not handled separately.
</p>


<h3>Value</h3>

<p>A list with elements
</p>
<table>
<tr><td><code>P</code></td>
<td>
<p>Value of the integral.</p>
</td></tr>
<tr><td><code>E</code></td>
<td>
<p>Estimated error of the P estimate.</p>
</td></tr>
<tr><td><code>Pv</code></td>
<td>
<p>A vector with the estimates of all sub-integrals.</p>
</td></tr>
<tr><td><code>Ev</code></td>
<td>
<p>A vector with the estimated errors of the Pv estimates.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Bolin <a href="mailto:davidbolin@gmail.com">davidbolin@gmail.com</a>
</p>


<h3>References</h3>

<p>Bolin, D. and Lindgren, F. (2015) <em>Excursion and contour uncertainty regions for latent Gaussian models</em>, JRSS-series B, vol 77, no 1, pp 85-106.
</p>
<p>Bolin, D. and Lindgren, F. (2018), <em>Calculating Probabilistic Excursion Sets and Related Quantities Using excursions</em>, Journal of Statistical Software, vol 86, no 1, pp 1-20.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create mean and a tridiagonal precision matrix
n &lt;- 11
mu.x &lt;- seq(-5, 5, length = n)
Q.x &lt;- Matrix(toeplitz(c(1, -0.1, rep(0, n - 2))))
## Calculate the probability that the variable is between mu-3 and mu+3
prob &lt;- gaussint(mu = mu.x, Q = Q.x, a = mu.x - 3, b = mu.x + 3, max.threads = 2)
prob$P
</code></pre>

<hr>
<h2 id='local_exc_testthat'>Unit test helpers</h2><span id='topic+local_exc_testthat'></span><span id='topic+local_exc_safe_inla'></span>

<h3>Description</h3>

<p>Local helper functions for package unit tests
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_exc_safe_inla(multicore = FALSE, quietly = TRUE, envir = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="local_exc_testthat_+3A_multicore">multicore</code></td>
<td>
<p>logical; if 'TRUE', multiple cores are allowed, and the
INLA 'num.threads' option is not checked or altered. Default: 'FALSE', multicore
not allowed (used for examples and unit tests).</p>
</td></tr>
<tr><td><code id="local_exc_testthat_+3A_quietly">quietly</code></td>
<td>
<p>logical; if 'TRUE', prints diagnostic messages. A message is
always printed if the INLA 'num.threads' option is altered, regardless of the
'quietly' argument. Default: TRUE.</p>
</td></tr>
<tr><td><code id="local_exc_testthat_+3A_envir">envir</code></td>
<td>
<p>environment for exit handlers</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>local_exc_safe_inla()</code>: Tests should set num.threads = &quot;1:1&quot; to ensure
within-system repeatability by calling 'local_exc_safe_inla()';
see also [exc_safe_inla()]
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
local_exc_safe_inla(multicore = FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='require.nowarnings'>Warnings free loading of add-on packages</h2><span id='topic+require.nowarnings'></span>

<h3>Description</h3>

<p>Turn off all warnings for require(), to allow clean completion
of examples that require unavailable Suggested packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>require.nowarnings(package, lib.loc = NULL, character.only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="require.nowarnings_+3A_package">package</code></td>
<td>
<p>The name of a package, given as a character string.</p>
</td></tr>
<tr><td><code id="require.nowarnings_+3A_lib.loc">lib.loc</code></td>
<td>
<p>a character vector describing the location of R library trees
to search through, or <code>NULL</code>.  The default value of <code>NULL</code>
corresponds to all libraries currently known to <code>.libPaths()</code>.
Non-existent library trees are silently ignored.</p>
</td></tr>
<tr><td><code id="require.nowarnings_+3A_character.only">character.only</code></td>
<td>
<p>a logical indicating whether <code>package</code> can be
assumed to be a character string.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>require(package)</code> acts the same as
<code>require(package, quietly = TRUE)</code> but with warnings turned off.
In particular, no warning or error is given if the package is unavailable.
Most cases should use <code>requireNamespace(package, quietly = TRUE)</code> instead,
which doesn't produce warnings.
</p>


<h3>Value</h3>

<p><code>require.nowarnings</code> returns (invisibly) <code>TRUE</code> if it succeeds, otherwise <code>FALSE</code>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+require">require</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## This should produce no output:
if (require.nowarnings(nonexistent)) {
  message("Package loaded successfully")
}
</code></pre>

<hr>
<h2 id='simconf'>Simultaneous confidence regions for Gaussian models</h2><span id='topic+simconf'></span>

<h3>Description</h3>

<p><code>simconf</code> is used for calculating simultaneous confidence regions for
Gaussian models <code class="reqn">x</code>. The function returns upper and lower bounds <code class="reqn">a</code>
and <code class="reqn">b</code> such that <code class="reqn">P(a&lt;x&lt;b) = 1-\alpha</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simconf(
  alpha,
  mu,
  Q,
  n.iter = 10000,
  Q.chol,
  vars,
  ind = NULL,
  verbose = 0,
  max.threads = 0,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simconf_+3A_alpha">alpha</code></td>
<td>
<p>Error probability for the region.</p>
</td></tr>
<tr><td><code id="simconf_+3A_mu">mu</code></td>
<td>
<p>Expectation vector for the Gaussian distribution.</p>
</td></tr>
<tr><td><code id="simconf_+3A_q">Q</code></td>
<td>
<p>Precision matrix for the Gaussian distribution.</p>
</td></tr>
<tr><td><code id="simconf_+3A_n.iter">n.iter</code></td>
<td>
<p>Number or iterations in the MC sampler that is used for
approximating probabilities. The default value is 10000.</p>
</td></tr>
<tr><td><code id="simconf_+3A_q.chol">Q.chol</code></td>
<td>
<p>The Cholesky factor of the precision matrix (optional).</p>
</td></tr>
<tr><td><code id="simconf_+3A_vars">vars</code></td>
<td>
<p>Precomputed marginal variances (optional).</p>
</td></tr>
<tr><td><code id="simconf_+3A_ind">ind</code></td>
<td>
<p>Indices of the nodes that should be analyzed (optional).</p>
</td></tr>
<tr><td><code id="simconf_+3A_verbose">verbose</code></td>
<td>
<p>Set to TRUE for verbose mode (optional).</p>
</td></tr>
<tr><td><code id="simconf_+3A_max.threads">max.threads</code></td>
<td>
<p>Decides the number of threads the program can use.
Set to 0 for using the maximum number of threads allowed by the system (default).</p>
</td></tr>
<tr><td><code id="simconf_+3A_seed">seed</code></td>
<td>
<p>Random seed (optional).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The pointwise confidence bands are based on the marginal quantiles,
meaning that <code>a.marignal</code> is a vector where the ith element equals 
<code class="reqn">\mu_i + q_{\alpha,i}</code>  and <code>b.marginal</code> is a vector where the ith element
equals  <code class="reqn">\mu_i + q_{1-\alpha,i}</code>, where <code class="reqn">\mu_i</code> is the expected value 
of the <code class="reqn">x_i</code> and <code class="reqn">q_{\alpha,i}</code> is the <code class="reqn">\alpha</code>-quantile of <code class="reqn">x_i-\mu_i</code>.
</p>
<p>The simultaneous confidence band is defined by the lower limit vector <code>a</code> and 
the upper limit vector <code>b</code>, where <code class="reqn">a_i = \mu_i +c q_{\alpha}</code> and 
<code class="reqn">b_i = \mu_i + c q_{1-\alpha}</code>, where <code class="reqn">c</code> is a constant computed such 
that <code class="reqn">P(a &lt; x &lt; b) = 1-\alpha</code>.
</p>


<h3>Value</h3>

<p>An object of class &quot;excurobj&quot; with elements
</p>
<table>
<tr><td><code>a</code></td>
<td>
<p>The lower bound.</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>The upper bound.</p>
</td></tr>
<tr><td><code>a.marginal</code></td>
<td>
<p>The lower bound for pointwise confidence bands.</p>
</td></tr>
<tr><td><code>b.marginal</code></td>
<td>
<p>The upper bound for pointwise confidence bands.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Bolin <a href="mailto:davidbolin@gmail.com">davidbolin@gmail.com</a> and Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>References</h3>

<p>Bolin et al. (2015) <em>Statistical prediction of global sea level
from global temperature</em>, Statistica Sinica, vol 25, pp 351-367.
</p>
<p>Bolin, D. and Lindgren, F. (2018), <em>Calculating Probabilistic Excursion Sets and Related Quantities Using excursions</em>, Journal of Statistical Software, vol 86, no 1, pp 1-20.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simconf.inla">simconf.inla</a></code>, <code><a href="#topic+simconf.mc">simconf.mc</a></code>, <code><a href="#topic+simconf.mixture">simconf.mixture</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create mean and a tridiagonal precision matrix
n &lt;- 11
mu.x &lt;- seq(-5, 5, length = n)
Q.x &lt;- Matrix(toeplitz(c(1, -0.1, rep(0, n - 2))))
## calculate the confidence region
conf &lt;- simconf(0.05, mu.x, Q.x, max.threads = 2)
## Plot the region
plot(mu.x,
  type = "l", ylim = c(-10, 10),
  main = "Mean (black) and confidence region (red)"
)
lines(conf$a, col = 2)
lines(conf$b, col = 2)
</code></pre>

<hr>
<h2 id='simconf.inla'>Simultaneous confidence regions for latent Gaussian models</h2><span id='topic+simconf.inla'></span>

<h3>Description</h3>

<p><code>simconf.inla</code> is used for calculating simultaneous confidence regions
for latent Gaussian models estimated using <code>INLA</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simconf.inla(
  result.inla,
  stack,
  name = NULL,
  tag = NULL,
  ind = NULL,
  alpha,
  method = "NI",
  n.iter = 10000,
  verbose = 0,
  link = FALSE,
  max.threads = 0,
  seed = NULL,
  inla.sample = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simconf.inla_+3A_result.inla">result.inla</code></td>
<td>
<p>Result object from INLA call.</p>
</td></tr>
<tr><td><code id="simconf.inla_+3A_stack">stack</code></td>
<td>
<p>The stack object used in the INLA call.</p>
</td></tr>
<tr><td><code id="simconf.inla_+3A_name">name</code></td>
<td>
<p>The name of the component for which to do the calculation. This
argument should only be used if a stack object is not provided, use the tag
argument otherwise.</p>
</td></tr>
<tr><td><code id="simconf.inla_+3A_tag">tag</code></td>
<td>
<p>The tag of the component in the stack for which to do the calculation.
This argument should only be used if a stack object is provided, use the name
argument otherwise.</p>
</td></tr>
<tr><td><code id="simconf.inla_+3A_ind">ind</code></td>
<td>
<p>If only a part of a component should be used in the calculations, this
argument specifies the indices for that part.</p>
</td></tr>
<tr><td><code id="simconf.inla_+3A_alpha">alpha</code></td>
<td>
<p>Error probability for the region.</p>
</td></tr>
<tr><td><code id="simconf.inla_+3A_method">method</code></td>
<td>
<p>Method for handling the latent Gaussian structure:
</p>

<dl>
<dt>'EB' </dt><dd><p>Empirical Bayes (Gaussian approximation of posterior).</p>
</dd>
<dt>'NI' </dt><dd><p>Numerical integration (Calculation based on the Gaussian mixture
approximation of the posterior, as calculated by INLA).</p>
</dd></dl>
</td></tr>
<tr><td><code id="simconf.inla_+3A_n.iter">n.iter</code></td>
<td>
<p>Number or iterations in the MC sampler that is used for approximating
probabilities. The default value is 10000.</p>
</td></tr>
<tr><td><code id="simconf.inla_+3A_verbose">verbose</code></td>
<td>
<p>Set to TRUE for verbose mode (optional).</p>
</td></tr>
<tr><td><code id="simconf.inla_+3A_link">link</code></td>
<td>
<p>Transform output to the scale of the data using the link function as defined in
the model estimated with INLA (default FALSE).</p>
</td></tr>
<tr><td><code id="simconf.inla_+3A_max.threads">max.threads</code></td>
<td>
<p>Decides the number of threads the program can use. Set to 0 for
using the maximum number of threads allowed by the system (default).</p>
</td></tr>
<tr><td><code id="simconf.inla_+3A_seed">seed</code></td>
<td>
<p>Random seed (optional).</p>
</td></tr>
<tr><td><code id="simconf.inla_+3A_inla.sample">inla.sample</code></td>
<td>
<p>Set to TRUE if inla.posterior.sample should be used for the MC
integration.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+simconf">simconf</a></code> for details.
</p>


<h3>Value</h3>

<p>An object of class &quot;excurobj&quot; with elements
</p>
<table>
<tr><td><code>a</code></td>
<td>
<p>The lower bound.</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>The upper bound.</p>
</td></tr>
<tr><td><code>a.marginal</code></td>
<td>
<p>The lower bound for pointwise confidence bands.</p>
</td></tr>
<tr><td><code>b.marginal</code></td>
<td>
<p>The upper bound for pointwise confidence bands.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function requires the <code>INLA</code> package, which is not a CRAN package.
See <a href="https://www.r-inla.org/download-install">https://www.r-inla.org/download-install</a> for easy installation instructions.
</p>


<h3>Author(s)</h3>

<p>David Bolin <a href="mailto:davidbolin@gmail.com">davidbolin@gmail.com</a>
</p>


<h3>References</h3>

<p>Bolin et al. (2015) <em>Statistical prediction of global sea level
from global temperature</em>, Statistica Sinica, vol 25, pp 351-367.
</p>
<p>Bolin, D. and Lindgren, F. (2018), <em>Calculating Probabilistic Excursion Sets and Related Quantities Using excursions</em>, Journal of Statistical Software, vol 86, no 1, pp 1-20.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simconf">simconf</a></code>, <code><a href="#topic+simconf.mc">simconf.mc</a></code>, <code><a href="#topic+simconf.mixture">simconf.mixture</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (require.nowarnings("INLA")) {
  n &lt;- 10
  x &lt;- seq(0, 6, length.out = n)
  y &lt;- sin(x) + rnorm(n)
  mu &lt;- 1:n
  result &lt;- inla(y ~ 1 + f(mu, model = "rw2"),
    data = list(y = y, mu = mu), verbose = FALSE,
    control.compute = list(
      config = TRUE,
      return.marginals.predictor = TRUE
    ),
    num.threads = "1:1"
  )

  res &lt;- simconf.inla(result, name = "mu", alpha = 0.05, max.threads = 1)

  plot(result$summary.random$mu$mean, ylim = c(-2, 2))
  lines(res$a)
  lines(res$b)
  lines(res$a.marginal, col = "2")
  lines(res$b.marginal, col = "2")
}

## End(Not run)

</code></pre>

<hr>
<h2 id='simconf.mc'>Simultaneous confidence regions using Monte Carlo samples</h2><span id='topic+simconf.mc'></span>

<h3>Description</h3>

<p><code>simconf.mc</code> is used for calculating simultaneous confidence regions based
on Monte Carlo samples. The function returns upper and lower bounds <code class="reqn">a</code> and
<code class="reqn">b</code> such that <code class="reqn">P(a&lt;x&lt;b) = 1-\alpha</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simconf.mc(samples, alpha, ind, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simconf.mc_+3A_samples">samples</code></td>
<td>
<p>Matrix with model Monte Carlo samples. Each column contains a sample of the model.</p>
</td></tr>
<tr><td><code id="simconf.mc_+3A_alpha">alpha</code></td>
<td>
<p>Error probability for the region.</p>
</td></tr>
<tr><td><code id="simconf.mc_+3A_ind">ind</code></td>
<td>
<p>Indices of the nodes that should be analyzed (optional).</p>
</td></tr>
<tr><td><code id="simconf.mc_+3A_verbose">verbose</code></td>
<td>
<p>Set to TRUE for verbose mode (optional).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+simconf">simconf</a></code> for details.
</p>


<h3>Value</h3>

<p>An object of class &quot;excurobj&quot; with elements
</p>
<table>
<tr><td><code>a</code></td>
<td>
<p>The lower bound.</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>The upper bound.</p>
</td></tr>
<tr><td><code>a.marginal</code></td>
<td>
<p>The lower bound for pointwise confidence bands.</p>
</td></tr>
<tr><td><code>b.marginal</code></td>
<td>
<p>The upper bound for pointwise confidence bands.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Bolin <a href="mailto:davidbolin@gmail.com">davidbolin@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simconf">simconf</a></code>, <code><a href="#topic+simconf.inla">simconf.inla</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create mean and a tridiagonal precision matrix
n &lt;- 11
mu.x &lt;- seq(-5, 5, length = n)
Q.x &lt;- Matrix(toeplitz(c(1, -0.1, rep(0, n - 2))))
## Sample the model 100 times (increase for better estimate)
X &lt;- mu.x + solve(chol(Q.x), matrix(rnorm(n = n * 100), nrow = n, ncol = 100))
## calculate the confidence region
conf &lt;- simconf.mc(X, 0.2)
## Plot the region
plot(mu.x,
  type = "l", ylim = c(-10, 10),
  main = "Mean (black) and confidence region (red)"
)
lines(conf$a, col = 2)
lines(conf$b, col = 2)
</code></pre>

<hr>
<h2 id='simconf.mixture'>Simultaneous confidence regions for Gaussian mixture models</h2><span id='topic+simconf.mixture'></span>

<h3>Description</h3>

<p><code>simconf.mixture</code> is used for calculating simultaneous confidence regions
for Gaussian mixture models. The distribution for the process <code class="reqn">x</code> is assumed to be
</p>
<p style="text-align: center;"><code class="reqn">\pi(x) = \sum_{k=1}^K w_k N(\mu_k, Q_k^{-1}).</code>
</p>

<p>The function returns upper and lower bounds <code class="reqn">a</code> and <code class="reqn">b</code> such that
<code class="reqn">P(a&lt;x&lt;b) = 1-\alpha</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simconf.mixture(
  alpha,
  mu,
  Q,
  w,
  ind,
  n.iter = 10000,
  vars,
  verbose = 0,
  max.threads = 0,
  seed = NULL,
  mix.samp = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simconf.mixture_+3A_alpha">alpha</code></td>
<td>
<p>Error probability for the region.</p>
</td></tr>
<tr><td><code id="simconf.mixture_+3A_mu">mu</code></td>
<td>
<p>A list with the <code>k</code> expectation vectors <code class="reqn">\mu_k</code>.</p>
</td></tr>
<tr><td><code id="simconf.mixture_+3A_q">Q</code></td>
<td>
<p>A list with the <code>k</code> precision matrices <code class="reqn">Q_k</code>.</p>
</td></tr>
<tr><td><code id="simconf.mixture_+3A_w">w</code></td>
<td>
<p>A vector with the weights for each class in the mixture.</p>
</td></tr>
<tr><td><code id="simconf.mixture_+3A_ind">ind</code></td>
<td>
<p>Indices of the nodes that should be analyzed (optional).</p>
</td></tr>
<tr><td><code id="simconf.mixture_+3A_n.iter">n.iter</code></td>
<td>
<p>Number or iterations in the MC sampler that is used for
approximating probabilities. The default value is 10000.</p>
</td></tr>
<tr><td><code id="simconf.mixture_+3A_vars">vars</code></td>
<td>
<p>A list with precomputed marginal variances for each class (optional).</p>
</td></tr>
<tr><td><code id="simconf.mixture_+3A_verbose">verbose</code></td>
<td>
<p>Set to TRUE for verbose mode (optional).</p>
</td></tr>
<tr><td><code id="simconf.mixture_+3A_max.threads">max.threads</code></td>
<td>
<p>Decides the number of threads the program can use. Set to 0
for using the maximum number of threads allowed by the system (default).</p>
</td></tr>
<tr><td><code id="simconf.mixture_+3A_seed">seed</code></td>
<td>
<p>Random seed (optional).</p>
</td></tr>
<tr><td><code id="simconf.mixture_+3A_mix.samp">mix.samp</code></td>
<td>
<p>If TRUE, the MC integration is done by directly sampling the mixture,
otherwise sequential integration is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+simconf">simconf</a></code> for details.
</p>


<h3>Value</h3>

<p>An object of class &quot;excurobj&quot; with elements
</p>
<table>
<tr><td><code>a</code></td>
<td>
<p>The lower bound.</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>The upper bound.</p>
</td></tr>
<tr><td><code>a.marginal</code></td>
<td>
<p>The lower bound for pointwise confidence bands.</p>
</td></tr>
<tr><td><code>b.marginal</code></td>
<td>
<p>The upper bound for pointwise confidence bands.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Bolin <a href="mailto:davidbolin@gmail.com">davidbolin@gmail.com</a>
</p>


<h3>References</h3>

<p>Bolin et al. (2015) <em>Statistical prediction of global sea level
from global temperature</em>, Statistica Sinica, vol 25, pp 351-367.
</p>
<p>Bolin, D. and Lindgren, F. (2018), <em>Calculating Probabilistic Excursion Sets and Related Quantities Using excursions</em>, Journal of Statistical Software, vol 86, no 1, pp 1-20.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simconf">simconf</a></code>, <code><a href="#topic+simconf.inla">simconf.inla</a></code>, <code><a href="#topic+simconf.mc">simconf.mc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 11
K &lt;- 3
mu &lt;- Q &lt;- list()
for (k in 1:K) {
  mu[[k]] &lt;- k * 0.1 + seq(-5, 5, length = n)
  Q[[k]] &lt;- Matrix(toeplitz(c(1, -0.1, rep(0, n - 2))))
}
## calculate the confidence region
conf &lt;- simconf.mixture(0.05, mu, Q, w = rep(1 / 3, 3), max.threads = 2)

## Plot the region
plot(mu[[1]], type = "l")
lines(mu[[2]])
lines(mu[[3]])
lines(conf$a, col = 2)
lines(conf$b, col = 2)
</code></pre>

<hr>
<h2 id='submesh.grid'>Extract a part of a grid</h2><span id='topic+submesh.grid'></span>

<h3>Description</h3>

<p>Extracts a part of a grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>submesh.grid(z, grid = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="submesh.grid_+3A_z">z</code></td>
<td>
<p>A matrix with values indicating which nodes that should be
present in the submesh.</p>
</td></tr>
<tr><td><code id="submesh.grid_+3A_grid">grid</code></td>
<td>
<p>A list with locations and dimensions of the grid.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>inla.mesh</code> object.
</p>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (require("fmesher")) {
  nxy &lt;- 40
  x &lt;- seq(from = 0, to = 4, length.out = nxy)
  lattice &lt;- fm_lattice_2d(x = x, y = x)
  mesh &lt;- fm_rcdt_2d_inla(lattice = lattice, extend = FALSE, refine = FALSE)

  # extract a part of the mesh inside a circle
  xy.in &lt;- rowSums((mesh$loc[, 1:2] - 2)^2) &lt; 1
  submesh &lt;- submesh.grid(
    matrix(xy.in, nxy, nxy),
    list(loc = mesh$loc, dim = c(nxy, nxy))
  )
  plot(mesh$loc[, 1:2])
  lines(2 + cos(seq(0, 2 * pi, length.out = 100)), 2 + sin(seq(0, 2 * pi, length.out = 100)))
  plot(submesh, add = TRUE)
  points(mesh$loc[xy.in, 1:2], col = "2")
}

## End(Not run)

</code></pre>

<hr>
<h2 id='submesh.mesh'>Extract a part of a mesh</h2><span id='topic+submesh.mesh'></span>

<h3>Description</h3>

<p>Extracts a part of a mesh
</p>


<h3>Usage</h3>

<pre><code class='language-R'>submesh.mesh(z, mesh)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="submesh.mesh_+3A_z">z</code></td>
<td>
<p>A matrix with values indicating which nodes that should be
present in the submesh.</p>
</td></tr>
<tr><td><code id="submesh.mesh_+3A_mesh">mesh</code></td>
<td>
<p>An <code>fm_mesh_2d</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>fm_mesh_2d</code> object.
</p>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (require(fmesher)) {
  nxy &lt;- 30
  x &lt;- seq(from = 0, to = 4, length.out = nxy)
  lattice &lt;- fm_lattice_2d(x = x, y = x)
  mesh &lt;- fm_mesh_2d_inla(lattice = lattice, extend = FALSE, refine = FALSE)

  # extract a part of the mesh inside a circle
  xy.in &lt;- rowSums((mesh$loc[, 1:2] - 2)^2) &lt; 1
  submesh &lt;- excursions:::submesh.mesh(matrix(xy.in, nxy, nxy), mesh)
  plot(mesh$loc[, 1:2])
  lines(2 + cos(seq(0, 2 * pi, length.out = 100)), 2 + sin(seq(0, 2 * pi, length.out = 100)))
  plot(submesh, add = TRUE)
  points(mesh$loc[xy.in, 1:2], col = "2")
}

## End(Not run)

</code></pre>

<hr>
<h2 id='summary.excurobj'>Summarise excurobj objects</h2><span id='topic+summary.excurobj'></span><span id='topic+print.summary.excurobj'></span><span id='topic+print.excurobj'></span>

<h3>Description</h3>

<p>Summary method for class &quot;excurobj&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'excurobj'
summary(object, ...)

## S3 method for class 'summary.excurobj'
print(x, ...)

## S3 method for class 'excurobj'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.excurobj_+3A_object">object</code></td>
<td>
<p>an object of class &quot;excurobj&quot;, usually, a result of a call
to <code><a href="#topic+excursions">excursions</a></code>.</p>
</td></tr>
<tr><td><code id="summary.excurobj_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary.excurobj_+3A_x">x</code></td>
<td>
<p>an object of class &quot;summary.excurobj&quot;, usually, a result of a call
to <code><a href="#topic+summary.excurobj">summary.excurobj</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='tricontour'>Calculate contour curves on a triangulation</h2><span id='topic+tricontour'></span><span id='topic+tricontour.inla.mesh'></span><span id='topic+tricontour.matrix'></span><span id='topic+tricontour.list'></span><span id='topic+tricontourmap'></span><span id='topic+tricontourmap.inla.mesh'></span><span id='topic+tricontourmap.matrix'></span><span id='topic+tricontourmap.list'></span>

<h3>Description</h3>

<p>Calculates contour curves and/or regions between them,
for functions defined on a triangulation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tricontour(
  x,
  z,
  nlevels = 10,
  levels = pretty(range(z, na.rm = TRUE), nlevels),
  ...
)

## S3 method for class 'inla.mesh'
tricontour(
  x,
  z,
  nlevels = 10,
  levels = pretty(range(z, na.rm = TRUE), nlevels),
  ...
)

## S3 method for class 'matrix'
tricontour(
  x,
  z,
  nlevels = 10,
  levels = pretty(range(z, na.rm = TRUE), nlevels),
  loc,
  ...
)

## S3 method for class 'list'
tricontour(
  x,
  z,
  nlevels = 10,
  levels = pretty(range(z, na.rm = TRUE), nlevels),
  loc,
  type = c("+", "-"),
  tol = 1e-07,
  ...
)

tricontourmap(
  x,
  z,
  nlevels = 10,
  levels = pretty(range(z, na.rm = TRUE), nlevels),
  ...
)

## S3 method for class 'inla.mesh'
tricontourmap(
  x,
  z,
  nlevels = 10,
  levels = pretty(range(z, na.rm = TRUE), nlevels),
  ...
)

## S3 method for class 'matrix'
tricontourmap(
  x,
  z,
  nlevels = 10,
  levels = pretty(range(z, na.rm = TRUE), nlevels),
  loc,
  ...
)

## S3 method for class 'list'
tricontourmap(
  x,
  z,
  nlevels = 10,
  levels = pretty(range(z, na.rm = TRUE), nlevels),
  loc,
  type = c("+", "-"),
  tol = 1e-07,
  output = c("sp", "fm", "inla.mesh.segment"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tricontour_+3A_x">x</code></td>
<td>
<p>An object generated by a call to <code>inla.mesh.2d</code> or
<code>inla.mesh.create</code>, a triangle-vertex index matrix, or a list
of triangulation information, <code>list(loc, graph=list(tv))</code>.</p>
</td></tr>
<tr><td><code id="tricontour_+3A_z">z</code></td>
<td>
<p>A vector containing the values to be contoured
(<code>NA</code>s are allowed).</p>
</td></tr>
<tr><td><code id="tricontour_+3A_nlevels">nlevels</code></td>
<td>
<p>Number of contour levels desired, if and only if
<code>levels</code> is not supplied.</p>
</td></tr>
<tr><td><code id="tricontour_+3A_levels">levels</code></td>
<td>
<p>Numeric vector of levels at which to calculate contour lines.</p>
</td></tr>
<tr><td><code id="tricontour_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the other methods.</p>
</td></tr>
<tr><td><code id="tricontour_+3A_loc">loc</code></td>
<td>
<p>coordinate matrix, to be supplied when <code>x</code> is given as a
triangle-vertex index matrix only.</p>
</td></tr>
<tr><td><code id="tricontour_+3A_type">type</code></td>
<td>
<p><code>"+"</code> or <code>"-"</code>, indicating positive or negative
association. For <code>+</code>, the generated contours enclose regions
where <code class="reqn">u_1 \leq z &lt; u_2</code>, for <code>-</code> the regions fulfil <code class="reqn">u_1
  &lt; z \leq u_2</code>.</p>
</td></tr>
<tr><td><code id="tricontour_+3A_tol">tol</code></td>
<td>
<p>tolerance for determining if the value at a vertex lies on a level.</p>
</td></tr>
<tr><td><code id="tricontour_+3A_output">output</code></td>
<td>
<p>The format of the generated output.  Implemented options
are <code>"sp"</code> (default) and <code>"fm"</code> (and deprecated <code>"inla.mesh.segment"</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>tricontour</code>, a list with some of the fields that
<code>inla.mesh.segment</code> objects have:
</p>
<table>
<tr><td><code>loc</code></td>
<td>
<p>A coordinate matrix</p>
</td></tr>
<tr><td><code>idx</code></td>
<td>
<p>Contour segment indices, as a 2-column matrix, each row
indexing a single segment</p>
</td></tr>
<tr><td><code>grp</code></td>
<td>
<p>A vector of group labels.  Each segment has a label, in
<code>1,...,nlevels*2+1</code>, where even labels indicate interior
on-level contour segments, and odd labels indicate boundary segments
between levels.</p>
</td></tr>
</table>
<p>For <code>tricontourmap</code>, a list:
</p>
<table>
<tr><td><code>contour</code></td>
<td>
<p>A list of <code>sp</code> or <code>inla.mesh.segment</code> objects
defining countour curves (level sets)</p>
</td></tr>
<tr><td><code>map</code></td>
<td>
<p>A list of <code>sp</code> or <code>inla.mesh.segment</code> objects
enclosing regions between level sets</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (require("fmesher")) {
  ## Generate mesh and SPDE model
  n.lattice &lt;- 20 # increase for more interesting, but slower, examples
  x &lt;- seq(from = 0, to = 10, length.out = n.lattice)
  lattice &lt;- fm_lattice_2d(x = x, y = x)
  mesh &lt;- fm_rcdt_2d_inla(lattice = lattice, extend = FALSE, refine = FALSE)

  ## Generate an artificial sample
  sigma2.e &lt;- 0.1
  n.obs &lt;- 1000
  obs.loc &lt;- cbind(
    runif(n.obs) * diff(range(x)) + min(x),
    runif(n.obs) * diff(range(x)) + min(x)
  )
  Q &lt;- fm_matern_precision(mesh, alpha = 2, rho = 3, sigma = 1)
  x &lt;- fm_sample(n = 1, Q = Q)
  A &lt;- fm_basis(mesh, loc = obs.loc)
  Y &lt;- as.vector(A %*% x + rnorm(n.obs) * sqrt(sigma2.e))

  ## Calculate posterior
  Q.post &lt;- (Q + (t(A) %*% A) / sigma2.e)
  mu.post &lt;- as.vector(solve(Q.post, (t(A) %*% Y) / sigma2.e))

  ## Calculate continuous contours
  tric &lt;- tricontour(mesh,
    z = mu.post,
    levels = as.vector(quantile(x, c(0.25, 0.75)))
  )

  ## Discrete domain contours
  map &lt;- contourmap(
    n.levels = 2, mu = mu.post, Q = Q.post,
    alpha = 0.1, compute = list(F = FALSE), max.threads = 1
  )

  ## Calculate continuous contour map
  setsc &lt;- tricontourmap(mesh,
    z = mu.post,
    levels = as.vector(quantile(x, c(0.25, 0.75)))
  )

  ## Plot the results
  reo &lt;- mesh$idx$lattice
  idx.setsc &lt;- setdiff(names(setsc$map), "-1")
  cols2 &lt;- contourmap.colors(map,
    col = heat.colors(100, 0.5, rev = TRUE),
    credible.col = grey(0.5, 0)
  )
  names(cols2) &lt;- as.character(-1:2)

  par(mfrow = c(1, 2))
  image(matrix(mu.post[reo], n.lattice, n.lattice),
    main = "mean", axes = FALSE, asp = 1
  )
  plot(setsc$map[idx.setsc], col = cols2[idx.setsc])
  par(mfrow = c(1, 1))
}

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
