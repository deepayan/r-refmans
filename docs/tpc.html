<!DOCTYPE html><html><head><title>Help for package tpc</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tpc}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#dat_cohort'><p>Simulated Cohort Data</p></a></li>
<li><a href='#dat_cohort_dis'><p>Simulated Cohort Data - discretized</p></a></li>
<li><a href='#dat_cohort_mis'><p>Simulated Cohort Data - with missing values</p></a></li>
<li><a href='#dat_sim'><p>Simulated Data with a Partial Ordering</p></a></li>
<li><a href='#MeekRules'><p>Last Step of tPC Algorithm: Apply Meek's rules</p></a></li>
<li><a href='#tpc'><p>PC Algorithm Accounting for a Partial Node Ordering</p></a></li>
<li><a href='#tpc-package'><p>Tiered PC Algorithm</p></a></li>
<li><a href='#tpc.cons.intern'><p>Utility for Conservative and Majority Rule in tpc</p></a></li>
<li><a href='#true_cohort'><p>Cohort Data Structure</p></a></li>
<li><a href='#true_sim'><p>A DAG with a Partial Ordering</p></a></li>
<li><a href='#tskeleton'><p>Estimate the Skeleton of a DAG while Accounting for a Partial Ordering</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tiered PC Algorithm</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ronja Foraita &lt;foraita@leibniz-bips.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Constraint-based causal discovery using the PC algorithm while
    accounting for a partial node ordering, for example a partial temporal ordering
    when the data were collected in different waves of a cohort study.
    Andrews RM, Foraita R, Didelez V, Witte J (2021) &lt;<a href="https://arxiv.org/abs/2108.13395">arXiv:2108.13395</a>&gt;  
    provide a guide how to use tpc to analyse cohort data.</td>
</tr>
<tr>
<td>Depends:</td>
<td>pcalg, R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>graph, graphics, methods, parallel, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>Rgraphviz, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/bips-hb/tpc">https://github.com/bips-hb/tpc</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/bips-hb/tpc/issues">https://github.com/bips-hb/tpc/issues</a></td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-02-18 14:37:32 UTC; foraita</td>
</tr>
<tr>
<td>Author:</td>
<td>Janine Witte [aut],
  Ronja Foraita <a href="https://orcid.org/0000-0003-2216-6653"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, ctb],
  DFG [fnd]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-02-20 11:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='dat_cohort'>Simulated Cohort Data</h2><span id='topic+dat_cohort'></span>

<h3>Description</h3>

<p>Simulated data based on 'true_sim' of a European child-and-youth cohort study with three waves
<code>(t0, t1 and t2)</code>. See Andrews et al. (2021) &lt;https://arxiv.org/abs/2108.13395&gt;
for more information on how the data were generated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dat_cohort
</code></pre>


<h3>Format</h3>

<p>A data frame with 5000 observations and 34 variables (10 variables were
measured at three time points each, denoted as &quot;_t0&quot;, &quot;_t1&quot; and &quot;_t2&quot;).
</p>

<dl>
<dt>sex</dt><dd><p>Sex. Factor variable with levels &quot;male&quot; and &quot;female&quot;.</p>
</dd>
<dt>country</dt><dd><p>Country of residence. Factor variable with levels &quot;ITA&quot;, &quot;EST&quot;, &quot;CYP&quot;,
&quot;BEL&quot;, &quot;SWE&quot;, &quot;GER&quot;, &quot;HUN&quot; and &quot;ESP&quot;.</p>
</dd>
<dt>fto</dt><dd><p>Genotype of one SNP located in the FTO gene. Factor variable with levels
&quot;TT&quot;, &quot;AT&quot;, &quot;AA&quot;.</p>
</dd>
<dt>birth_weight</dt><dd><p>Birth weight in grams (numeric).</p>
</dd>
<dt>age_t0</dt><dd><p>Age in years at survey 't0' (numeric).</p>
</dd>
<dt>age_t1</dt><dd><p>Age in years at survey 't1' (numeric).</p>
</dd>
<dt>age_t2</dt><dd><p>Age in years at survey 't2' (numeric).</p>
</dd>
<dt>bmi_t0</dt><dd><p>Body mass index z-score adjusted for sex and age at survey 't0' (numeric).</p>
</dd>
<dt>bmi_t1</dt><dd><p>Body mass index z-score adjusted for sex and age at survey 't1' (numeric).</p>
</dd>
<dt>bmi_t2</dt><dd><p>Body mass index z-score adjusted for sex and age at survey 't2' (numeric).</p>
</dd>
<dt>bodyfat_t0</dt><dd><p>Per cent body fat measured at survey 't0' (numeric).</p>
</dd>
<dt>bodyfat_t1</dt><dd><p>Per cent body fat measured at survey 't1' (numeric).</p>
</dd>
<dt>bodyfat_t2</dt><dd><p>Per cent body fat measured at survey 't2' (numeric).</p>
</dd>
<dt>education_t0</dt><dd><p>Educational level at survey 't0'. Factor variable with levels &quot;low education&quot;,
&quot;medium education&quot; and &quot;high education&quot;.</p>
</dd>
<dt>education_t1</dt><dd><p>Educational level at survey 't1'. Factor variable with levels &quot;low education&quot;,
&quot;medium education&quot; and &quot;high education&quot;.</p>
</dd>
<dt>education_t2</dt><dd><p>Educational level at survey 't2'. Factor variable with levels &quot;low education&quot;,
&quot;medium education&quot; and &quot;high education&quot;.</p>
</dd>
<dt>fiber_t0</dt><dd><p>Fiber intake in log(mg/kcal) at survey 't0' (numeric).</p>
</dd>
<dt>fiber_t1</dt><dd><p>Fiber intake in log(mg/kcal) at survey 't1' (numeric).</p>
</dd>
<dt>fiber_t2</dt><dd><p>Fiber intake in log(mg/kcal) at survey 't2' (numeric).</p>
</dd>
<dt>media_devices_t0</dt><dd><p>Number of audiovisual media in the child's bedroom at survey 't0' (numeric).</p>
</dd>
<dt>media_devices_t1</dt><dd><p>Number of audiovisual media in the child's bedroom at survey 't1' (numeric).</p>
</dd>
<dt>media_devices_t2</dt><dd><p>Number of audiovisual media in the child's bedroom at survey 't2' (numeric).</p>
</dd>
<dt>media_time_t0</dt><dd><p>Use of audiovisual media in log(h/week+1) at survey 't0' (numeric)</p>
</dd>
<dt>media_time_t1</dt><dd><p>Use of audiovisual media in log(h/week+1) at survey 't1' (numeric)</p>
</dd>
<dt>media_time_t2</dt><dd><p>Use of audiovisual media in log(h/week+1) at survey 't2' (numeric)</p>
</dd>
<dt>mvpa_t0</dt><dd><p>Moderate to vigorous physical activity in sqrt(min/day) at survey 't0' (numeric).</p>
</dd>
<dt>mvpa_t1</dt><dd><p>Moderate to vigorous physical activity in sqrt(min/day) at survey 't1' (numeric).</p>
</dd>
<dt>mvpa_t2</dt><dd><p>Moderate to vigorous physical activity in sqrt(min/day) at survey 't2' (numeric).</p>
</dd>
<dt>sugar_t0</dt><dd><p>Square root of sugar intake score at survey 't0' (numeric).</p>
</dd>
<dt>sugar_t1</dt><dd><p>Square root of sugar intake score at survey 't1' (numeric).</p>
</dd>
<dt>sugar_t2</dt><dd><p>Square root of sugar intake score at survey 't2' (numeric).</p>
</dd>
<dt>wellbeing_t0</dt><dd><p>Box-Cox-transformed well-being score at survey 't0' (numeric).</p>
</dd>
<dt>wellbeing_t1</dt><dd><p>Box-Cox-transformed well-being score at survey 't1' (numeric).</p>
</dd>
<dt>wellbeing_t2</dt><dd><p>Box-Cox-transformed well-being score at survey 't2' (numeric).</p>
</dd>
</dl>



<h3>References</h3>

<p>Andrews RM, Foraita R, Witte J (2021). A practical guide to causal discovery
with cohort data. &lt;https://doi.org/10.48550/arXiv.2108.13395&gt;
</p>


<h3>See Also</h3>

<p>[tpc::dat_cohort_dis()], [tpc::dat_cohort_mis()]
</p>

<hr>
<h2 id='dat_cohort_dis'>Simulated Cohort Data - discretized</h2><span id='topic+dat_cohort_dis'></span>

<h3>Description</h3>

<p>Data from <code><a href="#topic+dat_cohort">dat_cohort</a></code> for which all continuous variables have been
categorized into three categories.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dat_cohort_dis
</code></pre>


<h3>Format</h3>

<p>A data frame with 5000 observations and 34 variables (10 variables were
measured at three time points each, denoted as &quot;_t0&quot;, &quot;_t1&quot; and &quot;_t2&quot;).
</p>

<dl>
<dt>sex</dt><dd><p>Sex. Factor variable with levels &quot;male&quot; and &quot;female&quot;.</p>
</dd>
<dt>country</dt><dd><p>Country of residence. Factor variable with levels &quot;ITA&quot;, &quot;EST&quot;, &quot;CYP&quot;,
&quot;BEL&quot;, &quot;SWE&quot;, &quot;GER&quot;, &quot;HUN&quot; and &quot;ESP&quot;.</p>
</dd>
<dt>fto</dt><dd><p>Genotype of one SNP located in the FTO gene. Factor variable with levels
&quot;TT&quot;, &quot;AT&quot;, &quot;AA&quot;.</p>
</dd>
<dt>birth_weight</dt><dd><p>Birth weight in grams (numeric).</p>
</dd>
<dt>age_t0</dt><dd><p>Age in years at survey 't0' (numeric).</p>
</dd>
<dt>age_t1</dt><dd><p>Age in years at survey 't1' (numeric).</p>
</dd>
<dt>age_t2</dt><dd><p>Age in years at survey 't2' (numeric).</p>
</dd>
<dt>bmi_t0</dt><dd><p>Body mass index z-score adjusted for sex and age at survey 't0' (numeric).</p>
</dd>
<dt>bmi_t1</dt><dd><p>Body mass index z-score adjusted for sex and age at survey 't1' (numeric).</p>
</dd>
<dt>bmi_t2</dt><dd><p>Body mass index z-score adjusted for sex and age at survey 't2' (numeric).</p>
</dd>
<dt>bodyfat_t0</dt><dd><p>Per cent body fat measured at survey 't0' (numeric).</p>
</dd>
<dt>bodyfat_t1</dt><dd><p>Per cent body fat measured at survey 't1' (numeric).</p>
</dd>
<dt>bodyfat_t2</dt><dd><p>Per cent body fat measured at survey 't2' (numeric).</p>
</dd>
<dt>education_t0</dt><dd><p>Educational level at survey 't0'. Factor variable with levels &quot;low education&quot;,
&quot;medium education&quot; and &quot;high education&quot;.</p>
</dd>
<dt>education_t1</dt><dd><p>Educational level at survey 't1'. Factor variable with levels &quot;low education&quot;,
&quot;medium education&quot; and &quot;high education&quot;.</p>
</dd>
<dt>education_t2</dt><dd><p>Educational level at survey 't2'. Factor variable with levels &quot;low education&quot;,
&quot;medium education&quot; and &quot;high education&quot;.</p>
</dd>
<dt>fiber_t0</dt><dd><p>Fiber intake in log(mg/kcal) at survey 't0' (numeric).</p>
</dd>
<dt>fiber_t1</dt><dd><p>Fiber intake in log(mg/kcal) at survey 't1' (numeric).</p>
</dd>
<dt>fiber_t2</dt><dd><p>Fiber intake in log(mg/kcal) at survey 't2' (numeric).</p>
</dd>
<dt>media_devices_t0</dt><dd><p>Number of audiovisual media in the child's bedroom at survey 't0' (numeric).</p>
</dd>
<dt>media_devices_t1</dt><dd><p>Number of audiovisual media in the child's bedroom at survey 't1' (numeric).</p>
</dd>
<dt>media_devices_t2</dt><dd><p>Number of audiovisual media in the child's bedroom at survey 't2' (numeric).</p>
</dd>
<dt>media_time_t0</dt><dd><p>Use of audiovisual media in log(h/week+1) at survey 't0' (numeric)</p>
</dd>
<dt>media_time_t1</dt><dd><p>Use of audiovisual media in log(h/week+1) at survey 't1' (numeric)</p>
</dd>
<dt>media_time_t2</dt><dd><p>Use of audiovisual media in log(h/week+1) at survey 't2' (numeric)</p>
</dd>
<dt>mvpa_t0</dt><dd><p>Moderate to vigorous physical activity in sqrt(min/day) at survey 't0' (numeric).</p>
</dd>
<dt>mvpa_t1</dt><dd><p>Moderate to vigorous physical activity in sqrt(min/day) at survey 't1' (numeric).</p>
</dd>
<dt>mvpa_t2</dt><dd><p>Moderate to vigorous physical activity in sqrt(min/day) at survey 't2' (numeric).</p>
</dd>
<dt>sugar_t0</dt><dd><p>Square root of sugar intake score at survey 't0' (numeric).</p>
</dd>
<dt>sugar_t1</dt><dd><p>Square root of sugar intake score at survey 't1' (numeric).</p>
</dd>
<dt>sugar_t2</dt><dd><p>Square root of sugar intake score at survey 't2' (numeric).</p>
</dd>
<dt>wellbeing_t0</dt><dd><p>Box-Cox-transformed well-being score at survey 't0' (numeric).</p>
</dd>
<dt>wellbeing_t1</dt><dd><p>Box-Cox-transformed well-being score at survey 't1' (numeric).</p>
</dd>
<dt>wellbeing_t2</dt><dd><p>Box-Cox-transformed well-being score at survey 't2' (numeric).</p>
</dd>
</dl>



<h3>References</h3>

<p>Andrews RM, Foraita R, Witte J (2021). A practical guide to causal discovery
with cohort data. &lt;https://doi.org/10.48550/arXiv.2108.13395&gt;
</p>


<h3>See Also</h3>

<p>[tpc::dat_cohort()], [tpc::dat_cohort_mis()]
</p>

<hr>
<h2 id='dat_cohort_mis'>Simulated Cohort Data - with missing values</h2><span id='topic+dat_cohort_mis'></span>

<h3>Description</h3>

<p>Data from <code><a href="#topic+dat_cohort">dat_cohort</a></code> with missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dat_cohort_mis
</code></pre>


<h3>Format</h3>

<p>A data frame with 5000 observations and 34 variables (10 variables were
measured at three time points each, denoted as &quot;_t0&quot;, &quot;_t1&quot; and &quot;_t2&quot;).
</p>

<dl>
<dt>sex</dt><dd><p>Sex. Factor variable with levels &quot;male&quot; and &quot;female&quot;.</p>
</dd>
<dt>country</dt><dd><p>Country of residence. Factor variable with levels &quot;ITA&quot;, &quot;EST&quot;, &quot;CYP&quot;,
&quot;BEL&quot;, &quot;SWE&quot;, &quot;GER&quot;, &quot;HUN&quot; and &quot;ESP&quot;.</p>
</dd>
<dt>fto</dt><dd><p>Genotype of one SNP located in the FTO gene. Ordinal variable with levels
&quot;TT&quot;, &quot;AT&quot;, &quot;AA&quot;.</p>
</dd>
<dt>birth_weight</dt><dd><p>Birth weight in grams (numeric).</p>
</dd>
<dt>age_t0</dt><dd><p>Age in years at survey 't0' (numeric).</p>
</dd>
<dt>age_t1</dt><dd><p>Age in years at survey 't1' (numeric).</p>
</dd>
<dt>age_t2</dt><dd><p>Age in years at survey 't2' (numeric).</p>
</dd>
<dt>bmi_t0</dt><dd><p>Body mass index z-score adjusted for sex and age at survey 't0' (numeric).</p>
</dd>
<dt>bmi_t1</dt><dd><p>Body mass index z-score adjusted for sex and age at survey 't1' (numeric).</p>
</dd>
<dt>bmi_t2</dt><dd><p>Body mass index z-score adjusted for sex and age at survey 't2' (numeric).</p>
</dd>
<dt>bodyfat_t0</dt><dd><p>Per cent body fat measured at survey 't0' (numeric).</p>
</dd>
<dt>bodyfat_t1</dt><dd><p>Per cent body fat measured at survey 't1' (numeric).</p>
</dd>
<dt>bodyfat_t2</dt><dd><p>Per cent body fat measured at survey 't2' (numeric).</p>
</dd>
<dt>education_t0</dt><dd><p>Educational level at survey 't0'. Ordinal variable with levels &quot;low education&quot;,
&quot;medium education&quot; and &quot;high education&quot;.</p>
</dd>
<dt>education_t1</dt><dd><p>Educational level at survey 't1'. Ordinal variable with levels &quot;low education&quot;,
&quot;medium education&quot; and &quot;high education&quot;.</p>
</dd>
<dt>education_t2</dt><dd><p>Educational level at survey 't2'. Ordinal variable with levels &quot;low education&quot;,
&quot;medium education&quot; and &quot;high education&quot;.</p>
</dd>
<dt>fiber_t0</dt><dd><p>Fiber intake in log(mg/kcal) at survey 't0' (numeric).</p>
</dd>
<dt>fiber_t1</dt><dd><p>Fiber intake in log(mg/kcal) at survey 't1' (numeric).</p>
</dd>
<dt>fiber_t2</dt><dd><p>Fiber intake in log(mg/kcal) at survey 't2' (numeric).</p>
</dd>
<dt>media_devices_t0</dt><dd><p>Number of audiovisual media in the child's bedroom at survey 't0' (numeric).</p>
</dd>
<dt>media_devices_t1</dt><dd><p>Number of audiovisual media in the child's bedroom at survey 't1' (numeric).</p>
</dd>
<dt>media_devices_t2</dt><dd><p>Number of audiovisual media in the child's bedroom at survey 't2' (numeric).</p>
</dd>
<dt>media_time_t0</dt><dd><p>Use of audiovisual media in log(h/week+1) at survey 't0' (numeric)</p>
</dd>
<dt>media_time_t1</dt><dd><p>Use of audiovisual media in log(h/week+1) at survey 't1' (numeric)</p>
</dd>
<dt>media_time_t2</dt><dd><p>Use of audiovisual media in log(h/week+1) at survey 't2' (numeric)</p>
</dd>
<dt>mvpa_t0</dt><dd><p>Moderate to vigorous physical activity in sqrt(min/day) at survey 't0' (numeric).</p>
</dd>
<dt>mvpa_t1</dt><dd><p>Moderate to vigorous physical activity in sqrt(min/day) at survey 't1' (numeric).</p>
</dd>
<dt>mvpa_t2</dt><dd><p>Moderate to vigorous physical activity in sqrt(min/day) at survey 't2' (numeric).</p>
</dd>
<dt>sugar_t0</dt><dd><p>Square root of sugar intake score at survey 't0' (numeric).</p>
</dd>
<dt>sugar_t1</dt><dd><p>Square root of sugar intake score at survey 't1' (numeric).</p>
</dd>
<dt>sugar_t2</dt><dd><p>Square root of sugar intake score at survey 't2' (numeric).</p>
</dd>
<dt>wellbeing_t0</dt><dd><p>Box-Cox-transformed well-being score at survey 't0' (numeric).</p>
</dd>
<dt>wellbeing_t1</dt><dd><p>Box-Cox-transformed well-being score at survey 't1' (numeric).</p>
</dd>
<dt>wellbeing_t2</dt><dd><p>Box-Cox-transformed well-being score at survey 't2' (numeric).</p>
</dd>
</dl>



<h3>References</h3>

<p>Andrews RM, Foraita R, Witte J (2021). A practical guide to causal discovery
with cohort data. &lt;https://doi.org/10.48550/arXiv.2108.13395&gt;
</p>


<h3>See Also</h3>

<p>[tpc::dat_cohort()], [tpc::dat_cohort_dis()]
</p>

<hr>
<h2 id='dat_sim'>Simulated Data with a Partial Ordering</h2><span id='topic+dat_sim'></span>

<h3>Description</h3>

<p>A simple graph and corresponding dataset used in the examples illustrating <code><a href="#topic+tpc">tpc</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dat_sim
</code></pre>


<h3>Format</h3>

<p>A data frame with 1000 observations and 9 numerical variables simulated by
drawing from a multivariate distribution according to the DAG <code>true_sim</code>.
</p>

<dl>
<dt>A1</dt><dd><p>numeric</p>
</dd>
<dt>B1</dt><dd><p>numeric</p>
</dd>
<dt>C1</dt><dd><p>numeric</p>
</dd>
<dt>A2</dt><dd><p>numeric</p>
</dd>
<dt>B2</dt><dd><p>numeric</p>
</dd>
<dt>C2</dt><dd><p>numeric</p>
</dd>
<dt>A3</dt><dd><p>numeric</p>
</dd>
<dt>B3</dt><dd><p>numeric</p>
</dd>
<dt>C3</dt><dd><p>numeric</p>
</dd>
</dl>


<hr>
<h2 id='MeekRules'>Last Step of tPC Algorithm: Apply Meek's rules</h2><span id='topic+MeekRules'></span>

<h3>Description</h3>

<p>This is a modified version of <code>pcalg::<a href="pcalg.html#topic+udag2pdag">udag2pdagRelaxed</a></code>.
It applies Meek's rules to the partially oriented graph obtained after orienting edges
between time points / tiers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MeekRules(
  gInput,
  verbose = FALSE,
  unfVect = NULL,
  solve.confl = FALSE,
  rules = rep(TRUE, 4)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MeekRules_+3A_ginput">gInput</code></td>
<td>
<p>'pcAlgo'-object containing skeleton and conditional indepedence information.</p>
</td></tr>
<tr><td><code id="MeekRules_+3A_verbose">verbose</code></td>
<td>
<p>FALSE: No output; TRUE: Details</p>
</td></tr>
<tr><td><code id="MeekRules_+3A_unfvect">unfVect</code></td>
<td>
<p>Vector containing numbers that encode ambiguous triples (as returned by
[tpc_cons_intern()]. This is needed in the conservative and majority rule PC algorithms.</p>
</td></tr>
<tr><td><code id="MeekRules_+3A_solve.confl">solve.confl</code></td>
<td>
<p>If <code>TRUE</code>, the orientation rules work with lists for candidate
sets and allow bi-directed edges to resolve conflicting edge orientations. Note that
therefore the resulting object is order-independent but might not be a PDAG because
bi-directed edges can be present.</p>
</td></tr>
<tr><td><code id="MeekRules_+3A_rules">rules</code></td>
<td>
<p>A vector of length 4 containing <code>TRUE</code> or <code>FALSE</code> for each rule.
<code>TRUE</code> in position i means that rule i (Ri) will be applied. By default, all rules are used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>unfVect = NULL</code> (no ambiguous triples), the four orientation
rules are applied to each eligible structure until no more edges can be
oriented. Otherwise, unfVect contains the numbers of all ambiguous triples in
the graph as determined by [tpc_cons_intern()]. Then the orientation
rules take this information into account. For example, if <code>a -&gt; b - c</code> and <code>&lt;a,b,c&gt;</code>
is an unambigous triple and a non-v-structure, then rule 1 implies <code>b -&gt; c</code>. On
the other hand, if <code>a -&gt; b - c</code> but <code>&lt;a,b,c&gt;</code> is an ambiguous triple, then the edge
<code>b - c</code> is not oriented.
</p>
<p>If <code>solve.confl = FALSE</code>, earlier edge orientations are overwritten by
later ones.
</p>
<p>If <code>solv.confl = TRUE</code>, both the v-structures and the orientation rules
work with lists for the candidate edges and allow bi-directed edges if there are
conflicting orientations. For example, two v-structures <code>a -&gt; b &lt;- c</code> and
<code>b -&gt; c &lt;- d</code> then yield <code>a -&gt; b &lt;-&gt; c &lt;- d</code>. This option can be used to get an
order-independent version of the PC algorithm (see Colombo and Maathuis (2014)).
</p>
<p>We denote bi-directed edges, for example between two variables i and j, in the
adjacency matrix M of the graph as <code>M[i,j]=2</code> and <code>M[j,i]=2</code>. Such edges should be
interpreted as indications of conflicts in the algorithm, for example due to
errors in the conditional independence tests or violations of the faithfulness
assumption.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="pcalg.html#topic+pcAlgo-class">pcAlgo-class</a></code>.
</p>


<h3>Author(s)</h3>

<p>Original code by Markus Kalisch, modifications by Janine Witte.
</p>


<h3>References</h3>

<p>C. Meek (1995). Causal inference and causal explanation with
background knowledge. In: Proceedings of the Eleventh Conference on Uncertainty
in Artificial Intelligence (UAI-95), pp. 403-411. Morgan Kaufmann Publishers.
</p>
<p>D. Colombo and M.H. Maathuis (2014). Order-independent constraint-based causal
structure learning. Journal of Machine Learning Research 15:3741-3782.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dat_sim)
sk.fit &lt;- skeleton(suffStat = list(C = cor(dat_sim), n = nrow(dat_sim)),
             indepTest = gaussCItest, labels = names(dat_sim), alpha = 0.05)
MeekRules(sk.fit)

</code></pre>

<hr>
<h2 id='tpc'>PC Algorithm Accounting for a Partial Node Ordering</h2><span id='topic+tpc'></span>

<h3>Description</h3>

<p>Like [pcalg::pc()], but takes into account a user-specified partial
ordering of the nodes/variables. This has two effects:
1) The conditional independence between <code>x</code> and <code>y</code> given <code>S</code> is
ot tested if any variable in <code>S</code> lies in the future of both <code>x</code> and <code>y</code>;
2) edges cannot be oriented from a higher-order to a lower-order node. In addition,
the user may specify individual forbidden edges and context variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tpc(
  suffStat,
  indepTest,
  alpha,
  labels,
  p,
  skel.method = c("stable", "stable.parallel"),
  forbEdges = NULL,
  m.max = Inf,
  conservative = FALSE,
  maj.rule = TRUE,
  tiers = NULL,
  context.all = NULL,
  context.tier = NULL,
  verbose = FALSE,
  numCores = NULL,
  cl.type = "PSOCK",
  clusterexport = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tpc_+3A_suffstat">suffStat</code></td>
<td>
<p>A [base::list()] of sufficient statistics, containing all necessary
elements for the conditional independence decisions in the function [indepTest()].</p>
</td></tr>
<tr><td><code id="tpc_+3A_indeptest">indepTest</code></td>
<td>
<p>A function for testing conditional independence. It is internally
called as <code>indepTest(x,y,S,suffStat)</code>, and tests conditional independence of
<code>x</code> and <code>y</code> given <code>S</code>. Here, <code>x</code> and <code>y</code> are variables, and
<code>S</code> is a (possibly empty) vector of variables (all variables are denoted by their
(integer) column positions in the adjacency matrix). <code>suffStat</code> is a list,
see the argument above. The return value of <code>indepTest</code> is the p-value of the
test for conditional independence.</p>
</td></tr>
<tr><td><code id="tpc_+3A_alpha">alpha</code></td>
<td>
<p>significance level (number in <em>(0,1)</em> for the individual conditional
independence tests.</p>
</td></tr>
<tr><td><code id="tpc_+3A_labels">labels</code></td>
<td>
<p>(optional) character vector of variable (or &quot;node&quot;) names.
Typically preferred to specifying <code>p</code>.</p>
</td></tr>
<tr><td><code id="tpc_+3A_p">p</code></td>
<td>
<p>(optional) number of variables (or nodes). May be specified if <code>labels</code>
are not, in which case <code>labels</code> is set to <code>1:p</code>.</p>
</td></tr>
<tr><td><code id="tpc_+3A_skel.method">skel.method</code></td>
<td>
<p>Character string specifying method; the default, &quot;stable&quot; provides
an order-independent skeleton, see [tpc::tskeleton()].</p>
</td></tr>
<tr><td><code id="tpc_+3A_forbedges">forbEdges</code></td>
<td>
<p>A logical matrix of dimension p*p. If <code>[i,j]</code> is TRUE, then the
directed edge i-&gt;j is forbidden. If both <code>[i,j]</code> and <code>[j,i]</code> are TRUE, then any type of
edge between i and j is forbidden.</p>
</td></tr>
<tr><td><code id="tpc_+3A_m.max">m.max</code></td>
<td>
<p>Maximal size of the conditioning sets that are considered in the
conditional independence tests.</p>
</td></tr>
<tr><td><code id="tpc_+3A_conservative">conservative</code></td>
<td>
<p>Logical indicating if conservative PC should be used.
Defaults to FALSE. See [pcalg::pc()] for details.</p>
</td></tr>
<tr><td><code id="tpc_+3A_maj.rule">maj.rule</code></td>
<td>
<p>Logical indicating if the majority rule should be used. Defaults
to TRUE. See [pcalg::pc()] for details.</p>
</td></tr>
<tr><td><code id="tpc_+3A_tiers">tiers</code></td>
<td>
<p>Numeric vector specifying the tier / time point for each variable.
Must be of length 'p', if specified, or have the same length as 'labels', if specified.
A smaller number corresponds to an earlier tier / time point.</p>
</td></tr>
<tr><td><code id="tpc_+3A_context.all">context.all</code></td>
<td>
<p>Numeric or character vector. Specifies the positions or names
of global context variables. Global context variables have no incoming edges, i.e.
no parents, and are themselves parents of all non-context variables in the graph.</p>
</td></tr>
<tr><td><code id="tpc_+3A_context.tier">context.tier</code></td>
<td>
<p>Numeric or character vector. Specifies the positions or
names of tier-specific context variables. Tier-specific context variables have no
incoming edges, i.e. no parents, and are themselves parents of all non-context variables
in the same tier.</p>
</td></tr>
<tr><td><code id="tpc_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, detailed output is provided.</p>
</td></tr>
<tr><td><code id="tpc_+3A_numcores">numCores</code></td>
<td>
<p>The numbers of CPU cores to be used.</p>
</td></tr>
<tr><td><code id="tpc_+3A_cl.type">cl.type</code></td>
<td>
<p>The cluster type. Default value is <code>"PSOCK"</code>.
For High-performance clusters use <code>"MPI"</code>. See also <code>parallel::<a href="parallel.html#topic+makeCluster">makeCluster</a></code>.</p>
</td></tr>
<tr><td><code id="tpc_+3A_clusterexport">clusterexport</code></td>
<td>
<p>Character vector. Lists functions to be exported to nodes if numCores &gt; 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code>pcalg::<a href="pcalg.html#topic+pc">pc</a></code> for further information on the PC algorithm.
The PC algorithm is named after its developers Peter Spirtes and Clark Glymour
(Spirtes et al., 2000).
</p>
<p>Specifying a tier for each variable using the <code>tier</code> argument has the
following effects:
1) In the skeleton phase and v-structure learing phases,
conditional independence testing is restricted such that if x is in tier t(x)
and y is in t(y), only those variables are allowed in the conditioning set whose
tier is not larger than t(x).
2) Following the v-structure phase, all
edges that were found between two tiers are directed into the direction of the
higher-order tier. If context variables are specified using <code>context.all</code>
and/or <code>context.tier</code>, the corresponding orientations are added in this step.
</p>


<h3>Value</h3>

<p>An object of <code><a href="base.html#topic+class">class</a></code> &quot;<code>pcAlgo</code>&quot;
(see [pcalg::pcalgo] containing an estimate of the equivalence class of
the underlying DAG.
</p>


<h3>Author(s)</h3>

<p>Original code by Markus Kalisch, Martin Maechler, and Diego Colombo.
Modifications by Janine Witte (Kalisch et al., 2012).
</p>


<h3>References</h3>

<p>M. Kalisch, M. Maechler, D. Colombo, M.H. Maathuis and P. Buehlmann (2012).
Causal Inference Using Graphical Models with the R Package pcalg.
Journal of Statistical Software 47(11): 1&ndash;26.
</p>
<p>P. Spirtes, C. Glymour and R. Scheines (2000). Causation, Prediction,
and Search, 2nd edition. The MIT Press. https://philarchive.org/archive/SPICPA-2.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load simulated cohort data
data(dat_sim)
n &lt;- nrow(dat_sim)
lab &lt;- colnames(dat_sim)

# estimate skeleton without taking background information into account
tpc.fit &lt;- tpc(suffStat = list(C = cor(dat_sim), n = n),
               indepTest = gaussCItest, alpha = 0.01, labels = lab)
pc.fit &lt;- pcalg::pc(suffStat = list(C = cor(dat_sim), n = n),
                    indepTest = gaussCItest, alpha = 0.01, labels = lab,
                    maj.rule = TRUE, solve.conf = TRUE)
identical(pc.fit@graph, tpc.fit@graph) # TRUE
# estimate skeleton with temporal ordering as background information
tiers &lt;- rep(c(1,2,3), times=c(3,3,3))
tpc.fit2 &lt;- tpc(suffStat = list(C = cor(dat_sim), n = n),
                indepTest = gaussCItest, alpha = 0.01, labels = lab, tiers = tiers)

tpc.fit3 &lt;- tpc(suffStat = list(C = cor(dat_sim), n = n),
                indepTest = gaussCItest, alpha = 0.01, labels = lab, tiers = tiers,
                skel.method = "stable.parallel",
                numCores = 2, clusterexport = c("cor", "ecdf"))

if(requireNamespace("Rgraphviz", quietly = TRUE)){
 data("true_sim")
 oldpar &lt;- par(mfrow = c(1,3))
 plot(true_sim, main = "True DAG")
 plot(tpc.fit, main = "PC estimate")
 plot(tpc.fit2, main = "tPC estimate")
 par(oldpar)
 }

 # require that there is no edge between A1 and A1, and that any edge between A2 and B2
 # or A2 and C2 is directed away from A2
 forb &lt;- matrix(FALSE, nrow=9, ncol=9)
 rownames(forb) &lt;- colnames(forb) &lt;- lab
 forb["A1","A3"] &lt;- forb["A3","A1"] &lt;- TRUE
 forb["B2","A2"] &lt;- TRUE
 forb["C2","A2"] &lt;- TRUE

 tpc.fit3 &lt;- tpc(suffStat = list(C = cor(dat_sim), n = n),
                 indepTest = gaussCItest, alpha = 0.01,labels = lab,
                 forbEdges = forb, tiers = tiers)

 if (requireNamespace("Rgraphviz", quietly = TRUE)) {
 # compare estimated CPDAGs
   data("true_sim")
   oldpar &lt;- par(mfrow = c(1,2))
   plot(tpc.fit2, main = "old tPC estimate")
   plot(tpc.fit3, main = "new tPC estimate")
   par(oldpar)
 }
 # force edge from A1 to all other nodes measured at time 1
 # into the graph (note that the edge from A1 to A2 is then
 # forbidden)
 tpc.fit4 &lt;- tpc(suffStat = list(C = cor(dat_sim), n = n),
                 indepTest = gaussCItest, alpha = 0.01, labels = lab,
                 tiers = tiers, context.tier = "A1")

 if (requireNamespace("Rgraphviz", quietly = TRUE)) {
 # compare estimated CPDAGs
  data("true_sim")
  plot(tpc.fit4, main = "alternative tPC estimate")
 }

 # force edge from A1 to all other nodes into the graph
 tpc.fit5 &lt;- tpc(suffStat = list(C = cor(dat_sim), n = n),
                 indepTest = gaussCItest, alpha = 0.01, labels = lab,
                 tiers = tiers, context.all = "A1")

 if (requireNamespace("Rgraphviz", quietly = TRUE)) {
 # compare estimated CPDAGs
 data("true_sim")
 plot(tpc.fit5, main = "alternative tPC estimate")
 }

</code></pre>

<hr>
<h2 id='tpc-package'>Tiered PC Algorithm</h2><span id='topic+tpc-package'></span><span id='topic+_PACKAGE'></span>

<h3>Description</h3>

<p>Constraint-based causal discovery using the PC algorithm while accounting for a
partial node ordering, e.g. a partial temporal ordering when the data were
collected in different waves of a cohort study.
Andrews RM, Foraita R, Didelez V, Witte J (2021) &lt;arXiv:2108.13395&gt;
provide a guide how to use tpc to analyse cohort data.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Ronja Foraita <a href="mailto:foraita@leibniz-bips.de">foraita@leibniz-bips.de</a> (<a href="https://orcid.org/0000-0003-2216-6653">ORCID</a>) [contributor]
</p>
<p>Authors:
</p>

<ul>
<li><p> Janine Witte <a href="mailto:witte@leibniz-bips.de">witte@leibniz-bips.de</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> DFG [funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/bips-hb/tpc">https://github.com/bips-hb/tpc</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/bips-hb/tpc/issues">https://github.com/bips-hb/tpc/issues</a>
</p>
</li></ul>


<hr>
<h2 id='tpc.cons.intern'>Utility for Conservative and Majority Rule in tpc</h2><span id='topic+tpc.cons.intern'></span>

<h3>Description</h3>

<p>Like <code>pcalg::<a href="pcalg.html#topic+pc.cons.intern">pc.cons.intern</a></code>, but takes into account the
user-specified partial node/variable ordering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tpc.cons.intern(
  sk,
  suffStat,
  indepTest,
  alpha,
  version.unf = c(NA, NA),
  maj.rule = FALSE,
  forbEdges = NULL,
  tiers = NULL,
  context.all = NULL,
  context.tier = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tpc.cons.intern_+3A_sk">sk</code></td>
<td>
<p>A skeleton object as returned from <code>pcalg::<a href="pcalg.html#topic+skeleton">skeleton</a></code>.</p>
</td></tr>
<tr><td><code id="tpc.cons.intern_+3A_suffstat">suffStat</code></td>
<td>
<p>Sufficient statistic: List containing all relevant elements for
the conditional independence decisions.</p>
</td></tr>
<tr><td><code id="tpc.cons.intern_+3A_indeptest">indepTest</code></td>
<td>
<p>Pre-defined <code><a href="base.html#topic+function">function</a></code> for testing conditional
independence. The function is internally called as <code>indepTest(x,y,S,suffStat)</code>,
and tests conditional independence of <code>x</code> and <code>y</code> given <code>S</code>.
Here, <code>x</code> and <code>y</code> are variables, and <code>S</code> is a (possibly empty) vector of
variables (all variables are denoted by their (integer) column positions in the
adjacency matrix). The return value of <code>indepTest</code> is the p-value of the test for
conditional independence.</p>
</td></tr>
<tr><td><code id="tpc.cons.intern_+3A_alpha">alpha</code></td>
<td>
<p>Significance level for the individual conditional independence tests.</p>
</td></tr>
<tr><td><code id="tpc.cons.intern_+3A_version.unf">version.unf</code></td>
<td>
<p>Vector of length two. If <code>version.unf[2]==1</code>, the inititial
separating set found by the PC/FCI algorithm is added to the set of separating sets;
if <code>version.unf[2]==2</code>, it is not added. In the latter case, if the set of
separating sets is empty, the triple is marked as unambiguous if <code>version.unf[1]==1</code>,
and as ambiguous if <code>version.unf[1]==2</code>.</p>
</td></tr>
<tr><td><code id="tpc.cons.intern_+3A_maj.rule">maj.rule</code></td>
<td>
<p>Logical indicating if the triples are checked for ambiguity using the
majority rule idea, which is less strict than the standard conservative method.</p>
</td></tr>
<tr><td><code id="tpc.cons.intern_+3A_forbedges">forbEdges</code></td>
<td>
<p>A logical matrix of dimension <code>p*p</code>. If <code>[i,j]</code> is TRUE,
then the directed edge <code>i -&gt; j</code> is forbidden. If both <code>[i,j]</code> and <code>[j,i]</code>
are TRUE, then any type of edge between <code>i</code> and <code>j</code> is forbidden.</p>
</td></tr>
<tr><td><code id="tpc.cons.intern_+3A_tiers">tiers</code></td>
<td>
<p>Numeric vector specifying the tier / time point for each variable.
A smaller number corresponds to an earlier tier / time point.</p>
</td></tr>
<tr><td><code id="tpc.cons.intern_+3A_context.all">context.all</code></td>
<td>
<p>Numeric or character vector. Specifies the positions or names
of global context variables. Global context variables have no incoming edges,
i.e. no parents, and are themselves parents of all non-context variables in the graph.</p>
</td></tr>
<tr><td><code id="tpc.cons.intern_+3A_context.tier">context.tier</code></td>
<td>
<p>Numeric or character vector. Specifies the positions or names of
tier-specific context variables. Tier-specific context variables have no incoming edges,
i.e. no parents, and are themselves parents of all non-context variables in the same tier.</p>
</td></tr>
<tr><td><code id="tpc.cons.intern_+3A_verbose">verbose</code></td>
<td>
<p>Logical asking for detailed output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code>pcalg::<a href="pcalg.html#topic+pc.cons.intern">pc.cons.intern</a></code> for further information on the
majority and conservative approaches to learning v-structures.
</p>
<p>Specifying a tier for each variable using the <code>tier</code> argument has the
following effects:
</p>
<p>1) Only those triples <code>x-y-z</code> are considered as potential v-structures that
satisfy <code>t(y)=max(t(x),t(z))</code>. This allows for three constellations: either <code>y</code> is
in the same tier as <code>x</code> and both are later than <code>z</code>, or <code>y</code> is in the same tier as z
and both are later than <code>x</code>, or all three are in the same tier. Triples where <code>y</code> is
earlier than one or both of <code>x</code> and <code>z</code> need not be considered, as <code>y</code> being a
collider would be against the partial ordering. Triples where <code>y</code> is later than
both <code>x</code> and <code>z</code> will be oriented later in the pc algorithm and are left out here to
minimize the number of conditional independence tests.
</p>
<p>2) Conditional independence testing is restricted such that if <code>x</code> is in tier <code>t(x)</code>
and <code>y</code> is in <code>t(y)</code>, only those variables are allowed in the conditioning set whose
tier is not larger than <code>t(x)</code>.
</p>
<p>Context variables specified via <code>context.all</code> or <code>context.tier</code> are
not considered as candidate colliders or candidate parents of colliders.
</p>


<h3>Value</h3>


<dl>
<dt>unfTripl</dt><dd><p>numeric vector of triples coded as numbers (via <code>pcalg::triple2numb</code>)
that were marked as ambiguous.</p>
</dd>
<dt>sk</dt><dd><p>The updated skeleton-object (separating sets might have been updated).</p>
</dd></dl>



<h3>Author(s)</h3>

<p>Original code by Markus Kalisch and Diego Colombo. Modifications by Janine Witte.
</p>

<hr>
<h2 id='true_cohort'>Cohort Data Structure</h2><span id='topic+true_cohort'></span>

<h3>Description</h3>

<p>A DAG from which the data 'data_cohort' was simulated from.
See Andrews et al. (2021) &lt;https://arxiv.org/abs/2108.13395&gt; for more information on
how the data were generated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>true_cohort
</code></pre>


<h3>Format</h3>

<p>A DAG (graphNEL object) with 34 nodes and 128 edges.
</p>


<h3>References</h3>

<p>Andrews RM, Foraita R, Witte J (2021). A practical guide to causal discovery
with cohort data. &lt;https://doi.org/10.48550/arXiv.2108.13395&gt;
</p>


<h3>See Also</h3>

<p>See [graph::graphNEL()] for the class 'graphNEL'.
</p>

<hr>
<h2 id='true_sim'>A DAG with a Partial Ordering</h2><span id='topic+true_sim'></span>

<h3>Description</h3>

<p>An example DAG from which the data 'data_sim' was simulated from.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>true_sim
</code></pre>


<h3>Format</h3>

<p>A DAG (graphNEL object) with 9 nodes and 7 edges.
</p>


<h3>See Also</h3>

<p>See [graph::graphNEL()] for the class 'graphNEL'.
</p>

<hr>
<h2 id='tskeleton'>Estimate the Skeleton of a DAG while Accounting for a Partial Ordering</h2><span id='topic+tskeleton'></span>

<h3>Description</h3>

<p>Like <code>pcalg::<a href="pcalg.html#topic+skeleton">skeleton</a></code>, but takes a user-specified partial node
ordering into account. The conditional independence
between <code>x</code> and <code>y</code> given <code>S</code> is not tested if any variable in
<code>S</code> lies in the future of both <code>x</code> and <code>y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tskeleton(
  suffStat,
  indepTest,
  alpha,
  labels,
  p,
  method = c("stable", "original"),
  m.max = Inf,
  fixedGaps = NULL,
  fixedEdges = NULL,
  NAdelete = TRUE,
  tiers = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tskeleton_+3A_suffstat">suffStat</code></td>
<td>
<p>A list of sufficient statistics, containing all necessary elements for
the conditional independence decisions in the function <code>indepTest</code>.</p>
</td></tr>
<tr><td><code id="tskeleton_+3A_indeptest">indepTest</code></td>
<td>
<p>Predefined <code><a href="base.html#topic+function">function</a></code> for testing conditional
independence. It is internally called as <code>indepTest(x,y,S,suffStat)</code>, and tests
conditional independence of <code>x</code> and <code>y</code> given <code>S</code>. Here, <code>x</code> and
<code>y</code> are variables, and <code>S</code> is a (possibly empty) vector of variables (all
variables are denoted by their (integer) column positions in the adjacency matrix).
<code>suffStat</code> is a list, see the argument above. The return value of <code>indepTest</code>
is the p-value of the test for conditional independence.</p>
</td></tr>
<tr><td><code id="tskeleton_+3A_alpha">alpha</code></td>
<td>
<p>Significance level (number in <em>(0,1)</em> for the individual conditional
independence tests.</p>
</td></tr>
<tr><td><code id="tskeleton_+3A_labels">labels</code></td>
<td>
<p>(optional) character vector of variable (or &quot;node&quot;) names.
Typically preferred to specifying <code>p</code>.</p>
</td></tr>
<tr><td><code id="tskeleton_+3A_p">p</code></td>
<td>
<p>(optional) number of variables (or nodes). May be specified if <code>labels</code>
are not, in which case <code>labels</code> is set to <code>1:p</code>.</p>
</td></tr>
<tr><td><code id="tskeleton_+3A_method">method</code></td>
<td>
<p>Character string specifying method; the default, &quot;stable&quot; provides an
<em>order-independent</em> skeleton, see 'Details' below.</p>
</td></tr>
<tr><td><code id="tskeleton_+3A_m.max">m.max</code></td>
<td>
<p>Maximal size of the conditioning sets that are considered in the
conditional independence tests.</p>
</td></tr>
<tr><td><code id="tskeleton_+3A_fixedgaps">fixedGaps</code></td>
<td>
<p>logical <em>symmetric</em> matrix of dimension <code>p*p</code>. If entry
<code>[i,j]</code> is true, the edge <em>i-j</em> is removed before starting the
algorithm. Therefore, this edge is guaranteed to be <em>absent</em> in the
resulting graph.</p>
</td></tr>
<tr><td><code id="tskeleton_+3A_fixededges">fixedEdges</code></td>
<td>
<p>a logical <em>symmetric</em> matrix of dimension <code>p*p</code>. If entry
<code>[i,j]</code> is true, the edge <em>i-j</em> is never considered for removal.
Therefore, this edge is guaranteed to be <em>present</em> in the resulting graph.</p>
</td></tr>
<tr><td><code id="tskeleton_+3A_nadelete">NAdelete</code></td>
<td>
<p>logical needed for the case <code>indepTest(*)</code> returns <code>NA</code>.
If it is true, the corresponding edge is deleted, otherwise not.</p>
</td></tr>
<tr><td><code id="tskeleton_+3A_tiers">tiers</code></td>
<td>
<p>Numeric vector specifying the tier / time point for each variable.
Must be of length 'p', if specified, or have the same length as 'labels', if specified.
A smaller number corresponds to an earlier tier / time point. Conditional independence
testing is restricted such that if <code>x</code> is in tier <code>t(x)</code> and <code>y</code> is
in <code>t(y)</code>, only those variables are allowed in the conditioning set whose tier is
not larger than <code>t(x)</code>.</p>
</td></tr>
<tr><td><code id="tskeleton_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, detailed output is provided.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code>pcalg::<a href="pcalg.html#topic+skeleton">skeleton</a></code> for further information on the
skeleton algorithm.
</p>


<h3>Value</h3>

<p>An object of class &quot;pcAlgo&quot; (see <code>pcalg::<a href="pcalg.html#topic+pcAlgo">pcAlgo</a></code>)
containing an estimate of the skeleton of the underlying DAG, the conditioning
sets (sepset) that led to edge removals and several other parameters.
</p>


<h3>Author(s)</h3>

<p>Original code by Markus Kalisch, Martin Maechler, Alain Hauser and Diego Colombo.
Modifications by Janine Witte.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load simulated cohort data
data("dat_sim")
n &lt;- nrow(dat_sim)
lab &lt;- colnames(dat_sim)
# estimate skeleton without taking background information into account
tskel.fit &lt;- tskeleton(suffStat = list(C = cor(dat_sim), n = n),
                       indepTest = gaussCItest, alpha = 0.01, labels = lab)
skel.fit &lt;- pcalg::skeleton(suffStat = list(C = cor(dat_sim), n = n),
                            indepTest = gaussCItest, alpha = 0.01, labels = lab)
                            identical(skel.fit@graph, tskel.fit@graph) # TRUE

# estimate skeleton with temporal ordering as background information
tiers &lt;- rep(c(1,2,3), times=c(3,3,3))
tskel.fit2 &lt;- tskeleton(suffStat = list(C = cor(dat_sim), n = n),
                       indepTest = gaussCItest, alpha = 0.01, labels = lab, tiers = tiers)

# in this case, the skeletons estimated with and without
# background knowledge are identical, but fewer conditional
# independence tests were performed when background
# knowledge was taken into account
identical(tskel.fit@graph, tskel.fit2@graph) # TRUE
tskel.fit@n.edgetests
tskel.fit2@n.edgetests


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
