<!DOCTYPE html><html><head><title>Help for package NAIR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {NAIR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#NAIR-package'><p>NAIR: Network Analysis of Immune Repertoire</p></a></li>
<li><a href='#addClusterMembership'>
<p>Partition a Network Graph Into Clusters</p></a></li>
<li><a href='#addClusterStats'>
<p>Compute Cluster-Level Network Properties</p></a></li>
<li><a href='#addNodeNetworkStats'>
<p>Compute Node-Level Network Properties</p></a></li>
<li><a href='#addNodeStats'>
<p>Compute Node-Level Network Properties</p></a></li>
<li><a href='#addPlots'>
<p>Generate Plots of a Network Graph</p></a></li>
<li><a href='#aggregateIdenticalClones'>
<p>Aggregate Counts/Frequencies for Clones With Identical Receptor Sequences</p></a></li>
<li><a href='#buildAssociatedClusterNetwork'>
<p>Build Global Network of Associated TCR/BCR Clusters</p></a></li>
<li><a href='#buildPublicClusterNetwork'>
<p>Build Global Network of Public TCR/BCR Clusters</p></a></li>
<li><a href='#buildPublicClusterNetworkByRepresentative'>
<p>Build Global Network of Public TCR/BCR Clusters Using Representative Clones</p></a></li>
<li><a href='#buildRepSeqNetwork'>
<p>Network Analysis of Immune Repertoire</p></a></li>
<li><a href='#chooseNodeStats'>
<p>Specify Node-level Network Properties to Compute</p></a></li>
<li><a href='#combineSamples'>
<p>Load and Combine Data From Multiple Samples</p></a></li>
<li><a href='#extractLayout'>
<p>Get Coordinate Layout From Graph Plot</p></a></li>
<li><a href='#filterInputData'>
<p>Filter Data Rows and Subset Data Columns</p></a></li>
<li><a href='#findAssociatedClones'>
<p>Identify TCR/BCR Clones in a Neighborhood Around Each Associated Sequence</p></a></li>
<li><a href='#findAssociatedSeqs'>
<p>Identify TCR/BCR Sequences Associated With a Binary Variable</p></a></li>
<li><a href='#findPublicClusters'>
<p>Find Public Clusters Among RepSeq Samples</p></a></li>
<li><a href='#generateAdjacencyMatrix'>
<p>Compute Graph Adjacency Matrix for Immune Repertoire Network</p></a></li>
<li><a href='#generateNetworkGraph'>
<p>Generate the <code>igraph</code> for a Network Adjacency Matrix</p></a></li>
<li><a href='#generateNetworkObjects'>
<p>Generate Basic Output for an Immune Repertoire Network</p></a></li>
<li><a href='#getClusterStats'>
<p>Compute Cluster-Level Network Properties</p></a></li>
<li><a href='#getNeighborhood'>
<p>Identify Cells or Clones in a Neighborhood Around a Target Sequence</p></a></li>
<li><a href='#hamDistBounded'>
<p>Bounded Computation of Hamming Distance</p></a></li>
<li><a href='#labelClusters'>
<p>Label Clusters in a Network Graph Plot</p></a></li>
<li><a href='#labelNodes'>
<p>Label Nodes in a Network Graph Plot</p></a></li>
<li><a href='#levDistBounded'>
<p>Bounded Computation of Levenshtein Distance</p></a></li>
<li><a href='#plotNetworkGraph'>
<p>Plot the Graph of an Immune Repertoire Network</p></a></li>
<li><a href='#saveNetwork'>
<p>Save List of Network Objects</p></a></li>
<li><a href='#saveNetworkPlots'>
<p>Write Plots to a PDF</p></a></li>
<li><a href='#simulateToyData'>
<p>Generate Toy AIRR-Seq Data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Network Analysis of Immune Repertoire</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.4</td>
</tr>
<tr>
<td>Description:</td>
<td>Pipelines for studying the adaptive immune repertoire of T cells 
    and B cells via network analysis based on receptor sequence similarity. 
    Relate clinical outcomes to immune repertoires based on their network 
    properties, or to particular clusters and clones within a repertoire. 
    Yang et al. (2023) &lt;<a href="https://doi.org/10.3389%2Ffimmu.2023.1181825">doi:10.3389/fimmu.2023.1181825</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.8), lifecycle, igraph, ggraph, ggplot2,
grDevices, utils, Matrix, stats, dplyr, rlang</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo (&ge; 0.10.8.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://mlizhangx.github.io/Network-Analysis-for-Repertoire-Sequencing-/">https://mlizhangx.github.io/Network-Analysis-for-Repertoire-Sequencing-/</a>,
<a href="https://github.com/mlizhangx/Network-Analysis-for-Repertoire-Sequencing-">https://github.com/mlizhangx/Network-Analysis-for-Repertoire-Sequencing-</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-03 00:08:19 UTC; Brian</td>
</tr>
<tr>
<td>Author:</td>
<td>Brian Neal [aut, cre],
  Hai Yang [aut],
  Daniil Matveev [aut],
  Phi Long Le [aut],
  Li Zhang [cph, aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Brian Neal &lt;Brian.Neal@ucsf.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-03 00:52:36 UTC</td>
</tr>
</table>
<hr>
<h2 id='NAIR-package'>NAIR: Network Analysis of Immune Repertoire</h2><span id='topic+NAIR'></span><span id='topic+NAIR-package'></span>

<h3>Description</h3>

<p>To learn about the NAIR package and get started, visit the
<a href="https://mlizhangx.github.io/Network-Analysis-for-Repertoire-Sequencing-/">package website</a>,
or browse the package vignettes offline:
</p>
<p><code>browseVignettes(package = "NAIR")</code>
</p>
<p>The following vignette is a good place to start:
</p>
<p><code>vignette("NAIR", package = "NAIR")</code>
</p>


<h3>Author(s)</h3>


<ul>
<li><p> Brian Neal (<a href="mailto:Brian.Neal@ucsf.edu">Brian.Neal@ucsf.edu</a>), Maintainer
</p>
</li>
<li><p> Hai Yang (<a href="mailto:Hai.Yang@ucsf.edu">Hai.Yang@ucsf.edu</a>)
</p>
</li>
<li><p> Phi-Long Le (<a href="mailto:PhiLong.Le@ucsf.edu">PhiLong.Le@ucsf.edu</a>)
</p>
</li>
<li><p> Li Zhang (<a href="mailto:Li.Zhang@ucsf.edu">Li.Zhang@ucsf.edu</a>)
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li> <p><a href="https://mlizhangx.github.io/Network-Analysis-for-Repertoire-Sequencing-/">Package website</a>
</p>
</li>
<li> <p><a href="https://github.com/mlizhangx/Network-Analysis-for-Repertoire-Sequencing-">Github page</a>
</p>
</li>
<li> <p><a href="https://github.com/mlizhangx/Network-Analysis-for-Repertoire-Sequencing-/issues">Report bugs and issues here</a>
</p>
</li></ul>


<hr>
<h2 id='addClusterMembership'>
Partition a Network Graph Into Clusters
</h2><span id='topic+addClusterMembership'></span>

<h3>Description</h3>

<p>Given a list of network objects returned by
<code><a href="#topic+buildRepSeqNetwork">buildRepSeqNetwork()</a></code> or
<code><a href="#topic+generateNetworkObjects">generateNetworkObjects()</a></code>,
partitions the network graph into clusters using the specified clustering
algorithm, adding a cluster membership variable to the node metadata.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addClusterMembership(
  net,
  cluster_fun = "fast_greedy",
  cluster_id_name = "cluster_id",
  overwrite = FALSE,
  verbose = FALSE,
  ...,
  data = deprecated(),
  fun = deprecated()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addClusterMembership_+3A_net">net</code></td>
<td>

<p>A <code><a href="base.html#topic+list">list</a></code> of network objects conforming to the output of
<code><a href="#topic+buildRepSeqNetwork">buildRepSeqNetwork()</a></code> or
<code><a href="#topic+generateNetworkObjects">generateNetworkObjects()</a></code>.
See details.
Alternatively, this argument accepts the network
<code><a href="igraph.html#topic+igraph">igraph</a></code>, with the node metadata passed to the
<code>data</code> argument. However, this alternative functionality is
deprecated and will eventually be removed.
</p>
</td></tr>
<tr><td><code id="addClusterMembership_+3A_cluster_fun">cluster_fun</code></td>
<td>

<p>A character string specifying the clustering algorithm to use.
See details.
</p>
</td></tr>
<tr><td><code id="addClusterMembership_+3A_cluster_id_name">cluster_id_name</code></td>
<td>

<p>A character string specifying the name of the cluster membership variable
to be added to the node metadata.
</p>
</td></tr>
<tr><td><code id="addClusterMembership_+3A_overwrite">overwrite</code></td>
<td>

<p>Logical. Should the variable specified by <code>cluster_id_name</code> be
overwritten if it already exists?
</p>
</td></tr>
<tr><td><code id="addClusterMembership_+3A_verbose">verbose</code></td>
<td>

<p>Logical. If <code>TRUE</code>, generates messages about the tasks
performed and their progress, as well as relevant properties of intermediate
outputs. Messages are sent to <code><a href="base.html#topic+stderr">stderr()</a></code>.
</p>
</td></tr>
<tr><td><code id="addClusterMembership_+3A_...">...</code></td>
<td>

<p>Named optional arguments to the function specified by <code>cluster_fun</code>.
</p>
</td></tr>
<tr><td><code id="addClusterMembership_+3A_data">data</code></td>
<td>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
See <code>net</code>.
</p>
</td></tr>
<tr><td><code id="addClusterMembership_+3A_fun">fun</code></td>
<td>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
Replaced by <code>cluster_fun</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The list <code>net</code> must contain the named elements
<code>igraph</code> (of class <code><a href="igraph.html#topic+igraph">igraph</a></code>),
<code>adjacency_matrix</code> (a <code><a href="base.html#topic+matrix">matrix</a></code> or
<code><a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix</a></code> encoding edge connections),
and <code>node_data</code> (a <code><a href="base.html#topic+data.frame">data.frame</a></code> containing node metadata),
all corresponding to the same network. The lists returned by
<code><a href="#topic+buildRepSeqNetwork">buildRepSeqNetwork()</a></code> and
<code><a href="#topic+generateNetworkObjects">generateNetworkObjects()</a></code>
are examples of valid inputs for the <code>net</code> argument.
</p>
<p>Alternatively, the <code>igraph</code> may be passed to <code>net</code> and the node
metadata to <code>data</code>. However, this alternative functionality is
deprecated and will eventually be removed.
</p>
<p>A clustering algorithm is used to partition the network graph into clusters
(densely-connected subgraphs). Each cluster represents a collection of
clones/cells with similar receptor sequences. The method used to partition
the graph depends on the choice of clustering algorithm, which is specified
using the <code>cluster_fun</code> argument.
</p>
<p>The available options for <code>cluster_fun</code> are listed below. Each refers
to an <code><a href="igraph.html#topic+igraph-package">igraph</a></code> function implementing a
particular clustering algorithm. Follow the links to learn more about the
individual clustering algorithms.
</p>

<ul>
<li> <p><code><a href="igraph.html#topic+cluster_edge_betweenness">&quot;edge_betweenness&quot;</a></code>
</p>
</li>
<li> <p><code><a href="igraph.html#topic+cluster_fast_greedy">&quot;fast_greedy&quot;</a></code>
</p>
</li>
<li> <p><code><a href="igraph.html#topic+cluster_infomap">&quot;infomap&quot;</a></code>
</p>
</li>
<li> <p><code><a href="igraph.html#topic+cluster_label_prop">&quot;label_prop&quot;</a></code>
</p>
</li>
<li> <p><code><a href="igraph.html#topic+cluster_leading_eigen">&quot;leading_eigen&quot;</a></code>
</p>
</li>
<li> <p><code><a href="igraph.html#topic+cluster_leiden">&quot;leiden&quot;</a></code>
</p>
</li>
<li> <p><code><a href="igraph.html#topic+cluster_louvain">&quot;louvain&quot;</a></code>
</p>
</li>
<li> <p><code><a href="igraph.html#topic+cluster_optimal">&quot;optimal&quot;</a></code>
</p>
</li>
<li> <p><code><a href="igraph.html#topic+cluster_spinglass">&quot;spinglass&quot;</a></code>
</p>
</li>
<li> <p><code><a href="igraph.html#topic+cluster_walktrap">&quot;walktrap&quot;</a></code>
</p>
</li></ul>

<p>Optional arguments to each clustering algorithm can have their
values specified using the ellipses (<code>...</code>) argument of
<code>addClusterMembership()</code>.
</p>
<p>Each cluster is assigned a numeric cluster ID. A cluster membership variable,
whose name is specified by <code>cluster_id_name</code>, is added to the node
metadata, encoding the cluster membership of the node for each row. The cluster
membership is encoded as the cluster ID number of the cluster to which the node
belongs.
</p>
<p>The <code>overwrite</code> argument controls whether to overwrite pre-existing data.
If the variable specified by <code>cluster_id_name</code> is already present in
the node metadata, then <code>overwrite</code> must be set to <code>TRUE</code> in
order to perform clustering and overwrite the variable with new cluster
membership values. Alternatively, by specifying a value for
<code>cluster_id_name</code> that is not among the variables in the node metadata,
a new cluster membership variable can be created while preserving the old
cluster membership variable. In this manner, clustering can be performed
multiple times on the same network using different clustering algorithms,
without losing the results.
</p>


<h3>Value</h3>

<p>If the variable specified by <code>cluster_id_name</code> is not present in
<code>net$node_data</code>, returns a copy of <code>net</code> with this variable
added to <code>net$node_data</code> encoding the cluster membership of the network
node corresponding to each row. If the variable is already present and
<code>overwrite = TRUE</code>, then its values are replaced with the new values
for cluster membership.
</p>
<p>Additionally, if <code>net</code> contains a list named <code>details</code>, then the
following elements will be added to <code>net$details</code> if they do not
already exist:
</p>
<table>
<tr><td><code>clusters_in_network</code></td>
<td>

<p>A named numeric vector of length 1. The first entry's name is the
name of the clustering algorithm, and its value is the number of clusters
resulting from performing clustering on the network.
</p>
</td></tr>
<tr><td><code>cluster_id_variable</code></td>
<td>

<p>A named numeric vector of length 1. The first entry's name is the
name of the clustering algorithm, and its value is the name of the
corresponding cluster membership variable in the node metadata
(i.e., the value of <code>cluster_id_name</code>).
</p>
</td></tr>
</table>
<p>If <code>net$details</code> already contains these elements, they will be updated
according to whether the cluster membership variable specified by
<code>cluster_id_name</code>
is added to <code>net$node_data</code> or already exists and is overwritten.
In the former case (the cluster membership variable does not already exist),
the length of each vector
(<code>clusters_in_network</code>) and (<code>cluster_id_variable</code>)
is increased by 1, with the new information appended as a new named entry
to each. In the latter case (the cluster membership variable is overwritten),
the new information overwrites the name and value of the last entry of each
vector.
</p>
<p>In the event where <code>overwrite = FALSE</code> and <code>net$node_data</code> contains
a variable with the same name as the value of <code>cluster_id_name</code>, then an
unaltered copy of <code>net</code> is returned with a message notifying the user.
</p>
<p>Under the alternative (deprecated) input format where the node metadata is
passed to <code>data</code> and the <code>igraph</code> is passed to <code>net</code>, the
node metadata is returned instead of the list of network objects, with the
cluster membership variable added or updated as described above.
</p>


<h3>Author(s)</h3>

<p>Brian Neal (<a href="mailto:Brian.Neal@ucsf.edu">Brian.Neal@ucsf.edu</a>)
</p>


<h3>References</h3>

<p>Hai Yang, Jason Cham, Brian Neal, Zenghua Fan, Tao He and Li Zhang. (2023).
NAIR: Network Analysis of Immune Repertoire. <em>Frontiers in Immunology</em>, vol. 14.
<a href="https://www.frontiersin.org/articles/10.3389/fimmu.2023.1181825/full">doi: 10.3389/fimmu.2023.1181825</a>
</p>
<p><a href="https://mlizhangx.github.io/Network-Analysis-for-Repertoire-Sequencing-/index.html">Webpage for the NAIR package</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+addClusterStats">addClusterStats()</a></code>
<code><a href="#topic+labelClusters">labelClusters()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
toy_data &lt;- simulateToyData()

net &lt;- generateNetworkObjects(
  toy_data, "CloneSeq"
)

# Perform cluster analysis,
# add cluster membership to net$node_data
net &lt;- addClusterMembership(net)

net$details$clusters_in_network
net$details$cluster_id_variable

# overwrite values in net$node_data$cluster_id
# with cluster membership values obtained using "cluster_leiden" algorithm
net &lt;- addClusterMembership(
  net,
  cluster_fun = "leiden",
  overwrite = TRUE
)

net$details$clusters_in_network
net$details$cluster_id_variable

# perform clustering using "cluster_louvain" algorithm
# saves cluster membership values to net$node_data$cluster_id_louvain
# (net$node_data$cluster_id retains membership values from "cluster_leiden")
net &lt;- addClusterMembership(
  net,
  cluster_fun = "louvain",
  cluster_id_name = "cluster_id_louvain",
)

net$details$clusters_in_network
net$details$cluster_id_variable

</code></pre>

<hr>
<h2 id='addClusterStats'>
Compute Cluster-Level Network Properties
</h2><span id='topic+addClusterStats'></span>

<h3>Description</h3>

<p>Given a list of network objects returned by
<code><a href="#topic+buildRepSeqNetwork">buildRepSeqNetwork()</a></code> or
<code><a href="#topic+generateNetworkObjects">generateNetworkObjects()</a></code>,
computes cluster-level network properties,
performing clustering first if needed.
The list of network objects is returned
with the cluster properties added as a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addClusterStats(
  net,
  cluster_id_name = "cluster_id",
  seq_col = NULL,
  count_col = NULL,
  degree_col = "degree",
  cluster_fun = "fast_greedy",
  overwrite = FALSE,
  verbose = FALSE,
  ...
)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addClusterStats_+3A_net">net</code></td>
<td>

<p>A <code><a href="base.html#topic+list">list</a></code> of network objects conforming to the output of
<code><a href="#topic+buildRepSeqNetwork">buildRepSeqNetwork()</a></code> or
<code><a href="#topic+generateNetworkObjects">generateNetworkObjects()</a></code>.
See details.
</p>
</td></tr>
<tr><td><code id="addClusterStats_+3A_cluster_id_name">cluster_id_name</code></td>
<td>

<p>A character string specifying the name of the cluster membership variable
in <code>net$node_data</code> that identifies the cluster to which each node belongs.
If the variable does not exist, it will be added by calling
<code><a href="#topic+addClusterMembership">addClusterMembership()</a></code>.
If the variable does exist, its values will be used
unless <code>overwrite = TRUE</code>,
in which case its values will be overwritten and the new values used.
</p>
</td></tr>
<tr><td><code id="addClusterStats_+3A_seq_col">seq_col</code></td>
<td>

<p>Specifies the column(s) of <code>net$node_data</code> containing
the receptor sequences upon whose similarity the network is based.
Accepts a character or numeric vector of length 1 or 2,
containing either column names or column indices.
If provided, related cluster-level properties will be computed.
The default <code>NULL</code> will use the value contained in
<code>net$details$seq_col</code> if it exists and is valid.
</p>
</td></tr>
<tr><td><code id="addClusterStats_+3A_count_col">count_col</code></td>
<td>

<p>Specifies the column of <code>net$node_data</code> containing
a measure of abundance (such as clone count or UMI count).
Accepts a character string containing the column name
or a numeric scalar containing the column index.
If provided,  related cluster-level properties will be computed.
</p>
</td></tr>
<tr><td><code id="addClusterStats_+3A_degree_col">degree_col</code></td>
<td>

<p>Specifies the column of <code>net$node_data</code> containing
the network degree of each node.
Accepts a character string containing the column name.
If the column does not exist, it will be added.
</p>
</td></tr>
<tr><td><code id="addClusterStats_+3A_cluster_fun">cluster_fun</code></td>
<td>

<p>A character string specifying the clustering algorithm to use when
adding or overwriting the cluster membership variable in
<code>net$node_data</code> specified by <code>cluster_id_name</code>.
Passed to <code><a href="#topic+addClusterMembership">addClusterMembership()</a></code>.
</p>
</td></tr>
<tr><td><code id="addClusterStats_+3A_overwrite">overwrite</code></td>
<td>

<p>Logical. If <code>TRUE</code> and <code>net</code> already contains an element named
<code>cluster_data</code>, it will be overwritten. Similarly, if
<code>overwrite = TRUE</code> and <code>net$node_data</code> contains a variable whose
name matches the value of <code>cluster_id_name</code>, then its values will be
overwritten with new cluster membership values (obtained using
<code><a href="#topic+addClusterMembership">addClusterMembership()</a></code>
with the specified value of <code>cluster_fun</code>),
and cluster properties will be computed based on the new values.
</p>
</td></tr>
<tr><td><code id="addClusterStats_+3A_verbose">verbose</code></td>
<td>

<p>Logical. If <code>TRUE</code>, generates messages about the tasks
performed and their progress, as well as relevant properties of intermediate
outputs. Messages are sent to <code><a href="base.html#topic+stderr">stderr()</a></code>.
</p>
</td></tr>
<tr><td><code id="addClusterStats_+3A_...">...</code></td>
<td>

<p>Named optional arguments to the function specified by <code>cluster_fun</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The list <code>net</code> must contain the named elements
<code>igraph</code> (of class <code><a href="igraph.html#topic+igraph">igraph</a></code>),
<code>adjacency_matrix</code> (a <code><a href="base.html#topic+matrix">matrix</a></code> or
<code><a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix</a></code> encoding edge connections),
and <code>node_data</code> (a <code><a href="base.html#topic+data.frame">data.frame</a></code> containing node metadata),
all corresponding to the same network. The lists returned by
<code><a href="#topic+buildRepSeqNetwork">buildRepSeqNetwork()</a></code> and
<code><a href="#topic+generateNetworkObjects">generateNetworkObjects()</a></code>
are examples of valid inputs for the <code>net</code> argument.
</p>
<p>If the network graph has previously been partitioned into clusters using
<code><a href="#topic+addClusterMembership">addClusterMembership()</a></code> and the user
wishes to compute network properties for these clusters, the name of the
cluster membership variable in <code>net$node_data</code> should be provided to
the <code>cluster_id_name</code> argument.
</p>
<p>If the value of <code>cluster_id_name</code> is not the name of a variable
in <code>net$node_data</code>, then clustering is performed using
<code><a href="#topic+addClusterMembership">addClusterMembership()</a></code>
with the specified value of <code>cluster_fun</code>,
and the cluster membership values are written to <code>net$node_data</code> using
the value of <code>cluster_id_name</code> as the variable name.
If <code>overwrite = TRUE</code>, this is done even if this variable already exists.
</p>


<h3>Value</h3>

<p>A modified copy of <code>net</code>, with cluster properties contained in the element
<code>cluster_data</code>. This is a <code><a href="base.html#topic+data.frame">data.frame</a></code> containing
one row for each cluster in the network and the following variables:
</p>
<table>
<tr><td><code>cluster_id</code></td>
<td>

<p>The cluster ID number.
</p>
</td></tr>
<tr><td><code>node_count</code></td>
<td>

<p>The number of nodes in the cluster.
</p>
</td></tr>
<tr><td><code>mean_seq_length</code></td>
<td>

<p>The mean sequence length in the cluster.
Only present when <code>length(seq_col) == 1</code>.
</p>
</td></tr>
<tr><td><code>A_mean_seq_length</code></td>
<td>

<p>The mean first sequence length in the cluster.
Only present when <code>length(seq_col) == 2</code>.
</p>
</td></tr>
<tr><td><code>B_mean_seq_length</code></td>
<td>

<p>The mean second sequence length in the cluster.
Only present when <code>length(seq_col) == 2</code>.
</p>
</td></tr>
<tr><td><code>mean_degree</code></td>
<td>

<p>The mean network degree in the cluster.
</p>
</td></tr>
<tr><td><code>max_degree</code></td>
<td>

<p>The maximum network degree in the cluster.
</p>
</td></tr>
<tr><td><code>seq_w_max_degree</code></td>
<td>

<p>The receptor sequence possessing the maximum degree within the cluster.
Only present when <code>length(seq_col) == 1</code>.
</p>
</td></tr>
<tr><td><code>A_seq_w_max_degree</code></td>
<td>

<p>The first sequence of the node possessing the maximum degree within the cluster.
Only present when <code>length(seq_col) == 2</code>.
</p>
</td></tr>
<tr><td><code>B_seq_w_max_degree</code></td>
<td>

<p>The second sequence of the node possessing the maximum degree within the cluster.
Only present when <code>length(seq_col) == 2</code>.
</p>
</td></tr>
<tr><td><code>agg_count</code></td>
<td>

<p>The aggregate count among all nodes in the cluster (based on the counts in
<code>count_col</code>).
</p>
</td></tr>
<tr><td><code>max_count</code></td>
<td>

<p>The maximum count among all nodes in the cluster (based on the counts in
<code>count_col</code>).
</p>
</td></tr>
<tr><td><code>seq_w_max_count</code></td>
<td>

<p>The receptor sequence possessing the maximum count within the cluster.
Only present when <code>length(seq_col) == 1</code>.
</p>
</td></tr>
<tr><td><code>A_seq_w_max_count</code></td>
<td>

<p>The first sequence of the node possessing the maximum count within the cluster.
Only present when <code>length(seq_col) == 2</code>.
</p>
</td></tr>
<tr><td><code>B_seq_w_max_count</code></td>
<td>

<p>The second sequence of the node possessing the maximum count within the cluster.
Only present when <code>length(seq_col) == 2</code>.
</p>
</td></tr>
<tr><td><code>diameter_length</code></td>
<td>

<p>The longest geodesic distance in the cluster, computed as the length of the
vector returned by <code><a href="igraph.html#topic+get_diameter">get_diameter()</a></code>.
</p>
</td></tr>
<tr><td><code>assortativity</code></td>
<td>

<p>The assortativity coefficient of the cluster's graph, based on the degree
(minus one) of each node in the cluster (with the degree computed based only
upon the nodes within the cluster). Computed using
<code><a href="igraph.html#topic+assortativity_degree">assortativity_degree()</a></code>.
</p>
</td></tr>
<tr><td><code>global_transitivity</code></td>
<td>

<p>The transitivity (i.e., clustering coefficient) for the cluster's graph, which
estimates the probability that adjacent vertices are connected. Computed using
<code><a href="igraph.html#topic+transitivity">transitivity()</a></code> with <code>type = "global"</code>.
</p>
</td></tr>
<tr><td><code>edge_density</code></td>
<td>

<p>The number of edges in the cluster as a fraction of the maximum possible number
of edges. Computed using <code><a href="igraph.html#topic+edge_density">edge_density()</a></code>.
</p>
</td></tr>
<tr><td><code>degree_centrality_index</code></td>
<td>

<p>The centrality index of the cluster's graph based on within-cluster network degree.
Computed as the <code>centralization</code> element of the output from
<code><a href="igraph.html#topic+centr_degree">centr_degree()</a></code>.
</p>
</td></tr>
<tr><td><code>closeness_centrality_index</code></td>
<td>

<p>The centrality index of the cluster's graph based on closeness,
i.e., distance to other nodes in the cluster.
Computed using <code><a href="igraph.html#topic+centralization">centralization()</a></code>.
</p>
</td></tr>
<tr><td><code>eigen_centrality_index</code></td>
<td>

<p>The centrality index of the cluster's graph based on the eigenvector centrality scores,
i.e., values of the first eigenvector of the adjacency matrix for the cluster.
Computed as the <code>centralization</code> element of the output from
<code><a href="igraph.html#topic+centr_eigen">centr_eigen()</a></code>.
</p>
</td></tr>
<tr><td><code>eigen_centrality_eigenvalue</code></td>
<td>

<p>The eigenvalue corresponding to the first eigenvector of the adjacency matrix
for the cluster. Computed as the <code>value</code> element of the output from
<code><a href="igraph.html#topic+eigen_centrality">eigen_centrality()</a></code>.
</p>
</td></tr>
</table>
<p>If <code>net$node_data</code> did not previously contain a variable whose name matches
the value of <code>cluster_id_name</code>, then this variable will be present
and will contain values for cluster membership, obtained through a call to
<code><a href="#topic+addClusterMembership">addClusterMembership()</a></code>
using the clustering algorithm specified by <code>cluster_fun</code>.
</p>
<p>If <code>net$node_data</code> did previously contain a variable whose name matches
the value of <code>cluster_id_name</code> and <code>overwrite = TRUE</code>, then the
values of this variable will be overwritten with new values for cluster membership,
obtained as above based on <code>cluster_fun</code>.
</p>
<p>If <code>net$node_data</code> did not previously contain a variable whose name matches
the value of <code>degree_col</code>, then this variable will be present
and will contain values for network degree.
</p>
<p>Additionally, if <code>net</code> contains a list named <code>details</code>, then the
following elements will be added to <code>net$details</code>, or overwritten if they
already exist:
</p>
<table>
<tr><td><code>cluster_data_goes_with</code></td>
<td>

<p>A character string containing the value of <code>cluster_id_name</code>.
When <code>net$node_data</code> contains multiple cluster membership variables
(e.g., from applying different clustering methods),
<code>cluster_data_goes_with</code> allows the user
to distinguish which of these variables corresponds to
<code>net$cluster_data</code>.
</p>
</td></tr>
<tr><td><code>count_col_for_cluster_data</code></td>
<td>

<p>A character string containing the value of <code>count_col</code>.
If <code>net$node_data</code> contains multiple count variables, this allows
the user to distinguish which of these variables corresponds to the
count-related properties in <code>net$cluster_data</code>, such as
<code>max_count</code>.
If <code>count_col = NULL</code>, then the value will be <code>NA</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Brian Neal (<a href="mailto:Brian.Neal@ucsf.edu">Brian.Neal@ucsf.edu</a>)
</p>


<h3>References</h3>

<p>Hai Yang, Jason Cham, Brian Neal, Zenghua Fan, Tao He and Li Zhang. (2023).
NAIR: Network Analysis of Immune Repertoire. <em>Frontiers in Immunology</em>, vol. 14.
<a href="https://www.frontiersin.org/articles/10.3389/fimmu.2023.1181825/full">doi: 10.3389/fimmu.2023.1181825</a>
</p>
<p><a href="https://mlizhangx.github.io/Network-Analysis-for-Repertoire-Sequencing-/index.html">Webpage for the NAIR package</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+addClusterMembership">addClusterMembership()</a></code>
<code><a href="#topic+getClusterStats">getClusterStats()</a></code>
<code><a href="#topic+labelClusters">labelClusters()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
toy_data &lt;- simulateToyData()

net &lt;- generateNetworkObjects(
  toy_data, "CloneSeq"
)

net &lt;- addClusterStats(
  net,
  count_col = "CloneCount"
)

head(net$cluster_data)
net$details

# won't change net since net$cluster_data exists
net &lt;- addClusterStats(
  net,
  count_col = "CloneCount",
  cluster_fun = "leiden",
  verbose = TRUE
)

# overwrites values in net$cluster_data
# and cluster membership values in net$node_data$cluster_id
# with values obtained using "cluster_leiden" algorithm
net &lt;- addClusterStats(
  net,
  count_col = "CloneCount",
  cluster_fun = "leiden",
  overwrite = TRUE
)

net$details

# overwrites existing values in net$cluster_data
# with values obtained using "cluster_louvain" algorithm
# saves cluster membership values to net$node_data$cluster_id_louvain
# (net$node_data$cluster_id retains membership values from "cluster_leiden")
net &lt;- addClusterStats(
  net,
  count_col = "CloneCount",
  cluster_fun = "louvain",
  cluster_id_name = "cluster_id_louvain",
  overwrite = TRUE
)

net$details

# perform clustering using "cluster_fast_greedy" algorithm,
# save cluster membership values to net$node_data$cluster_id_greedy
net &lt;- addClusterMembership(
  net,
  cluster_fun = "fast_greedy",
  cluster_id_name = "cluster_id_greedy"
)

# compute cluster properties for the clusters from previous step
# overwrites values in net$cluster_data
net &lt;- addClusterStats(
  net,
  cluster_id_name = "cluster_id_greedy",
  overwrite = TRUE
)

net$details
</code></pre>

<hr>
<h2 id='addNodeNetworkStats'>
Compute Node-Level Network Properties
</h2><span id='topic+addNodeNetworkStats'></span>

<h3>Description</h3>

<p><img src="../help/figures/lifecycle-deprecated.svg" width="35%" alt="lifecycle-deprecated.svg" />
</p>
<p>Given the node metadata and <code><a href="igraph.html#topic+igraph">igraph</a></code> for a network,
computes a specified set of network properties for the network nodes.
The node metadata is returned
with each property added as a variable.
</p>
<p>This function was deprecated in favor of
<code><a href="#topic+addNodeStats">addNodeStats()</a></code>
in NAIR 1.0.1.
The new function accepts and returns the entire list of network
objects returned by <code><a href="#topic+buildRepSeqNetwork">buildRepSeqNetwork()</a></code>
or by <code><a href="#topic+generateNetworkObjects">generateNetworkObjects()</a></code>.
It can compute cluster membership and add the values to the node metadata.
It additionally updates the list element <code>details</code> with further
information linking the node-level and cluster-level metadata.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addNodeNetworkStats(
  data,
  net,
  stats_to_include = chooseNodeStats(),
  cluster_fun = "fast_greedy",
  cluster_id_name = "cluster_id",
  overwrite = FALSE,
  verbose = FALSE,
  ...
)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addNodeNetworkStats_+3A_data">data</code></td>
<td>

<p>A data frame containing the node-level metadata for the network, with each
row corresponding to a network node.
</p>
</td></tr>
<tr><td><code id="addNodeNetworkStats_+3A_net">net</code></td>
<td>

<p>The network <code><a href="igraph.html#topic+igraph">igraph</a></code>.
</p>
</td></tr>
<tr><td><code id="addNodeNetworkStats_+3A_stats_to_include">stats_to_include</code></td>
<td>

<p>Specifies which network properties to compute.
Accepts a vector created using
<code><a href="#topic+chooseNodeStats">chooseNodeStats()</a></code> or
<code><a href="#topic+exclusiveNodeStats">exclusiveNodeStats()</a></code>,
or the character string <code>"all"</code> to compute all network properties.
</p>
</td></tr>
<tr><td><code id="addNodeNetworkStats_+3A_cluster_fun">cluster_fun</code></td>
<td>

<p>A character string specifying the clustering algorithm to use when
computing cluster membership.
Applicable only when <code>stats_to_include = "all"</code> or
<code>stats_to_include["cluster_id"]</code> is <code>TRUE</code>.
Passed to <code><a href="#topic+addClusterMembership">addClusterMembership()</a></code>.
</p>
</td></tr>
<tr><td><code id="addNodeNetworkStats_+3A_cluster_id_name">cluster_id_name</code></td>
<td>

<p>A character string specifying the name of the cluster membership variable
to be added to <code>data</code>.
Applicable only when <code>stats_to_include = "all"</code> or
<code>stats_to_include["cluster_id"]</code> is <code>TRUE</code>.
Passed to <code><a href="#topic+addClusterMembership">addClusterMembership()</a></code>.
</p>
</td></tr>
<tr><td><code id="addNodeNetworkStats_+3A_overwrite">overwrite</code></td>
<td>

<p>Logical. If <code>TRUE</code> and <code>data</code> contains a variable whose
name matches the value of <code>cluster_id_name</code>, then its values will be
overwritten with new cluster membership values (obtained using
<code><a href="#topic+addClusterMembership">addClusterMembership()</a></code>
with the specified value of <code>cluster_fun</code>).
Applicable only when <code>stats_to_include = "all"</code> or
<code>stats_to_include["cluster_id"]</code> is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="addNodeNetworkStats_+3A_verbose">verbose</code></td>
<td>

<p>Logical. If <code>TRUE</code>, generates messages about the tasks
performed and their progress, as well as relevant properties of intermediate
outputs. Messages are sent to <code><a href="base.html#topic+stderr">stderr()</a></code>.
</p>
</td></tr>
<tr><td><code id="addNodeNetworkStats_+3A_...">...</code></td>
<td>

<p>Named optional arguments to the function specified by <code>cluster_fun</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Node-level network properties are properties that pertain to each individual
node in the network graph.
</p>
<p>Some are local properties, meaning that their value for a given node depends only
on a subset of the nodes in the network. One example is the network degree of a
given node, which represents the number of other nodes that are directly joined
to the given node by an edge connection.
</p>
<p>Other properties are global properties, meaning that their value for a given node
depends on all of the nodes in the network. An example is the authority score of
a node, which is computed using the entire graph adjacency matrix (if we denote
this matrix by <code class="reqn">A</code>, then the principal eigenvector of <code class="reqn">A^T A</code> represents
the authority scores of the network nodes).
</p>
<p>See <code><a href="#topic+chooseNodeStats">chooseNodeStats()</a></code>
for a list of the available node-level network properties.
</p>


<h3>Value</h3>

<p>A copy of <code>data</code> with with an additional column for each
new network property computed.
See <code><a href="#topic+chooseNodeStats">chooseNodeStats()</a></code>
for the network property names,
which are used as the column names,
except for the cluster membership variable,
whose name is the value of <code>cluster_id_name</code>.
</p>


<h3>Author(s)</h3>

<p>Brian Neal (<a href="mailto:Brian.Neal@ucsf.edu">Brian.Neal@ucsf.edu</a>)
</p>


<h3>References</h3>

<p>Hai Yang, Jason Cham, Brian Neal, Zenghua Fan, Tao He and Li Zhang. (2023).
NAIR: Network Analysis of Immune Repertoire. <em>Frontiers in Immunology</em>,
vol. 14.
<a href="https://www.frontiersin.org/articles/10.3389/fimmu.2023.1181825/full">doi: 10.3389/fimmu.2023.1181825</a>
</p>
<p><a href="https://mlizhangx.github.io/Network-Analysis-for-Repertoire-Sequencing-/index.html">Webpage for the NAIR package</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+addNodeStats">addNodeStats()</a></code>
<code><a href="#topic+chooseNodeStats">chooseNodeStats()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
toy_data &lt;- simulateToyData()

net &lt;-
  generateNetworkObjects(
    toy_data,
    "CloneSeq"
  )

net$node_data &lt;-
  addNodeNetworkStats(
    net$node_data,
    net$igraph
  )


</code></pre>

<hr>
<h2 id='addNodeStats'>
Compute Node-Level Network Properties
</h2><span id='topic+addNodeStats'></span>

<h3>Description</h3>

<p>Given a list of network objects returned by
<code><a href="#topic+buildRepSeqNetwork">buildRepSeqNetwork()</a></code> or
<code><a href="#topic+generateNetworkObjects">generateNetworkObjects()</a></code>,
computes a specified set of network properties for the network nodes.
The list of network objects is returned
with each property added as a variable to the node metadata.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addNodeStats(
  net,
  stats_to_include = chooseNodeStats(),
  cluster_fun = "fast_greedy",
  cluster_id_name = "cluster_id",
  overwrite = FALSE,
  verbose = FALSE,
  ...
)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addNodeStats_+3A_net">net</code></td>
<td>

<p>A <code><a href="base.html#topic+list">list</a></code> of network objects conforming to the output of
<code><a href="#topic+buildRepSeqNetwork">buildRepSeqNetwork()</a></code> or
<code><a href="#topic+generateNetworkObjects">generateNetworkObjects()</a></code>.
See details.
</p>
</td></tr>
<tr><td><code id="addNodeStats_+3A_stats_to_include">stats_to_include</code></td>
<td>

<p>Specifies which network properties to compute.
Accepts a vector created using
<code><a href="#topic+chooseNodeStats">chooseNodeStats()</a></code> or
<code><a href="#topic+exclusiveNodeStats">exclusiveNodeStats()</a></code>,
or the character string <code>"all"</code> to compute all network properties.
</p>
</td></tr>
<tr><td><code id="addNodeStats_+3A_cluster_fun">cluster_fun</code></td>
<td>

<p>A character string specifying the clustering algorithm to use when
computing cluster membership.
Applicable only when <code>stats_to_include = "all"</code> or
<code>stats_to_include["cluster_id"]</code> is <code>TRUE</code>.
Passed to <code><a href="#topic+addClusterMembership">addClusterMembership()</a></code>.
</p>
</td></tr>
<tr><td><code id="addNodeStats_+3A_cluster_id_name">cluster_id_name</code></td>
<td>

<p>A character string specifying the name of the cluster membership variable
to be added to the node metadata.
Applicable only when <code>stats_to_include = "all"</code> or
<code>stats_to_include["cluster_id"]</code> is <code>TRUE</code>.
Passed to <code><a href="#topic+addClusterMembership">addClusterMembership()</a></code>.
</p>
</td></tr>
<tr><td><code id="addNodeStats_+3A_overwrite">overwrite</code></td>
<td>

<p>Logical. If <code>TRUE</code> and <code>net$node_data</code> contains a variable whose
name matches the value of <code>cluster_id_name</code>, then its values will be
overwritten with new cluster membership values (obtained using
<code><a href="#topic+addClusterMembership">addClusterMembership()</a></code>, to which
the values of <code>cluster_fun</code>, <code>overwrite</code>).
Applicable only when <code>stats_to_include = "all"</code> or
<code>stats_to_include["cluster_id"]</code> is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="addNodeStats_+3A_verbose">verbose</code></td>
<td>

<p>Logical. If <code>TRUE</code>, generates messages about the tasks
performed and their progress, as well as relevant properties of intermediate
outputs. Messages are sent to <code><a href="base.html#topic+stderr">stderr()</a></code>.
</p>
</td></tr>
<tr><td><code id="addNodeStats_+3A_...">...</code></td>
<td>

<p>Named optional arguments to the function specified by <code>cluster_fun</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Node-level network properties are properties that pertain to each individual
node in the network graph.
</p>
<p>Some are local properties, meaning that their value for a given node depends only
on a subset of the nodes in the network. One example is the network degree of a
given node, which represents the number of other nodes that are directly joined
to the given node by an edge connection.
</p>
<p>Other properties are global properties, meaning that their value for a given node
depends on all of the nodes in the network. An example is the authority score of
a node, which is computed using the entire graph adjacency matrix (if we denote
this matrix by <code class="reqn">A</code>, then the principal eigenvector of <code class="reqn">A^T A</code> represents
the authority scores of the network nodes).
</p>
<p>See <code><a href="#topic+chooseNodeStats">chooseNodeStats()</a></code>
for a list of the available node-level network properties.
</p>
<p>The list <code>net</code> must contain the named elements
<code>igraph</code> (of class <code><a href="igraph.html#topic+igraph">igraph</a></code>),
<code>adjacency_matrix</code> (a <code><a href="base.html#topic+matrix">matrix</a></code> or
<code><a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix</a></code> encoding edge connections),
and <code>node_data</code> (a <code><a href="base.html#topic+data.frame">data.frame</a></code> containing node metadata),
all corresponding to the same network. The lists returned by
<code><a href="#topic+buildRepSeqNetwork">buildRepSeqNetwork()</a></code> and
<code><a href="#topic+generateNetworkObjects">generateNetworkObjects()</a></code>
are examples of valid inputs for the <code>net</code> argument.
</p>


<h3>Value</h3>

<p>A modified copy of <code>net</code>,
with <code>net$node_data</code> containing an additional column
for each new network property computed.
See <code><a href="#topic+chooseNodeStats">chooseNodeStats()</a></code>
for the network property names,
which are used as the column names,
except for the cluster membership variable,
whose name is the value of <code>cluster_id_name</code>.
</p>


<h3>Author(s)</h3>

<p>Brian Neal (<a href="mailto:Brian.Neal@ucsf.edu">Brian.Neal@ucsf.edu</a>)
</p>


<h3>References</h3>

<p>Hai Yang, Jason Cham, Brian Neal, Zenghua Fan, Tao He and Li Zhang. (2023).
NAIR: Network Analysis of Immune Repertoire. <em>Frontiers in Immunology</em>,
vol. 14.
<a href="https://www.frontiersin.org/articles/10.3389/fimmu.2023.1181825/full">doi: 10.3389/fimmu.2023.1181825</a>
</p>
<p><a href="https://mlizhangx.github.io/Network-Analysis-for-Repertoire-Sequencing-/index.html">Webpage for the NAIR package</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+chooseNodeStats">chooseNodeStats()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
toy_data &lt;- simulateToyData()

net &lt;- generateNetworkObjects(
  toy_data, "CloneSeq"
)

# Add default set of node properties
net &lt;- addNodeStats(net)

# Modify default set of node properties
net &lt;- addNodeStats(
  net,
  stats_to_include =
    chooseNodeStats(
      closeness = TRUE,
      page_rank = FALSE
    )
)

# Add only the spepcified node properties
net &lt;- addNodeStats(
  net,
  stats_to_include =
    exclusiveNodeStats(
      degree = TRUE,
      transitivity = TRUE
    )
)

# Add all node-level network properties
net &lt;- addNodeStats(
  net,
  stats_to_include = "all"
)


</code></pre>

<hr>
<h2 id='addPlots'>
Generate Plots of a Network Graph
</h2><span id='topic+addPlots'></span><span id='topic+generateNetworkGraphPlots'></span>

<h3>Description</h3>

<p>Generates one or more
<code><a href="ggraph.html#topic+ggraph">ggraph</a></code> plots of the network graph according to the user
specifications.
</p>
<p><code>addPlots()</code> accepts and returns a list of network objects, adding
the plots to the existing list contents. If the list already contains plots,
the new plots will be created using the same coordinate layout as the
existing plots.
</p>
<p><code>generateNetworkGraphPlots()</code> accepts the network
<code><a href="igraph.html#topic+igraph">igraph</a></code> and node metadata,
and returns a list containing plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addPlots(
  net,
  print_plots = FALSE,
  plot_title = NULL,
  plot_subtitle = "auto",
  color_nodes_by = NULL,
  color_scheme = "default",
  color_legend = "auto",
  color_title = "auto",
  edge_width = 0.1,
  size_nodes_by = 0.5,
  node_size_limits = NULL,
  size_title = "auto",
  verbose = FALSE
)

generateNetworkGraphPlots(
  igraph,
  data,
  print_plots = FALSE,
  plot_title = NULL,
  plot_subtitle = NULL,
  color_nodes_by = NULL,
  color_scheme = "default",
  color_legend = "auto",
  color_title = "auto",
  edge_width = 0.1,
  size_nodes_by = 0.5,
  node_size_limits = NULL,
  size_title = "auto",
  layout = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addPlots_+3A_net">net</code></td>
<td>

<p>A <code><a href="base.html#topic+list">list</a></code> of network objects conforming to the output of
<code><a href="#topic+buildRepSeqNetwork">buildRepSeqNetwork()</a></code> or
<code><a href="#topic+generateNetworkObjects">generateNetworkObjects()</a></code>.
See details.
</p>
</td></tr>
<tr><td><code id="addPlots_+3A_igraph">igraph</code></td>
<td>

<p>An <code><a href="igraph.html#topic+igraph">igraph</a></code> object containing the network graph to be plotted.
</p>
</td></tr>
<tr><td><code id="addPlots_+3A_data">data</code></td>
<td>

<p>A data frame containing the node metadata for the network, with each row
corresponding to a node.
</p>
</td></tr>
<tr><td><code id="addPlots_+3A_print_plots">print_plots</code></td>
<td>

<p>A logical scalar; should plots be printed in the <code>R</code> plotting window?
</p>
</td></tr>
<tr><td><code id="addPlots_+3A_plot_title">plot_title</code></td>
<td>

<p>A character string containing the plot title.
</p>
</td></tr>
<tr><td><code id="addPlots_+3A_plot_subtitle">plot_subtitle</code></td>
<td>

<p>A character string containing the plot subtitle. The default value
<code>"auto"</code> generates a subtitle describing the settings used to
construct the network,
including the distance type and distance cutoff.
</p>
</td></tr>
<tr><td><code id="addPlots_+3A_color_nodes_by">color_nodes_by</code></td>
<td>

<p>A vector specifying one or more node metadata variables used to encode the
color of the nodes. One plot is generated for each entry, with each plot
coloring the nodes according to the variable in the corresponding entry.
This argument accepts a character vector where each entry is a
column name of the node metadata.
If this argument is <code>NULL</code>, generates a single plot with uncolored nodes.
</p>
</td></tr>
<tr><td><code id="addPlots_+3A_color_scheme">color_scheme</code></td>
<td>

<p>A character string specifying the color scale to use for all plots, or a
character vector whose length matches that of <code>color_nodes_by</code>, with each
entry specifying the color scale for the corresponding plot.
<code>"default"</code> specifies the default
<code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code> color scale.
Other options are one of the viridis color scales (e.g., <code>"plasma"</code>,
<code>"A"</code> or other valid inputs to the <code>option</code> argument of
<code><a href="ggraph.html#topic+scale_color_viridis">scale_color_viridis()</a></code>)
or (for discrete variables) a palette
from <code><a href="grDevices.html#topic+hcl.pals">hcl.pals()</a></code> (e.g., <code>"RdYlGn"</code>).
Each of the viridis color scales can include the suffix <code>"-1"</code>
to reverse its direction (e.g., <code>"plasma-1"</code> or <code>"A-1"</code>).
</p>
</td></tr>
<tr><td><code id="addPlots_+3A_color_legend">color_legend</code></td>
<td>

<p>A logical scalar specifying whether to display the color legend in plots.
The default value of <code>"auto"</code> shows the color legend if nodes are colored
according to a continuous variable or
according to a discrete variable with at most 20 distinct values.
</p>
</td></tr>
<tr><td><code id="addPlots_+3A_color_title">color_title</code></td>
<td>

<p>A character string specifying the title of the color legend in all plots, or a
character vector whose length matches that of <code>color_nodes_by</code>, with each
entry specifying the title of the color legend in the corresponding plot.
Only applicable for plots with colored nodes.
The value <code>"auto"</code> uses the corresponding value of <code>color_nodes_by</code>.
</p>
</td></tr>
<tr><td><code id="addPlots_+3A_edge_width">edge_width</code></td>
<td>

<p>A numeric scalar specifying the width of the graph edges in the plot.
Passed to the <code>width</code> argument of
<code><a href="ggraph.html#topic+geom_edge_link0">geom_edge_link0()</a></code>.
</p>
</td></tr>
<tr><td><code id="addPlots_+3A_size_nodes_by">size_nodes_by</code></td>
<td>

<p>A numeric scalar specifying the size of the nodes in all plots, or the column
name of a node metadata variable used to encode the size of the nodes in all
plots. Alternatively, an argument value of <code>NULL</code> uses the default
<code><a href="ggraph.html#topic+ggraph">ggraph</a></code> size for all nodes. Passed to the size aesthetic
mapping of <code><a href="ggraph.html#topic+geom_node_point">geom_node_point()</a></code>.
</p>
</td></tr>
<tr><td><code id="addPlots_+3A_node_size_limits">node_size_limits</code></td>
<td>

<p>A numeric vector of length 2, specifying the minimum and maximum node size.
Only applicable if nodes are sized according to a variable.
If <code>node_size_limits = NULL</code>, the default size scale will be used.
</p>
</td></tr>
<tr><td><code id="addPlots_+3A_size_title">size_title</code></td>
<td>

<p>A character string (or <code>NULL</code>) specifying the title for the size legend.
Only applicable if nodes are sized according to a variable.
The value <code>"auto"</code> uses the value of <code>size_nodes_by</code>.
</p>
</td></tr>
<tr><td><code id="addPlots_+3A_layout">layout</code></td>
<td>

<p>A <code>matrix</code> specifying the coordinate layout of the network nodes,
with one row for each node in the network and two columns.
Each row specifies the x and y coordinates for the corresponding node.
If <code>NULL</code>, the layout matrix is created using
<code>[igraph:layout_components]{layout_components()}</code>.
This argument can be used to
create plots conforming to the same layout as previously-generated plots. It
can also be used to generate plots with custom layouts.
</p>
</td></tr>
<tr><td><code id="addPlots_+3A_verbose">verbose</code></td>
<td>

<p>Logical. If <code>TRUE</code>, generates messages about the tasks
performed and their progress, as well as relevant properties of intermediate
outputs. Messages are sent to <code><a href="base.html#topic+stderr">stderr()</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The list <code>net</code> must contain the named elements
<code>igraph</code> (of class <code><a href="igraph.html#topic+igraph">igraph</a></code>),
<code>adjacency_matrix</code> (a <code><a href="base.html#topic+matrix">matrix</a></code> or
<code><a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix</a></code> encoding edge connections),
and <code>node_data</code> (a <code><a href="base.html#topic+data.frame">data.frame</a></code> containing node metadata),
all corresponding to the same network. The lists returned by
<code><a href="#topic+buildRepSeqNetwork">buildRepSeqNetwork()</a></code> and
<code><a href="#topic+generateNetworkObjects">generateNetworkObjects()</a></code>
are examples of valid inputs for the <code>net</code> argument.
</p>
<p>The arguments <code>color_nodes_by</code> and <code>size_nodes_by</code> accept
the names of variables in the node metadata.
For <code>addPlots()</code>, this is the data frame <code>node_data</code>
contained in the list provided to the <code>net</code> argument.
For <code>generateNetworkGraphPlots()</code>, this is the data frame provided
to the <code>data</code> argument.
</p>
<p><code>addPlots()</code> adds the generated plots to the list <code>plots</code> contained
in the list of network objects provided to <code>net</code>.
The <code>plots</code> element is created if it does not already exist.
If plots already exist, the new plots will be generated with the same
coordinate layout as the existing plots.
Each plot is named according to the variable used to color the nodes.
If a plot already exists with the same name as one of the new plots,
it will be overwritten with the new plot.
If the <code>plots</code> list does not already contain an element named
<code>graph_layout</code>, it will be added. This element contains the coordinate
layout for the plots as a two-column matrix.
</p>
<p>When calling <code>generateNetworkGraphPlots()</code>, if one wishes for the plots
to be generated with the same coordinate layout as an existing plot, the
layout matrix for the existing plot must be passed to the <code>layout</code>
argument.
</p>
<p>The plots can be printed to a pdf using
<code><a href="#topic+saveNetworkPlots">saveNetworkPlots()</a></code>.
</p>


<h3>Value</h3>

<p><code>addPlots()</code> returns a modified copy of <code>net</code> with the new plots
contained in the element named <code>plots</code> (a list), in addition to any
previously existing plots.
</p>
<p><code>generateNetworkGraphPlots()</code> returns a list containing the new plots.
</p>
<p>Each plot is an object of class <code>ggraph</code>. Within the list of plots,
each plot is named after the variable used to color the nodes.
For a plot with uncolored nodes, the name is <code>uniform_color</code>.
</p>
<p>The list containing the new plots also contains an element named
<code>graph_layout</code>. This is
a matrix specifying the coordinate layout of the nodes in the plots.
It contains one row for each node in the
network and two columns. Each row specifies the x and y coordinates for the
corresponding node. This matrix can be used to generate additional plots with
the same layout as the plots in the returned list.
</p>


<h3>Author(s)</h3>

<p>Brian Neal (<a href="mailto:Brian.Neal@ucsf.edu">Brian.Neal@ucsf.edu</a>)
</p>


<h3>References</h3>

<p>Hai Yang, Jason Cham, Brian Neal, Zenghua Fan, Tao He and Li Zhang. (2023).
NAIR: Network Analysis of Immune Repertoire. <em>Frontiers in Immunology</em>, vol. 14.
<a href="https://www.frontiersin.org/articles/10.3389/fimmu.2023.1181825/full">doi: 10.3389/fimmu.2023.1181825</a>
</p>
<p><a href="https://mlizhangx.github.io/Network-Analysis-for-Repertoire-Sequencing-/index.html">Webpage for the NAIR package</a>
</p>
<p><a href="https://mlizhangx.github.io/Network-Analysis-for-Repertoire-Sequencing-/articles/network_visualization.html">Network Visualization article on package website</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+labelNodes">labelNodes()</a></code>
<code><a href="#topic+labelClusters">labelClusters()</a></code>
<code><a href="#topic+saveNetworkPlots">saveNetworkPlots()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
toy_data &lt;- simulateToyData()

net &lt;- buildNet(toy_data, "CloneSeq", node_stats = TRUE)

net &lt;- addPlots(
  net,
  color_nodes_by =
    c("SampleID", "transitivity", "coreness"),
  color_scheme =
    c("Set 2", "mako-1", "plasma-1"),
  color_title =
    c("", "Transitvity", "Coreness"),
  size_nodes_by = "degree",
  node_size_limits = c(0.1, 1.5),
  plot_subtitle = NULL,
  print_plots = TRUE
)

</code></pre>

<hr>
<h2 id='aggregateIdenticalClones'>
Aggregate Counts/Frequencies for Clones With Identical Receptor Sequences
</h2><span id='topic+aggregateIdenticalClones'></span>

<h3>Description</h3>

<p>Given bulk Adaptive Immune Receptor Repertoire Sequencing (AIRR-Seq) data
with clones indexed by row, returns a data frame containing one row for each
unique receptor sequence. Includes the number of clones sharing each sequence,
as well as aggregate values for clone count and clone frequency across all
clones sharing each sequence. Clones can be grouped according to metadata,
in which case aggregation is performed within (but not across) groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggregateIdenticalClones(
  data,
  clone_col,
  count_col,
  freq_col,
  grouping_cols = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggregateIdenticalClones_+3A_data">data</code></td>
<td>

<p>A data frame containing the bulk AIRR-Seq data, with clones indexed by row.
</p>
</td></tr>
<tr><td><code id="aggregateIdenticalClones_+3A_clone_col">clone_col</code></td>
<td>

<p>Specifies the column of <code>data</code> containing
the receptor sequences.
Accepts a character string containing the column name
or a numeric scalar containing the column index.
</p>
</td></tr>
<tr><td><code id="aggregateIdenticalClones_+3A_count_col">count_col</code></td>
<td>

<p>Specifies the column of <code>data</code> containing
the clone counts.
Accepts a character string containing the column name
or a numeric scalar containing the column index.
</p>
</td></tr>
<tr><td><code id="aggregateIdenticalClones_+3A_freq_col">freq_col</code></td>
<td>

<p>Specifies the column of <code>data</code> containing
the clone frequencies.
Accepts a character string containing the column name
or a numeric scalar containing the column index.
</p>
</td></tr>
<tr><td><code id="aggregateIdenticalClones_+3A_grouping_cols">grouping_cols</code></td>
<td>

<p>An optional character vector of column names
or numeric vector of column indices, specifying
one or more columns of <code>data</code> used to assign clones to groups.
If provided, aggregation occurs within groups, but not across groups.
See details.
</p>
</td></tr>
<tr><td><code id="aggregateIdenticalClones_+3A_verbose">verbose</code></td>
<td>

<p>Logical. If <code>TRUE</code>, generates messages about the tasks
performed and their progress, as well as relevant properties of intermediate
outputs. Messages are sent to <code><a href="base.html#topic+stderr">stderr()</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>grouping_cols</code> is left unspecified, the returned data frame will contain
one row for each unique receptor sequence appearing in <code>data</code>.
</p>
<p>If one or more columns of <code>data</code> are specified using the <code>grouping_cols</code>
argument, then each clone (row) in <code>data</code> is assigned to a group based on its
combination of values in these columns. If two clones share the same receptor sequence
but belong to different groups, their receptor sequence will appear multiple times
in the returned data frame, with one row for each group in which the sequence appears.
In each such row, the aggregate clone count, aggregate clone frequency, and number of
clones sharing the sequence are reported within the group for that row.
</p>


<h3>Value</h3>

<p>A data frame whose first column contains the receptor sequences and has the
same name as the column of <code>data</code> specified by <code>clone_col</code>. One
additional column will be present for each column of <code>data</code> that is
specified using the <code>grouping_cols</code> argument, with each having the same
column name. The remaining columns are as follows:
</p>
<table>
<tr><td><code>AggregatedCloneCount</code></td>
<td>
<p>The aggregate clone count across all clones (within
the same group, if applicable) that share the receptor sequence in that row.
</p>
</td></tr>
<tr><td><code>AggregatedCloneFrequency</code></td>
<td>
<p>The aggregate clone frequency across all clones
(within the same group, if applicable) that share the receptor sequence in that row.
</p>
</td></tr>
<tr><td><code>UniqueCloneCount</code></td>
<td>
<p>The number of clones (rows) in <code>data</code> (within the
same group, if applicable) possessing the receptor sequence for the current row.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Brian Neal (<a href="mailto:Brian.Neal@ucsf.edu">Brian.Neal@ucsf.edu</a>)
</p>


<h3>References</h3>

<p>Hai Yang, Jason Cham, Brian Neal, Zenghua Fan, Tao He and Li Zhang. (2023).
NAIR: Network Analysis of Immune Repertoire. <em>Frontiers in Immunology</em>, vol. 14.
<a href="https://www.frontiersin.org/articles/10.3389/fimmu.2023.1181825/full">doi: 10.3389/fimmu.2023.1181825</a>
</p>
<p><a href="https://mlizhangx.github.io/Network-Analysis-for-Repertoire-Sequencing-/index.html">Webpage for the NAIR package</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>my_data &lt;- data.frame(
  clone_seq = c("ATCG", rep("ACAC", 2), rep("GGGG", 4)),
  clone_count = rep(1, 7),
  clone_freq = rep(1/7, 7),
  time_point = c("t_0", rep(c("t_0", "t_1"), 3)),
  subject_id = c(rep(1, 5), rep(2, 2))
)
my_data

aggregateIdenticalClones(
  my_data,
  "clone_seq",
  "clone_count",
  "clone_freq",
)

# group clones by time point
aggregateIdenticalClones(
  my_data,
  "clone_seq",
  "clone_count",
  "clone_freq",
  grouping_cols = "time_point"
)

# group clones by subject ID
aggregateIdenticalClones(
  my_data,
  "clone_seq",
  "clone_count",
  "clone_freq",
  grouping_cols = "subject_id"
)

# group clones by time point and subject ID
aggregateIdenticalClones(
  my_data,
  "clone_seq",
  "clone_count",
  "clone_freq",
  grouping_cols =
    c("subject_id", "time_point")
)
</code></pre>

<hr>
<h2 id='buildAssociatedClusterNetwork'>
Build Global Network of Associated TCR/BCR Clusters
</h2><span id='topic+buildAssociatedClusterNetwork'></span>

<h3>Description</h3>

<p>Part of the workflow
<a href="https://mlizhangx.github.io/Network-Analysis-for-Repertoire-Sequencing-/articles/associated_clusters.html">Searching for Associated TCR/BCR Clusters</a>.
Intended for use following
<code><a href="#topic+findAssociatedClones">findAssociatedClones()</a></code>.
</p>
<p>Given data containing a neighborhood of similar clones around each associated sequence,
combines the data into a global network and performs network analysis and cluster
analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildAssociatedClusterNetwork(
  file_list,
  input_type = "rds",
  data_symbols = "data", header = TRUE, sep,
  read.args = list(row.names = 1),
  seq_col,
  min_seq_length = NULL,
  drop_matches = NULL,
  drop_isolated_nodes = FALSE,
  node_stats = TRUE,
  stats_to_include =
    chooseNodeStats(cluster_id = TRUE),
  cluster_stats = TRUE,
  color_nodes_by = "GroupID",
  output_name = "AssociatedClusterNetwork",
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildAssociatedClusterNetwork_+3A_file_list">file_list</code></td>
<td>

<p>A character vector of file paths, or a list containing
<code><a href="base.html#topic+connection">connections</a></code> and file paths.
Each element corresponds to a single file containing the data
for a single sample.
Passed to <code><a href="#topic+loadDataFromFileList">loadDataFromFileList()</a></code>.
</p>
</td></tr>
<tr><td><code id="buildAssociatedClusterNetwork_+3A_input_type">input_type</code></td>
<td>

<p>A character string specifying the file format of the neighborhood data files.
Options are <code>"table"</code>, <code>"txt"</code>, <code>"tsv"</code>, <code>"csv"</code>,
<code>"rds"</code> and <code>"rda"</code>.
Passed to <code><a href="#topic+loadDataFromFileList">loadDataFromFileList()</a></code>.
</p>
</td></tr>
<tr><td><code id="buildAssociatedClusterNetwork_+3A_data_symbols">data_symbols</code></td>
<td>

<p>Used when <code>input_type = "rda"</code>. Specifies the name of each neighborhood's
data frame within its respective Rdata file.  Passed to
<code><a href="#topic+loadDataFromFileList">loadDataFromFileList()</a></code>.
</p>
</td></tr>
<tr><td><code id="buildAssociatedClusterNetwork_+3A_header">header</code></td>
<td>

<p>For values of <code>input_type</code> other than <code>"rds"</code> and <code>"rda"</code>,
this argument is used to specify the value of the <code>header</code>
argument to <code><a href="utils.html#topic+read.table">read.table()</a></code>,
<code><a href="utils.html#topic+read.csv">read.csv()</a></code>, etc.
</p>
</td></tr>
<tr><td><code id="buildAssociatedClusterNetwork_+3A_sep">sep</code></td>
<td>

<p>For values of <code>input_type</code> other than <code>"rds"</code> and <code>"rda"</code>,
this argument can be used to specify a non-default value of the <code>sep</code>
argument to <code><a href="utils.html#topic+read.table">read.table()</a></code>,
<code><a href="utils.html#topic+read.csv">read.csv()</a></code>, etc.
</p>
</td></tr>
<tr><td><code id="buildAssociatedClusterNetwork_+3A_read.args">read.args</code></td>
<td>

<p>For values of <code>input_type</code> other than <code>"rds"</code> and <code>"rda"</code>,
this argument is used to specify values of optional
arguments to <code><a href="utils.html#topic+read.table">read.table()</a></code>,
<code><a href="utils.html#topic+read.csv">read.csv()</a></code>, etc.
Accepts a named list of argument values.
Values of <code>header</code> and <code>sep</code>
in this list take precedence over values specified via the <code>header</code>
and <code>sep</code> arguments.
</p>
</td></tr>
<tr><td><code id="buildAssociatedClusterNetwork_+3A_seq_col">seq_col</code></td>
<td>

<p>Specifies the column of each neighborhood's data frame containing the
TCR/BCR sequences.
Accepts a character string containing the column name
or a numeric scalar containing the column index.
</p>
</td></tr>
<tr><td><code id="buildAssociatedClusterNetwork_+3A_min_seq_length">min_seq_length</code></td>
<td>

<p>Passed to <code><a href="#topic+buildRepSeqNetwork">buildRepSeqNetwork()</a></code>
when constructing the global network.
</p>
</td></tr>
<tr><td><code id="buildAssociatedClusterNetwork_+3A_drop_matches">drop_matches</code></td>
<td>

<p>Passed to <code><a href="#topic+buildRepSeqNetwork">buildRepSeqNetwork()</a></code>
when constructing the global network.
</p>
</td></tr>
<tr><td><code id="buildAssociatedClusterNetwork_+3A_drop_isolated_nodes">drop_isolated_nodes</code></td>
<td>

<p>Passed to <code><a href="#topic+buildRepSeqNetwork">buildRepSeqNetwork()</a></code>
when constructing the global network.
</p>
</td></tr>
<tr><td><code id="buildAssociatedClusterNetwork_+3A_node_stats">node_stats</code></td>
<td>

<p>Passed to <code><a href="#topic+buildRepSeqNetwork">buildRepSeqNetwork()</a></code>
when constructing the global network.
</p>
</td></tr>
<tr><td><code id="buildAssociatedClusterNetwork_+3A_stats_to_include">stats_to_include</code></td>
<td>

<p>Passed to <code><a href="#topic+buildRepSeqNetwork">buildRepSeqNetwork()</a></code>
when constructing the global network.
</p>
</td></tr>
<tr><td><code id="buildAssociatedClusterNetwork_+3A_cluster_stats">cluster_stats</code></td>
<td>

<p>Passed to <code><a href="#topic+buildRepSeqNetwork">buildRepSeqNetwork()</a></code>
when constructing the global network.
</p>
</td></tr>
<tr><td><code id="buildAssociatedClusterNetwork_+3A_color_nodes_by">color_nodes_by</code></td>
<td>

<p>Passed to <code><a href="#topic+buildRepSeqNetwork">buildRepSeqNetwork()</a></code>
when constructing the global network.
</p>
</td></tr>
<tr><td><code id="buildAssociatedClusterNetwork_+3A_output_name">output_name</code></td>
<td>

<p>Passed to <code><a href="#topic+buildRepSeqNetwork">buildRepSeqNetwork()</a></code>
when constructing the global network.
</p>
</td></tr>
<tr><td><code id="buildAssociatedClusterNetwork_+3A_verbose">verbose</code></td>
<td>

<p>Logical. If <code>TRUE</code>, generates messages about the tasks
performed and their progress, as well as relevant properties of intermediate
outputs. Messages are sent to <code><a href="base.html#topic+stderr">stderr()</a></code>.
</p>
</td></tr>
<tr><td><code id="buildAssociatedClusterNetwork_+3A_...">...</code></td>
<td>

<p>Other arguments to <code><a href="#topic+buildRepSeqNetwork">buildRepSeqNetwork()</a></code>
when constructing the global network.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each associated sequence's neighborhood contains clones (from all samples)
with TCR/BCR sequences similar to the associated sequence. The neighborhoods
are assumed to have been previously identified using
<code><a href="#topic+findAssociatedClones">findAssociatedClones()</a></code>.
</p>
<p>The neighborhood data for all associated sequences are used to construct a
single global network. Cluster analysis is used to partition the global network
into clusters, which are considered as the associated TCR/BCR clusters. Network
properties for the nodes and clusters are computed and returned as metadata.
A plot of the global network graph is produced, with the nodes colored according
to the binary variable of interest.
</p>
<p>See the
<a href="https://mlizhangx.github.io/Network-Analysis-for-Repertoire-Sequencing-/articles/associated_clusters.html">Searching for Associated TCR/BCR Clusters</a>
article on the package website for more details.
</p>


<h3>Value</h3>

<p>A list of network objects as returned by
<code><a href="#topic+buildRepSeqNetwork">buildRepSeqNetwork()</a></code>.
The list is returned invisibly.
If the input data contains a combined total of fewer than two rows, or if the
global network contains no nodes, then the function returns <code>NULL</code>,
invisibly, with a warning.
</p>


<h3>Author(s)</h3>

<p>Brian Neal (<a href="mailto:Brian.Neal@ucsf.edu">Brian.Neal@ucsf.edu</a>)
</p>


<h3>References</h3>

<p>Hai Yang, Jason Cham, Brian Neal, Zenghua Fan, Tao He and Li Zhang. (2023).
NAIR: Network Analysis of Immune Repertoire. <em>Frontiers in Immunology</em>, vol. 14.
<a href="https://www.frontiersin.org/articles/10.3389/fimmu.2023.1181825/full">doi: 10.3389/fimmu.2023.1181825</a>
</p>
<p><a href="https://mlizhangx.github.io/Network-Analysis-for-Repertoire-Sequencing-/index.html">Webpage for the NAIR package</a>
</p>
<p><a href="https://mlizhangx.github.io/Network-Analysis-for-Repertoire-Sequencing-/articles/associated_clusters.html">Searching for Associated TCR/BCR Clusters article on package website</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+findAssociatedSeqs">findAssociatedSeqs()</a></code>
<code><a href="#topic+findAssociatedClones">findAssociatedClones()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)

## Simulate 30 samples from two groups (treatment/control) ##
n_control &lt;- n_treatment &lt;- 15
n_samples &lt;- n_control + n_treatment
sample_size &lt;- 30 # (seqs per sample)
base_seqs &lt;- # first five are associated with treatment
  c("CASSGAYEQYF", "CSVDLGKGNNEQFF", "CASSIEGQLSTDTQYF",
    "CASSEEGQLSTDTQYF", "CASSPEGQLSTDTQYF",
    "RASSLAGNTEAFF", "CASSHRGTDTQYF", "CASDAGVFQPQHF")
# Relative generation probabilities by control/treatment group
pgen_c &lt;- matrix(rep(c(rep(1, 5), rep(30, 3)), times = n_control),
                 nrow = n_control, byrow = TRUE)
pgen_t &lt;- matrix(rep(c(1, 1, rep(1/3, 3), rep(2, 3)), times = n_treatment),
                 nrow = n_treatment, byrow = TRUE)
pgen &lt;- rbind(pgen_c, pgen_t)
simulateToyData(
  samples = n_samples,
  sample_size = sample_size,
  prefix_length = 1,
  prefix_chars = c("", ""),
  prefix_probs = cbind(rep(1, n_samples), rep(0, n_samples)),
  affixes = base_seqs,
  affix_probs = pgen,
  num_edits = 0,
  output_dir = tempdir(),
  no_return = TRUE
)

## Step 1: Find Associated Sequences ##
sample_files &lt;-
  file.path(tempdir(),
            paste0("Sample", 1:n_samples, ".rds")
  )
group_labels &lt;- c(rep("reference", n_control),
                  rep("comparison", n_treatment))
associated_seqs &lt;-
  findAssociatedSeqs(
    file_list = sample_files,
    input_type = "rds",
    group_ids = group_labels,
    seq_col = "CloneSeq",
    min_seq_length = NULL,
    drop_matches = NULL,
    min_sample_membership = 0,
    pval_cutoff = 0.1
  )
head(associated_seqs[, 1:5])

## Step 2: Find Associated Clones ##
dir_step2 &lt;- tempfile()
findAssociatedClones(
  file_list = sample_files,
  input_type = "rds",
  group_ids = group_labels,
  seq_col = "CloneSeq",
  assoc_seqs = associated_seqs$ReceptorSeq,
  min_seq_length = NULL,
  drop_matches = NULL,
  output_dir = dir_step2
)

## Step 3: Global Network of Associated Clusters ##
associated_clusters &lt;-
  buildAssociatedClusterNetwork(
    file_list = list.files(dir_step2,
                           full.names = TRUE
    ),
    seq_col = "CloneSeq",
    size_nodes_by = 1.5,
    print_plots = TRUE
  )


</code></pre>

<hr>
<h2 id='buildPublicClusterNetwork'>
Build Global Network of Public TCR/BCR Clusters
</h2><span id='topic+buildPublicClusterNetwork'></span>

<h3>Description</h3>

<p>Part of the workflow
<a href="https://mlizhangx.github.io/Network-Analysis-for-Repertoire-Sequencing-/articles/public_clusters.html">Searching for Public TCR/BCR Clusters</a>.
Intended for use following <code><a href="#topic+findPublicClusters">findPublicClusters()</a></code>.
</p>
<p>Given node-level metadata for each sample's filtered clusters, combines the
data into a global network and performs network analysis and cluster analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildPublicClusterNetwork(

  ## Input ##
  file_list,
  input_type = "rds",
  data_symbols = "ndat",
  header = TRUE, sep,
  read.args = list(row.names = 1),
  seq_col,

  ## Network Settings ##
  drop_isolated_nodes = FALSE,
  node_stats = deprecated(),
  stats_to_include = deprecated(),
  cluster_stats = deprecated(),

  ## Visualization ##
  color_nodes_by = "SampleID",
  color_scheme = "turbo",
  plot_title = "Global Network of Public Clusters",

  ## Output ##
  output_dir = NULL,
  output_name = "PublicClusterNetwork",
  verbose = FALSE,

  ...

)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildPublicClusterNetwork_+3A_file_list">file_list</code></td>
<td>

<p>A character vector of file paths, or a list containing
<code><a href="base.html#topic+connection">connections</a></code> and file paths.
Each element corresponds to a single file containing the data
for a single sample.
<code><a href="#topic+loadDataFromFileList">loadDataFromFileList()</a></code>.
</p>
</td></tr>
<tr><td><code id="buildPublicClusterNetwork_+3A_input_type">input_type</code></td>
<td>

<p>A character string specifying the file format of the input files. Options are
<code>"csv"</code>, <code>"rds"</code> and <code>"rda"</code>. Passed to
<code><a href="#topic+loadDataFromFileList">loadDataFromFileList()</a></code>.
</p>
</td></tr>
<tr><td><code id="buildPublicClusterNetwork_+3A_data_symbols">data_symbols</code></td>
<td>

<p>Used when <code>input_type = "rda"</code>. Specifies the name of the data frame within
each Rdata file. Passed to
<code><a href="#topic+loadDataFromFileList">loadDataFromFileList()</a></code>.
</p>
</td></tr>
<tr><td><code id="buildPublicClusterNetwork_+3A_header">header</code></td>
<td>

<p>For values of <code>input_type</code> other than <code>"rds"</code> and <code>"rda"</code>,
this argument can be used to specify a non-default value of the <code>header</code>
argument to <code><a href="utils.html#topic+read.table">read.table()</a></code>,
<code><a href="utils.html#topic+read.csv">read.csv()</a></code>, etc.
</p>
</td></tr>
<tr><td><code id="buildPublicClusterNetwork_+3A_sep">sep</code></td>
<td>

<p>For values of <code>input_type</code> other than <code>"rds"</code> and <code>"rda"</code>,
this argument can be used to specify a non-default value of the <code>sep</code>
argument to <code><a href="utils.html#topic+read.table">read.table()</a></code>,
<code><a href="utils.html#topic+read.csv">read.csv()</a></code>, etc.
</p>
</td></tr>
<tr><td><code id="buildPublicClusterNetwork_+3A_read.args">read.args</code></td>
<td>

<p>For values of <code>input_type</code> other than <code>"rds"</code> and <code>"rda"</code>,
this argument can be used to specify non-default values of optional
arguments to <code><a href="utils.html#topic+read.table">read.table()</a></code>,
<code><a href="utils.html#topic+read.csv">read.csv()</a></code>, etc.
Accepts a named list of argument values.
Values of <code>header</code> and <code>sep</code>
in this list take precedence over values specified via the <code>header</code>
and <code>sep</code> arguments.
</p>
</td></tr>
<tr><td><code id="buildPublicClusterNetwork_+3A_seq_col">seq_col</code></td>
<td>

<p>Specifies the column in the node-level metadata that contains the TCR/BCR
sequences.
Accepts a character string containing the column name
or a numeric scalar containing the column index.
</p>
</td></tr>
<tr><td><code id="buildPublicClusterNetwork_+3A_drop_isolated_nodes">drop_isolated_nodes</code></td>
<td>

<p>Passed to <code><a href="#topic+buildRepSeqNetwork">buildRepSeqNetwork()</a></code>
when constructing the global network.
</p>
</td></tr>
<tr><td><code id="buildPublicClusterNetwork_+3A_node_stats">node_stats</code></td>
<td>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
All network properties are automatically computed.
</p>
</td></tr>
<tr><td><code id="buildPublicClusterNetwork_+3A_stats_to_include">stats_to_include</code></td>
<td>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
All network properties are automatically computed.
</p>
</td></tr>
<tr><td><code id="buildPublicClusterNetwork_+3A_cluster_stats">cluster_stats</code></td>
<td>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
All network properties are automatically computed.
</p>
</td></tr>
<tr><td><code id="buildPublicClusterNetwork_+3A_color_nodes_by">color_nodes_by</code></td>
<td>

<p>Passed to <code><a href="#topic+buildRepSeqNetwork">buildRepSeqNetwork()</a></code>
when constructing the global network.
The node-level network properties for the global network (see details) are
included among the valid options.
</p>
</td></tr>
<tr><td><code id="buildPublicClusterNetwork_+3A_color_scheme">color_scheme</code></td>
<td>

<p>Passed to <code><a href="#topic+addPlots">addPlots()</a></code>
when constructing the global network.
</p>
</td></tr>
<tr><td><code id="buildPublicClusterNetwork_+3A_plot_title">plot_title</code></td>
<td>

<p>Passed to <code><a href="#topic+buildRepSeqNetwork">buildRepSeqNetwork()</a></code>
when constructing the global network.
</p>
</td></tr>
<tr><td><code id="buildPublicClusterNetwork_+3A_output_dir">output_dir</code></td>
<td>

<p>Passed to <code><a href="#topic+buildRepSeqNetwork">buildRepSeqNetwork()</a></code>
when constructing the global network.
</p>
</td></tr>
<tr><td><code id="buildPublicClusterNetwork_+3A_output_name">output_name</code></td>
<td>

<p>Passed to <code><a href="#topic+buildRepSeqNetwork">buildRepSeqNetwork()</a></code>
when constructing the global network.
</p>
</td></tr>
<tr><td><code id="buildPublicClusterNetwork_+3A_verbose">verbose</code></td>
<td>

<p>Logical. If <code>TRUE</code>, generates messages about the tasks
performed and their progress, as well as relevant properties of intermediate
outputs. Messages are sent to <code><a href="base.html#topic+stderr">stderr()</a></code>.
</p>
</td></tr>
<tr><td><code id="buildPublicClusterNetwork_+3A_...">...</code></td>
<td>

<p>Other arguments to <code><a href="#topic+buildRepSeqNetwork">buildRepSeqNetwork()</a></code>
(including arguments to <code><a href="#topic+addPlots">addPlots()</a></code>)
when constructing the global network.
Does not include
<code>node_stats</code>, <code>stats_to_include</code>, <code>cluster_stats</code>
or <code>cluster_id_name</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The node-level metadata for the filtered clusters from all samples is combined
and the global network is constructed by calling
<code><a href="#topic+buildRepSeqNetwork">buildNet()</a></code> with
<code>node_stats = TRUE</code>, <code>stats_to_include = "all"</code>,
<code>cluster_stats = TRUE</code> and <code>cluster_id_name = "ClusterIDPublic"</code>.
</p>
<p>The computed node-level network properties are renamed to reflect their
correspondence to the global network. This is done to distinguish them from
the network properties that correspond to the sample-level networks. The names
are:
</p>

<ul>
<li> <p><code>ClusterIDPublic</code>
</p>
</li>
<li> <p><code>PublicNetworkDegree</code>
</p>
</li>
<li> <p><code>PublicTransitivity</code>
</p>
</li>
<li> <p><code>PublicCloseness</code>
</p>
</li>
<li> <p><code>PublicCentralityByCloseness</code>
</p>
</li>
<li> <p><code>PublicEigenCentrality</code>
</p>
</li>
<li> <p><code>PublicCentralityByEigen</code>
</p>
</li>
<li> <p><code>PublicBetweenness</code>
</p>
</li>
<li> <p><code>PublicCentralityByBetweenness</code>
</p>
</li>
<li> <p><code>PublicAuthorityScore</code>
</p>
</li>
<li> <p><code>PublicCoreness</code>
</p>
</li>
<li> <p><code>PublicPageRank</code>
</p>
</li></ul>

<p>See the
<a href="https://mlizhangx.github.io/Network-Analysis-for-Repertoire-Sequencing-/articles/public_clusters.html">Searching for Public TCR/BCR Clusters</a>
article on the package website.
</p>


<h3>Value</h3>

<p>A list of network objects as returned by
<code><a href="#topic+buildRepSeqNetwork">buildRepSeqNetwork()</a></code>.
The list is returned invisibly.
If the input data contains a combined total of fewer than two rows, or if the
global network contains no nodes, then the function returns <code>NULL</code>,
invisibly, with a warning.
</p>


<h3>Author(s)</h3>

<p>Brian Neal (<a href="mailto:Brian.Neal@ucsf.edu">Brian.Neal@ucsf.edu</a>)
</p>


<h3>References</h3>

<p>Hai Yang, Jason Cham, Brian Neal, Zenghua Fan, Tao He and Li Zhang. (2023).
NAIR: Network Analysis of Immune Repertoire. <em>Frontiers in Immunology</em>, vol. 14.
<a href="https://www.frontiersin.org/articles/10.3389/fimmu.2023.1181825/full">doi: 10.3389/fimmu.2023.1181825</a>
</p>
<p><a href="https://mlizhangx.github.io/Network-Analysis-for-Repertoire-Sequencing-/index.html">Webpage for the NAIR package</a>
</p>
<p><a href="https://mlizhangx.github.io/Network-Analysis-for-Repertoire-Sequencing-/articles/public_clusters.html">Searching for Public TCR/BCR Clusters article on package website</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+findPublicClusters">findPublicClusters()</a></code>
</p>
<p><code><a href="#topic+buildPublicClusterNetworkByRepresentative">buildPublicClusterNetworkByRepresentative()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)

## Simulate 30 samples with a mix of public/private sequences ##
samples &lt;- 30
sample_size &lt;- 30 # (seqs per sample)
base_seqs &lt;- c(
  "CASSIEGQLSTDTQYF", "CASSEEGQLSTDTQYF", "CASSSVETQYF",
  "CASSPEGQLSTDTQYF", "RASSLAGNTEAFF", "CASSHRGTDTQYF", "CASDAGVFQPQHF",
  "CASSLTSGYNEQFF", "CASSETGYNEQFF", "CASSLTGGNEQFF", "CASSYLTGYNEQFF",
  "CASSLTGNEQFF", "CASSLNGYNEQFF", "CASSFPWDGYGYTF", "CASTLARQGGELFF",
  "CASTLSRQGGELFF", "CSVELLPTGPLETSYNEQFF", "CSVELLPTGPSETSYNEQFF",
  "CVELLPTGPSETSYNEQFF", "CASLAGGRTQETQYF", "CASRLAGGRTQETQYF",
  "CASSLAGGRTETQYF", "CASSLAGGRTQETQYF", "CASSRLAGGRTQETQYF",
  "CASQYGGGNQPQHF", "CASSLGGGNQPQHF", "CASSNGGGNQPQHF", "CASSYGGGGNQPQHF",
  "CASSYGGGQPQHF", "CASSYKGGNQPQHF", "CASSYTGGGNQPQHF",
  "CAWSSQETQYF", "CASSSPETQYF", "CASSGAYEQYF", "CSVDLGKGNNEQFF")
# Relative generation probabilities
pgen &lt;- cbind(
  stats::toeplitz(0.6^(0:(sample_size - 1))),
  matrix(1, nrow = samples, ncol = length(base_seqs) - samples)
)
simulateToyData(
  samples = samples,
  sample_size = sample_size,
  prefix_length = 1,
  prefix_chars = c("", ""),
  prefix_probs = cbind(rep(1, samples), rep(0, samples)),
  affixes = base_seqs,
  affix_probs = pgen,
  num_edits = 0,
  output_dir = tempdir(),
  no_return = TRUE
)


## 1. Find Public Clusters in Each Sample
sample_files &lt;-
  file.path(tempdir(),
            paste0("Sample", 1:samples, ".rds")
  )
findPublicClusters(
  file_list = sample_files,
  input_type = "rds",
  seq_col = "CloneSeq",
  count_col = "CloneCount",
  min_seq_length = NULL,
  drop_matches = NULL,
  top_n_clusters = 3,
  min_node_count = 5,
  min_clone_count = 15000,
  output_dir = tempdir()
)

## 2. Build Global Network of Public Clusters
public_clusters &lt;-
  buildPublicClusterNetwork(
    file_list =
      list.files(
        file.path(tempdir(), "node_meta_data"),
        full.names = TRUE
      ),
    seq_col = "CloneSeq",
    count_col = "CloneCount",
    plot_title = NULL,
    plot_subtitle = NULL,
    print_plots = TRUE
  )



</code></pre>

<hr>
<h2 id='buildPublicClusterNetworkByRepresentative'>
Build Global Network of Public TCR/BCR Clusters Using Representative Clones
</h2><span id='topic+buildPublicClusterNetworkByRepresentative'></span>

<h3>Description</h3>

<p>Alternative step in the workflow
<a href="https://mlizhangx.github.io/Network-Analysis-for-Repertoire-Sequencing-/articles/public_clusters.html">Searching for Public TCR/BCR Clusters</a>.
Intended for use following <code><a href="#topic+findPublicClusters">findPublicClusters()</a></code>
in cases where
<code><a href="#topic+buildPublicClusterNetwork">buildPublicClusterNetwork()</a></code>
cannot be practically used due to the size of the full global network.
</p>
<p>Given cluster-level metadata for each sample's filtered clusters, selects a
representative TCR/BCR from each cluster, combines the representatives into a
global network and performs network analysis and cluster analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildPublicClusterNetworkByRepresentative(

  ## Input ##
  file_list,
  input_type = "rds",
  data_symbols = "cdat",
  header, sep, read.args,
  seq_col = "seq_w_max_count",
  count_col = "agg_count",

  ## Network Settings ##
  dist_type = "hamming",
  dist_cutoff = 1,
  cluster_fun = "fast_greedy",

  ## Visualization ##
  plots = TRUE,
  print_plots = FALSE,
  plot_title = "auto",
  plot_subtitle = "auto",
  color_nodes_by = "SampleID",
  color_scheme = "turbo",
  ...,

  ## Output ##
  output_dir = NULL,
  output_type = "rds",
  output_name = "PubClustByRepresentative",
  pdf_width = 12,
  pdf_height = 10,
  verbose = FALSE

)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildPublicClusterNetworkByRepresentative_+3A_file_list">file_list</code></td>
<td>

<p>A vector of file paths where each file contains the cluster-level metadata for
one sample's filtered clusters.
Passed to <code><a href="#topic+loadDataFromFileList">loadDataFromFileList()</a></code>.
</p>
</td></tr>
<tr><td><code id="buildPublicClusterNetworkByRepresentative_+3A_input_type">input_type</code></td>
<td>

<p>A character string specifying the file format of the input files. Options are
<code>"csv"</code>, <code>"rds"</code> and <code>"rda"</code>. Passed to
<code><a href="#topic+loadDataFromFileList">loadDataFromFileList()</a></code>.
</p>
</td></tr>
<tr><td><code id="buildPublicClusterNetworkByRepresentative_+3A_data_symbols">data_symbols</code></td>
<td>

<p>Used when <code>input_type = "rda"</code>. Specifies the name of the data frame
within each Rdata file.
Passed to <code><a href="#topic+loadDataFromFileList">loadDataFromFileList()</a></code>.
</p>
</td></tr>
<tr><td><code id="buildPublicClusterNetworkByRepresentative_+3A_header">header</code></td>
<td>

<p>For values of <code>input_type</code> other than <code>"rds"</code> and <code>"rda"</code>,
this argument can be used to specify a non-default value of the <code>header</code>
argument to <code><a href="utils.html#topic+read.table">read.table()</a></code>,
<code><a href="utils.html#topic+read.csv">read.csv()</a></code>, etc.
</p>
</td></tr>
<tr><td><code id="buildPublicClusterNetworkByRepresentative_+3A_sep">sep</code></td>
<td>

<p>For values of <code>input_type</code> other than <code>"rds"</code> and <code>"rda"</code>,
this argument can be used to specify a non-default value of the <code>sep</code>
argument to <code><a href="utils.html#topic+read.table">read.table()</a></code>,
<code><a href="utils.html#topic+read.csv">read.csv()</a></code>, etc.
</p>
</td></tr>
<tr><td><code id="buildPublicClusterNetworkByRepresentative_+3A_read.args">read.args</code></td>
<td>

<p>For values of <code>input_type</code> other than <code>"rds"</code> and <code>"rda"</code>,
this argument can be used to specify non-default values of optional
arguments to <code><a href="utils.html#topic+read.table">read.table()</a></code>,
<code><a href="utils.html#topic+read.csv">read.csv()</a></code>, etc.
Accepts a named list of argument values.
Values of <code>header</code> and <code>sep</code>
in this list take precedence over values specified via the <code>header</code>
and <code>sep</code> arguments.
</p>
</td></tr>
<tr><td><code id="buildPublicClusterNetworkByRepresentative_+3A_seq_col">seq_col</code></td>
<td>

<p>Specifies the column in the cluster-level metadata that contains the
representative TCR/BCR sequence for each cluster.
Accepts a character string containing the column name
or a numeric scalar containing the column index.
By default, uses the sequence with the maximum clone
count in each cluster.
</p>
</td></tr>
<tr><td><code id="buildPublicClusterNetworkByRepresentative_+3A_count_col">count_col</code></td>
<td>

<p>Specifies the column in the cluster-level metadata that contains the aggregate
clone count for each cluster.
Accepts a character string containing the column name
or a numeric scalar containing the column index.
</p>
</td></tr>
<tr><td><code id="buildPublicClusterNetworkByRepresentative_+3A_dist_type">dist_type</code></td>
<td>

<p>Passed to <code><a href="#topic+buildRepSeqNetwork">buildRepSeqNetwork()</a></code>
when constructing the global network.
</p>
</td></tr>
<tr><td><code id="buildPublicClusterNetworkByRepresentative_+3A_dist_cutoff">dist_cutoff</code></td>
<td>

<p>Passed to <code><a href="#topic+buildRepSeqNetwork">buildRepSeqNetwork()</a></code>
when constructing the global network.
</p>
</td></tr>
<tr><td><code id="buildPublicClusterNetworkByRepresentative_+3A_cluster_fun">cluster_fun</code></td>
<td>

<p>Passed to <code><a href="#topic+buildRepSeqNetwork">buildRepSeqNetwork()</a></code>
when performing cluster analysis on the global network.
</p>
</td></tr>
<tr><td><code id="buildPublicClusterNetworkByRepresentative_+3A_plots">plots</code></td>
<td>

<p>Logical. Should plots of the global network graph be produced?
</p>
</td></tr>
<tr><td><code id="buildPublicClusterNetworkByRepresentative_+3A_print_plots">print_plots</code></td>
<td>

<p>Logical. If plots of the global network graph are produced, should they be
printed to the R plotting window?
</p>
</td></tr>
<tr><td><code id="buildPublicClusterNetworkByRepresentative_+3A_plot_title">plot_title</code></td>
<td>

<p>Passed to <code><a href="#topic+addPlots">addPlots()</a></code> when producing plots of the
global network graph.
</p>
</td></tr>
<tr><td><code id="buildPublicClusterNetworkByRepresentative_+3A_plot_subtitle">plot_subtitle</code></td>
<td>

<p>Passed to <code><a href="#topic+addPlots">addPlots()</a></code> when producing plots of the
global network graph.
</p>
</td></tr>
<tr><td><code id="buildPublicClusterNetworkByRepresentative_+3A_color_nodes_by">color_nodes_by</code></td>
<td>

<p>Passed to <code><a href="#topic+addPlots">addPlots()</a></code> when producing plots of the
global network graph. Valid options include the default <code>"SampleID"</code>,
as well as node-level properties (see <code><a href="#topic+addNodeNetworkStats">addNodeNetworkStats</a></code>) and
sample-level cluster properties (see <code><a href="#topic+getClusterStats">getClusterStats</a></code>), which
correspond to the representative TCRs/BCRs and the original sample-level clusters
they represent, respectively.
</p>
</td></tr>
<tr><td><code id="buildPublicClusterNetworkByRepresentative_+3A_color_scheme">color_scheme</code></td>
<td>

<p>Passed to <code><a href="#topic+addPlots">addPlots()</a></code> when producing plots of the
global network graph.
</p>
</td></tr>
<tr><td><code id="buildPublicClusterNetworkByRepresentative_+3A_...">...</code></td>
<td>

<p>Other arguments to <code><a href="#topic+addPlots">addPlots()</a></code> when producing plots
of the global network graph.
</p>
</td></tr>
<tr><td><code id="buildPublicClusterNetworkByRepresentative_+3A_output_dir">output_dir</code></td>
<td>

<p>Passed to <code><a href="#topic+saveNetwork">saveNetwork()</a></code> after constructing the global network.
</p>
</td></tr>
<tr><td><code id="buildPublicClusterNetworkByRepresentative_+3A_output_type">output_type</code></td>
<td>

<p>Passed to <code><a href="#topic+saveNetwork">saveNetwork()</a></code> after constructing the global network.
</p>
</td></tr>
<tr><td><code id="buildPublicClusterNetworkByRepresentative_+3A_output_name">output_name</code></td>
<td>

<p>Passed to <code><a href="#topic+saveNetwork">saveNetwork()</a></code> after constructing the global network.
</p>
</td></tr>
<tr><td><code id="buildPublicClusterNetworkByRepresentative_+3A_pdf_width">pdf_width</code></td>
<td>

<p>Passed to <code><a href="#topic+saveNetwork">saveNetwork()</a></code> after constructing the global network.
Only applicable if <code>plots = TRUE</code>.
</p>
</td></tr>
<tr><td><code id="buildPublicClusterNetworkByRepresentative_+3A_pdf_height">pdf_height</code></td>
<td>

<p>Passed to <code><a href="#topic+saveNetwork">saveNetwork()</a></code> after constructing the global network.
Only applicable if <code>plots = TRUE</code>.
</p>
</td></tr>
<tr><td><code id="buildPublicClusterNetworkByRepresentative_+3A_verbose">verbose</code></td>
<td>

<p>Logical. If <code>TRUE</code>, generates messages about the tasks
performed and their progress, as well as relevant properties of intermediate
outputs. Messages are sent to <code><a href="base.html#topic+stderr">stderr()</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>From each filtered cluster in each sample's network, a representative TCR/BCR
is selected. By default, this is the sequence with the greatest clone count in
each cluster. The representatives from all clusters and all samples are then
used to construct a single global network. Cluster analysis is used to partition
this global network into clusters. Network properties for the nodes and clusters
are computed and returned as metadata. A plot of the global network graph is
produced, with the nodes colored according to sample ID.
</p>
<p>Within this network, clusters containing nodes from multiple samples can be
considered as the skeletons of the complete public clusters. The filtered cluster
data for each sample can then be subset to keep the sample-level clusters whose
representative TCR/BCRs belong to the skeletons of the public clusters. After
subsetting in this manner,
<code><a href="#topic+buildPublicClusterNetwork">buildPublicClusterNetwork()</a></code> can be used
to construct the global network of complete public clusters.
</p>
<p>See the
<a href="https://mlizhangx.github.io/Network-Analysis-for-Repertoire-Sequencing-/articles/public_clusters.html">Searching for Public TCR/BCR Clusters</a>
article on the package website.
</p>


<h3>Value</h3>

<p>If the input data contains a combined total of fewer than two rows, or if the
global network contains no nodes, then the function returns <code>NULL</code>,
invisibly, with a warning. Otherwise, invisibly returns
a list of network objects as returned by
<code><a href="#topic+buildRepSeqNetwork">buildRepSeqNetwork()</a></code>.
The global cluster membership variable in the data frame <code>node_data</code>
is named <code>ClusterIDPublic</code>.
</p>
<p>The data frame <code>cluster_data</code> includes the following variables that
represent properties of the clusters in the global network of representative
TCR/BCRs:
</p>
<table>
<tr><td><code>cluster_id</code></td>
<td>

<p>The global cluster ID number.</p>
</td></tr>
<tr><td><code>node_count</code></td>
<td>

<p>The number of global network nodes in the global cluster.</p>
</td></tr>
<tr><td><code>TotalSampleLevelNodes</code></td>
<td>

<p>For each representative TCR/BCR in the global cluster, we record the number
of nodes in the sample-level cluster for which it is the representative TCR/BCR.
We then sum these node counts across all the representative TCR/BCRs in the
global cluster.</p>
</td></tr>
<tr><td><code>TotalCloneCount</code></td>
<td>

<p>For each representative TCR/BCR in the global cluster, we record the
aggregate clone count from all nodes in the sample-level cluster for which
it is the representative TCR/BCR. We then sum these aggregate clone counts
across all the representative TCR/BCRs in the global cluster.</p>
</td></tr>
<tr><td><code>MeanOfMeanSeqLength</code></td>
<td>

<p>For each representative TCR/BCR in the global cluster, we record the mean
sequence length over all clones (nodes) in the sample-level cluster for which
it is the representative TCR/BCR. We then average these mean sequence lengths
over all the representative TCR/BCRs in the global cluster.</p>
</td></tr>
<tr><td><code>MeanDegreeInPublicNet</code></td>
<td>

<p>For each representative TCR/BCR in the global cluster, we record the mean
network degree over all nodes in the sample-level cluster for which it is the
representative TCR/BCR. We then average these mean degree values over all the
representative TCR/BCRs in the global cluster.</p>
</td></tr>
<tr><td><code>MaxDegreeInPublicNet</code></td>
<td>

<p>For each representative TCR/BCR in the global cluster, we record the maximum
network degree across all nodes in the sample-level cluster for which it is
the representative TCR/BCR. We then take the maximum of these maximum degree
values over all the representative TCR/BCRs in the global cluster.</p>
</td></tr>
<tr><td><code>SeqWithMaxDegree</code></td>
<td>

<p>For each representative TCR/BCR in the global cluster, we record the maximum
network degree across all nodes in the sample-level cluster for which it is
the representative TCR/BCR. We then identify the representative TCR/BCR with
the maximum value of these maximum degrees over all the representative TCR/BCRs
in the global cluster. The TCR/BCR sequence of the identified representative
TCR/BCR is recorded in this variable.</p>
</td></tr>
<tr><td><code>MaxCloneCount</code></td>
<td>

<p>For each representative TCR/BCR in the global cluster, we record the maximum
clone count across all clones (nodes) in the sample-level cluster for which
it is the representative TCR/BCR. We then take the maximum of these maximum
clone counts over all the representative TCR/BCRs in the global cluster.</p>
</td></tr>
<tr><td><code>SampleWithMaxCloneCount</code></td>
<td>

<p>For each representative TCR/BCR in the global cluster, we record the maximum
clone count across all clones (nodes) in the sample-level cluster for which
it is the representative TCR/BCR. We then identify the representative TCR/BCR
with the maximum value of these maximum clone counts over all the representative
TCR/BCRs in the global cluster. The sample to which the identified representative
TCR/BCR belongs is recorded in this variable.</p>
</td></tr>
<tr><td><code>SeqWithMaxCloneCount</code></td>
<td>

<p>For each representative TCR/BCR in the global cluster, we record the maximum
clone count across all clones (nodes) in the sample-level cluster for which it
is the representative TCR/BCR. We then identify the representative TCR/BCR with
the maximum value of these maximum clone counts over all the representative
TCR/BCRs in the global cluster. The TCR/BCR sequence of the identified
representative TCR/BCR is recorded in this variable.</p>
</td></tr>
<tr><td><code>MaxAggCloneCount</code></td>
<td>

<p>For each representative TCR/BCR in the global cluster, we record the
aggregate clone count across all clones (nodes) in the sample-level cluster
for which it is the representative TCR/BCR. We then take the maximum of these
aggregate clone counts over all the representative TCR/BCRs in the global
cluster.</p>
</td></tr>
<tr><td><code>SampleWithMaxAggCloneCount</code></td>
<td>

<p>For each representative TCR/BCR in the global cluster, we record the
aggregate clone count across all clones (nodes) in the sample-level cluster
for which it is the representative TCR/BCR. We then identify the representative
TCR/BCR with the maximum value of these aggregate clone counts over all the
representative TCR/BCRs in the global cluster. The sample to which the
identified representative TCR/BCR belongs is recorded in this variable.</p>
</td></tr>
<tr><td><code>SeqWithMaxAggCloneCount</code></td>
<td>

<p>For each representative TCR/BCR in the global cluster, we record the
aggregate clone count across all clones (nodes) in the sample-level cluster
for which it is the representative TCR/BCR. We then identify the representative
TCR/BCR with the maximum value of these aggregate clone counts over all the
representative TCR/BCRs in the global cluster. The TCR/BCR sequence of the
identified representative TCR/BCR is recorded in this variable.</p>
</td></tr>
<tr><td><code>DiameterLength</code></td>
<td>

<p>See <code><a href="#topic+getClusterStats">getClusterStats</a></code>.
Based on edge connections between representative TCR/BCRs in the global cluster.
</p>
</td></tr>
<tr><td><code>Assortativity</code></td>
<td>

<p>See <code><a href="#topic+getClusterStats">getClusterStats</a></code>.
Based on edge connections between representative TCR/BCRs in the global cluster.
</p>
</td></tr>
<tr><td><code>GlobalTransitivity</code></td>
<td>

<p>See <code><a href="#topic+getClusterStats">getClusterStats</a></code>.
Based on edge connections between representative TCR/BCRs in the global cluster.
</p>
</td></tr>
<tr><td><code>EdgeDensity</code></td>
<td>

<p>See <code><a href="#topic+getClusterStats">getClusterStats</a></code>.
Based on edge connections between representative TCR/BCRs in the global cluster.
</p>
</td></tr>
<tr><td><code>DegreeCentralityIndex</code></td>
<td>

<p>See <code><a href="#topic+getClusterStats">getClusterStats</a></code>.
Based on edge connections between representative TCR/BCRs in the global cluster.
</p>
</td></tr>
<tr><td><code>ClosenessCentralityIndex</code></td>
<td>

<p>See <code><a href="#topic+getClusterStats">getClusterStats</a></code>.
Based on edge connections between representative TCR/BCRs in the global cluster.
</p>
</td></tr>
<tr><td><code>EigenCentralityIndex</code></td>
<td>

<p>See <code><a href="#topic+getClusterStats">getClusterStats</a></code>.
Based on edge connections between representative TCR/BCRs in the global cluster.
</p>
</td></tr>
<tr><td><code>EigenCentralityEigenvalue</code></td>
<td>

<p>See <code><a href="#topic+getClusterStats">getClusterStats</a></code>.
Based on edge connections between representative TCR/BCRs in the global cluster.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Brian Neal (<a href="mailto:Brian.Neal@ucsf.edu">Brian.Neal@ucsf.edu</a>)
</p>


<h3>References</h3>

<p>Hai Yang, Jason Cham, Brian Neal, Zenghua Fan, Tao He and Li Zhang. (2023).
NAIR: Network Analysis of Immune Repertoire. <em>Frontiers in Immunology</em>, vol. 14.
<a href="https://www.frontiersin.org/articles/10.3389/fimmu.2023.1181825/full">doi: 10.3389/fimmu.2023.1181825</a>
</p>
<p><a href="https://mlizhangx.github.io/Network-Analysis-for-Repertoire-Sequencing-/index.html">Webpage for the NAIR package</a>
</p>
<p><a href="https://mlizhangx.github.io/Network-Analysis-for-Repertoire-Sequencing-/articles/public_clusters.html">Searching for Public TCR/BCR Clusters article on package website</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+findPublicClusters">findPublicClusters()</a></code>
<code><a href="#topic+buildPublicClusterNetwork">buildPublicClusterNetwork()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)

## Simulate 30 samples with a mix of public/private sequences ##
samples &lt;- 30
sample_size &lt;- 30 # (seqs per sample)
base_seqs &lt;- c(
  "CASSIEGQLSTDTQYF", "CASSEEGQLSTDTQYF", "CASSSVETQYF",
  "CASSPEGQLSTDTQYF", "RASSLAGNTEAFF", "CASSHRGTDTQYF", "CASDAGVFQPQHF",
  "CASSLTSGYNEQFF", "CASSETGYNEQFF", "CASSLTGGNEQFF", "CASSYLTGYNEQFF",
  "CASSLTGNEQFF", "CASSLNGYNEQFF", "CASSFPWDGYGYTF", "CASTLARQGGELFF",
  "CASTLSRQGGELFF", "CSVELLPTGPLETSYNEQFF", "CSVELLPTGPSETSYNEQFF",
  "CVELLPTGPSETSYNEQFF", "CASLAGGRTQETQYF", "CASRLAGGRTQETQYF",
  "CASSLAGGRTETQYF", "CASSLAGGRTQETQYF", "CASSRLAGGRTQETQYF",
  "CASQYGGGNQPQHF", "CASSLGGGNQPQHF", "CASSNGGGNQPQHF", "CASSYGGGGNQPQHF",
  "CASSYGGGQPQHF", "CASSYKGGNQPQHF", "CASSYTGGGNQPQHF",
  "CAWSSQETQYF", "CASSSPETQYF", "CASSGAYEQYF", "CSVDLGKGNNEQFF")
# Relative generation probabilities
pgen &lt;- cbind(
  stats::toeplitz(0.6^(0:(sample_size - 1))),
  matrix(1, nrow = samples, ncol = length(base_seqs) - samples)
)
simulateToyData(
  samples = samples,
  sample_size = sample_size,
  prefix_length = 1,
  prefix_chars = c("", ""),
  prefix_probs = cbind(rep(1, samples), rep(0, samples)),
  affixes = base_seqs,
  affix_probs = pgen,
  num_edits = 0,
  output_dir = tempdir(),
  no_return = TRUE
)


## 1. Find Public Clusters in Each Sample
sample_files &lt;-
  file.path(tempdir(),
            paste0("Sample", 1:samples, ".rds")
  )
findPublicClusters(
  file_list = sample_files,
  input_type = "rds",
  seq_col = "CloneSeq",
  count_col = "CloneCount",
  min_seq_length = NULL,
  drop_matches = NULL,
  top_n_clusters = 3,
  min_node_count = 5,
  min_clone_count = 15000,
  output_dir = tempdir()
)

## 2. Build Public Cluster Network by Representative TCR/BCRs
buildPublicClusterNetworkByRepresentative(
  file_list =
    list.files(
      file.path(tempdir(), "cluster_meta_data"),
      full.names = TRUE
    ),
  size_nodes_by = 1,
  print_plots = TRUE
)


</code></pre>

<hr>
<h2 id='buildRepSeqNetwork'>
Network Analysis of Immune Repertoire
</h2><span id='topic+buildRepSeqNetwork'></span><span id='topic+buildNet'></span>

<h3>Description</h3>

<p>Given Adaptive Immune Receptor Repertoire Sequencing (AIRR-Seq) data, builds
the network graph for the immune repertoire based on sequence similarity,
computes specified network properties and generates customized visualizations.
</p>
<p><code>buildNet()</code> is identical to <code>buildRepSeqNetwork()</code>, existing as
an alias for convenience.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildRepSeqNetwork(

  ## Input ##
  data,
  seq_col,
  count_col = NULL,
  subset_cols = NULL,
  min_seq_length = 3,
  drop_matches = NULL,

  ## Network ##
  dist_type = "hamming",
  dist_cutoff = 1,
  drop_isolated_nodes = TRUE,
  node_stats = FALSE,
  stats_to_include = chooseNodeStats(),
  cluster_stats = FALSE,
  cluster_fun = "fast_greedy",
  cluster_id_name = "cluster_id",

  ## Visualization ##
  plots = TRUE,
  print_plots = FALSE,
  plot_title = "auto",
  plot_subtitle = "auto",
  color_nodes_by = "auto",
  ...,

  ## Output ##
  output_dir = NULL,
  output_type = "rds",
  output_name = "MyRepSeqNetwork",
  pdf_width = 12,
  pdf_height = 10,
  verbose = FALSE

)

# Alias for buildRepSeqNetwork()
buildNet(
  data,
  seq_col,
  count_col = NULL,
  subset_cols = NULL,
  min_seq_length = 3,
  drop_matches = NULL,
  dist_type = "hamming",
  dist_cutoff = 1,
  drop_isolated_nodes = TRUE,
  node_stats = FALSE,
  stats_to_include = chooseNodeStats(),
  cluster_stats = FALSE,
  cluster_fun = "fast_greedy",
  cluster_id_name = "cluster_id",
  plots = TRUE,
  print_plots = FALSE,
  plot_title = "auto",
  plot_subtitle = "auto",
  color_nodes_by = "auto",
  ...,
  output_dir = NULL,
  output_type = "rds",
  output_name = "MyRepSeqNetwork",
  pdf_width = 12,
  pdf_height = 10,
  verbose = FALSE

)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildRepSeqNetwork_+3A_data">data</code></td>
<td>

<p>A data frame containing the AIRR-Seq data, with variables indexed by column
and observations (e.g., clones or cells) indexed by row.
</p>
</td></tr>
<tr><td><code id="buildRepSeqNetwork_+3A_seq_col">seq_col</code></td>
<td>

<p>Specifies the column(s) of <code>data</code> containing
the receptor sequences to be used as the basis of similarity between rows.
Accepts a character string containing the column name
or a numeric scalar containing the column index.
Also accepts a vector of length 2 specifying distinct sequence columns
(e.g., alpha chain and beta chain), in which case
similarity between rows depends on similarity in both sequence columns
(see details).
</p>
</td></tr>
<tr><td><code id="buildRepSeqNetwork_+3A_count_col">count_col</code></td>
<td>

<p>Optional. Specifies the column of <code>data</code> containing a measure of abundance,
e.g., clone count or unique molecular identifier (UMI) count. Accepts either
the column name or column index. Passed to
<code><a href="#topic+addClusterStats">addClusterStats()</a></code>; only
relevant if <code>cluster_stats = TRUE</code>.
</p>
</td></tr>
<tr><td><code id="buildRepSeqNetwork_+3A_subset_cols">subset_cols</code></td>
<td>

<p>Specifies which columns of the AIRR-Seq data are included in the output.
Accepts a vector of column names or a vector of column indices. The default
<code>NULL</code> includes all columns. The receptor sequence column is always
included regardless of this argument's value.
Passed to <code><a href="#topic+filterInputData">filterInputData()</a></code>.
</p>
</td></tr>
<tr><td><code id="buildRepSeqNetwork_+3A_min_seq_length">min_seq_length</code></td>
<td>

<p>A numeric scalar, or <code>NULL</code>. Observations whose receptor sequences have
fewer than <code>min_seq_length</code> characters are removed prior to network analysis.
</p>
</td></tr>
<tr><td><code id="buildRepSeqNetwork_+3A_drop_matches">drop_matches</code></td>
<td>

<p>Optional. Passed to <code><a href="#topic+filterInputData">filterInputData()</a></code>.
Accepts a character string
containing a regular expression (see <code><a href="base.html#topic+regex">regex</a></code>).
Checks receptor sequences for a pattern match using <code><a href="base.html#topic+grep">grep()</a></code>.
Those returning a match are removed prior to network analysis.
</p>
</td></tr>
<tr><td><code id="buildRepSeqNetwork_+3A_dist_type">dist_type</code></td>
<td>

<p>Specifies the function used to quantify the similarity between sequences.
The similarity between two sequences determines the pairwise distance between
their respective nodes in the network graph, with greater similarity corresponding
to shorter distance. Valid options are <code>"hamming"</code> (the default), which
uses <code><a href="#topic+hamDistBounded">hamDistBounded()</a></code>,
and <code>"levenshtein"</code>, which uses
<code><a href="#topic+levDistBounded">levDistBounded()</a></code>.
</p>
</td></tr>
<tr><td><code id="buildRepSeqNetwork_+3A_dist_cutoff">dist_cutoff</code></td>
<td>

<p>A nonnegative scalar. Specifies the maximum pairwise distance (based on
<code>dist_type</code>) for an edge connection to exist between two nodes. Pairs of
nodes whose distance is less than or equal to this value will be joined by an
edge connection in the network graph. Controls the stringency of the network
construction and affects the number and density of edges in the network. A lower
cutoff value requires greater similarity between sequences in order for their
respective nodes to be joined by an edge connection. A value of <code>0</code>
requires two sequences to be identical in order for their nodes to be joined
by an edge.
</p>
</td></tr>
<tr><td><code id="buildRepSeqNetwork_+3A_drop_isolated_nodes">drop_isolated_nodes</code></td>
<td>

<p>A logical scalar. When <code>TRUE</code>, removes each node that is not joined by an
edge connection to any other node in the network graph.
</p>
</td></tr>
<tr><td><code id="buildRepSeqNetwork_+3A_node_stats">node_stats</code></td>
<td>

<p>A logical scalar. Specifies whether node-level network properties are computed.
</p>
</td></tr>
<tr><td><code id="buildRepSeqNetwork_+3A_stats_to_include">stats_to_include</code></td>
<td>

<p>A named logical vector returned by
<code><a href="#topic+chooseNodeStats">chooseNodeStats()</a></code> or
<code><a href="#topic+exclusiveNodeStats">exclusiveNodeStats()</a></code>.
Specifies the node-level network properties
to compute. Also accepts the value <code>"all"</code>.
Only relevant if <code>node_stats = TRUE</code>.
</p>
</td></tr>
<tr><td><code id="buildRepSeqNetwork_+3A_cluster_stats">cluster_stats</code></td>
<td>

<p>A logical scalar. Specifies whether to compute cluster-level network properties.
</p>
</td></tr>
<tr><td><code id="buildRepSeqNetwork_+3A_cluster_fun">cluster_fun</code></td>
<td>

<p>Passed to <code><a href="#topic+addClusterMembership">addClusterMembership()</a></code>.
Specifies the clustering algorithm
used when cluster analysis is performed. Cluster analysis is performed when
<code>cluster_stats = TRUE</code> or when <code>node_stats = TRUE</code> with the
<code>cluster_id</code> property enabled via the <code>stats_to_include</code> argument.
</p>
</td></tr>
<tr><td><code id="buildRepSeqNetwork_+3A_cluster_id_name">cluster_id_name</code></td>
<td>

<p>Passed to <code><a href="#topic+addClusterMembership">addClusterMembership()</a></code>.
Specifies the name of the cluster membership variable added to the node metadata
when cluster analysis is performed (see <code>cluster_fun</code>).
</p>
</td></tr>
<tr><td><code id="buildRepSeqNetwork_+3A_plots">plots</code></td>
<td>

<p>A logical scalar. Specifies whether to generate plots of the network graph.
</p>
</td></tr>
<tr><td><code id="buildRepSeqNetwork_+3A_print_plots">print_plots</code></td>
<td>

<p>A logical scalar. If <code>plots = TRUE</code>, specifies whether the plots should
be printed to the R plotting window.
</p>
</td></tr>
<tr><td><code id="buildRepSeqNetwork_+3A_plot_title">plot_title</code></td>
<td>

<p>A character string or <code>NULL</code>. If <code>plots = TRUE</code>, this is the title
used for each plot. The default value <code>"auto"</code> generates the title based
on the value of the <code>output_name</code> argument.
</p>
</td></tr>
<tr><td><code id="buildRepSeqNetwork_+3A_plot_subtitle">plot_subtitle</code></td>
<td>

<p>A character string or <code>NULL</code>. If <code>plots = TRUE</code>, this is the subtitle
used for each plot. The default value <code>"auto"</code> generates a subtitle based
on the values of the <code>dist_type</code> and <code>dist_cutoff</code> arguments.
</p>
</td></tr>
<tr><td><code id="buildRepSeqNetwork_+3A_color_nodes_by">color_nodes_by</code></td>
<td>

<p>Optional. Specifies a variable to be used as metadata for coloring the nodes
in the network graph plot. Accepts a character string. This can be a column
name of <code>data</code> or (if <code>node_stats = TRUE</code>) the name of a computed
node-level network property (based on <code>stats_to_include</code>). Also accepts
a character vector specifying multiple variables, in which case one plot will
be generated for each variable. The default value <code>"auto"</code> attempts to use
one of several potential variables to color the nodes, depending on what is
available. A value of <code>NULL</code> leaves the nodes uncolored.
</p>
</td></tr>
<tr><td><code id="buildRepSeqNetwork_+3A_...">...</code></td>
<td>

<p>Other named arguments to <code><a href="#topic+addPlots">addPlots()</a></code>.
</p>
</td></tr>
<tr><td><code id="buildRepSeqNetwork_+3A_output_dir">output_dir</code></td>
<td>

<p>A file path specifying the directory for saving the output. The directory will
be created if it does not exist. If <code>NULL</code>, output will be returned but
not saved.
</p>
</td></tr>
<tr><td><code id="buildRepSeqNetwork_+3A_output_type">output_type</code></td>
<td>

<p>A character string specifying the file format to use when saving the output.
The default value <code>"individual"</code> saves each element of the returned list
as an individual uncompressed file, with data frames saved in csv format. For
better compression, the values <code>"rda"</code> and <code>"rds"</code> save the returned
list as a single file using the rda and rds format, respectively (in the former
case, the list will be named <code>net</code> within the rda file). Regardless of the
argument value, any plots generated will saved to a pdf file containing one plot
per page.
</p>
</td></tr>
<tr><td><code id="buildRepSeqNetwork_+3A_output_name">output_name</code></td>
<td>

<p>A character string. All files saved will have file names beginning with this value.
</p>
</td></tr>
<tr><td><code id="buildRepSeqNetwork_+3A_pdf_width">pdf_width</code></td>
<td>

<p>Sets the width of each plot when writing to pdf.
Passed to <code><a href="#topic+saveNetwork">saveNetwork()</a></code>.
</p>
</td></tr>
<tr><td><code id="buildRepSeqNetwork_+3A_pdf_height">pdf_height</code></td>
<td>

<p>Sets the height of each plot when writing to pdf.
Passed to <code><a href="#topic+saveNetwork">saveNetwork()</a></code>.
</p>
</td></tr>
<tr><td><code id="buildRepSeqNetwork_+3A_verbose">verbose</code></td>
<td>

<p>Logical. If <code>TRUE</code>, generates messages about the tasks
performed and their progress, as well as relevant properties of intermediate
outputs. Messages are sent to <code><a href="base.html#topic+stderr">stderr()</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To construct the immune repertoire network, each TCR/BCR clone (bulk data)
or cell (single-cell data) is modeled as a node in the network graph,
corresponding to a single row of the AIRR-Seq data. For each node, the
corresponding receptor sequence is considered. Both nucleotide and amino acid
sequences are supported for this purpose. The receptor sequence is used as the
basis of similarity and distance between nodes in the network.
</p>
<p>Similarity between sequences is measured using either the Hamming distance
or Levenshtein (edit) distance. The similarity determines the pairwise distance
between nodes in the network graph. The more similar two sequences are, the
shorter the distance between their respective nodes. Two nodes in the graph
are joined by an edge if the distance between them is sufficiently small,
i.e., if their receptor sequences are sufficiently similar.
</p>
<p>For single-cell data, edge connections between nodes can be based on similarity
in both the alpha chain and beta chain sequences.
This is done by providing a vector of length 2 to <code>seq_cols</code>
specifying the two sequence columns in <code>data</code>.
The distance between two nodes is then the greater of the two distances between
sequences in corresponding chains.
Two nodes will be joined by an edge if their alpha chain sequences are sufficiently
similar and their beta chain sequences are sufficiently similar.
</p>
<p>See the
<a href="https://mlizhangx.github.io/Network-Analysis-for-Repertoire-Sequencing-/articles/buildRepSeqNetwork.html">buildRepSeqNetwork package vignette</a>
for more details. The vignette can be accessed offline using
<code>vignette("buildRepSeqNetwork")</code>.
</p>


<h3>Value</h3>

<p>If the constructed network contains no nodes, the function will return
<code>NULL</code>, invisibly, with a warning. Otherwise, the function invisibly
returns a list containing the following items:
</p>
<table>
<tr><td><code>details</code></td>
<td>
<p>A list containing information about the network and the
settings used during its construction.
</p>
</td></tr>
<tr><td><code>igraph</code></td>
<td>
<p>An object of class <code><a href="igraph.html#topic+igraph">igraph</a></code> containing the
list of nodes and edges for the network graph.
</p>
</td></tr>
<tr><td><code>adjacency_matrix</code></td>
<td>
<p>The network graph adjacency matrix, stored as a sparse
matrix of class <code>dgCMatrix</code> from the <code>Matrix</code> package.
See <code><a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix-class</a></code>.
</p>
</td></tr>
<tr><td><code>node_data</code></td>
<td>
<p> A data frame containing containing metadata for the network
nodes, where each row corresponds to a node in the network graph. This data
frame contains all variables from <code>data</code> (unless otherwise specified via
<code>subset_cols</code>) in addition to the computed node-level network properties
if <code>node_stats = TRUE</code>. Each row's name is the name of the corresponding
row from <code>data</code>.
</p>
</td></tr>
<tr><td><code>cluster_data</code></td>
<td>
<p>A data frame containing network properties for the clusters,
where each row corresponds to a cluster in the network graph. Only included if
<code>cluster_stats = TRUE</code>.
</p>
</td></tr>
<tr><td><code>plots</code></td>
<td>
<p>A list containing one element for each plot generated
as well as an additional element for the matrix that specifies the graph layout.
Each plot is an object of class <code><a href="ggraph.html#topic+ggraph">ggraph</a></code>. Only included
if <code>plots = TRUE</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Brian Neal (<a href="mailto:Brian.Neal@ucsf.edu">Brian.Neal@ucsf.edu</a>)
</p>


<h3>References</h3>

<p>Hai Yang, Jason Cham, Brian Neal, Zenghua Fan, Tao He and Li Zhang. (2023).
NAIR: Network Analysis of Immune Repertoire. <em>Frontiers in Immunology</em>, vol. 14.
<a href="https://www.frontiersin.org/articles/10.3389/fimmu.2023.1181825/full">doi: 10.3389/fimmu.2023.1181825</a>
</p>
<p><a href="https://mlizhangx.github.io/Network-Analysis-for-Repertoire-Sequencing-/index.html">Webpage for the NAIR package</a>
</p>
<p><a href="https://mlizhangx.github.io/Network-Analysis-for-Repertoire-Sequencing-/articles/buildRepSeqNetwork.html">buildRepSeqNetwork vignette</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
toy_data &lt;- simulateToyData()

# Simple call
network = buildNet(
  toy_data,
  seq_col = "CloneSeq",
  print_plots = TRUE
)

# Customized:
network &lt;- buildNet(
  toy_data, "CloneSeq",
  dist_type = "levenshtein",
  node_stats = TRUE,
  cluster_stats = TRUE,
  cluster_fun = "louvain",
  cluster_id_name = "cluster_membership",
  count_col = "CloneCount",
  color_nodes_by = c("SampleID", "cluster_membership", "coreness"),
  color_scheme = c("default", "Viridis", "plasma-1"),
  size_nodes_by = "degree",
  node_size_limits = c(0.1, 1.5),
  plot_title = NULL,
  plot_subtitle = NULL,
  print_plots = TRUE,
  verbose = TRUE
)

typeof(network)

names(network)

network$details

head(network$node_data)

head(network$cluster_data)

</code></pre>

<hr>
<h2 id='chooseNodeStats'>
Specify Node-level Network Properties to Compute
</h2><span id='topic+chooseNodeStats'></span><span id='topic+exclusiveNodeStats'></span><span id='topic+node_stat_settings'></span>

<h3>Description</h3>

<p>Create a vector specifying node-level network properties to compute.
Intended for use with <code><a href="#topic+buildRepSeqNetwork">buildRepSeqNetwork()</a></code> or
<code><a href="#topic+addNodeNetworkStats">addNodeNetworkStats</a></code>.
</p>
<p><code>node_stat_settings()</code> is a deprecated equivalent of
<code>chooseNodeStats()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chooseNodeStats(
  degree = TRUE,
  cluster_id = FALSE,
  transitivity = TRUE,
  closeness = FALSE,
  centrality_by_closeness = FALSE,
  eigen_centrality = TRUE,
  centrality_by_eigen = TRUE,
  betweenness = TRUE,
  centrality_by_betweenness = TRUE,
  authority_score = TRUE,
  coreness = TRUE,
  page_rank = TRUE,
  all_stats = FALSE
)

exclusiveNodeStats(
  degree = FALSE,
  cluster_id = FALSE,
  transitivity = FALSE,
  closeness = FALSE,
  centrality_by_closeness = FALSE,
  eigen_centrality = FALSE,
  centrality_by_eigen = FALSE,
  betweenness = FALSE,
  centrality_by_betweenness = FALSE,
  authority_score = FALSE,
  coreness = FALSE,
  page_rank = FALSE
)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chooseNodeStats_+3A_degree">degree</code></td>
<td>

<p>Logical. Whether to compute network degree.
</p>
</td></tr>
<tr><td><code id="chooseNodeStats_+3A_cluster_id">cluster_id</code></td>
<td>

<p>Logical. Whether to perform cluster analysis and record the cluster
membership of each node.
See <code><a href="#topic+addClusterMembership">addClusterMembership()</a></code>.
</p>
</td></tr>
<tr><td><code id="chooseNodeStats_+3A_transitivity">transitivity</code></td>
<td>

<p>Logical. Whether to compute node-level network transitivity using
<code><a href="igraph.html#topic+transitivity">transitivity()</a></code>
with <code>type = "local"</code>. The local
transitivity of a node is the the number of triangles connected to the node
relative to the number of triples centered on that node.
</p>
</td></tr>
<tr><td><code id="chooseNodeStats_+3A_closeness">closeness</code></td>
<td>

<p>Logical. Whether to compute network closeness using
<code><a href="igraph.html#topic+closeness">closeness()</a></code>.
</p>
</td></tr>
<tr><td><code id="chooseNodeStats_+3A_centrality_by_closeness">centrality_by_closeness</code></td>
<td>

<p>Logical. Whether to compute network centrality by closeness. The values are
the entries of the <code>res</code> element of the list returned by
<code><a href="igraph.html#topic+centr_clo">centr_clo()</a></code>.
</p>
</td></tr>
<tr><td><code id="chooseNodeStats_+3A_eigen_centrality">eigen_centrality</code></td>
<td>

<p>Logical. Whether to compute the eigenvector centrality scores of node network
positions. The scores are the entries of the <code>vector</code> element of the list
returned by <code><a href="igraph.html#topic+eigen_centrality">eigen_centrality()</a></code>
with <code>weights = NA</code>.
The centrality scores correspond to the values of the first eigenvector of
the adjacency matrix for the cluster graph.
</p>
</td></tr>
<tr><td><code id="chooseNodeStats_+3A_centrality_by_eigen">centrality_by_eigen</code></td>
<td>

<p>Logical. Whether to compute node-level network centrality scores based on
eigenvector centrality scores. The scores are the entries of the <code>vector</code>
element of the list returned by <code><a href="igraph.html#topic+centr_eigen">centr_eigen()</a></code>.
</p>
</td></tr>
<tr><td><code id="chooseNodeStats_+3A_betweenness">betweenness</code></td>
<td>

<p>Logical. Whether to compute network betweenness using
<code><a href="igraph.html#topic+betweenness">betweenness()</a></code>.
</p>
</td></tr>
<tr><td><code id="chooseNodeStats_+3A_centrality_by_betweenness">centrality_by_betweenness</code></td>
<td>

<p>Logical. Whether to compute network centrality scores by betweenness. The
scores are the entires of the <code>res</code> element of the list returned by
<code><a href="igraph.html#topic+centr_betw">centr_betw()</a></code>.
</p>
</td></tr>
<tr><td><code id="chooseNodeStats_+3A_authority_score">authority_score</code></td>
<td>

<p>Logical. Whether to compute the authority score using
<code><a href="igraph.html#topic+authority_score">authority_score()</a></code>.
</p>
</td></tr>
<tr><td><code id="chooseNodeStats_+3A_coreness">coreness</code></td>
<td>

<p>Logical. Whether to compute network coreness using
<code><a href="igraph.html#topic+coreness">coreness()</a></code>.
</p>
</td></tr>
<tr><td><code id="chooseNodeStats_+3A_page_rank">page_rank</code></td>
<td>

<p>Logical. Whether to compute page rank. The page rank values are the entries of
the <code>vector</code> element of the list returned by
<code><a href="igraph.html#topic+page_rank">page_rank()</a></code>.
</p>
</td></tr>
<tr><td><code id="chooseNodeStats_+3A_all_stats">all_stats</code></td>
<td>

<p>Logical. If <code>TRUE</code>, all other argument values are overridden and set to
<code>TRUE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions return a vector that can be passed to the <code>stats_to_include</code>
argument of <code><a href="#topic+addNodeStats">addNodeStats()</a></code>
(or <code><a href="#topic+buildRepSeqNetwork">buildRepSeqNetwork()</a></code>, if
<code>node_stats = TRUE</code>)
in order to specify which node-level network properties to compute.
</p>
<p><code>chooseNodeStats</code> and <code>exclusiveNodeStats</code> each have default
argument values suited to a different use case,
in order to reduce the number of argument values that must be set manually.
</p>
<p><code>chooseNodeStats</code> has most arguments <code>TRUE</code> by default.
It is best suited for including a majority of the available properties.
It can be called with <code>all_stats = TRUE</code> to set all values to <code>TRUE</code>.
</p>
<p><code>exclusiveNodeStats</code> has all of its arguments set to <code>FALSE</code> by
default. It is best suited for including only a few properties.
</p>


<h3>Value</h3>

<p>A named logical vector with one entry for each of the function's arguments
(except for <code>all_stats</code>).
Each entry has the same name as the corresponding argument, and its value
matches the argument's value.
</p>


<h3>Author(s)</h3>

<p>Brian Neal (<a href="mailto:Brian.Neal@ucsf.edu">Brian.Neal@ucsf.edu</a>)
</p>


<h3>References</h3>

<p>Hai Yang, Jason Cham, Brian Neal, Zenghua Fan, Tao He and Li Zhang. (2023).
NAIR: Network Analysis of Immune Repertoire. <em>Frontiers in Immunology</em>, vol. 14.
<a href="https://www.frontiersin.org/articles/10.3389/fimmu.2023.1181825/full">doi: 10.3389/fimmu.2023.1181825</a>
</p>
<p><a href="https://mlizhangx.github.io/Network-Analysis-for-Repertoire-Sequencing-/index.html">Webpage for the NAIR package</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+addNodeStats">addNodeStats()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
toy_data &lt;- simulateToyData()

net &lt;- generateNetworkObjects(
  toy_data, "CloneSeq"
)

# Add default set of node properties
net &lt;- addNodeStats(net)

# Modify default set of node properties
net &lt;- addNodeStats(
  net,
  stats_to_include =
    chooseNodeStats(
      closeness = TRUE,
      page_rank = FALSE
    )
)

# Add only the spepcified node properties
net &lt;- addNodeStats(
  net,
  stats_to_include =
    exclusiveNodeStats(
      degree = TRUE,
      transitivity = TRUE
    )
)

# Add all node-level network properties
net &lt;- addNodeStats(
  net,
  stats_to_include = "all"
)

</code></pre>

<hr>
<h2 id='combineSamples'>
Load and Combine Data From Multiple Samples
</h2><span id='topic+combineSamples'></span><span id='topic+loadDataFromFileList'></span>

<h3>Description</h3>

<p>Given multiple data frames stored in separate files,
<code>loadDataFromFileList()</code>
loads and combines them into a single data frame.
</p>
<p><code>combineSamples()</code> has the same default behavior as
<code>loadDataFromFileList()</code>,
but possesses additional arguments that allow the data frames to be filtered,
subsetted and augmented with sample-level variables before being combined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadDataFromFileList(
  file_list,
  input_type,
  data_symbols = NULL,
  header, sep, read.args
)

combineSamples(
  file_list,
  input_type,
  data_symbols = NULL,
  header, sep, read.args,
  seq_col = NULL,
  min_seq_length = NULL,
  drop_matches = NULL,
  subset_cols = NULL,
  sample_ids = NULL,
  subject_ids = NULL,
  group_ids = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combineSamples_+3A_file_list">file_list</code></td>
<td>

<p>A character vector of file paths, or a list containing
<code><a href="base.html#topic+connection">connections</a></code> and file paths.
Each element corresponds to a single file containing the data
for a single sample.
</p>
</td></tr>
<tr><td><code id="combineSamples_+3A_input_type">input_type</code></td>
<td>

<p>A character string specifying the file format of the sample data files.
Options are <code>"rds"</code>, <code>"rda"</code>, <code>"csv"</code>,
<code>"csv2"</code>, <code>"tsv"</code>, <code>"table"</code>.
See details.
</p>
</td></tr>
<tr><td><code id="combineSamples_+3A_data_symbols">data_symbols</code></td>
<td>

<p>Used when <code>input_type = "rda"</code>. Specifies the name of each sample's
data frame within its respective Rdata file. Accepts a character vector of
the same length as <code>file_list</code>. Alternatively, a single character string
can be used if all data frames have the same name.
</p>
</td></tr>
<tr><td><code id="combineSamples_+3A_header">header</code></td>
<td>

<p>For values of <code>input_type</code> other than <code>"rds"</code> and <code>"rda"</code>,
this argument can be used to specify a non-default value of the <code>header</code>
argument to <code><a href="utils.html#topic+read.table">read.table()</a></code>,
<code><a href="utils.html#topic+read.csv">read.csv()</a></code>, etc.
</p>
</td></tr>
<tr><td><code id="combineSamples_+3A_sep">sep</code></td>
<td>

<p>For values of <code>input_type</code> other than <code>"rds"</code> and <code>"rda"</code>,
this argument can be used to specify a non-default value of the <code>sep</code>
argument to <code><a href="utils.html#topic+read.table">read.table()</a></code>,
<code><a href="utils.html#topic+read.csv">read.csv()</a></code>, etc.
</p>
</td></tr>
<tr><td><code id="combineSamples_+3A_read.args">read.args</code></td>
<td>

<p>For values of <code>input_type</code> other than <code>"rds"</code> and <code>"rda"</code>,
this argument can be used to specify non-default values of optional
arguments to <code><a href="utils.html#topic+read.table">read.table()</a></code>,
<code><a href="utils.html#topic+read.csv">read.csv()</a></code>, etc.
Accepts a named list of argument values.
Values of <code>header</code> and <code>sep</code>
in this list take precedence over values specified via the <code>header</code>
and <code>sep</code> arguments.
</p>
</td></tr>
<tr><td><code id="combineSamples_+3A_seq_col">seq_col</code></td>
<td>

<p>If provided, each sample's data will be filtered based on the values of
<code>min_seq_length</code> and <code>drop_matches</code>.
Passed to <code><a href="#topic+filterInputData">filterInputData()</a></code> for each sample.
</p>
</td></tr>
<tr><td><code id="combineSamples_+3A_min_seq_length">min_seq_length</code></td>
<td>

<p>Passed to <code><a href="#topic+filterInputData">filterInputData()</a></code> for each sample.
</p>
</td></tr>
<tr><td><code id="combineSamples_+3A_drop_matches">drop_matches</code></td>
<td>

<p>Passed to <code><a href="#topic+filterInputData">filterInputData()</a></code> for each sample.
</p>
</td></tr>
<tr><td><code id="combineSamples_+3A_subset_cols">subset_cols</code></td>
<td>

<p>Passed to <code><a href="#topic+filterInputData">filterInputData()</a></code> for each sample.
</p>
</td></tr>
<tr><td><code id="combineSamples_+3A_sample_ids">sample_ids</code></td>
<td>

<p>A character or numeric vector of sample IDs, whose length matches that of
<code>file_list</code>.
</p>
</td></tr>
<tr><td><code id="combineSamples_+3A_subject_ids">subject_ids</code></td>
<td>

<p>An optional character or numeric vector of subject IDs, whose length matches
that of <code>file_list</code>. Used to assign a subject ID to each sample.
</p>
</td></tr>
<tr><td><code id="combineSamples_+3A_group_ids">group_ids</code></td>
<td>

<p>A character or numeric vector of group IDs whose length matches that of
<code>file_list</code>. Used to assign each sample to a group.
</p>
</td></tr>
<tr><td><code id="combineSamples_+3A_verbose">verbose</code></td>
<td>

<p>Logical. If <code>TRUE</code>, generates messages about the tasks
performed and their progress, as well as relevant properties of intermediate
outputs. Messages are sent to <code><a href="base.html#topic+stderr">stderr()</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each file is assumed to contain the data for a single sample, with
observations indexed by row, and with the same columns across samples.
</p>
<p>Valid options for <code>input_type</code> (and the corresponding function used to
load each file) include:
</p>

<ul>
<li> <p><code>"rds"</code>: <code><a href="base.html#topic+readRDS">readRDS()</a></code>
</p>
</li>
<li> <p><code>"rds"</code>: <code><a href="base.html#topic+readRDS">readRDS()</a></code>
</p>
</li>
<li> <p><code>"rda"</code>: <code><a href="base.html#topic+load">load()</a></code>
</p>
</li>
<li> <p><code>"csv"</code>: <code><a href="utils.html#topic+read.csv">read.csv()</a></code>
</p>
</li>
<li> <p><code>"csv2"</code>: <code><a href="utils.html#topic+read.csv">read.csv2()</a></code>
</p>
</li>
<li> <p><code>"tsv"</code>: <code><a href="utils.html#topic+read.csv">read.delim()</a></code>
</p>
</li>
<li> <p><code>"table"</code>: <code><a href="utils.html#topic+read.table">read.table()</a></code>
</p>
</li></ul>

<p>If <code>input_type = "rda"</code>, the <code>data_symbols</code> argument specifies the
name of each data frame within its respective file.
</p>
<p>When calling <code>combineSamples()</code>, for each of <code>sample_ids</code>,
<code>subject_ids</code> and <code>group_ids</code> that is non-null, a corresponding
variable will be added to the combined data frame; these variables are named
<code>SampleID</code>, <code>SubjectID</code> and <code>GroupID</code>.
</p>


<h3>Value</h3>

<p>A data frame containing the combined data rows from all files.
</p>


<h3>Author(s)</h3>

<p>Brian Neal (<a href="mailto:Brian.Neal@ucsf.edu">Brian.Neal@ucsf.edu</a>)
</p>


<h3>References</h3>

<p>Hai Yang, Jason Cham, Brian Neal, Zenghua Fan, Tao He and Li Zhang. (2023).
NAIR: Network Analysis of Immune Repertoire. <em>Frontiers in Immunology</em>, vol. 14.
<a href="https://www.frontiersin.org/articles/10.3389/fimmu.2023.1181825/full">doi: 10.3389/fimmu.2023.1181825</a>
</p>
<p><a href="https://mlizhangx.github.io/Network-Analysis-for-Repertoire-Sequencing-/index.html">Webpage for the NAIR package</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate example data
set.seed(42)
samples &lt;- simulateToyData(sample_size = 5)
sample_1 &lt;- subset(samples, SampleID == "Sample1")
sample_2 &lt;- subset(samples, SampleID == "Sample2")

# RDS format
rdsfiles &lt;- tempfile(c("sample1", "sample2"), fileext = ".rds")
saveRDS(sample_1, rdsfiles[1])
saveRDS(sample_2, rdsfiles[2])

loadDataFromFileList(
  rdsfiles,
  input_type = "rds"
)

# With filtering and subsetting
combineSamples(
  rdsfiles,
  input_type = "rds",
  seq_col = "CloneSeq",
  min_seq_length = 13,
  drop_matches = "GGG",
  subset_cols = "CloneSeq",
  sample_ids = c("id01", "id02"),
  verbose = TRUE
)

# RData, different data frame names
rdafiles &lt;- tempfile(c("sample1", "sample2"), fileext = ".rda")
save(sample_1, file = rdafiles[1])
save(sample_2, file = rdafiles[2])
loadDataFromFileList(
  rdafiles,
  input_type = "rda",
  data_symbols = c("sample_1", "sample_2")
)

# RData, same data frame names
df &lt;- sample_1
save(df, file = rdafiles[1])
df &lt;- sample_2
save(df, file = rdafiles[2])
loadDataFromFileList(
  rdafiles,
  input_type = "rda",
  data_symbols = "df"
)

# comma-separated values with header row; row names in first column
csvfiles &lt;- tempfile(c("sample1", "sample2"), fileext = ".csv")
utils::write.csv(sample_1, csvfiles[1], row.names = TRUE)
utils::write.csv(sample_2, csvfiles[2], row.names = TRUE)
loadDataFromFileList(
  csvfiles,
  input_type = "csv",
  read.args = list(row.names = 1)
)

# semicolon-separated values with decimals as commas;
# header row, row names in first column
utils::write.csv2(sample_1, csvfiles[1], row.names = TRUE)
utils::write.csv2(sample_2, csvfiles[2], row.names = TRUE)
loadDataFromFileList(
  csvfiles,
  input_type = "csv2",
  read.args = list(row.names = 1)
)

# tab-separated values with header row and decimals as commas
tsvfiles &lt;- tempfile(c("sample1", "sample2"), fileext = ".tsv")
utils::write.table(sample_1, tsvfiles[1], sep = "\t", dec = ",")
utils::write.table(sample_2, tsvfiles[2], sep = "\t", dec = ",")
loadDataFromFileList(
  tsvfiles,
  input_type = "tsv",
  header = TRUE,
  read.args = list(dec = ",")
)

# space-separated values with header row and NAs encoded as as "No Value"
txtfiles &lt;- tempfile(c("sample1", "sample2"), fileext = ".txt")
utils::write.table(sample_1, txtfiles[1], na = "No Value")
utils::write.table(sample_2, txtfiles[2], na = "No Value")
loadDataFromFileList(
  txtfiles,
  input_type = "table",
  read.args = list(
    header = TRUE,
    na.strings = "No Value"
  )
)

# custom value separator and row names in first column
utils::write.table(sample_1, txtfiles[1],
                   sep = "@", row.names = TRUE, col.names = FALSE
)
utils::write.table(sample_2, txtfiles[2],
                   sep = "@", row.names = TRUE, col.names = FALSE
)
loadDataFromFileList(
  txtfiles,
  input_type = "table",
  sep = "@",
  read.args = list(
    row.names = 1,
    col.names = c("rownames",
                  "CloneSeq", "CloneFrequency",
                  "CloneCount", "SampleID"
    )
  )
)

# same as previous example
# (value of sep in read.args overrides value in sep argument)
loadDataFromFileList(
  txtfiles,
  input_type = "table",
  sep = "\t",
  read.args = list(
    sep = "@",
    row.names = 1,
    col.names = c("rownames",
                  "CloneSeq", "CloneFrequency",
                  "CloneCount", "SampleID"
    )
  )
)


</code></pre>

<hr>
<h2 id='extractLayout'>
Get Coordinate Layout From Graph Plot
</h2><span id='topic+extractLayout'></span>

<h3>Description</h3>

<p>Given a <code><a href="ggraph.html#topic+ggraph">ggraph</a></code> plot, extract the coordinate layout of
the graph nodes as a two-column matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractLayout(plot)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractLayout_+3A_plot">plot</code></td>
<td>
<p>An object of class <code><a href="ggraph.html#topic+ggraph">ggraph</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Equivalent to <code>as.matrix(plot$data[c("x", "y")])</code>.
</p>


<h3>Value</h3>

<p>A matrix with two columns and one row per network node. Each row contains the
Cartesian coordinates of the corresponding node.
</p>


<h3>Author(s)</h3>

<p>Brian Neal (<a href="mailto:Brian.Neal@ucsf.edu">Brian.Neal@ucsf.edu</a>)
</p>


<h3>References</h3>

<p>Hai Yang, Jason Cham, Brian Neal, Zenghua Fan, Tao He and Li Zhang. (2023).
NAIR: Network Analysis of Immune Repertoire. <em>Frontiers in Immunology</em>, vol. 14.
<a href="https://www.frontiersin.org/articles/10.3389/fimmu.2023.1181825/full">doi: 10.3389/fimmu.2023.1181825</a>
</p>
<p><a href="https://mlizhangx.github.io/Network-Analysis-for-Repertoire-Sequencing-/index.html">Webpage for the NAIR package</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(42)
toy_data &lt;- simulateToyData()
net &lt;- buildRepSeqNetwork(toy_data, "CloneSeq", print_plots = TRUE)

my_layout &lt;- extractLayout(net$plots[[1]])

# same as `graph_layout` element in the plot list
all.equal(my_layout, net$plots$graph_layout, check.attributes = FALSE)

</code></pre>

<hr>
<h2 id='filterInputData'>
Filter Data Rows and Subset Data Columns
</h2><span id='topic+filterInputData'></span>

<h3>Description</h3>

<p>Given a data frame with a column containing receptor sequences, filter data
rows by sequence length and sequence content. Keep all data columns or choose
which columns to keep.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filterInputData(
  data,
  seq_col,
  min_seq_length = NULL,
  drop_matches = NULL,
  subset_cols = NULL,
  count_col = deprecated(),
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filterInputData_+3A_data">data</code></td>
<td>

<p>A data frame.
</p>
</td></tr>
<tr><td><code id="filterInputData_+3A_seq_col">seq_col</code></td>
<td>

<p>Specifies the column(s) of <code>data</code> containing
the receptor sequences.
Accepts a character or numeric vector of length 1 or 2,
containing either column names or column indices.
Each column specified will be coerced
to a character vector. Data rows containing a value of <code>NA</code> in any
of the specified columns will be dropped.
</p>
</td></tr>
<tr><td><code id="filterInputData_+3A_min_seq_length">min_seq_length</code></td>
<td>

<p>Observations whose receptor sequences have fewer than <code>min_seq_length</code>
characters are dropped.
</p>
</td></tr>
<tr><td><code id="filterInputData_+3A_drop_matches">drop_matches</code></td>
<td>

<p>Accepts a character string containing a regular expression
(see <code><a href="base.html#topic+regex">regex</a></code>). Checks values in the receptor sequence
column for a pattern match using <code><a href="base.html#topic+grep">grep()</a></code>.
Rows in which a match is found are dropped.
</p>
</td></tr>
<tr><td><code id="filterInputData_+3A_subset_cols">subset_cols</code></td>
<td>

<p>Specifies which columns of the AIRR-Seq data are included in the output.
Accepts a character vector of column names
or a numeric vector of column indices.
The default
<code>NULL</code> includes all columns. The receptor sequence column is always
included regardless of this argument's value.
</p>
</td></tr>
<tr><td><code id="filterInputData_+3A_count_col">count_col</code></td>
<td>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
Does nothing.
</p>
</td></tr>
<tr><td><code id="filterInputData_+3A_verbose">verbose</code></td>
<td>

<p>Logical. If <code>TRUE</code>, generates messages about the tasks
performed and their progress, as well as relevant properties of intermediate
outputs. Messages are sent to <code><a href="base.html#topic+stderr">stderr()</a></code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame.
</p>


<h3>Author(s)</h3>

<p>Brian Neal (<a href="mailto:Brian.Neal@ucsf.edu">Brian.Neal@ucsf.edu</a>)
</p>


<h3>References</h3>

<p>Hai Yang, Jason Cham, Brian Neal, Zenghua Fan, Tao He and Li Zhang. (2023).
NAIR: Network Analysis of Immune Repertoire. <em>Frontiers in Immunology</em>, vol. 14.
<a href="https://www.frontiersin.org/articles/10.3389/fimmu.2023.1181825/full">doi: 10.3389/fimmu.2023.1181825</a>
</p>
<p><a href="https://mlizhangx.github.io/Network-Analysis-for-Repertoire-Sequencing-/index.html">Webpage for the NAIR package</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
raw_data &lt;- simulateToyData()

# Remove sequences shorter than 13 characters,
# as well as sequences containing the subsequence "GGGG".
# Keep variables for clone sequence, clone frequency and sample ID
filterInputData(
  raw_data,
  seq_col = "CloneSeq",
  min_seq_length = 13,
  drop_matches = "GGGG",
  subset_cols =
    c("CloneSeq", "CloneFrequency", "SampleID"),
  verbose = TRUE
)

</code></pre>

<hr>
<h2 id='findAssociatedClones'>
Identify TCR/BCR Clones in a Neighborhood Around Each Associated Sequence
</h2><span id='topic+findAssociatedClones'></span>

<h3>Description</h3>

<p>Part of the workflow
<a href="https://mlizhangx.github.io/Network-Analysis-for-Repertoire-Sequencing-/articles/associated_clusters.html">Searching for Associated TCR/BCR Clusters</a>.
Intended for use following <code><a href="#topic+findAssociatedSeqs">findAssociatedSeqs()</a></code>
and prior to
<code><a href="#topic+buildAssociatedClusterNetwork">buildAssociatedClusterNetwork()</a></code>.
</p>
<p>Given multiple samples of bulk Adaptive Immune Receptor Repertoire Sequencing
(AIRR-Seq) data and a vector of associated sequences, identifies for each
associated sequence a global &quot;neighborhood&quot; comprised of clones with TCR/BCR
sequences similar to the associated sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findAssociatedClones(

  ## Input ##
  file_list, input_type,
  data_symbols = NULL,
  header, sep, read.args,
  sample_ids =
    paste0("Sample", 1:length(file_list)),
  subject_ids = NULL,
  group_ids,
  seq_col,
  assoc_seqs,

  ## Neighborhood Criteria ##
  nbd_radius = 1,
  dist_type = "hamming",
  min_seq_length = 6,
  drop_matches = NULL,

  ## Output ##
  subset_cols = NULL,
  output_dir,
  output_type = "rds",
  verbose = FALSE

)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findAssociatedClones_+3A_file_list">file_list</code></td>
<td>

<p>A character vector of file paths, or a list containing
<code><a href="base.html#topic+connection">connections</a></code> and file paths.
Each element corresponds to a single file containing the data
for a single sample.
Passed to <code><a href="#topic+loadDataFromFileList">loadDataFromFileList()</a></code>.
</p>
</td></tr>
<tr><td><code id="findAssociatedClones_+3A_input_type">input_type</code></td>
<td>

<p>A character string specifying the file format of the sample data files. Options
are <code>"table"</code>, <code>"txt"</code>, <code>"tsv"</code>, <code>"csv"</code>, <code>"rds"</code> and
<code>"rda"</code>.
Passed to <code><a href="#topic+loadDataFromFileList">loadDataFromFileList()</a></code>.
</p>
</td></tr>
<tr><td><code id="findAssociatedClones_+3A_data_symbols">data_symbols</code></td>
<td>

<p>Used when <code>input_type = "rda"</code>. Specifies the name of each sample's data
frame within its respective Rdata file.
Passed to <code><a href="#topic+loadDataFromFileList">loadDataFromFileList()</a></code>.
</p>
</td></tr>
<tr><td><code id="findAssociatedClones_+3A_header">header</code></td>
<td>

<p>For values of <code>input_type</code> other than <code>"rds"</code> and <code>"rda"</code>,
this argument can be used to specify a non-default value of the <code>header</code>
argument to <code><a href="utils.html#topic+read.table">read.table()</a></code>,
<code><a href="utils.html#topic+read.csv">read.csv()</a></code>, etc.
</p>
</td></tr>
<tr><td><code id="findAssociatedClones_+3A_sep">sep</code></td>
<td>

<p>For values of <code>input_type</code> other than <code>"rds"</code> and <code>"rda"</code>,
this argument can be used to specify a non-default value of the <code>sep</code>
argument to <code><a href="utils.html#topic+read.table">read.table()</a></code>,
<code><a href="utils.html#topic+read.csv">read.csv()</a></code>, etc.
</p>
</td></tr>
<tr><td><code id="findAssociatedClones_+3A_read.args">read.args</code></td>
<td>

<p>For values of <code>input_type</code> other than <code>"rds"</code> and <code>"rda"</code>,
this argument can be used to specify non-default values of optional
arguments to <code><a href="utils.html#topic+read.table">read.table()</a></code>,
<code><a href="utils.html#topic+read.csv">read.csv()</a></code>, etc.
Accepts a named list of argument values.
Values of <code>header</code> and <code>sep</code>
in this list take precedence over values specified via the <code>header</code>
and <code>sep</code> arguments.
</p>
</td></tr>
<tr><td><code id="findAssociatedClones_+3A_sample_ids">sample_ids</code></td>
<td>

<p>A character or numeric vector of sample IDs, whose length matches that of
<code>file_list</code>. Each entry is assigned as the sample ID to the corresponding
entry of <code>file_list</code>.
</p>
</td></tr>
<tr><td><code id="findAssociatedClones_+3A_subject_ids">subject_ids</code></td>
<td>

<p>An optional character or numeric vector of subject IDs, whose length matches
that of <code>file_list</code>. Used to assign a subject ID to each sample.
</p>
</td></tr>
<tr><td><code id="findAssociatedClones_+3A_group_ids">group_ids</code></td>
<td>

<p>A character or numeric vector of group IDs whose length matches that of
<code>file_list</code>. Used to assign each sample to a group. The two groups
represent the levels of the binary variable of interest.
</p>
</td></tr>
<tr><td><code id="findAssociatedClones_+3A_seq_col">seq_col</code></td>
<td>

<p>Specifies the column of each sample's data frame containing the TCR/BCR
sequences.
Accepts a character string containing the column name
or a numeric scalar containing the column index.
</p>
</td></tr>
<tr><td><code id="findAssociatedClones_+3A_assoc_seqs">assoc_seqs</code></td>
<td>

<p>A character vector containing the TCR/BCR sequences associated with the
binary variable of interest.
</p>
</td></tr>
<tr><td><code id="findAssociatedClones_+3A_nbd_radius">nbd_radius</code></td>
<td>

<p>The maximum distance (based on <code>dist_type</code>) between an associated sequence
and other TCR/BCR sequences belonging to its neighborhood. Lower values require
sequences to be more similar to an associated sequence in order to belong to
its neighborhood.
</p>
</td></tr>
<tr><td><code id="findAssociatedClones_+3A_dist_type">dist_type</code></td>
<td>

<p>Specifies the function used to quantify the similarity between sequences. The
similarity between two sequences determines their pairwise distance, with
greater similarity corresponding to shorter distance. Valid options are
<code>"hamming"</code> (the default), which
uses <code><a href="#topic+hamDistBounded">hamDistBounded()</a></code>,
and <code>"levenshtein"</code>, which uses
<code><a href="#topic+levDistBounded">levDistBounded()</a></code>.
</p>
</td></tr>
<tr><td><code id="findAssociatedClones_+3A_min_seq_length">min_seq_length</code></td>
<td>

<p>Clones with TCR/BCR sequences below this length will be removed. Passed to
<code><a href="#topic+filterInputData">filterInputData()</a></code> when loading each sample.
</p>
</td></tr>
<tr><td><code id="findAssociatedClones_+3A_drop_matches">drop_matches</code></td>
<td>

<p>Passed to <code><a href="#topic+filterInputData">filterInputData()</a></code>.
Accepts a character string containing a regular expression
(see <code><a href="base.html#topic+regex">regex</a></code>).
Checks TCR/BCR sequences for a pattern match using <code><a href="base.html#topic+grep">grep()</a></code>.
Those returning a match are dropped.
By default, sequences containing any of the characters <code>*</code>, <code>|</code>
or <code>_</code> are dropped.
</p>
</td></tr>
<tr><td><code id="findAssociatedClones_+3A_subset_cols">subset_cols</code></td>
<td>

<p>Controls which columns of the AIRR-Seq data from each sample are included in
the output.
Accepts a character vector of column names
or a numeric vector of column indices.
The default <code>NULL</code> includes all columns. Passed to
<code><a href="#topic+filterInputData">filterInputData()</a></code>.
</p>
</td></tr>
<tr><td><code id="findAssociatedClones_+3A_output_dir">output_dir</code></td>
<td>

<p>A file path to a directory for saving the output. A valid output directory is
required, since no output is returned in R. The specified directory will be
created if it does not already exist.
</p>
</td></tr>
<tr><td><code id="findAssociatedClones_+3A_output_type">output_type</code></td>
<td>

<p>A character string specifying the file format to use for saving the output.
Valid options are
<code>"rda"</code>, <code>"csv"</code>, <code>"csv2"</code>, <code>"tsv"</code> and<code>"table"</code>.
For <code>"rda"</code>, data frames are named <code>data</code> in the R environment.
For the remaining options, <code><a href="utils.html#topic+write.table">write.table()</a></code> is
called with <code>row.names = TRUE</code>.
</p>
</td></tr>
<tr><td><code id="findAssociatedClones_+3A_verbose">verbose</code></td>
<td>

<p>Logical. If <code>TRUE</code>, generates messages about the tasks
performed and their progress, as well as relevant properties of intermediate
outputs. Messages are sent to <code><a href="base.html#topic+stderr">stderr()</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each associated sequence, its neighborhood is defined to include all
clones with TCR/BCR sequences that are sufficiently similar to the associated
sequence. The arguments <code>dist_type</code> and <code>nbd_radius</code> control how the
similarity is measured and the degree of similarity required for neighborhood
membership.
</p>
<p>For each associated sequence, a data frame is saved to an individual file.
The data frame contains one row for each clone in the associated sequence's
neighborhood (from all samples). It includes variables for sample ID, group ID
and (if provided) subject ID, as well as variables from the AIRR-Seq data.
</p>
<p>The files saved by this function are intended for use with
<code><a href="#topic+buildAssociatedClusterNetwork">buildAssociatedClusterNetwork()</a></code>. See the
<a href="https://mlizhangx.github.io/Network-Analysis-for-Repertoire-Sequencing-/articles/associated_clusters.html">Searching for Associated TCR/BCR Clusters</a>
article on the package website for more details.
</p>


<h3>Value</h3>

<p>Returns <code>TRUE</code>, invisibly. The function is called for its side effects.
</p>


<h3>Author(s)</h3>

<p>Brian Neal (<a href="mailto:Brian.Neal@ucsf.edu">Brian.Neal@ucsf.edu</a>)
</p>


<h3>References</h3>

<p>Hai Yang, Jason Cham, Brian Neal, Zenghua Fan, Tao He and Li Zhang. (2023).
NAIR: Network Analysis of Immune Repertoire. <em>Frontiers in Immunology</em>, vol. 14.
<a href="https://www.frontiersin.org/articles/10.3389/fimmu.2023.1181825/full">doi: 10.3389/fimmu.2023.1181825</a>
</p>
<p><a href="https://mlizhangx.github.io/Network-Analysis-for-Repertoire-Sequencing-/index.html">Webpage for the NAIR package</a>
</p>
<p><a href="https://mlizhangx.github.io/Network-Analysis-for-Repertoire-Sequencing-/articles/associated_clusters.html">Searching for Associated TCR/BCR Clusters article on package website</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+findAssociatedSeqs">findAssociatedSeqs()</a></code>
<code><a href="#topic+buildAssociatedClusterNetwork">buildAssociatedClusterNetwork()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)

## Simulate 30 samples from two groups (treatment/control) ##
n_control &lt;- n_treatment &lt;- 15
n_samples &lt;- n_control + n_treatment
sample_size &lt;- 30 # (seqs per sample)
base_seqs &lt;- # first five are associated with treatment
  c("CASSGAYEQYF", "CSVDLGKGNNEQFF", "CASSIEGQLSTDTQYF",
    "CASSEEGQLSTDTQYF", "CASSPEGQLSTDTQYF",
    "RASSLAGNTEAFF", "CASSHRGTDTQYF", "CASDAGVFQPQHF")
# Relative generation probabilities by control/treatment group
pgen_c &lt;- matrix(rep(c(rep(1, 5), rep(30, 3)), times = n_control),
                 nrow = n_control, byrow = TRUE)
pgen_t &lt;- matrix(rep(c(1, 1, rep(1/3, 3), rep(2, 3)), times = n_treatment),
                 nrow = n_treatment, byrow = TRUE)
pgen &lt;- rbind(pgen_c, pgen_t)
simulateToyData(
  samples = n_samples,
  sample_size = sample_size,
  prefix_length = 1,
  prefix_chars = c("", ""),
  prefix_probs = cbind(rep(1, n_samples), rep(0, n_samples)),
  affixes = base_seqs,
  affix_probs = pgen,
  num_edits = 0,
  output_dir = tempdir(),
  no_return = TRUE
)

## Step 1: Find Associated Sequences ##
sample_files &lt;-
  file.path(tempdir(),
            paste0("Sample", 1:n_samples, ".rds")
  )
group_labels &lt;- c(rep("reference", n_control),
                  rep("comparison", n_treatment))
associated_seqs &lt;-
  findAssociatedSeqs(
    file_list = sample_files,
    input_type = "rds",
    group_ids = group_labels,
    seq_col = "CloneSeq",
    min_seq_length = NULL,
    drop_matches = NULL,
    min_sample_membership = 0,
    pval_cutoff = 0.1
  )
head(associated_seqs[, 1:5])

## Step 2: Find Associated Clones ##
dir_step2 &lt;- tempfile()
findAssociatedClones(
  file_list = sample_files,
  input_type = "rds",
  group_ids = group_labels,
  seq_col = "CloneSeq",
  assoc_seqs = associated_seqs$ReceptorSeq,
  min_seq_length = NULL,
  drop_matches = NULL,
  output_dir = dir_step2
)

## Step 3: Global Network of Associated Clusters ##
associated_clusters &lt;-
  buildAssociatedClusterNetwork(
    file_list = list.files(dir_step2,
                           full.names = TRUE
    ),
    seq_col = "CloneSeq",
    size_nodes_by = 1.5,
    print_plots = TRUE
  )


</code></pre>

<hr>
<h2 id='findAssociatedSeqs'>
Identify TCR/BCR Sequences Associated With a Binary Variable
</h2><span id='topic+findAssociatedSeqs'></span><span id='topic+findAssociatedSeqs2'></span>

<h3>Description</h3>

<p>Part of the workflow
<a href="https://mlizhangx.github.io/Network-Analysis-for-Repertoire-Sequencing-/articles/associated_clusters.html">Searching for Associated TCR/BCR Clusters</a>.
</p>
<p>Given multiple samples of bulk Adaptive Immune Receptor Repertoire Sequencing
(AIRR-Seq) data and a binary variable of interest such as a disease condition,
treatment or clinical outcome, identify receptor sequences that exhibit a
statistically significant difference in frequency between the two levels of the
binary variable.
</p>
<p><code>findAssociatedSeqs()</code> is designed for use when each sample is stored in a
separate file. <code>findAssociatedSeqs2()</code> is designed for use with a single data
frame containing all samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findAssociatedSeqs(
  ## Input ##
  file_list,
  input_type,
  data_symbols = NULL,
  header, sep, read.args,
  sample_ids = deprecated(),
  subject_ids = NULL,
  group_ids,
  groups = deprecated(),
  seq_col,
  freq_col = NULL,

  ## Search Criteria ##
  min_seq_length = 7,
  drop_matches = "[*|_]",
  min_sample_membership = 5,
  pval_cutoff = 0.05,

  ## Output ##
  outfile = NULL,
  verbose = FALSE
)


findAssociatedSeqs2(
  ## Input ##
  data,
  seq_col,
  sample_col,
  subject_col = sample_col,
  group_col,
  groups = deprecated(),
  freq_col = NULL,

  ## Search Criteria ##
  min_seq_length = 7,
  drop_matches = "[*|_]",
  min_sample_membership = 5,
  pval_cutoff = 0.05,

  ## Ouptut ##
  outfile = NULL,
  verbose = FALSE
)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findAssociatedSeqs_+3A_file_list">file_list</code></td>
<td>

<p>A character vector of file paths, or a list containing
<code><a href="base.html#topic+connection">connections</a></code> and file paths.
Each element corresponds to a single file containing the data
for a single sample.
Passed to <code><a href="#topic+loadDataFromFileList">loadDataFromFileList()</a></code>.
</p>
</td></tr>
<tr><td><code id="findAssociatedSeqs_+3A_input_type">input_type</code></td>
<td>

<p>A character string specifying the file format of the sample data files.
Options are <code>"table"</code>, <code>"txt"</code>, <code>"tsv"</code>, <code>"csv"</code>,
<code>"rds"</code> and <code>"rda"</code>.
Passed to <code><a href="#topic+loadDataFromFileList">loadDataFromFileList()</a></code>.
</p>
</td></tr>
<tr><td><code id="findAssociatedSeqs_+3A_data_symbols">data_symbols</code></td>
<td>

<p>Used when <code>input_type = "rda"</code>. Specifies the name of each sample's data
frame within its respective Rdata file.  Passed to
<code><a href="#topic+loadDataFromFileList">loadDataFromFileList()</a></code>.
</p>
</td></tr>
<tr><td><code id="findAssociatedSeqs_+3A_header">header</code></td>
<td>

<p>For values of <code>input_type</code> other than <code>"rds"</code> and <code>"rda"</code>,
this argument can be used to specify a non-default value of the <code>header</code>
argument to <code><a href="utils.html#topic+read.table">read.table()</a></code>,
<code><a href="utils.html#topic+read.csv">read.csv()</a></code>, etc.
</p>
</td></tr>
<tr><td><code id="findAssociatedSeqs_+3A_sep">sep</code></td>
<td>

<p>For values of <code>input_type</code> other than <code>"rds"</code> and <code>"rda"</code>,
this argument can be used to specify a non-default value of the <code>sep</code>
argument to <code><a href="utils.html#topic+read.table">read.table()</a></code>,
<code><a href="utils.html#topic+read.csv">read.csv()</a></code>, etc.
</p>
</td></tr>
<tr><td><code id="findAssociatedSeqs_+3A_read.args">read.args</code></td>
<td>

<p>For values of <code>input_type</code> other than <code>"rds"</code> and <code>"rda"</code>,
this argument can be used to specify non-default values of optional
arguments to <code><a href="utils.html#topic+read.table">read.table()</a></code>,
<code><a href="utils.html#topic+read.csv">read.csv()</a></code>, etc.
Accepts a named list of argument values.
Values of <code>header</code> and <code>sep</code>
in this list take precedence over values specified via the <code>header</code>
and <code>sep</code> arguments.
</p>
</td></tr>
<tr><td><code id="findAssociatedSeqs_+3A_sample_ids">sample_ids</code></td>
<td>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
Does nothing.
</p>
</td></tr>
<tr><td><code id="findAssociatedSeqs_+3A_subject_ids">subject_ids</code></td>
<td>

<p>A character or numeric vector of subject IDs, whose length matches that of
<code>file_list</code>. Only relevant when the binary variable of interest is
subject-specific and multiple samples belong to the same subject.
</p>
</td></tr>
<tr><td><code id="findAssociatedSeqs_+3A_group_ids">group_ids</code></td>
<td>

<p>A character or numeric vector of group IDs containing exactly two unique values
and with length matching that of <code>file_list</code>. The two groups correspond to
the two values of the binary variable of interest.
</p>
</td></tr>
<tr><td><code id="findAssociatedSeqs_+3A_groups">groups</code></td>
<td>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
Does nothing.
</p>
</td></tr>
<tr><td><code id="findAssociatedSeqs_+3A_seq_col">seq_col</code></td>
<td>

<p>Specifies the column of each sample's data frame containing the TCR/BCR sequences.
Accepts a character string containing the column name
or a numeric scalar containing the column index.
</p>
</td></tr>
<tr><td><code id="findAssociatedSeqs_+3A_freq_col">freq_col</code></td>
<td>

<p>Optional. Specifies the column of each sample's data frame containing the clone
frequency (i.e., clone count divided by the sum of the clone counts across all
clones in the sample).
Accepts a character string containing the column name
or a numeric scalar containing the column index.
If this
argument is specified, the maximum clone frequency (across all samples) for
each associated sequence will be included in the content of the <code>label</code>
variable of the returned data frame.
</p>
</td></tr>
<tr><td><code id="findAssociatedSeqs_+3A_min_seq_length">min_seq_length</code></td>
<td>

<p>Controls the minimum TCR/BCR sequence length considered when searching for
associated sequences. Passed to <code><a href="#topic+filterInputData">filterInputData()</a></code>.
</p>
</td></tr>
<tr><td><code id="findAssociatedSeqs_+3A_drop_matches">drop_matches</code></td>
<td>

<p>Passed to <code><a href="#topic+filterInputData">filterInputData()</a></code>.
Accepts a character string containing
a regular expression (see <code><a href="base.html#topic+regex">regex</a></code>). Checks TCR/BCR sequences
for a pattern match using <code><a href="base.html#topic+grep">grep()</a></code>. Those returning a match are
excluded from consideration as associated sequences. It is recommended to
filter out sequences containing special characters that are invalid for use
in file names. By default, sequences containing any of the characters
<code>*</code>, <code>|</code> or <code>_</code> are dropped.
</p>
</td></tr>
<tr><td><code id="findAssociatedSeqs_+3A_min_sample_membership">min_sample_membership</code></td>
<td>

<p>Controls the minimum number of samples in which a TCR/BCR sequence must be
present in order to be considered when searching for associated sequences.
Setting this value to <code>NULL</code> bypasses the check.
</p>
</td></tr>
<tr><td><code id="findAssociatedSeqs_+3A_pval_cutoff">pval_cutoff</code></td>
<td>

<p>Controls the P-value cutoff below which an association is detected by Fisher's
exact test (see details).
</p>
</td></tr>
<tr><td><code id="findAssociatedSeqs_+3A_outfile">outfile</code></td>
<td>

<p>A file path for saving the output (using <code><a href="utils.html#topic+write.csv">write.csv()</a></code>).
</p>
</td></tr>
<tr><td><code id="findAssociatedSeqs_+3A_verbose">verbose</code></td>
<td>

<p>Logical. If <code>TRUE</code>, generates messages about the tasks
performed and their progress, as well as relevant properties of intermediate
outputs. Messages are sent to <code><a href="base.html#topic+stderr">stderr()</a></code>.
</p>
</td></tr>
<tr><td><code id="findAssociatedSeqs_+3A_data">data</code></td>
<td>

<p>A data frame containing the combined AIRR-seq data for all samples.
</p>
</td></tr>
<tr><td><code id="findAssociatedSeqs_+3A_sample_col">sample_col</code></td>
<td>

<p>The column of <code>data</code> containing the sample IDs.
Accepts a character string containing the column name
or a numeric scalar containing the column index.
</p>
</td></tr>
<tr><td><code id="findAssociatedSeqs_+3A_subject_col">subject_col</code></td>
<td>

<p>Optional. The column of <code>data</code> containing the subject IDs.
Accepts a character string containing the column name
or a numeric scalar containing the column index.
Only relevant when the binary variable of interest
is subject-specific and multiple samples belong to the same subject.
</p>
</td></tr>
<tr><td><code id="findAssociatedSeqs_+3A_group_col">group_col</code></td>
<td>

<p>The column of <code>data</code> containing the group IDs.
Accepts a character string containing the column name
or a numeric scalar containing the column index.
The groups correspond to the two values of the binary variable
of interest. Thus there should be exactly two unique values in this column.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The TCR/BCR sequences from all samples are first filtered according to minimum
sequence length and sequence content based on the specified values in
<code>min_seq_length</code> and <code>drop_matches</code>, respectively. The sequences
are further filtered based on sample membership, removing sequences appearing
in fewer than <code>min_sample_membership</code> samples.
</p>
<p>For each remaining TCR/BCR sequence, a P-value is computed for Fisher's exact
test of independence between the binary variable of interest and the presence
of the sequence within a repertoire. The samples/subjects are divided into two
groups based on the levels of the binary variable. If subject IDs are provided,
then the test is based on the number of subjects in each group for whom the
sequence appears in one of their samples. Without subject IDs, the test is
based on the number of samples possessing the sequence in each group.
</p>
<p>Fisher's exact test is performed using
<code><a href="stats.html#topic+fisher.test">fisher.test()</a></code>. TCR/BCR
sequences with a <code class="reqn">P</code>-value below <code>pval_cutoff</code> are sorted by <code class="reqn">P</code>-value
and returned along with some additional information.
</p>
<p>The returned ouput is intended for use with the
<code><a href="#topic+findAssociatedClones">findAssociatedClones()</a></code>
function. See the
<a href="https://mlizhangx.github.io/Network-Analysis-for-Repertoire-Sequencing-/articles/associated_clusters.html">Searching for Associated TCR/BCR Clusters</a>
article on the package website.
</p>


<h3>Value</h3>

<p>A data frame containing the TCR/BCR sequences found to be associated with
the binary variable using Fisher's exact test (see details). Each row corresponds
to a unique TCR/BCR sequence and includes the following variables:
</p>
<table>
<tr><td><code>ReceptorSeq</code></td>
<td>

<p>The unique receptor sequence.
</p>
</td></tr>
<tr><td><code>fisher_pvalue</code></td>
<td>

<p>The P-value on Fisher's exact test for independence between the receptor
sequence and the binary variable of interest.
</p>
</td></tr>
<tr><td><code>shared_by_n_samples</code></td>
<td>

<p>The number of samples in which the sequence was observed.
</p>
</td></tr>
<tr><td><code>samples_g0</code></td>
<td>

<p>Of the samples in which the sequence was observed, the number of samples
belonging to the first group.
</p>
</td></tr>
<tr><td><code>samples_g1</code></td>
<td>

<p>Of the samples in which the sequence was observed, the number of samples
belonging to the second group.
</p>
</td></tr>
<tr><td><code>shared_by_n_subjects</code></td>
<td>

<p>The number of subjects in which the sequence was observed (only present if
subject IDs are specified).
</p>
</td></tr>
<tr><td><code>subjects_g0</code></td>
<td>

<p>Of the subjects in which the sequence was observed, the number of subjects
belonging to the first group (only present if subject IDs are specified).
</p>
</td></tr>
<tr><td><code>subjects_g1</code></td>
<td>

<p>Of the subjects in which the sequence was observed, the number of subjects
belonging to the second group (only present if subject IDs are specified).
</p>
</td></tr>
<tr><td><code>max_freq</code></td>
<td>

<p>The maximum clone frequency across all samples.
Only present if <code>freq_col</code> is non-null.
</p>
</td></tr>
<tr><td><code>label</code></td>
<td>

<p>A character string summarizing the above information. Also includes the
maximum in-sample clone frequency across all samples, if available.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Brian Neal (<a href="mailto:Brian.Neal@ucsf.edu">Brian.Neal@ucsf.edu</a>)
</p>


<h3>References</h3>

<p>Hai Yang, Jason Cham, Brian Neal, Zenghua Fan, Tao He and Li Zhang. (2023).
NAIR: Network Analysis of Immune Repertoire. <em>Frontiers in Immunology</em>, vol. 14.
<a href="https://www.frontiersin.org/articles/10.3389/fimmu.2023.1181825/full">doi: 10.3389/fimmu.2023.1181825</a>
</p>
<p><a href="https://mlizhangx.github.io/Network-Analysis-for-Repertoire-Sequencing-/index.html">Webpage for the NAIR package</a>
</p>
<p><a href="https://mlizhangx.github.io/Network-Analysis-for-Repertoire-Sequencing-/articles/associated_clusters.html">Searching for Associated TCR/BCR Clusters article on package website</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+findAssociatedClones">findAssociatedClones()</a></code>
<code><a href="#topic+buildAssociatedClusterNetwork">buildAssociatedClusterNetwork()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)

## Simulate 30 samples from two groups (treatment/control) ##
n_control &lt;- n_treatment &lt;- 15
n_samples &lt;- n_control + n_treatment
sample_size &lt;- 30 # (seqs per sample)
base_seqs &lt;- # first five are associated with treatment
  c("CASSGAYEQYF", "CSVDLGKGNNEQFF", "CASSIEGQLSTDTQYF",
    "CASSEEGQLSTDTQYF", "CASSPEGQLSTDTQYF",
    "RASSLAGNTEAFF", "CASSHRGTDTQYF", "CASDAGVFQPQHF")
# Relative generation probabilities by control/treatment group
pgen_c &lt;- matrix(rep(c(rep(1, 5), rep(30, 3)), times = n_control),
                 nrow = n_control, byrow = TRUE)
pgen_t &lt;- matrix(rep(c(1, 1, rep(1/3, 3), rep(2, 3)), times = n_treatment),
                 nrow = n_treatment, byrow = TRUE)
pgen &lt;- rbind(pgen_c, pgen_t)
simulateToyData(
  samples = n_samples,
  sample_size = sample_size,
  prefix_length = 1,
  prefix_chars = c("", ""),
  prefix_probs = cbind(rep(1, n_samples), rep(0, n_samples)),
  affixes = base_seqs,
  affix_probs = pgen,
  num_edits = 0,
  output_dir = tempdir(),
  no_return = TRUE
)

## Step 1: Find Associated Sequences ##
sample_files &lt;-
  file.path(tempdir(),
            paste0("Sample", 1:n_samples, ".rds")
  )
group_labels &lt;- c(rep("reference", n_control),
                  rep("comparison", n_treatment))
associated_seqs &lt;-
  findAssociatedSeqs(
    file_list = sample_files,
    input_type = "rds",
    group_ids = group_labels,
    seq_col = "CloneSeq",
    min_seq_length = NULL,
    drop_matches = NULL,
    min_sample_membership = 0,
    pval_cutoff = 0.1
  )
head(associated_seqs[, 1:5])

## Step 2: Find Associated Clones ##
dir_step2 &lt;- tempfile()
findAssociatedClones(
  file_list = sample_files,
  input_type = "rds",
  group_ids = group_labels,
  seq_col = "CloneSeq",
  assoc_seqs = associated_seqs$ReceptorSeq,
  min_seq_length = NULL,
  drop_matches = NULL,
  output_dir = dir_step2
)

## Step 3: Global Network of Associated Clusters ##
associated_clusters &lt;-
  buildAssociatedClusterNetwork(
    file_list = list.files(dir_step2,
                           full.names = TRUE
    ),
    seq_col = "CloneSeq",
    size_nodes_by = 1.5,
    print_plots = TRUE
  )


</code></pre>

<hr>
<h2 id='findPublicClusters'>
Find Public Clusters Among RepSeq Samples
</h2><span id='topic+findPublicClusters'></span>

<h3>Description</h3>

<p>Part of the workflow
<a href="https://mlizhangx.github.io/Network-Analysis-for-Repertoire-Sequencing-/articles/public_clusters.html">Searching for Public TCR/BCR Clusters</a>.
</p>
<p>Given multiple samples of bulk Adaptive Immune Receptor Repertoire Sequencing
(AIRR-Seq) data, construct the repertoire network for each sample. Within each
sample's network, perform cluster analysis and filter the clusters based on node
count and aggregate clone count.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findPublicClusters(

  ## Input ##
  file_list,
  input_type,
  data_symbols = NULL,
  header, sep, read.args,
  sample_ids =
    paste0("Sample", 1:length(file_list)),
  seq_col,
  count_col = NULL,

  ## Search Criteria ##
  min_seq_length = 3,
  drop_matches = "[*|_]",
  top_n_clusters = 20,
  min_node_count = 10,
  min_clone_count = 100,

  ## Optional Visualization ##
  plots = FALSE,
  print_plots = FALSE,
  plot_title = "auto",
  color_nodes_by = "cluster_id",

  ## Output ##
  output_dir,
  output_type = "rds",

  ## Optional Output ##
  output_dir_unfiltered = NULL,
  output_type_unfiltered = "rds",

  verbose = FALSE,

  ...

)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findPublicClusters_+3A_file_list">file_list</code></td>
<td>

<p>A character vector of file paths, or a list containing
<code><a href="base.html#topic+connection">connections</a></code> and file paths.
Each element corresponds to a single file containing the data
for a single sample.
Passed to <code><a href="#topic+loadDataFromFileList">loadDataFromFileList()</a></code>.
</p>
</td></tr>
<tr><td><code id="findPublicClusters_+3A_input_type">input_type</code></td>
<td>

<p>A character string specifying the file format of the sample data files. Options
are <code>"table"</code>, <code>"txt"</code>, <code>"tsv"</code>, <code>"csv"</code>, <code>"rds"</code> and
<code>"rda"</code>. Passed to <code><a href="#topic+loadDataFromFileList">loadDataFromFileList()</a></code>.
</p>
</td></tr>
<tr><td><code id="findPublicClusters_+3A_data_symbols">data_symbols</code></td>
<td>

<p>Used when <code>input_type = "rda"</code>. Specifies the name of each sample's data
frame within its respective Rdata file.
Passed to <code><a href="#topic+loadDataFromFileList">loadDataFromFileList()</a></code>.
</p>
</td></tr>
<tr><td><code id="findPublicClusters_+3A_header">header</code></td>
<td>

<p>For values of <code>input_type</code> other than <code>"rds"</code> and <code>"rda"</code>,
this argument can be used to specify a non-default value of the <code>header</code>
argument to <code><a href="utils.html#topic+read.table">read.table()</a></code>,
<code><a href="utils.html#topic+read.csv">read.csv()</a></code>, etc.
</p>
</td></tr>
<tr><td><code id="findPublicClusters_+3A_sep">sep</code></td>
<td>

<p>For values of <code>input_type</code> other than <code>"rds"</code> and <code>"rda"</code>,
this argument can be used to specify a non-default value of the <code>sep</code>
argument to <code><a href="utils.html#topic+read.table">read.table()</a></code>,
<code><a href="utils.html#topic+read.csv">read.csv()</a></code>, etc.
</p>
</td></tr>
<tr><td><code id="findPublicClusters_+3A_read.args">read.args</code></td>
<td>

<p>For values of <code>input_type</code> other than <code>"rds"</code> and <code>"rda"</code>,
this argument can be used to specify non-default values of optional
arguments to <code><a href="utils.html#topic+read.table">read.table()</a></code>,
<code><a href="utils.html#topic+read.csv">read.csv()</a></code>, etc.
Accepts a named list of argument values.
Values of <code>header</code> and <code>sep</code>
in this list take precedence over values specified via the <code>header</code>
and <code>sep</code> arguments.
</p>
</td></tr>
<tr><td><code id="findPublicClusters_+3A_sample_ids">sample_ids</code></td>
<td>

<p>A character or numeric vector of sample IDs, whose length matches that of
<code>file_list</code>. The values should be valid for use as filenames and should
avoid using the forward slash or backslash characters (<code>/</code> or <code>\</code>).
</p>
</td></tr>
<tr><td><code id="findPublicClusters_+3A_seq_col">seq_col</code></td>
<td>

<p>Specifies the column of each sample's data frame containing the TCR/BCR
sequences.
Accepts a character string containing the column name
or a numeric scalar containing the column index.
</p>
</td></tr>
<tr><td><code id="findPublicClusters_+3A_count_col">count_col</code></td>
<td>

<p>Specifies the column of each sample's data frame containing the clone count
(measure of clonal abundance).
Accepts a character string containing the column name
or a numeric scalar containing the column index.
If <code>NULL</code>, the clusters in each sample's network will be selected solely
based upon node count.
</p>
</td></tr>
<tr><td><code id="findPublicClusters_+3A_min_seq_length">min_seq_length</code></td>
<td>

<p>Passed to <code><a href="#topic+buildRepSeqNetwork">buildRepSeqNetwork()</a></code>
when constructing the network for
each sample.
</p>
</td></tr>
<tr><td><code id="findPublicClusters_+3A_drop_matches">drop_matches</code></td>
<td>

<p>Passed to <code><a href="#topic+buildRepSeqNetwork">buildRepSeqNetwork()</a></code>
when constructing the network for
each sample. Accepts a character string containing a regular expression
(see <code><a href="base.html#topic+regex">regex</a></code>).
Checks TCR/BCR sequences for a pattern match using <code><a href="base.html#topic+grep">grep()</a></code>.
Those returning a match are dropped.
By default, sequences containing any of the characters <code>*</code>, <code>|</code>
or <code>_</code> are dropped.
</p>
</td></tr>
<tr><td><code id="findPublicClusters_+3A_top_n_clusters">top_n_clusters</code></td>
<td>

<p>The number of clusters from each sample to be automatically be included among
the filtered clusters, based on greatest node count.
</p>
</td></tr>
<tr><td><code id="findPublicClusters_+3A_min_node_count">min_node_count</code></td>
<td>

<p>Clusters with at least this many nodes will be included among the filtered
clusters.
</p>
</td></tr>
<tr><td><code id="findPublicClusters_+3A_min_clone_count">min_clone_count</code></td>
<td>

<p>Clusters with an aggregate clone count of at least this value will be included
among the filtered clusters. A value of <code>NULL</code> ignores this criterion
and does not select additional clusters based on clone count.
</p>
</td></tr>
<tr><td><code id="findPublicClusters_+3A_plots">plots</code></td>
<td>

<p>Passed to <code><a href="#topic+buildRepSeqNetwork">buildRepSeqNetwork()</a></code>
when constructing the network for each sample.
</p>
</td></tr>
<tr><td><code id="findPublicClusters_+3A_print_plots">print_plots</code></td>
<td>

<p>Passed to <code><a href="#topic+buildRepSeqNetwork">buildRepSeqNetwork()</a></code>
when constructing the network for each sample.
</p>
</td></tr>
<tr><td><code id="findPublicClusters_+3A_plot_title">plot_title</code></td>
<td>

<p>Passed to <code><a href="#topic+buildRepSeqNetwork">buildRepSeqNetwork()</a></code>
when constructing the network for each sample.
</p>
</td></tr>
<tr><td><code id="findPublicClusters_+3A_color_nodes_by">color_nodes_by</code></td>
<td>

<p>Passed to <code><a href="#topic+buildRepSeqNetwork">buildRepSeqNetwork()</a></code>
when constructing the network for each sample.
</p>
</td></tr>
<tr><td><code id="findPublicClusters_+3A_output_dir">output_dir</code></td>
<td>

<p>The file path of the directory for saving the output. The directory will be
created if it does not already exist.
</p>
</td></tr>
<tr><td><code id="findPublicClusters_+3A_output_type">output_type</code></td>
<td>

<p>A character string specifying the file format to use for saving the output.
Valid options include <code>"csv"</code>, <code>"rds"</code> and <code>"rda"</code>.
</p>
</td></tr>
<tr><td><code id="findPublicClusters_+3A_output_dir_unfiltered">output_dir_unfiltered</code></td>
<td>

<p>An optional directory for saving the unfiltered network data for each sample.
By default, only the filtered results are saved.
</p>
</td></tr>
<tr><td><code id="findPublicClusters_+3A_output_type_unfiltered">output_type_unfiltered</code></td>
<td>

<p>A character string specifying the file format to use for saving the unfiltered
network data for each sample. Only applicable if <code>output_dir_unfiltered</code>
is non-null. Passed to <code><a href="#topic+buildRepSeqNetwork">buildRepSeqNetwork()</a></code>
when constructing the network for each sample.
</p>
</td></tr>
<tr><td><code id="findPublicClusters_+3A_verbose">verbose</code></td>
<td>

<p>Logical. If <code>TRUE</code>, generates messages about the tasks
performed and their progress, as well as relevant properties of intermediate
outputs. Messages are sent to <code><a href="base.html#topic+stderr">stderr()</a></code>.
</p>
</td></tr>
<tr><td><code id="findPublicClusters_+3A_...">...</code></td>
<td>

<p>Other arguments to <code>buildRepSeqNetwork</code> when constructing the network
for each sample, not including <code>node_stats</code>, <code>stats_to_include</code>,
<code>cluster_stats</code>, <code>cluster_id_name</code> or <code>output_name</code>
(see details).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each sample's network is constructed using an individual call to
<code><a href="#topic+buildRepSeqNetwork">buildNet()</a></code> with
<code>node_stats = TRUE</code>, <code>stats_to_include = "all"</code>,
<code>cluster_stats = TRUE</code> and <code>cluster_id_name = "ClusterIDInSample"</code>.
The node-level properties are renamed to reflect their
correspondence to the sample-level network. Specifically, the properties are named:
</p>

<ul>
<li> <p><code>SampleLevelNetworkDegree</code>
</p>
</li>
<li> <p><code>SampleLevelTransitivity</code>
</p>
</li>
<li> <p><code>SampleLevelCloseness</code>
</p>
</li>
<li> <p><code>SampleLevelCentralityByCloseness</code>
</p>
</li>
<li> <p><code>SampleLevelCentralityByEigen</code>
</p>
</li>
<li> <p><code>SampleLevelEigenCentrality</code>
</p>
</li>
<li> <p><code>SampleLevelBetweenness</code>
</p>
</li>
<li> <p><code>SampleLevelCentralityByBetweenness</code>
</p>
</li>
<li> <p><code>SampleLevelAuthorityScore</code>
</p>
</li>
<li> <p><code>SampleLevelCoreness</code>
</p>
</li>
<li> <p><code>SampleLevelPageRank</code>
</p>
</li></ul>

<p>A variable <code>SampleID</code>
is added to both the node-level and cluster-level meta data for each sample.
</p>
<p>After the clusters in each sample are filtered, the node-level and cluster-level
metadata are saved in the respective subdirectories <code>node_meta_data</code> and
<code>cluster_meta_data</code> of the output directory specified by <code>output_dir</code>.
</p>
<p>The unfiltered network results for each sample can also be saved by supplying a
directory to <code>output_dir_unfiltered</code>, if these results are desired for
downstream analysis. Each sample's unfiltered network results will then be saved
to its own subdirectory created within this directory.
</p>
<p>The files containing the node-level metadata for the filtered clusters can be
supplied to <code><a href="#topic+buildPublicClusterNetwork">buildPublicClusterNetwork()</a></code>
in order to construct a global
network of public clusters. If the full global network is too large to practically
construct, the files containing the cluster-level meta data for the filtered
clusters can be supplied to
<code><a href="#topic+buildPublicClusterNetworkByRepresentative">buildPublicClusterNetworkByRepresentative()</a></code>
to build a global network using only a single representative sequence from each
cluster. This allows prominent public clusters to still be identified.
</p>
<p>See the
<a href="https://mlizhangx.github.io/Network-Analysis-for-Repertoire-Sequencing-/articles/public_clusters.html">Searching for Public TCR/BCR Clusters</a>
article on the package website.
</p>


<h3>Value</h3>

<p>Returns <code>TRUE</code>, invisibly.
</p>


<h3>Author(s)</h3>

<p>Brian Neal (<a href="mailto:Brian.Neal@ucsf.edu">Brian.Neal@ucsf.edu</a>)
</p>


<h3>References</h3>

<p>Hai Yang, Jason Cham, Brian Neal, Zenghua Fan, Tao He and Li Zhang. (2023).
NAIR: Network Analysis of Immune Repertoire. <em>Frontiers in Immunology</em>, vol. 14.
<a href="https://www.frontiersin.org/articles/10.3389/fimmu.2023.1181825/full">doi: 10.3389/fimmu.2023.1181825</a>
</p>
<p><a href="https://mlizhangx.github.io/Network-Analysis-for-Repertoire-Sequencing-/index.html">Webpage for the NAIR package</a>
</p>
<p><a href="https://mlizhangx.github.io/Network-Analysis-for-Repertoire-Sequencing-/articles/public_clusters.html">Searching for Public TCR/BCR Clusters vignette</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildPublicClusterNetwork">buildPublicClusterNetwork()</a></code>
</p>
<p><code><a href="#topic+buildPublicClusterNetworkByRepresentative">buildPublicClusterNetworkByRepresentative()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)

## Simulate 30 samples with a mix of public/private sequences ##
samples &lt;- 30
sample_size &lt;- 30 # (seqs per sample)
base_seqs &lt;- c(
  "CASSIEGQLSTDTQYF", "CASSEEGQLSTDTQYF", "CASSSVETQYF",
  "CASSPEGQLSTDTQYF", "RASSLAGNTEAFF", "CASSHRGTDTQYF", "CASDAGVFQPQHF",
  "CASSLTSGYNEQFF", "CASSETGYNEQFF", "CASSLTGGNEQFF", "CASSYLTGYNEQFF",
  "CASSLTGNEQFF", "CASSLNGYNEQFF", "CASSFPWDGYGYTF", "CASTLARQGGELFF",
  "CASTLSRQGGELFF", "CSVELLPTGPLETSYNEQFF", "CSVELLPTGPSETSYNEQFF",
  "CVELLPTGPSETSYNEQFF", "CASLAGGRTQETQYF", "CASRLAGGRTQETQYF",
  "CASSLAGGRTETQYF", "CASSLAGGRTQETQYF", "CASSRLAGGRTQETQYF",
  "CASQYGGGNQPQHF", "CASSLGGGNQPQHF", "CASSNGGGNQPQHF", "CASSYGGGGNQPQHF",
  "CASSYGGGQPQHF", "CASSYKGGNQPQHF", "CASSYTGGGNQPQHF",
  "CAWSSQETQYF", "CASSSPETQYF", "CASSGAYEQYF", "CSVDLGKGNNEQFF")
# Relative generation probabilities
pgen &lt;- cbind(
  stats::toeplitz(0.6^(0:(sample_size - 1))),
  matrix(1, nrow = samples, ncol = length(base_seqs) - samples)
)
simulateToyData(
  samples = samples,
  sample_size = sample_size,
  prefix_length = 1,
  prefix_chars = c("", ""),
  prefix_probs = cbind(rep(1, samples), rep(0, samples)),
  affixes = base_seqs,
  affix_probs = pgen,
  num_edits = 0,
  output_dir = tempdir(),
  no_return = TRUE
)

sample_files &lt;-
  file.path(tempdir(),
            paste0("Sample", 1:samples, ".rds")
  )
findPublicClusters(
  file_list = sample_files,
  input_type = "rds",
  seq_col = "CloneSeq",
  count_col = "CloneCount",
  min_seq_length = NULL,
  drop_matches = NULL,
  top_n_clusters = 3,
  min_node_count = 5,
  min_clone_count = 15000,
  output_dir = tempdir()
)



</code></pre>

<hr>
<h2 id='generateAdjacencyMatrix'>
Compute Graph Adjacency Matrix for Immune Repertoire Network
</h2><span id='topic+generateAdjacencyMatrix'></span><span id='topic+sparseAdjacencyMatFromSeqs'></span>

<h3>Description</h3>

<p>Given a list of receptor sequences, computes the adjacency matrix for the
network graph based on sequence similarity.
</p>
<p><code>sparseAdjacencyMatFromSeqs()</code> is a deprecated equivalent of
<code>generateAdjacencyMatrix()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateAdjacencyMatrix(
  seqs,
  dist_type = "hamming",
  dist_cutoff = 1,
  drop_isolated_nodes = TRUE,
  method = "default",
  verbose = FALSE
)

# Deprecated equivalent:
sparseAdjacencyMatFromSeqs(
  seqs,
  dist_type = "hamming",
  dist_cutoff = 1,
  drop_isolated_nodes = TRUE,
  method = "default",
  verbose = FALSE,
  max_dist = deprecated()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateAdjacencyMatrix_+3A_seqs">seqs</code></td>
<td>

<p>A character vector containing the receptor sequences.
</p>
</td></tr>
<tr><td><code id="generateAdjacencyMatrix_+3A_dist_type">dist_type</code></td>
<td>

<p>Specifies the function used to quantify the similarity between sequences. The
similarity between two sequences determines the pairwise distance between their
respective nodes in the network graph, with greater similarity corresponding to
shorter distance. Valid options are <code>"hamming"</code> (the default), which uses
<code><a href="#topic+hamDistBounded">hamDistBounded</a></code>, and <code>"levenshtein"</code>, which uses
<code><a href="#topic+levDistBounded">levDistBounded</a></code>.
</p>
</td></tr>
<tr><td><code id="generateAdjacencyMatrix_+3A_dist_cutoff">dist_cutoff</code></td>
<td>

<p>A nonnegative scalar. Specifies the maximum pairwise distance (based on
<code>dist_type</code>) for an edge connection to exist between two nodes. Pairs of
nodes whose distance is less than or equal to this value will be joined by an
edge connection in the network graph. Controls the stringency of the network
construction and affects the number and density of edges in the network. A lower
cutoff value requires greater similarity between sequences in order for their
respective nodes to be joined by an edge connection. A value of <code>0</code> requires
two sequences to be identical in order for their nodes to be joined by an edge.
</p>
</td></tr>
<tr><td><code id="generateAdjacencyMatrix_+3A_drop_isolated_nodes">drop_isolated_nodes</code></td>
<td>

<p>Logical. When <code>TRUE</code>, removes each node that is not joined by an
edge connection to any other node in the network graph.
</p>
</td></tr>
<tr><td><code id="generateAdjacencyMatrix_+3A_method">method</code></td>
<td>

<p>A character string specifying the algorithm to use. Choices are <code>"default"</code> and  <code>"pattern"</code>. <code>"pattern"</code> is only valid when <code>dist_cutoff &lt; 3</code>, but tends to be faster than <code>"default"</code> for sparsely connected networks, at the cost of greater memory usage (can cause crashes for large or densely-connected networks, particularly for <code>dist_cutoff = 2</code>). The default algorithm tends to be faster for densely-connected networks or long sequences.
</p>
</td></tr>
<tr><td><code id="generateAdjacencyMatrix_+3A_verbose">verbose</code></td>
<td>

<p>Logical. If <code>TRUE</code>, generates messages about the tasks
performed and their progress, as well as relevant properties of intermediate
outputs. Messages are sent to <code><a href="base.html#topic+stderr">stderr</a></code>.
</p>
</td></tr>
<tr><td><code id="generateAdjacencyMatrix_+3A_max_dist">max_dist</code></td>
<td>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
Equivalent to <code>dist_cutoff</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The adjacency matrix of a graph with <code class="reqn">n</code> nodes is the symmetric
<code class="reqn">n \times n</code> matrix for which entry <code class="reqn">(i,j)</code> is equal to 1 if nodes
<code class="reqn">i</code> and <code class="reqn">j</code> are connected by an edge in the network graph and 0 otherwise.
</p>
<p>To construct the graph of the immune repertoire network, each receptor sequence
is modeled as a node. The similarity between receptor sequences, as measured
using either the Hamming or Levenshtein distance, determines the distance between
nodes in the network graph. The more similar two sequences are, the shorter the
distance between their respective nodes. Two nodes in the graph are joined by an
edge if the distance between them is sufficiently small, i.e., if their receptor
sequences are sufficiently similar.
</p>


<h3>Value</h3>

<p>A sparse matrix of class <code>dgCMatrix</code>
(see <code><a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix-class</a></code>).
</p>
<p>If <code>drop_isolated_nodes = TRUE</code>, the row and column names of the matrix
indicate which receptor sequences in the <code>seqs</code> vector correspond to each
row and column of the matrix. The row and column names can be accessed using
<code><a href="base.html#topic+dimnames">dimnames</a></code>. This returns a list containing two character vectors,
one for the row names and one for the column names. The name of the <code class="reqn">i</code>th
matrix row is the index of the <code>seqs</code> vector corresponding to the <code class="reqn">i</code>th
row and <code class="reqn">i</code>th column of the matrix. The  name of the <code class="reqn">j</code>th matrix column
is the receptor sequence corresponding to the <code class="reqn">j</code>th row and <code class="reqn">j</code>th column
of the matrix.
</p>


<h3>Author(s)</h3>

<p>Brian Neal (<a href="mailto:Brian.Neal@ucsf.edu">Brian.Neal@ucsf.edu</a>)
</p>


<h3>References</h3>

<p>Hai Yang, Jason Cham, Brian Neal, Zenghua Fan, Tao He and Li Zhang. (2023).
NAIR: Network Analysis of Immune Repertoire. <em>Frontiers in Immunology</em>, vol. 14.
<a href="https://www.frontiersin.org/articles/10.3389/fimmu.2023.1181825/full">doi: 10.3389/fimmu.2023.1181825</a>
</p>
<p><a href="https://mlizhangx.github.io/Network-Analysis-for-Repertoire-Sequencing-/index.html">Webpage for the NAIR package</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>generateAdjacencyMatrix(
  c("fee", "fie", "foe", "fum", "foo")
)

# No edge connections exist based on a Hamming distance of 1
# (returns a 0x0 sparse matrix)
generateAdjacencyMatrix(
  c("foo", "foobar", "fubar", "bar")
)

# Same as the above example, but keeping all nodes
# (returns a 4x4 sparse matrix)
generateAdjacencyMatrix(
  c("foo", "foobar", "fubar", "bar"),
  drop_isolated_nodes = FALSE
)

# Relaxing the edge criteria using a Hamming distance of 2
# (still results in no edge connections)
generateAdjacencyMatrix(
  c("foo", "foobar", "fubar", "bar"),
  dist_cutoff = 2
)

# Using a Levenshtein distance of 2, however,
# does result in edge connections
generateAdjacencyMatrix(
  c("foo", "foobar", "fubar", "bar"),
  dist_type = "levenshtein",
  dist_cutoff = 2
)

# Using a Hamming distance of 3
# also results in (different) edge connections
generateAdjacencyMatrix(
  c("foo", "foobar", "fubar", "bar"),
  dist_cutoff = 3
)
</code></pre>

<hr>
<h2 id='generateNetworkGraph'>
Generate the <code>igraph</code> for a Network Adjacency Matrix
</h2><span id='topic+generateNetworkGraph'></span><span id='topic+generateNetworkFromAdjacencyMat'></span>

<h3>Description</h3>

<p>Given the adjacency matrix of an undirected graph, returns the corresponding
<code><a href="igraph.html#topic+igraph">igraph</a></code> containing the list of nodes and edges.
</p>
<p><code>generateNetworkFromAdjacencyMat()</code> is a deprecated equivalent of
<code>generateNetworkGraph()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateNetworkGraph(
  adjacency_matrix
)

# Deprecated equivalent:
generateNetworkFromAdjacencyMat(
  adjacency_matrix
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateNetworkGraph_+3A_adjacency_matrix">adjacency_matrix</code></td>
<td>

<p>A symmetric matrix.
Passed to
<code><a href="igraph.html#topic+graph_from_adjacency_matrix">graph_from_adjacency_matrix()</a></code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="igraph.html#topic+igraph">igraph</a></code>,
containing the list of nodes and edges corresponding to <code>adjacency_matrix</code>.
</p>


<h3>Author(s)</h3>

<p>Brian Neal (<a href="mailto:Brian.Neal@ucsf.edu">Brian.Neal@ucsf.edu</a>)
</p>


<h3>References</h3>

<p>Hai Yang, Jason Cham, Brian Neal, Zenghua Fan, Tao He and Li Zhang. (2023).
NAIR: Network Analysis of Immune Repertoire. <em>Frontiers in Immunology</em>, vol. 14.
<a href="https://www.frontiersin.org/articles/10.3389/fimmu.2023.1181825/full">doi: 10.3389/fimmu.2023.1181825</a>
</p>
<p><a href="https://mlizhangx.github.io/Network-Analysis-for-Repertoire-Sequencing-/index.html">Webpage for the NAIR package</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
toy_data &lt;- simulateToyData(sample_size = 10)

adj_mat &lt;-
  generateAdjacencyMatrix(
    toy_data$CloneSeq
  )

igraph &lt;-
  generateNetworkGraph(
    adj_mat
  )
</code></pre>

<hr>
<h2 id='generateNetworkObjects'>
Generate Basic Output for an Immune Repertoire Network
</h2><span id='topic+generateNetworkObjects'></span>

<h3>Description</h3>

<p>Given Adaptive Immune Receptor Repertoire Sequencing (AIRR-Seq) data, builds
the network graph for the immune repertoire based on sequence similarity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateNetworkObjects(
  data,
  seq_col,
  dist_type = "hamming",
  dist_cutoff = 1,
  drop_isolated_nodes = TRUE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateNetworkObjects_+3A_data">data</code></td>
<td>

<p>A data frame containing the AIRR-Seq data, with variables indexed by column
and observations (e.g., clones or cells) indexed by row.
</p>
</td></tr>
<tr><td><code id="generateNetworkObjects_+3A_seq_col">seq_col</code></td>
<td>

<p>Specifies the column(s) of <code>data</code> containing
the receptor sequences to be used as the basis of similarity between rows.
Accepts a character string containing the column name
or a numeric scalar containing the column index.
Also accepts a vector of length 2 specifying distinct sequence columns
(e.g., alpha chain and beta chain), in which case
similarity between rows depends on similarity in both sequence columns
(see details).
</p>
</td></tr>
<tr><td><code id="generateNetworkObjects_+3A_dist_type">dist_type</code></td>
<td>

<p>Specifies the function used to measure the similarity between sequences.
The similarity between two sequences determines the pairwise distance between
their respective nodes in the network graph. Valid options are <code>"hamming"</code>
(the default), which
uses <code><a href="#topic+hamDistBounded">hamDistBounded()</a></code>,
and <code>"levenshtein"</code>, which uses
<code><a href="#topic+levDistBounded">levDistBounded()</a></code>.
</p>
</td></tr>
<tr><td><code id="generateNetworkObjects_+3A_dist_cutoff">dist_cutoff</code></td>
<td>

<p>A nonnegative scalar. Specifies the maximum pairwise distance (based on
<code>dist_type</code>) for an edge connection to exist between two nodes. Pairs
of nodes whose distance is less than or equal to this value will be joined
by an edge connection in the network graph. Controls the stringency of the
network construction and affects the number and density of edges in the network.
A lower cutoff value requires greater similarity between sequences in order for
their respective nodes to be joined by an edge connection. A value of <code>0</code>
requires two sequences to be identical in order for their nodes to be joined
by an edge.
</p>
</td></tr>
<tr><td><code id="generateNetworkObjects_+3A_drop_isolated_nodes">drop_isolated_nodes</code></td>
<td>

<p>A logical scalar. When <code>TRUE</code>, removes each node that is not joined by
an edge connection to any other node in the network graph.
</p>
</td></tr>
<tr><td><code id="generateNetworkObjects_+3A_verbose">verbose</code></td>
<td>

<p>Logical. If <code>TRUE</code>, generates messages about the tasks
performed and their progress, as well as relevant properties of intermediate
outputs. Messages are sent to <code><a href="base.html#topic+stderr">stderr()</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To construct the immune repertoire network, each TCR/BCR clone (bulk data)
or cell (single-cell data) is modeled as a node in the network graph,
corresponding to a single row of the AIRR-Seq data. For each node, the
corresponding receptor sequence is considered. Both nucleotide and amino acid
sequences are supported for this purpose. The receptor sequence is used as the
basis of similarity and distance between nodes in the network.
</p>
<p>Similarity between sequences is measured using either the Hamming distance
or Levenshtein (edit) distance. The similarity determines the pairwise distance
between nodes in the network graph. The more similar two sequences are, the
shorter the distance between their respective nodes. Two nodes are joined by
an edge if their receptor sequences are sufficiently similar, i.e., if the
distance between the nodes is sufficiently small.
</p>
<p>For single-cell data, edge connections between nodes can be based on similarity
in both the alpha chain and beta chain sequences.
This is done by providing a vector of length 2 to <code>seq_cols</code>
specifying the two sequence columns in <code>data</code>.
The distance between two nodes is then the greater of the two distances between
sequences in corresponding chains.
Two nodes will be joined by an edge if their alpha chain sequences are sufficiently
similar and their beta chain sequences are sufficiently similar.
</p>
<p>See the
<a href="https://mlizhangx.github.io/Network-Analysis-for-Repertoire-Sequencing-/articles/buildRepSeqNetwork.html">buildRepSeqNetwork</a>
package vignette for more details. The vignette can be accessed offline using
<code>vignette("buildRepSeqNetwork")</code>.
</p>


<h3>Value</h3>

<p>If the constructed network contains no nodes, the function will return
<code>NULL</code>, invisibly, with a warning. Otherwise, the function invisibly
returns a list containing the following items:
</p>
<table>
<tr><td><code>igraph</code></td>
<td>

<p>An object of class <code><a href="igraph.html#topic+igraph">igraph</a></code> containing the list of nodes
and edges for the network graph.
</p>
</td></tr>
<tr><td><code>adjacency_matrix</code></td>
<td>

<p>The network graph adjacency matrix, stored as a sparse matrix of class
<code>dgCMatrix</code> from the <code>Matrix</code> package. See
<code><a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix-class</a></code>.
</p>
</td></tr>
<tr><td><code>node_data</code></td>
<td>

<p>A data frame containing containing metadata for the network nodes, where each
row corresponds to a node in the network graph. This data frame contains all
variables from <code>data</code> (unless otherwise specified via <code>subset_cols</code>)
in addition to the computed node-level network properties if
<code>node_stats = TRUE</code>. Each row's name is the name of the corresponding
row from <code>data</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Brian Neal (<a href="mailto:Brian.Neal@ucsf.edu">Brian.Neal@ucsf.edu</a>)
</p>


<h3>References</h3>

<p>Hai Yang, Jason Cham, Brian Neal, Zenghua Fan, Tao He and Li Zhang. (2023).
NAIR: Network Analysis of Immune Repertoire. <em>Frontiers in Immunology</em>, vol. 14.
<a href="https://www.frontiersin.org/articles/10.3389/fimmu.2023.1181825/full">doi: 10.3389/fimmu.2023.1181825</a>
</p>
<p><a href="https://mlizhangx.github.io/Network-Analysis-for-Repertoire-Sequencing-/index.html">Webpage for the NAIR package</a>
</p>
<p><a href="https://mlizhangx.github.io/Network-Analysis-for-Repertoire-Sequencing-/articles/buildRepSeqNetwork.html">buildRepSeqNetwork vignette</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
toy_data &lt;- simulateToyData()

net &lt;-
  generateNetworkObjects(
    toy_data,
    "CloneSeq"
  )
</code></pre>

<hr>
<h2 id='getClusterStats'>
Compute Cluster-Level Network Properties
</h2><span id='topic+getClusterStats'></span>

<h3>Description</h3>

<p>Given the node-level metadata and adjacency matrix for a network graph that has
been partitioned into clusters, computes network properties for the clusters
and returns them in a data frame.
</p>
<p><code><a href="#topic+addClusterStats">addClusterStats()</a></code>
is preferred to <code>getClusterStats()</code> in most situations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getClusterStats(
  data,
  adjacency_matrix,
  seq_col = NULL,
  count_col = NULL,
  cluster_id_col = "cluster_id",
  degree_col = NULL,
  cluster_fun = deprecated(),
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getClusterStats_+3A_data">data</code></td>
<td>

<p>A data frame containing the node-level metadata for the network, with each
row corresponding to a network node.
</p>
</td></tr>
<tr><td><code id="getClusterStats_+3A_adjacency_matrix">adjacency_matrix</code></td>
<td>

<p>The adjacency matrix for the network.
</p>
</td></tr>
<tr><td><code id="getClusterStats_+3A_seq_col">seq_col</code></td>
<td>

<p>Specifies the column(s) of <code>data</code> containing
the receptor sequences upon whose similarity the network is based.
Accepts a character or numeric vector of length 1 or 2,
containing either column names or column indices.
If provided, then related cluster-level properties will be computed.
</p>
</td></tr>
<tr><td><code id="getClusterStats_+3A_count_col">count_col</code></td>
<td>

<p>Specifies the column of <code>data</code> containing
a measure of abundance (such as clone count or UMI count).
Accepts a character string containing the column name
or a numeric scalar containing the column index.
If provided, related cluster-level properties will be computed.
</p>
</td></tr>
<tr><td><code id="getClusterStats_+3A_cluster_id_col">cluster_id_col</code></td>
<td>

<p>Specifies the column of <code>data</code> containing the cluster membership
variable that identifies the cluster to which each node belongs.
Accepts a character string containing the column name
or a numeric scalar containing the column index.
</p>
</td></tr>
<tr><td><code id="getClusterStats_+3A_degree_col">degree_col</code></td>
<td>

<p>Specifies the column of <code>data</code> containing
the network degree of each node.
Accepts a character string containing the column name
or a numeric scalar containing the column index.
If the column does not exist, the network degree will be computed.
</p>
</td></tr>
<tr><td><code id="getClusterStats_+3A_cluster_fun">cluster_fun</code></td>
<td>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
Does nothing.
</p>
</td></tr>
<tr><td><code id="getClusterStats_+3A_verbose">verbose</code></td>
<td>

<p>Logical. If <code>TRUE</code>, generates messages about the tasks
performed and their progress, as well as relevant properties of intermediate
outputs. Messages are sent to <code><a href="base.html#topic+stderr">stderr()</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To use <code>getClusterStats()</code>,
the network graph must first be partitioned into clusters,
which can be done using
<code><a href="#topic+addClusterMembership">addClusterMembership()</a></code>.
The name of the cluster membership variable in the node metadata
must be provided to the <code>cluster_id_col</code> argument
when calling <code>getClusterStats()</code>.
</p>


<h3>Value</h3>

<p>A data frame containing one row for each cluster in the network
and the following variables:
</p>
<table>
<tr><td><code>cluster_id</code></td>
<td>

<p>The cluster ID number.
</p>
</td></tr>
<tr><td><code>node_count</code></td>
<td>

<p>The number of nodes in the cluster.
</p>
</td></tr>
<tr><td><code>mean_seq_length</code></td>
<td>

<p>The mean sequence length in the cluster.
Only present when <code>length(seq_col) == 1</code>.
</p>
</td></tr>
<tr><td><code>A_mean_seq_length</code></td>
<td>

<p>The mean first sequence length in the cluster.
Only present when <code>length(seq_col) == 2</code>.
</p>
</td></tr>
<tr><td><code>B_mean_seq_length</code></td>
<td>

<p>The mean second sequence length in the cluster.
Only present when <code>length(seq_col) == 2</code>.
</p>
</td></tr>
<tr><td><code>mean_degree</code></td>
<td>

<p>The mean network degree in the cluster.
</p>
</td></tr>
<tr><td><code>max_degree</code></td>
<td>

<p>The maximum network degree in the cluster.
</p>
</td></tr>
<tr><td><code>seq_w_max_degree</code></td>
<td>

<p>The receptor sequence possessing the maximum degree within the cluster.
Only present when <code>length(seq_col) == 1</code>.
</p>
</td></tr>
<tr><td><code>A_seq_w_max_degree</code></td>
<td>

<p>The first sequence of the node possessing the maximum degree within the cluster.
Only present when <code>length(seq_col) == 2</code>.
</p>
</td></tr>
<tr><td><code>B_seq_w_max_degree</code></td>
<td>

<p>The second sequence of the node possessing the maximum degree within the cluster.
Only present when <code>length(seq_col) == 2</code>.
</p>
</td></tr>
<tr><td><code>agg_count</code></td>
<td>

<p>The aggregate count among all nodes in the cluster (based on the counts in
<code>count_col</code>).
</p>
</td></tr>
<tr><td><code>max_count</code></td>
<td>

<p>The maximum count among all nodes in the cluster (based on the counts in
<code>count_col</code>).
</p>
</td></tr>
<tr><td><code>seq_w_max_count</code></td>
<td>

<p>The receptor sequence possessing the maximum count within the cluster.
Only present when <code>length(seq_col) == 1</code>.
</p>
</td></tr>
<tr><td><code>A_seq_w_max_count</code></td>
<td>

<p>The first sequence of the node possessing the maximum count within the cluster.
Only present when <code>length(seq_col) == 2</code>.
</p>
</td></tr>
<tr><td><code>B_seq_w_max_count</code></td>
<td>

<p>The second sequence of the node possessing the maximum count within the cluster.
Only present when <code>length(seq_col) == 2</code>.
</p>
</td></tr>
<tr><td><code>diameter_length</code></td>
<td>

<p>The longest geodesic distance in the cluster, computed as the length of the
vector returned by <code><a href="igraph.html#topic+get_diameter">get_diameter()</a></code>.
</p>
</td></tr>
<tr><td><code>assortativity</code></td>
<td>

<p>The assortativity coefficient of the cluster's graph, based on the degree
(minus one) of each node in the cluster (with the degree computed based only
upon the nodes within the cluster). Computed using
<code><a href="igraph.html#topic+assortativity_degree">assortativity_degree()</a></code>.
</p>
</td></tr>
<tr><td><code>global_transitivity</code></td>
<td>

<p>The transitivity (i.e., clustering coefficient) for the cluster's graph, which
estimates the probability that adjacent vertices are connected. Computed using
<code><a href="igraph.html#topic+transitivity">transitivity()</a></code> with <code>type = "global"</code>.
</p>
</td></tr>
<tr><td><code>edge_density</code></td>
<td>

<p>The number of edges in the cluster as a fraction of the maximum possible number
of edges. Computed using <code><a href="igraph.html#topic+edge_density">edge_density()</a></code>.
</p>
</td></tr>
<tr><td><code>degree_centrality_index</code></td>
<td>

<p>The centrality index of the cluster's graph based on within-cluster network degree.
Computed as the <code>centralization</code> element of the output from
<code><a href="igraph.html#topic+centr_degree">centr_degree()</a></code>.
</p>
</td></tr>
<tr><td><code>closeness_centrality_index</code></td>
<td>

<p>The centrality index of the cluster's graph based on closeness,
i.e., distance to other nodes in the cluster.
Computed using <code><a href="igraph.html#topic+centralization">centralization()</a></code>.
</p>
</td></tr>
<tr><td><code>eigen_centrality_index</code></td>
<td>

<p>The centrality index of the cluster's graph based on the eigenvector centrality scores,
i.e., values of the first eigenvector of the adjacency matrix for the cluster.
Computed as the <code>centralization</code> element of the output from
<code><a href="igraph.html#topic+centr_eigen">centr_eigen()</a></code>.
</p>
</td></tr>
<tr><td><code>eigen_centrality_eigenvalue</code></td>
<td>

<p>The eigenvalue corresponding to the first eigenvector of the adjacency matrix
for the cluster. Computed as the <code>value</code> element of the output from
<code><a href="igraph.html#topic+eigen_centrality">eigen_centrality()</a></code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Brian Neal (<a href="mailto:Brian.Neal@ucsf.edu">Brian.Neal@ucsf.edu</a>)
</p>


<h3>References</h3>

<p>Hai Yang, Jason Cham, Brian Neal, Zenghua Fan, Tao He and Li Zhang. (2023).
NAIR: Network Analysis of Immune Repertoire. <em>Frontiers in Immunology</em>, vol. 14.
<a href="https://www.frontiersin.org/articles/10.3389/fimmu.2023.1181825/full">doi: 10.3389/fimmu.2023.1181825</a>
</p>
<p><a href="https://mlizhangx.github.io/Network-Analysis-for-Repertoire-Sequencing-/index.html">Webpage for the NAIR package</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+addClusterStats">addClusterStats()</a></code>
<code><a href="#topic+addClusterMembership">addClusterMembership()</a></code>
<code><a href="#topic+labelClusters">labelClusters()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
toy_data &lt;- simulateToyData()

net &lt;-
  generateNetworkObjects(
    toy_data, "CloneSeq"
  )

net &lt;- addClusterMembership(net)

net$cluster_data &lt;-
  getClusterStats(
    net$node_data,
    net$adjacency_matrix,
    seq_col = "CloneSeq",
    count_col = "CloneCount"
  )
</code></pre>

<hr>
<h2 id='getNeighborhood'>
Identify Cells or Clones in a Neighborhood Around a Target Sequence
</h2><span id='topic+getNeighborhood'></span>

<h3>Description</h3>

<p>Given Adaptive Immune Receptor Repertoire Sequencing (AIRR-Seq) data and a
target receptor sequence that is present within the data, identifies a
&quot;neighborhood&quot; comprised of cells/clones with receptor sequences sufficiently
similar to the target sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getNeighborhood(
    data,
    seq_col,
    target_seq,
    dist_type = "hamming",
    max_dist = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getNeighborhood_+3A_data">data</code></td>
<td>

<p>A data frame containing the AIRR-Seq data.
</p>
</td></tr>
<tr><td><code id="getNeighborhood_+3A_seq_col">seq_col</code></td>
<td>

<p>Specifies the column of <code>data</code> containing the receptor sequences.
Accepts a character string containing the column name
or a numeric scalar containing the column index.
</p>
</td></tr>
<tr><td><code id="getNeighborhood_+3A_target_seq">target_seq</code></td>
<td>

<p>A character string containing the target receptor sequence. Must be a receptor
sequence possessed by one of the clones/cells in the AIRR-Seq data.
</p>
</td></tr>
<tr><td><code id="getNeighborhood_+3A_dist_type">dist_type</code></td>
<td>

<p>Specifies the function used to quantify the similarity between receptor
sequences. The similarity between two sequences determines their pairwise
distance, with greater similarity corresponding to shorter distance. Valid
options are <code>"hamming"</code> (the default), which
uses <code><a href="#topic+hamDistBounded">hamDistBounded()</a></code>,
and <code>"levenshtein"</code>, which uses
<code><a href="#topic+levDistBounded">levDistBounded()</a></code>.
</p>
</td></tr>
<tr><td><code id="getNeighborhood_+3A_max_dist">max_dist</code></td>
<td>

<p>Determines whether each cell/clone belongs to the neighborhood based on its
receptor sequence's distance from the target sequence. The distance is based
on the <code>dist_type</code> argument. <code>max_dist</code> specifies the maximum
distance at which a cell/clone belongs to the neighborhood. Lower values
require greater similarity between the target sequence and the receptor
sequences of cells/clones in its neighborhood.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the rows of <code>data</code> corresponding to the
cells/clones in the neighborhood.
</p>
<p>If no cell/clone in the AIRR-Seq data possesses the target sequence as its
receptor sequence, then a value of <code>NULL</code> is returned.
</p>


<h3>Author(s)</h3>

<p>Brian Neal (<a href="mailto:Brian.Neal@ucsf.edu">Brian.Neal@ucsf.edu</a>)
</p>


<h3>References</h3>

<p>Hai Yang, Jason Cham, Brian Neal, Zenghua Fan, Tao He and Li Zhang. (2023).
NAIR: Network Analysis of Immune Repertoire. <em>Frontiers in Immunology</em>, vol. 14.
<a href="https://www.frontiersin.org/articles/10.3389/fimmu.2023.1181825/full">doi: 10.3389/fimmu.2023.1181825</a>
</p>
<p><a href="https://mlizhangx.github.io/Network-Analysis-for-Repertoire-Sequencing-/index.html">Webpage for the NAIR package</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
toy_data &lt;- simulateToyData(sample_size = 500)

# Get neighborhood around first clone sequence
nbd &lt;-
  getNeighborhood(
    toy_data,
    seq_col = "CloneSeq",
    target_seq = "GGGGGGGAATTGG"
  )

head(nbd)

</code></pre>

<hr>
<h2 id='hamDistBounded'>
Bounded Computation of Hamming Distance
</h2><span id='topic+hamDistBounded'></span>

<h3>Description</h3>

<p>Computes the Hamming distance between two strings subject to a specified upper bound.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hamDistBounded(a, b, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hamDistBounded_+3A_a">a</code></td>
<td>

<p>A character string.
</p>
</td></tr>
<tr><td><code id="hamDistBounded_+3A_b">b</code></td>
<td>

<p>A character string to be compared to <code>a</code>.
</p>
</td></tr>
<tr><td><code id="hamDistBounded_+3A_k">k</code></td>
<td>

<p>The upper bound on the Hamming distance between <code>a</code> and <code>b</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For two character strings of equal length, the Hamming distance measures the total
number of character differences between characters in corresponding positions.
That is, for each position in one string, the character in that position is checked
to see whether it differs from the character in the same position of the other string.
</p>
<p>For two character strings of different lengths, the Hamming distance is not defined.
However, <code>hamDistBounded()</code> will accommodate strings of different
lengths, doing so in a conservative fashion that seeks to yield a meaningful result
for the purpose of checking whether two strings are sufficiently similar. If the two
strings differ in length, placeholder characters are appended to the shorter string
until its length matches that of the longer string. Each appended placeholder
character is treated as different from the character in the corresponding position
of the longer string. This is effectively the same as truncating the end of the
longer string and adding the number of deleted characters to the Hamming distance
between the shorter string and the truncated longer string (which is what is
actually done in practice, as the computation is faster).
</p>
<p>The above method used by <code>hamDistBounded()</code> to accommodate unequal string
lengths results in distance values whose meaning may be questionable, depending
on context, when the two strings have different lengths. The decision to append
placeholder characters to the end of the shorter string (as opposed to prepending
them to the beginning) is ad hoc and somewhat arbitrary. In effect, it allows two
strings of different lengths to be considered sufficiently similar if the content
of the shorter string sufficiently matches the beginning content of the longer
string and the difference in string length is not too great.
</p>
<p>For comparing sequences of different lengths, the Levenshtein distance (see
<code><a href="#topic+levDistBounded">levDistBounded()</a></code>)
is more appropriate and meaningful than using
<code>hamDistBounded()</code>, but comes at the cost of greater computational burden.
</p>
<p>Computation is aborted early if the Hamming distance is determined to exceed
the specified upper bound. This functionality is designed for cases when
distinguishing between values above the upper bound is not meaningful, taking
advantage of this fact to reduce the computational burden.
</p>


<h3>Value</h3>

<p>An integer. If the Hamming distance exceeds the specified upper bound <code>k</code>,
then a value of <code>-1</code> is returned. Otherwise, returns the Hamming distance
between <code>a</code> and <code>b</code>.
</p>


<h3>Note</h3>

<p>The computed value may be invalid when the length of either string is close to
or greater than the value of <code>INT_MAX</code> in the compiler that was used at
build time (typically 2147483647).
</p>


<h3>Author(s)</h3>

<p>Brian Neal (<a href="mailto:Brian.Neal@ucsf.edu">Brian.Neal@ucsf.edu</a>)
</p>


<h3>References</h3>

<p>Hai Yang, Jason Cham, Brian Neal, Zenghua Fan, Tao He and Li Zhang. (2023).
NAIR: Network Analysis of Immune Repertoire. <em>Frontiers in Immunology</em>, vol. 14.
<a href="https://www.frontiersin.org/articles/10.3389/fimmu.2023.1181825/full">doi: 10.3389/fimmu.2023.1181825</a>
</p>
<p><a href="https://mlizhangx.github.io/Network-Analysis-for-Repertoire-Sequencing-/index.html">Webpage for the NAIR package</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+levDistBounded">levDistBounded()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># using an upper bound of 3
# (trivial since strings have length 3)
hamDistBounded("foo", "foo", 3)
hamDistBounded("foo", "fee", 3)
hamDistBounded("foo", "fie", 3)
hamDistBounded("foo", "foe", 3)
hamDistBounded("foo", "fum", 3)
hamDistBounded("foo", "bar", 3)

# using an upper bound of 1
# (most distances exceed the upper bound)
hamDistBounded("foo", "fee", 1)
hamDistBounded("foo", "fie", 1)
hamDistBounded("foo", "foe", 1)
hamDistBounded("foo", "fum", 1)
hamDistBounded("foo", "bar", 1)

# comparing strings of nonmatching length
hamDistBounded("foo", "fubar", 10)
hamDistBounded("foo", "foobar", 10)
hamDistBounded("foo", "barfoo", 10)

</code></pre>

<hr>
<h2 id='labelClusters'>
Label Clusters in a Network Graph Plot
</h2><span id='topic+labelClusters'></span><span id='topic+addClusterLabels'></span>

<h3>Description</h3>

<p>Functions for labeling the clusters in network graph plots with their cluster
IDs.
The user can specify a cluster-level property by which to rank the clusters,
labeling only those clusters above a specified rank.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>labelClusters(
  net,
  plots = NULL,
  top_n_clusters = 20,
  cluster_id_col = "cluster_id",
  criterion = "node_count",
  size = 5, color = "black",
  greatest_values = TRUE
)

addClusterLabels(
  plot,
  net,
  top_n_clusters = 20,
  cluster_id_col = "cluster_id",
  criterion = "node_count",
  size = 5,
  color = "black",
  greatest_values = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="labelClusters_+3A_net">net</code></td>
<td>

<p>A <code><a href="base.html#topic+list">list</a></code> of network objects conforming to the output of
<code><a href="#topic+buildRepSeqNetwork">buildRepSeqNetwork()</a></code> or
<code><a href="#topic+generateNetworkObjects">generateNetworkObjects()</a></code>.
See details.
</p>
</td></tr>
<tr><td><code id="labelClusters_+3A_plots">plots</code></td>
<td>

<p>Specifies which plots in <code>net$plots</code> to annotate.
Accepts a character vector of element names or a numeric vector of element
position indices.
The default <code>NULL</code> annotates all plots.
</p>
</td></tr>
<tr><td><code id="labelClusters_+3A_plot">plot</code></td>
<td>

<p>A <code><a href="ggraph.html#topic+ggraph">ggraph</a></code> object containing the network graph plot.
</p>
</td></tr>
<tr><td><code id="labelClusters_+3A_top_n_clusters">top_n_clusters</code></td>
<td>

<p>A positive integer specifying the number of clusters to label. Those with the
highest rank according to the <code>criterion</code> argument will be labeled.
</p>
</td></tr>
<tr><td><code id="labelClusters_+3A_cluster_id_col">cluster_id_col</code></td>
<td>

<p>Specifies the column of <code>net$node_data</code> containing
the variable for cluster membership.
Accepts a character string containing the column name.
</p>
</td></tr>
<tr><td><code id="labelClusters_+3A_criterion">criterion</code></td>
<td>

<p>Can be used to specify a cluster-level network property by which to rank the
clusters. Non-default values are ignored unless <code>net$cluster_data</code> exists and
corresponds to the cluster membership variable specified by <code>cluster_id_col</code>.
Accepts a character string containing a column name of <code>net$cluster_data</code>.
The property must be quantitative for the ranking to be meaningful.
By default, clusters are ranked by node count, which is computed based on the
cluster membership values if necessary.
</p>
</td></tr>
<tr><td><code id="labelClusters_+3A_size">size</code></td>
<td>

<p>The font size of the cluster ID labels. Passed to the <code>size</code> argument of
<code><a href="ggraph.html#topic+geom_node_text">geom_node_text()</a></code>.
</p>
</td></tr>
<tr><td><code id="labelClusters_+3A_color">color</code></td>
<td>

<p>The color of the cluster ID labels. Passed to the <code>color</code> argument of
<code><a href="ggraph.html#topic+geom_node_text">geom_node_text()</a></code>.
</p>
</td></tr>
<tr><td><code id="labelClusters_+3A_greatest_values">greatest_values</code></td>
<td>

<p>Logical. Controls whether clusters are ranked according to the greatest or
least values of the property specified by the <code>criterion</code> argument. If
<code>TRUE</code>, clusters with greater values will be ranked above those with
lower values, thereby receiving a higher priority to be labeled.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The list <code>net</code> must contain the named elements
<code>igraph</code> (of class <code><a href="igraph.html#topic+igraph">igraph</a></code>),
<code>adjacency_matrix</code> (a <code><a href="base.html#topic+matrix">matrix</a></code> or
<code><a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix</a></code> encoding edge connections),
and <code>node_data</code> (a <code><a href="base.html#topic+data.frame">data.frame</a></code> containing node metadata),
all corresponding to the same network. The lists returned by
<code><a href="#topic+buildRepSeqNetwork">buildRepSeqNetwork()</a></code> and
<code><a href="#topic+generateNetworkObjects">generateNetworkObjects()</a></code>
are examples of valid inputs for the <code>net</code> argument.
</p>


<h3>Value</h3>

<p><code>labelClusters()</code> returns a copy of <code>net</code> with the specified plots
annotated.
</p>
<p><code>addClusterLabels()</code> returns an annotated copy of <code>plot</code>.
</p>


<h3>Author(s)</h3>

<p>Brian Neal (<a href="mailto:Brian.Neal@ucsf.edu">Brian.Neal@ucsf.edu</a>)
</p>


<h3>References</h3>

<p>Hai Yang, Jason Cham, Brian Neal, Zenghua Fan, Tao He and Li Zhang. (2023).
NAIR: Network Analysis of Immune Repertoire. <em>Frontiers in Immunology</em>, vol. 14.
<a href="https://www.frontiersin.org/articles/10.3389/fimmu.2023.1181825/full">doi: 10.3389/fimmu.2023.1181825</a>
</p>
<p><a href="https://mlizhangx.github.io/Network-Analysis-for-Repertoire-Sequencing-/index.html">Webpage for the NAIR package</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+addClusterMembership">addClusterMembership()</a></code>,
<code><a href="#topic+getClusterStats">getClusterStats()</a></code>,
<code><a href="#topic+generateNetworkGraphPlots">generateNetworkGraphPlots()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
toy_data &lt;- simulateToyData()

network &lt;- buildRepSeqNetwork(
  toy_data, "CloneSeq",
  cluster_stats = TRUE,
  color_nodes_by = "cluster_id",
  color_scheme = "turbo",
  color_legend = FALSE,
  plot_title = NULL,
  plot_subtitle = NULL,
  size_nodes_by = 1
)

network &lt;- labelClusters(network)

network$plots$cluster_id
</code></pre>

<hr>
<h2 id='labelNodes'>
Label Nodes in a Network Graph Plot
</h2><span id='topic+labelNodes'></span><span id='topic+addGraphLabels'></span>

<h3>Description</h3>

<p>Functions for annotating a graph plot to add custom labels to the nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>labelNodes(
  net,
  node_labels,
  plots = NULL,
  size = 5,
  color = "black"
)

addGraphLabels(
  plot,
  node_labels,
  size = 5,
  color = "black"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="labelNodes_+3A_net">net</code></td>
<td>

<p>A <code><a href="base.html#topic+list">list</a></code> of network objects conforming to the output of
<code><a href="#topic+buildRepSeqNetwork">buildRepSeqNetwork()</a></code> or
<code><a href="#topic+generateNetworkObjects">generateNetworkObjects()</a></code>.
See details.
</p>
</td></tr>
<tr><td><code id="labelNodes_+3A_plot">plot</code></td>
<td>

<p>A <code><a href="ggraph.html#topic+ggraph">ggraph</a></code> object containing the network graph plot.
</p>
</td></tr>
<tr><td><code id="labelNodes_+3A_node_labels">node_labels</code></td>
<td>

<p>A vector containing the node labels, where each entry is the label for a
single node. The length should match the number of nodes in the plot.
</p>
</td></tr>
<tr><td><code id="labelNodes_+3A_plots">plots</code></td>
<td>

<p>Specifies which plots in <code>net$plots</code> to annotate.
Accepts a character vector of element names or a numeric vector of element
position indices.
The default <code>NULL</code> annotates all plots.
</p>
</td></tr>
<tr><td><code id="labelNodes_+3A_size">size</code></td>
<td>

<p>The font size of the node labels. Passed to the <code>size</code> argument of
<code><a href="ggraph.html#topic+geom_node_text">geom_node_text()</a></code>.
</p>
</td></tr>
<tr><td><code id="labelNodes_+3A_color">color</code></td>
<td>

<p>The color of the node labels. Passed to the <code>size</code> argument of
<code><a href="ggraph.html#topic+geom_node_text">geom_node_text()</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The list <code>net</code> must contain the named elements
<code>igraph</code> (of class <code><a href="igraph.html#topic+igraph">igraph</a></code>),
<code>adjacency_matrix</code> (a <code><a href="base.html#topic+matrix">matrix</a></code> or
<code><a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix</a></code> encoding edge connections),
and <code>node_data</code> (a <code><a href="base.html#topic+data.frame">data.frame</a></code> containing node metadata),
all corresponding to the same network. The lists returned by
<code><a href="#topic+buildRepSeqNetwork">buildRepSeqNetwork()</a></code> and
<code><a href="#topic+generateNetworkObjects">generateNetworkObjects()</a></code>
are examples of valid inputs for the <code>net</code> argument.
</p>
<p>Labels are added using
<code><a href="ggraph.html#topic+geom_node_text">geom_node_text()</a></code>.
</p>


<h3>Value</h3>

<p><code>labelNodes()</code> returns a copy of <code>net</code> with the specified plots
annotated.
</p>
<p><code>addGraphLabels()</code> returns
a <code><a href="ggraph.html#topic+ggraph">ggraph</a></code> object containing the original plot annotated
with the node labels.
</p>


<h3>Author(s)</h3>

<p>Brian Neal (<a href="mailto:Brian.Neal@ucsf.edu">Brian.Neal@ucsf.edu</a>)
</p>


<h3>References</h3>

<p>Hai Yang, Jason Cham, Brian Neal, Zenghua Fan, Tao He and Li Zhang. (2023).
NAIR: Network Analysis of Immune Repertoire. <em>Frontiers in Immunology</em>, vol. 14.
<a href="https://www.frontiersin.org/articles/10.3389/fimmu.2023.1181825/full">doi: 10.3389/fimmu.2023.1181825</a>
</p>
<p><a href="https://mlizhangx.github.io/Network-Analysis-for-Repertoire-Sequencing-/index.html">Webpage for the NAIR package</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
toy_data &lt;-
  simulateToyData(
    samples = 1,
    sample_size = 10,
    prefix_length = 1
  )

# Generate network
network &lt;-
  buildNet(
    toy_data,
    seq_col = "CloneSeq",
    plot_title = NULL,
    plot_subtitle = NULL
  )

# Label each node with its receptor sequence
network &lt;- labelNodes(network, "CloneSeq", size = 3)

network$plots[[1]]

</code></pre>

<hr>
<h2 id='levDistBounded'>
Bounded Computation of Levenshtein Distance
</h2><span id='topic+levDistBounded'></span>

<h3>Description</h3>

<p>Computes the Levenshtein distance between two strings subject to a specified
upper bound.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>levDistBounded(a, b, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="levDistBounded_+3A_a">a</code></td>
<td>

<p>A character string.
</p>
</td></tr>
<tr><td><code id="levDistBounded_+3A_b">b</code></td>
<td>

<p>A character string to be compared to <code>a</code>.
</p>
</td></tr>
<tr><td><code id="levDistBounded_+3A_k">k</code></td>
<td>

<p>An integer specifying the upper bound on the Levenshtein distance between <code>a</code> and <code>b</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Levenshtein distance (sometimes referred to as edit distance) between two
character strings measures the minimum number of single-character edits
(insertions, deletions and transformations) needed to transform one string into
the other.
</p>
<p>Compared to the Hamming distance
(see <code><a href="#topic+hamDistBounded">hamDistBounded()</a></code>), the
Levenshtein distance is particularly useful for comparing sequences of different
lengths, as it can account for insertions and deletions, whereas the Hamming
distance only accounts for single-character transformations. However, the
computational burden for the Levenshtein distance can be significantly greater
than for the Hamming distance.
</p>
<p>Computation is aborted early if the Levenshtein distance is determined to exceed
the specified upper bound. This functionality is designed for cases when
distinguishing between values above the upper bound is not meaningful, taking
advantage of this fact to reduce the computational burden.
</p>


<h3>Value</h3>

<p>An integer. If the Levenshtein distance exceeds the specified upper bound
<code>k</code>, then a value of <code>-1</code> is returned. Otherwise, returns the
Levenshtein distance between <code>a</code> and <code>b</code>.
</p>


<h3>Note</h3>

<p>The computed value may be invalid when the length of either string is close to
or greater than the value of <code>INT_MAX</code> in the compiler that was used at
build time (typically 2147483647).
</p>


<h3>Author(s)</h3>

<p>Brian Neal (<a href="mailto:Brian.Neal@ucsf.edu">Brian.Neal@ucsf.edu</a>)
</p>


<h3>References</h3>

<p>Hai Yang, Jason Cham, Brian Neal, Zenghua Fan, Tao He and Li Zhang. (2023).
NAIR: Network Analysis of Immune Repertoire. <em>Frontiers in Immunology</em>, vol. 14.
<a href="https://www.frontiersin.org/articles/10.3389/fimmu.2023.1181825/full">doi: 10.3389/fimmu.2023.1181825</a>
</p>
<p><a href="https://mlizhangx.github.io/Network-Analysis-for-Repertoire-Sequencing-/index.html">Webpage for the NAIR package</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hamDistBounded">hamDistBounded</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># equal string lengths,
# character transmutations only
levDistBounded("foo", "bar", 3)
hamDistBounded("foo", "bar", 3) # agrees with Hamming distance

# one insertion, one deletion
levDistBounded("1234567", "1.23457", 7)
hamDistBounded("1234567", "1.23457", 7) # compare to Hamming distance

# same as above, but with a different lower bound
levDistBounded("1234567", "1.23457", 3) # within the bound
hamDistBounded("1234567", "1.23457", 3) # exceeds the bound

# one deletion (last position)
levDistBounded("1234567890", "123456789", 10)
hamDistBounded("1234567890", "123456789", 10)

# note the Hamming distance agrees with the Levenshtein distance
# for the above example, since the deletion occurs in the final
# character position. This is due to how hamDistBounded() handles
# strings of different lengths. In the example below, however...

# one deletion (first position)
levDistBounded("1234567890", "234567890", 10)
hamDistBounded("1234567890", "234567890", 10) # compare to Hamming distance

# one deletion, one transmutation
levDistBounded("foobar", "fubar", 6)
hamDistBounded("foobar", "fubar", 6) # compare to Hamming distance
</code></pre>

<hr>
<h2 id='plotNetworkGraph'>
Plot the Graph of an Immune Repertoire Network
</h2><span id='topic+plotNetworkGraph'></span>

<h3>Description</h3>

<p><img src="../help/figures/lifecycle-deprecated.svg" width="35%" alt="lifecycle-deprecated.svg" />
</p>
<p>Given the <code><a href="igraph.html#topic+igraph">igraph</a></code> of an immune repertoire network,
generates a plot of the network graph according to the user specifications.
</p>
<p>Deprecated. Replaced by <code><a href="#topic+addPlots">addPlots()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotNetworkGraph(
  igraph,
  plot_title = NULL,
  plot_subtitle = NULL,
  color_nodes_by = NULL,
  color_scheme = "default",
  color_legend = "auto",
  color_title = "auto",
  edge_width = 0.1,
  size_nodes_by = 0.5,
  node_size_limits = NULL,
  size_title = "auto",
  outfile = NULL,
  pdf_width = 12,
  pdf_height = 8
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotNetworkGraph_+3A_igraph">igraph</code></td>
<td>

<p>An object of class <code><a href="igraph.html#topic+igraph">igraph</a></code>.
</p>
</td></tr>
<tr><td><code id="plotNetworkGraph_+3A_plot_title">plot_title</code></td>
<td>

<p>A character string containing the plot title. Passed to
<code><a href="ggplot2.html#topic+labs">labs()</a></code>.
</p>
</td></tr>
<tr><td><code id="plotNetworkGraph_+3A_plot_subtitle">plot_subtitle</code></td>
<td>

<p>A character string containing the plot subtitle. Passed to
<code><a href="ggplot2.html#topic+labs">labs()</a></code>.
</p>
</td></tr>
<tr><td><code id="plotNetworkGraph_+3A_color_nodes_by">color_nodes_by</code></td>
<td>

<p>A vector whose length matches the number of nodes in the network.
The values are used to encode the color of each node. An argument value of
<code>NULL</code> (the default) leaves the nodes uncolored. Passed to the color
aesthetic mapping of <code><a href="ggraph.html#topic+geom_node_point">geom_node_point()</a></code>.
</p>
</td></tr>
<tr><td><code id="plotNetworkGraph_+3A_color_scheme">color_scheme</code></td>
<td>

<p>A character string specifying the color scale used to color the nodes.
<code>"default"</code> uses default <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code> colors.
Other options are one of the viridis color scales (e.g., <code>"plasma"</code>,
<code>"A"</code> or other valid inputs to the <code>option</code> argument of
<code><a href="ggraph.html#topic+scale_color_viridis">scale_color_viridis()</a></code>) or
(for discrete variables) a palette
from <code><a href="grDevices.html#topic+hcl.pals">hcl.pals()</a></code> (e.g., <code>"RdYlGn"</code>).
Each of the viridis color scales can include the suffix <code>"-1"</code>
to reverse its direction (e.g., <code>"plasma-1"</code> or <code>"A-1"</code>).
</p>
</td></tr>
<tr><td><code id="plotNetworkGraph_+3A_color_legend">color_legend</code></td>
<td>

<p>A logical scalar specifying whether to display the color legend in the plot.
The default value of <code>"auto"</code> shows the color legend if <code>color_nodes_by</code>
is a continuous variable or a discrete variable with at most 20 distinct values.
</p>
</td></tr>
<tr><td><code id="plotNetworkGraph_+3A_color_title">color_title</code></td>
<td>

<p>A character string (or <code>NULL</code>) specifying the title for the color legend.
Only applicable if  <code>color_nodes_by</code> is a vector. If
<code>color_title = "auto"</code> (the default), the title for the color legend will
be the name of the vector provided to <code>color_nodes_by</code>.
</p>
</td></tr>
<tr><td><code id="plotNetworkGraph_+3A_edge_width">edge_width</code></td>
<td>

<p>A numeric scalar specifying the width of the graph edges in the plot.
Passed to the <code>width</code> argument of
<code><a href="ggraph.html#topic+geom_edge_link0">geom_edge_link0()</a></code>.
</p>
</td></tr>
<tr><td><code id="plotNetworkGraph_+3A_size_nodes_by">size_nodes_by</code></td>
<td>

<p>A numeric scalar specifying the size of the nodes, or a numeric vector with
positive entires that encodes the size of each node (and whose length matches
the number of nodes in the network). Alternatively, an argument value of
<code>NULL</code> uses the default <code><a href="ggraph.html#topic+ggraph">ggraph()</a></code> size
for all nodes.
Passed to the size aesthetic mapping of
<code><a href="ggraph.html#topic+geom_node_point">geom_node_point()</a></code>.
</p>
</td></tr>
<tr><td><code id="plotNetworkGraph_+3A_size_title">size_title</code></td>
<td>

<p>A character string (or <code>NULL</code>) specifying the title for the size legend.
Only applicable if  <code>size_nodes_by</code> is a vector. If
<code>size_title = "auto"</code> (the default),  the title for the color legend
will be the name of the vector provided to  <code>size_nodes_by</code>.
</p>
</td></tr>
<tr><td><code id="plotNetworkGraph_+3A_node_size_limits">node_size_limits</code></td>
<td>

<p>A numeric vector of length 2, specifying the minimum and maximum node size.
Only applicable if <code>size_nodes_by</code> is a vector. If
<code>node_size_limits = NULL</code>, the default size scale will be used.
</p>
</td></tr>
<tr><td><code id="plotNetworkGraph_+3A_outfile">outfile</code></td>
<td>

<p>An optional file path for saving the plot as a pdf. If <code>NULL</code>
(the default), no pdf will be saved.
</p>
</td></tr>
<tr><td><code id="plotNetworkGraph_+3A_pdf_width">pdf_width</code></td>
<td>

<p>Sets the plot width when writing to pdf. Passed to the <code>width</code> argument
of <code><a href="grDevices.html#topic+pdf">pdf()</a></code>.
</p>
</td></tr>
<tr><td><code id="plotNetworkGraph_+3A_pdf_height">pdf_height</code></td>
<td>

<p>Sets the plot height when writing to pdf. Passed to the <code>height</code> argument
of <code><a href="grDevices.html#topic+pdf">pdf()</a></code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="ggraph.html#topic+ggraph">ggraph</a></code> object.
</p>


<h3>Author(s)</h3>

<p>Brian Neal (<a href="mailto:Brian.Neal@ucsf.edu">Brian.Neal@ucsf.edu</a>)
</p>


<h3>References</h3>

<p>Hai Yang, Jason Cham, Brian Neal, Zenghua Fan, Tao He and Li Zhang. (2023).
NAIR: Network Analysis of Immune Repertoire. <em>Frontiers in Immunology</em>, vol. 14.
<a href="https://www.frontiersin.org/articles/10.3389/fimmu.2023.1181825/full">doi: 10.3389/fimmu.2023.1181825</a>
</p>
<p><a href="https://mlizhangx.github.io/Network-Analysis-for-Repertoire-Sequencing-/index.html">Webpage for the NAIR package</a>
</p>
<p><a href="https://mlizhangx.github.io/Network-Analysis-for-Repertoire-Sequencing-/articles/network_visualization.html">Network Visualization article on package website</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+addPlots">addPlots()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
toy_data &lt;- simulateToyData()

# Generate network for data
net &lt;- buildNet(toy_data, "CloneSeq")

# Plot network graph
net_plot &lt;- plotNetworkGraph(
  net$igraph,
  color_nodes_by =
    net$node_data$SampleID,
  color_title = NULL,
  size_nodes_by =
    net$node_data$CloneCount,
  size_title = "Clone Count",
  node_size_limits = c(0.5, 1.5))

print(net_plot)

</code></pre>

<hr>
<h2 id='saveNetwork'>
Save List of Network Objects
</h2><span id='topic+saveNetwork'></span>

<h3>Description</h3>

<p>Given a list of network objects such as that returned by
<code><a href="#topic+buildRepSeqNetwork">buildRepSeqNetwork()</a></code> or <code><a href="#topic+generateNetworkObjects">generateNetworkObjects</a></code>,
saves its contents according to the specified file format scheme.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saveNetwork(
  net,
  output_dir,
  output_type = "rds",
  output_name = "MyRepSeqNetwork",
  pdf_width = 12,
  pdf_height = 10,
  verbose = FALSE,
  output_filename = deprecated()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saveNetwork_+3A_net">net</code></td>
<td>

<p>A list of network objects returned by
<code><a href="#topic+buildRepSeqNetwork">buildRepSeqNetwork()</a></code> or
<code><a href="#topic+generateNetworkObjects">generateNetworkObjects()</a></code>.
</p>
</td></tr>
<tr><td><code id="saveNetwork_+3A_output_dir">output_dir</code></td>
<td>

<p>A file path specifying the directory in which to write the file(s).
</p>
</td></tr>
<tr><td><code id="saveNetwork_+3A_output_type">output_type</code></td>
<td>

<p>A character string specifying the file format scheme to use when writing output
to file. Valid options are <code>"individual"</code>, <code>"rds"</code> and <code>"rda"</code>.
See detials.
</p>
</td></tr>
<tr><td><code id="saveNetwork_+3A_output_name">output_name</code></td>
<td>

<p>A character string. All files saved will have file names beginning with this value.
</p>
</td></tr>
<tr><td><code id="saveNetwork_+3A_pdf_width">pdf_width</code></td>
<td>

<p>If the list contains plots, this controls the width of each plot when writing
to pdf. Passed to the <code>width</code> argument of the <code><a href="grDevices.html#topic+pdf">pdf</a></code>
function.
</p>
</td></tr>
<tr><td><code id="saveNetwork_+3A_pdf_height">pdf_height</code></td>
<td>

<p>If the list contains plots, this controls the height of each plot when writing
to pdf. Passed to the <code>height</code> argument of the <code><a href="grDevices.html#topic+pdf">pdf</a></code>
function.
</p>
</td></tr>
<tr><td><code id="saveNetwork_+3A_verbose">verbose</code></td>
<td>

<p>Logical. If <code>TRUE</code>, generates messages about the tasks
performed and their progress, as well as relevant properties of intermediate
outputs. Messages are sent to <code><a href="base.html#topic+stderr">stderr()</a></code>.
</p>
</td></tr>
<tr><td><code id="saveNetwork_+3A_output_filename">output_filename</code></td>
<td>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
Equivalent to <code>output_name</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The list <code>net</code> must contain the named elements
<code>igraph</code> (of class <code><a href="igraph.html#topic+igraph">igraph</a></code>),
<code>adjacency_matrix</code> (a <code><a href="base.html#topic+matrix">matrix</a></code> or
<code><a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix</a></code> encoding edge connections),
and <code>node_data</code> (a <code><a href="base.html#topic+data.frame">data.frame</a></code> containing node metadata),
all corresponding to the same network. The list returned by
<code><a href="#topic+buildRepSeqNetwork">buildRepSeqNetwork()</a></code> and
<code><a href="#topic+generateNetworkObjects">generateNetworkObjects()</a></code>
is an example of a valid input for the <code>net</code> argument.
</p>
<p>The additional elements <code>cluster_data</code> (a <code><a href="base.html#topic+data.frame">data.frame</a></code>) and
<code>plots</code> (a list containing objects of class
<code><a href="ggraph.html#topic+ggraph">ggraph</a></code>
and possibly one <code><a href="base.html#topic+matrix">matrix</a></code> named <code>graph_layout</code>)
will also be saved, if present.
</p>
<p>By default, the list <code>net</code> is saved to a compressed data file in the
RDS format, while any plots present are printed to a single pdf containing
one plot per page.
</p>
<p>The name of each saved file begins with the value of <code>output_name</code>.
When <code>output_type</code> is one of <code>"rds"</code> or <code>"rda"</code>,
only two files are saved (the rds/rda and the pdf); for each file,
<code>output_name</code> is followed by the appropriate file extension.
</p>
<p>When <code>output_type = "individual"</code>, each element of <code>net</code> is saved
as a separate file, where <code>output_name</code> is followed by:
</p>

<ul>
<li> <p><code>_NodeMetadata.csv</code> for <code>node_data</code>
</p>
</li>
<li> <p><code>_ClusterMetadata.csv</code> for <code>cluster_data</code>
</p>
</li>
<li> <p><code>_EdgeList.txt</code> for <code>igraph</code>
</p>
</li>
<li> <p><code>_AdjacencyMatrix.mtx</code> for <code>adjacency_matrix</code>
</p>
</li>
<li> <p><code>_Plots.rda</code> for <code>plots</code>
</p>
</li>
<li> <p><code>_GraphLayout.txt</code> for <code>plots$graph_layout</code>
</p>
</li>
<li> <p><code>_Details.rds</code> for <code>details</code>
</p>
</li></ul>

<p><code>node_data</code> and <code>cluster_data</code> are saved using
<code><a href="utils.html#topic+write.csv">write.csv()</a></code>,
with <code>row.names</code> being <code>TRUE</code> for <code>node_data</code>
and <code>FALSE</code> for <code>cluster_data</code>.
The <code>igraph</code> is saved using
<code><a href="igraph.html#topic+write_graph">write_graph()</a></code> with <code>format = "edgelist"</code>.
The adjacency matrix is saved using <code><a href="Matrix.html#topic+writeMM">writeMM()</a></code>.
The graph layout is saved using <code><a href="base.html#topic+write">write()</a></code> with
<code>ncolumns = 2</code>.
</p>


<h3>Value</h3>

<p>Returns <code>TRUE</code> if output is saved, otherwise returns <code>FALSE</code> (with a warning if <code>output_dir</code> is non-null and the specified directory does not exist and could not be created).
</p>


<h3>Author(s)</h3>

<p>Brian Neal (<a href="mailto:Brian.Neal@ucsf.edu">Brian.Neal@ucsf.edu</a>)
</p>


<h3>References</h3>

<p>Hai Yang, Jason Cham, Brian Neal, Zenghua Fan, Tao He and Li Zhang. (2023).
NAIR: Network Analysis of Immune Repertoire. <em>Frontiers in Immunology</em>, vol. 14.
<a href="https://www.frontiersin.org/articles/10.3389/fimmu.2023.1181825/full">doi: 10.3389/fimmu.2023.1181825</a>
</p>
<p><a href="https://mlizhangx.github.io/Network-Analysis-for-Repertoire-Sequencing-/index.html">Webpage for the NAIR package</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
toy_data &lt;- simulateToyData()

net &lt;- buildRepSeqNetwork(
  toy_data,
  seq_col = "CloneSeq",
  node_stats = TRUE,
  cluster_stats = TRUE,
  color_nodes_by = c("transitivity", "SampleID")
)

# save as single RDS file
saveNetwork(
  net,
  output_dir = tempdir(),
  verbose = TRUE
)

saveNetwork(
  net,
  output_dir = tempdir(),
  output_type = "individual",
  verbose = TRUE
)


</code></pre>

<hr>
<h2 id='saveNetworkPlots'>
Write Plots to a PDF
</h2><span id='topic+saveNetworkPlots'></span>

<h3>Description</h3>

<p>Given a list of plots, write all plots to a single pdf file containing one
plot per page, and optionally save the graph layout as a csv file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saveNetworkPlots(
  plotlist,
  outfile,
  pdf_width = 12,
  pdf_height = 10,
  outfile_layout = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saveNetworkPlots_+3A_plotlist">plotlist</code></td>
<td>

<p>A named list whose elements are of class <code><a href="ggraph.html#topic+ggraph">ggraph</a></code>. May
also contain an element named <code>graph_layout</code> with the matrix specifying
the graph layout.
</p>
</td></tr>
<tr><td><code id="saveNetworkPlots_+3A_outfile">outfile</code></td>
<td>

<p>A <code><a href="base.html#topic+connection">connection</a></code> or a character string containing the file path
used to save the pdf.
</p>
</td></tr>
<tr><td><code id="saveNetworkPlots_+3A_pdf_width">pdf_width</code></td>
<td>

<p>Sets the page width. Passed to the <code>width</code> argument of
<code><a href="grDevices.html#topic+pdf">pdf()</a></code>.
</p>
</td></tr>
<tr><td><code id="saveNetworkPlots_+3A_pdf_height">pdf_height</code></td>
<td>

<p>Sets the page height. Passed to the <code>height</code> argument of
<code><a href="grDevices.html#topic+pdf">pdf()</a></code>.
</p>
</td></tr>
<tr><td><code id="saveNetworkPlots_+3A_outfile_layout">outfile_layout</code></td>
<td>

<p>An optional <code><a href="base.html#topic+connection">connection</a></code> or file path for saving the graph layout.
Passed to
the <code>file</code> argument of <code><a href="base.html#topic+write">write()</a></code>,
which is called with <code>ncolumns = 2</code>.
</p>
</td></tr>
<tr><td><code id="saveNetworkPlots_+3A_verbose">verbose</code></td>
<td>

<p>Logical. If <code>TRUE</code>, generates messages about the tasks
performed and their progress, as well as relevant properties of intermediate
outputs. Messages are sent to <code><a href="base.html#topic+stderr">stderr()</a></code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>TRUE</code>, invisibly.
</p>


<h3>Author(s)</h3>

<p>Brian Neal (<a href="mailto:Brian.Neal@ucsf.edu">Brian.Neal@ucsf.edu</a>)
</p>


<h3>References</h3>

<p>Hai Yang, Jason Cham, Brian Neal, Zenghua Fan, Tao He and Li Zhang. (2023).
NAIR: Network Analysis of Immune Repertoire. <em>Frontiers in Immunology</em>, vol. 14.
<a href="https://www.frontiersin.org/articles/10.3389/fimmu.2023.1181825/full">doi: 10.3389/fimmu.2023.1181825</a>
</p>
<p><a href="https://mlizhangx.github.io/Network-Analysis-for-Repertoire-Sequencing-/index.html">Webpage for the NAIR package</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
toy_data &lt;- simulateToyData()

net &lt;-
  generateNetworkObjects(
    toy_data,
    "CloneSeq"
  )

net &lt;-
  addPlots(
    net,
    color_nodes_by =
      c("SampleID", "CloneCount"),
    print_plots = TRUE
  )

saveNetworkPlots(
  net$plots,
  outfile =
    file.path(tempdir(), "network.pdf"),
  outfile_layout =
    file.path(tempdir(), "graph_layout.txt")
)

# Load saved graph layout
graph_layout &lt;- matrix(
  scan(file.path(tempdir(), "graph_layout.txt"), quiet = TRUE),
  ncol = 2
)
all.equal(graph_layout, net$plots$graph_layout)



</code></pre>

<hr>
<h2 id='simulateToyData'>
Generate Toy AIRR-Seq Data
</h2><span id='topic+simulateToyData'></span>

<h3>Description</h3>

<p>Generates toy data that can be used to test or demonstrate the behavior of
functions in the <code>NAIR</code> package.  Created as a lightweight tool for use in
tests, examples and vignettes. This function is not intended to simulate realistic
data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulateToyData(
  samples = 2,
  chains = 1,
  sample_size = 100,
  prefix_length = 7,
  prefix_chars = c("G", "A", "T", "C"),
  prefix_probs = rbind(
    "sample1" = c(12, 4, 1, 1),
    "sample2" = c(4, 12, 1, 1)),
  affixes = c("AATTGG", "AATCGG", "AATTCG",
              "AATTGC", "AATTG", "AATTC"),
  affix_probs = rbind(
    "sample1" = c(10, 4, 2, 2, 1, 1),
    "sample2" = c(1, 1, 1, 2, 2.5, 2.5)),
  num_edits = 0,
  edit_pos_probs = function(seq_length) {
    stats::dnorm(seq(-4, 4, length.out = seq_length))
  },
  edit_ops = c("insertion", "deletion", "transmutation"),
  edit_probs = c(5, 1, 4),
  new_chars = prefix_chars,
  new_probs = prefix_probs,
  output_dir = NULL,
  no_return = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulateToyData_+3A_samples">samples</code></td>
<td>

<p>The number of distinct samples to include in the data.
</p>
</td></tr>
<tr><td><code id="simulateToyData_+3A_chains">chains</code></td>
<td>

<p>The number of chains (either 1 or 2) for which to generate receptor sequences.
</p>
</td></tr>
<tr><td><code id="simulateToyData_+3A_sample_size">sample_size</code></td>
<td>

<p>The number of observations to generate per sample.
</p>
</td></tr>
<tr><td><code id="simulateToyData_+3A_prefix_length">prefix_length</code></td>
<td>

<p>The length of the random prefix generated for each observed sequence.
Specifically, the number of elements of <code>prefix_chars</code> that are sampled
with replacement and concatenated to form each prefix.
</p>
</td></tr>
<tr><td><code id="simulateToyData_+3A_prefix_chars">prefix_chars</code></td>
<td>

<p>A character vector containing characters or strings from which to sample when
generating the prefix for each observed sequence.
</p>
</td></tr>
<tr><td><code id="simulateToyData_+3A_prefix_probs">prefix_probs</code></td>
<td>

<p>A numeric matrix whose column dimension matches the length of <code>prefix_chars</code>
and with row dimension matching the value of <code>samples</code>. The <code class="reqn">i</code>th row
specifies the relative probability weights assigned to each element of
<code>prefix_chars</code> when sampling to form the prefix for each sequence in the
<code class="reqn">i</code>th sample.
</p>
</td></tr>
<tr><td><code id="simulateToyData_+3A_affixes">affixes</code></td>
<td>

<p>A character vector containing characters or strings from which to sample when
generating the suffix for each observed sequence.
</p>
</td></tr>
<tr><td><code id="simulateToyData_+3A_affix_probs">affix_probs</code></td>
<td>

<p>A numeric matrix whose column dimension matches the length of <code>affixes</code>
and with row dimension matching the value of <code>samples</code>. The <code class="reqn">i</code>th
row specifies the relative probability weights assigned to each element of
<code>affixes</code> when sampling to form the suffix for each sequence in the
<code class="reqn">i</code>th sample.
</p>
</td></tr>
<tr><td><code id="simulateToyData_+3A_num_edits">num_edits</code></td>
<td>

<p>A nonnegative integer specifying the number of random edit operations to
perform on each observed sequence after its initial generation.
</p>
</td></tr>
<tr><td><code id="simulateToyData_+3A_edit_pos_probs">edit_pos_probs</code></td>
<td>

<p>A function that accepts a nonnegative integer (the character length of a
sequence) as its argument and returns a vector of this length containing
probability weights. Each time an edit operation is performed on a sequence,
the character position at which to perform the operation is randomly
determined according to the probabilities given by this function.
</p>
</td></tr>
<tr><td><code id="simulateToyData_+3A_edit_ops">edit_ops</code></td>
<td>

<p>A character vector specifying the possible operations that can be performed
for each edit. The default value includes all valid operations (insertion,
deletion, transmutation).
</p>
</td></tr>
<tr><td><code id="simulateToyData_+3A_edit_probs">edit_probs</code></td>
<td>

<p>A numeric vector of the same length as <code>edit_ops</code>, specifying the relative
probability weights assigned to each edit operation.
</p>
</td></tr>
<tr><td><code id="simulateToyData_+3A_new_chars">new_chars</code></td>
<td>

<p>A character vector containing characters or strings from which to sample when
performing an insertion edit operation.
</p>
</td></tr>
<tr><td><code id="simulateToyData_+3A_new_probs">new_probs</code></td>
<td>

<p>A numeric matrix whose column dimension matches the length of <code>new_chars</code>
and with row dimension matching the value of <code>samples</code>. The <code class="reqn">i</code>th row
specifies, for the <code class="reqn">i</code>th sample, the relative probability weights assigned
to each element of <code>new_chars</code> when performing a transmutation or insertion
as a random edit operation.
</p>
</td></tr>
<tr><td><code id="simulateToyData_+3A_output_dir">output_dir</code></td>
<td>

<p>An optional character string specifying a file directory to save the generated
data. One file will be generated per sample.
</p>
</td></tr>
<tr><td><code id="simulateToyData_+3A_no_return">no_return</code></td>
<td>

<p>A logical flag that can be used to prevent the function from returning the
generated data. If <code>TRUE</code>, the function will instead return <code>TRUE</code>
once all processes are complete.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each observed sequence is obtained by separately generating a prefix and
suffix according to the specified settings, then joining the two and performing
sequential rounds of edit operations randomized according to the user's
specifications.
</p>
<p>Count data is generated for each observation; note that this count data is
generated independently from the observed sequences and has no relationship
to them.
</p>


<h3>Value</h3>

<p>If <code>no_return = FALSE</code> (the default), a <code>data.frame</code> whose contents depend
on the value of the <code>chains</code> argument.
</p>
<p>For <code>chains = 1</code>, the data frame contains the following variables:
</p>
<table>
<tr><td><code>CloneSeq</code></td>
<td>
<p>The &quot;receptor sequence&quot; for each observation.</p>
</td></tr>
<tr><td><code>CloneFrequency</code></td>
<td>
<p>The &quot;clone frequency&quot; for each observation (clone count
as a proportion of the aggregate clone count within each sample).</p>
</td></tr>
<tr><td><code>CloneCount</code></td>
<td>
<p>The &quot;clone count&quot; for each observation.</p>
</td></tr>
<tr><td><code>SampleID</code></td>
<td>
<p>The sample ID for each observation.</p>
</td></tr>
</table>
<p>For <code>chains = 2</code>, the data frame contains the following variables:
</p>
<table>
<tr><td><code>AlphaSeq</code></td>
<td>
<p>The &quot;alpha chain&quot; receptor sequence for each observation.</p>
</td></tr>
<tr><td><code>AlphaSeq</code></td>
<td>
<p>The &quot;beta chain&quot; receptor sequence for each observation.</p>
</td></tr>
<tr><td><code>UMIs</code></td>
<td>
<p>The &quot;unique molecular identifier count&quot; for each observation.</p>
</td></tr>
<tr><td><code>Count</code></td>
<td>
<p>The &quot;count&quot; for each observation.</p>
</td></tr>
<tr><td><code>SampleID</code></td>
<td>
<p>The sample ID for each observation.</p>
</td></tr>
</table>
<p>If <code>no_return = TRUE</code>, the function returns <code>TRUE</code> upon completion.
</p>


<h3>Author(s)</h3>

<p>Brian Neal (<a href="mailto:Brian.Neal@ucsf.edu">Brian.Neal@ucsf.edu</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)

# Bulk data from two samples
dat1 &lt;- simulateToyData()

# Single-cell data with alpha and beta chain sequences
dat2 &lt;- simulateToyData(chains = 2)

# Write data to file, return nothing
simulateToyData(sample_size = 500,
                num_edits = 10,
                no_return = TRUE,
                output_dir = tempdir())

# Example customization
dat4 &lt;-
  simulateToyData(
    samples = 5,
    sample_size = 50,
    prefix_length = 0,
    prefix_chars = "",
    prefix_probs = matrix(1, nrow = 5),
    affixes = c("CASSLGYEQYF", "CASSLGETQYF",
                "CASSLGTDTQYF", "CASSLGTEAFF",
                "CASSLGGTEAFF", "CAGLGGRDQETQYF",
                "CASSQETQYF", "CASSLTDTQYF",
                "CANYGYTF", "CANTGELFF",
                "CSANYGYTF"),
    affix_probs = matrix(1, ncol = 11, nrow = 5),
  )

## Simulate 30 samples with a mix of public/private sequences ##
samples &lt;- 30
sample_size &lt;- 30 # (seqs per sample)
base_seqs &lt;- c(
  "CASSIEGQLSTDTQYF", "CASSEEGQLSTDTQYF", "CASSSVETQYF",
  "CASSPEGQLSTDTQYF", "RASSLAGNTEAFF", "CASSHRGTDTQYF", "CASDAGVFQPQHF",
  "CASSLTSGYNEQFF", "CASSETGYNEQFF", "CASSLTGGNEQFF", "CASSYLTGYNEQFF",
  "CASSLTGNEQFF", "CASSLNGYNEQFF", "CASSFPWDGYGYTF", "CASTLARQGGELFF",
  "CASTLSRQGGELFF", "CSVELLPTGPLETSYNEQFF", "CSVELLPTGPSETSYNEQFF",
  "CVELLPTGPSETSYNEQFF", "CASLAGGRTQETQYF", "CASRLAGGRTQETQYF",
  "CASSLAGGRTETQYF", "CASSLAGGRTQETQYF", "CASSRLAGGRTQETQYF",
  "CASQYGGGNQPQHF", "CASSLGGGNQPQHF", "CASSNGGGNQPQHF", "CASSYGGGGNQPQHF",
  "CASSYGGGQPQHF", "CASSYKGGNQPQHF", "CASSYTGGGNQPQHF",
  "CAWSSQETQYF", "CASSSPETQYF", "CASSGAYEQYF", "CSVDLGKGNNEQFF")
# Relative generation probabilities
pgen &lt;- cbind(
  stats::toeplitz(0.6^(0:(sample_size - 1))),
  matrix(1, nrow = samples, ncol = length(base_seqs) - samples))
dat5 &lt;-
  simulateToyData(
    samples = samples,
    sample_size = sample_size,
    prefix_length = 1,
    prefix_chars = c("", ""),
    prefix_probs = cbind(rep(1, samples), rep(0, samples)),
    affixes = base_seqs,
    affix_probs = pgen,
    num_edits = 0
  )

## Simulate 30 samples from two groups (treatment/control) ##
samples_c &lt;- samples_t &lt;- 15 # Number of samples by control/treatment group
samples &lt;- samples_c + samples_t
sample_size &lt;- 30 # (seqs per sample)
base_seqs &lt;- # first five are associated with treatment
  c("CASSGAYEQYF", "CSVDLGKGNNEQFF", "CASSIEGQLSTDTQYF",
    "CASSEEGQLSTDTQYF", "CASSPEGQLSTDTQYF",
    "RASSLAGNTEAFF", "CASSHRGTDTQYF", "CASDAGVFQPQHF")
# Relative generation probabilities by control/treatment group
pgen_c &lt;- matrix(rep(c(rep(1, 5), rep(30, 3)), times = samples_c),
                 nrow = samples_c, byrow = TRUE)
pgen_t &lt;- matrix(rep(c(1, 1, rep(1/3, 3), rep(2, 3)), times = samples_t),
                 nrow = samples_t, byrow = TRUE)
pgen &lt;- rbind(pgen_c, pgen_t)
dat6 &lt;-
  simulateToyData(
    samples = samples,
    sample_size = sample_size,
    prefix_length = 1,
    prefix_chars = c("", ""),
    prefix_probs =
      cbind(rep(1, samples), rep(0, samples)),
    affixes = base_seqs,
    affix_probs = pgen,
    num_edits = 0
  )



</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
