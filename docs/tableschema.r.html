<!DOCTYPE html><html><head><title>Help for package tableschema.r</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tableschema.r}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Constraints'><p>Constraints class</p></a></li>
<li><a href='#constraints.checkEnum'><p>Check Enum</p></a></li>
<li><a href='#constraints.checkMaximum'><p>Check if maximum constraint is met</p></a></li>
<li><a href='#constraints.checkMaxLength'><p>Check if maximum character length constraint is met</p></a></li>
<li><a href='#constraints.checkMinimum'><p>Check if minimum constraint is met</p></a></li>
<li><a href='#constraints.checkMinLength'><p>Check if minimum character length constraint is met</p></a></li>
<li><a href='#constraints.checkPattern'><p>Pattern matching</p></a></li>
<li><a href='#constraints.checkRequired'><p>Check if a field is required</p></a></li>
<li><a href='#constraints.checkUnique'><p>Check if a field is unique</p></a></li>
<li><a href='#DEFAULT_DECIMAL_CHAR'><p>default decimal char</p></a></li>
<li><a href='#DEFAULT_GROUP_CHAR'><p>default group char</p></a></li>
<li><a href='#durations'><p>Durations</p></a></li>
<li><a href='#FALSE_VALUES'><p>default false values</p></a></li>
<li><a href='#Field'><p>Field class</p></a></li>
<li><a href='#helpers.expandFieldDescriptor'><p>Expand Field Descriptor</p></a></li>
<li><a href='#helpers.expandSchemaDescriptor'><p>Expand Schema Descriptor</p></a></li>
<li><a href='#helpers.from.json.to.list'><p>Convert json to list</p></a></li>
<li><a href='#helpers.from.list.to.json'><p>Convert list to json</p></a></li>
<li><a href='#helpers.retrieveDescriptor'><p>Retrieve Descriptor</p></a></li>
<li><a href='#infer'><p>Infer source schema</p></a></li>
<li><a href='#is_empty'><p>Is empty</p></a></li>
<li><a href='#is_integer'><p>Is integer</p></a></li>
<li><a href='#is_object'><p>Is object</p></a></li>
<li><a href='#is.binary'><p>Is binary</p></a></li>
<li><a href='#is.email'><p>Is email</p></a></li>
<li><a href='#is.uri'><p>Is uri</p></a></li>
<li><a href='#is.uuid'><p>Is uuid</p></a></li>
<li><a href='#is.valid'><p>Is valid</p></a></li>
<li><a href='#Profile'><p>Profile class</p></a></li>
<li><a href='#Profile.load'><p>Instantiate <code>Profile</code> class</p></a></li>
<li><a href='#Readable'><p>Readable class</p></a></li>
<li><a href='#ReadableArray'><p>ReadableArray class</p></a></li>
<li><a href='#ReadableConnection'><p>ReadableConnection class</p></a></li>
<li><a href='#Schema'><p>Schema class</p></a></li>
<li><a href='#Schema.load'><p>Instantiate <code>Schema</code> class</p></a></li>
<li><a href='#Table'><p>Table Class</p></a></li>
<li><a href='#Table.load'><p>Instantiate <code>Table</code> class</p></a></li>
<li><a href='#tableschema.r-package'><p>Table Schema Package</p></a></li>
<li><a href='#TableSchemaError'><p>TableSchemaError class</p></a></li>
<li><a href='#TRUE_VALUES'><p>default true values</p></a></li>
<li><a href='#Types'><p>Types class</p></a></li>
<li><a href='#types.castAny'><p>Cast any value</p></a></li>
<li><a href='#types.castArray'><p>Cast array</p></a></li>
<li><a href='#types.castBoolean'><p>Cast boolean</p></a></li>
<li><a href='#types.castDate'><p>Cast date</p></a></li>
<li><a href='#types.castDatetime'><p>Cast datetime</p></a></li>
<li><a href='#types.castDuration'><p>Cast duration of time</p></a></li>
<li><a href='#types.castGeojson'><p>Cast JSON object according to GeoJSON or TopoJSON spec</p></a></li>
<li><a href='#types.castGeopoint'><p>Cast geographic point</p></a></li>
<li><a href='#types.castInteger'><p>Cast integer</p></a></li>
<li><a href='#types.castList'><p>Cast list</p></a></li>
<li><a href='#types.castNumber'><p>Cast numbers of any kind including decimals</p></a></li>
<li><a href='#types.castObject'><p>Cast object</p></a></li>
<li><a href='#types.castString'><p>Cast string</p></a></li>
<li><a href='#types.castTime'><p>Cast time without a date</p></a></li>
<li><a href='#types.castYear'><p>Cast year</p></a></li>
<li><a href='#types.castYearmonth'><p>Cast a specific month in a specific year</p></a></li>
<li><a href='#validate'><p>validate descriptor</p></a></li>
<li><a href='#write_json'><p>Save json file</p></a></li>
<li><a href='#Writeable'><p>Writeable class</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Table Schema 'Frictionless Data'</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-09-29</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kleanthis Koupidis &lt;koupidis.okfgr@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Allows to work with 'Table Schema' (<a href="https://specs.frictionlessdata.io/table-schema/">https://specs.frictionlessdata.io/table-schema/</a>). 'Table Schema' is well suited for use cases around handling and validating tabular data in text formats such as 'csv', but its utility extends well beyond this core usage, towards a range of applications where data benefits from a portable schema format. The 'tableschema.r' package can load and validate any table schema descriptor, allow the creation and modification of descriptors, expose methods for reading and streaming data that conforms to a 'Table Schema' via the 'Tabular Data Resource' abstraction.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/frictionlessdata/tableschema-r">https://github.com/frictionlessdata/tableschema-r</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/frictionlessdata/tableschema-r/issues">https://github.com/frictionlessdata/tableschema-r/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>config, future, httr, jsonlite, jsonvalidate, lubridate,
purrr, R6, RCurl, rlist, stringr, urltools</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, foreach, testthat</td>
</tr>
<tr>
<td>Collate:</td>
<td>'constraints.checkUnique.R' 'constraints.checkRequired.R'
'constraints.checkPattern.R' 'constraints.checkMinLength.R'
'constraints.checkMinimum.R' 'constraints.checkMaxLength.R'
'constraints.checkMaximum.R' 'constraints.checkEnum.R'
'constraints.R' 'types.castArray.R' 'types.castYearmonth.R'
'types.castYear.R' 'types.castTime.R' 'types.castString.R'
'types.castObject.R' 'types.castNumber.R' 'types.castList.R'
'types.castInteger.R' 'types.castGeopoint.R'
'types.castGeojson.R' 'types.castDuration.R'
'types.castDatetime.R' 'types.castDate.R' 'types.castBoolean.R'
'types.castAny.R' 'types.R' 'field.R' 'helpers.R' 'infer.R'
'is.valid.R' 'tableschemaerror.R' 'profile.R' 'readable.R'
'readable.array.R' 'readable.connection.R' 'schema.R' 'table.R'
'tableschema.r.R' 'validate.R' 'writable.R'</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-09-29 18:30:37 UTC; akis_</td>
</tr>
<tr>
<td>Author:</td>
<td>Kleanthis Koupidis [aut, cre],
  Lazaros Ioannidis [aut],
  Charalampos Bratsas [aut],
  Open Knowledge International [cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-09-29 20:00:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='Constraints'>Constraints class</h2><span id='topic+Constraints'></span>

<h3>Description</h3>

<p>R6 class with constraints.
</p>
<p>The constraints property on Table Schema Fields can be used by consumers to list constraints for 
validating field values. For example, validating the data in a Tabular Data Resource against 
its Table Schema; or as a means to validate data being collected or updated via a data entry interface.
</p>
<p>All constraints <code>MUST</code> be tested against the logical representation of data, and the physical 
representation of constraint values <code>MAY</code> be primitive types as possible in JSON, 
or represented as strings that are castable with the type and format rules of the field.
</p>


<h3>Format</h3>

<p><code><a href="R6.html#topic+R6Class">R6Class</a></code> object.
</p>


<h3>Value</h3>

<p>Object of <code><a href="R6.html#topic+R6Class">R6Class</a></code> .
</p>


<h3>Fields</h3>


<dl>
<dt><code>constraints</code></dt><dd><p>see Section See Also</p>
</dd>
</dl>


<h3>See Also</h3>

<p><a href="https://specs.frictionlessdata.io//table-schema/#constraints">Constraints specifications</a>,
<code><a href="#topic+constraints.checkEnum">constraints.checkEnum</a></code>, 
<code><a href="#topic+constraints.checkMaximum">constraints.checkMaximum</a></code>,
<code><a href="#topic+constraints.checkMaxLength">constraints.checkMaxLength</a></code>,
<code><a href="#topic+constraints.checkMinimum">constraints.checkMinimum</a></code>,
<code><a href="#topic+constraints.checkMinLength">constraints.checkMinLength</a></code>,
<code><a href="#topic+constraints.checkPattern">constraints.checkPattern</a></code>,
<code><a href="#topic+constraints.checkRequired">constraints.checkRequired</a></code>,
<code><a href="#topic+constraints.checkUnique">constraints.checkUnique</a></code>
</p>

<hr>
<h2 id='constraints.checkEnum'>Check Enum</h2><span id='topic+constraints.checkEnum'></span>

<h3>Description</h3>

<p>Check if the value is exactly match a constraint.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constraints.checkEnum(constraint, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="constraints.checkEnum_+3A_constraint">constraint</code></td>
<td>
<p>numeric list,matrix or vector with the constraint values</p>
</td></tr>
<tr><td><code id="constraints.checkEnum_+3A_value">value</code></td>
<td>
<p>numeric value to meet the constraint</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if value meets the constraint
</p>


<h3>See Also</h3>

<p><a href="https://specs.frictionlessdata.io//table-schema/#constraints">Constraints specifications</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
constraints.checkEnum(constraint = list(1, 2), value = 1)

constraints.checkEnum(constraint = list(1, 2), value = 3)
</code></pre>

<hr>
<h2 id='constraints.checkMaximum'>Check if maximum constraint is met</h2><span id='topic+constraints.checkMaximum'></span>

<h3>Description</h3>

<p>Specifies a maximum value for a field. This is different to <code>maxLength</code> which checks the number of items in the value. 
A maximum value constraint checks whether a field value is equal to or less than the specified value. 
The range checking depends on the type of the field. E.g. an integer field may have a maximum value of 100.
If a maximum value constraint is specified then the field descriptor <code>MUST</code> contain a type key.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constraints.checkMaximum(constraint, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="constraints.checkMaximum_+3A_constraint">constraint</code></td>
<td>
<p>numeric constraint value</p>
</td></tr>
<tr><td><code id="constraints.checkMaximum_+3A_value">value</code></td>
<td>
<p>numeric value to meet the constraint</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if value is equal to or less than the constraint
</p>


<h3>See Also</h3>

<p><a href="https://specs.frictionlessdata.io//table-schema/#constraints">Constraints specifications</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
constraints.checkMaximum(constraint = list(2), value = 1)

constraints.checkMaximum(constraint = 2, value = 3)

</code></pre>

<hr>
<h2 id='constraints.checkMaxLength'>Check if maximum character length constraint is met</h2><span id='topic+constraints.checkMaxLength'></span>

<h3>Description</h3>

<p>Specify the maximum length of a character
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constraints.checkMaxLength(constraint, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="constraints.checkMaxLength_+3A_constraint">constraint</code></td>
<td>
<p>numeric constraint, maximum character length</p>
</td></tr>
<tr><td><code id="constraints.checkMaxLength_+3A_value">value</code></td>
<td>
<p>character to meet the constraint</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if character length is equal to or less than the constraint
</p>


<h3>See Also</h3>

<p><a href="https://specs.frictionlessdata.io//table-schema/#constraints">Constraints specifications</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
constraints.checkMaxLength(constraint = list(2), value = "hi")

constraints.checkMaxLength(constraint = 2, value = "hello")
</code></pre>

<hr>
<h2 id='constraints.checkMinimum'>Check if minimum constraint is met</h2><span id='topic+constraints.checkMinimum'></span>

<h3>Description</h3>

<p>Specifies a minimum value for a field. This is different to <code>minLength</code> which checks the number of items in the value. 
A minimum value constraint checks whether a field value is greater than or equal to the specified value. 
The range checking depends on the type of the field. E.g. an integer field may have a minimum value of 100.
If a minimum value constraint is specified then the field descriptor <code>MUST</code> contain a type key.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constraints.checkMinimum(constraint, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="constraints.checkMinimum_+3A_constraint">constraint</code></td>
<td>
<p>numeric constraint value</p>
</td></tr>
<tr><td><code id="constraints.checkMinimum_+3A_value">value</code></td>
<td>
<p>numeric value to meet the constraint</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if value is equal to or greater than the constraint
</p>


<h3>See Also</h3>

<p><a href="https://specs.frictionlessdata.io//table-schema/#constraints">Constraints specifications</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
constraints.checkMinimum(constraint = list(2), value = 1)

constraints.checkMinimum(constraint = 2, value = 3)
</code></pre>

<hr>
<h2 id='constraints.checkMinLength'>Check if minimum character length constraint is met</h2><span id='topic+constraints.checkMinLength'></span>

<h3>Description</h3>

<p>Specify the minimum length of a character
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constraints.checkMinLength(constraint, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="constraints.checkMinLength_+3A_constraint">constraint</code></td>
<td>
<p>numeric constraint, minimum character length</p>
</td></tr>
<tr><td><code id="constraints.checkMinLength_+3A_value">value</code></td>
<td>
<p>character to meet the constraint</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if character length is equal to or greater than the constraint
</p>


<h3>See Also</h3>

<p><a href="https://specs.frictionlessdata.io//table-schema/#constraints">Constraints specifications</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
constraints.checkMinLength(constraint = list(3), value = "hi")

constraints.checkMinLength(constraint = 2, value = "hello")
</code></pre>

<hr>
<h2 id='constraints.checkPattern'>Pattern matching</h2><span id='topic+constraints.checkPattern'></span>

<h3>Description</h3>

<p>Search for pattern matches (value) within a character vector (constraint).
A regular expression is used to test field values. 
If the regular expression matches then the value is valid. 
The values of this field <code>MUST</code> conform to the standard 
<a href="http://www.w3.org/TR/xmlschema-2/#regexs">XML Schema regular expression syntax</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constraints.checkPattern(constraint, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="constraints.checkPattern_+3A_constraint">constraint</code></td>
<td>
<p>character vector where matches are sought</p>
</td></tr>
<tr><td><code id="constraints.checkPattern_+3A_value">value</code></td>
<td>
<p>character string to be matched</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if the pattern constraint is met
</p>


<h3>See Also</h3>

<p><a href="https://specs.frictionlessdata.io//table-schema/#constraints">Constraints specifications</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
constraints.checkPattern(constraint = '^test$', value = 'test')

constraints.checkPattern(constraint = '^test$', value = 'TEST')
</code></pre>

<hr>
<h2 id='constraints.checkRequired'>Check if a field is required</h2><span id='topic+constraints.checkRequired'></span>

<h3>Description</h3>

<p>Indicates whether this field is allowed to be <code>NULL</code>. 
If required is <code>TRUE</code>, then <code>NULL</code> is disallowed.
See the section on <a href="https://specs.frictionlessdata.io//table-schema/#missing-values">missingValues</a> for how, 
in the physical representation of the data, strings can represent <code>NULL</code> values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constraints.checkRequired(constraint, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="constraints.checkRequired_+3A_constraint">constraint</code></td>
<td>
<p>set TRUE to check required values</p>
</td></tr>
<tr><td><code id="constraints.checkRequired_+3A_value">value</code></td>
<td>
<p>value to check</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if field is required
</p>


<h3>See Also</h3>

<p><a href="https://specs.frictionlessdata.io//table-schema/#constraints">Constraints specifications</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
constraints.checkRequired(constraint = FALSE, value = 1)

constraints.checkRequired(constraint = TRUE, value = 0)

constraints.checkRequired(constraint = TRUE, value = NULL)

constraints.checkRequired(constraint = TRUE, value = "undefined")

</code></pre>

<hr>
<h2 id='constraints.checkUnique'>Check if a field is unique</h2><span id='topic+constraints.checkUnique'></span>

<h3>Description</h3>

<p>If <code>TRUE</code>, then all values for that field <code>MUST</code> be unique within the data file in which it is found.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constraints.checkUnique(constraint, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="constraints.checkUnique_+3A_constraint">constraint</code></td>
<td>
<p>set TRUE to check unique values</p>
</td></tr>
<tr><td><code id="constraints.checkUnique_+3A_value">value</code></td>
<td>
<p>value to check</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if field is unique
</p>


<h3>See Also</h3>

<p><a href="https://specs.frictionlessdata.io//table-schema/#constraints">Constraints specifications</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
constraints.checkUnique(constraint = FALSE, value = "any")

constraints.checkUnique(constraint = TRUE, value = "any")

</code></pre>

<hr>
<h2 id='DEFAULT_DECIMAL_CHAR'>default decimal char</h2><span id='topic+DEFAULT_DECIMAL_CHAR'></span>

<h3>Description</h3>

<p>default decimal char
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DEFAULT_DECIMAL_CHAR
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 1.
</p>

<hr>
<h2 id='DEFAULT_GROUP_CHAR'>default group char</h2><span id='topic+DEFAULT_GROUP_CHAR'></span>

<h3>Description</h3>

<p>default group char
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DEFAULT_GROUP_CHAR
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 1.
</p>

<hr>
<h2 id='durations'>Durations</h2><span id='topic+durations'></span>

<h3>Description</h3>

<p>Help function to use with <code><a href="#topic+types.castDuration">types.castDuration</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>durations(years = 0, months = 0, days = 0, hours = 0, minutes = 0, seconds = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="durations_+3A_years">years</code></td>
<td>
<p>years</p>
</td></tr>
<tr><td><code id="durations_+3A_months">months</code></td>
<td>
<p>months</p>
</td></tr>
<tr><td><code id="durations_+3A_days">days</code></td>
<td>
<p>days</p>
</td></tr>
<tr><td><code id="durations_+3A_hours">hours</code></td>
<td>
<p>hours</p>
</td></tr>
<tr><td><code id="durations_+3A_minutes">minutes</code></td>
<td>
<p>minutes</p>
</td></tr>
<tr><td><code id="durations_+3A_seconds">seconds</code></td>
<td>
<p>seconds</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+types.castDuration">types.castDuration</a></code>
</p>

<hr>
<h2 id='FALSE_VALUES'>default false values</h2><span id='topic+FALSE_VALUES'></span>

<h3>Description</h3>

<p>default false values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FALSE_VALUES
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 4.
</p>

<hr>
<h2 id='Field'>Field class</h2><span id='topic+Field'></span>

<h3>Description</h3>

<p>Class represents field in the schema.
</p>
<p>Data values can be cast to native R types. Casting a value will check 
the value is of the expected type, is in the correct format, 
and complies with any constraints imposed by a schema.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># Field$new(descriptor, missingValues = list(""))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Field_+3A_descriptor">descriptor</code></td>
<td>
<p>Schema field descriptor</p>
</td></tr>
<tr><td><code id="Field_+3A_missingvalues">missingValues</code></td>
<td>
<p>A list with vector strings representing missing values</p>
</td></tr>
<tr><td><code id="Field_+3A_base_path">base_path</code></td>
<td>
<p>see description</p>
</td></tr>
<tr><td><code id="Field_+3A_strict">strict</code></td>
<td>
<p>see description</p>
</td></tr>
<tr><td><code id="Field_+3A_value">value</code></td>
<td>
<p>see description</p>
</td></tr>
<tr><td><code id="Field_+3A_constraints">constraints</code></td>
<td>
<p>see description</p>
</td></tr>
<tr><td><code id="Field_+3A_...">...</code></td>
<td>
<p>see description</p>
</td></tr>
</table>


<h3>Format</h3>

<p><code><a href="R6.html#topic+R6Class">R6Class</a></code> object.
</p>


<h3>Details</h3>

<p>A field descriptor <code>MUST</code> be a JSON object that describes a single field. 
The descriptor provides additional human-readable documentation for a field, 
as well as additional information that may be used to validate the field or 
create a user interface for data entry.
</p>
<p>The field descriptor <code>object</code> <code>MAY</code> contain any number of other properties. 
Some specific properties are defined below. Of these, only the <code>name</code> property is <code>REQUIRED</code>.
</p>

<dl>
<dt><code>name</code></dt><dd>
<p>The field descriptor <code>MUST</code> contain a <code>name</code> property. 
This property <code>SHOULD</code> correspond to the name of field/column in the data file (if it has a name). 
As such it <code>SHOULD</code> be unique (though it is possible, but very bad practice, for the data file to 
have multiple columns with the same name). <code>name</code> <code>SHOULD NOT</code> be considered case sensitive in 
determining uniqueness. However, since it should correspond to the name of the field in the data file 
it may be important to preserve case.</p>
</dd>
<dt><code>title</code></dt><dd>
<p>A human readable label or title for the field.</p>
</dd>
<dt><code>description</code></dt><dd>
<p>A description for this field e.g. &quot;The recipient of the funds&quot;.</p>
</dd>
</dl>



<h3>Value</h3>

<p>Object of <code><a href="R6.html#topic+R6Class">R6Class</a></code> .
</p>


<h3>Methods</h3>


<dl>
<dt><code>Field$new(descriptor, missingValues = list(""))</code></dt><dd>
<p>Constructor to instantiate <code>Field</code> class.</p>
</dd>
</dl>

<ul>
<li><p><code>descriptor </code>Schema field descriptor.  
</p>
</li>
<li><p><code>missingValues </code>A list with vector strings representing missing values.
</p>
</li>
<li><p><code>TableSchemaError </code>Raises any error occured in the process.
</p>
</li>
<li><p><code>Field </code>Returns <code>Field</code> class instance.
</p>
</li></ul>

<dl>
<dt><code>cast_value(value, constraints=TRUE)</code></dt><dd>
<p>Cast given value according to the field type and format.</p>
</dd>
</dl>

<ul>
<li><p><code>value </code>Value to cast against field  
</p>
</li>
<li><p><code>constraints  </code> Gets constraints configuration: 
it could be set to true to disable constraint checks, or 
it could be a List of constraints to check
</p>
</li>
<li><p><code>errors$TableSchemaError </code>Raises any error occured in the process
</p>
</li>
<li><p><code>any </code>Returns cast value
</p>
</li></ul>

<dl>
<dt><code>testValue(value, constraints=TRUE)</code></dt><dd>
<p>Test if value is compliant to the field.</p>
</dd>
</dl>

<ul>
<li><p><code>value </code>Value to cast against field  
</p>
</li>
<li><p><code>constraints  </code>Constraints configuration
</p>
</li>
<li><p><code>Boolean </code>Returns if value is compliant to the field
</p>
</li></ul>




<h3>Properties</h3>


<dl>
<dt><code>name</code></dt><dd><p>Returns field name</p>
</dd>
<dt><code>type</code></dt><dd><p>Returns field type</p>
</dd>
<dt><code>format</code></dt><dd><p>Returns field format</p>
</dd>
<dt><code>required</code></dt><dd><p>Returns <code>TRUE</code> if field is required</p>
</dd>
<dt><code>constraints</code></dt><dd><p>Returns list with field constraints</p>
</dd>
<dt><code>descriptor</code></dt><dd><p>Returns field descriptor</p>
</dd>
</dl>



<h3>Language</h3>

<p>The key words <code>MUST</code>, <code>MUST NOT</code>, <code>REQUIRED</code>, <code>SHALL</code>, <code>SHALL NOT</code>, 
<code>SHOULD</code>, <code>SHOULD NOT</code>, <code>RECOMMENDED</code>, <code>MAY</code>, and <code>OPTIONAL</code> 
in this package documents are to be interpreted as described in <a href="https://www.ietf.org/rfc/rfc2119.txt">RFC 2119</a>.
</p>


<h3>See Also</h3>

<p><a href="https://specs.frictionlessdata.io//table-schema/#field-descriptors">Field Descriptors Specifications</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DESCRIPTOR = list(name = "height", type = "number")

field &lt;- Field$new(descriptor = DESCRIPTOR)

# get correct instance
field$name
field$format
field$type

# return true on test
field$testValue(1)

# cast value
field$cast_value(1)

# expand descriptor by defaults
field &lt;- Field$new(descriptor = list(name = "name"))

field$descriptor


# parse descriptor with "enum" constraint
field &lt;- Field$new(descriptor = list(name = "status", type = "string", 
                   constraints = list(enum = list('active', 'inactive'))))

field$testValue('active')
field$testValue('inactive')
field$testValue('activia')
field$cast_value('active')


# parse descriptor with "minimum" constraint'
field &lt;- Field$new(descriptor = list(name = "length", type = "integer", 
                   constraints = list(minimum = 100)))

field$testValue(200)
field$testValue(50)


# parse descriptor with "maximum" constraint'
field &lt;- Field$new(descriptor = list(name = "length", type = "integer", 
                   constraints = list(maximum = 100)))

field$testValue(50)
field$testValue(200)

</code></pre>

<hr>
<h2 id='helpers.expandFieldDescriptor'>Expand Field Descriptor</h2><span id='topic+helpers.expandFieldDescriptor'></span>

<h3>Description</h3>

<p>Helper function to expand field descriptor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>helpers.expandFieldDescriptor(descriptor)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="helpers.expandFieldDescriptor_+3A_descriptor">descriptor</code></td>
<td>
<p>descriptor</p>
</td></tr>
</table>

<hr>
<h2 id='helpers.expandSchemaDescriptor'>Expand Schema Descriptor</h2><span id='topic+helpers.expandSchemaDescriptor'></span>

<h3>Description</h3>

<p>Helper function to expand schema descriptor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>helpers.expandSchemaDescriptor(descriptor)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="helpers.expandSchemaDescriptor_+3A_descriptor">descriptor</code></td>
<td>
<p>descriptor</p>
</td></tr>
</table>

<hr>
<h2 id='helpers.from.json.to.list'>Convert json to list</h2><span id='topic+helpers.from.json.to.list'></span>

<h3>Description</h3>

<p>Convert json to list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>helpers.from.json.to.list(lst)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="helpers.from.json.to.list_+3A_lst">lst</code></td>
<td>
<p>list</p>
</td></tr>
</table>

<hr>
<h2 id='helpers.from.list.to.json'>Convert list to json</h2><span id='topic+helpers.from.list.to.json'></span>

<h3>Description</h3>

<p>Convert list to json
</p>


<h3>Usage</h3>

<pre><code class='language-R'>helpers.from.list.to.json(json)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="helpers.from.list.to.json_+3A_json">json</code></td>
<td>
<p>json string</p>
</td></tr>
</table>

<hr>
<h2 id='helpers.retrieveDescriptor'>Retrieve Descriptor</h2><span id='topic+helpers.retrieveDescriptor'></span>

<h3>Description</h3>

<p>Helper function to retrieve descriptor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>helpers.retrieveDescriptor(descriptor)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="helpers.retrieveDescriptor_+3A_descriptor">descriptor</code></td>
<td>
<p>descriptor</p>
</td></tr>
</table>

<hr>
<h2 id='infer'>Infer source schema</h2><span id='topic+infer'></span>

<h3>Description</h3>

<p>Given data source and headers infer will return a Table Schema based on the data values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>infer(source, options = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="infer_+3A_source">source</code></td>
<td>
<p>data source, one of:
</p>

<ul>
<li><p> string with the local CSV file (path)
</p>
</li>
<li><p> string with the remote CSV file (url)
</p>
</li>
<li><p> list of lists representing the rows
</p>
</li>
<li><p> readable stream with CSV file contents
</p>
</li>
<li><p> function returning readable stream with CSV file contents
</p>
</li></ul>
</td></tr>
<tr><td><code id="infer_+3A_options">options</code></td>
<td>
<p>any <code><a href="#topic+Table.load">Table.load</a></code> options</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Schema descriptor
</p>


<h3>Examples</h3>

<pre><code class='language-R'># list of lists data source
source = list(
             list("id"= 1,
                  "age"= 39,
                  "name"= "Paul"),
             list("id"= 2,
                  "age"= 23,
                  "name"= "Jimmy"),
             list("id"= 3,
                  "age"= 36,
                  "name"= "Jane"),
             list("id"= 4,
                  "age"= 28,
                  "name"= "Judy"))

infer(source, options=list(headers=list("id","age","name")))$fields

</code></pre>

<hr>
<h2 id='is_empty'>Is empty</h2><span id='topic+is_empty'></span>

<h3>Description</h3>

<p>Is empty list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_empty(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_empty_+3A_x">x</code></td>
<td>
<p>list object</p>
</td></tr>
</table>

<hr>
<h2 id='is_integer'>Is integer</h2><span id='topic+is_integer'></span>

<h3>Description</h3>

<p>Is integer
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_integer(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_integer_+3A_x">x</code></td>
<td>
<p>number</p>
</td></tr>
</table>

<hr>
<h2 id='is_object'>Is object</h2><span id='topic+is_object'></span>

<h3>Description</h3>

<p>Is object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_object(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_object_+3A_x">x</code></td>
<td>
<p>list, array, json string</p>
</td></tr>
</table>

<hr>
<h2 id='is.binary'>Is binary</h2><span id='topic+is.binary'></span>

<h3>Description</h3>

<p>Is binary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.binary(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.binary_+3A_x">x</code></td>
<td>
<p>input value to check</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if binary
</p>

<hr>
<h2 id='is.email'>Is email</h2><span id='topic+is.email'></span>

<h3>Description</h3>

<p>Is email
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.email(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.email_+3A_x">x</code></td>
<td>
<p>email string</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if x is email
</p>

<hr>
<h2 id='is.uri'>Is uri</h2><span id='topic+is.uri'></span>

<h3>Description</h3>

<p>Is uri
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.uri(uri)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.uri_+3A_uri">uri</code></td>
<td>
<p>uri input</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if uri string
</p>

<hr>
<h2 id='is.uuid'>Is uuid</h2><span id='topic+is.uuid'></span>

<h3>Description</h3>

<p>Is uuid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.uuid(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.uuid_+3A_x">x</code></td>
<td>
<p>character</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if uuid
</p>

<hr>
<h2 id='is.valid'>Is valid</h2><span id='topic+is.valid'></span>

<h3>Description</h3>

<p>Validate a descriptor over a schema
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.valid(descriptor, schema = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.valid_+3A_descriptor">descriptor</code></td>
<td>
<p>descriptor, one of:
</p>

<ul>
<li><p> string with the local CSV file (path)
</p>
</li>
<li><p> string with the remote CSV file (url)
</p>
</li>
<li><p> list object
</p>
</li></ul>
</td></tr>
<tr><td><code id="is.valid_+3A_schema">schema</code></td>
<td>
<p>Contents of the json schema, or a filename containing a schema</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if valid
</p>

<hr>
<h2 id='Profile'>Profile class</h2><span id='topic+Profile'></span>

<h3>Description</h3>

<p>Class to represent JSON Schema profile from <a href="https://specs.frictionlessdata.io/schemas/registry.json">Profiles Registry</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># Profile.load(profile)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Profile_+3A_profile">profile</code></td>
<td>
<p>string profile name in registry or URL to JSON Schema</p>
</td></tr>
</table>


<h3>Format</h3>

<p><code><a href="R6.html#topic+R6Class">R6Class</a></code> object.
</p>


<h3>Value</h3>

<p>Object of <code><a href="R6.html#topic+R6Class">R6Class</a></code> .
</p>


<h3>Methods</h3>


<dl>
<dt><code>Profile$new(descriptor = descriptor)</code></dt><dd>
<p>Use <code><a href="#topic+Profile.load">Profile.load</a></code> to instantiate <code>Profile</code> class.</p>
</dd>
<dt><code>validate(descriptor)</code></dt><dd>
<p>Validate a tabular data package descriptor against the <code>Profile</code>.</p>
</dd>
</dl>

<ul>
<li><p><code>descriptor </code>Retrieved and dereferenced tabular data package descriptor.  
</p>
</li>
<li><p><code>(Object) </code>Returns <code>TRUE</code> if descriptor is valid or <code>FALSE</code> with error message.
</p>
</li></ul>




<h3>Properties</h3>


<dl>
<dt><code>name</code></dt><dd><p>Returns profile name if available.</p>
</dd>
<dt><code>jsonschema</code></dt><dd><p>Returns profile JSON Schema contents.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><a href="https://specs.frictionlessdata.io//profiles/">Profile Specifications</a>
</p>

<hr>
<h2 id='Profile.load'>Instantiate <code>Profile</code> class</h2><span id='topic+Profile.load'></span>

<h3>Description</h3>

<p>Constuctor to instantiate <code><a href="#topic+Profile">Profile</a></code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Profile.load(profile)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Profile.load_+3A_profile">profile</code></td>
<td>
<p>string profile name in registry or URL to JSON Schema</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+Profile">Profile</a></code> class object
</p>

<hr>
<h2 id='Readable'>Readable class</h2><span id='topic+Readable'></span>

<h3>Description</h3>

<p>Readable class that allows typed access to its members
</p>


<h3>Format</h3>

<p><code><a href="R6.html#topic+R6Class">R6Class</a></code> object.
</p>


<h3>Value</h3>

<p>Object of <code><a href="R6.html#topic+R6Class">R6Class</a></code>.
</p>

<hr>
<h2 id='ReadableArray'>ReadableArray class</h2><span id='topic+ReadableArray'></span>

<h3>Description</h3>

<p>Readable Array class
</p>


<h3>Format</h3>

<p><code><a href="R6.html#topic+R6Class">R6Class</a></code> object.
</p>


<h3>Value</h3>

<p>Object of <code><a href="R6.html#topic+R6Class">R6Class</a></code> .
</p>

<hr>
<h2 id='ReadableConnection'>ReadableConnection class</h2><span id='topic+ReadableConnection'></span>

<h3>Description</h3>

<p>Readable connection class
</p>


<h3>Format</h3>

<p><code><a href="R6.html#topic+R6Class">R6Class</a></code> object.
</p>


<h3>Value</h3>

<p>Object of <code><a href="R6.html#topic+R6Class">R6Class</a></code> .
</p>

<hr>
<h2 id='Schema'>Schema class</h2><span id='topic+Schema'></span>

<h3>Description</h3>

<p>A model of a schema with helpful methods for working with the schema and supported data. 
Schema instances can be initialized with a schema source as a url to a JSON file or a JSON object. 
The schema is initially validated (see <a href="https://github.com/okgreece/tableschema-r#validate">validate</a>). 
By default validation errors will be stored in <code>$errors</code> but in a strict mode it will be instantly raised.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># Schema.load(descriptor, strict=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Schema_+3A_descriptor">descriptor</code></td>
<td>
<p>schema descriptor, a JSON string, URL or file</p>
</td></tr>
<tr><td><code id="Schema_+3A_strict">strict</code></td>
<td>
<p>flag to alter validation behaviour:
</p>

<ul>
<li><p>if <code>FALSE</code> error will not be raised and all error will be collected in <code>schema$errors</code>
</p>
</li>
<li><p>if <code>TRUE</code> any validation error will be raised immediately
</p>
</li></ul>
</td></tr>
</table>


<h3>Format</h3>

<p><code><a href="R6.html#topic+R6Class">R6Class</a></code> object.
</p>


<h3>Value</h3>

<p>Object of <code><a href="R6.html#topic+R6Class">R6Class</a></code> .
</p>


<h3>Methods</h3>


<dl>
<dt><code>Schema$new(descriptor = descriptor, strict = strict)</code></dt><dd>
<p>Use <code><a href="#topic+Schema.load">Schema.load</a></code> to instantiate <code>Schema</code> class.</p>
</dd>
<dt><code>getField(name)</code></dt><dd>
<p>Get schema field by name.</p>
</dd>
</dl>

<ul>
<li><p><code>name </code>String with schema field name.  
</p>
</li>
<li><p><code>(Field/NULL) </code>Returns <code>Field</code> instance or <code>NULL</code> if not found.
</p>
</li></ul>

<dl>
<dt><code>addField(descriptor)</code></dt><dd>
<p>Add new field to schema. The schema descriptor will be validated with newly added field descriptor.</p>
</dd>
</dl>

<ul>
<li><p><code>descriptor </code>List of field descriptor.  
</p>
</li>
<li><p><code>TableSchemaError </code>Raises any error occured in the process.
</p>
</li>
<li><p><code>(Field/NULL) </code>Returns added <code>Field</code> instance or <code>NULL</code> if not added.
</p>
</li></ul>

<dl>
<dt><code>removeField(name)</code></dt><dd>
<p>Remove field resource by name. The schema descriptor will be validated after field descriptor removal.</p>
</dd>
</dl>

<ul>
<li><p><code>name </code>String with schema field name.  
</p>
</li>
<li><p><code>TableSchemaError </code>Raises any error occured in the process.
</p>
</li>
<li><p><code>(Field/NULL) </code>Returns removed <code>Field</code> instances or <code>NULL</code> if not found.
</p>
</li></ul>
  
<dl>
<dt><code>castRow(row)</code></dt><dd>
<p>Cast row based on field types and formats.</p>
</dd>
</dl>

<ul>
<li><p><code>row </code>Data row as a list of values.  
</p>
</li>
<li><p><code>(any) </code>Returns cast data row.
</p>
</li></ul>

<dl>
<dt><code>infer(rows, headers=1)</code></dt><dd>
<p>Cast row based on field types and formats.</p>
</dd>
</dl>

<ul>
<li><p><code>rows </code>List of lists representing rows.  
</p>
</li>
<li><p><code>headers </code> data sample headers, one of:
</p>

<ul>
<li><p>row number containing headers (<code>rows</code> should contain headers rows)
</p>
</li>
<li><p>list of headers (<code>rows</code> should NOT contain headers rows)</p>
</li></ul>


</li>
<li><p><code>{Object} </code>Returns Table Schema descriptor.
</p>
</li></ul>

<dl>
<dt><code>commit(strict)</code></dt><dd>
<p>Cast row based on field types and formats.</p>
</dd>
</dl>

<ul>
<li><p><code>strict </code>Boolean, alter strict mode for further work.  
</p>
</li>
<li><p><code>TableSchemaError </code>Raises any error occured in the process.
</p>
</li>
<li><p><code>(Boolean) </code>Returns <code>TRUE</code> on success and <code>FALSE</code> if not modified.
</p>
</li></ul>

<dl>
<dt><code>save(target)</code></dt><dd>
<p>Cast row based on field types and formats.</p>
</dd>
</dl>

<ul>
<li><p><code>target </code>String, path where to save a descriptor.  
</p>
</li>
<li><p><code>TableSchemaError </code>Raises any error occured in the process.
</p>
</li>
<li><p><code>(Boolean) </code>Returns <code>TRUE</code> on success.
</p>
</li></ul>
  



<h3>Properties</h3>


<dl>
<dt><code>valid</code></dt><dd><p>Returns validation status. It always <code>TRUE</code> in strict mode.</p>
</dd>
<dt><code>errors</code></dt><dd><p>Returns validation errors. It always empty in strict mode.</p>
</dd>
<dt><code>descriptor</code></dt><dd><p>Returns list of schema descriptor.</p>
</dd>
<dt><code>primaryKey</code></dt><dd><p>Returns string list of schema primary key.</p>
</dd>
<dt><code>foreignKeys</code></dt><dd><p>Returns list of schema foreign keys.</p>
</dd>
<dt><code>fields</code></dt><dd><p>Returns list of <code>Field</code> instances.</p>
</dd>
<dt><code>fieldNames</code></dt><dd><p>Returns a list of field names.</p>
</dd>
</dl>



<h3>Language</h3>

<p>The key words <code>MUST</code>, <code>MUST NOT</code>, <code>REQUIRED</code>, <code>SHALL</code>, <code>SHALL NOT</code>, 
<code>SHOULD</code>, <code>SHOULD NOT</code>, <code>RECOMMENDED</code>, <code>MAY</code>, and <code>OPTIONAL</code> 
in this package documents are to be interpreted as described in <a href="https://www.ietf.org/rfc/rfc2119.txt">RFC 2119</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Schema.load">Schema.load</a></code>, 
<a href="https://specs.frictionlessdata.io//table-schema/">Table Schema Specifications</a>
</p>

<hr>
<h2 id='Schema.load'>Instantiate <code>Schema</code> class</h2><span id='topic+Schema.load'></span>

<h3>Description</h3>

<p>Factory method to instantiate <code>Schema</code> class. 
This method is async and it should be used with <code><a href="future.html#topic+value">value</a></code> keyword from 
<a href="https://CRAN.R-project.org/package=future">future</a> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Schema.load(descriptor, strict=FALSE, caseInsensitiveHeaders = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Schema.load_+3A_descriptor">descriptor</code></td>
<td>
<p>schema descriptor, a JSON string, URL or file</p>
</td></tr>
<tr><td><code id="Schema.load_+3A_strict">strict</code></td>
<td>
<p>flag to alter validation behaviour:
</p>

<ul>
<li><p>if <code>FALSE</code> error will not be raised and all error will be collected in <code>schema$errors</code>
</p>
</li>
<li><p>if <code>TRUE</code> any validation error will be raised immediately
</p>
</li></ul>
</td></tr>
<tr><td><code id="Schema.load_+3A_caseinsensitiveheaders">caseInsensitiveHeaders</code></td>
<td>
<p>default is set to <code>FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+Schema">Schema</a></code> class object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Schema">Schema</a></code>, <a href="https://specs.frictionlessdata.io//table-schema/">Table Schema Specifications</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SCHEMA &lt;- '{"fields": [
  {"name": "id", "type": "string", "constraints": {"required": true}},
  {"name": "height", "type": "number"},
  {"name": "age", "type": "integer"},
  {"name": "name", "type": "string", "constraints": {"required": true}},
  {"name": "occupation", "type": "string"}
  ]}'

# instantiate Schema class
def  = Schema.load(descriptor = SCHEMA)
schema = future::value(def)

# correct number of fields
length(schema$fields)

# correct field names
schema$fieldNames

# convert row
row = list('string', '10.0', '1', 'string', 'string')
castRow = schema$castRow(row)
castRow

SCHEMA_MIN &lt;- '{
"fields": [
  {"name": "id"},
  {"name": "height"}
  ]}'

# load schema
def2  = Schema.load(descriptor = SCHEMA_MIN)
schema2 = future::value(def2)
  
# set default types if not provided
schema2$fields[[1]]$type
schema2$fields[[2]]$type

# fields are not required by default
schema2$fields[[1]]$required
schema2$fields[[2]]$required


#work in strict mode
descriptor = '{"fields": [{"name": "name", "type": "string"}]}'
def3  = Schema.load(descriptor = descriptor, strict = TRUE)
schema3 = future::value(def3)
schema3$valid

# work in non-strict mode
descriptor = '{"fields": [{"name": "name", "type": "string"}]}'
def4 = Schema.load(descriptor = descriptor, strict = FALSE)
schema4 = future::value(def4)
schema4$valid

# work with primary/foreign keys as arrays
descriptor2 = '{
"fields": [{"name": "name"}],
"primaryKey": ["name"],
"foreignKeys": [{
  "fields": ["parent_id"],
  "reference": {"resource": "resource", "fields": ["id"]}
}]}'

def5 = Schema.load(descriptor2)
schema5 = future::value(def5)

schema5$primaryKey
schema5$foreignKeys


# work with primary/foreign keys as string
descriptor3 = '{
"fields": [{"name": "name"}],
"primaryKey": "name",
"foreignKeys": [{
  "fields": "parent_id",
  "reference": {"resource": "resource", "fields": "id"}
}]}'

def6 = Schema.load(descriptor3)
schema6 = future::value(def6)
schema6$primaryKey
schema6$foreignKeys

</code></pre>

<hr>
<h2 id='Table'>Table Class</h2><span id='topic+Table'></span>

<h3>Description</h3>

<p>Table class for working with data and schema.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># Table.load(source, schema = NULL, strict = FALSE, headers = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Table_+3A_source">source</code></td>
<td>
<p>data source, one of:
</p>

<ul>
<li><p> string with the path of the local CSV file
</p>
</li>
<li><p> string with the url of the remote CSV file
</p>
</li>
<li><p> list of lists representing the rows
</p>
</li>
<li><p> readable stream with CSV file contents
</p>
</li>
<li><p> function returning readable stream with CSV file contents
</p>
</li></ul>
</td></tr>
<tr><td><code id="Table_+3A_schema">schema</code></td>
<td>
<p>data schema in all forms supported by <code>Schema</code> class</p>
</td></tr>
<tr><td><code id="Table_+3A_strict">strict</code></td>
<td>
<p>strictness option <code>TRUE</code> or <code>FALSE</code>, to pass to <code>Schema</code> constructor</p>
</td></tr>
<tr><td><code id="Table_+3A_headers">headers</code></td>
<td>
<p>data source headers, one of:
</p>

<ul>
<li><p> row number containing headers (<code>source</code> should contain headers rows)
</p>
</li>
<li><p> list of headers (<code>source</code> should NOT contain headers rows)
</p>
</li></ul>
</td></tr>
<tr><td><code id="Table_+3A_...">...</code></td>
<td>
<p>options to be used by CSV parser. 
All options listed at <a href="https://csv.js.org/parse/options/">https://csv.js.org/parse/options/</a>. 
By default <code>ltrim</code> is <code>TRUE</code> according to the <a href="https://specs.frictionlessdata.io//csv-dialect/#specification">CSV Dialect spec</a>.</p>
</td></tr>
</table>


<h3>Format</h3>

<p><code><a href="R6.html#topic+R6Class">R6Class</a></code> object.
</p>


<h3>Value</h3>

<p>Object of <code><a href="R6.html#topic+R6Class">R6Class</a></code> .
</p>


<h3>Methods</h3>


<dl>
<dt><code>Table$new(source, schema, strict, headers)</code></dt><dd>
<p>Use <code><a href="#topic+Table.load">Table.load</a></code> to instantiate <code>Table</code> class.</p>
</dd>
<dt><code>iter(keyed, extended, cast=TRUE, relations=FALSE, stream=FALSE)</code></dt><dd>
<p>Iter through the table data and emits rows cast based on table schema. Data casting could be disabled.</p>
</dd>
</dl>

<ul>
<li><p><code>keyed </code>Iter keyed rows - <code>TRUE</code>/<code>FALSE</code>  
</p>
</li>
<li><p><code>extended </code>Iter extended rows - <code>TRUE</code>/<code>FALSE</code>
</p>
</li>
<li><p><code>cast </code>Disable data casting if <code>FALSE</code>
</p>
</li>
<li><p><code>relations </code>List object of foreign key references from a form of JSON <code>{resource1: [{field1: value1, field2: value2},...],...}</code>.
If provided foreign key fields will checked and resolved to its references
</p>
</li>
<li><p><code>stream </code>Return Readable Stream of table rows if <code>TRUE</code>
</p>
</li></ul>

<dl>
<dt><code>read(keyed, extended, cast=TRUE, relations=FALSE, limit)</code></dt><dd>
<p>Read the whole table and returns as array of rows. Count of rows could be limited.</p>
</dd>
</dl>

<ul>
<li><p><code>keyed </code>Flag to emit keyed rows - <code>TRUE</code>/<code>FALSE</code>  
</p>
</li>
<li><p><code>extended </code>Flag to emit extended rows - <code>TRUE</code>/<code>FALSE</code>
</p>
</li>
<li><p><code>cast </code>Disable data casting if <code>FALSE</code>
</p>
</li>
<li><p><code>relations </code>List object of foreign key references from a form of JSON <code>{resource1: [{field1: value1, field2: value2},...],...}</code>.
If provided foreign key fields will checked and resolved to its references
</p>
</li>
<li><p><code>limit </code>Integer limit of rows to return if specified
</p>
</li></ul>

<dl>
<dt><code>infer(limit=100)</code></dt><dd>
<p>Infer a schema for the table. It will infer and set <code>Table Schema</code> to <code>table$schema</code> based on table data.</p>
</dd>
</dl>

<ul>
<li><p><code>limit </code>Limit rows samle size - number
</p>
</li></ul>

<dl>
<dt><code>save(target)</code></dt><dd>
<p>Save data source to file locally in CSV format with <code>,</code> (comma) delimiter.</p>
</dd>
</dl>

<ul>
<li><p><code>target </code>String path where to save a table data
</p>
</li></ul>




<h3>Properties</h3>


<dl>
<dt><code>headers</code></dt><dd><p>Returns data source headers</p>
</dd>
<dt><code>schema</code></dt><dd><p>Returns schema class instance</p>
</dd>
</dl>



<h3>Details</h3>

<p>A table is a core concept in a tabular data world. It represents a data with a metadata (Table Schema).
Tabular data consists of a set of rows. Each row has a set of fields (columns). 
We usually expect that each row has the same set of fields and thus we can talk about the 
fields for the table as a whole. In case of tables in spreadsheets or CSV files we often interpret 
the first row as a header row, giving the names of the fields. By contrast, in other situations, 
e.g. tables in SQL databases, the field names are explicitly designated.
</p>
<p>In order to talk about the representation and processing of tabular data from text-based sources, 
it is useful to introduce the concepts of the <em>physical</em> and the <em>logical</em> representation of data.
</p>
<p>The <em>physical representation</em> of data refers to the representation of data as text on disk, 
for example, in a CSV or JSON file. This representation may have some type information 
(JSON, where the primitive types that JSON supports can be used) or not 
(CSV, where all data is represented in string form).
</p>
<p>The <em>logical representation</em> of data refers to the &quot;ideal&quot; representation of the data 
in terms of primitive types, data structures, and relations, all as defined by the specification. 
We could say that the specification is about the logical representation of data, 
as well as about ways in which to handle conversion of a physical representation to a logical one.
</p>
<p>We'll explicitly refer to either the <em>physical</em> or <em>logical</em> representation 
in places where it prevents ambiguity for those engaging with the specification, especially implementors.
</p>
<p>For example, <code>constraints</code> should be tested on the logical representation of data, 
whereas a property like <code>missingValues</code> applies to the physical representation of the data.
</p>
<p><a href="https://CRAN.R-project.org/package=jsonlite">Jsolite package</a> is internally used to convert json data to list objects. The input parameters of functions could be json strings, 
files or lists and the outputs are in list format to easily further process your data in R environment and exported as desired. 
More details about handling json you can see jsonlite documentation or vignettes <a href="https://CRAN.R-project.org/package=jsonlite">here</a>.
</p>
<p><a href="https://CRAN.R-project.org/package=future">Future package</a> is also used to load and create Table and Schema class asynchronously. 
To retrieve the actual result of the loaded Table or Schema you have to call <code>value(future)</code> to the variable you stored the loaded Table/Schema. 
More details about future package and sequential and parallel processing you can find <a href="https://CRAN.R-project.org/package=future">here</a>.
</p>
<p>Examples section of each function show how to use jsonlite and future packages with tableschema.r.
</p>


<h3>Language</h3>

<p>The key words <code>MUST</code>, <code>MUST NOT</code>, <code>REQUIRED</code>, <code>SHALL</code>, <code>SHALL NOT</code>, 
<code>SHOULD</code>, <code>SHOULD NOT</code>, <code>RECOMMENDED</code>, <code>MAY</code>, and <code>OPTIONAL</code> 
in this package documents are to be interpreted as described in <a href="https://www.ietf.org/rfc/rfc2119.txt">RFC 2119</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Table.load">Table.load</a></code>, 
<a href="https://specs.frictionlessdata.io//table-schema/">Table Schema Specifications</a>
</p>

<hr>
<h2 id='Table.load'>Instantiate <code>Table</code> class</h2><span id='topic+Table.load'></span>

<h3>Description</h3>

<p>Factory method to instantiate <code>Table</code> class. 
This method is async and it should be used with <code><a href="future.html#topic+value">value</a></code> keyword from 
<a href="https://CRAN.R-project.org/package=future">future</a> package.
If <code>references</code> argument is provided foreign keys will be checked on any reading operation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Table.load(source, schema = NULL, strict = FALSE, headers = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Table.load_+3A_source">source</code></td>
<td>
<p>data source, one of:
</p>

<ul>
<li><p> string with the path of the local CSV file
</p>
</li>
<li><p> string with the url of the remote CSV file
</p>
</li>
<li><p> list of lists representing the rows
</p>
</li>
<li><p> readable stream with CSV file contents
</p>
</li>
<li><p> function returning readable stream with CSV file contents
</p>
</li></ul>
</td></tr>
<tr><td><code id="Table.load_+3A_schema">schema</code></td>
<td>
<p>data schema in all forms supported by <code>Schema</code> class</p>
</td></tr>
<tr><td><code id="Table.load_+3A_strict">strict</code></td>
<td>
<p>strictness option <code>TRUE</code> or <code>FALSE</code>, to pass to <code>Schema</code> constructor</p>
</td></tr>
<tr><td><code id="Table.load_+3A_headers">headers</code></td>
<td>
<p>data source headers, one of:
</p>

<ul>
<li><p> row number containing headers (<code>source</code> should contain headers rows)
</p>
</li>
<li><p> list of headers (<code>source</code> should NOT contain headers rows)
</p>
</li></ul>
</td></tr>
<tr><td><code id="Table.load_+3A_...">...</code></td>
<td>
<p>options to be used by CSV parser. 
All options listed at <a href="https://csv.js.org/parse/options/">https://csv.js.org/parse/options/</a>. 
By default <code>ltrim</code> is <code>TRUE</code> according to the <a href="https://specs.frictionlessdata.io//csv-dialect/#specification">CSV Dialect spec</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><a href="https://CRAN.R-project.org/package=jsonlite">Jsolite package</a> is internally used to convert json data to list objects. The input parameters of functions could be json strings, 
files or lists and the outputs are in list format to easily further process your data in R environment and exported as desired. 
Examples section show how to use jsonlite package and tableschema.r together. More details about handling json you can see jsonlite documentation or vignettes <a href="https://CRAN.R-project.org/package=jsonlite">here</a>.
</p>
<p><a href="https://CRAN.R-project.org/package=future">Future package</a> is also used to load and create Table and Schema classes asynchronously. 
To retrieve the actual result of the loaded Table or Schema you have to use <code><a href="future.html#topic+value">value</a></code> function to the variable you stored the loaded Table/Schema. 
More details about future package and sequential and parallel processing you can find <a href="https://CRAN.R-project.org/package=future">here</a>.
</p>
<p>Term array refers to json arrays which if converted in R will be <code><a href="base.html#topic+list">list objects</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Table">Table</a></code>, <a href="https://specs.frictionlessdata.io//table-schema/">Table Schema Specifications</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# define source
SOURCE = '[
["id", "height", "age", "name", "occupation"],
[1, "10.0", 1, "string1", "2012-06-15 00:00:00"],
[2, "10.1", 2, "string2", "2013-06-15 01:00:00"],
[3, "10.2", 3, "string3", "2014-06-15 02:00:00"],
[4, "10.3", 4, "string4", "2015-06-15 03:00:00"],
[5, "10.4", 5, "string5", "2016-06-15 04:00:00"]
]'

# define schema
SCHEMA = '{
  "fields": [
    {"name": "id", "type": "integer", "constraints": {"required": true}},
    {"name": "height", "type": "number"},
    {"name": "age", "type": "integer"},
    {"name": "name", "type": "string", "constraints": {"unique": true}},
    {"name": "occupation", "type": "datetime", "format": "any"}
    ],
  "primaryKey": "id"
}' 


def = Table.load(jsonlite::fromJSON(SOURCE, simplifyVector = FALSE), schema = SCHEMA)
table = future::value(def)

# work with list source
rows = table$read()

# read source data and limit rows
rows2 = table$read(limit = 1)

# read source data and return keyed rows
rows3 = table$read(limit = 1, keyed = TRUE)

# read source data and return extended rows
rows4 = table$read(limit = 1, extended = TRUE)


# work with Schema instance
 def1  =  Schema.load(SCHEMA)
 schema = future::value(def1)
 def2  = Table.load(jsonlite::fromJSON(SOURCE, simplifyVector = FALSE), schema = schema)
 table2 = future::value(def2)
 rows5 = table2$read()
 

</code></pre>

<hr>
<h2 id='tableschema.r-package'>Table Schema Package</h2><span id='topic+tableschema.r-package'></span>

<h3>Description</h3>

<p>Table class for working with data and schema
</p>


<h3>Introduction</h3>

<p>Table Schema is a simple language- and implementation-agnostic way to declare a schema for tabular data. 
Table Schema is well suited for use cases around handling and validating tabular data in text formats 
such as CSV, but its utility extends well beyond this core usage, towards a range of applications 
where data benefits from a portable schema format.
</p>


<h3>Concepts</h3>

<p>#
</p>


<h3>Tabular data</h3>

<p>Tabular data consists of a set of rows. Each row has a set of fields (columns). 
We usually expect that each row has the same set of fields and thus we can talk about 
the fields for the table as a whole.
</p>
<p>In case of tables in spreadsheets or CSV files we often interpret the first row as a header row, 
giving the names of the fields. By contrast, in other situations, e.g. tables in SQL databases, 
the field names are explicitly designated.
</p>


<h3>Physical and logical representation</h3>

<p>In order to talk about the representation and processing of tabular data from text-based sources, 
it is useful to introduce the concepts of the <em>physical</em> and the <em>logical</em> representation of data.
</p>
<p>The <em>physical representation</em> of data refers to the representation of data as text on disk, 
for example, in a CSV or JSON file. This representation may have some type information 
(JSON, where the primitive types that JSON supports can be used) or not 
(CSV, where all data is represented in string form).
</p>
<p>The <em>logical representation</em> of data refers to the &quot;ideal&quot; representation of the data 
in terms of primitive types, data structures, and relations, all as defined by the specification. 
We could say that the specification is about the logical representation of data, 
as well as about ways in which to handle conversion of a physical representation to a logical one.
</p>
<p>In this document, we'll explicitly refer to either the <em>physical</em> or <em>logical</em> representation 
in places where it prevents ambiguity for those engaging with the specification, especially implementors.
</p>
<p>For example, <code>constraints</code> should be tested on the logical representation of data, 
whereas a property like <code>missingValues</code> applies to the physical representation of the data.
</p>


<h3>Descriptor</h3>

<p>A Table Schema is represented by a descriptor. The descriptor <code>MUST</code> be a JSON <code>object</code> 
(JSON is defined in <a href="https://www.ietf.org/rfc/rfc4627.txt">RFC 4627</a>).
</p>
<p>It <code>MUST</code> contain a property <code>fields</code>. <code>fields</code> <code>MUST</code> be an array/list where each entry 
in the array/list is a field descriptor (as defined below). The order of elements in <code>fields</code> array/list 
<code>MUST</code> be the order of fields in the CSV file. The number of elements in <code>fields</code> array/list 
<code>SHOULD</code> be exactly the same as the number of fields in the CSV file.
</p>
<p>The descriptor <code>MAY</code> have the additional properties set out below and <code>MAY</code> contain 
any number of other properties (not defined in this specification).
</p>


<h3>Field Descriptors</h3>

<p>See <code><a href="#topic+Field">Field</a></code> Class
</p>


<h3>Types and Formats</h3>

<p>See <code><a href="#topic+Types">Types</a></code> Class
</p>


<h3>Constraints</h3>

<p>See <code><a href="#topic+Constraints">Constraints</a></code> Class
</p>


<h3>Other Properties</h3>

<p>In additional to field descriptors, there are the following &quot;table level&quot; properties.
</p>


<h3>Missing Values</h3>

<p>Many datasets arrive with missing data values, either because a value was not collected or 
it never existed. Missing values may be indicated simply by the value being empty in other 
cases a special value may have been used e.g. -, NaN, 0, -9999 etc.
</p>
<p><code>missingValues</code> dictates which string values should be treated as null values. 
This conversion to null is done before any other attempted type-specific string conversion. 
The default value <code>list("")</code> means that empty strings will be converted to null before any other 
processing takes place. Providing the empty list means that no conversion to null will 
be done, on any value.
</p>
<p><code>missingValues</code> <code>MUST</code> be a list where each entry is a string.
</p>
<p><strong>Why strings</strong>: <code>missingValues</code> are strings rather than being the data type of the particular field. 
This allows for comparison prior to casting and for fields to have missing value which are not 
of their type, for example a <code>number</code> field to have missing values indicated by -.
</p>
<p>Examples:
</p>

<ul>
<li><p>missingValues = list(&quot;&quot;)
</p>
</li>
<li><p>missingValues = list(&quot;-&quot;)
</p>
</li>
<li><p>missingValues = list(&quot;NaN&quot;, &quot;-&quot;)
</p>
</li></ul>



<h3>Primary Key</h3>

<p>A primary key is a field or set of fields that uniquely identifies each row in the table.
</p>
<p>The <code>primaryKey</code> entry in the schema <code>object</code> is optional. If present it specifies the primary key for this table.
</p>
<p>The <code>primaryKey</code>, if present, <code>MUST</code> be:
</p>

<ul>
<li><p>Either: an array of strings with each string corresponding to one of the field <code>name</code> values in the <code>fields</code> array 
(denoting that the primary key is made up of those fields). It is acceptable to have an array with a single value 
(indicating just one field in the primary key). Strictly, order of values in the array does not matter. 
However, it is RECOMMENDED that one follow the order the fields in the <code>fields</code> has as client applications may 
utitlize the order of the primary key list (e.g. in concatenating values together).

</p>
</li>
<li><p>Or: a single string corresponding to one of the field <code>name</code> values in the <code>fields</code> array/list 
(indicating that this field is the primary key). Note that this version corresponds to the array form 
with a single value (and can be seen as simply a more convenient way of specifying a single field primary key).

</p>
</li></ul>



<h3>Foreign Keys</h3>

<p>A foreign key is a reference where values in a field (or fields) on the table ('resource' in data package terminology) 
described by this Table Schema connect to values a field (or fields) on this or a separate table (resource). 
They are directly modelled on the concept of foreign keys in SQL.
</p>
<p>The <code>foreignKeys</code> property, if present, <code>MUST</code> be a list Each entry in the array must be a <code>foreignKey</code>. 
A <code>foreignKey</code> <code>MUST</code> be a object and <code>MUST</code> have the following properties:
</p>

<ul>
<li><p><code>fields</code> - <code>fields</code> is a string or array specifying the field or fields on this resource that form the source part 
of the foreign key. The structure of the string or array is as per <code>primaryKey</code> above.
</p>
</li>
<li><p><code>reference</code> - <code>reference</code> <code>MUST</code> be a object. The object
</p>

<ul>
<li><p><code>MUST</code> have a property <code>resource</code> which is the name of the resource within the current data package 
(i.e. the data package within which this Table Schema is located). For self-referencing foreign keys, 
i.e. references between fields in this Table Schema, the value of <code>resource</code> <code>MUST</code> be <code>""</code> (i.e. the empty string).
</p>
</li>
<li><p><code>MUST</code> have a property <code>fields</code> which is a string if the outer <code>fields</code> is a string, 
else an array of the same length as the outer <code>fields</code>, describing the field (or fields) references 
on the destination resource. The structure of the string or array is as per <code>primaryKey</code> above.
</p>
</li></ul>


</li></ul>

<p><strong>Comment</strong>: Foreign Keys create links between one Table Schema and another Table Schema, 
and implicitly between the data tables described by those Table Schemas. If the foreign key is referring to 
another Table Schema how is that other Table Schema discovered? The answer is that a Table Schema will 
usually be embedded inside some larger descriptor for a dataset, in particular as the schema for a resource 
in the resources array of a hrefhttp://frictionlessdata.io/specs/data-package/Data Package. 
It is the use of Table Schema in this way that permits a meaningful use of a non-empty <code>resource</code> 
property on the foreign key.
</p>


<h3>Details</h3>

<p><a href="https://CRAN.R-project.org/package=jsonlite">Jsolite package</a> is internally used to convert json data to list objects. The input parameters of functions could be json strings, 
files or lists and the outputs are in list format to easily further process your data in R environment and exported as desired. 
More details about handling json you can see jsonlite documentation or vignettes <a href="https://CRAN.R-project.org/package=jsonlite">here</a>.
</p>
<p><a href="https://CRAN.R-project.org/package=future">Future package</a> is also used to load and create Table and Schema classes asynchronously. 
To retrieve the actual result of the loaded Table or Schema you have to use <code><a href="future.html#topic+value">value</a></code> function to the variable you stored the loaded Table/Schema. 
More details about future package and sequential and parallel processing you can find <a href="https://CRAN.R-project.org/package=future">here</a>.
</p>
<p>Examples section of each function show how to use <code>jsonlite</code> and <code>future</code> packages with <code>tableschema.r</code>. 
</p>
<p>Term array refers to json arrays which if converted in R will be <code><a href="base.html#topic+list">list objects</a></code>.
</p>


<h3>Language</h3>

<p>The key words <code>MUST</code>, <code>MUST NOT</code>, <code>REQUIRED</code>, <code>SHALL</code>, <code>SHALL NOT</code>, 
<code>SHOULD</code>, <code>SHOULD NOT</code>, <code>RECOMMENDED</code>, <code>MAY</code>, and <code>OPTIONAL</code> 
in this package documents are to be interpreted as described in <a href="https://www.ietf.org/rfc/rfc2119.txt">RFC 2119</a>.
</p>


<h3>See Also</h3>

<p><a href="https://specs.frictionlessdata.io//table-schema/">Table Schema Specifications</a>
</p>

<hr>
<h2 id='TableSchemaError'>TableSchemaError class</h2><span id='topic+TableSchemaError'></span>

<h3>Description</h3>

<p>Error class for Table Schema
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="TableSchemaError_+3A_message">message</code></td>
<td>
<p>message</p>
</td></tr>
<tr><td><code id="TableSchemaError_+3A_error">error</code></td>
<td>
<p>error</p>
</td></tr>
</table>


<h3>Format</h3>

<p><code><a href="R6.html#topic+R6Class">R6Class</a></code> object.
</p>


<h3>Value</h3>

<p>Object of <code><a href="R6.html#topic+R6Class">R6Class</a></code> .
</p>


<h3>Fields</h3>


<dl>
<dt><code>message</code></dt><dd></dd>
<dt><code>error</code></dt><dd></dd>
</dl>

<hr>
<h2 id='TRUE_VALUES'>default true values</h2><span id='topic+TRUE_VALUES'></span>

<h3>Description</h3>

<p>default true values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TRUE_VALUES
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 4.
</p>

<hr>
<h2 id='Types'>Types class</h2><span id='topic+Types'></span>

<h3>Description</h3>

<p>R6 class with Types and Formats.
</p>
<p><code>type</code> and <code>format</code> properties are used to give the type of the field (string, number etc) - 
see <a href="https://specs.frictionlessdata.io//table-schema/#types-and-formats">types and formats</a> for more details. 
If type is not provided a consumer should assume a type of &quot;string&quot;.
</p>
<p>A field's <code>type</code> property is a string indicating the type of this field.
</p>
<p>A field's <code>format</code> property is a string, indicating a format for the field type.
</p>
<p>Both <code>type</code> and format are optional: in a field descriptor, the absence of a <code>type</code> property indicates that 
the field is of the type &quot;string&quot;, and the absence of a <code>format</code> property indicates that the field's type <code>format</code> is &quot;default&quot;.
</p>
<p>Types are based on the <a href="https://datatracker.ietf.org/doc/html/draft-zyp-json-schema-03#section-5.1">type set of json-schema</a> 
with some additions and minor modifications (cf other type lists include those in 
<a href="http://www.elasticsearch.org/guide/reference/mapping/">Elasticsearch types</a>).
</p>


<h3>Format</h3>

<p><code><a href="R6.html#topic+R6Class">R6Class</a></code> object.
</p>


<h3>Value</h3>

<p>Object of <code><a href="R6.html#topic+R6Class">R6Class</a></code> .
</p>


<h3>Fields</h3>


<dl>
<dt><code>casts</code></dt><dd><p>see Section See also</p>
</dd>
</dl>


<h3>See Also</h3>

<p><a href="https://specs.frictionlessdata.io//table-schema/#types-and-formats">Types and formats specifications</a>,
<code><a href="#topic+types.castAny">types.castAny</a></code>,
<code><a href="#topic+types.castBoolean">types.castBoolean</a></code>,
<code><a href="#topic+types.castDate">types.castDate</a></code>,
<code><a href="#topic+types.castDatetime">types.castDatetime</a></code>,
<code><a href="#topic+types.castDuration">types.castDuration</a></code>,
<code><a href="#topic+types.castGeojson">types.castGeojson</a></code>,
<code><a href="#topic+types.castGeopoint">types.castGeopoint</a></code>,
<code><a href="#topic+types.castInteger">types.castInteger</a></code>,
<code><a href="#topic+types.castList">types.castList</a></code>,
<code><a href="#topic+types.castNumber">types.castNumber</a></code>,
<code><a href="#topic+types.castObject">types.castObject</a></code>,
<code><a href="#topic+types.castString">types.castString</a></code>,
<code><a href="#topic+types.castTime">types.castTime</a></code>,
<code><a href="#topic+types.castYear">types.castYear</a></code>,
<code><a href="#topic+types.castYearmonth">types.castYearmonth</a></code>,
<code><a href="#topic+types.castArray">types.castArray</a></code>
</p>

<hr>
<h2 id='types.castAny'>Cast any value</h2><span id='topic+types.castAny'></span>

<h3>Description</h3>

<p>Cast any value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>types.castAny(format, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="types.castAny_+3A_format">format</code></td>
<td>
<p>any format is accepted</p>
</td></tr>
<tr><td><code id="types.castAny_+3A_value">value</code></td>
<td>
<p>any value to cast</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Any type or format is accepted.
</p>


<h3>See Also</h3>

<p><a href="https://specs.frictionlessdata.io//table-schema/#any">Types and formats specifications</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
types.castAny(format = "default", value = 1)

types.castAny(format = "default", value = "1")

types.castAny(format = "default", value = "")

types.castAny(format = "default", value = TRUE)

</code></pre>

<hr>
<h2 id='types.castArray'>Cast array</h2><span id='topic+types.castArray'></span>

<h3>Description</h3>

<p>Cast array is used for list objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>types.castArray(format, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="types.castArray_+3A_format">format</code></td>
<td>
<p>no options (other than the default)</p>
</td></tr>
<tr><td><code id="types.castArray_+3A_value">value</code></td>
<td>
<p>lists, or valid JSON format arrays to cast</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+types.castList">types.castList</a></code>, 
<a href="https://specs.frictionlessdata.io//table-schema/#array">Types and formats specifications</a>
</p>

<hr>
<h2 id='types.castBoolean'>Cast boolean</h2><span id='topic+types.castBoolean'></span>

<h3>Description</h3>

<p>Cast boolean values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>types.castBoolean(
  format = "default",
  value,
  options = {
 }
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="types.castBoolean_+3A_format">format</code></td>
<td>
<p>no options (other than the default)</p>
</td></tr>
<tr><td><code id="types.castBoolean_+3A_value">value</code></td>
<td>
<p>boolean to cast</p>
</td></tr>
<tr><td><code id="types.castBoolean_+3A_options">options</code></td>
<td>
<p>specify additioanl true values or/and falsevalues</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the physical representations of data where boolean values are represented with strings, 
the values set in <code>trueValues</code> and <code>falseValues</code> are to be cast to their logical representation as booleans. 
<code>trueValues</code> and <code>falseValues</code> are lists which can be customised to user need. 
The default values for these are in the additional properties section below.
</p>
<p>The boolean field can be customised with these additional properties:
</p>

<ul>
<li><p>trueValues: [&quot;true&quot;, &quot;True&quot;, &quot;TRUE&quot;, &quot;1&quot;]
</p>
</li>
<li><p>falseValues: [&quot;false&quot;, &quot;False&quot;, &quot;FALSE&quot;, &quot;0&quot;]
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="https://specs.frictionlessdata.io//table-schema/#boolean">Types and formats specifications</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
types.castBoolean(format = "default", value =  TRUE)

types.castBoolean(format = "default", value = "true")

types.castBoolean(format = "default", value = "1")

types.castBoolean(format = "default", value = "0")

# set options with additional true value
types.castBoolean(format = "default", value = "yes", list(trueValues = list("yes")))

# set options with additional false value
types.castBoolean(format = "default", value = "no", list(falseValues  = list("no")))

</code></pre>

<hr>
<h2 id='types.castDate'>Cast date</h2><span id='topic+types.castDate'></span>

<h3>Description</h3>

<p>cast date without a time
</p>


<h3>Usage</h3>

<pre><code class='language-R'>types.castDate(format = "default", value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="types.castDate_+3A_format">format</code></td>
<td>
<p>available options are &quot;default&quot;, &quot;any&quot;, and &quot;&lt;pattern&gt;&quot; where
</p>

<dl>
<dt><code>default </code></dt><dd><p>An ISO8601 format string
</p>

<ul>
<li><p><code>date:</code> This <code>MUST</code> be in ISO8601 format YYYY-MM-DD
</p>
</li>
<li><p><code>datetime:</code> a date-time. This <code>MUST</code> be in ISO 8601 format of YYYY-MM-DDThh:mm:ssZ in UTC time
</p>
</li>
<li><p><code>time:</code> a time without a date
</p>
</li></ul>
</dd>
<dt><code>any </code></dt><dd><p>Any parsable representation of the type. The implementing library 
can attempt to parse the datetime via a range of strategies, e.g. <a href="https://CRAN.R-project.org/package=lubridate">lubridate</a>, 
<a href="https://CRAN.R-project.org/package=parsedate">parsedate</a>,<code><a href="base.html#topic+strptime">strptime</a></code>,
<code><a href="base.html#topic+DateTimeClasses">DateTimeClasses</a></code>.</p>
</dd>
<dt><code>&lt;pattern&gt; </code></dt><dd><p>date/time values in this field can be parsed according to <code>pattern</code>.
<code>&lt;pattern&gt;</code> MUST follow the syntax of <code><a href="base.html#topic+strptime">strptime</a></code>. 
(That is, values in the this field should be parseable by R using <code>&lt;pattern&gt;</code>).</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="types.castDate_+3A_value">value</code></td>
<td>
<p>date to cast</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="https://specs.frictionlessdata.io//table-schema/#date">Types and formats specifications</a>, 
<code><a href="base.html#topic+strptime">strptime</a></code>, <code><a href="base.html#topic+DateTimeClasses">DateTimeClasses</a></code>,
<code><a href="parsedate.html#topic+parsedate-package">parsedate-package</a></code> and 
<code><a href="lubridate.html#topic+lubridate-package">lubridate-package</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>types.castDate(format = "default", value =  as.Date("2019-1-1"))

types.castDate(format = "default", value = "2019-1-1")

types.castDate(format = "any", value = "2019-1-1")

types.castDate(format = "%d/%m/%y", value = "21/11/06")

types.castDate(format = "%d/%m/%y", value = as.Date("2019-1-1"))

</code></pre>

<hr>
<h2 id='types.castDatetime'>Cast datetime</h2><span id='topic+types.castDatetime'></span>

<h3>Description</h3>

<p>Cast date with time
</p>


<h3>Usage</h3>

<pre><code class='language-R'>types.castDatetime(format = "%Y-%m-%dT%H:%M:%SZ", value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="types.castDatetime_+3A_format">format</code></td>
<td>
<p>available options are &quot;default&quot;, &quot;any&quot;, and &quot;&lt;pattern&gt;&quot; where
</p>

<dl>
<dt><code>default </code></dt><dd><p>An ISO8601 format string e.g. YYYY-MM-DDThh:mm:ssZ in UTC time</p>
</dd>
<dt><code>any </code></dt><dd><p>As for <code><a href="#topic+types.castDate">types.castDate</a></code></p>
</dd>
<dt><code>&lt;pattern&gt; </code></dt><dd><p>As for <code><a href="#topic+types.castDate">types.castDate</a></code></p>
</dd>
</dl>
</td></tr>
<tr><td><code id="types.castDatetime_+3A_value">value</code></td>
<td>
<p>datetime to cast</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="https://specs.frictionlessdata.io//table-schema/#datetime">Types and formats specifications</a>, 
<code><a href="base.html#topic+strptime">strptime</a></code>, <code><a href="base.html#topic+DateTimeClasses">DateTimeClasses</a></code>,
<code><a href="parsedate.html#topic+parsedate-package">parsedate-package</a></code> and 
<code><a href="lubridate.html#topic+lubridate-package">lubridate-package</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
types.castDatetime(format = "default", value = "2014-01-01T06:00:00Z")

types.castDatetime(format = "%d/%m/%y %H:%M", value = "21/11/06 16:30")
 
</code></pre>

<hr>
<h2 id='types.castDuration'>Cast duration of time</h2><span id='topic+types.castDuration'></span>

<h3>Description</h3>

<p>Cast duration of time
</p>


<h3>Usage</h3>

<pre><code class='language-R'>types.castDuration(format = "default", value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="types.castDuration_+3A_format">format</code></td>
<td>
<p>no options (other than the default)</p>
</td></tr>
<tr><td><code id="types.castDuration_+3A_value">value</code></td>
<td>
<p>duration to cast</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We follow the definition of <a href="https://www.w3.org/TR/xmlschema-2/#duration">XML Schema duration datatype</a> 
directly and that definition is implicitly inlined here.
</p>
<p>To summarize: the lexical representation for duration is the <a href="https://en.wikipedia.org/wiki/ISO_8601#Durations">ISO 8601</a>
extended format PnYnMnDTnHnMnS, where nY represents the number of years, nM the number of months, nD the number of days, 
'T' is the date/time separator, nH the number of hours, nM the number of minutes and nS the number of seconds. 
The number of seconds can include decimal digits to arbitrary precision. 
Date and time elements including their designator may be omitted if their value is zero, 
and lower order elements may also be omitted for reduced precision.
</p>


<h3>See Also</h3>

<p><a href="https://specs.frictionlessdata.io//table-schema/#duration">Types and formats specifications</a>, 
<code><a href="lubridate.html#topic+lubridate-package">lubridate-package</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
types.castDuration(format = "default", value = durations(years= 10))

types.castDuration(format = "default", value = "P1Y10M3DT5H11M7S")
 
</code></pre>

<hr>
<h2 id='types.castGeojson'>Cast JSON object according to GeoJSON or TopoJSON spec</h2><span id='topic+types.castGeojson'></span>

<h3>Description</h3>

<p>Cast JSON object according to GeoJSON or TopoJSON spec
</p>


<h3>Usage</h3>

<pre><code class='language-R'>types.castGeojson(format, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="types.castGeojson_+3A_format">format</code></td>
<td>
<p>default is a geojson object as per the <a href="https://geojson.org/">GeoJSON spec</a> or
topojson object as per the <a href="https://github.com/topojson/topojson-specification/blob/master/README.md">TopoJSON spec</a></p>
</td></tr>
<tr><td><code id="types.castGeojson_+3A_value">value</code></td>
<td>
<p>GeoJSON to cast</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="https://specs.frictionlessdata.io//table-schema/#geojson">Types and formats specifications</a>
</p>

<hr>
<h2 id='types.castGeopoint'>Cast geographic point</h2><span id='topic+types.castGeopoint'></span>

<h3>Description</h3>

<p>Cast geographic point
</p>


<h3>Usage</h3>

<pre><code class='language-R'>types.castGeopoint(format, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="types.castGeopoint_+3A_format">format</code></td>
<td>
<p>available options are &quot;default&quot;, &quot;array&quot; and &quot;object&quot;, where
</p>

<dl>
<dt><code>default </code></dt><dd><p>A string of the pattern &quot;lon, lat&quot;, where <code>lon</code> is the longitude 
and <code>lat</code> is the latitude (note the space is optional after the <code>,</code>). E.g. <code>"90, 45"</code>.</p>
</dd>
<dt><code>array </code></dt><dd><p>A JSON array, or a string parsable as a JSON array, of exactly two items, 
where each item is a number, and the first item is <code>lon</code> and the second item is <code>lat</code> e.g. <code>[90, 45]</code>.</p>
</dd>
<dt><code>object </code></dt><dd><p>A JSON object with exactly two keys, <code>lat</code> and <code>lon</code> and each value is a number e.g. <code>{"lon": 90, "lat": 45}</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="types.castGeopoint_+3A_value">value</code></td>
<td>
<p>geopoint to cast</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="https://specs.frictionlessdata.io//table-schema/#geopoint">Types and formats specifications</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
types.castGeopoint(format = "default", value = list(180, 90))

types.castGeopoint(format = "default", value = '180,90')

types.castGeopoint(format = "default", value = '180, -90')

types.castGeopoint(format = "array", value = list(180, 90))

types.castGeopoint(format = "array", value =  '[180, -90]')

types.castGeopoint(format = "object", value = list(lon = 180, lat = 90))

types.castGeopoint(format = "object", value =  '{"lon": 180, "lat": 90}')

</code></pre>

<hr>
<h2 id='types.castInteger'>Cast integer</h2><span id='topic+types.castInteger'></span>

<h3>Description</h3>

<p>Cast integer. Integer values are indicated in the standard way for any valid integer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>types.castInteger(
  format,
  value,
  options = {
 }
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="types.castInteger_+3A_format">format</code></td>
<td>
<p>no options (other than the default)</p>
</td></tr>
<tr><td><code id="types.castInteger_+3A_value">value</code></td>
<td>
<p>integer to cast</p>
</td></tr>
<tr><td><code id="types.castInteger_+3A_options">options</code></td>
<td>
<p>named list set bareNumber <code>TRUE</code> or <code>FALSE</code>, see details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>bareNumber is a boolean field with a default of <code>TRUE</code>. If <code>TRUE</code> the physical contents of this field must follow 
the formatting constraints already set out. If <code>FALSE</code> the contents of this field may contain leading 
and or trailing non-numeric characters (which implementors MUST therefore strip). 
The purpose of <code>bareNumber</code> is to allow publishers to publish numeric data that contains trailing characters such as percentages
e.g. <code>95</code>
if anything, they do with stripped text.
</p>


<h3>See Also</h3>

<p><a href="https://specs.frictionlessdata.io//table-schema/#integer">Types and formats specifications</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>types.castInteger(format = "default", value = 1)

types.castInteger(format = "default", value = "1")
# cast trailing non numeric character
types.castInteger(format = "default", value = "1$", options = list(bareNumber = FALSE))

</code></pre>

<hr>
<h2 id='types.castList'>Cast list</h2><span id='topic+types.castList'></span>

<h3>Description</h3>

<p>cast list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>types.castList(format, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="types.castList_+3A_format">format</code></td>
<td>
<p>no options (other than the default)</p>
</td></tr>
<tr><td><code id="types.castList_+3A_value">value</code></td>
<td>
<p>lists, or valid JSON format arrays to cast</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="https://specs.frictionlessdata.io//table-schema/#array">Types and formats specifications</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
types.castList(format = "default", value =  list())

types.castList(format = "default", value = list('key', 'value'))

types.castList(format = "default", value = '["key", "value"]') # cast valid json array

</code></pre>

<hr>
<h2 id='types.castNumber'>Cast numbers of any kind including decimals</h2><span id='topic+types.castNumber'></span>

<h3>Description</h3>

<p>Cast numbers of any kind including decimals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>types.castNumber(
  format,
  value,
  options = {
 }
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="types.castNumber_+3A_format">format</code></td>
<td>
<p>no options (other than the default)</p>
</td></tr>
<tr><td><code id="types.castNumber_+3A_value">value</code></td>
<td>
<p>number to cast</p>
</td></tr>
<tr><td><code id="types.castNumber_+3A_options">options</code></td>
<td>
<p>available options are &quot;decimalChar&quot;, &quot;groupChar&quot; and &quot;bareNumber&quot;, where
</p>

<dl>
<dt><code>decimalChar </code></dt><dd><p>A string whose value is used to represent a decimal point within the number. The default value is &quot;.&quot;.</p>
</dd>
<dt><code>groupChar </code></dt><dd><p>A string whose value is used to group digits within the number. The default value is null. A common value is &quot;,&quot; e.g. &quot;100,000&quot;.</p>
</dd>
<dt><code>bareNumber </code></dt><dd><p>A boolean field with a default of <code>TRUE</code> If <code>TRUE</code> the physical contents of this field must follow 
the formatting constraints already set out. If <code>FALSE</code> the contents of this field may contain leading and/or 
trailing non-numeric characters (which implementors MUST therefore strip). The purpose of <code>bareNumber</code> is to allow publishers 
to publish numeric data that contains trailing characters such as percentages e.g. 95
e.g. 95 or EUR 95. Note that it is entirely up to implementors what, if anything, they do with stripped text.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>The lexical formatting follows that of decimal in <a href="https://www.w3.org/TR/xmlschema-2/#decimal">XMLSchema</a>: a non-empty finite-length sequence 
of decimal digits separated by a period as a decimal indicator. An optional leading sign is allowed. If the sign is omitted, &quot;+&quot; is assumed. 
Leading and trailing zeroes are optional. If the fractional part is zero, the period and following zero(es) can be omitted. 
For example: '-1.23', '12678967.543233', '+100000.00', '210'.
</p>
<p>The following special string values are permitted (case need not be respected):
</p>

<ul>
<li><p><code>NaN</code>: not a number
</p>
</li>
<li><p><code>INF</code>: positive infinity
</p>
</li>
<li><p><code>-INF</code>: negative infinity
</p>
</li></ul>

<p>A number MAY also have a trailing:
</p>

<ul>
<li><p><code>exponent</code>: this <code>MUST</code> consist of an E followed by an optional + or - sign followed by one or more decimal digits (0-9)
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="https://specs.frictionlessdata.io//table-schema/#number">Types and formats specifications</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
types.castNumber(format = "default", value = 1)
types.castNumber(format = "default", value = "1.0")

# cast number with  percent sign
types.castNumber(format = "default", value = "10.5%", options = list(bareNumber = FALSE))

# cast number with comma group character
types.castNumber(format = "default", value = "1,000", options = list(groupChar = ','))
types.castNumber(format = "default", value = "10,000.50", options = list(groupChar = ','))

# cast number with "#" group character and "&amp;" as decimal character
types.castNumber(format = "default", value = "10#000&amp;50", 
options = list(groupChar = '#', decimalChar = '&amp;'))

</code></pre>

<hr>
<h2 id='types.castObject'>Cast object</h2><span id='topic+types.castObject'></span>

<h3>Description</h3>

<p>Cast object data which is lists or valid JSON.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>types.castObject(format, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="types.castObject_+3A_format">format</code></td>
<td>
<p>no options (other than the default)</p>
</td></tr>
<tr><td><code id="types.castObject_+3A_value">value</code></td>
<td>
<p>object to cast</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="https://specs.frictionlessdata.io//table-schema/#object">Types and formats specifications</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
types.castObject(format = "default", value = list())

types.castObject(format = "default", value = "{}")

types.castObject(format = "default", value = '{"key": "value"}')

</code></pre>

<hr>
<h2 id='types.castString'>Cast string</h2><span id='topic+types.castString'></span>

<h3>Description</h3>

<p>Cast string that is, sequences of characters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>types.castString(format, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="types.castString_+3A_format">format</code></td>
<td>
<p>available options are &quot;default&quot;, &quot;email&quot;, &quot;uri&quot;, &quot;binary&quot; and &quot;uuid&quot;, where
</p>

<dl>
<dt><code>default </code></dt><dd><p>Any valid string.</p>
</dd>
<dt><code>email </code></dt><dd><p>A valid email address.</p>
</dd>
<dt><code>uri </code></dt><dd><p>A valid URI.</p>
</dd>
<dt><code>binary </code></dt><dd><p>A base64 encoded string representing binary data.</p>
</dd>
<dt><code>uuid </code></dt><dd><p>A string that is a uuid.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="types.castString_+3A_value">value</code></td>
<td>
<p>string to cast</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="https://specs.frictionlessdata.io//table-schema/#string">Types and formats specifications</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# cast any string
types.castString(format = "default", value = "string")

# cast email
types.castString(format = "email", value = "name@gmail.com")

# cast binary
types.castString(format = "binary", value = "dGVzdA==")

# cast uuid
types.castString(format = "uuid", value = "95ecc380-afe9-11e4-9b6c-751b66dd541e")

</code></pre>

<hr>
<h2 id='types.castTime'>Cast time without a date</h2><span id='topic+types.castTime'></span>

<h3>Description</h3>

<p>Cast time without a date
</p>


<h3>Usage</h3>

<pre><code class='language-R'>types.castTime(format = "%H:%M:%S", value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="types.castTime_+3A_format">format</code></td>
<td>
<p>available options are &quot;default&quot;, &quot;any&quot;, and &quot;&lt;pattern&gt;&quot; where
</p>

<dl>
<dt><code>default </code></dt><dd><p>An ISO8601 time string e.g. hh:mm:ss</p>
</dd>
<dt><code>any </code></dt><dd><p>As for <code><a href="#topic+types.castDate">types.castDate</a></code></p>
</dd>
<dt><code>&lt;pattern&gt; </code></dt><dd><p>As for <code><a href="#topic+types.castDate">types.castDate</a></code></p>
</dd>
</dl>
</td></tr>
<tr><td><code id="types.castTime_+3A_value">value</code></td>
<td>
<p>time to cast</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="https://specs.frictionlessdata.io//table-schema/#time">Types and formats specifications</a>,
<code><a href="base.html#topic+strptime">strptime</a></code>, <code><a href="base.html#topic+DateTimeClasses">DateTimeClasses</a></code>,
<code><a href="parsedate.html#topic+parsedate-package">parsedate-package</a></code> and 
<code><a href="lubridate.html#topic+lubridate-package">lubridate-package</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
types.castTime(format = "default", value = '06:00:00')

</code></pre>

<hr>
<h2 id='types.castYear'>Cast year</h2><span id='topic+types.castYear'></span>

<h3>Description</h3>

<p>Cast year. A calendar year as per <a href="https://www.w3.org/TR/xmlschema-2/#gYear">XMLSchema gYear</a>. 
Usual lexical representation is: YYYY.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>types.castYear(format, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="types.castYear_+3A_format">format</code></td>
<td>
<p>no options (other than the default)</p>
</td></tr>
<tr><td><code id="types.castYear_+3A_value">value</code></td>
<td>
<p>year to cast</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="https://specs.frictionlessdata.io//table-schema/#year">Types and formats specifications</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
types.castYear(format = "default", value = 2000)

types.castYear(format = "default", value = "2010")

</code></pre>

<hr>
<h2 id='types.castYearmonth'>Cast a specific month in a specific year</h2><span id='topic+types.castYearmonth'></span>

<h3>Description</h3>

<p>Cast a specific month in a specific year as per <a href="https://www.w3.org/TR/xmlschema-2/#gYearMonth">XMLSchema gYearMonth</a>. 
Usual lexical representation is: YYYY-MM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>types.castYearmonth(format, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="types.castYearmonth_+3A_format">format</code></td>
<td>
<p>no options (other than the default)</p>
</td></tr>
<tr><td><code id="types.castYearmonth_+3A_value">value</code></td>
<td>
<p>list or string with yearmonth to cast</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="https://specs.frictionlessdata.io//table-schema/#yearmonth">Types and formats specifications</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
types.castYearmonth(format = "default", value = list(2000, 10))

types.castYearmonth(format = "default", value = "2018-11")

</code></pre>

<hr>
<h2 id='validate'>validate descriptor</h2><span id='topic+validate'></span>

<h3>Description</h3>

<p>Validates whether a schema is a validate Table Schema accordingly to the specifications. 
It does not validate data against a schema.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate(descriptor)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate_+3A_descriptor">descriptor</code></td>
<td>
<p>schema descriptor, one of:
</p>

<ul>
<li><p> string with the local CSV file (path)
</p>
</li>
<li><p> string with the remote CSV file (url)
</p>
</li>
<li><p> list object
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> on valid
</p>

<hr>
<h2 id='write_json'>Save json file</h2><span id='topic+write_json'></span>

<h3>Description</h3>

<p>save json
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_json(x, file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_json_+3A_x">x</code></td>
<td>
<p>list object</p>
</td></tr>
<tr><td><code id="write_json_+3A_file">file</code></td>
<td>
<p>file</p>
</td></tr>
</table>

<hr>
<h2 id='Writeable'>Writeable class</h2><span id='topic+Writeable'></span>

<h3>Description</h3>

<p>Writable streams class
</p>


<h3>Format</h3>

<p><code><a href="R6.html#topic+R6Class">R6Class</a></code> object.
</p>


<h3>Value</h3>

<p>Object of <code><a href="R6.html#topic+R6Class">R6Class</a></code> .
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
