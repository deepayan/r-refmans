<!DOCTYPE html><html><head><title>Help for package combinat</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {combinat}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#combn'><p> Generate all combinations of the elements of x taken m at a time.</p></a></li>
<li><a href='#dmnom'>
<p>density of multinomial, and support</p>
functions</a></li>
<li><a href='#hcube'><p> Generate all points on a hypercuboid lattice.</p></a></li>
<li><a href='#nsimplex'><p> Computes the number of points on a (p, n)-simplex lattice</p></a></li>
<li><a href='#permn'><p> Generates all permutations of the elements of x</p></a></li>
<li><a href='#rmultinomial'><p> Generate random samples from multinomial distributions</p></a></li>
<li><a href='#x2u'><p>  Convert an x-encoded simplex-lattice point to a u-encoded simplex-lattice point</p></a></li>
<li><a href='#xsimplex'><p>  Generates all points on a (p,n) simplex lattice (i.e. a p-part</p>
composition of n).</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.0-8</td>
</tr>
<tr>
<td>Title:</td>
<td>combinatorics utilities</td>
</tr>
<tr>
<td>Author:</td>
<td>Scott Chasalow</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Vince Carey &lt;stvjc@channing.harvard.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>routines for combinatorics</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2012-10-29 08:58:26</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2012-10-29 08:58:26 UTC; ripley</td>
</tr>
</table>
<hr>
<h2 id='combn'> Generate all combinations of the elements of x taken m at a time. </h2><span id='topic+combn'></span><span id='topic+combn2'></span><span id='topic+nCm'></span>

<h3>Description</h3>

<p>Generate all combinations of the elements of x taken m at a time.
If x is a positive integer,  returns all combinations
of the elements of seq(x) taken m at a time.
If argument &quot;fun&quot; is not null,  applies a function given
by the argument to each point.  If simplify is FALSE,  returns
a list; else returns a vector or an array.  &quot;...&quot; are passed
unchanged to function given by argument fun,  if any.
</p>
<p>combn2:Generate all combinations of the elements of x taken two at a time.
If x is missing,  generate all combinations of 1:n taken two
at a time (that is,  the indices of x that would give all
combinations of the elements of x if x with length n had been given).
Exactly one of arguments &quot;x&quot; and &quot;n&quot; should be given; no provisions
for function evaluation.
</p>
<p>nCm: Compute the binomial coefficient (&quot;n choose m&quot;),  where n is any
real number and m is any integer.  Arguments n and m may be vectors;
they will be replicated as necessary to have the same length.
Argument tol controls rounding of results to integers.  If the
difference between a value and its nearest integer is less than tol,
the value returned will be rounded to its nearest integer.  To turn
off rounding, use tol = 0.  Values of tol greater than the default
should be used only with great caution, unless you are certain only
integer values should be returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combn(x, m, fun=NULL, simplify=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combn_+3A_x">x</code></td>
<td>
<p> vector source for combinations </p>
</td></tr>
<tr><td><code id="combn_+3A_m">m</code></td>
<td>
<p> number of elements </p>
</td></tr>
<tr><td><code id="combn_+3A_fun">fun</code></td>
<td>
<p> function to be applied to each combination (may be null) </p>
</td></tr>
<tr><td><code id="combn_+3A_simplify">simplify</code></td>
<td>
<p> logical, if FALSE, returns a list,
otherwise returns vector or array </p>
</td></tr>
<tr><td><code id="combn_+3A_...">...</code></td>
<td>
<p> args to fun </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Nijenhuis, A. and Wilf, H.S. (1978) Combinatorial Algorithms for
Computers and Calculators.  NY:  Academic Press.
</p>


<h3>Value</h3>

<p>see simplify argument
</p>


<h3>Author(s)</h3>

<p> Code by Scott Chasalow, R package and doc prep by Vince Carey, stvjc@channing.harvard.edu</p>


<h3>References</h3>

<p> ~put references to the literature/web site here ~ </p>


<h3>Examples</h3>

<pre><code class='language-R'> combn(letters[1:4], 2)
 combn(10, 5, min)  # minimum value in each combination
# Different way of encoding points:
 combn(c(1,1,1,1,2,2,2,3,3,4), 3, tabulate, nbins = 4)
#Compute support points and (scaled) probabilities for a
#Multivariate-Hypergeometric(n = 3, N = c(4,3,2,1)) p.f.:
# table.mat(t(combn(c(1,1,1,1,2,2,2,3,3,4), 3, tabulate,nbins=4)))
</code></pre>

<hr>
<h2 id='dmnom'>  
density of multinomial, and support
functions
</h2><span id='topic+dmnom'></span><span id='topic+fact'></span><span id='topic+logfact'></span>

<h3>Description</h3>

<p>density of multinomial
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmnom(x, size=sum(x), prob=stop("no prob arg"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dmnom_+3A_x">x</code></td>
<td>
<p> vector </p>
</td></tr>
<tr><td><code id="dmnom_+3A_size">size</code></td>
<td>
<p> total </p>
</td></tr>
<tr><td><code id="dmnom_+3A_prob">prob</code></td>
<td>
<p> parameter vector (sums to 1) </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> code by Scott Chasalow, R pack and maint by VJ Carey &lt;stvjc@channing.harvard.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'> dmnom(c(1,1,4,4),10,c(.2,.2,.3,.3))
</code></pre>

<hr>
<h2 id='hcube'> Generate all points on a hypercuboid lattice. </h2><span id='topic+hcube'></span>

<h3>Description</h3>

<p>Generate all points on a hypercuboid lattice.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hcube(x, scale, translation)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hcube_+3A_x">x</code></td>
<td>
 
<p>Argument x is an integer vector giving the extent of each dimension;
the number of dimensions is length(x).
</p>
</td></tr>
<tr><td><code id="hcube_+3A_scale">scale</code></td>
<td>
 
<p>Argument scale is a vector of real numbers giving an amount by which
to multiply the points in each dimension;  it will be replicated as
necessary to have the same length as x.
</p>
</td></tr>
<tr><td><code id="hcube_+3A_translation">translation</code></td>
<td>
 
<p>Argument translate is a vector of real numbers giving an amount to
translate (from the &quot;origin&quot;, rep(1,length(x))) the points in each
dimension;  it will be replicated as necessary to have the same
length as x.  To use rep(0,length(x)) as the origin,  use
translation = -1.  Scaling,  if any,  is done BEFORE translation.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A prod(x) by length(x) numeric matrix;  element (i,j) gives the
location of point i in the jth dimension.  The first column
(dimension) varies most rapidly.
</p>


<h3>Author(s)</h3>

<p> code by Scott Chasalow, R pack and maint by VJ Carey &lt;stvjc@channing.harvard.edu&gt;</p>


<h3>References</h3>

<p> ~put references to the literature/web site here ~ </p>


<h3>See Also</h3>

 
<p>fac.design, expand.grid </p>

<hr>
<h2 id='nsimplex'> Computes the number of points on a (p, n)-simplex lattice </h2><span id='topic+nsimplex'></span>

<h3>Description</h3>

<p>Computes the number of points on a (p, n)-simplex lattice; that is, the
number of p-part compositions of n. This gives the number of points in
the support space of a Multinomial(n, q) distribution, where
p == length(q).
</p>
<p>Arguments p and n are replicated as necessary to have the length of the
longer of them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nsimplex(p, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nsimplex_+3A_p">p</code></td>
<td>
<p> vector of integers </p>
</td></tr>
<tr><td><code id="nsimplex_+3A_n">n</code></td>
<td>
<p> vector of integers </p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nsimplex(3,5)
</code></pre>

<hr>
<h2 id='permn'> Generates all permutations of the elements of x </h2><span id='topic+permn'></span>

<h3>Description</h3>

<p>Generates all permutations of the elements of x, in a minimal-
change order. If x is a positive integer,  returns all permutations
of the elements of seq(x). If argument &quot;fun&quot; is not null,  applies
a function given by the argument to each point. &quot;...&quot; are passed
unchanged to the function given by argument fun, if any.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permn(x, fun=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permn_+3A_x">x</code></td>
<td>
<p> vector </p>
</td></tr>
<tr><td><code id="permn_+3A_fun">fun</code></td>
<td>
<p> if non.null, applied at each perm </p>
</td></tr>
<tr><td><code id="permn_+3A_...">...</code></td>
<td>
<p> args passed to fun </p>
</td></tr>
</table>


<h3>Value</h3>

<p>list: each component is either a permutation, or the
results of applying fun to a permutation
</p>


<h3>References</h3>

 
<p>Reingold, E.M., Nievergelt, J., Deo, N. (1977) Combinatorial
Algorithms: Theory and Practice. NJ: Prentice-Hall. pg. 170.
</p>


<h3>See Also</h3>

 
<p>sample, fact, combn, hcube, xsimplex
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    # Convert output to a matrix of dim c(6, 720)
     t(array(unlist(permn(6)), dim = c(6, gamma(7))))
       # A check that every element occurs the same number of times in each
       # position
       apply(t(array(unlist(permn(6)), dim = c(6, gamma(7)))), 2, tabulate,
               nbins = 6)

       # Apply, on the fly, the diff function to every permutation
       t(array(unlist(permn(6, diff)), dim = c(5, gamma(7))))
</code></pre>

<hr>
<h2 id='rmultinomial'> Generate random samples from multinomial distributions </h2><span id='topic+rmultinomial'></span><span id='topic+rmultz2'></span>

<h3>Description</h3>

<p>rmultinomial: Generate random samples from multinomial distributions, where both n
and p may vary among distributions
</p>
<p>rmultz2: fixed p case
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmultinomial(n, p, rows=max(c(length(n), nrow(p))))
rmultz2(n, p, draws=length(n))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmultinomial_+3A_n">n</code></td>
<td>
<p> vector of sizes </p>
</td></tr>
<tr><td><code id="rmultinomial_+3A_p">p</code></td>
<td>
<p> vector or probs </p>
</td></tr>
<tr><td><code id="rmultinomial_+3A_rows">rows</code></td>
<td>
<p> numeric giving desired number rows to be output </p>
</td></tr>
<tr><td><code id="rmultinomial_+3A_draws">draws</code></td>
<td>
<p> number samples required </p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of <code>rows</code> rows delivering specified samples
</p>


<h3>Author(s)</h3>

<p> John Wallace, 17 Feb 1997 S-news , mods by Chasalow </p>


<h3>Examples</h3>

<pre><code class='language-R'> n &lt;- c(100,20,10)
 p &lt;- matrix(c(.3,.1,.5,.1,.1,.2,.6,.8,.3),3)
 rmultinomial(n,p)
</code></pre>

<hr>
<h2 id='x2u'>  Convert an x-encoded simplex-lattice point to a u-encoded simplex-lattice point </h2><span id='topic+x2u'></span>

<h3>Description</h3>

<p>Convert an x-encoded simplex-lattice point to a u-encoded
simplex-lattice point  (equivalently,  &quot;untabulate&quot; bin counts)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x2u(x, labels=seq(along = x))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="x2u_+3A_x">x</code></td>
<td>
 
<p>x:    A numeric vector.  x[i] is interpreted as the count in bin i.</p>
</td></tr>
<tr><td><code id="x2u_+3A_labels">labels</code></td>
<td>
 
<p>A vector.  Interpreted as the bin labels;  default value is
seq(along = x), which causes return of a u-encoded simplex-lattice
point.  Other values of labels cause return of the result of
subscripting labels with the u-encoded simplex-lattice point that
would have been obtained if the default value of labels were used.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>rep(labels, x), a vector of length sum(x).  If labels = seq(along = x)
(the default),  value is the u-encoded translation of the simplex
lattice point, x.  Equivalently,  value gives the bin numbers,
in lexicographic order,  for the objects represented by the counts in
x.  For other values of argument &quot;labels&quot;, value gives the bin labels
for the objects represented by the counts in x (equivalent to
labels[x2u(x)]).
</p>


<h3>See Also</h3>

<p> tabulate, rep </p>

<hr>
<h2 id='xsimplex'>  Generates all points on a (p,n) simplex lattice (i.e. a p-part
composition of n).</h2><span id='topic+xsimplex'></span>

<h3>Description</h3>

<p>Generates all points on a p,n simplex lattice (i.e. a p-part
composition of n).  Each point is represented as x, a
p-dimensional vector of nonnegative integers that sum to n.
If argument &quot;fun&quot; is not null,  applies a function given
by the argument to each point.  If simplify is FALSE,  returns
a list; else returns a vector or an array.  &quot;...&quot; are passed
unchanged to function given by argument fun,  if any. </p>


<h3>Usage</h3>

<pre><code class='language-R'>xsimplex(p, n, fun=NULL, simplify=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xsimplex_+3A_p">p</code></td>
<td>
<p> first parameter of lattice description </p>
</td></tr>
<tr><td><code id="xsimplex_+3A_n">n</code></td>
<td>
<p>  second parameter of lattice description</p>
</td></tr>
<tr><td><code id="xsimplex_+3A_fun">fun</code></td>
<td>
<p> function to be applied pointwise </p>
</td></tr>
<tr><td><code id="xsimplex_+3A_simplify">simplify</code></td>
<td>
<p> logical: if FALSE, value is a list, otherwise a vector or
array</p>
</td></tr>
<tr><td><code id="xsimplex_+3A_...">...</code></td>
<td>
<p> parameters to be passed to <code>fun</code> </p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#Compute Multinomial(n = 4, pi = rep(1/3, 3)) p.f.:
   xsimplex(3, 4, dmnom, prob=1/3)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
