<!DOCTYPE html><html><head><title>Help for package simfam</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {simfam}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#simfam-package'><p>Simulate and Model Family Pedigrees With Structured Founders</p></a></li>
<li><a href='#admix_fam'><p>Calculate admixture matrix of a pedigree with known admixture of founders</p></a></li>
<li><a href='#admix_last_gen'><p>Calculate admixture matrix for last generation of a pedigree with admixture of founders</p></a></li>
<li><a href='#draw_sex'><p>Draw sex values randomly for a list of individuals</p></a></li>
<li><a href='#fam_ancestors'><p>Construct an ancestors-only pedigree for one person <code>G</code>-generations deep</p></a></li>
<li><a href='#geno_fam'><p>Draw random genotypes on a pedigree with known founder genotypes</p></a></li>
<li><a href='#geno_last_gen'><p>Draw random genotypes for last generation of a pedigree with known founder genotypes</p></a></li>
<li><a href='#kinship_fam'><p>Calculate kinship matrix of a pedigree with structured founders</p></a></li>
<li><a href='#kinship_last_gen'><p>Calculate kinship matrix for last generation of a pedigree with structured founders</p></a></li>
<li><a href='#prune_fam'><p>Remove non-ancestors of a set of individuals from pedigree</p></a></li>
<li><a href='#recomb_admix_inds'><p>Reduce haplotype ancestry data to population ancestry dosage matrices</p></a></li>
<li><a href='#recomb_fam'><p>Draw recombination breaks for autosomes from a pedigree</p></a></li>
<li><a href='#recomb_geno_inds'><p>Reduce haplotype data to genotype matrix</p></a></li>
<li><a href='#recomb_haplo_inds'><p>Construct haplotypes of individuals given their ancestral blocks and the ancestral haplotype variants</p></a></li>
<li><a href='#recomb_init_founders'><p>Initialize chromosome structures for founders</p></a></li>
<li><a href='#recomb_last_gen'><p>Draw recombination breaks for autosomes for last generation of a pedigree</p></a></li>
<li><a href='#recomb_map_fix_ends_chr'><p>Extrapolate and shift recombination map of one chromosome to ends</p></a></li>
<li><a href='#recomb_map_hg'><p>Simplified recombination maps for human genomes</p></a></li>
<li><a href='#recomb_map_inds'><p>Map recombination breaks from genetic positions to base pair coordinates</p></a></li>
<li><a href='#recomb_map_simplify_chr'><p>Simplify recombination map of one chromosome to a desired numerical precision</p></a></li>
<li><a href='#sim_pedigree'><p>Construct a random pedigree</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Simulate and Model Family Pedigrees with Structured Founders</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.6</td>
</tr>
<tr>
<td>Description:</td>
<td>The focus is on simulating and modeling families with founders drawn from a structured population (for example, with different ancestries or other potentially non-family relatedness), in contrast to traditional pedigree analysis that treats all founders as equally unrelated.  Main function simulates a random pedigree for many generations, avoiding close relatives, pairing closest individuals according to a 1D geography and their randomly-drawn sex, and with variable children sizes to result in a target population size per generation.  Auxiliary functions calculate kinship matrices, admixture matrices, and draw random genotypes across arbitrary pedigree structures starting from the corresponding founder values.  The code is built around the plink FAM table format for pedigrees.  Described in Yao and Ochoa (2022) &lt;<a href="https://doi.org/10.1101%2F2022.03.25.485885">doi:10.1101/2022.03.25.485885</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, stats, tibble</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), popkin, bnpsd (&ge; 1.3.2), kinship2,
RColorBrewer, knitr, rmarkdown</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/OchoaLab/simfam">https://github.com/OchoaLab/simfam</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/OchoaLab/simfam/issues">https://github.com/OchoaLab/simfam/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-09 21:28:58 UTC; viiia</td>
</tr>
<tr>
<td>Author:</td>
<td>Alejandro Ochoa <a href="https://orcid.org/0000-0003-4928-3403"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alejandro Ochoa &lt;alejandro.ochoa@duke.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-09 21:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='simfam-package'>Simulate and Model Family Pedigrees With Structured Founders</h2><span id='topic+simfam-package'></span><span id='topic+_PACKAGE'></span><span id='topic+simfam'></span>

<h3>Description</h3>

<p>The <code>simfam</code> package is for constructing large random families&mdash;with population studies in mind&mdash;with realistic constraints including avoidance of close relative pairings but otherwise biased for closest pairs in a 1-dimensional geography.
There is also code to draw genotypes across the pedigree starting from genotypes for the founders.
Our model allows for the founders to be related or structured&mdash;which arises in practice when there are different ancestries among founders&mdash;and given known parameters for these founders, we provide code to calculate the true kinship and expected admixture proportions of all descendants.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Alejandro Ochoa <a href="mailto:alejandro.ochoa@duke.edu">alejandro.ochoa@duke.edu</a> (<a href="https://orcid.org/0000-0003-4928-3403">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/OchoaLab/simfam">https://github.com/OchoaLab/simfam</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/OchoaLab/simfam/issues">https://github.com/OchoaLab/simfam/issues</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># create some toy data for examples
# data dimensions
n &lt;- 10 # number of individuals per generation
G &lt;- 3 # number of generations
m &lt;- 100 # number of loci
K &lt;- 3 # number of ancestries

# start by simulating pedigree
data &lt;- sim_pedigree( n, G )
# creates FAM table (describes pedigree, most important!)
fam &lt;- data$fam
# lists of IDs split by generation
ids &lt;- data$ids
# and local kinship of last generation
kinship_local_G &lt;- data$kinship_local

# prune pedigree to speed up simulations/etc by removing individuals without
# descendants among set of individuals (here it's last generation)
fam &lt;- prune_fam( fam, ids[[ G ]] )

# to model descendants, first need to setup founders with dummy toy data
# 1) random genotypes
X_1 &lt;- matrix( rbinom( n*m, 2, 0.5 ), m, n )
colnames( X_1 ) &lt;- ids[[ 1 ]] # need IDs to match founders
# 2) kinship of unrelated/outbred individuals
# (but in practice can be any structure!)
kinship_1 &lt;- diag( n ) / 2
colnames( kinship_1 ) &lt;- ids[[ 1 ]] # need IDs to match founders
rownames( kinship_1 ) &lt;- ids[[ 1 ]] # ditto
# 3) construct dummy admixture proportions
admix_proportions_1 &lt;- matrix( runif( n * K ), n, K )
# normalize so rows sum to 1
admix_proportions_1 &lt;- admix_proportions_1 / rowSums( admix_proportions_1 )
rownames( admix_proportions_1 ) &lt;- ids[[ 1 ]] # need IDs to match founders

# now construct/draw/propagate information across the pedigree!

# 1) draw genotypes through pedigree, starting from founders!
X &lt;- geno_fam( X_1, fam )
# version for last generation only, which uses less memory
X_G &lt;- geno_last_gen( X_1, fam, ids )

# 2) calculate kinship through pedigree, starting from kinship of founders!
kinship &lt;- kinship_fam( kinship_1, fam )
# version for last generation only, which uses less memory
kinship_G &lt;- kinship_last_gen( kinship_1, fam, ids )

# 3) calculate expected admixture proportions through pedigree, starting from admixture of founders!
admix_proportions &lt;- admix_fam( admix_proportions_1, fam )
# version for last generation only, which uses less memory
admix_proportions_G &lt;- admix_last_gen( admix_proportions_1, fam, ids )


</code></pre>

<hr>
<h2 id='admix_fam'>Calculate admixture matrix of a pedigree with known admixture of founders</h2><span id='topic+admix_fam'></span>

<h3>Description</h3>

<p>Calculates a full admixture proportions matrix (for all individuals in the provided pedigree FAM table) starting from the admixture proportions of the founders as provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>admix_fam(admix, fam, missing_vals = c("", 0))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="admix_fam_+3A_admix">admix</code></td>
<td>
<p>The admixture proportions matrix of the founders (individuals along rows and ancestries along columns).
This matrix must have row names that identify each founder (matching codes in <code>fam$id</code>).
Individuals may be in a different order than <code>fam$id</code>.
Extra individuals in <code>admix</code> but absent in <code>fam$id</code> will be silently ignored.
All values should be non-negative and each row of <code>admix</code> should sum to one; for speed, this code does not check that <code>admix</code> is valid, just averages data as-is.</p>
</td></tr>
<tr><td><code id="admix_fam_+3A_fam">fam</code></td>
<td>
<p>The pedigree data.frame, in plink FAM format.
Only columns <code>id</code>, <code>pat</code>, and <code>mat</code> are required.
<code>id</code> must be unique and non-missing.
Founders must be present, and their <code>pat</code> and <code>mat</code> values must be missing (see below).
Non-founders must have both their parents be non-missing.
Parents must appear earlier than their children in the table.</p>
</td></tr>
<tr><td><code id="admix_fam_+3A_missing_vals">missing_vals</code></td>
<td>
<p>The list of ID values treated as missing.
<code>NA</code> is always treated as missing.
By default, the empty string (&rdquo;) and zero (0) are also treated as missing (remove values from here if this is a problem).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The admixture proportions matrix of the entire <code>fam</code> table, based on the admixture of the founders.
These are expectations, calculated for each individual as the average ancestry proportion of the parents.
The rows of this admixture matrix correspond to <code>fam$id</code> in that order.
The columns (ancestries) are the same as in the input <code>admix</code>.
</p>


<h3>See Also</h3>

<p>Plink FAM format reference:
<a href="https://www.cog-genomics.org/plink/1.9/formats#fam">https://www.cog-genomics.org/plink/1.9/formats#fam</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The smallest pedigree, two parents and a child.
# A minimal fam table with the three required columns.
# Note "mother" and "father" have missing parent IDs, while "child" does not
library(tibble)
fam &lt;- tibble(
  id = c('father', 'mother', 'child'),
  pat = c(NA, NA, 'father'),
  mat = c(NA, NA, 'mother')
)

# admixture proportions of the parents
admix &lt;- rbind( c(0.3, 0.3, 0.4), c(0.5, 0.25, 0.25) )
# Name the parents with same codes as in `fam`
# (order can be different)
rownames( admix ) &lt;- c('mother', 'father')
# name ancestries too
colnames( admix ) &lt;- c('African', 'European', 'Asian')

# Calculate the full admixture proportions matrix
admix_all &lt;- admix_fam( admix, fam )

# This is a 3x3 matrix with row names matching fam$id.
# The parent submatrix equals the input (reordered),
# but now there's admixture to the child too (averages of parents)
admix_all

</code></pre>

<hr>
<h2 id='admix_last_gen'>Calculate admixture matrix for last generation of a pedigree with admixture of founders</h2><span id='topic+admix_last_gen'></span>

<h3>Description</h3>

<p>A wrapper around the more general <code><a href="#topic+admix_fam">admix_fam()</a></code>, specialized to save memory when only the last generation is desired (<code><a href="#topic+admix_fam">admix_fam()</a></code> returns admixture for the entire pedigree in a single matrix).
This function assumes that generations are non-overlapping (met by the output of <code><a href="#topic+sim_pedigree">sim_pedigree()</a></code>), in which case each generation <code>g</code> can be drawn from generation <code>g-1</code> data only.
That way, only two consecutive generations need be in memory at any given time.
The partitioning of individuals into generations is given by the <code>ids</code> parameter (again matches the output of <code><a href="#topic+sim_pedigree">sim_pedigree()</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>admix_last_gen(admix, fam, ids, missing_vals = c("", 0))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="admix_last_gen_+3A_admix">admix</code></td>
<td>
<p>The admixture proportions matrix of the founders (individuals along rows and ancestries along columns).
This matrix must have row names that identify each founder (matching codes in <code>fam$id</code>).
Individuals may be in a different order than <code>fam$id</code>.
Extra individuals in <code>admix</code> but absent in <code>fam$id</code> will be silently ignored.
All values should be non-negative and each row of <code>admix</code> should sum to one; for speed, this code does not check that <code>admix</code> is valid, just averages data as-is.</p>
</td></tr>
<tr><td><code id="admix_last_gen_+3A_fam">fam</code></td>
<td>
<p>The pedigree data.frame, in plink FAM format.
Only columns <code>id</code>, <code>pat</code>, and <code>mat</code> are required.
<code>id</code> must be unique and non-missing.
Founders must be present, and their <code>pat</code> and <code>mat</code> values must be missing (see below).
Non-founders must have both their parents be non-missing.
Parents must appear earlier than their children in the table.</p>
</td></tr>
<tr><td><code id="admix_last_gen_+3A_ids">ids</code></td>
<td>
<p>A list containing vectors of IDs for each generation.
All these IDs must be present in <code>fam$id</code>.
If IDs in <code>fam</code> and <code>ids</code> do not fully agree, the code processes the IDs in the intersection, which is helpful when <code>fam</code> is pruned but <code>ids</code> is the original (larger) set.</p>
</td></tr>
<tr><td><code id="admix_last_gen_+3A_missing_vals">missing_vals</code></td>
<td>
<p>The list of ID values treated as missing.
<code>NA</code> is always treated as missing.
By default, the empty string (&rdquo;) and zero (0) are also treated as missing (remove values from here if this is a problem).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The admixture proportions matrix of the last generation (the intersection of <code>ids[ length(ids) ]</code> and <code>fam$id</code>).
The rows of this matrix are last-generation individuals in the order that they appear in <code>fam$id</code>.
</p>


<h3>See Also</h3>

<p>Plink FAM format reference:
<a href="https://www.cog-genomics.org/plink/1.9/formats#fam">https://www.cog-genomics.org/plink/1.9/formats#fam</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A small pedigree, two parents and two children.
# A minimal fam table with the three required columns.
# Note "mother" and "father" have missing parent IDs, while children do not
library(tibble)
fam &lt;- tibble(
  id = c('father', 'mother', 'child', 'sib'),
  pat = c(NA, NA, 'father', 'father'),
  mat = c(NA, NA, 'mother', 'mother')
)
# need an `ids` list separating the generations
ids &lt;- list( c('father', 'mother'), c('child', 'sib') )

# admixture proportions of the parents
admix &lt;- rbind( c(0.3, 0.3, 0.4), c(0.5, 0.25, 0.25) )
# Name the parents with same codes as in `fam`
# (order can be different)
rownames( admix ) &lt;- c('mother', 'father')
# name ancestries too
colnames( admix ) &lt;- c('African', 'European', 'Asian')

# calculate the admixture matrix of the children
admix2 &lt;- admix_last_gen( admix, fam, ids )
admix2

</code></pre>

<hr>
<h2 id='draw_sex'>Draw sex values randomly for a list of individuals</h2><span id='topic+draw_sex'></span>

<h3>Description</h3>

<p>Each individual has their sex drawn between male and female with equal probability.
Sex is encoded numerically following the convention for plink FAM files (see below).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_sex(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_sex_+3A_n">n</code></td>
<td>
<p>The number of individuals.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The length-<code>n</code> vector of integer sex assignments: <code>1L</code> corresponds to male, <code>2L</code> to female.
</p>


<h3>See Also</h3>

<p>Plink FAM format reference:
<a href="https://www.cog-genomics.org/plink/1.9/formats#fam">https://www.cog-genomics.org/plink/1.9/formats#fam</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>draw_sex( 10 )

</code></pre>

<hr>
<h2 id='fam_ancestors'>Construct an ancestors-only pedigree for one person <code>G</code>-generations deep</h2><span id='topic+fam_ancestors'></span>

<h3>Description</h3>

<p>Creates an idealized pedigree listing all ancestors of one individual starting from <code>G</code> generations ago, without inbreeding (a binary tree).
IDs are automatically generated strings indicating generation and individual number within generation.
Useful for simple simulations of individuals with explicit ancestors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fam_ancestors(G)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fam_ancestors_+3A_g">G</code></td>
<td>
<p>The desired number of generations.
<code>G=1</code> returns a trivial pedigree with a single individual; <code>G=2</code> an individual and its two parents; <code>G=3</code> an individual, its parents and grandparents, etc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two named elements:
</p>

<ul>
<li> <p><code>fam</code>: a tibble describing the pedigree, with the following columns
</p>

<ul>
<li> <p><code>id</code>: The ID of each individual, a string in the format &quot;g-i&quot; joining with a dash the generation number (&quot;g&quot;, numbered backward in time) and the individual number within the generation (&quot;i&quot;).
</p>
</li>
<li> <p><code>pat</code>: The paternal ID.  For individual &quot;g-i&quot; parent is (g+1)&quot;-&quot;(2*i-1), except for last generation it is <code>NA</code> (their parents are missing).
</p>
</li>
<li> <p><code>mat</code>: The maternal ID.  For individual &quot;g-i&quot; parent is (g+1)&quot;-&quot;(2*i), except for last generation it is <code>NA</code> (their parents are missing).
</p>
</li>
<li> <p><code>sex</code>: 1 (male) for all odd-numbered individuals, 2 (female) for even-numbered individuals, consistent with pedigree structure.  Side-effect is first-generation individual (&quot;1-1&quot;) is always male (edit afterwards as desired).
</p>
</li></ul>

</li>
<li> <p><code>ids</code>: A list containing vectors of IDs separated by generation, but here starting from the last generation (highest &quot;g&quot;), to be consistent with output of <code><a href="#topic+sim_pedigree">sim_pedigree()</a></code> and the expected input of all <code style="white-space: pre;">&#8288;*_last_gen&#8288;</code> functions.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+sim_pedigree">sim_pedigree()</a></code> to simulate a random pedigree with a given number of generations, generation sizes, and other parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># construct the 8-generation ancestor tree of one individual:
data &lt;- fam_ancestors( 8 )
# this is the pedigree
fam &lt;- data$fam
# and this is the handy list of IDs by discrete generation,
# used by `*_last_gen` functions to reduce memory usage
ids &lt;- data$ids

</code></pre>

<hr>
<h2 id='geno_fam'>Draw random genotypes on a pedigree with known founder genotypes</h2><span id='topic+geno_fam'></span>

<h3>Description</h3>

<p>Constructs a random genotype matrix (for all individuals in the provided pedigree FAM table) starting from the genotype matrix of the founders as provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geno_fam(X, fam, missing_vals = c("", 0))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geno_fam_+3A_x">X</code></td>
<td>
<p>The genotype matrix of the founders (loci along rows, individuals along columns).
This matrix must have column names that identify each founder (matching codes in <code>fam$id</code>).
Individuals may be in a different order than <code>fam$id</code>.
Extra individuals in <code>admix</code> but absent in <code>fam$id</code> will be silently ignored.
All values should be in <code>c(0L, 1L, 2L)</code>; for speed, this code does not check that <code>X</code> is valid (i.e. fractional values between 0 and 2 may not cause errors).</p>
</td></tr>
<tr><td><code id="geno_fam_+3A_fam">fam</code></td>
<td>
<p>The pedigree data.frame, in plink FAM format.
Only columns <code>id</code>, <code>pat</code>, and <code>mat</code> are required.
<code>id</code> must be unique and non-missing.
Founders must be present, and their <code>pat</code> and <code>mat</code> values must be missing (see below).
Non-founders must have both their parents be non-missing.
Parents must appear earlier than their children in the table.</p>
</td></tr>
<tr><td><code id="geno_fam_+3A_missing_vals">missing_vals</code></td>
<td>
<p>The list of ID values treated as missing.
<code>NA</code> is always treated as missing.
By default, the empty string (&rdquo;) and zero (0) are also treated as missing (remove values from here if this is a problem).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The random genotype matrix of the entire <code>fam</code> table, starting from the genotypes of the founders.
The columns of this matrix correspond to <code>fam$id</code> in that order.
The rows (loci) are the same as in the input <code>X</code>.
</p>


<h3>See Also</h3>

<p>Plink FAM format reference:
<a href="https://www.cog-genomics.org/plink/1.9/formats#fam">https://www.cog-genomics.org/plink/1.9/formats#fam</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The smallest pedigree, two parents and a child.
# A minimal fam table with the three required columns.
# Note "mother" and "father" have missing parent IDs, while "child" does not
library(tibble)
fam &lt;- tibble(
  id = c('father', 'mother', 'child'),
  pat = c(NA, NA, 'father'),
  mat = c(NA, NA, 'mother')
)

# genotypes of the parents at 4 loci
X &lt;- cbind( c(1, 2, 0, 2), c(0, 2, 2, 1) )
# Name the parents with same codes as in `fam`
# (order can be different)
colnames( X ) &lt;- c('mother', 'father')
# name loci too
rownames( X ) &lt;- paste0( 'rs', 1:4 )

# Draw the full genotype matrix
X_all &lt;- geno_fam( X, fam )

# This is a 4x3 matrix with column names matching fam$id.
# The parent submatrix equals the input (reordered),
# but now there's random genotypes for the child too
X_all

</code></pre>

<hr>
<h2 id='geno_last_gen'>Draw random genotypes for last generation of a pedigree with known founder genotypes</h2><span id='topic+geno_last_gen'></span>

<h3>Description</h3>

<p>A wrapper around the more general <code><a href="#topic+geno_fam">geno_fam()</a></code>, specialized to save memory when only the last generation is desired (<code><a href="#topic+geno_fam">geno_fam()</a></code> returns genotypes for the entire pedigree in a single matrix).
This function assumes that generations are non-overlapping (met by the output of <code><a href="#topic+sim_pedigree">sim_pedigree()</a></code>), in which case each generation <code>g</code> can be drawn from generation <code>g-1</code> data only.
That way, only two consecutive generations need be in memory at any given time.
The partitioning of individuals into generations is given by the <code>ids</code> parameter (again matches the output of <code><a href="#topic+sim_pedigree">sim_pedigree()</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geno_last_gen(X, fam, ids, missing_vals = c("", 0))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geno_last_gen_+3A_x">X</code></td>
<td>
<p>The genotype matrix of the founders (loci along rows, individuals along columns).
This matrix must have column names that identify each founder (matching codes in <code>fam$id</code>).
Individuals may be in a different order than <code>fam$id</code>.
Extra individuals in <code>admix</code> but absent in <code>fam$id</code> will be silently ignored.
All values should be in <code>c(0L, 1L, 2L)</code>; for speed, this code does not check that <code>X</code> is valid (i.e. fractional values between 0 and 2 may not cause errors).</p>
</td></tr>
<tr><td><code id="geno_last_gen_+3A_fam">fam</code></td>
<td>
<p>The pedigree data.frame, in plink FAM format.
Only columns <code>id</code>, <code>pat</code>, and <code>mat</code> are required.
<code>id</code> must be unique and non-missing.
Founders must be present, and their <code>pat</code> and <code>mat</code> values must be missing (see below).
Non-founders must have both their parents be non-missing.
Parents must appear earlier than their children in the table.</p>
</td></tr>
<tr><td><code id="geno_last_gen_+3A_ids">ids</code></td>
<td>
<p>A list containing vectors of IDs for each generation.
All these IDs must be present in <code>fam$id</code>.
If IDs in <code>fam</code> and <code>ids</code> do not fully agree, the code processes the IDs in the intersection, which is helpful when <code>fam</code> is pruned but <code>ids</code> is the original (larger) set.</p>
</td></tr>
<tr><td><code id="geno_last_gen_+3A_missing_vals">missing_vals</code></td>
<td>
<p>The list of ID values treated as missing.
<code>NA</code> is always treated as missing.
By default, the empty string (&rdquo;) and zero (0) are also treated as missing (remove values from here if this is a problem).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The random genotype matrix of the last generation (the intersection of <code>ids[ length(ids) ]</code> and <code>fam$id</code>).
The columns of this matrix are last-generation individuals in the order that they appear in <code>fam$id</code>.
The rows (loci) are the same as in the input <code>X</code>.
</p>


<h3>See Also</h3>

<p>Plink FAM format reference:
<a href="https://www.cog-genomics.org/plink/1.9/formats#fam">https://www.cog-genomics.org/plink/1.9/formats#fam</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A small pedigree, two parents and two children.
# A minimal fam table with the three required columns.
# Note "mother" and "father" have missing parent IDs, while children do not
library(tibble)
fam &lt;- tibble(
  id = c('father', 'mother', 'child', 'sib'),
  pat = c(NA, NA, 'father', 'father'),
  mat = c(NA, NA, 'mother', 'mother')
)
# need an `ids` list separating the generations
ids &lt;- list( c('father', 'mother'), c('child', 'sib') )

# genotypes of the parents at 4 loci
X &lt;- cbind( c(1, 2, 0, 2), c(0, 2, 2, 1) )
# Name the parents with same codes as in `fam`
# (order can be different)
colnames( X ) &lt;- c('mother', 'father')
# name loci too
rownames( X ) &lt;- paste0( 'rs', 1:4 )

# Draw the genotype matrix of the children
X2 &lt;- geno_last_gen( X, fam, ids )
X2

</code></pre>

<hr>
<h2 id='kinship_fam'>Calculate kinship matrix of a pedigree with structured founders</h2><span id='topic+kinship_fam'></span>

<h3>Description</h3>

<p>Calculates a full kinship matrix (between all individuals in the provided pedigree FAM table) taking into account the relatedness of the founders as provided.
Output agrees with <code><a href="kinship2.html#topic+kinship">kinship2::kinship()</a></code> but only when founders are unrelated/outbred (in other words, that function does not allow relatedness between founders).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kinship_fam(kinship, fam, missing_vals = c("", 0))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kinship_fam_+3A_kinship">kinship</code></td>
<td>
<p>The kinship matrix of the founders.
This matrix must have column and row names that identify each founder (matching codes in <code>fam$id</code>).
Individuals may be in a different order than <code>fam$id</code>.
Extra individuals in <code>kinship</code> but absent in <code>fam$id</code> will be silently ignored.
A traditional pedigree calculation would use <code>kinship = diag(n)/2</code> (plus appropriate column/row names), where <code>n</code> is the number of founders, to model unrelated and outbred founders.
However, if <code>kinship</code> measures the population kinship estimates between founders, the output is also a population kinship matrix (which combines the structural/ancestral and local/pedigree relatedness values into one).</p>
</td></tr>
<tr><td><code id="kinship_fam_+3A_fam">fam</code></td>
<td>
<p>The pedigree data.frame, in plink FAM format.
Only columns <code>id</code>, <code>pat</code>, and <code>mat</code> are required.
<code>id</code> must be unique and non-missing.
Founders must be present, and their <code>pat</code> and <code>mat</code> values must be missing (see below).
Non-founders must have both their parents be non-missing.
Parents must appear earlier than their children in the table.</p>
</td></tr>
<tr><td><code id="kinship_fam_+3A_missing_vals">missing_vals</code></td>
<td>
<p>The list of ID values treated as missing.
<code>NA</code> is always treated as missing.
By default, the empty string (&rdquo;) and zero (0) are also treated as missing (remove values from here if this is a problem).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The kinship matrix of the entire <code>fam</code> table, taking the relatedness of the founders into account.
The rows and columns of this kinship matrix correspond to <code>fam$id</code> in that order.
</p>


<h3>See Also</h3>

<p>Plink FAM format reference:
<a href="https://www.cog-genomics.org/plink/1.9/formats#fam">https://www.cog-genomics.org/plink/1.9/formats#fam</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The smallest pedigree, two parents and a child.
# A minimal fam table with the three required columns.
# Note "mother" and "father" have missing parent IDs, while "child" does not
library(tibble)
fam &lt;- tibble(
  id = c('father', 'mother', 'child'),
  pat = c(NA, NA, 'father'),
  mat = c(NA, NA, 'mother')
)

# Kinship of the parents, here two unrelated/outbred individuals:
kinship &lt;- diag(2)/2
# Name the parents with same codes as in `fam`
# (order can be different)
colnames( kinship ) &lt;- c('mother', 'father')
rownames( kinship ) &lt;- c('mother', 'father')
# For a clearer example, make the father slightly inbred
# (a self-kinship value that exceeds 1/2):
kinship[2,2] &lt;- 0.6

# Calculate the full kinship matrix
kinship_all &lt;- kinship_fam( kinship, fam )

# This is a 3x3 matrix with row/col names matching fam$id.
# The parent submatrix equals the input (reordered),
# but now there's relatedness to the child too
kinship_all

</code></pre>

<hr>
<h2 id='kinship_last_gen'>Calculate kinship matrix for last generation of a pedigree with structured founders</h2><span id='topic+kinship_last_gen'></span>

<h3>Description</h3>

<p>A wrapper around the more general <code><a href="#topic+kinship_fam">kinship_fam()</a></code>, specialized to save memory when only the last generation is desired (<code><a href="#topic+kinship_fam">kinship_fam()</a></code> returns kinship for the entire pedigree in a single matrix).
This function assumes that generations are non-overlapping (met by the output of <code><a href="#topic+sim_pedigree">sim_pedigree()</a></code>), in which case each generation <code>g</code> can be drawn from generation <code>g-1</code> data only.
That way, only two consecutive generations need be in memory at any given time.
The partitioning of individuals into generations is given by the <code>ids</code> parameter (again matches the output of <code><a href="#topic+sim_pedigree">sim_pedigree()</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kinship_last_gen(kinship, fam, ids, missing_vals = c("", 0))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kinship_last_gen_+3A_kinship">kinship</code></td>
<td>
<p>The kinship matrix of the founders.
This matrix must have column and row names that identify each founder (matching codes in <code>fam$id</code>).
Individuals may be in a different order than <code>fam$id</code>.
Extra individuals in <code>kinship</code> but absent in <code>fam$id</code> will be silently ignored.
A traditional pedigree calculation would use <code>kinship = diag(n)/2</code> (plus appropriate column/row names), where <code>n</code> is the number of founders, to model unrelated and outbred founders.
However, if <code>kinship</code> measures the population kinship estimates between founders, the output is also a population kinship matrix (which combines the structural/ancestral and local/pedigree relatedness values into one).</p>
</td></tr>
<tr><td><code id="kinship_last_gen_+3A_fam">fam</code></td>
<td>
<p>The pedigree data.frame, in plink FAM format.
Only columns <code>id</code>, <code>pat</code>, and <code>mat</code> are required.
<code>id</code> must be unique and non-missing.
Founders must be present, and their <code>pat</code> and <code>mat</code> values must be missing (see below).
Non-founders must have both their parents be non-missing.
Parents must appear earlier than their children in the table.</p>
</td></tr>
<tr><td><code id="kinship_last_gen_+3A_ids">ids</code></td>
<td>
<p>A list containing vectors of IDs for each generation.
All these IDs must be present in <code>fam$id</code>.
If IDs in <code>fam</code> and <code>ids</code> do not fully agree, the code processes the IDs in the intersection, which is helpful when <code>fam</code> is pruned but <code>ids</code> is the original (larger) set.</p>
</td></tr>
<tr><td><code id="kinship_last_gen_+3A_missing_vals">missing_vals</code></td>
<td>
<p>The list of ID values treated as missing.
<code>NA</code> is always treated as missing.
By default, the empty string (&rdquo;) and zero (0) are also treated as missing (remove values from here if this is a problem).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The kinship matrix of the last generation (the intersection of <code>ids[ length(ids) ]</code> and <code>fam$id</code>).
The columns/rows of this matrix are last-generation individuals in the order that they appear in <code>fam$id</code>.
</p>


<h3>See Also</h3>

<p>Plink FAM format reference:
<a href="https://www.cog-genomics.org/plink/1.9/formats#fam">https://www.cog-genomics.org/plink/1.9/formats#fam</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A small pedigree, two parents and two children.
# A minimal fam table with the three required columns.
# Note "mother" and "father" have missing parent IDs, while children do not
library(tibble)
fam &lt;- tibble(
  id = c('father', 'mother', 'child', 'sib'),
  pat = c(NA, NA, 'father', 'father'),
  mat = c(NA, NA, 'mother', 'mother')
)
# need an `ids` list separating the generations
ids &lt;- list( c('father', 'mother'), c('child', 'sib') )

# Kinship of the parents, here two unrelated/outbred individuals:
kinship &lt;- diag(2)/2
# Name the parents with same codes as in `fam`
# (order can be different)
colnames( kinship ) &lt;- c('mother', 'father')
rownames( kinship ) &lt;- c('mother', 'father')
# For a clearer example, make the father slightly inbred
# (a self-kinship value that exceeds 1/2):
kinship[2,2] &lt;- 0.6

# calculate the kinship matrix of the children
kinship2 &lt;- kinship_last_gen( kinship, fam, ids )
kinship2

</code></pre>

<hr>
<h2 id='prune_fam'>Remove non-ancestors of a set of individuals from pedigree</h2><span id='topic+prune_fam'></span>

<h3>Description</h3>

<p>This function accepts an input pedigree and a list of individuals of interest, and returns the subset of the pedigree including only the individuals of interest and their direct ancestors.
This is useful in simulations, to avoid modeling/drawing genotypes of individuals without descendants in the last generation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prune_fam(fam, ids, missing_vals = c("", 0))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prune_fam_+3A_fam">fam</code></td>
<td>
<p>The pedigree data.frame, in plink FAM format.
Only columns <code>id</code>, <code>pat</code>, and <code>mat</code> are required.
<code>id</code> must be unique and non-missing.
Founders must be present, and their <code>pat</code> and <code>mat</code> values must be missing (see below).
Non-founders must have both their parents be non-missing.
Parents must appear earlier than their children in the table.</p>
</td></tr>
<tr><td><code id="prune_fam_+3A_ids">ids</code></td>
<td>
<p>The list of individuals of interest, whose ancestors we want to keep.
All must be present in <code>fam$id</code>.</p>
</td></tr>
<tr><td><code id="prune_fam_+3A_missing_vals">missing_vals</code></td>
<td>
<p>The list of ID values treated as missing.
<code>NA</code> is always treated as missing.
By default, the empty string (&rdquo;) and zero (0) are also treated as missing (remove values from here if this is a problem).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The filtered FAM table with non-ancestors of <code>ids</code> excluded.
IDs that are <code>NA</code>-equivalent (see <code>missing_vals</code>) will be mapped to <code>NA</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># construct a family with three founders, but one "bob" has no descendants
library(tibble)
fam &lt;- tibble(
    id  = c('mom', 'dad', 'bob', 'child'),
    pat = c(   NA,    NA,    NA,   'dad'),
    mat = c(   NA,    NA,    NA,   'mom')
)
# only want 'child' and its ancestors
ids &lt;- 'child'
fam2 &lt;- prune_fam( fam, ids )
# the filtered pedigree has "bob" removed:
fam2

</code></pre>

<hr>
<h2 id='recomb_admix_inds'>Reduce haplotype ancestry data to population ancestry dosage matrices</h2><span id='topic+recomb_admix_inds'></span>

<h3>Description</h3>

<p>This function accepts haplotype data, such as the output from <code><a href="#topic+recomb_haplo_inds">recomb_haplo_inds()</a></code> with <code>ret_anc = TRUE</code> (required), and reduces it to a list of population ancestry dosage matrices.
In this context, &quot;ancestors/ancestry&quot; refer to haplotype blocks from specific ancestor individuals, whereas &quot;population ancestry&quot; groups these ancestors into populations (such as African, European, etc.).
Although the haplotype data separates individuals and chromosomes into lists (the way it is simulated), the output matrices concatenates data from all chromosomes into a single matrix, as it appears in simpler simulations and real data, and matching the format of <code><a href="#topic+recomb_geno_inds">recomb_geno_inds()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recomb_admix_inds(haplos, anc_map, pops = sort(unique(anc_map$pop)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recomb_admix_inds_+3A_haplos">haplos</code></td>
<td>
<p>A list of diploid individuals, each of which is a list with two haploid individuals named <code>pat</code> and <code>mat</code>, each of which is a list of chromosomes, each of which must be a list with a named element <code>anc</code> must give the vector of ancestor names per position (the output format from <code><a href="#topic+recomb_haplo_inds">recomb_haplo_inds()</a></code> with <code>ret_anc = TRUE</code>).</p>
</td></tr>
<tr><td><code id="recomb_admix_inds_+3A_anc_map">anc_map</code></td>
<td>
<p>A data.frame or tibble with two columns: <code>anc</code> lists every ancestor haplotype name present in <code>haplos</code>, and <code>pop</code> the population assignment of that haplotype.</p>
</td></tr>
<tr><td><code id="recomb_admix_inds_+3A_pops">pops</code></td>
<td>
<p>Optional order of populations in output, by default sorted alphabetically from <code>anc_map$pop</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of population ancestry dosage matrices, ordered as in <code>pops</code>, each of which counts populations in both alleles (in 0, 1, 2), with individuals along columns in same order as <code>haplos</code> list, and loci along rows in order of appearance concatenating chromosomes in numerical order.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+recomb_fam">recomb_fam()</a></code> for drawing recombination (ancestor) blocks, defined in terms of genetic distance.
</p>
<p><code><a href="#topic+recomb_map_inds">recomb_map_inds()</a></code> for transforming genetic to basepair coordinates given a genetic map.
</p>
<p><code><a href="#topic+recomb_haplo_inds">recomb_haplo_inds()</a></code> for determining haplotypes of descendants given ancestral haplotypes (creates input to this function).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Lengthy code creates individuals with recombination data to map
# The smallest pedigree, two parents and a child (minimal fam table).
library(tibble)
fam &lt;- tibble(
  id = c('father', 'mother', 'child'),
  pat = c(NA, NA, 'father'),
  mat = c(NA, NA, 'mother')
)
# use latest human recombination map, but just first two chrs to keep this example fast
map &lt;- recomb_map_hg38[ 1L:2L ]
# initialize parents with this other function
founders &lt;- recomb_init_founders( c('father', 'mother'), map )
# draw recombination breaks for child
inds &lt;- recomb_fam( founders, fam )
# now add base pair coordinates to recombination breaks
inds &lt;- recomb_map_inds( inds, map )

# also need ancestral haplotypes
# these should be simulated carefully as needed, but for this example we make random data
haplo &lt;- vector( 'list', length( map ) )
# names of ancestor haplotypes for this scenario
# (founders of fam$id but each with "_pat" and "_mat" suffixes)
anc_names &lt;- c( 'father_pat', 'father_mat', 'mother_pat', 'mother_mat' )
n_ind &lt;- length( anc_names )
# number of loci per chr, for toy test
m_loci &lt;- 10L
for ( chr in 1L : length( map ) ) {
    # draw random positions
    pos_chr &lt;- sample.int( max( map[[ chr ]]$pos ), m_loci )
    # draw haplotypes
    X_chr &lt;- matrix(
        rbinom( m_loci * n_ind, 1L, 0.5 ),
        nrow = m_loci,
        ncol = n_ind
    )
    # required column names!
    colnames( X_chr ) &lt;- anc_names
    # add to structure, in a list
    haplo[[ chr ]] &lt;- list( X = X_chr, pos = pos_chr )
}
# determine haplotypes and per-position ancestries of descendants given ancestral haplotypes
haplos &lt;- recomb_haplo_inds( inds, haplo, ret_anc = TRUE )

# define individual to population ancestry map
# take four ancestral haplotypes from above, assign them population labels
anc_map &lt;- tibble(
    anc = anc_names,
    pop = c('African', 'European', 'African', 'African')
)

# finally, run desired function!
# convert haplotypes structure to list of population ancestry dosage matrices
Xs &lt;- recomb_admix_inds( haplos, anc_map )

</code></pre>

<hr>
<h2 id='recomb_fam'>Draw recombination breaks for autosomes from a pedigree</h2><span id='topic+recomb_fam'></span>

<h3>Description</h3>

<p>Create random recombination breaks for all autosomes of all individuals in the provided pedigree FAM table.
Recombination lengths follow an exponential distribution with mean of 100 centiMorgans (cM).
The output specifies identical-by-descent (IBD) blocks as ranges per chromosome (per individual) and the founder chromosome they arose from (are IBD with).
All calculations are in terms of genetic distance (not base pairs), and no genotypes are constructed/drawn in this step.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recomb_fam(founders, fam, missing_vals = c("", 0))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recomb_fam_+3A_founders">founders</code></td>
<td>
<p>The named list of founders with their chromosomes.
For unstructured founders, initialize with <code><a href="#topic+recomb_init_founders">recomb_init_founders()</a></code>.
Each element of this list is a diploid individual, which is a list with two haploid individuals named <code>pat</code> and <code>mat</code>, each of which is a list of chromosomes (always identified by number, but may also be named arbitrarily), each of which is a data.frame/tibble with implicit ranges (<code>posg</code> is end coordinates in cM; start is the end of the previous block, zero for the first block) and ancestors <code>anc</code> as strings.
For true founders each chromosome may be trivial (each chromosome is a single block with ID equal to itself but distinguishing maternal from paternal copy), but input itself can be recombined (for iterating).
This list must have names that identify each founder (matching codes in <code>fam$id</code>).
Individuals may be in a different order than <code>fam$id</code>.
Extra individuals in <code>founders</code> but absent in <code>fam$id</code> will be silently ignored.</p>
</td></tr>
<tr><td><code id="recomb_fam_+3A_fam">fam</code></td>
<td>
<p>The pedigree data.frame, in plink FAM format.
Only columns <code>id</code>, <code>pat</code>, and <code>mat</code> are required.
<code>id</code> must be unique and non-missing.
Founders must be present, and their <code>pat</code> and <code>mat</code> values must be missing (see below).
Non-founders must have both their parents be non-missing.
Parents must appear earlier than their children in the table.</p>
</td></tr>
<tr><td><code id="recomb_fam_+3A_missing_vals">missing_vals</code></td>
<td>
<p>The list of ID values treated as missing.
<code>NA</code> is always treated as missing.
By default, the empty string (&rdquo;) and zero (0) are also treated as missing (remove values from here if this is a problem).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The list of individuals with recombined chromosomes of the entire <code>fam</code> table, in the same format as <code>founders</code> above.
The names of this list correspond to <code>fam$id</code> in that order.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+recomb_init_founders">recomb_init_founders()</a></code> to initialize <code>founders</code> for this function.
</p>
<p>Plink FAM format reference:
<a href="https://www.cog-genomics.org/plink/1.9/formats#fam">https://www.cog-genomics.org/plink/1.9/formats#fam</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The smallest pedigree, two parents and a child.
# A minimal fam table with the three required columns.
# Note "mother" and "father" have missing parent IDs, while "child" does not
library(tibble)
fam &lt;- tibble(
  id = c('father', 'mother', 'child'),
  pat = c(NA, NA, 'father'),
  mat = c(NA, NA, 'mother')
)

# initialize parents with this other function
# Name the parents with same codes as in `fam`
# (order can be different)
ids &lt;- c('mother', 'father')
# simulate three chromosomes with these lengths in cM
lengs &lt;- c(50, 100, 150)
founders &lt;- recomb_init_founders( ids, lengs )

# draw recombination breaks for the whole fam table now:
inds &lt;- recomb_fam( founders, fam )

# This is a length-3 list with names matching fam$id.
# The parent data equals the input (reordered),
# but now there's data to the child too
inds

</code></pre>

<hr>
<h2 id='recomb_geno_inds'>Reduce haplotype data to genotype matrix</h2><span id='topic+recomb_geno_inds'></span>

<h3>Description</h3>

<p>This function accepts haplotype data, such as the output from <code><a href="#topic+recomb_haplo_inds">recomb_haplo_inds()</a></code>, and reduces it to a genotype matrix.
The haplotype data is more detailed because it is phased, while phase is lost in the genotype representation.
Moreover, the haplotype data separates individuals and chromosomes into lists (the way it is simulated), but the output genotype matrix concatenates data from all chromosomes into a single matrix, as it appears in simpler simulations and real data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recomb_geno_inds(haplos)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recomb_geno_inds_+3A_haplos">haplos</code></td>
<td>
<p>A list of diploid individuals, each of which is a list with two haploid individuals named &quot;pat&quot; and &quot;mat&quot;, each of which is a list of chromosomes.
Each chromosome can be a list, in which case the named element &quot;x&quot; must give the haplotype vector (ideally with values in zero and one counting reference alleles, including NA), otherwise the chromosome must be this vector (accommodating both output formats from <code><a href="#topic+recomb_haplo_inds">recomb_haplo_inds()</a></code> automatically).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The genotype matrix, which is the sum of the haplotype values (with values in 0, 1, 2, and NA, counting reference alleles), with individuals along columns in same order as <code>haplos</code> list, and loci along rows in order of appearance concatenating chromosomes in numerical order.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+recomb_fam">recomb_fam()</a></code> for drawing recombination (ancestor) blocks, defined in terms of genetic distance.
</p>
<p><code><a href="#topic+recomb_map_inds">recomb_map_inds()</a></code> for transforming genetic to basepair coordinates given a genetic map.
</p>
<p><code><a href="#topic+recomb_haplo_inds">recomb_haplo_inds()</a></code> for determining haplotypes of descendants given ancestral haplotypes (creates input to this function).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Lengthy code creates individuals with recombination data to map
# The smallest pedigree, two parents and a child (minimal fam table).
library(tibble)
fam &lt;- tibble(
  id = c('father', 'mother', 'child'),
  pat = c(NA, NA, 'father'),
  mat = c(NA, NA, 'mother')
)
# use latest human recombination map, but just first two chrs to keep this example fast
map &lt;- recomb_map_hg38[ 1L:2L ]
# initialize parents with this other function
founders &lt;- recomb_init_founders( c('father', 'mother'), map )
# draw recombination breaks for child
inds &lt;- recomb_fam( founders, fam )
# now add base pair coordinates to recombination breaks
inds &lt;- recomb_map_inds( inds, map )

# also need ancestral haplotypes
# these should be simulated carefully as needed, but for this example we make random data
haplo &lt;- vector( 'list', length( map ) )
# names of ancestor haplotypes for this scenario
# (founders of fam$id but each with "_pat" and "_mat" suffixes)
anc_names &lt;- c( 'father_pat', 'father_mat', 'mother_pat', 'mother_mat' )
n_ind &lt;- length( anc_names )
# number of loci per chr, for toy test
m_loci &lt;- 10L
for ( chr in 1L : length( map ) ) {
    # draw random positions
    pos_chr &lt;- sample.int( max( map[[ chr ]]$pos ), m_loci )
    # draw haplotypes
    X_chr &lt;- matrix(
        rbinom( m_loci * n_ind, 1L, 0.5 ),
        nrow = m_loci,
        ncol = n_ind
    )
    # required column names!
    colnames( X_chr ) &lt;- anc_names
    # add to structure, in a list
    haplo[[ chr ]] &lt;- list( X = X_chr, pos = pos_chr )
}
# determine haplotypes of descendants given ancestral haplotypes
haplos &lt;- recomb_haplo_inds( inds, haplo )

# finally, run desired function!
# convert haplotypes structure to a plain genotype matrix
X &lt;- recomb_geno_inds( haplos )

</code></pre>

<hr>
<h2 id='recomb_haplo_inds'>Construct haplotypes of individuals given their ancestral blocks and the ancestral haplotype variants</h2><span id='topic+recomb_haplo_inds'></span>

<h3>Description</h3>

<p>Construct haplotypes of individuals given their ancestral blocks and the ancestral haplotype variants
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recomb_haplo_inds(inds, haplo, ret_anc = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recomb_haplo_inds_+3A_inds">inds</code></td>
<td>
<p>A list of individuals in the same format as the output of <code><a href="#topic+recomb_fam">recomb_fam()</a></code> after being processed with <code><a href="#topic+recomb_map_inds">recomb_map_inds()</a></code>.
More specifically, each individual is a list with two haploid individuals named <code>pat</code> and <code>mat</code>, each of which is a list of chromosomes (always identified by number, but may also be named arbitrarily), each of which is a data.frame/tibble with implicit ranges (<code>pos</code> is end coordinates in base pairs; start is the end of the previous block plus one, 1 for the first block) and ancestors <code>anc</code> as strings.</p>
</td></tr>
<tr><td><code id="recomb_haplo_inds_+3A_haplo">haplo</code></td>
<td>
<p>The ancestral haplotypes, which is a list of chromosomes, each of which is a list with two named elements: <code>X</code> is a matrix of haplotype markers (loci along rows, ancestral individuals along columns, which must be named as in <code>anc</code> strings in <code>inds</code> above), and <code>pos</code> is a vector of locus positions in base pair coordinates.</p>
</td></tr>
<tr><td><code id="recomb_haplo_inds_+3A_ret_anc">ret_anc</code></td>
<td>
<p>If <code>TRUE</code>, returns local ancestries (per position) along with haplotypes, otherwise only haplotypes are returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of diploid individuals, each of which is a list with two haploid individuals named <code>pat</code> and <code>mat</code>, each of which is a list of chromosomes.
If <code>ret_anc = FALSE</code> (default), each chromosome is a haplotype (vector of values copied from ancestors in <code>haplo</code>);
if <code>ret_anc = TRUE</code>, each chromosome is a list with named elements <code>x</code> for the haplotype vector and <code>anc</code> for the vector of ancestor name per position.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+recomb_fam">recomb_fam()</a></code> for drawing recombination (ancestor) blocks, defined in terms of genetic distance.
</p>
<p><code><a href="#topic+recomb_map_inds">recomb_map_inds()</a></code> for transforming genetic to basepair coordinates given a genetic map.
</p>
<p><code><a href="#topic+recomb_geno_inds">recomb_geno_inds()</a></code> for transforming the output of this function from haplotypes (a nested lists structure) to a plain genotype matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Lengthy code creates individuals with recombination data to map
# The smallest pedigree, two parents and a child (minimal fam table).
library(tibble)
fam &lt;- tibble(
  id = c('father', 'mother', 'child'),
  pat = c(NA, NA, 'father'),
  mat = c(NA, NA, 'mother')
)
# use latest human recombination map, but just first two chrs to keep this example fast
map &lt;- recomb_map_hg38[ 1L:2L ]
# initialize parents with this other function
founders &lt;- recomb_init_founders( c('father', 'mother'), map )
# draw recombination breaks for child
inds &lt;- recomb_fam( founders, fam )
# now add base pair coordinates to recombination breaks
inds &lt;- recomb_map_inds( inds, map )

# also need ancestral haplotypes
# these should be simulated carefully as needed, but for this example we make random data
haplo &lt;- vector( 'list', length( map ) )
# names of ancestor haplotypes for this scenario
# (founders of fam$id but each with "_pat" and "_mat" suffixes)
anc_names &lt;- c( 'father_pat', 'father_mat', 'mother_pat', 'mother_mat' )
n_ind &lt;- length( anc_names )
# number of loci per chr, for toy test
m_loci &lt;- 10L
for ( chr in 1L : length( map ) ) {
    # draw random positions
    pos_chr &lt;- sample.int( max( map[[ chr ]]$pos ), m_loci )
    # draw haplotypes
    X_chr &lt;- matrix(
        rbinom( m_loci * n_ind, 1L, 0.5 ),
        nrow = m_loci,
        ncol = n_ind
    )
    # required column names!
    colnames( X_chr ) &lt;- anc_names
    # add to structure, in a list
    haplo[[ chr ]] &lt;- list( X = X_chr, pos = pos_chr )
}

# finally, run desired function!
# determine haplotypes of descendants given ancestral haplotypes
data &lt;- recomb_haplo_inds( inds, haplo )


</code></pre>

<hr>
<h2 id='recomb_init_founders'>Initialize chromosome structures for founders</h2><span id='topic+recomb_init_founders'></span>

<h3>Description</h3>

<p>This function initializes what is otherwise a tedious structure for founders, to be used for simulating recombination in a pedigree.
The genetic structure is trivial, in that these &quot;founder&quot; chromosomes are each of a single ancestral individual (none are recombined).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recomb_init_founders(ids, lengs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recomb_init_founders_+3A_ids">ids</code></td>
<td>
<p>The list of IDs to use for each individual</p>
</td></tr>
<tr><td><code id="recomb_init_founders_+3A_lengs">lengs</code></td>
<td>
<p>The lengths of each chromosome in centiMorgans (cM).
If this vector is named, the output inherits these chromosome names.
If it is a list, it is assumed to be a recombination map (see <code><a href="#topic+recomb_map_hg">recomb_map_hg</a></code> for examples) and the desired lengths extracted automatically (taken as the last value of column <code>posg</code> of each chromosome).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of diploid individuals, each of which is a list with two haploid individuals named <code>pat</code> and <code>mat</code>, each of which is a list of chromosomes (inherits names of <code>lengs</code> if present), each of which is a tibble with a single row and two columns: <code>posg</code> equals the chromosome length, and <code>anc</code> equals the ID of the individual (from <code>ids</code>) concatenated with either <code style="white-space: pre;">&#8288;_pat&#8288;</code> or <code style="white-space: pre;">&#8288;_mat&#8288;</code> depending on which parent it is.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+recomb_fam">recomb_fam()</a></code> to simulate recombination across a pedigree using the founders initialized here.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># version with explicit recombination lengths
ancs &lt;- recomb_init_founders( c('a', 'b'), c(100, 200) )
ancs

# version using genetic map (uses provided human map) from which lengths are extracted
ancs &lt;- recomb_init_founders( c('a', 'b'), recomb_map_hg38 )
ancs

</code></pre>

<hr>
<h2 id='recomb_last_gen'>Draw recombination breaks for autosomes for last generation of a pedigree</h2><span id='topic+recomb_last_gen'></span>

<h3>Description</h3>

<p>A wrapper around the more general <code><a href="#topic+recomb_fam">recomb_fam()</a></code>, specialized to save memory when only the last generation is desired (<code><a href="#topic+recomb_fam">recomb_fam()</a></code> returns recombination blocks for the entire pedigree).
This function assumes that generations are non-overlapping (met by the output of <code><a href="#topic+sim_pedigree">sim_pedigree()</a></code>), in which case each generation <code>g</code> can be drawn from generation <code>g-1</code> data only.
That way, only two consecutive generations need be in memory at any given time.
The partitioning of individuals into generations is given by the <code>ids</code> parameter (again matches the output of <code><a href="#topic+sim_pedigree">sim_pedigree()</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recomb_last_gen(founders, fam, ids, missing_vals = c("", 0))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recomb_last_gen_+3A_founders">founders</code></td>
<td>
<p>The named list of founders with their chromosomes.
For unstructured founders, initialize with <code><a href="#topic+recomb_init_founders">recomb_init_founders()</a></code>.
Each element of this list is a diploid individual, which is a list with two haploid individuals named <code>pat</code> and <code>mat</code>, each of which is a list of chromosomes (always identified by number, but may also be named arbitrarily), each of which is a data.frame/tibble with implicit ranges (<code>posg</code> is end coordinates in cM; start is the end of the previous block, zero for the first block) and ancestors <code>anc</code> as strings.
For true founders each chromosome may be trivial (each chromosome is a single block with ID equal to itself but distinguishing maternal from paternal copy), but input itself can be recombined (for iterating).
This list must have names that identify each founder (matching codes in <code>fam$id</code>).
Individuals may be in a different order than <code>fam$id</code>.
Extra individuals in <code>founders</code> but absent in <code>fam$id</code> will be silently ignored.</p>
</td></tr>
<tr><td><code id="recomb_last_gen_+3A_fam">fam</code></td>
<td>
<p>The pedigree data.frame, in plink FAM format.
Only columns <code>id</code>, <code>pat</code>, and <code>mat</code> are required.
<code>id</code> must be unique and non-missing.
Founders must be present, and their <code>pat</code> and <code>mat</code> values must be missing (see below).
Non-founders must have both their parents be non-missing.
Parents must appear earlier than their children in the table.</p>
</td></tr>
<tr><td><code id="recomb_last_gen_+3A_ids">ids</code></td>
<td>
<p>A list containing vectors of IDs for each generation.
All these IDs must be present in <code>fam$id</code>.
If IDs in <code>fam</code> and <code>ids</code> do not fully agree, the code processes the IDs in the intersection, which is helpful when <code>fam</code> is pruned but <code>ids</code> is the original (larger) set.</p>
</td></tr>
<tr><td><code id="recomb_last_gen_+3A_missing_vals">missing_vals</code></td>
<td>
<p>The list of ID values treated as missing.
<code>NA</code> is always treated as missing.
By default, the empty string (&rdquo;) and zero (0) are also treated as missing (remove values from here if this is a problem).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The list of individuals with recombined chromosomes of the last generation (the intersection of <code>ids[ length(ids) ]</code> and <code>fam$id</code>), in the same format as <code>founders</code> above.
The names of this list are last-generation individuals in the order that they appear in <code>fam$id</code>.
</p>


<h3>See Also</h3>

<p>Plink FAM format reference:
<a href="https://www.cog-genomics.org/plink/1.9/formats#fam">https://www.cog-genomics.org/plink/1.9/formats#fam</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A small pedigree, two parents and two children.
# A minimal fam table with the three required columns.
# Note "mother" and "father" have missing parent IDs, while children do not
library(tibble)
fam &lt;- tibble(
  id = c('father', 'mother', 'child', 'sib'),
  pat = c(NA, NA, 'father', 'father'),
  mat = c(NA, NA, 'mother', 'mother')
)
# need an `ids` list separating the generations
ids &lt;- list( c('father', 'mother'), c('child', 'sib') )

# initialize parents with this other function
# simulate three chromosomes with these lengths in cM
lengs &lt;- c(50, 100, 150)
founders &lt;- recomb_init_founders( ids[[1]], lengs )

# draw recombination breaks for the children
inds &lt;- recomb_last_gen( founders, fam, ids )

</code></pre>

<hr>
<h2 id='recomb_map_fix_ends_chr'>Extrapolate and shift recombination map of one chromosome to ends</h2><span id='topic+recomb_map_fix_ends_chr'></span>

<h3>Description</h3>

<p>Given an existing recombination map and a chromosome length in base pairs, extrapolates the map to ensure all positions are covered, and shifts to ensure position one in basepairs corresponds to position 0 in genetic position.
Recombination rates are extrapolated from the first and last 10Mb of data by default (separately per end).
Therefore fixes the fact that common maps start genetic position zero at base pair position <code style="white-space: pre;">&#8288;&gt;&gt; 1&#8288;</code> and do not extend to ends (some SNPs from modern projects fall out of range without fixes).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recomb_map_fix_ends_chr(map, pos_length, pos_delta = 10000000L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recomb_map_fix_ends_chr_+3A_map">map</code></td>
<td>
<p>A tibble with two columns: <code>pos</code> position in base pairs, and <code>posg</code> position in centiMorgans (cM).</p>
</td></tr>
<tr><td><code id="recomb_map_fix_ends_chr_+3A_pos_length">pos_length</code></td>
<td>
<p>The length of the chromosome in base pairs.</p>
</td></tr>
<tr><td><code id="recomb_map_fix_ends_chr_+3A_pos_delta">pos_delta</code></td>
<td>
<p>The size of the window used to extrapolate recombination rates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The extrapolated recombination map, shifted so the first non-trivial position maps to the genetic distance expected from the extrapolated rate at the beginning, then added a first trivial position (<code style="white-space: pre;">&#8288;pos=1, posg=0&#8288;</code>) and final basepair position at length of chromosome and expected genetic position from end extrapolation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+recomb_map_simplify_chr">recomb_map_simplify_chr()</a></code> to simplify recombination maps to a desired numerical accuracy.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)
# create a toy recombination map with at least 10Mb at each end
map &lt;- tibble(
    pos  = c( 3L,  15L, 100L, 120L ) * 1e6L,
    posg = c(  0, 10.4, 90.1,  110 )
)
# and length
pos_length &lt;- 150L * 1e6L

# apply function!
map_fixed &lt;- recomb_map_fix_ends_chr( map, pos_length )
# inspect
map_fixed

</code></pre>

<hr>
<h2 id='recomb_map_hg'>Simplified recombination maps for human genomes</h2><span id='topic+recomb_map_hg'></span><span id='topic+recomb_map_hg38'></span><span id='topic+recomb_map_hg37'></span>

<h3>Description</h3>

<p>Human genetic recombination maps for builds 38 (GRCh38/hg38) and 37 (GRCh37/hg19, below suffixed as hg37 for simplicity although technically incorrect).
Processed each first with <code><a href="#topic+recomb_map_fix_ends_chr">recomb_map_fix_ends_chr()</a></code> to shift and extrapolate to sequence ends, then simplified with <code><a href="#topic+recomb_map_simplify_chr">recomb_map_simplify_chr()</a></code> to remove all values that can be extrapolated with an error of up to <code>tol = 0.1</code>, in order to reduce their sizes and interpolation runtime.
Defaults were used, which resulted in extrapolated recombination rates close to and centered around the average of 1e-6 cM/base).
Autosomes only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recomb_map_hg38

recomb_map_hg37
</code></pre>


<h3>Format</h3>

<p>A list with 22 elements (autosomes, not named), each a tibble with two columns defining the recombination map at that chromosome:
</p>

<ul>
<li> <p><code>pos</code>: position in base pairs
</p>
</li>
<li> <p><code>posg</code>: position in centiMorgans (cM)
</p>
</li></ul>

<p>An object of class <code>list</code> of length 22.
</p>


<h3>Source</h3>

<p>Raw genetic maps downloaded from this location prior to above processing:
<a href="https://bochet.gcc.biostat.washington.edu/beagle/genetic_maps/">https://bochet.gcc.biostat.washington.edu/beagle/genetic_maps/</a>
</p>
<p>Chromosome lengths from:
<a href="https://www.ncbi.nlm.nih.gov/grc/human/data">https://www.ncbi.nlm.nih.gov/grc/human/data</a>
</p>

<hr>
<h2 id='recomb_map_inds'>Map recombination breaks from genetic positions to base pair coordinates</h2><span id='topic+recomb_map_inds'></span>

<h3>Description</h3>

<p>Given a list of individuals with recombination breaks given in genetic distance (such as the output of <code><a href="#topic+recomb_fam">recomb_fam()</a></code>), and a genetic map (see <code><a href="#topic+recomb_map_hg">recomb_map_hg</a></code>), this function determines all positions in base pair coordinates.
If base pair positions existed in input, they are overwritten.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recomb_map_inds(inds, map)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recomb_map_inds_+3A_inds">inds</code></td>
<td>
<p>The list of individuals, each of which is a list with two haploid individuals named <code>pat</code> and <code>mat</code>, each of which is a list of chromosomes (always identified by number, but may also be named arbitrarily), each of which is a data.frame/tibble with implicit ranges (<code>posg</code> is end coordinates in cM; start is the end of the previous block, zero for the first block) and ancestors <code>anc</code> as strings.</p>
</td></tr>
<tr><td><code id="recomb_map_inds_+3A_map">map</code></td>
<td>
<p>The genetic map, a list of chromosomes each of which is a data.frame/tibble with columns <code>pos</code> for base pair position and <code>posg</code> for genetic position.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Genetic positions are converted to base pair positions from the provided map using linear interpolation, using <code><a href="stats.html#topic+approxfun">stats::approx()</a></code> with options <code>rule = 2</code> (out of range cases are set to nearest end's value) and <code>ties = list( 'ordered', mean )</code> (assume data is ordered, interpolate ties in genetic distance in map using mean of base pair positions).
Output will be incorrect, without throwing errors, if genetic map is not ordered.
Base pair positions are rounded to integers.
</p>


<h3>Value</h3>

<p>The input list of individuals, with each chromosome added column <code>pos</code> corresponding to end coordinate in base pairs.
Each chromosome has columns reordered so <code>pos</code>, <code>posg</code>, and <code>anc</code> appear first, and any additional columns appear afterwards.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+recomb_fam">recomb_fam()</a></code> for drawing recombination breaks of individuals from a pedigree.
</p>
<p><code><a href="#topic+recomb_map_hg">recomb_map_hg</a></code> for simplified human recombination maps included in this package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Lengthy code creates individuals with recombination data to map
# The smallest pedigree, two parents and a child (minimal fam table).
library(tibble)
fam &lt;- tibble(
  id = c('father', 'mother', 'child'),
  pat = c(NA, NA, 'father'),
  mat = c(NA, NA, 'mother')
)
# use latest human recombination map, but just first two chrs to keep this example fast
map &lt;- recomb_map_hg38[ 1:2 ]
# initialize parents with this other function
founders &lt;- recomb_init_founders( c('father', 'mother'), map )
# draw recombination breaks for child
inds &lt;- recomb_fam( founders, fam )

# now use this function to add base pair coordinates for recombination breaks!
inds &lt;- recomb_map_inds( inds, map )

</code></pre>

<hr>
<h2 id='recomb_map_simplify_chr'>Simplify recombination map of one chromosome to a desired numerical precision</h2><span id='topic+recomb_map_simplify_chr'></span>

<h3>Description</h3>

<p>Given an input recombination map, this function iteratively removes rows that can be interpolated to less than a given error <code>tol</code>.
This is a heuristic that works very well in practice, resulting in average interpolation errors well below <code>tol</code>, and maximum final errors no greater than <code>3 * tol</code> in our internal benchmarks (expected in extremely concave or convex regions of the map; final errors are rarely above <code>tol</code> with few exceptions).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recomb_map_simplify_chr(map, tol = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recomb_map_simplify_chr_+3A_map">map</code></td>
<td>
<p>A tibble with two columns: <code>pos</code> position in base pairs, and <code>posg</code> position in centiMorgans (cM).</p>
</td></tr>
<tr><td><code id="recomb_map_simplify_chr_+3A_tol">tol</code></td>
<td>
<p>Tolerance of interpolation errors, in cM.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function reduces recombination map sizes drastically, in order to include them in packages, and also makes linear interpolation faster.
This simplification operation can be justified as the precision of many existing maps is both limited and overstated, and a high accuracy is not needed for simulations with many other approximations in place.
</p>


<h3>Value</h3>

<p>The recombination map with rows (positions) removed (if they are interpolated with errors below <code>tol</code> in most cases).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+recomb_map_fix_ends_chr">recomb_map_fix_ends_chr()</a></code> to shift and extrapolate recombination map to ends of chromosome.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)
# create a toy recombination map to simplify
# in this case all middle rows can be interpolated from the ends with practically no error
map &lt;- tibble(
    pos  = c(  1L, 1e6L, 2e6L, 3e6L ),
    posg = c( 0.0,  1.0,  2.0,  3.0 )
)

# simplify map!
map_simple &lt;- recomb_map_simplify_chr( map )
# inspect
map_simple

</code></pre>

<hr>
<h2 id='sim_pedigree'>Construct a random pedigree</h2><span id='topic+sim_pedigree'></span>

<h3>Description</h3>

<p>Specify the number of individuals per generation, and some other optional parameters, and a single pedigree with those properties will be simulated, where close relatives are never paired, sex is drawn randomly per individual and pairings are strictly across opposite-sex individuals, and otherwise closest individuals (on an underlying 1D geography given by their index) are paired in a random order.
Pairs are reordered based on the average of their indexes, where their children are placed (determines their indexes in the 1D geography).
The procedure may leave some individuals unpaired in the next generation, and family sizes vary randomly (with a fixed minimum family size) to achieve the desired population size in each generation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_pedigree(
  n,
  G = length(n),
  sex = draw_sex(n[1]),
  kinship_local = diag(n[1])/2,
  cutoff = 1/4^3,
  children_min = 1L,
  full = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_pedigree_+3A_n">n</code></td>
<td>
<p>The number of individuals per generation.
If scalar, the number of generations <code>G &gt;= 2</code> must also be specified.
Otherwise, the length of <code>n</code> is the number of generations.</p>
</td></tr>
<tr><td><code id="sim_pedigree_+3A_g">G</code></td>
<td>
<p>The number of generations (optional).
Note <code>G == 1</code> is founders only, so it is invalid (there is no pedigree).
Must specify a <code>G &gt;= 2</code> if <code>n</code> is a scalar.
If both <code>G</code> is specified and <code>length(n) &gt; 1</code>, both values must agree.</p>
</td></tr>
<tr><td><code id="sim_pedigree_+3A_sex">sex</code></td>
<td>
<p>The numeric sex values for the founders (1L for male, 2L for female).
By default they are drawn randomly using <code><a href="#topic+draw_sex">draw_sex()</a></code>.</p>
</td></tr>
<tr><td><code id="sim_pedigree_+3A_kinship_local">kinship_local</code></td>
<td>
<p>The local kinship matrix of the founder population.
The default value is half the identity matrix, which corresponds to locally unrelated and locally outbred founders.
This &quot;local&quot; kinship is the basis for all kinship calculations used to decide on close relative avoidance.
The goal is to make a decision to not pair close relatives based on the pedigree only (and not based on population structure, which otherwise increases all kinship values), so the default value is appropriate.</p>
</td></tr>
<tr><td><code id="sim_pedigree_+3A_cutoff">cutoff</code></td>
<td>
<p>Local kinship values strictly less than <code>cutoff</code> are required for pairs.
The default value of <code>1/4^3</code> corresponds to second cousins, so those and closer relatives are forbidden pairs (but a third cousin pair is allowed).</p>
</td></tr>
<tr><td><code id="sim_pedigree_+3A_children_min">children_min</code></td>
<td>
<p>The minimum number of children per family.
Must be 0 or larger, but not exceed the average number of children per family in each generation (varies depending on how many individuals were left unpaired, but this upper limit is approximately <code>2 * n[i] / n[i-1]</code> for generation <code>i</code>).
The number of children for each given family is first chosen as <code>children_min</code> plus a Poisson random variable with parameter equal to the mean number of children per family needed to achieve the desired population size (<code>n</code>) minus <code>children_min</code>.
As these numbers may not exactly equal the target population size, random families are incremented or decremented (respecting the minimum family size) by single counts until the target population size is met.</p>
</td></tr>
<tr><td><code id="sim_pedigree_+3A_full">full</code></td>
<td>
<p>If <code>TRUE</code>, part of the return object is a list of local kinship matrices for every generation.
If <code>FALSE</code> (default), only the local kinship matrix of the last generation is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with these named elements:
</p>

<ul>
<li> <p><code>fam</code>: the pedigree, a tibble in plink FAM format.  Following the column naming convention of the related <code>genio</code> package, it contains columns:
</p>

<ul>
<li> <p><code>fam</code>: Family ID, trivial &quot;fam1&quot; for all individuals
</p>
</li>
<li> <p><code>id</code>: Individual ID, in this case a code of format (in regular expression) &quot;(\d+)-(\d+)&quot; where the first integer is the generation number and the second integer is the index number (1 to <code>n[g]</code> for generation <code>g</code>).
</p>
</li>
<li> <p><code>pat</code>: Paternal ID.  Matches an <code>id</code> except for founders, which have fathers set to <code>NA</code>.
</p>
</li>
<li> <p><code>mat</code>: Maternal ID.  Matches an <code>id</code> except for founders, which have mothers set to <code>NA</code>.
</p>
</li>
<li> <p><code>sex</code>: integers 1L (male) or 2L (female) which were drawn randomly; no other values occur in these outputs.
</p>
</li>
<li> <p><code>pheno</code>: Phenotype, here all 0 (missing value).
</p>
</li></ul>

</li>
<li> <p><code>ids</code>: a list of IDs for each generation (indexed in the list by generation).
</p>
</li>
<li> <p><code>kinship_local</code>: if <code>full = FALSE</code>, the local kinship matrix of the last generation, otherwise a list of local kinship matrices for every generation.
</p>
</li></ul>



<h3>See Also</h3>

<p>Plink FAM format reference:
<a href="https://www.cog-genomics.org/plink/1.9/formats#fam">https://www.cog-genomics.org/plink/1.9/formats#fam</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># number of individuals for each generation
n &lt;- c(15, 20, 25)

# create random pedigree with 3 generations, etc
data &lt;- sim_pedigree( n )

# this is the FAM table defining the entire pedigree,
# which is the most important piece of information desired!
data$fam

# the IDs separated by generation
data$ids

# bonus: the local kinship matrix of the final generation
data$kinship_local

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
