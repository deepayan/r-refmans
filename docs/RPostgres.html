<!DOCTYPE html><html><head><title>Help for package RPostgres</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RPostgres}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#dbDataType_PqConnection'><p>Determine database type for R vector.</p></a></li>
<li><a href='#Postgres'><p>Postgres driver</p></a></li>
<li><a href='#postgres-query'><p>Execute a SQL statement on a database connection</p></a></li>
<li><a href='#postgres-tables'><p>Convenience functions for reading/writing DBMS tables</p></a></li>
<li><a href='#postgres-transactions'><p>Transaction management.</p></a></li>
<li><a href='#postgresHasDefault'><p>Check if default database is available.</p></a></li>
<li><a href='#postgresIsTransacting'><p>Return whether a transaction is ongoing</p></a></li>
<li><a href='#postgresWaitForNotify'><p>Wait for and return any notifications that return within timeout</p></a></li>
<li><a href='#PqConnection-class'><p>PqConnection and methods.</p></a></li>
<li><a href='#PqDriver-class'><p>PqDriver and methods.</p></a></li>
<li><a href='#PqResult-class'><p>PostgreSQL results.</p></a></li>
<li><a href='#quote'><p>Quote postgres strings, identifiers, and literals</p></a></li>
<li><a href='#Redshift'><p>Redshift driver/connection</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#RPostgres-package'><p>RPostgres: Rcpp Interface to PostgreSQL</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>C++ Interface to PostgreSQL</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-10</td>
</tr>
<tr>
<td>Description:</td>
<td>Fully DBI-compliant Rcpp-backed interface to PostgreSQL
    <a href="https://www.postgresql.org/">https://www.postgresql.org/</a>, an open-source relational database.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://rpostgres.r-dbi.org">https://rpostgres.r-dbi.org</a>, <a href="https://github.com/r-dbi/RPostgres">https://github.com/r-dbi/RPostgres</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/r-dbi/RPostgres/issues">https://github.com/r-dbi/RPostgres/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>bit64, blob (&ge; 1.2.0), DBI (&ge; 1.1.0), hms (&ge; 1.0.0),
lubridate, methods, withr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>callr, covr, DBItest (&ge; 1.7.2.9001), knitr, rmarkdown,
testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>cpp11, plogr (&ge; 0.2.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/autostyle/scope:</td>
<td>line_breaks</td>
</tr>
<tr>
<td>Config/autostyle/strict:</td>
<td>false</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>libpq &gt;= 9.0: libpq-dev (deb) or postgresql-devel
(rpm)</td>
</tr>
<tr>
<td>Collate:</td>
<td>'PqDriver.R' 'PqConnection.R' 'PqResult.R' 'RPostgres-pkg.R'
'Redshift.R' 'cpp11.R' 'dbAppendTable_PqConnection.R'
'dbBegin_PqConnection.R' 'dbBind_PqResult.R'
'dbClearResult_PqResult.R' 'dbColumnInfo_PqResult.R'
'dbCommit_PqConnection.R' 'dbConnect_PqDriver.R'
'dbConnect_RedshiftDriver.R' 'dbDataType_PqConnection.R'
'dbDataType_PqDriver.R' 'dbDisconnect_PqConnection.R'
'dbExistsTable_PqConnection_Id.R'
'dbExistsTable_PqConnection_character.R' 'dbFetch_PqResult.R'
'dbGetInfo_PqConnection.R' 'dbGetInfo_PqDriver.R'
'dbGetRowCount_PqResult.R' 'dbGetRowsAffected_PqResult.R'
'dbGetStatement_PqResult.R' 'dbHasCompleted_PqResult.R'
'dbIsValid_PqConnection.R' 'dbIsValid_PqDriver.R'
'dbIsValid_PqResult.R' 'dbListFields_PqConnection_Id.R'
'dbListFields_PqConnection_character.R'
'dbListObjects_PqConnection_ANY.R'
'dbListTables_PqConnection.R'
'dbQuoteIdentifier_PqConnection_Id.R'
'dbQuoteIdentifier_PqConnection_SQL.R'
'dbQuoteIdentifier_PqConnection_character.R'
'dbQuoteLiteral_PqConnection.R'
'dbQuoteString_PqConnection_SQL.R'
'dbQuoteString_PqConnection_character.R'
'dbReadTable_PqConnection_character.R'
'dbRemoveTable_PqConnection_character.R'
'dbRollback_PqConnection.R' 'dbSendQuery_PqConnection.R'
'dbUnloadDriver_PqDriver.R'
'dbUnquoteIdentifier_PqConnection_SQL.R'
'dbWriteTable_PqConnection_character_data.frame.R' 'default.R'
'export.R' 'names.R' 'quote.R' 'show_PqConnection.R'
'sqlData_PqConnection.R' 'tables.R' 'transactions.R' 'utils.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-22 18:23:44 UTC; kirill</td>
</tr>
<tr>
<td>Author:</td>
<td>Hadley Wickham [aut],
  Jeroen Ooms [aut],
  Kirill Müller <a href="https://orcid.org/0000-0002-1416-3412"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  RStudio [cph],
  R Consortium [fnd],
  Tomoaki Nishiyama [ctb] (Code for encoding vectors into strings derived
    from RPostgreSQL)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kirill Müller &lt;kirill@cynkra.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-22 19:00:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='dbDataType_PqConnection'>Determine database type for R vector.</h2><span id='topic+dbDataType_PqConnection'></span><span id='topic+dbDataType+2CPqConnection-method'></span><span id='topic+dbDataType_PqDriver'></span><span id='topic+dbDataType+2CPqDriver-method'></span>

<h3>Description</h3>

<p>Determine database type for R vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PqConnection'
dbDataType(dbObj, obj, ...)

## S4 method for signature 'PqDriver'
dbDataType(dbObj, obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbDataType_PqConnection_+3A_dbobj">dbObj</code></td>
<td>
<p>Postgres driver or connection.</p>
</td></tr>
<tr><td><code id="dbDataType_PqConnection_+3A_obj">obj</code></td>
<td>
<p>Object to convert</p>
</td></tr>
</table>

<hr>
<h2 id='Postgres'>Postgres driver</h2><span id='topic+Postgres'></span><span id='topic+dbConnect_PqDriver'></span><span id='topic+dbConnect+2CPqDriver-method'></span><span id='topic+dbDisconnect_PqConnection'></span><span id='topic+dbDisconnect+2CPqConnection-method'></span>

<h3>Description</h3>

<p><code>DBI::dbConnect()</code> establishes a connection to a database.
Set <code>drv = Postgres()</code> to connect to a PostgreSQL(-ish) database. Use <code>drv = Redshift()</code> instead to connect to an AWS Redshift cluster.
</p>
<p>Manually disconnecting a connection is not necessary with <span class="pkg">RPostgres</span>,
but still recommended;
if you delete the object containing the connection, it will be automatically
disconnected during the next GC with a warning.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Postgres()

## S4 method for signature 'PqDriver'
dbConnect(
  drv,
  dbname = NULL,
  host = NULL,
  port = NULL,
  password = NULL,
  user = NULL,
  service = NULL,
  ...,
  bigint = c("integer64", "integer", "numeric", "character"),
  check_interrupts = FALSE,
  timezone = "UTC",
  timezone_out = NULL
)

## S4 method for signature 'PqConnection'
dbDisconnect(conn, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Postgres_+3A_drv">drv</code></td>
<td>
<p><a href="DBI.html#topic+DBIDriver-class">DBI::DBIDriver</a>. Use <code><a href="#topic+Postgres">Postgres()</a></code> to connect to a
PostgreSQL(-ish) database or <code><a href="#topic+Redshift">Redshift()</a></code> to connect to an AWS Redshift
cluster. Use an existing <a href="DBI.html#topic+DBIConnection-class">DBI::DBIConnection</a> object to clone an
existing connection.</p>
</td></tr>
<tr><td><code id="Postgres_+3A_dbname">dbname</code></td>
<td>
<p>Database name. If <code>NULL</code>, defaults to the user name.
Note that this argument can only contain the database name, it will not
be parsed as a connection string (internally, <code>expand_dbname</code> is set to
<code>false</code> in the call to
<a href="https://www.postgresql.org/docs/current/libpq-connect.html"><code>PQconnectdbParams()</code></a>).</p>
</td></tr>
<tr><td><code id="Postgres_+3A_host">host</code>, <code id="Postgres_+3A_port">port</code></td>
<td>
<p>Host and port. If <code>NULL</code>, will be retrieved from
<code>PGHOST</code> and <code>PGPORT</code> env vars.</p>
</td></tr>
<tr><td><code id="Postgres_+3A_user">user</code>, <code id="Postgres_+3A_password">password</code></td>
<td>
<p>User name and password. If <code>NULL</code>, will be
retrieved from <code>PGUSER</code> and <code>PGPASSWORD</code> envvars, or from the
appropriate line in <code style="white-space: pre;">&#8288;~/.pgpass&#8288;</code>. See
<a href="https://www.postgresql.org/docs/current/libpq-pgpass.html">https://www.postgresql.org/docs/current/libpq-pgpass.html</a> for
more details.</p>
</td></tr>
<tr><td><code id="Postgres_+3A_service">service</code></td>
<td>
<p>Name of service to connect as.  If <code>NULL</code>, will be
ignored.  Otherwise, connection parameters will be loaded from the pg_service.conf
file and used.  See <a href="https://www.postgresql.org/docs/current/libpq-pgservice.html">https://www.postgresql.org/docs/current/libpq-pgservice.html</a>
for details on this file and syntax.</p>
</td></tr>
<tr><td><code id="Postgres_+3A_...">...</code></td>
<td>
<p>Other name-value pairs that describe additional connection
options as described at
<a href="https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-PARAMKEYWORDS">https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-PARAMKEYWORDS</a></p>
</td></tr>
<tr><td><code id="Postgres_+3A_bigint">bigint</code></td>
<td>
<p>The R type that 64-bit integer types should be mapped to,
default is <a href="bit64.html#topic+bit64-package">bit64::integer64</a>, which allows the full range of 64 bit
integers.</p>
</td></tr>
<tr><td><code id="Postgres_+3A_check_interrupts">check_interrupts</code></td>
<td>
<p>Should user interrupts be checked during the query execution (before
first row of data is available)? Setting to <code>TRUE</code> allows interruption of queries
running too long.</p>
</td></tr>
<tr><td><code id="Postgres_+3A_timezone">timezone</code></td>
<td>
<p>Sets the timezone for the connection. The default is <code>"UTC"</code>.
If <code>NULL</code> then no timezone is set, which defaults to the server's time zone.</p>
</td></tr>
<tr><td><code id="Postgres_+3A_timezone_out">timezone_out</code></td>
<td>
<p>The time zone returned to R, defaults to <code>timezone</code>.
If you want to display datetime values in the local timezone,
set to <code><a href="base.html#topic+Sys.timezone">Sys.timezone()</a></code> or <code>""</code>.
This setting does not change the time values returned, only their display.</p>
</td></tr>
<tr><td><code id="Postgres_+3A_conn">conn</code></td>
<td>
<p>Connection to disconnect.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
library(DBI)
# Pass more arguments as necessary to dbConnect()
con &lt;- dbConnect(RPostgres::Postgres())
dbDisconnect(con)

</code></pre>

<hr>
<h2 id='postgres-query'>Execute a SQL statement on a database connection</h2><span id='topic+postgres-query'></span><span id='topic+dbBind_PqResult'></span><span id='topic+dbBind+2CPqResult-method'></span><span id='topic+dbClearResult_PqResult'></span><span id='topic+dbClearResult+2CPqResult-method'></span><span id='topic+dbFetch_PqResult'></span><span id='topic+dbFetch+2CPqResult-method'></span><span id='topic+dbHasCompleted_PqResult'></span><span id='topic+dbHasCompleted+2CPqResult-method'></span><span id='topic+dbSendQuery_PqConnection'></span><span id='topic+dbSendQuery+2CPqConnection-method'></span>

<h3>Description</h3>

<p>To retrieve results a chunk at a time, use <code>dbSendQuery()</code>,
<code>dbFetch()</code>, then <code>dbClearResult()</code>. Alternatively, if you want all the
results (and they'll fit in memory) use <code>dbGetQuery()</code> which sends,
fetches and clears for you.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PqResult'
dbBind(res, params, ...)

## S4 method for signature 'PqResult'
dbClearResult(res, ...)

## S4 method for signature 'PqResult'
dbFetch(res, n = -1, ..., row.names = FALSE)

## S4 method for signature 'PqResult'
dbHasCompleted(res, ...)

## S4 method for signature 'PqConnection'
dbSendQuery(conn, statement, params = NULL, ..., immediate = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="postgres-query_+3A_res">res</code></td>
<td>
<p>Code a <a href="#topic+PqResult-class">PqResult</a> produced by
<code><a href="DBI.html#topic+dbSendQuery">DBI::dbSendQuery()</a></code>.</p>
</td></tr>
<tr><td><code id="postgres-query_+3A_params">params</code></td>
<td>
<p>A list of query parameters to be substituted into
a parameterised query. Query parameters are sent as strings, and the
correct type is imputed by PostgreSQL. If this fails, you can manually
cast the parameter with e.g. <code>"$1::bigint"</code>.</p>
</td></tr>
<tr><td><code id="postgres-query_+3A_...">...</code></td>
<td>
<p>Other arguments needed for compatibility with generic (currently
ignored).</p>
</td></tr>
<tr><td><code id="postgres-query_+3A_n">n</code></td>
<td>
<p>Number of rows to return. If less than zero returns all rows.</p>
</td></tr>
<tr><td><code id="postgres-query_+3A_row.names">row.names</code></td>
<td>
<p>Either <code>TRUE</code>, <code>FALSE</code>, <code>NA</code> or a string.
</p>
<p>If <code>TRUE</code>, always translate row names to a column called &quot;row_names&quot;.
If <code>FALSE</code>, never translate row names. If <code>NA</code>, translate
rownames only if they're a character vector.
</p>
<p>A string is equivalent to <code>TRUE</code>, but allows you to override the
default name.
</p>
<p>For backward compatibility, <code>NULL</code> is equivalent to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="postgres-query_+3A_conn">conn</code></td>
<td>
<p>A <a href="#topic+PqConnection-class">PqConnection</a> created by <code><a href="DBI.html#topic+dbConnect">dbConnect()</a></code>.</p>
</td></tr>
<tr><td><code id="postgres-query_+3A_statement">statement</code></td>
<td>
<p>An SQL string to execute.</p>
</td></tr>
<tr><td><code id="postgres-query_+3A_immediate">immediate</code></td>
<td>
<p>If <code>TRUE</code>, uses the <code>PGsendQuery()</code> API instead of <code>PGprepare()</code>.
This allows to pass multiple statements and turns off the ability to pass parameters.</p>
</td></tr>
</table>


<h3>Multiple queries and statements</h3>

<p>With <code>immediate = TRUE</code>, it is possible to pass multiple queries or statements,
separated by semicolons.
For multiple statements, the resulting value of <code><a href="DBI.html#topic+dbGetRowsAffected">dbGetRowsAffected()</a></code>
corresponds to the total number of affected rows.
If multiple queries are used, all queries must return data with the same
column names and types.
Queries and statements can be mixed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(DBI)
db &lt;- dbConnect(RPostgres::Postgres())
dbWriteTable(db, "usarrests", datasets::USArrests, temporary = TRUE)

# Run query to get results as dataframe
dbGetQuery(db, "SELECT * FROM usarrests LIMIT 3")

# Send query to pull requests in batches
res &lt;- dbSendQuery(db, "SELECT * FROM usarrests")
dbFetch(res, n = 2)
dbFetch(res, n = 2)
dbHasCompleted(res)
dbClearResult(res)

dbRemoveTable(db, "usarrests")

dbDisconnect(db)

</code></pre>

<hr>
<h2 id='postgres-tables'>Convenience functions for reading/writing DBMS tables</h2><span id='topic+postgres-tables'></span><span id='topic+dbAppendTable_PqConnection'></span><span id='topic+dbAppendTable+2CPqConnection-method'></span><span id='topic+dbExistsTable_PqConnection_Id'></span><span id='topic+dbExistsTable+2CPqConnection+2CId-method'></span><span id='topic+dbExistsTable_PqConnection_character'></span><span id='topic+dbExistsTable+2CPqConnection+2Ccharacter-method'></span><span id='topic+dbListFields_PqConnection_Id'></span><span id='topic+dbListFields+2CPqConnection+2CId-method'></span><span id='topic+dbListFields_PqConnection_character'></span><span id='topic+dbListFields+2CPqConnection+2Ccharacter-method'></span><span id='topic+dbListObjects_PqConnection_ANY'></span><span id='topic+dbListObjects+2CPqConnection-method'></span><span id='topic+dbListTables_PqConnection'></span><span id='topic+dbListTables+2CPqConnection-method'></span><span id='topic+dbReadTable_PqConnection_character'></span><span id='topic+dbReadTable+2CPqConnection+2Ccharacter-method'></span><span id='topic+dbRemoveTable_PqConnection_character'></span><span id='topic+dbRemoveTable+2CPqConnection+2Ccharacter-method'></span><span id='topic+dbWriteTable_PqConnection_character_data.frame'></span><span id='topic+dbWriteTable+2CPqConnection+2Ccharacter+2Cdata.frame-method'></span><span id='topic+sqlData_PqConnection'></span><span id='topic+sqlData+2CPqConnection-method'></span>

<h3>Description</h3>

<p><code><a href="DBI.html#topic+dbAppendTable">dbAppendTable()</a></code> is overridden because <span class="pkg">RPostgres</span>
uses placeholders of the form <code style="white-space: pre;">&#8288;$1&#8288;</code>, <code style="white-space: pre;">&#8288;$2&#8288;</code> etc. instead of <code style="white-space: pre;">&#8288;?&#8288;</code>.
</p>
<p><code><a href="DBI.html#topic+dbWriteTable">dbWriteTable()</a></code> executes several SQL statements that
create/overwrite a table and fill it with values.
<span class="pkg">RPostgres</span> does not use parameterised queries to insert rows because
benchmarks revealed that this was considerably slower than using a single
SQL string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PqConnection'
dbAppendTable(conn, name, value, copy = NULL, ..., row.names = NULL)

## S4 method for signature 'PqConnection,Id'
dbExistsTable(conn, name, ...)

## S4 method for signature 'PqConnection,character'
dbExistsTable(conn, name, ...)

## S4 method for signature 'PqConnection,Id'
dbListFields(conn, name, ...)

## S4 method for signature 'PqConnection,character'
dbListFields(conn, name, ...)

## S4 method for signature 'PqConnection'
dbListObjects(conn, prefix = NULL, ...)

## S4 method for signature 'PqConnection'
dbListTables(conn, ...)

## S4 method for signature 'PqConnection,character'
dbReadTable(conn, name, ..., check.names = TRUE, row.names = FALSE)

## S4 method for signature 'PqConnection,character'
dbRemoveTable(conn, name, ..., temporary = FALSE, fail_if_missing = TRUE)

## S4 method for signature 'PqConnection,character,data.frame'
dbWriteTable(
  conn,
  name,
  value,
  ...,
  row.names = FALSE,
  overwrite = FALSE,
  append = FALSE,
  field.types = NULL,
  temporary = FALSE,
  copy = NULL
)

## S4 method for signature 'PqConnection'
sqlData(con, value, row.names = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="postgres-tables_+3A_conn">conn</code></td>
<td>
<p>a <a href="#topic+PqConnection-class">PqConnection</a> object, produced by
<code><a href="DBI.html#topic+dbConnect">DBI::dbConnect()</a></code></p>
</td></tr>
<tr><td><code id="postgres-tables_+3A_name">name</code></td>
<td>
<p>a character string specifying a table name. Names will be
automatically quoted so you can use any sequence of characters, not
just any valid bare table name.
Alternatively, pass a name quoted with <code><a href="DBI.html#topic+dbQuoteIdentifier">dbQuoteIdentifier()</a></code>,
an <code><a href="#topic+Id">Id()</a></code> object, or a string escaped with <code><a href="DBI.html#topic+SQL">SQL()</a></code>.</p>
</td></tr>
<tr><td><code id="postgres-tables_+3A_value">value</code></td>
<td>
<p>A data.frame to write to the database.</p>
</td></tr>
<tr><td><code id="postgres-tables_+3A_copy">copy</code></td>
<td>
<p>If <code>TRUE</code>, serializes the data frame to a single string
and uses <code style="white-space: pre;">&#8288;COPY name FROM stdin&#8288;</code>. This is fast, but not supported by
all postgres servers (e.g. Amazon's Redshift). If <code>FALSE</code>, generates
a single SQL string. This is slower, but always supported.
The default maps to <code>TRUE</code> on connections established via <code><a href="#topic+Postgres">Postgres()</a></code>
and to <code>FALSE</code> on connections established via <code><a href="#topic+Redshift">Redshift()</a></code>.</p>
</td></tr>
<tr><td><code id="postgres-tables_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="postgres-tables_+3A_row.names">row.names</code></td>
<td>
<p>Either <code>TRUE</code>, <code>FALSE</code>, <code>NA</code> or a string.
</p>
<p>If <code>TRUE</code>, always translate row names to a column called &quot;row_names&quot;.
If <code>FALSE</code>, never translate row names. If <code>NA</code>, translate
rownames only if they're a character vector.
</p>
<p>A string is equivalent to <code>TRUE</code>, but allows you to override the
default name.
</p>
<p>For backward compatibility, <code>NULL</code> is equivalent to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="postgres-tables_+3A_prefix">prefix</code></td>
<td>
<p>A fully qualified path in the database's namespace, or <code>NULL</code>.
This argument will be processed with <code><a href="DBI.html#topic+dbUnquoteIdentifier">dbUnquoteIdentifier()</a></code>.
If given the method will return all objects accessible through this prefix.</p>
</td></tr>
<tr><td><code id="postgres-tables_+3A_check.names">check.names</code></td>
<td>
<p>If <code>TRUE</code>, the default, column names will be
converted to valid R identifiers.</p>
</td></tr>
<tr><td><code id="postgres-tables_+3A_temporary">temporary</code></td>
<td>
<p>If <code>TRUE</code>, only temporary tables are considered.</p>
</td></tr>
<tr><td><code id="postgres-tables_+3A_fail_if_missing">fail_if_missing</code></td>
<td>
<p>If <code>FALSE</code>, <code>dbRemoveTable()</code> succeeds if the
table doesn't exist.</p>
</td></tr>
<tr><td><code id="postgres-tables_+3A_overwrite">overwrite</code></td>
<td>
<p>a logical specifying whether to overwrite an existing table
or not. Its default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="postgres-tables_+3A_append">append</code></td>
<td>
<p>a logical specifying whether to append to an existing table
in the DBMS. Its default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="postgres-tables_+3A_field.types">field.types</code></td>
<td>
<p>character vector of named SQL field types where
the names are the names of new table's columns.
If missing, types are inferred with <code><a href="DBI.html#topic+dbDataType">DBI::dbDataType()</a></code>).
The types can only be specified with <code>append = FALSE</code>.</p>
</td></tr>
<tr><td><code id="postgres-tables_+3A_con">con</code></td>
<td>
<p>A database connection.</p>
</td></tr>
</table>


<h3>Schemas, catalogs, tablespaces</h3>

<p>Pass an identifier created with <code><a href="#topic+Id">Id()</a></code> as the <code>name</code> argument
to specify the schema or catalog, e.g.
<code>name = Id(catalog = "my_catalog", schema = "my_schema", table = "my_table")</code> .
To specify the tablespace, use
<code>dbExecute(conn, "SET default_tablespace TO my_tablespace")</code>
before creating the table.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(DBI)
con &lt;- dbConnect(RPostgres::Postgres())
dbListTables(con)
dbWriteTable(con, "mtcars", mtcars, temporary = TRUE)
dbReadTable(con, "mtcars")

dbListTables(con)
dbExistsTable(con, "mtcars")

# A zero row data frame just creates a table definition.
dbWriteTable(con, "mtcars2", mtcars[0, ], temporary = TRUE)
dbReadTable(con, "mtcars2")

dbDisconnect(con)

</code></pre>

<hr>
<h2 id='postgres-transactions'>Transaction management.</h2><span id='topic+postgres-transactions'></span><span id='topic+dbBegin_PqConnection'></span><span id='topic+dbBegin+2CPqConnection-method'></span><span id='topic+dbCommit_PqConnection'></span><span id='topic+dbCommit+2CPqConnection-method'></span><span id='topic+dbRollback_PqConnection'></span><span id='topic+dbRollback+2CPqConnection-method'></span>

<h3>Description</h3>

<p><code>dbBegin()</code> starts a transaction. <code>dbCommit()</code> and <code>dbRollback()</code>
end the transaction by either committing or rolling back the changes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PqConnection'
dbBegin(conn, ..., name = NULL)

## S4 method for signature 'PqConnection'
dbCommit(conn, ..., name = NULL)

## S4 method for signature 'PqConnection'
dbRollback(conn, ..., name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="postgres-transactions_+3A_conn">conn</code></td>
<td>
<p>a <a href="#topic+PqConnection-class">PqConnection</a> object, produced by
<code><a href="DBI.html#topic+dbConnect">DBI::dbConnect()</a></code></p>
</td></tr>
<tr><td><code id="postgres-transactions_+3A_...">...</code></td>
<td>
<p>Unused, for extensibility.</p>
</td></tr>
<tr><td><code id="postgres-transactions_+3A_name">name</code></td>
<td>
<p>If provided, uses the <code>SAVEPOINT</code> SQL syntax
to establish, remove (commit) or undo a ßsavepoint.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A boolean, indicating success or failure.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(DBI)
con &lt;- dbConnect(RPostgres::Postgres())
dbWriteTable(con, "USarrests", datasets::USArrests, temporary = TRUE)
dbGetQuery(con, 'SELECT count(*) from "USarrests"')

dbBegin(con)
dbExecute(con, 'DELETE from "USarrests" WHERE "Murder" &gt; 1')
dbGetQuery(con, 'SELECT count(*) from "USarrests"')
dbRollback(con)

# Rolling back changes leads to original count
dbGetQuery(con, 'SELECT count(*) from "USarrests"')

dbRemoveTable(con, "USarrests")
dbDisconnect(con)

</code></pre>

<hr>
<h2 id='postgresHasDefault'>Check if default database is available.</h2><span id='topic+postgresHasDefault'></span><span id='topic+postgresDefault'></span>

<h3>Description</h3>

<p>RPostgres examples and tests connect to a default database via
<code style="white-space: pre;">&#8288;dbConnect(&#8288;</code><code><a href="#topic+Postgres">Postgres()</a></code><code style="white-space: pre;">&#8288;)&#8288;</code>. This function checks if that
database is available, and if not, displays an informative message.
</p>
<p><code>postgresDefault()</code> works similarly but returns a connection on success and
throws a testthat skip condition on failure, making it suitable for use in
tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>postgresHasDefault(...)

postgresDefault(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="postgresHasDefault_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to <code><a href="DBI.html#topic+dbConnect">dbConnect()</a></code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if (postgresHasDefault()) {
  db &lt;- postgresDefault()
  print(dbListTables(db))
  dbDisconnect(db)
} else {
  message("No database connection.")
}
</code></pre>

<hr>
<h2 id='postgresIsTransacting'>Return whether a transaction is ongoing</h2><span id='topic+postgresIsTransacting'></span>

<h3>Description</h3>

<p>Detect whether the transaction is active for the given connection. A
transaction might be started with <code><a href="DBI.html#topic+dbBegin">dbBegin()</a></code> or wrapped within
<code><a href="DBI.html#topic+dbWithTransaction">DBI::dbWithTransaction()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>postgresIsTransacting(conn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="postgresIsTransacting_+3A_conn">conn</code></td>
<td>
<p>a <a href="#topic+PqConnection-class">PqConnection</a> object, produced by
<code><a href="DBI.html#topic+dbConnect">DBI::dbConnect()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A boolean, indicating if a transaction is ongoing.
</p>

<hr>
<h2 id='postgresWaitForNotify'>Wait for and return any notifications that return within timeout</h2><span id='topic+postgresWaitForNotify'></span>

<h3>Description</h3>

<p>Once you subscribe to notifications with LISTEN, use this to wait for
responses on each channel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>postgresWaitForNotify(conn, timeout = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="postgresWaitForNotify_+3A_conn">conn</code></td>
<td>
<p>a <a href="#topic+PqConnection-class">PqConnection</a> object, produced by
<code><a href="DBI.html#topic+dbConnect">DBI::dbConnect()</a></code></p>
</td></tr>
<tr><td><code id="postgresWaitForNotify_+3A_timeout">timeout</code></td>
<td>
<p>How long to wait, in seconds. Default 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If a notification was available, a list of:
</p>

<dl>
<dt>channel</dt><dd><p>Name of channel</p>
</dd>
<dt>pid</dt><dd><p>PID of notifying server process</p>
</dd>
<dt>payload</dt><dd><p>Content of notification</p>
</dd>
</dl>

<p>If no notifications are available, return NULL
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(DBI)
library(callr)

# listen for messages on the grapevine
db_listen &lt;- dbConnect(RPostgres::Postgres())
dbExecute(db_listen, "LISTEN grapevine")

# Start another process, which sends a message after a delay
rp &lt;- r_bg(function() {
  library(DBI)
  Sys.sleep(0.3)
  db_notify &lt;- dbConnect(RPostgres::Postgres())
  dbExecute(db_notify, "NOTIFY grapevine, 'psst'")
  dbDisconnect(db_notify)
})

# Sleep until we get the message
n &lt;- NULL
while (is.null(n)) {
  n &lt;- RPostgres::postgresWaitForNotify(db_listen, 60)
}
stopifnot(n$payload == 'psst')

# Tidy up
rp$wait()
dbDisconnect(db_listen)

</code></pre>

<hr>
<h2 id='PqConnection-class'>PqConnection and methods.</h2><span id='topic+PqConnection-class'></span><span id='topic+format.PqConnection'></span><span id='topic+dbGetInfo_PqConnection'></span><span id='topic+dbGetInfo+2CPqConnection-method'></span><span id='topic+dbIsValid_PqConnection'></span><span id='topic+dbIsValid+2CPqConnection-method'></span><span id='topic+show_PqConnection'></span><span id='topic+show+2CPqConnection-method'></span>

<h3>Description</h3>

<p>PqConnection and methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PqConnection'
format(x, ...)

## S4 method for signature 'PqConnection'
dbGetInfo(dbObj, ...)

## S4 method for signature 'PqConnection'
dbIsValid(dbObj, ...)

## S4 method for signature 'PqConnection'
show(object)
</code></pre>

<hr>
<h2 id='PqDriver-class'>PqDriver and methods.</h2><span id='topic+PqDriver-class'></span><span id='topic+dbGetInfo_PqDriver'></span><span id='topic+dbGetInfo+2CPqDriver-method'></span><span id='topic+dbUnloadDriver_PqDriver'></span><span id='topic+dbUnloadDriver+2CPqDriver-method'></span>

<h3>Description</h3>

<p>PqDriver and methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PqDriver'
dbGetInfo(dbObj, ...)

## S4 method for signature 'PqDriver'
dbUnloadDriver(drv, ...)
</code></pre>

<hr>
<h2 id='PqResult-class'>PostgreSQL results.</h2><span id='topic+PqResult-class'></span><span id='topic+dbColumnInfo_PqResult'></span><span id='topic+dbColumnInfo+2CPqResult-method'></span><span id='topic+dbGetRowCount_PqResult'></span><span id='topic+dbGetRowCount+2CPqResult-method'></span><span id='topic+dbGetRowsAffected_PqResult'></span><span id='topic+dbGetRowsAffected+2CPqResult-method'></span><span id='topic+dbGetStatement_PqResult'></span><span id='topic+dbGetStatement+2CPqResult-method'></span><span id='topic+dbIsValid_PqDriver'></span><span id='topic+dbIsValid+2CPqDriver-method'></span><span id='topic+dbIsValid_PqResult'></span><span id='topic+dbIsValid+2CPqResult-method'></span>

<h3>Description</h3>

<p>PostgreSQL results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PqResult'
dbColumnInfo(res, ...)

## S4 method for signature 'PqResult'
dbGetRowCount(res, ...)

## S4 method for signature 'PqResult'
dbGetRowsAffected(res, ...)

## S4 method for signature 'PqResult'
dbGetStatement(res, ...)

## S4 method for signature 'PqDriver'
dbIsValid(dbObj, ...)

## S4 method for signature 'PqResult'
dbIsValid(dbObj, ...)
</code></pre>

<hr>
<h2 id='quote'>Quote postgres strings, identifiers, and literals</h2><span id='topic+quote'></span><span id='topic+dbQuoteIdentifier_PqConnection_Id'></span><span id='topic+dbQuoteIdentifier+2CPqConnection+2CId-method'></span><span id='topic+dbQuoteIdentifier_PqConnection_SQL'></span><span id='topic+dbQuoteIdentifier+2CPqConnection+2CSQL-method'></span><span id='topic+dbQuoteIdentifier_PqConnection_character'></span><span id='topic+dbQuoteIdentifier+2CPqConnection+2Ccharacter-method'></span><span id='topic+dbQuoteLiteral_PqConnection'></span><span id='topic+dbQuoteLiteral+2CPqConnection-method'></span><span id='topic+dbQuoteString_PqConnection_SQL'></span><span id='topic+dbQuoteString+2CPqConnection+2CSQL-method'></span><span id='topic+dbQuoteString_PqConnection_character'></span><span id='topic+dbQuoteString+2CPqConnection+2Ccharacter-method'></span><span id='topic+dbUnquoteIdentifier_PqConnection_SQL'></span><span id='topic+dbUnquoteIdentifier+2CPqConnection+2CSQL-method'></span>

<h3>Description</h3>

<p>If an object of class <a href="#topic+Id">Id</a> is used for <code>dbQuoteIdentifier()</code>, it needs
at most one <code>table</code> component and at most one <code>schema</code> component.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PqConnection,Id'
dbQuoteIdentifier(conn, x, ...)

## S4 method for signature 'PqConnection,SQL'
dbQuoteIdentifier(conn, x, ...)

## S4 method for signature 'PqConnection,character'
dbQuoteIdentifier(conn, x, ...)

## S4 method for signature 'PqConnection'
dbQuoteLiteral(conn, x, ...)

## S4 method for signature 'PqConnection,SQL'
dbQuoteString(conn, x, ...)

## S4 method for signature 'PqConnection,character'
dbQuoteString(conn, x, ...)

## S4 method for signature 'PqConnection,SQL'
dbUnquoteIdentifier(conn, x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quote_+3A_conn">conn</code></td>
<td>
<p>A <a href="#topic+PqConnection-class">PqConnection</a> created by <code>dbConnect()</code></p>
</td></tr>
<tr><td><code id="quote_+3A_x">x</code></td>
<td>
<p>A character vector to be quoted.</p>
</td></tr>
<tr><td><code id="quote_+3A_...">...</code></td>
<td>
<p>Other arguments needed for compatibility with generic (currently
ignored).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
library(DBI)
con &lt;- dbConnect(RPostgres::Postgres())

x &lt;- c("a", "b c", "d'e", "\\f")
dbQuoteString(con, x)
dbQuoteIdentifier(con, x)
dbDisconnect(con)

</code></pre>

<hr>
<h2 id='Redshift'>Redshift driver/connection</h2><span id='topic+Redshift'></span><span id='topic+RedshiftDriver-class'></span><span id='topic+RedshiftConnection-class'></span><span id='topic+dbConnect_RedshiftDriver'></span><span id='topic+dbConnect+2CRedshiftDriver-method'></span>

<h3>Description</h3>

<p>Use <code>drv = Redshift()</code> instead of <code>drv = Postgres()</code> to connect to an AWS Redshift cluster.
All methods in <span class="pkg">RPostgres</span> and downstream packages can be called on such connections.
Some have different behavior for Redshift connections, to ensure better interoperability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Redshift()

## S4 method for signature 'RedshiftDriver'
dbConnect(
  drv,
  dbname = NULL,
  host = NULL,
  port = NULL,
  password = NULL,
  user = NULL,
  service = NULL,
  ...,
  bigint = c("integer64", "integer", "numeric", "character"),
  check_interrupts = FALSE,
  timezone = "UTC"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Redshift_+3A_drv">drv</code></td>
<td>
<p><a href="DBI.html#topic+DBIDriver-class">DBI::DBIDriver</a>. Use <code><a href="#topic+Postgres">Postgres()</a></code> to connect to a
PostgreSQL(-ish) database or <code><a href="#topic+Redshift">Redshift()</a></code> to connect to an AWS Redshift
cluster. Use an existing <a href="DBI.html#topic+DBIConnection-class">DBI::DBIConnection</a> object to clone an
existing connection.</p>
</td></tr>
<tr><td><code id="Redshift_+3A_dbname">dbname</code></td>
<td>
<p>Database name. If <code>NULL</code>, defaults to the user name.
Note that this argument can only contain the database name, it will not
be parsed as a connection string (internally, <code>expand_dbname</code> is set to
<code>false</code> in the call to
<a href="https://www.postgresql.org/docs/current/libpq-connect.html"><code>PQconnectdbParams()</code></a>).</p>
</td></tr>
<tr><td><code id="Redshift_+3A_host">host</code>, <code id="Redshift_+3A_port">port</code></td>
<td>
<p>Host and port. If <code>NULL</code>, will be retrieved from
<code>PGHOST</code> and <code>PGPORT</code> env vars.</p>
</td></tr>
<tr><td><code id="Redshift_+3A_user">user</code>, <code id="Redshift_+3A_password">password</code></td>
<td>
<p>User name and password. If <code>NULL</code>, will be
retrieved from <code>PGUSER</code> and <code>PGPASSWORD</code> envvars, or from the
appropriate line in <code style="white-space: pre;">&#8288;~/.pgpass&#8288;</code>. See
<a href="https://www.postgresql.org/docs/current/libpq-pgpass.html">https://www.postgresql.org/docs/current/libpq-pgpass.html</a> for
more details.</p>
</td></tr>
<tr><td><code id="Redshift_+3A_service">service</code></td>
<td>
<p>Name of service to connect as.  If <code>NULL</code>, will be
ignored.  Otherwise, connection parameters will be loaded from the pg_service.conf
file and used.  See <a href="https://www.postgresql.org/docs/current/libpq-pgservice.html">https://www.postgresql.org/docs/current/libpq-pgservice.html</a>
for details on this file and syntax.</p>
</td></tr>
<tr><td><code id="Redshift_+3A_...">...</code></td>
<td>
<p>Other name-value pairs that describe additional connection
options as described at
<a href="https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-PARAMKEYWORDS">https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-PARAMKEYWORDS</a></p>
</td></tr>
<tr><td><code id="Redshift_+3A_bigint">bigint</code></td>
<td>
<p>The R type that 64-bit integer types should be mapped to,
default is <a href="bit64.html#topic+bit64-package">bit64::integer64</a>, which allows the full range of 64 bit
integers.</p>
</td></tr>
<tr><td><code id="Redshift_+3A_check_interrupts">check_interrupts</code></td>
<td>
<p>Should user interrupts be checked during the query execution (before
first row of data is available)? Setting to <code>TRUE</code> allows interruption of queries
running too long.</p>
</td></tr>
<tr><td><code id="Redshift_+3A_timezone">timezone</code></td>
<td>
<p>Sets the timezone for the connection. The default is <code>"UTC"</code>.
If <code>NULL</code> then no timezone is set, which defaults to the server's time zone.</p>
</td></tr>
</table>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+Id'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>DBI</dt><dd><p><code><a href="DBI.html#topic+Id">Id</a></code></p>
</dd>
</dl>

<hr>
<h2 id='RPostgres-package'>RPostgres: Rcpp Interface to PostgreSQL</h2><span id='topic+RPostgres'></span><span id='topic+RPostgres-package'></span>

<h3>Description</h3>

<p>Fully DBI-compliant Rcpp-backed interface to PostgreSQL <a href="https://www.postgresql.org/">https://www.postgresql.org/</a>, an open-source relational database.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Kirill Müller <a href="mailto:kirill@cynkra.com">kirill@cynkra.com</a> (<a href="https://orcid.org/0000-0002-1416-3412">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Hadley Wickham
</p>
</li>
<li><p> Jeroen Ooms
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> RStudio [copyright holder]
</p>
</li>
<li><p> R Consortium [funder]
</p>
</li>
<li><p> Tomoaki Nishiyama (Code for encoding vectors into strings derived from RPostgreSQL) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://rpostgres.r-dbi.org">https://rpostgres.r-dbi.org</a>
</p>
</li>
<li> <p><a href="https://github.com/r-dbi/RPostgres">https://github.com/r-dbi/RPostgres</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/r-dbi/RPostgres/issues">https://github.com/r-dbi/RPostgres/issues</a>
</p>
</li></ul>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
