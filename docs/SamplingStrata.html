<!DOCTYPE html><html><head><title>Help for package SamplingStrata</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SamplingStrata}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adjustSize'>
<p>Adjustment of the sample size in case it is externally given</p></a></li>
<li><a href='#aggrStrata2'>
<p>Builds the &quot;strata&quot; dataframe containing information on target variables Y's</p>
distributions in the different strata, starting from a frame</a></li>
<li><a href='#aggrStrataSpatial'>
<p>Builds the &quot;strata&quot; dataframe containing information on target variables Y's</p>
distributions in the different strata, starting from a frame where units are spatially correlated.</a></li>
<li><a href='#assignStrataLabel'><p>Function to assign the optimized strata labels</p></a></li>
<li><a href='#bethel'>
<p>Multivariate optimal allocation</p></a></li>
<li><a href='#buildFrameDF'>
<p>Builds the &quot;sampling frame&quot; dataframe from a dataset containing information on</p>
all the units in the population of reference</a></li>
<li><a href='#buildFrameSpatial'>
<p>Builds the &quot;sampling frame&quot; dataframe from a dataset containing information all the units in the population of reference including spatial</p></a></li>
<li><a href='#buildStrataDF'>
<p>Builds the &quot;strata&quot; dataframe containing information on target variables Y's</p>
distributions in the different strata, starting from sample data or from a frame</a></li>
<li><a href='#buildStrataDFSpatial'>
<p>Builds the &quot;strata&quot; dataframe containing information on target variables Y's</p>
distributions in the different strata, starting from sample data or from a frame</a></li>
<li><a href='#checkInput'>
<p>Checks the inputs to the package: dataframes &quot;errors&quot;, &quot;strata&quot; and &quot;sampling frame&quot;</p></a></li>
<li><a href='#computeGamma'>
<p>Function that allows to calculate a heteroscedasticity index,</p>
together with associate prediction variance,
to be used by the optimization step
to correctly evaluate the standard deviation in the strata
due to prediction errors.</a></li>
<li><a href='#errors'>
<p>Precision constraints (maximum CVs) as input for Bethel allocation</p></a></li>
<li><a href='#evalSolution'>
<p>Evaluation of the solution produced by the function 'optimizeStrata' by</p>
selecting a number of samples from the frame with the optimal stratification, and calculating average CV's on the target variables Y's.</a></li>
<li><a href='#expected_CV'>
<p>Expected coefficients of variation of target variables Y</p></a></li>
<li><a href='#KmeansSolution'>
<p>Initial solution obtained by applying kmeans clustering of atomic strata</p></a></li>
<li><a href='#KmeansSolution2'>
<p>Initial solution obtained by applying kmeans clustering of frame units</p></a></li>
<li><a href='#KmeansSolutionSpatial'>
<p>Initial solution obtained by applying kmeans clustering of frame units</p></a></li>
<li><a href='#nations'><p>Dataset 'nations'</p></a></li>
<li><a href='#optimizeStrata'>
<p>Best stratification of a sampling frame for multipurpose surveys</p></a></li>
<li><a href='#optimizeStrata2'>
<p>Best stratification of a sampling frame for multipurpose surveys (only with continuous stratification variables)</p></a></li>
<li><a href='#optimizeStrataSpatial'>
<p>Best stratification of a sampling frame for multipurpose surveys considering also spatial correlation</p></a></li>
<li><a href='#optimStrata'>
<p>Optimization of the stratification of a sampling frame given a sample survey</p></a></li>
<li><a href='#plotSamprate'>
<p>Plotting sampling rates in the different strata for each domain in the solution.</p></a></li>
<li><a href='#plotStrata2d'><p>Plot bivariate distibutions in strata</p></a></li>
<li><a href='#prepareSuggestion'>
<p>Prepare suggestions for optimization with method = &quot;continuous&quot; or &quot;spatial&quot;</p></a></li>
<li><a href='#procBethel'>
<p>Procedure to apply Bethel algorithm and select a sample from given strata</p></a></li>
<li><a href='#selectSample'>
<p>Selection of a stratified sample from the frame with srswor method</p></a></li>
<li><a href='#selectSampleSpatial'>
<p>Selection of geo-referenced points from the frame</p></a></li>
<li><a href='#selectSampleSystematic'>
<p>Selection of a stratified sample from the frame with systematic method</p></a></li>
<li><a href='#strata'>
<p>Dataframe containing information on strata in the frame</p></a></li>
<li><a href='#summaryStrata'><p>Information on strata structure</p></a></li>
<li><a href='#swisserrors'>
<p>Precision constraints (maximum CVs) as input for Bethel allocation</p></a></li>
<li><a href='#swissframe'>
<p>Dataframe containing information on all units in the population of reference</p>
that can be considered as the final sampling unit
(this example is related to Swiss municipalities)</a></li>
<li><a href='#swissmunicipalities'><p>The Swiss municipalities population</p></a></li>
<li><a href='#swissstrata'>
<p>Dataframe containing information on strata in the swiss municipalities frame</p></a></li>
<li><a href='#tuneParameters'>
<p>Execution and compared evaluation of optimization runs</p></a></li>
<li><a href='#updateFrame'>
<p>Updates the initial frame on the basis of the optimized stratification</p></a></li>
<li><a href='#updateStrata'>
<p>Assigns new labels to atomic strata on the basis of the optimized aggregated strata</p></a></li>
<li><a href='#var.bin'>
<p>Allows to transform a continuous variable into a categorical ordinal one</p>
by applying a modified version of the k-means clustering function in the 'stats' package.</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Optimal Stratification of Sampling Frames for Multipurpose
Sampling Surveys</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5-4</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-11-11</td>
</tr>
<tr>
<td>Author:</td>
<td>Giulio Barcaroli, Marco Ballin, Hanjo Odendaal, Daniela Pagliuca, Egon Willighagen,
		Diego Zardetto</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Giulio Barcaroli &lt;gbarcaroli@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>In the field of stratified sampling design, this package offers an approach for the determination of the best stratification of a sampling frame, the one that ensures the minimum sample cost under the condition to satisfy precision constraints in a multivariate and multidomain case. This approach is based on the use of the genetic algorithm: each solution (i.e. a particular partition in strata of the sampling frame) is considered as an individual in a population; the fitness of all individuals is evaluated applying the Bethel-Chromy algorithm to calculate the sampling size satisfying precision constraints on the target estimates. Functions in the package allows to: (a) analyse the obtained results of the optimisation step; (b) assign the new strata labels to the sampling frame; (c) select a sample from the new frame accordingly to the best allocation. Functions for the execution of the genetic algorithm are a modified version of the functions in the 'genalg' package. M.Ballin, G.Barcaroli (2020) &lt;<a href="https://arxiv.org/abs/2004.09366">arXiv:2004.09366</a>&gt; "R package SamplingStrata: new developments and extension to Spatial Sampling".  </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), memoise, doParallel, pbapply, SamplingBigData,
glue, methods</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-14 10:41:01 UTC; Giulio</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, formattable</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://barcaroli.github.io/SamplingStrata/">https://barcaroli.github.io/SamplingStrata/</a>,
<a href="https://github.com/barcaroli/SamplingStrata/">https://github.com/barcaroli/SamplingStrata/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/barcaroli/SamplingStrata/issues">https://github.com/barcaroli/SamplingStrata/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-11-15 21:50:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='adjustSize'>
Adjustment of the sample size in case it is externally given
</h2><span id='topic+adjustSize'></span>

<h3>Description</h3>

<p>The optimisation step finds the best stratification that minimises the sample size under given precision constraints.
In some cases, the goal is not the minimisation of the sample size, as this value is given externally. Nonetheless, it is
still possible to perform the optimisation of the stratification, and then to proceed to an adjustment of the sample size
by increasing or decreasing it proportionally in each resulting stratum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjustSize(size, strata, cens=NULL, minnumstr=2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjustSize_+3A_size">size</code></td>
<td>

<p>The value of the sample size given externally
</p>
</td></tr>
<tr><td><code id="adjustSize_+3A_strata">strata</code></td>
<td>

<p>The new (aggregated) strata generated by the function 'optimizeStrata'
</p>
</td></tr>
<tr><td><code id="adjustSize_+3A_cens">cens</code></td>
<td>

<p>Flag indicating the presence of a take-all stratum
</p>
</td></tr>
<tr><td><code id="adjustSize_+3A_minnumstr">minnumstr</code></td>
<td>

<p>Indicates the minimum number of units that must be allocated in each stratum. Default is 2.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The strata generated by the function 'optimizeStrata', where the variable 'SOLUZ' has been adjusted by taking into account the total required sample size
</p>


<h3>Author(s)</h3>

<p>Giulio Barcaroli
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(SamplingStrata)
data(swisserrors)
data(swissstrata)
solution &lt;- optimizeStrata (
	errors = swisserrors,
	strata = swissstrata,
)
# 
sum(solution$aggr_strata$SOLUZ)
# Adjustment of total sample size (decreasing)
adjustedStrata &lt;- adjustSize(size=300,strata=solution$aggr_strata)
sum(adjustedStrata$SOLUZ)
# Adjustment of total sample size (increasing)
adjustedStrata &lt;- adjustSize(size=500,strata=solution$aggr_strata)
sum(adjustedStrata$SOLUZ)

## End(Not run)
</code></pre>

<hr>
<h2 id='aggrStrata2'>
Builds the &quot;strata&quot; dataframe containing information on target variables Y's
distributions in the different strata, starting from a frame
</h2><span id='topic+aggrStrata2'></span>

<h3>Description</h3>

<p>This function builds the dataframe &quot;strata&quot; considering as input a given domain in the sampling frame. In case a dataframe &quot;model&quot; is given, the anticipated variance in the strata for each target variable is calculated 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggrStrata2(dataset, 
            model=NULL, 
            vett,
            dominio)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggrStrata2_+3A_dataset">dataset</code></td>
<td>

<p>This is the name of the dataframe containing the sample data, or the frame data. 
It is strictly required that auxiliary information is organised in variables named 
as X1, X2, ... , Xm (there should be at least one of them) and the target variables 
are denoted by Y1, Y2, ... , Yn.
In addition, in case of sample data, a variable named 'WEIGHT' must be present in the dataframe, 
containing   the weigths associated to each sampling unit
</p>
</td></tr>
<tr><td><code id="aggrStrata2_+3A_model">model</code></td>
<td>

<p>Dataframe with the parameters of the model(s) to be used to calculate
anticipated variance.
Default is null.
</p>
</td></tr>
<tr><td><code id="aggrStrata2_+3A_vett">vett</code></td>
<td>

<p>vector of values indicating how the units in the dataset must 
be aggregated in strata.
</p>
</td></tr>	
<tr><td><code id="aggrStrata2_+3A_dominio">dominio</code></td>
<td>

<p>Value indicating the domain in the dataset to be processed.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe containing strata
</p>


<h3>Author(s)</h3>

<p>Giulio Barcaroli
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
strata &lt;- aggrStrata2(dataset=frame,
                      model=NULL,
                      vett,
                      dominio=1)

## End(Not run)
</code></pre>

<hr>
<h2 id='aggrStrataSpatial'>
Builds the &quot;strata&quot; dataframe containing information on target variables Y's
distributions in the different strata, starting from a frame where units are spatially correlated.
</h2><span id='topic+aggrStrataSpatial'></span>

<h3>Description</h3>

<p>This function builds the dataframe &quot;strata&quot; considering as input a given domain in the sampling frame. The variance in each stratum is calculated by considering also the component of spatial autocorrelation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggrStrataSpatial(dataset,
            fitting,
            range,
            kappa, 
            vett, 
            dominio)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggrStrataSpatial_+3A_dataset">dataset</code></td>
<td>

<p>This is the name of the dataframe containing the sample data, or the frame data. 
It is strictly required that auxiliary information is organised in variables named 
as X1, X2, ... , Xm (there should be at least one of them) and the target variables 
are denoted by Y1, Y2, ... , Yn.
In addition, in case of sample data, a variable named 'WEIGHT' must be present in the dataframe, 
containing   the weigths associated to each sampling unit
</p>
</td></tr>
<tr><td><code id="aggrStrataSpatial_+3A_fitting">fitting</code></td>
<td>

<p>Fitting of the model(s).
Default is 1.
</p>
</td></tr>
<tr><td><code id="aggrStrataSpatial_+3A_range">range</code></td>
<td>

<p>Maximum range for spatial autocorrelation
</p>
</td></tr>	
<tr><td><code id="aggrStrataSpatial_+3A_kappa">kappa</code></td>
<td>

<p>Factor used in evaluating spatial autocorrelation. 
Default is 3.
</p>
</td></tr>	
<tr><td><code id="aggrStrataSpatial_+3A_vett">vett</code></td>
<td>

<p>vector of values indicating how the units in the dataset must 
be aggregated in strata.
</p>
</td></tr>	
<tr><td><code id="aggrStrataSpatial_+3A_dominio">dominio</code></td>
<td>

<p>Value indicating the domain in the dataset to be processed.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe containing strata
</p>


<h3>Author(s)</h3>

<p>Giulio Barcaroli
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
strata &lt;- aggrStrataSpatial(dataset=frame,
                            fitting=1,
                            range=800,
                            kappa=1)

## End(Not run)
</code></pre>

<hr>
<h2 id='assignStrataLabel'>Function to assign the optimized strata labels</h2><span id='topic+assignStrataLabel'></span>

<h3>Description</h3>

<p>Function to assign the optimized strata labels to new sampling units in the frame
on the basis of the strata structure obtained by executing the function
'summaryStrata' after optimizing with 'optimizeStrata2'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assignStrataLabel(dataset, s)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assignStrataLabel_+3A_dataset">dataset</code></td>
<td>
<p>dataset with new sampling units in the frame</p>
</td></tr>
<tr><td><code id="assignStrataLabel_+3A_s">s</code></td>
<td>
<p>structure of the strata</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The same dataset in input with the label of the optimized stratum
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(SamplingStrata)
data("swissmunicipalities")
data("errors")
errors$CV1 &lt;- 0.1
errors$CV2 &lt;- 0.1
errors &lt;- errors[rep(row.names(errors),7),]
errors$domainvalue &lt;- c(1:7)
errors
swissmunicipalities$id &lt;- c(1:nrow(swissmunicipalities))
swissmunicipalities$domain = 1
frame &lt;- buildFrameDF(swissmunicipalities,
                      id = "id",
                      domainvalue = "REG",
                      X = c("Surfacesbois","Surfacescult"),
                      Y = c("Pop020", "Pop2040")
)
solution &lt;- optimizeStrata2 (
  errors, 
  frame,
  nStrata = 5,
  iter = 10, 
  pops = 10, 
  writeFiles = FALSE, 
  showPlot = TRUE, 
  parallel = FALSE) 
strataStructure &lt;- summaryStrata(solution$framenew, solution$aggr_strata)
strataStructure


newset &lt;- assignStrataLabel(solution$framenew,strataStructure)

## End(Not run)
</code></pre>

<hr>
<h2 id='bethel'>
Multivariate optimal allocation
</h2><span id='topic+bethel'></span>

<h3>Description</h3>

<p>Multivariate optimal allocation for different domains of interest in stratified sample design under a given stratification of the sampling frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bethel  (
          stratif,
          errors, 
          minnumstrat=2,          
          maxiter=200,
          maxiter1=25,
          printa=FALSE,
		  realAllocation=FALSE,
          epsilon=1e-11
          ) 
		  </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bethel_+3A_errors">errors</code></td>
<td>

<p>Data frame of coefficients of variation for each domain
</p>
</td></tr>
<tr><td><code id="bethel_+3A_stratif">stratif</code></td>
<td>

<p>Data frame of survey strata
</p>
</td></tr>
<tr><td><code id="bethel_+3A_minnumstrat">minnumstrat</code></td>
<td>

<p>Minimum number of units per strata (default=2) 
</p>
</td></tr>
<tr><td><code id="bethel_+3A_maxiter">maxiter</code></td>
<td>

<p>Maximum number of iterations of the algorithm (default=200)
</p>
</td></tr>
<tr><td><code id="bethel_+3A_maxiter1">maxiter1</code></td>
<td>

<p>Maximum number of iterations (default=25) of the general procedure. 
This kind of iteration may be required by the fact that when in a stratum the number 
of allocated units is greater or equal to its population, that stratum is set as &quot;census stratum&quot;, 
and the whole procedure is re-initialised 
</p>
</td></tr>
<tr><td><code id="bethel_+3A_printa">printa</code></td>
<td>

<p>If TRUE then two attributes are added to the resulting vector.
The first ('confr') is a comparison between results obtained with 3 different allocation methods: Bethel, proportional and equal.
The second ('outcv') is a table reporting planned and actual CV, together with a sensitivity analysis
</p>
</td></tr>
<tr><td><code id="bethel_+3A_realallocation">realAllocation</code></td>
<td>

<p>If FALSE, the allocation is based on INTEGER values; if TRUE, the allocation is based on REAL values
</p>
</td></tr>
<tr><td><code id="bethel_+3A_epsilon">epsilon</code></td>
<td>

<p>Epsilon (default=1e-11)): this value is used to compare the difference in results from one iteration to the other; 
if it it is lower than &quot;epsilon&quot;, then the procedure stops 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the computed optimal allocation
</p>


<h3>Author(s)</h3>

<p>Daniela Pagliuca with contributions from Teresa Buglielli and Giulio Barcaroli
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(SamplingStrata)
data(strata)
data(errors)
n &lt;- bethel(strata, errors, printa=TRUE)
sum(n)
attributes(n)$confr
attributes(n)$outcv

## End(Not run)
</code></pre>

<hr>
<h2 id='buildFrameDF'>
Builds the &quot;sampling frame&quot; dataframe from a dataset containing information on
all the units in the population of reference
</h2><span id='topic+buildFrameDF'></span>

<h3>Description</h3>

<p>This function allows to build the information regarding the sampling frame of the population of reference.
Mandatory variables are:
(i) the name of the dataset containing the sampling frame of the population of reference
(ii) an identifier (Id)
(iii) a set of auxiliary variables X
(iv) a set of target variables Y
(v) the indicator of the domain to which the unit belongs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildFrameDF(df, id, X, Y, domainvalue)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildFrameDF_+3A_df">df</code></td>
<td>

<p>This is the name of the dataframe containing the information
on all the units in population of reference. 
</p>
</td></tr>
<tr><td><code id="buildFrameDF_+3A_id">id</code></td>
<td>

<p>This is the name of the identifier in the sampling frame. 
</p>
</td></tr>
<tr><td><code id="buildFrameDF_+3A_x">X</code></td>
<td>

<p>A character vector containing the names of the auxiliary variables
in the frame dataset
</p>
</td></tr>
<tr><td><code id="buildFrameDF_+3A_y">Y</code></td>
<td>

<p>A character vector containing the names of the target variables
in the frame dataset
</p>
</td></tr>
<tr><td><code id="buildFrameDF_+3A_domainvalue">domainvalue</code></td>
<td>

<p>The name of the variable in the frame dataset that contains the 
indication of the domains to which the units belong.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe
</p>


<h3>Author(s)</h3>

<p>Giulio Barcaroli
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(swissmunicipalities)
id = "Nom"
X = c("Surfacesbois","Surfacescult")
Y = c("Pop020","Pop2040")
domainvalue = "REG"
frame &lt;- buildFrameDF(swissmunicipalities,id,X,Y,domainvalue)
head(frame)

## End(Not run)
</code></pre>

<hr>
<h2 id='buildFrameSpatial'>
Builds the &quot;sampling frame&quot; dataframe from a dataset containing information all the units in the population of reference including spatial
</h2><span id='topic+buildFrameSpatial'></span>

<h3>Description</h3>

<p>This function allows to build the information regarding the sampling frame of the population of reference.
Mandatory variables are:
(i) the name of the dataset containing the sampling frame of the population of reference
(ii) an identifier (Id)
(iii) a set of auxiliary variables 'X'
(iv) a set of target variables 'Y'
(v) a set of prediction errors variables 'variance'
(vi) longitude
(vii) latitude
(viii) the indicator of the domain to which the unit belongs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildFrameSpatial(df, id, X, Y, variance, lon, lat, domainvalue)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildFrameSpatial_+3A_df">df</code></td>
<td>

<p>This is the name of the dataframe containing the information
on all the units in population of reference. 
</p>
</td></tr>
<tr><td><code id="buildFrameSpatial_+3A_id">id</code></td>
<td>

<p>This is the name of the identifier in the sampling frame. 
</p>
</td></tr>
<tr><td><code id="buildFrameSpatial_+3A_x">X</code></td>
<td>

<p>A character vector containing the names of the auxiliary variables
in the frame dataset
</p>
</td></tr>
<tr><td><code id="buildFrameSpatial_+3A_y">Y</code></td>
<td>

<p>A character vector containing the names of the target variables
in the frame dataset
</p>
</td></tr>
<tr><td><code id="buildFrameSpatial_+3A_variance">variance</code></td>
<td>

<p>A character vector containing the names of the prediction error variables
in the frame dataset
</p>
</td></tr>
<tr><td><code id="buildFrameSpatial_+3A_lon">lon</code></td>
<td>

<p>Longitude of the unit
</p>
</td></tr>
<tr><td><code id="buildFrameSpatial_+3A_lat">lat</code></td>
<td>

<p>Latitude of the unit
</p>
</td></tr>
<tr><td><code id="buildFrameSpatial_+3A_domainvalue">domainvalue</code></td>
<td>

<p>The name of the variable in the frame dataset that contains the 
indication of the domains to which the units belong.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe
</p>


<h3>Author(s)</h3>

<p>Giulio Barcaroli
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sp)
library(gstat)
library(automap)
library(SamplingStrata)
data("meuse")
data("meuse.grid")
meuse.grid$id &lt;- c(1:nrow(meuse.grid))
coordinates(meuse)&lt;-c("x","y")
coordinates(meuse.grid)&lt;-c("x","y")
#################
# kriging
#################
v &lt;- variogram(lead ~ dist + soil, data=meuse)
fit.vgm &lt;- autofitVariogram(lead ~ elev + soil, meuse, model = "Exp")
plot(v, fit.vgm$var_model)
fit.vgm$var_model
g &lt;- NULL
g &lt;- gstat(g, "Pb", lead ~ dist + soil, meuse)
g
vm &lt;- variogram(g)
vm.fit &lt;- fit.lmc(vm, g, vgm(psill=fit.vgm$var_model$psill[2], 
                             model="Exp", range=fit.vgm$var_model$range[2], 
                             nugget=fit.vgm$var_model$psill[1]))
# Prediction on the whole grid
preds &lt;- predict(vm.fit, meuse.grid)
names(preds)
# [1] "Pb.pred" "Pb.var"
preds$Pb.pred &lt;- ifelse(preds$Pb.pred &lt; 0,0,preds$Pb.pred)
df &lt;- NULL
df$id &lt;- meuse.grid$id
df$Pb.pred &lt;- preds@data$Pb.pred
df$Pb.var &lt;- preds@data$Pb.var
df$lon &lt;- meuse.grid$x
df$lat &lt;- meuse.grid$y
df$dom1 &lt;- 1
df &lt;- as.data.frame(df)
frame &lt;- buildFrameSpatial(df=df,
                      id="id",
                      X=c("Pb.pred"),
                      Y=c("Pb.pred"),
                      variance=c("Pb.var"),
                      lon="lon",
                      lat="lat",
                      domainvalue = "dom1")
head(frame)

## End(Not run)
</code></pre>

<hr>
<h2 id='buildStrataDF'>
Builds the &quot;strata&quot; dataframe containing information on target variables Y's
distributions in the different strata, starting from sample data or from a frame 
</h2><span id='topic+buildStrataDF'></span>

<h3>Description</h3>

<p>This function allows to build the information regarding strata in the population required as
an input by the algorithm of Bethel for the optimal allocation.
In order to estimate means and standard deviations for target variables Y's, we need data coming from:
(1) a previous round of the survey whose sample we want to plan;
(2) sample data from a survey with variables that are proxy to the ones we are interested to;
(3) a frame containing values of Y's variables (or proxy variables) for all the population.
In all cases, each unit in the dataset must contain auxiliary information (X's variables)
and also target variables Y's (or proxy variables) values: under these conditions it is possible 
to build the dataframe &quot;strata&quot;, containing information on the distribution of Y's in the different strata 
(namely, means and standard deviations), together with information on strata (total population, 
if it is to be censused or not, the cost per single interview).
If the information is contained in a sample dataset, a variable named WEIGHT is expected to be 
present. In case of a frame, no such variable is given, and the function will define a WEIGHT variable
for each unit, whose value is always '1'.
Missing values for each Y variable will not be taken into account in the computation of means and standard 
deviations (in any case, NA's can be present in the dataset).
The dataframe &quot;strata&quot; is written to an external file (tab delimited, extension &quot;txt&quot;), and will be
used as an input by the function &quot;optimizeStrata&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildStrataDF(dataset,
              model=NULL,
              progress=TRUE,
              verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildStrataDF_+3A_dataset">dataset</code></td>
<td>

<p>This is the name of the dataframe containing the sample data, or the frame data. 
It is strictly required that auxiliary information is organised in variables named 
as X1, X2, ... , Xm (there should be at least one of them) and the target variables 
are denoted by Y1, Y2, ... , Yn.
In addition, in case of sample data, a variable named 'WEIGHT' must be present in the dataframe, 
containing   the weigths associated to each sampling unit
</p>
</td></tr>
<tr><td><code id="buildStrataDF_+3A_model">model</code></td>
<td>

<p>In case the Y variables are not directly observed, but are estimated by means of other explicative variables, in order
to compute the anticipated variance, information on models are given by a dataframe &quot;model&quot; with as many rows as the
target variables. Each row contains the indication if the model is linear o loglinear, and the values of the model parameters 
beta, sig2, gamma (&gt; 1 in case of heteroscedasticity). 
Default is NULL.
</p>
</td></tr>
<tr><td><code id="buildStrataDF_+3A_progress">progress</code></td>
<td>

<p>If set to TRUE, a progress bar is visualised during the execution. Default is TRUE.
</p>
</td></tr>
<tr><td><code id="buildStrataDF_+3A_verbose">verbose</code></td>
<td>

<p>If set to TRUE, information is given about the number of strata generated. Default is TRUE.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe containing strata
</p>


<h3>Author(s)</h3>

<p>Giulio Barcaroli
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Plain example without model
data(swissframe)
strata &lt;- buildStrataDF(dataset=swissframe,model=NULL)
head(strata)

# More complex example with models
library(SamplingStrata)
data(swissmunicipalities)
swiss &lt;- swissmunicipalities[,c("HApoly","Surfacesbois","Airind","POPTOT")]
Y1 = swiss$Surfacesbois
X1 = swiss$HApoly
mod1 &lt;- lm( Y1 ~ X1 )
summary(mod1)
mod1$coefficients[2]
summary(mod1)$sigma

Y2 = swiss$Airind
X2 = swiss$POPTOT
plot(log(X2[X2&gt;0]),log(Y2[X2&gt;0]))
mod2 &lt;- lm( log(Y2[X2 &gt; 0 &amp; Y2&gt;0]) ~ log(X2[X2 &gt; 0 &amp; Y2&gt;0]) )
summary(mod2)
mod2$coefficients[2]
summary(mod2)$sigma

swiss$id &lt;- c(1:nrow(swiss))
swiss$dom &lt;- 1
frame &lt;- buildFrameDF(swiss,id="id",X="id",Y=c("HApoly","POPTOT"),domainvalue="dom")

model &lt;- NULL
model$type[1] &lt;- "linear"
model$beta[1] &lt;- mod1$coefficients[2]
model$sig2[1] &lt;- summary(mod1)$sigma
model$gamma[1] = 2
model$type[2] &lt;- "loglinear"
model$beta[2] &lt;- mod2$coefficients[2]
model$sig2[2] &lt;- summary(mod2)$sigma
model$gamma[2] = NA
model &lt;- as.data.frame(model)

strata &lt;- buildStrataDF(dataset=frame, model=model)

## End(Not run)
</code></pre>

<hr>
<h2 id='buildStrataDFSpatial'>
Builds the &quot;strata&quot; dataframe containing information on target variables Y's
distributions in the different strata, starting from sample data or from a frame
</h2><span id='topic+buildStrataDFSpatial'></span>

<h3>Description</h3>

<p>This function allows to build the information regarding strata in the population required as
an input by the algorithm of Bethel for the optimal allocation.
In order to estimate means and standard deviations for target variables Y's, we need data coming from:
(1) a previous round of the survey whose sample we want to plan;
(2) sample data from a survey with variables that are proxy to the ones we are interested to;
(3) a frame containing values of Y's variables (or proxy variables) for all the population.
In all cases, each unit in the dataset must contain auxiliary information (X's variables)
and also target variables Y's (or proxy variables) values: under these conditions it is possible 
to build the dataframe &quot;strata&quot;, containing information on the distribution of Y's in the different strata 
(namely, means and standard deviations), together with information on strata (total population, 
if it is to be censused or not, the cost per single interview).
If the information is contained in a sample dataset, a variable named WEIGHT is expected to be 
present. In case of a frame, no such variable is given, and the function will define a WEIGHT variable
for each unit, whose value is always '1'.
Missing values for each Y variable will not be taken into account in the computation of means and standard 
deviations (in any case, NA's can be present in the dataset).
The dataframe &quot;strata&quot; is written to an external file (tab delimited, extension &quot;txt&quot;), and will be
used as an input by the function &quot;optimizeStrata&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildStrataDFSpatial(dataset,
                     fitting=c(1),
                     range=c(0),
                     kappa=3,
                     progress=FALSE,
                     verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildStrataDFSpatial_+3A_dataset">dataset</code></td>
<td>

<p>This is the name of the dataframe containing the sample data, or the frame data. 
It is strictly required that auxiliary information is organised in variables named 
as X1, X2, ... , Xm (there should be at least one of them) and the target variables 
are denoted by Y1, Y2, ... , Yn.
In addition, in case of sample data, a variable named 'WEIGHT' must be present in the dataframe, 
containing   the weigths associated to each sampling unit
</p>
</td></tr>
<tr><td><code id="buildStrataDFSpatial_+3A_fitting">fitting</code></td>
<td>

<p>Fitting of the model(s).
Default is 1.
</p>
</td></tr>
<tr><td><code id="buildStrataDFSpatial_+3A_range">range</code></td>
<td>

<p>Maximum range for spatial autocorrelation
</p>
</td></tr>	
<tr><td><code id="buildStrataDFSpatial_+3A_kappa">kappa</code></td>
<td>

<p>Factor used in evaluating spatial autocorrelation. 
Default is 3.
</p>
</td></tr>	
<tr><td><code id="buildStrataDFSpatial_+3A_progress">progress</code></td>
<td>

<p>If set to TRUE, a progress bar is visualised during the execution. Default is FALSE.
</p>
</td></tr>
<tr><td><code id="buildStrataDFSpatial_+3A_verbose">verbose</code></td>
<td>

<p>If set to TRUE, information is given about the number of strata generated. Default is FALSE.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe containing strata
</p>


<h3>Author(s)</h3>

<p>Giulio Barcaroli
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
strata &lt;- buildStrataDFSpatial(dataset=frame,range=800)

## End(Not run)
</code></pre>

<hr>
<h2 id='checkInput'>
Checks the inputs to the package: dataframes &quot;errors&quot;, &quot;strata&quot; and &quot;sampling frame&quot;
</h2><span id='topic+checkInput'></span>

<h3>Description</h3>

<p>This functions checks the internal structure of the different input dataframes (&quot;errors&quot;, &quot;strata&quot; and &quot;sampling frame&quot;), 
and also the correctness of the relationships among them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkInput(errors=NULL, strata=NULL, sampframe=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkInput_+3A_errors">errors</code></td>
<td>

<p>Dataframe containing the precision levels expressed in terms of 
maximum acceptable coefficients of variation that 
estimates of target variables Y's of the survey must comply. 
</p>
</td></tr>
<tr><td><code id="checkInput_+3A_strata">strata</code></td>
<td>

<p>Dataframe containing the information related to strata.
</p>
</td></tr>
<tr><td><code id="checkInput_+3A_sampframe">sampframe</code></td>
<td>

<p>Dataframe containing the information related to all the units belonging to the population of interest.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Giulio Barcaroli
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(SamplingStrata)
data(swisserrors)
data(swissstrata)
data(swissframe)
checkInput(swisserrors,swissstrata,swissframe)
checkInput(strata=swissstrata,sampframe=swissframe)
checkInput(strata=swissstrata)

## End(Not run)
</code></pre>

<hr>
<h2 id='computeGamma'>
Function that allows to calculate a heteroscedasticity index,
together with associate prediction variance,
to be used by the optimization step 
to correctly evaluate the standard deviation in the strata
due to prediction errors.
</h2><span id='topic+computeGamma'></span>

<h3>Description</h3>

<p>When the anticipated variance has to be calculated during the execution
of the optimization step, his function allows to calculate a heteroscedasticity index,
together with associate prediction variance,
to be used to correctly evaluate the variance in the strata.
The function returns a list where the first object is the heteroscedasticity index and the 
second is the associated standard deviation in the strata
due to prediction errors. 
The two parameters are calculated in this way:
(i) residuals 'e' are grouped in clusters defined by values of the explanatory variable 'x';
(ii) a model is fitted by considering log(e) and log(mean(x)) values;
(iii) the intercept is the value of standard deviation of residuals;
(iv) the slope is the value of the heteroscedasticity index.
These two values can be passed as parameters of the model, or used to calculate
prediction errors for ach unit in the frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeGamma(e,x,nbins,showPlot)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeGamma_+3A_e">e</code></td>
<td>

<p>This is the variable that contains prediction errors (residuals) of the model.
</p>
</td></tr>
<tr><td><code id="computeGamma_+3A_x">x</code></td>
<td>

<p>This is the variable that contains explanatory variable in the model.
</p>
</td></tr>
<tr><td><code id="computeGamma_+3A_nbins">nbins</code></td>
<td>

<p>Number of bins to be passed to the 'var.bin' function. Default is 6.
</p>
</td></tr>
<tr><td><code id="computeGamma_+3A_showplot">showPlot</code></td>
<td>

<p>Visualization of plots. Default is TRUE.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing: (i) the value of the heteroscedasticity index, (ii) associated standard deviation, (iii) R^2 of the interpolating model.
</p>


<h3>Author(s)</h3>

<p>Marco Ballin, Giulio Barcaroli 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("swissmunicipalities")
swiss_sample &lt;- swissmunicipalities[sample(c(1:nrow(swissmunicipalities)),500),]
mod_Airind_POPTOT &lt;- lm(swiss_sample$Airind ~ swiss_sample$POPTOT)
computeGamma(mod_Airind_POPTOT$residuals,
             swiss_sample$POPTOT,
             nbins = 8)
#     gamma     sigma  r.square 
# 0.8029292 0.0150446 0.9598539

## End(Not run)
</code></pre>

<hr>
<h2 id='errors'>
Precision constraints (maximum CVs) as input for Bethel allocation
</h2><span id='topic+errors'></span>

<h3>Description</h3>

<p>Dataframe containing precision levels (expressed in terms of acceptable CV's)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(errors)</code></pre>


<h3>Format</h3>

<p>The constraint data frame (errors) contains a row per each domain value with the following variables: 
</p>

<dl>
<dt>DOM</dt><dd>
<p>Type of domain code (factor)
</p>
</dd> 
<dt>CV1</dt><dd>
<p>Planned coefficient of variation for first variable Y1 (numeric)
</p>
</dd> 
<dt>CVj</dt><dd>
<p>Planned coefficient of variation for j-th variable Yj (numeric)
</p>
</dd>
<dt>CVn</dt><dd>
<p>Planned coefficient of variation for last variable Yn (numeric)
</p>
</dd> 
<dt>domainvalue</dt><dd>
<p>Value of the domain to which the constraints refer (numeric)
</p>
</dd>
</dl>



<h3>Details</h3>

<p>Note: the names of the variables must be the ones indicated above
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## data(errors)
## errors
</code></pre>

<hr>
<h2 id='evalSolution'>
Evaluation of the solution produced by the function 'optimizeStrata' by
selecting a number of samples from the frame with the optimal stratification, and calculating average CV's on the target variables Y's.
</h2><span id='topic+evalSolution'></span>

<h3>Description</h3>

<p>The user can indicate the number of samples that must be selected by the optmized frame. First, the true values of the parameters are calculated from the frame. Then, for each sample the sampling estimates are calculated, together with the differences between them and the true values of the parameters.
At the end, an estimate of the CV is produced for each target variable, in order to compare them
with the precision constraints set at the beginning of the optimization process.
If the flag 'writeFiles' is set to TRUE, boxplots of distribution of the CV's in the different 
domains are produced for each Y variable ('cv.pdf'),
together with boxplot of the distributions of differences between estimates and values of the parameters
in the population ('differences.pdf').
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evalSolution(frame,
		outstrata,
		nsampl=100,
		cens=NULL,
		writeFiles=TRUE,
		progress=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evalSolution_+3A_frame">frame</code></td>
<td>

<p>The frame to which the optimal stratification has been applied.
</p>
</td></tr>
<tr><td><code id="evalSolution_+3A_outstrata">outstrata</code></td>
<td>

<p>The new (aggregated) strata generated by the function 'optimizeStrata'.
</p>
</td></tr>
<tr><td><code id="evalSolution_+3A_nsampl">nsampl</code></td>
<td>

<p>The number of samples to be drawn from the frame.
</p>
</td></tr>
<tr><td><code id="evalSolution_+3A_cens">cens</code></td>
<td>

<p>A dataframe containing units to be selected in any cases.
</p>
</td></tr>
<tr><td><code id="evalSolution_+3A_writefiles">writeFiles</code></td>
<td>

<p>A flag to write in the work directory the outputs of the function. Default is TRUE.
</p>
</td></tr>
<tr><td><code id="evalSolution_+3A_progress">progress</code></td>
<td>

<p>If set to TRUE, a progress bar is visualised during the execution. Default is TRUE.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing (i) the CV distribution in the domains, (ii) the bias distribution in the domains, (iii) the dataframe containing the sampling
estimates by domain
</p>


<h3>Author(s)</h3>

<p>Giulio Barcaroli
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(SamplingStrata)
data(swisserrors)
data(swissstrata)
solution &lt;- optimizeStrata (
	errors = swisserrors,
	strata = swissstrata,
)
# update sampling strata with new strata labels
newstrata &lt;- updateStrata(swissstrata, solution, writeFiles = TRUE)
# update sampling frame with new strata labels
data(swissframe)
framenew &lt;- updateFrame(frame=swissframe,newstrata=newstrata,writeFile=TRUE)
samp &lt;- selectSample(framenew,solution$aggr_strata,writeFiles=TRUE)
# evaluate the current solution
results &lt;- evalSolution(framenew, solution$aggr_strata, 10, cens=NULL, writeFiles = TRUE)
results$coeff_var
results$rel_bias

## End(Not run)
</code></pre>

<hr>
<h2 id='expected_CV'>
Expected coefficients of variation of target variables Y
</h2><span id='topic+expected_CV'></span>

<h3>Description</h3>

<p>Once optimized the sampling frame, this function allows to calculate the expected coefficients of variation on the aggregated strata of the current optimized solution, and to compare them to the precision constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expected_CV(strata)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expected_CV_+3A_strata">strata</code></td>
<td>

<p>Aggregated strata in the solution obtained by the execution of the 'optimizedStrata' function
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix containing values of the CV's in the different domains
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(SamplingStrata)
data(swisserrors)
data(swissstrata)
# optimisation of sampling strata
solution &lt;- optimizeStrata ( 
    errors = swisserrors, 
    strata = swissstrata, 
)
# calculate CV's on Y's
expected_CV(solution$aggr_strata)
# compare to precision constraints
swisserrors

## End(Not run)
</code></pre>

<hr>
<h2 id='KmeansSolution'>
Initial solution obtained by applying kmeans clustering of atomic strata
</h2><span id='topic+KmeansSolution'></span>

<h3>Description</h3>

<p>In order to speed the convergence towards the optimal solution, an initial one can be 
given as &quot;suggestion&quot; to &quot;optimizeStrata&quot; function.
The function &quot;KmeansSolution&quot; produces this initial solution using the k-means 
algorithm by clustering atomic 
strata on the basis of the values of the means of target variables in them.
Also, if the parameter &quot;nstrata&quot; is not indicated, the optimal number of clusters 
is determined inside each domain, and the overall solution is obtained by concatenating optimal 
clusters obtained in domains.
The result is a dataframe with two columns: the first indicates the clusters, 
the second the domains.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KmeansSolution(strata, 
               errors, 
               nstrata=NA, 
			         minnumstrat=2,
               maxclusters = NA,
               showPlot=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KmeansSolution_+3A_strata">strata</code></td>
<td>

<p>The (mandatory) dataframe containing the information related to atomic strata.
</p>
</td></tr>
<tr><td><code id="KmeansSolution_+3A_errors">errors</code></td>
<td>

<p>The (mandatory) dataframe containing the precision constraints on target variables.
</p>
</td></tr>
<tr><td><code id="KmeansSolution_+3A_nstrata">nstrata</code></td>
<td>

<p>Number of aggregate strata (if NULL, it is optimized by varying the number of cluster
from 2 to half number of atomic strata). Default is NA.
</p>
</td></tr>
<tr><td><code id="KmeansSolution_+3A_minnumstrat">minnumstrat</code></td>
<td>

<p>Minimum number of units to be selected in each stratum. Default is 2.
</p>
</td></tr>
<tr><td><code id="KmeansSolution_+3A_maxclusters">maxclusters</code></td>
<td>

<p>Maximum number of clusters to be considered in the 
execution of kmeans algorithm. If not indicated it will be set equal to the
number of atomic strata divided by 2.
</p>
</td></tr>
<tr><td><code id="KmeansSolution_+3A_showplot">showPlot</code></td>
<td>

<p>Allows to visualise on a plot the different sample sizes for each number of aggregate strata. Default is TRUE.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe containing the solution
</p>


<h3>Author(s)</h3>

<p>Giulio Barcaroli 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(SamplingStrata)
data(swisserrors)
data(swissstrata)

# suggestion
solutionKmean &lt;- KmeansSolution(strata=swissstrata,
								errors=swisserrors,
								nstrata=NA,
								showPlot=TRUE)

# number of strata to be obtained in each domain		
nstrat &lt;- tapply(solutionKmean$suggestions,
                 solutionKmean$domainvalue,
                 FUN=function(x) length(unique(x)))

# optimisation of sampling strata
solution &lt;- optimStrata ( 
  method = "atomic",
  errors = swisserrors, 
  strata = swissstrata,
  nStrata = nstrat,
  suggestions = solutionKmean
)

## End(Not run)
</code></pre>

<hr>
<h2 id='KmeansSolution2'>
Initial solution obtained by applying kmeans clustering of frame units
</h2><span id='topic+KmeansSolution2'></span>

<h3>Description</h3>

<p>This function has to be used only in conjunction with &quot;optimizeStrata2&quot;, 
or with &quot;optimStrata&quot; when method = &quot;continuous&quot;, i.e. in the
case of optimizing with only continuous stratification variables.
The function &quot;KmeansSolution2&quot; has a twofold objective:
- to give indication about a possible best number of final strata (by fixing a 
convenient value for &quot;maxclusters&quot;, and leaving NA to &quot;nstrata&quot;;
- to give an initial solution fo the optimization step.
If the parameter &quot;nstrata&quot; is not indicated, the optimal number of clusters 
is determined inside each domain, and the overall solution is obtained by concatenating optimal 
clusters obtained in domains.
The result is a dataframe with two columns: the first indicates the clusters, 
the second the domains.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KmeansSolution2(frame,
                model=NULL,
                errors,
                nstrata = NA,
                minnumstrat =2,
                maxclusters = NA,
                showPlot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KmeansSolution2_+3A_frame">frame</code></td>
<td>

<p>The (mandatory) dataframe containing the information related to each unit in the sampling frame.
</p>
</td></tr>
<tr><td><code id="KmeansSolution2_+3A_model">model</code></td>
<td>

<p>The (optional) dataframe containing the information related to models used to predict
values of the target variables.
</p>
</td></tr>
<tr><td><code id="KmeansSolution2_+3A_errors">errors</code></td>
<td>

<p>The (mandatory) dataframe containing the precision constraints on target variables.
</p>
</td></tr>
<tr><td><code id="KmeansSolution2_+3A_nstrata">nstrata</code></td>
<td>

<p>Number of aggregate strata (if NULL, it is optimized by varying the number of cluster
from 2 to half number of atomic strata). Default is NA.
</p>
</td></tr>
<tr><td><code id="KmeansSolution2_+3A_minnumstrat">minnumstrat</code></td>
<td>

<p>Minimum number of units to be selected in each stratum. Default is 2.
</p>
</td></tr>
<tr><td><code id="KmeansSolution2_+3A_maxclusters">maxclusters</code></td>
<td>

<p>Maximum number of clusters to be considered in the 
execution of kmeans algorithm. If not indicated it will be set equal to the
number of atomic strata divided by 2.
</p>
</td></tr>
<tr><td><code id="KmeansSolution2_+3A_showplot">showPlot</code></td>
<td>

<p>Allows to visualise on a plot the different sample sizes for each number of aggregate strata. Default is TRUE.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe containing the solution
</p>


<h3>Author(s)</h3>

<p>Giulio Barcaroli 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(SamplingStrata)
data("swissmunicipalities")
swissmunicipalities$id &lt;- c(1:nrow(swissmunicipalities))
swissmunicipalities$dom &lt;- 1
frame &lt;- buildFrameDF(swissmunicipalities,
                      id = "id",
                      domainvalue = "REG",
                      X = c("Pop020", "Pop2040"),
                      Y = c("Pop020", "Pop2040")
)
cv &lt;- NULL
cv$DOM &lt;- "DOM1"
cv$CV1 &lt;- 0.1
cv$CV2 &lt;- 0.1
cv &lt;- as.data.frame(cv)
cv &lt;- cv[rep(row.names(cv),7),]
cv$domainvalue &lt;- c(1:7)
cv

# Solution with kmean clustering 
kmean &lt;- KmeansSolution2(frame,model=NULL,errors=cv,nstrata=NA,maxclusters=4)
# number of strata to be obtained in each domain in final solution	
nstrat &lt;- tapply(solutionKmean$suggestions,
                 solutionKmean$domainvalue,
                 FUN=function(x) length(unique(x)))
# Prepare suggestion for optimization
sugg &lt;- prepareSuggestion(kmean,frame,nstrat)
# Optimization
# Attention: number of strata must be the same than in kmeans
solution &lt;- optimStrata (
  method = "continuous",
  cv, 
  framesamp=frame,
  iter = 50,
  pops = 20,
  nStrata = nstrat,
  suggestions = sugg,
  writeFiles = FALSE,
  showPlot = FALSE,
  parallel = FALSE
)

## End(Not run)
</code></pre>

<hr>
<h2 id='KmeansSolutionSpatial'>
Initial solution obtained by applying kmeans clustering of frame units
</h2><span id='topic+KmeansSolutionSpatial'></span>

<h3>Description</h3>

<p>This function has to be used only in conjunction with &quot;optimizeStrataSpatial&quot;, i.e. in the
case of optimizing with only continuous stratification variables
and with a component of spatial autocorrelation.
The function &quot;KmeansSolutionSpatial&quot; has a twofold objective:
- to give indications about a possible best number of final strata (by fixing a 
convenient value for &quot;maxclusters&quot;, and leaving NA to &quot;nstrata&quot;;
- to give an initial solution fo the optimization step.
If the parameter &quot;nstrata&quot; is not indicated, the optimal number of clusters 
is determined inside each domain, and the overall solution is obtained by concatenating optimal 
clusters obtained in domains.
The result is a dataframe with two columns: the first indicates the clusters, 
the second the domains.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KmeansSolutionSpatial(frame, 
                    fitting = 1, 
                    range = c(0), 
                    kappa = 3, 
                    errors, 
                    nstrata = NA, 
                    minnumstrat = 2, 
                    maxclusters = NA, 
                    showPlot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KmeansSolutionSpatial_+3A_frame">frame</code></td>
<td>

<p>The (mandatory) dataframe containing the information related to each unit in the sampling frame.
</p>
</td></tr>
<tr><td><code id="KmeansSolutionSpatial_+3A_fitting">fitting</code></td>
<td>

<p>Fitting of the model(s).
Default is 1.
</p>
</td></tr>
<tr><td><code id="KmeansSolutionSpatial_+3A_range">range</code></td>
<td>

<p>Maximum range for spatial autocorrelation
</p>
</td></tr>	
<tr><td><code id="KmeansSolutionSpatial_+3A_kappa">kappa</code></td>
<td>

<p>Factor used in evaluating spatial autocorrelation. 
Default is 3.
</p>
</td></tr>	
<tr><td><code id="KmeansSolutionSpatial_+3A_errors">errors</code></td>
<td>

<p>The (mandatory) dataframe containing the precision constraints on target variables.
</p>
</td></tr>
<tr><td><code id="KmeansSolutionSpatial_+3A_nstrata">nstrata</code></td>
<td>

<p>Number of aggregate strata (if NULL, it is optimized by varying the number of cluster
from 2 to half number of atomic strata). Default is NA.
</p>
</td></tr>
<tr><td><code id="KmeansSolutionSpatial_+3A_minnumstrat">minnumstrat</code></td>
<td>

<p>Minimum number of units to be selected in each stratum. Default is 2.
</p>
</td></tr>
<tr><td><code id="KmeansSolutionSpatial_+3A_maxclusters">maxclusters</code></td>
<td>

<p>Maximum number of clusters to be considered in the 
execution of kmeans algorithm. If not indicated it will be set equal to the
number of atomic strata divided by 2.
</p>
</td></tr>
<tr><td><code id="KmeansSolutionSpatial_+3A_showplot">showPlot</code></td>
<td>

<p>Allows to visualise on a plot the different sample sizes for each number of aggregate strata. Default is TRUE.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe containing the solution
</p>


<h3>Author(s)</h3>

<p>Giulio Barcaroli 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sp)
library(gstat)
library(automap)
library(SamplingStrata)
#################
# data
#################
# locations (155 observed points)
data("meuse")
# grid of points (3103)
data("meuse.grid")
meuse.grid$id &lt;- c(1:nrow(meuse.grid))
coordinates(meuse)&lt;-c("x","y")
coordinates(meuse.grid)&lt;-c("x","y")
#################
# kriging
#################
v &lt;- variogram(lead ~ dist + soil, data=meuse)
fit.vgm &lt;- autofitVariogram(lead ~ elev + soil, meuse, model = "Exp")
plot(v, fit.vgm$var_model)
fit.vgm$var_model
# model    psill    range
# 1   Nug 1524.895   0.0000
# 2   Exp 8275.431 458.3303
g &lt;- NULL
g &lt;- gstat(g, "Pb", lead ~ dist + soil, meuse)
g
vm &lt;- variogram(g)
vm.fit &lt;- fit.lmc(vm, g, vgm(psill=fit.vgm$var_model$psill[2], 
                  model="Exp", range=fit.vgm$var_model$range[2], 
                  nugget=fit.vgm$var_model$psill[1]))
# Prediction on the whole grid
preds &lt;- predict(vm.fit, meuse.grid)
names(preds)
# [1] "Pb.pred" "Pb.var"
preds$Pb.pred &lt;- ifelse(preds$Pb.pred &lt; 0,0,preds$Pb.pred)
df &lt;- NULL
df$Pb.pred &lt;- preds@data$Pb.pred
df$Pb.var &lt;- preds@data$Pb.var
df$dom1 &lt;- 1
df &lt;- as.data.frame(df)
df$id &lt;- meuse.grid$id
#####################################
# Optimization with kmeans clustering
#####################################
frame &lt;- buildFrameDF(df=df,
                      id="id",
                      X=c("Pb.pred"),
                      Y=c("Pb.pred"),
                      domainvalue = "dom1")
frame$var1 &lt;- df$Pb.var
frame$lon &lt;- meuse.grid$x
frame$lat &lt;- meuse.grid$y
cv &lt;- as.data.frame(list(DOM=rep("DOM1",1),
                         CV1=rep(0.05,1),
                         domainvalue=c(1:1) ))
km &lt;- KmeansSolutionSpatial(frame,
                            errors = cv,
                            fitting = 1,
                            range = fit.vgm$var_model$range[2],
                            kappa=1,
                            nstrata=NA,
                            maxclusters = 5)
############################
# Analysis and visualization
############################
strataKm &lt;- aggrStrataSpatial(dataset=frame,
                        fitting = 1,
                        range = fit.vgm$var_model$range[2],
                        kappa=1,
                        vett=km$suggestions,
                        dominio=1)
strataKm$SOLUZ &lt;- bethel(strataKm,cv)
sum(strataKm$SOLUZ)
framenew &lt;- frame
framenew$LABEL &lt;- km$suggestions
strataKm$STRATO &lt;- strataKm$stratum
ssKm &lt;- summaryStrata(framenew,strataKm)
ssKm
frameres &lt;- SpatialPointsDataFrame(data=framenew, 
                                   coords=cbind(framenew$lon,framenew$lat) )
frameres2 &lt;- SpatialPixelsDataFrame(points=frameres[c("lon","lat")], 
                                    data=framenew)
frameres2$LABEL &lt;- as.factor(frameres2$LABEL)
spplot(frameres2,c("LABEL"), col.regions=bpy.colors(5))

## End(Not run)
</code></pre>

<hr>
<h2 id='nations'>Dataset 'nations'</h2><span id='topic+nations'></span>

<h3>Description</h3>

<p>Dataset containing data on 207 countries (from 'nations.txt' in Rcmdr, with missing values imputed)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(nations)</code></pre>


<h3>Format</h3>

<p>A data frame with 207 observations on the following variables:
</p>

<dl>
<dt>Country</dt><dd><p>Name of the country</p>
</dd>
<dt>TFR</dt><dd><p>Total Fertility Rate</p>
</dd>
<dt>contraception</dt><dd><p>Rate of women making use of contraceptive means</p>
</dd>
<dt>infant.mortality</dt><dd><p>Infant mortality rate</p>
</dd>
<dt>GDP</dt><dd><p>Gross Domestic Product ($ per capita)</p>
</dd>
<dt>region</dt><dd><p>Continent (description)</p>
</dd>
<dt>Continent</dt><dd><p>Continent (code)</p>
</dd>
</dl>



<h3>Source</h3>

<p>Rcmdr package
</p>

<hr>
<h2 id='optimizeStrata'>
Best stratification of a sampling frame for multipurpose surveys
</h2><span id='topic+optimizeStrata'></span>

<h3>Description</h3>

<p>This function runs a set of other functions to optimise the stratification of a sampling frame 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	optimizeStrata(
	errors , 
	strata , 
	cens = NULL, 
	strcens = FALSE,
	alldomains = TRUE,
	dom = NULL,	
	initialStrata = NA, 
	addStrataFactor = 0.0, 
	minnumstr = 2, 
	iter = 50, 
	pops = 20, 
	mut_chance = NA, 
	elitism_rate = 0.2,
	highvalue = 1e+08, 
	suggestions = NULL,
	realAllocation = TRUE,
	writeFiles = FALSE,
	showPlot = TRUE, 
	parallel = TRUE,
	cores
	)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimizeStrata_+3A_errors">errors</code></td>
<td>

<p>This is the (mandatory) dataframe containing the precision levels expressed in terms of maximum expected value of the Coefficients of Variation
related to target variables of the survey.
</p>
</td></tr>
<tr><td><code id="optimizeStrata_+3A_strata">strata</code></td>
<td>

<p>This is the (mandatory) dataframe containing the information related to &quot;atomic&quot; strata, i.e. the strata obtained by 
the Cartesian product of all auxiliary variables X's. Information concerns the identifiability of strata
(values of X's) and variability of Y's (for each Y, mean and standard error in strata).
</p>
</td></tr>
<tr><td><code id="optimizeStrata_+3A_cens">cens</code></td>
<td>

<p>This the (optional) dataframe containing the takeall strata, those strata whose units must be selected in whatever sample. It has same structure than &quot;strata&quot; dataframe.
</p>
</td></tr>
<tr><td><code id="optimizeStrata_+3A_strcens">strcens</code></td>
<td>

<p>Flag (TRUE/FALSE) to indicate if takeall strata do exist or not. Default is FALSE.
</p>
</td></tr>
<tr><td><code id="optimizeStrata_+3A_alldomains">alldomains</code></td>
<td>

<p>Flag (TRUE/FALSE) to indicate if the optimization must be carried out on all domains (default is TRUE). If it is set to FALSE,
then a value must be given to parameter 'dom'.
</p>
</td></tr>
<tr><td><code id="optimizeStrata_+3A_dom">dom</code></td>
<td>

<p>Indicates the domain on which the optimization must be carried. It is an integer value that has to be internal to the interval 
(1 &lt;&ndash;&gt; number of domains). If 'alldomains' is set to TRUE, it is ignored.
</p>
</td></tr>
<tr><td><code id="optimizeStrata_+3A_initialstrata">initialStrata</code></td>
<td>

<p>This is the initial limit on the number of strata in the different domains for each solution. Default is NA, and in this case it is set equal to the
number of atomic strata in each domain.
</p>
</td></tr>
<tr><td><code id="optimizeStrata_+3A_addstratafactor">addStrataFactor</code></td>
<td>

<p>This parameter indicates the probability that at each mutation the number of strata may increase with 
respect to the current value. Default is 0.0.
</p>
</td></tr>
<tr><td><code id="optimizeStrata_+3A_minnumstr">minnumstr</code></td>
<td>

<p>Indicates the minimum number of units that must be allocated in each stratum. Default is 2.
</p>
</td></tr>
<tr><td><code id="optimizeStrata_+3A_iter">iter</code></td>
<td>

<p>Indicated the maximum number of iterations (= generations) of the genetic algorithm. Default is 50.
</p>
</td></tr>
<tr><td><code id="optimizeStrata_+3A_pops">pops</code></td>
<td>

<p>The dimension of each generations in terms of individuals. Default is 20.
</p>
</td></tr>
<tr><td><code id="optimizeStrata_+3A_mut_chance">mut_chance</code></td>
<td>

<p>Mutation chance: for each new individual, the probability to change each single chromosome, i.e. one bit
of the solution vector. High values of this parameter allow a deeper exploration of the solution space,
but a slower convergence, while low values permit a faster convergence, but the final solution can be
distant from the optimal one. Default is NA, in correspondence of which it is computed as 1/(vars+1) 
where vars is the length of elements in the solution.
</p>
</td></tr>
<tr><td><code id="optimizeStrata_+3A_elitism_rate">elitism_rate</code></td>
<td>

<p>This  parameter indicates the rate of better solutions that must be preserved from one generation
to another. Default is 0.2 (20
</p>
</td></tr>
<tr><td><code id="optimizeStrata_+3A_highvalue">highvalue</code></td>
<td>

<p>Parameter for genetic algorithm. In should not be changed
</p>
</td></tr>
<tr><td><code id="optimizeStrata_+3A_suggestions">suggestions</code></td>
<td>

<p>Optional parameter for genetic algorithm that indicates a suggested solution to be introduced in the initial population. The most convenient is the one found by the function &quot;KmeanSolution&quot;. Default is NULL. 
</p>
</td></tr>
<tr><td><code id="optimizeStrata_+3A_realallocation">realAllocation</code></td>
<td>

<p>If FALSE, the allocation is based on INTEGER values; if TRUE, the allocation is based on REAL values.
Default is TRUE.
</p>
</td></tr>  
<tr><td><code id="optimizeStrata_+3A_writefiles">writeFiles</code></td>
<td>

<p>Indicates if the various dataframes and plots produced during the execution have to be written in the working
directory.
Default is FALSE.
</p>
</td></tr>
<tr><td><code id="optimizeStrata_+3A_showplot">showPlot</code></td>
<td>

<p>Indicates if the plot showing the trend in the value of the objective function has to be shown or not. In parallel = TRUE, this defaults to FALSE
Default is TRUE.
</p>
</td></tr>
<tr><td><code id="optimizeStrata_+3A_parallel">parallel</code></td>
<td>

<p>Should the analysis be run in parallel.
Default is TRUE.
</p>
</td></tr>
<tr><td><code id="optimizeStrata_+3A_cores">cores</code></td>
<td>

<p>If the analysis is run in parallel, how many cores should be used.
If not specified n-1 of total available cores are used OR if number of domains &lt; (n-1) cores, then number of cores equal to number of domains are used.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing (1) the vector of the solution and (2) the optimal aggregated strata
</p>


<h3>Author(s)</h3>

<p>Giulio Barcaroli
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(SamplingStrata)
############################
# Example of "atomic" method
############################
data(swissmunicipalities)
swissmunicipalities$id &lt;- c(1:nrow(swissmunicipalities))
frame &lt;- buildFrameDF(df = swissmunicipalities,
                      id = "id",
                      domainvalue = "REG",
                      X = c("POPTOT","HApoly"),
                      Y = c("Surfacesbois", "Airind"))
ndom &lt;- length(unique(frame$domainvalue))
cv &lt;- as.data.frame(list(DOM = rep("DOM1",ndom),
                         CV1 = rep(0.1,ndom),
                         CV2 = rep(0.1,ndom),
                         domainvalue = c(1:ndom)))
strata &lt;- buildStrataDF(frame)
kmean &lt;- KmeansSolution(strata,cv,maxclusters=30)
nstrat &lt;- tapply(kmean$suggestions, kmean$domainvalue,
                 FUN=function(x) length(unique(x)))
solution &lt;- optimizeStrata(strata = strata,
                        errors = cv,
                        initialStrata = nstrat,
                        suggestions = kmean,
                        iter = 50,
                        pops = 10)
outstrata &lt;- solution$aggr_strata
newstrata &lt;- updateStrata(strata,solution)
framenew &lt;- updateFrame(frame, newstrata)
s &lt;- selectSample(framenew, outstrata)

## End(Not run)
</code></pre>

<hr>
<h2 id='optimizeStrata2'>
Best stratification of a sampling frame for multipurpose surveys (only with continuous stratification variables)
</h2><span id='topic+optimizeStrata2'></span>

<h3>Description</h3>

<p>This function runs a set of other functions to optimise the stratification of a sampling frame, only when stratification variables are of the continuous type. It differentiates from 'optimizeStrata' that accepts both continuous and categorical variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	optimizeStrata2(
            errors, 
            framesamp,
            framecens = NULL, 
            strcens = FALSE, 
            model = NULL, 
            alldomains = TRUE, 
            dom = NULL, 
            nStrata = c(5), 
            minnumstr = 2, 
            iter = 50, 
            pops = 20, 
            mut_chance = NA, 
            elitism_rate = 0.2, 
            highvalue = 1e+08, 
            suggestions = NULL, 
            realAllocation = TRUE, 
            writeFiles = FALSE, 
            showPlot = TRUE, 
            parallel = TRUE, 
            cores = NA
	)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimizeStrata2_+3A_errors">errors</code></td>
<td>

<p>This is the (mandatory) dataframe containing the precision levels expressed in terms of maximum expected value of the Coefficients of Variation
related to target variables of the survey.
</p>
</td></tr>
<tr><td><code id="optimizeStrata2_+3A_framesamp">framesamp</code></td>
<td>

<p>This is the (mandatory) dataframe containing the information related to the sampling frame.
</p>
</td></tr>
<tr><td><code id="optimizeStrata2_+3A_framecens">framecens</code></td>
<td>

<p>This the (optional) dataframe containing the units to be selected in any case. It has same structure than &quot;frame&quot; dataframe.
</p>
</td></tr>
<tr><td><code id="optimizeStrata2_+3A_strcens">strcens</code></td>
<td>

<p>Flag (TRUE/FALSE) to indicate if takeall strata do exist or not. Default is FALSE.
</p>
</td></tr>
<tr><td><code id="optimizeStrata2_+3A_model">model</code></td>
<td>

<p>In case the Y variables are not directly observed, but are estimated by means of other explicative variables, in order
to compute the anticipated variance, information on models are given by a dataframe &quot;model&quot; with as many rows as the
target variables. Each row contains the indication if the model is linear o loglinear, and the values of the model parameters 
beta, sig2, gamma (&gt; 1 in case of heteroscedasticity). 
Default is NULL.
</p>
</td></tr>
<tr><td><code id="optimizeStrata2_+3A_alldomains">alldomains</code></td>
<td>

<p>Flag (TRUE/FALSE) to indicate if the optimization must be carried out on all domains (default is TRUE). If it is set to FALSE,
then a value must be given to parameter 'dom'.
</p>
</td></tr>
<tr><td><code id="optimizeStrata2_+3A_dom">dom</code></td>
<td>

<p>Indicates the domain on which the optimization must be carried. It is an integer value that has to be internal to the interval 
(1 &lt;&ndash;&gt; number of domains). If 'alldomains' is set to TRUE, it is ignored.
</p>
</td></tr>
<tr><td><code id="optimizeStrata2_+3A_nstrata">nStrata</code></td>
<td>

<p>Indicates the number of strata for each variable.
</p>
</td></tr>
<tr><td><code id="optimizeStrata2_+3A_minnumstr">minnumstr</code></td>
<td>

<p>Indicates the minimum number of units that must be allocated in each stratum. Default is 2.
</p>
</td></tr>
<tr><td><code id="optimizeStrata2_+3A_iter">iter</code></td>
<td>

<p>Indicated the maximum number of iterations (= generations) of the genetic algorithm. Default is 50.
</p>
</td></tr>
<tr><td><code id="optimizeStrata2_+3A_pops">pops</code></td>
<td>

<p>The dimension of each generations in terms of individuals. Default is 20.
</p>
</td></tr>
<tr><td><code id="optimizeStrata2_+3A_mut_chance">mut_chance</code></td>
<td>

<p>Mutation chance: for each new individual, the probability to change each single chromosome, i.e. one bit
of the solution vector. High values of this parameter allow a deeper exploration of the solution space,
but a slower convergence, while low values permit a faster convergence, but the final solution can be
distant from the optimal one. Default is NA, in correspondence of which it is computed as 1/(vars+1) 
where vars is the length of elements in the solution.
</p>
</td></tr>
<tr><td><code id="optimizeStrata2_+3A_elitism_rate">elitism_rate</code></td>
<td>

<p>This  parameter indicates the rate of better solutions that must be preserved from one generation
to another. Default is 0.2 (20
</p>
</td></tr>
<tr><td><code id="optimizeStrata2_+3A_highvalue">highvalue</code></td>
<td>

<p>Parameter for genetic algorithm. In should not be changed
</p>
</td></tr>
<tr><td><code id="optimizeStrata2_+3A_suggestions">suggestions</code></td>
<td>

<p>Optional parameter for genetic algorithm that indicates a suggested solution to be introduced in the initial population. The most convenient is the one found by the function &quot;KmeanSolution&quot;. Default is NULL. 
</p>
</td></tr>
<tr><td><code id="optimizeStrata2_+3A_realallocation">realAllocation</code></td>
<td>

<p>If FALSE, the allocation is based on INTEGER values; if TRUE, the allocation is based on REAL values.
Default is TRUE.
</p>
</td></tr>  
<tr><td><code id="optimizeStrata2_+3A_writefiles">writeFiles</code></td>
<td>

<p>Indicates if the various dataframes and plots produced during the execution have to be written in the working
directory.
Default is FALSE.
</p>
</td></tr>
<tr><td><code id="optimizeStrata2_+3A_showplot">showPlot</code></td>
<td>

<p>Indicates if the plot showing the trend in the value of the objective function has to be shown or not. In parallel = TRUE, this defaults to FALSE
Default is TRUE.
</p>
</td></tr>
<tr><td><code id="optimizeStrata2_+3A_parallel">parallel</code></td>
<td>

<p>Should the analysis be run in parallel.
Default is TRUE.
</p>
</td></tr>
<tr><td><code id="optimizeStrata2_+3A_cores">cores</code></td>
<td>

<p>If the analysis is run in parallel, how many cores should be used.
If not specified n-1 of total available cores are used OR if number of domains &lt; (n-1) cores, then number of cores equal to number of domains are used.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing 
(1) the vector of the solution, 
(2) the optimal aggregated strata,
(3) the total sampling frame with the label of aggregated strata
</p>


<h3>Author(s)</h3>

<p>Giulio Barcaroli
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(SamplingStrata)
data(swissmunicipalities)
swissmunicipalities$id &lt;- c(1:nrow(swissmunicipalities))
frame &lt;- buildFrameDF(df = swissmunicipalities,
                      id = "id",
                      domainvalue = "REG",
                      X = c("POPTOT","HApoly"),
                      Y = c("Surfacesbois", "Airind"))
ndom &lt;- length(unique(frame$domainvalue))
cv &lt;- as.data.frame(list(DOM = rep("DOM1",ndom),
                         CV1 = rep(0.1,ndom),
                         CV2 = rep(0.1,ndom),
                         domainvalue = c(1:ndom)))
################################
# Example of "continuous" method
################################
kmean &lt;- KmeansSolution2(frame = frame, 
                         errors = cv, 
                         maxclusters = 10)
nstrat &lt;- tapply(kmean$suggestions, kmean$domainvalue,
                 FUN=function(x) length(unique(x)))
sugg &lt;- prepareSuggestion(kmean = kmean, 
                          frame = frame, 
                          nstrat = nstrat)
solution &lt;- optimizeStrata2(framesamp = frame,
                        errors = cv,
                        nStrata = nstrat,
                        iter = 50,
                        pops = 10,
                        suggestions = sugg)
framenew &lt;- solution$framenew
outstrata &lt;- solution$aggr_strata
s &lt;- selectSample(framenew,outstrata)

## End(Not run)
</code></pre>

<hr>
<h2 id='optimizeStrataSpatial'>
Best stratification of a sampling frame for multipurpose surveys considering also spatial correlation
</h2><span id='topic+optimizeStrataSpatial'></span>

<h3>Description</h3>

<p>This function runs a set of other functions to optimise the stratification of a sampling frame, only when stratification variables are of the continuous type, and if there is also 
a component of spatial autocorrelation in frame units.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	optimizeStrataSpatial(
            errors, 
            framesamp,
            framecens = NULL, 
            strcens = FALSE, 
            alldomains = TRUE, 
            dom = NULL, 
            nStrata = c(5), 
            fitting=c(1),
            range=c(0),
            kappa=3,
            minnumstr = 2, 
            iter = 50, 
            pops = 20, 
            mut_chance = NA, 
            elitism_rate = 0.2, 
            highvalue = 1e+08, 
            suggestions = NULL, 
            realAllocation = TRUE, 
            writeFiles = FALSE, 
            showPlot = TRUE, 
            parallel = TRUE, 
            cores
	)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimizeStrataSpatial_+3A_errors">errors</code></td>
<td>

<p>This is the (mandatory) dataframe containing the precision levels expressed in terms of maximum expected value of the Coefficients of Variation
related to target variables of the survey.
</p>
</td></tr>
<tr><td><code id="optimizeStrataSpatial_+3A_framesamp">framesamp</code></td>
<td>

<p>This is the (mandatory) dataframe containing the information related to the sampling frame.
</p>
</td></tr>
<tr><td><code id="optimizeStrataSpatial_+3A_framecens">framecens</code></td>
<td>

<p>This the (optional) dataframe containing the units to be selected in any case. It has same structure than &quot;frame&quot; dataframe.
</p>
</td></tr>
<tr><td><code id="optimizeStrataSpatial_+3A_strcens">strcens</code></td>
<td>

<p>Flag (TRUE/FALSE) to indicate if takeall strata do exist or not. Default is FALSE.
</p>
</td></tr>
<tr><td><code id="optimizeStrataSpatial_+3A_alldomains">alldomains</code></td>
<td>

<p>Flag (TRUE/FALSE) to indicate if the optimization must be carried out on all domains (default is TRUE). If it is set to FALSE,
then a value must be given to parameter 'dom'.
</p>
</td></tr>
<tr><td><code id="optimizeStrataSpatial_+3A_dom">dom</code></td>
<td>

<p>Indicates the domain on which the optimization must be carried. It is an integer value that has to be internal to the interval 
(1 &lt;&ndash;&gt; number of domains). If 'alldomains' is set to TRUE, it is ignored.
</p>
</td></tr>
<tr><td><code id="optimizeStrataSpatial_+3A_nstrata">nStrata</code></td>
<td>

<p>Indicates the number of strata for each variable.
</p>
</td></tr>
<tr><td><code id="optimizeStrataSpatial_+3A_fitting">fitting</code></td>
<td>

<p>Fitting of the model(s).
Default is 1.
</p>
</td></tr>
<tr><td><code id="optimizeStrataSpatial_+3A_range">range</code></td>
<td>

<p>Maximum range for spatial autocorrelation. It is a vector with as many elements as the number of target variables Y.
</p>
</td></tr>	
<tr><td><code id="optimizeStrataSpatial_+3A_kappa">kappa</code></td>
<td>

<p>Factor used in evaluating spatial autocorrelation. 
Default is 3.
</p>
</td></tr>	
<tr><td><code id="optimizeStrataSpatial_+3A_minnumstr">minnumstr</code></td>
<td>

<p>Indicates the minimum number of units that must be allocated in each stratum. Default is 2.
</p>
</td></tr>
<tr><td><code id="optimizeStrataSpatial_+3A_iter">iter</code></td>
<td>

<p>Indicated the maximum number of iterations (= generations) of the genetic algorithm. Default is 50.
</p>
</td></tr>
<tr><td><code id="optimizeStrataSpatial_+3A_pops">pops</code></td>
<td>

<p>The dimension of each generations in terms of individuals. Default is 20.
</p>
</td></tr>
<tr><td><code id="optimizeStrataSpatial_+3A_mut_chance">mut_chance</code></td>
<td>

<p>Mutation chance: for each new individual, the probability to change each single chromosome, i.e. one bit
of the solution vector. High values of this parameter allow a deeper exploration of the solution space,
but a slower convergence, while low values permit a faster convergence, but the final solution can be
distant from the optimal one. Default is NA, in correspondence of which it is computed as 1/(vars+1) 
where vars is the length of elements in the solution.
</p>
</td></tr>
<tr><td><code id="optimizeStrataSpatial_+3A_elitism_rate">elitism_rate</code></td>
<td>

<p>This  parameter indicates the rate of better solutions that must be preserved from one generation
to another. Default is 0.2 (20
</p>
</td></tr>
<tr><td><code id="optimizeStrataSpatial_+3A_highvalue">highvalue</code></td>
<td>

<p>Parameter for genetic algorithm. In should not be changed
</p>
</td></tr>
<tr><td><code id="optimizeStrataSpatial_+3A_suggestions">suggestions</code></td>
<td>

<p>Optional parameter for genetic algorithm that indicates a suggested solution to be introduced in the initial population. The most convenient is the one found by the function &quot;KmeanSolution&quot;. Default is NULL. 
</p>
</td></tr>
<tr><td><code id="optimizeStrataSpatial_+3A_realallocation">realAllocation</code></td>
<td>

<p>If FALSE, the allocation is based on INTEGER values; if TRUE, the allocation is based on REAL values.
Default is TRUE.
</p>
</td></tr>  
<tr><td><code id="optimizeStrataSpatial_+3A_writefiles">writeFiles</code></td>
<td>

<p>Indicates if the various dataframes and plots produced during the execution have to be written in the working
directory.
Default is FALSE.
</p>
</td></tr>
<tr><td><code id="optimizeStrataSpatial_+3A_showplot">showPlot</code></td>
<td>

<p>Indicates if the plot showing the trend in the value of the objective function has to be shown or not. In parallel = TRUE, this defaults to FALSE
Default is TRUE.
</p>
</td></tr>
<tr><td><code id="optimizeStrataSpatial_+3A_parallel">parallel</code></td>
<td>

<p>Should the analysis be run in parallel.
Default is TRUE.
</p>
</td></tr>
<tr><td><code id="optimizeStrataSpatial_+3A_cores">cores</code></td>
<td>

<p>If the analysis is run in parallel, how many cores should be used.
If not specified n-1 of total available cores are used OR if number of domains &lt; (n-1) cores, then number of cores equal to number of domains are used.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing 
(1) the vector of the solution, 
(2) the optimal aggregated strata,
(3) the total sampling frame with the label of aggregated strata
</p>


<h3>Author(s)</h3>

<p>Giulio Barcaroli
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################
# Example of "spatial" method
#############################
library(sp)
data("meuse")
data("meuse.grid")
meuse.grid$id &lt;- c(1:nrow(meuse.grid))
coordinates(meuse) &lt;- c('x','y')
coordinates(meuse.grid) &lt;- c('x','y')
library(gstat)
library(automap)
v &lt;- variogram(lead ~ dist + soil, data = meuse)
fit.vgm.lead &lt;- autofitVariogram(lead ~ dist + soil,
                                 meuse,
                                 model = "Exp")
plot(v, fit.vgm.lead$var_model)
lead.kr &lt;- krige(lead ~ dist + soil, meuse, meuse.grid,
                model = fit.vgm.lead$var_model)
lead.pred &lt;- ifelse(lead.kr[1]$var1.pred &lt; 0,0, lead.kr[1]$var1.pred)
lead.var &lt;- ifelse(lead.kr[2]$var1.var &lt; 0, 0, lead.kr[2]$var1.var)
df &lt;- as.data.frame(list(dom = rep(1,nrow(meuse.grid)),
                         lead.pred = lead.pred,
                         lead.var = lead.var,
                         lon = meuse.grid$x,
                         lat = meuse.grid$y,
                         id = c(1:nrow(meuse.grid))))
frame &lt;-buildFrameSpatial(df = df,
                          id = "id",
                          X = c("lead.pred"),
                          Y = c("lead.pred"),
                          variance = c("lead.var"),
                          lon = "lon",
                          lat = "lat",
                          domainvalue = "dom")
cv &lt;- as.data.frame(list(DOM = rep("DOM1",1),
                          CV1 = rep(0.05,1),
                          domainvalue = c(1:1) ))
solution &lt;- optimizeStrataSpatial(errors = cv, 
                        framesamp = frame, 
                        iter = 25,
                        pops = 10,
                        nStrata = 5, 
                        fitting = 1, 
                        kappa = 1,
                        range = fit.vgm.lead$var_model$range[2])
framenew &lt;- solution$framenew
outstrata &lt;- solution$aggr_strata
frameres &lt;- SpatialPixelsDataFrame(points = framenew[c("LON","LAT")],
                                   data = framenew)
frameres$LABEL &lt;- as.factor(frameres$LABEL)
spplot(frameres,c("LABEL"), col.regions=bpy.colors(5))
s &lt;- selectSample(framenew,outstrata)


## End(Not run)
</code></pre>

<hr>
<h2 id='optimStrata'>
Optimization of the stratification of a sampling frame given a sample survey 
</h2><span id='topic+optimStrata'></span>

<h3>Description</h3>

<p>Wrapper function to call the different optimization functions: (i) optimizeStrata (method = &quot;atomic&quot;); (ii) optimizeStrata2 (method = &quot;continuous&quot;); (iii) optimizeStrataSpatial (method = &quot;spatial&quot;).
For continuity reasons, these functions are still available to be used standalone.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimStrata(method=c("atomic","continuous","spatial"),
            # common parameters
            framesamp,
            framecens=NULL,
            model=NULL,
            nStrata=NA,
            errors,
            alldomains=TRUE,
            dom=NULL,
            strcens=FALSE,
            minnumstr=2,
            iter=50,
            pops=20,
            mut_chance=NA,
            elitism_rate=0.2,
            suggestions=NULL,
            writeFiles=FALSE,
            showPlot=TRUE,
            parallel=TRUE,
            cores=NA,
            # parameters only for optimizeStrataSpatial
            fitting=NA,
            range=NA,
            kappa=NA) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimStrata_+3A_method">method</code></td>
<td>

<p>This parameter allows to choose the method to be applied in the optimization step: (i) optimizeStrata (method = &quot;atomic&quot;); (ii) optimizeStrata (method = &quot;continuous&quot;); (iii) optimizeStrata (method = &quot;spatial&quot;)
</p>
</td></tr>
<tr><td><code id="optimStrata_+3A_errors">errors</code></td>
<td>

<p>This is the (mandatory) dataframe containing the precision levels expressed in terms of maximum expected value of the Coefficients of Variation
related to target variables of the survey.
</p>
</td></tr>
<tr><td><code id="optimStrata_+3A_framesamp">framesamp</code></td>
<td>

<p>This is the dataframe containing the information related to the sampling frame.
</p>
</td></tr>
<tr><td><code id="optimStrata_+3A_framecens">framecens</code></td>
<td>

<p>This the dataframe containing the units to be selected in any case. It has same structure than &quot;framesamp&quot; dataframe.
</p>
</td></tr>
<tr><td><code id="optimStrata_+3A_nstrata">nStrata</code></td>
<td>

<p>Indicates the number of strata to be obtained in the final solution.
</p>
</td></tr>
<tr><td><code id="optimStrata_+3A_model">model</code></td>
<td>

<p>In case the Y variables are not directly observed, but are estimated by means of other explicative variables, in order
to compute the anticipated variance, information on models are given by a dataframe &quot;model&quot; with as many rows as the
target variables. Each row contains the indication if the model is linear o loglinear, and the values of the model parameters 
beta, sig2, gamma (&gt; 1 in case of heteroscedasticity). 
Default is NULL.
</p>
</td></tr>
<tr><td><code id="optimStrata_+3A_alldomains">alldomains</code></td>
<td>

<p>Flag (TRUE/FALSE) to indicate if the optimization must be carried out on all domains (default is TRUE). If it is set to FALSE,
then a value must be given to parameter 'dom'.
</p>
</td></tr>
<tr><td><code id="optimStrata_+3A_dom">dom</code></td>
<td>

<p>Indicates the domain on which the optimization must be carried. It is an integer value that has to be internal to the interval 
(1 &lt;&ndash;&gt; number of domains). If 'alldomains' is set to TRUE, it is ignored.
</p>
</td></tr>
<tr><td><code id="optimStrata_+3A_strcens">strcens</code></td>
<td>

<p>Flag (TRUE/FALSE) to indicate if takeall strata do exist or not. Default is FALSE.
</p>
</td></tr>
<tr><td><code id="optimStrata_+3A_minnumstr">minnumstr</code></td>
<td>

<p>Indicates the minimum number of units that must be allocated in each stratum. Default is 2.
</p>
</td></tr>
<tr><td><code id="optimStrata_+3A_iter">iter</code></td>
<td>

<p>Indicates the maximum number of iterations (= generations) of the genetic algorithm. Default is 50.
</p>
</td></tr>
<tr><td><code id="optimStrata_+3A_pops">pops</code></td>
<td>

<p>The dimension of each generations in terms of individuals. Default is 20.
</p>
</td></tr>
<tr><td><code id="optimStrata_+3A_mut_chance">mut_chance</code></td>
<td>

<p>Mutation chance: for each new individual, the probability to change each single chromosome, i.e. one bit
of the solution vector. High values of this parameter allow a deeper exploration of the solution space,
but a slower convergence, while low values permit a faster convergence, but the final solution can be
distant from the optimal one. Default is NA, in correspondence of which it is computed as 1/(vars+1) 
where vars is the length of elements in the solution.
</p>
</td></tr>
<tr><td><code id="optimStrata_+3A_elitism_rate">elitism_rate</code></td>
<td>

<p>This  parameter indicates the rate of better solutions that must be preserved from one generation
to another. Default is 0.2 (20
</p>
</td></tr>
<tr><td><code id="optimStrata_+3A_suggestions">suggestions</code></td>
<td>

<p>Optional parameter for genetic algorithm that indicates a suggested solution to be introduced in the initial population. The most convenient is the one found by the function &quot;KmeanSolution&quot;. Default is NULL. 
</p>
</td></tr>
<tr><td><code id="optimStrata_+3A_writefiles">writeFiles</code></td>
<td>

<p>Indicates if the various dataframes and plots produced during the execution have to be written in the working
directory.
Default is FALSE.
</p>
</td></tr>
<tr><td><code id="optimStrata_+3A_showplot">showPlot</code></td>
<td>

<p>Indicates if the plot showing the trend in the value of the objective function has to be shown or not. In parallel = TRUE, this defaults to FALSE
Default is TRUE.
</p>
</td></tr>
<tr><td><code id="optimStrata_+3A_parallel">parallel</code></td>
<td>

<p>Should the analysis be run in parallel.
Default is TRUE.
</p>
</td></tr>
<tr><td><code id="optimStrata_+3A_cores">cores</code></td>
<td>

<p>If the analysis is run in parallel, how many cores should be used.
If not specified n-1 of total available cores are used OR if number of domains &lt; (n-1) cores, then number of cores equal to number of domains are used.
</p>
</td></tr>
<tr><td><code id="optimStrata_+3A_fitting">fitting</code></td>
<td>

<p>Fitting of the model(s) (in terms of R squared). It is a vector with as many elements as the number of target variables Y.
</p>
</td></tr>
<tr><td><code id="optimStrata_+3A_range">range</code></td>
<td>

<p>Maximum range for spatial autocorrelation. It is a vector with as many elements as the number of target variables Y.
</p>
</td></tr>	
<tr><td><code id="optimStrata_+3A_kappa">kappa</code></td>
<td>

<p>Factor used in evaluating spatial autocorrelation. 
</p>
</td></tr>	
</table>


<h3>Value</h3>

<p>List containing 
(1) the vector of the solution, 
(2) the optimal aggregated strata,
(3) the total sampling frame with the label of aggregated strata
</p>


<h3>Author(s)</h3>

<p>Giulio Barcaroli
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(SamplingStrata)
############################
# Example of "atomic" method
############################
data(swissmunicipalities)
swissmunicipalities$id &lt;- c(1:nrow(swissmunicipalities))
frame &lt;- buildFrameDF(df = swissmunicipalities,
                      id = "id",
                      domainvalue = "REG",
                      X = c("POPTOT","HApoly"),
                      Y = c("Surfacesbois", "Airind"))
ndom &lt;- length(unique(frame$domainvalue))
cv &lt;- as.data.frame(list(DOM = rep("DOM1",ndom),
                         CV1 = rep(0.1,ndom),
                         CV2 = rep(0.1,ndom),
                         domainvalue = c(1:ndom)))
strata &lt;- buildStrataDF(frame)
kmean &lt;- KmeansSolution(strata,cv,maxclusters=30)
nstrat &lt;- tapply(kmean$suggestions, kmean$domainvalue,
                 FUN=function(x) length(unique(x)))
solution &lt;- optimStrata(method ="atomic",
                        framesamp = frame,
                        errors = cv,
                        nStrata = nstrat,
                        suggestions = kmean,
                        iter = 50,
                        pops = 10)
outstrata &lt;- solution$aggr_strata
framenew &lt;- solution$framenew
s &lt;- selectSample(framenew, outstrata)
################################
# Example of "continuous" method
################################
kmean &lt;- KmeansSolution2(frame = frame, 
                         errors = cv, 
                         maxclusters = 10)
nstrat &lt;- tapply(kmean$suggestions, kmean$domainvalue,
                 FUN=function(x) length(unique(x)))
sugg &lt;- prepareSuggestion(kmean = kmean, 
                          frame = frame, 
                          nstrat = nstrat)
solution &lt;- optimStrata(method = "continuous",
                        framesamp = frame,
                        errors = cv,
                        nStrata = nstrat,
                        iter = 50,
                        pops = 10,
                        suggestions = sugg)
framenew &lt;- solution$framenew
outstrata &lt;- solution$aggr_strata
s &lt;- selectSample(framenew,outstrata)
#############################
# Example of "spatial" method
#############################
library(sp)
data("meuse")
data("meuse.grid")
meuse.grid$id &lt;- c(1:nrow(meuse.grid))
coordinates(meuse) &lt;- c('x','y')
coordinates(meuse.grid) &lt;- c('x','y')
library(gstat)
library(automap)
v &lt;- variogram(lead ~ dist + soil, data = meuse)
fit.vgm.lead &lt;- autofitVariogram(lead ~ dist + soil,
                                 meuse,
                                 model = "Exp")
plot(v, fit.vgm.lead$var_model)
lead.kr &lt;- krige(lead ~ dist + soil, meuse, meuse.grid,
                 model = fit.vgm.lead$var_model)
lead.pred &lt;- ifelse(lead.kr[1]$var1.pred &lt; 0,0, lead.kr[1]$var1.pred)
lead.var &lt;- ifelse(lead.kr[2]$var1.var &lt; 0, 0, lead.kr[2]$var1.var)
df &lt;- as.data.frame(list(dom = rep(1,nrow(meuse.grid)),
                         lead.pred = lead.pred,
                         lead.var = lead.var,
                         lon = meuse.grid$x,
                         lat = meuse.grid$y,
                         id = c(1:nrow(meuse.grid))))
frame &lt;-buildFrameSpatial(df = df,
                          id = "id",
                          X = c("lead.pred"),
                          Y = c("lead.pred"),
                          variance = c("lead.var"),
                          lon = "lon",
                          lat = "lat",
                          domainvalue = "dom")
cv &lt;- as.data.frame(list(DOM = rep("DOM1",1),
                         CV1 = rep(0.05,1),
                         domainvalue = c(1:1) ))
solution &lt;- optimStrata(method = "spatial",
                        errors = cv, 
                        framesamp = frame, 
                        iter = 25,
                        pops = 10,
                        nStrata = 5, 
                        fitting = 1, 
                        kappa = 1,
                        range = fit.vgm.lead$var_model$range[2])
framenew &lt;- solution$framenew
outstrata &lt;- solution$aggr_strata
frameres &lt;- SpatialPixelsDataFrame(points = framenew[c("LON","LAT")],
                                   data = framenew)
frameres$LABEL &lt;- as.factor(frameres$LABEL)
spplot(frameres,c("LABEL"), col.regions=bpy.colors(5))
s &lt;- selectSample(framenew,outstrata)

## End(Not run)
</code></pre>

<hr>
<h2 id='plotSamprate'>
Plotting sampling rates in the different strata for each domain in the solution.
</h2><span id='topic+plotSamprate'></span>

<h3>Description</h3>

<p>Once the optimization step has been carried out, by applying this function it is
possible to obtain the visualization of the proportion of sampling units in the
different strata for each domain in the obtained solution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSamprate(solution, dom)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotSamprate_+3A_solution">solution</code></td>
<td>

<p>Solution obtained by executing optimizeStrata
</p>
</td></tr>
<tr><td><code id="plotSamprate_+3A_dom">dom</code></td>
<td>

<p>Identification of the domain
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(SamplingStrata)
data(swisserrors)
data(swissstrata)
# optimisation of sampling strata
solution &lt;- optimizeStrata ( 
    errors = swisserrors, 
    strata = swissstrata, 
)
# plot of the sampling rates in strata 
for (i in (1:length(unique(swissstrata$DOM1)))) plotSamprate(solution, i)

## End(Not run)
</code></pre>

<hr>
<h2 id='plotStrata2d'>Plot bivariate distibutions in strata</h2><span id='topic+plotStrata2d'></span>

<h3>Description</h3>

<p>Plots a 2d graph showing obtained strata 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotStrata2d (x,outstrata,domain,vars,labels)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotStrata2d_+3A_x">x</code></td>
<td>
<p>the sampling frame</p>
</td></tr>
<tr><td><code id="plotStrata2d_+3A_outstrata">outstrata</code></td>
<td>
<p>the optimized strata</p>
</td></tr>
<tr><td><code id="plotStrata2d_+3A_domain">domain</code></td>
<td>
<p>a domain in the frame</p>
</td></tr>
<tr><td><code id="plotStrata2d_+3A_vars">vars</code></td>
<td>
<p>vars to appear in x and y axis</p>
</td></tr>
<tr><td><code id="plotStrata2d_+3A_labels">labels</code></td>
<td>
<p>labels to appear in x and y axis</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A formatted output containing information on the strata in the given domain
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(SamplingStrata)
data("swissmunicipalities")
swissmunicipalities = swissmunicipalities[swissmunicipalities$REG==1,]
data("errors")
swissmunicipalities$id &lt;- c(1:nrow(swissmunicipalities))
swissmunicipalities$domain = 1
frame &lt;- buildFrameDF(swissmunicipalities,
                      id = "id",
                      domainvalue = "REG",
                      X = c("Surfacesbois","Surfacescult"),
                      Y = c("Pop020", "Pop2040")
)
solution &lt;- optimStrata (method = "continuous",
                        errors = errors,, 
                        framesamp = frame,
                        nStrata = 8, 
                        iter = 25, 
                        pops = 10) 
p &lt;- plotStrata2d(solution$framenew, 
                  solution$aggr_strata,
                  domain = 1, 
                  vars = c("X1","X2"),
                  labels = c("Surfacesbois","Surfacescult"))
p

## End(Not run)
</code></pre>

<hr>
<h2 id='prepareSuggestion'>
Prepare suggestions for optimization with method = &quot;continuous&quot; or &quot;spatial&quot;
</h2><span id='topic+prepareSuggestion'></span>

<h3>Description</h3>

<p>This function has to be used only in conjunction with &quot;KmeansSolution2&quot; or 
with &quot;KmeansSolutionSpatial&quot;, 
i.e. in the case of optimizing with only continuous stratification variables.
This function prepares the suggestion for the optimization function in case
of continuous variables (i.e. with with &quot;optimStrata&quot; 
when method = &quot;continuous&quot; or method = &quot;spatial&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepareSuggestion(kmean = kmean, frame = frame, nstrat = nstrat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepareSuggestion_+3A_kmean">kmean</code></td>
<td>

<p>The result of the execution of function 'KmeansSolution2'.
</p>
</td></tr>
<tr><td><code id="prepareSuggestion_+3A_frame">frame</code></td>
<td>

<p>The dataframe containing the information related to each unit in the sampling frame.
</p>
</td></tr>
<tr><td><code id="prepareSuggestion_+3A_nstrat">nstrat</code></td>
<td>

<p>The vector of number of strata identified as the best for each domain.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe containing the suggestions
</p>


<h3>Author(s)</h3>

<p>Giulio Barcaroli 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(SamplingStrata)
data("swissmunicipalities")
swissmunicipalities$id &lt;- c(1:nrow(swissmunicipalities))
swissmunicipalities$dom &lt;- 1
frame &lt;- buildFrameDF(swissmunicipalities,
                      id = "id",
                      domainvalue = "REG",
                      X = c("POPTOT", "HApoly"),
                      Y = c("Surfacesbois", "Airind")
)
ndom &lt;- length(unique(frame$domainvalue))
cv &lt;- as.data.frame(list(
              DOM = rep("DOM1",ndom),
              CV1 = rep(0.1,ndom),
              CV2 = rep(0.1,ndom),
              domainvalue = c(1:ndom)))

# Solution with kmean clustering 
kmean &lt;- KmeansSolution2(frame,model=NULL,errors=cv,nstrata=NA,maxclusters=4)
# Number of strata for each domain
nstrat &lt;- tapply(kmean$suggestions,
                 kmean$domainvalue,
                 FUN=function(x) length(unique(x)))
# Prepare suggestion for optimization step                 
sugg &lt;- prepareSuggestion(kmean = kmean,
                          frame = frame,
                          nstrat = nstrat)
# Optimization
solution &lt;- optimStrata (
  method="continuous",
  errors=cv, 
  framesamp=frame,
  iter = 50,
  pops = 10,
  nStrata = nstrat,
  suggestions = sugg)

## End(Not run)
</code></pre>

<hr>
<h2 id='procBethel'>
Procedure to apply Bethel algorithm and select a sample from given strata
</h2><span id='topic+procBethel'></span>

<h3>Description</h3>

<p>This function allows to execute a complete procedure from the Bethel optimal allocation to the selection of a sample, without having to optimize the strata, that are supposed to be given and fixed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>procBethel(framesamp,
           framecens,
           errors,
           sampling_method=c("srs","systematic","spatial"),
           minnumstrat=2) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="procBethel_+3A_framesamp">framesamp</code></td>
<td>

<p>Dataframe containing sampling frame units.
</p>
</td></tr>
<tr><td><code id="procBethel_+3A_framecens">framecens</code></td>
<td>

<p>Dataframe containing frame units that must be selected.
</p>
</td></tr>
<tr><td><code id="procBethel_+3A_errors">errors</code></td>
<td>

<p>Dataframe containing the precision levels expressed in terms of maximum expected value of the Coefficients of Variation related to target variables of the survey.
</p>
</td></tr>
<tr><td><code id="procBethel_+3A_sampling_method">sampling_method</code></td>
<td>

<p>Parameter for choosing the selection method: &quot;srs&quot;, &quot;systematic&quot; and &quot;spatial&quot;.
</p>
</td></tr>
<tr><td><code id="procBethel_+3A_minnumstrat">minnumstrat</code></td>
<td>

<p>Indicates the minimum number of units that must be allocated in each stratum. Default is 2.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing 
(1) the selected sample, 
(2) the strata with allocated sampling units,
(3) the take-all strata
(4) the sampling frame with the labels linking to (2)
(5) the frame with take-all units, with the labels linking to (3) 
</p>


<h3>Author(s)</h3>

<p>Giulio Barcaroli
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("swissmunicipalities")
swissmun &lt;- swissmunicipalities[swissmunicipalities$REG &lt; 4,
                                c("REG","COM","Nom","HApoly",
                                  "Surfacesbois","Surfacescult",
                                  "Airbat","POPTOT")]
ndom &lt;- length(unique(swissmun$REG))
cv &lt;- as.data.frame(list(DOM=rep("DOM1",ndom),
                         CV1=rep(0.10,ndom),
                         CV2=rep(0.10,ndom),
                         domainvalue=c(1:ndom) ))
cv
swissmun$HApoly.cat &lt;- var.bin(swissmun$HApoly,15)
swissmun$POPTOT.cat &lt;- var.bin(swissmun$POPTOT,15)
frame &lt;- buildFrameDF(df = swissmun,
                         id = "COM",
                         X = c("POPTOT.cat","HApoly.cat"),
                         Y = c("Airbat","Surfacesbois"),
                         domainvalue = "REG")
summary(frame)
#----Selection of units to be censused from the frame
ind_framecens &lt;- which(frame$X1 &gt; 9)
framecens &lt;- frame[ind_framecens,]
#----Selection of units to be sampled from the frame
# (complement to the previous)
framesamp &lt;- frame[-ind_framecens,]

a &lt;- procBethel(framesamp,framecens,errors=cv,sampling_method="srs",minnumstrat=2)
head(a$sample)
expected_CV(a$strata)

## End(Not run)
</code></pre>

<hr>
<h2 id='selectSample'>
Selection of a stratified sample from the frame with srswor method 
</h2><span id='topic+selectSample'></span>

<h3>Description</h3>

<p>Once optimal stratification has been obtained, 
and a new frame has been 
built by assigning to the units of the old one the new strata labels, it is possible to select 
a stratified sample from the frame 
with the simple random sampling without replacement (srswor) method. 
The result of the execution of &quot;selectSample&quot; function is a dataframe containing the selected
units, with their weights (inverse of the probabilities of inclusion).
It is possible to output this dataframe in a .csv file.
One more .csv file is produced (&quot;sampling_check&quot;), containing coeherence checks between 
(a) population in frame strata
(b) population in optimised strata
(c) planned units to be selected in optimised strata
(d) actually selected units
(e) sum of weights in each stratum
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selectSample(frame, outstrata, writeFiles = FALSE,verbatim=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selectSample_+3A_frame">frame</code></td>
<td>

<p>This is the (mandatory) dataframe containing the sampling frame, as it has been modified 
by the execution of the &quot;updateFrame&quot; function. 
</p>
</td></tr>
<tr><td><code id="selectSample_+3A_outstrata">outstrata</code></td>
<td>

<p>This is the (mandatory) dataframe containing the information related to resulting   stratification obtained by the execution of &quot;optimizeStrata&quot; function. It should coincide with 'solution$aggr_strata'.
</p>
</td></tr>
<tr><td><code id="selectSample_+3A_writefiles">writeFiles</code></td>
<td>

<p>Indicates if at the end of the processing the resulting strata will be outputted in a delimited file.
Default is &quot;FALSE&quot;.
</p>
</td></tr>
<tr><td><code id="selectSample_+3A_verbatim">verbatim</code></td>
<td>

<p>Indicates if information on the drawn sample must be printed or not.
Default is &quot;TRUE&quot;.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe containing the sample
</p>


<h3>Author(s)</h3>

<p>Giulio Barcaroli with contribution from Diego Zardetto
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(SamplingStrata)
data(swisserrors)
data(swissstrata)
# optimisation of sampling strata
solution &lt;- optimizeStrata ( 
    errors = swisserrors, 
    strata = swissstrata 
)
# updating sampling strata with new strata labels
newstrata &lt;- updateStrata(swissstrata, solution)
# updating sampling frame with new strata labels
data(swissframe)
framenew &lt;- updateFrame(frame=swissframe,newstrata=newstrata)
# selection of sample
sample &lt;- selectSample(frame=framenew,outstrata=solution$aggr_strata)
head(sample)

## End(Not run)
</code></pre>

<hr>
<h2 id='selectSampleSpatial'>
Selection of geo-referenced points from the frame  
</h2><span id='topic+selectSampleSpatial'></span>

<h3>Description</h3>

<p>Once optimal stratification has been obtained, and a new frame has been 
built by assigning to the units of the old one the new strata labels, 
it is possible to select a stratified sample from the frame. 
If geographical coordinates are available in the frame, in order to obtain spatially distributed selected points
this function makes use of the 'lpm2_kdtree' function from the' SamplingBigData' package (Lisic-Grafstrom).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selectSampleSpatial(frame, outstrata, coord_names)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selectSampleSpatial_+3A_frame">frame</code></td>
<td>

<p>This is the (mandatory) dataframe containing the sampling frame, as it has been modified 
by the execution of the &quot;updateFrame&quot; function. 
</p>
</td></tr>
<tr><td><code id="selectSampleSpatial_+3A_outstrata">outstrata</code></td>
<td>

<p>This is the (mandatory) dataframe containing the information related to resulting stratification obtained by the execution of &quot;optimStrata&quot; function. It should coincide with 'solution$aggr_strata'.
</p>
</td></tr>
<tr><td><code id="selectSampleSpatial_+3A_coord_names">coord_names</code></td>
<td>

<p>Indicates with which names the coordinates are indicated in the frame.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe containing the selected sample
</p>


<h3>Author(s)</h3>

<p>Giulio Barcaroli
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################
# Example of "spatial" method
#############################
library(sp)
# locations (155 observed points)
data("meuse")
# grid of points (3103)
data("meuse.grid")
meuse.grid$id &lt;- c(1:nrow(meuse.grid))
coordinates(meuse)&lt;-c("x","y")
coordinates(meuse.grid)&lt;-c("x","y")

## Kriging model
library(automap)
kriging_lead = autoKrige(log(lead) ~ dist, meuse, meuse.grid)
plot(kriging_lead,sp.layout = NULL, justPosition = TRUE)
kriging_zinc = autoKrige(log(zinc) ~ dist, meuse, meuse.grid)
plot(kriging_zinc, sp.layout = list(pts = list("sp.points", meuse)))
r2_lead &lt;- 1 - kriging_lead$sserr/sum((meuse$lead-mean(meuse$lead))^2)
r2_lead
r2_zinc &lt;- 1 - kriging_zinc$sserr/sum((meuse$zinc-mean(meuse$zinc))^2)
r2_zinc
df &lt;- NULL
df$id &lt;- meuse.grid$id
df$lead.pred &lt;- kriging_lead$krige_output@data$var1.pred
df$lead.var &lt;- kriging_lead$krige_output@data$var1.var
df$zinc.pred &lt;- kriging_zinc$krige_output@data$var1.pred
df$zinc.var &lt;- kriging_zinc$krige_output@data$var1.var
df$lon &lt;- meuse.grid$x
df$lat &lt;- meuse.grid$y
df$dom1 &lt;- 1
df &lt;- as.data.frame(df)
head(df)

## Optimization 
library(SamplingStrata)
frame &lt;- buildFrameSpatial(df=df,
                           id="id",
                           X=c("lead.pred","zinc.pred"),
                           Y=c("lead.pred","zinc.pred"),
                           variance=c("lead.var","zinc.var"),
                           lon="lon",
                           lat="lat",
                           domainvalue = "dom1")
cv &lt;- as.data.frame(list(DOM=rep("DOM1",1),
                         CV1=rep(0.01,1),
                         CV2=rep(0.01,1),
                         domainvalue=c(1:1) ))
set.seed(1234)
solution &lt;- optimStrata (
  method = "spatial",
  errors=cv, 
  framesamp=frame,
  iter = 15,
  pops = 10,
  nStrata = 5,
  fitting = c(r2_lead,r2_zinc),
  range = c(kriging_lead$var_model$range[2],kriging_zinc$var_model$range[2]),
  kappa=1,
  writeFiles = FALSE,
  showPlot = TRUE,
  parallel = FALSE)
framenew &lt;- solution$framenew
outstrata &lt;- solution$aggr_strata

# Sample selection
samp &lt;- selectSampleSpatial(framenew,outstrata,coord_names=c("LON","LAT"))
table(samp$STRATO)

# Plot
library(sf)
samp_sf &lt;- st_as_sf(samp, coords = c("LON", "LAT"))
plot(samp_sf["STRATO"])


## End(Not run)
</code></pre>

<hr>
<h2 id='selectSampleSystematic'>
Selection of a stratified sample from the frame with systematic method 
</h2><span id='topic+selectSampleSystematic'></span>

<h3>Description</h3>

<p>Once optimal stratification has been obtained, 
and a new frame has been 
built by assigning to the units of the old one the new stratum labels, it is possible to select 
a stratified sample from the frame 
with the systematic method, that is a selection that begins selecting the first 
unit by an initial ramndomly chosen starting point, and proceeding in selecting other units 
by adding an interval that is the inverse of the sampling rate in the stratum.
</p>
<p>This selection method can be useful if associated to a particular ordering of the selection
frame, where the ordering variable(s) can be considered as additional 
stratum variable(s). 
</p>
<p>The result of the execution of &quot;selectSampleSystematic&quot; function is a dataframe containing selected
units, with the probabilities of inclusion.
It is possible to output this dataframe in a .csv file.
One more .csv file is produced (&quot;sampling_check&quot;), containing coeherence checks between 
(a) population in frame strata
(b) population in optimised strata
(c) planned units to be selected in optimised strata
(d) actually selected units
(e) sum of weights in each stratum
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selectSampleSystematic(frame, 
                      outstrata, 
                      sortvariable = NULL, 
                      writeFiles = FALSE,
                      verbatim=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selectSampleSystematic_+3A_frame">frame</code></td>
<td>

<p>This is the (mandatory) dataframe containing the sampling frame, as it has been modified 
by the execution of the &quot;updateFrame&quot; function. 
Name of stratum variable must be 'strato'.
</p>
</td></tr>
<tr><td><code id="selectSampleSystematic_+3A_outstrata">outstrata</code></td>
<td>

<p>This is the (mandatory) dataframe containing the information related to resulting 
stratification obtained by the execution of &quot;optimizeStrata&quot; function.
Name of stratum variable must be 'strato'.
</p>
</td></tr>
<tr><td><code id="selectSampleSystematic_+3A_sortvariable">sortvariable</code></td>
<td>

<p>This is the name of the variable to be used as ordering variable inside each stratum before proceeding to the systematic selection. It must be previously added to the selection frame. Default is NULL.
</p>
</td></tr>
<tr><td><code id="selectSampleSystematic_+3A_writefiles">writeFiles</code></td>
<td>

<p>Indicates if at the end of the processing the resulting strata will be outputted in a delimited file.
Default is &quot;FALSE&quot;.
</p>
</td></tr>
<tr><td><code id="selectSampleSystematic_+3A_verbatim">verbatim</code></td>
<td>

<p>Indicates if information on the drawn sample must be printed or not.
Default is &quot;TRUE&quot;.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe containing the sample
</p>


<h3>Author(s)</h3>

<p>Giulio Barcaroli with contribution from Diego Zardetto
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# The following example is realistic, but is time consuming
#
## Not run: 
library(SamplingStrata)
data(swisserrors)
data(swissstrata)
# optimisation of sampling strata
solution &lt;- optimizeStrata ( 
    errors = swisserrors, 
    strata = swissstrata)
# updating sampling strata with new strata labels
newstrata &lt;- updateStrata(swissstrata, solution)
# updating sampling frame with new strata labels
data(swissframe)
framenew &lt;- updateFrame(frame=swissframe,newstrata=newstrata)
# adding variable "POPTOT" to framenew
data("swissmunicipalities")
framenew &lt;- merge(framenew,swissmunicipalities[,c("REG","Nom","POPTOT")],
                  by.x=c("REG","ID"),by.y=c("REG","Nom"))
# selection of sample with systematic method
sample &lt;- selectSampleSystematic(frame=framenew,
								outstrata=solution$aggr_strata,
								sortvariable="POPTOT")
head(sample)

## End(Not run)
</code></pre>

<hr>
<h2 id='strata'>
Dataframe containing information on strata in the frame
</h2><span id='topic+strata'></span>

<h3>Description</h3>

<p>Dataframe containing information on strata in the frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(strata)</code></pre>


<h3>Format</h3>

<p>The strata data frame (strata) contains a row per stratum with the following variables: 
</p>

<dl>
<dt>stratum</dt><dd>
<p>Identifier of the stratum (numeric)
</p>
</dd>
<dt>N</dt><dd>
<p>Number of population units in the stratum (numeric) 
</p>
</dd>
<dt>X1</dt><dd>
<p>Value of first auxiliary variable X1 in the stratum (factor)
</p>
</dd>
<dt>Xi</dt><dd>
<p>Value of i-th auxiliary variable Xi in the stratum (factor)
</p>
</dd>
<dt>Xk</dt><dd>
<p>Value of last auxiliary variable Xk in the stratum (factor)
</p>
</dd>
<dt>M1</dt><dd>
<p>Mean in the stratum of the first variable Y1 (numeric)
</p>
</dd>
<dt>Mj</dt><dd>
<p>Mean in the stratum of the j-th variable Yt (numeric)
</p>
</dd>
<dt>Mn</dt><dd>
<p>Mean in the stratum of the last variable Y (numeric)
</p>
</dd>
<dt>S1</dt><dd>
<p>Standard deviation in the stratum of the first variable Y (numeric)
</p>
</dd>
<dt>Sj</dt><dd>
<p>Standard deviation in the stratum of the j-th variable Yt (numeric)
</p>
</dd>
<dt>Sn</dt><dd>
<p>Standard deviation in the stratum of the last variable Y (numeric)
</p>
</dd>
<dt>cens</dt><dd>
<p>Flag (1 indicates a take all straum, 0 a sampling stratum) (numeric) 
Default = 0
</p>
</dd>
<dt>cost</dt><dd>
<p>Cost per interview in each stratum.  Default = 1 (numeric)
</p>
</dd>
<dt>DOM1</dt><dd>
<p>Value of domain to which the stratum belongs (factor or numeric)
</p>
</dd>
</dl>



<h3>Details</h3>

<p>Note: the names of the variables must be the ones indicated above
</p>


<h3>Examples</h3>

<pre><code class='language-R'># data(strata)
# head(strata)
</code></pre>

<hr>
<h2 id='summaryStrata'>Information on strata structure</h2><span id='topic+summaryStrata'></span>

<h3>Description</h3>

<p>Information on strata (population, allocation, sampling rate 
and X variables ranges)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summaryStrata(x,outstrata,progress,writeFiles)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summaryStrata_+3A_x">x</code></td>
<td>
<p>the sampling frame</p>
</td></tr>
<tr><td><code id="summaryStrata_+3A_outstrata">outstrata</code></td>
<td>
<p>the optimized strata</p>
</td></tr>
<tr><td><code id="summaryStrata_+3A_progress">progress</code></td>
<td>
<p>progress bar</p>
</td></tr>
<tr><td><code id="summaryStrata_+3A_writefiles">writeFiles</code></td>
<td>
<p>csv output of the strata structure</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A formatted output containing information on the strata in the given domain
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(SamplingStrata)
data("swissmunicipalities")
data("errors")
errors$CV1 &lt;- 0.1
errors$CV2 &lt;- 0.1
errors &lt;- errors[rep(row.names(errors),7),]
errors$domainvalue &lt;- c(1:7)
errors
swissmunicipalities$id &lt;- c(1:nrow(swissmunicipalities))
swissmunicipalities$domain = 1
frame &lt;- buildFrameDF(swissmunicipalities,
                      id = "id",
                      domainvalue = "REG",
                      X = c("Surfacesbois","Surfacescult"),
                      Y = c("Pop020", "Pop2040")
)
solution &lt;- optimizeStrata2 (
  errors, 
  frame,
  nStrata = 5,
  iter = 10, 
  pops = 10, 
  writeFiles = FALSE, 
  showPlot = TRUE, 
  parallel = FALSE) 
strataStructure &lt;- summaryStrata(solution$framenew, solution$aggr_strata)
strataStructure

## End(Not run)
</code></pre>

<hr>
<h2 id='swisserrors'>
Precision constraints (maximum CVs) as input for Bethel allocation
</h2><span id='topic+swisserrors'></span>

<h3>Description</h3>

<p>Dataframe containing precision levels (expressed in terms of acceptable CV's)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(errors)</code></pre>


<h3>Format</h3>

<p>The constraint data frame (swisserrors) contains a row per each domain value with the following variables: 
</p>

<dl>
<dt>DOM</dt><dd>
<p>Type of domain code (factor)
</p>
</dd> 
<dt>CV1</dt><dd>
<p>Planned coefficient of variation for first variable Y1 (number of men and women aged between 0 and 19) (numeric)
</p>
</dd> 
<dt>CV2</dt><dd>
<p>Planned coefficient of variation for second variable Y2 (number of men and women aged between 20 and 39) (numeric)
</p>
</dd>
<dt>CV3</dt><dd>
<p>Planned coefficient of variation for third variable Y3 (number of men and women aged between 40 and 64) (numeric)
</p>
</dd> 
<dt>CV4</dt><dd>
<p>Planned coefficient of variation for forth variable Y4 (number of men and women aged between 65 and over) (numeric)
</p>
</dd> 	
<dt>domainvalue</dt><dd>
<p>Value of the domain to which the constraints refer (numeric)
</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## data(swisserrors)
## swisserrors
</code></pre>

<hr>
<h2 id='swissframe'>
Dataframe containing information on all units in the population of reference
that can be considered as the final sampling unit
(this example is related to Swiss municipalities)
</h2><span id='topic+swissframe'></span>

<h3>Description</h3>

<p>Dataframe containing information on all municipalities in Swiss
(it is a derivation of dataframe &quot;swissmunicipalities&quot; in &quot;sampling&quot; package)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(swissframe)</code></pre>


<h3>Format</h3>

<p>The &quot;swissframe&quot; dataframe contains a row per each Swiss municipality with the following variables: 
</p>

<dl>
<dt>progr</dt><dd>
<p>Progressive associated to the frame unit (numeric)
</p>
</dd>
<dt>id</dt><dd>
<p>Name of the frame unit (character)
</p>
</dd>
<dt>X1</dt><dd>
<p>Classes of total population in the municipality (factor with 18 values)
</p>
</dd>
<dt>X2</dt><dd>
<p>Classes of wood area in the municipality (factor with 3 values)
</p>
</dd>
<dt>X3</dt><dd>
<p>Classes of area under cultivation in the municipality (factor with 3 values)
</p>
</dd>
<dt>X4</dt><dd>
<p>Classes of mountain pasture area in the municipality (factor with 3 values)
</p>
</dd>
<dt>X5</dt><dd>
<p>Classes of area with buildings in the municipality (factor with 3 values)
</p>
</dd>
<dt>X6</dt><dd>
<p>Classes of industrial area in the municipality (factor with 3 values)
</p>
</dd>
<dt>Y1</dt><dd>
<p>Number of men and women aged between 0 and 19 (numeric)
</p>
</dd>
<dt>Y2</dt><dd>
<p>Number of men and women aged between 20 and 39 (numeric)
</p>
</dd>
<dt>Y3</dt><dd>
<p>Number of men and women aged between 40 and 64 (numeric)
</p>
</dd>
<dt>Y4</dt><dd>
<p>Number of men and women aged between 65 and over (numeric)
</p>
</dd>
<dt>domainvalue</dt><dd>
<p>Value of domain to which the municipality belongs (factor or numeric)
</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>#data(swissframe)
#head(strata)
</code></pre>

<hr>
<h2 id='swissmunicipalities'>The Swiss municipalities population</h2><span id='topic+swissmunicipalities'></span>

<h3>Description</h3>

<p>This population provides information about the Swiss municipalities 
in 2003.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(swissmunicipalities)</code></pre>


<h3>Format</h3>

<p>A data frame with 2896 observations on the following 22 variables:
</p>

<dl>
<dt>id</dt><dd><p>Municipality unique identifier.</p>
</dd>
<dt>CT</dt><dd><p>Swiss canton.</p>
</dd>
<dt>REG</dt><dd><p>Swiss region.</p>
</dd>
<dt>COM</dt><dd><p>municipality number.</p>
</dd>
<dt>Nom</dt><dd><p>municipality name.</p>
</dd>
<dt>HApoly</dt><dd><p>municipality area.</p>
</dd>
<dt>Surfacesbois</dt><dd><p>wood area.</p>
</dd>
<dt>Surfacescult</dt><dd><p>area under cultivation.</p>
</dd>
<dt>Alp</dt><dd><p>mountain pasture area.</p>
</dd>
<dt>Airbat</dt><dd><p>area with buildings.</p>
</dd>
<dt>Airind</dt><dd><p>industrial area.</p>
</dd>
<dt>P00BMTOT</dt><dd><p>number of men.</p>
</dd>
<dt>P00BWTOT</dt><dd><p>number of women.</p>
</dd>
<dt>Pop020</dt><dd><p>number of men and women aged between 0 and 19.</p>
</dd>
<dt>Pop2040</dt><dd><p>number of men and women aged between 20 and 39.</p>
</dd>
<dt>Pop4065</dt><dd><p>number of men and women aged between 40 and 64.</p>
</dd>
<dt>Pop65P</dt><dd><p>number of men and women aged between 65 and over.</p>
</dd>
<dt>H00PTOT</dt><dd><p>number of households.</p>
</dd>
<dt>H00P01</dt><dd><p>number of households with 1 person.</p>
</dd>
<dt>H00P02</dt><dd><p>number of households with 2 persons.</p>
</dd>
<dt>H00P03</dt><dd><p>number of households with 3 persons.</p>
</dd>
<dt>H00P04</dt><dd><p>number of households with 4 persons.</p>
</dd>
<dt>POPTOT</dt><dd><p>total population.</p>
</dd>
<dt>lat</dt><dd><p>latitude.</p>
</dd>
<dt>long</dt><dd><p>longitude.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Swiss Federal Statistical Office.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># data(swissmunicipalities)
# hist(swissmunicipalities$POPTOT)
</code></pre>

<hr>
<h2 id='swissstrata'>
Dataframe containing information on strata in the swiss municipalities frame
</h2><span id='topic+swissstrata'></span>

<h3>Description</h3>

<p>Dataframe containing information on strata in the swiss municipalities frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(swissframe)</code></pre>


<h3>Format</h3>

<p>The &quot;swissstrata&quot; dataframe contains a row per stratum with the following variables: 
</p>

<dl>
<dt>STRATO</dt><dd>
<p>Identifier of the stratum (character)
</p>
</dd>
<dt>N</dt><dd>
<p>Number of population units in the stratum (numeric) 
</p>
</dd>
<dt>X1</dt><dd>
<p>Classes of total population in the municipality (factor with 18 values)
</p>
</dd>
<dt>X2</dt><dd>
<p>Classes of wood area in the municipality (factor with 3 values)
</p>
</dd>
<dt>X3</dt><dd>
<p>Classes of area under cultivation in the municipality (factor with 3 values)
</p>
</dd>
<dt>X4</dt><dd>
<p>Classes of mountain pasture area in the municipality (factor with 3 values)
</p>
</dd>
<dt>X5</dt><dd>
<p>Classes of area with buildings in the municipality (factor with 3 values)
</p>
</dd>
<dt>X6</dt><dd>
<p>Classes of industrial area in the municipality (factor with 3 values)
</p>
</dd>
<dt>M1</dt><dd>
<p>Mean in the stratum of Y1 (number of men and women aged between 0 and 19)(numeric)
</p>
</dd>
<dt>M2</dt><dd>
<p>Mean in the stratum of Y2 (number of men and women aged between 20 and 39) (numeric)
</p>
</dd>
<dt>M3</dt><dd>
<p>Mean in the stratum of Y3 (number of men and women aged between 40 and 64) (numeric)
</p>
</dd>
<dt>M4</dt><dd>
<p>Mean in the stratum of Y4 (number of men and women aged between 64 and over) (numeric)
</p>
</dd>
<dt>S1</dt><dd>
<p>Standard deviation in the stratum of Y1 (number of men and women aged between 0 and 19)(numeric)
</p>
</dd>
<dt>S2</dt><dd>
<p>Standard deviation in the stratum of Y2 (number of men and women aged between 20 and 39) (numeric)
</p>
</dd>
<dt>S3</dt><dd>
<p>Standard deviation in the stratum of Y3 (number of men and women aged between 40 and 64) (numeric)
</p>
</dd>
<dt>S4</dt><dd>
<p>Standard deviation in the stratum of Y4 (number of men and women aged between 64 and over) (numeric)
</p>
</dd>
<dt>cens</dt><dd>
<p>Flag (1 indicates a take all straum, 0 a sampling stratum) (numeric) 
Default = 0
</p>
</dd>
<dt>cost</dt><dd>
<p>Cost per interview in each stratum.  Default = 1 (numeric)
</p>
</dd>
<dt>DOM1</dt><dd>
<p>Value of domain to which the stratum belongs Default = 1 (factor or numeric)
</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># data(swissstrata)
# head(swissstrata)
</code></pre>

<hr>
<h2 id='tuneParameters'>
Execution and compared evaluation of optimization runs
</h2><span id='topic+tuneParameters'></span>

<h3>Description</h3>

<p>This function allows to execute a number of optimization runs,
varying in a controlled way the values of the parameters, in order to find their most suitable values.
by comparing the resulting solutions.
It can be applied only to a given domain per time.
Most parameters of this function are the same than those of the function 'optimizeStrata', but they are given 
in a vectorial format. The length of each vector is given by the number of optimizations to be run: 
it is therefore possible to define different combination of values of the parameters for each execution of 'optimizeStrata'.
After each optimization run, from the corrisponding optimized frame a given number of samples are drawn. For each of them, the 
estimates of the target variables Y's are computed (&quot;precision&quot;), together with the associated coefficients of variations, 
and the absolute differences between the values of the estimates and the true values in the population (&quot;bias&quot;).
Information on the distribution of bias (differences) and precision (CV's) are outputted, and also boxplots 
for each of them are produced, in order to permit a compared evaluation of the different solutions found in the different runs.
As the optimal solution is stored for each run, after the evaluation it is possible to use it directly, or as a
&quot;suggestion&quot; for a new optimization with more iterations (in order to improve it).  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tuneParameters (
		noptim,
		nsampl,
		frame,
		errors = errors, 
		strata = strata, 
		cens = NULL, 
		strcens = FALSE,
		alldomains = FALSE,
		dom = 1,			
		initialStrata, 
		addStrataFactor, 
		minnumstr, 
		iter, 
		pops, 
		mut_chance, 
		elitism_rate,
		writeFiles
		)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tuneParameters_+3A_noptim">noptim</code></td>
<td>

<p>Number of optimization runs to be performed
</p>
</td></tr>
<tr><td><code id="tuneParameters_+3A_nsampl">nsampl</code></td>
<td>

<p>Number of samples to be drawn from the optimized population frame after each optimization
</p>
</td></tr>
<tr><td><code id="tuneParameters_+3A_frame">frame</code></td>
<td>

<p>The (mandatory) dataframe containing the sampling frame
</p>
</td></tr>
<tr><td><code id="tuneParameters_+3A_errors">errors</code></td>
<td>

<p>This is the (mandatory) dataframe containing the precision levels expressed in terms of Coefficients of Variation
that estimates on target variables Y's of the survey must comply 
</p>
</td></tr>
<tr><td><code id="tuneParameters_+3A_strata">strata</code></td>
<td>

<p>This is the (mandatory) dataframe containing the information related to &quot;atomic&quot; strata, i.e. the strata obtained by 
the Cartesian product of all auxiliary variables X's. Information concerns the identifiability of strata
(values of X's) and variability of Y's (for each Y, mean and standard error in strata) 
</p>
</td></tr>
<tr><td><code id="tuneParameters_+3A_cens">cens</code></td>
<td>

<p>This the (optional) dataframe containing the takeall strata, those strata whose units must be selected in 
whatever sample. It has same structure than &quot;strata&quot; dataframe
</p>
</td></tr>
<tr><td><code id="tuneParameters_+3A_strcens">strcens</code></td>
<td>

<p>Flag (TRUE/FALSE) to indicate if takeall strata do exist or not. Default is FALSE
</p>
</td></tr>
<tr><td><code id="tuneParameters_+3A_alldomains">alldomains</code></td>
<td>

<p>Flag (TRUE/FALSE) to indicate if the optimization must be carried out on all domains. It must be left to its default (FALSE) 
</p>
</td></tr>
<tr><td><code id="tuneParameters_+3A_dom">dom</code></td>
<td>

<p>Indicates the domain on which the optimization runs must be performed. It is an integer value that has to be internal to the interval 
(1 &lt;&ndash;&gt; number of domains). It is mandatory, if not indicated, the default (1) is taken.
</p>
</td></tr>
<tr><td><code id="tuneParameters_+3A_initialstrata">initialStrata</code></td>
<td>

<p>This is the initial limit on the number of strata for each solution. Default is 3000.
This parameter has to be given in a vectorial format, whose length is given by the number of different optimisations
( = value of parameter 'noptim')
</p>
</td></tr>
<tr><td><code id="tuneParameters_+3A_addstratafactor">addStrataFactor</code></td>
<td>

<p>This parameter indicates the probability that at each mutation the number of strata may increase with 
respect to the current value. Default is 0.01 (1
This parameter has to be given in a vectorial format, whose length is given by the number of different optimisations
( = value of parameter 'noptim')
</p>
</td></tr>
<tr><td><code id="tuneParameters_+3A_minnumstr">minnumstr</code></td>
<td>

<p>Indicates the minimum number of units that must be allocated in each stratum. Default is 2.
This parameter has to be given in a vectorial format, whose length is given by the number of different optimisations
( = value of parameter 'noptim')
</p>
</td></tr>
<tr><td><code id="tuneParameters_+3A_iter">iter</code></td>
<td>

<p>Indicated the maximum number of iterations (= generations) of the genetic algorithm. Default is 20.
This parameter has to be given in a vectorial format, whose length is given by the number of different optimisations
( = value of parameter 'noptim')
</p>
</td></tr>
<tr><td><code id="tuneParameters_+3A_pops">pops</code></td>
<td>

<p>The dimension of each generations in terms of individuals. Default is 50.
This parameter has to be given in a vectorial format, whose length is given by the number of different optimisations
( = value of parameter 'noptim')
</p>
</td></tr>
<tr><td><code id="tuneParameters_+3A_mut_chance">mut_chance</code></td>
<td>

<p>Mutation chance: for each new individual, the probability to change each single chromosome, i.e. one bit
of the solution vector. High values of this parameter allow a deeper exploration of the solution space,
but a slower convergence, while low values permit a faster convergence, but the final solution can be
distant from the optimal one. Default is 0.05.
This parameter has to be given in a vectorial format, whose length is given by the number of different optimisations
( = value of parameter 'noptim')
</p>
</td></tr>
<tr><td><code id="tuneParameters_+3A_elitism_rate">elitism_rate</code></td>
<td>

<p>This  parameter indicates the rate of better solutions that must be preserved from one generation
to another. Default is 0.2 (20
This parameter has to be given in a vectorial format, whose length is given by the number of different optimisations
( = value of parameter 'noptim')
</p>
</td></tr>
<tr><td><code id="tuneParameters_+3A_writefiles">writeFiles</code></td>
<td>

<p>Indicates if the various dataframes and plots produced during the execution have to be written in the working
directory.
Default is FALSE.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe containing for each iteration the number of strata, the cost of the solution and the values of the expected CV's
</p>


<h3>Author(s)</h3>

<p>Giulio Barcaroli
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
## Not run: 
#------------------------------------------------------------
# data setting
library(SamplingStrata)
data(swissstrata)
data(swisserrors)
data(swissframe)
# As this function can be applied only to a given domain per time,
# we select the first domain
frame &lt;- swissframe[swissframe$domainvalue == 1,]
strata &lt;- swissstrata[swissstrata$DOM1 == 1,]
errors &lt;- swisserrors[swisserrors$domainvalue == 1,]
#------------------------------------------------------------
# parameters setting
noptim &lt;- 10 # Number of runs
nsampl &lt;- 100 # Number of samples to be drawn after each optimization
initialStrata &lt;- ceiling(c(1:noptim)*0.1*(nrow(strata))) # Number of initial strata
addStrataFactor &lt;- rep(0.01,noptim) # Rate for increasing initial strata
minnumstr &lt;- rep(2,noptim) # Minimum number of units per stratum
iter &lt;- rep(200,noptim) # Number of iterations for each optimization
pops &lt;- rep(20,noptim) # Number of solutions for each iteration
mut_chance &lt;- rep(0.004,noptim) # Mutation chance
elitism_rate &lt;- rep(0.2,noptim) # Elitism rate
#------------------------------------------------------------
results &lt;- tuneParameters (
  noptim,
  nsampl,
  frame,
  errors = errors, 
  strata = strata,
  cens = NULL, 
  strcens = FALSE,
  alldomains = FALSE,
  dom = 1,			
  initialStrata, 
  addStrataFactor, 
  minnumstr, 
  iter, 
  pops, 
  mut_chance, 
  elitism_rate
  )
results

## End(Not run)
</code></pre>

<hr>
<h2 id='updateFrame'>
Updates the initial frame on the basis of the optimized stratification 
</h2><span id='topic+updateFrame'></span>

<h3>Description</h3>

<p>Once optimal stratification has been obtained, and new labels have been attributed to initial
atomic strata (&quot;newstrata&quot;), it is important to report the new classification of units in the 
sampling frame by attributing new strata labels to each unit.
By executing this function, a new frame will be obtained with the same structure of the old, 
but with the addition of a new stratum label.
The initial frame must contain a variable named 'domainvalue' that indicates the 
same values of the domain that has been used with the 'optimizeStrata' function. 
If no domains have been defined, this variable will contains all 1's, but it must exist
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updateFrame(frame, newstrata, writeFiles = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updateFrame_+3A_frame">frame</code></td>
<td>

<p>This is the (mandatory) dataframe containing the sampling frame. 
</p>
</td></tr>
<tr><td><code id="updateFrame_+3A_newstrata">newstrata</code></td>
<td>

<p>This is the (mandatory) dataframe containing the information related to the optimisation applied to 
initial stratification (new labels applied to atomic strata). It is produced by executing 
the &quot;updateStrata&quot; function. 
</p>
</td></tr>
<tr><td><code id="updateFrame_+3A_writefiles">writeFiles</code></td>
<td>

<p>Flag to write or not the new sampling frame into the working directory.
Default is &quot;FALSE&quot;
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe containing the frame
</p>


<h3>Author(s)</h3>

<p>Giulio Barcaroli
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# The following example is realistic, but is time consuming
#
## Not run: 
library(SamplingStrata)
data(swisserrors)
data(swissstrata)
# optimisation of sampling strata
solution &lt;- optimizeStrata ( 
    errors = swisserrors, 
    strata = swissstrata)
# updating sampling strata with new strata labels
newstrata &lt;- updateStrata(swissstrata, solution, writeFiles = TRUE)
# updating sampling frame with new strata labels
data(swissframe)
framenew &lt;- updateFrame(frame=swissframe, newstrata=newstrata, writeFiles = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='updateStrata'>
Assigns new labels to atomic strata on the basis of the optimized aggregated strata 
</h2><span id='topic+updateStrata'></span>

<h3>Description</h3>

<p>Once optimal stratification has been obtained ('outstrata'), then we need to attribute 
new strata labels to each atomic stratum.
By executing this function, a new dataframe &quot;newstrata&quot; will be obtained with the same structure of the old, 
(&quot;strata&quot;) but with the addition of a new stratum label.
By indicating &quot;YES&quot; to &quot;writeFile&quot; parameter, the dataframe &quot;newstrata&quot; will be written to a delimited file 
(&quot;newstrata.txt&quot;).
Also a second delimited file (&quot;strata_aggregation.txt&quot;) will be outputted, 
containing the indication of the relations bewteen atomic and aggregated strata. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updateStrata(strata, solution, writeFiles = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updateStrata_+3A_strata">strata</code></td>
<td>

<p>This is the (mandatory) dataframe containing the information related to the atomic strata to which the 
optimisation has been applied to. 
</p>
</td></tr>
<tr><td><code id="updateStrata_+3A_solution">solution</code></td>
<td>

<p>List obtained by the execution of the &quot;optimizeStrata&quot; function. The first element of the list is the vector
of the indices corresponding to the optimal solution.
</p>
</td></tr>
<tr><td><code id="updateStrata_+3A_writefiles">writeFiles</code></td>
<td>

<p>Indicates if at the end of the processing the resulting strata will be outputted in a delimited file.
Default is &quot;FALSE&quot;.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe containing the strata
</p>


<h3>Author(s)</h3>

<p>Giulio Barcaroli
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(SamplingStrata)
data(swisserrors)
data(swissstrata)
# optimisation of sampling strata
solution &lt;- optimizeStrata ( 
    errors = swisserrors, 
    strata = swissstrata, 
)
# updating sampling strata with new strata labels
newstrata &lt;- updateStrata(swissstrata, solution, writeFiles = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='var.bin'>
Allows to transform a continuous variable into a categorical ordinal one
by applying a modified version of the k-means clustering function in the 'stats' package.
</h2><span id='topic+var.bin'></span>

<h3>Description</h3>

<p>The optimization of a frame stratification is applicable only in presence of all categorical
auxiliary variables in the frame. If one or more continuous auxiliary variables are in the frame, 
it is necessary to pre-process in order to convert them into categorical (ordinal) variables.
The applied method is the &quot;k-means&quot; clustering method contained in the in &quot;stats&quot; package.
This function ensures that the final result is in an ordered categorical variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var.bin(x,
		bins=3,
		iter.max=100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="var.bin_+3A_x">x</code></td>
<td>

<p>Continuous variable to be transformed into a categorical one 
</p>
</td></tr>
<tr><td><code id="var.bin_+3A_bins">bins</code></td>
<td>

<p>Number of values of the resulting categorical variable
</p>
</td></tr>
<tr><td><code id="var.bin_+3A_iter.max">iter.max</code></td>
<td>

<p>Maximum number of iterations of the clustering algorithm
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Binned variable
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(SamplingStrata)
data(swissmunicipalities)
data(swissframe)
swissframe$X1 &lt;- var.bin(swissmunicipalities$POPTOT,bins = 18)
table(swissframe$X1)
tapply(swissmunicipalities$POPTOT,swissframe$X1,mean)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
