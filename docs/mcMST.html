<!DOCTYPE html><html><head><title>Help for package mcMST</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mcMST}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#mcMST-package'><p>mcMST: A Toolbox for the Multi-Criteria Minimum Spanning Tree Problem.</p></a></li>
<li><a href='#charVecToEdgelist'><p>Convert characteristic vector to edge list.</p></a></li>
<li><a href='#computeSimilarityMatrix'><p>Compute similarity matrix.</p></a></li>
<li><a href='#edgeListToCharVec'><p>Convert edge list to characteristic vector.</p></a></li>
<li><a href='#enumerateTSP'><p>Enumerate all solution candidates.</p></a></li>
<li><a href='#genRandomMCGP'><p>Generate a bi-criteria graph with two uniformly randomly distribted edge weights.</p></a></li>
<li><a href='#genRandomSpanningTree'><p>Generate a random spanning tree.</p></a></li>
<li><a href='#genRandomSpanningTrees'><p>Generate a set of random spanning trees.</p></a></li>
<li><a href='#getCommonSubtrees'><p>Get common subtrees of two trees.</p></a></li>
<li><a href='#getExactFront'><p>Enumerate all Pareto-optimal solutions.</p></a></li>
<li><a href='#getExtremeSolutions'><p>Compute extreme spanning trees of bi-criteria graph problem.</p></a></li>
<li><a href='#getNumberOfSpanningTrees'><p>Compute number of spanning trees of a graph</p></a></li>
<li><a href='#getRandomSpanningTree'><p>Generate random spanning tree.</p></a></li>
<li><a href='#getWeight'><p>Get the overall costs/weight of a subgraph given its edgelist.</p></a></li>
<li><a href='#mcMSTEmoaBG'><p>Subgraph EMOA for the multi-criteria MST problem.</p></a></li>
<li><a href='#mcMSTEmoaZhou'><p>Pruefer-EMOA for the multi-objective MST problem.</p></a></li>
<li><a href='#mcMSTPrim'><p>Multi-Objective Prim algorithm.</p></a></li>
<li><a href='#mutEdgeExchange'><p>One-edge-exchange mutator for edge list representation of spanning trees.</p></a></li>
<li><a href='#mutKEdgeExchange'><p>k-edge-exchange mutator for edge list representation of spanning trees.</p></a></li>
<li><a href='#mutSubforestMST'><p>Forest-mutator for edge list representation.</p></a></li>
<li><a href='#mutSubgraphMST'><p>Subgraph-mutator for edge list representation.</p></a></li>
<li><a href='#mutUniformPruefer'><p>Uniform mutation for Pruefer code representation.</p></a></li>
<li><a href='#nodelistToEdgelist'><p>Convert sequence of nodes to edge list.</p></a></li>
<li><a href='#permutationToCharVec'><p>Convert permutation to characteristic vector.</p></a></li>
<li><a href='#permutationToEdgelist'><p>Convert permutation to edge list.</p></a></li>
<li><a href='#plotEdgeFrequency'><p>Visualization of edge frequency among solution set.</p></a></li>
<li><a href='#plotEdges'><p>Visualize edges common to several solutions.</p></a></li>
<li><a href='#prueferToCharVec'><p>Convert Pruefer code to characteristic vector.</p></a></li>
<li><a href='#prueferToEdgeList'><p>Convert Pruefer code to edge list.</p></a></li>
<li><a href='#sampleWeights'><p>Sample weights</p></a></li>
<li><a href='#scalarizeWeights'><p>Scalarize weight matrizes.</p></a></li>
<li><a href='#similarity_metrics'><p>Metrics for spanning tree comparisson.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>A Toolbox for the Multi-Criteria Minimum Spanning Tree Problem</td>
</tr>
<tr>
<td>Description:</td>
<td>Algorithms to approximate the Pareto-front of multi-criteria minimum spanning tree problems.</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-03-13</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jakob Bossek &lt;j.bossek@gmail.com&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-2-Clause">BSD_2_clause</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jakobbossek/mcMST">https://github.com/jakobbossek/mcMST</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jakobbossek/mcMST/issues">https://github.com/jakobbossek/mcMST/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>BBmisc (&ge; 1.6), ecr (&ge; 2.1.0), grapherator</td>
</tr>
<tr>
<td>Imports:</td>
<td>checkmate (&ge; 1.1), gtools, ggplot2 (&ge; 1.0.0), vegan, qgraph,
viridis, igraph</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 0.9.1), knitr, rmarkdown, gridExtra</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-13 18:49:57 UTC; bossek</td>
</tr>
<tr>
<td>Author:</td>
<td>Jakob Bossek [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-13 19:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='mcMST-package'>mcMST: A Toolbox for the Multi-Criteria Minimum Spanning Tree Problem.</h2><span id='topic+mcMST-package'></span>

<h3>Description</h3>

<p>The <span class="pkg">mcMST</span> package provides a set of algorithms to
approximate the Pareto-optimal set/front of multi-criteria
minimum spanning tree (mcMST) problems.
</p>


<h3>Algorithms</h3>

<p>Currently, the following algorithms are included:
</p>

<dl>
<dt>mcPrim</dt><dd><p>A multi-criteria version of Prim's algorithm
for the single-objective MST (see [1]).</p>
</dd>
<dt>ZhouEmoa</dt><dd><p>Evolutionary multi-objective algorithm operating
on the Pruefer-encoding as proposed by Zhou and Gen [2].</p>
</dd>
<dt>BGEmoa</dt><dd><p>Evolutionary multi-objective algorithm operating
on a direct edge list encoding. This algorithm applies a sub-tree
based mutation operator as proposed by Bossek and Grimme [3].</p>
</dd>
<dt>Exhaustive Enumeration</dt><dd><p>A simple method to enumerate all Pareto-optimal
solutions of a given combinatorial problem. This method is not limited to
mcMST problems.</p>
</dd>
</dl>



<h3>References</h3>

<p>[1] Knowles, J. D., and Corne, D. W. 2001. A Comparison of Encodings
and Algorithms for Multiobjective Minimum Spanning Tree Problems.
In Proceedings of the 2001 Congress on Evolutionary Computation (Ieee
Cat. No.01TH8546), 1:544–51 vol. 1. doi:10.1109/CEC.2001.934439.
</p>
<p>[2] Zhou, G., and Gen, M. 1999. Genetic Algorithm Approach on
Multi-Criteria Minimum Spanning Tree Problem. European Journal of
Operational Research 114 (1): 141–52.
doi:https://doi.org/10.1016/S0377- 2217(98)00016-2.
</p>
<p>[3] Bossek, J., and Grimme, C. 2017. A Pareto-Beneficial Sub-Tree Mutation
for the Multi-Criteria Minimum Spanning Tree Problem. In Proceedings of the
2017 IEEE Symposium Series on Computational Intelligence. (accepted)
</p>

<hr>
<h2 id='charVecToEdgelist'>Convert characteristic vector to edge list.</h2><span id='topic+charVecToEdgelist'></span>

<h3>Description</h3>

<p>Convert characteristic vector to edge list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>charVecToEdgelist(charvec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="charVecToEdgelist_+3A_charvec">charvec</code></td>
<td>
<p>[<code>integer</code>]
Characteristic vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>matrix</code>] Edge list.
</p>


<h3>See Also</h3>

<p>Other transformation functions: 
<code><a href="#topic+edgeListToCharVec">edgeListToCharVec</a>()</code>,
<code><a href="#topic+nodelistToEdgelist">nodelistToEdgelist</a>()</code>,
<code><a href="#topic+permutationToCharVec">permutationToCharVec</a>()</code>,
<code><a href="#topic+permutationToEdgelist">permutationToEdgelist</a>()</code>,
<code><a href="#topic+prueferToCharVec">prueferToCharVec</a>()</code>,
<code><a href="#topic+prueferToEdgeList">prueferToEdgeList</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># here we generate a random Pruefer-code representing
# a random spanning tree of a graph with n = 10 nodes
pcode = sample(1:10, 8, replace = TRUE)#'
edgelist = charVecToEdgelist(prueferToCharVec(pcode))
</code></pre>

<hr>
<h2 id='computeSimilarityMatrix'>Compute similarity matrix.</h2><span id='topic+computeSimilarityMatrix'></span>

<h3>Description</h3>

<p>Given a list of objects and a function which computes a similarity
measure between two objects of the list, <code>computeSimilarity</code> returns a
similarity matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeSimilarityMatrix(set, sim.fun, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeSimilarityMatrix_+3A_set">set</code></td>
<td>
<p>[<code>list</code>]<br />
List of objects.</p>
</td></tr>
<tr><td><code id="computeSimilarityMatrix_+3A_sim.fun">sim.fun</code></td>
<td>
<p>[<code>function(x, y, ...)</code>]<br />
Function which expects two objects <code>x</code> and <code>y</code> as first and second
arguments and returns a scalar value.</p>
</td></tr>
<tr><td><code id="computeSimilarityMatrix_+3A_...">...</code></td>
<td>
<p>[any]<br />
Passed down to <code>sim.fun</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>matrix(n, n)</code>] <code class="reqn">(n,n)</code> matrix with <code class="reqn">n</code> being the length of <code>set</code>.
</p>

<hr>
<h2 id='edgeListToCharVec'>Convert edge list to characteristic vector.</h2><span id='topic+edgeListToCharVec'></span>

<h3>Description</h3>

<p>Convert edge list to characteristic vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edgeListToCharVec(edgelist, n = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edgeListToCharVec_+3A_edgelist">edgelist</code></td>
<td>
<p>[<code>matrix(2, k)</code>]
Matrix of edges (each column is one edge).</p>
</td></tr>
<tr><td><code id="edgeListToCharVec_+3A_n">n</code></td>
<td>
<p>[<code>integer</code>]<br />
Number of nodes of the problem.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>integer</code>] Characteristic vector cv with cv[i] = 1 if the i-th edge is in the tree.
</p>


<h3>See Also</h3>

<p>Other transformation functions: 
<code><a href="#topic+charVecToEdgelist">charVecToEdgelist</a>()</code>,
<code><a href="#topic+nodelistToEdgelist">nodelistToEdgelist</a>()</code>,
<code><a href="#topic+permutationToCharVec">permutationToCharVec</a>()</code>,
<code><a href="#topic+permutationToEdgelist">permutationToEdgelist</a>()</code>,
<code><a href="#topic+prueferToCharVec">prueferToCharVec</a>()</code>,
<code><a href="#topic+prueferToEdgeList">prueferToEdgeList</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># first we generate a small edge list by hand
# (assume the given graph has n = 4 nodes)
edgelist = matrix(c(1, 2, 2, 4, 3, 4), ncol = 3)
print(edgelist)
# next we transform the edge into
# a characteristic vector
cvec = edgeListToCharVec(edgelist, n = 4)
print(cvec)
</code></pre>

<hr>
<h2 id='enumerateTSP'>Enumerate all solution candidates.</h2><span id='topic+enumerateTSP'></span><span id='topic+enumerateMST'></span>

<h3>Description</h3>

<p>These functions enumerate all candidate solutions for
a certain combinatorial optimization problem, e.g., all permutations
for a TSP or all Pruefer-codes for a MST problem. Note that the output
grows exponentially with the instance size <code>n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enumerateTSP(n)

enumerateMST(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="enumerateTSP_+3A_n">n</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Instance size.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>matrix</code>] Each row contains a candidate solution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sols = enumerateTSP(4L)
sols = enumerateMST(4L)
</code></pre>

<hr>
<h2 id='genRandomMCGP'>Generate a bi-criteria graph with two uniformly randomly distribted edge weights.</h2><span id='topic+genRandomMCGP'></span>

<h3>Description</h3>

<p>The instance is composed of two
symmetric weight matrices. The first weight is drawn independently at
random from a <code class="reqn">\mathcal{R}[10, 100]</code> distribution, the second one
from a <code class="reqn">\mathcal{R}[10, 50]</code> distribution (see references).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genRandomMCGP(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genRandomMCGP_+3A_n">n</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Instance size, i.e., number of nodes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code><a href="grapherator.html#topic+grapherator">grapherator</a></code>] Graph.
</p>


<h3>Note</h3>

<p>This is a simple wrapper around the much more flexible graph generation
system in package <span class="pkg">grapherator</span>.
</p>


<h3>References</h3>

<p>Zhou, G. and Gen, M. Genetic Algorithm Approach on Multi-Criteria
Minimum Spanning Tree Problem. In: European Journal of Operational Research (1999).
</p>
<p>Knowles, JD &amp; Corne, DW 2001, A comparison of encodings and algorithms for multiobjective
minimum spanning tree problems. in Proceedings of the IEEE Conference on Evolutionary
Computation, ICEC|Proc IEEE Conf Evol Comput Proc ICEC. vol. 1, Institute of Electrical
and Electronics Engineers , pp. 544-551, Congress on Evolutionary Computation 2001,
Soul, 1 July.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g = genRandomMCGP(10L)
## Not run: 
pl = grapherator::plot(g)

## End(Not run)
</code></pre>

<hr>
<h2 id='genRandomSpanningTree'>Generate a random spanning tree.</h2><span id='topic+genRandomSpanningTree'></span>

<h3>Description</h3>

<p>Generate a random spanning tree of a graph
given the number of nodes of the problem instance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genRandomSpanningTree(n, type = "pruefer")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genRandomSpanningTree_+3A_n">n</code></td>
<td>
<p>[<code>integer</code>]<br />
Number of nodes of the problem.</p>
</td></tr>
<tr><td><code id="genRandomSpanningTree_+3A_type">type</code></td>
<td>
<p>[<code>character(1)</code>]<br />
String representing the desired format of the generated
spanning tree. Possible values are &ldquo;pruefer&rdquo; (Pruefer-code),
&ldquo;edgelist&rdquo; and &ldquo;charvec&rdquo; (characteristic vector).
Default is &ldquo;pruefer&rdquo;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>integer</code> | <code>matrix(2, n)</code>] Return type depends on <code>type</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>genRandomSpanningTree(10)
genRandomSpanningTree(10, type = "edgelist")
</code></pre>

<hr>
<h2 id='genRandomSpanningTrees'>Generate a set of random spanning trees.</h2><span id='topic+genRandomSpanningTrees'></span>

<h3>Description</h3>

<p>Generate a set of random spanning trees of a graph
given the number of nodes of the problem instance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genRandomSpanningTrees(m, n, type = "pruefer", simplify = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genRandomSpanningTrees_+3A_m">m</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of random spanning trees to be generated.</p>
</td></tr>
<tr><td><code id="genRandomSpanningTrees_+3A_n">n</code></td>
<td>
<p>[<code>integer</code>]<br />
Number of nodes of the problem.</p>
</td></tr>
<tr><td><code id="genRandomSpanningTrees_+3A_type">type</code></td>
<td>
<p>[<code>character(1)</code>]<br />
String representing the desired format of the generated
spanning tree. Possible values are &ldquo;pruefer&rdquo; (Pruefer-code),
&ldquo;edgelist&rdquo; and &ldquo;charvec&rdquo; (characteristic vector).
Default is &ldquo;pruefer&rdquo;.</p>
</td></tr>
<tr><td><code id="genRandomSpanningTrees_+3A_simplify">simplify</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Should the result be simplified to a matrix if appropriate?
Only relevant if <code>type</code> is either &ldquo;pruefer&rdquo; or
&ldquo;charvec&rdquo;.
Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>list</code> | <code>matrix</code>] Result type depends on <code>simplify</code>
and <code>type</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>genRandomSpanningTrees(3, 10)
genRandomSpanningTrees(3, 10, simplify = FALSE)

genRandomSpanningTrees(3, 10, type = "edgelist")
</code></pre>

<hr>
<h2 id='getCommonSubtrees'>Get common subtrees of two trees.</h2><span id='topic+getCommonSubtrees'></span>

<h3>Description</h3>

<p>Given two spanning trees, the function returns the subtrees
of the intersection of these.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCommonSubtrees(x, y, n = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCommonSubtrees_+3A_x">x</code></td>
<td>
<p>[<code>matrix</code>]<br />
Edge list of first tree.</p>
</td></tr>
<tr><td><code id="getCommonSubtrees_+3A_y">y</code></td>
<td>
<p>[<code>matrix</code>]<br />
Edge list of second tree.</p>
</td></tr>
<tr><td><code id="getCommonSubtrees_+3A_n">n</code></td>
<td>
<p>[<code>integer(1)</code> | <code>NULL</code>]<br />
Number of nodes.
Default to <code>ncol(x) + 1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>list</code>] List of matrizes. Each matrix contains the edges of one
connected subtree.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># assume we have a graph with n = 10 nodes
n.nodes = 10
# we define two trees (matrices with colwise edges)
stree1 = matrix(c(1, 2, 1, 3, 2, 4, 5, 6, 6, 7), byrow = FALSE, nrow = 2)
stree2 = matrix(c(1, 3, 1, 2, 2, 4, 5, 8, 6, 7), byrow = FALSE, nrow = 2)
# ... and compute all common subtrees
subtrees = getCommonSubtrees(stree1, stree2, n = 10)
</code></pre>

<hr>
<h2 id='getExactFront'>Enumerate all Pareto-optimal solutions.</h2><span id='topic+getExactFront'></span>

<h3>Description</h3>

<p>Function which expects a problem instance of a combinatorial optimization
problem (e.g., MST), a multi-objective function and a solution enumerator, i.e., a function
which enumerates all possible solutions (e.g., all Pruefer codes in case of a
MST problem) and  determines both the Pareto front and Pareto set by
exhaustive enumeration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getExactFront(instance, obj.fun, enumerator.fun, n.objectives, simplify = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getExactFront_+3A_instance">instance</code></td>
<td>
<p>[any]<br />
Problem instance.</p>
</td></tr>
<tr><td><code id="getExactFront_+3A_obj.fun">obj.fun</code></td>
<td>
<p>[<code>function(solution, instance)</code>]<br />
Objective function which expects a numeric vector <code>solution</code> encoding a
solution candidate and a problem instance <code>instance</code>. The function should
return a numeric vector of length <code>n.objectives</code>.</p>
</td></tr>
<tr><td><code id="getExactFront_+3A_enumerator.fun">enumerator.fun</code></td>
<td>
<p>[<code>function(n)</code>]<br />
Function to exhaustively generate all possible candidate solutions.
Expects a single integer value n, i.e., the instance size, e.g., the
number of nodes for a graph problem.</p>
</td></tr>
<tr><td><code id="getExactFront_+3A_n.objectives">n.objectives</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of objectives of problem.</p>
</td></tr>
<tr><td><code id="getExactFront_+3A_simplify">simplify</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Should pareto set be simplified to matrix?
This will only be done if all elements are of the same length. Otherwise
the parameter will be ignored.
Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>list</code>] List with elements <code>pareto.set</code> (matrix of Pareto-optimal solutions)
and <code>pareto.front</code> (matrix of corresponding weight vectors).
</p>


<h3>Note</h3>

<p>This method exhaustively enumerates all possible solutions
of a given multi-objective combinatorial optimization problem. Thus,
it is limited to small input size due to combinatorial explosion.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># here we enumerate all Pareto-optimal solutions of a bi-objective mcMST problem
# we use the Pruefer-code enumerator. Thus, we need to define an objective
# function, which is able to handle this type of endcoding
objfunMCMST = function(pcode, instance) {
  getWeight(instance, prueferToEdgeList(pcode))
}

# next we generate a random bi-objective graph
g = genRandomMCGP(5L)

# ... and finally compute the exact front of g
res = getExactFront(g, obj.fun = objfunMCMST, enumerator.fun = enumerateMST, n.objectives = 2L)
## Not run: 
plot(res$pareto.front)

## End(Not run)
</code></pre>

<hr>
<h2 id='getExtremeSolutions'>Compute extreme spanning trees of bi-criteria graph problem.</h2><span id='topic+getExtremeSolutions'></span>

<h3>Description</h3>

<p>Internally <code><a href="#topic+mcMSTPrim">mcMSTPrim</a></code> is called with weights set accordingly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getExtremeSolutions(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getExtremeSolutions_+3A_graph">graph</code></td>
<td>
<p>[<code><a href="grapherator.html#topic+grapherator">grapherator</a></code>]<br />
Graph.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>matrix(2, 2)</code>] The i-th column contains the objective vector
of the extreme i-th extreme solution
</p>

<hr>
<h2 id='getNumberOfSpanningTrees'>Compute number of spanning trees of a graph</h2><span id='topic+getNumberOfSpanningTrees'></span>

<h3>Description</h3>

<p>Makes use of Kirchhoff's matrix tree theorem to compute the
number of spanning trees of a given graph in polynomial time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getNumberOfSpanningTrees(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getNumberOfSpanningTrees_+3A_graph">graph</code></td>
<td>
<p>[<code><a href="grapherator.html#topic+grapherator">grapherator</a></code>]<br />
Graph.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>integer(1)</code>]
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate complete graph
g = genRandomMCGP(10)

# this is equal to 10^8 (Cayley's theorem)
getNumberOfSpanningTrees(g)
</code></pre>

<hr>
<h2 id='getRandomSpanningTree'>Generate random spanning tree.</h2><span id='topic+getRandomSpanningTree'></span>

<h3>Description</h3>

<p>Given a <code><a href="grapherator.html#topic+grapherator">grapherator</a></code> object this function
returns a random spanning tree. The tree generation process is a simple heuristic:
A random weight from a <code class="reqn">U(0, 1)</code>-distribution is assigned to each edge of the
graph. Next, a spanning tree is computed by <code><a href="vegan.html#topic+spantree">spantree</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRandomSpanningTree(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getRandomSpanningTree_+3A_graph">graph</code></td>
<td>
<p>[<code><a href="grapherator.html#topic+grapherator">grapherator</a></code>]<br />
Graph.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>matrix</code>] Edge list of spanning tree edges.
</p>


<h3>Note</h3>

<p>Most likely this heuristic does not produce each spanning tree with equal
probability.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g = genRandomMCGP(10L)
stree = getRandomSpanningTree(g)
</code></pre>

<hr>
<h2 id='getWeight'>Get the overall costs/weight of a subgraph given its edgelist.</h2><span id='topic+getWeight'></span>

<h3>Description</h3>

<p>Get the overall costs/weight of a subgraph given its edgelist.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getWeight(graph, edgelist, obj.types = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getWeight_+3A_graph">graph</code></td>
<td>
<p>[<code><a href="grapherator.html#topic+grapherator">grapherator</a></code>]<br />
Graph.</p>
</td></tr>
<tr><td><code id="getWeight_+3A_edgelist">edgelist</code></td>
<td>
<p>[<code>matrix(2, k)</code>]
Matrix of edges (each column is one edge).</p>
</td></tr>
<tr><td><code id="getWeight_+3A_obj.types">obj.types</code></td>
<td>
<p>[<code>character</code>]<br />
How to aggregate edge weights?
Possible values are &ldquo;sum&rdquo; for sum objective and &ldquo;bottleneck&rdquo;
for bottleneck/min-max objectives.
Default is &ldquo;sum&rdquo; for each objective.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>numeric(2)</code>] Weight vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a random bi-objective graph
g = genRandomMCGP(5)

# generate a random Pruefer code, i.e., a random spanning tree of g
pcode = sample(1:5, 3, replace = TRUE)

getWeight(g, prueferToEdgeList(pcode))
getWeight(g, prueferToEdgeList(pcode), obj.types = "bottleneck")
</code></pre>

<hr>
<h2 id='mcMSTEmoaBG'>Subgraph EMOA for the multi-criteria MST problem.</h2><span id='topic+mcMSTEmoaBG'></span>

<h3>Description</h3>

<p>Evolutionary multi-objective algorithm to solve the
multi-objective minimum spanning tree problem. The algorithm relies
to mutation only to generate offspring. The package contains the subgraph mutator
(see <code><a href="#topic+mutSubgraphMST">mutSubgraphMST</a></code>) or a simple one-edge exchange mutator
(see <code><a href="#topic+mutEdgeExchange">mutEdgeExchange</a></code>). Of course, the user may use any
custom mutator which operators on edge lists as well
(see <code><a href="ecr.html#topic+makeMutator">makeMutator</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcMSTEmoaBG(
  instance,
  mu,
  lambda = mu,
  mut = NULL,
  selMating = NULL,
  selSurvival = ecr::selNondom,
  ref.point = NULL,
  max.iter = 100L,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcMSTEmoaBG_+3A_instance">instance</code></td>
<td>
<p>[<code><a href="grapherator.html#topic+grapherator">grapherator</a></code>]<br />
Multi-objective graph.</p>
</td></tr>
<tr><td><code id="mcMSTEmoaBG_+3A_mu">mu</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Population size.</p>
</td></tr>
<tr><td><code id="mcMSTEmoaBG_+3A_lambda">lambda</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of offspring generated in each generation.
Default is <code>mu</code>.</p>
</td></tr>
<tr><td><code id="mcMSTEmoaBG_+3A_mut">mut</code></td>
<td>
<p>[<code>ecr_mutator</code>]<br />
Mutation operator.
Default is <code><a href="#topic+mutSubgraphMST">mutSubgraphMST</a></code>.</p>
</td></tr>
<tr><td><code id="mcMSTEmoaBG_+3A_selmating">selMating</code></td>
<td>
<p>[<code>ecr_selector</code>]<br />
Mating selector.
Default is <code><a href="ecr.html#topic+selSimple">selSimple</a></code>.</p>
</td></tr>
<tr><td><code id="mcMSTEmoaBG_+3A_selsurvival">selSurvival</code></td>
<td>
<p>[<code>ecr_selector</code>]<br />
Survival selector.
Default is <code>link[ecr]{selNondom}</code>.</p>
</td></tr>
<tr><td><code id="mcMSTEmoaBG_+3A_ref.point">ref.point</code></td>
<td>
<p>[<code>numeric(n.objectives) | NULL</code>]<br />
Reference point for hypervolume computation used for logging.
If <code>NULL</code> the sum of the <code class="reqn">n</code> largest edges in each objective
is used where <code class="reqn">n</code> is the number of nodes of <code>instance</code>.
This is an upper bound for the size of each spanning tree
with <code class="reqn">(n-1)</code> edges.</p>
</td></tr>
<tr><td><code id="mcMSTEmoaBG_+3A_max.iter">max.iter</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Maximal number of iterations.
Default is <code>100</code>.</p>
</td></tr>
<tr><td><code id="mcMSTEmoaBG_+3A_...">...</code></td>
<td>
<p>[<code>any</code>]<br />
Further parameters passed to mutator.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code><a href="ecr.html#topic+ecr_result">ecr_result</a></code>] List of type <code><a href="ecr.html#topic+ecr_result">ecr_result</a></code>
with the following components:
</p>

<dl>
<dt>task</dt><dd><p>The <code>ecr_optimization_task</code>.</p>
</dd>
<dt>log</dt><dd><p>Logger object.</p>
</dd>
<dt>pareto.idx</dt><dd><p>Indizes of the non-dominated solutions in the last population.</p>
</dd>
<dt>pareto.front</dt><dd><p>(n x d) matrix of the approximated non-dominated front where n
is the number of non-dominated points and d is the number of objectives.</p>
</dd>
<dt>pareto.set</dt><dd><p>Matrix of decision space values resulting with objective values
given in pareto.front.</p>
</dd>
<dt>last.population</dt><dd><p>Last population.</p>
</dd>
<dt>message</dt><dd><p>Character string describing the reason of termination.</p>
</dd>
</dl>



<h3>References</h3>

<p>Bossek, J., and Grimme, C. A Pareto-Beneficial Sub-Tree Mutation
for the Multi-Criteria Minimum Spanning Tree Problem. In Proceedings of the
2017 IEEE Symposium Series on Computational Intelligence (2017). (accepted)
</p>


<h3>See Also</h3>

<p>Mutators <code><a href="#topic+mutSubgraphMST">mutSubgraphMST</a></code> and <code><a href="#topic+mutEdgeExchange">mutEdgeExchange</a></code>
</p>
<p>Other mcMST EMOAs: 
<code><a href="#topic+mcMSTEmoaZhou">mcMSTEmoaZhou</a>()</code>
</p>
<p>Other mcMST algorithms: 
<code><a href="#topic+mcMSTEmoaZhou">mcMSTEmoaZhou</a>()</code>,
<code><a href="#topic+mcMSTPrim">mcMSTPrim</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>inst = genRandomMCGP(10)
res = mcMSTEmoaBG(inst, mu = 20L, max.iter = 100L)
print(res$pareto.front)
print(tail(getStatistics(res$log)))
</code></pre>

<hr>
<h2 id='mcMSTEmoaZhou'>Pruefer-EMOA for the multi-objective MST problem.</h2><span id='topic+mcMSTEmoaZhou'></span>

<h3>Description</h3>

<p>Evolutionary multi-objective algorithm to solve the
multi-objective minimum spanning tree problem. The algorithm adopts the
so-called Pruefer-number as the encoding for spanning trees. A Pruefer-number
for a graph with nodes <code class="reqn">V = \{1, \ldots, n\}</code> is a sequence of <code class="reqn">n - 2</code>
numbers from <code class="reqn">V</code>. Cayleys theorem states, that a complete graph width n nodes
has exactly <code class="reqn">n^{n-2}</code> spanning trees.
The algorithm uses mutation only: each component of an individual is replaced
uniformly at random with another node number from the node set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcMSTEmoaZhou(
  instance,
  mu,
  lambda = mu,
  mut = mutUniformPruefer,
  selMating = ecr::selSimple,
  selSurvival = ecr::selNondom,
  ref.point = NULL,
  max.iter = 100L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcMSTEmoaZhou_+3A_instance">instance</code></td>
<td>
<p>[<code><a href="grapherator.html#topic+grapherator">grapherator</a></code>]<br />
Multi-objective graph.</p>
</td></tr>
<tr><td><code id="mcMSTEmoaZhou_+3A_mu">mu</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Population size.</p>
</td></tr>
<tr><td><code id="mcMSTEmoaZhou_+3A_lambda">lambda</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of offspring generated in each generation.
Default is <code>mu</code>.</p>
</td></tr>
<tr><td><code id="mcMSTEmoaZhou_+3A_mut">mut</code></td>
<td>
<p>[<code>ecr_mutator</code>]<br />
Mutation operator.
Defaults to <code><a href="#topic+mutUniformPruefer">mutUniformPruefer</a></code>, i.e., each digit of the Pruefer encoding
is replaced with some probability with a random number from <code class="reqn">V = \{1, \ldots, n\}</code>.</p>
</td></tr>
<tr><td><code id="mcMSTEmoaZhou_+3A_selmating">selMating</code></td>
<td>
<p>[<code>ecr_selector</code>]<br />
Mating selector.
Default is <code><a href="ecr.html#topic+selSimple">selSimple</a></code>.</p>
</td></tr>
<tr><td><code id="mcMSTEmoaZhou_+3A_selsurvival">selSurvival</code></td>
<td>
<p>[<code>ecr_selector</code>]<br />
Survival selector.
Default is <code>link[ecr]{selNondom}</code>.</p>
</td></tr>
<tr><td><code id="mcMSTEmoaZhou_+3A_ref.point">ref.point</code></td>
<td>
<p>[<code>numeric(n.objectives) | NULL</code>]<br />
Reference point for hypervolume computation used for logging.
If <code>NULL</code> the sum of the <code class="reqn">n</code> largest edges in each objective
is used where <code class="reqn">n</code> is the number of nodes of <code>instance</code>.
This is an upper bound for the size of each spanning tree
with <code class="reqn">(n-1)</code> edges.</p>
</td></tr>
<tr><td><code id="mcMSTEmoaZhou_+3A_max.iter">max.iter</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Maximal number of iterations.
Default is <code>100</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code><a href="ecr.html#topic+ecr_result">ecr_result</a></code>] List of type <code><a href="ecr.html#topic+ecr_result">ecr_result</a></code>
with the following components:
</p>

<dl>
<dt>task</dt><dd><p>The <code>ecr_optimization_task</code>.</p>
</dd>
<dt>log</dt><dd><p>Logger object.</p>
</dd>
<dt>pareto.idx</dt><dd><p>Indizes of the non-dominated solutions in the last population.</p>
</dd>
<dt>pareto.front</dt><dd><p>(n x d) matrix of the approximated non-dominated front where n
is the number of non-dominated points and d is the number of objectives.</p>
</dd>
<dt>pareto.set</dt><dd><p>Matrix of decision space values resulting with objective values
given in pareto.front.</p>
</dd>
<dt>last.population</dt><dd><p>Last population.</p>
</dd>
<dt>message</dt><dd><p>Character string describing the reason of termination.</p>
</dd>
</dl>



<h3>References</h3>

<p>Zhou, G. and Gen, M. Genetic Algorithm Approach on Multi-Criteria
Minimum Spanning Tree Problem. In: European Journal of Operational Research (1999).
</p>


<h3>See Also</h3>

<p>Mutator <code><a href="#topic+mutUniformPruefer">mutUniformPruefer</a></code>
</p>
<p>Other mcMST EMOAs: 
<code><a href="#topic+mcMSTEmoaBG">mcMSTEmoaBG</a>()</code>
</p>
<p>Other mcMST algorithms: 
<code><a href="#topic+mcMSTEmoaBG">mcMSTEmoaBG</a>()</code>,
<code><a href="#topic+mcMSTPrim">mcMSTPrim</a>()</code>
</p>

<hr>
<h2 id='mcMSTPrim'>Multi-Objective Prim algorithm.</h2><span id='topic+mcMSTPrim'></span>

<h3>Description</h3>

<p>Approximates the Pareto-optimal mcMST front of a multi-objective
graph problem by iteratively applying Prim's algorithm for the single-objective
MST problem to a scalarized version of the problem. I.e., the weight vector
<code class="reqn">(w_1, w_2)</code> of an edge <code class="reqn">(i, j)</code> is substituted with a weighted
sum <code class="reqn">\lambda_i w_1 + (1 - \lambda_i) w_2</code> for different weights <code class="reqn">\lambda_i \in [0, 1]</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcMSTPrim(instance, n.lambdas = NULL, lambdas = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcMSTPrim_+3A_instance">instance</code></td>
<td>
<p>[<code><a href="grapherator.html#topic+grapherator">grapherator</a></code>]<br />
Graph.</p>
</td></tr>
<tr><td><code id="mcMSTPrim_+3A_n.lambdas">n.lambdas</code></td>
<td>
<p>[<code>integer(1) | NULL</code>]<br />
Number of weights to generate. The weights are generated equdistantly
in the interval <code class="reqn">[0, 1]</code>.</p>
</td></tr>
<tr><td><code id="mcMSTPrim_+3A_lambdas">lambdas</code></td>
<td>
<p>[<code>numerci</code>]<br />
Vector of weights. This is an alternative to <code>n.lambdas</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>list</code>] List with component <code>pareto.front</code>.
</p>


<h3>Note</h3>

<p>Note that this procedure can only find socalled supported efficient
solutions, i.e., solutions on the convex hull of the Pareto-optimal front.
</p>


<h3>References</h3>

<p>J. D. Knowles and D. W. Corne, &quot;A comparison of encodings and
algorithms for multiobjective minimum spanning tree problems,&quot; in Proceedings
of the 2001 Congress on Evolutionary Computation (IEEE Cat. No.01TH8546),
vol. 1, 2001, pp. 544–551 vol. 1.
</p>


<h3>See Also</h3>

<p>Other mcMST algorithms: 
<code><a href="#topic+mcMSTEmoaBG">mcMSTEmoaBG</a>()</code>,
<code><a href="#topic+mcMSTEmoaZhou">mcMSTEmoaZhou</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g = genRandomMCGP(30)
res = mcMSTPrim(g, n.lambdas = 50)
print(res$pareto.front)
</code></pre>

<hr>
<h2 id='mutEdgeExchange'>One-edge-exchange mutator for edge list representation of spanning trees.</h2><span id='topic+mutEdgeExchange'></span>

<h3>Description</h3>

<p>Each edge is replaced with another feasible edge with probability p.
By default p = 1/m where m is the number of edges, i.e., in expectation one edge
is replaced. The operators maintains the spanning tree property, i.e., the resulting
edge list is indeed the edge list of a spanning tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutEdgeExchange(ind, p = 1/ncol(ind), instance = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutEdgeExchange_+3A_ind">ind</code></td>
<td>
<p>[<code>matrix(2, m)</code>]<br />
Matrix of edges (each column is one edge).</p>
</td></tr>
<tr><td><code id="mutEdgeExchange_+3A_p">p</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Probability of edge exchange.
Default is <code>1 / ncol(ind)</code>.</p>
</td></tr>
<tr><td><code id="mutEdgeExchange_+3A_instance">instance</code></td>
<td>
<p>[<code><a href="grapherator.html#topic+grapherator">grapherator</a></code>]<br />
Multi-objective graph.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>matrix(2, m)</code>] Mutated edge list.
</p>


<h3>See Also</h3>

<p>Evolutionary multi-objective algorithm <code><a href="#topic+mcMSTEmoaBG">mcMSTEmoaBG</a></code>
</p>
<p>Other mcMST EMOA mutators: 
<code><a href="#topic+mutKEdgeExchange">mutKEdgeExchange</a>()</code>,
<code><a href="#topic+mutSubforestMST">mutSubforestMST</a>()</code>,
<code><a href="#topic+mutSubgraphMST">mutSubgraphMST</a>()</code>,
<code><a href="#topic+mutUniformPruefer">mutUniformPruefer</a>()</code>
</p>

<hr>
<h2 id='mutKEdgeExchange'>k-edge-exchange mutator for edge list representation of spanning trees.</h2><span id='topic+mutKEdgeExchange'></span>

<h3>Description</h3>

<p>Let <code class="reqn">m</code> be the number of spanning tree edges. Then, the operator
selects <code class="reqn">1 \leq k \leq m</code> edges randomly and replaces each of the <code class="reqn">k</code>
edges with another feasible edge.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutKEdgeExchange(ind, k = 1L, instance = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutKEdgeExchange_+3A_ind">ind</code></td>
<td>
<p>[<code>matrix(2, m)</code>]<br />
Matrix of edges (each column is one edge).</p>
</td></tr>
<tr><td><code id="mutKEdgeExchange_+3A_k">k</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of edges to swap.</p>
</td></tr>
<tr><td><code id="mutKEdgeExchange_+3A_instance">instance</code></td>
<td>
<p>[<code><a href="grapherator.html#topic+grapherator">grapherator</a></code>]<br />
Multi-objective graph.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Evolutionary multi-objective algorithm <code><a href="#topic+mcMSTEmoaBG">mcMSTEmoaBG</a></code>
</p>
<p>Other mcMST EMOA mutators: 
<code><a href="#topic+mutEdgeExchange">mutEdgeExchange</a>()</code>,
<code><a href="#topic+mutSubforestMST">mutSubforestMST</a>()</code>,
<code><a href="#topic+mutSubgraphMST">mutSubgraphMST</a>()</code>,
<code><a href="#topic+mutUniformPruefer">mutUniformPruefer</a>()</code>
</p>

<hr>
<h2 id='mutSubforestMST'>Forest-mutator for edge list representation.</h2><span id='topic+mutSubforestMST'></span>

<h3>Description</h3>

<p><code>mutForestMST</code> drops k edges randomly. In consequence the
tree is decomposed into k+1 subtrees (forest). Now the operator reconnects the
subtrees by constructing a minimum spanning tree between the components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutSubforestMST(ind, sigma = ncol(ind), scalarize = FALSE, instance = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutSubforestMST_+3A_ind">ind</code></td>
<td>
<p>[<code>matrix(2, m)</code>]<br />
Matrix of edges (each column is one edge).</p>
</td></tr>
<tr><td><code id="mutSubforestMST_+3A_sigma">sigma</code></td>
<td>
<p>[<code>integer()</code>]<br />
Upper bound for number of dropped edges.</p>
</td></tr>
<tr><td><code id="mutSubforestMST_+3A_scalarize">scalarize</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Should a scalarized version of the the subproblem be solved?
If <code>TRUE</code>, a random weight <code class="reqn">\lambda \in [0,1]</code> is sampled
from a <code>U[0, 1]</code>-distribution. Next, a weighted sum
scalarization <code class="reqn">\lambda \cdot c_1 + (1 - \lambda) \cdot c_2</code>
of the subproblem is solved.
Default is <code>FALSE</code>, i.e., the single-objective subproblem is
solved. The objective to optimize for is sampled with equal probability.</p>
</td></tr>
<tr><td><code id="mutSubforestMST_+3A_instance">instance</code></td>
<td>
<p>[<code><a href="grapherator.html#topic+grapherator">grapherator</a></code>]<br />
Multi-objective graph.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>matrix(2, m)</code>] Mutated edge list.
</p>


<h3>See Also</h3>

<p>Evolutionary multi-objective algorithm <code><a href="#topic+mcMSTEmoaBG">mcMSTEmoaBG</a></code>
</p>
<p>Other mcMST EMOA mutators: 
<code><a href="#topic+mutEdgeExchange">mutEdgeExchange</a>()</code>,
<code><a href="#topic+mutKEdgeExchange">mutKEdgeExchange</a>()</code>,
<code><a href="#topic+mutSubgraphMST">mutSubgraphMST</a>()</code>,
<code><a href="#topic+mutUniformPruefer">mutUniformPruefer</a>()</code>
</p>

<hr>
<h2 id='mutSubgraphMST'>Subgraph-mutator for edge list representation.</h2><span id='topic+mutSubgraphMST'></span>

<h3>Description</h3>

<p><code>mutSubgraphMST</code> selects a random edge e = (u, v) and traverses
the tree starting form u and v respectively until a connected subtree of at most
<code>sigma</code> edges is selected. Then the subtree is replaced with the optimal spanning subtree
regarding one of the objectives with equal probability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutSubgraphMST(
  ind,
  sigma = floor(ncol(ind)/2),
  scalarize = FALSE,
  instance = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutSubgraphMST_+3A_ind">ind</code></td>
<td>
<p>[<code>matrix(2, m)</code>]<br />
Matrix of edges (each column is one edge).</p>
</td></tr>
<tr><td><code id="mutSubgraphMST_+3A_sigma">sigma</code></td>
<td>
<p>[<code>integer()</code>]<br />
Upper bound for the size of the selected subtree.</p>
</td></tr>
<tr><td><code id="mutSubgraphMST_+3A_scalarize">scalarize</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Should a scalarized version of the the subproblem be solved?
If <code>TRUE</code>, a random weight <code class="reqn">\lambda \in [0,1]</code> is sampled
from a <code>U[0, 1]</code>-distribution. Next, a weighted sum
scalarization <code class="reqn">\lambda \cdot c_1 + (1 - \lambda) \cdot c_2</code>
of the subproblem is solved.
Default is <code>FALSE</code>, i.e., the single-objective subproblem is
solved. The objective to optimize for is sampled with equal probability.</p>
</td></tr>
<tr><td><code id="mutSubgraphMST_+3A_instance">instance</code></td>
<td>
<p>[<code><a href="grapherator.html#topic+grapherator">grapherator</a></code>]<br />
Multi-objective graph.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>matrix(2, m)</code>] Mutated edge list.
</p>


<h3>See Also</h3>

<p>Evolutionary multi-objective algorithm <code><a href="#topic+mcMSTEmoaBG">mcMSTEmoaBG</a></code>
</p>
<p>Other mcMST EMOA mutators: 
<code><a href="#topic+mutEdgeExchange">mutEdgeExchange</a>()</code>,
<code><a href="#topic+mutKEdgeExchange">mutKEdgeExchange</a>()</code>,
<code><a href="#topic+mutSubforestMST">mutSubforestMST</a>()</code>,
<code><a href="#topic+mutUniformPruefer">mutUniformPruefer</a>()</code>
</p>

<hr>
<h2 id='mutUniformPruefer'>Uniform mutation for Pruefer code representation.</h2><span id='topic+mutUniformPruefer'></span>

<h3>Description</h3>

<p><code>mutUniformPruefer</code> replaces each component of a Pruefer code of length n - 2
with probability <code>p</code> with a random node number between 1 and n.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutUniformPruefer(ind, p = 1/length(ind))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutUniformPruefer_+3A_ind">ind</code></td>
<td>
<p>[<code>integer</code>]<br />
Pruefer code.</p>
</td></tr>
<tr><td><code id="mutUniformPruefer_+3A_p">p</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Probability of mutation of each component of <code>ind</code>.
Default is <code>1 / length(ind)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>integer</code>] Mutated Pruefer code.
</p>


<h3>See Also</h3>

<p>Evolutionary multi-objective algorithm <code><a href="#topic+mcMSTEmoaZhou">mcMSTEmoaZhou</a></code>
</p>
<p>Other mcMST EMOA mutators: 
<code><a href="#topic+mutEdgeExchange">mutEdgeExchange</a>()</code>,
<code><a href="#topic+mutKEdgeExchange">mutKEdgeExchange</a>()</code>,
<code><a href="#topic+mutSubforestMST">mutSubforestMST</a>()</code>,
<code><a href="#topic+mutSubgraphMST">mutSubgraphMST</a>()</code>
</p>

<hr>
<h2 id='nodelistToEdgelist'>Convert sequence of nodes to edge list.</h2><span id='topic+nodelistToEdgelist'></span>

<h3>Description</h3>

<p>Convert sequence of nodes to edge list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nodelistToEdgelist(nodelist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nodelistToEdgelist_+3A_nodelist">nodelist</code></td>
<td>
<p>[<code>integer</code>]<br />
Sequence of nodes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>matrix</code>] Edge list.
</p>


<h3>See Also</h3>

<p>Other transformation functions: 
<code><a href="#topic+charVecToEdgelist">charVecToEdgelist</a>()</code>,
<code><a href="#topic+edgeListToCharVec">edgeListToCharVec</a>()</code>,
<code><a href="#topic+permutationToCharVec">permutationToCharVec</a>()</code>,
<code><a href="#topic+permutationToEdgelist">permutationToEdgelist</a>()</code>,
<code><a href="#topic+prueferToCharVec">prueferToCharVec</a>()</code>,
<code><a href="#topic+prueferToEdgeList">prueferToEdgeList</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># first generate a random permutation, e.g., representing
# a roundtrip tour in a graph
nodelist = sample(1:8)
# now convert into an edge list
nodelistToEdgelist(nodelist)
</code></pre>

<hr>
<h2 id='permutationToCharVec'>Convert permutation to characteristic vector.</h2><span id='topic+permutationToCharVec'></span>

<h3>Description</h3>

<p>Convert permutation to characteristic vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permutationToCharVec(perm, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permutationToCharVec_+3A_perm">perm</code></td>
<td>
<p>[<code>integer</code>]<br />
Permutation of nodes, e.g., solution of a TSP.</p>
</td></tr>
<tr><td><code id="permutationToCharVec_+3A_n">n</code></td>
<td>
<p>[<code>integer</code>]<br />
Number of nodes of the problem.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>integer</code>] Characteristic vector cv with cv[i] = 1 if the i-th edge is in the tree.
</p>


<h3>See Also</h3>

<p>Other transformation functions: 
<code><a href="#topic+charVecToEdgelist">charVecToEdgelist</a>()</code>,
<code><a href="#topic+edgeListToCharVec">edgeListToCharVec</a>()</code>,
<code><a href="#topic+nodelistToEdgelist">nodelistToEdgelist</a>()</code>,
<code><a href="#topic+permutationToEdgelist">permutationToEdgelist</a>()</code>,
<code><a href="#topic+prueferToCharVec">prueferToCharVec</a>()</code>,
<code><a href="#topic+prueferToEdgeList">prueferToEdgeList</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># first generate a random permutation, e.g., representing
# a roundtrip tour in a graph
perm = sample(1:10)
print(perm)
# now convert into an edge list
permutationToCharVec(perm, n = 10)
</code></pre>

<hr>
<h2 id='permutationToEdgelist'>Convert permutation to edge list.</h2><span id='topic+permutationToEdgelist'></span>

<h3>Description</h3>

<p>Convert permutation to edge list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permutationToEdgelist(perm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permutationToEdgelist_+3A_perm">perm</code></td>
<td>
<p>[<code>integer</code>]<br />
Permutation of nodes, e.g., solution of a TSP.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>matrix(2, length(perm))</code>] Edge list.
</p>


<h3>See Also</h3>

<p>Other transformation functions: 
<code><a href="#topic+charVecToEdgelist">charVecToEdgelist</a>()</code>,
<code><a href="#topic+edgeListToCharVec">edgeListToCharVec</a>()</code>,
<code><a href="#topic+nodelistToEdgelist">nodelistToEdgelist</a>()</code>,
<code><a href="#topic+permutationToCharVec">permutationToCharVec</a>()</code>,
<code><a href="#topic+prueferToCharVec">prueferToCharVec</a>()</code>,
<code><a href="#topic+prueferToEdgeList">prueferToEdgeList</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># first generate a random permutation, e.g., representing
# a roundtrip tour in a graph
perm = sample(1:10)
print(perm)
# now convert into an edge list
permutationToEdgelist(perm)
</code></pre>

<hr>
<h2 id='plotEdgeFrequency'>Visualization of edge frequency among solution set.</h2><span id='topic+plotEdgeFrequency'></span>

<h3>Description</h3>

<p>Given a list of graphs and a list of solutions (encoded as edge
lists) for each graph the function generates each one plot. This is a
2D-scatterplot of edge weights of the graph. Size and colour of each point
indicate the number of solutions the edge is part of.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotEdgeFrequency(graphs, approx.sets, facet.args = list(), names = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotEdgeFrequency_+3A_graphs">graphs</code></td>
<td>
<p>[<code>list(grapherator)</code>]<br />
List of <code><a href="grapherator.html#topic+grapherator">grapherator</a></code> graphs.</p>
</td></tr>
<tr><td><code id="plotEdgeFrequency_+3A_approx.sets">approx.sets</code></td>
<td>
<p>[<code>list(list(matrix))</code>]<br />
List of approximations sets.</p>
</td></tr>
<tr><td><code id="plotEdgeFrequency_+3A_facet.args">facet.args</code></td>
<td>
<p>[<code>list</code>]<br />
Further arguments passed down to <code><a href="ggplot2.html#topic+facet_wrap">facet_wrap</a></code>.
Only relevant if <code>length(graphs) &gt; 1</code>.</p>
</td></tr>
<tr><td><code id="plotEdgeFrequency_+3A_names">names</code></td>
<td>
<p>[<code>character</code>]<br />
Optional names of the graph instances. Used for facetting. Default is
&ldquo;Problem_i&rdquo; with i ranging from 1 to <code>length(graphs)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>]
</p>


<h3>See Also</h3>

<p>Other result visualization: 
<code><a href="#topic+plotEdges">plotEdges</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g = genRandomMCGP(50L)
res = mcMSTEmoaBG(mu = 10L, max.iter = 50, instance = g, scalarize = TRUE)
## Not run: 
plotEdgeFrequency(list(g), list(res$pareto.set))

## End(Not run)
</code></pre>

<hr>
<h2 id='plotEdges'>Visualize edges common to several solutions.</h2><span id='topic+plotEdges'></span>

<h3>Description</h3>

<p>Given a list of characteristic vectors (graphs) the function plots
an embedding of the nodes in the Euclidean plane and depicts an edge if and
only if it is contained in at least one of the graphs. The edge thickness
indicates the number of graphs the edge is part of.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotEdges(x, n = NULL, normalize = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotEdges_+3A_x">x</code></td>
<td>
<p>[<code>list</code>]<br />
List of characteristic vectors.</p>
</td></tr>
<tr><td><code id="plotEdges_+3A_n">n</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of nodes of the problem instance.
Default is <code>sqrt(length(cv))</code> where cv is the first component of
<code>x</code>.</p>
</td></tr>
<tr><td><code id="plotEdges_+3A_normalize">normalize</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Shall edge frequencies be plotted? Default is code TRUE.</p>
</td></tr>
<tr><td><code id="plotEdges_+3A_...">...</code></td>
<td>
<p>[any]<br />
Further arguments passed down to <code><a href="qgraph.html#topic+qgraph">qgraph</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing
</p>


<h3>See Also</h3>

<p>Other result visualization: 
<code><a href="#topic+plotEdgeFrequency">plotEdgeFrequency</a>()</code>
</p>

<hr>
<h2 id='prueferToCharVec'>Convert Pruefer code to characteristic vector.</h2><span id='topic+prueferToCharVec'></span>

<h3>Description</h3>

<p>Convert Pruefer code to characteristic vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prueferToCharVec(pcode)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prueferToCharVec_+3A_pcode">pcode</code></td>
<td>
<p>[<code>integer</code>]
Pruefer code encoding a minimum spanning tree.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>integer</code>] Characteristic vector cv with cv[i] = 1 if the i-th edge is in the tree.
</p>


<h3>See Also</h3>

<p>Other transformation functions: 
<code><a href="#topic+charVecToEdgelist">charVecToEdgelist</a>()</code>,
<code><a href="#topic+edgeListToCharVec">edgeListToCharVec</a>()</code>,
<code><a href="#topic+nodelistToEdgelist">nodelistToEdgelist</a>()</code>,
<code><a href="#topic+permutationToCharVec">permutationToCharVec</a>()</code>,
<code><a href="#topic+permutationToEdgelist">permutationToEdgelist</a>()</code>,
<code><a href="#topic+prueferToEdgeList">prueferToEdgeList</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># here we generate a random Pruefer-code representing
# a random spanning tree of a graph with n = 10 nodes
pcode = sample(1:10, 8, replace = TRUE)
print(pcode)
print(prueferToCharVec(pcode))
</code></pre>

<hr>
<h2 id='prueferToEdgeList'>Convert Pruefer code to edge list.</h2><span id='topic+prueferToEdgeList'></span>

<h3>Description</h3>

<p>Convert Pruefer code to edge list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prueferToEdgeList(pcode)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prueferToEdgeList_+3A_pcode">pcode</code></td>
<td>
<p>[<code>integer</code>]
Pruefer code encoding a minimum spanning tree.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>matrix(2, length(pcode) + 1)</code>] Edge list.
</p>


<h3>See Also</h3>

<p>Other transformation functions: 
<code><a href="#topic+charVecToEdgelist">charVecToEdgelist</a>()</code>,
<code><a href="#topic+edgeListToCharVec">edgeListToCharVec</a>()</code>,
<code><a href="#topic+nodelistToEdgelist">nodelistToEdgelist</a>()</code>,
<code><a href="#topic+permutationToCharVec">permutationToCharVec</a>()</code>,
<code><a href="#topic+permutationToEdgelist">permutationToEdgelist</a>()</code>,
<code><a href="#topic+prueferToCharVec">prueferToCharVec</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># here we generate a random Pruefer-code representing
# a random spanning tree of a graph with n = 10 nodes
pcode = sample(1:10, 8, replace = TRUE)
print(pcode)
edgelist = prueferToEdgeList(pcode)
print(edgelist)
</code></pre>

<hr>
<h2 id='sampleWeights'>Sample weights</h2><span id='topic+sampleWeights'></span>

<h3>Description</h3>

<p>Sample random weights <code class="reqn">\lambda_1, ... \lambda_n, \sum_{i=1}^{n} \lambda_i = 1</code>
for weighted-sum scalarization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleWeights(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampleWeights_+3A_n">n</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of weights to sample.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>numeric</code>] Weight vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sampleWeights(2)

weights = replicate(10, sampleWeights(3L))
colSums(weights)
</code></pre>

<hr>
<h2 id='scalarizeWeights'>Scalarize weight matrizes.</h2><span id='topic+scalarizeWeights'></span>

<h3>Description</h3>

<p>Given a list of weight matrizes <code>weight.mats</code> and a vector
of numeric weights, the function returns a single weight matrix. Each component
of the resulting matrix is the weighted sum of the corresponding components of
the weight matrizes passed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scalarizeWeights(weight.mats, lambdas)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scalarizeWeights_+3A_weight.mats">weight.mats</code></td>
<td>
<p>[<code>list</code>]<br />
List of weight matrizes.</p>
</td></tr>
<tr><td><code id="scalarizeWeights_+3A_lambdas">lambdas</code></td>
<td>
<p>[<code>numeric</code>]<br />
Vector of weights.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>matrix</code>]
</p>

<hr>
<h2 id='similarity_metrics'>Metrics for spanning tree comparisson.</h2><span id='topic+similarity_metrics'></span><span id='topic+getNumberOfCommonEdges'></span><span id='topic+getSizeOfLargestCommonSubtree'></span>

<h3>Description</h3>

<p>Functions which expect two (spanning) trees and return a measure
of similiarity between those. Function <code>getNumberOfCommonEdges</code> returns
the (normalized) number of shared edges and function <code>getSizeOfLargestCommonSubtree</code>
returns the (normalized) size of the largest connected subtree which is located in
both trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getNumberOfCommonEdges(x, y, n = NULL, normalize = TRUE)

getSizeOfLargestCommonSubtree(x, y, n = NULL, normalize = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="similarity_metrics_+3A_x">x</code></td>
<td>
<p>[<code>matrix(2, n)</code>]<br />
First spanning tree represented as a list of edges.</p>
</td></tr>
<tr><td><code id="similarity_metrics_+3A_y">y</code></td>
<td>
<p>[<code>matrix(2, n)</code>]<br />
Second spanning tree represented as a list of edges.</p>
</td></tr>
<tr><td><code id="similarity_metrics_+3A_n">n</code></td>
<td>
<p>[<code>integer(1)</code> | <code>NULL</code>]<br />
Number of nodes of the graph.
Defaults to <code>length(x)</code>.</p>
</td></tr>
<tr><td><code id="similarity_metrics_+3A_normalize">normalize</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Should measure be normalized to <code class="reqn">[0, 1]</code> by devision
through the number of edges?
Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>numeric(1)</code>] Measure
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Here we generate two random spanning trees of a complete
# graph with 10 nodes
set.seed(1)
st1 = prueferToEdgeList(sample(1:10, size = 8, replace = TRUE))
st2 = prueferToEdgeList(sample(1:10, size = 8, replace = TRUE))
# Now check the number of common edges
NCE = getNumberOfCommonEdges(st1, st2)
# And the size of the largest common subtree
SLS = getSizeOfLargestCommonSubtree(st1, st2)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
