<!DOCTYPE html><html><head><title>Help for package lazysf</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {lazysf}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#lazysf-package'><p>lazysf: Delayed Read for 'GDAL' Vector Data Sources</p></a></li>
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#dbConnect+2CSFSQLDriver-method'><p>dbConnect</p></a></li>
<li><a href='#lazysf'><p>Delayed (lazy) read for GDAL vector</p></a></li>
<li><a href='#SFSQL'><p>SFSQL</p></a></li>
<li><a href='#SFSQLConnection-class'><p>Class SFSQLConnection (and methods)</p></a></li>
<li><a href='#SFSQLDriver-class'><p>Class SFSQLDriver.</p></a></li>
<li><a href='#SFSQLResult-class'><p>Class SFSQLResult (and methods)</p></a></li>
<li><a href='#st_as_sf'><p>Force computation of a GDAL query</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Delayed Read for 'GDAL' Vector Data Sources</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Lazy read for drawings. A 'dplyr' back end for data sources supported by 
    'GDAL' vector drivers, that allows working with local or remote sources as if they 
    are in-memory data frames. Basic features works with any drawing format ('GDAL vector 
    data source') supported by the 'sf' package. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>sf (&ge; 0.7-0), methods, DBI, tibble, dbplyr, magrittr, dplyr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mdsumner/lazysf">https://github.com/mdsumner/lazysf</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mdsumner/lazysf/issues">https://github.com/mdsumner/lazysf/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Collate:</td>
<td>'SFSQLConnection.R' 'SFSQLDriver.R' 'SFSQLResult.R'
'connect.R' 'lazysf-package.R' 'lazysf.R' 'utils-pipe.R'
'zzz.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-11-09 23:59:35 UTC; mdsumner</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael Sumner <a href="https://orcid.org/0000-0002-2471-7511"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Sumner &lt;mdsumner@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-11-14 08:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='lazysf-package'>lazysf: Delayed Read for 'GDAL' Vector Data Sources</h2><span id='topic+lazysf-package'></span><span id='topic+_PACKAGE'></span>

<h3>Description</h3>

<p>Lazy read for drawings. A 'dplyr' back end for data sources supported by 
'GDAL' vector drivers, that allows working with local or remote sources as if they 
are in-memory data frames. Basic features works with any drawing format ('GDAL vector 
data source') supported by the 'sf' package.
</p>


<h3>Package Options</h3>

<p>There is a debug option <code>options(lazysf.query.debug = TRUE)</code> which if set will cause the generated SQL statement
to be printed before every call to <code>sf::st_read()</code>. In addition it will print the number of rows actual read.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Michael Sumner <a href="mailto:mdsumner@gmail.com">mdsumner@gmail.com</a> (<a href="https://orcid.org/0000-0002-2471-7511">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/mdsumner/lazysf">https://github.com/mdsumner/lazysf</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/mdsumner/lazysf/issues">https://github.com/mdsumner/lazysf/issues</a>
</p>
</li></ul>


<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='dbConnect+2CSFSQLDriver-method'>dbConnect</h2><span id='topic+dbConnect+2CSFSQLDriver-method'></span>

<h3>Description</h3>

<p>dbConnect for drawings that may be read by package sf
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SFSQLDriver'
dbConnect(drv, DSN = "", readonly = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbConnect+2B2CSFSQLDriver-method_+3A_drv">drv</code></td>
<td>
<p>SFSQLDriver created by <code>SFSQL()</code></p>
</td></tr>
<tr><td><code id="dbConnect+2B2CSFSQLDriver-method_+3A_dsn">DSN</code></td>
<td>
<p>data source name, may be a file, or folder path, database connection string, or URL</p>
</td></tr>
<tr><td><code id="dbConnect+2B2CSFSQLDriver-method_+3A_readonly">readonly</code></td>
<td>
<p>open in readonly mode (<code>TRUE</code> is the only option)</p>
</td></tr>
<tr><td><code id="dbConnect+2B2CSFSQLDriver-method_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The 'OGRSQL' available is documented with GDAL: https://gdal.org/user/ogr_sql_dialect.html
</p>


<h3>Examples</h3>

<pre><code class='language-R'>afile &lt;- system.file("gpkg/nc.gpkg", package = "sf", mustWork = TRUE)
db &lt;- dbConnect(SFSQL(), afile)
dbSendQuery(db, 'SELECT * FROM "nc.gpkg"')
</code></pre>

<hr>
<h2 id='lazysf'>Delayed (lazy) read for GDAL vector</h2><span id='topic+lazysf'></span><span id='topic+lazysf.character'></span><span id='topic+lazysf.SFSQLConnection'></span>

<h3>Description</h3>

<p>A lazy data frame for GDAL drawings ('vector data sources'). lazysf is DBI
compatible and designed to work with dplyr. It should work with any data source
(file, url, connection string) readable by the sf package function <code>sf_read</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lazysf(x, layer, ...)

## S3 method for class 'character'
lazysf(x, layer, ..., query = NA)

## S3 method for class 'SFSQLConnection'
lazysf(x, layer, ..., query = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lazysf_+3A_x">x</code></td>
<td>
<p>the data source name (file path, url, or database connection string
</p>

<ul>
<li><p> analogous to <code><a href="sf.html#topic+st_read">sf::read_sf()</a></code> 'dsn')
</p>
</li></ul>
</td></tr>
<tr><td><code id="lazysf_+3A_layer">layer</code></td>
<td>
<p>layer name (varies by driver, may be a file name without
extension); in case <code>layer</code> is missing, <code>st_read</code> will read the
first layer of <code>dsn</code>, give a warning and (unless <code>quiet = TRUE</code>)
print a message when there are multiple layers, or give an error if there
are no layers in <code>dsn</code>. If <code>dsn</code> is a database connection, then
<code>layer</code> can be a table name or a database identifier (see
<code><a href="DBI.html#topic+Id">Id</a></code>). It is also possible to omit <code>layer</code> and rather
use the <code>query</code> argument.</p>
</td></tr>
<tr><td><code id="lazysf_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="lazysf_+3A_query">query</code></td>
<td>
<p>SQL query to pass in directly</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Lazy means that the usual behaviour of reading the entirety of a data source
into memory is avoided. Printing the output results in a preview query being
run and displayed (the top few rows of data).
</p>
<p>The output of <code>lazysf()</code> is a 'tbl_SFSQLConnection<code style="white-space: pre;">&#8288;that extends&#8288;</code>tbl_dbi' and
may be used with functions and workflows in the normal DBI way, see <code><a href="#topic+SFSQL">SFSQL()</a></code> for
the lazysf DBI support.
</p>
<p>The kind of q uery that may be run will depend on the type of format, see the
list on the GDAL vector drivers page. For some details see the
<a href="https://mdsumner.github.io/lazysf/articles/GDAL-SQL.html">GDALSQL vignette</a>.
</p>
<p>When dplyr is attached the lazy data frame can be used with the usual verbs
verbs (filter, select, distinct, mutate, transmute, arrange, left_join, pull,
collect etc.). To see the result as a SQL query rather than a data frame
preview use <code>dplyr::show_query()</code>.
</p>
<p>To obtain an in memory data frame use an explict <code>collect()</code> or <code>st_as_sf()</code>.
A call to <code>collect()</code> is triggered by <code>st_as_sf()</code> and will add the sf class
to the output. A result may not contain a geometry column, and so cannot be
convert to an sf data frame. Using <code>collect()</code> on its own returns an
unclassed data.frame and may include a classed <code>sfc</code> geometry column.
</p>
<p>As well as <code>collect()</code> it's also possible to use <code>tibble::as_tibble()</code> or
<code>as.data.frame()</code> or <code>pull()</code> which all force computation and retrieve the
result.
</p>


<h3>Value</h3>

<p>a 'tbl_SFSQLConnection', extending 'tbl_lazy' (something that works
with dplyr verbs, and only shows a preview until you commit the result via
<code><a href="#topic+collect">collect()</a></code>) see Details
</p>


<h3>Examples</h3>

<pre><code class='language-R'># online sources can work
geojson &lt;- file.path("https://raw.githubusercontent.com/SymbolixAU",
                     "geojsonsf/master/inst/examples/geo_melbourne.geojson")

lazysf(geojson)


## normal file stuff
## (Geopackage is an actual database so with SELECT we must be explicit re geom-column)
f &lt;- system.file("gpkg/nc.gpkg", package = "sf", mustWork = TRUE)
lazysf(f)
lazysf(f, query = "SELECT AREA, FIPS, geom FROM \"nc.gpkg\" WHERE AREA &lt; 0.1")
lazysf(f, layer = "nc.gpkg") %&gt;% dplyr::select(AREA, FIPS, geom) %&gt;% dplyr::filter(AREA &lt; 0.1)

## the famous ESRI Shapefile (not an actual database)
## so if we SELECT we must be ex
shp &lt;- lazysf(system.file("shape/nc.shp", package = "sf", mustWork = TRUE))
library(dplyr)
shp %&gt;%
 filter(NAME %LIKE% 'A%') %&gt;%
 mutate(abc = 1.3) %&gt;%
 select(abc, NAME, `_ogr_geometry_`) %&gt;%
 arrange(desc(NAME))  #%&gt;% show_query()

 ## a multi-layer file
 system.file("extdata/multi.gpkg", package = "lazysf", mustWork = TRUE)
</code></pre>

<hr>
<h2 id='SFSQL'>SFSQL</h2><span id='topic+SFSQL'></span>

<h3>Description</h3>

<p>SFSQL driver, use to <code><a href="DBI.html#topic+dbConnect">dbConnect()</a></code> to a data source readable by sf
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SFSQL()
</code></pre>


<h3>See Also</h3>

<p>lazysf dbConnect
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SFSQL()
</code></pre>

<hr>
<h2 id='SFSQLConnection-class'>Class SFSQLConnection (and methods)</h2><span id='topic+SFSQLConnection-class'></span><span id='topic+show+2CSFSQLConnection-method'></span><span id='topic+dbSendQuery+2CSFSQLConnection-method'></span><span id='topic+dbReadTable+2CSFSQLConnection+2Ccharacter-method'></span><span id='topic+dbListTables+2CSFSQLConnection-method'></span><span id='topic+dbExistsTable+2CSFSQLConnection+2CANY-method'></span><span id='topic+dbDisconnect+2CSFSQLConnection-method'></span>

<h3>Description</h3>

<p>SFSQLConnection objects are created by passing <code><a href="#topic+SFSQL">SFSQL()</a></code> as first
argument to <code><a href="DBI.html#topic+dbConnect">DBI::dbConnect()</a></code>.
They are a superclass of the <a href="DBI.html#topic+DBIConnection-class">DBIConnection</a> class.
The &quot;Usage&quot; section lists the class methods overridden by <span class="pkg">lazysf</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SFSQLConnection'
show(object)

## S4 method for signature 'SFSQLConnection'
dbSendQuery(conn, statement, ...)

## S4 method for signature 'SFSQLConnection,character'
dbReadTable(conn, name, ...)

## S4 method for signature 'SFSQLConnection'
dbListTables(conn, ...)

## S4 method for signature 'SFSQLConnection,ANY'
dbExistsTable(conn, name, ...)

## S4 method for signature 'SFSQLConnection'
dbDisconnect(conn, ...)
</code></pre>


<h3>See Also</h3>

<p>The corresponding generic functions
<code><a href="DBI.html#topic+dbSendQuery">DBI::dbSendQuery()</a></code>, <code><a href="DBI.html#topic+dbDisconnect">DBI::dbDisconnect()</a></code>,
<code><a href="DBI.html#topic+dbReadTable">DBI::dbReadTable()</a></code>,
<code><a href="DBI.html#topic+dbExistsTable">DBI::dbExistsTable()</a></code>, <code><a href="DBI.html#topic+dbListTables">DBI::dbListTables()</a></code>.
</p>

<hr>
<h2 id='SFSQLDriver-class'>Class SFSQLDriver.</h2><span id='topic+SFSQLDriver-class'></span><span id='topic+dbDataType+2CSFSQLDriver+2CANY-method'></span><span id='topic+dbIsValid+2CSFSQLDriver-method'></span><span id='topic+dbUnloadDriver+2CSFSQLDriver-method'></span><span id='topic+dbGetInfo+2CSFSQLDriver-method'></span>

<h3>Description</h3>

<p>SFSQLDriver objects are created by <code><a href="#topic+SFSQL">SFSQL()</a></code> and used to select the correct
method in <code><a href="DBI.html#topic+dbConnect">dbConnect()</a></code>.
They are a superclass of the <a href="DBI.html#topic+DBIDriver-class">DBIDriver</a> class, and used purely for dispatch.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SFSQLDriver,ANY'
dbDataType(dbObj, obj, ...)

## S4 method for signature 'SFSQLDriver'
dbIsValid(dbObj, ...)

## S4 method for signature 'SFSQLDriver'
dbUnloadDriver(drv, ...)

## S4 method for signature 'SFSQLDriver'
dbGetInfo(dbObj, ...)
</code></pre>


<h3>Details</h3>

<p>The &quot;Usage&quot; section lists the class methods overridden by <span class="pkg">lazysf</span>.
The <code><a href="DBI.html#topic+dbUnloadDriver">dbUnloadDriver()</a></code> method is a null-op.
</p>

<hr>
<h2 id='SFSQLResult-class'>Class SFSQLResult (and methods)</h2><span id='topic+SFSQLResult-class'></span><span id='topic+show+2CSFSQLResult-method'></span><span id='topic+dbFetch+2CSFSQLResult-method'></span><span id='topic+dbClearResult+2CSFSQLResult-method'></span><span id='topic+dbHasCompleted+2CSFSQLResult-method'></span>

<h3>Description</h3>

<p>SFSQLResult objects are created by <code><a href="DBI.html#topic+dbSendQuery">dbSendQuery()</a></code> or <code><a href="DBI.html#topic+dbSendStatement">dbSendStatement()</a></code>,
and encapsulate the result of an SQL statement.
They are a superclass of the <a href="DBI.html#topic+DBIResult-class">DBIResult</a> class.
The &quot;Usage&quot; section lists the class methods overridden by <span class="pkg">lazsf</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SFSQLResult'
show(object)

## S4 method for signature 'SFSQLResult'
dbFetch(res, n = -1, ...)

## S4 method for signature 'SFSQLResult'
dbClearResult(res, ...)

## S4 method for signature 'SFSQLResult'
dbHasCompleted(res, ...)
</code></pre>


<h3>See Also</h3>

<p>The corresponding generic functions
<code><a href="DBI.html#topic+dbFetch">DBI::dbFetch()</a></code>, <code><a href="DBI.html#topic+dbClearResult">DBI::dbClearResult()</a></code>, and
<code><a href="DBI.html#topic+dbHasCompleted">DBI::dbHasCompleted()</a></code>.
</p>

<hr>
<h2 id='st_as_sf'>Force computation of a GDAL query</h2><span id='topic+st_as_sf'></span><span id='topic+st_as_sf.tbl_SFSQLConnection'></span><span id='topic+collect'></span>

<h3>Description</h3>

<p>Convert lazysf to an in memory data frame or sf object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tbl_SFSQLConnection'
st_as_sf(x, ...)

collect(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_as_sf_+3A_x">x</code></td>
<td>
<p>output of <code><a href="#topic+lazysf">lazysf()</a></code></p>
</td></tr>
<tr><td><code id="st_as_sf_+3A_...">...</code></td>
<td>
<p>passed to <code><a href="#topic+collect">collect()</a></code></p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>function</code> of length 1.
</p>


<h3>Details</h3>

<p><code>collect()</code> retrieves data into a local table, preserving grouping and ordering.
</p>
<p><code>st_as_sf()</code> retrieves data into a local sf data frame (will succeed only if there is a geometry column of class <code>sfc</code>)
</p>


<h3>Value</h3>

<p>a data frame from <code>collect()</code>, sf data frame from <code>st_as_sf()</code> (only if it contains an <code>sfc</code> geometry column)
</p>


<h3>See Also</h3>

<p>lazysf
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("gpkg/nc.gpkg", package = "sf", mustWork = TRUE)
lsf &lt;- lazysf(f) %&gt;% dplyr::select(AREA, FIPS, geom) %&gt;% dplyr::filter(AREA &lt; 0.1)
st_as_sf(lsf)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
