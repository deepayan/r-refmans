<!DOCTYPE html><html><head><title>Help for package tsDyn</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tsDyn}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#tsDyn-package'><p>Getting started with the tsDyn package</p></a></li>
<li><a href='#aar'><p>Additive nonlinear autoregressive model</p></a></li>
<li><a href='#accuracy_stat'><p>Forecasting accuracy measures.</p></a></li>
<li><a href='#addRegime'><p>addRegime test</p></a></li>
<li><a href='#ar_mean'><p>Long-term mean of an AR(p) process</p></a></li>
<li><a href='#autopairs'><p>Bivariate time series plots</p></a></li>
<li><a href='#autotriples'><p>Trivariate time series plots</p></a></li>
<li><a href='#autotriples.rgl'><p>Interactive trivariate time series plots</p></a></li>
<li><a href='#availableModels'><p>Available models</p></a></li>
<li><a href='#barry'><p>Time series of PPI used as example in <cite>Bierens and Martins (2010)</cite></p></a></li>
<li><a href='#BBCTest'><p>Test of unit root against SETAR alternative</p></a></li>
<li><a href='#charac_root'><p>Characteristic roots of the AR coefficients</p></a></li>
<li><a href='#coefB'><p>Extract cointegration parameters A, B and PI</p></a></li>
<li><a href='#computeGradient'><p>computeGradient</p></a></li>
<li><a href='#delta'><p>delta test of conditional independence</p></a></li>
<li><a href='#delta.lin'><p>delta test of linearity</p></a></li>
<li><a href='#fevd.nlVar'><p>Forecast Error Variance Decomposition</p></a></li>
<li><a href='#fitted.nlVar'><p>fitted method for objects of class nlVar, i.e. VAR and VECM models.</p></a></li>
<li><a href='#getTh'><p>Extract threshold(s) coefficient</p></a></li>
<li><a href='#GIRF'><p>Generalized Impulse response Function (GIRF)</p></a></li>
<li><a href='#IIPUs'><p>US monthly industrial production from Hansen (1999)</p></a></li>
<li><a href='#irf.linear'><p>Impulse response function</p></a></li>
<li><a href='#isLinear'><p>isLinear</p></a></li>
<li><a href='#KapShinTest'><p>Test of unit root against SETAR alternative with</p></a></li>
<li><a href='#lags.select'><p>Selection of the lag with Information criterion.</p></a></li>
<li><a href='#LINEAR'><p>Linear AutoRegressive models</p></a></li>
<li><a href='#lineVar'><p>Multivariate linear models: VAR and VECM</p></a></li>
<li><a href='#llar'><p>Locally linear model</p></a></li>
<li><a href='#logLik.nlVar'><p>Extract Log-Likelihood</p></a></li>
<li><a href='#LSTAR'><p>Logistic Smooth Transition AutoRegressive model</p></a></li>
<li><a href='#m.unrate'><p>Monthly US unemployment</p></a></li>
<li><a href='#MakeThSpec'><p>Specification of the threshold search</p></a></li>
<li><a href='#MAPE'><p>Mean Absolute Percent Error</p></a></li>
<li><a href='#mse'><p>Mean Square Error</p></a></li>
<li><a href='#nlar'><p>Non-linear time series model, base class definition</p></a></li>
<li><a href='#nlar-methods'><p>NLAR methods</p></a></li>
<li><a href='#nlar.struct'><p>NLAR common structure</p></a></li>
<li><a href='#NNET'><p>Neural Network nonlinear autoregressive model</p></a></li>
<li><a href='#oneStep'><p>oneStep</p></a></li>
<li><a href='#plot methods'><p>Plotting methods for SETAR and LSTAR subclasses</p></a></li>
<li><a href='#plot_ECT'><p>Plot the Error Correct Term (ECT) response</p></a></li>
<li><a href='#predict_rolling'><p>Rolling forecasts</p></a></li>
<li><a href='#predict.nlar'><p>Predict method for objects of class &lsquo;<code>nlar</code>&rsquo;.</p></a></li>
<li><a href='#predict.TVAR'><p>Predict method for objects of class &lsquo;<code>VAR</code>&rsquo;, &lsquo;<code>VECM</code>&rsquo; or &lsquo;<code>TVAR</code>&rsquo;</p></a></li>
<li><a href='#rank.select'><p>Selection of the cointegrating rank with Information criterion.</p></a></li>
<li><a href='#rank.test'><p>Test of the cointegrating rank</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#regime'><p>Extract a variable showing the regime</p></a></li>
<li><a href='#resample_vec'><p>Resampling schemes</p></a></li>
<li><a href='#resVar'><p>Residual variance</p></a></li>
<li><a href='#selectHyperParms'><p>Automatic selection of model hyper-parameters</p></a></li>
<li><a href='#selectSETAR'><p>Automatic selection of SETAR hyper-parameters</p></a></li>
<li><a href='#SETAR'><p>Self Threshold Autoregressive model</p></a></li>
<li><a href='#setar.sim'><p>Simulation and bootstrap of Threshold Autoregressive model (SETAR)</p></a></li>
<li><a href='#setarTest'><p>Test of linearity against threshold (SETAR)</p></a></li>
<li><a href='#setarTest_IIPUs_results'><p>Results from the setarTest, applied on Hansen (1999) data</p></a></li>
<li><a href='#sigmoid'><p>sigmoid functions</p></a></li>
<li><a href='#STAR'><p>STAR model</p></a></li>
<li><a href='#toLatex.setar'><p>Latex representation of fitted setar models</p></a></li>
<li><a href='#TVAR'><p>Multivariate Threshold Vector Autoregressive model</p></a></li>
<li><a href='#TVAR.LRtest'><p>Test of linearity</p></a></li>
<li><a href='#TVAR.sim'><p>Simulation of a multivariate Threshold Autoregressive model (TVAR)</p></a></li>
<li><a href='#TVECM'><p>Threshold Vector Error Correction model (VECM)</p></a></li>
<li><a href='#TVECM.HStest '><p>Test of linear cointegration vs threshold cointegration</p></a></li>
<li><a href='#TVECM.SeoTest'><p>No cointegration vs threshold cointegration test</p></a></li>
<li><a href='#TVECM.sim'><p>Simulation and bootstrap a VECM or bivariate TVECM</p></a></li>
<li><a href='#UsUnemp'><p>US unemployment series used in <cite>Caner and Hansen (2001)</cite></p></a></li>
<li><a href='#VAR.sim'><p>Simulate or bootstrap a VAR model</p></a></li>
<li><a href='#VARrep'><p>VAR representation</p></a></li>
<li><a href='#VECM'><p>Estimation of Vector error correction model (VECM)</p></a></li>
<li><a href='#VECM_symbolic'><p>Virtual VECM model</p></a></li>
<li><a href='#zeroyld'><p>zeroyld time series</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Nonlinear Time Series Models with Regime Switching</td>
</tr>
<tr>
<td>Version:</td>
<td>11.0.4.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-01-26</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>mnormt, mgcv, nnet, tseriesChaos, tseries, utils, vars, urca,
forecast, MASS, Matrix, foreach, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>sm, scatterplot3d, rgl, tidyverse, rugarch</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matthieu Stigler &lt;Matthieu.Stigler@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements nonlinear autoregressive (AR) time series models. For univariate series, a non-parametric approach is available through additive nonlinear AR. Parametric modeling and testing for regime switching dynamics is available when the transition is either direct (TAR: threshold AR) or smooth (STAR: smooth transition AR, LSTAR). For multivariate series, one can estimate a range of TVAR or threshold cointegration TVECM models with two or three regimes. Tests can be conducted for TVAR as well as for TVECM (Hansen and Seo 2002 and Seo 2006). </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/MatthieuStigler/tsDyn/wiki">https://github.com/MatthieuStigler/tsDyn/wiki</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/MatthieuStigler/tsDyn/issues">https://github.com/MatthieuStigler/tsDyn/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-01 07:37:26 UTC; hornik</td>
</tr>
<tr>
<td>Author:</td>
<td>Antonio Fabio Di Narzo
    <a href="https://orcid.org/0000-0002-4033-5038"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Jose Luis Aznarte <a href="https://orcid.org/0000-0002-1636-244X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Matthieu Stigler <a href="https://orcid.org/0000-0002-6802-4290"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-01 09:50:58 UTC</td>
</tr>
</table>
<hr>
<h2 id='tsDyn-package'>Getting started with the tsDyn package</h2><span id='topic+tsDyn-package'></span><span id='topic+tsDyn'></span>

<h3>Description</h3>

<p>Getting started with the tsDyn package
</p>


<h3>Details</h3>

<p>This package provide some tools inspired by nonlinear dynamics for the analysis-modelling of 
observed time series.<br />
For loading the package, type:<br />
<code>library(tsDyn)</code><br />
A good place to start learning the package usage, is the vignette. It contains a more detailed guide on package contents, and an applied case study. At the R prompt, write:<br />
<code>vignette("tsDyn")</code><br />
For a full list of functions exported by the package, type:<br />
<code>ls("package:tsDyn")</code><br />
<br />
There is also an experimental GUI for built-in NLAR models. Call it with:<br />
<code>nlarDialog(timeSeries)</code><br />
where <code>timeSeries</code> is an available time series object.
</p>
<p>Each exported function has a corresponding man page (some man pages are in common to more functions). Display it by typing<br />
<code>help(functionName)</code>
</p>


<h3>Author(s)</h3>

<p> Antonio, Fabio Di Narzo </p>


<h3>See Also</h3>

<p><code><a href="#topic+availableModels">availableModels</a></code> for listing all currently available NLAR models
</p>
<p><code><a href="#topic+autopairs">autopairs</a></code>,<code><a href="#topic+autotriples">autotriples</a></code>,<code><a href="#topic+autotriples.rgl">autotriples.rgl</a></code> for graphical exploratory functions
</p>
<p><code><a href="#topic+llar">llar</a></code>, <code><a href="#topic+delta">delta</a></code>, <code><a href="#topic+delta.lin">delta.lin</a></code> for nonlinearity checking tools
</p>

<hr>
<h2 id='aar'>Additive nonlinear autoregressive model</h2><span id='topic+AAR'></span><span id='topic+aar'></span><span id='topic+summary.aar'></span><span id='topic+print.aar'></span><span id='topic+plot.aar'></span>

<h3>Description</h3>

<p>Additive nonlinear autoregressive model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aar(x, m, d=1, steps=d, series)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aar_+3A_x">x</code></td>
<td>
<p> time series </p>
</td></tr>
<tr><td><code id="aar_+3A_m">m</code>, <code id="aar_+3A_d">d</code>, <code id="aar_+3A_steps">steps</code></td>
<td>
<p> embedding dimension, time delay, forecasting steps </p>
</td></tr>
<tr><td><code id="aar_+3A_series">series</code></td>
<td>
<p> time series name (optional) </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Nonparametric additive autoregressive model of the form:
</p>
<p style="text-align: center;"><code class="reqn">
        x_{t+s} = \mu + \sum_{j=1}^{m} s_j(x_{t-(j-1)d})
  </code>
</p>

<p>where <code class="reqn">s_j</code> are nonparametric univariate functions of lagged time
series values. They are represented by cubic regression splines.
<code class="reqn">s_j</code> are estimated together with their level of
smoothing using routines in the <span class="pkg">mgcv</span> package (see references).
</p>


<h3>Value</h3>

<p>An object of class <code>nlar</code>, subclass <code>aar</code>, i.e. a list
with mostly internal structures for the fitted <code><a href="mgcv.html#topic+gam">gam</a></code> object.
</p>


<h3>Author(s)</h3>

<p> Antonio, Fabio Di Narzo </p>


<h3>References</h3>

<p>Wood, mgcv:GAMs and Generalized Ridge Regression for R. R News 1(2):20-25
(2001)
</p>
<p>Wood and Augustin, GAMs with integrated model selection using penalized regression splines and applications to environmental modelling. Ecological Modelling 157:157-177 (2002)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#fit an AAR model:
mod &lt;- aar(log(lynx), m=3)
#Summary informations:
summary(mod)
#Diagnostic plots:
plot(mod)
</code></pre>

<hr>
<h2 id='accuracy_stat'>Forecasting accuracy measures.</h2><span id='topic+accuracy_stat'></span><span id='topic+accuracy_stat.default'></span><span id='topic+accuracy_stat.pred_roll'></span>

<h3>Description</h3>

<p>Compute forecasting accuracies. This is very similar to the
<code><a href="forecast.html#topic+accuracy">accuracy</a></code> method form <span class="pkg">forecast</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>accuracy_stat(object, ...)

## Default S3 method:
accuracy_stat(object, true, ...)

## S3 method for class 'pred_roll'
accuracy_stat(object, w, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="accuracy_stat_+3A_object">object</code></td>
<td>
<p>A data-frame, matrix, or object of class <code>pred_roll</code></p>
</td></tr>
<tr><td><code id="accuracy_stat_+3A_...">...</code></td>
<td>
<p>Not used currently.</p>
</td></tr>
<tr><td><code id="accuracy_stat_+3A_true">true</code></td>
<td>
<p>If <code>object</code> is just a matrix or data-frame, true values to
be compared to should be supplied</p>
</td></tr>
<tr><td><code id="accuracy_stat_+3A_w">w</code></td>
<td>
<p>Optional. For objects of class <code>pred_roll</code> containing multiple
variables, user can specify the way to aggregate the specific x-step-ahead
into the &lsquo;all&rsquo; category</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function works either for a simple data.frame or for objects
<code>pred_roll</code>. For simple data.frames, the argument <code>true</code>, i.e. a
data frame containing the true values, has to be provided. For
<code>pred_roll</code> objects, the true values are contained in the object, so no
need (nor possibility) to provide the true values.
</p>


<h3>Value</h3>

<p>A data-frame containing the forecasting accuracy measures.
</p>


<h3>Author(s)</h3>

<p>Matthieu Stigler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## univariate:
mod_ar &lt;- linear(lynx[1:100], m=1)
mod_ar_pred &lt;- predict_rolling(mod_ar, newdata=lynx[101:114])
accuracy_stat(object=mod_ar_pred$pred, true=mod_ar_pred$true)

## multivariate
data(barry)
mod_var &lt;- lineVar(barry, lag=1)

mod_var_pred &lt;-predict_rolling(object=mod_var, nroll=10, n.ahead=1:3)
accuracy_stat(object=mod_var_pred)
accuracy_stat(object=mod_var_pred, w=c(0.7, 0.2, 0.1))



</code></pre>

<hr>
<h2 id='addRegime'>addRegime test</h2><span id='topic+addRegime'></span>

<h3>Description</h3>

<p>addRegime test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addRegime(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addRegime_+3A_object">object</code></td>
<td>
<p>fitted model object with at least 2 regimes</p>
</td></tr>
<tr><td><code id="addRegime_+3A_...">...</code></td>
<td>
<p>arguments to and from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the p-value of the F statistic and a boolean, true
if there is some remaining nonlinearity and false otherwise.
</p>


<h3>Author(s)</h3>

<p>J. L. Aznarte
</p>


<h3>References</h3>

<p>TODO
</p>


<h3>See Also</h3>

<p><code><a href="#topic+star">star</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##TODO

</code></pre>

<hr>
<h2 id='ar_mean'>Long-term mean of an AR(p) process</h2><span id='topic+ar_mean'></span><span id='topic+ar_mean.linear'></span><span id='topic+ar_mean.setar'></span><span id='topic+ar_mean.lstar'></span>

<h3>Description</h3>

<p>Computes the long term mean of an AR process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ar_mean(object, ...)

## S3 method for class 'linear'
ar_mean(object, ...)

## S3 method for class 'setar'
ar_mean(object, ...)

## S3 method for class 'lstar'
ar_mean(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ar_mean_+3A_object">object</code></td>
<td>
<p>an object of class <code><a href="#topic+linear">linear</a></code>, <code><a href="#topic+setar">setar</a></code> or <code><a href="#topic+lstar">lstar</a></code></p>
</td></tr>
<tr><td><code id="ar_mean_+3A_...">...</code></td>
<td>
<p>unused argument</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes the long-term mean of an AR(p) process, or of the corresponding sub-regimes in 
SETAR or LSTAR model. 
There are three possible cases:
</p>

<dl>
<dt>No constant nor trend</dt><dd><p>The LT mean is 0</p>
</dd>
<dt>constant</dt><dd><p>The LT mean is given by const/(1-sum(AR coefs))</p>
</dd>
<dt>Trend</dt><dd><p>The LT mean is not defined</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## estimate a (linear) AR, a SETAR and a LSTAR
lin_cst_l1 &lt;-  linear(lh, m = 1, include = "const")
set_cst_l1 &lt;-  setar(lh, m = 1, include = "const") 
lst_cst_l1 &lt;-  lstar(lh, m = 1, include = "const", trace = FALSE)

ar_mean(lin_cst_l1)
ar_mean(set_cst_l1)
ar_mean(lst_cst_l1)
</code></pre>

<hr>
<h2 id='autopairs'>Bivariate time series plots</h2><span id='topic+autopairs'></span>

<h3>Description</h3>

<p>Bivariate time series plots: scatterplots, directed lines and kernel density
estimations using functions in the <span class="pkg">sm</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autopairs(
  x,
  lag = 1,
  h,
  type = c("levels", "persp", "image", "lines", "points", "regression")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autopairs_+3A_x">x</code></td>
<td>
<p>time series</p>
</td></tr>
<tr><td><code id="autopairs_+3A_lag">lag</code></td>
<td>
<p>time lag</p>
</td></tr>
<tr><td><code id="autopairs_+3A_h">h</code></td>
<td>
<p>kernel window (useful only for kernel estimations)</p>
</td></tr>
<tr><td><code id="autopairs_+3A_type">type</code></td>
<td>
<p>type of plot: contour levels, perspective plots, image, directed
lines, points or points with superposed kernel regression</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Bivariate time series plots: scatterplots, directed lines and kernel density
and regression functions estimations using functions in the package <span class="pkg">sm</span>.
In particular, for kernel density estimation <code><a href="sm.html#topic+sm.density">sm.density</a></code> is
used, with smoothing parameter <code>h</code> defaulting to
<code><a href="sm.html#topic+hnorm">hnorm</a></code>. For kernel regression,
<code><a href="sm.html#topic+sm.regression">sm.regression</a></code> is used.
</p>


<h3>Value</h3>

<p>None. Plots are produced on the default graphical device.
</p>


<h3>Author(s)</h3>

<p>Wrappers to <span class="pkg">sm</span> by Antonio, Fabio Di Narzo
</p>


<h3>See Also</h3>

<p>For finer control on density estimation, consider using directly
<code><a href="sm.html#topic+sm.density">sm.density</a></code> and, especially, <code><a href="sm.html#topic+sm.ts.pdf">sm.ts.pdf</a></code>
from package <span class="pkg">sm</span>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- log10(lynx)
autopairs(x, lag=2, type="lines")

</code></pre>

<hr>
<h2 id='autotriples'>Trivariate time series plots</h2><span id='topic+autotriples'></span>

<h3>Description</h3>

<p>Trivariate time series plots: kernel autoregression using functions in the
<span class="pkg">sm</span> package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autotriples(
  x,
  lags = 1:2,
  h,
  type = c("levels", "persp", "image", "lines", "points")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autotriples_+3A_x">x</code></td>
<td>
<p>time series</p>
</td></tr>
<tr><td><code id="autotriples_+3A_lags">lags</code></td>
<td>
<p>vector of regressors lags</p>
</td></tr>
<tr><td><code id="autotriples_+3A_h">h</code></td>
<td>
<p>kernel window</p>
</td></tr>
<tr><td><code id="autotriples_+3A_type">type</code></td>
<td>
<p>type of plot: contour levels, perspective plots, image</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function displays trivariate time series plots, i.e. kernel regression
of <code class="reqn">x[t-lags[1]], x[t-lags[2]]</code> against
<code class="reqn">x[t]</code> using functions in the package <span class="pkg">sm</span>.  In particular,
<code><a href="sm.html#topic+sm.regression">sm.regression</a></code> is used, with smoothing parameter defaulting
to <code><a href="sm.html#topic+hnorm">hnorm</a>(x)</code>.
</p>


<h3>Value</h3>

<p>None. Plots are produced on the default graphical device.
</p>


<h3>Author(s)</h3>

<p>Wrappers to <span class="pkg">sm</span> by Antonio, Fabio Di Narzo
</p>


<h3>See Also</h3>

<p>For finer control on kernel regression, consider using directly
<code><a href="sm.html#topic+sm.regression">sm.regression</a></code> and, especially,
<code><a href="sm.html#topic+sm.autoregression">sm.autoregression</a></code> in package <code><a href="sm.html#topic+sm">sm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
autotriples(log(lynx))
autotriples(log(lynx), type="persp")
autotriples(log(lynx), type="image")

</code></pre>

<hr>
<h2 id='autotriples.rgl'>Interactive trivariate time series plots</h2><span id='topic+autotriples.rgl'></span>

<h3>Description</h3>

<p>Interactive trivariate time series plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autotriples.rgl(x, lags = 1:2, type = c("lines", "points"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autotriples.rgl_+3A_x">x</code></td>
<td>
<p>time series</p>
</td></tr>
<tr><td><code id="autotriples.rgl_+3A_lags">lags</code></td>
<td>
<p>vector of regressors lags</p>
</td></tr>
<tr><td><code id="autotriples.rgl_+3A_type">type</code></td>
<td>
<p>type of plot: contour levels, perspective plots, image</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function displays interactive trivariate time series plots
<code>x[t-lags[1]], x[t-lags[2]]</code> against <code>x[t]</code> using the interactive
<code><a href="rgl.html#topic+rgl">rgl</a></code> device.
</p>


<h3>Value</h3>

<p>None. A plot is produced on the current <code>rgl</code> device.
</p>


<h3>Author(s)</h3>

<p>Wrapper to 'sm' and GUI by Antonio, Fabio Di Narzo
</p>


<h3>See Also</h3>

<p><code><a href="#topic+autotriples">autotriples</a></code> for 3d visualization via
<span class="pkg">scatterplot3d</span> package and for kernel post-processing of the cloud for
nonparametric autoregression functions estimates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(interactive())
autotriples.rgl(log(lynx))

</code></pre>

<hr>
<h2 id='availableModels'>Available models</h2><span id='topic+availableModels'></span>

<h3>Description</h3>

<p>Available built-in time series models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>availableModels()
</code></pre>


<h3>Details</h3>

<p>Return the list of built-in available &lsquo;nlar&rsquo; time series models
</p>


<h3>Value</h3>

<p>A character vector containing built-in time series models. For help
on a specific model, type: <code>help(modelName)</code>.
</p>


<h3>Author(s)</h3>

<p>Antonio, Fabio Di Narzo
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
availableModels()

</code></pre>

<hr>
<h2 id='barry'>Time series of PPI used as example in <cite>Bierens and Martins (2010)</cite></h2><span id='topic+barry'></span>

<h3>Description</h3>

<p>This data set contains the series used by <cite>Bierens and Martins</cite>
for testing for PPI between Canada and US.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(barry)</code></pre>


<h3>Format</h3>

<p>A data frame with 324 monthly observations,
ranging from 1973:M1 until 1999:M12.
</p>

<table>
<tr>
 <td style="text-align: right;">
    <code>dolcan</code> </td><td style="text-align: left;"> Exchange rate US/Can dollar. </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>cpiUSA</code> </td><td style="text-align: left;"> US Consumer Price Index. </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>cpiCAN</code> </td><td style="text-align: left;"> Canada Consumer Price Index. </td>
</tr>
<tr>
 <td style="text-align: right;">
    </td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Matthieu Stigler</p>


<h3>Source</h3>

<p>Bierens, H. and Martins, L. (2010), Time Varying Cointegration,
</p>

<hr>
<h2 id='BBCTest'>Test of unit root against SETAR alternative</h2><span id='topic+BBCTest'></span>

<h3>Description</h3>

<p>Test of unit root against a stationnary three regime SETAR alternative
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BBCTest(
  x,
  m,
  series,
  testStat = c("LR", "Wald", "LM"),
  trim = 0.1,
  grid = c("minPerc", "minObs")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BBCTest_+3A_x">x</code></td>
<td>
<p>time series</p>
</td></tr>
<tr><td><code id="BBCTest_+3A_m">m</code></td>
<td>
<p>Number of lags under the alternative</p>
</td></tr>
<tr><td><code id="BBCTest_+3A_series">series</code></td>
<td>
<p>time series name (optional)</p>
</td></tr>
<tr><td><code id="BBCTest_+3A_teststat">testStat</code></td>
<td>
<p>Type of test statistic to use</p>
</td></tr>
<tr><td><code id="BBCTest_+3A_trim">trim</code></td>
<td>
<p>trimming parameter indicating the minimal percentage of
observations in each regime</p>
</td></tr>
<tr><td><code id="BBCTest_+3A_grid">grid</code></td>
<td>
<p>Whether a minimal number of percentage or observations should be
imposed. See details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>TODO
</p>


<h3>Value</h3>

<p>A object of class &quot;BBC2004Test&quot; containing:
</p>
<p>-The value of the sup Test
</p>
<p>-The version of test used (either Wald, LM or LR).
</p>


<h3>Author(s)</h3>

<p>Matthieu Stigler
</p>


<h3>References</h3>

<p>Bec, Ben Salem and Carrasco (2004) Tests for Unit-Root versus Threshold Specification With an Application to the Purchasing Power Parity Relationship, Journal of Business and Economic Statistics; 22:4
</p>


<h3>See Also</h3>

<p><code><a href="#topic+setarTest">setarTest</a></code> for a test with stationarity as a null.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
BBCTest(lynx, m=3, test="Wald", grid="minPerc")

</code></pre>

<hr>
<h2 id='charac_root'>Characteristic roots of the AR coefficients</h2><span id='topic+charac_root'></span><span id='topic+charac_root.nlar'></span>

<h3>Description</h3>

<p>Computes the (inverse) characteristic roots of the auto-regressive coefficients. 
To be stationary, the values should be outside the unit circle. The function here returns the
modulus of the roots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>charac_root(object, ...)

## S3 method for class 'nlar'
charac_root(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="charac_root_+3A_object">object</code></td>
<td>
<p>object of class <code><a href="#topic+nlar">nlar</a></code></p>
</td></tr>
<tr><td><code id="charac_root_+3A_...">...</code></td>
<td>
<p>currently unused</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the roots of the polynomial (1, -phi) using function <code><a href="base.html#topic+polyroot">polyroot</a></code>
</p>


<h3>Value</h3>

<p>a data.frame, with the modulus of the roots. 
For models with multiple regimes (setar, lstar, star), one column per regime.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mod.ar &lt;-  linear(lh, m = 5, include = "const")
mod.setar &lt;-  setar(lh, m = 5, include = "const")

charac_root(mod.ar)
charac_root(mod.setar)
</code></pre>

<hr>
<h2 id='coefB'>Extract cointegration parameters A, B and PI</h2><span id='topic+coefB'></span><span id='topic+coefB.VECM'></span><span id='topic+coefB.ca.jo'></span><span id='topic+coefA'></span><span id='topic+coefA.VECM'></span><span id='topic+coefA.ca.jo'></span><span id='topic+coefPI'></span>

<h3>Description</h3>

<p>Extract parameters in VECM: adjustment coefficients <code>A</code>, 
cointegrating coefficients <code>B</code> , or the composite matrix <code>PI</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coefB(object, ...)

## S3 method for class 'VECM'
coefB(object, ...)

## S3 method for class 'ca.jo'
coefB(object, r = 1, normalize = TRUE, ...)

coefA(object, ...)

## S3 method for class 'VECM'
coefA(object, ...)

## S3 method for class 'ca.jo'
coefA(object, r = 1, normalize = TRUE, ...)

coefPI(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coefB_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="#topic+VECM">VECM</a></code>, <code><a href="urca.html#topic+ca.jo">ca.jo</a></code></p>
</td></tr>
<tr><td><code id="coefB_+3A_r">r</code></td>
<td>
<p>The cointegrating rank</p>
</td></tr>
<tr><td><code id="coefB_+3A_normalize">normalize</code></td>
<td>
<p>Whether to normalize the A/B coefficients. See details</p>
</td></tr>
<tr><td><code id="coefB_+3A_...">...</code></td>
<td>
<p>Further arguments passed to methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions extract the parameters from a VECM with <code class="reqn">K</code> variables 
and rank <code class="reqn">r</code>:
</p>

<dl>
<dt>A</dt><dd><p>Adjustment coefficients, of dim <code class="reqn">K \times r</code></p>
</dd>
<dt>B</dt><dd><p>Cointegrating coefficients, of dim <code class="reqn">K \times r</code></p>
</dd>
<dt>Pi</dt><dd><p>Matrix <code class="reqn">\Pi=A B^{'}</code>, of dim <code class="reqn">K \times K</code></p>
</dd>
</dl>

<p>Coefficients are extracted from a VECM in package <code>tsDyn</code>, or from a VECM 
obtained in package <code>urca</code> from <code><a href="urca.html#topic+ca.jo">ca.jo</a></code> or <code><a href="urca.html#topic+cajorls">cajorls</a></code>. 
</p>
<p>Note that by default, the A and B coefficients returned are normalized (see below). This is 
the case for results obtained from <code><a href="#topic+VECM">VECM</a></code>/<code><a href="#topic+lineVar">lineVar</a></code> and 
<code><a href="urca.html#topic+cajorls">cajorls</a></code>, while for <code><a href="urca.html#topic+ca.jo">ca.jo</a></code>, the user has the choice
(but normalize=TRUE by default), in which case the rank <code>r</code> is also to be specified.
The normalization is the Phillips triangular representation,  as suggested by Johansen (1995, p. 72), 
standardising  the first <code class="reqn">r\times r</code> coefficients to <code class="reqn">I_r</code>:
</p>

<dl>
<dt>B</dt><dd><p><code class="reqn">B_{norm}=B (c^{'}B)^{-1}</code> with <code class="reqn">c=(I_r,0_{K-r,r})^{'}</code></p>
</dd>
<dt>A</dt><dd><p><code class="reqn">A_{norm}=AB^{'}c</code></p>
</dd>
</dl>

<p>Finally, note that the function also apply to objects obtained from tests of class 
<code>ca.jo.test</code> (from <code><a href="urca.html#topic+blrtest">blrtest</a></code> etc...). Care should be taken 
however, since the normalization might override the restrictions imposed.
</p>


<h3>Value</h3>

<p>A matrix containing the coefficients
</p>


<h3>Author(s)</h3>

<p>Matthieu Stigler
</p>


<h3>References</h3>

<p>Johansen, Soren, (1995), Likelihood-Based Inference in Cointegrated Vector Autoregressive Models, Oxford University Press
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(barry)
vecm &lt;- VECM(barry,  lag=1, estim="ML")
vecm_r2 &lt;- VECM(barry,  lag=1, estim="ML", r=2)

## extract coefficients:
coefA(vecm)
coefB(vecm)
coefPI(vecm)
coefB(vecm_r2)
coefPI(vecm_r2)

## Beta-Restricted VECM:
beta_vecm2 &lt;- coefB(vecm_r2) 
beta_vecm2[3,2] &lt;- 0.02
vecm_r2_rest &lt;- VECM(barry,  lag=1, estim="ML", r=2, beta=beta_vecm2)
round(coefB(vecm_r2_rest),5)

## Package vars/urca
if(require(urca)){
 vecm_ur &lt;- ca.jo(barry, K=2)
 coefB(vecm_ur)
 coefB(vecm_ur,r=2)
 coefB(cajorls(vecm_ur, r=2))
 all.equal(coefB(vecm), coefB(vecm_ur), check.attributes=FALSE)
 all.equal(coefB(vecm_r2), coefB(vecm_ur, r=2), check.attributes=FALSE)
}
</code></pre>

<hr>
<h2 id='computeGradient'>computeGradient</h2><span id='topic+computeGradient'></span>

<h3>Description</h3>

<p>Computes the gradient under the null hypothesis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeGradient(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeGradient_+3A_object">object</code></td>
<td>
<p>fitted star model</p>
</td></tr>
<tr><td><code id="computeGradient_+3A_...">...</code></td>
<td>
<p>currently unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>computed gradient
</p>


<h3>Author(s)</h3>

<p>J. L. Aznarte
</p>


<h3>References</h3>

<p>TODO
</p>


<h3>See Also</h3>

<p><code><a href="#topic+addRegime">addRegime</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##TODO

</code></pre>

<hr>
<h2 id='delta'>delta test of conditional independence</h2><span id='topic+delta'></span><span id='topic+delta.test'></span>

<h3>Description</h3>

<p>delta statistic of conditional independence and associated bootstrap test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delta(x, m, d = 1, eps)

delta.test(
  x,
  m = 2:3,
  d = 1,
  eps = seq(0.5 * sd(x), 2 * sd(x), length = 4),
  B = 49
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delta_+3A_x">x</code></td>
<td>
<p>time series</p>
</td></tr>
<tr><td><code id="delta_+3A_m">m</code></td>
<td>
<p>vector of embedding dimensions</p>
</td></tr>
<tr><td><code id="delta_+3A_d">d</code></td>
<td>
<p>time delay</p>
</td></tr>
<tr><td><code id="delta_+3A_eps">eps</code></td>
<td>
<p>vector of length scales</p>
</td></tr>
<tr><td><code id="delta_+3A_b">B</code></td>
<td>
<p>number of bootstrap replications</p>
</td></tr>
</table>


<h3>Details</h3>

<p>delta statistic of conditional independence and associated bootstrap test.
For details, see Manzan(2003).
</p>


<h3>Value</h3>

<p><code>delta</code> returns the computed delta statistic. <code>delta.test</code>
returns the bootstrap based 1-sided p-value.
</p>


<h3>Warning</h3>

<p>Results are sensible to the choice of the window
<code>eps</code>. So, try the test for a grid of <code>m</code> and <code>eps</code> values.
Also, be aware of the course of dimensionality: m can't be too high for
relatively small time series. See references for further details.
</p>


<h3>Author(s)</h3>

<p>Antonio, Fabio Di Narzo
</p>


<h3>References</h3>

<p>Sebastiano Manzan, Essays in Nonlinear Economic Dynamics, Thela
Thesis (2003)
</p>


<h3>See Also</h3>

<p>BDS marginal independence test: <code><a href="tseries.html#topic+bds.test">bds.test</a></code> in
package <span class="pkg">tseries</span>
</p>
<p>Teraesvirta's neural network test for nonlinearity:
<code><a href="tseries.html#topic+terasvirta.test">terasvirta.test</a></code> in package <span class="pkg">tseries</span>
</p>
<p>delta test for nonlinearity: <code><a href="#topic+delta.lin.test">delta.lin.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
delta(log10(lynx), m=3, eps=sd(log10(lynx)))

</code></pre>

<hr>
<h2 id='delta.lin'>delta test of linearity</h2><span id='topic+delta.lin'></span><span id='topic+delta.lin.test'></span>

<h3>Description</h3>

<p>delta test of linearity based on conditional mutual information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delta.lin(x, m, d = 1)

delta.lin.test(
  x,
  m = 2:3,
  d = 1,
  eps = seq(0.5 * sd(x), 2 * sd(x), length = 4),
  B = 49
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delta.lin_+3A_x">x</code></td>
<td>
<p>time series</p>
</td></tr>
<tr><td><code id="delta.lin_+3A_m">m</code></td>
<td>
<p>vector of embedding dimensions</p>
</td></tr>
<tr><td><code id="delta.lin_+3A_d">d</code></td>
<td>
<p>time delay</p>
</td></tr>
<tr><td><code id="delta.lin_+3A_eps">eps</code></td>
<td>
<p>vector of length scales</p>
</td></tr>
<tr><td><code id="delta.lin_+3A_b">B</code></td>
<td>
<p>number of bootstrap replications</p>
</td></tr>
</table>


<h3>Details</h3>

<p>delta test of linearity based on conditional mutual information
</p>


<h3>Value</h3>

<p><code>delta.lin</code> returns the parametrically estimated delta statistic
for the given time series (assuming linearity). <code>delta.lin.test</code> returns
the bootstrap based 1-sided p-value. The test statistic is the difference
between the parametric and nonparametric delta estimators.
</p>


<h3>Author(s)</h3>

<p>Antonio, Fabio Di Narzo
</p>


<h3>References</h3>

<p>Sebastiano Manzan, Essays in Nonlinear Economic Dynamics, Thela
Thesis (2003)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
delta.lin(log10(lynx), m=3)

</code></pre>

<hr>
<h2 id='fevd.nlVar'>Forecast Error Variance Decomposition</h2><span id='topic+fevd.nlVar'></span>

<h3>Description</h3>

<p>Use the <code>fevd</code> function from package <span class="pkg">vars</span> to compute the forecast
error variance decomposition of a VAR(p) or VECM for <code>n.ahead</code> steps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nlVar'
fevd(x, n.ahead = 10, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fevd.nlVar_+3A_x">x</code></td>
<td>
<p>Object of class &lsquo;<code>VAR</code>&rsquo; generated by
<code>lineVar()</code>, or an object of class &lsquo;<code>VECM</code>&rsquo; generated by
<code>VECM()</code></p>
</td></tr>
<tr><td><code id="fevd.nlVar_+3A_n.ahead">n.ahead</code></td>
<td>
<p>Integer specifying the number of steps.</p>
</td></tr>
<tr><td><code id="fevd.nlVar_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function converts the VAR or VECM computed by package tsDyn into an
object of class &lsquo;<code>vec2var</code>&rsquo;, on which then the
<code><a href="vars.html#topic+fevd">fevd</a></code> method is applied. For details, see package
<span class="pkg">vars</span>.
</p>


<h3>Value</h3>

<p>A list with class attribute &lsquo;<code>varfevd</code>&rsquo; of length
<code>K</code> holding the forecast error variances as matrices.
</p>


<h3>Author(s)</h3>

<p>Bernhard Pfaff
</p>


<h3>References</h3>

<p>Hamilton, J. (1994), <em>Time Series Analysis</em>, Princeton
University Press, Princeton.
</p>
<p>Lutkepohl, H. (2006), <em>New Introduction to Multiple Time Series
Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+plot">plot</a></code> for the plot method. <code><a href="#topic+lineVar">lineVar</a></code>,
<code><a href="#topic+VECM">VECM</a></code> for the models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(zeroyld)
mod_vecm &lt;- VECM(zeroyld, lag = 2)
fevd(mod_vecm, n.ahead = 5)

</code></pre>

<hr>
<h2 id='fitted.nlVar'>fitted method for objects of class nlVar, i.e. VAR and VECM models.</h2><span id='topic+fitted.nlVar'></span><span id='topic+fitted'></span>

<h3>Description</h3>

<p>Returns the fitted values of the model, either as computed in the model, or
back to the original series level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nlVar'
fitted(object, level = c("model", "original"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.nlVar_+3A_object">object</code></td>
<td>
<p>An object of class &lsquo;nlVar&rsquo;; generated by
<code><a href="#topic+VECM">VECM</a></code> or <code><a href="#topic+lineVar">lineVar</a></code>.</p>
</td></tr>
<tr><td><code id="fitted.nlVar_+3A_level">level</code></td>
<td>
<p>How to return the fitted values. See below.</p>
</td></tr>
<tr><td><code id="fitted.nlVar_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In case of a VAR in differences, in ADF specification, or a VECM, the fitted
values are actually in differences. With the option <code>level="original"</code>,
the function returns the series in the original level.
</p>
<p>For VAR in levels, the two arguments are evidently the same and hence it is
not taken into account, returning a warning.
</p>


<h3>Value</h3>

<p>A matrix.
</p>


<h3>Author(s)</h3>

<p>Matthieu Stigler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## estimate models
data(barry)

ve &lt;- VECM(barry, lag=2)
va &lt;- lineVar(barry, lag=1)
va_diff &lt;- lineVar(barry, lag=1, I="diff")
va_ADF &lt;- lineVar(barry, lag=1, I="ADF")


## get fitted values:
tail(fitted(ve))
tail(fitted(ve, level="original"))

tail(fitted(va))
tail(fitted(object=va, level="original"))

tail(fitted(va_diff))
tail(fitted(object=va_diff, level="original"))

tail(fitted(va_ADF))
tail(fitted(object=va_ADF, level="original"))


</code></pre>

<hr>
<h2 id='getTh'>Extract threshold(s) coefficient</h2><span id='topic+getTh'></span><span id='topic+getTh.default'></span>

<h3>Description</h3>

<p>Extract threshold coefficient(s)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTh(object, ...)

## Default S3 method:
getTh(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTh_+3A_object">object</code></td>
<td>
<p>object of class <code>setar</code>, <code>summary.setar</code>,
<code>nlVar</code></p>
</td></tr>
<tr><td><code id="getTh_+3A_...">...</code></td>
<td>
<p>additional arguments to <code>getTh</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Threshold value.
</p>


<h3>Author(s)</h3>

<p>Matthieu Stigler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set&lt;-setar(lynx, m=3)
getTh(set)
getTh(summary(set))

</code></pre>

<hr>
<h2 id='GIRF'>Generalized Impulse response Function (GIRF)</h2><span id='topic+GIRF'></span><span id='topic+GIRF.setar'></span><span id='topic+GIRF.linear'></span><span id='topic+GIRF.nlVar'></span><span id='topic+plot.GIRF_df'></span>

<h3>Description</h3>

<p>Generates a GIRF for multiple innovations and histories
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GIRF(object, n.ahead, seed = NULL, ...)

## S3 method for class 'setar'
GIRF(
  object,
  n.ahead = 10,
  seed = NULL,
  n.hist = 20,
  n.shock = 20,
  R = 10,
  hist_li = NULL,
  shock_li = NULL,
  ...
)

## S3 method for class 'linear'
GIRF(
  object,
  n.ahead = 10,
  seed = NULL,
  n.hist = 20,
  n.shock = 20,
  R = 10,
  hist_li = NULL,
  shock_li = NULL,
  ...
)

## S3 method for class 'nlVar'
GIRF(
  object,
  n.ahead = 10,
  seed = NULL,
  n.hist = 20,
  n.shock = 20,
  R = 10,
  hist_li = NULL,
  shock_li = NULL,
  ...
)

## S3 method for class 'GIRF_df'
plot(
  x,
  plot_type = c("density", "line"),
  n.ahead = c(1, 5, 10),
  var = unique(x$var)[1],
  n_simu = c(1, 2),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GIRF_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="#topic+linear">linear</a></code>, <code><a href="#topic+setar">setar</a></code> or <code>nlVar</code> (<code><a href="#topic+TVAR">TVAR</a></code>, <code><a href="#topic+TVECM">TVECM</a></code>)</p>
</td></tr>
<tr><td><code id="GIRF_+3A_n.ahead">n.ahead</code></td>
<td>
<p>The number of steps ahead to compute</p>
</td></tr>
<tr><td><code id="GIRF_+3A_seed">seed</code></td>
<td>
<p>optional, the seed for the random numbers</p>
</td></tr>
<tr><td><code id="GIRF_+3A_n.hist">n.hist</code></td>
<td>
<p>The number of past histories to consider. Should be high, ideally size of data (minus lags).</p>
</td></tr>
<tr><td><code id="GIRF_+3A_n.shock">n.shock</code></td>
<td>
<p>The number of actual shocks to consider</p>
</td></tr>
<tr><td><code id="GIRF_+3A_r">R</code></td>
<td>
<p>the number of draws to use for the n.ahead innovations</p>
</td></tr>
<tr><td><code id="GIRF_+3A_hist_li">hist_li</code></td>
<td>
<p>optional, a list of histories (each of same length as lags in the model). 
If not provided, <code>n.hist</code> histories will be randomly drawn for the original series.</p>
</td></tr>
<tr><td><code id="GIRF_+3A_shock_li">shock_li</code></td>
<td>
<p>optional, a list of innovations. 
If not provided, <code>n.shock</code> shocks will be randomly drawn from the estimated residuals.</p>
</td></tr>
<tr><td><code id="GIRF_+3A_x">x</code></td>
<td>
<p>output of girf</p>
</td></tr>
<tr><td><code id="GIRF_+3A_plot_type">plot_type</code></td>
<td>
<p>plot: density (for each <code>n.ahead</code>), or line (for multipe <code>n_simu</code>)?</p>
</td></tr>
<tr><td><code id="GIRF_+3A_var">var</code></td>
<td>
<p>plot: which variable to plot?</p>
</td></tr>
<tr><td><code id="GIRF_+3A_n_simu">n_simu</code></td>
<td>
<p>line plot: which simulation to plot?</p>
</td></tr>
<tr><td><code id="GIRF_+3A_...">...</code></td>
<td>
<p>Further arguments passed to specific methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In a nonlinear model, the Impulse response Function (IRF) is not time-, scale- and sign-invariant as in linear models. 
To address this, Koop et al (1996) introduced the Generalized Impulse response Function (GIRF):
</p>
<p style="text-align: center;"><code class="reqn">GIRF(h,\delta,\omega_{t-1})=E[y_{t+h}|\epsilon_{t}=\delta,\epsilon_{t+h}=0,\omega_{t-1}]-E[y_{t+h}|\epsilon_{t}=0,\epsilon_{t+h}=0,\omega_{t-1}]</code>
</p>

<p>It is the difference between two conditional expectations, one containing the shock of interest, the second one averaging it out. The averaging-out is done
by comparing against random innovations (unlike the IRF, which compares against innovation 0), 
The parameter <code>R</code> corresponds to the number of times this is done. 
</p>
<p>The GIRF as defined here depends on the particular shock, as well as on the history. 
Koop et al (1996) suggest to draw multiple combinations of histories and innovations. This is done with arguments <code>n.hist</code> and <code>n.shock</code> 
(or, alternatively, provide one of, or both, <code>hist_li</code> and <code>hist_li</code> as list of histories and shocks).
</p>
<p>The output is a data-frame containing the two average paths for each combinations of shocks and histories.
</p>


<h3>Value</h3>

<p>A data-frame, with:
</p>
 
<dl>
<dt>n_simu:</dt><dd><p>Id for the simulation (total number is n.hist times n.shock)</p>
</dd> 
<dt>hist, shock</dt><dd><p>History and shock used in the nth simulation</p>
</dd>
<dt>n.ahead:</dt><dd><p>The forecasting horizon. Note the shocks happens at time 0</p>
</dd>
<dt>var:</dt><dd><p>The variable (on which the shock happens, corresponds hence to the <code>response</code> argument in <code>irf</code>)</p>
</dd>
<dt>sim_1, sim_2</dt><dd><p>The average (over R times) simulation with the specific shock (sim_1) or with random shocks (sim_2). </p>
</dd>
<dt>girf</dt><dd><p>The difference between sim_1 and sim_2</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Matthieu Stigler
</p>


<h3>References</h3>

<p>Koop, G, Pesaran, M. H. &amp; Potter, S. M. (1996) Impulse response analysis in nonlinear multivariate models. Journal of Econometrics, 74, 119-147
</p>


<h3>See Also</h3>

<p><code><a href="#topic+irf.nlVar">irf.nlVar</a></code> for the IRF, for linear models, or in case of non-linear models, for each regime.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## simulate a SETAR for the example. Higher regime more persistent (AR coef 0.5 instead of 0.2)
set &lt;- setar.sim(B = c(0.5, 0.2, 0.5, 0.5), lag = 1, Thresh = 0.5, n = 500)
set_estim &lt;- setar(set, m = 1)

## regime-specific IRF:
plot(irf(set_estim, regime = "L", boot = FALSE))
plot(irf(set_estim, regime = "H", boot = FALSE))

## GIRF
girf_out &lt;- GIRF(set_estim, n.hist = 10, n.shock = 10) # smaller number for example only

## the GIRF shows a very fast convergence (the shock at n.ahead = 4 is already very close to 0)
plot(girf_out, n.ahead = 1:4)
## investigate a few specific GIRFS:
plot(girf_out, plot_type = "line", n_simu  = 1:5)
</code></pre>

<hr>
<h2 id='IIPUs'>US monthly industrial production from Hansen (1999)</h2><span id='topic+IIPUs'></span>

<h3>Description</h3>

<p>This data, used as example in Hansen (1999), contains the US monthly
industrial production.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IIPUs
</code></pre>


<h3>Format</h3>

<p>A monthly time series of class ts starting in January 1960 and
ending in September 1997. Note that the series ends at 1997 and not 1998 as
in the paper of Hansen, even if the data was taken from hi site and the
graph is exactly the same.
</p>


<h3>Source</h3>

<p>Hansen (1999) Testing for linearity, Journal of Economic Surveys,
Volume 13, Number 5, December 1999 , pp. 551-576(26) available at:
<a href="http://www.ssc.wisc.edu/~bhansen/papers/cv.htm">http://www.ssc.wisc.edu/~bhansen/papers/cv.htm</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(IIPUs)
end(IIPUs) #not same date as in the paper

## Figure 2 in paper (p. 555)
plot(IIPUs)

## Table 1 in paper (p. 556)
ar_1 &lt;- linear(IIPUs, m=16)
coef(summary(ar_1))[, 1:2]
deviance(ar_1)

## Table 2 in paper (p. 559)
set_1 &lt;- setar(IIPUs, m=16, thDelay=5, trim=0.1)
## tsDyn finds another threshold, with a better SSR:
getTh(set_1)
deviance(set_1)

## estimate with Hansen threshold:
set_1_han &lt;- setar(IIPUs, m=16, thDelay=5, trim=0.1, th = 0.23)
deviance(set_1_han)
set_1_CO &lt;- coef(summary(set_1_han))[, 1:2]
cbind(set_1_CO[1:17,], set_1_CO[18:34,])


## Table 4 in paper (p. 561)
set_2 &lt;- setar(IIPUs, m=16, thDelay=5, trim=0.1, nthresh =2)
getTh(set_2)
deviance(set_2)

##most of the results agree, except constant in the low regime which has opposed signs!
set_2_CO &lt;- coef(summary(set_2))[, 1:2]
cbind(set_2_CO[1:17,], set_1_CO[18:34,])

#this is obviously a error in Hansen, see:
XX&lt;-embed(IIPUs, 17)
Y&lt;-XX[,1]
X&lt;-XX[,-1]
dummyDown&lt;-ifelse(X[,6]&lt;= -2.5, 1,0)
sum(dummyDown)
M&lt;-cbind(1*dummyDown,X*dummyDown )
lm(Y~M-1)

## setar test (takes long to compute, even with small nboot)
## Not run: 
  test_1 &lt;- setarTest(IIPUs, m=16, thDelay=5, nboot=10)
  #because of the discrepency. test1vs2 does not correspond, test 1vs3 conforms
  test_1$Ftests ## compare with Table 2 (F12)  and Table 4 (F13, F23)
  summary(test_1)
  
  setarTest(IIPUs, m=16, thDelay=5, nboot=10, test="2vs3")
  #test 2vs3 is also different of the version in the article (27)

## End(Not run)

## results from the test is stored in: setarTest_IIPUs_results
data(setarTest_IIPUs_results)

## Table 5 and 6
test_1vs &lt;- setarTest_IIPUs_results$test_1
test_1vs

## Table 7
test_2vs &lt;- setarTest_IIPUs_results$test_2
test_2vs
plot(test_2vs)
</code></pre>

<hr>
<h2 id='irf.linear'>Impulse response function</h2><span id='topic+irf.linear'></span><span id='topic+irf.setar'></span><span id='topic+irf.ar'></span><span id='topic+irf.VAR'></span><span id='topic+irf.nlVar'></span><span id='topic+irf.VECM'></span><span id='topic+irf.TVAR'></span><span id='topic+irf.TVECM'></span>

<h3>Description</h3>

<p>Compute the impulse response coefficients (IRF) of a VAR(p) (or transformed VECM to VAR(p)) for
<code>n.ahead</code> steps.
For TVECM and TVAR model, argument <code>regime</code> offers regime-specific IRF.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'linear'
irf(
  x,
  impulse = NULL,
  response = NULL,
  n.ahead = 10,
  ortho = TRUE,
  cumulative = FALSE,
  boot = TRUE,
  ci = 0.95,
  runs = 100,
  seed = NULL,
  ...
)

## S3 method for class 'setar'
irf(
  x,
  impulse = NULL,
  response = NULL,
  n.ahead = 10,
  ortho = TRUE,
  cumulative = FALSE,
  boot = TRUE,
  ci = 0.95,
  runs = 100,
  seed = NULL,
  regime = c("L", "M", "H"),
  ...
)

## S3 method for class 'ar'
irf(
  x,
  impulse = NULL,
  response = NULL,
  n.ahead = 10,
  ortho = TRUE,
  cumulative = FALSE,
  boot = TRUE,
  ci = 0.95,
  runs = 100,
  seed = NULL,
  ...
)

## S3 method for class 'VAR'
irf(
  x,
  impulse = NULL,
  response = NULL,
  n.ahead = 10,
  ortho = TRUE,
  cumulative = FALSE,
  boot = TRUE,
  ci = 0.95,
  runs = 100,
  seed = NULL,
  ...
)

## S3 method for class 'VECM'
irf(
  x,
  impulse = NULL,
  response = NULL,
  n.ahead = 10,
  ortho = TRUE,
  cumulative = FALSE,
  boot = TRUE,
  ci = 0.95,
  runs = 100,
  seed = NULL,
  ...
)

## S3 method for class 'TVAR'
irf(
  x,
  impulse = NULL,
  response = NULL,
  n.ahead = 10,
  ortho = TRUE,
  cumulative = FALSE,
  boot = TRUE,
  ci = 0.95,
  runs = 100,
  seed = NULL,
  regime = c("L", "M", "H"),
  ...
)

## S3 method for class 'TVECM'
irf(
  x,
  impulse = NULL,
  response = NULL,
  n.ahead = 10,
  ortho = TRUE,
  cumulative = FALSE,
  boot = TRUE,
  ci = 0.95,
  runs = 100,
  seed = NULL,
  regime = c("L", "M", "H"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="irf.linear_+3A_x">x</code></td>
<td>
<p>Object of class &lsquo;<code>VAR</code>&rsquo;; generated by
<code>lineVar()</code>, or object of class &lsquo;<code>VECM</code>&rsquo;; generated
by<code>VECM()</code>.</p>
</td></tr>
<tr><td><code id="irf.linear_+3A_impulse">impulse</code>, <code id="irf.linear_+3A_response">response</code></td>
<td>
<p>Not used!</p>
</td></tr>
<tr><td><code id="irf.linear_+3A_n.ahead">n.ahead</code></td>
<td>
<p>Integer specifying the steps.</p>
</td></tr>
<tr><td><code id="irf.linear_+3A_ortho">ortho</code></td>
<td>
<p>Logical, if <code>TRUE</code> (the default) the orthogonalised
impulse response coefficients are computed .</p>
</td></tr>
<tr><td><code id="irf.linear_+3A_cumulative">cumulative</code></td>
<td>
<p>Logical, if <code>TRUE</code> the cumulated impulse response
coefficients are computed. The default value is false.</p>
</td></tr>
<tr><td><code id="irf.linear_+3A_boot">boot</code>, <code id="irf.linear_+3A_ci">ci</code>, <code id="irf.linear_+3A_runs">runs</code>, <code id="irf.linear_+3A_seed">seed</code></td>
<td>
<p>Arguments for the bootstrap, see  <code><a href="vars.html#topic+irf.varest">irf.varest</a></code></p>
</td></tr>
<tr><td><code id="irf.linear_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="irf.linear_+3A_regime">regime</code></td>
<td>
<p>For a setar model, which regime (L, M or H) to produce IRF for?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class &lsquo;<code>varirf</code>&rsquo; see  <code><a href="vars.html#topic+irf.varest">irf.varest</a></code>
</p>


<h3>Author(s)</h3>

<p>Matthieu Stigler
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+plot">plot</a></code> for the plot method. <code><a href="#topic+lineVar">lineVar</a></code>,
<code><a href="#topic+VECM">VECM</a></code> for the models.
Hamilton, J. (1994), <em>Time Series Analysis</em>, Princeton University
Press, Princeton.
</p>
<p>Lutkepohl, H. (2006), <em>New Introduction to Multiple Time Series
Analysis</em>, Springer, New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(barry)

## For VAR
mod_var &lt;- lineVar(barry, lag = 2)
irf(mod_var, impulse = "dolcan", response = c("dolcan", "cpiUSA", "cpiCAN"), boot =
FALSE)

## For VECM
mod_VECM &lt;- VECM(barry, lag = 2, estim="ML", r=2)
irf(mod_VECM, impulse = "dolcan", response = c("dolcan", "cpiUSA", "cpiCAN"), boot =
FALSE)

</code></pre>

<hr>
<h2 id='isLinear'>isLinear</h2><span id='topic+isLinear'></span>

<h3>Description</h3>

<p>Generic NLAR linearity test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isLinear(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isLinear_+3A_object">object</code></td>
<td>
<p>fitted time series model</p>
</td></tr>
<tr><td><code id="isLinear_+3A_...">...</code></td>
<td>
<p>arguments to and from other methods</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>A. F. Di Narzo
</p>

<hr>
<h2 id='KapShinTest'>Test of unit root against SETAR alternative with</h2><span id='topic+KapShinTest'></span><span id='topic+KapShinTest'></span>

<h3>Description</h3>

<p>Test of unit root against a stationnary 3 regime SETAR alternative with random walk in the inner regime
</p>


<h3>Usage</h3>

<pre><code class='language-R'> KapShinTest(x, m=1, series, include = c("none","const", "trend", "both"), 
  c=3, delta=0.5, points=NULL,minObsMid=10, 
  trick=c("for", "apply", "mapply"), trace=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KapShinTest_+3A_x">x</code></td>
<td>
<p> time series </p>
</td></tr>
<tr><td><code id="KapShinTest_+3A_m">m</code></td>
<td>
<p>Number of lags under the alternative</p>
</td></tr>
<tr><td><code id="KapShinTest_+3A_series">series</code></td>
<td>
<p> time series name (optional) </p>
</td></tr>
<tr><td><code id="KapShinTest_+3A_include">include</code></td>
<td>
<p>Whether data should be raw, de-meaned or de-meaned and de-trended</p>
</td></tr>
<tr><td><code id="KapShinTest_+3A_c">c</code></td>
<td>
<p>Argument for the grid search. See details</p>
</td></tr>
<tr><td><code id="KapShinTest_+3A_delta">delta</code></td>
<td>
<p>Argument for the grid search. See details</p>
</td></tr>
<tr><td><code id="KapShinTest_+3A_points">points</code></td>
<td>
<p>Points for the grid search. See details</p>
</td></tr>
<tr><td><code id="KapShinTest_+3A_minobsmid">minObsMid</code></td>
<td>
<p>Minimal number of observations in the inner regime</p>
</td></tr>
<tr><td><code id="KapShinTest_+3A_trick">trick</code></td>
<td>
<p>type of internal function used</p>
</td></tr>
<tr><td><code id="KapShinTest_+3A_trace">trace</code></td>
<td>
<p>should additional infos be printed? (logical)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is currently spurious.  
</p>


<h3>Value</h3>

<p>A object of class <code>KapShin2006Test</code> containing:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>The three (SupW, AvgW, ExpW) test statistics computed</p>
</td></tr>
<tr><td><code>case</code></td>
<td>
<p>Whether the data was transformed, corresponds to input argument include</p>
</td></tr>
<tr><td><code>series</code></td>
<td>
<p>The name of the series</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Matthieu Stigler</p>


<h3>See Also</h3>

<p><code><a href="#topic+BBCTest">BBCTest</a></code> for a similar test. <code><a href="#topic+setarTest">setarTest</a></code> for a test with stationarity as a null.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>KapShinTest(lynx, m=1, trace=FALSE, include="none", points=10)
</code></pre>

<hr>
<h2 id='lags.select'>Selection of the lag with Information criterion.</h2><span id='topic+lags.select'></span>

<h3>Description</h3>

<p>Selection of the cointegrating rank and the lags with Information criterion
(AIC, BIC).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lags.select(
  data,
  lag.max = 10,
  include = c("const", "trend", "none", "both"),
  fitMeasure = c("SSR", "LL"),
  sameSample = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lags.select_+3A_data">data</code></td>
<td>
<p>multivariate time series.</p>
</td></tr>
<tr><td><code id="lags.select_+3A_lag.max">lag.max</code></td>
<td>
<p>Maximum number of lags to investigate.</p>
</td></tr>
<tr><td><code id="lags.select_+3A_include">include</code></td>
<td>
<p>Type of deterministic regressors to include.</p>
</td></tr>
<tr><td><code id="lags.select_+3A_fitmeasure">fitMeasure</code></td>
<td>
<p>Whether the AIC/BIC should be based on the full likelihood,
or just the SSR. See explanations in <code><a href="#topic+logLik.VECM">logLik.VECM</a></code>.</p>
</td></tr>
<tr><td><code id="lags.select_+3A_samesample">sameSample</code></td>
<td>
<p>Logical. Whether the data should be shortened so that the
AIC/BIC are estimated on the same sample. Default to TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function selects the lag according to AIC, BIC and Hannan-Quinn.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+rank.select">rank.select</a></code>, with &lsquo;print&rsquo; and
&lsquo;summary methods&rsquo;, containing among other the matrices of AIC/BIC/HQ.
</p>


<h3>Author(s)</h3>

<p>Matthieu Stigler
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rank.select">rank.select</a></code>, the underlying function, to estimate the
rank also.
</p>
<p><code><a href="vars.html#topic+VARselect">VARselect</a></code> in package <span class="pkg">vars</span>, does basically the same.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(barry)

# 
rk_sel &lt;- lags.select(barry)
rk_sel
summary(rk_sel)


</code></pre>

<hr>
<h2 id='LINEAR'>Linear AutoRegressive models</h2><span id='topic+LINEAR'></span><span id='topic+linear'></span><span id='topic+print.linear'></span><span id='topic+summary.linear'></span><span id='topic+print.summary.linear'></span>

<h3>Description</h3>

<p>AR(m) model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	linear(x, m, d=1, steps=d, series, include = c( "const", "trend","none", "both"), 
        type=c("level", "diff", "ADF"), warn_root=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LINEAR_+3A_x">x</code></td>
<td>
<p> time series </p>
</td></tr>
<tr><td><code id="LINEAR_+3A_m">m</code>, <code id="LINEAR_+3A_d">d</code>, <code id="LINEAR_+3A_steps">steps</code></td>
<td>
<p> embedding dimension, time delay, forecasting steps </p>
</td></tr>
<tr><td><code id="LINEAR_+3A_series">series</code></td>
<td>
<p> time series name (optional) </p>
</td></tr>
<tr><td><code id="LINEAR_+3A_include">include</code></td>
<td>
<p>Type of deterministic regressors to include</p>
</td></tr>
<tr><td><code id="LINEAR_+3A_type">type</code></td>
<td>
<p>Whether the variable is taken is level, difference or a mix (diff y= y-1, diff lags) as in the ADF test</p>
</td></tr>
<tr><td><code id="LINEAR_+3A_warn_root">warn_root</code></td>
<td>
<p>Whether to check (and warn) for roots outside the unit circle?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>AR(m) model:
</p>
<p style="text-align: center;"><code class="reqn">  x_{t+s} = \phi_0 + \phi_1 x_t + \phi_2 x_{t-d} + \dots + \phi_m x_{t -
    (m-1)d} + \epsilon_{t+s}</code>
</p>



<h3>Value</h3>

<p>A <code><a href="#topic+nlar">nlar</a></code> object, <code>linear</code> subclass.
</p>


<h3>Author(s)</h3>

<p> Antonio, Fabio Di Narzo </p>


<h3>See Also</h3>

<p><code><a href="#topic+nlar">nlar</a></code> for fitting this and other models to time series data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#fit an AR(2) model
mod.linear &lt;- linear(log(lynx), m=2)
mod.linear
summary(mod.linear)
</code></pre>

<hr>
<h2 id='lineVar'>Multivariate linear models: VAR and VECM</h2><span id='topic+lineVar'></span>

<h3>Description</h3>

<p>Estimate either a VAR or a VECM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lineVar(
  data,
  lag,
  r = 1,
  include = c("const", "trend", "none", "both"),
  model = c("VAR", "VECM"),
  I = c("level", "diff", "ADF"),
  beta = NULL,
  estim = c("2OLS", "ML"),
  LRinclude = c("none", "const", "trend", "both"),
  exogen = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lineVar_+3A_data">data</code></td>
<td>
<p>multivariate time series (first row being first=oldest value)</p>
</td></tr>
<tr><td><code id="lineVar_+3A_lag">lag</code></td>
<td>
<p>Number of lags to include in each regime</p>
</td></tr>
<tr><td><code id="lineVar_+3A_r">r</code></td>
<td>
<p>Number of cointegrating relationships</p>
</td></tr>
<tr><td><code id="lineVar_+3A_include">include</code></td>
<td>
<p>Type of deterministic regressors to include</p>
</td></tr>
<tr><td><code id="lineVar_+3A_model">model</code></td>
<td>
<p>Model to estimate. Either a VAR or a VECM</p>
</td></tr>
<tr><td><code id="lineVar_+3A_i">I</code></td>
<td>
<p>For VAR only: whether in the VAR the variables are to be taken in
levels (original series) or in difference, or similarly to the univariate ADF
case.</p>
</td></tr>
<tr><td><code id="lineVar_+3A_beta">beta</code></td>
<td>
<p>for VECM only: user-specified cointegrating value. 
If NULL, will be estimated using the estimator specified in <code>estim</code></p>
</td></tr>
<tr><td><code id="lineVar_+3A_estim">estim</code></td>
<td>
<p>Type of estimator for the VECM: '2OLS' for the two-step approach
or 'ML' for Johansen MLE</p>
</td></tr>
<tr><td><code id="lineVar_+3A_lrinclude">LRinclude</code></td>
<td>
<p>Possibility to include in the long-run relationship and the
ECT a trend, a, constant, etc. Can also be a matrix with exogeneous regressors</p>
</td></tr>
<tr><td><code id="lineVar_+3A_exogen">exogen</code></td>
<td>
<p>Inclusion of exogenous variables (first row being first=oldest
value). Is either of same size than data (then automatically cut) or than
end-sample.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides basic functionalities for VAR and VECM models. More
comprehensive functions are in package <span class="pkg">vars</span>. A few differences appear
in the VECM estimation: </p>
 
<dl>
<dt>Engle-Granger estimator</dt><dd><p>The Engle-Granger estimator is available</p>
</dd>
<dt>Presentation</dt><dd><p>Results are printed in a different ways, using a matrix form</p>
</dd>
<dt>lateX export</dt><dd><p>The matrix of coefficients can be exported to latex, 
with or without standard-values and significance stars</p>
</dd>
</dl>
 
<p>Two estimators are available: the Engle-Granger two-steps
approach (<code>2OLS</code>) or the Johansen (<code>ML</code>). For the 2OLS,
deterministic regressors (or external variables if <code>LRinclude</code> is of
class numeric) can be added for the estimation of the cointegrating value and
for the ECT. This is only working when the beta value is not pre-specified.
</p>
<p>The argument <code>beta</code> is only for <code><a href="#topic+VECM">VECM</a></code>, look at the specific help page for more details.
</p>


<h3>Value</h3>

<p>Fitted model data
</p>


<h3>Author(s)</h3>

<p>Matthieu Stigler
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VECM">VECM</a></code> which is just a wrapper for <code>lineVar(..., model="VECM")</code>. 
Methods <code><a href="#topic+predict.VAR">predict.VAR</a></code>, <code><a href="#topic+VARrep">VARrep</a></code>, <code><a href="#topic+regime">regime</a></code>, <code><a href="#topic+irf">irf</a></code> and <code><a href="utils.html#topic+toLatex">toLatex</a></code>.
</p>
<p><code><a href="#topic+TVAR">TVAR</a></code> and <code><a href="#topic+TVECM">TVECM</a></code> for the corresponding threshold
models. <code><a href="#topic+linear">linear</a></code> for the univariate AR model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(zeroyld)

#Fit a VAR
VAR &lt;- lineVar(zeroyld, lag=1)
VAR
summary(VAR)

#compare results with package vars:
if(require(vars)) {
a&lt;-VAR(zeroyld, p=1)
coef_vars &lt;- t(sapply(coef(a), function(x) x[c(3,1,2),1]))
all.equal(coef(VAR),coef_vars, check.attributes=FALSE)
}

###VECM
VECM.EG &lt;- lineVar(zeroyld, lag=2, model="VECM")
VECM.EG
summary(VECM.EG)

VECM.ML &lt;- lineVar(zeroyld, lag=2, model="VECM", estim="ML")
VECM.ML
summary(VECM.ML)


###Check Johansen MLE
myVECM &lt;- lineVar(zeroyld, lag=1, include="const", model="VECM", estim="ML")
summary(myVECM, digits=7) 
#comparing with vars package
if(require(vars)){
a&lt;-ca.jo(zeroyld, spec="trans")
summary(a)
#same answer also!
}

##export to Latex
toLatex(VECM.EG)
toLatex(summary(VECM.EG))
options("show.signif.stars"=FALSE)
toLatex(summary(VECM.EG), parenthese="Pvalue")
options("show.signif.stars"=TRUE)



</code></pre>

<hr>
<h2 id='llar'>Locally linear model</h2><span id='topic+llar'></span><span id='topic+llar.predict'></span><span id='topic+llar.fitted'></span><span id='topic+print.llar'></span><span id='topic+as.data.frame.llar'></span><span id='topic+plot.llar'></span>

<h3>Description</h3>

<p>Casdagli test of nonlinearity via locally linear forecasts
</p>


<h3>Usage</h3>

<pre><code class='language-R'>llar(x, m, d = 1, steps = d, series, eps.min = sd(x)/2,
	eps.max = diff(range(x)), neps = 30, trace = 0)

llar.predict(x, m, d=1, steps=d, series, n.ahead=1, 
eps=stop("you must specify a window value"),
onvoid=c("fail","enlarge"), r = 20, trace=1)

llar.fitted(x, m, d=1, steps=d, series, eps, trace=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="llar_+3A_x">x</code></td>
<td>
<p> time series </p>
</td></tr>
<tr><td><code id="llar_+3A_m">m</code>, <code id="llar_+3A_d">d</code>, <code id="llar_+3A_steps">steps</code></td>
<td>
<p> embedding dimension, time delay, forecasting steps </p>
</td></tr>
<tr><td><code id="llar_+3A_series">series</code></td>
<td>
<p>time series name (optional)</p>
</td></tr>
<tr><td><code id="llar_+3A_n.ahead">n.ahead</code></td>
<td>
<p> n. of steps ahead to forecast </p>
</td></tr>
<tr><td><code id="llar_+3A_eps.min">eps.min</code>, <code id="llar_+3A_eps.max">eps.max</code></td>
<td>
<p> min and max neighbourhood size </p>
</td></tr>
<tr><td><code id="llar_+3A_neps">neps</code></td>
<td>
<p>number of neighbourhood levels along which iterate</p>
</td></tr>
<tr><td><code id="llar_+3A_eps">eps</code></td>
<td>
<p>neighbourhood size </p>
</td></tr>
<tr><td><code id="llar_+3A_onvoid">onvoid</code></td>
<td>
<p>what to do in case of an isolated point: stop or enlarge neighbourhood size by an r%</p>
</td></tr>
<tr><td><code id="llar_+3A_r">r</code></td>
<td>
<p>if an isolated point is found, enlarge neighbourhood window by r%</p>
</td></tr>
<tr><td><code id="llar_+3A_trace">trace</code></td>
<td>
<p>tracing level: 0, 1 or more than 1 for <code>llar</code>, 0 or
1 for <code>llar.forecast</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>llar</code> does the Casdagli test of non-linearity. Given the embedding state-space (of dimension <code>m</code> and time delay <code>d</code>) obtained from time series <code>series</code>, for a sequence of distance values <code>eps</code>, the relative error made by forecasting time series values with a linear autoregressive model estimated on points closer than <code>eps</code> is computed. 
If minimum error is reached at relatively small length scales, a global linear model may be inappropriate (using current embedding parameters).
This was suggested by Casdagli(1991) as a test for non-linearity.
</p>
<p><code>llar.predict</code> tries to extend the given time series by
<code>n.ahead</code> points by iteratively 
fitting locally (in the embedding space of dimension m and time delay d)
a linear model. If the spatial neighbourhood window is too small, your
time series last point would be probably isolated. You can ask to
automatically enlarge the window <code>eps</code> by a factor of r%
sequentially, until enough neighbours are found for fitting the linear
model.
</p>
<p><code>llar.fitted</code> gives out-of-sample fitted values from locally linear
models.
</p>


<h3>Value</h3>

<p><code>llar</code> gives an object of class 'llar'. I.e., a list of components: 
</p>
<table>
<tr><td><code>RMSE</code></td>
<td>
<p>vector of relative errors</p>
</td></tr>
<tr><td><code>eps</code></td>
<td>
<p>vector of neighbourhood sizes (in the same order of RMSE)</p>
</td></tr>
<tr><td><code>frac</code></td>
<td>
<p>vector of fractions of the time series used for RMSE computation</p>
</td></tr>
<tr><td><code>avfound</code></td>
<td>
<p>vector of average number of neighbours for each point in the time series 
which can be plotted using the <code>plot</code> method, and transformed to a regular <code>data.frame</code> with the <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> function.</p>
</td></tr>
</table>
<p>Function <code>llar.forecast</code> gives the vector of n steps ahead locally linear iterated
forecasts.
</p>
<p>Function <code>llar.fitted</code> gives out-of-sample fitted values from locally linear
models.
</p>


<h3>Warning</h3>

<p>For long time series, this can be slow, especially for relatively big neighbourhood sizes.
</p>


<h3>Note</h3>

<p>The C implementation was re-adapted from that in the TISEAN package (&quot;ll-ar&quot; routine, see references). However, here the euclidean norm is used, in place of the max-norm.
</p>


<h3>Author(s)</h3>

<p> Antonio, Fabio Di Narzo </p>


<h3>References</h3>

<p>M. Casdagli, Chaos and deterministic versus stochastic nonlinear modelling, J. Roy. Stat. Soc. 54, 303 (1991)
</p>
<p>Hegger, R., Kantz, H., Schreiber, T., Practical implementation of nonlinear time series methods: The TISEAN package; CHAOS 9, 413-435 (1999)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- llar(log(lynx), m=3, neps=7)
plot(res)

x.new &lt;- llar.predict(log(lynx),n.ahead=20, m=3, eps=1, onvoid="enlarge", r=5)
lag.plot(x.new, labels=FALSE)

x.fitted &lt;-  llar.fitted(log(lynx), m=3, eps=1)
lag.plot(x.fitted, labels=FALSE)


</code></pre>

<hr>
<h2 id='logLik.nlVar'>Extract Log-Likelihood</h2><span id='topic+logLik.nlVar'></span><span id='topic+logLik.VAR'></span><span id='topic+logLik.VECM'></span>

<h3>Description</h3>

<p>Log-Likelihood method for VAR and VECM models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nlVar'
logLik(object, ...)

## S3 method for class 'VECM'
logLik(object, r, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.nlVar_+3A_object">object</code></td>
<td>
<p>object of class <code>VAR</code> computed by <code><a href="#topic+lineVar">lineVar</a></code>, or 
class <code>VECM</code> computed by <code><a href="#topic+VECM">VECM</a></code>.</p>
</td></tr>
<tr><td><code id="logLik.nlVar_+3A_...">...</code></td>
<td>
<p>additional arguments to <code>logLik</code>.</p>
</td></tr>
<tr><td><code id="logLik.nlVar_+3A_r">r</code></td>
<td>
<p>The cointegrating rank. By default the rank specified in the call to
<code><a href="#topic+VECM">VECM</a></code>, but can be set differently by user.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a VAR, the Log-Likelihood is computed as in Luetkepohl (2006) equ. 3.4.5 (p. 89) and
Juselius (2006) p. 56:
</p>
<p style="text-align: center;"><code class="reqn"> LL = -(TK/2) \log(2\pi) - (T/2) \log|\Sigma| - (1/2) \sum^{T} \left [
(y_t - A^{'}x_t)^{'} \Sigma^{-1} (y_t - A^{'}x_t) \right ] </code>
</p>
<p> Where
<code class="reqn">\Sigma</code> is the Variance matrix of residuals, and <code class="reqn">x_t</code> is the matrix
stacking the regressors (lags and deterministic).
</p>
<p>However, we use a computationally simpler version:
</p>
<p style="text-align: center;"><code class="reqn"> LL = -(TK/2) \log(2\pi) - (T/2) \log|\Sigma| - (TK/2) </code>
</p>

<p>See Juselius (2006), p. 57.
</p>
<p>(Note that Hamilton (1994) 11.1.10, p. 293 gives <code class="reqn">+ (T/2)
\log|\Sigma^{-1}|</code>, which is the same as <code class="reqn">-(T/2) \log|\Sigma|)</code>.
</p>
<p>For VECM, the Log-Likelihood is computed in two different ways, depending on whether the
<code>VECM</code> was estimated with ML (Johansen) or 2OLS (Engle and Granger).
</p>
<p>When the model is estimated with ML, the LL is computed as in Hamilton (1994)
20.2.10 (p. 637):
</p>
<p style="text-align: center;"><code class="reqn"> LL = -(TK/2) \log(2\pi) - (TK/2) -(T/2) \log|\hat\Sigma_{UU}| - (T/2)
\sum_{i=1}^{r} \log (1-\hat\lambda_{i}) </code>
</p>
<p> Where <code class="reqn">\Sigma_{UU}</code> is the
variance matrix of residuals from the first auxiliary regression, i.e.
regressing <code class="reqn">\Delta y_t</code> on a constant and lags, <code class="reqn">\Delta y_{t-1},
\ldots, \Delta y_{t-p}</code>. <code class="reqn">\lambda_{i}</code> are the eigenvalues from the
<code class="reqn">\Sigma_{VV}^{-1}\Sigma_{VU}\Sigma_{UU}^{-1}\Sigma_{UV}</code>, see 20.2.9 in
Hamilton (1994).
</p>
<p>When the model is estimated with 2OLS, the LL is computed as: </p>
<p style="text-align: center;"><code class="reqn"> LL =
\log|\Sigma| </code>
</p>

<p>Where <code class="reqn">\Sigma</code> is the variance matrix of residuals from the the VECM
model. There is hence no correspondence between the LL from the VECM computed
with 2OLS or ML.
</p>


<h3>Value</h3>

<p>Log-Likelihood value.
</p>


<h3>Author(s)</h3>

<p>Matthieu Stigler
</p>


<h3>References</h3>

<p>Hamilton (1994) <em>Time Series Analysis</em>, Princeton University
Press
</p>
<p>Juselius (2006) <em>The Cointegrated VAR model: methodology and
Applications</em>, Oxford Univesity Press
</p>
<p>Luetkepohl (2006) <em>New Introduction to Multiple Time Series Analysis</em>,
Springer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(zeroyld)

#Fit a VAR
VAR &lt;- lineVar(zeroyld, lag=1)
logLik(VAR)

#'#Fit a VECM
vecm &lt;- VECM(zeroyld, lag=1, r=1, estim="ML")
logLik(vecm)

</code></pre>

<hr>
<h2 id='LSTAR'>Logistic Smooth Transition AutoRegressive model</h2><span id='topic+LSTAR'></span><span id='topic+lstar'></span>

<h3>Description</h3>

<p>Logistic Smooth Transition AutoRegressive model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lstar(x, m, d=1, steps=d, series, mL, mH, mTh, thDelay, 
          thVar, th, gamma, trace=TRUE, include = c("const", "trend","none", "both"), 
          control=list(), starting.control=list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LSTAR_+3A_x">x</code></td>
<td>
<p> time series </p>
</td></tr>
<tr><td><code id="LSTAR_+3A_m">m</code>, <code id="LSTAR_+3A_d">d</code>, <code id="LSTAR_+3A_steps">steps</code></td>
<td>
<p> embedding dimension, time delay, forecasting steps </p>
</td></tr>
<tr><td><code id="LSTAR_+3A_series">series</code></td>
<td>
<p> time series name (optional) </p>
</td></tr>
<tr><td><code id="LSTAR_+3A_ml">mL</code></td>
<td>
<p>autoregressive order for 'low' regime (default: m). Must be &lt;=m</p>
</td></tr>
<tr><td><code id="LSTAR_+3A_mh">mH</code></td>
<td>
<p>autoregressive order for 'high' regime (default: m). Must be
&lt;=m</p>
</td></tr>
<tr><td><code id="LSTAR_+3A_thdelay">thDelay</code></td>
<td>
<p>'time delay' for the threshold variable (as multiple of
embedding time delay d)</p>
</td></tr>
<tr><td><code id="LSTAR_+3A_mth">mTh</code></td>
<td>
<p>coefficients for the lagged time series, to obtain the
threshold variable</p>
</td></tr>
<tr><td><code id="LSTAR_+3A_thvar">thVar</code></td>
<td>
<p>external threshold variable</p>
</td></tr>
<tr><td><code id="LSTAR_+3A_th">th</code>, <code id="LSTAR_+3A_gamma">gamma</code></td>
<td>
<p>starting values for coefficients in the LSTAR model. If missing, a grid search is performed</p>
</td></tr>
<tr><td><code id="LSTAR_+3A_trace">trace</code></td>
<td>
<p>should additional infos be printed? (logical)</p>
</td></tr>
<tr><td><code id="LSTAR_+3A_include">include</code></td>
<td>
<p>Type of deterministic regressors to include</p>
</td></tr>
<tr><td><code id="LSTAR_+3A_control">control</code></td>
<td>
<p>further arguments to be passed as <code>control</code> list to
<code><a href="stats.html#topic+optim">optim</a></code></p>
</td></tr>
<tr><td><code id="LSTAR_+3A_starting.control">starting.control</code></td>
<td>
<p>further arguments for the grid search (dimension, bounds). See details below.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn"> x_{t+s} = ( \phi_{1,0} + \phi_{1,1} x_t + \phi_{1,2} x_{t-d} + \dots +
  \phi_{1,mL} x_{t - (mL-1)d} ) G( z_t, th, \gamma ) +
  ( \phi_{2,0} + \phi_{2,1} x_t + \phi_{2,2} x_{t-d} + \dots + \phi_{2,mH}
  x_{t - (mH-1)d} ) (1 - G( z_t, th, \gamma ) ) + \epsilon_{t+steps}</code>
</p>

<p>with <var>z</var> the threshold variable, and <code class="reqn">G</code> the logistic function,
computed as <code>plogis(q, location = th, scale = 1/gamma)</code>, so see
<code><a href="stats.html#topic+plogis">plogis</a></code> documentation for details on the logistic function
formulation and parameters meanings.  
The threshold variable can alternatively be specified by:
</p>

<dl>
<dt>mTh</dt><dd> <p><code class="reqn">z[t] = x[t] mTh[1] + x[t-d] mTh[2] + \dots +
    x[t-(m-1)d] mTh[m]</code> </p>
</dd> 
<dt>thDelay</dt><dd> <p><code class="reqn">z[t] = x[t - thDelay*d ]</code> </p>
</dd>
<dt>thVar</dt><dd> <p><code class="reqn">z[t] = thVar[t]</code> </p>
</dd>
</dl>

<p>Note that if starting values for phi1 and phi2 are provided, isn't
necessary to specify <code>mL</code> and <code>mH</code>. Further, the user has to specify only
one parameter between <code>mTh</code>, <code>thDelay</code> and <code>thVar</code> for indicating the
threshold variable. 
</p>
<p>Estimation of the transition parameters <var>th</var> and <var>gamma</var>, as well as the regression parameters 
<var>phi1</var> and <var>phi2</var>, is done using concentrated least squares, as suggested in <cite>Leybourne et al. (1996)</cite>. 
</p>
<p>Given <var>th</var> and <var>gamma</var>, the model is linear, so regression coefficients
can be obtained as usual by OLS. So the nonlinear numerical search needs only to be done for <var>th</var> and <var>gamma</var>; 
the regression parameters are then recovered by OLS again from the optimal <var>th</var> and <var>gamma</var>. 
</p>
<p>For the nonlinear estimation of the
parameters <var>th</var> and <var>gamma</var>, the program uses the
<code><a href="stats.html#topic+optim">optim</a></code> function, with optimization method BFGS using the analytical gradient. 
For the estimation of standard values, <code><a href="stats.html#topic+optim">optim</a></code> is re-run
using the complete Least Squares objective function, and the standard errors are obtained by inverting the hessian. 
You can pass further arguments to <a href="stats.html#topic+optim">optim</a> directly with the <code>control</code> list argument. For instance, the option <code>maxit</code> maybe useful when
there are convergence issues (see examples).
</p>
<p>Starting parameters are obtained doing a simple two-dimensional grid-search over <var>th</var> and <var>gamma</var>. 
Parameters of the grid (interval for the values, dimension of the grid) can be passed to <code>starting.control</code>. 
</p>

<dl>
<dt><code>nTh</code></dt><dd><p>The number of threshold values (<var>th</var>) in the grid. Defaults to 200</p>
</dd>
<dt><code>nGamma</code></dt><dd><p>The number of smoothing values (<var>gamma</var>) in the grid. Defaults to 40</p>
</dd>
<dt><code>trim</code></dt><dd><p>The minimal percentage of observations in each regime. Defaults to 10% (possible threshold values are between the 0.1 and 0.9 quantile)</p>
</dd>
<dt><code>gammaInt</code></dt><dd><p>The lower and higher smoothing values of the grid. Defaults to c(1,40)</p>
</dd>
<dt><code>thInt</code></dt><dd><p>The lower and higher threshold values of the grid. When not specified (default, i.e NA), the interval are the <code>trim</code> quantiles above. </p>
</dd>
</dl>



<h3>Value</h3>

<p>An object of class <code>nlar</code>, subclass <code>lstar</code>, i.e. a list
with fitted model informations.
</p>


<h3>Author(s)</h3>

<p> Antonio, Fabio Di Narzo </p>


<h3>References</h3>

<p>Non-linear time series models in empirical finance, Philip Hans Franses
and Dick van Dijk, Cambridge: Cambridge University Press (2000). 
</p>
<p>Non-Linear Time Series: A Dynamical Systems Approach, Tong, H., Oxford:
Oxford University Press (1990). 
</p>
<p>Leybourne, S., Newbold, P., Vougas, D. (1998) Unit roots and smooth transitions, Journal of Time Series Analysis, 19: 83-97
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.lstar">plot.lstar</a></code> for details on plots produced for this model
from the <code>plot</code> generic. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#fit a LSTAR model. Note 'maxit': slow convergence
mod.lstar &lt;- lstar(log10(lynx), m=2, mTh=c(0,1), control=list(maxit=3000))
mod.lstar

#fit a LSTAR model without a constant in both regimes. 
mod.lstar2 &lt;- lstar(log10(lynx), m=1,  include="none")
mod.lstar2

#Note in example below that the initial grid search seems to be to narrow. 
# Extend it, and evaluate more values (slow!):
controls &lt;- list(gammaInt=c(1,2000), nGamma=50)
mod.lstar3 &lt;- lstar(log10(lynx), m=1,  include="none", starting.control=controls)
mod.lstar3

# a few methods for lstar:
summary(mod.lstar)
residuals(mod.lstar)
AIC(mod.lstar)
BIC(mod.lstar)
plot(mod.lstar)
predict(mod.lstar, n.ahead=5)
</code></pre>

<hr>
<h2 id='m.unrate'>Monthly US unemployment </h2><span id='topic+m.unrate'></span>

<h3>Description</h3>

<p>Monthly US civilian unemployment rate from 1948 through 2004.  
Used in the book financial time series for Tsay (2005, chapter 4)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(m.unrate)
</code></pre>


<h3>Format</h3>

<p>zoo object 
</p>


<h3>Source</h3>

<p>&lsquo;<span class="samp">&#8288;https://faculty.chicagobooth.edu/ruey-s-tsay/research/analysis-of-financial-time-series-2nd-edition&#8288;</span>&rsquo;
</p>


<h3>References</h3>

<p>Ruey Tsay (2005) Analysis of Financial Time Series, 2nd ed. (Wiley,
ch. 4)
</p>

<hr>
<h2 id='MakeThSpec'>Specification of the threshold search</h2><span id='topic+MakeThSpec'></span><span id='topic+makeThSpec'></span>

<h3>Description</h3>

<p>This optional function allows the user to set different restrictions for the
threshold grid search in function <code><a href="#topic+selectSETAR">selectSETAR</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MakeThSpec(
  ngrid = c("All", "Half", "Third", "Quarter"),
  exact = NULL,
  int = c("from", "to"),
  around = "val",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MakeThSpec_+3A_ngrid">ngrid</code></td>
<td>
<p>The number of values to search for</p>
</td></tr>
<tr><td><code id="MakeThSpec_+3A_exact">exact</code></td>
<td>
<p>The user give an exact threshold value</p>
</td></tr>
<tr><td><code id="MakeThSpec_+3A_int">int</code></td>
<td>
<p>The user gives an interval to search inside</p>
</td></tr>
<tr><td><code id="MakeThSpec_+3A_around">around</code></td>
<td>
<p>The user gives an point to search around</p>
</td></tr>
<tr><td><code id="MakeThSpec_+3A_...">...</code></td>
<td>
<p>currently unused</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is just to check the inputs for the specification of the grid
search. If not provided, the search will be in the biggest interval
(<code style="white-space: pre;">&#8288;ngrid ="All"&#8288;</code>) between the minimum and maximum values. The user can
reduce it by giving setting &quot;Half&quot; (only every two points is taken) and so
on, or setting a number.
</p>
<p>The search can also be made around a point, or between two points. When
between a point, the argument <code>ngrid</code> is still used, whereas for around,
a value of 30 is taken as default value if <code>ngrid</code> is not specified by
user.
</p>


<h3>Value</h3>

<p>The input values are given as output after checking for consistency
(only one of exact/int/around should be given).
</p>


<h3>Author(s)</h3>

<p>Matthieu Stigler
</p>


<h3>See Also</h3>

<p><code><a href="#topic+selectSETAR">selectSETAR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sun&lt;-(sqrt(sunspot.year+1)-1)*2		
selectSETAR(sun, m=3, th=MakeThSpec(exact=10.40967),criterion="SSR", d=1, thDelay=0:2,
           plot=FALSE, nthresh=1)
#when pre-sepcified value does not correspond, function will search nearest value
selectSETAR(sun, m=3, th=MakeThSpec(exact=10.4),criterion="SSR", d=1, thDelay=0:2,
           plot=FALSE, nthresh=1)
#search around:
selectSETAR(sun, m=3, th=MakeThSpec(around=10.40967, ngrid=20),criterion="SSR", d=1, thDelay=0:2,
           plot=FALSE, nthresh=1)
#search in an interval
selectSETAR(sun, m=3, th=MakeThSpec(int=c(10, 11), ngrid=20),criterion="SSR", d=1, thDelay=0:2,
           plot=FALSE, nthresh=1)
#reduce size of the grid:
selectSETAR(sun, m=3, th=MakeThSpec(ngrid="Half"),criterion="SSR", d=1, thDelay=0:2,
           plot=FALSE, nthresh=1)


# 2 thresholds:
selectSETAR(sun, m=3, th=MakeThSpec(ngrid="Half"),criterion="SSR", d=1, thDelay=0:2,
           plot=FALSE, nthresh=2)


</code></pre>

<hr>
<h2 id='MAPE'>Mean Absolute Percent Error</h2><span id='topic+MAPE'></span><span id='topic+MAPE.default'></span>

<h3>Description</h3>

<p>Generic function to compute the Mean Absolute Percent Error of a fitted
model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MAPE(object, ...)

## Default S3 method:
MAPE(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MAPE_+3A_object">object</code></td>
<td>
<p>object of class <code>nlar.fit</code></p>
</td></tr>
<tr><td><code id="MAPE_+3A_...">...</code></td>
<td>
<p>additional arguments to <code>MAPE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Computed Mean Absolute Percent Error for the fitted model.
</p>


<h3>Author(s)</h3>

<p>Antonio, Fabio Di Narzo
</p>

<hr>
<h2 id='mse'>Mean Square Error</h2><span id='topic+mse'></span><span id='topic+mse.default'></span>

<h3>Description</h3>

<p>Generic function to compute the Mean Squared Error of a fitted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mse(object, ...)

## Default S3 method:
mse(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mse_+3A_object">object</code></td>
<td>
<p>object of class <code>nlar.fit</code></p>
</td></tr>
<tr><td><code id="mse_+3A_...">...</code></td>
<td>
<p>additional arguments to <code>mse</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Computed MSE for the fitted model.
</p>


<h3>Author(s)</h3>

<p>Antonio, Fabio Di Narzo
</p>

<hr>
<h2 id='nlar'>Non-linear time series model, base class definition</h2><span id='topic+nlar'></span>

<h3>Description</h3>

<p>Generic non-linear autoregressive model class constructor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nlar(
  str,
  coefficients,
  fitted.values,
  residuals,
  k,
  model,
  model.specific = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nlar_+3A_str">str</code></td>
<td>
<p>a <code>nlar.struct</code> object, i.e. the result of a call to
<code><a href="#topic+nlar.struct">nlar.struct</a></code></p>
</td></tr>
<tr><td><code id="nlar_+3A_coefficients">coefficients</code>, <code id="nlar_+3A_fitted.values">fitted.values</code>, <code id="nlar_+3A_residuals">residuals</code>, <code id="nlar_+3A_k">k</code>, <code id="nlar_+3A_model">model</code>, <code id="nlar_+3A_model.specific">model.specific</code></td>
<td>
<p>internal
structure</p>
</td></tr>
<tr><td><code id="nlar_+3A_...">...</code></td>
<td>
<p>further model specific fields</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Constructor for the generic <code>nlar</code> model class. On a fitted object you
can call some generic methods. For a list of them, see
<code><a href="#topic+nlar-methods">nlar-methods</a></code>.
</p>
<p>An object of the <code>nlar</code> class is a list of (at least) components:
</p>
 <dl>
<dt>str</dt><dd> <p><code><a href="#topic+nlar.struct">nlar.struct</a></code> object, encapsulating
general infos such as time series length, embedding parameters, forecasting
steps, model design matrix </p>
</dd> <dt>coefficients</dt><dd><p> a named vector of model
estimated/fixed coefficients </p>
</dd> <dt>k</dt><dd><p> total number of estimated
coefficients </p>
</dd> <dt>fitted.values</dt><dd><p> model fitted values </p>
</dd> <dt>residuals</dt><dd>
<p>model residuals </p>
</dd> <dt>model</dt><dd><p> data frame containing the variables used </p>
</dd>
<dt>model.specific</dt><dd><p> (optional) model specific additional infos</p>
</dd> </dl>

<p>A <code><a href="#topic+nlar">nlar</a></code> object normally should also have a model-specific
subclass (i.e., <code>nlar</code> is a virtual class).
</p>
<p>Each subclass should define at least a <code>print</code> and, hopefully, a
<code>oneStep</code> method, which is used by <code><a href="#topic+predict.nlar">predict.nlar</a></code> to
iteratively extend ahead the time series.
</p>


<h3>Value</h3>

<p>An object of class <code>nlar</code>. <a href="#topic+nlar-methods">nlar-methods</a> for a list of
available methods.
</p>


<h3>Author(s)</h3>

<p>Antonio, Fabio Di Narzo
</p>


<h3>References</h3>

<p>Non-linear time series models in empirical finance, Philip Hans
Franses and Dick van Dijk, Cambridge: Cambridge University Press (2000).
</p>
<p>Non-Linear Time Series: A Dynamical Systems Approach, Tong, H., Oxford:
Oxford University Press (1990).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+availableModels">availableModels</a></code> for currently available built-in
models.  <a href="#topic+nlar-methods">nlar-methods</a> for available <code>nlar</code> methods.
</p>

<hr>
<h2 id='nlar-methods'>NLAR methods</h2><span id='topic+nlar-methods'></span><span id='topic+coef.nlar'></span><span id='topic+fitted.nlar'></span><span id='topic+residuals.nlar'></span><span id='topic+deviance.nlar'></span><span id='topic+mse.nlar'></span><span id='topic+AIC.nlar'></span><span id='topic+BIC.nlar'></span><span id='topic+MAPE.nlar'></span><span id='topic+summary.nlar'></span><span id='topic+plot.nlar'></span><span id='topic+toLatex.nlar'></span>

<h3>Description</h3>

<p>Generic &lsquo;nlar&rsquo; methods. Method &lsquo;nlar&rsquo; is described in a
separate page: <code><a href="#topic+nlar">nlar</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nlar'
coef(object, ...)

## S3 method for class 'nlar'
fitted(object, ...)

## S3 method for class 'nlar'
residuals(object, initVal = TRUE, timeAttr = TRUE, ...)

## S3 method for class 'nlar'
deviance(object, ...)

## S3 method for class 'nlar'
mse(object, ...)

## S3 method for class 'nlar'
AIC(object, k = 2, ...)

## S3 method for class 'nlar'
BIC(object, ...)

## S3 method for class 'nlar'
MAPE(object, ...)

## S3 method for class 'nlar'
summary(object, ...)

## S3 method for class 'nlar'
plot(x, ask = interactive(), ...)

## S3 method for class 'nlar'
toLatex(object, digits, label, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nlar-methods_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to and from other methods</p>
</td></tr>
<tr><td><code id="nlar-methods_+3A_initval">initVal</code></td>
<td>
<p>Whether to return NA for initial values in residuals/predicitons etc</p>
</td></tr>
<tr><td><code id="nlar-methods_+3A_timeattr">timeAttr</code></td>
<td>
<p>Whether the time attributes should be returned in the output</p>
</td></tr>
<tr><td><code id="nlar-methods_+3A_k">k</code></td>
<td>
<p>numeric, the penalty per parameter to be used for AIC/BIC; the default k = 2 is
the classical AIC</p>
</td></tr>
<tr><td><code id="nlar-methods_+3A_x">x</code>, <code id="nlar-methods_+3A_object">object</code></td>
<td>
<p>fitted &lsquo;nlar&rsquo; object</p>
</td></tr>
<tr><td><code id="nlar-methods_+3A_ask">ask</code></td>
<td>
<p>graphical option. See <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
<tr><td><code id="nlar-methods_+3A_digits">digits</code></td>
<td>
<p>For print method, see <code><a href="stats.html#topic+printCoefmat">printCoefmat</a></code>.</p>
</td></tr>
<tr><td><code id="nlar-methods_+3A_label">label</code></td>
<td>
<p>LaTeX label passed to the equation</p>
</td></tr>
</table>


<h3>Details</h3>

 
<dl>
<dt>MAPE</dt><dd><p> Mean Absolute Percent Error </p>
</dd> 
<dt>mse</dt><dd><p> Mean Square Error </p>
</dd> 
<dt>plot</dt><dd><p> Diagnostic plots </p>
</dd> </dl>



<h3>Author(s)</h3>

<p>Antonio, Fabio Di Narzo
</p>


<h3>See Also</h3>

<p><code><a href="#topic+availableModels">availableModels</a></code> for listing all currently available
models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- log10(lynx)
mod.setar &lt;- setar(x, m=2, thDelay=1, th=3.25)
mod.setar
AIC(mod.setar)
mse(mod.setar)
MAPE(mod.setar)
coef(mod.setar)
summary(mod.setar)

e &lt;- residuals(mod.setar)
e &lt;- e[!is.na(e)]
plot(e)
acf(e)

plot(x)
lines(fitted(mod.setar), lty=2)
legend(x=1910, y=3.9,lty=c(1,2), legend=c("observed","fitted"))

plot(mod.setar)

</code></pre>

<hr>
<h2 id='nlar.struct'>NLAR common structure</h2><span id='topic+nlar.struct'></span><span id='topic+nlar.struct-methods'></span><span id='topic+getXXYY'></span><span id='topic+getXX'></span><span id='topic+getYY'></span><span id='topic+getNUsed'></span>

<h3>Description</h3>

<p>NLAR common structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nlar.struct(x, m, d=1, steps=d, series)
getXXYY(obj, ...)
getXX(obj, ...)
getYY(obj, ...)
getNUsed(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nlar.struct_+3A_x">x</code></td>
<td>
<p>time series</p>
</td></tr>
<tr><td><code id="nlar.struct_+3A_m">m</code>, <code id="nlar.struct_+3A_d">d</code>, <code id="nlar.struct_+3A_steps">steps</code></td>
<td>
<p>embedding dimension, time delay and forecasting steps</p>
</td></tr>
<tr><td><code id="nlar.struct_+3A_series">series</code></td>
<td>
<p>(optional) time series name</p>
</td></tr>
<tr><td><code id="nlar.struct_+3A_obj">obj</code></td>
<td>
<p><code>nlar.struct</code> object</p>
</td></tr>
<tr><td><code id="nlar.struct_+3A_...">...</code></td>
<td>
<p>arguments to be passed to and from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>nlar.struct</code> builds an object of class <code>nlar.struct</code>, from which common NLAR models infos can be extracted using:
</p>
<table>
<tr><td><code>getXXYY</code></td>
<td>
<p>design matrix</p>
</td></tr>
<tr><td><code>getXX</code></td>
<td>
<p>regressor matrix</p>
</td></tr>
<tr><td><code>getYY</code></td>
<td>
<p>response matrix</p>
</td></tr>
<tr><td><code>getNUsed</code></td>
<td>
<p>original time series length</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Antonio, Fabio Di Narzo </p>

<hr>
<h2 id='NNET'>Neural Network nonlinear autoregressive model</h2><span id='topic+NNET'></span><span id='topic+nnetTs'></span>

<h3>Description</h3>

<p>Neural Network nonlinear autoregressive model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nnetTs(x, m, d = 1, steps = d, series, size, 
	control = list(trace = FALSE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NNET_+3A_x">x</code></td>
<td>
<p> time series </p>
</td></tr>
<tr><td><code id="NNET_+3A_m">m</code>, <code id="NNET_+3A_d">d</code>, <code id="NNET_+3A_steps">steps</code></td>
<td>
<p> embedding dimension, time delay, forecasting steps </p>
</td></tr>
<tr><td><code id="NNET_+3A_series">series</code></td>
<td>
<p> time series name (optional) </p>
</td></tr>
<tr><td><code id="NNET_+3A_size">size</code></td>
<td>
<p>number of hidden units in the neural network</p>
</td></tr>
<tr><td><code id="NNET_+3A_control">control</code></td>
<td>
<p>control list to be passed to <code>nnet::nnet</code> optimizer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Neural network model with 1 hidden layer and linear output:
</p>
<p style="text-align: center;"><code class="reqn">x_{t+s} = \beta_0 + \sum_{j=1}^D \beta_j g( \gamma_{0j} +
    \sum_{i=1}^{m} \gamma_{ij} x_{t-(i-1) d} )</code>
</p>

<p>Model is estimated using the <code><a href="nnet.html#topic+nnet">nnet</a></code> function in <span class="pkg">nnet</span>
package. Optimization is done via the BFGS method of
<code><a href="stats.html#topic+optim">optim</a></code>. Note that for this model, no additional
model-specific summary and plot methods are made available from this package.
</p>


<h3>Value</h3>

<p>An object of class <code>nlar</code>, subclass <code>nnetTs</code>, i.e. a list
with mostly <code>nnet::nnet</code> internal structures.
</p>


<h3>Author(s)</h3>

<p> Antonio, Fabio Di Narzo </p>


<h3>References</h3>

<p>Non-linear time series models in empirical finance, Philip Hans Franses and Dick van Dijk, Cambridge: Cambridge University Press (2000).
</p>
<p>Non-Linear Time Series: A Dynamical Systems Approach, Tong, H., Oxford: Oxford University Press (1990).
</p>
<p>Chaos: A Statistical Perspective, Chan, K., Tong, H., New York: Springer-Verlag (2001).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#fit a Neural Network model
mod.nnet &lt;- nnetTs(log(lynx), m=2, size=3)
mod.nnet
</code></pre>

<hr>
<h2 id='oneStep'>oneStep</h2><span id='topic+oneStep'></span>

<h3>Description</h3>

<p>Doing one step forward within a <code>NLAR</code> model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oneStep(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oneStep_+3A_object">object</code></td>
<td>
<p>fitted &lsquo;nlar&rsquo; object</p>
</td></tr>
<tr><td><code id="oneStep_+3A_newdata">newdata</code></td>
<td>
<p>data from which to step forward</p>
</td></tr>
<tr><td><code id="oneStep_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to and from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If in <code>object</code> is encapsulated the <code>NLAR</code> map, say, <code>F(X[t],
X[t-d], ..., X[t-(m-1)d])</code>, this function should return the value of <code>F</code>
(with already fitted parameters) applied to given new data, which can be a
single vector of length <code>m</code> or a matrix with <code>m</code> columns.
</p>


<h3>Value</h3>

<p>Computed value(s)
</p>


<h3>Note</h3>

<p>This is an internal function, and should not be called by the user
</p>


<h3>Author(s)</h3>

<p>Antonio, Fabio Di Narzo
</p>

<hr>
<h2 id='plot+20methods'>Plotting methods for SETAR and LSTAR subclasses</h2><span id='topic+plot-methods'></span><span id='topic+plot.setar'></span><span id='topic+plot.lstar'></span>

<h3>Description</h3>

<p>Plotting methods &lsquo;setar&rsquo; and &lsquo;lstar&rsquo; subclasses
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'setar'
plot(x, ask=interactive(), legend=FALSE, regSwStart, regSwStop, ...)
## S3 method for class 'lstar'
plot(x, ask=interactive(), legend=FALSE, regSwStart, regSwStop, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B20methods_+3A_x">x</code></td>
<td>
<p> fitted &lsquo;setar&rsquo; or &lsquo;lstar&rsquo; object </p>
</td></tr>
<tr><td><code id="plot+2B20methods_+3A_ask">ask</code></td>
<td>
<p> graphical option. See <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
<tr><td><code id="plot+2B20methods_+3A_legend">legend</code></td>
<td>
<p> Should a legend be plotted? (logical)</p>
</td></tr>
<tr><td><code id="plot+2B20methods_+3A_regswstart">regSwStart</code>, <code id="plot+2B20methods_+3A_regswstop">regSwStop</code></td>
<td>
<p> optional starting and stopping time indices for regime
switching plot </p>
</td></tr>
<tr><td><code id="plot+2B20methods_+3A_...">...</code></td>
<td>
<p> further arguments to be passed to and from other methods </p>
</td></tr>
</table>


<h3>Details</h3>

<p>These plot methods produce a plot which gives to you an idea of the behaviour of the fitted model.
</p>
<p>Firstly, if embedding dimension is, say, <var>m</var>, <var>m</var> scatterplots are
produced. On the x axis you have the lagged time series values. On the y
axis the &lsquo;response&rsquo; time series values. Observed points are
represented with different colors-symbols depending on the level of the
threshold variable. Specifically, for the setar model, black means
&lsquo;low regime&rsquo;, red means &lsquo;high regime&rsquo;. For the lstar
model, where the self-threshold variable is continuous, threshold values
are grouped in 5 different zones with the same number of points in
each. Note that if more than 300 points are to be plotted, they all
share the same symbol, and regimes can be distinguished only by
color. If you want, by specifying <code>legend=TRUE</code> a legend is added
at the upper-left corner of each scatterplot. To each scatterplot, a
dashed line is superposed,
which links subsequent fitted values.
</p>
<p>Finally, a new time series plot is produced, with lines segments
coloured depending on the regime (colors meanings are the same of those
in the preceding scatterplots). Optionally, you can specify a starting
and ending time indices, for zooming on a particular segment of the
time series.
</p>


<h3>Author(s)</h3>

<p> Antonio, Fabio Di Narzo </p>


<h3>See Also</h3>

<p><code><a href="#topic+setar">setar</a></code>, <code><a href="#topic+lstar">lstar</a></code>
</p>
<p><a href="#topic+nlar-methods">nlar-methods</a> for other generic available methods for this kind of objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
##See 'setar' examples
##
</code></pre>

<hr>
<h2 id='plot_ECT'>Plot the Error Correct Term (ECT) response</h2><span id='topic+plot_ECT'></span>

<h3>Description</h3>

<p>This plot shows how variables in a (T)VECM respond to deviations from the long-term equilibrium
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_ECT(x, add.legend = TRUE, legend.location = "topright", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_ECT_+3A_x">x</code></td>
<td>
<p>object of class <code><a href="#topic+VECM">VECM</a></code> or <code><a href="#topic+TVECM">TVECM</a></code></p>
</td></tr>
<tr><td><code id="plot_ECT_+3A_add.legend">add.legend</code></td>
<td>
<p>logical. Whether to add a legend?</p>
</td></tr>
<tr><td><code id="plot_ECT_+3A_legend.location">legend.location</code></td>
<td>
<p>character. Location of the legend, see <code><a href="graphics.html#topic+legend">legend</a></code></p>
</td></tr>
<tr><td><code id="plot_ECT_+3A_...">...</code></td>
<td>
<p>arguments passed to the initial <code>plot</code> call, see <code><a href="graphics.html#topic+plot">plot</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plot, and invisibly the underlying data.frame, containing the ECT and the response for each variable
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(zeroyld)
vec_l1 &lt;- VECM(zeroyldMeta[, c("long.run", "short.run")], lag =1)
tvec_l1 &lt;- TVECM(zeroyldMeta[, c("long.run", "short.run")], lag =1, 
                plot  = FALSE, trace = FALSE, th1 = list(exact = -1.263))

plot_ECT(vec_l1)
plot_ECT(tvec_l1, legend.location = "bottomright")
</code></pre>

<hr>
<h2 id='predict_rolling'>Rolling forecasts</h2><span id='topic+predict_rolling'></span><span id='topic+predict_rolling.nlVar'></span>

<h3>Description</h3>

<p>Forecasts a VAR or VECM by discarding a part of the sample, and recursively generating a
series of updated forecasts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_rolling(object, ...)

## S3 method for class 'nlVar'
predict_rolling(object, nroll = 10, n.ahead = 1, refit.every, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_rolling_+3A_object">object</code></td>
<td>
<p>A linear object of class &lsquo;<code>nlVar</code>&rsquo;; generated by
<code><a href="#topic+lineVar">lineVar</a></code> or <code><a href="#topic+VECM">VECM</a></code>.</p>
</td></tr>
<tr><td><code id="predict_rolling_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="predict_rolling_+3A_nroll">nroll</code></td>
<td>
<p>The number of rolling forecasts</p>
</td></tr>
<tr><td><code id="predict_rolling_+3A_n.ahead">n.ahead</code></td>
<td>
<p>An integer specifying the number of forecast steps.</p>
</td></tr>
<tr><td><code id="predict_rolling_+3A_refit.every">refit.every</code></td>
<td>
<p>Determines every how many periods the model is
re-estimated.</p>
</td></tr>
<tr><td><code id="predict_rolling_+3A_newdata">newdata</code></td>
<td>
<p>In case the given model is already estimated on the
sub-sample, the out-of-sample data can be provided with this argument. Note it should contain
observations to predict the first values, that are also contained in the
in-sample.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows to check the out-of sample forecasting accuracy by
estimating the model on a sub-sample of the original, then making
<code>nroll</code> forecasts of horizon <code>n.ahead</code>, each time by updating the
sample. In other words, with a given model estimated on 100 observations, the
function will estimate it on say 90 first obs (<code>nroll=10</code>), generate a
say 1 step-ahead (<code>n.ahead=1</code>) from obs 90, then using true value 91 for 
to predict value at 92, etc, till the full sample is used.  
</p>
<p>Unlike with usual <code>predict()</code> methods, specifiying <code>n.ahead=2</code> will
not generate a 1 step-ahead and a 2 step-ahead forecasts, but only
<code>nroll</code> 2 step-ahead forecasts.
</p>
<p>Note that while the forecasts are updated with new values, the model
estimation is (by default) not updated. This can however be done with the
argument <code>fit.every</code>, specifiying at which frequency the model should be
re-estimated. By setting it to 1 for example, each time a new observation is
taken, the model is reestimated. This is similar to the
<code><a href="rugarch.html#topic+ugarchroll">ugarchroll</a></code> in package <span class="pkg">rugarch</span>.
</p>


<h3>Value</h3>

<p>A matrix containing the forecasts.
</p>


<h3>Author(s)</h3>

<p>Matthieu Stigler
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.nlar">predict.nlar</a></code> for the standard predict function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(barry)

## model estimated on full sample:
mod_vec &lt;- VECM(barry, lag=2)

## generate 10 1-step-ahead forecasts:
preds_roll &lt;- predict_rolling(mod_vec, nroll=10)

## plot the results:
plot(window(barry[,"dolcan"],start=1998), type="l", ylab="barry: dolcan")
preds_roll_ts &lt;- ts(preds_roll$pred, start=time(barry)[nrow(barry)-10], freq=12)
lines(preds_roll_ts[,"dolcan"], col=2, lty=2)
legend("bottomright", lty=c(1,2), col=1:2, leg=c("True", "Fitted"))
title("Comparison of true and rolling 1-ahead forecasts\n")


</code></pre>

<hr>
<h2 id='predict.nlar'>Predict method for objects of class &lsquo;<code>nlar</code>&rsquo;.</h2><span id='topic+predict.nlar'></span><span id='topic+predict'></span>

<h3>Description</h3>

<p>Forecasting a non-linear model object of general class &lsquo;<code>nlar</code>&rsquo;,
including &lsquo;<code>setar</code>&rsquo; and &lsquo;<code>star</code>&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nlar'
predict(
  object,
  newdata,
  n.ahead = 1,
  type = c("naive", "MC", "bootstrap", "block-bootstrap"),
  nboot = 100,
  ci = 0.95,
  block.size = 3,
  boot1Zero = TRUE,
  seed = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.nlar_+3A_object">object</code></td>
<td>
<p>An object of class &lsquo;<code>nlar</code>&rsquo;; generated by
<code>setar()</code> or <code>lstar()</code>.</p>
</td></tr>
<tr><td><code id="predict.nlar_+3A_newdata">newdata</code></td>
<td>
<p>Optional. A new data frame to predict from.</p>
</td></tr>
<tr><td><code id="predict.nlar_+3A_n.ahead">n.ahead</code></td>
<td>
<p>An integer specifying the number of forecast steps.</p>
</td></tr>
<tr><td><code id="predict.nlar_+3A_type">type</code></td>
<td>
<p>Type of forecasting method used. See details.</p>
</td></tr>
<tr><td><code id="predict.nlar_+3A_nboot">nboot</code></td>
<td>
<p>The number of replications for type MC or bootstrap.</p>
</td></tr>
<tr><td><code id="predict.nlar_+3A_ci">ci</code></td>
<td>
<p>The forecast confidence interval (available only with types MC and
bootstrap).</p>
</td></tr>
<tr><td><code id="predict.nlar_+3A_block.size">block.size</code></td>
<td>
<p>The block size when the block-bootstrap is used.</p>
</td></tr>
<tr><td><code id="predict.nlar_+3A_boot1zero">boot1Zero</code></td>
<td>
<p>Whether the first innovation for MC/bootstrap should be set
to zero.</p>
</td></tr>
<tr><td><code id="predict.nlar_+3A_seed">seed</code></td>
<td>
<p>optional, the seed for the random generation.</p>
</td></tr>
<tr><td><code id="predict.nlar_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the internal &lsquo;<code>oneStep</code>&rsquo; function. 
Mainly argument &lsquo;<code>thVar</code>&rsquo; if an external threshold variable was provided</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The forecasts are obtained recursively from the estimated model.  Given that
the models are non-linear, ignoring the residuals in the 2- and more steps
ahead forecasts leads to biased forecasts (so-called naive).  Different
resampling methods, averaging <code>n.boot</code> times over future residuals, are
available:
</p>
 <dl>
<dt>naive</dt><dd><p>No residuals</p>
</dd> <dt>MC</dt><dd><p>Monte-Carlo method, where
residuals are taken from a normal distribution, with a standard deviation equal to the
residuals sd. </p>
</dd> <dt>bootstrap</dt><dd><p>Residuals are resampled from the empirical
residuals from the model.</p>
</dd> <dt>block-bootstrap</dt><dd><p>Same as bootstrap, but
residuals are resampled in block, with size <code>block.size</code></p>
</dd> </dl>

<p>The <code>MC</code> and <code>bootstrap</code> methods correspond to equations 3.90 and
3.91 of Franses and van Dijk (2000, p. 121).  The bootstrap/MC is initiated
either from the first forecast, <code>n.ahead</code>=1 (set with <code>boot1zero</code>
to TRUE), or from the second only.
</p>
<p>When the forecast method is based on resampling, forecast intervals are
available. These are obtained simply as empirical <code>ci</code> quantiles of the
resampled forecasts (cf Method 2 in Franses and van Dijk, 2000, p. 122).
</p>


<h3>Value</h3>

<p>A &lsquo;<code>ts</code>&rsquo; object, or, in the case of MC/bootstrap, a list
containing the prediction (pred) and the forecast standard errors
(<code>se</code>).
</p>


<h3>Author(s)</h3>

<p>Matthieu Stigler
</p>


<h3>References</h3>

<p>Non-linear time series models in empirical finance, Philip Hans
Franses and Dick van Dijk, Cambridge: Cambridge University Press (2000).
</p>


<h3>See Also</h3>

<p>The model fitting functions <code><a href="#topic+setar">setar</a></code>,
<code><a href="#topic+lstar">lstar</a></code>. 
</p>
<p>A more sophisticated predict function, allowing to do sub-sample rolling
predictions: <code><a href="#topic+predict_rolling">predict_rolling</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

x.train &lt;- window(log10(lynx), end = 1924)
x.test &lt;- window(log10(lynx), start = 1925)


### Use different forecasting methods:
mod.set &lt;- setar(x.train, m=2, thDelay=0)
pred_setar_naive &lt;- predict(mod.set, n.ahead=10)
pred_setar_boot &lt;- predict(mod.set, n.ahead=10, type="bootstrap", n.boot=200)
pred_setar_Bboot &lt;- predict(mod.set, n.ahead=10, type="block-bootstrap", n.boot=200)
pred_setar_MC &lt;- predict(mod.set, n.ahead=10, type="bootstrap", n.boot=200)

## Plot to compare results:
pred_range &lt;- range(pred_setar_naive, pred_setar_boot$pred, pred_setar_MC$pred, na.rm=TRUE)
plot(x.test, ylim=pred_range, main="Comparison of forecasts methods from same SETAR")
lines(pred_setar_naive, lty=2, col=2)
lines(pred_setar_boot$pred, lty=3, col=3)
lines(pred_setar_Bboot$pred, lty=4, col=4)
lines(pred_setar_MC$pred, lty=5, col=5)

legLabels &lt;- c("Observed", "Naive F", "Bootstrap F","Block-Bootstrap F", "MC F")
legend("bottomleft", leg=legLabels, lty=1:5, col=1:5)

</code></pre>

<hr>
<h2 id='predict.TVAR'>Predict method for objects of class &lsquo;<code>VAR</code>&rsquo;, &lsquo;<code>VECM</code>&rsquo; or &lsquo;<code>TVAR</code>&rsquo;</h2><span id='topic+predict.TVAR'></span><span id='topic+predict.VAR'></span><span id='topic+predict.VECM'></span>

<h3>Description</h3>

<p>Forecasting the <strong>level</strong> of a series estimated by  &lsquo;<code>VAR</code>&rsquo; / &lsquo;<code>VECM</code>&rsquo; or &lsquo;<code>TVAR</code>&rsquo;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'TVAR'
predict(object, newdata, n.ahead = 5, newdataTrendStart, ...)

## S3 method for class 'VAR'
predict(object, newdata, n.ahead = 5, newdataTrendStart, exoPred = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.TVAR_+3A_object">object</code></td>
<td>
<p>An object of class  &lsquo;<code>VAR</code>&rsquo;, &lsquo;<code>VECM</code>&rsquo; or &lsquo;<code>TVAR</code>&rsquo;</p>
</td></tr>
<tr><td><code id="predict.TVAR_+3A_newdata">newdata</code></td>
<td>
<p>Optional. A new data frame to predict from. 
This should contain lags of the level of the original series. See Details.</p>
</td></tr>
<tr><td><code id="predict.TVAR_+3A_n.ahead">n.ahead</code></td>
<td>
<p>An integer specifying the number of forecast steps.</p>
</td></tr>
<tr><td><code id="predict.TVAR_+3A_newdatatrendstart">newdataTrendStart</code></td>
<td>
<p>If &lsquo;<code>newdata</code>&rsquo; is provided by the user, 
and the estimated model includes a trend, 
this argument specifies where the trend should start</p>
</td></tr>
<tr><td><code id="predict.TVAR_+3A_...">...</code></td>
<td>
<p>Arguments passed to the unexported &lsquo;<code>VAR.gen</code>&rsquo; or &lsquo;<code>TVAR.gen</code>&rsquo; function</p>
</td></tr>
<tr><td><code id="predict.TVAR_+3A_exopred">exoPred</code></td>
<td>
<p>vector/matrix of predictions for the exogeneous variable(s) (with &lsquo;<code>n.ahead</code>&rsquo; rows).
Only for &lsquo;<code>VAR</code>&rsquo;/&lsquo;<code>VECM</code>&rsquo;, not for &lsquo;<code>TVAR</code>&rsquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The forecasts are obtained recursively, and are for the levels of the series.  
</p>
<p>When providing newdata, newdata has to be ordered chronologically, 
so that the first row/element is the earliest value. 
</p>
<p>For VECM, the forecasts are obtained by transforming the VECM to a VAR (using function <code><a href="#topic+VARrep">VARrep</a></code>). 
Note that a VECM(lag=p) corresponds to a VAR(lag=p+1), so that if the user provides newdata 
for a VECM(lag=p), newdata should actually contain p+1 rows.
</p>


<h3>Value</h3>

<p>A matrix of predicted values.
</p>


<h3>Author(s)</h3>

<p>Matthieu Stigler
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lineVar">lineVar</a></code> and <code><a href="#topic+VECM">VECM</a></code>. <code><a href="#topic+VARrep">VARrep</a></code>
</p>
<p>A more sophisticated predict function, allowing to do sub-sample rolling
predictions: <code><a href="#topic+predict_rolling">predict_rolling</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(barry)
barry_in &lt;- head(barry, -5)
barry_out &lt;- tail(barry, 5)

mod_vecm &lt;- VECM(barry_in, lag=2)
mod_var &lt;- lineVar(barry_in, lag=3)
mod_tvar &lt;- TVAR(barry_in, lag=3, nthresh=1, thDelay=1)

pred_vecm &lt;- predict(mod_vecm)
pred_var  &lt;- predict(mod_var) 
pred_tvar &lt;- predict(mod_tvar)

 
## compare forecasts on a plot
n &lt;- 30
plot(1:n, tail(barry[,1], n), type="l", xlim=c(0,n))
lines((n-5+1):n, pred_var[,1], lty=2, col=2)
lines((n-5+1):n, pred_vecm[,1], lty=2, col=3)
lines((n-5+1):n, pred_tvar[,1], lty=2, col=4) 
legend("bottomright", lty=c(1,2,2,2), col=1:4, legend=c("true", "var", "vecm", "tvar"))

## example for newdata:
all.equal(predict(mod_vecm), predict(mod_vecm, newdata=barry[c(317, 318, 319),]))
</code></pre>

<hr>
<h2 id='rank.select'>Selection of the cointegrating rank with Information criterion.</h2><span id='topic+rank.select'></span><span id='topic+summary.rank.select'></span><span id='topic+print.rank.select'></span><span id='topic+as.data.frame.rank.select'></span>

<h3>Description</h3>

<p>Selection of the cointegrating rank and the lags with Information criterion
(AIC, BIC).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rank.select(
  data,
  lag.max = 10,
  r.max = ncol(data) - 1,
  include = c("const", "trend", "none", "both"),
  fitMeasure = c("SSR", "LL"),
  sameSample = TRUE,
  returnModels = FALSE
)

## S3 method for class 'rank.select'
print(x, ...)

## S3 method for class 'rank.select'
as.data.frame(x, ...)

## S3 method for class 'rank.select'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rank.select_+3A_data">data</code></td>
<td>
<p>multivariate time series.</p>
</td></tr>
<tr><td><code id="rank.select_+3A_lag.max">lag.max</code></td>
<td>
<p>Maximum number of lags to investigate.</p>
</td></tr>
<tr><td><code id="rank.select_+3A_r.max">r.max</code></td>
<td>
<p>Maximum rank to investigate.</p>
</td></tr>
<tr><td><code id="rank.select_+3A_include">include</code></td>
<td>
<p>Type of deterministic regressors to include. See
<code><a href="#topic+VECM">VECM</a></code> or <code><a href="#topic+lineVar">lineVar</a></code>.</p>
</td></tr>
<tr><td><code id="rank.select_+3A_fitmeasure">fitMeasure</code></td>
<td>
<p>Whether the AIC/BIC should be based on the full likelihood,
or just the SSR. See explanations in <code><a href="#topic+logLik.VECM">logLik.VECM</a></code>.</p>
</td></tr>
<tr><td><code id="rank.select_+3A_samesample">sameSample</code></td>
<td>
<p>Logical. Whether the data should be shortened so that the
AIC/BIC are estimated on the same sample. Default to TRUE.</p>
</td></tr>
<tr><td><code id="rank.select_+3A_returnmodels">returnModels</code></td>
<td>
<p>Logical, default to FALSE. Whether the output should also
contain the list of each model computed.</p>
</td></tr>
<tr><td><code id="rank.select_+3A_x">x</code></td>
<td>
<p>The output from <code>rank.select</code> for the print method.</p>
</td></tr>
<tr><td><code id="rank.select_+3A_...">...</code></td>
<td>
<p>Unused.</p>
</td></tr>
<tr><td><code id="rank.select_+3A_object">object</code></td>
<td>
<p>The output from <code>rank.select</code> for the summary method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function estimates the AIC, BIC and Hannan-Quinn for each rank (up to
<code>lags.max</code>) and lags (up to <code>lags.max</code>). This method has been shown
to be useful to select simultaneously the rank and the lags, see references.
</p>


<h3>Value</h3>

<p>An object of class &lsquo;rank.select&rsquo;, with &lsquo;print&rsquo; and
&lsquo;summary methods&rsquo;, containing among other the matrices of AIC/BIC/HQ,
the Likelihood, and best ranks according to each criterion.
</p>


<h3>Author(s)</h3>

<p>Matthieu Stigler
</p>


<h3>References</h3>

<p>- Aznar A and Salvador M (2002). Selecting The Rank Of The
Cointegration Space And The Form Of The Intercept Using An Information
Criterion. Econometric Theory, *18*(04), pp. 926-947. &lt;URL:
http://ideas.repec.org/a/cup/etheor/v18y2002i04p926-947_18.html&gt;.
</p>
<p>-Cheng X and Phillips PCB (2009). Semiparametric cointegrating rank
selection. Econometrics Journal , *12*(s1), pp. S83-S104. &lt;URL:
http://ideas.repec.org/a/ect/emjrnl/v12y2009is1ps83-s104.html&gt;.
</p>
<p>- Gonzalo J and Pitarakis J (1998). Specification via model selection in
vector error correction models. Economics Letters, *60*(3), pp. 321 - 328.
ISSN 0165-1765, &lt;URL: http://dx.doi.org/DOI: 10.1016/S0165-1765(98)00129-3&gt;.
</p>
<p>- Kapetanios G (2004). The Asymptotic Distribution Of The Cointegration Rank
Estimator Under The Akaike Information Criterion. Econometric Theory,
*20*(04), pp. 735-742. &lt;URL:
http://ideas.repec.org/a/cup/etheor/v20y2004i04p735-742_20.html&gt;.
</p>
<p>- Wang Z and Bessler DA (2005). A Monte Carlo Study On The Selection Of
Cointegrating Rank Using Information Criteria. Econometric Theory, *21*(03),
pp. 593-620. &lt;URL:
http://ideas.repec.org/a/cup/etheor/v21y2005i03p593-620_05.html&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VECM">VECM</a></code> for estimating a VECM. <code><a href="#topic+rank.test">rank.test</a></code>
(or <code><a href="urca.html#topic+ca.jo">ca.jo</a></code> in package <span class="pkg">urca</span>) for the classical
Johansen cointegration test.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(barry)

# 
rk_sel &lt;- rank.select(barry)
rk_sel
summary(rk_sel)


</code></pre>

<hr>
<h2 id='rank.test'>Test of the cointegrating rank</h2><span id='topic+rank.test'></span><span id='topic+summary.rank.test'></span><span id='topic+print.rank.test'></span>

<h3>Description</h3>

<p>Maximum-likelihood test of the cointegrating rank.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rank.test(vecm, type = c("eigen", "trace"), r_null, cval = 0.05)

## S3 method for class 'rank.test'
print(x, ...)

## S3 method for class 'rank.test'
summary(object, digits = max(1, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rank.test_+3A_vecm">vecm</code></td>
<td>
<p>&lsquo;VECM&rsquo; object computed with the function
<code><a href="#topic+VECM">VECM</a></code>.</p>
</td></tr>
<tr><td><code id="rank.test_+3A_type">type</code></td>
<td>
<p>Type of test, either 'trace' or 'eigenvalue'. See details below.</p>
</td></tr>
<tr><td><code id="rank.test_+3A_r_null">r_null</code></td>
<td>
<p>Rank to test specifically.</p>
</td></tr>
<tr><td><code id="rank.test_+3A_cval">cval</code></td>
<td>
<p>Critical value level for the automatic test.</p>
</td></tr>
<tr><td><code id="rank.test_+3A_x">x</code></td>
<td>
<p>The output from <code>rank.test</code> for the print method.</p>
</td></tr>
<tr><td><code id="rank.test_+3A_...">...</code></td>
<td>
<p>Unused.</p>
</td></tr>
<tr><td><code id="rank.test_+3A_object">object</code></td>
<td>
<p>The output from <code>rank.test</code> for the summary method.</p>
</td></tr>
<tr><td><code id="rank.test_+3A_digits">digits</code></td>
<td>
<p>The number of digits to use in <code><a href="base.html#topic+format.pval">format.pval</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the two maximum-likelihood tests for the cointegration
rank from Johansen (1996). Tests are: </p>
 <dl>
<dt>trace</dt><dd><p>Test the
hypothesis of rank &lsquo;h&rsquo; against rank &lsquo;K&rsquo;, i.e. against the
alternative that the system is stationary.</p>
</dd> <dt>eigenvalue</dt><dd><p>Test the
hypothesis of rank &lsquo;h&rsquo; against rank &lsquo;h+1&rsquo;.</p>
</dd> </dl>

<p>The test works for five specifications of the deterministic terms as in
Doornik et al (1998), to be specified in the previous call to
<code><a href="#topic+VECM">VECM</a></code>: </p>
 <dl>
<dt>H_ql</dt><dd><p>Unrestricted constant and trend:
use <code>include="both"</code> </p>
</dd> <dt>H_l</dt><dd><p>Unrestricted constant and restricted
trend: use <code>include="const"</code></p>
</dd></dl>
<p> and <code>LRinclude="trend"</code>
</p>
<dl>
<dt>H_lc</dt><dd><p>Unrestricted constant and no trend: use <code>include="const"</code></p>
</dd>
<dt>H_c</dt><dd><p>Restricted constant and no trend: use <code>LRinclude="const"</code></p>
</dd>
<dt>H_z</dt><dd><p>No constant nor trend: use <code>include="none"</code></p>
</dd> </dl>

<p>Two testing procedures can be used: </p>
 <dl>
<dt>Specific test</dt><dd><p>By
specifying a value for &lsquo;r_null&rsquo;. The &lsquo;pval&rsquo; value returned
gives the speciifc p-value.</p>
</dd> <dt>Automatic test</dt><dd><p>If not value is specified
for &lsquo;r_null&rsquo;, the function makes a simple automatic test: returns the
rank (slot &lsquo;r&rsquo;) of the first test not rejected (level specified by arg
<code>cval</code>) as recommend i.a. in Doornik et al (1998, p. 544).</p>
</dd> </dl>

<p>A full table with both test statistics ad their respective p-values is given
in the summary method.
</p>
<p>P-values are obtained from the gamma approximation from Doornik (1998, 1999).
Small sample values adjusted for the sample site are also available in the
summary method.  Note that the &lsquo;effective sample size&rsquo; for the these
values is different from output in gretl for example.
</p>


<h3>Value</h3>

<p>An object of class &lsquo;rank.test&rsquo;, with &lsquo;print&rsquo; and
&lsquo;summary methods&rsquo;.
</p>


<h3>Comparison with urca</h3>

<p>While <code><a href="urca.html#topic+ca.jo">ca.jo</a></code> in package
<span class="pkg">urca</span> and <code>rank.test</code> both implement Johansen tests, there are a
few differences:
</p>
 <ul>
<li> <p><code>rank.test</code> gives p-values, while <code>ca.jo</code> gives
only critical values.  </p>
</li>
<li> <p><code>rank.test</code> allows for five different
specifications of deterministic terms (see above), <code>ca.jo</code> for only
three.  </p>
</li>
<li> <p><code>ca.jo</code> allows for seasonal and exogenous regressors,
which is not available in <code>rank.test</code>.  </p>
</li>
<li><p> The lag is specified
differently: <code>K</code> from <code>ca.jo</code> corresponds to <code>lag</code>+1 in
<code>rank.test</code>.  </p>
</li></ul>



<h3>Author(s)</h3>

<p>Matthieu Stigler
</p>


<h3>References</h3>

<p>- Doornik, J. A. (1998) Approximations to the Asymptotic
Distributions of Cointegration Tests, Journal of Economic Surveys, 12, 573-93
</p>
<p>- Doornik, J. A. (1999) Erratum [Approximations to the Asymptotic
Distribution of Cointegration Tests], Journal of Economic Surveys, 13, i
</p>
<p>- Doornik, Hendry and Nielsen (1998) Inference in Cointegrating Models: UK M1
Revisited, Journal of Economic Surveys, 12, 533-72
</p>
<p>- Johansen, S. (1996) Likelihood-based inference in cointegrated Vector
Autoregressive Models, Oxford University Press
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VECM">VECM</a></code> for estimating a VECM. <code><a href="#topic+rank.select">rank.select</a></code>
to estimate the rank based on information criteria.
</p>
<p><code><a href="urca.html#topic+ca.jo">ca.jo</a></code> in package <span class="pkg">urca</span> for another implementation of
Johansen cointegration test (see section &lsquo;Comparison with urca&rsquo; for
more infos).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(barry)

## estimate the VECM with Johansen! 
ve &lt;- VECM(barry, lag=1, estim="ML")

## specific test:
ve_test_spec &lt;- rank.test(ve, r_null=1)
ve_test_spec_tr &lt;- rank.test(ve, r_null=1, type="trace")

ve_test_spec
ve_test_spec_tr

## No specific test: automatic method
ve_test_unspec &lt;- rank.test(ve)
ve_test_unspec_tr &lt;- rank.test(ve, type="trace")

ve_test_unspec
ve_test_unspec_tr

## summary method: output will be same for all types/test procedure:
summary(ve_test_unspec_tr)

## The function works for many specification of the VECM(), try:
rank.test(VECM(barry, lag=3, estim="ML"))
rank.test(VECM(barry, lag=3, include="both",estim="ML"))
rank.test(VECM(barry, lag=3, LRinclude="const",estim="ML"))

## Note that the tests are simple likelihood ratio, and hence can be obtained also manually:
-2*(logLik(ve, r=1)-logLik(ve, r=2)) # eigen test, 1 against 2
-2*(logLik(ve, r=1)-logLik(ve, r=3)) # eigen test, 1 against 3

</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+fevd'></span><span id='topic+irf'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>vars</dt><dd><p><code><a href="vars.html#topic+fevd">fevd</a></code>, <code><a href="vars.html#topic+irf">irf</a></code></p>
</dd>
</dl>

<hr>
<h2 id='regime'>Extract a variable showing the regime</h2><span id='topic+regime'></span><span id='topic+regime.default'></span><span id='topic+regime.lstar'></span>

<h3>Description</h3>

<p>This function allows to extract the indicator variable specifying the regime
in which the process is at time t.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regime(object, initVal = TRUE, timeAttr = TRUE, series = NULL, ...)

## S3 method for class 'lstar'
regime(object, initVal = TRUE, timeAttr = TRUE, series, discretize = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regime_+3A_object">object</code></td>
<td>
<p>object of class <code>setar</code> or <code>nlVar</code></p>
</td></tr>
<tr><td><code id="regime_+3A_initval">initVal</code></td>
<td>
<p>Logical. Whether the NA initial values should be returned.
Default to TRUE.</p>
</td></tr>
<tr><td><code id="regime_+3A_timeattr">timeAttr</code></td>
<td>
<p>Logical. Whether the time attributes should be returned.
Default to TRUE.</p>
</td></tr>
<tr><td><code id="regime_+3A_series">series</code></td>
<td>
<p>Optional. A numeric vector to classify according to the model.</p>
</td></tr>
<tr><td><code id="regime_+3A_...">...</code></td>
<td>
<p>additional arguments to <code>regime</code></p>
</td></tr>
<tr><td><code id="regime_+3A_discretize">discretize</code></td>
<td>
<p>logical (default TRUE) whether the series are discretized to {1,2}, 
or whether regime probabilities are returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Time series of same attributes as input to setar.
</p>


<h3>Author(s)</h3>

<p>Matthieu Stigler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set&lt;-setar(lynx, m=3)
regime(set)
regime(set, time=FALSE, initVal=FALSE)

plot(regime(set))

</code></pre>

<hr>
<h2 id='resample_vec'>Resampling schemes</h2><span id='topic+resample_vec'></span>

<h3>Description</h3>

<p>Bootstrap a vector according to multiple resampling schemes: resampling, block resampling, Wild bootstrap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resample_vec(
  x,
  boot.scheme = c("resample", "resample_block", "wild1", "wild2", "check"),
  seed = NULL,
  block.size = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resample_vec_+3A_x">x</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
<tr><td><code id="resample_vec_+3A_boot.scheme">boot.scheme</code></td>
<td>
<p>The type of resampling scheme used, see Details</p>
</td></tr>
<tr><td><code id="resample_vec_+3A_seed">seed</code></td>
<td>
<p>the seed used, see <code><a href="base.html#topic+set.seed">set.seed</a></code></p>
</td></tr>
<tr><td><code id="resample_vec_+3A_block.size">block.size</code></td>
<td>
<p>for the <code>resample_block</code> scheme, the size of the blocks.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function offers various bootstrap/resampling schemes:
</p>

<dl>
<dt>resample</dt><dd><p>Resampling with replacement</p>
</dd>
<dt>resample_block</dt><dd><p>Resampling contiguous observations (blocks) with replacement. Use argument <code>block.size</code></p>
</dd>
<dt>wild1</dt><dd><p>Wild bootstrap: do not resample, but add a N(0,1) distribution to each value</p>
</dd>
<dt>wild12</dt><dd><p>Wild bootstrap: same, but add instead -1 or 1. </p>
</dd>
</dl>


<hr>
<h2 id='resVar'>Residual variance</h2><span id='topic+resVar'></span>

<h3>Description</h3>

<p>Extracts the global and regime-dependent variance of the residuals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resVar(x, adj=c("OLS", "ML"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resVar_+3A_x">x</code></td>
<td>
<p>setar object</p>
</td></tr>
<tr><td><code id="resVar_+3A_adj">adj</code></td>
<td>
<p>Degrees of freedom adjustment for the variance</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The degree of freedom adjustment in the formula for the variance is the number of parameters when <code>adj="OLS"</code> or zero when <code>adj="ML"</code>. 
</p>


<h3>Value</h3>

<p>A vector containing:
</p>
<table>
<tr><td><code>Total</code></td>
<td>
<p>The residual variance of the full sample</p>
</td></tr>
<tr><td><code>L</code>, <code>(M)</code>, <code>H</code></td>
<td>
<p>The residual variance of the lower (L), middle (if two thresholds) (M) and higher (H) regimes</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matthieu Stigler</p>


<h3>References</h3>

<p>Non-Linear Time Series: A Dynamical Systems Approach, Tong, H., Oxford: Oxford University Press (1990).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Lynx model as in Tong (1980, p. 387)
mod.setar &lt;- setar(log10(lynx), mL=7,mH=2, thDelay=1, th=3.116)
summary(mod.setar)
#coefficients are same for lower regime but differ for higer

resVar(mod.setar, adj="ML")
#variance or the residuals is same for lower regime but differ for higer regime and hence for total

#Lynx model as in Tong (1980, p. 405)
mod.setar2 &lt;- setar(log10(lynx), mL=1,mM=7,mH=2, thDelay=1, nthresh=2,th=c(2.373, 3.154))
round(coefficients(mod.setar2),3)

resVar(mod.setar2, adj="ML")


</code></pre>

<hr>
<h2 id='selectHyperParms'>Automatic selection of model hyper-parameters</h2><span id='topic+selectLSTAR'></span><span id='topic+selectNNET'></span>

<h3>Description</h3>

<p>Automatic selection of model hyper-parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selectLSTAR(x, m, d=1, steps=d, mL = 1:m, mH = 1:m, thDelay=0:(m-1), 
            fast=TRUE, trace=FALSE)
selectNNET(x, m, d=1, steps=d, size=1:(m+1), maxit=1e3, trace=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selectHyperParms_+3A_x">x</code></td>
<td>
<p> time series </p>
</td></tr>
<tr><td><code id="selectHyperParms_+3A_m">m</code>, <code id="selectHyperParms_+3A_d">d</code>, <code id="selectHyperParms_+3A_steps">steps</code></td>
<td>
<p> embedding parameters. For their meanings, see help about <code><a href="#topic+nlar">nlar</a></code> </p>
</td></tr>
<tr><td><code id="selectHyperParms_+3A_ml">mL</code>, <code id="selectHyperParms_+3A_mh">mH</code></td>
<td>
<p> Vector of &lsquo;low&rsquo; and &lsquo;high&rsquo; regimes autoregressive orders</p>
</td></tr>
<tr><td><code id="selectHyperParms_+3A_thdelay">thDelay</code></td>
<td>
<p> Vector of &lsquo;threshold delay&rsquo; values</p>
</td></tr>
<tr><td><code id="selectHyperParms_+3A_size">size</code></td>
<td>
<p> Vector of numbers of hidden units in the nnet model </p>
</td></tr>
<tr><td><code id="selectHyperParms_+3A_maxit">maxit</code></td>
<td>
<p> Max. number of iterations for each model estimation </p>
</td></tr>
<tr><td><code id="selectHyperParms_+3A_fast">fast</code></td>
<td>
<p>For LSTAR selection, whether a fast algorithm using starting values fro previous models should be used</p>
</td></tr>
<tr><td><code id="selectHyperParms_+3A_trace">trace</code></td>
<td>
<p>Logical. Whether informations from each model should be returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functions for automatic selection of LSTAR and NNET models hyper parameters. An exhaustive search over all possible combinations of values of specified hyper-parameters is performed.
Embedding parameters <code>m,d,steps</code> are kept fixed.
</p>
<p>Selection criterion is the usual AIC.
</p>
<p>For the LSTAR model, two methods are offered:
</p>

<dl>
<dt>fast=FALSE</dt><dd><p>Each model is run separately, each time using the full grid search for starting values. </p>
</dd>
<dt>fast=TRUE</dt><dd><p>Only the first model is run with a full grid search, while the subsequent use the first model results for their starting values. </p>
</dd>
</dl>



<h3>Value</h3>

<p>A data-frame, with columns giving hyper-parameter values and the
computed AIC for each row (only the best 10s are returned)
</p>


<h3>Author(s)</h3>

<p> Antonio, Fabio Di Narzo </p>


<h3>Examples</h3>

<pre><code class='language-R'>llynx &lt;- log10(lynx)
selectLSTAR(llynx, m=2)
selectNNET(llynx, m=3, size=1:5)
</code></pre>

<hr>
<h2 id='selectSETAR'>Automatic selection of SETAR hyper-parameters</h2><span id='topic+selectSETAR'></span><span id='topic+selectSetar'></span><span id='topic+selectsetar'></span>

<h3>Description</h3>

<p>Automatic selection of SETAR hyper-parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selectSETAR(x, m, d=1, steps=d, series, mL, mH,mM, thDelay=0, mTh, thVar, 
	    th=MakeThSpec(), trace=TRUE, include = c("const", "trend","none", "both"), 
	    common=c("none", "include","lags", "both"), model=c("TAR", "MTAR"), 
	    ML=seq_len(mL), MH=seq_len(mH), MM=seq_len(mM), nthresh=1, trim=0.15,
	    criterion = c("pooled-AIC", "AIC","BIC", "SSR"),  plot=TRUE,
	    max.iter=2, type=c("level", "diff", "ADF"), same.lags=FALSE, 
	    restriction=c("none","OuterSymAll","OuterSymTh"),  hpc=c("none", "foreach") )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selectSETAR_+3A_x">x</code></td>
<td>
<p> time series </p>
</td></tr>
<tr><td><code id="selectSETAR_+3A_m">m</code>, <code id="selectSETAR_+3A_d">d</code>, <code id="selectSETAR_+3A_steps">steps</code></td>
<td>
<p> embedding parameters. For their meanings, see help about <code><a href="#topic+nlar">nlar</a></code> </p>
</td></tr>
<tr><td><code id="selectSETAR_+3A_series">series</code></td>
<td>
<p> time series name (optional) </p>
</td></tr>
<tr><td><code id="selectSETAR_+3A_ml">mL</code>, <code id="selectSETAR_+3A_mh">mH</code>, <code id="selectSETAR_+3A_mm">mM</code></td>
<td>
<p>autoregressive order for &lsquo;low&rsquo; (<code>mL</code>) &lsquo;middle&rsquo; (<code>mM</code>, only useful if <code>nthresh</code>=2) and &lsquo;high&rsquo; (<code>mH</code>) regime (default values: m). Must be &lt;=m. Alternatively, you can specify <code>ML</code></p>
</td></tr>
<tr><td><code id="selectSETAR_+3A_thdelay">thDelay</code></td>
<td>
<p> Vector of possible &lsquo;threshold delay&rsquo; values to check for</p>
</td></tr>
<tr><td><code id="selectSETAR_+3A_mth">mTh</code></td>
<td>
<p>coefficients for the lagged time series, to obtain the threshold variable</p>
</td></tr>
<tr><td><code id="selectSETAR_+3A_thvar">thVar</code></td>
<td>
<p>external threshold variable</p>
</td></tr>
<tr><td><code id="selectSETAR_+3A_th">th</code></td>
<td>
<p>Different specifications of the grid search, to pre-specify a value or set the number of points to search. See<code><a href="#topic+MakeThSpec">MakeThSpec</a></code></p>
</td></tr>
<tr><td><code id="selectSETAR_+3A_trace">trace</code></td>
<td>
<p>should additional infos be printed? (logical)</p>
</td></tr>
<tr><td><code id="selectSETAR_+3A_include">include</code></td>
<td>
<p>Type of deterministic regressors to include</p>
</td></tr>
<tr><td><code id="selectSETAR_+3A_common">common</code></td>
<td>
<p>Indicates which elements are common to all regimes: no, only the <code>include</code> variables, the lags or both</p>
</td></tr>
<tr><td><code id="selectSETAR_+3A_model">model</code></td>
<td>
<p>Currently not implemented</p>
</td></tr>
<tr><td><code id="selectSETAR_+3A_ml">ML</code>, <code id="selectSETAR_+3A_mm">MM</code>, <code id="selectSETAR_+3A_mh">MH</code></td>
<td>
<p>vector of lags for  order for &lsquo;low&rsquo; (ML) &lsquo;middle&rsquo; (MM, only useful if nthresh=2) and &lsquo;high&rsquo; (MH)regime. Max must be &lt;=m</p>
</td></tr>
<tr><td><code id="selectSETAR_+3A_nthresh">nthresh</code></td>
<td>
<p>Number of threshold of the model</p>
</td></tr>
<tr><td><code id="selectSETAR_+3A_trim">trim</code></td>
<td>
<p>trimming parameter indicating the minimal percentage of observations in each regime. Default to 0.15</p>
</td></tr>
<tr><td><code id="selectSETAR_+3A_criterion">criterion</code></td>
<td>
<p> Model selection criterion</p>
</td></tr>
<tr><td><code id="selectSETAR_+3A_plot">plot</code></td>
<td>
<p>Should a plot showing the criterion values be printed? (logical)</p>
</td></tr>
<tr><td><code id="selectSETAR_+3A_max.iter">max.iter</code></td>
<td>
<p>Number of iterations for the algorithm</p>
</td></tr>
<tr><td><code id="selectSETAR_+3A_type">type</code></td>
<td>
<p>Whether the variable is taken is level, difference or a mix (diff y= y-1, diff lags) as in the ADF test</p>
</td></tr>
<tr><td><code id="selectSETAR_+3A_same.lags">same.lags</code></td>
<td>
<p>Logical. When AIC or pooled-AIC is used and arg m is given, should it search for same number of lags in each regime (TRUE) or allow for different (FALSE) lags in each regime. Different lags involves more computation</p>
</td></tr>
<tr><td><code id="selectSETAR_+3A_restriction">restriction</code></td>
<td>
<p>Restriction on the threshold. <code>OuterSymAll</code> will take a symmetric threshold and symmetric coefficients for outer regimes. OuterSymTh currently unavailable</p>
</td></tr>
<tr><td><code id="selectSETAR_+3A_hpc">hpc</code></td>
<td>
<p>Possibility to run the bootstrap on parallel core. See details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Routine for automatic selection of SETAR models hyper parameters.
</p>
<p>An exhaustive search over all possible combinations of values of
specified hyper-parameters is performed. Thus the threshold delay, the number of lags in each regime and the threshold value are computed. 
</p>
<p>Embedding parameters <code>d,steps</code> are kept fixed.
</p>
<p>Possible criteria are the usual SSR, AIC and a pooled AIC formula:
<code class="reqn">AIC(low regime model) + AIC(high regime model)</code>. The default
criterion is the pooled AIC formula. SSR criterion can't be used to compare models with different lags. 
</p>
<p>When two thresholds(<code>nthresh</code>=2) have to be computed, the search for the second is made conditional on results for first threshold as suggested in Gonzalo and Pittarakis (2002). Refinements can be obtained by using <code>max.iter</code> (first threshold being re-estimated based on the second one). If SSR is used, the number of lags in the inner regime is either the same if only arg m was given, otherwise it has to be pre-specified. Criterion AIC can be used to determine the number of lags in the nner regime, whereas pooled-AIC is currently not implemented for nthresh=2. 
</p>
<p>By default, all threshold values excluding the upper and lower <code>trim</code> of the threshold values are taken as potential threshold. restriction can be made with arg <code>th</code>. See function <code><a href="#topic+MakeThSpec">MakeThSpec</a></code>. 
</p>
<p>With the argument <code>hpc</code>, the heavy grid search can be run on parallel cores, thus alleviating the time of computation. Preliminary results 
indicate however that the length of the series must be very considerable in order that the parallel code becomes advantageous. To use it, the user needs simply to choose a package (among doMC, doMPI, doSNOW or doRedis) and register the backend. See the vignette for more details.
</p>


<h3>Value</h3>

<p>An object of class <code>selectSETAR</code> (print and plot methods) with: 
</p>
<table>
<tr><td><code>res</code></td>
<td>
<p>A data-frame, with columns giving hyper-parameter values and the
computed AIC for each row (only the best 10/5s are returned)</p>
</td></tr>
<tr><td><code>res2</code></td>
<td>
<p>Same as res, returned if nthresh=2 otherwise set to NULL</p>
</td></tr>
<tr><td><code>bests</code></td>
<td>
<p>estimated hyper-parameters</p>
</td></tr>
<tr><td><code>th</code>, <code>firstBests</code>, <code>bests2th</code>, <code>ML</code>, <code>MM</code>, <code>MH</code></td>
<td>
<p>estimated parameters, from first and conditional search</p>
</td></tr>
<tr><td><code>criterion</code>, <code>nthresh</code>, <code>same.lags</code></td>
<td>
<p>returns args given by user</p>
</td></tr>
<tr><td><code>allTh</code></td>
<td>
<p>all threshold values and corresponding criterion from first search</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Antonio, Fabio Di Narzo and Stigler, Matthieu</p>


<h3>References</h3>

<p>Gonzalo, J. &amp; Pitarakis, J. (2002) Estimation and model selection based inference in single and multiple threshold models, Journal of Econometrics, 110, 319 - 352</p>


<h3>See Also</h3>

<p><code><a href="#topic+selectLSTAR">selectLSTAR</a></code>, <code><a href="#topic+selectNNET">selectNNET</a></code>, <a href="#topic+MakeThSpec">MakeThSpec</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>llynx &lt;- log10(lynx)
selectSETAR(llynx, m=2)
#Suggested model is the following:
setar(llynx, m=2, thDelay=1, th=3.4)
</code></pre>

<hr>
<h2 id='SETAR'>Self Threshold Autoregressive model</h2><span id='topic+SETAR'></span><span id='topic+setar'></span><span id='topic+summary.setar'></span>

<h3>Description</h3>

<p>Self Exciting Threshold AutoRegressive model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setar(x, m, d=1, steps=d, series, mL, mM, mH, thDelay=0, mTh, thVar, th, trace=FALSE, 
      nested=FALSE, include = c( "const", "trend","none", "both"), 
      common=c("none", "include","lags", "both"), model=c("TAR", "MTAR"), ML=seq_len(mL), 
      MM=seq_len(mM), MH=seq_len(mH),nthresh=1,trim=0.15, type=c("level", "diff", "ADF"),
      restriction=c("none","OuterSymAll","OuterSymTh") )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SETAR_+3A_x">x</code></td>
<td>
<p> time series </p>
</td></tr>
<tr><td><code id="SETAR_+3A_m">m</code>, <code id="SETAR_+3A_d">d</code>, <code id="SETAR_+3A_steps">steps</code></td>
<td>
<p> embedding dimension, time delay, forecasting steps </p>
</td></tr>
<tr><td><code id="SETAR_+3A_series">series</code></td>
<td>
<p> time series name (optional) </p>
</td></tr>
<tr><td><code id="SETAR_+3A_ml">mL</code>, <code id="SETAR_+3A_mm">mM</code>, <code id="SETAR_+3A_mh">mH</code></td>
<td>
<p>autoregressive order for &lsquo;low&rsquo; (mL) &lsquo;middle&rsquo; (mM, only useful if nthresh=2) and &lsquo;high&rsquo; (mH)regime (default values: m). Must be &lt;=m. Alternatively, you can specify <code>ML</code></p>
</td></tr>
<tr><td><code id="SETAR_+3A_thdelay">thDelay</code></td>
<td>
<p>'time delay' for the threshold variable (as multiple of embedding time delay d)</p>
</td></tr>
<tr><td><code id="SETAR_+3A_mth">mTh</code></td>
<td>
<p>coefficients for the lagged time series, to obtain the threshold variable</p>
</td></tr>
<tr><td><code id="SETAR_+3A_thvar">thVar</code></td>
<td>
<p>external threshold variable</p>
</td></tr>
<tr><td><code id="SETAR_+3A_th">th</code></td>
<td>
<p>threshold value (if missing, a search over a reasonable grid is tried)</p>
</td></tr>
<tr><td><code id="SETAR_+3A_trace">trace</code></td>
<td>
<p>should additional infos be printed? (logical)</p>
</td></tr>
<tr><td><code id="SETAR_+3A_include">include</code></td>
<td>
<p>Type of deterministic regressors to include</p>
</td></tr>
<tr><td><code id="SETAR_+3A_common">common</code></td>
<td>
<p>Indicates which elements are common to all regimes: no, only the <code>include</code> variables, the lags or both</p>
</td></tr>
<tr><td><code id="SETAR_+3A_ml">ML</code>, <code id="SETAR_+3A_mm">MM</code>, <code id="SETAR_+3A_mh">MH</code></td>
<td>
<p>vector of lags for  order for &lsquo;low&rsquo; (ML) &lsquo;middle&rsquo; (MM, only useful if nthresh=2) and &lsquo;high&rsquo; (MH)regime. Max must be &lt;=m</p>
</td></tr>
<tr><td><code id="SETAR_+3A_model">model</code></td>
<td>
<p>Whether the threshold variable is taken in levels (TAR) or differences (MTAR)</p>
</td></tr>
<tr><td><code id="SETAR_+3A_nthresh">nthresh</code></td>
<td>
<p>Number of threshold of the model</p>
</td></tr>
<tr><td><code id="SETAR_+3A_trim">trim</code></td>
<td>
<p>trimming parameter indicating the minimal percentage of observations in each regime. Default to 0.15</p>
</td></tr>
<tr><td><code id="SETAR_+3A_type">type</code></td>
<td>
<p>Whether the variable is taken is level, difference or a mix (diff y= y-1, diff lags) as in the ADF test</p>
</td></tr>
<tr><td><code id="SETAR_+3A_restriction">restriction</code></td>
<td>
<p>Restriction on the threshold. <code>OuterSymAll</code> will take a symmetric threshold and symmetric coefficients for outer regimes. OuterSymTh currently unavailable</p>
</td></tr>
<tr><td><code id="SETAR_+3A_nested">nested</code></td>
<td>
<p>Whether is this a nested call? (useful for correcting final model df)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Self Exciting Threshold AutoRegressive model.
</p>
<p style="text-align: center;"><code class="reqn">X_{t+s} = 
  x_{t+s} = ( \phi_{1,0} + \phi_{1,1} x_t + \phi_{1,2} x_{t-d} + \dots +
  \phi_{1,mL} x_{t - (mL-1)d} ) I( z_t \leq th) +
  ( \phi_{2,0} + \phi_{2,1} x_t + \phi_{2,2} x_{t-d} + \dots + \phi_{2,mH}
  x_{t - (mH-1)d} ) I(z_t &gt; th) + \epsilon_{t+steps}</code>
</p>

<p>with <var>z</var> the threshold variable. The threshold variable can alternatively be specified by (in that order):
</p>

<dl>
<dt>thDelay</dt><dd> <p><code>z[t] = x[t - thDelay*d ]</code> </p>
</dd>
<dt>mTh</dt><dd> <p><code>z[t] = x[t] mTh[1] + x[t-d] mTh[2] + ... + x[t-(m-1)d] mTh[m]</code> </p>
</dd>
<dt>thVar</dt><dd> <p><code>z[t] = thVar[t]</code> </p>
</dd>
</dl>

<p>For fixed <code>th</code> and threshold variable, the model is linear, so
<code>phi1</code> and <code>phi2</code> estimation can be done directly by CLS
(Conditional Least Squares).
Standard errors for phi1 and phi2 coefficients provided by the
<code>summary</code> method for this model are taken from the linear
regression theory, and are to be considered asymptotical.
</p>


<h3>Value</h3>

<p>An object of class <code>nlar</code>, subclass <code>setar</code>
</p>


<h3>Author(s)</h3>

<p> Antonio, Fabio Di Narzo </p>


<h3>References</h3>

<p>Non-linear time series models in empirical finance, Philip Hans Franses and Dick van Dijk, Cambridge: Cambridge University Press (2000).
</p>
<p>Non-Linear Time Series: A Dynamical Systems Approach, Tong, H., Oxford: Oxford University Press (1990).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.setar">plot.setar</a></code> for details on plots produced for this model from the <code>plot</code> generic.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#fit a SETAR model, with threshold as suggested in Tong(1990, p 377)
mod.setar &lt;- setar(log10(lynx), m=2, thDelay=1, th=3.25)
mod.setar
summary(mod.setar)

## example in Tsay (2005)
data(m.unrate)
setar(diff(m.unrate), ML=c(2,3,4,12), MH=c(2,4,12), th=0.1, include="none")
</code></pre>

<hr>
<h2 id='setar.sim'>Simulation and bootstrap of Threshold Autoregressive model (SETAR)</h2><span id='topic+setar.sim'></span><span id='topic+setar.boot'></span><span id='topic+linear.boot'></span><span id='topic+linear.sim'></span>

<h3>Description</h3>

<p>Simulate or bootstrap a Threshold AR (SETAR)
The <code>setar.sim</code> function allows to simulate a SETAR model from scratch. 
The most important argument is the <code>B</code> argument, which should be a one row matrix, 
with first the constant/trend arguments, then the 
slope coefficients, and this for each regime (lower, middle, high). 
Other arguments such as <code>lag</code>, <code>nthresh</code> indicate the dimension of this matrix. 
As an example, a SETAR with 2 lags, 1 threshold, a constant, would have coefficient in the order:
<code>c(const_L, phi_1_L, phi_2_L, const_H, phi_1_H, phi_2_H)</code> where L is for Lower regime, H for Higher. 
</p>
<p><code>setar.boot</code> on the other side resample/bootstraps an existing setar output. 
It uses a recursive approach, reconstructing the series. 
Residuals from the original model are resampled using different bootstrap schemes, see  <code><a href="#topic+resample_vec">resample_vec</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setar.boot(
  setarObject,
  boot.scheme = c("resample", "resample_block", "wild1", "wild2", "check"),
  seed = NULL,
  ...
)

linear.boot(
  linearObject,
  boot.scheme = c("resample", "resample_block", "wild1", "wild2", "check"),
  seed = NULL,
  ...
)

setar.sim(
  B,
  n = 200,
  lag = 1,
  include = c("const", "trend", "none", "both"),
  nthresh = 1,
  Thresh,
  starting = NULL,
  innov = rnorm(n),
  ...
)

linear.sim(
  B,
  n = 200,
  lag = 1,
  include = c("const", "trend", "none", "both"),
  starting = NULL,
  innov = rnorm(n),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setar.sim_+3A_setarobject">setarObject</code></td>
<td>
<p>Bootstrap: the <code><a href="#topic+setar">setar</a></code> object to resample data from.</p>
</td></tr>
<tr><td><code id="setar.sim_+3A_boot.scheme">boot.scheme</code></td>
<td>
<p>Bootstrap: which resampling scheme to use for the residuals. See <code><a href="#topic+resample_vec">resample_vec</a></code>.</p>
</td></tr>
<tr><td><code id="setar.sim_+3A_seed">seed</code></td>
<td>
<p>Bootstrap: seed used in the resampling</p>
</td></tr>
<tr><td><code id="setar.sim_+3A_...">...</code></td>
<td>
<p>additional arguments for the unexported <code>setar.gen</code>.</p>
</td></tr>
<tr><td><code id="setar.sim_+3A_linearobject">linearObject</code></td>
<td>
<p>Bootstrap: the <code><a href="#topic+linear">linear</a></code> object to resample data from.</p>
</td></tr>
<tr><td><code id="setar.sim_+3A_b">B</code></td>
<td>
<p>Simulation: vector of coefficients to simulate from.</p>
</td></tr>
<tr><td><code id="setar.sim_+3A_n">n</code></td>
<td>
<p>Simulation: Number of observations to simulate.</p>
</td></tr>
<tr><td><code id="setar.sim_+3A_thresh">Thresh</code>, <code id="setar.sim_+3A_nthresh">nthresh</code>, <code id="setar.sim_+3A_lag">lag</code>, <code id="setar.sim_+3A_include">include</code></td>
<td>
<p>Simulation: parameters for the SETAR to simulate. 
See <code><a href="#topic+setar">setar</a></code> for their description.</p>
</td></tr>
<tr><td><code id="setar.sim_+3A_starting">starting</code></td>
<td>
<p>Simulation: Starting values (same length as lag)</p>
</td></tr>
<tr><td><code id="setar.sim_+3A_innov">innov</code></td>
<td>
<p>Simulation: time series of innovations/residuals.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the simulated/bootstrapped data and the parameter matrix
used.
</p>


<h3>Author(s)</h3>

<p>Matthieu Stigler
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SETAR">SETAR</a></code> to estimate a SETAR, <code><a href="stats.html#topic+arima.sim">arima.sim</a></code> to
simulate an ARMA.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##Simulation of a TAR with 1 threshold
TvarMat &lt;- c(2.9,-0.4,-0.1,-1.5, 0.2,0.3)
sim&lt;-setar.sim(B=TvarMat,lag=2, type="simul", nthresh=1, Thresh=2, starting=c(2.8,2.2))
mean(ifelse(sim&gt;2,1,0))	#approximation of values over the threshold

#check the result
selectSETAR(sim, m=2)

##Bootstrap a TAR with two threshold (three regimes)
sun &lt;- (sqrt(sunspot.year+1)-1)*2
sun_est &lt;- setar(sun, nthresh=2, m=2)
sun_est_boot &lt;- setar.boot(sun_est)
head(sun_est_boot)

##Check the bootstrap: with no resampling, is it the same series?
sun_est_boot &lt;- setar.boot(sun_est, boot.scheme = "check")
all.equal(as.numeric(sun), sun_est_boot)

</code></pre>

<hr>
<h2 id='setarTest'>Test of linearity against threshold (SETAR)</h2><span id='topic+setarTest'></span><span id='topic+setartest'></span>

<h3>Description</h3>

<p>Test of linearity against threshold of Hansen (1999) with bootstrap
distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setarTest(
  x,
  m,
  thDelay = 0,
  trim = 0.1,
  include = c("const", "trend", "none", "both"),
  nboot = 10,
  test = c("1vs", "2vs3"),
  hpc = c("none", "foreach"),
  boot.scheme = c("resample", "resample_block", "wild1", "wild2", "check"),
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setarTest_+3A_x">x</code></td>
<td>
<p>time series</p>
</td></tr>
<tr><td><code id="setarTest_+3A_m">m</code>, <code id="setarTest_+3A_thdelay">thDelay</code></td>
<td>
<p>lag and 'time delay' for the threshold variable</p>
</td></tr>
<tr><td><code id="setarTest_+3A_trim">trim</code></td>
<td>
<p>trimming parameter indicating the minimal percentage of
observations in each regime</p>
</td></tr>
<tr><td><code id="setarTest_+3A_include">include</code></td>
<td>
<p>Type of deterministic regressors to include: none, a constant, a trend, or constant and trend (<code>both</code>).</p>
</td></tr>
<tr><td><code id="setarTest_+3A_nboot">nboot</code></td>
<td>
<p>number of bootstrap replications</p>
</td></tr>
<tr><td><code id="setarTest_+3A_test">test</code></td>
<td>
<p>whether to test AR against SETAR, or SETAR(1 reg) against SETAR(2 reg)</p>
</td></tr>
<tr><td><code id="setarTest_+3A_hpc">hpc</code></td>
<td>
<p>Possibility to run the bootstrap on parallel core. See details in</p>
</td></tr>
<tr><td><code id="setarTest_+3A_boot.scheme">boot.scheme</code></td>
<td>
<p>Type of resampling scheme to use for the residuals. See <code><a href="#topic+resample_vec">resample_vec</a></code>.</p>
</td></tr>
<tr><td><code id="setarTest_+3A_seed">seed</code></td>
<td>
<p>Seed used in the bootstrap resampling
<code><a href="#topic+TVECM.HStest">TVECM.HStest</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimation of the first threshold parameter is made with CLS, a conditional
search with one iteration is made for the second threshold. The Ftest
comparing the residual sum of squares (SSR) of each model is computed.
</p>
<p style="text-align: center;"><code class="reqn"> F_{ij}=T( (S_{i}-S_{j})/S_{j} )</code>
</p>

<p>where <code class="reqn">S_{i}</code> is the SSR of the model with i regimes (and so i-1
thresholds).
</p>
<p>Three test are available. The both first can be seen as linearity test,
whereas the third can be seen as a specification test: once the 1vs2 or/and
1vs3 rejected the linearity and henceforth accepted the presence of a
threshold, is a model with one or two thresholds preferable?
</p>
<p>Test <b>1vs</b>2: Linear AR versus 1 threshold TAR
</p>
<p>Test <b>1vs</b>3: Linear AR versus 2 thresholds TAR
</p>
<p>Test <b>2vs3</b>: 1 threshold TAR versus 2 thresholds TAR
</p>
<p>The two first tests are computed together and available with test=&quot;1vs&quot;. The
third test is available with test=&quot;2vs3&quot;.
</p>
<p>The homoskedastic bootstrap distribution is based on resampling the
residuals from H0 model (ar for test 1vs, and setar(1) for test 2vs3),
estimating the threshold parameter and then computing the Ftest, so it
involves many computations and is pretty slow.
</p>


<h3>Value</h3>

<p>A object of class &quot;Hansen99Test&quot; containing:
</p>
<table>
<tr><td><code>SSRs</code></td>
<td>
<p>The residual Sum of squares of model AR, 1 threshold TAR and 2
thresholds TAR</p>
</td></tr>
<tr><td><code>Ftests</code></td>
<td>
<p>The Ftest statistic for the test</p>
</td></tr>
<tr><td><code>PvalBoot</code></td>
<td>
<p>The bootstrap p-values for the test selected</p>
</td></tr>
<tr><td><code>CriticalValBoot</code></td>
<td>
<p>The critical values for the test selected</p>
</td></tr>
<tr><td><code>Ftestboot</code></td>
<td>
<p>All the F-test computed</p>
</td></tr> <tr><td><code>firstBests</code>, <code>secBests</code></td>
<td>
<p>The
thresholds for the original series, obtained from search for 1 thresh
(<code>firstBests</code>) and conditional search for 2 thresh (secBests)</p>
</td></tr>
<tr><td><code>nboot</code>, <code>m</code></td>
<td>
<p>The number of bootstrap replications (<code>nboot</code>), the
lags used (<code>m</code>)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matthieu Stigler
</p>


<h3>References</h3>

<p>Hansen (1999) Testing for linearity, Journal of Economic
Surveys, Volume 13, Number 5, December 1999 , pp. 551-576(26) available at:
<a href="http://www.ssc.wisc.edu/~bhansen/papers/cv.htm">http://www.ssc.wisc.edu/~bhansen/papers/cv.htm</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TVAR.LRtest">TVAR.LRtest</a></code> for the multivariate version.
<code><a href="#topic+SETAR">SETAR</a></code> for estimation of the model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Data used by Hansen
sun &lt;- (sqrt(sunspot.year + 1) - 1) * 2

#Test 1vs2 and 1vs3
#setarTest(sun, m=11, thDelay=0:1, nboot=5,trim=0.1, test="1vs")
</code></pre>

<hr>
<h2 id='setarTest_IIPUs_results'>Results from the setarTest, applied on Hansen (1999) data</h2><span id='topic+setarTest_IIPUs_results'></span>

<h3>Description</h3>

<p>Saved objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setarTest_IIPUs_results
</code></pre>


<h3>Format</h3>

<p>A list containing output from two tests
</p>


<h3>See Also</h3>

<p>Example in <code><a href="#topic+IIPUs">IIPUs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tsDyn)
data(IIPUs)
B &lt;-  1000
## Not run: 
  test_1 &lt;- setarTest(IIPUs, m=16, thDelay=5, nboot=B)
  test_2 &lt;- setarTest(IIPUs, m=16, thDelay=5, nboot=B, test = "2vs3")

## End(Not run)
</code></pre>

<hr>
<h2 id='sigmoid'>sigmoid functions</h2><span id='topic+sigmoid'></span><span id='topic+d2sigmoid'></span><span id='topic+dsigmoid'></span>

<h3>Description</h3>

<p>Some sigmoid functions. See R sources for their definition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sigmoid(x)

dsigmoid(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sigmoid_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J. L. Aznarte
</p>

<hr>
<h2 id='STAR'>STAR model</h2><span id='topic+STAR'></span><span id='topic+star'></span>

<h3>Description</h3>

<p>STAR model fitting with automatic selection of the number of regimes
based on LM tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>star(x, m=2, noRegimes, d = 1, steps = d, series, rob = FALSE,
                 mTh, thDelay, thVar, sig=0.05, trace=TRUE, control=list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="STAR_+3A_x">x</code></td>
<td>
<p> time series </p>
</td></tr>
<tr><td><code id="STAR_+3A_m">m</code>, <code id="STAR_+3A_d">d</code>, <code id="STAR_+3A_steps">steps</code></td>
<td>
<p> embedding dimension, time delay, forecasting steps </p>
</td></tr>
<tr><td><code id="STAR_+3A_noregimes">noRegimes</code></td>
<td>
<p> max number of regimes </p>
</td></tr>
<tr><td><code id="STAR_+3A_series">series</code></td>
<td>
<p> time series name (optional) </p>
</td></tr>
<tr><td><code id="STAR_+3A_rob">rob</code></td>
<td>
<p>perform robust test (not implemented)</p>
</td></tr>
<tr><td><code id="STAR_+3A_thdelay">thDelay</code></td>
<td>
<p>'time delay' for the threshold variable (as multiple of
embedding time delay d)</p>
</td></tr>
<tr><td><code id="STAR_+3A_mth">mTh</code></td>
<td>
<p>coefficients for the lagged time series, to obtain the
threshold variable</p>
</td></tr>
<tr><td><code id="STAR_+3A_thvar">thVar</code></td>
<td>
<p>external threshold variable</p>
</td></tr>
<tr><td><code id="STAR_+3A_sig">sig</code></td>
<td>
<p>significance level for the tests to select the number of regimes.</p>
</td></tr>
<tr><td><code id="STAR_+3A_control">control</code></td>
<td>
<p>further arguments to be passed as <code>control</code> list to
<code><a href="stats.html#topic+optim">optim</a></code></p>
</td></tr>
<tr><td><code id="STAR_+3A_trace">trace</code></td>
<td>
<p>should additional infos be printed out?</p>
</td></tr>
<tr><td><code id="STAR_+3A_...">...</code></td>
<td>
<p>currently unused</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function star implements the iterative building strategy described
in [1] to identify and estimate Smooth Transition Autoregressive
models.
</p>
<p>[1] T. Terasvirta, &quot;Specification, estimation and evaluation of smooth
transition autoregressive models&quot;, J. Am. Stat. Assoc. 89 (1994):
208-218. 
</p>


<h3>Value</h3>

<p><code>star</code> returns an object of class <code>nlar</code>, subclass
<code>star</code>, i.e. a list with informations about the fitted model.
</p>


<h3>Author(s)</h3>

<p> J. L. Aznarte M. </p>


<h3>See Also</h3>

<p><code><a href="#topic+addRegime">addRegime</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>mod.star &lt;- star(log10(lynx), mTh=c(0,1), control=list(maxit=3000))
mod.star

addRegime(mod.star)
</code></pre>

<hr>
<h2 id='toLatex.setar'>Latex representation of fitted setar models</h2><span id='topic+toLatex.setar'></span>

<h3>Description</h3>

<p>Produce LaTeX output of the SETAR model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'setar'
toLatex(object, digits = 3, label, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toLatex.setar_+3A_object">object</code></td>
<td>
<p>fitted setar model (using <code><a href="#topic+nlar">nlar</a></code>)</p>
</td></tr>
<tr><td><code id="toLatex.setar_+3A_digits">digits</code></td>
<td>
<p>options to be passed to <code><a href="base.html#topic+format">format</a></code> for formatting
numbers</p>
</td></tr>
<tr><td><code id="toLatex.setar_+3A_label">label</code></td>
<td>
<p>LaTeX label passed to the equation</p>
</td></tr>
<tr><td><code id="toLatex.setar_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Antonio, Fabio Di Narzo
</p>


<h3>See Also</h3>

<p><code><a href="#topic+setar">setar</a></code>, <code><a href="#topic+nlar-methods">nlar-methods</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mod.setar &lt;- setar(log10(lynx), m=2, thDelay=1, th=3.25)
toLatex(mod.setar)

</code></pre>

<hr>
<h2 id='TVAR'>Multivariate Threshold Vector Autoregressive model</h2><span id='topic+TVAR'></span><span id='topic+OlsTVAR'></span>

<h3>Description</h3>

<p>Estimate a multivariate Threshold VAR (TVAR), either using lags as transition variable (default),
or specifying an external variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TVAR(
  data,
  lag,
  include = c("const", "trend", "none", "both"),
  model = c("TAR", "MTAR"),
  commonInter = FALSE,
  nthresh = 1,
  thDelay = 1,
  mTh = 1,
  thVar,
  trim = 0.1,
  ngrid,
  gamma = NULL,
  around,
  plot = FALSE,
  dummyToBothRegimes = TRUE,
  trace = TRUE,
  trick = "for",
  max.iter = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TVAR_+3A_data">data</code></td>
<td>
<p>time series</p>
</td></tr>
<tr><td><code id="TVAR_+3A_lag">lag</code></td>
<td>
<p>Number of lags to include in each regime</p>
</td></tr>
<tr><td><code id="TVAR_+3A_include">include</code></td>
<td>
<p>Type of deterministic regressors to include</p>
</td></tr>
<tr><td><code id="TVAR_+3A_model">model</code></td>
<td>
<p>Whether the transition variable is taken in levels (TAR) or
difference (MTAR)</p>
</td></tr>
<tr><td><code id="TVAR_+3A_commoninter">commonInter</code></td>
<td>
<p>Whether the deterministic regressors are regime specific
(<code>commonInter</code>=FALSE) or not.</p>
</td></tr>
<tr><td><code id="TVAR_+3A_nthresh">nthresh</code></td>
<td>
<p>Number of thresholds</p>
</td></tr>
<tr><td><code id="TVAR_+3A_thdelay">thDelay</code></td>
<td>
<p>'time delay' for the threshold variable (as multiple of
embedding time delay d) PLEASE NOTE that the notation is currently different
to univariate models in tsDyn. The left side variable is taken at time t, and
not t+1 as in univariate cases.</p>
</td></tr>
<tr><td><code id="TVAR_+3A_mth">mTh</code></td>
<td>
<p>combination of variables with same lag order for the transition
variable. Either a single value (indicating which variable to take) or a
combination</p>
</td></tr>
<tr><td><code id="TVAR_+3A_thvar">thVar</code></td>
<td>
<p>Optional. External transition variable.</p>
</td></tr>
<tr><td><code id="TVAR_+3A_trim">trim</code></td>
<td>
<p>trimming parameter indicating the minimal percentage of
observations in each regime</p>
</td></tr>
<tr><td><code id="TVAR_+3A_ngrid">ngrid</code></td>
<td>
<p>number of elements of the grid, especially for <code>nthresh=3</code></p>
</td></tr>
<tr><td><code id="TVAR_+3A_gamma">gamma</code></td>
<td>
<p>prespecified threshold values</p>
</td></tr>
<tr><td><code id="TVAR_+3A_around">around</code></td>
<td>
<p>The grid search is restricted to <var>ngrid</var> values around this
point. Especially useful for <code>nthresh=3</code>.</p>
</td></tr>
<tr><td><code id="TVAR_+3A_plot">plot</code></td>
<td>
<p>Whether a plot showing the results of the grid search should be
printed</p>
</td></tr>
<tr><td><code id="TVAR_+3A_dummytobothregimes">dummyToBothRegimes</code></td>
<td>
<p>Whether the dummy in the one threshold model is
applied to each regime or not.</p>
</td></tr>
<tr><td><code id="TVAR_+3A_trace">trace</code></td>
<td>
<p>should additional infos be printed out?</p>
</td></tr>
<tr><td><code id="TVAR_+3A_trick">trick</code></td>
<td>
<p>type of R function called: <code>for</code> or <code>mapply</code></p>
</td></tr>
<tr><td><code id="TVAR_+3A_max.iter">max.iter</code></td>
<td>
<p>Number of iterations for the algorithm</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For fixed <code>th</code> and threshold variable, the model is linear, so
estimation can be done directly by CLS (Conditional Least Squares). The
search of the parameters values is made upon a grid of potential values. So
it is pretty slow.
</p>
<p>nthresh=1: estimation of one threshold model (two regimes) upon a grid of
<var>ngrid</var> values (default to ALL) possible thresholds and delays values.
</p>
<p>nthresh=2: estimation of two thresholds model (three regimes) Conditional on
the threshold found in model where nthresh=1, the second threshold is
searched. When both are found, a second grid search is made with 30 values
around each threshold.
</p>
<p>nthresh=3: DOES NOT estimate a 3 thresholds model, but a 2 thresholds model
with a whole grid over the thresholds parameters (so is really slow) with a
given delay, is there rather to check the consistency of the method nthresh=2
</p>


<h3>Value</h3>

<p>An object of class TVAR, with standard methods.
</p>


<h3>Author(s)</h3>

<p>Matthieu Stigler
</p>


<h3>References</h3>

<p>Lo and Zivot (2001) &quot;Threshold Cointegration and Nonlinear
Adjustment to the Law of One Price,&quot; Macroeconomic Dynamics, Cambridge
University Press, vol. 5(4), pages 533-76, September.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lineVar">lineVar</a></code> for the linear VAR/VECM,
<code><a href="#topic+TVAR.LRtest">TVAR.LRtest</a></code> to test for TVAR, <code><a href="#topic+TVAR.sim">TVAR.sim</a></code> to
simulate/bootstrap a TVAR.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(zeroyld)

tv &lt;- TVAR(zeroyld, lag=2, nthresh=2, thDelay=1, trim=0.1, mTh=1, plot=FALSE)

print(tv)
summary(tv)

# a few useful methods:
plot(tv)
predict(tv)
c(AIC(tv), BIC(tv), logLik(tv))
</code></pre>

<hr>
<h2 id='TVAR.LRtest'>Test of linearity</h2><span id='topic+TVAR.LRtest'></span>

<h3>Description</h3>

<p>Multivariate extension of the linearity against threshold test from Hansen
(1999) with bootstrap distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TVAR.LRtest(
  data,
  lag = 1,
  trend = TRUE,
  series,
  thDelay = 1:m,
  mTh = 1,
  thVar,
  nboot = 10,
  plot = FALSE,
  trim = 0.1,
  test = c("1vs", "2vs3"),
  model = c("TAR", "MTAR"),
  hpc = c("none", "foreach"),
  trace = FALSE,
  check = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TVAR.LRtest_+3A_data">data</code></td>
<td>
<p>multivariate time series</p>
</td></tr>
<tr><td><code id="TVAR.LRtest_+3A_lag">lag</code></td>
<td>
<p>Number of lags to include in each regime</p>
</td></tr>
<tr><td><code id="TVAR.LRtest_+3A_trend">trend</code></td>
<td>
<p>whether a trend should be added</p>
</td></tr>
<tr><td><code id="TVAR.LRtest_+3A_series">series</code></td>
<td>
<p>name of the series</p>
</td></tr>
<tr><td><code id="TVAR.LRtest_+3A_thdelay">thDelay</code></td>
<td>
<p>'time delay' for the threshold variable (as multiple of
embedding time delay d) PLEASE NOTE that the notation is currently different
to univariate models in tsDyn. The left side variable is taken at time t, and
not t+1 as in univariate cases.</p>
</td></tr>
<tr><td><code id="TVAR.LRtest_+3A_mth">mTh</code></td>
<td>
<p>combination of variables with same lag order for the transition
variable. Either a single value (indicating which variable to take) or a
combination</p>
</td></tr>
<tr><td><code id="TVAR.LRtest_+3A_thvar">thVar</code></td>
<td>
<p>external transition variable</p>
</td></tr>
<tr><td><code id="TVAR.LRtest_+3A_nboot">nboot</code></td>
<td>
<p>Number of bootstrap replications</p>
</td></tr>
<tr><td><code id="TVAR.LRtest_+3A_plot">plot</code></td>
<td>
<p>Whether a plot showing the results of the grid search should be
printed</p>
</td></tr>
<tr><td><code id="TVAR.LRtest_+3A_trim">trim</code></td>
<td>
<p>trimming parameter indicating the minimal percentage of
observations in each regime</p>
</td></tr>
<tr><td><code id="TVAR.LRtest_+3A_test">test</code></td>
<td>
<p>Type of usual and alternative hypothesis. See details</p>
</td></tr>
<tr><td><code id="TVAR.LRtest_+3A_model">model</code></td>
<td>
<p>Whether the threshold variable is taken in level (TAR) or
difference (MTAR)</p>
</td></tr>
<tr><td><code id="TVAR.LRtest_+3A_hpc">hpc</code></td>
<td>
<p>Possibility to run the bootstrap on parallel core. See details in
<code><a href="#topic+TVECM.HStest">TVECM.HStest</a></code></p>
</td></tr>
<tr><td><code id="TVAR.LRtest_+3A_trace">trace</code></td>
<td>
<p>should additional infos be printed? (logical)</p>
</td></tr>
<tr><td><code id="TVAR.LRtest_+3A_check">check</code></td>
<td>
<p>Possibility to check the function by no sampling: the test value
should be the same as in the original data</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This test is just the multivariate extension proposed by Lo and Zivot of the
linearity test of Hansen (1999). As in univariate case, estimation of the
first threshold parameter is made with CLS, for the second threshold a
conditional search with one iteration is made. Instead of a Ftest comparing
the SSR for the univariate case, a Likelihood Ratio (LR) test comparing the
covariance matrix of each model is computed.
</p>
<p style="text-align: center;"><code class="reqn"> LR_{ij}=T( ln(\det \hat \Sigma_{i}) -ln(\det \hat \Sigma_{j}))</code>
</p>
<p> where
<code class="reqn"> \hat \Sigma_{i}</code> is the estimated covariance matrix of the model with i
regimes (and so i-1 thresholds).
</p>
<p>Three test are available. The both first can be seen as linearity test,
whereas the third can be seen as a specification test: once the 1vs2 or/and
1vs3 rejected the linearity and henceforth accepted the presence of a
threshold, is a model with one or two thresholds preferable?
</p>
<p>Test <b>1vs</b>2: Linear VAR versus 1 threshold TVAR
</p>
<p>Test <b>1vs</b>3: Linear VAR versus 2 threshold2 TVAR
</p>
<p>Test <b>2vs3</b>: 1 threshold TAR versus 2 threshold2 TAR
</p>
<p>The both first are computed together and available with test=&quot;1vs&quot;. The third
test is available with test=&quot;2vs3&quot;.
</p>
<p>The homoskedastik bootstrap distribution is based on resampling the residuals
from H0 model, estimating the threshold parameter and then computing the
Ftest, so it involves many computations and is pretty slow.
</p>


<h3>Value</h3>

<p>A list containing:
</p>
<p>-The values of each LR test
</p>
<p>-The bootstrap Pvalues and critical values for the test selected
</p>


<h3>Author(s)</h3>

<p>Matthieu Stigler
</p>


<h3>References</h3>

<p>Hansen (1999) Testing for linearity, Journal of Economic Surveys,
Volume 13, Number 5, December 1999 , pp. 551-576(26) available at:
<a href="http://www.ssc.wisc.edu/~bhansen/papers/cv.htm">http://www.ssc.wisc.edu/~bhansen/papers/cv.htm</a>
</p>
<p>Lo and Zivot (2001) &quot;Threshold Cointegration and Nonlinear Adjustment to the
Law of One Price,&quot; Macroeconomic Dynamics, Cambridge University Press, vol.
5(4), pages 533-76, September.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+setarTest">setarTest</a></code> for the univariate version.
<code><a href="#topic+OlsTVAR">OlsTVAR</a></code> for estimation of the model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(zeroyld)
data&lt;-zeroyld

TVAR.LRtest(data, lag=2, mTh=1,thDelay=1:2, nboot=3, plot=FALSE, trim=0.1, test="1vs")
</code></pre>

<hr>
<h2 id='TVAR.sim'>Simulation of a multivariate Threshold Autoregressive model (TVAR)</h2><span id='topic+TVAR.sim'></span><span id='topic+TVAR.boot'></span>

<h3>Description</h3>

<p>Simulate a multivariate Threshold VAR (TVAR)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TVAR.sim(
  B,
  Thresh,
  nthresh = 1,
  n = 200,
  lag = 1,
  include = c("const", "trend", "none", "both"),
  thDelay = 1,
  mTh = 1,
  starting = NULL,
  innov = rmnorm(n, varcov = varcov),
  varcov = diag(1, nrow(B)),
  show.parMat = FALSE,
  ...
)

TVAR.boot(
  TVARobject,
  innov,
  seed,
  boot.scheme = c("resample", "wild1", "wild2", "check"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TVAR.sim_+3A_b">B</code></td>
<td>
<p>Matrix of coefficients to simulate</p>
</td></tr>
<tr><td><code id="TVAR.sim_+3A_thresh">Thresh</code></td>
<td>
<p>The threshold value(s). Vector of length nthresh</p>
</td></tr>
<tr><td><code id="TVAR.sim_+3A_nthresh">nthresh</code></td>
<td>
<p>number of threshold (see details)</p>
</td></tr>
<tr><td><code id="TVAR.sim_+3A_n">n</code></td>
<td>
<p>Number of observations to create when type=&quot;simul&quot;</p>
</td></tr>
<tr><td><code id="TVAR.sim_+3A_lag">lag</code></td>
<td>
<p>Number of lags to include in each regime</p>
</td></tr>
<tr><td><code id="TVAR.sim_+3A_include">include</code></td>
<td>
<p>Type of deterministic regressors to include. NOT WORKING
PROPERLY CURRENTLY if not const</p>
</td></tr>
<tr><td><code id="TVAR.sim_+3A_thdelay">thDelay</code></td>
<td>
<p>'time delay' for the threshold variable (as multiple of
embedding time delay d) PLEASE NOTE that the notation is currently different
to univariate models in tsDyn. The left side variable is taken at time t, and
not t+1 as in univariate cases.</p>
</td></tr>
<tr><td><code id="TVAR.sim_+3A_mth">mTh</code></td>
<td>
<p>combination of variables with same lag order for the transition
variable. Either a single value (indicating which variable to take) or a
combination</p>
</td></tr>
<tr><td><code id="TVAR.sim_+3A_starting">starting</code></td>
<td>
<p>Starting values (matrix of dimension lag x k). If not given,
set to zero.</p>
</td></tr>
<tr><td><code id="TVAR.sim_+3A_innov">innov</code></td>
<td>
<p>Innovations used for simulation. Should be matrix of dim n x k.
By default multivariate normal. For the bootstrap case <code>TVAR.boot</code>, residuals are
resampled if argument is missing.</p>
</td></tr>
<tr><td><code id="TVAR.sim_+3A_varcov">varcov</code></td>
<td>
<p>Variance-covariance matrix for the innovations. By default
identity matrix.</p>
</td></tr>
<tr><td><code id="TVAR.sim_+3A_show.parmat">show.parMat</code></td>
<td>
<p>Logical. Should the parameter matrix be shown? Useful to
understand how to give right input</p>
</td></tr>
<tr><td><code id="TVAR.sim_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the underlying (un-exported)
<code>TVAR.gen</code> function</p>
</td></tr>
<tr><td><code id="TVAR.sim_+3A_tvarobject">TVARobject</code></td>
<td>
<p>Object of class <code>TVAR</code> generated by function
<code><a href="#topic+TVAR">TVAR</a></code></p>
</td></tr>
<tr><td><code id="TVAR.sim_+3A_seed">seed</code></td>
<td>
<p>Optional. Seed for the random resampling function.</p>
</td></tr>
<tr><td><code id="TVAR.sim_+3A_boot.scheme">boot.scheme</code></td>
<td>
<p>The bootstrap scheme.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function offers the possibility to generate series following a TVAR.
</p>
<p>By giving a matrix of coefficients, on can only simulate a VAR (nthresh=0) or
TVAR (nthresh=1 or 2). One can have a specification with constant (default),
trend, both or none (see arg include). Order in parameters is include/lags
(VECM) and include/lags/include/lags for TVECM, hence, a matrix for a TVECM
with 3 regimes, a const and a 2 lags would have 2 lines and 2*(1+4) columns.
The innovations can be given by the user (a matrix of dim nxk, here n does
not include the starting values!), by default it uses a multivariate normal
distribution, with covariance matrix specified by varcov. The starting values
(of dim lags x k) can be given. The user should take care for their choice,
since it is not sure that the simulated values will cross the threshold even
once.
</p>
<p>The matrix &lsquo;B&rsquo; has to be in the form: constant, trend, lags, then
repeated if many regimes. In case of uncertainty, using
<code>who.parMat=TRUE</code> will print the matrix as interpreted by the function,
helping the user to feed the right input.
</p>
<p>For the bootstrap, the function resamples data from a given TVAR model generated by
<code><a href="#topic+TVAR">TVAR</a></code>, returning the resampled data. 
A residual recursive bootstrap is used, where one uses either a simple
resampling, or the Wild bootstrap, either with a normal distribution (wild1) or
inverting the sign randomly (wild2)
</p>


<h3>Value</h3>

<p>A matrix with the simulated/bootstrapped series.
</p>


<h3>Author(s)</h3>

<p>Matthieu Stigler
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TVAR">TVAR</a></code> to estimate the TVAR.  Similar <code><a href="#topic+TVECM.sim">TVECM.sim</a></code> and <code><a href="#topic+TVECM.boot">TVECM.boot</a></code> for <code><a href="#topic+TVECM">TVECM</a></code>, 
<code><a href="#topic+VAR.sim">VAR.sim</a></code> and <code><a href="#topic+VAR.boot">VAR.boot</a></code> for VAR models estimated with <code><a href="#topic+lineVar">lineVar</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## TVAR.sim: Simulation of a TVAR with 1 threshold
B &lt;- rbind(c(0.11928245, 1.00880447, -0.009974585, -0.089316, 0.95425564, 0.02592617),
        c(0.25283578, 0.09182279,  0.914763741, -0.0530613, 0.02248586, 0.94309347))
colnames(B) &lt;- paste(rep(c("Const", "Lag_1_var1", "Lag_1_var2"), 2), c("Low", "High"), sep="_")
sim &lt;- TVAR.sim(B=B,nthresh=1,n=500, mTh=1, Thresh=5, starting=matrix(c(5.2, 5.5), nrow=1))

#estimate the new serie
TVAR(sim, lag=1, dummyToBothRegimes=TRUE)






## TVAR.boot: Bootstrap a TVAR with two threshold (three regimes)
data(zeroyld)
serie &lt;- zeroyld
mod &lt;- TVAR(data=serie,lag=1, nthresh=1)
TVAR.boot(mod)
</code></pre>

<hr>
<h2 id='TVECM'>Threshold Vector Error Correction model (VECM)</h2><span id='topic+TVECM'></span>

<h3>Description</h3>

<p>Estimate a Threshold Vector Error Correction model (VECM)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TVECM(
  data,
  lag = 1,
  nthresh = 1,
  trim = 0.05,
  ngridBeta = 50,
  ngridTh = 50,
  plot = TRUE,
  th1 = list(exact = NULL, int = c("from", "to"), around = "val"),
  th2 = list(exact = NULL, int = c("from", "to"), around = "val"),
  beta = list(exact = NULL, int = c("from", "to"), around = c("val", "by")),
  restr = c("none", "equal", "signOp"),
  common = c("All", "only_ECT"),
  include = c("const", "trend", "none", "both"),
  dummyToBothRegimes = TRUE,
  beta0 = 0,
  methodMapply = FALSE,
  trace = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TVECM_+3A_data">data</code></td>
<td>
<p>time series</p>
</td></tr>
<tr><td><code id="TVECM_+3A_lag">lag</code></td>
<td>
<p>Number of lags to include in each regime</p>
</td></tr>
<tr><td><code id="TVECM_+3A_nthresh">nthresh</code></td>
<td>
<p>number of threshold (see details)</p>
</td></tr>
<tr><td><code id="TVECM_+3A_trim">trim</code></td>
<td>
<p>trimming parameter indicating the minimal percentage of
observations in each regime</p>
</td></tr>
<tr><td><code id="TVECM_+3A_ngridbeta">ngridBeta</code></td>
<td>
<p>number of elements to search for the cointegrating value</p>
</td></tr>
<tr><td><code id="TVECM_+3A_ngridth">ngridTh</code></td>
<td>
<p>number of elements to search for the threshold value</p>
</td></tr>
<tr><td><code id="TVECM_+3A_plot">plot</code></td>
<td>
<p>Whether the grid with the SSR of each threshold should be plotted.</p>
</td></tr>
<tr><td><code id="TVECM_+3A_th1">th1</code></td>
<td>
<p>different possibilities to pre-specify an exact value, an interval
or a central point for the search of the threshold (or first threshold if
nthresh=2)</p>
</td></tr>
<tr><td><code id="TVECM_+3A_th2">th2</code></td>
<td>
<p>different possibilities to pre-specify an exact value or a central
point for the search of the second threshold (used only if nthresh=2)</p>
</td></tr>
<tr><td><code id="TVECM_+3A_beta">beta</code></td>
<td>
<p>different possibilities to pre-specify an exact value, an
interval or a central point for the search of the cointegrating value</p>
</td></tr>
<tr><td><code id="TVECM_+3A_restr">restr</code></td>
<td>
<p>Currently not available</p>
</td></tr>
<tr><td><code id="TVECM_+3A_common">common</code></td>
<td>
<p>Whether the regime-specific dynamics are only for the ECT or
for the ECT and the lags</p>
</td></tr>
<tr><td><code id="TVECM_+3A_include">include</code></td>
<td>
<p>Type of deterministic regressors to include</p>
</td></tr>
<tr><td><code id="TVECM_+3A_dummytobothregimes">dummyToBothRegimes</code></td>
<td>
<p>Whether the dummy in the one threshold model is
applied to each regime or not.</p>
</td></tr>
<tr><td><code id="TVECM_+3A_beta0">beta0</code></td>
<td>
<p>Additional regressors to include in the cointegrating relation</p>
</td></tr>
<tr><td><code id="TVECM_+3A_methodmapply">methodMapply</code></td>
<td>
<p>only for programming. Is to make the choice between a for
loop or <code>mapply</code> implementation</p>
</td></tr>
<tr><td><code id="TVECM_+3A_trace">trace</code></td>
<td>
<p>should additional infos be printed? (logical)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For fixed threshold and cointegrating vector, the model is linear, so
estimation of the regression parameters can be done directly by CLS
(Conditional Least Squares). The search of the threshold and cointegrating
parameters values which minimize the residual sum of squares (SSR) is made on
a grid of potential values. For specification of the grids, see below.
</p>
<p>The function can estimate one as well as two thresholds:
</p>
 <dl>
<dt>nthresh=1:</dt><dd><p> estimation of one threshold model (two regimes)
upon a grid of <var>ngridTh</var> values (default to ALL) possible thresholds and
delays values. </p>
</dd>
<dt>nthresh=2:</dt><dd><p>estimation of two thresholds model (three regimes).
Conditional on the threshold found in model where nthresh=1, the second
threshold is searched. When both are found, a second grid search is made with
30 values around each threshold.</p>
</dd> </dl>

<p>The model can be either with a threshold effect on all variables (&quot;All&quot;) or
only on the error correction term (ECT) (argument &quot;only ECT&quot;). In the second
case, the value for the middle threshold is taken a null, as in Balke and
Fomby (1997).
</p>
<p>The grid for the threshold parameters can be set in different ways, through
the argument <var>th1</var>, <var>th2</var> and <var>beta</var>:
</p>
 
<dl>
<dt>exact:</dt><dd><p>Pre-specified value (for beta: cointegrating vector will be c(1,<code>-beta</code>))</p>
</dd> 
<dt>int:</dt><dd><p>Specify an interval (of length <var>ngridTh</var>) in which to search.</p>
</dd>
<dt>around:</dt><dd><p>Specify to take <var>ngridTh</var> points around the value given. </p>
</dd>
</dl>

<p>The default is to do an interval search. Interval bounds for the threshold
interval are simply the <var>trim</var> and 1-<var>trim</var> percents of the sorted
error correction term.  For the cointegrating parameter, bounds of the
interval are obtained from the (OLS) confidence interval of the linear
cointegration case.  It is often found however that this interval is too
tight. It is hence recommended to inspect the plot of the grid search.
</p>


<h3>Value</h3>

<p>Fitted model data
</p>


<h3>Author(s)</h3>

<p>Matthieu Stigler
</p>


<h3>References</h3>

<p>Hansen, B. and Seo, B. (2002), Testing for two-regime threshold
cointegration in vector error-correction models, Journal of Econometrics,
110, pages 293 - 318
</p>
<p>Seo, M. H. (2009) Estimation of non linear error-correction models, Working
paper
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VECM">VECM</a></code> for the linear VECM, <code><a href="#topic+TVAR">TVAR</a></code> for the
threshold VAR, <code><a href="#topic+TVECM.SeoTest">TVECM.SeoTest</a></code> to test for TVECM,
<code><a href="#topic+TVECM.sim">TVECM.sim</a></code> to simulate/bootstrap a TVECM.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(zeroyld)

##Estimate a TVECM (we use here minimal grid, it should be usually much bigger!)

tvec &lt;- TVECM(zeroyld, nthresh=2,lag=1, ngridBeta=20, ngridTh=30, plot=TRUE,trim=0.05, common="All")

print(tvec)
summary(tvec)

#Obtain diverse infos:
AIC(tvec)
BIC(tvec)

res.tvec&lt;-residuals(tvec)

#export the equations as Latex:
toLatex(tvec)

</code></pre>

<hr>
<h2 id='TVECM.HStest+20'>Test of linear cointegration vs threshold cointegration</h2><span id='topic+TVECM.HStest'></span>

<h3>Description</h3>

<p>Tests the null of linear cointegration against threshold cointegration following Hansen and Seo (2002). Fixed regressor and residual bootstrap are available. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TVECM.HStest(data, lag=1, ngridTh=300, trim=0.05, 
 nboot=100, fixed.beta=NULL,  intercept=TRUE, 
 boot.type=c("FixedReg", "ResBoot"), 
 hpc=c("none", "foreach"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TVECM.HStest+2B20_+3A_data">data</code></td>
<td>
<p>Time series </p>
</td></tr>
<tr><td><code id="TVECM.HStest+2B20_+3A_lag">lag</code></td>
<td>
<p>Number of lags to include in each regime</p>
</td></tr>
<tr><td><code id="TVECM.HStest+2B20_+3A_ngridth">ngridTh</code></td>
<td>
<p>Number of threshold grid points to evaluate the optimal threshold.</p>
</td></tr>
<tr><td><code id="TVECM.HStest+2B20_+3A_trim">trim</code></td>
<td>
<p>Trimming parameter indicating the minimal percentage of observations in each regime</p>
</td></tr>
<tr><td><code id="TVECM.HStest+2B20_+3A_nboot">nboot</code></td>
<td>
<p>Number of bootstrap replications</p>
</td></tr>
<tr><td><code id="TVECM.HStest+2B20_+3A_fixed.beta">fixed.beta</code></td>
<td>
<p>Numeric. User pre-specified cointegrating value, as in <code><a href="#topic+VECM">VECM</a></code> 
(i.e. cointegrating  vector will be c(1, <code>-beta.fixed</code>)). When NULL (default), the value is estimated from the linear VECM.</p>
</td></tr>
<tr><td><code id="TVECM.HStest+2B20_+3A_intercept">intercept</code></td>
<td>
<p>Logical. Whether an intercept has to be included in the VECM</p>
</td></tr>
<tr><td><code id="TVECM.HStest+2B20_+3A_boot.type">boot.type</code></td>
<td>
<p>Character. Type of bootstrap simulation (only if <code>nboot</code>&gt;0)</p>
</td></tr>
<tr><td><code id="TVECM.HStest+2B20_+3A_hpc">hpc</code></td>
<td>
<p>Possibility to run the bootstrap on parallel core. See details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This test follows the implementation done by Hansen and Seo (2002). The cointegrating value is estimated from the linear VECM. Then, conditional on this value, the LM test is run for a range of different threshold values. The maximum of those LM test values is reported. 
</p>
<p>Two bootstrap are available: a fixed regressor, as well as a usual residual bootstrap (using the function <code><a href="#topic+TVECM.sim">TVECM.sim</a></code>). 
</p>
<p>Available methods are <code>print()</code>, <code>summary()</code> and <code>plot()</code>. 
</p>
<p>With the argument <code>hpc</code>, the burdensome bootstrap replication can be run on parallel cores, thus alleviating the time of computation. The user needs simply to choose a package (among doMC, doMPI, doSNOW or doRedis) and register the backend. See the vignette for more details. 
</p>


<h3>Value</h3>

<p>A list containing diverse values:
</p>
<table>
<tr><td><code>stat</code></td>
<td>
<p>The sup-LM statistic.</p>
</td></tr>
<tr><td><code>values</code></td>
<td>
<p>The whole LM values.</p>
</td></tr>
<tr><td><code>PvalBoot</code></td>
<td>
<p>The bootstrap p-value</p>
</td></tr>
<tr><td><code>CriticalValBoot</code></td>
<td>
<p>The bootstrap critical values</p>
</td></tr>
<tr><td><code>allBoots</code></td>
<td>
<p>The boot sup-LM values</p>
</td></tr>
<tr><td><code>args</code></td>
<td>
<p>Some user given args (nboot, boot.type)</p>
</td></tr>
</table>


<h3>Reproducibility</h3>

<p>Comparison with original paper is made difficult as values of the test are not shown in the paper, only their critical values, which depend on random bootstrap. 
</p>
<p>Comparison is done with the GAUSS code available on the page of Bruce Hansen. Running tar_ci, we have the same sup-LM value when lags=1 and lags=2, a higher value with lag=3. When the test is run with pre-specified beta values, we have different results, sometimes higher but also smaller sup-LM value. 
</p>


<h3>Author(s)</h3>

<p>Matthieu Stigler</p>


<h3>References</h3>

<p>Hansen, B. and Seo, B. (2002), Testing for two-regime threshold cointegration in vector error-correction models, Journal of Econometrics, 110, pages 293 - 318
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zeroyld">zeroyld</a></code>: data used in the original paper of Hansen and Seo. 
</p>
<p><code><a href="#topic+TVECM.SeoTest">TVECM.SeoTest</a></code>: a similar test, but with null hypothesis of no-cointegration. 
</p>
<p><code><a href="#topic+TVECM">TVECM</a></code> for estimating a TVECM, <code><a href="#topic+TVECM.sim">TVECM.sim</a></code> for simulating/bootstrap a TVECM, 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Use original data from paper:
data(zeroyld)
dataPaper&lt;-zeroyld
# Test: nboot, number of bootstrap replications, should be high 
## Not run: 
test1&lt;-TVECM.HStest(dataPaper, lag=1, intercept=TRUE, nboot=1000)

## End(Not run)

#we use here for the example a much smaller number of bootstrap:
test1&lt;-TVECM.HStest(dataPaper, lag=1, intercept=TRUE, nboot=10)

test1
summary(test1)
plot(test1)

#can have only specific plots:
plot(test1, which="LM values")
plot(test1, which="Density")

## Run the function in parallel:
## Not run: 
#we show here the use with package doMC
library(doMC)
registerDoMC(2) #Number of cores
test1&lt;-TVECM.HStest(dataPaper, lag=1, intercept=TRUE, nboot=1000, hpc="foreach")

## End(Not run)

</code></pre>

<hr>
<h2 id='TVECM.SeoTest'>No cointegration vs threshold cointegration test</h2><span id='topic+TVECM.SeoTest'></span>

<h3>Description</h3>

<p>Test the null of no cointegration against threshold cointegration with
bootstrap distribution of Seo (2006)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TVECM.SeoTest(
  data,
  lag,
  beta,
  trim = 0.1,
  nboot,
  plot = FALSE,
  hpc = c("none", "foreach"),
  check = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TVECM.SeoTest_+3A_data">data</code></td>
<td>
<p>time series</p>
</td></tr>
<tr><td><code id="TVECM.SeoTest_+3A_lag">lag</code></td>
<td>
<p>Number of lags to include in each regime</p>
</td></tr>
<tr><td><code id="TVECM.SeoTest_+3A_beta">beta</code></td>
<td>
<p>Pre-specified cointegrating value (i.e. cointegrating  vector will be c(1, <code>-beta</code>))</p>
</td></tr>
<tr><td><code id="TVECM.SeoTest_+3A_trim">trim</code></td>
<td>
<p>trimming parameter indicating the minimal percentage of
observations in each regime</p>
</td></tr>
<tr><td><code id="TVECM.SeoTest_+3A_nboot">nboot</code></td>
<td>
<p>Number of bootstrap replications</p>
</td></tr>
<tr><td><code id="TVECM.SeoTest_+3A_plot">plot</code></td>
<td>
<p>Whether a grid with the SSR of each threshold should be printed</p>
</td></tr>
<tr><td><code id="TVECM.SeoTest_+3A_hpc">hpc</code></td>
<td>
<p>Possibility to run the bootstrap on parallel core. See details in
<code><a href="#topic+TVECM.HStest">TVECM.HStest</a></code></p>
</td></tr>
<tr><td><code id="TVECM.SeoTest_+3A_check">check</code></td>
<td>
<p>Possibility to check the function by no sampling: the test value
should be the same as in the original data</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For this test, the cointegrating value has to be specified by the user.
</p>
<p>The model used is one where the threshold effect concerns only the
cointegrating vector, and only in the outer regimes.
</p>
<p>Due to the presence of parameters unidentified under the null hypothesis, the
test employed is a Sup-Wald test, that means that for each combination of the
thresholds, a Wald Test is computed and the supremum of all tests is taken.
For each bootstrap replication, this approach is taken, so that the test is
really slow.
</p>


<h3>Value</h3>

<p>A list containing diverse informations:
</p>
<p>Estimated threshold parameters and usual slope parameters.
</p>
<p>Value of the test.
</p>
<p>Critical and Pvalue from bootstrap distribution.
</p>


<h3>Author(s)</h3>

<p>Matthieu Stigler
</p>


<h3>References</h3>

<p>Seo, Myunghwan, 2006. &quot;Bootstrap testing for the null of no
cointegration in a threshold vector error correction model,&quot; Journal of
Econometrics, vol. 127(1), pages 129-150, September.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TVECM">TVECM</a></code> for estimating a TVECM, <code><a href="#topic+TVECM.sim">TVECM.sim</a></code>
for simulating/bootstrap a TVECM,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# As the function takes long long time to be executed, we show in in don't run environement
## Not run: 
data(zeroyld)

#can be useful to check whether the bootstrap is working: 
#without sampling, results of boot should be same as original
#this is indeed not always the case duye to floating point algorithm
TVECM.SeoTest(zeroyld,lag=2, beta=1, trim=0.1,nboot=2, plot=FALSE,check=TRUE)

#then run the function:
TVECM.SeoTest(zeroyld,lag=2, beta=1, trim=0.1,nboot=100, plot=FALSE,check=FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='TVECM.sim'>Simulation and bootstrap a VECM or bivariate TVECM</h2><span id='topic+TVECM.sim'></span><span id='topic+VECM.sim'></span><span id='topic+VECM.boot'></span><span id='topic+TVECM.boot'></span>

<h3>Description</h3>

<p>Estimate or bootstraps a multivariate Threshold VAR
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TVECM.sim(
  B,
  n = 200,
  lag = 1,
  include = c("const", "trend", "none", "both"),
  beta,
  nthresh = 1,
  Thresh,
  starting = NULL,
  innov = rmnorm(n, varcov = diag(1, nrow(B))),
  show.parMat = FALSE,
  returnStarting = FALSE,
  ...
)

VECM.sim(
  B,
  n = 200,
  lag = 1,
  include = c("const", "trend", "none", "both"),
  beta,
  starting = NULL,
  innov = rmnorm(n, varcov = diag(1, nrow(B))),
  show.parMat = FALSE,
  returnStarting = FALSE,
  ...
)

VECM.boot(
  object,
  boot.scheme = c("resample", "resample_block", "wild1", "wild2", "check"),
  seed = NULL,
  ...
)

TVECM.boot(
  object,
  boot.scheme = c("resample", "resample_block", "wild1", "wild2", "check"),
  seed = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TVECM.sim_+3A_b">B</code></td>
<td>
<p>Simulation: Matrix of coefficients to simulate</p>
</td></tr>
<tr><td><code id="TVECM.sim_+3A_n">n</code></td>
<td>
<p>Simulation: Number of observations to simulate.</p>
</td></tr>
<tr><td><code id="TVECM.sim_+3A_beta">beta</code></td>
<td>
<p>The cointegrating value</p>
</td></tr>
<tr><td><code id="TVECM.sim_+3A_thresh">Thresh</code>, <code id="TVECM.sim_+3A_nthresh">nthresh</code>, <code id="TVECM.sim_+3A_lag">lag</code>, <code id="TVECM.sim_+3A_include">include</code></td>
<td>
<p>Simulation: parameters for the VECM/TVECM to simulate. 
See <code><a href="#topic+TVECM">TVECM</a></code> for their description.</p>
</td></tr>
<tr><td><code id="TVECM.sim_+3A_starting">starting</code></td>
<td>
<p>Simulation: Starting values (same length as lag = 1)</p>
</td></tr>
<tr><td><code id="TVECM.sim_+3A_innov">innov</code></td>
<td>
<p>Simulation: time series of innovations/residuals.</p>
</td></tr>
<tr><td><code id="TVECM.sim_+3A_show.parmat">show.parMat</code></td>
<td>
<p>Logical. Whether to show how the parameter matrix B is interpreted.</p>
</td></tr>
<tr><td><code id="TVECM.sim_+3A_returnstarting">returnStarting</code></td>
<td>
<p>Logical. Whether to return the starting values.</p>
</td></tr>
<tr><td><code id="TVECM.sim_+3A_...">...</code></td>
<td>
<p>additional arguments for the unexported <code>TVECM.gen</code>.</p>
</td></tr>
<tr><td><code id="TVECM.sim_+3A_object">object</code></td>
<td>
<p>Object computed by function <code><a href="#topic+TVECM">TVECM</a></code>
or linear <code><a href="#topic+VECM">VECM</a></code></p>
</td></tr>
<tr><td><code id="TVECM.sim_+3A_boot.scheme">boot.scheme</code></td>
<td>
<p>Bootstrap: which resampling scheme to use for the residuals. See <code><a href="#topic+resample_vec">resample_vec</a></code>.</p>
</td></tr>
<tr><td><code id="TVECM.sim_+3A_seed">seed</code></td>
<td>
<p>Bootstrap: seed used in the resampling</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function offers the possibility to generate series following a
VECM/TVECM from two approaches: bootstrap or simulation. <code>VECM.sim</code> is
just a wrapper for <code><a href="#topic+TVECM.sim">TVECM.sim</a></code>.
</p>
<p>When the argument <code>matrix</code> is given, on can only simulate a VECM
(<code>nthresh</code>=0) or TVECM (<code>nthresh</code>=1 or 2). One can have a
specification with constant (<code>"const"</code>), <code>"trend"</code>, <code>"both"</code>
or <code>"none"</code> (see argument <code>include</code>). Order for the parameters is
ECT/include/lags for VECM and ECT1/include1/lags1/ECT2/include2/lags2 for
TVECM. To be sure that once is using it correctly, setting <code>show.parMat
= TRUE</code> will show the matrix of parameters together with their values and
names.
</p>
<p>The argument <code>beta</code> is the cointegrating value on the right side of the
long-run relationship, and hence the function use the vector (1,-beta). The
<code>innov</code> argument specifies the innovations. It should be given as a
matrix of dim nxk, (here <var>n</var> does not include the starting values!), by
default it uses a multivariate normal distribution, with covariance matrix
specified by <code>varcov</code>.
</p>
<p>The starting values (of dim lags x k) can be given through argument
<code>starting</code>. The user should take care for their choice, since it is not
sure that the simulated values will cross the threshold even once. Notice
that only one cointegrating value is allowed. User interested in simulating a
VECM with more cointegrating values should do use the VAR representation and
use <code><a href="#topic+TVAR.sim">TVAR.sim</a></code>.
</p>
<p>The second possibility is to bootstrap series. This is done on a object
generated by <code><a href="#topic+TVECM">TVECM</a></code> (or <code><a href="#topic+VECM">VECM</a></code>). A simple residual
bootstrap is done, or one can simulate a series with the same parameter
matrix and with normal distributed residuals (with variance pre-specified),
corresponding to Monte-carlo simulations.
</p>
<p>One can alternatively give only the series, and then the function will call
internally <code><a href="#topic+TVECM">TVECM</a></code>.
</p>


<h3>Value</h3>

<p>A matrix with the simulated/bootstrapped series.
</p>


<h3>Author(s)</h3>

<p>Matthieu Stigler
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VECM">VECM</a></code> or <code><a href="#topic+TVECM">TVECM</a></code> to estimate the VECM or TVECM.  
Similar <code><a href="#topic+TVAR.sim">TVAR.sim</a></code> and <code><a href="#topic+TVAR.boot">TVAR.boot</a></code> for <code><a href="#topic+TVAR">TVAR</a></code>, 
<code><a href="#topic+VAR.sim">VAR.sim</a></code> and <code><a href="#topic+VAR.boot">VAR.boot</a></code> for VAR models estimated with <code><a href="#topic+lineVar">lineVar</a></code> models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

###reproduce example in Enders (2004, 2 edition) p. 350, 
# (similar example in Enders (2010, 3 edition) 301-302). 

if(require(mnormt)){
#see that the full "VAR" coefficient matrix is:
 A &lt;- matrix(c(-0.2, 0.2, 0.2, -0.2), byrow=TRUE, ncol=2)

# but this is not the input of VECM.sim. You should decompose into the a and b matrix:
 a&lt;-matrix(c(-0.2, 0.2), ncol=1)
 b&lt;-matrix(c(1,-1), nrow=1)

# so that:
 a%*%b

# The a matrix is the input under argument B, while the b matrix is under argument beta: 
# (the other zeros in B are for the not-specified lags)
 innov&lt;-rmnorm(100, varcov=diag(2))
 Bvecm &lt;- rbind(c(-0.2, 0,0), c(0.2, 0,0))
 vecm1 &lt;- VECM.sim(B=Bvecm, beta=1,n=100, lag=1,include="none", innov=innov)
 ECT &lt;- vecm1[,1]-vecm1[,2]

#add an intercept as in panel B
 Bvecm2 &lt;- rbind(c(-0.2, 0.1,0,0), c(0.2,0.4, 0,0))
 vecm2 &lt;- VECM.sim(B=Bvecm2,  n=100,beta=1, lag=1,include="const", innov=innov)

 par(mfrow=c(2,1))
 plot(vecm1[,1], type="l", main="Panel a: no drift or intercept", ylab="", xlab="")
 lines(vecm1[,2], lty=2)
 plot(vecm2[,1], type="l", main="Panel b: drift terms (0.1)", ylab="", xlab="")
 lines(vecm2[,2], lty=2)
}
##Bootstrap a TVAR with 1 threshold (two regimes)
data(zeroyld)
TVECMobject &lt;- TVECM(zeroyld, nthresh=1, lag=1, ngridBeta=20, ngridTh=20, plot=FALSE, trace = FALSE)
TVECM.boot(TVECMobject)

##Check the bootstrap: do we get original series, when not resampling residuals?
TVECM.boot.check &lt;- TVECM.boot(TVECMobject, boot.scheme = "check")
all.equal(as.data.frame(TVECM.boot.check), zeroyld)

</code></pre>

<hr>
<h2 id='UsUnemp'>US unemployment series used in <cite>Caner and Hansen (2001)</cite></h2><span id='topic+UsUnemp'></span>

<h3>Description</h3>

<p>This data, used as example in <cite>Caner and Hansen (2001)</cite>, contains the monthly US adult male unemployment from 1956 to 1999.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(UsUnemp)</code></pre>


<h3>Format</h3>

<p>A monthly time series of class <code>ts</code> starting in January 1956 and ending in August 1999.</p>


<h3>Source</h3>

<p>Caner and Hansen,Threshold autoregression with a unit root Econometrica, 2001, 69, 1555-1596
available at: <a href="http://www.ssc.wisc.edu/~bhansen/papers/cv.htm">http://www.ssc.wisc.edu/~bhansen/papers/cv.htm</a>
</p>

<hr>
<h2 id='VAR.sim'>Simulate or bootstrap a VAR model</h2><span id='topic+VAR.sim'></span><span id='topic+VAR.boot'></span>

<h3>Description</h3>

<p>Allow to either simulate from scratch (by providing coefficients) or bootstrap from an estimated VAR model,
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VAR.sim(
  B,
  n = 200,
  lag = 1,
  include = c("const", "trend", "none", "both"),
  starting = NULL,
  innov = rmnorm(n, varcov = varcov),
  varcov = diag(1, nrow(B)),
  show.parMat = FALSE,
  returnStarting = FALSE,
  ...
)

VAR.boot(
  VARobject,
  boot.scheme = c("resample", "wild1", "wild2", "check"),
  seed,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VAR.sim_+3A_b">B</code></td>
<td>
<p>Matrix of coefficients.</p>
</td></tr>
<tr><td><code id="VAR.sim_+3A_n">n</code></td>
<td>
<p>Number of observations to simulate</p>
</td></tr>
<tr><td><code id="VAR.sim_+3A_lag">lag</code></td>
<td>
<p>Number of lags of the VAR to simulate</p>
</td></tr>
<tr><td><code id="VAR.sim_+3A_include">include</code></td>
<td>
<p>Type of deterministic regressors to include in the VAR to simulate</p>
</td></tr>
<tr><td><code id="VAR.sim_+3A_starting">starting</code></td>
<td>
<p>Starting values (matrix of dimension lag x k) for the VAR to simulate. If not given,
set to zero.</p>
</td></tr>
<tr><td><code id="VAR.sim_+3A_innov">innov</code></td>
<td>
<p>Innovations used for in the VAR to simulate. Should be matrix of dim n x k.
By default multivariate normal.</p>
</td></tr>
<tr><td><code id="VAR.sim_+3A_varcov">varcov</code></td>
<td>
<p>Variance-covariance matrix for the innovations. By default
identity matrix.</p>
</td></tr>
<tr><td><code id="VAR.sim_+3A_show.parmat">show.parMat</code></td>
<td>
<p>Logical. Should the parameter matrix be shown? Useful to
understand how to give right input</p>
</td></tr>
<tr><td><code id="VAR.sim_+3A_returnstarting">returnStarting</code></td>
<td>
<p>Whether starting values are returned. Default to FALSE</p>
</td></tr>
<tr><td><code id="VAR.sim_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the underlying (un-exported)
<code>VAR.gen</code> function</p>
</td></tr>
<tr><td><code id="VAR.sim_+3A_varobject">VARobject</code></td>
<td>
<p>Object of class <code> VAR</code> generated by function
<code><a href="#topic+lineVar">lineVar</a></code></p>
</td></tr>
<tr><td><code id="VAR.sim_+3A_boot.scheme">boot.scheme</code></td>
<td>
<p>The bootstrap scheme. See details.</p>
</td></tr>
<tr><td><code id="VAR.sim_+3A_seed">seed</code></td>
<td>
<p>Optional. Seed for the random resampling function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the bootstrap, the function resamples data from a given VAR model generated by
<code><a href="#topic+lineVar">lineVar</a></code>, returning the resampled data. 
A residual recursive bootstrap is used, where one uses either a simple
resampling, or the Wild bootstrap, either with a normal distribution (wild1) or
inverting the sign randomly (wild2)
</p>


<h3>Value</h3>

<p>A matrix with the resampled series.
</p>


<h3>Author(s)</h3>

<p>Matthieu Stigler
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lineVar">lineVar</a></code> to estimate the VAR.  Similar <code><a href="#topic+TVECM.sim">TVECM.sim</a></code> and <code><a href="#topic+TVECM.boot">TVECM.boot</a></code> for <code><a href="#topic+TVECM">TVECM</a></code>, 
<code><a href="#topic+TVAR.sim">TVAR.sim</a></code> and <code><a href="#topic+TVAR.boot">TVAR.boot</a></code> for <code><a href="#topic+TVAR">TVAR</a></code> models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## VAR.sim: simulate VAR as in Enders 2004, p 268
B1&lt;-matrix(c(0.7, 0.2, 0.2, 0.7), 2)
var1 &lt;- VAR.sim(B=B1, n=100, include="none")
ts.plot(var1, type="l", col=c(1,2))


B2&lt;-rbind(c(0.5, 0.5, 0.5), c(0, 0.5, 0.5))
varcov&lt;-matrix(c(1,0.2, 0.3, 1),2)
var2 &lt;- VAR.sim(B=B2, n=100, include="const", varcov=varcov)
ts.plot(var2, type="l", col=c(1,2))

## VAR.boot: Bootstrap a VAR 
data(zeroyld)
mod &lt;- lineVar(data=zeroyld,lag=1)
VAR.boot(mod)


</code></pre>

<hr>
<h2 id='VARrep'>VAR representation</h2><span id='topic+VARrep'></span><span id='topic+VARrep.VECM'></span><span id='topic+VARrep.VAR'></span>

<h3>Description</h3>

<p>Show the VAR representation of a VECM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VARrep(object, ...)

## S3 method for class 'VECM'
VARrep(object, ...)

## S3 method for class 'VAR'
VARrep(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VARrep_+3A_object">object</code></td>
<td>
<p>An object of class &lsquo;VECM&rsquo; created by <code><a href="#topic+VECM">VECM</a></code>,
or of class &lsquo;VAR&rsquo; created by <code><a href="#topic+lineVar">lineVar</a></code></p>
</td></tr>
<tr><td><code id="VARrep_+3A_...">...</code></td>
<td>
<p>Currently not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the parameters of the VECM under their VAR
representation.
</p>


<h3>Author(s)</h3>

<p>Matthieu Stigler
</p>


<h3>References</h3>

<p>Hamilton (1994) <em>Time Series Analysis</em>, Princeton University
Press
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(barry)

# VECM model:
mod_vecm &lt;- VECM(barry, lag=2, estim="ML")
VARrep(mod_vecm)

# VAR model:
mod_var &lt;- lineVar(barry, lag=2, I="diff")
VARrep(mod_var)


</code></pre>

<hr>
<h2 id='VECM'>Estimation of Vector error correction model (VECM)</h2><span id='topic+VECM'></span>

<h3>Description</h3>

<p>Estimate a VECM by either Engle-Granger (2OLS) or Johansen (MLE) method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VECM(
  data,
  lag,
  r = 1,
  include = c("const", "trend", "none", "both"),
  beta = NULL,
  estim = c("2OLS", "ML"),
  LRinclude = c("none", "const", "trend", "both"),
  exogen = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VECM_+3A_data">data</code></td>
<td>
<p>multivariate time series (first row being first=oldest value)</p>
</td></tr>
<tr><td><code id="VECM_+3A_lag">lag</code></td>
<td>
<p>Number of lags (in the VECM representation, see Details)</p>
</td></tr>
<tr><td><code id="VECM_+3A_r">r</code></td>
<td>
<p>Number of cointegrating relationships</p>
</td></tr>
<tr><td><code id="VECM_+3A_include">include</code></td>
<td>
<p>Type of deterministic regressors to include</p>
</td></tr>
<tr><td><code id="VECM_+3A_beta">beta</code></td>
<td>
<p>for VECM only: user-specified cointegrating values, the cointegrating vector will be
taken as: (1, -<code>beta</code>)
If NULL, will be estimated using the estimator specified in <code>estim</code></p>
</td></tr>
<tr><td><code id="VECM_+3A_estim">estim</code></td>
<td>
<p>Type of estimator: <code>2OLS</code> for the two-step approach or
<code>ML</code> for Johansen MLE</p>
</td></tr>
<tr><td><code id="VECM_+3A_lrinclude">LRinclude</code></td>
<td>
<p>Type of deterministic regressors to include in the long-term
relationship. Can also be a matrix with exogeneous regressors (2OLS only).</p>
</td></tr>
<tr><td><code id="VECM_+3A_exogen">exogen</code></td>
<td>
<p>Inclusion of exogenous variables (first row being first=oldest
value). Is either of same size than data (then automatically cut) or than
end-sample.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is just a wrapper for the <code><a href="#topic+lineVar">lineVar</a></code>, with
model=&quot;VECM&quot;.
</p>
<p>More comprehensive functions for VECM are in package <span class="pkg">vars</span>. 
Differences with that package are: </p>
 <dl>
<dt>Engle-Granger
estimator</dt><dd><p>The Engle-Granger estimator is available</p>
</dd>
<dt>Presentation</dt><dd><p>Results are printed in a different ways, using a matrix
form</p>
</dd> <dt>lateX export</dt><dd><p>The matrix of coefficients can be exported to
latex, with or without standard-values and significance stars</p>
</dd>
<dt>Prediction</dt><dd><p>The <code>predict</code> method contains a <code>newdata</code>
argument allowing to compute rolling forecasts.</p>
</dd> </dl>

<p>Two estimators are available: the Engle-Granger two step approach
(<code>2OLS</code>) or the Johansen (<code>ML</code>). For the 2OLS, deterministic
regressors (or external variables if <code>LRinclude</code> is of class numeric) can be
added for the estimation of the cointegrating value and for the ECT. This is
only working when the beta value is not pre-specified.
</p>
<p>The arg beta is the cointegrating value, the cointegrating vector will be
taken as: (1, -beta).
</p>
<p>Note that the lag specification corresponds to the lags in the VECM
representation, not in the VAR (as is done in package vars or software
GRETL). Basically, a VAR with 2 lags corresponds here to a VECM with 1 lag.
The lag can be set to 0, although some methods (irf, fevd) won't work for this case.
</p>
<p>#'The arg <code>beta</code> allows to specify constrained cointegrating values, leading to
<code class="reqn">ECT= \beta^{'}X_{t-1}</code>. It should be specified as a <code class="reqn">K \times r</code> matrix. In case of
<code class="reqn">r=1</code>, can also be specified as a vector. Note that the vector should be normalised, 
with the first value to 1, and the next values showing the opposite sign in the long-run relationship <code class="reqn">- \beta</code>. 
In case the vector has <code class="reqn">K-1</code> values, this is what <code>lineVar</code> is doing, setting <code class="reqn">(1, - \beta)</code>. 
Note finally one should provide values for all
the coefficients (eventually except for special case of r=1 and k-1), if you want to provide only part of the 
parameters, and let the others be estimated, look at the functions in package urca. 
</p>
<p>The eigenvector matrix <code class="reqn">\beta</code> is normalised using the Phillips triangular representation, 
see Hamilton (1994, p. 576) and Juselius (2006, p. 216), see <code><a href="#topic+coefA">coefA</a></code> for more details.
</p>


<h3>Value</h3>

<p>An object of class <code>VECM</code> (and higher classes <code>VAR</code> and
<code>nlVar</code>) with methods: 
</p>
 
<dl>
<dt>Usual methods:</dt><dd><p>Print, summary,  residuals, fitted, vcov</p>
</dd> 
<dt>Fit criteria:</dt><dd><p>AIC, BIC, <code><a href="#topic+MAPE">MAPE</a></code>, <code><a href="#topic+mse">mse</a></code>, <code><a href="#topic+logLik.VECM">logLik</a></code>
(the latter only for models estimated with MLE)</p>
</dd> 
<dt>Prediction:</dt><dd><p>predict and <code><a href="#topic+predict_rolling">predict_rolling</a></code></p>
</dd> 
<dt>coef extraction:</dt><dd><p>Extract cointegrating/adjustment coefficients, <code><a href="#topic+coefA">coefA</a></code>, <code><a href="#topic+coefB">coefB</a></code> <code><a href="#topic+coefPI">coefPI</a></code></p>
</dd> 
<dt>VAR/VECM methods:</dt><dd><p>Impulse response function (<code><a href="#topic+irf.VECM">irf.VECM</a></code>) and forecast error variance
decomposition (<code><a href="#topic+fevd.nlVar">fevd</a></code>)</p>
</dd> 
<dt>LaTeX:</dt><dd><p>toLatex</p>
</dd> </dl>



<h3>Author(s)</h3>

<p>Matthieu Stigler
</p>


<h3>References</h3>

<p>Hamilton (1994) Time Series Analysis, Princeton University Press
</p>
<p>Juselius (2006) The Cointegrated VAR model, Oxford University Press
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coefA">coefA</a></code>, <code><a href="#topic+coefB">coefB</a></code> and <code><a href="#topic+coefPI">coefPI</a></code> 
to extract the relevant parameter matrices. 
</p>
<p><code><a href="#topic+lineVar">lineVar</a></code> <code><a href="#topic+TVAR">TVAR</a></code> and <code><a href="#topic+TVECM">TVECM</a></code> for
the corresponding threshold models. <code><a href="#topic+linear">linear</a></code> for the univariate AR
model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(zeroyld)
data&lt;-zeroyld

#Fit a VECM with Engle-Granger 2OLS estimator:
vecm.eg&lt;-VECM(zeroyld, lag=2)

#Fit a VECM with Johansen MLE estimator:
vecm.jo&lt;-VECM(zeroyld, lag=2, estim="ML")

#compare results with package vars:
if(require(vars)) {
 data(finland)
 #check long coint values
   all.equal(VECM(finland, lag=2, estim="ML", r=2)$model.specific$beta, 
             cajorls(ca.jo(finland, K=3, spec="transitory"), r=2)  $beta, check.attributes=FALSE)
# check OLS parameters
  all.equal(t(coefficients(VECM(finland, lag=2, estim="ML", r=2))), 
    coefficients(cajorls(ca.jo(finland, K=3, spec="transitory"), r=2)$rlm), check.attributes=FALSE)

}


##export to Latex
toLatex(vecm.eg)
toLatex(summary(vecm.eg))
options("show.signif.stars"=FALSE)
toLatex(summary(vecm.eg), parenthese="Pvalue")
options("show.signif.stars"=TRUE)



</code></pre>

<hr>
<h2 id='VECM_symbolic'>Virtual VECM model</h2><span id='topic+VECM_symbolic'></span>

<h3>Description</h3>

<p>Pedagogical tool to create a symbolic VECM model, i.e. just for
representation purpose.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VECM_symbolic(
  alpha,
  beta,
  lags,
  inc,
  include = c("none", "const", "trend", "both")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VECM_symbolic_+3A_alpha">alpha</code></td>
<td>
<p>Matrix of alpha speed adjustment coefficients.</p>
</td></tr>
<tr><td><code id="VECM_symbolic_+3A_beta">beta</code></td>
<td>
<p>Matrix of alpha, cointegrating coefficients.</p>
</td></tr>
<tr><td><code id="VECM_symbolic_+3A_lags">lags</code></td>
<td>
<p>Matrix containing the lags coefficients.</p>
</td></tr>
<tr><td><code id="VECM_symbolic_+3A_inc">inc</code></td>
<td>
<p>Matrix containing the include (see following arg.) coefficients.</p>
</td></tr>
<tr><td><code id="VECM_symbolic_+3A_include">include</code></td>
<td>
<p>Character indicating the type of deterministic term included,
if any.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &lsquo;VECM&rsquo;, without however any data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

 a&lt;-matrix(c(-0.4, 0.1), ncol=1)
 b&lt;-matrix(c(1, -2), ncol=2)

 # VECM_symb(alpha=a, beta=t(b))
 d&lt;- VECM_symbolic(alpha=a, beta=t(b))
 VARrep(d)
 d&lt;- VECM_symbolic(alpha=a, beta=t(b), lags=matrix(0, ncol=2, nrow=2))
 VARrep(d)
 LagMat &lt;- matrix(c(0.1, 0.3, 0.1, 0.2), ncol=2, nrow=2)
 incMat &lt;- matrix(c(0.5, 0.1), ncol=1)
 d3&lt;- VECM_symbolic(alpha=a, beta=t(b), lags=LagMat, inc=incMat, include="const")
 VARrep(d3)


</code></pre>

<hr>
<h2 id='zeroyld'>zeroyld time series</h2><span id='topic+zeroyld'></span><span id='topic+zeroyldMeta'></span>

<h3>Description</h3>

<p>U.S. Term Structure Data, 1951-1991. Dataset used by Hansen and Seo (2002). The data contains the 12 month short rate and 120 month long rate. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zeroyld
zeroyldMeta
</code></pre>


<h3>Format</h3>

<p><code>zeroyld</code> contains two variables, while <code>zeryldMeta</code> contains also <code>Year</code> and <code>Month</code> columns. 
</p>
<p><code>zeroyld</code> is a data frame with 482 observations and 2 variables:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>short.run</code>  </td><td style="text-align: left;"> numeric  </td><td style="text-align: left;"> Short term, 12 month</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>long.run</code>   </td><td style="text-align: left;"> numeric  </td><td style="text-align: left;"> Long term, 120 month
  </td>
</tr>

</table>



<h3>Source</h3>

<p>Hansen, B. and Seo, B. (2002), Testing for two-regime threshold cointegration in vector error-correction models, Journal of Econometrics, 110, pages 293 - 318
</p>
<p>The data can be downloaded from: <a href="http://www.ssc.wisc.edu/~bhansen/progs/joe_02r.zip">http://www.ssc.wisc.edu/~bhansen/progs/joe_02r.zip</a>.
</p>
<p>The authors themselves took the data from the webpage of Huston McCulloch:
<a href="https://www.asc.ohio-state.edu/mcculloch.2/ts/mcckwon/mccull.htm">https://www.asc.ohio-state.edu/mcculloch.2/ts/mcckwon/mccull.htm</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TVECM.HStest">TVECM.HStest</a></code>: Hansen and Seo test. 
</p>
<p><code><a href="#topic+TVECM">TVECM</a></code> for estimating a TVECM.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(zeroyldMeta)
plot(zeroyldMeta$Date, zeroyldMeta$short.run, type = "l", xlab = "Date", ylab ="Rate")
lines(zeroyldMeta$Date, zeroyldMeta$long.run, lty = 2)
legend("topleft", lty = c(1, 2), legend = c("Short rate: 12 months", "Long rate: 120 months"))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
