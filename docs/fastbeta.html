<!DOCTYPE html><html lang="en"><head><title>Help for package fastbeta</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fastbeta}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#fastbeta-package'><p><span class="rlang"><b>R</b></span> Package <span class="pkg">fastbeta</span></p></a></li>
<li><a href='#deconvolve'><p>Richardson-Lucy Deconvolution</p></a></li>
<li><a href='#fastbeta'><p>Estimate a Time-Varying Infectious Disease Transmission Rate</p></a></li>
<li><a href='#fastbeta-defunct'><p>Defunct Functions in Package <span class="pkg">fastbeta</span></p></a></li>
<li><a href='#fastbeta-deprecated'><p>Deprecated Functions in Package <span class="pkg">fastbeta</span></p></a></li>
<li><a href='#fastbeta-notyet'><p>Not Yet Implemented Functions in Package <span class="pkg">fastbeta</span></p></a></li>
<li><a href='#fastbeta.bootstrap'><p>Parametric Bootstrapping</p></a></li>
<li><a href='#fastbeta.matrix'><p>Calculate Coefficient Matrix for Iteration Step</p></a></li>
<li><a href='#ptpi'><p>Peak to Peak Iteration</p></a></li>
<li><a href='#seir'><p>Simulate Infectious Disease Time Series</p></a></li>
<li><a href='#seir.auxiliary'><p>Auxiliary Functions for the SEIR Model without Forcing</p></a></li>
<li><a href='#seir.library'><p>Often Used Simulations</p></a></li>
<li><a href='#smallpox'><p>Smallpox Mortality in London, England, 1661-1930</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.3.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-11-22</td>
</tr>
<tr>
<td>Title:</td>
<td>Fast Approximation of Time-Varying Infectious Disease
Transmission Rates</td>
</tr>
<tr>
<td>Description:</td>
<td>
	A fast method for approximating time-varying infectious disease
	transmission rates from disease incidence time series and other
	data, based on a discrete time approximation of an SEIR model, as
	analyzed in Jagan et al. (2020) &lt;<a href="https://doi.org/10.1371%2Fjournal.pcbi.1008124">doi:10.1371/journal.pcbi.1008124</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/davidearn/fastbeta">https://github.com/davidearn/fastbeta</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/davidearn/fastbeta/issues">https://github.com/davidearn/fastbeta/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.3)</td>
</tr>
<tr>
<td>Imports:</td>
<td>grDevices, graphics, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>adaptivetau, deSolve, tools, utils</td>
</tr>
<tr>
<td>BuildResaveData:</td>
<td>no</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-11-22 16:30:52 UTC; mikael</td>
</tr>
<tr>
<td>Author:</td>
<td>Mikael Jagan <a href="https://orcid.org/0000-0002-3542-2938"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mikael Jagan &lt;jaganmn@mcmaster.ca&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-11-22 17:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='fastbeta-package'><span class="rlang"><b>R</b></span> Package <span class="pkg">fastbeta</span></h2><span id='topic+fastbeta-package'></span>

<h3>Description</h3>

<p>An <span class="rlang"><b>R</b></span> package for approximating time-varying infectious disease
transmission rates from disease incidence time series and other data.
</p>


<h3>Details</h3>

<p>The &ldquo;main&rdquo; function is <code><a href="#topic+fastbeta">fastbeta</a></code>.
</p>
<p>To render a list of available help topics, use
<code><a href="utils.html#topic+help">help</a>(package = "fastbeta")</code>.
</p>
<p>To report a bug or request a change, use
<code><a href="utils.html#topic+bug.report">bug.report</a>(package = "fastbeta")</code>.
</p>


<h3>Author(s)</h3>

<p>Mikael Jagan
<a href="mailto:jaganmn@mcmaster.ca">jaganmn@mcmaster.ca</a>
</p>

<hr>
<h2 id='deconvolve'>Richardson-Lucy Deconvolution</h2><span id='topic+deconvolve'></span>

<h3>Description</h3>

<p>Performs a modified Richardson-Lucy iteration for the purpose of
estimating incidence from reported incidence or mortality, conditional
on a reporting probability and on a distribution of the time to
reporting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deconvolve(x, prob = 1, delay = 1,
           start, tol = 1, iter.max = 32L, complete = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="deconvolve_+3A_x">x</code></td>
<td>

<p>a numeric vector of length <code>n</code> giving the number of infections or
deaths reported during <code>n</code> observation intervals of equal
duration.</p>
</td></tr>
<tr><td><code id="deconvolve_+3A_prob">prob</code></td>
<td>

<p>a numeric vector of length <code>d+n</code> such that <code>prob[d+i]</code> is
the probability that an infection during interval <code>i</code> is
eventually reported.  <code>prob</code> of length 1 is recycled.</p>
</td></tr>
<tr><td><code id="deconvolve_+3A_delay">delay</code></td>
<td>

<p>a numeric vector of length <code>d+1</code> such that <code>delay[j]</code> is the
probability that an infection during interval <code>i</code> is reported
during interval <code>i+j-1</code>, given that it is eventually reported.
<code>delay</code> need not sum to 1 but must not sum to 0.</p>
</td></tr>
<tr><td><code id="deconvolve_+3A_start">start</code></td>
<td>

<p>a numeric vector of length <code>d+n</code> giving a starting value for the
iteration.  <code>start[d+i]</code> estimates the expected number of
infections during interval <code>i</code> that are eventually reported.  If
missing, then a starting value is generated by padding <code>x</code> on the
left and right with <code>d-d0</code> and <code>d0</code> zeros, choosing
<code>d0 = which.max(delay)-1</code>.</p>
</td></tr>
<tr><td><code id="deconvolve_+3A_tol">tol</code></td>
<td>

<p>a tolerance indicating a stopping condition; see the reference.</p>
</td></tr>
<tr><td><code id="deconvolve_+3A_iter.max">iter.max</code></td>
<td>

<p>the maximum number of iterations.</p>
</td></tr>
<tr><td><code id="deconvolve_+3A_complete">complete</code></td>
<td>

<p>a logical flag indicating if the result should preserve successive
updates to <code>start</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements:
</p>
<table role = "presentation">
<tr><td><code>value</code></td>
<td>

<p>the result of updating <code>start</code> <code>iter</code> times then dividing by
<code>prob</code>.  If <code>complete = TRUE</code>, then <code>value</code> is a
<code>(d+n)</code>-by-<code>(1+iter)</code> matrix containing <code>start</code> and the
<code>iter</code> successive updates, each divided by <code>prob</code>.</p>
</td></tr>
<tr><td><code>chisq</code></td>
<td>

<p>the chi-squared statistics corresponding to <code>value</code>.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>

<p>the number of iterations performed.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Goldstein, E., Dushoff, J., Ma, J., Plotkin, J. B., Earn, D. J. D.,
&amp; Lipsitch, M. (2020).
Reconstructing influenza incidence by deconvolution of daily mortality
time series.
<em>Proceedings of the National Academy of Sciences U. S. A.</em>,
<em>106</em>(51), 21825-21829.
<a href="https://doi.org/10.1073/pnas.0902958106">doi:10.1073/pnas.0902958106</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(2L)
n &lt;- 200L
d &lt;- 50L
p &lt;- 0.1
prob &lt;- plogis(rlogis(d + n, location = qlogis(p), scale = 0.1))
delay &lt;- diff(pgamma(0L:(d + 1L), 12, 0.4))

h &lt;- function (x, a = 1, b = 1, c = 0) a * exp(-b * (x - c)^2)
ans &lt;- floor(h(seq(-60, 60, length.out = d + n), a = 1000, b = 0.001))

x0 &lt;- rbinom(d + n, ans, prob)
x &lt;- tabulate(rep.int(1L:(d + n), x0) +
              sample(0L:d, size = sum(x0), replace = TRUE, prob = delay),
              d + n)[-(1L:d)]

str(D0 &lt;- deconvolve(x, prob, delay, complete = FALSE))
str(D1 &lt;- deconvolve(x, prob, delay, complete =  TRUE))

matplot(-(d - 1L):n,
        cbind(x0, c(rep.int(NA, d), x), prob * D0[["value"]], p * ans),
        type = c("p", "p", "p", "l"),
        col = c(1L, 1L, 2L, 4L), pch = c(16L, 1L, 16L, NA),
        lty = c(0L, 0L, 0L, 1L), lwd = c(NA, NA, NA, 3L),
        xlab = "Time", ylab = "Count")
legend("topleft", NULL,
       c("actual", "actual+delay", "actual+delay+deconvolution", "p*h"),
       col = c(1L, 1L, 2L, 4L), pch = c(16L, 1L, 16L, NA),
       lty = c(0L, 0L, 0L, 1L), lwd = c(NA, NA, NA, 3L),
       bty = "n")

plot(0L:D1[["iter"]], D1[["chisq"]], xlab = "Iterations", ylab = quote(chi^2))
abline(h = 1, lty = 2L)
</code></pre>

<hr>
<h2 id='fastbeta'>Estimate a Time-Varying Infectious Disease Transmission Rate</h2><span id='topic+fastbeta'></span>

<h3>Description</h3>

<p>Generates a discrete approximation of a time-varying infectious disease
transmission rate from an equally spaced disease incidence time series
and other data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fastbeta(series, sigma = 1, gamma = 1, delta = 0,
         m = 1L, n = 1L, init, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fastbeta_+3A_series">series</code></td>
<td>

<p>a &ldquo;multiple time series&rdquo; object, inheriting from class
<code><a href="stats.html#topic+ts">mts</a></code>, with three columns storing (&ldquo;parallel&rdquo;,
equally spaced) time series of incidence, births, and the per capita
natural mortality rate, in that order.</p>
</td></tr>
<tr><td><code id="fastbeta_+3A_sigma">sigma</code>, <code id="fastbeta_+3A_gamma">gamma</code>, <code id="fastbeta_+3A_delta">delta</code></td>
<td>

<p>non-negative numbers.  <code>m*sigma</code>, <code>n*gamma</code>, and
<code>delta</code> are the rates of removal from each latent, infectious,
and recovered compartment.</p>
</td></tr>
<tr><td><code id="fastbeta_+3A_m">m</code></td>
<td>

<p>a non-negative integer indicating a number of latent stages.</p>
</td></tr>
<tr><td><code id="fastbeta_+3A_n">n</code></td>
<td>

<p>a positive integer indicating a number of infectious stages.</p>
</td></tr>
<tr><td><code id="fastbeta_+3A_init">init</code></td>
<td>

<p>a numeric vector of length <code>1+m+n+1</code> giving an initial state with
compartments ordered as <code class="reqn">(S, E, I, R)</code>.</p>
</td></tr>
<tr><td><code id="fastbeta_+3A_...">...</code></td>
<td>

<p>optional arguments passed to <code><a href="#topic+deconvolve">deconvolve</a></code>, if the first
column of <code>series</code> represents <em>observed</em> incidence rather
than actual or estimated incidence.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm implemented by <code>fastbeta</code> is based on an SEIR model
with
</p>

<ul>
<li> <p><code class="reqn">m</code> latent stages
(<code class="reqn">E^{i}</code>, <code class="reqn">i = 1,\ldots,m</code>);
</p>
</li>
<li> <p><code class="reqn">n</code> infectious stages
(<code class="reqn">I^{j}</code>, <code class="reqn">j = 1,\ldots,n</code>);
</p>
</li>
<li><p> time-varying rates <code class="reqn">\beta</code>, <code class="reqn">\nu</code>, and <code class="reqn">\mu</code> of
transmission, birth, and natural death; and
</p>
</li>
<li><p> constant rates <code class="reqn">m \sigma</code>, <code class="reqn">n \gamma</code>, and <code class="reqn">\delta</code> of
removal from each latent, infectious, and recovered compartment, where
removal from the recovered compartment implies return to the
susceptible compartment (loss of immunity).
</p>
</li></ul>

<p>It is derived by linearizing of the system of ordinary differential
equations
</p>
<p style="text-align: center;"><code class="reqn">
  \begin{alignedat}{10}
  \text{d} &amp; S         &amp;{} / \text{d} t
  &amp;{} = {}&amp;     \delta &amp;R     &amp;{} - ( &amp;&amp; \lambda(t) &amp;{} + \mu(t)) S         &amp;{} + \nu(t) \\
  \text{d} &amp; E^{    1} &amp;{} / \text{d} t
  &amp;{} = {}&amp; \lambda(t) &amp;S     &amp;{} - ( &amp;&amp;   m \sigma &amp;{} + \mu(t)) E^{    1} &amp;{}          \\
  \text{d} &amp; E^{i + 1} &amp;{} / \text{d} t
  &amp;{} = {}&amp;   m \sigma &amp;E^{i} &amp;{} - ( &amp;&amp;   m \sigma &amp;{} + \mu(t)) E^{i + 1} &amp;{}          \\
  \text{d} &amp; I^{    1} &amp;{} / \text{d} t
  &amp;{} = {}&amp;   m \sigma &amp;E^{m} &amp;{} - ( &amp;&amp;   n \gamma &amp;{} + \mu(t)) I^{    1} &amp;{}          \\
  \text{d} &amp; I^{j + 1} &amp;{} / \text{d} t
  &amp;{} = {}&amp;   n \gamma &amp;I^{j} &amp;{} - ( &amp;&amp;   n \gamma &amp;{} + \mu(t)) I^{j + 1} &amp;{}          \\
  \text{d} &amp; R         &amp;{} / \text{d} t
  &amp;{} = {}&amp;   n \gamma &amp;I^{n} &amp;{} - ( &amp;&amp;     \delta &amp;{} + \mu(t)) R         &amp;{}
  \end{alignedat}
  \\
  \lambda(t) = \beta(t) \sum_{j} I^{j}
</code>
</p>

<p>and substituting actual or estimated incidence and births for definite
integrals of <code class="reqn">\lambda S</code> and <code class="reqn">\nu</code>.  This procedure yields a
system of linear difference equations from which one recovers a discrete
approximation of <code class="reqn">\beta</code>:
</p>
<p style="text-align: center;"><code class="reqn">
  \begin{alignedat}{17}
  &amp;E_{t + 1}^{    1}
  &amp;{} = {}&amp; [(1 - \tfrac{1}{2} ( &amp; m \sigma + \mu_{t})) &amp; E_{t}^{    1} &amp;       &amp;              &amp;            &amp;           &amp;       &amp;               &amp;   &amp;{} + Z_{t + 1} &amp;              ] &amp;{} /
  [1 + \tfrac{1}{2} ( &amp; m \sigma + \mu_{t + 1})] \\
  &amp;E_{t + 1}^{i + 1}
  &amp;{} = {}&amp; [(1 - \tfrac{1}{2} ( &amp; m \sigma + \mu_{t})) &amp; E_{t}^{i + 1} &amp;{} + {}&amp; \tfrac{1}{2} &amp; m \sigma ( &amp; E_{t}^{i} &amp;{} + {}&amp; E_{t + 1}^{i} &amp; ) &amp;               &amp;              ] &amp;{} /
  [1 + \tfrac{1}{2} ( &amp; m \sigma + \mu_{t + 1})] \\
  &amp;I_{t + 1}^{    1}
  &amp;{} = {}&amp; [(1 - \tfrac{1}{2} ( &amp; n \gamma + \mu_{t})) &amp; I_{t}^{    1} &amp;{} + {}&amp; \tfrac{1}{2} &amp; m \sigma ( &amp; E_{t}^{m} &amp;{} + {}&amp; E_{t + 1}^{m} &amp; ) &amp;               &amp;              ] &amp;{} /
  [1 + \tfrac{1}{2} ( &amp; n \gamma + \mu_{t + 1})] \\
  &amp;I_{t + 1}^{j + 1}
  &amp;{} = {}&amp; [(1 - \tfrac{1}{2} ( &amp; n \gamma + \mu_{t})) &amp; I_{t}^{j + 1} &amp;{} + {}&amp; \tfrac{1}{2} &amp; n \gamma ( &amp; I_{t}^{j} &amp;{} + {}&amp; I_{t + 1}^{j} &amp; ) &amp;               &amp;              ] &amp;{} /
  [1 + \tfrac{1}{2} ( &amp; n \gamma + \mu_{t + 1})] \\
  &amp;R_{t + 1}
  &amp;{} = {}&amp; [(1 - \tfrac{1}{2} ( &amp;   \delta + \mu_{t})) &amp; R_{t}         &amp;{} + {}&amp; \tfrac{1}{2} &amp; n \gamma ( &amp; I_{t}^{n} &amp;{} + {}&amp; I_{t + 1}^{n} &amp; ) &amp;               &amp;              ] &amp;{} /
  [1 + \tfrac{1}{2} ( &amp;   \delta + \mu_{t + 1})] \\
  &amp;S_{t + 1}
  &amp;{} = {}&amp; [(1 - \tfrac{1}{2} ( &amp;            \mu_{t})) &amp; S_{t}         &amp;{} + {}&amp; \tfrac{1}{2} &amp;   \delta ( &amp; R_{t}     &amp;{} + {}&amp; R_{t + 1}     &amp; ) &amp;{} - Z_{t + 1} &amp;{} + B_{t + 1}] &amp;{} /
  [1 + \tfrac{1}{2} ( &amp;            \mu_{t + 1})]
  \end{alignedat}
  \\
  \beta_{t} = (Z_{t} + Z_{t + 1}) / (2 S_{t} \sum_{j} I_{t}^{j})
</code>
</p>

<p>where we use the notation
</p>
<p style="text-align: center;"><code class="reqn">
  X_{t} \sim X(t) : X = S, E^{i}, I^{j}, R, Z, B, \mu, \beta \\
  \begin{aligned}
  Z(t) &amp;= \int_{t - 1}^{t} \lambda(s) S(s) \, \text{d} s \\
  B(t) &amp;= \int_{t - 1}^{t}          \nu(s) \, \text{d} s
  \end{aligned}
</code>
</p>

<p>and it is understood that the independent variable <code class="reqn">t</code> is a unitless
measure of time relative to the spacing of the substituted time series
of incidence and births.
</p>


<h3>Value</h3>

<p>A &ldquo;multiple time series&rdquo; object, inheriting from class
<code><a href="stats.html#topic+ts">mts</a></code>, with <code>1+m+n+1+1</code> columns (named <code>S</code>,
<code>E</code>, <code>I</code>, <code>R</code>, and <code>beta</code>) storing the result of the
iteration described in &lsquo;Details&rsquo;.  It is completely parallel to
argument <code>series</code>, having the same <code><a href="stats.html#topic+tsp">tsp</a></code> attribute.
</p>


<h3>References</h3>

<p>Jagan, M., deJonge, M. S., Krylova, O., &amp; Earn, D. J. D. (2020).
Fast estimation of time-varying infectious disease transmission rates.
<em>PLOS Computational Biology</em>,
<em>16</em>(9), Article e1008124, 1-39.
<a href="https://doi.org/10.1371/journal.pcbi.1008124">doi:10.1371/journal.pcbi.1008124</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("adaptivetau")) withAutoprint({

data(seir.ts02, package = "fastbeta")
a &lt;- attributes(seir.ts02)
str(seir.ts02)
plot(seir.ts02)

## We suppose that we have perfect knowledge of incidence,
## births, and the data-generating parameters
series &lt;- cbind(seir.ts02[, c("Z", "B")], mu = a[["mu"]](0))
colnames(series) &lt;- c("Z", "B", "mu") # FIXME: stats:::cbind.ts mangles dimnames

args &lt;- c(list(series = series),
          a[c("sigma", "gamma", "delta", "m", "n", "init")])
str(args)

X &lt;- do.call(fastbeta, args)
str(X)
plot(X)

plot(X[, "beta"], ylab = "Transmission rate")
lines(a[["beta"]](time(X)), col = "red") # the "truth"

})
</code></pre>

<hr>
<h2 id='fastbeta-defunct'>Defunct Functions in Package <span class="pkg">fastbeta</span></h2><span id='topic+fastbeta-defunct'></span>

<h3>Description</h3>

<p>The functions and other objects listed here are no longer part
of <span class="pkg">fastbeta</span> as they are no longer needed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Nothing yet!
</code></pre>


<h3>Details</h3>

<p>These either are stubs reporting that they are defunct or
have been removed completely (apart from being documented here).
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+Deprecated">Deprecated</a></code>, <code><a href="base.html#topic+base-deprecated">base-deprecated</a></code>,
<code><a href="#topic+fastbeta-deprecated">fastbeta-deprecated</a></code>, <code><a href="#topic+fastbeta-notyet">fastbeta-notyet</a></code>.
</p>

<hr>
<h2 id='fastbeta-deprecated'>Deprecated Functions in Package <span class="pkg">fastbeta</span></h2><span id='topic+fastbeta-deprecated'></span>

<h3>Description</h3>

<p>The functions and other objects listed here are provided only
for compatibility with older versions of <span class="pkg">fastbeta</span> and may
become defunct as soon as the next release.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Nothing yet!
</code></pre>


<h3>See Also</h3>

<p><code><a href="base.html#topic+Defunct">Defunct</a></code>, <code><a href="base.html#topic+base-defunct">base-defunct</a></code>,
<code><a href="#topic+fastbeta-defunct">fastbeta-defunct</a></code>, <code><a href="#topic+fastbeta-notyet">fastbeta-notyet</a></code>.
</p>

<hr>
<h2 id='fastbeta-notyet'>Not Yet Implemented Functions in Package <span class="pkg">fastbeta</span></h2><span id='topic+fastbeta-notyet'></span>

<h3>Description</h3>

<p>The functions listed here are defined but not yet implemented.
Use <code><a href="utils.html#topic+bug.report">bug.report</a>(package = "fastbeta")</code> to request
an implementation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Nothing yet!
</code></pre>


<h3>See Also</h3>

<p><code><a href="base.html#topic+NotYetImplemented">NotYetImplemented</a></code>,
<code><a href="#topic+fastbeta-deprecated">fastbeta-deprecated</a></code>, <code><a href="#topic+fastbeta-defunct">fastbeta-defunct</a></code>.
</p>

<hr>
<h2 id='fastbeta.bootstrap'>Parametric Bootstrapping</h2><span id='topic+fastbeta.bootstrap'></span>

<h3>Description</h3>

<p>A simple wrapper around <code><a href="#topic+fastbeta">fastbeta</a></code> using it to generate a
&ldquo;primary&rdquo; estimate of a time-varying transmission rate and
<code>r</code> bootstrap estimates.  Bootstrap estimates are computed for
incidence time series simulated using <code><a href="#topic+seir">seir</a></code>, with
transmission rate defined as the linear interpolant of the primary
estimate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fastbeta.bootstrap(r,
                   series, sigma = 1, gamma = 1, delta = 0,
                   m = 1L, n = 1L, init, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fastbeta.bootstrap_+3A_r">r</code></td>
<td>

<p>a non-negative integer indicating a number of replications.</p>
</td></tr>
<tr><td><code id="fastbeta.bootstrap_+3A_series">series</code></td>
<td>

<p>a &ldquo;multiple time series&rdquo; object, inheriting from class
<code><a href="stats.html#topic+ts">mts</a></code>, with three columns storing (&ldquo;parallel&rdquo;,
equally spaced) time series of incidence, births, and the per capita
natural mortality rate, in that order.</p>
</td></tr>
<tr><td><code id="fastbeta.bootstrap_+3A_sigma">sigma</code>, <code id="fastbeta.bootstrap_+3A_gamma">gamma</code>, <code id="fastbeta.bootstrap_+3A_delta">delta</code></td>
<td>

<p>non-negative numbers.  <code>m*sigma</code>, <code>n*gamma</code>, and
<code>delta</code> are the rates of removal from each latent, infectious,
and recovered compartment.</p>
</td></tr>
<tr><td><code id="fastbeta.bootstrap_+3A_m">m</code></td>
<td>

<p>a non-negative integer indicating a number of latent stages.</p>
</td></tr>
<tr><td><code id="fastbeta.bootstrap_+3A_n">n</code></td>
<td>

<p>a positive integer indicating a number of infectious stages.</p>
</td></tr>
<tr><td><code id="fastbeta.bootstrap_+3A_init">init</code></td>
<td>

<p>a numeric vector of length <code>1+m+n+1</code> giving an initial state with
compartments ordered as <code class="reqn">(S, E, I, R)</code>.</p>
</td></tr>
<tr><td><code id="fastbeta.bootstrap_+3A_...">...</code></td>
<td>

<p>optional arguments passed to <code><a href="#topic+seir">seir</a></code> and/or
<code><a href="#topic+deconvolve">deconvolve</a></code>.  Both take optional arguments <code>prob</code>
and <code>delay</code>.  When <code>prob</code> is supplied but not <code>delay</code>,
<code>seir</code> and <code>deconvolve</code> receive <code>prob</code> as is.  When
both are supplied, <code><a href="#topic+seir">seir</a></code> receives <code>prob</code> as is,
whereas <code><a href="#topic+deconvolve">deconvolve</a></code> receives <code>prob</code> augmented with
<code>length(delay)-1</code> ones.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A &ldquo;multiple time series&rdquo; object, inheriting from class
<code><a href="stats.html#topic+ts">mts</a></code>, with <code>1+r</code> columns storing the one primary
and <code>r</code> bootstrap estimates.  It is completely parallel to argument
<code>series</code>, having the same <code><a href="stats.html#topic+tsp">tsp</a></code> attribute.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("adaptivetau")) withAutoprint({

data(seir.ts02, package = "fastbeta")
a &lt;- attributes(seir.ts02)
str(seir.ts02)
plot(seir.ts02)

## We suppose that we have perfect knowledge of incidence,
## births, and the data-generating parameters
series &lt;- cbind(seir.ts02[, c("Z", "B")], mu = a[["mu"]](0))
colnames(series) &lt;- c("Z", "B", "mu") # FIXME: stats:::cbind.ts mangles dimnames

args &lt;- c(list(r = 100L, series = series),
          a[c("sigma", "gamma", "delta", "m", "n", "init")])
str(args)

R &lt;- do.call(fastbeta.bootstrap, args)
str(R)
plot(R)
plot(R, level = 0.95)

})
</code></pre>

<hr>
<h2 id='fastbeta.matrix'>Calculate Coefficient Matrix for Iteration Step</h2><span id='topic+fastbeta.matrix'></span>

<h3>Description</h3>

<p>Calculates the coefficient matrix corresponding to one step of the
iteration carried out by <code><a href="#topic+fastbeta">fastbeta</a></code>:
</p>
<pre>y &lt;- c(1, E, I, R, S)
for (pos in seq_len(nrow(series) - 1L)) {
    L &lt;- fastbeta.matrix(pos, series, ...)
    y &lt;- L %*% y
}
</pre>


<h3>Usage</h3>

<pre><code class='language-R'>fastbeta.matrix(pos,
                series, sigma = 1, gamma = 1, delta = 0,
                m = 1L, n = 1L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fastbeta.matrix_+3A_pos">pos</code></td>
<td>

<p>an integer indexing a row (but not the last row) of <code>series</code>.</p>
</td></tr>
<tr><td><code id="fastbeta.matrix_+3A_series">series</code></td>
<td>

<p>a &ldquo;multiple time series&rdquo; object, inheriting from class
<code><a href="stats.html#topic+ts">mts</a></code>, with three columns storing (&ldquo;parallel&rdquo;,
equally spaced) time series of incidence, births, and the per capita
natural mortality rate, in that order.</p>
</td></tr>
<tr><td><code id="fastbeta.matrix_+3A_sigma">sigma</code>, <code id="fastbeta.matrix_+3A_gamma">gamma</code>, <code id="fastbeta.matrix_+3A_delta">delta</code></td>
<td>

<p>non-negative numbers.  <code>m*sigma</code>, <code>n*gamma</code>, and
<code>delta</code> are the rates of removal from each latent, infectious,
and recovered compartment.</p>
</td></tr>
<tr><td><code id="fastbeta.matrix_+3A_m">m</code></td>
<td>

<p>a non-negative integer indicating a number of latent stages.</p>
</td></tr>
<tr><td><code id="fastbeta.matrix_+3A_n">n</code></td>
<td>

<p>a positive integer indicating a number of infectious stages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A lower triangular matrix of size <code>1+m+n+1+1</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("adaptivetau")) withAutoprint({

data(seir.ts02, package = "fastbeta")
a &lt;- attributes(seir.ts02); p &lt;- length(a[["init"]])
str(seir.ts02)
plot(seir.ts02)

## We suppose that we have perfect knowledge of incidence,
## births, and the data-generating parameters
series &lt;- cbind(seir.ts02[, c("Z", "B")], mu = a[["mu"]](0))
colnames(series) &lt;- c("Z", "B", "mu") # FIXME: stats:::cbind.ts mangles dimnames

args &lt;- c(list(series = series),
          a[c("sigma", "gamma", "delta", "init", "m", "n")])
str(args)

X &lt;- unclass(do.call(fastbeta, args))[, seq_len(p)]
colnames(X)
Y &lt;- Y. &lt;- cbind(1, X[, c(2L:p, 1L)], deparse.level = 2L)
colnames(Y)

args &lt;- c(list(pos = 1L, series = series),
          a[c("sigma", "gamma", "delta", "m", "n")])
str(args)

L &lt;- do.call(fastbeta.matrix, args)
str(L)
symnum(L != 0)

for (pos in seq_len(nrow(series) - 1L)) {
    args[["pos"]] &lt;- pos
    L. &lt;- do.call(fastbeta.matrix, args)
    Y.[pos + 1L, ] &lt;- L. %*% Y.[pos, ]
}
stopifnot(all.equal(Y, Y.))

})
</code></pre>

<hr>
<h2 id='ptpi'>Peak to Peak Iteration</h2><span id='topic+ptpi'></span>

<h3>Description</h3>

<p>Approximates the state of an SEIR model at a reference time from an
equally spaced, <code class="reqn">T</code>-periodic incidence time series and other data.
The algorithm relies on a strong assumption: that the incidence time
series was generated by the asymptotic dynamics of an SEIR model
admitting a locally stable, <code class="reqn">T</code>-periodic attractor.  Hence do
interpret with care.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ptpi(series, sigma = 1, gamma = 1, delta = 0,
     m = 1L, n = 1L, init,
     start = tsp(series)[1L], end = tsp(series)[2L],
     tol = 1e-03, iter.max = 32L,
     backcalc = FALSE, complete = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ptpi_+3A_series">series</code></td>
<td>

<p>a &ldquo;multiple time series&rdquo; object, inheriting from class
<code><a href="stats.html#topic+ts">mts</a></code>, with three columns storing (&ldquo;parallel&rdquo;,
equally spaced) time series of incidence, births, and the per capita
natural mortality rate, in that order.</p>
</td></tr>
<tr><td><code id="ptpi_+3A_sigma">sigma</code>, <code id="ptpi_+3A_gamma">gamma</code>, <code id="ptpi_+3A_delta">delta</code></td>
<td>

<p>non-negative numbers.  <code>m*sigma</code>, <code>n*gamma</code>, and
<code>delta</code> are the rates of removal from each latent, infectious,
and recovered compartment.</p>
</td></tr>
<tr><td><code id="ptpi_+3A_m">m</code></td>
<td>

<p>a non-negative integer indicating a number of latent stages.</p>
</td></tr>
<tr><td><code id="ptpi_+3A_n">n</code></td>
<td>

<p>a positive integer indicating a number of infectious stages.</p>
</td></tr>
<tr><td><code id="ptpi_+3A_init">init</code></td>
<td>

<p>a numeric vector of length <code>1+m+n+1</code> giving an initial guess for
the state at time <code>start</code>.</p>
</td></tr>
<tr><td><code id="ptpi_+3A_start">start</code>, <code id="ptpi_+3A_end">end</code></td>
<td>

<p>start and end times for the iteration, whose difference should be
approximately equal to an integer number of periods.  One often
chooses the time of the first peak in the incidence time series and
the time of the last peak in phase with the first.</p>
</td></tr>
<tr><td><code id="ptpi_+3A_tol">tol</code></td>
<td>

<p>a tolerance indicating a stopping condition; see &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="ptpi_+3A_iter.max">iter.max</code></td>
<td>

<p>the maximum number of iterations.</p>
</td></tr>
<tr><td><code id="ptpi_+3A_backcalc">backcalc</code></td>
<td>

<p>a logical indicating if the state at time <code>tsp(series)[1]</code> should
be back-calculated from the state at time <code>start</code> if that is
later.</p>
</td></tr>
<tr><td><code id="ptpi_+3A_complete">complete</code></td>
<td>

<p>a logical indicating if intermediate states should be recorded in an
array.  Useful mainly for didactic or diagnostic purposes.</p>
</td></tr>
<tr><td><code id="ptpi_+3A_...">...</code></td>
<td>

<p>optional arguments passed to <code><a href="#topic+deconvolve">deconvolve</a></code>, if the first
column of <code>series</code> represents <em>observed</em> incidence rather
than actual or estimated incidence.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ptpi</code> can be understood as an iterative application of
<code><a href="#topic+fastbeta">fastbeta</a></code> to a subset of <code>series</code>.  The basic
algorithm can be expressed in <span class="rlang"><b>R</b></span> code as:
</p>
<pre>w &lt;- window(series, start, end); i &lt;- nrow(s); j &lt;- seq_along(init)
diff &lt;- Inf; iter &lt;- 0L
while (diff &gt; tol &amp;&amp; iter &lt; iter.max) {
    init. &lt;- init
    init &lt;- fastbeta(w, sigma, gamma, delta, m, n, init)[i, j]
    diff &lt;- sqrt(sum((init - init.)^2) / sum(init.^2))
    iter &lt;- iter + 1L
}
value &lt;- init
</pre>
<p>Back-calculation involves solving a linear system of equations; the
back-calculated result can mislead if the system is ill-conditioned.
</p>


<h3>Value</h3>

<p>A list with elements:
</p>
<table role = "presentation">
<tr><td><code>value</code></td>
<td>

<p>an approximation of the state at time <code>start</code> or at time
<code>tsp(series)[1L]</code>, depending on <code>backcalc</code>.</p>
</td></tr>
<tr><td><code>diff</code></td>
<td>

<p>the relative difference between the last two approximations.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>

<p>the number of iterations performed.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>

<p>if <code>complete = TRUE</code>, then a &ldquo;multiple time series&rdquo;
object, inheriting from class <code><a href="stats.html#topic+ts">mts</a></code>, with
dimensions <code>c(nrow(w), length(value), iter)</code>, where
<code>w = window(series, start, end)</code>.  <code>x[, , k]</code> contains the
state at each <code>time(w)</code> in iteration <code>k</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Jagan, M., deJonge, M. S., Krylova, O., &amp; Earn, D. J. D. (2020).
Fast estimation of time-varying infectious disease transmission rates.
<em>PLOS Computational Biology</em>,
<em>16</em>(9), Article e1008124, 1-39.
<a href="https://doi.org/10.1371/journal.pcbi.1008124">doi:10.1371/journal.pcbi.1008124</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("deSolve")) withAutoprint({

data(seir.ts01, package = "fastbeta")
a &lt;- attributes(seir.ts01); p &lt;- length(a[["init"]])
str(seir.ts01)
plot(seir.ts01)

## We suppose that we have perfect knowledge of incidence,
## births, and the data-generating parameters, except for
## the initial state, which we "guess"
series &lt;- cbind(seir.ts01[, c("Z", "B")], mu = a[["mu"]](0))
colnames(series) &lt;- c("Z", "B", "mu") # FIXME: stats:::cbind.ts mangles dimnames

plot(series[, "Z"])
start &lt;- 23; end &lt;- 231
abline(v = c(start, end), lty = 2)

set.seed(0L)
args &lt;- c(list(series = series),
          a[c("sigma", "gamma", "delta", "m", "n", "init")],
          list(start = start, end = end, complete = TRUE))
init &lt;- seir.ts01[which.min(abs(time(seir.ts01) - start)), seq_len(p)]
args[["init"]] &lt;- init * rlnorm(p, 0, 0.1)
str(args)

L &lt;- do.call(ptpi, args)
str(L)

S &lt;- L[["x"]][, "S", ]
plot(S, plot.type = "single")
lines(seir.ts01[, "S"], col = "red", lwd = 4) # the "truth"
abline(h = L[["value"]]["S"], v = start, col = "blue", lwd = 4, lty = 2)

## Relative error
L[["value"]] / init - 1

})
</code></pre>

<hr>
<h2 id='seir'>Simulate Infectious Disease Time Series</h2><span id='topic+seir'></span><span id='topic+sir'></span>

<h3>Description</h3>

<p>Simulates incidence time series based on an SEIR model with user-defined
forcing and a simple model for observation error.
</p>
<p>Note that simulation code depends on availability of suggested packages
<span class="pkg">adaptivetau</span> and <span class="pkg">deSolve</span>.  If the dependency cannot be loaded
then an error is signaled.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seir(length.out = 1L,
     beta, nu = function(t) 0, mu = function(t) 0,
     sigma = 1, gamma = 1, delta = 0,
     m = 1L, n = 1L, init,
     stochastic = TRUE, prob = 1, delay = 1,
     aggregate = FALSE, useCompiled = TRUE, ...)

## A basic wrapper for the m=0L case:

 sir(length.out = 1L,
     beta, nu = function(t) 0, mu = function(t) 0,
     gamma = 1, delta = 0,
     n = 1L, init,
     stochastic = TRUE, prob = 1, delay = 1,
     aggregate = FALSE, useCompiled = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="seir_+3A_length.out">length.out</code></td>
<td>

<p>a non-negative integer indicating the time series length.</p>
</td></tr>
<tr><td><code id="seir_+3A_beta">beta</code>, <code id="seir_+3A_nu">nu</code>, <code id="seir_+3A_mu">mu</code></td>
<td>

<p>functions of one or more arguments returning transmission, birth, and
natural death rates at the time point indicated by the first argument.
Arguments after the first must be strictly optional.  The functions
need not be vectorized.</p>
</td></tr>
<tr><td><code id="seir_+3A_sigma">sigma</code>, <code id="seir_+3A_gamma">gamma</code>, <code id="seir_+3A_delta">delta</code></td>
<td>

<p>non-negative numbers.  <code>m*sigma</code>, <code>n*gamma</code>, and
<code>delta</code> are the rates of removal from each latent, infectious,
and recovered compartment.</p>
</td></tr>
<tr><td><code id="seir_+3A_m">m</code></td>
<td>

<p>a non-negative integer indicating a number of latent stages.</p>
</td></tr>
<tr><td><code id="seir_+3A_n">n</code></td>
<td>

<p>a positive integer indicating a number of infectious stages.</p>
</td></tr>
<tr><td><code id="seir_+3A_init">init</code></td>
<td>

<p>a numeric vector of length <code>1+m+n+1</code> giving an initial state with
compartments ordered as <code class="reqn">(S, E, I, R)</code>.</p>
</td></tr>
<tr><td><code id="seir_+3A_stochastic">stochastic</code></td>
<td>

<p>a logical indicating if the simulation should be stochastic; see
&lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="seir_+3A_prob">prob</code></td>
<td>

<p>a numeric vector of length <code>n</code> such that <code>prob[i]</code> is the
probability that an infection during interval <code>i</code> is eventually
observed.  <code>prob</code> of length 1 is recycled.</p>
</td></tr>
<tr><td><code id="seir_+3A_delay">delay</code></td>
<td>

<p>a numeric vector of positive length such that <code>delay[i]</code> is the
probability that an infection during interval <code>j</code> is observed
during interval <code>j+i-1</code>, given that it is eventually observed.
<code>delay</code> need not sum to 1 but must not sum to 0.</p>
</td></tr>
<tr><td><code id="seir_+3A_aggregate">aggregate</code></td>
<td>

<p>a logical indicating if latent and infectious compartments should be
aggregated.</p>
</td></tr>
<tr><td><code id="seir_+3A_usecompiled">useCompiled</code></td>
<td>

<p>a logical indicating if derivatives should be computed by compiled
C functions rather than by <span class="rlang"><b>R</b></span> functions (which <em>may</em>
be <em>byte</em>-compiled).  Set to <code>FALSE</code> only if <code>TRUE</code>
seems to cause problems, and in that case please report the problems
with <code><a href="utils.html#topic+bug.report">bug.report</a>(package = "fastbeta")</code>.</p>
</td></tr>
<tr><td><code id="seir_+3A_...">...</code></td>
<td>

<p>optional arguments passed to <code><a href="deSolve.html#topic+lsoda">lsoda</a></code> (directly)
or <code><a href="adaptivetau.html#topic+ssa.adaptivetau">ssa.adaptivetau</a></code> (via its list argument
<code>tl.params</code>), depending on <code>stochastic</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simulations are based on an SEIR model with
</p>

<ul>
<li> <p><code class="reqn">m</code> latent stages
(<code class="reqn">E^{i}</code>, <code class="reqn">i = 1,\ldots,m</code>);
</p>
</li>
<li> <p><code class="reqn">n</code> infectious stages
(<code class="reqn">I^{j}</code>, <code class="reqn">j = 1,\ldots,n</code>);
</p>
</li>
<li><p> time-varying rates <code class="reqn">\beta</code>, <code class="reqn">\nu</code>, and <code class="reqn">\mu</code> of
transmission, birth, and natural death; and
</p>
</li>
<li><p> constant rates <code class="reqn">m \sigma</code>, <code class="reqn">n \gamma</code>, and <code class="reqn">\delta</code> of
removal from each latent, infectious, and recovered compartment, where
removal from the recovered compartment implies return to the
susceptible compartment (loss of immunity).
</p>
</li></ul>

<p><code>seir(stochastic = FALSE)</code> works by numerically integrating the
system of ordinary differential equations
</p>
<p style="text-align: center;"><code class="reqn">
  \begin{alignedat}{10}
  \text{d} &amp; S         &amp;{} / \text{d} t
  &amp;{} = {}&amp;     \delta &amp;R     &amp;{} - ( &amp;&amp; \lambda(t) &amp;{} + \mu(t)) S         &amp;{} + \nu(t) \\
  \text{d} &amp; E^{    1} &amp;{} / \text{d} t
  &amp;{} = {}&amp; \lambda(t) &amp;S     &amp;{} - ( &amp;&amp;   m \sigma &amp;{} + \mu(t)) E^{    1} &amp;{}          \\
  \text{d} &amp; E^{i + 1} &amp;{} / \text{d} t
  &amp;{} = {}&amp;   m \sigma &amp;E^{i} &amp;{} - ( &amp;&amp;   m \sigma &amp;{} + \mu(t)) E^{i + 1} &amp;{}          \\
  \text{d} &amp; I^{    1} &amp;{} / \text{d} t
  &amp;{} = {}&amp;   m \sigma &amp;E^{m} &amp;{} - ( &amp;&amp;   n \gamma &amp;{} + \mu(t)) I^{    1} &amp;{}          \\
  \text{d} &amp; I^{j + 1} &amp;{} / \text{d} t
  &amp;{} = {}&amp;   n \gamma &amp;I^{j} &amp;{} - ( &amp;&amp;   n \gamma &amp;{} + \mu(t)) I^{j + 1} &amp;{}          \\
  \text{d} &amp; R         &amp;{} / \text{d} t
  &amp;{} = {}&amp;   n \gamma &amp;I^{n} &amp;{} - ( &amp;&amp;     \delta &amp;{} + \mu(t)) R         &amp;{}
  \end{alignedat}
  \\
  \lambda(t) = \beta(t) \sum_{j} I^{j}
</code>
</p>

<p>where it is understood that the independent variable <code class="reqn">t</code> is a
unitless measure of time relative to an observation interval.  To get
time series of incidence and births, the system is augmented with two
equations describing <em>cumulative</em> incidence and births
</p>
<p style="text-align: center;"><code class="reqn">
  \begin{aligned}
  \text{d} Z / \text{dt} &amp;{} = \lambda(t) S \\
  \text{d} B / \text{dt} &amp;{} = \nu(t)
  \end{aligned}
</code>
</p>

<p>and the <em>augmented</em> system is numerically integrated.
Observed incidence is simulated from incidence by scaling the latter
by <code>prob</code> and convolving the result with <code>delay</code>.
</p>
<p><code>seir(stochastic = TRUE)</code> works by simulating a Markov process
corresponding to the augmented system, as described in the reference.
Observed incidence is simulated from incidence by binning binomial
samples taken with probabilities <code>prob</code> over future observation
intervals according to multinomial samples taken with probabilities
<code>delay</code>.
</p>


<h3>Value</h3>

<p>A &ldquo;multiple time series&rdquo; object, inheriting from class
<code><a href="stats.html#topic+ts">mts</a></code>.  Beneath the class, it is a
<code>length.out</code>-by-<code>1+m+n+1+2</code> numeric matrix with columns
<code>S</code>, <code>E</code>, <code>I</code>, <code>R</code>, <code>Z</code>, and <code>B</code>, where
<code>Z</code> and <code>B</code> specify incidence and births as the number of
infections and births since the previous time point.
</p>
<p>If <code>prob</code> or <code>delay</code> is not missing, then there is an
additional column <code>Z.obs</code> specifying <em>observed</em> incidence as
the number of infections observed since the previous time point.
The first <code>length(delay)</code> elements of this column contain partial
counts.
</p>


<h3>References</h3>

<p>Cao, Y., Gillespie, D. T., &amp; Petzold, L. R. (2007).
Adaptive explicit-implicit tau-leaping method with
automatic tau selection.
<em>Journal of Chemical Physics</em>,
<em>126</em>(22), Article 224101, 1-9.
<a href="https://doi.org/10.1063/1.2745299">doi:10.1063/1.2745299</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seir.auxiliary">seir.auxiliary</a></code>, <code><a href="#topic+seir.library">seir.library</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("adaptivetau")) withAutoprint({

beta &lt;- function (t, a = 1e-01, b = 1e-05) b * (1 + a * sinpi(t / 26))
nu   &lt;- function (t) 1e+03
mu   &lt;- function (t) 1e-03

sigma &lt;- 0.5
gamma &lt;- 0.5
delta &lt;- 0

init &lt;- c(S = 50200, E = 1895, I = 1892, R = 946011)

length.out &lt;- 250L
prob &lt;- 0.1
delay &lt;- diff(pgamma(0:8, 2.5))

set.seed(0L)
X &lt;- seir(length.out, beta, nu, mu, sigma, gamma, delta, init = init,
          prob = prob, delay = delay, epsilon = 0.002)
##                                              ^^^^^
## default epsilon = 0.05 allows too big leaps =&gt; spurious noise
##
str(X)
plot(X)

r &lt;- 10L
Y &lt;- do.call(cbind, replicate(r, simplify = FALSE,
	seir(length.out, beta, nu, mu, sigma, gamma, delta, init = init,
	     prob = prob, delay = delay, epsilon = 0.002)[, "Z.obs"]))
str(Y) # FIXME: stats:::cbind.ts mangles dimnames
plot(window(Y, start = tsp(Y)[1L] + length(delay) / tsp(Y)[3L]),
     ##        ^^^^^
     ## discards points showing edge effects due to 'delay'
     ##
     plot.type = "single", col = seq_len(r), ylab = "Case reports")

})
</code></pre>

<hr>
<h2 id='seir.auxiliary'>Auxiliary Functions for the SEIR Model without Forcing</h2><span id='topic+seir.auxiliary'></span><span id='topic+seir.R0'></span><span id='topic+seir.ee'></span><span id='topic+seir.jacobian'></span>

<h3>Description</h3>

<p>Calculate the basic reproduction number, endemic equilibrium,
and Jacobian matrix of the SEIR model without forcing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seir.R0      (beta, nu = 0, mu = 0, sigma = 1, gamma = 1, delta = 0,
              m = 1L, n = 1L, N = 1)
seir.ee      (beta, nu = 0, mu = 0, sigma = 1, gamma = 1, delta = 0,
              m = 1L, n = 1L, N = 1)
seir.jacobian(beta, nu = 0, mu = 0, sigma = 1, gamma = 1, delta = 0,
              m = 1L, n = 1L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="seir.auxiliary_+3A_beta">beta</code>, <code id="seir.auxiliary_+3A_nu">nu</code>, <code id="seir.auxiliary_+3A_mu">mu</code>, <code id="seir.auxiliary_+3A_sigma">sigma</code>, <code id="seir.auxiliary_+3A_gamma">gamma</code>, <code id="seir.auxiliary_+3A_delta">delta</code></td>
<td>

<p>non-negative numbers.  <code>beta</code>, <code>nu</code>, and <code>mu</code> are the
rates of transmission, birth, and natural death.  <code>m*sigma</code>,
<code>n*gamma</code>, and <code>delta</code> are the rates of removal from each
latent, infectious, and recovered compartment.</p>
</td></tr>
<tr><td><code id="seir.auxiliary_+3A_m">m</code></td>
<td>

<p>a non-negative integer indicating a number of latent stages.</p>
</td></tr>
<tr><td><code id="seir.auxiliary_+3A_n">n</code></td>
<td>

<p>a positive integer indicating a number of infectious stages.</p>
</td></tr>
<tr><td><code id="seir.auxiliary_+3A_n">N</code></td>
<td>

<p>a non-negative number indicating a population size for the
<code>(nu == 0 &amp;&amp; mu == 0)</code> case.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code class="reqn">\mu, \nu = 0</code>, then the basic reproduction
number is computed as
</p>
<p style="text-align: center;"><code class="reqn">
  \mathcal{R}_{0} = N \beta / \gamma
</code>
</p>

<p>and the endemic equilibrium is computed as
</p>
<p style="text-align: center;"><code class="reqn">
  \begin{bmatrix}
  S^{\hphantom{1}} \\
  E^{i} \\
  I^{j} \\
  R^{\hphantom{1}}
  \end{bmatrix}
  =
  \begin{bmatrix}
  \gamma / \beta \\
  w \delta / (m \sigma) \\
  w \delta / (n \gamma) \\
  w
  \end{bmatrix}
</code>
</p>

<p>where <code class="reqn">w</code> is chosen so that the sum is <code class="reqn">N</code>.
</p>
<p>If <code class="reqn">\mu, \nu &gt; 0</code>, then the basic reproduction
number is computed as
</p>
<p style="text-align: center;"><code class="reqn">
  \mathcal{R}_{0} = \nu \beta a^{-m} (1 - b^{-n}) / \mu^{2}
</code>
</p>

<p>and the endemic equilibrium is computed as
</p>
<p style="text-align: center;"><code class="reqn">
  \begin{bmatrix}
  S^{\hphantom{1}} \\
  E^{i} \\
  I^{j} \\
  R^{\hphantom{1}}
  \end{bmatrix}
  =
  \begin{bmatrix}
  \mu a^{m} / (\beta (1 - b^{-n})) \\
  w a^{m - i} b^{n} (\delta + \mu) / (m \sigma) \\
  w b^{n - j} (\delta + \mu) / (n \gamma) \\
  w
  \end{bmatrix}
</code>
</p>

<p>where <code class="reqn">w</code> is chosen so that the sum is <code class="reqn">\nu / \mu</code>,
the population size at equilibrium, and
<code class="reqn">a = 1 + \mu / (m \sigma)</code> and
<code class="reqn">b = 1 + \mu / (n \gamma)</code>.
</p>
<p>Currently, none of the functions documented here are vectorized.
Arguments must have length 1.
</p>


<h3>Value</h3>

<p><code>seir.R0</code> returns a numeric vector of length 1.  <code>seir.ee</code>
returns a numeric vector of length <code>1+m+n+1</code>.  <code>seir.jacobian</code>
returns a function of one argument <code>x</code> (which must be a numeric
vector of length <code>1+m+n+1</code>) whose return value is a square numeric
matrix of size <code>length(x)</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seir">seir</a></code>, for the system of ordinary differential equations
on which these computations are predicated.
</p>

<hr>
<h2 id='seir.library'>Often Used Simulations</h2><span id='topic+seir.library'></span><span id='topic+seir.ts01'></span><span id='topic+seir.ts02'></span>

<h3>Description</h3>

<p>Infectious disease time series simulated using <code><a href="#topic+seir">seir</a></code>, for
use primarily in examples, tests, and vignettes.  Users should not rely
on simulation details, which may change between package versions.
</p>
<p>Note that simulation code depends on availability of suggested packages
<span class="pkg">adaptivetau</span> and <span class="pkg">deSolve</span>.  If the dependency cannot be loaded
then the value of the data set is <code>NULL</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## if (requireNamespace("deSolve"))
data(seir.ts01, package = "fastbeta")
## else ...

## if (requireNamespace("adaptivetau"))
data(seir.ts02, package = "fastbeta")
## else ...
</code></pre>


<h3>Format</h3>

<p>A &ldquo;multiple time series&rdquo; object, inheriting from class
<code><a href="stats.html#topic+ts">mts</a></code>, always a subset of the result of a call to
<code><a href="#topic+seir">seir</a></code>, discarding transient behaviour.  Simulation
parameters may be preserved as attributes.
</p>


<h3>Source</h3>

<p>Scripts sourced by <code><a href="utils.html#topic+data">data</a></code> to reproduce the simulations are
located in subdirectory &lsquo;<span class="file">data</span>&rsquo; of the <span class="pkg">fastbeta</span> installation;
see, e.g.
<code><a href="base.html#topic+system.file">system.file</a>("data", "seir.ts01.R", package = "fastbeta")</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seir">seir</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("deSolve")) withAutoprint({

data(seir.ts01, package = "fastbeta")
str(seir.ts01)
plot(seir.ts01)

})

if (requireNamespace("adaptivetau")) withAutoprint({

data(seir.ts02, package = "fastbeta")
str(seir.ts02)
plot(seir.ts02)

})
</code></pre>

<hr>
<h2 id='smallpox'>Smallpox Mortality in London, England, 1661-1930</h2><span id='topic+smallpox'></span>

<h3>Description</h3>

<p>Time series of deaths due to smallpox, deaths due to all causes, and
births in London, England, from 1661 to 1930, as recorded in the
London Bills of Mortality and the Registrar General's Weekly Returns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(smallpox, package = "fastbeta")
</code></pre>


<h3>Format</h3>

<p>A data frame with 13923 observations of 5 variables:
</p>

<dl>
<dt>from</dt><dd>
<p>start date of the record.</p>
</dd>
<dt>nday</dt><dd>
<p>length of the record, which is the number of days (typically 7) over
which deaths and births were counted.</p>
</dd>
<dt>smallpox</dt><dd>
<p>count of deaths due to smallpox.</p>
</dd>
<dt>allcauses</dt><dd>
<p>count of deaths due to all causes.</p>
</dd>
<dt>births</dt><dd>
<p>count of births.</p>
</dd>
</dl>



<h3>Source</h3>

<p>A precise description of the data set and its correspondence to the
original source documents is provided in the reference.
</p>
<p>A script generating the <code>smallpox</code> data frame from a CSV file
accompanying the reference is available as
<code><a href="base.html#topic+system.file">system.file</a>("scripts", "smallpox.R", package = "fastbeta")</code>.
</p>


<h3>References</h3>

<p>Krylova, O. &amp; Earn, D. J. D. (2020).
Patterns of smallpox mortality in London, England, over three centuries.
<em>PLOS Biology</em>,
<em>18</em>(12), Article e3000506, 1-27.
<a href="https://doi.org/10.1371/journal.pbio.3000506">doi:10.1371/journal.pbio.3000506</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(smallpox, package = "fastbeta")
str(smallpox)
table(smallpox[["nday"]]) # not all 7 days, hence:
plot(7 * smallpox / as.double(nday) ~ from, smallpox, type = "l")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
