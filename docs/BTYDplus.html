<!DOCTYPE html><html lang="en"><head><title>Help for package BTYDplus</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BTYDplus}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#abe.GenerateData'><p>Simulate data according to Pareto/NBD (Abe) model assumptions</p></a></li>
<li><a href='#abe.mcmc.DrawParameters'><p>Pareto/NBD (Abe) Parameter Draws</p></a></li>
<li><a href='#dc.check.model.params.safe'><p>Check Model Parameters</p></a></li>
<li><a href='#dc.PlotFreqVsConditionalExpectedFrequency'><p>Generic Method for Plotting Frequency vs. Conditional Expected Frequency</p></a></li>
<li><a href='#dc.PlotRecVsConditionalExpectedFrequency'><p>Generic Method for Plotting Frequency vs. Conditional Expected Frequency</p></a></li>
<li><a href='#dc.PlotTracking'><p>Generic Method for Tracking Plots</p></a></li>
<li><a href='#elog2cbs'><p>Convert Event Log to customer-level summary statistic</p></a></li>
<li><a href='#elog2cum'><p>Convert Event Log to Transaction Counts</p></a></li>
<li><a href='#estimateRegularity'><p>Estimate Regularity in Intertransaction Timings</p></a></li>
<li><a href='#groceryElog'><p>Event log for customers of an online grocery store.</p></a></li>
<li><a href='#mbgcnbd.cbs.LL'><p>(M)BG/CNBD-k Log-Likelihood</p></a></li>
<li><a href='#mbgcnbd.ConditionalExpectedTransactions'><p>(M)BG/CNBD-k Conditional Expected Transactions</p></a></li>
<li><a href='#mbgcnbd.EstimateParameters'><p>(M)BG/CNBD-k Parameter Estimation</p></a></li>
<li><a href='#mbgcnbd.Expectation'><p>(M)BG/CNBD-k Expectation</p></a></li>
<li><a href='#mbgcnbd.ExpectedCumulativeTransactions'><p>(M)BG/CNBD-k Expected Cumulative Transactions</p></a></li>
<li><a href='#mbgcnbd.GenerateData'><p>Simulate data according to (M)BG/CNBD-k model assumptions</p></a></li>
<li><a href='#mbgcnbd.PAlive'><p>(M)BG/CNBD-k P(alive)</p></a></li>
<li><a href='#mbgcnbd.PlotFrequencyInCalibration'><p>(M)BG/CNBD-k Plot Frequency in Calibration Period</p></a></li>
<li><a href='#mbgcnbd.PlotFreqVsConditionalExpectedFrequency'><p>(M)BG/CNBD-k Plot Frequency vs. Conditional Expected Frequency</p></a></li>
<li><a href='#mbgcnbd.PlotRecVsConditionalExpectedFrequency'><p>(M)BG/CNBD-k Plot Actual vs. Conditional Expected Frequency by Recency</p></a></li>
<li><a href='#mbgcnbd.PlotTrackingCum'><p>(M)BG/CNBD-k Tracking Cumulative Transactions Plot</p></a></li>
<li><a href='#mbgcnbd.PlotTrackingInc'><p>(M)BG/CNBD-k Tracking Incremental Transactions Comparison</p></a></li>
<li><a href='#mbgcnbd.pmf'><p>(M)BG/CNBD-k Probability Mass Function</p></a></li>
<li><a href='#mcmc.DrawFutureTransactions'><p>Draws number of future transactions based on MCMC parameter draws</p></a></li>
<li><a href='#mcmc.Expectation'><p>Unconditional Expectation for Pareto/GGG, Pareto/NBD (HB) and Pareto/NBD (Abe)</p></a></li>
<li><a href='#mcmc.ExpectedCumulativeTransactions'><p>Expected Cumulative Transactions for Pareto/GGG, Pareto/NBD (HB) and</p>
Pareto/NBD (Abe)</a></li>
<li><a href='#mcmc.PActive'><p>Calculates P(active) based on drawn future transactions.</p></a></li>
<li><a href='#mcmc.PAlive'><p>Calculates P(alive) based on MCMC parameter draws</p></a></li>
<li><a href='#mcmc.PlotFrequencyInCalibration'><p>Frequency in Calibration Period for Pareto/GGG, Pareto/NBD (HB) and Pareto/NBD (Abe)</p></a></li>
<li><a href='#mcmc.plotPActiveDiagnostic'><p>Draw diagnostic plot to inspect error in P(active).</p></a></li>
<li><a href='#mcmc.PlotTrackingCum'><p>Tracking Cumulative Transactions Plot for Pareto/GGG, Pareto/NBD (HB) and</p>
Pareto/NBD (Abe)</a></li>
<li><a href='#mcmc.PlotTrackingInc'><p>Tracking Incremental Transactions Plot for Pareto/GGG, Pareto/NBD (HB) and</p>
Pareto/NBD (Abe)</a></li>
<li><a href='#mcmc.pmf'><p>Probability Mass Function for Pareto/GGG, Pareto/NBD (HB) and Pareto/NBD (Abe)</p></a></li>
<li><a href='#mcmc.setBurnin'><p>(Re-)set burnin of MCMC chains.</p></a></li>
<li><a href='#nbd.cbs.LL'><p>Calculate the log-likelihood of the NBD model</p></a></li>
<li><a href='#nbd.ConditionalExpectedTransactions'><p>NBD Conditional Expected Transactions</p></a></li>
<li><a href='#nbd.EstimateParameters'><p>Parameter Estimation for the NBD model</p></a></li>
<li><a href='#nbd.GenerateData'><p>Simulate data according to NBD model assumptions</p></a></li>
<li><a href='#nbd.LL'><p>Calculate the log-likelihood of the NBD model</p></a></li>
<li><a href='#pggg.GenerateData'><p>Simulate data according to Pareto/GGG model assumptions</p></a></li>
<li><a href='#pggg.mcmc.DrawParameters'><p>Pareto/GGG Parameter Draws</p></a></li>
<li><a href='#pggg.plotRegularityRateHeterogeneity'><p>Pareto/GGG Plot Regularity Rate Heterogeneity</p></a></li>
<li><a href='#plotTimingPatterns'><p>Plot timing patterns of sampled customers</p></a></li>
<li><a href='#pnbd.GenerateData'><p>Simulate data according to Pareto/NBD model assumptions</p></a></li>
<li><a href='#pnbd.mcmc.DrawParameters'><p>Pareto/NBD (HB) Parameter Draws</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Probabilistic Models for Assessing and Predicting your Customer
Base</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides advanced statistical methods to describe and predict customers'
  purchase behavior in a non-contractual setting. It uses historic transaction records to fit a
  probabilistic model, which then allows to compute quantities of managerial interest on a cohort-
  as well as on a customer level (Customer Lifetime Value, Customer Equity, P(alive), etc.). This
  package complements the BTYD package by providing several additional buy-till-you-die models, that
  have been published in the marketing literature, but whose implementation are complex and non-trivial.
  These models are: NBD [Ehrenberg (1959) &lt;<a href="https://doi.org/10.2307%2F2985810">doi:10.2307/2985810</a>&gt;], MBG/NBD [Batislam et al (2007) 
  &lt;<a href="https://doi.org/10.1016%2Fj.ijresmar.2006.12.005">doi:10.1016/j.ijresmar.2006.12.005</a>&gt;], (M)BG/CNBD-k [Reutterer et al (2020) 
  &lt;<a href="https://doi.org/10.1016%2Fj.ijresmar.2020.09.002">doi:10.1016/j.ijresmar.2020.09.002</a>&gt;], Pareto/NBD (HB) [Abe (2009) &lt;<a href="https://doi.org/10.1287%2Fmksc.1090.0502">doi:10.1287/mksc.1090.0502</a>&gt;] 
  and Pareto/GGG [Platzer and Reutterer (2016) &lt;<a href="https://doi.org/10.1287%2Fmksc.2015.0963">doi:10.1287/mksc.2015.0963</a>&gt;].</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mplatzer/BTYDplus#readme">https://github.com/mplatzer/BTYDplus#readme</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mplatzer/BTYDplus/issues">https://github.com/mplatzer/BTYDplus/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, BTYD (&ge; 2.3), coda, data.table, mvtnorm, bayesm, stats,
graphics</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, covr, knitr, rmarkdown, gsl, lintr (&ge; 1.0.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-01-20 17:16:22 UTC; mplatzer</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael Platzer [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Platzer &lt;michael.platzer@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-01-21 11:00:16 UTC</td>
</tr>
</table>
<hr>
<h2 id='abe.GenerateData'>Simulate data according to Pareto/NBD (Abe) model assumptions</h2><span id='topic+abe.GenerateData'></span>

<h3>Description</h3>

<p>Simulate data according to Pareto/NBD (Abe) model assumptions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abe.GenerateData(
  n,
  T.cal,
  T.star,
  params,
  date.zero = "2000-01-01",
  covariates = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="abe.GenerateData_+3A_n">n</code></td>
<td>
<p>Number of customers.</p>
</td></tr>
<tr><td><code id="abe.GenerateData_+3A_t.cal">T.cal</code></td>
<td>
<p>Length of calibration period. If a vector is provided, then it
is assumed that customers have different 'birth' dates, i.e.
<code class="reqn">max(T.cal)-T.cal</code>.</p>
</td></tr>
<tr><td><code id="abe.GenerateData_+3A_t.star">T.star</code></td>
<td>
<p>Length of holdout period. This may be a vector.</p>
</td></tr>
<tr><td><code id="abe.GenerateData_+3A_params">params</code></td>
<td>
<p>A list of model parameters: <code>beta</code> and <code>gamma</code>.</p>
</td></tr>
<tr><td><code id="abe.GenerateData_+3A_date.zero">date.zero</code></td>
<td>
<p>Initial date for cohort start. Can be of class character, Date or POSIXt.</p>
</td></tr>
<tr><td><code id="abe.GenerateData_+3A_covariates">covariates</code></td>
<td>
<p>Provide matrix of customer covariates. If NULL then random covariate values between [-1,1] are drawn.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of length 2:
</p>
<table role = "presentation">
<tr><td><code>cbs</code></td>
<td>
<p>A data.frame with a row for each customer and the summary statistic as columns.</p>
</td></tr>
<tr><td><code>elog</code></td>
<td>
<p>A data.frame with a row for each transaction, and columns <code>cust</code>, <code>date</code> and <code>t</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># generate artificial Pareto/NBD (Abe) with 2 covariates
params &lt;- list()
params$beta  &lt;- matrix(c(0.18, -2.5, 0.5, -0.3, -0.2, 0.8), byrow = TRUE, ncol = 2)
params$gamma &lt;- matrix(c(0.05, 0.1, 0.1, 0.2), ncol = 2)
data &lt;- abe.GenerateData(n = 200, T.cal = 32, T.star = 32, params)
cbs &lt;- data$cbs  # customer by sufficient summary statistic - one row per customer
elog &lt;- data$elog  # Event log - one row per event/purchase
</code></pre>

<hr>
<h2 id='abe.mcmc.DrawParameters'>Pareto/NBD (Abe) Parameter Draws</h2><span id='topic+abe.mcmc.DrawParameters'></span>

<h3>Description</h3>

<p>Returns draws from the posterior distributions of the Pareto/NBD (Abe)
parameters, on cohort as well as on customer level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abe.mcmc.DrawParameters(
  cal.cbs,
  covariates = c(),
  mcmc = 2500,
  burnin = 500,
  thin = 50,
  chains = 2,
  mc.cores = NULL,
  trace = 100
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="abe.mcmc.DrawParameters_+3A_cal.cbs">cal.cbs</code></td>
<td>
<p>Calibration period customer-by-sufficient-statistic (CBS)
data.frame. It must contain a row for each customer, and columns <code>x</code>
for frequency, <code>t.x</code> for recency and <code>T.cal</code> for the total time
observed. A correct format can be easily generated based on the complete
event log of a customer cohort with <code><a href="#topic+elog2cbs">elog2cbs</a></code>.</p>
</td></tr>
<tr><td><code id="abe.mcmc.DrawParameters_+3A_covariates">covariates</code></td>
<td>
<p>A vector of columns of <code>cal.cbs</code> which contain customer-level covariates.</p>
</td></tr>
<tr><td><code id="abe.mcmc.DrawParameters_+3A_mcmc">mcmc</code></td>
<td>
<p>Number of MCMC steps.</p>
</td></tr>
<tr><td><code id="abe.mcmc.DrawParameters_+3A_burnin">burnin</code></td>
<td>
<p>Number of initial MCMC steps which are discarded.</p>
</td></tr>
<tr><td><code id="abe.mcmc.DrawParameters_+3A_thin">thin</code></td>
<td>
<p>Only every <code>thin</code>-th MCMC step will be returned.</p>
</td></tr>
<tr><td><code id="abe.mcmc.DrawParameters_+3A_chains">chains</code></td>
<td>
<p>Number of MCMC chains to be run.</p>
</td></tr>
<tr><td><code id="abe.mcmc.DrawParameters_+3A_mc.cores">mc.cores</code></td>
<td>
<p>Number of cores to use in parallel (Unix only). Defaults to <code>min(chains, detectCores())</code>.</p>
</td></tr>
<tr><td><code id="abe.mcmc.DrawParameters_+3A_trace">trace</code></td>
<td>
<p>Print logging statement every <code>trace</code>-th iteration. Not available for <code>mc.cores &gt; 1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code>demo('pareto-abe')</code> for how to apply this model.
</p>


<h3>Value</h3>

<p>List of length 2:
</p>
<table role = "presentation">
<tr><td><code>level_1</code></td>
<td>
<p>list of <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code>s, one for each customer, with draws for customer-level parameters <code>k</code>, <code>lambda</code>, <code>tau</code>, <code>z</code>, <code>mu</code></p>
</td></tr>
<tr><td><code>level_2</code></td>
<td>
<p><code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code>, with draws for cohort-level parameters</p>
</td></tr>
</table>


<h3>References</h3>

<p>Abe, M. (2009). &quot;Counting your customers&quot; one by one: A
hierarchical Bayes extension to the Pareto/NBD model. Marketing Science,
28(3), 541-553. doi: <a href="https://doi.org/10.1287/mksc.1090.0502">10.1287/mksc.1090.0502</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+abe.GenerateData">abe.GenerateData</a> </code> <code><a href="#topic+mcmc.PAlive">mcmc.PAlive</a> </code> <code><a href="#topic+mcmc.DrawFutureTransactions">mcmc.DrawFutureTransactions</a> </code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("groceryElog")
cbs &lt;- elog2cbs(groceryElog, T.cal = "2006-12-31")
cbs$cov1 &lt;- as.integer(cbs$cust) %% 2 # create dummy covariate
param.draws &lt;- abe.mcmc.DrawParameters(cbs, c("cov1"),
  mcmc = 100, burnin = 50, thin = 10, chains = 1) # short MCMC to run demo fast

# cohort-level parameter draws
as.matrix(param.draws$level_2)
# customer-level parameter draws for customer with ID '4'
as.matrix(param.draws$level_1[["4"]])

# estimate future transactions
xstar.draws &lt;- mcmc.DrawFutureTransactions(cbs, param.draws, cbs$T.star)
xstar.est &lt;- apply(xstar.draws, 2, mean)
head(xstar.est)
</code></pre>

<hr>
<h2 id='dc.check.model.params.safe'>Check Model Parameters</h2><span id='topic+dc.check.model.params.safe'></span>

<h3>Description</h3>

<p>Wrapper for <code>BTYD::dc.check.model.params</code> with additional check for
parameter names if these are present
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dc.check.model.params.safe(printnames, params, func)
</code></pre>

<hr>
<h2 id='dc.PlotFreqVsConditionalExpectedFrequency'>Generic Method for Plotting Frequency vs. Conditional Expected Frequency</h2><span id='topic+dc.PlotFreqVsConditionalExpectedFrequency'></span>

<h3>Description</h3>

<p>Generic Method for Plotting Frequency vs. Conditional Expected Frequency
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dc.PlotFreqVsConditionalExpectedFrequency(
  x,
  actual,
  expected,
  censor,
  xlab,
  ylab,
  xticklab,
  title
)
</code></pre>

<hr>
<h2 id='dc.PlotRecVsConditionalExpectedFrequency'>Generic Method for Plotting Frequency vs. Conditional Expected Frequency</h2><span id='topic+dc.PlotRecVsConditionalExpectedFrequency'></span>

<h3>Description</h3>

<p>Generic Method for Plotting Frequency vs. Conditional Expected Frequency
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dc.PlotRecVsConditionalExpectedFrequency(
  t.x,
  actual,
  expected,
  xlab,
  ylab,
  xticklab,
  title
)
</code></pre>

<hr>
<h2 id='dc.PlotTracking'>Generic Method for Tracking Plots</h2><span id='topic+dc.PlotTracking'></span>

<h3>Description</h3>

<p>Generic Method for Tracking Plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dc.PlotTracking(
  actual,
  expected,
  T.cal = NULL,
  xlab = "",
  ylab = "",
  title = "",
  xticklab = NULL,
  ymax = NULL,
  legend = c("Actual", "Model")
)
</code></pre>

<hr>
<h2 id='elog2cbs'>Convert Event Log to customer-level summary statistic</h2><span id='topic+elog2cbs'></span>

<h3>Description</h3>

<p>Efficient implementation for the conversion of an event log into a
customer-by-sufficient-statistic (CBS) <code>data.frame</code>, with a row for each
customer, which is the required data format for estimating model parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elog2cbs(elog, units = "week", T.cal = NULL, T.tot = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="elog2cbs_+3A_elog">elog</code></td>
<td>
<p>Event log, a <code>data.frame</code> with field <code>cust</code> for the
customer ID and field <code>date</code> for the date/time of the event, which
should be of type <code>Date</code> or <code>POSIXt</code>. If a field <code>sales</code> is
present, it will be aggregated as well.</p>
</td></tr>
<tr><td><code id="elog2cbs_+3A_units">units</code></td>
<td>
<p>Time unit, either <code>week</code>, <code>day</code>, <code>hour</code>,
<code>min</code> or <code>sec</code>. See <code><a href="base.html#topic+difftime">difftime</a></code>.</p>
</td></tr>
<tr><td><code id="elog2cbs_+3A_t.cal">T.cal</code></td>
<td>
<p>End date of calibration period. Defaults to
<code>max(elog$date)</code>.</p>
</td></tr>
<tr><td><code id="elog2cbs_+3A_t.tot">T.tot</code></td>
<td>
<p>End date of the observation period. Defaults to
<code>max(elog$date)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The time unit for expressing <code>t.x</code>, <code>T.cal</code> and <code>litt</code> are
determined via the argument <code>units</code>, which is passed forward to method
<code>difftime</code>, and defaults to <code>weeks</code>.
</p>
<p>Argument <code>T.tot</code> allows one to specify the end of the observation period,
i.e. the last possible date of an event to still be included in the event
log. If  <code>T.tot</code> is not provided, then the date of the last recorded event
will be assumed to coincide with the end of the observation period. If
<code>T.tot</code> is provided, then any event that occurs after that date is discarded.
</p>
<p>Argument <code>T.cal</code> allows one to split the summary statistics into a
calibration and a holdout period. This can be useful for evaluating
forecasting accuracy for a given dataset. If <code>T.cal</code> is not provided,
then the whole observation period is considered, and is then subsequently
used for for estimating model parameters. If it is provided, then the
returned <code>data.frame</code> contains two additional fields, with <code>x.star</code>
representing the number of repeat transactions during the holdout period of
length <code>T.star</code>. And only those customers are contained, who have had at
least one event during the calibration period.
</p>
<p>Transactions with identical <code>cust</code> and <code>date</code> field are treated as
a single transaction, with <code>sales</code> being summed up.
</p>


<h3>Value</h3>

<p><code>data.frame</code> with fields:
</p>
<table role = "presentation">
<tr><td><code>cust</code></td>
<td>
<p>Customer id (unique key).</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>Number of recurring events in calibration period.</p>
</td></tr>
<tr><td><code>t.x</code></td>
<td>
<p>Time between first and last event in calibration period.</p>
</td></tr>
<tr><td><code>litt</code></td>
<td>
<p>Sum of logarithmic intertransaction timings during calibration period.</p>
</td></tr>
<tr><td><code>sales</code></td>
<td>
<p>Sum of sales in calibration period, incl. initial transaction. Only if <code>elog$sales</code> is provided.</p>
</td></tr>
<tr><td><code>sales.x</code></td>
<td>
<p>Sum of sales in calibration period, excl. initial transaction. Only if <code>elog$sales</code> is provided.</p>
</td></tr>
<tr><td><code>first</code></td>
<td>
<p>Date of first transaction in calibration period.</p>
</td></tr>
<tr><td><code>T.cal</code></td>
<td>
<p>Time between first event and end of calibration period.</p>
</td></tr>
<tr><td><code>T.star</code></td>
<td>
<p>Length of holdout period. Only if <code>T.cal</code> is provided.</p>
</td></tr>
<tr><td><code>x.star</code></td>
<td>
<p>Number of events within holdout period. Only if <code>T.cal</code> is provided.</p>
</td></tr>
<tr><td><code>sales.star</code></td>
<td>
<p>Sum of sales within holdout period. Only if <code>T.cal</code> and <code>elog$sales</code> are provided.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data("groceryElog")
cbs &lt;- elog2cbs(groceryElog, T.cal = "2006-12-31", T.tot = "2007-12-30")
head(cbs)
</code></pre>

<hr>
<h2 id='elog2cum'>Convert Event Log to Transaction Counts</h2><span id='topic+elog2cum'></span><span id='topic+elog2inc'></span>

<h3>Description</h3>

<p>Aggregates an event log to either incremental or cumulative number of
transactions. If <code>first=TRUE</code> then the initial transactions of each
customer are included in the count as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elog2cum(elog, by = 7, first = FALSE)

elog2inc(elog, by = 7, first = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="elog2cum_+3A_elog">elog</code></td>
<td>
<p>Event log, a <code>data.frame</code> with columns <code>cust</code> and
transaction time <code>t</code> or <code>date</code>.</p>
</td></tr>
<tr><td><code id="elog2cum_+3A_by">by</code></td>
<td>
<p>Only return every <code>by</code>-th count Defaults to 7, and thus
returns weekly numbers.</p>
</td></tr>
<tr><td><code id="elog2cum_+3A_first">first</code></td>
<td>
<p>If TRUE, then the first transaction for each customer is being
counted as well</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Duplicate transactions with identical <code>cust</code> and <code>date</code> (or
<code>t</code>) field are counted only once.
</p>


<h3>Value</h3>

<p>Numeric vector of transaction counts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("groceryElog")
cum &lt;- elog2cum(groceryElog)
plot(cum, typ="l", frame = FALSE)
inc &lt;- elog2inc(groceryElog)
plot(inc, typ="l", frame = FALSE)
</code></pre>

<hr>
<h2 id='estimateRegularity'>Estimate Regularity in Intertransaction Timings</h2><span id='topic+estimateRegularity'></span>

<h3>Description</h3>

<p>The models (M)BG/CNBD-k and Pareto/GGG are capable of leveraging regularity
within transaction timings for improving forecast accuracy. This method
provides a quick check for the degree of regularity in the event timings. A
return value of close to 1 supports the assumption of exponentially
distributed intertransaction times, whereas values significantly larger than
1 reveal the presence of regularity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateRegularity(
  elog,
  method = "wheat",
  plot = FALSE,
  title = "",
  min = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimateRegularity_+3A_elog">elog</code></td>
<td>
<p>Event log, a <code>data.frame</code> with columns <code>cust</code> and
transaction time <code>t</code> or <code>date</code></p>
</td></tr>
<tr><td><code id="estimateRegularity_+3A_method">method</code></td>
<td>
<p>Either <code>wheat</code>, <code>mle</code>, <code>mle-minka</code>, <code>mle-thom</code> or
<code>cv</code>.</p>
</td></tr>
<tr><td><code id="estimateRegularity_+3A_plot">plot</code></td>
<td>
<p>If <code>TRUE</code> then an additional diagnostic plot is provided.</p>
</td></tr>
<tr><td><code id="estimateRegularity_+3A_title">title</code></td>
<td>
<p>Plot title.</p>
</td></tr>
<tr><td><code id="estimateRegularity_+3A_min">min</code></td>
<td>
<p>Minimum number of intertransaction times per customer. Customers
with less than <code>min</code> intertransactions are not considered. Defaults to 2
for method 'wheat', and to 10 otherwise.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimation is either done by 1) assuming the same degree of regularity across
all customers (Wheat &amp; Morrison (1990) via <code>method = "wheat"</code>), or 2) by
estimating regularity for each customer separately, as the shape parameter of
a fitted gamma distribution, and then return the median across estimates. The
latter methods, though, require sufficient (&gt;=<code>min</code>) transactions per
customer.
</p>
<p>Wheat &amp; Morrison (1990)'s method calculates for each customer a statistic
<code>M</code> based on her last two number of intertransaction times as
<code>ITT_1 / (ITT_1 + ITT_2)</code>. That measure is known to follow a
<code>Beta(k, k)</code> distribution, and <code>k</code> can be estimated as
<code>(1-4*Var(M))/(8*Var(M))</code>. The corresponding diagnostic plot (<code>plot
= TRUE</code>) shows the actual distribution of <code>M</code> vs. the theoretical
distribution for <code>k = 1</code> and <code>k = 2</code>.
</p>


<h3>Value</h3>

<p>Estimated real-valued regularity parameter.
</p>


<h3>References</h3>

<p>Wheat, Rita D., and Donald G. Morrison. &quot;Estimating purchase
regularity with two interpurchase times.&quot; Journal of Marketing Research
(1990): 87-93.
</p>
<p>Dunn, Richard, Steven Reader, and Neil Wrigley. 'An investigation
of the assumptions of the NBD model' Applied Statistics (1983): 249-259.
</p>
<p>Wu, Couchen, and H-L. Chen. 'A consumer purchasing model with
learning and departure behaviour.'  Journal of the Operational Research
Society (2000): 583-591.
</p>
<p><a href="https://tminka.github.io/papers/minka-gamma.pdf">https://tminka.github.io/papers/minka-gamma.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("groceryElog")
estimateRegularity(groceryElog, plot = TRUE, method = 'wheat')
estimateRegularity(groceryElog, plot = TRUE, method = 'mle-minka')
estimateRegularity(groceryElog, plot = TRUE, method = 'mle-thom')
estimateRegularity(groceryElog, plot = TRUE, method = 'cv')
</code></pre>

<hr>
<h2 id='groceryElog'>Event log for customers of an online grocery store.</h2><span id='topic+groceryElog'></span>

<h3>Description</h3>

<p>These data came from an online retailer offering a broad range of grocery
categories. The original data set spans four years, but lacked the customers'
acquisition date. Therefore, we constructed a quasi cohort by limiting the
provided data analysis to those customers who haven't purchased at all in the
first two years, and had their first purchase in the first quarter of 2006.
This resulted in 10483 transactions being recorded for 1525 customers during
a period of two years (2006-2007).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>groceryElog
</code></pre>


<h3>Format</h3>

<p>A data frame with 10483 rows and 2 variables: </p>

<dl>
<dt>cust</dt><dd><p>customer ID, factor vector</p>
</dd> <dt>date</dt><dd><p>transaction date,
Date vector</p>
</dd> </dl>



<h3>Source</h3>

<p>Thomas Reutterer &lt;thomas.reutterer@wu.ac.at&gt;
</p>


<h3>References</h3>

<p>Platzer, M., &amp; Reutterer, T. (2016). Ticking away the moments:
Timing regularity helps to better predict customer activity. Marketing
Science, 35(5), 779-799. doi: <a href="https://doi.org/10.1287/mksc.2015.0963">10.1287/mksc.2015.0963</a>
</p>

<hr>
<h2 id='mbgcnbd.cbs.LL'>(M)BG/CNBD-k Log-Likelihood</h2><span id='topic+mbgcnbd.cbs.LL'></span><span id='topic+mbgcnbd.LL'></span><span id='topic+bgcnbd.cbs.LL'></span><span id='topic+bgcnbd.LL'></span>

<h3>Description</h3>

<p>Calculates the log-likelihood of the (M)BG/CNBD-k model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mbgcnbd.cbs.LL(params, cal.cbs)

mbgcnbd.LL(params, x, t.x, T.cal, litt)

bgcnbd.cbs.LL(params, cal.cbs)

bgcnbd.LL(params, x, t.x, T.cal, litt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mbgcnbd.cbs.LL_+3A_params">params</code></td>
<td>
<p>A vector with model parameters <code>k</code>, <code>r</code>,
<code>alpha</code>, <code>a</code> and <code>b</code>, in that order.</p>
</td></tr>
<tr><td><code id="mbgcnbd.cbs.LL_+3A_cal.cbs">cal.cbs</code></td>
<td>
<p>Calibration period customer-by-sufficient-statistic (CBS)
data.frame. It must contain a row for each customer, and columns <code>x</code>
for frequency, <code>t.x</code> for recency , <code>T.cal</code> for the total time
observed, as well as the sum over logarithmic intertransaction times
<code>litt</code>. A correct format can be easily generated based on the complete
event log of a customer cohort with <code><a href="#topic+elog2cbs">elog2cbs</a></code>.</p>
</td></tr>
<tr><td><code id="mbgcnbd.cbs.LL_+3A_x">x</code></td>
<td>
<p>frequency, i.e. number of re-purchases</p>
</td></tr>
<tr><td><code id="mbgcnbd.cbs.LL_+3A_t.x">t.x</code></td>
<td>
<p>recency, i.e. time elapsed from first purchase to last purchase</p>
</td></tr>
<tr><td><code id="mbgcnbd.cbs.LL_+3A_t.cal">T.cal</code></td>
<td>
<p>total time of observation period</p>
</td></tr>
<tr><td><code id="mbgcnbd.cbs.LL_+3A_litt">litt</code></td>
<td>
<p>sum of logarithmic interpurchase times</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>bgcnbd.cbs.LL</code>, the total log-likelihood of the provided
data. For <code>bgcnbd.LL</code>, a vector of log-likelihoods as long as the
longest input vector (<code>x</code>, <code>t.x</code>, or <code>T.cal</code>).
</p>


<h3>References</h3>

<p>(M)BG/CNBD-k: Reutterer, T., Platzer, M., &amp; Schroeder, N. (2020).
Leveraging purchase regularity for predicting customer behavior the easy
way. International Journal of Research in Marketing.
doi: <a href="https://doi.org/10.1016/j.ijresmar.2020.09.002">10.1016/j.ijresmar.2020.09.002</a>
</p>

<hr>
<h2 id='mbgcnbd.ConditionalExpectedTransactions'>(M)BG/CNBD-k Conditional Expected Transactions</h2><span id='topic+mbgcnbd.ConditionalExpectedTransactions'></span><span id='topic+bgcnbd.ConditionalExpectedTransactions'></span>

<h3>Description</h3>

<p>Uses (M)BG/CNBD-k model parameters and a customer's past transaction behavior
to return the number of transactions they are expected to make in a given
time period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mbgcnbd.ConditionalExpectedTransactions(params, T.star, x, t.x, T.cal)

bgcnbd.ConditionalExpectedTransactions(params, T.star, x, t.x, T.cal)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mbgcnbd.ConditionalExpectedTransactions_+3A_params">params</code></td>
<td>
<p>A vector with model parameters <code>k</code>, <code>r</code>,
<code>alpha</code>, <code>a</code> and <code>b</code>, in that order.</p>
</td></tr>
<tr><td><code id="mbgcnbd.ConditionalExpectedTransactions_+3A_t.star">T.star</code></td>
<td>
<p>Length of time for which we are calculating the expected number
of transactions.</p>
</td></tr>
<tr><td><code id="mbgcnbd.ConditionalExpectedTransactions_+3A_x">x</code></td>
<td>
<p>Number of repeat transactions in the calibration period T.cal, or a
vector of calibration period frequencies.</p>
</td></tr>
<tr><td><code id="mbgcnbd.ConditionalExpectedTransactions_+3A_t.x">t.x</code></td>
<td>
<p>Recency, i.e. length between first and last transaction during
calibration period.</p>
</td></tr>
<tr><td><code id="mbgcnbd.ConditionalExpectedTransactions_+3A_t.cal">T.cal</code></td>
<td>
<p>Length of calibration period, or a vector of calibration period
lengths.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Number of transactions a customer is expected to make in a time
period of length t, conditional on their past behavior. If any of the input
parameters has a length greater than 1, this will be a vector of expected
number of transactions.
</p>


<h3>References</h3>

<p>(M)BG/CNBD-k: Reutterer, T., Platzer, M., &amp; Schroeder, N. (2020).
Leveraging purchase regularity for predicting customer behavior the easy
way. International Journal of Research in Marketing.
doi: <a href="https://doi.org/10.1016/j.ijresmar.2020.09.002">10.1016/j.ijresmar.2020.09.002</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("groceryElog")
cbs &lt;- elog2cbs(groceryElog)
params &lt;- mbgcnbd.EstimateParameters(cbs, k = 2)
# estimate transactions for next 12 weeks
xstar.est &lt;- mbgcnbd.ConditionalExpectedTransactions(params,
  T.star = 12, cbs$x, cbs$t.x, cbs$T.cal)
head(xstar.est) # expected number of transactions for first 6 customers
sum(xstar.est) # expected total number of transactions during holdout

## End(Not run)
</code></pre>

<hr>
<h2 id='mbgcnbd.EstimateParameters'>(M)BG/CNBD-k Parameter Estimation</h2><span id='topic+mbgcnbd.EstimateParameters'></span><span id='topic+bgcnbd.EstimateParameters'></span><span id='topic+mbgnbd.EstimateParameters'></span>

<h3>Description</h3>

<p>Estimates parameters for the (M)BG/CNBD-k model via Maximum Likelihood
Estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mbgcnbd.EstimateParameters(
  cal.cbs,
  k = NULL,
  par.start = c(1, 3, 1, 3),
  max.param.value = 10000,
  trace = 0
)

bgcnbd.EstimateParameters(
  cal.cbs,
  k = NULL,
  par.start = c(1, 3, 1, 3),
  max.param.value = 10000,
  trace = 0
)

mbgnbd.EstimateParameters(
  cal.cbs,
  par.start = c(1, 3, 1, 3),
  max.param.value = 10000,
  trace = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mbgcnbd.EstimateParameters_+3A_cal.cbs">cal.cbs</code></td>
<td>
<p>Calibration period customer-by-sufficient-statistic (CBS)
data.frame. It must contain a row for each customer, and columns <code>x</code>
for frequency, <code>t.x</code> for recency , <code>T.cal</code> for the total time
observed, as well as the sum over logarithmic intertransaction times
<code>litt</code>, in case that <code>k</code> is not provided. A correct format can be
easily generated based on the complete event log of a customer cohort with
<code><a href="#topic+elog2cbs">elog2cbs</a></code>.</p>
</td></tr>
<tr><td><code id="mbgcnbd.EstimateParameters_+3A_k">k</code></td>
<td>
<p>Integer-valued degree of regularity for Erlang-k distributed
interpurchase times. By default this <code>k</code> is not provided, and a grid
search from 1 to 12 is performed in order to determine the best-fitting
<code>k</code>. The grid search is stopped early, if the log-likelihood does not
increase anymore when increasing k beyond 4.</p>
</td></tr>
<tr><td><code id="mbgcnbd.EstimateParameters_+3A_par.start">par.start</code></td>
<td>
<p>Initial (M)BG/CNBD-k parameters. A vector with <code>r</code>,
<code>alpha</code>, <code>a</code> and <code>b</code> in that order.</p>
</td></tr>
<tr><td><code id="mbgcnbd.EstimateParameters_+3A_max.param.value">max.param.value</code></td>
<td>
<p>Upper bound on parameters.</p>
</td></tr>
<tr><td><code id="mbgcnbd.EstimateParameters_+3A_trace">trace</code></td>
<td>
<p>If larger than 0, then the parameter values are is printed every
<code>trace</code>-step of the maximum likelihood estimation search.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of estimated parameters.
</p>


<h3>References</h3>

<p>(M)BG/CNBD-k: Reutterer, T., Platzer, M., &amp; Schroeder, N. (2020).
Leveraging purchase regularity for predicting customer behavior the easy
way. International Journal of Research in Marketing.
doi: <a href="https://doi.org/10.1016/j.ijresmar.2020.09.002">10.1016/j.ijresmar.2020.09.002</a>
</p>
<p>Batislam, E. P., Denizel, M., &amp; Filiztekin, A. (2007). Empirical
validation and comparison of models for customer base analysis.
International Journal of Research in Marketing, 24(3), 201-209.
doi: <a href="https://doi.org/10.1016/j.ijresmar.2006.12.005">10.1016/j.ijresmar.2006.12.005</a>
</p>


<h3>See Also</h3>

<p><code><a href="BTYD.html#topic+bgnbd.EstimateParameters">bgnbd.EstimateParameters</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("groceryElog")
cbs &lt;- elog2cbs(groceryElog)
(params &lt;- mbgcnbd.EstimateParameters(cbs))

## End(Not run)
</code></pre>

<hr>
<h2 id='mbgcnbd.Expectation'>(M)BG/CNBD-k Expectation</h2><span id='topic+mbgcnbd.Expectation'></span><span id='topic+bgcnbd.Expectation'></span>

<h3>Description</h3>

<p>Returns the number of repeat transactions that a randomly chosen customer
(for whom we have no prior information) is expected to make in a given time
period, i.e. <code class="reqn">E(X(t) | k, r, alpha, a, b)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mbgcnbd.Expectation(params, t)

bgcnbd.Expectation(params, t)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mbgcnbd.Expectation_+3A_params">params</code></td>
<td>
<p>A vector with model parameters <code>k</code>, <code>r</code>,
<code>alpha</code>, <code>a</code> and <code>b</code>, in that order.</p>
</td></tr>
<tr><td><code id="mbgcnbd.Expectation_+3A_t">t</code></td>
<td>
<p>Length of time for which we are calculating the expected number of repeat transactions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: Computational time increases with the number of unique values of
<code>t</code>.
</p>


<h3>Value</h3>

<p>Number of repeat transactions a customer is expected to make in a time period of length t.
</p>


<h3>References</h3>

<p>(M)BG/CNBD-k: Reutterer, T., Platzer, M., &amp; Schroeder, N. (2020).
Leveraging purchase regularity for predicting customer behavior the easy
way. International Journal of Research in Marketing.
doi: <a href="https://doi.org/10.1016/j.ijresmar.2020.09.002">10.1016/j.ijresmar.2020.09.002</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("groceryElog")
cbs &lt;- elog2cbs(groceryElog)
params &lt;- mbgcnbd.EstimateParameters(cbs)
mbgcnbd.Expectation(params, t = c(26, 52))

## End(Not run)
</code></pre>

<hr>
<h2 id='mbgcnbd.ExpectedCumulativeTransactions'>(M)BG/CNBD-k Expected Cumulative Transactions</h2><span id='topic+mbgcnbd.ExpectedCumulativeTransactions'></span><span id='topic+bgcnbd.ExpectedCumulativeTransactions'></span>

<h3>Description</h3>

<p>Calculates the expected cumulative total repeat transactions by all customers
for the calibration and holdout periods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mbgcnbd.ExpectedCumulativeTransactions(params, T.cal, T.tot, n.periods.final)

bgcnbd.ExpectedCumulativeTransactions(params, T.cal, T.tot, n.periods.final)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mbgcnbd.ExpectedCumulativeTransactions_+3A_params">params</code></td>
<td>
<p>A vector with model parameters <code>k</code>, <code>r</code>,
<code>alpha</code>, <code>a</code> and <code>b</code>, in that order.</p>
</td></tr>
<tr><td><code id="mbgcnbd.ExpectedCumulativeTransactions_+3A_t.cal">T.cal</code></td>
<td>
<p>A vector to represent customers' calibration period lengths.</p>
</td></tr>
<tr><td><code id="mbgcnbd.ExpectedCumulativeTransactions_+3A_t.tot">T.tot</code></td>
<td>
<p>End of holdout period. Must be a single value, not a vector.</p>
</td></tr>
<tr><td><code id="mbgcnbd.ExpectedCumulativeTransactions_+3A_n.periods.final">n.periods.final</code></td>
<td>
<p>Number of time periods in the calibration and holdout
periods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: Computational time increases with the number of unique values of
<code>T.cal</code>.
</p>


<h3>Value</h3>

<p>Vector of length <code>n.periods.final</code> with expected cumulative
total repeat transactions by all customers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("groceryElog")
cbs &lt;- elog2cbs(groceryElog)
params &lt;- mbgcnbd.EstimateParameters(cbs, k = 2)
# Returns a vector containing expected cumulative repeat transactions for 104
# weeks, with every eigth week being reported.
mbgcnbd.ExpectedCumulativeTransactions(params,
  T.cal = cbs$T.cal,
  T.tot = 104,
  n.periods.final = 104 / 8)

## End(Not run)
</code></pre>

<hr>
<h2 id='mbgcnbd.GenerateData'>Simulate data according to (M)BG/CNBD-k model assumptions</h2><span id='topic+mbgcnbd.GenerateData'></span><span id='topic+bgcnbd.GenerateData'></span>

<h3>Description</h3>

<p>Simulate data according to (M)BG/CNBD-k model assumptions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mbgcnbd.GenerateData(n, T.cal, T.star = NULL, params, date.zero = "2000-01-01")

bgcnbd.GenerateData(n, T.cal, T.star = NULL, params, date.zero = "2000-01-01")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mbgcnbd.GenerateData_+3A_n">n</code></td>
<td>
<p>Number of customers.</p>
</td></tr>
<tr><td><code id="mbgcnbd.GenerateData_+3A_t.cal">T.cal</code></td>
<td>
<p>Length of calibration period. If a vector is provided, then it
is assumed that customers have different 'birth' dates, i.e.
<code class="reqn">max(T.cal)-T.cal</code>.</p>
</td></tr>
<tr><td><code id="mbgcnbd.GenerateData_+3A_t.star">T.star</code></td>
<td>
<p>Length of holdout period. This may be a vector.</p>
</td></tr>
<tr><td><code id="mbgcnbd.GenerateData_+3A_params">params</code></td>
<td>
<p>A vector with model parameters <code>k</code>, <code>r</code>,
<code>alpha</code>, <code>a</code> and <code>b</code>, in that order.</p>
</td></tr>
<tr><td><code id="mbgcnbd.GenerateData_+3A_date.zero">date.zero</code></td>
<td>
<p>Initial date for cohort start. Can be of class character, Date or POSIXt.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of length 2:
</p>
<table role = "presentation">
<tr><td><code>cbs</code></td>
<td>
<p>A data.frame with a row for each customer and the summary statistic as columns.</p>
</td></tr>
<tr><td><code>elog</code></td>
<td>
<p>A data.frame with a row for each transaction, and columns <code>cust</code>, <code>date</code> and <code>t</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>(M)BG/CNBD-k: Reutterer, T., Platzer, M., &amp; Schroeder, N. (2020).
Leveraging purchase regularity for predicting customer behavior the easy
way. International Journal of Research in Marketing.
doi: <a href="https://doi.org/10.1016/j.ijresmar.2020.09.002">10.1016/j.ijresmar.2020.09.002</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>params &lt;- c(k = 3, r = 0.85, alpha = 1.45, a = 0.79, b = 2.42)
data &lt;- mbgcnbd.GenerateData(n = 200, T.cal = 24, T.star = 32, params)

# customer by sufficient summary statistic - one row per customer
head(data$cbs)

# event log - one row per event/transaction
head(data$elog)
</code></pre>

<hr>
<h2 id='mbgcnbd.PAlive'>(M)BG/CNBD-k P(alive)</h2><span id='topic+mbgcnbd.PAlive'></span><span id='topic+bgcnbd.PAlive'></span>

<h3>Description</h3>

<p>Uses (M)BG/CNBD-k model parameters and a customer's past transaction behavior
to return the probability that they are still alive at the end of the
calibration period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mbgcnbd.PAlive(params, x, t.x, T.cal)

bgcnbd.PAlive(params, x, t.x, T.cal)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mbgcnbd.PAlive_+3A_params">params</code></td>
<td>
<p>A vector with model parameters <code>k</code>, <code>r</code>,
<code>alpha</code>, <code>a</code> and <code>b</code>, in that order.</p>
</td></tr>
<tr><td><code id="mbgcnbd.PAlive_+3A_x">x</code></td>
<td>
<p>Number of repeat transactions in the calibration period T.cal, or a
vector of calibration period frequencies.</p>
</td></tr>
<tr><td><code id="mbgcnbd.PAlive_+3A_t.x">t.x</code></td>
<td>
<p>Recency, i.e. length between first and last transaction during
calibration period.</p>
</td></tr>
<tr><td><code id="mbgcnbd.PAlive_+3A_t.cal">T.cal</code></td>
<td>
<p>Length of calibration period, or a vector of calibration period
lengths.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Probability that the customer is still alive at the end of the
calibration period.
</p>


<h3>References</h3>

<p>(M)BG/CNBD-k: Reutterer, T., Platzer, M., &amp; Schroeder, N. (2020).
Leveraging purchase regularity for predicting customer behavior the easy
way. International Journal of Research in Marketing.
doi: <a href="https://doi.org/10.1016/j.ijresmar.2020.09.002">10.1016/j.ijresmar.2020.09.002</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("groceryElog")
cbs &lt;- elog2cbs(groceryElog)
params &lt;- mbgcnbd.EstimateParameters(cbs)
palive &lt;- mbgcnbd.PAlive(params, cbs$x, cbs$t.x, cbs$T.cal)
head(palive) # Probability of being alive for first 6 customers
mean(palive) # Estimated share of customers to be still alive

## End(Not run)
</code></pre>

<hr>
<h2 id='mbgcnbd.PlotFrequencyInCalibration'>(M)BG/CNBD-k Plot Frequency in Calibration Period</h2><span id='topic+mbgcnbd.PlotFrequencyInCalibration'></span><span id='topic+bgcnbd.PlotFrequencyInCalibration'></span>

<h3>Description</h3>

<p>Plots a histogram and returns a matrix comparing the actual and expected
number of customers who made a certain number of repeat transactions in the
calibration period, binned according to calibration period frequencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mbgcnbd.PlotFrequencyInCalibration(
  params,
  cal.cbs,
  censor = 7,
  xlab = "Calibration period transactions",
  ylab = "Customers",
  title = "Frequency of Repeat Transactions"
)

bgcnbd.PlotFrequencyInCalibration(
  params,
  cal.cbs,
  censor = 7,
  xlab = "Calibration period transactions",
  ylab = "Customers",
  title = "Frequency of Repeat Transactions"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mbgcnbd.PlotFrequencyInCalibration_+3A_params">params</code></td>
<td>
<p>A vector with model parameters <code>k</code>, <code>r</code>,
<code>alpha</code>, <code>a</code> and <code>b</code>, in that order.</p>
</td></tr>
<tr><td><code id="mbgcnbd.PlotFrequencyInCalibration_+3A_cal.cbs">cal.cbs</code></td>
<td>
<p>Calibration period CBS (customer by sufficient statistic). It
must contain columns for frequency ('x') and total time observed ('T.cal').</p>
</td></tr>
<tr><td><code id="mbgcnbd.PlotFrequencyInCalibration_+3A_censor">censor</code></td>
<td>
<p>Cutoff point for number of transactions in plot.</p>
</td></tr>
<tr><td><code id="mbgcnbd.PlotFrequencyInCalibration_+3A_xlab">xlab</code></td>
<td>
<p>Descriptive label for the x axis.</p>
</td></tr>
<tr><td><code id="mbgcnbd.PlotFrequencyInCalibration_+3A_ylab">ylab</code></td>
<td>
<p>Descriptive label for the y axis.</p>
</td></tr>
<tr><td><code id="mbgcnbd.PlotFrequencyInCalibration_+3A_title">title</code></td>
<td>
<p>Title placed on the top-center of the plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Calibration period repeat transaction frequency comparison matrix
(actual vs. expected).
</p>


<h3>References</h3>

<p>(M)BG/CNBD-k: Reutterer, T., Platzer, M., &amp; Schroeder, N. (2020).
Leveraging purchase regularity for predicting customer behavior the easy
way. International Journal of Research in Marketing.
doi: <a href="https://doi.org/10.1016/j.ijresmar.2020.09.002">10.1016/j.ijresmar.2020.09.002</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("groceryElog")
cbs &lt;- elog2cbs(groceryElog)
params &lt;- mbgcnbd.EstimateParameters(cbs)
mbgcnbd.PlotFrequencyInCalibration(params, cbs)

## End(Not run)
</code></pre>

<hr>
<h2 id='mbgcnbd.PlotFreqVsConditionalExpectedFrequency'>(M)BG/CNBD-k Plot Frequency vs. Conditional Expected Frequency</h2><span id='topic+mbgcnbd.PlotFreqVsConditionalExpectedFrequency'></span><span id='topic+bgcnbd.PlotFreqVsConditionalExpectedFrequency'></span>

<h3>Description</h3>

<p>Plots the actual and conditional expected number transactions made by
customers in the holdout period, binned according to calibration period
frequencies, and returns this comparison in a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mbgcnbd.PlotFreqVsConditionalExpectedFrequency(
  params,
  T.star,
  cal.cbs,
  x.star,
  censor,
  xlab = "Calibration period transactions",
  ylab = "Holdout period transactions",
  xticklab = NULL,
  title = "Conditional Expectation"
)

bgcnbd.PlotFreqVsConditionalExpectedFrequency(
  params,
  T.star,
  cal.cbs,
  x.star,
  censor,
  xlab = "Calibration period transactions",
  ylab = "Holdout period transactions",
  xticklab = NULL,
  title = "Conditional Expectation"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mbgcnbd.PlotFreqVsConditionalExpectedFrequency_+3A_params">params</code></td>
<td>
<p>A vector with model parameters <code>k</code>, <code>r</code>,
<code>alpha</code>, <code>a</code> and <code>b</code>, in that order.</p>
</td></tr>
<tr><td><code id="mbgcnbd.PlotFreqVsConditionalExpectedFrequency_+3A_t.star">T.star</code></td>
<td>
<p>Length of the holdout period.</p>
</td></tr>
<tr><td><code id="mbgcnbd.PlotFreqVsConditionalExpectedFrequency_+3A_cal.cbs">cal.cbs</code></td>
<td>
<p>Calibration period CBS (customer by sufficient statistic). It
must contain columns for frequency ('x'), recency ('t.x') and total time
observed ('T.cal').</p>
</td></tr>
<tr><td><code id="mbgcnbd.PlotFreqVsConditionalExpectedFrequency_+3A_x.star">x.star</code></td>
<td>
<p>Vector of transactions made by each customer in the holdout period.</p>
</td></tr>
<tr><td><code id="mbgcnbd.PlotFreqVsConditionalExpectedFrequency_+3A_censor">censor</code></td>
<td>
<p>Cutoff point for number of transactions in plot.</p>
</td></tr>
<tr><td><code id="mbgcnbd.PlotFreqVsConditionalExpectedFrequency_+3A_xlab">xlab</code></td>
<td>
<p>Descriptive label for the x axis.</p>
</td></tr>
<tr><td><code id="mbgcnbd.PlotFreqVsConditionalExpectedFrequency_+3A_ylab">ylab</code></td>
<td>
<p>Descriptive label for the x axis.</p>
</td></tr>
<tr><td><code id="mbgcnbd.PlotFreqVsConditionalExpectedFrequency_+3A_xticklab">xticklab</code></td>
<td>
<p>A vector containing a label for each tick mark on the x axis.</p>
</td></tr>
<tr><td><code id="mbgcnbd.PlotFreqVsConditionalExpectedFrequency_+3A_title">title</code></td>
<td>
<p>Title placed on the top-center of the plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Holdout period transaction frequency comparison matrix (actual vs. expected).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bgcnbd.PlotFreqVsConditionalExpectedFrequency">bgcnbd.PlotFreqVsConditionalExpectedFrequency</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("groceryElog")
cbs &lt;- elog2cbs(groceryElog, T.cal = "2006-09-30")
params &lt;- mbgcnbd.EstimateParameters(cbs, k=2)
mbgcnbd.PlotFreqVsConditionalExpectedFrequency(params, T.star=52, cbs, cbs$x.star, censor=7)

## End(Not run)
</code></pre>

<hr>
<h2 id='mbgcnbd.PlotRecVsConditionalExpectedFrequency'>(M)BG/CNBD-k Plot Actual vs. Conditional Expected Frequency by Recency</h2><span id='topic+mbgcnbd.PlotRecVsConditionalExpectedFrequency'></span><span id='topic+bgcnbd.PlotRecVsConditionalExpectedFrequency'></span>

<h3>Description</h3>

<p>Plots the actual and conditional expected number transactions made by
customers in the holdout period, binned according to calibration period
recencies, and returns this comparison in a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mbgcnbd.PlotRecVsConditionalExpectedFrequency(
  params,
  cal.cbs,
  T.star,
  x.star,
  xlab = "Calibration period recency",
  ylab = "Holdout period transactions",
  xticklab = NULL,
  title = "Actual vs. Conditional Expected Transactions by Recency"
)

bgcnbd.PlotRecVsConditionalExpectedFrequency(
  params,
  cal.cbs,
  T.star,
  x.star,
  xlab = "Calibration period recency",
  ylab = "Holdout period transactions",
  xticklab = NULL,
  title = "Actual vs. Conditional Expected Transactions by Recency"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mbgcnbd.PlotRecVsConditionalExpectedFrequency_+3A_params">params</code></td>
<td>
<p>A vector with model parameters <code>k</code>, <code>r</code>,
<code>alpha</code>, <code>a</code> and <code>b</code>, in that order.</p>
</td></tr>
<tr><td><code id="mbgcnbd.PlotRecVsConditionalExpectedFrequency_+3A_cal.cbs">cal.cbs</code></td>
<td>
<p>Calibration period CBS (customer by sufficient statistic). It
must contain columns for frequency ('x'), recency ('t.x') and total time
observed ('T.cal').</p>
</td></tr>
<tr><td><code id="mbgcnbd.PlotRecVsConditionalExpectedFrequency_+3A_t.star">T.star</code></td>
<td>
<p>Length of the holdout period.</p>
</td></tr>
<tr><td><code id="mbgcnbd.PlotRecVsConditionalExpectedFrequency_+3A_x.star">x.star</code></td>
<td>
<p>Vector of transactions made by each customer in the holdout period.</p>
</td></tr>
<tr><td><code id="mbgcnbd.PlotRecVsConditionalExpectedFrequency_+3A_xlab">xlab</code></td>
<td>
<p>Descriptive label for the x axis.</p>
</td></tr>
<tr><td><code id="mbgcnbd.PlotRecVsConditionalExpectedFrequency_+3A_ylab">ylab</code></td>
<td>
<p>Descriptive label for the x axis.</p>
</td></tr>
<tr><td><code id="mbgcnbd.PlotRecVsConditionalExpectedFrequency_+3A_xticklab">xticklab</code></td>
<td>
<p>A vector containing a label for each tick mark on the x axis.</p>
</td></tr>
<tr><td><code id="mbgcnbd.PlotRecVsConditionalExpectedFrequency_+3A_title">title</code></td>
<td>
<p>Title placed on the top-center of the plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix comparing actual and conditional expected transactions in the holdout period.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bgcnbd.PlotFreqVsConditionalExpectedFrequency">bgcnbd.PlotFreqVsConditionalExpectedFrequency</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("groceryElog")
cbs &lt;- elog2cbs(groceryElog, T.cal = "2006-09-30")
params &lt;- mbgcnbd.EstimateParameters(cbs, k=2)
mbgcnbd.PlotRecVsConditionalExpectedFrequency(params, cbs, T.star=52, cbs$x.star)

## End(Not run)
</code></pre>

<hr>
<h2 id='mbgcnbd.PlotTrackingCum'>(M)BG/CNBD-k Tracking Cumulative Transactions Plot</h2><span id='topic+mbgcnbd.PlotTrackingCum'></span><span id='topic+bgcnbd.PlotTrackingCum'></span>

<h3>Description</h3>

<p>Plots the actual and expected cumulative total repeat transactions by all
customers for the calibration and holdout periods, and returns this
comparison in a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mbgcnbd.PlotTrackingCum(
  params,
  T.cal,
  T.tot,
  actual.cu.tracking.data,
  xlab = "Week",
  ylab = "Cumulative Transactions",
  xticklab = NULL,
  title = "Tracking Cumulative Transactions",
  ymax = NULL,
  legend = c("Actual", "Model")
)

bgcnbd.PlotTrackingCum(
  params,
  T.cal,
  T.tot,
  actual.cu.tracking.data,
  xlab = "Week",
  ylab = "Cumulative Transactions",
  xticklab = NULL,
  title = "Tracking Cumulative Transactions",
  ymax = NULL,
  legend = c("Actual", "Model")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mbgcnbd.PlotTrackingCum_+3A_params">params</code></td>
<td>
<p>A vector with model parameters <code>k</code>, <code>r</code>,
<code>alpha</code>, <code>a</code> and <code>b</code>, in that order.</p>
</td></tr>
<tr><td><code id="mbgcnbd.PlotTrackingCum_+3A_t.cal">T.cal</code></td>
<td>
<p>A vector to represent customers' calibration period lengths.</p>
</td></tr>
<tr><td><code id="mbgcnbd.PlotTrackingCum_+3A_t.tot">T.tot</code></td>
<td>
<p>End of holdout period. Must be a single value, not a vector.</p>
</td></tr>
<tr><td><code id="mbgcnbd.PlotTrackingCum_+3A_actual.cu.tracking.data">actual.cu.tracking.data</code></td>
<td>
<p>A vector containing the cumulative number of
repeat transactions made by customers for each period in the total time
period (both calibration and holdout periods).</p>
</td></tr>
<tr><td><code id="mbgcnbd.PlotTrackingCum_+3A_xlab">xlab</code></td>
<td>
<p>Descriptive label for the x axis.</p>
</td></tr>
<tr><td><code id="mbgcnbd.PlotTrackingCum_+3A_ylab">ylab</code></td>
<td>
<p>Descriptive label for the y axis.</p>
</td></tr>
<tr><td><code id="mbgcnbd.PlotTrackingCum_+3A_xticklab">xticklab</code></td>
<td>
<p>A vector containing a label for each tick mark on the x axis.</p>
</td></tr>
<tr><td><code id="mbgcnbd.PlotTrackingCum_+3A_title">title</code></td>
<td>
<p>Title placed on the top-center of the plot.</p>
</td></tr>
<tr><td><code id="mbgcnbd.PlotTrackingCum_+3A_ymax">ymax</code></td>
<td>
<p>Upper boundary for y axis.</p>
</td></tr>
<tr><td><code id="mbgcnbd.PlotTrackingCum_+3A_legend">legend</code></td>
<td>
<p>plot legend, defaults to 'Actual' and 'Model'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: Computational time increases with the number of unique values of
<code>T.cal</code>.
</p>


<h3>Value</h3>

<p>Matrix containing actual and expected cumulative repeat transactions.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mbgcnbd.ExpectedCumulativeTransactions">mbgcnbd.ExpectedCumulativeTransactions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("groceryElog")
groceryElog &lt;- groceryElog[groceryElog$date &lt; "2006-06-30", ]
cbs &lt;- elog2cbs(groceryElog, T.cal = "2006-04-30")
cum &lt;- elog2cum(groceryElog)
params &lt;- mbgcnbd.EstimateParameters(cbs, k = 2)
mbgcnbd.PlotTrackingCum(params, cbs$T.cal,
  T.tot = max(cbs$T.cal + cbs$T.star), cum)

## End(Not run)
</code></pre>

<hr>
<h2 id='mbgcnbd.PlotTrackingInc'>(M)BG/CNBD-k Tracking Incremental Transactions Comparison</h2><span id='topic+mbgcnbd.PlotTrackingInc'></span><span id='topic+bgcnbd.PlotTrackingInc'></span>

<h3>Description</h3>

<p>Plots the actual and expected incremental total repeat transactions by all
customers for the calibration and holdout periods, and returns this
comparison in a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mbgcnbd.PlotTrackingInc(
  params,
  T.cal,
  T.tot,
  actual.inc.tracking.data,
  xlab = "Week",
  ylab = "Transactions",
  xticklab = NULL,
  title = "Tracking Weekly Transactions",
  ymax = NULL,
  legend = c("Actual", "Model")
)

bgcnbd.PlotTrackingInc(
  params,
  T.cal,
  T.tot,
  actual.inc.tracking.data,
  xlab = "Week",
  ylab = "Transactions",
  xticklab = NULL,
  title = "Tracking Weekly Transactions",
  ymax = NULL,
  legend = c("Actual", "Model")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mbgcnbd.PlotTrackingInc_+3A_params">params</code></td>
<td>
<p>A vector with model parameters <code>k</code>, <code>r</code>,
<code>alpha</code>, <code>a</code> and <code>b</code>, in that order.</p>
</td></tr>
<tr><td><code id="mbgcnbd.PlotTrackingInc_+3A_t.cal">T.cal</code></td>
<td>
<p>A vector to represent customers' calibration period lengths.</p>
</td></tr>
<tr><td><code id="mbgcnbd.PlotTrackingInc_+3A_t.tot">T.tot</code></td>
<td>
<p>End of holdout period. Must be a single value, not a vector.</p>
</td></tr>
<tr><td><code id="mbgcnbd.PlotTrackingInc_+3A_actual.inc.tracking.data">actual.inc.tracking.data</code></td>
<td>
<p>A vector containing the incremental number of
repeat transactions made by customers for each period in the total time
period (both calibration and holdout periods).</p>
</td></tr>
<tr><td><code id="mbgcnbd.PlotTrackingInc_+3A_xlab">xlab</code></td>
<td>
<p>Descriptive label for the x axis.</p>
</td></tr>
<tr><td><code id="mbgcnbd.PlotTrackingInc_+3A_ylab">ylab</code></td>
<td>
<p>Descriptive label for the y axis.</p>
</td></tr>
<tr><td><code id="mbgcnbd.PlotTrackingInc_+3A_xticklab">xticklab</code></td>
<td>
<p>A vector containing a label for each tick mark on the x axis.</p>
</td></tr>
<tr><td><code id="mbgcnbd.PlotTrackingInc_+3A_title">title</code></td>
<td>
<p>Title placed on the top-center of the plot.</p>
</td></tr>
<tr><td><code id="mbgcnbd.PlotTrackingInc_+3A_ymax">ymax</code></td>
<td>
<p>Upper boundary for y axis.</p>
</td></tr>
<tr><td><code id="mbgcnbd.PlotTrackingInc_+3A_legend">legend</code></td>
<td>
<p>plot legend, defaults to 'Actual' and 'Model'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: Computational time increases with the number of unique values of
<code>T.cal</code>.
</p>


<h3>Value</h3>

<p>Matrix containing actual and expected incremental repeat transactions.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mbgcnbd.ExpectedCumulativeTransactions">mbgcnbd.ExpectedCumulativeTransactions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("groceryElog")
groceryElog &lt;- groceryElog[groceryElog$date &lt; "2006-06-30", ]
cbs &lt;- elog2cbs(groceryElog, T.cal = "2006-04-30")
inc &lt;- elog2inc(groceryElog)
params &lt;- mbgcnbd.EstimateParameters(cbs, k = 2)
mbgcnbd.PlotTrackingInc(params, cbs$T.cal,
  T.tot = max(cbs$T.cal + cbs$T.star), inc)

## End(Not run)
</code></pre>

<hr>
<h2 id='mbgcnbd.pmf'>(M)BG/CNBD-k Probability Mass Function</h2><span id='topic+mbgcnbd.pmf'></span><span id='topic+bgcnbd.pmf'></span>

<h3>Description</h3>

<p>Uses (M)BG/CNBD-k model parameters to return the probability distribution of
purchase frequencies for a random customer in a given time period, i.e.
<code class="reqn">P(X(t)=x|r,alpha,a,b)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mbgcnbd.pmf(params, t, x)

bgcnbd.pmf(params, t, x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mbgcnbd.pmf_+3A_params">params</code></td>
<td>
<p>A vector with model parameters <code>k</code>, <code>r</code>,
<code>alpha</code>, <code>a</code> and <code>b</code>, in that order.</p>
</td></tr>
<tr><td><code id="mbgcnbd.pmf_+3A_t">t</code></td>
<td>
<p>Length end of time period for which probability is being computed.
May also be a vector.</p>
</td></tr>
<tr><td><code id="mbgcnbd.pmf_+3A_x">x</code></td>
<td>
<p>Number of repeat transactions for which probability is calculated.
May also be a vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code class="reqn">P(X(t)=x|r,alpha,a,b)</code>. If either <code>t</code> or <code>x</code> is a
vector, then the output will be a vector as well. If both are vectors, the
output will be a matrix.
</p>


<h3>References</h3>

<p>(M)BG/CNBD-k: Reutterer, T., Platzer, M., &amp; Schroeder, N. (2020).
Leveraging purchase regularity for predicting customer behavior the easy
way. International Journal of Research in Marketing.
doi: <a href="https://doi.org/10.1016/j.ijresmar.2020.09.002">10.1016/j.ijresmar.2020.09.002</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("groceryElog")
cbs &lt;- elog2cbs(groceryElog)
params &lt;- mbgcnbd.EstimateParameters(cbs)
mbgcnbd.pmf(params, t = 52, x = 0:6)
mbgcnbd.pmf(params, t = c(26, 52), x = 0:6)

## End(Not run)
</code></pre>

<hr>
<h2 id='mcmc.DrawFutureTransactions'>Draws number of future transactions based on MCMC parameter draws</h2><span id='topic+mcmc.DrawFutureTransactions'></span>

<h3>Description</h3>

<p>For each customer and each provided MCMC parameter draw this method will
sample the number of transactions during the holdout period <code>T.star</code>. If
argument <code>size</code> is provided then it returns a flexible number of draws,
whereas for each customer and each draw it will first make a draw from the
parameter draws.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmc.DrawFutureTransactions(
  cal.cbs,
  draws,
  T.star = cal.cbs$T.star,
  sample_size = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcmc.DrawFutureTransactions_+3A_cal.cbs">cal.cbs</code></td>
<td>
<p>Calibration period customer-by-sufficient-statistic (CBS)
data.frame.</p>
</td></tr>
<tr><td><code id="mcmc.DrawFutureTransactions_+3A_draws">draws</code></td>
<td>
<p>MCMC draws as returned by <code>*.mcmc.DrawParameters</code></p>
</td></tr>
<tr><td><code id="mcmc.DrawFutureTransactions_+3A_t.star">T.star</code></td>
<td>
<p>Length of period for which future transactions are counted.</p>
</td></tr>
<tr><td><code id="mcmc.DrawFutureTransactions_+3A_sample_size">sample_size</code></td>
<td>
<p>Number of samples to draw. Defaults to the same number of
parameter draws that are passed to <code>draws</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>2-dim matrix [draw x customer] with sampled future transactions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("groceryElog")
cbs &lt;- elog2cbs(groceryElog, T.cal = "2006-12-31")
param.draws &lt;- pnbd.mcmc.DrawParameters(cbs,
  mcmc = 100, burnin = 50, thin = 10, chains = 1) # short MCMC to run demo fast
xstar.draws &lt;- mcmc.DrawFutureTransactions(cbs, param.draws)
cbs$xstar.est &lt;- apply(xstar.draws, 2, mean)
cbs$pactive &lt;- mcmc.PActive(xstar.draws)
head(cbs)
</code></pre>

<hr>
<h2 id='mcmc.Expectation'>Unconditional Expectation for Pareto/GGG, Pareto/NBD (HB) and Pareto/NBD (Abe)</h2><span id='topic+mcmc.Expectation'></span>

<h3>Description</h3>

<p>Uses model parameter draws to return the expected number of repeat
transactions that a randomly chosen customer (for whom we have no prior
information) is expected to make in a given time period. </p>
<p style="text-align: center;"><code class="reqn">E(X(t))</code>
</p>
<p>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmc.Expectation(draws, t, sample_size = 10000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcmc.Expectation_+3A_draws">draws</code></td>
<td>
<p>MCMC draws as returned by <code>*.mcmc.DrawParameters</code></p>
</td></tr>
<tr><td><code id="mcmc.Expectation_+3A_t">t</code></td>
<td>
<p>Length of time for which we are calculating the expected number of
transactions. May also be a vector.</p>
</td></tr>
<tr><td><code id="mcmc.Expectation_+3A_sample_size">sample_size</code></td>
<td>
<p>Sample size for estimating the probability distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The expected transactions need to be sampled. Due to this sampling, the
return result varies from one call to another. Larger values of
<code>sample_size</code> will generate more stable results.
</p>


<h3>Value</h3>

<p>Number of repeat transactions a customer is expected to make in a
time period of length t.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("groceryElog")
cbs &lt;- elog2cbs(groceryElog)
param.draws &lt;- pnbd.mcmc.DrawParameters(cbs,
  mcmc = 100, burnin = 50, thin = 10, chains = 1) # short MCMC to run demo fast
mcmc.Expectation(param.draws, t = c(26, 52))
</code></pre>

<hr>
<h2 id='mcmc.ExpectedCumulativeTransactions'>Expected Cumulative Transactions for Pareto/GGG, Pareto/NBD (HB) and
Pareto/NBD (Abe)</h2><span id='topic+mcmc.ExpectedCumulativeTransactions'></span>

<h3>Description</h3>

<p>Uses model parameter draws to return the expected number of repeat
transactions that a randomly chosen customer (for whom we have no prior
information) is expected to make in a given time period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmc.ExpectedCumulativeTransactions(
  draws,
  T.cal,
  T.tot,
  n.periods.final,
  sample_size = 10000,
  covariates = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcmc.ExpectedCumulativeTransactions_+3A_draws">draws</code></td>
<td>
<p>MCMC draws as returned by <code>*.mcmc.DrawParameters</code></p>
</td></tr>
<tr><td><code id="mcmc.ExpectedCumulativeTransactions_+3A_t.cal">T.cal</code></td>
<td>
<p>A vector to represent customers' calibration period lengths (in
other words, the <code>T.cal</code> column from a
customer-by-sufficient-statistic matrix). Considering rounding in order to
speed up calculations.</p>
</td></tr>
<tr><td><code id="mcmc.ExpectedCumulativeTransactions_+3A_t.tot">T.tot</code></td>
<td>
<p>End of holdout period. Must be a single value, not a vector.</p>
</td></tr>
<tr><td><code id="mcmc.ExpectedCumulativeTransactions_+3A_n.periods.final">n.periods.final</code></td>
<td>
<p>Number of time periods in the calibration and holdout
periods.</p>
</td></tr>
<tr><td><code id="mcmc.ExpectedCumulativeTransactions_+3A_sample_size">sample_size</code></td>
<td>
<p>Sample size for estimating the probability distribution.</p>
</td></tr>
<tr><td><code id="mcmc.ExpectedCumulativeTransactions_+3A_covariates">covariates</code></td>
<td>
<p>(optional) Matrix of covariates, for Pareto/NBD (Abe)
model, passed to <code><a href="#topic+abe.GenerateData">abe.GenerateData</a></code> for simulating data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The expected transactions need to be sampled. Due to this sampling, the
return result varies from one call to another. Larger values of
<code>sample_size</code> will generate more stable results.
</p>


<h3>Value</h3>

<p>Numeric vector of expected cumulative total repeat transactions by
all customers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("groceryElog")
cbs &lt;- elog2cbs(groceryElog)
param.draws &lt;- pnbd.mcmc.DrawParameters(cbs,
  mcmc = 100, burnin = 50, thin = 10, chains = 1) # short MCMC to run demo fast
# Returns a vector containing expected cumulative repeat transactions for 104
# weeks, with every eigth week being reported.
mcmc.ExpectedCumulativeTransactions(param.draws,
  T.cal = cbs$T.cal, T.tot = 104, n.periods.final = 104/8, sample_size = 1000)
</code></pre>

<hr>
<h2 id='mcmc.PActive'>Calculates P(active) based on drawn future transactions.</h2><span id='topic+mcmc.PActive'></span>

<h3>Description</h3>

<p>Calculates P(active) based on drawn future transactions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmc.PActive(xstar)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcmc.PActive_+3A_xstar">xstar</code></td>
<td>
<p>Future transaction draws as returned by
<code><a href="#topic+mcmc.DrawFutureTransactions">mcmc.DrawFutureTransactions</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric A vector with the customers' probabilities of being active
during the holdout period.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("groceryElog")
cbs &lt;- elog2cbs(groceryElog, T.cal = "2006-12-31")
param.draws &lt;- pnbd.mcmc.DrawParameters(cbs,
  mcmc = 100, burnin = 50, thin = 10, chains = 1) # short MCMC to run demo fast
xstar.draws &lt;- mcmc.DrawFutureTransactions(cbs, param.draws)
cbs$pactive &lt;- mcmc.PActive(xstar.draws)
head(cbs)
</code></pre>

<hr>
<h2 id='mcmc.PAlive'>Calculates P(alive) based on MCMC parameter draws</h2><span id='topic+mcmc.PAlive'></span>

<h3>Description</h3>

<p>Calculates P(alive) based on MCMC parameter draws
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmc.PAlive(draws)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcmc.PAlive_+3A_draws">draws</code></td>
<td>
<p>MCMC draws as returned by <code>*.mcmc.DrawParameters</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector with the customers' probabilities of being still alive
at end of calibration period
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("groceryElog")
cbs &lt;- elog2cbs(groceryElog)
param.draws &lt;- pnbd.mcmc.DrawParameters(cbs,
  mcmc = 100, burnin = 50, thin = 10, chains = 1) # short MCMC to run demo fast
palive &lt;- mcmc.PAlive(param.draws)
head(palive)
mean(palive)
</code></pre>

<hr>
<h2 id='mcmc.PlotFrequencyInCalibration'>Frequency in Calibration Period for Pareto/GGG, Pareto/NBD (HB) and Pareto/NBD (Abe)</h2><span id='topic+mcmc.PlotFrequencyInCalibration'></span>

<h3>Description</h3>

<p>Plots a histogram and returns a matrix comparing the actual and expected
number of customers who made a certain number of repeat transactions in the
calibration period, binned according to calibration period frequencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmc.PlotFrequencyInCalibration(
  draws,
  cal.cbs,
  censor = 7,
  xlab = "Calibration period transactions",
  ylab = "Customers",
  title = "Frequency of Repeat Transactions",
  sample_size = 1000
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcmc.PlotFrequencyInCalibration_+3A_draws">draws</code></td>
<td>
<p>MCMC draws as returned by <code>*.mcmc.DrawParameters</code></p>
</td></tr>
<tr><td><code id="mcmc.PlotFrequencyInCalibration_+3A_cal.cbs">cal.cbs</code></td>
<td>
<p>Calibration period customer-by-sufficient-statistic (CBS)
data.frame. It must contain columns for frequency ('x') and total time
observed ('T.cal').</p>
</td></tr>
<tr><td><code id="mcmc.PlotFrequencyInCalibration_+3A_censor">censor</code></td>
<td>
<p>Cutoff point for number of transactions in plot.</p>
</td></tr>
<tr><td><code id="mcmc.PlotFrequencyInCalibration_+3A_xlab">xlab</code></td>
<td>
<p>Descriptive label for the x axis.</p>
</td></tr>
<tr><td><code id="mcmc.PlotFrequencyInCalibration_+3A_ylab">ylab</code></td>
<td>
<p>Descriptive label for the y axis.</p>
</td></tr>
<tr><td><code id="mcmc.PlotFrequencyInCalibration_+3A_title">title</code></td>
<td>
<p>Title placed on the top-center of the plot.</p>
</td></tr>
<tr><td><code id="mcmc.PlotFrequencyInCalibration_+3A_sample_size">sample_size</code></td>
<td>
<p>Sample size for estimating the probability distribution.
See <code><a href="#topic+mcmc.pmf">mcmc.pmf</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method <code><a href="#topic+mcmc.pmf">mcmc.pmf</a></code> is called to calculate the expected numbers
based on the corresponding model.
</p>


<h3>Value</h3>

<p>Calibration period repeat transaction frequency comparison matrix
(actual vs. expected).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcmc.pmf">mcmc.pmf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("groceryElog")
cbs &lt;- elog2cbs(groceryElog, T.cal = "2006-12-31")
param.draws &lt;- pnbd.mcmc.DrawParameters(cbs,
  mcmc = 100, burnin = 50, thin = 10, chains = 1) # short MCMC to run demo fast
mcmc.PlotFrequencyInCalibration(param.draws, cbs, sample_size = 100)

## End(Not run)
</code></pre>

<hr>
<h2 id='mcmc.plotPActiveDiagnostic'>Draw diagnostic plot to inspect error in P(active).</h2><span id='topic+mcmc.plotPActiveDiagnostic'></span>

<h3>Description</h3>

<p>Draw diagnostic plot to inspect error in P(active).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmc.plotPActiveDiagnostic(cbs, xstar, title = "Diagnostic Plot for P(active)")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcmc.plotPActiveDiagnostic_+3A_cbs">cbs</code></td>
<td>
<p>A data.frame with column <code>x</code> and <code>x.star</code>.</p>
</td></tr>
<tr><td><code id="mcmc.plotPActiveDiagnostic_+3A_xstar">xstar</code></td>
<td>
<p>Future transaction draws as returned by
<code><a href="#topic+mcmc.DrawFutureTransactions">mcmc.DrawFutureTransactions</a></code>.</p>
</td></tr>
<tr><td><code id="mcmc.plotPActiveDiagnostic_+3A_title">title</code></td>
<td>
<p>Plot title.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data("groceryElog")
cbs &lt;- elog2cbs(groceryElog, T.cal = "2006-12-31")
param.draws &lt;- pnbd.mcmc.DrawParameters(cbs,
  mcmc = 100, burnin = 50, thin = 10, chains = 1) # short MCMC to run demo fast
xstar.draws &lt;- mcmc.DrawFutureTransactions(cbs, param.draws)
mcmc.plotPActiveDiagnostic(cbs, xstar.draws)
</code></pre>

<hr>
<h2 id='mcmc.PlotTrackingCum'>Tracking Cumulative Transactions Plot for Pareto/GGG, Pareto/NBD (HB) and
Pareto/NBD (Abe)</h2><span id='topic+mcmc.PlotTrackingCum'></span>

<h3>Description</h3>

<p>Plots the actual and expected cumulative total repeat transactions by all
customers for the calibration and holdout periods, and returns this
comparison in a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmc.PlotTrackingCum(
  draws,
  T.cal,
  T.tot,
  actual.cu.tracking.data,
  xlab = "Week",
  ylab = "Cumulative Transactions",
  xticklab = NULL,
  title = "Tracking Cumulative Transactions",
  ymax = NULL,
  sample_size = 10000,
  covariates = NULL,
  legend = c("Actual", "Model")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcmc.PlotTrackingCum_+3A_draws">draws</code></td>
<td>
<p>MCMC draws as returned by <code>*.mcmc.DrawParameters</code></p>
</td></tr>
<tr><td><code id="mcmc.PlotTrackingCum_+3A_t.cal">T.cal</code></td>
<td>
<p>A vector to represent customers' calibration period lengths (in
other words, the <code>T.cal</code> column from a
customer-by-sufficient-statistic matrix). Considering rounding in order to
speed up calculations.</p>
</td></tr>
<tr><td><code id="mcmc.PlotTrackingCum_+3A_t.tot">T.tot</code></td>
<td>
<p>End of holdout period. Must be a single value, not a vector.</p>
</td></tr>
<tr><td><code id="mcmc.PlotTrackingCum_+3A_actual.cu.tracking.data">actual.cu.tracking.data</code></td>
<td>
<p>A vector containing the cumulative number of
repeat transactions made by customers for each period in the total time
period (both calibration and holdout periods).</p>
</td></tr>
<tr><td><code id="mcmc.PlotTrackingCum_+3A_xlab">xlab</code></td>
<td>
<p>Descriptive label for the x axis.</p>
</td></tr>
<tr><td><code id="mcmc.PlotTrackingCum_+3A_ylab">ylab</code></td>
<td>
<p>Descriptive label for the y axis.</p>
</td></tr>
<tr><td><code id="mcmc.PlotTrackingCum_+3A_xticklab">xticklab</code></td>
<td>
<p>A vector containing a label for each tick mark on the x axis.</p>
</td></tr>
<tr><td><code id="mcmc.PlotTrackingCum_+3A_title">title</code></td>
<td>
<p>Title placed on the top-center of the plot.</p>
</td></tr>
<tr><td><code id="mcmc.PlotTrackingCum_+3A_ymax">ymax</code></td>
<td>
<p>Upper boundary for y axis.</p>
</td></tr>
<tr><td><code id="mcmc.PlotTrackingCum_+3A_sample_size">sample_size</code></td>
<td>
<p>Sample size for estimating the probability distribution.
See <code><a href="#topic+mcmc.ExpectedCumulativeTransactions">mcmc.ExpectedCumulativeTransactions</a></code>.</p>
</td></tr>
<tr><td><code id="mcmc.PlotTrackingCum_+3A_covariates">covariates</code></td>
<td>
<p>(optional) Matrix of covariates, for Pareto/NBD (Abe)
model, passed to <code><a href="#topic+abe.GenerateData">abe.GenerateData</a></code> for simulating data.</p>
</td></tr>
<tr><td><code id="mcmc.PlotTrackingCum_+3A_legend">legend</code></td>
<td>
<p>plot legend, defaults to 'Actual' and 'Model'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The expected transactions need to be sampled. Due to this sampling, the
return result varies from one call to another. Larger values of
<code>sample_size</code> will generate more stable results.
</p>


<h3>Value</h3>

<p>Matrix containing actual and expected cumulative repeat transactions.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcmc.PlotTrackingInc">mcmc.PlotTrackingInc</a></code>
<code><a href="#topic+mcmc.ExpectedCumulativeTransactions">mcmc.ExpectedCumulativeTransactions</a></code> <code><a href="#topic+elog2cum">elog2cum</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("groceryElog")
cbs &lt;- elog2cbs(groceryElog, T.cal = "2006-12-31")
cum &lt;- elog2cum(groceryElog)
param.draws &lt;- pnbd.mcmc.DrawParameters(cbs)
mat &lt;- mcmc.PlotTrackingCum(param.draws,
  T.cal = cbs$T.cal,
  T.tot = max(cbs$T.cal + cbs$T.star),
  actual.cu.tracking.data = cum)

## End(Not run)
</code></pre>

<hr>
<h2 id='mcmc.PlotTrackingInc'>Tracking Incremental Transactions Plot for Pareto/GGG, Pareto/NBD (HB) and
Pareto/NBD (Abe)</h2><span id='topic+mcmc.PlotTrackingInc'></span>

<h3>Description</h3>

<p>Plots the actual and expected incremental total repeat transactions by all
customers for the calibration and holdout periods, and returns this
comparison in a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmc.PlotTrackingInc(
  draws,
  T.cal,
  T.tot,
  actual.inc.tracking.data,
  xlab = "Week",
  ylab = "Transactions",
  xticklab = NULL,
  title = "Tracking Weekly Transactions",
  ymax = NULL,
  sample_size = 10000,
  covariates = NULL,
  legend = c("Actual", "Model")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcmc.PlotTrackingInc_+3A_draws">draws</code></td>
<td>
<p>MCMC draws as returned by <code>*.mcmc.DrawParameters</code></p>
</td></tr>
<tr><td><code id="mcmc.PlotTrackingInc_+3A_t.cal">T.cal</code></td>
<td>
<p>A vector to represent customers' calibration period lengths (in
other words, the <code>T.cal</code> column from a
customer-by-sufficient-statistic matrix). Considering rounding in order to
speed up calculations.</p>
</td></tr>
<tr><td><code id="mcmc.PlotTrackingInc_+3A_t.tot">T.tot</code></td>
<td>
<p>End of holdout period. Must be a single value, not a vector.</p>
</td></tr>
<tr><td><code id="mcmc.PlotTrackingInc_+3A_actual.inc.tracking.data">actual.inc.tracking.data</code></td>
<td>
<p>A vector containing the incremental number of
repeat transactions made by customers for each period in the total time
period (both calibration and holdout periods).</p>
</td></tr>
<tr><td><code id="mcmc.PlotTrackingInc_+3A_xlab">xlab</code></td>
<td>
<p>Descriptive label for the x axis.</p>
</td></tr>
<tr><td><code id="mcmc.PlotTrackingInc_+3A_ylab">ylab</code></td>
<td>
<p>Descriptive label for the y axis.</p>
</td></tr>
<tr><td><code id="mcmc.PlotTrackingInc_+3A_xticklab">xticklab</code></td>
<td>
<p>A vector containing a label for each tick mark on the x axis.</p>
</td></tr>
<tr><td><code id="mcmc.PlotTrackingInc_+3A_title">title</code></td>
<td>
<p>Title placed on the top-center of the plot.</p>
</td></tr>
<tr><td><code id="mcmc.PlotTrackingInc_+3A_ymax">ymax</code></td>
<td>
<p>Upper boundary for y axis.</p>
</td></tr>
<tr><td><code id="mcmc.PlotTrackingInc_+3A_sample_size">sample_size</code></td>
<td>
<p>Sample size for estimating the probability distribution.
See <code><a href="#topic+mcmc.ExpectedCumulativeTransactions">mcmc.ExpectedCumulativeTransactions</a></code>.</p>
</td></tr>
<tr><td><code id="mcmc.PlotTrackingInc_+3A_covariates">covariates</code></td>
<td>
<p>(optional) Matrix of covariates, for Pareto/NBD (Abe)
model, passed to <code><a href="#topic+abe.GenerateData">abe.GenerateData</a></code> for simulating data.</p>
</td></tr>
<tr><td><code id="mcmc.PlotTrackingInc_+3A_legend">legend</code></td>
<td>
<p>plot legend, defaults to 'Actual' and 'Model'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The expected transactions need to be sampled. Due to this sampling, the
return result varies from one call to another. Larger values of
<code>sample_size</code> will generate more stable results.
</p>


<h3>Value</h3>

<p>Matrix containing actual and expected incremental repeat
transactions.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcmc.PlotTrackingCum">mcmc.PlotTrackingCum</a></code>
<code><a href="#topic+mcmc.ExpectedCumulativeTransactions">mcmc.ExpectedCumulativeTransactions</a></code> <code><a href="#topic+elog2inc">elog2inc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("groceryElog")
cbs &lt;- elog2cbs(groceryElog, T.cal = "2006-12-31")
inc &lt;- elog2inc(groceryElog)
param.draws &lt;- pnbd.mcmc.DrawParameters(cbs)
mat &lt;- mcmc.PlotTrackingInc(param.draws,
  T.cal = cbs$T.cal,
  T.tot = max(cbs$T.cal + cbs$T.star),
  actual.inc.tracking.data = inc)

## End(Not run)
</code></pre>

<hr>
<h2 id='mcmc.pmf'>Probability Mass Function for Pareto/GGG, Pareto/NBD (HB) and Pareto/NBD (Abe)</h2><span id='topic+mcmc.pmf'></span>

<h3>Description</h3>

<p>Return the probability distribution of purchase frequencies for a random
customer in a given time period, i.e. <code class="reqn">P(X(t)=x)</code>. This is estimated by
generating <code>sample_size</code> number of random customers that follow the
provided parameter draws. Due to this sampling, the return result varies from
one call to another.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmc.pmf(draws, t, x, sample_size = 10000, covariates = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcmc.pmf_+3A_draws">draws</code></td>
<td>
<p>MCMC draws as returned by <code>*.mcmc.DrawParameters</code></p>
</td></tr>
<tr><td><code id="mcmc.pmf_+3A_t">t</code></td>
<td>
<p>Length of time for which we are calculating the expected number of
transactions. May also be a vector.</p>
</td></tr>
<tr><td><code id="mcmc.pmf_+3A_x">x</code></td>
<td>
<p>Number of transactions for which probability is calculated. May also
be a vector.</p>
</td></tr>
<tr><td><code id="mcmc.pmf_+3A_sample_size">sample_size</code></td>
<td>
<p>Sample size for estimating the probability distribution.</p>
</td></tr>
<tr><td><code id="mcmc.pmf_+3A_covariates">covariates</code></td>
<td>
<p>(optional) Matrix of covariates, for Pareto/NBD (Abe)
model, passed to <code><a href="#topic+abe.GenerateData">abe.GenerateData</a></code> for simulating data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code class="reqn">P(X(t)=x)</code>. If either <code>t</code> or <code>x</code> is a vector, then the
output will be a vector as well. If both are vectors, the output will be a
matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("groceryElog")
cbs &lt;- elog2cbs(groceryElog)
param.draws &lt;- pnbd.mcmc.DrawParameters(cbs,
  mcmc = 100, burnin = 50, thin = 10, chains = 1) # short MCMC to run demo fast
mcmc.pmf(param.draws, t = c(26, 52), x = 0:6)
</code></pre>

<hr>
<h2 id='mcmc.setBurnin'>(Re-)set burnin of MCMC chains.</h2><span id='topic+mcmc.setBurnin'></span>

<h3>Description</h3>

<p>(Re-)set burnin of MCMC chains.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmc.setBurnin(draws, burnin)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcmc.setBurnin_+3A_draws">draws</code></td>
<td>
<p>MCMC draws as returned by <code>*.mcmc.DrawParameters</code></p>
</td></tr>
<tr><td><code id="mcmc.setBurnin_+3A_burnin">burnin</code></td>
<td>
<p>New start index.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>2-element list with MCMC draws
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("groceryElog")
cbs &lt;- elog2cbs(groceryElog)
param.draws &lt;- pnbd.mcmc.DrawParameters(cbs,
  mcmc = 100, burnin = 50, thin = 10, chains = 1) # short MCMC to run demo fast
param.draws.stable &lt;- mcmc.setBurnin(param.draws, burnin = 80)
</code></pre>

<hr>
<h2 id='nbd.cbs.LL'>Calculate the log-likelihood of the NBD model</h2><span id='topic+nbd.cbs.LL'></span>

<h3>Description</h3>

<p>Calculate the log-likelihood of the NBD model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nbd.cbs.LL(params, cal.cbs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nbd.cbs.LL_+3A_params">params</code></td>
<td>
<p>NBD parameters - a vector with r and alpha, in that
order.</p>
</td></tr>
<tr><td><code id="nbd.cbs.LL_+3A_cal.cbs">cal.cbs</code></td>
<td>
<p>Calibration period CBS. It must contain columns for frequency
<code>x</code> and total time observed <code>T.cal</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The total log-likelihood for the provided data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("groceryElog")
cbs &lt;- elog2cbs(groceryElog)
params &lt;- nbd.EstimateParameters(cbs)
nbd.cbs.LL(params, cbs)
</code></pre>

<hr>
<h2 id='nbd.ConditionalExpectedTransactions'>NBD Conditional Expected Transactions</h2><span id='topic+nbd.ConditionalExpectedTransactions'></span>

<h3>Description</h3>

<p>Uses NBD model parameters and a customer's past transaction behavior to
return the number of transactions they are expected to make in a given time
period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nbd.ConditionalExpectedTransactions(params, T.star, x, T.cal)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nbd.ConditionalExpectedTransactions_+3A_params">params</code></td>
<td>
<p>NBD parameters - a vector with <code>r</code> and <code>alpha</code>, in that order.</p>
</td></tr>
<tr><td><code id="nbd.ConditionalExpectedTransactions_+3A_t.star">T.star</code></td>
<td>
<p>Length of time for which we are calculating the expected number
of transactions.</p>
</td></tr>
<tr><td><code id="nbd.ConditionalExpectedTransactions_+3A_x">x</code></td>
<td>
<p>Number of repeat transactions in the calibration period <code>T.cal</code>, or a
vector of calibration period frequencies.</p>
</td></tr>
<tr><td><code id="nbd.ConditionalExpectedTransactions_+3A_t.cal">T.cal</code></td>
<td>
<p>Length of calibration period, or a vector of calibration period
lengths.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Number of transactions a customer is expected to make in a time
period of length t, conditional on their past behavior. If any of the input
parameters has a length greater than 1, this will be a vector of expected
number of transactions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("groceryElog")
cbs &lt;- elog2cbs(groceryElog, T.cal = "2006-12-31")
params &lt;- nbd.EstimateParameters(cbs)
xstar.est &lt;- nbd.ConditionalExpectedTransactions(params, cbs$T.star, cbs$x, cbs$T.cal)
sum(xstar.est) # expected total number of transactions during holdout
</code></pre>

<hr>
<h2 id='nbd.EstimateParameters'>Parameter Estimation for the NBD model</h2><span id='topic+nbd.EstimateParameters'></span>

<h3>Description</h3>

<p>Estimates parameters for the NBD model via Maximum Likelihood Estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nbd.EstimateParameters(cal.cbs, par.start = c(1, 1), max.param.value = 10000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nbd.EstimateParameters_+3A_cal.cbs">cal.cbs</code></td>
<td>
<p>Calibration period CBS. It must contain columns for frequency
<code>x</code> and total time observed <code>T.cal</code>.</p>
</td></tr>
<tr><td><code id="nbd.EstimateParameters_+3A_par.start">par.start</code></td>
<td>
<p>Initial NBD parameters - a vector with <code>r</code> and <code>alpha</code> in
that order.</p>
</td></tr>
<tr><td><code id="nbd.EstimateParameters_+3A_max.param.value">max.param.value</code></td>
<td>
<p>Upper bound on parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of estimated parameters.
</p>


<h3>References</h3>

<p>Ehrenberg, A. S. (1959). The pattern of consumer purchases.
Journal of the Royal Statistical Society: Series C (Applied Statistics),
8(1), 26-41. doi: <a href="https://doi.org/10.2307/2985810">10.2307/2985810</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("groceryElog")
cbs &lt;- elog2cbs(groceryElog)
nbd.EstimateParameters(cbs)
</code></pre>

<hr>
<h2 id='nbd.GenerateData'>Simulate data according to NBD model assumptions</h2><span id='topic+nbd.GenerateData'></span>

<h3>Description</h3>

<p>Simulate data according to NBD model assumptions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nbd.GenerateData(n, T.cal, T.star, params, date.zero = "2000-01-01")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nbd.GenerateData_+3A_n">n</code></td>
<td>
<p>Number of customers.</p>
</td></tr>
<tr><td><code id="nbd.GenerateData_+3A_t.cal">T.cal</code></td>
<td>
<p>Length of calibration period.</p>
</td></tr>
<tr><td><code id="nbd.GenerateData_+3A_t.star">T.star</code></td>
<td>
<p>Length of holdout period. This may be a vector.</p>
</td></tr>
<tr><td><code id="nbd.GenerateData_+3A_params">params</code></td>
<td>
<p>NBD parameters - a vector with <code>r</code> and <code>alpha</code> in that order.</p>
</td></tr>
<tr><td><code id="nbd.GenerateData_+3A_date.zero">date.zero</code></td>
<td>
<p>Initial date for cohort start. Can be of class character, Date or POSIXt.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of length 2:
</p>
<table role = "presentation">
<tr><td><code>cbs</code></td>
<td>
<p>A data.frame with a row for each customer and the summary statistic as columns.</p>
</td></tr>
<tr><td><code>elog</code></td>
<td>
<p>A data.frame with a row for each transaction, and columns <code>cust</code>, <code>date</code> and <code>t</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 200  # no. of customers
T.cal &lt;- 32  # length of calibration period
T.star &lt;- 32  # length of hold-out period
params &lt;- c(r = 0.85, alpha = 4.45)  # purchase frequency lambda_i ~ Gamma(r, alpha)
data &lt;- nbd.GenerateData(n, T.cal, T.star, params)
cbs &lt;- data$cbs  # customer by sufficient summary statistic - one row per customer
elog &lt;- data$elog  # Event log - one row per event/purchase
</code></pre>

<hr>
<h2 id='nbd.LL'>Calculate the log-likelihood of the NBD model</h2><span id='topic+nbd.LL'></span>

<h3>Description</h3>

<p>Calculate the log-likelihood of the NBD model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nbd.LL(params, x, T.cal)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nbd.LL_+3A_params">params</code></td>
<td>
<p>NBD parameters - a vector with <code>r</code> and <code>alpha</code>, in that
order.</p>
</td></tr>
<tr><td><code id="nbd.LL_+3A_x">x</code></td>
<td>
<p>Frequency, i.e. number of re-purchases.</p>
</td></tr>
<tr><td><code id="nbd.LL_+3A_t.cal">T.cal</code></td>
<td>
<p>Total time of observation period.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of log-likelihoods.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nbd.cbs.LL">nbd.cbs.LL</a></code>
</p>

<hr>
<h2 id='pggg.GenerateData'>Simulate data according to Pareto/GGG model assumptions</h2><span id='topic+pggg.GenerateData'></span>

<h3>Description</h3>

<p>Simulate data according to Pareto/GGG model assumptions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pggg.GenerateData(n, T.cal, T.star, params, date.zero = "2000-01-01")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pggg.GenerateData_+3A_n">n</code></td>
<td>
<p>Number of customers.</p>
</td></tr>
<tr><td><code id="pggg.GenerateData_+3A_t.cal">T.cal</code></td>
<td>
<p>Length of calibration period. If a vector is provided, then it
is assumed that customers have different 'birth' dates, i.e.
<code class="reqn">max(T.cal)-T.cal</code>.</p>
</td></tr>
<tr><td><code id="pggg.GenerateData_+3A_t.star">T.star</code></td>
<td>
<p>Length of holdout period. This may be a vector.</p>
</td></tr>
<tr><td><code id="pggg.GenerateData_+3A_params">params</code></td>
<td>
<p>A list of model parameters <code>r</code>,
<code>alpha</code>, <code>s</code>, <code>beta</code>, <code>t</code> and <code>gamma</code>.</p>
</td></tr>
<tr><td><code id="pggg.GenerateData_+3A_date.zero">date.zero</code></td>
<td>
<p>Initial date for cohort start. Can be of class character, Date or POSIXt.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of length 2:
</p>
<table role = "presentation">
<tr><td><code>cbs</code></td>
<td>
<p>A data.frame with a row for each customer and the summary statistic as columns.</p>
</td></tr>
<tr><td><code>elog</code></td>
<td>
<p>A data.frame with a row for each transaction, and columns <code>cust</code>, <code>date</code> and <code>t</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Platzer, M., &amp; Reutterer, T. (2016). Ticking away the moments:
Timing regularity helps to better predict customer activity. Marketing
Science, 35(5), 779-799. doi: <a href="https://doi.org/10.1287/mksc.2015.0963">10.1287/mksc.2015.0963</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>params &lt;- list(t = 4.5, gamma = 1.5, r = 5, alpha = 10, s = 0.8, beta = 12)
data &lt;- pggg.GenerateData(n = 200, T.cal = 32, T.star = 32, params)
cbs &lt;- data$cbs  # customer by sufficient summary statistic - one row per customer
elog &lt;- data$elog  # Event log - one row per event/purchase
</code></pre>

<hr>
<h2 id='pggg.mcmc.DrawParameters'>Pareto/GGG Parameter Draws</h2><span id='topic+pggg.mcmc.DrawParameters'></span>

<h3>Description</h3>

<p>Returns draws from the posterior distributions of the Pareto/GGG
parameters, on cohort as well as on customer level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pggg.mcmc.DrawParameters(
  cal.cbs,
  mcmc = 2500,
  burnin = 500,
  thin = 50,
  chains = 2,
  mc.cores = NULL,
  param_init = NULL,
  trace = 100
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pggg.mcmc.DrawParameters_+3A_cal.cbs">cal.cbs</code></td>
<td>
<p>Calibration period customer-by-sufficient-statistic (CBS)
data.frame. It must contain a row for each customer, and columns <code>x</code>
for frequency, <code>t.x</code> for recency , <code>T.cal</code> for the total time
observed, as well as the sum over logarithmic intertransaction times
<code>litt</code>. A correct format can be easily generated based on the complete
event log of a customer cohort with <code><a href="#topic+elog2cbs">elog2cbs</a></code>.</p>
</td></tr>
<tr><td><code id="pggg.mcmc.DrawParameters_+3A_mcmc">mcmc</code></td>
<td>
<p>Number of MCMC steps.</p>
</td></tr>
<tr><td><code id="pggg.mcmc.DrawParameters_+3A_burnin">burnin</code></td>
<td>
<p>Number of initial MCMC steps which are discarded.</p>
</td></tr>
<tr><td><code id="pggg.mcmc.DrawParameters_+3A_thin">thin</code></td>
<td>
<p>Only every <code>thin</code>-th MCMC step will be returned.</p>
</td></tr>
<tr><td><code id="pggg.mcmc.DrawParameters_+3A_chains">chains</code></td>
<td>
<p>Number of MCMC chains to be run.</p>
</td></tr>
<tr><td><code id="pggg.mcmc.DrawParameters_+3A_mc.cores">mc.cores</code></td>
<td>
<p>Number of cores to use in parallel (Unix only). Defaults to <code>min(chains, detectCores())</code>.</p>
</td></tr>
<tr><td><code id="pggg.mcmc.DrawParameters_+3A_param_init">param_init</code></td>
<td>
<p>List of start values for cohort-level parameters.</p>
</td></tr>
<tr><td><code id="pggg.mcmc.DrawParameters_+3A_trace">trace</code></td>
<td>
<p>Print logging statement every <code>trace</code>-th iteration. Not available for <code>mc.cores &gt; 1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code>demo('pareto-ggg')</code> for how to apply this model.
</p>


<h3>Value</h3>

<p>List of length 2:
</p>
<table role = "presentation">
<tr><td><code>level_1</code></td>
<td>
<p>list of <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code>s, one for each customer, with draws for customer-level parameters <code>k</code>, <code>lambda</code>, <code>tau</code>, <code>z</code>, <code>mu</code></p>
</td></tr>
<tr><td><code>level_2</code></td>
<td>
<p><code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code>, with draws for cohort-level parameters <code>r</code>, <code>alpha</code>, <code>s</code>, <code>beta</code>, <code>t</code>, <code>gamma</code></p>
</td></tr>
</table>


<h3>References</h3>

<p>Platzer, M., &amp; Reutterer, T. (2016). Ticking away the moments:
Timing regularity helps to better predict customer activity. Marketing
Science, 35(5), 779-799. doi: <a href="https://doi.org/10.1287/mksc.2015.0963">10.1287/mksc.2015.0963</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pggg.GenerateData">pggg.GenerateData</a> </code> <code><a href="#topic+mcmc.PAlive">mcmc.PAlive</a> </code> <code><a href="#topic+mcmc.DrawFutureTransactions">mcmc.DrawFutureTransactions</a> </code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("groceryElog")
cbs &lt;- elog2cbs(groceryElog, T.cal = "2006-12-31")
param.draws &lt;- pggg.mcmc.DrawParameters(cbs,
  mcmc = 20, burnin = 10, thin = 2, chains = 1) # short MCMC to run demo fast

# cohort-level parameter draws
as.matrix(param.draws$level_2)
# customer-level parameter draws for customer with ID '4'
as.matrix(param.draws$level_1[["4"]])

# estimate future transactions
xstar.draws &lt;- mcmc.DrawFutureTransactions(cbs, param.draws, cbs$T.star)
xstar.est &lt;- apply(xstar.draws, 2, mean)
head(xstar.est)
</code></pre>

<hr>
<h2 id='pggg.plotRegularityRateHeterogeneity'>Pareto/GGG Plot Regularity Rate Heterogeneity</h2><span id='topic+pggg.plotRegularityRateHeterogeneity'></span>

<h3>Description</h3>

<p>Plots and returns the estimated gamma distribution of k (customers'
regularity in interpurchase times).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pggg.plotRegularityRateHeterogeneity(
  draws,
  xmax = NULL,
  fn = NULL,
  title = "Distribution of Regularity Rate k"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pggg.plotRegularityRateHeterogeneity_+3A_draws">draws</code></td>
<td>
<p>MCMC draws as returned by <code><a href="#topic+pggg.mcmc.DrawParameters">pggg.mcmc.DrawParameters</a></code>.</p>
</td></tr>
<tr><td><code id="pggg.plotRegularityRateHeterogeneity_+3A_xmax">xmax</code></td>
<td>
<p>Upper bound for x-scale.</p>
</td></tr>
<tr><td><code id="pggg.plotRegularityRateHeterogeneity_+3A_fn">fn</code></td>
<td>
<p>Optional function to summarize individual-level draws for k, e.g. 'mean'.</p>
</td></tr>
<tr><td><code id="pggg.plotRegularityRateHeterogeneity_+3A_title">title</code></td>
<td>
<p>Plot title.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Platzer, M., &amp; Reutterer, T. (2016). Ticking away the moments:
Timing regularity helps to better predict customer activity. Marketing
Science, 35(5), 779-799. doi: <a href="https://doi.org/10.1287/mksc.2015.0963">10.1287/mksc.2015.0963</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("groceryElog")
cbs &lt;- elog2cbs(groceryElog, T.cal = "2006-12-31")
param.draws &lt;- pggg.mcmc.DrawParameters(cbs,
  mcmc = 20, burnin = 10, thin = 2, chains = 1) # short MCMC to run demo fast
pggg.plotRegularityRateHeterogeneity(param.draws)
</code></pre>

<hr>
<h2 id='plotTimingPatterns'>Plot timing patterns of sampled customers</h2><span id='topic+plotTimingPatterns'></span>

<h3>Description</h3>

<p>Plot timing patterns of sampled customers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotTimingPatterns(
  elog,
  n = 40,
  T.cal = NULL,
  T.tot = NULL,
  title = "Sampled Timing Patterns",
  headers = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotTimingPatterns_+3A_elog">elog</code></td>
<td>
<p>Event log, a <code>data.frame</code> with columns <code>cust</code> and
transaction time <code>t</code> or <code>date</code>.</p>
</td></tr>
<tr><td><code id="plotTimingPatterns_+3A_n">n</code></td>
<td>
<p>Number of sampled customers.</p>
</td></tr>
<tr><td><code id="plotTimingPatterns_+3A_t.cal">T.cal</code></td>
<td>
<p>End of calibration period, which is visualized as a vertical line.</p>
</td></tr>
<tr><td><code id="plotTimingPatterns_+3A_t.tot">T.tot</code></td>
<td>
<p>End of observation period</p>
</td></tr>
<tr><td><code id="plotTimingPatterns_+3A_title">title</code></td>
<td>
<p>Plot title.</p>
</td></tr>
<tr><td><code id="plotTimingPatterns_+3A_headers">headers</code></td>
<td>
<p>Vector of length 2 for adding headers to the plot, e.g.
<code>c("Calibration", "Holdout")</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data("groceryElog")
plotTimingPatterns(groceryElog, T.tot = "2008-12-31")
plotTimingPatterns(groceryElog, T.cal = "2006-12-31", headers = c("Calibration", "Holdout"))
</code></pre>

<hr>
<h2 id='pnbd.GenerateData'>Simulate data according to Pareto/NBD model assumptions</h2><span id='topic+pnbd.GenerateData'></span>

<h3>Description</h3>

<p>Simulate data according to Pareto/NBD model assumptions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pnbd.GenerateData(n, T.cal, T.star, params, date.zero = "2000-01-01")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pnbd.GenerateData_+3A_n">n</code></td>
<td>
<p>Number of customers.</p>
</td></tr>
<tr><td><code id="pnbd.GenerateData_+3A_t.cal">T.cal</code></td>
<td>
<p>Length of calibration period. If a vector is provided, then it
is assumed that customers have different 'birth' dates, i.e.
<code class="reqn">max(T.cal)-T.cal</code>.</p>
</td></tr>
<tr><td><code id="pnbd.GenerateData_+3A_t.star">T.star</code></td>
<td>
<p>Length of holdout period. This may be a vector.</p>
</td></tr>
<tr><td><code id="pnbd.GenerateData_+3A_params">params</code></td>
<td>
<p>A list of model parameters <code>r</code>,
<code>alpha</code>, <code>s</code>, <code>beta</code>.</p>
</td></tr>
<tr><td><code id="pnbd.GenerateData_+3A_date.zero">date.zero</code></td>
<td>
<p>Initial date for cohort start. Can be of class character, Date or POSIXt.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of length 2:
</p>
<table role = "presentation">
<tr><td><code>cbs</code></td>
<td>
<p>A data.frame with a row for each customer and the summary statistic as columns.</p>
</td></tr>
<tr><td><code>elog</code></td>
<td>
<p>A data.frame with a row for each transaction, and columns <code>cust</code>, <code>date</code> and <code>t</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>params &lt;- list(r = 5, alpha = 10, s = 0.8, beta = 12)
data &lt;- pnbd.GenerateData(n = 200, T.cal = 32, T.star = 32, params)
cbs &lt;- data$cbs  # customer by sufficient summary statistic - one row per customer
elog &lt;- data$elog  # Event log - one row per event/purchase
</code></pre>

<hr>
<h2 id='pnbd.mcmc.DrawParameters'>Pareto/NBD (HB) Parameter Draws</h2><span id='topic+pnbd.mcmc.DrawParameters'></span>

<h3>Description</h3>

<p>Returns draws from the posterior distributions of the Pareto/NBD (HB)
parameters, on cohort as well as on customer level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pnbd.mcmc.DrawParameters(
  cal.cbs,
  mcmc = 2500,
  burnin = 500,
  thin = 50,
  chains = 2,
  mc.cores = NULL,
  use_data_augmentation = TRUE,
  param_init = NULL,
  trace = 100
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pnbd.mcmc.DrawParameters_+3A_cal.cbs">cal.cbs</code></td>
<td>
<p>Calibration period customer-by-sufficient-statistic (CBS)
data.frame. It must contain a row for each customer, and columns <code>x</code>
for frequency, <code>t.x</code> for recency and <code>T.cal</code> for the total time
observed. A correct format can be easily generated based on the complete
event log of a customer cohort with <code><a href="#topic+elog2cbs">elog2cbs</a></code>.</p>
</td></tr>
<tr><td><code id="pnbd.mcmc.DrawParameters_+3A_mcmc">mcmc</code></td>
<td>
<p>Number of MCMC steps.</p>
</td></tr>
<tr><td><code id="pnbd.mcmc.DrawParameters_+3A_burnin">burnin</code></td>
<td>
<p>Number of initial MCMC steps which are discarded.</p>
</td></tr>
<tr><td><code id="pnbd.mcmc.DrawParameters_+3A_thin">thin</code></td>
<td>
<p>Only every <code>thin</code>-th MCMC step will be returned.</p>
</td></tr>
<tr><td><code id="pnbd.mcmc.DrawParameters_+3A_chains">chains</code></td>
<td>
<p>Number of MCMC chains to be run.</p>
</td></tr>
<tr><td><code id="pnbd.mcmc.DrawParameters_+3A_mc.cores">mc.cores</code></td>
<td>
<p>Number of cores to use in parallel (Unix only). Defaults to <code>min(chains, detectCores())</code>.</p>
</td></tr>
<tr><td><code id="pnbd.mcmc.DrawParameters_+3A_use_data_augmentation">use_data_augmentation</code></td>
<td>
<p>deprecated</p>
</td></tr>
<tr><td><code id="pnbd.mcmc.DrawParameters_+3A_param_init">param_init</code></td>
<td>
<p>List of start values for cohort-level parameters.</p>
</td></tr>
<tr><td><code id="pnbd.mcmc.DrawParameters_+3A_trace">trace</code></td>
<td>
<p>Print logging statement every <code>trace</code>-th iteration. Not available for <code>mc.cores &gt; 1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code>demo('pareto-ggg')</code> for how to apply this model.
</p>


<h3>Value</h3>

<p>2-element list:
</p>

<ul>
<li><p><code>level_1 </code>list of <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code>s, one for each customer, with draws for customer-level parameters <code>lambda</code>, <code>tau</code>, <code>z</code>, <code>mu</code>
</p>
</li>
<li><p><code>level_2 </code><code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code>, with draws for cohort-level parameters <code>r</code>, <code>alpha</code>, <code>s</code>, <code>beta</code>
</p>
</li></ul>



<h3>References</h3>

<p>Ma, S. H., &amp; Liu, J. L. (2007, August). The MCMC approach for
solving the Pareto/NBD model and possible extensions. In Third
international conference on natural computation (ICNC 2007) (Vol. 2, pp.
505-512). IEEE. doi: <a href="https://doi.org/10.1109/ICNC.2007.728">10.1109/ICNC.2007.728</a>
</p>
<p>Abe, M. (2009). &quot;Counting your customers&quot; one by one: A
hierarchical Bayes extension to the Pareto/NBD model. Marketing Science,
28(3), 541-553. doi: <a href="https://doi.org/10.1287/mksc.1090.0502">10.1287/mksc.1090.0502</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pnbd.GenerateData">pnbd.GenerateData</a> </code> <code><a href="#topic+mcmc.DrawFutureTransactions">mcmc.DrawFutureTransactions</a> </code> <code><a href="#topic+mcmc.PAlive">mcmc.PAlive</a> </code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("groceryElog")
cbs &lt;- elog2cbs(groceryElog, T.cal = "2006-12-31")
param.draws &lt;- pnbd.mcmc.DrawParameters(cbs,
  mcmc = 100, burnin = 50, thin = 10, chains = 1) # short MCMC to run demo fast

# cohort-level parameter draws
as.matrix(param.draws$level_2)
# customer-level parameter draws for customer with ID '4'
as.matrix(param.draws$level_1[["4"]])

# estimate future transactions
xstar.draws &lt;- mcmc.DrawFutureTransactions(cbs, param.draws, cbs$T.star)
xstar.est &lt;- apply(xstar.draws, 2, mean)
head(xstar.est)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
