<!DOCTYPE html><html lang="en"><head><title>Help for package gganimate</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gganimate}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#gganimate-package'><p>gganimate: A Grammar of Animated Graphics</p></a></li>
<li><a href='#anim_save'><p>Save an animation to a file</p></a></li>
<li><a href='#animate'><p>Render a gganim object</p></a></li>
<li><a href='#ease_aes'><p>Control easing of aesthetics</p></a></li>
<li><a href='#enter_exit'><p>Define how entering and exiting data behaves</p></a></li>
<li><a href='#frame_vars'><p>Access metadata about the frames in an animation</p></a></li>
<li><a href='#gganimate'><p>Catch attempt to use the old API</p></a></li>
<li><a href='#gganimate-ggproto'><p>Base ggproto classes for gganimate</p></a></li>
<li><a href='#gif_file'><p>Wrap a gif file for easy handling</p></a></li>
<li><a href='#group_column'><p>Define what graphical type a layer is</p></a></li>
<li><a href='#last_animation'><p>Retrieve the last rendered animation</p></a></li>
<li><a href='#renderers'><p>Renderers provided by gganimate</p></a></li>
<li><a href='#save_animation'><p>Infrastructure for animation saving</p></a></li>
<li><a href='#shadow_mark'><p>Show original data as background marks</p></a></li>
<li><a href='#shadow_null'><p>A non-existent shadow</p></a></li>
<li><a href='#shadow_trail'><p>A trail of evenly spaced old frames</p></a></li>
<li><a href='#shadow_wake'><p>Show preceding frames with gradual falloff</p></a></li>
<li><a href='#split_animation'><p>Split an animation into chunks</p></a></li>
<li><a href='#sprite_file'><p>Wrap an image sprite for easy handling</p></a></li>
<li><a href='#transition_components'><p>Transition individual components through their own lifecycle</p></a></li>
<li><a href='#transition_events'><p>Transition individual events in and out</p></a></li>
<li><a href='#transition_filter'><p>Transition between different filters</p></a></li>
<li><a href='#transition_layers'><p>Build up a plot, layer by layer</p></a></li>
<li><a href='#transition_manual'><p>Create an animation by specifying the frame membership directly</p></a></li>
<li><a href='#transition_null'><p>Keep all data constant across the animation</p></a></li>
<li><a href='#transition_reveal'><p>Reveal data along a given dimension</p></a></li>
<li><a href='#transition_states'><p>Transition between several distinct stages of the data</p></a></li>
<li><a href='#transition_time'><p>Transition through distinct states in time</p></a></li>
<li><a href='#tween_before_stat'><p>Define if layers should be tweened before stats are calculated</p></a></li>
<li><a href='#video_file'><p>Wrap a video file for easy handling</p></a></li>
<li><a href='#view_follow'><p>Let the view follow the data in each frame</p></a></li>
<li><a href='#view_static'><p>Keep a fixed view that include all of the data</p></a></li>
<li><a href='#view_step'><p>Follow the data in steps</p></a></li>
<li><a href='#view_zoom'><p>Pan and zoom smoothly between different states</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Grammar of Animated Graphics</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.9</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas Lin Pedersen &lt;thomasp85@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The grammar of graphics as implemented in the 'ggplot2'
    package has been successful in providing a powerful API for creating
    static visualisation. In order to extend the API for animated graphics
    this package provides a completely new set of grammar, fully
    compatible with 'ggplot2' for specifying transitions and animations in
    a flexible and extensible way.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://gganimate.com">https://gganimate.com</a>, <a href="https://github.com/thomasp85/gganimate">https://github.com/thomasp85/gganimate</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/thomasp85/gganimate/issues">https://github.com/thomasp85/gganimate/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>ggplot2 (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, glue, grDevices, grid, lifecycle, progress, rlang,
scales, stringi, transformr (&ge; 0.1.5), tweenr (&ge; 2.0.3),
utils, vctrs</td>
</tr>
<tr>
<td>Suggests:</td>
<td>av, base64enc, covr, gifski (&ge; 1.4.3), htmltools, knitr,
magick, ragg, rmarkdown, sf, svglite, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Collate:</td>
<td>'aaa.R' 'anim_save.R' 'animate.R' 'animation_store.R'
'ease-aes.R' 'gganim.R' 'gganimate-ggproto.R'
'gganimate-package.r' 'ggplot2_reimpl.R' 'group_column.R'
'import-standalone-obj-type.R'
'import-standalone-types-check.R' 'layer_type.R'
'match_shapes.R' 'plot-build.R' 'post_process.R' 'renderers.R'
'scene.R' 'shadow-.R' 'shadow-mark.R' 'shadow-null.R'
'shadow-trail.R' 'shadow-wake.R' 'transformr.R' 'transition-.R'
'transition-components.R' 'transition-events.R'
'transition-filter.R' 'transition-manual.R'
'transition-layers.R' 'transition-null.R' 'transition-states.R'
'transition-time.R' 'transition_reveal.R' 'transmute-.R'
'transmute-enter.R' 'transmute-exit.R' 'transmuters.R'
'tween_before_stat.R' 'view-.R' 'view-follow.R' 'view-static.R'
'view-step.R' 'view-step-manual.R' 'view-zoom.R'
'view-zoom-manual.R' 'zzz.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-27 12:19:51 UTC; thomas</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas Lin Pedersen
    <a href="https://orcid.org/0000-0002-5147-4711"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  David Robinson [aut],
  Posit, PBC [cph, fnd]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-27 14:00:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='gganimate-package'>gganimate: A Grammar of Animated Graphics</h2><span id='topic+gganimate-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>The grammar of graphics as implemented in the 'ggplot2' package has been successful in providing a powerful API for creating static visualisation. In order to extend the API for animated graphics this package provides a completely new set of grammar, fully compatible with 'ggplot2' for specifying transitions and animations in a flexible and extensible way.
</p>


<h3>Good starting points</h3>

<p>The <code><a href="#topic+animate">animate()</a></code> function documentation describes how to specify how the
animation is rendered, whereas the documentation for the different transition
functions, e.g. <code><a href="#topic+transition_states">transition_states()</a></code>, describe how to declare the animation.
</p>
<p>Both <code><a href="#topic+ease_aes">ease_aes()</a></code> and the different <a href="#topic+enter_exit">enter and exit</a> functions
are good to understand in order to modify tweening of the animation.
</p>
<p>Apart from the included documentation there is also a few web ressources
worth mentioning:
</p>

<ul>
<li><p> The <a href="https://github.com/thomasp85/gganimate/wiki">gganimate wiki</a> includes
user supplied example walkthroughs
</p>
</li>
<li><p> The <a href="https://github.com/ropensci-archive/learngganimate">learngganimate</a>
project by rOpenSci Labs includes a long range of detailed explorations of
the different gganimate functions
</p>
</li></ul>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Thomas Lin Pedersen <a href="mailto:thomasp85@gmail.com">thomasp85@gmail.com</a> (<a href="https://orcid.org/0000-0002-5147-4711">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> David Robinson <a href="mailto:admiral.david@gmail.com">admiral.david@gmail.com</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Posit, PBC [copyright holder, funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://gganimate.com">https://gganimate.com</a>
</p>
</li>
<li> <p><a href="https://github.com/thomasp85/gganimate">https://github.com/thomasp85/gganimate</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/thomasp85/gganimate/issues">https://github.com/thomasp85/gganimate/issues</a>
</p>
</li></ul>


<hr>
<h2 id='anim_save'>Save an animation to a file</h2><span id='topic+anim_save'></span>

<h3>Description</h3>

<p>This function is analogous to <code><a href="ggplot2.html#topic+ggsave">ggplot2::ggsave()</a></code> in that it by default takes
the last created animation and saves it to the specific location. As
<code>gganimate</code> supports arbitrary renderers, and thus return types, the returned
object must implement a <code>save_animation</code> method to be able to be used with
<code>anim_save()</code>. This is provided natively for <code>gif_image</code> and <code>magick-image</code>
objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anim_save(filename, animation = last_animation(), path = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="anim_save_+3A_filename">filename</code></td>
<td>
<p>File name to create on disk.</p>
</td></tr>
<tr><td><code id="anim_save_+3A_animation">animation</code></td>
<td>
<p>The animation object to save, as returned by <code><a href="#topic+animate">animate()</a></code>.
Defaults to the last rendered animation using <code><a href="#topic+last_animation">last_animation()</a></code></p>
</td></tr>
<tr><td><code id="anim_save_+3A_path">path</code></td>
<td>
<p>Path of the directory to save plot to: <code>path</code> and <code>filename</code>
are combined to create the fully qualified file name. Defaults to the
working directory.</p>
</td></tr>
<tr><td><code id="anim_save_+3A_...">...</code></td>
<td>
<p>arguments passed on to <code><a href="#topic+animate">animate()</a></code> if <code>animation</code> is a <code>gganim</code>
object</p>
</td></tr>
</table>

<hr>
<h2 id='animate'>Render a gganim object</h2><span id='topic+animate'></span><span id='topic+animate.gganim'></span><span id='topic+print.gganim'></span><span id='topic+knit_print.gganim'></span>

<h3>Description</h3>

<p>This function takes a gganim object and renders it into an animation. The
nature of the animation is dependent on the renderer, but defaults to using
<code>gifski</code> to render it to a gif. The length and framerate is decided on render
time and can be any two combination of <code>nframes</code>, <code>fps</code>, and <code>duration</code>.
Rendering is happening in discrete time units. This means that any event in
the animation is rounded of to the nearest frame (e.g. entering will always
take a whole number of frames). This means that rounding artifacts are
possible when only rendering few frames. To avoid this you can increase the
<code>detail</code> argument. <code>detail</code> will get multiplied to <code>nframes</code> and the
resulting number of frames will get calculated, but only <code>nframes</code> evenly
spaced frames are rendered.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>animate(plot, ...)

## S3 method for class 'gganim'
animate(
  plot,
  nframes,
  fps,
  duration,
  detail,
  renderer,
  device,
  ref_frame,
  start_pause,
  end_pause,
  rewind,
  ...
)

## S3 method for class 'gganim'
print(x, ...)

knit_print.gganim(x, options, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="animate_+3A_plot">plot</code>, <code id="animate_+3A_x">x</code></td>
<td>
<p>A <code>gganim</code> object</p>
</td></tr>
<tr><td><code id="animate_+3A_...">...</code></td>
<td>
<p>Arguments passed on to the device.
For available device arguments, see <code><a href="grDevices.html#topic+png">grDevices::png()</a></code> or <code><a href="grDevices.html#topic+cairo">grDevices::svg()</a></code></p>
</td></tr>
<tr><td><code id="animate_+3A_nframes">nframes</code></td>
<td>
<p>The number of frames to render (default <code>100</code>)</p>
</td></tr>
<tr><td><code id="animate_+3A_fps">fps</code></td>
<td>
<p>The framerate of the animation in frames/sec (default <code>10</code>)</p>
</td></tr>
<tr><td><code id="animate_+3A_duration">duration</code></td>
<td>
<p>The length of the animation in seconds (unset by default)</p>
</td></tr>
<tr><td><code id="animate_+3A_detail">detail</code></td>
<td>
<p>The number of additional frames to calculate, per frame (default <code>1</code>)</p>
</td></tr>
<tr><td><code id="animate_+3A_renderer">renderer</code></td>
<td>
<p>The function used to render the generated frames into an
animation. Gets a vector of paths to images along with the framerate. (by
default it will use <code><a href="#topic+gifski_renderer">gifski_renderer()</a></code> if gifski is installed. If not it
will use <code><a href="#topic+magick_renderer">magick_renderer()</a></code> if magick is installed and then <code><a href="#topic+av_renderer">av_renderer()</a></code>
if av is installed. If all fails it will use the <code><a href="#topic+file_renderer">file_renderer()</a></code>)</p>
</td></tr>
<tr><td><code id="animate_+3A_device">device</code></td>
<td>
<p>The device to use for rendering the single frames. Possible
values are <code>'png'</code>, <code>'ragg_png'</code> (requires the ragg package), <code>'jpeg'</code>,
<code>'tiff'</code>, <code>'bmp'</code>, <code>'svg'</code>, and <code>'svglite'</code> (requires the svglite package).
(default <code>'png'</code>)</p>
</td></tr>
<tr><td><code id="animate_+3A_ref_frame">ref_frame</code></td>
<td>
<p>The frame to use for fixing dimensions of the plot, e.g. the
space available for axis text. Defaults to the first frame. Negative values
counts backwards (-1 is the last frame) (default <code>1</code>)</p>
</td></tr>
<tr><td><code id="animate_+3A_start_pause">start_pause</code>, <code id="animate_+3A_end_pause">end_pause</code></td>
<td>
<p>Number of times to repeat the first and last
frame in the animation (default is <code>0</code> for both)</p>
</td></tr>
<tr><td><code id="animate_+3A_rewind">rewind</code></td>
<td>
<p>Should the animation roll back in the end (default <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="animate_+3A_options">options</code></td>
<td>
<p>chunk options for the currently executing chunk</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>print.gganim</code>()  is an alias for <code>animate()</code> in the same way as
<code>print.ggplot()</code> is an alias for <code>plot.ggplot()</code>. This ensures that gganimate
behaves ggplot2-like and produces the animation when the object is printed.
The <code>plot()</code> method is different and produces a single frame for inspection
(by default frame 50 out of 100).
</p>
<p>Animations can be saved to disk using <code><a href="#topic+anim_save">anim_save()</a></code> in much the same way
<a href="ggplot2.html#topic+ggsave">ggsave()</a> works for static plots.
</p>


<h3>Value</h3>

<p>The return value of the <a href="#topic+renderers">renderer</a> function
</p>


<h3>Defaults</h3>

<p>It is possible to overwrite the defaults used by gganimate for the animation
by setting them with <code><a href="base.html#topic+options">options()</a></code> (prefixed with <code>gganimate.</code>. As an example,
if you would like to change the default nframes to 50 you would call
<code>options(gganimate.nframes = 50)</code>. In order to set default device arguments
(those you would normally pass through with <code>...</code>) you should use the
<code>gganimate.dev_args</code> options and provide a list of arguments e.g.
<code>options(gganimate.dev_args = list(width = 800, height = 600))</code> Defaults set
this way can still be overridden by giving arguments directly to <code>animate()</code>.
</p>
<p><strong>knitr Support:</strong> <br />
It is possible to specify the arguments to <code>animate()</code> in the chunk options
when using <code>gganimate</code> with <code>knitr</code>. Arguments specified in this way will
have precedence over defaults, but not over arguments specified directly in
<code>animate()</code>. The arguments should be provided as a list to the <code>gganimate</code>
chunk option, e.g. <code style="white-space: pre;">&#8288;{r, gganimate = list(nframes = 50, fps = 20)}&#8288;</code>. A few
build-in knitr options have relevance for animation and will be used unless
given specifically in the <code>gganimate</code> list option. The native knitr options
supported are:
</p>

<ul>
<li> <p><code>dev</code>: will set <code>device</code>
</p>
</li>
<li> <p><code>dev.args</code>: will set additional arguments to the device (<code>...</code>)
</p>
</li>
<li> <p><code>fig.width</code>, <code>fig.height</code>, <code>fig.asp</code>, <code>fig.dim</code>: will set <code>width</code> and
<code>height</code> of the device.
</p>
</li></ul>



<h3>Label variables</h3>

<p>All plots have a certain set of variables available for string literal
interpolation within plot labels. These are:
</p>

<ul>
<li> <p><strong>frame</strong> gives you the frame index for the current frame
</p>
</li>
<li> <p><strong>nframes</strong> gives you the total number of frames in the animation
</p>
</li>
<li> <p><strong>progress</strong> gives you the progress of the animation at the current frame
(equal to <code>frame/nframes</code>)
</p>
</li>
<li> <p><strong>data</strong> gives you the layer data for the current frame (as a list of data
frames)
</p>
</li></ul>

<p>Further, the transition and view in use can also make variables available.
Consult the documentation for these for more detail.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>anim &lt;- ggplot(mtcars, aes(mpg, disp)) +
  geom_point(aes(color = gear)) +
  transition_states(gear, transition_length = 2, state_length = 1) +
  enter_fade() +
  exit_fade()

## Not run: 
# Explicitly animate using default (same as just printing the animation)
animate(anim)

# Change duration and framerate
animate(anim, fps = 20, duration = 15)

# Make the animation pause at the end and then rewind
animate(anim, nframes = 100, end_pause = 10, rewind = TRUE)

# Use a different renderer
animate(anim, renderer = file_renderer('~/animation/'))[1:6]

# Specify device dimensions and/or resolution
animate(anim, height = 2, width = 3, units = "in", res = 150)

## End(Not run)

</code></pre>

<hr>
<h2 id='ease_aes'>Control easing of aesthetics</h2><span id='topic+ease_aes'></span>

<h3>Description</h3>

<p>Easing defines how a value change to another during tweening. Will it
progress linearly, or maybe start slowly and then build up momentum. In
<code>gganimate</code>, each aesthetic or computed variable can be tweened with
individual easing functions using the <code>ease_aes()</code> function. All easing
functions implemented in <code>tweenr</code> are available, see <a href="tweenr.html#topic+display_ease">tweenr::display_ease</a>
for an overview. Setting an ease for <code>x</code> and/or <code>y</code> will also affect the
other related positional aesthetics (e.g. <code>xmin</code>, <code>yend</code>, etc).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ease_aes(default = "linear", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ease_aes_+3A_default">default</code></td>
<td>
<p>The default easing function to use (defaults to <code>'linear'</code>)</p>
</td></tr>
<tr><td><code id="ease_aes_+3A_...">...</code></td>
<td>
<p>Override easing for specific aesthetics</p>
</td></tr>
</table>


<h3>Easing functions</h3>


<ul>
<li> <p><strong>quadratic</strong> Models a power-of-2 function
</p>
</li>
<li> <p><strong>cubic</strong> Models a power-of-3 function
</p>
</li>
<li> <p><strong>quartic</strong> Models a power-of-4 function
</p>
</li>
<li> <p><strong>quintic</strong> Models a power-of-5 function
</p>
</li>
<li> <p><strong>sine</strong> Models a sine function
</p>
</li>
<li> <p><strong>circular</strong> Models a pi/2 circle arc
</p>
</li>
<li> <p><strong>exponential</strong> Models an exponential function
</p>
</li>
<li> <p><strong>elastic</strong> Models an elastic release of energy
</p>
</li>
<li> <p><strong>back</strong> Models a pullback and relase
</p>
</li>
<li> <p><strong>bounce</strong> Models the bouncing of a ball
</p>
</li></ul>

<p><em>Modifiers</em> <br />
</p>

<ul>
<li> <p><strong>-in</strong> The easing function is applied as-is
</p>
</li>
<li> <p><strong>-out</strong> The easing function is applied in reverse
</p>
</li>
<li> <p><strong>-in-out</strong> The first half of the transition it is applied as-is, while in
the last half it is reversed
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>anim &lt;- ggplot(mtcars, aes(mpg, disp)) +
  transition_states(gear, transition_length = 2, state_length = 1) +
  enter_fade() +
  exit_fade()

## Not run: 
# Default uses linear easing
animate(anim)

## End(Not run)

# Change all to 'cubic-in-out' for a smoother appearance
anim1 &lt;- anim +
  ease_aes('cubic-in-out')
## Not run: 
animate(anim1)

## End(Not run)

# Only change easing of y variables
anim2 &lt;- anim +
  ease_aes(y = 'bounce-in')
## Not run: 
animate(anim2)

## End(Not run)

</code></pre>

<hr>
<h2 id='enter_exit'>Define how entering and exiting data behaves</h2><span id='topic+enter_exit'></span><span id='topic+enter'></span><span id='topic+exit'></span><span id='topic+enter_manual'></span><span id='topic+enter_appear'></span><span id='topic+enter_fade'></span><span id='topic+enter_grow'></span><span id='topic+enter_recolour'></span><span id='topic+enter_recolor'></span><span id='topic+enter_fly'></span><span id='topic+enter_drift'></span><span id='topic+enter_reset'></span><span id='topic+exit_manual'></span><span id='topic+exit_disappear'></span><span id='topic+exit_fade'></span><span id='topic+exit_shrink'></span><span id='topic+exit_recolour'></span><span id='topic+exit_recolor'></span><span id='topic+exit_fly'></span><span id='topic+exit_drift'></span><span id='topic+exit_reset'></span>

<h3>Description</h3>

<p>The purpose of <code style="white-space: pre;">&#8288;enter_*()&#8288;</code> and <code style="white-space: pre;">&#8288;exit_*()&#8288;</code> is to control what happens with
data that does not persist during a tween. In general the non-persistent data
is transformed to an <em>invisible</em> version that can be tweened to, e.g. by
setting the opacity to 0 or be moving the element off-screen. It is possible
to define your own transformations, or rely on some of the build in
<em>effects</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enter_manual(default = NULL, ..., name = "manual")

enter_appear(early = FALSE, ...)

enter_fade(..., alpha = 0)

enter_grow(..., size = 0)

enter_recolour(..., colour = "white", fill = colour)

enter_recolor(..., color = "white", fill = color)

enter_fly(..., x_loc = NA, y_loc = NA)

enter_drift(..., x_mod = 0, y_mod = 0)

enter_reset()

exit_manual(default = NULL, ..., name = "manual")

exit_disappear(early = FALSE, ...)

exit_fade(..., alpha = 0)

exit_shrink(..., size = 0)

exit_recolour(..., colour = "white", fill = colour)

exit_recolor(..., color = "white", fill = color)

exit_fly(..., x_loc = NA, y_loc = NA)

exit_drift(..., x_mod = 0, y_mod = 0)

exit_reset()
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="enter_exit_+3A_default">default</code></td>
<td>
<p>A default transformation to use</p>
</td></tr>
<tr><td><code id="enter_exit_+3A_...">...</code></td>
<td>
<p>Additional specific transformations either named by the geom
(e.g. <code>bar</code>, or by its position in the layer stack, e.g. <code>"2"</code>)</p>
</td></tr>
<tr><td><code id="enter_exit_+3A_name">name</code></td>
<td>
<p>A name for the manual modification (only used when printing the
object)</p>
</td></tr>
<tr><td><code id="enter_exit_+3A_early">early</code></td>
<td>
<p>Should the data appear in the beginning of the transition or in
the end</p>
</td></tr>
<tr><td><code id="enter_exit_+3A_alpha">alpha</code></td>
<td>
<p>The start/end transparency.</p>
</td></tr>
<tr><td><code id="enter_exit_+3A_size">size</code></td>
<td>
<p>The proportional start/end size. <code>0</code> means complete shrinking
while <code>1</code> means no shrinking</p>
</td></tr>
<tr><td><code id="enter_exit_+3A_colour">colour</code>, <code id="enter_exit_+3A_color">color</code>, <code id="enter_exit_+3A_fill">fill</code></td>
<td>
<p>The start/end colour and fill the elements should
(dis)appear into</p>
</td></tr>
<tr><td><code id="enter_exit_+3A_x_loc">x_loc</code>, <code id="enter_exit_+3A_y_loc">y_loc</code></td>
<td>
<p>Start and end positions of the graphic elements</p>
</td></tr>
<tr><td><code id="enter_exit_+3A_x_mod">x_mod</code>, <code id="enter_exit_+3A_y_mod">y_mod</code></td>
<td>
<p>Modification to add to the entering or exiting data</p>
</td></tr>
</table>


<h3>User-defined transformations</h3>

<p>All enter/exit functions allows the user to add additional transformation
functions targeting specific layers. If the functions are named, then the
name is understood to reference the class of geoms it applies to. If the
functions are unnamed or numbered they will apply to the layer with a
matching index in the stack. Named and indexed transformations cannot be
mixed.
</p>
<p>All modifications except <code>enter_manual()</code>/<code>exit_manual()</code> sets a range of
modifications already, but further can be added with the <code>...</code>. For the
manual versions a <code>default</code> transformation can be set which will apply to all
layers that does not match any of the other given transformations. Often a
single default transformation is enough and no specific transformations are
needed.
</p>
<p>Transformation can be given as any expression that can be converted with
<code><a href="rlang.html#topic+as_function">rlang::as_function()</a></code>. This means that <code>purrr</code> style lambda functions are
allowed in addition to anonymous functions etc. Transformation functions must
accept a data.frame and return a data.frame of the same dimensions. The
function will be called with the entering/exiting layer data, except for the
case of polygon- and path-like layers in which case the function recieves the
entering/exiting polygon/path data one by one. A special option is to set a
transformation as <code>NULL</code> instead of a function. In that case the entering and
exiting data will simply appear/disappear when it is no longer part of a
frame.
</p>


<h3>Modification composition</h3>

<p>Enter and exit modifications are composable so that multiple different ones
can be added to an animation and will be applied in turn. You can also
combine multiples and save them as a new enter or exit modification using
<code>c()</code>.
</p>
<p>Due to the composable nature of enter and exit modifications it is not
possible to overwrite a prior modification by adding a new. If it is needed
to start from scratch then the sentinels <code>enter_reset()</code> and <code>exit_reset()</code>
are provided which clears all prior modifications.
</p>


<h3>Modification types</h3>

<p>A range of modification types are provided by <code>gganimate</code> and using
<code>enter_manual()</code>/<code>exit_manual()</code> or modification composition it is possible
to create your own.
</p>
<p><strong>appear</strong>/<strong>disappear</strong> will simply make elements appear/disappear at either
the start or end of the transition. The default if nothing else is added.
</p>
<p><strong>fade</strong> will simply set the alpha value to zero making the elements fade
in/out during the transition.
</p>
<p><strong>grow</strong>/<strong>shrink</strong> will set the elements to zero size making them gradually
grow into / shrink out of existence. Zero size depends on the type of layer,
e.g. polygons/paths will have all their points set to the mean, while points
will have size/stroke set to zero.
</p>
<p><strong>recolour</strong>/<strong>recolor</strong> will change the colour and/or fill of the elements
making them gradually change from the defined colour and into their try
colour. Be aware that unless the colour and fill are set to the same as the
background colour of the plot this modification needs to be combined with
others to ensure that elements does not abruptly appear.
</p>
<p><strong>fly</strong> will set a specific x and y position where all elements will enter
from/ exit to, irrespectible of their real position.
</p>
<p><strong>drift</strong> will modify the real position of the entering and exiting elements
by a specified amount, e.g. setting <code>x_mod = -5</code> will let all elements enter
from/exit to the left with a terminal position 5 points to the left of the
real position.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Default is appear/disappear
anim &lt;- ggplot(mtcars, aes(factor(gear), mpg)) +
  geom_boxplot() +
  transition_states(gear, 2, 1)

# Fade-in, fly-out
anim1 &lt;- anim +
  enter_fade() +
  exit_fly(x_loc = 7, y_loc = 40)

# Enter and exit accumulates
anim2 &lt;- anim +
  enter_fade() + enter_grow() +
  exit_fly(x_loc = 7, y_loc = 40) + exit_recolour(fill = 'forestgreen')

</code></pre>

<hr>
<h2 id='frame_vars'>Access metadata about the frames in an animation</h2><span id='topic+frame_vars'></span>

<h3>Description</h3>

<p>This function extracts the metadata generated about each frame during
rendering. It corresponds to the information available to the labels for
string literal interpretation and is thus dependent on the transition and
view used for the animation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frame_vars(animation = last_animation())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="frame_vars_+3A_animation">animation</code></td>
<td>
<p>The animation to extract metadata from. Defaults to the last
rendered animation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with a row per frame in the animation and metadata as
columns
</p>

<hr>
<h2 id='gganimate'>Catch attempt to use the old API</h2><span id='topic+gganimate'></span><span id='topic+gg_animate'></span>

<h3>Description</h3>

<p>Catch attempt to use the old API
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gganimate(...)

gg_animate(...)
</code></pre>

<hr>
<h2 id='gganimate-ggproto'>Base ggproto classes for gganimate</h2><span id='topic+gganimate-ggproto'></span><span id='topic+Shadow'></span><span id='topic+ShadowMark'></span><span id='topic+ShadowNull'></span><span id='topic+ShadowTrail'></span><span id='topic+ShadowWake'></span><span id='topic+Transition'></span><span id='topic+TransitionComponents'></span><span id='topic+TransitionEvents'></span><span id='topic+TransitionFilter'></span><span id='topic+TransitionManual'></span><span id='topic+TransitionLayers'></span><span id='topic+TransitionNull'></span><span id='topic+TransitionStates'></span><span id='topic+TransitionTime'></span><span id='topic+TransitionReveal'></span><span id='topic+View'></span><span id='topic+ViewFollow'></span><span id='topic+ViewStep'></span><span id='topic+ViewStepManual'></span><span id='topic+ViewZoom'></span><span id='topic+ViewZoomManual'></span>

<h3>Description</h3>

<p>If you are creating a new transition, view, etc. in another package,
you'll need to extend from some of the ggproto classes defined in <code>gganimate</code>
</p>


<h3>See Also</h3>

<p>ggproto
</p>

<hr>
<h2 id='gif_file'>Wrap a gif file for easy handling</h2><span id='topic+gif_file'></span><span id='topic+gif_image'></span><span id='topic+print.gif_image'></span><span id='topic+knit_print.gif_image'></span><span id='topic+split.gif_image'></span>

<h3>Description</h3>

<p>This is a simple class for gif files that takes care printing the file
correctly in different environment (e.g. knitr, RStudio, etc.). If your
renderer produces a gif file you can wrap the final output in <code>gif_file</code> to
get all of these benefits for free.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gif_file(file)

## S3 method for class 'gif_image'
print(x, ...)

knit_print.gif_image(x, options, ...)

## S3 method for class 'gif_image'
split(x, f, drop = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gif_file_+3A_file">file</code></td>
<td>
<p>The gif file to be wrapped</p>
</td></tr>
<tr><td><code id="gif_file_+3A_x">x</code></td>
<td>
<p>A <code>gif_image</code> object</p>
</td></tr>
<tr><td><code id="gif_file_+3A_...">...</code></td>
<td>
<p>Arguments passed on</p>
</td></tr>
<tr><td><code id="gif_file_+3A_f">f</code></td>
<td>
<p>a ‘factor’ in the sense that <a href="base.html#topic+factor">as.factor(f)</a> defines
the grouping, or a list of such factors in which case their interaction is
used for the grouping.</p>
</td></tr>
<tr><td><code id="gif_file_+3A_drop">drop</code></td>
<td>
<p>logical indicating if levels that do not occur should be dropped
(if <code>f</code> is a <code>factor</code> or a list).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>gif_file</code> returns a <code>gif_image</code> object. <code>split</code> returns a list of
<code>magick-image</code> objects and requires magick to work.
</p>

<hr>
<h2 id='group_column'>Define what graphical type a layer is</h2><span id='topic+group_column'></span><span id='topic+layer_type'></span><span id='topic+match_shapes'></span>

<h3>Description</h3>

<p>Define what graphical type a layer is
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_column(x)

layer_type(x)

match_shapes(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="group_column_+3A_x">x</code></td>
<td>
<p>a Layer, Geom, or Stat</p>
</td></tr>
</table>

<hr>
<h2 id='last_animation'>Retrieve the last rendered animation</h2><span id='topic+last_animation'></span><span id='topic+set_last_animation'></span>

<h3>Description</h3>

<p>Retrieve the last rendered animation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>last_animation()

set_last_animation(value)
</code></pre>

<hr>
<h2 id='renderers'>Renderers provided by gganimate</h2><span id='topic+renderers'></span><span id='topic+gifski_renderer'></span><span id='topic+file_renderer'></span><span id='topic+av_renderer'></span><span id='topic+ffmpeg_renderer'></span><span id='topic+magick_renderer'></span><span id='topic+sprite_renderer'></span>

<h3>Description</h3>

<p>The purpose of the renderer function is to take a list of image files and
assemble them into an animation. <code>gganimate</code> provide a range of renderers
but it is also possible to provide your own, if the supplied ones are lacking
in any way. A renderer is given as argument to <code><a href="#topic+animate">animate()</a></code>/print() and
receives the paths to the individual frames once they have been created.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gifski_renderer(file = NULL, loop = TRUE, width = NULL, height = NULL)

file_renderer(dir = ".", prefix = "gganim_plot", overwrite = FALSE)

av_renderer(file = NULL, vfilter = "null", codec = NULL, audio = NULL)

ffmpeg_renderer(
  format = "auto",
  ffmpeg = NULL,
  options = list(pix_fmt = "yuv420p")
)

magick_renderer(loop = TRUE)

sprite_renderer()
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="renderers_+3A_file">file</code></td>
<td>
<p>The animation file</p>
</td></tr>
<tr><td><code id="renderers_+3A_loop">loop</code></td>
<td>
<p>Logical. Should the produced gif loop</p>
</td></tr>
<tr><td><code id="renderers_+3A_width">width</code>, <code id="renderers_+3A_height">height</code></td>
<td>
<p>Dimensions of the animation in pixels. If <code>NULL</code> will
take the dimensions from the frame, otherwise it will rescale it.</p>
</td></tr>
<tr><td><code id="renderers_+3A_dir">dir</code></td>
<td>
<p>The directory to copy the frames to</p>
</td></tr>
<tr><td><code id="renderers_+3A_prefix">prefix</code></td>
<td>
<p>The filename prefix to use for the image files</p>
</td></tr>
<tr><td><code id="renderers_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical. If TRUE, existing files will be overwritten.</p>
</td></tr>
<tr><td><code id="renderers_+3A_vfilter">vfilter</code></td>
<td>
<p>A string defining an ffmpeg filter graph. This is the same
parameter as the <code>-vf</code> argument in the <code>ffmpeg</code> command line utility.</p>
</td></tr>
<tr><td><code id="renderers_+3A_codec">codec</code></td>
<td>
<p>The name of the video codec. The default is <code>libx264</code> for most
formats, which usually the best choice. See the <code>av</code> documentation for more
information.</p>
</td></tr>
<tr><td><code id="renderers_+3A_audio">audio</code></td>
<td>
<p>An optional file with sounds to add to the video</p>
</td></tr>
<tr><td><code id="renderers_+3A_format">format</code></td>
<td>
<p>The video format to encode the animation into</p>
</td></tr>
<tr><td><code id="renderers_+3A_ffmpeg">ffmpeg</code></td>
<td>
<p>The location of the <code>ffmpeg</code> executable. If <code>NULL</code> it will be
assumed to be on the search path</p>
</td></tr>
<tr><td><code id="renderers_+3A_options">options</code></td>
<td>
<p>Either a character vector of command line options for ffmpeg
or a named list of option-value pairs that will be converted to command line
options automatically</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>gifski_renderer()</code> is used unless otherwise specified in
<code><a href="#topic+animate">animate()</a></code> or in <code>options('gganimate.renderer')</code>. This renderer requires
both the <code>gifski</code> and <code>png</code> packages to be installed.
</p>
<p>Other possible renderers are:
</p>

<ul>
<li> <p><code>magick_renderer()</code> which requires the <code>magick</code> package and produce a <code>gif</code>.
If <code>gifski</code> is not installed, the rendering will be much slower than using the
<code>gifski_renderer()</code> and can potentially result in system problems when many
frames need to be rendered (if <code>gifski</code> is installed <code>magick</code> will use it
under the hood)
</p>
</li>
<li> <p><code>av_renderer()</code> which requies the <code>av</code> package and uses ffmpeg to encode
the animation into a video file.
</p>
</li>
<li> <p><code>ffmpeg_renderer()</code> which requires that ffmpeg has been installed on your
computer. As with <code>av_renderer()</code> it will use ffmpeg to encode the animation
into a video
</p>
</li>
<li> <p><code>sprite_renderer()</code> which requires <code>magick</code> and will render the animation
into a spritesheet
</p>
</li>
<li> <p><code>file_renderer()</code> which has no dependencies and simply returns the
animation as a list of image files (one for each frame)
</p>
</li></ul>

<p>It is possible to create your own renderer function providing that it
matches the required signature (<code>frames</code> and <code>fps</code> argument). The return
value of your provided function will be the return value ultimately given by
<code><a href="#topic+animate">animate()</a></code>
</p>


<h3>Value</h3>

<p>The provided renderers are factory functions that returns a new function
that take <code>frames</code> and <code>fps</code> as arguments, the former being a character
vector with file paths to the images holding the separate frames, in the
order they should appear, and the latter being the framerate to use for the
animation in frames-per-second.
</p>
<p>The return type of the different returned renderers are:
</p>

<ul>
<li> <p><strong><code>gifski_renderer</code></strong>: Returns a <a href="#topic+gif_image">gif_image</a> object
</p>
</li>
<li> <p><strong><code>magick_renderer</code></strong>: Returns a <code>magick-image</code> object
</p>
</li>
<li> <p><strong><code>av_renderer</code></strong>: Returns a <a href="#topic+video_file">video_file</a> object
</p>
</li>
<li> <p><strong><code>ffmpeg_renderer</code></strong>: Returns a <a href="#topic+video_file">video_file</a> object
</p>
</li>
<li> <p><strong><code>file_renderer</code></strong>: Returns a vector of file paths
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>anim &lt;- ggplot(mtcars, aes(mpg, disp)) +
  transition_states(gear, transition_length = 2, state_length = 1) +
  enter_fade() +
  exit_fade()

## Not run: 
# Renderers are specified in the `animate()` function
animate(anim, renderer = sprite_renderer())

## End(Not run)

</code></pre>

<hr>
<h2 id='save_animation'>Infrastructure for animation saving</h2><span id='topic+save_animation'></span>

<h3>Description</h3>

<p>Any returned animation object that wish to support <code><a href="#topic+anim_save">anim_save()</a></code> need to
implement this method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save_animation(animation, file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="save_animation_+3A_animation">animation</code></td>
<td>
<p>The animation object to save</p>
</td></tr>
<tr><td><code id="save_animation_+3A_file">file</code></td>
<td>
<p>The file path to save it to</p>
</td></tr>
</table>

<hr>
<h2 id='shadow_mark'>Show original data as background marks</h2><span id='topic+shadow_mark'></span>

<h3>Description</h3>

<p>This shadow lets you show the raw data behind the current frame. Both past
and/or future raw data can be shown and styled as you want.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shadow_mark(past = TRUE, future = FALSE, ..., exclude_layer = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shadow_mark_+3A_past">past</code></td>
<td>
<p>Should raw data from earlier in the animation be shown</p>
</td></tr>
<tr><td><code id="shadow_mark_+3A_future">future</code></td>
<td>
<p>Should raw data from later in the animation be shown</p>
</td></tr>
<tr><td><code id="shadow_mark_+3A_...">...</code></td>
<td>
<p>changes to the shadow data, e.g. <code>alpha = alpha/2</code> or
<code>colour = 'grey'</code></p>
</td></tr>
<tr><td><code id="shadow_mark_+3A_exclude_layer">exclude_layer</code></td>
<td>
<p>Indexes of layers that should be excluded.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other shadows: 
<code><a href="#topic+shadow_null">shadow_null</a>()</code>,
<code><a href="#topic+shadow_trail">shadow_trail</a>()</code>,
<code><a href="#topic+shadow_wake">shadow_wake</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use any of the aesthetics to add a style to either the past or the future raw data.
# Adding a grouping variable in a transition call prior to calling `shadow_mark()` will
# allow transitioning through different states in time.

p1 &lt;- ggplot(airquality, aes(Day, Temp)) +
  geom_line(color = 'red', size = 1) +
  transition_time(Month) +
  shadow_mark(colour = 'black', size = 0.75)

# animate(p1)

# Add a future = TRUE argument to show data later in the animation.

p2 &lt;- ggplot(airquality, aes(Day, Temp)) +
  geom_line(color = 'red', size = 1) +
  transition_time(Month) +
  shadow_mark(color = 'black', size = 0.75, past = FALSE, future = TRUE)

# animate(p2)

</code></pre>

<hr>
<h2 id='shadow_null'>A non-existent shadow</h2><span id='topic+shadow_null'></span>

<h3>Description</h3>

<p>This is the default shadow that simply doesn't show anything other than the
data for the current frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shadow_null()
</code></pre>


<h3>See Also</h3>

<p>Other shadows: 
<code><a href="#topic+shadow_mark">shadow_mark</a>()</code>,
<code><a href="#topic+shadow_trail">shadow_trail</a>()</code>,
<code><a href="#topic+shadow_wake">shadow_wake</a>()</code>
</p>

<hr>
<h2 id='shadow_trail'>A trail of evenly spaced old frames</h2><span id='topic+shadow_trail'></span>

<h3>Description</h3>

<p>This shadow will trace the movement in your animation by keeping every <em>n</em>th
frame and will thus produce a breadcrumb-like trail. Note that the shadow
frames will not be equidistant in space but in time (that is, if a point
moves slowly the <em>crumbs</em> will be closer to each other). It is possible to
modify the look of the shadow by changing the different graphic parameters in
the data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shadow_trail(distance = 0.05, max_frames = Inf, ..., exclude_layer = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shadow_trail_+3A_distance">distance</code></td>
<td>
<p>The temporal distance between the frames to show, as a
fraction of the full animation length</p>
</td></tr>
<tr><td><code id="shadow_trail_+3A_max_frames">max_frames</code></td>
<td>
<p>The maximum number of shadow frames to show</p>
</td></tr>
<tr><td><code id="shadow_trail_+3A_...">...</code></td>
<td>
<p>changes to the shadow data, e.g. <code>alpha = alpha/2</code> or
<code>colour = 'grey'</code></p>
</td></tr>
<tr><td><code id="shadow_trail_+3A_exclude_layer">exclude_layer</code></td>
<td>
<p>Indexes of layers that should be excluded.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other shadows: 
<code><a href="#topic+shadow_mark">shadow_mark</a>()</code>,
<code><a href="#topic+shadow_null">shadow_null</a>()</code>,
<code><a href="#topic+shadow_wake">shadow_wake</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>anim &lt;- ggplot(airquality, aes(Day, Temp, colour = factor(Month))) +
  geom_point() +
  transition_time(Day)

# Change distance between points
anim1 &lt;- anim +
  shadow_trail(0.02)

# Style shadow differently
anim2 &lt;- anim +
  shadow_trail(alpha = 0.3, shape = 2)

# Restrict the shadow to 10 frames
anim3 &lt;- anim +
  shadow_trail(max_frames = 10)

</code></pre>

<hr>
<h2 id='shadow_wake'>Show preceding frames with gradual falloff</h2><span id='topic+shadow_wake'></span>

<h3>Description</h3>

<p>This shadow is meant to draw a small wake after data by showing the latest
frames up to the current. You can choose to gradually diminish the size
and/or opacity of the shadow. The length of the wake is not given in absolute
frames as that would make the animation susceptible to changes in the
framerate. Instead it is given as a proportion of the total length of the
animation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shadow_wake(
  wake_length,
  size = TRUE,
  alpha = TRUE,
  colour = NULL,
  fill = NULL,
  falloff = "cubic-in",
  wrap = TRUE,
  exclude_layer = NULL,
  exclude_phase = c("enter", "exit")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shadow_wake_+3A_wake_length">wake_length</code></td>
<td>
<p>A number between 0 and 1 giving the length of the wake,
in relation to the total number of frames.</p>
</td></tr>
<tr><td><code id="shadow_wake_+3A_size">size</code></td>
<td>
<p>Numeric indicating the size the wake should end on. If <code>NULL</code>
then size is not modified. Can also be a boolean with <code>TRUE</code> beeing equal <code>0</code>
and <code>FALSE</code> beeing equal to <code>NULL</code></p>
</td></tr>
<tr><td><code id="shadow_wake_+3A_alpha">alpha</code></td>
<td>
<p>as <code>size</code> but for alpha modification of the wake</p>
</td></tr>
<tr><td><code id="shadow_wake_+3A_colour">colour</code>, <code id="shadow_wake_+3A_fill">fill</code></td>
<td>
<p>colour or fill the wake should end on. If <code>NULL</code> they are
not modified.</p>
</td></tr>
<tr><td><code id="shadow_wake_+3A_falloff">falloff</code></td>
<td>
<p>An easing function that control how size and/or alpha should
change.</p>
</td></tr>
<tr><td><code id="shadow_wake_+3A_wrap">wrap</code></td>
<td>
<p>Should the shadow wrap around, so that the first frame will get
shadows from the end of the animation.</p>
</td></tr>
<tr><td><code id="shadow_wake_+3A_exclude_layer">exclude_layer</code></td>
<td>
<p>Indexes of layers that should be excluded.</p>
</td></tr>
<tr><td><code id="shadow_wake_+3A_exclude_phase">exclude_phase</code></td>
<td>
<p>Element phases that should not get a shadow. Possible
values are <code>'enter'</code>, <code>'exit'</code>, <code>'static'</code>, <code>'transition'</code>, and <code>'raw'</code>. If
<code>NULL</code> all phases will be included. Defaults to <code>'enter'</code> and <code>'exit'</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other shadows: 
<code><a href="#topic+shadow_mark">shadow_mark</a>()</code>,
<code><a href="#topic+shadow_null">shadow_null</a>()</code>,
<code><a href="#topic+shadow_trail">shadow_trail</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>anim &lt;- ggplot(iris, aes(Petal.Length, Sepal.Length)) +
  geom_point() +
  labs(title = "{closest_state}") +
  transition_states(Species, transition_length = 4, state_length = 1)

# `shadow_wake` can be combined with e.g. `transition_states` to show
# motion of geoms as they are in transition with respect to the selected state.
anim1 &lt;- anim +
  shadow_wake(wake_length = 0.05)

# Different qualities can be manipulated by setting a value for it that it
# should taper off to
anim2 &lt;- anim +
  shadow_wake(0.1, size = 10, alpha = FALSE, colour = 'grey92')

# Use `detail` in the `animate()` call to increase the number of calculated
# frames and thus make the wake smoother
## Not run: 
animate(anim2, detail = 5)

## End(Not run)

</code></pre>

<hr>
<h2 id='split_animation'>Split an animation into chunks</h2><span id='topic+split_animation'></span>

<h3>Description</h3>

<p>Sometimes it is of interest to split an animation out in smaller chunks so
they can be orchestrated, e.g. in a presentation. This function lets you
provide a 'factor' to split by in the same way as <code><a href="base.html#topic+split">base::split()</a></code> though this
one will be evaluated in the context of the animations <code><a href="#topic+frame_vars">frame_vars()</a></code> data,
so you can split directly on frame metadata.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_animation(animation = last_animation(), by)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="split_animation_+3A_animation">animation</code></td>
<td>
<p>The animation to extract metadata from. Defaults to the last
rendered animation</p>
</td></tr>
<tr><td><code id="split_animation_+3A_by">by</code></td>
<td>
<p>An unquoted expression to be evaluated in the context of the frame
metadata. The result must be of equal length to the number of frames in the
animation and define a grouping</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on the output type of the renderer used to produce the
animation. Often a list with elements referencing the chunks of the
animation. that can then be saved individually.
</p>

<hr>
<h2 id='sprite_file'>Wrap an image sprite for easy handling</h2><span id='topic+sprite_file'></span><span id='topic+print.sprite_image'></span><span id='topic+knit_print.sprite_image'></span>

<h3>Description</h3>

<p>This function is equivalent to <code><a href="#topic+gif_file">gif_file()</a></code> but works for animations encoded
as a sprite. A sprite is a single image file where each frame of the
animation is stacked next to each other. The animation then happens by
changing what slice of the image is shown. The implementation used allow
users to click on the animation in order to toggle pause/play.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sprite_file(file, fps, width, full_width, height)

## S3 method for class 'sprite_image'
print(x, width = NULL, ...)

knit_print.sprite_image(x, options, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sprite_file_+3A_file">file</code></td>
<td>
<p>A png file with frames placed horizontally</p>
</td></tr>
<tr><td><code id="sprite_file_+3A_fps">fps</code></td>
<td>
<p>The framerate for the sprite animation</p>
</td></tr>
<tr><td><code id="sprite_file_+3A_width">width</code>, <code id="sprite_file_+3A_height">height</code></td>
<td>
<p>The dimension of a single frame</p>
</td></tr>
<tr><td><code id="sprite_file_+3A_full_width">full_width</code></td>
<td>
<p>The width of the whole image</p>
</td></tr>
<tr><td><code id="sprite_file_+3A_x">x</code></td>
<td>
<p>A <code>sprite_image</code> object</p>
</td></tr>
<tr><td><code id="sprite_file_+3A_...">...</code></td>
<td>
<p>Arguments passed on</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>sprite_file</code> returns a <code>sprite_image</code> object which is a shallow wrapper
around the file path text string along with dimensions and fps used for
animating the sprite when printing.
</p>

<hr>
<h2 id='transition_components'>Transition individual components through their own lifecycle</h2><span id='topic+transition_components'></span>

<h3>Description</h3>

<p>This transition allows individual visual components to define their own
&quot;life-cycle&quot;. This means that the final animation will not have any common
&quot;state&quot; and &quot;transition&quot; phase as any component can be moving or static at
any point in time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transition_components(
  time,
  range = NULL,
  enter_length = NULL,
  exit_length = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transition_components_+3A_time">time</code></td>
<td>
<p>The unquoted name of the column holding the time for each state
of the components</p>
</td></tr>
<tr><td><code id="transition_components_+3A_range">range</code></td>
<td>
<p>The range the animation should span. Defaults to the range of
time plus enter and exit length</p>
</td></tr>
<tr><td><code id="transition_components_+3A_enter_length">enter_length</code>, <code id="transition_components_+3A_exit_length">exit_length</code></td>
<td>
<p>How long time should be spend on enter and
exit transitions. Defaults to 0</p>
</td></tr>
</table>


<h3>Label variables</h3>

<p><code>transition_components</code> makes the following variables available for string
literal interpretation, in addition to the general ones provided by
<code><a href="#topic+animate">animate()</a></code>:
</p>

<ul>
<li> <p><strong>frame_time</strong> gives the time that the current frame corresponds to
</p>
</li></ul>



<h3>Object permanence</h3>

<p><code>transition_components</code> uses the group aesthetic of each layer to identify
which rows in the input data correspond to the same graphic element and will
therefore define stages in time that the element will animate through. The
group aesthetic, if not set, will be calculated from the interaction of all
discrete aesthetics in the layer (excluding <code>label</code>), so it is often better
to set it explicitly when animating, to make sure your data is interpreted in
the right way. If the group aesthetic is not set, and no discrete aesthetics
exists then all rows will have the same group.
</p>


<h3>Computed Variables</h3>

<p>It is possible to use variables calculated by the statistic to define the
transition. Simply inclose the variable in <code>stat()</code> in the same way as when
using computed variables in aesthetics.
</p>


<h3>See Also</h3>

<p>Other transitions: 
<code><a href="#topic+transition_events">transition_events</a>()</code>,
<code><a href="#topic+transition_filter">transition_filter</a>()</code>,
<code><a href="#topic+transition_layers">transition_layers</a>()</code>,
<code><a href="#topic+transition_manual">transition_manual</a>()</code>,
<code><a href="#topic+transition_null">transition_null</a>()</code>,
<code><a href="#topic+transition_reveal">transition_reveal</a>()</code>,
<code><a href="#topic+transition_states">transition_states</a>()</code>,
<code><a href="#topic+transition_time">transition_time</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- data.frame(
  x = runif(10),
  y = runif(10),
  size = sample(1:3, 10, TRUE),
  time = c(1, 4, 6, 7, 9, 6, 7, 8, 9, 10),
  id = rep(1:2, each = 5)
)

anim &lt;- ggplot(data, aes(x, y, group = id, size = size)) +
  geom_point() +
  transition_components(time)

# By default the time range is set to the range of the time variable (plus
# any enter and exit length), but this can be overwritten
anim2 &lt;- ggplot(data, aes(x, y, group = id, size = size)) +
  geom_point() +
  transition_components(time, range = c(4, 8))

# If you are using any enter/exit functions you need to give them some time
anim3 &lt;- ggplot(data, aes(x, y, group = id, size = size)) +
  geom_point() +
  transition_components(time, enter_length = 2, exit_length = 2) +
  enter_grow() +
  exit_fade()

</code></pre>

<hr>
<h2 id='transition_events'>Transition individual events in and out</h2><span id='topic+transition_events'></span>

<h3>Description</h3>

<p>This transition treats each visual element as an event in time and allows you
to control the duration and enter/exit length individually for each event.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transition_events(
  start,
  end = NULL,
  range = NULL,
  enter_length = NULL,
  exit_length = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transition_events_+3A_start">start</code>, <code id="transition_events_+3A_end">end</code></td>
<td>
<p>The unquoted expression giving the start and end time of
each event. If <code>end</code>is <code>NULL</code> the event will be treated as having no duration.</p>
</td></tr>
<tr><td><code id="transition_events_+3A_range">range</code></td>
<td>
<p>The range the animation should span. Defaults to the range of
the events from they enter to they have exited.</p>
</td></tr>
<tr><td><code id="transition_events_+3A_enter_length">enter_length</code>, <code id="transition_events_+3A_exit_length">exit_length</code></td>
<td>
<p>The unquoted expression giving the length to
be used for enter and exit for each event.</p>
</td></tr>
</table>


<h3>Label variables</h3>

<p><code>transition_components</code> makes the following variables available for string
literal interpretation, in addition to the general ones provided by
<code><a href="#topic+animate">animate()</a></code>:
</p>

<ul>
<li> <p><strong>frame_time</strong> gives the time that the current frame corresponds to
</p>
</li></ul>



<h3>Object permanence</h3>

<p><code>transition_events</code> does not link rows across data to the same graphic
element, so elements will be defined uniquely by each row and its specific
start, end, enter and exit.
</p>


<h3>Computed Variables</h3>

<p>It is possible to use variables calculated by the statistic to define the
transition. Simply inclose the variable in <code>stat()</code> in the same way as when
using computed variables in aesthetics.
</p>


<h3>See Also</h3>

<p>Other transitions: 
<code><a href="#topic+transition_components">transition_components</a>()</code>,
<code><a href="#topic+transition_filter">transition_filter</a>()</code>,
<code><a href="#topic+transition_layers">transition_layers</a>()</code>,
<code><a href="#topic+transition_manual">transition_manual</a>()</code>,
<code><a href="#topic+transition_null">transition_null</a>()</code>,
<code><a href="#topic+transition_reveal">transition_reveal</a>()</code>,
<code><a href="#topic+transition_states">transition_states</a>()</code>,
<code><a href="#topic+transition_time">transition_time</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- data.frame(
  x = 1:10,
  y = runif(10),
  begin = runif(10, 1, 100),
  length = runif(10, 5, 20),
  enter = runif(10, 5, 10),
  exit = runif(10, 5, 10)
)

anim &lt;- ggplot(data, aes(x, y)) +
  geom_col() +
  transition_events(start = begin,
                    end = begin + length,
                    enter_length = enter,
                    exit_length = exit) +
 enter_grow() +
 exit_drift(x_mod = 11) +
 exit_fade()
</code></pre>

<hr>
<h2 id='transition_filter'>Transition between different filters</h2><span id='topic+transition_filter'></span>

<h3>Description</h3>

<p>This transition allows you to transition between a range of filtering
conditions. The conditions are expressed as logical statements and rows in
the data will be retained if the statement evaluates to <code>TRUE</code>. It is
possible to keep filtered data on display by setting <code>keep = TRUE</code> which will
let data be retained as the result of the exit function. Note that if data is
kept the enter function will have no effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transition_filter(
  transition_length = 1,
  filter_length = 1,
  ...,
  wrap = TRUE,
  keep = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transition_filter_+3A_transition_length">transition_length</code></td>
<td>
<p>The relative length of the transition. Will be
recycled to match the number of states in the data</p>
</td></tr>
<tr><td><code id="transition_filter_+3A_filter_length">filter_length</code></td>
<td>
<p>The relative length of the pause at the states. Will be
recycled to match the number of states in the data</p>
</td></tr>
<tr><td><code id="transition_filter_+3A_...">...</code></td>
<td>
<p>A number of expressions to be evaluated in the context of the layer
data, returning a logical vector. If the expressions are named, the name will
be available as a frame variable.</p>
</td></tr>
<tr><td><code id="transition_filter_+3A_wrap">wrap</code></td>
<td>
<p>Should the animation <em>wrap-around</em>? If <code>TRUE</code> the last filter will
be transitioned into the first.</p>
</td></tr>
<tr><td><code id="transition_filter_+3A_keep">keep</code></td>
<td>
<p>Should rows that evaluates to <code>FALSE</code> be kept in the data as it
looks after exit has been applied</p>
</td></tr>
</table>


<h3>Label variables</h3>

<p><code>transition_filter</code> makes the following variables available for string
literal interpretation, in addition to the general ones provided by
<code><a href="#topic+animate">animate()</a></code>:
</p>

<ul>
<li> <p><strong>transitioning</strong> is a boolean indicating whether the frame is part of the
transitioning phase
</p>
</li>
<li> <p><strong>previous_filter</strong> The name of the last filter the animation was at
</p>
</li>
<li> <p><strong>closest_filter</strong> The name of the filter closest to this frame
</p>
</li>
<li> <p><strong>next_filter</strong> The name of the next filter the animation will be part of
</p>
</li>
<li> <p><strong>previous_expression</strong> The expression of the last filter the animation was at
</p>
</li>
<li> <p><strong>closest_expression</strong> The expression of the filter closest to this frame
</p>
</li>
<li> <p><strong>next_expression</strong> The expression of the next filter the animation will be part of
</p>
</li></ul>



<h3>Object permanence</h3>

<p><code>transition_filter</code> does not link rows across data to the same graphic
element, so elements will be defined uniquely by each row. If <code>keep = TRUE</code>
the rows not matching the conditions of a filter is not removed from the plot
after the exit animation, and a possible subsequent enter will begin from
the state they were left in, rather than enter anew from the state defined by
the enter function.
</p>


<h3>Computed Variables</h3>

<p>It is possible to use variables calculated by the statistic to define the
transition. Simply inclose the variable in <code>stat()</code> in the same way as when
using computed variables in aesthetics.
</p>


<h3>See Also</h3>

<p>Other transitions: 
<code><a href="#topic+transition_components">transition_components</a>()</code>,
<code><a href="#topic+transition_events">transition_events</a>()</code>,
<code><a href="#topic+transition_layers">transition_layers</a>()</code>,
<code><a href="#topic+transition_manual">transition_manual</a>()</code>,
<code><a href="#topic+transition_null">transition_null</a>()</code>,
<code><a href="#topic+transition_reveal">transition_reveal</a>()</code>,
<code><a href="#topic+transition_states">transition_states</a>()</code>,
<code><a href="#topic+transition_time">transition_time</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>anim &lt;- ggplot(iris, aes(Petal.Width, Petal.Length, colour = Species)) +
  geom_point() +
  transition_filter(
    transition_length = 2,
    filter_length = 1,
    Setosa = Species == 'setosa',
    Long = Petal.Length &gt; 4,
    Wide = Petal.Width &gt; 2
  ) +
  ggtitle(
    'Filter: {closest_filter}',
    subtitle = '{closest_expression}'
  ) +
  enter_fade() +
  exit_fly(y_loc = 0)

# Setting `keep = TRUE` allows you to keep the culled data on display. Only
# exit functions will be used in that case (as elements enters from the
# result of the exit function)
anim2 &lt;- ggplot(iris, aes(Petal.Width, Petal.Length, colour = Species)) +
  geom_point() +
  transition_filter(
    transition_length = 2,
    filter_length = 1,
    Setosa = Species == 'setosa',
    Long = Petal.Length &gt; 4,
    Wide = Petal.Width &gt; 2,
    keep = TRUE
  ) +
  ggtitle(
    'Filter: {closest_filter}',
    subtitle = '{closest_expression}'
  ) +
  exit_recolour(colour = 'grey') +
  exit_shrink(size = 0.5)

</code></pre>

<hr>
<h2 id='transition_layers'>Build up a plot, layer by layer</h2><span id='topic+transition_layers'></span>

<h3>Description</h3>

<p>This transition gradually adds layers to the plot in the order they have been
defined. By default prior layers are kept for the remainder of the animation,
but they can also be set to be removed as the next layer enters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transition_layers(
  layer_length = 1,
  transition_length = 1,
  keep_layers = TRUE,
  from_blank = TRUE,
  layer_order = NULL,
  layer_names = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transition_layers_+3A_layer_length">layer_length</code></td>
<td>
<p>The proportional time to pause at each layer before a new
one enters</p>
</td></tr>
<tr><td><code id="transition_layers_+3A_transition_length">transition_length</code></td>
<td>
<p>The proportional time to use for the entrance of a
new layer</p>
</td></tr>
<tr><td><code id="transition_layers_+3A_keep_layers">keep_layers</code></td>
<td>
<p>Either an integer indicating for how many following layers
the layers should stay on screen or a logical. In the case of the later,
<code>TRUE</code> will mean keep the layer for the remainder of the animation
(equivalent to setting it to <code>Inf</code>) and <code>FALSE</code> will mean to transition the
layer out as the next layer enters.</p>
</td></tr>
<tr><td><code id="transition_layers_+3A_from_blank">from_blank</code></td>
<td>
<p>Should the first layer transition in or be present on the
onset of the animation</p>
</td></tr>
<tr><td><code id="transition_layers_+3A_layer_order">layer_order</code></td>
<td>
<p>An alternative order the layers should appear in (default
to using the stacking order). All other arguments that references the layers
index in some way refers to this order.</p>
</td></tr>
<tr><td><code id="transition_layers_+3A_layer_names">layer_names</code></td>
<td>
<p>A character vector of names for each layers, to be used
when interpreting label literals</p>
</td></tr>
</table>


<h3>Label variables</h3>

<p><code>transition_layers</code> makes the following variables available for string
literal interpretation, in addition to the general ones provided by
<code><a href="#topic+animate">animate()</a></code>:
</p>

<ul>
<li> <p><strong>transitioning</strong> is a boolean indicating whether the frame is part of the
transitioning phase
</p>
</li>
<li> <p><strong>previous_layer</strong> The name of the last layer the animation was showing
</p>
</li>
<li> <p><strong>closest_layer</strong> The name of the layer the animation is closest to showing
</p>
</li>
<li> <p><strong>next_layer</strong> The name of the next layer the animation will show
</p>
</li>
<li> <p><strong>nlayers</strong> The total number of layers
</p>
</li></ul>



<h3>Object permanence</h3>

<p><code>transition_layer</code> does not link rows across data to the same graphic
element, so elements will be defined uniquely by each row and the enter and
exit of the layer it belongs to.
</p>


<h3>See Also</h3>

<p>Other transitions: 
<code><a href="#topic+transition_components">transition_components</a>()</code>,
<code><a href="#topic+transition_events">transition_events</a>()</code>,
<code><a href="#topic+transition_filter">transition_filter</a>()</code>,
<code><a href="#topic+transition_manual">transition_manual</a>()</code>,
<code><a href="#topic+transition_null">transition_null</a>()</code>,
<code><a href="#topic+transition_reveal">transition_reveal</a>()</code>,
<code><a href="#topic+transition_states">transition_states</a>()</code>,
<code><a href="#topic+transition_time">transition_time</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Default is to use layer order and keep layers for duration of animation
anim &lt;- ggplot(mtcars, aes(mpg, disp)) +
  geom_point() +
  geom_smooth(colour = 'grey', se = FALSE) +
  geom_smooth(aes(colour = factor(gear))) +
  transition_layers(layer_length = 1, transition_length = 2) +
  enter_fade() + enter_grow()

# Start with the first layer already present
anim1 &lt;- ggplot(mtcars, aes(mpg, disp)) +
  geom_point() +
  geom_smooth(colour = 'grey', se = FALSE) +
  geom_smooth(aes(colour = factor(gear))) +
  transition_layers(layer_length = 1, transition_length = 2,
                    from_blank = FALSE) +
  enter_fade() + enter_grow()

# Change the order of the layers
anim2 &lt;- ggplot(mtcars, aes(mpg, disp)) +
  geom_point() +
  geom_smooth(colour = 'grey', se = FALSE) +
  geom_smooth(aes(colour = factor(gear))) +
  transition_layers(layer_length = 1, transition_length = 2,
                    from_blank = FALSE, layer_order = c(3, 1, 2)) +
  enter_fade() + enter_grow()

# Keep layer 1 for the whole animation, but remove the 2nd layer as the 3rd
# enters
anim3 &lt;- ggplot(mtcars, aes(mpg, disp)) +
  geom_point() +
  geom_smooth(colour = 'grey', se = FALSE) +
  geom_smooth(aes(colour = factor(gear))) +
  transition_layers(layer_length = 1, transition_length = 2,
                    from_blank = FALSE, keep_layers = c(Inf, 0, 0)) +
  enter_fade() + enter_grow() +
  exit_fade() + exit_shrink()

</code></pre>

<hr>
<h2 id='transition_manual'>Create an animation by specifying the frame membership directly</h2><span id='topic+transition_manual'></span>

<h3>Description</h3>

<p>This transition allows you to map a variable in your data to a specific frame
in the animation. No tweening of data will be made and the number of frames
in the animation will be decided by the number of levels in the frame
variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transition_manual(frames, ..., cumulative = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transition_manual_+3A_frames">frames</code></td>
<td>
<p>The unquoted name of the column holding the frame membership.</p>
</td></tr>
<tr><td><code id="transition_manual_+3A_...">...</code></td>
<td>
<p>Additional variables</p>
</td></tr>
<tr><td><code id="transition_manual_+3A_cumulative">cumulative</code></td>
<td>
<p>Keep data from previous frames as part of the current frame
data</p>
</td></tr>
</table>


<h3>Label variables</h3>

<p><code>transition_states</code> makes the following variables available for string
literal interpretation, in addition to the general ones provided by
<code><a href="#topic+animate">animate()</a></code>:
</p>

<ul>
<li> <p><strong>previous_frame</strong> The name of the last frame the animation was at
</p>
</li>
<li> <p><strong>current_frame</strong> The name of the current frame
</p>
</li>
<li> <p><strong>next_frame</strong> The name of the next frame in the animation
</p>
</li></ul>



<h3>Object permanence</h3>

<p><code>transition_manual</code> does not link rows across data to the same graphic
element. Every frame is a discrete state and no animation between the states
is done.
</p>


<h3>Computed Variables</h3>

<p>It is possible to use variables calculated by the statistic to define the
transition. Simply inclose the variable in <code>stat()</code> in the same way as when
using computed variables in aesthetics.
</p>


<h3>See Also</h3>

<p>Other transitions: 
<code><a href="#topic+transition_components">transition_components</a>()</code>,
<code><a href="#topic+transition_events">transition_events</a>()</code>,
<code><a href="#topic+transition_filter">transition_filter</a>()</code>,
<code><a href="#topic+transition_layers">transition_layers</a>()</code>,
<code><a href="#topic+transition_null">transition_null</a>()</code>,
<code><a href="#topic+transition_reveal">transition_reveal</a>()</code>,
<code><a href="#topic+transition_states">transition_states</a>()</code>,
<code><a href="#topic+transition_time">transition_time</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>anim &lt;- ggplot(mtcars, aes(factor(gear), mpg)) +
  geom_boxplot() +
  transition_manual(gear)

# Using `cumulative = TRUE` to keep data from older frames
anim2 &lt;- ggplot(mtcars, aes(factor(gear), mpg)) +
  geom_boxplot() +
  transition_manual(gear, cumulative = TRUE)

# Use `factor()` to set the order of the frames
anim3 &lt;- ggplot(mtcars, aes(factor(gear), mpg)) +
  geom_boxplot() +
  transition_manual(factor(gear, levels = c('4', '3', '5')))

</code></pre>

<hr>
<h2 id='transition_null'>Keep all data constant across the animation</h2><span id='topic+transition_null'></span>

<h3>Description</h3>

<p>Keep all data constant across the animation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transition_null()
</code></pre>


<h3>See Also</h3>

<p>Other transitions: 
<code><a href="#topic+transition_components">transition_components</a>()</code>,
<code><a href="#topic+transition_events">transition_events</a>()</code>,
<code><a href="#topic+transition_filter">transition_filter</a>()</code>,
<code><a href="#topic+transition_layers">transition_layers</a>()</code>,
<code><a href="#topic+transition_manual">transition_manual</a>()</code>,
<code><a href="#topic+transition_reveal">transition_reveal</a>()</code>,
<code><a href="#topic+transition_states">transition_states</a>()</code>,
<code><a href="#topic+transition_time">transition_time</a>()</code>
</p>

<hr>
<h2 id='transition_reveal'>Reveal data along a given dimension</h2><span id='topic+transition_reveal'></span>

<h3>Description</h3>

<p>This transition allows you to let data gradually appear, based on a given
time dimension. In contrast to e.g. <code><a href="#topic+transition_time">transition_time()</a></code> <code>transition_reveal()</code>
calculates intermediary values at exact positions instead of coercing raw
values into the closest frame. It further keeps old data for path and polygon
type layers so that they are gradually build up instead of being a set of
disconnected segments as will happen when using <code><a href="#topic+transition_time">transition_time()</a></code> and
<code><a href="#topic+shadow_mark">shadow_mark()</a></code> together.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transition_reveal(along, range = NULL, keep_last = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transition_reveal_+3A_along">along</code></td>
<td>
<p>An unquoted expression giving the dimension to tween along. For
a gradually revealing time series this should be set to the same as the <code>x</code>
aesthetic.</p>
</td></tr>
<tr><td><code id="transition_reveal_+3A_range">range</code></td>
<td>
<p>The time range to animate. If <code>NULL</code> it will be set to the range
of <code>along</code></p>
</td></tr>
<tr><td><code id="transition_reveal_+3A_keep_last">keep_last</code></td>
<td>
<p>For non-path/polygon layers should the last row be kept for
subsequent frames.</p>
</td></tr>
</table>


<h3>Label variables</h3>

<p><code>transition_reveal</code> makes the following variables available for string
literal interpretation, in addition to the general ones provided by
<code><a href="#topic+animate">animate()</a></code>:
</p>

<ul>
<li> <p><strong>frame_along</strong> gives the position on the along-dimension that the current
frame corresponds to
</p>
</li></ul>



<h3>Object permanence</h3>

<p><code>transition_reveal</code> uses the group aesthetic of each layer to identify
which rows in the input data correspond to the same graphic element and will
therefore define a whole to be revealed over the animation.
The group aesthetic, if not set, will be calculated from the interaction of all
discrete aesthetics in the layer (excluding <code>label</code>), so it is often better
to set it explicitly when animating, to make sure your data is interpreted in
the right way. If the group aesthetic is not set, and no discrete aesthetics
exists then all rows will have the same group.
</p>


<h3>Computed Variables</h3>

<p>It is possible to use variables calculated by the statistic to define the
transition. Simply inclose the variable in <code>stat()</code> in the same way as when
using computed variables in aesthetics.
</p>


<h3>See Also</h3>

<p>Other transitions: 
<code><a href="#topic+transition_components">transition_components</a>()</code>,
<code><a href="#topic+transition_events">transition_events</a>()</code>,
<code><a href="#topic+transition_filter">transition_filter</a>()</code>,
<code><a href="#topic+transition_layers">transition_layers</a>()</code>,
<code><a href="#topic+transition_manual">transition_manual</a>()</code>,
<code><a href="#topic+transition_null">transition_null</a>()</code>,
<code><a href="#topic+transition_states">transition_states</a>()</code>,
<code><a href="#topic+transition_time">transition_time</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>anim &lt;- ggplot(airquality, aes(Day, Temp, group = Month)) +
  geom_line() +
  transition_reveal(Day)

# Non-paths will only show the current position, not the history
anim1 &lt;- ggplot(airquality, aes(Day, Temp, group = Month)) +
  geom_line() +
  geom_point(colour = 'red', size = 3) +
  transition_reveal(Day)

# Points can be kept by giving them a unique group and set `keep = TRUE` (the
# default)
anim2 &lt;- ggplot(airquality, aes(Day, Temp, group = Month)) +
  geom_line() +
  geom_point(aes(group = seq_along(Day))) +
  geom_point(colour = 'red', size = 3) +
  transition_reveal(Day)

# Since ggplot2 3.4 geom_ribbon and geom_area has used stat_align
# This stat is incompatible with transition_reveal when applied before
# stats are calculated
anim3 &lt;- ggplot(airquality, aes(Day, Temp, group = Month)) +
  geom_area() +
  transition_reveal(Day)

# This can be fixed by either reverting to use stat_identity
anim4 &lt;- ggplot(airquality, aes(Day, Temp, group = Month)) +
  geom_area(stat = "identity") +
  transition_reveal(Day)

# Or by applying the transition after the stat
anim5 &lt;- ggplot(airquality, aes(Day, Temp, group = Month)) +
  geom_area() +
  transition_reveal(after_stat(x))

</code></pre>

<hr>
<h2 id='transition_states'>Transition between several distinct stages of the data</h2><span id='topic+transition_states'></span>

<h3>Description</h3>

<p>This transition splits your data into multiple states based on the levels in
a given column, much like <code><a href="ggplot2.html#topic+facet_wrap">ggplot2::facet_wrap()</a></code> splits up the data in
multiple panels. It then tweens between the defined states and pauses at each
state. Layers with data without the specified column will be kept constant
during the animation (again, mimicking <code>facet_wrap</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transition_states(states, transition_length = 1, state_length = 1, wrap = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transition_states_+3A_states">states</code></td>
<td>
<p>The unquoted name of the column holding the state levels in the
data.</p>
</td></tr>
<tr><td><code id="transition_states_+3A_transition_length">transition_length</code></td>
<td>
<p>The relative length of the transition. Will be
recycled to match the number of states in the data</p>
</td></tr>
<tr><td><code id="transition_states_+3A_state_length">state_length</code></td>
<td>
<p>The relative length of the pause at the states. Will be
recycled to match the number of states in the data</p>
</td></tr>
<tr><td><code id="transition_states_+3A_wrap">wrap</code></td>
<td>
<p>Should the animation <em>wrap-around</em>? If <code>TRUE</code> the last state will
be transitioned into the first.</p>
</td></tr>
</table>


<h3>Label variables</h3>

<p><code>transition_states</code> makes the following variables available for string
literal interpretation, in addition to the general ones provided by
<code><a href="#topic+animate">animate()</a></code>:
</p>

<ul>
<li> <p><strong>transitioning</strong> is a boolean indicating whether the frame is part of the
transitioning phase
</p>
</li>
<li> <p><strong>previous_state</strong> The name of the last state the animation was at
</p>
</li>
<li> <p><strong>closest_state</strong> The name of the state closest to this frame
</p>
</li>
<li> <p><strong>next_state</strong> The name of the next state the animation will be part of
</p>
</li></ul>



<h3>Object permanence</h3>

<p><code>transition_states</code> uses the group aesthetic of each layer to identify
which rows in the input data correspond to the same graphic element and will
therefore define which elements will turn into each other between states.
The group aesthetic, if not set, will be calculated from the interaction of all
discrete aesthetics in the layer (excluding <code>label</code>), so it is often better
to set it explicitly when animating, to make sure your data is interpreted in
the right way. If the group aesthetic is not set, and no discrete aesthetics
exists then all rows will have the same group. If the group aesthetic is not
unique in each state, then rows will be matched first by group and then by
index. Unmatched rows will appear/disappear, potentially using an enter or
exit function.
</p>


<h3>Computed Variables</h3>

<p>It is possible to use variables calculated by the statistic to define the
transition. Simply inclose the variable in <code>stat()</code> in the same way as when
using computed variables in aesthetics.
</p>


<h3>See Also</h3>

<p>Other transitions: 
<code><a href="#topic+transition_components">transition_components</a>()</code>,
<code><a href="#topic+transition_events">transition_events</a>()</code>,
<code><a href="#topic+transition_filter">transition_filter</a>()</code>,
<code><a href="#topic+transition_layers">transition_layers</a>()</code>,
<code><a href="#topic+transition_manual">transition_manual</a>()</code>,
<code><a href="#topic+transition_null">transition_null</a>()</code>,
<code><a href="#topic+transition_reveal">transition_reveal</a>()</code>,
<code><a href="#topic+transition_time">transition_time</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>anim &lt;- ggplot(iris, aes(Sepal.Width, Petal.Width)) +
  geom_point() +
  labs(title = "{closest_state}") +
  transition_states(Species, transition_length = 3, state_length = 1)

# Use a unique group to avoid matching graphic elements
iris$group &lt;- seq_len(nrow(iris))
anim1 &lt;- ggplot(iris, aes(Sepal.Width, Petal.Width, group = group)) +
  geom_point() +
  labs(title = "{closest_state}") +
  transition_states(Species, transition_length = 3, state_length = 1) +
  enter_fade() +
  exit_fade()

# Set `wrap = FALSE` to avoid transitioning the last state to the first
anim2 &lt;- ggplot(iris, aes(Sepal.Width, Petal.Width)) +
  geom_point() +
  labs(title = "{closest_state}") +
  transition_states(Species, transition_length = 3, state_length = 1,
                    wrap = FALSE)

</code></pre>

<hr>
<h2 id='transition_time'>Transition through distinct states in time</h2><span id='topic+transition_time'></span>

<h3>Description</h3>

<p>This is a variant of <code><a href="#topic+transition_states">transition_states()</a></code> that is intended for data where
the states are representing specific point in time. The transition length
between the states will be set to correspond to the actual time difference
between them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transition_time(time, range = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transition_time_+3A_time">time</code></td>
<td>
<p>An unquoted expression giving the time, and thus state
membership, of each observation.</p>
</td></tr>
<tr><td><code id="transition_time_+3A_range">range</code></td>
<td>
<p>The time range to animate. If <code>NULL</code> it will be set to the range
of <code>time</code></p>
</td></tr>
</table>


<h3>Label variables</h3>

<p><code>transition_time</code> makes the following variables available for string
literal interpretation, in addition to the general ones provided by
<code><a href="#topic+animate">animate()</a></code>:
</p>

<ul>
<li> <p><strong>frame_time</strong> gives the time that the current frame corresponds to
</p>
</li></ul>



<h3>Object permanence</h3>

<p><code>transition_time</code> uses the group aesthetic of each layer to identify
which rows in the input data correspond to the same graphic element and will
therefore define which elements will turn into each other between time points.
The group aesthetic, if not set, will be calculated from the interaction of all
discrete aesthetics in the layer (excluding <code>label</code>), so it is often better
to set it explicitly when animating, to make sure your data is interpreted in
the right way. If the group aesthetic is not set, and no discrete aesthetics
exists then all rows will have the same group. If the group aesthetic is not
unique in each state, then rows will be matched first by group and then by
index. Unmatched rows will appear/disappear, potentially using an enter or
exit function.
</p>


<h3>Computed Variables</h3>

<p>It is possible to use variables calculated by the statistic to define the
transition. Simply inclose the variable in <code>stat()</code> in the same way as when
using computed variables in aesthetics.
</p>


<h3>See Also</h3>

<p>Other transitions: 
<code><a href="#topic+transition_components">transition_components</a>()</code>,
<code><a href="#topic+transition_events">transition_events</a>()</code>,
<code><a href="#topic+transition_filter">transition_filter</a>()</code>,
<code><a href="#topic+transition_layers">transition_layers</a>()</code>,
<code><a href="#topic+transition_manual">transition_manual</a>()</code>,
<code><a href="#topic+transition_null">transition_null</a>()</code>,
<code><a href="#topic+transition_reveal">transition_reveal</a>()</code>,
<code><a href="#topic+transition_states">transition_states</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>anim &lt;- ggplot(airquality, aes(Day, Temp)) +
  geom_point(aes(colour = factor(Month))) +
  transition_time(Day)

# Removing a time point will prolong the tweening between neighbouring time
# points so the time dimension stays linear
airquality_missing &lt;- airquality[airquality$Day &lt;= 10 | airquality$Day &gt;= 20, ]
anim1 &lt;- ggplot(airquality_missing, aes(Day, Temp)) +
  geom_point(aes(colour = factor(Month))) +
  transition_time(Day)

# Range can be constrained if needed
anim2 &lt;- ggplot(airquality, aes(Day, Temp)) +
  geom_point(aes(colour = factor(Month))) +
  transition_time(Day, range = c(10L, 20L))

# The group aesthetic is used to connect elements
# No grouping
anim3 &lt;- ggplot(airquality, aes(Day, Temp)) +
  geom_line() +
  transition_time(Month)

# Group by month
anim4 &lt;- ggplot(airquality, aes(Day, Temp)) +
  geom_line(aes(group = Month)) +
  transition_time(Month) +
  enter_fade() +
  exit_fade()
</code></pre>

<hr>
<h2 id='tween_before_stat'>Define if layers should be tweened before stats are calculated</h2><span id='topic+tween_before_stat'></span>

<h3>Description</h3>

<p>Define if layers should be tweened before stats are calculated
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tween_before_stat(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tween_before_stat_+3A_x">x</code></td>
<td>
<p>a Layer, Geom, or Stat</p>
</td></tr>
</table>

<hr>
<h2 id='video_file'>Wrap a video file for easy handling</h2><span id='topic+video_file'></span><span id='topic+print.video_file'></span><span id='topic+knit_print.video_file'></span>

<h3>Description</h3>

<p>This function is equivalent to <code><a href="#topic+gif_file">gif_file()</a></code> but works for arbitrary video
file formats. There are some caveats involved though, most notably it doesn't
currently supports splitting so you can't easily use this output together
with <code><a href="#topic+split_animation">split_animation()</a></code>. Graceful printing is contingent on the file format.
Only <code>mp4</code>, <code>webm</code>, and <code>ogg</code> is supported by the HTML format and can thus be
shown in the RStudio viewer and inside HTML documents created with knitr.
Other formats will be opened in their default OS-specific viewer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>video_file(file)

## S3 method for class 'video_file'
print(x, width = NULL, ...)

knit_print.video_file(x, options, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="video_file_+3A_file">file</code></td>
<td>
<p>A video file</p>
</td></tr>
<tr><td><code id="video_file_+3A_x">x</code></td>
<td>
<p>A <code>video_file</code> object</p>
</td></tr>
<tr><td><code id="video_file_+3A_width">width</code></td>
<td>
<p>The width the output should be scaled to</p>
</td></tr>
<tr><td><code id="video_file_+3A_...">...</code></td>
<td>
<p>Arguments passed on</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>video_file</code> returns a <code>video_file</code> object which is a shallow wrapper
around the file path text string.
</p>

<hr>
<h2 id='view_follow'>Let the view follow the data in each frame</h2><span id='topic+view_follow'></span>

<h3>Description</h3>

<p>This view will set the panels to include the data present in the frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>view_follow(
  fixed_x = FALSE,
  fixed_y = FALSE,
  exclude_layer = NULL,
  aspect_ratio = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="view_follow_+3A_fixed_x">fixed_x</code>, <code id="view_follow_+3A_fixed_y">fixed_y</code></td>
<td>
<p>Either a logical indicating if the dimension should
not be modified by the view, or a numeric vector giving the lower and upper
bounds of the dimension. For the latter, an <code>NA</code> value will be substituted
for whatever is calculated by the view (e.g. <code>fixed_x = c(0, NA)</code>) will fix
the minimum x value to 0 and let the view calculate the upper bound.</p>
</td></tr>
<tr><td><code id="view_follow_+3A_exclude_layer">exclude_layer</code></td>
<td>
<p>Integer vector of layer indices that should be ignored
when calculating the view</p>
</td></tr>
<tr><td><code id="view_follow_+3A_aspect_ratio">aspect_ratio</code></td>
<td>
<p>If the coord is fixed, ensure that the view matches the
given aspect ratio. Will override anything given in <code>fixed_x</code>/<code>fixed_y</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other views: 
<code><a href="#topic+view_static">view_static</a>()</code>,
<code><a href="#topic+view_step">view_step</a>()</code>,
<code><a href="#topic+view_zoom">view_zoom</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>anim &lt;- ggplot(iris, aes(Sepal.Length, Sepal.Width)) +
  geom_point() +
  labs(title = "{closest_state}") +
  transition_states(Species, transition_length = 4, state_length = 1) +
  view_follow()

# Fixing a dimension can be done in general
anim1 &lt;- ggplot(iris, aes(Sepal.Length, Sepal.Width)) +
  geom_point() +
  labs(title = "{closest_state}") +
  transition_states(Species, transition_length = 4, state_length = 1) +
  view_follow(fixed_x = TRUE)

# ...or just for one side of the range
anim1 &lt;- ggplot(iris, aes(Sepal.Length, Sepal.Width)) +
  geom_point() +
  labs(title = "{closest_state}") +
  transition_states(Species, transition_length = 4, state_length = 1) +
  view_follow(fixed_x = c(4, NA), fixed_y = c(2, NA))

</code></pre>

<hr>
<h2 id='view_static'>Keep a fixed view that include all of the data</h2><span id='topic+view_static'></span>

<h3>Description</h3>

<p>This view keeps positional scales fixed across all frames
</p>


<h3>Usage</h3>

<pre><code class='language-R'>view_static()
</code></pre>


<h3>See Also</h3>

<p>Other views: 
<code><a href="#topic+view_follow">view_follow</a>()</code>,
<code><a href="#topic+view_step">view_step</a>()</code>,
<code><a href="#topic+view_zoom">view_zoom</a>()</code>
</p>

<hr>
<h2 id='view_step'>Follow the data in steps</h2><span id='topic+view_step'></span><span id='topic+view_step_manual'></span>

<h3>Description</h3>

<p>This view is a bit like <code><a href="#topic+view_follow">view_follow()</a></code> but will not match the data in each
frame. Instead it will switch between being static and zoom to the range of
the data. It is a great pairing with <code><a href="#topic+transition_states">transition_states()</a></code> as it can move the
view while the data is static and then be static while the data moves. The
standard version will look at the data present in the calculated frames and
set the ranges based on that, while the <code style="white-space: pre;">&#8288;_manual&#8288;</code> version will allow you to
define your own ranges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>view_step(
  pause_length = 1,
  step_length = 1,
  nsteps = NULL,
  look_ahead = pause_length,
  delay = 0,
  include = TRUE,
  ease = "cubic-in-out",
  wrap = TRUE,
  pause_first = FALSE,
  fixed_x = FALSE,
  fixed_y = FALSE,
  exclude_layer = NULL,
  aspect_ratio = 1
)

view_step_manual(
  pause_length = 1,
  step_length = 1,
  xmin,
  xmax,
  ymin,
  ymax,
  delay = 0,
  ease = "cubic-in-out",
  wrap = TRUE,
  pause_first = FALSE,
  fixed_x = FALSE,
  fixed_y = FALSE,
  exclude_layer = NULL,
  aspect_ratio = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="view_step_+3A_pause_length">pause_length</code></td>
<td>
<p>The relative length the view will be kept static. Will
be recycled to match the number of steps</p>
</td></tr>
<tr><td><code id="view_step_+3A_step_length">step_length</code></td>
<td>
<p>The relative length the view will use to transition to the
new position. Will be recycled to match the number of steps</p>
</td></tr>
<tr><td><code id="view_step_+3A_nsteps">nsteps</code></td>
<td>
<p>The number of steps. If <code>NULL</code> it will be set to the max length
of <code>pause_length</code> or <code>step_length</code></p>
</td></tr>
<tr><td><code id="view_step_+3A_look_ahead">look_ahead</code></td>
<td>
<p>A relative length to look ahead in the animation to get the
new zoom area. Allow the view to zoom to where the data will be</p>
</td></tr>
<tr><td><code id="view_step_+3A_delay">delay</code></td>
<td>
<p>A relative length to switch the view back and forth relative to
the actual frames. E.g. if delay is calculated to 5 frames, frame 6 will get
the view intended for frame 1.</p>
</td></tr>
<tr><td><code id="view_step_+3A_include">include</code></td>
<td>
<p>Should the steps include both the start and end frame range</p>
</td></tr>
<tr><td><code id="view_step_+3A_ease">ease</code></td>
<td>
<p>The easing function used for the step</p>
</td></tr>
<tr><td><code id="view_step_+3A_wrap">wrap</code></td>
<td>
<p>As in <code><a href="#topic+transition_states">transition_states()</a></code>. Should the view wrap around and zoom
back to the first state.</p>
</td></tr>
<tr><td><code id="view_step_+3A_pause_first">pause_first</code></td>
<td>
<p>Should the view start with a pause. The default is to
start with a step so that it is aligned to the static period in
<code><a href="#topic+transition_states">transition_states()</a></code></p>
</td></tr>
<tr><td><code id="view_step_+3A_fixed_x">fixed_x</code>, <code id="view_step_+3A_fixed_y">fixed_y</code></td>
<td>
<p>Either a logical indicating if the dimension should
not be modified by the view, or a numeric vector giving the lower and upper
bounds of the dimension. For the latter, an <code>NA</code> value will be substituted
for whatever is calculated by the view (e.g. <code>fixed_x = c(0, NA)</code>) will fix
the minimum x value to 0 and let the view calculate the upper bound.</p>
</td></tr>
<tr><td><code id="view_step_+3A_exclude_layer">exclude_layer</code></td>
<td>
<p>Integer vector of layer indices that should be ignored
when calculating the view</p>
</td></tr>
<tr><td><code id="view_step_+3A_aspect_ratio">aspect_ratio</code></td>
<td>
<p>If the coord is fixed, ensure that the view matches the
given aspect ratio. Will override anything given in <code>fixed_x</code>/<code>fixed_y</code></p>
</td></tr>
<tr><td><code id="view_step_+3A_xmin">xmin</code>, <code id="view_step_+3A_xmax">xmax</code>, <code id="view_step_+3A_ymin">ymin</code>, <code id="view_step_+3A_ymax">ymax</code></td>
<td>
<p>Vectors of even length defining the boundaries of
the different views to go through</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other views: 
<code><a href="#topic+view_follow">view_follow</a>()</code>,
<code><a href="#topic+view_static">view_static</a>()</code>,
<code><a href="#topic+view_zoom">view_zoom</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>anim &lt;- ggplot(iris, aes(Petal.Length, Petal.Width)) +
  geom_point() +
  transition_states(Species, transition_length = 2, state_length = 1) +
  view_step(pause_length = 2, step_length = 1, nsteps = 3)

# Default is to include the data from the two states you're stepping between
# but this can be turned off
anim &lt;- ggplot(iris, aes(Petal.Length, Petal.Width)) +
  geom_point() +
  transition_states(Species, transition_length = 2, state_length = 1) +
  view_step(pause_length = 2, step_length = 1, nsteps = 3, include = FALSE)

# Default is to work off-beat of transition_states so that view changes while
# data is static. Setting pause_first=TRUE changes this
anim &lt;- ggplot(iris, aes(Petal.Length, Petal.Width)) +
  geom_point() +
  transition_states(Species, transition_length = 2, state_length = 1) +
  view_step(pause_length = 1, step_length = 2, nsteps = 3, pause_first = TRUE)

# If the transition doesn't wrap, then the view shouldn't either
anim &lt;- ggplot(iris, aes(Petal.Length, Petal.Width)) +
  geom_point() +
  transition_states(Species, transition_length = 2, state_length = 1, wrap = FALSE) +
  view_step(pause_length = 2, step_length = 1, nsteps = 3, wrap = FALSE)

</code></pre>

<hr>
<h2 id='view_zoom'>Pan and zoom smoothly between different states</h2><span id='topic+view_zoom'></span><span id='topic+view_zoom_manual'></span>

<h3>Description</h3>

<p>This view is in many ways equivalent to <code><a href="#topic+view_step">view_step()</a></code> and
<code><a href="#topic+view_step_manual">view_step_manual()</a></code> but instead of simply tweening the bounding box of each
view it implement the smooth zoom and pan technique developed by Reach &amp;
North (2018). It gradually zooms out and then in during the pan to allow a
smooth transition of the view. As with <code><a href="#topic+view_step">view_step()</a></code> the standard version
will look at the data present in the calculated frames and set the ranges
based on that, while the <code style="white-space: pre;">&#8288;_manual&#8288;</code> version will allow you to define your own
ranges to zoom between.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>view_zoom(
  pause_length = 1,
  step_length = 1,
  nsteps = NULL,
  look_ahead = 0,
  delay = 0,
  include = FALSE,
  pan_zoom = 0,
  ease = "sine-in-out",
  wrap = TRUE,
  pause_first = TRUE,
  fixed_x = FALSE,
  fixed_y = FALSE,
  exclude_layer = NULL,
  aspect_ratio = 1
)

view_zoom_manual(
  pause_length = 1,
  step_length = 1,
  xmin,
  xmax,
  ymin,
  ymax,
  delay = 0,
  pan_zoom = 0,
  ease = "sine-in-out",
  wrap = TRUE,
  pause_first = TRUE,
  fixed_x = FALSE,
  fixed_y = FALSE,
  exclude_layer = NULL,
  aspect_ratio = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="view_zoom_+3A_pause_length">pause_length</code></td>
<td>
<p>The relative length the view will be kept static. Will
be recycled to match the number of steps</p>
</td></tr>
<tr><td><code id="view_zoom_+3A_step_length">step_length</code></td>
<td>
<p>The relative length the view will use to transition to the
new position. Will be recycled to match the number of steps</p>
</td></tr>
<tr><td><code id="view_zoom_+3A_nsteps">nsteps</code></td>
<td>
<p>The number of steps. If <code>NULL</code> it will be set to the max length
of <code>pause_length</code> or <code>step_length</code></p>
</td></tr>
<tr><td><code id="view_zoom_+3A_look_ahead">look_ahead</code></td>
<td>
<p>A relative length to look ahead in the animation to get the
new zoom area. Allow the view to zoom to where the data will be</p>
</td></tr>
<tr><td><code id="view_zoom_+3A_delay">delay</code></td>
<td>
<p>A relative length to switch the view back and forth relative to
the actual frames. E.g. if delay is calculated to 5 frames, frame 6 will get
the view intended for frame 1.</p>
</td></tr>
<tr><td><code id="view_zoom_+3A_include">include</code></td>
<td>
<p>Should the steps include both the start and end frame range</p>
</td></tr>
<tr><td><code id="view_zoom_+3A_pan_zoom">pan_zoom</code></td>
<td>
<p>The tradeoff between pan- and zoom-induced movement. Negative
values will value zoom over pan and positive values will value pan over zoom</p>
</td></tr>
<tr><td><code id="view_zoom_+3A_ease">ease</code></td>
<td>
<p>The easing function used for the step</p>
</td></tr>
<tr><td><code id="view_zoom_+3A_wrap">wrap</code></td>
<td>
<p>As in <code><a href="#topic+transition_states">transition_states()</a></code>. Should the view wrap around and zoom
back to the first state.</p>
</td></tr>
<tr><td><code id="view_zoom_+3A_pause_first">pause_first</code></td>
<td>
<p>Should the view start with a pause. The default is to
start with a step so that it is aligned to the static period in
<code><a href="#topic+transition_states">transition_states()</a></code></p>
</td></tr>
<tr><td><code id="view_zoom_+3A_fixed_x">fixed_x</code>, <code id="view_zoom_+3A_fixed_y">fixed_y</code></td>
<td>
<p>Either a logical indicating if the dimension should
not be modified by the view, or a numeric vector giving the lower and upper
bounds of the dimension. For the latter, an <code>NA</code> value will be substituted
for whatever is calculated by the view (e.g. <code>fixed_x = c(0, NA)</code>) will fix
the minimum x value to 0 and let the view calculate the upper bound.</p>
</td></tr>
<tr><td><code id="view_zoom_+3A_exclude_layer">exclude_layer</code></td>
<td>
<p>Integer vector of layer indices that should be ignored
when calculating the view</p>
</td></tr>
<tr><td><code id="view_zoom_+3A_aspect_ratio">aspect_ratio</code></td>
<td>
<p>If the coord is fixed, ensure that the view matches the
given aspect ratio. Will override anything given in <code>fixed_x</code>/<code>fixed_y</code></p>
</td></tr>
<tr><td><code id="view_zoom_+3A_xmin">xmin</code>, <code id="view_zoom_+3A_xmax">xmax</code>, <code id="view_zoom_+3A_ymin">ymin</code>, <code id="view_zoom_+3A_ymax">ymax</code></td>
<td>
<p>Vectors of even length defining the boundaries of
the different views to go through</p>
</td></tr>
</table>


<h3>References</h3>

<p>Reach, A., North, C. (2018) <em>Smooth, Efficient, and Interruptible Zooming and Panning</em>. IEEE Transactions on Visualization and Computer Graphics DOI:10.1109/TVCG.2018.2800013
</p>


<h3>See Also</h3>

<p>Other views: 
<code><a href="#topic+view_follow">view_follow</a>()</code>,
<code><a href="#topic+view_static">view_static</a>()</code>,
<code><a href="#topic+view_step">view_step</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>anim &lt;- ggplot(iris, aes(Petal.Length, Petal.Width, colour = Species)) +
  geom_point() +
  transition_states(Species, transition_length = 2, state_length = 1) +
  shadow_mark(past = TRUE, future = TRUE, colour = 'grey') +
  view_zoom(pause_length = 1, step_length = 2, nsteps = 3)

# Use pan_zoom to change the relationship between pan- and zoom movement
# Mainly zooming
anim1 &lt;- ggplot(iris, aes(Petal.Length, Petal.Width, colour = Species)) +
  geom_point() +
  transition_states(Species, transition_length = 2, state_length = 1) +
  shadow_mark(past = TRUE, future = TRUE, colour = 'grey') +
  view_zoom(pause_length = 1, step_length = 2, nsteps = 3, pan_zoom = -3)

# Mainly panning
anim2 &lt;- ggplot(iris, aes(Petal.Length, Petal.Width, colour = Species)) +
  geom_point() +
  transition_states(Species, transition_length = 2, state_length = 1) +
  shadow_mark(past = TRUE, future = TRUE, colour = 'grey') +
  view_zoom(pause_length = 1, step_length = 2, nsteps = 3, pan_zoom = -3)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
