<!DOCTYPE html><html lang="en"><head><title>Help for package sfcurve</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sfcurve}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#sfcurve-package'><p>sfcurve: 2x2, 3x3 and nxn Space-Filling Curves</p></a></li>
<li><a href='#+5B.sfc_nxn'><p>Subunit in the curve</p></a></li>
<li><a href='#+5B.sfc_sequence'><p>Utility functions</p></a></li>
<li><a href='#all_traverse_paths'><p>All traverse paths of a sequence</p></a></li>
<li><a href='#BASE_I'><p>Base patterns</p></a></li>
<li><a href='#draw_multiple_curves'><p>Draw multiple curves</p></a></li>
<li><a href='#draw_rules_2x2'><p>Draw the expansion rules</p></a></li>
<li><a href='#H0'><p>Seed sequences of the H-curve</p></a></li>
<li><a href='#hilbert_3d'><p>Three dimensional Hilbert curve</p></a></li>
<li><a href='#hilbert_curve'><p>Various curves in their standard forms</p></a></li>
<li><a href='#level1_unit_orientation+2Csfc_3x3_peano-method'><p>Level-1 unit in the Peano curve and Meander curve</p></a></li>
<li><a href='#plot_segments'><p>Plot segments</p></a></li>
<li><a href='#sfc_2x2'><p>Create space-filling curves</p></a></li>
<li><a href='#sfc_3x3_combined'><p>General 3x3 space-filling curves</p></a></li>
<li><a href='#sfc_4x4_meander'><p>4x4 space-filling curves in meander type</p></a></li>
<li><a href='#sfc_apply+2Csfc_nxn-method'><p>Apply to every unit in the sfc_nxn curve</p></a></li>
<li><a href='#sfc_base'><p>Constructor of the sfc_base class</p></a></li>
<li><a href='#sfc_expand_by_rules+2Csfc_rules+2Csfc_nxn-method'><p>Expand a sequence</p></a></li>
<li><a href='#sfc_expand+2Csfc_2x2-method'><p>Expand the curve to the next level</p></a></li>
<li><a href='#sfc_generator'><p>Generate a nxn curve based on expansion rules</p></a></li>
<li><a href='#sfc_grob+2Csfc_base-method'><p>The graphics object</p></a></li>
<li><a href='#sfc_h'><p>H-curve</p></a></li>
<li><a href='#sfc_is_compatible+2Csfc_sequence+2Csfc_sequence-method'><p>Whether two sfc_sequence objects are compatible</p></a></li>
<li><a href='#sfc_level+2Csfc_nxn-method'><p>The level of the curve</p></a></li>
<li><a href='#sfc_mode+2Csfc_nxn-method'><p>The mode of the curve</p></a></li>
<li><a href='#sfc_previous_point+2Csfc_base-method'><p>The previous and the next point</p></a></li>
<li><a href='#sfc_reduce+2Csfc_nxn-method'><p>Reduce a curve</p></a></li>
<li><a href='#sfc_rotate+2Csfc_sequence-method'><p>Transformations of a sequence</p></a></li>
<li><a href='#sfc_rules'><p>Constructor of the sfc_rules class</p></a></li>
<li><a href='#SFC_RULES_2x2'><p>Rules</p></a></li>
<li><a href='#sfc_segments+2Csfc_nxn-method'><p>Coordinates of the points on the curve</p></a></li>
<li><a href='#sfc_sequence'><p>Constructor of the sfc_sequence class</p></a></li>
<li><a href='#sfc_shape+2Csfc_2x2-method'><p>Shape of the curve</p></a></li>
<li><a href='#sfc_universe+2Csfc_rules-method'><p>The universe base pattern set</p></a></li>
<li><a href='#sfc_validate+2Csfc_sequence-method'><p>Validate the sequence</p></a></li>
<li><a href='#show+2Csfc_base-method'><p>Print the object</p></a></li>
<li><a href='#unit_orientation'><p>Flip units</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>2x2, 3x3 and Nxn Space-Filling Curves</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-09-10</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>grid, Rcpp, methods, colorRamp2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr, rgl, testthat, ComplexHeatmap, igraph,
digest</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of all possible forms of 2x2 and 3x3 space-filling curves, 
    i.e., the generalized forms of the Hilbert curve <a href="https://en.wikipedia.org/wiki/Hilbert_curve">https://en.wikipedia.org/wiki/Hilbert_curve</a>, 
    the Peano curve <a href="https://en.wikipedia.org/wiki/Peano_curve">https://en.wikipedia.org/wiki/Peano_curve</a> and the Peano curve in the 
    meander type (Figure 5 in <a href="https://eudml.org/doc/141086">https://eudml.org/doc/141086</a>). It can generates nxn curves expanded from
    any specific level-1 units. It also implements the H-curve and the three-dimensional Hilbert curve.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jokergoo/sfcurve">https://github.com/jokergoo/sfcurve</a>,
<a href="https://jokergoo.github.io/sfcurve/">https://jokergoo.github.io/sfcurve/</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-10 18:00:15 UTC; guz</td>
</tr>
<tr>
<td>Author:</td>
<td>Zuguang Gu <a href="https://orcid.org/0000-0002-7395-8709"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Zuguang Gu &lt;z.gu@dkfz.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-13 18:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='sfcurve-package'>sfcurve: 2x2, 3x3 and nxn Space-Filling Curves</h2><span id='topic+sfcurve'></span><span id='topic+sfcurve-package'></span>

<h3>Description</h3>

<p>Implementation of all possible forms of 2x2 and 3x3 space-filling curves, i.e., the generalized forms of the Hilbert curve <a href="https://en.wikipedia.org/wiki/Hilbert_curve">https://en.wikipedia.org/wiki/Hilbert_curve</a>, the Peano curve <a href="https://en.wikipedia.org/wiki/Peano_curve">https://en.wikipedia.org/wiki/Peano_curve</a> and the Peano curve in the meander type (Figure 5 in <a href="https://eudml.org/doc/141086">https://eudml.org/doc/141086</a>). It can generates nxn curves expanded from any specific level-1 units. It also implements the H-curve and the three-dimensional Hilbert curve.
</p>


<h3>Details</h3>

<p>Please go to the package's website: <a href="https://jokergoo.github.io/sfcurve/">https://jokergoo.github.io/sfcurve/</a> for more details.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Zuguang Gu <a href="mailto:z.gu@dkfz.de">z.gu@dkfz.de</a> (<a href="https://orcid.org/0000-0002-7395-8709">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/jokergoo/sfcurve">https://github.com/jokergoo/sfcurve</a>
</p>
</li>
<li> <p><a href="https://jokergoo.github.io/sfcurve/">https://jokergoo.github.io/sfcurve/</a>
</p>
</li></ul>


<hr>
<h2 id='+5B.sfc_nxn'>Subunit in the curve</h2><span id='topic++5B.sfc_nxn'></span><span id='topic+sfc_index+2Csfc_nxn-method'></span><span id='topic+sfc_index'></span><span id='topic+test_sfc_index'></span>

<h3>Description</h3>

<p>Subunit in the curve
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sfc_nxn'
x[i, j, ..., drop = TRUE]

## S4 method for signature 'sfc_nxn'
sfc_index(p, index = "")

test_sfc_index(p, index)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B5B.sfc_nxn_+3A_x">x</code></td>
<td>
<p>An <code>sfc_nxn</code> object.</p>
</td></tr>
<tr><td><code id="+2B5B.sfc_nxn_+3A_i">i</code>, <code id="+2B5B.sfc_nxn_+3A_index">index</code></td>
<td>
<p>A string of digits representing the path on the hierarchy of the curve. The left side
corresponds to the top level and the right side corresponds to the bottom level on the curve. For the
2x2 curve, the digits can only be 1-4, and for the Peano and Meander curves, the digites can be 1-9.
The hierarchical index should be specified in a format of <code>i1:i2:i3:...</code>
where <code>:</code> can be replaced by any non-number character. For 2x2 and 3x3 curves, <code>:</code> can be omitted and the
hierarchical index can be specified as <code>i1i2i3...</code>. See the <strong>Examples</strong> section.</p>
</td></tr>
<tr><td><code id="+2B5B.sfc_nxn_+3A_j">j</code></td>
<td>
<p>A value of <code>TRUE</code> or <code>FALSE</code> that controls whether to keep the <code>sfc_nxn</code> class or degenerate to the <code>sfc_sequence</code> class.</p>
</td></tr>
<tr><td><code id="+2B5B.sfc_nxn_+3A_...">...</code></td>
<td>
<p>Ignore.</p>
</td></tr>
<tr><td><code id="+2B5B.sfc_nxn_+3A_drop">drop</code></td>
<td>
<p>A value of <code>TRUE</code> or <code>FALSE</code> that controls whether to keep the <code>sfc_nxn</code> class or degenerate to the <code>sfc_sequence</code> class.</p>
</td></tr>
<tr><td><code id="+2B5B.sfc_nxn_+3A_p">p</code></td>
<td>
<p>An <code>sfc_nxn</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sfc_index()</code> only works on square curves (i.e. a curve with a single base letter as seed.)
</p>
<p><code>test_sfc_index()</code> is a helper function for demonstrating <code>sfc_index()</code>.
</p>


<h3>Value</h3>

<p><code>sfc_index()</code> returns an integer vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p = sfc_2x2("I", "11111")
p["3:2:1"]
# for 2x2 and 3x3 curves, ":" can be omitted
p["321"]
p["3:2:1", TRUE] # or p["3:2:1", drop = FALSE]
# only for testing
p = sfc_2x2("I", "11111")
om = par(no.readonly = TRUE)
par(mfrow = c(2, 2))
test_sfc_index(p, "3")
test_sfc_index(p, "3:2")
test_sfc_index(p, "3:2:1")
test_sfc_index(p, "3:2:1:1")
par(om)

p = sfc_3x3_meander("I", "11111")
om = par(no.readonly = TRUE)
par(mfrow = c(2, 2))
test_sfc_index(p, "7")
test_sfc_index(p, "7:5")
test_sfc_index(p, "7:5:9")
test_sfc_index(p, "7:5:9:2")
par(om)
</code></pre>

<hr>
<h2 id='+5B.sfc_sequence'>Utility functions</h2><span id='topic++5B.sfc_sequence'></span><span id='topic++5B+3C-.sfc_sequence'></span><span id='topic+length.sfc_sequence'></span><span id='topic+c.sfc_sequence'></span>

<h3>Description</h3>

<p>Utility functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sfc_sequence'
x[i]

## S3 replacement method for class 'sfc_sequence'
x[i] &lt;- value

## S3 method for class 'sfc_sequence'
length(x)

## S3 method for class 'sfc_sequence'
c(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B5B.sfc_sequence_+3A_x">x</code></td>
<td>
<p>An <code>sfc_sequence</code> object.</p>
</td></tr>
<tr><td><code id="+2B5B.sfc_sequence_+3A_i">i</code></td>
<td>
<p>Numeric index.</p>
</td></tr>
<tr><td><code id="+2B5B.sfc_sequence_+3A_value">value</code></td>
<td>
<p>An <code>sfc_sequence</code> object.</p>
</td></tr>
<tr><td><code id="+2B5B.sfc_sequence_+3A_...">...</code></td>
<td>
<p>A list of <code>sfc_sequence</code> objects or other arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For efficiency, <code>c.sfc_sequence()</code> does not check whether the input <code>sfc_sequence</code> objects are compatible.
</p>


<h3>Value</h3>

<p><code>length.sfc_sequence()</code> returns an integer scalar.
</p>
<p><code>c.sfc_sequence()</code> returns an <code>sfc_sequence</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p = sfc_sequence("ABCDEFGH")
p
p[1:4]
p[1:4] = p[8:5]
p
length(p)
c(p, p)
</code></pre>

<hr>
<h2 id='all_traverse_paths'>All traverse paths of a sequence</h2><span id='topic+all_traverse_paths'></span><span id='topic+get_one_traverse_path'></span><span id='topic+plot_traverse_paths'></span>

<h3>Description</h3>

<p>All traverse paths of a sequence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_traverse_paths(rules, p)

get_one_traverse_path(rules, p)

plot_traverse_paths(rules, p, type = c("all", "11|22", "12|21"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="all_traverse_paths_+3A_rules">rules</code></td>
<td>
<p>An <code>sfc_rules</code> object.</p>
</td></tr>
<tr><td><code id="all_traverse_paths_+3A_p">p</code></td>
<td>
<p>An <code>sfc_sequence</code> sequence. <code>p</code> and <code>rules</code> should have the same universe base set.
Please provide <code>p</code> as a small sequence because the total number of all traverse paths might be very huge.</p>
</td></tr>
<tr><td><code id="all_traverse_paths_+3A_type">type</code></td>
<td>
<p>If the value is <code>"11|22"</code>, it highlights the paths only via 1-1/2-2 corners. If the value is <code>"12|21"</code>, it highlights the paths
only via 1-2/2-1 corners.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given an input sequence with rotations, <code>all_traverse_paths()</code> lists all combinations of expansion
codes from the first letter to the last letter in <code>p</code> (i.e. all possible traverse paths).
</p>
<p><code>get_one_traverse_path()</code> returns one random traverse path.
</p>


<h3>Value</h3>

<p><code>all_traverse_paths()</code> returns a list of integer vectors.
</p>
<p><code>get_one_traverse_path()</code> returns an integer vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># expansion rules for the general 3x3 curves
p = SFC_RULES_3x3_COMBINED@rules$I[[3]]
get_one_traverse_path(SFC_RULES_3x3_COMBINED, p)
get_one_traverse_path(SFC_RULES_3x3_COMBINED, p)
get_one_traverse_path(SFC_RULES_3x3_COMBINED, p)
get_one_traverse_path(SFC_RULES_3x3_COMBINED, p)
# 
p = SFC_RULES_3x3_COMBINED@rules$I[[3]]
plot_traverse_paths(SFC_RULES_3x3_COMBINED, p)
plot_traverse_paths(SFC_RULES_3x3_COMBINED, p, type = "11|22")
plot_traverse_paths(SFC_RULES_3x3_COMBINED, p, type = "12|21")

# 2x2 curve
p = sfc_2x2("I", 11)
plot_traverse_paths(SFC_RULES_2x2, p)

# Peano curve
p = sfc_3x3_peano("I", 1)
plot_traverse_paths(SFC_RULES_3x3_PEANO, p)

# Meander curve
p = sfc_3x3_meander("I", 1)
plot_traverse_paths(SFC_RULES_3x3_MEANDER, p)
</code></pre>

<hr>
<h2 id='BASE_I'>Base patterns</h2><span id='topic+BASE_I'></span><span id='topic+BASE_J'></span><span id='topic+BASE_R'></span><span id='topic+BASE_L'></span><span id='topic+BASE_U'></span><span id='topic+BASE_B'></span><span id='topic+BASE_D'></span><span id='topic+BASE_P'></span><span id='topic+BASE_Q'></span><span id='topic+BASE_C'></span><span id='topic+BASE_LIST'></span>

<h3>Description</h3>

<p>A list of pre-defined base patterns. See the <strong>Examples</strong> section.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BASE_I

BASE_J

BASE_R

BASE_L

BASE_U

BASE_B

BASE_D

BASE_P

BASE_Q

BASE_C

BASE_LIST
</code></pre>


<h3>Format</h3>

<p>An object of class <code>sfc_base</code> of length 1.
</p>
<p>An object of class <code>sfc_base</code> of length 1.
</p>
<p>An object of class <code>sfc_base</code> of length 1.
</p>
<p>An object of class <code>sfc_base</code> of length 1.
</p>
<p>An object of class <code>sfc_base</code> of length 1.
</p>
<p>An object of class <code>sfc_base</code> of length 1.
</p>
<p>An object of class <code>sfc_base</code> of length 1.
</p>
<p>An object of class <code>sfc_base</code> of length 1.
</p>
<p>An object of class <code>sfc_base</code> of length 1.
</p>
<p>An object of class <code>sfc_base</code> of length 1.
</p>
<p>An object of class <code>list</code> of length 10.
</p>


<h3>Details</h3>

<p><code>BASE_I</code> and <code>BASE_J</code> are identical. They are only used to distinguish the two
&quot;going forward&quot; patterns for the level-1 units with 11/22 corner values, i.e. bottom-left to top-right, and bottom-right
to top-left.
</p>


<h3>Value</h3>

<p><code>sfc_base</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>BASE_I
BASE_J
BASE_R
BASE_L
BASE_U
BASE_B
BASE_D
BASE_P
BASE_Q
BASE_C
draw_multiple_curves(
    BASE_I, BASE_J, BASE_R, BASE_L, BASE_U,
    BASE_B, BASE_D, BASE_P, BASE_Q, BASE_C,
    nrow = 2
)
</code></pre>

<hr>
<h2 id='draw_multiple_curves'>Draw multiple curves</h2><span id='topic+draw_multiple_curves'></span>

<h3>Description</h3>

<p>Draw multiple curves
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_multiple_curves(
  ...,
  list = NULL,
  nrow = NULL,
  ncol = NULL,
  extend = TRUE,
  title = FALSE,
  closed = FALSE,
  padding = unit(0, "pt"),
  lwd = 4,
  col = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="draw_multiple_curves_+3A_...">...</code></td>
<td>
<p>A list of <code>sfc_sequence</code> objects or objects in its child classes, a list of <code><a href="grid.html#topic+grid.grob">grid::grob</a></code> objects
or a list of two-column coordinate matrices, i.e., all the forms that can represent curves in this package.</p>
</td></tr>
<tr><td><code id="draw_multiple_curves_+3A_list">list</code></td>
<td>
<p>The list of curve object can also be directly specified as a &quot;list&quot; object.</p>
</td></tr>
<tr><td><code id="draw_multiple_curves_+3A_nrow">nrow</code></td>
<td>
<p>Number of rows in the layout.</p>
</td></tr>
<tr><td><code id="draw_multiple_curves_+3A_ncol">ncol</code></td>
<td>
<p>Number of columns in the layout.</p>
</td></tr>
<tr><td><code id="draw_multiple_curves_+3A_extend">extend</code></td>
<td>
<p>Whether to draw the entry and exit segments? It is only used when input is a list of <code>sfc_sequence</code> objects.</p>
</td></tr>
<tr><td><code id="draw_multiple_curves_+3A_title">title</code></td>
<td>
<p>Whether to add titles on each panel? The title is constructed in the form of <code>initial_seed|expansion_codes</code>, e.g. <code>I|111</code>.
The value can be a vector of user-defined strings.</p>
</td></tr>
<tr><td><code id="draw_multiple_curves_+3A_closed">closed</code></td>
<td>
<p>Whether the curves are closed? The value should be a logical vector. If it is <code>TRUE</code>, the last point
is connected to the first point in the curve to form a closed curve. Length of <code>closed</code> can be 1 or the number of curves.</p>
</td></tr>
<tr><td><code id="draw_multiple_curves_+3A_padding">padding</code></td>
<td>
<p>Space around each curve. The value should be a <code><a href="grid.html#topic+unit">grid::unit</a></code> object with length 1.</p>
</td></tr>
<tr><td><code id="draw_multiple_curves_+3A_lwd">lwd</code></td>
<td>
<p>Line width with length 1.</p>
</td></tr>
<tr><td><code id="draw_multiple_curves_+3A_col">col</code></td>
<td>
<p>Color for the segments with length 1. If the value is <code>NULL</code>, it uses the &quot;Spectral&quot; color palettes from the <strong>RColorBrewer</strong> package.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used for quick comparison on curves.
</p>


<h3>Value</h3>

<p>No value is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># for all forms of curves initialized by base pattern 'R', with rotation 0, and on level 3
draw_multiple_curves(
    sfc_2x2("R", "111"),
    sfc_2x2("R", "112"),
    sfc_2x2("R", "121"),
    sfc_2x2("R", "122"),
    sfc_2x2("R", "211"),
    sfc_2x2("R", "212"),
    sfc_2x2("R", "221"),
    sfc_2x2("R", "222"),
    nrow = 2, title = TRUE)

# simply a list of sequences
# note they only contain I/R/L, so the base patterns I/R/L are internally used
draw_multiple_curves(
    sfc_sequence("IIII"),
    sfc_sequence("RRRR"),
    sfc_sequence("RRLL"),
    nrow = 1
)
</code></pre>

<hr>
<h2 id='draw_rules_2x2'>Draw the expansion rules</h2><span id='topic+draw_rules_2x2'></span><span id='topic+draw_rules_3x3_peano'></span><span id='topic+draw_rules_3x3_meander'></span>

<h3>Description</h3>

<p>Draw the expansion rules
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_rules_2x2()

draw_rules_3x3_peano(flip = FALSE)

draw_rules_3x3_meander(flip = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="draw_rules_2x2_+3A_flip">flip</code></td>
<td>
<p>Whether to use the &quot;flipped&quot; rules? For the Peano curve and the Meander curve, there is also a &quot;fliiped&quot; version
of the curve expansion rules. See the vignettes for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The expansion rules define how the curve is expanded from level-0 to level-1.
</p>


<h3>Value</h3>

<p>No value is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>draw_rules_2x2()
# the units in the main rules of the Peano curve are vertical
draw_rules_3x3_peano()
# the units in the flipped rules of the Peano curve are horizontal
draw_rules_3x3_peano(flip = TRUE)
# the units in the main rules of the Meander curve are "forward"
# i.e. the direction of the "wave" is the same as the direction of the curve
draw_rules_3x3_meander()
# the units in the flipped rules of the Meander curve are "backward"
draw_rules_3x3_meander(flip = TRUE)
</code></pre>

<hr>
<h2 id='H0'>Seed sequences of the H-curve</h2><span id='topic+H0'></span><span id='topic+H1'></span><span id='topic+H2'></span>

<h3>Description</h3>

<p>Seed sequences of the H-curve
</p>


<h3>Usage</h3>

<pre><code class='language-R'>H0

H1

H2
</code></pre>


<h3>Format</h3>

<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 4 rows and 2 columns.
</p>
<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 16 rows and 2 columns.
</p>
<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 16 rows and 2 columns.
</p>


<h3>Details</h3>

<p>The three objects simply contain coordinates of points on the three base H-curves.
</p>


<h3>Value</h3>

<p>Two-column matrices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>H0
draw_multiple_curves(H0, H1, H2, nrow = 1, closed = TRUE)
</code></pre>

<hr>
<h2 id='hilbert_3d'>Three dimensional Hilbert curve</h2><span id='topic+hilbert_3d'></span>

<h3>Description</h3>

<p>Three dimensional Hilbert curve
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hilbert_3d(level = 2L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hilbert_3d_+3A_level">level</code></td>
<td>
<p>The level of the curve.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are many forms of 3D Hilbert curve. Here we only implement one specific form.
</p>


<h3>Value</h3>

<p>A three-column matrix of coordinates of points on the 3D Hilbert curve.
</p>


<h3>See Also</h3>

<p>Michael Bader. Space-Filling Curves: An Introduction with Applications in Scientific Computing, Springer Science &amp; Business Media, 2012. <a href="https://doi.org/10.1007/978-3-642-31046-1">doi:10.1007/978-3-642-31046-1</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pos = hilbert_3d(2)
if(require(rgl) &amp;&amp; interactive()) {
    plot3d(pos, type = "l", lwd = 4, col = 2)
}
</code></pre>

<hr>
<h2 id='hilbert_curve'>Various curves in their standard forms</h2><span id='topic+hilbert_curve'></span><span id='topic+moore_curve'></span><span id='topic+beta_omega_curve'></span><span id='topic+peano_curve'></span><span id='topic+meander_curve'></span><span id='topic+h_curve'></span>

<h3>Description</h3>

<p>Various curves in their standard forms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hilbert_curve(level = 2L, by = "Cpp")

moore_curve(level = 2L)

beta_omega_curve(level = 2L)

peano_curve(level = 2L, pattern = "vvvvvvvvv", by = "Cpp")

meander_curve(level = 2L, pattern = "fffffffff", code = rep(1, level))

h_curve(iteration = 2L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hilbert_curve_+3A_level">level</code></td>
<td>
<p>Level of the curve.</p>
</td></tr>
<tr><td><code id="hilbert_curve_+3A_by">by</code></td>
<td>
<p>Which implementation? Only for the testing purpose.</p>
</td></tr>
<tr><td><code id="hilbert_curve_+3A_pattern">pattern</code></td>
<td>
<p>The orientation of units on level-2, i.e. the orientation of the 9 3x3 units. The
value should be a string with 9 letters of &quot;v&quot;/&quot;h&quot; (vertical or horizontal) for the Peano curve,
and &quot;f&quot;/&quot;b&quot; (forward or backward) for the Meander curve. The length of the string should be maximal 9.
If the length is smaller than 9, the stringis automatically recycled.</p>
</td></tr>
<tr><td><code id="hilbert_curve_+3A_code">code</code></td>
<td>
<p>Internally used.</p>
</td></tr>
<tr><td><code id="hilbert_curve_+3A_iteration">iteration</code></td>
<td>
<p>Number of iterations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are just special forms of <code><a href="#topic+sfc_2x2">sfc_2x2()</a></code>, <code><a href="#topic+sfc_3x3_peano">sfc_3x3_peano()</a></code>, <code><a href="#topic+sfc_3x3_meander">sfc_3x3_meander()</a></code> and <code><a href="#topic+sfc_h">sfc_h()</a></code>.
</p>


<h3>Value</h3>

<p>A two-column matrix of coordinates of points on the curve.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hilbert_curve(2)
draw_multiple_curves(
    hilbert_curve(3),
    hilbert_curve(4),
    nrow = 1
)
draw_multiple_curves(
    moore_curve(3),
    moore_curve(4),
    nrow = 1
)
draw_multiple_curves(
    beta_omega_curve(3),
    beta_omega_curve(4),
    nrow = 1
)
draw_multiple_curves(
    peano_curve(2),
    peano_curve(3),
    nrow = 1
)
draw_multiple_curves(
    peano_curve(3, pattern = "vh"),
    peano_curve(3, pattern = "vvvhhhvvv"),
    nrow = 1
)
draw_multiple_curves(
    meander_curve(2),
    meander_curve(3),
    nrow = 1
)
draw_multiple_curves(
    meander_curve(3, pattern = "fbfbfbfbf"),
    meander_curve(3, pattern = "bbbbbffff"),
    nrow = 1
)
draw_multiple_curves(
    h_curve(1),
    h_curve(2),
    nrow = 1, closed = TRUE
)
</code></pre>

<hr>
<h2 id='level1_unit_orientation+2Csfc_3x3_peano-method'>Level-1 unit in the Peano curve and Meander curve</h2><span id='topic+level1_unit_orientation+2Csfc_3x3_peano-method'></span><span id='topic+level1_unit_orientation'></span><span id='topic+change_level1_unit_orientation+2Csfc_3x3_peano-method'></span><span id='topic+change_level1_unit_orientation'></span><span id='topic+level1_unit_orientation+2Csfc_3x3_meander-method'></span><span id='topic+change_level1_unit_orientation+2Csfc_3x3_meander-method'></span>

<h3>Description</h3>

<p>Level-1 unit in the Peano curve and Meander curve
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'sfc_3x3_peano'
level1_unit_orientation(p)

## S4 method for signature 'sfc_3x3_peano'
change_level1_unit_orientation(p, to = c("horizontal", "vertical"))

## S4 method for signature 'sfc_3x3_meander'
level1_unit_orientation(p)

## S4 method for signature 'sfc_3x3_meander'
change_level1_unit_orientation(p, to = c("forward", "backward"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="level1_unit_orientation+2B2Csfc_3x3_peano-method_+3A_p">p</code></td>
<td>
<p>For <code>level1_unit_orientation()</code>, it is an <code>sfc_3x3_peano</code> or <code>sfc_3x3_meander</code> unit on level 1.
For <code>change_level1_unit_orientation()</code>, it is a normal <code>sfc_3x3_peano</code> or <code>sfc_3x3_meander</code> object.</p>
</td></tr>
<tr><td><code id="level1_unit_orientation+2B2Csfc_3x3_peano-method_+3A_to">to</code></td>
<td>
<p>A string of &quot;vertical/horizontal&quot; (on the <code>sfc_3x3_peano</code> object) or &quot;forward/backward&quot; (on the <code>sfc_3x3_meander</code> object).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&quot;vertical&quot; and &quot;horizontal&quot; correspond to the direction of the &quot;long segments&quot; in a Peano curve (see <strong>Examples</strong>).
</p>
<p><code>level1_unit_orientation()</code> is normally used inside <code><a href="#topic+sfc_apply">sfc_apply()</a></code>. <code>change_level1_unit_orientation()</code>
changes all level-1 units of a Peano curve or a Meander curve simultaneously.
</p>


<h3>Value</h3>

<p><code>level1_unit_orientation()</code> returns &quot;verticalhorizontal&quot; (on the <code>sfc_3x3_peano</code> object) or &quot;forward/backward&quot; (on the <code>sfc_3x3_meander</code> object).
</p>
<p><code>change_level1_unit_orientation()</code> returns an <code>sfc_3x3_peano</code> or <code>sfc_3x3_meander</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p = sfc_3x3_peano("I", 111)
# the first level-1 unit
level1_unit_orientation(p[1:9, TRUE])
# the fourth level-1 unit
level1_unit_orientation(p[1:9 + 27, TRUE])
p2 = change_level1_unit_orientation(p, "horizontal")
p3 = change_level1_unit_orientation(p, "vertical")
draw_multiple_curves(p, p2, p3, 
    title = c("original", "all horizontal", "all vertical"), nrow = 1)
# by default, orientations of all level-1 units in Meander curve are forward
p = sfc_3x3_meander("I", 111)
level1_unit_orientation(p[1:9, TRUE])
p2 = change_level1_unit_orientation(p, "backward")
draw_multiple_curves(p, p2,
   title = c("all forward", "all backward"), nrow = 1)
</code></pre>

<hr>
<h2 id='plot_segments'>Plot segments</h2><span id='topic+plot_segments'></span>

<h3>Description</h3>

<p>Plot segments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_segments(x, grid = FALSE, title = FALSE, closed = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_segments_+3A_x">x</code></td>
<td>
<p>A two-column matrix of coordinates of points.</p>
</td></tr>
<tr><td><code id="plot_segments_+3A_grid">grid</code></td>
<td>
<p>Whether to add grid lines on the plot?</p>
</td></tr>
<tr><td><code id="plot_segments_+3A_title">title</code></td>
<td>
<p>The value should be <code>FALSE</code> or a string.</p>
</td></tr>
<tr><td><code id="plot_segments_+3A_closed">closed</code></td>
<td>
<p>Whether the curve is closed?</p>
</td></tr>
<tr><td><code id="plot_segments_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="#topic+sfc_grob">sfc_grob()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is only for a quick demonstration of curves represented as two-column coordinate matrices.
</p>


<h3>Value</h3>

<p>No value is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pos = cbind(c(0, 0, 1, 1, 2, 2, 3, 3, 2, 2, 1, 1),
            c(1, 2, 2, 3, 3, 2, 2, 1, 1, 0, 0, 1))
plot_segments(pos)
</code></pre>

<hr>
<h2 id='sfc_2x2'>Create space-filling curves</h2><span id='topic+sfc_2x2'></span><span id='topic+sfc_3x3_peano'></span><span id='topic+sfc_3x3_meander'></span>

<h3>Description</h3>

<p>Create space-filling curves
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfc_2x2(seed, code = integer(0), rot = 0L)

sfc_3x3_peano(seed, code = integer(0), rot = 0L, level = NULL, flip = FALSE)

sfc_3x3_meander(seed, code = integer(0), rot = 0L, flip = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sfc_2x2_+3A_seed">seed</code></td>
<td>
<p>The seed sequence. In most cases, the seed sequence is a single base pattern, which can be specified as a single letter, then <code>rot</code> controls
the initial rotation of the base pattern. It also supports a sequence with more than one base patterns as the seed sequence. In this case,
it can be specified as a string of more than one base letters, then <code>rot</code> can be set to a single rotation scalar which controls the rotation of the
first letter, or a vector with the same length as the number of base letters.</p>
</td></tr>
<tr><td><code id="sfc_2x2_+3A_code">code</code></td>
<td>
<p>A vector of the expansion code. The left side corresponds to the top levels of the curve and the right side corresponds to the bottom level of the curve.
The value can be set as a vector e.g. <code>c(1, 2, 1)</code>, or as a string e.g. <code>"121"</code>, or as a number e.g. <code>121</code>.</p>
</td></tr>
<tr><td><code id="sfc_2x2_+3A_rot">rot</code></td>
<td>
<p>Rotation of the seed sequence, measured in the polar coordinate system, in degrees.</p>
</td></tr>
<tr><td><code id="sfc_2x2_+3A_level">level</code></td>
<td>
<p>Specifically for <code>sfc_3x3_peano()</code>, since there is only one expansion code 1, it can also be generated by <code>rep(1, level)</code>.</p>
</td></tr>
<tr><td><code id="sfc_2x2_+3A_flip">flip</code></td>
<td>
<p>Whether to use the &quot;flipped&quot; rules? For the Peano curve and the Meander curve, there is also a &quot;fliiped&quot; version
of curve expansion rules. On each level expansion in the Peano curve and the Meander curve, a point expands to nine points in
3x3 grids. Thus the value of <code>flip</code> can be set as a logical vector of length of nine that controls whether to use the flipped expansion
for the corresponding unit. Besides such &quot;1-to-9&quot; mode, <code>flip</code> can also be set as a function which acccepts the number of current points in the curve and return
a logical vector with the same length, i.e. the &quot;all-to-all*9&quot; mode.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code>sfc_2x2()</code> generates the Hilbert curve from the seed sequence.
</p>
</li>
<li> <p><code>sfc_3x3_peano()</code> generates the Peano curve from the seed sequence.
</p>
</li>
<li> <p><code>sfc_3x3_meander()</code> generates the Meander curve from the seed sequence.
</p>
</li></ul>



<h3>Value</h3>


<ul>
<li> <p><code>sfc_hilbert()</code> returns an <code>sfc_2x2</code> object.
</p>
</li>
<li> <p><code>sfc_peano()</code> returns an <code>sfc_3x3_peano</code> object.
</p>
</li>
<li> <p><code>sfc_meander()</code> returns an <code>sfc_3x3_meander</code> object.
</p>
</li></ul>

<p>These three classes are child classes of <code>sfc_nxn</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sfc_2x2("I", "111") |&gt; plot()
sfc_2x2("I", "111", rot = 90) |&gt; plot()
sfc_2x2("IR", "111", rot = 90) |&gt; plot()
sfc_3x3_peano("I", "111") |&gt; plot()
sfc_3x3_peano("I", "111", 
    flip = c(FALSE, FALSE, FALSE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE)) |&gt; plot()
sfc_3x3_peano("IJ", "111") |&gt; plot()

sfc_3x3_peano("I", level = 4, flip = function(p) {
    p@rot %in% c(90, 270)
}) |&gt; plot(lwd = 1)

level = 4
sfc_3x3_peano("I", level = level, flip = function(p) {
     if(length(p) == 9^(level-1)) {
         l = rep(FALSE, length(p))
         ind = 1:9^2 + 9^2*rep(c(0, 2, 4, 6, 8), each = 9^2)
         l[ind] = p@rot[ind] %in% c(90, 270)

         ind = 1:9^2 + 9^2*rep(c(1, 3, 5, 7), each = 9^2)
         l[ind] = p@rot[ind] %in% c(0, 180)

         l
    } else {
         rep(FALSE, length(p))
    }
}) |&gt; plot(lwd = 1)

sfc_3x3_meander("I", "111") |&gt; plot()
sfc_3x3_meander("I", "111", 
    flip = c(TRUE, FALSE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE, TRUE)) |&gt; plot()
sfc_3x3_meander("IR", "111") |&gt; plot()
</code></pre>

<hr>
<h2 id='sfc_3x3_combined'>General 3x3 space-filling curves</h2><span id='topic+sfc_3x3_combined'></span><span id='topic+sfc_expand+2Csfc_3x3_combined-method'></span><span id='topic+draw_rules_3x3_combined'></span>

<h3>Description</h3>

<p>General 3x3 space-filling curves
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfc_3x3_combined(seed, level = 0, rot = 0L, flip = FALSE)

## S4 method for signature 'sfc_3x3_combined'
sfc_expand(p, code = NULL, flip = FALSE)

draw_rules_3x3_combined(flip = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sfc_3x3_combined_+3A_seed">seed</code></td>
<td>
<p>The seed sequence. In most cases, the seed sequence is a single base pattern, which can be specified as a single letter, then <code>rot</code> controls
the initial rotation of the base pattern. It also supports a sequence with more than one base patterns as the seed sequence. In this case,
it can be specified as a string of more than one base letters, then <code>rot</code> can be set to a single rotation scalar which controls the rotation of the
first letter, or a vector with the same length as the number of base letters.</p>
</td></tr>
<tr><td><code id="sfc_3x3_combined_+3A_level">level</code></td>
<td>
<p>Level of the curve. Currently it is restricted to an integer no bigger than 5.</p>
</td></tr>
<tr><td><code id="sfc_3x3_combined_+3A_rot">rot</code></td>
<td>
<p>Rotation of the seed sequence, measured in the polar coordinate system, in degrees.</p>
</td></tr>
<tr><td><code id="sfc_3x3_combined_+3A_flip">flip</code></td>
<td>
<p>The same setting as in <code><a href="#topic+sfc_3x3_peano">sfc_3x3_peano()</a></code> or <code><a href="#topic+sfc_3x3_meander">sfc_3x3_meander()</a></code>.</p>
</td></tr>
<tr><td><code id="sfc_3x3_combined_+3A_p">p</code></td>
<td>
<p>An <code>sfc_3x3_combined</code> object.</p>
</td></tr>
<tr><td><code id="sfc_3x3_combined_+3A_code">code</code></td>
<td>
<p>Ignore. The traverse codes are selected randomly.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This type of 3x3 curve uses the combintation of base patterns from both the Peano curve and the Meander curve.
On each level, the traverse path is randomly selected.
</p>


<h3>Value</h3>

<p><code>sfc_3x3_combined()</code> returns an <code>sfc_3x3_combined</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>draw_multiple_curves(
    sfc_3x3_combined("I", level = 3),
    sfc_3x3_combined("I", level = 3),
    sfc_3x3_combined("I", level = 3),
    nrow = 1
)
draw_rules_3x3_combined()
draw_rules_3x3_combined(flip = TRUE)
</code></pre>

<hr>
<h2 id='sfc_4x4_meander'>4x4 space-filling curves in meander type</h2><span id='topic+sfc_4x4_meander'></span><span id='topic+sfc_expand+2Csfc_4x4_meander-method'></span><span id='topic+draw_rules_4x4_meander'></span>

<h3>Description</h3>

<p>4x4 space-filling curves in meander type
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfc_4x4_meander(seed, code = integer(0), rot = 0L, flip = FALSE, type = 1L)

## S4 method for signature 'sfc_4x4_meander'
sfc_expand(p, code, flip = FALSE)

draw_rules_4x4_meander(type = 1, flip = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sfc_4x4_meander_+3A_seed">seed</code></td>
<td>
<p>The seed sequence. In most cases, the seed sequence is a single base pattern, which can be specified as a single letter, then <code>rot</code> controls
the initial rotation of the base pattern. It also supports a sequence with more than one base patterns as the seed sequence. In this case,
it can be specified as a string of more than one base letters, then <code>rot</code> can be set to a single rotation scalar which controls the rotation of the
first letter, or a vector with the same length as the number of base letters.</p>
</td></tr>
<tr><td><code id="sfc_4x4_meander_+3A_code">code</code></td>
<td>
<p>A vector of the expansion code. The left side corresponds to the higher levels (more to the top-level) of the curve and the right side corresponds to the lower level (more to the bottom-level) of the curve.
The value can be set as a vector e.g. <code>c(1, 2, 1)</code>, or as a string e.g. <code>"121"</code>, or as a number e.g. <code>121</code>.</p>
</td></tr>
<tr><td><code id="sfc_4x4_meander_+3A_rot">rot</code></td>
<td>
<p>Rotation of the seed sequence, measured in the polar coordinate system, in degrees.</p>
</td></tr>
<tr><td><code id="sfc_4x4_meander_+3A_flip">flip</code></td>
<td>
<p>The same setting as in <code><a href="#topic+sfc_3x3_peano">sfc_3x3_peano()</a></code> or <code><a href="#topic+sfc_3x3_meander">sfc_3x3_meander()</a></code>.</p>
</td></tr>
<tr><td><code id="sfc_4x4_meander_+3A_type">type</code></td>
<td>
<p>Which type of rules to use? 1 for <code><a href="#topic+SFC_RULES_4x4_MEANDER_1">SFC_RULES_4x4_MEANDER_1</a></code> and 2 for <code><a href="#topic+SFC_RULES_4x4_MEANDER_2">SFC_RULES_4x4_MEANDER_2</a></code>.</p>
</td></tr>
<tr><td><code id="sfc_4x4_meander_+3A_p">p</code></td>
<td>
<p>An <code>sfc_4x4_meander</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is an extension of the 3x3 Meander curves to mode 4. For simplicity, it only supports <code>I/R/L</code> base patterns.
</p>


<h3>Value</h3>

<p><code>sfc_4x4_meander()</code> returns an <code>sfc_4x4_meander</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>draw_multiple_curves(
    sfc_4x4_meander("I", "11", type = 1),
    sfc_4x4_meander("I", "12", type = 1),
    sfc_4x4_meander("I", "11", type = 2),
    sfc_4x4_meander("I", "12", type = 2),
    nrow = 2
)
seed = paste(rep(paste0("R", sapply(0:10, function(i) strrep("I", i))), each = 2), collapse="")
sfc_4x4_meander(seed, 1) |&gt; plot()
draw_rules_4x4_meander(type = 1)
draw_rules_4x4_meander(type = 2)
</code></pre>

<hr>
<h2 id='sfc_apply+2Csfc_nxn-method'>Apply to every unit in the sfc_nxn curve</h2><span id='topic+sfc_apply+2Csfc_nxn-method'></span><span id='topic+sfc_apply'></span>

<h3>Description</h3>

<p>Apply to every unit in the sfc_nxn curve
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'sfc_nxn'
sfc_apply(p, depth = 1, fun = function(x) x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sfc_apply+2B2Csfc_nxn-method_+3A_p">p</code></td>
<td>
<p>An <code>sfc_nxn</code> object.</p>
</td></tr>
<tr><td><code id="sfc_apply+2B2Csfc_nxn-method_+3A_depth">depth</code></td>
<td>
<p>An integer between 0 and <code>level-1</code> of the curve.</p>
</td></tr>
<tr><td><code id="sfc_apply+2B2Csfc_nxn-method_+3A_fun">fun</code></td>
<td>
<p>A function of which the argument <code>x</code> is a subunit in the curve. The subunit is an <code>sfc_nxn</code> object but only contains the current sub-sequence.
The function should return an <code>sfc_seuqence</code> object with the same length as of <code>x</code>. The function can take an optional second argument which
the index of the current subunit in the curve.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is mainly used to flip subunits on various levels on the curve, thus mainly on the Peano curve and the Meander curve.
A depth of 0 corresponds to the complete curve. A depth of 1 corresponds to the nine first-level units, et al.
</p>
<p>Currently, <code>sfc_apply()</code> only works on curves with a single base pattern as the seed.
</p>


<h3>Value</h3>

<p>An <code>sfc_nxn</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p = sfc_3x3_peano("I", level = 3)
# flip the global curve
draw_multiple_curves(
    p, 
    sfc_apply(p, 0, sfc_flip_unit),
    nrow = 1
)

# flip all the subunits on depth = 1
draw_multiple_curves(
    p, 
    sfc_apply(p, 1, sfc_flip_unit),
    nrow = 1
)

# flip all the subunits on depth = 2
draw_multiple_curves(
    p, 
    sfc_apply(p, 2, sfc_flip_unit),
    nrow = 1
)

# flip all level-1 patterns on the Peano curve to horizontal
# only works on the lowest subunit, 
p2 = sfc_apply(p, 2, function(x) {
    if(level1_unit_orientation(x) == "vertical") {
        sfc_flip_unit(x)
    } else {
        x
    }
})
# then on depth=1, only flip the unit with odd index
p3 = sfc_apply(p2, 1, function(x, i) {
    if(i %% 2 == 1) {
        sfc_flip_unit(x)
    } else {
        x
    }
})
draw_multiple_curves(p2, p3, nrow = 1)

# flip all level-1 patterns to vertical
p3 = sfc_apply(p, 2, function(x) {
    if(level1_unit_orientation(x) == "horizontal") {
        sfc_flip_unit(x)
    } else {
        x
    }
})
draw_multiple_curves(p, p3, nrow = 1)
</code></pre>

<hr>
<h2 id='sfc_base'>Constructor of the sfc_base class</h2><span id='topic+sfc_base'></span>

<h3>Description</h3>

<p>Constructor of the sfc_base class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfc_base(
  letter,
  in_direction,
  out_direction,
  grob = NULL,
  primary = TRUE,
  open = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sfc_base_+3A_letter">letter</code></td>
<td>
<p>A single letter to represent the base pattern.</p>
</td></tr>
<tr><td><code id="sfc_base_+3A_in_direction">in_direction</code></td>
<td>
<p>The direction of the segment that enters the point, measured in the polar coordinate system, in degrees.</p>
</td></tr>
<tr><td><code id="sfc_base_+3A_out_direction">out_direction</code></td>
<td>
<p>The direction of the segment that leaves the point, measured in the polar coordinate system, in degrees.</p>
</td></tr>
<tr><td><code id="sfc_base_+3A_grob">grob</code></td>
<td>
<p>A <code><a href="grid.html#topic+grid.grob">grid::grob()</a></code> object of this base pattern. If it is not set, it is generated according to <code>in_direction</code> and <code>out_direction</code>.</p>
</td></tr>
<tr><td><code id="sfc_base_+3A_primary">primary</code></td>
<td>
<p>Currently, going forward, turning left and turning right can be set as primary base patterns because other high-level patterns
can be built from them.</p>
</td></tr>
<tr><td><code id="sfc_base_+3A_open">open</code></td>
<td>
<p>Can the base pattern be connected to other base patterns?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &quot;base pattern&quot; is designed not only for single point but also for combination of points that form a &quot;base curve&quot;. However,
currently, it is fixed to the single point base pattern.
</p>
<p>Currently, this package supports 2x2 and 3x3 space-filling curves that fills grids in 2D space constructed by the Gaussian integers.
And when the curve expands, we only allow the segments to go forward, backward, left and right. Thus there are the following base patterns
pre-defined in this package:
</p>

<ul>
<li> <p><code><a href="#topic+BASE_I">BASE_I</a></code>/<code><a href="#topic+BASE_J">BASE_J</a></code>: go forward.
</p>
</li>
<li> <p><code><a href="#topic+BASE_R">BASE_R</a></code>: turn right.
</p>
</li>
<li> <p><code><a href="#topic+BASE_L">BASE_L</a></code>: turn left.
</p>
</li>
<li> <p><code><a href="#topic+BASE_U">BASE_U</a></code>: go backward.
</p>
</li>
<li> <p><code><a href="#topic+BASE_B">BASE_B</a></code>: leave the start point where the start point is closed.
</p>
</li>
<li> <p><code><a href="#topic+BASE_D">BASE_D</a></code>: leave the start point where the start point is closed.
</p>
</li>
<li> <p><code><a href="#topic+BASE_P">BASE_P</a></code>: return to the end point where the end point is closed.
</p>
</li>
<li> <p><code><a href="#topic+BASE_Q">BASE_Q</a></code>: return to the end point where the end point is closed.
</p>
</li>
<li> <p><code>BASE_C</code>: self-closed.
</p>
</li></ul>

<p>The base pattern determines the final form of the curve.
</p>


<h3>Value</h3>

<p>An <code>sfc_base</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>BASE_I
</code></pre>

<hr>
<h2 id='sfc_expand_by_rules+2Csfc_rules+2Csfc_nxn-method'>Expand a sequence</h2><span id='topic+sfc_expand_by_rules+2Csfc_rules+2Csfc_nxn-method'></span><span id='topic+sfc_expand_by_rules'></span><span id='topic+sfc_expand_by_rules+2Csfc_rules+2Cfactor-method'></span><span id='topic+sfc_expand_by_rules+2Csfc_rules+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Expand a sequence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'sfc_rules,sfc_nxn'
sfc_expand_by_rules(p, seq, code = 1L, flip = FALSE, by = "Cpp")

## S4 method for signature 'sfc_rules,factor'
sfc_expand_by_rules(p, seq, code = 1L, flip = FALSE, by = "Cpp")

## S4 method for signature 'sfc_rules,character'
sfc_expand_by_rules(p, seq, code = 1L, flip = FALSE, by = "Cpp")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sfc_expand_by_rules+2B2Csfc_rules+2B2Csfc_nxn-method_+3A_p">p</code></td>
<td>
<p>An <code>sfc_rules</code> object.</p>
</td></tr>
<tr><td><code id="sfc_expand_by_rules+2B2Csfc_rules+2B2Csfc_nxn-method_+3A_seq">seq</code></td>
<td>
<p>An <code>sfc_nxn</code> object or other objects.</p>
</td></tr>
<tr><td><code id="sfc_expand_by_rules+2B2Csfc_rules+2B2Csfc_nxn-method_+3A_code">code</code></td>
<td>
<p>The expansion code.</p>
</td></tr>
<tr><td><code id="sfc_expand_by_rules+2B2Csfc_rules+2B2Csfc_nxn-method_+3A_flip">flip</code></td>
<td>
<p>For the Peano curve and the Meander curves, each unit can be flipped without affecting other parts in the curve. This argument
controls whether to flip the unit. Since currently it only works on the Peano curve and the Meander curve, <code>flip</code> should be a logical
vector of length one or with the same length as <code>seq</code>. Whether it flips horizontally, vertically or against the diagonal line is automatically choosen.
The value of <code>flip</code> can also be a function which takes the current curve as the only argument.</p>
</td></tr>
<tr><td><code id="sfc_expand_by_rules+2B2Csfc_rules+2B2Csfc_nxn-method_+3A_by">by</code></td>
<td>
<p>Which implementation? Only for the testing purpose.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>seq</code> is an <code>sfc_nxn</code> object, the function also returns an &quot;expanded&quot; <code>sfc_nxn</code> object. Or else it returns an <code>sfc_sequence</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sfc_expand_by_rules(SFC_RULES_2x2, sfc_2x2("I"))
</code></pre>

<hr>
<h2 id='sfc_expand+2Csfc_2x2-method'>Expand the curve to the next level</h2><span id='topic+sfc_expand+2Csfc_2x2-method'></span><span id='topic+sfc_expand'></span><span id='topic+sfc_expand+2Csfc_3x3_peano-method'></span><span id='topic+sfc_expand+2Csfc_3x3_meander-method'></span>

<h3>Description</h3>

<p>Expand the curve to the next level
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'sfc_2x2'
sfc_expand(p, code, flip = FALSE)

## S4 method for signature 'sfc_3x3_peano'
sfc_expand(p, code = 1, flip = FALSE)

## S4 method for signature 'sfc_3x3_meander'
sfc_expand(p, code, flip = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sfc_expand+2B2Csfc_2x2-method_+3A_p">p</code></td>
<td>
<p>An <code>sfc_2x2</code> object or other related objects.</p>
</td></tr>
<tr><td><code id="sfc_expand+2B2Csfc_2x2-method_+3A_code">code</code></td>
<td>
<p>Expansion code, a single integer.</p>
</td></tr>
<tr><td><code id="sfc_expand+2B2Csfc_2x2-method_+3A_flip">flip</code></td>
<td>
<p>Whethe to flip level-1 units? The value should be a logical vector of length one or the same as the length of <code>p</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the Hilbert curve and Meander curve, as long as the expansion code of the first base pattern in the sequence is determinted,
the expansion codes for other base patterns in the sequence are all determined. For the Peano curve, since
there is only one traverse path on any level, <code>code</code> is ignored.
</p>
<p>These functions are mainly used internally.
</p>


<h3>Value</h3>

<p>An object in the same class as the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p = sfc_2x2("I", 11)
sfc_expand(p, 2) # I|211
p = sfc_3x3_peano("I", 11)
sfc_expand(p, 2) # I|211
p = sfc_3x3_meander("I", 11)
sfc_expand(p, 2) # I|211
</code></pre>

<hr>
<h2 id='sfc_generator'>Generate a nxn curve based on expansion rules</h2><span id='topic+sfc_generator'></span>

<h3>Description</h3>

<p>Generate a nxn curve based on expansion rules
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfc_generator(
  rules,
  name,
  envir = topenv(parent.frame()),
  flippable = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sfc_generator_+3A_rules">rules</code></td>
<td>
<p>An <code>sfc_rules</code> object.</p>
</td></tr>
<tr><td><code id="sfc_generator_+3A_name">name</code></td>
<td>
<p>Name of the curve. The name will be used for the functions that will be generated.</p>
</td></tr>
<tr><td><code id="sfc_generator_+3A_envir">envir</code></td>
<td>
<p>Environment where the functions are exported.</p>
</td></tr>
<tr><td><code id="sfc_generator_+3A_flippable">flippable</code></td>
<td>
<p>Whether <code>rules</code> can have flipped version? If it is <code>TRUE</code>, the generated function also accepts the <code>flip</code> argument.</p>
</td></tr>
<tr><td><code id="sfc_generator_+3A_verbose">verbose</code></td>
<td>
<p>Whether to print messages?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two functions will be exported:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;sfc_{name}()&#8288;</code>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;draw_rules_{name}()&#8288;</code>
</p>
</li></ul>

<p>For the simplicity, flipping is not supported yet.
</p>


<h3>Value</h3>

<p>No value is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>UNIVERSE_4x4_PEANO = c("I", "R", "L")

RULES_4x4_PEANO = list()
RULES_4x4_PEANO[["I"]][[1]] = sfc_unit("RIILLIIRRIILLIIR", rot = 0, universe = UNIVERSE_4x4_PEANO)
RULES_4x4_PEANO[["I"]][[2]] = sfc_hflip(RULES_4x4_PEANO[["I"]][[1]])
RULES_4x4_PEANO[["R"]][[1]] = sfc_unit("IIIRRIILLIIRRIIL", rot = 0, universe = UNIVERSE_4x4_PEANO)      
RULES_4x4_PEANO[["R"]][[2]] = sfc_rotate(sfc_unit("LIIRRIILLIIRRIII", 
                                rot = 270, universe = UNIVERSE_4x4_PEANO), 90)
RULES_4x4_PEANO[["L"]][[1]] = sfc_hflip(RULES_4x4_PEANO[["R"]][[2]])
RULES_4x4_PEANO[["L"]][[2]] = sfc_hflip(RULES_4x4_PEANO[["R"]][[1]])

SFC_RULES_4x4_PEANO = sfc_rules(rules = RULES_4x4_PEANO,
        name = "Peano 4x4",
        bases = BASE_LIST[UNIVERSE_4x4_PEANO])

sfc_generator(SFC_RULES_4x4_PEANO, "4x4_peano")
draw_rules_4x4_peano()
sfc_4x4_peano("I", 111) |&gt; plot()
</code></pre>

<hr>
<h2 id='sfc_grob+2Csfc_base-method'>The graphics object</h2><span id='topic+sfc_grob+2Csfc_base-method'></span><span id='topic+sfc_grob+2Csfc_sequence-method'></span><span id='topic+sfc_grob'></span><span id='topic+plot.sfc_sequence'></span><span id='topic+sfc_grob+2Csfc_nxn-method'></span><span id='topic+plot.sfc_nxn'></span><span id='topic+sfc_grob+2Cmatrix-method'></span>

<h3>Description</h3>

<p>The graphics object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'sfc_base'
sfc_grob(p)

## S4 method for signature 'sfc_sequence'
sfc_grob(
  p,
  bases = NULL,
  extend = FALSE,
  title = FALSE,
  closed = FALSE,
  lwd = 4,
  col = NULL,
  ...
)

## S3 method for class 'sfc_sequence'
plot(
  x,
  bases = NULL,
  grid = FALSE,
  extend = FALSE,
  title = FALSE,
  closed = FALSE,
  ...
)

## S4 method for signature 'sfc_nxn'
sfc_grob(
  p,
  bases = p@rules@bases,
  extend = FALSE,
  title = FALSE,
  closed = FALSE,
  ...
)

## S3 method for class 'sfc_nxn'
plot(x, grid = FALSE, extend = FALSE, title = FALSE, closed = FALSE, ...)

## S4 method for signature 'matrix'
sfc_grob(p, title = NULL, closed = FALSE, lwd = 4, col = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sfc_grob+2B2Csfc_base-method_+3A_p">p</code></td>
<td>
<p>The corresponding object.</p>
</td></tr>
<tr><td><code id="sfc_grob+2B2Csfc_base-method_+3A_bases">bases</code></td>
<td>
<p>A list of base patterns, normally <code><a href="#topic+BASE_LIST">BASE_LIST</a></code> is used.</p>
</td></tr>
<tr><td><code id="sfc_grob+2B2Csfc_base-method_+3A_extend">extend</code></td>
<td>
<p>Whether to add the entry and exit segments?</p>
</td></tr>
<tr><td><code id="sfc_grob+2B2Csfc_base-method_+3A_title">title</code></td>
<td>
<p>Whether to add title on the top of the plot? The title is constructed in the form of <code>initial_seed|expansion_code</code>, e.g. <code>I|111</code>.
The value can also be a string.</p>
</td></tr>
<tr><td><code id="sfc_grob+2B2Csfc_base-method_+3A_closed">closed</code></td>
<td>
<p>Whether the curve is closed?</p>
</td></tr>
<tr><td><code id="sfc_grob+2B2Csfc_base-method_+3A_lwd">lwd</code></td>
<td>
<p>Line width.</p>
</td></tr>
<tr><td><code id="sfc_grob+2B2Csfc_base-method_+3A_col">col</code></td>
<td>
<p>Color for segments. If the value is <code>NULL</code>, it uses the &quot;Spectral&quot; color palettes.</p>
</td></tr>
<tr><td><code id="sfc_grob+2B2Csfc_base-method_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="grid.html#topic+viewport">grid::viewport()</a></code> or <code>sfc_grob()</code>.</p>
</td></tr>
<tr><td><code id="sfc_grob+2B2Csfc_base-method_+3A_x">x</code></td>
<td>
<p>The corresponding object.</p>
</td></tr>
<tr><td><code id="sfc_grob+2B2Csfc_base-method_+3A_grid">grid</code></td>
<td>
<p>Whether to add grid lines on the plot?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>p</code> is an <code>sfc_sequence</code> and <code>p</code> contains base patterns defined in <code>"I/J/R/L/U/B/D/P/Q/C"</code>,
the default <code><a href="#topic+BASE_LIST">BASE_LIST</a></code> is automatically used for <code>bases</code>. If <code>p</code> is an <code>sfc_nxn</code> object, <code>bases</code>
is already stored in <code>p</code> and it is passed to this function automatically.
</p>


<h3>Value</h3>

<p>A <code><a href="grid.html#topic+grid.grob">grid::grob()</a></code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sfc_grob(BASE_I)
plot(sfc_2x2("I", "11"))
plot(sfc_2x2("I", "11"), extend = TRUE, title = TRUE, grid = TRUE)
plot(sfc_sequence("IIIRRR"))
</code></pre>

<hr>
<h2 id='sfc_h'>H-curve</h2><span id='topic+sfc_h'></span><span id='topic+expand_h'></span>

<h3>Description</h3>

<p>H-curve
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfc_h(h, iteration = 1, connect = c("h", "v"), random = FALSE)

expand_h(h1, h2 = h1, h3 = h1, h4 = h1, connect = "hhhh")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sfc_h_+3A_h">h</code></td>
<td>
<p>The seed of the H-curve. The value should be one of <code><a href="#topic+H0">H0</a></code>, <code><a href="#topic+H1">H1</a></code> or <code><a href="#topic+H2">H2</a></code>.</p>
</td></tr>
<tr><td><code id="sfc_h_+3A_iteration">iteration</code></td>
<td>
<p>Number of iterations.</p>
</td></tr>
<tr><td><code id="sfc_h_+3A_connect">connect</code></td>
<td>
<p>How the four subunits are connected to form the H-curve on the next level. See <strong>Details</strong>.</p>
</td></tr>
<tr><td><code id="sfc_h_+3A_random">random</code></td>
<td>
<p>Whether to generate subunits randomly on each iteration.</p>
</td></tr>
<tr><td><code id="sfc_h_+3A_h1">h1</code></td>
<td>
<p>The first subunit on the bottom left.</p>
</td></tr>
<tr><td><code id="sfc_h_+3A_h2">h2</code></td>
<td>
<p>The second subunit on the top left.</p>
</td></tr>
<tr><td><code id="sfc_h_+3A_h3">h3</code></td>
<td>
<p>The third subunit on the top right.</p>
</td></tr>
<tr><td><code id="sfc_h_+3A_h4">h4</code></td>
<td>
<p>The fourth subunit on the bottom right.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An H-curve on level k is composed with four subunits on level k-1. If we number the four subunits in the following order:
</p>
<div class="sourceCode"><pre>2  3
1  4
</pre></div>
<p>where subunit 1 connects to subunit 2, subunit 2 connects to subunit 3, et al., and e.g. subunit 1 connects to subunit 2
via its toprigth corner. Since H-curve can be thought of as a closed curve, to, e.g. let subunit 1 to connect to
subunit 2, its topright corner needs to be opened. There are two segments on subunit 1 that can be removed/opened: the horizontal
segment and the vertical segment on the topright corner in subunit 1.
</p>
<p>In this way, in <code>sfc_h()</code>, the argument <code>connect</code> only accepts a single value of <code>"h"</code> or <code>"v"</code> where the types of segments for
all the four subunits are the same, i.e. whether all the horizontal corner segments are opened or whether all the vertical corner
segments are opened. In <code>expand_h()</code>, the argument <code>connect</code> can be set to a string with four letters or a vector of length four where the type of segments of the
four subunits can be set separately.
</p>
<p>In the random mode, each subunit is generated randomly, the type of the open segment is choosen randomly, also each subunit has a probability of 0.5
to rotate by 90 degrees.
</p>


<h3>Value</h3>

<p>A two-column matrix of coordinates of points on the curve.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>draw_multiple_curves(
    sfc_h(H0, iteration = 2),
    sfc_h(H2, iteration = 2),
    closed = TRUE, nrow =1
)
draw_multiple_curves(
    sfc_h(H1, iteration = 3, random = TRUE),
    sfc_h(H1, iteration = 3, random = TRUE),
    closed = TRUE, nrow = 1
)
draw_multiple_curves(
    expand_h(H0, connect = "hvvh"),
    expand_h(H1, connect = "vvhh"),
    closed = TRUE, nrow = 1
)

# set the four subunits separately
h1 = expand_h(H0, connect = "hhhh")
h2 = expand_h(H0, connect = "vvvv")
h3 = expand_h(H0, connect = "hvhv")
h4 = expand_h(H0, connect = "hvvh")
expand_h(h1, h2, h3, h4, connect = "vhvh") |&gt; 
    plot_segments(closed = TRUE)

fun = function(h, iteration) {
    for(i in 1:iteration) h = expand_h(h, connect = "vhvh")
    h
}
fun(H0, 4) |&gt; plot_segments(closed = TRUE)
</code></pre>

<hr>
<h2 id='sfc_is_compatible+2Csfc_sequence+2Csfc_sequence-method'>Whether two sfc_sequence objects are compatible</h2><span id='topic+sfc_is_compatible+2Csfc_sequence+2Csfc_sequence-method'></span><span id='topic+sfc_is_compatible'></span><span id='topic+sfc_is_compatible+2Csfc_sequence+2Csfc_rules-method'></span><span id='topic+sfc_is_compatible+2Csfc_rules+2Csfc_sequence-method'></span>

<h3>Description</h3>

<p>Whether two sfc_sequence objects are compatible
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'sfc_sequence,sfc_sequence'
sfc_is_compatible(p1, p2, strict = TRUE)

## S4 method for signature 'sfc_sequence,sfc_rules'
sfc_is_compatible(p1, p2)

## S4 method for signature 'sfc_rules,sfc_sequence'
sfc_is_compatible(p1, p2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sfc_is_compatible+2B2Csfc_sequence+2B2Csfc_sequence-method_+3A_p1">p1</code></td>
<td>
<p>An <code>sfc_sequence</code> object.</p>
</td></tr>
<tr><td><code id="sfc_is_compatible+2B2Csfc_sequence+2B2Csfc_sequence-method_+3A_p2">p2</code></td>
<td>
<p>An <code>sfc_sequence</code> object.</p>
</td></tr>
<tr><td><code id="sfc_is_compatible+2B2Csfc_sequence+2B2Csfc_sequence-method_+3A_strict">strict</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>, see <strong>Details</strong>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function compares whether the two universe base pattern sets are identical.
If <code>strict</code> is <code>TRUE</code>, the order of the two universe sets should also be the same.
If <code>strict</code> is <code>FALSE</code>, the universe set of <code>p2</code> can be a subset of the universe set of <code>p1</code>.
</p>


<h3>Value</h3>

<p>A logical scalar.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p1 = sfc_2x2("I")
p2 = sfc_2x2("R")
sfc_is_compatible(p1, p2)

p1 = sfc_2x2("I")
p2 = sfc_sequence("R")
sfc_is_compatible(p1, p2)
sfc_is_compatible(p1, p2, strict = FALSE)

p1 = sfc_sequence("ABC")
p2 = sfc_sequence("DEF")
sfc_is_compatible(p1, p2)
</code></pre>

<hr>
<h2 id='sfc_level+2Csfc_nxn-method'>The level of the curve</h2><span id='topic+sfc_level+2Csfc_nxn-method'></span><span id='topic+sfc_level'></span>

<h3>Description</h3>

<p>The level of the curve
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'sfc_nxn'
sfc_level(p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sfc_level+2B2Csfc_nxn-method_+3A_p">p</code></td>
<td>
<p>An <code>sfc_nxn</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p = sfc_2x2("I", "11")
sfc_level(p)

p = sfc_2x2("I", "1111")
sfc_level(p)
</code></pre>

<hr>
<h2 id='sfc_mode+2Csfc_nxn-method'>The mode of the curve</h2><span id='topic+sfc_mode+2Csfc_nxn-method'></span><span id='topic+sfc_mode+2Csfc_rules-method'></span><span id='topic+sfc_mode'></span>

<h3>Description</h3>

<p>The mode of the curve
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'sfc_nxn'
sfc_mode(p)

## S4 method for signature 'sfc_rules'
sfc_mode(p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sfc_mode+2B2Csfc_nxn-method_+3A_p">p</code></td>
<td>
<p>The corresponding object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p = sfc_2x2("I", "1")
sfc_mode(p)
p = sfc_3x3_peano("I", "1")
sfc_mode(p)
sfc_mode(SFC_RULES_2x2)
sfc_mode(SFC_RULES_3x3_PEANO)
</code></pre>

<hr>
<h2 id='sfc_previous_point+2Csfc_base-method'>The previous and the next point</h2><span id='topic+sfc_previous_point+2Csfc_base-method'></span><span id='topic+sfc_previous_point'></span><span id='topic+sfc_next_point+2Csfc_base-method'></span><span id='topic+sfc_next_point'></span>

<h3>Description</h3>

<p>The previous and the next point
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'sfc_base'
sfc_previous_point(p, x, rot, length = 1)

## S4 method for signature 'sfc_base'
sfc_next_point(p, x, rot, length = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sfc_previous_point+2B2Csfc_base-method_+3A_p">p</code></td>
<td>
<p>An <code>sfc_base</code> object.</p>
</td></tr>
<tr><td><code id="sfc_previous_point+2B2Csfc_base-method_+3A_x">x</code></td>
<td>
<p>The coordinate of the current point.</p>
</td></tr>
<tr><td><code id="sfc_previous_point+2B2Csfc_base-method_+3A_rot">rot</code></td>
<td>
<p>Rotation of the current point.</p>
</td></tr>
<tr><td><code id="sfc_previous_point+2B2Csfc_base-method_+3A_length">length</code></td>
<td>
<p>Length of the segment between the previous/next point and the current point.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length two.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sfc_previous_point(BASE_R, c(0, 0), 0)
sfc_previous_point(BASE_R, c(0, 0), 90)
sfc_previous_point(BASE_R, c(0, 0), 180)
sfc_previous_point(BASE_R, c(1, 0), 0)
sfc_previous_point(BASE_R, c(1, 0), 90)
sfc_previous_point(BASE_R, c(1, 0), 180)
sfc_next_point(BASE_R, c(0, 0), 0)
sfc_next_point(BASE_R, c(0, 0), 90)
sfc_next_point(BASE_R, c(0, 0), 180)
sfc_next_point(BASE_R, c(1, 0), 0)
sfc_next_point(BASE_R, c(1, 0), 90)
sfc_next_point(BASE_R, c(1, 0), 180)
</code></pre>

<hr>
<h2 id='sfc_reduce+2Csfc_nxn-method'>Reduce a curve</h2><span id='topic+sfc_reduce+2Csfc_nxn-method'></span><span id='topic+sfc_reduce'></span><span id='topic+sfc_reduce+2Cmatrix-method'></span><span id='topic+add_base_structure'></span>

<h3>Description</h3>

<p>Reduce a curve
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'sfc_nxn'
sfc_reduce(p, to = sfc_level(p) - 1)

## S4 method for signature 'matrix'
sfc_reduce(p, to = level - 1, mode = NULL)

add_base_structure(gb, level = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sfc_reduce+2B2Csfc_nxn-method_+3A_p">p</code></td>
<td>
<p>An <code>sfc_nxn</code> object.</p>
</td></tr>
<tr><td><code id="sfc_reduce+2B2Csfc_nxn-method_+3A_to">to</code></td>
<td>
<p>Which level to reduce to? Value should be between 1 and <code>sfc_level(p) - 1</code>.</p>
</td></tr>
<tr><td><code id="sfc_reduce+2B2Csfc_nxn-method_+3A_mode">mode</code></td>
<td>
<p>Mode of the curve.</p>
</td></tr>
<tr><td><code id="sfc_reduce+2B2Csfc_nxn-method_+3A_gb">gb</code></td>
<td>
<p>A <code>grob</code> object returned by <code><a href="#topic+sfc_grob">sfc_grob()</a></code> or a <code>sfc_nxn</code> object then <code><a href="#topic+sfc_grob">sfc_grob()</a></code> is internally applied.</p>
</td></tr>
<tr><td><code id="sfc_reduce+2B2Csfc_nxn-method_+3A_level">level</code></td>
<td>
<p>The level of the unit.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The reduction is applied on the coordinates of points.
</p>
<p><code>add_base_structure()</code> adds a base structure on a certain level to the curve.
</p>


<h3>Value</h3>

<p>A two-column matrix of coordinates of the reduced curve.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p = sfc_3x3_peano("I", level = 3)
draw_multiple_curves(
    p, 
    sfc_reduce(p, 2), 
    sfc_reduce(p, 1), 
    nrow = 1)
p = hilbert_curve(level = 4)
draw_multiple_curves(
    p, 
    sfc_reduce(p, 3), 
    sfc_reduce(p, 2), 
    nrow = 1)
p = hilbert_curve(3)
draw_multiple_curves(
    add_base_structure(p, level = 1),
    add_base_structure(p, level = 2),
    nrow = 1
)
</code></pre>

<hr>
<h2 id='sfc_rotate+2Csfc_sequence-method'>Transformations of a sequence</h2><span id='topic+sfc_rotate+2Csfc_sequence-method'></span><span id='topic+sfc_rotate'></span><span id='topic++5E.sfc_sequence'></span><span id='topic+sfc_hflip+2Csfc_sequence-method'></span><span id='topic+sfc_hflip'></span><span id='topic+sfc_vflip+2Csfc_sequence-method'></span><span id='topic+sfc_vflip'></span><span id='topic+sfc_dflip+2Csfc_sequence-method'></span><span id='topic+sfc_dflip'></span><span id='topic+sfc_reverse+2Csfc_sequence-method'></span><span id='topic+sfc_reverse'></span><span id='topic+rev.sfc_sequence'></span>

<h3>Description</h3>

<p>Transformations of a sequence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'sfc_sequence'
sfc_rotate(p, rot)

## S3 method for class 'sfc_sequence'
e1 ^ e2

## S4 method for signature 'sfc_sequence'
sfc_hflip(p, fix_ends = FALSE, bases = NULL)

## S4 method for signature 'sfc_sequence'
sfc_vflip(p, fix_ends = FALSE, bases = NULL)

## S4 method for signature 'sfc_sequence'
sfc_dflip(p, slop = 1L, fix_ends = FALSE, bases = NULL)

## S4 method for signature 'sfc_sequence'
sfc_reverse(p)

## S3 method for class 'sfc_sequence'
rev(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sfc_rotate+2B2Csfc_sequence-method_+3A_p">p</code>, <code id="sfc_rotate+2B2Csfc_sequence-method_+3A_e1">e1</code></td>
<td>
<p>An <code>sfc_sequence</code> object.</p>
</td></tr>
<tr><td><code id="sfc_rotate+2B2Csfc_sequence-method_+3A_rot">rot</code>, <code id="sfc_rotate+2B2Csfc_sequence-method_+3A_e2">e2</code></td>
<td>
<p>Rotation measured in the polar coordinate system, in degrees.</p>
</td></tr>
<tr><td><code id="sfc_rotate+2B2Csfc_sequence-method_+3A_fix_ends">fix_ends</code></td>
<td>
<p>By default, the curve is flipped as a complete whole, which means, the associated entry and exit directions of the curve
is also adjusted accordingly. When flipping subunits in a curve, e.g. level-1 subunits in a Peano curve, we want the
entry and exit direction of the subunit not changed so that the subunits are still connected in the curve after the flipping. In this
case, <code>fix_ends</code> can be set to <code>TRUE</code>, then only the subunits are flipped while the connections to neighbouring subunits are not affected.
See the <strong>Examples</strong> section.</p>
</td></tr>
<tr><td><code id="sfc_rotate+2B2Csfc_sequence-method_+3A_bases">bases</code></td>
<td>
<p>A list of base patterns, consider to use <code><a href="#topic+BASE_LIST">BASE_LIST</a></code>. It is only used when <code>fix_ends = TRUE</code>.</p>
</td></tr>
<tr><td><code id="sfc_rotate+2B2Csfc_sequence-method_+3A_slop">slop</code></td>
<td>
<p>Slop of the diagonal. Value can only be 1 or -1.</p>
</td></tr>
<tr><td><code id="sfc_rotate+2B2Csfc_sequence-method_+3A_x">x</code></td>
<td>
<p>An <code>sfc_sequence</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code>sfc_rotate()</code> and <code style="white-space: pre;">&#8288;^()&#8288;</code> rotate each base pattern.
</p>
</li>
<li> <p><code>sfc_hflip()</code> flips a sequence horizontally.
</p>
</li>
<li> <p><code>sfc_vflip()</code> flips a sequence vertically.
</p>
</li>
<li> <p><code>sfc_dflip()</code> flips a sequence against a diagonal line (with slop 1 or -1).
</p>
</li></ul>



<h3>Value</h3>

<p>An <code>sfc_sequence</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p = sfc_3x3_meander("R", 2, rot = -90)
draw_multiple_curves(
    p, 
    sfc_hflip(p), 
    sfc_hflip(p, fix_ends = TRUE), 
    nrow = 1)
p = sfc_3x3_meander("L", 2, rot = -90)
draw_multiple_curves(
    p, 
    sfc_vflip(p), 
    sfc_vflip(p, fix_ends = TRUE), 
    nrow = 1)
p = sfc_3x3_peano("I", 2)
draw_multiple_curves(
    p, 
    sfc_dflip(p, 1), 
    sfc_dflip(p, 1, fix_ends = TRUE), 
    nrow = 1)
</code></pre>

<hr>
<h2 id='sfc_rules'>Constructor of the sfc_rules class</h2><span id='topic+sfc_rules'></span>

<h3>Description</h3>

<p>Constructor of the sfc_rules class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfc_rules(rules, bases, flip = list(), name = "sfc_rules")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sfc_rules_+3A_rules">rules</code></td>
<td>
<p>A list of rules.</p>
</td></tr>
<tr><td><code id="sfc_rules_+3A_bases">bases</code></td>
<td>
<p>A list of base patterns.</p>
</td></tr>
<tr><td><code id="sfc_rules_+3A_flip">flip</code></td>
<td>
<p>A list of rules. They are &quot;flipped&quot; version of <code>rules</code>. The value can also simply be <code>TRUE</code>, then
the flipped version is automatically generated from <code>rules</code>.</p>
</td></tr>
<tr><td><code id="sfc_rules_+3A_name">name</code></td>
<td>
<p>A self-defined string.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is mainly used internally.
</p>
<p><code>rules</code> is a two-level list. It is in a format of <code>rules[[ base ]][[ expansion_code ]] = sfc_unit()</code>.
In the following example where we define the expansion rules for the 2x2 curve:
</p>
<div class="sourceCode"><pre>UNIVERSE_2x2 = c("I", "R", "L", "U", "B", "D", "P", "Q", "C")
RULES_2x2 = list()
RULES_2x2[["I"]][[1]] = sfc_unit(c("R", "L", "L", "R"), rot = 0, universe = UNIVERSE_2x2)
</pre></div>
<p><code>I</code> is the level-0 base pattern, <code style="white-space: pre;">&#8288;[[1]]&#8288;</code> corresponds to the first form of expansion to level-1, and the value
assigned is a <code><a href="#topic+sfc_unit">sfc_unit()</a></code> object which is basically a list of base patterns.
</p>
<p>Then we also need to provide the base patterns which define how to extend the curve. The list of base patterns
is assigned to the <code>bases</code> argument. In the same example, we set <code>bases</code> as:
</p>
<div class="sourceCode"><pre>list("I" = BASE_I, "R" = BASE_R, "L" = BASE_L, "U" = BASE_U, ...)
</pre></div>
<p>where e.g. <code><a href="#topic+BASE_I">BASE_I</a></code> is a pre-defined base pattern in the <code><a href="#topic+sfc_base">sfc_base</a></code> class.
</p>
<p>There are the following pre-defined rules:
</p>

<ul>
<li> <p><code><a href="#topic+SFC_RULES_2x2">SFC_RULES_2x2</a></code>
</p>
</li>
<li> <p><code><a href="#topic+SFC_RULES_3x3_PEANO">SFC_RULES_3x3_PEANO</a></code>
</p>
</li>
<li> <p><code><a href="#topic+SFC_RULES_3x3_MEANDER">SFC_RULES_3x3_MEANDER</a></code>
</p>
</li>
<li> <p><code><a href="#topic+SFC_RULES_3x3_COMBINED">SFC_RULES_3x3_COMBINED</a></code>
</p>
</li>
<li> <p><code><a href="#topic+SFC_RULES_4x4_MEANDER_1">SFC_RULES_4x4_MEANDER_1</a></code>
</p>
</li>
<li> <p><code><a href="#topic+SFC_RULES_4x4_MEANDER_2">SFC_RULES_4x4_MEANDER_2</a></code>
</p>
</li></ul>

<p>Check <a href="https://github.com/jokergoo/sfcurve/blob/master/R/zz_global.R">https://github.com/jokergoo/sfcurve/blob/master/R/zz_global.R</a> to see how these pre-defined rules are constructed.
</p>


<h3>Value</h3>

<p>An <code>sfc_rules</code> object.
</p>

<hr>
<h2 id='SFC_RULES_2x2'>Rules</h2><span id='topic+SFC_RULES_2x2'></span><span id='topic+SFC_RULES_3x3_PEANO'></span><span id='topic+SFC_RULES_3x3_MEANDER'></span><span id='topic+SFC_RULES_3x3_COMBINED'></span><span id='topic+SFC_RULES_4x4_MEANDER_1'></span><span id='topic+SFC_RULES_4x4_MEANDER_2'></span>

<h3>Description</h3>

<p>A list of pre-defined expansion rules for different curves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SFC_RULES_2x2

SFC_RULES_3x3_PEANO

SFC_RULES_3x3_MEANDER

SFC_RULES_3x3_COMBINED

SFC_RULES_4x4_MEANDER_1

SFC_RULES_4x4_MEANDER_2
</code></pre>


<h3>Format</h3>

<p>An object of class <code>sfc_rules</code> of length 1.
</p>
<p>An object of class <code>sfc_rules</code> of length 1.
</p>
<p>An object of class <code>sfc_rules</code> of length 1.
</p>
<p>An object of class <code>sfc_rules</code> of length 1.
</p>
<p>An object of class <code>sfc_rules</code> of length 1.
</p>
<p>An object of class <code>sfc_rules</code> of length 1.
</p>


<h3>Details</h3>

<p><code>SFC_RULES_3x3_PEANO</code>, <code>SFC_RULES_3x3_MEANDER</code> and <code>SFC_RULES_3x3_COMBINED</code>, <code>SFC_RULES_MEANDER_4x4_1</code>, <code>SFC_RULES_MEANDER_4x4_2</code> also contain the &quot;flipped&quot; expansion rules.
</p>
<p><code>SFC_RULES_3x3_COMBINED</code> is a combination of <code>SFC_RULES_3x3_PEANO</code> and <code>SFC_RULES_3x3_MEANDER</code> where
in <code>SFC_RULES_3x3_PEANO</code>, <code>J</code> is replaced by its original pattern <code>I</code>.
</p>
<p><code>SFC_RULES_4x4_MEANDER_1</code> and <code>SFC_RULES_4x4_MEANDER_2</code> are extension rules of Meander curves (3x3)
on the 4x4 mode It is only for the demonstration purpose, thus only <code>I/R/L</code> are supported.
</p>


<h3>Value</h3>

<p><code>sfc_rules</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SFC_RULES_2x2
SFC_RULES_3x3_PEANO
SFC_RULES_3x3_MEANDER
SFC_RULES_3x3_COMBINED
SFC_RULES_4x4_MEANDER_1
SFC_RULES_4x4_MEANDER_2
</code></pre>

<hr>
<h2 id='sfc_segments+2Csfc_nxn-method'>Coordinates of the points on the curve</h2><span id='topic+sfc_segments+2Csfc_nxn-method'></span><span id='topic+sfc_segments'></span><span id='topic+sfc_segments+2Csfc_sequence-method'></span>

<h3>Description</h3>

<p>Coordinates of the points on the curve
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'sfc_nxn'
sfc_segments(p, bases = p@rules@bases, start = c(0, 0), ...)

## S4 method for signature 'sfc_sequence'
sfc_segments(p, bases = NULL, start = c(0, 0), by = "Cpp")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sfc_segments+2B2Csfc_nxn-method_+3A_p">p</code></td>
<td>
<p>An <code>sfc_nxn</code> or <code>sfc_sequence</code> object.</p>
</td></tr>
<tr><td><code id="sfc_segments+2B2Csfc_nxn-method_+3A_bases">bases</code></td>
<td>
<p>A list of base patterns, consider to use <code><a href="#topic+BASE_LIST">BASE_LIST</a></code>.</p>
</td></tr>
<tr><td><code id="sfc_segments+2B2Csfc_nxn-method_+3A_start">start</code></td>
<td>
<p>Coordinate of the start point.</p>
</td></tr>
<tr><td><code id="sfc_segments+2B2Csfc_nxn-method_+3A_...">...</code></td>
<td>
<p>Other argument.</p>
</td></tr>
<tr><td><code id="sfc_segments+2B2Csfc_nxn-method_+3A_by">by</code></td>
<td>
<p>Which implementation? Only for the testing purpose.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the <code>sfc_segments()</code> on the <code>sfc_sequence</code> object, if <code>bases</code> is not set,
it uses <code><a href="#topic+BASE_LIST">BASE_LIST</a></code> internally. Make sure the sequence only contains the pre-defined base patterns.
</p>


<h3>Value</h3>

<p>A two-column matrix of coordinates of points on the curve.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p = sfc_2x2("I", "11")
loc = sfc_segments(p)
plot(loc, type = "l", asp = 1)
</code></pre>

<hr>
<h2 id='sfc_sequence'>Constructor of the sfc_sequence class</h2><span id='topic+sfc_sequence'></span><span id='topic+sfc_seed'></span><span id='topic+sfc_unit'></span>

<h3>Description</h3>

<p>Constructor of the sfc_sequence class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfc_sequence(seq, rot = 0L, universe = NULL)

sfc_seed(seq, rot = 0L, universe = NULL)

sfc_unit(seq, rot = 0L, universe = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sfc_sequence_+3A_seq">seq</code></td>
<td>
<p>A sequence of base patterns. The value can be a vector of letters or a single string.</p>
</td></tr>
<tr><td><code id="sfc_sequence_+3A_rot">rot</code></td>
<td>
<p>The corresponding rotations of base patterns. If it has length one and the sequence contains R/L/I (right/left/forward),
<code>rot</code> controls the rotation of the first base pattern and the rotations for remaining base patterns in the sequence are automatically
calculated.</p>
</td></tr>
<tr><td><code id="sfc_sequence_+3A_universe">universe</code></td>
<td>
<p>The universe of base patterns. A vector of letters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This funtion is very low-level. Normally, users do not need to directly use this constructor.
</p>
<p><code>sfc_seed</code> class is the same as the <code>sfc_sequence</code> class. It is used specifically as the &quot;seed sequence&quot;
when generating the curves.
</p>
<p><code>sfc_unit</code> class also inherits the <code>sfc_sequence</code> class but has one additionally slot: <code>corner</code>.
It is used specifically when defining the expansion rules.
</p>


<h3>Value</h3>

<p>An <code>sfc_sequence</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sfc_sequence("ABCD", rot = c(0, 90, 180, 270), universe = c("A", "B", "C", "D"))
</code></pre>

<hr>
<h2 id='sfc_shape+2Csfc_2x2-method'>Shape of the curve</h2><span id='topic+sfc_shape+2Csfc_2x2-method'></span><span id='topic+sfc_shape'></span><span id='topic+all_2x2_shapes'></span><span id='topic+sfc_shape+2Csfc_3x3_peano-method'></span><span id='topic+all_3x3_peano_shapes'></span><span id='topic+sfc_shape+2Csfc_3x3_meander-method'></span><span id='topic+all_3x3_meander_shapes'></span>

<h3>Description</h3>

<p>Shape of the curve
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'sfc_2x2'
sfc_shape(p)

all_2x2_shapes(level = 2)

## S4 method for signature 'sfc_3x3_peano'
sfc_shape(p)

all_3x3_peano_shapes(level = 2)

## S4 method for signature 'sfc_3x3_meander'
sfc_shape(p)

all_3x3_meander_shapes(level = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sfc_shape+2B2Csfc_2x2-method_+3A_p">p</code></td>
<td>
<p>An <code>sfc_2x2</code> object.</p>
</td></tr>
<tr><td><code id="sfc_shape+2B2Csfc_2x2-method_+3A_level">level</code></td>
<td>
<p>Level of the 2x2 curve.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The shape of the curve is defined as a form of the curve without considering entry/exit directions, rotation,
flipping (reflection) nor reversing.
</p>


<h4>2x2 curve</h4>

<p>The process of selecting the shape segment of the curve denoted as <code>P</code> is:
</p>

<ol>
<li><p> The entry-point should locate in the bottom left subunit and the exit-point should
locate in the bottom right subunit. We try the four rotations (0, 90, 180, 270), and
the four rotations on the horizontally flipped curve. Once we find the transformed curve
that satisfies this criterion, we name it as <code>P2</code>.
</p>
</li>
<li><p> We also generate <code>P3</code> which is a horizontally flipped version of <code>rev(P2)</code>.
</p>
</li>
<li><p> We compare the first point <code>p</code> of <code>P2</code> and <code>P3</code>, and select the one whose <code>p</code> has the smaller
x-coordinate (i.e. more to the left of the curve). If the x-coordinates of <code>p</code> are the same in
<code>P2</code> and <code>P3</code>, we select the one whose <code>p</code> has the smaller y-coordinate.
</p>
</li></ol>




<h4>3x3 Peano curve</h4>

<p>The process of selecting the shape segment of the curve denoted as <code>P</code> is:
</p>

<ol>
<li><p> The entry-point should locate in the bottom left subunit and the exit-point should
locate in the top right subunit. We try the four rotations (0, 90, 180, 270). Once we find the transformed curve
that satisfies this criterion, we name it as <code>P2</code>.
</p>
</li>
<li><p> We also generate <code>P3</code> which is a 180 degrees rotation on the reversed <code>P2</code>, <code>P4</code> which is a diagonal flip with slop of 1 on <code>P2</code>
and <code>P5</code> which is a diagonal flip with slop of 1 on <code>P3</code>.
</p>
</li>
<li><p> We calculate the &quot;UID&quot; of <code>P(2-5)</code> and pick the one with the smallest UID as the final curve.
</p>
</li></ol>

<p>The UID of a 3x3 Peano curve is based on the hierarchical indices of the units on it. The hierarchy of the
Peano curve is traversed in a depth-first manner. On each node, the orientation of the corresponding unit is
calculated where vertical is 1 and horizontal is 2. The digits are concatenated into a long string.
</p>

<p><code>all_3x3_peano_shapes()</code> only calculates all shapes for Peano curve on level 2.
</p>
<p><code>all_3x3_meander_shapes()</code> only considers the Meander curve with all subunits on all levels in forward orientation.
</p>


<h3>Value</h3>

<p><code>sfc_shape()</code> returns a two-column data frame of the xy-coordinates of the shape curve.
</p>
<p><code>all_2x2_shapes()</code> returns a list of <code>n</code> two-column data frames where each data frame corresponds to
the xy-coordnates of the corresponding shape curve.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p1 = sfc_2x2("I", 11)
p2 = sfc_2x2("R", 22)
draw_multiple_curves(
    p1, p2, 
    sfc_shape(p1), sfc_shape(p2), 
    col = "black")
sl = all_2x2_shapes(2)
draw_multiple_curves(list = sl, lwd = 2, col = "black")
sl = all_2x2_shapes(3)
draw_multiple_curves(list = sl, lwd = 2, col = "black")
p = sfc_3x3_peano("I", 11)
draw_multiple_curves(
    p, sfc_dflip(p),
    sfc_shape(p), sfc_shape(sfc_dflip(p)),
    col = "black")

sl = all_3x3_peano_shapes()
length(sl)
# the first 8 shapes
draw_multiple_curves(sl[1:8], col = "black")

sl = all_3x3_meander_shapes(2)
draw_multiple_curves(list = sl, lwd = 2, col = "black")
</code></pre>

<hr>
<h2 id='sfc_universe+2Csfc_rules-method'>The universe base pattern set</h2><span id='topic+sfc_universe+2Csfc_rules-method'></span><span id='topic+sfc_universe'></span><span id='topic+sfc_universe+2Csfc_sequence-method'></span>

<h3>Description</h3>

<p>The universe base pattern set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'sfc_rules'
sfc_universe(p)

## S4 method for signature 'sfc_sequence'
sfc_universe(p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sfc_universe+2B2Csfc_rules-method_+3A_p">p</code></td>
<td>
<p>The corresponding object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of base patterns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sfc_universe(SFC_RULES_2x2)
sfc_universe(SFC_RULES_3x3_PEANO)
</code></pre>

<hr>
<h2 id='sfc_validate+2Csfc_sequence-method'>Validate the sequence</h2><span id='topic+sfc_validate+2Csfc_sequence-method'></span><span id='topic+sfc_validate'></span><span id='topic+sfc_validate+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Validate the sequence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'sfc_sequence'
sfc_validate(p, by = "sfc_2x2")

## S4 method for signature 'character'
sfc_validate(p, by = "sfc_2x2")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sfc_validate+2B2Csfc_sequence-method_+3A_p">p</code></td>
<td>
<p>An <code>sfc_sequence</code> object or a character string. If it is a character string, rotation of zero is assigned to the first letter.</p>
</td></tr>
<tr><td><code id="sfc_validate+2B2Csfc_sequence-method_+3A_by">by</code></td>
<td>
<p>One of <code>sfc_2x2</code>, <code>sfc_3x3_peano</code> and <code>sfc_3x3_meander</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is mainly used to validate a seed sequence whether they follow the forward-left-right rule.
</p>


<h3>Value</h3>

<p>A logical scalar.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>try(sfc_validate("LLLLL"))
try(sfc_validate(sfc_sequence("IIIII", rot = c(0, 90, 180, 270, 0), 
        universe = sfc_universe(SFC_RULES_2x2))))
</code></pre>

<hr>
<h2 id='show+2Csfc_base-method'>Print the object</h2><span id='topic+show+2Csfc_base-method'></span><span id='topic+show+2Csfc_nxn-method'></span><span id='topic+show+2Csfc_rules-method'></span><span id='topic+show+2Csfc_sequence-method'></span>

<h3>Description</h3>

<p>Print the object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'sfc_base'
show(object)

## S4 method for signature 'sfc_nxn'
show(object)

## S4 method for signature 'sfc_rules'
show(object)

## S4 method for signature 'sfc_sequence'
show(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="show+2B2Csfc_base-method_+3A_object">object</code></td>
<td>
<p>The corresponding object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value is returned.
</p>

<hr>
<h2 id='unit_orientation'>Flip units</h2><span id='topic+unit_orientation'></span><span id='topic+sfc_flip_unit+2Csfc_nxn-method'></span><span id='topic+sfc_flip_unit'></span><span id='topic+sfc_flip_unit+2Csfc_unit-method'></span>

<h3>Description</h3>

<p>Flip units
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unit_orientation(p, index = "")

## S4 method for signature 'sfc_nxn'
sfc_flip_unit(p, index = "", to = NULL)

## S4 method for signature 'sfc_unit'
sfc_flip_unit(p, bases)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unit_orientation_+3A_p">p</code></td>
<td>
<p>The corresponding object.</p>
</td></tr>
<tr><td><code id="unit_orientation_+3A_index">index</code></td>
<td>
<p>A string of digits representing the path on the hierarchy of the curve. The left
side corresponds to the top level and the right side corresponds to the bottom level
on the curve. For the 2x2 curve, the digits can only be 1-4, and for the Peano and
Meander curves, the digits can be 1-9. The hierarchical index should be specified in a format of <code>i1:i2:i3:...</code>
where <code>:</code> can be replaced by any non-number character. For 2x2 and 3x3 curves, <code>:</code> can be omitted and the
hierarchical index can be specified as <code>i1i2i3...</code>. See examples in <code><a href="#topic+sfc_index">sfc_index()</a></code>. The value can also
be a vector where each flipping is applied in sequence.</p>
</td></tr>
<tr><td><code id="unit_orientation_+3A_to">to</code></td>
<td>
<p>The orientation to flip to. If the specified unit already has such orientation, the function returns
the original curve.</p>
</td></tr>
<tr><td><code id="unit_orientation_+3A_bases">bases</code></td>
<td>
<p>Normally use <code><a href="#topic+BASE_LIST">BASE_LIST</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The orientation of a unit is the orientation
of the line connected by the entry-corner and exit-corner of that unit.
</p>
<p>A unit in the curve is represented as a square block (e.g. <code style="white-space: pre;">&#8288;2^k x 2^k&#8288;</code> for the 2x2 curve and <code style="white-space: pre;">&#8288;3^k x 3^k&#8288;</code> for the Peano and Meander curves, <code>k</code> between 1 and the level of the curve).
In the 2x2 curve, if an unit can be flipped, it is symmetric, thus flipping in the 2x2 curve does not change its form.
The flipping is mainly applied on the Peano curve and the Meander curves. Peano curve only allows flippings by the diagonals and the Meander
curve only allows flipping horizontally or vertically. The type of flipping is choosen automatically in the function.
</p>
<p>Currently, <code>sfc_flip_unit()</code> only works on curves with a single base pattern as the seed.
</p>


<h3>Value</h3>

<p><code>unit_orientation()</code> returns a string one of &quot;vertical&quot;, &quot;horizontal&quot;, &quot;diagonal_1&quot; and &quot;diagonal_-1&quot;.
</p>
<p><code>sfc_flip_unit</code> returns an <code>sfc_nxn</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p = sfc_3x3_meander("I", 11)
draw_multiple_curves(
    p, 
    sfc_flip_unit(p, "1"), # bottom left
    sfc_flip_unit(p, "2"), # bottom middle
    sfc_flip_unit(p, "3"), # bottom right
    nrow = 2)

p = sfc_3x3_peano("I", level = 3)
draw_multiple_curves(
    p, 
    sfc_flip_unit(p, ""),
    sfc_flip_unit(p, "2"),
    sfc_flip_unit(p, "2:1"),
    nrow = 2)

p = sfc_3x3_peano("I", level = 2)
draw_multiple_curves(p, 
    sfc_flip_unit(p, c("4", "7")),
    sfc_flip_unit(p, c("1", "2", "3", "5", "6", "8", "9")),
    nrow = 1)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
