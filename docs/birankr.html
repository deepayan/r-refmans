<!DOCTYPE html><html><head><title>Help for package birankr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {birankr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bipartite_rank'><p>Bipartite Ranks</p></a></li>
<li><a href='#br_bgrm'><p>BGRM Ranks</p></a></li>
<li><a href='#br_birank'><p>BiRanks</p></a></li>
<li><a href='#br_cohits'><p>CoHITS Ranks</p></a></li>
<li><a href='#br_hits'><p>HITS Ranks</p></a></li>
<li><a href='#pagerank'><p>Estimate PageRank</p></a></li>
<li><a href='#project_to_one_mode'><p>Create a one-mode projection of a two mode graph</p></a></li>
<li><a href='#sparsematrix_from_edgelist'><p>Convert edge list to sparse matrix</p></a></li>
<li><a href='#sparsematrix_from_matrix'><p>Convert matrix to sparse matrix</p></a></li>
<li><a href='#sparsematrix_rm_weights'><p>Remove sparse matrix edge weights</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Ranking Nodes in Bipartite and Weighted Networks</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Highly efficient functions for estimating various rank (centrality) measures of nodes in bipartite graphs (two-mode networks). Includes methods for estimating HITS, CoHITS, BGRM, and BiRank with implementation primarily inspired by He et al. (2016) &lt;<a href="https://doi.org/10.1109%2FTKDE.2016.2611584">doi:10.1109/TKDE.2016.2611584</a>&gt;. Also provides easy-to-use tools for efficiently estimating PageRank in one-mode graphs, incorporating or removing edge-weights during rank estimation, projecting two-mode graphs to one-mode, and for converting edgelists and matrices to sparseMatrix format. Best of all, the package's rank estimators can work directly with common formats of network data including edgelists (class data.frame, data.table, or tbl_df) and adjacency matrices (class matrix or dgCMatrix).</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0), Matrix, data.table</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.0.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-03-23 17:07:09 UTC; admin</td>
</tr>
<tr>
<td>Author:</td>
<td>Brian Aronson [aut, cre],
  Kai-Cheng Yang [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Brian Aronson &lt;bdaronson@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-03-23 17:30:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='bipartite_rank'>Bipartite Ranks</h2><span id='topic+bipartite_rank'></span>

<h3>Description</h3>

<p>Estimate bipartite ranks (centrality scores) of nodes from an edge list or adjacency matrix. Functions as a wrapper for estimating rank based on a number of normalizers (algorithms) including HITS, CoHITS, BGRM, and BiRank. Returns a vector of ranks or (optionally) a list containing a vector for each mode. If the provided data is an edge list, this function returns ranks ordered by the unique values in the supplied edge list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bipartite_rank(
  data,
  sender_name = NULL,
  receiver_name = NULL,
  weight_name = NULL,
  rm_weights = FALSE,
  duplicates = c("add", "remove"),
  normalizer = c("HITS", "CoHITS", "BGRM", "BiRank"),
  return_mode = c("rows", "columns", "both"),
  return_data_frame = TRUE,
  alpha = 0.85,
  beta = 0.85,
  max_iter = 200,
  tol = 1e-04,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bipartite_rank_+3A_data">data</code></td>
<td>
<p>Data to use for estimating rank. Must contain bipartite graph data, either formatted as an edge list (class data.frame, data.table, or tibble (tbl_df)) or as an adjacency matrix (class matrix or dgCMatrix).</p>
</td></tr>
<tr><td><code id="bipartite_rank_+3A_sender_name">sender_name</code></td>
<td>
<p>Name of sender column. Parameter ignored if data is an adjacency matrix. Defaults to first column of edge list.</p>
</td></tr>
<tr><td><code id="bipartite_rank_+3A_receiver_name">receiver_name</code></td>
<td>
<p>Name of sender column. Parameter ignored if data is an adjacency matrix. Defaults to the second column of edge list.</p>
</td></tr>
<tr><td><code id="bipartite_rank_+3A_weight_name">weight_name</code></td>
<td>
<p>Name of edge weights. Parameter ignored if data is an adjacency matrix. Defaults to edge weights = 1.</p>
</td></tr>
<tr><td><code id="bipartite_rank_+3A_rm_weights">rm_weights</code></td>
<td>
<p>Removes edge weights from graph object before estimating rank. Parameter ignored if data is an edge list. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="bipartite_rank_+3A_duplicates">duplicates</code></td>
<td>
<p>How to treat duplicate edges if any in data. Parameter ignored if data is an adjacency matrix. If option &quot;add&quot; is selected, duplicated edges and corresponding edge weights are collapsed via addition. Otherwise, duplicated edges are removed and only the first instance of a duplicated edge is used. Defaults to &quot;add&quot;.</p>
</td></tr>
<tr><td><code id="bipartite_rank_+3A_normalizer">normalizer</code></td>
<td>
<p>Normalizer (algorithm) used for estimating node ranks (centrality scores). Options include HITS, CoHITS, BGRM, and BiRank. Defaults to HITS.</p>
</td></tr>
<tr><td><code id="bipartite_rank_+3A_return_mode">return_mode</code></td>
<td>
<p>Mode for which to return ranks. Defaults to &quot;rows&quot; (the first column of an edge list).</p>
</td></tr>
<tr><td><code id="bipartite_rank_+3A_return_data_frame">return_data_frame</code></td>
<td>
<p>Return results as a data frame with node names in the first column and ranks in the second column. If set to FALSE, the function just returns a named vector of ranks. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="bipartite_rank_+3A_alpha">alpha</code></td>
<td>
<p>Dampening factor for first mode of data. Defaults to 0.85.</p>
</td></tr>
<tr><td><code id="bipartite_rank_+3A_beta">beta</code></td>
<td>
<p>Dampening factor for second mode of data. Defaults to 0.85.</p>
</td></tr>
<tr><td><code id="bipartite_rank_+3A_max_iter">max_iter</code></td>
<td>
<p>Maximum number of iterations to run before model fails to converge. Defaults to 200.</p>
</td></tr>
<tr><td><code id="bipartite_rank_+3A_tol">tol</code></td>
<td>
<p>Maximum tolerance of model convergence. Defaults to 1.0e-4.</p>
</td></tr>
<tr><td><code id="bipartite_rank_+3A_verbose">verbose</code></td>
<td>
<p>Show the progress of this function. Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For information about the different normalizers available in this function, see the descriptions for the HITS, CoHITS, BGRM, and BiRank functions. However, below outlines the key differences between the normalizers, with <code class="reqn">K_d</code> and <code class="reqn">K_p</code> representing diagonal matrices with generalized degrees (sum of the edge weights) on the diagonal (e.g. <code class="reqn">(K_d)_{ii} = \sum_j w_{ij}</code> and <code class="reqn">(K_p)_{jj} = \sum_i w_{ij}</code>).
</p>

<table>
<tr>
 <td style="text-align: left;">
<strong>Transition matrix</strong> </td><td style="text-align: left;"> <strong><code class="reqn">S_p</code></strong> </td><td style="text-align: left;"> <strong><code class="reqn">S_d</code></strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
--------------------- </td><td style="text-align: left;"> --------------------- </td><td style="text-align: left;"> --------------------- </td>
</tr>
<tr>
 <td style="text-align: left;">
HITS </td><td style="text-align: left;"> <code class="reqn">W^T</code> </td><td style="text-align: left;"> <code class="reqn">W</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
Co-HITS </td><td style="text-align: left;"> <code class="reqn">W^T K_d^{-1}</code> </td><td style="text-align: left;"> <code class="reqn">W K_p^{-1}</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
BGRM </td><td style="text-align: left;"> <code class="reqn">K_p^{-1} W^T K_d^{-1}</code> </td><td style="text-align: left;"> <code class="reqn">K_d^{-1} W K_p^{-1}</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
BiRank </td><td style="text-align: left;"> <code class="reqn">K_p^{-1/2} W^T K_d^{-1/2}</code> </td><td style="text-align: left;"> <code class="reqn">K_d^{-1/2} W K_p^{-1/2}</code>
</td>
</tr>

</table>



<h3>Value</h3>

<p>A dataframe containing each node name and node rank. If return_data_frame changed to FALSE or input data is classed as an adjacency matrix, returns a vector of node ranks. Does not return node ranks for isolates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#create edge list between patients and providers
    df &lt;- data.table(
      patient_id = sample(x = 1:10000, size = 10000, replace = TRUE),
      provider_id = sample(x = 1:5000, size = 10000, replace = TRUE)
    )

#estimate CoHITS ranks
    CoHITS &lt;- bipartite_rank(data = df, normalizer = "CoHITS")
</code></pre>

<hr>
<h2 id='br_bgrm'>BGRM Ranks</h2><span id='topic+br_bgrm'></span>

<h3>Description</h3>

<p>Estimate BGRM ranks of nodes from an edge list or adjacency matrix. Returns a vector of ranks or (optionally) a list containing a vector for each mode. If the provided data is an edge list, this function returns ranks ordered by the unique values in the selected mode.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>br_bgrm(
  data,
  sender_name = NULL,
  receiver_name = NULL,
  weight_name = NULL,
  rm_weights = FALSE,
  duplicates = c("add", "remove"),
  return_mode = c("rows", "columns", "both"),
  return_data_frame = TRUE,
  alpha = 0.85,
  beta = 0.85,
  max_iter = 200,
  tol = 1e-04,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="br_bgrm_+3A_data">data</code></td>
<td>
<p>Data to use for estimating BGRM. Must contain bipartite graph data, either formatted as an edge list (class data.frame, data.table, or tibble (tbl_df)) or as an adjacency matrix (class matrix or dgCMatrix).</p>
</td></tr>
<tr><td><code id="br_bgrm_+3A_sender_name">sender_name</code></td>
<td>
<p>Name of sender column. Parameter ignored if data is an adjacency matrix. Defaults to first column of edge list.</p>
</td></tr>
<tr><td><code id="br_bgrm_+3A_receiver_name">receiver_name</code></td>
<td>
<p>Name of sender column. Parameter ignored if data is an adjacency matrix. Defaults to the second column of edge list.</p>
</td></tr>
<tr><td><code id="br_bgrm_+3A_weight_name">weight_name</code></td>
<td>
<p>Name of edge weights. Parameter ignored if data is an adjacency matrix. Defaults to edge weights = 1.</p>
</td></tr>
<tr><td><code id="br_bgrm_+3A_rm_weights">rm_weights</code></td>
<td>
<p>Removes edge weights from graph object before estimating BGRM. Parameter ignored if data is an edge list. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="br_bgrm_+3A_duplicates">duplicates</code></td>
<td>
<p>How to treat duplicate edges if any in data. Parameter ignored if data is an adjacency matrix. If option &quot;add&quot; is selected, duplicated edges and corresponding edge weights are collapsed via addition. Otherwise, duplicated edges are removed and only the first instance of a duplicated edge is used. Defaults to &quot;add&quot;.</p>
</td></tr>
<tr><td><code id="br_bgrm_+3A_return_mode">return_mode</code></td>
<td>
<p>Mode for which to return BGRM ranks. Defaults to &quot;rows&quot; (the first column of an edge list).</p>
</td></tr>
<tr><td><code id="br_bgrm_+3A_return_data_frame">return_data_frame</code></td>
<td>
<p>Return results as a data frame with node names in the first column and ranks in the second column. If set to FALSE, the function just returns a named vector of ranks. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="br_bgrm_+3A_alpha">alpha</code></td>
<td>
<p>Dampening factor for first mode of data. Defaults to 0.85.</p>
</td></tr>
<tr><td><code id="br_bgrm_+3A_beta">beta</code></td>
<td>
<p>Dampening factor for second mode of data. Defaults to 0.85.</p>
</td></tr>
<tr><td><code id="br_bgrm_+3A_max_iter">max_iter</code></td>
<td>
<p>Maximum number of iterations to run before model fails to converge. Defaults to 200.</p>
</td></tr>
<tr><td><code id="br_bgrm_+3A_tol">tol</code></td>
<td>
<p>Maximum tolerance of model convergence. Defaults to 1.0e-4.</p>
</td></tr>
<tr><td><code id="br_bgrm_+3A_verbose">verbose</code></td>
<td>
<p>Show the progress of this function. Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Created by Rui et. al (2007) doi: <a href="https://doi.org/10.1145/1291233.1291378">10.1145/1291233.1291378</a>, BGRM (Bipartite Graph Reinforcement Model) was developed explicitly for use in bipartite graphs. Like every bipartite ranking algorithm in this package, BGRM simultaneously estimates ranks across each mode of the input data. BGRM primarily differs from CoHITS and HITS by symmetrically normalizing the transition matrix, both by the out-degree of the source node and the indegree of the target node.
</p>


<h3>Value</h3>

<p>A dataframe containing each node name and node rank. If return_data_frame changed to FALSE or input data is classed as an adjacency matrix, returns a vector of node ranks. Does not return node ranks for isolates.
</p>


<h3>References</h3>

<p>Xiaoguang Rui, Mingjing Li, Zhiwei Li, Wei-Ying Ma, and Nenghai Yu. &quot;Bipartite graph reinforcement model for web image annotation&quot;. In <em>Proceedings of the 15th ACM International Conference on Multimedia</em>, MM '07, pages 585-594, New York, NY, USA, 2007. ACM.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#create edge list between patients and providers
    df &lt;- data.table(
      patient_id = sample(x = 1:10000, size = 10000, replace = TRUE),
      provider_id = sample(x = 1:5000, size = 10000, replace = TRUE)
    )

#estimate BGRM ranks
    BGRM &lt;- br_bgrm(data = df)
</code></pre>

<hr>
<h2 id='br_birank'>BiRanks</h2><span id='topic+br_birank'></span>

<h3>Description</h3>

<p>Estimate BiRanks of nodes from an edge list or adjacency matrix. Returns a vector of ranks or (optionally) a list containing a vector for each mode. If the provided data is an edge list, this function returns ranks ordered by the unique values in the selected mode.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>br_birank(
  data,
  sender_name = NULL,
  receiver_name = NULL,
  weight_name = NULL,
  rm_weights = FALSE,
  duplicates = c("add", "remove"),
  return_mode = c("rows", "columns", "both"),
  return_data_frame = TRUE,
  alpha = 0.85,
  beta = 0.85,
  max_iter = 200,
  tol = 1e-04,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="br_birank_+3A_data">data</code></td>
<td>
<p>Data to use for estimating BiRank. Must contain bipartite graph data, either formatted as an edge list (class data.frame, data.table, or tibble (tbl_df)) or as an adjacency matrix (class matrix or dgCMatrix).</p>
</td></tr>
<tr><td><code id="br_birank_+3A_sender_name">sender_name</code></td>
<td>
<p>Name of sender column. Parameter ignored if data is an adjacency matrix. Defaults to first column of edge list.</p>
</td></tr>
<tr><td><code id="br_birank_+3A_receiver_name">receiver_name</code></td>
<td>
<p>Name of sender column. Parameter ignored if data is an adjacency matrix. Defaults to the second column of edge list.</p>
</td></tr>
<tr><td><code id="br_birank_+3A_weight_name">weight_name</code></td>
<td>
<p>Name of edge weights. Parameter ignored if data is an adjacency matrix. Defaults to edge weights = 1.</p>
</td></tr>
<tr><td><code id="br_birank_+3A_rm_weights">rm_weights</code></td>
<td>
<p>Removes edge weights from graph object before estimating BiRank. Parameter ignored if data is an edge list. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="br_birank_+3A_duplicates">duplicates</code></td>
<td>
<p>How to treat duplicate edges if any in data. Parameter ignored if data is an adjacency matrix. If option &quot;add&quot; is selected, duplicated edges and corresponding edge weights are collapsed via addition. Otherwise, duplicated edges are removed and only the first instance of a duplicated edge is used. Defaults to &quot;add&quot;.</p>
</td></tr>
<tr><td><code id="br_birank_+3A_return_mode">return_mode</code></td>
<td>
<p>Mode for which to return BiRank ranks. Defaults to &quot;rows&quot; (the first column of an edge list).</p>
</td></tr>
<tr><td><code id="br_birank_+3A_return_data_frame">return_data_frame</code></td>
<td>
<p>Return results as a data frame with node names in first column and ranks in the second column. If set to FALSE, the function just returns a named vector of ranks. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="br_birank_+3A_alpha">alpha</code></td>
<td>
<p>Dampening factor for first mode of data. Defaults to 0.85.</p>
</td></tr>
<tr><td><code id="br_birank_+3A_beta">beta</code></td>
<td>
<p>Dampening factor for second mode of data. Defaults to 0.85.</p>
</td></tr>
<tr><td><code id="br_birank_+3A_max_iter">max_iter</code></td>
<td>
<p>Maximum number of iterations to run before model fails to converge. Defaults to 200.</p>
</td></tr>
<tr><td><code id="br_birank_+3A_tol">tol</code></td>
<td>
<p>Maximum tolerance of model convergence. Defaults to 1.0e-4.</p>
</td></tr>
<tr><td><code id="br_birank_+3A_verbose">verbose</code></td>
<td>
<p>Show the progress of this function. Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Created by He et al. (2017) doi: <a href="https://doi.org/10.1109/TKDE.2016.2611584">10.1109/TKDE.2016.2611584</a>, BiRank is a highly generalizable algorithm that was developed explicitly for use in bipartite graphs. In fact, He et al.'s implementation of BiRank forms the basis of this package's implementation of all other bipartite ranking algorithms. Like every other bipartite ranking algorithm, BiRank simultaneously estimates ranks across each mode of the input data. BiRank's implementation is also highly similar to BGRM in that it symmetrically normalizes the transition matrix. BiRank differs from BGRM only in that it normalizes the transition matrix by the square-root outdegree of the source node and the square-root indegree of the target node.
</p>


<h3>Value</h3>

<p>A dataframe containing each node name and node rank. If return_data_frame changed to FALSE or input data is classed as an adjacency matrix, returns a vector of node ranks. Does not return node ranks for isolates.
</p>


<h3>References</h3>

<p>Xiangnan He, Ming Gao, Min-Yen Kan, and Dingxian Wang. &quot;Birank: Towards ranking on bipartite graphs&quot;. <em>IEEE Transactions on Knowledge and Data Engineering</em>, 29(1):57-71, 2016
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#create edge list between patients and providers
    df &lt;- data.table(
      patient_id = sample(x = 1:10000, size = 10000, replace = TRUE),
      provider_id = sample(x = 1:5000, size = 10000, replace = TRUE)
    )

#estimate BiRank ranks
    BiRank &lt;- br_birank(data = df)
</code></pre>

<hr>
<h2 id='br_cohits'>CoHITS Ranks</h2><span id='topic+br_cohits'></span>

<h3>Description</h3>

<p>Estimate CoHITS ranks of nodes from an edge list or adjacency matrix. Returns a vector of ranks or (optionally) a list containing a vector for each mode. If the provided data is an edge list, this function returns ranks ordered by the unique values in the selected mode.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>br_cohits(
  data,
  sender_name = NULL,
  receiver_name = NULL,
  weight_name = NULL,
  rm_weights = FALSE,
  duplicates = c("add", "remove"),
  return_mode = c("rows", "columns", "both"),
  return_data_frame = TRUE,
  alpha = 0.85,
  beta = 0.85,
  max_iter = 200,
  tol = 1e-04,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="br_cohits_+3A_data">data</code></td>
<td>
<p>Data to use for estimating CoHITS. Must contain bipartite graph data, either formatted as an edge list (class data.frame, data.table, or tibble (tbl_df)) or as an adjacency matrix (class matrix or dgCMatrix).</p>
</td></tr>
<tr><td><code id="br_cohits_+3A_sender_name">sender_name</code></td>
<td>
<p>Name of sender column. Parameter ignored if data is an adjacency matrix. Defaults to first column of edge list.</p>
</td></tr>
<tr><td><code id="br_cohits_+3A_receiver_name">receiver_name</code></td>
<td>
<p>Name of sender column. Parameter ignored if data is an adjacency matrix. Defaults to the second column of edge list.</p>
</td></tr>
<tr><td><code id="br_cohits_+3A_weight_name">weight_name</code></td>
<td>
<p>Name of edge weights. Parameter ignored if data is an adjacency matrix. Defaults to edge weights = 1.</p>
</td></tr>
<tr><td><code id="br_cohits_+3A_rm_weights">rm_weights</code></td>
<td>
<p>Removes edge weights from graph object before estimating CoHITS. Parameter ignored if data is an edge list. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="br_cohits_+3A_duplicates">duplicates</code></td>
<td>
<p>How to treat duplicate edges if any in data. Parameter ignored if data is an adjacency matrix. If option &quot;add&quot; is selected, duplicated edges and corresponding edge weights are collapsed via addition. Otherwise, duplicated edges are removed and only the first instance of a duplicated edge is used. Defaults to &quot;add&quot;.</p>
</td></tr>
<tr><td><code id="br_cohits_+3A_return_mode">return_mode</code></td>
<td>
<p>Mode for which to return CoHITS ranks. Defaults to &quot;rows&quot; (the first column of an edge list).</p>
</td></tr>
<tr><td><code id="br_cohits_+3A_return_data_frame">return_data_frame</code></td>
<td>
<p>Return results as a data frame with node names in the first column and ranks in the second column. If set to FALSE, the function just returns a named vector of ranks. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="br_cohits_+3A_alpha">alpha</code></td>
<td>
<p>Dampening factor for first mode of data. Defaults to 0.85.</p>
</td></tr>
<tr><td><code id="br_cohits_+3A_beta">beta</code></td>
<td>
<p>Dampening factor for second mode of data. Defaults to 0.85.</p>
</td></tr>
<tr><td><code id="br_cohits_+3A_max_iter">max_iter</code></td>
<td>
<p>Maximum number of iterations to run before model fails to converge. Defaults to 200.</p>
</td></tr>
<tr><td><code id="br_cohits_+3A_tol">tol</code></td>
<td>
<p>Maximum tolerance of model convergence. Defaults to 1.0e-4.</p>
</td></tr>
<tr><td><code id="br_cohits_+3A_verbose">verbose</code></td>
<td>
<p>Show the progress of this function. Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Created by Deng, Lyo, and Kind (2009) doi: <a href="https://doi.org/10.1145/1557019.1557051">10.1145/1557019.1557051</a>, CoHITS was developed explicitly for use in bipartite graphs as a way to better-incorporate content information (the &quot;Co&quot; in CoHITS) in HITS ranks. Like HITS, CoHITS is based on a markov process for simultaneously estimating ranks across each mode of the input data. CoHITS primarily differs from HITS in that it normalizes the transition matrix by the out-degree of the source nodes, leading to an interpretation more similar to that of a random walk.
</p>


<h3>Value</h3>

<p>A dataframe containing each node name and node rank. If return_data_frame changed to FALSE or input data is classed as an adjacency matrix, returns a vector of node ranks. Does not return node ranks for isolates.
</p>


<h3>References</h3>

<p>Hongbo Deng, Michael R. Lyu, and Irwin King. &quot;A generalized co-hits algorithm and its application to bipartite graphs&quot;. In <em>Proceedings of the 15th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining</em>,  KDD '09,  pages 239-248,  New York,  NY, USA, 2009. ACM.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#create edge list between patients and providers
    df &lt;- data.table(
      patient_id = sample(x = 1:10000, size = 10000, replace = TRUE),
      provider_id = sample(x = 1:5000, size = 10000, replace = TRUE)
    )

#estimate CoHITS ranks
    CoHITS &lt;- br_cohits(data = df)
</code></pre>

<hr>
<h2 id='br_hits'>HITS Ranks</h2><span id='topic+br_hits'></span>

<h3>Description</h3>

<p>Estimate HITS ranks of nodes from an edge list or adjacency matrix. Returns a vector of ranks or (optionally) a list containing a vector for each mode. If the provided data is an edge list, this function returns ranks ordered by the unique values in the selected mode.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>br_hits(
  data,
  sender_name = NULL,
  receiver_name = NULL,
  weight_name = NULL,
  rm_weights = FALSE,
  duplicates = c("add", "remove"),
  return_mode = c("rows", "columns", "both"),
  return_data_frame = TRUE,
  alpha = 0.85,
  beta = 0.85,
  max_iter = 200,
  tol = 1e-04,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="br_hits_+3A_data">data</code></td>
<td>
<p>Data to use for estimating HITS. Must contain bipartite graph data, either formatted as an edge list (class data.frame, data.table, or tibble (tbl_df)) or as an adjacency matrix (class matrix or dgCMatrix).</p>
</td></tr>
<tr><td><code id="br_hits_+3A_sender_name">sender_name</code></td>
<td>
<p>Name of sender column. Parameter ignored if data is an adjacency matrix. Defaults to first column of edge list.</p>
</td></tr>
<tr><td><code id="br_hits_+3A_receiver_name">receiver_name</code></td>
<td>
<p>Name of sender column. Parameter ignored if data is an adjacency matrix. Defaults to the second column of edge list.</p>
</td></tr>
<tr><td><code id="br_hits_+3A_weight_name">weight_name</code></td>
<td>
<p>Name of edge weights. Parameter ignored if data is an adjacency matrix. Defaults to edge weights = 1.</p>
</td></tr>
<tr><td><code id="br_hits_+3A_rm_weights">rm_weights</code></td>
<td>
<p>Removes edge weights from graph object before estimating HITS. Parameter ignored if data is an edge list. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="br_hits_+3A_duplicates">duplicates</code></td>
<td>
<p>How to treat duplicate edges if any in data. Parameter ignored if data is an adjacency matrix. If option &quot;add&quot; is selected, duplicated edges and corresponding edge weights are collapsed via addition. Otherwise, duplicated edges are removed and only the first instance of a duplicated edge is used. Defaults to &quot;add&quot;.</p>
</td></tr>
<tr><td><code id="br_hits_+3A_return_mode">return_mode</code></td>
<td>
<p>Mode for which to return HITS ranks. Defaults to &quot;rows&quot; (the first column of an edge list).</p>
</td></tr>
<tr><td><code id="br_hits_+3A_return_data_frame">return_data_frame</code></td>
<td>
<p>Return results as a data frame with node names in the first column and ranks in the second column. If set to FALSE, the function just returns a named vector of ranks. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="br_hits_+3A_alpha">alpha</code></td>
<td>
<p>Dampening factor for first mode of data. Defaults to 0.85.</p>
</td></tr>
<tr><td><code id="br_hits_+3A_beta">beta</code></td>
<td>
<p>Dampening factor for second mode of data. Defaults to 0.85.</p>
</td></tr>
<tr><td><code id="br_hits_+3A_max_iter">max_iter</code></td>
<td>
<p>Maximum number of iterations to run before model fails to converge. Defaults to 200.</p>
</td></tr>
<tr><td><code id="br_hits_+3A_tol">tol</code></td>
<td>
<p>Maximum tolerance of model convergence. Defaults to 1.0e-4.</p>
</td></tr>
<tr><td><code id="br_hits_+3A_verbose">verbose</code></td>
<td>
<p>Show the progress of this function. Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Although originally designed for estimating ranks in unipartite graphs, HITS (Hyperlink-Induced Topic Search) is also one of the earliest bipartite ranking algorithms. Created by Jon Kleinberg (2009) doi: <a href="https://doi.org/10.1145/324133.324140">10.1145/324133.324140</a> as an alternative to PageRank, HITS takes better account of the topology of bipartite networks by iteratively ranking nodes according to their role as an &quot;Authority&quot; and as a &quot;Hub&quot;. Nodes with authority have high indegree from high ranking hubs; high ranking hubs have high outdegree to nodes with high authority. This function provides a slightly expanded version of HITS that only interfaces with bipartite networks and that allows for weighted edges. In general, HITS ranks tend to be more sensitive to user query than PageRanks, but HITS is substantially less efficient in ranking large graphs. HITS is likely less preferable than the other bipartite ranking algorithms in most applications. There are a number of contexts where HITS performs poorly, such as in graphs with extreme outliers.
</p>


<h3>Value</h3>

<p>A dataframe containing each node name and node rank. If return_data_frame changed to FALSE or input data is classed as an adjacency matrix, returns a vector of node ranks. Does not return node ranks for isolates.
</p>


<h3>References</h3>

<p>Jon M. Kleinberg. &quot;Authoritative sources in a hyperlinked environment&quot;. <em>J. ACM</em>, 46(5):604-632, September 1999.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#create edge list between patients and providers
    df &lt;- data.table(
      patient_id = sample(x = 1:10000, size = 10000, replace = TRUE),
      provider_id = sample(x = 1:5000, size = 10000, replace = TRUE)
    )

#estimate HITS ranks
    HITS &lt;- br_hits(data = df)
</code></pre>

<hr>
<h2 id='pagerank'>Estimate PageRank</h2><span id='topic+pagerank'></span>

<h3>Description</h3>

<p>Estimate PageRank (centrality scores) of nodes from an edge list or adjacency matrix. If data is a bipartite graph, estimates PageRank based on a one-mode projection of the input. If the data is an edge list, returns ranks ordered by the unique values in the supplied edge list (first by unique senders, then by unique receivers).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pagerank(
  data,
  is_bipartite = TRUE,
  project_mode = c("rows", "columns"),
  sender_name = NULL,
  receiver_name = NULL,
  weight_name = NULL,
  rm_weights = FALSE,
  duplicates = c("add", "remove"),
  return_data_frame = TRUE,
  alpha = 0.85,
  max_iter = 200,
  tol = 1e-04,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pagerank_+3A_data">data</code></td>
<td>
<p>Data to use for estimating PageRank. Can contain unipartite or bipartite graph data, either formatted as an edge list (class data.frame, data.table, or tibble (tbl_df)) or as an adjacency matrix (class matrix or dgCMatrix).</p>
</td></tr>
<tr><td><code id="pagerank_+3A_is_bipartite">is_bipartite</code></td>
<td>
<p>Indicate whether input data is bipartite (rather than unipartite/one-mode). Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="pagerank_+3A_project_mode">project_mode</code></td>
<td>
<p>Mode for which to return PageRank estimates. Parameter ignored if is_bipartite = FALSE. Defaults to &quot;rows&quot; (the first column of an edge list).</p>
</td></tr>
<tr><td><code id="pagerank_+3A_sender_name">sender_name</code></td>
<td>
<p>Name of sender column. Parameter ignored if data is an adjacency matrix. Defaults to first column of edge list.</p>
</td></tr>
<tr><td><code id="pagerank_+3A_receiver_name">receiver_name</code></td>
<td>
<p>Name of sender column. Parameter ignored if data is an adjacency matrix. Defaults to the second column of edge list.</p>
</td></tr>
<tr><td><code id="pagerank_+3A_weight_name">weight_name</code></td>
<td>
<p>Name of edge weights. Parameter ignored if data is an adjacency matrix. Defaults to edge weights = 1.</p>
</td></tr>
<tr><td><code id="pagerank_+3A_rm_weights">rm_weights</code></td>
<td>
<p>Removes edge weights from graph object before estimating PageRank. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="pagerank_+3A_duplicates">duplicates</code></td>
<td>
<p>How to treat duplicate edges if any in data. Parameter ignored if data is an adjacency matrix. If option &quot;add&quot; is selected, duplicated edges and corresponding edge weights are collapsed via addition. Otherwise, duplicated edges are removed and only the first instance of a duplicated edge is used. Defaults to &quot;add&quot;.</p>
</td></tr>
<tr><td><code id="pagerank_+3A_return_data_frame">return_data_frame</code></td>
<td>
<p>Return results as a data frame with node names in the first column and ranks in the second column. If set to FALSE, the function just returns a named vector of ranks. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="pagerank_+3A_alpha">alpha</code></td>
<td>
<p>Dampening factor. Defaults to 0.85.</p>
</td></tr>
<tr><td><code id="pagerank_+3A_max_iter">max_iter</code></td>
<td>
<p>Maximum number of iterations to run before model fails to converge. Defaults to 200.</p>
</td></tr>
<tr><td><code id="pagerank_+3A_tol">tol</code></td>
<td>
<p>Maximum tolerance of model convergence. Defaults to 1.0e-4.</p>
</td></tr>
<tr><td><code id="pagerank_+3A_verbose">verbose</code></td>
<td>
<p>Show the progress of this function. Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default optional arguments are likely well-suited for most users. However, it is critical to change the is.bipartite function to FALSE when working with one mode data. In addition, when estimating PageRank in unipartite edge lists that contain nodes with outdegrees or indegrees equal to 0, it is recommended that users append self-ties to the edge list to ensure that the returned PageRank estimates are ordered intuitively.
</p>


<h3>Value</h3>

<p>A dataframe containing each node name and node rank. If return_data_frame changed to FALSE or input data is classed as an adjacency matrix, returns a vector of node ranks. Does not return node ranks for isolates.
</p>


<h3>References</h3>

<p>Lawrence Page, Sergey Brin, Rajeev Motwani, and Terry Winograd. &quot;The pagerank citation ranking: Bringing order to the web&quot;. Technical report, Stanford InfoLab, 1999
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Prepare one-mode data
    df_one_mode &lt;- data.frame(
      sender = sample(x = 1:10000, size = 10000, replace = TRUE),
      receiver = sample(x = 1:10000, size = 10000, replace = TRUE)
    )

#Add self-loops for all nodes
    unique_ids &lt;- unique(c(df_one_mode$sender, df_one_mode$receiver))
    df_one_mode &lt;- rbind(df_one_mode, data.frame(sender = unique_ids,
    receiver = unique_ids))

#Estimate PageRank in one-mode data
    PageRank &lt;- pagerank(data = df_one_mode, is_bipartite = FALSE)

#Estimate PageRank in two-mode data
    df_two_mode &lt;- data.frame(
      patient_id = sample(x = 1:10000, size = 10000, replace = TRUE),
      provider_id = sample(x = 1:5000, size = 10000, replace = TRUE)
    )
    PageRank &lt;- pagerank(data = df_two_mode)
</code></pre>

<hr>
<h2 id='project_to_one_mode'>Create a one-mode projection of a two mode graph</h2><span id='topic+project_to_one_mode'></span>

<h3>Description</h3>

<p>Create a one-mode projection of a two mode graph. Converts a rectangular matrix to a square one by taking the cross product of the input matrix. The edge weights in the resulting matrix are equal to the number of transitive ties of each node in the input matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>project_to_one_mode(adj_mat, mode = c("rows", "columns"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="project_to_one_mode_+3A_adj_mat">adj_mat</code></td>
<td>
<p>Sparse matrix of class dgCMatrix</p>
</td></tr>
<tr><td><code id="project_to_one_mode_+3A_mode">mode</code></td>
<td>
<p>Mode to return. Defaults to projecting by rows.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A double or complex matrix, with appropriate dimnames taken from x and y.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#make matrix
   my_matrix &lt;- sparseMatrix(i = c(1, 1, 2, 3, 4, 4, 5, 6, 7, 7), 
       j = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10), x = 1
   )
#project to one mode
   project_to_one_mode(adj_mat = my_matrix, mode = "rows")
</code></pre>

<hr>
<h2 id='sparsematrix_from_edgelist'>Convert edge list to sparse matrix</h2><span id='topic+sparsematrix_from_edgelist'></span>

<h3>Description</h3>

<p>Converts edge lists (class data.frame) to sparse matrices (class &quot;dgCMatrix&quot;). For unipartite edge lists that contain any nodes with outdegrees or indegrees equal to 0, it is recommended that users append self-ties to the edge list to ensure that the IDs of the rows and columns are ordered intuitively to the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparsematrix_from_edgelist(
  data,
  sender_name = NULL,
  receiver_name = NULL,
  weight_name = NULL,
  duplicates = c("add", "remove"),
  is_bipartite = T
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sparsematrix_from_edgelist_+3A_data">data</code></td>
<td>
<p>Edge list to convert to sparse matrix. Must be in edge list format and of class data.frame, data.table, or tbl_df.</p>
</td></tr>
<tr><td><code id="sparsematrix_from_edgelist_+3A_sender_name">sender_name</code></td>
<td>
<p>Name of sender column. Defaults to the first column of an edge list.</p>
</td></tr>
<tr><td><code id="sparsematrix_from_edgelist_+3A_receiver_name">receiver_name</code></td>
<td>
<p>Name of sender column. Defaults to the second column of an edge list.</p>
</td></tr>
<tr><td><code id="sparsematrix_from_edgelist_+3A_weight_name">weight_name</code></td>
<td>
<p>Name of edge weights. Defaults to edge weight = 1.</p>
</td></tr>
<tr><td><code id="sparsematrix_from_edgelist_+3A_duplicates">duplicates</code></td>
<td>
<p>How to treat duplicate edges from edge list. If option &quot;add&quot; is selected, duplicated edges and corresponding edge weights are collapsed via addition. Otherwise, duplicated edges or removed and only the first instance of a duplicated edge is used. Defaults to &quot;add&quot;.</p>
</td></tr>
<tr><td><code id="sparsematrix_from_edgelist_+3A_is_bipartite">is_bipartite</code></td>
<td>
<p>Indicate whether input data is bipartite (rather than unipartite/one-mode). Defaults to TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sparse matrix of class dgCMatrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#make edge.list
   df &lt;- data.frame(
     id1 = sample(x = 1:20, size = 100, replace = TRUE),
     id2 = sample(x = 1:10, size = 100, replace = TRUE),
     weight = sample(x = 1:10, size = 100, replace = TRUE)
   )
#convert to sparsematrix
   sparsematrix_from_edgelist(data = df)
</code></pre>

<hr>
<h2 id='sparsematrix_from_matrix'>Convert matrix to sparse matrix</h2><span id='topic+sparsematrix_from_matrix'></span>

<h3>Description</h3>

<p>Converts adjacency matrices (class &quot;matrix&quot;) to a sparse matrices (class &quot;dgCMatrix&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparsematrix_from_matrix(adj_mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sparsematrix_from_matrix_+3A_adj_mat">adj_mat</code></td>
<td>
<p>Adjacency matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sparse matrix of class dgCMatrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#make matrix
   my_matrix &lt;- rep(0, 100)
   my_matrix[c(1, 11, 22, 33, 44, 54, 65, 76, 87, 97)] &lt;- 1
   my_matrix &lt;- matrix(data = my_matrix, nrow = 10, ncol = 10)
#convert to sparsematrix
   sparsematrix_from_matrix(adj_mat = my_matrix)
</code></pre>

<hr>
<h2 id='sparsematrix_rm_weights'>Remove sparse matrix edge weights</h2><span id='topic+sparsematrix_rm_weights'></span>

<h3>Description</h3>

<p>Removes edge weights from sparse matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparsematrix_rm_weights(adj_mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sparsematrix_rm_weights_+3A_adj_mat">adj_mat</code></td>
<td>
<p>Sparse matrix of class dgCMatrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sparse matrix of class dgCMatrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#make matrix
   my_matrix &lt;- sparseMatrix(
       i = c(1, 1, 2, 3, 4, 4, 5, 6, 7, 7), 
       j = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10), 
       x = c(1, 1, 3, 1, 2, 1, 1, 1, 2, 1)
   )
#remove weights
   sparsematrix_rm_weights(my_matrix)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
