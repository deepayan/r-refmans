<!DOCTYPE html><html lang="en"><head><title>Help for package admisc</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {admisc}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#About+20the+20admisc+20package'>
<p>Adrian Dusa's Miscellaneous</p></a></li>
<li><a href='#.rda+20functions+3A+20listRDA+2C+20objRDA'><p>Load and list objects from an .rda file</p></a></li>
<li><a href='#admisc+20internal+20functions'><p>Internal Functions</p></a></li>
<li><a href='#betweenQuotes'><p>Extract information between quotes in a string</p></a></li>
<li><a href='#Brackets'><p>Extract information from a multi-value SOP/DNF expression</p></a></li>
<li><a href='#change'>
<p>Generic function to change the structure of an object, function of the (changed)</p>
parameters used to create it.</a></li>
<li><a href='#coerceMode'><p>Coerce an atomic vector to numeric or integer, if possible</p></a></li>
<li><a href='#combnk'><p>Generate all combinations of n numbers, taken k at a time</p></a></li>
<li><a href='#dimnames'><p>Set matrix row or column names</p></a></li>
<li><a href='#export'><p>Export an object to a file or a connection</p></a></li>
<li><a href='#factorize'><p>Factorize Boolean expressions</p></a></li>
<li><a href='#finvert'><p>Inverts the values of a factor</p></a></li>
<li><a href='#frelevel'><p>Modified <code>relevel()</code> function</p></a></li>
<li><a href='#getName'><p>Get the name of the object being used in a function call</p></a></li>
<li><a href='#hclr'><p>Colors from the HCL spectrum</p></a></li>
<li><a href='#inside'><p>Evaluate an Expression in a Data Environment</p></a></li>
<li><a href='#Interpret+20DNF+2FSOP+20expressions+3A+20compute+2C+20simplify+2C+20expand+2C+20translate'><p>Functions to interpret and manupulate a SOP/DNF expression</p></a></li>
<li><a href='#intersection'><p>Intersect expressions</p></a></li>
<li><a href='#Negate+20DNF+2FSOP+20expressions'><p>Negate Boolean expressions</p></a></li>
<li><a href='#Number+20equality'><p>Check difference and / or (in)equality of numbers</p></a></li>
<li><a href='#numdec'><p>Count number of decimals</p></a></li>
<li><a href='#Numeric+20testing+20and+20coercion'><p>Numeric vectors</p></a></li>
<li><a href='#overwrite'>
<p>Overwrite an object in a given environment.</p></a></li>
<li><a href='#permutations'><p>Calculates the permutations of a vector</p></a></li>
<li><a href='#recode'><p>Recode a variable</p></a></li>
<li><a href='#recreate'><p>Facilitate expression substitution</p></a></li>
<li><a href='#replaceText'><p>Replace text in a string</p></a></li>
<li><a href='#scan.clipboard'><p>Cross platform scan/write clipboard</p></a></li>
<li><a href='#Tilde+20operations'><p>Tilde operations</p></a></li>
<li><a href='#tryCatchWEM'><p>Try functions to capture warnings, errors and messages.</p></a></li>
<li><a href='#using'><p>Evaluate an expression in a data environment</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.37</td>
</tr>
<tr>
<td>Title:</td>
<td>Adrian Dusa's Miscellaneous</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>QCA (&ge; 3.7)</td>
</tr>
<tr>
<td>Description:</td>
<td>Contains functions used across packages 'DDIwR', 'QCA' and 'venn'.
    Interprets and translates, factorizes and negates SOP - Sum of Products
    expressions, for both binary and multi-value crisp sets, and extracts
    information (set names, set values) from those expressions. Other functions
    perform various other checks if possibly numeric (even if all numbers reside
    in a character vector) and coerce to numeric, or check if the numbers are
    whole. It also offers, among many others, a highly versatile recoding
    routine and some more flexible alternatives to the base functions 'with()'
    and 'within()'.
    SOP simplification functions in this package use related minimization from
    package 'QCA', which is recommended to be installed despite not being listed
    in the Imports field, due to circular dependency issues.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/dusadrian/admisc">https://github.com/dusadrian/admisc</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/dusadrian/admisc/issues">https://github.com/dusadrian/admisc/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-12-08 08:22:19 UTC; dusadrian</td>
</tr>
<tr>
<td>Author:</td>
<td>Adrian Dusa <a href="https://orcid.org/0000-0002-3525-9253"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Adrian Dusa &lt;dusa.adrian@unibuc.ro&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-12-08 09:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='About+20the+20admisc+20package'>
Adrian Dusa's Miscellaneous
</h2><span id='topic+admisc-package'></span>

<h3>Description</h3>

<p>Contains functions used across packages 'DDIwR', 'QCA' and 'venn'.
Interprets and translates, factorizes and negates SOP - Sum of Products
expressions, for both binary and multi-value crisp sets, and extracts
information (set names, set values) from those expressions. Other functions
perform various checks if possibly numeric (even if all numbers reside in a
character vector) and coerce to numeric, or check if the numbers are whole. It
also offers, among many others, a highly versatile recoding routine and some
more flexible alternatives to the base functions <code>with()</code> and
<code>within()</code>.
SOP simplification functions in this package use related minimization from
package <b><span class="pkg">QCA</span></b>, which is recommended to be installed despite not being
listed in the Imports field, due to circular dependency issues.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
    Package: </td><td style="text-align: left;"> admisc</td>
</tr>
<tr>
 <td style="text-align: left;">
    Type:    </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
    Version: </td><td style="text-align: left;"> 0.37</td>
</tr>
<tr>
 <td style="text-align: left;">
    Date:    </td><td style="text-align: left;"> 2024-12-08</td>
</tr>
<tr>
 <td style="text-align: left;">
    License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
    </td>
</tr>

</table>



<h3>Author(s)</h3>

<p><b>Authors</b>:<br />
Adrian Dusa<br />
Department of Sociology<br />
University of Bucharest<br />
<a href="mailto:dusa.adrian@unibuc.ro">dusa.adrian@unibuc.ro</a>
</p>
<p><b>Maintainer</b>:<br />
Adrian Dusa
</p>

<hr>
<h2 id='.rda+20functions+3A+20listRDA+2C+20objRDA'>Load and list objects from an .rda file</h2><span id='topic+listRDA'></span><span id='topic+objRDA'></span>

<h3>Description</h3>

<p>Utility functions to read the names and load the objects from an .rda file, into
an R list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>listRDA(.filename)

objRDA(.filename)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".rda+2B20functions+2B3A+2B20listRDA+2B2C+2B20objRDA_+3A_.filename">.filename</code></td>
<td>
<p>The path to the file where the R object is saved.</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>Files with the extension .rda are routinely created using the base function
<b><code><a href="base.html#topic+save">save</a>()</code></b>.
</p>
<p>The function <b><code>listRDA()</code></b> loads the object(s) from the .rda file into a list,
preserving the object names in the list components.
</p>
<p>The .rda file can naturally be loaded with the base <b><code><a href="base.html#topic+load">load</a>()</code></b> function,
but in doing so the containing objects will overwrite any existing objects with the same names.
</p>
<p>The function <b><code>objRDA()</code></b> returns the names of the objects from the .rda file.
</p>


<h3>Value</h3>

<p>A list, containing the objects from the loaded .rda file.
</p>


<h3>Author(s)</h3>

<p>Adrian Dusa
</p>

<hr>
<h2 id='admisc+20internal+20functions'>Internal Functions</h2><span id='topic+anyTagged'></span><span id='topic+checkMV'></span><span id='topic+checkSubset'></span><span id='topic+classify'></span><span id='topic+dashes'></span><span id='topic+doublequotes'></span><span id='topic+expandBrackets'></span><span id='topic+getInfo'></span><span id='topic+getLevels'></span><span id='topic+getMatrix'></span><span id='topic+getNonChars'></span><span id='topic+getTag'></span><span id='topic+hasTag'></span><span id='topic+makeTag'></span><span id='topic+negateLoop'></span><span id='topic+padLeft'></span><span id='topic+padRight'></span><span id='topic+padBoth'></span><span id='topic+prettyString'></span><span id='topic+prettyTable'></span><span id='topic+reload'></span><span id='topic+removeSingleStars'></span><span id='topic+splitMainComponents'></span><span id='topic+splitstr'></span><span id='topic+splitBrackets'></span><span id='topic+splitPluses'></span><span id='topic+splitProducts'></span><span id='topic+splitStars'></span><span id='topic+splitTildas'></span><span id='topic+solveBrackets'></span><span id='topic+sortExpressions'></span><span id='topic+simplifyList'></span><span id='topic+singlequotes'></span><span id='topic+spaces'></span><span id='topic+stopError'></span><span id='topic+tildae'></span><span id='topic+trimstr'></span><span id='topic+uninstall'></span><span id='topic+unload'></span><span id='topic+checkValid'></span><span id='topic+validateNames'></span><span id='topic+verify'></span><span id='topic+writePrimeimp'></span>

<h3>Description</h3>

<p>The above functions are internal in the admisc package which are not designed to
be called directly by the user.
</p>

<hr>
<h2 id='betweenQuotes'>Extract information between quotes in a string</h2><span id='topic+betweenQuotes'></span>

<h3>Description</h3>

<p>Functions to extract the between the (escaped) quotes, in a string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>betweenQuotes(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="betweenQuotes_+3A_x">x</code></td>
<td>
<p>A string.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Adrian Dusa
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- "An example of \"quoted\" text."

betweenQuotes(x)
</code></pre>

<hr>
<h2 id='Brackets'>Extract information from a multi-value SOP/DNF expression</h2><span id='topic+insideBrackets'></span><span id='topic+betweenBrackets'></span><span id='topic+outsideBrackets'></span><span id='topic+curlyBrackets'></span><span id='topic+squareBrackets'></span><span id='topic+roundBrackets'></span>

<h3>Description</h3>

<p>Functions to extract information from an expression written in SOP - sum of products form,
(or from the canonical DNF - disjunctive normal form) for multi-value causal conditions.
It extracts either the values within brackets, or the causal conditions' names outside the
brackets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>betweenBrackets(x, type = "[", invert = FALSE, regexp = NULL)
outsideBrackets(x, type = "[", regexp = NULL)
curlyBrackets(x, outside = FALSE, regexp = NULL)
squareBrackets(x, outside = FALSE, regexp = NULL)
roundBrackets(x, outside = FALSE, regexp = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Brackets_+3A_x">x</code></td>
<td>
<p>A DNF/SOP expression.</p>
</td></tr>
<tr><td><code id="Brackets_+3A_type">type</code></td>
<td>
<p>Brackets type: curly, round or square.</p>
</td></tr>
<tr><td><code id="Brackets_+3A_invert">invert</code></td>
<td>
<p>Logical, if activated returns whatever is not within the brackets.</p>
</td></tr>
<tr><td><code id="Brackets_+3A_outside">outside</code></td>
<td>
<p>Logical, if activated returns the conditions' names outside the brackets.</p>
</td></tr>
<tr><td><code id="Brackets_+3A_regexp">regexp</code></td>
<td>
<p>Optional regular expression to extract information with.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Expressions written in SOP - sum of products are used in Boolean logic, signaling a
disjunction of conjunctions.
</p>
<p>These expressions are useful in Qualitative Comparative Analysis, a social science methodology
that is employed in the context of searching for causal configurations that are associated
with a certain outcome.
</p>
<p>They are also used to draw Venn diagrams with the package <b><code>venn</code></b>, which draws any
kind of set intersection (conjunction) based on a custom SOP expression.
</p>
<p>The functions <b><code>curlyBrackets</code></b>, <b><code>squareBrackets</code></b> and
<b><code>roundBrackets</code></b> are just special cases of the functions <b><code>betweenBrackets</code></b>
and <b><code>outsideBrackets</code></b>, using the argument <b><code>type</code></b> as either
<code>"{"</code>, <code>"["</code>  or <code>"("</code>.
</p>
<p>The function <b><code>outsideBrackets</code></b> itself can be considered a special case of the
function <b><code>betweenBrackets</code></b>, when it uses the argument <b><code>invert = TRUE</code></b>.
</p>
<p>SOP expressions are usually written using curly brackets for multi-value conditions but to allow
the evaluation of unquoted expressions, they first needs to get past R's internal parsing system.
For this reason, multi-value conditions in unquoted expresions should use the square brackets
notation, and conjunctions should always use the product <code>*</code> sign.
</p>
<p>Sufficiency is recognized as <code>"=&gt;"</code> in quoted expressions but this does not pass over R's
parsing system in unquoted expressions. To overcome this problem, it is best to use the single
arrow <code>"-&gt;"</code> notation. Necessity is recognized as either <code>"&lt;="</code> or <code>"&lt;-"</code>, both
being valid in quoted and unquoted expressions.
</p>


<h3>Author(s)</h3>

<p>Adrian Dusa
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sop &lt;- "A[1] + B[2]*C[0]"

betweenBrackets(sop) # 1, 2, 0

betweenBrackets(sop, invert = TRUE) # A, B, C

# unquoted (valid) SOP expressions are allowed, same result
betweenBrackets(A[1] + B[2]*C[0]) # the default type is "["

# curly brackets are also valid in quoted expressions
betweenBrackets("A{1} + B{2}*C{0}", type = "{")

# or
curlyBrackets("A{1} + B{2}*C{0}")

# and the condition names
curlyBrackets("A{1} + B{2}*C{0}", outside = TRUE)

squareBrackets(A[1] + B[2]*C[0]) # 1, 2, 0

squareBrackets(A[1] + B[2]*C[0], outside = TRUE) # A, B, C
</code></pre>

<hr>
<h2 id='change'>
Generic function to change the structure of an object, function of the (changed)
parameters used to create it.
</h2><span id='topic+change'></span>

<h3>Description</h3>

<p>A generic function that applies different altering methods for different types
of objects (of certain classes).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>change(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="change_+3A_x">x</code></td>
<td>
<p>An object of a particular class.</p>
</td></tr>
<tr><td><code id="change_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to a specific method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the time being, this function is designed to change truth table objects (only).
Future versions will likely add class methods for different other objects.
</p>


<h3>Value</h3>

<p>The changed object.
</p>


<h3>Author(s)</h3>

<p>Adrian Dusa
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# An example to change a QCA truth table
library(QCA)

ttLF &lt;- truthTable(LF, outcome = SURV, incl.cut = 0.8)
minimize(ttLF, include = "?")

# excluding contradictory simplifying assumptions
minimize(
    change(ttLF, exclude = findRows(type = 2)),
    include = "?"
)

## End(Not run)
</code></pre>

<hr>
<h2 id='coerceMode'>Coerce an atomic vector to numeric or integer, if possible</h2><span id='topic+coerceMode'></span>

<h3>Description</h3>

<p>This function verifies if an R vector is possibly numeric, and further if the
numbers inside are whole numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coerceMode(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coerceMode_+3A_x">x</code></td>
<td>
<p>An atomic R vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R vector of coerced mode.
</p>


<h3>Author(s)</h3>

<p>Adrian Dusa
</p>


<h3>Examples</h3>

<pre><code class='language-R'>obj &lt;- c("1.0", 2:5)

is.integer(coerceMode(obj))
</code></pre>

<hr>
<h2 id='combnk'>Generate all combinations of n numbers, taken k at a time</h2><span id='topic+combnk'></span>

<h3>Description</h3>

<p>A fast function to generate all possible combinations of n numbers, taken k at a time,
starting from the first k numbers or starting from a combination that contain a
certain number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combnk(n, k, ogte = 0, zerobased = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="combnk_+3A_n">n</code></td>
<td>
<p>Vector of any kind, or a numerical scalar.</p>
</td></tr>
<tr><td><code id="combnk_+3A_k">k</code></td>
<td>
<p>Numeric scalar.</p>
</td></tr>
<tr><td><code id="combnk_+3A_ogte">ogte</code></td>
<td>
<p>At least one value greater than or equal to this number.</p>
</td></tr>
<tr><td><code id="combnk_+3A_zerobased">zerobased</code></td>
<td>
<p>Logical, zero or one based.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When a scalar, argument <code>n</code> should be numeric, otherwise when a vector its
length should not be less than <code>k</code>.
</p>
<p>When the argument <b><code>ogte</code></b> is specified, the combinations will sequentially
be incremented from those which contain a certain number, or a certain position from
<code>n</code> when specified as a vector.
</p>


<h3>Value</h3>

<p>A matrix with <code>k</code> rows and <code>choose(n, k)</code> columns.
</p>


<h3>Author(s)</h3>

<p>Adrian Dusa
</p>


<h3>Examples</h3>

<pre><code class='language-R'>combnk(5, 2)

combnk(5, 2, ogte = 3)

combnk(letters[1:5], 2)
</code></pre>

<hr>
<h2 id='dimnames'>Set matrix row or column names</h2><span id='topic+setColnames'></span><span id='topic+setRownames'></span><span id='topic+setDimnames'></span>

<h3>Description</h3>

<p>Set matrix row or column names without copying, especially useful for (very)
large matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setColnames(matrix, colnames)
setRownames(matrix, rownames)
setDimnames(matrix, nameslist)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dimnames_+3A_matrix">matrix</code></td>
<td>
<p>An R matrix</p>
</td></tr>
<tr><td><code id="dimnames_+3A_colnames">colnames</code></td>
<td>
<p>Character vector of column names</p>
</td></tr>
<tr><td><code id="dimnames_+3A_rownames">rownames</code></td>
<td>
<p>Character vector of row names</p>
</td></tr>
<tr><td><code id="dimnames_+3A_nameslist">nameslist</code></td>
<td>
<p>A two-component list containing rownames and colnames</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Adrian Dusa
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mat &lt;- matrix(1:9, nrow = 3)
setDimnames(mat, list(LETTERS[1:3], letters[1:3]))
</code></pre>

<hr>
<h2 id='export'>Export an object to a file or a connection</h2><span id='topic+export'></span>

<h3>Description</h3>

<p>This is a generic function, usually a wrapper to <b><code><a href="utils.html#topic+write.table">write.table</a>()</code></b>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export(what, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="export_+3A_what">what</code></td>
<td>
<p>The object to be written (matrix or dataframe)</p>
</td></tr>
<tr><td><code id="export_+3A_...">...</code></td>
<td>
<p>Specific arguments to class functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default convention for <b><code><a href="utils.html#topic+write.table">write.table</a>()</code></b> is to add a blank column
name for the row names, but (despite it is a standard used for CSV files) that doesn't work
with all spreadsheets or other programs that attempt to import the result of
<b><code><a href="utils.html#topic+write.table">write.table</a>()</code></b>.
</p>
<p>This function acts as if <b><code><a href="utils.html#topic+write.table">write.table</a>()</code></b> was called, with only one
difference: if row names are present in the dataframe (i.e. any of them should be different
from the default row numbers), the final result will display a new column called
<b><code>cases</code></b> in the first position, except the situation that another column called
<b><code>cases</code></b> already exists in the data, when the row names will be completely ignored.
</p>
<p>If not otherwise specified, an argument <b><code>sep = ","</code></b> is added by default.
</p>
<p>The argument <b><code>row.names</code></b> is always set to FALSE, a new column being added anyways (if possible).
</p>
<p>Since this function pipes everything to <b><code><a href="utils.html#topic+write.table">write.table</a>()</code></b>, the argument <b><code>file</code></b>
can also be a connection open for writing, and <b><code>""</code></b> indicates output to the console.
</p>


<h3>Author(s)</h3>

<p>Adrian Dusa
</p>


<h3>See Also</h3>

<p>The &ldquo;R Data Import/Export&rdquo; manual.
</p>
<p><code><a href="utils.html#topic+write.table">write.table</a></code>
</p>

<hr>
<h2 id='factorize'>Factorize Boolean expressions</h2><span id='topic+factorize'></span>

<h3>Description</h3>

<p>This function finds all combinations of common factors in a Boolean expression
written in SOP - sum of products. It makes use of the function
<b><code><a href="#topic+simplify">simplify</a>()</code></b>, which uses the function
<b><code><a href="QCA.html#topic+minimize">minimize</a>()</code></b> from package <b><span class="pkg">QCA</span></b>). Users are
highly encouraged to install and load that package, despite not being present
in the Imports field (due to circular dependency issues).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>factorize(input, snames = "", noflevels = NULL, pos = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="factorize_+3A_input">input</code></td>
<td>
<p>A string representing a SOP expression, or a minimization
object of class <code>"qca"</code>.</p>
</td></tr>
<tr><td><code id="factorize_+3A_snames">snames</code></td>
<td>
<p>A string containing the sets' names, separated by commas.</p>
</td></tr>
<tr><td><code id="factorize_+3A_noflevels">noflevels</code></td>
<td>
<p>Numerical vector containing the number of levels for each set.</p>
</td></tr>
<tr><td><code id="factorize_+3A_pos">pos</code></td>
<td>
<p>Logical, if possible factorize using product(s) of sums.</p>
</td></tr>
<tr><td><code id="factorize_+3A_...">...</code></td>
<td>
<p>Other arguments (mainly for backwards compatibility).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Factorization is a process of finding common factors in a Boolean expression,
written in SOP - sum of products. Whenever possible, the factorization can also
be performed in a POS - product of sums form.
</p>
<p>Conjunctions should preferably be indicated with a star <code>*</code> sign, but this is not
necessary when conditions have single letters or when the expression is expressed in
multi-value notation.
</p>
<p>The argument <b><code>snames</code></b> is only needed when conjunctions are not indicated by
any sign, and the set names have more than one letter each (see function
<b><code><a href="#topic+translate">translate</a>()</code></b> for more details).
</p>
<p>The number of levels in <b><code>noflevels</code></b> is needed only when negating multivalue
conditions, and it should complement the <b><code>snames</code></b> argument.
</p>
<p>If <b><code>input</code></b> is an object of class <code>"qca"</code> (the result of the
function <b><code><a href="QCA.html#topic+minimize">minimize</a>()</code></b> from package <b><span class="pkg">QCA</span></b>), a
factorization is performed for each of the minimized solutions.
</p>


<h3>Value</h3>

<p>A named list, each component containing all possible factorizations of the input
expression(s), found in the name(s).
</p>


<h3>Author(s)</h3>

<p>Adrian Dusa
</p>


<h3>References</h3>

<p>Ragin, C.C. (1987) <em>The Comparative Method. Moving beyond qualitative
and quantitative strategies</em>, Berkeley: University of California Press
</p>


<h3>See Also</h3>

<p><code><a href="#topic+translate">translate</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
# typical example with redundant conditions
factorize(a~b~cd + a~bc~d + a~bcd + abc~d)

# results presented in alphabetical order
factorize(~one*two*~four + ~one*three + three*~four)

# to preserve a certain order of the set names
factorize(~one*two*~four + ~one*three + three*~four,
          snames = c(one, two, three, four))

# using pos - products of sums
factorize(~a~c + ~ad + ~b~c + ~bd, pos = TRUE)

## Not run: 
# make sure the package QCA is loaded
library(QCA)

# using an object of class "qca" produced with function minimize()
# in package QCA

pCVF &lt;- minimize(CVF, outcome = "PROTEST", incl.cut = 0.8,
                 include = "?", use.letters = TRUE)

factorize(pCVF)

# using an object of class "deMorgan" produced with negate()
factorize(negate(pCVF))

## End(Not run)

</code></pre>

<hr>
<h2 id='finvert'>Inverts the values of a factor</h2><span id='topic+finvert'></span>

<h3>Description</h3>

<p>Useful function to invert the values from a categorical variable, for instance
a Likert response scale.</p>


<h3>Usage</h3>

<pre><code class='language-R'>finvert(x, levels = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="finvert_+3A_x">x</code></td>
<td>
<p>A categorical variable (a factor)</p>
</td></tr>
<tr><td><code id="finvert_+3A_levels">levels</code></td>
<td>
<p>Logical, invert the levels as well</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A factor of the same length as the original one.</p>


<h3>Author(s)</h3>

<p>Adrian Dusa</p>


<h3>Examples</h3>

<pre><code class='language-R'>words &lt;- c("ini", "mini", "miny", "moe")
variable &lt;- factor(words, levels = words)

# inverts the value, preserving the levels
finvert(variable)

# inverts both values and levels
finvert(variable, levels = TRUE)

</code></pre>

<hr>
<h2 id='frelevel'>Modified <code>relevel()</code> function</h2><span id='topic+frelevel'></span>

<h3>Description</h3>

<p>The base function <code>relevel()</code> accepts a single argument &quot;ref&quot;, which
can only be a scalar and not a vector of values. <code>frelevel()</code> accepts
more (even all) levels and reorders them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frelevel(variable, levels)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="frelevel_+3A_variable">variable</code></td>
<td>
<p>The categorical variable of interest</p>
</td></tr>
<tr><td><code id="frelevel_+3A_levels">levels</code></td>
<td>
<p>One or more levels of the factor, in the desired order</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A factor of the same length as the initial one.</p>


<h3>Author(s)</h3>

<p>Adrian Dusa</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+relevel">relevel</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>words &lt;- c("ini", "mini", "miny", "moe")
variable &lt;- factor(words, levels = words)

# modify the order of the levels, keeping the order of the values
frelevel(variable, c("moe", "ini", "miny", "mini"))

</code></pre>

<hr>
<h2 id='getName'>Get the name of the object being used in a function call</h2><span id='topic+getName'></span>

<h3>Description</h3>

<p>This is a utility to be used inside a function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getName(x, object = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getName_+3A_x">x</code></td>
<td>
<p>String, expression to be evaluated</p>
</td></tr>
<tr><td><code id="getName_+3A_object">object</code></td>
<td>
<p>Logical, return the object's name</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Within a function, the argument <code>x</code> can be anything and it is usually
evaluated as an object.
</p>
<p>This function should be used in conjunction with the base <code>match.call()</code>,
to obtain the original name of the object being served as an input, regardless
of how it is being served.
</p>
<p>A particular use case of this function relates to the cases when a variable
within a data.frame is used. The overall name of the object (the data frame)
is irrelevant, as the real object of interest is the variable.
</p>


<h3>Value</h3>

<p>A character vector of length 1.
</p>


<h3>Author(s)</h3>

<p>Adrian Dusa
</p>


<h3>Examples</h3>

<pre><code class='language-R'>foo &lt;- function(x) {
    funargs &lt;- sapply(match.call(), deparse)[-1]
    return(getName(funargs[1]))
}

dd &lt;- data.frame(X = 1:5, Y = 1:5, Z = 1:5)

foo(dd)
# dd

foo(dd$X)
# X

foo(dd[["X"]])
# X

foo(dd[[c("X", "Y")]])
# X Y

foo(dd[, 1])
# X

foo(dd[, 2:3])
# Y Z
</code></pre>

<hr>
<h2 id='hclr'>Colors from the HCL spectrum</h2><span id='topic+hclr'></span>

<h3>Description</h3>

<p>Produces colors from the HCL (Hue Chroma Luminance) spectrum, based on the number of levels
from a factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hclr(x, starth = 25, c = 50, l = 75, alpha = 1, fixup = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hclr_+3A_x">x</code></td>
<td>
<p>Number of factor levels, or the factor itself, or a frequency distribution
from a factor</p>
</td></tr>
<tr><td><code id="hclr_+3A_starth">starth</code></td>
<td>
<p>Starting point for the hue (in the interval 0 - 360)</p>
</td></tr>
<tr><td><code id="hclr_+3A_c">c</code></td>
<td>
<p>chroma - color purity, small values produce dark and high values produce
bright colors</p>
</td></tr>
<tr><td><code id="hclr_+3A_l">l</code></td>
<td>
<p>color luminance - a number between 0 and 100</p>
</td></tr>
<tr><td><code id="hclr_+3A_alpha">alpha</code></td>
<td>
<p>color transparency, where 0 is a completely transparent color, up to 1</p>
</td></tr>
<tr><td><code id="hclr_+3A_fixup">fixup</code></td>
<td>
<p>logical, corrects the RGB values foto produce a realistic color</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Any value of <code>h</code> outside the interval 0 - 360 is constrained to this interval using
modulo values. For instance, 410 is constrained to 50 = 410
</p>


<h3>Value</h3>

<p>The RBG code for the corresponding HCL colors.
</p>


<h3>Author(s)</h3>

<p>Adrian Dusa</p>


<h3>Examples</h3>

<pre><code class='language-R'>
aa &lt;- sample(letters[1:5], 100, replace = TRUE)

hclr(aa)

# same with
hclr(5)

# or
hclr(table(aa))
</code></pre>

<hr>
<h2 id='inside'>Evaluate an Expression in a Data Environment</h2><span id='topic+inside'></span><span id='topic+inside.list'></span>

<h3>Description</h3>

<p>Evaluate an R expression in an environment constructed from data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inside(data, expr, ...)

## S3 method for class 'list'
inside(data, expr, keepAttrs = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inside_+3A_data">data</code></td>
<td>
<p>Data to use for constructing an environment a <code>data frame</code>
or a <code>list</code>.</p>
</td></tr>
<tr><td><code id="inside_+3A_expr">expr</code></td>
<td>
<p>Expression to evaluate, often a &ldquo;compound&rdquo; expression,
i.e., of the form </p>
<pre>
            {
                a &lt;- somefun()
                b &lt;- otherfun()
                .....
                rm(unused1, temp)
            }
        </pre></td></tr>
<tr><td><code id="inside_+3A_keepattrs">keepAttrs</code></td>
<td>
<p>For the <code><a href="base.html#topic+list">list</a></code> method of <code>inside()</code>,
a <code><a href="base.html#topic+logical">logical</a></code> specifying if the resulting list should keep
the <code><a href="base.html#topic+attributes">attributes</a></code> from <code>data</code> and have its
<code><a href="base.html#topic+names">names</a></code> in the same order.  Often this is unneeded as
the result is a <em>named</em> list anyway, and then <code>keepAttrs =
        FALSE</code> is more efficient.</p>
</td></tr>
<tr><td><code id="inside_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to (future) methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a modified version of the base R function <code>within))</code>, with exactly
the same arguments and functionality but only one fundamental difference:
instead of returning a modified copy of the input data, this function alters the
data directly.
</p>


<h3>Author(s)</h3>

<p>Adrian Dusa
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mt &lt;- mtcars
inside(mt, hwratio &lt;- hp/wt)

dim(mtcars)

dim(mt)
</code></pre>

<hr>
<h2 id='Interpret+20DNF+2FSOP+20expressions+3A+20compute+2C+20simplify+2C+20expand+2C+20translate'>Functions to interpret and manupulate a SOP/DNF expression</h2><span id='topic+asSOP'></span><span id='topic+compute'></span><span id='topic+expand'></span><span id='topic+mvSOP'></span><span id='topic+simplify'></span><span id='topic+sop'></span><span id='topic+translate'></span>

<h3>Description</h3>

<p>These functions interpret an expression written in sum of products (SOP) or in
canonical disjunctive normal form (DNF), for both crisp and multivalue notations.
The function <b><code>compute()</code></b> calculates set membership scores based on a
SOP expression applied to a calibrated data set (see function
<b><code><a href="QCA.html#topic+calibrate">calibrate</a>()</code></b> from package <b><span class="pkg">QCA</span></b>), while the
function <b><code>translate()</code></b> translates a  SOP expression into a matrix form.
</p>
<p>The function <b><code>simplify()</code></b> transforms a SOP expression into a simpler
equivalent, through a process of Boolean minimization. The package uses the
function <b><code><a href="QCA.html#topic+minimize">minimize</a>()</code></b> from package <b><span class="pkg">QCA</span></b>), so
users are highly encouraged to install and load that package, despite not being
present in the Imports field (due to circular dependency issues).
</p>
<p>Function <b><code>expand()</code></b> performs a Quine expansion to the complete DNF,
or a partial expansion to a SOP expression with equally complex terms.
</p>
<p>Function <b><code>asSOP()</code></b> returns a SOP expression from a POS (product of
sums) expression. This function is different from the function
<b><code>invert()</code></b>, which also negates each causal condition.
</p>
<p>Function <b><code>mvSOP()</code></b> coerces an expression from crisp set notation to
multi-value notation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asSOP(expression = "", snames = "", noflevels = NULL)

compute(expression = "", data = NULL, separate = FALSE, ...)

expand(expression = "", snames = "", noflevels = NULL, partial = FALSE,
      implicants = FALSE, ...)

mvSOP(expression = "", snames = "", data = NULL, keep.tilde = TRUE, ...)

simplify(expression = "", snames = "", noflevels = NULL, ...)

translate(expression = "", snames = "", noflevels = NULL, data = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Interpret+2B20DNF+2B2FSOP+2B20expressions+2B3A+2B20compute+2B2C+2B20simplify+2B2C+2B20expand+2B2C+2B20translate_+3A_expression">expression</code></td>
<td>
<p>String, a SOP expression.</p>
</td></tr>
<tr><td><code id="Interpret+2B20DNF+2B2FSOP+2B20expressions+2B3A+2B20compute+2B2C+2B20simplify+2B2C+2B20expand+2B2C+2B20translate_+3A_data">data</code></td>
<td>
<p>A dataset with binary cs, mv and fs data.</p>
</td></tr>
<tr><td><code id="Interpret+2B20DNF+2B2FSOP+2B20expressions+2B3A+2B20compute+2B2C+2B20simplify+2B2C+2B20expand+2B2C+2B20translate_+3A_separate">separate</code></td>
<td>
<p>Logical, perform computations on individual, separate paths.</p>
</td></tr>
<tr><td><code id="Interpret+2B20DNF+2B2FSOP+2B20expressions+2B3A+2B20compute+2B2C+2B20simplify+2B2C+2B20expand+2B2C+2B20translate_+3A_snames">snames</code></td>
<td>
<p>A string containing the sets' names, separated by commas.</p>
</td></tr>
<tr><td><code id="Interpret+2B20DNF+2B2FSOP+2B20expressions+2B3A+2B20compute+2B2C+2B20simplify+2B2C+2B20expand+2B2C+2B20translate_+3A_noflevels">noflevels</code></td>
<td>
<p>Numerical vector containing the number of levels for each set.</p>
</td></tr>
<tr><td><code id="Interpret+2B20DNF+2B2FSOP+2B20expressions+2B3A+2B20compute+2B2C+2B20simplify+2B2C+2B20expand+2B2C+2B20translate_+3A_partial">partial</code></td>
<td>
<p>Logical, perform a partial Quine expansion.</p>
</td></tr>
<tr><td><code id="Interpret+2B20DNF+2B2FSOP+2B20expressions+2B3A+2B20compute+2B2C+2B20simplify+2B2C+2B20expand+2B2C+2B20translate_+3A_implicants">implicants</code></td>
<td>
<p>Logical, return an expanded matrix in the implicants space.</p>
</td></tr>
<tr><td><code id="Interpret+2B20DNF+2B2FSOP+2B20expressions+2B3A+2B20compute+2B2C+2B20simplify+2B2C+2B20expand+2B2C+2B20translate_+3A_keep.tilde">keep.tilde</code></td>
<td>
<p>Logical, preserves the tilde sign when coercing a factor level</p>
</td></tr>
<tr><td><code id="Interpret+2B20DNF+2B2FSOP+2B20expressions+2B3A+2B20compute+2B2C+2B20simplify+2B2C+2B20expand+2B2C+2B20translate_+3A_...">...</code></td>
<td>
<p>Other arguments, mainly for backwards compatibility.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An expression written in sum of products (SOP), is a &quot;union of intersections&quot;,
for example <b><code>A*B + B*~C</code></b>. The disjunctive normal form (DNF) is also
a sum of products, with the restriction that each product has to contain all
literals. The equivalent DNF expression is: <b><code>A*B*~C + A*B*C + ~A*B*~C</code></b>
</p>
<p>The same expression can be written in multivalue notation:
<b><code>A[1]*B[1] + B[1]*C[0]</code></b>.
</p>
<p>Expressions can contain multiple values for the same condition, separated by a
comma. If B was a multivalue causal condition, an expression could be:
<b><code>A[1] + B[1,2]*C[0]</code></b>.
</p>
<p>Whether crisp or multivalue, expressions are treated as Boolean. In this last
example, all values in B equal to either 1 or 2 will be converted to 1, and the
rest of the (multi)values will be converted to 0.
</p>
<p>Negating a multivalue condition requires a known number of levels (see examples
below). Intersections between multiple levels of the same condition are possible.
For a causal condition with 3 levels (0, 1 and 2) the following expression
<b><code>~A[0,2]*A[1,2]</code></b> is equivalent with <b><code>A[1]</code></b>, while
<b><code>A[0]*A[1]</code></b> results in the empty set.
</p>
<p>The number of levels, as well as the set names can be automatically detected
from a dataset via the argument <b><code>data</code></b>. When specified, arguments
<b><code>snames</code></b> and <b><code>noflevels</code></b> have precedence over
<b><code>data</code></b>.
</p>
<p>The product operator <b><code>*</code></b> should always be used, but it can be omitted
when the data is multivalue (where product terms are separated by curly brackets),
and/or when the set names are single letters (for example <b><code>AD + B~C</code></b>),
and/or when the set names are provided via the argument <b><code>snames</code></b>.
</p>
<p>When expressions are simplified, their simplest equivalent can result in the
empty set, if the conditions cancel each other out.
</p>
<p>The function <b><code>mvSOP()</code></b> assumes binary crisp conditions in the
expression, except for categorical data used as multi-value conditions. The 
factor levels are read directly from the data, and they should be unique accross
all conditions.
</p>


<h3>Value</h3>

<p>For the function <b><code>compute()</code></b>, a vector of set membership values.
</p>
<p>For function <b><code>simplify()</code></b>, a character expression.
</p>
<p>For the function <b><code>translate()</code></b>, a matrix containing the implicants
on the rows and the set names on the columns, with the following codes:
</p>

<table>
<tr>
 <td style="text-align: right;">
     0 </td><td style="text-align: left;"> absence of a causal condition</td>
</tr>
<tr>
 <td style="text-align: right;">
     1 </td><td style="text-align: left;"> presence of a causal condition</td>
</tr>
<tr>
 <td style="text-align: right;">
    -1 </td><td style="text-align: left;"> causal condition was eliminated
</td>
</tr>

</table>

<p>The matrix was also assigned a class &quot;translate&quot;, to avoid printing the -1 codes
when signaling a minimized condition. The mode of this matrix is character, to
allow printing multiple levels in the same cell, such as &quot;1,2&quot;.
</p>
<p>For function <b><code>expand()</code></b>, a character expression or a matrix of
implicants.
</p>


<h3>Author(s)</h3>

<p>Adrian Dusa
</p>


<h3>References</h3>

<p>Ragin, C.C. (1987) <em>The Comparative Method: Moving beyond Qualitative and 
Quantitative Strategies</em>. Berkeley: University of California Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># -----
# for compute()
## Not run: 
# make sure the package QCA is loaded
library(QCA)
compute(DEV*~IND + URB*STB, data = LF)

# calculating individual paths
compute(DEV*~IND + URB*STB, data = LF, separate = TRUE)

## End(Not run)


# -----
# for simplify(), also make sure the package QCA is loaded
simplify(asSOP("(A + B)(A + ~B)")) # result is "A"

# works even without the quotes
simplify(asSOP((A + B)(A + ~B))) # result is "A"

# but to avoid confusion POS expressions are more clear when quoted
# to force a certain order of the set names
simplify("(URB + LIT*~DEV)(~LIT + ~DEV)", snames = c(DEV, URB, LIT))

# multilevel conditions can also be specified (and negated)
simplify("(A[1] + ~B[0])(B[1] + C[0])", snames = c(A, B, C), noflevels = c(2, 3, 2))


# Ragin's (1987) book presents the equation E = SG + LW as the result
# of the Boolean minimization for the ethnic political mobilization.

# intersecting the reactive ethnicity perspective (R = ~L~W)
# with the equation E (page 144)

simplify("~L~W(SG + LW)", snames = c(S, L, W, G))

# [1] "S~L~WG"


# resources for size and wealth (C = SW) with E (page 145)
simplify("SW(SG + LW)", snames = c(S, L, W, G))

# [1] "SWG + SLW"


# and factorized
factorize(simplify("SW(SG + LW)", snames = c(S, L, W, G)))

# F1: SW(G + L)


# developmental perspective (D = Lg) and E (page 146)
simplify("L~G(SG + LW)", snames = c(S, L, W, G))

# [1] "LW~G"

# subnations that exhibit ethnic political mobilization (E) but were
# not hypothesized by any of the three theories (page 147)
# ~H = ~(~L~W + SW + L~G) = GL~S + GL~W + G~SW + ~L~SW

simplify("(GL~S + GL~W + G~SW + ~L~SW)(SG + LW)", snames = c(S, L, W, G))


# -----
# for translate()
translate(A + B*C)

# same thing in multivalue notation
translate(A[1] + B[1]*C[1])

# tilde as a standard negation (note the condition "b"!)
translate(~A + b*C)

# and even for multivalue variables
# in multivalue notation, the product sign * is redundant
translate(C[1] + T[2] + T[1]*V[0] + C[0])

# negation of multivalue sets requires the number of levels
translate(~A[1] + ~B[0]*C[1], snames = c(A, B, C), noflevels = c(2, 2, 2))

# multiple values can be specified
translate(C[1] + T[1,2] + T[1]*V[0] + C[0])

# or even negated
translate(C[1] + ~T[1,2] + T[1]*V[0] + C[0], snames = c(C, T, V), noflevels = c(2,3,2))

# if the expression does not contain the product sign *
# snames are required to complete the translation 
translate(AaBb + ~CcDd, snames = c(Aa, Bb, Cc, Dd))

# to print _all_ codes from the standard output matrix
(obj &lt;- translate(A + ~B*C))
print(obj, original = TRUE) # also prints the -1 code


# -----
# for expand()
expand(~AB + B~C)

# S1: ~AB~C + ~ABC + AB~C 

expand(~AB + B~C, snames = c(A, B, C, D))

# S1: ~AB~C~D + ~AB~CD + ~ABC~D + ~ABCD + AB~C~D + AB~CD 

# In implicants form:
expand(~AB + B~C, snames = c(A, B, C, D), implicants = TRUE)

#      A B C D
# [1,] 1 2 1 1    ~AB~C~D
# [2,] 1 2 1 2    ~AB~CD
# [3,] 1 2 2 1    ~ABC~D
# [4,] 1 2 2 2    ~ABCD
# [5,] 2 2 1 1    AB~C~D
# [6,] 2 2 1 2    AB~CD

</code></pre>

<hr>
<h2 id='intersection'>Intersect expressions</h2><span id='topic+intersection'></span>

<h3>Description</h3>

<p>This function takes two or more SOP expressions (combinations of conjunctions and
disjunctions) or even entire minimization objects, and finds their intersection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intersection(..., snames = "", noflevels)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="intersection_+3A_...">...</code></td>
<td>
<p>One or more expressions, combined with / or minimization objects
of class <code>"QCA_min"</code>.</p>
</td></tr>
<tr><td><code id="intersection_+3A_snames">snames</code></td>
<td>
<p>A string containing the sets' names, separated by commas.</p>
</td></tr>
<tr><td><code id="intersection_+3A_noflevels">noflevels</code></td>
<td>
<p>Numerical vector containing the number of levels for each set.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The initial aim of this function was to provide a software implementation of the
intersection examples presented by Ragin (1987: 144-147). That type of example can also
be performed with the function <b><code>simplify()</code></b>, while this
function is now mainly used in conjunction with the <b><code><a href="QCA.html#topic+modelFit">modelFit</a>()</code></b>
function from package <b><span class="pkg">QCA</span></b>, to assess the intersection between theory and a
QCA model.
</p>
<p>Irrespective of the input type (character expressions and / or minimiation objects),
this function is now a wrapper to the main <b><code>simplify()</code></b>
function (which only accepts character expressions).
</p>
<p>It can deal with any kind of expressions, but multivalent crisp conditions need additional
information about their number of levels, via the argument <b><code>noflevels</code></b>.
</p>
<p>The expressions can be formulated in terms of either lower case - upper case notation
for the absence and the presence of the causal condition, or use the tilde notation
(see examples below). Usage of either of these is automatically detected, as long as all
expressions use the same notation.
</p>
<p>If the <b><code>snames</code></b> argument is provided, the result is sorted according to the order
of the causal conditions (set names) in the original dataset, otherwise it sorts the causal
conditions in alphabetical order.
</p>
<p>For minimzation objects of class <code>"QCA_min"</code>, the number of levels, and the set names are
automatically detected.
</p>


<h3>Author(s)</h3>

<p>Adrian Dusa
</p>


<h3>References</h3>

<p>Ragin, Charles C. 1987. <em>The Comparative Method: Moving beyond Qualitative and 
Quantitative Strategies</em>. Berkeley: University of California Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># using minimization objects
## Not run: 
library(QCA) # if not already loaded
ttLF &lt;- truthTable(LF, outcome = "SURV", incl.cut = 0.8)
pLF &lt;- minimize(ttLF, include = "?")


# for example the intersection between the parsimonious model and
# a theoretical expectation
intersection(pLF, DEV*STB)


# negating the model
intersection(negate(pLF), DEV*STB)

## End(Not run)


# -----
# in Ragin's (1987) book, the equation E = SG + LW is the result
# of the Boolean minimization for the ethnic political mobilization.

# intersecting the reactive ethnicity perspective (R = lw)
# with the equation E (page 144)
intersection(~L~W, SG + LW, snames = c(S, L, W, G))


# resources for size and wealth (C = SW) with E (page 145)
intersection(SW, SG + LW, snames = c(S, L, W, G))


# and factorized
factorize(intersection(SW, SG + LW, snames = c(S, L, W, G)))


# developmental perspective (D = L~G) and E (page 146)
intersection(L~G, SG + LW, snames = c(S, L, W, G))


# subnations that exhibit ethic political mobilization (E) but were
# not hypothesized by any of the three theories (page 147)
# ~H = ~(~L~W + SW + L~G)
intersection(negate(~L~W + SW + L~G), SG + LW, snames = c(S, L, W, G))
</code></pre>

<hr>
<h2 id='Negate+20DNF+2FSOP+20expressions'>Negate Boolean expressions</h2><span id='topic+negate'></span><span id='topic+invert'></span><span id='topic+deMorgan'></span>

<h3>Description</h3>

<p>Functions to negate a DNF/SOP expression, or to invert a SOP to a negated POS or
a POS to a negated SOP.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>negate(input, snames = "", noflevels, simplify = TRUE, ...)

invert(input, snames = "", noflevels)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Negate+2B20DNF+2B2FSOP+2B20expressions_+3A_input">input</code></td>
<td>
<p>A string representing a SOP expression, or a minimization
object of class <code>"QCA_min"</code>.</p>
</td></tr>
<tr><td><code id="Negate+2B20DNF+2B2FSOP+2B20expressions_+3A_snames">snames</code></td>
<td>
<p>A string containing the sets' names, separated by commas.</p>
</td></tr>
<tr><td><code id="Negate+2B20DNF+2B2FSOP+2B20expressions_+3A_noflevels">noflevels</code></td>
<td>
<p>Numerical vector containing the number of levels for each set.</p>
</td></tr>
<tr><td><code id="Negate+2B20DNF+2B2FSOP+2B20expressions_+3A_simplify">simplify</code></td>
<td>
<p>Logical, allow users to choose between the raw negation or
its simplest form.</p>
</td></tr>
<tr><td><code id="Negate+2B20DNF+2B2FSOP+2B20expressions_+3A_...">...</code></td>
<td>
<p>Other arguments (mainly for backwards compatibility).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In Boolean algebra, there are two transformation rules named after the British
mathematician Augustus De Morgan. These rules state that:
</p>
<p>1. The complement of the union of two sets is the intersection of their complements.
</p>
<p>2. The complement of the intersection of two sets is the union of their complements.
</p>
<p>In &quot;normal&quot; language, these would be written as:
</p>
<p>1. <code>not (A and B) = (not A) or (not B)</code>
</p>
<p>2. <code>not (A or B) = (not A) and (not B)</code>
</p>
<p>Based on these two laws, any Boolean expression written in disjunctive normal
form can be transformed into its negation.
</p>
<p>It is also possible to negate all models and solutions from the result of a
Boolean minimization from function <b><code><a href="QCA.html#topic+minimize">minimize</a>()</code></b> in
package <b><code>QCA</code></b>. The resulting object, of class <code>"qca"</code>, is
automatically recognised by this function.
</p>
<p>In a SOP expression, the products should normally be split by using a star
<b><code>*</code></b> sign, otherwise the sets' names will be considered the individual
letters in alphabetical order, unless they are specified via <b><code>snames</code></b>.
</p>
<p>To negate multilevel expressions, the argument <b><code>noflevels</code></b> is required.
</p>
<p>It is entirely possible to obtain multiple negations of a single expression, since
the result of the negation is passed to function <b><code><a href="#topic+simplify">simplify</a>()</code></b>.
</p>
<p>Function <b><code>invert</code>()</b> simply transforms an expression from a sum of
products (SOP) to a negated product of sums (POS), and the other way round.
</p>


<h3>Value</h3>

<p>A character vector when the input is a SOP expresison, or a named list for
minimization input objects, each component containing all possible negations of
the model(s).
</p>


<h3>Author(s)</h3>

<p>Adrian Dusa
</p>


<h3>References</h3>

<p>Ragin, Charles C. 1987. <em>The Comparative Method: Moving beyond Qualitative 
and Quantitative Strategies</em>. Berkeley: University of California Press.
</p>


<h3>See Also</h3>

<p><code><a href="QCA.html#topic+minimize">minimize</a></code>, <code><a href="#topic+simplify">simplify</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
# example from Ragin (1987, p.99)
negate(AC + B~C, simplify = FALSE)

# the simplified, logically equivalent negation
negate(AC + B~C)

# with different intersection operators
negate(AB*EF + ~CD*EF)

# invert to POS
invert(a*b + ~c*d)

## Not run: 
# using an object of class "qca" produced with minimize()
# from package QCA
library(QCA)
cLC &lt;- minimize(LC, outcome = SURV)

negate(cLC)


# parsimonious solution
pLC &lt;- minimize(LC, outcome = SURV, include = "?")

negate(pLC)

## End(Not run)
</code></pre>

<hr>
<h2 id='Number+20equality'>Check difference and / or (in)equality of numbers</h2><span id='topic+agtb'></span><span id='topic+altb'></span><span id='topic+agteb'></span><span id='topic+alteb'></span><span id='topic+aeqb'></span><span id='topic+aneqb'></span>

<h3>Description</h3>

<p>Check if one number is greater / lower than (or equal to) another.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>agtb(a, b, bincat)
altb(a, b, bincat)
agteb(a, b, bincat)
alteb(a, b, bincat)
aeqb(a, b, bincat)
aneqb(a, b, bincat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Number+2B20equality_+3A_a">a</code></td>
<td>
<p>Numerical vector</p>
</td></tr>
<tr><td><code id="Number+2B20equality_+3A_b">b</code></td>
<td>
<p>Numerical vector</p>
</td></tr>
<tr><td><code id="Number+2B20equality_+3A_bincat">bincat</code></td>
<td>
<p>Binary categorization values, an atomic vector of length 2</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Not all numbers (especially the decimal ones) can be represented exactly in
floating point arithmetic, and their arithmetic may not give the normal expected
result.
</p>
<p>This set of functions check for the in(equality) between two numerical vectors a
and b, with the following name convention:
</p>
<p><b><code>gt</code></b> means &ldquo;greater than&rdquo;
</p>
<p><b><code>lt</code></b> means a &ldquo;lower than&rdquo; b
</p>
<p><b><code>gte</code></b> means a &ldquo;greater than or equal to&rdquo; b
</p>
<p><b><code>lte</code></b> means a &ldquo;lower than or equal to&rdquo; b
</p>
<p><b><code>eq</code></b> means a &ldquo;equal to&rdquo; b
</p>
<p><b><code>neq</code></b> means a &ldquo;not equal to&rdquo; b
</p>
<p>The argument <b><code>values</code></b> is useful to replace the TRUE / FALSE values
with custom categories.
</p>


<h3>Author(s)</h3>

<p>Adrian Dusa
</p>


<h3>References</h3>

<p>Goldberg, David (1991) &quot;What Every Computer Scientist Should Know About
Floating-point Arithmetic&quot;, ACM Computing Surveys vol.23, no.1, pp.5-48,
<a href="https://doi.org/10.1145/103162.103163">doi:10.1145/103162.103163</a>
</p>

<hr>
<h2 id='numdec'>Count number of decimals</h2><span id='topic+numdec'></span>

<h3>Description</h3>

<p>Calculates the (maximum) number of decimals in a possibly numeric vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>numdec(x, each = FALSE, na.rm = TRUE, maxdec = 15)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="numdec_+3A_x">x</code></td>
<td>
<p>A vector of values</p>
</td></tr>
<tr><td><code id="numdec_+3A_each">each</code></td>
<td>
<p>Logical, return the result for each value in the vector</p>
</td></tr>
<tr><td><code id="numdec_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical, ignore missing values</p>
</td></tr>
<tr><td><code id="numdec_+3A_maxdec">maxdec</code></td>
<td>
<p>Maximal number of decimals to count</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Adrian Dusa
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(12, 12.3, 12.34)

numdec(x) # 2

numdec(x, each = TRUE) # 0, 1, 2

x &lt;- c("-.1", " 2.75 ", "12", "B", NA)

numdec(x) # 2

numdec(x, each = TRUE) # 1, 2, 0, NA, NA
</code></pre>

<hr>
<h2 id='Numeric+20testing+20and+20coercion'>Numeric vectors</h2><span id='topic+asNumeric'></span><span id='topic+possibleNumeric'></span><span id='topic+wholeNumeric'></span>

<h3>Description</h3>

<p>Coerces objects to class &quot;numeric&quot;, and checks if an object is numeric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asNumeric(x, ...)
possibleNumeric(x, each = FALSE)
wholeNumeric(x, each = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Numeric+2B20testing+2B20and+2B20coercion_+3A_x">x</code></td>
<td>
<p>A vector of values</p>
</td></tr>
<tr><td><code id="Numeric+2B20testing+2B20and+2B20coercion_+3A_each">each</code></td>
<td>
<p>Logical, return the result for each value in the vector</p>
</td></tr>
<tr><td><code id="Numeric+2B20testing+2B20and+2B20coercion_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed for class based methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unlike the function <b><code>as.numeric</code>()</b> from the <b><span class="pkg">base</span></b>
package, the function <b><code>asNumeric()</code></b> coerces to numeric without a
warning if any values are not numeric. All such values are considered NA missing.
</p>
<p>This is a generic function, with specific class methods for factors and objects
of class &ldquo;declared&rdquo;. The usual way of coercing factors to numeric is
meaningless, converting the inner storage numbers. The class method of this
particular function coerces the levels to numeric, via the default activated
argument <code>levels</code>.
</p>
<p>For objects of class &ldquo;declared&rdquo;, a similar argument called <code>na_values</code>
is by default activated to coerce the declared missing values to numeric.
</p>
<p>The function <b><code>possibleNumeric()</code></b> tests if the values in a vector are
possibly numeric, irrespective of their storing as character or numbers. In the
case of factors, it tests its levels representation.
</p>
<p>Function <b><code>wholeNumeric()</code></b> tests if numbers in a vector are whole
(round) numbers. Whole numbers are different from &ldquo;integer&rdquo; numbers (which
have special memory representation), and consequently the function
<b><code>is.integer</code>()</b> tests something different, how numbers are stored in
memory (see the description of function <b><code><a href="base.html#topic+double">double</a>()</code></b> for
more details).
</p>
<p>The function 
</p>


<h3>Author(s)</h3>

<p>Adrian Dusa
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+numeric">numeric</a></code>,
<code><a href="base.html#topic+integer">integer</a></code>,
<code><a href="base.html#topic+double">double</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c("-.1", " 2.7 ", "B")
asNumeric(x) # no warning

f &lt;- factor(c(3, 2, "a"))

asNumeric(f)

asNumeric(f, levels = FALSE)

possibleNumeric(x) # FALSE

possibleNumeric(x, each = TRUE) # TRUE  TRUE FALSE

possibleNumeric(c("1", 2, 3)) # TRUE

is.integer(1) # FALSE

# Signaling an integer in R 
is.integer(1L) # TRUE

wholeNumeric(1) # TRUE

wholeNumeric(c(1, 1.1), each = TRUE) # TRUE FALSE
</code></pre>

<hr>
<h2 id='overwrite'>
Overwrite an object in a given environment.
</h2><span id='topic+overwrite'></span>

<h3>Description</h3>

<p>Utility function to overwrite an object, and bypass the assignment operator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overwrite(objname, content, environment)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="overwrite_+3A_objname">objname</code></td>
<td>
<p>Character, the name of the object to overwrite.</p>
</td></tr>
<tr><td><code id="overwrite_+3A_content">content</code></td>
<td>
<p>An R object</p>
</td></tr>
<tr><td><code id="overwrite_+3A_environment">environment</code></td>
<td>
<p>The environment where to perform the overwrite procedure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function does not return anything.
</p>


<h3>Author(s)</h3>

<p>Adrian Dusa
</p>


<h3>Examples</h3>

<pre><code class='language-R'>foo &lt;- function(object, x) {
    objname &lt;- deparse(substitute(object))
    object &lt;- x
    overwrite(objname, object, parent.frame())
}


bar &lt;- 1
foo(bar, 2)

bar
# [1] 2

bar &lt;- list(A = bar)
foo(bar$A, 3)

bar
</code></pre>

<hr>
<h2 id='permutations'>Calculates the permutations of a vector</h2><span id='topic+permutations'></span>

<h3>Description</h3>

<p>Generates all possible permutations of elements from a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permutations(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="permutations_+3A_x">x</code></td>
<td>
<p>Any kind of vector.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Adrian Dusa
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
permutations(1:3)

</code></pre>

<hr>
<h2 id='recode'>Recode a variable</h2><span id='topic+recode'></span>

<h3>Description</h3>

<p>Recodes a vector (numeric, character or factor) according to a set of rules.
It is similar to the function <b><code>recode</code>()</b> from package <span class="pkg">car</span>,
but more flexible. It also has similarities with the function
<b><code><a href="base.html#topic+findInterval">findInterval</a>()</code></b> from package <b><span class="pkg">base</span></b>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recode(x, rules = NULL, cut = NULL, values = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="recode_+3A_x">x</code></td>
<td>
<p>A vector of mode numeric, character or factor.</p>
</td></tr>
<tr><td><code id="recode_+3A_rules">rules</code></td>
<td>
<p>Character string or a vector of character strings
for recoding specifications.</p>
</td></tr>
<tr><td><code id="recode_+3A_cut">cut</code></td>
<td>
<p>A vector of one or more unique cut points.</p>
</td></tr>
<tr><td><code id="recode_+3A_values">values</code></td>
<td>
<p>A vector of output values.</p>
</td></tr>
<tr><td><code id="recode_+3A_...">...</code></td>
<td>
<p>Other parameters, for compatibility with other functions such as
<b><code>recode</code>()</b> in package <span class="pkg">car</span> but also
<b><code><a href="base.html#topic+factor">factor</a>()</code></b> in package <b><span class="pkg">base</span></b></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Similar to the <b><code>recode()</code></b> function in package <span class="pkg">car</span>, the
recoding rules are separated by semicolons, of the form <b><code>input = output</code></b>,
and allow for:
</p>

<table>
<tr>
 <td style="text-align: right;">
    a single value </td><td style="text-align: left;"> <b><code>1 = 0</code></b></td>
</tr>
<tr>
 <td style="text-align: right;">
    a range of values </td><td style="text-align: left;"> <b><code>2:5 = 1</code></b></td>
</tr>
<tr>
 <td style="text-align: right;">
    a set of values </td><td style="text-align: left;"> <b><code>c(6,7,10) = 2</code></b></td>
</tr>
<tr>
 <td style="text-align: right;">
    <b><code>else</code></b> </td><td style="text-align: left;"> everything that is not covered by the previously specified rules
</td>
</tr>

</table>

<p>Contrary to the <b><code>recode</code>()</b> function in package <span class="pkg">car</span>, this
function allows the <b><code>:</code></b> sequence operator (even for factors), so
that a rule such as <b><code>c(1,3,5:7)</code></b>, or <b><code>c(a,d,f:h)</code></b> would
be valid.
</p>
<p>Actually, since all rules are specified in a string, it really doesn't matter
if the <b><code>c()</code></b> function is used or not. For compatibility reasons it
accepts it, but a more simple way to specify a set of rules is
<b><code>"1,3,5:7=A; else=B"</code></b>
</p>
<p>Special values <b><code>lo</code></b> and <b><code>hi</code></b> may also appear in the
range of values, while <b><code>else</code></b> can be used with <b><code>else=copy</code></b>
to copy all values which were not specified in the recoding rules.
</p>
<p>In the package <span class="pkg">car</span>, a character <b><code>output</code></b> would have to be quoted,
like <b><code>"1:2='A'"</code></b> but that is not mandatory in this function, <b><code>"1:2=A"</code></b>
would do just as well. Output values such as <b><code>"NA"</code></b> or <b><code>"missing"</code></b>
are converted to <b><code>NA</code></b>.
</p>
<p>Another difference from the <span class="pkg">car</span> package: the output is <b>not</b> automatically
converted to a factor even if the original variable is a factor. That option is left to the
user's decision to specify <b><code>as.factor.result</code></b>, defaulted to <b><code>FALSE</code></b>.
</p>
<p>A capital difference is the treatment of the values not present in the recoding rules. By
default, package <span class="pkg">car</span> copies all those values in the new object, whereas in this
package the default values are <b><code>NA</code></b> and new values are added only if they are
found in the rules. Users can choose to copy all other values not present in the recoding
rules, by specifically adding <b><code>else=copy</code></b> in the rules.
</p>
<p>Since the two functions have the same name, it is possible that users loading both
packages to use one instead of the other (depending which package is loaded first).
In order to preserve functionality and minimize possible namespace collisions with package
<span class="pkg">car</span>, special efforts have been invested to ensure perfect compatibility with
the other <b><code>recode</code>()</b> function (plus more).
</p>
<p>The argument <b><code>...</code></b> allows for more arguments specific to the <span class="pkg">car</span> package,
such as <b><code>as.factor.result</code></b>, <b><code>as.numeric.result</code></b>. In addition, it also
accepts <b><code>levels</code></b>, <b><code>labels</code></b> and <b><code>ordered</code></b> specific to function
<b><code><a href="base.html#topic+factor">factor</a>()</code></b> in package <b><span class="pkg">base</span></b>. When using the arguments
<b><code>levels</code></b> and / or <b><code>labels</code></b>, the output will automatically be coerced
to a factor, unless the argument <b><code>values</code></b> is used, as indicated below.
</p>
<p>Blank spaces outside category labels are ignored, see the last example.
</p>
<p>It is possible to use <b><code>recode()</code></b> in a similar way to function
<b><code>cut()</code></b>, by specifying a vector of cut points. For any number of
such <b><code>c</code></b> cut ploints, there should be <b><code>c + 1</code></b> values.
If not otherwise specified, the argument <b><code>values</code></b> is automatically
constructed as a sequence of numbers from <b><code>1</code></b> to <b><code>c + 1</code></b>.
</p>
<p>Unlike the function <b><code>cut()</code></b>, arguments such as
<b><code>include.lowest</code></b> or <b><code>right</code></b> are not necessary because
the final outcome can be changed by tweaking the cut values.
</p>
<p>If both arguments <b><code>values</code></b> and <b><code>labels</code></b> are provided,
the labels are going to be stored as an attribute.
</p>


<h3>Author(s)</h3>

<p>Adrian Dusa
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rep(1:3, 3)
#  [1] 1 2 3 1 2 3 1 2 3

recode(x, "1:2 = A; else = B")
#  [1] "A" "A" "B" "A" "A" "B" "A" "A" "B"

recode(x, "1:2 = 0; else = copy")
#  [1] 0 0 3 0 0 3 0 0 3


set.seed(1234)
x &lt;- sample(18:90, 20, replace = TRUE)
#  [1] 45 39 26 22 55 33 21 87 31 73 79 21 21 38 57 73 84 22 83 64

recode(x, cut = "35, 55")
#  [1] 2 2 1 1 2 1 1 3 1 3 3 1 1 2 3 3 3 1 3 3

set.seed(1234)
x &lt;- factor(sample(letters[1:10], 20, replace = TRUE),
          levels = letters[1:10])
#  [1] j f e i e f d b g f j f d h d d e h d h
# Levels: a b c d e f g h i j

recode(x, "b:d = 1; g:hi = 2; else = NA") # note the "hi" special value
#  [1]  2 NA NA  2 NA NA  1  1  2 NA  2 NA  1  2  1  1 NA  2  1  2

recode(x, "a, c:f = A; g:hi = B; else = C", labels = "A, B, C")
#  [1] B A A B A A A C B A B A A B A A A B A B
# Levels: A B C

recode(x, "a, c:f = 1; g:hi = 2; else = 3",
       labels = c("one", "two", "three"), ordered = TRUE)
#  [1] two   one   one   two   one   one   one   three two   one
# [11] two   one   one   two   one   one   one   two   one   two
# Levels: one &lt; two &lt; three

set.seed(1234)
categories &lt;- c("An", "example", "that has", "spaces")
x &lt;- factor(sample(categories, 20, replace = TRUE),
            levels = categories, ordered = TRUE)
sort(x)
#  [1] An       An       An       example  example  example  example
#  [8] example  example  example  example  that has that has that has
# [15] spaces   spaces   spaces   spaces   spaces   spaces
# Levels: An &lt; example &lt; that has &lt; spaces

recode(sort(x), "An : that has = 1; spaces = 2")
#  [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2

# single quotes work, but are not necessary
recode(sort(x), "An : 'that has' = 1; spaces = 2")
#  [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2

# same using cut values
recode(sort(x), cut = "that has")
#  [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2

# modifying the output values
recode(sort(x), cut = "that has", values = 0:1)
#  [1] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1

# more treatment of "else" values
x &lt;- 10:20

# recoding rules don't overlap all existing values, the rest are empty
recode(x, "8:15 = 1")
#  [1]  1  1  1  1  1  1 NA NA NA NA NA

# all other values copied
recode(x, "8:15 = 1; else = copy")
#  [1]  1  1  1  1  1  1 16 17 18 19 20

</code></pre>

<hr>
<h2 id='recreate'>Facilitate expression substitution</h2><span id='topic+recreate'></span>

<h3>Description</h3>

<p>Utility function based on <code>substitute()</code>, to recover an unquoted input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recreate(x, snames = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="recreate_+3A_x">x</code></td>
<td>
<p>A substituted input.</p>
</td></tr>
<tr><td><code id="recreate_+3A_snames">snames</code></td>
<td>
<p>A character string containing set names.</p>
</td></tr>
<tr><td><code id="recreate_+3A_...">...</code></td>
<td>
<p>Other arguments, mainly for internal use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is especially useful when users have to provide lots of quoted
inputs, such as the name of the columns from a data frame to be considered
for a particular function.
</p>
<p>This is actually one of the main uses of the base function
<b><code><a href="base.html#topic+substitute">substitute</a>()</code></b>, but here it can be employed to also
detect SOP (sum of products) expressions, explained for instance in function
<b><code><a href="#topic+translate">translate</a>()</code></b>.
</p>
<p>Such SOP expressions are usually used in contexts of sufficieny and necessity,
which are indicated with the usual signs <code>-&gt;</code> and <code>&lt;-</code>. These are
both allowed by the R parser, indicating standard assignment. Due to the R's
internal parsing system, a sufficient expression using <code>-&gt;</code> is automatically
flipped to a necessity statement <code>&lt;-</code> with reversed LHS to RHS, but this
function is able to determine what is the expression and what is the output.
</p>
<p>The other necessity code <code>&lt;=</code> is also recognized, but the equivalent
sufficiency code <code>=&gt;</code> is not allowed in unquoted expressions.
</p>


<h3>Value</h3>

<p>A quoted, equivalent expression or a substituted object.
</p>


<h3>Author(s)</h3>

<p>Adrian Dusa
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+substitute">substitute</a></code>, <code><a href="#topic+simplify">simplify</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>recreate(substitute(A + ~B*C))

foo &lt;- function(x, ...) recreate(substitute(list(...)))

foo(arg1 = 3, arg2 = A + ~B*C)

df &lt;- data.frame(A = 1, B = 2, C = 3, Y = 4)

# substitute from the global environment
# the result is the builtin C() function
res &lt;- recreate(substitute(C))

is.function(res) # TRUE

# search first within the column name space from df
recreate(substitute(C), colnames(df))
# "C"

# necessity well recognized
recreate(substitute(A &lt;- B))

# but sufficiency is flipped
recreate(substitute(A -&gt; B))

# more complex SOP expressions are still recovered
recreate(substitute(A + ~B*C -&gt; Y))
</code></pre>

<hr>
<h2 id='replaceText'>Replace text in a string</h2><span id='topic+replaceText'></span>

<h3>Description</h3>

<p>Provides an improved method to replace strings, compared to function
<b><code>gsub</code>()</b> in package <b><span class="pkg">base</span></b>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replaceText(
    expression = "", target = "", replacement = "", protect = "",
    boolean = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="replaceText_+3A_expression">expression</code></td>
<td>
<p>Character string, usually a SOP - sum of products expression.</p>
</td></tr>
<tr><td><code id="replaceText_+3A_target">target</code></td>
<td>
<p>Character vector or a string containing the text to be replaced.</p>
</td></tr>
<tr><td><code id="replaceText_+3A_replacement">replacement</code></td>
<td>
<p>Character vector or a string containing the text to replace with.</p>
</td></tr>
<tr><td><code id="replaceText_+3A_protect">protect</code></td>
<td>
<p>Character vector or a string containing the text to protect.</p>
</td></tr>
<tr><td><code id="replaceText_+3A_boolean">boolean</code></td>
<td>
<p>Treat characters in a boolean way, using upper and lower case letters.</p>
</td></tr>
<tr><td><code id="replaceText_+3A_...">...</code></td>
<td>
<p>Other arguments, from and to other functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the input expression is &quot;J*JSR&quot;, and the task is to replace &quot;J&quot; with &quot;A&quot; and &quot;JSR&quot; with
&quot;B&quot;, function <b><code>gsub</code>()</b> is not very useful since the letter &quot;J&quot; is
found in multiple places, including the second target.
</p>
<p>This function finds the exact location(s) of each target in the input string, starting with
those having the largest number of characters, making sure the locations are unique. For
instance, the target &quot;JSR&quot; is found on the location from 3 to 5, while the target &quot;J&quot; is
is found on two locations 1 and 3, but 3 was already identified in the previously found
location for the larger target.
</p>
<p>In addition, this function can also deal with target strings containing spaces.
</p>


<h3>Value</h3>

<p>The original string, replacing the target text with its replacement.
</p>


<h3>Author(s)</h3>

<p>Adrian Dusa
</p>


<h3>Examples</h3>

<pre><code class='language-R'>replaceText("J*JSR", "J, JSR", "A, B")

# same output, on input expresions containing spaces
replaceText("J*JS R", "J, JS R", "A, B")

# works even with Boolean expressions, where lower case
# letters signal the absence of the causal condition
replaceText("DEV + urb*LIT", "DEV, URB, LIT", "A, B, C", boolean = TRUE)
</code></pre>

<hr>
<h2 id='scan.clipboard'>Cross platform scan/write clipboard</h2><span id='topic+scan.clipboard'></span><span id='topic+write.clipboard'></span>

<h3>Description</h3>

<p>Functions to read and write to the system's clipboard, for copy/paste operations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scan.clipboard(...)
write.clipboard(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scan.clipboard_+3A_x">x</code></td>
<td>
<p>Object to be written to the clipboard</p>
</td></tr>
<tr><td><code id="scan.clipboard_+3A_...">...</code></td>
<td>
<p>Same arguments that are used in the base function <b><code>scan</code></b></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Adrian Dusa
</p>

<hr>
<h2 id='Tilde+20operations'>Tilde operations</h2><span id='topic+hastilde'></span><span id='topic+notilde'></span><span id='topic+tilde1st'></span>

<h3>Description</h3>

<p>Checks and changes expressions containing set negations using a tilde.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hastilde(x)
notilde(x)
tilde1st(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Tilde+2B20operations_+3A_x">x</code></td>
<td>
<p>A vector of values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Boolean expressions can be negated in various ways. For binary crisp and fuzzy sets, one of
the most straightforward ways to invert the set membership scores is to subtract them from 1.
This is both possible using R vectors and also often used to signal a negation in SOP
(sum of products) expressions. 
</p>
<p>Some other times, SOP expressions can signal a set negation (also known as the absence of a 
causal condition) by using lower case letters, while upper case letters are used to signal
the presence of a causal condition. SOP expressions also use a tilde to signal a set negation,
immediately preceding the set name.
</p>
<p>This set of functions detect when and if a set present in a SOP expression contains a tilde
(function <b><code>hastilde</code></b>), whether the entire expression begins with a tilde (function
<b><code>tilde1st</code></b>).
</p>


<h3>Author(s)</h3>

<p>Adrian Dusa
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hastilde("~A")
</code></pre>

<hr>
<h2 id='tryCatchWEM'>Try functions to capture warnings, errors and messages.</h2><span id='topic+tryCatchWEM'></span>

<h3>Description</h3>

<p>This function combines the base functions <b><code>tryCatch</code>()</b> and
<b><code>withCallingHandlers</code>()</b> for the specific purpose of capturing
not only  errors and warnings but messages as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tryCatchWEM(expr, capture = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tryCatchWEM_+3A_expr">expr</code></td>
<td>
<p>Expression to be evaluated.</p>
</td></tr>
<tr><td><code id="tryCatchWEM_+3A_capture">capture</code></td>
<td>
<p>Logical, capture the visible output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In some situations it might be important not only to test a function, but also
to capture everything that is written in the R console, be it an error, a warning
or simply a message.
</p>
<p>For instance package <b><span class="pkg">QCA</span></b> (version 3.4) has a Graphical User Interface
that simulates an R console embedded into a web based <b><span class="pkg">shiny</span></b> app.
</p>
<p>It is not intended to replace function <b><code>tryCatch</code>()</b> in any
way, especially not evaluating an expression before returning or exiting, it simply
captures everything that is printed on the console (the visible output).
</p>


<h3>Value</h3>

<p>A list, if anything would be printed on the screen, or an empty (NULL) object
otherwise.
</p>


<h3>Author(s)</h3>

<p>Adrian Dusa
</p>

<hr>
<h2 id='using'>Evaluate an expression in a data environment</h2><span id='topic+using'></span><span id='topic+using.data.frame'></span>

<h3>Description</h3>

<p>A function almost identical to the base function <code>with()</code>, but allowing
to evaluate the expression in every subset of a split file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>using(data, expr, split.by = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="using_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="using_+3A_expr">expr</code></td>
<td>
<p>Expression to evaluate</p>
</td></tr>
<tr><td><code id="using_+3A_split.by">split.by</code></td>
<td>
<p>A factor variable from the <code>data</code>, or a <code>declared</code>/<code>labelled</code> variable</p>
</td></tr>
<tr><td><code id="using_+3A_...">...</code></td>
<td>
<p>Other internal arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of results, or a matrix if each separate result is a vector.
</p>


<h3>Author(s)</h3>

<p>Adrian Dusa
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
DF &lt;- data.frame(
    Area = factor(sample(c("Rural", "Urban"), 123, replace = TRUE)),
    Gender = factor(sample(c("Female", "Male"), 123, replace = TRUE)),
    Age = sample(18:90, 123, replace = TRUE),
    Children = sample(0:5, 123, replace = TRUE)
)


# table of frequencies for Gender
table(DF$Gender)

# same with
using(DF, table(Gender))

# same, but split by Area
using(DF, table(Gender), split.by = Area)

# calculate the mean age by gender
using(DF, mean(Age), split.by = Gender)

# same, but select cases from the urban area
using(subset(DF, Area == "Urban"), mean(Age), split.by = Gender)

# mean age by gender and area
using(DF, mean(Age), split.by = Area &amp; Gender)

# same with
using(DF, mean(Age), split.by = c(Area, Gender))

# average number of children by Area
using(DF, mean(Children), split.by = Area)

# frequency tables by Area
using(DF, table(Children), split.by = Area)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
