<!DOCTYPE html><html><head><title>Help for package ebmstate</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ebmstate}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ebmstate-package'><p>Empirical Bayes multi-state Cox model</p></a></li>
<li><a href='#boot_coxrfx'><p>Bootstrap confidence intervals for regression coefficients</p></a></li>
<li><a href='#boot_ebmstate'><p>Bootstrap samples and bootstrap interval estimates</p></a></li>
<li><a href='#boot_probtrans'><p>Bootstrap confidence intervals for transition probabilities</p></a></li>
<li><a href='#CIs_for_target_state'><p>Ancillary function of <code>boot_ebmstate</code>.</p></a></li>
<li><a href='#convolute_clockforward'><p>Convolution function for clock-forward models</p></a></li>
<li><a href='#convolute_clockreset'><p>Convolution function for clock-reset models</p></a></li>
<li><a href='#CoxRFX'><p>Empirical Bayes, multi-state Cox model</p></a></li>
<li><a href='#coxrfx_object_sample'><p>Example of an empirical Bayes model fit</p></a></li>
<li><a href='#cumhaz_splines'><p>Spline approximations of the cumulative hazard functions</p></a></li>
<li><a href='#cumhazCIs_for_target_transition'><p>Ancillary function of <code>boot_ebmstate</code>.</p></a></li>
<li><a href='#extract_function'><p>Ancillary function to <code>boot_ebmstate</code>.</p></a></li>
<li><a href='#joint_cum_hazard_function'><p>Compute the cumulative hazard of leaving a given state</p></a></li>
<li><a href='#loo_ebmstate'><p>Leave-one-out estimation</p></a></li>
<li><a href='#MakeInteger'><p>Convert factor to integer.</p></a></li>
<li><a href='#msfit_generic'><p>Compute subject-specific transition hazards.</p></a></li>
<li><a href='#msfit_object_sample'><p>Estimated cumulative hazard rates under</p>
an empirical Bayes Cox model (example)</a></li>
<li><a href='#mstate_data'><p>An example of long-format multistate data</p></a></li>
<li><a href='#mstate_data_sample'><p>A simulated event-history data set</p></a></li>
<li><a href='#print.coxrfx'><p>Print method for CoxRFX objects</p></a></li>
<li><a href='#print.msfit'><p>Print method for <code>msfit</code> objects</p>
generated by <code>msfit_generic</code></a></li>
<li><a href='#probtrans_by_convolution'><p>Compute all transition probabilities from a given state</p>
using convolution</a></li>
<li><a href='#probtrans_by_convolution_clockforward'><p>Compute transition probabilities under a clock-forward model using</p>
a convolution algorithm.</a></li>
<li><a href='#probtrans_by_convolution_clockreset'><p>Compute transition probabilities under a clock-reset model using</p>
a convolution algorithm.</a></li>
<li><a href='#probtrans_ebmstate'><p>Compute subject-specific transition probabilities</p>
using convolution.</a></li>
<li><a href='#probtrans_fft'><p>Compute subject-specific transition probabilities</p>
using a convolution algorithm based on the Fast Fourier transform.</a></li>
<li><a href='#probtrans_mstate'><p>Compute subject-specific or overall transition probabilities</p></a></li>
<li><a href='#successful_transitions'><p>Find the unique possible path until an</p>
absorbing state</a></li>
<li><a href='#summary.coxrfx'><p>A summary method for CoxRFX models</p></a></li>
<li><a href='#unique_paths'><p>Find all possible paths until absorption from a given starting state</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Empirical Bayes Multi-State Cox Model</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.4</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements an empirical Bayes, multi-state Cox model for survival analysis. Run "?'ebmstate-package'" for details. See also Schall (1991) &lt;<a href="https://doi.org/10.1093%2Fbiomet%2F78.4.719">doi:10.1093/biomet/78.4.719</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0), survival (&ge; 2.44-1.1), mstate (&ge; 0.2.11)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, HDInterval, stats, utils, methods</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-02 16:42:33 UTC; RuiCosta</td>
</tr>
<tr>
<td>Author:</td>
<td>Rui Costa [aut, cre],
  Moritz Gerstung [aut],
  Terry M Therneau [ctb] (author of 'survival', a package from which code
    parts were copied),
  Thomas Lumley [ctb] (contributor to 'survival', a package from which
    code parts were copied),
  Hein Putter [ctb] (co-author of 'mstate', a package from which code
    parts were copied),
  Liesbeth de Wreede [ctb] (co-author of 'mstate', a package from which
    code parts were copied),
  Marta Fiocco [ctb] (co-author of 'mstate', a package from which code
    parts were copied),
  Ronald Geskus [ctb] (contributor to 'mstate', a package from which code
    parts were copied)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Rui Costa &lt;ruibarrigana@hotmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-04 17:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ebmstate-package'>Empirical Bayes multi-state Cox model</h2><span id='topic+ebmstate-package'></span>

<h3>Description</h3>

<p>This package implements an empirical Bayes,
multi-state Cox model. Different groups of regression
coefficients can be defined, with coefficients of the
same group sharing the same Gaussian prior. It takes
as input a data set in 'long format' and generates
estimates of relative hazards, cumulative hazard
functions and transition probabilities. It relies 
on packages <code>survival</code> and <code><a href="mstate.html#topic+mstate">mstate</a></code> 
and incorporates some
of their functions to reduce upstream dependency.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> ebmstate</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.0.73</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2020-01-21</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL 3</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Rui Costa, Moritz Gerstung
</p>

<hr>
<h2 id='boot_coxrfx'>Bootstrap confidence intervals for regression coefficients</h2><span id='topic+boot_coxrfx'></span>

<h3>Description</h3>

<p>This function computes 95% highest density bootstrap confidence intervals (non-parametric) for the regression coefficients estimated by CoxRFX.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot_coxrfx(
  mstate_data_expanded,
  which_group,
  min_nr_samples = 100,
  output = "CIs",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot_coxrfx_+3A_mstate_data_expanded">mstate_data_expanded</code></td>
<td>
<p>Data in 'long format', possibly with 'expanded' covariates (as obtained by running mstate::expand.covs).</p>
</td></tr>
<tr><td><code id="boot_coxrfx_+3A_which_group">which_group</code></td>
<td>
<p>A character vector with the same meaning as the 'groups' argument of the function <code>CoxRFX</code> but named (with the covariate names).</p>
</td></tr>
<tr><td><code id="boot_coxrfx_+3A_min_nr_samples">min_nr_samples</code></td>
<td>
<p>The confidence interval of any coefficient is based on a number of bootstrap samples at least as high as this argument. See details.</p>
</td></tr>
<tr><td><code id="boot_coxrfx_+3A_output">output</code></td>
<td>
<p>Determines the sort of output. See value.</p>
</td></tr>
<tr><td><code id="boot_coxrfx_+3A_...">...</code></td>
<td>
<p>Further arguments to the CoxRFX function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In a given bootstrap sample there might not be enough information to generate 
estimates for all coefficients. If a covariate has little or no variation in a given bootstrap sample, 
no estimate of its coefficient will be computed. The present function will
keep taking bootstrap samples until every coefficient has been estimated
at least <code>min_nr_samples</code> times.
</p>


<h3>Value</h3>

<p>For each regression coefficient, the confidence intervals and the number of bootstrap samples on which they are based, if the 'output' argument is equal to 'CIs'; if 'output' is equal to 'CIs_and_coxrfx_fits', also the <code>CoxRFX</code> objects for each bootstrap sample.
</p>


<h3>Author(s)</h3>

<p>Rui Costa
</p>

<hr>
<h2 id='boot_ebmstate'>Bootstrap samples and bootstrap interval estimates</h2><span id='topic+boot_ebmstate'></span>

<h3>Description</h3>

<p>This function computes bootstrap samples of regression coefficients,
cumulative hazard functions, and transition probability functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot_ebmstate(
  mstate_data = NULL,
  which_group = NULL,
  min_nr_samples = NULL,
  patient_data = NULL,
  initial_state = NULL,
  tmat = NULL,
  time_model = NULL,
  backup_file = NULL,
  input_file = NULL,
  coxrfx_args = NULL,
  msfit_args = NULL,
  probtrans_args = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot_ebmstate_+3A_mstate_data">mstate_data</code></td>
<td>
<p>A data frame with outcome and covariate data in long format.</p>
</td></tr>
<tr><td><code id="boot_ebmstate_+3A_which_group">which_group</code></td>
<td>
<p>A character vector with the same meaning as the 'groups' argument of the function <code>CoxRFX</code> but named (with the covariate names).</p>
</td></tr>
<tr><td><code id="boot_ebmstate_+3A_min_nr_samples">min_nr_samples</code></td>
<td>
<p>The confidence interval of any coefficient is based on a number of bootstrap samples at least as high as this argument. See details.</p>
</td></tr>
<tr><td><code id="boot_ebmstate_+3A_patient_data">patient_data</code></td>
<td>
<p>The covariate data for which the estimates of cumulative hazards and transition probabilities are computed. 
Must contain: one row of data for each transition, all the covariate columns in the fitted model, and also the 'strata' column.</p>
</td></tr>
<tr><td><code id="boot_ebmstate_+3A_initial_state">initial_state</code></td>
<td>
<p>The initial state for which transition probability estimates should be computed</p>
</td></tr>
<tr><td><code id="boot_ebmstate_+3A_tmat">tmat</code></td>
<td>
<p>Transition matrix for the multi-state model, as obtained by running <code>mstate::transMat</code></p>
</td></tr>
<tr><td><code id="boot_ebmstate_+3A_time_model">time_model</code></td>
<td>
<p>The model of time-dependency: either 'clockforward' or 'clockreset'.</p>
</td></tr>
<tr><td><code id="boot_ebmstate_+3A_backup_file">backup_file</code></td>
<td>
<p>Path to file. Objects generated while the present function is running are stored in this file. 
This avoids losing all estimates if and when the algorithm breaks down. See argument <code>input_file</code>.</p>
</td></tr>
<tr><td><code id="boot_ebmstate_+3A_input_file">input_file</code></td>
<td>
<p>Path to <code>backup_file</code> (see argument <code>backup_file</code>). If this argument is given, all other arguments should be <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="boot_ebmstate_+3A_coxrfx_args">coxrfx_args</code></td>
<td>
<p>Named list with arguments to the <code>CoxRFX</code> function other than <code>Z</code>,<code>surv</code> and <code>groups</code>.</p>
</td></tr>
<tr><td><code id="boot_ebmstate_+3A_msfit_args">msfit_args</code></td>
<td>
<p>Named list with arguments to the <code>msfit_generic.coxrfx</code> function other than <code>object</code>,<code>newdata</code> and <code>trans</code>.</p>
</td></tr>
<tr><td><code id="boot_ebmstate_+3A_probtrans_args">probtrans_args</code></td>
<td>
<p>Named list with arguments to the <code>probtrans_ebmstate</code> function other than <code>initia_state</code>,<code>cumhaz</code> and <code>model</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In a given bootstrap sample there might not be enough information to generate 
estimates for all coefficients. If a covariate has little or no variation in a given bootstrap sample, 
no estimate of its coefficient will be computed. The present function will
keep taking bootstrap samples until every coefficient has been estimated
at least <code>min_nr_samples</code> times. <code>covariate_df</code> should only contain the covariates
of the model one wishes to estimate.
</p>


<h3>Value</h3>

<p>A list with: 95% bootstrap intervals for each regression coefficient and for transition probabilities; 
bootstrap samples of regression coefficients, cumulative hazards and transition probabilities.
</p>


<h3>Author(s)</h3>

<p>Rui Costa
</p>

<hr>
<h2 id='boot_probtrans'>Bootstrap confidence intervals for transition probabilities</h2><span id='topic+boot_probtrans'></span>

<h3>Description</h3>

<p>Generates 95% highest density bootstrap interval estimates for transition probabilities computed using <code>probtrans_ebmstate</code> (clock-reset version).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot_probtrans(coxrfx_fits_boot, patient_data, tmat, initial_state, max_time)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot_probtrans_+3A_coxrfx_fits_boot">coxrfx_fits_boot</code></td>
<td>
<p>The list of CoxRFX objects obtained by running <code>boot_coxrfx</code>.</p>
</td></tr>
<tr><td><code id="boot_probtrans_+3A_patient_data">patient_data</code></td>
<td>
<p>(Single) patient data in 'long format', possibly with 'expanded' covariates
(as obtained by running <code>mstate::expand.covs</code>).</p>
</td></tr>
<tr><td><code id="boot_probtrans_+3A_tmat">tmat</code></td>
<td>
<p>Transition matrix for the multi-state model, as obtained by running <code>mstate::transMat</code></p>
</td></tr>
<tr><td><code id="boot_probtrans_+3A_initial_state">initial_state</code></td>
<td>
<p>The initial state for which transition probability estimates should be computed</p>
</td></tr>
<tr><td><code id="boot_probtrans_+3A_max_time">max_time</code></td>
<td>
<p>The maximum time for which estimates should be computed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Interval estimates for transition probabilities.
</p>


<h3>Author(s)</h3>

<p>Rui Costa
</p>


<h3>See Also</h3>

<p><code><a href="#topic+probtrans_ebmstate">probtrans_ebmstate</a></code>; <code><a href="#topic+boot_coxrfx">boot_coxrfx</a></code>; 
<code><a href="mstate.html#topic+transMat">transMat</a></code>; <code><a href="mstate.html#topic+expand.covs">expand.covs</a></code>
</p>

<hr>
<h2 id='CIs_for_target_state'>Ancillary function of <code>boot_ebmstate</code>.</h2><span id='topic+CIs_for_target_state'></span>

<h3>Description</h3>

<p>Computes 95% highest density bootstrap confidence 
intervals for the transition probabilities into <code>target_state</code>, 
given a list object with boostrap estimates of transition probabilities into multiple states. This 
function is not meant to be called by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CIs_for_target_state(target_state, probtrans_objects_boot)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CIs_for_target_state_+3A_target_state">target_state</code></td>
<td>
<p>The target state for whose transition probabilties the confidence intervals
are computed.</p>
</td></tr>
<tr><td><code id="CIs_for_target_state_+3A_probtrans_objects_boot">probtrans_objects_boot</code></td>
<td>
<p>A list containing bootstrap estimates of transition probabilities.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses function <code>extract_function</code>.
</p>


<h3>Value</h3>

<p>95% highest density bootstrap confidence intervals for the transition
probabilities into <code>target_state</code>.
</p>


<h3>Author(s)</h3>

<p>Rui Costa
</p>


<h3>See Also</h3>

<p><code><a href="#topic+boot_ebmstate">boot_ebmstate</a></code>; <code><a href="#topic+extract_function">extract_function</a></code>.
</p>

<hr>
<h2 id='convolute_clockforward'>Convolution function for clock-forward models</h2><span id='topic+convolute_clockforward'></span>

<h3>Description</h3>

<p>Internal function of 
<code>probtrans_by_convolution_clockforward</code>. It is written in C++ and is
not meant to be called
directly by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convolute_clockforward(
  time_vector,
  diff_vector,
  probtrans_vector_1,
  probtrans_vector_2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convolute_clockforward_+3A_time_vector">time_vector</code>, <code id="convolute_clockforward_+3A_diff_vector">diff_vector</code>, <code id="convolute_clockforward_+3A_probtrans_vector_1">probtrans_vector_1</code>, <code id="convolute_clockforward_+3A_probtrans_vector_2">probtrans_vector_2</code></td>
<td>
<p>Numeric vectors.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Moritz Gerstung &amp; Rui Costa
</p>


<h3>See Also</h3>

<p><code><a href="#topic+probtrans_by_convolution_clockforward">probtrans_by_convolution_clockforward</a></code>.
</p>

<hr>
<h2 id='convolute_clockreset'>Convolution function for clock-reset models</h2><span id='topic+convolute_clockreset'></span>

<h3>Description</h3>

<p>Internal function of 
<code>probtrans_by_convolution_clockreset</code>. It is written in C++
and is not meant to be called
directly by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convolute_clockreset(time_vector, integrand_1, integrand_2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convolute_clockreset_+3A_time_vector">time_vector</code>, <code id="convolute_clockreset_+3A_integrand_1">integrand_1</code>, <code id="convolute_clockreset_+3A_integrand_2">integrand_2</code></td>
<td>
<p>Numeric vectors.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Moritz Gerstung &amp; Rui Costa
</p>


<h3>See Also</h3>

<p><code><a href="#topic+probtrans_by_convolution_clockreset">probtrans_by_convolution_clockreset</a></code>.
</p>

<hr>
<h2 id='CoxRFX'>Empirical Bayes, multi-state Cox model</h2><span id='topic+CoxRFX'></span>

<h3>Description</h3>

<p>This function estimates a multi-state Cox model with one or more Gaussian priors
imposed on the regression coefficients (see Therneau et al., 2003).
Multiple groups of coefficients can be defined: coefficients within a group share 
the same (possibly unknown) mean and variance. The parameters and hyperparameters are
efficiently estimated by an EM-type algorithm built around the function
<code>survival::coxph</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CoxRFX(
  Z,
  surv,
  groups = rep(1, ncol(Z)),
  which.mu = unique(groups),
  tol = 0.001,
  max.iter = 50,
  sigma0 = 0.1,
  sigma.hat = c("df", "MLE", "REML", "BLUP"),
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CoxRFX_+3A_z">Z</code></td>
<td>
<p>A data frame consisting of the covariate columns of a data set in 'long format',
and two extra columns: one named 'trans', with
the transition that each row refers to, and 
another named 'strata', with the stratum
of each transition (transitions belonging to the same 
stratum are assumed to have the same baseline hazard
function).</p>
</td></tr>
<tr><td><code id="CoxRFX_+3A_surv">surv</code></td>
<td>
<p>A &lsquo;survival&rsquo; object created with <code>survival::Surv</code>.</p>
</td></tr>
<tr><td><code id="CoxRFX_+3A_groups">groups</code></td>
<td>
<p>A character or numeric vector whose <code class="reqn">i</code>th element gives the group of the regression
coefficient associated with the <code class="reqn">i</code>th covariate column of Z (coefficients belonging to the same group 
share the same Gaussian prior).</p>
</td></tr>
<tr><td><code id="CoxRFX_+3A_which.mu">which.mu</code></td>
<td>
<p>A vector with names or numbers of coefficient groups (see 
argument <code>groups</code>). If the name or number of a group of coefficients is
given in this argument, <code>CoxRFX</code> will estimate the mean of its Gaussian distribution;
otherwise the mean will be fixed at zero.</p>
</td></tr>
<tr><td><code id="CoxRFX_+3A_tol">tol</code></td>
<td>
<p>Convergence criterium of the EM algorithm. The algorithm stops unless
there is at least one parameter (or hyperparameter) for which it holds that the
current estimate differs in absolute terms by more than <code>tol</code> from the
previous estimate.</p>
</td></tr>
<tr><td><code id="CoxRFX_+3A_max.iter">max.iter</code></td>
<td>
<p>The maximum number of iterations in the EM algorithm.</p>
</td></tr>
<tr><td><code id="CoxRFX_+3A_sigma0">sigma0</code></td>
<td>
<p>A vector with the initial value of the variance hyperparameter for each group of coefficients.
Or a single value, in case the initial value of the variance hyperparameter is meant to be the same for all groups.</p>
</td></tr>
<tr><td><code id="CoxRFX_+3A_sigma.hat">sigma.hat</code></td>
<td>
<p>Which estimator to use for the variance hyperparameters (see details).</p>
</td></tr>
<tr><td><code id="CoxRFX_+3A_verbose">verbose</code></td>
<td>
<p>Gives more output.</p>
</td></tr>
<tr><td><code id="CoxRFX_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the function <code>survival::coxph</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Different estimators exist for the variance hyperparameters: the default is &quot;df&quot;, as used by Perperoglou (2014) and introduced by Schall (1991). 
Alternatives are MLE, REML, and BLUP, as defined by Therneau et al. (2003). 
Simulations suggest that the 'df' method is the most accurate.
</p>
<p>The model can also be fitted using package <code>coxme</code>; the <code>coxme</code>
routine numerically optimises the integrated partial likelihood, which may
be more accurate, but is computationally expensive.
</p>


<h3>Value</h3>

<p>An object of class <code>c(coxrfx,coxph.penal,coxph)</code>,
which is essentially a <code>coxph</code> object with a few extra 
fields [the inputs $groups, $Z and $surv,
and the hyperparameters $sigma2 (variances) and $mu (means)].
See <code><a href="survival.html#topic+coxph.object">survival::coxph.object</a></code>.
</p>


<h3>Author(s)</h3>

<p>Moritz Gerstung &amp; Rui Costa, extending the work of 
Terry Therneau et al. in the package <code>survival</code>.
</p>


<h3>References</h3>

<p>Terry M Therneau, Patricia M Grambsch &amp; V. Shane Pankratz (2003) Penalized Survival Models and Frailty, Journal of Computational and Graphical Statistics, 12:1, 156-175, http://dx.doi.org/10.1198/1061860031365
</p>
<p>A. Perperoglou (2014). Cox models with dynamic ridge penalties on time-varying effects of the covariates. Stat Med, 33:170-80. http://dx.doi.org/10.1002/sim.5921
</p>
<p>R. Schall (1991). Estimation in generalized linear models with random effects. Biometrika, 78:719-727. http://dx.doi.org/10.1093/biomet/78.4.719
</p>


<h3>See Also</h3>

<p>Package <code>survival</code>
<code><a href="survival.html#topic+coxph.object">survival::coxph.object</a></code>;
<code><a href="survival.html#topic+Surv">survival::Surv</a></code>; package <code>coxme</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Fit an empirical Bayes Cox model using
# simulated, illness-death data from 250
# patients ('mstate_data_sample').

#load simulated data
data("mstate_data_sample")

# Set class of ‘mstate_data_sample’
class(mstate_data_sample)&lt;-c("data.frame","msdata")

# add transition matrix as attribute
tmat&lt;-mstate::transMat(x=list(c(2,3),c(4),c(),c()),
      names=c("health","illness","death",
     "death_after_illness"))
attr(mstate_data_sample,"trans")&lt;-tmat 

# expand covariates by transition:
covariates.expanded&lt;-mstate::expand.covs(
      mstate_data_sample,
      covs=names(mstate_data_sample)
      [!names(mstate_data_sample)%in%c("id","from",
      "to","trans","Tstart","Tstop","time","status",
      "strata")],append=FALSE)


# argument ‘Z’ of coxrfx
Z&lt;-data.frame(covariates.expanded,
   trans=mstate_data_sample$trans,
   strata=mstate_data_sample$trans)

# argument ‘surv’ for a non-homogeneous 
# Markov model
surv&lt;-survival::Surv(mstate_data_sample$Tstart,
           mstate_data_sample$Tstop,
           mstate_data_sample$status)

# argument ‘groups’ of coxrfx
groups&lt;-paste0(rep("group", ncol(Z)-2),c("_1","_2","_3"))

#fit random effects model
coxrfx_object&lt;-CoxRFX(Z,surv,groups)

#show point estimates
summary(coxrfx_object)


</code></pre>

<hr>
<h2 id='coxrfx_object_sample'>Example of an empirical Bayes model fit</h2><span id='topic+coxrfx_object_sample'></span>

<h3>Description</h3>

<p>An RData object containing the model fit 
obtained by running <code>CoxRFX</code> on the
data set <code>mstate_data_sample</code> (included 
in the present package).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coxrfx_object_sample
</code></pre>


<h3>Format</h3>

<p>An object of class 
<code>c(coxrfx,coxph.penal,coxph)</code>, which is 
essentially a coxph object with a few 
extra fields [the inputs $groups, $Z,
and $surv, and the hyperparameters 
$sigma2 (variances) and $mu (means)].
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mstate_data_sample">mstate_data_sample</a></code>; 
<code><a href="#topic+CoxRFX">CoxRFX</a></code>.
</p>

<hr>
<h2 id='cumhaz_splines'>Spline approximations of the cumulative hazard functions</h2><span id='topic+cumhaz_splines'></span>

<h3>Description</h3>

<p>Creates a spline approximation for the vector of cumulative hazards of each transition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cumhaz_splines(cumhaz)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cumhaz_splines_+3A_cumhaz">cumhaz</code></td>
<td>
<p>An object of class <code>msfit</code>, created by 
<code><a href="#topic+msfit_generic">msfit_generic</a></code> or <code><a href="mstate.html#topic+msfit">msfit</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used by the function <code>probtrans_by_convolution</code>. It is not meant to be called by the user.
</p>


<h3>Value</h3>

<p>A list of estimated cumulative hazard functions (one for each transition).
</p>


<h3>Author(s)</h3>

<p>Rui Costa
</p>


<h3>See Also</h3>

<p><code><a href="#topic+msfit_generic">msfit_generic</a></code>; <code><a href="mstate.html#topic+msfit">msfit</a></code>; <code><a href="#topic+probtrans_by_convolution">probtrans_by_convolution</a></code>.
</p>

<hr>
<h2 id='cumhazCIs_for_target_transition'>Ancillary function of <code>boot_ebmstate</code>.</h2><span id='topic+cumhazCIs_for_target_transition'></span>

<h3>Description</h3>

<p>Computes 95% highest density, non-parametric bootstrap confidence 
intervals for the cumulative hazard rate functions, 
given a list of <code>msfit</code> objects with boostrap estimates of cumulative hazard rate functions
for multiple transitions. This 
function is not meant to be called by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cumhazCIs_for_target_transition(transition, msfit_objects_boot)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cumhazCIs_for_target_transition_+3A_transition">transition</code></td>
<td>
<p>The transition for which transition confidence intervals
are computed.</p>
</td></tr>
<tr><td><code id="cumhazCIs_for_target_transition_+3A_msfit_objects_boot">msfit_objects_boot</code></td>
<td>
<p>List of <code>msfit</code> objects with boostrap estimates 
of cumulative hazard rate functions
for multiple transitions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>95% highest density, non-parametric bootstrap confidence intervals for the cumulative
hazard rate functions.
</p>


<h3>Author(s)</h3>

<p>Rui Costa
</p>


<h3>See Also</h3>

<p><code><a href="#topic+boot_ebmstate">boot_ebmstate</a></code>.
</p>

<hr>
<h2 id='extract_function'>Ancillary function to <code>boot_ebmstate</code>.</h2><span id='topic+extract_function'></span>

<h3>Description</h3>

<p>Extracts the bootstrap estimates of transition probabilities for
target state 'tstate' from a list
with bootstrap estimates of transition probabilities into multiple states.
This function is not meant to be called by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_function(list_object, tstate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_function_+3A_list_object">list_object</code></td>
<td>
<p>A list in which each individual element is a single
bootstrap estimate of the probability of transition
into different states.</p>
</td></tr>
<tr><td><code id="extract_function_+3A_tstate">tstate</code></td>
<td>
<p>The state whose bootstrap estimates of transition probabilities we wish to extract
from <code>list_object</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is an ancillary function of <code>CIs_for_target_state</code>, which
in turn is an ancillary function of <code>boot_ebmstate</code>.
</p>


<h3>Value</h3>

<p>Bootstrap estimates of transition probabilities into target state 'tstate'.
</p>


<h3>Author(s)</h3>

<p>Rui Costa
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CIs_for_target_state">CIs_for_target_state</a></code>; <code><a href="#topic+boot_ebmstate">boot_ebmstate</a></code>
</p>

<hr>
<h2 id='joint_cum_hazard_function'>Compute the cumulative hazard of leaving a given state</h2><span id='topic+joint_cum_hazard_function'></span>

<h3>Description</h3>

<p>This function is not meant to be called by the user. It is
an internal function of <code>probtrans_by_convolution_clockforward</code>
and <code>probtrans_by_convolution_clockreset</code>.
</p>
<p><code>joint_cum_hazard_function</code> returns the cumulative
hazard of leaving state <code>i</code> to any state that can be
reached directly from <code>i</code>, at each of the time points in <code>t</code>.
There is no explicit argument <code>i</code>: this state 
is entirely defined by the transitions
that can occur when the patient is in it (and these 
transitions
are given in the argument <code>competing_transitions</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>joint_cum_hazard_function(t, competing_transitions, spline_list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="joint_cum_hazard_function_+3A_t">t</code></td>
<td>
<p>A vector of time points.</p>
</td></tr>
<tr><td><code id="joint_cum_hazard_function_+3A_competing_transitions">competing_transitions</code></td>
<td>
<p>The transitions that can occur when the process
is in state <code>i</code>.</p>
</td></tr>
<tr><td><code id="joint_cum_hazard_function_+3A_spline_list">spline_list</code></td>
<td>
<p>A list whose elements are spline functions 
approximating the cumulative hazard of making each possible transition in
the process. This is normally a list
object created by running <code>cumhaz_splines</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the cumulative hazard of leaving a given state evaluated at given time points.
</p>


<h3>Author(s)</h3>

<p>Rui Costa
</p>


<h3>See Also</h3>

<p><code><a href="#topic+probtrans_by_convolution_clockforward">probtrans_by_convolution_clockforward</a></code>;
<code><a href="#topic+probtrans_by_convolution_clockreset">probtrans_by_convolution_clockreset</a></code>;
<code><a href="#topic+cumhaz_splines">cumhaz_splines</a></code>.
</p>

<hr>
<h2 id='loo_ebmstate'>Leave-one-out estimation</h2><span id='topic+loo_ebmstate'></span>

<h3>Description</h3>

<p>This function computes leave-one-out estimation of regression coefficients,
cumulative hazard functions, and transition probability functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loo_ebmstate(
  mstate_data,
  mstate_data_expanded,
  which_group,
  patient_IDs,
  initial_state,
  tmat,
  time_model,
  backup_file = NULL,
  input_file = NULL,
  coxrfx_args = list(),
  msfit_args = NULL,
  probtrans_args = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loo_ebmstate_+3A_mstate_data">mstate_data</code></td>
<td>
<p>Data in 'long format'.</p>
</td></tr>
<tr><td><code id="loo_ebmstate_+3A_mstate_data_expanded">mstate_data_expanded</code></td>
<td>
<p>Data in 'long format', possibly with 'expanded' covariates (as obtained by running mstate::expand.covs).</p>
</td></tr>
<tr><td><code id="loo_ebmstate_+3A_which_group">which_group</code></td>
<td>
<p>A character vector with the same meaning as the 'groups' argument of the function <code>CoxRFX</code> but named (with the covariate names).</p>
</td></tr>
<tr><td><code id="loo_ebmstate_+3A_patient_ids">patient_IDs</code></td>
<td>
<p>The IDs of the patients whose cumulative hazards and transition probabilities one wishes to estimate.</p>
</td></tr>
<tr><td><code id="loo_ebmstate_+3A_initial_state">initial_state</code></td>
<td>
<p>The initial state for which transition probability estimates should be computed</p>
</td></tr>
<tr><td><code id="loo_ebmstate_+3A_tmat">tmat</code></td>
<td>
<p>Transition matrix for the multi-state model, as obtained by running <code>mstate::transMat</code></p>
</td></tr>
<tr><td><code id="loo_ebmstate_+3A_time_model">time_model</code></td>
<td>
<p>The model of time-dependency: either 'clockforward' or 'clockreset'.</p>
</td></tr>
<tr><td><code id="loo_ebmstate_+3A_backup_file">backup_file</code></td>
<td>
<p>Path to file. Objects generated while the present function is running are stored in this file. 
This avoids losing all estimates if and when the algorithm breaks down. See argument <code>input_file</code>.</p>
</td></tr>
<tr><td><code id="loo_ebmstate_+3A_input_file">input_file</code></td>
<td>
<p>Path to <code>backup_file</code> (see argument <code>backup_file</code>). If this argument is given, all other arguments should be <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="loo_ebmstate_+3A_coxrfx_args">coxrfx_args</code></td>
<td>
<p>Named list with arguments to the <code>CoxRFX</code> function other than <code>Z</code>,<code>surv</code> and <code>groups</code>.</p>
</td></tr>
<tr><td><code id="loo_ebmstate_+3A_msfit_args">msfit_args</code></td>
<td>
<p>Named list with arguments to the <code>msfit_generic.coxrfx</code> function other than <code>object</code>,<code>newdata</code> and <code>trans</code>.</p>
</td></tr>
<tr><td><code id="loo_ebmstate_+3A_probtrans_args">probtrans_args</code></td>
<td>
<p>Named list with arguments to the <code>probtrans_ebmstate</code> function other than <code>initia_state</code>,<code>cumhaz</code> and <code>model</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In a given bootstrap sample there might not be enough information to generate 
estimates for all coefficients. If a covariate has little or no variation in a given bootstrap sample, 
no estimate of its coefficient will be computed. The present function will
keep taking bootstrap samples until every coefficient has been estimated
at least <code>min_nr_samples</code> times.
</p>


<h3>Value</h3>

<p>A list with: 95% bootstrap intervals for each regression coefficient and for transition probabilities; 
bootstrap samples of regression coefficients, cumulative hazards and transition probabilities.
</p>


<h3>Author(s)</h3>

<p>Rui Costa
</p>

<hr>
<h2 id='MakeInteger'>Convert factor to integer.</h2><span id='topic+MakeInteger'></span>

<h3>Description</h3>

<p>Convert factor to integer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MakeInteger(v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MakeInteger_+3A_v">v</code></td>
<td>
<p>A factor vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An internal function of <code>CoxRFX</code>, not meant
to called directly by the user.
</p>


<h3>Value</h3>

<p>A data.frame with columns corresponding to levels in the factor.
</p>


<h3>Author(s)</h3>

<p>Moritz Gerstung
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CoxRFX">CoxRFX</a></code>
</p>

<hr>
<h2 id='msfit_generic'>Compute subject-specific transition hazards.</h2><span id='topic+msfit_generic'></span><span id='topic+msfit_generic.default'></span><span id='topic+msfit_generic.coxrfx'></span>

<h3>Description</h3>

<p>This function computes subject-specific or overall cumulative transition
hazards for each of the possible transitions in the multi-state model.
This help page is an adaptation of the <code>mstate::msfit</code> help page.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msfit_generic(object, ...)

## Default S3 method:
msfit_generic(
  object,
  newdata,
  variance = TRUE,
  vartype = c("aalen", "greenwood"),
  trans,
  ...
)

## S3 method for class 'coxrfx'
msfit_generic(object, newdata, trans, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="msfit_generic_+3A_object">object</code></td>
<td>
<p>An object describing the fit of
a multi-state Cox model.</p>
</td></tr>
<tr><td><code id="msfit_generic_+3A_...">...</code></td>
<td>
<p>Further arguments</p>
</td></tr>
<tr><td><code id="msfit_generic_+3A_newdata">newdata</code></td>
<td>
<p>A data frame in &lsquo;long format&rsquo;. See details.</p>
</td></tr>
<tr><td><code id="msfit_generic_+3A_variance">variance</code></td>
<td>
<p>A logical value indicating whether the
(co-)variances of the subject-specific transition hazards should be computed.</p>
</td></tr>
<tr><td><code id="msfit_generic_+3A_vartype">vartype</code></td>
<td>
<p>A character string specifying the type of
variances to be computed (so only needed if variance=TRUE).</p>
</td></tr>
<tr><td><code id="msfit_generic_+3A_trans">trans</code></td>
<td>
<p>Transition matrix describing the states and transitions in 
the multi-state model. See <code>trans</code> in <code><a href="mstate.html#topic+msprep">mstate::msprep</a></code>
for more detailed information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The purpose of <code>msfit_generic</code> is to be able to use 
<code>mstate::msfit</code> on model fit objects of class <code>coxrfx</code> 
(i.e. objects generated by <code><a href="#topic+CoxRFX">CoxRFX</a></code>). This can now be done
with <code>msfit_generic.coxrfx</code>, which introduces minor modifications
to <code>mstate::msfit</code>. In particular, it precludes <code>msfit</code> from 
computing the (co-)variances of transition hazard estimators, as this
computation relies on asymptotic results for the fixed effects Cox model
(see de Wreede et al, 2010, section 2.3.2). The method <code>msfit_generic.default</code>
corresponds to the original <code>mstate::msfit</code> function. 
The data frame given as <code>newdata</code> input needs to have one row for each transition
in the multi-state model, and one column for each covariate.
An additional column strata (numeric) is needed to describe for each transition to
which stratum it belongs. The name has to be <code>strata</code>, even if in the original
<code>coxph</code> call another variable was used. See <code><a href="mstate.html#topic+msfit">msfit</a></code> for more details.
</p>


<h3>Value</h3>

<p>An 'msfit' object. See <code><a href="mstate.html#topic+msfit">mstate::msfit</a></code> for details.
If the S3 method <code>msfit_generic.coxrfx</code> is called, the 
returned object will be of class <code>c(msfit,coxrfx)</code>; 
otherwise, it will be of class <code>msfit</code>.
</p>


<h3>Author(s)</h3>

<p>Rui Costa, adapting the work of L. de Wreede,
M. Fiocco and H. Putter in the
<code><a href="mstate.html#topic+mstate">mstate</a></code> package.
</p>


<h3>References</h3>

<p>de Wreede LC, Fiocco M, and Putter H (2010). The mstate package for 
estimation and prediction in non- and semi-parametric multi-state and 
competing risks models. <em>Computer Methods and Programs in Biomedicine</em> 
<strong>99</strong>, 261–274.
</p>


<h3>See Also</h3>

<p><code><a href="mstate.html#topic+msfit">mstate::msfit</a></code>; <code><a href="mstate.html#topic+msprep">mstate::msprep</a></code>; <code><a href="mstate.html#topic+plot.msfit">mstate::plot.msfit</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute cumulative hazard rates
# under a (pre-estimated) empirical Bayes Cox
# model.

#load simulated data (illness-death model,
#500 patients) and estimated empirical
# Bayes Cox model
data("mstate_data_sample")
data("coxrfx_object_sample")

# Make objects 'surv' and 'Z'
# with the data used in the estimation

#outcome data
surv&lt;-coxrfx_object_sample$surv

#covariate data
Z&lt;-coxrfx_object_sample$Z

# Build a data frame 'patient_data'
# with the covariate values for which 
# cumulative hazards are to be computed
# (patient 1 covariate values in this case).
# 'patient_data' must have one row for each
# transition in the model 
# and the same columns as 'Z'. The assignment
# of transitions to strata (made in the 'strata'
# column) must follow the original model in
# 'coxrfx_object_sample'.

patient_data&lt;-mstate_data_sample[mstate_data_sample$id==1,
   ,drop=FALSE][rep(1,3),]
patient_data$strata&lt;-patient_data$trans&lt;-1:3
patient_data&lt;-mstate::expand.covs(patient_data,
   covs=names(patient_data)[!names(patient_data)%in%
   c("id","from","to","trans","Tstart","Tstop","time",
   "to","trans","Tstart","Tstop","time","status",
   "strata")],append=TRUE)

# compute cumulative hazards
msfit_object&lt;-msfit_generic(coxrfx_object_sample,
                            patient_data,
                            coxrfx_object_sample$tmat)

# show estimates
print(msfit_object)
</code></pre>

<hr>
<h2 id='msfit_object_sample'>Estimated cumulative hazard rates under 
an empirical Bayes Cox model (example)</h2><span id='topic+msfit_object_sample'></span>

<h3>Description</h3>

<p>An RData object containing estimated
cumulative hazards,
obtained by running <code>msfit_generic</code> on the
object <code>coxrfx_object_sample</code> (also included 
in the present package).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msfit_object_sample
</code></pre>


<h3>Format</h3>

<p>An object of class 
<code>c(msfit,coxrfx)</code>. See <code><a href="#topic+msfit_generic">msfit_generic</a></code> 
and <code><a href="mstate.html#topic+msfit">mstate::msfit</a></code> for details.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coxrfx_object_sample">coxrfx_object_sample</a></code>.
</p>

<hr>
<h2 id='mstate_data'>An example of long-format multistate data</h2><span id='topic+mstate_data'></span>

<h3>Description</h3>

<p>An RData object containing disease progression
data for a sample of 576 patients with myelodysplastic
syndromes (MDS), as an example of long-format 
multistate data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mstate_data
</code></pre>


<h3>Format</h3>

<p>A data frame.
</p>

<hr>
<h2 id='mstate_data_sample'>A simulated event-history data set</h2><span id='topic+mstate_data_sample'></span>

<h3>Description</h3>

<p>A data set generated by simulation from an 
illness-death Cox model. This is an object
of double class 'data.frame' and 'msdata', whose
'trans' attribute is a transition matrix  
(<code>attr(mstate_data_sample,"trans")</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mstate_data_sample
</code></pre>


<h3>Format</h3>

<p>A data frame with 649 rows and 18 variables
(250 patients):
</p>

<dl>
<dt>id</dt><dd><p>patient identification number</p>
</dd>
<dt>from</dt><dd><p>state in which the patient is</p>
</dd>
<dt>to</dt><dd><p>state to which the patient is at risk of going to</p>
</dd>
<dt>trans</dt><dd><p>transition ID number</p>
</dd>
<dt>Tstart</dt><dd><p>when the risk of the transition started</p>
</dd>
<dt>Tstop</dt><dd><p>the time at which the risk of the
transition ended or the last follow-up time (whichever 
happened first)</p>
</dd>
<dt>time</dt><dd><p>Tstop-Tstart</p>
</dd>
<dt>status</dt><dd><p>did the transition occur at Tstop?</p>
</dd>
<dt>Cov1,Cov2,Cov3,Cov4,Cov5,Cov6,Cov7,Cov8,Cov9,Cov10</dt><dd><p>covariates</p>
</dd>
</dl>


<hr>
<h2 id='print.coxrfx'>Print method for CoxRFX objects</h2><span id='topic+print.coxrfx'></span>

<h3>Description</h3>

<p>This function implicitly calls summary.coxrfx().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coxrfx'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.coxrfx_+3A_x">x</code></td>
<td>
<p>A <code>coxrfx</code> object</p>
</td></tr>
<tr><td><code id="print.coxrfx_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prints two data frames, one with hyperparameter estimates and 
another with regression coefficient estimates.
</p>


<h3>Value</h3>

<p>Returns an invisible NULL object.
</p>


<h3>Author(s)</h3>

<p>Moritz Gerstung &amp; Rui Costa
</p>

<hr>
<h2 id='print.msfit'>Print method for <code>msfit</code> objects
generated by <code>msfit_generic</code></h2><span id='topic+print.msfit'></span>

<h3>Description</h3>

<p>This method is a simple call to <code>print.default</code>.
Its main purpose is to override <code>print.coxrfx</code>
when printing an
object of double class <code>msfit</code> and <code>coxrfx</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'msfit'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.msfit_+3A_x">x</code></td>
<td>
<p>An object of class <code>msfit</code> or double class <code>msfit</code> 
and <code>coxrfx</code>.</p>
</td></tr>
<tr><td><code id="print.msfit_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input object (an object of double class <code>msfit</code> and <code>coxrfx</code>).
</p>


<h3>Author(s)</h3>

<p>Rui Costa
</p>

<hr>
<h2 id='probtrans_by_convolution'>Compute all transition probabilities from a given state
using convolution</h2><span id='topic+probtrans_by_convolution'></span>

<h3>Description</h3>

<p><code>probtrans_by_convolution</code> is an internal function of <code>probtrans_ebmstate</code> and
is not meant to be called directly by the user.
It is itself a wrapper for the functions <code>probtrans_by_convolution_clockforward</code>
and <code>probtrans_by_convolution_clockreset</code>, which are the workhorses of the 
convolution algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>probtrans_by_convolution(tmat, cumhaz, from_state, model, max_time, nr_steps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="probtrans_by_convolution_+3A_tmat">tmat</code></td>
<td>
<p>A transition matrix extracted from the <code>cumhaz</code> argument to 
<code>probtrans_ebmstate</code>.</p>
</td></tr>
<tr><td><code id="probtrans_by_convolution_+3A_cumhaz">cumhaz</code></td>
<td>
<p><code>msfit</code> object (argument passed on from <code>probtrans_ebmstate</code>).</p>
</td></tr>
<tr><td><code id="probtrans_by_convolution_+3A_from_state">from_state</code></td>
<td>
<p>Initial state (argument passed on from <code>probtrans_ebmstate</code>).</p>
</td></tr>
<tr><td><code id="probtrans_by_convolution_+3A_model">model</code></td>
<td>
<p>'clockforward' or 'clockreset' (argument passed on from <code>probtrans_ebmstate</code>).</p>
</td></tr>
<tr><td><code id="probtrans_by_convolution_+3A_max_time">max_time</code></td>
<td>
<p>The maximum time for which transition probabilities
are estimated.</p>
</td></tr>
<tr><td><code id="probtrans_by_convolution_+3A_nr_steps">nr_steps</code></td>
<td>
<p>The number of steps in the convolution algorithm
(larger increases precision but makes it slower)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more information on the arguments of this function 
see <code><a href="#topic+probtrans_ebmstate">probtrans_ebmstate</a></code>.
</p>


<h3>Author(s)</h3>

<p>Rui Costa &amp; Moritz Gerstung
</p>


<h3>See Also</h3>

<p><code><a href="#topic+probtrans_ebmstate">probtrans_ebmstate</a></code>;<code><a href="#topic+probtrans_by_convolution_clockforward">probtrans_by_convolution_clockforward</a></code>;
<code><a href="#topic+probtrans_by_convolution_clockreset">probtrans_by_convolution_clockreset</a></code>.
</p>

<hr>
<h2 id='probtrans_by_convolution_clockforward'>Compute transition probabilities under a clock-forward model using
a convolution algorithm.</h2><span id='topic+probtrans_by_convolution_clockforward'></span>

<h3>Description</h3>

<p>Compute transition probabilities for a given starting state and target state
under a clock-forward model, using a convolution algorithm.
</p>
<p><code>probtrans_by_convolution_clockforward</code> is an internal function of
<code>probtrans_by_convolution</code> and is not meant to be called directly by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>probtrans_by_convolution_clockforward(
  tmat,
  cumhaz,
  from_state,
  to_state,
  spline_list,
  unique_paths_object,
  time
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="probtrans_by_convolution_clockforward_+3A_tmat">tmat</code></td>
<td>
<p>Transition matrix.</p>
</td></tr>
<tr><td><code id="probtrans_by_convolution_clockforward_+3A_cumhaz">cumhaz</code></td>
<td>
<p><code>msfit</code> object.</p>
</td></tr>
<tr><td><code id="probtrans_by_convolution_clockforward_+3A_from_state">from_state</code></td>
<td>
<p>Initial state.</p>
</td></tr>
<tr><td><code id="probtrans_by_convolution_clockforward_+3A_to_state">to_state</code></td>
<td>
<p>Target state.</p>
</td></tr>
<tr><td><code id="probtrans_by_convolution_clockforward_+3A_spline_list">spline_list</code></td>
<td>
<p>A list whose elements are spline functions 
approximating the cumulative hazard of making each possible transition in
the process. This is normally a list
object created by running <code>cumhaz_splines</code>.</p>
</td></tr>
<tr><td><code id="probtrans_by_convolution_clockforward_+3A_unique_paths_object">unique_paths_object</code></td>
<td>
<p>An object created by running <code>unique_paths</code>.</p>
</td></tr>
<tr><td><code id="probtrans_by_convolution_clockforward_+3A_time">time</code></td>
<td>
<p>A vector of ordered time points.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rui Costa &amp; Moritz Gerstung
</p>


<h3>See Also</h3>

<p><code><a href="#topic+probtrans_ebmstate">probtrans_ebmstate</a></code>;
<code><a href="#topic+probtrans_by_convolution_clockreset">probtrans_by_convolution_clockreset</a></code>; 
<code><a href="#topic+probtrans_by_convolution">probtrans_by_convolution</a></code>;
<code><a href="#topic+unique_paths">unique_paths</a></code>;
<code><a href="#topic+cumhaz_splines">cumhaz_splines</a></code>.
</p>

<hr>
<h2 id='probtrans_by_convolution_clockreset'>Compute transition probabilities under a clock-reset model using
a convolution algorithm.</h2><span id='topic+probtrans_by_convolution_clockreset'></span>

<h3>Description</h3>

<p>Compute transition probabilities for a given starting state and target state
under a clock-reset model with a single time scale (sojourn time),
using a convolution algorithm.
</p>
<p><code>probtrans_by_convolution_clockreset</code> is an internal function of
<code>probtrans_by_convolution</code> and is not meant to be called directly by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>probtrans_by_convolution_clockreset(
  tmat,
  cumhaz,
  from_state,
  to_state,
  spline_list,
  unique_paths_object,
  time
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="probtrans_by_convolution_clockreset_+3A_tmat">tmat</code></td>
<td>
<p>Transition matrix.</p>
</td></tr>
<tr><td><code id="probtrans_by_convolution_clockreset_+3A_cumhaz">cumhaz</code></td>
<td>
<p><code>msfit</code> object.</p>
</td></tr>
<tr><td><code id="probtrans_by_convolution_clockreset_+3A_from_state">from_state</code></td>
<td>
<p>Initial state.</p>
</td></tr>
<tr><td><code id="probtrans_by_convolution_clockreset_+3A_to_state">to_state</code></td>
<td>
<p>Target state.</p>
</td></tr>
<tr><td><code id="probtrans_by_convolution_clockreset_+3A_spline_list">spline_list</code></td>
<td>
<p>A list whose elements are spline functions 
approximating the cumulative hazard of making each possible transition in
the process. This is normally a list
object created by running <code>cumhaz_splines</code>.</p>
</td></tr>
<tr><td><code id="probtrans_by_convolution_clockreset_+3A_unique_paths_object">unique_paths_object</code></td>
<td>
<p>An object created by running <code>unique_paths</code>.</p>
</td></tr>
<tr><td><code id="probtrans_by_convolution_clockreset_+3A_time">time</code></td>
<td>
<p>A vector of ordered time points.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rui Costa &amp; Moritz Gerstung
</p>


<h3>See Also</h3>

<p><code><a href="#topic+probtrans_ebmstate">probtrans_ebmstate</a></code>;
<code><a href="#topic+probtrans_by_convolution_clockforward">probtrans_by_convolution_clockforward</a></code>; 
<code><a href="#topic+probtrans_by_convolution">probtrans_by_convolution</a></code>;
<code><a href="#topic+unique_paths">unique_paths</a></code>;
<code><a href="#topic+cumhaz_splines">cumhaz_splines</a></code>.
</p>

<hr>
<h2 id='probtrans_ebmstate'>Compute subject-specific transition probabilities
using convolution.</h2><span id='topic+probtrans_ebmstate'></span>

<h3>Description</h3>

<p>Compute subject-specific transition probabilities
using convolution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>probtrans_ebmstate(
  initial_state,
  cumhaz,
  model,
  max_time = NULL,
  nr_steps = 10000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="probtrans_ebmstate_+3A_initial_state">initial_state</code></td>
<td>
<p>The present function 
estimates transition probabilities from the state given
in this argument.</p>
</td></tr>
<tr><td><code id="probtrans_ebmstate_+3A_cumhaz">cumhaz</code></td>
<td>
<p>An <code>msfit</code> object created by running
<code>mstate</code> or <code>mstate_generic</code>.</p>
</td></tr>
<tr><td><code id="probtrans_ebmstate_+3A_model">model</code></td>
<td>
<p>Either 'clockforward' or
'clockreset'. See details.</p>
</td></tr>
<tr><td><code id="probtrans_ebmstate_+3A_max_time">max_time</code></td>
<td>
<p>The maximum time for which transition probabilities
are estimated.</p>
</td></tr>
<tr><td><code id="probtrans_ebmstate_+3A_nr_steps">nr_steps</code></td>
<td>
<p>The number of steps in the convolution algorithm
(larger increases precision but makes it slower)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The clock-forward model is a model 
in which the transition hazard rates depend only on
time since the initiating event. The clock-reset model
has a single time scale: the sojourn time in the current 
state.
</p>
<p>The algorithm behind <code>probtrans_ebmstate</code> is based 
on the convolution of density and survival functions and
is suitable for processes with a tree-like transition
structure only.
</p>


<h3>Value</h3>

<p>An object of class 'probtrans'. See the 'value' 
section in the help page of <code>mstate::probtrans</code>.
</p>


<h3>Author(s)</h3>

<p>Rui Costa &amp; Moritz Gerstung
</p>


<h3>See Also</h3>

<p><code><a href="mstate.html#topic+probtrans">probtrans</a></code>;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Compute transition probabilities
# from an object with (pre-estimated) 
# cumulative hazard rates.

#load object with estimated
#cumulative hazard rates 
data("msfit_object_sample")

#compute transition probabilities
probtrans_object&lt;-probtrans_ebmstate("health",
   msfit_object_sample,"clockforward")

</code></pre>

<hr>
<h2 id='probtrans_fft'>Compute subject-specific transition probabilities
using a convolution algorithm based on the Fast Fourier transform.</h2><span id='topic+probtrans_fft'></span>

<h3>Description</h3>

<p>Compute subject-specific transition probabilities
using a convolution algorithm based on the Fast Fourier transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>probtrans_fft(initial_state, cumhaz, max_time, nr_steps = 10000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="probtrans_fft_+3A_initial_state">initial_state</code></td>
<td>
<p>The present function 
estimates state occupation probabilities from the state given
in this argument.</p>
</td></tr>
<tr><td><code id="probtrans_fft_+3A_cumhaz">cumhaz</code></td>
<td>
<p>An <code>msfit</code> object created by running
<code>mstate</code> or <code>mstate_generic</code>.</p>
</td></tr>
<tr><td><code id="probtrans_fft_+3A_max_time">max_time</code></td>
<td>
<p>The maximum time for which transition probabilities
are estimated.</p>
</td></tr>
<tr><td><code id="probtrans_fft_+3A_nr_steps">nr_steps</code></td>
<td>
<p>The number of steps in the convolution algorithm
(larger increases precision but makes it slower)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>time</code> argument is crucial for precision.
The density of time points and
the upper time limit should
be increased until the estimated curves become stable.
A useful rule of thumb is to set the upper time limit
to a time point in which the
probability of each transient state is zero and the probability of
each absorbing state is constant.
</p>
<p>For the same approximation grid, <code>probtrans_fft</code> doesn’t
always yield the same result as <code>probtrans_ebmstate</code>
(semi-Markov version), even though they are meant to approximate
exactly the same convolution. <code>probtrans_ebmstate</code> is
sensitive to the grid interval size, but not such much to the
maximum grid time. <code>probtrans_fft</code> is sensitive to both
these parameters, as referred above.
</p>
<p>The algorithm behind <code>probtrans_ebmstate</code> is based
on the convolution of density and survival functions and
is suitable for processes with a tree-like transition
structure only.
</p>


<h3>Value</h3>

<p>An object of class 'probtrans'. See the 'value' 
section in the help page of <code>mstate::probtrans</code>.
</p>


<h3>Author(s)</h3>

<p>Rui Costa
</p>


<h3>See Also</h3>

<p><code><a href="mstate.html#topic+probtrans">probtrans</a></code>; <code><a href="#topic+probtrans_ebmstate">probtrans_ebmstate</a></code>
</p>

<hr>
<h2 id='probtrans_mstate'>Compute subject-specific or overall transition probabilities</h2><span id='topic+probtrans_mstate'></span><span id='topic+probtrans_mstate.default'></span><span id='topic+probtrans_mstate.coxrfx'></span>

<h3>Description</h3>

<p>This function is a wrapper for <code>mstate::probtrans</code>. Its purpose is to 
preclude the computation of (co-)variances of the transition probability 
estimator when the fitted Cox model is empirical Bayes. 
This help page is an adaptation of the <code>mstate::probtrans</code> help page.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>probtrans_mstate(object, ...)

## Default S3 method:
probtrans_mstate(
  object,
  predt,
  direction = c("forward", "fixedhorizon"),
  method = c("aalen", "greenwood"),
  variance = TRUE,
  covariance = FALSE,
  ...
)

## S3 method for class 'coxrfx'
probtrans_mstate(object, predt, direction = c("forward", "fixedhorizon"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="probtrans_mstate_+3A_object">object</code></td>
<td>
<p>An msfit object containing estimated cumulative hazards
for each of the transitions in the multi-state model and,
if standard errors are requested, (co)variances of these cumulative hazards
for each pair of transitions.</p>
</td></tr>
<tr><td><code id="probtrans_mstate_+3A_...">...</code></td>
<td>
<p>other arguments.</p>
</td></tr>
<tr><td><code id="probtrans_mstate_+3A_predt">predt</code></td>
<td>
<p>A positive number indicating the prediction time. 
This is either the time at which the prediction is made (if direction= &quot;forward&quot;) 
or the time for which the prediction is to be made (if direction=&quot;fixedhorizon&quot;).</p>
</td></tr>
<tr><td><code id="probtrans_mstate_+3A_direction">direction</code></td>
<td>
<p>One of &quot;forward&quot; (default) or &quot;fixedhorizon&quot;, indicating whether
prediction is forward or for a fixed horizon.</p>
</td></tr>
<tr><td><code id="probtrans_mstate_+3A_method">method</code></td>
<td>
<p>A character string specifying the type of variances to be computed
(so only needed if either variance or covariance is TRUE). Possible values are 
&quot;aalen&quot; or &quot;greenwood&quot;.</p>
</td></tr>
<tr><td><code id="probtrans_mstate_+3A_variance">variance</code></td>
<td>
<p>Logical value indicating whether standard errors are to be
calculated (default is TRUE).</p>
</td></tr>
<tr><td><code id="probtrans_mstate_+3A_covariance">covariance</code></td>
<td>
<p>Logical value indicating whether covariances of transition
probabilities for different states are to be calculated (default is FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>probtrans_mstate</code> computes estimates of transition probabilities
for an object generated by <code>msfit_generic</code>. It calls the method 
<code>probtrans_mstate.coxrfx</code>, if the msfit object was generated
by msfit_generic.coxrfx, or the method probtrans_mstate.default otherwise.
Both methods are identical to the function <code>mstate::probtrans</code>. The 
only reserve is that <code>probtrans_mstate.coxrfx</code> does not allow the computation of
the (co-)variances of the transition probability estimator. In fact,
this computation relies on asymptotic results for the <em>fixed</em> effects Cox model
(see de Wreede et al, 2010, section 2.3.2), and <code>msfit_generic.coxrfx</code> produces
estimates of cumulative hazards under a random effects/empirical Bayes Cox model. 
</p>
<p><code>probtrans_mstate</code> should only be used for Markov models, as it relies
on product limit calculations.
</p>


<h3>Value</h3>

<p>An object of class <code>probtrans</code>. See the &lsquo;value&rsquo; section in the
the help page of <code><a href="mstate.html#topic+probtrans">probtrans</a></code> for details.
</p>


<h3>Author(s)</h3>

<p>Rui Costa, adapting the work of L. de Wreede,
M. Fiocco and H. Putter in the
<code><a href="mstate.html#topic+mstate">mstate</a></code> package.
</p>


<h3>References</h3>

<p>de Wreede LC, Fiocco M, and Putter H (2010). The mstate package for 
estimation and prediction in non- and semi-parametric multi-state and 
competing risks models. <em>Computer Methods and Programs in Biomedicine</em> 
<strong>99</strong>, 261–274.
</p>


<h3>See Also</h3>

<p><code><a href="mstate.html#topic+probtrans">mstate::probtrans</a></code>; <code><a href="mstate.html#topic+msfit">mstate::msfit</a></code>; <code><a href="#topic+msfit_generic">msfit_generic</a></code>.
</p>

<hr>
<h2 id='successful_transitions'>Find the unique possible path until an 
absorbing state</h2><span id='topic+successful_transitions'></span>

<h3>Description</h3>

<p>From a <code>unique_paths</code> object that
shows all possible paths until 
absorption from an initial state, 
<code>successful_transitions</code> picks the path
that finishes in <code>to_state</code>, if there is one. 
The initial state is the one defined in the 
argument <code>from_state</code> 
to the function <code>unique_paths</code>. 
The process must have a tree-like structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>successful_transitions(unique_paths_object, to_state, tmat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="successful_transitions_+3A_unique_paths_object">unique_paths_object</code></td>
<td>
<p>An object created by running 
<code><a href="#topic+unique_paths">unique_paths</a></code>.</p>
</td></tr>
<tr><td><code id="successful_transitions_+3A_to_state">to_state</code></td>
<td>
<p>An absorbing state.</p>
</td></tr>
<tr><td><code id="successful_transitions_+3A_tmat">tmat</code></td>
<td>
<p>Transition matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used by <code>probtrans_by_convolution_clockforward</code> and <code>probtrans_by_convolution_clockreset</code>.
It is not meant to be called by the user.
</p>


<h3>Value</h3>

<p>A vector with the unique sequence of states between two states.
</p>


<h3>Author(s)</h3>

<p>Rui Costa
</p>


<h3>See Also</h3>

<p><code><a href="#topic+unique_paths">unique_paths</a></code>;
<code><a href="#topic+probtrans_by_convolution_clockforward">probtrans_by_convolution_clockforward</a></code>;
<code><a href="#topic+probtrans_by_convolution_clockreset">probtrans_by_convolution_clockreset</a></code>.
</p>

<hr>
<h2 id='summary.coxrfx'>A summary method for CoxRFX models</h2><span id='topic+summary.coxrfx'></span>

<h3>Description</h3>

<p>This function prints the point estimates of parameters and 
hyperparameters contained in a <code>coxrfx</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coxrfx'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.coxrfx_+3A_object">object</code></td>
<td>
<p>A <code>coxrfx</code> object 
(obtained by running the function <code>CoxRFX</code>).</p>
</td></tr>
<tr><td><code id="summary.coxrfx_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prints two data frames, one with hyperparameter estimates and 
another with regression coefficient estimates.
</p>


<h3>Value</h3>

<p>Returns an invisible NULL object.
</p>


<h3>Author(s)</h3>

<p>Rui Costa
</p>

<hr>
<h2 id='unique_paths'>Find all possible paths until absorption from a given starting state</h2><span id='topic+unique_paths'></span>

<h3>Description</h3>

<p><code>unique_paths</code> finds all possible sequences of states until absorption
when the process has a tree-like structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unique_paths(from_state, tmat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unique_paths_+3A_from_state">from_state</code></td>
<td>
<p>Initial state.</p>
</td></tr>
<tr><td><code id="unique_paths_+3A_tmat">tmat</code></td>
<td>
<p>A transition matrix describing the states and transitions in 
the multi-state model, as can be obtained by running
<code><a href="mstate.html#topic+transMat">transMat</a></code>. 
See argument <code>trans</code> in <code><a href="mstate.html#topic+msprep">msprep</a></code> (<code>mstate</code>
package) for more detailed information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used by the function <code><a href="#topic+probtrans_by_convolution">probtrans_by_convolution</a></code>. 
It is not meant to be called by the user.
</p>


<h3>Value</h3>

<p>A matrix where each column is a sequence of states taken by the process until absorption. 
There are as many columns as the number of possible paths until absorption.
</p>


<h3>Author(s)</h3>

<p>Rui Costa
</p>


<h3>See Also</h3>

<p><code><a href="#topic+probtrans_by_convolution">probtrans_by_convolution</a></code>;
<code><a href="mstate.html#topic+transMat">transMat</a></code>.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
