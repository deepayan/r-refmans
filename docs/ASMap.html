<!DOCTYPE html><html><head><title>Help for package ASMap</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ASMap}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#alignCross'>
<p>Graphical linkage group identity and alignment.</p></a></li>
<li><a href='#ASMap-internal'><p>Internal fastMap functions</p></a></li>
<li><a href='#ASMap-package'>
<p>Additional functions for linkage map construction and manipulation of R/qtl</p>
objects.</a></li>
<li><a href='#breakCross'>
<p>Break linkage groups of an <span class="pkg">qtl</span> cross object</p></a></li>
<li><a href='#combineMap'>
<p>Combine linkage maps from multiple <span class="pkg">qtl</span> cross objects</p></a></li>
<li><a href='#fixClones'>
<p>Consensus genotypes for clonal genotype groups</p></a></li>
<li><a href='#genClones'>
<p>Find and report genotype clones</p></a></li>
<li><a href='#heatMap'>
<p>Heat map of the estimated pairwise recombination fractions and LOD</p>
linkage between markers.</a></li>
<li><a href='#mapBC'><p>A constructed linkage map for a backcross barley population</p></a></li>
<li><a href='#mapBCu'><p>An unconstructed marker set for a backcross barley population</p></a></li>
<li><a href='#mapDH'><p>A constructed linkage map for a doubled haploid wheat population</p></a></li>
<li><a href='#mapDHf'><p>An unconstructed marker set for a doubled haploid wheat population</p></a></li>
<li><a href='#mapF2'><p>Simulated constructed linkage map for a self pollinated F2 barley population</p></a></li>
<li><a href='#mergeCross'>
<p>Merge linkage groups of an <span class="pkg">qtl</span> cross object</p></a></li>
<li><a href='#mstmap.cross'>
<p>Extremely fast linkage map construction for <span class="pkg">qtl</span> objects using MSTmap.</p></a></li>
<li><a href='#mstmap.data.frame'>
<p>Extremely fast linkage map construction for data frame objects using MSTmap.</p></a></li>
<li><a href='#pp.init'>
<p>Parameter initialization function</p></a></li>
<li><a href='#profileGen'>
<p>Profile individual genotype statistics for an R/qtl cross object</p></a></li>
<li><a href='#profileMark'>
<p>Profile individual marker and interval statistics for an R/qtl cross object</p></a></li>
<li><a href='#pullCross'>
<p>Pull markers from a linkage map.</p></a></li>
<li><a href='#pushCross'>
<p>Push markers into an established R/qtl linkage map.</p></a></li>
<li><a href='#pValue'>
<p>P-value graph</p></a></li>
<li><a href='#quickEst'>
<p>Very quick estimation of genetic map distances.</p></a></li>
<li><a href='#statGen'>
<p>Individual genotype statistics for an R/qtl cross object</p></a></li>
<li><a href='#statMark'>
<p>Individual marker and interval statistics for an R/qtl cross object</p></a></li>
<li><a href='#subsetCross'>
<p>Subset an R/qtl object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Linkage Map Construction using the MSTmap Algorithm</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0-7</td>
</tr>
<tr>
<td>Author:</td>
<td>Julian Taylor &lt;julian.taylor@adelaide.edu.au&gt;, David Butler
    &lt;dbutler@uow.edu.au&gt;.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Julian Taylor &lt;julian.taylor@adelaide.edu.au&gt;</td>
</tr>
<tr>
<td>Imports:</td>
<td>fields, RColorBrewer, gtools</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), qtl, lattice</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, formatR, digest</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for Accurate and Speedy linkage map construction, manipulation and diagnosis of Doubled Haploid, Backcross and Recombinant Inbred 'R/qtl' objects. This includes extremely fast linkage map clustering and optimal marker ordering using 'MSTmap' (see Wu et al.,2008).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-09 04:49:38 UTC; a1193984</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-09 05:20:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='alignCross'>
Graphical linkage group identity and alignment.
</h2><span id='topic+alignCross'></span>

<h3>Description</h3>

<p>A graphical tool for identity and alignment of linkage groups in <span class="pkg">qtl</span>
cross objects using reference maps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alignCross(object, chr, maps, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alignCross_+3A_object">object</code></td>
<td>

<p>A <span class="pkg">qtl</span> cross <code>object</code> with any class structure.
</p>
</td></tr>
<tr><td><code id="alignCross_+3A_chr">chr</code></td>
<td>

<p>A character string of linkage group names or a logical vector equal to
the length of the number of linkage groups (see <code><a href="qtl.html#topic+subset.cross">subset.cross</a></code>).
</p>
</td></tr>
<tr><td><code id="alignCross_+3A_maps">maps</code></td>
<td>

<p>A named list of <span class="pkg">qtl</span> cross objects or <code>data.frame</code> objects
containing markers that are present in <code>object</code>. The matching
markers are used to identify and orient the <code>object</code> linkage groups (see Details).
</p>
</td></tr>
<tr><td><code id="alignCross_+3A_...">...</code></td>
<td>

<p>Other arguments to be passed to the high level lattice plot.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If any list elements of <code>map</code> are <span class="pkg">qtl</span> <code>"cross"</code> objects
then marker names, linkage group identity and genetic distance
information are extracted. List elements of <code>map</code> that are <code>data.frame</code>
objects must explicitly contain named columns
<code>"marker"</code>, <code>"ref.chr"</code>, <code>"ref.dist"</code> otherwise an error will be produced.
</p>
<p>For each linkage group determined by <code>chr</code>, the contents of the
listed <code>maps</code> are checked for matching markers in
<code>object</code>. For each <code>chr</code> and reference map combination, a
scatter plot of the <code>object</code> genetic distances against the
reference distances is displayed with reference
linkage group names as the plotting character. If a linkage group is in
correct orientation the overall slope of the scatter plot should be
positive. If a linkage group requires inverting then the overall slope
should be negative.
</p>


<h3>Value</h3>

<p>A lattice panel plot is displayed with panels labelled by a combination
of <code>chr</code> and the <code>maps</code> used as a reference. A data frame of
these results is also invisibly returned.
</p>


<h3>Author(s)</h3>

<p>Julian Taylor
</p>


<h3>References</h3>

<p>Taylor, J., Butler, D. (2017) R Package ASMap: Efficient Genetic
Linkage Map Construction and Diagnosis. Journal of Statistical Software,
<b>79</b>(6), 1&ndash;29.
</p>


<h3>See Also</h3>

<p><code><a href="qtl.html#topic+est.map">est.map</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mapDH, package = "ASMap")

chrl &lt;- sample(c(TRUE,FALSE), 23, replace = TRUE)
mapDH1 &lt;- subset(mapDH, chr = chrl)
alignCross(mapDH, maps = list(DH = mapDH1), layout = c(3,5), col = 1:7)

</code></pre>

<hr>
<h2 id='ASMap-internal'>Internal fastMap functions</h2><span id='topic+mstmap.default'></span>

<h3>Description</h3>

<p>These are internal <code>fastMap</code> functions that are not intended to be directly called by the user
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
mstmap(object, ...)
</code></pre>


<h3>Author(s)</h3>

<p>Julian Taylor</p>

<hr>
<h2 id='ASMap-package'>
Additional functions for linkage map construction and manipulation of R/qtl
objects.
</h2><span id='topic+ASMap-package'></span>

<h3>Description</h3>

<p>Additional functions for linkage map construction and manipulation of R/qtl
objects. This includes extremely fast linkage map clustering and marker
ordering using MSTmap (see Wu et al., 2008).
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> ASMap</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0-4</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2018-10-24</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL 2</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Welcome to the ASMap package!
</p>
<p>One of the fundamental reasons why this package exists was to utilize
and implement the source code for the the Minimum Spanning Tree
algorithm derived in Wu et al. (2008) (reference
below) for linkage map construction. The algorithm is lightning quick at
linkage group clustering and optimal marker ordering and can handle large numbers of
markers.
</p>
<p>The package contains two very efficient functions, <code>mstmap.data.frame</code>
and <code>mstmap.cross</code>, that provide users with a highly flexible set
linkage map construction methods using the MSTmap
algorithm. <code>mstmap.data.frame</code> constructs a linkage map from
a data frame of genetic marker data and will use the entire
contents of the object to form linkage groups and optimally order
markers within each linkage group. <code>mstmap.cross</code> is a
linkage map construction function for <span class="pkg">qtl</span> package objects and can
be used to construct linkage maps in a flexible number of ways.
See <code>?mstmap.cross</code> for complete details.
</p>
<p>To complement the computationally efficient linkage map construction
functions, the package also contains functions <code>pullCross</code> and
<code>pushCross</code> that allow the pulling/pushing markers of different
types to and from the linkage map. This system gives users the ability
to initially pull markers aside that are not needed for immediate
construction and push them back later if required. There are also
functions for fast numerical and graphical diagnosis of unconstructed
and constructed linkage maps. Specifically, there is an improved
<code>heatMap</code> that graphically displays pairwise recombination
fractions and LOD scores with separate legends for
each. <code>profileGen</code> can be used to simultaneously profile multiple
statistics such as recombination counts and double recombination
counts for individual lines across the constructed linkage
map. <code>profileMark</code> allows simultaneous graphical visualization of
marker or interval statistics profiles across the genome or subsetted
for a predefined set of linkage groups. Graphical identification and
orientation of linkage groups using reference linkage maps can be conducted using
<code>alignCross</code>. All of these graphical functions utilize the power of
the advanced graphics package <span class="pkg">lattice</span> to provide seamless multiple
displays.
</p>
<p>Other miscellaneous utilities for <span class="pkg">qtl</span> objects include
</p>

<ul>
<li> <p><code>mergeCross</code>: Merging of linkage groups
</p>
</li>
<li> <p><code>breakCross</code>: Breaking of linkage groups
</p>
</li>
<li> <p><code>combineMap</code>: Combining linkage maps
</p>
</li>
<li> <p><code>quickEst</code>: Very quick estimation of genetic map distances
</p>
</li>
<li> <p><code>genClones</code>: Reporting genotype clones
</p>
</li>
<li> <p><code>fixClones</code>: Consensus genotypes for clonal groups
</p>
</li></ul>

<p>A comprehensive vignette showcasing the package is now available! It
contains detailed explanations of the functions in the package and how
they can be used to perform efficient map construction. There is a fully
worked example that involves pre-construction diagnostics, linkage map
construction and post construction diagnostics. This example also shows
how functions of the package can be used for post linkage map
construction techniques such as fine mapping and combining linkage maps.
The vignette has be succinctly summarised in the Journal of
Statistical Software publication Taylor and Butler (2017) referenced
below.
</p>


<h3>Author(s)</h3>

<p>Julian Taylor, Dave Butler, Timothy Close, Yonghui Wu, Stefano Lonardi
Maintainer: Julian Taylor &lt;julian.taylor@adelaide.edu.au&gt;
</p>


<h3>References</h3>

<p>Wu, Y., Bhat, P., Close, T.J, Lonardi, S. (2008) Efficient and Accurate
Construction of Genetic Linkage Maps from Minimum Spanning Tree of a
Graph. Plos Genetics, <b>4</b>, Issue 10.
</p>
<p>Taylor, J., Butler, D. (2017) R Package ASMap: Efficient Genetic
Linkage Map Construction and Diagnosis. Journal of Statistical Software,
<b>79</b>(6), 1&ndash;29.
</p>


<h3>See Also</h3>

<p><code><a href="qtl.html#topic+qtl-package">qtl-package</a></code>
</p>

<hr>
<h2 id='breakCross'>
Break linkage groups of an <span class="pkg">qtl</span> cross object
</h2><span id='topic+breakCross'></span>

<h3>Description</h3>

<p>Breaks linkage groups of an <span class="pkg">qtl</span> cross object from a user specified
list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>breakCross(cross, split = NULL, suffix = "numeric", sep = ".")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="breakCross_+3A_cross">cross</code></td>
<td>

<p>An <span class="pkg">qtl</span> <code>cross</code> object with any class structure.
</p>
</td></tr>
<tr><td><code id="breakCross_+3A_split">split</code></td>
<td>

<p>A list named by the linkage groups required for splitting and containing
marker names immediately preceding where the splits are to be made (see
Details).
</p>
</td></tr>
<tr><td><code id="breakCross_+3A_suffix">suffix</code></td>
<td>

<p>This can be a vector of character strings containing <code>"numeric"</code> or
<code>"alpha"</code> specifying whether integers or letters are to be appended to the old linkage group
names to form new names. This argument may also be list with elements named by the
linkage groups that are in <code>split</code> and containing the new names for
the split linkage groups (see Examples).
</p>
</td></tr>
<tr><td><code id="breakCross_+3A_sep">sep</code></td>
<td>

<p>The character separator to be used to separate the linkage group name
and the suffix.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The splitting of any linkage group only needs to be defined by the
markers immediately preceding where the splits are to be made. Multiple
splits in the one linkage group are possible as well as splitting across
multiple linkage groups with one call.
</p>


<h3>Value</h3>

<p>The cross object is returned with identical class structure as the
inputted cross object. The <code>"geno"</code> element will contain
separate linkage groups for the user defined splits.
</p>


<h3>Author(s)</h3>

<p>Julian Taylor
</p>


<h3>References</h3>

<p>Taylor, J., Butler, D. (2017) R Package ASMap: Efficient Genetic
Linkage Map Construction and Diagnosis. Journal of Statistical Software,
<b>79</b>(6), 1&ndash;29.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mergeCross">mergeCross</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mapDH, package = "ASMap")

mapDH1 &lt;- breakCross(mapDH, split = list("4A" = "4A.m.8"))
pull.map(mapDH1)[["4A.1"]]
pull.map(mapDH1)[["4A.2"]]

## manually choose suffix

mapDH1 &lt;- breakCross(mapDH, split = list("4A" = "4A.m.8"),
                     suffix = list("4A" = c("4AA","4AB")))

</code></pre>

<hr>
<h2 id='combineMap'>
Combine linkage maps from multiple <span class="pkg">qtl</span> cross objects
</h2><span id='topic+combineMap'></span>

<h3>Description</h3>

<p>Combine map information, marker data and phenotype data from multiple <span class="pkg">qtl</span> cross objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combineMap(..., id = "Genotype", keep.all = TRUE,
           merge.by = "genotype")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combineMap_+3A_...">...</code></td>
<td>

<p>An unlimited set of arguments with each argument defining an <span class="pkg">qtl</span> cross
object. All <span class="pkg">qtl</span> objects can have any class structure but it must be
identical across objects. (see Details for more information.)
</p>
</td></tr>
<tr><td><code id="combineMap_+3A_id">id</code></td>
<td>

<p>The name of the common column in the <code>pheno</code> element of each cross
object representing the genotype names. Default is <code>"Genotype"</code>.
</p>
</td></tr>
<tr><td><code id="combineMap_+3A_keep.all">keep.all</code></td>
<td>

<p>A logical value determining whether all genotypes should be kept in the
final linkage map regardless of their absence in some linkage maps (see
Details). Default is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="combineMap_+3A_merge.by">merge.by</code></td>
<td>

<p>A character string. If &quot;genotype&quot; then combining of maps occurs by
common genotypes and if &quot;marker&quot; combining of maps occurs by common
markers. Default is &quot;genotype&quot;. (see Details for more information.)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function combines linkage maps from multiple <span class="pkg">qtl</span> cross
objects by merging marker data and map information as well as phenotypic
data if present. The function contains some initial checks before
proceeding with the combining. Firstly, all <span class="pkg">qtl</span> cross objects must
have the same class structure and have a column in the <code>pheno</code>
element of the object named by the argument <code>id</code>. The symbol &quot;;&quot;
should be avoided in markers as this is reserved for string manipulation
within the function.
</p>
<p>If <code>merge.by = "genotype"</code> then the combining occurs sequentially
across linkage maps based on common genotype names. If
<code>keep.all=TRUE</code> then the marker set and phenotypic data are
&quot;padded out&quot; when genotype names are not shared between maps. If
<code>keep.all=FALSE</code> then the marker set and phenotype data are shrunk
to only include genotypes that are shared among all linkage
maps. Marker names must be unique across the set of linkage
maps. Non-matching genotype names between linkage maps will expand the
final marker data and phenotypic data so it is prudent to check genotype
names are correct in each of the linkage maps before combining.
</p>
<p>If <code>merge.by = "marker"</code> then the combining occurs
sequentially across linkage maps based on common markers. If
<code>keep.all=TRUE</code> then the marker set is
&quot;padded out&quot; when marker names are not shared between maps. If
<code>keep.all=FALSE</code> then the marker set is shrunk
to only include markers that are shared among all linkage
maps. Genotypes must be unique across the set of linkage maps. It should
be noted, this function does not use a consensus map
algorithm to determine chromosome identification and genetic distances
of common markers. These are both calculated using the first instance of
the markers appearance across the sequential maps. This makes it ideal
for potentially pushing additional genotypes into an established map.
</p>
<p>For both <code>merge.by</code> types, if a linkage group name is shared across
linkage maps then the marker data from the shared linkage group in each
of the maps will be merged. If maps share the same
linkage group names and do not require merging the duplicate linkage
group names in one of the linkage maps will need to be altered before
combining. As a final process, markers are ordered within linkage groups
according to distances supplied in each of the linkage maps.
</p>
<p>It should also be noted that this function does not re-construct the
final linkage map after combining the set of linkage maps. For efficient
linkage map reconstruction of a combined <span class="pkg">qtl</span> object see
<code>mstmap.cross()</code>.
</p>


<h3>Value</h3>

<p>A single R/qtl cross object is returned with identical class structure as the
inputted cross objects.
</p>


<h3>Author(s)</h3>

<p>Julian Taylor
</p>


<h3>References</h3>

<p>Taylor, J., Butler, D. (2017) R Package ASMap: Efficient Genetic
Linkage Map Construction and Diagnosis. Journal of Statistical Software,
<b>79</b>(6), 1&ndash;29.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+breakCross">breakCross</a></code> and <code><a href="#topic+mergeCross">mergeCross</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mapDH, package = "ASMap")

## create copy of mapDH with some different linkage groups
## and change marker names so they are unique

mapDH1 &lt;- mapDH
names(mapDH1$geno)[5:14] &lt;- paste("L",1:10, sep = "")
mapDH1$geno &lt;- lapply(mapDH1$geno, function(el){
    nam &lt;- paste(names(el$map), "A", sep = "")
    names(el$map) &lt;- dimnames(el$data)[[2]] &lt;- nam
    el})

mapDHc &lt;- combineMap(mapDH, mapDH1)
nmar(mapDHc)
</code></pre>

<hr>
<h2 id='fixClones'>
Consensus genotypes for clonal genotype groups
</h2><span id='topic+fixClones'></span>

<h3>Description</h3>

<p>Consensus genotypes for clonal genotype groups of an R/qtl object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixClones(object, gc, id = "Genotype", consensus = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixClones_+3A_object">object</code></td>
<td>

<p>An <span class="pkg">qtl</span> <code>object</code> object with any class structure.
</p>
</td></tr>
<tr><td><code id="fixClones_+3A_gc">gc</code></td>
<td>

<p>A data frame of genotype clone infomation usually from a call to
<code>genClones</code> (see Details).
</p>
</td></tr>
<tr><td><code id="fixClones_+3A_id">id</code></td>
<td>

<p>Character string defining the column of <code>object$pheno</code> containing
the genotype names.
</p>
</td></tr>
<tr><td><code id="fixClones_+3A_consensus">consensus</code></td>
<td>

<p>A logical value. If <code>TRUE</code> then consensus genotypes will be
calculated for each clonal group by intelligently collapsing alleles for each marker
(see Details). If <code>FALSE</code> then for each clonal group the genotype with the least missing
alleles across the genome will be retained and the remaining genotypes
from each group will be removed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides a very efficient way of dealing with genotype
clones in a genetic marker set. This function can be used at any stage
of the map construction process as it retains linkage group and marker
position information.
</p>
<p>The <code>gc</code> argument needs to be a data frame of clone
information and is easily obtained from a call to <code>genClones</code>. If
this function is not used then the data frame must contain at least three
columns with the first two columns named <code>"G1"</code> and <code>"G2"</code>
containing the pairs of genotypes that are clones and a <code>"group"</code>
column that indicates the clonal group the pairs of genotypes belongs to.
</p>
<p>If <code>consensus = TRUE</code> then the function will intelligently collapse
the alleles for each marker to form a consensus genotype. Specifically, the allele
value will remain unchanged when there are observed allele values
across all genotypes in the clone group. For cases where there are
missing alleles for some but not all of the
genotypes, the consensus genotype will be given the common allele value
from the genotypes that contained observed allele values. If there is
more than one unique allele value across the genotypes for any marker
then it is set to missing.
</p>


<h3>Value</h3>

<p>The cross object is returned with identical class structure as the
imputted cross object.
</p>


<h3>Author(s)</h3>

<p>Julian Taylor
</p>


<h3>References</h3>

<p>Taylor, J., Butler, D. (2017) R Package ASMap: Efficient Genetic
Linkage Map Construction and Diagnosis. Journal of Statistical Software,
<b>79</b>(6), 1&ndash;29.
</p>


<h3>See Also</h3>

<p><code><a href="qtl.html#topic+comparegeno">comparegeno</a></code> and <code><a href="#topic+genClones">genClones</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mapDH, package = "ASMap")

gc &lt;- genClones(mapDH)
mapDHf &lt;- fixClones(mapDH, gc$cgd, consensus = TRUE)

</code></pre>

<hr>
<h2 id='genClones'>
Find and report genotype clones
</h2><span id='topic+genClones'></span>

<h3>Description</h3>

<p>Find and report genotype clones for <span class="pkg">qtl</span> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genClones(object, chr, tol = 0.9, id = "Genotype")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genClones_+3A_object">object</code></td>
<td>

<p>An <span class="pkg">qtl</span> <code>object</code> object with any class structure.
</p>
</td></tr>
<tr><td><code id="genClones_+3A_chr">chr</code></td>
<td>

<p>A character string of linkage group names.
</p>
</td></tr>
<tr><td><code id="genClones_+3A_tol">tol</code></td>
<td>

<p>Pairs of genotypes with a proporion of matching alleles above this
tolerance will be returned.
</p>
</td></tr>
<tr><td><code id="genClones_+3A_id">id</code></td>
<td>

<p>Character string defining the column of <code>object$pheno</code> containing
the genotype names.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function extends the functionality of <code>comparegeno</code> in the
<span class="pkg">qtl</span> package by providing breakdown statistics for the pairs of
genotypes that have a proportion of matching alleles above <code>tol</code>.
</p>


<h3>Value</h3>

<p>A list is returned with the matrix from <code>comparegeno</code> as an element
<code>cgm</code> and the breakdown statistics for returned genotype pairs in
<code>cgd</code>. Specifically, the statistics contain a <code>"group"</code> column
which determines the clonal group the pair of genotypes belongs to.
</p>


<h3>Author(s)</h3>

<p>Julian Taylor
</p>


<h3>References</h3>

<p>Taylor, J., Butler, D. (2017) R Package ASMap: Efficient Genetic
Linkage Map Construction and Diagnosis. Journal of Statistical Software,
<b>79</b>(6), 1&ndash;29.
</p>


<h3>See Also</h3>

<p><code><a href="qtl.html#topic+comparegeno">comparegeno</a></code> and <code><a href="#topic+fixClones">fixClones</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mapDH, package = "ASMap")

gc &lt;- genClones(mapDH)

</code></pre>

<hr>
<h2 id='heatMap'>
Heat map of the estimated pairwise recombination fractions and LOD
linkage between markers.
</h2><span id='topic+heatMap'></span>

<h3>Description</h3>

<p>Heat map of the estimated pairwise recombination fractions and LOD
linkage between markers that provides extended functionality of Bromans
<span class="pkg">qtl</span> package <code>plotRF</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heatMap(x, chr, mark, what = c("both", "lod", "rf"), lmax = 12,
   rmin = 0, markDiagonal = FALSE, color =
rev(colorRampPalette(brewer.pal(11,"Spectral"))(256)),  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="heatMap_+3A_x">x</code></td>
<td>

<p>A <code>"cross"</code> object generated from the <span class="pkg">qtl</span> package.
</p>
</td></tr>
<tr><td><code id="heatMap_+3A_chr">chr</code></td>
<td>

<p>A character string of linkage group names to subset the cross object.
</p>
</td></tr>
<tr><td><code id="heatMap_+3A_mark">mark</code></td>
<td>

<p>An argument to subset linkage groups further into marker subsets. This
can be a single numerical vector of markers positions which will
subset all linkage groups in the same manner. Or it may be a list of
numerical vectors named by the linkage group names with which to subset
the linkage groups separately.
</p>
</td></tr>
<tr><td><code id="heatMap_+3A_what">what</code></td>
<td>

<p>A character string of either <code>"lod"</code>, <code>"rf"</code> or
<code>"both"</code>. If <code>"lod"</code> only pairwise LOD scores between markers
are plotted. If <code>"rf"</code> then only pairwise recombination fractions
between markers are plotted. If <code>"both"</code> then both are plotted
with LOD on the lower triangle and recombination in the upper
triangle. This is the default (see Details).
</p>
</td></tr>
<tr><td><code id="heatMap_+3A_lmax">lmax</code></td>
<td>

<p>The threshold LOD score to implemented. Scores above this threshold will be
plotted at the same colour.
</p>
</td></tr>
<tr><td><code id="heatMap_+3A_rmin">rmin</code></td>
<td>

<p>The threshold recombination fraction to be implemented. Recombination
fractions below this threshold will be plotted at the same colour.
</p>
</td></tr>
<tr><td><code id="heatMap_+3A_markdiagonal">markDiagonal</code></td>
<td>

<p>Logical value. If <code>TRUE</code> then borders are added around the diagonal
elements of the heat map.
</p>
</td></tr>
<tr><td><code id="heatMap_+3A_color">color</code></td>
<td>

<p>The colour spectrum used to display the heat map. The default is a
<code>"Spectral"</code> diverging palette from the <span class="pkg">RColorBrewer</span> package (see Details).
</p>
</td></tr>
<tr><td><code id="heatMap_+3A_...">...</code></td>
<td>

<p>There are additional features available through this argument that
can be used to customize the heatmap (see Details).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a rewrite of Bromans <span class="pkg">qtl</span> package function
<code>plot.rf</code> that provides extended functionality. When <code>what =
  "lod"</code> is chosen the pairwise LOD linkage
between markers is displayed on the heat map with
a legend on the right hand side spanning zero to <code>lmax</code> across the
<code>color</code> spectrum. If <code>what = "rf"</code> the pairwise estimated recombination
fractions are displayed on the heat map with a legend on the right hand side spanning
<code>rmin</code> to 0.5 across the <code>color</code> spectrum. The legend also
extends past 0.5 to display estimated recombination fractions between
0.5 and one through a colour spectrum of the maximum <code>color</code> value
to white. This functionality now gives users the ability to detect
markers that may be problematic or possibly out of phase. For <code>what
  = "both"</code> the pairwise LOD linkage is displayed on the lower triangle of the
heat map and the pairwise estimated recombination fractions are
displayed on the upper triangle. If this option is chosen, legends are displayed for both
components of the heat map.
</p>
<p>The default colour spectrum is the diverging palette <code>"Spectral"</code>
from the <span class="pkg">RcolorBrewer</span> package. This diverging palette
provides an aesthetically pleasing colour spectrum for the
diagnosis of pairwise linkage between markers. Specifically, the palette
displays weak linkage and/or low recombination between markers as blue
or &quot;cool&quot; areas and strong linkage and/or recombination between markers are
shown as red or &quot;hot&quot; areas.
</p>
<p>Much of the extra functionality of this function comes from the use of
<code>image.plot</code> in the <span class="pkg">fields</span> package. This function allows the
partitioning of the plotting region into a <code>bigplot</code> region for the
heat map and a <code>smallplot</code> region for the legend. This is called
twice when <code>what = "both"</code>. The size of the regions can be
manipulated by passing the <code>bigplot</code> or <code>smallplot</code> arguments
to the function but it is advised to use the defaults. Further
manipulation of the heat map can achieved by passing other arguments of
the function <code>image.plot</code>. Users should consult the help file for
<code>image.plot</code> for more details. It should be noted that the
argument <code>legend.args</code> needs to be avoided as it used in this
function.
</p>


<h3>Value</h3>

<p>A heat map is displayed on the current plotting device.
</p>


<h3>Author(s)</h3>

<p>Julian Taylor
</p>


<h3>References</h3>

<p>Taylor, J., Butler, D. (2017) R Package ASMap: Efficient Genetic
Linkage Map Construction and Diagnosis. Journal of Statistical Software,
<b>79</b>(6), 1&ndash;29.
</p>


<h3>See Also</h3>

<p><code><a href="qtl.html#topic+plotRF">plotRF</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mapDH, package = "ASMap")

## bulking linkage groups and reconstructing entire linkage map

test1 &lt;- mstmap(mapDH, bychr = FALSE, dist.fun = "kosambi",
                trace = FALSE)

## plot heat map of result

heatMap(test1, lmax = 30)

</code></pre>

<hr>
<h2 id='mapBC'>A constructed linkage map for a backcross barley population</h2><span id='topic+mapBC'></span>

<h3>Description</h3>

<p>A constructed linkage map for a backcross
barley population in the form of a constructed <span class="pkg">qtl</span> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mapBC)</code></pre>


<h3>Format</h3>

<p>This data relates to a fully constructed linkage map of 3019
markers genotyped on 300 individuals spanning the 7 linkage groups of
the barley genome. The map was constructed using the MSTmap algorithm
integrated in <code><a href="#topic+mstmap.cross">mstmap.cross</a></code> with geentic distances estimated
using the <code>"kosambi"</code> mapping function. The data is in <span class="pkg">qtl</span>
format with a class structure <code>c("bc","cross")</code>. See
<code>read.cross()</code> documentation for more details on the
format of this object.
</p>


<h3>References</h3>

<p>Taylor, J., Butler, D. (2017) R Package ASMap: Efficient Genetic
Linkage Map Construction and Diagnosis. Journal of Statistical Software,
<b>79</b>(6), 1&ndash;29.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mapBC, package = "ASMap")

</code></pre>

<hr>
<h2 id='mapBCu'>An unconstructed marker set for a backcross barley population</h2><span id='topic+mapBCu'></span>

<h3>Description</h3>

<p>An unconstructed marker set for a backcross
barley population in the form of an <span class="pkg">qtl</span> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mapBCu)</code></pre>


<h3>Format</h3>

<p>This data relates to an unconstructed version of
<code><a href="#topic+mapBC">mapBC</a></code> and consists of 3023 markers genotyped on 326
individuals with markers randomly assorted on one large linkage group.
The data is in <span class="pkg">qtl</span> format with a class structure
<code>c("bc","cross")</code>. See <code>read.cross()</code> documentation for more
details on the format of this object. This data set forms the basis of
the worked example in Chapter 3 of the vignette (see vignette(&quot;ASMap&quot;)
for complete details)
</p>


<h3>References</h3>

<p>Taylor, J., Butler, D. (2017) R Package ASMap: Efficient Genetic
Linkage Map Construction and Diagnosis. Journal of Statistical Software,
<b>79</b>(6), 1&ndash;29.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mapBCu, package = "ASMap")

</code></pre>

<hr>
<h2 id='mapDH'>A constructed linkage map for a doubled haploid wheat population</h2><span id='topic+mapDH'></span>

<h3>Description</h3>

<p>A constructed linkage map for a doubled
haploid wheat population in the form of a constructed <span class="pkg">qtl</span> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mapDH)</code></pre>


<h3>Format</h3>

<p>This data relates to a fully constructed linkage map of 599
markers genotyped on 218 individuals. The linkage map consists of 23
linkage groups spanning the whole genome. 584 markers are from the
orignal map with an additonal 12 co-located markers and 3 slightly
distorted markers. The map was constructed using the MSTmap algorithm
integrated in<code><a href="#topic+mstmap.cross">mstmap.cross</a></code> with geentic distances estimated
using the <code>"kosambi"</code> mapping function. The data is in <span class="pkg">qtl</span>
format with a class structure <code>c("bc","cross")</code>. See
<code>read.cross</code> documentation for more details on the
format of this object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mapDH, package = "ASMap")

</code></pre>

<hr>
<h2 id='mapDHf'>An unconstructed marker set for a doubled haploid wheat population</h2><span id='topic+mapDHf'></span>

<h3>Description</h3>

<p>An unconstructed marker set for a doubled
haploid wheat population in the form of a constructed <span class="pkg">qtl</span> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mapDHf)</code></pre>


<h3>Format</h3>

<p>This data is the unconstructed version of <code><a href="#topic+mapDH">mapDH</a></code>
and consists of 599 markers genotyped on 218 individuals. 584 markers
are from the orignal map with an additonal 12 co-located markers and
3 slightly distorted markers. The data is in a <code>data.frame</code> format
with genotypes in columns and randomly assorted markers in rows. See
<code><a href="#topic+mstmap.data.frame">mstmap.data.frame</a></code> documentation for more details on the format
of this object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mapDHf, package = "ASMap")

</code></pre>

<hr>
<h2 id='mapF2'>Simulated constructed linkage map for a self pollinated F2 barley population</h2><span id='topic+mapF2'></span>

<h3>Description</h3>

<p>Simulated constructed linkage map for a self pollinated F2
barley population in the form of an <span class="pkg">qtl</span> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mapF2)</code></pre>


<h3>Format</h3>

<p>This data relates to a fully constructed linkage map of 700
simulated markers genotyped on 250
individuals. The map consists of 7 linkage groups, each contaning 100
markers spanning an approximate linkage group length of 200cM. The map was
constructed using <code><a href="#topic+mstmap.cross">mstmap.cross</a></code> from the <span class="pkg">ASMap</span> package and
map distances were estimated using the <code>"kosambi"</code>
mapping function. The data is in R/qtl format with a class structure
<code>c("bcsft","cross")</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mapF2, package = "ASMap")

</code></pre>

<hr>
<h2 id='mergeCross'>
Merge linkage groups of an <span class="pkg">qtl</span> cross object
</h2><span id='topic+mergeCross'></span>

<h3>Description</h3>

<p>Merges linkage groups of an <span class="pkg">qtl</span> cross object from a user specified list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeCross(cross, merge = NULL, gap = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergeCross_+3A_cross">cross</code></td>
<td>

<p>An <span class="pkg">qtl</span> <code>cross</code> object with any class structure.
</p>
</td></tr>
<tr><td><code id="mergeCross_+3A_merge">merge</code></td>
<td>

<p>A list with elements containing the linkage groups to be merged with
each element named by the proposed linkage group name (see Examples).
</p>
</td></tr>
<tr><td><code id="mergeCross_+3A_gap">gap</code></td>
<td>

<p>The cM gap to put between the merged map elements in the complete linkage group.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This merging function allows you to perform multiple merges of two or more linkage groups
in one call. Users should ensure linkage group names are correct and
that proposed linkage group names do not already exist.
</p>


<h3>Value</h3>

<p>The cross object is returned with identical class structure as the
inputted cross object. The <code>"geno"</code> element should now contain
merged linkage groups for the user defined merges.
</p>


<h3>Author(s)</h3>

<p>Julian Taylor
</p>


<h3>References</h3>

<p>Taylor, J., Butler, D. (2017) R Package ASMap: Efficient Genetic
Linkage Map Construction and Diagnosis. Journal of Statistical Software,
<b>79</b>(6), 1&ndash;29.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+breakCross">breakCross</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mapDH, package = "ASMap")

mapDH1 &lt;- breakCross(mapDH, split = list("4A" = "4A.m.8"))
pull.map(mapDH1)[["4A.1"]]
pull.map(mapDH1)[["4A.2"]]

mapDH2 &lt;- mergeCross(mapDH1, merge = list("4A" = c("4A.1","4A.2")))
pull.map(mapDH2)[["4A"]]
</code></pre>

<hr>
<h2 id='mstmap.cross'>
Extremely fast linkage map construction for <span class="pkg">qtl</span> objects using MSTmap.
</h2><span id='topic+mstmap.cross'></span><span id='topic+mstmap'></span>

<h3>Description</h3>

<p>Extremely fast linkage map construction for <span class="pkg">qtl</span> objects using the
source code for MSTmap (see Wu et al., 2008). The construction includes
linkage group clustering, marker ordering and genetic distance calculations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cross'
mstmap(object, chr, id = "Genotype", bychr = TRUE,
       suffix = "numeric", anchor = FALSE, dist.fun = "kosambi",
       objective.fun = "COUNT", p.value = 1e-06, noMap.dist = 15,
       noMap.size = 0, miss.thresh = 1, mvest.bc = FALSE,
       detectBadData = FALSE, return.imputed = FALSE,
       trace = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mstmap.cross_+3A_object">object</code></td>
<td>

<p>A <code>"cross"</code> object generated from the <span class="pkg">qtl</span> package. Specifically
the object needs to inherit from one of the following classes
<code>"bc"</code>, <code>"dh"</code>, <code>"riself"</code>, <code>"bcsft"</code> (see Details).
</p>
</td></tr>
<tr><td><code id="mstmap.cross_+3A_chr">chr</code></td>
<td>

<p>A character string of linkage group names that require re-construction
and/or optimal ordering of the markers they contain.
(see Details).
</p>
</td></tr>
<tr><td><code id="mstmap.cross_+3A_id">id</code></td>
<td>

<p>The name of the column in <code>object$pheno</code> that uniquely identifies the
genotype names. Default is <code>"Genotype"</code>.
</p>
</td></tr>
<tr><td><code id="mstmap.cross_+3A_bychr">bychr</code></td>
<td>

<p>Logical value. For a given set of linkage groups defined by <code>chr</code>,
if <code>TRUE</code> then split linkage groups (only if required, see
<code>p.value</code>) and order markers within linkage groups. If <code>FALSE</code> then combine
linkage groups and reconstruct. Default is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="mstmap.cross_+3A_suffix">suffix</code></td>
<td>

<p>Character string either <code>"numeric"</code> or <code>"alpha"</code> determining
whether numeric or alphabetic ascending values are post-fixed to linkage
group names when splitting linkage groups.
</p>
</td></tr>
<tr><td><code id="mstmap.cross_+3A_anchor">anchor</code></td>
<td>

<p>Logical value. The MSTmap algorithm does not respect the inputted marker
order of the linkage map required for construction. For a given set of
linkage groups defined by <code>chr</code>, if <code>TRUE</code> the order of the
inputted markers is respected regardless of the choices of <code>chr</code>
and <code>bychr</code>. Default is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="mstmap.cross_+3A_dist.fun">dist.fun</code></td>
<td>

<p>Character string defining the distance function used for calculation of
genetic distances. Options are &quot;kosambi&quot; and &quot;haldane&quot;. Default is &quot;kosambi&quot;.
</p>
</td></tr>
<tr><td><code id="mstmap.cross_+3A_objective.fun">objective.fun</code></td>
<td>

<p>Character string defining the objective function to be used when
constructing the map. Options are <code>"COUNT"</code> for minimising the sum of
recombination events between markers and <code>"ML"</code> for maximising the
likelihood objective function. Default is <code>"COUNT"</code>.
</p>
</td></tr>
<tr><td><code id="mstmap.cross_+3A_p.value">p.value</code></td>
<td>

<p>Numerical value to specify the threshold to use when clustering
markers. Defaults to <code>1e-06</code>. If a value greater than one
is given this feature is turned off inputted marker data are assumed to
belong to the same linkage group (see Details).
</p>
</td></tr>
<tr><td><code id="mstmap.cross_+3A_nomap.dist">noMap.dist</code></td>
<td>

<p>Numerical value to specify the smallest genetic distance a set of
isolated markers can appear distinct from other linked markers. Isolated
markers will appear in their own linkage groups and will be of size
specified by <code>noMap.size</code>.
</p>
</td></tr>
<tr><td><code id="mstmap.cross_+3A_nomap.size">noMap.size</code></td>
<td>

<p>Numerical value to specify the maximum size of isolated marker linkage
groups that have been identified using <code>noMap.dist</code>. This feature
can be turned off by setting it to 0. Default is 0.
</p>
</td></tr>
<tr><td><code id="mstmap.cross_+3A_miss.thresh">miss.thresh</code></td>
<td>

<p>Numerical value to specify the threshold proportion of missing marker
scores allowable in each of the markers. Markers above this threshold
will not be included in the linkage map. Default is 1.
</p>
</td></tr>
<tr><td><code id="mstmap.cross_+3A_mvest.bc">mvest.bc</code></td>
<td>

<p>Logical value. If <code>TRUE</code> missing markers will be imputed
before clustering the markers into linkage groups. This is restricted
to <code>"bc","dh","riself"</code> populations only (see Details). Default is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="mstmap.cross_+3A_detectbaddata">detectBadData</code></td>
<td>

<p>Logical value. If <code>TRUE</code> possible genotyping errors are detected,
set to missing and then imputed as part of the
marker ordering algorithm. Genotyping errors will also be printed in the
file specified by <code>trace</code>.  This is restricted
to <code>"bc","dh","riself"</code> populations only. (see Details). Default is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="mstmap.cross_+3A_return.imputed">return.imputed</code></td>
<td>

<p>Logical value. If <code>TRUE</code> then the imputed marker probability matrix is
returned for the linkage groups that are constructed (see
Details). Default is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="mstmap.cross_+3A_trace">trace</code></td>
<td>

<p>An automatic tracing facility. If <code>trace = FALSE</code> then
minimal <code>MSTmap</code> output is piped to the screen during the algorithm.
If <code>trace = TRUE</code>, then detailed output from MSTmap is
piped to <code>"MSToutput.txt"</code>. This file is equivalent to the output that
would be obtained from running the MSTmap executable from the command line.
</p>
</td></tr>
<tr><td><code id="mstmap.cross_+3A_...">...</code></td>
<td>

<p>Currently ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <span class="pkg">qtl</span> cross object needs to inherit one of the allowable classes
<code>"bc","dh","riself", "bcsft"</code>. This provides a safeguard against
attempts to construct a map for more complex populations that can
exist in <span class="pkg">qtl</span>. Users should be aware when doubled haploid
populations are read in using <code>read.cross()</code> from the <span class="pkg">qtl</span>
package they inherit the class <code>"bc"</code>. Users can apply the class
<code>"dh"</code> by simply changing the class of the object. For the purpose
of linkage map construction the classes <code>"bc"</code> and <code>"dh"</code> will
provide equivalent results.
</p>
<p>MSTmap supports <code>"RILn"</code> populations, where n is the number of generations
of selfing. Markers in these populations are required to be fully
informative i.e. contain 3 distinct allele types such as AA, BB for
parental homozygotes and AB for phase unknown heterozygotes.
If <code>read.cross</code> is used to import the <code>"RILn"</code> population the resultant
object will initially be given a class <code>"f2"</code>. The level of selfing
would then have to be encoded into the object by applying one of the two conversion
functions available in the <span class="pkg">qtl</span> package. For a
population that has been generated by selfing n times the conversion
function <code>convert2bcsft</code> can be used by setting the arguments
<code>F.gen = n</code> and <code>BC.gen = 0</code>. Populations that are genuine
advanced RILs can be converted using the <code>convert2riself</code> function.
</p>
<p>This method function is designed to be an &quot;all-in-one&quot; function that
will allow you to construct linkage maps extremely fast in multiple
different ways from the supplied cross <code>object</code>. Initially, the map
can be kept complete or a subset of selected linkage groups can be chosen
using the <code>chr</code> argument. Setting <code>bychr = FALSE</code> will
bulk the marker information for the selected linkage groups and, if
necessary, form new linkage groups and optimise the marker order within
each. Setting <code>bychr = TRUE</code> will ensure that markers
are optimally ordered within each linkage group. This will also break
linkage groups depending on the p-value given in the call (see
below for details of the use of <code>p.value</code>). If the
linkage map was initially subsetted, the linkage groups not involved in
the subset are returned to ensure the map is complete.
</p>
<p>The algorithm allows an adjustment of the <code>p.value</code> threshold for
clustering of markers to distinct linkage groups (see Wu et al.,
2008) and is highly dependent on the number of individuals in
the population. As the number of individuals increases the
<code>p.value</code> threshold should be decreased accordingly. This may
require some trial and error to achieve desired results.
When <code>bychr = TRUE</code>, established linkage groups may also split
depending on the <code>p.value</code> given. To prevent this the <code>p.value</code> threshold
may be increased to a desired value or the splitting may be prevented
altogether by supplying a value greater than one to this argument.
</p>
<p>If <code>mvest.bc = TRUE</code> and the population type is <code>"bc","dh","riself"</code>
then missing values are imputed before markers are clustered into
linkage groups. This is only a simple imputation that places a 0.5
probability of the missing observation being one allele or the other and
is used to assist the clustering algorithm when there is known to be high numbers of
missing observations between pairs of markers.
</p>
<p>It should be highlighted that for population types
<code>"bc","dh","riself"</code>, imputation of missing values occurs
regardless of the value of <code>mvest.bc</code>. This is achieved using an EM algorithm that is
tightly coupled with marker ordering (see Wu et al., 2008). Initially
a marker order is obtained omitting missing marker scores and then
imputation is performed based on the underlying recombinant probabilities
of the flanking markers with the markers containing the missing
value. The recombinant probabilities are then recomputed and an update of
the pairwise distances are calculated. The ordering algorithm is then
run again and the complete process is repeated until
convergence. Note, the imputed probability matrix for the linkage map
being constructed is returned if <code>return.imputed = TRUE</code>.
</p>
<p>For populations <code>"bc","dh","riself"</code>, if <code>detectBadData =
  TRUE</code> the marker ordering algorithm also
includes the detection of genotyping errors. For any individual
genotype, the detection method is based on a weighted Euclidean metric
(see Wu et al., 2008) that is a function of the
recombination probabilities of all the markers with the marker containing
the suspicious observation. Any genotyping errors detected are set to
missing and the missing values are then imputed as part of the marker
ordering algorithm. Note, the detection of these errors and their
amendment can be returned in the imputed probability matrix if
<code>return.imputed = TRUE</code>.
</p>
<p>If <code>return.imputed = TRUE</code> and the object has class
<code>"bc","dh","riself"</code> then the marker probability matrix is
returned for the linkage groups that have been constructed using the
algorithm. Each linkage group is named identically to the linkage groups
of the map and contains an ordered <code>"map"</code> element and a <code>"data"</code>
element consisting of marker probabilities of the A allele being
present (i.e. P(A) = 1, P(B) = 0). Both elements contain a
possibly reduced version of the marker set that includes all
non-colocating markers as well as the first marker of any set of
co-locating markers.
</p>


<h3>Value</h3>

<p>The function returns a cross object with an identical class
structure to the cross <code>object</code> inputted. The object is a list
with usual components <code>"pheno"</code> and <code>"geno"</code>. If markers were
omitted for any reason during the construction, the object will have an
<code>"omit"</code> component with all omitted markers in a collated
matrix. If <code>return.imputed = TRUE</code> then the object will also
contain an <code>"imputed.geno"</code> element.
</p>


<h3>Author(s)</h3>

<p>Julian Taylor, Dave Butler, Timothy Close, Yonghui Wu, Stefano Lonardi
</p>


<h3>References</h3>

<p>Wu, Y., Bhat, P., Close, T.J, Lonardi, S. (2008) Efficient and Accurate
Construction of Genetic Linkage Maps from Minimum Spanning Tree of a
Graph. Plos Genetics, <b>4</b>, Issue 10.
</p>
<p>Taylor, J., Butler, D. (2017) R Package ASMap: Efficient Genetic
Linkage Map Construction and Diagnosis. Journal of Statistical Software,
<b>79</b>(6), 1&ndash;29.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mstmap.data.frame">mstmap.data.frame</a></code> and <code><a href="#topic+breakCross">breakCross</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mapDH, package = "ASMap")

## bulking linkage groups and reconstructing entire linkage map

test1 &lt;- mstmap(mapDH, bychr = FALSE, dist.fun = "kosambi",
                trace = FALSE)
pull.map(test1)

## one linkage group at a time (possibly break established linkage
## groups)

test2 &lt;- mstmap(mapDH, bychr = TRUE, dist.fun = "kosambi", trace = FALSE)
pull.map(test2)

## one linkage group at a time (do not break established linkage groups)

test3 &lt;- mstmap(mapDH, bychr = TRUE, dist.fun = "kosambi", p.value = 2,
                trace = FALSE)
pull.map(test3)

## impute before clustering and detect genotyping errors, pipe output to
## file

test4 &lt;- mstmap(mapDH, bychr = FALSE, dist.fun = "kosambi",
                trace = TRUE, mvest.bc = TRUE, detectBadData = TRUE)
pull.map(test4)
unlink("MSToutput.txt")

</code></pre>

<hr>
<h2 id='mstmap.data.frame'>
Extremely fast linkage map construction for data frame objects using MSTmap.
</h2><span id='topic+mstmap.data.frame'></span>

<h3>Description</h3>

<p>Extremely fast linkage map construction for data frame objects utilizing the
source code for MSTmap (see Wu et al., 2008). The construction includes
linkage group clustering, marker ordering and genetic distance calculations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.frame'
mstmap(object, pop.type = "DH", dist.fun = "kosambi",
      objective.fun = "COUNT", p.value = 1e-06, noMap.dist = 15,
      noMap.size = 0, miss.thresh = 1, mvest.bc = FALSE,
      detectBadData = FALSE, as.cross = TRUE, return.imputed = FALSE,
      trace = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mstmap.data.frame_+3A_object">object</code></td>
<td>

<p>A <code>"data.frame"</code> object containing marker information. The
data.frame must explicitly be arranged with markers in rows and
genotypes in columns. Marker names are obtained from the <code>rownames</code> of the
<code>object</code> and genotype names are obtained from the <code>names</code>
component of the <code>object</code> (see Details).
</p>
</td></tr>
<tr><td><code id="mstmap.data.frame_+3A_pop.type">pop.type</code></td>
<td>

<p>Character string specifying the population type of the data frame
<code>object</code>. Accepted values are <code>"DH"</code> (doubled haploid),
<code>"BC"</code> (backcross), <code>"RILn"</code> (non-advanced RIL population with
n generations of selfing) and <code>"ARIL"</code> (advanced RIL) (see
Details). Default is <code>"DH"</code>.
</p>
</td></tr>
<tr><td><code id="mstmap.data.frame_+3A_dist.fun">dist.fun</code></td>
<td>

<p>Character string defining the distance function used for calculation of
genetic distances. Options are <code>"kosambi"</code> and <code>"haldane"</code>.
Default is <code>"kosambi"</code>.
</p>
</td></tr>
<tr><td><code id="mstmap.data.frame_+3A_objective.fun">objective.fun</code></td>
<td>

<p>Character string defining the objective function to be used when
constructing the map. Options are <code>"COUNT"</code> for minimising the sum of
recombination events between markers and <code>"ML"</code> for maximising the
likelihood objective function. Default is <code>"COUNT"</code>.
</p>
</td></tr>
<tr><td><code id="mstmap.data.frame_+3A_p.value">p.value</code></td>
<td>

<p>Numerical value to specify the threshold to use when clustering
markers. Defaults to <code>1e-06</code>. If a value greater than one
is given this feature is turned off inputted marker data are assumed to
belong to the same linkage group (see Details).
</p>
</td></tr>
<tr><td><code id="mstmap.data.frame_+3A_nomap.dist">noMap.dist</code></td>
<td>

<p>Numerical value to specify the smallest genetic distance a set of
isolated markers can appear distinct from other linked markers. Isolated
markers will appear in their own linkage groups ad will be of size
specified by <code>noMap.size</code>.
</p>
</td></tr>
<tr><td><code id="mstmap.data.frame_+3A_nomap.size">noMap.size</code></td>
<td>

<p>Numerical value to specify the maximum size of isolated marker linkage
groups that have been identified using <code>noMap.dist</code>. This feature
can be turned off by setting it to 0. Default is 0.
</p>
</td></tr>
<tr><td><code id="mstmap.data.frame_+3A_miss.thresh">miss.thresh</code></td>
<td>

<p>Numerical value to specify the threshold proportion of missing marker
scores allowable in each of the markers. Markers above this threshold
will not be included in the linkage map. Default is 1.
</p>
</td></tr>
<tr><td><code id="mstmap.data.frame_+3A_mvest.bc">mvest.bc</code></td>
<td>

<p>Logical value. If <code>TRUE</code> missing markers will be imputed
before clustering the markers into linkage groups.  This is restricted
to <code>"BC","DH","ARIL"</code> populations only (see Details).
</p>
</td></tr>
<tr><td><code id="mstmap.data.frame_+3A_detectbaddata">detectBadData</code></td>
<td>

<p>Logical value. If <code>TRUE</code> possible genotyping errors are detected,
set to missing and then imputed as part of the
marker ordering algorithm. Genotyping errors will also be printed in the
file specified by <code>trace</code>.  This is restricted
to <code>"BC","DH","ARIL"</code> populations only. (see Details). Default is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="mstmap.data.frame_+3A_as.cross">as.cross</code></td>
<td>

<p>Logical value. If <code>TRUE</code> the constructed linkage map is returned as
a <span class="pkg">qtl</span> cross object (see Details). If <code>FALSE</code> then the constructed
linkage map is returned as a <code>data.frame</code> with extra columns
indicating the linkage group, marker name/position and genetic distance.
Default is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="mstmap.data.frame_+3A_return.imputed">return.imputed</code></td>
<td>

<p>Logical value. If <code>TRUE</code> then the imputed marker probability matrix is
returned for the linkage groups that are constructed (see
Details). Default is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="mstmap.data.frame_+3A_trace">trace</code></td>
<td>

<p>An automatic tracing facility. If <code>trace = FALSE</code> then
minimal <code>MSTmap</code> output is piped to the screen during the algorithm.
If <code>trace = TRUE</code>, then detailed output from MSTmap is
piped to &quot;<code>MSToutput.txt</code>&quot;. This file is equivalent to the output that
would be obtained from running the MSTmap executable from the command line.
</p>
</td></tr>
<tr><td><code id="mstmap.data.frame_+3A_...">...</code></td>
<td>

<p>Currently ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data frame <code>object</code> must have an explicit format with markers
in rows and genotypes in columns. The marker names are required to be in
the <code>rownames</code> component and the genotype names are
required to be in the <code>names</code> component of the <code>object</code>. In
each set of names there must be no spaces. If spaces are detected they
are exchanged for a &quot;-&quot;. Each of the columns of the data frame must be of class
<code>"character"</code> (not factors). If converting from a matrix, this can
easily be achieved by using the <code>stringAsFactors = FALSE</code> argument
for any <code>data.frame</code> method.
</p>
<p>It is important to know what population type the data frame
<code>object</code> is and to correctly input this into <code>pop.type</code>. If
<code>pop.type = "ARIL"</code> then it is assumed that the minimal number of heterozygotes have been
set to missing before proceeding. The advanced RIL population is then
treated like a backcross population for the purpose of linkage map
construction. Genetic distances are adjusted post construction.
For non-advanced RIL populations <code>pop.type =
  "RILn"</code>, the number of generations of selfing is limited to 20 to
ensure sensible input.
</p>
<p>The content of the markers in <code>object</code> can either be all numeric
(see below) or all character. If markers are of type character then
the following allelic content must be explicitly adhered to. For <code>pop.type</code> <code>"BC"</code>,
<code>"DH"</code> or <code>"ARIL"</code> the two allele types should
be represented as (<code>"A"</code> or <code>"a"</code>) and (<code>"B"</code> or
<code>"b"</code>). For non-advanced RIL populations (<code>pop.type = "RILn"</code>)
phase unknown heterozygotes should be represented as
<code>"X"</code>. For all populations, missing marker scores should be represented
as (<code>"U"</code> or <code>"-"</code>).
</p>
<p>This function also extends the functionality of the MSTmap
algorithm by allowing users to input a complete numeric data frame of
marker probabilities for <code>pop.type</code> <code>"BC"</code>, <code>"DH"</code> or
<code>"ARIL"</code>. The values must be inclusively between 1 (A) and 0 (B) and be
representative of the probability that the A allele is present. No
missing values are allowed.
</p>
<p>The algorithm allows an adjustment of the <code>p.value</code> threshold for
clustering of markers to distinct linkage groups (see Wu et al.,
2008) and is highly dependent on the number of individuals in
the population. As the number of individuals increases the
<code>p.value</code> threshold should be decreased accordingly. This may
require some trial and error to achieve desired results.
</p>
<p>If <code>mvest.bc = TRUE</code> and the population type is <code>"BC","DH","ARIL"</code>
then missing values are imputed before markers are clustered into
linkage groups. This is only a simple imputation that places a 0.5
probability of the missing observation being one allele or the other and
is used to assist the clustering algorithm when there is known to be high numbers of
missing observations between pairs of markers.
</p>
<p>It should be highlighted that for population types
<code>"BC","DH","ARIL"</code>, imputation of missing values occurs
regardless of the value of <code>mvest.bc</code>. This is achieved using an EM algorithm that is
tightly coupled with marker ordering (see Wu et al., 2008). Initially
a marker order is obtained omitting missing marker scores and then
imputation is performed based on the underlying recombinant probabilities
of the flanking markers with the markers containing the missing
value. The recombinant probabilities are then recomputed and an update of
the pairwise distances are calculated. The ordering algorithm is then
run again and the complete process is repeated until
convergence. Note, the imputed probability matrix for the linkage map
being constructed is returned if <code>return.imputed = TRUE</code>.
</p>
<p>For populations <code>"BC","DH","ARIL"</code>, if <code>detectBadData = TRUE</code>,
the marker ordering algorithm also
includes the detection of genotyping errors. For any individual
genotype, the detection method is based on a weighted Euclidean metric
(see Wu et al., 2008) that is a function of the
recombination probabilities of all the markers with the marker containing
the suspicious observation. Any genotyping errors detected are set to
missing and the missing values are then imputed if <code>mv.est =
  TRUE</code>.  Note, the detection of these errors and their
amendment is returned in the imputed probability matrix if
<code>return.imputed = TRUE</code>
</p>
<p>If <code>as.cross = TRUE</code> then the constructed object is returned as a
<span class="pkg">qtl</span> cross object with the appropriate class structure. For <code>"RILn"</code>
populations the constructed object is given the class <code>"bcsft"</code> by
using the <span class="pkg">qtl</span> package conversion function <code>convert2bcsft</code>
with arguments <code>F.gen = n</code> and <code>BC.gen =
  0</code>. For <code>"ARIL"</code> populations the constructed object is given the
class <code>"riself"</code>.
</p>
<p>If <code>return.imputed = TRUE</code> and <code>pop.type</code> is one of
<code>"BC","DH","ARIL"</code>, then the marker probability matrix is
returned for the linkage groups that have been constructed using the
algorithm. Each linkage group is named identically to the linkage groups
of the map and, if <code>as.cross = TRUE</code>, contains an ordered
<code>"map"</code> element and a <code>"data"</code>
element consisting of marker probabilities of the A allele being present
(i.e. P(A) = 1, P(B) = 0). Both elements contain a
possibly reduced version of the marker set that includes all
non-colocating markers as well as the first marker of any set of
co-locating markers. If <code>as.cross = FALSE</code> then an ordered data frame of matrix
probabilities is returned.
</p>


<h3>Value</h3>

<p>If <code>as.cross = TRUE</code> the function returns an R/qtl cross object with the appropriate
class structure. The object is a list with usual components
<code>"pheno"</code> and <code>"geno"</code>. If <code>as.cross = FALSE</code> the
function returns an ordered data frame object
with additional columns that indicate the linkage group, the position
and marker names and genetic distance of the markers within in each
linkage group. If markers were omitted for any reason during the
construction, the object will have an <code>"omit"</code> component with
all omitted markers in a collated matrix.  If <code>return.imputed =
    TRUE</code> then the object will also contain an <code>"imputed.geno"</code> element.
</p>


<h3>Author(s)</h3>

<p>Julian Taylor, Dave Butler, Timothy Close, Yonghui Wu, Stefano Lonardi
</p>


<h3>References</h3>

<p>Wu, Y., Bhat, P., Close, T.J, Lonardi, S. (2008) Efficient and Accurate
Construction of Genetic Linkage Maps from Minimum Spanning Tree of a
Graph. Plos Genetics, <b>4</b>, Issue 10.
</p>
<p>Taylor, J., Butler, D. (2017) R Package ASMap: Efficient Genetic
Linkage Map Construction and Diagnosis. Journal of Statistical Software,
<b>79</b>(6), 1&ndash;29.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mstmap.cross">mstmap.cross</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mapDH, package = "ASMap")

## forming data frame object from R/qtl object

dfg &lt;- t(do.call("cbind", lapply(mapDH$geno, function(el) el$data)))
dimnames(dfg)[[2]] &lt;- as.character(mapDH$pheno[["Genotype"]])
dfg &lt;- dfg[sample(1:nrow(dfg), nrow(dfg), replace = FALSE),]
dfg[dfg == 1] &lt;- "A"
dfg[dfg == 2] &lt;- "B"
dfg[is.na(dfg)] &lt;- "U"
dfg &lt;- cbind.data.frame(dfg, stringsAsFactors = FALSE)

## construct map

testd &lt;- mstmap(dfg, dist.fun = "kosambi", trace = FALSE)
pull.map(testd)

## let's get a timing on that ...

system.time(testd &lt;- mstmap(dfg, dist.fun = "kosambi", trace = FALSE))

</code></pre>

<hr>
<h2 id='pp.init'>
Parameter initialization function
</h2><span id='topic+pp.init'></span>

<h3>Description</h3>

<p>Parameter initialization function for <code>pushCross</code> and <code>pullCross</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pp.init(seg.thresh = 0.05, seg.ratio = NULL, miss.thresh = 0.1,
        max.rf = 0.25, min.lod = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pp.init_+3A_seg.thresh">seg.thresh</code></td>
<td>

<p>Numerical value between zero and one determining the p-value threshold
for the test of marker segregation distortion.
</p>
</td></tr>
<tr><td><code id="pp.init_+3A_seg.ratio">seg.ratio</code></td>
<td>

<p>A character string of the form &quot;AA:BB&quot; or &quot;AA:AB:BB&quot; describing the
ratio of the alleles.
</p>
</td></tr>
<tr><td><code id="pp.init_+3A_miss.thresh">miss.thresh</code></td>
<td>

<p>Numerical value between zero and one determining the proportion of
missing values.
</p>
</td></tr>
<tr><td><code id="pp.init_+3A_max.rf">max.rf</code></td>
<td>

<p>The maximum recombination fraction to consider when attempting to
cluster pushed markers back into linkage groups.
</p>
</td></tr>
<tr><td><code id="pp.init_+3A_min.lod">min.lod</code></td>
<td>

<p>The minimum LOD score to consider when attempting to cluster pushed
markers back into linkage groups.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This parameter initialization function is used by the function <code>pullCross</code> to
pull markers from a linkage map and <code>pushCross</code> to push markers
back into a linkage map. How the arguments <code>seg.thresh</code>,
<code>seg.ratio</code> and <code>miss.thresh</code> are used depends on which
function is called. See <code>pushCross</code> and <code>pullCross</code> for
more details.
</p>


<h3>Value</h3>

<p>Return user defined parameter values for each of the parameters.
</p>


<h3>Author(s)</h3>

<p>Julian Taylor
</p>


<h3>References</h3>

<p>Taylor, J., Butler, D. (2017) R Package ASMap: Efficient Genetic
Linkage Map Construction and Diagnosis. Journal of Statistical Software,
<b>79</b>(6), 1&ndash;29.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pushCross">pushCross</a></code>; <code><a href="#topic+pullCross">pullCross</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mapDH, package = "ASMap")

## pull markers from a linkage map with a segregation distortion

pars &lt;- pp.init(seg.thresh = 0.05)
mapDH.s &lt;- pullCross(mapDH, type = "seg.distortion", pars = pars)
mapDH.s$seg.distortion$table
</code></pre>

<hr>
<h2 id='profileGen'>
Profile individual genotype statistics for an R/qtl cross object
</h2><span id='topic+profileGen'></span>

<h3>Description</h3>

<p>Profile individual genotype statistics for the current linkage map
order of and R/qtl cross object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>profileGen(cross, chr, bychr = TRUE, stat.type = c("xo", "dxo",
           "miss"), id = "Genotype", xo.lambda = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="profileGen_+3A_cross">cross</code></td>
<td>

<p>An <span class="pkg">qtl</span> <code>cross</code> object with class structure <code>"bc",
  "dh", "riself", "bcsft"</code>. (see <code>?mstmap.cross</code> for more details.)
</p>
</td></tr>
<tr><td><code id="profileGen_+3A_chr">chr</code></td>
<td>

<p>Character vector of linkage group names used for subsetting the
linkage map.
</p>
</td></tr>
<tr><td><code id="profileGen_+3A_bychr">bychr</code></td>
<td>

<p>Logical vector determining whether statistics should be plotted by
chromosome (see Details).
</p>
</td></tr>
<tr><td><code id="profileGen_+3A_stat.type">stat.type</code></td>
<td>

<p>Character string of any combination of <code>"xo"</code> or <code>"dxo"</code> or
<code>"miss"</code>. <code>"xo"</code> calculates the number of crossovers,
<code>"dxo"</code> calculates the number of double crossover and <code>"miss"</code>
calculates the number of missing values.
</p>
</td></tr>
<tr><td><code id="profileGen_+3A_id">id</code></td>
<td>

<p>Character string determining the column of <code>cross$pheno</code> that
contains the genotype names.
</p>
</td></tr>
<tr><td><code id="profileGen_+3A_xo.lambda">xo.lambda</code></td>
<td>

<p>A numerical value for the expected rate of recombination. (see Details).
</p>
</td></tr>
<tr><td><code id="profileGen_+3A_...">...</code></td>
<td>

<p>Other arguments to be passed to the high level lattice plot.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses <code>statGen</code> to profile statistics for the
genotypes for the current order of the linkage map. Any combination of
<code>"xo"</code> or <code>"dxo"</code> or <code>"miss"</code> may be given to
simultaneous plot. If <code>bychr = TRUE</code> then the plots will be further partitioned by
linkage groups given by <code>chr</code>.
</p>
<p>If a numerical value is given for <code>xo.lambda</code> then the
recombination count for each genotype is tested against the expected
recombination rate <code>xo.lambda</code> using a simple one-tailed test of a
Poisson mean. Any lines that have a p-value less than than a family wise
error rate based on bonferroni adjustment of the usual alpha level of 0.05 are
annotated on the profiles being plotted.
</p>


<h3>Value</h3>

<p>A lattice panel plot with panels described by the <code>stat.type</code> given
in the call and genotype statistics are returned invisibly. If
<code>xo.lambda</code> is not NULL then these statistics also include a
logical vector named <code>"xo.lambda"</code> that is returned from testing
the individuals for inflated recombination rates (see Details).
</p>


<h3>Author(s)</h3>

<p>Julian Taylor
</p>


<h3>References</h3>

<p>Taylor, J., Butler, D. (2017) R Package ASMap: Efficient Genetic
Linkage Map Construction and Diagnosis. Journal of Statistical Software,
<b>79</b>(6), 1&ndash;29.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+statGen">statGen</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mapDH, package = "ASMap")

## profile all genotype crossover and double crossover statistics

profileGen(mapDH, bychr = FALSE, stat.type = c("xo","dxo"),
     xo.lambda = 25, layout = c(1,3))

</code></pre>

<hr>
<h2 id='profileMark'>
Profile individual marker and interval statistics for an R/qtl cross object
</h2><span id='topic+profileMark'></span>

<h3>Description</h3>

<p>Graphically profile individual marker and interval statistics for an R/qtl cross object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>profileMark(cross, chr, stat.type = "marker", use.dist = TRUE,
          map.function = "kosambi", crit.val = NULL,
          display.markers = FALSE, mark.line = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="profileMark_+3A_cross">cross</code></td>
<td>

<p>An R/qtl <code>cross</code> object with class structure <code>"bc"</code>,
<code>"dh"</code>, <code>"riself"</code>, <code>"bcsft"</code>. (see <code>?mstmap.cross</code> for more details.)
</p>
</td></tr>
<tr><td><code id="profileMark_+3A_chr">chr</code></td>
<td>

<p>Character vector of linkage group names used for subsetting the
linkage map.
</p>
</td></tr>
<tr><td><code id="profileMark_+3A_stat.type">stat.type</code></td>
<td>

<p>Character string of either <code>"marker"</code> or <code>"interval"</code> or
both. Also this can be a set of character strings relating to individual
marker or interval statistics that want to be viewed simultaneously (see Details).
</p>
</td></tr>
<tr><td><code id="profileMark_+3A_use.dist">use.dist</code></td>
<td>

<p>Logical value determining whether the actual map distances should be use
to represent marker positions. If <code>FALSE</code> then markers are placed
equidistant from each other.
</p>
</td></tr>
<tr><td><code id="profileMark_+3A_map.function">map.function</code></td>
<td>

<p>Character string of either <code>"koasmbi"</code>, <code>"haldane"</code>,
<code>"morgan"</code> or <code>"cf"</code> defining the map
function to be used for interval related statistics.
</p>
</td></tr>
<tr><td><code id="profileMark_+3A_crit.val">crit.val</code></td>
<td>

<p>The critical value to be used in displaying marker or intervals above a
certain threshold (see Details).
</p>
</td></tr>
<tr><td><code id="profileMark_+3A_display.markers">display.markers</code></td>
<td>

<p>A logical value determining whether marker names should be displayed on
the bottom axis.
</p>
</td></tr>
<tr><td><code id="profileMark_+3A_mark.line">mark.line</code></td>
<td>

<p>A logical value determining whether vertical lines should be drawn at
marker positions. This may be useful to line up marker positions across
several plots.
</p>
</td></tr>
<tr><td><code id="profileMark_+3A_...">...</code></td>
<td>

<p>Other arguments to be passed to the high level lattice plot.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This graphical function calls the function <code>statMark</code> to retrieve
marker and interval statistics. If <code>"marker"</code> is given as the
<code>stat.type</code> then the complete set of marker statistics is plotted
simultaneously. If <code>"interval"</code> is given as the
<code>stat.type</code> then the function simultaneously plots the complete set
of interval statistics. Both can also be chosen.
</p>
<p>This function also allows users to choose any combination of marker or interval
statistics they would like to view. The set of available marker
statistics that can be profiled are given below
</p>

<ul>
<li> <p><code>"seg.dist"</code>: Profile the -log10 p-value.
results from a test of segregation distortion for each marker.
</p>
</li>
<li> <p><code>"miss"</code>: Profile the proportion of missing values
for each marker.
</p>
</li>
<li> <p><code>"prop"</code>: Profile the allele proportions for each
marker.
</p>
</li>
<li> <p><code>"dxo"</code>: Profile the number of double crossovers
occurring at each marker.
</p>
</li></ul>

<p>The set of available interval statistics that can be profiled are given below
</p>

<ul>
<li> <p><code>"erf"</code>: Profile the recombination fractions for the
intervals.
</p>
</li>
<li> <p><code>"lod"</code>: Profile the LOD score for the test of no linkage
between markers in an interval.
</p>
</li>
<li> <p><code>"dist"</code>: Profile the interval map distance taken
from the map component of each linkage group.
</p>
</li>
<li> <p><code>"mrf"</code>: Profile the map recombination fraction for
the intervals.
</p>
</li>
<li> <p><code>"recomb"</code>: Profile the actual number of recombinations
within each of the intervals.
</p>
</li></ul>

<p>If <code>crit.val="bonf"</code> and marker statistics are plotted then any
markers that have p-value for the test of segregation distortion less
than the family wise error rate based on a bonferroni adjustment of the
usual 0.05 alpha level, are annotated on each of the marker plots. If any interval statistics
are being plotted then any intervals that have a p-value for the test of
no linkage that is less than a bonferroni adjustment of the usual 0.05
alpha level are annotated on each of the interval statistics plots.
</p>


<h3>Value</h3>

<p>A lattice panel plot is displayed with panels described by the
<code>stat.type</code> given in the call and the complete marker/interval statistics
are returned invisibly. If <code>crit.val</code> is not NULL then both
the marker/interval statistics are returned with an extra logical column called
<code>"crit.val"</code> from testing markers for segregation distortion and
intervals for weak linkage (see Details).
</p>


<h3>Author(s)</h3>

<p>Julian Taylor
</p>


<h3>References</h3>

<p>Taylor, J., Butler, D. (2017) R Package ASMap: Efficient Genetic
Linkage Map Construction and Diagnosis. Journal of Statistical Software,
<b>79</b>(6), 1&ndash;29.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+profileMark">profileMark</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mapDH, package = "ASMap")

## profile chosen statistics

profileMark(mapDH, stat.type = c("seg.dist","prop","erf"), layout =
      c(1,4), type = "l")

</code></pre>

<hr>
<h2 id='pullCross'>
Pull markers from a linkage map.
</h2><span id='topic+pullCross'></span>

<h3>Description</h3>

<p>Pull markers of a certain type from a linkage map and place them aside in the
R/qtl object and, if appropriate, keeping their connections with the reduced linkage map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pullCross(object, chr, type = c("co.located","seg.distortion",
          "missing"), pars = NULL, replace = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pullCross_+3A_object">object</code></td>
<td>

<p>An <span class="pkg">qtl</span> <code>cross</code> object with class structure <code>"bc"</code>
<code>"dh"</code>, <code>"riself"</code>, <code>"bcsft"</code>. (see <code>?mstmap.cross</code> for more details.)
</p>
</td></tr>
<tr><td><code id="pullCross_+3A_chr">chr</code></td>
<td>

<p>A character vector of linkage group names with which to subset the linkage
map before pulling any markers.
</p>
</td></tr>
<tr><td><code id="pullCross_+3A_type">type</code></td>
<td>

<p>A character string determining the type of markers to be pulled from the
map (see Details).
</p>
</td></tr>
<tr><td><code id="pullCross_+3A_pars">pars</code></td>
<td>

<p>A list of parameters that are used by <code>pullCross</code> to pull markers
of certain type. The default NULL calls the parameter
initialization function <code>pp.init</code> with defaults (see Details and
Examples).
</p>
</td></tr>
<tr><td><code id="pullCross_+3A_replace">replace</code></td>
<td>

<p>A logical value determining whether the markers and summary of marker information that is
pulled from the map replaces information that is already residing in the
<code>type</code> element of the object.
</p>
</td></tr>
<tr><td><code id="pullCross_+3A_...">...</code></td>
<td>

<p>Currently ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function gives users the ability to &quot;pull&quot; markers of several
different types from the linkage map and place them in appropriately named
elements of the cross object. These elements can be examined by the
user and can even be &quot;pushed&quot; back using the complementary command
<code>pushCross</code>.
</p>
<p>Currently supported types are:
</p>

<ul>
<li> <p><code>type = "co.located"</code>. This type gives the user the ability to
reduce a linkage map to a unique set of markers for the purpose of
efficient map construction. Co-located markers are pulled from the
linkage map using the technology of <code>findDupMarkers</code> from the
<span class="pkg">qtl</span> package and places them aside
in a separate list element called <code>"co.located"</code>. This element
contains the removed marker data as well as a table
that displays the connections between the co-located markers with
markers that remain in the linkage map. If required, this table is used
by <code>pushCross</code> to &quot;push&quot; the co-located markers back into the
linkage map.
</p>
</li>
<li> <p><code>type = "seg.distortion"</code>. Users can pull markers with
segregation distortion from a linkage map with two different
thresholding mechanisms called using <code>pars</code>. If the list argument
<code>pars</code> is used with an element called <code>seg.thresh</code>
then markers are pulled from the map if the p-value from the test for segregation distortion
is LESS than <code>seg.thresh</code>. Values of <code>seg.thresh</code> must be
between 0 and 1. If <code>pars</code> contains an element
<code>seg.ratio</code> then markers are pulled from the map based on the
ratio provided. The ratio must be in character format and of the type
&quot;AA:BB&quot; for two allele populations and &quot;AA:AB:BB&quot; for three allele
populations (see Examples for more details). Markers are pulled if their
allele proportions are GREATER than the largest proportional ratio or LESS
than the smallest proportional ratio given in <code>seg.thresh</code>. If neither
thresholding mechanisms are given then the default is
to use <code>seg.thresh = 0.05</code>. If markers are found matching the above
criteria they are pulled from the linkage map and placed aside in an
element called <code>"seg.distortion"</code>. This element contains the
removed distorted marker data as well as a table summarizing each of the
markers. See examples below for more detail.
</p>
</li>
<li> <p><code>type = "missing"</code>. Users can pull markers with a
proportional amount of missing allele scores. If <code>pars</code> contains an
element <code>miss.thresh</code> then markers are pulled from the linkage map
that have a proportion of missing values GREATER than
<code>miss.thresh</code>. If no value is given for <code>miss.thresh</code> then it defaults
to 0.1 or 10% missing values. If markers are found matching the above
criteria they are pulled from the map and are placed aside in an separate list element
called <code>"missing"</code>. This element contains the
removed marker data as well as a table summarizing each of the
markers. See examples below for more detail.
</p>
</li></ul>



<h3>Value</h3>

<p>The cross object is returned with identical class structure as the
inputted cross object and an additional elements corresponding to the
marker types being pulled from the map.
</p>


<h3>Author(s)</h3>

<p>Julian Taylor
</p>


<h3>References</h3>

<p>Taylor, J., Butler, D. (2017) R Package ASMap: Efficient Genetic
Linkage Map Construction and Diagnosis. Journal of Statistical Software,
<b>79</b>(6), 1&ndash;29.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pushCross">pushCross</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mapDH, package = "ASMap")

## pull co-located markers from linkage map

mapDH.c &lt;- pullCross(mapDH, type = "co.located")
mapDH.c$co.located$table

## pull distorted markers from linkage map using seg.thresh

mapDH.s &lt;- pullCross(mapDH, type = "seg.distortion", pars =
           list(seg.thresh = 0.05))
mapDH.s$seg.distortion$table

## pull distorted markers from linkage map using seg.ratio

mapDH.s &lt;- pullCross(mapDH, type = "seg.distortion", pars =
            list(seg.ratio = "56:44"))
mapDH.s$seg.distortion$table

</code></pre>

<hr>
<h2 id='pushCross'>
Push markers into an established R/qtl linkage map.
</h2><span id='topic+pushCross'></span>

<h3>Description</h3>

<p>Push unlinked markers or markers that were originally placed aside by
<code>pullCross</code> back into linkage groups of an established R/qtl linkage map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pushCross(object, type = c("co.located","seg.distortion",
          "missing","unlinked"), unlinked.chr = NULL,
          pars = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pushCross_+3A_object">object</code></td>
<td>

<p>An R/qtl <code>cross</code> object with class structure <code>"bc"</code>,
<code>"dh"</code>, <code>"riself"</code>, <code>"bcsft"</code>. (see <code>?mstmap.cross</code> for more details.)
</p>
</td></tr>
<tr><td><code id="pushCross_+3A_type">type</code></td>
<td>

<p>A character string determining the type of markers to be pushed into
the linkage map (see Details).
</p>
</td></tr>
<tr><td><code id="pushCross_+3A_unlinked.chr">unlinked.chr</code></td>
<td>

<p>A character string of linkage group names containing markers that
require pushing into the remaining linkage groups of the object. This is only useful when
<code>type="unlinked"</code>. Default is <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="pushCross_+3A_pars">pars</code></td>
<td>

<p>A list of parameters that are used by <code>pushCross</code> to push markers
a certain type back into the linkage group. The default NULL calls the parameter
initialization function <code>pp.init</code> with defaults (see Details and
Examples).
</p>
</td></tr>
<tr><td><code id="pushCross_+3A_...">...</code></td>
<td>

<p>Currently ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function was written explicitly to complement <code>pullCross</code> by
&quot;pushing&quot; markers of certain types back into linkage groups of an
established linkage map.
</p>
<p>Currently supported marker types are:
</p>

<ul>
<li> <p><code>type = "co.located"</code>. Users can push co-located markers back
into the linkage map that have been set aside in the cross object element
<code>co.located</code>. To ensure this can be used at any stage of the linkage map
construction process the function disregards the linkage group information
provided in the table formed by using <code>pullCross</code>. Instead it uses the
current positions of the markers in the reduced linkage map to determine
where to push the co-located markers back to.
</p>
</li>
<li> <p><code>type = "seg.distortion"</code>. Users can push markers from the
<code>"seg.distortion"</code> element of the object back into a linkage map using the thresholding
mechanisms <code>seg.thresh</code> and <code>seg.ratio</code> called using
<code>pars</code>. If <code>seg.thresh</code> is given then the markers are pushed
back that have p-values that are GREATER than <code>seg.thresh</code>. If
<code>pars</code> contains an element <code>seg.ratio</code> then markers are pushed
back based on the ratio provided. The ratio must be in character format and of the type
&quot;AA:BB&quot; for two allele populations and &quot;AA:AB:BB&quot; for three allele
populations (see Examples for more details). Markers are pushed back if their
allele proportions are LESS than the largest proportional ratio or GREATER
than the smallest proportional ratio given in <code>seg.thresh</code>. If neither
thresholding mechanisms are given then the default is to use <code>seg.thresh = 0.05</code>.
</p>
</li>
<li> <p><code>type = "missing"</code>. Users can push markers from the object
element <code>"missing"</code> back into the linkage map using the
thresholding parameter <code>miss.thresh</code> called using
<code>pars</code>. Markers will be pushed back that have a
proportion of missing values LESS than <code>miss.thresh</code>. If no value
is given for this parameter it defaults to 0.1 or 10% missing values.
</p>
</li>
<li> <p><code>type = "unlinked"</code>. Users can push unlinked markers that
reside in linkage groups of the established linkage map. If this type is
chosen <code>unlinked.chr</code> must be a character string of linkage group
names in the object.
</p>
</li></ul>

<p>For types <code>"seg.distortion"</code>, <code>"missing"</code> and
<code>"unlinked"</code> a fast clustering method is used to allocate markers
to established linkage groups. This is done very
efficiently by reducing the constructed linkage map to a skeleton set
of markers before checking linkages. How these linkages are formed can
be tweaked by setting <code>max.rf</code> and <code>min.lod</code> when calling
<code>pars</code>. These currently default to <code>max.rf = 0.25</code> and
<code>min.lod = 3</code>.
</p>
<p>Users should explicitly avoid the use of &quot;UL&quot; as part of a linkage group name as
this is used internally to name unlinked groups of markers if required.
It should also be noted that this function does not re-construct the
object after allocating markers to linkage groups. For efficient linkage map
reconstruction of an R/qtl object see <code>mstmap.cross()</code>.
</p>


<h3>Value</h3>

<p>The cross object is returned with an identical class structure as the
inputted cross object with additional markers from the marker types
pushed into linkage groups of the established linkage map. If all
markers of an element type are pushed back then the element type is
removed from the object.
</p>


<h3>Author(s)</h3>

<p>Julian Taylor
</p>


<h3>References</h3>

<p>Taylor, J., Butler, D. (2017) R Package ASMap: Efficient Genetic
Linkage Map Construction and Diagnosis. Journal of Statistical Software,
<b>79</b>(6), 1&ndash;29.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pullCross">pullCross</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mapDH, package = "ASMap")

## pull co-located markers from map

mapDH.c &lt;- pullCross(mapDH, type = "co.located")
mapDH.c$co.located$table

## push co-located markers back into linkage map

mapDH.z &lt;- pushCross(mapDH.c, type = "co.located")
pull.map(mapDH.z)

</code></pre>

<hr>
<h2 id='pValue'>
P-value graph
</h2><span id='topic+pValue'></span>

<h3>Description</h3>

<p>P-value graph to determine threshold for marker clustering
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pValue(dist = seq(25,40, by = 5), pop.size = 100:500,
       map.function = "kosambi", LOD = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pValue_+3A_dist">dist</code></td>
<td>

<p>Numeric range of genetic distances in cM.
</p>
</td></tr>
<tr><td><code id="pValue_+3A_pop.size">pop.size</code></td>
<td>

<p>Numeric range of population sizes.
</p>
</td></tr>
<tr><td><code id="pValue_+3A_map.function">map.function</code></td>
<td>

<p>Character string of either <code>"koasmbi"</code>, <code>"haldane"</code>,
<code>"morgan"</code> or <code>"cf"</code> defining the mapping function to be used.
</p>
</td></tr>
<tr><td><code id="pValue_+3A_lod">LOD</code></td>
<td>

<p>If <code>LOD = TRUE</code> the LOD score of linkage is calculated
or if <code>LOD = FALSE</code> then the minus log10 p-value used to threshold the
hoeffding inequality is calculated (defaults to <code>FALSE</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides the ability to create a user specified p-value
plot similar to Figure 1.1 in the vignette for the package.
</p>


<h3>Value</h3>

<p>A plot is displayed showing minus log10 pvalue (or LOD score) of linkage vs the
range of specified population sizes for different specified genetic
distances.
</p>


<h3>Author(s)</h3>

<p>Julian Taylor
</p>


<h3>References</h3>

<p>Taylor, J., Butler, D. (2017) R Package ASMap: Efficient Genetic
Linkage Map Construction and Diagnosis. Journal of Statistical Software,
<b>79</b>(6), 1&ndash;29.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mstmap.cross">mstmap.cross</a></code> and <code><a href="#topic+mstmap.data.frame">mstmap.data.frame</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
pValue(dist = seq(25, 40, by = 2))
</code></pre>

<hr>
<h2 id='quickEst'>
Very quick estimation of genetic map distances.
</h2><span id='topic+quickEst'></span>

<h3>Description</h3>

<p>Very quick estimation of genetic map distances for a constructed R/qtl object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quickEst(object, chr, map.function = "kosambi", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quickEst_+3A_object">object</code></td>
<td>

<p>An R/qtl <code>object</code> object with any class structure.
</p>
</td></tr>
<tr><td><code id="quickEst_+3A_chr">chr</code></td>
<td>

<p>A character string of linkage group names that require (re)estimation of
their genetic map distances.
</p>
</td></tr>
<tr><td><code id="quickEst_+3A_map.function">map.function</code></td>
<td>

<p>Character string of either <code>"koasmbi"</code>, <code>"haldane"</code>,
<code>"morgan"</code> or <code>"cf"</code> defining the mapping
function to be used.
</p>
</td></tr>
<tr><td><code id="quickEst_+3A_...">...</code></td>
<td>

<p>Other arguments passed to <code>argmax.geno</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For linkage groups with large numbers of markers, the Hidden Markov algorithm in <code>est.map</code>
can be extremely slow. The computational burden for this algorithm
increases as the number of missing values and genotyping errors
increase. <code>quickEst</code> circumvents this by using the Viterbi
algorithm computationally implemented in <code>argmax.geno</code> of the
<span class="pkg">qtl</span> package. Initial conservative estimates of the map distances
are calculated from inverting recombination fractions outputted from
<code>est.rf</code>. These are then passed to <code>argmax.geno</code> and
imputation of missing allele scores is performed along with
re-estimation of map distances.
</p>


<h3>Value</h3>

<p>The cross object is returned with identical class structure as the
inputted cross object.
</p>


<h3>Author(s)</h3>

<p>Julian Taylor
</p>


<h3>References</h3>

<p>Taylor, J., Butler, D. (2017) R Package ASMap: Efficient Genetic
Linkage Map Construction and Diagnosis. Journal of Statistical Software,
<b>79</b>(6), 1&ndash;29.
</p>


<h3>See Also</h3>

<p><code><a href="qtl.html#topic+est.map">est.map</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mapDH, package = "ASMap")

mapDH1 &lt;- quickEst(mapDH, map.function = "kosambi")

</code></pre>

<hr>
<h2 id='statGen'>
Individual genotype statistics for an R/qtl cross object
</h2><span id='topic+statGen'></span>

<h3>Description</h3>

<p>Individual genotype statistics for the current linkage map
order of and R/qtl cross object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>statGen(cross, chr, bychr = TRUE, stat.type = c("xo","dxo",
        "miss"), id = "Genotype")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="statGen_+3A_cross">cross</code></td>
<td>

<p>An R/qtl <code>cross</code> object with class structure <code>"bc"</code>,
<code>"dh"</code>, <code>"riself"</code>, <code>"bcsft"</code>. (see <code>?mstmap.cross</code> for more details.)
</p>
</td></tr>
<tr><td><code id="statGen_+3A_chr">chr</code></td>
<td>

<p>Character vector of linkage group names used for subsetting the
linkage map.
</p>
</td></tr>
<tr><td><code id="statGen_+3A_bychr">bychr</code></td>
<td>

<p>Logical vector determining whether statistics should be plotted by
chromosome (see Details).
</p>
</td></tr>
<tr><td><code id="statGen_+3A_stat.type">stat.type</code></td>
<td>

<p>Character string of any combination of <code>"xo"</code> or <code>"dxo"</code> or
both. <code>"miss"</code>. <code>"xo"</code> calculates the number of crossovers,
<code>"dxo"</code> calculates the number of double crossover and <code>"miss"</code>
calculates the number of missing values.
</p>
</td></tr>
<tr><td><code id="statGen_+3A_id">id</code></td>
<td>

<p>Character string determining the column of <code>cross$pheno</code> that
contains the genotype names.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used in <code>profileGen</code> to plot any combination of
returned linkage map statistics on a single graphical display.
</p>


<h3>Value</h3>

<p>A list with elements named by the <code>stat.type</code> used in the call. If
<code>bychr = TRUE</code> then each element is a data frame of statistics with
columns named by the linkage groups. If <code>bychr = FALSE</code> then each
element is a vector of statistics named by the <code>stat.type</code>.
</p>


<h3>Author(s)</h3>

<p>Julian Taylor
</p>


<h3>References</h3>

<p>Taylor, J., Butler, D. (2017) R Package ASMap: Efficient Genetic
Linkage Map Construction and Diagnosis. Journal of Statistical Software,
<b>79</b>(6), 1&ndash;29.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+profileGen">profileGen</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mapDH, package = "ASMap")

## produce all genotype crossover and double crossover statistics

sg &lt;- statGen(mapDH, stat.type = c("xo","dxo"))

</code></pre>

<hr>
<h2 id='statMark'>
Individual marker and interval statistics for an R/qtl cross object
</h2><span id='topic+statMark'></span>

<h3>Description</h3>

<p>Individual marker and interval statistics for an R/qtl cross object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>statMark(cross, chr, stat.type = c("marker","interval"),
         map.function = "kosambi")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="statMark_+3A_cross">cross</code></td>
<td>

<p>An <span class="pkg">qtl</span> <code>cross</code> object with class structure <code>"bc"</code>,
<code>"dh"</code>, <code>"riself"</code>, <code>"bcsft"</code>. (see <code>?mstmap.cross</code> for more details.)
</p>
</td></tr>
<tr><td><code id="statMark_+3A_chr">chr</code></td>
<td>

<p>Character vector of linkage group names used for subsetting the
linkage map.
</p>
</td></tr>
<tr><td><code id="statMark_+3A_stat.type">stat.type</code></td>
<td>

<p>Character string of either <code>"marker"</code> or <code>"interval"</code> or both. <code>"marker"</code>
produces individual marker related statistics and <code>"interval"</code> produces
interval related statistics for the current map order (see Details).
</p>
</td></tr>
<tr><td><code id="statMark_+3A_map.function">map.function</code></td>
<td>

<p>Character string of either <code>"koasmbi"</code>, <code>"haldane"</code>,
<code>"morgan"</code> or <code>"cf"</code> defining the map
function to be used for interval related statistics.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>"marker"</code> is chosen then a call to <code>geno.table</code> from
<span class="pkg">qtl</span> is used to return individual marker statistics for segregation distortion,
as well as allele and missing value proportions. For the current map
order the number of double crossovers at each marker are also returned.
</p>
<p>If <code>"interval"</code> is chosen then interval statistics are returned for
the current map order. These include the estimated recombination
fraction and LOD score between adjacent markers, calculated from
<code>est.rf</code> in <span class="pkg">qtl</span>. Also returned are the map interval distances and
converted map recombination fractions extracted from the <code>"map"</code>
component of each linkage group as well as the actual number of
recombinations between markers.
</p>
<p>This function is used in <code>profileMark</code> to plot any combination of
returned linkage map statistics on a single graphical display.
</p>


<h3>Value</h3>

<p>A list named by the <code>stat.type</code> used in the call. Each element is a
data frame of statistics with columns named by the statistic.
</p>


<h3>Author(s)</h3>

<p>Julian Taylor
</p>


<h3>References</h3>

<p>Taylor, J., Butler, D. (2017) R Package ASMap: Efficient Genetic
Linkage Map Construction and Diagnosis. Journal of Statistical Software,
<b>79</b>(6), 1&ndash;29.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+profileMark">profileMark</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mapDH, package = "ASMap")

## produce all statistics

sm &lt;- statMark(mapDH, stat.type = c("marker","interval"))

</code></pre>

<hr>
<h2 id='subsetCross'>
Subset an R/qtl object
</h2><span id='topic+subsetCross'></span>

<h3>Description</h3>

<p>Subset an R/qtl object by chromosome or by individuals for populations used
within the R/ASMap package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subsetCross(cross, chr, ind, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subsetCross_+3A_cross">cross</code></td>
<td>

<p>A <code>"cross"</code> object generated from the R/qtl package. Specifically
the object needs to inherit from one of the following classes
<code>"bc"</code>, <code>"dh"</code>, <code>"riself"</code>, <code>"bcsft"</code> (see Details).
</p>
</td></tr>
<tr><td><code id="subsetCross_+3A_chr">chr</code></td>
<td>

<p>Optional vector specifying which chromosomes to keep or
discard. This may be a logical, numeric, or character string
vector. See <code>?subset.cross</code>.
</p>
</td></tr>
<tr><td><code id="subsetCross_+3A_ind">ind</code></td>
<td>

<p>Optional vector specifying which individuals to keep or discard.
This may be a logical or numeric vector (see Details).
</p>
</td></tr>
<tr><td><code id="subsetCross_+3A_...">...</code></td>
<td>

<p>Kept for compatability with <code>subset.cross</code> and is ignored at this point.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a replacement version of <code>subset.cross</code> that should be
used if the <code>cross</code> object contains any or all of the components <code>"co.located"</code>,
<code>"seg.distortion"</code> and <code>"missing"</code> created by a
<code>pullCross</code> call. For a given <code>ind</code>, the function calls
<code>subset.cross</code> to ensure that all elements created from calls to
native R/qtl functions are subsetted appropriately. In addition,
the <code>"co.located"</code>, <code>"seg.distortion"</code> and <code>"missing"</code>
elements are also subsetted and if components <code>"seg.distortion"</code>
and <code>"missing"</code> exist, statistics in their respective tables are
recalculated.
</p>
<p>It provides identical functionality to <code>subset.cross</code>
with the exception that <code>ind</code> can only be a logical or numeric
vector.
</p>


<h3>Value</h3>

<p>The cross object is returned with the appropriate subsetting.
</p>


<h3>Author(s)</h3>

<p>Julian Taylor
</p>


<h3>References</h3>

<p>Taylor, J., Butler, D. (2017) R Package ASMap: Efficient Genetic
Linkage Map Construction and Diagnosis. Journal of Statistical Software,
<b>79</b>(6), 1&ndash;29.
</p>


<h3>See Also</h3>

<p><code><a href="qtl.html#topic+subset.cross">subset.cross</a></code> and <code>pullCross</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mapDH, package = "ASMap")

mapDH.s &lt;- pullCross(mapDH, type = "seg.distortion")
mapDH.s &lt;- subsetCross(mapDH.s, ind = 3:218)
dim(mapDH.s$seg.distortion$data)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
