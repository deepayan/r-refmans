<!DOCTYPE html><html lang="en"><head><title>Help for package SPUTNIK</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SPUTNIK}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#applyPeaksFilter+2Cmsi.dataset-method'><p>Apply the results of a peaks filter.</p></a></li>
<li><a href='#binKmeans+2Cmsi.dataset-method'><p>Return a binary mask generated applying k-means clustering</p>
on first 10 principal components of peaks intensities.</a></li>
<li><a href='#binKmeans2+2Cmsi.dataset-method'><p>Return a binary mask generated applying k-means clustering</p>
on peaks intensities. A finer segmentation is obtained by using a larger
number of clusters than 2. The off-sample clusters are merged looking at the
most frequent labels in the image corners. The lookup areas are defined by
the kernel size.</a></li>
<li><a href='#binOtsu+2Cms.image-method'><p>Binarize MS image using Otsu's thresholding.</p></a></li>
<li><a href='#binSupervised+2Cmsi.dataset-method'><p>Return a binary mask generated applying a supervised classifier</p>
on peaks intensities using manually selected regions corresponding to off-sample
and sample-related areas.</a></li>
<li><a href='#bladderMALDIRompp2010'><p>Load the example MALDI-MSI data.</p></a></li>
<li><a href='#closeImage+2Cms.image-method'><p>Apply morphological closing to binary image.</p></a></li>
<li><a href='#countPixelsFilter'><p>Filter based on the minimum number of connected pixels in the ROI.</p></a></li>
<li><a href='#createPeaksFilter'><p>Generate a peak filter object.</p></a></li>
<li><a href='#CSRPeaksFilter'><p>Performs the peak selection based on complete spatial randomness test.</p></a></li>
<li><a href='#getIntensityMat+2Cmsi.dataset-method'><p>Return the peaks intensity matrix.</p></a></li>
<li><a href='#getMZ+2Cmsi.dataset-method'><p>Return the m/z vector.</p></a></li>
<li><a href='#getShapeMSI+2Cmsi.dataset-method'><p>Returns the geometrical shape of MSI dataset</p></a></li>
<li><a href='#gini.index'><p>Gini index.</p></a></li>
<li><a href='#globalPeaksFilter'><p>Reference similarity based peak selection.</p></a></li>
<li><a href='#invertImage+2Cms.image-method'><p>Invert the colors of an MS image.</p></a></li>
<li><a href='#ms.image-class'><p>ms.image-class definition.</p></a></li>
<li><a href='#msi.dataset-class'><p>msi.dataset-class S4 class definition containing the information about</p>
the mass spectrometry imaging dataset.</a></li>
<li><a href='#msiDataset'><p>Constructor for msi.dataset-class objects.</p></a></li>
<li><a href='#msImage'><p>Constructor for ms.image-class objects.</p></a></li>
<li><a href='#NMI'><p>Normalized mutual information (NMI).</p></a></li>
<li><a href='#normIntensity+2Cmsi.dataset-method'><p>Normalize the peaks intensities.</p></a></li>
<li><a href='#numDetectedMSI+2Cmsi.dataset-method'><p>Generates an msImage representing the number of detected peaks per pixel. This</p>
image can be used to qualitatively evaluate the spatial heterogeneity of the
sample.</a></li>
<li><a href='#ovarianDESIDoria2016'><p>Load the example DESI-MSI data.</p></a></li>
<li><a href='#PCAImage+2Cmsi.dataset-method'><p>Generates an RGB msImage representing the first 3 principal components. This</p>
image can be used to qualitatively evaluate the spatial heterogeneity of the
sample.</a></li>
<li><a href='#plot+2Cms.image+2Cmissing-method'><p>Visualize an MS image.</p>
<code>plot</code> extends the generic function to ms.image-class objects.</a></li>
<li><a href='#refImageBinaryKmeans'><p>Calculate the binary reference image using k-means clustering. K-Means is run</p>
on the first 'npcs' principal components to speed up the calculations.</a></li>
<li><a href='#refImageBinaryKmeansMulti'><p>Calculate the binary reference image using k-means clustering with multi-cluster</p>
merging. K-means is run on the first 'npcs' principal
components to speed up the calculations.</a></li>
<li><a href='#refImageBinaryOtsu'><p>Calculate the binary reference image using Otsu's thresholding.</p></a></li>
<li><a href='#refImageBinarySVM'><p>Calculate the binary reference image using linear SVM trained on manually</p>
selected pixels.</a></li>
<li><a href='#refImageContinuous'><p><code>refImageContinuous</code> returns the reference image, calculated using the</p>
<code>method</code>.
This image represents the basic measure for the filters in SPUTNIK.</a></li>
<li><a href='#removeSmallObjects+2Cms.image-method'><p>Remove binary ROI objects smaller than user-defined number of pixels</p></a></li>
<li><a href='#scatter.ratio'><p>Pixel scatteredness ratio.</p></a></li>
<li><a href='#smoothImage+2Cms.image-method'><p>Apply Gaussian smoothing to an MS image.</p></a></li>
<li><a href='#spatial.chaos'><p>Spatial chaos measure.</p></a></li>
<li><a href='#splitPeaksFilter'><p>Test for the presence of split peaks.</p></a></li>
<li><a href='#SSIM'><p>Structural similarity index (SSIM).</p></a></li>
<li><a href='#totalIonCountMSI+2Cmsi.dataset-method'><p>Generates an msImage representing pixels total-ion-counts. This</p>
image can be used to qualitatively evaluate the spatial heterogeneity of the
sample.</a></li>
<li><a href='#varTransform+2Cmsi.dataset-method'><p>Variance stabilizing transformation.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Spatially Automatic Denoising for Imaging Mass Spectrometry
Toolkit</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.2</td>
</tr>
<tr>
<td>Author:</td>
<td>Paolo Inglese [aut, cre],
  Goncalo Correia [aut, ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Paolo Inglese &lt;p.inglese@outlook.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Set of tools for peak filtering of mass spectrometry
  imaging data based on spatial distribution of signal. Given a 
  region-of-interest, representing the spatial region where the informative
  signal is expected to be localized, a series of filters determine which peak
  signals are characterized by an implausible spatial distribution. The filters
  reduce the dataset dimension and increase its information vs noise ratio,
  improving the quality of the unsupervised analysis results, reducing data
  dimension and simplifying the chemical interpretation.
  The methods are described in Inglese P. et al (2019) &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbty622">doi:10.1093/bioinformatics/bty622</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>e1071, edgeR, spatstat.explore, spatstat.geom, viridis,
ggplot2, reshape, imager, methods, infotheo, parallel, irlba,
doSNOW, foreach</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/paoloinglese/SPUTNIK">https://github.com/paoloinglese/SPUTNIK</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/paoloinglese/SPUTNIK/issues">https://github.com/paoloinglese/SPUTNIK/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-14 17:15:33 UTC; Paolo</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-16 14:30:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='applyPeaksFilter+2Cmsi.dataset-method'>Apply the results of a peaks filter.</h2><span id='topic+applyPeaksFilter+2Cmsi.dataset-method'></span><span id='topic+applyPeaksFilter-msi.dataset-method'></span><span id='topic+applyPeaksFilter'></span>

<h3>Description</h3>

<p><code>applyPeaksFilter</code> select the peaks returned by a peak filter. Custom
filters can be created passing a named array of selected peak indices to
<a href="#topic+createPeaksFilter">createPeaksFilter</a>. Names correspond to the m/z values of the selected
peaks and must coincide with those of the MS dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'msi.dataset'
applyPeaksFilter(object, peakFilter)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="applyPeaksFilter+2B2Cmsi.dataset-method_+3A_object">object</code></td>
<td>
<p><a href="#topic+msi.dataset-class">msi.dataset-class</a> object.</p>
</td></tr>
<tr><td><code id="applyPeaksFilter+2B2Cmsi.dataset-method_+3A_peakfilter">peakFilter</code></td>
<td>
<p>peaks filter results.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="#topic+msi.dataset-class">msi.dataset-class</a> object with only selected peaks.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load package
library("SPUTNIK")

## Mass spectrometry intensity matrix
X &lt;- matrix(rnorm(16000), 400, 40)
X[X &lt; 0] &lt;- 0

## Print original dimensions
print(dim(X))

## m/z vector
mzVector &lt;- seq(600, 900, by = (900 - 600) / 39)

## Read the image size
imSize &lt;- c(20, 20)

## Construct the ms.dataset object
msiX &lt;- msiDataset(X, mzVector, imSize[1], imSize[2])

## Calculate the p-values using the Clark Evans test, then apply Benjamini-
## Hochberg correction.
csr &lt;- CSRPeaksFilter(
  msiData = msiX, method = "ClarkEvans",
  calculateCovariate = FALSE, adjMethod = "BH"
)

## Print selected peaks
print(csr$q.value)

## Create a new filter selecting corrected p-values &lt; 0.001
selIdx &lt;- which(csr$q.value &lt; 0.001)
csrFilter &lt;- createPeaksFilter(selIdx)
</code></pre>

<hr>
<h2 id='binKmeans+2Cmsi.dataset-method'>Return a binary mask generated applying k-means clustering
on first 10 principal components of peaks intensities.</h2><span id='topic+binKmeans+2Cmsi.dataset-method'></span><span id='topic+binKmeans'></span>

<h3>Description</h3>

<p>Return a binary mask generated applying k-means clustering
on first 10 principal components of peaks intensities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'msi.dataset'
binKmeans(object, ref = "detected", invert = FALSE, npcs = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="binKmeans+2B2Cmsi.dataset-method_+3A_object">object</code></td>
<td>
<p><a href="#topic+msi.dataset-class">msi.dataset-class</a> object</p>
</td></tr>
<tr><td><code id="binKmeans+2B2Cmsi.dataset-method_+3A_ref">ref</code></td>
<td>
<p>string (default = &quot;detected). Sample reference image used to align
the clusters.</p>
</td></tr>
<tr><td><code id="binKmeans+2B2Cmsi.dataset-method_+3A_invert">invert</code></td>
<td>
<p>boolean (default = FALSE). If FALSE, the clusters are inversely aligned to the
sample reference image.</p>
</td></tr>
<tr><td><code id="binKmeans+2B2Cmsi.dataset-method_+3A_npcs">npcs</code></td>
<td>
<p>int (default = 10). Number of principal components to calculate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="#topic+ms.image-class">ms.image-class</a> object representing the binary mask image.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load package
library("SPUTNIK")

## Create the msi.dataset-class object
sz &lt;- c(5, 4)
x &lt;- matrix(rnorm(sz[1] * sz[2] * 20), sz[1] * sz[2], 20)
x[x &lt; 0] &lt;- 0
mz &lt;- sort(sample(100, ncol(x)))
msiX &lt;- msiDataset(x, mz, sz[1], sz[2])

## Generate binary mask by applying k-means on the entire dataset
roiImg &lt;- refImageBinaryKmeans(msiX, npcs = 3)

## Plot the mask
# plot(roiImg)
</code></pre>

<hr>
<h2 id='binKmeans2+2Cmsi.dataset-method'>Return a binary mask generated applying k-means clustering
on peaks intensities. A finer segmentation is obtained by using a larger
number of clusters than 2. The off-sample clusters are merged looking at the
most frequent labels in the image corners. The lookup areas are defined by
the kernel size.</h2><span id='topic+binKmeans2+2Cmsi.dataset-method'></span><span id='topic+binKmeans2'></span>

<h3>Description</h3>

<p>Return a binary mask generated applying k-means clustering
on peaks intensities. A finer segmentation is obtained by using a larger
number of clusters than 2. The off-sample clusters are merged looking at the
most frequent labels in the image corners. The lookup areas are defined by
the kernel size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'msi.dataset'
binKmeans2(
  object,
  mzQuery = numeric(),
  useFullMZ = TRUE,
  mzTolerance = Inf,
  numClusters = 4,
  kernelSize = c(3, 3, 3, 3),
  numCores = 1,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="binKmeans2+2B2Cmsi.dataset-method_+3A_object">object</code></td>
<td>
<p><a href="#topic+msi.dataset-class">msi.dataset-class</a> object</p>
</td></tr>
<tr><td><code id="binKmeans2+2B2Cmsi.dataset-method_+3A_mzquery">mzQuery</code></td>
<td>
<p>numeric. Values of m/z used to calculate the reference image.
2 values are interpreted as interval, multiple or single values are searched
in the m/z vector. It should be left unset when using <code>useFullMZRef = TRUE</code>.</p>
</td></tr>
<tr><td><code id="binKmeans2+2B2Cmsi.dataset-method_+3A_usefullmz">useFullMZ</code></td>
<td>
<p>logical (default = 'TRUE&ldquo;). Whether all the peaks should be
used to calculate the reference image.</p>
</td></tr>
<tr><td><code id="binKmeans2+2B2Cmsi.dataset-method_+3A_mztolerance">mzTolerance</code></td>
<td>
<p>numeric (default = Inf). Tolerance in PPM to match the
<code>mzQueryRef</code>. values in the m/z vector. It overrides <code>useFullMZ</code>.</p>
</td></tr>
<tr><td><code id="binKmeans2+2B2Cmsi.dataset-method_+3A_numclusters">numClusters</code></td>
<td>
<p>numeric (default = 4). Number of k-means clusters.</p>
</td></tr>
<tr><td><code id="binKmeans2+2B2Cmsi.dataset-method_+3A_kernelsize">kernelSize</code></td>
<td>
<p>4D array (default = c(3, 3, 3, 3)). Array of sizes in pixels
of the corner kernels used to identify the off-sample clusters. The elements
represent the size of the top-left, top-right, bottom-right and bottom-left
corners. A negative value can be used to skip the corresponding corner.</p>
</td></tr>
<tr><td><code id="binKmeans2+2B2Cmsi.dataset-method_+3A_numcores">numCores</code></td>
<td>
<p>(default = 1). Multi-core parallel computation of k-means.
Each core corresponds to a repetition of k-means. If <code>numCores = 1</code>, a
serial k-means with 5 repetitions is performed.</p>
</td></tr>
<tr><td><code id="binKmeans2+2B2Cmsi.dataset-method_+3A_verbose">verbose</code></td>
<td>
<p>logical (default = 'TRUE&ldquo;). Show additional output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="#topic+ms.image-class">ms.image-class</a> object representing the binary mask image.
</p>


<h3>Author(s)</h3>

<p>Paolo Inglese <a href="mailto:p.inglese14@imperial.ac.uk">p.inglese14@imperial.ac.uk</a>
</p>

<hr>
<h2 id='binOtsu+2Cms.image-method'>Binarize MS image using Otsu's thresholding.</h2><span id='topic+binOtsu+2Cms.image-method'></span><span id='topic+binOtsu'></span>

<h3>Description</h3>

<p>Binarize MS image using Otsu's thresholding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ms.image'
binOtsu(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="binOtsu+2B2Cms.image-method_+3A_object">object</code></td>
<td>
<p><a href="#topic+ms.image-class">ms.image-class</a> object. See <a href="#topic+msImage">msImage</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="#topic+ms.image-class">ms.image-class</a> object with binary intensities.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load package
library("SPUTNIK")

## Create ms.image-class object
msIm &lt;- msImage(values = matrix(rnorm(200), 40, 50), name = "test", scale = TRUE)

## Generate binary image
binIm &lt;- refImageBinaryOtsu(msIm)
</code></pre>

<hr>
<h2 id='binSupervised+2Cmsi.dataset-method'>Return a binary mask generated applying a supervised classifier
on peaks intensities using manually selected regions corresponding to off-sample
and sample-related areas.</h2><span id='topic+binSupervised+2Cmsi.dataset-method'></span><span id='topic+binSupervised'></span>

<h3>Description</h3>

<p>Return a binary mask generated applying a supervised classifier
on peaks intensities using manually selected regions corresponding to off-sample
and sample-related areas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'msi.dataset'
binSupervised(
  object,
  refImage,
  mzQuery = numeric(),
  mzTolerance = Inf,
  useFullMZ = TRUE,
  method = "svm",
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="binSupervised+2B2Cmsi.dataset-method_+3A_object">object</code></td>
<td>
<p><a href="#topic+msi.dataset-class">msi.dataset-class</a> object</p>
</td></tr>
<tr><td><code id="binSupervised+2B2Cmsi.dataset-method_+3A_refimage">refImage</code></td>
<td>
<p><a href="#topic+ms.image-class">ms.image-class</a> object. Image used as reference to
manually select the ROI pixels.</p>
</td></tr>
<tr><td><code id="binSupervised+2B2Cmsi.dataset-method_+3A_mzquery">mzQuery</code></td>
<td>
<p>numeric. Values of m/z used to calculate the reference image.
2 values are interpreted as interval, multiple or single values are searched
in the m/z vector. It overrides <code>useFullMZ</code>.</p>
</td></tr>
<tr><td><code id="binSupervised+2B2Cmsi.dataset-method_+3A_mztolerance">mzTolerance</code></td>
<td>
<p>numeric (default = Inf). Tolerance in PPM to match the
<code>mzQueryRef</code>. values in the m/z vector. It overrides <code>useFullMZ</code>.</p>
</td></tr>
<tr><td><code id="binSupervised+2B2Cmsi.dataset-method_+3A_usefullmz">useFullMZ</code></td>
<td>
<p>logical (default = 'TRUE&ldquo;). Whether all the peaks should be
used to perform the supervised segmentation.</p>
</td></tr>
<tr><td><code id="binSupervised+2B2Cmsi.dataset-method_+3A_method">method</code></td>
<td>
<p>string (default = 'svm'). Supervised classifier used to segment
the ROI.</p>
</td></tr>
<tr><td><code id="binSupervised+2B2Cmsi.dataset-method_+3A_verbose">verbose</code></td>
<td>
<p>boolean (default = 'TRUE'). Additional output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="#topic+ms.image-class">ms.image-class</a> object representing the binary mask image.
</p>


<h3>Author(s)</h3>

<p>Paolo Inglese <a href="mailto:p.inglese14@imperial.ac.uk">p.inglese14@imperial.ac.uk</a>
</p>

<hr>
<h2 id='bladderMALDIRompp2010'>Load the example MALDI-MSI data.</h2><span id='topic+bladderMALDIRompp2010'></span>

<h3>Description</h3>

<p>Loads a single mouse urinary bladder MALDI mass spectrometry imaging dataset
acquired in positive ionization mode using Thermo qExactive Orbitrap. The
dataset is available at
&quot;https://raw.github.com/paoloinglese/SPUTNIKexamples/master/data/bladder_maldi_prepr_MALDIquant.RData&quot;
The dataset is loaded in the R environment under the variable name <code>maldiData</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bladderMALDIRompp2010(verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bladderMALDIRompp2010_+3A_verbose">verbose</code></td>
<td>
<p>Logical (default = TRUE). Show additional output text.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>desiData MS intensity matrix. Rows represent pixels, columns represent
matched peaks.
</p>


<h3>References</h3>

<p>Rompp, A., Guenther, S., Schober, Y., Schulz, O., Takats, Z., Kummer, W.,
&amp; Spengler, B. (2010). Histology by mass spectrometry: label-free tissue
characterization obtained from high-accuracy bioanalytical imaging. Angewandte
chemie international edition, 49(22), 3834-3838.
</p>

<hr>
<h2 id='closeImage+2Cms.image-method'>Apply morphological closing to binary image.</h2><span id='topic+closeImage+2Cms.image-method'></span><span id='topic+closeImage'></span>

<h3>Description</h3>

<p>Apply morphological closing to binary image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ms.image'
closeImage(object, kern.size = 5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="closeImage+2B2Cms.image-method_+3A_object">object</code></td>
<td>
<p><a href="#topic+ms.image-class">ms.image-class</a> object. See <a href="#topic+msImage">msImage</a>.</p>
</td></tr>
<tr><td><code id="closeImage+2B2Cms.image-method_+3A_kern.size">kern.size</code></td>
<td>
<p>numeric. Kernel size.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="#topic+ms.image-class">ms.image-class</a> object after closing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load package
library("SPUTNIK")

## Create ms.image-class object
msIm &lt;- msImage(values = matrix(rnorm(200), 40, 50), name = "test", scale = TRUE)

## Generate binary image
msImBin &lt;- refImageBinaryOtsu(msIm)

## Apply the morphological closing
msImClosed &lt;- closeImage(msImBin, kern.size = 3)
</code></pre>

<hr>
<h2 id='countPixelsFilter'>Filter based on the minimum number of connected pixels in the ROI.</h2><span id='topic+countPixelsFilter'></span>

<h3>Description</h3>

<p><code>countPixelsFilter</code> selects peaks which signals are localized in regions
consisting of a minimum number of connected pixels in the ROI.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>countPixelsFilter(
  msiData,
  roiImage,
  minNumPixels = 9,
  smoothPeakImage = FALSE,
  smoothSigma = 2,
  closePeakImage = FALSE,
  closeKernSize = 5,
  aggressive = 0,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="countPixelsFilter_+3A_msidata">msiData</code></td>
<td>
<p><a href="#topic+msi.dataset-class">msi.dataset-class</a> object. See <a href="#topic+msiDataset">msiDataset</a>.</p>
</td></tr>
<tr><td><code id="countPixelsFilter_+3A_roiimage">roiImage</code></td>
<td>
<p><a href="#topic+ms.image-class">ms.image-class</a> object representing the ROI mask. See
<a href="#topic+msImage">msImage</a>.</p>
</td></tr>
<tr><td><code id="countPixelsFilter_+3A_minnumpixels">minNumPixels</code></td>
<td>
<p>integer (default = 9). Smallest number of connected pixels
used to select a peak.</p>
</td></tr>
<tr><td><code id="countPixelsFilter_+3A_smoothpeakimage">smoothPeakImage</code></td>
<td>
<p>logical (default = <code>FALSE</code>). Whether the peak
images should be smoothed before determining the connected components.</p>
</td></tr>
<tr><td><code id="countPixelsFilter_+3A_smoothsigma">smoothSigma</code></td>
<td>
<p>numeric (default = 2). Standard deviation of the smoothing Gaussian
kernel.</p>
</td></tr>
<tr><td><code id="countPixelsFilter_+3A_closepeakimage">closePeakImage</code></td>
<td>
<p>logical (default = <code>FALSE</code>). Whether morphological
closing should be applied to the binary peak images.</p>
</td></tr>
<tr><td><code id="countPixelsFilter_+3A_closekernsize">closeKernSize</code></td>
<td>
<p>numeric (default = 5). Kernel size for the morphological
closing operation. Kernel shape is fixed to <code>diamond</code>.</p>
</td></tr>
<tr><td><code id="countPixelsFilter_+3A_aggressive">aggressive</code></td>
<td>
<p>integer (default = 0). Defines the level of aggressiveness
of the filter. See 'Details' section.</p>
</td></tr>
<tr><td><code id="countPixelsFilter_+3A_verbose">verbose</code></td>
<td>
<p>logical (default = <code>TRUE</code>). Additional output text.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Count filter tries to determine and remove peaks which signal is
scattered in a region unrelated with the expected ROI. A minimum number of
connected pixels in the ROI is used to trigger the filter. This value should
be carefully set equal to the geometrical size of the smallest expected
informative sub-region. Each peak image is binarized using Otsu's thresholding
and the connected components are extracted. The filter selects those peaks
that show, within the ROI, at least one connected component of size larger or
equal to <code>minNumPixels</code>. The level of aggressiveness, associated with
increasing values of the parameter <code>aggressive</code>, determines whether the
size of the connected components within the ROI should be compared with that
of the connected components localized outside the ROI. If <code>aggressive = 0</code>,
no comparison is performed. If <code>aggressive = 1</code>, the filter checks whether
the max size of the connected components localized outside the ROI is smaller
or equal to the maximum size of the connected components inside the ROI.
If <code>aggressive = 2</code>, a stricter filter checks whether the maximum size
of the connected components localized outside the ROI is smaller than
<code>minNumPixels</code>. Different aggressiveness levels can produce completely
different results, depending on the nature of the analyzed dataset.
</p>


<h3>Value</h3>

<p><code>peak.filter</code> object. See <a href="#topic+applyPeaksFilter-msi.dataset-method">applyPeaksFilter-msi.dataset-method</a>.
</p>


<h3>Author(s)</h3>

<p>Paolo Inglese <a href="mailto:p.inglese14@imperial.ac.uk">p.inglese14@imperial.ac.uk</a>
</p>


<h3>See Also</h3>

<p>applyPeaksFilter
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load package
library("SPUTNIK")

## Mass spectrometry intensity matrix
X &lt;- matrix(rnorm(16000), 400, 40)
X[X &lt; 0] &lt;- 0

## Print original dimensions
print(dim(X))

## m/z vector
mzVector &lt;- seq(600, 900, by = (900 - 600) / 39)

## Read the image size
imSize &lt;- c(20, 20)

## Construct the ms.dataset object
msiX &lt;- msiDataset(X, mzVector, imSize[1], imSize[2])

## Extract the ROI using k-means

refImg &lt;- refImageContinuous(msiX, method = "sum")
roiImg &lt;- refImageBinaryOtsu(refImg)

## Perform count pixels filtering
count.sel &lt;- countPixelsFilter(
  msiData = msiX, roiImage = roiImg,
  minNumPixels = 4, aggressive = 1
)

## Apply the filter
msiX &lt;- applyPeaksFilter(msiX, count.sel)

## Print new dimensions
print(dim(getIntensityMat(msiX)))
</code></pre>

<hr>
<h2 id='createPeaksFilter'>Generate a peak filter object.</h2><span id='topic+createPeaksFilter'></span>

<h3>Description</h3>

<p><a href="#topic+createPeaksFilter">createPeaksFilter</a> returns a <code>peak.filter</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createPeaksFilter(peaksIndices)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createPeaksFilter_+3A_peaksindices">peaksIndices</code></td>
<td>
<p>a named array representing the selected peaks. Names correspond
to the m/z values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function to create a custom peak that can be subsequently applied using
the function <code><a href="#topic+applyPeaksFilter-msi.dataset-method">applyPeaksFilter-msi.dataset-method</a></code>. Argument of
the function is the index vector of the selected peaks named with their m/z
values. The m/z values are used to check whether the indices correspond to the
common m/z values in the <code><a href="#topic+msi.dataset-class">msi.dataset-class</a></code> object.
</p>


<h3>Value</h3>

<p><code>peak.filter</code> object.
</p>


<h3>Author(s)</h3>

<p>Paolo Inglese <a href="mailto:p.inglese14@imperial.ac.uk">p.inglese14@imperial.ac.uk</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+applyPeaksFilter-msi.dataset-method">applyPeaksFilter-msi.dataset-method</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("SPUTNIK")
mz &lt;- seq(100, 195, 5)
mzIdx &lt;- sample(100, 20)
names(mzIdx) &lt;- mz
peaksFilter &lt;- createPeaksFilter(mzIdx)
</code></pre>

<hr>
<h2 id='CSRPeaksFilter'>Performs the peak selection based on complete spatial randomness test.</h2><span id='topic+CSRPeaksFilter'></span>

<h3>Description</h3>

<p><code>CSRPeaksFilter</code> returns the significance for the null hypothesis that the
spatial distribution of the peak intensities follow a random pattern. A
significant p-value (q-values can be returned after applying multiple testing
correction) allows to reject the hypothesis that the spatial distribution of
a peak signal is random. The tests are performed using the functions available
in the <code>statspat</code> R package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CSRPeaksFilter(
  msiData,
  method = "ClarkEvans",
  covariateImage = NULL,
  adjMethod = "bonferroni",
  returnQvalues = TRUE,
  plotCovariate = FALSE,
  cores = 1,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CSRPeaksFilter_+3A_msidata">msiData</code></td>
<td>
<p><a href="#topic+msi.dataset-class">msi.dataset-class</a> object. See <a href="#topic+msiDataset">msiDataset</a>.</p>
</td></tr>
<tr><td><code id="CSRPeaksFilter_+3A_method">method</code></td>
<td>
<p>string (default = <code>"ClarkEvans"</code>). CSR statistical test
applied to the peaks signal. Accepted values are:
</p>

<ul>
<li><p> &quot;ClarkEvans&quot;: performs a test based on the Clark and Evans aggregation
R index. This test evaluates the compares of the nearest-neighbors distances
to the case of purely random pattern.
</p>
</li>
<li><p> &quot;KS&quot;: performs a test of goodness-of-fit between the signal pixels
associated point process pattern and a spatial covariate using the
Kolmogorov-Smirnov test. The covariate is defined by the reference image.
</p>
</li></ul>
</td></tr>
<tr><td><code id="CSRPeaksFilter_+3A_covariateimage">covariateImage</code></td>
<td>
<p><a href="#topic+ms.image-class">ms.image-class</a> object. An image used as covariate
(required for Kolmogorov-Smirnov test).</p>
</td></tr>
<tr><td><code id="CSRPeaksFilter_+3A_adjmethod">adjMethod</code></td>
<td>
<p>string (default = <code>"bonferroni"</code>). Multiple testing correction
method. Possible values coincide with those of the <code>stats::p.adjust</code> function.</p>
</td></tr>
<tr><td><code id="CSRPeaksFilter_+3A_returnqvalues">returnQvalues</code></td>
<td>
<p>logical (default = <code>TRUE</code>). Whether the computed
q-values should be returned together with the p-values.</p>
</td></tr>
<tr><td><code id="CSRPeaksFilter_+3A_plotcovariate">plotCovariate</code></td>
<td>
<p>logical (default = <code>FALSE</code>). Whether the covariate image
should be visualized. Read only when <code>method = "KS"</code>.</p>
</td></tr>
<tr><td><code id="CSRPeaksFilter_+3A_cores">cores</code></td>
<td>
<p>integer (default = 1). Number of CPU cores. Parallel computation if
greater than 1.</p>
</td></tr>
<tr><td><code id="CSRPeaksFilter_+3A_verbose">verbose</code></td>
<td>
<p>logical (default = <code>TRUE</code>). Additional output texts are
generated.</p>
</td></tr>
<tr><td><code id="CSRPeaksFilter_+3A_...">...</code></td>
<td>
<p>additional parameters compatible with the <code>statspat.core</code> functions.
See <a href="spatstat.explore.html#topic+cdf.test">cdf.test</a> for &quot;KS&quot; and <a href="spatstat.explore.html#topic+clarkevans.test">clarkevans.test</a>.
for &quot;ClarkEvans&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of the p-values and adjusted p-values for the CSR test.
</p>


<h3>Author(s)</h3>

<p>Paolo Inglese <a href="mailto:p.inglese14@imperial.ac.uk">p.inglese14@imperial.ac.uk</a>
</p>


<h3>References</h3>

<p>Baddeley, A., &amp; Turner, R. (2005). Spatstat: an R package for
analyzing spatial point patterns. Journal of statistical software, 12(6), 1-42.
</p>
<p>Clark, P.J. and Evans, F.C. (1954) Distance to nearest neighbour
as a measure of spatial relationships in populations. Ecology 35, 445–453.
</p>
<p>Berman, M. (1986) Testing for spatial association between a point
process and another stochastic process. Applied Statistics 35, 54–62.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load package
library("SPUTNIK")

## Mass spectrometry intensity matrix
X &lt;- matrix(rnorm(16000), 400, 40)
X[X &lt; 0] &lt;- 0

## Print original dimensions
print(dim(X))

## m/z vector
mzVector &lt;- seq(600, 900, by = (900 - 600) / 39)

## Read the image size
imSize &lt;- c(20, 20)

## Construct the ms.dataset object
msiX &lt;- msiDataset(X, mzVector, imSize[1], imSize[2])

## Calculate the p-values using the Clark Evans test, then apply Benjamini-
## Hochberg correction.
csr &lt;- CSRPeaksFilter(
  msiData = msiX, method = "ClarkEvans",
  calculateCovariate = FALSE, adjMethod = "BH"
)

## Print selected peaks
print(csr$q.value)

## Create a new filter selecting corrected p-values &lt; 0.001
selIdx &lt;- which(csr$q.value &lt; 0.001)
csrFilter &lt;- createPeaksFilter(selIdx)
</code></pre>

<hr>
<h2 id='getIntensityMat+2Cmsi.dataset-method'>Return the peaks intensity matrix.</h2><span id='topic+getIntensityMat+2Cmsi.dataset-method'></span><span id='topic+getIntensityMat'></span>

<h3>Description</h3>

<p>Return the peaks intensity matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'msi.dataset'
getIntensityMat(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getIntensityMat+2B2Cmsi.dataset-method_+3A_object">object</code></td>
<td>
<p><a href="#topic+msi.dataset-class">msi.dataset-class</a> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>peaks intensity matrix. Rows represent pixels, and columns represent
peaks.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load package
library("SPUTNIK")

## Create the msi.dataset-class object
sz &lt;- c(5, 4)
x &lt;- matrix(rnorm(sz[1] * sz[2] * 20), sz[1] * sz[2], 20)
x[x &lt; 0] &lt;- 0
mz &lt;- sort(sample(100, ncol(x)))
msiX &lt;- msiDataset(x, mz, sz[1], sz[2])

## Get m/z vector
mz &lt;- getMZ(msiX)

## Get intensity matrix
X &lt;- getIntensityMat(msiX)

## Get image size
sz &lt;- getShapeMSI(msiX)
</code></pre>

<hr>
<h2 id='getMZ+2Cmsi.dataset-method'>Return the m/z vector.</h2><span id='topic+getMZ+2Cmsi.dataset-method'></span><span id='topic+getMZ'></span>

<h3>Description</h3>

<p>Return the m/z vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'msi.dataset'
getMZ(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getMZ+2B2Cmsi.dataset-method_+3A_object">object</code></td>
<td>
<p><a href="#topic+msi.dataset-class">msi.dataset-class</a> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector containing the m/z values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load package
library("SPUTNIK")

## Create the msi.dataset-class object
sz &lt;- c(5, 4)
x &lt;- matrix(rnorm(sz[1] * sz[2] * 20), sz[1] * sz[2], 20)
x[x &lt; 0] &lt;- 0
mz &lt;- sort(sample(100, ncol(x)))
msiX &lt;- msiDataset(x, mz, sz[1], sz[2])

## Get m/z vector
mz &lt;- getMZ(msiX)

## Get intensity matrix
X &lt;- getIntensityMat(msiX)

## Get image size
sz &lt;- getShapeMSI(msiX)
</code></pre>

<hr>
<h2 id='getShapeMSI+2Cmsi.dataset-method'>Returns the geometrical shape of MSI dataset</h2><span id='topic+getShapeMSI+2Cmsi.dataset-method'></span><span id='topic+getShapeMSI'></span>

<h3>Description</h3>

<p>Returns the geometrical shape of MSI dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'msi.dataset'
getShapeMSI(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getShapeMSI+2B2Cmsi.dataset-method_+3A_object">object</code></td>
<td>
<p><a href="#topic+msi.dataset-class">msi.dataset-class</a> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>number of rows ans number of columns of the MS image.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load package
library("SPUTNIK")

## Create the msi.dataset-class object
sz &lt;- c(5, 4)
x &lt;- matrix(rnorm(sz[1] * sz[2] * 20), sz[1] * sz[2], 20)
x[x &lt; 0] &lt;- 0
mz &lt;- sort(sample(100, ncol(x)))
msiX &lt;- msiDataset(x, mz, sz[1], sz[2])

## Get m/z vector
mz &lt;- getMZ(msiX)

## Get intensity matrix
X &lt;- getIntensityMat(msiX)

## Get image size
sz &lt;- getShapeMSI(msiX)
</code></pre>

<hr>
<h2 id='gini.index'>Gini index.</h2><span id='topic+gini.index'></span>

<h3>Description</h3>

<p><code>gini.index</code> returns the Gini index of the ion intensity vector as a
measure of its sparseness. The intensity vector is first quantized in N
levels (default = 256). A value close to 1 represents a high level of
sparseness, a value close to 0 represents a low level of sparseness.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gini.index(x, levels = 256)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gini.index_+3A_x">x</code></td>
<td>
<p>numeric. Peak intensity array.</p>
</td></tr>
<tr><td><code id="gini.index_+3A_levels">levels</code></td>
<td>
<p>numeric (default = 256). Number of levels for the peak
intensity quantization.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A value between 0 and 1. High levels of signal sparsity are associated
with values close to 1, whereas low levels of signal sparsity are associated
with values close to 0.
</p>


<h3>Author(s)</h3>

<p>Paolo Inglese <a href="mailto:p.inglese14@imperial.ac.uk">p.inglese14@imperial.ac.uk</a>
</p>


<h3>References</h3>

<p>Hurley, N., &amp; Rickard, S. (2009). Comparing measures of sparsity.
IEEE Transactions on Information Theory, 55(10), 4723-4741.
</p>


<h3>See Also</h3>

<p><a href="#topic+scatter.ratio">scatter.ratio</a> <a href="#topic+spatial.chaos">spatial.chaos</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load package
library("SPUTNIK")

## Image
im &lt;- matrix(rnorm(100), 10, 10)
im[im &lt; 0] &lt;- 0

## Spatial chaos
sc &lt;- spatial.chaos(im, levels = 30, morph = TRUE)
stopifnot(sc &lt;= 1)

## Gini index
gi &lt;- gini.index(im, levels = 16)
stopifnot(gi &gt;= -1 &amp;&amp; gi &lt;= 1)

## Scatter ratio
sr &lt;- scatter.ratio(im)
stopifnot(sr &lt;= 1)
</code></pre>

<hr>
<h2 id='globalPeaksFilter'>Reference similarity based peak selection.</h2><span id='topic+globalPeaksFilter'></span>

<h3>Description</h3>

<p><code>globalPeaksFilter</code> returns a list of peaks selected by their similarity
with a reference image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>globalPeaksFilter(
  msiData,
  referenceImage,
  method = "pearson",
  threshold = NULL,
  cores = 1,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="globalPeaksFilter_+3A_msidata">msiData</code></td>
<td>
<p><a href="#topic+msi.dataset-class">msi.dataset-class</a> object. See <a href="#topic+msiDataset">msiDataset</a>.</p>
</td></tr>
<tr><td><code id="globalPeaksFilter_+3A_referenceimage">referenceImage</code></td>
<td>
<p><a href="#topic+ms.image-class">ms.image-class</a> object. Reference image used
to calculate the similarity values.</p>
</td></tr>
<tr><td><code id="globalPeaksFilter_+3A_method">method</code></td>
<td>
<p>method used to calculate the similariry between the peak
intensities and the reference image. Accepted values are:
</p>

<ul>
<li> <p><code>pearson</code>: Pearson's correlation
</p>
</li>
<li> <p><code>spearman</code>: Spearman's correlation
</p>
</li>
<li> <p><code>ssim</code>: structural similarity index measure
</p>
</li>
<li> <p><code>nmi</code>: normalized mutual information.
</p>
</li></ul>
</td></tr>
<tr><td><code id="globalPeaksFilter_+3A_threshold">threshold</code></td>
<td>
<p>numeric (default = 0, default = 0.001 (SSIM)). The threshold
applied to the similarity values between the peaks images and the reference
image. The default value of 0 guarantees that only the ions with a positive
similarity with the reference image (typically representing the spatial
distribution of the signal source) are retrieved. For consistency, the NMI are
scaled in [-1, 1] to match the same range of correlations.</p>
</td></tr>
<tr><td><code id="globalPeaksFilter_+3A_cores">cores</code></td>
<td>
<p>integer (default = 1). Number of cores for parallel computing.</p>
</td></tr>
<tr><td><code id="globalPeaksFilter_+3A_verbose">verbose</code></td>
<td>
<p>logical (default = <code>TRUE</code>). Additional output text.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A filter based on the similarity between the peak signals and a reference
signal. The reference signal, passed as an <code><a href="#topic+ms.image-class">ms.image-class</a></code> object.
Both continuous and binary references can be passed. The filter then calculates the similarity
between the peaks signal and the reference image and select those with a similarity
larger than <code>threshold</code>. Multiple measures are available, correlation,
structural similarity index measure (SSIM), and normalized mutual information (NMI).
Since correlation can assume values in [-1, 1], also NMI are scaled in [-1, 1].
</p>


<h3>Value</h3>

<p><code>peak.filter</code> object. See <a href="#topic+applyPeaksFilter">applyPeaksFilter</a>.
</p>


<h3>Author(s)</h3>

<p>Paolo Inglese <a href="mailto:p.inglese14@imperial.ac.uk">p.inglese14@imperial.ac.uk</a>
</p>


<h3>References</h3>

<p>Wang, Z., Bovik, A. C., Sheikh, H. R., &amp; Simoncelli, E. P. (2004).
Image quality assessment: from error visibility to structural similarity.
IEEE transactions on image processing, 13(4), 600-612.
</p>
<p>Meyer, P. E. (2009). Infotheo: information-theoretic measures.
R package. Version, 1(0).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+countPixelsFilter">countPixelsFilter</a></code> <code><a href="#topic+applyPeaksFilter-msi.dataset-method">applyPeaksFilter-msi.dataset-method</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load package
library("SPUTNIK")

## Mass spectrometry intensity matrix
X &lt;- matrix(rnorm(16000), 400, 40)
X[X &lt; 0] &lt;- 0

## Print original dimensions
print(dim(X))

## m/z vector
mzVector &lt;- seq(600, 900, by = (900 - 600) / 39)

## Read the image size
imSize &lt;- c(20, 20)

## Construct the ms.dataset object
msiX &lt;- msiDataset(X, mzVector, imSize[1], imSize[2])

## Generate the reference image and the ROI mask
refImg &lt;- refImageContinuous(msiX, method = "sum")

## Perform global peaks filter
glob.peaks &lt;- globalPeaksFilter(
  msiData = msiX, referenceImage = refImg,
  method = "pearson", threshold = 0
)

## Apply the filter
msiX &lt;- applyPeaksFilter(msiX, glob.peaks)

## Print the new dimensions
print(dim(getIntensityMat(msiX)))
</code></pre>

<hr>
<h2 id='invertImage+2Cms.image-method'>Invert the colors of an MS image.</h2><span id='topic+invertImage+2Cms.image-method'></span><span id='topic+invertImage'></span>

<h3>Description</h3>

<p>Invert the colors of an MS image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ms.image'
invertImage(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="invertImage+2B2Cms.image-method_+3A_object">object</code></td>
<td>
<p><a href="#topic+ms.image-class">ms.image-class</a> object. See <a href="#topic+msImage">msImage</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="#topic+ms.image-class">ms.image-class</a> object after inverting colors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load package
library("SPUTNIK")

## Create ms.image-class object
msIm &lt;- msImage(values = matrix(rnorm(200), 40, 50), name = "test", scale = TRUE)

## Invert the colors
msImInverted &lt;- invertImage(msIm)
</code></pre>

<hr>
<h2 id='ms.image-class'><a href="#topic+ms.image-class">ms.image-class</a> definition.</h2><span id='topic+ms.image-class'></span>

<h3>Description</h3>

<p><a href="#topic+ms.image-class">ms.image-class</a> definition.
</p>


<h3>Slots</h3>


<dl>
<dt><code>values</code></dt><dd><p>numeric 2-D matrix representing the pixel intensity values.</p>
</dd>
<dt><code>name</code></dt><dd><p>string. Image name used for plotting.</p>
</dd>
<dt><code>scaled</code></dt><dd><p>logical. Whether the pixels intensities have been scaled in [0, 1]
or not.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Paolo Inglese <a href="mailto:p.inglese14@imperial.ac.uk">p.inglese14@imperial.ac.uk</a>
</p>

<hr>
<h2 id='msi.dataset-class'><a href="#topic+msi.dataset-class">msi.dataset-class</a> S4 class definition containing the information about
the mass spectrometry imaging dataset.</h2><span id='topic+msi.dataset-class'></span>

<h3>Description</h3>

<p><a href="#topic+msi.dataset-class">msi.dataset-class</a> S4 class definition containing the information about
the mass spectrometry imaging dataset.
</p>


<h3>Slots</h3>


<dl>
<dt><code>matrix</code></dt><dd><p>the peaks intensity matrix. Rows represent pixels, and columns
represent peaks.</p>
</dd>
<dt><code>mz</code></dt><dd><p>vector of matched m/z values.</p>
</dd>
<dt><code>nrow</code></dt><dd><p>geometrical shape (number of rows) of image.</p>
</dd>
<dt><code>ncol</code></dt><dd><p>geometrical shape (number of columns) of image.</p>
</dd>
<dt><code>norm</code></dt><dd><p>normalization method.</p>
</dd>
<dt><code>normoffset</code></dt><dd><p>numeric offset used for the normalization.</p>
</dd>
<dt><code>vartr</code></dt><dd><p>variance stabilizing transformation.</p>
</dd>
<dt><code>vartroffset</code></dt><dd><p>numeric offset used for the variance stabilizing transformation.</p>
</dd>
<dt><code>numdetected</code></dt><dd><p>msImage of number of detected peaks.</p>
</dd>
<dt><code>totalioncount</code></dt><dd><p>msImage of total-ion-count per pixel.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Paolo Inglese <a href="mailto:p.inglese14@imperial.ac.uk">p.inglese14@imperial.ac.uk</a>
</p>

<hr>
<h2 id='msiDataset'>Constructor for <a href="#topic+msi.dataset-class">msi.dataset-class</a> objects.</h2><span id='topic+msiDataset'></span>

<h3>Description</h3>

<p><code>msiDataset</code> returns a <a href="#topic+msi.dataset-class">msi.dataset-class</a> object. It
contains information about the matched peaks intensities, the geometrical
dimensions of the mass spectral image, and the common m/z values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msiDataset(values, mz, rsize, csize, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="msiDataset_+3A_values">values</code></td>
<td>
<p>numeric matrix containing the peaks intensities. Rows represent
pixels and columns represent peaks.</p>
</td></tr>
<tr><td><code id="msiDataset_+3A_mz">mz</code></td>
<td>
<p>array of m/z peaks values.</p>
</td></tr>
<tr><td><code id="msiDataset_+3A_rsize">rsize</code></td>
<td>
<p>geometric shape (number of rows) of image.</p>
</td></tr>
<tr><td><code id="msiDataset_+3A_csize">csize</code></td>
<td>
<p>geometric shape (number of columns) of image.</p>
</td></tr>
<tr><td><code id="msiDataset_+3A_verbose">verbose</code></td>
<td>
<p>boolean (default = TRUE). Additional output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function used to construct the main object <code><a href="#topic+msi.dataset-class">msi.dataset-class</a></code>.
This object contains all the information about peaks intensities (intensity
matrix), the geometrical shape of the image (rows, columns), and the vector
of the common m/z values, generated during the peak matching process.
</p>


<h3>Value</h3>

<p><a href="#topic+msi.dataset-class">msi.dataset-class</a> object.
</p>


<h3>Author(s)</h3>

<p>Paolo Inglese <a href="mailto:p.inglese14@imperial.ac.uk">p.inglese14@imperial.ac.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load package
library("SPUTNIK")

## Create the msi.dataset-class object
sz &lt;- c(5, 4)
numIons &lt;- 20
x &lt;- matrix(rnorm(prod(sz) * numIons), prod(sz), numIons)
mz &lt;- sort(sample(100, numIons))
msiX &lt;- msiDataset(x, mz, sz[1], sz[2])
</code></pre>

<hr>
<h2 id='msImage'>Constructor for <a href="#topic+ms.image-class">ms.image-class</a> objects.</h2><span id='topic+msImage'></span>

<h3>Description</h3>

<p>Constructor for <a href="#topic+ms.image-class">ms.image-class</a> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msImage(values, name = character(), scale = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="msImage_+3A_values">values</code></td>
<td>
<p>numeric matrix representing the pixels intensities. Rows and
columns represent the geometrical shape of the image.</p>
</td></tr>
<tr><td><code id="msImage_+3A_name">name</code></td>
<td>
<p>image name.</p>
</td></tr>
<tr><td><code id="msImage_+3A_scale">scale</code></td>
<td>
<p>logical (default = TRUE). Whether the intensities should be
scaled in [0, 1].</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="#topic+ms.image-class">ms.image-class</a> object.
</p>


<h3>Author(s)</h3>

<p>Paolo Inglese <a href="mailto:p.inglese14@imperial.ac.uk">p.inglese14@imperial.ac.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load package
library("SPUTNIK")

## MS image
imShape &lt;- c(40, 50)
matIm &lt;- matrix(rnorm(200), imShape[1], imShape[2])
im &lt;- msImage(values = matIm, name = "random", scale = TRUE)
</code></pre>

<hr>
<h2 id='NMI'>Normalized mutual information (NMI).</h2><span id='topic+NMI'></span>

<h3>Description</h3>

<p><code>NMI</code> returns the normalized mutual information between two <code>ms.image</code>
objects. The normalized mutual information is calculated as the mutual information
divided by square-root of the product of the entropies. This function makes
use of the functions available in <code>infotheo</code> R package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMI(x, y, numBins = 256)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NMI_+3A_x">x</code></td>
<td>
<p>numeric array. Image 1 color intensity array.</p>
</td></tr>
<tr><td><code id="NMI_+3A_y">y</code></td>
<td>
<p>numeric array. Image 2 (binary mask).</p>
</td></tr>
<tr><td><code id="NMI_+3A_numbins">numBins</code></td>
<td>
<p>numeric. Number of bins for discretizing the image colors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NMI value between 0 and 1.
</p>


<h3>Author(s)</h3>

<p>Paolo Inglese <a href="mailto:p.inglese14@imperial.ac.uk">p.inglese14@imperial.ac.uk</a>
</p>


<h3>References</h3>

<p>Meyer, P. E. (2009). Infotheo: information-theoretic measures.
R package. Version, 1(0).
</p>

<hr>
<h2 id='normIntensity+2Cmsi.dataset-method'>Normalize the peaks intensities.</h2><span id='topic+normIntensity+2Cmsi.dataset-method'></span><span id='topic+normIntensity'></span>

<h3>Description</h3>

<p>Normalize the peaks intensities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'msi.dataset'
normIntensity(object, method = "median", peaksInd = NULL, offsetZero = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normIntensity+2B2Cmsi.dataset-method_+3A_object">object</code></td>
<td>
<p><a href="#topic+msi.dataset-class">msi.dataset-class</a> object.</p>
</td></tr>
<tr><td><code id="normIntensity+2B2Cmsi.dataset-method_+3A_method">method</code></td>
<td>
<p>string (default = <code>"median"</code>). The normalization method to
be used. Valid values are: <code>"median"</code>, <code>"PQN"</code>, <code>"TIC"</code>,
<code>TMM</code>, or <code>"upperQuartile"</code>.
See 'Details' section.</p>
</td></tr>
<tr><td><code id="normIntensity+2B2Cmsi.dataset-method_+3A_peaksind">peaksInd</code></td>
<td>
<p>numeric array (default = NULL). Array of peak indices used to
calculate the scaling factors (TIC, median). If NULL, all the peaks are used.</p>
</td></tr>
<tr><td><code id="normIntensity+2B2Cmsi.dataset-method_+3A_offsetzero">offsetZero</code></td>
<td>
<p>numeric (default = 0). This value is added to all the peak
intensities to take into accounts of the zeros.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The valid values for <code>method</code> are:
</p>

<ul>
<li> <p><code>"median"</code>: median of spectrum intensities is scaled to one.
</p>
</li>
<li> <p><code>"PQN"</code>:
</p>

<ol>
<li><p> apply <code>"TIC"</code> normalization
</p>
</li>
<li><p> calculate the median reference spectrum (after removing the zeros)
</p>
</li>
<li><p> calculate the quotients of peaks intensities and reference
</p>
</li>
<li><p> calculate the median of quotients for each peak (after removing the zeros)
</p>
</li>
<li><p> divide all the peak intensities by the median of quotients
</p>
</li></ol>

</li>
<li> <p><code>"TIC"</code>: total ion current normalization assign the sum of the
peaks intensities to one.
</p>
</li>
<li> <p><code>"TMM"</code>: trimmed mean of M-values (TMM with zero pairing).
Called TMMwzp in edgeR.
</p>
</li>
<li> <p><code>"upperQuartile"</code>: spectra are scaled by their 3rd quartile.
</p>
</li></ul>



<h3>Value</h3>

<p>object <a href="#topic+msi.dataset-class">msi.dataset-class</a> object, with normalized peaks
intensities.
</p>
<p>When using TIC scaling, if zeros are present in the matrix, a positive offset
must be added to all the peak intensities through the parameter <code>offsetZero</code>.
This is necessary for applying the CLR transformation. TIC scaling transforms the
spectra into compositional data; in this case the CLR transformation must be
applied through the varTransform function.
</p>


<h3>Author(s)</h3>

<p>Paolo Inglese <a href="mailto:p.inglese14@imperial.ac.uk">p.inglese14@imperial.ac.uk</a>
</p>


<h3>References</h3>

<p>F. Dieterle, A. Ross, G. Schlotterbeck, and Hans Senn. 2006.
Probabilistic quotient normalization as robust method to account for dilution
of complex biological mixtures. Application in 1H NMR metabonomics.
Analytical Chemistry 78(13): 4281-4290.
</p>
<p>Robinson MD, Oshlack A (2010). A scaling normalization method for
differential expression analysis of RNA-seq data. Genome Biology 11, R25.
</p>


<h3>See Also</h3>

<p><a href="#topic+msi.dataset-class">msi.dataset-class</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load package
library("SPUTNIK")

## Create the msi.dataset-class object
sz &lt;- c(40, 40)
x &lt;- matrix(rnorm(sz[1] * sz[2] * 20) * 1000, sz[1] * sz[2], 20)
x[x &lt; 0] &lt;- 0 # MS data is positive
mz &lt;- sort(sample(100, ncol(x)))
msiX &lt;- msiDataset(x, mz, sz[1], sz[2])

## Normalize and log-transform
msiX &lt;- normIntensity(msiX, "median")
msiX &lt;- varTransform(msiX, "log")

## Create the msi.dataset-class object
sz &lt;- c(40, 40)
x &lt;- matrix(rnorm(sz[1] * sz[2] * 20) * 1000, sz[1] * sz[2], 20)
x[x &lt; 0] &lt;- 0 # MS data is positive
mz &lt;- sort(sample(100, ncol(x)))
msiX &lt;- msiDataset(x, mz, sz[1], sz[2])

## Normalize using PQN
msiX &lt;- normIntensity(msiX, "PQN")
</code></pre>

<hr>
<h2 id='numDetectedMSI+2Cmsi.dataset-method'>Generates an msImage representing the number of detected peaks per pixel. This
image can be used to qualitatively evaluate the spatial heterogeneity of the
sample.</h2><span id='topic+numDetectedMSI+2Cmsi.dataset-method'></span><span id='topic+numDetectedMSI'></span>

<h3>Description</h3>

<p>Generates an msImage representing the number of detected peaks per pixel. This
image can be used to qualitatively evaluate the spatial heterogeneity of the
sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'msi.dataset'
numDetectedMSI(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="numDetectedMSI+2B2Cmsi.dataset-method_+3A_object">object</code></td>
<td>
<p><a href="#topic+msi.dataset-class">msi.dataset-class</a> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="#topic+ms.image-class">ms.image-class</a> object representing the detected ions per pixel.
</p>

<hr>
<h2 id='ovarianDESIDoria2016'>Load the example DESI-MSI data.</h2><span id='topic+ovarianDESIDoria2016'></span>

<h3>Description</h3>

<p>Loads a single human ovarian cancer DESI mass spectrometry imaging dataset
acquired in negative ionization mode using Waters XEVO-GS2 qToF. The
dataset is available at
&quot;https://raw.github.com/paoloinglese/SPUTNIKexamples/master/data/ovarian_xevo_prepr_MALDIquant.RData&quot;
The dataset is loaded in the R environment under the variable name <code>maldiData</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ovarianDESIDoria2016(verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ovarianDESIDoria2016_+3A_verbose">verbose</code></td>
<td>
<p>Logical (default = TRUE). Show additional output text.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>maldiData MS intensity matrix. Rows represent pixels, columns represent
matched peaks.
</p>


<h3>References</h3>

<p>Doria, M. L., McKenzie, J. S., Mroz, A., Phelps, D. L., Speller,
A., Rosini, F., ... &amp; Ghaem-Maghami, S. (2016). Epithelial ovarian carcinoma
diagnosis by desorption electrospray ionization mass spectrometry imaging.
Scientific reports, 6, 39219.
</p>

<hr>
<h2 id='PCAImage+2Cmsi.dataset-method'>Generates an RGB msImage representing the first 3 principal components. This
image can be used to qualitatively evaluate the spatial heterogeneity of the
sample.</h2><span id='topic+PCAImage+2Cmsi.dataset-method'></span><span id='topic+PCAImage'></span>

<h3>Description</h3>

<p>Generates an RGB msImage representing the first 3 principal components. This
image can be used to qualitatively evaluate the spatial heterogeneity of the
sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'msi.dataset'
PCAImage(object, alignToSample = TRUE, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCAImage+2B2Cmsi.dataset-method_+3A_object">object</code></td>
<td>
<p><a href="#topic+msi.dataset-class">msi.dataset-class</a> object.</p>
</td></tr>
<tr><td><code id="PCAImage+2B2Cmsi.dataset-method_+3A_aligntosample">alignToSample</code></td>
<td>
<p>boolean (default = TRUE). If TRUE, the principal component
scores are aligned to the pixel mean intensity.</p>
</td></tr>
<tr><td><code id="PCAImage+2B2Cmsi.dataset-method_+3A_seed">seed</code></td>
<td>
<p>set the random seed (default = <code>NULL</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>RGB raster representing the first 3 principal components
(see <a href="#topic+msImage">msImage</a>).
</p>

<hr>
<h2 id='plot+2Cms.image+2Cmissing-method'>Visualize an MS image.
<code>plot</code> extends the generic function to <a href="#topic+ms.image-class">ms.image-class</a> objects.</h2><span id='topic+plot+2Cms.image+2Cmissing-method'></span><span id='topic+plot'></span>

<h3>Description</h3>

<p>Visualize an MS image.
<code>plot</code> extends the generic function to <a href="#topic+ms.image-class">ms.image-class</a> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ms.image,missing'
plot(x, palette = "inferno")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot+2B2Cms.image+2B2Cmissing-method_+3A_x">x</code></td>
<td>
<p><a href="#topic+ms.image-class">ms.image-class</a> object. See <a href="#topic+msImage">msImage</a>.</p>
</td></tr>
<tr><td><code id="plot+2B2Cms.image+2B2Cmissing-method_+3A_palette">palette</code></td>
<td>
<p>string. Color palette. See <a href="viridis.html#topic+viridis">viridis</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot2 plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load package


  library("SPUTNIK")

  ## Create ms.image-class object
  msIm &lt;- msImage(values = matrix(rnorm(200), 40, 50), name = "test", scale = TRUE)
  
  ## Plot the image
  plot(msIm)

</code></pre>

<hr>
<h2 id='refImageBinaryKmeans'>Calculate the binary reference image using k-means clustering. K-Means is run
on the first 'npcs' principal components to speed up the calculations.</h2><span id='topic+refImageBinaryKmeans'></span><span id='topic+refImageOtsu'></span>

<h3>Description</h3>

<p>Calculate the binary reference image using k-means clustering. K-Means is run
on the first 'npcs' principal components to speed up the calculations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>refImageBinaryKmeans(
  dataset,
  npcs = 10,
  alignTo = "detected",
  invertAligned = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="refImageBinaryKmeans_+3A_dataset">dataset</code></td>
<td>
<p><a href="#topic+msi.dataset-class">msi.dataset-class</a> object. See <a href="#topic+msiDataset">msiDataset</a>.</p>
</td></tr>
<tr><td><code id="refImageBinaryKmeans_+3A_npcs">npcs</code></td>
<td>
<p>int (default = 10). Number of principal components to calculate.</p>
</td></tr>
<tr><td><code id="refImageBinaryKmeans_+3A_alignto">alignTo</code></td>
<td>
<p>string (default = &quot;detected&quot;). Sample reference image to align
the estimate binary image. It is expected to correlate with the sample location.</p>
</td></tr>
<tr><td><code id="refImageBinaryKmeans_+3A_invertaligned">invertAligned</code></td>
<td>
<p>boolean (default = FALSE). If TRUE, the binary image is
inverted after being aligned to the sample reference (<code>alignTo</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="#topic+ms.image-class">ms.image-class</a> object with binary intensities.
</p>

<hr>
<h2 id='refImageBinaryKmeansMulti'>Calculate the binary reference image using k-means clustering with multi-cluster
merging. K-means is run on the first 'npcs' principal 
components to speed up the calculations.</h2><span id='topic+refImageBinaryKmeansMulti'></span>

<h3>Description</h3>

<p>Calculate the binary reference image using k-means clustering with multi-cluster
merging. K-means is run on the first 'npcs' principal 
components to speed up the calculations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>refImageBinaryKmeansMulti(
  dataset,
  npcs = 10,
  mzQuery = numeric(),
  mzTolerance = Inf,
  useFullMZ = TRUE,
  numClusters = 4,
  kernelSize = 5,
  cores = 1,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="refImageBinaryKmeansMulti_+3A_dataset">dataset</code></td>
<td>
<p><a href="#topic+msi.dataset-class">msi.dataset-class</a> object. See <a href="#topic+msiDataset">msiDataset</a>.</p>
</td></tr>
<tr><td><code id="refImageBinaryKmeansMulti_+3A_npcs">npcs</code></td>
<td>
<p>int (default = 10). Number of principal components to calculate.</p>
</td></tr>
<tr><td><code id="refImageBinaryKmeansMulti_+3A_mzquery">mzQuery</code></td>
<td>
<p>numeric. Values of m/z used to calculate the reference image.
2 values are interpreted as interval, multiple or single values are searched
in the m/z vector. It overrides the argument <code>useFullMZ</code>.</p>
</td></tr>
<tr><td><code id="refImageBinaryKmeansMulti_+3A_mztolerance">mzTolerance</code></td>
<td>
<p>numeric (default = Inf). Tolerance in PPM to match the
<code>mzQueryRef</code> values in the m/z vector.</p>
</td></tr>
<tr><td><code id="refImageBinaryKmeansMulti_+3A_usefullmz">useFullMZ</code></td>
<td>
<p>logical (default = TRUE). Whether all the peaks should be
used to calculate the reference image.</p>
</td></tr>
<tr><td><code id="refImageBinaryKmeansMulti_+3A_numclusters">numClusters</code></td>
<td>
<p>numeric (default = 4). Number of clusters.</p>
</td></tr>
<tr><td><code id="refImageBinaryKmeansMulti_+3A_kernelsize">kernelSize</code></td>
<td>
<p>4-D numeric array or numeric (default = 5).
Each element of the 4-D array represents the size of the corners square kernels
used to determine the off-tissue clusters. The element order is clockwise:
top-left, top-right, bottom-left, bottom-right. If negative, the corresponding
corner is skipped. If only a single value is passed, the same kernel size is
used for the 4 corners.</p>
</td></tr>
<tr><td><code id="refImageBinaryKmeansMulti_+3A_cores">cores</code></td>
<td>
<p>numeric (default = 1). Number of CPU cores for parallel k-means.</p>
</td></tr>
<tr><td><code id="refImageBinaryKmeansMulti_+3A_verbose">verbose</code></td>
<td>
<p>boolean (default = TRUE). Additional output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="#topic+ms.image-class">ms.image-class</a> object with binary intensities.
</p>

<hr>
<h2 id='refImageBinaryOtsu'>Calculate the binary reference image using Otsu's thresholding.</h2><span id='topic+refImageBinaryOtsu'></span>

<h3>Description</h3>

<p>Calculate the binary reference image using Otsu's thresholding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>refImageBinaryOtsu(image)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="refImageBinaryOtsu_+3A_image">image</code></td>
<td>
<p><a href="#topic+ms.image-class">ms.image-class</a> object. See <a href="#topic+msImage">msImage</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="#topic+ms.image-class">ms.image-class</a> object with binary intensities.
#'
</p>

<hr>
<h2 id='refImageBinarySVM'>Calculate the binary reference image using linear SVM trained on manually 
selected pixels.</h2><span id='topic+refImageBinarySVM'></span>

<h3>Description</h3>

<p>Calculate the binary reference image using linear SVM trained on manually 
selected pixels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>refImageBinarySVM(
  dataset,
  mzQueryRef = numeric(),
  mzTolerance = Inf,
  useFullMZ = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="refImageBinarySVM_+3A_dataset">dataset</code></td>
<td>
<p><a href="#topic+msi.dataset-class">msi.dataset-class</a> object. See <a href="#topic+msiDataset">msiDataset</a>.</p>
</td></tr>
<tr><td><code id="refImageBinarySVM_+3A_mzqueryref">mzQueryRef</code></td>
<td>
<p>numeric. Values of m/z used to calculate the reference image.
2 values are interpreted as interval, multiple or single values are searched
in the m/z vector. It overrides the argument <code>useFullMZ</code>.</p>
</td></tr>
<tr><td><code id="refImageBinarySVM_+3A_mztolerance">mzTolerance</code></td>
<td>
<p>numeric (default = Inf). Tolerance in PPM to match the
<code>mzQueryRef</code> values in the m/z vector.</p>
</td></tr>
<tr><td><code id="refImageBinarySVM_+3A_usefullmz">useFullMZ</code></td>
<td>
<p>logical (default = TRUE). Whether all the peaks should be
used to calculate the reference image.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="#topic+ms.image-class">ms.image-class</a> object with binary intensities.
</p>

<hr>
<h2 id='refImageContinuous'><code>refImageContinuous</code> returns the reference image, calculated using the
<code>method</code>.
This image represents the basic measure for the filters in SPUTNIK.</h2><span id='topic+refImageContinuous'></span>

<h3>Description</h3>

<p><code>refImageContinuous</code> returns the reference image, calculated using the
<code>method</code>.
This image represents the basic measure for the filters in SPUTNIK.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>refImageContinuous(
  msiData,
  method = "sum",
  mzQueryRef = numeric(),
  mzTolerance = Inf,
  useFullMZRef = TRUE,
  doSmooth = FALSE,
  smoothSigma = 2,
  alignTo = "detected",
  invertAligned = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="refImageContinuous_+3A_msidata">msiData</code></td>
<td>
<p><a href="#topic+msiDataset">msiDataset</a> object..</p>
</td></tr>
<tr><td><code id="refImageContinuous_+3A_method">method</code></td>
<td>
<p>string (default = &quot;sum&quot;). Method used to calculate the
reference image. Valid values are:
</p>

<ul>
<li><p> &quot;sum&quot;: peak intensities sum
</p>
</li>
<li><p> &quot;mean&quot;: average peak intensities (without zeros)
</p>
</li>
<li><p> &quot;median&quot;: median peak intensities (without zeros)
</p>
</li>
<li><p> &quot;pca&quot;: first principal component scores.
</p>
</li></ul>
</td></tr>
<tr><td><code id="refImageContinuous_+3A_mzqueryref">mzQueryRef</code></td>
<td>
<p>numeric. Mass-to-charge ratios used to calculate the reference image.
Two values are interpreted as interval, multiple or single values are searched
in the m/z vector. It overrides the <code>useFullMZRef</code> argument.</p>
</td></tr>
<tr><td><code id="refImageContinuous_+3A_mztolerance">mzTolerance</code></td>
<td>
<p>numeric (default = Inf). Search window in parts-per-million units
for the <code>mzQueryRef</code>.</p>
</td></tr>
<tr><td><code id="refImageContinuous_+3A_usefullmzref">useFullMZRef</code></td>
<td>
<p>logical (default = <code>TRUE</code>). Whether all peaks should be
used to calculate the reference image. Ignored if <code>mzQueryRef</code> is provided.</p>
</td></tr>
<tr><td><code id="refImageContinuous_+3A_dosmooth">doSmooth</code></td>
<td>
<p>logical (default = FALSE). If <code>TRUE</code>, the reference image is
smoothed using a Gaussian kernel.</p>
</td></tr>
<tr><td><code id="refImageContinuous_+3A_smoothsigma">smoothSigma</code></td>
<td>
<p>numeric (default = 2). Standard deviation of the smoothing 
Gaussian kernel.</p>
</td></tr>
<tr><td><code id="refImageContinuous_+3A_alignto">alignTo</code></td>
<td>
<p>string (default = &quot;detected&quot;). The reference image is aligned
to the image representing:
</p>

<ul>
<li><p> &quot;detected&quot;: number of detected peaks
</p>
</li>
<li><p> &quot;tic&quot;: total-ion-count image
</p>
</li></ul>

<p>The reference image will have a positive Pearson's correlation with the selected image.</p>
</td></tr>
<tr><td><code id="refImageContinuous_+3A_invertaligned">invertAligned</code></td>
<td>
<p>logical (default = FALSE). If <code>TRUE</code>, the reference image
has negative correlation with the selected image in <code>alignTo</code>.</p>
</td></tr>
<tr><td><code id="refImageContinuous_+3A_verbose">verbose</code></td>
<td>
<p>logical (default = TRUE). Additional output text.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function to extract the continuous reference image from a 
<code><a href="#topic+msi.dataset-class">msi.dataset-class</a></code> object.
The continuous reference image represents the spatial location of the sample.
By default, it is aligned with either the image representing the number of detected
peaks, or the total-ion-count in all pixels. It is expected to be higher in the
region occupied by the sample (positive correlation with the mask representing
the real sample pixels). In some cases, the alignment images can have higher
values in the pixels outside of the sample. In these circumstances, the argument
<code>invertAligned</code> should be set to <code>TRUE</code>.
</p>


<h3>Value</h3>

<p>A continuous valued reference image (see <a href="#topic+msImage">msImage</a>).
</p>


<h3>See Also</h3>

<p>msiDataset, msImage
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load package
library("SPUTNIK")

## Mass spectrometry intensity matrix
X &lt;- matrix(rnorm(200), 20, 40)
X[X &lt; 0] &lt;- 0

## Print original dimensions
print(dim(X))

## m/z vector
mzVector &lt;- seq(600, 900, by = (900 - 600) / 39)

## Read the image size
imSize &lt;- c(5, 4)

## Construct the ms.dataset object
msiX &lt;- msiDataset(X, mzVector, imSize[1], imSize[2])

## Calculate the reference and ROI images from the ms.dataset-class object msiX.
## The reference is calculated as the first principal component scores scaled
## in [0, 1]; the binary ROI is calculated applying k-means on the entire dataset.
## Use only m/z values in the range of [700, 900]. The interval extremal values
## are matched within a tolerance of 50 ppm.

refImg &lt;- refImageContinuous(msiX, method = "sum")
roiImg &lt;- refImageBinaryOtsu(refImg)

## Plot the reference and region of interest ROI
## plot(ref.roi$Reference)
## plot(ref.roi$ROI)
</code></pre>

<hr>
<h2 id='removeSmallObjects+2Cms.image-method'>Remove binary ROI objects smaller than user-defined number of pixels</h2><span id='topic+removeSmallObjects+2Cms.image-method'></span><span id='topic+removeSmallObjects'></span>

<h3>Description</h3>

<p>Remove binary ROI objects smaller than user-defined number of pixels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ms.image'
removeSmallObjects(object, threshold = 5, border = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="removeSmallObjects+2B2Cms.image-method_+3A_object">object</code></td>
<td>
<p><a href="#topic+ms.image-class">ms.image-class</a> object. See <a href="#topic+msImage">msImage</a>.</p>
</td></tr>
<tr><td><code id="removeSmallObjects+2B2Cms.image-method_+3A_threshold">threshold</code></td>
<td>
<p>numeric. Smallest number of connected pixels.</p>
</td></tr>
<tr><td><code id="removeSmallObjects+2B2Cms.image-method_+3A_border">border</code></td>
<td>
<p>numeric (default = 3). Size of the empty border to add before
detecting the connected objects. The border is removed at the end of the
process. If 'border = 0', no border is added.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="#topic+ms.image-class">ms.image-class</a> object after filtering.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(SPUTNIK)

fakeBinImage &lt;- matrix(0, 100, 100)
fakeBinImage[sample(prod(dim(fakeBinImage)), 2000)] &lt;- 1

fakeBinMsImage &lt;- msImage(values = fakeBinImage, name = "ROI", scale = FALSE)

# Remove the objects with a number of connected pixels smaller than 5
fakeBinMsImage &lt;- removeSmallObjects(fakeBinMsImage, threshold = 5)
</code></pre>

<hr>
<h2 id='scatter.ratio'>Pixel scatteredness ratio.</h2><span id='topic+scatter.ratio'></span>

<h3>Description</h3>

<p><code>scatter.ratio</code> returns a measure of image scatteredness represented by
the ratio between the number of connected components and the total number of
non-zero pixels. The number of connected components is calculated from the
binarized image using Otsu's method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scatter.ratio(im)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scatter.ratio_+3A_im">im</code></td>
<td>
<p>2-D numeric matrix representing the image pixel intensities.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>calculated scatter ratio.
</p>


<h3>Author(s)</h3>

<p>Paolo Inglese <a href="mailto:p.inglese14@imperial.ac.uk">p.inglese14@imperial.ac.uk</a>
</p>


<h3>References</h3>

<p>Otsu, N. (1979). A threshold selection method from gray-level
histograms. IEEE transactions on systems, man, and cybernetics, 9(1), 62-66.
</p>


<h3>See Also</h3>

<p><a href="#topic+gini.index">gini.index</a> <a href="#topic+spatial.chaos">spatial.chaos</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load package
library("SPUTNIK")

## Image
im &lt;- matrix(rnorm(100), 10, 10)
im[im &lt; 0] &lt;- 0

## Spatial chaos
sc &lt;- spatial.chaos(im, levels = 30, morph = TRUE)
stopifnot(sc &lt;= 1)

## Gini index
gi &lt;- gini.index(im, levels = 16)
stopifnot(gi &gt;= -1 &amp;&amp; gi &lt;= 1)

## Scatter ratio
sr &lt;- scatter.ratio(im)
stopifnot(sr &lt;= 1)
</code></pre>

<hr>
<h2 id='smoothImage+2Cms.image-method'>Apply Gaussian smoothing to an MS image.</h2><span id='topic+smoothImage+2Cms.image-method'></span><span id='topic+smoothImage'></span>

<h3>Description</h3>

<p>Apply Gaussian smoothing to an MS image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ms.image'
smoothImage(object, sigma = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smoothImage+2B2Cms.image-method_+3A_object">object</code></td>
<td>
<p><a href="#topic+ms.image-class">ms.image-class</a> object. See <a href="#topic+msImage">msImage</a>.</p>
</td></tr>
<tr><td><code id="smoothImage+2B2Cms.image-method_+3A_sigma">sigma</code></td>
<td>
<p>numeric (default = 2). Standard deviation of the smoothing
Gaussian kernel.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="#topic+ms.image-class">ms.image-class</a> smoothed msImage.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load package
library("SPUTNIK")

## Create ms.image-class object
msIm &lt;- msImage(values = matrix(rnorm(200), 40, 50), name = "test", scale = TRUE)

## Smooth the image colors
msImSmoothed &lt;- smoothImage(msIm, sigma = 5)
</code></pre>

<hr>
<h2 id='spatial.chaos'>Spatial chaos measure.</h2><span id='topic+spatial.chaos'></span>

<h3>Description</h3>

<p><code>spatial.chaos</code> returns the 'spatial chaos' randomness measure for
imaging data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatial.chaos(im, levels = 30, morph = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spatial.chaos_+3A_im">im</code></td>
<td>
<p>2-D numeric matrix representing the image pixel intensities.</p>
</td></tr>
<tr><td><code id="spatial.chaos_+3A_levels">levels</code></td>
<td>
<p>numeric (default = 30). Number of histogram bins.</p>
</td></tr>
<tr><td><code id="spatial.chaos_+3A_morph">morph</code></td>
<td>
<p>logical (default = <code>TRUE</code>). Whether morphological operations should
be applied to the binary image.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A value between 0 and 1. A value close to 1 represents a high level of
spatial scatteredness, a value close to 0 represents a less level of spatial
scatteredness. Maximum possible value is 1 - 1 / (# histogram bins)
</p>


<h3>Author(s)</h3>

<p>Paolo Inglese <a href="mailto:p.inglese14@imperial.ac.uk">p.inglese14@imperial.ac.uk</a>
</p>


<h3>References</h3>

<p>Palmer, A., Phapale, P., Chernyavsky, I., Lavigne, R., Fay,
D., Tarasov, A., ... &amp; Becker, M. (2017). FDR-controlled metabolite annotation
for high-resolution imaging mass spectrometry. Nature methods, 14(1), 57.
</p>


<h3>See Also</h3>

<p><a href="#topic+gini.index">gini.index</a> <a href="#topic+scatter.ratio">scatter.ratio</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load package
library("SPUTNIK")

## Image
im &lt;- matrix(rnorm(100), 10, 10)
im[im &lt; 0] &lt;- 0

## Spatial chaos
sc &lt;- spatial.chaos(im, levels = 30, morph = TRUE)
stopifnot(sc &lt;= 1)

## Gini index
gi &lt;- gini.index(im, levels = 16)
stopifnot(gi &gt;= -1 &amp;&amp; gi &lt;= 1)

## Scatter ratio
sr &lt;- scatter.ratio(im)
stopifnot(sr &lt;= 1)
</code></pre>

<hr>
<h2 id='splitPeaksFilter'>Test for the presence of split peaks.</h2><span id='topic+splitPeaksFilter'></span>

<h3>Description</h3>

<p><a href="#topic+splitPeaksFilter">splitPeaksFilter</a> returns a list of estimated split peak indices. Each
element of the list contains an array of the original peak indices that can
be merged. The name of the list element is the new m/z value associated with
the merged peaks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitPeaksFilter(
  msiData,
  mzTolerance = 5,
  sharedPixelsRatio = 0,
  sparseness = "scatter.ratio",
  threshold = 0.5,
  returnDetails = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="splitPeaksFilter_+3A_msidata">msiData</code></td>
<td>
<p><a href="#topic+msi.dataset-class">msi.dataset-class</a> object. See <a href="#topic+msiDataset">msiDataset</a>.</p>
</td></tr>
<tr><td><code id="splitPeaksFilter_+3A_mztolerance">mzTolerance</code></td>
<td>
<p>numeric (default = 5). Maximum distance in PPM between the
m/z values of two peaks to consider them for merging. See 'Details' section.</p>
</td></tr>
<tr><td><code id="splitPeaksFilter_+3A_sharedpixelsratio">sharedPixelsRatio</code></td>
<td>
<p>numeric (default = 0). Maximum fraction of common pixels
where the signal of two peaks is different from zero to consider them for
merging. See 'Details' section.</p>
</td></tr>
<tr><td><code id="splitPeaksFilter_+3A_sparseness">sparseness</code></td>
<td>
<p>string (default = <code>"scatter.ratio"</code>). Method used to estimate
the 'scatteredness' of the peak image. See 'Details' section.</p>
</td></tr>
<tr><td><code id="splitPeaksFilter_+3A_threshold">threshold</code></td>
<td>
<p>numeric (default = 0.5). Threshold for scatteredness measure
to consider peaks for merging. At least one of the merging peaks should have
a measure associated with presence of structure.</p>
</td></tr>
<tr><td><code id="splitPeaksFilter_+3A_returndetails">returnDetails</code></td>
<td>
<p>logical (default = <code>TRUE</code>). Add details on merged peaks
in the results.</p>
</td></tr>
<tr><td><code id="splitPeaksFilter_+3A_verbose">verbose</code></td>
<td>
<p>logical (default = <code>TRUE</code>). Additional output text.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><a href="#topic+splitPeaksFilter">splitPeaksFilter</a> determines whether close peaks represent the
same signal. This estimation is based on multiple conditions:
</p>

<ol>
<li><p> peaks m/z values should be closer than <code>mzTolerance</code> PPM
</p>
</li>
<li><p> at least one of the peak images should be structured, accordingly to
the <code>sparseness</code> measure. The <code>threshold</code> determines whether the
pixel images are structured or not. The possible measures are:
</p>

<ul>
<li> <p><code>"scatter.ratio"</code>: ratio between the number of non-zero pixels
and the image size after binarization using Otsu's thresholding. A value close
to 0 is associated with a more structured image, whereas a value close to
1 is associated with a less structured image. A suggested parameter of
<code>threshold = 0.5</code> represents the maximum value for this measure for
a structured image. Minimum possible value is 1 / ( # non-zero pixels ).
</p>
</li>
<li> <p><code>"spatial.chaos"</code>: similar to the scatter ratio taking into
account of the color histogram. A value close to 1 represents a structured
image, whereas a value close to 0 represents a more scattered image.
A suggested parameter of <code>threshold = 0.8</code> represents the minimum value
for this measure for a structured image. Maximum possible value is
1 - 1 / ( # histogram bins ). Here, we use the default number of bins
equal to 30.
</p>
</li>
<li> <p><code>"gini.index"</code>: Gini index measures the image sparsity. A value
close to 1 is associated with a sparse image whereas a value close to 0
is associated with a more uniform image. A suggested value of <code>threshold = 0.9</code>
represents the maximum value of this measure for a structured image.
</p>
</li></ul>

</li>
<li><p> the merged peaks image should be more structured than the single
peak images, accordingly to the selected <code>sparseness</code>.
</p>
</li></ol>



<h3>Value</h3>

<p><code>peak.filter</code> object. See <a href="#topic+applyPeaksFilter">applyPeaksFilter</a>.
</p>


<h3>Author(s)</h3>

<p>Paolo Inglese <a href="mailto:p.inglese14@imperial.ac.uk">p.inglese14@imperial.ac.uk</a>
</p>


<h3>References</h3>

<p>Palmer, A., Phapale, P., Chernyavsky, I., Lavigne, R., Fay, D.,
Tarasov, A., ... &amp; Becker, M. (2017). FDR-controlled metabolite annotation for
high-resolution imaging mass spectrometry. Nature methods, 14(1), 57.
</p>
<p>Hurley, N., &amp; Rickard, S. (2009). Comparing measures of sparsity.
IEEE Transactions on Information Theory, 55(10), 4723-4741.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load package
library("SPUTNIK")

## Mass spectrometry intensity matrix
X &lt;- matrix(rnorm(200), 20, 40)
X[X &lt; 0] &lt;- 0

## Print original dimensions
print(dim(X))

## m/z vector
mzVector &lt;- seq(600, 601, by = (601 - 600) / 39)

## Read the image size
imSize &lt;- c(5, 4)

## Construct the ms.dataset object
msiX &lt;- msiDataset(X, mzVector, imSize[1], imSize[2])

## Determine split peaks
sp.filter &lt;- splitPeaksFilter(
  msiData = msiX, mzTolerance = 50,
  sharedPixelsRatio = 0,
  sparseness = "spatial.chaos", threshold = 0.5
)
</code></pre>

<hr>
<h2 id='SSIM'>Structural similarity index (SSIM).</h2><span id='topic+SSIM'></span>

<h3>Description</h3>

<p><code>ssim</code> returns the value of SSIM between two vectors representing the
color intensities of two images.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SSIM(x, y, numBreaks = 256)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SSIM_+3A_x">x</code></td>
<td>
<p>numeric array. Image 1 color intensity array.</p>
</td></tr>
<tr><td><code id="SSIM_+3A_y">y</code></td>
<td>
<p>numeric array. Image 2 color intensity array.</p>
</td></tr>
<tr><td><code id="SSIM_+3A_numbreaks">numBreaks</code></td>
<td>
<p>numeric. Number of bins for the color histogram.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>SSIM is an image quality measure, given a reference considered as
noise-less image. It can be also used as a perceived similarity measure
between images. The images are converted by default in 8bit.
</p>


<h3>Value</h3>

<p>value of SSIM defined between 0 and 1.
</p>


<h3>Author(s)</h3>

<p>Paolo Inglese <a href="mailto:p.inglese14@imperial.ac.uk">p.inglese14@imperial.ac.uk</a>
</p>


<h3>References</h3>

<p>Wang, Z., Bovik, A. C., Sheikh, H. R., &amp; Simoncelli, E. P. (2004).
Image quality assessment: from error visibility to structural similarity.
IEEE transactions on image processing, 13(4), 600-612.
</p>

<hr>
<h2 id='totalIonCountMSI+2Cmsi.dataset-method'>Generates an msImage representing pixels total-ion-counts. This
image can be used to qualitatively evaluate the spatial heterogeneity of the
sample.</h2><span id='topic+totalIonCountMSI+2Cmsi.dataset-method'></span><span id='topic+totalIonCountMSI'></span>

<h3>Description</h3>

<p>Generates an msImage representing pixels total-ion-counts. This
image can be used to qualitatively evaluate the spatial heterogeneity of the
sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'msi.dataset'
totalIonCountMSI(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="totalIonCountMSI+2B2Cmsi.dataset-method_+3A_object">object</code></td>
<td>
<p><a href="#topic+msi.dataset-class">msi.dataset-class</a> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="#topic+ms.image-class">ms.image-class</a> object representing the total ion counts.
</p>

<hr>
<h2 id='varTransform+2Cmsi.dataset-method'>Variance stabilizing transformation.</h2><span id='topic+varTransform+2Cmsi.dataset-method'></span><span id='topic+varTransform'></span>

<h3>Description</h3>

<p><code>varTransform</code> transforms the MS intensities in order to reduce heteroscedasticity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'msi.dataset'
varTransform(object, method = "log", offsetZero = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="varTransform+2B2Cmsi.dataset-method_+3A_object">object</code></td>
<td>
<p><a href="#topic+msi.dataset-class">msi.dataset-class</a> object. See <a href="#topic+msiDataset">msiDataset</a>.</p>
</td></tr>
<tr><td><code id="varTransform+2B2Cmsi.dataset-method_+3A_method">method</code></td>
<td>
<p>string (default = <code>log</code>). Transformation method.
Valid values are:
</p>

<ul>
<li><p> &quot;log&quot;, &quot;log2&quot;, &quot;log10&quot;: log-transformation defined as <code>log(x + offsetZero)</code>.
</p>
</li>
<li><p> &quot;sqrt&quot;: square-root transformation.
</p>
</li>
<li><p> &quot;clr&quot;: centered log-transformation. To be used when TIC scaling
normalization is applied.
</p>
</li></ul>
</td></tr>
<tr><td><code id="varTransform+2B2Cmsi.dataset-method_+3A_offsetzero">offsetZero</code></td>
<td>
<p>numeric (default = 1). This value is added to all the peak
intensities to take into accounts of the zeros. It must be positive.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="#topic+msi.dataset-class">msi.dataset-class</a> object with transformed peaks intensities.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load package
library("SPUTNIK")

## Create the msi.dataset-class object
sz &lt;- c(40, 40)
x &lt;- matrix(rnorm(sz[1] * sz[2] * 20) * 1000, sz[1] * sz[2], 20)
x[x &lt; 0] &lt;- 0 # MS data is positive
mz &lt;- sort(sample(100, ncol(x)))
msiX &lt;- msiDataset(x, mz, sz[1], sz[2])

## Normalize and log-transform
msiX &lt;- normIntensity(msiX, "median")
msiX &lt;- varTransform(msiX, "log")

## Create the msi.dataset-class object
sz &lt;- c(40, 40)
x &lt;- matrix(rnorm(sz[1] * sz[2] * 20) * 1000, sz[1] * sz[2], 20)
x[x &lt; 0] &lt;- 0 # MS data is positive
mz &lt;- sort(sample(100, ncol(x)))
msiX &lt;- msiDataset(x, mz, sz[1], sz[2])

## Normalize using PQN
msiX &lt;- normIntensity(msiX, "PQN")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
