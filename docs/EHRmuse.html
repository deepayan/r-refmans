<!DOCTYPE html><html lang="en"><head><title>Help for package EHRmuse</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {EHRmuse}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#EHRmuse'><p>IPW and AIPW Methods for Multi-cohort Selection Bias in Non-probability Samples</p></a></li>
<li><a href='#expit'><p>Expit</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multi-Cohort Selection Bias Correction using IPW and AIPW
Methods</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.2.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Comprehensive toolkit for addressing selection 
    bias in binary disease models across diverse non-probability samples, each 
    with unique selection mechanisms. It utilizes Inverse Probability Weighting 
    (IPW) and Augmented Inverse Probability Weighting (AIPW) methods to reduce 
    selection bias effectively in multiple non-probability cohorts by integrating 
    data from either individual-level or summary-level external sources. The 
    package also provides a variety of variance estimation techniques. Please 
    refer to Kundu et al. &lt;<a href="https://doi.org/10.48550%2FarXiv.2412.00228">doi:10.48550/arXiv.2412.00228</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/Ritoban1/EHRmuse">https://github.com/Ritoban1/EHRmuse</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Ritoban1/EHRmuse/issues">https://github.com/Ritoban1/EHRmuse/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr (&ge; 1.0.0), magrittr, MASS, nleqslv (&ge; 3.3.2), xgboost
(&ge; 1.4.1), survey (&ge; 4.1.0), stats, nnet (&ge; 7.3-17),
simplexreg (&ge; 0.1.6)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-28 14:06:19 UTC; mk</td>
</tr>
<tr>
<td>Author:</td>
<td>Ritoban Kundu [aut],
  Michael Kleinsasser [cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Kleinsasser &lt;biostat-cran-manager@umich.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-28 14:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='EHRmuse'>IPW and AIPW Methods for Multi-cohort Selection Bias in Non-probability Samples</h2><span id='topic+EHRmuse'></span>

<h3>Description</h3>

<p>IPW and AIPW Methods for Multi-cohort Selection Bias in Non-probability Samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EHRmuse(
  K,
  Z_names,
  intdata_list,
  N = NULL,
  UW_CS = FALSE,
  IPW = FALSE,
  weights_user = NULL,
  AIPW = FALSE,
  ipw_method = "PL",
  extdata = NULL,
  marginals_list = NULL,
  select_var_list = NULL,
  aux_var_list = NULL,
  Weights_e = NULL,
  aux_model = "XGBoost",
  variance = FALSE,
  type_var = "approx"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EHRmuse_+3A_k">K</code></td>
<td>
<p>Necessary Input. Number of cohorts. Should be a numeric positive integer.</p>
</td></tr>
<tr><td><code id="EHRmuse_+3A_z_names">Z_names</code></td>
<td>
<p>Necessary Input. A character vector containing the names of the Z
variables or disease model covariates.</p>
</td></tr>
<tr><td><code id="EHRmuse_+3A_intdata_list">intdata_list</code></td>
<td>
<p>Necessary Input. A list of size K where each element of
list corresponds to the data for each of the K multiple cohorts including the disease indicator D, the Z variables and the selection variables in the disease model. Each data should be of the form of a data frame. Please include a column named &quot;id&quot; to indicate unique identifiers to the units.</p>
</td></tr>
<tr><td><code id="EHRmuse_+3A_n">N</code></td>
<td>
<p>Target Population Size.</p>
</td></tr>
<tr><td><code id="EHRmuse_+3A_uw_cs">UW_CS</code></td>
<td>
<p>An indicator variable (TRUE or FALSE) for using the unweighted logistic
regression model with cohort-specific intercepts.</p>
</td></tr>
<tr><td><code id="EHRmuse_+3A_ipw">IPW</code></td>
<td>
<p>An indicator variable (TRUE or FALSE) for using the Inverse Probability Weighted Methods (IPW) methods.</p>
</td></tr>
<tr><td><code id="EHRmuse_+3A_weights_user">weights_user</code></td>
<td>
<p>User specified weights. A numeric vector of weights for the
combined data (not duplicated).</p>
</td></tr>
<tr><td><code id="EHRmuse_+3A_aipw">AIPW</code></td>
<td>
<p>An indicator variable (TRUE or FALSE) for using the Joint Augmented
IPW method. If AIPW is TRUE, please also input IPW to be TRUE.</p>
</td></tr>
<tr><td><code id="EHRmuse_+3A_ipw_method">ipw_method</code></td>
<td>
<p>If IPW is TRUE, specify the IPW method to be used. A character
variable. Default is PL (Pseudolikelihood). Other options are Simplex Regression
(SR), Calibration (CL) or User Specified (US).</p>
</td></tr>
<tr><td><code id="EHRmuse_+3A_extdata">extdata</code></td>
<td>
<p>If IPW method is set to PL or SR or AIPW is TRUE, please provide
a data frame containing individual level external data which is a probability
sample like NHANES. The external data should contain all the selection variables
and if AIPW is TRUE, then also all the auxiliary score model variables.  Please
include a column named &quot;id&quot; to indicate unique identifiers to the units.</p>
</td></tr>
<tr><td><code id="EHRmuse_+3A_marginals_list">marginals_list</code></td>
<td>
<p>If IPW method is set to CL, please provide a list of size
K in which each element is a numeric vector containing the marginal sums of the selection variables of each of the K cohorts. Please ensure the first element for each of the K numeric vector should be the population size, N.</p>
</td></tr>
<tr><td><code id="EHRmuse_+3A_select_var_list">select_var_list</code></td>
<td>
<p>If IPW is set to be TRUE, please provide a list of size
K in which each element is a character vector corresponding to the selection
variables' names for each of the K cohorts.</p>
</td></tr>
<tr><td><code id="EHRmuse_+3A_aux_var_list">aux_var_list</code></td>
<td>
<p>If AIPW is set to be TRUE, please provide a list of size K
in which each element is a character vector corresponding to the auxiliary score
model variables' names for each of the K cohorts.</p>
</td></tr>
<tr><td><code id="EHRmuse_+3A_weights_e">Weights_e</code></td>
<td>
<p>If IPW method is set to PL or SR or AIPW is TRUE, please provide
the known selection weights for the external probability sample. The input should
be a numeric vector.</p>
</td></tr>
<tr><td><code id="EHRmuse_+3A_aux_model">aux_model</code></td>
<td>
<p>If AIPW is true, please provide the auxiliary score model.
Default is XGboost.</p>
</td></tr>
<tr><td><code id="EHRmuse_+3A_variance">variance</code></td>
<td>
<p>An indicator variable (TRUE or FALSE) whether variance should
be computed or not, along with the point estimate.</p>
</td></tr>
<tr><td><code id="EHRmuse_+3A_type_var">type_var</code></td>
<td>
<p>If variance is true, indicate the method type to be used for
computing the variance. For the unweighted method, do not provide any type.
For IPW methods, PL and CL, we have two options, asy (asymptotic variance
incorporating the variance from nuisance parameters) and &quot;approx&quot; ignoring the
variance from nuisance parameters. For SR and AIPW, we have only the approx method.
The default for IPW and AIPW methods is approx.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If variance=TRUE, it will return a list of estimate vector and variance vector.
If variance=FALSE, it will return an estimate vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#library(MASS)

K=3 ## Number of Cohorts
set.seed(100)
mean_w_p=0
mean_z_1=0
mean_z_2=0
mean_z_3=0
corr=0.5
var_z_w_p=matrix(c(1,corr,corr,corr,
                   corr,1,corr,corr,
                   corr,corr,1,corr,
                   corr,corr,corr,1),
                 nrow=4,ncol=4)

theta=c(-2,0.35,0.45,0.25) ## Theta_Z vector
N=5e4 ## Population size

### selection models
dw=1
dwz1=c(1,0.8,0.6)
dwz2=c(0.6,0.8,1)
dwz3=rep(1,3)

gamma_ext=c(-0.6,1.2,0.4,-0.2,0.5)
gamma_int_1=c(-1,1.5,0.2,0.8,-0.3)
gamma_int_2=c(-1,1.25,0.4,0.6)
gamma_int_3=c(-3,0.8,0.5)

## Generation of population level data
simu_popu&lt;-function(N,mean_w_p,mean_z_1,mean_z_2,mean_z_3,
                    var_z_w_p,theta,dw){
    cov&lt;- MASS::mvrnorm(n = N, mu = c(mean_w_p,mean_z_1,mean_z_2,mean_z_3), Sigma = var_z_w_p)
    data &lt;- data.frame(Z1 = cov[, 2], Z2 = cov[, 3], Z3=cov[,4])
    W_p=cov[,1]
    # Generate random uniforms
    #set.seed(5678)
    U1 &lt;- runif(N)
    #set.seed(4321)
    # Generate Disease Status
    DISEASE &lt;- expit(theta[1] + theta[2] * data$Z1 + theta[3]*data$Z2 +theta[4]*data$Z3)
    data$D   &lt;- ifelse(DISEASE &gt; U1, 1, 0)
    # Relate W_p and D
    data$W_1 &lt;- W_p + dw* data$D + dwz1[1]*data$Z1 +
        dwz2[1]*data$Z2 + dwz3[1]*data$Z3 +
        rnorm(n=N,0,1)

    data$W_2 &lt;- W_p + dw* data$D + dwz1[2]*data$Z1 +
        dwz2[2]*data$Z2 + dwz3[2]*data$Z3 +
        rnorm(n=N,0,1)

    data$W_3 &lt;- W_p + dw* data$D + dwz1[3]*data$Z1 +
        dwz2[3]*data$Z2 + dwz3[3]*data$Z3 +
        rnorm(n=N,0,1)

    data$id=c(1:N)
    return(data)
}
## Generation of external individual level data
simu_ext&lt;-function(data,gamma_ext){
    U2e &lt;- runif(N)
    # Generate Sampling Status
    SELECT &lt;-0.75*expit(gamma_ext[1] +
                            gamma_ext[2]* data$D +
                            gamma_ext[3] * data$Z1 +
                            gamma_ext[4]* data$Z2 +
                            gamma_ext[5] * data$Z3)
    S_e  &lt;- ifelse(SELECT &gt; U2e, TRUE, FALSE)
    # Observed Data
    data_e &lt;- data[which(S_e==1),]
    data_e$Select_Weights = 0.75*expit(gamma_ext[1] +
                                           gamma_ext[2]* data_e$D +
                                           gamma_ext[3] * data_e$Z1 +
                                           gamma_ext[4]* data_e$Z2 +
                                           gamma_ext[5] * data_e$Z3)
    return(data_e)
}
## Generation of internal data 1
simu_int_1&lt;-function(data,gamma_int_1){
    U2i &lt;- runif(N)
    # Generate Sampling Status
    SELECT &lt;- expit(cbind(1,data$D,data$W_1,data$Z2,data$Z3)
                    %*% gamma_int_1)
    S_i  &lt;- ifelse(SELECT &gt; U2i, TRUE, FALSE)
    # Observed Data
    data_i &lt;- data[which(S_i==1),]
    return(data_i)
}

## Generation of internal data 2
simu_int_2&lt;-function(data,gamma_int_2){
    U2i &lt;- runif(N)
    # Generate Sampling Status
    SELECT &lt;- expit(cbind(1,data$D,data$W_2,data$Z3)
                    %*% gamma_int_2)
    S_i  &lt;- ifelse(SELECT &gt; U2i, TRUE, FALSE)
    # Observed Data
    data_i &lt;- data[which(S_i==1),]
    return(data_i)
}


## Generation of internal data 3
simu_int_3&lt;-function(data,gamma_int_3){
    U2i &lt;- runif(N)
    # Generate Sampling Status
    SELECT &lt;- expit(cbind(1,data$W_3,data$Z2)
                    %*% gamma_int_3)
    S_i  &lt;- ifelse(SELECT &gt; U2i, TRUE, FALSE)
    # Observed Data
    data_i &lt;- data[which(S_i==1),]
    return(data_i)
}

data=simu_popu(N,mean_w_p,mean_z_1,mean_z_2,mean_z_3,
               var_z_w_p,theta,dw)

extdata=simu_ext(data,gamma_ext)


intdata1=simu_int_1(data,gamma_int_1)
intdata2=simu_int_2(data,gamma_int_2)
intdata3=simu_int_3(data,gamma_int_3)

## names of selection variables in each cohort
select_var_list=list(c("D","W_1","Z2","Z3"),c("D","W_2","Z3"),c("W_3","Z2"))

## names of auxiliary variables in each cohort
aux_var_list=list(c("D","W_1","Z2","Z3"),c("D","W_2","Z3"),c("W_3","Z2"))

## list of internal data
intdata_list=list(intdata1,intdata2,intdata3)
## names of Z variables
Z_names=c("Z1","Z2","Z3")

theta ## actual theta_z
res_uw=EHRmuse(K=K,N=N,Z_names=Z_names,
               intdata_list=intdata_list,variance = TRUE)

</code></pre>

<hr>
<h2 id='expit'>Expit</h2><span id='topic+expit'></span>

<h3>Description</h3>

<p>Expit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expit(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expit_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>exp(x)/(1+exp(x))
</p>


<h3>Examples</h3>

<pre><code class='language-R'>expit(1)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
