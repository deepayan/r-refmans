<!DOCTYPE html><html><head><title>Help for package bayesdfa</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bayesdfa}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bayesdfa-package'><p>The 'bayesdfa' package.</p></a></li>
<li><a href='#dfa_cv'><p>Apply cross validation to DFA model</p></a></li>
<li><a href='#dfa_fitted'><p>Get the fitted values from a DFA as a data frame</p></a></li>
<li><a href='#dfa_loadings'><p>Get the loadings from a DFA as a data frame</p></a></li>
<li><a href='#dfa_trends'><p>Get the trends from a DFA as a data frame</p></a></li>
<li><a href='#find_dfa_trends'><p>Find the best number of trends according to LOOIC</p></a></li>
<li><a href='#find_inverted_chains'><p>Find which chains to invert</p></a></li>
<li><a href='#find_regimes'><p>Fit multiple models with differing numbers of regimes to trend data</p></a></li>
<li><a href='#find_swans'><p>Find outlying &quot;black swan&quot; jumps in trends</p></a></li>
<li><a href='#fit_dfa'><p>Fit a Bayesian DFA</p></a></li>
<li><a href='#fit_regimes'><p>Fit models with differing numbers of regimes to trend data</p></a></li>
<li><a href='#hmm_init'><p>Create initial values for the HMM model.</p></a></li>
<li><a href='#invert_chains'><p>Invert chains</p></a></li>
<li><a href='#is_converged'><p>Summarize Rhat convergence statistics across parameters</p></a></li>
<li><a href='#loo.bayesdfa'><p>LOO information criteria</p></a></li>
<li><a href='#plot_fitted'><p>Plot the fitted values from a DFA</p></a></li>
<li><a href='#plot_loadings'><p>Plot the loadings from a DFA</p></a></li>
<li><a href='#plot_regime_model'><p>Plot the state probabilities from <code>find_regimes()</code></p></a></li>
<li><a href='#plot_trends'><p>Plot the trends from a DFA</p></a></li>
<li><a href='#predicted'><p>Calculate predicted value from DFA object</p></a></li>
<li><a href='#rotate_trends'><p>Rotate the trends from a DFA</p></a></li>
<li><a href='#sim_dfa'><p>Simulate from a DFA</p></a></li>
<li><a href='#trend_cor'><p>Estimate the correlation between a DFA trend and some other timeseries</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Dynamic Factor Analysis (DFA) with 'Stan'</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements Bayesian dynamic factor analysis with 'Stan'. Dynamic 
    factor analysis is a dimension reduction tool for multivariate time series.
    'bayesdfa' extends conventional dynamic factor models in several ways. 
    First, extreme events may be estimated in the latent trend by modeling
    process error with a student-t distribution. Second, alternative constraints
    (including proportions are allowed). Third, the estimated
    dynamic factors can be analyzed with hidden Markov models to evaluate
    support for latent regimes.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, ggplot2, loo (&ge; 2.7.0), methods, mgcv (&ge; 1.8.13),
Rcpp (&ge; 0.12.0), reshape2, rstantools (&ge; 2.1.1), rlang, rstan
(&ge; 2.26.0), splines, viridisLite</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>BH (&ge; 1.66.0), Rcpp (&ge; 0.12.0), RcppEigen (&ge; 0.3.3.3.0),
RcppParallel (&ge; 5.0.1), rstan (&ge; 2.26.0), StanHeaders (&ge;
2.26.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, parallel, knitr, rmarkdown</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://fate-ewi.github.io/bayesdfa/">https://fate-ewi.github.io/bayesdfa/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/fate-ewi/bayesdfa/issues">https://github.com/fate-ewi/bayesdfa/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-26 18:47:51 UTC; ericward</td>
</tr>
<tr>
<td>Author:</td>
<td>Eric J. Ward [aut, cre],
  Sean C. Anderson [aut],
  Luis A. Damiano [aut],
  Michael J. Malick [aut],
  Mary E. Hunsicker, [ctb],
  Mike A. Litzow [ctb],
  Mark D. Scheuerell [ctb],
  Elizabeth E. Holmes [ctb],
  Nick Tolimieri [ctb],
  Trustees of Columbia University [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Eric J. Ward &lt;eric.ward@noaa.gov&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-26 20:50:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='bayesdfa-package'>The 'bayesdfa' package.</h2><span id='topic+bayesdfa-package'></span><span id='topic+bayesdfa'></span>

<h3>Description</h3>

<p>A DESCRIPTION OF THE PACKAGE
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Eric J. Ward <a href="mailto:eric.ward@noaa.gov">eric.ward@noaa.gov</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Sean C. Anderson
</p>
</li>
<li><p> Luis A. Damiano
</p>
</li>
<li><p> Michael J. Malick
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Mary E. Hunsicker, [contributor]
</p>
</li>
<li><p> Mike A. Litzow [contributor]
</p>
</li>
<li><p> Mark D. Scheuerell [contributor]
</p>
</li>
<li><p> Elizabeth E. Holmes [contributor]
</p>
</li>
<li><p> Nick  Tolimieri [contributor]
</p>
</li>
<li><p> Trustees of Columbia University [copyright holder]
</p>
</li></ul>



<h3>References</h3>

<p>Stan Development Team (2020). RStan: the R interface to Stan. R package version 2.21.2. https://mc-stan.org
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://fate-ewi.github.io/bayesdfa/">https://fate-ewi.github.io/bayesdfa/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/fate-ewi/bayesdfa/issues">https://github.com/fate-ewi/bayesdfa/issues</a>
</p>
</li></ul>


<hr>
<h2 id='dfa_cv'>Apply cross validation to DFA model</h2><span id='topic+dfa_cv'></span>

<h3>Description</h3>

<p>Apply cross validation to DFA model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dfa_cv(
  stanfit,
  cv_method = c("loocv", "lfocv"),
  fold_ids = NULL,
  n_folds = 10,
  estimation = c("sampling", "optimizing", "vb"),
  iter = 2000,
  chains = 4,
  thin = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dfa_cv_+3A_stanfit">stanfit</code></td>
<td>
<p>A stanfit object, to preserve the model structure from a call to fit_dfa()</p>
</td></tr>
<tr><td><code id="dfa_cv_+3A_cv_method">cv_method</code></td>
<td>
<p>The method used for cross validation. The options are 'loocv', where time is ignored and each data point is
assigned randomly to a fold. The method 'ltocv' is leave time out cross validation, and time slices are iteratively held out
out. Finally the method 'lfocv' implements leave future out cross validation to do one-step ahead predictions.</p>
</td></tr>
<tr><td><code id="dfa_cv_+3A_fold_ids">fold_ids</code></td>
<td>
<p>A vector whose length is the same as the number of total data points. Elements are the fold id of each data point. If not all data points are
used (e.g. the lfocv or ltocv approach might only use 10 time steps) the value can be something other than a numbber,
e.g. NA</p>
</td></tr>
<tr><td><code id="dfa_cv_+3A_n_folds">n_folds</code></td>
<td>
<p>Number of folds, defaults to 10</p>
</td></tr>
<tr><td><code id="dfa_cv_+3A_estimation">estimation</code></td>
<td>
<p>Character string. Should the model be sampled using <code><a href="rstan.html#topic+stanmodel-method-sampling">rstan::sampling()</a></code> (&quot;sampling&quot;,default),
<code><a href="rstan.html#topic+stanmodel-method-optimizing">rstan::optimizing()</a></code> (&quot;optimizing&quot;), variational inference <code><a href="rstan.html#topic+stanmodel-method-vb">rstan::vb()</a></code> (&quot;vb&quot;).</p>
</td></tr>
<tr><td><code id="dfa_cv_+3A_iter">iter</code></td>
<td>
<p>Number of iterations in Stan sampling, defaults to 2000.</p>
</td></tr>
<tr><td><code id="dfa_cv_+3A_chains">chains</code></td>
<td>
<p>Number of chains in Stan sampling, defaults to 4.</p>
</td></tr>
<tr><td><code id="dfa_cv_+3A_thin">thin</code></td>
<td>
<p>Thinning rate in Stan sampling, defaults to 1.</p>
</td></tr>
<tr><td><code id="dfa_cv_+3A_...">...</code></td>
<td>
<p>Any other arguments to pass to <code><a href="rstan.html#topic+stanmodel-method-sampling">rstan::sampling()</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(42)
s &lt;- sim_dfa(num_trends = 1, num_years = 20, num_ts = 3)
obs &lt;- c(s$y_sim[1, ], s$y_sim[2, ], s$y_sim[3, ])
long &lt;- data.frame("obs" = obs, "ts" = sort(rep(1:3, 20)),
"time" = rep(1:20, 3))
m &lt;- fit_dfa(y = long, data_shape = "long", estimation="none")
# random folds
fit_cv &lt;- dfa_cv(m, cv_method = "loocv", n_folds = 5, iter = 50,
chains = 1, estimation="sampling")

# folds can also be passed in
fold_ids &lt;- sample(1:5, size = nrow(long), replace = TRUE)
m &lt;- fit_dfa(y = long, data_shape = "long", estimation="none")
fit_cv &lt;- dfa_cv(m, cv_method = "loocv", n_folds = 5, iter = 50, chains = 1,
fold_ids = fold_ids, estimation="sampling")

# do an example of leave-time-out cross validation where years are dropped
fold_ids &lt;- long$time
m &lt;- fit_dfa(y = long, data_shape = "long", estimation="none")
fit_cv &lt;- dfa_cv(m, cv_method = "loocv", iter = 100, chains = 1,
fold_ids = fold_ids)

# example with covariates and long format data
obs_covar &lt;- expand.grid("time" = 1:20, "timeseries" = 1:3,
"covariate" = 1:2)
obs_covar$value &lt;- rnorm(nrow(obs_covar), 0, 0.1)
obs &lt;- c(s$y_sim[1, ], s$y_sim[2, ], s$y_sim[3, ])
m &lt;- fit_dfa(y = long, obs_covar = obs_covar,
data_shape = "long", estimation="none")
fit_cv &lt;- dfa_cv(m, cv_method = "loocv", n_folds = 5,
iter = 50, chains = 1, estimation="sampling")

## End(Not run)

</code></pre>

<hr>
<h2 id='dfa_fitted'>Get the fitted values from a DFA as a data frame</h2><span id='topic+dfa_fitted'></span>

<h3>Description</h3>

<p>Get the fitted values from a DFA as a data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dfa_fitted(modelfit, conf_level = 0.95, names = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dfa_fitted_+3A_modelfit">modelfit</code></td>
<td>
<p>Output from <code><a href="#topic+fit_dfa">fit_dfa</a></code>.</p>
</td></tr>
<tr><td><code id="dfa_fitted_+3A_conf_level">conf_level</code></td>
<td>
<p>Probability level for CI.</p>
</td></tr>
<tr><td><code id="dfa_fitted_+3A_names">names</code></td>
<td>
<p>Optional vector of names for time series labels. Should be same length as the number of time series.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the following columns: <code>ID</code> is an identifier for each time series, <code>time</code> is the time step, <code>y</code> is the observed values standardized to mean 0 and unit variance, <code>estimate</code> is the mean fitted value, <code>lower</code> is the lower CI, and <code>upper</code> is the upper CI.
</p>


<h3>See Also</h3>

<p>predicted plot_fitted fit_dfa
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
y &lt;- sim_dfa(num_trends = 2, num_years = 20, num_ts = 4)
m &lt;- fit_dfa(y = y$y_sim, num_trends = 2, iter = 50, chains = 1)
fitted &lt;- dfa_fitted(m)

</code></pre>

<hr>
<h2 id='dfa_loadings'>Get the loadings from a DFA as a data frame</h2><span id='topic+dfa_loadings'></span>

<h3>Description</h3>

<p>Get the loadings from a DFA as a data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dfa_loadings(rotated_modelfit, names = NULL, summary = TRUE, conf_level = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dfa_loadings_+3A_rotated_modelfit">rotated_modelfit</code></td>
<td>
<p>Output from <code><a href="#topic+rotate_trends">rotate_trends</a></code>.</p>
</td></tr>
<tr><td><code id="dfa_loadings_+3A_names">names</code></td>
<td>
<p>An optional vector of names for plotting the loadings.</p>
</td></tr>
<tr><td><code id="dfa_loadings_+3A_summary">summary</code></td>
<td>
<p>Logical. Should the full posterior densities be returned? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="dfa_loadings_+3A_conf_level">conf_level</code></td>
<td>
<p>Confidence level for credible intervals. Defaults to 0.95.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the following columns:
<code>name</code> is an identifier for each loading, <code>trend</code> is the trend for the
loading, <code>median</code> is the posterior median loading, <code>lower</code> is the lower CI,
<code>upper</code> is the upper CI, and <code>prob_diff0</code> is the probability the loading is
different than 0. When <code>summary = FALSE</code>, there is no <code>lower</code> or <code>upper</code>
columns and instead there are columns <code>chain</code> and <code>draw</code>.
</p>


<h3>See Also</h3>

<p>plot_loadings fit_dfa rotate_trends
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
s &lt;- sim_dfa(num_trends = 2, num_ts = 4, num_years = 10)
# only 1 chain and 180 iterations used so example runs quickly:
m &lt;- fit_dfa(y = s$y_sim, num_trends = 2, iter = 50, chains = 1)
r &lt;- rotate_trends(m)
loadings &lt;- dfa_loadings(r, summary = TRUE)
loadings &lt;- dfa_loadings(r, summary = FALSE)
</code></pre>

<hr>
<h2 id='dfa_trends'>Get the trends from a DFA as a data frame</h2><span id='topic+dfa_trends'></span>

<h3>Description</h3>

<p>Get the trends from a DFA as a data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dfa_trends(rotated_modelfit, years = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dfa_trends_+3A_rotated_modelfit">rotated_modelfit</code></td>
<td>
<p>Output from <code><a href="#topic+rotate_trends">rotate_trends</a></code>.</p>
</td></tr>
<tr><td><code id="dfa_trends_+3A_years">years</code></td>
<td>
<p>Optional numeric vector of years.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the following columns: <code>time</code> is the time step, <code>trend_number</code> is an identifier for each trend, <code>estimate</code> is the trend mean, <code>lower</code> is the lower CI, and <code>upper</code> is the upper CI.
</p>


<h3>See Also</h3>

<p>plot_trends fit_dfa rotate_trends
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
s &lt;- sim_dfa(num_trends = 1)
m &lt;- fit_dfa(y = s$y_sim, num_trends = 1, iter = 50, chains = 1)
r &lt;- rotate_trends(m)
trends &lt;- dfa_trends(r)
</code></pre>

<hr>
<h2 id='find_dfa_trends'>Find the best number of trends according to LOOIC</h2><span id='topic+find_dfa_trends'></span>

<h3>Description</h3>

<p>Fit a DFA with different number of trends and return the leave one out (LOO)
value as calculated by the <a href="loo.html#topic+loo-package">loo</a> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_dfa_trends(
  y = y,
  kmin = 1,
  kmax = 5,
  iter = 2000,
  thin = 1,
  compare_normal = FALSE,
  convergence_threshold = 1.05,
  variance = c("equal", "unequal"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_dfa_trends_+3A_y">y</code></td>
<td>
<p>A matrix of data to fit. Columns represent time element.</p>
</td></tr>
<tr><td><code id="find_dfa_trends_+3A_kmin">kmin</code></td>
<td>
<p>Minimum number of trends, defaults to 1.</p>
</td></tr>
<tr><td><code id="find_dfa_trends_+3A_kmax">kmax</code></td>
<td>
<p>Maximum number of trends, defaults to 5.</p>
</td></tr>
<tr><td><code id="find_dfa_trends_+3A_iter">iter</code></td>
<td>
<p>Iterations when sampling from each Stan model, defaults to 2000.</p>
</td></tr>
<tr><td><code id="find_dfa_trends_+3A_thin">thin</code></td>
<td>
<p>Thinning rate when sampling from each Stan model, defaults to 1.</p>
</td></tr>
<tr><td><code id="find_dfa_trends_+3A_compare_normal">compare_normal</code></td>
<td>
<p>If <code>TRUE</code>, does model selection comparison of Normal vs.
Student-t errors</p>
</td></tr>
<tr><td><code id="find_dfa_trends_+3A_convergence_threshold">convergence_threshold</code></td>
<td>
<p>The maximum allowed value of Rhat to determine
convergence of parameters</p>
</td></tr>
<tr><td><code id="find_dfa_trends_+3A_variance">variance</code></td>
<td>
<p>Vector of variance arguments for searching over large groups
of models. Can be either or both of (&quot;equal&quot;,&quot;unequal&quot;)</p>
</td></tr>
<tr><td><code id="find_dfa_trends_+3A_...">...</code></td>
<td>
<p>Other arguments to pass to <code>fit_dfa()</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(42)
s &lt;- sim_dfa(num_trends = 2, num_years = 20, num_ts = 3)
# only 1 chain and 180 iterations used so example runs quickly:
m &lt;- find_dfa_trends(
  y = s$y_sim, iter = 50,
  kmin = 1, kmax = 2, chains = 1, compare_normal = FALSE,
  variance = "equal", convergence_threshold = 1.1,
  control = list(adapt_delta = 0.95, max_treedepth = 20)
)
m$summary
m$best_model

</code></pre>

<hr>
<h2 id='find_inverted_chains'>Find which chains to invert</h2><span id='topic+find_inverted_chains'></span>

<h3>Description</h3>

<p>Find which chains to invert by checking the sum of the squared
deviations between the first chain and each other chain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_inverted_chains(model, trend = 1, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_inverted_chains_+3A_model">model</code></td>
<td>
<p>A Stan model, <code>rstanfit</code> object</p>
</td></tr>
<tr><td><code id="find_inverted_chains_+3A_trend">trend</code></td>
<td>
<p>Which trend to check</p>
</td></tr>
<tr><td><code id="find_inverted_chains_+3A_plot">plot</code></td>
<td>
<p>Logical: should a plot of the trend for each chain be made?
Defaults to <code>FALSE</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p>invert_chains
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2)
s &lt;- sim_dfa(num_trends = 2)
set.seed(1)
m &lt;- fit_dfa(y = s$y_sim, num_trends = 1, iter = 30, chains = 2)
# chains were already inverted, but we can redo that, as an example, with:
find_inverted_chains(m$model, plot = TRUE)
</code></pre>

<hr>
<h2 id='find_regimes'>Fit multiple models with differing numbers of regimes to trend data</h2><span id='topic+find_regimes'></span>

<h3>Description</h3>

<p>Fit multiple models with differing numbers of regimes to trend data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_regimes(
  y,
  sds = NULL,
  min_regimes = 1,
  max_regimes = 3,
  iter = 2000,
  thin = 1,
  chains = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_regimes_+3A_y">y</code></td>
<td>
<p>Data, time series or trend from fitted DFA model.</p>
</td></tr>
<tr><td><code id="find_regimes_+3A_sds">sds</code></td>
<td>
<p>Optional time series of standard deviations of estimates. If
passed in, residual variance not estimated.</p>
</td></tr>
<tr><td><code id="find_regimes_+3A_min_regimes">min_regimes</code></td>
<td>
<p>Smallest of regimes to evaluate, defaults to 1.</p>
</td></tr>
<tr><td><code id="find_regimes_+3A_max_regimes">max_regimes</code></td>
<td>
<p>Biggest of regimes to evaluate, defaults to 3.</p>
</td></tr>
<tr><td><code id="find_regimes_+3A_iter">iter</code></td>
<td>
<p>MCMC iterations, defaults to 2000.</p>
</td></tr>
<tr><td><code id="find_regimes_+3A_thin">thin</code></td>
<td>
<p>MCMC thinning rate, defaults to 1.</p>
</td></tr>
<tr><td><code id="find_regimes_+3A_chains">chains</code></td>
<td>
<p>MCMC chains; defaults to 1 (note that running multiple chains
may result in a &quot;label switching&quot; problem where the regimes are identified
with different IDs across chains).</p>
</td></tr>
<tr><td><code id="find_regimes_+3A_...">...</code></td>
<td>
<p>Other parameters to pass to <code><a href="rstan.html#topic+stanmodel-method-sampling">rstan::sampling()</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(Nile)
find_regimes(log(Nile), iter = 50, chains = 1, max_regimes = 2)
</code></pre>

<hr>
<h2 id='find_swans'>Find outlying &quot;black swan&quot; jumps in trends</h2><span id='topic+find_swans'></span>

<h3>Description</h3>

<p>Find outlying &quot;black swan&quot; jumps in trends
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_swans(rotated_modelfit, threshold = 0.01, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_swans_+3A_rotated_modelfit">rotated_modelfit</code></td>
<td>
<p>Output from <code><a href="#topic+rotate_trends">rotate_trends()</a></code>.</p>
</td></tr>
<tr><td><code id="find_swans_+3A_threshold">threshold</code></td>
<td>
<p>A probability threshold below which to flag trend events as
extreme</p>
</td></tr>
<tr><td><code id="find_swans_+3A_plot">plot</code></td>
<td>
<p>Logical: should a plot be made?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints a ggplot2 plot if <code>plot = TRUE</code>; returns a data frame indicating the
probability that any given point in time represents a &quot;black swan&quot; event
invisibly.
</p>


<h3>References</h3>

<p>Anderson, S.C., Branch, T.A., Cooper, A.B., and Dulvy, N.K. 2017.
Black-swan events in animal populations. Proceedings of the National Academy
of Sciences 114(12): 3252–3257. https://doi.org/10.1073/pnas.1611525114
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
s &lt;- sim_dfa(num_trends = 1, num_ts = 3, num_years = 30)
s$y_sim[1, 15] &lt;- s$y_sim[1, 15] - 6
plot(s$y_sim[1, ], type = "o")
abline(v = 15, col = "red")
# only 1 chain and 250 iterations used so example runs quickly:
m &lt;- fit_dfa(y = s$y_sim, num_trends = 1, iter = 50, chains = 1, nu_fixed = 2)
r &lt;- rotate_trends(m)
p &lt;- plot_trends(r) #+ geom_vline(xintercept = 15, colour = "red")
print(p)
# a 1 in 1000 probability if was from a normal distribution:
find_swans(r, plot = TRUE, threshold = 0.001)
</code></pre>

<hr>
<h2 id='fit_dfa'>Fit a Bayesian DFA</h2><span id='topic+fit_dfa'></span>

<h3>Description</h3>

<p>Fit a Bayesian DFA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_dfa(
  y = y,
  num_trends = 1,
  varIndx = NULL,
  scale = c("zscore", "center", "none"),
  iter = 2000,
  chains = 4,
  thin = 1,
  control = list(adapt_delta = 0.99, max_treedepth = 20),
  nu_fixed = 101,
  est_correlation = FALSE,
  estimate_nu = FALSE,
  estimate_trend_ar = FALSE,
  estimate_trend_ma = FALSE,
  estimate_process_sigma = FALSE,
  equal_process_sigma = TRUE,
  estimation = c("sampling", "optimizing", "vb", "none"),
  data_shape = c("wide", "long"),
  obs_covar = NULL,
  pro_covar = NULL,
  offset = NULL,
  z_bound = NULL,
  z_model = c("dfa", "proportion"),
  trend_model = c("rw", "bs", "ps", "gp"),
  n_knots = NULL,
  knot_locs = NULL,
  par_list = NULL,
  family = "gaussian",
  verbose = FALSE,
  inv_var_weights = NULL,
  likelihood_weights = NULL,
  gp_theta_prior = c(3, 1),
  expansion_prior = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_dfa_+3A_y">y</code></td>
<td>
<p>A matrix of data to fit. See <code>data_shape</code> option to specify whether
this is long or wide format data. Wide format data (default) is a matrix with
time across columns and unique time series across rows, and can only contain 1 observation
per time series - time combination. In contrast, long format data is a data frame that includes
observations (&quot;obs&quot;), time (&quot;time&quot;) and time series (&quot;ts&quot;) identifiers &ndash; the benefit of long
format is that multiple observations per time series can be included. Correlation matrix currently
not estimated if data shape is long.</p>
</td></tr>
<tr><td><code id="fit_dfa_+3A_num_trends">num_trends</code></td>
<td>
<p>Number of trends to fit.</p>
</td></tr>
<tr><td><code id="fit_dfa_+3A_varindx">varIndx</code></td>
<td>
<p>Indices indicating which timeseries should have shared
variances.</p>
</td></tr>
<tr><td><code id="fit_dfa_+3A_scale">scale</code></td>
<td>
<p>Character string, used to standardized data. Can be &quot;zscore&quot; to center and
standardize data, &quot;center&quot; to just standardize data, or &quot;none&quot;. Defaults to &quot;zscore&quot;</p>
</td></tr>
<tr><td><code id="fit_dfa_+3A_iter">iter</code></td>
<td>
<p>Number of iterations in Stan sampling, defaults to 2000. Used for both
<code><a href="rstan.html#topic+stanmodel-method-sampling">rstan::sampling()</a></code> and <code><a href="rstan.html#topic+stanmodel-method-vb">rstan::vb()</a></code></p>
</td></tr>
<tr><td><code id="fit_dfa_+3A_chains">chains</code></td>
<td>
<p>Number of chains in Stan sampling, defaults to 4.</p>
</td></tr>
<tr><td><code id="fit_dfa_+3A_thin">thin</code></td>
<td>
<p>Thinning rate in Stan sampling, defaults to 1.</p>
</td></tr>
<tr><td><code id="fit_dfa_+3A_control">control</code></td>
<td>
<p>A list of options to pass to Stan sampling. Defaults to
<code>list(adapt_delta = 0.99, max_treedepth = 20)</code>.</p>
</td></tr>
<tr><td><code id="fit_dfa_+3A_nu_fixed">nu_fixed</code></td>
<td>
<p>Student t degrees of freedom parameter. If specified as
greater than 100, a normal random walk is used instead of a random walk
with a t-distribution. Defaults to <code>101</code>.</p>
</td></tr>
<tr><td><code id="fit_dfa_+3A_est_correlation">est_correlation</code></td>
<td>
<p>Boolean, whether to estimate correlation of
observation error matrix <code>R</code>. Defaults to <code>FALSE</code>. Currently can't be estimated if data are in long format.</p>
</td></tr>
<tr><td><code id="fit_dfa_+3A_estimate_nu">estimate_nu</code></td>
<td>
<p>Logical. Estimate the student t degrees of freedom
parameter? Defaults to <code>FALSE</code>,</p>
</td></tr>
<tr><td><code id="fit_dfa_+3A_estimate_trend_ar">estimate_trend_ar</code></td>
<td>
<p>Logical. Estimate AR(1) parameters on DFA trends?
Defaults to 'FALSE&ldquo;, in which case AR(1) parameters are set to 1</p>
</td></tr>
<tr><td><code id="fit_dfa_+3A_estimate_trend_ma">estimate_trend_ma</code></td>
<td>
<p>Logical. Estimate MA(1) parameters on DFA trends?
Defaults to 'FALSE&ldquo;, in which case MA(1) parameters are set to 0.</p>
</td></tr>
<tr><td><code id="fit_dfa_+3A_estimate_process_sigma">estimate_process_sigma</code></td>
<td>
<p>Logical. Defaults FALSE, whether or not to estimate process error sigma. If not estimated,
sigma is fixed at 1, like conventional DFAs.</p>
</td></tr>
<tr><td><code id="fit_dfa_+3A_equal_process_sigma">equal_process_sigma</code></td>
<td>
<p>Logical. If process sigma is estimated, whether or not to estimate a single shared value across trends (default)
or estimate equal values for each trend</p>
</td></tr>
<tr><td><code id="fit_dfa_+3A_estimation">estimation</code></td>
<td>
<p>Character string. Should the model be sampled using <code><a href="rstan.html#topic+stanmodel-method-sampling">rstan::sampling()</a></code> (&quot;sampling&quot;,default),
<code><a href="rstan.html#topic+stanmodel-method-optimizing">rstan::optimizing()</a></code> (&quot;optimizing&quot;), variational inference <code><a href="rstan.html#topic+stanmodel-method-vb">rstan::vb()</a></code> (&quot;vb&quot;),
or no estimation done (&quot;none&quot;). No estimation may be useful for debugging and simulation.</p>
</td></tr>
<tr><td><code id="fit_dfa_+3A_data_shape">data_shape</code></td>
<td>
<p>If <code>wide</code> (the current default) then the input data should
have rows representing the various timeseries and columns representing the
values through time. This matches the MARSS input data format. If <code>long</code>
then the long format data is a data frame that includes observations (&quot;obs&quot;),
time (&quot;time&quot;) and time series (&quot;ts&quot;) identifiers &ndash; the benefit of long
format is that multiple observations per time series can be included</p>
</td></tr>
<tr><td><code id="fit_dfa_+3A_obs_covar">obs_covar</code></td>
<td>
<p>Optional dataframe of data with 4 named columns (&quot;time&quot;,&quot;timeseries&quot;,&quot;covariate&quot;,&quot;value&quot;), representing: (1) time, (2) the time series
affected, (3) the covariate number for models with more than one covariate affecting each
trend, and (4) the value of the covariate</p>
</td></tr>
<tr><td><code id="fit_dfa_+3A_pro_covar">pro_covar</code></td>
<td>
<p>Optional dataframe of data with 4 named columns (&quot;time&quot;,&quot;trend&quot;,&quot;covariate&quot;,&quot;value&quot;), representing: (1) time, (2) the trend
affected, (3) the covariate number for models with more than one covariate affecting each
trend, and (4) the value of the covariate</p>
</td></tr>
<tr><td><code id="fit_dfa_+3A_offset">offset</code></td>
<td>
<p>a string argument representing the name of the offset variable to be included. The variable name is in
the data frame passed in, e.g. &quot;offset&quot;. This only works when the data shape is &quot;long&quot;. All transformations (such as log transformed effort)
to the offset must be done before passing in the data.</p>
</td></tr>
<tr><td><code id="fit_dfa_+3A_z_bound">z_bound</code></td>
<td>
<p>Optional hard constraints for estimated factor loadings &ndash; really only applies to model with 1 trend. Passed in as a 2-element vector representing the lower and upper bound, e.g. (0, 100) to constrain positive</p>
</td></tr>
<tr><td><code id="fit_dfa_+3A_z_model">z_model</code></td>
<td>
<p>Optional argument allowing for elements of Z to be constrained to be proportions (each time series modeled as a mixture of trends). Arguments can be &quot;dfa&quot; (default) or &quot;proportion&quot;</p>
</td></tr>
<tr><td><code id="fit_dfa_+3A_trend_model">trend_model</code></td>
<td>
<p>Optional argument to change the model of the underlying latent trend. By default this is set to 'rw', where the trend
is modeled as a random walk - as in conentional DFA. Alternative options are 'bs', where B-splines are used to model the trends,
&quot;ps&quot; where P-splines are used to model the trends,
or 'gp', where gaussian predictive processes are used. If models other than 'rw' are used, there are some key points. First, the MA and AR
parameters on these models will be turned off. Second, for B-splines and P-splines, the process_sigma becomes an optional scalar on the spline coefficients,
and is turned off by default. Third, the number of knots can be specified (more knots = more wiggliness, and n_knots &lt; N). For models
with &gt; 2 trends, each trend has their own spline coefficients estimated though the knot locations are assumed shared. If knots aren't specified,
the default is N/3. By default both the B-spline and P-spline models use 3rd degree functions for smoothing, and include an intercept term. The P-spline
model uses a difference penalty of 2.</p>
</td></tr>
<tr><td><code id="fit_dfa_+3A_n_knots">n_knots</code></td>
<td>
<p>The number of knots for the B-spline, P-spline, or Gaussian predictive process models. Optional, defaults to round(N/3)</p>
</td></tr>
<tr><td><code id="fit_dfa_+3A_knot_locs">knot_locs</code></td>
<td>
<p>Locations of knots (optional), defaults to uniform spacing between 1 and N</p>
</td></tr>
<tr><td><code id="fit_dfa_+3A_par_list">par_list</code></td>
<td>
<p>A vector of parameter names of variables to be estimated by Stan. If NULL, this will default to
c(&quot;x&quot;, &quot;Z&quot;, &quot;sigma&quot;, &quot;log_lik&quot;, &quot;psi&quot;,&quot;xstar&quot;) for most models &ndash; though if AR / MA, or Student-t models are used
additional parameters will be monitored. If you want to use diagnostic tools in rstan, including moment_matching,
you will need to pass in a larger list. Setting this argument to &quot;all&quot; will monitor all parameters, enabling the use
of diagnostic functions &ndash; but making the models a lot larger for storage. Finally, this argument may be a custom string
of parameters to monitor, e.g. c(&quot;x&quot;,&quot;sigma&quot;)</p>
</td></tr>
<tr><td><code id="fit_dfa_+3A_family">family</code></td>
<td>
<p>String describing the observation model. Default is &quot;gaussian&quot;,
but included options are &quot;gamma&quot;, &quot;lognormal&quot;, negative binomial (&quot;nbinom2&quot;),
&quot;poisson&quot;, or &quot;binomial&quot;. The binomial family is assumed to have logit link,
gaussian family is assumed to be identity, and the rest are log-link.</p>
</td></tr>
<tr><td><code id="fit_dfa_+3A_verbose">verbose</code></td>
<td>
<p>Whether to print iterations and information from Stan, defaults to FALSE.</p>
</td></tr>
<tr><td><code id="fit_dfa_+3A_inv_var_weights">inv_var_weights</code></td>
<td>
<p>Optional name of inverse variance weights argument in data frame. This is only implemented when data
are in long format. If not entered, defaults to inv_var_weights = 1 for all observations. The implementation of inv_var_weights
relies on inverse variance weightings, so that if you have standard errors associated with each observation,
the inverse variance weights are calculated as inv_var_weights &lt;- 1 / (standard_errors^2) . The observation error sigma
in the likelihood then becomes sigma / sqrt(inv_var_weights)</p>
</td></tr>
<tr><td><code id="fit_dfa_+3A_likelihood_weights">likelihood_weights</code></td>
<td>
<p>Optional name of likelihood weights argument in data frame. These
are used in the same way weights are implemented in packages <code>glmmTMB</code>, <code>brms</code>, <code>sdmTMB</code>, etc.
Weights are used as multipliers on the log-likelihood, with higher weights allowing observations
to contribute more. Currently only implemented with univariate distributions, when data is in long
format</p>
</td></tr>
<tr><td><code id="fit_dfa_+3A_gp_theta_prior">gp_theta_prior</code></td>
<td>
<p>A 2-element vector controlling the prior on the Gaussian process parameter in cov_exp_quad.
This prior is a half-Student t prior, with the first argument of gp_theta_prior being the degrees of freedom (nu),
and the second element being the standard deviation</p>
</td></tr>
<tr><td><code id="fit_dfa_+3A_expansion_prior">expansion_prior</code></td>
<td>
<p>Defaults to FALSE, if TRUE uses the parameter expansion prior of Ghosh &amp; Dunson 2009</p>
</td></tr>
<tr><td><code id="fit_dfa_+3A_...">...</code></td>
<td>
<p>Any other arguments to pass to <code><a href="rstan.html#topic+stanmodel-method-sampling">rstan::sampling()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that there is nothing restricting the loadings and trends from
being inverted (i.e. multiplied by <code>-1</code>) for a given chain. Therefore, if
you fit multiple chains, the package will attempt to determine which chains
need to be inverted using the function <code><a href="#topic+find_inverted_chains">find_inverted_chains()</a></code>.
</p>


<h3>See Also</h3>

<p>plot_loadings plot_trends rotate_trends find_swans
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
s &lt;- sim_dfa(num_trends = 1, num_years = 20, num_ts = 3)
# only 1 chain and 250 iterations used so example runs quickly:
m &lt;- fit_dfa(y = s$y_sim, iter = 50, chains = 1)
## Not run: 
# example of observation error covariates
set.seed(42)
obs_covar &lt;- expand.grid("time" = 1:20, "timeseries" = 1:3, "covariate" = 1)
obs_covar$value &lt;- rnorm(nrow(obs_covar), 0, 0.1)
m &lt;- fit_dfa(y = s$y_sim, iter = 50, chains = 1, obs_covar = obs_covar)

# example of process error covariates
pro_covar &lt;- expand.grid("time" = 1:20, "trend" = 1:2, "covariate" = 1)
pro_covar$value &lt;- rnorm(nrow(pro_covar), 0, 0.1)
m &lt;- fit_dfa(y = s$y_sim, iter = 50, chains = 1, num_trends = 2, pro_covar = pro_covar)

# example of long format data
s &lt;- sim_dfa(num_trends = 1, num_years = 20, num_ts = 3)
obs &lt;- c(s$y_sim[1, ], s$y_sim[2, ], s$y_sim[3, ])
long &lt;- data.frame("obs" = obs, "ts" = sort(rep(1:3, 20)), "time" = rep(1:20, 3))
m &lt;- fit_dfa(y = long, data_shape = "long", iter = 50, chains = 1)

# example of long format data with obs covariates
s &lt;- sim_dfa(num_trends = 1, num_years = 20, num_ts = 3)
obs &lt;- c(s$y_sim[1, ], s$y_sim[2, ], s$y_sim[3, ])
long &lt;- data.frame("obs" = obs, "ts" = sort(rep(1:3, 20)), "time" = rep(1:20, 3))
obs_covar &lt;- expand.grid("time" = 1:20, "timeseries" = 1:3, "covariate" = 1:2)
obs_covar$value &lt;- rnorm(nrow(obs_covar), 0, 0.1)
m &lt;- fit_dfa(y = long, data_shape = "long", iter = 50, chains = 1, obs_covar = obs_covar)

# example of model with Z constrained to be proportions and wide format data
s &lt;- sim_dfa(num_trends = 1, num_years = 20, num_ts = 3)
m &lt;- fit_dfa(y = s$y_sim, z_model = "proportion", iter = 50, chains = 1)

# example of model with Z constrained to be proportions and long format data
s &lt;- sim_dfa(num_trends = 1, num_years = 20, num_ts = 3)
obs &lt;- c(s$y_sim[1, ], s$y_sim[2, ], s$y_sim[3, ])
long &lt;- data.frame("obs" = obs, "ts" = sort(rep(1:3, 20)), "time" = rep(1:20, 3))
m &lt;- fit_dfa(y = long, data_shape = "long", z_model = "proportion", iter = 50, chains = 1)

#' # example of B-spline model with wide format data
s &lt;- sim_dfa(num_trends = 1, num_years = 20, num_ts = 3)
m &lt;- fit_dfa(y = s$y_sim, iter = 50, chains = 1, trend_model = "bs", n_knots = 10)

#' #' # example of P-spline model with wide format data
s &lt;- sim_dfa(num_trends = 1, num_years = 20, num_ts = 3)
m &lt;- fit_dfa(y = s$y_sim, iter = 50, chains = 1, trend_model = "ps", n_knots = 10)

# example of Gaussian process model with wide format data
s &lt;- sim_dfa(num_trends = 1, num_years = 20, num_ts = 3)
m &lt;- fit_dfa(y = s$y_sim, iter = 50, chains = 1, trend_model = "gp", n_knots = 5)

# example of long format data
s &lt;- sim_dfa(num_trends = 1, num_years = 20, num_ts = 3)
obs &lt;- c(s$y_sim[1, ], s$y_sim[2, ], s$y_sim[3, ])
long &lt;- data.frame("obs" = obs, "ts" = sort(rep(1:3, 20)),
"time" = rep(1:20, 3), "offset" = rep(0.1,length(obs)))
m &lt;- fit_dfa(y = long, data_shape = "long", offset = "offset", iter = 50, chains = 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='fit_regimes'>Fit models with differing numbers of regimes to trend data</h2><span id='topic+fit_regimes'></span>

<h3>Description</h3>

<p>Fit models with differing numbers of regimes to trend data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_regimes(
  y,
  sds = NULL,
  n_regimes = 2,
  iter = 2000,
  thin = 1,
  chains = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_regimes_+3A_y">y</code></td>
<td>
<p>Data, time series or trend from fitted DFA model.</p>
</td></tr>
<tr><td><code id="fit_regimes_+3A_sds">sds</code></td>
<td>
<p>Optional time series of standard deviations of estimates.
If passed in, residual variance not estimated. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="fit_regimes_+3A_n_regimes">n_regimes</code></td>
<td>
<p>Number of regimes to evaluate, defaults 2</p>
</td></tr>
<tr><td><code id="fit_regimes_+3A_iter">iter</code></td>
<td>
<p>MCMC iterations, defaults to 2000.</p>
</td></tr>
<tr><td><code id="fit_regimes_+3A_thin">thin</code></td>
<td>
<p>MCMC thinning rate, defaults to 1.</p>
</td></tr>
<tr><td><code id="fit_regimes_+3A_chains">chains</code></td>
<td>
<p>MCMC chains, defaults to 1 (note that running multiple chains
may result in a label switching problem where the regimes are identified
with different IDs across chains).</p>
</td></tr>
<tr><td><code id="fit_regimes_+3A_...">...</code></td>
<td>
<p>Other parameters to pass to <code><a href="rstan.html#topic+stanmodel-method-sampling">rstan::sampling()</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(Nile)
fit_regimes(log(Nile), iter = 50, n_regimes = 1)
</code></pre>

<hr>
<h2 id='hmm_init'>Create initial values for the HMM model.</h2><span id='topic+hmm_init'></span>

<h3>Description</h3>

<p>Create initial values for the HMM model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hmm_init(K, x_t)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hmm_init_+3A_k">K</code></td>
<td>
<p>The number of regimes or clusters to fit. Called by <code><a href="rstan.html#topic+stanmodel-method-sampling">rstan::sampling()</a></code>.</p>
</td></tr>
<tr><td><code id="hmm_init_+3A_x_t">x_t</code></td>
<td>
<p>A matrix of values. Called by <code><a href="rstan.html#topic+stanmodel-method-sampling">rstan::sampling()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of initial values (mu, sigma)
</p>

<hr>
<h2 id='invert_chains'>Invert chains</h2><span id='topic+invert_chains'></span>

<h3>Description</h3>

<p>Invert chains
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invert_chains(model, trends = 1, print = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="invert_chains_+3A_model">model</code></td>
<td>
<p>A Stan model, rstanfit object</p>
</td></tr>
<tr><td><code id="invert_chains_+3A_trends">trends</code></td>
<td>
<p>The number of trends in the DFA, defaults to 1</p>
</td></tr>
<tr><td><code id="invert_chains_+3A_print">print</code></td>
<td>
<p>Logical indicating whether the summary should be printed.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="invert_chains_+3A_...">...</code></td>
<td>
<p>Other arguments to pass to <code><a href="#topic+find_inverted_chains">find_inverted_chains()</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>find_inverted_chains
</p>

<hr>
<h2 id='is_converged'>Summarize Rhat convergence statistics across parameters</h2><span id='topic+is_converged'></span>

<h3>Description</h3>

<p>Pass in <code>rstanfit</code> model object, and a threshold Rhat value for
convergence. Returns boolean.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_converged(fitted_model, threshold = 1.05, parameters = c("sigma", "x", "Z"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_converged_+3A_fitted_model">fitted_model</code></td>
<td>
<p>Samples extracted (with <code>permuted = FALSE</code>) from a Stan
model. E.g. output from <code><a href="#topic+invert_chains">invert_chains()</a></code>.</p>
</td></tr>
<tr><td><code id="is_converged_+3A_threshold">threshold</code></td>
<td>
<p>Threshold for maximum Rhat.</p>
</td></tr>
<tr><td><code id="is_converged_+3A_parameters">parameters</code></td>
<td>
<p>Vector of parameters to be included in convergence determination. Defaults = c(&quot;sigma&quot;,&quot;x&quot;,&quot;Z&quot;). Other elements can be added including &quot;pred&quot;, &quot;log_lik&quot;, or &quot;lp__&quot;</p>
</td></tr>
</table>

<hr>
<h2 id='loo.bayesdfa'>LOO information criteria</h2><span id='topic+loo.bayesdfa'></span><span id='topic+loo'></span>

<h3>Description</h3>

<p>Extract the LOOIC (leave-one-out information criterion) using
<code><a href="loo.html#topic+loo">loo::loo()</a></code>. Note that we've implemented slightly different variants
of loo, based on whether the DFA observation model includes correlation
between time series or not (default is no correlation). Importantly,
these different versions are not directly comparable to evaluate data support
for including correlation or not in a DFA. If time series are not correlated,
the point-wise log-likelihood for each observation is calculated and used
in the loo calculations. However if time series are correlated, then each
time slice is assumed to be a joint observation of
all variables, and the point-wise log-likelihood is calculated as the
joint likelihood of all variables under the multivariate normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bayesdfa'
loo(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loo.bayesdfa_+3A_x">x</code></td>
<td>
<p>Output from <code><a href="#topic+fit_dfa">fit_dfa()</a></code>.</p>
</td></tr>
<tr><td><code id="loo.bayesdfa_+3A_...">...</code></td>
<td>
<p>Arguments for <code><a href="loo.html#topic+relative_eff">loo::relative_eff()</a></code> and <code><a href="loo.html#topic+loo">loo::loo.array()</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
s &lt;- sim_dfa(num_trends = 1, num_years = 20, num_ts = 3)
m &lt;- fit_dfa(y = s$y_sim, iter = 50, chains = 1, num_trends = 1)
loo(m)

</code></pre>

<hr>
<h2 id='plot_fitted'>Plot the fitted values from a DFA</h2><span id='topic+plot_fitted'></span>

<h3>Description</h3>

<p>Plot the fitted values from a DFA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_fitted(
  modelfit,
  conf_level = 0.95,
  names = NULL,
  spaghetti = FALSE,
  time_labels = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_fitted_+3A_modelfit">modelfit</code></td>
<td>
<p>Output from <code><a href="#topic+fit_dfa">fit_dfa</a></code>, a rstanfit object</p>
</td></tr>
<tr><td><code id="plot_fitted_+3A_conf_level">conf_level</code></td>
<td>
<p>Probability level for CI.</p>
</td></tr>
<tr><td><code id="plot_fitted_+3A_names">names</code></td>
<td>
<p>Optional vector of names for plotting labels TODO. Should be same length as the number of time series</p>
</td></tr>
<tr><td><code id="plot_fitted_+3A_spaghetti">spaghetti</code></td>
<td>
<p>Defaults to FALSE, but if TRUE puts all raw time series (grey) and fitted values on a single plot</p>
</td></tr>
<tr><td><code id="plot_fitted_+3A_time_labels">time_labels</code></td>
<td>
<p>Optional vector of time labels for plotting, same length as number of time steps</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>plot_loadings fit_dfa rotate_trends dfa_fitted
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
y &lt;- sim_dfa(num_trends = 2, num_years = 20, num_ts = 4)
m &lt;- fit_dfa(y = y$y_sim, num_trends = 2, iter = 50, chains = 1)
p &lt;- plot_fitted(m)
print(p)

p &lt;- plot_fitted(m, spaghetti = TRUE)
print(p)

</code></pre>

<hr>
<h2 id='plot_loadings'>Plot the loadings from a DFA</h2><span id='topic+plot_loadings'></span>

<h3>Description</h3>

<p>Plot the loadings from a DFA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_loadings(
  rotated_modelfit,
  names = NULL,
  facet = TRUE,
  violin = TRUE,
  conf_level = 0.95,
  threshold = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_loadings_+3A_rotated_modelfit">rotated_modelfit</code></td>
<td>
<p>Output from <code><a href="#topic+rotate_trends">rotate_trends()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_loadings_+3A_names">names</code></td>
<td>
<p>An optional vector of names for plotting the loadings.</p>
</td></tr>
<tr><td><code id="plot_loadings_+3A_facet">facet</code></td>
<td>
<p>Logical. Should there be a separate facet for each trend?
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot_loadings_+3A_violin">violin</code></td>
<td>
<p>Logical. Should the full posterior densities be shown as a
violin plot? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot_loadings_+3A_conf_level">conf_level</code></td>
<td>
<p>Confidence level for credible intervals. Defaults to 0.95.</p>
</td></tr>
<tr><td><code id="plot_loadings_+3A_threshold">threshold</code></td>
<td>
<p>Numeric (0-1). Optional for plots, if included, only plot
loadings who have Pr(&lt;0) or Pr(&gt;0) &gt; threshold. For example <code>threshold = 0.8</code>
would only display estimates where 80% of posterior density was above/below
zero. Defaults to <code>NULL</code> (not used).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>plot_trends fit_dfa rotate_trends
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
s &lt;- sim_dfa(num_trends = 2, num_ts = 4, num_years = 10)
# only 1 chain and 180 iterations used so example runs quickly:
m &lt;- fit_dfa(y = s$y_sim, num_trends = 2, iter = 50, chains = 1)
r &lt;- rotate_trends(m)
plot_loadings(r, violin = FALSE, facet = TRUE)
plot_loadings(r, violin = FALSE, facet = FALSE)
plot_loadings(r, violin = TRUE, facet = FALSE)
plot_loadings(r, violin = TRUE, facet = TRUE)
</code></pre>

<hr>
<h2 id='plot_regime_model'>Plot the state probabilities from <code><a href="#topic+find_regimes">find_regimes()</a></code></h2><span id='topic+plot_regime_model'></span>

<h3>Description</h3>

<p>Plot the state probabilities from <code><a href="#topic+find_regimes">find_regimes()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_regime_model(
  model,
  probs = c(0.05, 0.95),
  type = c("probability", "means"),
  regime_prob_threshold = 0.9,
  plot_prob_indices = NULL,
  flip_regimes = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_regime_model_+3A_model">model</code></td>
<td>
<p>A model returned by <code><a href="#topic+find_regimes">find_regimes()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_regime_model_+3A_probs">probs</code></td>
<td>
<p>A numeric vector of quantiles to plot the credible intervals at.
Defaults to <code>c(0.05, 0.95)</code>.</p>
</td></tr>
<tr><td><code id="plot_regime_model_+3A_type">type</code></td>
<td>
<p>Whether to plot the probabilities (default) or means.</p>
</td></tr>
<tr><td><code id="plot_regime_model_+3A_regime_prob_threshold">regime_prob_threshold</code></td>
<td>
<p>The probability density that must be above 0.5.
Defaults to 0.9 before we classify a regime (only affects <code>"means"</code> plot).</p>
</td></tr>
<tr><td><code id="plot_regime_model_+3A_plot_prob_indices">plot_prob_indices</code></td>
<td>
<p>Optional indices of probability plots to plot.
Defaults to showing all.</p>
</td></tr>
<tr><td><code id="plot_regime_model_+3A_flip_regimes">flip_regimes</code></td>
<td>
<p>Optional whether to flip regimes in plots, defaults to FALSE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the original timeseries data (dots) are shown scaled
between 0 and 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Nile)
m &lt;- fit_regimes(log(Nile), n_regimes = 2, chains = 1, iter = 50)
plot_regime_model(m)
plot_regime_model(m, plot_prob_indices = c(2))
plot_regime_model(m, type = "means")


</code></pre>

<hr>
<h2 id='plot_trends'>Plot the trends from a DFA</h2><span id='topic+plot_trends'></span>

<h3>Description</h3>

<p>Plot the trends from a DFA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_trends(
  rotated_modelfit,
  years = NULL,
  highlight_outliers = FALSE,
  threshold = 0.01
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_trends_+3A_rotated_modelfit">rotated_modelfit</code></td>
<td>
<p>Output from <code><a href="#topic+rotate_trends">rotate_trends</a></code></p>
</td></tr>
<tr><td><code id="plot_trends_+3A_years">years</code></td>
<td>
<p>Optional numeric vector of years for the plot</p>
</td></tr>
<tr><td><code id="plot_trends_+3A_highlight_outliers">highlight_outliers</code></td>
<td>
<p>Logical. Should trend events
that exceed the probability of occurring with a normal distribution as
defined by <code>threshold</code> be highlighted? Defaults to FALSE</p>
</td></tr>
<tr><td><code id="plot_trends_+3A_threshold">threshold</code></td>
<td>
<p>A probability threshold below which to
flag trend events as extreme. Defaults to 0.01</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>dfa_trends plot_loadings fit_dfa rotate_trends
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
s &lt;- sim_dfa(num_trends = 1)
m &lt;- fit_dfa(y = s$y_sim, num_trends = 1, iter = 50, chains = 1)
r &lt;- rotate_trends(m)
p &lt;- plot_trends(r)
print(p)
</code></pre>

<hr>
<h2 id='predicted'>Calculate predicted value from DFA object</h2><span id='topic+predicted'></span>

<h3>Description</h3>

<p>Pass in <code>rstanfit</code> model object. Returns array of predictions, dimensioned
number of MCMC draws x number of MCMC chains x time series length x number of time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predicted(fitted_model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predicted_+3A_fitted_model">fitted_model</code></td>
<td>
<p>Samples extracted (with <code>permuted = FALSE</code>) from a Stan
model. E.g. output from <code><a href="#topic+invert_chains">invert_chains()</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(42)
s &lt;- sim_dfa(num_trends = 1, num_years = 20, num_ts = 3)
# only 1 chain and 1000 iterations used so example runs quickly:
m &lt;- fit_dfa(y = s$y_sim, iter = 2000, chains = 3, num_trends = 1)
pred &lt;- predicted(m)

## End(Not run)
</code></pre>

<hr>
<h2 id='rotate_trends'>Rotate the trends from a DFA</h2><span id='topic+rotate_trends'></span>

<h3>Description</h3>

<p>Rotate the trends from a DFA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotate_trends(fitted_model, conf_level = 0.95, invert = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotate_trends_+3A_fitted_model">fitted_model</code></td>
<td>
<p>Output from <code><a href="#topic+fit_dfa">fit_dfa()</a></code>.</p>
</td></tr>
<tr><td><code id="rotate_trends_+3A_conf_level">conf_level</code></td>
<td>
<p>Probability level for CI.</p>
</td></tr>
<tr><td><code id="rotate_trends_+3A_invert">invert</code></td>
<td>
<p>Whether to invert the trends and loadings for plotting purposes</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
s &lt;- sim_dfa(num_trends = 1, num_years = 20, num_ts = 3)
# only 1 chain and 800 iterations used so example runs quickly:
m &lt;- fit_dfa(y = s$y_sim, iter = 50, chains = 1)
r &lt;- rotate_trends(m)
plot_trends(r)
</code></pre>

<hr>
<h2 id='sim_dfa'>Simulate from a DFA</h2><span id='topic+sim_dfa'></span>

<h3>Description</h3>

<p>Simulate from a DFA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_dfa(
  num_trends = 1,
  num_years = 20,
  num_ts = 4,
  loadings_matrix = matrix(nrow = num_ts, ncol = num_trends, rnorm(num_ts * num_trends,
    0, 1)),
  sigma = rlnorm(1, meanlog = log(0.2), 0.1),
  varIndx = rep(1, num_ts),
  trend_model = c("rw", "bs"),
  spline_weights = matrix(ncol = 6, nrow = num_trends, data = rnorm(6 * num_trends)),
  extreme_value = NULL,
  extreme_loc = NULL,
  nu_fixed = 100,
  user_supplied_deviations = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_dfa_+3A_num_trends">num_trends</code></td>
<td>
<p>The number of trends.</p>
</td></tr>
<tr><td><code id="sim_dfa_+3A_num_years">num_years</code></td>
<td>
<p>The number of years.</p>
</td></tr>
<tr><td><code id="sim_dfa_+3A_num_ts">num_ts</code></td>
<td>
<p>The number of timeseries.</p>
</td></tr>
<tr><td><code id="sim_dfa_+3A_loadings_matrix">loadings_matrix</code></td>
<td>
<p>A loadings matrix. The number of rows should match the
number of timeseries and the number of columns should match the number of
trends. Note that this loadings matrix will be internally manipulated by
setting some elements to 0 and constraining some elements to 1 so that the
model can be fitted. See <code><a href="#topic+fit_dfa">fit_dfa()</a></code>. See the outfit element <code>Z</code> in
the returned list is to see the manipulated loadings matrix. If not
specified, a random matrix <code>~ N(0, 1)</code> is used.</p>
</td></tr>
<tr><td><code id="sim_dfa_+3A_sigma">sigma</code></td>
<td>
<p>A vector of standard deviations on the observation error. Should
be of the same length as the number of trends. If not specified, random
numbers are used <code>rlnorm(1, meanlog = log(0.2), 0.1)</code>.</p>
</td></tr>
<tr><td><code id="sim_dfa_+3A_varindx">varIndx</code></td>
<td>
<p>Indices of unique observation variances. Defaults to <code>c(1, 1, 1, 1)</code>. Unique observation error variances would be specified as <code>c(1, 2, 3, 4)</code> in the case of 4 time series.</p>
</td></tr>
<tr><td><code id="sim_dfa_+3A_trend_model">trend_model</code></td>
<td>
<p>The type of trend model. Random walk (<code>"rw"</code>) or basis
spline (<code>"bs"</code>)</p>
</td></tr>
<tr><td><code id="sim_dfa_+3A_spline_weights">spline_weights</code></td>
<td>
<p>A matrix of basis function weights that is used
if <code>trend_model = "bs"</code>. The number of columns should correspond to
the number of knots and the number of rows should correspond to the
number of trends.</p>
</td></tr>
<tr><td><code id="sim_dfa_+3A_extreme_value">extreme_value</code></td>
<td>
<p>Value added to the random walk in the extreme time step.
Defaults to not included.</p>
</td></tr>
<tr><td><code id="sim_dfa_+3A_extreme_loc">extreme_loc</code></td>
<td>
<p>Location of single extreme event in the process. The same
for all processes, and defaults to <code>round(n_t/2)</code> where <code>n_t</code> is the time
series length</p>
</td></tr>
<tr><td><code id="sim_dfa_+3A_nu_fixed">nu_fixed</code></td>
<td>
<p>Nu is the degrees of freedom parameter for the
t-distribution, defaults to 100, which is effectively normal.</p>
</td></tr>
<tr><td><code id="sim_dfa_+3A_user_supplied_deviations">user_supplied_deviations</code></td>
<td>
<p>An optional matrix of deviations for the trend
random walks. Columns are for trends and rows are for each time step.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements: <code>y_sim</code> is the simulated data,
pred is the true underlying data without observation error added, <code>x</code> is
the underlying trends, <code>Z</code> is the manipulated loadings matrix that is fed
to the model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sim_dfa(num_trends = 2)
names(x)
matplot(t(x$y_sim), type = "l")
matplot(t(x$x), type = "l")

set.seed(42)
x &lt;- sim_dfa(extreme_value = -4, extreme_loc = 10)
matplot(t(x$x), type = "l")
abline(v = 10)
matplot(t(x$pred), type = "l")
abline(v = 10)

set.seed(42)
x &lt;- sim_dfa()
matplot(t(x$x), type = "l")
abline(v = 10)
matplot(t(x$pred), type = "l")
abline(v = 10)
</code></pre>

<hr>
<h2 id='trend_cor'>Estimate the correlation between a DFA trend and some other timeseries</h2><span id='topic+trend_cor'></span>

<h3>Description</h3>

<p>Fully incorporates the uncertainty from the posterior of the DFA trend
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trend_cor(
  rotated_modelfit,
  y,
  trend = 1,
  time_window = seq_len(length(y)),
  trend_samples = 100,
  stan_iter = 300,
  stan_chains = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trend_cor_+3A_rotated_modelfit">rotated_modelfit</code></td>
<td>
<p>Output from <code><a href="#topic+rotate_trends">rotate_trends()</a></code>.</p>
</td></tr>
<tr><td><code id="trend_cor_+3A_y">y</code></td>
<td>
<p>A numeric vector to correlate with the DFA trend. Must be the same
length as the DFA trend.</p>
</td></tr>
<tr><td><code id="trend_cor_+3A_trend">trend</code></td>
<td>
<p>A number corresponding to which trend to use, defaults to 1.</p>
</td></tr>
<tr><td><code id="trend_cor_+3A_time_window">time_window</code></td>
<td>
<p>Indices indicating a time window slice to use in the
correlation. Defaults to using the entire time window. Can be used to walk
through the timeseries and test the cross correlations.</p>
</td></tr>
<tr><td><code id="trend_cor_+3A_trend_samples">trend_samples</code></td>
<td>
<p>The number of samples from the trend posterior to use. A
model will be run for each trend sample so this value shouldn't be too
large. Defaults to 100.</p>
</td></tr>
<tr><td><code id="trend_cor_+3A_stan_iter">stan_iter</code></td>
<td>
<p>The number of samples from the posterior with each Stan
model run, defaults to 300.</p>
</td></tr>
<tr><td><code id="trend_cor_+3A_stan_chains">stan_chains</code></td>
<td>
<p>The number of chains for each Stan model run, defaults to
1.</p>
</td></tr>
<tr><td><code id="trend_cor_+3A_...">...</code></td>
<td>
<p>Other arguments to pass to <code><a href="rstan.html#topic+sampling">sampling</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses a <code>sigma ~ half_t(3, 0, 2)</code> prior on the residual standard
deviation and a <code>uniform(-1, 1)</code> prior on the correlation coefficient.
Fitted as a linear regression of <code>y ~ x</code>, where y represents the <code>y</code>
argument to <code><a href="#topic+trend_cor">trend_cor()</a></code> and <code>x</code> represents the DFA trend, and both <code>y</code>
and <code>x</code> have been scaled by subtracting their means and dividing by their
standard deviations. Samples are drawn from the posterior of the trend and
repeatedly fed through the Stan regression to come up with a combined
posterior of the correlation.
</p>


<h3>Value</h3>

<p>A numeric vector of samples from the correlation coefficient
posterior.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
s &lt;- sim_dfa(num_trends = 1, num_years = 15)
m &lt;- fit_dfa(y = s$y_sim, num_trends = 1, iter = 50, chains = 1)
r &lt;- rotate_trends(m)
n_years &lt;- ncol(r$trends[, 1, ])
fake_dat &lt;- rnorm(n_years, 0, 1)
correlation &lt;- trend_cor(r, fake_dat, trend_samples = 25)
hist(correlation)
correlation &lt;- trend_cor(r,
  y = fake_dat, time_window = 5:15,
  trend_samples = 25
)
hist(correlation)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
