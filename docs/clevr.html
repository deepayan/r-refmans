<!DOCTYPE html><html><head><title>Help for package clevr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {clevr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#clevr-package'><p>clevr: Clustering and Link Prediction Evaluation in R</p></a></li>
<li><a href='#accuracy_pairs'><p>Accuracy of Linked Pairs</p></a></li>
<li><a href='#adj_rand_index'><p>Adjusted Rand Index Between Clusterings</p></a></li>
<li><a href='#balanced_accuracy_pairs'><p>Balanced Accuracy of Linked Pairs</p></a></li>
<li><a href='#canonicalize_pairs'><p>Canonicalize element pairs</p></a></li>
<li><a href='#clusters_to_membership'><p>Transform Clustering Representations</p></a></li>
<li><a href='#completeness'><p>Completeness Between Clusterings</p></a></li>
<li><a href='#contingency_table_clusters'><p>Contingency Table for Clusterings</p></a></li>
<li><a href='#contingency_table_pairs'><p>Binary Contingency Table for Linked Pairs</p></a></li>
<li><a href='#eval_report_clusters'><p>Evaluation Report for Clustering</p></a></li>
<li><a href='#eval_report_pairs'><p>Evaluation Report for Linked Pairs</p></a></li>
<li><a href='#f_measure_pairs'><p>F-measure of Linked Pairs</p></a></li>
<li><a href='#fowlkes_mallows'><p>Fowlkes-Mallows Index Between Clusterings</p></a></li>
<li><a href='#fowlkes_mallows_pairs'><p>Fowlkes-Mallows Index of Linked Pairs</p></a></li>
<li><a href='#homogeneity'><p>Homogeneity Between Clusterings</p></a></li>
<li><a href='#mutual_info'><p>Mutual Information Between Clusterings</p></a></li>
<li><a href='#precision_pairs'><p>Precision of Linked Pairs</p></a></li>
<li><a href='#rand_index'><p>Rand Index Between Clusterings</p></a></li>
<li><a href='#recall_pairs'><p>Recall of Linked Pairs</p></a></li>
<li><a href='#specificity_pairs'><p>Specificity of Linked Pairs</p></a></li>
<li><a href='#v_measure'><p>V-measure Between Clusterings</p></a></li>
<li><a href='#variation_info'><p>Variation of Information Between Clusterings</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Clustering and Link Prediction Evaluation in R</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-16</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Neil Marchant &lt;ngmarchant@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for evaluating link prediction and clustering algorithms 
    with respect to ground truth. Includes efficient implementations of 
    common performance measures such as pairwise precision/recall, 
    cluster homogeneity/completeness, variation of information, 
    Rand index etc.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.5), stats, Matrix</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, BH (&ge; 1.69.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/cleanzr/clevr">https://github.com/cleanzr/clevr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/cleanzr/clevr/issues">https://github.com/cleanzr/clevr/issues</a></td>
</tr>
<tr>
<td>Collate:</td>
<td>'RcppExports.R' 'clevr.R' 'measures_clusterings.R'
'transformations.R' 'measures_pairs.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-16 08:49:55 UTC; nmarchant</td>
</tr>
<tr>
<td>Author:</td>
<td>Neil Marchant [aut, cre],
  Rebecca Steorts [aut],
  Olivier Binette [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-16 09:10:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='clevr-package'>clevr: Clustering and Link Prediction Evaluation in R</h2><span id='topic+clevr'></span><span id='topic+clevr-package'></span>

<h3>Description</h3>

<p>Tools for evaluating link prediction and clustering algorithms with respect to ground truth. Includes efficient implementations of common performance measures such as pairwise precision/recall, cluster homogeneity/completeness, variation of information, Rand index etc.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Neil Marchant <a href="mailto:ngmarchant@gmail.com">ngmarchant@gmail.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Rebecca Steorts <a href="mailto:beka@stat.duke.edu">beka@stat.duke.edu</a>
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/cleanzr/clevr">https://github.com/cleanzr/clevr</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/cleanzr/clevr/issues">https://github.com/cleanzr/clevr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='accuracy_pairs'>Accuracy of Linked Pairs</h2><span id='topic+accuracy_pairs'></span>

<h3>Description</h3>

<p>Computes the accuracy of a set of <em>predicted</em> coreferent
(linked) pairs given a set of <em>ground truth</em> coreferent pairs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>accuracy_pairs(true_pairs, pred_pairs, num_pairs, ordered = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="accuracy_pairs_+3A_true_pairs">true_pairs</code></td>
<td>
<p>set of true coreferent pairs stored in a matrix or
data.frame, where rows index pairs and columns index the ids of the
constituents. Any pairs not included are assumed to be <em>non-coreferent</em>.
Duplicate pairs (including equivalent pairs with reversed ids) are
automatically removed.</p>
</td></tr>
<tr><td><code id="accuracy_pairs_+3A_pred_pairs">pred_pairs</code></td>
<td>
<p>set of predicted coreferent pairs, following the same
specification as <code>true_pairs</code>.</p>
</td></tr>
<tr><td><code id="accuracy_pairs_+3A_num_pairs">num_pairs</code></td>
<td>
<p>the total number of coreferent and non-coreferent pairs,
excluding equivalent pairs with reversed ids.</p>
</td></tr>
<tr><td><code id="accuracy_pairs_+3A_ordered">ordered</code></td>
<td>
<p>whether to treat the element pairs as ordered&mdash;i.e. whether
pair <code class="reqn">(x, y)</code> is distinct from pair <code class="reqn">(y, x)</code> for <code class="reqn">x \neq y</code>.
Defaults to FALSE, which is appropriate for clustering, undirected link
prediction, record linkage etc.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The accuracy is defined as:
</p>
<p style="text-align: center;"><code class="reqn">\frac{|T \cap P| + |T' \cap P'|}{N}</code>
</p>

<p>where:
</p>

<ul>
<li> <p><code class="reqn">T</code> is the set of true coreferent pairs,
</p>
</li>
<li> <p><code class="reqn">P</code> is the set of predicted coreferent pairs,
</p>
</li>
<li> <p><code class="reqn">T'</code> is the set of true non-coreferent pairs,
</p>
</li>
<li> <p><code class="reqn">P'</code> is the set of predicted non-coreferent pairs, and
</p>
</li>
<li> <p><code class="reqn">N</code> is the total number of coreferent and non-coreferent pairs.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>true_pairs &lt;- rbind(c(1,2), c(2,3), c(1,3)) # ground truth is 3-clique
pred_pairs &lt;- rbind(c(1,2), c(2,3))         # prediction misses one edge
num_pairs &lt;- 3                              # assuming 3 elements
accuracy_pairs(true_pairs, pred_pairs, num_pairs)

</code></pre>

<hr>
<h2 id='adj_rand_index'>Adjusted Rand Index Between Clusterings</h2><span id='topic+adj_rand_index'></span>

<h3>Description</h3>

<p>Computes the adjusted Rand index (ARI) between two clusterings,
such as a predicted and ground truth clustering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adj_rand_index(true, pred)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adj_rand_index_+3A_true">true</code></td>
<td>
<p>ground truth clustering represented as a membership
vector. Each entry corresponds to an element and the value identifies
the assigned cluster. The specific values of the cluster identifiers
are arbitrary.</p>
</td></tr>
<tr><td><code id="adj_rand_index_+3A_pred">pred</code></td>
<td>
<p>predicted clustering represented as a membership
vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The adjusted Rand index (ARI) is a variant of the Rand index (RI)
which is corrected for chance using the Permutation Model for
clusterings. It is related to the RI as follows:
</p>
<p style="text-align: center;"><code class="reqn">\frac{RI - E(RI)}{1 - E(RI)},</code>
</p>

<p>where <code class="reqn">E(RI)</code> is the expected value of the RI under the Permutation
Model.
Unlike the RI, the ARI takes values in the range -1 to 1. A value
of 1 indicates that the clusterings are identical, while a value of
0 indicates the clusterings are drawn randomly independent of one
another.
</p>


<h3>References</h3>

<p>Hubert, L., Arabie, P. &quot;Comparing partitions.&quot; <em>Journal of Classification</em>
<strong>2</strong>, 193â€“218 (1985). <a href="https://doi.org/10.1007/BF01908075">doi:10.1007/BF01908075</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>true &lt;- c(1,1,1,2,2)  # ground truth clustering
pred &lt;- c(1,1,2,2,2)  # predicted clustering
adj_rand_index(true, pred)

</code></pre>

<hr>
<h2 id='balanced_accuracy_pairs'>Balanced Accuracy of Linked Pairs</h2><span id='topic+balanced_accuracy_pairs'></span>

<h3>Description</h3>

<p>Computes the balanced accuracy of a set of <em>predicted</em>
coreferent (linked) pairs given a set of <em>ground truth</em> coreferent
pairs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>balanced_accuracy_pairs(true_pairs, pred_pairs, num_pairs, ordered = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="balanced_accuracy_pairs_+3A_true_pairs">true_pairs</code></td>
<td>
<p>set of true coreferent pairs stored in a matrix or
data.frame, where rows index pairs and columns index the ids of the
constituents. Any pairs not included are assumed to be <em>non-coreferent</em>.
Duplicate pairs (including equivalent pairs with reversed ids) are
automatically removed.</p>
</td></tr>
<tr><td><code id="balanced_accuracy_pairs_+3A_pred_pairs">pred_pairs</code></td>
<td>
<p>set of predicted coreferent pairs, following the same
specification as <code>true_pairs</code>.</p>
</td></tr>
<tr><td><code id="balanced_accuracy_pairs_+3A_num_pairs">num_pairs</code></td>
<td>
<p>the total number of coreferent and non-coreferent pairs,
excluding equivalent pairs with reversed ids.</p>
</td></tr>
<tr><td><code id="balanced_accuracy_pairs_+3A_ordered">ordered</code></td>
<td>
<p>whether to treat the element pairs as ordered&mdash;i.e. whether
pair <code class="reqn">(x, y)</code> is distinct from pair <code class="reqn">(y, x)</code> for <code class="reqn">x \neq y</code>.
Defaults to FALSE, which is appropriate for clustering, undirected link
prediction, record linkage etc.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The balanced accuracy is defined as:
</p>
<p style="text-align: center;"><code class="reqn">\frac{\frac{|T \cap P|}{|P|} + \frac{|T' \cap P'|}{|P'|}}{2}</code>
</p>

<p>where:
</p>

<ul>
<li> <p><code class="reqn">T</code> is the set of true coreferent pairs,
</p>
</li>
<li> <p><code class="reqn">P</code> is the set of predicted coreferent pairs,
</p>
</li>
<li> <p><code class="reqn">T'</code> is the set of true non-coreferent pairs, and
</p>
</li>
<li> <p><code class="reqn">P'</code> is the set of predicted non-coreferent pairs.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>true_pairs &lt;- rbind(c(1,2), c(2,3), c(1,3)) # ground truth is 3-clique
pred_pairs &lt;- rbind(c(1,2), c(2,3))         # prediction misses one edge
num_pairs &lt;- 3                              # assuming 3 elements
balanced_accuracy_pairs(true_pairs, pred_pairs, num_pairs)

</code></pre>

<hr>
<h2 id='canonicalize_pairs'>Canonicalize element pairs</h2><span id='topic+canonicalize_pairs'></span>

<h3>Description</h3>

<p>Coerce a collection of element pairs into canonical form. Facilitates
testing of equivalence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>canonicalize_pairs(pairs, ordered = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="canonicalize_pairs_+3A_pairs">pairs</code></td>
<td>
<p>a matrix or data.frame of element pairs where rows correspond
to element pairs and columns correspond to element identifiers.</p>
</td></tr>
<tr><td><code id="canonicalize_pairs_+3A_ordered">ordered</code></td>
<td>
<p>whether to treat the element pairs as ordered&mdash;i.e. whether
pair <code class="reqn">(x, y)</code> is distinct from pair <code class="reqn">(y, x)</code> for <code class="reqn">x \neq y</code>.
Defaults to FALSE, which is appropriate for clustering, undirected link
prediction, record linkage etc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the element pairs in canonical form, so that:
</p>

<ul>
<li><p> the first element id precedes the second element id lexicographically
if <code>ordered = FALSE</code>&mdash;i.e. pair (3, 2) becomes pair (2, 3);
</p>
</li>
<li><p> pairs with missing element ids are removed;
</p>
</li>
<li><p> duplicate pairs are removed; and
</p>
</li>
<li><p> the rows in the matrix/data.frame pairs are sorted lexicographically
by the first element id, then by the second element id.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>messy_pairs &lt;- rbind(c(2,1), c(1,2), c(3,1), c(1,2))
clean_pairs &lt;- canonicalize_pairs(messy_pairs)
all(rbind(c(1,2), c(1,3)) == clean_pairs) # duplicates removed and order fixed

</code></pre>

<hr>
<h2 id='clusters_to_membership'>Transform Clustering Representations</h2><span id='topic+clusters_to_membership'></span><span id='topic+membership_to_clusters'></span><span id='topic+clusters_to_pairs'></span><span id='topic+membership_to_pairs'></span><span id='topic+pairs_to_membership'></span><span id='topic+pairs_to_clusters'></span>

<h3>Description</h3>

<p>Transform between different representations of a clustering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clusters_to_membership(clusters, elem_ids = NULL, clust_ids = NULL)

membership_to_clusters(membership, elem_ids = NULL, clust_ids = NULL)

clusters_to_pairs(clusters)

membership_to_pairs(membership, elem_ids = NULL)

pairs_to_membership(pairs, elem_ids)

pairs_to_clusters(pairs, elem_ids)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clusters_to_membership_+3A_clusters">clusters</code></td>
<td>
<p>a representation of a clustering as a list of vectors,
where the i-th vector contains the identifiers of elements assigned to the
i-th cluster. If <code>clust_ids</code> is specified (see below), the i-th cluster
is identified according to the corresponding entry in <code>clust_ids</code>.
Otherwise the i-th cluster is identified according it's name (if
<code>clusters</code> is a named list) or its integer index i.</p>
</td></tr>
<tr><td><code id="clusters_to_membership_+3A_elem_ids">elem_ids</code></td>
<td>
<p>a vector specifying the complete set of identifiers for the
cluster elements in canonical order. Optional for all functions excluding
<code>pairs_to_membership</code> and <code>pairs_to_clusters</code>.</p>
</td></tr>
<tr><td><code id="clusters_to_membership_+3A_clust_ids">clust_ids</code></td>
<td>
<p>a vector specifying the complete set of identifiers for
the clusters in canonical order. Optional for all functions.</p>
</td></tr>
<tr><td><code id="clusters_to_membership_+3A_membership">membership</code></td>
<td>
<p>a representation of a clustering as a membership vector,
where the i-th entry contains the cluster identifier for the i-th element.
If <code>elem_ids</code> is specified (see below), the i-th element is identified
according to the corresponding entry in <code>elem_ids</code>. Otherwise the i-th
element is identified according it's name (if <code>members</code> is a named vector)
or its integer index i.</p>
</td></tr>
<tr><td><code id="clusters_to_membership_+3A_pairs">pairs</code></td>
<td>
<p>a representation of a clustering as a matrix or data.frame
containing all pairs of elements that are co-clustered. The rows index
of the matrix/data.frame index pairs and columns index the identifiers
of the constituent elements. The <code>elem_ids</code> argument (see below) must be
specified in order to recover singleton clusters (containing a single
element).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>clusters_to_membership</code> and <code>pairs_to_membership</code> both return a
membership vector representation of the clustering. The order of the
elements is taken from <code>elem_ids</code> if specified, otherwise the elements are
ordered lexicographically by their identifiers. For
<code>pairs_to_membership</code>, the cluster identifiers cannot be recovered and
are taken to be integers.
</p>
<p><code>membership_to_clusters</code> and <code>pairs_to_clusters</code> both return a
representation of the clustering as a list of vectors. The order of the
clusters is taken from <code>clust_ids</code> if specified, otherwise the clusters
are ordered lexicographically by their identifiers. For
<code>pairs_to_clusters</code>, the cluster identifiers cannot be recovered and
are taken to be integers.
</p>
<p><code>clusters_to_pairs</code> and <code>membership_to_pairs</code> both return a
representation of the clustering as a matrix of element pairs that are
co-clustered. This representation results in loss of information, as
singleton clusters (with one element) and cluster identifiers are not
represented.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## A clustering of three items represented as a membership vector
m &lt;- c("Item1" = 1, "Item2" = 2, "Item3" = 1)

# Transform to list of clusters
membership_to_clusters(m)
# Specify different identifiers for the items
membership_to_clusters(m, elem_ids = c(1, 2, 3))
# Transform to array of pairs that are co-clustered
membership_to_pairs(m)

## A clustering represented as a list of clusters
cl &lt;- list("ClustA" = c(1,3), "ClustB" = c(2))

# Transform to membership vector representation
clusters_to_membership(cl)
# Transform to array of pairs that are co-clustered
clusters_to_pairs(cl)

## A clustering (incompletely) represented as an array of pairs that
## are co-clustered
p &lt;- rbind(c(1,3)) # pairs of elements in the same cluster
ids &lt;- c(1,2,3)    # necessary to specify set of all elements

# Transform to membership vector representation
pairs_to_membership(p, ids)
# Transform to list of clusters
pairs_to_clusters(p, ids)

</code></pre>

<hr>
<h2 id='completeness'>Completeness Between Clusterings</h2><span id='topic+completeness'></span>

<h3>Description</h3>

<p>Computes the completeness between two clusterings, such
as a predicted and ground truth clustering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>completeness(true, pred)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="completeness_+3A_true">true</code></td>
<td>
<p>ground truth clustering represented as a membership
vector. Each entry corresponds to an element and the value identifies
the assigned cluster. The specific values of the cluster identifiers
are arbitrary.</p>
</td></tr>
<tr><td><code id="completeness_+3A_pred">pred</code></td>
<td>
<p>predicted clustering represented as a membership
vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Completeness is an entropy-based measure of the similarity
between two clusterings, say <code class="reqn">t</code> and <code class="reqn">p</code>. The completeness
is high if <em>all</em> members of a given cluster in <code class="reqn">t</code> are assigned
to a single cluster in <code class="reqn">p</code>. The completeness ranges between 0
and 1, where 1 indicates perfect completeness.
</p>


<h3>References</h3>

<p>Rosenberg, A. and Hirschberg, J. &quot;V-measure: A conditional entropy-based external cluster evaluation measure.&quot; <em>Proceedings of the 2007 Joint Conference on Empirical Methods in Natural Language Processing and Computational Natural Language Learning</em> (EMNLP-CoNLL), (2007).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+homogeneity">homogeneity</a></code> evaluates the <em>homogeneity</em>, which is a dual
measure to <em>completeness</em>. <code><a href="#topic+v_measure">v_measure</a></code> evaluates the harmonic mean of
<em>completeness</em> and <em>homogeneity</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>true &lt;- c(1,1,1,2,2)  # ground truth clustering
pred &lt;- c(1,1,2,2,2)  # predicted clustering
completeness(true, pred)

</code></pre>

<hr>
<h2 id='contingency_table_clusters'>Contingency Table for Clusterings</h2><span id='topic+contingency_table_clusters'></span>

<h3>Description</h3>

<p>Compute the contingency table for a <em>predicted</em> clustering
given a <em>ground truth</em> clustering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contingency_table_clusters(true, pred)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contingency_table_clusters_+3A_true">true</code></td>
<td>
<p>ground truth clustering represented as a membership
vector. Each entry corresponds to an element and the value identifies
the assigned cluster. The specific values of the cluster identifiers
are arbitrary.</p>
</td></tr>
<tr><td><code id="contingency_table_clusters_+3A_pred">pred</code></td>
<td>
<p>predicted clustering represented as a membership
vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a table <code class="reqn">C</code> (stored as a sparse matrix) such that
<code class="reqn">C_{ij}</code> counts the number of elements assigned to
cluster <code class="reqn">i</code> in <code>pred</code> and cluster <code class="reqn">j</code> in <code>true</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eval_report_clusters">eval_report_clusters</a></code> computes common evaluation measures derived
from the output of this function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>true &lt;- c(1,1,1,2,2)  # ground truth clustering
pred &lt;- c(1,1,2,2,2)  # predicted clustering
contingency_table_clusters(true, pred)

</code></pre>

<hr>
<h2 id='contingency_table_pairs'>Binary Contingency Table for Linked Pairs</h2><span id='topic+contingency_table_pairs'></span>

<h3>Description</h3>

<p>Compute the binary contingency table for a set of <em>predicted</em>
coreferent (linked) pairs given a set of <em>ground truth</em> coreferent pairs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contingency_table_pairs(
  true_pairs,
  pred_pairs,
  num_pairs = NULL,
  ordered = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contingency_table_pairs_+3A_true_pairs">true_pairs</code></td>
<td>
<p>set of true coreferent pairs stored in a matrix or
data.frame, where rows index pairs and columns index the ids of the
constituents. Any pairs not included are assumed to be <em>non-coreferent</em>.
Duplicate pairs (including equivalent pairs with reversed ids) are
automatically removed.</p>
</td></tr>
<tr><td><code id="contingency_table_pairs_+3A_pred_pairs">pred_pairs</code></td>
<td>
<p>set of predicted coreferent pairs, following the same
specification as <code>true_pairs</code>.</p>
</td></tr>
<tr><td><code id="contingency_table_pairs_+3A_num_pairs">num_pairs</code></td>
<td>
<p>the total number of coreferent and non-coreferent pairs,
excluding equivalent pairs with reversed ids. If not provided,
the true negative cell will be set to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="contingency_table_pairs_+3A_ordered">ordered</code></td>
<td>
<p>whether to treat the element pairs as ordered&mdash;i.e. whether
pair <code class="reqn">(x, y)</code> is distinct from pair <code class="reqn">(y, x)</code> for <code class="reqn">x \neq y</code>.
Defaults to FALSE, which is appropriate for clustering, undirected link
prediction, record linkage etc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code class="reqn">2 \times 2</code> contingency table of the form:
</p>
<pre>
             Truth
   Prediction   TRUE  FALSE
        TRUE      TP     FP
        FALSE     FN     TN
</pre>


<h3>See Also</h3>

<p>The <code><a href="#topic+membership_to_pairs">membership_to_pairs</a></code> and <code><a href="#topic+clusters_to_pairs">clusters_to_pairs</a></code> functions can be
used to transform other clustering representations into lists of pairs,
as required by this function.
The <code><a href="#topic+eval_report_pairs">eval_report_pairs</a></code> function computes common evaluation measures
derived from binary contingency matrices, like the ones output by this
function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Example where pairs/edges are undirected
# ground truth is 3-clique
true_pairs &lt;- rbind(c(1,2), c(2,3), c(1,3))
# prediction misses one edge
pred_pairs &lt;- rbind(c(1,2), c(2,3))
# total number of pairs assuming 3 elements
num_pairs &lt;- 3 * (3 - 1) / 2
eval_report_pairs(true_pairs, pred_pairs, num_pairs)

### Example where pairs/edges are directed
# ground truth is a 3-star
true_pairs &lt;- rbind(c(2,1), c(3,1), c(4,1))
# prediction gets direction of one edge incorrect
pred_pairs &lt;- rbind(c(2,1), c(3,1), c(1,4))
# total number of pairs assuming 4 elements
num_pairs &lt;- 4 * 4
eval_report_pairs(true_pairs, pred_pairs, num_pairs, ordered = TRUE)

</code></pre>

<hr>
<h2 id='eval_report_clusters'>Evaluation Report for Clustering</h2><span id='topic+eval_report_clusters'></span>

<h3>Description</h3>

<p>Compute various evaluation measures for a predicted
clustering using a ground truth clustering as a reference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_report_clusters(true, pred)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval_report_clusters_+3A_true">true</code></td>
<td>
<p>ground truth clustering represented as a membership
vector. Each entry corresponds to an element and the value identifies
the assigned cluster. The specific values of the cluster identifiers
are arbitrary.</p>
</td></tr>
<tr><td><code id="eval_report_clusters_+3A_pred">pred</code></td>
<td>
<p>predicted clustering represented as a membership
vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing the following measures:
</p>

<dl>
<dt>homogeneity</dt><dd><p>see <code><a href="#topic+homogeneity">homogeneity</a></code></p>
</dd>
<dt>completeness</dt><dd><p>see <code><a href="#topic+completeness">completeness</a></code></p>
</dd>
<dt>v_measure</dt><dd><p>see <code><a href="#topic+v_measure">v_measure</a></code></p>
</dd>
<dt>rand_index</dt><dd><p>see <code><a href="#topic+rand_index">rand_index</a></code></p>
</dd>
<dt>adj_rand_index</dt><dd><p>see <code><a href="#topic+adj_rand_index">adj_rand_index</a></code></p>
</dd>
<dt>variation_info</dt><dd><p>see <code><a href="#topic+variation_info">variation_info</a></code></p>
</dd>
<dt>mutual_info</dt><dd><p>see <code><a href="#topic+mutual_info">mutual_info</a></code></p>
</dd>
<dt>fowlkes_mallows</dt><dd><p>see <code><a href="#topic+fowlkes_mallows">fowlkes_mallows</a></code></p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>true &lt;- c(1,1,1,2,2)  # ground truth clustering
pred &lt;- c(1,1,2,2,2)  # predicted clustering
eval_report_clusters(true, pred)

</code></pre>

<hr>
<h2 id='eval_report_pairs'>Evaluation Report for Linked Pairs</h2><span id='topic+eval_report_pairs'></span>

<h3>Description</h3>

<p>Compute various evaluation measures for a set of <em>predicted</em>
coreferent (linked) pairs given a set of <em>ground truth</em> coreferent pairs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_report_pairs(true_pairs, pred_pairs, num_pairs = NULL, ordered = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval_report_pairs_+3A_true_pairs">true_pairs</code></td>
<td>
<p>set of true coreferent pairs stored in a matrix or
data.frame, where rows index pairs and columns index the ids of the
constituents. Any pairs not included are assumed to be <em>non-coreferent</em>.
Duplicate pairs (including equivalent pairs with reversed ids) are
automatically removed.</p>
</td></tr>
<tr><td><code id="eval_report_pairs_+3A_pred_pairs">pred_pairs</code></td>
<td>
<p>set of predicted coreferent pairs, following the same
specification as <code>true_pairs</code>.</p>
</td></tr>
<tr><td><code id="eval_report_pairs_+3A_num_pairs">num_pairs</code></td>
<td>
<p>the total number of coreferent and non-coreferent pairs,
excluding equivalent pairs with reversed ids. If not provided,
measures that depend on the number of true negatives will be returned
as <code>NA</code>.</p>
</td></tr>
<tr><td><code id="eval_report_pairs_+3A_ordered">ordered</code></td>
<td>
<p>whether to treat the element pairs as ordered&mdash;i.e. whether
pair <code class="reqn">(x, y)</code> is distinct from pair <code class="reqn">(y, x)</code> for <code class="reqn">x \neq y</code>.
Defaults to FALSE, which is appropriate for clustering, undirected link
prediction, record linkage etc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing the following measures:
</p>

<dl>
<dt>precision</dt><dd><p>see <code><a href="#topic+precision_pairs">precision_pairs</a></code></p>
</dd>
<dt>recall</dt><dd><p>see <code><a href="#topic+recall_pairs">recall_pairs</a></code></p>
</dd>
<dt>specificity</dt><dd><p>see <code><a href="#topic+specificity_pairs">specificity_pairs</a></code></p>
</dd>
<dt>sensitivity</dt><dd><p>see <code><a href="#topic+sensitivity_pairs">sensitivity_pairs</a></code></p>
</dd>
<dt>f1score</dt><dd><p>see <code><a href="#topic+f_measure_pairs">f_measure_pairs</a></code></p>
</dd>
<dt>accuracy</dt><dd><p>see <code><a href="#topic+accuracy_pairs">accuracy_pairs</a></code></p>
</dd>
<dt>balanced_accuracy</dt><dd><p>see <code><a href="#topic+balanced_accuracy_pairs">balanced_accuracy_pairs</a></code></p>
</dd>
<dt>fowlkes_mallows</dt><dd><p>see <code><a href="#topic+fowlkes_mallows_pairs">fowlkes_mallows_pairs</a></code></p>
</dd>
</dl>



<h3>See Also</h3>

<p>The <code><a href="#topic+contingency_table_pairs">contingency_table_pairs</a></code> function can be used to compute
the contingency table for entity resolution or record linkage problems.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Example where pairs/edges are undirected
# ground truth is 3-clique
true_pairs &lt;- rbind(c(1,2), c(2,3), c(1,3))
# prediction misses one edge
pred_pairs &lt;- rbind(c(1,2), c(2,3))
# total number of pairs assuming 3 elements
num_pairs &lt;- 3 * (3 - 1) / 2
eval_report_pairs(true_pairs, pred_pairs, num_pairs)

### Example where pairs/edges are directed
# ground truth is a 3-star
true_pairs &lt;- rbind(c(2,1), c(3,1), c(4,1))
# prediction gets direction of one edge incorrect
pred_pairs &lt;- rbind(c(2,1), c(3,1), c(1,4))
# total number of pairs assuming 4 elements
num_pairs &lt;- 4 * 4
eval_report_pairs(true_pairs, pred_pairs, num_pairs, ordered = TRUE)

</code></pre>

<hr>
<h2 id='f_measure_pairs'>F-measure of Linked Pairs</h2><span id='topic+f_measure_pairs'></span>

<h3>Description</h3>

<p>Computes the F-measure (a.k.a. F-score) of a set of
<em>predicted</em> coreferent (linked) pairs given a set of <em>ground truth</em>
coreferent pairs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_measure_pairs(true_pairs, pred_pairs, beta = 1, ordered = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="f_measure_pairs_+3A_true_pairs">true_pairs</code></td>
<td>
<p>set of true coreferent pairs stored in a matrix or
data.frame, where rows index pairs and columns index the ids of the
constituents. Any pairs not included are assumed to be <em>non-coreferent</em>.
Duplicate pairs (including equivalent pairs with reversed ids) are
automatically removed.</p>
</td></tr>
<tr><td><code id="f_measure_pairs_+3A_pred_pairs">pred_pairs</code></td>
<td>
<p>set of predicted coreferent pairs, following the same
specification as <code>true_pairs</code>.</p>
</td></tr>
<tr><td><code id="f_measure_pairs_+3A_beta">beta</code></td>
<td>
<p>non-negative weight. A value of 0 assigns no weight to recall
(i.e. the measure reduces to precision), while larger values assign
increasing weight to recall. A value of 1 weights precision and recall
equally.</p>
</td></tr>
<tr><td><code id="f_measure_pairs_+3A_ordered">ordered</code></td>
<td>
<p>whether to treat the element pairs as ordered&mdash;i.e. whether
pair <code class="reqn">(x, y)</code> is distinct from pair <code class="reqn">(y, x)</code> for <code class="reqn">x \neq y</code>.
Defaults to FALSE, which is appropriate for clustering, undirected link
prediction, record linkage etc.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code class="reqn">\beta</code>-weighted F-measure is defined as the weighted
harmonic mean of precision <code class="reqn">P</code> and recall <code class="reqn">R</code>:
</p>
<p style="text-align: center;"><code class="reqn">(1 + \beta^2)\frac{P \cdot R}{\beta^2 \cdot P + R}.</code>
</p>



<h3>References</h3>

<p>Van Rijsbergen, C. J. &quot;Information Retrieval.&quot; (2nd ed.).
Butterworth-Heinemann, USA, (1979).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>true_pairs &lt;- rbind(c(1,2), c(2,3), c(1,3)) # ground truth is 3-clique
pred_pairs &lt;- rbind(c(1,2), c(2,3))         # prediction misses one edge
num_pairs &lt;- 3                              # assuming 3 elements
f_measure_pairs(true_pairs, pred_pairs, num_pairs)

</code></pre>

<hr>
<h2 id='fowlkes_mallows'>Fowlkes-Mallows Index Between Clusterings</h2><span id='topic+fowlkes_mallows'></span>

<h3>Description</h3>

<p>Computes the Fowlkes-Mallows index between two clusterings,
such as a predicted and ground truth clustering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fowlkes_mallows(true, pred)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fowlkes_mallows_+3A_true">true</code></td>
<td>
<p>ground truth clustering represented as a membership
vector. Each entry corresponds to an element and the value identifies
the assigned cluster. The specific values of the cluster identifiers
are arbitrary.</p>
</td></tr>
<tr><td><code id="fowlkes_mallows_+3A_pred">pred</code></td>
<td>
<p>predicted clustering represented as a membership
vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Fowlkes-Mallows index is defined as the geometric mean of
precision and recall, computed with respect to pairs of elements.
</p>


<h3>References</h3>

<p>Fowlkes, E. B. and Mallows, C. L. &quot;A Method for Comparing Two Hierarchical
Clusterings.&quot; <em>Journal of the American Statistical Association</em> <strong>78:383</strong>,
553-569, (1983). <a href="https://doi.org/10.1080/01621459.1983.10478008">doi:10.1080/01621459.1983.10478008</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>true &lt;- c(1,1,1,2,2)  # ground truth clustering
pred &lt;- c(1,1,2,2,2)  # predicted clustering
fowlkes_mallows(true, pred)

</code></pre>

<hr>
<h2 id='fowlkes_mallows_pairs'>Fowlkes-Mallows Index of Linked Pairs</h2><span id='topic+fowlkes_mallows_pairs'></span>

<h3>Description</h3>

<p>Computes the Fowlkes-Mallows index for a set of <em>predicted</em>
coreferent (linked) pairs given a set of <em>ground truth</em> coreferent pairs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fowlkes_mallows_pairs(true_pairs, pred_pairs, ordered = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fowlkes_mallows_pairs_+3A_true_pairs">true_pairs</code></td>
<td>
<p>set of true coreferent pairs stored in a matrix or
data.frame, where rows index pairs and columns index the ids of the
constituents. Any pairs not included are assumed to be <em>non-coreferent</em>.
Duplicate pairs (including equivalent pairs with reversed ids) are
automatically removed.</p>
</td></tr>
<tr><td><code id="fowlkes_mallows_pairs_+3A_pred_pairs">pred_pairs</code></td>
<td>
<p>set of predicted coreferent pairs, following the same
specification as <code>true_pairs</code>.</p>
</td></tr>
<tr><td><code id="fowlkes_mallows_pairs_+3A_ordered">ordered</code></td>
<td>
<p>whether to treat the element pairs as ordered&mdash;i.e. whether
pair <code class="reqn">(x, y)</code> is distinct from pair <code class="reqn">(y, x)</code> for <code class="reqn">x \neq y</code>.
Defaults to FALSE, which is appropriate for clustering, undirected link
prediction, record linkage etc.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Fowlkes-Mallows index is defined as the geometric mean of
precision <code class="reqn">P</code> and recall <code class="reqn">R</code>:
</p>
<p style="text-align: center;"><code class="reqn">\sqrt{P R}.</code>
</p>



<h3>References</h3>

<p>Fowlkes, E. B. and Mallows, C. L. &quot;A Method for Comparing Two Hierarchical
Clusterings.&quot; <em>Journal of the American Statistical Association</em> <strong>78:383</strong>,
553-569, (1983). <a href="https://doi.org/10.1080/01621459.1983.10478008">doi:10.1080/01621459.1983.10478008</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>true_pairs &lt;- rbind(c(1,2), c(2,3), c(1,3)) # ground truth is 3-clique
pred_pairs &lt;- rbind(c(1,2), c(2,3))         # prediction misses one edge
num_pairs &lt;- 3                              # assuming 3 elements
fowlkes_mallows_pairs(true_pairs, pred_pairs, num_pairs)

</code></pre>

<hr>
<h2 id='homogeneity'>Homogeneity Between Clusterings</h2><span id='topic+homogeneity'></span>

<h3>Description</h3>

<p>Computes the homogeneity between two clusterings, such
as a predicted and ground truth clustering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>homogeneity(true, pred)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="homogeneity_+3A_true">true</code></td>
<td>
<p>ground truth clustering represented as a membership
vector. Each entry corresponds to an element and the value identifies
the assigned cluster. The specific values of the cluster identifiers
are arbitrary.</p>
</td></tr>
<tr><td><code id="homogeneity_+3A_pred">pred</code></td>
<td>
<p>predicted clustering represented as a membership
vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Homogeneity is an entropy-based measure of the similarity
between two clusterings, say <code class="reqn">t</code> and <code class="reqn">p</code>. The homogeneity
is high if clustering <code class="reqn">t</code> only assigns members of a cluster to
a single cluster in <code class="reqn">p</code>. The homogeneity ranges between 0
and 1, where 1 indicates a perfect homogeneity.
</p>


<h3>References</h3>

<p>Rosenberg, A. and Hirschberg, J. &quot;V-measure: A conditional entropy-based external cluster evaluation measure.&quot; <em>Proceedings of the 2007 Joint Conference on Empirical Methods in Natural Language Processing and Computational Natural Language Learning</em> (EMNLP-CoNLL), (2007).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+completeness">completeness</a></code> evaluates the <em>completeness</em>, which is a dual
measure to <em>homogeneity</em>. <code><a href="#topic+v_measure">v_measure</a></code> evaluates the harmonic mean of
<em>completeness</em> and <em>homogeneity</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>true &lt;- c(1,1,1,2,2)  # ground truth clustering
pred &lt;- c(1,1,2,2,2)  # predicted clustering
homogeneity(true, pred)

</code></pre>

<hr>
<h2 id='mutual_info'>Mutual Information Between Clusterings</h2><span id='topic+mutual_info'></span>

<h3>Description</h3>

<p>Computes the mutual information between two
clusterings, such as a predicted and ground truth clustering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutual_info(true, pred, base = exp(1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutual_info_+3A_true">true</code></td>
<td>
<p>ground truth clustering represented as a membership
vector. Each entry corresponds to an element and the value identifies
the assigned cluster. The specific values of the cluster identifiers
are arbitrary.</p>
</td></tr>
<tr><td><code id="mutual_info_+3A_pred">pred</code></td>
<td>
<p>predicted clustering represented as a membership
vector.</p>
</td></tr>
<tr><td><code id="mutual_info_+3A_base">base</code></td>
<td>
<p>base of the logarithm. Defaults to <code>exp(1)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Mutual information is an entropy-based measure of the similarity
between two clusterings.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>true &lt;- c(1,1,1,2,2)  # ground truth clustering
pred &lt;- c(1,1,2,2,2)  # predicted clustering
mutual_info(true, pred)

</code></pre>

<hr>
<h2 id='precision_pairs'>Precision of Linked Pairs</h2><span id='topic+precision_pairs'></span>

<h3>Description</h3>

<p>Computes the precision of a set of <em>predicted</em> coreferent
(linked) pairs given a set of <em>ground truth</em> coreferent pairs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>precision_pairs(true_pairs, pred_pairs, ordered = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="precision_pairs_+3A_true_pairs">true_pairs</code></td>
<td>
<p>set of true coreferent pairs stored in a matrix or
data.frame, where rows index pairs and columns index the ids of the
constituents. Any pairs not included are assumed to be <em>non-coreferent</em>.
Duplicate pairs (including equivalent pairs with reversed ids) are
automatically removed.</p>
</td></tr>
<tr><td><code id="precision_pairs_+3A_pred_pairs">pred_pairs</code></td>
<td>
<p>set of predicted coreferent pairs, following the same
specification as <code>true_pairs</code>.</p>
</td></tr>
<tr><td><code id="precision_pairs_+3A_ordered">ordered</code></td>
<td>
<p>whether to treat the element pairs as ordered&mdash;i.e. whether
pair <code class="reqn">(x, y)</code> is distinct from pair <code class="reqn">(y, x)</code> for <code class="reqn">x \neq y</code>.
Defaults to FALSE, which is appropriate for clustering, undirected link
prediction, record linkage etc.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The precision is defined as:
</p>
<p style="text-align: center;"><code class="reqn">\frac{|T \cap P|}{|P|}</code>
</p>

<p>where <code class="reqn">T</code> is the set of true coreferent pairs and <code class="reqn">P</code> is the
set of predicted coreferent pairs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>true_pairs &lt;- rbind(c(1,2), c(2,3), c(1,3)) # ground truth is 3-clique
pred_pairs &lt;- rbind(c(1,2), c(2,3))         # prediction misses one edge
num_pairs &lt;- 3                              # assuming 3 elements
precision_pairs(true_pairs, pred_pairs, num_pairs)

</code></pre>

<hr>
<h2 id='rand_index'>Rand Index Between Clusterings</h2><span id='topic+rand_index'></span>

<h3>Description</h3>

<p>Computes the Rand index (RI) between two clusterings, such
as a predicted and ground truth clustering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rand_index(true, pred)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rand_index_+3A_true">true</code></td>
<td>
<p>ground truth clustering represented as a membership
vector. Each entry corresponds to an element and the value identifies
the assigned cluster. The specific values of the cluster identifiers
are arbitrary.</p>
</td></tr>
<tr><td><code id="rand_index_+3A_pred">pred</code></td>
<td>
<p>predicted clustering represented as a membership
vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Rand index (RI) can be expressed as:
</p>
<p style="text-align: center;"><code class="reqn">\frac{a + b}{{n \choose 2}}.</code>
</p>

<p>where
</p>

<ul>
<li> <p><code class="reqn">n</code> is the number of elements,
</p>
</li>
<li> <p><code class="reqn">a</code> is the number of pairs of elements that appear in the
same cluster in both clusterings, and
</p>
</li>
<li> <p><code class="reqn">b</code> is the number of pairs of elements that appear in distinct
clusters in both clusterings.
</p>
</li></ul>

<p>The RI takes on values between 0 and 1, where 1 denotes exact agreement
between the clusterings and 0 denotes disagreement on all pairs of
elements.
</p>


<h3>References</h3>

<p>Rand, W. M. &quot;Objective Criteria for the Evaluation of Clustering Methods.&quot;
<em>Journal of the American Statistical Association</em> 66(336), 846-850 (1971).
<a href="https://doi.org/10.1080/01621459.1971.10482356">doi:10.1080/01621459.1971.10482356</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>true &lt;- c(1,1,1,2,2)  # ground truth clustering
pred &lt;- c(1,1,2,2,2)  # predicted clustering
rand_index(true, pred)

</code></pre>

<hr>
<h2 id='recall_pairs'>Recall of Linked Pairs</h2><span id='topic+recall_pairs'></span><span id='topic+sensitivity_pairs'></span>

<h3>Description</h3>

<p>Computes the precision of a set of <em>predicted</em> coreferent
(linked) pairs given a set of <em>ground truth</em> coreferent pairs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recall_pairs(true_pairs, pred_pairs, ordered = FALSE)

sensitivity_pairs(true_pairs, pred_pairs, ordered = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recall_pairs_+3A_true_pairs">true_pairs</code></td>
<td>
<p>set of true coreferent pairs stored in a matrix or
data.frame, where rows index pairs and columns index the ids of the
constituents. Any pairs not included are assumed to be <em>non-coreferent</em>.
Duplicate pairs (including equivalent pairs with reversed ids) are
automatically removed.</p>
</td></tr>
<tr><td><code id="recall_pairs_+3A_pred_pairs">pred_pairs</code></td>
<td>
<p>set of predicted coreferent pairs, following the same
specification as <code>true_pairs</code>.</p>
</td></tr>
<tr><td><code id="recall_pairs_+3A_ordered">ordered</code></td>
<td>
<p>whether to treat the element pairs as ordered&mdash;i.e. whether
pair <code class="reqn">(x, y)</code> is distinct from pair <code class="reqn">(y, x)</code> for <code class="reqn">x \neq y</code>.
Defaults to FALSE, which is appropriate for clustering, undirected link
prediction, record linkage etc.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The recall is defined as:
</p>
<p style="text-align: center;"><code class="reqn">\frac{|T \cap P|}{|T|}</code>
</p>

<p>where <code class="reqn">T</code> is the set of true coreferent pairs and <code class="reqn">P</code> is the
set of predicted coreferent pairs.
</p>


<h3>Note</h3>

<p><code>sensitivity_pairs</code> is an alias for <code>recall_pairs</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>true_pairs &lt;- rbind(c(1,2), c(2,3), c(1,3)) # ground truth is 3-clique
pred_pairs &lt;- rbind(c(1,2), c(2,3))         # prediction misses one edge
num_pairs &lt;- 3                              # assuming 3 elements
recall_pairs(true_pairs, pred_pairs, num_pairs)

</code></pre>

<hr>
<h2 id='specificity_pairs'>Specificity of Linked Pairs</h2><span id='topic+specificity_pairs'></span>

<h3>Description</h3>

<p>Computes the specificity of a set of <em>predicted</em> coreferent
(linked) pairs given a set of <em>ground truth</em> coreferent pairs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>specificity_pairs(true_pairs, pred_pairs, num_pairs, ordered = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="specificity_pairs_+3A_true_pairs">true_pairs</code></td>
<td>
<p>set of true coreferent pairs stored in a matrix or
data.frame, where rows index pairs and columns index the ids of the
constituents. Any pairs not included are assumed to be <em>non-coreferent</em>.
Duplicate pairs (including equivalent pairs with reversed ids) are
automatically removed.</p>
</td></tr>
<tr><td><code id="specificity_pairs_+3A_pred_pairs">pred_pairs</code></td>
<td>
<p>set of predicted coreferent pairs, following the same
specification as <code>true_pairs</code>.</p>
</td></tr>
<tr><td><code id="specificity_pairs_+3A_num_pairs">num_pairs</code></td>
<td>
<p>the total number of coreferent and non-coreferent pairs,
excluding equivalent pairs with reversed ids.</p>
</td></tr>
<tr><td><code id="specificity_pairs_+3A_ordered">ordered</code></td>
<td>
<p>whether to treat the element pairs as ordered&mdash;i.e. whether
pair <code class="reqn">(x, y)</code> is distinct from pair <code class="reqn">(y, x)</code> for <code class="reqn">x \neq y</code>.
Defaults to FALSE, which is appropriate for clustering, undirected link
prediction, record linkage etc.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The specificity is defined as:
</p>
<p style="text-align: center;"><code class="reqn">\frac{|P' \cap T'|}{|P'|}</code>
</p>

<p>where <code class="reqn">T'</code> is the set of true non-coreferent pairs, <code class="reqn">P</code> is the
set of predicted non-coreferent pairs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>true_pairs &lt;- rbind(c(1,2), c(2,3), c(1,3)) # ground truth is 3-clique
pred_pairs &lt;- rbind(c(1,2), c(2,3))         # prediction misses one edge
num_pairs &lt;- 3                              # assuming 3 elements
specificity_pairs(true_pairs, pred_pairs, num_pairs)

</code></pre>

<hr>
<h2 id='v_measure'>V-measure Between Clusterings</h2><span id='topic+v_measure'></span>

<h3>Description</h3>

<p>Computes the V-measure between two clusterings, such
as a predicted and ground truth clustering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>v_measure(true, pred, beta = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="v_measure_+3A_true">true</code></td>
<td>
<p>ground truth clustering represented as a membership
vector. Each entry corresponds to an element and the value identifies
the assigned cluster. The specific values of the cluster identifiers
are arbitrary.</p>
</td></tr>
<tr><td><code id="v_measure_+3A_pred">pred</code></td>
<td>
<p>predicted clustering represented as a membership
vector.</p>
</td></tr>
<tr><td><code id="v_measure_+3A_beta">beta</code></td>
<td>
<p>non-negative weight. A value of 0 assigns no weight to
completeness (i.e. the measure reduces to homogeneity), while larger
values assign increasing weight to completeness. A value of 1 weights
completeness and homogeneity equally.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>V-measure is defined as the <code class="reqn">\beta</code>-weighted harmonic
mean of homogeneity <code class="reqn">h</code> and completeness <code class="reqn">c</code>:
</p>
<p style="text-align: center;"><code class="reqn">(1 + \beta)\frac{h \cdot c}{\beta \cdot h + c}.</code>
</p>

<p>The range of V-measure is between 0 and 1, where 1 corresponds to a
perfect match between the clusterings. It is equivalent to the
normalised mutual information, when the aggregation function is the
arithmetic mean.
</p>


<h3>References</h3>

<p>Rosenberg, A. and Hirschberg, J. &quot;V-measure: A conditional entropy-based external cluster evaluation measure.&quot; <em>Proceedings of the 2007 Joint Conference on Empirical Methods in Natural Language Processing and Computational Natural Language Learning</em> (EMNLP-CoNLL), (2007).
</p>
<p>Becker, H. &quot;Identification and characterization of events in social media.&quot;
<em>PhD dissertation</em>, Columbia University, (2011).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+homogeneity">homogeneity</a></code> and <code><a href="#topic+completeness">completeness</a></code> evaluate the component
measures upon which this measure is based.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>true &lt;- c(1,1,1,2,2)  # ground truth clustering
pred &lt;- c(1,1,2,2,2)  # predicted clustering
v_measure(true, pred)

</code></pre>

<hr>
<h2 id='variation_info'>Variation of Information Between Clusterings</h2><span id='topic+variation_info'></span>

<h3>Description</h3>

<p>Computes the variation of information between two
clusterings, such as a predicted and ground truth clustering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>variation_info(true, pred, base = exp(1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="variation_info_+3A_true">true</code></td>
<td>
<p>ground truth clustering represented as a membership
vector. Each entry corresponds to an element and the value identifies
the assigned cluster. The specific values of the cluster identifiers
are arbitrary.</p>
</td></tr>
<tr><td><code id="variation_info_+3A_pred">pred</code></td>
<td>
<p>predicted clustering represented as a membership
vector.</p>
</td></tr>
<tr><td><code id="variation_info_+3A_base">base</code></td>
<td>
<p>base of the logarithm. Defaults to <code>exp(1)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Variation of information is an entropy-based distance metric
on the space of clusterings. It is unnormalized and varies between
<code class="reqn">0</code> and <code class="reqn">\log(N)</code> where <code class="reqn">N</code> is the number of
clustered elements. Larger values of the distance metric correspond
to greater dissimilarity between the clusterings.
</p>


<h3>References</h3>

<p>Arabie, P. and Boorman, S. A. &quot;Multidimensional scaling of measures of
distance between partitions.&quot; <em>Journal of Mathematical Psychology</em> <strong>10:2</strong>,
148-203, (1973). <a href="https://doi.org/10.1016/0022-2496%2873%2990012-6">doi:10.1016/0022-2496(73)90012-6</a>
</p>
<p>MeilÄƒ, M. &quot;Comparing Clusterings by the Variation of Information.&quot; In:
Learning Theory and Kernel Machines, Lecture Notes in Computer Science
<strong>2777</strong>, Springer, Berlin, Heidelberg, (2003).
<a href="https://doi.org/10.1007/978-3-540-45167-9_14">doi:10.1007/978-3-540-45167-9_14</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>true &lt;- c(1,1,1,2,2)  # ground truth clustering
pred &lt;- c(1,1,2,2,2)  # predicted clustering
variation_info(true, pred)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
