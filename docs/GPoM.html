<!DOCTYPE html><html><head><title>Help for package GPoM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {GPoM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#GPoM-package'><p>GPoM package: Generalized Polynomial Modelling</p></a></li>
<li><a href='#allMod_nVar3_dMax2+20data+20set'><p>Numerical description of a list of eighteen three-dimensional chaotic</p>
sytems (see vignette <code>7_Retro-Modelling</code>)</a></li>
<li><a href='#allToTest'><p>A list providing the description of six models tested by</p>
the function <code>autoGPoMoTest</code>.</a></li>
<li><a href='#autoGPoMoSearch'><p>Automatic search of polynomial Equations</p></a></li>
<li><a href='#autoGPoMoTest'><p>Tests the numerical integrability of models and</p>
classify their dynamical regime</a></li>
<li><a href='#bDrvFilt'><p>Builds the derivative filter</p></a></li>
<li><a href='#cano2M'><p>cano2M : Converts a model in canonical form into a matrix form</p></a></li>
<li><a href='#combiEq'><p>combiEq : Combine Equations from different sources</p></a></li>
<li><a href='#compDeriv'><p>Computes the successive derivatives of a time series</p></a></li>
<li><a href='#concat'><p>Concat Concatenates separated time series</p></a></li>
<li><a href='#concatMulTS'><p>ConcatMulTS Concatenates separated time series (of single or multiples variables)</p></a></li>
<li><a href='#d2pMax'><p>Provides the number of polynomial terms <code>pMax</code></p>
given <code>dMax</code> and <code>nVar</code></a></li>
<li><a href='#data_vignetteIII+20data+20set'><p>Output of the vignette <code>III_Modelling</code></p></a></li>
<li><a href='#data_vignetteVI+20data+20set'><p>Output of the vignette <code>VI_Sensitivity</code></p></a></li>
<li><a href='#data_vignetteVII+20data+20set'><p>Output of the vignette <code>VII_Retro-Modelling</code></p></a></li>
<li><a href='#derivODE2'><p>A subfonction for the numerical integration</p>
of polynomial equations provided in a generic form
following the convetion defined by function <code>poLabs</code>.</a></li>
<li><a href='#derivODEwMultiX'><p>deriveODEwMultiX : A Subfonction for the numerical integration</p>
of polynomial equations in the generic form defined by function
<code>poLabs</code> and with External Forcing F(t)</a></li>
<li><a href='#detectP1limCycl'><p>Detection of limit cycles of period-1</p></a></li>
<li><a href='#drvSucc'><p>drvSucc : Computes the successive derivatives of a time series</p></a></li>
<li><a href='#extractEq'><p>extractEq : Extracts Equations from one system</p></a></li>
<li><a href='#findAllSets'><p>Find all possible sets of equation combinations</p>
considering an ensemble of possible equation.</a></li>
<li><a href='#gloMoId'><p>Global Model Identification</p></a></li>
<li><a href='#gPoMo'><p>Generalized Polynomial Modeling</p></a></li>
<li><a href='#GSproc'><p>Gram-Schmidt procedure</p></a></li>
<li><a href='#NDVI'><p>A time series of vegetation index measured from satellite</p></a></li>
<li><a href='#numicano'><p>Numerical Integration of models in ODE of polynomial form</p></a></li>
<li><a href='#numiMultiX'><p>Numerical Integration polynomial ODEs with Multiple eXternal forcing</p></a></li>
<li><a href='#numinoisy'><p>Generates time series of deterministic-behavior</p>
with stochatic perturbations (measurement and/or dynamical noise)</a></li>
<li><a href='#odeBruitMult2'><p>For the numerical integration of ordinary</p>
differential equations with dynamical noise.</a></li>
<li><a href='#P1FxCh'><p>A data set for testing periodicity</p></a></li>
<li><a href='#P1FxChP2'><p>A data set for testing periodicity</p></a></li>
<li><a href='#p2dMax'><p>p2dMax : provides the maximum polynomial degree <code>dMax</code></p>
given the number of variables <code>nVar</code> and the number of possible
polynomial terms <code>pMax</code>.</a></li>
<li><a href='#paramId'><p>For parameter Identification</p></a></li>
<li><a href='#poLabs'><p>Polynomial labels order</p></a></li>
<li><a href='#predictab'><p>Estimate the models performance obtained with <code>GPoMo</code></p>
in term of predictability</a></li>
<li><a href='#pTimEv'><p>Model stationnary testing</p></a></li>
<li><a href='#regOrd'><p>Generate the conventional order for polynomial terms</p>
in a the polynomial formulation</a></li>
<li><a href='#regSeries'><p>Estimates the monomial time series</p></a></li>
<li><a href='#Rossler-1976+20data+20set'><p>Time series of the Rossler-1976 system</p></a></li>
<li><a href='#RosYco'><p>Twelve Rossler-1976 time series (exclusively variable <code class="reqn">y</code>)</p></a></li>
<li><a href='#subSysD'><p>subSysD : Sub-systems Disentangling</p></a></li>
<li><a href='#svrlTS'><p>A data set for the global modeling of time series in association</p></a></li>
<li><a href='#testP'><p>Periodic solution test</p></a></li>
<li><a href='#TS'><p>Time series resulting from the integration of a non stationary system</p></a></li>
<li><a href='#TSallMod_nVar3_dMax2+20data+20set'><p>Time series of three-dimensional chaotic sytems</p>
(for vignette <code>VII_Retro-Modelling</code>)</a></li>
<li><a href='#visuEq'><p>Displays the models Equations</p></a></li>
<li><a href='#visuOutGP'><p>visuOutGP : get a quick information of gPoMo output</p></a></li>
<li><a href='#wInProd'><p>Weighted inner product</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Generalized Polynomial Modelling</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-06-16</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mireille Huc &lt;mireille.huc@u-paris2.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Platform dedicated to the Global Modelling technique. Its aim
    is to obtain ordinary differential equations of polynomial form directly
    from time series. It can be applied to single or multiple time series under
    various conditions of noise, time series lengths, sampling, etc. This platform
    is developped at the Centre d'Etudes Spatiales de la Biosphere (CESBIO),
    UMR 5126 UPS/CNRS/CNES/IRD, 18 av. Edouard Belin, 31401 TOULOUSE, FRANCE.
    The developments were funded by the French program Les Enveloppes Fluides
    et l'Environnement (LEFE, MANU, projets GloMo, SpatioGloMo and MoMu). The
    French program Defi InFiNiTi (CNRS) and PNTS are also acknowledged (projects
    Crops'IChaos and Musc &amp; SlowFast). The method is described in the article :
    Mangiarotti S. and Huc M. (2019) &lt;<a href="https://doi.org/10.1063%2F1.5081448">doi:10.1063/1.5081448</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.cecill.info/licences/Licence_CeCILL_V2-en.txt">CeCILL-2</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6), deSolve, rgl</td>
</tr>
<tr>
<td>Imports:</td>
<td>float</td>
</tr>
<tr>
<td>Suggests:</td>
<td>signal, knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-15 17:05:56 UTC; hucm</td>
</tr>
<tr>
<td>Author:</td>
<td>Sylvain Mangiarotti [aut],
  Mireille Huc [cre, aut],
  Flavie Le Jean [ctb],
  Malika Chassan [ctb],
  Laurent Drapeau [ctb],
  Institut de Recherche pour le Développement [fnd],
  Centre National de la Recherche Scientifique [fnd]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-16 08:10:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='GPoM-package'>GPoM package: Generalized Polynomial Modelling</h2><span id='topic+GPoM-package'></span>

<h3>Description</h3>

<p>GPoM is a platform dedicated to the Global Modelling
technique. Its aim is to obtain deterministic models of
Ordinary Differential Equations from observational time series.
It applies to single and to multiple time series.
With single time series, it can be used:
to detect low-dimnesional determinism and low-dimensional
(deterministic) chaos. It can also be used to
characterize the observed behavior, using the obtained
models as a proxy of the original dynamics,
as far as the model validation could be checked.
With multiple time series, it can be used:
to detect couplings between observed variables,
to infer causal networks,
and to reformulate the original equations of the observed
system (retro-modelling).
The present package focuses on models in Ordinary Differential
Equations of polynomial form.
The package was designed to model weakly predictable dynamical
behaviors (such as chaotic behaviors).
Of course, it can also apply to more of fully predictable
behavior, either linear or nonlinear.
Several vignettes are associated to the package
which can be used as a tutorial,
and it also provides an overlook of the diversity
of applications and at the performances of the tools.
Users are kindly asked to quote the corresponding
references when using the package (see hereafter).
</p>


<h3>Note</h3>

<p>FOR USERS <br />
This package was developped at Centre d'Etudes Spatiales de
la Biosphere (Cesbio, UMR 5126, UPS-CNRS-CNES-IRD,
http://www.cesbio.ups-tlse.fr).
An important part of the developments were funded by
the French program Les Enveloppes Fluides et l'Environnement
(LEFE, MANU, projets GloMo, SpatioGloMo and MoMu).
The French program Défi InFiNiTi (CNRS) and PNTS
are also acknowledged (projects Crops'IChaos and Musc &amp; SlowFast).
</p>
<p>If you apply this package to single time series,
please quote [6].
If you apply it to multivariate time series,
please quote [10].
If you apply it to infer couplings among
time series, please quote [8].
If you apply it to classification, please quote [11].
</p>
<p>HISTORICAL BACKGROUND <br />
The global modelling technique was initiated during
the early 1990s [1-3]. It takes its background from
the Theory of Nonlinear Dynamical Systems.
Earlier investigations can also be found in the fields
of Electrical Engineering and Statistics but these
mainly focused on linear problems [4].
The approach became applicable to the analysis of real world
environmental behaviours by the end of the 2000s [5-7].
Recent works have shown that the approach could be applied to
numerous other dynamical behaviors [8-10].
Global modelling aims to obtain deterministic models
directly from observed time series.
</p>


<h3>Author(s)</h3>

<p>Sylvain Mangiarotti, Flavie Le Jean,
Malika Chassan, Laurent Drapeau, Mireille Huc.
</p>
<p>Maintainer: M. Huc &lt;mireille.huc@u-paris2.fr&gt;
</p>


<h3>References</h3>

<p>[1] J. P. Crutchfield and B. S. McNamara, 1987.
Equations of motion from a data series,
Complex Systems. 1, 417-452. <br />
[2] Gouesbet G., Letellier C., 1994.
Global vector-field reconstruction by using a multivariate
polynomial L2 approximation on nets,
Physical Review E, 49 (6), 4955-4972. <br />
[3] C. Letellier, L. Le Sceller, E. Marechal, P. Dutertre, B. Maheu,
G. Gouesbet, Z. Fei, and J. L. Hudson, 1995.
Global vector field reconstruction from a chaotic experimental
signal in copper electrodissolution,
Physical Review E, 51, 4262-4266. <br />
[4] L. A. Aguirre &amp; C. Letellier,
Modeling nonlinear dynamics and chaos: A review,
Mathematical Problems in Engineering, 2009, 238960. <br />
C. Letellier, L. Le Sceller, E. Marechal, P. Dutertre, B. Maheu,
G. Gouesbet, Z. Fei, and J. L. Hudson, 1995.
Global vector field reconstruction from a chaotic experimental
signal in copper electrodissolution,
Physical Review E 51, 4262-4266. <br />
[5] J. Maquet, C. Letellier, and L. A. Aguirre, 2007.
Global models from the Canadian Lynx cycles as a first evidence
for chaos in real ecosystems,
Juornal of Mathematical Biology. 55(1), 21-39. <br />
[6] Mangiarotti S., Coudret R., Drapeau L., &amp; Jarlan L., 2012.
Polynomial search and global modeling : Two algorithms for
modeling chaos,
Physical Review E, 86, 046205. <br />
[7] Mangiarotti S., Drapeau L. &amp; Letellier C., 2014.
Two chaotic models for cereal crops observed from satellite in
northern Morocco.
Chaos, 24(2), 023130. <br />
[8] Mangiarotti S., 2015. Low dimensional chaotic models for the
plague epidemic in Bombay (1896-1911).
Chaos, Solitons and Fractals, 81A, 184-186. <br />
[9] Mangiarotti S., Peyre M. &amp; Huc M.,
A chaotic model for the epidemic of Ebola Virus Disease in West Africa (2013-2016).
Chaos, 26, 113112, 2016. <br />
[10] Mangiarotti S., 2014. Modelisation globale et Caracterisation
Topologique de dynamiques environnementales - de l'analyse des
enveloppes fluides et du couvert de surface de la Terre a la
caracterisation topolodynamique du chaos.
Habilitation to Direct Research,
University of Toulouse 3, France. <br />
[11] Mangiarotti S., Sharma A.K., Corgne S., Hubert-Moy L., Ruiz L., Sekhar M., Kerr Y.,
Can the global modelling technique be used for crop classification?
Chaos, Solitons &amp; Fractals, in press. <br />
</p>

<hr>
<h2 id='allMod_nVar3_dMax2+20data+20set'>Numerical description of a list of eighteen three-dimensional chaotic
sytems (see vignette <code>7_Retro-Modelling</code>)</h2><span id='topic+allMod_nVar3_dMax2+20data+20set'></span><span id='topic+allMod_nVar3_dMax2'></span>

<h3>Description</h3>

<p>A list named <code>allMod_nVar3_dMax2</code> of matrix
providing the numerical description of eighteen three-dimensional
chaotic systems: <br />
Lorenz-1963 (<code>$L63</code>), Rössler-1976 (<code>$R76</code>), Burke &amp; shaw 1981 (<code>$BS81</code>),
Lorenz-1984 (<code>$L84</code>), Nosé &amp; Hooer 1986 (<code>$NH86</code>), Genesio &amp; Tosi 1992 (<code>$GT92</code>),
Spott systems 1994 (<code>$SprF</code>, <code>$SprH</code>, <code>$SprK</code>, <code>$SprO</code>, <code>$SprP</code>, <code>$SprG</code>,
<code>$SprM</code>, <code>$SprQ</code>, <code>$SprS</code>),
Chlouverakis &amp; Sprott 2004 (<code>$CS2004</code>), Li 2007 (<code>$Li2007</code>)
and the Cord system by Aguirre &amp; Letellier 2012 (<code>$Cord2012</code>).
Each dynamical system is provided as a matrix:
each column corresponds to one equation,
each lines to the polynomial coefficients
which order is following the convetion defined
by function <code>poLabs(nVar = 3, dMax = 2)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allMod_nVar3_dMax2
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 18.
</p>


<h3>Author(s)</h3>

<p>Sylvain Mangiarotti, Mireille Huc.
</p>


<h3>References</h3>

<p>All the references are provided in
vignette <code>7_retro-modelling</code>.
</p>

<hr>
<h2 id='allToTest'>A list providing the description of six models tested by
the function <code>autoGPoMoTest</code>.</h2><span id='topic+allToTest'></span>

<h3>Description</h3>

<p>List of 6 models available for tests (by <code>autoGPoMoTest</code>).
Each model (<code>$mToTest1</code>, <code>$mToTest2</code>, etc.) is provided as a matrix
of dimension 10 * 3. Each column corresponds to one equation.
The order of the coefficients follows the conventions defined
by <code>poLabs(nVar = 3, dMax = 2)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allToTest
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 6.
</p>


<h3>Author(s)</h3>

<p>Sylvain Mangiarotti, Mireille Huc
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###########
# example #
###########
data("allToTest")
# 6 models are available in this list:
names(allToTest)
# The parameter of their formulation (nVar and dMax)
# can be retrieved:
nVar &lt;- dim(allToTest$mToTest6)[2]
dMax &lt;- p2dMax(nVar = 3, pMaxKnown = dim(allToTest$mToTest6)[1])
# Their equation can be edited as follows:
visuEq(allToTest$mToTest6, nVar, dMax, approx = 2)

</code></pre>

<hr>
<h2 id='autoGPoMoSearch'>Automatic search of polynomial Equations</h2><span id='topic+autoGPoMoSearch'></span>

<h3>Description</h3>

<p>This algorithm aims to get an ensemble of possible
models which integrability will be tested later with function
<code>autoGPoMoTest</code>. By default, all the terms are considered
available (Some of the terms can be excluded intentionally
using the option <code>filterReg</code>).
The maximum size of the equation depends on the model dimension
<code>nVar</code>, and on the maximum polynomial degree <code>dMax</code>.
The algorithm removes polynomial terms one by one using a
leave-one-out method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autoGPoMoSearch(
  data,
  dt,
  nVar,
  dMax,
  dMin = 0,
  weight = NULL,
  show = 0,
  underSamp = NULL,
  filterReg = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoGPoMoSearch_+3A_data">data</code></td>
<td>
<p>Input Time series: Each column is one time series
that corresponds to one variable.</p>
</td></tr>
<tr><td><code id="autoGPoMoSearch_+3A_dt">dt</code></td>
<td>
<p>Time sampling of the input series.</p>
</td></tr>
<tr><td><code id="autoGPoMoSearch_+3A_nvar">nVar</code></td>
<td>
<p>Number of variables considered in the polynomial formulation.</p>
</td></tr>
<tr><td><code id="autoGPoMoSearch_+3A_dmax">dMax</code></td>
<td>
<p>Maximum degree of the polynomial formulation.</p>
</td></tr>
<tr><td><code id="autoGPoMoSearch_+3A_dmin">dMin</code></td>
<td>
<p>The minimum negative degree of the polynomial
formulation (0 by default).</p>
</td></tr>
<tr><td><code id="autoGPoMoSearch_+3A_weight">weight</code></td>
<td>
<p>A vector providing the binary weighting function
of the input data series (0 or 1). By default, all the values
are set to 1.</p>
</td></tr>
<tr><td><code id="autoGPoMoSearch_+3A_show">show</code></td>
<td>
<p>Provide (2) or not (0-1) visual output during
the running process.</p>
</td></tr>
<tr><td><code id="autoGPoMoSearch_+3A_undersamp">underSamp</code></td>
<td>
<p>Number of points used for undersampling the data.
For <code>undersamp = 1</code> the complete time series is used.
For <code>undersamp = 2</code>, only one data out of two is kept, etc.</p>
</td></tr>
<tr><td><code id="autoGPoMoSearch_+3A_filterreg">filterReg</code></td>
<td>
<p>A vector that specifies the template for
the equation structure (for one single equation).
The convention defined by <code>poLabs</code> is used.
Value is 1 if the regressor is available, 0 if it is not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two matrices:
</p>
<p><code>$filtMemo</code> describes the selected terms
(1 if the term is used, 0 if not)
</p>
<p><code>$KMemo</code> provides the corresponding coefficients
</p>


<h3>Author(s)</h3>

<p>Sylvain Mangiarotti, Flavie Le Jean
</p>


<h3>See Also</h3>

<p><code><a href="#topic+autoGPoMoTest">autoGPoMoTest</a></code>, <code><a href="#topic+gPoMo">gPoMo</a></code>,
<code><a href="#topic+findAllSets">findAllSets</a></code>, <code><a href="#topic+poLabs">poLabs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data('RosYco')
# Search for potential models
filt = autoGPoMoSearch(RosYco[,2], nVar = 3, dMax = 2,
                       dt = 1/125, show = 1)
# As an example, the equations of the fourth line has the following terms:
poLabs(nVar = 3, dMax = 2)[filt$filtMemo[5,] != 0]
# which coefficients correspond to
cbind(filt$KMemo[5,], poLabs(nVar = 3, dMax = 2))[filt$filtMemo[5,] != 0,]

</code></pre>

<hr>
<h2 id='autoGPoMoTest'>Tests the numerical integrability of models and
classify their dynamical regime</h2><span id='topic+autoGPoMoTest'></span>

<h3>Description</h3>

<p>Tests the numerical integrability of
provided models (these may have been obtained with
function <code>autoGPoMoSearch</code>),
and classify these models as Divergent, Fixed Points,
Periodic or not Unclassified (potentially chaotic).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autoGPoMoTest(
  data,
  nVar,
  dMax,
  dMin = 0,
  tin = NULL,
  dt = NULL,
  show = 1,
  verbose = 1,
  allKL = allKL,
  numValidIC = 1,
  weight = NULL,
  IstepMin = 10,
  IstepMax = 10000,
  tooFarThr = 4,
  FxPtThr = 1e-08,
  LimCyclThr = 1e-06,
  method = "rk4"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoGPoMoTest_+3A_data">data</code></td>
<td>
<p>Input Time series: Each column is one time series
that corresponds to one variable.</p>
</td></tr>
<tr><td><code id="autoGPoMoTest_+3A_nvar">nVar</code></td>
<td>
<p>Number of variables considered in the polynomial formulation.</p>
</td></tr>
<tr><td><code id="autoGPoMoTest_+3A_dmax">dMax</code></td>
<td>
<p>Maximum degree of the polynomial formulation.</p>
</td></tr>
<tr><td><code id="autoGPoMoTest_+3A_dmin">dMin</code></td>
<td>
<p>The minimum negative degree of the polynomial
formulation (0 by default).</p>
</td></tr>
<tr><td><code id="autoGPoMoTest_+3A_tin">tin</code></td>
<td>
<p>Input date vector which length should correspond to
the input time series.</p>
</td></tr>
<tr><td><code id="autoGPoMoTest_+3A_dt">dt</code></td>
<td>
<p>Sampling time of the input time series.</p>
</td></tr>
<tr><td><code id="autoGPoMoTest_+3A_show">show</code></td>
<td>
<p>Provide (2) or not (0-1) visual output during
the running process.</p>
</td></tr>
<tr><td><code id="autoGPoMoTest_+3A_verbose">verbose</code></td>
<td>
<p>Gives information (if set to 1) about the algorithm
progress and keeps silent if set to 0.</p>
</td></tr>
<tr><td><code id="autoGPoMoTest_+3A_allkl">allKL</code></td>
<td>
<p>A list of all the models <code>$mToTest1</code>,
<code>$mToTest2</code>, etc. to be tested. Each model is provided
as a matrix.</p>
</td></tr>
<tr><td><code id="autoGPoMoTest_+3A_numvalidic">numValidIC</code></td>
<td>
<p>Line number of the first valid initial
conditions, that is, such as weight is not equal to zero.</p>
</td></tr>
<tr><td><code id="autoGPoMoTest_+3A_weight">weight</code></td>
<td>
<p>A vector providing the binary weighting function
of the input data series (0 or 1). By default, all the values
are set to 1.</p>
</td></tr>
<tr><td><code id="autoGPoMoTest_+3A_istepmin">IstepMin</code></td>
<td>
<p>The minimum number of integration step to start
of the analysis (by default <code>IstepMin = 10</code>).</p>
</td></tr>
<tr><td><code id="autoGPoMoTest_+3A_istepmax">IstepMax</code></td>
<td>
<p>The maximum number of integration steps for
stopping the analysis (by default <code>IstepMax = 10000</code>).</p>
</td></tr>
<tr><td><code id="autoGPoMoTest_+3A_toofarthr">tooFarThr</code></td>
<td>
<p>Divergence threshold, maximum value
of the model trajectory compared to the data standard
deviation. By default a trjactory is too far if
the distance to the center is larger than four times the variance
of the input data.</p>
</td></tr>
<tr><td><code id="autoGPoMoTest_+3A_fxptthr">FxPtThr</code></td>
<td>
<p>Threshold used to detect fixed points.</p>
</td></tr>
<tr><td><code id="autoGPoMoTest_+3A_limcyclthr">LimCyclThr</code></td>
<td>
<p>Threshold used to detect the limit cycle.</p>
</td></tr>
<tr><td><code id="autoGPoMoTest_+3A_method">method</code></td>
<td>
<p>The integration technique used for the numerical
integration. By default, the fourth-order Runge-Kutta method
(<code>method = 'rk4'</code>) is used. Other methods such as 'ode45'
or 'lsoda' may also be chosen. See package <code>deSolve</code>
for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>
<p><code>$okMod</code>      A vector classifying the models: diverging models (0),
periodic models of period-1 (-1), unclassified models (1).
</p>
<p><code>$okMod</code>      A matrix classifying the model variables: diverging variable (0),
period-1 variable (-1), period-2 variable (-2), fixed point variable (2), unclassified models (1).
</p>
<p><code>$coeff</code>      A matrix with the coefficients of one selected model
</p>
<p><code>$models</code>     A list of all the models to be tested <code>$mToTest1</code>,
<code>$mToTest2</code>, etc. and of all selected models <code>$model1</code>, <code>$model2</code>, etc.
</p>
<p><code>$tout</code>       The time vector of the output time series (vector length
corresponding to the longest numerical integration duration)
</p>
<p><code>$stockoutreg</code> A list of matrices with the integrated trajectories
(variable <code>X1</code> in column 1, <code>X2</code> in 2, etc.) for all the models
<code>$model1</code>, <code>$model2</code>, etc.
</p>


<h3>Author(s)</h3>

<p>Sylvain Mangiarotti, Flavie Le Jean
</p>


<h3>See Also</h3>

<p><code><a href="#topic+autoGPoMoSearch">autoGPoMoSearch</a></code>, <code><a href="#topic+gPoMo">gPoMo</a></code>, <code><a href="#topic+poLabs">poLabs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Example
# Load data:
data('RosYco')
# Structure choice
data('allToTest')
# Test the models
outGPT &lt;- autoGPoMoTest(RosYco, nVar= 3, dMax = 2, dt = 1/125, show=1,
                        allKL = allToTest, IstepMax = 60)

</code></pre>

<hr>
<h2 id='bDrvFilt'>Builds the derivative filter</h2><span id='topic+bDrvFilt'></span>

<h3>Description</h3>

<p>Build the Savitzky-Golay derivative filter (Savitzky-Golay, 1964).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bDrvFilt(nDrv, tstep, winL = 9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bDrvFilt_+3A_ndrv">nDrv</code></td>
<td>
<p>The number of derivatives to be computed.</p>
</td></tr>
<tr><td><code id="bDrvFilt_+3A_tstep">tstep</code></td>
<td>
<p>Sampling time.</p>
</td></tr>
<tr><td><code id="bDrvFilt_+3A_winl">winL</code></td>
<td>
<p>The local window length to be used for computing the derivatives [1].</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dFlt A matrix of size (nDrv+1) * winL
</p>


<h3>Author(s)</h3>

<p>Sylvain Mangiarotti
</p>


<h3>References</h3>

<p>[1] Savitzky, A.; Golay, M.J.E.,
Smoothing and Differentiation of Data by Simplified Least Squares Procedures.
Analytical Chemistry 36 (8), 1627-1639, 1964.<br />
</p>

<hr>
<h2 id='cano2M'>cano2M : Converts a model in canonical form into a matrix form</h2><span id='topic+cano2M'></span>

<h3>Description</h3>

<p>Converts the vectorial formulation of canonical models
into a matrix formulation (that is, including explicitely all the
equations). For both input, the list of terms follows the convention
defined by <code>poLabs</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cano2M(nVar, dMax, poly, dMin = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cano2M_+3A_nvar">nVar</code></td>
<td>
<p>The number of variables</p>
</td></tr>
<tr><td><code id="cano2M_+3A_dmax">dMax</code></td>
<td>
<p>The maximum degree allowed in the formulation</p>
</td></tr>
<tr><td><code id="cano2M_+3A_poly">poly</code></td>
<td>
<p>A vector of coefficients corresponding to the regressor
of the canonical function</p>
</td></tr>
<tr><td><code id="cano2M_+3A_dmin">dMin</code></td>
<td>
<p>The minimum negative degree of the polynomial
formulation (0 by default).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>Kmod</code> A matrix with nVar columns of the complete description of the equations.
The first columns relates to the canonical part dX1/dt = X2, dX2/dt = X3 etc. and
the column is the polynomial term itself
</p>


<h3>Author(s)</h3>

<p>Sylvain Mangiarotti, Mireille Huc
</p>


<h3>See Also</h3>

<p><code><a href="#topic+drvSucc">drvSucc</a></code>, <code><a href="#topic+gPoMo">gPoMo</a></code>, <code><a href="#topic+poLabs">poLabs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A vector of polynomial terms corresponding to a canonical form:
polyTerms &lt;- c(0.2,0,-1,0.5,0,0,0,0,0,0)
# Convert this vector into a matrix formulation with all the equations: 
K &lt;- cano2M(3,2,polyTerms)
# Visualize the equations:
visuEq(K,3,2)

</code></pre>

<hr>
<h2 id='combiEq'>combiEq : Combine Equations from different sources</h2><span id='topic+combiEq'></span>

<h3>Description</h3>

<p>Combines equations of different sources
into a single system. During this combination, the polynomial
maximal degree can be either imposed or optimized to reduce
the model size. All the input have to follow
the convention defined by <code>poLabs</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combiEq(allKL, eqOrder = NULL, dMaxOut = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combiEq_+3A_allkl">allKL</code></td>
<td>
<p>A list of models, each provided as a matrix.
A single matrix can also be provided, it will be transformed
into a list containing a single matrix.</p>
</td></tr>
<tr><td><code id="combiEq_+3A_eqorder">eqOrder</code></td>
<td>
<p>A list of vector, providing each the equations
number (relating to the input models) to be kept in the
output equation system. If not provided, all the equations
are kept.
A single matrix can also be provided, it will be transformed
into a list containing a single matrix.</p>
</td></tr>
<tr><td><code id="combiEq_+3A_dmaxout">dMaxOut</code></td>
<td>
<p>The maximal polynomial degree of the output
equation system (if not provided, this degree is deduced
from the input models)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>KLout A matrix of the combined model
</p>


<h3>Author(s)</h3>

<p>Sylvain Mangiarotti
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gPoMo">gPoMo</a></code>, <code><a href="#topic+poLabs">poLabs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load models
data("allMod_nVar3_dMax2")
# Display equations of system 1
visuEq(nVar = 3, dMax = 2, K = allMod_nVar3_dMax2$NH86, substit = 1)
# Display equations of system 2
visuEq(nVar = 3, dMax = 2, K = allMod_nVar3_dMax2$R76, substit = 1)
# put the two systems in a list
allK &lt;- list()
allK[[1]] &lt;- allMod_nVar3_dMax2$NH86
allK[[2]] &lt;- allMod_nVar3_dMax2$R76

# Example 1: reformulate two autonomous system in a single matrix 
visuEq(K = allK[[1]], substit = c('u', 'v', 'w'))
visuEq(K = allK[[2]], substit = c('X', 'Y', 'Z'))
Knew &lt;- combiEq(allK)
visuEq(K = Knew, substit = c('u', 'v', 'w', 'X', 'Y', 'Z'))

# Example 2
inXnote = list()
inXnote[[1]] &lt;- c('u', 'v', 'w')
inXnote[[2]] &lt;- c('X', 'Y', 'Z')
visuEq(K = allK[[1]], substit = inXnote[[1]])
visuEq(K = allK[[2]], substit = inXnote[[2]])
XnoteOut = c('X', 'Y', 'Z', 'u', 'v', 'w')
Knew2 &lt;- combiEq(allK, eqOrder=c(4,5,6,1,2,3))
visuEq(K = Knew2, substit = XnoteOut)

# Example 3
inXnote = list()
inXnote[[1]] &lt;- c('u', 'v', 'w')
inXnote[[2]] &lt;- c('X', 'Y', 'Z')
visuEq(K = allK[[1]], substit = inXnote[[1]])
visuEq(K = allK[[2]], substit = inXnote[[2]])
XnoteOut = c('u', 'X', 'v', 'Y', 'w', 'Z')
Knew3 &lt;- combiEq(allK, eqOrder=c(1,4,2,5,3,6), dMaxOut = 3)
visuEq(K = Knew3, substit = XnoteOut)
</code></pre>

<hr>
<h2 id='compDeriv'>Computes the successive derivatives of a time series</h2><span id='topic+compDeriv'></span>

<h3>Description</h3>

<p>Computes the successive derivatives from one single time series,
with the Savitzky-Golay approach (1964).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compDeriv(TS, nDrv, tstep, winL = 9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compDeriv_+3A_ts">TS</code></td>
<td>
<p>A single time series provided as a single vector.</p>
</td></tr>
<tr><td><code id="compDeriv_+3A_ndrv">nDrv</code></td>
<td>
<p>The number of derivatives to be computed from the input
<code>series</code>. The resulting number of outpout time series
will thus be <code>nVar = nDrv + 1</code>.</p>
</td></tr>
<tr><td><code id="compDeriv_+3A_tstep">tstep</code></td>
<td>
<p>Sampling Time of the input time series <code>TS</code>.</p>
</td></tr>
<tr><td><code id="compDeriv_+3A_winl">winL</code></td>
<td>
<p>The local window length used for computing
the derivatives [1-2].</p>
</td></tr>
</table>


<h3>Value</h3>

<p>drv A matrix containing the original variable (smoothed by the
filtering process) in the first comlumn and its <code>nDrv</code>+1 first derivatives
in the next columns (note that <code>winL</code> values of the original time series
will be lost both at the begining and the end of the time series due to boundary
effect).
</p>


<h3>Author(s)</h3>

<p>Sylvain Mangiarotti
</p>


<h3>References</h3>

<p>[1] Savitzky, A.; Golay, M.J.E.,
Smoothing and Differentiation of Data by Simplified Least Squares Procedures.
Analytical Chemistry 36 (8), 1627-1639, 1964.<br />
[2] Steinier J., Termonia Y., Deltour, J.
Comments on smoothing and differentiation of data by simplified least square procedure.
Analytical Chemistry 44 (11): 1906-1909, 1972. <br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gloMoId">gloMoId</a></code>, <code><a href="#topic+gPoMo">gPoMo</a></code>, <code><a href="#topic+poLabs">poLabs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data:
data(NDVI)

# Compute the derivatives:
drv &lt;- compDeriv(NDVI[,1], nDrv = 3, tstep = 1/125)

</code></pre>

<hr>
<h2 id='concat'>Concat Concatenates separated time series</h2><span id='topic+concat'></span>

<h3>Description</h3>

<p>The aim of this code is to provide, from a set of multiple
time series, a single concatenated time series for applying the global
modeling technique to all the time time series in association.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>concat(svrlTS, winL = 9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="concat_+3A_svrlts">svrlTS</code></td>
<td>
<p>All separated time series.</p>
</td></tr>
<tr><td><code id="concat_+3A_winl">winL</code></td>
<td>
<p>Total number of points used for computing the derivatives
of the input time series. This parameter will be used as an
input in function <code>drvSucc</code> to compute the derivatives.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>concaTS</code> The concatenated time series.
</p>


<h3>Author(s)</h3>

<p>Sylvain Mangiarotti, Mireille Huc
</p>


<h3>References</h3>

<p>S. Mangiarotti, F. Le Jean, M. Huc &amp; C. Letellier, 2016.
Global modeling of aggregated and associated chaotic dynamics,
Chaos, Solitons &amp; Fractals, 83, 82-96.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data
data("svrlTS")
# Concatenate the data set into a single time series
winL = 55
concaTS &lt;- concat(svrlTS, winL = winL)
# Plot the concatenated time series
plot(concaTS$sglTS$TS[,1], concaTS$sglTS$TS[,2],
     main = 'Concatenated time series',
     xlab = 'Time (concatenated)', ylab = 'y(t)',
     type = 'l', col = 'gray')
lines(concaTS$sglTS$TS[concaTS$sglTS$W == 1,1],
      concaTS$sglTS$TS[concaTS$sglTS$W == 1,2], type = 'p', col = 'green', cex = 0.5)
lines(concaTS$sglTS$TS[concaTS$sglTS$W == 0,1],
      concaTS$sglTS$TS[concaTS$sglTS$W == 0,2], type = 'p', col = 'red', cex = 0.5)
lines(concaTS$sglTS$TS[,1], concaTS$sglTS$W, type = 'l')

# The concatenated data set can be used for global modelling:
GPout1 &lt;- gPoMo(data = concaTS$sglTS$TS[,2], tin = concaTS$sglTS$TS[,1],
                dMax = 2, nS = 3, winL = winL, weight = concaTS$sglTS$W, show = 1,
                IstepMin = 10, IstepMax = 6000, nPmin = 11, nPmax = 11, method = 'rk4')


</code></pre>

<hr>
<h2 id='concatMulTS'>ConcatMulTS Concatenates separated time series (of single or multiples variables)</h2><span id='topic+concatMulTS'></span>

<h3>Description</h3>

<p>The aim of this code is to provide, from multiple sets of
(single or multiple) time series, a single concatenated set of time series
for applying the global modeling technique to all the time time series
in association.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>concatMulTS(svrlTS, winL = 9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="concatMulTS_+3A_svrlts">svrlTS</code></td>
<td>
<p>All separated sets of time series.</p>
</td></tr>
<tr><td><code id="concatMulTS_+3A_winl">winL</code></td>
<td>
<p>Total number of points used for computing the derivatives
of the input time series. This parameter will be used as an
input in function <code>drvSucc</code> to compute the derivatives.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>concaTS</code> A single set of concatenated time series.
</p>


<h3>Author(s)</h3>

<p>Sylvain Mangiarotti, Mireille Huc
</p>


<h3>References</h3>

<p>S. Mangiarotti, F. Le Jean, M. Huc &amp; C. Letellier, 2016.
Global modeling of aggregated and associated chaotic dynamics,
Chaos, Solitons &amp; Fractals, 83, 82-96.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data
data("svrlTS")
# Concatenate the data set into a single time series
winL = 55
concaTS &lt;- concat(svrlTS, winL = winL)
# Plot the concatenated time series
plot(concaTS$sglTS$TS[,1], concaTS$sglTS$TS[,2],
     main = 'Concatenated time series',
     xlab = 'Time (concatenated)', ylab = 'y(t)',
     type = 'l', col = 'gray')
lines(concaTS$sglTS$TS[concaTS$sglTS$W == 1,1],
      concaTS$sglTS$TS[concaTS$sglTS$W == 1,2], type = 'p', col = 'green', cex = 0.5)
lines(concaTS$sglTS$TS[concaTS$sglTS$W == 0,1],
      concaTS$sglTS$TS[concaTS$sglTS$W == 0,2], type = 'p', col = 'red', cex = 0.5)
lines(concaTS$sglTS$TS[,1], concaTS$sglTS$W, type = 'l')

# The concatenated data set can be used for global modelling:
GPout1 &lt;- gPoMo(data = concaTS$sglTS$TS[,2], tin = concaTS$sglTS$TS[,1],
                dMax = 2, nS = 3, winL = winL, weight = concaTS$sglTS$W, show = 1,
                IstepMin = 10, IstepMax = 6000, nPmin = 11, nPmax = 11, method = 'rk4')


</code></pre>

<hr>
<h2 id='d2pMax'>Provides the number of polynomial terms <code>pMax</code>
given <code>dMax</code> and <code>nVar</code></h2><span id='topic+d2pMax'></span>

<h3>Description</h3>

<p>Computes the number of polynomial terms <code>pMax</code>
used to formulate an equation given
the maximal polynomial degree <code>dMax</code>
and the number of variables <code>nVar</code>
following the conventions as defined by fuction <code>poLabs</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d2pMax(nVar, dMaxKnown, dMin = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="d2pMax_+3A_nvar">nVar</code></td>
<td>
<p>Number of variables considered in the polynomial formulation.</p>
</td></tr>
<tr><td><code id="d2pMax_+3A_dmaxknown">dMaxKnown</code></td>
<td>
<p>The maximum polynomial degree <code>dMax</code></p>
</td></tr>
<tr><td><code id="d2pMax_+3A_dmin">dMin</code></td>
<td>
<p>The minimum negative degree of the polynomial
formulation (0 by default).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number <code>pMax</code> of polynomial terms used to code
a polynomial equation
</p>


<h3>Author(s)</h3>

<p>Sylvain Mangiarotti
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gloMoId">gloMoId</a></code>, <code><a href="#topic+gPoMo">gPoMo</a></code>, <code><a href="#topic+poLabs">poLabs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############
# Example 1 #
#############
# Maximum polynomial degree ?
# number of variables:
nVar &lt;- 3
# polynomial degree:
dMax &lt;- 3
# The maximal polynomial degree used for coding the polynomial is:
d2pMax(nVar,dMax)

</code></pre>

<hr>
<h2 id='data_vignetteIII+20data+20set'>Output of the vignette <code>III_Modelling</code></h2><span id='topic+data_vignetteIII+20data+20set'></span><span id='topic+data_vignetteIII'></span>

<h3>Description</h3>

<p>To reduce the computation time, the outputs
of the simulations presented in vignette VI have been
run beforehand and saved in this file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_vignetteIII
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 12.
</p>


<h3>Author(s)</h3>

<p>Sylvain Mangiarotti, Mireille Huc.
</p>

<hr>
<h2 id='data_vignetteVI+20data+20set'>Output of the vignette <code>VI_Sensitivity</code></h2><span id='topic+data_vignetteVI+20data+20set'></span><span id='topic+data_vignetteVI'></span>

<h3>Description</h3>

<p>To reduce the computation time, the outputs
of the simulations presented in vignette VI have been
run beforehand and saved in this file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_vignetteVI
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 6.
</p>


<h3>Author(s)</h3>

<p>Sylvain Mangiarotti, Mireille Huc.
</p>

<hr>
<h2 id='data_vignetteVII+20data+20set'>Output of the vignette <code>VII_Retro-Modelling</code></h2><span id='topic+data_vignetteVII+20data+20set'></span><span id='topic+data_vignetteVII'></span>

<h3>Description</h3>

<p>To reduce the computation time, the outputs
of the simulations presented in vignette VII have been
run beforehand and saved in this file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_vignetteVII
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 29.
</p>


<h3>Author(s)</h3>

<p>Sylvain Mangiarotti, Mireille Huc.
</p>

<hr>
<h2 id='derivODE2'>A subfonction for the numerical integration
of polynomial equations provided in a generic form
following the convetion defined by function <code>poLabs</code>.</h2><span id='topic+derivODE2'></span>

<h3>Description</h3>

<p>This function provides the one step integration of
polynomial Ordinary Differential Equations (ODE). This function
requires the function <code>ode</code> (<code>deSolve</code> package).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derivODE2(t, x, K, dMin = 0, regS = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derivODE2_+3A_t">t</code></td>
<td>
<p>All the dates for which the result of the numerical
integration of the model must be provided</p>
</td></tr>
<tr><td><code id="derivODE2_+3A_x">x</code></td>
<td>
<p>Current state vector (input from which the next state will
be estimated)</p>
</td></tr>
<tr><td><code id="derivODE2_+3A_k">K</code></td>
<td>
<p>A matrix providing the model description:
each column corresponds to one equation which polynomial organisation
is following the convention defined by function <code>poLabs</code>.</p>
</td></tr>
<tr><td><code id="derivODE2_+3A_dmin">dMin</code></td>
<td>
<p>The minimum negative degree of the polynomial
formulation (0 by default).</p>
</td></tr>
<tr><td><code id="derivODE2_+3A_regs">regS</code></td>
<td>
<p>Current states of each polynomial terms used
in <code>poLabs</code>. These states can be deduced from the current
state vector <code>x</code> (using the function <code>regSeries</code>).
When available, it can be provided as an input to avoid
unecessary computation.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sylvain Mangiarotti
</p>


<h3>See Also</h3>

<p><code><a href="#topic+numicano">numicano</a></code>, <code><a href="#topic+numinoisy">numinoisy</a></code>
</p>

<hr>
<h2 id='derivODEwMultiX'>deriveODEwMultiX : A Subfonction for the numerical integration
of polynomial equations in the generic form defined by function
<code>poLabs</code> and with External Forcing F(t)</h2><span id='topic+derivODEwMultiX'></span>

<h3>Description</h3>

<p>This function provides the one step integration of
polynomial Ordinary Differential Equations (ODE). This function
requires the function <code>ode</code> (&quot;deSolve&quot; package).
This function has to be run with the Runge-Kutta method (method = 'rk4')
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derivODEwMultiX(t, x, K, extF, regS = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derivODEwMultiX_+3A_t">t</code></td>
<td>
<p>All the dates for which the result of the numerical integration
of the model will have to be provided</p>
</td></tr>
<tr><td><code id="derivODEwMultiX_+3A_x">x</code></td>
<td>
<p>Current state vector (input from which the next state will
be estimated)</p>
</td></tr>
<tr><td><code id="derivODEwMultiX_+3A_k">K</code></td>
<td>
<p>is the model: each column corresponds to one equation
which organisation is following the convention given by function
<code>poLabs</code> which requires the definition of the model dimension
<code>nVar</code> (i.e. the number of variables) and the maximum polynomial
degree <code>dMax</code> allowed. The last Equation correspond to the
forcing variable that is artificially set to 0.</p>
</td></tr>
<tr><td><code id="derivODEwMultiX_+3A_extf">extF</code></td>
<td>
<p>is the external forcing. It is defined by two columns.
The first colomn correspond to time t. The second column to F(t) the
forcing at time t. Note that when launching the integration function
ode, the forcing F(t) should be provided with a sampling time twice
the sampling time used in t (because rk4 method will always use an
intermediate time step).</p>
</td></tr>
<tr><td><code id="derivODEwMultiX_+3A_regs">regS</code></td>
<td>
<p>Current states of each polynomial terms used
in <code>poLabs</code>. These states can be deduced from the current
state vector x (using function <code>regSeries</code>). When available,
it can be provided as an input to avoid unecessary computation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>xxx
</p>


<h3>Author(s)</h3>

<p>Sylvain Mangiarotti
</p>


<h3>Examples</h3>

<pre><code class='language-R'># build a non autonomous model
nVar = 4
dMax = 3
omega = 0.2
gamma = 0.05
KDf=matrix(0, nrow = d2pMax(nVar = nVar, dMax = dMax), ncol = nVar)
KDf[11,1]  = 1
KDf[2,2]  = 1
KDf[5,2]  = 1
KDf[11,2]  = -gamma
KDf[35,2] = -1
KDf[2,3]  = NA
KDf[2,4]  = NA
visuEq(K = KDf, substit = c('x', 'y', 'u', 'v'))
#
# Prepare the external forcing
# number of integration time step
Istep &lt;- 500
# time step
smpl &lt;- 1 / 20
# output time vector
dater &lt;- (0:Istep) * smpl
# hald step time vector (for Runge-Kutta integration)
daterdbl &lt;- (0:(Istep*2 + 1)) * smpl / 2
# generate the forcing (here variables u and v)
extF = cbind(daterdbl, -0.1 * cos(daterdbl * omega), 0.05 * cos(daterdbl * 16/3*omega))
#
# Initial conditions to be used (external variables can be set to 0)
etatInit &lt;- c(-0.616109362 , -0.126882584 , 0, 0)
#
# Numerical integration
reconstr2 &lt;- ode(etatInit, dater, derivODEwMultiX,
                 KDf, extF = extF, method = 'rk4')
# Reconstruction of the output
nVarExt &lt;- dim(extF)[2] - 1
reconstr2[,(nVar - nVarExt + 2):(nVar + 1)] &lt;- extF[(0:Istep+1)*2, 2:(nVarExt+1)]

</code></pre>

<hr>
<h2 id='detectP1limCycl'>Detection of limit cycles of period-1</h2><span id='topic+detectP1limCycl'></span>

<h3>Description</h3>

<p>This algorithm aim to detect period-1 limit cycles
from trajectories in the phase sapce considered in a
bidimensional projection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detectP1limCycl(data, LimCyclThreshold = 0.01, show = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="detectP1limCycl_+3A_data">data</code></td>
<td>
<p>A matrix of the trajectory in a 2D space (if more than
two columns are provided, only the two first columns are considered)</p>
</td></tr>
<tr><td><code id="detectP1limCycl_+3A_limcyclthreshold">LimCyclThreshold</code></td>
<td>
<p>The detection threshold</p>
</td></tr>
<tr><td><code id="detectP1limCycl_+3A_show">show</code></td>
<td>
<p>Indicates the deepness of the feedback (from 0 to 2)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Indicates if a limit cycle is detected (1) or not (0)
</p>


<h3>Author(s)</h3>

<p>Sylvain Mangiarotti
</p>


<h3>See Also</h3>

<p><code><a href="#topic+autoGPoMoTest">autoGPoMoTest</a></code>
</p>

<hr>
<h2 id='drvSucc'>drvSucc : Computes the successive derivatives of a time series</h2><span id='topic+drvSucc'></span>

<h3>Description</h3>

<p>Computes the successive derivatives from one single time series,
using the Savitzky-Golay algorithm (1964).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drvSucc(tin = NULL, serie, nDeriv, weight = NULL, tstep = NULL, winL = 9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drvSucc_+3A_tin">tin</code></td>
<td>
<p>Input date vector which length should correspond to
the input time series.</p>
</td></tr>
<tr><td><code id="drvSucc_+3A_serie">serie</code></td>
<td>
<p>A single time series provided as a single vector.</p>
</td></tr>
<tr><td><code id="drvSucc_+3A_nderiv">nDeriv</code></td>
<td>
<p>The number of derivatives to be computed from
the input time series. The resulting number of
time series obtained in output will be <code>nDeriv + 1</code>.</p>
</td></tr>
<tr><td><code id="drvSucc_+3A_weight">weight</code></td>
<td>
<p>A vector providing the binary weighting function
of the input data series (0 or 1). By default, all the values
are set to 1.</p>
</td></tr>
<tr><td><code id="drvSucc_+3A_tstep">tstep</code></td>
<td>
<p>Sampling time of the input time series. Used
only if time vector <code>tin</code> is not provided.</p>
</td></tr>
<tr><td><code id="drvSucc_+3A_winl">winL</code></td>
<td>
<p>Number (exclusively odd number) of points of
the local window used for computing the derivatives along
the input time series. The Savitzky-Golay filter is used for
this purpose [1,2].</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>
<p>$serie The original time serie
</p>
<p>$tin The time vector containing the dates corresponding
to the original time series
</p>
<p>$tstep The time step (assumed to be regular)
</p>
<p>$tout The time vector of the output series
</p>
<p>seriesDeriv A matrix containing the original time series
(smoothed by the filtering process) in the first column
and its <code>nDeriv + 1</code> successive derivatives in the next ones.
Note that <code>winL</code> values of the original time series will be lost,
that is <code>(winL - 1)/2</code> at the begining and <code>(winL - 1)/2</code>
at the end of the time series due to a computation boundary effect).
</p>


<h3>Author(s)</h3>

<p>Sylvain Mangiarotti, Mireille Huc
</p>


<h3>References</h3>

<p>[1] Savitzky, A.; Golay, M.J.E.,
Smoothing and Differentiation of Data by Simplified Least Squares Procedures.
Analytical Chemistry 36 (8), 1627-1639, 1964.<br />
[2] Steinier J., Termonia Y., Deltour, J.
Comments on smoothing and differentiation of data by simplified least square procedure.
Analytical Chemistry 44 (11): 1906-1909, 1972. <br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gloMoId">gloMoId</a></code>, <code><a href="#topic+gPoMo">gPoMo</a></code>, <code><a href="#topic+poLabs">poLabs</a></code>, <code><a href="#topic+compDeriv">compDeriv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############
# Example 1 #
#############
# Generate a time series:
tin &lt;- seq(0, 5, by = 0.01)
data &lt;- 2 * sin(5*tin)
dev.new()
oldpar &lt;- par(no.readonly = TRUE)    
on.exit(par(oldpar))  
par(mfrow = c(3, 1))
# Compute its derivatives:
drv &lt;- drvSucc(tin = tin, nDeriv = 2, serie = data, winL = 5)
#
# plot original and filtered series
plot(tin, data, type='l', col = 'black', xlab = 't', ylab = 'x(t)')
lines(drv$tout, drv$seriesDeriv[,1], lty = 3, lwd = 3, col = 'green')
#
# analytic 1st derivative
firstD &lt;- 10 * cos(5 * tin)
# plot both
plot(tin, firstD, type = 'l', col = 'black', xlab = 't', ylab = 'dx/dt')
lines(drv$tout, drv$seriesDeriv[,2], lty = 3, lwd = 3, col = 'green')
#
# analytic 2nd derivative
scdD &lt;- -50 * sin(5 * tin)
# plot both
plot(tin, scdD, type = 'l', col = 'black', xlab = 't', ylab = 'd2x/dt2')
lines(drv$tout, drv$seriesDeriv[,3], lty=3, lwd = 3, col = 'green')

#############
# Example 2 #
#############
# load data:
data("Ross76")
tin &lt;- Ross76[,1]
data &lt;- Ross76[,2]

# Compute the derivatives
drvOut &lt;- drvSucc(tin, data, nDeriv=4)
dev.new()
oldpar &lt;- par(no.readonly = TRUE)    
on.exit(par(oldpar))  
par(mfrow = c(3, 1))
# original and smoothed variable:
plot(drvOut$tin, drvOut$serie,
     type='p', cex = 1, xlab = 'time', ylab = 'x(t)')
lines(drvOut$tout, drvOut$seriesDeriv[,1], type='p', col='red')
lines(drvOut$tout, drvOut$seriesDeriv[,1], type='l', col='red')
# 1st derivative:
plot(drvOut$tout, drvOut$seriesDeriv[,2],
     type='p', col='red', xlab = 'time', ylab = 'dx(t)/dt')
lines(drvOut$tout, drvOut$seriesDeriv[,2], type='l', col='red')
# 2nd derivative:
plot(drvOut$tout, drvOut$seriesDeriv[,3],
     type='p', col='red', xlab = 'time', ylab = 'd2x(t)/dt2')
lines(drvOut$tout, drvOut$seriesDeriv[,3], type='l', col='red')

</code></pre>

<hr>
<h2 id='extractEq'>extractEq : Extracts Equations from one system</h2><span id='topic+extractEq'></span>

<h3>Description</h3>

<p>Combines equations of different sources
into a single system. During this combination, the polynomial
maximal degree can be either imposed or optimized to reduce
the model size. All the input have to follow
the convention defined by <code>poLabs</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractEq(KL, eqVect)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractEq_+3A_kl">KL</code></td>
<td>
<p>A model, provided as a matrix.</p>
</td></tr>
<tr><td><code id="extractEq_+3A_eqvect">eqVect</code></td>
<td>
<p>A vector of integers, providing the equations
numbers to be kept in the output equation system.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mireille Huc
</p>

<hr>
<h2 id='findAllSets'>Find all possible sets of equation combinations
considering an ensemble of possible equation.</h2><span id='topic+findAllSets'></span>

<h3>Description</h3>

<p>For each equation to be retrieved, an ensemble
of potential formulation is given. For instance, if three possible
formulations are provided for equation (1), one for equation (2)
and two for equation (3). In this case, six (i.e. 3*1*2) possible
sets of equations can be obtained from these potential formulations.
The aim of this program is to formulate all the potential
systems from the individual formulations provided of the
individual equations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findAllSets(allFilt, nS = c(3), nPmin = 1, nPmax = 14)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findAllSets_+3A_allfilt">allFilt</code></td>
<td>
<p>A list with:
(1) A matrix <code>allFilt$Xi</code> of possible formulations
for each equation (corresponding to variable <code>Xi</code>);
And (2) a vector <code>allFilt$Npi</code> providing the number of
polynomial terms contained in each formulation.</p>
</td></tr>
<tr><td><code id="findAllSets_+3A_ns">nS</code></td>
<td>
<p>A vector providing the number of dimensions used for each
input variables (see Examples 1 and 2). The dimension of the resulting
model will be <code>nVar = sum(nS)</code>.</p>
</td></tr>
<tr><td><code id="findAllSets_+3A_npmin">nPmin</code></td>
<td>
<p>Corresponds to the minimum number of parameters (and thus
of polynomial term) allowed.</p>
</td></tr>
<tr><td><code id="findAllSets_+3A_npmax">nPmax</code></td>
<td>
<p>Corresponds to the maximum number of parameters (and thus
of polynomial) allowed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SetsNp A list of two matrices
$Sets A matrix defining all the sets the equation combination
(each line provides a combination, for instance, a line with 1,2,2
means the first equation of allFilt$X1, the second one of allFilt$X2
and the second one of allFilt$X3)
$Np  A matrix providing the number of parameters of all equation
combination (each line provides the number of parameter of the selected
equations)
</p>


<h3>Author(s)</h3>

<p>Sylvain Mangiarotti
</p>


<h3>See Also</h3>

<p><code><a href="#topic+autoGPoMoSearch">autoGPoMoSearch</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############
# Example 1 #
#############
# We build an example
allFilt &lt;- list()
# For equation 1 (variable X1)
allFilt$Np1 &lt;- 1         # only one formulation with one single parameter
# For equation 2 (variable X2)
allFilt$Np2 &lt;- c(3, 2)   # two potential formulations, with respectively three and four parameters
# For equation 3 (variable X3)
allFilt$Np3 &lt;- c(4, 2)   # two potential formulations, with respectively two and four parameters
# Formulations for variables Xi:
# For X1:
allFilt$X1 &lt;- t(as.matrix(c(0,0,0,1,0,0,0,0,0,0)))
# For X2:
allFilt$X2 &lt;- t(matrix(c(0,-0.85,0,-0.27,0,0,0,0.46,0,0,
                         0,-0.64,0,0,0,0,0,0.43,0,0),
                       ncol=2, nrow=10))
# For X3:
allFilt$X3 &lt;- t(matrix(c(0, 0.52,  0, -1.22e-05,  0, 0, 0.99, 5.38e-05, 0, 0,
                         0, 0.52, 0, 0, 0, 0, 0.99, 0, 0, 0),
                       ncol=2, nrow=10))
# From these individual we can retrieve all possible formulations
findAllSets(allFilt, nS=c(3), nPmin=1, nPmax=14)
# if only formulations with seven maximum number of terms are expected:
findAllSets(allFilt, nS=c(3), nPmin=1, nPmax=7)

</code></pre>

<hr>
<h2 id='gloMoId'>Global Model Identification</h2><span id='topic+gloMoId'></span>

<h3>Description</h3>

<p>Algorithm for global modelling in
polynomial and canonical formulation of Ordinary
Differential Equations.
Univariate Global modeling aims to obtain multidimensional
models from single time series (Gouesbet &amp; Letellier 1994,
Mangiarotti et al. 2012).
An example of such application can be found in
Mangiarotti et al. (2014)
For a multivariate application, see <code>GPoMo</code>
(Mangiarotti 2015, Mangiarotti et al. 2016).
</p>
<p>Example:<br />
For a model dimension nVar=3, the global model will read: <br />
<code class="reqn">dX1/dt = X2</code><br />
<code class="reqn">dX2/dt = X3</code><br />
<code class="reqn">dX3/dt = P(X1,X2,X3).</code><br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gloMoId(
  series,
  tin = NULL,
  dt = NULL,
  nVar = NULL,
  dMax = 1,
  dMin = 0,
  weight = NULL,
  show = 1,
  filterReg = NULL,
  winL = 9
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gloMoId_+3A_series">series</code></td>
<td>
<p>The original data set: either a single vector
corresponding to the original variable; Or a matrix containing
the original variable in the first column and its successive
derivatives in the next columns. In the latter case, for the
construction of n-dimensional model, <code>series</code> should have
<code class="reqn">nVar+1</code> columns since one more derivative will be necessary
to identify the model parameters. Variable <code>nVar</code> will be set
equal to n.
In the former case, that is when only a single vector is provided,
the derivatives will be automatically recomputed. Therefore, the
dimension nVar expected for the model has to be provided.</p>
</td></tr>
<tr><td><code id="gloMoId_+3A_tin">tin</code></td>
<td>
<p>Input date vector which length should correspond to
the input time series.</p>
</td></tr>
<tr><td><code id="gloMoId_+3A_dt">dt</code></td>
<td>
<p>Sampling time of the input time series.</p>
</td></tr>
<tr><td><code id="gloMoId_+3A_nvar">nVar</code></td>
<td>
<p>Number of variables considered in the polynomial formulation.</p>
</td></tr>
<tr><td><code id="gloMoId_+3A_dmax">dMax</code></td>
<td>
<p>Maximum degree of the polynomial formulation.</p>
</td></tr>
<tr><td><code id="gloMoId_+3A_dmin">dMin</code></td>
<td>
<p>The minimum negative degree of the polynomial
formulation (0 by default).</p>
</td></tr>
<tr><td><code id="gloMoId_+3A_weight">weight</code></td>
<td>
<p>A vector providing the binary weighting function
of the input data series (0 or 1). By default, all the values
are set to 1.</p>
</td></tr>
<tr><td><code id="gloMoId_+3A_show">show</code></td>
<td>
<p>Provide (2) or not (0-1) visual output during
the running process.</p>
</td></tr>
<tr><td><code id="gloMoId_+3A_filterreg">filterReg</code></td>
<td>
<p>A vector that specifies the template for
the equation structure (for one single equation).
The convention defined by <code>poLabs</code> is used.
Value is 1 if the regressor is available, 0 if it is not.</p>
</td></tr>
<tr><td><code id="gloMoId_+3A_winl">winL</code></td>
<td>
<p>Total number of points used for computing the derivatives
of the input time series. This parameter will be used as an
input in function <code>drvSucc</code> to compute the derivatives.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>A</code> list of five elements : <br />
</p>
<p><code>$init</code> The original time series and the successive derivatives used
for the modeling. <br />
</p>
<p><code>$filterReg</code>	The structure of the output model. Value is 1 if the
regressor is available, 0 if it is not. The terms order is
given by function <code>poLabs</code>. <br />
</p>
<p><code>$K</code>	Values of the identified coefficients corresponding to
the regressors defined in <code>filterReg</code>. <br />
</p>
<p><code>$resTot</code> The variance of the residual signal of the model. <br />
</p>
<p><code>$resSsMod</code> The variance of the residual signal of the closer submodels. <br />
</p>
<p><code>$finalWeight</code> Weighting series after boundary values
were removed. <br />
</p>


<h3>Author(s)</h3>

<p>Sylvain Mangiarotti, Laurent Drapeau, Mireille Huc
</p>


<h3>References</h3>

<p>[1] Gouesbet G., Letellier C.,
Global vector-field reconstruction by using a multivariate polynomial
L2 approximation on nets,
Physical Review E, 49 (6), 4955-4972, 1994. <br />
[2] Mangiarotti S., Coudret R., Drapeau L., &amp; Jarlan L.,
Polynomial search and global modeling : Two algorithms for modeling chaos,
Physical Review E, 86, 046205, 2012. <br />
[3] Mangiarotti S., Drapeau L. &amp; Letellier C.,
Two chaotic models for cereal crops observed from satellite in northern Morocco.
Chaos, 24(2), 023130, 2014. <br />
[4] Mangiarotti S.,
Low dimensional chaotic models for the plague epidemic in Bombay (1896-1911),
Chaos, Solitons &amp; Fractals, 81(A), 184-196, 2015. <br />
[5] Mangiarotti S., Peyre M. &amp; Huc M.,
A chaotic model for the epidemic of Ebola Virus Disease in West Africa (2013-2016).
Chaos, 26, 113112, 2016. <br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gPoMo">gPoMo</a></code>, <code><a href="#topic+autoGPoMoSearch">autoGPoMoSearch</a></code>,
<code><a href="#topic+autoGPoMoTest">autoGPoMoTest</a></code>, <code><a href="#topic+poLabs">poLabs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#############
# Example 1 #
#############
# load data
data("Ross76")
tin &lt;- Ross76[,1]
data &lt;- Ross76[,2:3]

# Polynomial identification
reg &lt;- gloMoId(data[0:500,2], dt=1/100, nVar=2, dMax=2, show=0)

#############
# Example 2 #
#############
# load data
data(NDVI)

# Definition of the Model structure
terms &lt;- c(1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1)
poLabs(3,3)[terms==1]
reg &lt;- gloMoId(NDVI [,1:1], dt=1/125, nVar=3, dMax=3,
               show=0, filterReg=terms==1)



#############
# Example 3 #
#############
# load data
data("Ross76")
# time vector
tin &lt;- Ross76[1:500,1]
# single time series
series &lt;- Ross76[1:500,3]
# some noise is added
series[1:100] &lt;- series[1:100] + 0.01 * runif(1:100, min = -1, max = 1)
series[301:320] &lt;- series[301:320] + 0.05 * runif(1:20, min = -1, max = 1)
# weighting function
W &lt;- tin * 0 + 1
W[1:100] &lt;- 0  # the first hundred values will not be considered
W[301:320] &lt;- 0  # twenty other values will not be considered either
reg &lt;- gloMoId(series, dt=1/100, weight = W, nVar=3, dMax=2, show=1)
visuEq(reg$K, 3, 2, approx = 4)
# first weight which value not equal to zero:
i1 = which(reg$finalWeight == 1)[1]
v0 &lt;-  reg$init[i1,1:3]

reconstr &lt;- numicano(nVar=3, dMax=2, Istep=5000, onestep=1/250, PolyTerms=reg$K,
                     v0=v0, method="ode45")
plot(reconstr$reconstr[,2], reconstr$reconstr[,3], type='l', lwd = 3,
                            main='phase portrait', xlab='time t', ylab = 'x(t)', col='orange')
# original data:
lines(reg$init[,1], reg$init[,2], type='l',
      main='phase portrait', xlab='x', ylab = 'dx/dt', col='black')
# initial condition
lines(v0[1], v0[2], type = 'p', col = 'red')


</code></pre>

<hr>
<h2 id='gPoMo'>Generalized Polynomial Modeling</h2><span id='topic+gPoMo'></span>

<h3>Description</h3>

<p>Algorithm for a Generalized Polynomial formulation
of multivariate Global Modeling.
Global modeling aims to obtain multidimensional models
from single time series [1-2].
In the generalized (polynomial) formulation provided in this
function, it can also be applied to multivariate time series [3-4].
</p>
<p>Example:<br />
Note that <code>nS</code> provides the number of dimensions used from each variable
</p>
<p>case I <br />
For <code>nS=c(2,3)</code> means that 2 dimensions are reconstructed from variable 1:
the original variable <code>X1</code> and its first derivative <code>X2</code>), and
3 dimensions are reconstructed from variable 2: the original
variable <code>X3</code> and its first and second derivatives <code>X4</code> and <code>X5</code>.
The generalized model will thus be such as: <br />
<code class="reqn">dX1/dt = X2</code><br />
<code class="reqn">dX2/dt = P1(X1,X2,X3,X4,X5)</code><br />
<code class="reqn">dX3/dt = X4</code><br />
<code class="reqn">dX4/dt = X5</code><br />
<code class="reqn">dX5/dt = P2(X1,X2,X3,X4,X5).</code><br />
</p>
<p>case II<br />
For <code>nS=c(1,1,1,1)</code> means that only the original variables
<code>X1</code>, <code>X2</code>, <code>X3</code> and <code>X4</code> will be used.
The generalized model will thus be such as:<br />
<code class="reqn">dX1/dt = P1(X1,X2,X3,X4)</code><br />
<code class="reqn">dX2/dt = P2(X1,X2,X3,X4)</code><br />
<code class="reqn">dX3/dt = P3(X1,X2,X3,X4)</code><br />
<code class="reqn">dX4/dt = P4(X1,X2,X3,X4).</code><br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gPoMo(
  data,
  tin = NULL,
  dtFixe = NULL,
  dMax = 2,
  dMin = 0,
  nS = c(3),
  winL = 9,
  weight = NULL,
  show = 1,
  verbose = 1,
  underSamp = NULL,
  EqS = NULL,
  AndManda = NULL,
  OrMandaPerEq = NULL,
  IstepMin = 2,
  IstepMax = 2000,
  nPmin = 1,
  nPmax = 14,
  tooFarThr = 4,
  FxPtThr = 1e-08,
  LimCyclThr = 1e-06,
  nPminPerEq = 1,
  nPmaxPerEq = NULL,
  method = "rk4"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gPoMo_+3A_data">data</code></td>
<td>
<p>Input Time series: Each column is one time series
that corresponds to one variable.</p>
</td></tr>
<tr><td><code id="gPoMo_+3A_tin">tin</code></td>
<td>
<p>Input date vector which length should correspond to
the input time series.</p>
</td></tr>
<tr><td><code id="gPoMo_+3A_dtfixe">dtFixe</code></td>
<td>
<p>Time step used for the analysis. It should correspond
to the sampling time of the input data.
Note that for very large and very small time steps, alternative units
may be used in order to stabilize the numerical computation.</p>
</td></tr>
<tr><td><code id="gPoMo_+3A_dmax">dMax</code></td>
<td>
<p>Maximum degree of the polynomial formulation.</p>
</td></tr>
<tr><td><code id="gPoMo_+3A_dmin">dMin</code></td>
<td>
<p>The minimum negative degree of the polynomial
formulation (0 by default).</p>
</td></tr>
<tr><td><code id="gPoMo_+3A_ns">nS</code></td>
<td>
<p>A vector providing the number of dimensions used for each
input variables (see Examples 1 and 2). The dimension of the resulting
model will be <code>nVar = sum(nS)</code>.</p>
</td></tr>
<tr><td><code id="gPoMo_+3A_winl">winL</code></td>
<td>
<p>Total number of points used for computing the derivatives
of the input time series. This parameter will be used as an
input in function <code>drvSucc</code> to compute the derivatives.</p>
</td></tr>
<tr><td><code id="gPoMo_+3A_weight">weight</code></td>
<td>
<p>A vector providing the binary weighting function
of the input data series (0 or 1). By default, all the values
are set to 1.</p>
</td></tr>
<tr><td><code id="gPoMo_+3A_show">show</code></td>
<td>
<p>Provide (2) or not (0-1) visual output during
the running process.</p>
</td></tr>
<tr><td><code id="gPoMo_+3A_verbose">verbose</code></td>
<td>
<p>Gives information (if set to 1) about the algorithm
progress and keeps silent if set to 0.</p>
</td></tr>
<tr><td><code id="gPoMo_+3A_undersamp">underSamp</code></td>
<td>
<p>Number of points used for undersampling the data.
For <code>undersamp = 1</code> the complete time series is used.
For <code>undersamp = 2</code>, only one data out of two is kept, etc.</p>
</td></tr>
<tr><td><code id="gPoMo_+3A_eqs">EqS</code></td>
<td>
<p>Model template including all allowed regressors.
Each column corresponds to one equation. Each line corresponds to one
polynomial term as defined by function <code>poLabs</code>.</p>
</td></tr>
<tr><td><code id="gPoMo_+3A_andmanda">AndManda</code></td>
<td>
<p>AND-mandatory terms in the equations (all the provided
terms should be in the equations).</p>
</td></tr>
<tr><td><code id="gPoMo_+3A_ormandapereq">OrMandaPerEq</code></td>
<td>
<p>OR-mandatory terms per equations (at least one of
the provided terms should be in each equation).</p>
</td></tr>
<tr><td><code id="gPoMo_+3A_istepmin">IstepMin</code></td>
<td>
<p>The minimum number of integration step to start
of the analysis (by default <code>IstepMin = 10</code>).</p>
</td></tr>
<tr><td><code id="gPoMo_+3A_istepmax">IstepMax</code></td>
<td>
<p>The maximum number of integration steps for
stopping the analysis (by default <code>IstepMax = 10000</code>).</p>
</td></tr>
<tr><td><code id="gPoMo_+3A_npmin">nPmin</code></td>
<td>
<p>Corresponds to the minimum number of parameters (and thus
of polynomial term) allowed.</p>
</td></tr>
<tr><td><code id="gPoMo_+3A_npmax">nPmax</code></td>
<td>
<p>Corresponds to the maximum number of parameters (and thus
of polynomial) allowed.</p>
</td></tr>
<tr><td><code id="gPoMo_+3A_toofarthr">tooFarThr</code></td>
<td>
<p>Divergence threshold, maximum value
of the model trajectory compared to the data standard
deviation. By default a trjactory is too far if
the distance to the center is larger than four times the variance
of the input data.</p>
</td></tr>
<tr><td><code id="gPoMo_+3A_fxptthr">FxPtThr</code></td>
<td>
<p>Threshold used to detect fixed points.</p>
</td></tr>
<tr><td><code id="gPoMo_+3A_limcyclthr">LimCyclThr</code></td>
<td>
<p>Threshold used to detect the limit cycle.</p>
</td></tr>
<tr><td><code id="gPoMo_+3A_npminpereq">nPminPerEq</code></td>
<td>
<p>Corresponds to the minimum number of parameters (and thus
of polynomial term) allowed per equation.</p>
</td></tr>
<tr><td><code id="gPoMo_+3A_npmaxpereq">nPmaxPerEq</code></td>
<td>
<p>Corresponds to the maximum number of parameters (and thus
of polynomial) allowed per equation.</p>
</td></tr>
<tr><td><code id="gPoMo_+3A_method">method</code></td>
<td>
<p>The integration technique used for the numerical
integration. By default, the fourth-order Runge-Kutta method
(<code>method = 'rk4'</code>) is used. Other methods such as 'ode45'
or 'lsoda' may also be chosen. See package <code>deSolve</code>
for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>
<p><code>$tin</code>        The time vector of the input time series
</p>
<p><code>$inputdata</code>  The input time series
</p>
<p><code>$tfiltdata</code>  The time vector of the filtered time series (boudary removed)
</p>
<p><code>$filtdata</code>   A matrix of the filtered time series with its derivatives
</p>
<p><code>$okMod</code>      A vector classifying the models: diverging models (0), periodic
models of period-1 (-1), unclassified models (1).
</p>
<p><code>$coeff</code>      A matrix with the coefficients of one selected model
</p>
<p><code>$models</code>     A list of all the models to be tested <code>$mToTest1</code>,
<code>$mToTest2</code>, etc. and all selected models <code>$model1</code>, <code>$model2</code>, etc.
</p>
<p><code>$tout</code>       The time vector of the output time series (vector length
corresponding to the longest numerical integration duration)
</p>
<p><code>$stockoutreg</code> A list of matrices with the integrated trajectories
(variable <code>X1</code> in column 1, <code>X2</code> in 2, etc.) of all the models <code>$model1</code>,
<code>$model2</code>, etc.
</p>


<h3>Author(s)</h3>

<p>Sylvain Mangiarotti, Flavie Le Jean, Mireille Huc
</p>


<h3>References</h3>

<p>[1] Gouesbet G. &amp; Letellier C., 1994. Global vector-field reconstruction by using a
multivariate polynomial L2 approximation on nets, Physical Review E, 49 (6),
4955-4972. <br />
[2] Mangiarotti S., Coudret R., Drapeau L. &amp; Jarlan L., Polynomial search and
Global modelling: two algorithms for modeling chaos. Physical Review E, 86(4),
046205. <br />
[3] Mangiarotti S., Le Jean F., Huc M. &amp; Letellier C., Global Modeling of aggregated
and associated chaotic dynamics. Chaos, Solitons and Fractals, 83, 82-96. <br />
[4] S. Mangiarotti, M. Peyre &amp; M. Huc, 2016.
A chaotic model for the epidemic of Ebola virus disease
in West Africa (2013-2016). Chaos, 26, 113112. <br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gloMoId">gloMoId</a></code>, <code><a href="#topic+autoGPoMoSearch">autoGPoMoSearch</a></code>,
<code><a href="#topic+autoGPoMoTest">autoGPoMoTest</a></code>
</p>
<p><code><a href="#topic+autoGPoMoSearch">autoGPoMoSearch</a></code>, <code><a href="#topic+autoGPoMoTest">autoGPoMoTest</a></code>, <code><a href="#topic+visuOutGP">visuOutGP</a></code>,
<code><a href="#topic+poLabs">poLabs</a></code>, <code><a href="#topic+predictab">predictab</a></code>, <code><a href="#topic+drvSucc">drvSucc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Example 1
data("Ross76")
tin &lt;- Ross76[,1]
data &lt;- Ross76[,3]
dev.new()
out1 &lt;- gPoMo(data, tin = tin, dMax = 2, nS=c(3), show = 1,
              IstepMax = 1000, nPmin = 9, nPmax = 11)
visuEq(out1$models$model1, approx = 4)



#Example 2
data("Ross76")
tin &lt;- Ross76[,1]
data &lt;- Ross76[,3]
# if some data are not valid (vector 'weight' with zeros)
W &lt;- tin * 0 + 1
W[1:100] &lt;- 0
W[700:1500] &lt;- 0
W[2000:2800] &lt;- 0
W[3000:3500] &lt;- 0
dev.new()
out2 &lt;- gPoMo(data, tin = tin, weight = W,
                 dMax = 2, nS=c(3), show = 1,
                 IstepMax = 6000, nPmin = 9, nPmax = 11)
visuEq(out2$models$model3, approx = 4)




#Example 3
data("Ross76")
tin &lt;- Ross76[,1]
data &lt;- Ross76[,2:4]
dev.new()
out3 &lt;- gPoMo(data, tin=tin, dMax = 2, nS=c(1,1,1), show = 1,
              IstepMin = 10, IstepMax = 3000, nPmin = 7, nPmax = 8)
# the simplest model able to reproduce the observed dynamics is model #5
visuEq(out3$models$model5, approx = 3, substit = 1) # the original Rossler system is thus retrieved



#Example 4
data("Ross76")
tin &lt;- Ross76[,1]
data &lt;- Ross76[,2:3]
# model template:
EqS &lt;- matrix(1, ncol = 3, nrow = 10)
EqS[,1] &lt;- c(0,0,0,1,0,0,0,0,0,0)
EqS[,2] &lt;- c(1,1,0,1,0,1,1,1,1,1)
EqS[,3] &lt;- c(0,1,0,0,0,0,1,1,0,0)
visuEq(EqS, substit = c('X','Y','Z'))
dev.new()
out4 &lt;- gPoMo(data, tin=tin, dMax = 2, nS=c(2,1), show = 1,
      EqS = EqS, IstepMin = 10, IstepMax = 2000,
      nPmin = 9, nPmax = 11)
visuEq(out4$models$model2, approx = 2, substit = c("Y","Y2","Z"))



#Example 5
# load data
data("TSallMod_nVar3_dMax2")
#multiple (six) time series
tin &lt;- TSallMod_nVar3_dMax2$SprK$reconstr[1:400,1]
TSRo76 &lt;- TSallMod_nVar3_dMax2$R76$reconstr[,2:4]
TSSprK &lt;- TSallMod_nVar3_dMax2$SprK$reconstr[,2:4]
data &lt;- cbind(TSRo76,TSSprK)[1:400,]
dev.new()
# generalized Polynomial modelling
out5 &lt;- gPoMo(data, tin = tin, dMax = 2, nS = c(1,1,1,1,1,1),
              show = 0, method = 'rk4',
              IstepMin = 2, IstepMax = 3,
              nPmin = 13, nPmax = 13)

# the original Rossler (variables x, y and z) and Sprott (variables u, v and w)
# systems are retrieved:
visuEq(out5$models$model347, approx = 4,
       substit = c('x', 'y', 'z', 'u', 'v', 'w'))
# to check the robustness of the model, the integration duration
# should be chosen longer (at least IstepMax = 4000)


</code></pre>

<hr>
<h2 id='GSproc'>Gram-Schmidt procedure</h2><span id='topic+GSproc'></span>

<h3>Description</h3>

<p>Computes regressors coefficients
using the Gram-Schmidt procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GSproc(polyK, ivec, weight = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GSproc_+3A_polyk">polyK</code></td>
<td>
<p>One list including <code>$Y</code> and <code>$phy</code> with:
<code>$Y</code> a matrix for which the ith column will be used
to add one orthogonal vector to the (i-1)th vectors of the
current orthogonal base;
and <code>$phy</code> such as the current orthogonal base is
given by the (i-1)th first columns of matrix <code>polyK$phy</code>.</p>
</td></tr>
<tr><td><code id="GSproc_+3A_ivec">ivec</code></td>
<td>
<p>Defines i, the current vector of <code>polyK$Y</code> and
the current orthogonal base of <code>pParam$phy</code>.</p>
</td></tr>
<tr><td><code id="GSproc_+3A_weight">weight</code></td>
<td>
<p>The weighing vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>uNew</code> The model parameterization, that is:
The residual orthogonal vector that can be included into
the current orthogonal base. If the current base is empty,
<code>uNew</code> is equal to the input vector of <code>$Y</code>;
if the base is complete, <code>uNew</code> equals 0.
</p>


<h3>Author(s)</h3>

<p>Sylvain Mangiarotti
</p>

<hr>
<h2 id='NDVI'>A time series of vegetation index measured from satellite</h2><span id='topic+NDVI'></span>

<h3>Description</h3>

<p>A time series of 28 years of Normalized
Difference Vegetation Index measured from space by
the Advanced Very High Resolution Radiometer (AVHRR)
sensor from 1982 to 2008 (see reference [1] for details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NDVI
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 1000 rows and 4 columns.
</p>


<h3>Author(s)</h3>

<p>Sylvain Mangiarotti, Flavie Le Jean
</p>


<h3>References</h3>

<p>[1] Mangiarotti S., Drapeau L. &amp; Letellier C., 2014.
Two chaotic models for cereal crops observed from satellite in 
northern Morocco.<br />
</p>

<hr>
<h2 id='numicano'>Numerical Integration of models in ODE of polynomial form</h2><span id='topic+numicano'></span>

<h3>Description</h3>

<p>Function for the numerical integration
of Ordinary Differential Equations of polynomial form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>numicano(
  nVar,
  dMax,
  dMin = 0,
  Istep = 1000,
  onestep = 1/125,
  KL = NULL,
  PolyTerms = NULL,
  v0 = NULL,
  method = "rk4"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="numicano_+3A_nvar">nVar</code></td>
<td>
<p>Number of variables considered in the polynomial formulation.</p>
</td></tr>
<tr><td><code id="numicano_+3A_dmax">dMax</code></td>
<td>
<p>Maximum degree of the polynomial formulation.</p>
</td></tr>
<tr><td><code id="numicano_+3A_dmin">dMin</code></td>
<td>
<p>The minimum negative degree of the polynomial
formulation (0 by default).</p>
</td></tr>
<tr><td><code id="numicano_+3A_istep">Istep</code></td>
<td>
<p>The number of integration time steps</p>
</td></tr>
<tr><td><code id="numicano_+3A_onestep">onestep</code></td>
<td>
<p>Time step length</p>
</td></tr>
<tr><td><code id="numicano_+3A_kl">KL</code></td>
<td>
<p>Matrix formulation of the model to integrate numerically</p>
</td></tr>
<tr><td><code id="numicano_+3A_polyterms">PolyTerms</code></td>
<td>
<p>Vectorial formulation of the model (only for models
of canonical form)</p>
</td></tr>
<tr><td><code id="numicano_+3A_v0">v0</code></td>
<td>
<p>The initial conditions (a vector which length should correspond
to the model dimension <code>nVar</code>)</p>
</td></tr>
<tr><td><code id="numicano_+3A_method">method</code></td>
<td>
<p>The integration method (See package <code>deSolve</code>),
by default <code>method = 'rk4'</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two variables: <br />
</p>
<p><code>$KL</code> The model in its matrix formulation <br />
</p>
<p><code>$reconstr</code> The integrated trajectory (first column is the time,
next columns are the model variables)
</p>


<h3>Author(s)</h3>

<p>Sylvain Mangiarotti
</p>


<h3>See Also</h3>

<p><code><a href="#topic+derivODE2">derivODE2</a></code>, <code><a href="#topic+numinoisy">numinoisy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############
# Example 1 #
#############
# For a model of general form (here the rossler model)
# model dimension:
nVar = 3
# maximal polynomial degree
dMax = 2
# Number of parameter number (by default)
pMax &lt;- d2pMax(nVar, dMax)
# convention used for the model formulation
poLabs(nVar, dMax)
# Definition of the Model Function
a = 0.520
b = 2
c = 4
Eq1 &lt;- c(0,-1, 0,-1, 0, 0, 0, 0, 0, 0)
Eq2 &lt;- c(0, 0, 0, a, 0, 0, 1, 0, 0, 0)
Eq3 &lt;- c(b,-c, 0, 0, 0, 0, 0, 1, 0, 0)
K &lt;- cbind(Eq1, Eq2, Eq3)
# Edition of the equations
visuEq(K, nVar, dMax)
# initial conditions
v0 &lt;- c(-0.6, 0.6, 0.4)
# model integration
reconstr &lt;- numicano(nVar, dMax, Istep=1000, onestep=1/50, KL=K,
                      v0=v0, method="ode45")
# Plot of the simulated time series obtained
dev.new()
plot(reconstr$reconstr[,2], reconstr$reconstr[,3], type='l',
      main='phase portrait', xlab='x(t)', ylab = 'y(t)')


#############
# Example 2 #
#############
# For a model of canonical form
# model dimension:
nVar = 4
# maximal polynomial degree
dMax = 3
# Number of parameter number (by default)
pMax &lt;- d2pMax(nVar, dMax)
# Definition of the Model Function
PolyTerms &lt;- c(281000, 0, 0, 0, -2275, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
               861, 0, 0, 0, -878300, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
# terms used in the model
poLabs(nVar, dMax, findIt=(PolyTerms!=0))
# initial conditions
v0 &lt;- c(0.54, 3.76, -90, -5200)
# model integration
reconstr &lt;- numicano(nVar, dMax, Istep=500, onestep=1/250, PolyTerms=PolyTerms,
                     v0=v0, method="ode45")
# Plot of the simulated time series obtained
plot(reconstr$reconstr[,2], reconstr$reconstr[,3], type='l',
     main='phase portrait', xlab='x', ylab = 'dx/dt')
# Edition of the equations
visuEq(reconstr$KL, nVar, dMax)





#############
# Example 3 #
#############
# For a model of general form (here the rossler model)
# model dimension:
nVar = 3
# maximal polynomial degree
dMax = 2
dMin = -1
# Number of parameter number (by default)
pMax &lt;- regOrd(nVar, dMax, dMin)[2]
# convention used for the model formulation
poLabs(nVar, dMax, dMin)
# Definition of the Model Function
a = 0.520
b = 2
c = 4
Eq1 &lt;- c(0,-1, 0,-1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0)
Eq2 &lt;- c(0, 0, 0, a, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0)
Eq3 &lt;- c(b,-c, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0)
K &lt;- cbind(Eq1, Eq2, Eq3)
# Edition of the equations
#visuEq(K, nVar, dMax)
# initial conditions
v0 &lt;- c(-0.6, 0.6, 0.4)
# model integration
reconstr &lt;- numicano(nVar, dMax, dMin, Istep=1000, onestep=1/50, KL=K,
                      v0=v0, method="ode45")
# Plot of the simulated time series obtained
dev.new()
plot(reconstr$reconstr[,2], reconstr$reconstr[,3], type='l',
      main='phase portrait', xlab='x(t)', ylab = 'y(t)')



</code></pre>

<hr>
<h2 id='numiMultiX'>Numerical Integration polynomial ODEs with Multiple eXternal forcing</h2><span id='topic+numiMultiX'></span>

<h3>Description</h3>

<p>Function for the numerical integration
of Ordinary Differential Equations of polynomial form
including single or Multiple external forcing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>numiMultiX(
  nVar,
  dMax,
  Istep = 1000,
  onestep = 1/125,
  KDf,
  extF = extF,
  v0 = NULL,
  method = "rk4"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="numiMultiX_+3A_nvar">nVar</code></td>
<td>
<p>Number of variables considered in the polynomial formulation.</p>
</td></tr>
<tr><td><code id="numiMultiX_+3A_dmax">dMax</code></td>
<td>
<p>Maximum degree of the polynomial formulation.</p>
</td></tr>
<tr><td><code id="numiMultiX_+3A_istep">Istep</code></td>
<td>
<p>The number of integration time steps. By default,
Istep = 1000</p>
</td></tr>
<tr><td><code id="numiMultiX_+3A_onestep">onestep</code></td>
<td>
<p>The time step to be used for numerical integration</p>
</td></tr>
<tr><td><code id="numiMultiX_+3A_kdf">KDf</code></td>
<td>
<p>The nonautonomous model in its matrix formulation,
NA (i.e. not available) values should be provided for forcing
variables provided as an external signal</p>
</td></tr>
<tr><td><code id="numiMultiX_+3A_extf">extF</code></td>
<td>
<p>A matrix providing the time vector in the first column,
and time series of each forcing in the next ones</p>
</td></tr>
<tr><td><code id="numiMultiX_+3A_v0">v0</code></td>
<td>
<p>The initial conditions. Its length should be in agreement
with the dynamical system dimension. Therefore, 0 or NA can be
provided for external forcing</p>
</td></tr>
<tr><td><code id="numiMultiX_+3A_method">method</code></td>
<td>
<p>integration method. By default 'rk4' is used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two variables: <br />
</p>
<p><code>$KDf</code> The nonautonomous model in its matrix formulation <br />
</p>
<p><code>$reconstr</code> The integrated trajectory (first column is the time,
next columns are the model variables)
</p>


<h3>Author(s)</h3>

<p>Sylvain Mangiarotti
</p>


<h3>See Also</h3>

<p><code><a href="#topic+derivODE2">derivODE2</a></code>, <code><a href="#topic+numicano">numicano</a></code>, <code><a href="#topic+numinoisy">numinoisy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############
# Example 1 #
#############
# build a non autonomous model
nVar = 4
dMax = 3
gamma = 0.05
KDf=matrix(0, nrow = d2pMax(nVar = nVar, dMax = dMax), ncol = nVar)
KDf[11,1]  = 1
KDf[2,2]  = 1
KDf[5,2]  = 1
KDf[11,2]  = -gamma
KDf[35,2] = -1
KDf[2,3]  = NA
KDf[2,4]  = NA
visuEq(K = KDf, substit = c('x', 'y', 'u', 'v'))

# build an external forcing
# number of integration time step
Istep &lt;- 500

# time step
smpl &lt;- 1 / 20

# output time vector
tvec &lt;- (0:(Istep-1)) * smpl

# angular frequency (for periodic forcing)
omega = 0.2

# half step time vector (for Runge-Kutta integration)
tvecX &lt;- (0:(Istep*2-2)) * smpl / 2
# generate the forcing (here variables u and v)
extF = cbind(tvecX, -0.1 * cos(tvecX * omega), 0.05 * cos(tvecX * 16/3*omega))

# decimate the data
extFrs &lt;- extF[seq(1,dim(extF)[1],by=50),]
extFrs &lt;- rbind(extFrs,extF[dim(extF)[1],])

# Initial conditions to be used (external variables can be set to 0)
etatInit &lt;- c(-0.616109362 , -0.126882584 , NA, NA)
# model integration
out &lt;- numiMultiX(nVar, dMax, Istep=Istep, onestep=smpl, KDf=KDf,
                       extF,
                       v0=etatInit, method="rk4")
outrs &lt;- numiMultiX(nVar, dMax, Istep=Istep, onestep=smpl, KDf=KDf,
                       extFrs,
                       v0=etatInit, method="rk4")
dev.new
oldpar &lt;- par(no.readonly = TRUE)    
on.exit(par(oldpar))  
par(mfrow = c(2, 2), # 2 x 2 pictures on one plot
    pty = "s")
plot(out$reconstr[,2],out$reconstr[,3],
    xlab = 'x(t)', ylab = 'y(t)', type = 'l', col = 'red')
lines(outrs$reconstr[,2],outrs$reconstr[,3],
    xlab = 'x(t)', ylab = 'y(t)', type = 'l', col = 'green')
plot(out$reconstr[,2],out$reconstr[,4],
    xlab = 'x(t)', ylab = 'u(t)', type = 'l', col = 'red')
plot(out$reconstr[,4],out$reconstr[,5],
    xlab = 'u(t)', ylab = 'v(t)', type = 'l', col = 'red')

</code></pre>

<hr>
<h2 id='numinoisy'>Generates time series of deterministic-behavior
with stochatic perturbations (measurement and/or dynamical noise)</h2><span id='topic+numinoisy'></span>

<h3>Description</h3>

<p>Generates time series from Ordinary Differential Equations
perturbed by dynamical and/or measurement noises
</p>


<h3>Usage</h3>

<pre><code class='language-R'>numinoisy(
  x0,
  t,
  K,
  varData = NULL,
  txVarBruitA = NULL,
  txVarBruitM = NULL,
  varBruitA = NULL,
  varBruitM = NULL,
  taux = NULL,
  freq = NULL,
  variables = NULL,
  method = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="numinoisy_+3A_x0">x0</code></td>
<td>
<p>The initial conditions. Should be a vector which size must be equal
to the model dimension <code>dim(K)[2]</code> (the number of variables of the
model defined by matrix <code>K</code>).</p>
</td></tr>
<tr><td><code id="numinoisy_+3A_t">t</code></td>
<td>
<p>A vector providing all the dates for which the output are expected.</p>
</td></tr>
<tr><td><code id="numinoisy_+3A_k">K</code></td>
<td>
<p>The Ordinary Differential Equations used to model the dynamics.
The number of column should correspond to the number of variables, the
number of lines to the number of parameters following the convention
defined by <code>poLabs(nVar,dMax)</code>.</p>
</td></tr>
<tr><td><code id="numinoisy_+3A_vardata">varData</code></td>
<td>
<p>A vector of size <code>nVar</code> providing the caracteristic
variances of each variable of the dynamical systems in ODE defined
by matrix <code>K</code>.
If not provided, this variance is automatically estimated.</p>
</td></tr>
<tr><td><code id="numinoisy_+3A_txvarbruita">txVarBruitA</code></td>
<td>
<p>A vector defining the ratio of ADDITIVE noise
for each variable of the dynamical system in ODE. The additive noise is
added at the end of the numerical integration process. The ratio is
defined relatively to the signal variance of each variable.</p>
</td></tr>
<tr><td><code id="numinoisy_+3A_txvarbruitm">txVarBruitM</code></td>
<td>
<p>A vector defining the ratio of DYNAMICAL
noise for each variable of the dynamical system in ODE. This
noise is a perturbation added at each numerical integration step. The
ratio is defined relatively to the signal variance of each variable.</p>
</td></tr>
<tr><td><code id="numinoisy_+3A_varbruita">varBruitA</code></td>
<td>
<p>A vector defining the variance of ADDITIVE noise
for each variable of the dynamical system in ODE. The additive noise is
added at the end of the numerical integration process.</p>
</td></tr>
<tr><td><code id="numinoisy_+3A_varbruitm">varBruitM</code></td>
<td>
<p>A vector defining the variance of DYNAMICAL
noise for each variable of the dynamical system in ODE. This
noise is a perturbation added at each numerical integration step.</p>
</td></tr>
<tr><td><code id="numinoisy_+3A_taux">taux</code></td>
<td>
<p>Generates random gaps in time series. Parameter <code>taux</code>
defines the ratio of data to be kept (e.g. for <code class="reqn">taux=0.75</code>, 75 percents
of the data are kept).</p>
</td></tr>
<tr><td><code id="numinoisy_+3A_freq">freq</code></td>
<td>
<p>Subsamples the time series. Parameter <code>freq</code> defines the
periodicity of data kept (e.g. for <code class="reqn">freq=3</code>, 1 data out of 3 is kept).</p>
</td></tr>
<tr><td><code id="numinoisy_+3A_variables">variables</code></td>
<td>
<p>Defines which variables must be generated.</p>
</td></tr>
<tr><td><code id="numinoisy_+3A_method">method</code></td>
<td>
<p>Defines the numerical integration method to be used.
The fourth-order Runge-Kutta method is used by default
(<code>method = 'rk4'</code>). Other method may be used (such as <code>'ode45'</code>
or <code>'lsoda'</code>), see function <code>ode</code> from package <code>deSolve</code>
for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two variables: <br />
</p>
<p><code>$donnees</code> The integrated trajectory (first column is the time,
next columns are the model variables) <br />
</p>
<p><code>$bruitM</code> The level of dynamical noise <br />
</p>
<p><code>$bruitA</code> The level of additive noise <br />
</p>
<p><code>$vectBruitM</code> The vector of the dynamical noise used to produce
the time series <br />
</p>
<p><code>$vectBruitA</code> The vector of the additive noise used to produce
the time series <br />
</p>
<p><code>$ecart_type</code> The level standard deviation <br />
</p>


<h3>Author(s)</h3>

<p>Sylvain Mangiarotti, Malika Chassan
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############
# Example 1 #
#############
# Rossler Model formulation
# The model dimension
nVar = 3
 # maximal polynomial degree
dMax = 2
a = 0.520
b = 2
c = 4
Eq1 &lt;- c(0,-1, 0,-1, 0, 0, 0, 0, 0, 0)
Eq2 &lt;- c(0, 0, 0, a, 0, 0, 1, 0, 0, 0)
Eq3 &lt;- c(b,-c, 0, 0, 0, 0, 0, 1, 0, 0)
K &lt;- cbind(Eq1, Eq2, Eq3)
# Edit the equations
visuEq(K, nVar, dMax)
# initial conditions
v0 &lt;- c(-0.6, 0.6, 0.4)
# output time required
timeOut = (0:800)/50
# variance of additive noise
varBruitA = c(0,0,0)^2
# variance of multiplitive noise
varBruitM = c(2E-2, 0, 2E-2)^2
# numerical integration with noise
intgr &lt;- numinoisy(v0, timeOut, K, varBruitA = varBruitA, varBruitM = varBruitM, freq = 1)
# Plot of the simulated time series obtained
dev.new()
plot(intgr$donnees[,2], intgr$donnees[,3], type='l',
      main='phase portrait', xlab='x(t)', ylab = 'y(t)')
dev.new()
oldpar &lt;- par(no.readonly = TRUE)    
on.exit(par(oldpar))  
par(mfrow = c(3, 1))
plot(intgr$donnees[,1], intgr$donnees[,2], type='l',
      main='phase portrait', xlab='x(t)', ylab = 'y(t)')
lines(intgr$donnees[,1], intgr$vectBruitM[,2]*10, type='l',
      main='phase portrait', xlab='x(t)', ylab = 'e(t)*10', col='red')
plot(intgr$donnees[,1], intgr$donnees[,3], type='l',
      main='phase portrait', xlab='x(t)', ylab = 'y(t)')
lines(intgr$donnees[,1], intgr$vectBruitM[,3]*10, type='l',
      main='phase portrait', xlab='x(t)', ylab = 'e(t)*10', col='red')
plot(intgr$donnees[,1], intgr$donnees[,4], type='l',
      main='phase portrait', xlab='x(t)', ylab = 'y(t)')
lines(intgr$donnees[,1], intgr$vectBruitM[,4]*10, type='l',
      main='phase portrait', xlab='x(t)', ylab = 'e(t)*10', col='red')

</code></pre>

<hr>
<h2 id='odeBruitMult2'>For the numerical integration of ordinary
differential equations with dynamical noise.</h2><span id='topic+odeBruitMult2'></span>

<h3>Description</h3>

<p>A subfunction for the numerical integration of Ordinary
Differential Equations provided in a generic polynomial form.
Model formulation follows the convention defined
by function <code>poLabs</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>odeBruitMult2(
  x0,
  t,
  K,
  varData = NULL,
  txVarBruitM = NULL,
  varBruitM = NULL,
  method = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="odeBruitMult2_+3A_x0">x0</code></td>
<td>
<p>Initial conditions</p>
</td></tr>
<tr><td><code id="odeBruitMult2_+3A_t">t</code></td>
<td>
<p>All the dates for which the result of the numerical
integration of the model must be provided</p>
</td></tr>
<tr><td><code id="odeBruitMult2_+3A_k">K</code></td>
<td>
<p>A matrix providing the model description:
each column corresponds to one equation which polynomial organisation
is following the convention defined by function <code>poLabs</code>.</p>
</td></tr>
<tr><td><code id="odeBruitMult2_+3A_vardata">varData</code></td>
<td>
<p>A vector of size <code>nVar</code> providing the caracteristic
variances of each variable of the dynamical systems in ODE defined
by matrix <code>K</code>.
If not provided, this variance is automatically estimated.</p>
</td></tr>
<tr><td><code id="odeBruitMult2_+3A_txvarbruitm">txVarBruitM</code></td>
<td>
<p>A vector defining the ratio of DYNAMICAL
noise for each variable of the dynamical system in ODE. This
noise is a perturbation added at each numerical integration step. The
ratio is defined relatively to the signal variance of each variable.</p>
</td></tr>
<tr><td><code id="odeBruitMult2_+3A_varbruitm">varBruitM</code></td>
<td>
<p>A vector defining the variance of DYNAMICAL
noise for each variable of the dynamical system in ODE. This
noise is a perturbation added at each numerical integration step.</p>
</td></tr>
<tr><td><code id="odeBruitMult2_+3A_method">method</code></td>
<td>
<p>Numerical method used in the integration process.
(see <code>ode</code> function in <code>deSolve</code> package for details).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sylvain Mangiarotti, Malika Chassan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+numinoisy">numinoisy</a></code>
</p>

<hr>
<h2 id='P1FxCh'>A data set for testing periodicity</h2><span id='topic+P1FxCh'></span>

<h3>Description</h3>

<p>A matrix of 6 columns corresponding to six
time series, two resulting from a Period-1 limit cycle,
two from regime converging to fixed point, and two relating
to a chaotic behavior
</p>


<h3>Usage</h3>

<pre><code class='language-R'>P1FxCh
</code></pre>


<h3>Format</h3>

<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 1000 rows and 6 columns.
</p>


<h3>Author(s)</h3>

<p>Sylvain Mangiarotti, Mireille Huc.
</p>

<hr>
<h2 id='P1FxChP2'>A data set for testing periodicity</h2><span id='topic+P1FxChP2'></span>

<h3>Description</h3>

<p>Trajectories for testing periodicity.
The following regimes are made available:
Period-1 in columns 1:2, Fixed Point in 3:4,
chaotic in 5:6, Period-2 in 7:8
</p>


<h3>Usage</h3>

<pre><code class='language-R'>P1FxChP2
</code></pre>


<h3>Format</h3>

<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 1000 rows and 8 columns.
</p>


<h3>Author(s)</h3>

<p>Sylvain Mangiarotti, Mireille Huc.
</p>

<hr>
<h2 id='p2dMax'>p2dMax : provides the maximum polynomial degree <code>dMax</code>
given the number of variables <code>nVar</code> and the number of possible
polynomial terms <code>pMax</code>.</h2><span id='topic+p2dMax'></span>

<h3>Description</h3>

<p>Find the maximum polynomial degree <code>dMax</code>
given the number of polynomial terms <code>pMax</code>
and the system dimension <code>nVar</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p2dMax(nVar, pMaxKnown, dMin = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p2dMax_+3A_nvar">nVar</code></td>
<td>
<p>Number of variables considered in the polynomial formulation.</p>
</td></tr>
<tr><td><code id="p2dMax_+3A_pmaxknown">pMaxKnown</code></td>
<td>
<p>The number of polynomial terms</p>
</td></tr>
<tr><td><code id="p2dMax_+3A_dmin">dMin</code></td>
<td>
<p>The minimum negative degree of the polynomial
formulation (0 by default).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dMax</code> The maximum polynomial degree
</p>


<h3>Author(s)</h3>

<p>Sylvain Mangiarotti, Laurent Drapeau
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gloMoId">gloMoId</a></code>, <code><a href="#topic+gPoMo">gPoMo</a></code>, <code><a href="#topic+poLabs">poLabs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############
# Example 1 #
#############
# Maximum polynomial degree ?
# number of variables:
nVar &lt;- 3
# size of the polynomial vector:
pMax &lt;- 10
# The maximal polynomial degree used for coding the polynomial is:
p2dMax(nVar,pMax)

#############
# Example 2 #
#############
# for pMax = 462 and nVar = 6, then dMax is:
p2dMax(6,462)
# indeed:
length(poLabs(nVar=6, dMax=5))

</code></pre>

<hr>
<h2 id='paramId'>For parameter Identification</h2><span id='topic+paramId'></span>

<h3>Description</h3>

<p>Estimate the polynomial coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paramId(allForK, drv, weight)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="paramId_+3A_allfork">allForK</code></td>
<td>
<p>The list of input parameters</p>
</td></tr>
<tr><td><code id="paramId_+3A_drv">drv</code></td>
<td>
<p>The derivative (on the equation left hand)</p>
</td></tr>
<tr><td><code id="paramId_+3A_weight">weight</code></td>
<td>
<p>The weighting series</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>allForK</code> The initial list completed with the model parameters.
</p>


<h3>Author(s)</h3>

<p>Sylvain Mangiarotti
</p>

<hr>
<h2 id='poLabs'>Polynomial labels order</h2><span id='topic+poLabs'></span>

<h3>Description</h3>

<p>Defines the order of the polynomial labels given
the number of variables <code>nVar</code> and the maximum polynomial
degree <code>dMax</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poLabs(nVar, dMax, dMin = 0, findIt = NULL, Xnote = "X")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="poLabs_+3A_nvar">nVar</code></td>
<td>
<p>The number of variables</p>
</td></tr>
<tr><td><code id="poLabs_+3A_dmax">dMax</code></td>
<td>
<p>The maximum degree allowed in the formulation</p>
</td></tr>
<tr><td><code id="poLabs_+3A_dmin">dMin</code></td>
<td>
<p>The minimum negative degree of the polynomial
formulation (0 by default).</p>
</td></tr>
<tr><td><code id="poLabs_+3A_findit">findIt</code></td>
<td>
<p>A vector of selected terms.</p>
</td></tr>
<tr><td><code id="poLabs_+3A_xnote">Xnote</code></td>
<td>
<p>Enables to defines the notation used for the variable,
by default <code>Xnote = 'X'</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>lbls</code> A vector of characters. Each element is the
expression of one polynomial term, such as <code class="reqn">X_1^2 X_3 X_4</code>
</p>


<h3>Author(s)</h3>

<p>Sylvain Mangiarotti
</p>


<h3>See Also</h3>

<p><code><a href="#topic+visuEq">visuEq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Regressor order for three variables \eqn{(X1,X2,X3)} (nVar = 3) for a maximum
#polynomial degree equal to 2 (dMax = 2): poLabs(3,2)
#and for two variables only : poLabs(2,2)

# For a quadratic equation of two variables,
# the polynomial \deqn{P(X1,X2) = 0.5 + 0.3 X1 -0.25 X1 X2}
# could thus be written as a vector Pvec such as:
Pvec = c(0.5, 0, 0, 0.3, -0.25, 0)
# considering the convention corresponding to
poLabs(2,2)
# Indeed:
poLabs(2, 2, findIt = Pvec!=0)
# An alternative notation can be used with parameter Xnote
poLabs(2, 2, findIt = Pvec!=0, Xnote = 'w')
# or also
poLabs(2, 2, findIt = Pvec!=0, Xnote = c('x','y'))

</code></pre>

<hr>
<h2 id='predictab'>Estimate the models performance obtained with <code>GPoMo</code>
in term of predictability</h2><span id='topic+predictab'></span>

<h3>Description</h3>

<p>The algorithm aims to estimate automatically the forecasting
performances of the models obtained with <code>gPoMo</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictab(
  ogp,
  fullt = NULL,
  fulldata = NULL,
  hp = NULL,
  Nech = 50,
  intSimStep = NULL,
  show = 1,
  selecmod = NULL,
  id = 1,
  selV = 1,
  na.rm = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictab_+3A_ogp">ogp</code></td>
<td>
<p>The output list obtained from function <code>gPoMo</code>.</p>
</td></tr>
<tr><td><code id="predictab_+3A_fullt">fullt</code></td>
<td>
<p>Time vector of the data set for which predictability
will be tested</p>
</td></tr>
<tr><td><code id="predictab_+3A_fulldata">fulldata</code></td>
<td>
<p>Data set for which predictability will be tested</p>
</td></tr>
<tr><td><code id="predictab_+3A_hp">hp</code></td>
<td>
<p>Time vector of the horizon of prediction</p>
</td></tr>
<tr><td><code id="predictab_+3A_nech">Nech</code></td>
<td>
<p>Number of simulations</p>
</td></tr>
<tr><td><code id="predictab_+3A_intsimstep">intSimStep</code></td>
<td>
<p>Internal number of simulation steps</p>
</td></tr>
<tr><td><code id="predictab_+3A_show">show</code></td>
<td>
<p>Provide (2) or not (0-1) visual output during
the running process.</p>
</td></tr>
<tr><td><code id="predictab_+3A_selecmod">selecmod</code></td>
<td>
<p>A vector of the model selected.</p>
</td></tr>
<tr><td><code id="predictab_+3A_id">id</code></td>
<td>
<p>The type of model to identify. <code>id = 1</code> corresponds
to unidentified models, that is, potentialy chaotic.</p>
</td></tr>
<tr><td><code id="predictab_+3A_selv">selV</code></td>
<td>
<p>Selected variable for the analysis</p>
</td></tr>
<tr><td><code id="predictab_+3A_na.rm">na.rm</code></td>
<td>
<p>Indicates if the <code>NA</code> should be removed
(<code>na.rm = TRUE</code>) or not (<code>na.rm = FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ErrmodAll</code> A list of matrix <code>$Predmod1</code>,
<code>$Predmod2</code>, etc. and <code>$Errmod1</code>, <code>$Errmod2</code>, etc.
providing respectively the forecasting and the forecasting error
of models 1, 2, etc.
Each column corresponds to one simulation starting from
a specific initial condition. Each line corresponds to
one horizon of prediction.
Vectors corresponding to the initial condition time <code>tE</code>
and the horizon of prediction <code>hpE</code> are also provided
in <code>$tE</code> and <code>$hpE</code>, respectively.
The percentiles of the distributions of error growth
are provided in <code>qt</code> (0.05, 0.1, 0.25, 0.5, 0.75, 0.9, 0.95)
and of absolute error growth in <code>qt2</code> (0.5, 0.75, 0.9, 0.95, 0.98, 0.99).
</p>


<h3>Author(s)</h3>

<p>Sylvain Mangiarotti, Mireille Huc
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data
data("Ross76")
# time vector
tin &lt;- Ross76[seq(1, 3000, by = 8), 1]
# single time series
data &lt;- Ross76[seq(1, 3000, by = 8), 3]
# dev.new()
# plot(tin, data, xlab = 'time', ylab = 'y(t)')

# global modelling
# results are put in list outputGPoM
outputGPoM &lt;- gPoMo(data[1:300], tin = tin[1:300], dMax = 2, nS=c(3),
                    show = 0, method = 'rk4',
                    nPmin = 10, nPmax = 12,
                    IstepMin = 150, IstepMax = 151)
#
visuOutGP(outputGPoM)

###########################
# and test predictability #
###########################
outpred &lt;- predictab(outputGPoM, hp = 15, Nech = 30)

# manual visualisation of the outputs (e.g. for model 1):
dev.new()
image(outpred$tE, outpred$hpE, t(outpred$Errmod1),
xlab = 't', ylab = 'hp', main = 'Errmod1')

</code></pre>

<hr>
<h2 id='pTimEv'>Model stationnary testing</h2><span id='topic+pTimEv'></span>

<h3>Description</h3>

<p>Estimate the parameters variations 
of a model of canonical form considering a sliding
window on an external dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pTimEv(
  TS,
  nVar,
  dMax,
  TSdate,
  whatTerms = NULL,
  weight = NULL,
  wlength = 1000,
  onestep = 100,
  removeExtr = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pTimEv_+3A_ts">TS</code></td>
<td>
<p>The time series to be tested</p>
</td></tr>
<tr><td><code id="pTimEv_+3A_nvar">nVar</code></td>
<td>
<p>Number of variables considered in the polynomial formulation.</p>
</td></tr>
<tr><td><code id="pTimEv_+3A_dmax">dMax</code></td>
<td>
<p>Maximum degree of the polynomial formulation.</p>
</td></tr>
<tr><td><code id="pTimEv_+3A_tsdate">TSdate</code></td>
<td>
<p>The time vector</p>
</td></tr>
<tr><td><code id="pTimEv_+3A_whatterms">whatTerms</code></td>
<td>
<p>The terms to be considered in the analysis. Note 
that these are organised following the convention defined by
poLabs(nVar,dMax). Since only the structure is required, if
coefficients are provided, these are transformed to 1.</p>
</td></tr>
<tr><td><code id="pTimEv_+3A_weight">weight</code></td>
<td>
<p>A vector providing the binary weighting function
of the input data series (0 or 1). By default, all the values
are set to 1.</p>
</td></tr>
<tr><td><code id="pTimEv_+3A_wlength">wlength</code></td>
<td>
<p>The window length</p>
</td></tr>
<tr><td><code id="pTimEv_+3A_onestep">onestep</code></td>
<td>
<p>Step length between two estimations</p>
</td></tr>
<tr><td><code id="pTimEv_+3A_removeextr">removeExtr</code></td>
<td>
<p>Ratio of estimated values to be removed (if
chosen equal to 0.1, only 90
disersion will be kept)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>
<p><code>$slidingoutGM</code> An n*(pMax+1) matrix presenting
the pMax estimated parameters p1(t), p2(t) etc. column by column.
The residual signal epsilon(t) is provided in the last (i.e. pMax + 1)
column. Each line correspond to one date provided in <code>$TSdate</code>
</p>
<p><code>$TSdate</code> A time vector relating to the estimates
presented in <code>$slidingoutGM</code>
</p>
<p><code>$W</code> A vector providing the output values that
can kept (=1) or must be removed (=0)
</p>
<p><code>$whatTerms</code> A vector recalling the terms
taken into account in the analysis (their order refers
to <code>poLabs(nVar,dMax)</code> function)
</p>
<p><code>$param</code> A vector with the parameter values
used to apply the function: nVar, dMax, wlength, onestep,
removeExtr
</p>


<h3>Author(s)</h3>

<p>Sylvain Mangiarotti
</p>


<h3>See Also</h3>

<p><code><a href="#topic+autoGPoMoSearch">autoGPoMoSearch</a></code>, <code><a href="#topic+gPoMo">gPoMo</a></code>, <code><a href="#topic+poLabs">poLabs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Example
data(TS)
plot(TS[,1], TS[,2], type='l')
nVar &lt;- 3
dMax &lt;- 2
pMax &lt;- choose(nVar+dMax,dMax)
whatTerms &lt;- c(1,1,0,1,1,1,1,1,1,1)
 
# apply pTimEv
statio &lt;- pTimEv(TS[,2], nVar, dMax, TS[,1], whatTerms = whatTerms, 
                 wlength = 1000, onestep = 20, removeExtr = 0.15)
# Plot the results
dev.new()
  layout(matrix(1:12, nrow=4, ncol=3, byrow = TRUE))
  what &lt;- which(statio$whatTerms!=0)
  for (i in what) {
      plot(statio$TSdate[statio$W==1], statio$slidingoutGM[statio$W==1,i],
           xlab='TSdate', ylab='coeff', main=poLabs(nVar,dMax)[i])
     }
  plot(statio$TSdate[statio$W==1], statio$slidingoutGM[statio$W==1,pMax+1],
       xlab='date', ylab='Epsilon', main='Resid', log = 'y')
       
</code></pre>

<hr>
<h2 id='regOrd'>Generate the conventional order for polynomial terms
in a the polynomial formulation</h2><span id='topic+regOrd'></span>

<h3>Description</h3>

<p>Generate the conventional order of the polynomial
terms for the polynomial description.
It is formulated as a matrix of exponents: Each
column of the matrix (a,b,c, ...) corresponds to a product
of the <code>nVar</code> available variables X1, X2, X3, etc.,
that is, <code class="reqn">X1^a X2^b X3^c</code>, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regOrd(nVar, dMax, dMin = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regOrd_+3A_nvar">nVar</code></td>
<td>
<p>The number of variables</p>
</td></tr>
<tr><td><code id="regOrd_+3A_dmax">dMax</code></td>
<td>
<p>The maximum degree allowed in the formulation</p>
</td></tr>
<tr><td><code id="regOrd_+3A_dmin">dMin</code></td>
<td>
<p>The minimum negative degree of the polynomial
formulation (0 by default).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of exponents. Each column corresponds to one
polynomial term. Each line correspond to the exponent of one
variable.
For example, a column of three exponents <code>(0,2,1)</code> corresponds
to the monomial <code>X1^0 * X2^2 * X3^1</code>, that is <code class="reqn">X2^2 X3</code>.
</p>


<h3>Author(s)</h3>

<p>Sylvain Mangiarotti
</p>


<h3>See Also</h3>

<p><code><a href="#topic+poLabs">poLabs</a></code>
</p>

<hr>
<h2 id='regSeries'>Estimates the monomial time series</h2><span id='topic+regSeries'></span>

<h3>Description</h3>

<p>Creates time series by multiplying given time series among them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regSeries(nVar, dMax, series, dMin = 0, pReg = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regSeries_+3A_nvar">nVar</code></td>
<td>
<p>Number of variables considered in the polynomial formulation.</p>
</td></tr>
<tr><td><code id="regSeries_+3A_dmax">dMax</code></td>
<td>
<p>Maximum degree of the polynomial formulation.</p>
</td></tr>
<tr><td><code id="regSeries_+3A_series">series</code></td>
<td>
<p>A matrix containing the original time series from which
the monomials are built. Each column corresponds to one given variable.</p>
</td></tr>
<tr><td><code id="regSeries_+3A_dmin">dMin</code></td>
<td>
<p>The minimum negative degree of the polynomial
formulation (0 by default).</p>
</td></tr>
<tr><td><code id="regSeries_+3A_preg">pReg</code></td>
<td>
<p>A matrix filled, for each column, with powers of time series
used to create.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>rpFull</code> A matrix of time series. Each column corresponds to one
regressor such as <code class="reqn">X_1^2 X_3 X_4</code>
</p>


<h3>Author(s)</h3>

<p>Sylvain Mangiarotti
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(TSallMod_nVar3_dMax2)
sprottK &lt;- as.matrix(TSallMod_nVar3_dMax2$SprK$reconstr)[,2:4]
dMax &lt;- 2
nVar &lt;- dim(sprottK)[2]

#Example 1
polySeries1 &lt;- regSeries(nVar, dMax, sprottK)

#Example 2
p &lt;- c(1,3,1)
polySeries2 &lt;- regSeries(nVar, dMax, sprottK, pReg=p)

</code></pre>

<hr>
<h2 id='Rossler-1976+20data+20set'>Time series of the Rossler-1976 system</h2><span id='topic+Rossler-1976+20data+20set'></span><span id='topic+Ross76'></span>

<h3>Description</h3>

<p>The Rössler system is the 3-dimensional chaotic system <br />
<code class="reqn">dx/dt = - y - z</code> <br />
<code class="reqn">dy/dt = x + a y</code> <br />
<code class="reqn">dz/dt = b + z (x - c)</code>, <br />
discovered by Otto E. Rössler in 1976 [1].
The following parameters and initial conditions
were used to produce the present data set:<br />
a = 0.520, b = 2, c = 4 <br />
and (x0, y0, z0) = (-0.04298734, 1.025536, 0.09057987).<br />
The following four columns are provided:<br />
(1) time t, (2) x(t), (3) y(t) and (4) z(t).<br />
For this parameterization, the Rössler system produces
a chaotic behavior characterized by a regime
non-coherent in phase (oscillations duration can be
very different from one oscillation to another).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ross76
</code></pre>


<h3>Format</h3>

<p>An object of class <code>deSolve</code> (inherits from <code>matrix</code>) with 4000 rows and 4 columns.
</p>


<h3>Author(s)</h3>

<p>Sylvain Mangiarotti, Flavie Le Jean,
Malika Chassan, Laurent Drapeau, Mireille Huc.
</p>


<h3>References</h3>

<p>[1] O. Rössler, 1976. An Equation for Continuous Chaos,
Physics Letters, 71A, 2-3, 155-157. <br />
</p>

<hr>
<h2 id='RosYco'>Twelve Rossler-1976 time series (exclusively variable <code class="reqn">y</code>)</h2><span id='topic+RosYco'></span>

<h3>Description</h3>

<p>Twelve independant Rossler-1976 time series
(variable y). The parameters used to generate the time
series correspond to a phase coherent behavior.
Details can be found in [1]
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RosYco
</code></pre>


<h3>Format</h3>

<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 3000 rows and 12 columns.
</p>


<h3>Details</h3>

<p>Another set of time series of the Rossler-1976 chaotic system
</p>


<h3>Author(s)</h3>

<p>Sylvain Mangiarotti, Flavie Le Jean.
</p>


<h3>References</h3>

<p>[1] Mangiarotti S., Le Jean F., Huc M. &amp; Letellier C.,
Global Modeling of aggregated and associated chaotic
dynamics. Chaos, Solitons and Fractals, 83, 82-96.
</p>

<hr>
<h2 id='subSysD'>subSysD : Sub-systems Disentangling</h2><span id='topic+subSysD'></span>

<h3>Description</h3>

<p>Detect, disentangle and reformulate Sub-systems
from an ensemble of equations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subSysD(inK, inXnote = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subSysD_+3A_ink">inK</code></td>
<td>
<p>A list of models, each provided as a matrix.
A single matrix can also be provided, it will be transformed
into a list containing a single matrix.</p>
</td></tr>
<tr><td><code id="subSysD_+3A_inxnote">inXnote</code></td>
<td>
<p>A vector with the names of the input
variables. If not provided, default notation
is used: &quot;X1&quot;, &quot;X2&quot;, etc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>subS A matrix with the extracted subsystem
</p>


<h3>Author(s)</h3>

<p>Sylvain Mangiarotti
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gPoMo">gPoMo</a></code>, <code><a href="#topic+poLabs">poLabs</a></code>, <code><a href="#topic+combiEq">combiEq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load models
data("allMod_nVar3_dMax2")
# Display equations of system 1
visuEq(nVar = 3, dMax = 2, K = allMod_nVar3_dMax2$NH86, substit = 1)
# Display equations of system 2
visuEq(nVar = 3, dMax = 2, K = allMod_nVar3_dMax2$R76, substit = 1)
# put the two systems in a list
allK &lt;- list()
allK[[1]] &lt;- allMod_nVar3_dMax2$NH86
allK[[2]] &lt;- allMod_nVar3_dMax2$R76

# Example 1 (two independant subsystems)
# take two separate systems and mix them
inXnote = list()
inXnote[[1]] &lt;- c('u', 'v', 'w')
inXnote[[2]] &lt;- c('X', 'Y', 'Z')
visuEq(K = allK[[1]], substit = inXnote[[1]])
visuEq(K = allK[[2]], substit = inXnote[[2]])
XnoteOut = c('u', 'X', 'v', 'Y', 'w', 'Z')
Knew3 &lt;- combiEq(allK,dMaxOut = 3, eqOrder = c(1,4,2,5,3,6))
visuEq(K = Knew3, substit = XnoteOut)
# Disentangle the subsystems from the mixed equations
dstgl &lt;- subSysD(Knew3, inXnote = XnoteOut)
## Optional
# library(igraph)
# g1&lt;-graph.adjacency(dstgl$FM);
# l &lt;- layout_with_fr(g1)
# plot(g1, edge.arrow.siez = .4, edge.curved=.4, vertex.label=XnoteOut, layout = l)

# Example 2 (one subsystem included in the other)
Kduff &lt;- matrix(0, ncol = 4, nrow = 35)
Kduff[11,1] &lt;- Kduff[5,2] &lt;- Kduff[2,3] &lt;- 1
Kduff[35,2] &lt;- -1
Kduff[11,2] &lt;- -0.05
Kduff[5,4] &lt;- 2 * acos(-1) / 6.2
Xnote &lt;- c("x", "y", "u", "v")
visuEq(Kduff, substit = Xnote)
dstgl2 &lt;- subSysD(Kduff, inXnote = Xnote)

</code></pre>

<hr>
<h2 id='svrlTS'>A data set for the global modeling of time series in association</h2><span id='topic+svrlTS'></span>

<h3>Description</h3>

<p>This data set aims to test the global modelling technique
when several time series of different sizes are available.
Four time series are provided, all derived from the Rössler-1976 system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svrlTS
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 4.
</p>


<h3>Author(s)</h3>

<p>Sylvain Mangiarotti, Mireille Huc.
</p>


<h3>References</h3>

<p>S. Mangiarotti, F. Le Jean, M. Huc &amp; C. Letellier, 2016.
Global modeling of aggregated and associated chaotic dynamics,
Chaos, Solitons &amp; Fractals, 83, 82-96.
</p>

<hr>
<h2 id='testP'>Periodic solution test</h2><span id='topic+testP'></span>

<h3>Description</h3>

<p>Tests if a trajectory is periodic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testP(data, wthresh = 0.1, fxPtThresh = 1e-04, show = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testP_+3A_data">data</code></td>
<td>
<p>Input Time series: Each column is one time series
that corresponds to one variable.</p>
</td></tr>
<tr><td><code id="testP_+3A_wthresh">wthresh</code></td>
<td>
<p>Threshold used to detect the limit cycle.</p>
</td></tr>
<tr><td><code id="testP_+3A_fxptthresh">fxPtThresh</code></td>
<td>
<p>Threshold used to detect fixed points.</p>
</td></tr>
<tr><td><code id="testP_+3A_show">show</code></td>
<td>
<p>Provide (2) or not (0-1) visual output during
the running process.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>periodic</code>  An integer classifying the models:
diverging or unclassified trajectory (0),
period-1 trajectory (-1), period-2 trajectory (-2)
and fixed Point (2).
</p>


<h3>Author(s)</h3>

<p>Sylvain Mangiarotti, Flavie Le Jean
</p>


<h3>See Also</h3>

<p><code><a href="#topic+autoGPoMoTest">autoGPoMoTest</a></code>, <code><a href="#topic+gPoMo">gPoMo</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Example
# Load data:
data('P1FxChP2')
# Test a period-1 trajectory
testP(P1FxChP2[,1:2], wthresh=0.1, fxPtThresh = 1e-6, show=0)
# Test a Fixed Point trajectory
testP(P1FxChP2[,3:4], wthresh=0.1, fxPtThresh = 1e-6, show=0)
# Test a chaotic trajectory
testP(P1FxChP2[,5:6], wthresh=0.1, fxPtThresh = 1e-6, show=0)
# Test a period-2 trajectory
testP(P1FxChP2[,7:8], wthresh=0.1, fxPtThresh = 1e-6, show=0)

</code></pre>

<hr>
<h2 id='TS'>Time series resulting from the integration of a non stationary system</h2><span id='topic+TS'></span>

<h3>Description</h3>

<p>A 2*6001 matrix with the time vector in column one
and a time series resulting from the integration of a non stationary
Rössler system &ndash; parameter a varying in time: a(t) &ndash; in colmn two.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TS
</code></pre>


<h3>Format</h3>

<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 6001 rows and 2 columns.
</p>


<h3>Author(s)</h3>

<p>Sylvain Mangiarotti, Mireille Huc.
</p>

<hr>
<h2 id='TSallMod_nVar3_dMax2+20data+20set'>Time series of three-dimensional chaotic sytems
(for vignette <code>VII_Retro-Modelling</code>)</h2><span id='topic+TSallMod_nVar3_dMax2+20data+20set'></span><span id='topic+TSallMod_nVar3_dMax2'></span>

<h3>Description</h3>

<p>A list of matrix providing the time series
in a list named <code>TSallMod_nVar3_dMax2</code> of eighteen
three-dimensional chaotic systems:
Lorenz-1963 ($L63), Rössler-1976 ($R76), Burke &amp; shaw 1981 ($BS81),
Lorenz-1984 ($L84), Nosé &amp; Hooer 1986 ($NH86), Genesio &amp; Tosi 1992 ($GT92),
Spott systems 1994 ($SprF, $SprH, $SprK, $SprO, $SprP, $SprG,
$SprM, $SprQ, $SprS),
Chlouverakis &amp; Sprott 2004 ($CS2004), Li 2007 ($Li2007)
and the Cord system by Aguirre &amp; Letellier 2012 ($Cord2012).
Time series are provided in a matrix in which
each column corresponds to one variable of the dynamical systems.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TSallMod_nVar3_dMax2
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 18.
</p>


<h3>Author(s)</h3>

<p>Sylvain Mangiarotti, Mireille Huc.
</p>


<h3>References</h3>

<p>References for the systems are provided
in vignette 'VII_retro-modelling'.
</p>

<hr>
<h2 id='visuEq'>Displays the models Equations</h2><span id='topic+visuEq'></span>

<h3>Description</h3>

<p>Displays the model equations for a polynomial model
which description is provided as a matrix <code>K</code>, each column
corresponding to one equation. The coefficients of the polynomial
terms are given following the order defined by function <code>poLabs</code>.
The matrix can also be provided in a list <code>K</code>,
in this case, the matrix should be located in <code>K$model[[selecmod]]</code>
where selecmod should be provided as input parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>visuEq(
  K,
  nVar = NULL,
  dMax = NULL,
  dMin = 0,
  substit = 0,
  approx = FALSE,
  selecmod = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="visuEq_+3A_k">K</code></td>
<td>
<p>A matrix providing the model description:
each column corresponds to one equation which polynomial organisation
is following the convention defined by function <code>poLabs</code>.</p>
</td></tr>
<tr><td><code id="visuEq_+3A_nvar">nVar</code></td>
<td>
<p>The number of variables</p>
</td></tr>
<tr><td><code id="visuEq_+3A_dmax">dMax</code></td>
<td>
<p>The maximum degree allowed in the formulation</p>
</td></tr>
<tr><td><code id="visuEq_+3A_dmin">dMin</code></td>
<td>
<p>The minimum negative degree of the polynomial
formulation (0 by default).</p>
</td></tr>
<tr><td><code id="visuEq_+3A_substit">substit</code></td>
<td>
<p>Applies subtitutions to the default values:
for <code>substit = 0</code> (default value), variables are chosen
as <code>X1</code>, <code>X2</code>, ...
for <code>substit = 1</code>, variable <code>X1</code>, <code>X2</code>, ...
will be replaced by <code>x</code>, <code>y</code>, <code>z</code>, ...
for <code>substit = 2</code>, the codes provides a LaTex-like
formulation of the model.
The variables name can also be defined explicitely as follows:
for <code>substit = c('x', 'H', 'T1')</code>, variables <code>X1</code>,
<code>X2</code>, <code>X3</code> ... will be replaced by <code>x</code>, <code>H</code>
and <code>T1</code>.</p>
</td></tr>
<tr><td><code id="visuEq_+3A_approx">approx</code></td>
<td>
<p>The number of extra digits to be used:
for <code>approx = FALSE</code> (default value) digits are
edited with double precision;
for <code>approx = TRUE</code>, only the minimum number of digits is
edited (in order to have all the terms different from 0)
for <code>approx</code> = 1, 2, etc. then respectively 1, 2, etc.
digits are added to the minimum number of digits corresponding
to <code>approx = TRUE</code>.</p>
</td></tr>
<tr><td><code id="visuEq_+3A_selecmod">selecmod</code></td>
<td>
<p>An integer providing the number in the sublist
when the model matrix is provided in a list. Should not be
provided (or NULL) if the model matrix is provided directly.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>N A list of Nvar elements presenting a set of equtions,
each equation being an element of this list and written as
a character strings
</p>


<h3>Author(s)</h3>

<p>Sylvain Mangiarotti
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#EQUATIONS VISUALISATION
# number of variables:
nVar &lt;- 3
# maximum polynomial degree:
dMax &lt;- 2
# polynomial organization:
poLabs(nVar,dMax)
# model construction
KL = matrix(0, ncol = 3, nrow = 10)
KL[1,1] &lt;- KL[2,2] &lt;- 1
KL[4,1] &lt;- -1
KL[5,3] &lt;- -0.123456789
# Equations visualisation:
# (a) by default, variables names X1, X2, X3 are used
visuEq(KL, nVar, dMax)
# (b) for susbstit=1, variables names x, y, y are used instead
visuEq(KL, nVar, dMax, approx = TRUE, substit=1)
# (c) the name of the variables can also be chosen manualy
visuEq(KL, nVar, dMax, approx = 3, substit=c('U', 'V', 'W'))

# A canonical model can be provided as a single vector
polyTerms &lt;- c(0.2,0,-1,0.5,0,0,0,0,0,0)
visuEq(polyTerms, 3,2)

</code></pre>

<hr>
<h2 id='visuOutGP'>visuOutGP : get a quick information of gPoMo output</h2><span id='topic+visuOutGP'></span>

<h3>Description</h3>

<p>The algorithm aims to get a quick information about
the outputs obtained with gPoMo.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>visuOutGP(
  ogp,
  selecmod = NULL,
  id = 1,
  prioMinMax = "data",
  opt3D = "TRUE",
  maxPages = NULL,
  seeEq = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="visuOutGP_+3A_ogp">ogp</code></td>
<td>
<p>The output list obtained from gPoMo.</p>
</td></tr>
<tr><td><code id="visuOutGP_+3A_selecmod">selecmod</code></td>
<td>
<p>A vector of the selected model. Maximum 24 models can be
presented at the same time.</p>
</td></tr>
<tr><td><code id="visuOutGP_+3A_id">id</code></td>
<td>
<p>The type of model to identify. <code>id = 1</code> corresponds to
the unidentified models, that is, potentialy chaotic models).</p>
</td></tr>
<tr><td><code id="visuOutGP_+3A_priominmax">prioMinMax</code></td>
<td>
<p>Gives the priority for the plots among: <code>"data"</code>,
<code>"model"</code>, <code>"dataonly"</code> and <code>"modelonly"</code>.</p>
</td></tr>
<tr><td><code id="visuOutGP_+3A_opt3d">opt3D</code></td>
<td>
<p>Provides a 3D plot (x,y,z) when <code>opt = 'TRUE'</code>
(the <code>rgl</code> library is required).</p>
</td></tr>
<tr><td><code id="visuOutGP_+3A_maxpages">maxPages</code></td>
<td>
<p>The maximum of pages to be displayed (4 by default,
but this may be insufficient when too many models remain)</p>
</td></tr>
<tr><td><code id="visuOutGP_+3A_seeeq">seeEq</code></td>
<td>
<p>Indicates if equations should be displayed (seeEq = 1,
by default) or not (seeEq = 0).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Matrix describing the terms composing each model by row. The first
row corresponds to the model detection (1 unclarified, 2 diverging, 0 is fixed
point, -n with n an integer, is period-n cycle' )
</p>


<h3>Author(s)</h3>

<p>Sylvain Mangiarotti
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data
data("Ross76")
# # time vector
tin &lt;- Ross76[seq(1, 3000, by = 8), 1]
# single time series
data &lt;- Ross76[seq(1, 3000, by = 8), 3]
dev.new()
plot(tin, data, type = 'l', main = 'Observed time series')
# global modelling
# results are put in list outputGPoM
outputGPoM &lt;- gPoMo(data, tin=tin, dMax = 2, nS=c(3), show = 0,
                    nPmin = 9, nPmax = 12, method = 'rk4',
                    IstepMin = 200, IstepMax = 201)
visuOutGP(outputGPoM)

</code></pre>

<hr>
<h2 id='wInProd'>Weighted inner product</h2><span id='topic+wInProd'></span>

<h3>Description</h3>

<p>Computes weighted inner products.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wInProd(A1, A2, weight = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wInProd_+3A_a1">A1</code></td>
<td>
<p>The input matrix 1.</p>
</td></tr>
<tr><td><code id="wInProd_+3A_a2">A2</code></td>
<td>
<p>The input matrix 2.</p>
</td></tr>
<tr><td><code id="wInProd_+3A_weight">weight</code></td>
<td>
<p>The weighting vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>inP</code> The weighted inner product.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>############
#Example 1 #
############
A1 = c(0,1,2,0,1,3)
A2 = c(1,2,0,0,4,1)
wInProd(A1, A2)

############
#Example 2 #
############
A1 = c(0,1,2,0,1,3)
A2 = c(1,2,0,0,4,1)
w = c(0,0,0,1,1,1)
wInProd(A1, A2, weight = w)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
