<!DOCTYPE html><html><head><title>Help for package openSkies</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {openSkies}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ADSBDecoder'><p>An object of class <code>adsbDecoder</code> object representing a decoder used</p>
to decode ADS-B v2 messages</a></li>
<li><a href='#clusterRoutes'><p>Cluster aircraft trajectories based on positional features</p></a></li>
<li><a href='#findFlightPhases'><p>Find the phases of a flight based on altitude, vertical rate and speed</p></a></li>
<li><a href='#getAircraftFlights'><p>Retrieve flights performed by a specified aircraft during a time interval</p></a></li>
<li><a href='#getAircraftMetadata'><p>Retrieve metadata for a specified aircraft</p></a></li>
<li><a href='#getAircraftStateVectorsSeries'><p>Retrieve a series of state vectors received from a specified aircraft</p>
during a given time interval</a></li>
<li><a href='#getAirportArrivals'><p>Retrieve flight arrivals into a specified airport</p></a></li>
<li><a href='#getAirportDepartures'><p>Retrieve flight departures from a specified airport</p></a></li>
<li><a href='#getAirportMetadata'><p>Retrieve metadata for a specified airport</p></a></li>
<li><a href='#getIntervalFlights'><p>Retrieve all flights registered during a time interval</p></a></li>
<li><a href='#getIntervalStateVectors'><p>Retrieve all state vectors received during a time interval</p></a></li>
<li><a href='#getOSNCoverage'><p>Retrieve coverage of the OpenSky Network for a given day</p></a></li>
<li><a href='#getRouteMetadata'><p>Retrieve metadata for a specified route</p></a></li>
<li><a href='#getSingleTimeStateVectors'><p>Retrieve all state vectors received at a given time point</p></a></li>
<li><a href='#getVectorSetFeatures'><p>Get positional features of an openSkiesStateVectorSet object</p></a></li>
<li><a href='#getVectorSetListFeatures'><p>Get positional features of a list of openSkiesStateVectorSet objects</p></a></li>
<li><a href='#openSkiesAircraft'><p>An <code>R6Class</code> object representing an aircraft</p></a></li>
<li><a href='#openSkiesAirport'><p>An <code>R6Class</code> object representing an airport</p></a></li>
<li><a href='#openSkiesFlight'><p>An <code>R6Class</code> object representing a specific flight</p></a></li>
<li><a href='#openSkiesRoute'><p>An <code>R6Class</code> object representing a flight route</p></a></li>
<li><a href='#openSkiesStateVector'><p>An <code>R6Class</code> object representing an aircraft state vector</p></a></li>
<li><a href='#openSkiesStateVectorSet'><p>An <code>R6Class</code> object representing an ensemble of aircraft</p>
state vectors</a></li>
<li><a href='#plotPlanes'><p>Plot the location of a set of aircrafts</p></a></li>
<li><a href='#plotRoute'><p>Plot a single aircraft route</p></a></li>
<li><a href='#plotRoutes'><p>Plot several aircraft routes</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Retrieval, Analysis and Visualization of Air Traffic Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-04-03</td>
</tr>
<tr>
<td>Author:</td>
<td>Rafael Ayala, Daniel Ayala, David Ruiz, Aleix Sellés, Lara Sellés Vidal</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Rafael Ayala &lt;rafael.ayala@oist.jp&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functionalities and data structures to retrieve, analyze and visualize aviation 
    data. It includes a client interface to the 'OpenSky' API <a href="https://opensky-network.org">https://opensky-network.org</a>. It allows 
    retrieval of flight information, as well as aircraft state vectors.</td>
</tr>
<tr>
<td>Acknowledgements:</td>
<td>The development of this software is supported by the
Spanish Ministry of Science and Innovation (grant code
PID2019-105471RB-I00) and the Regional Government of Andalusia
(grant code P18-RT-1060).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://creativecommons.org/licenses/by-nc/4.0">CC BY-NC 4.0</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>grid</td>
</tr>
<tr>
<td>Imports:</td>
<td>httr, ssh, xml2, ggmap, ggplot2, magick, utils, stats, R6,
dbscan, cluster, DBI, RPresto</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, BiocStyle, RUnit, BiocGenerics, rmarkdown, markdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Rafael-Ayala/openSkies/issues">https://github.com/Rafael-Ayala/openSkies/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-03 09:13:40 UTC; rafael</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-03 09:43:00 UTC</td>
</tr>
</table>
<hr>
<h2 id='ADSBDecoder'>An object of class <code>adsbDecoder</code> object representing a decoder used 
to decode ADS-B v2 messages</h2><span id='topic+ADSBDecoder'></span>

<h3>Description</h3>

<p><code><a href="R6.html#topic+R6Class">R6Class</a></code> object of class <code>adsbDecoder</code> representing a decoder 
used to decode ADS-B v2 messages. Provides methods for decoding a single message 
or a batch. Additionally, it includes methods for transforming hex strings into 
bits vectors and decoding some individual fields. Decoded messages are returned 
as lists with each decoded field.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ADSBDecoder
</code></pre>


<h3>Fields</h3>


<dl>
<dt><code>lastOddPosition</code></dt><dd><p>Last ground or airborne position message decoded with 
<code>decodeGroundPositionMessage</code> or <code>decodeAirbornePositionMessage</code>
</p>
</dd>
<dt><code>lastEvenPosition</code></dt><dd><p>Last ground or airborne position message decoded with 
<code>decodeGroundPositionMessage</code> or <code>decodeAirbornePositionMessage</code>
</p>
</dd>
</dl>


<h3>Methods</h3>


<dl>
<dt>
<code>hexToBits(hex)</code></dt><dd>
<p>Transform a hexadecimal string into its corresponding bits representation, with higher 
bits in the first positions.
</p>
</dd></dl>
<p>,
</p>
<dl>
<dt>
<code>decodeCPR(cprLatEven, cprLonEven, cprLatOdd, cprLonOdd, isAirborne=TRUE)</code></dt><dd>
<p>Decodes a pair of CPR-encoded positions given as longitudes and latitudes,
corresponding to a pair of even and odd messages, obtaining the actual positions
for both. The isAirborne argument indicates whether or not the CPR-encoded positions correspond to 
isAirborne position messages or not (ground position messages). The result is given as a vector with
the decoded positions for both the even and odd messages, in the following order: even latitude, 
even longitude, odd latitude, odd longitude.
</p>
</dd></dl>
<p>,
</p>
<dl>
<dt>
<code>decodeMessage(message)</code></dt><dd>
<p>Decodes a single ADS-B v2 message in the form of a bits vector (higher bits 
in the first positions). The last even and odd positional messages are cached to
decode following positional messages. The following message types are supported: 
aircraft identification, airborne position, ground position, airborne velocity,
and operation status.
</p>
</dd></dl>
<p>,
</p>
<dl>
<dt>
<code>decodeMessages(messages)</code></dt><dd>
<p>Decodes several ADS-B v2 messages in the form of a list of bits vector (higher bits 
in the first positions). The following message types are supported: aircraft 
identification, airborne position, ground position, airborne velocity, and operation
status.
</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
# Decode three messages, using both individual decoding and batch decoding. 
# The two first messages contain the airborne position.
# The third one, the aircraft identification

msg0 &lt;- ADSBDecoder$hexToBits("8D40621D58C386435CC412692AD6")
msg1 &lt;- ADSBDecoder$hexToBits("8D40621D58C382D690C8AC2863A7")
msg2 &lt;- ADSBDecoder$hexToBits("8D4840D6202CC371C32CE0576098")

decoded0 &lt;- ADSBDecoder$decodeMessage(msg0)
decoded1 &lt;- ADSBDecoder$decodeMessage(msg1)
decoded2 &lt;- ADSBDecoder$decodeMessage(msg2)

decodedAll &lt;- ADSBDecoder$decodeMessages(list(msg0, msg1, msg2))
</code></pre>

<hr>
<h2 id='clusterRoutes'>Cluster aircraft trajectories based on positional features
</h2><span id='topic+clusterRoutes'></span>

<h3>Description</h3>

<p>Performs clustering of aircraft trajectories positional based on their positional
features with several available methods. The input should be either a list of <code><a href="#topic+openSkiesStateVectorSet">openSkiesStateVectorSet</a></code>
or an already computed features matrix as returned by <code><a href="#topic+getVectorSetListFeatures">getVectorSetListFeatures</a></code>. 
If the input is a list of vector sets, features will be computed with default settings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clusterRoutes(input, method="dbscan", eps=0.5, numberClusters=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clusterRoutes_+3A_input">input</code></td>
<td>
<p>input to be clustered, given as either a list of <code><a href="#topic+openSkiesStateVectorSet">openSkiesStateVectorSet</a></code>, or a
matrix of positional features extracted from a list of
<code><a href="#topic+openSkiesStateVectorSet">openSkiesStateVectorSet</a></code> objects with <code><a href="#topic+getVectorSetListFeatures">getVectorSetListFeatures</a></code>,
that will be used to identify clusters.
</p>
</td></tr>
<tr><td><code id="clusterRoutes_+3A_method">method</code></td>
<td>
<p>clustering method that will be applied to the positional features.
Accepted methods are: dbscan, kmeans, hclust, fanny, clara, agnes</p>
</td></tr>
<tr><td><code id="clusterRoutes_+3A_eps">eps</code></td>
<td>
<p>Size of the epsilon neighborhood to be passed to <code><a href="dbscan.html#topic+dbscan">dbscan</a>.This argument is 
  only used if the selected clustering method is dbscan.</code>.
</p>
</td></tr>
<tr><td><code id="clusterRoutes_+3A_numberclusters">numberClusters</code></td>
<td>
<p>number of expected clusters. If NULL or a value lesser than 2 is passed,
the number of clusters will be estimated. This argument is only used if the selected clustering
method is kmeans, hclust, fanny, clara, or agnes</p>
</td></tr>
<tr><td><code id="clusterRoutes_+3A_...">...</code></td>
<td>
<p>additional arguments accepted by the selected clustering method</p>
</td></tr></table>
<p>.
</p>


<h3>Value</h3>

<p>An object with clustering results, containing at least a &quot;cluster&quot;. For additional details, 
see the documentation of <code><a href="survival.html#topic+cluster">cluster</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
# Retrieve series of state vectors for 7 instances of flights between 
# Cagliari-Elmas airport and Parma airport

vectors1=getAircraftStateVectorsSeries(aircraft="4d2219", 
startTime="2020-11-06 09:20:00", endTime="2020-11-06 10:30:00", 
timeZone="Europe/London", timeResolution=300)

vectors2=getAircraftStateVectorsSeries(aircraft="4d226c", 
startTime="2020-10-30 09:20:00", endTime="2020-10-30 10:30:00", 
timeZone="Europe/London", timeResolution=300)

vectors3=getAircraftStateVectorsSeries(aircraft="4d225b", 
startTime="2020-10-29 07:15:00", endTime="2020-10-29 08:25:00", 
timeZone="Europe/London", timeResolution=300)

vectors4=getAircraftStateVectorsSeries(aircraft="4d225b", 
startTime="2020-10-25 06:25:00", endTime="2020-10-25 07:35:00", 
timeZone="Europe/London", timeResolution=300)

vectors5=getAircraftStateVectorsSeries(aircraft="4d224e", 
startTime="2020-10-19 09:30:00", endTime="2020-10-19 10:40:00", 
timeZone="Europe/London", timeResolution=300)

vectors6=getAircraftStateVectorsSeries(aircraft="4d225b", 
startTime="2020-10-16 09:30:00", endTime="2020-10-16 10:30:00", 
timeZone="Europe/London", timeResolution=300)

vectors7=getAircraftStateVectorsSeries(aircraft="4d227d", 
startTime="2020-10-12 09:30:00", endTime="2020-10-12 10:30:00", 
timeZone="Europe/London", timeResolution=300)

# Retrieve state vectors for an outlier flight, corresponding to a flight 
# between the airports of Sevilla and Palma de Mallorca

vectors8=getAircraftStateVectorsSeries(aircraft = "4ca7b3", 
startTime="2020-11-04 10:30:00", endTime="2020-11-04 12:00:00",
timeZone="Europe/London", timeResolution=300)

## Group all the openSkiesStateVectorSet objects in a single list

vectors_list=list(vectors1, vectors2, vectors3, vectors4, vectors5, vectors6, vectors7, vectors8)

## Extract the matrix of features

features_matrix=getVectorSetListFeatures(vectors_list, scale=TRUE, useAngles=FALSE)

## Perform clustering

clustering=clusterRoutes(features_matrix, "dbscan", eps=5)

## Display clustering results with flights colored by assigned cluster

plotRoutes(vectors_list, pathColors=clustering$cluster, literalColors=FALSE)
}
</code></pre>

<hr>
<h2 id='findFlightPhases'>Find the phases of a flight based on altitude, vertical rate and speed
</h2><span id='topic+findFlightPhases'></span>

<h3>Description</h3>

<p>Identifies the different phases of a flight based on the altitude, vertical 
rate and speed of the aircraft reported in a time series of state vectors.
Identification of flight phases is performed using a fuzzy logic approach as
described in https://arc.aiaa.org/doi/10.2514/1.I010520. Currently, five 
different phases are considered: ground, climb, cruise, descent and level flight.
Flight phase identification can also be performed by calling the <code>detect_phases</code>
method of an <code><a href="#topic+openSkiesFlight">openSkiesFlight</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findFlightPhases(times, altitudes, verticalRates, speeds, window=60)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findFlightPhases_+3A_times">times</code></td>
<td>
<p>vector of times in seconds corresponding to the altitude, vertical
rate and speed values.
</p>
</td></tr>
<tr><td><code id="findFlightPhases_+3A_altitudes">altitudes</code></td>
<td>
<p>vector of altitude values in meters</p>
</td></tr>
<tr><td><code id="findFlightPhases_+3A_verticalrates">verticalRates</code></td>
<td>
<p>vector of vertical rate values in meters/second.</p>
</td></tr></table>
<p>.
</p>
<table>
<tr><td><code id="findFlightPhases_+3A_speeds">speeds</code></td>
<td>
<p>vector of speed values (i.e., the speed at which the aircraft
is moving with respect to the ground) in meters/second</p>
</td></tr></table>
<p>.
</p>
<table>
<tr><td><code id="findFlightPhases_+3A_window">window</code></td>
<td>
<p>time window in seconds to compute mean values before detecting
flight phases. It is recommended to apply a window in order to reduce the impact
of spurious wrong values, but window application can be effectively turned off
by setting this argument to 1</p>
</td></tr></table>
<p>.
</p>


<h3>Value</h3>

<p>A character vector where each element indicates the phase corresponding to each
of the time points.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># In the following example, we will retrieve all state vectors for a flight 
# along route SCX624, from Harlingen to Minneapolis. We will then identify 
# the different phases of the flight, and plot it together with altitude values.
# Note that when retrieving the state vectors, the username and password should 
# be substituted by your own, for which you should have received authorization 
# to access the OpenSky Trino interface

## Not run: 
state_vectors &lt;- getIntervalStateVectors(aircraft = "ab3da7",
                                         startTime = "2021-12-12 04:20:00",
                                         endTime = "2021-12-12 07:40:00",
                                         username="your_username",
                                         password="your_password")

flights &lt;- state_vectors$split_into_flights()
length(flights)

# Only one flight identified in the time period, as expected

flight &lt;- flights[[1]]

# Let's extract the data required for detection of flight phases

data &lt;- flight$state_vectors$get_values(c("requested_time", "baro_altitude",
                                          "vertical_rate", "velocity"))
data$requested_time &lt;- data$requested_time - data$requested_time[1]

# We can now identify flight phases. We will use a time window of 60 s

phases &lt;- findFlightPhases(times=data$requested_time,
                           altitudes=data$baro_altitude,
                           verticalRates=data$vertical_rate,
                           speeds=data$velocity,
                           window=60)

# We can now plot the phases together with the altitude values

library(ggplot2)
data &lt;- cbind(data, phases)
ggplot(data[!is.na(data$baro_altitude), ], aes(x = requested_time, y = baro_altitude)) +
    geom_line() +
    geom_point(aes(color=phases))     

## End(Not run)
</code></pre>

<hr>
<h2 id='getAircraftFlights'>Retrieve flights performed by a specified aircraft during a time interval
</h2><span id='topic+getAircraftFlights'></span>

<h3>Description</h3>

<p>Retrieves the list of flights registered for a specified aircraft during a given
time interval. The aircraft must be specified using its ICAO 24-bit address.
Beginning and end times must be specified as date-time strings in any format 
that can be unambiguously converted to POSIXct (such as YYYY-MM-DD HH:MM:SS).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAircraftFlights(aircraft, startTime, endTime, timeZone=Sys.timezone(), 
                   username=NULL, password=NULL, includeStateVectors=FALSE, 
                   timeResolution=NULL, useTrino=FALSE, 
                   includeAirportsMetadata=FALSE, timeOut=60, maxQueryAttempts=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getAircraftFlights_+3A_aircraft">aircraft</code></td>
<td>
<p>string with the ICAO 24-bit address of an aircraft (for 
example, \&quot;346190\&quot; for Air Nostrum EC-NCD (ATR 72-600).
</p>
</td></tr>
<tr><td><code id="getAircraftFlights_+3A_starttime">startTime</code></td>
<td>
<p>date-time string indicating the starting time of the interval 
for which flights should be retrieved. Must be in a format that can be 
unambiguously converted into POSIXct time. Valid examples are
\&quot;2011-03-27 01:30:00\&quot; and \&quot;2011/03/27 01:30:00\&quot;.
</p>
</td></tr>
<tr><td><code id="getAircraftFlights_+3A_endtime">endTime</code></td>
<td>
<p>date-time string indicating the ending time of the interval for
which flights should be retrieved. Must be in a format that can be 
unambiguously converted into POSIXct time. Valid examples are
\&quot;2011-03-28 01:30:00\&quot; and \&quot;2011/03/28 01:30:00\&quot;.
</p>
</td></tr>
<tr><td><code id="getAircraftFlights_+3A_timezone">timeZone</code></td>
<td>
<p>string with the name of the time zone for startTime and 
endTime. For details on supported time zones, see help(timezones). By default,
the system time zone is used.
</p>
</td></tr>
<tr><td><code id="getAircraftFlights_+3A_username">username</code></td>
<td>
<p>optional string with the username to use for authentication
for the OpenSky API. By default, no authentication is performed.
</p>
</td></tr>
<tr><td><code id="getAircraftFlights_+3A_password">password</code></td>
<td>
<p>optional string with the password to use for authentication
for the OpenSky API. By default, no authentication is performed.
</p>
</td></tr>
<tr><td><code id="getAircraftFlights_+3A_includestatevectors">includeStateVectors</code></td>
<td>
<p>logical indicating if the set of state vectors for
each flight should also be retrieved. By default, state vectors are not
retrieved.
</p>
</td></tr>
<tr><td><code id="getAircraftFlights_+3A_timeresolution">timeResolution</code></td>
<td>
<p>time resolution in seconds with which state vectors
should be retrieved if <code>includeStateVectors=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="getAircraftFlights_+3A_usetrino">useTrino</code></td>
<td>
<p>logical indicating whether or not to use the OpenSky
Trino query interface instead of the API to retrieve state vectors if <code>includeStateVectors=TRUE</code>. If used, the provided 
username and password are used for the Trino connection. By default, the Trino interface
is not used.
</p>
</td></tr>
<tr><td><code id="getAircraftFlights_+3A_includeairportsmetadata">includeAirportsMetadata</code></td>
<td>
<p>logical indicating if the data about the origin and destination
airports of each flight should also be retrieved. If not, only the ICAO24 code of the airports will be
included.
</p>
</td></tr>
<tr><td><code id="getAircraftFlights_+3A_timeout">timeOut</code></td>
<td>
<p>number of seconds after which the query will time out and return
a NULL result. In the default behavior, timeout will be reached after 60 seconds.
</p>
</td></tr>
<tr><td><code id="getAircraftFlights_+3A_maxqueryattempts">maxQueryAttempts</code></td>
<td>
<p>On rare occassions, queries to the OpenSky Network
live API can return malformed responses. This is the maximum number of attempts 
to obtain a properly formatted response when carrying out the requested query. 
It should be noted that the query will still terminate if a timeout is reached.
In the default behavior, a single attempt will be performed. It is not recommended
to change this to a very large number, since it can lead to long running times.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of objects of class <code><a href="#topic+openSkiesFlight">openSkiesFlight</a></code>, where each object
represents a flight that was performed by the specified aircraft during the
specified time interval. See the <code><a href="#topic+openSkiesFlight">openSkiesFlight</a></code> documentation 
for details on the fields for the class.
</p>


<h3>References</h3>

<p>https://opensky-network.org/apidoc/rest.html
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Obtain a list with information for all the flights registered for the aircraft
# with ICAO 24-bit address 346190 during the 26th of July, 2019.

if(interactive()){
getAircraftFlights("346190", startTime="2019-07-26 00:00:00", 
endTime="2019-07-26 23:59:59", timeZone="Europe/Madrid")
}
</code></pre>

<hr>
<h2 id='getAircraftMetadata'>Retrieve metadata for a specified aircraft
</h2><span id='topic+getAircraftMetadata'></span>

<h3>Description</h3>

<p>Retrieves the available metadata for a specified aircraft. These include the
registration ID for the aircraft, as well as information about its manufacturer,
owner, operator and country of registration, among others. A single aircraft 
must be specified using its ICAO 24-bit address.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAircraftMetadata(aircraft, timeOut=60, maxQueryAttempts=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getAircraftMetadata_+3A_aircraft">aircraft</code></td>
<td>
<p>string with the ICAO 24-bit address of an aircraft (for 
example, \&quot;3c6444\&quot; for Lufthansa D-AIBD (Airbus A319).
</p>
</td></tr>
<tr><td><code id="getAircraftMetadata_+3A_timeout">timeOut</code></td>
<td>
<p>number of seconds after which the query will time out and return
a NULL result. In the default behavior, timeout will be reached after 60 seconds.
</p>
</td></tr>
<tr><td><code id="getAircraftMetadata_+3A_maxqueryattempts">maxQueryAttempts</code></td>
<td>
<p>Maximum number of attempts that will be performed when
carrying out the requested query. Failed attempts include timeouts. In the
default behavior, a single attempt will be performed. It should be noted
that setting a large number of maximum attempts can lead to long running
times.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+openSkiesAircraft">openSkiesAircraft</a></code>. See the <code><a href="#topic+openSkiesAirport">openSkiesAirport</a></code>
documentation for details on the fields for the class.
</p>


<h3>References</h3>

<p>https://www.icao.int/publications/doc8643/pages/search.aspx
</p>
<p>https://www.eurocontrol.int/sites/default/files/content/documents/nm/asterix/archives/asterix-cat021-asterix-ads-b-messages-part-12-v1.4-072009.pdf
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Obtain metadata for the aircraft with ICAO 24-bit address 3922e2 

if(interactive()){
getAircraftMetadata("3922e2")
}
</code></pre>

<hr>
<h2 id='getAircraftStateVectorsSeries'>Retrieve a series of state vectors received from a specified aircraft
during a given time interval
</h2><span id='topic+getAircraftStateVectorsSeries'></span>

<h3>Description</h3>

<p>Retrieves a time series o state vectors received from a specified aircraft 
during a given time interval. A state vector is a collection of data elements 
that characterize the status of an aircraft at a given point during a flight 
(such as latitude, longitude, altitude, etc.)
</p>
<p>The time point must be specified as a date-time string in any format that can be 
unambiguously converted to POSIXct (such as YYYY-MM-DD HH:MM:SS). Time 
resolution for the time series of state vectors must be specified in seconds.
Time resolution is limited to 10 s for anonymous users, and 5 s for registered
users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAircraftStateVectorsSeries(aircraft, startTime, endTime, 
                              timeZone=Sys.timezone(), timeResolution, 
                              username=NULL, password=NULL,
                              useTrino=FALSE, timeOut=60, maxQueryAttempts=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getAircraftStateVectorsSeries_+3A_aircraft">aircraft</code></td>
<td>
<p>string with the ICAO 24-bit address of an aircraft (for 
example, \&quot;346190\&quot; for Air Nostrum EC-NCD (ATR 72-600), or a character vector
with multiple ICAO 24-bit addresses. In the default behavior, data is 
retrieved for any aircraft.
</p>
</td></tr>
<tr><td><code id="getAircraftStateVectorsSeries_+3A_starttime">startTime</code></td>
<td>
<p>date-time string indicating the starting time of the interval 
for which state vectors should be retrieved. Must be in a format that can be 
unambiguously converted into POSIXct time. Valid examples are
\&quot;2011-03-27 01:30:00\&quot; and \&quot;2011/03/27 01:30:00\&quot;.
</p>
</td></tr>
<tr><td><code id="getAircraftStateVectorsSeries_+3A_endtime">endTime</code></td>
<td>
<p>date-time string indicating the ending time of the interval for
which state vectors should be retrieved. Must be in a format that can be 
unambiguously converted into POSIXct time. Valid examples are
\&quot;2011-03-28 01:30:00\&quot; and \&quot;2011/03/28 01:30:00\&quot;.
</p>
</td></tr>
<tr><td><code id="getAircraftStateVectorsSeries_+3A_timezone">timeZone</code></td>
<td>
<p>string with the name of the time zone for time. For details on
supported time zones, see help(timezones). By default, the system time zone is
used.
</p>
</td></tr>
<tr><td><code id="getAircraftStateVectorsSeries_+3A_timeresolution">timeResolution</code></td>
<td>
<p>time resolution in seconds to be used for the requested 
timeseries of state vectors. Limited to 5 s for anonymous users and 10 s for
registered users.
</p>
</td></tr>
<tr><td><code id="getAircraftStateVectorsSeries_+3A_username">username</code></td>
<td>
<p>optional string with the username to use for authentication
for the OpenSky API. By default, no authentication is performed.
</p>
</td></tr>
<tr><td><code id="getAircraftStateVectorsSeries_+3A_password">password</code></td>
<td>
<p>optional string with the password to use for authentication
for the OpenSky API. By default, no authentication is performed.
</p>
</td></tr>
<tr><td><code id="getAircraftStateVectorsSeries_+3A_usetrino">useTrino</code></td>
<td>
<p>logical indicating whether or not to use the OpenSky
Trino query interface instead of the API to retrieve state vectors. If used, the provided 
username and password are used for the Trino connection. By default, the Trino interface
is not used.
</p>
</td></tr>
<tr><td><code id="getAircraftStateVectorsSeries_+3A_timeout">timeOut</code></td>
<td>
<p>number of seconds after which the query will time out and return
a NULL result. In the default behavior, timeout will be reached after 60 seconds.
</p>
</td></tr>
<tr><td><code id="getAircraftStateVectorsSeries_+3A_maxqueryattempts">maxQueryAttempts</code></td>
<td>
<p>On rare occassions, queries to the OpenSky Network
live API can return malformed responses. This is the maximum number of attempts 
to obtain a properly formatted response when carrying out the requested query. 
It should be noted that the query will still terminate if a timeout is reached.
In the default behavior, a single attempt will be performed. It is not recommended
to change this to a very large number, since it can lead to long running times.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code><a href="#topic+openSkiesStateVectorSet">openSkiesStateVectorSet</a></code> object with field <code>time_series=TRUE</code>.
For details on the information stored in state vectors, see the documentation for
<code><a href="#topic+openSkiesStateVector">openSkiesStateVector</a></code> and <code><a href="#topic+openSkiesStateVectorSet">openSkiesStateVectorSet</a></code>.
</p>


<h3>References</h3>

<p>https://opensky-network.org/apidoc/rest.html
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Obtain a time series of state vectors for the aircraft with ICAO 24-bit 
# address 403003 for the 8th of October, 2020 between 16:50 and 16:53 (London
# time), with a time resolution of 1 minute.

if(interactive()){
getAircraftStateVectorsSeries("403003", startTime = "2020-10-08 16:50:00", 
endTime = "2020-10-08 16:52:00", timeZone="Europe/London", timeResolution=60)
}
</code></pre>

<hr>
<h2 id='getAirportArrivals'>Retrieve flight arrivals into a specified airport
</h2><span id='topic+getAirportArrivals'></span>

<h3>Description</h3>

<p>Retrieves the list of flights that landed into a specified airport during a
certain time interval. The aiport must be specified using its ICAO identified.
Beginning and end times must be specified as date-time strings in any format 
that can be unambiguously converted to POSIXct (such as YYYY-MM-DD HH:MM:SS).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAirportArrivals(airport, startTime, endTime, timeZone=Sys.timezone(), 
                   username=NULL, password=NULL, includeStateVectors=FALSE, 
                   timeResolution=NULL, useTrino=FALSE, 
                   includeAirportsMetadata=FALSE, timeOut=60, maxQueryAttempts=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getAirportArrivals_+3A_airport">airport</code></td>
<td>
<p>string with the ICAO identifier of an airport (for example,
\&quot;EDDF\&quot; for Frankfurt International Airport.
</p>
</td></tr>
<tr><td><code id="getAirportArrivals_+3A_starttime">startTime</code></td>
<td>
<p>date-time string indicating the starting time of the interval 
for which arrivals should be retrieved. Must be in a format that can be 
unambiguously converted into POSIXct time. Valid examples are
\&quot;2011-03-27 01:30:00\&quot; and \&quot;2011/03/27 01:30:00\&quot;.
</p>
</td></tr>
<tr><td><code id="getAirportArrivals_+3A_endtime">endTime</code></td>
<td>
<p>date-time string indicating the ending time of the interval for
which arrivals should be retrieved. Must be in a format that can be 
unambiguously converted into POSIXct time. Valid examples are
\&quot;2011-03-28 01:30:00\&quot; and \&quot;2011/03/28 01:30:00\&quot;.
</p>
</td></tr>
<tr><td><code id="getAirportArrivals_+3A_timezone">timeZone</code></td>
<td>
<p>string with the name of the time zone for startTime and 
endTime. For details on supported time zones, see help(timezones). By default,
the system time zone is used.
</p>
</td></tr>
<tr><td><code id="getAirportArrivals_+3A_username">username</code></td>
<td>
<p>optional string with the username to use for authentication
for the OpenSky API. By default, no authentication is performed.
</p>
</td></tr>
<tr><td><code id="getAirportArrivals_+3A_password">password</code></td>
<td>
<p>optional string with the password to use for authentication
for the OpenSky API. By default, no authentication is performed.
</p>
</td></tr>
<tr><td><code id="getAirportArrivals_+3A_includestatevectors">includeStateVectors</code></td>
<td>
<p>logical indicating if the set of state vectors for
each flight should also be retrieved. By default, state vectors are not
retrieved.
</p>
</td></tr>
<tr><td><code id="getAirportArrivals_+3A_timeresolution">timeResolution</code></td>
<td>
<p>time resolution in seconds with which state vectors
should be retrieved if <code>includeStateVectors=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="getAirportArrivals_+3A_usetrino">useTrino</code></td>
<td>
<p>logical indicating whether or not to use the OpenSky
Trino query interface instead of the API to retrieve state vectors if <code>includeStateVectors=TRUE</code>. If used, the provided 
username and password are used for the Trino connection. By default, the Trino interface
is not used.
</p>
</td></tr>
<tr><td><code id="getAirportArrivals_+3A_includeairportsmetadata">includeAirportsMetadata</code></td>
<td>
<p>logical indicating if the data about the origin and destination
airports of each flight should also be retrieved. If not, only the ICAO24 code of the airports will be
included.
</p>
</td></tr>
<tr><td><code id="getAirportArrivals_+3A_timeout">timeOut</code></td>
<td>
<p>number of seconds after which the query will time out and return
a NULL result. In the default behavior, timeout will be reached after 60 seconds.
</p>
</td></tr>
<tr><td><code id="getAirportArrivals_+3A_maxqueryattempts">maxQueryAttempts</code></td>
<td>
<p>On rare occassions, queries to the OpenSky Network
live API can return malformed responses. This is the maximum number of attempts 
to obtain a properly formatted response when carrying out the requested query. 
It should be noted that the query will still terminate if a timeout is reached.
In the default behavior, a single attempt will be performed. It is not recommended
to change this to a very large number, since it can lead to long running times.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of objects of class <code><a href="#topic+openSkiesFlight">openSkiesFlight</a></code>, where each object
represents a flight that that landed at the specified airport during the 
specified time interval. See the <code><a href="#topic+openSkiesFlight">openSkiesFlight</a></code> documentation 
for details on the fields for the class.
</p>


<h3>References</h3>

<p>https://opensky-network.org/apidoc/rest.html
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Obtain a list with information for all the flights that landed at Frankfurt
# International Airport on the 29th of January, 2018 between 12 PM and 1 PM,
# local time.

if(interactive()){
getAirportArrivals(airport="EDDF", startTime="2018-01-29 12:00:00", 
endTime="2018-01-29 13:00:00", timeZone="Europe/Berlin")
}
</code></pre>

<hr>
<h2 id='getAirportDepartures'>Retrieve flight departures from a specified airport
</h2><span id='topic+getAirportDepartures'></span>

<h3>Description</h3>

<p>Retrieves the list of flights that departed from a specified airport during a
certain time interval. The aiport must be specified using its ICAO identified.
Beginning and end times must be specified as date-time strings in any format 
that can be unambiguously converted to POSIXct (such as YYYY-MM-DD HH:MM:SS).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAirportDepartures(airport, startTime, endTime, timeZone=Sys.timezone(), 
                     username=NULL, password=NULL, includeStateVectors=FALSE, 
                     timeResolution=NULL, useTrino=FALSE, 
                     includeAirportsMetadata=FALSE, timeOut=60, maxQueryAttempts=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getAirportDepartures_+3A_airport">airport</code></td>
<td>
<p>string with the ICAO identifier of an airport (for example,
\&quot;LEZL\&quot; for Seville Airport.
</p>
</td></tr>
<tr><td><code id="getAirportDepartures_+3A_starttime">startTime</code></td>
<td>
<p>date-time string indicating the starting time of the interval 
for which departures should be retrieved. Must be in a format that can be 
unambiguously converted into POSIXct time. Valid examples are
\&quot;2011-03-27 01:30:00\&quot; and \&quot;2011/03/27 01:30:00\&quot;.
</p>
</td></tr>
<tr><td><code id="getAirportDepartures_+3A_endtime">endTime</code></td>
<td>
<p>date-time string indicating the ending time of the interval for
which departures should be retrieved. Must be in a format that can be 
unambiguously converted into POSIXct time. Valid examples are
\&quot;2011-03-28 01:30:00\&quot; and \&quot;2011/03/28 01:30:00\&quot;.
</p>
</td></tr>
<tr><td><code id="getAirportDepartures_+3A_timezone">timeZone</code></td>
<td>
<p>string with the name of the time zone for startTime and 
endTime. For details on supported time zones, see help(timezones). By default,
the system time zone is used.
</p>
</td></tr>
<tr><td><code id="getAirportDepartures_+3A_username">username</code></td>
<td>
<p>optional string with the username to use for authentication
for the OpenSky API. By default, no authentication is performed.
</p>
</td></tr>
<tr><td><code id="getAirportDepartures_+3A_password">password</code></td>
<td>
<p>optional string with the password to use for authentication
for the OpenSky API. By default, no authentication is performed.
</p>
</td></tr>
<tr><td><code id="getAirportDepartures_+3A_includestatevectors">includeStateVectors</code></td>
<td>
<p>logical indicating if the set of state vectors for
each flight should also be retrieved. By default, state vectors are not
retrieved.
</p>
</td></tr>
<tr><td><code id="getAirportDepartures_+3A_timeresolution">timeResolution</code></td>
<td>
<p>time resolution in seconds with which state vectors
should be retrieved if <code>includeStateVectors=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="getAirportDepartures_+3A_usetrino">useTrino</code></td>
<td>
<p>logical indicating whether or not to use the OpenSky
Trino query interface instead of the API to retrieve state vectors if <code>includeStateVectors=TRUE</code>. If used, the provided 
username and password are used for the Trino connection. By default, the Trino interface
is not used.
</p>
</td></tr>
<tr><td><code id="getAirportDepartures_+3A_includeairportsmetadata">includeAirportsMetadata</code></td>
<td>
<p>logical indicating if the data about the origin and destination
airports of each flight should also be retrieved. If not, only the ICAO24 code of the airports will be
included.
</p>
</td></tr>
<tr><td><code id="getAirportDepartures_+3A_timeout">timeOut</code></td>
<td>
<p>number of seconds after which the query will time out and return
a NULL result. In the default behavior, timeout will be reached after 60 seconds.
</p>
</td></tr>
<tr><td><code id="getAirportDepartures_+3A_maxqueryattempts">maxQueryAttempts</code></td>
<td>
<p>On rare occassions, queries to the OpenSky Network
live API can return malformed responses. This is the maximum number of attempts 
to obtain a properly formatted response when carrying out the requested query. 
It should be noted that the query will still terminate if a timeout is reached.
In the default behavior, a single attempt will be performed. It is not recommended
to change this to a very large number, since it can lead to long running times.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of objects of class <code><a href="#topic+openSkiesFlight">openSkiesFlight</a></code>, where each object
represents a flight that that departed from the specified airport during the 
specified time interval. See the <code><a href="#topic+openSkiesFlight">openSkiesFlight</a></code> documentation 
for details on the fields for the class.
</p>


<h3>References</h3>

<p>https://opensky-network.org/apidoc/rest.html
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Obtain a list with information for all the flights that departed from Seville
# Airport on the 25th of July, 2019 between 9 AM and 11 AM, local time.

if(interactive()){
getAirportDepartures(airport="LEZL", startTime="2019-07-25 09:00:00", 
endTime="2019-07-25 11:00:00", timeZone="Europe/Madrid")
}
</code></pre>

<hr>
<h2 id='getAirportMetadata'>Retrieve metadata for a specified airport
</h2><span id='topic+getAirportMetadata'></span>

<h3>Description</h3>

<p>Retrieves the available metadata for a specified airport. These include its
IATA code, common name and location, among others. A single airport  must be 
specified using its ICAO code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAirportMetadata(airport, timeOut=60, maxQueryAttempts=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getAirportMetadata_+3A_airport">airport</code></td>
<td>
<p>string with the ICAO 4-letter code of an airport (for 
example, \&quot;LEZL\&quot; for Sevilla Airport.
</p>
</td></tr>
<tr><td><code id="getAirportMetadata_+3A_timeout">timeOut</code></td>
<td>
<p>number of seconds after which the query will time out and return
a NULL result. In the default behavior, timeout will be reached after 60 seconds.
</p>
</td></tr>
<tr><td><code id="getAirportMetadata_+3A_maxqueryattempts">maxQueryAttempts</code></td>
<td>
<p>On rare occassions, queries to the OpenSky Network
live API can return malformed responses. This is the maximum number of attempts 
to obtain a properly formatted response when carrying out the requested query. 
It should be noted that the query will still terminate if a timeout is reached.
In the default behavior, a single attempt will be performed. It is not recommended
to change this to a very large number, since it can lead to long running times.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+openSkiesAirport">openSkiesAirport</a></code>. See the <code><a href="#topic+openSkiesAirport">openSkiesAirport</a></code>
documentation for details on the fields for the class.
</p>


<h3>References</h3>

<p>https://en.wikipedia.org/wiki/List_of_airports_by_IATA_and_ICAO_code
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Obtain metadata for the airport with ICAO code LEZL

if(interactive()){
getAirportMetadata("LEZL")
}
</code></pre>

<hr>
<h2 id='getIntervalFlights'>Retrieve all flights registered during a time interval
</h2><span id='topic+getIntervalFlights'></span>

<h3>Description</h3>

<p>Retrieves the list of all flights registered for any aircraft during a given
time interval. Beginning and end times must be specified as date-time strings in 
any format that can be unambiguously converted to POSIXct (such as 
YYYY-MM-DD HH:MM:SS).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getIntervalFlights(startTime, endTime, timeZone=Sys.timezone(), username=NULL, 
                   password=NULL, includeStateVectors=FALSE, 
                   timeResolution=NULL, useTrino=FALSE, 
                   includeAirportsMetadata=FALSE, timeOut=60, maxQueryAttempts=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getIntervalFlights_+3A_starttime">startTime</code></td>
<td>
<p>date-time string indicating the starting time of the interval 
for which flights should be retrieved. Must be in a format that can be 
unambiguously converted into POSIXct time. Valid examples are
\&quot;2011-03-27 01:30:00\&quot; and \&quot;2011/03/27 01:30:00\&quot;.
</p>
</td></tr>
<tr><td><code id="getIntervalFlights_+3A_endtime">endTime</code></td>
<td>
<p>date-time string indicating the ending time of the interval for
which flights should be retrieved. Must be in a format that can be 
unambiguously converted into POSIXct time. Valid examples are
\&quot;2011-03-28 01:30:00\&quot; and \&quot;2011/03/28 01:30:00\&quot;.
</p>
</td></tr>
<tr><td><code id="getIntervalFlights_+3A_timezone">timeZone</code></td>
<td>
<p>string with the name of the time zone for startTime and 
endTime. For details on supported time zones, see help(timezones). By default,
the system time zone is used.
</p>
</td></tr>
<tr><td><code id="getIntervalFlights_+3A_username">username</code></td>
<td>
<p>optional string with the username to use for authentication
for the OpenSky API. By default, no authentication is performed.
</p>
</td></tr>
<tr><td><code id="getIntervalFlights_+3A_password">password</code></td>
<td>
<p>optional string with the password to use for authentication
for the OpenSky API. By default, no authentication is performed.
</p>
</td></tr>
<tr><td><code id="getIntervalFlights_+3A_includestatevectors">includeStateVectors</code></td>
<td>
<p>logical indicating if the set of state vectors for
each flight should also be retrieved. By default, state vectors are not
retrieved.
</p>
</td></tr>
<tr><td><code id="getIntervalFlights_+3A_timeresolution">timeResolution</code></td>
<td>
<p>time resolution in seconds with which state vectors
should be retrieved if <code>includeStateVectors=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="getIntervalFlights_+3A_usetrino">useTrino</code></td>
<td>
<p>logical indicating whether or not to use the OpenSky
Trino query interface instead of the API to retrieve state vectors if <code>includeStateVectors=TRUE</code>. If used, the provided 
username and password are used for the Trino connection. By default, the Trino interface
is not used.
</p>
</td></tr>
<tr><td><code id="getIntervalFlights_+3A_includeairportsmetadata">includeAirportsMetadata</code></td>
<td>
<p>logical indicating if the data about the origin and destination
airports of each flight should also be retrieved. If not, only the ICAO24 code of the airports will be
included.
</p>
</td></tr>
<tr><td><code id="getIntervalFlights_+3A_timeout">timeOut</code></td>
<td>
<p>number of seconds after which the query will time out and return
a NULL result. In the default behavior, timeout will be reached after 60 seconds.
</p>
</td></tr>
<tr><td><code id="getIntervalFlights_+3A_maxqueryattempts">maxQueryAttempts</code></td>
<td>
<p>On rare occassions, queries to the OpenSky Network
live API can return malformed responses. This is the maximum number of attempts 
to obtain a properly formatted response when carrying out the requested query. 
It should be noted that the query will still terminate if a timeout is reached.
In the default behavior, a single attempt will be performed. It is not recommended
to change this to a very large number, since it can lead to long running times.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of objects of class <code><a href="#topic+openSkiesFlight">openSkiesFlight</a></code>, where each object
represents a flight that was registered during the specified time interval. See 
the <code><a href="#topic+openSkiesFlight">openSkiesFlight</a></code> documentation for details on the fields for 
the class.
</p>


<h3>References</h3>

<p>https://opensky-network.org/apidoc/rest.html
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
# Obtain a list with information for all the flights registered during the 16th
# of November, 2019 between 9 AM and 10 AM, London time.

flights &lt;- getIntervalFlights(startTime="2019-11-16 09:00:00", 
endTime="2019-11-16 10:00:00", timeZone="Europe/London")

# Count the number of registered flights.

length(flights)
}
</code></pre>

<hr>
<h2 id='getIntervalStateVectors'>Retrieve all state vectors received during a time interval
</h2><span id='topic+getIntervalStateVectors'></span>

<h3>Description</h3>

<p>Retrieves the list of all state vectors received from any or specified aircrafts
during an interval of time. A state vector is a collection of data elements that
characterize the status of an aircraft at a given point during a flight (such
as latitude, longitude, altitude, etc.)
</p>
<p>The starting and end time points must be specified as date-time strings in any 
format that can be  unambiguously converted to POSIXct (such as 
YYYY-MM-DD HH:MM:SS). Results can be filtered to specific ranges of latitudes 
and/or longitudes. This function requires access to the OpenSky Network Trino
query interface, and therefore can only be used by registered users that have been 
granted access to the Trino interface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getIntervalStateVectors(aircraft=NULL, startTime, endTime,
                        timeZone=Sys.timezone(), minLatitude=NULL, 
                        maxLatitude=NULL, minLongitude=NULL, maxLongitude=NULL,
                        minBaroAltitude=NULL, maxBaroAltitude=NULL,
                        minGeoAltitude=NULL, maxGeoAltitude=NULL,
                        minVelocity=NULL, maxVelocity=NULL,
                        minVerticalRate=NULL, maxVerticalRate=NULL,
                        callSignFilter=NULL, onGroundStatus=NULL,
                        squawkFilter=NULL, spiStatus=NULL, alertStatus=NULL,
                        username, password)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getIntervalStateVectors_+3A_aircraft">aircraft</code></td>
<td>
<p>string with the ICAO 24-bit address of an aircraft (for 
example, \&quot;346190\&quot; for Air Nostrum EC-NCD (ATR 72-600), or a character vector
with multiple ICAO 24-bit addresses. In the default behavior, data is 
retrieved for any aircraft.
</p>
</td></tr>
<tr><td><code id="getIntervalStateVectors_+3A_starttime">startTime</code></td>
<td>
<p>date-time string indicating the starting time point of the
interval for which state vectors should be retrieved. Must be in a format that 
can be unambiguously converted into POSIXct time. Valid examples are 
\&quot;2011-03-28 01:30:00\&quot; and \&quot;2011/03/28 01:30:00\&quot;.
</p>
</td></tr>
<tr><td><code id="getIntervalStateVectors_+3A_endtime">endTime</code></td>
<td>
<p>date-time string indicating the end time point of the interval 
for which state vectors should be retrieved. Must be in a format that can be 
unambiguously converted into POSIXct time. Valid examples are 
\&quot;2011-03-28 01:30:00\&quot; and \&quot;2011/03/28 01:30:00\&quot;.
</p>
</td></tr>
<tr><td><code id="getIntervalStateVectors_+3A_timezone">timeZone</code></td>
<td>
<p>string with the name of the time zone for time. For details on
supported time zones, see help(timezones). By default, the system time zone is
used.
</p>
</td></tr>
<tr><td><code id="getIntervalStateVectors_+3A_minlatitude">minLatitude</code></td>
<td>
<p>minimum latitude to filter the retrieved state vectors.
Must be a value between -180 and 180. Negative values denote south latitudes,
and positive values denote north latitudes. By default, no filtering based on
location is performed.
</p>
</td></tr>
<tr><td><code id="getIntervalStateVectors_+3A_maxlatitude">maxLatitude</code></td>
<td>
<p>maximum latitude to filter the retrieved state vectors.
Must be a value between -180 and 180. Negative values denote south latitudes,
and positive values denote north latitudes. By default, no filtering based on
location is performed.
</p>
</td></tr>
<tr><td><code id="getIntervalStateVectors_+3A_minlongitude">minLongitude</code></td>
<td>
<p>minimum longitude to filter the retrieved state vectors.
Must be a value between -180 and 180. Negative values denote west longitudes,
and positive values denote east longitudes. By default, no filtering based on
location is performed.
</p>
</td></tr>
<tr><td><code id="getIntervalStateVectors_+3A_maxlongitude">maxLongitude</code></td>
<td>
<p>maximum longitude to filter the retrieved state vectors.
Must be a value between -180 and 180. Negative values denote west longitudes,
and positive values denote east longitudes. By default, no filtering based on
location is performed.
</p>
</td></tr>
<tr><td><code id="getIntervalStateVectors_+3A_minbaroaltitude">minBaroAltitude</code></td>
<td>
<p>minimum barometric altitude to filter the retrieved 
state vectors. By default, no filtering based on barometric altitude is 
performed.
</p>
</td></tr>
<tr><td><code id="getIntervalStateVectors_+3A_maxbaroaltitude">maxBaroAltitude</code></td>
<td>
<p>maximum barometric altitude to filter the retrieved 
state vectors. By default, no filtering based on barometric altitude is 
performed.
</p>
</td></tr>
<tr><td><code id="getIntervalStateVectors_+3A_mingeoaltitude">minGeoAltitude</code></td>
<td>
<p>minimum geometric altitude to filter the retrieved 
state vectors. By default, no filtering based on geometric altitude is 
performed. It should be noted that geometric altitude is included in state
vectors less frequently than barometric altitude.
</p>
</td></tr>
<tr><td><code id="getIntervalStateVectors_+3A_maxgeoaltitude">maxGeoAltitude</code></td>
<td>
<p>maximum geometric altitude to filter the retrieved 
state vectors. By default, no filtering based on geometric altitude is 
performed. It should be noted that geometric altitude is included in state
vectors less frequently than barometric altitude.
</p>
</td></tr>
<tr><td><code id="getIntervalStateVectors_+3A_minvelocity">minVelocity</code></td>
<td>
<p>minimum velocity to filter the retrieved state vectors. 
By default, no filtering based on velocity is performed.
</p>
</td></tr>
<tr><td><code id="getIntervalStateVectors_+3A_maxvelocity">maxVelocity</code></td>
<td>
<p>maximum velocity to filter the retrieved state vectors. 
By default, no filtering based on velocity is performed.
</p>
</td></tr>
<tr><td><code id="getIntervalStateVectors_+3A_minverticalrate">minVerticalRate</code></td>
<td>
<p>minimum vertical rate to filter the retrieved state 
vectors. Ascending aircrafts have positive vertical rate values, while
descending aircrafts have negative values. By default, no filtering based on 
vertical rate is performed.
</p>
</td></tr>
<tr><td><code id="getIntervalStateVectors_+3A_maxverticalrate">maxVerticalRate</code></td>
<td>
<p>maximum vertical rate to filter the retrieved state 
vectors. Ascending aircrafts have positive vertical rate values, while
descending aircrafts have negative values. By default, no filtering based on 
vertical rate is performed.
</p>
</td></tr>
<tr><td><code id="getIntervalStateVectors_+3A_callsignfilter">callSignFilter</code></td>
<td>
<p>string or character vector specifying one or more call
signs that will be used to filter the results of the query, returning only
those that match the specified values. By default, no filtering based on 
call sign is performed.
</p>
</td></tr>
<tr><td><code id="getIntervalStateVectors_+3A_ongroundstatus">onGroundStatus</code></td>
<td>
<p>logical indicating if the results should be filtered to
return only state vectors with an on_ground state of TRUE or FALSE (usually,
corresponding respectively to planes on air or on land). By default, no 
filtering based on on_ground status is performed.
</p>
</td></tr>
<tr><td><code id="getIntervalStateVectors_+3A_squawkfilter">squawkFilter</code></td>
<td>
<p>string or character vector specifying one or more squawk
codes that will be used to filter the results of the query, returning only
those that match the specified values. By default, no filtering based on 
call sign is performed. Each specified squawk code should be a 4-character
string, containing only digits from 0 to 7. It should be noted that the
meaning of most squawk codes is not universally defined. Only the three
following codes are applicable worldwide: 7500 (hijacked aircraft), 7600
(radio failure) and 7700 (emergency situation). For additional details, see
https://en.wikipedia.org/wiki/List_of_transponder_codes
</p>
</td></tr>
<tr><td><code id="getIntervalStateVectors_+3A_spistatus">spiStatus</code></td>
<td>
<p>logical indicating if the results should be filtered to
return only state vectors where the SPI (Special Purpose Identification) was
turned on (TRUE) or not (FALSE). By default, no filtering based on emission of
SPI pulse is performed. For details, see 
https://www.faa.gov/documentLibrary/media/Order/FAA_Order_6365.1A.pdf
</p>
</td></tr>
<tr><td><code id="getIntervalStateVectors_+3A_alertstatus">alertStatus</code></td>
<td>
<p>logical indicating if the results should be filtered to
return only state vectors with the alert flag on (TRUE) or not (FALSE). By 
default, no filtering based on the alert flag is performed. For details, see
https://www.faa.gov/documentLibrary/media/Order/FAA_Order_6365.1A.pdf
</p>
</td></tr>
<tr><td><code id="getIntervalStateVectors_+3A_username">username</code></td>
<td>
<p>string with the username to use for authentication for the 
OpenSky Trino interface. The user must have been granted access to the Trino interface.
</p>
</td></tr>
<tr><td><code id="getIntervalStateVectors_+3A_password">password</code></td>
<td>
<p>string with the password to use for authentication for the 
OpenSky Trino interface. The user must have been granted access to the Trino interface.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code><a href="#topic+openSkiesStateVectorSet">openSkiesStateVectorSet</a></code> object with field <code>time_series=FALSE</code>,
which contains all the state vectors that matched the query parameters.
For details on the information stored in state vectors, see the documentation for
<code><a href="#topic+openSkiesStateVector">openSkiesStateVector</a></code> and <code><a href="#topic+openSkiesStateVectorSet">openSkiesStateVectorSet</a></code>.
</p>


<h3>References</h3>

<p>https://opensky-network.org/impala-guide
https://en.wikipedia.org/wiki/List_of_transponder_codes
https://www.faa.gov/documentLibrary/media/Order/FAA_Order_6365.1A.pdf
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Obtain a list with the state vectors for all aircrafts that flew over the city
# of Seville the 21st of July, 2019 between 7 AM and 8 PM Spanish time.
# Note that the username and password should be substituted by your own,
# for which you should have received authorization to access the OpenSky
# Trino query interface

## Not run: 
state_vectors &lt;- getIntervalStateVectors(startTime = "2019-07-21 07:00:00",
                                         endTime = "2019-07-21 20:00:00",
                                         timeZone = "Europe/Madrid",
                                         minLatitude = 37.362796,
                                         minLongitude = -6.019819,
                                         maxLatitude = 37.416954,
                                         maxLongitude = -5.939724,
                                         username="your_username",
                                         password="your_password")
                                         
# Group the state vectors into flights

flights &lt;- state_vectors$split_into_flights()

# Plot the flight paths

paths &lt;- vector(mode = "list", length = length(flights))

for(i in 1:length(flights)) {
  paths[[i]] &lt;- flights[[i]]$state_vectors
}

plotRoutes(paths, pathColors = rainbow(length(flights)))

## End(Not run)
</code></pre>

<hr>
<h2 id='getOSNCoverage'>Retrieve coverage of the OpenSky Network for a given day
</h2><span id='topic+getOSNCoverage'></span>

<h3>Description</h3>

<p>Retrieves the coverage of the OpenSky Network across all regions for a given
day. The date must be specified as a date-time string in any format that can
be unambiguously converted to POSIXct (such as YYYY-MM-DD).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getOSNCoverage(time, timeZone=Sys.timezone(), timeOut=60, maxQueryAttempts=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getOSNCoverage_+3A_time">time</code></td>
<td>
<p>date-time string indicating the day for which coverage should be
retrieved. Must be in a format that can be unambiguously converted into 
POSIXct time. Valid examples are \&quot;2011-03-27\&quot; and \&quot;2011/03/27\&quot;. The
exact time of the day can also be supplied in the date-time string, but 
coverage data is only available with single-day resolution.
</p>
</td></tr>
<tr><td><code id="getOSNCoverage_+3A_timezone">timeZone</code></td>
<td>
<p>string with the name of the time zone for startTime and 
endTime. For details on supported time zones, see help(timezones). By default,
the system time zone is used.
</p>
</td></tr>
<tr><td><code id="getOSNCoverage_+3A_timeout">timeOut</code></td>
<td>
<p>number of seconds after which the query will time out and return
a NULL result. In the default behavior, timeout will be reached after 60 seconds.
</p>
</td></tr>
<tr><td><code id="getOSNCoverage_+3A_maxqueryattempts">maxQueryAttempts</code></td>
<td>
<p>On rare occassions, queries to the OpenSky Network
live API can return malformed responses. This is the maximum number of attempts 
to obtain a properly formatted response when carrying out the requested query. 
It should be noted that the query will still terminate if a timeout is reached.
In the default behavior, a single attempt will be performed. It is not recommended
to change this to a very large number, since it can lead to long running times.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with three columns, named &quot;latitude&quot;, &quot;longitude&quot; and &quot;altitude&quot;.
Each row represents an area of coverage data. The first two columns indicate
the coordinates of the center of each area, which extends 0.1 degrees North and
South and 0.15 degrees East and West from its center. The third column,
&quot;altitude&quot;, indicates the lowest altitude value received for any aircraft in the 
area. This provides an estimate of the coverage for that given area, with lower
values indicating a better coverage since low-flying aircraft are more difficult
to detect due to a higher chance that obstacles can block the line of sight
between the aircraft and the receptors in the area. 
</p>
<p>The &quot;altitude&quot; values are obtained from the barometric altitude sensors, and 
therefore is prone to the same errors as such sensors (e.g., negative altitudes 
might be reported). Areas not covered by any of the rows in the dataframe do not
have any coverage.
</p>


<h3>References</h3>

<p>https://opensky-network.org/forum/questions/640-interpreting-the-response-from-the-coverage-api-endpoint
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Obtain a data frame with coverage of the OpenSky Network for the 13th of
# September, 2020.

if(interactive()){
getOSNCoverage("2020-09-13", timeZone="Europe/London")
}
</code></pre>

<hr>
<h2 id='getRouteMetadata'>Retrieve metadata for a specified route
</h2><span id='topic+getRouteMetadata'></span>

<h3>Description</h3>

<p>Retrieves the available metadata for a specified flight route. These include the 
airports of origin and destination, the operator IATA code and the flight
number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRouteMetadata(route, includeAirportsMetadata=FALSE, timeOut=60, maxQueryAttempts=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getRouteMetadata_+3A_route">route</code></td>
<td>
<p>string with the call sign of a route (for example, &quot;AAL683&quot; for 
American Airlines flight number 683.
</p>
</td></tr>
<tr><td><code id="getRouteMetadata_+3A_includeairportsmetadata">includeAirportsMetadata</code></td>
<td>
<p>logical indicating if the data about the origin and destination
airports of the route should also be retrieved. If not, only the ICAO24 code of the airports will be
included.
</p>
</td></tr>
<tr><td><code id="getRouteMetadata_+3A_timeout">timeOut</code></td>
<td>
<p>number of seconds after which the query will time out and return
a NULL result. In the default behavior, timeout will be reached after 60 seconds.
</p>
</td></tr>
<tr><td><code id="getRouteMetadata_+3A_maxqueryattempts">maxQueryAttempts</code></td>
<td>
<p>On rare occassions, queries to the OpenSky Network
live API can return malformed responses. This is the maximum number of attempts 
to obtain a properly formatted response when carrying out the requested query. 
It should be noted that the query will still terminate if a timeout is reached.
In the default behavior, a single attempt will be performed. It is not recommended
to change this to a very large number, since it can lead to long running times.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+openSkiesRoute">openSkiesRoute</a></code>. See the <code><a href="#topic+openSkiesRoute">openSkiesRoute</a></code>
documentation for details on the fields for the class.
</p>


<h3>References</h3>

<p>https://en.wikipedia.org/wiki/Flight_number
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Obtain metadata for the route with call sign AAL683

if(interactive()){
getRouteMetadata("AAL683")
}
</code></pre>

<hr>
<h2 id='getSingleTimeStateVectors'>Retrieve all state vectors received at a given time point
</h2><span id='topic+getSingleTimeStateVectors'></span>

<h3>Description</h3>

<p>Retrieves the list of all state vectors received from any or specified aircrafts
at a single time point. A state vector is a collection of data elements that
characterize the status of an aircraft at a given point during a flight (such
as latitude, longitude, altitude, etc.)
</p>
<p>The time point must be specified as a date-time string in any format that can be 
unambiguously converted to POSIXct (such as YYYY-MM-DD HH:MM:SS). Results can be 
filtered to specific ranges of latitudes and/or longitudes. The extent of the 
data than can be accessed varies depending on if login details are provided:
* For anonymous users:
+ If no aircraft is specified or multiple aircrafts are specified: 
historical data cannot be retrieved. If a time point was specified, it will
be ignored, and data for current time will be returned.
+ If a single aircraft is specified, historical data can be retrieved.
* For registered users:
+ If no aircraft is specified or multiple aircrafts are specified: 
historical data of up to 1 hour ago from current time can be retrieved.
+ If a single aircraft is specified, historical data can be retrieved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSingleTimeStateVectors(aircraft=NULL, time=NULL, timeZone=Sys.timezone(),
                          minLatitude=NULL, maxLatitude=NULL, minLongitude=NULL,
                          maxLongitude=NULL, username=NULL, password=NULL,
                          useTrino=FALSE, timeOut=60, maxQueryAttempts=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSingleTimeStateVectors_+3A_aircraft">aircraft</code></td>
<td>
<p>string with the ICAO 24-bit address of an aircraft (for 
example, \&quot;346190\&quot; for Air Nostrum EC-NCD (ATR 72-600), or a character vector
with multiple ICAO 24-bit addresses. In the default behavior, data is 
retrieved for any aircraft.
</p>
</td></tr>
<tr><td><code id="getSingleTimeStateVectors_+3A_time">time</code></td>
<td>
<p>date-time string indicating the time point for which state vectors
should be retrieved. Must be in a format that can be  unambiguously converted 
into POSIXct time. Valid examples are \&quot;2011-03-28 01:30:00\&quot; and 
\&quot;2011/03/28 01:30:00\&quot;. If no time point is specified, data is retrieved for
current time.
</p>
</td></tr>
<tr><td><code id="getSingleTimeStateVectors_+3A_timezone">timeZone</code></td>
<td>
<p>string with the name of the time zone for time. For details on
supported time zones, see help(timezones). By default, the system time zone is
used.
</p>
</td></tr>
<tr><td><code id="getSingleTimeStateVectors_+3A_minlatitude">minLatitude</code></td>
<td>
<p>minimum latitude to filter the retrieved state vectors.
Must be a value between -180 and 180. Negative values denote south latitudes,
and positive values denote north latitudes. By default, no filtering based on
location is performed.
</p>
</td></tr>
<tr><td><code id="getSingleTimeStateVectors_+3A_maxlatitude">maxLatitude</code></td>
<td>
<p>maximum latitude to filter the retrieved state vectors.
Must be a value between -180 and 180. Negative values denote south latitudes,
and positive values denote north latitudes. By default, no filtering based on
location is performed.
</p>
</td></tr>
<tr><td><code id="getSingleTimeStateVectors_+3A_minlongitude">minLongitude</code></td>
<td>
<p>minimum longitude to filter the retrieved state vectors.
Must be a value between -180 and 180. Negative values denote west longitudes,
and positive values denote east longitudes. By default, no filtering based on
location is performed.
</p>
</td></tr>
<tr><td><code id="getSingleTimeStateVectors_+3A_maxlongitude">maxLongitude</code></td>
<td>
<p>maximum longitude to filter the retrieved state vectors.
Must be a value between -180 and 180. Negative values denote west longitudes,
and positive values denote east longitudes. By default, no filtering based on
location is performed.
</p>
</td></tr>
<tr><td><code id="getSingleTimeStateVectors_+3A_username">username</code></td>
<td>
<p>optional string with the username to use for authentication
for the OpenSky API. By default, no authentication is performed.
</p>
</td></tr>
<tr><td><code id="getSingleTimeStateVectors_+3A_password">password</code></td>
<td>
<p>optional string with the password to use for authentication
for the OpenSky API. By default, no authentication is performed.
</p>
</td></tr>
<tr><td><code id="getSingleTimeStateVectors_+3A_usetrino">useTrino</code></td>
<td>
<p>logical indicating whether or not to use the OpenSky
Trino query interface instead of the API to retrieve state vectors if <code>includeStateVectors=TRUE</code>. If used, the provided 
username and password are used for the Trino connection. By default, the Trino interface
is not used.
</p>
</td></tr>
<tr><td><code id="getSingleTimeStateVectors_+3A_timeout">timeOut</code></td>
<td>
<p>number of seconds after which the query will time out and return
a NULL result. In the default behavior, timeout will be reached after 60 seconds.
</p>
</td></tr>
<tr><td><code id="getSingleTimeStateVectors_+3A_maxqueryattempts">maxQueryAttempts</code></td>
<td>
<p>On rare occassions, queries to the OpenSky Network
live API can return malformed responses. This is the maximum number of attempts 
to obtain a properly formatted response when carrying out the requested query. 
It should be noted that the query will still terminate if a timeout is reached.
In the default behavior, a single attempt will be performed. It is not recommended
to change this to a very large number, since it can lead to long running times.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If a single state vector matching the query conditions is found, an
<code><a href="#topic+openSkiesStateVector">openSkiesStateVector</a></code> object.
If multiple state vectors matching the query conditions are found,
an <code><a href="#topic+openSkiesStateVectorSet">openSkiesStateVectorSet</a></code> object with field <code>time_series=FALSE</code>.
For details on the information stored in state vectors, see the documentation for
<code><a href="#topic+openSkiesStateVector">openSkiesStateVector</a></code> and <code><a href="#topic+openSkiesStateVectorSet">openSkiesStateVectorSet</a></code>.
</p>


<h3>References</h3>

<p>https://opensky-network.org/apidoc/rest.html
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Obtain a list with the state vectors for all aircrafts currently flying over
# an area covering Switzerland.

getSingleTimeStateVectors(minLatitude=45.8389, maxLatitude=47.8229, 
minLongitude=5.9962, maxLongitude=10.5226)

# Obtain the state vector for aircraft with ICAO 24-bit address 403003 for
# the 8th of October, 2020 at 16:50 London time.

if(interactive()){
getSingleTimeStateVectors(aircraft="403003", time="2020-10-08 16:50:00", 
timeZone="Europe/London")
}
</code></pre>

<hr>
<h2 id='getVectorSetFeatures'>Get positional features of an openSkiesStateVectorSet object
</h2><span id='topic+getVectorSetFeatures'></span>

<h3>Description</h3>

<p>Retrieves positional features of an <code><a href="#topic+openSkiesStateVectorSet">openSkiesStateVectorSet</a></code> object. 
Features will be uniformly interpolated from the observed values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getVectorSetFeatures(stateVectorSet, resamplingSize=15, method="fmm", fields=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getVectorSetFeatures_+3A_statevectorset">stateVectorSet</code></td>
<td>
<p>object of class <code><a href="#topic+openSkiesStateVectorSet">openSkiesStateVectorSet</a></code> for
which positional features should be extracted.
</p>
</td></tr>
<tr><td><code id="getVectorSetFeatures_+3A_resamplingsize">resamplingSize</code></td>
<td>
<p>number of uniformly separated interpolation points at
which the values of the position features should be calculated.
</p>
</td></tr>
<tr><td><code id="getVectorSetFeatures_+3A_method">method</code></td>
<td>
<p>method to be used for interpolation. &quot;linear&quot; will result in 
linear interpolation, while &quot;fmm&quot;, &quot;periodic&quot;, or &quot;natural&quot; will result in 
different types of spline interpolation.
</p>
</td></tr>
<tr><td><code id="getVectorSetFeatures_+3A_fields">fields</code></td>
<td>
<p>character vector indicating the names of the fields of the
<code><a href="#topic+openSkiesStateVector">openSkiesStateVector</a></code> objects that should be included in the
extracted positional features. In the default behavior, <code>fields=NULL</code>
and only latitude and longitude values will be used.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with positional features of the provided <code><a href="#topic+openSkiesStateVectorSet">openSkiesStateVectorSet</a></code> object.
The vector alternates values of longitude and latitude at each interpolated 
point, unless a character vector with valid names of fields of <code><a href="#topic+openSkiesStateVector">openSkiesStateVector</a></code> 
objects is provided through <code>fields</code>, in which case values of the specified 
fields are alternated, in the specified order.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Extract positional features for a time series of state vectors for the 
# aircraft with ICAO 24-bit address 403003 for the 8th of October, 2020 between 
# 16:50 and 16:53 (London time), with a time resolution of 1 minute.

if(interactive()){
vectors &lt;- getAircraftStateVectorsSeries(aircraft="4ca7b3", 
startTime="2020-11-04 10:30:00", endTime="2020-11-04 12:00:00", 
timeZone="Europe/London", timeResolution=300)

features &lt;- getVectorSetFeatures(vectors)
}
</code></pre>

<hr>
<h2 id='getVectorSetListFeatures'>Get positional features of a list of openSkiesStateVectorSet objects
</h2><span id='topic+getVectorSetListFeatures'></span>

<h3>Description</h3>

<p>Retrieves positional features of a list of <code><a href="#topic+openSkiesStateVectorSet">openSkiesStateVectorSet</a></code> objects. 
Features will be uniformly interpolated from the observed values for all the
<code><a href="#topic+openSkiesStateVectorSet">openSkiesStateVectorSet</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getVectorSetListFeatures(stateVectorSetList, resamplingSize=15, method="fmm", 
                         scale=TRUE, fields=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getVectorSetListFeatures_+3A_statevectorsetlist">stateVectorSetList</code></td>
<td>
<p>list of objects of class <code><a href="#topic+openSkiesStateVectorSet">openSkiesStateVectorSet</a></code> 
for which positional features should be extracted.
</p>
</td></tr>
<tr><td><code id="getVectorSetListFeatures_+3A_resamplingsize">resamplingSize</code></td>
<td>
<p>number of uniformly separated interpolation points at
which the values of the position features should be calculated.
</p>
</td></tr>
<tr><td><code id="getVectorSetListFeatures_+3A_method">method</code></td>
<td>
<p>method to be used for interpolation. &quot;linear&quot; will result in 
linear interpolation, while &quot;fmm&quot;, &quot;periodic&quot;, or &quot;natural&quot; will result in 
different types of spline interpolation.
</p>
</td></tr>
<tr><td><code id="getVectorSetListFeatures_+3A_scale">scale</code></td>
<td>
<p>logical indicating if the matrix of features should be scaled
by applying the <code><a href="base.html#topic+scale">scale</a></code> function. This can be desirable if the
features are going to be used for clustering.
</p>
</td></tr>
<tr><td><code id="getVectorSetListFeatures_+3A_fields">fields</code></td>
<td>
<p>character vector indicating the names of the fields of the
<code><a href="#topic+openSkiesStateVector">openSkiesStateVector</a></code> objects that should be included in the
extracted positional features. In the default behavior, <code>fields=NULL</code>
and only latitude and longitude values will be used.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with positional features of the provided list of <code><a href="#topic+openSkiesStateVectorSet">openSkiesStateVectorSet</a></code> 
objects. Each row of the matrix represents a vector of features for each of the
<code><a href="#topic+openSkiesStateVectorSet">openSkiesStateVectorSet</a></code> objects. Each vector alternates values of 
longitude and latitude at each interpolated point, unless a character vector
with valid names of fields of <code><a href="#topic+openSkiesStateVector">openSkiesStateVector</a></code> objects is
provided through <code>fields</code>, in which case values of the specified fields are 
alternated, in the specified order.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Extract positional features for a time series of state vectors for the 
# aircraft with ICAO 24-bit address 403003 for the 8th of October, 2020 between 
# 16:50 and 16:53 (London time), with a time resolution of 1 minute.

if(interactive()){
vectors1=getAircraftStateVectorsSeries(aircraft="345107", 
startTime="2020-11-04 11:55:00", endTime="2020-11-04 13:10:00", 
timeZone="Europe/London", timeResolution=300)

vectors2=getAircraftStateVectorsSeries(aircraft = "4ca7b3", 
startTime="2020-11-04 10:30:00", endTime="2020-11-04 12:00:00",
timeZone="Europe/London", timeResolution=300)

vectors_list=list(vectors1, vectors2)

features_matrix=getVectorSetListFeatures(vectors_list, scale=FALSE, 
                                         fields=c("longitude", "latitude", "true_track"))
}
</code></pre>

<hr>
<h2 id='openSkiesAircraft'>An <code><a href="R6.html#topic+R6Class">R6Class</a></code> object representing an aircraft</h2><span id='topic+openSkiesAircraft'></span>

<h3>Description</h3>

<p><code><a href="R6.html#topic+R6Class">R6Class</a></code> object representing an aircraft. Contains information
about the ICAO 24-bit code of the aircraft, its registration code, its country
of origin, its manufacturer and its operator. New instances can be manually 
created by providing values for at least the <code>ICAO24</code> field. Alternatively, 
<code><a href="#topic+getAircraftMetadata">getAircraftMetadata</a></code> will return an <code>openSkiesAirport</code> object 
corresponding to the airport with the provided ICAO 24-bit code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>openSkiesAircraft
</code></pre>


<h3>Fields</h3>


<dl>
<dt><code>ICAO24</code></dt><dd><p>String with the ICAO 24-bit aicraft address associated to
the aircraft in hexadecimal format
</p>
</dd>
<dt><code>registration</code></dt><dd><p>String with the aircraft registration code, also 
called tail number
</p>
</dd>
<dt><code>origin_country</code></dt><dd><p>String with the country where the aircraft is 
registered
</p>
</dd>
<dt><code>last_state_vector</code></dt><dd><p>An object of class <code><a href="#topic+openSkiesStateVector">openSkiesStateVector</a></code>
representing the last known state vector for the aircraft
</p>
</dd>
<dt><code>state_vector_history</code></dt><dd><p>An object of class <code><a href="#topic+openSkiesStateVectorSet">openSkiesStateVectorSet</a></code>
representing the history of all known state vectors for the aircraft
</p>
</dd>
<dt><code>manufacturer_name</code></dt><dd><p>String with the name of the manufacturer of 
the aircraft
</p>
</dd>
<dt><code>manufacturer_ICAO</code></dt><dd><p>String with the ICAO code of the manufacturer 
of the aircraft
</p>
</dd>
<dt><code>model</code></dt><dd><p>String with the aicraft model
</p>
</dd>
<dt><code>serial_number</code></dt><dd><p>String with the serial number of the aircraft
</p>
</dd>
<dt><code>line_number</code></dt><dd><p>String with the line number of the aircraft.
Usually only provided for Boeing aircrafts. Line numbers specify the order in 
which airframes of a particular product line were assembled.
</p>
</dd>
<dt><code>ICAO_type_code</code></dt><dd><p>String with the ICAO code for the model of 
aircraft
</p>
</dd>
<dt><code>ICAO_aircraft_class</code></dt><dd><p>String with the ICAO code for the type of 
aircraft. ICAO aircraft classes provide more general groups than ICAO type 
codes
</p>
</dd>
<dt><code>owner</code></dt><dd><p>String with the name of the registered aircraft owner
</p>
</dd>
<dt><code>operator</code></dt><dd><p>String with the name of the aircraft operator
</p>
</dd>
<dt><code>operator_call_sign</code></dt><dd><p>String with the callsign of the aircraft 
operator
</p>
</dd>
<dt><code>operator_ICAO</code></dt><dd><p>String with the ICAO code of the aircraft operator
</p>
</dd>
<dt><code>operator_IATA</code></dt><dd><p>String with the IATA code of the aircraft operator
</p>
</dd>
<dt><code>first_flight_date</code></dt><dd><p>String with the date when the first flight 
for the aircraft was registered. This information is usually not available
when retrieving information from the OpenSky API
</p>
</dd>
<dt><code>category_description</code></dt><dd><p>String with physical information about the 
aircraft provided by the ADS-B emitter unit
</p>
</dd>
</dl>


<h3>Methods</h3>


<dl>
<dt>
<code>get_values(field, removeNAs=FALSE)</code></dt><dd>
<p>This method retrieves the value of <code>field</code> for all the state vectors
stored in the <code>openSkiesStateVectorSet</code> object. If <code>removeNAs=TRUE</code>
(by default, <code>removeNAs=FALSE</code>), missing values are removed from the
output. Otherwise, NA is returned in place of missing items.
</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
# Create an openSkiesAircraft object corresponding to the aircraft with
# ICAO 24-bit address 3922e2

if(interactive()){
test_aircraft &lt;- getAircraftMetadata("3922e2")
test_aircraft
}
</code></pre>

<hr>
<h2 id='openSkiesAirport'>An <code><a href="R6.html#topic+R6Class">R6Class</a></code> object representing an airport</h2><span id='topic+openSkiesAirport'></span>

<h3>Description</h3>

<p><code><a href="R6.html#topic+R6Class">R6Class</a></code> object representing an airport. Contains information
about the name of the airport, its IATA and ICAO codes, and its location.
New instances can be manually created by providing values for at least the 
fields <code>name</code>, <code>city</code>, <code>country</code>, <code>longitude</code> and 
<code>latitude</code>. Alternatively, <code><a href="#topic+getAirportMetadata">getAirportMetadata</a></code> will return an
<code>openSkiesAirport</code> object corresponding to the airport with the 
provided ICAO code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>openSkiesAirport
</code></pre>


<h3>Fields</h3>


<dl>
<dt><code>name</code></dt><dd><p>String with the name of the airport
</p>
</dd>
<dt><code>ICAO</code></dt><dd><p>String with the ICAO code of the airport
</p>
</dd>
<dt><code>IATA</code></dt><dd><p>String with the IATA code of the airport
</p>
</dd>
<dt><code>longitude</code></dt><dd><p>Longitude of the position of the airport
</p>
</dd>
<dt><code>latitude</code></dt><dd><p>Latitude of the position of the airport
</p>
</dd>
<dt><code>altitude</code></dt><dd><p>Altitude of the position of the airport
</p>
</dd>
<dt><code>city</code></dt><dd><p>String with the name of the city where the airport 
is located
</p>
</dd>
<dt><code>municipality</code></dt><dd><p>String with the ISO 3166-2 code where the 
airport is located
</p>
</dd>
<dt><code>region</code></dt><dd><p>String with the name of the region where the 
airport is located
</p>
</dd>
<dt><code>country</code></dt><dd><p>String with the ISO 3166-1 alpha-2 code of the country 
where the airport is located
</p>
</dd>
<dt><code>continent</code></dt><dd><p>String with the ISO 3166-1 alpha-2 code of the 
continent where the airport is located
</p>
</dd>
<dt><code>type</code></dt><dd><p>String with information about the type of airport
</p>
</dd>
<dt><code>website</code></dt><dd><p>String with the URL for the website of the airport
</p>
</dd>
<dt><code>wikipedia_entry</code></dt><dd><p>String with the URL for the Wikipedia entry 
of the airport
</p>
</dd>
<dt><code>reliable_position</code></dt><dd><p>Logical value indicating if the position of
the airport is reliable
</p>
</dd>
<dt><code>GPS_code</code></dt><dd><p>String with the GPS code of the airport
</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create an openSkiesAirport object corresponding to Sevilla Airport

if(interactive()){
test_airport &lt;- getAirportMetadata("LEZL")
test_airport
}
</code></pre>

<hr>
<h2 id='openSkiesFlight'>An <code><a href="R6.html#topic+R6Class">R6Class</a></code> object representing a specific flight</h2><span id='topic+openSkiesFlight'></span>

<h3>Description</h3>

<p><code><a href="R6.html#topic+R6Class">R6Class</a></code> object representing a specific flight performed by a
certain aircraft. Contains information about the aircraft that performed the
flight, the airports of origin and destination, the times of departure and
arrival and the callsign under which the flight was performed. New instances can be manually created by providing values for at least the fields <code>ICAO24</code>,  <code>departure_time</code> and  <code>arrival_time</code>. 
Alternatively, <code><a href="#topic+getAircraftFlights">getAircraftFlights</a></code>, <code><a href="#topic+getAirportDepartures">getAirportDepartures</a></code>,
<code><a href="#topic+getAirportArrivals">getAirportArrivals</a></code> <code><a href="#topic+getIntervalFlights">getIntervalFlights</a></code> will all 
return lists of <code>openSkiesFlight</code> objects corresponding to the flights
that match the query conditions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>openSkiesFlight
</code></pre>


<h3>Fields</h3>


<dl>
<dt><code>ICAO24</code></dt><dd><p>String with the ICAO 24-bit aicraft address associated to
the aircraft in hexadecimal format
</p>
</dd>
<dt><code>call_sign</code></dt><dd><p>String with callsign under which the flight was
performed
</p>
</dd>
<dt><code>state_vectors</code></dt><dd><p>Object of class <code><a href="#topic+openSkiesStateVectorSet">openSkiesStateVectorSet</a></code>
with field <code>time_series = TRUE</code> containing the state vectors received
from the aircraft during the flight
</p>
</dd>
<dt><code>origin_airport</code></dt><dd><p>String with the ICAO 4-letter code of the airport
of origin
</p>
</dd>
<dt><code>destination_airport</code></dt><dd><p>String with the ICAO 4-letter code of the 
destination airport
</p>
</dd>
<dt><code>departure_time</code></dt><dd><p>String with the date and time at which the 
aircraft took off
</p>
</dd>
<dt><code>arrival_time</code></dt><dd><p>String with the date and time at which the 
aircraft arrived at its destination
</p>
</dd>
</dl>


<h3>Methods</h3>


<dl>
<dt>
<code>get_moment_state_vector(time, includeFuture = TRUE)</code></dt><dd>
<p>This method retrieves the state vector closest with the timestamp closest
to the provided time, which must be supplied as a date-time string. In the 
default behaviour, <code>includeFuture=TRUE</code> and the retrieved vector will 
be the one with the closest timestamp, regardless of if this is earlier or
later than the provided time. If <code>includeFuture=FALSE</code>, the closest
earlier state vector will be retrieved.
</p>
</dd></dl>
<p>,
</p>
<dl>
<dt>
<code>get_duration()</code></dt><dd>
<p>This method returns the duration of the flight in seconds
</p>
</dd></dl>
<p>,
</p>
<dl>
<dt>
<code>distance_to_flight(flight, numberSamples=15, 
                             samplesAggregationMethod="concatenated", 
                             method="euclidean", additionalFields=NULL)</code></dt><dd>
<p>This method calculates the distance to the provided flight, which must be 
another object of class openSkiesFlight. Both openSkiesFlight objects
will be resampled to the number of points specified by 
<code>numberSamples</code>. If <code>samplesAggregationMethod="concatenated"</code>,
a vector of values indicating the distance between the flights at each
point is returned. If <code>samplesAggregationMethod="average"</code>, the
average distance is returned. By default, <code>method="euclidean"</code> and
euclidean distances are calculated. Other possible values of <code>method</code>
are all values accepted by <code><a href="stats.html#topic+dist">dist</a></code>. By default, 
<code>additionalFields=NULL</code>, and only latitude and longitude values will
be included in the features vectors used to calculate distances. Additional
fields can be specified by providing their names as a character vector
through <code>additionalFields</code>. The names should be valid names of fields
of <code><a href="#topic+openSkiesStateVector">openSkiesStateVector</a></code> objects.
</p>
</dd>
<dt>
<code>detect_phases(time_window, use_baro_altitude = FALSE)</code></dt><dd>
<p>This method detects the phases of the flight, applying the <code><a href="#topic+findFlightPhases">findFlightPhases</a></code>
function. A time window will be applied to calculate mean values of altitude,
vertical rate and speed. Its length is provided in seconds through the 
<code>time_window</code> argument. Setting this value to 1 effectively disables
the usage of a time window. By default, <code>use_baro_altitude=FALSE</code> and
geo altitude values will be used to calculate the flight phases. If 
<code>use_baro_altitude=TRUE</code>, barometric altitude values will be used instead.
</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
# Create a list of openSkiesFlight objects corresponding to all the flights that 
# landed at Frankfurt International Airport on the 29th of January, 2018 between 
# 12 PM and 1 PM

if(interactive()){
test_flights &lt;- getAirportArrivals(airport="EDDF", startTime="2018-01-29 12:00:00", 
endTime="2018-01-29 13:00:00", timeZone="Europe/Berlin")
test_flights
}
</code></pre>

<hr>
<h2 id='openSkiesRoute'>An <code><a href="R6.html#topic+R6Class">R6Class</a></code> object representing a flight route</h2><span id='topic+openSkiesRoute'></span>

<h3>Description</h3>

<p><code><a href="R6.html#topic+R6Class">R6Class</a></code> object representing a flight route, usually operated by
a commercial airline. Contains information about the callsign under which the 
route is operated, the operator itself and the airports of origin and 
destination. New instances can be manually created by providing values for at 
least the fields <code>call_sign</code>,  <code>origin_airport</code> and  <code>destination_airport</code>. 
Alternatively, <code><a href="#topic+getRouteMetadata">getRouteMetadata</a></code> will return an <code>openSkiesRoute</code> 
object corresponding to the route with the provided callsign.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>openSkiesRoute
</code></pre>


<h3>Fields</h3>


<dl>
<dt><code>call_sign</code></dt><dd><p>String with callsign of the route
</p>
</dd>
<dt><code>origin_airport</code></dt><dd><p>String with the ICAO 4-letter code of the airport
of origin
</p>
</dd>
<dt><code>destination_airport</code></dt><dd><p>String with the ICAO 4-letter code of the 
destination airport
</p>
</dd>
<dt><code>operator_IATA</code></dt><dd><p>String with the IATA code for the operator of the 
route
</p>
</dd>
<dt><code>flight_number</code></dt><dd><p>String with the flight number for the route. The
callsign is usually composed of an airline identifier and the flight number
</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create an openSkiesRoute object corresponding to the American Airlines route
# with callsign AAL683

if(interactive()){
test_route &lt;- getRouteMetadata("AAL683")
test_route
}
</code></pre>

<hr>
<h2 id='openSkiesStateVector'>An <code><a href="R6.html#topic+R6Class">R6Class</a></code> object representing an aircraft state vector</h2><span id='topic+openSkiesStateVector'></span>

<h3>Description</h3>

<p><code><a href="R6.html#topic+R6Class">R6Class</a></code> object representing an aircraft state vector. Contains 
information about status at a given timepoint of an aircraft, including
its position, altitude and velocity. New instances can be manually 
created by providing values for at least the <code>ICAO24</code>, <code>longitude</code> and
<code>latitude</code> fields. Alternatively, <code><a href="#topic+getSingleTimeStateVectors">getSingleTimeStateVectors</a></code> 
will return an <code>openSkiesStateVector</code> object if a single state vector 
matching the query conditions is found.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>openSkiesStateVector
</code></pre>


<h3>Fields</h3>


<dl>
<dt><code>ICAO24</code></dt><dd><p>String with the ICAO 24-bit aicraft address associated to
the aircraft in hexadecimal format
</p>
</dd>
<dt><code>call_sign</code></dt><dd><p>String with the callsign assigned to the aircraft
</p>
</dd>
<dt><code>origin_country</code></dt><dd><p>String with the country where the aircraft is 
registered
</p>
</dd>
<dt><code>requested_time</code></dt><dd><p>String with the time point for which the state
vector was requested
</p>
</dd>
<dt><code>last_position_update_time</code></dt><dd><p>String with the time at which the last
position update for the aircraft was received, or NULL if no position update 
had been received in the past 15 s
</p>
</dd>
<dt><code>last_any_update_time</code></dt><dd><p>String with the time at which the last 
update (of any type) for the aircraft was received
</p>
</dd>
<dt><code>longitude</code></dt><dd><p>Longitude value for the position of the aircraft
</p>
</dd>
<dt><code>latitude</code></dt><dd><p>Latitude value for the position of the aircraft
</p>
</dd>
<dt><code>baro_altitude</code></dt><dd><p>Barometric altitude of the aircraft in meters
</p>
</dd>
<dt><code>geo_altitude</code></dt><dd><p>Geometric altitude of the aircraft in meters
</p>
</dd>
<dt><code>on_ground</code></dt><dd><p>Logical indicating if the aircraft is at a surface 
position
</p>
</dd>
<dt><code>velocity</code></dt><dd><p>velocity of the aircraft over the ground in 
meters/second
</p>
</dd>
<dt><code>true_track</code></dt><dd><p>True track angle in degrees of the current aircraft 
course. Measured clockwise from the North (0º)
</p>
</dd>
<dt><code>vertical_rate</code></dt><dd><p>Vertical movement rate of the aircraft in 
meters/second. Positive means the aircraft is climbing, and negative means it
is descending
</p>
</dd>
<dt><code>squawk</code></dt><dd><p>String with the squawk code for the aircraft transponder
</p>
</dd>
<dt><code>special_purpose_indicator</code></dt><dd><p>Logical indicating if the transponder 
of the aircraft has emitted a Special Purpose Indicator pulse
</p>
</dd>
<dt><code>position_source</code></dt><dd><p>String with the source of the position 
information for this state vector. Can be ADS-B (Automatic Dependent 
Surveillance–Broadcast), ASTERIX (All Purpose Structured Eurocontrol 
Surveillance Information Exchange) or MLA (Multilateration)
</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>
# Obtain the state vector for aircraft with ICAO 24-bit address 403003 for
# the 8th of October, 2020 at 16:50 London time.

if(interactive()){
test_stateVector &lt;- getSingleTimeStateVectors(aircraft="403003", 
time="2020-10-08 16:50:00", timeZone="Europe/London")
test_stateVector
}
</code></pre>

<hr>
<h2 id='openSkiesStateVectorSet'>An <code><a href="R6.html#topic+R6Class">R6Class</a></code> object representing an ensemble of aircraft 
state vectors</h2><span id='topic+openSkiesStateVectorSet'></span>

<h3>Description</h3>

<p><code><a href="R6.html#topic+R6Class">R6Class</a></code> object representing an ensemble of aircraft state vectors. 
Contains a list of objects of class <code><a href="#topic+openSkiesStateVector">openSkiesStateVector</a></code>. The
ensemble can either represent a time series of state vectors of a single 
aircraft, or represent state vectors corresponding to multiple different
aircrafts. For details on the information stored in each state vector, see
the documentation for the <code><a href="#topic+openSkiesStateVector">openSkiesStateVector</a></code> class. New instances can be manually 
created by providing a list of <code><a href="#topic+openSkiesStateVector">openSkiesStateVector</a></code> objects.
Alternatively, <code><a href="#topic+getSingleTimeStateVectors">getSingleTimeStateVectors</a></code> and <code><a href="#topic+getAircraftStateVectorsSeries">getAircraftStateVectorsSeries</a></code> 
will return an <code><a href="#topic+openSkiesStateVectorSet">openSkiesStateVectorSet</a></code> object if multiple state
vectors matching the query conditions are found.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>openSkiesStateVectorSet
</code></pre>


<h3>Fields</h3>


<dl>
<dt><code>state_vectors</code></dt><dd><p>List of <code><a href="#topic+openSkiesStateVector">openSkiesStateVector</a></code> objects
</p>
</dd>
<dt><code>time_series</code></dt><dd><p>Logical indicating if the <code><a href="#topic+openSkiesStateVectorSet">openSkiesStateVectorSet</a></code>
object represents a time series of state vectors of a single aircraft.
</p>
</dd>
</dl>


<h3>Methods</h3>


<dl>
<dt>
<code>add_state_vector(state_vector)</code></dt><dd>
<p>This method adds a new state vector to the openSkiesAircraft object, which
will be set as the new <code>last_state_vector</code> and will be added to
<code>state_vector_history</code>. <code>state_vector</code> should be an
<code><a href="#topic+openSkiesStateVector">openSkiesStateVector</a></code> object
</p>
</dd>
<dt>
<code>get_values(fields, removeNAs=FALSE, unwrapAngles=FALSE)</code></dt><dd>
<p>This method retrieves all the values for the specified fields in the 
ensemble of <code><a href="#topic+openSkiesStateVector">openSkiesStateVector</a></code> objects. One or several
field names can be provided through the <code>fields</code> argument. The values
will be returned as a vector if a single field was provided, or as a data
frame if multiple fields were provided. Field names should match those of
the fields of <code><a href="#topic+openSkiesStateVector">openSkiesStateVector</a></code> objects. If <code>removeNAs=TRUE</code>,
NA values will be omitted from the output (if multiple fields were provided,
only state vectors for which all of the fields were NA will be omitted).
If <code>unwrapAngles=TRUE</code> and values for the <code>true_track</code> field
were requested, the values will be unwrapped to be a smooth succession of
values without sudden discontinuities when crossing from 360º to 0º
(this will likely make multiple values become higher than 360).
</p>
</dd>
<dt>
<code>get_uniform_interpolation(n, fields, method="fmm")</code></dt><dd>
<p>This method obtains a data frame with an interpolation of the specified fields along the
route represented by the state vector set across n evenly distributed points. <code>fields</code>
should be a character vector with the name of the fields that will be interpolated.
Only numeric fields are accepted. <code>method</code> represents the interpolation method.
&quot;linear&quot; will result in linear interpolation, while &quot;fmm&quot;, &quot;periodic&quot;, or &quot;natural&quot; will result
in different types of spline interpolation.
</p>
</dd>
<dt>
<code>get_time_points_interpolation(fields, time_field, timestamps, method="fmm")</code></dt><dd>
<p>This method obtains a data frame with an interpolation of the specified fields along the
route represented by the state vector set across the specified timestamps. <code>fields</code>
should be a character vector with the name of the fields that will be interpolated.
Only numeric fields are accepted. <code>method</code> represents the interpolation method.
&quot;linear&quot; will result in linear interpolation, while &quot;fmm&quot;, &quot;periodic&quot;, or &quot;natural&quot; will result
in different types of spline interpolation. <code>time_field</code> indicates the
name of the field of the openSkiesStateVectorSet object from which the 
timestamps of the original state vectors will be retrieved. Possible values
are <code>c("requested_time", "last_position_update_time", "last_any_update_time")</code>.
The time points at which the interpolations should be calculated should be
provided as a vector through the <code>timestamps</code> argument.
</p>
</dd>
<dt>
<code>sort_by_field(field, decreasing=FALSE)</code></dt><dd>
<p>This method sorts the state vectors of the openSkiesStateVectorSet object
by the values of the field provided through <code>field</code>. By default,
<code>decreasing=FALSE</code> and the state vectors will be sorted by increasing 
order of <code>field</code>. If <code>decreasing=TRUE</code>, decreasing order will be
used.
</p>
</dd>
<dt>
<code>split_into_flights(timeOnLandThreshold=300, timeDiffThreshold=1800)</code></dt><dd>
<p>This method automatically detects different flights contained in the
openSkiesStateVectorSet object and returns a list of objects of class
<code><a href="#topic+openSkiesFlight">openSkiesFlight</a></code>. Separate flights are detected based on two
conditions: either the aircraft staying on ground for a given amount of
time, or the aircraft not sending any status update for a given period. The
thresholds are controlled, respectively, through the <code>timeOnLandThreshold</code>
and <code>timeDiffThreshold</code> arguments. In both cases, the value should be
provided in seconds.
</p>
</dd>
<dt>
<code>remove_redundants(updateType="position")</code></dt><dd>
<p>This method removes redundant state vectors, i.e., those that do not
contain updated information with respect to older state vectors. What is
considered as a redundant state vector is defined by the <code>updateType</code> 
argument. If <code>updateType="position"</code>, which is also the default
behavior, state vectors for which there was no update of positional
information will be considered as redundant (even if there might have been
an update of other information). If <code>updateType="any"</code>, only state
vectors for which no information was updated (positional or any other) will
be considered as redundant. It should be noted that applying this method
will also sort the state vectors from older to more recent. The method
is intended to be applied to time series, and therefore a warning will be
given if it is applied on an <code><a href="#topic+openSkiesStateVectorSet">openSkiesStateVectorSet</a></code> with
field <code>time_series=FALSE</code>.
</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
# Obtain a time series of state vectors for the aircraft with ICAO 24-bit 
# address 403003 for the 8th of October, 2020 between 16:50 and 16:53 (London
# time), with a time resolution of 1 minute.

if(interactive()){
test_stateVectorSet &lt;- getAircraftStateVectorsSeries("403003", startTime="2020-10-08 16:50:00", 
endTime="2020-10-08 16:52:00", timeZone="Europe/London", timeResolution=60)
test_stateVectorSet
}
</code></pre>

<hr>
<h2 id='plotPlanes'>Plot the location of a set of aircrafts
</h2><span id='topic+plotPlanes'></span>

<h3>Description</h3>

<p>Draws the location of a set of aircrafts given in their state vectors on a ggmap 
object. The planes will be oriented according to the path they are following.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPlanes(stateVectors, ggmapObject=NULL, plotResult=TRUE, paddingFactor=0.2, 
           iconSize=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPlanes_+3A_statevectors">stateVectors</code></td>
<td>
<p>list of state vectors. Each state vector must be 
represented by a list with, at least, fields &quot;longitude&quot;, &quot;latitude&quot; and
&quot;trueTrack&quot;.
</p>
</td></tr>
<tr><td><code id="plotPlanes_+3A_ggmapobject">ggmapObject</code></td>
<td>
<p>optional ggmap object on which the route will be drawn. 
By default, a new ggmap object will be created, covering the necessary space 
plus an amount of padding determined by the paddingFactor argument.
</p>
</td></tr>
<tr><td><code id="plotPlanes_+3A_plotresult">plotResult</code></td>
<td>
<p>whether or not the resulting ggmap object with the added 
route should be plotted.
</p>
</td></tr>
<tr><td><code id="plotPlanes_+3A_paddingfactor">paddingFactor</code></td>
<td>
<p>amount of padding to add to the map if no ggmap object is
provided. The added padding will be equal to paddingFactor multiplied by the 
height and width of the map (determined by the difference between the maximum 
and minimum longitudes/latitudes).
</p>
</td></tr>
<tr><td><code id="plotPlanes_+3A_iconsize">iconSize</code></td>
<td>
<p>scaling factor for the size of the plane icons.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggmap object with added paths and points representing the route.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Plot the position of aircrafts currently flying over an area covering 
# Switzerland.

if(interactive()){
vectors &lt;- getSingleTimeStateVectors(minLatitude=45.8389, maxLatitude=47.8229, 
                                minLongitude=5.9962, maxLongitude=10.5226)

plotPlanes(vectors)
}
</code></pre>

<hr>
<h2 id='plotRoute'>Plot a single aircraft route
</h2><span id='topic+plotRoute'></span>

<h3>Description</h3>

<p>Draws a given route on a ggmap object. The route must be given as an object of 
class <code><a href="#topic+openSkiesStateVectorSet">openSkiesStateVectorSet</a></code> with field <code>time_series=TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotRoute(stateVectorSet, pathColor="blue", ggmapObject=NULL, plotResult=TRUE, 
          paddingFactor=0.2, lineSize=1, lineAlpha=0.5, pointSize=0.3, 
          pointAlpha=0.8, arrowLength=0.3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotRoute_+3A_statevectorset">stateVectorSet</code></td>
<td>
<p>object of class <code><a href="#topic+openSkiesStateVectorSet">openSkiesStateVectorSet</a></code> with
field <code>time_series=TRUE</code> with positional information of an aircraft
along different timepoints.
</p>
</td></tr>
<tr><td><code id="plotRoute_+3A_pathcolor">pathColor</code></td>
<td>
<p>color of the path and points that will be used to draw the 
route. Must be a value accepted by ggmap's color attributes.
</p>
</td></tr>
<tr><td><code id="plotRoute_+3A_ggmapobject">ggmapObject</code></td>
<td>
<p>optional ggmap object on which the route will be drawn. 
By default, a new ggmap object will be created, covering the necessary space 
plus an amount of padding determined by the paddingFactor argument.
</p>
</td></tr>
<tr><td><code id="plotRoute_+3A_plotresult">plotResult</code></td>
<td>
<p>whether or not the resulting ggmap object with the added 
route should be plotted.
</p>
</td></tr>
<tr><td><code id="plotRoute_+3A_paddingfactor">paddingFactor</code></td>
<td>
<p>amount of padding to add to the map if no ggmap object is
provided. The added padding will be equal to paddingFactor multiplied by the 
height and width of the map (determined by the difference between the maximum 
and minimum longitudes/latitudes).
</p>
</td></tr>
<tr><td><code id="plotRoute_+3A_linesize">lineSize</code></td>
<td>
<p>width of the line that connects the points of the route in the 
plot.
</p>
</td></tr>
<tr><td><code id="plotRoute_+3A_linealpha">lineAlpha</code></td>
<td>
<p>opacity of the line that connects the points of the route in 
the plot.
</p>
</td></tr>
<tr><td><code id="plotRoute_+3A_pointsize">pointSize</code></td>
<td>
<p>size of the points of the route in the plot.
</p>
</td></tr>
<tr><td><code id="plotRoute_+3A_pointalpha">pointAlpha</code></td>
<td>
<p>opacity of the points of the route in the plot.
</p>
</td></tr>
<tr><td><code id="plotRoute_+3A_arrowlength">arrowLength</code></td>
<td>
<p>length of the segment arrows in centimeters.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggmap object with added paths and points representing the route.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Plot the route followed by the aircraft with ICAO address 4ca7b3 
# during the 4th of November, 2020.

if(interactive()){
vectors &lt;- getAircraftStateVectorsSeries(aircraft="4ca7b3", 
startTime="2020-11-04 10:30:00", endTime="2020-11-04 12:00:00", 
timeZone="Europe/London", timeResolution=300)

plotRoute(vectors)
}
</code></pre>

<hr>
<h2 id='plotRoutes'>Plot several aircraft routes
</h2><span id='topic+plotRoutes'></span>

<h3>Description</h3>

<p>Draws the given routes on a ggmap object. The routes must be given as a list of 
objects of class <code><a href="#topic+openSkiesStateVectorSet">openSkiesStateVectorSet</a></code>, all of them with field 
<code>time_series=TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotRoutes(stateVectorSetList, pathColors="blue", ggmapObject=NULL, 
plotResult=TRUE, paddingFactor=0.2, lineSize=1, lineAlpha=0.5, pointSize=0.3, 
pointAlpha=0.8, includeArrows=FALSE, arrowLength=0.3, literalColors=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotRoutes_+3A_statevectorsetlist">stateVectorSetList</code></td>
<td>
<p>list of objects of class <code><a href="#topic+openSkiesStateVectorSet">openSkiesStateVectorSet</a></code>
with field <code>time_series=TRUE</code>, each of them containing positional 
information of given aircraft along different timepoints.
</p>
</td></tr>
<tr><td><code id="plotRoutes_+3A_pathcolors">pathColors</code></td>
<td>
<p>If <code>literalColors=TRUE</code>, vector with the colors of the 
paths and points that will be used to draw the routes. If the number of routes 
is greater than the number of colors, these will be rotated. Each color must 
be a value accepted by ggmap's color attributes. Alternatively, if <code>literalColors=FALSE</code>,
a factor defining a certain feature for each route, in which case a color will 
be assigned for each level of the factor.
</p>
</td></tr>
<tr><td><code id="plotRoutes_+3A_ggmapobject">ggmapObject</code></td>
<td>
<p>optional ggmap object on which the routes will be drawn. By 
default, a new ggmap object will be created, covering the necessary space plus
an amount of padding determined by the paddingFactor argument.
</p>
</td></tr>
<tr><td><code id="plotRoutes_+3A_plotresult">plotResult</code></td>
<td>
<p>wether or not the resulting ggmap object with the added 
routes should be plotted.
</p>
</td></tr>
<tr><td><code id="plotRoutes_+3A_paddingfactor">paddingFactor</code></td>
<td>
<p>amount of padding to add to the map if no ggmap object is
provided. The added padding will be equal to paddingFactor multiplied by the 
height and width of the map (determined by the difference between the maximum 
and minimum longitudes/latitudes).
</p>
</td></tr>
<tr><td><code id="plotRoutes_+3A_linesize">lineSize</code></td>
<td>
<p>width of the line that connects the points of the routes in 
the plot.
</p>
</td></tr>
<tr><td><code id="plotRoutes_+3A_linealpha">lineAlpha</code></td>
<td>
<p>opacity of the line that connects the points of the routes in
the plot.
</p>
</td></tr>
<tr><td><code id="plotRoutes_+3A_pointsize">pointSize</code></td>
<td>
<p>size of the points of the routes in the plot.
</p>
</td></tr>
<tr><td><code id="plotRoutes_+3A_pointalpha">pointAlpha</code></td>
<td>
<p>opacity of the points of the routes in the plot.
</p>
</td></tr>
<tr><td><code id="plotRoutes_+3A_includearrows">includeArrows</code></td>
<td>
<p>logical indicating if arrows showing the direction of
the flight should be added to the plot. The default value of FALSE can 
speed up the generation of the plot considerably when a large amount of
routes are plotted.
</p>
</td></tr>
<tr><td><code id="plotRoutes_+3A_arrowlength">arrowLength</code></td>
<td>
<p>length of the segment arrows in centimeters.
</p>
</td></tr>
<tr><td><code id="plotRoutes_+3A_literalcolors">literalColors</code></td>
<td>
<p>logical indicating if the values provided through 
<code>pathColors</code> should be interpreted as color names/codes. By default, 
TRUE. If set to FALSE, <code>pathColors</code> will be interpreted as a factor,
and a color for each different value will be automatically assigned.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggmap object with added paths and points representing the routes.
</p>


<h3>References</h3>

<p>https://opensky-network.org/apidoc/rest
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Plot the routes followed by two aircrafts departing from Sevilla airport the
# 4th of November, 2020.

if(interactive()){
vectors1=getAircraftStateVectorsSeries(aircraft="345107", 
startTime="2020-11-04 11:55:00", endTime="2020-11-04 13:10:00", 
timeZone="Europe/London", timeResolution=300)

vectors2=getAircraftStateVectorsSeries(aircraft = "4ca7b3", 
startTime="2020-11-04 10:30:00", endTime="2020-11-04 12:00:00",
timeZone="Europe/London", timeResolution=300)

plotRoutes(list(vectors1, vectors2), pathColors=c("red", "blue"))
}
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
