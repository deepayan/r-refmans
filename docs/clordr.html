<!DOCTYPE html><html><head><title>Help for package clordr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {clordr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cl'><p>Composite Likelihood Calculation for Spatial Ordinal Data without Replications (for implmentation)</p></a></li>
<li><a href='#cl_l'><p>Composite Likelihood Calculation for Spatial Ordinal Data without Replications (for implmentation)</p></a></li>
<li><a href='#cl.rord'><p>Composite Likelihood Calculation for Replciations of Spatial Ordinal Data (for illustration)</p></a></li>
<li><a href='#cle.rord'><p>Composite Likelihood Estimation for Replciations of Spatial Ordinal Data</p></a></li>
<li><a href='#clic'><p>Composite likelihood Information Criterion</p></a></li>
<li><a href='#merge.list'><p>Composite Likelihood Calculation for Spatial Ordinal Data without Replications (for implmentation)</p></a></li>
<li><a href='#sim.rord'><p>Simulation of Replciations of Spatial Ordinal Data</p></a></li>
<li><a href='#surrogate.residual'><p>Surrogate Residuals for Replciations of Spatial Ordinal Data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Composite Likelihood Inference and Diagnostics for Replicated
Spatial Ordinal Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.7.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ting Fung (Ralph) Ma &lt;tingfung.ma@wisc.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Composite likelihood parameter estimate and asymptotic covariance matrix are calculated for the spatial ordinal data with replications, where spatial ordinal response with covariate and both spatial exponential covariance within subject and independent and identically distributed measurement error.  Parameter estimation can be performed by either solving the gradient function or maximizing composite log-likelihood. Parametric bootstrapping is used to estimate the Godambe information matrix and hence the asymptotic standard error and covariance matrix with parallel processing option. Moreover, the proposed surrogate residual, which extends the results of Liu and Zhang (2017) &lt;<a href="https://doi.org/10.1080%2F01621459.2017.1292915">doi:10.1080/01621459.2017.1292915</a>&gt;, can act as a useful tool for model diagnostics.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>pbivnorm (&ge; 0.6.0), MASS (&ge; 7.3-45), rootSolve (&ge; 1.7),
parallel, doParallel (&ge; 1.0.11), foreach (&ge; 1.2.0),
tmvmixnorm (&ge; 1.0.2), utils, stats</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>false</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-03-24 18:44:42 UTC; ralph</td>
</tr>
<tr>
<td>Author:</td>
<td>Ting Fung (Ralph) Ma [cre, aut],
  Pingping Wang [aut],
  Jun Zhu [aut],
  Dipankar Bandyopadhyay [ctb],
  Yincai Tang [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-03-24 19:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='cl'>Composite Likelihood Calculation for Spatial Ordinal Data without Replications (for implmentation)</h2><span id='topic+cl'></span>

<h3>Description</h3>

<p><code>cl</code> Calculate the negative composite log-likelihood value and score function for a particular subject given parameter value and other input variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cl(theta, y, X, dwdv, cmwdv, lt, wn, base, J, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cl_+3A_theta">theta</code></td>
<td>
<p>a vector of parameter value.</p>
</td></tr>
<tr><td><code id="cl_+3A_y">y</code></td>
<td>
<p>a vector of observation for the subject.</p>
</td></tr>
<tr><td><code id="cl_+3A_x">X</code></td>
<td>
<p>covariate for the particular subject.</p>
</td></tr>
<tr><td><code id="cl_+3A_dwdv">dwdv</code></td>
<td>
<p>corresponding distance of selected pair.</p>
</td></tr>
<tr><td><code id="cl_+3A_cmwdv">cmwdv</code></td>
<td>
<p>combination of the pairs included into the composite likelihood.</p>
</td></tr>
<tr><td><code id="cl_+3A_lt">lt</code></td>
<td>
<p>number of parameter (i.e. length of theta).</p>
</td></tr>
<tr><td><code id="cl_+3A_wn">wn</code></td>
<td>
<p>number of pairs with distance.</p>
</td></tr>
<tr><td><code id="cl_+3A_base">base</code></td>
<td>
<p>identity matrix with dimension <code>J+1</code>.</p>
</td></tr>
<tr><td><code id="cl_+3A_j">J</code></td>
<td>
<p>number of category among (ALL) observed response.</p>
</td></tr>
<tr><td><code id="cl_+3A_p">p</code></td>
<td>
<p>number of covariate (i.e. number of column of <code>X</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>cl</code> returns a list: composite log-likelihood value and a vector of first-order partial derivatives for <code>theta</code>.
</p>

<hr>
<h2 id='cl_l'>Composite Likelihood Calculation for Spatial Ordinal Data without Replications (for implmentation)</h2><span id='topic+cl_l'></span>

<h3>Description</h3>

<p><code>cl_l</code> Calculate the negative composite log-likelihood value for a particular subject given parameter value and other input variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cl_l(theta, y, X, dwdv, cmwdv, lt, wn, base, J, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cl_l_+3A_theta">theta</code></td>
<td>
<p>a vector of parameter value</p>
</td></tr>
<tr><td><code id="cl_l_+3A_y">y</code></td>
<td>
<p>a vector of observation for the subject.</p>
</td></tr>
<tr><td><code id="cl_l_+3A_x">X</code></td>
<td>
<p>covariate for the particular subject</p>
</td></tr>
<tr><td><code id="cl_l_+3A_dwdv">dwdv</code></td>
<td>
<p>corresponding distance of selected pair</p>
</td></tr>
<tr><td><code id="cl_l_+3A_cmwdv">cmwdv</code></td>
<td>
<p>combination of the pairs included into the composite likelihood</p>
</td></tr>
<tr><td><code id="cl_l_+3A_lt">lt</code></td>
<td>
<p>number of parameter (i.e. length of theta)</p>
</td></tr>
<tr><td><code id="cl_l_+3A_wn">wn</code></td>
<td>
<p>number of pairs</p>
</td></tr>
<tr><td><code id="cl_l_+3A_base">base</code></td>
<td>
<p>identity matrix with dimension <code>J+1</code></p>
</td></tr>
<tr><td><code id="cl_l_+3A_j">J</code></td>
<td>
<p>number of category among (ALL) observed response.</p>
</td></tr>
<tr><td><code id="cl_l_+3A_p">p</code></td>
<td>
<p>number of covariate (i.e. number of column of <code>X</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>cl</code> returns a list: composite log-likelihood value and a vector of first-order partial derivatives for <code>theta</code>.
</p>

<hr>
<h2 id='cl.rord'>Composite Likelihood Calculation for Replciations of Spatial Ordinal Data (for illustration)</h2><span id='topic+cl.rord'></span>

<h3>Description</h3>

<p><code>cl.rord</code> Calculate the negative composite log-likelihood value for replications of spatial ordinal data at given value of parameter value.
Note that this function is not directly used in <code>cle.rord</code> but illustration only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cl.rord(theta, response, covar, location, radius = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cl.rord_+3A_theta">theta</code></td>
<td>
<p>a vector of parameter value</p>
</td></tr>
<tr><td><code id="cl.rord_+3A_response">response</code></td>
<td>
<p>a matrix of observation (row: spatial site and column: subject).</p>
</td></tr>
<tr><td><code id="cl.rord_+3A_covar">covar</code></td>
<td>
<p>regression (design) matrix, including intercepts.</p>
</td></tr>
<tr><td><code id="cl.rord_+3A_location">location</code></td>
<td>
<p>a matrix contains spatial location of sites within each subject</p>
</td></tr>
<tr><td><code id="cl.rord_+3A_radius">radius</code></td>
<td>
<p>radius for selecting pairs for the composite likelihood estimation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>cl.rord</code> returns a list: negative composite log-likelihood, a vector of first-order partial derivatives for <code>theta</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1203)
n.subject &lt;- 10
n.lat &lt;- n.lon &lt;- 10
n.site &lt;- n.lat*n.lon

beta &lt;- c(1,2,-1) # First 1 here is the intercept
midalpha &lt;- c(1.15, 2.18) ; sigma2 &lt;- 0.7 ; phi &lt;- 0.8

true = c(midalpha,beta,sigma2,phi)

Xi = rnorm(n.subject,0,1) ; Xj &lt;- rbinom(n.site,1,0.6)

 VV &lt;- matrix(NA, nrow = n.subject*n.site, ncol = 3)

 for(i in 1:n.subject){ for(j in 1:n.site){
     VV[(i-1)*n.site+j,] &lt;- c(1,Xi[i],Xj[j])
       }
 }

location = cbind(rep(seq(1,n.lat,length=n.lat),n.lat),rep(1:n.lon, each=n.lon))
sim.data &lt;- sim.rord(n.subject, n.site, n.rep = 2, midalpha, beta, sigma2, phi, covar=VV, location)

cl.rord(theta=true,response=sim.data[[1]], covar=VV, location, radius = 4)

</code></pre>

<hr>
<h2 id='cle.rord'>Composite Likelihood Estimation for Replciations of Spatial Ordinal Data</h2><span id='topic+cle.rord'></span>

<h3>Description</h3>

<p><code>cle.rord</code> Estimate parameters (including regression coefficient and cutoff) for replications of spatial ordinal data using pairwise likelihood approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cle.rord(
  response,
  covar,
  location,
  radius = 4,
  n.sim = 100,
  output = TRUE,
  SE = TRUE,
  parallel = FALSE,
  n.core = max(detectCores()/2, 1),
  ini.sp = c(0.5, 0.5),
  est.method = TRUE,
  maxiter = 100,
  rtol = 1e-06,
  factr = 1e+07
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cle.rord_+3A_response">response</code></td>
<td>
<p>a matrix of observation (row: spatial site and column: subject).</p>
</td></tr>
<tr><td><code id="cle.rord_+3A_covar">covar</code></td>
<td>
<p>regression (design) matrix, including intercepts.</p>
</td></tr>
<tr><td><code id="cle.rord_+3A_location">location</code></td>
<td>
<p>a matrix contains spatial location of sites within each subject.</p>
</td></tr>
<tr><td><code id="cle.rord_+3A_radius">radius</code></td>
<td>
<p>radius for selecting pairs for the composite likelihood estimation.</p>
</td></tr>
<tr><td><code id="cle.rord_+3A_n.sim">n.sim</code></td>
<td>
<p>number of simulation used for parametric bootstrapping (and hence used for asymptotic variance and standard error).</p>
</td></tr>
<tr><td><code id="cle.rord_+3A_output">output</code></td>
<td>
<p>logical flag indicates whether printing out result (default: <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="cle.rord_+3A_se">SE</code></td>
<td>
<p>logical flag for detailed output.</p>
</td></tr>
<tr><td><code id="cle.rord_+3A_parallel">parallel</code></td>
<td>
<p>logical flag indicates using parallel processing (default: <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="cle.rord_+3A_n.core">n.core</code></td>
<td>
<p>number of physical cores used for parallel processing (when <code>parallel</code> is <code>TRUE</code>, default value is <code>max(detectCores()/2,1)</code>).</p>
</td></tr>
<tr><td><code id="cle.rord_+3A_ini.sp">ini.sp</code></td>
<td>
<p>initial estimate for spatial parameter, <code class="reqn">\phi,\sigma^2</code> (default: c(0.5,0.5)).</p>
</td></tr>
<tr><td><code id="cle.rord_+3A_est.method">est.method</code></td>
<td>
<p>logical flag (default) <code>TRUE</code> for rootsolve and <code>FALSE</code> for L-BFGS-B.</p>
</td></tr>
<tr><td><code id="cle.rord_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations in the root solving of gradient function (dafault: 100).</p>
</td></tr>
<tr><td><code id="cle.rord_+3A_rtol">rtol</code></td>
<td>
<p>relative error tolerrance  in the root solving of gradient function (default: 1e-6).</p>
</td></tr>
<tr><td><code id="cle.rord_+3A_factr">factr</code></td>
<td>
<p>reduction in the objective (-logCL) within this factor of the machine tolerance for L-BFGS-B (default: 1e7).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given vector of ordinal responses, the design matrix, spatial location for sites, weight radius (for pair selection), and the prespecified number of simulation used for estimating the Godambe information matrix. Initial estimate is obtained by fitting model without spatial dependence (using <code>MASS::polr()</code>) and optional guess of spatial parameters. The function first estimates parameters of interest by either solving the gradient of composite log-likelihood using <code>rootSolve::multiroot()</code> or maximize the composite log-likelihood by <code>optim(..., method="L-BFGS-B")</code>. The asymptotic covariance matrix and standard error of parameters are then estimated by parametric boostrapping. Although the default root solving option is typically more efficient, it may encounter runtime error if negative value of <code class="reqn">\phi</code> is evaluated (and L-BFGS-B approach should be used).
</p>


<h3>Value</h3>

<p><code>cle.rord</code> returns a list contains:
</p>
<p><code>vec.par</code>: a vector of estimator for <code class="reqn">\theta=(\alpha,\beta,\phi,\sigma^2)</code>;
</p>
<p><code>vec.se</code>: a vector of standard error for the estimator;
</p>
<p><code>mat.asyvar</code>: estimated asymptotic covariance matrix <code class="reqn">H^{-1}(\theta)J(\theta)H^{-1}(\theta)</code> for the estimator;
</p>
<p><code>mat.Hessian</code>: Hessian matrix at the parameter estimate;
</p>
<p><code>mat.J</code>: Sensitivity matrix estimated by parametric boostrapping; and
</p>
<p><code>CLIC</code>: Composite likelihood information criterion (see help manual of <code>clic()</code> for detail).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1228)
n.subject &lt;- 20
n.lat &lt;- n.lon &lt;- 10
n.site &lt;- n.lat*n.lon

beta &lt;- c(1,2,-1) # First 1 here is the intercept
midalpha &lt;- c(1.15, 2.18) ; phi &lt;- 0.6 ; sigma2 &lt;- 0.7

true &lt;- c(midalpha,beta,phi,sigma2)

Xi &lt;- rnorm(n.subject,0,1) ; Xj &lt;- rbinom(n.site,1,0.6)

 VV &lt;- matrix(NA, nrow = n.subject*n.site, ncol = 3)

 for(i in 1:n.subject){ for(j in 1:n.site){
     VV[(i-1)*n.site+j,] &lt;- c(1,Xi[i],Xj[j])
       }
 }

location &lt;- cbind(rep(seq(1,n.lat,length=n.lat),n.lat),rep(1:n.lon, each=n.lon))
sim.data &lt;- sim.rord(n.subject, n.site, n.rep = 2, midalpha, beta, phi, sigma2, covar=VV, location)


options(digits=3)
result &lt;- cle.rord(response=sim.data[[1]], covar=VV,
          location = location ,radius = 4, n.sim = 100, output = TRUE, parallel=TRUE, n.core =2)
result$vec.par
# alpha2  alpha3   beta0   beta1   beta2     phi sigma^2
# 1.249   2.319   1.169   1.990  -1.000   0.668   0.678

result$vec.se
# alpha2  alpha3   beta0   beta1   beta2     phi sigma^2
# 0.0704  0.1201  0.1370  0.2272  0.0767  0.0346  0.1050



</code></pre>

<hr>
<h2 id='clic'>Composite likelihood Information Criterion</h2><span id='topic+clic'></span>

<h3>Description</h3>

<p><code>clic</code> Calculating the Composite likelihood information criterion proposed by Varin and Vidoni (2005)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clic(logCL, mat.hessian, mat.J)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clic_+3A_logcl">logCL</code></td>
<td>
<p>value of composite log-likelihood.</p>
</td></tr>
<tr><td><code id="clic_+3A_mat.hessian">mat.hessian</code></td>
<td>
<p>hessian matrix.</p>
</td></tr>
<tr><td><code id="clic_+3A_mat.j">mat.J</code></td>
<td>
<p>Sensitivity matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Varin and Vidoni (2005) proposed the information criterion in the form:
<code class="reqn">-2*logCL(theta) + 2*trace(H^{-1}(\theta)J(\theta))</code>
</p>


<h3>Value</h3>

<p><code>CLIC</code>: Composite likelihood information criterion proposed by Varin and Vidoni (2005)
</p>
<p><code>clic</code>: Composite likelihood information criterion proposed by Varin and Vidoni (2005)
</p>


<h3>References</h3>

<p>Varin, C. and Vidoni, P. (2005) A note on composite likelihood inference and model selection. <em>Biometrika</em> 92: 519&ndash;528.
</p>

<hr>
<h2 id='merge.list'>Composite Likelihood Calculation for Spatial Ordinal Data without Replications (for implmentation)</h2><span id='topic+merge.list'></span>

<h3>Description</h3>

<p>Composite Likelihood Calculation for Spatial Ordinal Data without Replications (for implmentation)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'list'
merge(x, y = NULL, mergeUnnamed = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge.list_+3A_x">x</code></td>
<td>
<p>an object to be merged into list of object.</p>
</td></tr>
<tr><td><code id="merge.list_+3A_y">y</code></td>
<td>
<p>an object to be merged into list.</p>
</td></tr>
<tr><td><code id="merge.list_+3A_mergeunnamed">mergeUnnamed</code></td>
<td>
<p>select an element if it has a.) an empty name in y and
mergeUnnamed is true or  b.) a name _not_ contained in x</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>merge.list</code> returns a list: a merged list
</p>

<hr>
<h2 id='sim.rord'>Simulation of Replciations of Spatial Ordinal Data</h2><span id='topic+sim.rord'></span>

<h3>Description</h3>

<p><code>sim.rord</code> Simulate replications of spatial ordinal data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.rord(
  n.subject,
  n.site,
  n.rep = 100,
  midalpha,
  beta,
  phi,
  sigma2,
  covar,
  location
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.rord_+3A_n.subject">n.subject</code></td>
<td>
<p>number of subjects.</p>
</td></tr>
<tr><td><code id="sim.rord_+3A_n.site">n.site</code></td>
<td>
<p>number of spatial sites for each subject.</p>
</td></tr>
<tr><td><code id="sim.rord_+3A_n.rep">n.rep</code></td>
<td>
<p>number of simulation.
Parameter inputs include:</p>
</td></tr>
<tr><td><code id="sim.rord_+3A_midalpha">midalpha</code></td>
<td>
<p>cutoff parameter (excluding -Inf and +Inf);</p>
</td></tr>
<tr><td><code id="sim.rord_+3A_beta">beta</code></td>
<td>
<p>regression coefficient;</p>
</td></tr>
<tr><td><code id="sim.rord_+3A_phi">phi</code></td>
<td>
<p>dependence parameter for spatial dependence; and</p>
</td></tr>
<tr><td><code id="sim.rord_+3A_sigma2">sigma2</code></td>
<td>
<p>sigma^2 (variance) for the spatial dependence.</p>
</td></tr>
<tr><td><code id="sim.rord_+3A_covar">covar</code></td>
<td>
<p>regression (design) matrix, including intercepts.</p>
</td></tr>
<tr><td><code id="sim.rord_+3A_location">location</code></td>
<td>
<p>a matrix contains spatial location of sites within each subject.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>sim.rord</code> returns a list (length <code>n.rep</code>) of matrix (<code>n.subject*n.site</code>) with the underlying parameter as inputs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1203)
n.subject &lt;- 100
n.lat &lt;- n.lon &lt;- 10
n.site &lt;- n.lat*n.lon

beta &lt;- c(1,2,-1) # First 1 here is the intercept
midalpha &lt;- c(1.15, 2.18) ; phi &lt;- 0.8 ; sigma2 &lt;- 0.7

true &lt;- c(midalpha,beta,sigma2,phi)

Xi &lt;- rnorm(n.subject,0,1) ; Xj &lt;- rbinom(n.site,1,0.6)

 VV &lt;- matrix(NA, nrow = n.subject*n.site, ncol = 3)

 for(i in 1:n.subject){ for(j in 1:n.site){
     VV[(i-1)*n.site+j,] &lt;- c(1,Xi[i],Xj[j])
       }
 }

location &lt;- cbind(rep(seq(1,n.lat,length=n.lat),n.lat),rep(1:n.lon, each=n.lon))
sim.data &lt;- sim.rord(n.subject, n.site, n.rep = 2, midalpha, beta, phi, sigma2, covar=VV, location)

length(sim.data)
head(sim.data[[1]])
dim(sim.data[[1]])
hist(sim.data[[1]])
</code></pre>

<hr>
<h2 id='surrogate.residual'>Surrogate Residuals for Replciations of Spatial Ordinal Data</h2><span id='topic+surrogate.residual'></span>

<h3>Description</h3>

<p><code>surrogate.residual</code> simulate the surrogate residual with the the given parameter value and covariate for model diagnostics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surrogate.residual(
  response,
  covar,
  location,
  seed = NULL,
  midalpha,
  beta,
  sigma2,
  phi,
  burn.in = 20,
  output = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="surrogate.residual_+3A_response">response</code></td>
<td>
<p>a matrix of observation (row: spatial site and column: subject).</p>
</td></tr>
<tr><td><code id="surrogate.residual_+3A_covar">covar</code></td>
<td>
<p>regression (design) matrix, including intercepts.</p>
</td></tr>
<tr><td><code id="surrogate.residual_+3A_location">location</code></td>
<td>
<p>a matrix contains spatial location of sites within each subject.</p>
</td></tr>
<tr><td><code id="surrogate.residual_+3A_seed">seed</code></td>
<td>
<p>seed input for simulation (default =<code>NULL</code>).
Parameter values:</p>
</td></tr>
<tr><td><code id="surrogate.residual_+3A_midalpha">midalpha</code></td>
<td>
<p>cutoff for latent ordinal response.</p>
</td></tr>
<tr><td><code id="surrogate.residual_+3A_beta">beta</code></td>
<td>
<p>regression coefficient  for <code>covar</code>.</p>
</td></tr>
<tr><td><code id="surrogate.residual_+3A_sigma2">sigma2</code></td>
<td>
<p><code class="reqn">\sigma^2</code> for exponential covariance.</p>
</td></tr>
<tr><td><code id="surrogate.residual_+3A_phi">phi</code></td>
<td>
<p>spatial correlation for exponential covariance.</p>
</td></tr>
<tr><td><code id="surrogate.residual_+3A_burn.in">burn.in</code></td>
<td>
<p>burn-in length (i.e. declaring the initial sample).</p>
</td></tr>
<tr><td><code id="surrogate.residual_+3A_output">output</code></td>
<td>
<p>logical flag indicates whether printing out result (default: <code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given vector of observed responses, the design matrix, spatial location for sites and parameter value, raw surrogate residuals are simulated using an efficient Gibbs sampling, which can be used for model diagnostics. When the fitted model is correct, the raw surrogate residuals among subjects should follow multivariate normal with mean 0 and covariance Sigma. If the model is correct, residual plot should be close to a null plot or random scatter. For example, it can be used to check the potential missing in covariate, non-linearity of covariate and outliers. In particular for the example below, the residual plot shows that linearity of Xi is adequate for the model.
</p>


<h3>Value</h3>

<p><code>surrogate.residual</code> returns a (no. spatial site * no. subject) matrix contains
raw surrogate residuals with element corresponds to the response matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1228)
n.subject &lt;- 50
n.lat &lt;- n.lon &lt;- 10
n.site &lt;- n.lat*n.lon

beta &lt;- c(1,2,-1) # First 1 here is the intercept
midalpha &lt;- c(1.15, 2.18) ; phi &lt;- 0.6 ; sigma2 &lt;- 0.7

true &lt;- c(midalpha,beta,phi,sigma2)

Xi &lt;- rnorm(n.subject,0,1) ; Xj &lt;- rbinom(n.site,1,0.6)

 VV &lt;- matrix(NA, nrow = n.subject*n.site, ncol = 3)

 for(i in 1:n.subject){ for(j in 1:n.site){
     VV[(i-1)*n.site+j,] &lt;- c(1,Xi[i],Xj[j])
       }
 }

location &lt;- cbind(rep(seq(1,n.lat,length=n.lat),n.lat),rep(1:n.lon, each=n.lon))
response &lt;- sim.rord(n.subject, n.site, n.rep = 1,
midalpha, beta, phi, sigma2, covar=VV, location)[[1]]


# Example for linearity of covariate
sur.resid &lt;- surrogate.residual(response, covar=VV, location, seed =1,
midalpha, beta, sigma2, phi,
burn.in=20, output = TRUE)

scatter.smooth(rep(Xi,each=n.site),c(sur.resid),
main="Surrogate residual against Xi", xlab="Xi", ylab="Surrogate residual",
lpars = list(col = "red", lwd = 3, lty = 2))

abline(h=0, col="blue")


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
