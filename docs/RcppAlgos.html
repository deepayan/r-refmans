<!DOCTYPE html><html><head><title>Help for package RcppAlgos</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RcppAlgos}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#RcppAlgos-package'>
<p>High Performance Tools for Combinatorics and Computational Mathematics</p></a></li>
<li><a href='#Combo-class'><p>S4-classes for Exposing C++ Combinatorial Classes</p></a></li>
<li><a href='#comboCount'>
<p>Number of combinations/permutations</p></a></li>
<li><a href='#comboGeneral'>
<p>Generate Combinations and Permutations of a Vector with/without Constraints</p></a></li>
<li><a href='#comboGrid'>
<p>Efficient Version of <code>expand.grid</code> Where order Does Not Matter</p></a></li>
<li><a href='#comboGroups'>
<p>Partition a Vector into Groups</p></a></li>
<li><a href='#ComboGroups-class'><p>S4-class for Exposing C++ ComboGroups Class</p></a></li>
<li><a href='#comboGroupsCount'>
<p>Number of Partitions of a Vector into Groups</p></a></li>
<li><a href='#comboGroupsIter'>
<p>comboGroups Iterator</p></a></li>
<li><a href='#comboGroupsSample'>
<p>Sample Partitions of a Vector into Groups</p></a></li>
<li><a href='#comboIter'>
<p>Combination and Permutation Iterator</p></a></li>
<li><a href='#comboRank'>
<p>Rank Combinations and Permutations</p></a></li>
<li><a href='#comboSample'>
<p>Sample Combinations and Permutations</p></a></li>
<li><a href='#Constraints-class'><p>S4-class for Exposing C++ Constraints Class</p></a></li>
<li><a href='#divisorsRcpp'>
<p>Vectorized Factorization (Complete)</p></a></li>
<li><a href='#divisorsSieve'>
<p>Generate Complete Factorization for Numbers in a Range</p></a></li>
<li><a href='#eulerPhiSieve'>
<p>Apply Euler's Phi Function to Every Element in a Range</p></a></li>
<li><a href='#isPrimeRcpp'>
<p>Vectorized Primality Test</p></a></li>
<li><a href='#numDivisorSieve'>
<p>Apply Divisor Function to Every Element in a Range</p></a></li>
<li><a href='#Partitions-class'><p>S4-class for Exposing C++ Partitions Class</p></a></li>
<li><a href='#partitionsCount'>
<p>Number of Partitions/Compositions</p></a></li>
<li><a href='#partitionsGeneral'>
<p>Generate Partitions/Compositions</p></a></li>
<li><a href='#partitionsIter'>
<p>Partition/Composition Iterator</p></a></li>
<li><a href='#partitionsRank'>
<p>Rank Partitions/Compositions</p></a></li>
<li><a href='#partitionsSample'>
<p>Sample Partitions/Compositions</p></a></li>
<li><a href='#primeCount'>
<p>Prime Counting Function <code class="reqn">\pi(x)</code></p></a></li>
<li><a href='#primeFactorize'>
<p>Vectorized Prime Factorization</p></a></li>
<li><a href='#primeFactorizeSieve'>
<p>Generate Prime Factorization for Numbers in a Range</p></a></li>
<li><a href='#primeSieve'>
<p>Generate Prime Numbers</p></a></li>
<li><a href='#stdThreadMax'>
<p>Max Number of Concurrent Threads</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>2.8.3</td>
</tr>
<tr>
<td>Title:</td>
<td>High Performance Tools for Combinatorics and Computational
Mathematics</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides optimized functions and flexible combinatorial iterators
    implemented in C++ for solving problems in combinatorics and
    computational mathematics. Utilizes the RMatrix class from 'RcppParallel'
    for thread safety. There are combination/permutation functions with
    constraint parameters that allow for generation of all results of a vector
    meeting specific criteria (e.g. generating integer partitions/compositions
    or finding all combinations such that the sum is between two bounds).
    Capable of generating specific combinations/permutations (e.g. retrieve
    only the nth lexicographical result) which sets up nicely for
    parallelization as well as random sampling. Gmp support permits exploration
    where the total number of results is large (e.g. comboSample(10000, 500,
    n = 4)). Additionally, there are several high performance number theoretic
    functions that are useful for problems common in computational mathematics.
    Some of these functions make use of the fast integer division library
    'libdivide'. The primeSieve function is based on the segmented sieve of
    Eratosthenes implementation by Kim Walisch. It is also efficient for large
    numbers by using the cache friendly improvements originally developed by
    Tom√°s Oliveira. Finally, there is a prime counting function that implements
    Legendre's formula based on the work of Kim Walisch.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jwood000/RcppAlgos">https://github.com/jwood000/RcppAlgos</a>, <a href="https://gmplib.org/">https://gmplib.org/</a>,
<a href="https://github.com/kimwalisch/primesieve">https://github.com/kimwalisch/primesieve</a>,
<a href="https://libdivide.com">https://libdivide.com</a>,
<a href="https://github.com/kimwalisch/primecount">https://github.com/kimwalisch/primecount</a>,
<a href="https://ridiculousfish.com/">https://ridiculousfish.com/</a>,
<a href="https://sweet.ua.pt/tos/software/prime_sieve.html">https://sweet.ua.pt/tos/software/prime_sieve.html</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jwood000/RcppAlgos/issues">https://github.com/jwood000/RcppAlgos/issues</a></td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>cpp11</td>
</tr>
<tr>
<td>Imports:</td>
<td>gmp, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, partitions, microbenchmark, knitr, RcppBigIntAlgos,
rmarkdown</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>gmp (&gt;= 4.2.3)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Author:</td>
<td>Joseph Wood</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Joseph Wood &lt;jwood000@gmail.com&gt;</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-09 23:41:11 UTC; josephwood</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-10 01:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='RcppAlgos-package'>
High Performance Tools for Combinatorics and Computational Mathematics
</h2><span id='topic+RcppAlgos-package'></span><span id='topic+RcppAlgos'></span>

<h3>Description</h3>

<p>The <strong>RcppAlgos</strong> package attacks age-old problems in combinatorics and computational mathematics.
</p>


<h3>Goals</h3>


<ol>
<li><p>The main goal is to encourage fresh and creative approaches to foundational problems. The question that most appropriately summarizes <code>RcppAlgos</code> is: <strong><em>&quot;Can we do better?&quot;</em></strong>.
</p>
</li>
<li><p>Provide highly optimized functions that facilitates a broader spectrum of researchable cases. <em>E.g</em>
</p>

<ul>
<li><p>Investigating the structure of large numbers over wide ranges:
</p>

<ul>
<li><p><code>primeFactorizeSieve(10^13 - 10^7, 10^13 + 10^7)</code>
</p>
</li>
<li><p><code>primeSieve(2^53 - 10^10, 2^53 - 1, nThreads = 32)</code>
</p>
</li></ul>


</li>
<li><p>Easily explore combinations/permutations/partitions that would otherwise be inaccessible due to time of execution/memory constraints:
</p>

<ul>
<li><pre>c_iter = comboIter(10000, 100)
bigSamp = gmp::urand.bigz(3, gmp::log2.bigz(comboCount(10000, 100)))
c_iter[[bigSamp]] ## flexible iterator allows random sampling</pre>
</li>
<li><pre>p_iter = partitionsIter(5000, 100, target = 6000)
p_iter[[1e9]] ## start iterating from index = 1e9
p_iter@nextIter()
p_iter@nextNIter(1e3)</pre>
</li>
<li><p><code>comboGeneral(150, 5, constraintFun = "sum", Parallel = TRUE)</code>
</p>
</li>
<li><pre>parallel::mclapply(seq(...), function(x) {
            temp = permuteGeneral(15, 10, lower = x, upper = y)
            ## analyze permutations
            ## output results
    }, mc.cores = detectCores() - 1))</pre>
</li>
<li><pre>partitionsGeneral(0:80, repetition = TRUE)</pre>
</li>
<li><p><code>permuteSample(rnorm(100), 10, freqs = rep(1:4, 25), n = 15, seed = 123)</code>
</p>
</li>
<li><pre>set.seed(123)
comboGeneral(runif(42, 0, 50), 10,
             constraintFun = "mean",
             comparisonFun = c("&gt;","&lt;"),
             limitConstraints = c(39.876, 42.123))</pre>
</li></ul>


</li></ul>

</li>
<li><p><em>Speed!!!...</em>. You will find that the functions in <code>RcppAlgos</code> are some of the fastest of their type available in <code>R</code>.
</p>
</li></ol>



<h3>Author(s)</h3>

<p>Joseph Wood
</p>

<hr>
<h2 id='Combo-class'>S4-classes for Exposing C++ Combinatorial Classes</h2><span id='topic+Combo-class'></span><span id='topic+ComboApply-class'></span><span id='topic+ComboRes-class'></span><span id='topic++24+2CCombo-method'></span><span id='topic++24+2CComboApply-method'></span><span id='topic++24+2CComboRes-method'></span>

<h3>Description</h3>

<p>The <code>Combo</code> class family are S4-classes that expose C++ classes that provide access to iterators and other useful methods.
</p>


<h3>Slots</h3>

<p>of <code>"Combo"</code> and all classes inheriting from it:
</p>

<dl>
<dt><code>nextIter</code></dt><dd><p>Retrieve the <b>next</b> lexicographical result</p>
</dd>
<dt><code>nextNIter</code></dt><dd><p>Pass an integer <em>n</em> to retrieve the <b>next</b> <em>n</em> lexicographical results</p>
</dd>
<dt><code>nextRemaining</code></dt><dd><p>Retrieve all remaining lexicographical results</p>
</dd>
<dt><code>currIter</code></dt><dd><p>Returns the current iteration</p>
</dd>
<dt><code>prevIter</code></dt><dd><p>Retrieve the <b>previous</b> lexicographical result (the <b>next</b> <em>reverse</em> lexicographical result)</p>
</dd>
<dt><code>prevNIter</code></dt><dd><p>Pass an integer <em>n</em> to retrieve the <b>previous</b> <em>n</em> lexicographical results (the <b>next</b> <em>n</em> <em>reverse</em> lexicographical results)</p>
</dd>
<dt><code>prevRemaining</code></dt><dd><p>Retrieve all remaining <em>reverse</em> lexicographical results</p>
</dd>
<dt><code>startOver</code></dt><dd><p>Resets the iterator</p>
</dd>
<dt><code>sourceVector</code></dt><dd><p>View the source vector</p>
</dd>
<dt><code>summary</code></dt><dd><p>Returns a list of summary information about the iterator</p>
</dd>
<dt><code>front</code></dt><dd><p>Retrieve the <b>first</b> lexicographical result</p>
</dd>
<dt><code>back</code></dt><dd><p>Retrieve the <b>last</b> lexicographical result</p>
</dd>
<dt><code>randomAccess</code></dt><dd><p>Random access method. Pass a single value or a vector of valid indices. If a single value is passed, the internal index of the iterator will be updated, however if a vector is passed the internal state will not change. GMP support allows for flexible indexing.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Joseph Wood</p>


<h3>See Also</h3>

<p><code><a href="#topic+Partitions-class">Partitions-class</a></code>, <code><a href="#topic+Constraints-class">Constraints-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  showClass("Combo")
</code></pre>

<hr>
<h2 id='comboCount'>
Number of combinations/permutations
</h2><span id='topic+comboCount'></span><span id='topic+comboCount.default'></span><span id='topic+comboCount.table'></span><span id='topic+comboCount.list'></span><span id='topic+permuteCount'></span><span id='topic+permuteCount.default'></span><span id='topic+permuteCount.table'></span><span id='topic+permuteCount.list'></span>

<h3>Description</h3>

<p>Calculate the number of combinations/permutations of a vector chosen <code class="reqn">m</code> at a time with or without replacement. Additionally, these functions can calculate the number of combinations/permutations of multisets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comboCount(v, m = NULL, ...)
permuteCount(v, m = NULL, ...)

## Default S3 method:
comboCount(v, m = NULL, repetition = FALSE, freqs = NULL, ...)
## Default S3 method:
permuteCount(v, m = NULL, repetition = FALSE, freqs = NULL, ...)

## S3 method for class 'table'
comboCount(v, m = NULL, ...)
## S3 method for class 'table'
permuteCount(v, m = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comboCount_+3A_v">v</code></td>
<td>
<p>Source vector. If <code>v</code> is a positive integer, it will be converted to the sequence <code>1:v</code>. If <code>v</code> is a negative integer, it will be converted to the sequence <code>v:-1</code>. All atomic types are supported (See <code><a href="base.html#topic+is.atomic">is.atomic</a></code>).</p>
</td></tr>
<tr><td><code id="comboCount_+3A_m">m</code></td>
<td>
<p>Number of elements to choose.  If <code>repetition = TRUE</code> or <code>freqs</code> is utilized, <code>m</code> can exceed the length of <code>v</code>. If <code>m = NULL</code>, the length will default to <code>length(v)</code> or <code>sum(freqs)</code>.</p>
</td></tr>
<tr><td><code id="comboCount_+3A_...">...</code></td>
<td>
<p>Further arguments passed to methods.</p>
</td></tr>
<tr><td><code id="comboCount_+3A_repetition">repetition</code></td>
<td>
<p>Logical value indicating whether combinations/permutations should be with or without repetition. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="comboCount_+3A_freqs">freqs</code></td>
<td>
<p>A vector of frequencies used for producing all combinations/permutations of a multiset of <code>v</code>. Each element of <code>freqs</code> represents how many times each element of the source vector, <code>v</code>, is repeated. It is analogous to the <code>times</code> argument in <code><a href="base.html#topic+rep">rep</a></code>. The default value is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numerical value representing the total number of combinations/permutations.
</p>


<h3>Note</h3>

<p>When the number of results exceeds <code class="reqn">2^{53} - 1</code>, a number of class <code>bigz</code> is returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+comboGeneral">comboGeneral</a></code>, <code><a href="#topic+permuteGeneral">permuteGeneral</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Same interface as the respective "general" functions:
## i.e. comboGeneral &amp; permuteGeneral

permuteCount(-5)
permuteCount(5)
comboCount(25, 12)
permuteCount(15, 7, TRUE)
comboCount(25, 12, freqs = rep(2, 25))

## Return object of class 'bigz'
comboCount(250, 15, freqs = rep(2, 250))
</code></pre>

<hr>
<h2 id='comboGeneral'>
Generate Combinations and Permutations of a Vector with/without Constraints
</h2><span id='topic+comboGeneral'></span><span id='topic+comboGeneral.integer'></span><span id='topic+comboGeneral.numeric'></span><span id='topic+comboGeneral.factor'></span><span id='topic+comboGeneral.logical'></span><span id='topic+comboGeneral.default'></span><span id='topic+comboGeneral.table'></span><span id='topic+comboGeneral.list'></span><span id='topic+permuteGeneral'></span><span id='topic+permuteGeneral.integer'></span><span id='topic+permuteGeneral.numeric'></span><span id='topic+permuteGeneral.factor'></span><span id='topic+permuteGeneral.logical'></span><span id='topic+permuteGeneral.default'></span><span id='topic+permuteGeneral.table'></span><span id='topic+permuteGeneral.list'></span>

<h3>Description</h3>


<ul>
<li><p> Generate combinations or permutations of a vector with or without constraints.
</p>
</li>
<li><p> Produce results in parallel using the <code>Parallel</code> or <code>nThreads</code> arguments. You can also apply each of the five compiled functions given by the argument <code>constraintFun</code> in parallel.
</p>
</li>
<li><p> The arguments <code>lower</code> and <code>upper</code> make it possible to generate combinations/permutations in chunks allowing for parallelization via the <code><a href="parallel.html#topic+parallel-package">parallel-package</a></code>. This is convenient when you want to apply a custom function to the output in parallel.
</p>
</li>
<li><p> Attack integer partition and general subset sum problems.
</p>
</li>
<li><p> GMP support allows for exploration of combinations/permutations of vectors with many elements.
</p>
</li>
<li><p> The output is in lexicographical order.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>comboGeneral(v, m = NULL, ...)
permuteGeneral(v, m = NULL, ...)

## S3 method for class 'numeric'
comboGeneral(v, m = NULL, repetition = FALSE, freqs = NULL,
             lower = NULL, upper = NULL, constraintFun = NULL,
             comparisonFun = NULL, limitConstraints = NULL,
             keepResults = NULL, FUN = NULL, Parallel = FALSE,
             nThreads = NULL, tolerance = NULL, FUN.VALUE = NULL, ...)

## S3 method for class 'numeric'
permuteGeneral(v, m = NULL, repetition = FALSE, freqs = NULL,
               lower = NULL, upper = NULL, constraintFun = NULL,
               comparisonFun = NULL, limitConstraints = NULL,
               keepResults = NULL, FUN = NULL, Parallel = FALSE,
               nThreads = NULL, tolerance = NULL, FUN.VALUE = NULL, ...)

## S3 method for class 'factor'
comboGeneral(
    v, m = NULL, repetition = FALSE, freqs = NULL, lower = NULL, upper = NULL,
    FUN = NULL, Parallel = FALSE, nThreads = NULL, FUN.VALUE = NULL, ...
)
## S3 method for class 'factor'
permuteGeneral(
    v, m = NULL, repetition = FALSE, freqs = NULL, lower = NULL, upper = NULL,
    FUN = NULL, Parallel = FALSE, nThreads = NULL, FUN.VALUE = NULL, ...
)

## Default S3 method:
comboGeneral(v, m = NULL, repetition = FALSE,
             freqs = NULL, lower = NULL, upper = NULL,
             FUN = NULL, FUN.VALUE = NULL, ...)
## Default S3 method:
permuteGeneral(v, m = NULL, repetition = FALSE,
               freqs = NULL, lower = NULL, upper = NULL,
               FUN = NULL, FUN.VALUE = NULL, ...)

## S3 method for class 'table'
comboGeneral(
    v, m = NULL, lower = NULL, upper = NULL, constraintFun = NULL,
    comparisonFun = NULL, limitConstraints = NULL, keepResults = NULL,
    FUN = NULL, Parallel = FALSE, nThreads = NULL, tolerance = NULL,
    FUN.VALUE = NULL, ...
)
## S3 method for class 'table'
permuteGeneral(
    v, m = NULL, lower = NULL, upper = NULL, constraintFun = NULL,
    comparisonFun = NULL, limitConstraints = NULL, keepResults = NULL,
    FUN = NULL, Parallel = FALSE, nThreads = NULL, tolerance = NULL,
    FUN.VALUE = NULL, ...
)

## S3 method for class 'list'
comboGeneral(v, m = NULL, repetition = FALSE,
             freqs = NULL, lower = NULL, upper = NULL, ...)
## S3 method for class 'list'
permuteGeneral(v, m = NULL, repetition = FALSE,
               freqs = NULL, lower = NULL, upper = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comboGeneral_+3A_v">v</code></td>
<td>
<p>Source vector. If <code>v</code> is a positive integer, it will be converted to the sequence <code>1:v</code>. If <code>v</code> is a negative integer, it will be converted to the sequence <code>v:-1</code>. All atomic types are supported (See <code><a href="base.html#topic+is.atomic">is.atomic</a></code>).</p>
</td></tr>
<tr><td><code id="comboGeneral_+3A_m">m</code></td>
<td>
<p>Number of elements to choose.  If <code>repetition = TRUE</code> or <code>freqs</code> is utilized, <code>m</code> can exceed the length of <code>v</code>. If <code>m = NULL</code>, the length will default to <code>length(v)</code> or <code>sum(freqs)</code>.</p>
</td></tr>
<tr><td><code id="comboGeneral_+3A_...">...</code></td>
<td>
<p>Further arguments passed to methods.</p>
</td></tr>
<tr><td><code id="comboGeneral_+3A_repetition">repetition</code></td>
<td>
<p>Logical value indicating whether combinations/permutations should be with or without repetition. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="comboGeneral_+3A_freqs">freqs</code></td>
<td>
<p>A vector of frequencies used for producing all combinations/permutations of a multiset of <code>v</code>. Each element of <code>freqs</code> represents how many times each element of the source vector, <code>v</code>, is repeated. It is analogous to the <code>times</code> argument in <code><a href="base.html#topic+rep">rep</a></code>. The default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="comboGeneral_+3A_lower">lower</code></td>
<td>
<p>The lower bound. Combinations/permutations are generated lexicographically, thus utilizing this argument will determine which specific combination/permutation to start generating from (<em>e.g.</em> <code>comboGeneral(5, 3, lower = 6)</code> is equivalent to <code>comboGeneral(5, 3)[6:choose(5, 3), ]</code>). This argument along with <code>upper</code> is very useful for generating combinations/permutations in chunks allowing for easy parallelization.</p>
</td></tr>
<tr><td><code id="comboGeneral_+3A_upper">upper</code></td>
<td>
<p>The upper bound. Similar to <code>lower</code>, however this parameter allows the user to <em>stop</em> generation at a specific combination/permutation (<em>e.g.</em> <code>comboGeneral(5, 3, upper = 5)</code> is equivalent to <code>comboGeneral(5, 3)[1:5, ]</code>)
</p>
<p>If the output is constrained and <code>lower</code> isn't supplied, <code>upper</code> serves as a cap for how many results will be returned that meet the criteria (<em>e.g.</em> setting <code>upper = 100</code> alone will return the first 100 results that meet the criteria, while setting <code>lower = 1</code> and <code>upper = 100</code> will test the first 100 results against the criteria).
</p>
<p>In addition to the benefits listed for <code>lower</code>, this parameter is useful when the total number of combinations/permutations without constraint is large and you expect/need a small number of combinations/permutations that meet a certain criteria. Using <code>upper</code> can improve run time if used judiciously as we call the member function <a href="https://en.cppreference.com/w/cpp/container/vector/reserve">reserve</a> of <a href="https://en.cppreference.com/w/cpp/container/vector">std::vector</a>. See examples below.</p>
</td></tr>
<tr><td><code id="comboGeneral_+3A_constraintfun">constraintFun</code></td>
<td>
<p>Function to be applied to the elements of <code>v</code> that should be passed as a string (<em>e.g.</em> <code>constraintFun = "sum"</code>). The possible constraint functions are: <code>"sum"</code>, <code>"prod"</code>, <code>"mean"</code>, <code>"max"</code>, &amp; <code>"min"</code>. The default is <code>NULL</code>, meaning no function is applied.</p>
</td></tr>
<tr><td><code id="comboGeneral_+3A_comparisonfun">comparisonFun</code></td>
<td>
<p>Comparison operator that will be used to compare <code>limitConstraints</code> with the result of <code>constraintFun</code> applied to <code>v</code>. It should be passed as a string or a vector of two strings (<em>e.g.</em> <code>comparisonFun = "&lt;="</code> or  <code>comparisonFun = c("&gt;","&lt;")</code>). The possible comparison operators are: <code>"&lt;"</code>, <code>"&gt;"</code>, <code>"&lt;="</code>, <code>"&gt;="</code>, <code>"=="</code>. The default is <code>NULL</code>.
</p>
<p>When <code>comparisonFun</code> is a vector of two comparison strings, <em>e.g</em> <code>comparisonFun = c(comp1, comp2)</code>, and <code>limitConstraints</code> is a vector of two numerical values, <em>e.g</em> <code>limitConstraints = c(x1, x2)</code>, the combinations/permutations will be filtered in one of the following two ways:
</p>

<ol>
<li><p>When <code>comp1</code> is one of the 'greater-than' operators (<em>i.e.</em> &quot;&gt;=&quot; or &quot;&gt;&quot;), <code>comp2</code> is one of the 'less-than' operators (<em>i.e.</em> &quot;&lt;=&quot; or &quot;&lt;&quot;), and <code>x1 &lt; x2</code>, the combinations/permutations that are returned will have a value (after <code>constraintFun</code> has been applied) between <code>x1</code> and <code>x2</code>.
</p>
</li>
<li><p>When <code>comp1</code> and <code>comp2</code> are defined as in #1 and <code>x1 &gt; x2</code>, the combinations/permutations that are returned will have a value outside the range of <code>x1</code> and <code>x2</code>. See the examples below.
</p>
</li></ol>

<p>In other words, the first comparison operator is applied to the first limit and the second operator is applied to the second limit.</p>
</td></tr>
<tr><td><code id="comboGeneral_+3A_limitconstraints">limitConstraints</code></td>
<td>
<p>This is the value(s) that will be used for comparison. Can be passed as a single value or a vector of two numerical values. The default is <code>NULL</code>. See the definition of <code>comparisonFun</code> as well as the examples below for more information.</p>
</td></tr>
<tr><td><code id="comboGeneral_+3A_keepresults">keepResults</code></td>
<td>
<p>A logical flag indicating if the result of <code>constraintFun</code> applied to <code>v</code> should be displayed; if <code>TRUE</code>, an additional column of results will be added to the resulting matrix. The default is <code>FALSE</code>. If user is only applying <code>constraintFun</code>, <code>keepResults</code> will default to <code>TRUE</code>.
</p>
<p><em>E.g</em>. The following are equivalent and will produce a <code class="reqn">4^{th}</code> column of row sums:
</p>

<ul>
<li> <p><code>comboGeneral(5, 3 constraintFun = "sum", keepResults = TRUE)</code>
</p>
</li>
<li> <p><code>comboGeneral(5, 3 constraintFun = "sum")</code>
</p>
</li></ul>

</td></tr>
<tr><td><code id="comboGeneral_+3A_fun">FUN</code></td>
<td>
<p>Function to be applied to each combination/permutation. The default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="comboGeneral_+3A_parallel">Parallel</code></td>
<td>
<p>Logical value indicating whether combinations/permutations should be generated in parallel using <code class="reqn">n - 1</code> threads, where <code class="reqn">n</code> is the maximum number of threads. The default is <code>FALSE</code>. If <code>nThreads</code> is not <code>NULL</code>, it will be given preference (<em>e.g.</em> if user has 8 threads with <code>Parallel = TRUE</code> and <code>nThreads = 4</code>, only 4 threads will be spawned). If your system is single-threaded, the arguments <code>Parallel</code> and <code>nThreads</code> are ignored.</p>
</td></tr>
<tr><td><code id="comboGeneral_+3A_nthreads">nThreads</code></td>
<td>
<p>Specific number of threads to be used. The default is <code>NULL</code>. See <code>Parallel</code>.</p>
</td></tr>
<tr><td><code id="comboGeneral_+3A_tolerance">tolerance</code></td>
<td>
<p>A numeric value greater than or equal to zero. This parameter is utilized when a constraint is applied on a numeric vector. The default value is 0 when it can be determined that whole values are being utilized, otherwise it is <code>sqrt(.Machine$double.eps)</code> which is approximately <code class="reqn">1.5e-8</code>. N.B. If the input vector is of type integer, this parameter will be ignored and strict equality will be enforced.</p>
</td></tr>
<tr><td><code id="comboGeneral_+3A_fun.value">FUN.VALUE</code></td>
<td>
<p>A template for the return value from <code>FUN</code>. See 'Details' of <code><a href="base.html#topic+vapply">vapply</a></code> for more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the general case, finding all combinations/permutations with constraints is optimized by organizing them in such a way that when <code>constraintFun</code> is applied, a <em>partially</em> monotonic sequence is produced. Combinations/permutations are added successively, until a particular combination exceeds the given constraint value for a given constraint/comparison function combo. After this point, we can safely skip several combinations knowing that they will exceed the given constraint value.
</p>
<p>There are special cases where more efficient algorithms are dyncamically deployed. These cases center around the subject of integer partitions. See <code><a href="#topic+partitionsGeneral">partitionsGeneral</a></code> for more information.
</p>
<p>When there are any negative values in <code>v</code> and <code>constraintFun = "prod"</code>, producing a monotonic set is non-trivial for the general case. As a result, performance will suffer as all combinations/permutations must be tested against the constraint criteria.
</p>


<h3>Value</h3>


<ul>
<li><p> In general, a matrix with <code class="reqn">m</code> or <code class="reqn">m + 1</code> columns, depending on the value of <code>keepResults</code>
</p>
</li>
<li><p> If <code>FUN</code> is utilized and <code>FUN.VALUE = NULL</code>, a list is returned
</p>
</li>
<li><p> When both <code>FUN</code> and <code>FUN.VALUE</code> are not <code>NULL</code>, the return is modeled after the return of <code>vapply</code>. See the 'Value' section of <code><a href="base.html#topic+vapply">vapply</a></code>.
</p>
</li></ul>



<h3>Note</h3>


<ul>
<li> <p><code>Parallel</code> and <code>nThreads</code> will be ignored in the following cases:
</p>

<ul>
<li><p> When the output is constrained (except for most partitions cases)
</p>
</li>
<li><p> If the class of the vector passed is <code>character</code>, <code>raw</code>, and <code>complex</code> (N.B. <code>Rcpp::CharacterMatrix</code> is not thread safe). Alternatively, you can generate an indexing matrix in parallel.
</p>
</li>
<li><p> If <code>FUN</code> is utilized.
</p>
</li></ul>


</li>
<li><p> If either <code>constraintFun</code>, <code>comparisonFun</code> or <code>limitConstraints</code> is <code>NULL</code> &ndash;or&ndash; if the class of the vector passed is <code>logical</code>, <code>character</code>, <code>raw</code>, <code>factor</code>, or <code>complex</code>, the constraint check will not be carried out. This is equivalent to simply finding all combinations/permutations of <code class="reqn">v</code> choose <code class="reqn">m</code>.
</p>
</li>
<li><p> The maximum number of combinations/permutations that can be generated at one time is <code class="reqn">2^{31} - 1</code>. Utilizing <code>lower</code> and <code>upper</code> makes it possible to generate additional combinations/permutations.
</p>
</li>
<li><p> Factor vectors are accepted. Class and level attributes are preserved except when <code>FUN</code> is used.
</p>
</li>
<li><p> Lexicographical ordering isn't guaranteed for permutations if <code>lower</code> isn't supplied and the output is constrained.
</p>
</li>
<li><p> If <code>lower</code> is supplied and the output is constrained, the combinations/permutations that will be tested will be in the lexicographical range <code>lower</code> to <code>upper</code> or up to the total possible number of results if <code>upper</code> is not given. See the second paragraph for the definition of <code>upper</code>.
</p>
</li>
<li> <p><code>FUN</code> will be ignored if the constraint check is satisfied.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Joseph Wood
</p>


<h3>References</h3>


<ul>
<li><p><a href="https://gallery.rcpp.org/articles/passing-cpp-function-pointers/">Passing user-supplied C++ functions</a>
</p>
</li>
<li><p><a href="https://en.wikipedia.org/wiki/Monotonic_function">Monotonic Sequence</a>
</p>
</li>
<li><p><a href="https://en.wikipedia.org/wiki/Multiset">Multiset</a>
</p>
</li>
<li><p><a href="https://en.wikipedia.org/wiki/Lexicographical_order">Lexicographical Order</a>
</p>
</li>
<li><p><a href="https://en.wikipedia.org/wiki/Subset_sum_problem">Subset Sum Problem</a>
</p>
</li>
<li><p><a href="https://en.wikipedia.org/wiki/Partition_(number_theory)">Partition (Number Theory)</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>comboGeneral(4, 3)
permuteGeneral(3)

permuteGeneral(factor(letters[1:3]), repetition = TRUE)

## permutations of the multiset :
## c(1,1,1,2,2,3)
permuteGeneral(table(c(1,1,1,2,2,3)))

## Example with list
comboGeneral(
    v = list(
        p1 = matrix(1:10, ncol = 2),
        p2 = data.frame(a = letters, b = 1:26),
        p3 = as.complex(1:10)
    ),
    m = 2
)

#### Examples using "upper" and "lower":
## See specific range of permutations
permuteGeneral(75, 10, freqs = rep(1:3, 25),
               lower = 1e12, upper = 1e12 + 10)

## Researcher only needs 10 7-tuples of mySamp
## such that the sum is greater than 7200.
## Generate some random data
set.seed(1009)
mySamp = rnorm(75, 997, 23)
comboGeneral(mySamp, 7, constraintFun = "sum",
             comparisonFun = "&gt;", limitConstraints = 7200, upper = 10)

## Similarly, you can use "lower" to obtain the last rows.
## Generate the last 10 rows
comboGeneral(mySamp, 7, lower = choose(75, 7) - 9)

## Or if you would like to generate a specific chunk,
## use both "lower" and "upper". E.g. Generate one
## million combinations starting with the 900,000,001
## lexicographic combination.
t1 = comboGeneral(mySamp, 7,
                  lower = 9*10^8 + 1,
                  upper = 9*10^8 + 10^6)

## class of the source vector is preserved
class(comboGeneral(5,3)[1,]) == class(1:5)
class(comboGeneral(c(1,2:5),3)[1,]) == class(c(1,2:5))
class(comboGeneral(factor(month.name),3)[1,]) == class(factor(month.name))

## Using keepResults will add a column of results
comboGeneral(-3, 6, TRUE,
             constraintFun = "sum",
             comparisonFun = "==",
             limitConstraints = -8,
             keepResults = TRUE)

## Using multiple constraints:

## Get combinations such that the product
## is between 3000 and 4000 inclusive
comboGeneral(5, 7, TRUE, constraintFun = "prod",
             comparisonFun = c("&gt;=","&lt;="),
             limitConstraints = c(3000, 4000),
             keepResults = TRUE)

## Or, get the combinations such that the
## product is less than or equal to 10 or
## greater than or equal to 40000
comboGeneral(5, 7, TRUE, constraintFun = "prod",
             comparisonFun = c("&lt;=","&gt;="),
             limitConstraints = c(10, 40000),
             keepResults = TRUE)

#### General subset sum problem
set.seed(516781810)
comboGeneral(runif(100, 0, 42), 5, constraintFun = "mean",
             comparisonFun = "==", limitConstraints = 30,
             tolerance = 0.0000002)


#### Integer Partitions
comboGeneral(0:5, 5, TRUE, constraintFun = "sum",
             comparisonFun = "==", limitConstraints = 5)


## Using FUN
comboGeneral(10000, 5, lower = 20, upper = 22,
             FUN = function(x) {
                 which(cummax(x) %% 2 == 1)
             })

## Not run: 
## Parallel example generating more than 2^31 - 1 combinations.
library(parallel)
numCores = detectCores() - 1

## 10086780 evenly divides choose(35, 15) and is "small enough" to
## generate quickly in chunks.
system.time(mclapply(seq(1, comboCount(35, 15), 10086780), function(x) {
    a = comboGeneral(35, 15, lower = x, upper = x + 10086779)
    ## do something
    x
}, mc.cores = numCores))


## Find 13-tuple combinations of 1:25 such
## that the mean is less than 10
system.time(myComb &lt;- comboGeneral(25, 13, FALSE,
                                   constraintFun = "mean",
                                   comparisonFun = "&lt;",
                                   limitConstraints = 10))

## Alternatively, you must generate all combinations and subsequently
## subset to obtain the combinations that meet the criteria
system.time(myComb2 &lt;- combn(25, 13))
system.time(myCols &lt;- which(colMeans(myComb2) &lt; 10))
system.time(myComb2 &lt;- myComb2[, myCols])

## Any variation is much slower
system.time(myComb2 &lt;- combn(25, 13)[,combn(25, 13, mean) &lt; 10])

## Test equality with myComb above
all.equal(myComb, t(myComb2))

## Fun example... see stackoverflow:
## https://stackoverflow.com/q/22218640/4408538
system.time(permuteGeneral(seq(0L,100L,10L), 8, TRUE,
                           constraintFun = "sum",
                           comparisonFun = "==",
                           limitConstraints = 100))

## These are called weak integer compositions. Below, we call
## compositionsGeneral which gives the same output except it
## in lexicographical order. See 'Note' above
system.time(compositionsGeneral(seq(0L,100L,10L), 8, TRUE, weak = TRUE))

## End(Not run)
</code></pre>

<hr>
<h2 id='comboGrid'>
Efficient Version of <code>expand.grid</code> Where order Does Not Matter
</h2><span id='topic+comboGrid'></span>

<h3>Description</h3>

<p>This function efficiently generates Cartesian-product-like output where order does not matter. It is loosely equivalent to the following:
</p>

<ul>
<li><p><code>t = expand.grid(list)</code>
</p>
</li>
<li><p><code>t = t[do.call(order, t), ]</code>
</p>
</li>
<li><p><code>key = apply(t, 1, function(x) paste0(sort(x), collapse = ""))</code>
</p>
</li>
<li><p><code>t[!duplicated(key), ]</code>
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>comboGrid(..., repetition = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comboGrid_+3A_...">...</code></td>
<td>
<p>vectors, factors or a list containing these. (See <code>?expand.grid</code>).</p>
</td></tr>
<tr><td><code id="comboGrid_+3A_repetition">repetition</code></td>
<td>
<p>Logical value indicating whether results should be with or without repetition. The default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If items with different classes are passed, a data frame will be returned, otherwise a matrix will be returned.
</p>


<h3>Author(s)</h3>

<p>Joseph Wood
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## return a matrix
expGridNoOrder = comboGrid(1:5, 3:9, letters[1:5], letters[c(1,4,5,8)])
head(expGridNoOrder)
tail(expGridNoOrder)

expGridNoOrderNoRep = comboGrid(1:5, 3:9, letters[1:5],
                                letters[c(1,4,5,8)], repetition = FALSE)

head(expGridNoOrderNoRep)
tail(expGridNoOrderNoRep)
</code></pre>

<hr>
<h2 id='comboGroups'>
Partition a Vector into Groups
</h2><span id='topic+comboGroups'></span>

<h3>Description</h3>


<ul>
<li><p> Generate partitions of a vector into groups. See <a href="https://stackoverflow.com/q/57732672/4408538">Create Combinations in R by Groups</a> on https://stackoverflow.com for a direct use case of when the groups sizes are equal.
</p>
</li>
<li><p> Produce results in parallel using the <code>Parallel</code> or <code>nThreads</code> arguments.
</p>
</li>
<li><p> GMP support allows for exploration where the number of results is large.
</p>
</li>
<li><p> The output is in lexicographical order by groups.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>comboGroups(v, numGroups = NULL, grpSizes = NULL,
            retType = "matrix", lower = NULL, upper = NULL,
            Parallel = FALSE, nThreads = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comboGroups_+3A_v">v</code></td>
<td>
<p>Source vector. If <code>v</code> is a positive integer, it will be converted to the sequence <code>1:v</code>. If <code>v</code> is a negative integer, it will be converted to the sequence <code>v:-1</code>. All atomic types are supported (See <code><a href="base.html#topic+is.atomic">is.atomic</a></code>).</p>
</td></tr>
<tr><td><code id="comboGroups_+3A_numgroups">numGroups</code></td>
<td>
<p>An Integer. The number of groups that the vector will be partitioned into. The default is <code>NULL</code>. If provided and <code>grpSize</code> is <code>NULL</code>, it must divide the length of v (if v is a vector) or v (if v is a scalar).</p>
</td></tr>
<tr><td><code id="comboGroups_+3A_grpsizes">grpSizes</code></td>
<td>
<p>A vector of whole numbers representing the size of each group. The default is <code>NULL</code>. If provided, the sum of the elements must total the length of v (if v is a vector) or v (if v is a scalar).</p>
</td></tr>
<tr><td><code id="comboGroups_+3A_rettype">retType</code></td>
<td>
<p>A string, &quot;3Darray&quot; or &quot;matrix&quot;, that determines the shape of the output. The default is &quot;matrix&quot;. Note, &quot;3Darray&quot; can only be used when the size of each group is uniform. When the size of each group varies, the return output will always be a matrix.</p>
</td></tr>
<tr><td><code id="comboGroups_+3A_lower">lower</code></td>
<td>
<p>The lower bound. Partitions of groups are generated lexicographically, thus utilizing this argument will determine which specific result to start generating from (<em>e.g.</em> <code>comboGroups(8, 2, lower = 30)</code> is equivalent to <code>comboGroups(8, 2)[30:comboGroupsCount(8, 2), ]</code>). This argument along with <code>upper</code> is very useful for generating results in chunks allowing for easy parallelization.</p>
</td></tr>
<tr><td><code id="comboGroups_+3A_upper">upper</code></td>
<td>
<p>The upper bound. Similar to <code>lower</code>, however this parameter allows the user to <em>stop</em> generation at a specific result (<em>e.g.</em> <code>comboGroups(8, 2, upper = 5)</code> is equivalent to <code>comboGroups(8, 2)[1:5, ]</code>)</p>
</td></tr>
<tr><td><code id="comboGroups_+3A_parallel">Parallel</code></td>
<td>
<p>Logical value indicating whether results should be generated in parallel using <code class="reqn">n - 1</code> threads, where <code class="reqn">n</code> is the maximum number of threads. The default is <code>FALSE</code>. If <code>nThreads</code> is not <code>NULL</code>, it will be given preference (<em>e.g.</em> if user has 8 threads with <code>Parallel = TRUE</code> and <code>nThreads = 4</code>, only 4 threads will be spawned). If your system is single-threaded, the arguments <code>Parallel</code> and <code>nThreads</code> are ignored.</p>
</td></tr>
<tr><td><code id="comboGroups_+3A_nthreads">nThreads</code></td>
<td>
<p>Specific number of threads to be used. The default is <code>NULL</code>. See <code>Parallel</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Conceptually, this problem can be viewed as generating all permutations of the vector <code>v</code> and removing the within group permutations. To illustrate this, let us consider the case of generating partitions of <code>1:8</code> into 2 groups each of size 4.
</p>

<ul>
<li><p>To begin, generate the permutations of <code>1:8</code> and group the first/last four elements of each row.
</p>

<table>
<tr>
 <td style="text-align: center;">
      </td><td style="text-align: center;"> </td><td style="text-align: center;"> </td><td style="text-align: center;"> Grp1 </td><td style="text-align: center;"> </td><td style="text-align: center;"> </td><td style="text-align: center;"> Grp2 </td><td style="text-align: center;"> </td><td style="text-align: center;"> </td>
</tr>
<tr>
 <td style="text-align: center;">
      </td><td style="text-align: center;"> C1</td><td style="text-align: center;"> C2</td><td style="text-align: center;"> C3</td><td style="text-align: center;"> C4</td><td style="text-align: center;"> C5</td><td style="text-align: center;"> C6</td><td style="text-align: center;"> C7</td><td style="text-align: center;"> C8</td>
</tr>
<tr>
 <td style="text-align: center;">
      R1 </td><td style="text-align: center;">  | 1 </td><td style="text-align: center;"> 2 </td><td style="text-align: center;"> 3 </td><td style="text-align: center;"> 4 | </td><td style="text-align: center;"> | 5 </td><td style="text-align: center;"> 6 </td><td style="text-align: center;"> 7 </td><td style="text-align: center;"> 8 |</td>
</tr>
<tr>
 <td style="text-align: center;">
      R2 </td><td style="text-align: center;">  | 1 </td><td style="text-align: center;"> 2 </td><td style="text-align: center;"> 3 </td><td style="text-align: center;"> 4 | </td><td style="text-align: center;"> | 5 </td><td style="text-align: center;"> 6 </td><td style="text-align: center;"> 8 </td><td style="text-align: center;"> 7 |</td>
</tr>
<tr>
 <td style="text-align: center;">
      R3 </td><td style="text-align: center;">  | 1 </td><td style="text-align: center;"> 2 </td><td style="text-align: center;"> 3 </td><td style="text-align: center;"> 4 | </td><td style="text-align: center;"> | 5 </td><td style="text-align: center;"> 7 </td><td style="text-align: center;"> 6 </td><td style="text-align: center;"> 8 |</td>
</tr>
<tr>
 <td style="text-align: center;">
      R4 </td><td style="text-align: center;">  | 1 </td><td style="text-align: center;"> 2 </td><td style="text-align: center;"> 3 </td><td style="text-align: center;"> 4 | </td><td style="text-align: center;"> | 5 </td><td style="text-align: center;"> 7 </td><td style="text-align: center;"> 8 </td><td style="text-align: center;"> 6 |</td>
</tr>
<tr>
 <td style="text-align: center;">
      R5 </td><td style="text-align: center;">  | 1 </td><td style="text-align: center;"> 2 </td><td style="text-align: center;"> 3 </td><td style="text-align: center;"> 4 | </td><td style="text-align: center;"> | 5 </td><td style="text-align: center;"> 8 </td><td style="text-align: center;"> 6 </td><td style="text-align: center;"> 7 |</td>
</tr>
<tr>
 <td style="text-align: center;">
      R6 </td><td style="text-align: center;">  | 1 </td><td style="text-align: center;"> 2 </td><td style="text-align: center;"> 3 </td><td style="text-align: center;"> 4 | </td><td style="text-align: center;"> | 5 </td><td style="text-align: center;"> 8 </td><td style="text-align: center;"> 7 </td><td style="text-align: center;"> 6 |
      </td>
</tr>

</table>


</li>
<li><p>Note that the permutations above are equivalent partitions of 2 groups of size 4 as only the last four elements are permuted. If we look at at the <code class="reqn">25^{th}</code> lexicographical permutation, we observe our second distinct partition.
</p>

<table>
<tr>
 <td style="text-align: center;">
      </td><td style="text-align: center;"> </td><td style="text-align: center;"> </td><td style="text-align: center;"> Grp1 </td><td style="text-align: center;"> </td><td style="text-align: center;"> </td><td style="text-align: center;"> Grp2 </td><td style="text-align: center;"> </td><td style="text-align: center;"> </td>
</tr>
<tr>
 <td style="text-align: center;">
      </td><td style="text-align: center;"> C1</td><td style="text-align: center;"> C2</td><td style="text-align: center;"> C3</td><td style="text-align: center;"> C4</td><td style="text-align: center;"> C5</td><td style="text-align: center;"> C6</td><td style="text-align: center;"> C7</td><td style="text-align: center;"> C8</td>
</tr>
<tr>
 <td style="text-align: center;">
      R24 </td><td style="text-align: center;">  | 1 </td><td style="text-align: center;"> 2 </td><td style="text-align: center;"> 3 </td><td style="text-align: center;"> 4 | </td><td style="text-align: center;"> | 8 </td><td style="text-align: center;"> 7 </td><td style="text-align: center;"> 6 </td><td style="text-align: center;"> 5 |</td>
</tr>
<tr>
 <td style="text-align: center;">
      <strong>R25</strong> </td><td style="text-align: center;">  <strong>| 1</strong> </td><td style="text-align: center;"> <strong>2</strong> </td><td style="text-align: center;"> <strong>3</strong> </td><td style="text-align: center;"> <strong>5 |</strong> </td><td style="text-align: center;"> <strong>| 4</strong> </td><td style="text-align: center;"> <strong>6</strong> </td><td style="text-align: center;"> <strong>7</strong> </td><td style="text-align: center;"> <strong>8 |</strong></td>
</tr>
<tr>
 <td style="text-align: center;">
      R26 </td><td style="text-align: center;">  | 1 </td><td style="text-align: center;"> 2 </td><td style="text-align: center;"> 3 </td><td style="text-align: center;"> 5 | </td><td style="text-align: center;"> | 4 </td><td style="text-align: center;"> 6 </td><td style="text-align: center;"> 8 </td><td style="text-align: center;"> 7 |</td>
</tr>
<tr>
 <td style="text-align: center;">
      R27 </td><td style="text-align: center;">  | 1 </td><td style="text-align: center;"> 2 </td><td style="text-align: center;"> 3 </td><td style="text-align: center;"> 5 | </td><td style="text-align: center;"> | 4 </td><td style="text-align: center;"> 7 </td><td style="text-align: center;"> 6 </td><td style="text-align: center;"> 8 |</td>
</tr>
<tr>
 <td style="text-align: center;">
      R28 </td><td style="text-align: center;">  | 1 </td><td style="text-align: center;"> 2 </td><td style="text-align: center;"> 3 </td><td style="text-align: center;"> 5 | </td><td style="text-align: center;"> | 4 </td><td style="text-align: center;"> 7 </td><td style="text-align: center;"> 8 </td><td style="text-align: center;"> 6 |
      </td>
</tr>

</table>


</li>
<li><p>Continuing on, we will reach the <code class="reqn">3,457^{th}</code> lexicographical permutation, which represents the last result:
</p>

<table>
<tr>
 <td style="text-align: center;">
      </td><td style="text-align: center;"> </td><td style="text-align: center;"> </td><td style="text-align: center;"> Grp1 </td><td style="text-align: center;"> </td><td style="text-align: center;"> </td><td style="text-align: center;"> Grp2 </td><td style="text-align: center;"> </td><td style="text-align: center;"> </td>
</tr>
<tr>
 <td style="text-align: center;">
      </td><td style="text-align: center;"> C1</td><td style="text-align: center;"> C2</td><td style="text-align: center;"> C3</td><td style="text-align: center;"> C4</td><td style="text-align: center;"> C5</td><td style="text-align: center;"> C6</td><td style="text-align: center;"> C7</td><td style="text-align: center;"> C8</td>
</tr>
<tr>
 <td style="text-align: center;">
      R3454 </td><td style="text-align: center;">  | 1 </td><td style="text-align: center;"> 6 </td><td style="text-align: center;"> 7 </td><td style="text-align: center;"> 5 | </td><td style="text-align: center;"> |8 </td><td style="text-align: center;"> 3 </td><td style="text-align: center;"> 4 </td><td style="text-align: center;"> 2 |</td>
</tr>
<tr>
 <td style="text-align: center;">
      R3455 </td><td style="text-align: center;">  | 1 </td><td style="text-align: center;"> 6 </td><td style="text-align: center;"> 7 </td><td style="text-align: center;"> 5 | </td><td style="text-align: center;"> |8 </td><td style="text-align: center;"> 4 </td><td style="text-align: center;"> 2 </td><td style="text-align: center;"> 3 |</td>
</tr>
<tr>
 <td style="text-align: center;">
      R3456 </td><td style="text-align: center;">  | 1 </td><td style="text-align: center;"> 6 </td><td style="text-align: center;"> 7 </td><td style="text-align: center;"> 5 | </td><td style="text-align: center;"> |8 </td><td style="text-align: center;"> 4 </td><td style="text-align: center;"> 3 </td><td style="text-align: center;"> 2 |</td>
</tr>
<tr>
 <td style="text-align: center;">
      <strong>R3457</strong> </td><td style="text-align: center;">  <strong>| 1</strong> </td><td style="text-align: center;"> <strong>6</strong> </td><td style="text-align: center;"> <strong>7</strong> </td><td style="text-align: center;"> <strong>8 |</strong> </td><td style="text-align: center;"> <strong>| 2</strong> </td><td style="text-align: center;"> <strong>3</strong> </td><td style="text-align: center;"> <strong>4</strong> </td><td style="text-align: center;"> <strong>5 |</strong></td>
</tr>
<tr>
 <td style="text-align: center;">
      R3458 </td><td style="text-align: center;">  | 1 </td><td style="text-align: center;"> 6 </td><td style="text-align: center;"> 7 </td><td style="text-align: center;"> 8 | </td><td style="text-align: center;"> |2 </td><td style="text-align: center;"> 3 </td><td style="text-align: center;"> 5 </td><td style="text-align: center;"> 4 |
      </td>
</tr>

</table>


</li>
<li>
<p>For this small example, the method above will not be that computationally expensive. In fact, there are only 35 total partitions of <code>1:8</code> into 2 groups of size 4 out of a possible <code>factorial(8) = 40320</code> permutations. However, just doubling the size of the vector will make this approach infeasible as there are over 10 trillion permutations of <code>1:16</code>.

</p>
</li>
<li><p>The algorithm in <code>comboGroups</code> avoids these duplicate partitions of groups by utilizing an efficient algorithm analogous to the <a href="https://en.cppreference.com/w/cpp/algorithm/next_permutation">std::next_permutation</a> found in the standard algorithm library in C++.

</p>
</li></ul>



<h3>Value</h3>

<p>By default, a matrix is returned with column names corresponding to the associated group. If <code>retType = "3Darray"</code>, a named 3D array is returned.
</p>


<h3>Note</h3>


<ul>
<li><p>The maximum number of partitions of groups that can be generated at one time is <code class="reqn">2^{31} - 1</code>. Utilizing <code>lower</code> and <code>upper</code> makes it possible to generate additional combinations/permutations.
</p>
</li>
<li><p>The length of <code>grpSizes</code> must equal <code>numGroups</code> if both <code>grpSize</code> and <code>numGroups</code> are provided.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Joseph Wood
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## return a matrix
comboGroups(8, 2)

## or a 3 dimensional array
temp = comboGroups(8, 2, retType = "3Darray")

## view the first partition
temp[1, , ]

## Example with groups of varying size
comboGroups(8, grpSizes = c(3, 5))

total = comboGroupsCount(11, grpSizes = c(3, 3, 5))

## Start generating from particular index
comboGroups(11, grpSizes = c(3, 3, 5), lower = total - 20)
</code></pre>

<hr>
<h2 id='ComboGroups-class'>S4-class for Exposing C++ ComboGroups Class</h2><span id='topic+ComboGroups-class'></span><span id='topic++24+2CComboGroups-method'></span>

<h3>Description</h3>

<p>The <code>ComboGroups</code> class is an S4-class that exposes C++ classes that provide access to iterators and other useful methods.
</p>


<h3>Slots</h3>


<dl>
<dt><code>nextIter</code></dt><dd><p>Retrieve the <b>next</b> lexicographical result</p>
</dd>
<dt><code>nextNIter</code></dt><dd><p>Pass an integer <em>n</em> to retrieve the <b>next</b> <em>n</em> lexicographical results</p>
</dd>
<dt><code>nextRemaining</code></dt><dd><p>Retrieve all remaining lexicographical results</p>
</dd>
<dt><code>currIter</code></dt><dd><p>Returns the current iteration</p>
</dd>
<dt><code>startOver</code></dt><dd><p>Resets the iterator</p>
</dd>
<dt><code>sourceVector</code></dt><dd><p>View the source vector</p>
</dd>
<dt><code>summary</code></dt><dd><p>Returns a list of summary information about the iterator</p>
</dd>
<dt><code>front</code></dt><dd><p>Retrieve the <b>first</b> lexicographical result</p>
</dd>
<dt><code>back</code></dt><dd><p>Retrieve the <b>last</b> lexicographical result</p>
</dd>
<dt><code>randomAccess</code></dt><dd><p>Random access method. Pass a single value or a vector of valid indices. If a single value is passed, the internal index of the iterator will be updated, however if a vector is passed the internal state will not change. GMP support allows for flexible indexing.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Joseph Wood</p>


<h3>See Also</h3>

<p><code><a href="#topic+Combo-class">Combo-class</a></code>, <code><a href="#topic+Constraints-class">Constraints-class</a></code>, <code><a href="#topic+Partitions-class">Partitions-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  showClass("ComboGroups")
</code></pre>

<hr>
<h2 id='comboGroupsCount'>
Number of Partitions of a Vector into Groups
</h2><span id='topic+comboGroupsCount'></span>

<h3>Description</h3>

<p>Calculate the number of partitions of a vector into groups. See the related integer sequences A025035-A025042 at <a href="https://oeis.org">OEIS</a> (E.g. <a href="https://oeis.org/A025036">A025036</a> for Number of partitions of <code class="reqn"> 1, 2, ..., 4n </code> into sets of size 4.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comboGroupsCount(v, numGroups = NULL, grpSizes = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comboGroupsCount_+3A_v">v</code></td>
<td>
<p>Source vector. If <code>v</code> is a positive integer, it will be converted to the sequence <code>1:v</code>. If <code>v</code> is a negative integer, it will be converted to the sequence <code>v:-1</code>. All atomic types are supported (See <code><a href="base.html#topic+is.atomic">is.atomic</a></code>).</p>
</td></tr>
<tr><td><code id="comboGroupsCount_+3A_numgroups">numGroups</code></td>
<td>
<p>An Integer. The number of groups that the vector will be partitioned into. The default is <code>NULL</code>. If provided and <code>grpSize</code> is <code>NULL</code>, it must divide the length of v (if v is a vector) or v (if v is a scalar).</p>
</td></tr>
<tr><td><code id="comboGroupsCount_+3A_grpsizes">grpSizes</code></td>
<td>
<p>A vector of whole numbers representing the size of each group. The default is <code>NULL</code>. If provided, the sum of the elements must total the length of v (if v is a vector) or v (if v is a scalar).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numerical value representing the total number of partitions of groups.
</p>


<h3>Note</h3>

<p>When the number of results exceeds <code class="reqn">2^{53} - 1</code>, a number of class <code>bigz</code> is returned.
</p>


<h3>Author(s)</h3>

<p>Joseph Wood
</p>


<h3>References</h3>

<p><a href="https://oeis.org/A025036">OEIS Integer Sequence A025036</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comboGroupsCount(16, 4)
comboGroupsCount(16, grpSizes = c(1:4, 6))
comboGroupsCount(28, grpSizes = rep(2:5, each = 2))
</code></pre>

<hr>
<h2 id='comboGroupsIter'>
comboGroups Iterator
</h2><span id='topic+comboGroupsIter'></span>

<h3>Description</h3>


<ul>
<li><p> Returns an iterator for iterating over partitions of a vector into groups.
</p>
</li>
<li><p> Supports random access via the <code>[[</code> method.
</p>
</li>
<li><p> GMP support allows for exploration of cases where the number of comboGroups is large.
</p>
</li>
<li><p> Use the <code>next</code> methods to obtain results in lexicographical order.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>comboGroupsIter(v, numGroups = NULL, grpSizes = NULL,
                retType = "matrix", Parallel = FALSE,
                nThreads = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comboGroupsIter_+3A_v">v</code></td>
<td>
<p>Source vector. If <code>v</code> is a positive integer, it will be converted to the sequence <code>1:v</code>. If <code>v</code> is a negative integer, it will be converted to the sequence <code>v:-1</code>. All atomic types are supported (See <code><a href="base.html#topic+is.atomic">is.atomic</a></code>).</p>
</td></tr>
<tr><td><code id="comboGroupsIter_+3A_numgroups">numGroups</code></td>
<td>
<p>An Integer. The number of groups that the vector will be partitioned into. The default is <code>NULL</code>. If provided and <code>grpSize</code> is <code>NULL</code>, it must divide the length of v (if v is a vector) or v (if v is a scalar).</p>
</td></tr>
<tr><td><code id="comboGroupsIter_+3A_grpsizes">grpSizes</code></td>
<td>
<p>A vector of whole numbers representing the size of each group. The default is <code>NULL</code>. If provided, the sum of the elements must total the length of v (if v is a vector) or v (if v is a scalar).</p>
</td></tr>
<tr><td><code id="comboGroupsIter_+3A_rettype">retType</code></td>
<td>
<p>A string, &quot;3Darray&quot; or &quot;matrix&quot;, that determines the shape of the output. The default is &quot;matrix&quot;. Note, &quot;3Darray&quot; can only be used when the size of each group is uniform. When the size of each group varies, the return output will always be a matrix.</p>
</td></tr>
<tr><td><code id="comboGroupsIter_+3A_parallel">Parallel</code></td>
<td>
<p>Logical value indicating whether results should be generated in parallel using <code class="reqn">n - 1</code> threads, where <code class="reqn">n</code> is the maximum number of threads. The default is <code>FALSE</code>. If <code>nThreads</code> is not <code>NULL</code>, it will be given preference (<em>e.g.</em> if user has 8 threads with <code>Parallel = TRUE</code> and <code>nThreads = 4</code>, only 4 threads will be spawned). If your system is single-threaded, the arguments <code>Parallel</code> and <code>nThreads</code> are ignored.</p>
</td></tr>
<tr><td><code id="comboGroupsIter_+3A_nthreads">nThreads</code></td>
<td>
<p>Specific number of threads to be used. The default is <code>NULL</code>. See <code>Parallel</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Once you initialize a new iterator, the following methods are available:
</p>

<dl>
<dt><code>nextIter</code></dt><dd><p>Retrieve the <b>next</b> lexicographical result</p>
</dd>
<dt><code>nextNIter</code></dt><dd><p>Pass an integer <em>n</em> to retrieve the <b>next</b> <em>n</em> lexicographical results</p>
</dd>
<dt><code>nextRemaining</code></dt><dd><p>Retrieve all remaining lexicographical results</p>
</dd>
<dt><code>currIter</code></dt><dd><p>Returns the current iteration</p>
</dd>
<dt><code>startOver</code></dt><dd><p>Resets the iterator</p>
</dd>
<dt><code>sourceVector</code></dt><dd><p>View the source vector</p>
</dd>
<dt><code>summary</code></dt><dd><p>Returns a list of summary information about the iterator</p>
</dd>
<dt><code>front</code></dt><dd><p>Retrieve the <b>first</b> lexicographical result</p>
</dd>
<dt><code>back</code></dt><dd><p>Retrieve the <b>last</b> lexicographical result</p>
</dd>
<dt><code>[[</code></dt><dd><p>Random access method. Pass a single value or a vector of valid indices. If a single value is passed, the internal index of the iterator will be updated, however if a vector is passed the internal state will not change. GMP support allows for flexible indexing.</p>
</dd>
</dl>



<h3>Value</h3>


<ul>
<li><p> If <code>nextIter</code> is called, a named vector is returned if <code>retType = "matrix"</code>. If <code>retType = "3Darray"</code>, a named matrix is returned.
</p>
</li>
<li><p> Otherwise a named matrix is returned when <code>retType = "matrix"</code> and a named 3D array is returned when <code>retType = "3Darray"</code>.
</p>
</li></ul>



<h3>Note</h3>


<ul>
<li><p>If <code>nThreads</code> is utilized, it will only take effect if the number of elements requested is greater than some threshold (determined internally). <em>E.g</em>:
</p>
<pre>serial   &lt;- comboGroupsIter(50, 10)
multi    &lt;- comboGroupsIter(50, 10, nThreads = 4)
fetch1e6 &lt;- multi@nextNIter(1e6)  ## much faster than serial@nextNIter(1e6)
fetch1e3 &lt;- multi@nextNIter(1e3)  ## only one thread used... same as serial@nextNIter(1e3)

library(microbenchmark)
microbenchmark(multi@nextNIter(1e6), serial@nextNIter(1e6), times = 20)
microbenchmark(multi@nextNIter(1e3), serial@nextNIter(1e3), times = 20)</pre>

</li>
<li><p>The maximum number of comboGroups that can be generated at one time is <code class="reqn">2^{31} - 1</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Joseph Wood
</p>


<h3>See Also</h3>

<p><a href="#topic+comboGroups">comboGroups</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>a = comboGroupsIter(12, 3)
a@nextIter()
a@nextNIter(3)
a@front()
all_remaining = a@nextRemaining()
dim(all_remaining)
a@summary()
a@back()
a[[5]]
a@summary()
a[[c(1, 17, 3)]]
a@summary()
</code></pre>

<hr>
<h2 id='comboGroupsSample'>
Sample Partitions of a Vector into Groups
</h2><span id='topic+comboGroupsSample'></span>

<h3>Description</h3>


<ul>
<li><p> Generate a specific (lexicographically) or random sample of partitions of groups.
</p>
</li>
<li><p> Produce results in parallel using the <code>Parallel</code> or <code>nThreads</code> arguments.
</p>
</li>
<li><p> GMP support allows for exploration where the number of results is large.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>comboGroupsSample(v, numGroups = NULL, grpSizes = NULL, retType = "matrix",
                  n = NULL, sampleVec = NULL, seed = NULL, Parallel = FALSE,
                  nThreads = NULL, namedSample = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comboGroupsSample_+3A_v">v</code></td>
<td>
<p>Source vector. If <code>v</code> is a positive integer, it will be converted to the sequence <code>1:v</code>. If <code>v</code> is a negative integer, it will be converted to the sequence <code>v:-1</code>. All atomic types are supported (See <code><a href="base.html#topic+is.atomic">is.atomic</a></code>).</p>
</td></tr>
<tr><td><code id="comboGroupsSample_+3A_numgroups">numGroups</code></td>
<td>
<p>An Integer. The number of groups that the vector will be partitioned into. The default is <code>NULL</code>. If provided and <code>grpSize</code> is <code>NULL</code>, it must divide the length of v (if v is a vector) or v (if v is a scalar).</p>
</td></tr>
<tr><td><code id="comboGroupsSample_+3A_grpsizes">grpSizes</code></td>
<td>
<p>A vector of whole numbers representing the size of each group. The default is <code>NULL</code>. If provided, the sum of the elements must total the length of v (if v is a vector) or v (if v is a scalar).</p>
</td></tr>
<tr><td><code id="comboGroupsSample_+3A_rettype">retType</code></td>
<td>
<p>A string, &quot;3Darray&quot; or &quot;matrix&quot;, that determines the shape of the output. The default is &quot;matrix&quot;. Note, &quot;3Darray&quot; can only be used when the size of each group is uniform. When the size of each group varies, the return output will always be a matrix.</p>
</td></tr>
<tr><td><code id="comboGroupsSample_+3A_n">n</code></td>
<td>
<p>Number of results to return. The default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="comboGroupsSample_+3A_samplevec">sampleVec</code></td>
<td>
<p>A vector of numbers representing the lexicographical partition of groups to return. Accepts vectors of class <code>bigz</code> as well as vectors of characters</p>
</td></tr>
<tr><td><code id="comboGroupsSample_+3A_seed">seed</code></td>
<td>
<p>Random seed initialization. The default is <code>NULL</code>. N.B. If the gmp library is needed, this parameter must be set in order to have reproducible results (<em>E.g</em> <code>set.seed()</code> has no effect in these cases).</p>
</td></tr>
<tr><td><code id="comboGroupsSample_+3A_parallel">Parallel</code></td>
<td>
<p>Logical value indicating whether results should be generated in parallel. The default is <code>FALSE</code>. If <code>TRUE</code> and <code>nThreads = NULL</code>, the number of threads used is equal to the minimum of one minus the number of threads available on your system and the number of results requested (<em>e.g.</em> if user has 16 threads and only needs 5 results, 5 threads will be used (<em>i.e.</em> <code>min(16 - 1, 5) = 5</code>)). If <code>nThreads</code> is not <code>NULL</code>, it will be given preference (<em>e.g.</em> if user has 8 threads with <code>Parallel = TRUE</code> and <code>nThreads = 4</code>, only 4 threads will be spawned). If your system is single-threaded, the arguments <code>Parallel</code> and <code>nThreads</code> are ignored.</p>
</td></tr>
<tr><td><code id="comboGroupsSample_+3A_nthreads">nThreads</code></td>
<td>
<p>Specific number of threads to be used. The default is <code>NULL</code>. See <code>Parallel</code>.</p>
</td></tr>
<tr><td><code id="comboGroupsSample_+3A_namedsample">namedSample</code></td>
<td>
<p>Logical flag. If <code>TRUE</code>, <code>rownames</code> corresponding to the lexicographical result, will be added to the returned matrix. The default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These algorithms rely on efficiently generating the <code class="reqn">n^{th}</code> lexicographical result.
</p>


<h3>Value</h3>

<p>By default, a matrix is returned with column names corresponding to the associated group. If <code>retType = "3Darray"</code>, a 3D array is returned.
</p>


<h3>Author(s)</h3>

<p>Joseph Wood
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Lexicographical_order">Lexicographical order</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate 10 random partitions of groups of equal size
comboGroupsSample(10, 2, n = 10, seed = 123)

## generate 10 random partitions of groups of varying sizes
comboGroupsSample(10, grpSizes = 1:4, n = 10, seed = 123)

## using sampleVec to generate specific results
comboGroupsSample(15, 5, sampleVec = c(1, 100, 1e3, 1e6))

all.equal(comboGroupsSample(10, 5,
            sampleVec = 1:comboGroupsCount(10, 5)),
         comboGroups(10, 5))

## Examples with enormous number of total results
num = comboGroupsCount(100, 20)
gmp::log2.bigz(num)
## [1] 325.5498

first = gmp::urand.bigz(n = 1, size = 325, seed = 123)
mySamp = do.call(c, lapply(0:10, function(x) gmp::add.bigz(first, x)))

class(mySamp)
## [1] "bigz"

## using the sampling function
cbgSamp = comboGroupsSample(100, 20, sampleVec = mySamp)

## using the standard function
cbgGeneral = comboGroups(100, 20,
                         lower = first,
                         upper = gmp::add.bigz(first, 10))

identical(cbgSamp, cbgGeneral)
## [1] TRUE

## Not run: 
## Using Parallel
system.time(comboGroupsSample(1000, 20, n = 80, seed = 10, Parallel = TRUE))

## End(Not run)
</code></pre>

<hr>
<h2 id='comboIter'>
Combination and Permutation Iterator
</h2><span id='topic+comboIter'></span><span id='topic+comboIter.integer'></span><span id='topic+comboIter.numeric'></span><span id='topic+comboIter.factor'></span><span id='topic+comboIter.logical'></span><span id='topic+comboIter.default'></span><span id='topic+comboIter.table'></span><span id='topic+comboIter.list'></span><span id='topic+permuteIter'></span><span id='topic+permuteIter.integer'></span><span id='topic+permuteIter.numeric'></span><span id='topic+permuteIter.factor'></span><span id='topic+permuteIter.logical'></span><span id='topic+permuteIter.default'></span><span id='topic+permuteIter.table'></span><span id='topic+permuteIter.list'></span>

<h3>Description</h3>


<ul>
<li><p> Returns an iterator for iterating over combinations or permutations of a vector with or without constraints.
</p>
</li>
<li><p> Supports random access via the <code>[[</code> method.
</p>
</li>
<li><p> GMP support allows for exploration of combinations/permutations of vectors with many elements.
</p>
</li>
<li><p> The output is in lexicographical order for the <code>next</code> methods and reverse lexicographical order for the <code>prev</code> methods.
</p>
</li>
<li><p> Learn more in <code>vignette("iterators")</code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>comboIter(v, m = NULL, ...)
permuteIter(v, m = NULL, ...)

## S3 method for class 'numeric'
comboIter(v, m = NULL, repetition = FALSE, freqs = NULL,
          constraintFun = NULL, comparisonFun = NULL,
          limitConstraints = NULL, keepResults = NULL,
          FUN = NULL, Parallel = FALSE, nThreads = NULL,
          tolerance = NULL, FUN.VALUE = NULL, ...)

## S3 method for class 'numeric'
permuteIter(v, m = NULL, repetition = FALSE, freqs = NULL,
            constraintFun = NULL, comparisonFun = NULL,
            limitConstraints = NULL, keepResults = NULL,
            FUN = NULL, Parallel = FALSE, nThreads = NULL,
            tolerance = NULL, FUN.VALUE = NULL, ...)

## S3 method for class 'factor'
comboIter(
    v, m = NULL, repetition = FALSE, freqs = NULL, FUN = NULL,
    Parallel = FALSE, nThreads = NULL, FUN.VALUE = NULL, ...
)
## S3 method for class 'factor'
permuteIter(
    v, m = NULL, repetition = FALSE, freqs = NULL, FUN = NULL,
    Parallel = FALSE, nThreads = NULL, FUN.VALUE = NULL, ...
)

## Default S3 method:
comboIter(
    v, m = NULL, repetition = FALSE, freqs = NULL,
    FUN = NULL, FUN.VALUE = NULL, ...
)
## Default S3 method:
permuteIter(
    v, m = NULL, repetition = FALSE, freqs = NULL,
    FUN = NULL, FUN.VALUE = NULL, ...
)

## S3 method for class 'table'
comboIter(
    v, m = NULL, constraintFun = NULL, comparisonFun = NULL,
    limitConstraints = NULL, keepResults = NULL, FUN = NULL,
    Parallel = FALSE, nThreads = NULL, tolerance = NULL, FUN.VALUE = NULL, ...
)
## S3 method for class 'table'
permuteIter(
    v, m = NULL, constraintFun = NULL, comparisonFun = NULL,
    limitConstraints = NULL, keepResults = NULL, FUN = NULL,
    Parallel = FALSE, nThreads = NULL, tolerance = NULL, FUN.VALUE = NULL, ...
)

## S3 method for class 'list'
comboIter(v, m = NULL, repetition = FALSE, freqs = NULL, ...)
## S3 method for class 'list'
permuteIter(v, m = NULL, repetition = FALSE, freqs = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comboIter_+3A_v">v</code></td>
<td>
<p>Source vector. If <code>v</code> is a positive integer, it will be converted to the sequence <code>1:v</code>. If <code>v</code> is a negative integer, it will be converted to the sequence <code>v:-1</code>. All atomic types are supported (See <code><a href="base.html#topic+is.atomic">is.atomic</a></code>).</p>
</td></tr>
<tr><td><code id="comboIter_+3A_m">m</code></td>
<td>
<p>Number of elements to choose.  If <code>repetition = TRUE</code> or <code>freqs</code> is utilized, <code>m</code> can exceed the length of <code>v</code>. If <code>m = NULL</code>, the length will default to <code>length(v)</code> or <code>sum(freqs)</code>.</p>
</td></tr>
<tr><td><code id="comboIter_+3A_...">...</code></td>
<td>
<p>Further arguments passed to methods.</p>
</td></tr>
<tr><td><code id="comboIter_+3A_repetition">repetition</code></td>
<td>
<p>Logical value indicating whether combinations/permutations should be with or without repetition. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="comboIter_+3A_freqs">freqs</code></td>
<td>
<p>A vector of frequencies used for producing all combinations/permutations of a multiset of <code>v</code>. Each element of <code>freqs</code> represents how many times each element of the source vector, <code>v</code>, is repeated. It is analogous to the <code>times</code> argument in <code><a href="base.html#topic+rep">rep</a></code>. The default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="comboIter_+3A_constraintfun">constraintFun</code></td>
<td>
<p>Function to be applied to the elements of <code>v</code> that should be passed as a string (<em>e.g.</em> <code>constraintFun = "sum"</code>). The possible constraint functions are: <code>"sum"</code>, <code>"prod"</code>, <code>"mean"</code>, <code>"max"</code>, &amp; <code>"min"</code>. The default is <code>NULL</code>, meaning no function is applied.</p>
</td></tr>
<tr><td><code id="comboIter_+3A_comparisonfun">comparisonFun</code></td>
<td>
<p>Comparison operator that will be used to compare <code>limitConstraints</code> with the result of <code>constraintFun</code> applied to <code>v</code>. It should be passed as a string or a vector of two strings (<em>e.g.</em> <code>comparisonFun = "&lt;="</code> or  <code>comparisonFun = c("&gt;","&lt;")</code>). The possible comparison operators are: <code>"&lt;"</code>, <code>"&gt;"</code>, <code>"&lt;="</code>, <code>"&gt;="</code>, <code>"=="</code>. The default is <code>NULL</code>.
</p>
<p>When <code>comparisonFun</code> is a vector of two comparison strings, <em>e.g</em> <code>comparisonFun = c(comp1, comp2)</code>, and <code>limitConstraints</code> is a vector of two numerical values, <em>e.g</em> <code>limitConstraints = c(x1, x2)</code>, the combinations/permutations will be filtered in one of the following two ways:
</p>

<ol>
<li><p>When <code>comp1</code> is one of the 'greater-than' operators (<em>i.e.</em> &quot;&gt;=&quot; or &quot;&gt;&quot;), <code>comp2</code> is one of the 'less-than' operators (<em>i.e.</em> &quot;&lt;=&quot; or &quot;&lt;&quot;), and <code>x1 &lt; x2</code>, the combinations/permutations that are returned will have a value (after <code>constraintFun</code> has been applied) between <code>x1</code> and <code>x2</code>.
</p>
</li>
<li><p>When <code>comp1</code> and <code>comp2</code> are defined as in #1 and <code>x1 &gt; x2</code>, the combinations/permutations that are returned will have a value outside the range of <code>x1</code> and <code>x2</code>. See the examples below.
</p>
</li></ol>

<p>In other words, the first comparison operator is applied to the first limit and the second operator is applied to the second limit.</p>
</td></tr>
<tr><td><code id="comboIter_+3A_limitconstraints">limitConstraints</code></td>
<td>
<p>This is the value(s) that will be used for comparison. Can be passed as a single value or a vector of two numerical values. The default is <code>NULL</code>. See the definition of <code>comparisonFun</code> as well as the examples below for more information.</p>
</td></tr>
<tr><td><code id="comboIter_+3A_keepresults">keepResults</code></td>
<td>
<p>A logical flag indicating if the result of <code>constraintFun</code> applied to <code>v</code> should be displayed; if <code>TRUE</code>, an additional column of results will be added to the resulting matrix. The default is <code>FALSE</code>. If user is only applying <code>constraintFun</code>, <code>keepResults</code> will default to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="comboIter_+3A_fun">FUN</code></td>
<td>
<p>Function to be applied to each combination/permutation. The default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="comboIter_+3A_parallel">Parallel</code></td>
<td>
<p>Logical value indicating whether combinations/permutations should be generated in parallel using <code class="reqn">n - 1</code> threads, where <code class="reqn">n</code> is the maximum number of threads. The default is <code>FALSE</code>. If <code>nThreads</code> is not <code>NULL</code>, it will be given preference (<em>e.g.</em> if user has 8 threads with <code>Parallel = TRUE</code> and <code>nThreads = 4</code>, only 4 threads will be spawned). If your system is single-threaded, the arguments <code>Parallel</code> and <code>nThreads</code> are ignored.</p>
</td></tr>
<tr><td><code id="comboIter_+3A_nthreads">nThreads</code></td>
<td>
<p>Specific number of threads to be used. The default is <code>NULL</code>. See <code>Parallel</code>.</p>
</td></tr>
<tr><td><code id="comboIter_+3A_tolerance">tolerance</code></td>
<td>
<p>A numeric value greater than or equal to zero. This parameter is utilized when a constraint is applied on a numeric vector. The default value is 0 when it can be determined that whole values are being utilized, otherwise it is <code>sqrt(.Machine$double.eps)</code> which is approximately <code class="reqn">1.5e-8</code>. N.B. If the input vector is of type integer, this parameter will be ignored and strict equality will be enforced.</p>
</td></tr>
<tr><td><code id="comboIter_+3A_fun.value">FUN.VALUE</code></td>
<td>
<p>A template for the return value from <code>FUN</code>. See 'Details' of <code><a href="base.html#topic+vapply">vapply</a></code> for more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Once you initialize a new iterator, the following methods are available via <code>@</code> (<em>e.g.</em> <code>a@nextIter()</code>) or <code>$</code> (<em>e.g.</em> <code>a$nextIter()</code>). The preferred practice is to use <code>@</code> as it is much more efficient (See examples below). Also note that not all of the methods below are available in all cases. See <code><a href="#topic+Combo-class">Combo-class</a></code>, <code><a href="#topic+Constraints-class">Constraints-class</a></code>, and <code><a href="#topic+Partitions-class">Partitions-class</a></code>:
</p>

<dl>
<dt><code>nextIter</code></dt><dd><p>Retrieve the <b>next</b> lexicographical result</p>
</dd>
<dt><code>nextNIter</code></dt><dd><p>Pass an integer <em>n</em> to retrieve the <b>next</b> <em>n</em> lexicographical results</p>
</dd>
<dt><code>nextRemaining</code></dt><dd><p>Retrieve all remaining lexicographical results</p>
</dd>
<dt><code>currIter</code></dt><dd><p>Returns the current iteration</p>
</dd>
<dt><code>prevIter</code></dt><dd><p>Retrieve the <b>previous</b> lexicographical result (the <b>next</b> <em>reverse</em> lexicographical result)</p>
</dd>
<dt><code>prevNIter</code></dt><dd><p>Pass an integer <em>n</em> to retrieve the <b>previous</b> <em>n</em> lexicographical results (the <b>next</b> <em>n</em> <em>reverse</em> lexicographical results)</p>
</dd>
<dt><code>prevRemaining</code></dt><dd><p>Retrieve all remaining <em>reverse</em> lexicographical results</p>
</dd>
<dt><code>startOver</code></dt><dd><p>Resets the iterator</p>
</dd>
<dt><code>sourceVector</code></dt><dd><p>View the source vector</p>
</dd>
<dt><code>summary</code></dt><dd><p>Returns a list of summary information about the iterator</p>
</dd>
<dt><code>front</code></dt><dd><p>Retrieve the <b>first</b> lexicographical result</p>
</dd>
<dt><code>back</code></dt><dd><p>Retrieve the <b>last</b> lexicographical result</p>
</dd>
<dt><code>[[</code></dt><dd><p>Random access method. Pass a single value or a vector of valid indices. If a single value is passed, the internal index of the iterator will be updated, however if a vector is passed the internal state will not change. GMP support allows for flexible indexing.</p>
</dd>
</dl>



<h3>Value</h3>


<ul>
<li><p> If <code>nextIter</code> or <code>prevIter</code> is called, a vector is returned
</p>
</li>
<li><p> Otherwise, a matrix with <code class="reqn">m</code> or <code class="reqn">m + 1</code> columns, depending on the value of <code>keepResults</code>
</p>
</li>
<li><p> If <code>FUN</code> is utilized, <code>FUN.VALUE = NULL</code>, and either <code>nextIter</code> or <code>prevIter</code> is called, the result will be determined by <code>FUN</code>, otherwise a list is returned.
</p>
</li>
<li><p> When both <code>FUN</code> and <code>FUN.VALUE</code> are not <code>NULL</code>, the return is modeled after the return of <code>vapply</code>. See the 'Value' section of <code><a href="base.html#topic+vapply">vapply</a></code>.
</p>
</li></ul>



<h3>Note</h3>


<ul>
<li> <p><code>Parallel</code> and <code>nThreads</code> will be ignored in the following cases:
</p>

<ul>
<li><p> When the output is constrained (except for most partitions cases)
</p>
</li>
<li><p> If the class of the vector passed is <code>character</code>, <code>raw</code>, and <code>complex</code> (N.B. <code>Rcpp::CharacterMatrix</code> is not thread safe). Alternatively, you can generate an indexing matrix in parallel.
</p>
</li>
<li><p> If <code>FUN</code> is utilized.
</p>
</li></ul>


</li>
<li><p> If either <code>constraintFun</code>, <code>comparisonFun</code> or <code>limitConstraints</code> is <code>NULL</code> &ndash;or&ndash; if the class of the vector passed is <code>logical</code>, <code>character</code>, <code>raw</code>, <code>factor</code>, or <code>complex</code>, the constraint check will not be carried out. This is equivalent to simply finding all combinations/permutations of <code class="reqn">v</code> choose <code class="reqn">m</code>.
</p>
</li>
<li><p> The maximum number of combinations/permutations that can be generated at one time is <code class="reqn">2^{31} - 1</code>.
</p>
</li>
<li><p> Factor vectors are accepted. Class and level attributes are preserved except when <code>FUN</code> is used.
</p>
</li>
<li><p> Lexicographical ordering isn't guaranteed for permutations if the output is constrained.
</p>
</li>
<li> <p><code>FUN</code> will be ignored if the constraint check is satisfied.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Joseph Wood
</p>


<h3>References</h3>


<ul>
<li><p><a href="https://en.wikipedia.org/wiki/Lexicographical_order">Lexicographical Order</a>
</p>
</li>
<li><p><a href="https://oeis.org/wiki/Orderings#Reverse_lexicographic_order">Reverse Lexicographical Order</a>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+comboGeneral">comboGeneral</a></code>, <code><a href="#topic+permuteGeneral">permuteGeneral</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Typical usage
a = permuteIter(unique(state.region))
a@nextIter()
a@nextNIter(3)
a@front()
a@nextRemaining()
a@prevIter()
a@prevNIter(15)
a@summary()
a@back()
a@prevRemaining()
a[[5]]
a@summary()
a[[c(1, 17, 3)]]
a@summary()

## See examples for comboGeneral where lower and upper are used
set.seed(1009)
mySamp = sort(rnorm(75, 997, 23))

b = comboIter(mySamp, 7,
              constraintFun = "sum",
              comparisonFun = "&gt;",
              limitConstraints = 7200)
b@nextIter()
b@nextNIter(3)
b@summary()
b@currIter()

## Not run: 
## We don't have random access or previous methods
b@back()
#&gt; Error: no slot of name "back" for this object of class "Constraints"
b@prevIter()
#&gt; Error: no slot of name "prevIter" for this object of class "Constraints"

## End(Not run)
</code></pre>

<hr>
<h2 id='comboRank'>
Rank Combinations and Permutations
</h2><span id='topic+comboRank'></span><span id='topic+permuteRank'></span>

<h3>Description</h3>


<ul>
<li><p> Generate the rank (lexicographically) of combinations/permutations. These functions are the complement to <code>comboSample</code> and <code>permuteSample</code>. See the examples below.
</p>
</li>
<li><p> GMP support allows for exploration of combinations/permutations of vectors with many elements.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>comboRank(..., v, repetition = FALSE, freqs = NULL)
permuteRank(..., v, repetition = FALSE, freqs = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comboRank_+3A_...">...</code></td>
<td>
<p>vectors or matrices to be ranked.</p>
</td></tr>
<tr><td><code id="comboRank_+3A_v">v</code></td>
<td>
<p>Source vector. If <code>v</code> is a positive integer, it will be converted to the sequence <code>1:v</code>. If <code>v</code> is a negative integer, it will be converted to the sequence <code>v:-1</code>. All atomic types are supported (See <code><a href="base.html#topic+is.atomic">is.atomic</a></code>).</p>
</td></tr>
<tr><td><code id="comboRank_+3A_repetition">repetition</code></td>
<td>
<p>Logical value indicating whether combinations/permutations should be with or without repetition. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="comboRank_+3A_freqs">freqs</code></td>
<td>
<p>A vector of frequencies used for producing all combinations/permutations of a multiset of <code>v</code>. Each element of <code>freqs</code> represents how many times each element of the source vector, <code>v</code>, is repeated. It is analogous to the <code>times</code> argument in <code><a href="base.html#topic+rep">rep</a></code>. The default value is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These algorithms rely on efficiently ranking the <code class="reqn">n^{th}</code> lexicographical combination/permutation.
</p>


<h3>Value</h3>

<p>A vector of class <code>integer</code>, <code>numeric</code>, or <code>bigz</code> determined by the total number of combinations/permutations</p>


<h3>Note</h3>

<p><code>v</code> must be supplied.
</p>


<h3>Author(s)</h3>

<p>Joseph Wood
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Lexicographical_order">Lexicographical order</a>
<a href="https://rosettacode.org/wiki/Permutations/Rank_of_a_permutation">ranking/unranking</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+comboSample">comboSample</a></code>, <code><a href="#topic+permuteSample">permuteSample</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mySamp = comboSample(30, 8, TRUE, n = 5, seed = 10, namedSample = TRUE)
myRank = comboRank(mySamp, v = 30, repetition = TRUE)
all.equal(as.integer(rownames(mySamp)), myRank)
</code></pre>

<hr>
<h2 id='comboSample'>
Sample Combinations and Permutations
</h2><span id='topic+comboSample'></span><span id='topic+comboSample.integer'></span><span id='topic+comboSample.numeric'></span><span id='topic+comboSample.factor'></span><span id='topic+comboSample.logical'></span><span id='topic+comboSample.default'></span><span id='topic+comboSample.table'></span><span id='topic+comboSample.list'></span><span id='topic+permuteSample'></span><span id='topic+permuteSample.integer'></span><span id='topic+permuteSample.numeric'></span><span id='topic+permuteSample.factor'></span><span id='topic+permuteSample.logical'></span><span id='topic+permuteSample.default'></span><span id='topic+permuteSample.table'></span><span id='topic+permuteSample.list'></span>

<h3>Description</h3>


<ul>
<li><p> Generate a specific (lexicographically) or random sample of combinations/permutations.
</p>
</li>
<li><p> Produce results in parallel using the <code>Parallel</code> or <code>nThreads</code> arguments.
</p>
</li>
<li><p> GMP support allows for exploration of combinations/permutations of vectors with many elements.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>comboSample(v, m = NULL, ...)
permuteSample(v, m = NULL, ...)

## S3 method for class 'numeric'
comboSample(v, m = NULL, repetition = FALSE, freqs = NULL, n = NULL,
            sampleVec = NULL, seed = NULL, FUN = NULL, Parallel = FALSE,
            nThreads = NULL, namedSample = FALSE, FUN.VALUE = NULL, ...)

## S3 method for class 'numeric'
permuteSample(v, m = NULL, repetition = FALSE, freqs = NULL, n = NULL,
              sampleVec = NULL, seed = NULL, FUN = NULL, Parallel = FALSE,
              nThreads = NULL, namedSample = FALSE, FUN.VALUE = NULL, ...)

## S3 method for class 'factor'
comboSample(
    v, m = NULL, repetition = FALSE, freqs = NULL, n = NULL,
    sampleVec = NULL, seed = NULL, FUN = NULL, Parallel = FALSE,
    nThreads = NULL, namedSample = FALSE, FUN.VALUE = NULL, ...
)
## S3 method for class 'factor'
permuteSample(
    v, m = NULL, repetition = FALSE, freqs = NULL, n = NULL,
    sampleVec = NULL, seed = NULL, FUN = NULL, Parallel = FALSE,
    nThreads = NULL, namedSample = FALSE, FUN.VALUE = NULL, ...
)

## Default S3 method:
comboSample(
    v, m = NULL, repetition = FALSE, freqs = NULL, n = NULL, sampleVec = NULL,
    seed = NULL, FUN = NULL, namedSample = FALSE, FUN.VALUE = NULL, ...
)
## Default S3 method:
permuteSample(
    v, m = NULL, repetition = FALSE, freqs = NULL, n = NULL, sampleVec = NULL,
    seed = NULL, FUN = NULL, namedSample = FALSE, FUN.VALUE = NULL, ...
)

## S3 method for class 'table'
comboSample(
    v, m = NULL, n = NULL, sampleVec = NULL, seed = NULL, FUN = NULL,
    Parallel = FALSE, nThreads = NULL, namedSample = FALSE, FUN.VALUE = NULL, ...
)
## S3 method for class 'table'
permuteSample(
    v, m = NULL, n = NULL, sampleVec = NULL, seed = NULL, FUN = NULL,
    Parallel = FALSE, nThreads = NULL, namedSample = FALSE, FUN.VALUE = NULL, ...
)

## S3 method for class 'list'
comboSample(
    v, m = NULL, repetition = FALSE, freqs = NULL, n = NULL,
    sampleVec = NULL, seed = NULL, namedSample = FALSE, ...
)
## S3 method for class 'list'
permuteSample(
    v, m = NULL, repetition = FALSE, freqs = NULL, n = NULL,
    sampleVec = NULL, seed = NULL, namedSample = FALSE, ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comboSample_+3A_v">v</code></td>
<td>
<p>Source vector. If <code>v</code> is a positive integer, it will be converted to the sequence <code>1:v</code>. If <code>v</code> is a negative integer, it will be converted to the sequence <code>v:-1</code>. All atomic types are supported (See <code><a href="base.html#topic+is.atomic">is.atomic</a></code>).</p>
</td></tr>
<tr><td><code id="comboSample_+3A_m">m</code></td>
<td>
<p>Number of elements to choose.  If <code>repetition = TRUE</code> or <code>freqs</code> is utilized, <code>m</code> can exceed the length of <code>v</code>. If <code>m = NULL</code>, the length will default to <code>length(v)</code> or <code>sum(freqs)</code>.</p>
</td></tr>
<tr><td><code id="comboSample_+3A_...">...</code></td>
<td>
<p>Further arguments passed to methods.</p>
</td></tr>
<tr><td><code id="comboSample_+3A_repetition">repetition</code></td>
<td>
<p>Logical value indicating whether combinations/permutations should be with or without repetition. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="comboSample_+3A_freqs">freqs</code></td>
<td>
<p>A vector of frequencies used for producing all combinations/permutations of a multiset of <code>v</code>. Each element of <code>freqs</code> represents how many times each element of the source vector, <code>v</code>, is repeated. It is analogous to the <code>times</code> argument in <code><a href="base.html#topic+rep">rep</a></code>. The default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="comboSample_+3A_n">n</code></td>
<td>
<p>Number of combinations/permutations to return. The default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="comboSample_+3A_samplevec">sampleVec</code></td>
<td>
<p>A vector of indices representing the lexicographical combination/permutations to return. Accepts whole numbers as well as vectors of class <code>bigz</code> as well as vectors of characters</p>
</td></tr>
<tr><td><code id="comboSample_+3A_seed">seed</code></td>
<td>
<p>Random seed initialization. The default is <code>NULL</code>. N.B. If the gmp library is needed, this parameter must be set in order to have reproducible results (<em>E.g</em> <code>set.seed()</code> has no effect in these cases).</p>
</td></tr>
<tr><td><code id="comboSample_+3A_fun">FUN</code></td>
<td>
<p>Function to be applied to each combination/permutation. The default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="comboSample_+3A_parallel">Parallel</code></td>
<td>
<p>Logical value indicating whether combinations/permutations should be generated in parallel. The default is <code>FALSE</code>. If <code>TRUE</code> and <code>nThreads = NULL</code>, the number of threads used is equal to the minimum of one minus the number of threads available on your system and the number of results requested (<em>e.g.</em> if user has 16 threads and only needs 5 results, 5 threads will be used (<em>i.e.</em> <code>min(16 - 1, 5) = 5</code>)). If <code>nThreads</code> is not <code>NULL</code>, it will be given preference (<em>e.g.</em> if user has 8 threads with <code>Parallel = TRUE</code> and <code>nThreads = 4</code>, only 4 threads will be spawned). If your system is single-threaded, the arguments <code>Parallel</code> and <code>nThreads</code> are ignored.</p>
</td></tr>
<tr><td><code id="comboSample_+3A_nthreads">nThreads</code></td>
<td>
<p>Specific number of threads to be used. The default is <code>NULL</code>. See <code>Parallel</code>.</p>
</td></tr>
<tr><td><code id="comboSample_+3A_namedsample">namedSample</code></td>
<td>
<p>Logical flag. If <code>TRUE</code>, <code>rownames</code> corresponding to the lexicographical combination/permutation, will be added to the returned matrix. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="comboSample_+3A_fun.value">FUN.VALUE</code></td>
<td>
<p>A template for the return value from <code>FUN</code>. See 'Details' of <code><a href="base.html#topic+vapply">vapply</a></code> for more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These algorithms rely on efficiently generating the <code class="reqn">n^{th}</code> lexicographical combination/permutation. This is the process of <a href="https://rosettacode.org/wiki/Permutations/Rank_of_a_permutation">unranking</a>.
</p>


<h3>Value</h3>


<ul>
<li><p> In general, a matrix with <code class="reqn">m</code> or <code class="reqn">m + 1</code> columns, depending on the value of <code>keepResults</code>
</p>
</li>
<li><p> If <code>FUN</code> is utilized and <code>FUN.VALUE = NULL</code>, a list is returned
</p>
</li>
<li><p> When both <code>FUN</code> and <code>FUN.VALUE</code> are not <code>NULL</code>, the return is modeled after the return of <code>vapply</code>. See the 'Value' section of <code><a href="base.html#topic+vapply">vapply</a></code>.
</p>
</li></ul>



<h3>Note</h3>


<ul>
<li> <p><code>Parallel</code> and <code>nThreads</code> will be ignored in the following cases:
</p>

<ul>
<li><p> If the class of the vector passed is <code>character</code> (N.B. <code>Rcpp::CharacterMatrix</code> is not thread safe). Alternatively, you can generate an indexing matrix in parallel.
</p>
</li>
<li><p> If <code>FUN</code> is utilized.
</p>
</li></ul>


</li>
<li> <p><code>n</code> and <code>sampleVec</code> cannot both be <code>NULL</code>.
</p>
</li>
<li><p> Factor vectors are accepted. Class and level attributes are preserved except when <code>FUN</code> is used.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Joseph Wood
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Lexicographical_order">Lexicographical order</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+comboRank">comboRank</a></code>, <code><a href="#topic+permuteRank">permuteRank</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate 10 random combinations
comboSample(30, 8, TRUE, n = 5, seed = 10)

## Using sampleVec to generate specific permutations
fqs   = c(1,2,2,1,2,2,1,2,1,2,2,1,2,1,1)
s_idx = c(1, 10^2, 10^5, 10^8, 10^11)

permuteSample(15, 10, freqs = fqs, sampleVec = s_idx)

## Same example using 'table' method
permuteSample(table(rep(1:15, times = fqs)), 10, sampleVec = s_idx)

## Generate each result one by one...
## Same, but not as efficient as generating iteratively
all.equal(comboSample(10, 5, sampleVec = 1:comboCount(10, 5)),
          comboGeneral(10, 5))

## Examples with enormous number of total permutations
num = permuteCount(10000, 20)
gmp::log2.bigz(num)

first  = gmp::urand.bigz(n = 1, size = 265, seed = 123)
mySamp = do.call(c, lapply(0:10, function(x) gmp::add.bigz(first, x)))

class(mySamp)

## using permuteSample
pSamp = permuteSample(10000, 20, sampleVec = mySamp)

## using permuteGeneral
pGeneral = permuteGeneral(10000, 20,
                          lower = first,
                          upper = gmp::add.bigz(first, 10))

identical(pSamp, pGeneral)

## Using nThreads
permPar = permuteSample(10000, 50, n = 8, seed = 10, nThreads = 2)

## Using FUN
permuteSample(10000, 50, n = 4, seed = 10, FUN = sd)

## Not run: 
## Using Parallel
permuteSample(10000, 50, n = 80, seed = 10, Parallel = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='Constraints-class'>S4-class for Exposing C++ Constraints Class</h2><span id='topic+Constraints-class'></span><span id='topic++24+2CConstraints-method'></span>

<h3>Description</h3>

<p>The <code>Constraints</code> class is an S4-class that exposes C++ classes that provide access to iterators and other useful methods.
</p>


<h3>Slots</h3>


<dl>
<dt><code>nextIter</code></dt><dd><p>Retrieve the <b>next</b> lexicographical result</p>
</dd>
<dt><code>nextNIter</code></dt><dd><p>Pass an integer <em>n</em> to retrieve the <b>next</b> <em>n</em> lexicographical results</p>
</dd>
<dt><code>nextRemaining</code></dt><dd><p>Retrieve all remaining lexicographical results</p>
</dd>
<dt><code>currIter</code></dt><dd><p>Returns the current iteration</p>
</dd>
<dt><code>startOver</code></dt><dd><p>Resets the iterator</p>
</dd>
<dt><code>sourceVector</code></dt><dd><p>View the source vector</p>
</dd>
<dt><code>summary</code></dt><dd><p>Returns a list of summary information about the iterator</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Joseph Wood</p>


<h3>See Also</h3>

<p><code><a href="#topic+Combo-class">Combo-class</a></code>, <code><a href="#topic+Partitions-class">Partitions-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  showClass("Constraints")
</code></pre>

<hr>
<h2 id='divisorsRcpp'>
Vectorized Factorization (Complete)
</h2><span id='topic+divisorsRcpp'></span>

<h3>Description</h3>

<p>Function for generating the complete factorization for a vector of numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>divisorsRcpp(v, namedList = FALSE, nThreads = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="divisorsRcpp_+3A_v">v</code></td>
<td>
<p>Vector of integers or numeric values. Non-integral values will be coerced to whole numbers.</p>
</td></tr>
<tr><td><code id="divisorsRcpp_+3A_namedlist">namedList</code></td>
<td>
<p>Logical flag. If <code>TRUE</code> and the <code>length(v) &gt; 1</code>, a named list is returned. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="divisorsRcpp_+3A_nthreads">nThreads</code></td>
<td>
<p>Specific number of threads to be used. The default is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Efficient algorithm that builds on <code><a href="#topic+primeFactorize">primeFactorize</a></code> to generate the complete factorization of many numbers.
</p>


<h3>Value</h3>


<ul>
<li><p>Returns an unnamed vector if <code>length(v) == 1</code> regardless of the value of <code>namedList</code>. If <code class="reqn">v &lt; 2^{31}</code>, the class of the returned vector will be integer, otherwise the class will be numeric.
</p>
</li>
<li><p>If <code>length(v) &gt; 1</code>, a named/unnamed list of vectors will be returned. If <code>max(bound1, bound2)</code> <code class="reqn">&lt; 2^{31}</code>, the class of each vector will be integer, otherwise the class will be numeric.
</p>
</li></ul>



<h3>Note</h3>

<p>The maximum value for each element in <code class="reqn">v</code> is <code class="reqn">2^{53} - 1</code>.
</p>


<h3>Author(s)</h3>

<p>Joseph Wood
</p>


<h3>References</h3>


<ul>
<li><p><a href="https://en.wikipedia.org/wiki/Divisor">Divisor</a>
</p>
</li>
<li><p><a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format">53-bit significand precision</a>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+primeFactorize">primeFactorize</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Get the complete factorization of a single number
divisorsRcpp(10^8)

## Or get the complete factorization of many numbers
set.seed(29)
myVec &lt;- sample(-1000000:1000000, 1000)
system.time(myFacs &lt;- divisorsRcpp(myVec))

## Return named list
myFacsWithNames &lt;- divisorsRcpp(myVec, namedList = TRUE)

## Using nThreads
system.time(divisorsRcpp(myVec, nThreads = 2))
</code></pre>

<hr>
<h2 id='divisorsSieve'>
Generate Complete Factorization for Numbers in a Range
</h2><span id='topic+divisorsSieve'></span>

<h3>Description</h3>

<p>Sieve that generates the complete factorization of all numbers between <code>bound1</code> and <code>bound2</code> (if supplied) or all numbers up to <code>bound1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>divisorsSieve(bound1, bound2 = NULL, namedList = FALSE, nThreads = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="divisorsSieve_+3A_bound1">bound1</code></td>
<td>
<p>Positive integer or numeric value.</p>
</td></tr>
<tr><td><code id="divisorsSieve_+3A_bound2">bound2</code></td>
<td>
<p>Positive integer or numeric value.</p>
</td></tr>
<tr><td><code id="divisorsSieve_+3A_namedlist">namedList</code></td>
<td>
<p>Logical flag. If <code>TRUE</code>, a named list is returned. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="divisorsSieve_+3A_nthreads">nThreads</code></td>
<td>
<p>Specific number of threads to be used. The default is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is useful when many complete factorizations are needed. Instead of generating the complete factorization on the fly, one can reference the indices/names of the generated list.
</p>
<p>This algorithm benefits greatly from the fast integer division library 'libdivide'. The following is from <a href="https://libdivide.com/">https://libdivide.com/</a>:
</p>
<ul>
<li><p>&ldquo;<em>libdivide allows you to replace expensive integer divides with comparatively cheap multiplication and bitshifts. Compilers usually do this, but only when the divisor is known at compile time. libdivide allows you to take advantage of it at runtime. The result is that integer division can become faster - a lot faster.</em>&rdquo;</p>
</li></ul>



<h3>Value</h3>

<p>Returns a named/unnamed list of integer vectors if <code>max(bound1, bound2)</code> <code class="reqn">&lt; 2^{31}</code>, or a list of numeric vectors otherwise.
</p>


<h3>Note</h3>

<p>The maximum value for either of the bounds is <code class="reqn">2^{53} - 1</code>.
</p>


<h3>Author(s)</h3>

<p>Joseph Wood
</p>


<h3>References</h3>


<ul>
<li><p><a href="https://en.wikipedia.org/wiki/Divisor">Divisor</a>
</p>
</li>
<li><p><a href="https://ridiculousfish.com/">ridiculousfish (author of libdivide)</a>
</p>
</li>
<li><p><a href="https://github.com/ridiculousfish/libdivide">github.com/ridiculousfish/libdivide</a>
</p>
</li>
<li><p><a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format">53-bit significand precision</a>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+divisorsRcpp">divisorsRcpp</a></code>, <code><a href="#topic+primeFactorizeSieve">primeFactorizeSieve</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate some random data
set.seed(33550336)
mySamp &lt;- sample(10^5, 5*10^4)

## Generate complete factorizations up
## to 10^5 (max element from mySamp)
system.time(allFacs &lt;- divisorsSieve(10^5))

## Use generated complete factorization for further
## analysis by accessing the index of allFacs
for (s in mySamp) {
    myFac &lt;- allFacs[[s]]
    ## Continue algorithm
}

## Generating complete factorizations over
## a range is efficient as well
system.time(divisorsSieve(10^12, 10^12 + 10^5))

## Use nThreads for improved efficiency
system.time(divisorsSieve(10^12, 10^12 + 10^5, nThreads = 2))

## Set 'namedList' to TRUE to return a named list
divisorsSieve(27, 30, namedList = TRUE)

## Using nThreads
system.time(divisorsSieve(1e5, 2e5, nThreads = 2))
</code></pre>

<hr>
<h2 id='eulerPhiSieve'>
Apply Euler's Phi Function to Every Element in a Range
</h2><span id='topic+eulerPhiSieve'></span>

<h3>Description</h3>

<p>Sieve that generates the number of coprime elements for every number between <code>bound1</code> and <code>bound2</code> (if supplied) or all numbers up to <code>bound1</code>. This is equivalent to applying Euler's phi function (often written as <code class="reqn">\phi(x)</code>) to every number in a given range.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eulerPhiSieve(bound1, bound2 = NULL, namedVector = FALSE, nThreads = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eulerPhiSieve_+3A_bound1">bound1</code></td>
<td>
<p>Positive integer or numeric value.</p>
</td></tr>
<tr><td><code id="eulerPhiSieve_+3A_bound2">bound2</code></td>
<td>
<p>Positive integer or numeric value.</p>
</td></tr>
<tr><td><code id="eulerPhiSieve_+3A_namedvector">namedVector</code></td>
<td>
<p>Logical flag. If <code>TRUE</code>, a named vector is returned. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="eulerPhiSieve_+3A_nthreads">nThreads</code></td>
<td>
<p>Specific number of threads to be used. The default is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the simple case (i.e. when <code>bound2 = NULL</code>), this algorithm first generates all primes up to <code class="reqn">n</code> via the sieve of Eratosthenes. We use these primes to sieve over the sequence <code>1:n</code>, dividing each value by <code class="reqn">p</code>, creating a temporary value that will be subtracted from the original value at each index (i.e. equivalent to multiply each index by <code class="reqn">(1 - 1/p)</code> but more efficient as we don't have to deal with floating point numbers). The case when <code>is.null(bound2) = FALSE</code> is more complicated but the basic ideas still hold.
</p>
<p>This function is very useful when you need to calculate Euler's phi function for many numbers in a range as performing this calculation on the fly can be computationally expensive.
</p>
<p>This algorithm benefits greatly from the fast integer division library 'libdivide'. The following is from <a href="https://libdivide.com/">https://libdivide.com/</a>:
</p>
<ul>
<li><p>&ldquo;<em>libdivide allows you to replace expensive integer divides with comparatively cheap multiplication and bitshifts. Compilers usually do this, but only when the divisor is known at compile time. libdivide allows you to take advantage of it at runtime. The result is that integer division can become faster - a lot faster.</em>&rdquo;</p>
</li></ul>



<h3>Value</h3>

<p>Returns a named/unnamed integer vector if <code>max(bound1, bound2)</code> <code class="reqn">&lt; 2^{31}</code>, or a numeric vector otherwise.
</p>


<h3>Note</h3>

<p>The maximum allowed value is <code class="reqn">2^{53} - 1</code>.
</p>


<h3>Author(s)</h3>

<p>Joseph Wood
</p>


<h3>References</h3>


<ul>
<li><p><a href="https://en.wikipedia.org/wiki/Euler%27s_totient_function">Euler's totient function</a>
</p>
</li>
<li><p><a href="https://ridiculousfish.com/">ridiculousfish (author of libdivide)</a>
</p>
</li>
<li><p><a href="https://github.com/ridiculousfish/libdivide">github.com/ridiculousfish/libdivide</a>
</p>
</li>
<li><p><a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format">53-bit significand precision</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Generate some random data
set.seed(496)
mySamp &lt;- sample(10^6, 5*10^5)

## Generate number of coprime elements for many numbers
system.time(myPhis &lt;- eulerPhiSieve(10^6))

## Now use result in algorithm
for (s in mySamp) {
    sPhi &lt;- myPhis[s]
    ## Continue algorithm
}

## See https://projecteuler.net
system.time(which.max((1:10^6)/eulerPhiSieve(10^6)))

## Generating number of coprime elements
## for every number in a range is no problem
system.time(myPhiRange &lt;- eulerPhiSieve(10^13, 10^13 + 10^6))

## Returning a named vector
eulerPhiSieve(10, 20, namedVector = TRUE)
eulerPhiSieve(10, namedVector = TRUE)

## Using nThreads
system.time(eulerPhiSieve(1e5, 2e5, nThreads = 2))
</code></pre>

<hr>
<h2 id='isPrimeRcpp'>
Vectorized Primality Test
</h2><span id='topic+isPrimeRcpp'></span>

<h3>Description</h3>

<p>Implementation of the <a href="https://en.wikipedia.org/wiki/Miller-Rabin_primality_test">Miller-Rabin primality test</a>. Based on the &quot;mp_prime_p&quot; function from the &quot;factorize.c&quot; source file found in the gmp library: <a href="https://gmplib.org">https://gmplib.org</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isPrimeRcpp(v, namedVector = FALSE, nThreads = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isPrimeRcpp_+3A_v">v</code></td>
<td>
<p>Vector of integers or numeric values.</p>
</td></tr>
<tr><td><code id="isPrimeRcpp_+3A_namedvector">namedVector</code></td>
<td>
<p>Logical flag. If <code>TRUE</code>, a named vector is returned. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="isPrimeRcpp_+3A_nthreads">nThreads</code></td>
<td>
<p>Specific number of threads to be used. The default is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Miller-Rabin primality test is a probabilistic algorithm that makes heavy use of <a href="https://en.wikipedia.org/wiki/Modular_exponentiation">modular exponentiation</a>. At the heart of modular exponentiation is the ability to accurately obtain the remainder of the product of two numbers <code class="reqn">\pmod p</code>.
</p>
<p>With the gmp library, producing accurate calculations for problems like this is trivial because of the nature of the multiple precision data type. However, standard C++ does not afford this luxury and simply relying on a strict translation would have limited this algorithm to numbers less than <code class="reqn">\sqrt 2^{63} - 1</code> (N.B. We are taking advantage of the signed 64-bit fixed width integer from the stdint library in C++. If we were confined to base R, the limit would have been <code class="reqn">\sqrt 2^{53} - 1</code>). RcppAlgos::isPrimeRcpp gets around this limitation with a <a href="https://en.wikipedia.org/wiki/Divide_and_conquer_algorithm">divide and conquer</a> approach taking advantage of properties of arithmetic.
</p>
<p>The problem we are trying to solve can be summarized as follows:
</p>
<p style="text-align: center;"><code class="reqn">(x_1 * x_2) \pmod p</code>
</p>

<p>Now, we rewrite <code class="reqn">x_2</code> as <code class="reqn">x_2 = y_1 + y_2 + \dots + y_n</code>, so that we obtain:
</p>
<p style="text-align: center;"><code class="reqn">(x_1 * y_1) \pmod p + (x_1 * y_2) \pmod p + \dots + (x_1 * y_n) \pmod p</code>
</p>

<p>Where each product <code class="reqn">(x_1 * y_j)</code> for <code class="reqn">j &lt;= n</code> is smaller than the original <code class="reqn">x_1 * x_2</code>. With this approach, we are now capable of handling much larger numbers. Many details have been omitted for clarity.
</p>
<p>For a more in depth examination of this topic see <a href="https://codereview.stackexchange.com/questions/186751/accurate-modular-arithmetic-with-double-precision">Accurate Modular Arithmetic with Double Precision</a>.
</p>


<h3>Value</h3>

<p>Returns a named/unnamed logical vector. If an index is <code>TRUE</code>, the number at that index is prime, otherwise the number is composite.
</p>


<h3>Note</h3>

<p>The maximum value for each element in <code class="reqn">v</code> is <code class="reqn">2^{53} - 1</code>.
</p>


<h3>References</h3>


<ul>
<li><p><a href="https://www.math.uconn.edu/~kconrad/blurbs/ugradnumthy/millerrabin.pdf">THE MILLER-RABIN TEST</a></p>
<ul>
<li><p>Conrad, Keith. &quot;THE MILLER-RABIN TEST.&quot; https://www.math.uconn.edu/~kconrad/blurbs/ugradnumthy/millerrabin.pdf.</p>
</li></ul>

</li>
<li><p><a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format">53-bit significand precision</a></p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+primeFactorize">primeFactorize</a></code>, <code><a href="gmp.html#topic+isprime">isprime</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## check the primality of a single number
isPrimeRcpp(100)

## check the primality of every number in a vector
isPrimeRcpp(1:100)

set.seed(42)
mySamp &lt;- sample(10^13, 10)

## return named vector for easy identification
isPrimeRcpp(mySamp, namedVector = TRUE)

## Using nThreads
system.time(isPrimeRcpp(mySamp, nThreads = 2))
</code></pre>

<hr>
<h2 id='numDivisorSieve'>
Apply Divisor Function to Every Element in a Range
</h2><span id='topic+numDivisorSieve'></span>

<h3>Description</h3>

<p>Sieve that generates the number of divisors for every number between <code>bound1</code> and <code>bound2</code> (if supplied) or all numbers up to <code>bound1</code>. This is equivalent to applying the divisor function (often written as <code class="reqn">\sigma(x)</code>) to every number in a given range.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>numDivisorSieve(bound1, bound2 = NULL, namedVector = FALSE, nThreads = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="numDivisorSieve_+3A_bound1">bound1</code></td>
<td>
<p>Positive integer or numeric value.</p>
</td></tr>
<tr><td><code id="numDivisorSieve_+3A_bound2">bound2</code></td>
<td>
<p>Positive integer or numeric value.</p>
</td></tr>
<tr><td><code id="numDivisorSieve_+3A_namedvector">namedVector</code></td>
<td>
<p>Logical flag. If <code>TRUE</code>, a named vector is returned. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="numDivisorSieve_+3A_nthreads">nThreads</code></td>
<td>
<p>Specific number of threads to be used. The default is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simple and efficient sieve that calculates the number of divisors for every number in a given range. This function is very useful when you need to calculate the number of divisors for many numbers.
</p>
<p>This algorithm benefits greatly from the fast integer division library 'libdivide'. The following is from <a href="https://libdivide.com/">https://libdivide.com/</a>:
</p>
<ul>
<li><p>&ldquo;<em>libdivide allows you to replace expensive integer divides with comparatively cheap multiplication and bitshifts. Compilers usually do this, but only when the divisor is known at compile time. libdivide allows you to take advantage of it at runtime. The result is that integer division can become faster - a lot faster.</em>&rdquo;</p>
</li></ul>



<h3>Value</h3>

<p>Returns a named/unnamed integer vector
</p>


<h3>Note</h3>

<p>The maximum allowed value is <code class="reqn">2^{53} - 1</code>.
</p>


<h3>Author(s)</h3>

<p>Joseph Wood
</p>


<h3>References</h3>


<ul>
<li><p><a href="https://en.wikipedia.org/wiki/Divisor_function">Divisor function</a>
</p>
</li>
<li><p><a href="https://ridiculousfish.com/">ridiculousfish (author of libdivide)</a>
</p>
</li>
<li><p><a href="https://github.com/ridiculousfish/libdivide">github.com/ridiculousfish/libdivide</a>
</p>
</li>
<li><p><a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format">53-bit significand precision</a></p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Generate some random data
set.seed(8128)
mySamp &lt;- sample(10^6, 5*10^5)

## Generate number of divisors for
## every number less than a million
system.time(mySigmas &lt;- numDivisorSieve(10^6))

## Now use result in algorithm
for (s in mySamp) {
    sSig &lt;- mySigmas[s]
    ## Continue algorithm
}

## Generating number of divisors for every
## number in a range is no problem
system.time(sigmaRange &lt;- numDivisorSieve(10^13, 10^13 + 10^6))

## Returning a named vector
numDivisorSieve(10, 20, namedVector = TRUE)
numDivisorSieve(10, namedVector = TRUE)

## Using nThreads
system.time(numDivisorSieve(1e5, 2e5, nThreads = 2))
</code></pre>

<hr>
<h2 id='Partitions-class'>S4-class for Exposing C++ Partitions Class</h2><span id='topic+Partitions-class'></span><span id='topic++24+2CPartitions-method'></span>

<h3>Description</h3>

<p>The <code>Partitions</code> class is an S4-class that exposes C++ classes that provide access to iterators and other useful methods.
</p>


<h3>Slots</h3>


<dl>
<dt><code>nextIter</code></dt><dd><p>Retrieve the <b>next</b> lexicographical result</p>
</dd>
<dt><code>nextNIter</code></dt><dd><p>Pass an integer <em>n</em> to retrieve the <b>next</b> <em>n</em> lexicographical results</p>
</dd>
<dt><code>nextRemaining</code></dt><dd><p>Retrieve all remaining lexicographical results</p>
</dd>
<dt><code>currIter</code></dt><dd><p>Returns the current iteration</p>
</dd>
<dt><code>startOver</code></dt><dd><p>Resets the iterator</p>
</dd>
<dt><code>sourceVector</code></dt><dd><p>View the source vector</p>
</dd>
<dt><code>summary</code></dt><dd><p>Returns a list of summary information about the iterator</p>
</dd>
<dt><code>front</code></dt><dd><p>Retrieve the <b>first</b> lexicographical result</p>
</dd>
<dt><code>back</code></dt><dd><p>Retrieve the <b>last</b> lexicographical result</p>
</dd>
<dt><code>randomAccess</code></dt><dd><p>Random access method. Pass a single value or a vector of valid indices. If a single value is passed, the internal index of the iterator will be updated, however if a vector is passed the internal state will not change. GMP support allows for flexible indexing.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Joseph Wood</p>


<h3>See Also</h3>

<p><code><a href="#topic+Combo-class">Combo-class</a></code>, <code><a href="#topic+Constraints-class">Constraints-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  showClass("Partitions")
</code></pre>

<hr>
<h2 id='partitionsCount'>
Number of Partitions/Compositions
</h2><span id='topic+partitionsCount'></span><span id='topic+partitionsCount.default'></span><span id='topic+partitionsCount.table'></span><span id='topic+compositionsCount'></span><span id='topic+compositionsCount.default'></span><span id='topic+compositionsCount.table'></span>

<h3>Description</h3>

<p>Calculate the number of partitions/compositions of a vector chosen <code class="reqn">m</code> at a time with or without replacement. Additionally, these functions can calculate the number of partitions of multisets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partitionsCount(v, m = NULL, ...)
compositionsCount(v, m = NULL, ...)

## Default S3 method:
partitionsCount(v, m = NULL, repetition = FALSE,
                freqs = NULL, target = NULL, ...)
## Default S3 method:
compositionsCount(v, m = NULL, repetition = FALSE,
                  freqs = NULL, target = NULL, weak = FALSE, ...)

## S3 method for class 'table'
partitionsCount(v, m = NULL, target = NULL, ...)
## S3 method for class 'table'
compositionsCount(v, m = NULL, target = NULL, weak = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partitionsCount_+3A_v">v</code></td>
<td>
<p>Source vector. If <code>v</code> is a positive integer, it will be converted to the sequence <code>1:v</code>. If <code>v</code> is a negative integer, it will be converted to the sequence <code>v:-1</code>. Only integer and numeric vectors are accepted.</p>
</td></tr>
<tr><td><code id="partitionsCount_+3A_m">m</code></td>
<td>
<p>Width of the partition. If <code>m = NULL</code>, the length will be determined by the partitioning case (<em>e.g.</em> When we are generating distinct partitions of <code class="reqn">n</code>, the width will be equal to the smallest <code class="reqn">m</code> such that <code>sum(1:m) &gt;= n</code>).</p>
</td></tr>
<tr><td><code id="partitionsCount_+3A_...">...</code></td>
<td>
<p>Further arguments passed to methods.</p>
</td></tr>
<tr><td><code id="partitionsCount_+3A_repetition">repetition</code></td>
<td>
<p>Logical value indicating whether partitions/compositions should be with or without repetition. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="partitionsCount_+3A_freqs">freqs</code></td>
<td>
<p>A vector of frequencies used for producing all partitions of a multiset of <code>v</code>. Each element of <code>freqs</code> represents how many times each element of the source vector, <code>v</code>, is repeated. It is analogous to the <code>times</code> argument in <code><a href="base.html#topic+rep">rep</a></code>. The default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="partitionsCount_+3A_target">target</code></td>
<td>
<p>Number to be partitioned. If <code>NULL</code>, <code>max(v)</code> will be used.</p>
</td></tr>
<tr><td><code id="partitionsCount_+3A_weak">weak</code></td>
<td>
<p>(Compositions only) Logical flag indicating whether to allow terms of the sequence to be zero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numerical value representing the total number of partitions/compositions.
</p>


<h3>Note</h3>

<p>When the number of results exceeds <code class="reqn">2^{53} - 1</code>, a number of class <code>bigz</code> is returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+partitionsGeneral">partitionsGeneral</a></code>, <code><a href="#topic+compositionsGeneral">compositionsGeneral</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Same interface as partitionsGeneral
partitionsCount(25, 5)
compositionsCount(25, 5, TRUE)
partitionsCount(15, 7, TRUE)
partitionsCount(25, 5, freqs = rep(2, 25))

## Return object of class 'bigz'
partitionsCount(2500, 15, TRUE)
compositionsCount(2500, 15, TRUE)
</code></pre>

<hr>
<h2 id='partitionsGeneral'>
Generate Partitions/Compositions
</h2><span id='topic+partitionsGeneral'></span><span id='topic+partitionsGeneral.default'></span><span id='topic+partitionsGeneral.table'></span><span id='topic+compositionsGeneral'></span><span id='topic+compositionsGeneral.default'></span><span id='topic+compositionsGeneral.table'></span>

<h3>Description</h3>

<p>The algorithms in <code>RcppAlgos</code> go beyond the traditional integer partition algorithms and can tackle a wide variety of cases.
</p>

<ul>
<li><p> Efficient algorithms for partitioning numbers under various constraints:
</p>

<ul>
<li><p> Standard (with repetition)
</p>
</li>
<li><p> Distinct
</p>
</li>
<li><p> Restricted
</p>
</li>
<li><p> Where each part has a specific multiplicity (i.e. when using <code>freqs</code> for multisets).
</p>
</li>
<li><p> Arbitrary target and source vector (<em>e.g.</em> <code>partitionsGeneral(sample(1000, 20), 10, TRUE, target = 5000)</code>)
</p>
</li></ul>

</li>
<li><p> Produce results in parallel using the <code>nThreads</code> arguments.
</p>
</li>
<li><p> Alternatively, the arguments <code>lower</code> and <code>upper</code> make it possible to generate partitions/compositions in chunks allowing for parallelization via the parallel package.
</p>
</li>
<li><p> GMP support allows for exploration of cases where the number of partitions/compositions is large.
</p>
</li>
<li><p> The output is in lexicographical order.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>partitionsGeneral(v, m = NULL, ...)
compositionsGeneral(v, m = NULL, ...)

## Default S3 method:
partitionsGeneral(
    v, m = NULL, repetition = FALSE, freqs = NULL, target = NULL,
    lower = NULL, upper = NULL, nThreads = NULL, tolerance = NULL, ...
)
## Default S3 method:
compositionsGeneral(
    v, m = NULL, repetition = FALSE, freqs = NULL, target = NULL, weak = FALSE,
    lower = NULL, upper = NULL, nThreads = NULL, tolerance = NULL, ...
)

## S3 method for class 'table'
partitionsGeneral(
    v, m = NULL, target = NULL, lower = NULL,
    upper = NULL, nThreads = NULL, tolerance = NULL, ...
)
## S3 method for class 'table'
compositionsGeneral(
    v, m = NULL, target = NULL, weak = FALSE, lower = NULL,
    upper = NULL, nThreads = NULL, tolerance = NULL, ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partitionsGeneral_+3A_v">v</code></td>
<td>
<p>Source vector. If <code>v</code> is a positive integer, it will be converted to the sequence <code>1:v</code>. If <code>v</code> is a negative integer, it will be converted to the sequence <code>v:-1</code>. Only integer and numeric vectors are accepted.</p>
</td></tr>
<tr><td><code id="partitionsGeneral_+3A_m">m</code></td>
<td>
<p>Width of the partition. If <code>m = NULL</code>, the length will be determined by the partitioning case (<em>e.g.</em> When we are generating distinct partitions of <code class="reqn">n</code>, the width will be equal to the smallest <code class="reqn">m</code> such that <code>sum(1:m) &gt;= n</code>).</p>
</td></tr>
<tr><td><code id="partitionsGeneral_+3A_...">...</code></td>
<td>
<p>Further arguments passed to methods.</p>
</td></tr>
<tr><td><code id="partitionsGeneral_+3A_repetition">repetition</code></td>
<td>
<p>Logical value indicating whether partitions/compositions should be with or without repetition. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="partitionsGeneral_+3A_freqs">freqs</code></td>
<td>
<p>A vector of frequencies used for producing all partitions of a multiset of <code>v</code>. Each element of <code>freqs</code> represents how many times each element of the source vector, <code>v</code>, is repeated. It is analogous to the <code>times</code> argument in <code><a href="base.html#topic+rep">rep</a></code>. The default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="partitionsGeneral_+3A_lower">lower</code></td>
<td>
<p>The lower bound. Partitions/compositions are generated lexicographically, thus utilizing this argument will determine which specific partition to start generating from (<em>e.g.</em> <code>partitionsGeneral(15, 3, lower = 6)</code> is equivalent to <code>partitionsGeneral(15, 3)[6:partitionsCount(15, 3), ]</code>). This argument along with <code>upper</code> is very useful for generating partitions/compositions in chunks allowing for easy parallelization.</p>
</td></tr>
<tr><td><code id="partitionsGeneral_+3A_upper">upper</code></td>
<td>
<p>The upper bound. Similar to <code>lower</code>, however this parameter allows the user to <em>stop</em> generation at a specific partition (<em>e.g.</em> <code>partitionsGeneral(15, 3, upper = 5)</code> is equivalent to <code>partitionsGeneral(15, 3)[1:5, ]</code>)</p>
</td></tr>
<tr><td><code id="partitionsGeneral_+3A_target">target</code></td>
<td>
<p>Number to be partitioned. If <code>NULL</code>, <code>max(v)</code> will be used.</p>
</td></tr>
<tr><td><code id="partitionsGeneral_+3A_weak">weak</code></td>
<td>
<p>(Compositions only) Logical flag indicating whether to allow terms of the sequence to be zero.</p>
</td></tr>
<tr><td><code id="partitionsGeneral_+3A_nthreads">nThreads</code></td>
<td>
<p>Specific number of threads to be used. The default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="partitionsGeneral_+3A_tolerance">tolerance</code></td>
<td>
<p>A numeric value greater than or equal to zero. This parameter is utilized when a constraint is applied on a numeric vector. The default value is 0 when it can be determined that whole values are being utilized, otherwise it is <code>sqrt(.Machine$double.eps)</code> which is approximately <code class="reqn">1.5e-8</code>. N.B. If the input vector is of type integer, this parameter will be ignored and strict equality will be enforced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix is returned with each row containing a vector of length <code class="reqn">m</code>.
</p>


<h3>Note</h3>


<ul>
<li><p><code>nThreads</code> will be ignored in the following cases (i.e. Generating the <code class="reqn">n^{th}</code> partition in these cases are currently unavailable):
</p>

<ul>
<li><p> With standard multisets. If zero is the only element with a non-trivial multiplicity, multithreading is possible (<em>e.g.</em> <code>partitionsGeneral(0:100, freqs = c(100, rep(1, 100)), nThreads = 4)</code>).
</p>
</li>
<li><p> If the source vector is not isomorphic to <code>1:length(v)</code> (<em>e.g.</em> <code>v = c(1, 4, 6, 7, 8)</code>).
</p>
</li></ul>


</li>
<li><p> The maximum number of partitions/compositions that can be generated at one time is <code class="reqn">2^{31} - 1</code>. Utilizing <code>lower</code> and <code>upper</code> makes it possible to generate additional partitions/compositions.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Joseph Wood
</p>


<h3>References</h3>


<ul>
<li><p><a href="https://en.wikipedia.org/wiki/Lexicographical_order">Lexicographical Order</a>
</p>
</li>
<li><p><a href="https://en.wikipedia.org/wiki/Subset_sum_problem">Subset Sum Problem</a>
</p>
</li>
<li><p><a href="https://en.wikipedia.org/wiki/Partition_(number_theory)">Partition (number theory)</a>
</p>
</li>
<li><p><a href="https://en.wikipedia.org/wiki/Composition_(combinatorics)">Composition (combinatorics))</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>partitionsGeneral(1)
partitionsGeneral(-1:0, 1)
partitionsGeneral(-1:0, 1, target = -1)
partitionsGeneral(20, 5)
partitionsGeneral(20, 5, repetition = TRUE)
partitionsGeneral(20, 5, freqs = rep(1:4, 5))
partitionsGeneral(20, 5, TRUE, target = 80)
partitionsGeneral(0:10, repetition = TRUE)
partitionsGeneral(seq(2L, 500L, 23L), 5, target = 1804)

compositionsGeneral(0:10, 5, repetition = TRUE)

set.seed(111)
partitionsGeneral(sample(1000, 20), 5, TRUE, target = 2500)

system.time(one_thread  &lt;- partitionsGeneral(80, 10, TRUE))
system.time(two_threads &lt;- partitionsGeneral(80, 10, TRUE, nThreads = 2))
identical(one_thread, two_threads)
</code></pre>

<hr>
<h2 id='partitionsIter'>
Partition/Composition Iterator
</h2><span id='topic+partitionsIter'></span><span id='topic+partitionsIter.default'></span><span id='topic+partitionsIter.table'></span><span id='topic+compositionsIter'></span><span id='topic+compositionsIter.default'></span><span id='topic+compositionsIter.table'></span>

<h3>Description</h3>


<ul>
<li><p> Returns an iterator for iterating over partitions/compositions of a numbers.
</p>
</li>
<li><p> Supports random access via the <code>[[</code> method.
</p>
</li>
<li><p> GMP support allows for exploration of cases where the number of partitions/compositions is large.
</p>
</li>
<li><p> Use the <code>next</code> methods to obtain results in lexicographical order.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>partitionsIter(v, m = NULL, ...)
compositionsIter(v, m = NULL, ...)

## Default S3 method:
partitionsIter(v, m = NULL, repetition = FALSE,
               freqs = NULL, target = NULL,
               nThreads = NULL, tolerance = NULL, ...)

## Default S3 method:
compositionsIter(v, m = NULL, repetition = FALSE, freqs = NULL,
                 target = NULL, weak = FALSE, nThreads = NULL,
                 tolerance = NULL, ...)

## S3 method for class 'table'
partitionsIter(
    v, m = NULL, target = NULL, nThreads = NULL, tolerance = NULL, ...
)
## S3 method for class 'table'
compositionsIter(
    v, m = NULL, target = NULL, weak = FALSE, nThreads = NULL, tolerance = NULL, ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partitionsIter_+3A_v">v</code></td>
<td>
<p>Source vector. If <code>v</code> is a positive integer, it will be converted to the sequence <code>1:v</code>. If <code>v</code> is a negative integer, it will be converted to the sequence <code>v:-1</code>. Only integer and numeric vectors are accepted.</p>
</td></tr>
<tr><td><code id="partitionsIter_+3A_m">m</code></td>
<td>
<p>Width of the partition. If <code>m = NULL</code>, the length will be determined by the partitioning case (<em>e.g.</em> When we are generating distinct partitions of <code class="reqn">n</code>, the width will be equal to the smallest <code class="reqn">m</code> such that <code>sum(1:m) &gt;= n</code>).</p>
</td></tr>
<tr><td><code id="partitionsIter_+3A_...">...</code></td>
<td>
<p>Further arguments passed to methods.</p>
</td></tr>
<tr><td><code id="partitionsIter_+3A_repetition">repetition</code></td>
<td>
<p>Logical value indicating whether partitions/compositions should be with or without repetition. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="partitionsIter_+3A_freqs">freqs</code></td>
<td>
<p>A vector of frequencies used for producing all partitions of a multiset of <code>v</code>. Each element of <code>freqs</code> represents how many times each element of the source vector, <code>v</code>, is repeated. It is analogous to the <code>times</code> argument in <code><a href="base.html#topic+rep">rep</a></code>. The default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="partitionsIter_+3A_target">target</code></td>
<td>
<p>Number to be partitioned. If <code>NULL</code>, <code>max(v)</code> will be used.</p>
</td></tr>
<tr><td><code id="partitionsIter_+3A_weak">weak</code></td>
<td>
<p>(Compositions only) Logical flag indicating whether to allow terms of the sequence to be zero.</p>
</td></tr>
<tr><td><code id="partitionsIter_+3A_nthreads">nThreads</code></td>
<td>
<p>Specific number of threads to be used. The default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="partitionsIter_+3A_tolerance">tolerance</code></td>
<td>
<p>A numeric value greater than or equal to zero. This parameter is utilized when a constraint is applied on a numeric vector. The default value is 0 when it can be determined that whole values are being utilized, otherwise it is <code>sqrt(.Machine$double.eps)</code> which is approximately <code class="reqn">1.5e-8</code>. N.B. If the input vector is of type integer, this parameter will be ignored and strict equality will be enforced.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Once you initialize a new iterator, the following methods are available:
</p>

<dl>
<dt><code>nextIter</code></dt><dd><p>Retrieve the <b>next</b> lexicographical result</p>
</dd>
<dt><code>nextNIter</code></dt><dd><p>Pass an integer <em>n</em> to retrieve the <b>next</b> <em>n</em> lexicographical results</p>
</dd>
<dt><code>nextRemaining</code></dt><dd><p>Retrieve all remaining lexicographical results</p>
</dd>
<dt><code>currIter</code></dt><dd><p>Returns the current iteration</p>
</dd>
<dt><code>startOver</code></dt><dd><p>Resets the iterator</p>
</dd>
<dt><code>sourceVector</code></dt><dd><p>View the source vector</p>
</dd>
<dt><code>summary</code></dt><dd><p>Returns a list of summary information about the iterator</p>
</dd>
<dt><code>front</code></dt><dd><p>Retrieve the <b>first</b> lexicographical result</p>
</dd>
<dt><code>back</code></dt><dd><p>Retrieve the <b>last</b> lexicographical result</p>
</dd>
<dt><code>[[</code></dt><dd><p>Random access method. Pass a single value or a vector of valid indices. If a single value is passed, the internal index of the iterator will be updated, however if a vector is passed the internal state will not change. GMP support allows for flexible indexing.</p>
</dd>
</dl>



<h3>Value</h3>


<ul>
<li><p> If <code>nextIter</code> is called, a vector is returned
</p>
</li>
<li><p> Otherwise, a matrix with <code class="reqn">m</code> columns
</p>
</li></ul>



<h3>Note</h3>


<ul>
<li><p>If <code>nThreads</code> is utilized, it will only take effect if the number of elements requested is greater than some threshold (determined internally). <em>E.g</em>:
</p>
<pre>serial   &lt;- partitionsIter(1000, 10)
multi    &lt;- partitionsIter(1000, 10, nThreads = 4)
fetch1e6 &lt;- multi@nextNIter(1e6)  ## much faster than serial@nextNIter(1e6)
fetch1e3 &lt;- multi@nextNIter(1e3)  ## only one thread used... same as serial@nextNIter(1e3)

library(microbenchmark)
microbenchmark(multi@nextNIter(1e6), serial@nextNIter(1e6))
microbenchmark(multi@nextNIter(1e3), serial@nextNIter(1e3))</pre>

</li>
<li><p><code>nThreads</code> will be ignored in the following cases (i.e. Generating the <code class="reqn">n^{th}</code> partition in these cases are currently unavailable):
</p>

<ul>
<li><p>With standard multisets. If zero is the only element with a non-trivial multiplicity, multithreading is possible.
</p>
</li>
<li><p>If the source vector is not isomorphic to <code>1:length(v)</code>
</p>
</li></ul>


</li>
<li><p>The maximum number of partitions/compositions that can be generated at one time is <code class="reqn">2^{31} - 1</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Joseph Wood
</p>


<h3>References</h3>


<ul>
<li><p><a href="https://en.wikipedia.org/wiki/Lexicographical_order">Lexicographical Order</a>
</p>
</li>
<li><p><a href="https://en.wikipedia.org/wiki/Subset_sum_problem">Subset Sum Problem</a>
</p>
</li>
<li><p><a href="https://en.wikipedia.org/wiki/Partition_(number_theory)">Partition (number theory)</a>
</p>
</li>
<li><p><a href="https://en.wikipedia.org/wiki/Composition_(combinatorics)">Composition (combinatorics))</a>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+partitionsGeneral">partitionsGeneral</a></code>, <code><a href="#topic+compositionsGeneral">compositionsGeneral</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a = partitionsIter(0:10, repetition = TRUE)
a@nextIter()
a@nextNIter(3)
a@front()
a@nextRemaining()
a@summary()
a@back()
a[[5]]
a@summary()
a[[c(1, 17, 3)]]
a@summary()

## Multisets... no random access
b = partitionsIter(40, 5, freqs = rep(1:4, 10), target = 80)
b@nextIter()
b@nextNIter(10)
b@summary()
b@nextIter()
b@currIter()
</code></pre>

<hr>
<h2 id='partitionsRank'>
Rank Partitions/Compositions
</h2><span id='topic+partitionsRank'></span><span id='topic+compositionsRank'></span>

<h3>Description</h3>


<ul>
<li><p> Generate the rank (lexicographically) of partitions/compositions. These functions are the complement to <code>partitions/compositionsSample</code>. See the examples below.
</p>
</li>
<li><p> GMP support allows for exploration of partitions/compositions of vectors with many elements.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>partitionsRank(..., v, repetition = FALSE, freqs = NULL, target = NULL)

compositionsRank(..., v, repetition = FALSE, freqs = NULL,
                 target = NULL, weak = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partitionsRank_+3A_...">...</code></td>
<td>
<p>vectors or matrices to be ranked.</p>
</td></tr>
<tr><td><code id="partitionsRank_+3A_v">v</code></td>
<td>
<p>Source vector. If <code>v</code> is a positive integer, it will be converted to the sequence <code>1:v</code>. If <code>v</code> is a negative integer, it will be converted to the sequence <code>v:-1</code>. All atomic types are supported (See <code><a href="base.html#topic+is.atomic">is.atomic</a></code>).</p>
</td></tr>
<tr><td><code id="partitionsRank_+3A_repetition">repetition</code></td>
<td>
<p>Logical value indicating whether partitions/compositions should be with or without repetition. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="partitionsRank_+3A_freqs">freqs</code></td>
<td>
<p>A vector of frequencies used for producing all partitions of a multiset of <code>v</code>. Each element of <code>freqs</code> represents how many times each element of the source vector, <code>v</code>, is repeated. It is analogous to the <code>times</code> argument in <code><a href="base.html#topic+rep">rep</a></code>. The default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="partitionsRank_+3A_target">target</code></td>
<td>
<p>Number to be partitioned. If <code>NULL</code>, <code>max(v)</code> will be used.</p>
</td></tr>
<tr><td><code id="partitionsRank_+3A_weak">weak</code></td>
<td>
<p>(Compositions only) Logical flag indicating whether to allow terms of the sequence to be zero.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These algorithms rely on efficiently ranking the <code class="reqn">n^{th}</code> lexicographical partition.
</p>


<h3>Value</h3>

<p>A vector of class <code>integer</code>, <code>numeric</code>, or <code>bigz</code> determined by the total number of partitions/compositions</p>


<h3>Note</h3>

<p><code>v</code> must be supplied.
</p>


<h3>Author(s)</h3>

<p>Joseph Wood
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Lexicographical_order">Lexicographical order</a>
<a href="https://rosettacode.org/wiki/Permutations/Rank_of_a_permutation">ranking/unranking</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+partitionsSample">partitionsSample</a></code>, <code><a href="#topic+compositionsSample">compositionsSample</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mySamp = partitionsSample(30, 8, TRUE, n = 5, seed = 10, namedSample = TRUE)
myRank = partitionsRank(mySamp, v = 30, repetition = TRUE)
all.equal(as.integer(rownames(mySamp)), myRank)
</code></pre>

<hr>
<h2 id='partitionsSample'>
Sample Partitions/Compositions
</h2><span id='topic+partitionsSample'></span><span id='topic+partitionsSample.default'></span><span id='topic+partitionsSample.table'></span><span id='topic+compositionsSample'></span><span id='topic+compositionsSample.default'></span><span id='topic+compositionsSample.table'></span>

<h3>Description</h3>


<ul>
<li><p> Generate a specific (lexicographically) or random sample of partitions/compositions of a number.
</p>
</li>
<li><p> Produce results in parallel using the <code>Parallel</code> or <code>nThreads</code> arguments.
</p>
</li>
<li><p> GMP support allows for exploration of cases where the number of partitions/compositions is large.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>partitionsSample(v, m = NULL, ...)
compositionsSample(v, m = NULL, ...)

## Default S3 method:
partitionsSample(
    v, m = NULL, repetition = FALSE, freqs = NULL, target = NULL,
    n = NULL, sampleVec = NULL, seed = NULL,
    nThreads = NULL, namedSample = FALSE, ...
)
## Default S3 method:
compositionsSample(
    v, m = NULL, repetition = FALSE, freqs = NULL, target = NULL,
    weak = FALSE, n = NULL, sampleVec = NULL, seed = NULL,
    nThreads = NULL, namedSample = FALSE, ...
)

## S3 method for class 'table'
partitionsSample(
    v, m = NULL, target = NULL, n = NULL,
    sampleVec = NULL, seed = NULL, nThreads = NULL, namedSample = FALSE, ...
)
## S3 method for class 'table'
compositionsSample(
    v, m = NULL, target = NULL, weak = FALSE, n = NULL,
    sampleVec = NULL, seed = NULL, nThreads = NULL, namedSample = FALSE, ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partitionsSample_+3A_v">v</code></td>
<td>
<p>Source vector. If <code>v</code> is a positive integer, it will be converted to the sequence <code>1:v</code>. If <code>v</code> is a negative integer, it will be converted to the sequence <code>v:-1</code>. Only integer and numeric vectors are accepted.</p>
</td></tr>
<tr><td><code id="partitionsSample_+3A_m">m</code></td>
<td>
<p>Width of the partition. If <code>m = NULL</code>, the length will be determined by the partitioning case (<em>e.g.</em> When we are generating distinct partitions of <code class="reqn">n</code>, the width will be equal to the smallest <code class="reqn">m</code> such that <code>sum(1:m) &gt;= n</code>).</p>
</td></tr>
<tr><td><code id="partitionsSample_+3A_...">...</code></td>
<td>
<p>Further arguments passed to methods.</p>
</td></tr>
<tr><td><code id="partitionsSample_+3A_repetition">repetition</code></td>
<td>
<p>Logical value indicating whether partitions/compositions should be with or without repetition. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="partitionsSample_+3A_freqs">freqs</code></td>
<td>
<p>A vector of frequencies used for producing all partitions of a multiset of <code>v</code>. Each element of <code>freqs</code> represents how many times each element of the source vector, <code>v</code>, is repeated. It is analogous to the <code>times</code> argument in <code><a href="base.html#topic+rep">rep</a></code>. The default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="partitionsSample_+3A_target">target</code></td>
<td>
<p>Number to be partitioned. If <code>NULL</code>, <code>max(v)</code> will be used.</p>
</td></tr>
<tr><td><code id="partitionsSample_+3A_weak">weak</code></td>
<td>
<p>(Compositions only) Logical flag indicating whether to allow terms of the sequence to be zero.</p>
</td></tr>
<tr><td><code id="partitionsSample_+3A_n">n</code></td>
<td>
<p>Number of partitions/compositions to return. The default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="partitionsSample_+3A_samplevec">sampleVec</code></td>
<td>
<p>A vector of numbers representing the lexicographical partitions/compositions to return. Accepts vectors of class <code>bigz</code> as well as vectors of characters</p>
</td></tr>
<tr><td><code id="partitionsSample_+3A_seed">seed</code></td>
<td>
<p>Random seed initialization. The default is <code>NULL</code>. N.B. If the gmp library is needed, this parameter must be set in order to have reproducible results (<em>E.g</em> <code>set.seed()</code> has no effect in these cases).</p>
</td></tr>
<tr><td><code id="partitionsSample_+3A_nthreads">nThreads</code></td>
<td>
<p>Specific number of threads to be used. The default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="partitionsSample_+3A_namedsample">namedSample</code></td>
<td>
<p>Logical flag. If <code>TRUE</code>, <code>rownames</code> corresponding to the lexicographical partition, will be added to the returned matrix. The default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These algorithms rely on efficiently generating the <code class="reqn">n^{th}</code> lexicographical partition. This is the process of <a href="https://rosettacode.org/wiki/Permutations/Rank_of_a_permutation">unranking</a>.
</p>


<h3>Value</h3>

<p>A matrix is returned with each row containing a vector of length <code class="reqn">m</code>.
</p>


<h3>Note</h3>


<ul>
<li><p><code>partitionsSample</code> is not available for the following cases:
</p>

<ul>
<li><p> With standard multisets. If zero is the only element with a non-trivial multiplicity, sampling is allowed (<em>e.g.</em> <code>partitionsSample(0:100, freqs = c(100, rep(1, 100)), n = 2)</code>)
</p>
</li>
<li><p> If the source vector is not isomorphic to <code>1:length(v)</code> (<em>e.g.</em> <code>v = c(1, 4, 6, 7, 8)</code>).
</p>
</li></ul>


</li>
<li> <p><code>n</code> and <code>sampleVec</code> cannot both be <code>NULL</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Joseph Wood
</p>


<h3>References</h3>


<ul>
<li><p><a href="https://en.wikipedia.org/wiki/Lexicographical_order">Lexicographical order</a>
</p>
</li>
<li><p><a href="https://en.wikipedia.org/wiki/Partition_(number_theory)">Partition (Number Theory)</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>partitionsSample(100, 10, n = 5)
partitionsSample(100, 10, seed = 42, n = 5, target = 200)

## retrieve specific results (lexicographically)
partitionsCount(100, 10, TRUE, target = 500)
## [1] 175591757896
partitionsSample(100, 10, TRUE, target = 500,
                 sampleVec = c(1, 1000, 175591757896))
</code></pre>

<hr>
<h2 id='primeCount'>
Prime Counting Function <code class="reqn">\pi(x)</code>
</h2><span id='topic+primeCount'></span>

<h3>Description</h3>

<p><a href="https://en.wikipedia.org/wiki/Prime-counting_function">Prime counting function</a> for counting the prime numbers less than an integer, <code class="reqn">n</code>, using Legendre's formula. It is based on the the algorithm developed by Kim Walisch found here: <a href="https://github.com/kimwalisch/primecount">kimwalisch/primecount</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>primeCount(n, nThreads = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="primeCount_+3A_n">n</code></td>
<td>
<p>Positive number</p>
</td></tr>
<tr><td><code id="primeCount_+3A_nthreads">nThreads</code></td>
<td>
<p>Specific number of threads to be used. The default is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><a href="https://mathworld.wolfram.com/LegendresFormula.html">Legendre's Formula</a> for counting the number of primes less than <code class="reqn">n</code> makes use of the <a href="https://en.wikipedia.org/wiki/Inclusion-exclusion_principle">inclusion-exclusion principle</a> to avoid explicitly counting every prime up to <code class="reqn">n</code>. It is given by:
</p>
<p style="text-align: center;"><code class="reqn">\pi(x) = \pi(\sqrt x) + \Phi(x, \sqrt x) - 1</code>
</p>

<p>Where <code class="reqn">\Phi(x, a)</code> is the number of positive integers less than or equal to <code class="reqn">x</code> that are relatively prime to the first <code class="reqn">a</code> primes (i.e. not divisible by any of the first <code class="reqn">a</code> primes). It is given by the recurrence relation (<code class="reqn">p_a</code> is the <code class="reqn">ath</code> prime (e.g. <code class="reqn">p_4 = 7</code>)):
</p>
<p style="text-align: center;"><code class="reqn">\Phi(x, a) = \Phi(x, a - 1) + \Phi(x / p_a, a - 1)</code>
</p>

<p>This algorithm implements five modifications developed by Kim Walisch for calculating <code class="reqn">\Phi(x, a)</code> efficiently.
</p>

<ol>
<li><p>Cache results of <code class="reqn">\Phi(x, a)</code>
</p>
</li>
<li><p>Calculate <code class="reqn">\Phi(x, a)</code> using <code class="reqn">\Phi(x, a) = (x / pp) * \phi(pp) + \Phi(x mod pp, a)</code>  if <code class="reqn">a &lt;= 6</code>
</p>

<ul>
<li><p><code class="reqn">pp = 2 * 3 * ... * </code> <code>prime[a]</code>
</p>
</li>
<li><p><code class="reqn">\phi(pp) = (2 - 1) * (3 - 1) * ... * </code> <code class="reqn">(</code><code>prime[a]</code> <code class="reqn">- 1)</code> (i.e. Euler's totient function)
</p>
</li></ul>


</li>
<li><p>Calculate <code class="reqn">\Phi(x, a)</code> using <code class="reqn">\pi(x)</code> lookup table
</p>
</li>
<li><p>Calculate all <code class="reqn">\Phi(x, a) = 1</code> upfront
</p>
</li>
<li><p>Stop recursion at <code class="reqn">6</code> if <code class="reqn">\sqrt x &gt;= 13</code> or <code class="reqn">\pi(\sqrt x)</code> instead of <code class="reqn">1</code>
</p>
</li></ol>



<h3>Value</h3>

<p>Whole number representing the number of prime numbers less than or equal to <code class="reqn">n</code>.
</p>


<h3>Note</h3>

<p>The maximum value of <code class="reqn">n</code> is <code class="reqn">2^{53} - 1</code>
</p>


<h3>Author(s)</h3>

<p>Joseph Wood
</p>


<h3>References</h3>


<ul>
<li><p><a href="https://sweet.ua.pt/tos/bib/5.4.pdf">Computing <code class="reqn">\pi(x)</code>: the combinatorial method</a></p>
<ul>
<li><p>Tom√°s Oliveira e Silva, Computing pi(x): the combinatorial method, Revista do DETUA, vol. 4, no. 6, March 2006, p. 761. https://sweet.ua.pt/tos/bib/5.4.pdf</p>
</li></ul>

</li>
<li><p><a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format">53-bit significand precision</a>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+primeSieve">primeSieve</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Get the number of primes less than a billion
primeCount(10^9)

## Using nThreads
system.time(primeCount(10^10, nThreads = 2))
</code></pre>

<hr>
<h2 id='primeFactorize'>
Vectorized Prime Factorization
</h2><span id='topic+primeFactorize'></span>

<h3>Description</h3>

<p>Implementation of Pollard's rho algorithm for generating the prime factorization. The algorithm is based on the &quot;factorize.c&quot; source file from the gmp library found here <a href="https://gmplib.org">https://gmplib.org</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>primeFactorize(v, namedList = FALSE, nThreads = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="primeFactorize_+3A_v">v</code></td>
<td>
<p>Vector of integers or numeric values. Non-integral values will be cured to whole numbers.</p>
</td></tr>
<tr><td><code id="primeFactorize_+3A_namedlist">namedList</code></td>
<td>
<p>Logical flag. If <code>TRUE</code> and the <code>length(v) &gt; 1</code>, a named list is returned. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="primeFactorize_+3A_nthreads">nThreads</code></td>
<td>
<p>Specific number of threads to be used. The default is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As noted in the Description section above, this algorithm is based on the &quot;factorize.c&quot; source code from the gmp library. Much of the code in RcppAlgos::primeFactorize is a straightforward translation from multiple precision C data types to standard C++ data types. A crucial part of the algorithm's efficiency is based on quickly determining <a href="https://en.wikipedia.org/wiki/Primality_test">primality</a>, which is easily computed with gmp. However, with standard C++, this is quite challenging. Much of the research for RcppAlgos::primeFactorize was focused on developing an algorithm that could accurately and efficiently compute primality.
</p>
<p>For more details, see the documentation for <code><a href="#topic+isPrimeRcpp">isPrimeRcpp</a></code>.
</p>


<h3>Value</h3>


<ul>
<li><p>Returns an unnamed vector if <code>length(v) == 1</code> regardless of the value of <code>namedList</code>. If <code class="reqn">v &lt; 2^{31}</code>, the class of the returned vector will be integer, otherwise the class will be numeric.
</p>
</li>
<li><p>If <code>length(v) &gt; 1</code>, a named/unnamed list of vectors will be returned. If <code>max(bound1, bound2)</code> <code class="reqn">&lt; 2^{31}</code>, the class of each vector will be integer, otherwise the class will be numeric.
</p>
</li></ul>



<h3>Note</h3>

<p>The maximum value for each element in <code class="reqn">v</code> is <code class="reqn">2^{53} - 1</code>.
</p>


<h3>Author(s)</h3>

<p>Joseph Wood
</p>


<h3>References</h3>


<ul>
<li><p><a href="https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm">Pollard's rho algorithm</a>
</p>
</li>
<li><p><a href="https://en.wikipedia.org/wiki/Miller-Rabin_primality_test">Miller-Rabin primality test</a>
</p>
</li>
<li><p><a href="https://codereview.stackexchange.com/questions/186751/accurate-modular-arithmetic-with-double-precision">Accurate Modular Arithmetic with Double Precision</a>
</p>
</li>
<li><p><a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format">53-bit significand precision</a>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+primeFactorizeSieve">primeFactorizeSieve</a></code>, <code><a href="gmp.html#topic+factorize">factorize</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Get the prime factorization of a single number
primeFactorize(10^8)

## Or get the prime factorization of many numbers
set.seed(29)
myVec &lt;- sample(-1000000:1000000, 1000)
system.time(pFacs &lt;- primeFactorize(myVec))

## Return named list
pFacsWithNames &lt;- primeFactorize(myVec, namedList = TRUE)

## Using nThreads
system.time(primeFactorize(myVec, nThreads = 2))
</code></pre>

<hr>
<h2 id='primeFactorizeSieve'>
Generate Prime Factorization for Numbers in a Range
</h2><span id='topic+primeFactorizeSieve'></span>

<h3>Description</h3>

<p>Generates the prime factorization of all numbers between <code>bound1</code> and <code>bound2</code> (if supplied) or all numbers up to <code>bound1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>primeFactorizeSieve(bound1, bound2 = NULL, namedList = FALSE, nThreads = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="primeFactorizeSieve_+3A_bound1">bound1</code></td>
<td>
<p>Positive integer or numeric value.</p>
</td></tr>
<tr><td><code id="primeFactorizeSieve_+3A_bound2">bound2</code></td>
<td>
<p>Positive integer or numeric value.</p>
</td></tr>
<tr><td><code id="primeFactorizeSieve_+3A_namedlist">namedList</code></td>
<td>
<p>Logical flag. If <code>TRUE</code>, a named list is returned. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="primeFactorizeSieve_+3A_nthreads">nThreads</code></td>
<td>
<p>Specific number of threads to be used. The default is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is useful when many prime factorizations are needed. Instead of generating the prime factorization on the fly, one can reference the indices/names of the generated list.
</p>
<p>This algorithm benefits greatly from the fast integer division library 'libdivide'. The following is from <a href="https://libdivide.com/">https://libdivide.com/</a>:
</p>
<ul>
<li><p>&ldquo;<em>libdivide allows you to replace expensive integer divides with comparatively cheap multiplication and bitshifts. Compilers usually do this, but only when the divisor is known at compile time. libdivide allows you to take advantage of it at runtime. The result is that integer division can become faster - a lot faster.</em>&rdquo;</p>
</li></ul>



<h3>Value</h3>

<p>Returns a named/unnamed list of integer vectors if <code>max(bound1, bound2)</code> <code class="reqn">&lt; 2^{31}</code>, or a list of numeric vectors otherwise.
</p>


<h3>Note</h3>

<p>The maximum value for either of the bounds is <code class="reqn">2^{53} - 1</code>.
</p>


<h3>Author(s)</h3>

<p>Joseph Wood
</p>


<h3>References</h3>


<ul>
<li><p><a href="https://en.wikipedia.org/wiki/Prime_factor">Prime Factor</a>
</p>
</li>
<li><p><a href="https://ridiculousfish.com/">ridiculousfish (author of libdivide)</a>
</p>
</li>
<li><p><a href="https://github.com/ridiculousfish/libdivide">github.com/ridiculousfish/libdivide</a>
</p>
</li>
<li><p><a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format">53-bit significand precision</a>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+primeFactorize">primeFactorize</a></code>, <code><a href="#topic+divisorsSieve">divisorsSieve</a></code>, <code><a href="gmp.html#topic+factorize">factorize</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate some random data
set.seed(28)
mySamp &lt;- sample(10^5, 5*10^4)

## Generate prime factorizations up
## to 10^5 (max element from mySamp)
system.time(allPFacs &lt;- primeFactorizeSieve(10^5))

## Use generated prime factorization for further
## analysis by accessing the index of allPFacs
for (s in mySamp) {
    pFac &lt;- allPFacs[[s]]
    ## Continue algorithm
}

## Generating prime factorizations over
## a range is efficient as well
system.time(primeFactorizeSieve(10^12, 10^12 + 10^5))

## Set 'namedList' to TRUE to return a named list
primeFactorizeSieve(27, 30, namedList = TRUE)

## Using nThreads
system.time(primeFactorizeSieve(1e4, 5e4, nThreads = 2))
</code></pre>

<hr>
<h2 id='primeSieve'>
Generate Prime Numbers
</h2><span id='topic+primeSieve'></span>

<h3>Description</h3>

<p>Implementation of the segmented sieve of Eratosthenes with wheel factorization. Generates all prime numbers between <code>bound1</code> and <code>bound2</code> (if supplied) or all primes up to <code>bound1</code>. See this stackoverflow post for an analysis on prime number generation efficiency in R: <a href="https://stackoverflow.com/a/48313378/4408538">Generate a list of primes up to a certain number
</a>
</p>
<p>The fundamental concepts of this algorithm are based off of the implementation by Kim Walisch found here: <a href="https://github.com/kimwalisch/primesieve">kimwalisch/primesieve</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>primeSieve(bound1, bound2 = NULL, nThreads = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="primeSieve_+3A_bound1">bound1</code></td>
<td>
<p>Positive integer or numeric value.</p>
</td></tr>
<tr><td><code id="primeSieve_+3A_bound2">bound2</code></td>
<td>
<p>Positive integer or numeric value.</p>
</td></tr>
<tr><td><code id="primeSieve_+3A_nthreads">nThreads</code></td>
<td>
<p>Specific number of threads to be used. The default is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At the heart of this algorithm is the traditional sieve of Eratosthenes (i.e. given a <a href="https://en.wikipedia.org/wiki/Prime_number">prime</a> <code class="reqn">p</code>, mark all multiples of <code class="reqn">p</code> as <a href="https://en.wikipedia.org/wiki/Composite_number">composite</a>), however instead of sieving the entire interval, we only consider small sub-intervals. The benefits of this method are two fold:
</p>

<ol>
<li><p> Reduction of the <a href="https://en.wikipedia.org/wiki/DSPACE">space complexity</a> from <code class="reqn">O(n)</code>, for the traditional sieve, to <code class="reqn">O(\sqrt n)</code>
</p>
</li>
<li><p> Reduction of <a href="https://en.wikipedia.org/wiki/CPU_cache#Cache_miss">cache misses</a>
</p>
</li></ol>

<p>The latter is of particular importance as cache memory is much more efficient and closer in proximity to the CPU than <a href="https://en.wikipedia.org/wiki/Computer_data_storage#Primary_storage">main memory</a>. Reducing the size of the sieving interval allows for more effective utilization of the cache, which greatly impacts the overall efficiency.
</p>
<p>Another optimization over the traditional sieve is the utilization of wheel factorization. With the traditional sieve of Eratosthenes, you typically check every odd index of your logical vector and if the value is true, you have found a prime. With wheel factorization using the first four primes (i.e. 2, 3, 5, and 7) to construct your wheel (i.e. 210 wheel), you only have to check indices of your logical vector that are coprime to 210 (i.e. the product of the first four primes). As an example, with <code class="reqn">n = 10000</code> and a 210 wheel, you only have to check 2285 indices vs. 5000 with the classical implementation.
</p>


<h3>Value</h3>

<p>Returns an integer vector if <code>max(bound1, bound2)</code> <code class="reqn">&lt; 2^{31}</code>, or a numeric vector otherwise.
</p>


<h3>Note</h3>


<ul>
<li><p>It does not matter which bound is larger as the resulting primes will be between <code>min(bound1, bound2)</code> and <code>max(bound1, bound2)</code> if <code>bound2</code> is provided.
</p>
</li>
<li><p>The maximum value for either of the bounds is <code class="reqn">2^{53} - 1</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Joseph Wood
</p>


<h3>References</h3>


<ul>
<li><p><a href="https://github.com/kimwalisch/primesieve">primesieve (Fast C/C++ prime number generator)</a>
</p>
</li>
<li><p><a href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes">Sieve of Eratosthenes</a>
</p>
</li>
<li><p><a href="https://en.wikipedia.org/wiki/Wheel_factorization">Wheel factorization</a>
</p>
</li>
<li><p><a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format">53-bit significand precision</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Primes up to a thousand
primeSieve(100)

## Primes between 42 and 17
primeSieve(42, 17)

## Equivalent to
primeSieve(17, 42)

## Primes up to one hundred million in no time
system.time(primeSieve(10^8))

## options(scipen = 50)
## Generate large primes over interval
system.time(myPs &lt;- primeSieve(10^13+10^6, 10^13))
## Object created is small
object.size(myPs)

## Using nThreads
system.time(primeSieve(1e7, nThreads = 2))
</code></pre>

<hr>
<h2 id='stdThreadMax'>
Max Number of Concurrent Threads
</h2><span id='topic+stdThreadMax'></span>

<h3>Description</h3>

<p>Wrapper of <a href="https://en.cppreference.com/w/cpp/thread/thread/hardware_concurrency">std::thread::hardware_concurrency()</a>. As stated by <a href="https://en.cppreference.com/w/">cppreference</a>, the returned value should be considered only a hint.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stdThreadMax()
</code></pre>


<h3>Value</h3>

<p>An integer representing the number of concurrent threads supported by the user implementation. If the value cannot be determined, <code>1L</code> is returned.
</p>


<h3>See Also</h3>

<p><code><a href="parallel.html#topic+detectCores">detectCores</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stdThreadMax()
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
