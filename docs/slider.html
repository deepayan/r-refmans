<!DOCTYPE html><html><head><title>Help for package slider</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {slider}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#block'><p>Break a vector into blocks</p></a></li>
<li><a href='#hop'><p>Hop</p></a></li>
<li><a href='#hop_index'><p>Hop relative to an index</p></a></li>
<li><a href='#hop_index2'><p>Hop along multiple inputs simultaneously relative to an index</p></a></li>
<li><a href='#hop2'><p>Hop along multiple inputs simultaneously</p></a></li>
<li><a href='#index-arithmetic'><p>Index arithmetic</p></a></li>
<li><a href='#slide'><p>Slide</p></a></li>
<li><a href='#slide_index'><p>Slide relative to an index</p></a></li>
<li><a href='#slide_index2'><p>Slide along multiples inputs simultaneously relative to an index</p></a></li>
<li><a href='#slide_period'><p>Slide relative to an index chunked by period</p></a></li>
<li><a href='#slide_period2'><p>Slide along multiple inputs simultaneously relative to an index chunked by period</p></a></li>
<li><a href='#slide2'><p>Slide over multiple inputs simultaneously</p></a></li>
<li><a href='#slider-package'><p>slider: Sliding Window Functions</p></a></li>
<li><a href='#summary-index'><p>Specialized sliding functions relative to an index</p></a></li>
<li><a href='#summary-slide'><p>Specialized sliding functions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Sliding Window Functions</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides type-stable rolling window functions over any R data
    type. Cumulative and expanding windows are also supported. For more
    advanced usage, an index can be used as a secondary vector that
    defines how sliding windows are to be created.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/r-lib/slider">https://github.com/r-lib/slider</a>, <a href="https://slider.r-lib.org">https://slider.r-lib.org</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/r-lib/slider/issues">https://github.com/r-lib/slider/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli (&ge; 3.6.1), rlang (&ge; 1.1.1), vctrs (&ge; 0.6.3), warp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, dplyr (&ge; 1.0.0), knitr, lubridate, rmarkdown, testthat
(&ge; 3.0.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>vctrs (&ge; 0.6.3)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>tidyverse/tidytemplate</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Collate:</td>
<td>'arithmetic.R' 'block.R' 'conditions.R' 'hop-common.R'
'hop-index-common.R' 'hop-index.R' 'hop-index2.R' 'hop.R'
'hop2.R' 'phop-index.R' 'phop.R' 'slide-index2.R'
'pslide-index.R' 'slide-period2.R' 'pslide-period.R' 'slide2.R'
'pslide.R' 'segment-tree.R' 'slide-common.R'
'slide-index-common.R' 'slide-index.R' 'slide-period-common.R'
'slide-period.R' 'slide.R' 'slider-package.R' 'summary-index.R'
'summary-slide.R' 'utils.R' 'zzz.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-12 14:30:46 UTC; davis</td>
</tr>
<tr>
<td>Author:</td>
<td>Davis Vaughan [aut, cre],
  Posit Software, PBC [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Davis Vaughan &lt;davis@posit.co&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-12 15:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='block'>Break a vector into blocks</h2><span id='topic+block'></span>

<h3>Description</h3>

<p><code>block()</code> breaks up the <code>i</code>-ndex by <code>period</code>, and then uses that to define
the indices to chop <code>x</code> with.
</p>
<p>For example, it can split <code>x</code> into monthly or yearly blocks. Combined with
<code>purrr::map()</code>, it is a way to iterate over a vector in &quot;time blocks&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>block(x, i, period, every = 1L, origin = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="block_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[vector]&#8288;</code>
</p>
<p>The vector to block.</p>
</td></tr>
<tr><td><code id="block_+3A_i">i</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[Date / POSIXct / POSIXlt]&#8288;</code>
</p>
<p>The datetime index to block by.
</p>
<p>There are 3 restrictions on the index:
</p>

<ul>
<li><p> The size of the index must match the size of <code>x</code>, they will not be
recycled to their common size.
</p>
</li>
<li><p> The index must be an <em>increasing</em> vector, but duplicate values
are allowed.
</p>
</li>
<li><p> The index cannot have missing values.
</p>
</li></ul>
</td></tr>
<tr><td><code id="block_+3A_period">period</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character(1)]&#8288;</code>
</p>
<p>A string defining the period to group by. Valid inputs can be roughly
broken into:
</p>

<ul>
<li> <p><code>"year"</code>, <code>"quarter"</code>, <code>"month"</code>, <code>"week"</code>, <code>"day"</code>
</p>
</li>
<li> <p><code>"hour"</code>, <code>"minute"</code>, <code>"second"</code>, <code>"millisecond"</code>
</p>
</li>
<li> <p><code>"yweek"</code>, <code>"mweek"</code>
</p>
</li>
<li> <p><code>"yday"</code>, <code>"mday"</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="block_+3A_every">every</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[positive integer(1)]&#8288;</code>
</p>
<p>The number of periods to group together.
</p>
<p>For example, if the period was set to <code>"year"</code> with an every value of <code>2</code>,
then the years 1970 and 1971 would be placed in the same group.</p>
</td></tr>
<tr><td><code id="block_+3A_origin">origin</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[Date(1) / POSIXct(1) / POSIXlt(1) / NULL]&#8288;</code>
</p>
<p>The reference date time value. The default when left as <code>NULL</code> is the
epoch time of <code style="white-space: pre;">&#8288;1970-01-01 00:00:00&#8288;</code>, <em>in the time zone of the index</em>.
</p>
<p>This is generally used to define the anchor time to count from, which is
relevant when the every value is <code style="white-space: pre;">&#8288;&gt; 1&#8288;</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>block()</code> determines the indices to block by with <code><a href="warp.html#topic+warp_boundary">warp::warp_boundary()</a></code>,
and splits <code>x</code> by those indices using <code><a href="vctrs.html#topic+vec_chop">vctrs::vec_chop()</a></code>.
</p>
<p>Like <code><a href="#topic+slide">slide()</a></code>, <code>block()</code> splits data frame <code>x</code> values row wise.
</p>


<h3>Value</h3>

<p>A vector fulfilling the following invariants:
</p>

<ul>
<li> <p><code>vec_size(block(x)) == vec_size(unique(warp::warp_boundary(i)))</code>
</p>
</li>
<li> <p><code>vec_ptype(block(x)) == list()</code>
</p>
</li>
<li> <p><code>vec_ptype(block(x)[[1]]) == vec_ptype(x)</code>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+slide_period">slide_period()</a></code>, <code><a href="#topic+slide">slide()</a></code>, <code><a href="#topic+slide_index">slide_index()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:6
i &lt;- as.Date("2019-01-01") + c(-2:2, 31)

block(i, i, period = "year")

# Data frames are split row wise
df &lt;- data.frame(x = x, i = i)
block(df, i, period = "month")

# Iterate over these blocks to apply a function over
# non-overlapping period blocks. For example, to compute a
# mean over yearly or monthly blocks.
vapply(block(x, i, "year"), mean, numeric(1))
vapply(block(x, i, "month"), mean, numeric(1))

# block by every 2 months, ensuring that we start counting
# the 1st of the 2 months from `2019-01-01`
block(i, i, period = "month", every = 2, origin = as.Date("2019-01-01"))

# Use the `origin` to instead start counting from `2018-12-01`, meaning
# that [2018-12, 2019-01] gets bucketed together.
block(i, i, period = "month", every = 2, origin = as.Date("2018-12-01"))

</code></pre>

<hr>
<h2 id='hop'>Hop</h2><span id='topic+hop'></span><span id='topic+hop_vec'></span>

<h3>Description</h3>

<p><code>hop()</code> is the lower level engine that powers <code><a href="#topic+slide">slide()</a></code> (at least in theory).
It has slightly different invariants than <code>slide()</code>, and is useful
when you either need to hand craft boundary locations, or want to compute a
result with a size that is different from <code>.x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hop(.x, .starts, .stops, .f, ...)

hop_vec(.x, .starts, .stops, .f, ..., .ptype = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hop_+3A_.x">.x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[vector]&#8288;</code>
</p>
<p>The vector to iterate over and apply <code>.f</code> to.</p>
</td></tr>
<tr><td><code id="hop_+3A_.starts">.starts</code>, <code id="hop_+3A_.stops">.stops</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integer]&#8288;</code>
</p>
<p>Vectors of boundary locations that make up the windows to bucket <code>.x</code> with.
Both <code>.starts</code> and <code>.stops</code> will be recycled to their common size, and
that common size will be the size of the result. Both vectors should be
integer locations along <code>.x</code>, but out-of-bounds values are allowed.</p>
</td></tr>
<tr><td><code id="hop_+3A_.f">.f</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[function / formula]&#8288;</code>
</p>
<p>If a <strong>function</strong>, it is used as is.
</p>
<p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function. There
are three ways to refer to the arguments:
</p>

<ul>
<li><p> For a single argument function, use <code>.</code>
</p>
</li>
<li><p> For a two argument function, use <code>.x</code> and <code>.y</code>
</p>
</li>
<li><p> For more arguments, use <code>..1</code>, <code>..2</code>, <code>..3</code> etc
</p>
</li></ul>

<p>This syntax allows you to create very compact anonymous functions.</p>
</td></tr>
<tr><td><code id="hop_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to the mapped function.</p>
</td></tr>
<tr><td><code id="hop_+3A_.ptype">.ptype</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[vector(0) / NULL]&#8288;</code>
</p>
<p>A prototype corresponding to the type of the output.
</p>
<p>If <code>NULL</code>, the default, the output type is determined by computing the
common type across the results of the calls to <code>.f</code>.
</p>
<p>If supplied, the result of each call to <code>.f</code> will be cast to that type,
and the final output will have that type.
</p>
<p>If <code>getOption("vctrs.no_guessing")</code> is <code>TRUE</code>, the <code>.ptype</code> must be
supplied. This is a way to make production code demand fixed types.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>hop()</code> is very close to being a faster version of:
</p>
<div class="sourceCode"><pre>map2(
  .starts,
  .stops,
  function(start, stop) {
    x_slice &lt;- vec_slice(.x, start:stop)
    .f(x_slice, ...)
  }
)
</pre></div>
<p>Because of this, <code><a href="#topic+hop_index">hop_index()</a></code> is often the more useful function. <code>hop()</code>
mainly exists for API completeness.
</p>
<p>The main difference is that the start and stop values make up ranges of
<em>possible</em> locations along <code>.x</code>, and it is not enforced that these locations
actually exist along <code>.x</code>. As an example, with <code>hop()</code> you can do the
following, which would be an error with <code>vec_slice()</code> because <code>0L</code> is
out of bounds.
</p>
<div class="sourceCode"><pre>hop(c("a", "b"), .starts = 0L, .stops = 1L, ~.x)
#&gt; [[1]]
#&gt; [1] "a"
</pre></div>
<p><code>hop()</code> allows these out of bounds values to be fully compatible with
<code>slide()</code>. It is always possible to construct a <code>hop()</code> call from a <code>slide()</code>
call. For example, the following are equivalent:
</p>
<div class="sourceCode"><pre>slide(1:2, ~.x, .before = 1)

hop(1:2, .starts = c(0, 1), .stops = c(1, 2), ~.x)

#&gt; [[1]]
#&gt; [1] 1
#&gt;
#&gt; [[2]]
#&gt; [1] 1 2
</pre></div>


<h3>Value</h3>

<p>A vector fulfilling the following invariants:
</p>


<h4><code>hop()</code></h4>


<ul>
<li> <p><code>vec_size(hop(.x, .starts, .stops)) == vec_size_common(.starts, .stops)</code>
</p>
</li>
<li> <p><code>vec_ptype(hop(.x, .starts, .stops)) == list()</code>
</p>
</li></ul>




<h4><code>hop_vec()</code></h4>


<ul>
<li> <p><code>vec_size(hop_vec(.x, .starts, .stops)) == vec_size_common(.starts, .stops)</code>
</p>
</li>
<li> <p><code>vec_size(hop_vec(.x, .starts, .stops)[[1]]) == 1L</code>
</p>
</li>
<li> <p><code>vec_ptype(hop_vec(.x, .starts, .stops, .ptype = ptype)) == ptype</code>
</p>
</li></ul>




<h3>See Also</h3>

<p><code><a href="#topic+hop2">hop2()</a></code>, <code><a href="#topic+hop_index">hop_index()</a></code>, <code><a href="#topic+slide">slide()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># `hop()` let's you manually specify locations to apply `.f` at.
hop(1:3, .starts = c(1, 3), .stops = 3, ~.x)

# `hop()`'s start/stop locations are allowed to be out of bounds relative
# to the size of `.x`.
hop(
  mtcars,
  .starts = c(-1, 3),
  .stops  = c(2, 6),
  ~.x
)

</code></pre>

<hr>
<h2 id='hop_index'>Hop relative to an index</h2><span id='topic+hop_index'></span><span id='topic+hop_index_vec'></span>

<h3>Description</h3>

<p><code>hop_index()</code> is the lower level engine that powers <code><a href="#topic+slide_index">slide_index()</a></code>. It
has slightly different invariants than <code>slide_index()</code>, and is useful when
you either need to hand craft boundary values, or want to compute a result
with a size that is different from <code>.x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hop_index(.x, .i, .starts, .stops, .f, ...)

hop_index_vec(.x, .i, .starts, .stops, .f, ..., .ptype = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hop_index_+3A_.x">.x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[vector]&#8288;</code>
</p>
<p>The vector to iterate over and apply <code>.f</code> to.</p>
</td></tr>
<tr><td><code id="hop_index_+3A_.i">.i</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[vector]&#8288;</code>
</p>
<p>The index vector that determines the window sizes. It is fairly common to
supply a date vector as the index, but not required.
</p>
<p>There are 3 restrictions on the index:
</p>

<ul>
<li><p> The size of the index must match the size of <code>.x</code>, they will not be
recycled to their common size.
</p>
</li>
<li><p> The index must be an <em>increasing</em> vector, but duplicate values
are allowed.
</p>
</li>
<li><p> The index cannot have missing values.
</p>
</li></ul>
</td></tr>
<tr><td><code id="hop_index_+3A_.starts">.starts</code>, <code id="hop_index_+3A_.stops">.stops</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[vector]&#8288;</code>
</p>
<p>Vectors of boundary values that make up the windows to bucket <code>.i</code> with.
Both <code>.starts</code> and <code>.stops</code> will be recycled to their common size, and
that common size will be the size of the result. Both vectors should be
the same type as <code>.i</code>. These boundaries are both <em>inclusive</em>, meaning
that the slice of <code>.x</code> that will be used in each call to <code>.f</code> is where
<code>.i &gt;= start &amp; .i &lt;= stop</code> returns <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="hop_index_+3A_.f">.f</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[function / formula]&#8288;</code>
</p>
<p>If a <strong>function</strong>, it is used as is.
</p>
<p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function. There
are three ways to refer to the arguments:
</p>

<ul>
<li><p> For a single argument function, use <code>.</code>
</p>
</li>
<li><p> For a two argument function, use <code>.x</code> and <code>.y</code>
</p>
</li>
<li><p> For more arguments, use <code>..1</code>, <code>..2</code>, <code>..3</code> etc
</p>
</li></ul>

<p>This syntax allows you to create very compact anonymous functions.</p>
</td></tr>
<tr><td><code id="hop_index_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to the mapped function.</p>
</td></tr>
<tr><td><code id="hop_index_+3A_.ptype">.ptype</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[vector(0) / NULL]&#8288;</code>
</p>
<p>A prototype corresponding to the type of the output.
</p>
<p>If <code>NULL</code>, the default, the output type is determined by computing the
common type across the results of the calls to <code>.f</code>.
</p>
<p>If supplied, the result of each call to <code>.f</code> will be cast to that type,
and the final output will have that type.
</p>
<p>If <code>getOption("vctrs.no_guessing")</code> is <code>TRUE</code>, the <code>.ptype</code> must be
supplied. This is a way to make production code demand fixed types.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector fulfilling the following invariants:
</p>


<h4><code>hop_index()</code></h4>


<ul>
<li> <p><code>vec_size(hop_index(.x, .starts, .stops)) == vec_size_common(.starts, .stops)</code>
</p>
</li>
<li> <p><code>vec_ptype(hop_index(.x, .starts, .stops)) == list()</code>
</p>
</li></ul>




<h4><code>hop_index_vec()</code></h4>


<ul>
<li> <p><code>vec_size(hop_index_vec(.x, .starts, .stops)) == vec_size_common(.starts, .stops)</code>
</p>
</li>
<li> <p><code>vec_size(hop_index_vec(.x, .starts, .stops)[[1]]) == 1L</code>
</p>
</li>
<li> <p><code>vec_ptype(hop_index_vec(.x, .starts, .stops, .ptype = ptype)) == ptype</code>
</p>
</li></ul>




<h3>See Also</h3>

<p><code><a href="#topic+slide">slide()</a></code>, <code><a href="#topic+slide_index">slide_index()</a></code>, <code><a href="#topic+hop_index2">hop_index2()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(vctrs)
library(lubridate, warn.conflicts = FALSE)

# ---------------------------------------------------------------------------
# Returning a size smaller than `.x`

i &lt;- as.Date("2019-01-25") + c(0, 1, 2, 3, 10, 20, 35, 42, 45)

# slide_index() allows you to slide relative to `i`
slide_index(i, i, ~.x, .before = weeks(1))

# But you might be more interested in coarser summaries. This groups
# by year-month and computes 2 `.f` on 2 month windows.
i_yearmonth &lt;- year(i) + (month(i) - 1) / 12
slide_index(i, i_yearmonth, ~.x, .before = 1)

# ^ This works nicely when working with dplyr if you are trying to create
# a new column in a data frame, but you'll notice that there are really only
# 3 months, so only 3 values are being calculated. If you only want to return
# a vector of those 3 values, you can use `hop_index()`. You'll have to
# hand craft the boundaries, but this is a general strategy
# I've found useful:
first_start &lt;- floor_date(i[1], "months")
last_stop &lt;- ceiling_date(i[length(i)], "months")
dates &lt;- seq(first_start, last_stop, "1 month")
inner &lt;- dates[2:(length(dates) - 1L)]
starts &lt;- vec_c(first_start, inner)
stops &lt;- vec_c(inner - 1, last_stop)

hop_index(i, i, starts, stops, ~.x)

# ---------------------------------------------------------------------------
# Non-existant dates with `lubridate::months()`

# Imagine you want to compute a 1 month rolling average on this
# irregular daily data.
i &lt;- vec_c(as.Date("2019-02-27") + 0:3, as.Date("2019-03-27") + 0:5)
x &lt;- rnorm(vec_seq_along(i))

# You might try `slide_index()` like this, but you'd run into this error
library(rlang)

with_options(
  catch_cnd(
    slide_index(x, i, mean, .before = months(1))
  ),
  rlang_backtrace_on_error = current_env()
)

# This is because when you actually compute the `.i - .before` sequence,
# you hit non-existant dates. i.e. `"2019-03-29" - months(1)` doesn't exist.
i - months(1)

# To get around this, lubridate provides `add_with_rollback()`,
# and the shortcut operation `%m-%`, which subtracts the month, then rolls
# forward/backward if it hits an `NA`. You can manually generate boundaries,
# then provide them to `hop_index()`.
starts &lt;- i %m-% months(1)
stops &lt;- i

hop_index(x, i, starts, stops, mean)

hop_index(i, i, starts, stops, ~.x)

</code></pre>

<hr>
<h2 id='hop_index2'>Hop along multiple inputs simultaneously relative to an index</h2><span id='topic+hop_index2'></span><span id='topic+hop_index2_vec'></span><span id='topic+phop_index'></span><span id='topic+phop_index_vec'></span>

<h3>Description</h3>

<p><code>hop_index2()</code> and <code>phop_index()</code> represent the combination
of <code><a href="#topic+slide2">slide2()</a></code> and <code><a href="#topic+pslide">pslide()</a></code> with <code><a href="#topic+hop_index">hop_index()</a></code>, allowing you to iterate
over multiple vectors at once, relative to an <code>.i</code>-ndex with
boundaries defined by <code>.starts</code> and <code>.stops</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hop_index2(.x, .y, .i, .starts, .stops, .f, ...)

hop_index2_vec(.x, .y, .i, .starts, .stops, .f, ..., .ptype = NULL)

phop_index(.l, .i, .starts, .stops, .f, ...)

phop_index_vec(.l, .i, .starts, .stops, .f, ..., .ptype = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hop_index2_+3A_.x">.x</code>, <code id="hop_index2_+3A_.y">.y</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[vector]&#8288;</code>
</p>
<p>Vectors to iterate over. Vectors of size 1 will be recycled.</p>
</td></tr>
<tr><td><code id="hop_index2_+3A_.i">.i</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[vector]&#8288;</code>
</p>
<p>The index vector that determines the window sizes. It is fairly common to
supply a date vector as the index, but not required.
</p>
<p>There are 3 restrictions on the index:
</p>

<ul>
<li><p> The size of the index must match the size of <code>.x</code>, they will not be
recycled to their common size.
</p>
</li>
<li><p> The index must be an <em>increasing</em> vector, but duplicate values
are allowed.
</p>
</li>
<li><p> The index cannot have missing values.
</p>
</li></ul>
</td></tr>
<tr><td><code id="hop_index2_+3A_.starts">.starts</code>, <code id="hop_index2_+3A_.stops">.stops</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[vector]&#8288;</code>
</p>
<p>Vectors of boundary values that make up the windows to bucket <code>.i</code> with.
Both <code>.starts</code> and <code>.stops</code> will be recycled to their common size, and
that common size will be the size of the result. Both vectors should be
the same type as <code>.i</code>. These boundaries are both <em>inclusive</em>, meaning
that the slice of <code>.x</code> that will be used in each call to <code>.f</code> is where
<code>.i &gt;= start &amp; .i &lt;= stop</code> returns <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="hop_index2_+3A_.f">.f</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[function / formula]&#8288;</code>
</p>
<p>If a <strong>function</strong>, it is used as is.
</p>
<p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function. There
are three ways to refer to the arguments:
</p>

<ul>
<li><p> For a single argument function, use <code>.</code>
</p>
</li>
<li><p> For a two argument function, use <code>.x</code> and <code>.y</code>
</p>
</li>
<li><p> For more arguments, use <code>..1</code>, <code>..2</code>, <code>..3</code> etc
</p>
</li></ul>

<p>This syntax allows you to create very compact anonymous functions.</p>
</td></tr>
<tr><td><code id="hop_index2_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to the mapped function.</p>
</td></tr>
<tr><td><code id="hop_index2_+3A_.ptype">.ptype</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[vector(0) / NULL]&#8288;</code>
</p>
<p>A prototype corresponding to the type of the output.
</p>
<p>If <code>NULL</code>, the default, the output type is determined by computing the
common type across the results of the calls to <code>.f</code>.
</p>
<p>If supplied, the result of each call to <code>.f</code> will be cast to that type,
and the final output will have that type.
</p>
<p>If <code>getOption("vctrs.no_guessing")</code> is <code>TRUE</code>, the <code>.ptype</code> must be
supplied. This is a way to make production code demand fixed types.</p>
</td></tr>
<tr><td><code id="hop_index2_+3A_.l">.l</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[list]&#8288;</code>
</p>
<p>A list of vectors. The length of <code>.l</code> determines the
number of arguments that <code>.f</code> will be called with. If <code>.l</code> has names,
they will be used as named arguments to <code>.f</code>. Elements of <code>.l</code> with size
1 will be recycled.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector fulfilling the following invariants:
</p>


<h4><code>hop_index2()</code></h4>


<ul>
<li> <p><code>vec_size(hop_index2(.x, .y, .starts, .stops)) == vec_size_common(.starts, .stops)</code>
</p>
</li>
<li> <p><code>vec_ptype(hop_index2(.x, .y, .starts, .stops)) == list()</code>
</p>
</li></ul>




<h4><code>hop_index2_vec()</code></h4>


<ul>
<li> <p><code>vec_size(hop_index2_vec(.x, .y, .starts, .stops)) == vec_size_common(.starts, .stops)</code>
</p>
</li>
<li> <p><code>vec_size(hop_index2_vec(.x, .y, .starts, .stops)[[1]]) == 1L</code>
</p>
</li>
<li> <p><code>vec_ptype(hop_index2_vec(.x, .y, .starts, .stops, .ptype = ptype)) == ptype</code>
</p>
</li></ul>




<h4><code>phop_index()</code></h4>


<ul>
<li> <p><code>vec_size(phop_index(.l, .starts, .stops)) == vec_size_common(.starts, .stops)</code>
</p>
</li>
<li> <p><code>vec_ptype(phop_index(.l, .starts, .stops)) == list()</code>
</p>
</li></ul>




<h4><code>phop_index_vec()</code></h4>


<ul>
<li> <p><code>vec_size(phop_index_vec(.l, .starts, .stops)) == vec_size_common(.starts, .stops)</code>
</p>
</li>
<li> <p><code>vec_size(phop_index_vec(.l, .starts, .stops)[[1]]) == 1L</code>
</p>
</li>
<li> <p><code>vec_ptype(phop_index_vec(.l, .starts, .stops, .ptype = ptype)) == ptype</code>
</p>
</li></ul>




<h3>See Also</h3>

<p><code><a href="#topic+slide2">slide2()</a></code>, <code><a href="#topic+slide_index2">slide_index2()</a></code>, <code><a href="#topic+hop_index">hop_index()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Notice that `i` is an irregular index!
x &lt;- 1:5
i &lt;- as.Date("2019-08-15") + c(0:1, 4, 6, 7)

# Manually create starts/stops. They don't have to be equally spaced,
# and they don't have to be the same size as `.x` or `.i`.
starts &lt;- as.Date(c("2019-08-15", "2019-08-18"))
stops &lt;- as.Date(c("2019-08-16", "2019-08-23"))

# The output size is equal to the common size of `.starts` and `.stops`
hop_index2(x, i, i, starts, stops, ~data.frame(x = .x, y = .y))

</code></pre>

<hr>
<h2 id='hop2'>Hop along multiple inputs simultaneously</h2><span id='topic+hop2'></span><span id='topic+hop2_vec'></span><span id='topic+phop'></span><span id='topic+phop_vec'></span>

<h3>Description</h3>

<p><code>hop2()</code> and <code>phop()</code> represent the combination
of <code><a href="#topic+slide2">slide2()</a></code> and <code><a href="#topic+pslide">pslide()</a></code> with <code><a href="#topic+hop">hop()</a></code>, allowing you to iterate
over multiple vectors at once, hopping along them using boundaries defined
by <code>.starts</code> and <code>.stops</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hop2(.x, .y, .starts, .stops, .f, ...)

hop2_vec(.x, .y, .starts, .stops, .f, ..., .ptype = NULL)

phop(.l, .starts, .stops, .f, ...)

phop_vec(.l, .starts, .stops, .f, ..., .ptype = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hop2_+3A_.x">.x</code>, <code id="hop2_+3A_.y">.y</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[vector]&#8288;</code>
</p>
<p>Vectors to iterate over. Vectors of size 1 will be recycled.</p>
</td></tr>
<tr><td><code id="hop2_+3A_.starts">.starts</code>, <code id="hop2_+3A_.stops">.stops</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integer]&#8288;</code>
</p>
<p>Vectors of boundary locations that make up the windows to bucket <code>.x</code> with.
Both <code>.starts</code> and <code>.stops</code> will be recycled to their common size, and
that common size will be the size of the result. Both vectors should be
integer locations along <code>.x</code>, but out-of-bounds values are allowed.</p>
</td></tr>
<tr><td><code id="hop2_+3A_.f">.f</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[function / formula]&#8288;</code>
</p>
<p>If a <strong>function</strong>, it is used as is.
</p>
<p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function. There
are three ways to refer to the arguments:
</p>

<ul>
<li><p> For a single argument function, use <code>.</code>
</p>
</li>
<li><p> For a two argument function, use <code>.x</code> and <code>.y</code>
</p>
</li>
<li><p> For more arguments, use <code>..1</code>, <code>..2</code>, <code>..3</code> etc
</p>
</li></ul>

<p>This syntax allows you to create very compact anonymous functions.</p>
</td></tr>
<tr><td><code id="hop2_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to the mapped function.</p>
</td></tr>
<tr><td><code id="hop2_+3A_.ptype">.ptype</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[vector(0) / NULL]&#8288;</code>
</p>
<p>A prototype corresponding to the type of the output.
</p>
<p>If <code>NULL</code>, the default, the output type is determined by computing the
common type across the results of the calls to <code>.f</code>.
</p>
<p>If supplied, the result of each call to <code>.f</code> will be cast to that type,
and the final output will have that type.
</p>
<p>If <code>getOption("vctrs.no_guessing")</code> is <code>TRUE</code>, the <code>.ptype</code> must be
supplied. This is a way to make production code demand fixed types.</p>
</td></tr>
<tr><td><code id="hop2_+3A_.l">.l</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[list]&#8288;</code>
</p>
<p>A list of vectors. The length of <code>.l</code> determines the
number of arguments that <code>.f</code> will be called with. If <code>.l</code> has names,
they will be used as named arguments to <code>.f</code>. Elements of <code>.l</code> with size
1 will be recycled.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector fulfilling the following invariants:
</p>


<h4><code>hop2()</code></h4>


<ul>
<li> <p><code>vec_size(hop2(.x, .y, .starts, .stops)) == vec_size_common(.starts, .stops)</code>
</p>
</li>
<li> <p><code>vec_ptype(hop2(.x, .y, .starts, .stops)) == list()</code>
</p>
</li></ul>




<h4><code>hop2_vec()</code></h4>


<ul>
<li> <p><code>vec_size(hop2_vec(.x, .y, .starts, .stops)) == vec_size_common(.starts, .stops)</code>
</p>
</li>
<li> <p><code>vec_size(hop2_vec(.x, .y, .starts, .stops)[[1]]) == 1L</code>
</p>
</li>
<li> <p><code>vec_ptype(hop2_vec(.x, .y, .starts, .stops, .ptype = ptype)) == ptype</code>
</p>
</li></ul>




<h4><code>phop()</code></h4>


<ul>
<li> <p><code>vec_size(phop(.l, .starts, .stops)) == vec_size_common(.starts, .stops)</code>
</p>
</li>
<li> <p><code>vec_ptype(phop(.l, .starts, .stops)) == list()</code>
</p>
</li></ul>




<h4><code>phop_vec()</code></h4>


<ul>
<li> <p><code>vec_size(phop_vec(.l, .starts, .stops)) == vec_size_common(.starts, .stops)</code>
</p>
</li>
<li> <p><code>vec_size(phop_vec(.l, .starts, .stops)[[1]]) == 1L</code>
</p>
</li>
<li> <p><code>vec_ptype(phop_vec(.l, .starts, .stops, .ptype = ptype)) == ptype</code>
</p>
</li></ul>




<h3>See Also</h3>

<p><code><a href="#topic+hop">hop()</a></code>, <code><a href="#topic+hop_index">hop_index()</a></code>, <code><a href="#topic+slide2">slide2()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hop2(1:2, 3:4, .starts = 1, .stops = c(2, 1), ~c(x = .x, y = .y))

phop(
 list(1, 2:4, 5:7),
 .starts = c(0, 1),
 .stops  = c(2, 4),
 ~c(x = ..1, y = ..2, z = ..3)
)

</code></pre>

<hr>
<h2 id='index-arithmetic'>Index arithmetic</h2><span id='topic+index-arithmetic'></span><span id='topic+slider_plus'></span><span id='topic+slider_minus'></span>

<h3>Description</h3>

<p><code>slider_plus()</code> and <code>slider_minus()</code> are developer functions used to register
special double dispatch methods to control how <code>.before</code> and <code>.after</code> are
subtracted from and added to <code>.i</code>. These allow developers to overcome some of
the restrictions around <code>+</code> and <code>-</code> when custom S3 types are involved. These
should only be used by package authors creating new index types.
</p>

<ul>
<li> <p><code>slider_plus()</code> allows you to override the default behavior of
<code>.i + .after</code>. When writing the S3 method, <code>x</code> will be <code>.i</code>, and <code>y</code> will
be <code>.after</code>.
</p>
</li>
<li> <p><code>slider_minus()</code> allows you to override the default behavior of
<code>.i - .before</code>. When writing the S3 method, <code>x</code> will be <code>.i</code>, and <code>y</code> will
be <code>.before</code>.
</p>
</li></ul>

<p>These generics are a bit special. They work similarly to
<code><a href="vctrs.html#topic+vec_ptype2">vctrs::vec_ptype2()</a></code> in that they are <em>double dispatch</em> methods that
dispatch off the types of both <code>x</code> and <code>y</code>. To write an S3 method for these
generics, write and export an S3 method of the form:
</p>
<div class="sourceCode"><pre>slider_plus.x_class.y_class &lt;- function(x, y) {
  # My method
}
</pre></div>
<p>Inheritance is not considered in the method lookup, and you cannot use
<code>NextMethod()</code> from within your method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slider_plus(x, y)

slider_minus(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="index-arithmetic_+3A_x">x</code>, <code id="index-arithmetic_+3A_y">y</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[vector]&#8288;</code>
</p>
<p>Two vectors to add or subtract.
</p>
<p><code>x</code> will always be the index, <code>.i</code>.
</p>
<p>For <code>slider_plus()</code>, <code>y</code> will be <code>.after</code>.
</p>
<p>For <code>slider_minus()</code>, <code>y</code> will be <code>.before</code>.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p> For <code>slider_plus()</code>, <code>x</code> after adding <code>y</code>.
</p>
</li>
<li><p> For <code>slider_minus()</code>, <code>x</code> after subtracting <code>y</code>.
</p>
</li></ul>

<p>The result should always be the same type and size as <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>slider_plus(1, 2)
slider_minus(1, 2)
</code></pre>

<hr>
<h2 id='slide'>Slide</h2><span id='topic+slide'></span><span id='topic+slide_vec'></span><span id='topic+slide_dbl'></span><span id='topic+slide_int'></span><span id='topic+slide_lgl'></span><span id='topic+slide_chr'></span><span id='topic+slide_dfr'></span><span id='topic+slide_dfc'></span>

<h3>Description</h3>

<p><code>slide()</code> iterates through <code>.x</code> using a sliding window, applying <code>.f</code> to each
sub-window of <code>.x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slide(.x, .f, ..., .before = 0L, .after = 0L, .step = 1L, .complete = FALSE)

slide_vec(
  .x,
  .f,
  ...,
  .before = 0L,
  .after = 0L,
  .step = 1L,
  .complete = FALSE,
  .ptype = NULL
)

slide_dbl(
  .x,
  .f,
  ...,
  .before = 0L,
  .after = 0L,
  .step = 1L,
  .complete = FALSE
)

slide_int(
  .x,
  .f,
  ...,
  .before = 0L,
  .after = 0L,
  .step = 1L,
  .complete = FALSE
)

slide_lgl(
  .x,
  .f,
  ...,
  .before = 0L,
  .after = 0L,
  .step = 1L,
  .complete = FALSE
)

slide_chr(
  .x,
  .f,
  ...,
  .before = 0L,
  .after = 0L,
  .step = 1L,
  .complete = FALSE
)

slide_dfr(
  .x,
  .f,
  ...,
  .before = 0L,
  .after = 0L,
  .step = 1L,
  .complete = FALSE,
  .names_to = rlang::zap(),
  .name_repair = c("unique", "universal", "check_unique")
)

slide_dfc(
  .x,
  .f,
  ...,
  .before = 0L,
  .after = 0L,
  .step = 1L,
  .complete = FALSE,
  .size = NULL,
  .name_repair = c("unique", "universal", "check_unique", "minimal")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slide_+3A_.x">.x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[vector]&#8288;</code>
</p>
<p>The vector to iterate over and apply <code>.f</code> to.</p>
</td></tr>
<tr><td><code id="slide_+3A_.f">.f</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[function / formula]&#8288;</code>
</p>
<p>If a <strong>function</strong>, it is used as is.
</p>
<p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function. There
are three ways to refer to the arguments:
</p>

<ul>
<li><p> For a single argument function, use <code>.</code>
</p>
</li>
<li><p> For a two argument function, use <code>.x</code> and <code>.y</code>
</p>
</li>
<li><p> For more arguments, use <code>..1</code>, <code>..2</code>, <code>..3</code> etc
</p>
</li></ul>

<p>This syntax allows you to create very compact anonymous functions.</p>
</td></tr>
<tr><td><code id="slide_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to the mapped function.</p>
</td></tr>
<tr><td><code id="slide_+3A_.before">.before</code>, <code id="slide_+3A_.after">.after</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integer(1) / Inf]&#8288;</code>
</p>
<p>The number of values before or after the current element to
include in the sliding window. Set to <code>Inf</code> to select all elements
before or after the current element. Negative values are allowed, which
allows you to &quot;look forward&quot; from the current element if used as the
<code>.before</code> value, or &quot;look backwards&quot; if used as <code>.after</code>.</p>
</td></tr>
<tr><td><code id="slide_+3A_.step">.step</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[positive integer(1)]&#8288;</code>
</p>
<p>The number of elements to shift the window forward between function calls.</p>
</td></tr>
<tr><td><code id="slide_+3A_.complete">.complete</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical(1)]&#8288;</code>
</p>
<p>Should the function be evaluated on complete windows only? If <code>FALSE</code>,
the default, then partial computations will be allowed.</p>
</td></tr>
<tr><td><code id="slide_+3A_.ptype">.ptype</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[vector(0) / NULL]&#8288;</code>
</p>
<p>A prototype corresponding to the type of the output.
</p>
<p>If <code>NULL</code>, the default, the output type is determined by computing the
common type across the results of the calls to <code>.f</code>.
</p>
<p>If supplied, the result of each call to <code>.f</code> will be cast to that type,
and the final output will have that type.
</p>
<p>If <code>getOption("vctrs.no_guessing")</code> is <code>TRUE</code>, the <code>.ptype</code> must be
supplied. This is a way to make production code demand fixed types.</p>
</td></tr>
<tr><td><code id="slide_+3A_.names_to">.names_to</code></td>
<td>
<p>This controls what to do with input names supplied in <code>...</code>.
</p>

<ul>
<li><p> By default, input names are <a href="rlang.html#topic+zap">zapped</a>.
</p>
</li>
<li><p> If a string, specifies a column where the input names will be
copied. These names are often useful to identify rows with
their original input. If a column name is supplied and <code>...</code> is
not named, an integer column is used instead.
</p>
</li>
<li><p> If <code>NULL</code>, the input names are used as row names.
</p>
</li></ul>
</td></tr>
<tr><td><code id="slide_+3A_.name_repair">.name_repair</code></td>
<td>
<p>One of <code>"unique"</code>, <code>"universal"</code>, <code>"check_unique"</code>,
<code>"unique_quiet"</code>, or  <code>"universal_quiet"</code>. See <code><a href="vctrs.html#topic+vec_as_names">vec_as_names()</a></code> for the
meaning of these options.
</p>
<p>With <code>vec_rbind()</code>, the repair function is applied to all inputs
separately. This is because <code>vec_rbind()</code> needs to align their
columns before binding the rows, and thus needs all inputs to
have unique names. On the other hand, <code>vec_cbind()</code> applies the
repair function after all inputs have been concatenated together
in a final data frame. Hence <code>vec_cbind()</code> allows the more
permissive minimal names repair.</p>
</td></tr>
<tr><td><code id="slide_+3A_.size">.size</code></td>
<td>
<p>If, <code>NULL</code>, the default, will determine the number of rows in
<code>vec_cbind()</code> output by using the tidyverse <a href="vctrs.html#topic+vector_recycling_rules">recycling rules</a>.
</p>
<p>Alternatively, specify the desired number of rows, and any inputs of length
1 will be recycled appropriately.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unlike <code>lapply()</code> or <code>purrr::map()</code>, which construct calls like
</p>
<div class="sourceCode"><pre>.f(.x[[i]], ...)
</pre></div>
<p>the equivalent with <code>slide()</code> looks like
</p>
<div class="sourceCode"><pre>.f(vctrs::vec_slice(.x, i), ...)
</pre></div>
<p>which is approximately
</p>
<div class="sourceCode"><pre>.f(.x[i], ...)
</pre></div>
<p>except in the case of data frames or arrays, which are iterated
over row-wise.
</p>
<p>If <code>.x</code> has names, then the output will preserve those names.
</p>
<p>Using <code><a href="vctrs.html#topic+vec_cast">vctrs::vec_cast()</a></code>, the output of <code>.f</code> will be automatically cast
to the type required by the variant of <code style="white-space: pre;">&#8288;slide_*()&#8288;</code> being used.
</p>


<h3>Value</h3>

<p>A vector fulfilling the following invariants:
</p>


<h4><code>slide()</code></h4>


<ul>
<li> <p><code>vec_size(slide(.x)) == vec_size(.x)</code>
</p>
</li>
<li> <p><code>vec_ptype(slide(.x)) == list()</code>
</p>
</li></ul>




<h4><code>slide_vec()</code> and <code style="white-space: pre;">&#8288;slide_*()&#8288;</code> variants</h4>


<ul>
<li> <p><code>vec_size(slide_vec(.x)) == vec_size(.x)</code>
</p>
</li>
<li> <p><code>vec_size(slide_vec(.x)[[1]]) == 1L</code>
</p>
</li>
<li> <p><code>vec_ptype(slide_vec(.x, .ptype = ptype)) == ptype</code>
</p>
</li></ul>




<h3>See Also</h3>

<p><code><a href="#topic+slide2">slide2()</a></code>, <code><a href="#topic+slide_index">slide_index()</a></code>, <code><a href="#topic+hop">hop()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The defaults work similarly to `map()`
slide(1:5, ~.x)

# Use `.before`, `.after`, and `.step` to control the window
slide(1:5, ~.x, .before = 1)

# This can be used for rolling means
slide_dbl(rnorm(5), mean, .before = 2)

# Or more flexible rolling operations
slide(rnorm(5), ~ .x - mean(.x), .before = 2)

# `.after` allows you to "align to the left" rather than the right
slide(1:5, ~.x, .after = 2)

# And a mixture of `.before` and `.after`
# allows you complete control over the exact alignment.
# Below, "center alignment" is used.
slide(1:5, ~.x, .before = 1, .after = 1)

# The `.step` controls how the window is shifted along `.x`,
# allowing you to "skip" iterations if you only need a less granular result
slide(1:10, ~.x, .before = 2, .step = 3)

# `.complete` controls whether or not partial results are computed.
# By default, they are, but setting `.complete = TRUE` restricts
# `slide()` to only evaluate the function where a complete window exists.
slide(1:5, ~.x, .before = 2, .after = 1)
slide(1:5, ~.x, .before = 2, .after = 1, .complete = TRUE)

# ---------------------------------------------------------------------------
# Data frames

# Data frames are iterated over rowwise
mtcars_rowwise &lt;- slide(mtcars, ~.x)
mtcars_rowwise[1:3]

# This means that any column name is easily accessible
slide_dbl(mtcars, ~.x$mpg + .x$cyl)

# More advanced rowwise iteration is available as well by using the
# other arguments
mtcars_rowwise_window &lt;- slide(mtcars, ~.x, .before = 1, .after = 1)
mtcars_rowwise_window[1:3]

# ---------------------------------------------------------------------------
# Cumulative sliding

# Using the special cased value, `Inf`, you can ask `slide()` to pin the
# start of the sliding window to the first element, effectively creating
# a cumulative window
slide(1:5, ~.x, .before = Inf)

# Same with `.after`, this creates a window where you start with all of the
# elements, but decrease the total number over each iteration
slide(1:5, ~.x, .after = Inf)

# ---------------------------------------------------------------------------
# Negative `.before` / `.after`

# `.before` is allowed to be negative, allowing you to "look forward" in
# your vector. Note that `abs(.before) &lt;= .after` must hold if `.before` is
# negative. In this example, we look forward to elements in locations 2 and 3
# but place the result in position 1 in the output.
slide(1:5, ~.x, .before = -1, .after = 2)

# `.after` can be negative as well to "look backwards"
slide(1:5, ~.x, .before = 2, .after = -1)

# ---------------------------------------------------------------------------
# Removing padding

# If you are looking for a way to remove the `NA` values from something like
# this, then it doesn't exist as a built in option.
x &lt;- rnorm(10)
slide_dbl(x, mean, .before = 3, .step = 2, .complete = TRUE)

# Adding an option to `slide_dbl()` to remove the `NA` values would destroy
# its size stability. Instead, you can use a combination of `slide_dfr()`
# to get the start/stop indices with `hop_index_vec()`.
i &lt;- seq_along(x)
idx &lt;- slide_dfr(
  i,
  ~data.frame(start = .x[1], stop = .x[length(.x)]),
  .before = 3,
  .step = 2,
  .complete = TRUE
)

idx

hop_index_vec(x, i, idx$start, idx$stop, mean, .ptype = double())

</code></pre>

<hr>
<h2 id='slide_index'>Slide relative to an index</h2><span id='topic+slide_index'></span><span id='topic+slide_index_vec'></span><span id='topic+slide_index_dbl'></span><span id='topic+slide_index_int'></span><span id='topic+slide_index_lgl'></span><span id='topic+slide_index_chr'></span><span id='topic+slide_index_dfr'></span><span id='topic+slide_index_dfc'></span>

<h3>Description</h3>

<p><code>slide_index()</code> is similar to <code>slide()</code>, but allows a secondary <code>.i</code>-ndex
vector to be provided.
</p>
<p>This is often useful in business calculations, when
you want to compute a rolling computation looking &quot;3 months back&quot;, which
is approximately but not equivalent to, 3 * 30 days. <code>slide_index()</code> allows
for these irregular window sizes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slide_index(.x, .i, .f, ..., .before = 0L, .after = 0L, .complete = FALSE)

slide_index_vec(
  .x,
  .i,
  .f,
  ...,
  .before = 0L,
  .after = 0L,
  .complete = FALSE,
  .ptype = NULL
)

slide_index_dbl(.x, .i, .f, ..., .before = 0L, .after = 0L, .complete = FALSE)

slide_index_int(.x, .i, .f, ..., .before = 0L, .after = 0L, .complete = FALSE)

slide_index_lgl(.x, .i, .f, ..., .before = 0L, .after = 0L, .complete = FALSE)

slide_index_chr(.x, .i, .f, ..., .before = 0L, .after = 0L, .complete = FALSE)

slide_index_dfr(
  .x,
  .i,
  .f,
  ...,
  .before = 0L,
  .after = 0L,
  .complete = FALSE,
  .names_to = rlang::zap(),
  .name_repair = c("unique", "universal", "check_unique")
)

slide_index_dfc(
  .x,
  .i,
  .f,
  ...,
  .before = 0L,
  .after = 0L,
  .complete = FALSE,
  .size = NULL,
  .name_repair = c("unique", "universal", "check_unique", "minimal")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slide_index_+3A_.x">.x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[vector]&#8288;</code>
</p>
<p>The vector to iterate over and apply <code>.f</code> to.</p>
</td></tr>
<tr><td><code id="slide_index_+3A_.i">.i</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[vector]&#8288;</code>
</p>
<p>The index vector that determines the window sizes. It is fairly common to
supply a date vector as the index, but not required.
</p>
<p>There are 3 restrictions on the index:
</p>

<ul>
<li><p> The size of the index must match the size of <code>.x</code>, they will not be
recycled to their common size.
</p>
</li>
<li><p> The index must be an <em>increasing</em> vector, but duplicate values
are allowed.
</p>
</li>
<li><p> The index cannot have missing values.
</p>
</li></ul>
</td></tr>
<tr><td><code id="slide_index_+3A_.f">.f</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[function / formula]&#8288;</code>
</p>
<p>If a <strong>function</strong>, it is used as is.
</p>
<p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function. There
are three ways to refer to the arguments:
</p>

<ul>
<li><p> For a single argument function, use <code>.</code>
</p>
</li>
<li><p> For a two argument function, use <code>.x</code> and <code>.y</code>
</p>
</li>
<li><p> For more arguments, use <code>..1</code>, <code>..2</code>, <code>..3</code> etc
</p>
</li></ul>

<p>This syntax allows you to create very compact anonymous functions.</p>
</td></tr>
<tr><td><code id="slide_index_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to the mapped function.</p>
</td></tr>
<tr><td><code id="slide_index_+3A_.before">.before</code>, <code id="slide_index_+3A_.after">.after</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[vector(1) / function / Inf]&#8288;</code>
</p>

<ul>
<li><p> If a vector of size 1, these represent the number of values before or
after the current element of <code>.i</code> to include in the sliding window.
Negative values are allowed, which allows you to &quot;look forward&quot; from the
current element if used as the <code>.before</code> value, or &quot;look backwards&quot; if used
as <code>.after</code>. Boundaries are computed from these elements as <code>.i - .before</code>
and <code>.i + .after</code>. Any object that can be added or subtracted from <code>.i</code>
with <code>+</code> and <code>-</code> can be used. For example, a lubridate period, such as
<code><a href="lubridate.html#topic+period">lubridate::weeks()</a></code>.
</p>
</li>
<li><p> If <code>Inf</code>, this selects all elements before or after the current element.
</p>
</li>
<li><p> If a function, or a one-sided formula which can be coerced to a function,
it is applied to <code>.i</code> to compute the boundaries. Note that this function
will only be applied to the <em>unique</em> values of <code>.i</code>, so it should not rely
on the original length of <code>.i</code> in any way. This is useful for applying a
complex arithmetic operation that can't be expressed with a single <code>-</code> or
<code>+</code> operation. One example would be to use <code><a href="lubridate.html#topic+mplus">lubridate::add_with_rollback()</a></code>
to avoid invalid dates at the end of the month.
</p>
</li></ul>

<p>The ranges that result from applying <code>.before</code> and <code>.after</code> have the same
3 restrictions as <code>.i</code> itself.</p>
</td></tr>
<tr><td><code id="slide_index_+3A_.complete">.complete</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical(1)]&#8288;</code>
</p>
<p>Should the function be evaluated on complete windows only? If <code>FALSE</code>,
the default, then partial computations will be allowed.</p>
</td></tr>
<tr><td><code id="slide_index_+3A_.ptype">.ptype</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[vector(0) / NULL]&#8288;</code>
</p>
<p>A prototype corresponding to the type of the output.
</p>
<p>If <code>NULL</code>, the default, the output type is determined by computing the
common type across the results of the calls to <code>.f</code>.
</p>
<p>If supplied, the result of each call to <code>.f</code> will be cast to that type,
and the final output will have that type.
</p>
<p>If <code>getOption("vctrs.no_guessing")</code> is <code>TRUE</code>, the <code>.ptype</code> must be
supplied. This is a way to make production code demand fixed types.</p>
</td></tr>
<tr><td><code id="slide_index_+3A_.names_to">.names_to</code></td>
<td>
<p>This controls what to do with input names supplied in <code>...</code>.
</p>

<ul>
<li><p> By default, input names are <a href="rlang.html#topic+zap">zapped</a>.
</p>
</li>
<li><p> If a string, specifies a column where the input names will be
copied. These names are often useful to identify rows with
their original input. If a column name is supplied and <code>...</code> is
not named, an integer column is used instead.
</p>
</li>
<li><p> If <code>NULL</code>, the input names are used as row names.
</p>
</li></ul>
</td></tr>
<tr><td><code id="slide_index_+3A_.name_repair">.name_repair</code></td>
<td>
<p>One of <code>"unique"</code>, <code>"universal"</code>, <code>"check_unique"</code>,
<code>"unique_quiet"</code>, or  <code>"universal_quiet"</code>. See <code><a href="vctrs.html#topic+vec_as_names">vec_as_names()</a></code> for the
meaning of these options.
</p>
<p>With <code>vec_rbind()</code>, the repair function is applied to all inputs
separately. This is because <code>vec_rbind()</code> needs to align their
columns before binding the rows, and thus needs all inputs to
have unique names. On the other hand, <code>vec_cbind()</code> applies the
repair function after all inputs have been concatenated together
in a final data frame. Hence <code>vec_cbind()</code> allows the more
permissive minimal names repair.</p>
</td></tr>
<tr><td><code id="slide_index_+3A_.size">.size</code></td>
<td>
<p>If, <code>NULL</code>, the default, will determine the number of rows in
<code>vec_cbind()</code> output by using the tidyverse <a href="vctrs.html#topic+vector_recycling_rules">recycling rules</a>.
</p>
<p>Alternatively, specify the desired number of rows, and any inputs of length
1 will be recycled appropriately.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector fulfilling the following invariants:
</p>


<h4><code>slide_index()</code></h4>


<ul>
<li> <p><code>vec_size(slide_index(.x)) == vec_size(.x)</code>
</p>
</li>
<li> <p><code>vec_ptype(slide_index(.x)) == list()</code>
</p>
</li></ul>




<h4><code>slide_index_vec()</code> and <code style="white-space: pre;">&#8288;slide_index_*()&#8288;</code> variants</h4>


<ul>
<li> <p><code>vec_size(slide_index_vec(.x)) == vec_size(.x)</code>
</p>
</li>
<li> <p><code>vec_size(slide_index_vec(.x)[[1]]) == 1L</code>
</p>
</li>
<li> <p><code>vec_ptype(slide_index_vec(.x, .ptype = ptype)) == ptype</code>
</p>
</li></ul>




<h3>See Also</h3>

<p><code><a href="#topic+slide">slide()</a></code>, <code><a href="#topic+hop_index">hop_index()</a></code>, <code><a href="#topic+slide_index2">slide_index2()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lubridate)

x &lt;- 1:5

# In some cases, sliding over `x` with a strict window size of 2
# will fit your use case.
slide(x, ~.x, .before = 1)

# However, if this `i` is a date vector paired with `x`, when computing
# rolling calculations you might want to iterate over `x` while
# respecting the fact that `i` is an irregular sequence.
i &lt;- as.Date("2019-08-15") + c(0:1, 4, 6, 7)

# For example, a "2 day" window should not pair `"2019-08-19"` and
# `"2019-08-21"` together, even though they are next to each other in `x`.
# `slide_index()` computes the lookback value from the current date in `.i`,
# meaning that if you are currently on `"2019-08-21"` and look back 1 day,
# it will correctly not include `"2019-08-19"`.
slide_index(i, i, ~.x, .before = 1)

# We could have equivalently used a lubridate period object for this as well,
# since `i - lubridate::days(1)` is allowed
slide_index(i, i, ~.x, .before = lubridate::days(1))

# ---------------------------------------------------------------------------
# Functions for `.before` and `.after`

# In some cases, it might not be appropriate to compute
# `.i - .before` or `.i + .after`, either because there isn't a `-` or `+`
# method defined, or because there is an alternative way to perform the
# arithmetic. For example, subtracting 1 month with `- months(1)` (using
# lubridate) can sometimes land you on an invalid date that doesn't exist.
i &lt;- as.Date(c("2019-01-31", "2019-02-28", "2019-03-31"))

# 2019-03-31 - months(1) = 2019-02-31, which doesn't exist
i - months(1)

# These NAs create problems with `slide_index()`, which doesn't allow
# missing values in the computed endpoints
try(slide_index(i, i, identity, .before = months(1)))

# In these cases, it is more appropriate to use `%m-%`,
# which will snap to the end of the month, at least giving you something
# to work with.
i %m-% months(1)

# To use this as your `.before` or `.after`, supply an anonymous function of
# 1 argument that performs the computation
slide_index(i, i, identity, .before = ~.x %m-% months(1))

# Notice that in the `.after` case, `2019-02-28 %m+% months(1)` doesn't
# capture the end of March, so it isn't included in the 2nd result
slide_index(i, i, identity, .after = ~.x %m+% months(1))

# ---------------------------------------------------------------------------

# When `.i` has repeated values, they are always grouped together.
i &lt;- c(2017, 2017, 2018, 2019, 2020, 2020)
slide_index(i, i, ~.x)
slide_index(i, i, ~.x, .after = 1)

# ---------------------------------------------------------------------------
# Rolling regressions

# Rolling regressions are easy with `slide_index()` because:
# - Data frame `.x` values are iterated over rowwise
# - The index is respected by using `.i`
set.seed(123)

df &lt;- data.frame(
  y = rnorm(100),
  x = rnorm(100),
  i = as.Date("2019-08-15") + c(0, 2, 4, 6:102) # &lt;- irregular
)

# 20 day rolling regression. Current day + 19 days back.
# Additionally, set `.complete = TRUE` to not compute partial results.
regr &lt;- slide_index(df, df$i, ~lm(y ~ x, .x), .before = 19, .complete = TRUE)

regr[16:18]

# The first 16 slots are NULL because there is no possible way to
# look back 19 days from the 16th index position and construct a full
# window. But on the 17th index position, `""2019-09-03"`, if we look
# back 19 days we get to `""2019-08-15"`, which is the same value as
# `i[1]` so a full window can be constructed.
df$i[16] - 19 &gt;= df$i[1] # FALSE
df$i[17] - 19 &gt;= df$i[1] # TRUE

# ---------------------------------------------------------------------------
# Accessing the current index value

# A very simplistic version of `purrr::map2()`
fake_map2 &lt;- function(.x, .y, .f, ...) {
  Map(.f, .x, .y, ...)
}

# Occasionally you need to access the index value that you are currently on.
# This is generally not possible with a single call to `slide_index()`, but
# can be easily accomplished by following up a `slide_index()` call with a
# `purrr::map2()`. In this example, we want to use the distance from the
# current index value (in days) as a multiplier on `x`. Values further
# away from the current date get a higher multiplier.
set.seed(123)

# 25 random days past 2000-01-01
i &lt;- sort(as.Date("2000-01-01") + sample(100, 25))

df &lt;- data.frame(i = i, x = rnorm(25))

weight_by_distance &lt;- function(df, i) {
  df$weight = abs(as.integer(df$i - i))
  df$x_weighted = df$x * df$weight
  df
}

# Use `slide_index()` to just generate the rolling data.
# Here we take the current date + 5 days before + 5 days after.
dfs &lt;- slide_index(df, df$i, ~.x, .before = 5, .after = 5)

# Follow up with a `map2()` with `i` as the second input.
# This allows you to track the current `i` value and weight accordingly.
result &lt;- fake_map2(dfs, df$i, weight_by_distance)

head(result)

</code></pre>

<hr>
<h2 id='slide_index2'>Slide along multiples inputs simultaneously relative to an index</h2><span id='topic+slide_index2'></span><span id='topic+slide_index2_vec'></span><span id='topic+slide_index2_dbl'></span><span id='topic+slide_index2_int'></span><span id='topic+slide_index2_lgl'></span><span id='topic+slide_index2_chr'></span><span id='topic+slide_index2_dfr'></span><span id='topic+slide_index2_dfc'></span><span id='topic+pslide_index'></span><span id='topic+pslide_index_vec'></span><span id='topic+pslide_index_dbl'></span><span id='topic+pslide_index_int'></span><span id='topic+pslide_index_lgl'></span><span id='topic+pslide_index_chr'></span><span id='topic+pslide_index_dfr'></span><span id='topic+pslide_index_dfc'></span>

<h3>Description</h3>

<p><code>slide_index2()</code> and <code>pslide_index()</code> represent the combination
of <code><a href="#topic+slide2">slide2()</a></code> and <code><a href="#topic+pslide">pslide()</a></code> with <code><a href="#topic+slide_index">slide_index()</a></code>, allowing you to iterate
over multiple vectors at once relative to an <code>.i</code>-ndex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slide_index2(.x, .y, .i, .f, ..., .before = 0L, .after = 0L, .complete = FALSE)

slide_index2_vec(
  .x,
  .y,
  .i,
  .f,
  ...,
  .before = 0L,
  .after = 0L,
  .complete = FALSE,
  .ptype = NULL
)

slide_index2_dbl(
  .x,
  .y,
  .i,
  .f,
  ...,
  .before = 0L,
  .after = 0L,
  .complete = FALSE
)

slide_index2_int(
  .x,
  .y,
  .i,
  .f,
  ...,
  .before = 0L,
  .after = 0L,
  .complete = FALSE
)

slide_index2_lgl(
  .x,
  .y,
  .i,
  .f,
  ...,
  .before = 0L,
  .after = 0L,
  .complete = FALSE
)

slide_index2_chr(
  .x,
  .y,
  .i,
  .f,
  ...,
  .before = 0L,
  .after = 0L,
  .complete = FALSE
)

slide_index2_dfr(
  .x,
  .y,
  .i,
  .f,
  ...,
  .before = 0L,
  .after = 0L,
  .complete = FALSE,
  .names_to = rlang::zap(),
  .name_repair = c("unique", "universal", "check_unique")
)

slide_index2_dfc(
  .x,
  .y,
  .i,
  .f,
  ...,
  .before = 0L,
  .after = 0L,
  .complete = FALSE,
  .size = NULL,
  .name_repair = c("unique", "universal", "check_unique", "minimal")
)

pslide_index(.l, .i, .f, ..., .before = 0L, .after = 0L, .complete = FALSE)

pslide_index_vec(
  .l,
  .i,
  .f,
  ...,
  .before = 0L,
  .after = 0L,
  .complete = FALSE,
  .ptype = NULL
)

pslide_index_dbl(.l, .i, .f, ..., .before = 0L, .after = 0L, .complete = FALSE)

pslide_index_int(.l, .i, .f, ..., .before = 0L, .after = 0L, .complete = FALSE)

pslide_index_lgl(.l, .i, .f, ..., .before = 0L, .after = 0L, .complete = FALSE)

pslide_index_chr(.l, .i, .f, ..., .before = 0L, .after = 0L, .complete = FALSE)

pslide_index_dfr(
  .l,
  .i,
  .f,
  ...,
  .before = 0L,
  .after = 0L,
  .complete = FALSE,
  .names_to = rlang::zap(),
  .name_repair = c("unique", "universal", "check_unique")
)

pslide_index_dfc(
  .l,
  .i,
  .f,
  ...,
  .before = 0L,
  .after = 0L,
  .complete = FALSE,
  .size = NULL,
  .name_repair = c("unique", "universal", "check_unique", "minimal")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slide_index2_+3A_.x">.x</code>, <code id="slide_index2_+3A_.y">.y</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[vector]&#8288;</code>
</p>
<p>Vectors to iterate over. Vectors of size 1 will be recycled.</p>
</td></tr>
<tr><td><code id="slide_index2_+3A_.i">.i</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[vector]&#8288;</code>
</p>
<p>The index vector that determines the window sizes. It is fairly common to
supply a date vector as the index, but not required.
</p>
<p>There are 3 restrictions on the index:
</p>

<ul>
<li><p> The size of the index must match the size of <code>.x</code>, they will not be
recycled to their common size.
</p>
</li>
<li><p> The index must be an <em>increasing</em> vector, but duplicate values
are allowed.
</p>
</li>
<li><p> The index cannot have missing values.
</p>
</li></ul>
</td></tr>
<tr><td><code id="slide_index2_+3A_.f">.f</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[function / formula]&#8288;</code>
</p>
<p>If a <strong>function</strong>, it is used as is.
</p>
<p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function. There
are three ways to refer to the arguments:
</p>

<ul>
<li><p> For a single argument function, use <code>.</code>
</p>
</li>
<li><p> For a two argument function, use <code>.x</code> and <code>.y</code>
</p>
</li>
<li><p> For more arguments, use <code>..1</code>, <code>..2</code>, <code>..3</code> etc
</p>
</li></ul>

<p>This syntax allows you to create very compact anonymous functions.</p>
</td></tr>
<tr><td><code id="slide_index2_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to the mapped function.</p>
</td></tr>
<tr><td><code id="slide_index2_+3A_.before">.before</code>, <code id="slide_index2_+3A_.after">.after</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[vector(1) / function / Inf]&#8288;</code>
</p>

<ul>
<li><p> If a vector of size 1, these represent the number of values before or
after the current element of <code>.i</code> to include in the sliding window.
Negative values are allowed, which allows you to &quot;look forward&quot; from the
current element if used as the <code>.before</code> value, or &quot;look backwards&quot; if used
as <code>.after</code>. Boundaries are computed from these elements as <code>.i - .before</code>
and <code>.i + .after</code>. Any object that can be added or subtracted from <code>.i</code>
with <code>+</code> and <code>-</code> can be used. For example, a lubridate period, such as
<code><a href="lubridate.html#topic+period">lubridate::weeks()</a></code>.
</p>
</li>
<li><p> If <code>Inf</code>, this selects all elements before or after the current element.
</p>
</li>
<li><p> If a function, or a one-sided formula which can be coerced to a function,
it is applied to <code>.i</code> to compute the boundaries. Note that this function
will only be applied to the <em>unique</em> values of <code>.i</code>, so it should not rely
on the original length of <code>.i</code> in any way. This is useful for applying a
complex arithmetic operation that can't be expressed with a single <code>-</code> or
<code>+</code> operation. One example would be to use <code><a href="lubridate.html#topic+mplus">lubridate::add_with_rollback()</a></code>
to avoid invalid dates at the end of the month.
</p>
</li></ul>

<p>The ranges that result from applying <code>.before</code> and <code>.after</code> have the same
3 restrictions as <code>.i</code> itself.</p>
</td></tr>
<tr><td><code id="slide_index2_+3A_.complete">.complete</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical(1)]&#8288;</code>
</p>
<p>Should the function be evaluated on complete windows only? If <code>FALSE</code>,
the default, then partial computations will be allowed.</p>
</td></tr>
<tr><td><code id="slide_index2_+3A_.ptype">.ptype</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[vector(0) / NULL]&#8288;</code>
</p>
<p>A prototype corresponding to the type of the output.
</p>
<p>If <code>NULL</code>, the default, the output type is determined by computing the
common type across the results of the calls to <code>.f</code>.
</p>
<p>If supplied, the result of each call to <code>.f</code> will be cast to that type,
and the final output will have that type.
</p>
<p>If <code>getOption("vctrs.no_guessing")</code> is <code>TRUE</code>, the <code>.ptype</code> must be
supplied. This is a way to make production code demand fixed types.</p>
</td></tr>
<tr><td><code id="slide_index2_+3A_.names_to">.names_to</code></td>
<td>
<p>This controls what to do with input names supplied in <code>...</code>.
</p>

<ul>
<li><p> By default, input names are <a href="rlang.html#topic+zap">zapped</a>.
</p>
</li>
<li><p> If a string, specifies a column where the input names will be
copied. These names are often useful to identify rows with
their original input. If a column name is supplied and <code>...</code> is
not named, an integer column is used instead.
</p>
</li>
<li><p> If <code>NULL</code>, the input names are used as row names.
</p>
</li></ul>
</td></tr>
<tr><td><code id="slide_index2_+3A_.name_repair">.name_repair</code></td>
<td>
<p>One of <code>"unique"</code>, <code>"universal"</code>, <code>"check_unique"</code>,
<code>"unique_quiet"</code>, or  <code>"universal_quiet"</code>. See <code><a href="vctrs.html#topic+vec_as_names">vec_as_names()</a></code> for the
meaning of these options.
</p>
<p>With <code>vec_rbind()</code>, the repair function is applied to all inputs
separately. This is because <code>vec_rbind()</code> needs to align their
columns before binding the rows, and thus needs all inputs to
have unique names. On the other hand, <code>vec_cbind()</code> applies the
repair function after all inputs have been concatenated together
in a final data frame. Hence <code>vec_cbind()</code> allows the more
permissive minimal names repair.</p>
</td></tr>
<tr><td><code id="slide_index2_+3A_.size">.size</code></td>
<td>
<p>If, <code>NULL</code>, the default, will determine the number of rows in
<code>vec_cbind()</code> output by using the tidyverse <a href="vctrs.html#topic+vector_recycling_rules">recycling rules</a>.
</p>
<p>Alternatively, specify the desired number of rows, and any inputs of length
1 will be recycled appropriately.</p>
</td></tr>
<tr><td><code id="slide_index2_+3A_.l">.l</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[list]&#8288;</code>
</p>
<p>A list of vectors. The length of <code>.l</code> determines the
number of arguments that <code>.f</code> will be called with. If <code>.l</code> has names,
they will be used as named arguments to <code>.f</code>. Elements of <code>.l</code> with size
1 will be recycled.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector fulfilling the following invariants:
</p>


<h4><code>slide_index2()</code></h4>


<ul>
<li> <p><code>vec_size(slide_index2(.x, .y)) == vec_size_common(.x, .y)</code>
</p>
</li>
<li> <p><code>vec_ptype(slide_index2(.x, .y)) == list()</code>
</p>
</li></ul>




<h4><code>slide_index2_vec()</code> and <code style="white-space: pre;">&#8288;slide_index2_*()&#8288;</code> variants</h4>


<ul>
<li> <p><code>vec_size(slide_index2_vec(.x, .y)) == vec_size_common(.x, .y)</code>
</p>
</li>
<li> <p><code>vec_size(slide_index2_vec(.x, .y)[[1]]) == 1L</code>
</p>
</li>
<li> <p><code>vec_ptype(slide_index2_vec(.x, .y, .ptype = ptype)) == ptype</code>
</p>
</li></ul>




<h4><code>pslide_index()</code></h4>


<ul>
<li> <p><code>vec_size(pslide_index(.l)) == vec_size_common(!!! .l)</code>
</p>
</li>
<li> <p><code>vec_ptype(pslide_index(.l)) == list()</code>
</p>
</li></ul>




<h4><code>pslide_index_vec()</code> and <code style="white-space: pre;">&#8288;pslide_index_*()&#8288;</code> variants</h4>


<ul>
<li> <p><code>vec_size(pslide_index_vec(.l)) == vec_size_common(!!! .l)</code>
</p>
</li>
<li> <p><code>vec_size(pslide_index_vec(.l)[[1]]) == 1L</code>
</p>
</li>
<li> <p><code>vec_ptype(pslide_index_vec(.l, .ptype = ptype)) == ptype</code>
</p>
</li></ul>




<h3>See Also</h3>

<p><code><a href="#topic+slide2">slide2()</a></code>, <code><a href="#topic+hop_index2">hop_index2()</a></code>, <code><a href="#topic+slide_index">slide_index()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Notice that `i` is an irregular index!
x &lt;- 1:5
y &lt;- 6:10
i &lt;- as.Date("2019-08-15") + c(0:1, 4, 6, 7)

# When we slide over `i` looking back 1 day, the irregularity is respected.
# When there is a gap in dates, only 2 values are returned (one from
# `x` and one from `y`), otherwise, 4 values are returned.
slide_index2(x, y, i, ~c(.x, .y), .before = 1)

</code></pre>

<hr>
<h2 id='slide_period'>Slide relative to an index chunked by period</h2><span id='topic+slide_period'></span><span id='topic+slide_period_vec'></span><span id='topic+slide_period_dbl'></span><span id='topic+slide_period_int'></span><span id='topic+slide_period_lgl'></span><span id='topic+slide_period_chr'></span><span id='topic+slide_period_dfr'></span><span id='topic+slide_period_dfc'></span>

<h3>Description</h3>

<p><code>slide_period()</code> breaks up the <code>.i</code>-ndex by <code>.period</code>, and then uses that
to define the indices to slide over <code>.x</code> with.
</p>
<p>It can be useful for, say, sliding over daily data in monthly chunks.
</p>
<p>The underlying engine for breaking up <code>.i</code> is <code><a href="warp.html#topic+warp_distance">warp::warp_distance()</a></code>.
If you need more information about the <code>.period</code> types, that is the best
place to look.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slide_period(
  .x,
  .i,
  .period,
  .f,
  ...,
  .every = 1L,
  .origin = NULL,
  .before = 0L,
  .after = 0L,
  .complete = FALSE
)

slide_period_vec(
  .x,
  .i,
  .period,
  .f,
  ...,
  .every = 1L,
  .origin = NULL,
  .before = 0L,
  .after = 0L,
  .complete = FALSE,
  .ptype = NULL
)

slide_period_dbl(
  .x,
  .i,
  .period,
  .f,
  ...,
  .every = 1L,
  .origin = NULL,
  .before = 0L,
  .after = 0L,
  .complete = FALSE
)

slide_period_int(
  .x,
  .i,
  .period,
  .f,
  ...,
  .every = 1L,
  .origin = NULL,
  .before = 0L,
  .after = 0L,
  .complete = FALSE
)

slide_period_lgl(
  .x,
  .i,
  .period,
  .f,
  ...,
  .every = 1L,
  .origin = NULL,
  .before = 0L,
  .after = 0L,
  .complete = FALSE
)

slide_period_chr(
  .x,
  .i,
  .period,
  .f,
  ...,
  .every = 1L,
  .origin = NULL,
  .before = 0L,
  .after = 0L,
  .complete = FALSE
)

slide_period_dfr(
  .x,
  .i,
  .period,
  .f,
  ...,
  .every = 1L,
  .origin = NULL,
  .before = 0L,
  .after = 0L,
  .complete = FALSE,
  .names_to = rlang::zap(),
  .name_repair = c("unique", "universal", "check_unique")
)

slide_period_dfc(
  .x,
  .i,
  .period,
  .f,
  ...,
  .every = 1L,
  .origin = NULL,
  .before = 0L,
  .after = 0L,
  .complete = FALSE,
  .size = NULL,
  .name_repair = c("unique", "universal", "check_unique", "minimal")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slide_period_+3A_.x">.x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[vector]&#8288;</code>
</p>
<p>The vector to iterate over and apply <code>.f</code> to.</p>
</td></tr>
<tr><td><code id="slide_period_+3A_.i">.i</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[Date / POSIXct / POSIXlt]&#8288;</code>
</p>
<p>A datetime index to break into periods.
</p>
<p>There are 3 restrictions on the index:
</p>

<ul>
<li><p> The size of the index must match the size of <code>.x</code>, they will not be
recycled to their common size.
</p>
</li>
<li><p> The index must be an <em>increasing</em> vector, but duplicate values
are allowed.
</p>
</li>
<li><p> The index cannot have missing values.
</p>
</li></ul>
</td></tr>
<tr><td><code id="slide_period_+3A_.period">.period</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character(1)]&#8288;</code>
</p>
<p>A string defining the period to group by. Valid inputs can be roughly
broken into:
</p>

<ul>
<li> <p><code>"year"</code>, <code>"quarter"</code>, <code>"month"</code>, <code>"week"</code>, <code>"day"</code>
</p>
</li>
<li> <p><code>"hour"</code>, <code>"minute"</code>, <code>"second"</code>, <code>"millisecond"</code>
</p>
</li>
<li> <p><code>"yweek"</code>, <code>"mweek"</code>
</p>
</li>
<li> <p><code>"yday"</code>, <code>"mday"</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="slide_period_+3A_.f">.f</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[function / formula]&#8288;</code>
</p>
<p>If a <strong>function</strong>, it is used as is.
</p>
<p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function. There
are three ways to refer to the arguments:
</p>

<ul>
<li><p> For a single argument function, use <code>.</code>
</p>
</li>
<li><p> For a two argument function, use <code>.x</code> and <code>.y</code>
</p>
</li>
<li><p> For more arguments, use <code>..1</code>, <code>..2</code>, <code>..3</code> etc
</p>
</li></ul>

<p>This syntax allows you to create very compact anonymous functions.</p>
</td></tr>
<tr><td><code id="slide_period_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to the mapped function.</p>
</td></tr>
<tr><td><code id="slide_period_+3A_.every">.every</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[positive integer(1)]&#8288;</code>
</p>
<p>The number of periods to group together.
</p>
<p>For example, if the period was set to <code>"year"</code> with an every value of <code>2</code>,
then the years 1970 and 1971 would be placed in the same group.</p>
</td></tr>
<tr><td><code id="slide_period_+3A_.origin">.origin</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[Date(1) / POSIXct(1) / POSIXlt(1) / NULL]&#8288;</code>
</p>
<p>The reference date time value. The default when left as <code>NULL</code> is the
epoch time of <code style="white-space: pre;">&#8288;1970-01-01 00:00:00&#8288;</code>, <em>in the time zone of the index</em>.
</p>
<p>This is generally used to define the anchor time to count from, which is
relevant when the every value is <code style="white-space: pre;">&#8288;&gt; 1&#8288;</code>.</p>
</td></tr>
<tr><td><code id="slide_period_+3A_.before">.before</code>, <code id="slide_period_+3A_.after">.after</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integer(1) / Inf]&#8288;</code>
</p>
<p>The number of values before or after the current element to
include in the sliding window. Set to <code>Inf</code> to select all elements
before or after the current element. Negative values are allowed, which
allows you to &quot;look forward&quot; from the current element if used as the
<code>.before</code> value, or &quot;look backwards&quot; if used as <code>.after</code>.</p>
</td></tr>
<tr><td><code id="slide_period_+3A_.complete">.complete</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical(1)]&#8288;</code>
</p>
<p>Should the function be evaluated on complete windows only? If <code>FALSE</code>,
the default, then partial computations will be allowed.</p>
</td></tr>
<tr><td><code id="slide_period_+3A_.ptype">.ptype</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[vector(0) / NULL]&#8288;</code>
</p>
<p>A prototype corresponding to the type of the output.
</p>
<p>If <code>NULL</code>, the default, the output type is determined by computing the
common type across the results of the calls to <code>.f</code>.
</p>
<p>If supplied, the result of each call to <code>.f</code> will be cast to that type,
and the final output will have that type.
</p>
<p>If <code>getOption("vctrs.no_guessing")</code> is <code>TRUE</code>, the <code>.ptype</code> must be
supplied. This is a way to make production code demand fixed types.</p>
</td></tr>
<tr><td><code id="slide_period_+3A_.names_to">.names_to</code></td>
<td>
<p>This controls what to do with input names supplied in <code>...</code>.
</p>

<ul>
<li><p> By default, input names are <a href="rlang.html#topic+zap">zapped</a>.
</p>
</li>
<li><p> If a string, specifies a column where the input names will be
copied. These names are often useful to identify rows with
their original input. If a column name is supplied and <code>...</code> is
not named, an integer column is used instead.
</p>
</li>
<li><p> If <code>NULL</code>, the input names are used as row names.
</p>
</li></ul>
</td></tr>
<tr><td><code id="slide_period_+3A_.name_repair">.name_repair</code></td>
<td>
<p>One of <code>"unique"</code>, <code>"universal"</code>, <code>"check_unique"</code>,
<code>"unique_quiet"</code>, or  <code>"universal_quiet"</code>. See <code><a href="vctrs.html#topic+vec_as_names">vec_as_names()</a></code> for the
meaning of these options.
</p>
<p>With <code>vec_rbind()</code>, the repair function is applied to all inputs
separately. This is because <code>vec_rbind()</code> needs to align their
columns before binding the rows, and thus needs all inputs to
have unique names. On the other hand, <code>vec_cbind()</code> applies the
repair function after all inputs have been concatenated together
in a final data frame. Hence <code>vec_cbind()</code> allows the more
permissive minimal names repair.</p>
</td></tr>
<tr><td><code id="slide_period_+3A_.size">.size</code></td>
<td>
<p>If, <code>NULL</code>, the default, will determine the number of rows in
<code>vec_cbind()</code> output by using the tidyverse <a href="vctrs.html#topic+vector_recycling_rules">recycling rules</a>.
</p>
<p>Alternatively, specify the desired number of rows, and any inputs of length
1 will be recycled appropriately.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector fulfilling the following invariants:
</p>


<h4><code>slide_period()</code></h4>


<ul>
<li> <p><code>vec_size(slide_period(.x)) == vec_size(unique(warp::warp_distance(.i)))</code>
</p>
</li>
<li> <p><code>vec_ptype(slide_period(.x)) == list()</code>
</p>
</li></ul>




<h4><code>slide_period_vec()</code> and <code style="white-space: pre;">&#8288;slide_period_*()&#8288;</code> variants</h4>


<ul>
<li> <p><code>vec_size(slide_period_vec(.x)) == vec_size(unique(warp::warp_distance(.i)))</code>
</p>
</li>
<li> <p><code>vec_size(slide_period_vec(.x)[[1]]) == 1L</code>
</p>
</li>
<li> <p><code>vec_ptype(slide_period_vec(.x, .ptype = ptype)) == ptype</code>
</p>
</li></ul>




<h3>See Also</h3>

<p><code><a href="#topic+block">block()</a></code>, <code><a href="#topic+slide">slide()</a></code>, <code><a href="#topic+slide_index">slide_index()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>i &lt;- as.Date("2019-01-28") + 0:5

# Split `i` into 2-day periods to apply `.f` to
slide_period(i, i, "day", identity, .every = 2)

# Or into 1-month periods
slide_period(i, i, "month", identity)

# Now select:
# - The current 2-day period
# - Plus 1 2-day period before the current one
slide_period(i, i, "day", identity, .every = 2, .before = 1)

# Alter the `origin` to control the reference date for
# how the 2-day groups are formed
origin &lt;- as.Date("2019-01-29")
slide_period(i, i, "day", identity, .every = 2, .origin = origin)

# This can be useful for, say, monthly averages
daily_sales &lt;- c(2, 5, 3, 6, 9, 4)
slide_period_dbl(daily_sales, i, "month", mean)

# If you need the index, slide over and return a data frame
sales_df &lt;- data.frame(i = i, sales = daily_sales)

slide_period_dfr(
  sales_df,
  sales_df$i,
  "month",
  ~data.frame(
     i = max(.x$i),
     sales = mean(.x$sales)
   )
)

# One of the most unique features about `slide_period()` is that it is
# aware of how far apart elements of `.i` are in the `.period` you are
# interested in. For example, if you do a monthly slide with `i2`, selecting
# the current month and 1 month before it, then it will recognize that
# `2019-02-01` and `2019-04-01` are not beside each other, and it won't
# group them together.
i2 &lt;- as.Date(c("2019-01-01", "2019-02-01", "2019-04-01", "2019-05-01"))

slide_period(i2, i2, "month", identity, .before = 1)

</code></pre>

<hr>
<h2 id='slide_period2'>Slide along multiple inputs simultaneously relative to an index chunked by period</h2><span id='topic+slide_period2'></span><span id='topic+slide_period2_vec'></span><span id='topic+slide_period2_dbl'></span><span id='topic+slide_period2_int'></span><span id='topic+slide_period2_lgl'></span><span id='topic+slide_period2_chr'></span><span id='topic+slide_period2_dfr'></span><span id='topic+slide_period2_dfc'></span><span id='topic+pslide_period'></span><span id='topic+pslide_period_vec'></span><span id='topic+pslide_period_dbl'></span><span id='topic+pslide_period_int'></span><span id='topic+pslide_period_lgl'></span><span id='topic+pslide_period_chr'></span><span id='topic+pslide_period_dfr'></span><span id='topic+pslide_period_dfc'></span>

<h3>Description</h3>

<p><code>slide_period2()</code> and <code>pslide_period()</code> represent the combination
of <code><a href="#topic+slide2">slide2()</a></code> and <code><a href="#topic+pslide">pslide()</a></code> with <code><a href="#topic+slide_period">slide_period()</a></code>, allowing you to slide
over multiple vectors at once, using indices defined by breaking up the
<code>.i</code>-ndex by <code>.period</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slide_period2(
  .x,
  .y,
  .i,
  .period,
  .f,
  ...,
  .every = 1L,
  .origin = NULL,
  .before = 0L,
  .after = 0L,
  .complete = FALSE
)

slide_period2_vec(
  .x,
  .y,
  .i,
  .period,
  .f,
  ...,
  .every = 1L,
  .origin = NULL,
  .before = 0L,
  .after = 0L,
  .complete = FALSE,
  .ptype = NULL
)

slide_period2_dbl(
  .x,
  .y,
  .i,
  .period,
  .f,
  ...,
  .every = 1L,
  .origin = NULL,
  .before = 0L,
  .after = 0L,
  .complete = FALSE
)

slide_period2_int(
  .x,
  .y,
  .i,
  .period,
  .f,
  ...,
  .every = 1L,
  .origin = NULL,
  .before = 0L,
  .after = 0L,
  .complete = FALSE
)

slide_period2_lgl(
  .x,
  .y,
  .i,
  .period,
  .f,
  ...,
  .every = 1L,
  .origin = NULL,
  .before = 0L,
  .after = 0L,
  .complete = FALSE
)

slide_period2_chr(
  .x,
  .y,
  .i,
  .period,
  .f,
  ...,
  .every = 1L,
  .origin = NULL,
  .before = 0L,
  .after = 0L,
  .complete = FALSE
)

slide_period2_dfr(
  .x,
  .y,
  .i,
  .period,
  .f,
  ...,
  .every = 1L,
  .origin = NULL,
  .before = 0L,
  .after = 0L,
  .complete = FALSE,
  .names_to = rlang::zap(),
  .name_repair = c("unique", "universal", "check_unique")
)

slide_period2_dfc(
  .x,
  .y,
  .i,
  .period,
  .f,
  ...,
  .every = 1L,
  .origin = NULL,
  .before = 0L,
  .after = 0L,
  .complete = FALSE,
  .size = NULL,
  .name_repair = c("unique", "universal", "check_unique", "minimal")
)

pslide_period(
  .l,
  .i,
  .period,
  .f,
  ...,
  .every = 1L,
  .origin = NULL,
  .before = 0L,
  .after = 0L,
  .complete = FALSE
)

pslide_period_vec(
  .l,
  .i,
  .period,
  .f,
  ...,
  .every = 1L,
  .origin = NULL,
  .before = 0L,
  .after = 0L,
  .complete = FALSE,
  .ptype = NULL
)

pslide_period_dbl(
  .l,
  .i,
  .period,
  .f,
  ...,
  .every = 1L,
  .origin = NULL,
  .before = 0L,
  .after = 0L,
  .complete = FALSE
)

pslide_period_int(
  .l,
  .i,
  .period,
  .f,
  ...,
  .every = 1L,
  .origin = NULL,
  .before = 0L,
  .after = 0L,
  .complete = FALSE
)

pslide_period_lgl(
  .l,
  .i,
  .period,
  .f,
  ...,
  .every = 1L,
  .origin = NULL,
  .before = 0L,
  .after = 0L,
  .complete = FALSE
)

pslide_period_chr(
  .l,
  .i,
  .period,
  .f,
  ...,
  .every = 1L,
  .origin = NULL,
  .before = 0L,
  .after = 0L,
  .complete = FALSE
)

pslide_period_dfr(
  .l,
  .i,
  .period,
  .f,
  ...,
  .every = 1L,
  .origin = NULL,
  .before = 0L,
  .after = 0L,
  .complete = FALSE,
  .names_to = rlang::zap(),
  .name_repair = c("unique", "universal", "check_unique")
)

pslide_period_dfc(
  .l,
  .i,
  .period,
  .f,
  ...,
  .every = 1L,
  .origin = NULL,
  .before = 0L,
  .after = 0L,
  .complete = FALSE,
  .size = NULL,
  .name_repair = c("unique", "universal", "check_unique", "minimal")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slide_period2_+3A_.x">.x</code>, <code id="slide_period2_+3A_.y">.y</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[vector]&#8288;</code>
</p>
<p>Vectors to iterate over. Vectors of size 1 will be recycled.</p>
</td></tr>
<tr><td><code id="slide_period2_+3A_.i">.i</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[Date / POSIXct / POSIXlt]&#8288;</code>
</p>
<p>A datetime index to break into periods.
</p>
<p>There are 3 restrictions on the index:
</p>

<ul>
<li><p> The size of the index must match the size of <code>.x</code>, they will not be
recycled to their common size.
</p>
</li>
<li><p> The index must be an <em>increasing</em> vector, but duplicate values
are allowed.
</p>
</li>
<li><p> The index cannot have missing values.
</p>
</li></ul>
</td></tr>
<tr><td><code id="slide_period2_+3A_.period">.period</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character(1)]&#8288;</code>
</p>
<p>A string defining the period to group by. Valid inputs can be roughly
broken into:
</p>

<ul>
<li> <p><code>"year"</code>, <code>"quarter"</code>, <code>"month"</code>, <code>"week"</code>, <code>"day"</code>
</p>
</li>
<li> <p><code>"hour"</code>, <code>"minute"</code>, <code>"second"</code>, <code>"millisecond"</code>
</p>
</li>
<li> <p><code>"yweek"</code>, <code>"mweek"</code>
</p>
</li>
<li> <p><code>"yday"</code>, <code>"mday"</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="slide_period2_+3A_.f">.f</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[function / formula]&#8288;</code>
</p>
<p>If a <strong>function</strong>, it is used as is.
</p>
<p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function. There
are three ways to refer to the arguments:
</p>

<ul>
<li><p> For a single argument function, use <code>.</code>
</p>
</li>
<li><p> For a two argument function, use <code>.x</code> and <code>.y</code>
</p>
</li>
<li><p> For more arguments, use <code>..1</code>, <code>..2</code>, <code>..3</code> etc
</p>
</li></ul>

<p>This syntax allows you to create very compact anonymous functions.</p>
</td></tr>
<tr><td><code id="slide_period2_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to the mapped function.</p>
</td></tr>
<tr><td><code id="slide_period2_+3A_.every">.every</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[positive integer(1)]&#8288;</code>
</p>
<p>The number of periods to group together.
</p>
<p>For example, if the period was set to <code>"year"</code> with an every value of <code>2</code>,
then the years 1970 and 1971 would be placed in the same group.</p>
</td></tr>
<tr><td><code id="slide_period2_+3A_.origin">.origin</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[Date(1) / POSIXct(1) / POSIXlt(1) / NULL]&#8288;</code>
</p>
<p>The reference date time value. The default when left as <code>NULL</code> is the
epoch time of <code style="white-space: pre;">&#8288;1970-01-01 00:00:00&#8288;</code>, <em>in the time zone of the index</em>.
</p>
<p>This is generally used to define the anchor time to count from, which is
relevant when the every value is <code style="white-space: pre;">&#8288;&gt; 1&#8288;</code>.</p>
</td></tr>
<tr><td><code id="slide_period2_+3A_.before">.before</code>, <code id="slide_period2_+3A_.after">.after</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integer(1) / Inf]&#8288;</code>
</p>
<p>The number of values before or after the current element to
include in the sliding window. Set to <code>Inf</code> to select all elements
before or after the current element. Negative values are allowed, which
allows you to &quot;look forward&quot; from the current element if used as the
<code>.before</code> value, or &quot;look backwards&quot; if used as <code>.after</code>.</p>
</td></tr>
<tr><td><code id="slide_period2_+3A_.complete">.complete</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical(1)]&#8288;</code>
</p>
<p>Should the function be evaluated on complete windows only? If <code>FALSE</code>,
the default, then partial computations will be allowed.</p>
</td></tr>
<tr><td><code id="slide_period2_+3A_.ptype">.ptype</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[vector(0) / NULL]&#8288;</code>
</p>
<p>A prototype corresponding to the type of the output.
</p>
<p>If <code>NULL</code>, the default, the output type is determined by computing the
common type across the results of the calls to <code>.f</code>.
</p>
<p>If supplied, the result of each call to <code>.f</code> will be cast to that type,
and the final output will have that type.
</p>
<p>If <code>getOption("vctrs.no_guessing")</code> is <code>TRUE</code>, the <code>.ptype</code> must be
supplied. This is a way to make production code demand fixed types.</p>
</td></tr>
<tr><td><code id="slide_period2_+3A_.names_to">.names_to</code></td>
<td>
<p>This controls what to do with input names supplied in <code>...</code>.
</p>

<ul>
<li><p> By default, input names are <a href="rlang.html#topic+zap">zapped</a>.
</p>
</li>
<li><p> If a string, specifies a column where the input names will be
copied. These names are often useful to identify rows with
their original input. If a column name is supplied and <code>...</code> is
not named, an integer column is used instead.
</p>
</li>
<li><p> If <code>NULL</code>, the input names are used as row names.
</p>
</li></ul>
</td></tr>
<tr><td><code id="slide_period2_+3A_.name_repair">.name_repair</code></td>
<td>
<p>One of <code>"unique"</code>, <code>"universal"</code>, <code>"check_unique"</code>,
<code>"unique_quiet"</code>, or  <code>"universal_quiet"</code>. See <code><a href="vctrs.html#topic+vec_as_names">vec_as_names()</a></code> for the
meaning of these options.
</p>
<p>With <code>vec_rbind()</code>, the repair function is applied to all inputs
separately. This is because <code>vec_rbind()</code> needs to align their
columns before binding the rows, and thus needs all inputs to
have unique names. On the other hand, <code>vec_cbind()</code> applies the
repair function after all inputs have been concatenated together
in a final data frame. Hence <code>vec_cbind()</code> allows the more
permissive minimal names repair.</p>
</td></tr>
<tr><td><code id="slide_period2_+3A_.size">.size</code></td>
<td>
<p>If, <code>NULL</code>, the default, will determine the number of rows in
<code>vec_cbind()</code> output by using the tidyverse <a href="vctrs.html#topic+vector_recycling_rules">recycling rules</a>.
</p>
<p>Alternatively, specify the desired number of rows, and any inputs of length
1 will be recycled appropriately.</p>
</td></tr>
<tr><td><code id="slide_period2_+3A_.l">.l</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[list]&#8288;</code>
</p>
<p>A list of vectors. The length of <code>.l</code> determines the
number of arguments that <code>.f</code> will be called with. If <code>.l</code> has names,
they will be used as named arguments to <code>.f</code>. Elements of <code>.l</code> with size
1 will be recycled.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector fulfilling the following invariants:
</p>


<h4><code>slide_period2()</code></h4>


<ul>
<li> <p><code>vec_size(slide_period2(.x, .y)) == vec_size(unique(warp::warp_distance(.i)))</code>
</p>
</li>
<li> <p><code>vec_ptype(slide_period2(.x, .y)) == list()</code>
</p>
</li></ul>




<h4><code>slide_period2_vec()</code> and <code style="white-space: pre;">&#8288;slide_period2_*()&#8288;</code> variants</h4>


<ul>
<li> <p><code>vec_size(slide_period2_vec(.x, .y)) == vec_size(unique(warp::warp_distance(.i)))</code>
</p>
</li>
<li> <p><code>vec_size(slide_period2_vec(.x, .y)[[1]]) == 1L</code>
</p>
</li>
<li> <p><code>vec_ptype(slide_period2_vec(.x, .y, .ptype = ptype)) == ptype</code>
</p>
</li></ul>




<h4><code>pslide_period()</code></h4>


<ul>
<li> <p><code>vec_size(pslide_period(.l)) == vec_size(unique(warp::warp_distance(.i)))</code>
</p>
</li>
<li> <p><code>vec_ptype(pslide_period(.l)) == list()</code>
</p>
</li></ul>




<h4><code>pslide_period_vec()</code> and <code style="white-space: pre;">&#8288;pslide_period_*()&#8288;</code> variants</h4>


<ul>
<li> <p><code>vec_size(pslide_period_vec(.l)) == vec_size(unique(warp::warp_distance(.i)))</code>
</p>
</li>
<li> <p><code>vec_size(pslide_period_vec(.l)[[1]]) == 1L</code>
</p>
</li>
<li> <p><code>vec_ptype(pslide_period_vec(.l, .ptype = ptype)) == ptype</code>
</p>
</li></ul>




<h3>See Also</h3>

<p><code><a href="#topic+slide2">slide2()</a></code>, <code><a href="#topic+slide_index2">slide_index2()</a></code>, <code><a href="#topic+slide_period">slide_period()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>i &lt;- as.Date("2019-01-28") + 0:5

slide_period2(
  .x = 1:6,
  .y = i,
  .i = i,
  .period = "month",
  .f = ~data.frame(x = .x, i = .y)
)

pslide_period(
  .l = list(1:6, 7:12, i),
  .i = i,
  .period = "month",
  .f = ~data.frame(x = .x, y = .y, i = ..3)
)

</code></pre>

<hr>
<h2 id='slide2'>Slide over multiple inputs simultaneously</h2><span id='topic+slide2'></span><span id='topic+slide2_vec'></span><span id='topic+slide2_dbl'></span><span id='topic+slide2_int'></span><span id='topic+slide2_lgl'></span><span id='topic+slide2_chr'></span><span id='topic+slide2_dfr'></span><span id='topic+slide2_dfc'></span><span id='topic+pslide'></span><span id='topic+pslide_vec'></span><span id='topic+pslide_dbl'></span><span id='topic+pslide_int'></span><span id='topic+pslide_lgl'></span><span id='topic+pslide_chr'></span><span id='topic+pslide_dfr'></span><span id='topic+pslide_dfc'></span>

<h3>Description</h3>

<p>These are variants of <code><a href="#topic+slide">slide()</a></code> that iterate over multiple inputs in
parallel. They are parallel in the sense that each input is processed in
parallel with the others, not in the sense of multicore computing. These
functions work similarly to <code>map2()</code> and <code>pmap()</code> from purrr.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slide2(
  .x,
  .y,
  .f,
  ...,
  .before = 0L,
  .after = 0L,
  .step = 1L,
  .complete = FALSE
)

slide2_vec(
  .x,
  .y,
  .f,
  ...,
  .before = 0L,
  .after = 0L,
  .step = 1L,
  .complete = FALSE,
  .ptype = NULL
)

slide2_dbl(
  .x,
  .y,
  .f,
  ...,
  .before = 0L,
  .after = 0L,
  .step = 1L,
  .complete = FALSE
)

slide2_int(
  .x,
  .y,
  .f,
  ...,
  .before = 0L,
  .after = 0L,
  .step = 1L,
  .complete = FALSE
)

slide2_lgl(
  .x,
  .y,
  .f,
  ...,
  .before = 0L,
  .after = 0L,
  .step = 1L,
  .complete = FALSE
)

slide2_chr(
  .x,
  .y,
  .f,
  ...,
  .before = 0L,
  .after = 0L,
  .step = 1L,
  .complete = FALSE
)

slide2_dfr(
  .x,
  .y,
  .f,
  ...,
  .before = 0L,
  .after = 0L,
  .step = 1L,
  .complete = FALSE,
  .names_to = rlang::zap(),
  .name_repair = c("unique", "universal", "check_unique")
)

slide2_dfc(
  .x,
  .y,
  .f,
  ...,
  .before = 0L,
  .after = 0L,
  .step = 1L,
  .complete = FALSE,
  .size = NULL,
  .name_repair = c("unique", "universal", "check_unique", "minimal")
)

pslide(.l, .f, ..., .before = 0L, .after = 0L, .step = 1L, .complete = FALSE)

pslide_vec(
  .l,
  .f,
  ...,
  .before = 0L,
  .after = 0L,
  .step = 1L,
  .complete = FALSE,
  .ptype = NULL
)

pslide_dbl(
  .l,
  .f,
  ...,
  .before = 0L,
  .after = 0L,
  .step = 1L,
  .complete = FALSE
)

pslide_int(
  .l,
  .f,
  ...,
  .before = 0L,
  .after = 0L,
  .step = 1L,
  .complete = FALSE
)

pslide_lgl(
  .l,
  .f,
  ...,
  .before = 0L,
  .after = 0L,
  .step = 1L,
  .complete = FALSE
)

pslide_chr(
  .l,
  .f,
  ...,
  .before = 0L,
  .after = 0L,
  .step = 1L,
  .complete = FALSE
)

pslide_dfr(
  .l,
  .f,
  ...,
  .before = 0L,
  .after = 0L,
  .step = 1L,
  .complete = FALSE,
  .names_to = rlang::zap(),
  .name_repair = c("unique", "universal", "check_unique")
)

pslide_dfc(
  .l,
  .f,
  ...,
  .before = 0L,
  .after = 0L,
  .step = 1L,
  .complete = FALSE,
  .size = NULL,
  .name_repair = c("unique", "universal", "check_unique", "minimal")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slide2_+3A_.x">.x</code>, <code id="slide2_+3A_.y">.y</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[vector]&#8288;</code>
</p>
<p>Vectors to iterate over. Vectors of size 1 will be recycled.</p>
</td></tr>
<tr><td><code id="slide2_+3A_.f">.f</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[function / formula]&#8288;</code>
</p>
<p>If a <strong>function</strong>, it is used as is.
</p>
<p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function. There
are three ways to refer to the arguments:
</p>

<ul>
<li><p> For a single argument function, use <code>.</code>
</p>
</li>
<li><p> For a two argument function, use <code>.x</code> and <code>.y</code>
</p>
</li>
<li><p> For more arguments, use <code>..1</code>, <code>..2</code>, <code>..3</code> etc
</p>
</li></ul>

<p>This syntax allows you to create very compact anonymous functions.</p>
</td></tr>
<tr><td><code id="slide2_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to the mapped function.</p>
</td></tr>
<tr><td><code id="slide2_+3A_.before">.before</code>, <code id="slide2_+3A_.after">.after</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integer(1) / Inf]&#8288;</code>
</p>
<p>The number of values before or after the current element to
include in the sliding window. Set to <code>Inf</code> to select all elements
before or after the current element. Negative values are allowed, which
allows you to &quot;look forward&quot; from the current element if used as the
<code>.before</code> value, or &quot;look backwards&quot; if used as <code>.after</code>.</p>
</td></tr>
<tr><td><code id="slide2_+3A_.step">.step</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[positive integer(1)]&#8288;</code>
</p>
<p>The number of elements to shift the window forward between function calls.</p>
</td></tr>
<tr><td><code id="slide2_+3A_.complete">.complete</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical(1)]&#8288;</code>
</p>
<p>Should the function be evaluated on complete windows only? If <code>FALSE</code>,
the default, then partial computations will be allowed.</p>
</td></tr>
<tr><td><code id="slide2_+3A_.ptype">.ptype</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[vector(0) / NULL]&#8288;</code>
</p>
<p>A prototype corresponding to the type of the output.
</p>
<p>If <code>NULL</code>, the default, the output type is determined by computing the
common type across the results of the calls to <code>.f</code>.
</p>
<p>If supplied, the result of each call to <code>.f</code> will be cast to that type,
and the final output will have that type.
</p>
<p>If <code>getOption("vctrs.no_guessing")</code> is <code>TRUE</code>, the <code>.ptype</code> must be
supplied. This is a way to make production code demand fixed types.</p>
</td></tr>
<tr><td><code id="slide2_+3A_.names_to">.names_to</code></td>
<td>
<p>This controls what to do with input names supplied in <code>...</code>.
</p>

<ul>
<li><p> By default, input names are <a href="rlang.html#topic+zap">zapped</a>.
</p>
</li>
<li><p> If a string, specifies a column where the input names will be
copied. These names are often useful to identify rows with
their original input. If a column name is supplied and <code>...</code> is
not named, an integer column is used instead.
</p>
</li>
<li><p> If <code>NULL</code>, the input names are used as row names.
</p>
</li></ul>
</td></tr>
<tr><td><code id="slide2_+3A_.name_repair">.name_repair</code></td>
<td>
<p>One of <code>"unique"</code>, <code>"universal"</code>, <code>"check_unique"</code>,
<code>"unique_quiet"</code>, or  <code>"universal_quiet"</code>. See <code><a href="vctrs.html#topic+vec_as_names">vec_as_names()</a></code> for the
meaning of these options.
</p>
<p>With <code>vec_rbind()</code>, the repair function is applied to all inputs
separately. This is because <code>vec_rbind()</code> needs to align their
columns before binding the rows, and thus needs all inputs to
have unique names. On the other hand, <code>vec_cbind()</code> applies the
repair function after all inputs have been concatenated together
in a final data frame. Hence <code>vec_cbind()</code> allows the more
permissive minimal names repair.</p>
</td></tr>
<tr><td><code id="slide2_+3A_.size">.size</code></td>
<td>
<p>If, <code>NULL</code>, the default, will determine the number of rows in
<code>vec_cbind()</code> output by using the tidyverse <a href="vctrs.html#topic+vector_recycling_rules">recycling rules</a>.
</p>
<p>Alternatively, specify the desired number of rows, and any inputs of length
1 will be recycled appropriately.</p>
</td></tr>
<tr><td><code id="slide2_+3A_.l">.l</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[list]&#8288;</code>
</p>
<p>A list of vectors. The length of <code>.l</code> determines the
number of arguments that <code>.f</code> will be called with. If <code>.l</code> has names,
they will be used as named arguments to <code>.f</code>. Elements of <code>.l</code> with size
1 will be recycled.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector fulfilling the following invariants:
</p>


<h4><code>slide2()</code></h4>


<ul>
<li> <p><code>vec_size(slide2(.x, .y)) == vec_size_common(.x, .y)</code>
</p>
</li>
<li> <p><code>vec_ptype(slide2(.x, .y)) == list()</code>
</p>
</li></ul>




<h4><code>slide2_vec()</code> and <code style="white-space: pre;">&#8288;slide2_*()&#8288;</code> variants</h4>


<ul>
<li> <p><code>vec_size(slide2_vec(.x, .y)) == vec_size_common(.x, .y)</code>
</p>
</li>
<li> <p><code>vec_size(slide2_vec(.x, .y)[[1]]) == 1L</code>
</p>
</li>
<li> <p><code>vec_ptype(slide2_vec(.x, .y, .ptype = ptype)) == ptype</code>
</p>
</li></ul>




<h4><code>pslide()</code></h4>


<ul>
<li> <p><code>vec_size(pslide(.l)) == vec_size_common(!!! .l)</code>
</p>
</li>
<li> <p><code>vec_ptype(pslide(.l)) == list()</code>
</p>
</li></ul>




<h4><code>pslide_vec()</code> and <code style="white-space: pre;">&#8288;pslide_*()&#8288;</code> variants</h4>


<ul>
<li> <p><code>vec_size(pslide_vec(.l)) == vec_size_common(!!! .l)</code>
</p>
</li>
<li> <p><code>vec_size(pslide_vec(.l)[[1]]) == 1L</code>
</p>
</li>
<li> <p><code>vec_ptype(pslide_vec(.l, .ptype = ptype)) == ptype</code>
</p>
</li></ul>




<h3>See Also</h3>

<p><code><a href="#topic+slide">slide()</a></code>, <code><a href="#topic+slide_index2">slide_index2()</a></code>, <code><a href="#topic+hop_index2">hop_index2()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Slide along two inputs at once
slide2(1:4, 5:8, ~list(.x, .y), .before = 2)

# Or, for more than two, use `pslide()`
pslide(list(1:4, 5:8, 9:12), ~list(.x, .y, ..3), .before = 2)

# You can even slide along the rows of multiple data frames of
# equal size at once
set.seed(16)
x &lt;- data.frame(a = rnorm(5), b = rnorm(5))
y &lt;- data.frame(c = letters[1:5], d = letters[6:10])

row_return &lt;- function(x_rows, y_rows) {
  if (sum(x_rows$a) &lt; 0) {
    x_rows
  } else {
    y_rows
  }
}

slide2(x, y, row_return, .before = 1, .after = 2)

</code></pre>

<hr>
<h2 id='slider-package'>slider: Sliding Window Functions</h2><span id='topic+slider-package'></span><span id='topic+_PACKAGE'></span>

<h3>Description</h3>

<p>Provides type-stable rolling window functions over any R data type. Cumulative and expanding windows are also supported. For more advanced usage, an index can be used as a secondary vector that defines how sliding windows are to be created.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Davis Vaughan <a href="mailto:davis@posit.co">davis@posit.co</a>
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Posit Software, PBC [copyright holder, funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/r-lib/slider">https://github.com/r-lib/slider</a>
</p>
</li>
<li> <p><a href="https://slider.r-lib.org">https://slider.r-lib.org</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/r-lib/slider/issues">https://github.com/r-lib/slider/issues</a>
</p>
</li></ul>


<hr>
<h2 id='summary-index'>Specialized sliding functions relative to an index</h2><span id='topic+summary-index'></span><span id='topic+slide_index_sum'></span><span id='topic+slide_index_prod'></span><span id='topic+slide_index_mean'></span><span id='topic+slide_index_min'></span><span id='topic+slide_index_max'></span><span id='topic+slide_index_all'></span><span id='topic+slide_index_any'></span>

<h3>Description</h3>

<p>These functions are specialized variants of the most common ways that
<code><a href="#topic+slide_index">slide_index()</a></code> is generally used. Notably, <code><a href="#topic+slide_index_sum">slide_index_sum()</a></code> can be used
for rolling sums relative to an index (like a Date column), and
<code><a href="#topic+slide_index_mean">slide_index_mean()</a></code> can be used for rolling averages.
</p>
<p>These specialized variants are <em>much</em> faster and more memory efficient than
using an otherwise equivalent call constructed with <code><a href="#topic+slide_index_dbl">slide_index_dbl()</a></code>
or <code><a href="#topic+slide_index_lgl">slide_index_lgl()</a></code>, especially with a very wide window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slide_index_sum(
  x,
  i,
  ...,
  before = 0L,
  after = 0L,
  complete = FALSE,
  na_rm = FALSE
)

slide_index_prod(
  x,
  i,
  ...,
  before = 0L,
  after = 0L,
  complete = FALSE,
  na_rm = FALSE
)

slide_index_mean(
  x,
  i,
  ...,
  before = 0L,
  after = 0L,
  complete = FALSE,
  na_rm = FALSE
)

slide_index_min(
  x,
  i,
  ...,
  before = 0L,
  after = 0L,
  complete = FALSE,
  na_rm = FALSE
)

slide_index_max(
  x,
  i,
  ...,
  before = 0L,
  after = 0L,
  complete = FALSE,
  na_rm = FALSE
)

slide_index_all(
  x,
  i,
  ...,
  before = 0L,
  after = 0L,
  complete = FALSE,
  na_rm = FALSE
)

slide_index_any(
  x,
  i,
  ...,
  before = 0L,
  after = 0L,
  complete = FALSE,
  na_rm = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary-index_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[vector]&#8288;</code>
</p>
<p>A vector to compute the sliding function on.
</p>

<ul>
<li><p> For sliding sum, mean, prod, min, and max, <code>x</code> will be cast to a double
vector with <code><a href="vctrs.html#topic+vec_cast">vctrs::vec_cast()</a></code>.
</p>
</li>
<li><p> For sliding any and all, <code>x</code> will be cast to a logical vector with
<code><a href="vctrs.html#topic+vec_cast">vctrs::vec_cast()</a></code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="summary-index_+3A_i">i</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[vector]&#8288;</code>
</p>
<p>The index vector that determines the window sizes. It is fairly common to
supply a date vector as the index, but not required.
</p>
<p>There are 3 restrictions on the index:
</p>

<ul>
<li><p> The size of the index must match the size of <code>.x</code>, they will not be
recycled to their common size.
</p>
</li>
<li><p> The index must be an <em>increasing</em> vector, but duplicate values
are allowed.
</p>
</li>
<li><p> The index cannot have missing values.
</p>
</li></ul>
</td></tr>
<tr><td><code id="summary-index_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="summary-index_+3A_before">before</code>, <code id="summary-index_+3A_after">after</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[vector(1) / function / Inf]&#8288;</code>
</p>

<ul>
<li><p> If a vector of size 1, these represent the number of values before or
after the current element of <code>.i</code> to include in the sliding window.
Negative values are allowed, which allows you to &quot;look forward&quot; from the
current element if used as the <code>.before</code> value, or &quot;look backwards&quot; if used
as <code>.after</code>. Boundaries are computed from these elements as <code>.i - .before</code>
and <code>.i + .after</code>. Any object that can be added or subtracted from <code>.i</code>
with <code>+</code> and <code>-</code> can be used. For example, a lubridate period, such as
<code><a href="lubridate.html#topic+period">lubridate::weeks()</a></code>.
</p>
</li>
<li><p> If <code>Inf</code>, this selects all elements before or after the current element.
</p>
</li>
<li><p> If a function, or a one-sided formula which can be coerced to a function,
it is applied to <code>.i</code> to compute the boundaries. Note that this function
will only be applied to the <em>unique</em> values of <code>.i</code>, so it should not rely
on the original length of <code>.i</code> in any way. This is useful for applying a
complex arithmetic operation that can't be expressed with a single <code>-</code> or
<code>+</code> operation. One example would be to use <code><a href="lubridate.html#topic+mplus">lubridate::add_with_rollback()</a></code>
to avoid invalid dates at the end of the month.
</p>
</li></ul>

<p>The ranges that result from applying <code>.before</code> and <code>.after</code> have the same
3 restrictions as <code>.i</code> itself.</p>
</td></tr>
<tr><td><code id="summary-index_+3A_complete">complete</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical(1)]&#8288;</code>
</p>
<p>Should the function be evaluated on complete windows only? If <code>FALSE</code>,
the default, then partial computations will be allowed.</p>
</td></tr>
<tr><td><code id="summary-index_+3A_na_rm">na_rm</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical(1)]&#8288;</code>
</p>
<p>Should missing values be removed from the computation?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more details about the implementation, see the help page of
<code><a href="#topic+slide_sum">slide_sum()</a></code>.
</p>


<h3>Value</h3>

<p>A vector the same size as <code>x</code> containing the result of applying the
summary function over the sliding windows.
</p>

<ul>
<li><p> For sliding sum, mean, prod, min, and max, a double vector will be
returned.
</p>
</li>
<li><p> For sliding any and all, a logical vector will be returned.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+slide_sum">slide_sum()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(1, 5, 3, 2, 6, 10)
i &lt;- as.Date("2019-01-01") + c(0, 1, 3, 4, 6, 8)

# `slide_index_sum()` can be used for rolling sums relative to an index,
# allowing you to "respect gaps" in your series. Notice that the rolling
# sum in row 3 is only computed from `2019-01-04` and `2019-01-02` since
# `2019-01-01` is more than two days before the current date.
data.frame(
  i = i,
  x = x,
  roll = slide_index_sum(x, i, before = 2)
)

# `slide_index_mean()` can be used for rolling averages
slide_index_mean(x, i, before = 2)

# Only evaluate the sum on windows that have the potential to be complete
slide_index_sum(x, i, before = 2, after = 1, complete = TRUE)
</code></pre>

<hr>
<h2 id='summary-slide'>Specialized sliding functions</h2><span id='topic+summary-slide'></span><span id='topic+slide_sum'></span><span id='topic+slide_prod'></span><span id='topic+slide_mean'></span><span id='topic+slide_min'></span><span id='topic+slide_max'></span><span id='topic+slide_all'></span><span id='topic+slide_any'></span>

<h3>Description</h3>

<p>These functions are specialized variants of the most common ways that
<code><a href="#topic+slide">slide()</a></code> is generally used. Notably, <code><a href="#topic+slide_sum">slide_sum()</a></code> can be used for
rolling sums, and <code><a href="#topic+slide_mean">slide_mean()</a></code> can be used for rolling averages.
</p>
<p>These specialized variants are <em>much</em> faster and more memory efficient
than using an otherwise equivalent call constructed with <code><a href="#topic+slide_dbl">slide_dbl()</a></code>
or <code><a href="#topic+slide_lgl">slide_lgl()</a></code>, especially with a very wide window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slide_sum(
  x,
  ...,
  before = 0L,
  after = 0L,
  step = 1L,
  complete = FALSE,
  na_rm = FALSE
)

slide_prod(
  x,
  ...,
  before = 0L,
  after = 0L,
  step = 1L,
  complete = FALSE,
  na_rm = FALSE
)

slide_mean(
  x,
  ...,
  before = 0L,
  after = 0L,
  step = 1L,
  complete = FALSE,
  na_rm = FALSE
)

slide_min(
  x,
  ...,
  before = 0L,
  after = 0L,
  step = 1L,
  complete = FALSE,
  na_rm = FALSE
)

slide_max(
  x,
  ...,
  before = 0L,
  after = 0L,
  step = 1L,
  complete = FALSE,
  na_rm = FALSE
)

slide_all(
  x,
  ...,
  before = 0L,
  after = 0L,
  step = 1L,
  complete = FALSE,
  na_rm = FALSE
)

slide_any(
  x,
  ...,
  before = 0L,
  after = 0L,
  step = 1L,
  complete = FALSE,
  na_rm = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary-slide_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[vector]&#8288;</code>
</p>
<p>A vector to compute the sliding function on.
</p>

<ul>
<li><p> For sliding sum, mean, prod, min, and max, <code>x</code> will be cast to a double
vector with <code><a href="vctrs.html#topic+vec_cast">vctrs::vec_cast()</a></code>.
</p>
</li>
<li><p> For sliding any and all, <code>x</code> will be cast to a logical vector with
<code><a href="vctrs.html#topic+vec_cast">vctrs::vec_cast()</a></code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="summary-slide_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="summary-slide_+3A_before">before</code>, <code id="summary-slide_+3A_after">after</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integer(1) / Inf]&#8288;</code>
</p>
<p>The number of values before or after the current element to
include in the sliding window. Set to <code>Inf</code> to select all elements
before or after the current element. Negative values are allowed, which
allows you to &quot;look forward&quot; from the current element if used as the
<code>.before</code> value, or &quot;look backwards&quot; if used as <code>.after</code>.</p>
</td></tr>
<tr><td><code id="summary-slide_+3A_step">step</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[positive integer(1)]&#8288;</code>
</p>
<p>The number of elements to shift the window forward between function calls.</p>
</td></tr>
<tr><td><code id="summary-slide_+3A_complete">complete</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical(1)]&#8288;</code>
</p>
<p>Should the function be evaluated on complete windows only? If <code>FALSE</code>,
the default, then partial computations will be allowed.</p>
</td></tr>
<tr><td><code id="summary-slide_+3A_na_rm">na_rm</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical(1)]&#8288;</code>
</p>
<p>Should missing values be removed from the computation?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that these functions are <em>not</em> generic and do not respect method
dispatch of the corresponding summary function (i.e. <code><a href="base.html#topic+sum">base::sum()</a></code>,
<code><a href="base.html#topic+mean">base::mean()</a></code>). Input will always be cast to a double or logical vector
using <code><a href="vctrs.html#topic+vec_cast">vctrs::vec_cast()</a></code>, and an internal method for computing the summary
function will be used.
</p>
<p>Due to the structure of segment trees, <code>slide_mean()</code> does not perform the
same &quot;two pass&quot; mean that <code>mean()</code> does (the intention of the second pass is
to perform a floating point error correction). Because of this, there may be
small differences between <code>slide_mean(x)</code> and <code>slide_dbl(x, mean)</code> in some
cases.
</p>


<h3>Value</h3>

<p>A vector the same size as <code>x</code> containing the result of applying the
summary function over the sliding windows.
</p>

<ul>
<li><p> For sliding sum, mean, prod, min, and max, a double vector will be
returned.
</p>
</li>
<li><p> For sliding any and all, a logical vector will be returned.
</p>
</li></ul>



<h3>Implementation</h3>

<p>These variants are implemented using a data structure known as a
<em>segment tree</em>, which allows for extremely fast repeated range queries
without loss of precision.
</p>
<p>One alternative to segment trees is to directly recompute the summary
function on each full window. This is what is done by using, for example,
<code>slide_dbl(x, sum)</code>. This is extremely slow with large window sizes and
wastes a lot of effort recomputing nearly the same information on each
window. It can be made slightly faster by moving the sum to C to avoid
intermediate allocations, but it still fairly slow.
</p>
<p>A second alternative is to use an <em>online</em> algorithm, which uses information
from the previous window to compute the next window. These are extremely
fast, only requiring a single pass through the data, but often suffer from
numerical instability issues.
</p>
<p>Segment trees are an attempt to reconcile the performance issues of the
direct approach with the numerical issues of the online approach. The
performance of segment trees isn't quite as fast as online algorithms, but is
close enough that it should be usable on most large data sets without any
issues. Unlike online algorithms, segment trees don't suffer from any
extra numerical instability issues.
</p>


<h3>References</h3>

<p>Leis, Kundhikanjana, Kemper, and Neumann (2015). &quot;Efficient Processing of
Window Functions in Analytical SQL Queries&quot;.
https://dl.acm.org/doi/10.14778/2794367.2794375
</p>


<h3>See Also</h3>

<p><code><a href="#topic+slide_index_sum">slide_index_sum()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(1, 5, 3, 2, 6, 10)

# `slide_sum()` can be used for rolling sums.
# The following are equivalent, but `slide_sum()` is much faster.
slide_sum(x, before = 2)
slide_dbl(x, sum, .before = 2)

# `slide_mean()` can be used for rolling averages
slide_mean(x, before = 2)

# Only evaluate the sum on complete windows
slide_sum(x, before = 2, after = 1, complete = TRUE)

# Skip every other calculation
slide_sum(x, before = 2, step = 2)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
