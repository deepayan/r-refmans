<!DOCTYPE html><html><head><title>Help for package timeseriesdb</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {timeseriesdb}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as.meta'><p>Convert a List into a Metadata Object</p></a></li>
<li><a href='#as.tsmeta'><p>Convert a List into a Metadata Object</p></a></li>
<li><a href='#change_access_level'><p>Change the Access Level of a Time Series</p></a></li>
<li><a href='#create_meta'><p>Create Meta Data Objects</p></a></li>
<li><a href='#create_tsmeta'><p>Meta in</p></a></li>
<li><a href='#date_to_index'><p>Convert date-likes to time index</p></a></li>
<li><a href='#db_access_level_create'><p>Create a New Role (Access Level)</p></a></li>
<li><a href='#db_access_level_delete'><p>Delete a role in access levels table</p></a></li>
<li><a href='#db_access_level_list'><p>Get All Access Levels and Their Description</p></a></li>
<li><a href='#db_access_level_set_default'><p>Set the Default Access Level</p></a></li>
<li><a href='#db_call_function'><p>Helper to construct SQL function calls</p></a></li>
<li><a href='#db_collection_add_ts'><p>Bundles Keys into an Existing Collection or Adds a New Collection</p></a></li>
<li><a href='#db_collection_delete'><p>Remove an Entire Time Series Key Collection</p></a></li>
<li><a href='#db_collection_get_keys'><p>Get All Keys in a User Collection</p></a></li>
<li><a href='#db_collection_get_last_update'><p>Get the last update of a collection for a specific User</p></a></li>
<li><a href='#db_collection_list'><p>List All Available Collections for a Specific User</p></a></li>
<li><a href='#db_collection_read_metadata'><p>Read Metadata for a Collection</p></a></li>
<li><a href='#db_collection_read_ts'><p>Read all Time Series in a User Collection</p></a></li>
<li><a href='#db_collection_remove_ts'><p>Remove Keys From a User's Collection</p></a></li>
<li><a href='#db_connection_close'><p>Close an Existing Database Connection</p></a></li>
<li><a href='#db_connection_create'><p>Create Database Connection</p></a></li>
<li><a href='#db_dataset_create'><p>Create a New Dataset</p></a></li>
<li><a href='#db_dataset_delete'><p>Irrevocably Delete All Time Series in a Set and the Set Itself</p></a></li>
<li><a href='#db_dataset_get_keys'><p>Get All Time Series Keys in a Given Set</p></a></li>
<li><a href='#db_dataset_get_last_update'><p>Get the dataset last update</p></a></li>
<li><a href='#db_dataset_get_latest_release'><p>Get the latest Release for Given Datasets</p></a></li>
<li><a href='#db_dataset_get_next_release'><p>Get Next Release Date for Given Datasets</p></a></li>
<li><a href='#db_dataset_get_release'><p>Get the latest Release for Given Datasets</p></a></li>
<li><a href='#db_dataset_list'><p>Get All Available Datasets and Their Description</p></a></li>
<li><a href='#db_dataset_read_metadata'><p>Read Dataset Meta Information</p></a></li>
<li><a href='#db_dataset_read_ts'><p>Read all Time Series in a Dataset</p></a></li>
<li><a href='#db_dataset_trim_history'><p>Remove Vintages from the Beginning of Dataset</p></a></li>
<li><a href='#db_dataset_update_metadata'><p>Update Description and/or Metadata of a Dataset</p></a></li>
<li><a href='#db_get_installed_version'><p>Get the Currently Installed Version of Timeseriesdb</p></a></li>
<li><a href='#db_grant_to_admin'><p>GRANT all rights on a (temp) table to schema admin</p></a></li>
<li><a href='#db_meta_get_latest_validity'><p>Get Latest Validity for Metadata of a Given Time Series</p></a></li>
<li><a href='#db_metadata_read'><p>Read Time Series Metadata</p></a></li>
<li><a href='#db_metadata_store'><p>Store Time Series Metadata to PostgreSQL</p></a></li>
<li><a href='#db_release_cancel'><p>Cancel a Scheduled Release</p></a></li>
<li><a href='#db_release_create'><p>Create an Entry in the Release Calendar</p></a></li>
<li><a href='#db_release_list'><p>List Data on Registered Releases</p></a></li>
<li><a href='#db_release_update'><p>Update an Existing Release Record</p></a></li>
<li><a href='#db_ts_assign_dataset'><p>Assign Time Series Identifiers to a Dataset</p></a></li>
<li><a href='#db_ts_delete'><p>Remove Time Series from the Database</p></a></li>
<li><a href='#db_ts_delete_latest_version'><p>Delete the Latest Vintage of a Time Series</p></a></li>
<li><a href='#db_ts_find_keys'><p>Get All keys that follow a pattern</p></a></li>
<li><a href='#db_ts_get_access_level'><p>Find Out About the Access Level of a Vintage</p></a></li>
<li><a href='#db_ts_get_dataset'><p>Find Datasets Given a Set</p></a></li>
<li><a href='#db_ts_get_last_update'><p>Get the times series last update</p></a></li>
<li><a href='#db_ts_read'><p>Read Time Series From PostgreSQL into R</p></a></li>
<li><a href='#db_ts_read_history'><p>Read the Entire History of a Time Series</p></a></li>
<li><a href='#db_ts_rename'><p>Rename Time Series by Assigning a New Key</p></a></li>
<li><a href='#db_ts_store'><p>Store a Time Series to the Database</p></a></li>
<li><a href='#db_ts_trim_history'><p>Remove Vintages from the Beginning</p></a></li>
<li><a href='#db_with_tmp_read'><p>Helper to Create and Populate a Temporary Table for Fast Reading</p></a></li>
<li><a href='#has_depth_2'><p>Test if a list has exactly depth 2</p></a></li>
<li><a href='#index_to_date'><p>Helper Function for Date Operations</p></a></li>
<li><a href='#install_timeseriesdb'><p>Install timeseriesdb</p></a></li>
<li><a href='#json_to_ts'><p>Convert JSON Representation of a Time Series into R Time Series Objects</p></a></li>
<li><a href='#kof_ts'><p>KOF indicators</p></a></li>
<li><a href='#param_defs'><p>Common parameters</p></a></li>
<li><a href='#print.meta'><p>Print Method for meta Object</p></a></li>
<li><a href='#setup_sql_extentions'><p>Install PostgreSQL Schemas and Extensions</p></a></li>
<li><a href='#setup_sql_functions'><p>Install timeseriesdb System Functions</p></a></li>
<li><a href='#setup_sql_grant_rights'><p>Grant execute on timeseriesdb functions</p></a></li>
<li><a href='#setup_sql_roles'><p>Create Roles needed for operation of timeseriesdb</p></a></li>
<li><a href='#setup_sql_tables'><p>Install timeseriesdb System Tables</p></a></li>
<li><a href='#setup_sql_triggers'><p>Install timeseriesdb Triggers</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0-1.1.2</td>
</tr>
<tr>
<td>Title:</td>
<td>A Time Series Database for Official Statistics with R and
PostgreSQL</td>
</tr>
<tr>
<td>Description:</td>
<td>Archive and manage times series data from official statistics. The 'timeseriesdb' package was designed to manage a large catalog of time series from official statistics which are typically published on a monthly, quarterly or yearly basis. Thus timeseriesdb is optimized to handle updates caused by data revision as well as elaborate, multi-lingual meta information. </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0),</td>
</tr>
<tr>
<td>Imports:</td>
<td>RPostgres (&ge; 1.2.0), jsonlite (&ge; 1.1), data.table (&ge;
1.9.4), utils, xts, DBI,</td>
</tr>
<tr>
<td>Suggests:</td>
<td>openxlsx, rstudioapi, dygraphs, rmarkdown, knitr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-03-23</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mbannert/timeseriesdb">https://github.com/mbannert/timeseriesdb</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mbannert/timeseriesdb/issues">https://github.com/mbannert/timeseriesdb/issues</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-03-23 21:30:43 UTC; mbannert</td>
</tr>
<tr>
<td>Author:</td>
<td>Matthias Bannert [aut, cre],
  Severin Th√∂ni [aut],
  Ioan Gabriel Bucur [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matthias Bannert &lt;bannert@kof.ethz.ch&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-03-23 22:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='as.meta'>Convert a List into a Metadata Object</h2><span id='topic+as.meta'></span>

<h3>Description</h3>

<p>Create timeseriesdb specific metadata class. Typically one list per natural language
is converted to a meta description object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.meta(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.meta_+3A_x">x</code></td>
<td>
<p>list of meta data.</p>
</td></tr>
</table>

<hr>
<h2 id='as.tsmeta'>Convert a List into a Metadata Object</h2><span id='topic+as.tsmeta'></span>

<h3>Description</h3>

<p>Create timeseriesdb specific metadata class. Typically one list per natural language
is converted to a meta description object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.tsmeta(meta, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.tsmeta_+3A_meta">meta</code></td>
<td>
<p>list containing meta information. List elements are character strings.</p>
</td></tr>
<tr><td><code id="as.tsmeta_+3A_...">...</code></td>
<td>
<p>additional arguments, passed on to metthods below.</p>
</td></tr>
</table>

<hr>
<h2 id='change_access_level'>Change the Access Level of a Time Series</h2><span id='topic+change_access_level'></span><span id='topic+db_ts_change_access'></span><span id='topic+db_dataset_change_access'></span>

<h3>Description</h3>

<p>Change the Access Level of a Time Series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_ts_change_access(
  con,
  ts_keys,
  access_level,
  valid_from = NULL,
  schema = "timeseries"
)

db_dataset_change_access(
  con,
  dataset,
  access_level,
  valid_from = NULL,
  schema = "timeseries"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="change_access_level_+3A_con">con</code></td>
<td>
<p>RPostgres connection object.</p>
</td></tr>
<tr><td><code id="change_access_level_+3A_ts_keys">ts_keys</code></td>
<td>
<p><strong>character</strong> vector of time series identifiers.</p>
</td></tr>
<tr><td><code id="change_access_level_+3A_access_level">access_level</code></td>
<td>
<p><strong>character</strong> describing the access level of the time series or dataset.</p>
</td></tr>
<tr><td><code id="change_access_level_+3A_valid_from">valid_from</code></td>
<td>
<p>character representation of a date in the form of 'YYYY-MM-DD'. valid_from starts a new version</p>
</td></tr>
<tr><td><code id="change_access_level_+3A_schema">schema</code></td>
<td>
<p><strong>character</strong> name of the database schema. Defaults to 'timeseries'</p>
</td></tr>
<tr><td><code id="change_access_level_+3A_dataset">dataset</code></td>
<td>
<p><strong>character</strong> name of the dataset. Datasets are group of time series.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list containing the parsed JSON status feedback from the DB.
</p>
<p>returns a list containing the parsed JSON status feedback from the DB.
</p>


<h3>See Also</h3>

<p>Other access levels functions: 
<code><a href="#topic+db_access_level_create">db_access_level_create</a>()</code>,
<code><a href="#topic+db_access_level_delete">db_access_level_delete</a>()</code>,
<code><a href="#topic+db_access_level_list">db_access_level_list</a>()</code>,
<code><a href="#topic+db_access_level_set_default">db_access_level_set_default</a>()</code>,
<code><a href="#topic+db_ts_find_keys">db_ts_find_keys</a>()</code>
</p>

<hr>
<h2 id='create_meta'>Create Meta Data Objects</h2><span id='topic+create_meta'></span>

<h3>Description</h3>

<p>Create list based S3 objects to store meta data. Meta data objects can 
be passed on to a plethora of functions including storing to database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_meta(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_meta_+3A_...">...</code></td>
<td>
<p>arguments passed on the respective method.</p>
</td></tr>
</table>

<hr>
<h2 id='create_tsmeta'>Meta in</h2><span id='topic+create_tsmeta'></span>

<h3>Description</h3>

<p>Meta in
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_tsmeta(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_tsmeta_+3A_...">...</code></td>
<td>
<p>arguments passed on the respective method.</p>
</td></tr>
</table>

<hr>
<h2 id='date_to_index'>Convert date-likes to time index</h2><span id='topic+date_to_index'></span>

<h3>Description</h3>

<p>Convert date-likes to time index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date_to_index(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="date_to_index_+3A_x">x</code></td>
<td>
<p>The Date or Y-m-d string to convert</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The numeric representation of the date that can be used with ts
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: date_to_index("2020-07-01")
</code></pre>

<hr>
<h2 id='db_access_level_create'>Create a New Role (Access Level)</h2><span id='topic+db_access_level_create'></span>

<h3>Description</h3>

<p>Creates a new role in the database. Roles represent access levels and together
with the assignment of roles to time series, versions of time series or datasets
define who is allowed to access a particular series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_access_level_create(
  con,
  access_level_name,
  access_level_description = NULL,
  access_level_default = NULL,
  schema = "timeseries"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="db_access_level_create_+3A_con">con</code></td>
<td>
<p>RPostgres connection object.</p>
</td></tr>
<tr><td><code id="db_access_level_create_+3A_access_level_name">access_level_name</code></td>
<td>
<p><strong>character</strong> name of the access level to insert.</p>
</td></tr>
<tr><td><code id="db_access_level_create_+3A_access_level_description">access_level_description</code></td>
<td>
<p><strong>character</strong> description of the access level. Defaults to NA.</p>
</td></tr>
<tr><td><code id="db_access_level_create_+3A_access_level_default">access_level_default</code></td>
<td>
<p>set if the new access level should be the default. Defaults to NA.</p>
</td></tr>
<tr><td><code id="db_access_level_create_+3A_schema">schema</code></td>
<td>
<p><strong>character</strong> name of the database schema. Defaults to 'timeseries'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list containing the parsed JSON status feedback from the DB.
</p>


<h3>See Also</h3>

<p>Other access levels functions: 
<code><a href="#topic+change_access_level">change_access_level</a></code>,
<code><a href="#topic+db_access_level_delete">db_access_level_delete</a>()</code>,
<code><a href="#topic+db_access_level_list">db_access_level_list</a>()</code>,
<code><a href="#topic+db_access_level_set_default">db_access_level_set_default</a>()</code>,
<code><a href="#topic+db_ts_find_keys">db_ts_find_keys</a>()</code>
</p>

<hr>
<h2 id='db_access_level_delete'>Delete a role in access levels table</h2><span id='topic+db_access_level_delete'></span>

<h3>Description</h3>

<p>Delete a role in access levels table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_access_level_delete(con, access_level, schema = "timeseries")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="db_access_level_delete_+3A_con">con</code></td>
<td>
<p>RPostgres connection object.</p>
</td></tr>
<tr><td><code id="db_access_level_delete_+3A_access_level">access_level</code></td>
<td>
<p><strong>character</strong> describing the access level of the time series or dataset.</p>
</td></tr>
<tr><td><code id="db_access_level_delete_+3A_schema">schema</code></td>
<td>
<p><strong>character</strong> name of the database schema. Defaults to 'timeseries'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list containing the parsed JSON status feedback from the DB.
</p>


<h3>See Also</h3>

<p>Other access levels functions: 
<code><a href="#topic+change_access_level">change_access_level</a></code>,
<code><a href="#topic+db_access_level_create">db_access_level_create</a>()</code>,
<code><a href="#topic+db_access_level_list">db_access_level_list</a>()</code>,
<code><a href="#topic+db_access_level_set_default">db_access_level_set_default</a>()</code>,
<code><a href="#topic+db_ts_find_keys">db_ts_find_keys</a>()</code>
</p>

<hr>
<h2 id='db_access_level_list'>Get All Access Levels and Their Description</h2><span id='topic+db_access_level_list'></span>

<h3>Description</h3>

<p>Gets an overview of roles and shows whether a role (aka access level) is
the default level for series stored without an explicitly specified access level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_access_level_list(con, schema = "timeseries")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="db_access_level_list_+3A_con">con</code></td>
<td>
<p>RPostgres connection object.</p>
</td></tr>
<tr><td><code id="db_access_level_list_+3A_schema">schema</code></td>
<td>
<p><strong>character</strong> name of the database schema. Defaults to 'timeseries'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>access levels data.frame with columns 'role' and 'description' and 'is_default'
</p>


<h3>See Also</h3>

<p>Other access levels functions: 
<code><a href="#topic+change_access_level">change_access_level</a></code>,
<code><a href="#topic+db_access_level_create">db_access_level_create</a>()</code>,
<code><a href="#topic+db_access_level_delete">db_access_level_delete</a>()</code>,
<code><a href="#topic+db_access_level_set_default">db_access_level_set_default</a>()</code>,
<code><a href="#topic+db_ts_find_keys">db_ts_find_keys</a>()</code>
</p>

<hr>
<h2 id='db_access_level_set_default'>Set the Default Access Level</h2><span id='topic+db_access_level_set_default'></span>

<h3>Description</h3>

<p>Changes the default access level. Apparently only one access level can be
the default level at a time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_access_level_set_default(con, access_level, schema = "timeseries")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="db_access_level_set_default_+3A_con">con</code></td>
<td>
<p>RPostgres connection object.</p>
</td></tr>
<tr><td><code id="db_access_level_set_default_+3A_access_level">access_level</code></td>
<td>
<p><strong>character</strong> describing the access level of the time series or dataset.</p>
</td></tr>
<tr><td><code id="db_access_level_set_default_+3A_schema">schema</code></td>
<td>
<p><strong>character</strong> name of the database schema. Defaults to 'timeseries'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list containing the parsed JSON status feedback from the DB.
</p>


<h3>See Also</h3>

<p>Other access levels functions: 
<code><a href="#topic+change_access_level">change_access_level</a></code>,
<code><a href="#topic+db_access_level_create">db_access_level_create</a>()</code>,
<code><a href="#topic+db_access_level_delete">db_access_level_delete</a>()</code>,
<code><a href="#topic+db_access_level_list">db_access_level_list</a>()</code>,
<code><a href="#topic+db_ts_find_keys">db_ts_find_keys</a>()</code>
</p>

<hr>
<h2 id='db_call_function'>Helper to construct SQL function calls</h2><span id='topic+db_call_function'></span>

<h3>Description</h3>

<p>Calls function 'schema'.'fname' with the given 'args', returning
the result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_call_function(con, fname, args = NULL, schema = "timeseries")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="db_call_function_+3A_con">con</code></td>
<td>
<p>RPostgres connection object.</p>
</td></tr>
<tr><td><code id="db_call_function_+3A_fname">fname</code></td>
<td>
<p>character Name of the function to be called</p>
</td></tr>
<tr><td><code id="db_call_function_+3A_args">args</code></td>
<td>
<p>list of function arguments. A single, unnested list.</p>
</td></tr>
<tr><td><code id="db_call_function_+3A_schema">schema</code></td>
<td>
<p><strong>character</strong> name of the database schema. Defaults to 'timeseries'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Args may be named to enable postgres to decide which candidate to choose in case
of overloaded functions.
If any args are named, all of them must be.
</p>


<h3>Value</h3>

<p>value of 'dbGetQuery(con, &quot;SELECT * FROM schema.fname($args)&quot;)$fname'
</p>

<hr>
<h2 id='db_collection_add_ts'>Bundles Keys into an Existing Collection or Adds a New Collection</h2><span id='topic+db_collection_add_ts'></span>

<h3>Description</h3>

<p>Collections are user specific compilations of time series keys. Similar to
a playlist in a music app, collections help to come back to a previously stored
selection of time series. This functions adds more time series to existing bundles (collections).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_collection_add_ts(
  con,
  collection_name,
  ts_keys,
  description = NULL,
  user = Sys.info()["user"],
  schema = "timeseries"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="db_collection_add_ts_+3A_con">con</code></td>
<td>
<p>RPostgres connection object.</p>
</td></tr>
<tr><td><code id="db_collection_add_ts_+3A_collection_name">collection_name</code></td>
<td>
<p><strong>character</strong> name of a collection to read. Collection are bookmark lists that contain time series keys.</p>
</td></tr>
<tr><td><code id="db_collection_add_ts_+3A_ts_keys">ts_keys</code></td>
<td>
<p><strong>character</strong> vector of time series identifiers.</p>
</td></tr>
<tr><td><code id="db_collection_add_ts_+3A_description">description</code></td>
<td>
<p><strong>character</strong> description of the collection.</p>
</td></tr>
<tr><td><code id="db_collection_add_ts_+3A_user">user</code></td>
<td>
<p>character name of the database user. Defaults to the user of the R session.
this is often the user for the database, too so you do not have to specify
your username explicitly if that is the case.</p>
</td></tr>
<tr><td><code id="db_collection_add_ts_+3A_schema">schema</code></td>
<td>
<p><strong>character</strong> name of the database schema. Defaults to 'timeseries'</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other collections functions: 
<code><a href="#topic+db_collection_delete">db_collection_delete</a>()</code>,
<code><a href="#topic+db_collection_get_keys">db_collection_get_keys</a>()</code>,
<code><a href="#topic+db_collection_get_last_update">db_collection_get_last_update</a>()</code>,
<code><a href="#topic+db_collection_list">db_collection_list</a>()</code>,
<code><a href="#topic+db_collection_remove_ts">db_collection_remove_ts</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
db_ts_store(con = connection, zrh_airport, schema = "schema")
db_ts_store(con = connection, kof_ts, schema = "schema")

db_collection_add_ts(
  con = connection,
  collection_name = "barometer and departures zurich",
  ts_keys = c(
    "ch.zrh_airport.departure.total",
    "ch.zrh_airport.departure.total",
    "ch.kof.barometer"
  ),
  schema = "schema"
)

## End(Not run)
</code></pre>

<hr>
<h2 id='db_collection_delete'>Remove an Entire Time Series Key Collection</h2><span id='topic+db_collection_delete'></span>

<h3>Description</h3>

<p>Remove an Entire Time Series Key Collection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_collection_delete(
  con,
  collection_name,
  user = Sys.info()["user"],
  schema = "timeseries"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="db_collection_delete_+3A_con">con</code></td>
<td>
<p>RPostgres connection object.</p>
</td></tr>
<tr><td><code id="db_collection_delete_+3A_collection_name">collection_name</code></td>
<td>
<p><strong>character</strong> name of a collection to read. Collection are bookmark lists that contain time series keys.</p>
</td></tr>
<tr><td><code id="db_collection_delete_+3A_user">user</code></td>
<td>
<p>character name of the database user. Defaults to the user of the R session.
this is often the user for the database, too so you do not have to specify
your username explicitly if that is the case.</p>
</td></tr>
<tr><td><code id="db_collection_delete_+3A_schema">schema</code></td>
<td>
<p><strong>character</strong> name of the database schema. Defaults to 'timeseries'</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other collections functions: 
<code><a href="#topic+db_collection_add_ts">db_collection_add_ts</a>()</code>,
<code><a href="#topic+db_collection_get_keys">db_collection_get_keys</a>()</code>,
<code><a href="#topic+db_collection_get_last_update">db_collection_get_last_update</a>()</code>,
<code><a href="#topic+db_collection_list">db_collection_list</a>()</code>,
<code><a href="#topic+db_collection_remove_ts">db_collection_remove_ts</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
db_ts_store(con = connection, zrh_airport, schema = "schema")
db_ts_store(con = connection, kof_ts, schema = "schema")

db_collection_add_ts(
  con = connection,
  collection_name = "barometer and departures zurich",
  ts_keys = c(
    "ch.zrh_airport.departure.total",
    "ch.zrh_airport.departure.total",
    "ch.kof.barometer"
  ),
  schema = "schema"
)

db_collection_delete(
  con = connection,
  collection_name = "barometer and departures zurich",
  schema = "schema"
)

## End(Not run)
</code></pre>

<hr>
<h2 id='db_collection_get_keys'>Get All Keys in a User Collection</h2><span id='topic+db_collection_get_keys'></span>

<h3>Description</h3>

<p>Reads all keys in the given collection and returns them in a vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_collection_get_keys(
  con,
  collection_name,
  user = Sys.info()["user"],
  schema = "timeseries"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="db_collection_get_keys_+3A_con">con</code></td>
<td>
<p>RPostgres connection object.</p>
</td></tr>
<tr><td><code id="db_collection_get_keys_+3A_collection_name">collection_name</code></td>
<td>
<p><strong>character</strong> name of a collection to read. Collection are bookmark lists that contain time series keys.</p>
</td></tr>
<tr><td><code id="db_collection_get_keys_+3A_user">user</code></td>
<td>
<p>character name of the database user. Defaults to the user of the R session.
this is often the user for the database, too so you do not have to specify
your username explicitly if that is the case.</p>
</td></tr>
<tr><td><code id="db_collection_get_keys_+3A_schema">schema</code></td>
<td>
<p><strong>character</strong> name of the database schema. Defaults to 'timeseries'</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other collections functions: 
<code><a href="#topic+db_collection_add_ts">db_collection_add_ts</a>()</code>,
<code><a href="#topic+db_collection_delete">db_collection_delete</a>()</code>,
<code><a href="#topic+db_collection_get_last_update">db_collection_get_last_update</a>()</code>,
<code><a href="#topic+db_collection_list">db_collection_list</a>()</code>,
<code><a href="#topic+db_collection_remove_ts">db_collection_remove_ts</a>()</code>
</p>

<hr>
<h2 id='db_collection_get_last_update'>Get the last update of a collection for a specific User</h2><span id='topic+db_collection_get_last_update'></span>

<h3>Description</h3>

<p>Get the last update of a collection for a specific User
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_collection_get_last_update(
  con,
  collection_name,
  user = Sys.info()["user"],
  schema = "timeseries"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="db_collection_get_last_update_+3A_con">con</code></td>
<td>
<p>RPostgres connection object.</p>
</td></tr>
<tr><td><code id="db_collection_get_last_update_+3A_collection_name">collection_name</code></td>
<td>
<p><strong>character</strong> name of a collection to read. Collection are bookmark lists that contain time series keys.</p>
</td></tr>
<tr><td><code id="db_collection_get_last_update_+3A_user">user</code></td>
<td>
<p>character name of the database user. Defaults to the user of the R session.
this is often the user for the database, too so you do not have to specify
your username explicitly if that is the case.</p>
</td></tr>
<tr><td><code id="db_collection_get_last_update_+3A_schema">schema</code></td>
<td>
<p><strong>character</strong> name of the database schema. Defaults to 'timeseries'</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other collections functions: 
<code><a href="#topic+db_collection_add_ts">db_collection_add_ts</a>()</code>,
<code><a href="#topic+db_collection_delete">db_collection_delete</a>()</code>,
<code><a href="#topic+db_collection_get_keys">db_collection_get_keys</a>()</code>,
<code><a href="#topic+db_collection_list">db_collection_list</a>()</code>,
<code><a href="#topic+db_collection_remove_ts">db_collection_remove_ts</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

db_ts_store(con = connection, zrh_airport, schema = "schema")
db_ts_store(con = connection, kof_ts, schema = "schema")

db_collection_add_ts(
  con = connection,
  collection_name = "barometer and departures zurich",
  ts_keys = c(
    "ch.zrh_airport.departure.total",
    "ch.zrh_airport.departure.total",
    "ch.kof.barometer"
  ),
  schema = "schema"
)

db_collection_get_last_update(
  con = connection,
  collection_name = "barometer and departures zurich",
  schema = "schema"
)

## End(Not run)
</code></pre>

<hr>
<h2 id='db_collection_list'>List All Available Collections for a Specific User</h2><span id='topic+db_collection_list'></span>

<h3>Description</h3>

<p>List All Available Collections for a Specific User
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_collection_list(con, user = Sys.info()["user"], schema = "timeseries")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="db_collection_list_+3A_con">con</code></td>
<td>
<p>RPostgres connection object.</p>
</td></tr>
<tr><td><code id="db_collection_list_+3A_user">user</code></td>
<td>
<p>character name of the database user. Defaults to the user of the R session.
this is often the user for the database, too so you do not have to specify
your username explicitly if that is the case.</p>
</td></tr>
<tr><td><code id="db_collection_list_+3A_schema">schema</code></td>
<td>
<p><strong>character</strong> name of the database schema. Defaults to 'timeseries'</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other collections functions: 
<code><a href="#topic+db_collection_add_ts">db_collection_add_ts</a>()</code>,
<code><a href="#topic+db_collection_delete">db_collection_delete</a>()</code>,
<code><a href="#topic+db_collection_get_keys">db_collection_get_keys</a>()</code>,
<code><a href="#topic+db_collection_get_last_update">db_collection_get_last_update</a>()</code>,
<code><a href="#topic+db_collection_remove_ts">db_collection_remove_ts</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
ts1 &lt;- list(ts(rnorm(100), start = c(1990, 1), frequency = 4))
names(ts1) &lt;- c("ts1")
db_ts_store(con = connection, ts1, schema = "schema")
db_ts_store(con = connection, zrh_airport, schema = "schema")
db_ts_store(con = connection, kof_ts, schema = "schema")

db_collection_add_ts(
  con = connection,
  collection_name = "barometer and departures zurich",
  ts_keys = c(
    "ch.zrh_airport.departure.total",
    "ch.zrh_airport.departure.total",
    "ch.kof.barometer"
  ),
  schema = "schema"
)

db_collection_add_ts(
  con = connection,
  collection_name = "ts1 and departures zurich",
  ts_keys = c(
    "ch.zrh_airport.departure.total",
    "ts1"
  ),
  schema = "schema"
)

db_collection_list(
  con = connection,
  schema = "schema"
)

## End(Not run)
</code></pre>

<hr>
<h2 id='db_collection_read_metadata'>Read Metadata for a Collection</h2><span id='topic+db_collection_read_metadata'></span>

<h3>Description</h3>

<p>Read Metadata for a Collection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_collection_read_metadata(
  con,
  collection_name,
  collection_owner,
  valid_on = NULL,
  locale = NULL,
  schema = "timeseries"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="db_collection_read_metadata_+3A_con">con</code></td>
<td>
<p>RPostgres connection object.</p>
</td></tr>
<tr><td><code id="db_collection_read_metadata_+3A_collection_name">collection_name</code></td>
<td>
<p>character name of the collection.</p>
</td></tr>
<tr><td><code id="db_collection_read_metadata_+3A_collection_owner">collection_owner</code></td>
<td>
<p>character name of the collection owner.</p>
</td></tr>
<tr><td><code id="db_collection_read_metadata_+3A_valid_on">valid_on</code></td>
<td>
<p><strong>character</strong> representation of a date in the form of 'YYYY-MM-DD'. valid_on selects the
version of a time series that is valid at the specified time.</p>
</td></tr>
<tr><td><code id="db_collection_read_metadata_+3A_locale">locale</code></td>
<td>
<p><strong>character</strong> indicating the language of the meta information to be store. We recommend to use ISO country codes to represent languages. Defaults to NULL. When local is set to NULL, metadata are stored without localization. Note that, when localizing meta information by assigning a language, multiple meta information objects can be stored for a single time series.</p>
</td></tr>
<tr><td><code id="db_collection_read_metadata_+3A_schema">schema</code></td>
<td>
<p><strong>character</strong> name of the database schema. Defaults to 'timeseries'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of all available meta descriptions for a particular collection and language.
</p>


<h3>See Also</h3>

<p>Other metadata functions: 
<code><a href="#topic+db_dataset_read_metadata">db_dataset_read_metadata</a>()</code>,
<code><a href="#topic+db_meta_get_latest_validity">db_meta_get_latest_validity</a>()</code>,
<code><a href="#topic+db_metadata_read">db_metadata_read</a>()</code>,
<code><a href="#topic+db_metadata_store">db_metadata_store</a>()</code>
</p>

<hr>
<h2 id='db_collection_read_ts'>Read all Time Series in a User Collection</h2><span id='topic+db_collection_read_ts'></span>

<h3>Description</h3>

<p>Read all Time Series in a User Collection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_collection_read_ts(
  con,
  collection_name,
  collection_owner,
  valid_on = NULL,
  respect_release_date = FALSE,
  schema = "timeseries",
  chunksize = 10000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="db_collection_read_ts_+3A_con">con</code></td>
<td>
<p>RPostgres connection object.</p>
</td></tr>
<tr><td><code id="db_collection_read_ts_+3A_collection_name">collection_name</code></td>
<td>
<p><strong>character</strong> name of a collection to read. Collection are bookmark lists that contain time series keys.</p>
</td></tr>
<tr><td><code id="db_collection_read_ts_+3A_collection_owner">collection_owner</code></td>
<td>
<p><strong>character</strong> username that is the owner of a collection.</p>
</td></tr>
<tr><td><code id="db_collection_read_ts_+3A_valid_on">valid_on</code></td>
<td>
<p><strong>character</strong> representation of a date in the form of 'YYYY-MM-DD'. valid_on selects the
version of a time series that is valid at the specified time.</p>
</td></tr>
<tr><td><code id="db_collection_read_ts_+3A_respect_release_date">respect_release_date</code></td>
<td>
<p><strong>boolean</strong> indicating if it should the release embargo of a time series be respected. Defaults to FALSE. This option makes sense when the function is used in an API. In that sense, users do not have direct access to this function and therefore cannot simply switch parameters.</p>
</td></tr>
<tr><td><code id="db_collection_read_ts_+3A_schema">schema</code></td>
<td>
<p><strong>character</strong> name of the database schema. Defaults to 'timeseries'</p>
</td></tr>
<tr><td><code id="db_collection_read_ts_+3A_chunksize">chunksize</code></td>
<td>
<p>set a limit of the number of time series requested in the function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Collections are identified by their name and owner. Several collections
with the same name but different owners may exist, therefore both need to be supplied
in order to uniquely identify a collection.
</p>


<h3>See Also</h3>

<p>Other time series functions: 
<code><a href="#topic+db_dataset_read_ts">db_dataset_read_ts</a>()</code>,
<code><a href="#topic+db_ts_delete_latest_version">db_ts_delete_latest_version</a>()</code>,
<code><a href="#topic+db_ts_delete">db_ts_delete</a>()</code>,
<code><a href="#topic+db_ts_get_last_update">db_ts_get_last_update</a>()</code>,
<code><a href="#topic+db_ts_read_history">db_ts_read_history</a>()</code>,
<code><a href="#topic+db_ts_read">db_ts_read</a>()</code>,
<code><a href="#topic+db_ts_store">db_ts_store</a>()</code>,
<code><a href="#topic+db_ts_trim_history">db_ts_trim_history</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

db_ts_store(con = connection, zrh_airport, schema = "schema")
db_ts_store(con = connection, kof_ts, schema = "schema")

db_collection_add_ts(
  con = connection,
  collection_name = "barometer and departures zurich",
  ts_keys = c(
    "ch.zrh_airport.departure.total",
    "ch.zrh_airport.departure.total",
    "ch.kof.barometer"
  ),
  schema = "schema"
)

db_collection_read_ts(
  con = connection,
  collection_name = "barometer and departures zurich",
  collection_owner = "user_name",
  schema = "schema"
)

## End(Not run)
</code></pre>

<hr>
<h2 id='db_collection_remove_ts'>Remove Keys From a User's Collection</h2><span id='topic+db_collection_remove_ts'></span>

<h3>Description</h3>

<p>Removes a vector of time series keys from a user specific
compilation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_collection_remove_ts(
  con,
  collection_name,
  ts_keys,
  user = Sys.info()["user"],
  schema = "timeseries"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="db_collection_remove_ts_+3A_con">con</code></td>
<td>
<p>RPostgres connection object.</p>
</td></tr>
<tr><td><code id="db_collection_remove_ts_+3A_collection_name">collection_name</code></td>
<td>
<p><strong>character</strong> name of a collection to read. Collection are bookmark lists that contain time series keys.</p>
</td></tr>
<tr><td><code id="db_collection_remove_ts_+3A_ts_keys">ts_keys</code></td>
<td>
<p><strong>character</strong> vector of time series identifiers.</p>
</td></tr>
<tr><td><code id="db_collection_remove_ts_+3A_user">user</code></td>
<td>
<p>character name of the database user. Defaults to the user of the R session.
this is often the user for the database, too so you do not have to specify
your username explicitly if that is the case.</p>
</td></tr>
<tr><td><code id="db_collection_remove_ts_+3A_schema">schema</code></td>
<td>
<p><strong>character</strong> name of the database schema. Defaults to 'timeseries'</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other collections functions: 
<code><a href="#topic+db_collection_add_ts">db_collection_add_ts</a>()</code>,
<code><a href="#topic+db_collection_delete">db_collection_delete</a>()</code>,
<code><a href="#topic+db_collection_get_keys">db_collection_get_keys</a>()</code>,
<code><a href="#topic+db_collection_get_last_update">db_collection_get_last_update</a>()</code>,
<code><a href="#topic+db_collection_list">db_collection_list</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
db_ts_store(con = connection, zrh_airport, schema = "schema")
db_ts_store(con = connection, kof_ts, schema = "schema")

db_collection_add_ts(
  con = connection,
  collection_name = "barometer and departures zurich",
  ts_keys = c(
    "ch.zrh_airport.departure.total",
    "ch.zrh_airport.departure.total",
    "ch.kof.barometer"
  ),
  schema = "schema"
)

db_collection_remove_ts(
  con = connection,
  collection_name = "barometer and departures zurich",
  ts_keys = "ch.zrh_airport.departure.total",
  schema = "schema"
)

## End(Not run)
</code></pre>

<hr>
<h2 id='db_connection_close'>Close an Existing Database Connection</h2><span id='topic+db_connection_close'></span>

<h3>Description</h3>

<p>Close database connection given a connection object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_connection_close(con, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="db_connection_close_+3A_con">con</code></td>
<td>
<p>RPostgres connection object.</p>
</td></tr>
<tr><td><code id="db_connection_close_+3A_...">...</code></td>
<td>
<p>passed on to RPostgres::dbDisconnect</p>
</td></tr>
</table>

<hr>
<h2 id='db_connection_create'>Create Database Connection</h2><span id='topic+db_connection_create'></span>

<h3>Description</h3>

<p>Connects to the PostgreSQL database backend of timeseriesdb. This function
is convenience wrapper around DBI's dbConnect. It's less general than the DBI
function and only works for PostgreSQL, but it is a little more convenient
because of its defaults / assumptions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_connection_create(
  dbname,
  user = Sys.info()[["user"]],
  host = "localhost",
  passwd = NULL,
  passwd_from_file = FALSE,
  line_no = 1,
  passwd_from_env = FALSE,
  connection_description = "timeseriesdb",
  port = 5432
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="db_connection_create_+3A_dbname">dbname</code></td>
<td>
<p>character name of the database.</p>
</td></tr>
<tr><td><code id="db_connection_create_+3A_user">user</code></td>
<td>
<p>character name of the database user. Defaults to the user of the R session.
this is often the user for the database, too so you do not have to specify
your username explicitly if that is the case.</p>
</td></tr>
<tr><td><code id="db_connection_create_+3A_host">host</code></td>
<td>
<p>character denoting the hostname. Defaults to localhost.</p>
</td></tr>
<tr><td><code id="db_connection_create_+3A_passwd">passwd</code></td>
<td>
<p>character password, file or environment name. Defaults to NULL triggering an R Studio function that
asks for your passwords interactively if you are on R Studio. Make sure to adapt the boolean params correspondingly.</p>
</td></tr>
<tr><td><code id="db_connection_create_+3A_passwd_from_file">passwd_from_file</code></td>
<td>
<p>boolean if set to TRUE the passwd param is interpreted as a file
location for a password file such as .pgpass. Make sure to be very
restrictive with file permissions if you store a password to a file.</p>
</td></tr>
<tr><td><code id="db_connection_create_+3A_line_no">line_no</code></td>
<td>
<p>integer specify line number of password file that holds the actual password.</p>
</td></tr>
<tr><td><code id="db_connection_create_+3A_passwd_from_env">passwd_from_env</code></td>
<td>
<p>boolean if set to TRUE the passwd param is interpreted as the name of an
environment variable from which to get the password</p>
</td></tr>
<tr><td><code id="db_connection_create_+3A_connection_description">connection_description</code></td>
<td>
<p>character connection description describing the application
that connects to the database. This is mainly helpful for
DB admins and shows up in the pg_stat_activity table.
Defaults to 'timeseriesdb'. Avoid spaces as this is a psql option.</p>
</td></tr>
<tr><td><code id="db_connection_create_+3A_port">port</code></td>
<td>
<p>integer defaults to 5432, the PostgreSQL standard port.</p>
</td></tr>
</table>

<hr>
<h2 id='db_dataset_create'>Create a New Dataset</h2><span id='topic+db_dataset_create'></span>

<h3>Description</h3>

<p>A dataset is a family of time series that belong to the same topic. By default all series stored with 'db_store_ts' belong to a default set. In order to assign them a different set, it must first be created with 'db_dataset_create' after which the series may be moved with <code><a href="#topic+db_ts_assign_dataset">db_ts_assign_dataset</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_dataset_create(
  con,
  set_name,
  set_description = NULL,
  set_md = NULL,
  schema = "timeseries"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="db_dataset_create_+3A_con">con</code></td>
<td>
<p>RPostgres connection object.</p>
</td></tr>
<tr><td><code id="db_dataset_create_+3A_set_name">set_name</code></td>
<td>
<p><strong>character</strong> name of a dataset.</p>
</td></tr>
<tr><td><code id="db_dataset_create_+3A_set_description">set_description</code></td>
<td>
<p><strong>character</strong> description about the set. Default to NA.</p>
</td></tr>
<tr><td><code id="db_dataset_create_+3A_set_md">set_md</code></td>
<td>
<p>meta information data about the set. Default to NA.</p>
</td></tr>
<tr><td><code id="db_dataset_create_+3A_schema">schema</code></td>
<td>
<p><strong>character</strong> name of the database schema. Defaults to 'timeseries'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character name of the created set
</p>


<h3>See Also</h3>

<p>Other datasets functions: 
<code><a href="#topic+db_dataset_delete">db_dataset_delete</a>()</code>,
<code><a href="#topic+db_dataset_get_keys">db_dataset_get_keys</a>()</code>,
<code><a href="#topic+db_dataset_get_last_update">db_dataset_get_last_update</a>()</code>,
<code><a href="#topic+db_dataset_list">db_dataset_list</a>()</code>,
<code><a href="#topic+db_dataset_trim_history">db_dataset_trim_history</a>()</code>,
<code><a href="#topic+db_dataset_update_metadata">db_dataset_update_metadata</a>()</code>,
<code><a href="#topic+db_ts_assign_dataset">db_ts_assign_dataset</a>()</code>,
<code><a href="#topic+db_ts_get_dataset">db_ts_get_dataset</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

db_dataset_create(
  con = connection,
  set_name = "zrh_airport_data",
  set_description = "Zurich airport arrivals and departures ",
  schema = "schema"
)

## End(Not run)
</code></pre>

<hr>
<h2 id='db_dataset_delete'>Irrevocably Delete All Time Series in a Set and the Set Itself</h2><span id='topic+db_dataset_delete'></span>

<h3>Description</h3>

<p>This function cannot be used in batch mode as it needs user interaction.
It asks the user to manually input confirmation to prevent
unintentional deletion of datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_dataset_delete(con, set_name, schema = "timeseries")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="db_dataset_delete_+3A_con">con</code></td>
<td>
<p>RPostgres connection object.</p>
</td></tr>
<tr><td><code id="db_dataset_delete_+3A_set_name">set_name</code></td>
<td>
<p><strong>character</strong> name of a dataset.</p>
</td></tr>
<tr><td><code id="db_dataset_delete_+3A_schema">schema</code></td>
<td>
<p><strong>character</strong> name of the database schema. Defaults to 'timeseries'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character name of the deleted set, NA in case of an error.
</p>


<h3>See Also</h3>

<p>Other datasets functions: 
<code><a href="#topic+db_dataset_create">db_dataset_create</a>()</code>,
<code><a href="#topic+db_dataset_get_keys">db_dataset_get_keys</a>()</code>,
<code><a href="#topic+db_dataset_get_last_update">db_dataset_get_last_update</a>()</code>,
<code><a href="#topic+db_dataset_list">db_dataset_list</a>()</code>,
<code><a href="#topic+db_dataset_trim_history">db_dataset_trim_history</a>()</code>,
<code><a href="#topic+db_dataset_update_metadata">db_dataset_update_metadata</a>()</code>,
<code><a href="#topic+db_ts_assign_dataset">db_ts_assign_dataset</a>()</code>,
<code><a href="#topic+db_ts_get_dataset">db_ts_get_dataset</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

db_dataset_create(
  con = connection,
  set_name = "zrh_airport_data",
  set_description = "Zurich airport arrivals and departures ",
  schema = "schema"
)

db_dataset_delete(
  con = connection,
  set_name = "zrh_airport_data",
  schema = "schema"
)

## End(Not run)
</code></pre>

<hr>
<h2 id='db_dataset_get_keys'>Get All Time Series Keys in a Given Set</h2><span id='topic+db_dataset_get_keys'></span>

<h3>Description</h3>

<p>Get All Time Series Keys in a Given Set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_dataset_get_keys(con, set_name = "default", schema = "timeseries")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="db_dataset_get_keys_+3A_con">con</code></td>
<td>
<p>RPostgres connection object.</p>
</td></tr>
<tr><td><code id="db_dataset_get_keys_+3A_set_name">set_name</code></td>
<td>
<p><strong>character</strong> name of a dataset.</p>
</td></tr>
<tr><td><code id="db_dataset_get_keys_+3A_schema">schema</code></td>
<td>
<p><strong>character</strong> name of the database schema. Defaults to 'timeseries'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character A vector of ts keys contained in the set
</p>


<h3>See Also</h3>

<p>Other datasets functions: 
<code><a href="#topic+db_dataset_create">db_dataset_create</a>()</code>,
<code><a href="#topic+db_dataset_delete">db_dataset_delete</a>()</code>,
<code><a href="#topic+db_dataset_get_last_update">db_dataset_get_last_update</a>()</code>,
<code><a href="#topic+db_dataset_list">db_dataset_list</a>()</code>,
<code><a href="#topic+db_dataset_trim_history">db_dataset_trim_history</a>()</code>,
<code><a href="#topic+db_dataset_update_metadata">db_dataset_update_metadata</a>()</code>,
<code><a href="#topic+db_ts_assign_dataset">db_ts_assign_dataset</a>()</code>,
<code><a href="#topic+db_ts_get_dataset">db_ts_get_dataset</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

db_dataset_get_keys(
  con = connection,
  set_name = "zrh_airport_data",
  set_description = "Zurich airport arrivals and departures ",
  schema = "schema"
)

## End(Not run)
</code></pre>

<hr>
<h2 id='db_dataset_get_last_update'>Get the dataset last update</h2><span id='topic+db_dataset_get_last_update'></span>

<h3>Description</h3>

<p>Get the dataset last update
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_dataset_get_last_update(con, set_id, schema = "timeseries")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="db_dataset_get_last_update_+3A_con">con</code></td>
<td>
<p>RPostgres connection object.</p>
</td></tr>
<tr><td><code id="db_dataset_get_last_update_+3A_set_id">set_id</code></td>
<td>
<p><strong>character</strong> name of the set to get the last update</p>
</td></tr>
<tr><td><code id="db_dataset_get_last_update_+3A_schema">schema</code></td>
<td>
<p><strong>character</strong> name of the database schema. Defaults to 'timeseries'</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other datasets functions: 
<code><a href="#topic+db_dataset_create">db_dataset_create</a>()</code>,
<code><a href="#topic+db_dataset_delete">db_dataset_delete</a>()</code>,
<code><a href="#topic+db_dataset_get_keys">db_dataset_get_keys</a>()</code>,
<code><a href="#topic+db_dataset_list">db_dataset_list</a>()</code>,
<code><a href="#topic+db_dataset_trim_history">db_dataset_trim_history</a>()</code>,
<code><a href="#topic+db_dataset_update_metadata">db_dataset_update_metadata</a>()</code>,
<code><a href="#topic+db_ts_assign_dataset">db_ts_assign_dataset</a>()</code>,
<code><a href="#topic+db_ts_get_dataset">db_ts_get_dataset</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

# Storing different versions of the data, use parameter valid_from
# different versions are stored with the same key
ch.kof.barometer &lt;- kof_ts["baro_2019m11"]
names(ch.kof.barometer) &lt;- c("ch.kof.barometer")
db_ts_store(
  con = connection,
  ch.kof.barometer,
  valid_from = "2019-12-01",
  schema = "schema"
)

ch.kof.barometer &lt;- kof_ts["baro_2019m12"]
names(ch.kof.barometer) &lt;- c("ch.kof.barometer")
db_ts_store(
  con = connection,
  ch.kof.barometer,
  valid_from = "2020-01-01",
  schema = "schema"
)

db_dataset_create(
  con = connection,
  set_name = "barometer",
  set_description = "KOF Barometer",
  schema = "schema"
)

db_ts_assign_dataset(
  con = connection,
  ts_keys = "ch.kof.barometer",
  set_name = "barometer",
  schema = "schema"
)

db_dataset_get_last_update(
  con = connection,
  set_id = "barometer",
  schema = "schema"
)

## End(Not run)
</code></pre>

<hr>
<h2 id='db_dataset_get_latest_release'>Get the latest Release for Given Datasets</h2><span id='topic+db_dataset_get_latest_release'></span>

<h3>Description</h3>

<p>Get the latest Release for Given Datasets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_dataset_get_latest_release(con, set_ids, schema = "timeseries")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="db_dataset_get_latest_release_+3A_con">con</code></td>
<td>
<p>RPostgres connection object.</p>
</td></tr>
<tr><td><code id="db_dataset_get_latest_release_+3A_set_ids">set_ids</code></td>
<td>
<p>Sets to get release dates for</p>
</td></tr>
<tr><td><code id="db_dataset_get_latest_release_+3A_schema">schema</code></td>
<td>
<p><strong>character</strong> name of the database schema. Defaults to 'timeseries'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with columns 'set_id', 'release_id', 'release_date'
</p>


<h3>See Also</h3>

<p>Other calendar functions: 
<code><a href="#topic+db_dataset_get_next_release">db_dataset_get_next_release</a>()</code>,
<code><a href="#topic+db_dataset_get_release">db_dataset_get_release</a>()</code>,
<code><a href="#topic+db_release_cancel">db_release_cancel</a>()</code>,
<code><a href="#topic+db_release_create">db_release_create</a>()</code>,
<code><a href="#topic+db_release_list">db_release_list</a>()</code>,
<code><a href="#topic+db_release_update">db_release_update</a>()</code>
</p>

<hr>
<h2 id='db_dataset_get_next_release'>Get Next Release Date for Given Datasets</h2><span id='topic+db_dataset_get_next_release'></span>

<h3>Description</h3>

<p>Get Next Release Date for Given Datasets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_dataset_get_next_release(con, set_ids, schema = "timeseries")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="db_dataset_get_next_release_+3A_con">con</code></td>
<td>
<p>RPostgres connection object.</p>
</td></tr>
<tr><td><code id="db_dataset_get_next_release_+3A_set_ids">set_ids</code></td>
<td>
<p>Sets to get release dates for</p>
</td></tr>
<tr><td><code id="db_dataset_get_next_release_+3A_schema">schema</code></td>
<td>
<p><strong>character</strong> name of the database schema. Defaults to 'timeseries'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with columns 'set_id', 'release_id', 'release_date'
</p>


<h3>See Also</h3>

<p>Other calendar functions: 
<code><a href="#topic+db_dataset_get_latest_release">db_dataset_get_latest_release</a>()</code>,
<code><a href="#topic+db_dataset_get_release">db_dataset_get_release</a>()</code>,
<code><a href="#topic+db_release_cancel">db_release_cancel</a>()</code>,
<code><a href="#topic+db_release_create">db_release_create</a>()</code>,
<code><a href="#topic+db_release_list">db_release_list</a>()</code>,
<code><a href="#topic+db_release_update">db_release_update</a>()</code>
</p>

<hr>
<h2 id='db_dataset_get_release'>Get the latest Release for Given Datasets</h2><span id='topic+db_dataset_get_release'></span>

<h3>Description</h3>

<p>Get the latest Release for Given Datasets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_dataset_get_release(
  con,
  set_ids,
  target_year = year(Sys.Date()),
  target_period = month(Sys.Date()),
  schema = "timeseries"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="db_dataset_get_release_+3A_con">con</code></td>
<td>
<p>RPostgres connection object.</p>
</td></tr>
<tr><td><code id="db_dataset_get_release_+3A_set_ids">set_ids</code></td>
<td>
<p>Sets to get release dates for</p>
</td></tr>
<tr><td><code id="db_dataset_get_release_+3A_target_year">target_year</code></td>
<td>
<p>Year of the desired release</p>
</td></tr>
<tr><td><code id="db_dataset_get_release_+3A_target_period">target_period</code></td>
<td>
<p>Period of the desired release</p>
</td></tr>
<tr><td><code id="db_dataset_get_release_+3A_schema">schema</code></td>
<td>
<p><strong>character</strong> name of the database schema. Defaults to 'timeseries'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with columns 'set_id', 'release_id', 'release_date'
</p>


<h3>See Also</h3>

<p>Other calendar functions: 
<code><a href="#topic+db_dataset_get_latest_release">db_dataset_get_latest_release</a>()</code>,
<code><a href="#topic+db_dataset_get_next_release">db_dataset_get_next_release</a>()</code>,
<code><a href="#topic+db_release_cancel">db_release_cancel</a>()</code>,
<code><a href="#topic+db_release_create">db_release_create</a>()</code>,
<code><a href="#topic+db_release_list">db_release_list</a>()</code>,
<code><a href="#topic+db_release_update">db_release_update</a>()</code>
</p>

<hr>
<h2 id='db_dataset_list'>Get All Available Datasets and Their Description</h2><span id='topic+db_dataset_list'></span>

<h3>Description</h3>

<p>Get All Available Datasets and Their Description
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_dataset_list(con, schema = "timeseries")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="db_dataset_list_+3A_con">con</code></td>
<td>
<p>RPostgres connection object.</p>
</td></tr>
<tr><td><code id="db_dataset_list_+3A_schema">schema</code></td>
<td>
<p><strong>character</strong> name of the database schema. Defaults to 'timeseries'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with columns 'set_id' and 'set_description'
</p>


<h3>See Also</h3>

<p>Other datasets functions: 
<code><a href="#topic+db_dataset_create">db_dataset_create</a>()</code>,
<code><a href="#topic+db_dataset_delete">db_dataset_delete</a>()</code>,
<code><a href="#topic+db_dataset_get_keys">db_dataset_get_keys</a>()</code>,
<code><a href="#topic+db_dataset_get_last_update">db_dataset_get_last_update</a>()</code>,
<code><a href="#topic+db_dataset_trim_history">db_dataset_trim_history</a>()</code>,
<code><a href="#topic+db_dataset_update_metadata">db_dataset_update_metadata</a>()</code>,
<code><a href="#topic+db_ts_assign_dataset">db_ts_assign_dataset</a>()</code>,
<code><a href="#topic+db_ts_get_dataset">db_ts_get_dataset</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

db_dataset_create(
  con = connection,
  set_name = "zrh_airport_data",
  set_description = "Zurich airport arrivals and departures ",
  schema = "schema"
)

db_dataset_list(
  con = connection,
  schema = "schema"
)

## End(Not run)
</code></pre>

<hr>
<h2 id='db_dataset_read_metadata'>Read Dataset Meta Information</h2><span id='topic+db_dataset_read_metadata'></span>

<h3>Description</h3>

<p>Read Dataset Meta Information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_dataset_read_metadata(
  con,
  dataset_id,
  valid_on = NULL,
  locale = NULL,
  schema = "timeseries"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="db_dataset_read_metadata_+3A_con">con</code></td>
<td>
<p>RPostgres connection object.</p>
</td></tr>
<tr><td><code id="db_dataset_read_metadata_+3A_dataset_id">dataset_id</code></td>
<td>
<p>character name of the dataset.</p>
</td></tr>
<tr><td><code id="db_dataset_read_metadata_+3A_valid_on">valid_on</code></td>
<td>
<p><strong>character</strong> representation of a date in the form of 'YYYY-MM-DD'. valid_on selects the
version of a time series that is valid at the specified time.</p>
</td></tr>
<tr><td><code id="db_dataset_read_metadata_+3A_locale">locale</code></td>
<td>
<p>character ISO-2 country locale.</p>
</td></tr>
<tr><td><code id="db_dataset_read_metadata_+3A_schema">schema</code></td>
<td>
<p><strong>character</strong> name of the database schema. Defaults to 'timeseries'</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other metadata functions: 
<code><a href="#topic+db_collection_read_metadata">db_collection_read_metadata</a>()</code>,
<code><a href="#topic+db_meta_get_latest_validity">db_meta_get_latest_validity</a>()</code>,
<code><a href="#topic+db_metadata_read">db_metadata_read</a>()</code>,
<code><a href="#topic+db_metadata_store">db_metadata_store</a>()</code>
</p>

<hr>
<h2 id='db_dataset_read_ts'>Read all Time Series in a Dataset</h2><span id='topic+db_dataset_read_ts'></span>

<h3>Description</h3>

<p>Read all Time Series in a Dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_dataset_read_ts(
  con,
  datasets,
  valid_on = NULL,
  respect_release_date = FALSE,
  schema = "timeseries",
  chunksize = 10000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="db_dataset_read_ts_+3A_con">con</code></td>
<td>
<p>RPostgres connection object.</p>
</td></tr>
<tr><td><code id="db_dataset_read_ts_+3A_datasets">datasets</code></td>
<td>
<p><strong>character</strong> vector of the datasets. Dataset is a group of time series.</p>
</td></tr>
<tr><td><code id="db_dataset_read_ts_+3A_valid_on">valid_on</code></td>
<td>
<p><strong>character</strong> representation of a date in the form of 'YYYY-MM-DD'. valid_on selects the
version of a time series that is valid at the specified time.</p>
</td></tr>
<tr><td><code id="db_dataset_read_ts_+3A_respect_release_date">respect_release_date</code></td>
<td>
<p><strong>boolean</strong> indicating if it should the release embargo of a time series be respected. Defaults to FALSE. This option makes sense when the function is used in an API. In that sense, users do not have direct access to this function and therefore cannot simply switch parameters.</p>
</td></tr>
<tr><td><code id="db_dataset_read_ts_+3A_schema">schema</code></td>
<td>
<p><strong>character</strong> name of the database schema. Defaults to 'timeseries'</p>
</td></tr>
<tr><td><code id="db_dataset_read_ts_+3A_chunksize">chunksize</code></td>
<td>
<p>set a limit of the number of time series requested in the function.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other time series functions: 
<code><a href="#topic+db_collection_read_ts">db_collection_read_ts</a>()</code>,
<code><a href="#topic+db_ts_delete_latest_version">db_ts_delete_latest_version</a>()</code>,
<code><a href="#topic+db_ts_delete">db_ts_delete</a>()</code>,
<code><a href="#topic+db_ts_get_last_update">db_ts_get_last_update</a>()</code>,
<code><a href="#topic+db_ts_read_history">db_ts_read_history</a>()</code>,
<code><a href="#topic+db_ts_read">db_ts_read</a>()</code>,
<code><a href="#topic+db_ts_store">db_ts_store</a>()</code>,
<code><a href="#topic+db_ts_trim_history">db_ts_trim_history</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
db_dataset_create(con = connection,
                  set_name = "zrh_airport_data",
                  set_description = "Zurich airport arrivals and departures ",
                  schema = "schema")

db_ts_assign_dataset(con = connection,
                     ts_keys = c("ch.zrh_airport.departure.total",
                                 "ch.zrh_airport.arrival.total"),
                     set_name = "zrh_airport_data",
                     schema = "schema")

db_dataset_read_ts(con = connection,
                   datasets = "zrh_airport_data",
                   schema = "schema")

## End(Not run)
</code></pre>

<hr>
<h2 id='db_dataset_trim_history'>Remove Vintages from the Beginning of Dataset</h2><span id='topic+db_dataset_trim_history'></span>

<h3>Description</h3>

<p>Removes any vintages of the given dataset that are older than a specified date.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_dataset_trim_history(con, set_id, older_than, schema = "timeseries")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="db_dataset_trim_history_+3A_con">con</code></td>
<td>
<p>RPostgres connection object.</p>
</td></tr>
<tr><td><code id="db_dataset_trim_history_+3A_set_id">set_id</code></td>
<td>
<p>character Name of the set to trim</p>
</td></tr>
<tr><td><code id="db_dataset_trim_history_+3A_older_than">older_than</code></td>
<td>
<p>Date cut off point</p>
</td></tr>
<tr><td><code id="db_dataset_trim_history_+3A_schema">schema</code></td>
<td>
<p><strong>character</strong> name of the database schema. Defaults to 'timeseries'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In some cases only the last few versions of time series are of interest. This
function can be used to trim off old vintages that are no longer relevant. It may
be helpful to use this function with high frequency data to save disk space
of versions are not needed.
</p>


<h3>See Also</h3>

<p>Other datasets functions: 
<code><a href="#topic+db_dataset_create">db_dataset_create</a>()</code>,
<code><a href="#topic+db_dataset_delete">db_dataset_delete</a>()</code>,
<code><a href="#topic+db_dataset_get_keys">db_dataset_get_keys</a>()</code>,
<code><a href="#topic+db_dataset_get_last_update">db_dataset_get_last_update</a>()</code>,
<code><a href="#topic+db_dataset_list">db_dataset_list</a>()</code>,
<code><a href="#topic+db_dataset_update_metadata">db_dataset_update_metadata</a>()</code>,
<code><a href="#topic+db_ts_assign_dataset">db_ts_assign_dataset</a>()</code>,
<code><a href="#topic+db_ts_get_dataset">db_ts_get_dataset</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

# Storing different versions of the data, use parameter valid_from
# different versions are stored with the same key
ch.kof.barometer &lt;- kof_ts["baro_2019m11"]
names(ch.kof.barometer) &lt;- c("ch.kof.barometer")
db_ts_store(
  con = connection,
  ch.kof.barometer,
  valid_from = "2019-12-01",
  schema = "schema"
)

ch.kof.barometer &lt;- kof_ts["baro_2019m12"]
names(ch.kof.barometer) &lt;- c("ch.kof.barometer")
db_ts_store(
  con = connection,
  ch.kof.barometer,
  valid_from = "2020-01-01",
  schema = "schema"
)

db_dataset_create(
  con = connection,
  set_name = "barometer",
  set_description = "KOF Barometer",
  schema = "schema"
)

db_ts_assign_dataset(
  con = connection,
  ts_keys = "ch.kof.barometer",
  set_name = "barometer",
  schema = "schema"
)

db_dataset_trim_history(
  con = connection,
  set_id = "barometer",
  older_than = "2019-12-31",
  schema = "schema"
)

## End(Not run)
</code></pre>

<hr>
<h2 id='db_dataset_update_metadata'>Update Description and/or Metadata of a Dataset</h2><span id='topic+db_dataset_update_metadata'></span>

<h3>Description</h3>

<p>Update Description and/or Metadata of a Dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_dataset_update_metadata(
  con,
  set_name,
  description = NULL,
  metadata = NULL,
  metadata_update_mode = "update",
  schema = "timeseries"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="db_dataset_update_metadata_+3A_con">con</code></td>
<td>
<p>RPostgres connection object.</p>
</td></tr>
<tr><td><code id="db_dataset_update_metadata_+3A_set_name">set_name</code></td>
<td>
<p><strong>character</strong> name of a dataset.</p>
</td></tr>
<tr><td><code id="db_dataset_update_metadata_+3A_description">description</code></td>
<td>
<p>character New description. If set to NA (default) the description is left untouched</p>
</td></tr>
<tr><td><code id="db_dataset_update_metadata_+3A_metadata">metadata</code></td>
<td>
<p><strong>list</strong> Metadata update (see metadata_update_mode)</p>
</td></tr>
<tr><td><code id="db_dataset_update_metadata_+3A_metadata_update_mode">metadata_update_mode</code></td>
<td>
<p>character one of &quot;update&quot; or &quot;overwrite&quot;. If set to &quot;update&quot;,
new fields in the list are added to the existing metadata and existing fields overwritten.
If NA nothing happens in update mode. If set to &quot;overwrite&quot; ALL existing metadata is replaced.</p>
</td></tr>
<tr><td><code id="db_dataset_update_metadata_+3A_schema">schema</code></td>
<td>
<p><strong>character</strong> name of the database schema. Defaults to 'timeseries'</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other datasets functions: 
<code><a href="#topic+db_dataset_create">db_dataset_create</a>()</code>,
<code><a href="#topic+db_dataset_delete">db_dataset_delete</a>()</code>,
<code><a href="#topic+db_dataset_get_keys">db_dataset_get_keys</a>()</code>,
<code><a href="#topic+db_dataset_get_last_update">db_dataset_get_last_update</a>()</code>,
<code><a href="#topic+db_dataset_list">db_dataset_list</a>()</code>,
<code><a href="#topic+db_dataset_trim_history">db_dataset_trim_history</a>()</code>,
<code><a href="#topic+db_ts_assign_dataset">db_ts_assign_dataset</a>()</code>,
<code><a href="#topic+db_ts_get_dataset">db_ts_get_dataset</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

db_dataset_update_metadata(
  con = connection,
  set_name = "zrh_airport_data",
  description = "updating description Zurich airport arrivals and departures",
  schema = "schema"
)

## End(Not run)
</code></pre>

<hr>
<h2 id='db_get_installed_version'>Get the Currently Installed Version of Timeseriesdb</h2><span id='topic+db_get_installed_version'></span>

<h3>Description</h3>

<p>Get the Currently Installed Version of Timeseriesdb
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_get_installed_version(con, schema = "timeseries")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="db_get_installed_version_+3A_con">con</code></td>
<td>
<p>RPostgres connection object.</p>
</td></tr>
<tr><td><code id="db_get_installed_version_+3A_schema">schema</code></td>
<td>
<p><strong>character</strong> name of the database schema. Defaults to 'timeseries'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character The version number of timeseriesdb currently installed on the given schema
</p>

<hr>
<h2 id='db_grant_to_admin'>GRANT all rights on a (temp) table to schema admin</h2><span id='topic+db_grant_to_admin'></span>

<h3>Description</h3>

<p>The SECURITY DEFINER functions do not have access to tables that
are stored via dbWriteTable. Usage rights on these tables must
be granted for them to be usable inside the db functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_grant_to_admin(con, table, schema = "timeseries")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="db_grant_to_admin_+3A_con">con</code></td>
<td>
<p>RPostgres connection object.</p>
</td></tr>
<tr><td><code id="db_grant_to_admin_+3A_table">table</code></td>
<td>
<p>which table to grant rights on</p>
</td></tr>
<tr><td><code id="db_grant_to_admin_+3A_schema">schema</code></td>
<td>
<p><strong>character</strong> name of the database schema. Defaults to 'timeseries'</p>
</td></tr>
</table>

<hr>
<h2 id='db_meta_get_latest_validity'>Get Latest Validity for Metadata of a Given Time Series</h2><span id='topic+db_meta_get_latest_validity'></span>

<h3>Description</h3>

<p>Because metadata are only loosely coupled with their respective time series
in order to keep metadata records constant over multiple version of
time series if the data description does not change, it comes in
handy to find out the last time meta information was updated. This function
automagickally finds exactly this date.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_meta_get_latest_validity(
  con,
  ts_keys,
  regex = FALSE,
  locale = NULL,
  schema = "timeseries"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="db_meta_get_latest_validity_+3A_con">con</code></td>
<td>
<p>RPostgres connection object.</p>
</td></tr>
<tr><td><code id="db_meta_get_latest_validity_+3A_ts_keys">ts_keys</code></td>
<td>
<p><strong>character</strong> vector of time series identifiers.</p>
</td></tr>
<tr><td><code id="db_meta_get_latest_validity_+3A_regex">regex</code></td>
<td>
<p><strong>boolean</strong> indicating if ts_keys should be interpreted as a regular expression pattern. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="db_meta_get_latest_validity_+3A_locale">locale</code></td>
<td>
<p><strong>character</strong> indicating the language of the meta information to be store. We recommend to use ISO country codes to represent languages. Defaults to NULL. When local is set to NULL, metadata are stored without localization. Note that, when localizing meta information by assigning a language, multiple meta information objects can be stored for a single time series.</p>
</td></tr>
<tr><td><code id="db_meta_get_latest_validity_+3A_schema">schema</code></td>
<td>
<p><strong>character</strong> name of the database schema. Defaults to 'timeseries'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.table of latest validity
</p>


<h3>See Also</h3>

<p>Other metadata functions: 
<code><a href="#topic+db_collection_read_metadata">db_collection_read_metadata</a>()</code>,
<code><a href="#topic+db_dataset_read_metadata">db_dataset_read_metadata</a>()</code>,
<code><a href="#topic+db_metadata_read">db_metadata_read</a>()</code>,
<code><a href="#topic+db_metadata_store">db_metadata_store</a>()</code>
</p>

<hr>
<h2 id='db_metadata_read'>Read Time Series Metadata</h2><span id='topic+db_metadata_read'></span>

<h3>Description</h3>

<p>Read meta information given a vector of time series identifiers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_metadata_read(
  con,
  ts_keys,
  valid_on = NULL,
  regex = FALSE,
  locale = NULL,
  schema = "timeseries"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="db_metadata_read_+3A_con">con</code></td>
<td>
<p>RPostgres connection object.</p>
</td></tr>
<tr><td><code id="db_metadata_read_+3A_ts_keys">ts_keys</code></td>
<td>
<p><strong>character</strong> vector of time series identifiers.</p>
</td></tr>
<tr><td><code id="db_metadata_read_+3A_valid_on">valid_on</code></td>
<td>
<p><strong>character</strong> representation of a date in the form of 'YYYY-MM-DD'. valid_on selects the
version of a time series that is valid at the specified time.</p>
</td></tr>
<tr><td><code id="db_metadata_read_+3A_regex">regex</code></td>
<td>
<p><strong>boolean</strong> indicating if ts_keys should be interpreted as a regular expression pattern. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="db_metadata_read_+3A_locale">locale</code></td>
<td>
<p><strong>character</strong> indicating the language of the meta information to be store. We recommend to use ISO country codes to represent languages. Defaults to NULL. When local is set to NULL, metadata are stored without localization. Note that, when localizing meta information by assigning a language, multiple meta information objects can be stored for a single time series.</p>
</td></tr>
<tr><td><code id="db_metadata_read_+3A_schema">schema</code></td>
<td>
<p><strong>character</strong> name of the database schema. Defaults to 'timeseries'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of tsmeta objects.
</p>


<h3>See Also</h3>

<p>Other metadata functions: 
<code><a href="#topic+db_collection_read_metadata">db_collection_read_metadata</a>()</code>,
<code><a href="#topic+db_dataset_read_metadata">db_dataset_read_metadata</a>()</code>,
<code><a href="#topic+db_meta_get_latest_validity">db_meta_get_latest_validity</a>()</code>,
<code><a href="#topic+db_metadata_store">db_metadata_store</a>()</code>
</p>

<hr>
<h2 id='db_metadata_store'>Store Time Series Metadata to PostgreSQL</h2><span id='topic+db_metadata_store'></span>

<h3>Description</h3>

<p>The most basic way to store meta information is to assign non-translated (unlocalized) descriptions, but it also can be stored in different languages (localized) using the parameter <strong>locale</strong>. See also <a href="https://mbannert.github.io/timeseriesdb/articles/a01_basic_usage.html#basic-metadata">basic usage</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_metadata_store(
  con,
  metadata,
  valid_from,
  locale = NULL,
  on_conflict = "update",
  schema = "timeseries"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="db_metadata_store_+3A_con">con</code></td>
<td>
<p>RPostgres connection object.</p>
</td></tr>
<tr><td><code id="db_metadata_store_+3A_metadata">metadata</code></td>
<td>
<p>object of class tsmeta that contains the metadata to be stored.</p>
</td></tr>
<tr><td><code id="db_metadata_store_+3A_valid_from">valid_from</code></td>
<td>
<p><strong>character</strong> representation of a date in the form of 'YYYY-MM-DD'. It should always be explicitly specified.</p>
</td></tr>
<tr><td><code id="db_metadata_store_+3A_locale">locale</code></td>
<td>
<p><strong>character</strong> indicating the language of the meta information to be store. We recommend to use ISO country codes to represent languages. Defaults to NULL. When local is set to NULL, metadata are stored without localization. Note that, when localizing meta information by assigning a language, multiple meta information objects can be stored for a single time series.</p>
</td></tr>
<tr><td><code id="db_metadata_store_+3A_on_conflict">on_conflict</code></td>
<td>
<p><strong>character</strong> either &quot;update&quot;: add new fields and update existing ones or &quot;overwrite&quot;: completely replace existing record.</p>
</td></tr>
<tr><td><code id="db_metadata_store_+3A_schema">schema</code></td>
<td>
<p><strong>character</strong> name of the database schema. Defaults to 'timeseries'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>status list created from DB status return JSON.
</p>


<h3>See Also</h3>

<p>Other metadata functions: 
<code><a href="#topic+db_collection_read_metadata">db_collection_read_metadata</a>()</code>,
<code><a href="#topic+db_dataset_read_metadata">db_dataset_read_metadata</a>()</code>,
<code><a href="#topic+db_meta_get_latest_validity">db_meta_get_latest_validity</a>()</code>,
<code><a href="#topic+db_metadata_read">db_metadata_read</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
sum("a")

## End(Not run)
</code></pre>

<hr>
<h2 id='db_release_cancel'>Cancel a Scheduled Release</h2><span id='topic+db_release_cancel'></span>

<h3>Description</h3>

<p>Attempts to cancel a release that has already passed will result in an error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_release_cancel(con, release_id, schema = "timeseries")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="db_release_cancel_+3A_con">con</code></td>
<td>
<p>RPostgres connection object.</p>
</td></tr>
<tr><td><code id="db_release_cancel_+3A_release_id">release_id</code></td>
<td>
<p>character ID of the release to cancel</p>
</td></tr>
<tr><td><code id="db_release_cancel_+3A_schema">schema</code></td>
<td>
<p><strong>character</strong> name of the database schema. Defaults to 'timeseries'</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other calendar functions: 
<code><a href="#topic+db_dataset_get_latest_release">db_dataset_get_latest_release</a>()</code>,
<code><a href="#topic+db_dataset_get_next_release">db_dataset_get_next_release</a>()</code>,
<code><a href="#topic+db_dataset_get_release">db_dataset_get_release</a>()</code>,
<code><a href="#topic+db_release_create">db_release_create</a>()</code>,
<code><a href="#topic+db_release_list">db_release_list</a>()</code>,
<code><a href="#topic+db_release_update">db_release_update</a>()</code>
</p>

<hr>
<h2 id='db_release_create'>Create an Entry in the Release Calendar</h2><span id='topic+db_release_create'></span>

<h3>Description</h3>

<p>The idea of the release calendar is to set a release date for some time series that might be in the database already but should not be publicly available before a specific date, e.g., a press release. Since publishing is simply a matter of changing the access level, an update of the access levels could be triggered based on the release information in a release table. Only timeseries admins may create and modify releases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_release_create(
  con,
  id,
  title,
  release_date,
  datasets,
  target_year = year(release_date),
  target_period = month(release_date),
  target_frequency = 12,
  note = NULL,
  schema = "timeseries"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="db_release_create_+3A_con">con</code></td>
<td>
<p>RPostgres connection object.</p>
</td></tr>
<tr><td><code id="db_release_create_+3A_id">id</code></td>
<td>
<p>Identifier for the release e.g. 'gdb_may_2020'</p>
</td></tr>
<tr><td><code id="db_release_create_+3A_title">title</code></td>
<td>
<p>Display title for the release</p>
</td></tr>
<tr><td><code id="db_release_create_+3A_release_date">release_date</code></td>
<td>
<p>Timestamp when the release is to occur</p>
</td></tr>
<tr><td><code id="db_release_create_+3A_datasets">datasets</code></td>
<td>
<p><strong>character</strong> vector of the datasets. Dataset is a group of time series.</p>
</td></tr>
<tr><td><code id="db_release_create_+3A_target_year">target_year</code></td>
<td>
<p>Year observed in the data</p>
</td></tr>
<tr><td><code id="db_release_create_+3A_target_period">target_period</code></td>
<td>
<p>Period observed in the data (e.g. month, quarter)</p>
</td></tr>
<tr><td><code id="db_release_create_+3A_target_frequency">target_frequency</code></td>
<td>
<p>Frequency of the data (e.g. 4 for quarterly)</p>
</td></tr>
<tr><td><code id="db_release_create_+3A_note">note</code></td>
<td>
<p>Additional remarks about the release.</p>
</td></tr>
<tr><td><code id="db_release_create_+3A_schema">schema</code></td>
<td>
<p><strong>character</strong> name of the database schema. Defaults to 'timeseries'</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>target_period</code> changes meaning depending on the frequency of the release.
e.g. period 2 for quarterly data (reference_frequency = 4) means Q2 whereas
period 2 for monthly data (frequency 12) means February
In other words: <code>target_year</code> and <code>target_period</code> mark the end of the time series
in the release.
</p>


<h3>Value</h3>

<p>a status list
</p>


<h3>See Also</h3>

<p>Other calendar functions: 
<code><a href="#topic+db_dataset_get_latest_release">db_dataset_get_latest_release</a>()</code>,
<code><a href="#topic+db_dataset_get_next_release">db_dataset_get_next_release</a>()</code>,
<code><a href="#topic+db_dataset_get_release">db_dataset_get_release</a>()</code>,
<code><a href="#topic+db_release_cancel">db_release_cancel</a>()</code>,
<code><a href="#topic+db_release_list">db_release_list</a>()</code>,
<code><a href="#topic+db_release_update">db_release_update</a>()</code>
</p>

<hr>
<h2 id='db_release_list'>List Data on Registered Releases</h2><span id='topic+db_release_list'></span>

<h3>Description</h3>

<p>List Data on Registered Releases
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_release_list(con, include_past = FALSE, schema = "timeseries")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="db_release_list_+3A_con">con</code></td>
<td>
<p>RPostgres connection object.</p>
</td></tr>
<tr><td><code id="db_release_list_+3A_include_past">include_past</code></td>
<td>
<p>Should past releases be included? Defaults to FALSE</p>
</td></tr>
<tr><td><code id="db_release_list_+3A_schema">schema</code></td>
<td>
<p><strong>character</strong> name of the database schema. Defaults to 'timeseries'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with columns 'id', 'title', 'note', 'release_date', 'reference_year', 'reference_period', 'reference_frequency'
</p>


<h3>See Also</h3>

<p>Other calendar functions: 
<code><a href="#topic+db_dataset_get_latest_release">db_dataset_get_latest_release</a>()</code>,
<code><a href="#topic+db_dataset_get_next_release">db_dataset_get_next_release</a>()</code>,
<code><a href="#topic+db_dataset_get_release">db_dataset_get_release</a>()</code>,
<code><a href="#topic+db_release_cancel">db_release_cancel</a>()</code>,
<code><a href="#topic+db_release_create">db_release_create</a>()</code>,
<code><a href="#topic+db_release_update">db_release_update</a>()</code>
</p>

<hr>
<h2 id='db_release_update'>Update an Existing Release Record</h2><span id='topic+db_release_update'></span>

<h3>Description</h3>

<p>Any parameters provided to this function will overwrite the corresponding
fields in the database. Parameters set to NA (default) will leave the
corresponding fields untouched.
For details see <code><a href="#topic+db_release_create">db_release_create</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_release_update(
  con,
  id,
  title = NULL,
  release_date = NULL,
  datasets = NULL,
  target_year = NULL,
  target_period = NULL,
  target_frequency = NULL,
  note = NULL,
  schema = "timeseries"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="db_release_update_+3A_con">con</code></td>
<td>
<p>RPostgres connection object.</p>
</td></tr>
<tr><td><code id="db_release_update_+3A_id">id</code></td>
<td>
<p>Identifier for the release e.g. 'gdb_may_2020'</p>
</td></tr>
<tr><td><code id="db_release_update_+3A_title">title</code></td>
<td>
<p>Display title for the release</p>
</td></tr>
<tr><td><code id="db_release_update_+3A_release_date">release_date</code></td>
<td>
<p>Timestamp when the release is to occur</p>
</td></tr>
<tr><td><code id="db_release_update_+3A_datasets">datasets</code></td>
<td>
<p><strong>character</strong> vector of the datasets. Dataset is a group of time series.</p>
</td></tr>
<tr><td><code id="db_release_update_+3A_target_year">target_year</code></td>
<td>
<p>Year observed in the data</p>
</td></tr>
<tr><td><code id="db_release_update_+3A_target_period">target_period</code></td>
<td>
<p>Period observed in the data (e.g. month, quarter)</p>
</td></tr>
<tr><td><code id="db_release_update_+3A_target_frequency">target_frequency</code></td>
<td>
<p>Frequency of the data (e.g. 4 for quarterly)</p>
</td></tr>
<tr><td><code id="db_release_update_+3A_note">note</code></td>
<td>
<p>Additional remarks about the release.</p>
</td></tr>
<tr><td><code id="db_release_update_+3A_schema">schema</code></td>
<td>
<p><strong>character</strong> name of the database schema. Defaults to 'timeseries'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a status list
</p>


<h3>See Also</h3>

<p>Other calendar functions: 
<code><a href="#topic+db_dataset_get_latest_release">db_dataset_get_latest_release</a>()</code>,
<code><a href="#topic+db_dataset_get_next_release">db_dataset_get_next_release</a>()</code>,
<code><a href="#topic+db_dataset_get_release">db_dataset_get_release</a>()</code>,
<code><a href="#topic+db_release_cancel">db_release_cancel</a>()</code>,
<code><a href="#topic+db_release_create">db_release_create</a>()</code>,
<code><a href="#topic+db_release_list">db_release_list</a>()</code>
</p>

<hr>
<h2 id='db_ts_assign_dataset'>Assign Time Series Identifiers to a Dataset</h2><span id='topic+db_ts_assign_dataset'></span>

<h3>Description</h3>

<p>'db_ts_assign_dataset' returns a list with status information.
status '&quot;ok&quot;' means all went well.
status '&quot;warning&quot;' means some keys are not in the catalog. The vector of
those keys is in the 'offending_keys' field.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_ts_assign_dataset(con, ts_keys, set_name, schema = "timeseries")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="db_ts_assign_dataset_+3A_con">con</code></td>
<td>
<p>RPostgres connection object.</p>
</td></tr>
<tr><td><code id="db_ts_assign_dataset_+3A_ts_keys">ts_keys</code></td>
<td>
<p><strong>character</strong> vector of time series identifiers.</p>
</td></tr>
<tr><td><code id="db_ts_assign_dataset_+3A_set_name">set_name</code></td>
<td>
<p><strong>character</strong> name of a dataset.</p>
</td></tr>
<tr><td><code id="db_ts_assign_dataset_+3A_schema">schema</code></td>
<td>
<p><strong>character</strong> name of the database schema. Defaults to 'timeseries'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Trying to assign keys to a non-existent dataset is an error.
</p>


<h3>Value</h3>

<p>list A status list
</p>


<h3>See Also</h3>

<p>Other datasets functions: 
<code><a href="#topic+db_dataset_create">db_dataset_create</a>()</code>,
<code><a href="#topic+db_dataset_delete">db_dataset_delete</a>()</code>,
<code><a href="#topic+db_dataset_get_keys">db_dataset_get_keys</a>()</code>,
<code><a href="#topic+db_dataset_get_last_update">db_dataset_get_last_update</a>()</code>,
<code><a href="#topic+db_dataset_list">db_dataset_list</a>()</code>,
<code><a href="#topic+db_dataset_trim_history">db_dataset_trim_history</a>()</code>,
<code><a href="#topic+db_dataset_update_metadata">db_dataset_update_metadata</a>()</code>,
<code><a href="#topic+db_ts_get_dataset">db_ts_get_dataset</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

db_dataset_create(
  con = connection,
  set_name = "zrh_airport_data",
  set_description = "Zurich airport arrivals and departures ",
  schema = "schema"
)

db_ts_assign_dataset(
  con = connection,
  ts_keys = c(
    "ch.zrh_airport.departure.total",
    "ch.zrh_airport.arrival.total"
  ),
  set_name = "zrh_airport_data",
  schema = "schema"
)

## End(Not run)
</code></pre>

<hr>
<h2 id='db_ts_delete'>Remove Time Series from the Database</h2><span id='topic+db_ts_delete'></span>

<h3>Description</h3>

<p>This function completely removes a time series from the database, including
all vintages and metadata.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_ts_delete(con, ts_keys, schema = "timeseries", skip_checks = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="db_ts_delete_+3A_con">con</code></td>
<td>
<p>RPostgres connection object.</p>
</td></tr>
<tr><td><code id="db_ts_delete_+3A_ts_keys">ts_keys</code></td>
<td>
<p><strong>character</strong> vector of time series identifiers.</p>
</td></tr>
<tr><td><code id="db_ts_delete_+3A_schema">schema</code></td>
<td>
<p><strong>character</strong> name of the database schema. Defaults to 'timeseries'</p>
</td></tr>
<tr><td><code id="db_ts_delete_+3A_skip_checks">skip_checks</code></td>
<td>
<p>boolean should checks be skipped? Use with caution and only in batch mode! Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Due to the potentially severe consequences of such a deletion only timeseries
admins may perform this action and should do so very diligently.
</p>


<h3>See Also</h3>

<p>Other time series functions: 
<code><a href="#topic+db_collection_read_ts">db_collection_read_ts</a>()</code>,
<code><a href="#topic+db_dataset_read_ts">db_dataset_read_ts</a>()</code>,
<code><a href="#topic+db_ts_delete_latest_version">db_ts_delete_latest_version</a>()</code>,
<code><a href="#topic+db_ts_get_last_update">db_ts_get_last_update</a>()</code>,
<code><a href="#topic+db_ts_read_history">db_ts_read_history</a>()</code>,
<code><a href="#topic+db_ts_read">db_ts_read</a>()</code>,
<code><a href="#topic+db_ts_store">db_ts_store</a>()</code>,
<code><a href="#topic+db_ts_trim_history">db_ts_trim_history</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# Store zrh_airport data
db_ts_store(con = connection, zrh_airport, schema = "schema")

# Deleting one key
db_ts_delete(
  con = connection,
  ts_keys = "ch.zrh_airport.departure.total",
  schema = "schema"
)

# Deleting multiple keys
db_ts_delete(
  con = connection,
  ts_keys = c(
    "ch.zrh_airport.departure.total",
    "ch.zrh_airport.arrival.total"
  ),
  schema = "schema"
)

## End(Not run)
</code></pre>

<hr>
<h2 id='db_ts_delete_latest_version'>Delete the Latest Vintage of a Time Series</h2><span id='topic+db_ts_delete_latest_version'></span>

<h3>Description</h3>

<p>Vintages of time series should not be deleted as they are versions and
represent a former status of a time series that may not be stored elsewhere,
even not with their original provider. To benchmark forecasts it is essential
to keep the versions to evaluate real time performance of forecasts. However,
when operating at current edge of a time series, i.e., its last update, mistakes
may happen. Hence timeseriesdb allows to update / delete the last iteration.
Do not loop recursively through iterations to delete an entire time series.
There are admin level functions for that.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_ts_delete_latest_version(con, ts_keys, schema = "timeseries")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="db_ts_delete_latest_version_+3A_con">con</code></td>
<td>
<p>RPostgres connection object.</p>
</td></tr>
<tr><td><code id="db_ts_delete_latest_version_+3A_ts_keys">ts_keys</code></td>
<td>
<p><strong>character</strong> vector of time series identifiers.</p>
</td></tr>
<tr><td><code id="db_ts_delete_latest_version_+3A_schema">schema</code></td>
<td>
<p><strong>character</strong> name of the database schema. Defaults to 'timeseries'</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other time series functions: 
<code><a href="#topic+db_collection_read_ts">db_collection_read_ts</a>()</code>,
<code><a href="#topic+db_dataset_read_ts">db_dataset_read_ts</a>()</code>,
<code><a href="#topic+db_ts_delete">db_ts_delete</a>()</code>,
<code><a href="#topic+db_ts_get_last_update">db_ts_get_last_update</a>()</code>,
<code><a href="#topic+db_ts_read_history">db_ts_read_history</a>()</code>,
<code><a href="#topic+db_ts_read">db_ts_read</a>()</code>,
<code><a href="#topic+db_ts_store">db_ts_store</a>()</code>,
<code><a href="#topic+db_ts_trim_history">db_ts_trim_history</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

# Store different versions of the time series data
ch.kof.barometer &lt;- kof_ts["baro_2019m11"]
names(ch.kof.barometer) &lt;- c("ch.kof.barometer")
db_ts_store(
  con = connection,
  ch.kof.barometer,
  valid_from = "2019-12-01",
  schema = "schema"
)

ch.kof.barometer &lt;- kof_ts["baro_2019m12"]
names(ch.kof.barometer) &lt;- c("ch.kof.barometer")
db_ts_store(
  con = connection,
  ch.kof.barometer,
  valid_from = "2020-01-01",
  schema = "schema"
)

db_ts_delete_latest_version(
  con = connection,
  ts_keys = "ch.kof.barometer",
  schema = "schema"
)

## End(Not run)
</code></pre>

<hr>
<h2 id='db_ts_find_keys'>Get All keys that follow a pattern</h2><span id='topic+db_ts_find_keys'></span>

<h3>Description</h3>

<p>Get All keys that follow a pattern
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_ts_find_keys(con, pattern, schema = "timeseries")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="db_ts_find_keys_+3A_con">con</code></td>
<td>
<p>RPostgres connection object.</p>
</td></tr>
<tr><td><code id="db_ts_find_keys_+3A_pattern">pattern</code></td>
<td>
<p><strong>character</strong> that represents a regular expression to find keys</p>
</td></tr>
<tr><td><code id="db_ts_find_keys_+3A_schema">schema</code></td>
<td>
<p><strong>character</strong> name of the database schema. Defaults to 'timeseries'</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other access levels functions: 
<code><a href="#topic+change_access_level">change_access_level</a></code>,
<code><a href="#topic+db_access_level_create">db_access_level_create</a>()</code>,
<code><a href="#topic+db_access_level_delete">db_access_level_delete</a>()</code>,
<code><a href="#topic+db_access_level_list">db_access_level_list</a>()</code>,
<code><a href="#topic+db_access_level_set_default">db_access_level_set_default</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
db_ts_store(con = connection, zrh_airport, schema = "schema")

# get all keys that start with "ch"
db_ts_find_keys(
  con = connection,
  "^ch",
  schema = "schema")

## End(Not run)
</code></pre>

<hr>
<h2 id='db_ts_get_access_level'>Find Out About the Access Level of a Vintage</h2><span id='topic+db_ts_get_access_level'></span>

<h3>Description</h3>

<p>Provide the function with vector of time series keys and find out which access level is necessary to access the supplied keys.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_ts_get_access_level(con, ts_keys, valid_on = NULL, schema = "timeseries")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="db_ts_get_access_level_+3A_con">con</code></td>
<td>
<p>RPostgres connection object.</p>
</td></tr>
<tr><td><code id="db_ts_get_access_level_+3A_ts_keys">ts_keys</code></td>
<td>
<p><strong>character</strong> vector of time series identifiers.</p>
</td></tr>
<tr><td><code id="db_ts_get_access_level_+3A_valid_on">valid_on</code></td>
<td>
<p><strong>character</strong> representation of a date in the form of 'YYYY-MM-DD'. valid_on selects the
version of a time series that is valid at the specified time.</p>
</td></tr>
<tr><td><code id="db_ts_get_access_level_+3A_schema">schema</code></td>
<td>
<p><strong>character</strong> name of the database schema. Defaults to 'timeseries'</p>
</td></tr>
</table>

<hr>
<h2 id='db_ts_get_dataset'>Find Datasets Given a Set</h2><span id='topic+db_ts_get_dataset'></span>

<h3>Description</h3>

<p>Return set identifiers associated with a vector of keys. If a ts key does not exist in the catalog, set_id will be NA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_ts_get_dataset(con, ts_keys, schema = "timeseries")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="db_ts_get_dataset_+3A_con">con</code></td>
<td>
<p>RPostgres connection object.</p>
</td></tr>
<tr><td><code id="db_ts_get_dataset_+3A_ts_keys">ts_keys</code></td>
<td>
<p><strong>character</strong> vector of time series identifiers.</p>
</td></tr>
<tr><td><code id="db_ts_get_dataset_+3A_schema">schema</code></td>
<td>
<p><strong>character</strong> name of the database schema. Defaults to 'timeseries'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with columns 'ts_key' and 'set_id'
</p>


<h3>See Also</h3>

<p>Other datasets functions: 
<code><a href="#topic+db_dataset_create">db_dataset_create</a>()</code>,
<code><a href="#topic+db_dataset_delete">db_dataset_delete</a>()</code>,
<code><a href="#topic+db_dataset_get_keys">db_dataset_get_keys</a>()</code>,
<code><a href="#topic+db_dataset_get_last_update">db_dataset_get_last_update</a>()</code>,
<code><a href="#topic+db_dataset_list">db_dataset_list</a>()</code>,
<code><a href="#topic+db_dataset_trim_history">db_dataset_trim_history</a>()</code>,
<code><a href="#topic+db_dataset_update_metadata">db_dataset_update_metadata</a>()</code>,
<code><a href="#topic+db_ts_assign_dataset">db_ts_assign_dataset</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

# one key
db_ts_get_dataset(
  con = connection,
  ts_keys = "ch.zrh_airport.departure.total",
  schema = "schema"
)

# multiple keys
db_ts_get_dataset(
  con = connection,
  ts_keys = c(
    "ch.zrh_airport.departure.total",
    "ch.zrh_airport.arrival.total"
  ),
  schema = "schema"
)

## End(Not run)
</code></pre>

<hr>
<h2 id='db_ts_get_last_update'>Get the times series last update</h2><span id='topic+db_ts_get_last_update'></span>

<h3>Description</h3>

<p>Get the times series last update
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_ts_get_last_update(con, ts_keys, schema = "timeseries")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="db_ts_get_last_update_+3A_con">con</code></td>
<td>
<p>RPostgres connection object.</p>
</td></tr>
<tr><td><code id="db_ts_get_last_update_+3A_ts_keys">ts_keys</code></td>
<td>
<p><strong>character</strong> vector of time series identifiers.</p>
</td></tr>
<tr><td><code id="db_ts_get_last_update_+3A_schema">schema</code></td>
<td>
<p><strong>character</strong> name of the database schema. Defaults to 'timeseries'</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other time series functions: 
<code><a href="#topic+db_collection_read_ts">db_collection_read_ts</a>()</code>,
<code><a href="#topic+db_dataset_read_ts">db_dataset_read_ts</a>()</code>,
<code><a href="#topic+db_ts_delete_latest_version">db_ts_delete_latest_version</a>()</code>,
<code><a href="#topic+db_ts_delete">db_ts_delete</a>()</code>,
<code><a href="#topic+db_ts_read_history">db_ts_read_history</a>()</code>,
<code><a href="#topic+db_ts_read">db_ts_read</a>()</code>,
<code><a href="#topic+db_ts_store">db_ts_store</a>()</code>,
<code><a href="#topic+db_ts_trim_history">db_ts_trim_history</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
db_ts_store(con = connection, zrh_airport, schema = "schema")

# get last update for one key
db_ts_get_last_update(
  con = connection,
  ts_keys = "ch.zrh_airport.departure.total",
  schema = "schema")

# get last update for multiple keys
db_ts_get_last_update(
  con = connection,
  ts_keys = c(
    "ch.zrh_airport.departure.total",
    "ch.zrh_airport.arrival.total"
  ),
  schema = "schema"
)

## End(Not run)
</code></pre>

<hr>
<h2 id='db_ts_read'>Read Time Series From PostgreSQL into R</h2><span id='topic+db_ts_read'></span>

<h3>Description</h3>

<p>Read specific version of a time series given time series key (unique identifier) and validity. By default, this function returns the most recent version of a time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_ts_read(
  con,
  ts_keys,
  valid_on = NULL,
  regex = FALSE,
  respect_release_date = FALSE,
  schema = "timeseries",
  chunksize = 10000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="db_ts_read_+3A_con">con</code></td>
<td>
<p>RPostgres connection object.</p>
</td></tr>
<tr><td><code id="db_ts_read_+3A_ts_keys">ts_keys</code></td>
<td>
<p><strong>character</strong> vector of time series identifiers.</p>
</td></tr>
<tr><td><code id="db_ts_read_+3A_valid_on">valid_on</code></td>
<td>
<p><strong>character</strong> representation of a date in the form of 'YYYY-MM-DD'. valid_on selects the
version of a time series that is valid at the specified time.</p>
</td></tr>
<tr><td><code id="db_ts_read_+3A_regex">regex</code></td>
<td>
<p><strong>boolean</strong> indicating if ts_keys should be interpreted as a regular expression pattern. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="db_ts_read_+3A_respect_release_date">respect_release_date</code></td>
<td>
<p><strong>boolean</strong> indicating if it should the release embargo of a time series be respected. Defaults to FALSE. This option makes sense when the function is used in an API. In that sense, users do not have direct access to this function and therefore cannot simply switch parameters.</p>
</td></tr>
<tr><td><code id="db_ts_read_+3A_schema">schema</code></td>
<td>
<p><strong>character</strong> name of the database schema. Defaults to 'timeseries'</p>
</td></tr>
<tr><td><code id="db_ts_read_+3A_chunksize">chunksize</code></td>
<td>
<p>set a limit of the number of time series requested in the function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of time series. List elements vary depending on nature of time series, i.e., regular vs. irregular time series.
</p>


<h3>See Also</h3>

<p>Other time series functions: 
<code><a href="#topic+db_collection_read_ts">db_collection_read_ts</a>()</code>,
<code><a href="#topic+db_dataset_read_ts">db_dataset_read_ts</a>()</code>,
<code><a href="#topic+db_ts_delete_latest_version">db_ts_delete_latest_version</a>()</code>,
<code><a href="#topic+db_ts_delete">db_ts_delete</a>()</code>,
<code><a href="#topic+db_ts_get_last_update">db_ts_get_last_update</a>()</code>,
<code><a href="#topic+db_ts_read_history">db_ts_read_history</a>()</code>,
<code><a href="#topic+db_ts_store">db_ts_store</a>()</code>,
<code><a href="#topic+db_ts_trim_history">db_ts_trim_history</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
db_ts_store(con = connection, zrh_airport, schema = "schema")
db_ts_read(con = connection, ts_keys = "ch.zrh_airport.departure.total", schema = "schema")

## End(Not run)
</code></pre>

<hr>
<h2 id='db_ts_read_history'>Read the Entire History of a Time Series</h2><span id='topic+db_ts_read_history'></span>

<h3>Description</h3>

<p>This function returns a list whose keys correspond to the date on which the
contained version of the time series took effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_ts_read_history(
  con,
  ts_key,
  respect_release_date = FALSE,
  schema = "timeseries"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="db_ts_read_history_+3A_con">con</code></td>
<td>
<p>RPostgres connection object.</p>
</td></tr>
<tr><td><code id="db_ts_read_history_+3A_ts_key">ts_key</code></td>
<td>
<p>character The identifier of the time series to read.</p>
</td></tr>
<tr><td><code id="db_ts_read_history_+3A_respect_release_date">respect_release_date</code></td>
<td>
<p><strong>boolean</strong> indicating if it should the release embargo of a time series be respected. Defaults to FALSE. This option makes sense when the function is used in an API. In that sense, users do not have direct access to this function and therefore cannot simply switch parameters.</p>
</td></tr>
<tr><td><code id="db_ts_read_history_+3A_schema">schema</code></td>
<td>
<p><strong>character</strong> name of the database schema. Defaults to 'timeseries'</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other time series functions: 
<code><a href="#topic+db_collection_read_ts">db_collection_read_ts</a>()</code>,
<code><a href="#topic+db_dataset_read_ts">db_dataset_read_ts</a>()</code>,
<code><a href="#topic+db_ts_delete_latest_version">db_ts_delete_latest_version</a>()</code>,
<code><a href="#topic+db_ts_delete">db_ts_delete</a>()</code>,
<code><a href="#topic+db_ts_get_last_update">db_ts_get_last_update</a>()</code>,
<code><a href="#topic+db_ts_read">db_ts_read</a>()</code>,
<code><a href="#topic+db_ts_store">db_ts_store</a>()</code>,
<code><a href="#topic+db_ts_trim_history">db_ts_trim_history</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

# Storing different versions of the data, use parameter valid_from
# different versions are stored with the same key
ch.kof.barometer &lt;- kof_ts["baro_2019m11"]
names(ch.kof.barometer) &lt;- c("ch.kof.barometer")
db_ts_store(con = connection,
                  ch.kof.barometer,
                  valid_from = "2019-12-01",
                  schema = "schema")

ch.kof.barometer &lt;- kof_ts["baro_2019m12"]
names(ch.kof.barometer) &lt;- c("ch.kof.barometer")
db_ts_store(con = connection,
                  ch.kof.barometer,
                  valid_from = "2020-01-01",
                  schema = "schema")

# Reading all versions
db_ts_read_history(con = connection,
                         ts_key = "ch.kof.barometer",
                         schema = "schema")

## End(Not run)
</code></pre>

<hr>
<h2 id='db_ts_rename'>Rename Time Series by Assigning a New Key</h2><span id='topic+db_ts_rename'></span>

<h3>Description</h3>

<p>Rename Time Series by Assigning a New Key
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_ts_rename(con, ts_key, ts_key_new, schema = "timeseries")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="db_ts_rename_+3A_con">con</code></td>
<td>
<p>RPostgres connection object.</p>
</td></tr>
<tr><td><code id="db_ts_rename_+3A_ts_key">ts_key</code></td>
<td>
<p>character Vector of keys to rename</p>
</td></tr>
<tr><td><code id="db_ts_rename_+3A_ts_key_new">ts_key_new</code></td>
<td>
<p>character Vector of new names</p>
</td></tr>
<tr><td><code id="db_ts_rename_+3A_schema">schema</code></td>
<td>
<p><strong>character</strong> name of the database schema. Defaults to 'timeseries'</p>
</td></tr>
</table>

<hr>
<h2 id='db_ts_store'>Store a Time Series to the Database</h2><span id='topic+db_ts_store'></span>

<h3>Description</h3>

<p>Stores one or more time series to the database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_ts_store(
  con,
  x,
  access = NULL,
  valid_from = NULL,
  release_date = NULL,
  pre_release_access = NULL,
  schema = "timeseries"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="db_ts_store_+3A_con">con</code></td>
<td>
<p>RPostgres connection object.</p>
</td></tr>
<tr><td><code id="db_ts_store_+3A_x">x</code></td>
<td>
<p>Object containing time series to store. Single ts or xts objects are allowed as well as objects of type list, tslist, and data.table.</p>
</td></tr>
<tr><td><code id="db_ts_store_+3A_access">access</code></td>
<td>
<p>character Access level for all ts to be stored. If set to NA (default) the database set it to 'main' access.</p>
</td></tr>
<tr><td><code id="db_ts_store_+3A_valid_from">valid_from</code></td>
<td>
<p>character representation of a date in the form of 'YYYY-MM-DD'. valid_from starts a new version</p>
</td></tr>
<tr><td><code id="db_ts_store_+3A_release_date">release_date</code></td>
<td>
<p>character date from which on this version of the time series should be made available when release date is respected. Applies to all time series in x.</p>
</td></tr>
<tr><td><code id="db_ts_store_+3A_pre_release_access">pre_release_access</code></td>
<td>
<p>character Only allow access to the series being stored ahead of the release date to users with this access level. NULL (default) allows everybody. See respect_release_date in <code><a href="#topic+db_ts_read">db_ts_read</a></code>.</p>
</td></tr>
<tr><td><code id="db_ts_store_+3A_schema">schema</code></td>
<td>
<p><strong>character</strong> name of the database schema. Defaults to 'timeseries'</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other time series functions: 
<code><a href="#topic+db_collection_read_ts">db_collection_read_ts</a>()</code>,
<code><a href="#topic+db_dataset_read_ts">db_dataset_read_ts</a>()</code>,
<code><a href="#topic+db_ts_delete_latest_version">db_ts_delete_latest_version</a>()</code>,
<code><a href="#topic+db_ts_delete">db_ts_delete</a>()</code>,
<code><a href="#topic+db_ts_get_last_update">db_ts_get_last_update</a>()</code>,
<code><a href="#topic+db_ts_read_history">db_ts_read_history</a>()</code>,
<code><a href="#topic+db_ts_read">db_ts_read</a>()</code>,
<code><a href="#topic+db_ts_trim_history">db_ts_trim_history</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# storing zrh_airport data that is a list with two xts objects.
db_ts_store(con = connection, zrh_airport, schema = "schema")

# to store different versions of the data, use parameter valid_from
# different versions are stored with the same key
ch.kof.barometer &lt;- kof_ts["baro_2019m11"]
names(ch.kof.barometer) &lt;- c("ch.kof.barometer")
db_ts_store(
  con = connection,
  ch.kof.barometer,
  valid_from = "2019-12-01",
  schema = "schema"
)

ch.kof.barometer &lt;- kof_ts["baro_2019m12"]
names(ch.kof.barometer) &lt;- c("ch.kof.barometer")
db_ts_store(
  con = connection,
  ch.kof.barometer,
  valid_from = "2020-01-01",
  schema = "schema"
)

## End(Not run)
</code></pre>

<hr>
<h2 id='db_ts_trim_history'>Remove Vintages from the Beginning</h2><span id='topic+db_ts_trim_history'></span>

<h3>Description</h3>

<p>Removes any vintages of the given time series that are older than a specified date.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_ts_trim_history(con, ts_keys, older_than, schema = "timeseries")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="db_ts_trim_history_+3A_con">con</code></td>
<td>
<p>RPostgres connection object.</p>
</td></tr>
<tr><td><code id="db_ts_trim_history_+3A_ts_keys">ts_keys</code></td>
<td>
<p><strong>character</strong> vector of time series identifiers.</p>
</td></tr>
<tr><td><code id="db_ts_trim_history_+3A_older_than">older_than</code></td>
<td>
<p>Date cut off point</p>
</td></tr>
<tr><td><code id="db_ts_trim_history_+3A_schema">schema</code></td>
<td>
<p><strong>character</strong> name of the database schema. Defaults to 'timeseries'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In some cases only the last few versions of time series are of interest. This
function can be used to trim off old vintages that are no longer relevant.
</p>


<h3>See Also</h3>

<p>Other time series functions: 
<code><a href="#topic+db_collection_read_ts">db_collection_read_ts</a>()</code>,
<code><a href="#topic+db_dataset_read_ts">db_dataset_read_ts</a>()</code>,
<code><a href="#topic+db_ts_delete_latest_version">db_ts_delete_latest_version</a>()</code>,
<code><a href="#topic+db_ts_delete">db_ts_delete</a>()</code>,
<code><a href="#topic+db_ts_get_last_update">db_ts_get_last_update</a>()</code>,
<code><a href="#topic+db_ts_read_history">db_ts_read_history</a>()</code>,
<code><a href="#topic+db_ts_read">db_ts_read</a>()</code>,
<code><a href="#topic+db_ts_store">db_ts_store</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

# Store different versions of the time series data
ch.kof.barometer &lt;- kof_ts["baro_2019m11"]
names(ch.kof.barometer) &lt;- c("ch.kof.barometer")
db_ts_store(
  con = connection,
  ch.kof.barometer,
  valid_from = "2019-12-01",
  schema = "schema"
)

ch.kof.barometer &lt;- kof_ts["baro_2019m12"]
names(ch.kof.barometer) &lt;- c("ch.kof.barometer")
db_ts_store(
  con = connection,
  ch.kof.barometer,
  valid_from = "2020-01-01",
  schema = "schema"
)

db_ts_trim_history(
  con = connection,
  ts_keys = "ch.kof.barometer",
  older_than = "2019-12-31",
  schema = "schema"
)

## End(Not run)
</code></pre>

<hr>
<h2 id='db_with_tmp_read'>Helper to Create and Populate a Temporary Table for Fast Reading</h2><span id='topic+db_with_tmp_read'></span>

<h3>Description</h3>

<p>This function is not exported. It creates a tempory table containing the
keys that should be read to join them against the time series storage.
This is much faster for larger selections than simple where clauses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_with_tmp_read(con, ts_keys, regex = FALSE, code, schema = "timeseries")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="db_with_tmp_read_+3A_con">con</code></td>
<td>
<p>RPostgres connection object.</p>
</td></tr>
<tr><td><code id="db_with_tmp_read_+3A_ts_keys">ts_keys</code></td>
<td>
<p><strong>character</strong> vector of time series identifiers.</p>
</td></tr>
<tr><td><code id="db_with_tmp_read_+3A_regex">regex</code></td>
<td>
<p>logical if set to TRUE, the ts_keys parameter is interpreted as a regular expression pattern.</p>
</td></tr>
<tr><td><code id="db_with_tmp_read_+3A_code">code</code></td>
<td>
<p>expression Code to be evaluated after populating the temporary table on the database
of a time series that is valid from the specified date.</p>
</td></tr>
<tr><td><code id="db_with_tmp_read_+3A_schema">schema</code></td>
<td>
<p><strong>character</strong> name of the database schema. Defaults to 'timeseries'</p>
</td></tr>
</table>

<hr>
<h2 id='has_depth_2'>Test if a list has exactly depth 2</h2><span id='topic+has_depth_2'></span>

<h3>Description</h3>

<p>Test if a list has exactly depth 2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has_depth_2(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="has_depth_2_+3A_x">x</code></td>
<td>
<p>The list to check</p>
</td></tr>
</table>

<hr>
<h2 id='index_to_date'>Helper Function for Date Operations</h2><span id='topic+index_to_date'></span>

<h3>Description</h3>

<p>This function is not exported.
Helper function to convert time series indices of the form 2005.75
to a date representation like 2005-07-01.
Does not currently support sub-monthly frequencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>index_to_date(x, as.string = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="index_to_date_+3A_x">x</code></td>
<td>
<p>numeric A vector of time series time indices (e.g. from stats::time)</p>
</td></tr>
<tr><td><code id="index_to_date_+3A_as.string">as.string</code></td>
<td>
<p>logical If as.string is TRUE the string representation of the
Date is returned, otherwise a Date object.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: index_to_date(2020.25)
</code></pre>

<hr>
<h2 id='install_timeseriesdb'>Install timeseriesdb</h2><span id='topic+install_timeseriesdb'></span>

<h3>Description</h3>

<p>Install timeseriesdb in a given PostgreSQL schema. Make sure the database user
has sufficient rights to perform the necessary operations on the schema. In the process
tables, roles, triggers and functions will be created. Also extensions will be installed and
rights will be granted and revoked from the freshly created roles.
Note also, that the functions created are created as SECURITY DEFINER roles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>install_timeseriesdb(
  con,
  schema = "timeseries",
  verbose = FALSE,
  install_tables = TRUE,
  install_functions = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="install_timeseriesdb_+3A_con">con</code></td>
<td>
<p>RPostgres connection object.</p>
</td></tr>
<tr><td><code id="install_timeseriesdb_+3A_schema">schema</code></td>
<td>
<p><strong>character</strong> name of the database schema. Defaults to 'timeseries'</p>
</td></tr>
<tr><td><code id="install_timeseriesdb_+3A_verbose">verbose</code></td>
<td>
<p>boolean Should progress messages be printed? Default FALSE</p>
</td></tr>
<tr><td><code id="install_timeseriesdb_+3A_install_tables">install_tables</code></td>
<td>
<p>boolean Should the tables be created? Default TRUE</p>
</td></tr>
<tr><td><code id="install_timeseriesdb_+3A_install_functions">install_functions</code></td>
<td>
<p>boolean Should the functions be installed? Default TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>install_tables</code> and <code>install_functions</code> can be used to install components of
timeseriesdb independently (e.g. only update function definitions without touching the
table structure). They are used mainly for development purposes.
</p>

<hr>
<h2 id='json_to_ts'>Convert JSON Representation of a Time Series into R Time Series Objects</h2><span id='topic+json_to_ts'></span>

<h3>Description</h3>

<p>This function is not exported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>json_to_ts(jsn, as.dt = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="json_to_ts_+3A_jsn">jsn</code></td>
<td>
<p>JSON string to convert</p>
</td></tr>
<tr><td><code id="json_to_ts_+3A_as.dt">as.dt</code></td>
<td>
<p>boolean Should the result be returned as a data.table?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>R time series representation of class ts, xts or data.table depending on parameter setting and nature of time series. Regular time series can be returned as 'ts' objects whereas irregular time series use 'xts' objects.
</p>

<hr>
<h2 id='kof_ts'>KOF indicators</h2><span id='topic+kof_ts'></span>

<h3>Description</h3>

<p>KOF indicators
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kof_ts
</code></pre>


<h3>Format</h3>

<p>A list with four time series objects:
</p>

<dl>
<dt>ch.kof.barometer</dt><dd><p>Indicator for the Swiss Business Cycle.</p>
</dd>
<dt>baro</dt><dd><p>Vintages (versions) of the KOF Barometer Indicator.</p>
</dd>
<dt>ch.kof.ie.retro.ch_total.ind.d11</dt><dd><p>KOF Employment Indicator for Switzerland</p>
</dd>
</dl>



<h3>Source</h3>

<p>KOF Swiss Economic Institute - KOF indicators.
<a href="https://kof.ethz.ch/en/forecasts-and-indicators/indicators.html">https://kof.ethz.ch/en/forecasts-and-indicators/indicators.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 kof_ts

## End(Not run)
</code></pre>

<hr>
<h2 id='param_defs'>Common parameters</h2><span id='topic+param_defs'></span>

<h3>Description</h3>

<p>Common parameters
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="param_defs_+3A_con">con</code></td>
<td>
<p>RPostgres connection object.</p>
</td></tr>
<tr><td><code id="param_defs_+3A_schema">schema</code></td>
<td>
<p><strong>character</strong> name of the database schema. Defaults to 'timeseries'</p>
</td></tr>
<tr><td><code id="param_defs_+3A_ts_keys">ts_keys</code></td>
<td>
<p><strong>character</strong> vector of time series identifiers.</p>
</td></tr>
<tr><td><code id="param_defs_+3A_dataset">dataset</code></td>
<td>
<p><strong>character</strong> name of the dataset. Datasets are group of time series.</p>
</td></tr>
<tr><td><code id="param_defs_+3A_datasets">datasets</code></td>
<td>
<p><strong>character</strong> vector of the datasets. Dataset is a group of time series.</p>
</td></tr>
<tr><td><code id="param_defs_+3A_valid_on">valid_on</code></td>
<td>
<p><strong>character</strong> representation of a date in the form of 'YYYY-MM-DD'. valid_on selects the
version of a time series that is valid at the specified time.</p>
</td></tr>
<tr><td><code id="param_defs_+3A_valid_from">valid_from</code></td>
<td>
<p>character representation of a date in the form of 'YYYY-MM-DD'. valid_from starts a new version</p>
</td></tr>
<tr><td><code id="param_defs_+3A_code">code</code></td>
<td>
<p>expression Code to be evaluated after populating the temporary table on the database
of a time series that is valid from the specified date.</p>
</td></tr>
<tr><td><code id="param_defs_+3A_collection_name">collection_name</code></td>
<td>
<p><strong>character</strong> name of a collection to read. Collection are bookmark lists that contain time series keys.</p>
</td></tr>
<tr><td><code id="param_defs_+3A_access_level">access_level</code></td>
<td>
<p><strong>character</strong> describing the access level of the time series or dataset.</p>
</td></tr>
<tr><td><code id="param_defs_+3A_set_name">set_name</code></td>
<td>
<p><strong>character</strong> name of a dataset.</p>
</td></tr>
<tr><td><code id="param_defs_+3A_regex">regex</code></td>
<td>
<p><strong>boolean</strong> indicating if ts_keys should be interpreted as a regular expression pattern. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="param_defs_+3A_locale">locale</code></td>
<td>
<p><strong>character</strong> indicating the language of the meta information to be store. We recommend to use ISO country codes to represent languages. Defaults to NULL. When local is set to NULL, metadata are stored without localization. Note that, when localizing meta information by assigning a language, multiple meta information objects can be stored for a single time series.</p>
</td></tr>
<tr><td><code id="param_defs_+3A_respect_release_date">respect_release_date</code></td>
<td>
<p><strong>boolean</strong> indicating if it should the release embargo of a time series be respected. Defaults to FALSE. This option makes sense when the function is used in an API. In that sense, users do not have direct access to this function and therefore cannot simply switch parameters.</p>
</td></tr>
<tr><td><code id="param_defs_+3A_chunksize">chunksize</code></td>
<td>
<p>set a limit of the number of time series requested in the function.</p>
</td></tr>
<tr><td><code id="param_defs_+3A_collection_owner">collection_owner</code></td>
<td>
<p><strong>character</strong> username that is the owner of a collection.</p>
</td></tr>
<tr><td><code id="param_defs_+3A_user">user</code></td>
<td>
<p>character name of the database user. Defaults to the user of the R session.
this is often the user for the database, too so you do not have to specify
your username explicitly if that is the case.</p>
</td></tr>
</table>

<hr>
<h2 id='print.meta'>Print Method for meta Object</h2><span id='topic+print.meta'></span>

<h3>Description</h3>

<p>Print Method for meta Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'meta'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.meta_+3A_x">x</code></td>
<td>
<p>a metadata object.</p>
</td></tr>
<tr><td><code id="print.meta_+3A_...">...</code></td>
<td>
<p>list of print options.</p>
</td></tr>
</table>

<hr>
<h2 id='setup_sql_extentions'>Install PostgreSQL Schemas and Extensions</h2><span id='topic+setup_sql_extentions'></span>

<h3>Description</h3>

<p>Installs schema, uuid-ossp, btree_gist.
This function must be run with a connection of a database level admin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setup_sql_extentions(con, schema = "timeseries")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setup_sql_extentions_+3A_con">con</code></td>
<td>
<p>RPostgres connection object.</p>
</td></tr>
<tr><td><code id="setup_sql_extentions_+3A_schema">schema</code></td>
<td>
<p>schema character schema name, defaults to 'timeseries'.</p>
</td></tr>
</table>

<hr>
<h2 id='setup_sql_functions'>Install timeseriesdb System Functions</h2><span id='topic+setup_sql_functions'></span>

<h3>Description</h3>

<p>Installs functions needed to operated timeseriesdb in
a given PostgreSQL schema. The functions uses a default SQL file installed
with the package to generate SQL functions. The default schema 'timeseries'
can be replaced using the 'schema' parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setup_sql_functions(con, schema = "timeseries", prnt = identity)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setup_sql_functions_+3A_con">con</code></td>
<td>
<p>PostgreSQL connection object created by the RPostgres package.</p>
</td></tr>
<tr><td><code id="setup_sql_functions_+3A_schema">schema</code></td>
<td>
<p>character schema name, defaults to 'timeseries'.</p>
</td></tr>
<tr><td><code id="setup_sql_functions_+3A_prnt">prnt</code></td>
<td>
<p>function log printing function</p>
</td></tr>
</table>

<hr>
<h2 id='setup_sql_grant_rights'>Grant execute on timeseriesdb functions</h2><span id='topic+setup_sql_grant_rights'></span>

<h3>Description</h3>

<p>Grant execute on timeseriesdb functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setup_sql_grant_rights(con, schema = "timeseries", prnt = identity)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setup_sql_grant_rights_+3A_con">con</code></td>
<td>
<p>RPostgres connection object</p>
</td></tr>
<tr><td><code id="setup_sql_grant_rights_+3A_schema">schema</code></td>
<td>
<p>character schema name, defaults to 'timeseries'</p>
</td></tr>
<tr><td><code id="setup_sql_grant_rights_+3A_prnt">prnt</code></td>
<td>
<p>function log printing function</p>
</td></tr>
</table>

<hr>
<h2 id='setup_sql_roles'>Create Roles needed for operation of timeseriesdb</h2><span id='topic+setup_sql_roles'></span>

<h3>Description</h3>

<p>This function must be run with a connection of a database level admin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setup_sql_roles(con, schema = "timeseries")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setup_sql_roles_+3A_con">con</code></td>
<td>
<p>RPostgres connection object</p>
</td></tr>
<tr><td><code id="setup_sql_roles_+3A_schema">schema</code></td>
<td>
<p>schema character schema name, defaults to 'timeseries'.</p>
</td></tr>
</table>

<hr>
<h2 id='setup_sql_tables'>Install timeseriesdb System Tables</h2><span id='topic+setup_sql_tables'></span>

<h3>Description</h3>

<p>Installs tables needed to operated timeseriesdb in
a given PostgreSQL schema. The tables use a default SQL file installed
with the package to generate SQL tables. The default schema 'timeseries'
can be replaced using the 'schema' parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setup_sql_tables(con, schema = "timeseries", prnt = identity)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setup_sql_tables_+3A_con">con</code></td>
<td>
<p>PostgreSQL connection object created by the RPostgres package.</p>
</td></tr>
<tr><td><code id="setup_sql_tables_+3A_schema">schema</code></td>
<td>
<p>character schema name, defaults to 'timeseries'.</p>
</td></tr>
<tr><td><code id="setup_sql_tables_+3A_prnt">prnt</code></td>
<td>
<p>function log printing function</p>
</td></tr>
</table>

<hr>
<h2 id='setup_sql_triggers'>Install timeseriesdb Triggers</h2><span id='topic+setup_sql_triggers'></span>

<h3>Description</h3>

<p>Installs functions needed for timeseriesdb triggers and sets up these triggers in
a given PostgreSQL schema. The functions uses a default SQL file installed
with the package to generate SQL functions. The default schema 'timeseries'
can be replaced using the 'schema' parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setup_sql_triggers(con, schema = "timeseries", prnt = identity)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setup_sql_triggers_+3A_con">con</code></td>
<td>
<p>PostgreSQL connection object created by the RPostgres package.</p>
</td></tr>
<tr><td><code id="setup_sql_triggers_+3A_schema">schema</code></td>
<td>
<p>character schema name, defaults to 'timeseries'.</p>
</td></tr>
<tr><td><code id="setup_sql_triggers_+3A_prnt">prnt</code></td>
<td>
<p>function log printing function</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
