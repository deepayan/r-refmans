<!DOCTYPE html><html><head><title>Help for package netcom</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {netcom}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#align'><p>Network Alignment</p></a></li>
<li><a href='#best_fit_optim'><p>Empirical parameterization</p></a></li>
<li><a href='#classify'><p>Mechanistic Network Classification</p></a></li>
<li><a href='#classify_Systematic'><p>Mechanistic Network Classification</p></a></li>
<li><a href='#compare'><p>Compare Networks Many-to-Many</p></a></li>
<li><a href='#compare_Target'><p>Compare Networks One-to-Many</p></a></li>
<li><a href='#gini'><p>Gini coefficient</p></a></li>
<li><a href='#grow_DD'><p>Grow a Duplication and Divergence Network</p></a></li>
<li><a href='#grow_DM'><p>Grow a Duplication and Mutation Network</p></a></li>
<li><a href='#grow_ER'><p>Grow an Erdos-Renyi Random Network</p></a></li>
<li><a href='#grow_NM'><p>Grow a Niche Model Network</p></a></li>
<li><a href='#grow_PA'><p>Grow a Preferential Attachment Network</p></a></li>
<li><a href='#grow_SW'><p>Grow a Small-World Network</p></a></li>
<li><a href='#ics'><p>Induced Conserved Structure (ICS)</p></a></li>
<li><a href='#make_DD'><p>Makes a Duplication and Divergence Network</p></a></li>
<li><a href='#make_DM'><p>Make a Duplication and Mutation Network</p></a></li>
<li><a href='#make_Mixture'><p>Make a Mixture Mechanism Network</p></a></li>
<li><a href='#make_NM'><p>Make a Niche Model network</p></a></li>
<li><a href='#make_Null'><p>Mechanism Null Distributions</p></a></li>
<li><a href='#make_Null_canonical'><p>Mechanism Null Distributions</p></a></li>
<li><a href='#make_Null_mixture'><p>Mechanism Null Distributions</p></a></li>
<li><a href='#make_SW'><p>Makes a Small-World Network</p></a></li>
<li><a href='#make_Systematic'><p>Systematically Make Networks</p></a></li>
<li><a href='#make_Systematic_canonical'><p>Systematically Make Networks</p></a></li>
<li><a href='#make_Systematic_directedCanonicalLike'><p>Systematically Make Networks</p></a></li>
<li><a href='#make_Systematic_mixture'><p>Systematically Make Networks</p></a></li>
<li><a href='#null_fit_optim'><p>Empirical parameterization via null distributions</p></a></li>
<li><a href='#stir_DD'><p>Sitrs a Duplication and Divergence Network</p></a></li>
<li><a href='#stir_DM'><p>Stirs a Duplication and Mutation Network</p></a></li>
<li><a href='#stir_ER'><p>Stir an Erdos-Renyi Random Network</p></a></li>
<li><a href='#stir_NM'><p>Stirs a Niche Model Network</p></a></li>
<li><a href='#stir_PA'><p>Stirs a Preferential Attachment Network</p></a></li>
<li><a href='#stir_SW'><p>Stirs a Small-World Network</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>NETwork COMparison Inference</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.7</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-5-28</td>
</tr>
<tr>
<td>Description:</td>
<td>Infer system functioning with empirical NETwork COMparisons. These methods are part of a growing paradigm in network science that uses relative comparisons of networks to infer mechanistic classifications and predict systemic interventions. They have been developed and applied in Langendorf and Burgess (2021) &lt;<a href="https://doi.org/10.1038%2Fs41598-021-99251-7">doi:10.1038/s41598-021-99251-7</a>&gt;, Langendorf (2020) &lt;<a href="https://doi.org/10.1201%2F9781351190831-6">doi:10.1201/9781351190831-6</a>&gt;, and Langendorf and Goldberg (2019) &lt;<a href="https://doi.org/10.48550%2FarXiv.1912.12551">doi:10.48550/arXiv.1912.12551</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/langendorfr/netcom">https://github.com/langendorfr/netcom</a></td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, dplyr, tibble, clue, expm, igraph, Matrix, pdist,
pracma, vegan, magrittr, foreach, parallel, doParallel, optimx,
GenSA, rlang, ggfortify, ggplot2, ggraph, reshape2</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-04 16:27:43 UTC; ryan</td>
</tr>
<tr>
<td>Author:</td>
<td>Ryan Langendorf [aut, cre],
  Debra Goldberg [ctb],
  Matthew Burgess [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ryan Langendorf &lt;ryan.langendorf@colorado.edu&gt;</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-04 17:50:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling 'rhs(lhs)'.
</p>

<hr>
<h2 id='align'>Network Alignment</h2><span id='topic+align'></span>

<h3>Description</h3>

<p>Network alignment by comparing the entropies of diffusion kernels simulated on two networks.
<code>align</code> takes two networks stored as matrices and returns a node-level alignment between them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>align(
  network_1_input,
  network_2_input,
  base = 2,
  max_duration,
  characterization = "entropy",
  normalization = FALSE,
  unit_test = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="align_+3A_network_1_input">network_1_input</code></td>
<td>
<p>The first network being aligned, which must be in matrix form. If the two
networks are of different sizes, it will be easier to interpret the output if this is the smaller one.</p>
</td></tr>
<tr><td><code id="align_+3A_network_2_input">network_2_input</code></td>
<td>
<p>The second network, which also must be a matrix.</p>
</td></tr>
<tr><td><code id="align_+3A_base">base</code></td>
<td>
<p>Defaults to 1. The base in the series of time steps to sample the diffusion kernels at. If base = 1 every time step
is sampled. If base = 2, only time steps that are powers of 2 are sampled, etc. Larger values place more emphasis on 
earlier time steps. This can be helpful if the diffusion kernel quickly converges to an equilibrium, and also
runs faster.</p>
</td></tr>
<tr><td><code id="align_+3A_max_duration">max_duration</code></td>
<td>
<p>Defaults to twice the diameter of the larger network. Sets the number of time steps to allow the diffusion
kernel to spread for, which is the smallest power of base that is at least as large as max_duration.</p>
</td></tr>
<tr><td><code id="align_+3A_characterization">characterization</code></td>
<td>
<p>Defaults to &quot;entropy&quot;. Determines how the diffusion kernels are characterized. Either &quot;entropy&quot; or &quot;gini&quot;. &quot;entropy&quot; 
is a size-normalized version of Shannon's entropy with base e (Euler's number). This is also known as interaction or species evenness
in ecology. &quot;gini&quot; is the Gini coefficient.</p>
</td></tr>
<tr><td><code id="align_+3A_normalization">normalization</code></td>
<td>
<p>Defaults to FALSE. Determines if self-loops should be augmented such that edge weights are
proportional to those in network_1_input and network_2_input. FALSE by default because this is inappropriate for
unweighted binary/logical networks where edges indicate only the presence of an interaction.</p>
</td></tr>
<tr><td><code id="align_+3A_unit_test">unit_test</code></td>
<td>
<p>Defaults to FALSE. Saves the following intermediate steps to help with general troubleshooting: post-processing matrix
representations of both networks, time steps at which the diffusion kernels were sampled, the diffusion kernels at those time steps,
the characterizations of the diffusion kernels at those time steps, and the cost matrix fed into the Hungarian algorithm where the 
ij element is the difference between the characterization-over-time curves for node i in the first network and node j in the second network.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Network alignment pairs nodes between two networks so as to maximize similarities in their edge structures. 
This allows information from well-studied systems to be used in poorly studied ones, such as to identify
unknown protein functions or ecosystems that will respond similarly to a given disturbance. Most network alignment
algorithms focus on measures of topological overlap between edges of the two networks. The method implemented here 
compares nodes using the predictability of dynamics originating from each node in each network. Consider network alignment 
as trying to compare two hypothetical cities of houses connected by roads. The approach implemented here is to pairwise 
compare each house with those in the other city by creating a house-specific signature. This is accomplished by quantifying 
the predictability of the location of a person at various times after they left their house, assuming they were moving randomly. 
This predictability across all houses captures much of the way each city is organized and functions. <code>align</code> 
uses this conceptual rationale to align two networks, with nodes as houses, edges as roads, and random diffusion representing people leaving 
their houses and walking around the city to other houses. The mechanics of this, which are conceptually akin to flow 
algorithms and Laplacian dynamics, can be analytically expressed as a Markov chain raised to successive powers which are 
the durations of diffusion.
</p>
<p>Note that the novel part of <code>align</code> lies in creating a matrix where the ij entry is a measure of similarity between node i in the first
network and node j in the second. The final alignment is found using <code>solve_LSAP</code> in the package <code>clue</code>, which uses the 
Hungarian algorithm to solve the assignment problem optimally.
</p>


<h3>Value</h3>

<table>
<tr><td><code>score</code></td>
<td>
<p>Mean of all alignment scores between nodes in both original networks network_1_input and network_2_input.</p>
</td></tr>
<tr><td><code>alignment</code></td>
<td>
<p>Data frame of the nodes in both networks, sorted numerically by the first network (why it helps to make the smaller network the first one), and the corresponding alignment score.</p>
</td></tr>
<tr><td><code>score_with_padding</code></td>
<td>
<p>Same as score but includes the padding nodes in the smaller network, which can be thought of as a size gap penalty for aligning differently sized networks. Only included if the input networks are different sizes.</p>
</td></tr>
<tr><td><code>alignment_with_padding</code></td>
<td>
<p>Same as alignment but includes the padding nodes in the smaller network. Only included if the input networks are different sizes.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Kuhn, H. W. (1955). The Hungarian method for the assignment problem. Naval Research Logistics (NRL), 2(1-2), 83-97.
</p>
<p>Langendorf, R. E., &amp; Goldberg, D. S. (2019). Aligning statistical dynamics captures biological network functioning. arXiv preprint arXiv:1912.12551.
</p>
<p>C. Papadimitriou and K. Steiglitz (1982), Combinatorial Optimization: Algorithms and Complexity. Englewood Cliffs: Prentice Hall.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The two networks to be aligned
net_one &lt;- matrix(stats::runif(25,0,1), nrow=5, ncol=5)
net_two &lt;- matrix(stats::runif(25,0,1), nrow=5, ncol=5)

align(net_one, net_two)
align(net_one, net_two, base = 1, characterization = "gini", normalization = TRUE)

</code></pre>

<hr>
<h2 id='best_fit_optim'>Empirical parameterization</h2><span id='topic+best_fit_optim'></span>

<h3>Description</h3>

<p>Helper function to find the best fitting version of a mechanism by searching across its parameter space
</p>


<h3>Usage</h3>

<pre><code class='language-R'>best_fit_optim(
  parameter,
  process,
  network,
  net_size,
  net_kind,
  mechanism_kind,
  resolution,
  resolution_min,
  resolution_max,
  reps,
  power_max,
  connectance_max,
  divergence_max,
  mutation_max,
  cores,
  directed,
  method,
  cause_orientation,
  DD_kind,
  DD_weight,
  max_norm,
  best_fit_kind = "avg",
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="best_fit_optim_+3A_parameter">parameter</code></td>
<td>
<p>The parameter being tested for its ability to generate networks alike the input 'network'.</p>
</td></tr>
<tr><td><code id="best_fit_optim_+3A_process">process</code></td>
<td>
<p>Name of mechanism. Currently only &quot;ER&quot;, &quot;PA&quot;, &quot;DD&quot;, &quot;DM&quot; &quot;SW&quot;, and &quot;NM&quot; are supported. Future versions will accept user-defined network-generating functions and associated parameters. ER = Erdos-Renyi random. PA = Preferential Attachment. DD = Duplication and Divergence. DM = Duplication and Mutation. SW = Small World. NM = Niche Model.</p>
</td></tr>
<tr><td><code id="best_fit_optim_+3A_network">network</code></td>
<td>
<p>The network being compared to a hypothesized 'process' with a given 'parameter' value.</p>
</td></tr>
<tr><td><code id="best_fit_optim_+3A_net_size">net_size</code></td>
<td>
<p>Number of nodes in the network.</p>
</td></tr>
<tr><td><code id="best_fit_optim_+3A_net_kind">net_kind</code></td>
<td>
<p>If the network is an adjacency matrix (&quot;matrix&quot;) or an edge list (&quot;list&quot;).</p>
</td></tr>
<tr><td><code id="best_fit_optim_+3A_mechanism_kind">mechanism_kind</code></td>
<td>
<p>Either &quot;canonical&quot; or &quot;grow&quot; can be used to simulate networks. If &quot;grow&quot; is used, note that here it will only simulate pure mixtures made of a single mechanism.</p>
</td></tr>
<tr><td><code id="best_fit_optim_+3A_resolution">resolution</code></td>
<td>
<p>The first step is to find the version of each process most similar to the target network. This parameter sets the number of parameter values to search across. Decrease to improve performance, but at the cost of accuracy.</p>
</td></tr>
<tr><td><code id="best_fit_optim_+3A_resolution_min">resolution_min</code></td>
<td>
<p>= The minimum parameter value to consider. Zero is not used because in many processes it results in degenerate systems (e.g. entirely unconnected networks). Currently process agnostic. Future versions will accept a vector of values, one for each process.</p>
</td></tr>
<tr><td><code id="best_fit_optim_+3A_resolution_max">resolution_max</code></td>
<td>
<p>The maximum parameter value to consider. One is not used because in many processes it results in degenerate systems (e.g. entirely connected networks). Currently process agnostic. Future versions will accept a vector of values, one for each process.</p>
</td></tr>
<tr><td><code id="best_fit_optim_+3A_reps">reps</code></td>
<td>
<p>The number of networks to simulate for each parameter. More replicates increases accuracy by making the estimation of the parameter that produces networks most similar to the target network less idiosyncratic.</p>
</td></tr>
<tr><td><code id="best_fit_optim_+3A_power_max">power_max</code></td>
<td>
<p>The maximum power of attachment in the Preferential Attachment process (PA).</p>
</td></tr>
<tr><td><code id="best_fit_optim_+3A_connectance_max">connectance_max</code></td>
<td>
<p>The maximum connectance parameter for the Niche Model.</p>
</td></tr>
<tr><td><code id="best_fit_optim_+3A_divergence_max">divergence_max</code></td>
<td>
<p>The maximum divergence parameter for the Duplication and Divergence/Mutation mechanisms.</p>
</td></tr>
<tr><td><code id="best_fit_optim_+3A_mutation_max">mutation_max</code></td>
<td>
<p>The maximum mutation parameter for the Duplication and Mutation mechanism.</p>
</td></tr>
<tr><td><code id="best_fit_optim_+3A_cores">cores</code></td>
<td>
<p>The number of cores to run the classification on. When set to 1 parallelization will be ignored.</p>
</td></tr>
<tr><td><code id="best_fit_optim_+3A_directed">directed</code></td>
<td>
<p>Whether the target network is directed.</p>
</td></tr>
<tr><td><code id="best_fit_optim_+3A_method">method</code></td>
<td>
<p>This determines the method used to compare networks at the heart of the classification. Currently &quot;DD&quot; (Degree Distribution) and &quot;align&quot; (the align function which compares networks by the entropy of diffusion on them) are supported. Future versions will allow user-defined methods.</p>
</td></tr>
<tr><td><code id="best_fit_optim_+3A_cause_orientation">cause_orientation</code></td>
<td>
<p>The orientation of directed adjacency matrices.</p>
</td></tr>
<tr><td><code id="best_fit_optim_+3A_dd_kind">DD_kind</code></td>
<td>
<p>A vector of network properties to be used to compare networks.</p>
</td></tr>
<tr><td><code id="best_fit_optim_+3A_dd_weight">DD_weight</code></td>
<td>
<p>Weights of each network property in DD_kind. Defaults to 1, which is equal weighting for each property.</p>
</td></tr>
<tr><td><code id="best_fit_optim_+3A_max_norm">max_norm</code></td>
<td>
<p>Binary variable indicating if each network property should be normalized so its max value (if a node-level property) is one.</p>
</td></tr>
<tr><td><code id="best_fit_optim_+3A_best_fit_kind">best_fit_kind</code></td>
<td>
<p>How to aggregate the stochastic replicates of the process + parameter combination.</p>
</td></tr>
<tr><td><code id="best_fit_optim_+3A_verbose">verbose</code></td>
<td>
<p>Defaults to TRUE. Whether to print all messages.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: Currently each process is assumed to have a single governing parameter.
</p>


<h3>Value</h3>

<p>A number measuring how different the input network is from the parameter + process combination.
</p>


<h3>References</h3>

<p>Langendorf, R. E., &amp; Burgess, M. G. (2020). Empirically Classifying Network Mechanisms. arXiv preprint arXiv:2012.15863.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import netcom
library(netcom)

# Adjacency matrix
size &lt;- 10
network &lt;- matrix(sample(c(0,1), size = size^2, replace = TRUE), nrow = size, ncol = size)

# Calculate how similar the input network is to Small-World networks with 
# a rewiring probability of 0.28.
best_fit_optim(
     parameter = 0.28, 
     process = "SW", 
     network = network, 
     net_size = 12, 
     net_kind = "matrix", 
     mechanism_kind = "grow", 
     resolution = 100, 
     resolution_min = 0.01, 
     resolution_max = 0.99, 
     reps = 3, 
     power_max = 5, 
     connectance_max = 0.5, 
     divergence_max = 0.5, 
     mutation_max = 0.5, 
     cores = 1, 
     directed = TRUE, 
     method = "DD", 
     cause_orientation = "row", 
     DD_kind = c(
         "in", "out", "entropy_in", "entropy_out", 
         "clustering_coefficient", "page_rank", "communities"
     ), 
     DD_weight = 1, 
     max_norm = FALSE,
     verbose = FALSE
)

</code></pre>

<hr>
<h2 id='classify'>Mechanistic Network Classification</h2><span id='topic+classify'></span>

<h3>Description</h3>

<p>Tests a network against hypothetical generating processes using a comparative network inference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classify(
  network,
  directed,
  method = "DD",
  net_kind = "matrix",
  mechanism_kind = "canonical",
  DD_kind = c("in", "out", "entropy_in", "entropy_out", "clustering_coefficient",
    "page_rank", "communities", "motifs_3", "motifs_4", "eq_in", "eq_out",
    "eq_entropy_in", "eq_entropy_out", "eq_clustering_coefficient", "eq_page_rank",
    "eq_communities", "eq_motifs_3", "eq_motifs_4"),
  DD_weight = c(0.0735367966, 0.0739940162, 0.0714523761, 0.0708156931, 0.0601296752,
    0.0448072016, 0.0249793608, 0.0733125084, 0.0697029389, 0.0504358835, 0.0004016029,
    0.0563752664, 0.0561878218, 0.0540490099, 0.0504347104, 0.0558106667, 0.0568270319,
    0.0567474398),
  cause_orientation = "row",
  max_norm = FALSE,
  resolution = 100,
  resolution_min = 0.01,
  resolution_max = 0.99,
  reps = 3,
  processes = c("ER", "PA", "DM", "SW", "NM"),
  test = "empirical",
  best_fit_finder = "systematic",
  power_max = 5,
  connectance_max = 0.5,
  divergence_max = 0.5,
  mutation_max = 0.5,
  null_reps = 50,
  best_fit_kind = "avg",
  best_fit_sd = 0,
  ks_dither = 0,
  ks_alternative = "two.sided",
  cores = 1,
  size_different = FALSE,
  null_dist_trim = 1,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="classify_+3A_network">network</code></td>
<td>
<p>The network to be classified.</p>
</td></tr>
<tr><td><code id="classify_+3A_directed">directed</code></td>
<td>
<p>Whether the target network is directed. If missing this will be inferred by the symmetry of the input network.</p>
</td></tr>
<tr><td><code id="classify_+3A_method">method</code></td>
<td>
<p>This determines the method used to compare networks at the heart of the classification. Currently &quot;DD&quot; (Degree Distribution) and &quot;align&quot; (the align function which compares networks by the entropy of diffusion on them) are supported. Future versions will allow user-defined methods. Defaults to &quot;DD&quot;.</p>
</td></tr>
<tr><td><code id="classify_+3A_net_kind">net_kind</code></td>
<td>
<p>If the network is an adjacency matrix (&quot;matrix&quot;) or an edge list (&quot;list&quot;). Defaults to &quot;matrix&quot;.</p>
</td></tr>
<tr><td><code id="classify_+3A_mechanism_kind">mechanism_kind</code></td>
<td>
<p>Either &quot;canonical&quot; or &quot;grow&quot; can be used to simulate networks. If &quot;grow&quot; is used, note that here it will only simulate pure mixtures made of a single mechanism. Defaults to &quot;canonical&quot;.</p>
</td></tr>
<tr><td><code id="classify_+3A_dd_kind">DD_kind</code></td>
<td>
<p>= A vector of network properties to be used to compare networks. Defaults to &quot;all&quot;, which is the average of the in- and out-degrees.</p>
</td></tr>
<tr><td><code id="classify_+3A_dd_weight">DD_weight</code></td>
<td>
<p>= Weights of each network property in DD_kind. Defaults to 1, which is equal weighting for each property.</p>
</td></tr>
<tr><td><code id="classify_+3A_cause_orientation">cause_orientation</code></td>
<td>
<p>= The orientation of directed adjacency matrices. Defaults to &quot;row&quot;.</p>
</td></tr>
<tr><td><code id="classify_+3A_max_norm">max_norm</code></td>
<td>
<p>Binary variable indicating if each network property should be normalized so its max value (if a node-level property) is one. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="classify_+3A_resolution">resolution</code></td>
<td>
<p>Defaults to 100. The first step is to find the version of each process most similar to the target network. This parameter sets the number of parameter values to search across. Decrease to improve performance, but at the cost of accuracy.</p>
</td></tr>
<tr><td><code id="classify_+3A_resolution_min">resolution_min</code></td>
<td>
<p>Defaults to 0.01. The minimum parameter value to consider. Zero is not used because in many processes it results in degenerate systems (e.g. entirely unconnected networks). Currently process agnostic. Future versions will accept a vector of values, one for each process.</p>
</td></tr>
<tr><td><code id="classify_+3A_resolution_max">resolution_max</code></td>
<td>
<p>Defaults to 0.99. The maximum parameter value to consider. One is not used because in many processes it results in degenerate systems (e.g. entirely connected networks). Currently process agnostic. Future versions will accept a vector of values, one for each process.</p>
</td></tr>
<tr><td><code id="classify_+3A_reps">reps</code></td>
<td>
<p>Defaults to 3. The number of networks to simulate for each parameter. More replicates increases accuracy by making the estimation of the parameter that produces networks most similar to the target network less idiosyncratic.</p>
</td></tr>
<tr><td><code id="classify_+3A_processes">processes</code></td>
<td>
<p>Defaults to c(&quot;ER&quot;, &quot;PA&quot;, &quot;DD&quot;, &quot;SW&quot;, &quot;NM&quot;). Vector of process abbreviations. Currently only the default five are supported. Future versions will accept user-defined network-generating functions and associated parameters. ER = Erdos-Renyi random. PA = Preferential Attachment. DD = Duplication and Divergence. SW = Small World. NM = Niche Model.</p>
</td></tr>
<tr><td><code id="classify_+3A_test">test</code></td>
<td>
<p>Defaults to &quot;empirical&quot;. The test used to distinguish the null distribution of comparisons between the network being classified and the networks simulated according to a hypothesized mechanism(s), with a particular best-fitting parameter. &quot;empirical&quot; finds how many simulated networks were on average farther from each other than the network being classified is. &quot;KS&quot; uses a KS test. &quot;WMWU&quot; uses a Wilcoxon-Mann-Whitney-U test.</p>
</td></tr>
<tr><td><code id="classify_+3A_best_fit_finder">best_fit_finder</code></td>
<td>
<p>Defaults to &quot;systematic&quot;. Determines how the best-fitting parameter of each mechanism specified in processes is found. &quot;systematic&quot; tries every parameter value from resolution_min to resolution_max with a step size of resolution_max - resolution_min / resolution. &quot;optim_L-BFGS-B&quot; uses the L-BFGS-B optimizer in the optimx package. &quot;optim_GenSA&quot; uses the GenSA optimizer in the GenSA package.</p>
</td></tr>
<tr><td><code id="classify_+3A_power_max">power_max</code></td>
<td>
<p>Defaults to 5. The maximum power of attachment in the Preferential Attachment process (PA).</p>
</td></tr>
<tr><td><code id="classify_+3A_connectance_max">connectance_max</code></td>
<td>
<p>= Defaults to 0.5. The maximum connectance parameter for the Niche Model.</p>
</td></tr>
<tr><td><code id="classify_+3A_divergence_max">divergence_max</code></td>
<td>
<p>= Defaults to 0.5. The maximum divergence parameter for the Duplication and Divergence/Mutation mechanisms.</p>
</td></tr>
<tr><td><code id="classify_+3A_mutation_max">mutation_max</code></td>
<td>
<p>= Defaults to 0.5. The maximum mutation parameter for the Duplication and Mutation mechanism.</p>
</td></tr>
<tr><td><code id="classify_+3A_null_reps">null_reps</code></td>
<td>
<p>Defaults to 50. The number of best fit networks to simulate that will be used to create a null distribution of distances between networks within the given process, which will then be used to test if the target network appears unusually distant from them and therefore likely not governed by that process.</p>
</td></tr>
<tr><td><code id="classify_+3A_best_fit_kind">best_fit_kind</code></td>
<td>
<p>Defaults to &quot;avg&quot;. If null_reps is more than 1, the fit of each parameter has to be an aggregate statistic of the fit of all the null_reps networks. Must be 'avg', 'median', 'min', or 'max'.</p>
</td></tr>
<tr><td><code id="classify_+3A_best_fit_sd">best_fit_sd</code></td>
<td>
<p>Defaults to 0. Standard Deviation used to simulate networks with a similar but not identical best fit parameter. This is important because simulating networks with the identical parameter can artificially inflate the false negative rate by assuming the best fit parameter is the true parameter. For large resolution and reps values this will become true, but can be computationally intractable for realistically large systems.</p>
</td></tr>
<tr><td><code id="classify_+3A_ks_dither">ks_dither</code></td>
<td>
<p>Defaults to 0. The KS test cannot compute exact p-values when every pairwise network distance is not unique. Adding small amounts of noise makes each distance unique. We are not aware of a study on the impacts this has on accuracy so it is set to zero by default.</p>
</td></tr>
<tr><td><code id="classify_+3A_ks_alternative">ks_alternative</code></td>
<td>
<p>Defaults to &quot;two.sided&quot;. Governs the KS test. Assuming best_fit_sd is not too large, this can be set to &quot;greater&quot; because the target network cannot be more alike identically simulated networks than they are to each other. In practice we have found &quot;greater&quot; and &quot;less&quot; produce numerical errors. Only &quot;two.sided&quot;, &quot;less&quot;, and &quot;greater&quot; are supported through stats::ks.test().</p>
</td></tr>
<tr><td><code id="classify_+3A_cores">cores</code></td>
<td>
<p>Defaults to 1. The number of cores to run the classification on. When set to 1 parallelization will be ignored.</p>
</td></tr>
<tr><td><code id="classify_+3A_size_different">size_different</code></td>
<td>
<p>= If there is a difference in the size of the networks used in the null distribution. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="classify_+3A_null_dist_trim">null_dist_trim</code></td>
<td>
<p>= Number between zero and one that determines how much of each network comparison distribution (unknown network compared to simulated networks, simulated networks compared to each other) should be used. Prevents p-value convergence with large sample sizes. Defaults to 1, which means all comparisons are used (no trimming).</p>
</td></tr>
<tr><td><code id="classify_+3A_verbose">verbose</code></td>
<td>
<p>Defaults to FALSE. Whether to print all messages.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: Currently each process is assumed to have a single governing parameter.
</p>


<h3>Value</h3>

<p>A dataframe with 3 columns and as many rows as processes being tested (5 by default). The first column lists the processes. The second lists the p-value on the null hypothesis that the target network did come from that row's process. The third column gives the estimated parameter for that particular process.
</p>


<h3>References</h3>

<p>Langendorf, R. E., &amp; Burgess, M. G. (2020). Empirically Classifying Network Mechanisms. arXiv preprint arXiv:2012.15863.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import netcom
library(netcom)

# Adjacency matrix
size &lt;- 10
network &lt;- matrix(sample(c(0,1), size = size^2, replace = TRUE), nrow = size, ncol = size)

# Classify this network
# This can take several minutes to run
classify(network, processes = c("ER", "PA", "DM", "SW", "NM"))

</code></pre>

<hr>
<h2 id='classify_Systematic'>Mechanistic Network Classification</h2><span id='topic+classify_Systematic'></span>

<h3>Description</h3>

<p>Tests a network against hypothetical generating processes using a comparative network inference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classify_Systematic(
  network,
  directed = FALSE,
  method = "DD",
  net_kind = "matrix",
  DD_kind = c("in", "out", "entropy_in", "entropy_out", "clustering_coefficient",
    "page_rank", "communities", "motifs_3", "motifs_4", "eq_in", "eq_out",
    "eq_entropy_in", "eq_entropy_out", "eq_clustering_coefficient", "eq_page_rank",
    "eq_communities", "eq_motifs_3", "eq_motifs_4"),
  DD_weight = c(0.0735367966, 0.0739940162, 0.0714523761, 0.0708156931, 0.0601296752,
    0.0448072016, 0.0249793608, 0.0733125084, 0.0697029389, 0.0504358835, 0.0004016029,
    0.0563752664, 0.0561878218, 0.0540490099, 0.0504347104, 0.0558106667, 0.0568270319,
    0.0567474398),
  cause_orientation = "row",
  max_norm = FALSE,
  resolution = 100,
  resolution_min = 0.01,
  resolution_max = 0.99,
  reps = 3,
  processes = c("ER", "PA", "DM", "SW", "NM"),
  power_max = 5,
  connectance_max = 0.5,
  divergence_max = 0.5,
  mutation_max = 0.5,
  null_reps = 50,
  best_fit_kind = "avg",
  best_fit_sd = 0.01,
  ks_dither = 0,
  ks_alternative = "two.sided",
  cores = 1,
  size_different = FALSE,
  null_dist_trim = 1,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="classify_Systematic_+3A_network">network</code></td>
<td>
<p>The network to be classified.</p>
</td></tr>
<tr><td><code id="classify_Systematic_+3A_directed">directed</code></td>
<td>
<p>Defaults to TRUE. Whether the target network is directed.</p>
</td></tr>
<tr><td><code id="classify_Systematic_+3A_method">method</code></td>
<td>
<p>This determines the method used to compare networks at the heart of the classification. Currently &quot;DD&quot; (Degree Distribution) and &quot;align&quot; (the align function which compares networks by the entropy of diffusion on them) are supported. Future versions will allow user-defined methods. Defaults to &quot;DD&quot;.</p>
</td></tr>
<tr><td><code id="classify_Systematic_+3A_net_kind">net_kind</code></td>
<td>
<p>If the network is an adjacency matrix (&quot;matrix&quot;) or an edge list (&quot;list&quot;). Defaults to &quot;matrix&quot;.</p>
</td></tr>
<tr><td><code id="classify_Systematic_+3A_dd_kind">DD_kind</code></td>
<td>
<p>= A vector of network properties to be used to compare networks. Defaults to &quot;all&quot;, which is the average of the in- and out-degrees.</p>
</td></tr>
<tr><td><code id="classify_Systematic_+3A_dd_weight">DD_weight</code></td>
<td>
<p>= Weights of each network property in DD_kind. Defaults to 1, which is equal weighting for each property.</p>
</td></tr>
<tr><td><code id="classify_Systematic_+3A_cause_orientation">cause_orientation</code></td>
<td>
<p>= The orientation of directed adjacency matrices. Defaults to &quot;row&quot;.</p>
</td></tr>
<tr><td><code id="classify_Systematic_+3A_max_norm">max_norm</code></td>
<td>
<p>Binary variable indicating if each network property should be normalized so its max value (if a node-level property) is one. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="classify_Systematic_+3A_resolution">resolution</code></td>
<td>
<p>Defaults to 100. The first step is to find the version of each process most similar to the target network. This parameter sets the number of parameter values to search across. Decrease to improve performance, but at the cost of accuracy.</p>
</td></tr>
<tr><td><code id="classify_Systematic_+3A_resolution_min">resolution_min</code></td>
<td>
<p>Defaults to 0.01. The minimum parameter value to consider. Zero is not used because in many processes it results in degenerate systems (e.g. entirely unconnected networks). Currently process agnostic. Future versions will accept a vector of values, one for each process.</p>
</td></tr>
<tr><td><code id="classify_Systematic_+3A_resolution_max">resolution_max</code></td>
<td>
<p>Defaults to 0.99. The maximum parameter value to consider. One is not used because in many processes it results in degenerate systems (e.g. entirely connected networks). Currently process agnostic. Future versions will accept a vector of values, one for each process.</p>
</td></tr>
<tr><td><code id="classify_Systematic_+3A_reps">reps</code></td>
<td>
<p>Defaults to 3. The number of networks to simulate for each parameter. More replicates increases accuracy by making the estimation of the parameter that produces networks most similar to the target network less idiosyncratic.</p>
</td></tr>
<tr><td><code id="classify_Systematic_+3A_processes">processes</code></td>
<td>
<p>Defaults to c(&quot;ER&quot;, &quot;PA&quot;, &quot;DD&quot;, &quot;SW&quot;, &quot;NM&quot;). Vector of process abbreviations. Currently only the default five are supported. Future versions will accept user-defined network-generating functions and associated parameters. ER = Erdos-Renyi random. PA = Preferential Attachment. DD = Duplication and Divergence. SW = Small World. NM = Niche Model.</p>
</td></tr>
<tr><td><code id="classify_Systematic_+3A_power_max">power_max</code></td>
<td>
<p>Defaults to 5. The maximum power of attachment in the Preferential Attachment process (PA).</p>
</td></tr>
<tr><td><code id="classify_Systematic_+3A_connectance_max">connectance_max</code></td>
<td>
<p>= Defaults to 0.5. The maximum connectance parameter for the Niche Model.</p>
</td></tr>
<tr><td><code id="classify_Systematic_+3A_divergence_max">divergence_max</code></td>
<td>
<p>= Defaults to 0.5. The maximum divergence parameter for the Duplication and Divergence/Mutation mechanisms.</p>
</td></tr>
<tr><td><code id="classify_Systematic_+3A_mutation_max">mutation_max</code></td>
<td>
<p>= Defaults to 0.5. The maximum mutation parameter for the Duplication and Mutation mechanism.</p>
</td></tr>
<tr><td><code id="classify_Systematic_+3A_null_reps">null_reps</code></td>
<td>
<p>Defaults to 50. The number of best fit networks to simulate that will be used to create a null distribution of distances between networks within the given process, which will then be used to test if the target network appears unusually distant from them and therefore likely not governed by that process.</p>
</td></tr>
<tr><td><code id="classify_Systematic_+3A_best_fit_kind">best_fit_kind</code></td>
<td>
<p>Defaults to &quot;avg&quot;. If null_reps is more than 1, the fit of each parameter has to be an aggregate statistic of the fit of all the null_reps networks. Must be 'avg', 'median', 'min', or 'max'.</p>
</td></tr>
<tr><td><code id="classify_Systematic_+3A_best_fit_sd">best_fit_sd</code></td>
<td>
<p>Defaults to 0.01. Standard Deviation used to simulate networks with a similar but not identical best fit parameter. This is important because simulating networks with the identical parameter artificially inflates the false negative rate by assuming the best fit parameter is the true parameter. For large resolution and reps values this will become true, but also computationally intractable for realistically large systems.</p>
</td></tr>
<tr><td><code id="classify_Systematic_+3A_ks_dither">ks_dither</code></td>
<td>
<p>Defaults to 0. The KS test cannot compute exact p-values when every pairwise network distance is not unique. Adding small amounts of noise makes each distance unique. We are not aware of a study on the impacts this has on accuracy so it is set to zero by default.</p>
</td></tr>
<tr><td><code id="classify_Systematic_+3A_ks_alternative">ks_alternative</code></td>
<td>
<p>Defaults to &quot;two.sided&quot;. Governs the KS test. Assuming best_fit_sd is not too large, this can be set to &quot;greater&quot; because the target network cannot be more alike identically simulated networks than they are to each other. In practice we have found &quot;greater&quot; and &quot;less&quot; produce numerical errors. Only &quot;two.sided&quot;, &quot;less&quot;, and &quot;greater&quot; are supported through stats::ks.test().</p>
</td></tr>
<tr><td><code id="classify_Systematic_+3A_cores">cores</code></td>
<td>
<p>Defaults to 1. The number of cores to run the classification on. When set to 1 parallelization will be ignored.</p>
</td></tr>
<tr><td><code id="classify_Systematic_+3A_size_different">size_different</code></td>
<td>
<p>= If there is a difference in the size of the networks used in the null distribution. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="classify_Systematic_+3A_null_dist_trim">null_dist_trim</code></td>
<td>
<p>= Number between zero and one that determines how much of each network comparison distribution (unknown network compared to simulated networks, simulated networks compared to each other) should be used. Prevents p-value convergence with large sample sizes. Defaults to 1, which means all comparisons are used (no trimming).</p>
</td></tr>
<tr><td><code id="classify_Systematic_+3A_verbose">verbose</code></td>
<td>
<p>Defaults to TRUE. Whether to print all messages.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: Currently each process is assumed to have a single governing parameter.
</p>


<h3>Value</h3>

<p>A dataframe with 3 columns and as many rows as processes being tested (5 by default). The first column lists the processes. The second lists the p-value on the null hypothesis that the target network did come from that row's process. The third column gives the estimated parameter for that particular process.
</p>


<h3>References</h3>

<p>Langendorf, R. E., &amp; Burgess, M. G. (2020). Empirically Classifying Network Mechanisms. arXiv preprint arXiv:2012.15863.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import netcom
library(netcom)

# Adjacency matrix
size &lt;- 10
network &lt;- matrix(sample(c(0,1), size = size^2, replace = TRUE), nrow = size, ncol = size)

# Classify this network
# This can take several minutes to run
classify(network, processes = c("ER", "PA", "DM", "SW", "NM"))

</code></pre>

<hr>
<h2 id='compare'>Compare Networks Many-to-Many</h2><span id='topic+compare'></span>

<h3>Description</h3>

<p>Compares one network to a list of many networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare(
  networks,
  net_kind = "matrix",
  method = "DD",
  cause_orientation = "row",
  DD_kind = "all",
  DD_weight = 1,
  max_norm = FALSE,
  size_different = FALSE,
  cores = 1,
  diffusion_sampling = 2,
  diffusion_limit = 10,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_+3A_networks">networks</code></td>
<td>
<p>The networks being compared to the target network</p>
</td></tr>
<tr><td><code id="compare_+3A_net_kind">net_kind</code></td>
<td>
<p>If the network is an adjacency matrix (&quot;matrix&quot;) or an edge list (&quot;list&quot;). Defaults to &quot;matrix&quot;.</p>
</td></tr>
<tr><td><code id="compare_+3A_method">method</code></td>
<td>
<p>This determines the method used to compare networks at the heart of the classification. Currently &quot;DD&quot; (Degree Distribution) and &quot;align&quot; (the align function which compares networks by the entropy of diffusion on them) are supported. Future versions will allow user-defined methods. Defaults to &quot;DD&quot;.</p>
</td></tr>
<tr><td><code id="compare_+3A_cause_orientation">cause_orientation</code></td>
<td>
<p>= The orientation of directed adjacency matrices. Defaults to &quot;row&quot;.</p>
</td></tr>
<tr><td><code id="compare_+3A_dd_kind">DD_kind</code></td>
<td>
<p>= A vector of network properties to be used to compare networks. Defaults to &quot;all&quot;, which is the average of the in- and out-degrees.</p>
</td></tr>
<tr><td><code id="compare_+3A_dd_weight">DD_weight</code></td>
<td>
<p>= Weights of each network property in DD_kind. Defaults to 1, which is equal weighting for each property.</p>
</td></tr>
<tr><td><code id="compare_+3A_max_norm">max_norm</code></td>
<td>
<p>Binary variable indicating if each network property should be normalized so its max value (if a node-level property) is one. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="compare_+3A_size_different">size_different</code></td>
<td>
<p>Defaults to FALSE. If TRUE, will ensure the node-level properties being compared are vectors of the same length, which is accomplished using splines.</p>
</td></tr>
<tr><td><code id="compare_+3A_cores">cores</code></td>
<td>
<p>Defaults to 1. The number of cores to run the classification on. When set to 1 parallelization will be ignored.</p>
</td></tr>
<tr><td><code id="compare_+3A_diffusion_sampling">diffusion_sampling</code></td>
<td>
<p>Base of the power to use to nonlinearly sample the diffusion kernels if method = &quot;align&quot;. Defaults to 2.</p>
</td></tr>
<tr><td><code id="compare_+3A_diffusion_limit">diffusion_limit</code></td>
<td>
<p>Number of markov steps in the diffusion kernels if method = &quot;align&quot;. Defaults to 10.</p>
</td></tr>
<tr><td><code id="compare_+3A_verbose">verbose</code></td>
<td>
<p>Defaults to TRUE. Whether to print all messages.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: Currently each process is assumed to have a single governing parameter.
</p>


<h3>Value</h3>

<p>A square matrix with dimensions equal to the number of networks being compared, where the ij element is the comparison of networks i and j.
</p>


<h3>References</h3>

<p>Langendorf, R. E., &amp; Burgess, M. G. (2020). Empirically Classifying Network Mechanisms. arXiv preprint arXiv:2012.15863.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import netcom
library(netcom)

# Adjacency matrix
size &lt;- 10
comparisons &lt;- 50
networks &lt;- list()
for (net in 1:comparisons) {
     networks[[net]] = matrix(
         sample(
             c(0,1),
             size = size^2,
             replace = TRUE),
         nrow = size,
         ncol = size)
}
compare(networks = networks)

</code></pre>

<hr>
<h2 id='compare_Target'>Compare Networks One-to-Many</h2><span id='topic+compare_Target'></span>

<h3>Description</h3>

<p>Compares one network to a list of many networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_Target(
  target,
  networks,
  net_size,
  net_kind = "matrix",
  method = "DD",
  cause_orientation = "row",
  DD_kind = "all",
  DD_weight = 1,
  max_norm = FALSE,
  cores = 1,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_Target_+3A_target">target</code></td>
<td>
<p>The network be compared.</p>
</td></tr>
<tr><td><code id="compare_Target_+3A_networks">networks</code></td>
<td>
<p>The networks being compared to the target network</p>
</td></tr>
<tr><td><code id="compare_Target_+3A_net_size">net_size</code></td>
<td>
<p>Size</p>
</td></tr>
<tr><td><code id="compare_Target_+3A_net_kind">net_kind</code></td>
<td>
<p>If the network is an adjacency matrix (&quot;matrix&quot;) or an edge list (&quot;list&quot;). Defaults to &quot;matrix&quot;.</p>
</td></tr>
<tr><td><code id="compare_Target_+3A_method">method</code></td>
<td>
<p>This determines the method used to compare networks at the heart of the classification. Currently &quot;DD&quot; (Degree Distribution) and &quot;align&quot; (the align function which compares networks by the entropy of diffusion on them) are supported. Future versions will allow user-defined methods. Defaults to &quot;DD&quot;.</p>
</td></tr>
<tr><td><code id="compare_Target_+3A_cause_orientation">cause_orientation</code></td>
<td>
<p>= The orientation of directed adjacency matrices. Defaults to &quot;row&quot;.</p>
</td></tr>
<tr><td><code id="compare_Target_+3A_dd_kind">DD_kind</code></td>
<td>
<p>= A vector of network properties to be used to compare networks. Defaults to &quot;all&quot;, which is the average of the in- and out-degrees.</p>
</td></tr>
<tr><td><code id="compare_Target_+3A_dd_weight">DD_weight</code></td>
<td>
<p>= Weights of each network property in DD_kind. Defaults to 1, which is equal weighting for each property.</p>
</td></tr>
<tr><td><code id="compare_Target_+3A_max_norm">max_norm</code></td>
<td>
<p>Binary variable indicating if each network property should be normalized so its max value (if a node-level property) is one. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="compare_Target_+3A_cores">cores</code></td>
<td>
<p>Defaults to 1. The number of cores to run the classification on. When set to 1 parallelization will be ignored.</p>
</td></tr>
<tr><td><code id="compare_Target_+3A_verbose">verbose</code></td>
<td>
<p>Defaults to TRUE. Whether to print all messages.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: Currently each process is assumed to have a single governing parameter.
</p>


<h3>Value</h3>

<p>A pseudo-distance vector where the i-element is the comparison between the target network and the ith network being compared to.
</p>


<h3>References</h3>

<p>Langendorf, R. E., &amp; Burgess, M. G. (2020). Empirically Classifying Network Mechanisms. arXiv preprint arXiv:2012.15863.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import netcom
library(netcom)

# Adjacency matrix
size &lt;- 10
comparisons &lt;- 50
network_target &lt;- matrix(sample(c(0,1), size = size^2, replace = TRUE), nrow = size, ncol = size)
network_others &lt;- list()
for (net in 1:comparisons) {
     network_others[[net]] = matrix(
         sample(
             c(0,1),
             size = size^2,
             replace = TRUE),
         nrow = size,
         ncol = size)
}
compare_Target(target = network_target, networks = network_others, net_size = size, method = "DD")

</code></pre>

<hr>
<h2 id='gini'>Gini coefficient</h2><span id='topic+gini'></span>

<h3>Description</h3>

<p>Takes a matrix and returns the Gini coefficient of each column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gini(input, byrow = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gini_+3A_input">input</code></td>
<td>
<p>A matrix where the Gini coefficient will be calculated on each column. Note that vector data must be converted to a single-column matrix.</p>
</td></tr>
<tr><td><code id="gini_+3A_byrow">byrow</code></td>
<td>
<p>Defaults to FALSE. Set to TRUE to calculate the Gini coefficient of each row.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the Gini coefficients of each column.
</p>


<h3>References</h3>

<p>Gini, C. (1912). Variabilita e mutabilita. Reprinted in Memorie di metodologica statistica (Ed. Pizetti E, Salvemini, T). Rome: Libreria Eredi Virgilio Veschi.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Vectors are not supported. First convert to a single-column matrix.
sample_data &lt;- runif(20, 0, 1)
gini(matrix(sample_data, ncol = 1))

# Multiple Gini coefficients can be calculated simultaneously
gini(matrix(sample_data, ncol = 2)) 

</code></pre>

<hr>
<h2 id='grow_DD'>Grow a Duplication and Divergence Network</h2><span id='topic+grow_DD'></span>

<h3>Description</h3>

<p>Grows an already existing network by adding a node according to the Duplication and Divergence mechanism. Nodes can only attach to previously grown nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grow_DD(
  matrix,
  x,
  divergence,
  link = 0,
  connected = FALSE,
  retcon = FALSE,
  directed = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grow_DD_+3A_matrix">matrix</code></td>
<td>
<p>Existing network to experience growth.</p>
</td></tr>
<tr><td><code id="grow_DD_+3A_x">x</code></td>
<td>
<p>The ID of the node to be grown.</p>
</td></tr>
<tr><td><code id="grow_DD_+3A_divergence">divergence</code></td>
<td>
<p>Probability that the new node loses edges associated with the node it duplicates. Needs to be between zero and one.</p>
</td></tr>
<tr><td><code id="grow_DD_+3A_link">link</code></td>
<td>
<p>Probability that the new node attaches to the node it duplicates. Defaults to 0.</p>
</td></tr>
<tr><td><code id="grow_DD_+3A_connected">connected</code></td>
<td>
<p>Binary argument determining if the newly grown node has to be connected to the existing network. Defaults to FALSE, to prevent rare computational slow-downs when it is unlikely to create a connected network. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="grow_DD_+3A_retcon">retcon</code></td>
<td>
<p>Binary variable determining if already existing nodes can attach to new nodes. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="grow_DD_+3A_directed">directed</code></td>
<td>
<p>Binary variable determining if the network is directed, resulting in off-diagonal asymmetry in the adjacency matrix. Defaults to TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Different from Duplication &amp; Mutation models in that edges can only be lost.
</p>


<h3>Value</h3>

<p>An adjacency matrix.
</p>


<h3>References</h3>

<p>Ispolatov, I., Krapivsky, P. L., &amp; Yuryev, A. (2005). Duplication-divergence model of protein interaction network. Physical review E, 71(6), 061911.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import netcom
library(netcom)

size &lt;- 10
existing_network &lt;- matrix(sample(c(0,1), size = size^2, replace = TRUE), nrow = size, ncol = size)
new_network_prep &lt;- matrix(0, nrow = size + 1, ncol = size + 1)
new_network_prep[1:size, 1:size] = existing_network
new_network &lt;- grow_DD(matrix = new_network_prep, x = size + 1, divergence = 0.5)

</code></pre>

<hr>
<h2 id='grow_DM'>Grow a Duplication and Mutation Network</h2><span id='topic+grow_DM'></span>

<h3>Description</h3>

<p>Grows an already existing network by adding a node according to the Duplication and Mutation mechanism. Nodes can only attach to previously grown nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grow_DM(
  matrix,
  x,
  divergence,
  mutation = 0,
  link = 0,
  connected = FALSE,
  retcon = FALSE,
  directed = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grow_DM_+3A_matrix">matrix</code></td>
<td>
<p>Existing network to experience growth.</p>
</td></tr>
<tr><td><code id="grow_DM_+3A_x">x</code></td>
<td>
<p>The ID of the node to be grown.</p>
</td></tr>
<tr><td><code id="grow_DM_+3A_divergence">divergence</code></td>
<td>
<p>Probability that the new node loses edges associated with the node it duplicates. Needs to be between zero and one.</p>
</td></tr>
<tr><td><code id="grow_DM_+3A_mutation">mutation</code></td>
<td>
<p>Probability that the new node gains edges not associated with the node it duplicates. Needs to be between zero and one.</p>
</td></tr>
<tr><td><code id="grow_DM_+3A_link">link</code></td>
<td>
<p>Probability that the new node attaches to the node it duplicates. Defaults to 0.</p>
</td></tr>
<tr><td><code id="grow_DM_+3A_connected">connected</code></td>
<td>
<p>Binary argument determining if the newly grown node has to be connected to the existing network. Defaults to FALSE, to prevent rare computational slow-downs when it is unlikely to create a connected network. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="grow_DM_+3A_retcon">retcon</code></td>
<td>
<p>Binary variable determining if already existing nodes can attach to new nodes. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="grow_DM_+3A_directed">directed</code></td>
<td>
<p>Binary variable determining if the network is directed, resulting in off-diagonal asymmetry in the adjacency matrix. Defaults to TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Different from Duplication &amp; Mutation models in that edges can only be lost.
</p>


<h3>Value</h3>

<p>An adjacency matrix.
</p>


<h3>References</h3>

<p>Ispolatov, I., Krapivsky, P. L., &amp; Yuryev, A. (2005). Duplication-divergence model of protein interaction network. Physical review E, 71(6), 061911.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import netcom
library(netcom)

size &lt;- 10
existing_network &lt;- matrix(sample(c(0,1), size = size^2, replace = TRUE), nrow = size, ncol = size)
new_network_prep &lt;- matrix(0, nrow = size + 1, ncol = size + 1)
new_network_prep[1:size, 1:size] = existing_network
new_network &lt;- grow_DM(matrix = new_network_prep, x = size + 1, divergence = 0.5)

</code></pre>

<hr>
<h2 id='grow_ER'>Grow an Erdos-Renyi Random Network</h2><span id='topic+grow_ER'></span>

<h3>Description</h3>

<p>Grows an already existing network by adding a node according to the Erdos-Renyi random mechanism. Nodes can only attach to previously grown nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grow_ER(matrix, x, p, retcon = FALSE, directed = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grow_ER_+3A_matrix">matrix</code></td>
<td>
<p>Existing network to experience growth.</p>
</td></tr>
<tr><td><code id="grow_ER_+3A_x">x</code></td>
<td>
<p>The ID of the node to be grown.</p>
</td></tr>
<tr><td><code id="grow_ER_+3A_p">p</code></td>
<td>
<p>Probability possible edges exist. Needs to be between zero and one.</p>
</td></tr>
<tr><td><code id="grow_ER_+3A_retcon">retcon</code></td>
<td>
<p>Binary variable determining if already existing nodes can attach to new nodes. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="grow_ER_+3A_directed">directed</code></td>
<td>
<p>Binary variable determining if the network is directed, resulting in off-diagonal asymmetry in the adjacency matrix. Defaults to TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Different from Duplication &amp; Mutation models in that edges can only be lost.
</p>


<h3>Value</h3>

<p>An adjacency matrix.
</p>


<h3>References</h3>

<p>Erdos, P. and Renyi, A., On random graphs, Publicationes Mathematicae 6, 290297 (1959).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import netcom
library(netcom)

size &lt;- 10
existing_network &lt;- matrix(sample(c(0,1), size = size^2, replace = TRUE), nrow = size, ncol = size)
new_network_prep &lt;- matrix(0, nrow = size + 1, ncol = size + 1)
new_network_prep[1:size, 1:size] = existing_network
new_network &lt;- grow_ER(matrix = new_network_prep, x = size + 1, p = 0.5)

</code></pre>

<hr>
<h2 id='grow_NM'>Grow a Niche Model Network</h2><span id='topic+grow_NM'></span>

<h3>Description</h3>

<p>Grows an already existing network by adding a node according to the Niche Model mechanism. Nodes can only attach to previously grown nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grow_NM(matrix, x, niches, connectance = 0.2, directed = TRUE, retcon = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grow_NM_+3A_matrix">matrix</code></td>
<td>
<p>Existing network to experience growth.</p>
</td></tr>
<tr><td><code id="grow_NM_+3A_x">x</code></td>
<td>
<p>The ID of the node to be grown.</p>
</td></tr>
<tr><td><code id="grow_NM_+3A_niches">niches</code></td>
<td>
<p>Vector of length x, with values between zero and one corresponding to each node's niche.</p>
</td></tr>
<tr><td><code id="grow_NM_+3A_connectance">connectance</code></td>
<td>
<p>Niche Model parameter specifying the expected connectivity of the network, which determines for a given node the niche space window within which it attaches to every other node. Defaults to 0.2.</p>
</td></tr>
<tr><td><code id="grow_NM_+3A_directed">directed</code></td>
<td>
<p>Binary variable determining if the network is directed, resulting in off-diagonal asymmetry in the adjacency matrix. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="grow_NM_+3A_retcon">retcon</code></td>
<td>
<p>Binary variable determining if already existing nodes can attach to new nodes. Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Stirs a node in a Niche Model network.
</p>


<h3>Value</h3>

<p>An adjacency matrix.
</p>


<h3>References</h3>

<p>Williams, R. J., &amp; Martinez, N. D. (2000). Simple rules yield complex food webs. Nature, 404(6774), 180-183.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import netcom
library(netcom)

size &lt;- 10
existing_network &lt;- matrix(sample(c(0,1), size = size^2, replace = TRUE), nrow = size, ncol = size)
new_network_prep &lt;- matrix(0, nrow = size + 1, ncol = size + 1)
new_network_prep[1:size, 1:size] = existing_network
new_network &lt;- grow_NM(matrix = new_network_prep, x = size + 1, niches = stats::runif(size))

</code></pre>

<hr>
<h2 id='grow_PA'>Grow a Preferential Attachment Network</h2><span id='topic+grow_PA'></span>

<h3>Description</h3>

<p>Grows an already existing network by adding a node according to the Preferential Attachment mechanism. Nodes can only attach to previously grown nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grow_PA(
  matrix,
  x,
  power,
  sum_v_max = "sum",
  nascent_help = TRUE,
  retcon = FALSE,
  directed = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grow_PA_+3A_matrix">matrix</code></td>
<td>
<p>Existing network to experience growth.</p>
</td></tr>
<tr><td><code id="grow_PA_+3A_x">x</code></td>
<td>
<p>The ID of the node to be grown.</p>
</td></tr>
<tr><td><code id="grow_PA_+3A_power">power</code></td>
<td>
<p>Power of attachment, which determines how much new nodes prefer to attach to nodes that have many edges compared to few. Needs to be positive.</p>
</td></tr>
<tr><td><code id="grow_PA_+3A_sum_v_max">sum_v_max</code></td>
<td>
<p>Degree distributions must be normalized, either by their &quot;max&quot; or &quot;sum&quot;. Defaults to &quot;max&quot;.</p>
</td></tr>
<tr><td><code id="grow_PA_+3A_nascent_help">nascent_help</code></td>
<td>
<p>Should a single edge be added to the degree distribution of all nodes so that nodes with a zero in-degree can still have a chance of being attached to by new nodes. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="grow_PA_+3A_retcon">retcon</code></td>
<td>
<p>Binary variable determining if already existing nodes can attach to new nodes. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="grow_PA_+3A_directed">directed</code></td>
<td>
<p>Binary variable determining if the network is directed, resulting in off-diagonal asymmetry in the adjacency matrix. Defaults to TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Adds a node in a network according to the Preferential Attachment mechanism.
</p>


<h3>Value</h3>

<p>An adjacency matrix.
</p>


<h3>References</h3>

<p>Barabsi, A. L., &amp; Albert, R. (1999). Emergence of scaling in random networks. science, 286(5439), 509-512.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import netcom
library(netcom)

size &lt;- 10
existing_network &lt;- matrix(sample(c(0,1), size = size^2, replace = TRUE), nrow = size, ncol = size)
new_network_prep &lt;- matrix(0, nrow = size + 1, ncol = size + 1)
new_network_prep[1:size, 1:size] = existing_network
new_network &lt;- grow_PA(matrix = new_network_prep, x = size + 1, power = 2.15)

</code></pre>

<hr>
<h2 id='grow_SW'>Grow a Small-World Network</h2><span id='topic+grow_SW'></span>

<h3>Description</h3>

<p>Grows an already existing network by adding a node according to the Small-World mechanism. Nodes can only attach to previously grown nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grow_SW(matrix, x, rewire, connected = FALSE, retcon = FALSE, directed = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grow_SW_+3A_matrix">matrix</code></td>
<td>
<p>Existing network to experience growth.</p>
</td></tr>
<tr><td><code id="grow_SW_+3A_x">x</code></td>
<td>
<p>The ID of the node to be grown.</p>
</td></tr>
<tr><td><code id="grow_SW_+3A_rewire">rewire</code></td>
<td>
<p>Small-World parameter specifying the probability each edge is randomly rewired, allowing for the possiblity of bridges between connected communities.</p>
</td></tr>
<tr><td><code id="grow_SW_+3A_connected">connected</code></td>
<td>
<p>Binary argument determining if the newly grown node has to be connected to the existing network. Defaults to FALSE, to prevent rare computational slow-downs when it is unlikely to create a connected network. Defaults to False.</p>
</td></tr>
<tr><td><code id="grow_SW_+3A_retcon">retcon</code></td>
<td>
<p>Binary variable determining if already existing nodes can attach to new nodes. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="grow_SW_+3A_directed">directed</code></td>
<td>
<p>Binary variable determining if the network is directed, resulting in off-diagonal asymmetry in the adjacency matrix. Defaults to TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Grows a node in a network according to the Small-World mechanism.
</p>


<h3>Value</h3>

<p>An adjacency matrix.
</p>


<h3>References</h3>

<p>Watts, D. J., &amp; Strogatz, S. H. (1998). Collective dynamics of small-worldnetworks. nature, 393(6684), 440-442.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import netcom
library(netcom)

size &lt;- 10
existing_network &lt;- matrix(sample(c(0,1), size = size^2, replace = TRUE), nrow = size, ncol = size)
new_network_prep &lt;- matrix(0, nrow = size + 1, ncol = size + 1)
new_network_prep[1:size, 1:size] = existing_network
new_network &lt;- grow_SW(matrix = new_network_prep, x = size + 1, rewire = 0.213)

</code></pre>

<hr>
<h2 id='ics'>Induced Conserved Structure (ICS)</h2><span id='topic+ics'></span>

<h3>Description</h3>

<p>Calculates the Induced Conserved Structure proposed by Patro and Kingsford (2012) of an alignment between two networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ics(network_1_input, network_2_input, alignment, flip = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ics_+3A_network_1_input">network_1_input</code></td>
<td>
<p>The first network being aligned, which must be in matrix form. If the two
networks are of different sizes, it will be easier to interpret the output if this is the smaller one.</p>
</td></tr>
<tr><td><code id="ics_+3A_network_2_input">network_2_input</code></td>
<td>
<p>The second network, which also must be a matrix.</p>
</td></tr>
<tr><td><code id="ics_+3A_alignment">alignment</code></td>
<td>
<p>A matrix, such as is output by the function NetCom, where the first two columns contain
corresponding node IDs for the two networks that were aligned.</p>
</td></tr>
<tr><td><code id="ics_+3A_flip">flip</code></td>
<td>
<p>Defaults to FALSE. Set to TRUE if the first network is larger than the second. This is necessary 
because ICS is not a symmetric measure of alignment quality.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number ranging between 0 and 1. If the Induced Conserved Structure is 1, the two networks are
isomorphic (identical) under the given alignment.
</p>


<h3>References</h3>

<p>Patro, R., &amp; Kingsford, C. (2012). Global network alignment using multiscale spectral signatures. Bioinformatics, 28(23), 3105-3114.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Note that ICS is only defined on unweighted networks.
net_one &lt;- round(matrix(runif(25,0,1), nrow=5, ncol=5))
net_two &lt;- round(matrix(runif(25,0,1), nrow=5, ncol=5))

ics(net_two, net_two, align(net_one, net_two)$alignment)

</code></pre>

<hr>
<h2 id='make_DD'>Makes a Duplication and Divergence Network</h2><span id='topic+make_DD'></span>

<h3>Description</h3>

<p>Makes a network according to the Duplication and Divergence mechanism.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_DD(size, net_kind, divergence, directed = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_DD_+3A_size">size</code></td>
<td>
<p>Number of nodes in the network.</p>
</td></tr>
<tr><td><code id="make_DD_+3A_net_kind">net_kind</code></td>
<td>
<p>If the network is an adjacency matrix (&quot;matrix&quot;) or an edge list (&quot;list&quot;).</p>
</td></tr>
<tr><td><code id="make_DD_+3A_divergence">divergence</code></td>
<td>
<p>Probability that the new node loses edges associated with the node it duplicates. Needs to be between zero and one.</p>
</td></tr>
<tr><td><code id="make_DD_+3A_directed">directed</code></td>
<td>
<p>Whether the target network is directed. Defaults to TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Different from Duplication &amp; Mutation models in that edges can only be lost.
</p>


<h3>Value</h3>

<p>An adjacency matrix.
</p>


<h3>References</h3>

<p>Ispolatov, I., Krapivsky, P. L., &amp; Yuryev, A. (2005). Duplication-divergence model of protein interaction network. Physical review E, 71(6), 061911.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import netcom
library(netcom)

# Network size (number of nodes)
size &lt;- 10

# Divergence parameter
divergence &lt;- 0.237

# Make network according to the Duplication &amp; Divergence mechanism
make_DD(size = size, net_kind = "matrix", divergence = divergence)

</code></pre>

<hr>
<h2 id='make_DM'>Make a Duplication and Mutation Network</h2><span id='topic+make_DM'></span>

<h3>Description</h3>

<p>Make an already existing network according to the Duplication and Mutation mechanism.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_DM(size, net_kind, divergence, mutation, directed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_DM_+3A_size">size</code></td>
<td>
<p>Number of nodes in the network.</p>
</td></tr>
<tr><td><code id="make_DM_+3A_net_kind">net_kind</code></td>
<td>
<p>If the network is an adjacency matrix (&quot;matrix&quot;) or an edge list (&quot;list&quot;).</p>
</td></tr>
<tr><td><code id="make_DM_+3A_divergence">divergence</code></td>
<td>
<p>Probability that the new node loses edges associated with the node it duplicates. Needs to be between zero and one.</p>
</td></tr>
<tr><td><code id="make_DM_+3A_mutation">mutation</code></td>
<td>
<p>Probability that the new node gains edges not associated with the node it duplicates. Needs to be between zero and one.</p>
</td></tr>
<tr><td><code id="make_DM_+3A_directed">directed</code></td>
<td>
<p>Binary variable determining if the network is directed, resulting in off-diagonal asymmetry in the adjacency matrix. Defaults to TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Different from Duplication &amp; Mutation models in that edges can only be lost.
</p>


<h3>Value</h3>

<p>An adjacency matrix.
</p>


<h3>References</h3>

<p>Ispolatov, I., Krapivsky, P. L., &amp; Yuryev, A. (2005). Duplication-divergence model of protein interaction network. Physical review E, 71(6), 061911.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import netcom
library(netcom)

# Network size (number of nodes)
size &lt;- 10

# Divergence parameter
divergence &lt;- 0.237

# Mutation parameter
mutation &lt;- 0.1

# Make network according to the Duplication &amp; Mutation mechanism
make_DM(size = size, net_kind = "matrix", divergence = divergence, mutation = mutation)

</code></pre>

<hr>
<h2 id='make_Mixture'>Make a Mixture Mechanism Network</h2><span id='topic+make_Mixture'></span>

<h3>Description</h3>

<p>Creates a network by iteratively adding or rewiring nodes, each capable of attaching to existing nodes according to a user-specified mechanism.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_Mixture(
  mechanism,
  directed,
  parameter,
  kind,
  size,
  niches,
  retcon = FALSE,
  link_DD = 0,
  link_DM = 0,
  force_connected = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_Mixture_+3A_mechanism">mechanism</code></td>
<td>
<p>A vector of mechanism names corresponding to the mechanisms each node acts in accordance with. Note that the first two mechanisms are irrelevant because the first two nodes default to connecting to each other. Currently supported mechanisms: &quot;ER&quot; (Erdos-Renyi random), &quot;PA&quot;, (Preferential Attachment), &quot;DD&quot;, (Duplication and Divergence), &quot;DM&quot; (Duplication and Mutation), &quot;SW&quot;, (Small-World), and &quot;NM&quot; (Niche Model).</p>
</td></tr>
<tr><td><code id="make_Mixture_+3A_directed">directed</code></td>
<td>
<p>A binary variable determining if the network is directed, resulting in off-diagonal asymmetry in the adjacency matrix. Either a single value or a vector of values the same length as the mechanism input vector.</p>
</td></tr>
<tr><td><code id="make_Mixture_+3A_parameter">parameter</code></td>
<td>
<p>Parameter of each node's mechanism. Either a single value or a vector of values the same length as the mechanism input vector.</p>
</td></tr>
<tr><td><code id="make_Mixture_+3A_kind">kind</code></td>
<td>
<p>Either 'grow' or 'rewire', and determines if the nodes specified in the mechanism input vector are to be rewired or grown. Either a single value or a vector of values the same length as the mechanism input vector. The number of 'grow' nodes, excluding the first two which are always a pair of bidirectionally connected nodes, is the size of the final network.</p>
</td></tr>
<tr><td><code id="make_Mixture_+3A_size">size</code></td>
<td>
<p>Typically not specified. The size of the network depends on how many 'grow' events are part of the 'kind' input sequence. This should only be used when all four components of the network evolution ('mechanism', 'kind', 'parameter', and 'directed') are single name inputs instead of vectors.</p>
</td></tr>
<tr><td><code id="make_Mixture_+3A_niches">niches</code></td>
<td>
<p>Used by the Niche Model to determine which nodes interact. Needs to be a vector of the same length as the number of nodes, and range between zero and one.</p>
</td></tr>
<tr><td><code id="make_Mixture_+3A_retcon">retcon</code></td>
<td>
<p>Binary variable determining if already existing nodes can attach to new nodes. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="make_Mixture_+3A_link_dd">link_DD</code></td>
<td>
<p>Defaults to 0. A second parameter in the DD (Duplication &amp; Divergence). Currently only one parameter per mechanism can be specified.</p>
</td></tr>
<tr><td><code id="make_Mixture_+3A_link_dm">link_DM</code></td>
<td>
<p>Defaults to 0. A second parameter in the DM (Duplication &amp; Mutation). Currently only one parameter per mechanism can be specified.</p>
</td></tr>
<tr><td><code id="make_Mixture_+3A_force_connected">force_connected</code></td>
<td>
<p>Defaults to FALSE. Determines if nodes can be added to the growing network that are disconnected. If TRUE, this is prevented by re-determining the offending node's edges until the network is connected.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function grows, one node at a time, a mixture mechanism network. As each node is added to the growing network it can attach to existing nodes by its own node-specific mechanism. A sequence of mechanism names must be provided. Note: Currently each mechanism is assumed to have a single governing parameter.
</p>


<h3>Value</h3>

<p>An unweighted mixture mechanism adjacency matrix.
</p>


<h3>References</h3>

<p>Langendorf, R. E., &amp; Burgess, M. G. (2020). Empirically Classifying Network Mechanisms. arXiv preprint arXiv:2012.15863.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import netcom
library(netcom)

# Start by creating a sequence of network evolutions. 
# There are four components to this sequence that can each be defined for every step 
# in the network's evolution. Or, you can also specify a component once which will 
# be used for every step in the newtwork's evolution.

mechanism &lt;- c(
    rep("ER", 7),
    rep("PA", 2),
    rep("ER", 3)
)

kind &lt;- c(
    rep("grow", 7),
    rep("rewire", 2),
    rep("grow", 3)
)

parameter &lt;- c(
    rep(0.3, 7),
    rep(2, 2),
    rep(0.3, 3)
)
directed &lt;- c(
    rep(TRUE, 7),
    rep(FALSE, 2),
    rep(TRUE, 3)
)

# Simulate a network according to the rules of this system evolution.
network &lt;- make_Mixture(
     mechanism = mechanism, 
     kind = kind, 
     parameter = parameter, 
     directed = directed
)

</code></pre>

<hr>
<h2 id='make_NM'>Make a Niche Model network</h2><span id='topic+make_NM'></span>

<h3>Description</h3>

<p>Creates a single network according to the Niche Model. Can be directed or undirected, but is always unweighted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_NM(
  size,
  niches,
  net_kind = "matrix",
  connectance = 0.1,
  directed = TRUE,
  grow = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_NM_+3A_size">size</code></td>
<td>
<p>The number of nodes in the network. Must be a positive integer.</p>
</td></tr>
<tr><td><code id="make_NM_+3A_niches">niches</code></td>
<td>
<p>A vector of numbers specifying the niche of each member of the system (node). Each niche value must be element of [0,1].</p>
</td></tr>
<tr><td><code id="make_NM_+3A_net_kind">net_kind</code></td>
<td>
<p>The format of the network. Currently must be either 'matrix' or 'list'.</p>
</td></tr>
<tr><td><code id="make_NM_+3A_connectance">connectance</code></td>
<td>
<p>Defaults to 0.5. The ratio of actual interactions to possible interactions. Effects the beta distributed width of niche values each member of the system (node) interacts with.</p>
</td></tr>
<tr><td><code id="make_NM_+3A_directed">directed</code></td>
<td>
<p>If FALSE all interactions will be made symmetric. Note that the process of creating interactions is unaffected by this choice. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="make_NM_+3A_grow">grow</code></td>
<td>
<p>Binary argument that determines if the network should be made in a growing fashion, where nodes' edges are added in order of their niches and can only attach to previously considered nodes. Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An interaction matrix format of a Niche Model network.
</p>


<h3>References</h3>

<p>Williams, R. J., &amp; Martinez, N. D. (2000). Simple rules yield complex food webs. Nature, 404(6774), 180-183.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import netcom
library(netcom)

# Network size (number of nodes)
size &lt;- 10

# Create niche values for each member of the system (node)
niches &lt;- stats::runif(n = size)

# Make network according to the Niche Model
make_NM(size = size, niches = niches)

</code></pre>

<hr>
<h2 id='make_Null'>Mechanism Null Distributions</h2><span id='topic+make_Null'></span>

<h3>Description</h3>

<p>Creates a null distribution for a mechanism and parameter combination.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_Null(
  input_network,
  net_kind,
  mechanism_kind,
  process,
  parameter,
  net_size,
  iters,
  method,
  neighborhood,
  DD_kind,
  DD_weight,
  directed,
  resolution_min = 0.01,
  resolution_max = 0.99,
  power_max = 5,
  connectance_max = 0.5,
  divergence_max = 0.5,
  best_fit_sd = 0,
  cores = 1,
  size_different = FALSE,
  cause_orientation = "row",
  max_norm = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_Null_+3A_input_network">input_network</code></td>
<td>
<p>The network for which to create a null distribution.</p>
</td></tr>
<tr><td><code id="make_Null_+3A_net_kind">net_kind</code></td>
<td>
<p>If the network is an adjacency matrix (&quot;matrix&quot;) or an edge list (&quot;list&quot;). Defaults to &quot;matrix&quot;.</p>
</td></tr>
<tr><td><code id="make_Null_+3A_mechanism_kind">mechanism_kind</code></td>
<td>
<p>Either &quot;canonical&quot; or &quot;grow&quot; can be used to simulate networks. If &quot;grow&quot; is used, note that here it will only simulate pure mixtures made of a single mechanism.</p>
</td></tr>
<tr><td><code id="make_Null_+3A_process">process</code></td>
<td>
<p>Name of mechanism. Currently only &quot;ER&quot;, &quot;PA&quot;, &quot;DD&quot;, &quot;DM&quot; &quot;SW&quot;, and &quot;NM&quot; are supported. Future versions will accept user-defined network-generating functions and associated parameters. ER = Erdos-Renyi random. PA = Preferential Attachment. DD = Duplication and Divergence. DM = Duplication and Mutation. SW = Small World. NM = Niche Model.</p>
</td></tr>
<tr><td><code id="make_Null_+3A_parameter">parameter</code></td>
<td>
<p>Parameter in the governing mechanism.</p>
</td></tr>
<tr><td><code id="make_Null_+3A_net_size">net_size</code></td>
<td>
<p>Number of nodes in the network.</p>
</td></tr>
<tr><td><code id="make_Null_+3A_iters">iters</code></td>
<td>
<p>Number of replicates in the null distribution. Note that length(null_dist) = ((iters^2)-iters)/2.</p>
</td></tr>
<tr><td><code id="make_Null_+3A_method">method</code></td>
<td>
<p>This determines the method used to compare networks at the heart of the classification. Currently &quot;DD&quot; (Degree Distribution) and &quot;align&quot; (the align function which compares networks by the entropy of diffusion on them) are supported. Future versions will allow user-defined methods.</p>
</td></tr>
<tr><td><code id="make_Null_+3A_neighborhood">neighborhood</code></td>
<td>
<p>The range of nodes that form connected communities. Note: This implementation results in overlap of communities.</p>
</td></tr>
<tr><td><code id="make_Null_+3A_dd_kind">DD_kind</code></td>
<td>
<p>= A vector of network properties to be used to compare networks.</p>
</td></tr>
<tr><td><code id="make_Null_+3A_dd_weight">DD_weight</code></td>
<td>
<p>= A vector of weights for the relative importance of the network properties in DD_kind being used to compare networks. Should be the same length as DD_kind.</p>
</td></tr>
<tr><td><code id="make_Null_+3A_directed">directed</code></td>
<td>
<p>Whether the target network is directed.</p>
</td></tr>
<tr><td><code id="make_Null_+3A_resolution_min">resolution_min</code></td>
<td>
<p>The minimum parameter value to consider. Zero is not used because in many processes it results in degenerate systems (e.g. entirely unconnected networks). Currently process agnostic. Future versions will accept a vector of values, one for each process. Defaults to 0.01.</p>
</td></tr>
<tr><td><code id="make_Null_+3A_resolution_max">resolution_max</code></td>
<td>
<p>The maximum parameter value to consider. One is not used because in many processes it results in degenerate systems (e.g. entirely connected networks). Currently process agnostic. Future versions will accept a vector of values, one for each process. Defaults to 0.99.</p>
</td></tr>
<tr><td><code id="make_Null_+3A_power_max">power_max</code></td>
<td>
<p>Defaults to 5. The maximum power of attachment in the Preferential Attachment process (PA).</p>
</td></tr>
<tr><td><code id="make_Null_+3A_connectance_max">connectance_max</code></td>
<td>
<p>Defaults to 0.5. The maximum connectance parameter for the Niche Model.</p>
</td></tr>
<tr><td><code id="make_Null_+3A_divergence_max">divergence_max</code></td>
<td>
<p>Defaults to 0.5. The maximum divergence parameter for the Duplication and Divergence/Mutation mechanisms.</p>
</td></tr>
<tr><td><code id="make_Null_+3A_best_fit_sd">best_fit_sd</code></td>
<td>
<p>Defaults to 0.01. Standard Deviation used to simulate networks with a similar but not identical best fit parameter. This is important because simulating networks with the identical parameter artificially inflates the false negative rate by assuming the best fit parameter is the true parameter. For large resolution and reps values this will become true, but also computationally intractable for realistically large systems.</p>
</td></tr>
<tr><td><code id="make_Null_+3A_cores">cores</code></td>
<td>
<p>Defaults to 1. The number of cores to run the classification on. When set to 1 parallelization will be ignored.</p>
</td></tr>
<tr><td><code id="make_Null_+3A_size_different">size_different</code></td>
<td>
<p>If there is a difference in the size of the networks used in the null distribution. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="make_Null_+3A_cause_orientation">cause_orientation</code></td>
<td>
<p>The orientation of directed adjacency matrices. Defaults to &quot;row&quot;.</p>
</td></tr>
<tr><td><code id="make_Null_+3A_max_norm">max_norm</code></td>
<td>
<p>Binary variable indicating if each network property should be normalized so its max value (if a node-level property) is one. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="make_Null_+3A_verbose">verbose</code></td>
<td>
<p>Defaults to FALSE. Whether to print all messages.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Produces ground-truthing network data.
</p>


<h3>Value</h3>

<p>A list. The first element contains the networks. The second contains their corresponding parameters.
</p>


<h3>References</h3>

<p>Langendorf, R. E., &amp; Burgess, M. G. (2020). Empirically Classifying Network Mechanisms. arXiv preprint arXiv:2012.15863.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import netcom
library(netcom)

make_Systematic(net_size = 10)

</code></pre>

<hr>
<h2 id='make_Null_canonical'>Mechanism Null Distributions</h2><span id='topic+make_Null_canonical'></span>

<h3>Description</h3>

<p>Creates a null distribution for a mechanism and parameter combination.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_Null_canonical(
  input_network,
  net_kind,
  process,
  parameter,
  net_size,
  iters,
  method,
  neighborhood,
  DD_kind,
  DD_weight,
  directed,
  resolution_min = 0.01,
  resolution_max = 0.99,
  power_max = 5,
  connectance_max = 0.5,
  divergence_max = 0.5,
  best_fit_sd = 0,
  cores = 1,
  size_different = FALSE,
  cause_orientation = "row",
  max_norm = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_Null_canonical_+3A_input_network">input_network</code></td>
<td>
<p>The network for which to create a null distribution.</p>
</td></tr>
<tr><td><code id="make_Null_canonical_+3A_net_kind">net_kind</code></td>
<td>
<p>If the network is an adjacency matrix (&quot;matrix&quot;) or an edge list (&quot;list&quot;). Defaults to &quot;matrix&quot;.</p>
</td></tr>
<tr><td><code id="make_Null_canonical_+3A_process">process</code></td>
<td>
<p>Name of mechanism. Currently only &quot;ER&quot;, &quot;PA&quot;, &quot;DD&quot;, &quot;DM&quot; &quot;SW&quot;, and &quot;NM&quot; are supported. Future versions will accept user-defined network-generating functions and associated parameters. ER = Erdos-Renyi random. PA = Preferential Attachment. DD = Duplication and Divergence. DM = Duplication and Mutation. SW = Small World. NM = Niche Model.</p>
</td></tr>
<tr><td><code id="make_Null_canonical_+3A_parameter">parameter</code></td>
<td>
<p>Parameter in the governing mechanism.</p>
</td></tr>
<tr><td><code id="make_Null_canonical_+3A_net_size">net_size</code></td>
<td>
<p>Number of nodes in the network.</p>
</td></tr>
<tr><td><code id="make_Null_canonical_+3A_iters">iters</code></td>
<td>
<p>Number of replicates in the null distribution. Note that length(null_dist) = ((iters^2)-iters)/2.</p>
</td></tr>
<tr><td><code id="make_Null_canonical_+3A_method">method</code></td>
<td>
<p>This determines the method used to compare networks at the heart of the classification. Currently &quot;DD&quot; (Degree Distribution) and &quot;align&quot; (the align function which compares networks by the entropy of diffusion on them) are supported. Future versions will allow user-defined methods.</p>
</td></tr>
<tr><td><code id="make_Null_canonical_+3A_neighborhood">neighborhood</code></td>
<td>
<p>The range of nodes that form connected communities. Note: This implementation results in overlap of communities.</p>
</td></tr>
<tr><td><code id="make_Null_canonical_+3A_dd_kind">DD_kind</code></td>
<td>
<p>A vector of network properties to be used to compare networks.</p>
</td></tr>
<tr><td><code id="make_Null_canonical_+3A_dd_weight">DD_weight</code></td>
<td>
<p>A vector of weights for the relative importance of the network properties in DD_kind being used to compare networks. Should be the same length as DD_kind.</p>
</td></tr>
<tr><td><code id="make_Null_canonical_+3A_directed">directed</code></td>
<td>
<p>Whether the target network is directed.</p>
</td></tr>
<tr><td><code id="make_Null_canonical_+3A_resolution_min">resolution_min</code></td>
<td>
<p>The minimum parameter value to consider. Zero is not used because in many processes it results in degenerate systems (e.g. entirely unconnected networks). Currently process agnostic. Future versions will accept a vector of values, one for each process. Defaults to 0.01.</p>
</td></tr>
<tr><td><code id="make_Null_canonical_+3A_resolution_max">resolution_max</code></td>
<td>
<p>The maximum parameter value to consider. One is not used because in many processes it results in degenerate systems (e.g. entirely connected networks). Currently process agnostic. Future versions will accept a vector of values, one for each process. Defaults to 0.99.</p>
</td></tr>
<tr><td><code id="make_Null_canonical_+3A_power_max">power_max</code></td>
<td>
<p>Defaults to 5. The maximum power of attachment in the Preferential Attachment process (PA).</p>
</td></tr>
<tr><td><code id="make_Null_canonical_+3A_connectance_max">connectance_max</code></td>
<td>
<p>Defaults to 0.5. The maximum connectance parameter for the Niche Model.</p>
</td></tr>
<tr><td><code id="make_Null_canonical_+3A_divergence_max">divergence_max</code></td>
<td>
<p>Defaults to 0.5. The maximum divergence parameter for the Duplication and Divergence/Mutation mechanisms.</p>
</td></tr>
<tr><td><code id="make_Null_canonical_+3A_best_fit_sd">best_fit_sd</code></td>
<td>
<p>Defaults to 0.01. Standard Deviation used to simulate networks with a similar but not identical best fit parameter. This is important because simulating networks with the identical parameter artificially inflates the false negative rate by assuming the best fit parameter is the true parameter. For large resolution and reps values this will become true, but also computationally intractable for realistically large systems.</p>
</td></tr>
<tr><td><code id="make_Null_canonical_+3A_cores">cores</code></td>
<td>
<p>Defaults to 1. The number of cores to run the classification on. When set to 1 parallelization will be ignored.</p>
</td></tr>
<tr><td><code id="make_Null_canonical_+3A_size_different">size_different</code></td>
<td>
<p>If there is a difference in the size of the networks used in the null distribution. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="make_Null_canonical_+3A_cause_orientation">cause_orientation</code></td>
<td>
<p>The orientation of directed adjacency matrices. Defaults to &quot;row&quot;.</p>
</td></tr>
<tr><td><code id="make_Null_canonical_+3A_max_norm">max_norm</code></td>
<td>
<p>Binary variable indicating if each network property should be normalized so its max value (if a node-level property) is one. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="make_Null_canonical_+3A_verbose">verbose</code></td>
<td>
<p>Defaults to FALSE. Whether to print all messages.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Produces ground-truthing network data.
</p>


<h3>Value</h3>

<p>A list. The first element contains the networks. The second contains their corresponding parameters.
</p>


<h3>References</h3>

<p>Langendorf, R. E., &amp; Burgess, M. G. (2020). Empirically Classifying Network Mechanisms. arXiv preprint arXiv:2012.15863.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import netcom
library(netcom)

make_Systematic(net_size = 10)

</code></pre>

<hr>
<h2 id='make_Null_mixture'>Mechanism Null Distributions</h2><span id='topic+make_Null_mixture'></span>

<h3>Description</h3>

<p>Creates a null distribution for a mechanism and parameter combination.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_Null_mixture(
  input_network,
  net_kind,
  process,
  parameter,
  net_size,
  iters,
  method,
  neighborhood,
  DD_kind,
  DD_weight,
  directed,
  resolution_min = 0.01,
  resolution_max = 0.99,
  power_max = 5,
  connectance_max = 0.5,
  divergence_max = 0.5,
  best_fit_sd = 0,
  cores = 1,
  size_different = FALSE,
  cause_orientation = "row",
  max_norm = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_Null_mixture_+3A_input_network">input_network</code></td>
<td>
<p>The network for which to create a null distribution.</p>
</td></tr>
<tr><td><code id="make_Null_mixture_+3A_net_kind">net_kind</code></td>
<td>
<p>If the network is an adjacency matrix (&quot;matrix&quot;) or an edge list (&quot;list&quot;). Defaults to &quot;matrix&quot;.</p>
</td></tr>
<tr><td><code id="make_Null_mixture_+3A_process">process</code></td>
<td>
<p>Name of mechanism. Currently only &quot;ER&quot;, &quot;PA&quot;, &quot;DD&quot;, &quot;DM&quot; &quot;SW&quot;, and &quot;NM&quot; are supported. Future versions will accept user-defined network-generating functions and associated parameters. ER = Erdos-Renyi random. PA = Preferential Attachment. DD = Duplication and Divergence. DM = Duplication and Mutation. SW = Small World. NM = Niche Model.</p>
</td></tr>
<tr><td><code id="make_Null_mixture_+3A_parameter">parameter</code></td>
<td>
<p>Parameter in the governing mechanism.</p>
</td></tr>
<tr><td><code id="make_Null_mixture_+3A_net_size">net_size</code></td>
<td>
<p>Number of nodes in the network.</p>
</td></tr>
<tr><td><code id="make_Null_mixture_+3A_iters">iters</code></td>
<td>
<p>Number of replicates in the null distribution. Note that length(null_dist) = ((iters^2)-iters)/2.</p>
</td></tr>
<tr><td><code id="make_Null_mixture_+3A_method">method</code></td>
<td>
<p>This determines the method used to compare networks at the heart of the classification. Currently &quot;DD&quot; (Degree Distribution) and &quot;align&quot; (the align function which compares networks by the entropy of diffusion on them) are supported. Future versions will allow user-defined methods.</p>
</td></tr>
<tr><td><code id="make_Null_mixture_+3A_neighborhood">neighborhood</code></td>
<td>
<p>The range of nodes that form connected communities. Note: This implementation results in overlap of communities.</p>
</td></tr>
<tr><td><code id="make_Null_mixture_+3A_dd_kind">DD_kind</code></td>
<td>
<p>A vector of network properties to be used to compare networks.</p>
</td></tr>
<tr><td><code id="make_Null_mixture_+3A_dd_weight">DD_weight</code></td>
<td>
<p>A vector of weights for the relative importance of the network properties in DD_kind being used to compare networks. Should be the same length as DD_kind.</p>
</td></tr>
<tr><td><code id="make_Null_mixture_+3A_directed">directed</code></td>
<td>
<p>Whether the target network is directed.</p>
</td></tr>
<tr><td><code id="make_Null_mixture_+3A_resolution_min">resolution_min</code></td>
<td>
<p>The minimum parameter value to consider. Zero is not used because in many processes it results in degenerate systems (e.g. entirely unconnected networks). Currently process agnostic. Future versions will accept a vector of values, one for each process. Defaults to 0.01.</p>
</td></tr>
<tr><td><code id="make_Null_mixture_+3A_resolution_max">resolution_max</code></td>
<td>
<p>The maximum parameter value to consider. One is not used because in many processes it results in degenerate systems (e.g. entirely connected networks). Currently process agnostic. Future versions will accept a vector of values, one for each process. Defaults to 0.99.</p>
</td></tr>
<tr><td><code id="make_Null_mixture_+3A_power_max">power_max</code></td>
<td>
<p>Defaults to 5. The maximum power of attachment in the Preferential Attachment process (PA).</p>
</td></tr>
<tr><td><code id="make_Null_mixture_+3A_connectance_max">connectance_max</code></td>
<td>
<p>Defaults to 0.5. The maximum connectance parameter for the Niche Model.</p>
</td></tr>
<tr><td><code id="make_Null_mixture_+3A_divergence_max">divergence_max</code></td>
<td>
<p>Defaults to 0.5. The maximum divergence parameter for the Duplication and Divergence/Mutation mechanisms.</p>
</td></tr>
<tr><td><code id="make_Null_mixture_+3A_best_fit_sd">best_fit_sd</code></td>
<td>
<p>Defaults to 0.01. Standard Deviation used to simulate networks with a similar but not identical best fit parameter. This is important because simulating networks with the identical parameter artificially inflates the false negative rate by assuming the best fit parameter is the true parameter. For large resolution and reps values this will become true, but also computationally intractable for realistically large systems.</p>
</td></tr>
<tr><td><code id="make_Null_mixture_+3A_cores">cores</code></td>
<td>
<p>Defaults to 1. The number of cores to run the classification on. When set to 1 parallelization will be ignored.</p>
</td></tr>
<tr><td><code id="make_Null_mixture_+3A_size_different">size_different</code></td>
<td>
<p>If there is a difference in the size of the networks used in the null distribution. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="make_Null_mixture_+3A_cause_orientation">cause_orientation</code></td>
<td>
<p>The orientation of directed adjacency matrices. Defaults to &quot;row&quot;.</p>
</td></tr>
<tr><td><code id="make_Null_mixture_+3A_max_norm">max_norm</code></td>
<td>
<p>Binary variable indicating if each network property should be normalized so its max value (if a node-level property) is one. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="make_Null_mixture_+3A_verbose">verbose</code></td>
<td>
<p>Defaults to FALSE. Whether to print all messages.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Produces ground-truthing network data.
</p>


<h3>Value</h3>

<p>A list. The first element contains the networks. The second contains their corresponding parameters.
</p>


<h3>References</h3>

<p>Langendorf, R. E., &amp; Burgess, M. G. (2020). Empirically Classifying Network Mechanisms. arXiv preprint arXiv:2012.15863.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import netcom
library(netcom)

make_Systematic(net_size = 10)

</code></pre>

<hr>
<h2 id='make_SW'>Makes a Small-World Network</h2><span id='topic+make_SW'></span>

<h3>Description</h3>

<p>Make an already existing network according to the Small-World mechanism.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_SW(size, rewire, neighborhood, net_kind = "matrix", directed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_SW_+3A_size">size</code></td>
<td>
<p>The number of nodes in the network. Must be a positive integer.</p>
</td></tr>
<tr><td><code id="make_SW_+3A_rewire">rewire</code></td>
<td>
<p>Small-World parameter specifying the probability each edge is randomly rewired, allowing for the possiblity of bridges between connected communities.</p>
</td></tr>
<tr><td><code id="make_SW_+3A_neighborhood">neighborhood</code></td>
<td>
<p>The range of nodes that form connected communities. Note: This implementation results in overlap of communities.</p>
</td></tr>
<tr><td><code id="make_SW_+3A_net_kind">net_kind</code></td>
<td>
<p>The format of the network. Currently must be either 'matrix' or 'list'.x</p>
</td></tr>
<tr><td><code id="make_SW_+3A_directed">directed</code></td>
<td>
<p>Binary variable determining if the network is directed, resulting in off-diagonal asymmetry in the adjacency matrix. Defaults to TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Rewires a node in a network according to the Small-World mechanism.
</p>


<h3>Value</h3>

<p>An adjacency matrix.
</p>


<h3>References</h3>

<p>Watts, D. J., &amp; Strogatz, S. H. (1998). Collective dynamics of small-worldnetworks. nature, 393(6684), 440-442.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import netcom
library(netcom)

# Network size (number of nodes)
size &lt;- 10

# Rewiring parameter
rewire &lt;- 0.2

# Make network according to the Small-World mechanism
make_SW(size = size, net_kind = "matrix", rewire = rewire)

</code></pre>

<hr>
<h2 id='make_Systematic'>Systematically Make Networks</h2><span id='topic+make_Systematic'></span>

<h3>Description</h3>

<p>Creates a list of networks that systematically spans mechanisms and their respective parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_Systematic(
  net_size,
  neighborhood,
  directed = TRUE,
  net_kind = "matrix",
  mechanism_kind = "canonical",
  resolution = 100,
  resolution_min = 0.01,
  resolution_max = 0.99,
  reps = 3,
  processes = c("ER", "PA", "DM", "SW", "NM"),
  power_max = 5,
  connectance_max = 0.5,
  divergence_max = 0.5,
  mutation_max = 0.5,
  canonical = FALSE,
  cores = 1,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_Systematic_+3A_net_size">net_size</code></td>
<td>
<p>Number of nodes in the network.</p>
</td></tr>
<tr><td><code id="make_Systematic_+3A_neighborhood">neighborhood</code></td>
<td>
<p>The range of nodes that form connected communities. Note: This implementation results in overlap of communities.</p>
</td></tr>
<tr><td><code id="make_Systematic_+3A_directed">directed</code></td>
<td>
<p>Whether the target network is directed. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="make_Systematic_+3A_net_kind">net_kind</code></td>
<td>
<p>If the network is an adjacency matrix (&quot;matrix&quot;) or an edge list (&quot;list&quot;). Defaults to &quot;matrix&quot;.</p>
</td></tr>
<tr><td><code id="make_Systematic_+3A_mechanism_kind">mechanism_kind</code></td>
<td>
<p>Either &quot;canonical&quot; or &quot;grow&quot; can be used to simulate networks. If &quot;grow&quot; is used, note that here it will only simulate pure mixtures made of a single mechanism. Defaults to &quot;canonical&quot;.</p>
</td></tr>
<tr><td><code id="make_Systematic_+3A_resolution">resolution</code></td>
<td>
<p>The first step is to find the version of each process most similar to the target network. This parameter sets the number of parameter values to search across. Decrease to improve performance, but at the cost of accuracy. Defaults to 100.</p>
</td></tr>
<tr><td><code id="make_Systematic_+3A_resolution_min">resolution_min</code></td>
<td>
<p>= The minimum parameter value to consider. Zero is not used because in many processes it results in degenerate systems (e.g. entirely unconnected networks). Currently process agnostic. Future versions will accept a vector of values, one for each process. Defaults to 0.01.</p>
</td></tr>
<tr><td><code id="make_Systematic_+3A_resolution_max">resolution_max</code></td>
<td>
<p>The maximum parameter value to consider. One is not used because in many processes it results in degenerate systems (e.g. entirely connected networks). Currently process agnostic. Future versions will accept a vector of values, one for each process. Defaults to 0.99.</p>
</td></tr>
<tr><td><code id="make_Systematic_+3A_reps">reps</code></td>
<td>
<p>Defaults to 3. The number of networks to simulate for each parameter. More replicates increases accuracy by making the estimation of the parameter that produces networks most similar to the target network less idiosyncratic.</p>
</td></tr>
<tr><td><code id="make_Systematic_+3A_processes">processes</code></td>
<td>
<p>Defaults to c(&quot;ER&quot;, &quot;PA&quot;, &quot;DD&quot;, &quot;SW&quot;, &quot;NM&quot;). Vector of process abbreviations. Currently only the default five are supported. Future versions will accept user-defined network-generating functions and associated parameters. ER = Erdos-Renyi random. PA = Preferential Attachment. DD = Duplication and Divergence. SW = Small World. NM = Niche Model.</p>
</td></tr>
<tr><td><code id="make_Systematic_+3A_power_max">power_max</code></td>
<td>
<p>Defaults to 5. The maximum power of attachment in the Preferential Attachment process (PA).</p>
</td></tr>
<tr><td><code id="make_Systematic_+3A_connectance_max">connectance_max</code></td>
<td>
<p>Defaults to 0.5. The maximum connectance parameter for the Niche Model.</p>
</td></tr>
<tr><td><code id="make_Systematic_+3A_divergence_max">divergence_max</code></td>
<td>
<p>Defaults to 0.5. The maximum divergence parameter for the Duplication and Divergence/Mutation mechanisms.</p>
</td></tr>
<tr><td><code id="make_Systematic_+3A_mutation_max">mutation_max</code></td>
<td>
<p>Defaults to 0.5. The maximum mutation parameter for the Duplication and Mutation mechanism.</p>
</td></tr>
<tr><td><code id="make_Systematic_+3A_canonical">canonical</code></td>
<td>
<p>Defautls to FALSE. If TRUE the mechanisms are directed or undirected in accordance with their canonical forms. This negates the value of 'directed'.</p>
</td></tr>
<tr><td><code id="make_Systematic_+3A_cores">cores</code></td>
<td>
<p>Defaults to 1. The number of cores to run the classification on. When set to 1 parallelization will be ignored.</p>
</td></tr>
<tr><td><code id="make_Systematic_+3A_verbose">verbose</code></td>
<td>
<p>Defaults to TRUE. Whether to print all messages.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Produces ground-truthing network data.
</p>


<h3>Value</h3>

<p>A list. The first element contains the networks. The second contains their corresponding parameters.
</p>


<h3>References</h3>

<p>Langendorf, R. E., &amp; Burgess, M. G. (2020). Empirically Classifying Network Mechanisms. arXiv preprint arXiv:2012.15863.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import netcom
library(netcom)

make_Systematic(net_size = 10)

</code></pre>

<hr>
<h2 id='make_Systematic_canonical'>Systematically Make Networks</h2><span id='topic+make_Systematic_canonical'></span>

<h3>Description</h3>

<p>Creates a list of networks that systematically spans mechanisms and their respective parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_Systematic_canonical(
  net_size,
  neighborhood,
  directed = TRUE,
  net_kind = "matrix",
  resolution = 100,
  resolution_min = 0.01,
  resolution_max = 0.99,
  reps = 3,
  processes = c("ER", "PA", "DM", "SW", "NM"),
  power_max = 5,
  connectance_max = 0.5,
  divergence_max = 0.5,
  mutation_max = 0.5,
  cores = 1,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_Systematic_canonical_+3A_net_size">net_size</code></td>
<td>
<p>Number of nodes in the network.</p>
</td></tr>
<tr><td><code id="make_Systematic_canonical_+3A_neighborhood">neighborhood</code></td>
<td>
<p>The range of nodes that form connected communities. Note: This implementation results in overlap of communities.</p>
</td></tr>
<tr><td><code id="make_Systematic_canonical_+3A_directed">directed</code></td>
<td>
<p>Whether the target network is directed. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="make_Systematic_canonical_+3A_net_kind">net_kind</code></td>
<td>
<p>If the network is an adjacency matrix (&quot;matrix&quot;) or an edge list (&quot;list&quot;). Defaults to &quot;matrix&quot;.</p>
</td></tr>
<tr><td><code id="make_Systematic_canonical_+3A_resolution">resolution</code></td>
<td>
<p>The first step is to find the version of each process most similar to the target network. This parameter sets the number of parameter values to search across. Decrease to improve performance, but at the cost of accuracy. Defaults to 100.</p>
</td></tr>
<tr><td><code id="make_Systematic_canonical_+3A_resolution_min">resolution_min</code></td>
<td>
<p>= The minimum parameter value to consider. Zero is not used because in many processes it results in degenerate systems (e.g. entirely unconnected networks). Currently process agnostic. Future versions will accept a vector of values, one for each process. Defaults to 0.01.</p>
</td></tr>
<tr><td><code id="make_Systematic_canonical_+3A_resolution_max">resolution_max</code></td>
<td>
<p>The maximum parameter value to consider. One is not used because in many processes it results in degenerate systems (e.g. entirely connected networks). Currently process agnostic. Future versions will accept a vector of values, one for each process. Defaults to 0.99.</p>
</td></tr>
<tr><td><code id="make_Systematic_canonical_+3A_reps">reps</code></td>
<td>
<p>Defaults to 3. The number of networks to simulate for each parameter. More replicates increases accuracy by making the estimation of the parameter that produces networks most similar to the target network less idiosyncratic.</p>
</td></tr>
<tr><td><code id="make_Systematic_canonical_+3A_processes">processes</code></td>
<td>
<p>Defaults to c(&quot;ER&quot;, &quot;PA&quot;, &quot;DD&quot;, &quot;SW&quot;, &quot;NM&quot;). Vector of process abbreviations. Currently only the default five are supported. Future versions will accept user-defined network-generating functions and associated parameters. ER = Erdos-Renyi random. PA = Preferential Attachment. DD = Duplication and Divergence. SW = Small World. NM = Niche Model.</p>
</td></tr>
<tr><td><code id="make_Systematic_canonical_+3A_power_max">power_max</code></td>
<td>
<p>= Defaults to 5. The maximum power of attachment in the Preferential Attachment process (PA).</p>
</td></tr>
<tr><td><code id="make_Systematic_canonical_+3A_connectance_max">connectance_max</code></td>
<td>
<p>= Defaults to 0.5. The maximum connectance parameter for the Niche Model.</p>
</td></tr>
<tr><td><code id="make_Systematic_canonical_+3A_divergence_max">divergence_max</code></td>
<td>
<p>= Defaults to 0.5. The maximum divergence parameter for the Duplication and Divergence/Mutation mechanisms.</p>
</td></tr>
<tr><td><code id="make_Systematic_canonical_+3A_mutation_max">mutation_max</code></td>
<td>
<p>= Defaults to 0.5. The maximum mutation parameter for the Duplication and Mutation mechanism.</p>
</td></tr>
<tr><td><code id="make_Systematic_canonical_+3A_cores">cores</code></td>
<td>
<p>= Defaults to 1. The number of cores to run the classification on. When set to 1 parallelization will be ignored.</p>
</td></tr>
<tr><td><code id="make_Systematic_canonical_+3A_verbose">verbose</code></td>
<td>
<p>= Defaults to TRUE. Whether to print all messages.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Produces ground-truthing network data.
</p>


<h3>Value</h3>

<p>A list. The first element contains the networks. The second contains their corresponding parameters.
</p>


<h3>References</h3>

<p>Langendorf, R. E., &amp; Burgess, M. G. (2020). Empirically Classifying Network Mechanisms. arXiv preprint arXiv:2012.15863.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import netcom
library(netcom)

make_Systematic(net_size = 10)

</code></pre>

<hr>
<h2 id='make_Systematic_directedCanonicalLike'>Systematically Make Networks</h2><span id='topic+make_Systematic_directedCanonicalLike'></span>

<h3>Description</h3>

<p>Creates a list of networks that systematically spans mechanisms and their respective parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_Systematic_directedCanonicalLike(
  net_size,
  directed = TRUE,
  net_kind = "matrix",
  resolution = 100,
  resolution_min = 0.01,
  resolution_max = 0.99,
  reps = 3,
  processes = c("ER", "PA", "DM", "SW", "NM"),
  power_max = 5,
  connectance_max = 0.5,
  divergence_max = 0.5,
  mutation_max = 0.5,
  cores = 1,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_Systematic_directedCanonicalLike_+3A_net_size">net_size</code></td>
<td>
<p>Number of nodes in the network.</p>
</td></tr>
<tr><td><code id="make_Systematic_directedCanonicalLike_+3A_directed">directed</code></td>
<td>
<p>Whether the target network is directed. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="make_Systematic_directedCanonicalLike_+3A_net_kind">net_kind</code></td>
<td>
<p>If the network is an adjacency matrix (&quot;matrix&quot;) or an edge list (&quot;list&quot;). Defaults to &quot;matrix&quot;.</p>
</td></tr>
<tr><td><code id="make_Systematic_directedCanonicalLike_+3A_resolution">resolution</code></td>
<td>
<p>The first step is to find the version of each process most similar to the target network. This parameter sets the number of parameter values to search across. Decrease to improve performance, but at the cost of accuracy. Defaults to 100.</p>
</td></tr>
<tr><td><code id="make_Systematic_directedCanonicalLike_+3A_resolution_min">resolution_min</code></td>
<td>
<p>= The minimum parameter value to consider. Zero is not used because in many processes it results in degenerate systems (e.g. entirely unconnected networks). Currently process agnostic. Future versions will accept a vector of values, one for each process. Defaults to 0.01.</p>
</td></tr>
<tr><td><code id="make_Systematic_directedCanonicalLike_+3A_resolution_max">resolution_max</code></td>
<td>
<p>The maximum parameter value to consider. One is not used because in many processes it results in degenerate systems (e.g. entirely connected networks). Currently process agnostic. Future versions will accept a vector of values, one for each process. Defaults to 0.99.</p>
</td></tr>
<tr><td><code id="make_Systematic_directedCanonicalLike_+3A_reps">reps</code></td>
<td>
<p>Defaults to 3. The number of networks to simulate for each parameter. More replicates increases accuracy by making the estimation of the parameter that produces networks most similar to the target network less idiosyncratic.</p>
</td></tr>
<tr><td><code id="make_Systematic_directedCanonicalLike_+3A_processes">processes</code></td>
<td>
<p>Defaults to c(&quot;ER&quot;, &quot;PA&quot;, &quot;DD&quot;, &quot;SW&quot;, &quot;NM&quot;). Vector of process abbreviations. Currently only the default five are supported. Future versions will accept user-defined network-generating functions and associated parameters. ER = Erdos-Renyi random. PA = Preferential Attachment. DD = Duplication and Divergence. SW = Small World. NM = Niche Model.</p>
</td></tr>
<tr><td><code id="make_Systematic_directedCanonicalLike_+3A_power_max">power_max</code></td>
<td>
<p>= Defaults to 5. The maximum power of attachment in the Preferential Attachment process (PA).</p>
</td></tr>
<tr><td><code id="make_Systematic_directedCanonicalLike_+3A_connectance_max">connectance_max</code></td>
<td>
<p>= Defaults to 0.5. The maximum connectance parameter for the Niche Model.</p>
</td></tr>
<tr><td><code id="make_Systematic_directedCanonicalLike_+3A_divergence_max">divergence_max</code></td>
<td>
<p>= Defaults to 0.5. The maximum divergence parameter for the Duplication and Divergence/Mutation mechanisms.</p>
</td></tr>
<tr><td><code id="make_Systematic_directedCanonicalLike_+3A_mutation_max">mutation_max</code></td>
<td>
<p>= Defaults to 0.5. The maximum mutation parameter for the Duplication and Mutation mechanism.</p>
</td></tr>
<tr><td><code id="make_Systematic_directedCanonicalLike_+3A_cores">cores</code></td>
<td>
<p>= Defaults to 1. The number of cores to run the classification on. When set to 1 parallelization will be ignored.</p>
</td></tr>
<tr><td><code id="make_Systematic_directedCanonicalLike_+3A_verbose">verbose</code></td>
<td>
<p>= Defaults to TRUE. Whether to print all messages.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Produces ground-truthing network data.
</p>


<h3>Value</h3>

<p>A list. The first element contains the networks. The second contains their corresponding parameters.
</p>


<h3>References</h3>

<p>Langendorf, R. E., &amp; Burgess, M. G. (2020). Empirically Classifying Network Mechanisms. arXiv preprint arXiv:2012.15863.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import netcom
library(netcom)

make_Systematic(net_size = 10)

</code></pre>

<hr>
<h2 id='make_Systematic_mixture'>Systematically Make Networks</h2><span id='topic+make_Systematic_mixture'></span>

<h3>Description</h3>

<p>Creates a list of networks that systematically spans mechanisms and their respective parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_Systematic_mixture(
  net_size,
  neighborhood,
  directed = TRUE,
  net_kind = "matrix",
  resolution = 100,
  resolution_min = 0.01,
  resolution_max = 0.99,
  reps = 3,
  processes = c("ER", "PA", "DM", "SW", "NM"),
  power_max = 5,
  connectance_max = 0.5,
  divergence_max = 0.5,
  mutation_max = 0.5,
  canonical = FALSE,
  cores = 1,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_Systematic_mixture_+3A_net_size">net_size</code></td>
<td>
<p>Number of nodes in the network.</p>
</td></tr>
<tr><td><code id="make_Systematic_mixture_+3A_neighborhood">neighborhood</code></td>
<td>
<p>The range of nodes that form connected communities. Note: This implementation results in overlap of communities.</p>
</td></tr>
<tr><td><code id="make_Systematic_mixture_+3A_directed">directed</code></td>
<td>
<p>Whether the target network is directed. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="make_Systematic_mixture_+3A_net_kind">net_kind</code></td>
<td>
<p>If the network is an adjacency matrix (&quot;matrix&quot;) or an edge list (&quot;list&quot;). Defaults to &quot;matrix&quot;.</p>
</td></tr>
<tr><td><code id="make_Systematic_mixture_+3A_resolution">resolution</code></td>
<td>
<p>The first step is to find the version of each process most similar to the target network. This parameter sets the number of parameter values to search across. Decrease to improve performance, but at the cost of accuracy. Defaults to 100.</p>
</td></tr>
<tr><td><code id="make_Systematic_mixture_+3A_resolution_min">resolution_min</code></td>
<td>
<p>= The minimum parameter value to consider. Zero is not used because in many processes it results in degenerate systems (e.g. entirely unconnected networks). Currently process agnostic. Future versions will accept a vector of values, one for each process. Defaults to 0.01.</p>
</td></tr>
<tr><td><code id="make_Systematic_mixture_+3A_resolution_max">resolution_max</code></td>
<td>
<p>The maximum parameter value to consider. One is not used because in many processes it results in degenerate systems (e.g. entirely connected networks). Currently process agnostic. Future versions will accept a vector of values, one for each process. Defaults to 0.99.</p>
</td></tr>
<tr><td><code id="make_Systematic_mixture_+3A_reps">reps</code></td>
<td>
<p>Defaults to 3. The number of networks to simulate for each parameter. More replicates increases accuracy by making the estimation of the parameter that produces networks most similar to the target network less idiosyncratic.</p>
</td></tr>
<tr><td><code id="make_Systematic_mixture_+3A_processes">processes</code></td>
<td>
<p>Defaults to c(&quot;ER&quot;, &quot;PA&quot;, &quot;DD&quot;, &quot;SW&quot;, &quot;NM&quot;). Vector of process abbreviations. Currently only the default five are supported. Future versions will accept user-defined network-generating functions and associated parameters. ER = Erdos-Renyi random. PA = Preferential Attachment. DD = Duplication and Divergence. SW = Small World. NM = Niche Model.</p>
</td></tr>
<tr><td><code id="make_Systematic_mixture_+3A_power_max">power_max</code></td>
<td>
<p>Defaults to 5. The maximum power of attachment in the Preferential Attachment process (PA).</p>
</td></tr>
<tr><td><code id="make_Systematic_mixture_+3A_connectance_max">connectance_max</code></td>
<td>
<p>Defaults to 0.5. The maximum connectance parameter for the Niche Model.</p>
</td></tr>
<tr><td><code id="make_Systematic_mixture_+3A_divergence_max">divergence_max</code></td>
<td>
<p>Defaults to 0.5. The maximum divergence parameter for the Duplication and Divergence/Mutation mechanisms.</p>
</td></tr>
<tr><td><code id="make_Systematic_mixture_+3A_mutation_max">mutation_max</code></td>
<td>
<p>Defaults to 0.5. The maximum mutation parameter for the Duplication and Mutation mechanism.</p>
</td></tr>
<tr><td><code id="make_Systematic_mixture_+3A_canonical">canonical</code></td>
<td>
<p>Defautls to FALSE. If TRUE the mechanisms are directed or undirected in accordance with their canonical forms. This negates the value of 'directed'.</p>
</td></tr>
<tr><td><code id="make_Systematic_mixture_+3A_cores">cores</code></td>
<td>
<p>= Defaults to 1. The number of cores to run the classification on. When set to 1 parallelization will be ignored.</p>
</td></tr>
<tr><td><code id="make_Systematic_mixture_+3A_verbose">verbose</code></td>
<td>
<p>= Defaults to TRUE. Whether to print all messages.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Produces ground-truthing network data.
</p>


<h3>Value</h3>

<p>A list. The first element contains the networks. The second contains their corresponding parameters.
</p>


<h3>References</h3>

<p>Langendorf, R. E., &amp; Burgess, M. G. (2020). Empirically Classifying Network Mechanisms. arXiv preprint arXiv:2012.15863.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import netcom
library(netcom)

make_Systematic(net_size = 10)

</code></pre>

<hr>
<h2 id='null_fit_optim'>Empirical parameterization via null distributions</h2><span id='topic+null_fit_optim'></span>

<h3>Description</h3>

<p>Helper function to find the best fitting version of a mechanism by searching across the null distributions associated with a process + parameter combination.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>null_fit_optim(
  parameter,
  process,
  network,
  net_size,
  iters,
  neighborhood,
  directed,
  DD_kind,
  DD_weight,
  net_kind,
  mechanism_kind,
  method,
  size_different,
  power_max,
  connectance_max,
  divergence_max,
  best_fit_sd,
  max_norm,
  cause_orientation,
  cores,
  null_dist_trim,
  ks_dither,
  ks_alternative,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="null_fit_optim_+3A_parameter">parameter</code></td>
<td>
<p>The parameter being tested for its ability to generate networks alike the input 'network'.</p>
</td></tr>
<tr><td><code id="null_fit_optim_+3A_process">process</code></td>
<td>
<p>Name of mechanism. Currently only &quot;ER&quot;, &quot;PA&quot;, &quot;DD&quot;, &quot;DM&quot; &quot;SW&quot;, and &quot;NM&quot; are supported. Future versions will accept user-defined network-generating functions and associated parameters. ER = Erdos-Renyi random. PA = Preferential Attachment. DD = Duplication and Divergence. DM = Duplication and Mutation. SW = Small World. NM = Niche Model.</p>
</td></tr>
<tr><td><code id="null_fit_optim_+3A_network">network</code></td>
<td>
<p>The network being compared to a hypothesized 'process' with a given 'parameter' value.</p>
</td></tr>
<tr><td><code id="null_fit_optim_+3A_net_size">net_size</code></td>
<td>
<p>Number of nodes in the network.</p>
</td></tr>
<tr><td><code id="null_fit_optim_+3A_iters">iters</code></td>
<td>
<p>Number of replicates in the null distribution. Note that length(null_dist) = ((iters^2)-iters)/2.</p>
</td></tr>
<tr><td><code id="null_fit_optim_+3A_neighborhood">neighborhood</code></td>
<td>
<p>The range of nodes that form connected communities. Note: This implementation results in overlap of communities.</p>
</td></tr>
<tr><td><code id="null_fit_optim_+3A_directed">directed</code></td>
<td>
<p>Whether the target network is directed.</p>
</td></tr>
<tr><td><code id="null_fit_optim_+3A_dd_kind">DD_kind</code></td>
<td>
<p>A vector of network properties to be used to compare networks.</p>
</td></tr>
<tr><td><code id="null_fit_optim_+3A_dd_weight">DD_weight</code></td>
<td>
<p>A vector of weights for the relative importance of the network properties in DD_kind being used to compare networks. Should be the same length as DD_kind.</p>
</td></tr>
<tr><td><code id="null_fit_optim_+3A_net_kind">net_kind</code></td>
<td>
<p>If the network is an adjacency matrix (&quot;matrix&quot;) or an edge list (&quot;list&quot;).</p>
</td></tr>
<tr><td><code id="null_fit_optim_+3A_mechanism_kind">mechanism_kind</code></td>
<td>
<p>Either &quot;canonical&quot; or &quot;grow&quot; can be used to simulate networks. If &quot;grow&quot; is used, note that here it will only simulate pure mixtures made of a single mechanism.</p>
</td></tr>
<tr><td><code id="null_fit_optim_+3A_method">method</code></td>
<td>
<p>This determines the method used to compare networks at the heart of the classification. Currently &quot;DD&quot; (Degree Distribution) and &quot;align&quot; (the align function which compares networks by the entropy of diffusion on them) are supported. Future versions will allow user-defined methods.</p>
</td></tr>
<tr><td><code id="null_fit_optim_+3A_size_different">size_different</code></td>
<td>
<p>If there is a difference in the size of the networks used in the null distribution.</p>
</td></tr>
<tr><td><code id="null_fit_optim_+3A_power_max">power_max</code></td>
<td>
<p>The maximum power of attachment in the Preferential Attachment process (PA).</p>
</td></tr>
<tr><td><code id="null_fit_optim_+3A_connectance_max">connectance_max</code></td>
<td>
<p>The maximum connectance parameter for the Niche Model.</p>
</td></tr>
<tr><td><code id="null_fit_optim_+3A_divergence_max">divergence_max</code></td>
<td>
<p>The maximum divergence parameter for the Duplication and Divergence/Mutation mechanisms.</p>
</td></tr>
<tr><td><code id="null_fit_optim_+3A_best_fit_sd">best_fit_sd</code></td>
<td>
<p>Standard Deviation used to simulate networks with a similar but not identical best fit parameter. This is important because simulating networks with the identical parameter artificially inflates the false negative rate by assuming the best fit parameter is the true parameter. For large resolution and reps values this will become true, but also computationally intractable for realistically large systems.</p>
</td></tr>
<tr><td><code id="null_fit_optim_+3A_max_norm">max_norm</code></td>
<td>
<p>Binary variable indicating if each network property should be normalized so its max value (if a node-level property) is one.</p>
</td></tr>
<tr><td><code id="null_fit_optim_+3A_cause_orientation">cause_orientation</code></td>
<td>
<p>The orientation of directed adjacency matrices.</p>
</td></tr>
<tr><td><code id="null_fit_optim_+3A_cores">cores</code></td>
<td>
<p>The number of cores to run the classification on. When set to 1 parallelization will be ignored.</p>
</td></tr>
<tr><td><code id="null_fit_optim_+3A_null_dist_trim">null_dist_trim</code></td>
<td>
<p>= Number between zero and one that determines how much of each network comparison distribution (unknown network compared to simulated networks, simulated networks compared to each other) should be used. Prevents p-value convergence with large sample sizes. Defaults to 1, which means all comparisons are used (no trimming).</p>
</td></tr>
<tr><td><code id="null_fit_optim_+3A_ks_dither">ks_dither</code></td>
<td>
<p>The KS test cannot compute exact p-values when every pairwise network distance is not unique. Adding small amounts of noise makes each distance unique. We are not aware of a study on the impacts this has on accuracy so it is set to zero by default.</p>
</td></tr>
<tr><td><code id="null_fit_optim_+3A_ks_alternative">ks_alternative</code></td>
<td>
<p>Governs the KS test. Assuming best_fit_sd is not too large, this can be set to &quot;greater&quot; because the target network cannot be more alike identically simulated networks than they are to each other. In practice we have found &quot;greater&quot; and &quot;less&quot; produce numerical errors. Only &quot;two.sided&quot;, &quot;less&quot;, and &quot;greater&quot; are supported through stats::ks.test().</p>
</td></tr>
<tr><td><code id="null_fit_optim_+3A_verbose">verbose</code></td>
<td>
<p>Defaults to TRUE. Whether to print all messages.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: Currently each process is assumed to have a single governing parameter.
</p>


<h3>Value</h3>

<p>A number measuring how different the input network is from the parameter + process combination.
</p>


<h3>References</h3>

<p>Langendorf, R. E., &amp; Burgess, M. G. (2020). Empirically Classifying Network Mechanisms. arXiv preprint arXiv:2012.15863.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import netcom
library(netcom)

# Adjacency matrix
size &lt;- 10
network &lt;- matrix(sample(c(0,1), size = size^2, replace = TRUE), nrow = size, ncol = size)

# Calculate how similar the input network is to Small-World networks with 
# a rewiring probability of 0.28.
null_fit_optim(
     parameter = 0.28, 
     process = "SW", 
     network = network, 
     net_size = 12, 
     iters = 20,
     neighborhood = max(1, round(0.1 * net_size)),
     net_kind = "matrix", 
     mechanism_kind = "grow", 
     power_max = 5, 
     connectance_max = 0.5, 
     divergence_max = 0.5, 
     cores = 1, 
     directed = TRUE, 
     method = "DD", 
     size_different = FALSE,
     cause_orientation = "row", 
     DD_kind = c(
         "in", "out", "entropy_in", "entropy_out", 
         "clustering_coefficient", "page_rank", "communities"
     ), 
     DD_weight = 1, 
     best_fit_sd = 0,
     max_norm = FALSE,
     null_dist_trim = 0,
     ks_dither = 0,
     ks_alternative = "two.sided",
     verbose = FALSE
)

</code></pre>

<hr>
<h2 id='stir_DD'>Sitrs a Duplication and Divergence Network</h2><span id='topic+stir_DD'></span>

<h3>Description</h3>

<p>Stirs an already existing network by rewiring a node according to the Duplication and Divergence mechanism.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stir_DD(
  matrix,
  x,
  divergence,
  directed = TRUE,
  link = 0,
  force_connected = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stir_DD_+3A_matrix">matrix</code></td>
<td>
<p>Existing network to be rewired (stirred).</p>
</td></tr>
<tr><td><code id="stir_DD_+3A_x">x</code></td>
<td>
<p>The ID of the node to be grown.</p>
</td></tr>
<tr><td><code id="stir_DD_+3A_divergence">divergence</code></td>
<td>
<p>Probability that the new node loses edges associated with the node it duplicates. Needs to be between zero and one.</p>
</td></tr>
<tr><td><code id="stir_DD_+3A_directed">directed</code></td>
<td>
<p>Binary variable determining if the network is directed, resulting in off-diagonal asymmetry in the adjacency matrix.</p>
</td></tr>
<tr><td><code id="stir_DD_+3A_link">link</code></td>
<td>
<p>Probability that the new node attaches to the node it duplicates. Defaults to 0.</p>
</td></tr>
<tr><td><code id="stir_DD_+3A_force_connected">force_connected</code></td>
<td>
<p>Binary argument determining if the newly grown node has to be connected to the existing network. Defaults to FALSE, to prevent rare computational slow-downs when it is unlikely to create a connected network. Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Different from Duplication &amp; Mutation models in that edges can only be lost.
</p>


<h3>Value</h3>

<p>An adjacency matrix.
</p>


<h3>References</h3>

<p>Ispolatov, I., Krapivsky, P. L., &amp; Yuryev, A. (2005). Duplication-divergence model of protein interaction network. Physical review E, 71(6), 061911.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import netcom
library(netcom)

size &lt;- 10
existing_network &lt;- matrix(sample(c(0,1), size = size^2, replace = TRUE), nrow = size, ncol = size)
new_network_prep &lt;- matrix(0, nrow = size + 1, ncol = size + 1)
new_network_prep[1:size, 1:size] = existing_network
new_network &lt;- stir_DD(matrix = new_network_prep, x = size + 1, divergence = 0.5)

</code></pre>

<hr>
<h2 id='stir_DM'>Stirs a Duplication and Mutation Network</h2><span id='topic+stir_DM'></span>

<h3>Description</h3>

<p>Stirs an already existing network by rewiring a node according to the Duplication and Mutation mechanism.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stir_DM(
  matrix,
  x,
  divergence,
  mutation,
  directed = TRUE,
  link = 0,
  force_connected = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stir_DM_+3A_matrix">matrix</code></td>
<td>
<p>Existing network to experience growth.</p>
</td></tr>
<tr><td><code id="stir_DM_+3A_x">x</code></td>
<td>
<p>The ID of the node to be rewired (stirred).</p>
</td></tr>
<tr><td><code id="stir_DM_+3A_divergence">divergence</code></td>
<td>
<p>Probability that the new node loses edges associated with the node it duplicates. Needs to be between zero and one.</p>
</td></tr>
<tr><td><code id="stir_DM_+3A_mutation">mutation</code></td>
<td>
<p>Probability that the new node gains edges not associated with the node it duplicates. Needs to be between zero and one.</p>
</td></tr>
<tr><td><code id="stir_DM_+3A_directed">directed</code></td>
<td>
<p>Binary variable determining if the network is directed, resulting in off-diagonal asymmetry in the adjacency matrix.</p>
</td></tr>
<tr><td><code id="stir_DM_+3A_link">link</code></td>
<td>
<p>Probability that the new node attaches to the node it duplicates. Defaults to 0.</p>
</td></tr>
<tr><td><code id="stir_DM_+3A_force_connected">force_connected</code></td>
<td>
<p>Binary argument determining if the newly grown node has to be connected to the existing network. Defaults to FALSE, to prevent rare computational slow-downs when it is unlikely to create a connected network. Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Different from Duplication &amp; Mutation models in that edges can only be lost.
</p>


<h3>Value</h3>

<p>An adjacency matrix.
</p>


<h3>References</h3>

<p>Ispolatov, I., Krapivsky, P. L., &amp; Yuryev, A. (2005). Duplication-divergence model of protein interaction network. Physical review E, 71(6), 061911.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import netcom
library(netcom)

size &lt;- 10
existing_network &lt;- matrix(sample(c(0,1), size = size^2, replace = TRUE), nrow = size, ncol = size)
new_network_prep &lt;- matrix(0, nrow = size + 1, ncol = size + 1)
new_network_prep[1:size, 1:size] = existing_network
new_network &lt;- stir_DM(matrix = new_network_prep, x = size + 1, divergence = 0.5, mutation = 0.21)

</code></pre>

<hr>
<h2 id='stir_ER'>Stir an Erdos-Renyi Random Network</h2><span id='topic+stir_ER'></span>

<h3>Description</h3>

<p>Stirs an already existing network by rewiring a node according to the Erdos-Renyi random mechanism.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stir_ER(matrix, x, p, directed = TRUE, retcon = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stir_ER_+3A_matrix">matrix</code></td>
<td>
<p>Existing network to experience growth.</p>
</td></tr>
<tr><td><code id="stir_ER_+3A_x">x</code></td>
<td>
<p>The ID of the node to be rewired (stirred).</p>
</td></tr>
<tr><td><code id="stir_ER_+3A_p">p</code></td>
<td>
<p>Probability possible edges exist. Needs to be between zero and one.</p>
</td></tr>
<tr><td><code id="stir_ER_+3A_directed">directed</code></td>
<td>
<p>Binary variable determining if the network is directed, resulting in off-diagonal asymmetry in the adjacency matrix.</p>
</td></tr>
<tr><td><code id="stir_ER_+3A_retcon">retcon</code></td>
<td>
<p>Binary variable determining if already existing nodes can attach to new nodes. Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Different from Duplication &amp; Mutation models in that edges can only be lost.
</p>


<h3>Value</h3>

<p>An adjacency matrix.
</p>


<h3>References</h3>

<p>Erdos, P. and Renyi, A., On random graphs, Publicationes Mathematicae 6, 290297 (1959).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import netcom
library(netcom)

size &lt;- 10
existing_network &lt;- matrix(sample(c(0,1), size = size^2, replace = TRUE), nrow = size, ncol = size)
new_network_prep &lt;- matrix(0, nrow = size + 1, ncol = size + 1)
new_network_prep[1:size, 1:size] = existing_network
new_network &lt;- stir_ER(matrix = new_network_prep, x = size + 1, p = 0.5)

</code></pre>

<hr>
<h2 id='stir_NM'>Stirs a Niche Model Network</h2><span id='topic+stir_NM'></span>

<h3>Description</h3>

<p>Stirs an already existing network by rewiring a node according to the Niche Model mechanism.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stir_NM(matrix, x, niches, directed = TRUE, connectance = 0.2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stir_NM_+3A_matrix">matrix</code></td>
<td>
<p>Existing network to experience rewiring (stirring).</p>
</td></tr>
<tr><td><code id="stir_NM_+3A_x">x</code></td>
<td>
<p>The ID of the node to be grown.</p>
</td></tr>
<tr><td><code id="stir_NM_+3A_niches">niches</code></td>
<td>
<p>Vector of length x, with values between zero and one corresponding to each node's niche.</p>
</td></tr>
<tr><td><code id="stir_NM_+3A_directed">directed</code></td>
<td>
<p>Binary variable determining if the network is directed, resulting in off-diagonal asymmetry in the adjacency matrix. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="stir_NM_+3A_connectance">connectance</code></td>
<td>
<p>Niche Model parameter specifying the expected connectivity of the network, which determines for a given node the niche space window within which it attaches to every other node. Defaults to 0.2.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Stirs a node in a Niche Model network.
</p>


<h3>Value</h3>

<p>An adjacency matrix.
</p>


<h3>References</h3>

<p>Williams, R. J., &amp; Martinez, N. D. (2000). Simple rules yield complex food webs. Nature, 404(6774), 180-183.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import netcom
library(netcom)

size &lt;- 10
existing_network &lt;- matrix(sample(c(0,1), size = size^2, replace = TRUE), nrow = size, ncol = size)
new_network_prep &lt;- matrix(0, nrow = size + 1, ncol = size + 1)
new_network_prep[1:size, 1:size] = existing_network
new_network &lt;- stir_NM(
     matrix = new_network_prep, 
     x = size + 1, 
     connectance = 0.1, 
     niches = runif(size + 1)
)

</code></pre>

<hr>
<h2 id='stir_PA'>Stirs a Preferential Attachment Network</h2><span id='topic+stir_PA'></span>

<h3>Description</h3>

<p>Stirs an already existing network by rewiring a node according to the Preferential Attachment mechanism.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stir_PA(
  matrix,
  x,
  power,
  directed = TRUE,
  retcon = FALSE,
  sum_v_max = "max",
  nascent_help = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stir_PA_+3A_matrix">matrix</code></td>
<td>
<p>Existing network to experience growth.</p>
</td></tr>
<tr><td><code id="stir_PA_+3A_x">x</code></td>
<td>
<p>The ID of the node to be rewired (stirred).</p>
</td></tr>
<tr><td><code id="stir_PA_+3A_power">power</code></td>
<td>
<p>Power of attachment, which determines how much new nodes prefer to attach to nodes that have many edges compared to few. Needs to be positive.</p>
</td></tr>
<tr><td><code id="stir_PA_+3A_directed">directed</code></td>
<td>
<p>Binary variable determining if the network is directed, resulting in off-diagonal asymmetry in the adjacency matrix.</p>
</td></tr>
<tr><td><code id="stir_PA_+3A_retcon">retcon</code></td>
<td>
<p>Binary variable determining if already existing nodes can attach to new nodes. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="stir_PA_+3A_sum_v_max">sum_v_max</code></td>
<td>
<p>Degree distributions must be normalized, either by their &quot;max&quot; or &quot;sum&quot;. Defaults to &quot;max&quot;.</p>
</td></tr>
<tr><td><code id="stir_PA_+3A_nascent_help">nascent_help</code></td>
<td>
<p>Should a single edge be added to the degree distribution of all nodes so that nodes with a zero in-degree can still have a chance of being attached to by new nodes. Defaults to TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Rewires a node in a network according to the Preferential Attachment mechanism.
</p>


<h3>Value</h3>

<p>An adjacency matrix.
</p>


<h3>References</h3>

<p>Barabsi, A. L., &amp; Albert, R. (1999). Emergence of scaling in random networks. science, 286(5439), 509-512.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import netcom
library(netcom)

size &lt;- 10
existing_network &lt;- matrix(sample(c(0,1), size = size^2, replace = TRUE), nrow = size, ncol = size)
new_network_prep &lt;- matrix(0, nrow = size + 1, ncol = size + 1)
new_network_prep[1:size, 1:size] = existing_network
new_network &lt;- stir_PA(matrix = new_network_prep, x = size + 1, power = 2.15)

</code></pre>

<hr>
<h2 id='stir_SW'>Stirs a Small-World Network</h2><span id='topic+stir_SW'></span>

<h3>Description</h3>

<p>Stirs an already existing network by rewiring a node according to the Small-World mechanism.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stir_SW(matrix, x, rewire, directed = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stir_SW_+3A_matrix">matrix</code></td>
<td>
<p>Existing network to experience growth.</p>
</td></tr>
<tr><td><code id="stir_SW_+3A_x">x</code></td>
<td>
<p>The ID of the node to be grown.</p>
</td></tr>
<tr><td><code id="stir_SW_+3A_rewire">rewire</code></td>
<td>
<p>Small-World parameter specifying the probability each edge is randomly rewired, allowing for the possiblity of bridges between connected communities.</p>
</td></tr>
<tr><td><code id="stir_SW_+3A_directed">directed</code></td>
<td>
<p>Binary variable determining if the network is directed, resulting in off-diagonal asymmetry in the adjacency matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Rewires a node in a network according to the Small-World mechanism.
</p>


<h3>Value</h3>

<p>An adjacency matrix.
</p>


<h3>References</h3>

<p>Watts, D. J., &amp; Strogatz, S. H. (1998). Collective dynamics of small-worldnetworks. nature, 393(6684), 440-442.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import netcom
library(netcom)

size &lt;- 10
existing_network &lt;- matrix(sample(c(0,1), size = size^2, replace = TRUE), nrow = size, ncol = size)
new_network_prep &lt;- matrix(0, nrow = size + 1, ncol = size + 1)
new_network_prep[1:size, 1:size] = existing_network
new_network &lt;- stir_SW(matrix = new_network_prep, x = size + 1, rewire = 0.213)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
