<!DOCTYPE html><html><head><title>Help for package piecepackr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {piecepackr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AA_to_R'><p>Helper functions for making geometric calculations.</p></a></li>
<li><a href='#aabb_piece'><p>Calculate axis-aligned bounding box for set of game pieces</p></a></li>
<li><a href='#animate_piece'><p>Animate board game pieces</p></a></li>
<li><a href='#basicPieceGrobs'><p>Piece Grob Functions</p></a></li>
<li><a href='#font_utils'><p>Font utility functions</p></a></li>
<li><a href='#game_systems'><p>Standard game systems</p></a></li>
<li><a href='#geom_piece'><p>Draw board game pieces with ggplot2</p></a></li>
<li><a href='#grid.cropmark'><p>Crop Mark Grob</p></a></li>
<li><a href='#grid.piece'><p>Draw board game pieces with grid</p></a></li>
<li><a href='#op_transform'><p>Oblique projection helper function</p></a></li>
<li><a href='#piece'><p>Create rayrender board game piece objects</p></a></li>
<li><a href='#piece_mesh'><p>Create rayvertex board game piece objects</p></a></li>
<li><a href='#piece3d'><p>Render board game pieces with rgl</p></a></li>
<li><a href='#piecepackr-defunct'><p>Defunct functions</p></a></li>
<li><a href='#piecepackr-package'><p>piecepackr: Board Game Graphics</p></a></li>
<li><a href='#pmap_piece'><p>Create graphics using data frame input</p></a></li>
<li><a href='#pp_cfg'><p>Configuration list R6 object</p></a></li>
<li><a href='#pp_shape'><p>Shape object for generating various grobs</p></a></li>
<li><a href='#pp_utils'><p>Miscellaneous <code>piecepackr</code> utility functions</p></a></li>
<li><a href='#render_piece'><p>Render image of game pieces</p></a></li>
<li><a href='#save_ellipsoid_obj'><p>Alternative Wavefront OBJ file generators</p></a></li>
<li><a href='#save_piece_images'><p>Save piecepack images</p></a></li>
<li><a href='#save_piece_obj'><p>Save Wavefront OBJ files of board game pieces</p></a></li>
<li><a href='#save_print_and_play'><p>Save piecepack print-and-play (PnP) file</p></a></li>
<li><a href='#scale_x_piece'><p>ggplot2 game diagram scales</p></a></li>
<li><a href='#spdx_license_list'><p>SPDX License List data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Board Game Graphics</td>
</tr>
<tr>
<td>Version:</td>
<td>1.13.10</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions to make board game graphics with the 'ggplot2', 'grid', 'rayrender', 'rayvertex', and 'rgl' packages.  Specializes in game diagrams, animations, and "Print &amp; Play" layouts for the 'piecepack' <a href="https://www.ludism.org/ppwiki">https://www.ludism.org/ppwiki</a> but can make graphics for other board game systems.  Includes configurations for several public domain game systems such as checkers, (double-18) dominoes, go, 'piecepack', playing cards, etc.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://trevorldavis.com/piecepackr/">https://trevorldavis.com/piecepackr/</a> (blog),
<a href="https://trevorldavis.com/R/piecepackr/">https://trevorldavis.com/R/piecepackr/</a> (pkgdown),
<a href="https://groups.google.com/forum/#!forum/piecepackr">https://groups.google.com/forum/#!forum/piecepackr</a> (forum)</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/piecepackr/piecepackr/issues">https://github.com/piecepackr/piecepackr/issues</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Imports:</td>
<td>grid, gridGeometry, grImport2, grDevices, purrr, jpeg, png,
R6, rlang, stringr, tibble, tools, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>animation (&ge; 2.7), ggplot2, gifski, gridpattern, magick,
pdftools, rayrender (&ge; 0.28.8), rayvertex (&ge; 0.10.4), readobj
(&ge; 0.4.0), rgl (&ge; 0.106.8), scales (&ge; 0.5.0), systemfonts,
testthat, tweenr, vdiffr, xmpdf (&ge; 0.1.1), XML (&ge; 3.99-0.9)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-19 01:01:55 UTC; trevorld</td>
</tr>
<tr>
<td>Author:</td>
<td>Trevor L Davis <a href="https://orcid.org/0000-0001-6341-4639"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Linux Foundation [dtc] (Uses some data from the "SPDX License List"
    &lt;https://github.com/spdx/license-list-XML&gt;),
  Delapouite &lt;https://delapouite.com/&gt; [ill] (Meeple shape extracted from
    "Meeple icon" &lt;https://game-icons.net/1x1/delapouite/meeple.html&gt; /
    "CC BY 3.0" &lt;https://creativecommons.org/licenses/by/3.0/&gt;),
  Creative Commons [ill] (`save_print_and_play()` uses "license badges"
    from Creative Commons to describe the generated print-and-play
    file's license)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Trevor L Davis &lt;trevor.l.davis@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-19 04:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='AA_to_R'>Helper functions for making geometric calculations.</h2><span id='topic+AA_to_R'></span><span id='topic+R_to_AA'></span><span id='topic+geometry_utils'></span><span id='topic+R_x'></span><span id='topic+R_y'></span><span id='topic+R_z'></span><span id='topic+to_radians'></span><span id='topic+to_degrees'></span><span id='topic+to_x'></span><span id='topic+to_y'></span><span id='topic+to_r'></span><span id='topic+to_t'></span>

<h3>Description</h3>

<p><code>to_x</code>, <code>to_y</code>, <code>to_r</code>, <code>to_t</code> convert
between polar coordinates (in degrees) and Cartesian coordinates.
<code>to_degrees</code> and <code>to_radians</code> converts between degrees and radians.
<code>AA_to_R</code> and <code>R_to_AA</code> convert back and forth between (post-multiplied) rotation matrix
and axis-angle representations of 3D rotations.
<code>R_x</code>, <code>R_y</code>, and <code>R_z</code> build (post-multiplied) rotation matrices for simple rotations around
the x, y, and z axes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AA_to_R(angle = 0, axis_x = 0, axis_y = 0, axis_z = NA, ...)

R_to_AA(R = diag(3))

R_x(angle = 0)

R_y(angle = 0)

R_z(angle = 0)

to_radians(t)

to_degrees(t)

to_x(t, r)

to_y(t, r)

to_r(x, y)

to_t(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AA_to_R_+3A_angle">angle</code></td>
<td>
<p>Angle in degrees (counter-clockwise)</p>
</td></tr>
<tr><td><code id="AA_to_R_+3A_axis_x">axis_x</code></td>
<td>
<p>First coordinate of the axis unit vector.</p>
</td></tr>
<tr><td><code id="AA_to_R_+3A_axis_y">axis_y</code></td>
<td>
<p>Second coordinate of the axis unit vector.</p>
</td></tr>
<tr><td><code id="AA_to_R_+3A_axis_z">axis_z</code></td>
<td>
<p>Third coordinate of the axis unit vector (usually inferred).</p>
</td></tr>
<tr><td><code id="AA_to_R_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
<tr><td><code id="AA_to_R_+3A_r">R</code></td>
<td>
<p>3D rotation matrix (post-multiplied)</p>
</td></tr>
<tr><td><code id="AA_to_R_+3A_t">t</code></td>
<td>
<p>Angle in degrees (counter-clockwise)</p>
</td></tr>
<tr><td><code id="AA_to_R_+3A_r">r</code></td>
<td>
<p>Radial distance</p>
</td></tr>
<tr><td><code id="AA_to_R_+3A_x">x</code></td>
<td>
<p>Cartesian x coordinate</p>
</td></tr>
<tr><td><code id="AA_to_R_+3A_y">y</code></td>
<td>
<p>Cartesian y coordinate</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pp_cfg</code> uses polar coordinates to determine where the &quot;primary&quot; and &quot;directional&quot;
symbols are located on a game piece.
They are also useful for drawing certain shapes and for making game diagrams on hex boards.
</p>
<p><code>piecepackr</code> and <code>grid</code> functions use angles in degrees
but the <code>base</code> trigonometry functions usually use radians.
</p>
<p><code>piecepackr</code>'s 3D graphics functions <code>save_piece_obj</code>, <code>piece</code>, and <code>piece3d</code>
use the axis-angle representation for 3D rotations.
The axis-angle representation involves specifying a unit vector
indicating the direction of an axis of rotation and an angle describing the (counter-clockwise)
rotation around that axis.  Because it is a unit vector one only needs to specify the first two elements,
<code>axis_x</code> and <code>axis_y</code>, and we are able to infer the 3rd element <code>axis_z</code>.  The default of
<code>axis = 0</code>, <code>axis_y = 0</code>, and implied <code>axis_z = 1</code>
corresponds to a rotation around the z-axis which is reverse-compatible
with the originally 2D <code>angle</code> interpretation in <code>grid.piece</code>.  In order to figure out the appropriate
axis-angle representation parameters <code>R_to_AA</code>, <code>R_x</code>, <code>R_y</code>, and <code>R_z</code> allow one
to first come up with an appropriate (post-multiplied) 3D rotation matrix by chaining simple rotations
and then convert them to the corresponding axis-angle representation.
Pieces are rotated as if their center was at the origin.
</p>


<h3>See Also</h3>

<p><a href="https://en.wikipedia.org/wiki/Axis-angle_representation">https://en.wikipedia.org/wiki/Axis-angle_representation</a> for more details
about the Axis-angle representation of 3D rotations.
See <code><a href="base.html#topic+Trig">Trig</a></code> for R's built-in trigonometric functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> to_x(90, 1)
 to_y(180, 0.5)
 to_t(0, -1)
 to_r(0.5, 0)
 all.equal(pi, to_radians(to_degrees(pi)))
 # default axis-angle axis is equivalent to a rotation about the z-axis
 all.equal(AA_to_R(angle=60), R_z(angle=60))
 # axis-angle representation of 90 rotation about the x-axis
 R_to_AA(R_x(90))
 # find Axis-Angle representation of first rotating about x-axis 180 degrees
 # and then rotating about z-axis 45 degrees
 R_to_AA(R_x(180) %*% R_z(45))

</code></pre>

<hr>
<h2 id='aabb_piece'>Calculate axis-aligned bounding box for set of game pieces</h2><span id='topic+aabb_piece'></span>

<h3>Description</h3>

<p>Calculate axis-aligned bounding box (AABB) for set of game pieces
with and without an &ldquo;oblique projection&rdquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aabb_piece(
  df,
  cfg = getOption("piecepackr.cfg", pp_cfg()),
  envir = getOption("piecepackr.envir"),
  op_scale = getOption("piecepackr.op_scale", 0),
  op_angle = getOption("piecepackr.op_angle", 45),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aabb_piece_+3A_df">df</code></td>
<td>
<p>A data frame of game piece information with (at least) the
named columns &ldquo;piece_side&rdquo;, &ldquo;x&rdquo;, and &ldquo;y&rdquo;.</p>
</td></tr>
<tr><td><code id="aabb_piece_+3A_cfg">cfg</code></td>
<td>
<p>Piecepack configuration list or <code>pp_cfg</code> object,
a list of <code>pp_cfg</code> objects,
or a character vector referring to names in <code>envir</code>
or a character vector referring to object names that
can be retrieved by <code>base::dynGet()</code>.</p>
</td></tr>
<tr><td><code id="aabb_piece_+3A_envir">envir</code></td>
<td>
<p>Environment (or named list) containing configuration list(s).</p>
</td></tr>
<tr><td><code id="aabb_piece_+3A_op_scale">op_scale</code></td>
<td>
<p>How much to scale the depth of the piece in the oblique projection
(viewed from the top of the board).
<code>0</code> (the default) leads to an &ldquo;orthographic&rdquo; projection,
<code>0.5</code> is the most common scale used in the &ldquo;cabinet&rdquo; projection,
and <code>1.0</code> is the scale used in the &ldquo;cavalier&rdquo; projection.</p>
</td></tr>
<tr><td><code id="aabb_piece_+3A_op_angle">op_angle</code></td>
<td>
<p>What is the angle of the oblique projection?  Has no effect if <code>op_scale</code> is <code>0</code>.</p>
</td></tr>
<tr><td><code id="aabb_piece_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &ldquo;oblique projection&rdquo; of a set of <code class="reqn">(x,y,z)</code> points onto the xy-plane
is <code class="reqn">(x + \lambda * z * cos(\alpha), y + \lambda * z * sin(\alpha))</code>
where <code class="reqn">\lambda</code> is the scale factor and <code class="reqn">\alpha</code> is the angle.
</p>


<h3>Value</h3>

<p>A named list of ranges with five named elements <code>x</code>, <code>y</code>, and <code>z</code> for
the axis-aligned bounding cube
in xyz-space plus <code>x_op</code> and <code>y_op</code> for the axis-aligned bounding box
of the &ldquo;oblique projection&rdquo; onto the xy plane.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> df_tiles &lt;- data.frame(piece_side="tile_back", x=0.5+c(3,1,3,1), y=0.5+c(3,3,1,1),
                        suit=NA, angle=NA, z=NA, stringsAsFactors=FALSE)
 df_coins &lt;- data.frame(piece_side="coin_back", x=rep(4:1, 4), y=rep(4:1, each=4),
                        suit=1:16%%2+rep(c(1,3), each=8),
                        angle=rep(c(180,0), each=8), z=1/4+1/16, stringsAsFactors=FALSE)
 df &lt;- rbind(df_tiles, df_coins)

 aabb_piece(df, op_scale = 0)
 aabb_piece(df, op_scale = 1, op_angle = 45)
 aabb_piece(df, op_scale = 1, op_angle = -90)
</code></pre>

<hr>
<h2 id='animate_piece'>Animate board game pieces</h2><span id='topic+animate_piece'></span>

<h3>Description</h3>

<p><code>animate_piece()</code> animates board game pieces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>animate_piece(
  dfs,
  file = "animation.gif",
  ...,
  annotate = TRUE,
  .f = piecepackr::grid.piece,
  cfg = getOption("piecepackr.cfg", NULL),
  envir = getOption("piecepackr.envir", game_systems("sans")),
  n_transitions = 0L,
  n_pauses = 1L,
  fps = n_transitions + n_pauses,
  width = NULL,
  height = NULL,
  ppi = NULL,
  new_device = TRUE,
  annotation_scale = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="animate_piece_+3A_dfs">dfs</code></td>
<td>
<p>A list of data frames of game data to plot.</p>
</td></tr>
<tr><td><code id="animate_piece_+3A_file">file</code></td>
<td>
<p>Filename to save animation unless <code>NULL</code>
in which case it uses the current graphics device.</p>
</td></tr>
<tr><td><code id="animate_piece_+3A_...">...</code></td>
<td>
<p>Arguments to <code>pmap_piece</code></p>
</td></tr>
<tr><td><code id="animate_piece_+3A_annotate">annotate</code></td>
<td>
<p>If <code>TRUE</code> or <code>"algebraic"</code> annotate the plot
with &ldquo;algrebraic&rdquo; coordinates,
if <code>FALSE</code> or <code>"none"</code> don't annotate,
if <code>"cartesian"</code> annotate the plot with &ldquo;cartesian&rdquo; coordinates.</p>
</td></tr>
<tr><td><code id="animate_piece_+3A_.f">.f</code></td>
<td>
<p>Low level graphics function to use e.g. <code><a href="#topic+grid.piece">grid.piece()</a></code>, <code><a href="#topic+piece3d">piece3d()</a></code>, <code><a href="#topic+piece">piece()</a></code>, or <code><a href="#topic+piece_mesh">piece_mesh()</a></code>.</p>
</td></tr>
<tr><td><code id="animate_piece_+3A_cfg">cfg</code></td>
<td>
<p>A piecepackr configuration list</p>
</td></tr>
<tr><td><code id="animate_piece_+3A_envir">envir</code></td>
<td>
<p>Environment (or named list) of piecepackr configuration lists</p>
</td></tr>
<tr><td><code id="animate_piece_+3A_n_transitions">n_transitions</code></td>
<td>
<p>Integer, if over zero (the default)
how many transition frames to add between moves.</p>
</td></tr>
<tr><td><code id="animate_piece_+3A_n_pauses">n_pauses</code></td>
<td>
<p>Integer, how many paused frames per completed move.</p>
</td></tr>
<tr><td><code id="animate_piece_+3A_fps">fps</code></td>
<td>
<p>Double, frames per second.</p>
</td></tr>
<tr><td><code id="animate_piece_+3A_width">width</code></td>
<td>
<p>Width of animation (in inches).  Inferred by default.</p>
</td></tr>
<tr><td><code id="animate_piece_+3A_height">height</code></td>
<td>
<p>Height of animation (in inches).  Inferred by default.</p>
</td></tr>
<tr><td><code id="animate_piece_+3A_ppi">ppi</code></td>
<td>
<p>Resolution of animation in pixels per inch.
By default set so image max 600 pixels wide or tall.</p>
</td></tr>
<tr><td><code id="animate_piece_+3A_new_device">new_device</code></td>
<td>
<p>If <code>file</code> is <code>NULL</code> should we open up a new graphics device?</p>
</td></tr>
<tr><td><code id="animate_piece_+3A_annotation_scale">annotation_scale</code></td>
<td>
<p>Multiplicative factor that scales (stretches) any annotation coordinates.
By default uses <code>attr(df, "scale_factor") %||% 1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing, as a side effect creates an animation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Basic tic-tac-toe animation
  dfs &lt;- list()
  d.frame &lt;- function(piece_side = "bit_back", ..., rank = 1L) {
                 data.frame(piece_side = piece_side, ..., rank = rank,
                            cfg = "checkers1", stringsAsFactors = FALSE)
  }
  df &lt;- d.frame("board_back", suit = 2L, rank = 3L, x = 2, y = 2, id = "1")
  dfs[[1L]] &lt;- df
  df &lt;- rbind(df, d.frame(suit = 1L, x = 2, y = 2, id = "2"))
  dfs[[2L]] &lt;- df
  df &lt;- rbind(df, d.frame(suit = 2L, x = 1, y = 2, id = "3"))
  dfs[[3L]] &lt;- df
  df &lt;- rbind(df, d.frame(suit = 1L, x = 3, y = 1, id = "4"))
  dfs[[4L]] &lt;- df
  df &lt;- rbind(df, d.frame(suit = 2L, x = 1, y = 3, id = "5"))
  dfs[[5L]] &lt;- df
  df &lt;- rbind(df, d.frame(suit = 1L, x = 1, y = 1, id = "6"))
  dfs[[6L]] &lt;- df
  df &lt;- rbind(df, d.frame(suit = 2L, x = 3, y = 3, id = "7"))
  dfs[[7L]] &lt;- df
  df &lt;- rbind(df, d.frame(suit = 1L, x = 2, y = 1, id = "8"))
  dfs[[8L]] &lt;- df

  ## Press enter to walk through moves in a "game" in new graphics device
  if (interactive()) {
      animate_piece(dfs, file = NULL)
  }

  ## Save GIF of game with animation transitions
  ## Not run: # May take more than 5 seconds on CRAN servers
  if ((requireNamespace("animation", quietly = TRUE) ||
       requireNamespace("gifski", quietly = TRUE)) &amp;&amp;
      requireNamespace("tweenr", quietly = TRUE)) {
      file &lt;- tempfile("tic-tac-toe", fileext = ".gif")
      animate_piece(dfs, file = file,
                    n_transitions = 5L, n_pauses = 2L, fps = 9)
  }
  
## End(Not run)

</code></pre>

<hr>
<h2 id='basicPieceGrobs'>Piece Grob Functions</h2><span id='topic+basicPieceGrobs'></span><span id='topic+basicPieceGrob'></span><span id='topic+picturePieceGrobFn'></span><span id='topic+pyramidTopGrob'></span><span id='topic+previewLayoutGrob'></span>

<h3>Description</h3>

<p><code>basicPieceGrob</code> is the most common
&ldquo;grob&rdquo; function that <code>grid.piece</code> uses
to create <code>grid</code> graphical <code>grob</code> objects.
<code>picturePieceGrobFn</code> is a function that returns a &ldquo;grob&rdquo; function
that imports graphics from files found in its <code>directory</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>basicPieceGrob(piece_side, suit, rank, cfg = pp_cfg())

picturePieceGrobFn(directory, filename_fn = find_pp_file)

pyramidTopGrob(piece_side, suit, rank, cfg = pp_cfg())

previewLayoutGrob(piece_side, suit, rank, cfg = pp_cfg())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="basicPieceGrobs_+3A_piece_side">piece_side</code></td>
<td>
<p>A string with piece and side separated by a underscore e.g. &quot;coin_face&quot;</p>
</td></tr>
<tr><td><code id="basicPieceGrobs_+3A_suit">suit</code></td>
<td>
<p>Number of suit (starting from 1).</p>
</td></tr>
<tr><td><code id="basicPieceGrobs_+3A_rank">rank</code></td>
<td>
<p>Number of rank (starting from 1)</p>
</td></tr>
<tr><td><code id="basicPieceGrobs_+3A_cfg">cfg</code></td>
<td>
<p>Piecepack configuration list or <code>pp_cfg</code> object.</p>
</td></tr>
<tr><td><code id="basicPieceGrobs_+3A_directory">directory</code></td>
<td>
<p>Directory that <code>picturePieceGrobFn</code> will look in for piece graphics.</p>
</td></tr>
<tr><td><code id="basicPieceGrobs_+3A_filename_fn">filename_fn</code></td>
<td>
<p>Function that takes arguments <code>directory</code>, <code>piece_side</code>, <code>suit</code>,
<code>rank</code>, and optionally <code>cfg</code> and returns the (full path) filename of the image that the
function returned by <code>picturePieceGrobFn</code> should import.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
 if (requireNamespace("grid", quietly = TRUE) &amp;&amp; piecepackr:::device_supports_unicode()) {
   cfg &lt;- pp_cfg(list(grob_fn.tile=basicPieceGrob, invert_colors=TRUE))
   grid.piece("tile_face", suit=1, rank=3, cfg=cfg)
 }

 # May take more than 5 seconds on CRAN servers
 try({
   if (requireNamespace("grid", quietly = TRUE) &amp;&amp; capabilities(c("cairo"))) {
     cfg &lt;- pp_cfg(list(grob_fn.tile=basicPieceGrob, invert_colors=TRUE))
     directory &lt;- tempdir()
     save_piece_images(cfg, directory=directory, format="svg", angle=0)
     cfg2 &lt;- pp_cfg(list(grob_fn=picturePieceGrobFn(directory)))

     grid::grid.newpage()
     grid.piece("coin_back", suit=3, rank=5, cfg=cfg2)
   }
 })
 
</code></pre>

<hr>
<h2 id='font_utils'>Font utility functions</h2><span id='topic+font_utils'></span><span id='topic+get_embedded_font'></span><span id='topic+has_font'></span>

<h3>Description</h3>

<p><code>get_embedded_font()</code> returns which font is actually embedded
by <code>cairo_pdf()</code> for a given character.
<code>has_font()</code> tries to determine if a given font is available on the OS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_embedded_font(font, char)

has_font(font)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="font_utils_+3A_font">font</code></td>
<td>
<p>A character vector of font(s).</p>
</td></tr>
<tr><td><code id="font_utils_+3A_char">char</code></td>
<td>
<p>A character vector of character(s) to be embedded by <code>grid::grid.text()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>get_embedded_font()</code> depends on the suggested <code>pdftools</code> package being installed
and R being compiled with Cairo support.
<code>has_font()</code> depends on either the suggested <code>systemfonts</code> (preferred) or <code>pdftools</code>
packages being installed.
</p>


<h3>Value</h3>

<p><code>get_embedded_font()</code> returns character vector of fonts that were actually embedded by <code>cairo_pdf()</code>.
<code>NA</code>'s means no embedded font detected: this either means that no font
was found or that a color emoji font was found and instead of a font an image was embedded.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> if (requireNamespace("pdftools", quietly = TRUE) &amp;&amp;
     capabilities("cairo") &amp;&amp;
     !piecepackr:::is_cairo_maybe_buggy()) {
   chars &lt;- c("a", "\u2666")
   fonts &lt;- c("sans", "Sans Noto", "Noto Sans", "Noto Sans Symbols2")
   try(get_embedded_font(fonts, chars))
 }

 if (requireNamespace("systemfonts", quietly = TRUE) ||
     (requireNamespace("pdftools", quietly = TRUE) &amp;&amp;
      capabilities("cairo")) &amp;&amp; !piecepackr:::is_cairo_maybe_buggy()) {
   try(has_font("Dejavu Sans"))
 }
</code></pre>

<hr>
<h2 id='game_systems'>Standard game systems</h2><span id='topic+game_systems'></span><span id='topic+to_hexpack'></span><span id='topic+to_subpack'></span>

<h3>Description</h3>

<p><code>game_systems</code> returns a list of <code>pp_cfg</code> objects
representing several game systems and pieces.
<code>to_subpack</code> and <code>to_hexpack</code> will attempt to generate matching (piecepack stackpack)
subpack and (piecepack) hexpack <code>pp_cfg</code> R6 objects respectively given a piecepack configuration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>game_systems(style = NULL, round = FALSE, pawn = "token")

to_hexpack(cfg = getOption("piecepackr.cfg", pp_cfg()))

to_subpack(cfg = getOption("piecepackr.cfg", pp_cfg()))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="game_systems_+3A_style">style</code></td>
<td>
<p>If <code>NULL</code> (the default) uses suit glyphs from the default &ldquo;sans&rdquo; font.
If <code>"dejavu"</code> it will use suit glyphs from the &quot;DejaVu Sans&quot; font
(must be installed on the system).</p>
</td></tr>
<tr><td><code id="game_systems_+3A_round">round</code></td>
<td>
<p>If <code>TRUE</code> the &ldquo;shape&rdquo; of &ldquo;tiles&rdquo; and &ldquo;cards&rdquo;
will be &ldquo;roundrect&rdquo; instead of &ldquo;rect&rdquo; (the default).</p>
</td></tr>
<tr><td><code id="game_systems_+3A_pawn">pawn</code></td>
<td>
<p>If <code>"token"</code> (default) the piecepack pawn will be a two-sided token in a &ldquo;halma&rdquo; outline,
if <code>"peg-doll"</code> the piecepack pawn will be a &ldquo;peg doll&rdquo; style pawn, and
if <code>"joystick"</code> the piecepack pawn will be a &ldquo;joystick&rdquo; style pawn.
Note for the latter two pawn styles only <code>pawn_top</code> will work with <code>grid.piece</code>.</p>
</td></tr>
<tr><td><code id="game_systems_+3A_cfg">cfg</code></td>
<td>
<p>List of configuration options</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Contains the following game systems:</p>

<dl>
<dt>alquerque</dt><dd><p>Boards and pieces in six color schemes for Alquerque</p>
</dd>
<dt>checkers1, checkers2</dt><dd><p>Checkers and checkered boards in six color schemes.
Checkers are represented by a piecepackr &ldquo;bit&rdquo;.
The &ldquo;board&rdquo; &ldquo;face&rdquo; is a checkered board and the &ldquo;back&rdquo; is a lined board.
Color is controlled by suit and number of rows/columns by rank.
<code>checkers1</code> has one inch squares and <code>checkers2</code> has two inch squares.</p>
</dd>
<dt>chess1, chess2</dt><dd><p>Chess pieces, boards, and dice in six color schemes.
Chess pieces are represented by a &ldquo;bit&rdquo; (face).
The &ldquo;board&rdquo; &ldquo;face&rdquo; is a checkered board and the &ldquo;back&rdquo; is a lined board.
Color is controlled by suit and number of rows/columns by rank.
<code>chess1</code> has one inch squares and <code>chess2</code> has two inch squares.
Currently uses print-and-play style discs instead of 3D Staunton chess pieces.</p>
</dd>
<dt>dice</dt><dd><p>Traditional six-sided pipped dice in six color schemes (color controlled by their suit).</p>
</dd>
<dt>dice_d4, dice_numeral, dice_d8, dice_d10, dice_d10_percentile, dice_d12, dice_d20</dt><dd>
<p>Polyhedral dice most commonly used to play wargames, roleplaying games, and trading card games:</p>

<dl>
<dt>dice_d4</dt><dd><p>Four-sided dice in six color schemes (color controlled by their suit).
Tetrahedrons with the rank as a numeral at the top point.</p>
</dd>
<dt>dice_numeral</dt><dd><p>Six-sided dice with numerals instead of pips in six color schemes (color controlled by their suit).</p>
</dd>
<dt>dice_d8</dt><dd><p>Eight-sided dice in six color schemes (color controlled by their suit).
Octahedrons with the rank as a numeral at the top face.</p>
</dd>
<dt>dice_d10</dt><dd><p>Ten-sided dice in six color schemes (color controlled by their suit).
Pentagonal trapezohedrons with the rank as a numeral at the top face.
The rank of ten is represented by a zero.</p>
</dd>
<dt>dice_d10_percentile</dt><dd><p>Ten-sided dice in six color schemes (color controlled by their suit).
Pentagonal trapezohedrons with the rank as a numeral followed by a zero at the top face.
The rank of ten is represented by a zero.</p>
</dd>
<dt>dice_d12</dt><dd><p>Twelve-sided dice in six color schemes (color controlled by their suit).
Dodecahedrons with the rank as a numeral at the top face.</p>
</dd>
<dt>dice_d20</dt><dd><p>Twenty-sided dice in six color schemes (color controlled by their suit).
Icosahedrons with the rank as a numeral at the top face.</p>
</dd></dl>
</dd>
<dt>dice_fudge</dt><dd><p>&ldquo;Fudge&rdquo; dice in six color schemes (color controlled by their suit).
&ldquo;Fudge&rdquo; dice have three ranks &quot;+&quot;, &quot; &quot;, and &quot;-&quot; repeated twice.</p>
</dd>
<dt>dominoes, dominoes_black, dominoes_blue, dominoes_green, dominoes_red, dominoes_white, dominoes_yellow</dt><dd>
<p>Traditional pipped dominoes in six color schemes (<code>dominoes</code> and <code>dominoes_white</code> are the same).
In each color scheme the number of pips on the &ldquo;top&rdquo; of the domino is
controlled by their &ldquo;rank&rdquo; and on the &ldquo;bottom&rdquo; by their &ldquo;suit&rdquo;.
Supports up to double-18 sets.</p>
</dd>
<dt>dominoes_chinese, dominoes_chinese_black</dt><dd><p><code>dominoes_chinese</code> has Asian-style six-sided pipped dice with
white background and black and red pips.
The &ldquo;tile&rdquo;'s are Chinese dominoes (1&quot; x 2.5&quot;) whose number of pips are controlled
by both their &ldquo;rank&rdquo; and their &ldquo;suit&rdquo;. <code>dominoes_chinese_black</code> are like <code>dominoes_chinese</code> but the
dice and dominoes have a black background and white and red pips.</p>
</dd>
<dt>go</dt><dd><p>Go stones and lined boards in six color schemes.
Go stones are represented by a &ldquo;bit&rdquo; and the board is a &ldquo;board&rdquo;.
Color is controlled by suit and number of rows/columns by rank.</p>
</dd>
<dt>meeples</dt><dd><p>Standard 16mm x 16mm x 10mm &ldquo;meeples&rdquo; in six colors represented by a &ldquo;bit&rdquo;.</p>
</dd>
<dt>morris</dt><dd><p>Various morris aka mills aka merels games in six colors.
Color is controlled by suit and &ldquo;size&rdquo; of morris board
is controlled by rank e.g. &ldquo;Six men's morris&rdquo; corresponds to a rank of 6 and
&ldquo;Nine men's morris&rdquo; corresponds to a rank of 9.
Game pieces are represented by stones.</p>
</dd>
<dt>piecepack, dual_piecepacks_expansion, playing_cards_expansion, hexpack, subpack, piecepack_inverted</dt><dd>
<p>The piecepack is a public domain game system invented by James &quot;Kyle&quot; Droscha.
See <a href="https://www.ludism.org/ppwiki">https://www.ludism.org/ppwiki</a> for more info about the piecepack and its accessories/expansions.
</p>

<dl>
<dt>piecepack</dt><dd><p>A standard piecepack.  The configuration also contains the following piecepack accessories:</p>

<dl>
<dt>piecepack dice cards</dt><dd><p>An accessory proposed by John Braley.
See <a href="https://www.ludism.org/ppwiki/PiecepackDiceCards">https://www.ludism.org/ppwiki/PiecepackDiceCards</a>.</p>
</dd>
<dt>piecepack matchsticks</dt><dd><p>A public domain accessory developed by Dan Burkey.
See <a href="https://www.ludism.org/ppwiki/PiecepackMatchsticks">https://www.ludism.org/ppwiki/PiecepackMatchsticks</a>.</p>
</dd>
<dt>piecepack pyramids</dt><dd><p>A public domain accessory developed by Tim Schutz.
See <a href="https://www.ludism.org/ppwiki/PiecepackPyramids">https://www.ludism.org/ppwiki/PiecepackPyramids</a>.</p>
</dd>
<dt>piecepack saucers</dt><dd><p>A public domain accessory developed by Karol M. Boyle at Mesomorph Games.
See <a href="https://web.archive.org/web/20190719155827/http://www.piecepack.org/Accessories.html">https://web.archive.org/web/20190719155827/http://www.piecepack.org/Accessories.html</a>.</p>
</dd></dl>
</dd>
<dt>piecepack_inverted</dt><dd><p>The standard piecepack with its color scheme inverted.
Intended to aid in highlighting special pieces in diagrams.</p>
</dd>
<dt>dual_piecepacks_expansion</dt><dd><p>A companion piecepack with a special suit scheme.
See <a href="https://trevorldavis.com/piecepackr/dual-piecepacks-pnp.html">https://trevorldavis.com/piecepackr/dual-piecepacks-pnp.html</a>.</p>
</dd>
<dt>playing_cards_expansion</dt><dd><p>A piecepack with the standard &ldquo;French&rdquo; playing card suits.
See <a href="https://www.ludism.org/ppwiki/PlayingCardsExpansion">https://www.ludism.org/ppwiki/PlayingCardsExpansion</a>.</p>
</dd>
<dt>hexpack</dt><dd><p>A hexagonal extrapolation of the piecepack designed by Nathan Morse and Daniel Wilcox.
See <a href="https://boardgamegeek.com/boardgameexpansion/35424/hexpack">https://boardgamegeek.com/boardgameexpansion/35424/hexpack</a>.</p>
</dd>
<dt>subpack</dt><dd><p>A mini piecepack.  Designed to be used with the <code>piecepack</code> to make piecepack
&ldquo;stackpack&rdquo; diagrams.  See <a href="https://www.ludism.org/ppwiki/StackPack">https://www.ludism.org/ppwiki/StackPack</a>.</p>
</dd>
</dl>
</dd>
<dt>playing_cards, playing_cards_colored, playing_cards_tarot</dt><dd>
<p>Poker-sized <code>card</code> components for various playing card decks:</p>

<dl>
<dt>playing_cards</dt><dd><p>A traditional deck of playing cards with 4 suits
and 13 ranks (A, 2-10, J, Q, K) plus a 14th &ldquo;Joker&rdquo; rank.</p>
</dd>
<dt>playing_cards_colored</dt><dd><p>Like <code>playing_cards</code> but with five colored suits:
red hearts, black spades, green clubs, blue diamonds, and yellow stars.</p>
</dd>
<dt>playing_cards_tarot</dt><dd><p>A (French Bourgeois) deck of tarot playing cards:
first four suits are hearts, spades, clubs, and diamonds with
14 ranks (ace through jack, knight, queen, king) plus a 15th &ldquo;Joker&rdquo; rank
and a fifth &quot;suit&quot; of 22 trump cards (1-21 plus an &ldquo;excuse&rdquo;).</p>
</dd></dl>
</dd>
<dt>reversi</dt><dd><p>Boards and pieces for Reversi.
&quot;board_face&quot; provides lined boards with colored backgrounds.
&quot;board_back&quot; provides checkered boards.
&quot;bit_face&quot; / &quot;bit_back&quot; provides circular game tokens with differently colored sides:
red paired with green, black paired with white, and blue paired with yellow.
</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+pp_cfg">pp_cfg</a></code> for information about the <code>pp_cfg</code> objects returned by <code>game_systems</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cfgs &lt;- game_systems(pawn = "joystick")
names(cfgs)

# May take more than 5 seconds on CRAN servers
# standard dice, meeples, and joystick pawns
if (requireNamespace("grid", quietly = TRUE) &amp;&amp; piecepackr:::device_supports_unicode()) {
   opt &lt;- options(piecepackr.at.inform = FALSE)
   grid::grid.newpage()
   dice &lt;-  c("d4", "numeral", "d8", "d10", "d12", "d20")
   cfg &lt;- paste0("dice_", dice)
   grid.piece("die_face", suit = c(1:6, 1), rank = 1:6,
              cfg = cfg, envir = cfgs, x = 1:6, y = 1,
              default.units = "in", op_scale = 0.5)
   grid.piece("die_face", rank=1:6, suit=1:6,
              x=1:6, y=2, default.units="in",
              op_scale=0.5, cfg=cfgs$dice)
   grid.piece("bit_face", suit=1:6,
              x=1:6, y=3, default.units="in",
              op_scale=0.5, cfg=cfgs$meeple)
   grid.piece("pawn_top", suit=1:6,
              x=1:6, y=4, default.units="in",
              op_scale=0.5, cfg=cfgs$piecepack)
   options(opt)
}

# dominoes
if (requireNamespace("grid", quietly = TRUE)) {
   grid::grid.newpage()
   colors &lt;- c("black", "red", "green", "blue", "yellow", "white")
   cfg &lt;- paste0("dominoes_", rep(colors, 2))
   grid.piece("tile_face",  suit=1:12, rank=1:12+1,
              cfg=cfg, envir=cfgs,
              x=rep(6:1, 2), y=rep(2*2:1, each=6),
              default.units="in", op_scale=0.5)
}
# piecepack "playing card expansion"
if (requireNamespace("grid", quietly = TRUE) &amp;&amp; piecepackr:::device_supports_unicode()) {
   grid::grid.newpage()
   df_tiles &lt;- data.frame(piece_side="tile_back",
                          x=0.5+c(3,1,3,1), y=0.5+c(3,3,1,1),
                          suit=NA, angle=NA, z=1/8,
                          stringsAsFactors=FALSE)
   df_coins &lt;- data.frame(piece_side="coin_back",
                          x=rep(4:1, 4), y=rep(4:1, each=4),
                          suit=c(1,4,1,4,4,1,4,1,2,3,2,3,3,2,3,2),
                          angle=rep(c(180,0), each=8), z=1/4+1/16,
                          stringsAsFactors=FALSE)
   df &lt;- rbind(df_tiles, df_coins)
   pmap_piece(df, cfg = cfgs$playing_cards_expansion, op_scale=0.5,
              default.units="in")
}
</code></pre>

<hr>
<h2 id='geom_piece'>Draw board game pieces with ggplot2</h2><span id='topic+geom_piece'></span><span id='topic+aes_piece'></span>

<h3>Description</h3>

<p><code>geom_piece()</code> creates a <code>ggplot2</code> geom.
<code>aes_piece()</code> takes a data frame and generates
an appropriate <code>ggplot2::aes()</code> mapping.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_piece(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  envir = getOption("piecepackr.envir", piecepackr::game_systems()),
  op_scale = getOption("piecepackr.op_scale", 0),
  op_angle = getOption("piecepackr.op_angle", 45),
  inherit.aes = TRUE
)

aes_piece(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_piece_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_piece_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_piece_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_piece_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_piece_+3A_...">...</code></td>
<td>
<p>Aesthetics, used to set an aesthetic to a fixed value.</p>
</td></tr>
<tr><td><code id="geom_piece_+3A_envir">envir</code></td>
<td>
<p>Environment (or named list) containing configuration list(s).</p>
</td></tr>
<tr><td><code id="geom_piece_+3A_op_scale">op_scale</code></td>
<td>
<p>How much to scale the depth of the piece in the oblique projection
(viewed from the top of the board).
<code>0</code> (the default) leads to an &ldquo;orthographic&rdquo; projection,
<code>0.5</code> is the most common scale used in the &ldquo;cabinet&rdquo; projection,
and <code>1.0</code> is the scale used in the &ldquo;cavalier&rdquo; projection.</p>
</td></tr>
<tr><td><code id="geom_piece_+3A_op_angle">op_angle</code></td>
<td>
<p>What is the angle of the oblique projection?  Has no effect if <code>op_scale</code> is <code>0</code>.</p>
</td></tr>
<tr><td><code id="geom_piece_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_piece_+3A_df">df</code></td>
<td>
<p>A data frame of game piece information with (at least) the
named columns &ldquo;piece_side&rdquo;, &ldquo;x&rdquo;, and &ldquo;y&rdquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>geom_piece()</code> requires a fixed scale coordinate system with an aspect
ratio of 1 as provided by <code>ggplot2::coord_fixed()</code>.
<code>geom_piece()</code> also requires that <code>cfg</code> is a character vector (and not a <code>pp_cfg()</code> object).
In particular if using <code>op_transform()</code> one should set its argument <code>cfg_class = "character"</code>
if intending for use with <code>geom_piece()</code>.
</p>


<h3>Aesthetics</h3>

<p><code>geom_piece()</code> understands the following aesthetics (required aesthetics are in bold).
See <code><a href="#topic+pieceGrob">pieceGrob()</a></code> for more details.
</p>

<ul>
<li> <p><strong><code>x</code></strong>
</p>
</li>
<li> <p><strong><code>y</code></strong>
</p>
</li>
<li> <p><code>z</code>
</p>
</li>
<li> <p><code>piece_side</code>
</p>
</li>
<li> <p><code>rank</code>
</p>
</li>
<li> <p><code>suit</code>
</p>
</li>
<li> <p><code>cfg</code>
</p>
</li>
<li> <p><code>width</code>
</p>
</li>
<li> <p><code>height</code>
</p>
</li>
<li> <p><code>depth</code>
</p>
</li>
<li> <p><code>angle</code>
</p>
</li>
<li> <p><code>scale</code>
</p>
</li>
<li> <p><code>type</code>
</p>
</li></ul>



<h3>See Also</h3>

<p><code>geom_piece()</code> is a wrapper around <code><a href="#topic+pieceGrob">pieceGrob()</a></code>.
<code><a href="#topic+scale_x_piece">scale_x_piece()</a></code> and <code><a href="#topic+scale_y_piece">scale_y_piece()</a></code> are wrappers
around <code><a href="ggplot2.html#topic+scale_continuous">ggplot2::scale_x_continuous()</a></code> and <code><a href="ggplot2.html#topic+scale_continuous">ggplot2::scale_y_continuous()</a></code>
with better defaults for board game diagrams.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("ggplot2", quietly = TRUE) &amp;&amp; require("tibble", quietly = TRUE)) {
  envir &lt;- game_systems("sans")
  df_board &lt;- tibble(piece_side = "board_face", suit = 3, rank = 8,
                 x = 4.5, y = 4.5)
  df_w &lt;- tibble(piece_side = "bit_face", suit = 6, rank = 1,
                 x = rep(1:8, 2), y = rep(1:2, each=8))
  df_b &lt;- tibble(piece_side = "bit_face", suit = 1, rank = 1,
                 x = rep(1:8, 2), y = rep(7:8, each=8))
  df &lt;- rbind(df_board, df_w, df_b)
  # 2D example
  # `cfg` must be a character vector for `geom_piece()`
  ggplot(df, aes_piece(df)) +
      geom_piece(cfg = "checkers1", envir = envir) +
      coord_fixed() +
      scale_x_piece() +
      scale_y_piece() +
      theme_minimal(28) +
      theme(panel.grid = element_blank())
}
if (require("ggplot2", quietly = TRUE) &amp;&amp; require("tibble", quietly = TRUE)) {
  # 3D "oblique" projection example
  # `cfg_class` must be "character" when using with `geom_piece()`
  df3d &lt;- op_transform(df, cfg = "checkers1", envir = envir,
                       op_angle = 45, cfg_class = "character")
  ggplot(df3d, aes_piece(df3d)) +
      geom_piece(cfg = "checkers1", envir = envir,
                 op_angle = 45, op_scale = 0.5) +
      coord_fixed() +
      theme_void()
}
</code></pre>

<hr>
<h2 id='grid.cropmark'>Crop Mark Grob</h2><span id='topic+grid.cropmark'></span><span id='topic+cropmarkGrob'></span>

<h3>Description</h3>

<p><code>grid.cropmark()</code> draws &ldquo;crop marks&rdquo; to the active graphics device.
<code>cropmarkGrob()</code> is its grid grob counterpart.
Intended for use in adding crop marks around
game pieces in print-and-play layouts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cropmarkGrob(
  ...,
  piece_side = "tile_back",
  suit = NA,
  rank = NA,
  cfg = getOption("piecepackr.cfg", pp_cfg()),
  x = unit(0.5, "npc"),
  y = unit(0.5, "npc"),
  angle = 0,
  width = NA,
  height = NA,
  scale = 1,
  default.units = "npc",
  envir = getOption("piecepackr.envir"),
  name = NULL,
  gp = NULL,
  vp = NULL,
  bleed = unit(0.125, "in"),
  cm_select = "12345678",
  cm_width = unit(0.25, "mm"),
  cm_length = unit(0.125, "in")
)

grid.cropmark(..., draw = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.cropmark_+3A_...">...</code></td>
<td>
<p><code>cropmarkGrob()</code> ignores; <code>grid.cropmark()</code> passes to <code>cropmarkGrob()</code>.</p>
</td></tr>
<tr><td><code id="grid.cropmark_+3A_piece_side">piece_side</code></td>
<td>
<p>A string with piece and side separated by a underscore e.g. &quot;coin_face&quot;</p>
</td></tr>
<tr><td><code id="grid.cropmark_+3A_suit">suit</code></td>
<td>
<p>Number of suit (starting from 1).</p>
</td></tr>
<tr><td><code id="grid.cropmark_+3A_rank">rank</code></td>
<td>
<p>Number of rank (starting from 1)</p>
</td></tr>
<tr><td><code id="grid.cropmark_+3A_cfg">cfg</code></td>
<td>
<p>Piecepack configuration list or <code>pp_cfg</code> object,
a list of <code>pp_cfg</code> objects,
or a character vector referring to names in <code>envir</code>
or a character vector referring to object names that
can be retrieved by <code>base::dynGet()</code>.</p>
</td></tr>
<tr><td><code id="grid.cropmark_+3A_x">x</code></td>
<td>
<p>Where to place piece on x axis of viewport</p>
</td></tr>
<tr><td><code id="grid.cropmark_+3A_y">y</code></td>
<td>
<p>Where to place piece on y axis of viewport</p>
</td></tr>
<tr><td><code id="grid.cropmark_+3A_angle">angle</code></td>
<td>
<p>Angle (on xy plane) to draw piece at</p>
</td></tr>
<tr><td><code id="grid.cropmark_+3A_width">width</code></td>
<td>
<p>Width of piece</p>
</td></tr>
<tr><td><code id="grid.cropmark_+3A_height">height</code></td>
<td>
<p>Height of piece</p>
</td></tr>
<tr><td><code id="grid.cropmark_+3A_scale">scale</code></td>
<td>
<p>Multiplicative scaling factor to apply to width, height, and depth.</p>
</td></tr>
<tr><td><code id="grid.cropmark_+3A_default.units">default.units</code></td>
<td>
<p>A string indicating the default units to use if
'x', 'y', 'width', and/or 'height' are only given as numeric vectors.</p>
</td></tr>
<tr><td><code id="grid.cropmark_+3A_envir">envir</code></td>
<td>
<p>Environment (or named list) containing configuration list(s).</p>
</td></tr>
<tr><td><code id="grid.cropmark_+3A_name">name</code></td>
<td>
<p>A character identifier (for grid)</p>
</td></tr>
<tr><td><code id="grid.cropmark_+3A_gp">gp</code></td>
<td>
<p>An object of class &ldquo;gpar&rdquo;.</p>
</td></tr>
<tr><td><code id="grid.cropmark_+3A_vp">vp</code></td>
<td>
<p>A <code>grid</code> viewport object (or <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="grid.cropmark_+3A_bleed">bleed</code></td>
<td>
<p>Bleed zone size to assume:
</p>

<ul>
<li><p>If <code>bleed</code> is a <code><a href="grid.html#topic+unit">grid::unit()</a></code> simply use it
</p>
</li>
<li><p>If <code>bleed</code> is numeric then convert via <code>grid::unit(bleed, default.units)</code>
</p>
</li>
<li><p>If <code>bleed</code> is <code>TRUE</code> assume 1/8 inch bleed zone size
</p>
</li>
<li><p>If <code>bleed</code> is <code>FALSE</code> assume 0 inch bleed zone size
</p>
</li></ul>
</td></tr>
<tr><td><code id="grid.cropmark_+3A_cm_select">cm_select</code></td>
<td>
<p>A string of integers from &quot;1&quot; to &quot;8&quot; indicating which
crop marks to draw.  &quot;1&quot; represents the top right crop mark
then we proceeding clockwise to &quot;8&quot; which represents the
top left crop mark.
Default &quot;12345678&quot; draws all eight crop marks.</p>
</td></tr>
<tr><td><code id="grid.cropmark_+3A_cm_width">cm_width</code></td>
<td>
<p>Width of crop mark.</p>
</td></tr>
<tr><td><code id="grid.cropmark_+3A_cm_length">cm_length</code></td>
<td>
<p>Length of crop mark.</p>
</td></tr>
<tr><td><code id="grid.cropmark_+3A_draw">draw</code></td>
<td>
<p>A logical value indicating whether graphics output should be produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A grid grob.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("grid", quietly = TRUE) &amp;&amp; piecepackr:::device_supports_unicode()) {
  cfg &lt;- pp_cfg(list(mat_color = "pink", mat_width=0.05, border_color=NA))
  grid::grid.newpage()
  df &lt;- data.frame(piece_side = "tile_face", suit = 2, rank = 2,
                   x = 2, y = 2, angle = 0,
                   stringsAsFactors = FALSE)
  pmap_piece(df, grid.cropmark, cfg = cfg, default.units = "in")
  pmap_piece(df, grid.piece, cfg = cfg, default.units = "in", bleed=TRUE)
}
if (requireNamespace("grid", quietly = TRUE) &amp;&amp; piecepackr:::device_supports_unicode()) {
  grid::grid.newpage()
  df &lt;- data.frame(piece_side = "coin_back", suit = 2, rank = 2,
                   x = 2, y = 2, angle = 0,
                   stringsAsFactors = FALSE)
  pmap_piece(df, grid.cropmark, cfg = cfg, default.units = "in", bleed=TRUE)
  pmap_piece(df, grid.piece, cfg = cfg, default.units = "in", bleed=TRUE)
}
</code></pre>

<hr>
<h2 id='grid.piece'>Draw board game pieces with grid</h2><span id='topic+grid.piece'></span><span id='topic+pieceGrob'></span>

<h3>Description</h3>

<p><code>grid.piece()</code> draws board game pieces onto the graphics device.
<code>pieceGrob()</code> is its <code>grid</code> &ldquo;grob&rdquo; counterpart.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pieceGrob(
  piece_side = "tile_back",
  suit = NA,
  rank = NA,
  cfg = getOption("piecepackr.cfg", pp_cfg()),
  x = unit(0.5, "npc"),
  y = unit(0.5, "npc"),
  z = NA,
  angle = 0,
  ...,
  width = NA,
  height = NA,
  depth = NA,
  op_scale = getOption("piecepackr.op_scale", 0),
  op_angle = getOption("piecepackr.op_angle", 45),
  default.units = getOption("piecepackr.default.units", "npc"),
  envir = getOption("piecepackr.envir"),
  name = NULL,
  gp = NULL,
  vp = NULL,
  scale = 1,
  alpha = 1,
  type = "normal",
  bleed = FALSE
)

grid.piece(
  piece_side = "tile_back",
  suit = NA,
  rank = NA,
  cfg = getOption("piecepackr.cfg", pp_cfg()),
  x = unit(0.5, "npc"),
  y = unit(0.5, "npc"),
  z = NA,
  angle = 0,
  ...,
  width = NA,
  height = NA,
  depth = NA,
  op_scale = getOption("piecepackr.op_scale", 0),
  op_angle = getOption("piecepackr.op_angle", 45),
  default.units = getOption("piecepackr.default.units", "npc"),
  envir = getOption("piecepackr.envir"),
  name = NULL,
  gp = NULL,
  draw = TRUE,
  vp = NULL,
  scale = 1,
  alpha = 1,
  type = "normal",
  bleed = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.piece_+3A_piece_side">piece_side</code></td>
<td>
<p>A string with piece and side separated by a underscore e.g. &quot;coin_face&quot;</p>
</td></tr>
<tr><td><code id="grid.piece_+3A_suit">suit</code></td>
<td>
<p>Number of suit (starting from 1).</p>
</td></tr>
<tr><td><code id="grid.piece_+3A_rank">rank</code></td>
<td>
<p>Number of rank (starting from 1)</p>
</td></tr>
<tr><td><code id="grid.piece_+3A_cfg">cfg</code></td>
<td>
<p>Piecepack configuration list or <code>pp_cfg</code> object,
a list of <code>pp_cfg</code> objects,
or a character vector referring to names in <code>envir</code>
or a character vector referring to object names that
can be retrieved by <code>base::dynGet()</code>.</p>
</td></tr>
<tr><td><code id="grid.piece_+3A_x">x</code></td>
<td>
<p>Where to place piece on x axis of viewport</p>
</td></tr>
<tr><td><code id="grid.piece_+3A_y">y</code></td>
<td>
<p>Where to place piece on y axis of viewport</p>
</td></tr>
<tr><td><code id="grid.piece_+3A_z">z</code></td>
<td>
<p>z-coordinate of the piece.  Has no effect if <code>op_scale</code> is <code>0</code>.</p>
</td></tr>
<tr><td><code id="grid.piece_+3A_angle">angle</code></td>
<td>
<p>Angle (on xy plane) to draw piece at</p>
</td></tr>
<tr><td><code id="grid.piece_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="grid.piece_+3A_width">width</code></td>
<td>
<p>Width of piece</p>
</td></tr>
<tr><td><code id="grid.piece_+3A_height">height</code></td>
<td>
<p>Height of piece</p>
</td></tr>
<tr><td><code id="grid.piece_+3A_depth">depth</code></td>
<td>
<p>Depth (thickness) of piece.  Has no effect if <code>op_scale</code> is <code>0</code>.</p>
</td></tr>
<tr><td><code id="grid.piece_+3A_op_scale">op_scale</code></td>
<td>
<p>How much to scale the depth of the piece in the oblique projection
(viewed from the top of the board).
<code>0</code> (the default) leads to an &ldquo;orthographic&rdquo; projection,
<code>0.5</code> is the most common scale used in the &ldquo;cabinet&rdquo; projection,
and <code>1.0</code> is the scale used in the &ldquo;cavalier&rdquo; projection.</p>
</td></tr>
<tr><td><code id="grid.piece_+3A_op_angle">op_angle</code></td>
<td>
<p>What is the angle of the oblique projection?  Has no effect if <code>op_scale</code> is <code>0</code>.</p>
</td></tr>
<tr><td><code id="grid.piece_+3A_default.units">default.units</code></td>
<td>
<p>A string indicating the default units to use if
'x', 'y', 'width', and/or 'height' are only given as numeric vectors.</p>
</td></tr>
<tr><td><code id="grid.piece_+3A_envir">envir</code></td>
<td>
<p>Environment (or named list) containing configuration list(s).</p>
</td></tr>
<tr><td><code id="grid.piece_+3A_name">name</code></td>
<td>
<p>A character identifier (for grid)</p>
</td></tr>
<tr><td><code id="grid.piece_+3A_gp">gp</code></td>
<td>
<p>An object of class &ldquo;gpar&rdquo;.</p>
</td></tr>
<tr><td><code id="grid.piece_+3A_vp">vp</code></td>
<td>
<p>A <code>grid</code> viewport object (or <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="grid.piece_+3A_scale">scale</code></td>
<td>
<p>Multiplicative scaling factor to apply to width, height, and depth.</p>
</td></tr>
<tr><td><code id="grid.piece_+3A_alpha">alpha</code></td>
<td>
<p>Alpha channel for transparency.</p>
</td></tr>
<tr><td><code id="grid.piece_+3A_type">type</code></td>
<td>
<p>Type of grid grob to use.  Either <code>"normal"</code> (default), <code>"picture"</code>, <code>"raster"</code>, or <code>"transformation"</code>.
<code>"picture"</code> exports to (temporary) svg and re-imports as a <code>grImport2::pictureGrob</code>.
<code>"raster"</code> exports to (temporary) png and re-imports as a <code>grid::rasterGrob</code>.
<code>"transformation"</code> uses the affine transformation feature only supported in
R 4.2+ within select graphic devices.
The latter three can be useful if drawing pieces really big or small and don't want
to mess with re-configuring fontsizes and linewidths.</p>
</td></tr>
<tr><td><code id="grid.piece_+3A_bleed">bleed</code></td>
<td>
<p>If <code>FALSE</code> do not add a &ldquo;bleed&rdquo; zone around the piece,
otherwise add a &ldquo;bleed&rdquo; zone around the piece:</p>

<ul>
<li><p>If <code>bleed</code> is <code>TRUE</code> we will add 1/8 inch bleeds
</p>
</li>
<li><p>If <code>bleed</code> is a <code><a href="grid.html#topic+unit">grid::unit()</a></code> we will use it as bleed size
</p>
</li>
<li><p>If <code>bleed</code> is numeric we will convert to <code><a href="grid.html#topic+unit">grid::unit()</a></code> via <code>grid::unit(bleed, default.units)</code>
</p>
</li></ul>

<p>A non-<code>FALSE</code> <code>bleed</code> is incompatible with <code>op_scale &gt; 0</code> (drawing in an &ldquo;oblique projection&rdquo;).</p>
</td></tr>
<tr><td><code id="grid.piece_+3A_draw">draw</code></td>
<td>
<p>A logical value indicating whether graphics output should be produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>grid</code> grob object.  If <code>draw</code> is <code>TRUE</code> then as a side effect
<code>grid.piece()</code> will also draw it to the graphics device.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pmap_piece">pmap_piece()</a></code> which applies <code>pieceGrob()</code> over rows of a data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  if (requireNamespace("grid", quietly = TRUE) &amp;&amp; piecepackr:::device_supports_unicode()) {
    opt &lt;- options(piecepackr.at.inform = FALSE)
    on.exit(options(opt))

    draw_pp_diagram &lt;- function(cfg=pp_cfg(), op_scale=0) {
        g.p &lt;- function(...) {
            grid.piece(..., op_scale=op_scale, cfg=cfg, default.units="in")
        }
        g.p("tile_back", x=0.5+c(3,1,3,1), y=0.5+c(3,3,1,1))
        g.p("tile_back", x=0.5+3, y=0.5+1, z=1/4+1/8)
        g.p("tile_back", x=0.5+3, y=0.5+1, z=2/4+1/8)
        g.p("die_face", suit=3, rank=5, x=1, y=1, z=1/4+1/4)
        g.p("pawn_face", x=1, y=4, z=1/4+1/2, angle=90)
        g.p("coin_back", x=3, y=4, z=1/4+1/16, angle=180)
        g.p("coin_back", suit=4, x=3, y=4, z=1/4+1/8+1/16, angle=180)
        g.p("coin_back", suit=2, x=3, y=1, z=3/4+1/8, angle=90)
    }

    # default piecepack, orthogonal projection
    draw_pp_diagram(cfg=pp_cfg())
  }
  if (requireNamespace("grid", quietly = TRUE) &amp;&amp; piecepackr:::device_supports_unicode()) {
    # custom configuration, orthogonal projection
    grid::grid.newpage()
    dark_colorscheme &lt;- list(suit_color="darkred,black,darkgreen,darkblue,black",
                         invert_colors.suited=TRUE, border_color="black", border_lex=2)
    traditional_ranks &lt;- list(use_suit_as_ace=TRUE, rank_text=",a,2,3,4,5")
    cfg &lt;- c(dark_colorscheme, traditional_ranks)
    draw_pp_diagram(cfg=pp_cfg(cfg))
  }
  if (requireNamespace("grid", quietly = TRUE) &amp;&amp; piecepackr:::device_supports_unicode()) {
    # custom configuration, oblique projection
    grid::grid.newpage()
    cfg3d &lt;- list(width.pawn=0.75, height.pawn=0.75, depth.pawn=1,
                       dm_text.pawn="", shape.pawn="convex6", invert_colors.pawn=TRUE,
                       edge_color.coin="tan", edge_color.tile="tan")
    cfg &lt;- pp_cfg(c(cfg, cfg3d))
    draw_pp_diagram(cfg=pp_cfg(cfg), op_scale=0.5)
  }
</code></pre>

<hr>
<h2 id='op_transform'>Oblique projection helper function</h2><span id='topic+op_transform'></span>

<h3>Description</h3>

<p>Guesses <code>z</code> coordinates and
sorting order to more easily
make 3D graphics with <code>pmap_piece</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>op_transform(
  df,
  ...,
  cfg = getOption("piecepackr.cfg", pp_cfg()),
  envir = getOption("piecepackr.envir"),
  op_angle = getOption("piecepackr.op_angle", 45),
  pt_thickness = 0.01,
  as_top = character(0),
  cfg_class = "list"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="op_transform_+3A_df">df</code></td>
<td>
<p>A data frame with coordinates and dimensions in inches</p>
</td></tr>
<tr><td><code id="op_transform_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
<tr><td><code id="op_transform_+3A_cfg">cfg</code></td>
<td>
<p>Piecepack configuration list or <code>pp_cfg</code> object,
a list of <code>pp_cfg</code> objects,
or a character vector of <code>pp_cfg</code> objects</p>
</td></tr>
<tr><td><code id="op_transform_+3A_envir">envir</code></td>
<td>
<p>Environment (or named list) containing configuration list(s).</p>
</td></tr>
<tr><td><code id="op_transform_+3A_op_angle">op_angle</code></td>
<td>
<p>Intended oblique projection angle (used for re-sorting)</p>
</td></tr>
<tr><td><code id="op_transform_+3A_pt_thickness">pt_thickness</code></td>
<td>
<p>Thickness of pyramid tip i.e. value to add to the z-value of a pyramid top
if it is a (weakly) smaller ranked pyramid (top)
placed on top of a larger ranked pyramid (top).</p>
</td></tr>
<tr><td><code id="op_transform_+3A_as_top">as_top</code></td>
<td>
<p>Character vector of components whose &ldquo;side&rdquo;
should be converted to &ldquo;top&rdquo; e.g. <code>c("pawn_face")</code>.</p>
</td></tr>
<tr><td><code id="op_transform_+3A_cfg_class">cfg_class</code></td>
<td>
<p>Either <code>"list"</code> (default) or <code>"character"</code>.
Desired class of the <code>cfg</code> column in the returned tibble.
<code>"list"</code> is more efficient for use with <code>pmap_piece()</code> but
<code>geom_piece()</code> needs <code>"character"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The heuristics used to generate guesses
for <code>z</code> coordinates and sorting order
aren't guaranteed to work in every case.
In some cases you may get better sorting results
by changing the <code>op_angle</code> or the dimensions of pieces.
</p>


<h3>Value</h3>

<p>A tibble with extra columns added
and re-sorted rows
</p>


<h3>See Also</h3>

<p><a href="https://trevorldavis.com/piecepackr/3d-projections.html">https://trevorldavis.com/piecepackr/3d-projections.html</a> for more details
and examples of oblique projections in <code>piecepackr</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- tibble::tibble(piece_side="tile_back",
                     x=c(2,2,2,4,6,6,4,2,5),
                     y=c(4,4,4,4,4,2,2,2,3))
cfg &lt;- game_systems()$piecepack
pmap_piece(df, op_angle=135, trans=op_transform,
           op_scale=0.5, default.units="in", cfg=cfg)
</code></pre>

<hr>
<h2 id='piece'>Create rayrender board game piece objects</h2><span id='topic+piece'></span>

<h3>Description</h3>

<p><code>piece</code> creates 3d board game piece objects for use with the rayrender package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>piece(
  piece_side = "tile_back",
  suit = NA,
  rank = NA,
  cfg = getOption("piecepackr.cfg", pp_cfg()),
  x = 0,
  y = 0,
  z = NA,
  angle = 0,
  axis_x = 0,
  axis_y = 0,
  width = NA,
  height = NA,
  depth = NA,
  envir = getOption("piecepackr.envir"),
  ...,
  scale = 1,
  res = 72
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="piece_+3A_piece_side">piece_side</code></td>
<td>
<p>A string with piece and side separated by a underscore e.g. &quot;coin_face&quot;</p>
</td></tr>
<tr><td><code id="piece_+3A_suit">suit</code></td>
<td>
<p>Number of suit (starting from 1).</p>
</td></tr>
<tr><td><code id="piece_+3A_rank">rank</code></td>
<td>
<p>Number of rank (starting from 1)</p>
</td></tr>
<tr><td><code id="piece_+3A_cfg">cfg</code></td>
<td>
<p>Piecepack configuration list or <code>pp_cfg</code> object,
a list of <code>pp_cfg</code> objects,
or a character vector referring to names in <code>envir</code>
or a character vector referring to object names that
can be retrieved by <code>base::dynGet()</code>.</p>
</td></tr>
<tr><td><code id="piece_+3A_x">x</code></td>
<td>
<p>Where to place piece on x axis of viewport</p>
</td></tr>
<tr><td><code id="piece_+3A_y">y</code></td>
<td>
<p>Where to place piece on y axis of viewport</p>
</td></tr>
<tr><td><code id="piece_+3A_z">z</code></td>
<td>
<p>z-coordinate of the piece.  Has no effect if <code>op_scale</code> is <code>0</code>.</p>
</td></tr>
<tr><td><code id="piece_+3A_angle">angle</code></td>
<td>
<p>Angle (on xy plane) to draw piece at</p>
</td></tr>
<tr><td><code id="piece_+3A_axis_x">axis_x</code></td>
<td>
<p>First coordinate of the axis unit vector.</p>
</td></tr>
<tr><td><code id="piece_+3A_axis_y">axis_y</code></td>
<td>
<p>Second coordinate of the axis unit vector.</p>
</td></tr>
<tr><td><code id="piece_+3A_width">width</code></td>
<td>
<p>Width of piece</p>
</td></tr>
<tr><td><code id="piece_+3A_height">height</code></td>
<td>
<p>Height of piece</p>
</td></tr>
<tr><td><code id="piece_+3A_depth">depth</code></td>
<td>
<p>Depth (thickness) of piece.  Has no effect if <code>op_scale</code> is <code>0</code>.</p>
</td></tr>
<tr><td><code id="piece_+3A_envir">envir</code></td>
<td>
<p>Environment (or named list) containing configuration list(s).</p>
</td></tr>
<tr><td><code id="piece_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="piece_+3A_scale">scale</code></td>
<td>
<p>Multiplicative scaling factor to apply to width, height, and depth.</p>
</td></tr>
<tr><td><code id="piece_+3A_res">res</code></td>
<td>
<p>Resolution of the faces.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A rayrender object.
</p>


<h3>See Also</h3>

<p>See <a href="https://www.rayrender.net">https://www.rayrender.net</a> for more information about the <code>rayrender</code> package.
See <code><a href="#topic+geometry_utils">geometry_utils</a></code> for a discussion of the 3D rotation parameterization.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # May take more than 5 seconds on CRAN servers
  opt &lt;- options(cores = getOption("Ncpus"))
  cfg &lt;- game_systems("sans3d")$piecepack
  if (requireNamespace("rayrender", quietly = TRUE) &amp;&amp; all(capabilities(c("cairo", "png")))) {
      rayrender::render_scene(piece("tile_face", suit = 3, rank = 3, cfg = cfg))
  }
  if (requireNamespace("rayrender", quietly = TRUE) &amp;&amp; all(capabilities(c("cairo", "png")))) {
      rayrender::render_scene(piece("coin_back", suit = 4, rank = 2, cfg = cfg))
  }
  if (requireNamespace("rayrender", quietly = TRUE) &amp;&amp; all(capabilities(c("cairo", "png")))) {
      rayrender::render_scene(piece("pawn_face", suit = 2, cfg = cfg))
  }
  options(opt)
  
</code></pre>

<hr>
<h2 id='piece_mesh'>Create rayvertex board game piece objects</h2><span id='topic+piece_mesh'></span>

<h3>Description</h3>

<p><code>piece_mesh()</code> creates 3d board game piece objects for use with the rayvertex package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>piece_mesh(
  piece_side = "tile_back",
  suit = NA,
  rank = NA,
  cfg = pp_cfg(),
  x = 0,
  y = 0,
  z = NA,
  angle = 0,
  axis_x = 0,
  axis_y = 0,
  width = NA,
  height = NA,
  depth = NA,
  envir = NULL,
  ...,
  scale = 1,
  res = 72
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="piece_mesh_+3A_piece_side">piece_side</code></td>
<td>
<p>A string with piece and side separated by a underscore e.g. &quot;coin_face&quot;</p>
</td></tr>
<tr><td><code id="piece_mesh_+3A_suit">suit</code></td>
<td>
<p>Number of suit (starting from 1).</p>
</td></tr>
<tr><td><code id="piece_mesh_+3A_rank">rank</code></td>
<td>
<p>Number of rank (starting from 1)</p>
</td></tr>
<tr><td><code id="piece_mesh_+3A_cfg">cfg</code></td>
<td>
<p>Piecepack configuration list or <code>pp_cfg</code> object,
a list of <code>pp_cfg</code> objects,
or a character vector referring to names in <code>envir</code>
or a character vector referring to object names that
can be retrieved by <code>base::dynGet()</code>.</p>
</td></tr>
<tr><td><code id="piece_mesh_+3A_x">x</code></td>
<td>
<p>Where to place piece on x axis of viewport</p>
</td></tr>
<tr><td><code id="piece_mesh_+3A_y">y</code></td>
<td>
<p>Where to place piece on y axis of viewport</p>
</td></tr>
<tr><td><code id="piece_mesh_+3A_z">z</code></td>
<td>
<p>z-coordinate of the piece.  Has no effect if <code>op_scale</code> is <code>0</code>.</p>
</td></tr>
<tr><td><code id="piece_mesh_+3A_angle">angle</code></td>
<td>
<p>Angle (on xy plane) to draw piece at</p>
</td></tr>
<tr><td><code id="piece_mesh_+3A_axis_x">axis_x</code></td>
<td>
<p>First coordinate of the axis unit vector.</p>
</td></tr>
<tr><td><code id="piece_mesh_+3A_axis_y">axis_y</code></td>
<td>
<p>Second coordinate of the axis unit vector.</p>
</td></tr>
<tr><td><code id="piece_mesh_+3A_width">width</code></td>
<td>
<p>Width of piece</p>
</td></tr>
<tr><td><code id="piece_mesh_+3A_height">height</code></td>
<td>
<p>Height of piece</p>
</td></tr>
<tr><td><code id="piece_mesh_+3A_depth">depth</code></td>
<td>
<p>Depth (thickness) of piece.  Has no effect if <code>op_scale</code> is <code>0</code>.</p>
</td></tr>
<tr><td><code id="piece_mesh_+3A_envir">envir</code></td>
<td>
<p>Environment (or named list) containing configuration list(s).</p>
</td></tr>
<tr><td><code id="piece_mesh_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="piece_mesh_+3A_scale">scale</code></td>
<td>
<p>Multiplicative scaling factor to apply to width, height, and depth.</p>
</td></tr>
<tr><td><code id="piece_mesh_+3A_res">res</code></td>
<td>
<p>Resolution of the faces.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A rayvertex object.
</p>


<h3>See Also</h3>

<p>See <a href="https://www.rayvertex.com">https://www.rayvertex.com</a> for more information about the <code>rayvertex</code> package.
See <code><a href="#topic+geometry_utils">geometry_utils</a></code> for a discussion of the 3D rotation parameterization.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # May take more than 5 seconds on CRAN servers
  if (requireNamespace("rayvertex", quietly = TRUE) &amp;&amp; all(capabilities(c("cairo", "png")))) {
      cfg &lt;- game_systems("sans3d")$piecepack
      rs &lt;- function(shape) {
           opt &lt;- options(cores = getOption("Ncpus"))
           light &lt;- rayvertex::directional_light(c(0, 0, 1))
           rayvertex::rasterize_scene(shape, light_info = light)
           options(opt)
      }
      rs(piece_mesh("tile_face", suit = 3, rank = 3, cfg = cfg))
  }
  if (requireNamespace("rayvertex", quietly = TRUE) &amp;&amp; all(capabilities(c("cairo", "png")))) {
      rs(piece_mesh("coin_back", suit = 4, rank = 2, cfg = cfg))
  }
  if (requireNamespace("rayvertex", quietly = TRUE) &amp;&amp; all(capabilities(c("cairo", "png")))) {
      rs(piece_mesh("pawn_face", suit = 1, cfg = cfg))
  }
  
</code></pre>

<hr>
<h2 id='piece3d'>Render board game pieces with rgl</h2><span id='topic+piece3d'></span>

<h3>Description</h3>

<p><code>piece3d</code> draws board games pieces using the rgl package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>piece3d(
  piece_side = "tile_back",
  suit = NA,
  rank = NA,
  cfg = getOption("piecepackr.cfg", pp_cfg()),
  x = 0,
  y = 0,
  z = NA,
  angle = 0,
  axis_x = 0,
  axis_y = 0,
  width = NA,
  height = NA,
  depth = NA,
  envir = getOption("piecepackr.envir"),
  ...,
  scale = 1,
  res = 72,
  alpha = 1,
  lit = FALSE,
  shininess = 50,
  textype = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="piece3d_+3A_piece_side">piece_side</code></td>
<td>
<p>A string with piece and side separated by a underscore e.g. &quot;coin_face&quot;</p>
</td></tr>
<tr><td><code id="piece3d_+3A_suit">suit</code></td>
<td>
<p>Number of suit (starting from 1).</p>
</td></tr>
<tr><td><code id="piece3d_+3A_rank">rank</code></td>
<td>
<p>Number of rank (starting from 1)</p>
</td></tr>
<tr><td><code id="piece3d_+3A_cfg">cfg</code></td>
<td>
<p>Piecepack configuration list or <code>pp_cfg</code> object,
a list of <code>pp_cfg</code> objects,
or a character vector referring to names in <code>envir</code>
or a character vector referring to object names that
can be retrieved by <code>base::dynGet()</code>.</p>
</td></tr>
<tr><td><code id="piece3d_+3A_x">x</code></td>
<td>
<p>Where to place piece on x axis of viewport</p>
</td></tr>
<tr><td><code id="piece3d_+3A_y">y</code></td>
<td>
<p>Where to place piece on y axis of viewport</p>
</td></tr>
<tr><td><code id="piece3d_+3A_z">z</code></td>
<td>
<p>z-coordinate of the piece.  Has no effect if <code>op_scale</code> is <code>0</code>.</p>
</td></tr>
<tr><td><code id="piece3d_+3A_angle">angle</code></td>
<td>
<p>Angle (on xy plane) to draw piece at</p>
</td></tr>
<tr><td><code id="piece3d_+3A_axis_x">axis_x</code></td>
<td>
<p>First coordinate of the axis unit vector.</p>
</td></tr>
<tr><td><code id="piece3d_+3A_axis_y">axis_y</code></td>
<td>
<p>Second coordinate of the axis unit vector.</p>
</td></tr>
<tr><td><code id="piece3d_+3A_width">width</code></td>
<td>
<p>Width of piece</p>
</td></tr>
<tr><td><code id="piece3d_+3A_height">height</code></td>
<td>
<p>Height of piece</p>
</td></tr>
<tr><td><code id="piece3d_+3A_depth">depth</code></td>
<td>
<p>Depth (thickness) of piece.  Has no effect if <code>op_scale</code> is <code>0</code>.</p>
</td></tr>
<tr><td><code id="piece3d_+3A_envir">envir</code></td>
<td>
<p>Environment (or named list) containing configuration list(s).</p>
</td></tr>
<tr><td><code id="piece3d_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="piece3d_+3A_scale">scale</code></td>
<td>
<p>Multiplicative scaling factor to apply to width, height, and depth.</p>
</td></tr>
<tr><td><code id="piece3d_+3A_res">res</code></td>
<td>
<p>Resolution of the faces.</p>
</td></tr>
<tr><td><code id="piece3d_+3A_alpha">alpha</code></td>
<td>
<p>Alpha channel for transparency.</p>
</td></tr>
<tr><td><code id="piece3d_+3A_lit">lit</code></td>
<td>
<p>logical, specifying if rgl lighting calculation should take place.</p>
</td></tr>
<tr><td><code id="piece3d_+3A_shininess">shininess</code></td>
<td>
<p>Properties for rgl lighting calculation.</p>
</td></tr>
<tr><td><code id="piece3d_+3A_textype">textype</code></td>
<td>
<p>Use <code>"rgba"</code> when sure texture will have alpha transparency.
Use <code>"rgb"</code> when sure texture will not have alpha transparency
(in particular <code>rgl</code>'s WebGL export will likely work better).
If <code>NA</code> we will read the texture and figure out a reasonable value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of rgl object IDs.
</p>


<h3>See Also</h3>

<p>See <code><a href="rgl.html#topic+rgl-package">rgl-package</a></code> for more information about the <code>rgl</code> package.
See <code><a href="rgl.html#topic+material">rgl::material3d()</a></code> for more info about setting <code>rgl</code> material properties.
See <code><a href="#topic+geometry_utils">geometry_utils</a></code> for a discussion of the 3D rotation parameterization.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("rgl", quietly = TRUE) &amp;&amp; all(capabilities(c("cairo", "png")))) {
  rgl::open3d()
  cfg &lt;- game_systems("sans3d")$piecepack
  piece3d("tile_back", suit = 3, rank = 3, cfg = cfg, x = 0, y = 0, z = 0)
  piece3d("coin_back", suit = 4, rank = 2, cfg = cfg, x = 0.5, y = 0.5, z = 0.25)
  piece3d("pawn_top", suit = 1, cfg = cfg, x = -0.5, y = 0.5, z = 0.6)
  piece3d("die_face", suit = 3, cfg = cfg, x = -0.5, y = -0.5, z = 0.375)
  piece3d("pyramid_top", suit = 2, rank = 3, cfg = cfg, x = 1.5, y = 0.0, z = 0.31875)
  invisible(NULL)
}
</code></pre>

<hr>
<h2 id='piecepackr-defunct'>Defunct functions</h2><span id='topic+piecepackr-defunct'></span><span id='topic+halmaGrob'></span><span id='topic+kiteGrob'></span><span id='topic+pyramidGrob'></span><span id='topic+convexGrobFn'></span><span id='topic+concaveGrobFn'></span><span id='topic+gridlinesGrob'></span><span id='topic+matGrob'></span><span id='topic+checkersGrob'></span><span id='topic+hexlinesGrob'></span><span id='topic+get_shape_grob_fn'></span>

<h3>Description</h3>

<p>These functions are Defunct and have been removed from piecepackr.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>halmaGrob(...)

kiteGrob(...)

pyramidGrob(...)

convexGrobFn(...)

concaveGrobFn(...)

gridlinesGrob(...)

matGrob(...)

checkersGrob(...)

hexlinesGrob(...)

get_shape_grob_fn(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="piecepackr-defunct_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Details</h3>


<ol>
<li><p>For <code>get_shape_grob_fn</code> use <code>pp_shape()$shape</code> instead.
</p>
</li>
<li><p>For <code>gridlinesGrob()</code> use <code>pp_shape()$gridlines()</code> instead.
</p>
</li>
<li><p>For <code>matGrob()</code> use <code>pp_shape()$mat()</code> instead.
</p>
</li>
<li><p>For <code>checkersGrob()</code>() use <code>pp_shape()$checkers()</code> instead.
</p>
</li>
<li><p>For <code>hexlinesGrob()</code> use <code>pp_shape()$hexlines()</code> instead.
</p>
</li>
<li><p>For <code>halmaGrob()</code> use <code>pp_shape("halma")$shape()</code> instead.
</p>
</li>
<li><p>For <code>kiteGrob()</code> use <code>pp_shape("kite")$shape()</code> instead.
</p>
</li>
<li><p>For <code>pyramidGrob()</code> use <code>pp_shape("pyramid")$shape()</code> instead.
</p>
</li>
<li><p>For <code>convexGrobFn(n, t)</code> use <code>pp_shape(paste0("convex", n), t)$shape</code> instead.
</p>
</li>
<li><p>For <code>concaveGrobFn(n, t, r)</code> use <code>pp_shape(paste0("concave", n), t, r)$shape</code> instead.
</p>
</li></ol>


<hr>
<h2 id='piecepackr-package'>piecepackr: Board Game Graphics</h2><span id='topic+piecepackr'></span><span id='topic+piecepackr-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Functions to make board game graphics with the 'ggplot2', 'grid', 'rayrender', 'rayvertex', and 'rgl' packages. Specializes in game diagrams, animations, and &quot;Print &amp; Play&quot; layouts for the 'piecepack' <a href="https://www.ludism.org/ppwiki">https://www.ludism.org/ppwiki</a> but can make graphics for other board game systems. Includes configurations for several public domain game systems such as checkers, (double-18) dominoes, go, 'piecepack', playing cards, etc.
</p>


<h3>Package options</h3>

<p>The following piecepackr function arguments may be set globally via <code><a href="base.html#topic+options">base::options()</a></code>:
</p>

<dl>
<dt>piecepackr.at.inform</dt><dd><p>If <code>FALSE</code> turns off messages when affine transformation support not detected in active graphics device.</p>
</dd>
<dt>piecepackr.cfg</dt><dd><p>Sets a new default for the <code>cfg</code> argument</p>
</dd>
<dt>piecepackr.check.cairo</dt><dd><p>If <code>FALSE</code> don't check the version of cairo</p>
</dd>
<dt>piecepackr.default.units</dt><dd><p>Sets a new default for the <code>default.units</code> argument</p>
</dd>
<dt>piecepackr.envir</dt><dd><p>Sets a new default for the <code>envir</code> argument</p>
</dd>
<dt>piecepackr.metadata.inform</dt><dd><p>If <code>FALSE</code> turns off messages when support for embedding metadata not detected.</p>
</dd>
<dt>piecepackr.op_angle</dt><dd><p>Sets a new default for the <code>op_angle</code> argument</p>
</dd>
<dt>piecepackr.op_scale</dt><dd><p>Sets a new default for the <code>op_scale</code> argument</p>
</dd>
<dt>piecepackr.trans</dt><dd><p>Sets a new default for the <code>trans</code> argument</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Trevor L Davis <a href="mailto:trevor.l.davis@gmail.com">trevor.l.davis@gmail.com</a> (<a href="https://orcid.org/0000-0001-6341-4639">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Linux Foundation (Uses some data from the &quot;SPDX License List&quot; &lt;https://github.com/spdx/license-list-XML&gt;) [data contributor]
</p>
</li>
<li><p> Delapouite &lt;https://delapouite.com/&gt; (Meeple shape extracted from &quot;Meeple icon&quot; &lt;https://game-icons.net/1x1/delapouite/meeple.html&gt; / &quot;CC BY 3.0&quot; &lt;https://creativecommons.org/licenses/by/3.0/&gt;) [illustrator]
</p>
</li>
<li><p> Creative Commons (&lsquo;save_print_and_play()' uses &quot;license badges&quot; from Creative Commons to describe the generated print-and-play file&rsquo;s license) [illustrator]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li><p> blog: <a href="https://trevorldavis.com/piecepackr/">https://trevorldavis.com/piecepackr/</a>
</p>
</li>
<li><p> pkgdown: <a href="https://trevorldavis.com/R/piecepackr/">https://trevorldavis.com/R/piecepackr/</a>
</p>
</li>
<li><p> forum: <a href="https://groups.google.com/forum/#!forum/piecepackr">https://groups.google.com/forum/#!forum/piecepackr</a>
</p>
</li>
<li><p> Report bugs: <a href="https://github.com/piecepackr/piecepackr/issues">https://github.com/piecepackr/piecepackr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='pmap_piece'>Create graphics using data frame input</h2><span id='topic+pmap_piece'></span>

<h3>Description</h3>

<p><code>pmap_piece()</code> operates on the rows of a data frame
applying <code>.f</code> to each row (usually <code>grid.piece</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pmap_piece(
  .l,
  .f = pieceGrob,
  ...,
  cfg = getOption("piecepackr.cfg"),
  envir = getOption("piecepackr.envir"),
  trans = getOption("piecepackr.trans"),
  draw = TRUE,
  name = NULL,
  gp = NULL,
  vp = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pmap_piece_+3A_.l">.l</code></td>
<td>
<p>A list of vectors, such as a data frame. The length of <code>.l</code>
determines the number of arguments that <code>.f</code>
will be called  with. List names will be used if present.</p>
</td></tr>
<tr><td><code id="pmap_piece_+3A_.f">.f</code></td>
<td>
<p>Function to be applied to <code>.l</code> after adjustments to
<code>cfg</code> and <code>envir</code> and the application of <code>trans</code>.
Usually <code><a href="#topic+grid.piece">grid.piece()</a></code>, <code><a href="#topic+pieceGrob">pieceGrob()</a></code>, <code><a href="#topic+piece3d">piece3d()</a></code>, or <code><a href="#topic+piece">piece()</a></code>.</p>
</td></tr>
<tr><td><code id="pmap_piece_+3A_...">...</code></td>
<td>
<p>Extra arguments to pass to <code>.f</code>.</p>
</td></tr>
<tr><td><code id="pmap_piece_+3A_cfg">cfg</code></td>
<td>
<p>Piecepack configuration list or <code>pp_cfg</code> object,
a list of <code>pp_cfg</code> objects,
or a character vector referring to names in <code>envir</code>
or a character vector referring to object names that
can be retrieved by <code>base::dynGet()</code>.</p>
</td></tr>
<tr><td><code id="pmap_piece_+3A_envir">envir</code></td>
<td>
<p>Environment (or named list) containing configuration list(s).</p>
</td></tr>
<tr><td><code id="pmap_piece_+3A_trans">trans</code></td>
<td>
<p>Function to modify <code>.l</code> before drawing.
Default (<code>NULL</code>) is to not modify <code>.l</code>.  <code>op_transform</code>
can help with using an oblique projection (i.e. <code>op_scale</code> over 0).</p>
</td></tr>
<tr><td><code id="pmap_piece_+3A_draw">draw</code></td>
<td>
<p>A logical value indicating whether graphics output should be produced.</p>
</td></tr>
<tr><td><code id="pmap_piece_+3A_name">name</code></td>
<td>
<p>A character identifier (for grid)</p>
</td></tr>
<tr><td><code id="pmap_piece_+3A_gp">gp</code></td>
<td>
<p>An object of class &ldquo;gpar&rdquo;.</p>
</td></tr>
<tr><td><code id="pmap_piece_+3A_vp">vp</code></td>
<td>
<p>A <code>grid</code> viewport object (or <code>NULL</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pmap_piece()</code> differs from <code>purrr::pmap()</code> in a few ways:
</p>

<ol>
<li><p>If <code>cfg</code> and/or <code>envir</code> are missing attempts to set reasonable defaults.
</p>
</li>
<li><p>If not <code>NULL</code> will first apply function <code>trans</code> to <code>.l</code>.
</p>
</li>
<li><p>If the output of <code>.f</code> is a grid grob object then <code>pmap_piece</code>
will return a <code>gTree</code> object with
specified <code>name</code>, <code>gp</code>, and <code>vp</code> values and if <code>draw</code> is true draw it.
</p>
</li>
<li><p>If <code>.l</code> lacks a <code>name</code> column or if <code>name</code> column is non-unique
attempts to generate a reasonable new default <code>name</code> column
and use that to name the return <code>gTree</code> children  or <code>list</code> values.
</p>
</li></ol>



<h3>See Also</h3>

<p><code><a href="#topic+render_piece">render_piece()</a></code> is a higher-level function that wraps this function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  if (requireNamespace("grid", quietly = TRUE) &amp;&amp; piecepackr:::device_supports_unicode()) {
       dark_colorscheme &lt;- list(suit_color="darkred,black,darkgreen,darkblue,black",
                            invert_colors.suited=TRUE, border_color="black", border_lex=2)
       traditional_ranks &lt;- list(use_suit_as_ace=TRUE, rank_text=",a,2,3,4,5")
       cfg3d &lt;- list(width.pawn=0.75, height.pawn=0.75, depth.pawn=1,
                          dm_text.pawn="", shape.pawn="convex6", invert_colors.pawn=TRUE,
                          edge_color.coin="tan", edge_color.tile="tan")
       cfg &lt;- pp_cfg(c(dark_colorscheme, traditional_ranks, cfg3d))
       grid::grid.newpage()
       df_tiles &lt;- data.frame(piece_side="tile_back", x=0.5+c(3,1,3,1), y=0.5+c(3,3,1,1),
                              suit=NA, angle=NA, z=NA, stringsAsFactors=FALSE)
       df_coins &lt;- data.frame(piece_side="coin_back", x=rep(4:1, 4), y=rep(4:1, each=4),
                              suit=1:16%%2+rep(c(1,3), each=8),
                              angle=rep(c(180,0), each=8), z=1/4+1/16, stringsAsFactors=FALSE)
       df &lt;- rbind(df_tiles, df_coins)
       pmap_piece(df, cfg=cfg, op_scale=0.5, default.units="in")
  }
</code></pre>

<hr>
<h2 id='pp_cfg'>Configuration list R6 object</h2><span id='topic+pp_cfg'></span><span id='topic+is_pp_cfg'></span><span id='topic+as_pp_cfg'></span>

<h3>Description</h3>

<p><code>pp_cfg()</code> and <code>as_pp_cfg()</code> create piecepack configuration list R6 objects.
<code>is_pp_cfg()</code> returns <code>TRUE</code> if object is a piecepack configuration list R6 object.
<code>as.list()</code> will convert it into a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pp_cfg(cfg = list())

is_pp_cfg(cfg)

as_pp_cfg(cfg = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pp_cfg_+3A_cfg">cfg</code></td>
<td>
<p>List of configuration options</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pp_cfg</code> R6 class objects serve the following purposes:
</p>

<ul>
<li><p> Customize the appearance of pieces drawn by <code>grid.piece()</code>.
</p>
</li>
<li><p> Speed up the drawing of graphics through use of caching.
</p>
</li>
<li><p> Allow the setting and querying of information about the board game components
that maybe of use to developers:
</p>

<ul>
<li><p> Number of suits
</p>
</li>
<li><p> Number of ranks
</p>
</li>
<li><p> Suit colors
</p>
</li>
<li><p> Which types of components are included and/or properly supported
</p>
</li>
<li><p> What would be a good color to use when adding annotations on top of these components.
</p>
</li>
<li><p> Title, Description, Copyright, License, and Credit metadata
</p>
</li></ul>

</li></ul>



<h3><code>pp_cfg</code> R6 Class Method Arguments</h3>


<dl>
<dt><code>piece_side</code></dt><dd><p>A string with piece and side separated by a underscore e.g. &quot;coin_face&quot;.</p>
</dd>
<dt><code>suit</code></dt><dd><p>Number of suit (starting from 1).</p>
</dd>
<dt><code>rank</code></dt><dd><p>Number of rank (starting from 1).</p>
</dd>
<dt><code>type</code></dt><dd><p>Which type of grob to return, either <code>"normal"</code>, <code>"picture"</code>, <code>"raster"</code>, or <code>"transformation"</code>.</p>
</dd>
<dt><code>scale</code></dt><dd><p>&quot;scale&quot; factor</p>
</dd>
<dt><code>alpha</code></dt><dd><p>&quot;alpha&quot; value</p>
</dd>
</dl>



<h3><code>pp_cfg</code> R6 Class Methods</h3>


<dl>
<dt><code>get_grob()</code></dt><dd><p>Returns a <code>grid</code> &ldquo;grob&rdquo; for drawing the piece.</p>
</dd>
<dt><code>get_piece_opt()</code></dt><dd><p>Returns a list with info useful for drawing the piece.</p>
</dd>
<dt><code>get_suit_color()</code></dt><dd><p>Returns the suit colors.</p>
</dd>
<dt><code>get_width()</code>, <code>get_height()</code>, <code>get_depth()</code></dt><dd>
<p>Dimensions (of the bounding cube) of the piece in inches</p>
</dd>
</dl>



<h3><code>pp_cfg</code> R6 Class Fields and Active Bindings</h3>


<dl>
<dt><code>annotation_color</code></dt><dd><p>Suggestion of a good color to annotate with</p>
</dd>
<dt><code>cache</code></dt><dd><p>Cache object which stores intermediate graphical calculations.
Default is a memory-cache that does not prune.
This can be replaced by another cache that
implements the cache API used by the <code>cachem</code> package</p>
</dd>
<dt><code>cache_grob</code></dt><dd><p>Whether we should cache (2D) grobs</p>
</dd>
<dt><code>cache_grob_with_bleed_fn</code></dt><dd><p>Whether we should cache the grob with bleed functions</p>
</dd>
<dt><code>cache_piece_opt</code></dt><dd><p>Whether we should cache piece opt information</p>
</dd>
<dt><code>cache_op_fn</code></dt><dd><p>Whether we should cache the oblique projection functions</p>
</dd>
<dt><code>cache_obj_fn</code></dt><dd><p>Whether we should cache any 3D rendering functions</p>
</dd>
<dt><code>copyright</code></dt><dd><p>Design copyright information</p>
</dd>
<dt><code>credit</code></dt><dd><p>Design credits</p>
</dd>
<dt><code>description</code></dt><dd><p>Design description</p>
</dd>
<dt><code>fontfamily</code></dt><dd><p>Main font family</p>
</dd>
<dt><code>has_bits</code></dt><dd><p>Whether we should assume this supports &quot;bit&quot; pieces</p>
</dd>
<dt><code>has_boards</code></dt><dd><p>Whether we should assume this supports &quot;board&quot; pieces</p>
</dd>
<dt><code>has_cards</code></dt><dd><p>Whether we should assume this supports &quot;card&quot; pieces</p>
</dd>
<dt><code>has_coins</code></dt><dd><p>Whether we should assume this supports &quot;coin&quot; pieces</p>
</dd>
<dt><code>has_dice</code></dt><dd><p>Whether we should assume this supports &quot;die&quot; pieces</p>
</dd>
<dt><code>has_matchsticks</code></dt><dd><p>Whether we should assume this supports &quot;matchstick&quot; pieces</p>
</dd>
<dt><code>has_pawns</code></dt><dd><p>Whether we should assume this supports &quot;pawn&quot; pieces</p>
</dd>
<dt><code>has_piecepack</code></dt><dd><p>Binding which simultaneously checks/sets
<code>has_coins</code>, <code>has_tiles</code>, <code>has_pawns</code>, <code>has_dice</code></p>
</dd>
<dt><code>has_pyramids</code></dt><dd><p>Whether we should assume this supports &quot;pyramid&quot; pieces</p>
</dd>
<dt><code>has_saucers</code></dt><dd><p>Whether we should assume this supports &quot;saucer&quot; pieces</p>
</dd>
<dt><code>has_tiles</code></dt><dd><p>Whether we should assume this supports &quot;tile&quot; pieces</p>
</dd>
<dt><code>spdx_id</code></dt><dd><p>SPDX Identifier for graphical design license.
See <a href="https://spdx.org/licenses/">https://spdx.org/licenses/</a> for full list.</p>
</dd>
<dt><code>title</code></dt><dd><p>Design title</p>
</dd>
</dl>



<h3>Defunct <code>pp_cfg</code> R6 Class attributes which have been removed</h3>


<dl>
<dt><code>cache_shadow</code></dt><dd><p>Use <code>cache_op_fn</code> instead</p>
</dd>
<dt><code>i_unsuit</code></dt><dd><p>Instead add <code>1L</code> to <code>n_suits</code></p>
</dd>
<dt><code>get_pictureGrob()</code></dt><dd><p>Use <code>get_grob(..., type = "picture")</code> instead</p>
</dd>
<dt><code>get_shadow_fn</code></dt><dd><p><code>get_op_grob()</code> returns complete oblique projection grob</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+game_systems">game_systems()</a></code> for functions that return configuration list
objects for several game systems.
<a href="https://trevorldavis.com/piecepackr/configuration-lists.html">https://trevorldavis.com/piecepackr/configuration-lists.html</a> for more details
about <code>piecepackr</code> configuration lists.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> cfg &lt;- pp_cfg(list(invert_colors=TRUE))
 as.list(cfg)
 is_pp_cfg(cfg)
 as_pp_cfg(list(suit_color="darkred,black,darkgreen,darkblue,grey"))
 cfg$get_suit_color(suit=3)
 cfg$annotation_color
 cfg$has_matchsticks
 cfg$has_matchsticks &lt;- TRUE
 cfg$has_matchsticks
 cfg$get_width("tile_back")
 cfg$get_height("die_face")
 cfg$get_depth("coin_face")
 # May take more than 5 seconds on CRAN servers
 # `pp_cfg()` objects use a cache to speed up repeated drawing
 pdf(tempfile(fileext = ".pdf"))
 cfg &lt;- list()
 system.time(replicate(100, grid.piece("tile_back", 4, 4, cfg)))
 cfg &lt;- pp_cfg(list())
 system.time(replicate(100, grid.piece("tile_back", 4, 4, cfg)))
 invisible(dev.off())
 

</code></pre>

<hr>
<h2 id='pp_shape'>Shape object for generating various grobs</h2><span id='topic+pp_shape'></span>

<h3>Description</h3>

<p><code>pp_shape()</code> creates an R6 object with methods for creating various shape based grobs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pp_shape(label = "rect", theta = 90, radius = 0.2, back = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pp_shape_+3A_label">label</code></td>
<td>
<p>Label of the shape.  One of </p>

<dl>
<dt>&ldquo;circle&rdquo;</dt><dd><p>Circle.</p>
</dd>
<dt>&ldquo;convexN&rdquo;</dt><dd><p>An <code>N</code>-sided convex polygon.
<code>theta</code> controls which direction the first vertex is drawn.</p>
</dd>
<dt>&ldquo;concaveN&rdquo;</dt><dd><p>A &ldquo;star&rdquo; (concave) polygon with <code>N</code> &ldquo;points&rdquo;.
<code>theta</code> controls which direction the first point is drawn.
<code>radius</code> controls the distance of the &ldquo;inner&rdquo; vertices from the center.</p>
</dd>
<dt>&ldquo;halma&rdquo;</dt><dd><p>A 2D outline of a &ldquo;Halma pawn&rdquo;.</p>
</dd>
<dt>&ldquo;kite&rdquo;</dt><dd><p>&ldquo;Kite&rdquo; quadrilateral shape.</p>
</dd>
<dt>&ldquo;meeple&rdquo;</dt><dd><p>A 2D outline of a &ldquo;meeple&rdquo;.</p>
</dd>
<dt>&ldquo;oval&rdquo;</dt><dd><p>Oval.</p>
</dd>
<dt>&ldquo;pyramid&rdquo;</dt><dd><p>An &ldquo;Isosceles&rdquo; triangle whose base is the bottom of the viewport.
Typically used to help draw the face of the &ldquo;pyramid&rdquo; piece.</p>
</dd>
<dt>&ldquo;rect&rdquo;</dt><dd><p>Rectangle.</p>
</dd>
<dt>&ldquo;roundrect&rdquo;</dt><dd><p>&ldquo;Rounded&rdquo; rectangle.  <code>radius</code> controls curvature of corners.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="pp_shape_+3A_theta">theta</code></td>
<td>
<p><code>convex</code> and <code>concave</code> polygon shapes
use this to determine where the first point is drawn.</p>
</td></tr>
<tr><td><code id="pp_shape_+3A_radius">radius</code></td>
<td>
<p><code>concave</code> polygon and <code>roundrect</code> use this
to control appearance of the shape.</p>
</td></tr>
<tr><td><code id="pp_shape_+3A_back">back</code></td>
<td>
<p>Whether the shape should be reflected across a vertical line in the middle of the viewport.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pp_shape</code> objects serve the following purposes:</p>

<ol>
<li><p>Make it easier for developers to customize game piece appearances
either through a &quot;grob_fn&quot; or &quot;op_grob_fn&quot; styles in <code>pp_cfg()</code>
or manipulate a piece post drawing via functions like <code>grid::grid.edit()</code>.
</p>
</li>
<li><p>Used internally to generate <code>piecepackr</code>'s built-in game piece grobs.
</p>
</li></ol>



<h3><code>pp_shape</code> R6 Class Method Arguments</h3>


<dl>
<dt><code>mat_width</code></dt><dd><p>Numeric vector of mat widths.</p>
</dd>
<dt><code>clip</code></dt><dd><p>&ldquo;clip grob&rdquo; to perform polyclip operation with.
See <code><a href="gridGeometry.html#topic+grid.polyclip">gridGeometry::grid.polyclip()</a></code> for more info.</p>
</dd>
<dt><code>op</code></dt><dd><p>Polyclip operation to perform.
See <code><a href="gridGeometry.html#topic+grid.polyclip">gridGeometry::grid.polyclip()</a></code> for more info.</p>
</dd>
<dt><code>pattern</code></dt><dd><p>Pattern to fill in shape with.
See <code><a href="gridpattern.html#topic+grid.pattern">gridpattern::patternGrob()</a></code> for more info.</p>
</dd>
<dt><code>...</code></dt><dd><p>Passed to <code>gridpattern::patternGrob()</code>.</p>
</dd>
<dt><code>name</code></dt><dd><p>Grid grob <code>name</code> value.</p>
</dd>
<dt><code>gp</code></dt><dd><p>Grid <code>gpar</code> list.  See <code><a href="grid.html#topic+gpar">grid::gpar()</a></code> for more info.</p>
</dd>
<dt><code>vp</code></dt><dd><p>Grid viewport or <code>NULL</code>.</p>
</dd>
</dl>



<h3><code>pp_shape</code> R6 Class Methods</h3>


<dl>
<dt><code>checkers(name = NULL, gp = gpar(), vp = NULL)</code></dt><dd><p>Returns a grob of checkers for that shape.</p>
</dd>
<dt><code>gridlines(name = NULL, gp = gpar(), vp = NULL)</code></dt><dd><p>Returns a grob of gridlines for that shape.</p>
</dd>
<dt><code>hexlines(name = NULL, gp = gpar(), vp = NULL)</code></dt><dd><p>Returns a grob of hexlines for that shape.</p>
</dd>
<dt><code>mat(mat_width = 0, name = NULL, gp = gpar(), vp = NULL)</code></dt><dd>
<p>Returns a grob for a matting &ldquo;mat&rdquo; for that shape.</p>
</dd>
<dt><code>pattern(pattern = "stripe", ..., name = NULL, gp = gpar(), vp = NULL)</code></dt><dd>
<p>Fills in the shape's <code>npc_coords</code> with a pattern.
See <code><a href="gridpattern.html#topic+grid.pattern">gridpattern::patternGrob()</a></code> for more information.
</p>
</dd>
<dt><code>polyclip(clip, op = "intersection", name = NULL, gp = gpar(), vp = NULL)</code></dt><dd>
<p>Returns a grob that is an &ldquo;intersection&rdquo;, &ldquo;minus&rdquo;, &ldquo;union&rdquo;, or &ldquo;xor&rdquo; of another grob.
Note unlike <code>gridGeometry::polyclipGrob</code> it can directly work with a <code>pieceGrob</code> &quot;clip grob&quot; argument.</p>
</dd>
<dt><code>shape(name = NULL, gp = gpar(), vp = NULL)</code></dt><dd><p>Returns a grob of the shape.</p>
</dd>
</dl>



<h3><code>pp_shape</code> R6 Class Active Bindings</h3>


<dl>
<dt><code>label</code></dt><dd><p>The shape's label.</p>
</dd>
<dt><code>theta</code></dt><dd><p>The shape's theta.</p>
</dd>
<dt><code>radius</code></dt><dd><p>The shape's radius.</p>
</dd>
<dt><code>back</code></dt><dd><p>A boolean of whether this is the shape's &ldquo;back&rdquo; side.</p>
</dd>
<dt><code>npc_coords</code></dt><dd><p>A named list of &ldquo;npc&rdquo; coordinates along the perimeter of the shape.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'> if (require("grid", quietly = TRUE)) {
     gp &lt;- gpar(col="black", fill="yellow")
     rect &lt;- pp_shape(label="rect")
     convex6 &lt;- pp_shape(label="convex6")
     circle &lt;- pp_shape(label="circle")

     pushViewport(viewport(x=0.25, y=0.75, width=1/2, height=1/2))
     grid.draw(rect$shape(gp=gp))
     grid.draw(rect$gridlines(gp=gpar(col="blue", lex=4)))
     grid.draw(rect$hexlines(gp=gpar(col="green")))
     popViewport()

     pushViewport(viewport(x=0.75, y=0.75, width=1/2, height=1/2))
     grid.draw(convex6$shape(gp=gp))
     grid.draw(convex6$checkers(gp=gpar(fill="blue")))
     popViewport()

     pushViewport(viewport(x=0.25, y=0.25, width=1/2, height=1/2))
     grid.draw(circle$shape(gp=gp))
     grid.draw(circle$mat(mat_width=0.2, gp=gpar(fill="blue")))
     popViewport()

     pushViewport(viewport(x=0.75, y=0.25, width=1/2, height=1/2))
     grid.draw(rect$shape(gp=gp))
     grid.draw(rect$mat(mat_width=c(0.2, 0.1, 0.3, 0.4), gp=gpar(fill="blue")))
     popViewport()
 }
 if (require("grid", quietly = TRUE)) {
     grid.newpage()
     gp &lt;- gpar(col="black", fill="yellow")

     vp &lt;- viewport(x=1/4, y=1/4, width=1/2, height=1/2)
     grid.draw(pp_shape("halma")$shape(gp=gp, vp=vp))
     vp &lt;- viewport(x=3/4, y=1/4, width=1/2, height=1/2)
     grid.draw(pp_shape("pyramid")$shape(gp=gp, vp=vp))
     vp &lt;- viewport(x=3/4, y=3/4, width=1/2, height=1/2)
     grid.draw(pp_shape("kite")$shape(gp=gp, vp=vp))
     vp &lt;- viewport(x=1/4, y=3/4, width=1/2, height=1/2)
     grid.draw(pp_shape("meeple")$shape(gp=gp, vp=vp))
 }
 if (require("grid", quietly = TRUE)) {
     grid.newpage()
     vp &lt;- viewport(x=1/4, y=1/4, width=1/2, height=1/2)
     grid.draw(pp_shape("convex3", 0)$shape(gp=gp, vp=vp))
     vp &lt;- viewport(x=3/4, y=1/4, width=1/2, height=1/2)
     grid.draw(pp_shape("convex4", 90)$shape(gp=gp, vp=vp))
     vp &lt;- viewport(x=3/4, y=3/4, width=1/2, height=1/2)
     grid.draw(pp_shape("convex5", 180)$shape(gp=gp, vp=vp))
     vp &lt;- viewport(x=1/4, y=3/4, width=1/2, height=1/2)
     grid.draw(pp_shape("convex6", 270)$shape(gp=gp, vp=vp))
 }
 if (require("grid", quietly = TRUE)) {
     grid.newpage()
     vp &lt;- viewport(x=1/4, y=1/4, width=1/2, height=1/2)
     grid.draw(pp_shape("concave3", 0, 0.1)$shape(gp=gp, vp=vp))
     vp &lt;- viewport(x=3/4, y=1/4, width=1/2, height=1/2)
     grid.draw(pp_shape("concave4", 90, 0.2)$shape(gp=gp, vp=vp))
     vp &lt;- viewport(x=3/4, y=3/4, width=1/2, height=1/2)
     grid.draw(pp_shape("concave5", 180, 0.3)$shape(gp=gp, vp=vp))
     vp &lt;- viewport(x=1/4, y=3/4, width=1/2, height=1/2)
     grid.draw(pp_shape("concave6", 270)$shape(gp=gp, vp=vp))
 }
 if (require("grid", quietly = TRUE) &amp;&amp;
     requireNamespace("gridpattern", quietly = TRUE)) {
     grid.newpage()
     hex &lt;- pp_shape("convex6")
     gp &lt;- gpar(fill = c("blue", "yellow", "red"), col = "black")
     grid.draw(hex$pattern("polygon_tiling", gp = gp, spacing = 0.1,
                           type = "truncated_trihexagonal"))
     gp &lt;- gpar(fill = "black", col = NA)
     grid.draw(hex$mat(mat_width = 0.025, gp = gp))
 }
</code></pre>

<hr>
<h2 id='pp_utils'>Miscellaneous <code>piecepackr</code> utility functions</h2><span id='topic+pp_utils'></span><span id='topic+is_color_invisible'></span><span id='topic+inch'></span><span id='topic+cleave'></span><span id='topic+file2grob'></span>

<h3>Description</h3>

<p><code>cleave</code> converts a delimiter separated string into a vector.
<code>inch(x)</code> is equivalent to <code>unit(x, "in")</code>.
<code>is_color_invisible</code> tells whether the color is transparent (and hence need not be drawn).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_color_invisible(col)

inch(inches)

cleave(s, sep = ",", float = FALSE, color = FALSE)

file2grob(file, distort = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pp_utils_+3A_col">col</code></td>
<td>
<p>Color</p>
</td></tr>
<tr><td><code id="pp_utils_+3A_inches">inches</code></td>
<td>
<p>Number representing number of inches</p>
</td></tr>
<tr><td><code id="pp_utils_+3A_s">s</code></td>
<td>
<p>String to convert</p>
</td></tr>
<tr><td><code id="pp_utils_+3A_sep">sep</code></td>
<td>
<p>Delimiter (defaults to &quot;,&quot;)</p>
</td></tr>
<tr><td><code id="pp_utils_+3A_float">float</code></td>
<td>
<p>If <code>TRUE</code> cast to numeric</p>
</td></tr>
<tr><td><code id="pp_utils_+3A_color">color</code></td>
<td>
<p>if <code>TRUE</code> convert empty strings to <code>"transparent"</code></p>
</td></tr>
<tr><td><code id="pp_utils_+3A_file">file</code></td>
<td>
<p>Filename of image</p>
</td></tr>
<tr><td><code id="pp_utils_+3A_distort">distort</code></td>
<td>
<p>Logical value of whether one should preserve the aspect ratio
or distort to fit the area it is drawn in</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'> cleave("0.5,0.2,0.4,0.5", float=TRUE)
 cleave("black,darkred,#050EAA,,", color=TRUE)

 is_color_invisible("transparent")
 is_color_invisible(NA)
 is_color_invisible("blue")
 is_color_invisible("#05AE9C")

 if (requireNamespace("grid", quietly = TRUE)) {
     identical(inch(1), grid::unit(1, "inch"))
 }

</code></pre>

<hr>
<h2 id='render_piece'>Render image of game pieces</h2><span id='topic+render_piece'></span>

<h3>Description</h3>

<p><code>render_piece()</code> renders an image of game pieces to a file or graphics device.
It is a wrapper around <code>pmap_piece()</code> that can auto-size files and graphic devices,
apply axes offsets, annotate coordinates, and set up <code>rayrender</code> / <code>rayvertex</code> scenes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render_piece(
  df,
  file = NULL,
  ...,
  .f = piecepackr::grid.piece,
  cfg = getOption("piecepackr.cfg", NULL),
  envir = getOption("piecepackr.envir", game_systems("sans")),
  width = NULL,
  height = NULL,
  ppi = 72,
  bg = "white",
  xoffset = NULL,
  yoffset = NULL,
  new_device = TRUE,
  dev = NULL,
  dev.args = list(res = ppi, bg = bg, units = "in"),
  annotate = FALSE,
  annotation_scale = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="render_piece_+3A_df">df</code></td>
<td>
<p>A data frame of game piece information with (at least) the
named columns &ldquo;piece_side&rdquo;, &ldquo;x&rdquo;, and &ldquo;y&rdquo;.</p>
</td></tr>
<tr><td><code id="render_piece_+3A_file">file</code></td>
<td>
<p>Filename to save image unless <code>NULL</code>
in which case it either uses the current graphics device or opens a new device
(depending on <code>new_device</code> argument).</p>
</td></tr>
<tr><td><code id="render_piece_+3A_...">...</code></td>
<td>
<p>Arguments to <code><a href="#topic+pmap_piece">pmap_piece()</a></code></p>
</td></tr>
<tr><td><code id="render_piece_+3A_.f">.f</code></td>
<td>
<p>Low level graphics function to use e.g. <code><a href="#topic+grid.piece">grid.piece()</a></code>, <code><a href="#topic+piece3d">piece3d()</a></code>, <code><a href="#topic+piece_mesh">piece_mesh()</a></code>, or <code><a href="#topic+piece">piece()</a></code>.</p>
</td></tr>
<tr><td><code id="render_piece_+3A_cfg">cfg</code></td>
<td>
<p>A piecepackr configuration list</p>
</td></tr>
<tr><td><code id="render_piece_+3A_envir">envir</code></td>
<td>
<p>Environment (or named list) of piecepackr configuration lists</p>
</td></tr>
<tr><td><code id="render_piece_+3A_width">width</code></td>
<td>
<p>Width of image (in inches).  Inferred by default.</p>
</td></tr>
<tr><td><code id="render_piece_+3A_height">height</code></td>
<td>
<p>Height of image (in inches).  Inferred by default.</p>
</td></tr>
<tr><td><code id="render_piece_+3A_ppi">ppi</code></td>
<td>
<p>Resolution of image in pixels per inch.</p>
</td></tr>
<tr><td><code id="render_piece_+3A_bg">bg</code></td>
<td>
<p>Background color (use <code>"transparent"</code> for transparent)</p>
</td></tr>
<tr><td><code id="render_piece_+3A_xoffset">xoffset</code></td>
<td>
<p>Number to add to the <code>x</code> column in <code>df</code>.  Inferred by default.</p>
</td></tr>
<tr><td><code id="render_piece_+3A_yoffset">yoffset</code></td>
<td>
<p>Number to add to the <code>y</code> column in <code>df</code>.  Inferred by default.</p>
</td></tr>
<tr><td><code id="render_piece_+3A_new_device">new_device</code></td>
<td>
<p>If <code>file</code> is <code>NULL</code> should we open up a new graphics device?</p>
</td></tr>
<tr><td><code id="render_piece_+3A_dev">dev</code></td>
<td>
<p>Graphics device function to use.  If <code>NULL</code> infer a reasonable choice.</p>
</td></tr>
<tr><td><code id="render_piece_+3A_dev.args">dev.args</code></td>
<td>
<p>Additional arguments to pass to <code>dev</code> (besides <code>filename</code>, <code>width</code>, and <code>height</code>).
Will filter out any names that aren't in <code>formals(dev)</code>.</p>
</td></tr>
<tr><td><code id="render_piece_+3A_annotate">annotate</code></td>
<td>
<p>If <code>TRUE</code> or <code>"algebraic"</code> annotate the plot
with &ldquo;algrebraic&rdquo; coordinates,
if <code>FALSE</code> or <code>"none"</code> don't annotate,
if <code>"cartesian"</code> annotate the plot with &ldquo;cartesian&rdquo; coordinates.</p>
</td></tr>
<tr><td><code id="render_piece_+3A_annotation_scale">annotation_scale</code></td>
<td>
<p>Multiplicative factor that scales (stretches) any annotation coordinates.
By default uses <code>attr(df, "scale_factor") %||% 1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An invisible list of the dimensions of the image, as a side effect saves a graphic
</p>


<h3>See Also</h3>

<p>This function is a wrapper around <code><a href="#topic+pmap_piece">pmap_piece()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> df_board &lt;- data.frame(piece_side = "board_face", suit = 3, rank = 5,
                        x = 3.0, y = 3.0, stringsAsFactors = FALSE)
 df_w &lt;- data.frame(piece_side = "bit_face", suit = 6, rank = 1,
                    x = rep(1:5, 2), y = rep(1:2, each=5),
                    stringsAsFactors = FALSE)
 df_b &lt;- data.frame(piece_side = "bit_face", suit = 1, rank = 1,
                    x = rep(1:5, 2), y = rep(4:5, each=5),
                    stringsAsFactors = FALSE)
 df &lt;- rbind(df_board, df_w, df_b)
 df$cfg &lt;- "checkers1"

 if (requireNamespace("grid", quietly = TRUE)) {
   render_piece(df, new_device = FALSE)
 }
 if (requireNamespace("grid", quietly = TRUE)) {
   grid::grid.newpage()
   render_piece(df, new_device = FALSE,
                op_scale = 0.5, trans = op_transform,
                annotate = "algrebraic")
 }
 ## Not run: # May take more than 5 seconds on CRAN servers
 if (require(rayvertex)) {
   envir3d &lt;- game_systems("sans3d")
   render_piece(df, .f = piece_mesh, envir = envir3d,
                op_scale = 0.5, trans = op_transform)
 }
 
## End(Not run)
</code></pre>

<hr>
<h2 id='save_ellipsoid_obj'>Alternative Wavefront OBJ file generators</h2><span id='topic+save_ellipsoid_obj'></span><span id='topic+save_peg_doll_obj'></span>

<h3>Description</h3>

<p>These are alternative Wavefront OBJ generators intended to be used as a <code>obj_fn</code> attribute
in a <code>pp_cfg()</code> &ldquo;configuration list&rdquo;.
<code>save_ellipsoid_obj</code> saves an ellipsoid with a color equal to that piece's <code>background_color</code>.
<code>save_peg_doll_obj</code> saves a &ldquo;peg doll&rdquo; style doll with a color equal to that piece's <code>edge_color</code>
with a &ldquo;pawn belt&rdquo; around it's waste from that suit's and rank's <code>belt_face</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save_ellipsoid_obj(
  piece_side = "bit_face",
  suit = 1,
  rank = 1,
  cfg = getOption("piecepackr.cfg", pp_cfg()),
  ...,
  x = 0,
  y = 0,
  z = 0,
  angle = 0,
  axis_x = 0,
  axis_y = 0,
  width = NA,
  height = NA,
  depth = NA,
  filename = tempfile(fileext = ".obj"),
  subdivide = 3
)

save_peg_doll_obj(
  piece_side = "pawn_top",
  suit = 1,
  rank = 1,
  cfg = getOption("piecepackr.cfg", pp_cfg()),
  ...,
  x = 0,
  y = 0,
  z = 0,
  angle = 0,
  axis_x = 0,
  axis_y = 0,
  width = NA,
  height = NA,
  depth = NA,
  filename = tempfile(fileext = ".obj"),
  res = 72
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="save_ellipsoid_obj_+3A_piece_side">piece_side</code></td>
<td>
<p>A string with piece and side separated by a underscore e.g. &quot;coin_face&quot;</p>
</td></tr>
<tr><td><code id="save_ellipsoid_obj_+3A_suit">suit</code></td>
<td>
<p>Number of suit (starting from 1).</p>
</td></tr>
<tr><td><code id="save_ellipsoid_obj_+3A_rank">rank</code></td>
<td>
<p>Number of rank (starting from 1)</p>
</td></tr>
<tr><td><code id="save_ellipsoid_obj_+3A_cfg">cfg</code></td>
<td>
<p>Piecepack configuration list or <code>pp_cfg</code> object,
a list of <code>pp_cfg</code> objects,
or a character vector referring to names in <code>envir</code>
or a character vector referring to object names that
can be retrieved by <code>base::dynGet()</code>.</p>
</td></tr>
<tr><td><code id="save_ellipsoid_obj_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="save_ellipsoid_obj_+3A_x">x</code></td>
<td>
<p>Where to place piece on x axis of viewport</p>
</td></tr>
<tr><td><code id="save_ellipsoid_obj_+3A_y">y</code></td>
<td>
<p>Where to place piece on y axis of viewport</p>
</td></tr>
<tr><td><code id="save_ellipsoid_obj_+3A_z">z</code></td>
<td>
<p>z-coordinate of the piece.  Has no effect if <code>op_scale</code> is <code>0</code>.</p>
</td></tr>
<tr><td><code id="save_ellipsoid_obj_+3A_angle">angle</code></td>
<td>
<p>Angle (on xy plane) to draw piece at</p>
</td></tr>
<tr><td><code id="save_ellipsoid_obj_+3A_axis_x">axis_x</code></td>
<td>
<p>First coordinate of the axis unit vector.</p>
</td></tr>
<tr><td><code id="save_ellipsoid_obj_+3A_axis_y">axis_y</code></td>
<td>
<p>Second coordinate of the axis unit vector.</p>
</td></tr>
<tr><td><code id="save_ellipsoid_obj_+3A_width">width</code></td>
<td>
<p>Width of piece</p>
</td></tr>
<tr><td><code id="save_ellipsoid_obj_+3A_height">height</code></td>
<td>
<p>Height of piece</p>
</td></tr>
<tr><td><code id="save_ellipsoid_obj_+3A_depth">depth</code></td>
<td>
<p>Depth (thickness) of piece.  Has no effect if <code>op_scale</code> is <code>0</code>.</p>
</td></tr>
<tr><td><code id="save_ellipsoid_obj_+3A_filename">filename</code></td>
<td>
<p>Name of Wavefront OBJ object.</p>
</td></tr>
<tr><td><code id="save_ellipsoid_obj_+3A_subdivide">subdivide</code></td>
<td>
<p>Increasing this value makes for a smoother ellipsoid (and larger OBJ file and slower render).
See <code><a href="rgl.html#topic+ellipse3d">ellipse3d</a></code>.</p>
</td></tr>
<tr><td><code id="save_ellipsoid_obj_+3A_res">res</code></td>
<td>
<p>Resolution of the faces.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>See <code><a href="#topic+pp_cfg">pp_cfg()</a></code> for a discussion of &ldquo;configuration lists&rdquo;.
Wavefront OBJ file generators are used by <code><a href="#topic+save_piece_obj">save_piece_obj()</a></code> and (by default)
<code><a href="#topic+piece3d">piece3d()</a></code> (<code>rgl</code> wrapper), <code><a href="#topic+piece">piece()</a></code> (<code>rayrender</code> wrapper),
and <code><a href="#topic+piece_mesh">piece_mesh()</a></code> (<code>rayvertex</code> wrapper).
</p>

<hr>
<h2 id='save_piece_images'>Save piecepack images</h2><span id='topic+save_piece_images'></span>

<h3>Description</h3>

<p>Saves images of all individual piecepack pieces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save_piece_images(
  cfg = getOption("piecepackr.cfg", pp_cfg()),
  directory = tempdir(),
  format = "svg",
  angle = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="save_piece_images_+3A_cfg">cfg</code></td>
<td>
<p>Piecepack configuration list</p>
</td></tr>
<tr><td><code id="save_piece_images_+3A_directory">directory</code></td>
<td>
<p>Directory where to place images</p>
</td></tr>
<tr><td><code id="save_piece_images_+3A_format">format</code></td>
<td>
<p>Character vector of formats to save images in</p>
</td></tr>
<tr><td><code id="save_piece_images_+3A_angle">angle</code></td>
<td>
<p>Numeric vector of angles to rotate images (in degrees)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>  # May take more than 5 seconds on CRAN server
  if (all(capabilities(c("cairo", "png")))) {
      cfg &lt;- pp_cfg(list(suit_color="darkred,black,darkgreen,darkblue,grey"))
      save_piece_images(cfg, directory=tempdir(), format="svg", angle=0)
      save_piece_images(cfg, directory=tempdir(), format="png", angle=90)
  }
  
</code></pre>

<hr>
<h2 id='save_piece_obj'>Save Wavefront OBJ files of board game pieces</h2><span id='topic+save_piece_obj'></span>

<h3>Description</h3>

<p><code>save_piece_obj</code> saves Wavefront OBJ files (including associated MTL and texture image) of board game pieces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save_piece_obj(
  piece_side = "tile_face",
  suit = 1,
  rank = 1,
  cfg = getOption("piecepackr.cfg", pp_cfg()),
  ...,
  x = 0,
  y = 0,
  z = 0,
  angle = 0,
  axis_x = 0,
  axis_y = 0,
  width = NA,
  height = NA,
  depth = NA,
  filename = tempfile(fileext = ".obj"),
  scale = 1,
  res = 72
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="save_piece_obj_+3A_piece_side">piece_side</code></td>
<td>
<p>A string with piece and side separated by a underscore e.g. &quot;coin_face&quot;</p>
</td></tr>
<tr><td><code id="save_piece_obj_+3A_suit">suit</code></td>
<td>
<p>Number of suit (starting from 1).</p>
</td></tr>
<tr><td><code id="save_piece_obj_+3A_rank">rank</code></td>
<td>
<p>Number of rank (starting from 1)</p>
</td></tr>
<tr><td><code id="save_piece_obj_+3A_cfg">cfg</code></td>
<td>
<p>Piecepack configuration list or <code>pp_cfg</code> object,
a list of <code>pp_cfg</code> objects,
or a character vector referring to names in <code>envir</code>
or a character vector referring to object names that
can be retrieved by <code>base::dynGet()</code>.</p>
</td></tr>
<tr><td><code id="save_piece_obj_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="save_piece_obj_+3A_x">x</code></td>
<td>
<p>Where to place piece on x axis of viewport</p>
</td></tr>
<tr><td><code id="save_piece_obj_+3A_y">y</code></td>
<td>
<p>Where to place piece on y axis of viewport</p>
</td></tr>
<tr><td><code id="save_piece_obj_+3A_z">z</code></td>
<td>
<p>z-coordinate of the piece.  Has no effect if <code>op_scale</code> is <code>0</code>.</p>
</td></tr>
<tr><td><code id="save_piece_obj_+3A_angle">angle</code></td>
<td>
<p>Angle (on xy plane) to draw piece at</p>
</td></tr>
<tr><td><code id="save_piece_obj_+3A_axis_x">axis_x</code></td>
<td>
<p>First coordinate of the axis unit vector.</p>
</td></tr>
<tr><td><code id="save_piece_obj_+3A_axis_y">axis_y</code></td>
<td>
<p>Second coordinate of the axis unit vector.</p>
</td></tr>
<tr><td><code id="save_piece_obj_+3A_width">width</code></td>
<td>
<p>Width of piece</p>
</td></tr>
<tr><td><code id="save_piece_obj_+3A_height">height</code></td>
<td>
<p>Height of piece</p>
</td></tr>
<tr><td><code id="save_piece_obj_+3A_depth">depth</code></td>
<td>
<p>Depth (thickness) of piece.  Has no effect if <code>op_scale</code> is <code>0</code>.</p>
</td></tr>
<tr><td><code id="save_piece_obj_+3A_filename">filename</code></td>
<td>
<p>Name of Wavefront OBJ object.</p>
</td></tr>
<tr><td><code id="save_piece_obj_+3A_scale">scale</code></td>
<td>
<p>Multiplicative scaling factor to apply to width, height, and depth.</p>
</td></tr>
<tr><td><code id="save_piece_obj_+3A_res">res</code></td>
<td>
<p>Resolution of the faces.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with named elements &quot;obj&quot;, &quot;mtl&quot;, &quot;png&quot; with the created filenames.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+geometry_utils">geometry_utils</a></code> for a discussion of the 3D rotation parameterization.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    if (all(capabilities(c("cairo", "png")))) {
      cfg &lt;- game_systems("sans3d")$dominoes
      files &lt;- save_piece_obj("tile_face", suit = 3+1, rank=6+1, cfg = cfg)
      print(files)
    }
</code></pre>

<hr>
<h2 id='save_print_and_play'>Save piecepack print-and-play (PnP) file</h2><span id='topic+save_print_and_play'></span>

<h3>Description</h3>

<p>Save piecepack print-and-play (PnP) file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save_print_and_play(
  cfg = getOption("piecepackr.cfg", pp_cfg()),
  output_filename = "piecepack.pdf",
  size = c("letter", "A4", "A5", "4x6"),
  pieces = NULL,
  arrangement = c("single-sided", "double-sided"),
  dev = NULL,
  dev.args = list(family = cfg$fontfamily, onefile = TRUE, units = "in", bg = "white",
    res = 300),
  quietly = FALSE,
  ...,
  bleed = FALSE,
  size_bleed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="save_print_and_play_+3A_cfg">cfg</code></td>
<td>
<p>Piecepack configuration list or <code>pp_cfg</code> object</p>
</td></tr>
<tr><td><code id="save_print_and_play_+3A_output_filename">output_filename</code></td>
<td>
<p>Filename for print-and-play file</p>
</td></tr>
<tr><td><code id="save_print_and_play_+3A_size">size</code></td>
<td>
<p>PnP output size (currently supports either &quot;letter&quot;, &quot;A4&quot;, &quot;A5&quot;, or &quot;4x6&quot;).
This is the targeted &ldquo;trim&rdquo; size of the print-and-play file
(<code>size_bleed</code> can be used to make the print-and-play file larger than this).
Size &quot;4x6&quot; currently only supports <code>pieces = "piecepack"</code>
and doesn't support <code>bleed = TRUE</code>.
&quot;A5&quot; is in &ldquo;portrait&rdquo; mode whereas the other sizes are in &ldquo;landscape&rdquo; mode.</p>
</td></tr>
<tr><td><code id="save_print_and_play_+3A_pieces">pieces</code></td>
<td>
<p>Character vector of desired PnP pieces.
Supports &quot;piecepack&quot;, &quot;matchsticks&quot;, &quot;pyramids&quot;, &quot;subpack&quot;, or &quot;all&quot;.
If <code>NULL</code> and combination of <code>size</code> / <code>bleed</code> values supports &quot;matchsticks&quot; and &quot;pyramids&quot;
then defaults to <code>c("piecepack", "pyramids", "matchsticks")</code> else just &quot;piecepack&quot;.</p>
</td></tr>
<tr><td><code id="save_print_and_play_+3A_arrangement">arrangement</code></td>
<td>
<p>Either &quot;single-sided&quot; or &quot;double-sided&quot;.
Ignored if <code>size = "4x6"</code>.</p>
</td></tr>
<tr><td><code id="save_print_and_play_+3A_dev">dev</code></td>
<td>
<p>Graphics device function to use.  If <code>NULL</code> infer a reasonable choice.</p>
</td></tr>
<tr><td><code id="save_print_and_play_+3A_dev.args">dev.args</code></td>
<td>
<p>Additional arguments to pass to <code>dev</code> (besides <code>filename</code>, <code>width</code>, and <code>height</code>).
Will filter out any names that aren't in <code>formals(dev)</code>.</p>
</td></tr>
<tr><td><code id="save_print_and_play_+3A_quietly">quietly</code></td>
<td>
<p>Whether to hide messages about missing metadata
in the provided configuration.</p>
</td></tr>
<tr><td><code id="save_print_and_play_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
<tr><td><code id="save_print_and_play_+3A_bleed">bleed</code></td>
<td>
<p>If <code>TRUE</code> produce a variant print-and-play file with &quot;bleed&quot; zones
and &quot;crop marks&quot; around game pieces.
Currently only supports <code>pieces = "piecepack"</code> and doesn't
support <code>size = "4x6"</code>.</p>
</td></tr>
<tr><td><code id="save_print_and_play_+3A_size_bleed">size_bleed</code></td>
<td>
<p>A list with names &quot;top&quot;, &quot;right&quot;, &quot;bottom&quot;, &quot;left&quot;
containing numeric values indicating the inches &quot;bleed&quot; to add to
the <code>size</code> of the print-and-play layout.
The default <code>NULL</code> means no such bleed added to &quot;letter&quot;, &quot;A4&quot;, &quot;A5&quot;
layouts and a small bleed added to &quot;4x6&quot; layouts
(1/16&quot; to top/bottom and 3/32&quot; to left/right).
NB. multiply millimeters by <code>0.0393700787</code> to convert to inches.
We currently don't support an asymmetric left/right bleed combined with
<code>arrangement = "double-sided"</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># May take more than 5 seconds on CRAN servers
if (capabilities("cairo")) {
  cfg &lt;- pp_cfg(list(invert_colors.suited=TRUE))
  cfg$description &lt;- 'Piecepack with an "inverted" color scheme.'
  cfg$title &lt;- '"Inverted" piecepack'
  cfg$copyright &lt;- "\u00a9 2022 Trevor L Davis.  Some Right Reserved."
  cfg$spdx_id &lt;- "CC-BY-4.0"
  cfg$credit &lt;- ""

  file &lt;- tempfile("my_pnp_file", fileext = ".pdf")
  file_ds &lt;- tempfile("my_pnp_file_ds", fileext = ".pdf")
  file_a4 &lt;- tempfile("my_pnp_file_a4", fileext = ".pdf")
  file_a5 &lt;- tempfile("my_pnp_file_a5", fileext = ".pdf")

  save_print_and_play(cfg, file)
  save_print_and_play(cfg, file_ds, arrangement="double-sided")
  save_print_and_play(cfg, file_a4, size="A4", pieces="all")
  save_print_and_play(cfg, file_a5, size="A5")
}

</code></pre>

<hr>
<h2 id='scale_x_piece'>ggplot2 game diagram scales</h2><span id='topic+scale_x_piece'></span><span id='topic+scale_y_piece'></span><span id='topic+label_letter'></span><span id='topic+label_counting'></span><span id='topic+breaks_counting'></span>

<h3>Description</h3>

<p><code>scale_x_piece()</code> and <code>scale_y_piece()</code> are wrappers
around <code><a href="ggplot2.html#topic+scale_continuous">ggplot2::scale_x_continuous()</a></code> and
<code><a href="ggplot2.html#topic+scale_continuous">ggplot2::scale_y_continuous()</a></code> with &quot;better&quot;
defaults for board game diagrams.
<code>label_letter()</code> labels breaks with letters
and <code>label_counting()</code> labels breaks with positive integers
to more easily generate (i.e. chess) algebraic notation coordinates.
<code>breaks_counting()</code> generates breaks of just the positive integers within the limits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_x_piece(
  ...,
  name = NULL,
  breaks = breaks_counting(),
  minor_breaks = NULL,
  labels = label_letter()
)

scale_y_piece(
  ...,
  name = NULL,
  breaks = breaks_counting(),
  minor_breaks = NULL,
  labels = label_counting()
)

label_letter()

label_counting()

breaks_counting()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_x_piece_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="ggplot2.html#topic+scale_continuous">ggplot2::scale_x_continuous()</a></code> or <code><a href="ggplot2.html#topic+scale_continuous">ggplot2::scale_y_continuous()</a></code>.</p>
</td></tr>
<tr><td><code id="scale_x_piece_+3A_name">name</code></td>
<td>
<p>The name of the scale. Used as the axis or legend title. If
<code>waiver()</code>, the default, the name of the scale is taken from the first
mapping used for that aesthetic. If <code>NULL</code>, the legend title will be
omitted.</p>
</td></tr>
<tr><td><code id="scale_x_piece_+3A_breaks">breaks</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks computed by the
<a href="scales.html#topic+trans_new">transformation object</a>
</p>
</li>
<li><p> A numeric vector of positions
</p>
</li>
<li><p> A function that takes the limits as input and returns breaks
as output (e.g., a function returned by <code><a href="scales.html#topic+breaks_extended">scales::extended_breaks()</a></code>).
Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function notation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale_x_piece_+3A_minor_breaks">minor_breaks</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no minor breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks (one minor break between
each major break)
</p>
</li>
<li><p> A numeric vector of positions
</p>
</li>
<li><p> A function that given the limits returns a vector of minor breaks. Also
accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function notation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale_x_piece_+3A_labels">labels</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no labels
</p>
</li>
<li> <p><code>waiver()</code> for the default labels computed by the
transformation object
</p>
</li>
<li><p> A character vector giving labels (must be same length as <code>breaks</code>)
</p>
</li>
<li><p> An expression vector (must be the same length as breaks). See ?plotmath for details.
</p>
</li>
<li><p> A function that takes the breaks as input and returns labels
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p><code>scale_x_piece()</code> and <code>scale_y_piece()</code> return ggplot2 scale objects.
<code>label_letter()</code> and <code>label_counting()</code> return functions suitable for use with the <code>labels</code> scale argument.
<code>breaks_counting()</code> returns a function suitable for use with the <code>breaks</code> scale argument.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("ggplot2", quietly = TRUE) &amp;&amp; require("tibble", quietly = TRUE)) {
  envir &lt;- game_systems("sans")
  df_board &lt;- tibble(piece_side = "board_face", suit = 3, rank = 8,
                 x = 4.5, y = 4.5)
  df_w &lt;- tibble(piece_side = "bit_face", suit = 6, rank = 1,
                 x = rep(1:8, 2), y = rep(1:2, each=8))
  df_b &lt;- tibble(piece_side = "bit_face", suit = 1, rank = 1,
                 x = rep(1:8, 2), y = rep(7:8, each=8))
  df &lt;- rbind(df_board, df_w, df_b)

  # `cfg` must be a character vector for `geom_piece()`
  ggplot(df, aes_piece(df)) +
      geom_piece(cfg = "checkers1", envir = envir) +
      coord_fixed() +
      scale_x_piece() +
      scale_y_piece() +
      theme_minimal(28) +
      theme(panel.grid = element_blank())
}
</code></pre>

<hr>
<h2 id='spdx_license_list'>SPDX License List data</h2><span id='topic+spdx_license_list'></span>

<h3>Description</h3>

<p><code>spdx_license_list</code> is a data frame of SPDX License List data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spdx_license_list
</code></pre>


<h3>Format</h3>

<p>a data frame with eight variables:
</p>

<dl>
<dt>id</dt><dd><p>SPDX Identifier.</p>
</dd>
<dt>name</dt><dd><p>Full name of license.
For Creative Commons licenses these have been tweaked from the SPDX version
to more closely match the full name used by Creative Commons Foundation. </p>
</dd>
<dt>url</dt><dd><p>URL for copy of license located at <code>spdx.org</code></p>
</dd>
<dt>fsf</dt><dd><p>Is this license considered Free/Libre by the FSF?</p>
</dd>
<dt>osi</dt><dd><p>Is this license OSI approved?</p>
</dd>
<dt>deprecated</dt><dd><p>Has this SPDFX Identifier been deprecated by SPDX?</p>
</dd>
<dt>badge</dt><dd><p>Filename of appropriate &ldquo;button mark&rdquo; badge (if any)
located in <code>system.file("extdata/badges", package = "piecepackr")</code>.</p>
</dd>
<dt>url_alt</dt><dd><p>Alternative URL for license.
Manually created for a subset of Creative Commons licenses.
Others taken from <a href="https://github.com/sindresorhus/spdx-license-list">https://github.com/sindresorhus/spdx-license-list</a>.
</p>
</dd>
</dl>



<h3>See Also</h3>

<p>See <a href="https://spdx.org/licenses/">https://spdx.org/licenses/</a> for more information.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
