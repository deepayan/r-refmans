<!DOCTYPE html><html lang="en"><head><title>Help for package TestFunctions</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {TestFunctions}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_linear_terms'><p>add_linear_terms: Add linear terms to another function.</p>
Allows you to easily change an existing function to include linear terms.</a></li>
<li><a href='#add_noise'><p>add_noise: Adds noise to any function</p></a></li>
<li><a href='#add_null_dims'><p>add_null_dims: Add null dimensions to another function.</p>
Allows you to pass in input data with any number of dimensions and it will only keep the first nactive.</a></li>
<li><a href='#add_zoom'><p>add_zoom: Zoom in on region of another function.</p>
Allows you to easily change an existing function
so that [0,1]^n refers to a subregion of the original function</a></li>
<li><a href='#bananagramacy2Dexp'><p>bananagramacy2Dexp: bananagramacy2Dexp function</p>
6 dimensional function.
First two dimensions are banana function,
next two are the gramacy2Dexp function,
last two are null dimensions</a></li>
<li><a href='#funcprofile'><p>Profile a function</p></a></li>
<li><a href='#nsin'><p>Wave functions</p></a></li>
<li><a href='#numGrad'><p>Create function calculating the numerical gradient</p></a></li>
<li><a href='#numHessian'><p>Create function calculating the numerical hessian</p></a></li>
<li><a href='#RFF'><p>Evaluate an RFF (random wave function) at given input</p></a></li>
<li><a href='#RFF_get'><p>Create a new RFF function</p></a></li>
<li><a href='#standard_test_func'><p>Create a standard test function.</p></a></li>
<li><a href='#subtractlm'><p>Subtract linear model from a function</p></a></li>
<li><a href='#test_func_applyMO'><p>General function for evaluating a test function with multivariate output</p></a></li>
<li><a href='#TF_ackley'><p>TF_ackley: Ackley function for evaluating a single point.</p></a></li>
<li><a href='#TF_bananagramacy2Dexp'><p>TF_bananagramacy2Dexp: bananagramacy2Dexp function for evaluating a single point.</p></a></li>
<li><a href='#TF_bananatimesgramacy2Dexp'><p>TF_bananatimesgramacy2Dexp: bananatimesgramacy2Dexp function for evaluating a single point.</p></a></li>
<li><a href='#TF_beale'><p>TF_beale: Beale function for evaluating a single point.</p></a></li>
<li><a href='#TF_beambending'><p>TF_beambending: beambending function for evaluating a single point.</p></a></li>
<li><a href='#TF_branin'><p>Base test function.</p></a></li>
<li><a href='#TF_chengsandu'><p>TF_chengsandu: chengsandu function for evaluating a single point.</p></a></li>
<li><a href='#TF_detpep8d'><p>TF_detpep8d: detpep8d function for evaluating a single point.</p></a></li>
<li><a href='#TF_easom'><p>TF_easom: Easom function for evaluating a single point.</p></a></li>
<li><a href='#TF_Gfunction'><p>TF_Gfunction: G-function for evaluating a single point.</p></a></li>
<li><a href='#TF_GoldsteinPrice'><p>TF_GoldsteinPrice: Goldstein Price function for evaluating a single point</p></a></li>
<li><a href='#TF_GoldsteinPriceLog'><p>TF_GoldsteinPrice: Goldstein Price function for evaluating a single point</p>
on a log scale, normalized to have mean 0 and variance 1.</a></li>
<li><a href='#TF_gramacy2Dexp'><p>TF_gramacy2Dexp: gramacy2Dexp function for evaluating a single point.</p></a></li>
<li><a href='#TF_gramacy2Dexp3hole'><p>TF_gramacy2Dexp3hole: gramacy2Dexp3hole function for evaluating a single point.</p></a></li>
<li><a href='#TF_gramacy6D'><p>TF_gramacy6D: gramacy6D function for evaluating a single point.</p></a></li>
<li><a href='#TF_griewank'><p>TF_griewank: Griewank function for evaluating a single point.</p></a></li>
<li><a href='#TF_hartmann'><p>TF_hartmann: hartmann function for evaluating a single point.</p></a></li>
<li><a href='#TF_hump'><p>TF_hump: Hump function for evaluating a single point.</p></a></li>
<li><a href='#TF_levy'><p>TF_levy: Levy function for evaluating a single point.</p></a></li>
<li><a href='#TF_levytilt'><p>TF_levytilt: Levy function with a tilt for evaluating a single point.</p></a></li>
<li><a href='#TF_linkletter_nosignal'><p>TF_linkletter_nosignal: Linkletter (2006) no signal function for evaluating a single point.</p></a></li>
<li><a href='#TF_logistic'><p>TF_logistic: logistic function for evaluating a single point.</p></a></li>
<li><a href='#TF_logistic_plateau'><p>TF_logistic_plateau: logistic_plateau function for evaluating a single point.</p></a></li>
<li><a href='#TF_logistic15'><p>TF_logistic15: logistic15 function for evaluating a single point.</p>
Same as logistic except adjusted to be reasonable from 0 to 1.</a></li>
<li><a href='#TF_michalewicz'><p>TF_michalewicz: Michalewicz function for evaluating a single point.</p></a></li>
<li><a href='#TF_moon_high'><p>TF_moon_high: Moon (2010) high-dimensional function for evaluating a single point.</p></a></li>
<li><a href='#TF_morris'><p>TF_morris: morris function for evaluating a single point.</p></a></li>
<li><a href='#TF_piston'><p>TF_piston: Piston simulation function for evaluating a single point.</p></a></li>
<li><a href='#TF_quad_peaks'><p>TF_quad_peaks: quad_peaks function for evaluating a single point.</p></a></li>
<li><a href='#TF_quad_peaks_slant'><p>TF_quad_peaks_slant: quad_peaks_slant function for evaluating a single point.</p></a></li>
<li><a href='#TF_rastrigin'><p>TF_rastrigin: Rastrigin function for evaluating a single point.</p></a></li>
<li><a href='#TF_robotarm'><p>TF_robotarm: Robot arm function for evaluating a single point.</p></a></li>
<li><a href='#TF_RoosArnold'><p>TF_RoosArnold: Roos &amp; Arnold (1963) function for evaluating a single point.</p></a></li>
<li><a href='#TF_steelcolumnstress'><p>TF_steelcolumnstress: steelcolumnstress function for evaluating a single point.</p></a></li>
<li><a href='#TF_SWNExpCos'><p>TF_SWNExpCos: SWNExpCos function for evaluating a single point.</p></a></li>
<li><a href='#TF_vertigrad'><p>TF_vertigrad: vertigrad function for evaluating a single point.</p></a></li>
<li><a href='#TF_vertigrad_grad'><p>TF_vertigrad_grad: vertigrad_grad function for evaluating a single point.</p></a></li>
<li><a href='#TF_welch'><p>TF_welch: Welch function for evaluating a single point.</p></a></li>
<li><a href='#TF_wingweight'><p>TF_wingweight: Wing weight function for evaluating a single point.</p></a></li>
<li><a href='#TF_winkel'><p>TF_winkel: winkel function for evaluating a single point.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Test Functions for Simulation Experiments and Evaluating
Optimization and Emulation Algorithms</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.2</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Collin Erickson &lt;collinberickson@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Test functions are often used to test computer code.
  They are used in optimization to test algorithms and in
  metamodeling to evaluate model predictions. This package provides
  test functions that can be used for any purpose.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>ContourFunctions, numDeriv, rmarkdown</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, covr, ggplot2, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-14 04:20:38 UTC; colli</td>
</tr>
<tr>
<td>Author:</td>
<td>Collin Erickson [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-15 04:10:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_linear_terms'>add_linear_terms: Add linear terms to another function.
Allows you to easily change an existing function to include linear terms.</h2><span id='topic+add_linear_terms'></span>

<h3>Description</h3>

<p>add_linear_terms: Add linear terms to another function.
Allows you to easily change an existing function to include linear terms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_linear_terms(func, coeffs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_linear_terms_+3A_func">func</code></td>
<td>
<p>Function to add linear terms to</p>
</td></tr>
<tr><td><code id="add_linear_terms_+3A_coeffs">coeffs</code></td>
<td>
<p>Linear coefficients, should have same length as function has dimensions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function with added linear terms
</p>


<h3>Examples</h3>

<pre><code class='language-R'>banana(c(.1,.2))
add_linear_terms(banana, coeffs=c(10,1000))(c(.1,.2))
</code></pre>

<hr>
<h2 id='add_noise'>add_noise: Adds noise to any function</h2><span id='topic+add_noise'></span>

<h3>Description</h3>

<p>add_noise: Adds noise to any function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_noise(func, noise = 0, noise_type = "Gauss")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_noise_+3A_func">func</code></td>
<td>
<p>Function to add noise to.</p>
</td></tr>
<tr><td><code id="add_noise_+3A_noise">noise</code></td>
<td>
<p>Standard deviation of Gaussian noise</p>
</td></tr>
<tr><td><code id="add_noise_+3A_noise_type">noise_type</code></td>
<td>
<p>Type of noise, only option now is &quot;Gauss&quot; for Gaussian noise.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function that has noise
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tf &lt;- add_noise(function(x)sin(2*x*pi));curve(tf)
tf &lt;- add_noise(function(x)sin(2*x*pi), noise=.1);curve(tf)
</code></pre>

<hr>
<h2 id='add_null_dims'>add_null_dims: Add null dimensions to another function.
Allows you to pass in input data with any number of dimensions and it will only keep the first nactive.</h2><span id='topic+add_null_dims'></span>

<h3>Description</h3>

<p>add_null_dims: Add null dimensions to another function.
Allows you to pass in input data with any number of dimensions and it will only keep the first nactive.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_null_dims(func, nactive)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_null_dims_+3A_func">func</code></td>
<td>
<p>Function to add null dimensions to</p>
</td></tr>
<tr><td><code id="add_null_dims_+3A_nactive">nactive</code></td>
<td>
<p>Number of active dimensions in func</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function that can take any dimensional input
</p>


<h3>Examples</h3>

<pre><code class='language-R'>banana(c(.1,.2))
# banana(c(.1,.2,.4,.5,.6,.7,.8)) # gives warning
add_null_dims(banana, nact=2)(c(.1,.2,.4,.5,.6,.7,.8))
</code></pre>

<hr>
<h2 id='add_zoom'>add_zoom: Zoom in on region of another function.
Allows you to easily change an existing function
so that [0,1]^n refers to a subregion of the original function</h2><span id='topic+add_zoom'></span>

<h3>Description</h3>

<p>add_zoom: Zoom in on region of another function.
Allows you to easily change an existing function
so that [0,1]^n refers to a subregion of the original function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_zoom(func, scale_low, scale_high)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_zoom_+3A_func">func</code></td>
<td>
<p>Function to add linear terms to</p>
</td></tr>
<tr><td><code id="add_zoom_+3A_scale_low">scale_low</code></td>
<td>
<p>Vector of low end of scale values for each dimension</p>
</td></tr>
<tr><td><code id="add_zoom_+3A_scale_high">scale_high</code></td>
<td>
<p>Vector of high end of scale values for each dimension</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function with added linear terms
</p>


<h3>Examples</h3>

<pre><code class='language-R'>banana(c(.5,.85))
add_zoom(banana, c(0,.5), c(1,1))(c(.5,.7))
add_zoom(banana, c(.2,.5), c(.8,1))(matrix(c(.5,.7),ncol=2))
ContourFunctions::cf(banana)
ContourFunctions::cf(add_zoom(banana, c(0,.5), c(1,1)))
ContourFunctions::cf(add_zoom(banana, c(.2,.5), c(.8,1)))
</code></pre>

<hr>
<h2 id='bananagramacy2Dexp'>bananagramacy2Dexp: bananagramacy2Dexp function
6 dimensional function.
First two dimensions are banana function,
next two are the gramacy2Dexp function,
last two are null dimensions</h2><span id='topic+bananagramacy2Dexp'></span><span id='topic+bananatimesgramacy2Dexp'></span><span id='topic+gramacy2Dexp'></span><span id='topic+gramacy2Dexp3hole'></span><span id='topic+gramacy6D'></span><span id='topic+branin'></span><span id='topic+borehole'></span><span id='topic+franke'></span><span id='topic+zhou1998'></span><span id='topic+currin1991'></span><span id='topic+currin1991b'></span><span id='topic+limpoly'></span><span id='topic+limnonpoly'></span><span id='topic+banana'></span><span id='topic+banana_grad'></span><span id='topic+gaussian1'></span><span id='topic+sinumoid'></span><span id='topic+waterfall'></span><span id='topic+sqrtsin'></span><span id='topic+powsin'></span><span id='topic+OTL_Circuit'></span><span id='topic+GoldsteinPrice'></span><span id='topic+GoldsteinPriceLog'></span><span id='topic+ackley'></span><span id='topic+piston'></span><span id='topic+wingweight'></span><span id='topic+welch'></span><span id='topic+robotarm'></span><span id='topic+RoosArnold'></span><span id='topic+Gfunction'></span><span id='topic+beale'></span><span id='topic+easom'></span><span id='topic+griewank'></span><span id='topic+hump'></span><span id='topic+levy'></span><span id='topic+levytilt'></span><span id='topic+michalewicz'></span><span id='topic+rastrigin'></span><span id='topic+moon_high'></span><span id='topic+linkletter_nosignal'></span><span id='topic+morris'></span><span id='topic+detpep8d'></span><span id='topic+hartmann'></span><span id='topic+quad_peaks'></span><span id='topic+quad_peaks_slant'></span><span id='topic+SWNExpCos'></span><span id='topic+logistic'></span><span id='topic+logistic15'></span><span id='topic+logistic_plateau'></span><span id='topic+vertigrad'></span><span id='topic+vertigrad_grad'></span><span id='topic+beambending'></span><span id='topic+chengsandu'></span><span id='topic+steelcolumnstress'></span><span id='topic+winkel'></span><span id='topic+boreholeMV'></span><span id='topic+test_func_apply'></span>

<h3>Description</h3>

<p>branin: A function.
2 dimensional function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bananagramacy2Dexp(
  x,
  scale_it = T,
  scale_low = 0,
  scale_high = 1,
  noise = 0,
  ...
)

bananatimesgramacy2Dexp(
  x,
  scale_it = T,
  scale_low = 0,
  scale_high = 1,
  noise = 0,
  ...
)

gramacy2Dexp(x, scale_it = T, scale_low = -2, scale_high = 6, noise = 0, ...)

gramacy2Dexp3hole(
  x,
  scale_it = T,
  scale_low = 0,
  scale_high = 1,
  noise = 0,
  ...
)

gramacy6D(x, scale_it = T, scale_low = 0, scale_high = 1, noise = 0, ...)

branin(
  x,
  scale_it = T,
  scale_low = c(-5, 0),
  scale_high = c(10, 15),
  noise = 0
)

borehole(
  x,
  scale_it = T,
  scale_low = c(0.05, 100, 63070, 990, 63.1, 700, 1120, 9855),
  scale_high = c(0.15, 50000, 115600, 1110, 116, 820, 1680, 12045),
  noise = 0
)

franke(x, scale_it = F, scale_low = c(0, 0), scale_high = c(1, 1), noise = 0)

zhou1998(x, scale_it = F, scale_low = c(0, 0), scale_high = c(1, 1), noise = 0)

currin1991(
  x,
  scale_it = F,
  scale_low = c(0, 0),
  scale_high = c(1, 1),
  noise = 0
)

currin1991b(
  x,
  scale_it = F,
  scale_low = c(0, 0),
  scale_high = c(1, 1),
  noise = 0
)

limpoly(x, scale_it = F, scale_low = c(0, 0), scale_high = c(1, 1), noise = 0)

limnonpoly(
  x,
  scale_it = F,
  scale_low = c(0, 0),
  scale_high = c(1, 1),
  noise = 0
)

banana(
  x,
  scale_it = T,
  scale_low = c(-20, -10),
  scale_high = c(20, 5),
  noise = 0
)

banana_grad(
  x,
  scale_it = T,
  scale_low = c(-20, -10),
  scale_high = c(20, 5),
  noise = 0
)

gaussian1(
  x,
  scale_it = F,
  scale_low = c(0, 0),
  scale_high = c(1, 1),
  noise = 0
)

sinumoid(x, scale_it = F, scale_low = c(0, 0), scale_high = c(1, 1), noise = 0)

waterfall(
  x,
  scale_it = F,
  scale_low = c(0, 0),
  scale_high = c(1, 1),
  noise = 0
)

sqrtsin(
  x,
  scale_it = F,
  scale_low = c(0, 0),
  scale_high = c(1, 1),
  noise = 0,
  freq = 2 * pi
)

powsin(
  x,
  scale_it = F,
  scale_low = c(0, 0),
  scale_high = c(1, 1),
  noise = 0,
  freq = 2 * pi,
  pow = 0.7
)

OTL_Circuit(
  x,
  scale_it = T,
  scale_low = c(50, 25, 0.5, 1.2, 0.25, 50),
  scale_high = c(150, 70, 3, 2.5, 1.2, 300),
  noise = 0
)

GoldsteinPrice(
  x,
  scale_it = T,
  scale_low = c(-2, -2),
  scale_high = c(2, 2),
  noise = 0
)

GoldsteinPriceLog(
  x,
  scale_it = T,
  scale_low = c(-2, -2),
  scale_high = c(2, 2),
  noise = 0
)

ackley(
  x,
  scale_it = T,
  scale_low = -32.768,
  scale_high = 32.768,
  noise = 0,
  a = 20,
  b = 0.2,
  c = 2 * pi
)

piston(
  x,
  scale_it = T,
  scale_low = c(30, 0.005, 0.002, 1000, 90000, 290, 340),
  scale_high = c(60, 0.02, 0.01, 5000, 110000, 296, 360),
  noise = 0
)

wingweight(
  x,
  scale_it = T,
  scale_low = c(150, 220, 6, -10, 16, 0.5, 0.08, 2.5, 1700, 0.025),
  scale_high = c(200, 300, 10, 10, 45, 1, 0.18, 6, 2500, 0.08),
  noise = 0
)

welch(x, scale_it = T, scale_low = c(-0.5), scale_high = c(0.5), noise = 0)

robotarm(
  x,
  scale_it = T,
  scale_low = rep(0, 8),
  scale_high = c(rep(2 * pi, 4), rep(1, 4)),
  noise = 0
)

RoosArnold(x, scale_it = F, scale_low = 0, scale_high = 1, noise = 0)

Gfunction(x, scale_it = F, scale_low = 0, scale_high = 1, noise = 0, ...)

beale(x, scale_it = T, scale_low = -4.5, scale_high = 4.5, noise = 0, ...)

easom(x, scale_it = T, scale_low = -4.5, scale_high = 4.5, noise = 0, ...)

griewank(x, scale_it = T, scale_low = -600, scale_high = 600, noise = 0, ...)

hump(x, scale_it = T, scale_low = -5, scale_high = 5, noise = 0, ...)

levy(x, scale_it = T, scale_low = -10, scale_high = 10, noise = 0, ...)

levytilt(x, scale_it = T, scale_low = 0, scale_high = 1, noise = 0, ...)

michalewicz(x, scale_it = T, scale_low = 0, scale_high = pi, noise = 0, ...)

rastrigin(
  x,
  scale_it = T,
  scale_low = -5.12,
  scale_high = 5.12,
  noise = 0,
  ...
)

moon_high(x, scale_it = F, scale_low = 0, scale_high = 1, noise = 0, ...)

linkletter_nosignal(
  x,
  scale_it = F,
  scale_low = 0,
  scale_high = 1,
  noise = 0,
  ...
)

morris(x, scale_it = T, scale_low = 0, scale_high = 1, noise = 0, ...)

detpep8d(x, scale_it = T, scale_low = 0, scale_high = 1, noise = 0, ...)

hartmann(x, scale_it = F, scale_low = 0, scale_high = 1, noise = 0, ...)

quad_peaks(x, scale_it = T, scale_low = 0, scale_high = 1, noise = 0, ...)

quad_peaks_slant(
  x,
  scale_it = T,
  scale_low = 0,
  scale_high = 1,
  noise = 0,
  ...
)

SWNExpCos(x, scale_it = T, scale_low = 0, scale_high = 1, noise = 0, ...)

logistic(x, scale_it = T, scale_low = 0, scale_high = 1, noise = 0, ...)

logistic15(x, scale_it = T, scale_low = 0, scale_high = 1, noise = 0, ...)

logistic_plateau(
  x,
  scale_it = T,
  scale_low = 0,
  scale_high = 1,
  noise = 0,
  ...
)

vertigrad(x, scale_it = T, scale_low = 0, scale_high = 1, noise = 0, ...)

vertigrad_grad(x, scale_it = T, scale_low = 0, scale_high = 1, noise = 0, ...)

beambending(
  x,
  scale_it = T,
  scale_low = c(10, 1, 0.1),
  scale_high = c(20, 2, 0.2),
  noise = 0,
  ...
)

chengsandu(x, scale_it = T, scale_low = 0, scale_high = 1, noise = 0, ...)

steelcolumnstress(
  x,
  scale_it = T,
  scale_low = c(330, 4e+05, 420000, 420000, 200, 10, 100, 10, 12600),
  scale_high = c(470, 6e+05, 780000, 780000, 400, 30, 500, 50, 29400),
  noise = 0,
  ...
)

winkel(x, scale_it = T, scale_low = 0, scale_high = 1, noise = 0, ...)

boreholeMV(
  x,
  NOD = 51,
  scale_it = T,
  scale_low = c(0.05, 100, 63070, 990, 63.1, 700, 1120, 9855),
  scale_high = c(0.15, 50000, 115600, 1110, 116, 820, 1680, 12045),
  noise = 0
)

test_func_apply(func, x, scale_it, scale_low, scale_high, noise = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bananagramacy2Dexp_+3A_x">x</code></td>
<td>
<p>Input value, either a matrix whose rows are points or
a vector for a single point. Be careful with 1-D functions.</p>
</td></tr>
<tr><td><code id="bananagramacy2Dexp_+3A_scale_it">scale_it</code></td>
<td>
<p>Should the data be scaled from [0, 1]^D to
[scale_low, scale_high]? This means the input data is confined
to be in [0, 1]^D, but the function isn't.</p>
</td></tr>
<tr><td><code id="bananagramacy2Dexp_+3A_scale_low">scale_low</code></td>
<td>
<p>Lower bound for each variable</p>
</td></tr>
<tr><td><code id="bananagramacy2Dexp_+3A_scale_high">scale_high</code></td>
<td>
<p>Upper bound for each variable</p>
</td></tr>
<tr><td><code id="bananagramacy2Dexp_+3A_noise">noise</code></td>
<td>
<p>If white noise should be added, specify the
standard deviation for normal noise</p>
</td></tr>
<tr><td><code id="bananagramacy2Dexp_+3A_...">...</code></td>
<td>
<p>Additional parameters for func</p>
</td></tr>
<tr><td><code id="bananagramacy2Dexp_+3A_freq">freq</code></td>
<td>
<p>Wave frequency for sqrtsin and powsin</p>
</td></tr>
<tr><td><code id="bananagramacy2Dexp_+3A_pow">pow</code></td>
<td>
<p>Power for powsin</p>
</td></tr>
<tr><td><code id="bananagramacy2Dexp_+3A_a">a</code></td>
<td>
<p>A constant for ackley()</p>
</td></tr>
<tr><td><code id="bananagramacy2Dexp_+3A_b">b</code></td>
<td>
<p>A constant for ackley()</p>
</td></tr>
<tr><td><code id="bananagramacy2Dexp_+3A_c">c</code></td>
<td>
<p>A constant for ackley()</p>
</td></tr>
<tr><td><code id="bananagramacy2Dexp_+3A_nod">NOD</code></td>
<td>
<p>number of output dimensions</p>
</td></tr>
<tr><td><code id="bananagramacy2Dexp_+3A_func">func</code></td>
<td>
<p>A function to evaluate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function values at x
</p>


<h3>References</h3>

<p>Gramacy, Robert B., and Herbert KH Lee.
&quot;Adaptive design and analysis of supercomputer experiments.&quot;
Technometrics 51.2 (2009): 130-145.
</p>
<p>Gramacy, Robert B., and Herbert KH Lee.
&quot;Adaptive design and analysis of supercomputer experiments.&quot;
Technometrics 51.2 (2009): 130-145.
</p>
<p>Gramacy, Robert B., and Herbert KH Lee.
&quot;Adaptive design and analysis of supercomputer experiments.&quot;
Technometrics 51.2 (2009): 130-145.
</p>
<p>Dixon, L. C. W. (1978). The global optimization problem: an introduction. Towards Global Optimiation 2, 1-15.
</p>
<p>Morris, M. D., Mitchell, T. J., &amp; Ylvisaker, D. (1993). Bayesian design and analysis of computer experiments: use of derivatives in surface prediction. Technometrics, 35(3), 243-255.
</p>
<p>Worley, Brian A. Deterministic uncertainty analysis. No. ORNL-6428. Oak Ridge National Lab., TN (USA), 1987.
</p>
<p>Franke, R. (1979). A critical comparison of some methods for interpolation of scattered data. Monterey, California: Naval Postgraduate School. Page 13.
</p>
<p>An, J., &amp; Owen, A. (2001). Quasi-regression. Journal of complexity, 17(4), 588-607.
</p>
<p>Currin, C., Mitchell, T., Morris, M., &amp; Ylvisaker, D. (1991). Bayesian prediction of deterministic functions, with applications to the design and analysis of computer experiments. Journal of the American Statistical Association, 86(416), 953-963.
</p>
<p>Currin, C., Mitchell, T., Morris, M., &amp; Ylvisaker, D. (1991). Bayesian prediction of deterministic functions, with applications to the design and analysis of computer experiments. Journal of the American Statistical Association, 86(416), 953-963.
</p>
<p>Lim, Yong B., Jerome Sacks, W. J. Studden, and William J. Welch.
&quot;Design and analysis of computer experiments when the output is highly
correlated over the input space.&quot;
Canadian Journal of Statistics 30, no. 1 (2002): 109-126.
</p>
<p>Lim, Yong B., Jerome Sacks, W. J. Studden, and William J. Welch.
&quot;Design and analysis of computer experiments when the output is highly
correlated over the input space.&quot;
Canadian Journal of Statistics 30, no. 1 (2002): 109-126.
</p>
<p>Haario, H., Saksman, E., &amp; Tamminen, J. (1999). Adaptive proposal distribution for random walk Metropolis algorithm. Computational Statistics, 14(3), 375-396.
</p>
<p>Joseph, V. R., Dasgupta, T., Tuo, R., &amp; Wu, C. J. (2015). Sequential exploration of complex surfaces using minimum energy designs. Technometrics, 57(1), 64-74.
</p>
<p>Ben-Ari, Einat Neumann, and David M. Steinberg. &quot;Modeling data
from computer experiments: an empirical comparison of kriging with MARS and
projection pursuit regression.&quot; Quality Engineering 19.4 (2007): 327-338.
</p>
<p>Kenett, Ron S., Shelemyahu Zacks, and Daniele Amberti.
Modern Industrial Statistics: with applications in R,
MINITAB and JMP. John Wiley &amp; Sons, 2013.
</p>
<p>Forrester, A., &amp; Keane, A. (2008). Engineering design via surrogate modelling: a practical guide. John Wiley &amp; Sons.
</p>
<p>http://www.abe.ufl.edu/jjones/ABE_5646/2010/Morris.1991
</p>
<p>http://www.tandfonline.com/doi/pdf/10.1198/TECH.2010.09157?needAccess=true
</p>
<p>Santner, T. J., Williams, B. J., &amp; Notz, W. (2003). The Design and Analysis of Computer Experiments. Springer Science &amp; Business Media.
</p>
<p>Cheng, Haiyan, and Adrian Sandu. &quot;Collocation least-squares polynomial chaos method.&quot; In Proceedings of the 2010 Spring Simulation Multiconference, p. 80. Society for Computer Simulation International, 2010.
</p>
<p>Kuschel, Norbert, and Rudiger Rackwitz. &quot;Two basic problems in reliability-based structural optimization.&quot; Mathematical Methods of Operations Research 46, no. 3 (1997): 309-333.
</p>
<p>Prikhodko, Pavel, and Nikita Kotlyarov. &quot;Calibration of Sobol indices estimates in case of noisy output.&quot; arXiv preprint arXiv:1804.00766 (2018).
</p>
<p>Winkel, Munir A., Jonathan W. Stallings, Curt B. Storlie, and
Brian J. Reich. &quot;Sequential Optimization in Locally Important Dimensions.&quot;
arXiv preprint arXiv:1804.10671 (2018).
</p>
<p>Morris, M. D., Mitchell, T. J., &amp; Ylvisaker, D. (1993). Bayesian design and analysis of computer experiments: use of derivatives in surface prediction. Technometrics, 35(3), 243-255.
</p>
<p>Worley, Brian A. Deterministic uncertainty analysis. No. ORNL-6428. Oak Ridge National Lab., TN (USA), 1987.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bananagramacy2Dexp(runif(6))
bananagramacy2Dexp(matrix(runif(6*20),ncol=6))
bananatimesgramacy2Dexp(runif(6))
bananatimesgramacy2Dexp(matrix(runif(6*20),ncol=6))
gramacy2Dexp(runif(2))
gramacy2Dexp(matrix(runif(2*20),ncol=2))
gramacy2Dexp3hole(runif(2))
gramacy2Dexp3hole(matrix(runif(2*20),ncol=2))
gramacy6D(runif(6))
gramacy6D(matrix(runif(6*20),ncol=6))
branin(runif(2))
branin(matrix(runif(20), ncol=2))
borehole(runif(8))
borehole(matrix(runif(80), ncol=8))
franke(runif(2))
zhou1998(runif(2))
currin1991(runif(2))
currin1991b(runif(2))
limpoly(runif(2))
limnonpoly(runif(2))
banana(runif(2))
x &lt;- y &lt;- seq(0, 1, len=100)
z &lt;- outer(x, y, Vectorize(function(a, b){banana(c(a, b))}))
contour(x, y, z)
banana_grad(runif(2))
x &lt;- y &lt;- seq(0, 1, len=100)
z &lt;- outer(x, y, Vectorize(function(a, b){sum(banana_grad(c(a, b))^2)}))
contour(x, y, z)
gaussian1(runif(2))
sinumoid(runif(2))
x &lt;- y &lt;- seq(0, 1, len=100)
z &lt;- outer(x, y, Vectorize(function(a, b){sinumoid(c(a, b))}))
contour(x, y, z)
waterfall(runif(2))
sqrtsin(runif(1))
curve(sqrtsin(matrix(x,ncol=1)))
powsin(runif(1))#,pow=2)
OTL_Circuit(runif(6))
OTL_Circuit(matrix(runif(60),ncol=6))
GoldsteinPrice(runif(2))
GoldsteinPrice(matrix(runif(60),ncol=2))
GoldsteinPriceLog(runif(2))
GoldsteinPriceLog(matrix(runif(60),ncol=2))
ackley(runif(2))
ackley(matrix(runif(60),ncol=2))
piston(runif(7))
piston(matrix(runif(7*20),ncol=7))
wingweight(runif(10))
wingweight(matrix(runif(10*20),ncol=10))
welch(runif(20))
welch(matrix(runif(20*20),ncol=20))
robotarm(runif(8))
robotarm(matrix(runif(8*20),ncol=8))
RoosArnold(runif(8))
RoosArnold(matrix(runif(8*20),ncol=8))
Gfunction(runif(8))
Gfunction(matrix(runif(8*20),ncol=8))
beale(runif(2))
beale(matrix(runif(2*20),ncol=2))
easom(runif(2))
easom(matrix(runif(2*20),ncol=2))
griewank(runif(2))
griewank(matrix(runif(2*20),ncol=2))
hump(runif(2))
hump(matrix(runif(2*20),ncol=2))
levy(runif(2))
levy(matrix(runif(2*20),ncol=2))
levytilt(runif(2))
levytilt(matrix(runif(2*20),ncol=2))
michalewicz(runif(2))
michalewicz(matrix(runif(2*20),ncol=2))
rastrigin(runif(2))
rastrigin(matrix(runif(2*20),ncol=2))
moon_high(runif(20))
moon_high(matrix(runif(20*20),ncol=20))
linkletter_nosignal(runif(2))
linkletter_nosignal(matrix(runif(2*20),ncol=2))
morris(runif(20))
morris(matrix(runif(20*20),ncol=20))
detpep8d(runif(2))
detpep8d(matrix(runif(2*20),ncol=2))
hartmann(runif(2))
hartmann(matrix(runif(6*20),ncol=6))
quad_peaks(runif(2))
quad_peaks(matrix(runif(2*20),ncol=2))
quad_peaks_slant(runif(2))
quad_peaks_slant(matrix(runif(2*20),ncol=2))
SWNExpCos(runif(2))
SWNExpCos(matrix(runif(2*20),ncol=2))
curve(logistic, from=-5,to=5)
curve(logistic(x,offset=.5, scl=15))
logistic(matrix(runif(20),ncol=1))
curve(logistic15)
curve(logistic15(x,offset=.25))
logistic15(matrix(runif(20),ncol=1))
curve(logistic_plateau(matrix(x,ncol=1)))
logistic_plateau(matrix(runif(20),ncol=1))
vertigrad(runif(2))
vertigrad(matrix(runif(2*20),ncol=2))
vertigrad_grad(runif(2))
vertigrad_grad(matrix(runif(2*20),ncol=2))
beambending(runif(3))
beambending(matrix(runif(3*20),ncol=3))
chengsandu(runif(2))
chengsandu(matrix(runif(2*20),ncol=2))
steelcolumnstress(runif(8))
steelcolumnstress(matrix(runif(8*20),ncol=8))
winkel(runif(2))
winkel(matrix(runif(2*20),ncol=2))
boreholeMV(runif(8))
boreholeMV(matrix(runif(80), ncol=8))
x &lt;- matrix(seq(0,1,length.out=10), ncol=1)
y &lt;- test_func_apply(sin, x, TRUE, 0, 2*pi, .05)
plot(x,y)
curve(sin(2*pi*x), col=2, add=TRUE)
</code></pre>

<hr>
<h2 id='funcprofile'>Profile a function</h2><span id='topic+funcprofile'></span>

<h3>Description</h3>

<p>Gives details about how linear it is.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>funcprofile(func, d, n = 1000 * d, bins = 30)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="funcprofile_+3A_func">func</code></td>
<td>
<p>A function with a single output</p>
</td></tr>
<tr><td><code id="funcprofile_+3A_d">d</code></td>
<td>
<p>The number of input dimensions for the function</p>
</td></tr>
<tr><td><code id="funcprofile_+3A_n">n</code></td>
<td>
<p>The number of points to use for the linear model.</p>
</td></tr>
<tr><td><code id="funcprofile_+3A_bins">bins</code></td>
<td>
<p>Number of bins in histogram.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing, prints and plots
</p>


<h3>Examples</h3>

<pre><code class='language-R'>funcprofile(ackley, 2)
</code></pre>

<hr>
<h2 id='nsin'>Wave functions</h2><span id='topic+nsin'></span><span id='topic+vsin'></span>

<h3>Description</h3>

<p>nsin: Block wave
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nsin(xx)

vsin(xx)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nsin_+3A_xx">xx</code></td>
<td>
<p>Input values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nsin evaluated at nsin
</p>


<h3>Examples</h3>

<pre><code class='language-R'>curve(nsin(2*pi*x), n = 1000)
curve(nsin(12*pi*x), n = 1000)
curve(vsin(2*pi*x), n = 1000)
curve(vsin(12*pi*x), n = 1000)
</code></pre>

<hr>
<h2 id='numGrad'>Create function calculating the numerical gradient</h2><span id='topic+numGrad'></span>

<h3>Description</h3>

<p>Create function calculating the numerical gradient
</p>


<h3>Usage</h3>

<pre><code class='language-R'>numGrad(func, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="numGrad_+3A_func">func</code></td>
<td>
<p>Function to get gradient of.</p>
</td></tr>
<tr><td><code id="numGrad_+3A_...">...</code></td>
<td>
<p>Arguments passed to numDeriv::grad().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A gradient function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>numGrad(sin)
</code></pre>

<hr>
<h2 id='numHessian'>Create function calculating the numerical hessian</h2><span id='topic+numHessian'></span>

<h3>Description</h3>

<p>Create function calculating the numerical hessian
</p>


<h3>Usage</h3>

<pre><code class='language-R'>numHessian(func, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="numHessian_+3A_func">func</code></td>
<td>
<p>Function to get hessian of</p>
</td></tr>
<tr><td><code id="numHessian_+3A_...">...</code></td>
<td>
<p>Arguments passed to numDeriv::hessian().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A hessian function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>numHessian(sin)
</code></pre>

<hr>
<h2 id='RFF'>Evaluate an RFF (random wave function) at given input</h2><span id='topic+RFF'></span>

<h3>Description</h3>

<p>Evaluate an RFF (random wave function) at given input
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RFF(x, freq, mag, dirr, offset, wave = sin, noise = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RFF_+3A_x">x</code></td>
<td>
<p>Matrix whose rows are points to evaluate or a vector representing
a single point. In 1 dimension you must use a matrix for multiple points,
not a vector.</p>
</td></tr>
<tr><td><code id="RFF_+3A_freq">freq</code></td>
<td>
<p>Vector of wave frequencies</p>
</td></tr>
<tr><td><code id="RFF_+3A_mag">mag</code></td>
<td>
<p>Vector of wave magnitudes</p>
</td></tr>
<tr><td><code id="RFF_+3A_dirr">dirr</code></td>
<td>
<p>Matrix of wave directions</p>
</td></tr>
<tr><td><code id="RFF_+3A_offset">offset</code></td>
<td>
<p>Vector of wave offsets</p>
</td></tr>
<tr><td><code id="RFF_+3A_wave">wave</code></td>
<td>
<p>Type of wave</p>
</td></tr>
<tr><td><code id="RFF_+3A_noise">noise</code></td>
<td>
<p>Standard deviation of random normal noise to add</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Output of RFF evaluated at x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>curve(RFF(matrix(x,ncol=1),3,1,1,0))
curve(RFF(matrix(x,ncol=1),3,1,1,0, noise=.1), n=1e3, type='p', pch=19)

curve(RFF(matrix(x,ncol=1),c(3,20),c(1,.1),c(1,1),c(0,0)), n=1e3)
</code></pre>

<hr>
<h2 id='RFF_get'>Create a new RFF function</h2><span id='topic+RFF_get'></span>

<h3>Description</h3>

<p>Create a new RFF function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RFF_get(D = 2, M = 30, wave = sin, noise = 0, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RFF_get_+3A_d">D</code></td>
<td>
<p>Number of dimensions</p>
</td></tr>
<tr><td><code id="RFF_get_+3A_m">M</code></td>
<td>
<p>Number of random waves</p>
</td></tr>
<tr><td><code id="RFF_get_+3A_wave">wave</code></td>
<td>
<p>Type of wave</p>
</td></tr>
<tr><td><code id="RFF_get_+3A_noise">noise</code></td>
<td>
<p>Standard deviation of random normal noise to add</p>
</td></tr>
<tr><td><code id="RFF_get_+3A_seed">seed</code></td>
<td>
<p>Seed to set before randomly selecting function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A random wave function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>func &lt;- RFF_get(D=1)
curve(func)

f &lt;- RFF_get(D=1, noise=.1)
curve(f(matrix(x,ncol=1)))
for(i in 1:100) curve(f(matrix(x,ncol=1)), add=TRUE, col=sample(2:8,1))
</code></pre>

<hr>
<h2 id='standard_test_func'>Create a standard test function.</h2><span id='topic+standard_test_func'></span>

<h3>Description</h3>

<p>This makes it easier to create
many functions that follow the same template.
R CMD check doesn't like the ... if this command is used to
create functions in the package, so it is not currently used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standard_test_func(
  func,
  scale_it_ = F,
  scale_low_ = NULL,
  scale_high_ = NULL,
  noise_ = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="standard_test_func_+3A_func">func</code></td>
<td>
<p>A function that takes a vector representing a single point.</p>
</td></tr>
<tr><td><code id="standard_test_func_+3A_scale_it_">scale_it_</code></td>
<td>
<p>Should the function scale the inputs from [0, 1]^D to
[scale_low_, scale_high_] by default? This can be overridden when
actually giving the output function points to evaluate.</p>
</td></tr>
<tr><td><code id="standard_test_func_+3A_scale_low_">scale_low_</code></td>
<td>
<p>What is the default lower bound of the data?</p>
</td></tr>
<tr><td><code id="standard_test_func_+3A_scale_high_">scale_high_</code></td>
<td>
<p>What is the default upper bound of the data?</p>
</td></tr>
<tr><td><code id="standard_test_func_+3A_noise_">noise_</code></td>
<td>
<p>Should noise be added to the function by default?</p>
</td></tr>
<tr><td><code id="standard_test_func_+3A_...">...</code></td>
<td>
<p>Parameters passed to func when evaluating points.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A test function created using the standard_test_func template.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.gaussian1 &lt;- function(x, center=.5, s2=.01) {
  exp(-sum((x-center)^2/2/s2))
}
gaussian1 &lt;- standard_test_func(.gaussian1, scale_it=FALSE, scale_low = c(0,0), scale_high = c(1,1))
curve(gaussian1(matrix(x,ncol=1)))
</code></pre>

<hr>
<h2 id='subtractlm'>Subtract linear model from a function</h2><span id='topic+subtractlm'></span>

<h3>Description</h3>

<p>This returns a new function which a linear model has an r-squared of 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subtractlm(func, d, n = d * 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subtractlm_+3A_func">func</code></td>
<td>
<p>A function</p>
</td></tr>
<tr><td><code id="subtractlm_+3A_d">d</code></td>
<td>
<p>Number of input dimensions</p>
</td></tr>
<tr><td><code id="subtractlm_+3A_n">n</code></td>
<td>
<p>Number of points to use for the linear model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>subtractlm(ackley, 2)


  f &lt;- function(x) {
    if (is.matrix(x)) x[,1]^2
    else x[1]^2
  }
  ContourFunctions::cf(f)
  ContourFunctions::cf(subtractlm(f, 2), batchmax=Inf)

</code></pre>

<hr>
<h2 id='test_func_applyMO'>General function for evaluating a test function with multivariate output</h2><span id='topic+test_func_applyMO'></span>

<h3>Description</h3>

<p>General function for evaluating a test function with multivariate output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_func_applyMO(
  func,
  x,
  numoutdim,
  scale_it,
  scale_low,
  scale_high,
  noise = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test_func_applyMO_+3A_func">func</code></td>
<td>
<p>A function to evaluate</p>
</td></tr>
<tr><td><code id="test_func_applyMO_+3A_x">x</code></td>
<td>
<p>Input value, either a matrix whose rows are points or
a vector for a single point. Be careful with 1-D functions.</p>
</td></tr>
<tr><td><code id="test_func_applyMO_+3A_numoutdim">numoutdim</code></td>
<td>
<p>Number of output dimensions</p>
</td></tr>
<tr><td><code id="test_func_applyMO_+3A_scale_it">scale_it</code></td>
<td>
<p>Should the data be scaled from [0, 1]^D to
[scale_low, scale_high]? This means the input data is confined
to be in [0, 1]^D, but the function isn't.</p>
</td></tr>
<tr><td><code id="test_func_applyMO_+3A_scale_low">scale_low</code></td>
<td>
<p>Lower bound for each variable</p>
</td></tr>
<tr><td><code id="test_func_applyMO_+3A_scale_high">scale_high</code></td>
<td>
<p>Upper bound for each variable</p>
</td></tr>
<tr><td><code id="test_func_applyMO_+3A_noise">noise</code></td>
<td>
<p>If white noise should be added, specify the
standard deviation for normal noise</p>
</td></tr>
<tr><td><code id="test_func_applyMO_+3A_...">...</code></td>
<td>
<p>Additional parameters for func</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function values at x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(seq(0,1,length.out=10), ncol=1)
y &lt;- test_func_apply(sin, x, TRUE, 0, 2*pi, .05)
plot(x,y)
curve(sin(2*pi*x), col=2, add=TRUE)
</code></pre>

<hr>
<h2 id='TF_ackley'>TF_ackley: Ackley function for evaluating a single point.</h2><span id='topic+TF_ackley'></span>

<h3>Description</h3>

<p>TF_ackley: Ackley function for evaluating a single point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TF_ackley(x, a = 20, b = 0.2, c = 2 * pi)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TF_ackley_+3A_x">x</code></td>
<td>
<p>Input vector at which to evaluate.</p>
</td></tr>
<tr><td><code id="TF_ackley_+3A_a">a</code></td>
<td>
<p>A constant for ackley()</p>
</td></tr>
<tr><td><code id="TF_ackley_+3A_b">b</code></td>
<td>
<p>A constant for ackley()</p>
</td></tr>
<tr><td><code id="TF_ackley_+3A_c">c</code></td>
<td>
<p>A constant for ackley()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function output evaluated at x.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TF_ackley(c(0, 0)) # minimum of zero, hard to solve
</code></pre>

<hr>
<h2 id='TF_bananagramacy2Dexp'>TF_bananagramacy2Dexp: bananagramacy2Dexp function for evaluating a single point.</h2><span id='topic+TF_bananagramacy2Dexp'></span>

<h3>Description</h3>

<p>TF_bananagramacy2Dexp: bananagramacy2Dexp function for evaluating a single point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TF_bananagramacy2Dexp(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TF_bananagramacy2Dexp_+3A_x">x</code></td>
<td>
<p>Input vector at which to evaluate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function output evaluated at x.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TF_bananagramacy2Dexp(rep(0,6))
TF_bananagramacy2Dexp(rep(1,6))
</code></pre>

<hr>
<h2 id='TF_bananatimesgramacy2Dexp'>TF_bananatimesgramacy2Dexp: bananatimesgramacy2Dexp function for evaluating a single point.</h2><span id='topic+TF_bananatimesgramacy2Dexp'></span>

<h3>Description</h3>

<p>TF_bananatimesgramacy2Dexp: bananatimesgramacy2Dexp function for evaluating a single point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TF_bananatimesgramacy2Dexp(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TF_bananatimesgramacy2Dexp_+3A_x">x</code></td>
<td>
<p>Input vector at which to evaluate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function output evaluated at x.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TF_bananatimesgramacy2Dexp(rep(0,6))
TF_bananatimesgramacy2Dexp(rep(1,6))
</code></pre>

<hr>
<h2 id='TF_beale'>TF_beale: Beale function for evaluating a single point.</h2><span id='topic+TF_beale'></span>

<h3>Description</h3>

<p>TF_beale: Beale function for evaluating a single point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TF_beale(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TF_beale_+3A_x">x</code></td>
<td>
<p>Input vector at which to evaluate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function output evaluated at x.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TF_beale(rep(0,2))
TF_beale(rep(1,2))
</code></pre>

<hr>
<h2 id='TF_beambending'>TF_beambending: beambending function for evaluating a single point.</h2><span id='topic+TF_beambending'></span>

<h3>Description</h3>

<p>TF_beambending: beambending function for evaluating a single point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TF_beambending(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TF_beambending_+3A_x">x</code></td>
<td>
<p>Input vector at which to evaluate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function output evaluated at x.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TF_beambending(rep(0,3))
TF_beambending(rep(1,3))
</code></pre>

<hr>
<h2 id='TF_branin'>Base test function.</h2><span id='topic+TF_branin'></span><span id='topic+TF_borehole'></span><span id='topic+TF_franke'></span><span id='topic+TF_zhou1998'></span><span id='topic+TF_currin1991'></span><span id='topic+TF_currin1991b'></span><span id='topic+TF_limpoly'></span><span id='topic+TF_limnonpoly'></span><span id='topic+TF_banana'></span><span id='topic+TF_banana_grad'></span><span id='topic+TF_gaussian1'></span><span id='topic+TF_sinumoid'></span><span id='topic+TF_sqrtsin'></span><span id='topic+TF_powsin'></span><span id='topic+TF_OTL_Circuit'></span><span id='topic+TF_boreholeMV'></span>

<h3>Description</h3>

<p>TF_branin: A function taking in a single vector.
2 dimensional function.
See corresponding function with &quot;TF_&quot; for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TF_branin(
  x,
  a = 1,
  b = 5.1/(4 * pi^2),
  cc = 5/pi,
  r = 6,
  s = 10,
  tt = 1/(8 * pi)
)

TF_borehole(x)

TF_franke(x)

TF_zhou1998(x)

TF_currin1991(x)

TF_currin1991b(x)

TF_limpoly(x)

TF_limnonpoly(x)

TF_banana(x)

TF_banana_grad(x, v1, v2)

TF_gaussian1(x, center = 0.5, s2 = 0.01)

TF_sinumoid(x)

TF_sqrtsin(x, freq = 2 * pi)

TF_powsin(x, freq = 2 * pi, pow = 0.7)

TF_OTL_Circuit(x)

TF_boreholeMV(x, NOD = 51)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TF_branin_+3A_x">x</code></td>
<td>
<p>Input vector at which to evaluate.</p>
</td></tr>
<tr><td><code id="TF_branin_+3A_a">a</code></td>
<td>
<p>Parameter for TF_branin</p>
</td></tr>
<tr><td><code id="TF_branin_+3A_b">b</code></td>
<td>
<p>Parameter for TF_branin</p>
</td></tr>
<tr><td><code id="TF_branin_+3A_cc">cc</code></td>
<td>
<p>Parameter for TF_branin</p>
</td></tr>
<tr><td><code id="TF_branin_+3A_r">r</code></td>
<td>
<p>Parameter for TF_branin</p>
</td></tr>
<tr><td><code id="TF_branin_+3A_s">s</code></td>
<td>
<p>Parameter for TF_branin</p>
</td></tr>
<tr><td><code id="TF_branin_+3A_tt">tt</code></td>
<td>
<p>Parameter for TF_branin</p>
</td></tr>
<tr><td><code id="TF_branin_+3A_v1">v1</code></td>
<td>
<p>Scale parameter for first dimension</p>
</td></tr>
<tr><td><code id="TF_branin_+3A_v2">v2</code></td>
<td>
<p>Scale parameter for second dimension</p>
</td></tr>
<tr><td><code id="TF_branin_+3A_center">center</code></td>
<td>
<p>Where to center the function, a vector.</p>
</td></tr>
<tr><td><code id="TF_branin_+3A_s2">s2</code></td>
<td>
<p>Variance of the Gaussian.</p>
</td></tr>
<tr><td><code id="TF_branin_+3A_freq">freq</code></td>
<td>
<p>Wave frequency for TF_sqrtsin and TF_powsin</p>
</td></tr>
<tr><td><code id="TF_branin_+3A_pow">pow</code></td>
<td>
<p>Power to raise wave to for TF_powsin.</p>
</td></tr>
<tr><td><code id="TF_branin_+3A_nod">NOD</code></td>
<td>
<p>number of output dimensions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function output evaluated at x.
</p>


<h3>References</h3>

<p>Dixon, L. C. W. (1978). The global optimization problem: an introduction. Towards Global Optimiation 2, 1-15.
</p>
<p>Morris, M. D., Mitchell, T. J., &amp; Ylvisaker, D. (1993). Bayesian design and analysis of computer experiments: use of derivatives in surface prediction. Technometrics, 35(3), 243-255.
</p>
<p>Worley, Brian A. Deterministic uncertainty analysis. No. ORNL-6428. Oak Ridge National Lab., TN (USA), 1987.
</p>
<p>Franke, R. (1979). A critical comparison of some methods for interpolation of scattered data. Monterey, California: Naval Postgraduate School. Page 13.
</p>
<p>An, J., &amp; Owen, A. (2001). Quasi-regression. Journal of complexity, 17(4), 588-607.
</p>
<p>Currin, C., Mitchell, T., Morris, M., &amp; Ylvisaker, D. (1991). Bayesian prediction of deterministic functions, with applications to the design and analysis of computer experiments. Journal of the American Statistical Association, 86(416), 953-963.
</p>
<p>Currin, C., Mitchell, T., Morris, M., &amp; Ylvisaker, D. (1991). Bayesian prediction of deterministic functions, with applications to the design and analysis of computer experiments. Journal of the American Statistical Association, 86(416), 953-963.
</p>
<p>Haario, H., Saksman, E., &amp; Tamminen, J. (1999). Adaptive proposal distribution for random walk Metropolis algorithm. Computational Statistics, 14(3), 375-396.
</p>
<p>Joseph, V. R., Dasgupta, T., Tuo, R., &amp; Wu, C. J. (2015). Sequential exploration of complex surfaces using minimum energy designs. Technometrics, 57(1), 64-74.
</p>
<p>Ben-Ari, Einat Neumann, and David M. Steinberg. &quot;Modeling data
from computer experiments: an empirical comparison of kriging with MARS and
projection pursuit regression.&quot; Quality Engineering 19.4 (2007): 327-338.
</p>
<p>Morris, M. D., Mitchell, T. J., &amp; Ylvisaker, D. (1993). Bayesian design and analysis of computer experiments: use of derivatives in surface prediction. Technometrics, 35(3), 243-255.
</p>
<p>Worley, Brian A. Deterministic uncertainty analysis. No. ORNL-6428. Oak Ridge National Lab., TN (USA), 1987.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TF_branin(runif(2))
TF_borehole(runif(8))
TF_franke(runif(2))
TF_zhou1998(runif(2))
TF_currin1991(runif(2))
TF_currin1991b(runif(2))
TF_limpoly(runif(2))
TF_limnonpoly(runif(2))
TF_banana(runif(2))
TF_banana_grad(runif(2), v1=40, v2=15)
TF_gaussian1(runif(2))
TF_sinumoid(runif(2))
TF_sqrtsin(runif(2))
TF_powsin(runif(2))
TF_OTL_Circuit(c(50,25,0.5,1.2,0.25,50))
TF_boreholeMV(runif(8))
</code></pre>

<hr>
<h2 id='TF_chengsandu'>TF_chengsandu: chengsandu function for evaluating a single point.</h2><span id='topic+TF_chengsandu'></span>

<h3>Description</h3>

<p>TF_chengsandu: chengsandu function for evaluating a single point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TF_chengsandu(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TF_chengsandu_+3A_x">x</code></td>
<td>
<p>Input vector at which to evaluate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function output evaluated at x.
</p>


<h3>References</h3>

<p>Cheng, Haiyan, and Adrian Sandu. &quot;Collocation least-squares polynomial chaos method.&quot; In Proceedings of the 2010 Spring Simulation Multiconference, p. 80. Society for Computer Simulation International, 2010.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TF_chengsandu(rep(0,2))
TF_chengsandu(rep(1,2))
</code></pre>

<hr>
<h2 id='TF_detpep8d'>TF_detpep8d: detpep8d function for evaluating a single point.</h2><span id='topic+TF_detpep8d'></span>

<h3>Description</h3>

<p>TF_detpep8d: detpep8d function for evaluating a single point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TF_detpep8d(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TF_detpep8d_+3A_x">x</code></td>
<td>
<p>Input vector at which to evaluate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function output evaluated at x.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TF_detpep8d(rep(0,2))
TF_detpep8d(rep(1,2))
</code></pre>

<hr>
<h2 id='TF_easom'>TF_easom: Easom function for evaluating a single point.</h2><span id='topic+TF_easom'></span>

<h3>Description</h3>

<p>TF_easom: Easom function for evaluating a single point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TF_easom(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TF_easom_+3A_x">x</code></td>
<td>
<p>Input vector at which to evaluate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function output evaluated at x.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TF_easom(rep(0,2))
TF_easom(rep(1,2))
</code></pre>

<hr>
<h2 id='TF_Gfunction'>TF_Gfunction: G-function for evaluating a single point.</h2><span id='topic+TF_Gfunction'></span>

<h3>Description</h3>

<p>TF_Gfunction: G-function for evaluating a single point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TF_Gfunction(x, a = (1:length(x) - 1)/2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TF_Gfunction_+3A_x">x</code></td>
<td>
<p>Input vector at which to evaluate.</p>
</td></tr>
<tr><td><code id="TF_Gfunction_+3A_a">a</code></td>
<td>
<p>Parameter for Gfunction</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function output evaluated at x.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TF_Gfunction(rep(0,8))
TF_Gfunction(rep(1,8))
</code></pre>

<hr>
<h2 id='TF_GoldsteinPrice'>TF_GoldsteinPrice: Goldstein Price function for evaluating a single point</h2><span id='topic+TF_GoldsteinPrice'></span>

<h3>Description</h3>

<p>TF_GoldsteinPrice: Goldstein Price function for evaluating a single point
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TF_GoldsteinPrice(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TF_GoldsteinPrice_+3A_x">x</code></td>
<td>
<p>Input vector at which to evaluate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function output evaluated at x.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TF_GoldsteinPrice(c(0, -1)) # minimum
</code></pre>

<hr>
<h2 id='TF_GoldsteinPriceLog'>TF_GoldsteinPrice: Goldstein Price function for evaluating a single point
on a log scale, normalized to have mean 0 and variance 1.</h2><span id='topic+TF_GoldsteinPriceLog'></span>

<h3>Description</h3>

<p>TF_GoldsteinPrice: Goldstein Price function for evaluating a single point
on a log scale, normalized to have mean 0 and variance 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TF_GoldsteinPriceLog(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TF_GoldsteinPriceLog_+3A_x">x</code></td>
<td>
<p>Input vector at which to evaluate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function output evaluated at x.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TF_GoldsteinPriceLog(c(0, -1)) # minimum
</code></pre>

<hr>
<h2 id='TF_gramacy2Dexp'>TF_gramacy2Dexp: gramacy2Dexp function for evaluating a single point.</h2><span id='topic+TF_gramacy2Dexp'></span>

<h3>Description</h3>

<p>TF_gramacy2Dexp: gramacy2Dexp function for evaluating a single point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TF_gramacy2Dexp(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TF_gramacy2Dexp_+3A_x">x</code></td>
<td>
<p>Input vector at which to evaluate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function output evaluated at x.
</p>


<h3>References</h3>

<p>Gramacy, Robert B., and Herbert KH Lee.
&quot;Adaptive design and analysis of supercomputer experiments.&quot;
Technometrics 51.2 (2009): 130-145.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TF_gramacy2Dexp(rep(0,2))
TF_gramacy2Dexp(rep(1,2))
</code></pre>

<hr>
<h2 id='TF_gramacy2Dexp3hole'>TF_gramacy2Dexp3hole: gramacy2Dexp3hole function for evaluating a single point.</h2><span id='topic+TF_gramacy2Dexp3hole'></span>

<h3>Description</h3>

<p>TF_gramacy2Dexp3hole: gramacy2Dexp3hole function for evaluating a single point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TF_gramacy2Dexp3hole(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TF_gramacy2Dexp3hole_+3A_x">x</code></td>
<td>
<p>Input vector at which to evaluate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function output evaluated at x.
</p>


<h3>References</h3>

<p>Gramacy, Robert B., and Herbert KH Lee.
&quot;Adaptive design and analysis of supercomputer experiments.&quot;
Technometrics 51.2 (2009): 130-145.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TF_gramacy2Dexp3hole(rep(0,2))
TF_gramacy2Dexp3hole(rep(1,2))
</code></pre>

<hr>
<h2 id='TF_gramacy6D'>TF_gramacy6D: gramacy6D function for evaluating a single point.</h2><span id='topic+TF_gramacy6D'></span>

<h3>Description</h3>

<p>From Gramacy and Lee (2009).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TF_gramacy6D(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TF_gramacy6D_+3A_x">x</code></td>
<td>
<p>Input vector at which to evaluate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function output evaluated at x.
</p>


<h3>References</h3>

<p>Gramacy, Robert B., and Herbert KH Lee.
&quot;Adaptive design and analysis of supercomputer experiments.&quot;
Technometrics 51.2 (2009): 130-145.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TF_gramacy6D(rep(0,6))
TF_gramacy6D(rep(1,6))
</code></pre>

<hr>
<h2 id='TF_griewank'>TF_griewank: Griewank function for evaluating a single point.</h2><span id='topic+TF_griewank'></span>

<h3>Description</h3>

<p>TF_griewank: Griewank function for evaluating a single point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TF_griewank(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TF_griewank_+3A_x">x</code></td>
<td>
<p>Input vector at which to evaluate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function output evaluated at x.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TF_griewank(rep(0,2))
TF_griewank(rep(1,2))
</code></pre>

<hr>
<h2 id='TF_hartmann'>TF_hartmann: hartmann function for evaluating a single point.</h2><span id='topic+TF_hartmann'></span>

<h3>Description</h3>

<p>TF_hartmann: hartmann function for evaluating a single point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TF_hartmann(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TF_hartmann_+3A_x">x</code></td>
<td>
<p>Input vector at which to evaluate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function output evaluated at x.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TF_hartmann(rep(0,6))
TF_hartmann(rep(1,6))
TF_hartmann(c(.20169, .150011, .476874, .275332, .311652, .6573)) # Global minimum of -3.322368
</code></pre>

<hr>
<h2 id='TF_hump'>TF_hump: Hump function for evaluating a single point.</h2><span id='topic+TF_hump'></span>

<h3>Description</h3>

<p>TF_hump: Hump function for evaluating a single point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TF_hump(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TF_hump_+3A_x">x</code></td>
<td>
<p>Input vector at which to evaluate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function output evaluated at x.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TF_hump(rep(0,2))
TF_hump(rep(1,2))
</code></pre>

<hr>
<h2 id='TF_levy'>TF_levy: Levy function for evaluating a single point.</h2><span id='topic+TF_levy'></span>

<h3>Description</h3>

<p>TF_levy: Levy function for evaluating a single point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TF_levy(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TF_levy_+3A_x">x</code></td>
<td>
<p>Input vector at which to evaluate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function output evaluated at x.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TF_levy(rep(0,2))
TF_levy(rep(1,2))
</code></pre>

<hr>
<h2 id='TF_levytilt'>TF_levytilt: Levy function with a tilt for evaluating a single point.</h2><span id='topic+TF_levytilt'></span>

<h3>Description</h3>

<p>TF_levytilt: Levy function with a tilt for evaluating a single point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TF_levytilt(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TF_levytilt_+3A_x">x</code></td>
<td>
<p>Input vector at which to evaluate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function output evaluated at x.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TF_levytilt(rep(0,2))
TF_levytilt(rep(1,2))
</code></pre>

<hr>
<h2 id='TF_linkletter_nosignal'>TF_linkletter_nosignal: Linkletter (2006) no signal function for evaluating a single point.</h2><span id='topic+TF_linkletter_nosignal'></span>

<h3>Description</h3>

<p>TF_linkletter_nosignal: Linkletter (2006) no signal function for evaluating a single point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TF_linkletter_nosignal(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TF_linkletter_nosignal_+3A_x">x</code></td>
<td>
<p>Input vector at which to evaluate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function output evaluated at x.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TF_linkletter_nosignal(rep(0,2))
TF_linkletter_nosignal(rep(1,2))
</code></pre>

<hr>
<h2 id='TF_logistic'>TF_logistic: logistic function for evaluating a single point.</h2><span id='topic+TF_logistic'></span>

<h3>Description</h3>

<p>TF_logistic: logistic function for evaluating a single point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TF_logistic(x, offset = 0, scl = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TF_logistic_+3A_x">x</code></td>
<td>
<p>Input vector at which to evaluate.</p>
</td></tr>
<tr><td><code id="TF_logistic_+3A_offset">offset</code></td>
<td>
<p>Amount it should be offset</p>
</td></tr>
<tr><td><code id="TF_logistic_+3A_scl">scl</code></td>
<td>
<p>Scale parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function output evaluated at x.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TF_logistic(0)
TF_logistic(1)
</code></pre>

<hr>
<h2 id='TF_logistic_plateau'>TF_logistic_plateau: logistic_plateau function for evaluating a single point.</h2><span id='topic+TF_logistic_plateau'></span>

<h3>Description</h3>

<p>TF_logistic_plateau: logistic_plateau function for evaluating a single point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TF_logistic_plateau(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TF_logistic_plateau_+3A_x">x</code></td>
<td>
<p>Input vector at which to evaluate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function output evaluated at x.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TF_logistic_plateau(0)
TF_logistic_plateau(.5)
</code></pre>

<hr>
<h2 id='TF_logistic15'>TF_logistic15: logistic15 function for evaluating a single point.
Same as logistic except adjusted to be reasonable from 0 to 1.</h2><span id='topic+TF_logistic15'></span>

<h3>Description</h3>

<p>TF_logistic15: logistic15 function for evaluating a single point.
Same as logistic except adjusted to be reasonable from 0 to 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TF_logistic15(x, offset = 0.5, scl = 15)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TF_logistic15_+3A_x">x</code></td>
<td>
<p>Input vector at which to evaluate.</p>
</td></tr>
<tr><td><code id="TF_logistic15_+3A_offset">offset</code></td>
<td>
<p>Amount it should be offset</p>
</td></tr>
<tr><td><code id="TF_logistic15_+3A_scl">scl</code></td>
<td>
<p>Scale parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function output evaluated at x.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TF_logistic15(0)
TF_logistic15(1)
curve(Vectorize(TF_logistic15)(x))
</code></pre>

<hr>
<h2 id='TF_michalewicz'>TF_michalewicz: Michalewicz function for evaluating a single point.</h2><span id='topic+TF_michalewicz'></span>

<h3>Description</h3>

<p>TF_michalewicz: Michalewicz function for evaluating a single point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TF_michalewicz(x, m = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TF_michalewicz_+3A_x">x</code></td>
<td>
<p>Input vector at which to evaluate.</p>
</td></tr>
<tr><td><code id="TF_michalewicz_+3A_m">m</code></td>
<td>
<p>Parameter for the michalewicz function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function output evaluated at x.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TF_michalewicz(rep(0,2))
TF_michalewicz(rep(1,2))
</code></pre>

<hr>
<h2 id='TF_moon_high'>TF_moon_high: Moon (2010) high-dimensional function for evaluating a single point.</h2><span id='topic+TF_moon_high'></span>

<h3>Description</h3>

<p>TF_moon_high: Moon (2010) high-dimensional function for evaluating a single point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TF_moon_high(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TF_moon_high_+3A_x">x</code></td>
<td>
<p>Input vector at which to evaluate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function output evaluated at x.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TF_moon_high(rep(0,20))
TF_moon_high(rep(1,20))
</code></pre>

<hr>
<h2 id='TF_morris'>TF_morris: morris function for evaluating a single point.</h2><span id='topic+TF_morris'></span>

<h3>Description</h3>

<p>TF_morris: morris function for evaluating a single point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TF_morris(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TF_morris_+3A_x">x</code></td>
<td>
<p>Input vector at which to evaluate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function output evaluated at x.
</p>


<h3>References</h3>

<p>http://www.abe.ufl.edu/jjones/ABE_5646/2010/Morris.1991
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TF_morris(rep(0,20))
TF_morris(rep(1,20))
</code></pre>

<hr>
<h2 id='TF_piston'>TF_piston: Piston simulation function for evaluating a single point.</h2><span id='topic+TF_piston'></span>

<h3>Description</h3>

<p>TF_piston: Piston simulation function for evaluating a single point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TF_piston(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TF_piston_+3A_x">x</code></td>
<td>
<p>Input vector at which to evaluate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function output evaluated at x.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TF_piston(c(30,.005,.002,1e3,9e4,290,340)) # minimum of zero, hard to solve
</code></pre>

<hr>
<h2 id='TF_quad_peaks'>TF_quad_peaks: quad_peaks function for evaluating a single point.</h2><span id='topic+TF_quad_peaks'></span>

<h3>Description</h3>

<p>TF_quad_peaks: quad_peaks function for evaluating a single point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TF_quad_peaks(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TF_quad_peaks_+3A_x">x</code></td>
<td>
<p>Input vector at which to evaluate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function output evaluated at x.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TF_quad_peaks(rep(0,2))
TF_quad_peaks(rep(1,2))
</code></pre>

<hr>
<h2 id='TF_quad_peaks_slant'>TF_quad_peaks_slant: quad_peaks_slant function for evaluating a single point.</h2><span id='topic+TF_quad_peaks_slant'></span>

<h3>Description</h3>

<p>TF_quad_peaks_slant: quad_peaks_slant function for evaluating a single point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TF_quad_peaks_slant(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TF_quad_peaks_slant_+3A_x">x</code></td>
<td>
<p>Input vector at which to evaluate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function output evaluated at x.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TF_quad_peaks_slant(rep(0,2))
TF_quad_peaks_slant(rep(1,2))
</code></pre>

<hr>
<h2 id='TF_rastrigin'>TF_rastrigin: Rastrigin function for evaluating a single point.</h2><span id='topic+TF_rastrigin'></span>

<h3>Description</h3>

<p>TF_rastrigin: Rastrigin function for evaluating a single point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TF_rastrigin(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TF_rastrigin_+3A_x">x</code></td>
<td>
<p>Input vector at which to evaluate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function output evaluated at x.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TF_rastrigin(rep(0,2))
TF_rastrigin(rep(1,2))
</code></pre>

<hr>
<h2 id='TF_robotarm'>TF_robotarm: Robot arm function for evaluating a single point.</h2><span id='topic+TF_robotarm'></span>

<h3>Description</h3>

<p>TF_robotarm: Robot arm function for evaluating a single point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TF_robotarm(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TF_robotarm_+3A_x">x</code></td>
<td>
<p>Input vector at which to evaluate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function output evaluated at x.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TF_robotarm(rep(0,8))
TF_robotarm(rep(1,8))
</code></pre>

<hr>
<h2 id='TF_RoosArnold'>TF_RoosArnold: Roos &amp; Arnold (1963) function for evaluating a single point.</h2><span id='topic+TF_RoosArnold'></span>

<h3>Description</h3>

<p>TF_RoosArnold: Roos &amp; Arnold (1963) function for evaluating a single point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TF_RoosArnold(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TF_RoosArnold_+3A_x">x</code></td>
<td>
<p>Input vector at which to evaluate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function output evaluated at x.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TF_RoosArnold(rep(0,8))
TF_RoosArnold(rep(1,8))
</code></pre>

<hr>
<h2 id='TF_steelcolumnstress'>TF_steelcolumnstress: steelcolumnstress function for evaluating a single point.</h2><span id='topic+TF_steelcolumnstress'></span>

<h3>Description</h3>

<p>TF_steelcolumnstress: steelcolumnstress function for evaluating a single point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TF_steelcolumnstress(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TF_steelcolumnstress_+3A_x">x</code></td>
<td>
<p>Input vector at which to evaluate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function output evaluated at x.
</p>


<h3>References</h3>

<p>Kuschel, Norbert, and Rudiger Rackwitz. &quot;Two basic problems in reliability-based structural optimization.&quot; Mathematical Methods of Operations Research 46, no. 3 (1997): 309-333.
</p>
<p>Prikhodko, Pavel, and Nikita Kotlyarov. &quot;Calibration of Sobol indices estimates in case of noisy output.&quot; arXiv preprint arXiv:1804.00766 (2018).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TF_steelcolumnstress(rep(0,8))
TF_steelcolumnstress(rep(1,8))
</code></pre>

<hr>
<h2 id='TF_SWNExpCos'>TF_SWNExpCos: SWNExpCos function for evaluating a single point.</h2><span id='topic+TF_SWNExpCos'></span>

<h3>Description</h3>

<p>TF_SWNExpCos: SWNExpCos function for evaluating a single point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TF_SWNExpCos(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TF_SWNExpCos_+3A_x">x</code></td>
<td>
<p>Input vector at which to evaluate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function output evaluated at x.
</p>


<h3>References</h3>

<p>Santner, T. J., Williams, B. J., &amp; Notz, W. (2003). The Design and Analysis of Computer Experiments. Springer Science &amp; Business Media.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TF_SWNExpCos(rep(0,2))
TF_SWNExpCos(rep(1,2))
</code></pre>

<hr>
<h2 id='TF_vertigrad'>TF_vertigrad: vertigrad function for evaluating a single point.</h2><span id='topic+TF_vertigrad'></span>

<h3>Description</h3>

<p>TF_vertigrad: vertigrad function for evaluating a single point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TF_vertigrad(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TF_vertigrad_+3A_x">x</code></td>
<td>
<p>Input vector at which to evaluate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function output evaluated at x.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TF_vertigrad(rep(0,2))
TF_vertigrad(rep(1,2))
</code></pre>

<hr>
<h2 id='TF_vertigrad_grad'>TF_vertigrad_grad: vertigrad_grad function for evaluating a single point.</h2><span id='topic+TF_vertigrad_grad'></span>

<h3>Description</h3>

<p>TF_vertigrad_grad: vertigrad_grad function for evaluating a single point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TF_vertigrad_grad(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TF_vertigrad_grad_+3A_x">x</code></td>
<td>
<p>Input vector at which to evaluate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function output evaluated at x.
</p>


<h3>References</h3>

<p>Forrester, A., &amp; Keane, A. (2008). Engineering design via surrogate modelling: a practical guide. John Wiley &amp; Sons.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TF_vertigrad_grad(rep(0,2))
TF_vertigrad_grad(rep(1,2))
</code></pre>

<hr>
<h2 id='TF_welch'>TF_welch: Welch function for evaluating a single point.</h2><span id='topic+TF_welch'></span>

<h3>Description</h3>

<p>TF_welch: Welch function for evaluating a single point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TF_welch(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TF_welch_+3A_x">x</code></td>
<td>
<p>Input vector at which to evaluate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function output evaluated at x.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TF_welch(rep(0,20)) # minimum of zero, hard to solve
</code></pre>

<hr>
<h2 id='TF_wingweight'>TF_wingweight: Wing weight function for evaluating a single point.</h2><span id='topic+TF_wingweight'></span>

<h3>Description</h3>

<p>TF_wingweight: Wing weight function for evaluating a single point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TF_wingweight(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TF_wingweight_+3A_x">x</code></td>
<td>
<p>Input vector at which to evaluate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function output evaluated at x.
</p>


<h3>References</h3>

<p>Forrester, A., &amp; Keane, A. (2008). Engineering design via surrogate modelling: a practical guide. John Wiley &amp; Sons.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TF_wingweight(c(150,220,6,-10,16,.5,.08,2.5,1700,.025)) # minimum of zero, hard to solve
</code></pre>

<hr>
<h2 id='TF_winkel'>TF_winkel: winkel function for evaluating a single point.</h2><span id='topic+TF_winkel'></span>

<h3>Description</h3>

<p>TF_winkel: winkel function for evaluating a single point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TF_winkel(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TF_winkel_+3A_x">x</code></td>
<td>
<p>Input vector at which to evaluate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function output evaluated at x.
</p>


<h3>References</h3>

<p>Winkel, Munir A., Jonathan W. Stallings, Curt B. Storlie, and
Brian J. Reich. &quot;Sequential Optimization in Locally Important Dimensions.&quot;
arXiv preprint arXiv:1804.10671 (2018).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TF_winkel(rep(0,2))
TF_winkel(rep(1,2))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
