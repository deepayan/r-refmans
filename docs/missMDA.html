<!DOCTYPE html><html lang="en"><head><title>Help for package missMDA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {missMDA}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#missMDA-package'><p>Handling missing values with/in multivariate data analysis (principal component methods)</p></a></li>
<li><a href='#estim_ncpFAMD'><p>Estimate the number of dimensions for the Factorial Analysis of Mixed Data by cross-validation</p></a></li>
<li><a href='#estim_ncpMCA'><p>Estimate the number of dimensions for the Multiple Correspondence Analysis by cross-validation</p></a></li>
<li><a href='#estim_ncpMultilevel'><p>Estimate the number of dimensions for the Multilevel PCA, multlevel MCA or Multilevel FAMD by cross-validation</p></a></li>
<li><a href='#estim_ncpPCA'><p>Estimate the number of dimensions for the Principal Component Analysis by cross-validation</p></a></li>
<li><a href='#gene'>
<p>Gene expression</p></a></li>
<li><a href='#geno'>
<p>Genotype-environment data set with missing values</p></a></li>
<li><a href='#imputeCA'><p>Impute contingency table</p></a></li>
<li><a href='#imputeFAMD'><p>Impute mixed dataset</p></a></li>
<li><a href='#imputeMCA'><p>Impute categorical dataset</p></a></li>
<li><a href='#imputeMFA'><p>Impute dataset with variables structured into groups of variables (groups of continuous or categorical variables)</p></a></li>
<li><a href='#imputeMultilevel'><p>Impute a multilevel mixed dataset</p></a></li>
<li><a href='#imputePCA'><p>Impute dataset with PCA</p></a></li>
<li><a href='#MIFAMD'>
<p>Multiple Imputation with FAMD</p></a></li>
<li><a href='#MIMCA'><p>Multiple Imputation with MCA</p></a></li>
<li><a href='#MIPCA'><p>Multiple Imputation with PCA</p></a></li>
<li><a href='#orange'>
<p>Sensory description of 12 orange juices by 8 attributes.</p></a></li>
<li><a href='#Overimpute'><p>Overimputation diagnostic plot</p></a></li>
<li><a href='#ozone'>
<p>Daily measurements of meteorological variables and ozone concentration</p></a></li>
<li><a href='#plot.MIMCA'><p>Plot the graphs for the Multiple Imputation in MCA</p></a></li>
<li><a href='#plot.MIPCA'><p>Plot the graphs for the Multiple Imputation in PCA</p></a></li>
<li><a href='#prelim'><p>Converts a dataset imputed by MIMCA, MIPCA or MIFAMD into a mids object</p></a></li>
<li><a href='#snorena'>
<p>Characterization of people who snore</p></a></li>
<li><a href='#TitanicNA'>
<p>Categorical data set with missing values: Survival of passengers on the Titanic</p></a></li>
<li><a href='#vnf'>
<p>Questionnaire done by 1232 individuals who answered 14 questions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Handling Missing Values with Multivariate Data Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.19</td>
</tr>
<tr>
<td>Author:</td>
<td>Francois Husson, Julie Josse</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Francois Husson &lt;francois.husson@institut-agro.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Imputation of incomplete continuous or categorical datasets; Missing values are imputed with a principal component analysis (PCA), a multiple correspondence analysis (MCA) model or a multiple factor analysis (MFA) model; Perform multiple imputation with and in PCA or MCA.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>FactoMineR (&ge;
2.3),ggplot2,graphics,grDevices,mice,mvtnorm,stats,utils,doParallel,parallel,foreach</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, markdown</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://factominer.free.fr/missMDA/index.html">http://factominer.free.fr/missMDA/index.html</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-17 06:53:54 UTC; husson</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-17 10:20:19 UTC</td>
</tr>
</table>
<hr>
<h2 id='missMDA-package'>Handling missing values with/in multivariate data analysis (principal component methods)
</h2><span id='topic+missMDA-package'></span><span id='topic+missMDA'></span>

<h3>Description</h3>

<p>handle missing values in exploratory multivariate analysis such as principal component analysis (PCA), multiple correspondence analysis (MCA),  factor analysis for mixed data (FAMD) and multiple factor analysis (MFA)<br />
impute missing values in continuous data sets using the PCA model, categorical data sets using MCA, mixed data using FAMD<br />
generate multiple imputed data sets for continuous data using the PCA model and for categorical data using MCA<br />
visualize multiple imputation in PCA and MCA</p>


<h3>Details</h3>

<p>The package missMDA impute incomplete datasets for quantitative and / or categorical variables</p>


<h3>Author(s)</h3>

<p>Francois Husson, Julie Josse
</p>
<p>Maintainer: <a href="mailto:francois.husson@institut-agro.fr">francois.husson@institut-agro.fr</a>
</p>


<h3>References</h3>

<p>Josse, J. &amp; Husson, F. (2012). Handling missing values in exploratory multivariate data analysis methods. Journal de la SFdS, 153(2), pp. 79-99.
</p>
<p>Julie Josse, Francois Husson (2016). missMDA: A Package for Handling Missing Values in Multivariate Data Analysis. Journal of Statistical Software, 70(1), 1-31. <a href="https://doi.org/10.18637/jss.v070.i01">doi:10.18637/jss.v070.i01</a>
</p>
<p>Audigier, V., Husson, F., and Josse, J. (2016). Multiple imputation for continuous variables using a bayesian principal component analysis. Journal of Statistical Computation and Simulation, 86(11):2140-2156.
</p>
<p>Audigier, V., Husson, F., and Josse, J. (2016). A principal component method to impute missing values for mixed data. Advances in Data Analysis and Classification, 10(1):5-26.
</p>
<p>Audigier, V., Husson, F., and Josse, J. (2017). Mimca: multiple imputation for categorical variables with multiple correspondence analysis. Statistics and Computing, 27(2):501-518.
</p>
<p>Some videos: <a href="https://www.youtube.com/playlist?list=PLnZgp6epRBbQzxFnQrcxg09kRt-PA66T_">https://www.youtube.com/playlist?list=PLnZgp6epRBbQzxFnQrcxg09kRt-PA66T_</a>
</p>

<hr>
<h2 id='estim_ncpFAMD'>Estimate the number of dimensions for the Factorial Analysis of Mixed Data by cross-validation</h2><span id='topic+estim_ncpFAMD'></span>

<h3>Description</h3>

<p>Estimate the number of dimensions for the Factorial Analysis of Mixed Data by cross-validation</p>


<h3>Usage</h3>

<pre><code class='language-R'>estim_ncpFAMD(don, ncp.min=0, ncp.max=5,  method = c("Regularized","EM"), 
     method.cv = c("Kfold","loo"), nbsim=100, pNA=0.05, ind.sup=NULL,
	 sup.var=NULL, threshold=1e-4, verbose = TRUE, maxiter = 1000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estim_ncpFAMD_+3A_don">don</code></td>
<td>
<p>a data.frame with categorical variables; with missing entries or not</p>
</td></tr>
<tr><td><code id="estim_ncpFAMD_+3A_ncp.min">ncp.min</code></td>
<td>
<p>integer corresponding to the minimum number of components to test</p>
</td></tr>
<tr><td><code id="estim_ncpFAMD_+3A_ncp.max">ncp.max</code></td>
<td>
<p>integer corresponding to the maximum number of components to test</p>
</td></tr>
<tr><td><code id="estim_ncpFAMD_+3A_method">method</code></td>
<td>
<p>&quot;Regularized&quot; by default or &quot;EM&quot;</p>
</td></tr>
<tr><td><code id="estim_ncpFAMD_+3A_method.cv">method.cv</code></td>
<td>
<p>&quot;Kfold&quot; for cross-validation or &quot;loo&quot; for leave-one-out</p>
</td></tr>
<tr><td><code id="estim_ncpFAMD_+3A_nbsim">nbsim</code></td>
<td>
<p>number of simulations, useful only if method.cv=&quot;Kfold&quot;</p>
</td></tr>
<tr><td><code id="estim_ncpFAMD_+3A_pna">pNA</code></td>
<td>
<p>percentage of missing values added in the data set, useful only if method.cv=&quot;Kfold&quot;</p>
</td></tr>
<tr><td><code id="estim_ncpFAMD_+3A_ind.sup">ind.sup</code></td>
<td>
<p>a vector indicating the indexes of the supplementary individuals</p>
</td></tr>
<tr><td><code id="estim_ncpFAMD_+3A_sup.var">sup.var</code></td>
<td>
<p>a vector indicating the indexes of the supplementary variables (quantitative and categorical)</p>
</td></tr>
<tr><td><code id="estim_ncpFAMD_+3A_threshold">threshold</code></td>
<td>
<p>the threshold for assessing convergence</p>
</td></tr>
<tr><td><code id="estim_ncpFAMD_+3A_verbose">verbose</code></td>
<td>
<p>boolean. TRUE means that a progressbar is writtent</p>
</td></tr>
<tr><td><code id="estim_ncpFAMD_+3A_maxiter">maxiter</code></td>
<td>
<p>integer, maximum number of iteration for the algorithm</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For leave-one-out cross-validation (method.cv=&quot;loo&quot;), each cell of the data matrix is alternatively removed and predicted with a FAMD model using ncp.min to ncp.max dimensions. The number of components which leads to the smallest mean square error of prediction (MSEP) is retained.
For the Kfold cross-validation (method.cv=&quot;Kfold&quot;), pNA percentage of missing values is inserted at random in the data matrix and predicted with a FAMD model using ncp.min to ncp.max dimensions. This process is repeated nbsim times. The number of components which leads to the smallest MSEP is retained. More precisely, for both cross-validation methods, the missing entries are predicted using the imputeFAMD function, it means using it means using the regularized iterative FAMD algorithm (method=&quot;Regularized&quot;) or the iterative FAMD algorithm (method=&quot;EM&quot;). The regularized version is more appropriate to avoid overfitting issues.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>ncp</code></td>
<td>
<p>the number of components retained for the FAMD</p>
</td></tr>
<tr><td><code>criterion</code></td>
<td>
<p>the criterion (the MSEP) calculated for each number of components</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vincent Audigier  <a href="mailto:vincent.audigier@cnam.fr">vincent.audigier@cnam.fr</a>, Francois Husson  <a href="mailto:francois.husson@institut-agro.fr">francois.husson@institut-agro.fr</a> and Julie Josse  <a href="mailto:julie.josse@polytechnique.edu">julie.josse@polytechnique.edu</a>
</p>


<h3>References</h3>

<p>Audigier, V., Husson, F. &amp; Josse, J. (2014). A principal components method to impute mixed data. Advances in Data Analysis and Classification</p>


<h3>See Also</h3>

<p><code><a href="#topic+imputeFAMD">imputeFAMD</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(ozone)
result &lt;- estim_ncpFAMD(ozone)

## End(Not run)
</code></pre>

<hr>
<h2 id='estim_ncpMCA'>Estimate the number of dimensions for the Multiple Correspondence Analysis by cross-validation</h2><span id='topic+estim_ncpMCA'></span>

<h3>Description</h3>

<p>Estimate the number of dimensions for the Multiple Correspondence Analysis by cross-validation</p>


<h3>Usage</h3>

<pre><code class='language-R'>estim_ncpMCA(don, ncp.min=0, ncp.max=5,  method = c("Regularized","EM"), 
     method.cv = c("Kfold","loo"), nbsim=100, pNA=0.05, ind.sup=NULL,
	 quanti.sup=NULL, quali.sup=NULL, threshold=1e-4,verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estim_ncpMCA_+3A_don">don</code></td>
<td>
<p>a data.frame with categorical variables; with missing entries or not</p>
</td></tr>
<tr><td><code id="estim_ncpMCA_+3A_ncp.min">ncp.min</code></td>
<td>
<p>integer corresponding to the minimum number of components to test</p>
</td></tr>
<tr><td><code id="estim_ncpMCA_+3A_ncp.max">ncp.max</code></td>
<td>
<p>integer corresponding to the maximum number of components to test</p>
</td></tr>
<tr><td><code id="estim_ncpMCA_+3A_method">method</code></td>
<td>
<p>&quot;Regularized&quot; by default or &quot;EM&quot;</p>
</td></tr>
<tr><td><code id="estim_ncpMCA_+3A_method.cv">method.cv</code></td>
<td>
<p>&quot;Kfold&quot; for cross-validation or &quot;loo&quot; for leave-one-out</p>
</td></tr>
<tr><td><code id="estim_ncpMCA_+3A_nbsim">nbsim</code></td>
<td>
<p>number of simulations, useful only if method.cv=&quot;Kfold&quot;</p>
</td></tr>
<tr><td><code id="estim_ncpMCA_+3A_pna">pNA</code></td>
<td>
<p>percentage of missing values added in the data set, useful only if method.cv=&quot;Kfold&quot;</p>
</td></tr>
<tr><td><code id="estim_ncpMCA_+3A_ind.sup">ind.sup</code></td>
<td>
<p>a vector indicating the indexes of the supplementary individuals</p>
</td></tr>
<tr><td><code id="estim_ncpMCA_+3A_quanti.sup">quanti.sup</code></td>
<td>
<p>a vector indicating the indexes of the quantitative supplementary variables</p>
</td></tr>
<tr><td><code id="estim_ncpMCA_+3A_quali.sup">quali.sup</code></td>
<td>
<p>a vector indicating the indexes of the categorical supplementary variables</p>
</td></tr>
<tr><td><code id="estim_ncpMCA_+3A_threshold">threshold</code></td>
<td>
<p>the threshold for assessing convergence</p>
</td></tr>
<tr><td><code id="estim_ncpMCA_+3A_verbose">verbose</code></td>
<td>
<p>boolean. TRUE means that a progressbar is writtent</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For leave-one-out cross-validation (method.cv=&quot;loo&quot;), each cell of the data matrix is alternatively removed and predicted with a MCA model using ncp.min to ncp.max dimensions. The number of components which leads to the smallest mean square error of prediction (MSEP) is retained.
For the Kfold cross-validation (method.cv=&quot;Kfold&quot;), pNA percentage of missing values is inserted at random in the data matrix and predicted with a MCA model using ncp.min to ncp.max dimensions. This process is repeated nbsim times.  The number of components which leads to the smallest MSEP is retained. More precisely, for both cross-validation methods, the missing entries are predicted using the imputeMCA function, it means using it means using the regularized iterative MCA algorithm (method=&quot;Regularized&quot;) or the iterative MCA algorithm (method=&quot;EM&quot;). The regularized version is more appropriate to avoid overfitting issues.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>ncp</code></td>
<td>
<p>the number of components retained for the MCA</p>
</td></tr>
<tr><td><code>criterion</code></td>
<td>
<p>the criterion (the MSEP) calculated for each number of components</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Francois Husson  <a href="mailto:francois.husson@institut-agro.fr">francois.husson@institut-agro.fr</a> and Julie Josse  <a href="mailto:julie.josse@polytechnique.edu">julie.josse@polytechnique.edu</a>
</p>


<h3>References</h3>

<p>Josse, J., Chavent, M., Liquet, B. and Husson, F. (2010). Handling missing values with Regularized Iterative Multiple Correspondence Analysis, Journal of Clcassification, 29 (1), pp. 91-116.</p>


<h3>See Also</h3>

<p><code><a href="#topic+imputeMCA">imputeMCA</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(vnf)
result &lt;- estim_ncpMCA(vnf,ncp.min=0, ncp.max=5)

## End(Not run)
</code></pre>

<hr>
<h2 id='estim_ncpMultilevel'>Estimate the number of dimensions for the Multilevel PCA, multlevel MCA or Multilevel FAMD by cross-validation</h2><span id='topic+estim_ncpMultilevel'></span>

<h3>Description</h3>

<p>Estimate the number of dimensions for Multilevel principal component (multilevel PCA, multilevel MCA ormultilevel Factorial Analysis of Mixed Data) by cross-validation</p>


<h3>Usage</h3>

<pre><code class='language-R'>estim_ncpMultilevel(X,  ifac=1, ncpW.min = 1, ncpW.max = 5, ncpB.min = 1, 
    ncpB.max = 5, scale = TRUE, nbsim=100, pNA=0.05, threshold=1e-4, 
	nb.cores = NULL, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estim_ncpMultilevel_+3A_x">X</code></td>
<td>
<p>a data.frame with categorical variables; with missing entries or not</p>
</td></tr>
<tr><td><code id="estim_ncpMultilevel_+3A_ifac">ifac</code></td>
<td>
<p>index of the group variable</p>
</td></tr>
<tr><td><code id="estim_ncpMultilevel_+3A_ncpb.min">ncpB.min</code></td>
<td>
<p>integer corresponding to the minimum number of components to test for the between matrix</p>
</td></tr>
<tr><td><code id="estim_ncpMultilevel_+3A_ncpb.max">ncpB.max</code></td>
<td>
<p>integer corresponding to the maximum number of components to test for the between matrix</p>
</td></tr>
<tr><td><code id="estim_ncpMultilevel_+3A_ncpw.min">ncpW.min</code></td>
<td>
<p>integer corresponding to the minimum number of components to test for the within matrix</p>
</td></tr>
<tr><td><code id="estim_ncpMultilevel_+3A_ncpw.max">ncpW.max</code></td>
<td>
<p>integer corresponding to the maximum number of components to test for the within matrix</p>
</td></tr>
<tr><td><code id="estim_ncpMultilevel_+3A_scale">scale</code></td>
<td>
<p>if all the variables are continuous, should they be standardized? Yes if true.</p>
</td></tr>
<tr><td><code id="estim_ncpMultilevel_+3A_nbsim">nbsim</code></td>
<td>
<p>number of simulations</p>
</td></tr>
<tr><td><code id="estim_ncpMultilevel_+3A_pna">pNA</code></td>
<td>
<p>percentage of missing values added in the data set, useful only if method.cv=&quot;Kfold&quot;</p>
</td></tr>
<tr><td><code id="estim_ncpMultilevel_+3A_threshold">threshold</code></td>
<td>
<p>the threshold for assessing convergence</p>
</td></tr>
<tr><td><code id="estim_ncpMultilevel_+3A_nb.cores">nb.cores</code></td>
<td>
<p>Integer, number of core used. By default, NULL and the number of cores used are the number of cores of your computer  minus 1</p>
</td></tr>
<tr><td><code id="estim_ncpMultilevel_+3A_verbose">verbose</code></td>
<td>
<p>boolean. TRUE means that a progressbar is writtent</p>
</td></tr>
</table>


<h3>Details</h3>

<p>pNA percentage of missing values is inserted at random in the data matrix and predicted with a multilevel model using ncpB.min to ncpB.max and ncpW.min to ncpW.max dimensions. 
This process is repeated nbsim times. The number of components which leads to the smallest MSEP is retained. 
More precisely, the missing entries are predicted using the imputeMultilevel function.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>ncp</code></td>
<td>
<p>the number of components retained for the FAMD</p>
</td></tr>
<tr><td><code>criterion</code></td>
<td>
<p>the criterion (the MSEP) calculated for each number of components</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+imputeMultilevel">imputeMultilevel</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(ozone)
result &lt;- estim_ncpMultilevel(ozone, ifac=12)

## End(Not run)
</code></pre>

<hr>
<h2 id='estim_ncpPCA'>Estimate the number of dimensions for the Principal Component Analysis by cross-validation</h2><span id='topic+estim_ncpPCA'></span>

<h3>Description</h3>

<p>Estimate the number of dimensions for the Principal Component Analysis by cross-validation</p>


<h3>Usage</h3>

<pre><code class='language-R'>estim_ncpPCA(X, ncp.min = 0, ncp.max = 5, method = c("Regularized","EM"), 
       scale = TRUE, method.cv = c("gcv","loo","Kfold"), nbsim = 100, 
	   pNA = 0.05, ind.sup=NULL, quanti.sup=NULL, quali.sup=NULL,
	   threshold=1e-4, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estim_ncpPCA_+3A_x">X</code></td>
<td>
<p>a data.frame with continuous variables; with missing entries or not</p>
</td></tr>
<tr><td><code id="estim_ncpPCA_+3A_ncp.min">ncp.min</code></td>
<td>
<p>integer corresponding to the minimum number of components to test</p>
</td></tr>
<tr><td><code id="estim_ncpPCA_+3A_ncp.max">ncp.max</code></td>
<td>
<p>integer corresponding to the maximum number of components to test</p>
</td></tr>
<tr><td><code id="estim_ncpPCA_+3A_method">method</code></td>
<td>
<p>&quot;Regularized&quot; by default or &quot;EM&quot;</p>
</td></tr>
<tr><td><code id="estim_ncpPCA_+3A_scale">scale</code></td>
<td>
<p>boolean. TRUE implies a same weight for each variable</p>
</td></tr>
<tr><td><code id="estim_ncpPCA_+3A_method.cv">method.cv</code></td>
<td>
<p>string with the values &quot;gcv&quot; for generalised cross-validation, &quot;loo&quot; for leave-one-out or &quot;Kfold&quot; cross-validation</p>
</td></tr>
<tr><td><code id="estim_ncpPCA_+3A_nbsim">nbsim</code></td>
<td>
<p>number of simulations, useful only if method.cv=&quot;Kfold&quot;</p>
</td></tr>
<tr><td><code id="estim_ncpPCA_+3A_pna">pNA</code></td>
<td>
<p>percentage of missing values added in the data set, useful only if method.cv=&quot;Kfold&quot;</p>
</td></tr>
<tr><td><code id="estim_ncpPCA_+3A_ind.sup">ind.sup</code></td>
<td>
<p>a vector indicating the indexes of the supplementary individuals</p>
</td></tr>
<tr><td><code id="estim_ncpPCA_+3A_quanti.sup">quanti.sup</code></td>
<td>
<p>a vector indicating the indexes of the quantitative supplementary variables</p>
</td></tr>
<tr><td><code id="estim_ncpPCA_+3A_quali.sup">quali.sup</code></td>
<td>
<p>a vector indicating the indexes of the categorical supplementary variables</p>
</td></tr>
<tr><td><code id="estim_ncpPCA_+3A_threshold">threshold</code></td>
<td>
<p>the threshold for assessing convergence</p>
</td></tr>
<tr><td><code id="estim_ncpPCA_+3A_verbose">verbose</code></td>
<td>
<p>boolean. TRUE means that a progressbar is writtent</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For leave-one-out (loo) cross-validation, each cell of the data matrix is alternatively removed and predicted with a PCA model using ncp.min to ncp.max dimensions. The number of components which leads to the smallest mean square error of prediction (MSEP) is retained.
For the Kfold cross-validation, pNA percentage of missing values is inserted and predicted with a PCA model using ncp.min to ncp.max dimensions. This process is repeated nbsim times. The number of components which leads to the smallest MSEP is retained. <br />
For both cross-validation methods, missing entries are predicted using the imputePCA function, it means using the regularized iterative PCA algorithm (method=&quot;Regularized&quot;) or the iterative PCA algorithm (method=&quot;EM&quot;). The regularized version is more appropriate when there are already many missing values in the dataset to avoid overfitting issues.
<br />
Cross-validation (especially method.cv=&quot;loo&quot;) is time-consuming. The generalised cross-validation criterion (method.cv=&quot;gcv&quot;) can be seen as an approximation of the loo cross-validation criterion which provides a straightforward way to estimate the number of dimensions without resorting to a computationally intensive method. <br />
</p>
<p>This argument scale has to be chosen in agreement with the PCA that will be performed. If one wants to perform a normed PCA (where the variables are centered and scaled, i.e. divided by their standard deviation), then the argument scale has to be set to the value TRUE.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>ncp</code></td>
<td>
<p>the number of components retained for the PCA</p>
</td></tr>
<tr><td><code>criterion</code></td>
<td>
<p>the criterion (the MSEP) calculated for each number of components</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Francois Husson  <a href="mailto:francois.husson@institut-agro.fr">francois.husson@institut-agro.fr</a> and Julie Josse  <a href="mailto:julie.josse@polytechnique.edu">julie.josse@polytechnique.edu</a>
</p>


<h3>References</h3>

<p>Bro, R., Kjeldahl, K. Smilde, A. K. and Kiers, H. A. L. (2008) Cross-validation of component models: A critical look at current methods. Analytical and Bioanalytical Chemistry, 5, 1241-1251.<br />
</p>
<p>Josse, J. and Husson, F. (2011). Selecting the number of components in PCA using cross-validation approximations. Computational Statistics and Data Analysis. 56 (6), pp. 1869-1879.</p>


<h3>See Also</h3>

<p><code><a href="#topic+imputePCA">imputePCA</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(orange)
nb &lt;- estim_ncpPCA(orange,ncp.min=0,ncp.max=4) 

## End(Not run)
</code></pre>

<hr>
<h2 id='gene'>
Gene expression
</h2><span id='topic+gene'></span>

<h3>Description</h3>

<p>A data frame with 53 brain tumors of 4 different types defined by the standard World Health 
Organization (WHO) classification (O, oligodendrogliomas; A, astrocytomas; OA, mixed oligo-astrocytomas 
and GBM, glioblastomas)  are described by information at the transcriptome level with expression data 
(356 continuous variables for microarrays) and at the genome level (76 continuous variables for CGH data) as illustrated.
10 rows are missing for the expression data.
</p>


<h3>Format</h3>

<p>A data-frame with 53 rows and 432 continuous variables</p>


<h3>Source</h3>

<p>de Tayrac M, Le S, Aubry M, Mosser J, Husson F. (2009). Simultaneous analysis of distinct Omics data sets with integration of biological knowledge: Multiple Factor Analysis approach. BMC Genomics, 10.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(gene)
res.impute &lt;- imputeMFA(gene[,-1], group = c(76,356), 
    type = rep("s",2), ncp = 2) 
res.mfa &lt;- MFA(cbind.data.frame(gene[,1], res.impute$completeObs), 
      group = c(1,76,356), type=c("n",rep("s",2)), 
	  name.group = c("WHO","CGH","expr"), num.group.sup = 1)
plot(res.mfa, habillage = 1, lab.ind = FALSE)
plot(res.mfa, habillage = "group", invisible = "ind", partial = "all")
plot(res.mfa, habillage = "group", lab.ind = FALSE, partial = "all")
plot(res.mfa, choix = "var", habillage = "group", lab.var = FALSE)
plot(res.mfa, choix = "group", habillage = "group")

## End(Not run)
</code></pre>

<hr>
<h2 id='geno'>
Genotype-environment data set with missing values
</h2><span id='topic+geno'></span>

<h3>Description</h3>

<p>A data-frame with 16 rows corresponding to genotypes (triticale lines) and 10 columns corresponding to different environments where the genotypes were sown. 
Each cell of the data-frame corresponds to the grain yield (kilograms per hectare) for one genotype in an environment.  
The first six genotypes correspond to the so-called &ldquo;complete&rdquo; type, while the next eight were of the &ldquo;substituted&rdquo; type and two 
check genotypes were included. Such data sets are often incomplete. 
Indeed, it frequently happens that all the varieties are not assessed on all the environments.  
</p>


<h3>Format</h3>

<p>A data-frame with 16 rows and 10 columns</p>


<h3>Source</h3>

<p>Royo C, Rodriguez A, Romagosa I (1993). Differential adaptation of complete and substitute
triticale. Plant Breeding, 111, 113- 119.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(geno)
ncomp &lt;- estim_ncpPCA(geno)
res.imp &lt;- imputePCA(geno, ncp= ncomp$ncp)
res.pca &lt;- PCA(res.imp$completeObs)

## End(Not run)
</code></pre>

<hr>
<h2 id='imputeCA'>Impute contingency table</h2><span id='topic+imputeCA'></span>

<h3>Description</h3>

<p>Impute the missing entries of a contingency table using Correspondence Analysis (CA). Can be used as a preliminary step before performing CA on an incomplete dataset.</p>


<h3>Usage</h3>

<pre><code class='language-R'>imputeCA(X, ncp = 2, threshold = 1e-08, maxiter = 1000, row.sup=NULL, 
     col.sup=NULL, quanti.sup=NULL, quali.sup=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="imputeCA_+3A_x">X</code></td>
<td>
<p>a data.frame that is a contingency table containing missing values</p>
</td></tr>
<tr><td><code id="imputeCA_+3A_ncp">ncp</code></td>
<td>
<p>integer corresponding to the number of dimensions used  to predict the missing entries</p>
</td></tr>
<tr><td><code id="imputeCA_+3A_threshold">threshold</code></td>
<td>
<p>the threshold for assessing convergence</p>
</td></tr>
<tr><td><code id="imputeCA_+3A_maxiter">maxiter</code></td>
<td>
<p>integer, maximum number of iterations for the regularized iterative CA algorithm</p>
</td></tr>
<tr><td><code id="imputeCA_+3A_row.sup">row.sup</code></td>
<td>
<p>a vector indicating the indexes of the supplementary rows</p>
</td></tr>
<tr><td><code id="imputeCA_+3A_col.sup">col.sup</code></td>
<td>
<p>a vector indicating the indexes of the supplementary columns</p>
</td></tr>
<tr><td><code id="imputeCA_+3A_quanti.sup">quanti.sup</code></td>
<td>
<p>a vector indicating the indexes of the quantitative supplementary variables</p>
</td></tr>
<tr><td><code id="imputeCA_+3A_quali.sup">quali.sup</code></td>
<td>
<p>a vector indicating the indexes of the categorical supplementary variables</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Impute the missing entries of a contingency table using a regularized CA algorithm. 
The (regularized) iterative CA algorithm first consists in initializing missing values with random initial values. 
The second step of the (regularized) iterative CA algorithm consists in performing CA on the completed dataset. Then, it imputes the missing values with the (regularized) reconstruction formulae of order ncp (the fitted matrix computed with ncp components for the (regularized) scores and loadings). These steps of estimation of the parameters via CA and imputation of the missing values using the (regularized) fitted matrix are iterate until convergence. <br />
In this regularized algorithm, the singular values of the CA are shrinked. <br />
The number of components ncp used in the algorithm should be small. 
A small number of components can also be seen as a way to regularize more and consequently may be advices to get more stable predictions.
<br />
The output of the algorithm can be used as an input of the CA function of the FactoMineR package in order to perform CA on an incomplete dataset.
</p>


<h3>Value</h3>

<p>The imputed contingency table; the observed values are kept for the non-missing entries and the missing values are replaced by the predicted ones.
</p>


<h3>Author(s)</h3>

<p>Francois Husson  <a href="mailto:francois.husson@institut-agro.fr">francois.husson@institut-agro.fr</a> and Julie Josse  <a href="mailto:julie.josse@polytechnique.edu">julie.josse@polytechnique.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(children)

## Impute the indicator matrix and perform a CA
res.impute &lt;- imputeCA(children, ncp=2)
res.ca &lt;- CA(res.impute) 

## End(Not run)
</code></pre>

<hr>
<h2 id='imputeFAMD'>Impute mixed dataset</h2><span id='topic+imputeFAMD'></span>

<h3>Description</h3>

<p>Impute the missing values of a mixed dataset (with continuous and categorical variables) using the principal component method &quot;factorial analysis for mixed data&quot; (FAMD). Can be used as a preliminary step before performing FAMD on an incomplete dataset.</p>


<h3>Usage</h3>

<pre><code class='language-R'>imputeFAMD(X, ncp = 2, method=c("Regularized","EM"), row.w = NULL,
      coeff.ridge=1,threshold = 1e-06, ind.sup=NULL, sup.var=NULL,
	  seed = NULL, maxiter = 1000,...)
	   </code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="imputeFAMD_+3A_x">X</code></td>
<td>
<p>a data.frame with continuous and categorical variables containing missing values</p>
</td></tr>
<tr><td><code id="imputeFAMD_+3A_ncp">ncp</code></td>
<td>
<p>integer corresponding to the number of components used to predict the missing entries</p>
</td></tr>
<tr><td><code id="imputeFAMD_+3A_method">method</code></td>
<td>
<p>&quot;Regularized&quot; by default or &quot;EM&quot;</p>
</td></tr>
<tr><td><code id="imputeFAMD_+3A_row.w">row.w</code></td>
<td>
<p>row weights (by default, uniform row weights)</p>
</td></tr>
<tr><td><code id="imputeFAMD_+3A_coeff.ridge">coeff.ridge</code></td>
<td>
<p>1 by default to perform the regularized imputeFAMD algorithm; useful only if method=&quot;Regularized&quot;. Other regularization terms can be implemented by setting the value to less than 1 in order to regularized less (to get closer to the results of the EM method) or more than 1 to regularized more</p>
</td></tr>
<tr><td><code id="imputeFAMD_+3A_threshold">threshold</code></td>
<td>
<p>the threshold for assessing convergence</p>
</td></tr>
<tr><td><code id="imputeFAMD_+3A_ind.sup">ind.sup</code></td>
<td>
<p>a vector indicating the indexes of the supplementary individuals</p>
</td></tr>
<tr><td><code id="imputeFAMD_+3A_sup.var">sup.var</code></td>
<td>
<p>a vector indicating the indexes of the supplementary variables (quantitative or categorical)</p>
</td></tr>
<tr><td><code id="imputeFAMD_+3A_seed">seed</code></td>
<td>
<p>integer, by default seed = NULL implies that missing values are initially imputed by the mean of each variable for the continuous variables and by the proportion of the category for the categorical variables coded with indicator matrices of dummy variables. Other values leads to a random initialization</p>
</td></tr>
<tr><td><code id="imputeFAMD_+3A_maxiter">maxiter</code></td>
<td>
<p>integer, maximum number of iteration for the algorithm</p>
</td></tr>
<tr><td><code id="imputeFAMD_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Impute the missing entries of a mixed data using the iterative FAMD algorithm (method=&quot;EM&quot;) or the regularised iterative FAMD algorithm (method=&quot;Regularized&quot;). The (regularized) iterative FAMD algorithm first consists in coding the categorical variables using the indicator matrix
of dummy variables. Then, in the initialization step, missing values are imputed with initial values such as the mean of the variable for the continuous variables and the proportion of the category for each category using the non-missing entries. If the argument seed is set to a specific value, a random initialization is performed: the initial values are drawn from a gaussian distribution
with mean and standard deviation calculated from the observed values for each continuous variable. The second step of the (regularized) iterative FAMD algorithm is to perform FAMD on the completed dataset. Then, it imputes the missing values with the (regularized) reconstruction formulae of order ncp (the fitted matrix computed with ncp components for the (regularized) scores and loadings). These steps of estimation of the parameters via FAMD and imputation of the missing values using the (regularized) fitted matrix are iterate until convergence. <br />
</p>
<p>We advice to use the regularized version of the algorithm to avoid the overfitting problems which are very frequent when there are many missing values. In the regularized algorithm, the singular values of the FAMD are shrinked.<br />
</p>
<p>The output of the algorithm can be used as an input of the FAMD function of the FactoMineR package in order to perform FAMD on an incomplete dataset.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>tab.disj</code></td>
<td>
<p>the imputed matrix; the observed values are kept for the non-missing entries and the missing values are replaced by the predicted ones. The categorical variables are coded with the indicator matrix of dummy variables. In this indicator matrix, the imputed values are real numbers but they met the constraint that the sum of the entries corresponding to one individual and one variable is equal to one. Consequently they can be seen as degree of membership to the corresponding category</p>
</td></tr>
<tr><td><code>completeObs</code></td>
<td>
<p>the mixed imputed dataset; the observed values are kept for the non-missing entries and the missing values are replaced by the predicted ones. For the continuous variables, the values are the same as in the tab.disj output; for the categorical variables missing values are imputed with the most plausible categories according to the values in the tab.disj output</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Francois Husson  <a href="mailto:francois.husson@institut-agro.fr">francois.husson@institut-agro.fr</a> and Julie Josse  <a href="mailto:julie.josse@polytechnique.edu">julie.josse@polytechnique.edu</a>
</p>


<h3>References</h3>

<p>Audigier, V., Husson, F. &amp; Josse, J. (2013). A principal components method to impute mixed data.  Advances in Data Analysis and Classification, 10(1), 5-26. https://arxiv.org/abs/1301.4797</p>


<h3>See Also</h3>

<p><code><a href="#topic+imputePCA">imputePCA</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(ozone)
res.impute &lt;- imputeFAMD(ozone, ncp=3) 
## The output can be used as an input of the FAMD function of the FactoMineR package 
##to perform the FAMD on the incomplete data ozone 
require(FactoMineR)
res.afdm &lt;- FAMD(ozone,tab.disj=res.impute$tab.disj) 

## End(Not run)
</code></pre>

<hr>
<h2 id='imputeMCA'>Impute categorical dataset</h2><span id='topic+imputeMCA'></span>

<h3>Description</h3>

<p>Impute the missing values of a categorical dataset using Multiple Correspondence Analysis (MCA). Can be used as a preliminary step before performing MCA on an incomplete dataset.</p>


<h3>Usage</h3>

<pre><code class='language-R'>imputeMCA(don, ncp=2, method = c("Regularized","EM"), row.w=NULL, coeff.ridge=1, 
    threshold=1e-06, ind.sup = NULL, quanti.sup=NULL, quali.sup=NULL,
	seed=NULL, maxiter=1000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="imputeMCA_+3A_don">don</code></td>
<td>
<p>a data.frame with categorical variables containing missing values</p>
</td></tr>
<tr><td><code id="imputeMCA_+3A_ncp">ncp</code></td>
<td>
<p>integer corresponding to the number of dimensions used  to predict the missing entries</p>
</td></tr>
<tr><td><code id="imputeMCA_+3A_method">method</code></td>
<td>
<p>&quot;Regularized&quot; by default or &quot;EM&quot;</p>
</td></tr>
<tr><td><code id="imputeMCA_+3A_row.w">row.w</code></td>
<td>
<p>row weights  (by default, a vector of 1 for uniform row weights)</p>
</td></tr>
<tr><td><code id="imputeMCA_+3A_coeff.ridge">coeff.ridge</code></td>
<td>
<p>1 by default to perform the regularized imputeMCA algorithm; useful only if method=&quot;Regularized&quot;. Other regularization terms can be implemented by setting the value to less than 1 in order to regularized less (to get closer to the results of the EM method) or more than 1 to regularized more (to get closer to the results of the proportion imputation)</p>
</td></tr>
<tr><td><code id="imputeMCA_+3A_threshold">threshold</code></td>
<td>
<p>the threshold for assessing convergence</p>
</td></tr>
<tr><td><code id="imputeMCA_+3A_ind.sup">ind.sup</code></td>
<td>
<p>a vector indicating the indexes of the supplementary individuals</p>
</td></tr>
<tr><td><code id="imputeMCA_+3A_quanti.sup">quanti.sup</code></td>
<td>
<p>a vector indicating the indexes of the quantitative supplementary variables</p>
</td></tr>
<tr><td><code id="imputeMCA_+3A_quali.sup">quali.sup</code></td>
<td>
<p>a vector indicating the indexes of the categorical supplementary variables</p>
</td></tr>
<tr><td><code id="imputeMCA_+3A_seed">seed</code></td>
<td>
<p>integer, by default seed = NULL implies that missing values are initially imputed by the proportion of the category for the categorical variables coded with indicator matrices of dummy variables. Other values leads to a random initialization</p>
</td></tr>
<tr><td><code id="imputeMCA_+3A_maxiter">maxiter</code></td>
<td>
<p>integer, maximum number of iterations for the regularized iterative MCA algorithm</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Impute the missing entries of a categorical data using the iterative MCA algorithm (method=&quot;EM&quot;) or the regularised iterative MCA algorithm (method=&quot;Regularized&quot;). The (regularized) iterative MCA algorithm first consists in coding the categorical variables using the indicator matrix
of dummy variables. Then, in the initialization step, missing values are imputed with initial values such as the proportion of the category for each category using the non-missing entries. This imputation corresponds also to using the algorithm with ncp=0 and is sometimes called in the literature the &quot;missing fuzzy average method&quot;. If the argument seed is set to a specific value, a random initialization is performed: random values are drawn in such a way that the constraint that the sum of the entries corresponding to one individual and one variable is equal to one in the indicator matrix of dummy variables. 
The second step of the (regularized) iterative MCA algorithm consists in performing MCA on the completed dataset. Then, it imputes the missing values with the (regularized) reconstruction formulae of order ncp (the fitted matrix computed with ncp components for the (regularized) scores and loadings). These steps of estimation of the parameters via MCA and imputation of the missing values using the (regularized) fitted matrix are iterate until convergence. <br />
We advice to use the regularized version of the algorithm to avoid the overfitting problems which are very frequent when there are many missing values. In the regularized algorithm, the singular values of the MCA are shrinked. <br />
The number of components ncp used in the algorithm can be selected using the function ncpMCA. A small number of components can also be seen as a way to regularize more and consequently may be advices to get more stable predictions.
<br />
The output of the algorithm can be used as an input of the MCA function of the FactoMineR package in order to perform MCA on an incomplete dataset.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>tab.disj</code></td>
<td>
<p>The imputed indicator matrix; the observed values are kept for the non-missing entries and the missing values are replaced by the predicted ones.  The imputed values are real numbers but they  but they met the constraint that the sum of the entries corresponding to one individual and one variable is equal to one. Consequently they can be seen as degree of membership to the corresponding category.
</p>
</td></tr>
<tr><td><code>completeObs</code></td>
<td>
<p>The categorical imputed dataset; the observed values are kept for the non-missing entries and the missing values are replaced by the predicted ones. Missing values are imputed with the most plausible categories according to the values in the tab.disj output</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Francois Husson  <a href="mailto:francois.husson@institut-agro.fr">francois.husson@institut-agro.fr</a> and Julie Josse  <a href="mailto:julie.josse@polytechnique.edu">julie.josse@polytechnique.edu</a>
</p>


<h3>References</h3>

<p>Josse, J., Chavent, M., Liquet, B. and Husson, F. (2010). Handling missing values with Regularized Iterative Multiple Correspondence Analysis, Journal of Clcassification, 29 (1), pp. 91-116.<br />
Josse, J. and Husson, F. missMDA (2016). A Package for Handling Missing Values in Multivariate Data Analysis. Journal of Statistical Software, 70 (1), pp 1-31 <a href="https://doi.org/10.18637/jss.v070.i01">doi:10.18637/jss.v070.i01</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+estim_ncpMCA">estim_ncpMCA</a></code>,<br />
<a href="https://www.youtube.com/watch?v=_Wa6R4PM9dY&amp;list=PLnZgp6epRBbQzxFnQrcxg09kRt-PA66T_&amp;index=1">Video showing how to perform MCA on an incomplete dataset</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(vnf)
## First the number of components has to be chosen 
##   (for the reconstruction step)
## nb &lt;- estim_ncpMCA(vnf,ncp.max=5) ## Time-consuming, nb = 4

## Impute the indicator matrix and perform a MCA
res.impute &lt;- imputeMCA(vnf, ncp=4)

## The imputed indicator matrix can be used as an input of the MCA function of the
## FactoMineR package to perform the MCA on the incomplete data vnf 
require(FactoMineR)
res.mca &lt;- MCA(vnf,tab.disj=res.impute$tab.disj) 

## With supplementary variables (var 11 to 14), impute the active ones
res.impute &lt;- imputeMCA(vnf[,1:10], ncp=4)
res.mca &lt;- MCA(vnf,tab.disj=res.impute$tab.disj,quali.sup=11:14) 

## End(Not run)
</code></pre>

<hr>
<h2 id='imputeMFA'>Impute dataset with variables structured into groups of variables (groups of continuous or categorical variables)</h2><span id='topic+imputeMFA'></span>

<h3>Description</h3>

<p>Impute the missing values of a dataset with Multiple Factor Analysis (MFA). The variables are structured a priori into groups of variables. The variables can be continuous or categorical but within a group the nature of the variables is the same.  Can be used as a preliminary step before performing MFA on an incomplete dataset.</p>


<h3>Usage</h3>

<pre><code class='language-R'>imputeMFA(X, group, ncp = 2, type=rep("s",length(group)), method = c("Regularized","EM"), 
       row.w = NULL, coeff.ridge = 1,threshold = 1e-06, ind.sup = NULL,  
	   num.group.sup = NULL, seed = NULL, maxiter = 1000, ...)
	   </code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="imputeMFA_+3A_x">X</code></td>
<td>
<p>a data.frame with groups of continuous or categorical variables containing missing values</p>
</td></tr>
<tr><td><code id="imputeMFA_+3A_group">group</code></td>
<td>
<p>a vector indicating the number of variables in each group</p>
</td></tr>
<tr><td><code id="imputeMFA_+3A_ncp">ncp</code></td>
<td>
<p>integer corresponding to the number of components used to predict the missing entries</p>
</td></tr>
<tr><td><code id="imputeMFA_+3A_type">type</code></td>
<td>
<p>the type of variables in each group; three possibilities: &quot;c&quot; or &quot;s&quot; for continuous variables
(for &quot;c&quot; the variables are centered and for &quot;s&quot; variables are scaled to unit variance), &quot;n&quot; for categorical variables</p>
</td></tr>
<tr><td><code id="imputeMFA_+3A_method">method</code></td>
<td>
<p>&quot;Regularized&quot; by default or &quot;EM&quot;</p>
</td></tr>
<tr><td><code id="imputeMFA_+3A_row.w">row.w</code></td>
<td>
<p>row weights (by default, a vector of 1 for uniform row weights)</p>
</td></tr>
<tr><td><code id="imputeMFA_+3A_coeff.ridge">coeff.ridge</code></td>
<td>
<p>1 by default to perform the regularized imputeMFA algorithm; useful only if method=&quot;Regularized&quot;. Other regularization terms can be implemented by setting the value to less than 1 in order to regularized less (to get closer to the results of the EM method) or more than 1 to regularized more</p>
</td></tr>
<tr><td><code id="imputeMFA_+3A_threshold">threshold</code></td>
<td>
<p>the threshold for assessing convergence</p>
</td></tr>
<tr><td><code id="imputeMFA_+3A_ind.sup">ind.sup</code></td>
<td>
<p>a vector indicating the indexes of the supplementary individuals</p>
</td></tr>
<tr><td><code id="imputeMFA_+3A_num.group.sup">num.group.sup</code></td>
<td>
<p>a vector indicating the group of variables that are supplementary</p>
</td></tr>
<tr><td><code id="imputeMFA_+3A_seed">seed</code></td>
<td>
<p>integer, by default seed = NULL implies that missing values are initially imputed by the mean of each variable for the continuous variables and by the proportion of the category for the categorical variables coded with indicator matrices of dummy variables. Other values leads to a random initialization</p>
</td></tr>
<tr><td><code id="imputeMFA_+3A_maxiter">maxiter</code></td>
<td>
<p>integer, maximum number of iteration for the algorithm</p>
</td></tr>
<tr><td><code id="imputeMFA_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Impute the missing entries of a data with groups of variables using the iterative MFA algorithm (method=&quot;EM&quot;) or the regularised iterative MFA algorithm (method=&quot;Regularized&quot;). The (regularized) iterative MFA algorithm first consists in coding the categorical variables using the indicator matrix
of dummy variables. Then, in the initialization step, missing values are imputed with initial values such as the mean of the variable for the continuous variables and the proportion of the category for each category using the non-missing entries. If the argument seed is set to a specific value, a random initialization is performed: the initial values are drawn from a gaussian distribution
with mean and standard deviation calculated from the observed values for each continuous variable. The second step of the (regularized) iterative MFA algorithm is to perform MFA on the completed dataset. Then, it imputes the missing values with the (regularized) reconstruction formulae of order ncp (the fitted matrix computed with ncp components for the (regularized) scores and loadings). These steps of estimation of the parameters via MFA and imputation of the missing values using the (regularized) fitted matrix are iterate until convergence. <br />
</p>
<p>We advice to use the regularized version of the algorithm to avoid the overfitting problems which are very frequent when there are many missing values. In the regularized algorithm, the singular values of the MFA are shrinked.<br />
</p>
<p>The output of the algorithm can be used as an input of the MFA function of the FactoMineR package in order to perform the MFA on an incomplete dataset.</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>tab.disj</code></td>
<td>
<p>the imputed matrix; the observed values are kept for the non-missing entries and the missing values are replaced by the predicted ones. The categorical variables are coded with the indicator matrix of dummy variables. In this indicator matrix, the imputed values are real numbers but they met the constraint that the sum of the entries corresponding to one individual and one variable is equal to one. Consequently they can be seen as degree of membership to the corresponding category</p>
</td></tr>
<tr><td><code>completeObs</code></td>
<td>
<p>the imputed dataset; the observed values are kept for the non-missing entries and the missing values are replaced by the predicted ones. For the continuous variables, the values are the same as in the tab.disj output; for the categorical variables missing values are imputed with the most plausible categories according to the values in the tab.disj output</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Francois Husson  <a href="mailto:francois.husson@institut-agro.fr">francois.husson@institut-agro.fr</a> and Julie Josse  <a href="mailto:julie.josse@polytechnique.edu">julie.josse@polytechnique.edu</a>
</p>


<h3>References</h3>

<p>F. Husson, J. Josse (2013) Handling missing values in multiple factor analysis. Food Quality and Preferences, 30 (2), 77-85.<br />
Josse, J. and Husson, F. missMDA (2016). A Package for Handling Missing Values in Multivariate Data Analysis. Journal of Statistical Software, 70 (1), pp 1-31 <a href="https://doi.org/10.18637/jss.v070.i01">doi:10.18637/jss.v070.i01</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+imputePCA">imputePCA</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(orange)
## Impute the data and perform a MFA
## with groups of continuous variables only
res.impute &lt;- imputeMFA(orange, group=c(5,3), type=rep("s",2),ncp=2) 
res.mfa &lt;- MFA(res.impute$completeObs,group=c(5,3),type=rep("s",2)) 

## End(Not run)
## Not run: 
data(vnf)
## Impute the indicator matrix and perform a MFA 
## with groups of categorical variables only
res.comp &lt;- imputeMFA(vnf,group=c(6,5,3),type=c("n","n","n"),ncp=2)
require(FactoMineR)
res.mfa &lt;- MFA(vnf,group=c(6,5,3),type=c("n","n","n"),tab.comp=res.comp)

## End(Not run)
</code></pre>

<hr>
<h2 id='imputeMultilevel'>Impute a multilevel mixed dataset</h2><span id='topic+imputeMultilevel'></span>

<h3>Description</h3>

<p>Impute the missing values of a multilevel mixed dataset (with a variable that groups the individuals, and with continuous and categorical variables) using the principal component method &quot;multilevel factorial analysis for mixed data&quot;.</p>


<h3>Usage</h3>

<pre><code class='language-R'>imputeMultilevel(X, ifac = 1, ncpB = 2, ncpW=2, method=c("Regularized","EM"), 
    scale=TRUE, row.w = NULL, threshold = 1e-04, maxiter = 1000,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="imputeMultilevel_+3A_x">X</code></td>
<td>
<p>a data.frame with continuous and categorical variables containing missing values</p>
</td></tr>
<tr><td><code id="imputeMultilevel_+3A_ifac">ifac</code></td>
<td>
<p>integer corresponding to the index of the group variable</p>
</td></tr>
<tr><td><code id="imputeMultilevel_+3A_ncpb">ncpB</code></td>
<td>
<p>integer corresponding to the number of components used for the between group</p>
</td></tr>
<tr><td><code id="imputeMultilevel_+3A_ncpw">ncpW</code></td>
<td>
<p>integer corresponding to the number of components used for the within group</p>
</td></tr>
<tr><td><code id="imputeMultilevel_+3A_method">method</code></td>
<td>
<p>&quot;Regularized&quot; by default or &quot;EM&quot;</p>
</td></tr>
<tr><td><code id="imputeMultilevel_+3A_scale">scale</code></td>
<td>
<p>boolean. By default TRUE leading to a same weight for each variable. This is useful only when all the variables are continuous.</p>
</td></tr>
<tr><td><code id="imputeMultilevel_+3A_row.w">row.w</code></td>
<td>
<p>row weights (by default, uniform row weights)</p>
</td></tr>
<tr><td><code id="imputeMultilevel_+3A_threshold">threshold</code></td>
<td>
<p>the threshold for assessing convergence</p>
</td></tr>
<tr><td><code id="imputeMultilevel_+3A_maxiter">maxiter</code></td>
<td>
<p>integer, maximum number of iteration for the algorithm</p>
</td></tr>
<tr><td><code id="imputeMultilevel_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Impute the missing entries of a multilevel mixed data using the iterative multilevel FAMD algorithm (method=&quot;EM&quot;) or the regularised iterative multilevel FAMD algorithm (method=&quot;Regularized&quot;). 
</p>
<p>We advice to use the regularized version of the algorithm to avoid the overfitting problems which are very frequent when there are many missing values. In the regularized algorithm, the singular values of the FAMD are shrinked.<br />
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>completeObs</code></td>
<td>
<p>the mixed imputed dataset; the observed values are kept for the non-missing entries and the missing values are replaced by the predicted ones. For the continuous variables, the values are the same as in the tab.disj output; for the categorical variables missing values are imputed with the most plausible categories according to the values in the tab.disj output</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Francois Husson  <a href="mailto:francois.husson@institut-agro.fr">francois.husson@institut-agro.fr</a> and Julie Josse  <a href="mailto:julie.josse@polytechnique.edu">julie.josse@polytechnique.edu</a>
</p>


<h3>References</h3>

<p>F. Husson, J. Josse, B. Narasimhan, G. Robin (2019). Imputation of mixed data with multilevel singular value decomposition. Journal of Computational and Graphical Statistics, 28 (3), pp. 552-566 &lt;DOI:10.1080/10618600.2019.1585261&gt;</p>


<h3>See Also</h3>

<p><code><a href="#topic+imputePCA">imputePCA</a></code>,<code><a href="#topic+imputeFAMD">imputeFAMD</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Example on artificial data
data(ozone)
res &lt;- imputeMultilevel(ozone, ifac=12, ncpB=2, ncpW=2)

## End(Not run)
</code></pre>

<hr>
<h2 id='imputePCA'>Impute dataset with PCA</h2><span id='topic+imputePCA'></span>

<h3>Description</h3>

<p>Impute the missing values of a dataset with the Principal Components Analysis model. Can be used as a preliminary step before performing a PCA on an completed dataset.</p>


<h3>Usage</h3>

<pre><code class='language-R'>imputePCA(X, ncp = 2, scale = TRUE, method = c("Regularized","EM"), 
       row.w = NULL, ind.sup=NULL,quanti.sup=NULL,quali.sup=NULL,
	   coeff.ridge = 1, threshold = 1e-06, seed = NULL, nb.init = 1,  
	   maxiter = 1000, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="imputePCA_+3A_x">X</code></td>
<td>
<p>a data.frame with continuous variables containing missing values</p>
</td></tr>
<tr><td><code id="imputePCA_+3A_ncp">ncp</code></td>
<td>
<p>integer corresponding to the number of components used to  to predict the missing entries</p>
</td></tr>
<tr><td><code id="imputePCA_+3A_scale">scale</code></td>
<td>
<p>boolean. By default TRUE leading to a same weight for each variable</p>
</td></tr>
<tr><td><code id="imputePCA_+3A_method">method</code></td>
<td>
<p>&quot;Regularized&quot; by default or &quot;EM&quot;</p>
</td></tr>
<tr><td><code id="imputePCA_+3A_row.w">row.w</code></td>
<td>
<p>row weights  (by default, a vector of 1 for uniform row weights)</p>
</td></tr>
<tr><td><code id="imputePCA_+3A_ind.sup">ind.sup</code></td>
<td>
<p>a vector indicating the indexes of the supplementary individuals</p>
</td></tr>
<tr><td><code id="imputePCA_+3A_quanti.sup">quanti.sup</code></td>
<td>
<p>a vector indicating the indexes of the quantitative supplementary variables</p>
</td></tr>
<tr><td><code id="imputePCA_+3A_quali.sup">quali.sup</code></td>
<td>
<p>a vector indicating the indexes of the categorical supplementary variables</p>
</td></tr>
<tr><td><code id="imputePCA_+3A_coeff.ridge">coeff.ridge</code></td>
<td>
<p>1 by default to perform the regularized imputePCA algorithm; useful only if method=&quot;Regularized&quot;. Other regularization terms can be implemented by setting the value to less than 1 in order to regularized less (to get closer to the results of the EM method) or more than 1 to regularized more (to get closer to the results of the mean imputation)</p>
</td></tr>
<tr><td><code id="imputePCA_+3A_threshold">threshold</code></td>
<td>
<p>the threshold for assessing convergence</p>
</td></tr>
<tr><td><code id="imputePCA_+3A_seed">seed</code></td>
<td>
<p>integer, by default seed = NULL implies that missing values are initially imputed by the mean of each variable. Other values leads to a random initialization</p>
</td></tr>
<tr><td><code id="imputePCA_+3A_nb.init">nb.init</code></td>
<td>
<p>integer corresponding to the number of random initializations; the first initialization is the initialization with the mean imputation</p>
</td></tr>
<tr><td><code id="imputePCA_+3A_maxiter">maxiter</code></td>
<td>
<p>integer, maximum number of iteration for the algorithm</p>
</td></tr>
<tr><td><code id="imputePCA_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Impute the missing entries of a mixed data using the iterative PCA algorithm (method=&quot;EM&quot;) or the regularised iterative PCA algorithm (method=&quot;Regularized&quot;). The (regularized) iterative PCA algorithm first consists imputing missing values with initial values such as the mean of the variable. If the argument seed is set to a specific value, a random initialization is performed: the initial values are drawn from a gaussian distribution
with mean and standard deviation calculated from the observed values. nb.init different random initialization can be drawn. In such a situation, the solution giving the smallest objective function (the mean square error between the fitted matrix and the observed one) is kept.  The second step of the (regularized) iterative PCA algorithm is to perform PCA on the completed dataset. Then, it imputes the missing values with the (regularized) reconstruction formulae of order ncp (the fitted matrix computed with ncp components for the (regularized) scores and loadings). These steps of estimation of the parameters via PCA and imputation of the missing values using the (regularized) fitted matrix are iterate until convergence. The iterative PCA algorithm is also known as the EM-PCA algorithm since it corresponds to an EM algorithm of the fixed effect model where the data are generated as a fixed structure (with a low rank representation) corrupted by noise. The number of components used in the algorithm can be found using cross-validation criteria implemented in the function estim_ncpPCA.<br />
</p>
<p>We advice to use the regularized version of the algorithm to avoid the overfitting problems which are very frequent when there are many missing values. In the regularized algorithm, the singular values of the PCA are shrinked.<br />
</p>
<p>The output of the algorithm can be used as an input of the PCA function of the FactoMineR package in order to perform PCA on an incomplete dataset.</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>completeObs</code></td>
<td>
<p>the imputed dataset; the observed values are kept for the non-missing entries and the missing values are replaced by the predicted ones.</p>
</td></tr>
<tr><td><code>fittedX</code></td>
<td>
<p>the reconstructed data</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Francois Husson  <a href="mailto:francois.husson@institut-agro.fr">francois.husson@institut-agro.fr</a> and Julie Josse  <a href="mailto:julie.josse@polytechnique.edu">julie.josse@polytechnique.edu</a>
</p>


<h3>References</h3>

<p>Josse, J &amp; Husson, F. (2013). Handling missing values in exploratory multivariate data analysis methods. Journal de la SFdS. 153 (2), pp. 79-99.<br />
Josse, J. and Husson, F. missMDA (2016). A Package for Handling Missing Values in Multivariate Data Analysis. Journal of Statistical Software, 70 (1), pp 1-31 <a href="https://doi.org/10.18637/jss.v070.i01">doi:10.18637/jss.v070.i01</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+estim_ncpPCA">estim_ncpPCA</a></code>, <code><a href="#topic+MIPCA">MIPCA</a></code>,<br />
<a href="https://www.youtube.com/watch?v=YDbx2pk9xNY&amp;list=PLnZgp6epRBbQzxFnQrcxg09kRt-PA66T_&amp;index=2">Video showing how to perform PCA on an incomplete dataset</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(orange)
## First the number of components has to be chosen 
##   (for the imputation step)
## nb &lt;- estim_ncpPCA(orange,ncp.max=5) ## Time consuming, nb = 2

## Imputation
res.comp &lt;- imputePCA(orange,ncp=2)

## A PCA can be performed on the imputed data 
require(FactoMineR)
res.pca &lt;- PCA(res.comp$completeObs)

## End(Not run)
</code></pre>

<hr>
<h2 id='MIFAMD'>
Multiple Imputation with FAMD
</h2><span id='topic+MIFAMD'></span>

<h3>Description</h3>

<p>MIFAMD performs multiple imputations for mixed data (continuous and categorical) using Factorial Analysis of Mixed Data.</p>


<h3>Usage</h3>

<pre><code class='language-R'>MIFAMD(X, ncp = 2, method = c("Regularized", "EM"), coeff.ridge = 1, threshold = 1e-06, 
    seed = NULL, maxiter = 1000, nboot = 20, verbose = T)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MIFAMD_+3A_x">X</code></td>
<td>
<p>a data.frame with continuous AND categorical variables containing missing values</p>
</td></tr>
<tr><td><code id="MIFAMD_+3A_ncp">ncp</code></td>
<td>
<p>integer corresponding to the number of components used to reconstruct data with the FAMD reconstruction formulae</p>
</td></tr>
<tr><td><code id="MIFAMD_+3A_method">method</code></td>
<td>
<p>&quot;Regularized&quot; by default or &quot;EM&quot;</p>
</td></tr>
<tr><td><code id="MIFAMD_+3A_coeff.ridge">coeff.ridge</code></td>
<td>
<p>1 by default to perform the regularized imputeFAMD algorithm. Other regularization terms can be implemented by setting the value to less than 1 in order to regularized less (to get closer to the results of an EM method) or more than 1 to regularized more (to get closer to the results of the proportion imputation)</p>
</td></tr>
<tr><td><code id="MIFAMD_+3A_threshold">threshold</code></td>
<td>
<p>the threshold for the criterion convergence</p>
</td></tr>
<tr><td><code id="MIFAMD_+3A_seed">seed</code></td>
<td>
<p>integer, by default seed = NULL implies that missing values are initially imputed by the mean of each variable for the continuous variables and by the proportion of the category for the categorical variables coded with indicator matrices of dummy variables. Other values leads to a random initialization</p>
</td></tr>
<tr><td><code id="MIFAMD_+3A_maxiter">maxiter</code></td>
<td>
<p>integer, maximum number of iterations for the algorithm</p>
</td></tr>
<tr><td><code id="MIFAMD_+3A_nboot">nboot</code></td>
<td>
<p>the number of imputed datasets</p>
</td></tr>
<tr><td><code id="MIFAMD_+3A_verbose">verbose</code></td>
<td>
<p>use verbose=TRUE for screen printing of iteration numbers</p>
</td></tr>
</table>


<h3>Details</h3>

<p>MIFAMD generates nboot imputed data sets using FAMD. The observed values are the same from one dataset to the others, whereas the imputed values change. The algorithm is as follows: first, nboot weightings are defined for the individuals (equivalent to a non-parametric bootstrap). Then, the iterative regularized FAMD algorithm (Audigier et al., 2016) is applied according to each weighting, leading to nboot imputed tables. Dummy variables (coding for categorial variables) of these imputed tables are scaled to verify the constraint that the sum is equal to one per variable and per individual. Lastly, missing categories are drawn from the probabilities given by the imputed tables, and gaussian noise is added to the prediction of continuous variables. Thus, nboot imputed mixed data sets are obtained. The variation among the imputed values reflects the variability with which missing values can be predicted.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>res.MI</code></td>
<td>
<p>A list of data frames corresponding to the nboot imputed mixed data sets</p>
</td></tr>
<tr><td><code>res.imputeFAMD</code></td>
<td>
<p>A list corresponding to the output obtained with the function imputeFAMD (single imputation)</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The matched call</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vincent Audigier <a href="mailto:vincent.audigier@lecnam.net">vincent.audigier@lecnam.net</a>
</p>


<h3>References</h3>

<p>Audigier, V., Husson, F. &amp; Josse, J. (2015). A principal components method to impute mixed data. Advances in Data Analysis and Classification, 10(1), 5-26. &lt;doi:10.1007/s11634-014-0195-1&gt;
</p>
<p>Audigier, V., Husson, F., Josse, J. (2017). MIMCA: Multiple imputation for categorical variables with multiple correspondence analysis. &lt;doi:10.1007/s11222-016-9635-4&gt;
</p>
<p>Little R.J.A., Rubin D.B. (2002) Statistical Analysis with Missing Data. Wiley series in probability and statistics, New-York
</p>


<h3>See Also</h3>

<p><code><a href="#topic+imputeFAMD">imputeFAMD</a></code>,<code><a href="#topic+MIPCA">MIPCA</a></code>,<code><a href="#topic+MIMCA">MIMCA</a></code>,<code><a href="#topic+estim_ncpFAMD">estim_ncpFAMD</a></code>,<code>with.mids</code>,<code>pool</code>,<code>summary.mira</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(ozone)

## First the number of components has to be chosen 
##   (for the reconstruction step)
 nb &lt;- estim_ncpFAMD(ozone) ## Time-consuming, nb = 2


## Multiple Imputation
res.mi&lt;-MIFAMD(ozone,ncp = 2,nboot=50)


## First completed data matrix
head(res.mi$res.MI[[1]])

## Analysis and pooling with mice
require(mice)
imp&lt;-prelim(res.mi,ozone)
fit &lt;- with(data=imp,exp=lm(maxO3~T9+T12+T15+Ne9+Ne12+Ne15+Vx9+Vx12+Vx15+maxO3v+vent+pluie))
res.pool&lt;-pool(fit)
summary(res.pool)

## End(Not run)
</code></pre>

<hr>
<h2 id='MIMCA'>Multiple Imputation with MCA</h2><span id='topic+MIMCA'></span>

<h3>Description</h3>

<p>MIMCA performs multiple imputations for categorical data using Multiple Correspondence Analysis.</p>


<h3>Usage</h3>

<pre><code class='language-R'>MIMCA(X, nboot=100, ncp, coeff.ridge=1, threshold = 1e-06, maxiter = 1000, verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MIMCA_+3A_x">X</code></td>
<td>
<p>a data.frame with categorical variables containing missing values</p>
</td></tr>
<tr><td><code id="MIMCA_+3A_nboot">nboot</code></td>
<td>
<p>the number of imputed datasets</p>
</td></tr>
<tr><td><code id="MIMCA_+3A_ncp">ncp</code></td>
<td>
<p>integer corresponding to the number of components used to reconstruct data with the MCA reconstruction formulae</p>
</td></tr>
<tr><td><code id="MIMCA_+3A_coeff.ridge">coeff.ridge</code></td>
<td>
<p>1 by default to perform the regularized imputeMCA algorithm. Other regularization terms can be implemented by setting the value to less than 1 in order to regularized less (to get closer to the results of an EM method) or more than 1 to regularized more (to get closer to the results of the proportion imputation)</p>
</td></tr>
<tr><td><code id="MIMCA_+3A_threshold">threshold</code></td>
<td>
<p>the threshold for assessing convergence for the (regularized) iterative MCA algorithm</p>
</td></tr>
<tr><td><code id="MIMCA_+3A_maxiter">maxiter</code></td>
<td>
<p>integer, maximum number of iterations for the (regularized) iterative MCA algorithm</p>
</td></tr>
<tr><td><code id="MIMCA_+3A_verbose">verbose</code></td>
<td>
<p>use verbose=TRUE for screen printing of iteration numbers</p>
</td></tr>
</table>


<h3>Details</h3>

<p>MIMCA generates nboot imputed data sets from MCA. The observed values are the same from one dataset to the others whereas the imputed values change. First, nboot weightings are defined for the individuals. Then, the iterative regularized MCA algorithm (Josse, 2012) is applied according to each weighting, leading to nboot imputed tables. These imputed tables are scaled to verify the constraint that the sum is equal to one per variable and per individual. Lastly, missing categories are drawn from the probabilities given by the imputed tables. Thus, nboot imputed categorical data sets are obtained. The variation among the imputed values reflects the variability with which missing values can be predicted. The multiple imputation is proper in the sense of Little and Rubin (2002) since it takes into account the variability of the parameters using a non-parametric bootstrap approach.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>res.MI</code></td>
<td>
<p>A list of data frames corresponding to the nboot imputed categorical data sets</p>
</td></tr>
<tr><td><code>res.imputeMCA</code></td>
<td>
<p>A matrix corresponding to the single imputed disjunctive table obtained with the function imputeMCA</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The matched call</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vincent Audigier <a href="mailto:vincent.audigier@cnam.fr">vincent.audigier@cnam.fr</a>, Francois Husson  <a href="mailto:francois.husson@institut-agro.fr">francois.husson@institut-agro.fr</a> and Julie Josse  <a href="mailto:julie.josse@polytechnique.edu">julie.josse@polytechnique.edu</a>
</p>


<h3>References</h3>

<p>Audigier, V., Husson, F., Josse, J. (2015). MIMCA: Multiple imputation for categorical variables with multiple correspondence analysis.
</p>
<p>Josse, J., Chavent, M., Liquet, B. and Husson, F. (2010). Handling missing values with Regularized Iterative Multiple Correspondence Analysis, Journal of Classification, 29 (1), pp. 91-116.
</p>
<p>Little R.J.A., Rubin D.B. (2002) Statistical Analysis with Missing Data. Wiley series in probability and statistics, New-York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+imputeMCA">imputeMCA</a></code>,<code><a href="#topic+MIPCA">MIPCA</a></code>,<code><a href="#topic+estim_ncpMCA">estim_ncpMCA</a></code>,<code>with.mids</code>,<code>pool</code>,<code>summary.mira</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(TitanicNA)

## First the number of components has to be chosen 
##   (for the reconstruction step)
## nb &lt;- estim_ncpMCA(TitanicNA) ## Time-consuming, nb = 5

## Multiple Imputation
res.mi &lt;- MIMCA(TitanicNA, ncp=5, verbose=TRUE)

## First completed data matrix
res.mi$res.MI[[1]]
 
## Analysis and pooling with mice
require(mice)
imp&lt;-prelim(res.mi,TitanicNA)
fit &lt;- with(data=imp,exp=glm(SURV~CLASS+AGE+SEX,family = "binomial"))
res.pool&lt;-pool(fit)
summary(res.pool)


## End(Not run)
</code></pre>

<hr>
<h2 id='MIPCA'>Multiple Imputation with PCA</h2><span id='topic+MIPCA'></span>

<h3>Description</h3>

<p>MIPCA performs Multiple Imputation with a PCA model. Can be used as a preliminary step to perform Multiple Imputation in PCA.</p>


<h3>Usage</h3>

<pre><code class='language-R'>MIPCA(X, ncp = 2, scale = TRUE, method=c("Regularized","EM"), threshold = 1e-04, 
    nboot = 100,  method.mi="Boot", Lstart=1000, L=100, verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MIPCA_+3A_x">X</code></td>
<td>
<p>a data.frame with continuous variables containing missing values</p>
</td></tr>
<tr><td><code id="MIPCA_+3A_ncp">ncp</code></td>
<td>
<p>integer corresponding to the number of components used to reconstruct data with the PCA reconstruction formulae</p>
</td></tr>
<tr><td><code id="MIPCA_+3A_scale">scale</code></td>
<td>
<p>boolean. By default TRUE leading to a same weight for each variable</p>
</td></tr>
<tr><td><code id="MIPCA_+3A_method">method</code></td>
<td>
<p>&quot;Regularized&quot; by default or &quot;EM&quot;</p>
</td></tr>
<tr><td><code id="MIPCA_+3A_threshold">threshold</code></td>
<td>
<p>the threshold for the criterion convergence</p>
</td></tr>
<tr><td><code id="MIPCA_+3A_nboot">nboot</code></td>
<td>
<p>the number of imputed datasets</p>
</td></tr>
<tr><td><code id="MIPCA_+3A_method.mi">method.mi</code></td>
<td>
<p>a string. If &quot;Bayes&quot;, the uncertainty on the parameters of the imputation model is taken into account using a Bayesian treatment of PCA. By default &quot;Boot&quot; leading to a MI which reflect uncertainty a bootstrap procedure. See details.</p>
</td></tr>
<tr><td><code id="MIPCA_+3A_lstart">Lstart</code></td>
<td>
<p>number of iterations for the burn-in period (only used if method.mi=&quot;Bayes&quot;)</p>
</td></tr>
<tr><td><code id="MIPCA_+3A_l">L</code></td>
<td>
<p>number of skipped iterations to keep one imputed data set after the burn-in period (only used if method.mi=&quot;Bayes&quot;)</p>
</td></tr>
<tr><td><code id="MIPCA_+3A_verbose">verbose</code></td>
<td>
<p>use verbose=TRUE for screen printing of iteration numbers</p>
</td></tr>
</table>


<h3>Details</h3>

<p>MIPCA generates nboot imputed datasets from a PCA model. The observed values are the same from one dataset to the others whereas the imputed values change. The variation among the imputed values reflects the variability with which missing values can be predicted.
The multiple imputation is proper in the sense of Little and Rubin (2002) since it takes into account the variability of the parameters. Two versions are available: multiple imputation using a parametric bootstrap (Josse, J., Husson, F. (2010)) and multiple imputation using a Bayesian treatment of the PCA model (Audigier et al 2015). The methods differ by the way in which the variability due to missing values is reflected. The method used is controlled by the <code>method.mi</code> argument. By default, MIPCA uses the parametric bootstrap <code>method.mi="Boot"</code>. This bootstrap method is more recommended to evaluate uncertainty in PCA (through confidence ellipses). Otherwise, the Bayesian method can be used by specifying the argument <code>method.mi="Bayes"</code>. It is based on an iterative algorithm which alternates imputation of the data set and draw of the PCA parameters in a posterior distribution. These steps are repeated <code>Lstart</code> times to reach a convergence. Then, one imputed data set is kept each <code>L</code> iterations to ensure independence between imputed values from a data set to another. The Bayesian method is more recommanded to apply a statistical method on an incomplete data set.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>res.imputePCA</code></td>
<td>
<p>A matrix corresponding to the imputed dataset obtained with the function imputePCA (the completed dataset)</p>
</td></tr>
<tr><td><code>res.MI</code></td>
<td>
<p>A list of data frames corresponding to the nboot imputed data sets</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Francois Husson  <a href="mailto:francois.husson@institut-agro.fr">francois.husson@institut-agro.fr</a>, Julie Josse  <a href="mailto:julie.josse@polytechnique.edu">julie.josse@polytechnique.edu</a> and Vincent Audigier</p>


<h3>References</h3>

<p>Josse, J., Husson, F. (2011). Multiple Imputation in PCA. Advances in Data Analysis and Classification.
</p>
<p>Audigier, V. Josse, J., Husson, F. (2015). Multiple imputation for continuous variables using a Bayesian principal component analysis. Journal of Statistical Computation and Simulation.
</p>
<p>Little R.J.A., Rubin D.B. (2002) Statistical Analysis with Missing Data. Wiley series in probability and statistics, New-York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+imputePCA">imputePCA</a></code>,<code><a href="#topic+plot.MIPCA">plot.MIPCA</a></code>,<code><a href="#topic+Overimpute">Overimpute</a></code>,<code><a href="#topic+MIMCA">MIMCA</a></code>,<code>with.mids</code>,<code>pool</code>,<code>summary.mira</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#########################################################
## Multiple Imputation for visualization on the PCA map
#########################################################

data(orange)
## First the number of components has to be chosen 
##   (for the reconstruction step)
nb &lt;- estim_ncpPCA(orange,ncp.max=4)

## Multiple Imputation
resMI &lt;- MIPCA(orange,ncp=2)

## Visualization on the PCA map
plot(resMI)

#########################################################
## Multiple Imputation for applying statistical methods
(Bayesian method)
#########################################################
data(ozone)

## First the number of components has to be chosen 
nb &lt;- estim_ncpPCA(ozone[,1:11])

## Multiple Imputation with Bayesian method
res.BayesMIPCA&lt;-MIPCA(ozone[,1:11],ncp=2,method.mi="Bayes",verbose=TRUE)

## Regression on the multiply imputed data set and pooling with mice
require(mice)
imp&lt;-prelim(res.mi=res.BayesMIPCA,X=ozone[,1:11])#creating a mids object
fit &lt;- with(data=imp,exp=lm(maxO3~T9+T12+T15+Ne9+Ne12+Ne15+Vx9+Vx12+Vx15+maxO3v))#analysis
res.pool&lt;-pool(fit);summary(res.pool)#pooling

## Diagnostics
res.over&lt;-Overimpute(res.BayesMIPCA)

## End(Not run)
</code></pre>

<hr>
<h2 id='orange'>
Sensory description of 12 orange juices by 8 attributes.
</h2><span id='topic+orange'></span>

<h3>Description</h3>

<p>Sensory description of 12 orange juices by 8 attributes. Some values are missing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(orange)</code></pre>


<h3>Format</h3>

<p>A data frame with 12 rows and 8 columns. Rows represent the different orange juices,
columns represent the attributes.
</p>


<h3>Details</h3>

<p>A sensory data frame.
</p>


<h3>Source</h3>

<p>Francois Husson, Agrocampus Rennes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(orange)
nb &lt;- estim_ncpPCA(orange,ncp.min=0,ncp.max=5,method.cv="Kfold",nbsim=20,pNA=0.05)
res.comp &lt;- imputePCA(orange,ncp=nb$ncp)
require(FactoMineR)
res.pca &lt;- PCA(res.comp$completeObs)
resMI &lt;- MIPCA(orange,ncp=nb$ncp)
plot(resMI)

## End(Not run)
</code></pre>

<hr>
<h2 id='Overimpute'>Overimputation diagnostic plot</h2><span id='topic+Overimpute'></span>

<h3>Description</h3>

<p>Assess the fit of the predictive distribution after performing multiple imputation with the function <code>MIPCA</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Overimpute(output, plotvars)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Overimpute_+3A_output">output</code></td>
<td>
<p>output from the function <code>MIPCA</code>.</p>
</td></tr>
<tr><td><code id="Overimpute_+3A_plotvars">plotvars</code></td>
<td>
<p>column number of the variable to overimpute.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function imputes each observed values from each of the parameters of the imputation model obtained from the <code>MIPCA</code> procedure. The comparison between the &ldquo;overimputed&quot; values and the observed values is made by constructing a confidence interval for each observed value using the quantiles of the overimputed values (Blackwell et al. (2015)). Note that confidence intervals constructed with quantiles require a large number of imputations. If the model fits well the data, then the 90% confidence interval should contain the observed value in 90% of the cases. The function <code>Overimpute</code> takes as an input the output of the MIPCA function (<code>output</code>) and the indices of the variables that are plotted (<code>plotvars</code>).
</p>


<h3>Value</h3>

<p>A list of 6-column matrix that contains (1) the row in the original data,
(2) the observed value of that observation, (3) the mean of the
overimputations, (4) the lower bound of the 90% confidence interval of
the overimputations, (5) the upper bound of the 90% confidence interval
of the overimputations, and (6) the proportion of the other variables that were
missing for that observation in the original data.</p>


<h3>References</h3>

<p>Blackwell, M., Honaker, J. and King. G. 2015. A Unified Approach to Measurement Error and Missing Data: Overview and Applications. Sociological Methods and Research, 1-39.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MIPCA">MIPCA</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
require(Zelig)
data(ozone)

# First the number of components has to be chosen 
nb &lt;- estim_ncpPCA(ozone[,1:11])

# Multiple Imputation with Bayesian method
res.BayesMIPCA&lt;-MIPCA(ozone[,1:11],ncp=2,method.mi="Bayes",verbose=T)

# Regression on the multiply imputed data set and pooling
z.out &lt;- zelig(maxO3~., model = "ls", data = res.BayesMIPCA$res.MI,cite=F)
summary(z.out,digits=5)

# Diagnostics
res.over&lt;-Overimpute(res.BayesMIPCA)


## End(Not run)
</code></pre>

<hr>
<h2 id='ozone'>
Daily measurements of meteorological variables and ozone concentration
</h2><span id='topic+ozone'></span>

<h3>Description</h3>

<p>This dataset contains 112 daily measurements of meteorological variables (wind speed, temperature, rainfall, etc.) and ozone concentration recorded in Rennes (France) during the summer 2001. There are 11 continuous variables and 2 categorical variables with 2 or 4 levels. Some values are missing.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ozone)</code></pre>


<h3>Format</h3>

<p>A data frame with 112 observations on 13 variables.
</p>


<h3>Source</h3>

<p>Cornillon, P.-A., Guyader, A., Husson, F., Jegou, N., Josse, J., Kloareg, M., Matzner-Lober, E., Rouviere, L., (2012). R for Statistics. Chapman &amp; Hall/CRC Computer Science &amp; Data Analysis, Rennes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(ozone)
res.comp &lt;- imputeFAMD(ozone, ncp=3)
require(FactoMineR)
res.afdm &lt;- FAMD(ozone,tab.comp=res.comp$tab.disj)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.MIMCA'>Plot the graphs for the Multiple Imputation in MCA</h2><span id='topic+plot.MIMCA'></span>

<h3>Description</h3>

<p>From the multiple imputed datasets, the function plots graphs for the individuals, categories and dimensions for the Multiple Correspondance Analysis (MCA)</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MIMCA'
plot(x, choice = "all", axes = c(1, 2), new.plot = TRUE, 
   main = NULL, level.conf = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.MIMCA_+3A_x">x</code></td>
<td>
<p>an object of class MIMCA</p>
</td></tr>
<tr><td><code id="plot.MIMCA_+3A_choice">choice</code></td>
<td>
<p>the graph(s) to plot. By default &quot;all&quot; the graphs are plotted. &quot;ind.proc&quot; the procrustean representation of the individuals, &quot;dim&quot; the representation of the dimensions of the MCA, &quot;ind.supp&quot; the projection of the individuals as supplementary individuals, &quot;mod.supp&quot; the projection of the categories</p>
</td></tr>
<tr><td><code id="plot.MIMCA_+3A_axes">axes</code></td>
<td>
<p>a length 2 vector specifying the components to plot</p>
</td></tr>
<tr><td><code id="plot.MIMCA_+3A_new.plot">new.plot</code></td>
<td>
<p>boolean, if TRUE, a new graphical device is created</p>
</td></tr>
<tr><td><code id="plot.MIMCA_+3A_main">main</code></td>
<td>
<p>string corresponding to the title of the graph you draw (by default NULL and a title is chosen)</p>
</td></tr>
<tr><td><code id="plot.MIMCA_+3A_level.conf">level.conf</code></td>
<td>
<p>confidence level used to construct the ellipses. By default, 0.95</p>
</td></tr>
<tr><td><code id="plot.MIMCA_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots the multiple imputed datasets obtained by the function MIMCA.
The idea is to represent the multiple imputed dataset on a reference configuration (the map obtained from the MCA on the incomplete dataset). Different ways are available to take into account and visualize the supplement variability due to missing values.
</p>


<h3>Value</h3>

<p>Four graphs can be drawn:
</p>
<table role = "presentation">
<tr><td><code>ind.supp</code></td>
<td>
<p>The individuals of the imputed datasets are projected as supplementary individuals onto the reference MCA map; then confidence ellipses are drawn</p>
</td></tr>
<tr><td><code>mod.supp</code></td>
<td>
<p>The individuals of the imputed datasets are projected as supplementary individuals onto the reference MCA map, but only categories are plotted; then confidence ellipses are drawn</p>
</td></tr>
<tr><td><code>ind.proc</code></td>
<td>
<p>A PCA is performed on each imputed dataset and each configuration of scores is rotated onto the reference MCA map with procrustes rotation; then confidence ellipses are drawn</p>
</td></tr>
<tr><td><code>dim</code></td>
<td>
<p>The dimensions of each imputed dataset are projected as supplementary variables onto the dimensions of the reference MCA dimensions</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Audigier Vincent <a href="mailto:vincent.audigier@cnam.fr">vincent.audigier@cnam.fr</a>, Francois Husson  <a href="mailto:francois.husson@institut-agro.fr">francois.husson@institut-agro.fr</a> and Julie Josse  <a href="mailto:julie.josse@polytechnique.edu">julie.josse@polytechnique.edu</a>
</p>


<h3>References</h3>

<p>Audigier, V., Husson, F., Josse, J. (2016). MIMCA: Multiple imputation for categorical variables with multiple correspondence analysis</p>


<h3>See Also</h3>

<p><code><a href="#topic+MIMCA">MIMCA</a></code>,<code><a href="#topic+imputeMCA">imputeMCA</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(TitanicNA)

## First the number of components has to be chosen 
##   (for the reconstruction step)
## nb &lt;- estim_ncpMCA(TitanicNA) ## Time-consuming, nb = 5

## Multiple Imputation
res.mi &lt;- MIMCA(TitanicNA, ncp=5, verbose=TRUE)

## Plot the graphs
plot(res.mi)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.MIPCA'>Plot the graphs for the Multiple Imputation in PCA</h2><span id='topic+plot.MIPCA'></span>

<h3>Description</h3>

<p>From the multiple imputed datasets, the function plots graphs for the individuals, variables and dimensions for the Principal Component Analysis (PCA)</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MIPCA'
plot(x, choice = "all", axes = c(1, 2), new.plot = TRUE, 
   main = NULL, level.conf = 0.95, graph.type = c("ggplot","classic"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.MIPCA_+3A_x">x</code></td>
<td>
<p>an object of class MIPCA</p>
</td></tr>
<tr><td><code id="plot.MIPCA_+3A_choice">choice</code></td>
<td>
<p>the graph(s) to plot. By default &quot;all&quot; the graphs are plotted. &quot;ind.proc&quot; the procrustean representation of the individuals, &quot;dim&quot; the representation of the dimensions of the PCA, &quot;ind.supp&quot; the projection of the individuals as supplementary individuals, &quot;var&quot; the projection of the variables as supplementary variables</p>
</td></tr>
<tr><td><code id="plot.MIPCA_+3A_axes">axes</code></td>
<td>
<p>a length 2 vector specifying the components to plot</p>
</td></tr>
<tr><td><code id="plot.MIPCA_+3A_new.plot">new.plot</code></td>
<td>
<p>boolean, if TRUE, a new graphical device is created</p>
</td></tr>
<tr><td><code id="plot.MIPCA_+3A_main">main</code></td>
<td>
<p>string corresponding to the title of the graph you draw (by default NULL and a title is chosen)</p>
</td></tr>
<tr><td><code id="plot.MIPCA_+3A_level.conf">level.conf</code></td>
<td>
<p>confidence level used to construct the ellipses. By default, 0.95</p>
</td></tr>
<tr><td><code id="plot.MIPCA_+3A_graph.type">graph.type</code></td>
<td>
<p>a character that gives the type of graph used: &quot;ggplot&quot; or &quot;classic&quot;</p>
</td></tr>
<tr><td><code id="plot.MIPCA_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots the multiple imputed datasets obtained by the function MIPCA.
The idea is to represent the multiple imputed dataset on a reference configuration (the map obtained from the PCA on the incomplete dataset). Different ways are available to take into account and visualize the supplement variability due to missing values.
</p>


<h3>Value</h3>

<p>Four graphs can be drawn:
</p>
<table role = "presentation">
<tr><td><code>ind.supp</code></td>
<td>
<p>The individuals of the imputed datasets are projected as supplementary individuals onto the reference PCA map; then confidence ellipses are drawn</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>The variables of the imputed datasets are projected as supplementary variables onto the reference PCA map</p>
</td></tr>
<tr><td><code>ind.proc</code></td>
<td>
<p>A PCA is performed on each imputed dataset and each configuration of scores is rotated onto the reference PCA map with procrustes rotation; then confidence ellipses are drawn</p>
</td></tr>
<tr><td><code>dim</code></td>
<td>
<p>The dimensions of each imputed dataset are projected as supplementary variables onto the dimensions of the reference PCA dimensions</p>
</td></tr>
<tr><td><code>graph</code></td>
<td>
<p>if the <code>graph.type=ggplot</code> an object with a list with the ggplot graphs that can be modified and plotted</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Francois Husson  <a href="mailto:francois.husson@institut-agro.fr">francois.husson@institut-agro.fr</a> and Julie Josse  <a href="mailto:julie.josse@polytechnique.edu">julie.josse@polytechnique.edu</a>
</p>


<h3>References</h3>

<p>Josse, J., Husson, F. (2010). Multiple Imputation in PCA</p>


<h3>See Also</h3>

<p><code><a href="#topic+MIPCA">MIPCA</a></code>,<code><a href="#topic+imputePCA">imputePCA</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(orange)
## nb &lt;- estim_ncpPCA(orange,ncp.max=5) ## Time consuming, nb = 2
resMI &lt;- MIPCA(orange,ncp=2)
plot(resMI)

## End(Not run)
</code></pre>

<hr>
<h2 id='prelim'>Converts a dataset imputed by MIMCA, MIPCA or MIFAMD into a mids object</h2><span id='topic+prelim'></span>

<h3>Description</h3>

<p>This function performs grouping and sorting operations on a multiply imputed dataset. It creates a mids object that is needed for input to with.mids, which allows analyse of the multiply imputed data set. The original incomplete data set needs to be available so that we know where the missing data are.</p>


<h3>Usage</h3>

<pre><code class='language-R'>prelim(res.mi,X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prelim_+3A_res.mi">res.mi</code></td>
<td>
<p>an output of the functions MIPCA, MIMCA or MIFAMD</p>
</td></tr>
<tr><td><code id="prelim_+3A_x">X</code></td>
<td>
<p>the original incomplete data set corresponding to the res.mi argument</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>imp.mids</code></td>
<td>
<p>An object of type mids</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vincent Audigier <a href="mailto:vincent.audigier@lecnam.net">vincent.audigier@lecnam.net</a>, Francois Husson  <a href="mailto:francois.husson@institut-agro.fr">francois.husson@institut-agro.fr</a> and Julie Josse  <a href="mailto:josse@agrocampus-ouest.fr">josse@agrocampus-ouest.fr</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MIFAMD">MIFAMD</a></code>,<code><a href="#topic+MIPCA">MIPCA</a></code>,<code><a href="#topic+MIMCA">MIMCA</a></code>,<code>with.mids</code>,<code>pool</code>,<code>summary.mira</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(TitanicNA)

## First the number of components has to be chosen 
##   (for the reconstruction step)
## nb &lt;- estim_ncpMCA(TitanicNA,ncp.max=5) ## Time-consuming, nb = 5

## Multiple Imputation
res.mi &lt;- MIMCA(TitanicNA, ncp=5, verbose=T)

#Analysis
imp&lt;-prelim(res.mi,TitanicNA)
fit &lt;- with(data=imp,exp=glm(SURV~CLASS+AGE+SEX,family = "binomial"))

#Pooling
res.pool&lt;-pool(fit)
summary(res.pool)

## End(Not run)
</code></pre>

<hr>
<h2 id='snorena'>
Characterization of people who snore
</h2><span id='topic+snorena'></span>

<h3>Description</h3>

<p>This dataset contains 100 individuals and 7 variables (age, weight, size, alcohol, sex, snore, tobacco). There are 4 continuous variables and 3 categorical variables with 2 levels. Some values are missing.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(snorena)</code></pre>


<h3>Format</h3>

<p>A data frame with 100 observations on 7 variables.
</p>


<h3>Source</h3>

<p>Cornillon, P.-A., Guyader, A., Husson, F., Jegou, N., Josse, J., Kloareg, M., Matzner-Lober, E., Rouviere, L., (2012). R for Statistics. Chapman &amp; Hall/CRC Computer Science &amp; Data Analysis, Rennes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(snorena)
res.comp &lt;- imputeFAMD(snorena, ncp=3)
require(FactoMineR)
res.afdm &lt;- FAMD(snorena, tab.comp = res.comp$tab.disj)

## End(Not run)
</code></pre>

<hr>
<h2 id='TitanicNA'>
Categorical data set with missing values: Survival of passengers on the Titanic
</h2><span id='topic+TitanicNA'></span>

<h3>Description</h3>

<p>This data set provides information on the fate of passengers on the fatal maiden voyage of the ocean liner Titanic, summarized according to economic status (class), sex, age and survival. Twenty percent of values are missing completely at random on each variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(TitanicNA)</code></pre>


<h3>Format</h3>

<p>A data frame with 2201 observations on the following 4 variables:
</p>
<p>CLASS
0 = crew, 1 = first, 2 = second, 3 = third, denoting the economic status of the subject
</p>
<p>AGE
1 = adult, 0 = child, denoting if the subject is an adult or a child
</p>
<p>SEX
1 = male, 0 = female, denoting the sex of the subject
</p>
<p>SURV
1 = yes, 0 = no, denoting if the passenger lived through the fatal maiden voyage of the ocean liner Titanic
</p>


<h3>Source</h3>

<p>British Board of Trade (1990), Report on the Loss of the Titanic (S.S.). British Board of Trade Inquiry Report (reprint). Gloucester, UK: Allan Sutton Publishing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(TitanicNA)
</code></pre>

<hr>
<h2 id='vnf'>
Questionnaire done by 1232 individuals who answered 14 questions
</h2><span id='topic+vnf'></span>

<h3>Description</h3>

<p>A user satisfaction survey of pleasure craft operators on the &ldquo;Canal des Deux Mers&rdquo;, located in South of France, was carried out by the public corporation &ldquo;Voies Navigables de France&rdquo; responsible for managing and developing the largest network of navigable waterways in Europe. Some values are missing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(vnf)</code></pre>


<h3>Format</h3>

<p>A data frame with 1232 observations on 14 categorical variables.
</p>


<h3>References</h3>

<p>Josse, J., Chavent, M., Liquet, B. and Husson, F. (2010). Handling missing values with Regularized Iterative Multiple Correspondence Analysis, Journal of Classification, 29 (1), pp. 91-116.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(vnf)
tab.disj.impute &lt;- imputeMCA(vnf, ncp=4)$tab.disj
require(FactoMineR)
res.mca &lt;- MCA(vnf,tab.disj=tab.disj.impute)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
