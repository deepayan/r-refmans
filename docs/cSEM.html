<!DOCTYPE html><html><head><title>Help for package cSEM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cSEM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cSEM-package'><p>cSEM: A package for composite-based structural equation modeling</p></a></li>
<li><a href='#adjustAlpha'><p>Internal: Multiple testing correction</p></a></li>
<li><a href='#Anime'><p>Data: Anime</p></a></li>
<li><a href='#args_assess_dotdotdot'><p>Complete list of assess()'s ... arguments</p></a></li>
<li><a href='#args_default'><p>Show argument defaults or candidates</p></a></li>
<li><a href='#assess'><p>Assess model</p></a></li>
<li><a href='#Benitezetal2020'><p>Data: Benitezetal2020</p></a></li>
<li><a href='#BergamiBagozzi2000'><p>Data: BergamiBagozzi2000</p></a></li>
<li><a href='#calculate2ndStage'><p>Internal: Second/Third stage of the two-stage approach for second order constructs</p></a></li>
<li><a href='#calculateAVE'><p>Average variance extracted (AVE)</p></a></li>
<li><a href='#calculateCompositeVCV'><p>Internal: Calculate composite variance-covariance matrix</p></a></li>
<li><a href='#calculateConstructVCV'><p>Internal: Calculate construct variance-covariance matrix</p></a></li>
<li><a href='#calculateCorrectionFactors'><p>Internal: Calculate PLSc correction factors</p></a></li>
<li><a href='#calculateDf'><p>Degrees of freedom</p></a></li>
<li><a href='#calculateDistance'><p>Internal: Matrix difference</p></a></li>
<li><a href='#calculateEffects'><p>Internal: Calculate direct, indirect and total effect</p></a></li>
<li><a href='#calculatef2'><p>Calculate Cohens f^2</p></a></li>
<li><a href='#calculateFLCriterion'><p>Fornell-Larcker criterion</p></a></li>
<li><a href='#calculateFR'><p>Internal: ANOVA F-test statistic</p></a></li>
<li><a href='#calculateGoF'><p>Goodness of Fit (GoF)</p></a></li>
<li><a href='#calculateHTMT'><p>HTMT</p></a></li>
<li><a href='#calculateIndicatorCor'><p>Internal: Calculate indicator correlation matrix</p></a></li>
<li><a href='#calculateInnerWeightsPLS'><p>Internal: Calculate the inner weights for PLS-PM</p></a></li>
<li><a href='#calculateMAE'><p>Internal: Calculate prediction metrics</p></a></li>
<li><a href='#calculateModelSelectionCriteria'><p>Model selection criteria</p></a></li>
<li><a href='#calculateOuterWeightsPLS'><p>Internal: Calculate the outer weights for PLS-PM</p></a></li>
<li><a href='#calculateParameterDifference'><p>Internal: Parameter differences across groups</p></a></li>
<li><a href='#calculatePr'><p>Internal: Calculation of the CDF used in Henseler et al. (2009)</p></a></li>
<li><a href='#calculateReliabilities'><p>Internal: Calculate Reliabilities</p></a></li>
<li><a href='#calculateVIFModeB'><p>Calculate variance inflation factors (VIF) for weights obtained by PLS Mode B</p></a></li>
<li><a href='#calculateWeightsGSCA'><p>Calculate composite weights using GSCA</p></a></li>
<li><a href='#calculateWeightsGSCAm'><p>Calculate weights using GSCAm</p></a></li>
<li><a href='#calculateWeightsKettenring'><p>Calculate composite weights using GCCA</p></a></li>
<li><a href='#calculateWeightsPCA'><p>Calculate composite weights using principal component analysis (PCA)</p></a></li>
<li><a href='#calculateWeightsPLS'><p>Calculate composite weights using PLS-PM</p></a></li>
<li><a href='#calculateWeightsUnit'><p>Calculate composite weights using unit weights</p></a></li>
<li><a href='#checkConvergence'><p>Internal: Check convergence</p></a></li>
<li><a href='#classifyConstructs'><p>Internal: Classify structural model terms by type</p></a></li>
<li><a href='#convertModel'><p>Internal: Convert second order cSEMModel</p></a></li>
<li><a href='#csem'><p>Composite-based SEM</p></a></li>
<li><a href='#csem_arguments'><p>cSEMArguments</p></a></li>
<li><a href='#csem_model'><p>cSEMModel</p></a></li>
<li><a href='#csem_results'><p>cSEMResults</p></a></li>
<li><a href='#csem_summary'><p>cSEMSummarize</p></a></li>
<li><a href='#csem_test'><p>cSEMTest</p></a></li>
<li><a href='#dgp_2ndorder_cf_of_c'><p>Data: Second order common factor of composites</p></a></li>
<li><a href='#distance_measures'><p>Calculate difference between S and Sigma_hat</p></a></li>
<li><a href='#doIPMA'><p>Do an importance-performance matrix analysis</p></a></li>
<li><a href='#doNonlinearEffectsAnalysis'><p>Do a nonlinear effects analysis</p></a></li>
<li><a href='#doRedundancyAnalysis'><p>Do a redundancy analysis</p></a></li>
<li><a href='#estimatePath'><p>Internal: Estimate the structural coefficients</p></a></li>
<li><a href='#exportToExcel'><p>Export to Excel (.xlsx)</p></a></li>
<li><a href='#fit'><p>Model-implied indicator or construct variance-covariance matrix</p></a></li>
<li><a href='#fit_measures'><p>Model fit measures</p></a></li>
<li><a href='#foreman'><p>Internal: Composite-based SEM</p></a></li>
<li><a href='#getConstructScores'><p>Get construct scores</p></a></li>
<li><a href='#getParameterNames'><p>Internal: Parameter names</p></a></li>
<li><a href='#getRelevantParameters'><p>Internal: Extract relevant parameters from several cSEMResults_multi</p></a></li>
<li><a href='#getValuesFloodlight'><p>Internal: Helper for doNonlinearEffectsAnalysis()</p></a></li>
<li><a href='#handleArgs'><p>Internal: Handle arguments</p></a></li>
<li><a href='#infer'><p>Inference</p></a></li>
<li><a href='#inference_helper'><p>Internal: Helper for infer()</p></a></li>
<li><a href='#ITFlex'><p>Data: ITFlex</p></a></li>
<li><a href='#LancelotMiltgenetal2016'><p>Data: LancelotMiltgenetal2016</p></a></li>
<li><a href='#moments'><p>Internal: Calculate consistent moments of a nonlinear model</p></a></li>
<li><a href='#nonlinear_estimation_utilities'><p>Internal: Utility functions for the estimation of nonlinear models</p></a></li>
<li><a href='#parseModel'><p>Parse lavaan model</p></a></li>
<li><a href='#plot.cSEMIPMA'><p><code>cSEMIPMA</code> method for <code>plot()</code></p></a></li>
<li><a href='#plot.cSEMNonlinearEffects'><p><code>cSEMNonlinearEffects</code> method for <code>plot()</code></p></a></li>
<li><a href='#plot.cSEMPredict'><p><code>cSEMPredict</code> method for <code>plot()</code></p></a></li>
<li><a href='#PoliticalDemocracy'><p>Data: political democracy</p></a></li>
<li><a href='#predict'><p>Predict indicator scores</p></a></li>
<li><a href='#print.cSEMAssess'><p><code>cSEMAssess</code> method for <code>print()</code></p></a></li>
<li><a href='#print.cSEMNonlinearEffects'><p><code>cSEMNonlinearEffectsAnalysis</code> method for <code>print()</code></p></a></li>
<li><a href='#print.cSEMPlotPredict'><p><code>cSEMPlotPredict</code> method for <code>print()</code></p></a></li>
<li><a href='#print.cSEMPredict'><p><code>cSEMPredict</code> method for <code>print()</code></p></a></li>
<li><a href='#print.cSEMResults'><p><code>cSEMResults</code> method for <code>print()</code></p></a></li>
<li><a href='#print.cSEMSummarize'><p><code>cSEMSummarize</code> method for <code>print()</code></p></a></li>
<li><a href='#print.cSEMTestCVPAT'><p><code>cSEMTestCVPAT</code> method for <code>print()</code></p></a></li>
<li><a href='#print.cSEMTestHausman'><p><code>cSEMTestHausman</code> method for <code>print()</code></p></a></li>
<li><a href='#print.cSEMTestMGD'><p><code>cSEMTestMGD</code> method for <code>print()</code></p></a></li>
<li><a href='#print.cSEMTestMICOM'><p><code>cSEMTestMICOM</code> method for <code>print()</code></p></a></li>
<li><a href='#print.cSEMTestOMF'><p><code>cSEMTestOMF</code> method for <code>print()</code></p></a></li>
<li><a href='#print.cSEMVerify'><p><code>cSEMVerify</code> method for <code>print()</code></p></a></li>
<li><a href='#processData'><p>Internal: Process data</p></a></li>
<li><a href='#reliability'><p>Reliability</p></a></li>
<li><a href='#resamplecSEMResults'><p>Resample cSEMResults</p></a></li>
<li><a href='#resampleData'><p>Resample data</p></a></li>
<li><a href='#Russett'><p>Data: Russett</p></a></li>
<li><a href='#satisfaction'><p>Data: satisfaction</p></a></li>
<li><a href='#satisfaction_gender'><p>Data: satisfaction including gender</p></a></li>
<li><a href='#scaleWeights'><p>Internal: Scale weights</p></a></li>
<li><a href='#setDominantIndicator'><p>Internal: Set the dominant indicator</p></a></li>
<li><a href='#setStartingValues'><p>Internal: Set starting values</p></a></li>
<li><a href='#Sigma_Summers_composites'><p>Data: Summers</p></a></li>
<li><a href='#SQ'><p>Data: SQ</p></a></li>
<li><a href='#structureTestMGDDecisions'><p>Internal: get structured cSEMTestMGD results</p></a></li>
<li><a href='#summarize'><p>Summarize model</p></a></li>
<li><a href='#Switching'><p>Data: Switching</p></a></li>
<li><a href='#testCVPAT'><p>Perform a Cross-Validated Predictive Ability Test (CVPAT)</p></a></li>
<li><a href='#testHausman'><p>Regression-based Hausman test</p></a></li>
<li><a href='#testMGD'><p>Tests for multi-group comparisons</p></a></li>
<li><a href='#testMICOM'><p>Test measurement invariance of composites</p></a></li>
<li><a href='#testOMF'><p>Test for overall model fit</p></a></li>
<li><a href='#threecommonfactors'><p>Data: threecommonfactors</p></a></li>
<li><a href='#verify'><p>Verify admissibility</p></a></li>
<li><a href='#Yooetal2000'><p>Data: Yooetal2000</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Composite-Based Structural Equation Modeling</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-11-24</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Florian Schuberth &lt;f.schuberth@utwente.nl&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimate, assess, test, and study linear, nonlinear, hierarchical 
  and multigroup structural equation models using composite-based approaches 
  and procedures, including estimation techniques such as partial least squares 
  path modeling (PLS-PM) and its derivatives (PLSc, ordPLSc, robustPLSc), 
  generalized structured component analysis (GSCA), generalized structured 
  component analysis with uniqueness terms (GSCAm), generalized canonical 
  correlation analysis (GCCA), principal component analysis (PCA), 
  factor score regression (FSR) using sum score, regression or 
  bartlett scores (including bias correction using Croon’s approach), 
  as well as several tests and typical postestimation procedures 
  (e.g., verify admissibility of the estimates, assess the model fit, 
  test the model fit etc.).</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/M-E-Rademaker/cSEM/issues/">https://github.com/M-E-Rademaker/cSEM/issues/</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/M-E-Rademaker/cSEM/">https://github.com/M-E-Rademaker/cSEM/</a>,
<a href="https://m-e-rademaker.github.io/cSEM/">https://m-e-rademaker.github.io/cSEM/</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>alabama, cli, crayon, expm (&ge; 0.999-5), future.apply, future,
lavaan, magrittr, MASS, Matrix, matrixcalc, matrixStats,
polycor, progressr, psych, purrr, Rdpack, rlang, stats,
symmoments, TruncatedNormal, utils, lifecycle</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack, lifecycle</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>dplyr, tidyr, knitr, nnls, prettydoc, plotly, rmarkdown,
rootSolve, listviewer, testthat, ggplot2, openxlsx, graphics</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-24 16:22:23 UTC; SchuberthF</td>
</tr>
<tr>
<td>Author:</td>
<td>Manuel E. Rademaker
    <a href="https://orcid.org/0000-0002-8902-3561"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Florian Schuberth <a href="https://orcid.org/0000-0002-2110-9086"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Tamara Schamberger
    <a href="https://orcid.org/0000-0002-7845-784X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Michael Klesel <a href="https://orcid.org/0000-0002-2884-1819"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Theo K. Dijkstra [ctb],
  Jörg Henseler <a href="https://orcid.org/0000-0002-9736-3048"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-11-24 17:50:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='cSEM-package'>cSEM: A package for composite-based structural equation modeling</h2><span id='topic+cSEM'></span><span id='topic+cSEM-package'></span>

<h3>Description</h3>

<p>Estimate, analyze, test, and study linear, nonlinear, hierarchical and
multigroup structural equation models using composite-based approaches and procedures including estimation
techniques such as partial least squares path modeling (PLS) and its derivatives
(PLSc, ordPLSc, robustPLSc), generalized structured component analysis (GSCA),
generalized structured component analysis with uniqueness terms (GSCAm),
generalized canonical correlation analysis (GCCA) unit weights (sum score) and
fixed weights, as well as several tests and typical postestimation
procedures (e.g., assess the model fit, compute direct, indirect and total effects).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Florian Schuberth <a href="mailto:f.schuberth@utwente.nl">f.schuberth@utwente.nl</a> (<a href="https://orcid.org/0000-0002-2110-9086">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Manuel E. Rademaker <a href="mailto:manuel-rademaker@outlook.de">manuel-rademaker@outlook.de</a> (<a href="https://orcid.org/0000-0002-8902-3561">ORCID</a>)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Tamara Schamberger <a href="mailto:tamara.schamberger@uni-wuerzburg.de">tamara.schamberger@uni-wuerzburg.de</a> (<a href="https://orcid.org/0000-0002-7845-784X">ORCID</a>) [contributor]
</p>
</li>
<li><p> Michael Klesel (<a href="https://orcid.org/0000-0002-2884-1819">ORCID</a>) [contributor]
</p>
</li>
<li><p> Theo K. Dijkstra [contributor]
</p>
</li>
<li><p> Jörg Henseler (<a href="https://orcid.org/0000-0002-9736-3048">ORCID</a>) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/M-E-Rademaker/cSEM/">https://github.com/M-E-Rademaker/cSEM/</a>
</p>
</li>
<li> <p><a href="https://m-e-rademaker.github.io/cSEM/">https://m-e-rademaker.github.io/cSEM/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/M-E-Rademaker/cSEM/issues/">https://github.com/M-E-Rademaker/cSEM/issues/</a>
</p>
</li></ul>


<hr>
<h2 id='adjustAlpha'>Internal: Multiple testing correction</h2><span id='topic+adjustAlpha'></span>

<h3>Description</h3>

<p>Adjust a given significance level <code>.alpha</code> to accommodate multiple testing.
The following corrections are implemented:
</p>

<dl>
<dt><code>none</code></dt><dd><p>(Default) No correction is done.</p>
</dd>
<dt><code>bonferroni</code></dt><dd><p>A Bonferroni correction is done, i.e., alpha is divided by the
number of comparisons <code>.nr_comparisons</code>.</p>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>adjustAlpha(
 .alpha                 = args_default()$.alpha,
 .approach_alpha_adjust = args_default()$.approach_alpha_adjust,
 .nr_comparisons        = args_default()$.nr_comparisons
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjustAlpha_+3A_.alpha">.alpha</code></td>
<td>
<p>An integer or a numeric vector of significance levels.
Defaults to <code>0.05</code>.</p>
</td></tr>
<tr><td><code id="adjustAlpha_+3A_.approach_alpha_adjust">.approach_alpha_adjust</code></td>
<td>
<p>Character string. Approach used to adjust the
significance level to accommodate multiple testing.
One of &quot;<em>none</em>&quot; or &quot;<em>bonferroni</em>&quot;. Defaults to &quot;<em>none</em>&quot;.</p>
</td></tr>
<tr><td><code id="adjustAlpha_+3A_.nr_comparisons">.nr_comparisons</code></td>
<td>
<p>Integer. The number of comparisons. Defaults to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of (possibly adjusted) significance levels.
</p>

<hr>
<h2 id='Anime'>Data: Anime</h2><span id='topic+Anime'></span>

<h3>Description</h3>

<p>A data frame with 183 observations and 13 variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Anime
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 183 rows and 13 columns.
</p>


<h3>Details</h3>

<p>The data set for the example on <a href="https://github.com/ISS-Analytics/pls-predict/">github.com/ISS-Analytics/pls-predict/</a>
with irrelevant variables removed.
</p>


<h3>Source</h3>

<p>Original source: <a href="https://github.com/ISS-Analytics/pls-predict/">github.com/ISS-Analytics/pls-predict/</a>
</p>

<hr>
<h2 id='args_assess_dotdotdot'>Complete list of assess()'s ... arguments</h2><span id='topic+args_assess_dotdotdot'></span>

<h3>Description</h3>

<p>A complete alphabetical list of all possible arguments accepted by <code>assess()</code>'s <code>...</code>
(dotdotdot) argument.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="args_assess_dotdotdot_+3A_.absolute">.absolute</code></td>
<td>
<p>Logical. Should the absolute HTMT values be returned?
Defaults to <code>TRUE</code> .</p>
</td></tr>
<tr><td><code id="args_assess_dotdotdot_+3A_.alpha">.alpha</code></td>
<td>
<p>An integer or a numeric vector of significance levels.
Defaults to <code>0.05</code>.</p>
</td></tr>
<tr><td><code id="args_assess_dotdotdot_+3A_.ci">.ci</code></td>
<td>
<p>A vector of character strings naming the confidence interval to compute.
For possible choices see <code><a href="#topic+infer">infer()</a></code>.</p>
</td></tr>
<tr><td><code id="args_assess_dotdotdot_+3A_.closed_form_ci">.closed_form_ci</code></td>
<td>
<p>Logical. Should a closed-form confidence interval be computed?
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="args_assess_dotdotdot_+3A_.handle_inadmissibles">.handle_inadmissibles</code></td>
<td>
<p>Character string. How should inadmissible results
be treated? One of &quot;<em>drop</em>&quot;, &quot;<em>ignore</em>&quot;, or &quot;<em>replace</em>&quot;. If &quot;<em>drop</em>&quot;, all
replications/resamples yielding an inadmissible result will be dropped
(i.e. the number of results returned will potentially be less than <code>.R</code>).
For &quot;<em>ignore</em>&quot; all results are returned even if all or some of the replications
yielded inadmissible results (i.e. number of results returned is equal to <code>.R</code>).
For &quot;<em>replace</em>&quot; resampling continues until there are exactly <code>.R</code> admissible solutions.
Depending on the frequency of inadmissible solutions this may significantly increase
computing time. Defaults to &quot;<em>drop</em>&quot;.</p>
</td></tr>
<tr><td><code id="args_assess_dotdotdot_+3A_.inference">.inference</code></td>
<td>
<p>Logical. Should critical values be computed? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="args_assess_dotdotdot_+3A_.null_model">.null_model</code></td>
<td>
<p>Logical. Should the degrees of freedom for the null model
be computed? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="args_assess_dotdotdot_+3A_.r">.R</code></td>
<td>
<p>Integer. The number of bootstrap replications. Defaults to <code>499</code>.</p>
</td></tr>
<tr><td><code id="args_assess_dotdotdot_+3A_.saturated">.saturated</code></td>
<td>
<p>Logical. Should a saturated structural model be used?
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="args_assess_dotdotdot_+3A_.seed">.seed</code></td>
<td>
<p>Integer or <code>NULL</code>. The random seed to use. Defaults to <code>NULL</code> in which
case an arbitrary seed is chosen. Note that the scope of the seed is limited
to the body of the function it is used in. Hence, the global seed will
not be altered!</p>
</td></tr>
<tr><td><code id="args_assess_dotdotdot_+3A_.type_gfi">.type_gfi</code></td>
<td>
<p>Character string. Which fitting function should the GFI be based
on? One of <em>&quot;ML&quot;</em> for the maximum likelihood fitting function, <em>&quot;GLS&quot;</em> for
the generalized least squares fitting function or <em>&quot;ULS&quot;</em> for the
unweighted least squares fitting function (same as the squared Euclidean distance).
Defaults to <em>&quot;ML&quot;</em>.</p>
</td></tr>
<tr><td><code id="args_assess_dotdotdot_+3A_.type_vcv">.type_vcv</code></td>
<td>
<p>Character string. Which model-implied correlation
matrix should be calculated?
One of &quot;<em>indicator</em>&quot; or &quot;<em>construct</em>&quot;. Defaults to &quot;<em>indicator</em>&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Most arguments supplied to the <code>...</code> argument of <code>assess()</code> are only
accepted by a subset of the functions called by <code>assess()</code>. The following
list shows which argument is passed to which function:
</p>

<dl>
<dt>.absolute</dt><dd><p>Accepted by/Passed down to: <code><a href="#topic+calculateHTMT">calculateHTMT()</a></code></p>
</dd>
<dt>.alpha</dt><dd><p>Accepted by/Passed down to: <code><a href="#topic+calculateRhoT">calculateRhoT()</a></code>, <code><a href="#topic+calculateHTMT">calculateHTMT()</a></code>, <code><a href="#topic+calculateCN">calculateCN()</a></code></p>
</dd>
<dt>.ci</dt><dd><p>Accepted by/Passed down to: <code><a href="#topic+calculateHTMT">calculateHTMT()</a></code></p>
</dd>
<dt>.closed_form_ci</dt><dd><p>Accepted by/Passed down to: <code><a href="#topic+calculateRhoT">calculateRhoT()</a></code></p>
</dd>
<dt>.handle_inadmissibles</dt><dd><p>Accepted by/Passed down to: <code><a href="#topic+calculateHTMT">calculateHTMT()</a></code></p>
</dd>
<dt>.inference</dt><dd><p>Accepted by/Passed down to: <a href="#topic+calculateHTMT">calculateHTMT</a></p>
</dd>
<dt>.null_model</dt><dd><p>Accepted by/Passed down to: <code><a href="#topic+calculateDf">calculateDf()</a></code></p>
</dd>
<dt>.R</dt><dd><p>Accepted by/Passed down to: <code><a href="#topic+calculateHTMT">calculateHTMT()</a></code></p>
</dd>
<dt>.saturated</dt><dd><p>Accepted by/Passed down to: <code><a href="#topic+calculateSRMR">calculateSRMR()</a></code>,
<code><a href="#topic+calculateDG">calculateDG()</a></code>, <code><a href="#topic+calculateDL">calculateDL()</a></code>, <code><a href="#topic+calculateDML">calculateDML()</a></code>and subsequently <code><a href="#topic+fit">fit()</a></code>.</p>
</dd>
<dt>.seed</dt><dd><p>Accepted by/Passed down to: <code><a href="#topic+calculateHTMT">calculateHTMT()</a></code></p>
</dd>
<dt>.type_gfi</dt><dd><p>Accepted by/Passed down to: <code><a href="#topic+calculateGFI">calculateGFI()</a></code></p>
</dd>
<dt>.type_vcv</dt><dd><p>Accepted by/Passed down to: <code><a href="#topic+calculateSRMR">calculateSRMR()</a></code>,
<code><a href="#topic+calculateDG">calculateDG()</a></code>, <code><a href="#topic+calculateDL">calculateDL()</a></code>, <code><a href="#topic+calculateDML">calculateDML()</a></code> and subsequently <code><a href="#topic+fit">fit()</a></code>.</p>
</dd>
</dl>


<hr>
<h2 id='args_default'>Show argument defaults or candidates</h2><span id='topic+args_default'></span>

<h3>Description</h3>

<p>Show all arguments used by package functions including default or candidate
values. For argument descriptions see: <a href="#topic+csem_arguments">csem_arguments</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>args_default(.choices = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="args_default_+3A_.choices">.choices</code></td>
<td>
<p>Logical. Should candidate values for the arguments be returned?
Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default <code>args_default()</code>returns a list of default values by argument name.
If the list of accepted candidate values is required instead, use <code>.choices = TRUE</code>.
</p>


<h3>Value</h3>

<p>A named list of argument names and defaults or accepted candidates.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+handleArgs">handleArgs()</a></code>, <a href="#topic+csem_arguments">csem_arguments</a>, <code><a href="#topic+csem">csem()</a></code>, <code><a href="#topic+foreman">foreman()</a></code>
</p>

<hr>
<h2 id='assess'>Assess model</h2><span id='topic+assess'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#maturing"><img src="../help/figures/lifecycle-maturing.svg" alt='[Maturing]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assess(
  .object              = NULL, 
  .quality_criterion   = c("all", "aic", "aicc", "aicu", "bic", "fpe", "gm", "hq",
                           "hqc", "mallows_cp", "ave",
                           "rho_C", "rho_C_mm", "rho_C_weighted", 
                           "rho_C_weighted_mm", "dg", "dl", "dml", "df",
                           "effects", "f2", "fl_criterion", "chi_square", "chi_square_df",
                           "cfi", "cn", "gfi", "ifi", "nfi", "nnfi", 
                           "reliability",
                           "rmsea", "rms_theta", "srmr",
                           "gof", "htmt", "htmt2", "r2", "r2_adj",
                           "rho_T", "rho_T_weighted", "vif", 
                           "vifmodeB"),
  .only_common_factors = TRUE, 
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assess_+3A_.object">.object</code></td>
<td>
<p>An R object of class <a href="#topic+cSEMResults">cSEMResults</a> resulting from a call to <code><a href="#topic+csem">csem()</a></code>.</p>
</td></tr>
<tr><td><code id="assess_+3A_.quality_criterion">.quality_criterion</code></td>
<td>
<p>Character string. A single character string or a
vector of character strings naming the quality criterion to compute. See
the Details section for a list of possible candidates.
Defaults to &quot;<em>all</em>&quot; in which case all possible quality criteria are computed.</p>
</td></tr>
<tr><td><code id="assess_+3A_.only_common_factors">.only_common_factors</code></td>
<td>
<p>Logical. Should only concepts modeled as common
factors be included when calculating one of the following quality criteria:
AVE, the Fornell-Larcker criterion, HTMT, and all reliability estimates.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="assess_+3A_...">...</code></td>
<td>
<p>Further arguments passed to functions called by <code><a href="#topic+assess">assess()</a></code>.
See <a href="#topic+args_assess_dotdotdot">args_assess_dotdotdot</a> for a complete list of available arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Assess a model using common quality criteria.
See the <a href="https://m-e-rademaker.github.io/cSEM/articles/Using-assess.html">Postestimation: Assessing a model</a>
article on the
<a href="https://m-e-rademaker.github.io/cSEM/index.html">cSEM website</a> for details.
</p>
<p>The function is essentially a wrapper around a number of internal functions
that perform an &quot;assessment task&quot; (called a <strong>quality criterion</strong> in <span class="pkg">cSEM</span>
parlance) like computing reliability estimates,
the effect size (Cohen's f^2), the heterotrait-monotrait ratio of correlations (HTMT) etc.
</p>
<p>By default every possible quality criterion is calculated (<code>.quality_criterion = "all"</code>).
If only a subset of quality criteria are needed a single character string
or a vector of character strings naming the criteria to be computed may be
supplied to <code><a href="#topic+assess">assess()</a></code> via the <code>.quality_criterion</code> argument. Currently, the
following quality criteria are implemented (in alphabetical order):
</p>

<dl>
<dt>Average variance extracted (AVE); &quot;ave&quot;</dt><dd><p>An estimate of the
amount of variation in the indicators that is due to the underlying latent variable.
Practically, it is calculated as the ratio of the (indicator) true score variances
(i.e., the sum of the squared loadings)
relative to the sum of the total indicator variances. The AVE is inherently
tied to the common factor model. It is therefore unclear how to meaningfully
interpret AVE results for constructs modeled as composites.
It is possible to report the AVE for constructs modeled as composites by setting
<code>.only_common_factors = FALSE</code>, however, result should be interpreted with caution
as they may not have a conceptual meaning. Calculation is done
by <code><a href="#topic+calculateAVE">calculateAVE()</a></code>.</p>
</dd>
<dt>Congeneric reliability; &quot;rho_C&quot;, &quot;rho_C_mm&quot;, &quot;rho_C_weighted&quot;, &quot;rho_C_weighted_mm&quot;</dt><dd>
<p>An estimate of the reliability assuming a congeneric measurement model (i.e., loadings are
allowed to differ) and a test score (proxy) based on unit weights.
There are four different versions implemented. See the
<a href="https://m-e-rademaker.github.io/cSEM/articles/Using-assess.html#methods">Methods and Formulae</a> section
of the <a href="https://m-e-rademaker.github.io/cSEM/articles/Using-assess.html">Postestimation: Assessing a model</a>
article on the
<a href="https://m-e-rademaker.github.io/cSEM/index.html">cSEM website</a> for details.
Alternative but synonymous names for <code>"rho_C"</code> are:
composite reliability, construct reliability, reliability coefficient,
Joereskog's rho, coefficient omega, or Dillon-Goldstein's rho.
For <code>"rho_C_weighted"</code>: (Dijkstra-Henselers) rhoA. <code>rho_C_mm</code> and <code>rho_C_weighted_mm</code>
have no corresponding names. The former uses unit weights scaled by (w'Sw)^(-1/2) and
the latter weights scaled by (w'Sigma_hat w)^(-1/2) where Sigma_hat is
the model-implied indicator correlation matrix.
The Congeneric reliability is inherently
tied to the common factor model. It is therefore unclear how to meaningfully
interpret congeneric reliability estimates for constructs modeled as composites.
It is possible to report the congeneric reliability for constructs modeled as
composites by setting <code>.only_common_factors = FALSE</code>, however, result should be
interpreted with caution as they may not have a conceptual meaning.
Calculation is done by <code><a href="#topic+calculateRhoC">calculateRhoC()</a></code>.</p>
</dd>
<dt>Distance measures; &quot;dg&quot;, &quot;dl&quot;, &quot;dml&quot;</dt><dd><p>Measures of the distance
between the model-implied and the empirical indicator correlation matrix.
Currently, the geodesic distance (<code>"dg"</code>), the squared Euclidean distance
(<code>"dl"</code>) and the the maximum likelihood-based distance function are implemented
(<code>"dml"</code>). Calculation is done by <code><a href="#topic+calculateDL">calculateDL()</a></code>, <code><a href="#topic+calculateDG">calculateDG()</a></code>,
and <code><a href="#topic+calculateDML">calculateDML()</a></code>.</p>
</dd>
<dt>Degrees of freedom, &quot;df&quot;</dt><dd>
<p>Returns the degrees of freedom. Calculation is done by <code><a href="#topic+calculateDf">calculateDf()</a></code>.
</p>
</dd>
<dt>Effects; &quot;effects&quot;</dt><dd><p>Total and indirect effect estimates. Additionally,
the variance accounted for (VAF) is computed. The VAF is defined as the ratio of a variables
indirect effect to its total effect. Calculation is done
by <code><a href="#topic+calculateEffects">calculateEffects()</a></code>.</p>
</dd>
<dt>Effect size; &quot;f2&quot;</dt><dd><p>An index of the effect size of an independent
variable in a structural regression equation. This measure is commonly
known as Cohen's f^2. The effect size of the k'th
independent variable in this case
is defined as the ratio (R2_included - R2_excluded)/(1 - R2_included), where
R2_included and R2_excluded are the R squares of the
original structural model regression equation (R2_included) and the
alternative specification with the k'th variable dropped (R2_excluded).
Calculation is done by <code><a href="#topic+calculatef2">calculatef2()</a></code>.</p>
</dd>
<dt>Fit indices; &quot;chi_square&quot;, &quot;chi_square_df&quot;, &quot;cfi&quot;, &quot;cn&quot;, &quot;gfi&quot;, &quot;ifi&quot;, &quot;nfi&quot;,
&quot;nnfi&quot;,  &quot;rmsea&quot;, &quot;rms_theta&quot;, &quot;srmr&quot;</dt><dd>
<p>Several absolute and incremental fit indices. Note that their suitability
for models containing constructs modeled as composites is still an
open research question. Also note that fit indices are not tests in a
hypothesis testing sense and
decisions based on common one-size-fits-all cut-offs proposed in the literature
suffer from serious statistical drawbacks. Calculation is done by <code><a href="#topic+calculateChiSquare">calculateChiSquare()</a></code>,
<code><a href="#topic+calculateChiSquareDf">calculateChiSquareDf()</a></code>, <code><a href="#topic+calculateCFI">calculateCFI()</a></code>,
<code><a href="#topic+calculateGFI">calculateGFI()</a></code>, <code><a href="#topic+calculateIFI">calculateIFI()</a></code>, <code><a href="#topic+calculateNFI">calculateNFI()</a></code>, <code><a href="#topic+calculateNNFI">calculateNNFI()</a></code>,
<code><a href="#topic+calculateRMSEA">calculateRMSEA()</a></code>, <code><a href="#topic+calculateRMSTheta">calculateRMSTheta()</a></code> and <code><a href="#topic+calculateSRMR">calculateSRMR()</a></code>.</p>
</dd>
<dt>Fornell-Larcker criterion; &quot;fl_criterion&quot;</dt><dd><p>A rule suggested by Fornell and Larcker (1981)
to assess discriminant validity. The Fornell-Larcker
criterion is a decision rule based on a comparison between the squared
construct correlations and the average variance extracted. FL returns
a matrix with the squared construct correlations on the off-diagonal and
the AVE's on the main diagonal. Calculation is done by <code>calculateFLCriterion()</code>.</p>
</dd>
<dt>Goodness of Fit (GoF); &quot;gof&quot;</dt><dd><p>The GoF is defined as the square root
of the mean of the R squares of the structural model times the mean
of the variances in the indicators that are explained by their
related constructs (i.e., the average over all lambda^2_k).
For the latter, only constructs modeled as common factors are considered
as they explain their indicator variance in contrast to a composite where
indicators actually build the construct.
Note that, contrary to what the name suggests, the GoF is <strong>not</strong> a
measure of model fit in a Chi-square fit test sense. Calculation is done
by <code><a href="#topic+calculateGoF">calculateGoF()</a></code>.</p>
</dd>
<dt>Heterotrait-monotrait ratio of correlations (HTMT); &quot;htmt&quot;</dt><dd>
<p>An estimate of the correlation between latent variables assuming tau equivalent
measurement models. The HTMT is used
to assess convergent and/or discriminant validity of a construct.
The HTMT is inherently tied to the common factor model. If the model contains
less than two constructs modeled as common factors and
<code>.only_common_factors = TRUE</code>, <code>NA</code> is returned.
It is possible to report the HTMT for constructs modeled as
composites by setting <code>.only_common_factors = FALSE</code>, however, result should be
interpreted with caution as they may not have a conceptual meaning.
Calculation is done by <code><a href="#topic+calculateHTMT">calculateHTMT()</a></code>.</p>
</dd>
<dt>HTMT2; &quot;htmt2&quot;</dt><dd>
<p>An estimate of the correlation between latent variables assuming congeneric
measurement models. The HTMT2 is used
to assess convergent and/or discriminant validity of a construct.
The HTMT is inherently tied to the common factor model. If the model contains
less than two constructs modeled as common factors and
<code>.only_common_factors = TRUE</code>, <code>NA</code> is returned.
It is possible to report the HTMT for constructs modeled as
composites by setting <code>.only_common_factors = FALSE</code>, however, result should be
interpreted with caution as they may not have a conceptual meaning.
Calculation is done by <code><a href="#topic+calculateHTMT">calculateHTMT()</a></code>.</p>
</dd>
<dt>Model selection criteria: &quot;aic&quot;, &quot;aicc&quot;, &quot;aicu&quot;, &quot;bic&quot;, &quot;fpe&quot;, &quot;gm&quot;,
&quot;hq&quot;, &quot;hqc&quot;, &quot;mallows_cp&quot;</dt><dd>
<p>Several model selection criteria as suggested by Sharma et al. (2019)
in the context of PLS. See: <code><a href="#topic+calculateModelSelectionCriteria">calculateModelSelectionCriteria()</a></code> for details.</p>
</dd>
<dt>Reliability: &quot;reliability&quot;</dt><dd>
<p>As described in the <a href="https://m-e-rademaker.github.io/cSEM/articles/Using-assess.html#methods">Methods and Formulae</a>
section of the <a href="https://m-e-rademaker.github.io/cSEM/articles/Using-assess.html">Postestimation: Assessing a model</a>
article on the <a href="https://m-e-rademaker.github.io/cSEM/index.html">cSEM website</a>
there are many different estimators for the (internal consistency) reliability.
Choosing <code>.quality_criterion = "reliability"</code> computes the three most common
measures, namely: &quot;Cronbachs alpha&quot; (identical to &quot;rho_T&quot;), &quot;Jöreskogs rho&quot; (identical to &quot;rho_C_mm&quot;),
and &quot;Dijkstra-Henselers rho A&quot; (identical to &quot;rho_C_weighted_mm&quot;).
Reliability is inherently
tied to the common factor model. It is therefore unclear how to meaningfully
interpret reliability estimates for constructs modeled as composites.
It is possible to report the three common reliability estimates for constructs modeled as
composites by setting <code>.only_common_factors = FALSE</code>, however, result should be
interpreted with caution as they may not have a conceptual meaning.
</p>
</dd>
<dt>R square and R square adjusted; &quot;r2&quot;, &quot;r2_adj&quot;</dt><dd><p>The R square and the adjusted
R square for each structural regression equation.
Calculated when running <code><a href="#topic+csem">csem()</a></code>.</p>
</dd>
<dt>Tau-equivalent reliability; &quot;rho_T&quot;</dt><dd><p>An estimate of the
reliability assuming a tau-equivalent measurement model (i.e. a measurement
model with equal loadings) and a test score (proxy) based on unit weights.
Tau-equivalent reliability is the preferred name for reliability estimates
that assume a tau-equivalent measurement model such as Cronbach's alpha.
The tau-equivalent
reliability (Cronbach's alpha) is inherently
tied to the common factor model. It is therefore unclear how to meaningfully
interpret tau-equivalent
reliability estimates for constructs modeled as composites.
It is possible to report tau-equivalent
reliability estimates for constructs modeled as
composites by setting <code>.only_common_factors = FALSE</code>, however, result should be
interpreted with caution as they may not have a conceptual meaning.
Calculation is done by <code><a href="#topic+calculateRhoT">calculateRhoT()</a></code>.</p>
</dd>
<dt>Variance inflation factors (VIF); &quot;vif&quot;</dt><dd><p>An index for the amount of
(multi-)collinearity between independent variables of a regression equation. Computed
for each structural equation. Practically, VIF_k is defined
as the ratio of 1 over (1 - R2_k) where R2_k is the R squared from a regression
of the k'th independent variable on all remaining independent variables.
Calculated when running <code><a href="#topic+csem">csem()</a></code>.</p>
</dd>
<dt>Variance inflation factors for PLS-PM mode B (VIF-ModeB); &quot;vifmodeB&quot;</dt><dd><p>An index for
the amount of (multi-)collinearity between independent variables (indicators) in
mode B regression equations. Computed only if <code>.object</code> was obtained using
<code>.weight_approach = "PLS-PM"</code> and at least one mode was mode B.
Practically, VIF-ModeB_k is defined as the ratio of 1 over (1 - R2_k) where
R2_k is the R squared from a regression of the k'th indicator of block j on
all remaining indicators of the same block.
Calculation is done by <code><a href="#topic+calculateVIFModeB">calculateVIFModeB()</a></code>.</p>
</dd>
</dl>

<p>For details on the most important quality criteria see the <a href="https://m-e-rademaker.github.io/cSEM/articles/Using-assess.html#methods">Methods and Formulae</a> section
of the <a href="https://m-e-rademaker.github.io/cSEM/articles/Using-assess.html">Postestimation: Assessing a model</a>
article on the on the
<a href="https://m-e-rademaker.github.io/cSEM/index.html">cSEM website</a>.
</p>
<p>Some of the quality criteria are inherently tied to the classical common
factor model and therefore only meaningfully interpreted within a common
factor model (see the
<a href="https://m-e-rademaker.github.io/cSEM/articles/Using-assess.html">Postestimation: Assessing a model</a>
article for details).
It is possible to force computation of all quality criteria for constructs
modeled as composites by setting <code>.only_common_factors = FALSE</code>, however,
we explicitly warn to interpret quality criteria in analogy to the common factor
model in this case, as the interpretation often does not carry over to composite models.
</p>


<h4>Resampling</h4>

<p>To resample a given quality criterion supply the name of the function
that calculates the desired quality criterion to <code><a href="#topic+csem">csem()</a></code>'s <code>.user_funs</code> argument.
See <code><a href="#topic+resamplecSEMResults">resamplecSEMResults()</a></code> for details.
</p>



<h3>Value</h3>

<p>A named list of quality criteria. Note that if only a single quality
criteria is computed the return value is still a list!
</p>


<h3>See Also</h3>

<p><code><a href="#topic+csem">csem()</a></code>, <code><a href="#topic+resamplecSEMResults">resamplecSEMResults()</a></code>, <code><a href="#topic+exportToExcel">exportToExcel()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># ===========================================================================
# Using the three common factors dataset
# ===========================================================================
model &lt;- "
# Structural model
eta2 ~ eta1
eta3 ~ eta1 + eta2

# Each concept is measured by 3 indicators, i.e., modeled as latent variable
eta1 =~ y11 + y12 + y13
eta2 =~ y21 + y22 + y23
eta3 =~ y31 + y32 + y33
"

res &lt;- csem(threecommonfactors, model)
a   &lt;- assess(res) # computes all quality criteria (.quality_criterion = "all")
a

## The return value is a named list. Type for example:
a$HTMT

# You may also just compute a subset of the quality criteria
assess(res, .quality_criterion = c("ave", "rho_C", "htmt"))

## Resampling ---------------------------------------------------------------
# To resample a given quality criterion use csem()'s .user_funs argument
# Note: The output of the quality criterion needs to be a vector or a matrix.
#       Matrices will be vectorized columnwise.
res &lt;- csem(threecommonfactors, model, 
            .resample_method = "bootstrap", 
            .R               = 40,
            .user_funs       = cSEM:::calculateSRMR
)

## Look at the resamples
res$Estimates$Estimates_resample$Estimates1$User_fun$Resampled[1:4, ]

## Use infer() to compute e.g., the 95% percentile confidence interval
res_infer &lt;- infer(res, .quantity = "CI_percentile")

## The results are saved under the name "User_fun"
res_infer$User_fun 

## Several quality criteria can be resampled simultaneously
res &lt;- csem(threecommonfactors, model, 
            .resample_method = "bootstrap",
            .R               = 40,
            .user_funs       = list(
              "SRMR" = cSEM:::calculateSRMR,
              "RMS_theta" = cSEM:::calculateRMSTheta
            ),
            .tolerance = 1e-04
)
res$Estimates$Estimates_resample$Estimates1$SRMR$Resampled[1:4, ]
res$Estimates$Estimates_resample$Estimates1$RMS_theta$Resampled[1:4]

</code></pre>

<hr>
<h2 id='Benitezetal2020'>Data: Benitezetal2020</h2><span id='topic+Benitezetal2020'></span>

<h3>Description</h3>

<p>A data frame containing 22 variables with 300 observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Benitezetal2020
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 300 rows and 22 columns.
</p>


<h3>Details</h3>

<p>The simulated data contains variables about the social executive and employee behavior.
Moreover, it contains variables about the social media capability and business performance.
The dataset was used as an illustrative example in Benitez et al. (2020).
</p>


<h3>Source</h3>

<p>The dataset is provided as supplementary material by Benitez et al. (2020).
</p>


<h3>References</h3>

<p>Benitez J, Henseler J, Castillo A, Schuberth F (2020).
&ldquo;How to perform and report an impactful analysis using partial least squares: Guidelines for confirmatory and explanatory IS research.&rdquo;
<em>Information &amp; Management</em>, <b>2</b>(57), 103168.
<a href="https://doi.org/10.1016/j.im.2019.05.003">doi:10.1016/j.im.2019.05.003</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#============================================================================
# Example is taken from Benitez et al. (2020)
#============================================================================
model_Benitez &lt;-"
# Reflective measurement models# Reflective measurement models
SEXB =~ SEXB1 + SEXB2 + SEXB3 +SEXB4
SEMB =~ SEMB1 + SEMB2 + SEMB3 + SEMB4

# Composite models
SMC &lt;~ SMC1 + SMC2 + SMC3 + SMC4
BPP &lt;~ BPP1 + BPP2 + BPP3 + BPP4 + BPP5

# Control variables
FS&lt;~ FirmSize
Ind &lt;~ Industry1 + Industry2 + Industry3

# Structural model
SMC ~ SEXB + SEMB 
BPP ~ SMC + Ind + FS
"

out &lt;- csem(.data = Benitezetal2020, .model = model_Benitez,
            .PLS_weight_scheme_inner = 'factorial',
            .tolerance = 1e-06)

</code></pre>

<hr>
<h2 id='BergamiBagozzi2000'>Data: BergamiBagozzi2000</h2><span id='topic+BergamiBagozzi2000'></span>

<h3>Description</h3>

<p>A data frame containing 22 variables with 305 observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BergamiBagozzi2000
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 305 rows and 22 columns.
</p>


<h3>Details</h3>

<p>The dataset contains 22 variables and originates
from a larger survey among South Korean employees conducted and
reported by Bergami and Bagozzi (2000). It is
also used in  Hwang and Takane (2004) and
Henseler (2021)
for demonstration purposes, see the corresponding tutorial.
</p>


<h3>Source</h3>

<p>Survey among South Korean employees conducted and
reported by Bergami and Bagozzi (2000).
</p>


<h3>References</h3>

<p>Bergami M, Bagozzi RP (2000).
&ldquo;Self-categorization, affective commitment and group self-esteem as distinct aspects of social identity in the organization.&rdquo;
<em>British Journal of Social Psychology</em>, <b>39</b>(4), 555&ndash;577.
<a href="https://doi.org/10.1348/014466600164633">doi:10.1348/014466600164633</a>.<br /><br /> Henseler J (2021).
<em>Composite-Based Structural Equation Modeling: Analyzing Latent and Emergent Variables</em>.
Guilford Press, New York.<br /><br /> Hwang H, Takane Y (2004).
&ldquo;Generalized Structured Component Analysis.&rdquo;
<em>Psychometrika</em>, <b>69</b>(1), 81&ndash;99.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#============================================================================
# Example is taken from Henseler (2021)
#============================================================================
model_Bergami_Bagozzi_Henseler="
# Measurement models
OrgPres =~ cei1 + cei2 + cei3 + cei4 + cei5 + cei6 + cei7 + cei8 
OrgIden =~ ma1 + ma2 + ma3 + ma4 + ma5 + ma6
AffLove =~ orgcmt1 + orgcmt2 + orgcmt3 + orgcmt7
AffJoy  =~ orgcmt5 + orgcmt8
Gender  &lt;~ gender

# Structural model 
OrgIden ~ OrgPres
AffLove ~ OrgPres + OrgIden + Gender 
AffJoy  ~ OrgPres + OrgIden + Gender 
"

out &lt;- csem(.data = BergamiBagozzi2000, 
            .model = model_Bergami_Bagozzi_Henseler,
            .PLS_weight_scheme_inner = 'factorial',
            .tolerance = 1e-06
)

#============================================================================
# Example is taken from Hwang et al. (2004)
#============================================================================ 

model_Bergami_Bagozzi_Hwang="
# Measurement models
OrgPres =~ cei1 + cei2 + cei3 + cei4 + cei5 + cei6 + cei7 + cei8 
OrgIden =~ ma1 + ma2 + ma3 + ma4 + ma5 + ma6
AffJoy =~ orgcmt1 + orgcmt2 + orgcmt3 + orgcmt7
AffLove  =~ orgcmt5 + orgcmt6 + orgcmt8

# Structural model 
OrgIden ~ OrgPres 
AffLove ~ OrgIden
AffJoy  ~ OrgIden"

out_Hwang &lt;- csem(.data = BergamiBagozzi2000, 
                 .model = model_Bergami_Bagozzi_Hwang,
                 .approach_weights = "GSCA",
                 .disattenuate = FALSE,
                 .id = "gender",
                 .tolerance = 1e-06) 


</code></pre>

<hr>
<h2 id='calculate2ndStage'>Internal: Second/Third stage of the two-stage approach for second order constructs</h2><span id='topic+calculate2ndStage'></span>

<h3>Description</h3>

<p>Performs the second and third stage for a model containing second order
constructs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate2ndStage(
 .csem_model          = args_default()$.csem_model,
 .first_stage_results = args_default()$.first_stage_results,
 .original_arguments  = args_default()$.original_arguments,
 .approach_2ndorder   = args_default()$.approach_2ndorder
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate2ndStage_+3A_.csem_model">.csem_model</code></td>
<td>
<p>A (possibly incomplete) <a href="#topic+cSEMModel">cSEMModel</a>-list.</p>
</td></tr>
<tr><td><code id="calculate2ndStage_+3A_.original_arguments">.original_arguments</code></td>
<td>
<p>The list of arguments used within <code><a href="#topic+csem">csem()</a></code>.</p>
</td></tr>
<tr><td><code id="calculate2ndStage_+3A_.approach_2ndorder">.approach_2ndorder</code></td>
<td>
<p>Character string. Approach used for models containing
second-order constructs. One of: &quot;<em>2stage</em>&quot;, or &quot;<em>mixed</em>&quot;. Defaults to &quot;<em>2stage</em>&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cSEMResults object.
</p>

<hr>
<h2 id='calculateAVE'>Average variance extracted (AVE)</h2><span id='topic+calculateAVE'></span>

<h3>Description</h3>

<p>Calculate the average variance extracted (AVE) as proposed by
Fornell and Larcker (1981). For details see the
<a href="https://m-e-rademaker.github.io/cSEM/articles/Using-assess.html#ave">cSEM website</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateAVE(
 .object              = NULL,
 .only_common_factors = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculateAVE_+3A_.object">.object</code></td>
<td>
<p>An R object of class <a href="#topic+cSEMResults">cSEMResults</a> resulting from a call to <code><a href="#topic+csem">csem()</a></code>.</p>
</td></tr>
<tr><td><code id="calculateAVE_+3A_.only_common_factors">.only_common_factors</code></td>
<td>
<p>Logical. Should only concepts modeled as common
factors be included when calculating one of the following quality criteria:
AVE, the Fornell-Larcker criterion, HTMT, and all reliability estimates.
Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The AVE is inherently tied to the common factor model. It is therefore
unclear how to meaningfully interpret the AVE in the context of a
composite model. It is possible, however, to force computation of the AVE for constructs
modeled as composites by setting <code>.only_common_factors = FALSE</code>.
</p>


<h3>Value</h3>

<p>A named vector of numeric values (the AVEs). If <code>.object</code> is a list
of <code>cSEMResults</code> objects, a list of AVEs is returned.
</p>


<h3>References</h3>

<p>Fornell C, Larcker DF (1981).
&ldquo;Evaluating structural equation models with unobservable variables and measurement error.&rdquo;
<em>Journal of Marketing Research</em>, <b>XVIII</b>, 39&ndash;50.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+assess">assess()</a></code>, <a href="#topic+cSEMResults">cSEMResults</a>
</p>

<hr>
<h2 id='calculateCompositeVCV'>Internal: Calculate composite variance-covariance matrix</h2><span id='topic+calculateCompositeVCV'></span>

<h3>Description</h3>

<p>Calculate the sample variance-covariance (VCV) matrix of the composites/proxies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateCompositeVCV(
 .S  = args_default()$.S,
 .W  = args_default()$.W
 )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculateCompositeVCV_+3A_.s">.S</code></td>
<td>
<p>The (K x K) empirical indicator correlation matrix.</p>
</td></tr>
<tr><td><code id="calculateCompositeVCV_+3A_.w">.W</code></td>
<td>
<p>A (J x K) matrix of weights.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A (J x J) composite VCV matrix.
</p>

<hr>
<h2 id='calculateConstructVCV'>Internal: Calculate construct variance-covariance matrix</h2><span id='topic+calculateConstructVCV'></span>

<h3>Description</h3>

<p>Calculate the variance-covariance matrix (VCV) of the constructs, i.e., correlations
that involve common factors/latent variables are diattenuated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateConstructVCV(
 .C          = args_default()$.C, 
 .Q          = args_default()$.Q
 )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculateConstructVCV_+3A_.c">.C</code></td>
<td>
<p>A (J x J) composite variance-covariance matrix.</p>
</td></tr>
<tr><td><code id="calculateConstructVCV_+3A_.q">.Q</code></td>
<td>
<p>A vector of composite-construct correlations with element names equal to
the names of the J construct names used in the measurement model. Note
Q^2 is also called the reliability coefficient.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The (J x J) construct VCV matrix. Disattenuated if requested.
</p>

<hr>
<h2 id='calculateCorrectionFactors'>Internal: Calculate PLSc correction factors</h2><span id='topic+calculateCorrectionFactors'></span>

<h3>Description</h3>

<p>Calculates the correction factor used by PLSc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateCorrectionFactors(
 .S               = args_default()$.S,
 .W               = args_default()$.W,
 .modes           = args_default()$.modes,
 .csem_model      = args_default()$.csem_model,
 .PLS_approach_cf = args_default()$.PLS_approach_cf
 )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculateCorrectionFactors_+3A_.s">.S</code></td>
<td>
<p>The (K x K) empirical indicator correlation matrix.</p>
</td></tr>
<tr><td><code id="calculateCorrectionFactors_+3A_.w">.W</code></td>
<td>
<p>A (J x K) matrix of weights.</p>
</td></tr>
<tr><td><code id="calculateCorrectionFactors_+3A_.modes">.modes</code></td>
<td>
<p>A vector giving the mode for each construct in the form <code>"name" = "mode"</code>.
Only used internally.</p>
</td></tr>
<tr><td><code id="calculateCorrectionFactors_+3A_.csem_model">.csem_model</code></td>
<td>
<p>A (possibly incomplete) <a href="#topic+cSEMModel">cSEMModel</a>-list.</p>
</td></tr>
<tr><td><code id="calculateCorrectionFactors_+3A_.pls_approach_cf">.PLS_approach_cf</code></td>
<td>
<p>Character string. Approach used to obtain the correction
factors for PLSc. One of: &quot;<em>dist_squared_euclid</em>&quot;, &quot;<em>dist_euclid_weighted</em>&quot;,
&quot;<em>fisher_transformed</em>&quot;, &quot;<em>mean_arithmetic</em>&quot;, &quot;<em>mean_geometric</em>&quot;, &quot;<em>mean_harmonic</em>&quot;,
&quot;<em>geo_of_harmonic</em>&quot;. Defaults to &quot;<em>dist_squared_euclid</em>&quot;.
Ignored if <code>.disattenuate = FALSE</code> or if <code>.approach_weights</code> is not PLS-PM.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, seven approaches are available:
</p>

<ul>
<li><p> &quot;dist_squared_euclid&quot; (default)
</p>
</li>
<li><p> &quot;dist_euclid_weighted&quot;
</p>
</li>
<li><p> &quot;fisher_transformed&quot;
</p>
</li>
<li><p> &quot;mean_geometric&quot;
</p>
</li>
<li><p> &quot;mean_harmonic&quot;
</p>
</li>
<li><p> &quot;mean_arithmetic&quot;
</p>
</li>
<li><p> &quot;geo_of_harmonic&quot; (not yet implemented)
</p>
</li></ul>

<p>See (Dijkstra 2013) for details.
</p>


<h3>Value</h3>

<p>A numeric vector of correction factors with element names equal
to the names of the J constructs used in the measurement model.
</p>


<h3>References</h3>

<p>Dijkstra TK (2013).
&ldquo;A Note on How to Make Partial Least Squares Consistent.&rdquo;
<em>Working Paper</em>.
<a href="https://doi.org/10.13140/RG.2.1.4547.5688">doi:10.13140/RG.2.1.4547.5688</a>.
</p>

<hr>
<h2 id='calculateDf'>Degrees of freedom</h2><span id='topic+calculateDf'></span>

<h3>Description</h3>

<p>Calculate the degrees of freedom for a given model from a <a href="#topic+cSEMResults">cSEMResults</a> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateDf(
  .object     = NULL,
  .null_model = FALSE,
  ...
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculateDf_+3A_.object">.object</code></td>
<td>
<p>An R object of class <a href="#topic+cSEMResults">cSEMResults</a> resulting from a call to <code><a href="#topic+csem">csem()</a></code>.</p>
</td></tr>
<tr><td><code id="calculateDf_+3A_.null_model">.null_model</code></td>
<td>
<p>Logical. Should the degrees of freedom for the null model
be computed? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="calculateDf_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Although, composite-based estimators always retrieve parameters of the
postulated models via the estimation of a composite model,
the computation of the degrees of freedom depends on the postulated model.
</p>
<p>See: <a href="https://m-e-rademaker.github.io/cSEM/articles/Using-assess.html">cSEM website</a>
for details on how the degrees of freedom are calculated.
</p>
<p>To compute the degrees of freedom of the null model use <code>.null_model = TRUE</code>.
The degrees of freedom of the null model are identical to the number of
non-redundant off-diagonal elements of the empirical indicator correlation matrix.
This implicitly assumes a null model with model-implied indicator correlation
matrix equal to the identity matrix.
</p>


<h3>Value</h3>

<p>A single numeric value.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+assess">assess()</a></code>, <a href="#topic+cSEMResults">cSEMResults</a>
</p>

<hr>
<h2 id='calculateDistance'>Internal: Matrix difference</h2><span id='topic+calculateDistance'></span>

<h3>Description</h3>

<p>Calculates the average of the differences between all possible pairs of
(symmetric) matrices in a list using a given distance measure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateDistance(
  .matrices = NULL, 
  .distance = args_default()$.distance
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculateDistance_+3A_.matrices">.matrices</code></td>
<td>
<p>A list of at least two matrices.</p>
</td></tr>
<tr><td><code id="calculateDistance_+3A_.distance">.distance</code></td>
<td>
<p>Character string. A distance measure. One of: &quot;<em>geodesic</em>&quot;
or &quot;<em>squared_euclidean</em>&quot;. Defaults to &quot;<em>geodesic</em>&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>.matrices</code> must be a list of at least two matrices. If more than two matrices
are supplied the arithmetic mean of the differences between all possible pairs of
(symmetric) matrices in a list is computed. Mathematically this is
n chose 2. Hence, supplying a large number of matrices will
become computationally challenging.
</p>
<p>Currently two distance measures are supported:
</p>

<dl>
<dt><code>geodesic</code></dt><dd><p>(Default) The geodesic distance.</p>
</dd>
<dt><code>squared_euclidean</code></dt><dd><p>The squared Euclidean distance</p>
</dd>
</dl>



<h3>Value</h3>

<p>A numeric vector of length one containing the (arithmetic) mean of
the differences between all possible pairs of matrices supplied via <code>.matrices</code>.
</p>

<hr>
<h2 id='calculateEffects'>Internal: Calculate direct, indirect and total effect</h2><span id='topic+calculateEffects'></span>

<h3>Description</h3>

<p>The direct effects are equal to the estimated coefficients. The total effect
equals (I-B)^-1Gamma. The indirect effect equals the difference between
the total effect and the indirect effect. In addition, the variance accounted
for (VAF) is calculated. The VAF is defined as the ratio of a variables
indirect effect to its total effect. Helper for generic functions <code><a href="#topic+summarize">summarize()</a></code> and <code><a href="#topic+assess">assess()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateEffects(
 .object       = NULL,
 .output_type  = c("data.frame", "matrix")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculateEffects_+3A_.object">.object</code></td>
<td>
<p>An R object of class <a href="#topic+cSEMResults">cSEMResults</a> resulting from a call to <code><a href="#topic+csem">csem()</a></code>.</p>
</td></tr>
<tr><td><code id="calculateEffects_+3A_.output_type">.output_type</code></td>
<td>
<p>Character string. The type of output to return. One of
&quot;<em>complete</em>&quot; or &quot;<em>structured</em>&quot;. See the Value section for details. Defaults to
&quot;<em>complete</em>&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix or a data frame of effects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+assess">assess()</a></code>, <code><a href="#topic+summarize">summarize()</a></code> <a href="#topic+cSEMResults">cSEMResults</a>
</p>

<hr>
<h2 id='calculatef2'>Calculate Cohens f^2</h2><span id='topic+calculatef2'></span>

<h3>Description</h3>

<p>Calculate the effect size for regression analysis (Cohen 1992)
known as Cohen's f^2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculatef2(.object = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculatef2_+3A_.object">.object</code></td>
<td>
<p>An R object of class <a href="#topic+cSEMResults">cSEMResults</a> resulting from a call to <code><a href="#topic+csem">csem()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with as many rows as there are structural equations. The
number of columns is equal to the total number of right-hand side variables
of these equations.
</p>


<h3>References</h3>

<p>Cohen J (1992).
&ldquo;A power primer.&rdquo;
<em>Psychological Bulletin</em>, <b>112</b>(1), 155&ndash;159.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+assess">assess()</a></code>, <a href="#topic+csem">csem</a>, <a href="#topic+cSEMResults">cSEMResults</a>
</p>

<hr>
<h2 id='calculateFLCriterion'>Fornell-Larcker criterion</h2><span id='topic+calculateFLCriterion'></span>

<h3>Description</h3>

<p>Computes the Fornell-Larcker matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateFLCriterion(
  .object              = NULL,
  .only_common_factors = TRUE,
  ...
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculateFLCriterion_+3A_.object">.object</code></td>
<td>
<p>An R object of class <a href="#topic+cSEMResults">cSEMResults</a> resulting from a call to <code><a href="#topic+csem">csem()</a></code>.</p>
</td></tr>
<tr><td><code id="calculateFLCriterion_+3A_.only_common_factors">.only_common_factors</code></td>
<td>
<p>Logical. Should only concepts modeled as common
factors be included when calculating one of the following quality criteria:
AVE, the Fornell-Larcker criterion, HTMT, and all reliability estimates.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="calculateFLCriterion_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Fornell-Larcker criterion (FL criterion) is a rule suggested by Fornell and Larcker (1981)
to assess discriminant validity. The Fornell-Larcker
criterion is a decision rule based on a comparison between the squared
construct correlations and the average variance extracted (AVE).
</p>
<p>The FL criterion is inherently tied to the common factor model. It is therefore
unclear how to meaningfully interpret the FL criterion in the context of a
model that contains constructs modeled as composites.
</p>


<h3>Value</h3>

<p>A matrix with the squared construct correlations on the off-diagonal and
the AVE's on the main diagonal.
</p>


<h3>References</h3>

<p>Fornell C, Larcker DF (1981).
&ldquo;Evaluating structural equation models with unobservable variables and measurement error.&rdquo;
<em>Journal of Marketing Research</em>, <b>XVIII</b>, 39&ndash;50.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+assess">assess()</a></code>, <a href="#topic+cSEMResults">cSEMResults</a>
</p>

<hr>
<h2 id='calculateFR'>Internal: ANOVA F-test statistic</h2><span id='topic+calculateFR'></span>

<h3>Description</h3>

<p>Calculate the ANOVA F-test statistic suggested by
Sarstedt et al. (2011) in the OTG testing procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateFR(.resample_sarstedt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculateFR_+3A_.resample_sarstedt">.resample_sarstedt</code></td>
<td>
<p>A matrix containing the parameter estimates that
could potentially be compared and an id column indicating the group adherence
of each row.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named scalar, the test statistic of the ANOVA F-test
</p>


<h3>References</h3>

<p>Sarstedt M, Henseler J, Ringle CM (2011).
&ldquo;Multigroup Analysis in Partial Least Squares (PLS) Path Modeling: Alternative Methods and Empirical Results.&rdquo;
In <em>Advances in International Marketing</em>, 195&ndash;218.
Emerald Group Publishing Limited.
<a href="https://doi.org/10.1108/s1474-7979%282011%290000022012">doi:10.1108/s1474-7979(2011)0000022012</a>.
</p>

<hr>
<h2 id='calculateGoF'>Goodness of Fit (GoF)</h2><span id='topic+calculateGoF'></span>

<h3>Description</h3>

<p>Calculate the Goodness of Fit (GoF) proposed by Tenenhaus et al. (2004).
Note that, contrary to what the name suggests, the GoF is <strong>not</strong> a
measure of model fit in the sense of SEM. See e.g. Henseler and Sarstedt (2012)
for a discussion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateGoF(
 .object              = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculateGoF_+3A_.object">.object</code></td>
<td>
<p>An R object of class <a href="#topic+cSEMResults">cSEMResults</a> resulting from a call to <code><a href="#topic+csem">csem()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The GoF is inherently tied to the common factor model. It is therefore
unclear how to meaningfully interpret the GoF in the context of a
model that contains constructs modeled as composites.
</p>


<h3>Value</h3>

<p>A single numeric value.
</p>


<h3>References</h3>

<p>Henseler J, Sarstedt M (2012).
&ldquo;Goodness-of-fit Indices for Partial Least Squares Path Modeling.&rdquo;
<em>Computational Statistics</em>, <b>28</b>(2), 565&ndash;580.
<a href="https://doi.org/10.1007/s00180-012-0317-1">doi:10.1007/s00180-012-0317-1</a>.<br /><br /> Tenenhaus M, Amanto S, Vinzi VE (2004).
&ldquo;A Global Goodness-of-Fit Index for PLS Structural Equation Modelling.&rdquo;
In <em>Proceedings of the XLII SIS Scientific Meeting</em>, 739&ndash;742.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+assess">assess()</a></code>, <a href="#topic+cSEMResults">cSEMResults</a>
</p>

<hr>
<h2 id='calculateHTMT'>HTMT</h2><span id='topic+calculateHTMT'></span>

<h3>Description</h3>

<p>Computes either the heterotrait-monotrait ratio of correlations (HTMT) based on
Henseler et al. (2015) or the HTMT2 proposed by Roemer et al. (2021).
While the HTMT is a consistent estimator for the construct correlation in
case of tau-equivalent measurement models, the HTMT2 is a consistent estimator
for congeneric measurement models. In general, they are used to assess discriminant validity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateHTMT(
 .object               = NULL,
 .type_htmt            = c('htmt','htmt2'),
 .absolute             = TRUE,
 .alpha                = 0.05,
 .ci                   = c("CI_percentile", "CI_standard_z", "CI_standard_t", 
                           "CI_basic", "CI_bc", "CI_bca", "CI_t_interval"),
 .inference            = FALSE,
 .only_common_factors  = TRUE,
 .R                    = 499,
 .seed                 = NULL,
 ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculateHTMT_+3A_.object">.object</code></td>
<td>
<p>An R object of class <a href="#topic+cSEMResults">cSEMResults</a> resulting from a call to <code><a href="#topic+csem">csem()</a></code>.</p>
</td></tr>
<tr><td><code id="calculateHTMT_+3A_.type_htmt">.type_htmt</code></td>
<td>
<p>Character string indicating the type of HTMT that should be
calculated, i.e., the original HTMT (&quot;<em>htmt</em>&quot;) or the HTMT2 (&quot;<em>htmt2</em>&quot;).
Defaults to &quot;<em>htmt</em>&quot;</p>
</td></tr>
<tr><td><code id="calculateHTMT_+3A_.absolute">.absolute</code></td>
<td>
<p>Logical. Should the absolute HTMT values be returned?
Defaults to <code>TRUE</code> .</p>
</td></tr>
<tr><td><code id="calculateHTMT_+3A_.alpha">.alpha</code></td>
<td>
<p>A numeric value giving the significance level.
Defaults to <code>0.05</code>.</p>
</td></tr>
<tr><td><code id="calculateHTMT_+3A_.ci">.ci</code></td>
<td>
<p>A character strings naming the type of confidence interval to use
to compute the 1-alpha% quantile of the bootstrap HTMT values. For possible
choices see <code><a href="#topic+infer">infer()</a></code>. Ignored
if <code>.inference = FALSE</code>. Defaults to &quot;<em>CI_percentile</em>&quot;.</p>
</td></tr>
<tr><td><code id="calculateHTMT_+3A_.inference">.inference</code></td>
<td>
<p>Logical. Should critical values be computed? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="calculateHTMT_+3A_.only_common_factors">.only_common_factors</code></td>
<td>
<p>Logical. Should only concepts modeled as common
factors be included when calculating one of the following quality criteria:
AVE, the Fornell-Larcker criterion, HTMT, and all reliability estimates.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="calculateHTMT_+3A_.r">.R</code></td>
<td>
<p>Integer. The number of bootstrap replications. Defaults to <code>499</code>.</p>
</td></tr>
<tr><td><code id="calculateHTMT_+3A_.seed">.seed</code></td>
<td>
<p>Integer or <code>NULL</code>. The random seed to use. Defaults to <code>NULL</code> in which
case an arbitrary seed is chosen. Note that the scope of the seed is limited
to the body of the function it is used in. Hence, the global seed will
not be altered!</p>
</td></tr>
<tr><td><code id="calculateHTMT_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computation of the HTMT/HTMT2 assumes that all intra-block and inter-block
correlations between indicators are either all-positive or all-negative.
A warning is given if this is not the case.
</p>
<p>To obtain bootstrap confidence intervals for the HTMT/HTMT2 values, set <code>.inference = TRUE</code>.
To choose the type of confidence interval, use <code>.ci</code>. To control the bootstrap process,
arguments <code>.R</code> and <code>.seed</code> are available. Note, that <code>.alpha</code> is multiplied by two
because typically researchers are interested in one-sided bootstrap confidence intervals
for the HTMT/HTMT2.
</p>
<p>Since the HTMT and the HTMT2 both assume a reflective measurement
model only concepts modeled as common factors are considered by default.
For concepts modeled as composites the HTMT may be computed by setting
<code>.only_common_factors = FALSE</code>, however, it is unclear how to
interpret values in this case.
</p>


<h3>Value</h3>

<p>A named list containing:
</p>

<ul>
<li><p> the values of the HTMT/HTMT2, i.e., a matrix with the HTMT/HTMT2 values
at its lower triangular and if <code>.inference = TRUE</code> the upper triangular contains
the upper limit of the 1-2*.alpha% bootstrap confidence interval if the HTMT/HTMT2 is positive and
the lower limit if the HTMT/HTMT2 is negative.
</p>
</li>
<li><p> the lower and upper limits of the 1-2*.alpha% bootstrap confidence interval if
<code>.inference = TRUE</code>; otherwise it is <code>NULL</code>.
</p>
</li>
<li><p> the number of admissible bootstrap runs, i.e., the number of HTMT/HTMT2 values
calculated during bootstrap if <code>.inference = TRUE</code>; otherwise it is <code>NULL</code>.
Note, the HTMT2 is based on the geometric and thus cannot always be calculated.
</p>
</li></ul>



<h3>References</h3>

<p>Henseler J, Ringle CM, Sarstedt M (2015).
&ldquo;A New Criterion for Assessing Discriminant Validity in Variance-based Structural Equation Modeling.&rdquo;
<em>Journal of the Academy of Marketing Science</em>, <b>43</b>(1), 115&ndash;135.
<a href="https://doi.org/10.1007/s11747-014-0403-8">doi:10.1007/s11747-014-0403-8</a>.<br /><br /> Roemer E, Schuberth F, Henseler J (2021).
&ldquo;HTMT2 &ndash; an improved criterion for assessing discriminant validity in structural equation modeling.&rdquo;
<em>Industrial Management &amp; Data Systems</em>, <b>121</b>(12), 2637&ndash;2650.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+assess">assess()</a></code>, <a href="#topic+csem">csem</a>, <a href="#topic+cSEMResults">cSEMResults</a>
</p>

<hr>
<h2 id='calculateIndicatorCor'>Internal: Calculate indicator correlation matrix</h2><span id='topic+calculateIndicatorCor'></span>

<h3>Description</h3>

<p>Calculate the indicator correlation matrix using conventional or robust methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateIndicatorCor(
  .X_cleaned           = NULL, 
  .approach_cor_robust = "none"
 )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculateIndicatorCor_+3A_.x_cleaned">.X_cleaned</code></td>
<td>
<p>A data.frame of processed data (cleaned and ordered). Note: <code>X_cleaned</code>
may not be scaled!</p>
</td></tr>
<tr><td><code id="calculateIndicatorCor_+3A_.approach_cor_robust">.approach_cor_robust</code></td>
<td>
<p>Character string. Approach used to obtain a robust
indicator correlation matrix. One of: &quot;<em>none</em>&quot; in which case the standard
Bravais-Pearson correlation is used,
&quot;<em>spearman</em>&quot; for the Spearman rank correlation, or
&quot;<em>mcd</em>&quot; via <code><a href="MASS.html#topic+cov.rob">MASS::cov.rob()</a></code> for a robust correlation matrix.
Defaults to &quot;<em>none</em>&quot;. Note that many postestimation procedures (such as
<code><a href="#topic+testOMF">testOMF()</a></code> or <code><a href="#topic+fit">fit()</a></code> implicitly assume a continuous
indicator correlation matrix (e.g. Bravais-Pearson correlation matrix).
Only use if you know what you are doing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>.approach_cor_robust = "none"</code> (the default) the type of correlation computed
depends on the types of the columns of <code>.X_cleaned</code> (i.e., the indicators)
involved in the computation.
</p>

<dl>
<dt><code>Numeric-numeric</code></dt><dd><p>If both columns (indicators) involved are numeric, the
Bravais-Pearson product-moment correlation is computed (via <code><a href="stats.html#topic+cor">stats::cor()</a></code>).</p>
</dd>
<dt><code>Numeric-factor</code></dt><dd><p>If any of the columns is a factor variable, the
polyserial correlation (Drasgow 1988) is computed (via
<code><a href="polycor.html#topic+polyserial">polycor::polyserial()</a></code>).</p>
</dd>
<dt><code>Factor-factor</code></dt><dd><p>If both columns are factor variables, the
polychoric correlation (Drasgow 1988) is computed (via
<code><a href="polycor.html#topic+polychor">polycor::polychor()</a></code>).</p>
</dd>
</dl>

<p>Note: logical input is treated as a 0-1 factor variable.
</p>
<p>If  <code>"mcd"</code> (= minimum covariance determinant), the MCD estimator
(Rousseeuw and Driessen 1999), a robust covariance estimator, is applied
(via <code><a href="MASS.html#topic+cov.rob">MASS::cov.rob()</a></code>).
</p>
<p>If <code>"spearman"</code>, the Spearman rank correlation is used (via <code><a href="stats.html#topic+cor">stats::cor()</a></code>).
</p>


<h3>Value</h3>

<p>A list with elements:
</p>

<dl>
<dt><code style="white-space: pre;">&#8288;$S&#8288;</code></dt><dd><p>The (K x K) indicator correlation matrix</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$cor_type&#8288;</code></dt><dd><p>The type(s) of indicator correlation computed (
&quot;Pearson&quot;, &quot;Polyserial&quot;, &quot;Polychoric&quot;)</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$thre_est&#8288;</code></dt><dd><p>Currently ignored (NULL)</p>
</dd>
</dl>



<h3>References</h3>

<p>Drasgow F (1988).
&ldquo;Polychoric and polyserial correlations.&rdquo;
In <em>Encyclopedia of Statistical Sciences</em>, volume 7, 68-74.
John Wiley &amp; Sons Inc, Hoboken.<br /><br /> Rousseeuw PJ, Driessen KV (1999).
&ldquo;A Fast Algorithm for the Minimum Covariance Determinant Estimator.&rdquo;
<em>Technometrics</em>, <b>41</b>(3), 212&ndash;223.
<a href="https://doi.org/10.1080/00401706.1999.10485670">doi:10.1080/00401706.1999.10485670</a>.
</p>

<hr>
<h2 id='calculateInnerWeightsPLS'>Internal: Calculate the inner weights for PLS-PM</h2><span id='topic+calculateInnerWeightsPLS'></span>

<h3>Description</h3>

<p>PLS-PM forms &quot;inner&quot; composites as a weighted sum of its <em>I</em> related composites.
These inner weights are obtained using one of the following schemes (Lohmöller 1989):
</p>

<dl>
<dt><code>centroid</code></dt><dd><p>According to the centroid weighting scheme each inner weight used
to form composite <em>j</em> is either 1 if the correlation between composite <em>j</em> and
its via the structural model related composite <em>i = 1, ..., I</em> is positive
and -1 if it is negative.</p>
</dd>
<dt><code>factorial</code></dt><dd><p>According to the factorial weighting scheme each inner weight used
to form inner composite <em>j</em> is equal to the correlation between composite <em>j</em>
and its via the structural model related composite <em>i = 1, ..., I</em>.</p>
</dd>
<dt><code>path</code></dt><dd><p>Lets call all construct that have an arrow pointing to construct <em>j</em>
<strong>predecessors of j</strong> and all arrows going from j to other constructs <strong>followers of j</strong>.
According the path weighting scheme, inner weights are computed as follows.
Take construct <em>j</em>:
</p>

<ul>
<li><p> For all predecessors of <em>j</em> set the inner weight of predecessor
<em>i</em> to the correlation of <em>i</em> with <em>j</em>.
</p>
</li>
<li><p> For all followers of <em>j</em> set the inner weight of follower <em>i</em> to
the coefficient of a multiple regression of <em>j</em> on all
followers <em>i</em> with <em>i = 1,...,I</em>.
</p>
</li></ul>
</dd>
</dl>

<p>Except for the path weighting scheme relatedness can come in two flavors.
If <code>.PLS_ignore_structural_model = TRUE</code> all constructs are considered related.
If <code>.PLS_ignore_structural_model = FALSE</code> (the default) only adjacent constructs
are considered. If <code>.PLS_ignore_structural_model = TRUE</code> and <code>.PLS_weight_scheme_inner = "path"</code>
a warning is issued and <code>.PLS_ignore_structural_model</code> is changed to <code>FALSE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateInnerWeightsPLS(
  .S                           = args_default()$.S,
  .W                           = args_default()$.W,
  .csem_model                  = args_default()$.csem_model,
  .PLS_ignore_structural_model = args_default()$.PLS_ignore_structrual_model,
  .PLS_weight_scheme_inner     = args_default()$.PLS_weight_scheme_inner
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculateInnerWeightsPLS_+3A_.s">.S</code></td>
<td>
<p>The (K x K) empirical indicator correlation matrix.</p>
</td></tr>
<tr><td><code id="calculateInnerWeightsPLS_+3A_.w">.W</code></td>
<td>
<p>A (J x K) matrix of weights.</p>
</td></tr>
<tr><td><code id="calculateInnerWeightsPLS_+3A_.csem_model">.csem_model</code></td>
<td>
<p>A (possibly incomplete) <a href="#topic+cSEMModel">cSEMModel</a>-list.</p>
</td></tr>
<tr><td><code id="calculateInnerWeightsPLS_+3A_.pls_ignore_structural_model">.PLS_ignore_structural_model</code></td>
<td>
<p>Logical. Should the structural model be ignored
when calculating the inner weights of the PLS-PM algorithm? Defaults to <code>FALSE</code>.
Ignored if <code>.approach_weights</code> is not PLS-PM.</p>
</td></tr>
<tr><td><code id="calculateInnerWeightsPLS_+3A_.pls_weight_scheme_inner">.PLS_weight_scheme_inner</code></td>
<td>
<p>Character string. The inner weighting scheme
used by PLS-PM. One of: &quot;<em>centroid</em>&quot;, &quot;<em>factorial</em>&quot;, or &quot;<em>path</em>&quot;.
Defaults to &quot;<em>path</em>&quot;. Ignored if <code>.approach_weight</code> is not PLS-PM.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The (J x J) matrix <code>E</code> of inner weights.
</p>

<hr>
<h2 id='calculateMAE'>Internal: Calculate prediction metrics</h2><span id='topic+calculateMAE'></span>

<h3>Description</h3>

<p>Currently, the following prediction measures are available:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateMAE(resid)
</code></pre>


<h3>Details</h3>


<ul>
<li><p> Mean absolute error
</p>
</li>
<li><p> Mean absolute percentage error
</p>
</li>
<li><p> Mean squared error
</p>
</li>
<li><p> Root mean squared error
</p>
</li>
<li><p> Theil's forecast accuracy
</p>
</li>
<li><p> Theil's forecast quality
</p>
</li>
<li><p> Bias proportion of MSE
</p>
</li>
<li><p> Regression proportion of MSE
</p>
</li>
<li><p> Disturbance proportion of MSE
</p>
</li></ul>



<h3>Value</h3>

<p>A vector of the prediction measures for the observed variables
belonging to endogenous constructs
</p>

<hr>
<h2 id='calculateModelSelectionCriteria'>Model selection criteria</h2><span id='topic+calculateModelSelectionCriteria'></span>

<h3>Description</h3>

<p>Calculate several information or model selection criteria (MSC) such as the
Akaike information criterion (AIC), the Bayesian information criterion (BIC) or
the Hannan-Quinn criterion (HQ).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateModelSelectionCriteria(
  .object          = NULL,
  .ms_criterion    = c("all", "aic", "aicc", "aicu", "bic", "fpe", "gm", "hq",
                       "hqc", "mallows_cp"),
  .by_equation     = TRUE, 
  .only_structural = TRUE 
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculateModelSelectionCriteria_+3A_.object">.object</code></td>
<td>
<p>An R object of class <a href="#topic+cSEMResults">cSEMResults</a> resulting from a call to <code><a href="#topic+csem">csem()</a></code>.</p>
</td></tr>
<tr><td><code id="calculateModelSelectionCriteria_+3A_.ms_criterion">.ms_criterion</code></td>
<td>
<p>Character string. Either a single character string or a vector
of character strings naming the model selection criterion to compute.
Defaults to <code>"all"</code>.</p>
</td></tr>
<tr><td><code id="calculateModelSelectionCriteria_+3A_.by_equation">.by_equation</code></td>
<td>
<p>Should the criteria be computed for each structural model
equation separately? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="calculateModelSelectionCriteria_+3A_.only_structural">.only_structural</code></td>
<td>
<p>Should the the log-likelihood be based on the
structural model? Ignored if <code>.by_equation == TRUE</code>. Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, all criteria are calculated (<code>.ms_criterion == "all"</code>). To compute only
a subset of the criteria a vector of criteria may be given.
</p>
<p>If <code>.by_equation == TRUE</code> (the default), the criteria are computed for each
structural equation of the model separately, as suggested by
Sharma et al. (2019) in the context of PLS. The relevant formula can be found in
Table B1 of the appendix of Sharma et al. (2019).
</p>
<p>If <code>.by_equation == FALSE</code> the AIC, the BIC and the HQ for whole model
are calculated. All other criteria are currently ignored in this case!
The relevant formula are (see, e.g., (Akaike 1974),
Schwarz (1978),
Hannan and Quinn (1979)):
</p>
<p style="text-align: center;"><code class="reqn">AIC = - 2*log(L) + 2*k</code>
</p>

<p style="text-align: center;"><code class="reqn">BIC = - 2*log(L) + k*ln(n)</code>
</p>

<p style="text-align: center;"><code class="reqn">HQ  = - 2*log(L) + 2*k*ln(ln(n))</code>
</p>

<p>where log(L) is the log likelihood function of the multivariate normal
distribution of the observable variables, k the (total) number of estimated parameters,
and n the sample size.
</p>
<p>If <code>.only_structural == TRUE</code>, log(L) is based on the structural model only.
The argument is ignored if <code>.by_equation == TRUE</code>.
</p>


<h3>Value</h3>

<p>If <code>.by_equation == TRUE</code> a named list of model selection criteria.
</p>


<h3>References</h3>

<p>Akaike H (1974).
&ldquo;A New Look at the Statistical Model Identification.&rdquo;
<em>IEEE Transactions on Automatic Control</em>, <b>19</b>(6), 716&ndash;723.<br /><br /> Hannan EJ, Quinn BG (1979).
&ldquo;The Determination of the order of an autoregression.&rdquo;
<em>Journal of the Royal Statistical Society: Series B (Methodological)</em>, <b>41</b>(2), 190&ndash;195.<br /><br /> Schwarz G (1978).
&ldquo;Estimating the Dimension of a Model.&rdquo;
<em>The Annals of Statistics</em>, <b>6</b>(2), 461&ndash;464.
<a href="https://doi.org/10.1214/aos/1176344136">doi:10.1214/aos/1176344136</a>.<br /><br /> Sharma P, Sarstedt M, Shmueli G, Kim KH, Thiele KO (2019).
&ldquo;PLS-Based Model Selection: The Role of Alternative Explanations in Information Systems Research.&rdquo;
<em>Journal of the Association for Information Systems</em>, <b>20</b>(4).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+assess">assess()</a></code>, <a href="#topic+cSEMResults">cSEMResults</a>
</p>

<hr>
<h2 id='calculateOuterWeightsPLS'>Internal: Calculate the outer weights for PLS-PM</h2><span id='topic+calculateOuterWeightsPLS'></span>

<h3>Description</h3>

<p>Calculates outer weights in PLS-PM. Currently, the originally suggested mode A
and mode B are suggested. Additionally, non-negative least squares (modeBNNLS) and
weights of principal component analysis (PCA) are implemented.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateOuterWeightsPLS(
   .data   = args_default()$.data,  
   .S      = args_default()$.S,
   .W      = args_default()$.W,
   .E      = args_default()$.E,
   .modes  = args_default()$.modes
   )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculateOuterWeightsPLS_+3A_.data">.data</code></td>
<td>
<p>A <code>data.frame</code> or a <code>matrix</code> of standardized or unstandardized
data (indicators/items/manifest variables). Possible column types or classes
of the data provided are: &quot;<code>logical</code>&quot;, &quot;<code>numeric</code>&quot; (&quot;<code>double</code>&quot; or &quot;<code>integer</code>&quot;),
&quot;<code>factor</code>&quot; (&quot;<code>ordered</code>&quot; and/or &quot;<code>unordered</code>&quot;), &quot;<code>character</code>&quot; (converted to factor),
or a mix of several types.</p>
</td></tr>
<tr><td><code id="calculateOuterWeightsPLS_+3A_.s">.S</code></td>
<td>
<p>The (K x K) empirical indicator correlation matrix.</p>
</td></tr>
<tr><td><code id="calculateOuterWeightsPLS_+3A_.w">.W</code></td>
<td>
<p>A (J x K) matrix of weights.</p>
</td></tr>
<tr><td><code id="calculateOuterWeightsPLS_+3A_.e">.E</code></td>
<td>
<p>A (J x J) matrix of inner weights.</p>
</td></tr>
<tr><td><code id="calculateOuterWeightsPLS_+3A_.modes">.modes</code></td>
<td>
<p>A vector giving the mode for each construct in the form <code>"name" = "mode"</code>.
Only used internally.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A (J x K) matrix of outer weights.
</p>

<hr>
<h2 id='calculateParameterDifference'>Internal: Parameter differences across groups</h2><span id='topic+calculateParameterDifference'></span>

<h3>Description</h3>

<p>Calculate the difference between one or more parameter estimates across
all possible pairs of groups (data sets) in <code>.object</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateParameterDifference(
  .object     = args_default()$.object,
  .model      = args_default()$.model
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculateParameterDifference_+3A_.object">.object</code></td>
<td>
<p>An R object of class <a href="#topic+cSEMResults">cSEMResults</a> resulting from a call to <code><a href="#topic+csem">csem()</a></code>.</p>
</td></tr>
<tr><td><code id="calculateParameterDifference_+3A_.model">.model</code></td>
<td>
<p>A model in <a href="lavaan.html#topic+model.syntax">lavaan model syntax</a> indicating which
parameters (i.e., path (<code>~</code>), loadings (<code style="white-space: pre;">&#8288;=~&#8288;</code>), or weights (<code style="white-space: pre;">&#8288;&lt;~&#8288;</code>)) should be
compared across groups. Defaults to <code>NULL</code> in which case all parameters of the model
are compared.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of length equal to the number of possible pairs of
groups in <code>.object</code> (mathematically, this is n choose 2, i.e., 3 if there are three
groups and 6 if there are 4 groups). Each list elements is itself a list of
three. The first list element contains
the difference between parameter estimates of the structural model, the second
list element the difference between estimated loadings, and the third
the difference between estimated weights.
</p>

<hr>
<h2 id='calculatePr'>Internal: Calculation of the CDF used in Henseler et al. (2009)</h2><span id='topic+calculatePr'></span>

<h3>Description</h3>

<p>Calculates the probability that theta^1 is smaller than or equal to theta^2.
See Equation (6) in Sarstedt et al. (2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculatePr(.resample_centered = NULL, .parameters_to_compare = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculatePr_+3A_.parameters_to_compare">.parameters_to_compare</code></td>
<td>
<p>A model in <a href="lavaan.html#topic+model.syntax">lavaan model syntax</a> indicating which
parameters (i.e, path (<code>~</code>), loadings (<code style="white-space: pre;">&#8288;=~&#8288;</code>), weights (<code style="white-space: pre;">&#8288;&lt;~&#8288;</code>), or correlations (<code style="white-space: pre;">&#8288;~~&#8288;</code>)) should be
compared across groups. Defaults to <code>NULL</code> in which case all weights, loadings and
path coefficients of the originally specified model are compared.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector
</p>


<h3>References</h3>

<p>Sarstedt M, Henseler J, Ringle CM (2011).
&ldquo;Multigroup Analysis in Partial Least Squares (PLS) Path Modeling: Alternative Methods and Empirical Results.&rdquo;
In <em>Advances in International Marketing</em>, 195&ndash;218.
Emerald Group Publishing Limited.
<a href="https://doi.org/10.1108/s1474-7979%282011%290000022012">doi:10.1108/s1474-7979(2011)0000022012</a>.
</p>

<hr>
<h2 id='calculateReliabilities'>Internal: Calculate Reliabilities</h2><span id='topic+calculateReliabilities'></span>

<h3>Description</h3>

<p>Internal: Calculate Reliabilities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateReliabilities(
  .X = args_default()$.X,
  .S = args_default()$.S,
  .W = args_default()$.W,
  .approach_weights = args_default()$.approach_weights,
  .csem_model = args_default()$.csem_model,
  .disattenuate = args_default()$.disattenuate,
  .PLS_approach_cf = args_default()$.PLS_approach_cf,
  .reliabilities = args_default()$.reliabilities
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculateReliabilities_+3A_.x">.X</code></td>
<td>
<p>A matrix of processed data (scaled, cleaned and ordered).</p>
</td></tr>
<tr><td><code id="calculateReliabilities_+3A_.s">.S</code></td>
<td>
<p>The (K x K) empirical indicator correlation matrix.</p>
</td></tr>
<tr><td><code id="calculateReliabilities_+3A_.w">.W</code></td>
<td>
<p>A (J x K) matrix of weights.</p>
</td></tr>
<tr><td><code id="calculateReliabilities_+3A_.approach_weights">.approach_weights</code></td>
<td>
<p>Character string. Approach used to
obtain composite weights. One of: &quot;<em>PLS-PM</em>&quot;, &quot;<em>SUMCORR</em>&quot;, &quot;<em>MAXVAR</em>&quot;,
&quot;<em>SSQCORR</em>&quot;, &quot;<em>MINVAR</em>&quot;, &quot;<em>GENVAR</em>&quot;, &quot;<em>GSCA</em>&quot;, &quot;<em>PCA</em>&quot;, &quot;<em>unit</em>&quot;, &quot;<em>bartlett</em>&quot;,
or &quot;<em>regression</em>&quot;. Defaults to &quot;<em>PLS-PM</em>&quot;.</p>
</td></tr>
<tr><td><code id="calculateReliabilities_+3A_.csem_model">.csem_model</code></td>
<td>
<p>A (possibly incomplete) <a href="#topic+cSEMModel">cSEMModel</a>-list.</p>
</td></tr>
<tr><td><code id="calculateReliabilities_+3A_.disattenuate">.disattenuate</code></td>
<td>
<p>Logical. Should composite/proxy correlations
be disattenuated to yield consistent loadings and path estimates if at least
one of the construct is modeled as a common factor? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="calculateReliabilities_+3A_.pls_approach_cf">.PLS_approach_cf</code></td>
<td>
<p>Character string. Approach used to obtain the correction
factors for PLSc. One of: &quot;<em>dist_squared_euclid</em>&quot;, &quot;<em>dist_euclid_weighted</em>&quot;,
&quot;<em>fisher_transformed</em>&quot;, &quot;<em>mean_arithmetic</em>&quot;, &quot;<em>mean_geometric</em>&quot;, &quot;<em>mean_harmonic</em>&quot;,
&quot;<em>geo_of_harmonic</em>&quot;. Defaults to &quot;<em>dist_squared_euclid</em>&quot;.
Ignored if <code>.disattenuate = FALSE</code> or if <code>.approach_weights</code> is not PLS-PM.</p>
</td></tr>
<tr><td><code id="calculateReliabilities_+3A_.reliabilities">.reliabilities</code></td>
<td>
<p>A character vector of <code>"name" = value</code> pairs,
where <code>value</code> is a number between 0 and 1 and <code>"name"</code> a character string
of the corresponding construct name, or <code>NULL</code>. Reliabilities
may be given for a subset of the constructs. Defaults to <code>NULL</code> in which case
reliabilities are estimated by <code>csem()</code>. Currently, only supported for
<code>.approach_weights = "PLS-PM"</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='calculateVIFModeB'>Calculate variance inflation factors (VIF) for weights obtained by PLS Mode B</h2><span id='topic+calculateVIFModeB'></span>

<h3>Description</h3>

<p>Calculate the variance inflation factor (VIF) for weights obtained by PLS-PM's Mode B.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateVIFModeB(.object = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculateVIFModeB_+3A_.object">.object</code></td>
<td>
<p>An R object of class <a href="#topic+cSEMResults">cSEMResults</a> resulting from a call to <code><a href="#topic+csem">csem()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Weight estimates obtained by Mode B can suffer from multicollinearity. VIF values
are commonly used to assess the severity of multicollinearity.
</p>
<p>The function is only applicable to objects of class <code>cSEMResults_default</code>.
For other object classes use <code><a href="#topic+assess">assess()</a></code>.
</p>


<h3>Value</h3>

<p>A named list of vectors containing the VIF values. Each list name
is the name of a construct whose weights were obtained by Mode B.
The vectors contain the VIF values obtained from a regression of each
explanatory variable of a given construct on the remaining explanatory
variables of that construct.
</p>
<p>If the weighting approach is not <code>"PLS-PM"</code> or for none of the constructs Mode B is used,
the function silently returns <code>NA</code>.
</p>


<h3>References</h3>

<p>There are no references for Rd macro <code style="white-space: pre;">&#8288;\insertAllCites&#8288;</code> on this help page.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+assess">assess()</a></code>, <a href="#topic+cSEMResults">cSEMResults</a>
</p>

<hr>
<h2 id='calculateWeightsGSCA'>Calculate composite weights using GSCA</h2><span id='topic+calculateWeightsGSCA'></span>

<h3>Description</h3>

<p>Calculate composite weights using generalized structure component analysis (GSCA).
The first version of this approach was presented in Hwang and Takane (2004).
Since then, several advancements have been proposed. The latest version
of GSCA can been found in Hwang and Takane (2014). This is the version
<span class="pkg">cSEM</span>s implementation is based on.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateWeightsGSCA(
  .X                           = args_default()$.X,
  .S                           = args_default()$.S,
  .csem_model                  = args_default()$.csem_model,
  .conv_criterion              = args_default()$.conv_criterion,
  .iter_max                    = args_default()$.iter_max,
  .starting_values             = args_default()$.starting_values,
  .tolerance                   = args_default()$.tolerance
   )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculateWeightsGSCA_+3A_.x">.X</code></td>
<td>
<p>A matrix of processed data (scaled, cleaned and ordered).</p>
</td></tr>
<tr><td><code id="calculateWeightsGSCA_+3A_.s">.S</code></td>
<td>
<p>The (K x K) empirical indicator correlation matrix.</p>
</td></tr>
<tr><td><code id="calculateWeightsGSCA_+3A_.csem_model">.csem_model</code></td>
<td>
<p>A (possibly incomplete) <a href="#topic+cSEMModel">cSEMModel</a>-list.</p>
</td></tr>
<tr><td><code id="calculateWeightsGSCA_+3A_.conv_criterion">.conv_criterion</code></td>
<td>
<p>Character string. The criterion to use for the convergence check.
One of: &quot;<em>diff_absolute</em>&quot;, &quot;<em>diff_squared</em>&quot;, or &quot;<em>diff_relative</em>&quot;. Defaults
to &quot;<em>diff_absolute</em>&quot;.</p>
</td></tr>
<tr><td><code id="calculateWeightsGSCA_+3A_.iter_max">.iter_max</code></td>
<td>
<p>Integer. The maximum number of iterations allowed.
If <code>iter_max = 1</code> and <code>.approach_weights = "PLS-PM"</code> one-step weights are returned.
If the algorithm exceeds the specified number, weights of iteration step
<code>.iter_max - 1</code>  will be returned with a warning. Defaults to <code>100</code>.</p>
</td></tr>
<tr><td><code id="calculateWeightsGSCA_+3A_.starting_values">.starting_values</code></td>
<td>
<p>A named list of vectors where the
list names are the construct names whose indicator weights the user
wishes to set. The vectors must be named vectors of <code>"indicator_name" = value</code>
pairs, where <code>value</code> is the (scaled or unscaled) starting weight. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="calculateWeightsGSCA_+3A_.tolerance">.tolerance</code></td>
<td>
<p>Double. The tolerance criterion for convergence.
Defaults to <code>1e-05</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list. J stands for the number of constructs and K for the number
of indicators.
</p>

<dl>
<dt><code style="white-space: pre;">&#8288;$W&#8288;</code></dt><dd><p>A (J x K) matrix of estimated weights.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$E&#8288;</code></dt><dd><p><code>NULL</code></p>
</dd>
<dt><code style="white-space: pre;">&#8288;$Modes&#8288;</code></dt><dd><p>A named vector of Modes used for the outer estimation, for GSCA
the mode is automatically set to &quot;gsca&quot;.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$Conv_status&#8288;</code></dt><dd><p>The convergence status. <code>TRUE</code> if the algorithm has converged
and <code>FALSE</code> otherwise.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$Iterations&#8288;</code></dt><dd><p>The number of iterations required.</p>
</dd>
</dl>



<h3>References</h3>

<p>Hwang H, Takane Y (2004).
&ldquo;Generalized Structured Component Analysis.&rdquo;
<em>Psychometrika</em>, <b>69</b>(1), 81&ndash;99.<br /><br /> Hwang H, Takane Y (2014).
<em>Generalized Structured Component Analysis: A Component-Based Approach to Structural Equation Modeling</em>,  Chapman &amp; Hall/CRC Statistics in the Social and Behavioral Sciences.
Chapman and Hall/CRC.
</p>

<hr>
<h2 id='calculateWeightsGSCAm'>Calculate weights using GSCAm</h2><span id='topic+calculateWeightsGSCAm'></span>

<h3>Description</h3>

<p>Calculate composite weights using generalized structured component analysis
with uniqueness terms (GSCAm) proposed by Hwang et al. (2017).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateWeightsGSCAm(
  .X                           = args_default()$.X,
  .csem_model                  = args_default()$.csem_model,
  .conv_criterion              = args_default()$.conv_criterion,
  .iter_max                    = args_default()$.iter_max,
  .starting_values             = args_default()$.starting_values,
  .tolerance                   = args_default()$.tolerance
   )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculateWeightsGSCAm_+3A_.x">.X</code></td>
<td>
<p>A matrix of processed data (scaled, cleaned and ordered).</p>
</td></tr>
<tr><td><code id="calculateWeightsGSCAm_+3A_.csem_model">.csem_model</code></td>
<td>
<p>A (possibly incomplete) <a href="#topic+cSEMModel">cSEMModel</a>-list.</p>
</td></tr>
<tr><td><code id="calculateWeightsGSCAm_+3A_.conv_criterion">.conv_criterion</code></td>
<td>
<p>Character string. The criterion to use for the convergence check.
One of: &quot;<em>diff_absolute</em>&quot;, &quot;<em>diff_squared</em>&quot;, or &quot;<em>diff_relative</em>&quot;. Defaults
to &quot;<em>diff_absolute</em>&quot;.</p>
</td></tr>
<tr><td><code id="calculateWeightsGSCAm_+3A_.iter_max">.iter_max</code></td>
<td>
<p>Integer. The maximum number of iterations allowed.
If <code>iter_max = 1</code> and <code>.approach_weights = "PLS-PM"</code> one-step weights are returned.
If the algorithm exceeds the specified number, weights of iteration step
<code>.iter_max - 1</code>  will be returned with a warning. Defaults to <code>100</code>.</p>
</td></tr>
<tr><td><code id="calculateWeightsGSCAm_+3A_.starting_values">.starting_values</code></td>
<td>
<p>A named list of vectors where the
list names are the construct names whose indicator weights the user
wishes to set. The vectors must be named vectors of <code>"indicator_name" = value</code>
pairs, where <code>value</code> is the (scaled or unscaled) starting weight. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="calculateWeightsGSCAm_+3A_.tolerance">.tolerance</code></td>
<td>
<p>Double. The tolerance criterion for convergence.
Defaults to <code>1e-05</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If there are only constructs modeled as common factors
calling <code><a href="#topic+csem">csem()</a></code> with <code>.appraoch_weights = "GSCA"</code> will automatically call
<code><a href="#topic+calculateWeightsGSCAm">calculateWeightsGSCAm()</a></code> unless <code>.disattenuate = FALSE</code>.
GSCAm currently only works for pure common factor models. The reason is that the implementation
in <span class="pkg">cSEM</span> is based on (the appendix) of Hwang et al. (2017).
Following the appendix, GSCAm fails if there is at least one construct
modeled as a composite because calculating weight estimates with GSCAm leads to a product
involving the measurement matrix. This matrix does not have full rank
if a construct modeled as a composite is present.
The reason is that the measurement matrix has a zero row for every construct
which is a pure composite (i.e. all related loadings are zero)
and, therefore, leads to a non-invertible matrix when multiplying it with its transposed.
</p>


<h3>Value</h3>

<p>A list with the elements
</p>

<dl>
<dt><code style="white-space: pre;">&#8288;$W&#8288;</code></dt><dd><p>A (J x K) matrix of estimated weights.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$C&#8288;</code></dt><dd><p>The (J x K) matrix of estimated loadings.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$B&#8288;</code></dt><dd><p>The (J x J) matrix of estimated path coefficients.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$E&#8288;</code></dt><dd><p><code>NULL</code></p>
</dd>
<dt><code style="white-space: pre;">&#8288;$Modes&#8288;</code></dt><dd><p>A named vector of Modes used for the outer estimation, for GSCA
the mode is automatically set to 'gsca'.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$Conv_status&#8288;</code></dt><dd><p>The convergence status. <code>TRUE</code> if the algorithm has converged
and <code>FALSE</code> otherwise.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$Iterations&#8288;</code></dt><dd><p>The number of iterations required.</p>
</dd>
</dl>



<h3>References</h3>

<p>Hwang H, Takane Y, Jung K (2017).
&ldquo;Generalized structured component analysis with uniqueness terms for accommodating measurement error.&rdquo;
<em>Frontiers in Psychology</em>, <b>8</b>(2137), 1&ndash;12.
</p>

<hr>
<h2 id='calculateWeightsKettenring'>Calculate composite weights using GCCA</h2><span id='topic+calculateWeightsKettenring'></span>

<h3>Description</h3>

<p>Calculates composite weights according to one of the the five criteria
&quot;<em>SUMCORR</em>&quot;, &quot;<em>MAXVAR</em>&quot;, &quot;<em>SSQCORR</em>&quot;, &quot;<em>MINVAR</em>&quot;, and &quot;<em>GENVAR</em>&quot;
suggested by Kettenring (1971).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateWeightsKettenring(
  .S              = args_default()$.S, 
  .csem_model     = args_default()$.csem_model,   
  .approach_gcca  = args_default()$.approach_gcca
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculateWeightsKettenring_+3A_.s">.S</code></td>
<td>
<p>The (K x K) empirical indicator correlation matrix.</p>
</td></tr>
<tr><td><code id="calculateWeightsKettenring_+3A_.csem_model">.csem_model</code></td>
<td>
<p>A (possibly incomplete) <a href="#topic+cSEMModel">cSEMModel</a>-list.</p>
</td></tr>
<tr><td><code id="calculateWeightsKettenring_+3A_.approach_gcca">.approach_gcca</code></td>
<td>
<p>Character string. The Kettenring approach to use for GCCA. One of
&quot;<em>SUMCORR</em>&quot;, &quot;<em>MAXVAR</em>&quot;, &quot;<em>SSQCORR</em>&quot;, &quot;<em>MINVAR</em>&quot; or &quot;<em>GENVAR</em>&quot;. Defaults to
&quot;<em>SUMCORR</em>&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list. J stands for the number of constructs and K for the number
of indicators.
</p>

<dl>
<dt><code style="white-space: pre;">&#8288;$W&#8288;</code></dt><dd><p>A (J x K) matrix of estimated weights.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$E&#8288;</code></dt><dd><p><code>NULL</code></p>
</dd>
<dt><code style="white-space: pre;">&#8288;$Modes&#8288;</code></dt><dd><p>The GCCA mode used for the estimation.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$Conv_status&#8288;</code></dt><dd><p>The convergence status. <code>TRUE</code> if the algorithm has converged
and <code>FALSE</code> otherwise. For <code>.approach_gcca = "MINVAR"</code> or <code>.approach_gcca = "MAXVAR"</code>
the convergence status is <code>NULL</code> since both are closed-form estimators.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$Iterations&#8288;</code></dt><dd><p>The number of iterations required. 0 for
<code>.approach_gcca = "MINVAR"</code> or <code>.approach_gcca = "MAXVAR"</code></p>
</dd>
</dl>



<h3>References</h3>

<p>Kettenring JR (1971).
&ldquo;Canonical Analysis of Several Sets of Variables.&rdquo;
<em>Biometrika</em>, <b>58</b>(3), 433&ndash;451.
</p>

<hr>
<h2 id='calculateWeightsPCA'>Calculate composite weights using principal component analysis (PCA)</h2><span id='topic+calculateWeightsPCA'></span>

<h3>Description</h3>

<p>Calculate weights for each block by extracting the first principal component
of the indicator correlation matrix S_jj for each blocks, i.e., weights
are the simply the first eigenvector of S_jj.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateWeightsPCA(
 .S                 = args_default()$.S,
 .csem_model        = args_default()$.csem_model
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculateWeightsPCA_+3A_.s">.S</code></td>
<td>
<p>The (K x K) empirical indicator correlation matrix.</p>
</td></tr>
<tr><td><code id="calculateWeightsPCA_+3A_.csem_model">.csem_model</code></td>
<td>
<p>A (possibly incomplete) <a href="#topic+cSEMModel">cSEMModel</a>-list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list. J stands for the number of constructs and K for the number
of indicators.
</p>

<dl>
<dt><code style="white-space: pre;">&#8288;$W&#8288;</code></dt><dd><p>A (J x K) matrix of estimated weights.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$E&#8288;</code></dt><dd><p><code>NULL</code></p>
</dd>
<dt><code style="white-space: pre;">&#8288;$Modes&#8288;</code></dt><dd><p>The mode used. Always &quot;PCA&quot;.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$Conv_status&#8288;</code></dt><dd><p><code>NULL</code> as there are no iterations</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$Iterations&#8288;</code></dt><dd><p>0 as there are no iterations</p>
</dd>
</dl>


<hr>
<h2 id='calculateWeightsPLS'>Calculate composite weights using PLS-PM</h2><span id='topic+calculateWeightsPLS'></span>

<h3>Description</h3>

<p>Calculate composite weights using the partial least squares path modeling
(PLS-PM) algorithm (Wold 1975).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateWeightsPLS(
  .data                        = args_default()$.data,
  .S                           = args_default()$.S,
  .csem_model                  = args_default()$.csem_model,
  .conv_criterion              = args_default()$.conv_criterion,
  .iter_max                    = args_default()$.iter_max,
  .PLS_ignore_structural_model = args_default()$.PLS_ignore_structural_model,
  .PLS_modes                   = args_default()$.PLS_modes,
  .PLS_weight_scheme_inner     = args_default()$.PLS_weight_scheme_inner,
  .starting_values             = args_default()$.starting_values,
  .tolerance                   = args_default()$.tolerance
   )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculateWeightsPLS_+3A_.data">.data</code></td>
<td>
<p>A <code>data.frame</code> or a <code>matrix</code> of standardized or unstandardized
data (indicators/items/manifest variables). Possible column types or classes
of the data provided are: &quot;<code>logical</code>&quot;, &quot;<code>numeric</code>&quot; (&quot;<code>double</code>&quot; or &quot;<code>integer</code>&quot;),
&quot;<code>factor</code>&quot; (&quot;<code>ordered</code>&quot; and/or &quot;<code>unordered</code>&quot;), &quot;<code>character</code>&quot; (converted to factor),
or a mix of several types.</p>
</td></tr>
<tr><td><code id="calculateWeightsPLS_+3A_.s">.S</code></td>
<td>
<p>The (K x K) empirical indicator correlation matrix.</p>
</td></tr>
<tr><td><code id="calculateWeightsPLS_+3A_.csem_model">.csem_model</code></td>
<td>
<p>A (possibly incomplete) <a href="#topic+cSEMModel">cSEMModel</a>-list.</p>
</td></tr>
<tr><td><code id="calculateWeightsPLS_+3A_.conv_criterion">.conv_criterion</code></td>
<td>
<p>Character string. The criterion to use for the convergence check.
One of: &quot;<em>diff_absolute</em>&quot;, &quot;<em>diff_squared</em>&quot;, or &quot;<em>diff_relative</em>&quot;. Defaults
to &quot;<em>diff_absolute</em>&quot;.</p>
</td></tr>
<tr><td><code id="calculateWeightsPLS_+3A_.iter_max">.iter_max</code></td>
<td>
<p>Integer. The maximum number of iterations allowed.
If <code>iter_max = 1</code> and <code>.approach_weights = "PLS-PM"</code> one-step weights are returned.
If the algorithm exceeds the specified number, weights of iteration step
<code>.iter_max - 1</code>  will be returned with a warning. Defaults to <code>100</code>.</p>
</td></tr>
<tr><td><code id="calculateWeightsPLS_+3A_.pls_ignore_structural_model">.PLS_ignore_structural_model</code></td>
<td>
<p>Logical. Should the structural model be ignored
when calculating the inner weights of the PLS-PM algorithm? Defaults to <code>FALSE</code>.
Ignored if <code>.approach_weights</code> is not PLS-PM.</p>
</td></tr>
<tr><td><code id="calculateWeightsPLS_+3A_.pls_modes">.PLS_modes</code></td>
<td>
<p>Either a named list specifying the mode that should be used for
each construct in the form <code>"construct_name" = mode</code>, a single character
string giving the mode that should be used for all constructs, or <code>NULL</code>.
Possible choices for <code>mode</code> are: &quot;<em>modeA</em>&quot;, &quot;<em>modeB</em>&quot;, &quot;<em>modeBNNLS</em>&quot;,
&quot;<em>unit</em>&quot;, &quot;<em>PCA</em>&quot;, a single integer or
a vector of fixed weights of the same length as there are indicators for the
construct given by <code>"construct_name"</code>. If only a single number is provided this is identical to
using unit weights, as weights are rescaled such that the related composite
has unit variance.  Defaults to <code>NULL</code>.
If <code>NULL</code> the appropriate mode according to the type
of construct used is chosen. Ignored if <code>.approach_weight</code> is not PLS-PM.</p>
</td></tr>
<tr><td><code id="calculateWeightsPLS_+3A_.pls_weight_scheme_inner">.PLS_weight_scheme_inner</code></td>
<td>
<p>Character string. The inner weighting scheme
used by PLS-PM. One of: &quot;<em>centroid</em>&quot;, &quot;<em>factorial</em>&quot;, or &quot;<em>path</em>&quot;.
Defaults to &quot;<em>path</em>&quot;. Ignored if <code>.approach_weight</code> is not PLS-PM.</p>
</td></tr>
<tr><td><code id="calculateWeightsPLS_+3A_.starting_values">.starting_values</code></td>
<td>
<p>A named list of vectors where the
list names are the construct names whose indicator weights the user
wishes to set. The vectors must be named vectors of <code>"indicator_name" = value</code>
pairs, where <code>value</code> is the (scaled or unscaled) starting weight. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="calculateWeightsPLS_+3A_.tolerance">.tolerance</code></td>
<td>
<p>Double. The tolerance criterion for convergence.
Defaults to <code>1e-05</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list. J stands for the number of constructs and K for the number
of indicators.
</p>

<dl>
<dt><code style="white-space: pre;">&#8288;$W&#8288;</code></dt><dd><p>A (J x K) matrix of estimated weights.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$E&#8288;</code></dt><dd><p>A (J x J) matrix of inner weights.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$Modes&#8288;</code></dt><dd><p>A named vector of modes used for the outer estimation.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$Conv_status&#8288;</code></dt><dd><p>The convergence status. <code>TRUE</code> if the algorithm has converged
and <code>FALSE</code> otherwise. If one-step weights are used via <code>.iter_max = 1</code>
or a non-iterative procedure was used, the convergence status is set to <code>NULL</code>.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$Iterations&#8288;</code></dt><dd><p>The number of iterations required.</p>
</dd>
</dl>



<h3>References</h3>

<p>Wold H (1975).
&ldquo;Path models with latent variables: The NIPALS approach.&rdquo;
In Blalock HM, Aganbegian A, Borodkin FM, Boudon R, Capecchi V (eds.), <em>Quantitative Sociology</em>,  International Perspectives on Mathematical and Statistical Modeling, 307&ndash;357.
Academic Press, New York.
</p>

<hr>
<h2 id='calculateWeightsUnit'>Calculate composite weights using unit weights</h2><span id='topic+calculateWeightsUnit'></span>

<h3>Description</h3>

<p>Calculate unit weights for all blocks, i.e., each indicator of a block is
equally weighted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateWeightsUnit(
 .S                 = args_default()$.S,
 .csem_model        = args_default()$.csem_model,
 .starting_values   = args_default()$.starting_values
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculateWeightsUnit_+3A_.s">.S</code></td>
<td>
<p>The (K x K) empirical indicator correlation matrix.</p>
</td></tr>
<tr><td><code id="calculateWeightsUnit_+3A_.csem_model">.csem_model</code></td>
<td>
<p>A (possibly incomplete) <a href="#topic+cSEMModel">cSEMModel</a>-list.</p>
</td></tr>
<tr><td><code id="calculateWeightsUnit_+3A_.starting_values">.starting_values</code></td>
<td>
<p>A named list of vectors where the
list names are the construct names whose indicator weights the user
wishes to set. The vectors must be named vectors of <code>"indicator_name" = value</code>
pairs, where <code>value</code> is the (scaled or unscaled) starting weight. Defaults to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list. J stands for the number of constructs and K for the number
of indicators.
</p>

<dl>
<dt><code style="white-space: pre;">&#8288;$W&#8288;</code></dt><dd><p>A (J x K) matrix of estimated weights.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$E&#8288;</code></dt><dd><p><code>NULL</code></p>
</dd>
<dt><code style="white-space: pre;">&#8288;$Modes&#8288;</code></dt><dd><p>The mode used. Always &quot;unit&quot;.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$Conv_status&#8288;</code></dt><dd><p><code>NULL</code> as there are no iterations</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$Iterations&#8288;</code></dt><dd><p>0 as there are no iterations</p>
</dd>
</dl>


<hr>
<h2 id='checkConvergence'>Internal: Check convergence</h2><span id='topic+checkConvergence'></span>

<h3>Description</h3>

<p>Check convergence of an algorithm using one of the following criteria:
</p>

<dl>
<dt><code>diff_absolute</code></dt><dd><p>Checks if the largest elementwise absolute difference
between two matrices <code>.W_new</code> and <code>W.old</code> is
smaller than a given tolerance.</p>
</dd>
<dt><code>diff_squared</code></dt><dd><p>Checks if the largest elementwise squared difference
between two matrices <code>.W_new</code> and <code>W.old</code> is
smaller than a given tolerance.</p>
</dd>
<dt><code>diff_relative</code></dt><dd><p>Checks if the largest elementwise absolute rate of change
(new - old / new) for two matrices <code>.W_new</code>
and <code>W.old</code> is smaller than a given tolerance.</p>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>checkConvergence(
  .W_new          = args_default()$.W_new,
  .W_old          = args_default()$.W_old,
  .conv_criterion = args_default()$.conv_criterion,
  .tolerance      = args_default()$.tolerance
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkConvergence_+3A_.w_new">.W_new</code></td>
<td>
<p>A (J x K) matrix of weights.</p>
</td></tr>
<tr><td><code id="checkConvergence_+3A_.w_old">.W_old</code></td>
<td>
<p>A (J x K) matrix of weights.</p>
</td></tr>
<tr><td><code id="checkConvergence_+3A_.conv_criterion">.conv_criterion</code></td>
<td>
<p>Character string. The criterion to use for the convergence check.
One of: &quot;<em>diff_absolute</em>&quot;, &quot;<em>diff_squared</em>&quot;, or &quot;<em>diff_relative</em>&quot;. Defaults
to &quot;<em>diff_absolute</em>&quot;.</p>
</td></tr>
<tr><td><code id="checkConvergence_+3A_.tolerance">.tolerance</code></td>
<td>
<p>Double. The tolerance criterion for convergence.
Defaults to <code>1e-05</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if converged; <code>FALSE</code> otherwise.
</p>

<hr>
<h2 id='classifyConstructs'>Internal: Classify structural model terms by type</h2><span id='topic+classifyConstructs'></span>

<h3>Description</h3>

<p>Classify terms of the structural model according to their type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classifyConstructs(.terms = args_default()$.terms)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="classifyConstructs_+3A_.terms">.terms</code></td>
<td>
<p>A vector of construct names to be classified.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Classification is required to estimate nonlinear structural relationships.
Currently the following terms are supported
</p>

<ul>
<li><p> Single, e.g., <code>eta1</code>
</p>
</li>
<li><p> Quadratic, e.g., <code>eta1.eta1</code>
</p>
</li>
<li><p> Cubic, e.g., <code>eta1.eta1.eta1</code>
</p>
</li>
<li><p> Two-way interaction, e.g., <code>eta1.eta2</code>
</p>
</li>
<li><p> Three-way interaction, e.g., <code>eta1.eta2.eta3</code>
</p>
</li>
<li><p> Quadratic and two-way interaction, e.g., <code>eta1.eta1.eta3</code>
</p>
</li></ul>

<p>Note that exponential terms are modeled as &quot;interactions with itself&quot;
as in i.e., <code>eta1^3 = eta1.eta1.eta1</code>.
</p>


<h3>Value</h3>

<p>A named list of length equal to the number of terms provided containing
a data frame with columns &quot;<em>Term_class</em>&quot;, &quot;<em>Component</em>&quot;,
&quot;<em>Component_type</em>&quot;, and &quot;<em>Component_freq</em>&quot;.
</p>

<hr>
<h2 id='convertModel'>Internal: Convert second order cSEMModel</h2><span id='topic+convertModel'></span>

<h3>Description</h3>

<p>Uses a <a href="#topic+cSEMModel">cSEMModel</a> containing second order constructs and turns it into an
estimable model using either the &quot;2stage&quot; approach or the &quot;mixed&quot; approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convertModel(
 .csem_model        = NULL, 
 .approach_2ndorder = "2stage",
 .stage             = "first"
 )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convertModel_+3A_.csem_model">.csem_model</code></td>
<td>
<p>A (possibly incomplete) <a href="#topic+cSEMModel">cSEMModel</a>-list.</p>
</td></tr>
<tr><td><code id="convertModel_+3A_.approach_2ndorder">.approach_2ndorder</code></td>
<td>
<p>Character string. Approach used for models containing
second-order constructs. One of: &quot;<em>2stage</em>&quot;, or &quot;<em>mixed</em>&quot;. Defaults to &quot;<em>2stage</em>&quot;.</p>
</td></tr>
<tr><td><code id="convertModel_+3A_.stage">.stage</code></td>
<td>
<p>Character string. The stage the model is needed for.
One of &quot;<em>first</em>&quot; or &quot;<em>second</em>&quot;. Defaults to &quot;<em>first</em>&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+cSEMModel">cSEMModel</a> list that may be passed to any function requiring
<code>.csem_model</code> as a mandatory argument.
</p>

<hr>
<h2 id='csem'>Composite-based SEM</h2><span id='topic+csem'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>csem(
.data                  = NULL,
.model                 = NULL,
.approach_2ndorder     = c("2stage", "mixed"),
.approach_cor_robust   = c("none", "mcd", "spearman"),
.approach_nl           = c("sequential", "replace"),
.approach_paths        = c("OLS", "2SLS"),
.approach_weights      = c("PLS-PM", "SUMCORR", "MAXVAR", "SSQCORR", 
                           "MINVAR", "GENVAR","GSCA", "PCA",
                           "unit", "bartlett", "regression"),
.conv_criterion        = c("diff_absolute", "diff_squared", "diff_relative"),
.disattenuate          = TRUE,
.dominant_indicators   = NULL,
.estimate_structural   = TRUE,
.id                    = NULL,
.instruments           = NULL,
.iter_max              = 100,
.normality             = FALSE,
.PLS_approach_cf       = c("dist_squared_euclid", "dist_euclid_weighted", 
                           "fisher_transformed", "mean_arithmetic",
                           "mean_geometric", "mean_harmonic",
                           "geo_of_harmonic"),
.PLS_ignore_structural_model = FALSE,
.PLS_modes                   = NULL,
.PLS_weight_scheme_inner     = c("path", "centroid", "factorial"),
.reliabilities         = NULL,
.starting_values       = NULL,
.resample_method       = c("none", "bootstrap", "jackknife"),
.resample_method2      = c("none", "bootstrap", "jackknife"),
.R                     = 499,
.R2                    = 199,
.handle_inadmissibles  = c("drop", "ignore", "replace"),
.user_funs             = NULL,
.eval_plan             = c("sequential", "multicore", "multisession"),
.seed                  = NULL,
.sign_change_option    = c("none", "individual", "individual_reestimate", 
                           "construct_reestimate"),
.tolerance             = 1e-05
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="csem_+3A_.data">.data</code></td>
<td>
<p>A <code>data.frame</code> or a <code>matrix</code> of standardized or unstandardized
data (indicators/items/manifest variables).
Additionally, a <code>list</code> of data sets (data frames or matrices) is accepted in which
case estimation is repeated for each data set. Possible column types or classes
of the data provided are: &quot;<code>logical</code>&quot;, &quot;<code>numeric</code>&quot; (&quot;<code>double</code>&quot; or &quot;<code>integer</code>&quot;),
&quot;<code>factor</code>&quot; (&quot;<code>ordered</code>&quot; and/or &quot;<code>unordered</code>&quot;), &quot;<code>character</code>&quot; (will be converted to factor),
or a mix of several types.</p>
</td></tr>
<tr><td><code id="csem_+3A_.model">.model</code></td>
<td>
<p>A model in <a href="lavaan.html#topic+model.syntax">lavaan model syntax</a>
or a <a href="#topic+cSEMModel">cSEMModel</a> list.</p>
</td></tr>
<tr><td><code id="csem_+3A_.approach_2ndorder">.approach_2ndorder</code></td>
<td>
<p>Character string. Approach used for models containing
second-order constructs. One of: &quot;<em>2stage</em>&quot;, or &quot;<em>mixed</em>&quot;. Defaults to &quot;<em>2stage</em>&quot;.</p>
</td></tr>
<tr><td><code id="csem_+3A_.approach_cor_robust">.approach_cor_robust</code></td>
<td>
<p>Character string. Approach used to obtain a robust
indicator correlation matrix. One of: &quot;<em>none</em>&quot; in which case the standard
Bravais-Pearson correlation is used,
&quot;<em>spearman</em>&quot; for the Spearman rank correlation, or
&quot;<em>mcd</em>&quot; via <code><a href="MASS.html#topic+cov.rob">MASS::cov.rob()</a></code> for a robust correlation matrix.
Defaults to &quot;<em>none</em>&quot;. Note that many postestimation procedures (such as
<code><a href="#topic+testOMF">testOMF()</a></code> or <code><a href="#topic+fit">fit()</a></code> implicitly assume a continuous
indicator correlation matrix (e.g. Bravais-Pearson correlation matrix).
Only use if you know what you are doing.</p>
</td></tr>
<tr><td><code id="csem_+3A_.approach_nl">.approach_nl</code></td>
<td>
<p>Character string. Approach used to estimate nonlinear
structural relationships. One of: &quot;<em>sequential</em>&quot; or &quot;<em>replace</em>&quot;.
Defaults to &quot;<em>sequential</em>&quot;.</p>
</td></tr>
<tr><td><code id="csem_+3A_.approach_paths">.approach_paths</code></td>
<td>
<p>Character string. Approach used to estimate the
structural coefficients. One of: &quot;<em>OLS</em>&quot; or &quot;<em>2SLS</em>&quot;. If &quot;<em>2SLS</em>&quot;, instruments
need to be supplied to <code>.instruments</code>. Defaults to &quot;<em>OLS</em>&quot;.</p>
</td></tr>
<tr><td><code id="csem_+3A_.approach_weights">.approach_weights</code></td>
<td>
<p>Character string. Approach used to
obtain composite weights. One of: &quot;<em>PLS-PM</em>&quot;, &quot;<em>SUMCORR</em>&quot;, &quot;<em>MAXVAR</em>&quot;,
&quot;<em>SSQCORR</em>&quot;, &quot;<em>MINVAR</em>&quot;, &quot;<em>GENVAR</em>&quot;, &quot;<em>GSCA</em>&quot;, &quot;<em>PCA</em>&quot;, &quot;<em>unit</em>&quot;, &quot;<em>bartlett</em>&quot;,
or &quot;<em>regression</em>&quot;. Defaults to &quot;<em>PLS-PM</em>&quot;.</p>
</td></tr>
<tr><td><code id="csem_+3A_.conv_criterion">.conv_criterion</code></td>
<td>
<p>Character string. The criterion to use for the convergence check.
One of: &quot;<em>diff_absolute</em>&quot;, &quot;<em>diff_squared</em>&quot;, or &quot;<em>diff_relative</em>&quot;. Defaults
to &quot;<em>diff_absolute</em>&quot;.</p>
</td></tr>
<tr><td><code id="csem_+3A_.disattenuate">.disattenuate</code></td>
<td>
<p>Logical. Should composite/proxy correlations
be disattenuated to yield consistent loadings and path estimates if at least
one of the construct is modeled as a common factor? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="csem_+3A_.dominant_indicators">.dominant_indicators</code></td>
<td>
<p>A character vector of <code>"construct_name" = "indicator_name"</code> pairs,
where <code>"indicator_name"</code> is a character string giving the name of the dominant indicator
and <code>"construct_name"</code> a character string of the corresponding construct name.
Dominant indicators may be specified for a subset of the constructs.
Default to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="csem_+3A_.estimate_structural">.estimate_structural</code></td>
<td>
<p>Logical. Should the structural coefficients
be estimated? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="csem_+3A_.id">.id</code></td>
<td>
<p>Character string or integer. A character string giving the name or
an integer of the position of the column of <code>.data</code> whose levels are used
to split <code>.data</code> into groups. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="csem_+3A_.instruments">.instruments</code></td>
<td>
<p>A named list of vectors of instruments. The names
of the list elements are the names of the dependent (LHS) constructs of the structural
equation whose explanatory variables are endogenous. The vectors
contain the names of the instruments corresponding to each equation. Note
that exogenous variables of a given equation <strong>must</strong> be supplied as
instruments for themselves. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="csem_+3A_.iter_max">.iter_max</code></td>
<td>
<p>Integer. The maximum number of iterations allowed.
If <code>iter_max = 1</code> and <code>.approach_weights = "PLS-PM"</code> one-step weights are returned.
If the algorithm exceeds the specified number, weights of iteration step
<code>.iter_max - 1</code>  will be returned with a warning. Defaults to <code>100</code>.</p>
</td></tr>
<tr><td><code id="csem_+3A_.normality">.normality</code></td>
<td>
<p>Logical. Should joint normality of
<code class="reqn">[\eta_{1:p}; \zeta; \epsilon]</code>
be assumed in the nonlinear model? See (Dijkstra and Schermelleh-Engel 2014) for details.
Defaults to <code>FALSE</code>. Ignored if the model is not nonlinear.</p>
</td></tr>
<tr><td><code id="csem_+3A_.pls_approach_cf">.PLS_approach_cf</code></td>
<td>
<p>Character string. Approach used to obtain the correction
factors for PLSc. One of: &quot;<em>dist_squared_euclid</em>&quot;, &quot;<em>dist_euclid_weighted</em>&quot;,
&quot;<em>fisher_transformed</em>&quot;, &quot;<em>mean_arithmetic</em>&quot;, &quot;<em>mean_geometric</em>&quot;, &quot;<em>mean_harmonic</em>&quot;,
&quot;<em>geo_of_harmonic</em>&quot;. Defaults to &quot;<em>dist_squared_euclid</em>&quot;.
Ignored if <code>.disattenuate = FALSE</code> or if <code>.approach_weights</code> is not PLS-PM.</p>
</td></tr>
<tr><td><code id="csem_+3A_.pls_ignore_structural_model">.PLS_ignore_structural_model</code></td>
<td>
<p>Logical. Should the structural model be ignored
when calculating the inner weights of the PLS-PM algorithm? Defaults to <code>FALSE</code>.
Ignored if <code>.approach_weights</code> is not PLS-PM.</p>
</td></tr>
<tr><td><code id="csem_+3A_.pls_modes">.PLS_modes</code></td>
<td>
<p>Either a named list specifying the mode that should be used for
each construct in the form <code>"construct_name" = mode</code>, a single character
string giving the mode that should be used for all constructs, or <code>NULL</code>.
Possible choices for <code>mode</code> are: &quot;<em>modeA</em>&quot;, &quot;<em>modeB</em>&quot;, &quot;<em>modeBNNLS</em>&quot;,
&quot;<em>unit</em>&quot;, &quot;<em>PCA</em>&quot;, a single integer or
a vector of fixed weights of the same length as there are indicators for the
construct given by <code>"construct_name"</code>. If only a single number is provided this is identical to
using unit weights, as weights are rescaled such that the related composite
has unit variance.  Defaults to <code>NULL</code>.
If <code>NULL</code> the appropriate mode according to the type
of construct used is chosen. Ignored if <code>.approach_weight</code> is not PLS-PM.</p>
</td></tr>
<tr><td><code id="csem_+3A_.pls_weight_scheme_inner">.PLS_weight_scheme_inner</code></td>
<td>
<p>Character string. The inner weighting scheme
used by PLS-PM. One of: &quot;<em>centroid</em>&quot;, &quot;<em>factorial</em>&quot;, or &quot;<em>path</em>&quot;.
Defaults to &quot;<em>path</em>&quot;. Ignored if <code>.approach_weight</code> is not PLS-PM.</p>
</td></tr>
<tr><td><code id="csem_+3A_.reliabilities">.reliabilities</code></td>
<td>
<p>A character vector of <code>"name" = value</code> pairs,
where <code>value</code> is a number between 0 and 1 and <code>"name"</code> a character string
of the corresponding construct name, or <code>NULL</code>. Reliabilities
may be given for a subset of the constructs. Defaults to <code>NULL</code> in which case
reliabilities are estimated by <code>csem()</code>. Currently, only supported for
<code>.approach_weights = "PLS-PM"</code>.</p>
</td></tr>
<tr><td><code id="csem_+3A_.starting_values">.starting_values</code></td>
<td>
<p>A named list of vectors where the
list names are the construct names whose indicator weights the user
wishes to set. The vectors must be named vectors of <code>"indicator_name" = value</code>
pairs, where <code>value</code> is the (scaled or unscaled) starting weight. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="csem_+3A_.resample_method">.resample_method</code></td>
<td>
<p>Character string. The resampling method to use. One of:
&quot;<em>none</em>&quot;, &quot;<em>bootstrap</em>&quot; or &quot;<em>jackknife</em>&quot;. Defaults to &quot;<em>none</em>&quot;.</p>
</td></tr>
<tr><td><code id="csem_+3A_.resample_method2">.resample_method2</code></td>
<td>
<p>Character string. The resampling method to use when resampling
from a resample. One of: &quot;<em>none</em>&quot;, &quot;<em>bootstrap</em>&quot; or &quot;<em>jackknife</em>&quot;. For
&quot;<em>bootstrap</em>&quot; the number of draws is provided via <code>.R2</code>. Currently,
resampling from each resample is only required for the studentized confidence
interval (&quot;<em>CI_t_interval</em>&quot;) computed by the <code><a href="#topic+infer">infer()</a></code> function. Defaults to &quot;<em>none</em>&quot;.</p>
</td></tr>
<tr><td><code id="csem_+3A_.r">.R</code></td>
<td>
<p>Integer. The number of bootstrap replications. Defaults to <code>499</code>.</p>
</td></tr>
<tr><td><code id="csem_+3A_.r2">.R2</code></td>
<td>
<p>Integer. The number of bootstrap replications to use when
resampling from a resample. Defaults to <code>199</code>.</p>
</td></tr>
<tr><td><code id="csem_+3A_.handle_inadmissibles">.handle_inadmissibles</code></td>
<td>
<p>Character string. How should inadmissible results
be treated? One of &quot;<em>drop</em>&quot;, &quot;<em>ignore</em>&quot;, or &quot;<em>replace</em>&quot;. If &quot;<em>drop</em>&quot;, all
replications/resamples yielding an inadmissible result will be dropped
(i.e. the number of results returned will potentially be less than <code>.R</code>).
For &quot;<em>ignore</em>&quot; all results are returned even if all or some of the replications
yielded inadmissible results (i.e. number of results returned is equal to <code>.R</code>).
For &quot;<em>replace</em>&quot; resampling continues until there are exactly <code>.R</code> admissible solutions.
Depending on the frequency of inadmissible solutions this may significantly increase
computing time. Defaults to &quot;<em>drop</em>&quot;.</p>
</td></tr>
<tr><td><code id="csem_+3A_.user_funs">.user_funs</code></td>
<td>
<p>A function or a (named) list of functions to apply to every
resample. The functions must take <code>.object</code> as its first argument (e.g.,
<code style="white-space: pre;">&#8288;myFun &lt;- function(.object, ...) {body-of-the-function}&#8288;</code>).
Function output should preferably be a (named)
vector but matrices are also accepted. However, the output will be
vectorized (columnwise) in this case. See the examples section for details.</p>
</td></tr>
<tr><td><code id="csem_+3A_.eval_plan">.eval_plan</code></td>
<td>
<p>Character string. The evaluation plan to use. One of
&quot;<em>sequential</em>&quot;, &quot;<em>multicore</em>&quot;, or &quot;<em>multisession</em>&quot;. In the two latter cases
all available cores will be used. Defaults to &quot;<em>sequential</em>&quot;.</p>
</td></tr>
<tr><td><code id="csem_+3A_.seed">.seed</code></td>
<td>
<p>Integer or <code>NULL</code>. The random seed to use. Defaults to <code>NULL</code> in which
case an arbitrary seed is chosen. Note that the scope of the seed is limited
to the body of the function it is used in. Hence, the global seed will
not be altered!</p>
</td></tr>
<tr><td><code id="csem_+3A_.sign_change_option">.sign_change_option</code></td>
<td>
<p>Character string. Which sign change option should
be used to handle flipping signs when resampling? One of &quot;<em>none</em>&quot;,&quot;<em>individual</em>&quot;,
&quot;<em>individual_reestimate</em>&quot;, &quot;<em>construct_reestimate</em>&quot;. Defaults to &quot;<em>none</em>&quot;.</p>
</td></tr>
<tr><td><code id="csem_+3A_.tolerance">.tolerance</code></td>
<td>
<p>Double. The tolerance criterion for convergence.
Defaults to <code>1e-05</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimate linear, nonlinear, hierarchical or multigroup structural equation
models using a composite-based approach. In <span class="pkg">cSEM</span>
any method or approach that involves linear compounds (scores/proxies/composites)
of observables (indicators/items/manifest variables) is defined as composite-based.
See the <a href="https://m-e-rademaker.github.io/cSEM/articles/cSEM.html">Get started</a>
section of the <a href="https://m-e-rademaker.github.io/cSEM/index.html">cSEM website</a>
for a general introduction to composite-based SEM and <span class="pkg">cSEM</span>.
</p>
<p><code>csem()</code> estimates linear, nonlinear, hierarchical  or multigroup structural
equation models using a composite-based approach.
</p>


<h4>Data and model:</h4>

<p>The <code>.data</code> and <code>.model</code> arguments are required. <code>.data</code> must be given
a <code>matrix</code> or a <code>data.frame</code> with column names matching
the indicator names used in the model description. Alternatively,
a <code>list</code> of data sets (matrices or data frames) may be provided
in which case estimation is repeated for each data set.
Possible column types/classes of the data provided are: &quot;<code>logical</code>&quot;,
&quot;<code>numeric</code>&quot; (&quot;<code>double</code>&quot; or &quot;<code>integer</code>&quot;), &quot;<code>factor</code>&quot; (&quot;<code>ordered</code>&quot; and/or &quot;<code>unordered</code>&quot;),
&quot;<code>character</code>&quot;, or a mix of several types. Character columns will be treated
as (unordered) factors.
</p>
<p>Depending on the type/class of the indicator data provided cSEM computes the indicator
correlation matrix in different ways. See <code><a href="#topic+calculateIndicatorCor">calculateIndicatorCor()</a></code> for details.
</p>
<p>In the current version <code>.data</code> must not contain missing values. Future versions
are likely to handle missing values as well.
</p>
<p>To provide a model use the <a href="lavaan.html#topic+model.syntax">lavaan model syntax</a>.
Note, however, that <span class="pkg">cSEM</span> currently only supports the &quot;standard&quot; lavaan
model syntax (Types 1, 2, 3, and 7 as described on the help page).
Therefore, specifying e.g., a threshold or scaling factors is ignored.
Alternatively, a standardized (possibly incomplete) <a href="#topic+cSEMModel">cSEMModel</a>-list may be supplied.
See <code><a href="#topic+parseModel">parseModel()</a></code> for details.
</p>



<h4>Weights and path coefficients:</h4>

<p>By default weights are estimated using the partial least squares path modeling
algorithm (<code>"PLS-PM"</code>).
A range of alternative weighting algorithms may be supplied to
<code>.approach_weights</code>. Currently, the following approaches are implemented
</p>

<ol>
<li><p>(Default) Partial least squares path modeling (<code>"PLS-PM"</code>). The algorithm
can be customized. See <code><a href="#topic+calculateWeightsPLS">calculateWeightsPLS()</a></code> for details.
</p>
</li>
<li><p>Generalized structured component analysis (<code>"GSCA"</code>) and generalized
structured component analysis with uniqueness terms (GSCAm). The algorithms
can be customized. See <code><a href="#topic+calculateWeightsGSCA">calculateWeightsGSCA()</a></code> and <code><a href="#topic+calculateWeightsGSCAm">calculateWeightsGSCAm()</a></code> for details.
Note that GSCAm is called indirectly when the model contains constructs
modeled as common factors only and <code>.disattenuate = TRUE</code>. See below.
</p>
</li>
<li><p>Generalized canonical correlation analysis (<em>GCCA</em>), including
<code>"SUMCORR"</code>, <code>"MAXVAR"</code>, <code>"SSQCORR"</code>, <code>"MINVAR"</code>, <code>"GENVAR"</code>.
</p>
</li>
<li><p>Principal component analysis (<code>"PCA"</code>)
</p>
</li>
<li><p>Factor score regression using sum scores (<code>"unit"</code>),
regression (<code>"regression"</code>) or bartlett scores (<code>"bartlett"</code>)
</p>
</li></ol>

<p>It is possible to supply starting values for the weighting algorithm
via <code>.starting_values</code>. The argument accepts a named list of vectors where the
list names are the construct names whose indicator weights the user
wishes to set. The vectors must be named vectors of <code>"indicator_name" = value</code>
pairs, where <code>value</code> is the starting weight. See the examples section below for details.
</p>
<p>Composite-indicator and composite-composite correlations are properly
disattenuated by default to yield consistent loadings, construct correlations,
and path coefficients if any of the concepts are modeled as a
common factor.
</p>
<p>For <em>PLS-PM</em> disattenuation is done using <em>PLSc</em> (Dijkstra and Henseler 2015).
For <em>GSCA</em> disattenuation is done implicitly by using <em>GSCAm</em> (Hwang et al. 2017).
Weights obtained by <em>GCCA</em>, <em>unit</em>, <em>regression</em>, <em>bartlett</em> or <em>PCA</em> are
disattenuated using Croon's approach (Croon 2002).
Disattenuation my be suppressed by setting <code>.disattenuate = FALSE</code>.
Note, however, that quantities in this case are inconsistent
estimates for their construct level counterparts if any of the constructs in
the structural model are modeled as a common factor!
</p>
<p>By default path coefficients are estimated using ordinary least squares (<code>.approach_path = "OLS"</code>).
For linear models, two-stage least squares (<code>"2SLS"</code>) is available, however, <em>only if</em>
<em>instruments are internal</em>, i.e., part of the structural model. Future versions
will add support for external instruments if possible. Instruments must be supplied to
<code>.instruments</code> as a named list where the names
of the list elements are the names of the dependent constructs of the structural
equations whose explanatory variables are believed to be endogenous.
The list consists of vectors of names of instruments corresponding to each equation.
Note that exogenous variables of a given equation <strong>must</strong> be supplied as
instruments for themselves.
</p>
<p>If reliabilities are known they can be supplied as <code>"name" = value</code> pairs to
<code>.reliabilities</code>, where <code>value</code> is a numeric value between 0 and 1.
Currently, only supported for &quot;PLS-PM&quot;.
</p>



<h4>Nonlinear models:</h4>

<p>If the model contains nonlinear terms <code>csem()</code> estimates a polynomial structural equation model
using a non-iterative method of moments approach described in
Dijkstra and Schermelleh-Engel (2014). Nonlinear terms include interactions and
exponential terms. The latter is described in model syntax as an
&quot;interaction with itself&quot;, e.g., <code>xi^3 = xi.xi.xi</code>. Currently only exponential
terms up to a power of three (e.g., three-way interactions or cubic terms) are allowed:
</p>

<ol>
<li><p>- Single, e.g., <code>eta1</code>
</p>
</li>
<li><p>- Quadratic, e.g., <code>eta1.eta1</code>
</p>
</li>
<li><p>- Cubic, e.g., <code>eta1.eta1.eta1</code>
</p>
</li>
<li><p>- Two-way interaction, e.g., <code>eta1.eta2</code>
</p>
</li>
<li><p>- Three-way interaction, e.g., <code>eta1.eta2.eta3</code>
</p>
</li>
<li><p>- Quadratic and two-way interaction, e.g., <code>eta1.eta1.eta3</code>
</p>
</li></ol>

<p>The current version of the package allows two kinds of estimation:
estimation of the reduced form equation (<code>.approach_nl = "replace"</code>) and
sequential estimation (<code>.approach_nl = "sequential"</code>, the default). The latter does not
allow for multivariate normality of all exogenous variables, i.e.,
the latent variables and the error terms.
</p>
<p>Distributional assumptions are kept to a minimum (an i.i.d. sample from a
population with finite moments for the relevant order); for higher order models,
that go beyond interaction, we work in this version with the assumption that
as far as the relevant moments are concerned certain combinations of
measurement errors behave as if they were Gaussian.
For details see: Dijkstra and Schermelleh-Engel (2014).
</p>



<h4>Models containing second-order constructs</h4>

<p>Second-order constructs are specified using the operators <code style="white-space: pre;">&#8288;=~&#8288;</code> and <code style="white-space: pre;">&#8288;&lt;~&#8288;</code>. These
operators are usually used with indicators on their right-hand side. For
second-order constructs the right-hand side variables are constructs instead.
If c1, and c2 are constructs forming or measuring a higher-order
construct, a model would look like this:
</p>
<pre>my_model &lt;- "
# Structural model
SAT  ~ QUAL
VAL  ~ SAT

# Measurement/composite model
QUAL =~ qual1 + qual2
SAT  =~ sat1 + sat2

c1 =~ x11 + x12
c2 =~ x21 + x22

# Second-order construct (in this case a second-order composite build by common
# factors)
VAL &lt;~ c1 + c2
"
</pre>
<p>Currently, two approaches are explicitly implemented:
</p>

<ul>
<li><p>(Default) <code>"2stage"</code>. The (disjoint) two-stage approach as proposed by Agarwal and Karahanna (2000).
Note that by default a correction for attenuation is applied if common factors are
involved in modeling second-order constructs. For instance, the three-stage approach
proposed by Van Riel et al. (2017) is applied in case of a second-order construct specified as a
composite of common factors. On the other hand, if no common factors are involved the two-stage approach
is applied as proposed by Schuberth et al. (2020).
</p>
</li>
<li><p><code>"mixed"</code>. The mixed repeated indicators/two-stage approach as proposed by Ringle et al. (2012).
</p>
</li></ul>

<p>The repeated indicators approach as proposed by Joereskog and Wold (1982)
and the extension proposed by Becker et al. (2012) are
not directly implemented as they simply require a respecification  of the model.
In the above example the repeated indicators approach
would require to change the model and to append the repeated indicators to
the data supplied to <code>.data</code>. Note that the indicators need to be renamed in this case as
<code>csem()</code> does not allow for one indicator to be attached to multiple constructs.
</p>
<pre>my_model &lt;- "
# Structural model
SAT  ~ QUAL
VAL  ~ SAT

VAL ~ c1 + c2

# Measurement/composite model
QUAL =~ qual1 + qual2
SAT  =~ sat1 + sat2
VAL  =~ x11_temp + x12_temp + x21_temp + x22_temp

c1 =~ x11 + x12
c2 =~ x21 + x22
"
</pre>
<p>According to the extended approach indirect effects of <code>QUAL</code> on <code>VAL</code> via <code>c1</code>
and <code>c2</code> would have to be specified as well.
</p>



<h4>Multigroup analysis</h4>

<p>To perform a multigroup analysis provide either a list of data sets or one
data set containing a group-identifier-column whose column
name must be provided to <code>.id</code>. Values of this column are taken as levels of a
factor and are interpreted as group
identifiers. <code>csem()</code> will split the data by levels of that column and run
the estimation for each level separately. Note, the more levels
the group-identifier-column has, the more estimation runs are required.
This can considerably slow down estimation, especially if resampling is
requested. For the latter it will generally be faster to use
<code>.eval_plan = "multisession"</code> or <code>.eval_plan = "multicore"</code>.
</p>



<h4>Inference:</h4>

<p>Inference is done via resampling. See <code><a href="#topic+resamplecSEMResults">resamplecSEMResults()</a></code> and <code><a href="#topic+infer">infer()</a></code> for details.
</p>



<h3>Value</h3>

<p>An object of class <code>cSEMResults</code> with methods for all postestimation generics.
Technically, a call to <code><a href="#topic+csem">csem()</a></code> results in an object with at least
two class attributes. The first class attribute is always <code>cSEMResults</code>.
The second is one of <code>cSEMResults_default</code>, <code>cSEMResults_multi</code>, or
<code>cSEMResults_2ndorder</code> and depends on the estimated model and/or the type of
data provided to the <code>.model</code> and <code>.data</code> arguments. The third class attribute
<code>cSEMResults_resampled</code> is only added if resampling was conducted.
For a details see the <a href="#topic+cSEMResults">cSEMResults helpfile </a>.
</p>


<h3>Postestimation</h3>


<dl>
<dt><code><a href="#topic+assess">assess()</a></code></dt><dd><p>Assess results using common quality criteria, e.g., reliability,
fit measures, HTMT, R2 etc.</p>
</dd>
<dt><code><a href="#topic+infer">infer()</a></code></dt><dd><p>Calculate common inferential quantities, e.g., standard errors,
confidence intervals.</p>
</dd>
<dt><code><a href="#topic+predict">predict()</a></code></dt><dd><p>Predict endogenous indicator scores and compute common prediction metrics.</p>
</dd>
<dt><code><a href="#topic+summarize">summarize()</a></code></dt><dd><p>Summarize the results. Mainly called for its side-effect the print method.</p>
</dd>
<dt><code><a href="#topic+verify">verify()</a></code></dt><dd><p>Verify/Check admissibility of the estimates.</p>
</dd>
</dl>

<p>Tests are performed using the test-family of functions. Currently the following
tests are implemented:
</p>

<dl>
<dt><code><a href="#topic+testOMF">testOMF()</a></code></dt><dd><p>Bootstrap-based test for overall model fit based on
Beran and Srivastava (1985)</p>
</dd>
<dt><code><a href="#topic+testMICOM">testMICOM()</a></code></dt><dd><p>Permutation-based test for measurement invariance of composites
proposed by Henseler et al. (2016)</p>
</dd>
<dt><code><a href="#topic+testMGD">testMGD()</a></code></dt><dd><p>Several (mainly) permutation-based tests for multi-group comparisons.</p>
</dd>
<dt><code><a href="#topic+testHausman">testHausman()</a></code></dt><dd><p>Regression-based Hausman test to test for endogeneity.</p>
</dd>
</dl>

<p>Other miscellaneous postestimation functions belong do the do-family of functions.
Currently three do functions are implemented:
</p>

<dl>
<dt><code><a href="#topic+doIPMA">doIPMA()</a></code></dt><dd><p>Performs an importance-performance matrix analyis (IPMA).</p>
</dd>
<dt><code><a href="#topic+doNonlinearEffectsAnalysis">doNonlinearEffectsAnalysis()</a></code></dt><dd><p>Perform a nonlinear effects analysis as
described in e.g.,
Spiller et al. (2013)</p>
</dd>
<dt><code><a href="#topic+doRedundancyAnalysis">doRedundancyAnalysis()</a></code></dt><dd><p>Perform a redundancy analysis (RA) as proposed by
Hair et al. (2016) with reference to Chin (1998)</p>
</dd>
</dl>



<h3>References</h3>

<p>Agarwal R, Karahanna E (2000).
&ldquo;Time Flies When You're Having Fun: Cognitive Absorption and Beliefs about Information Technology Usage.&rdquo;
<em>MIS Quarterly</em>, <b>24</b>(4), 665.<br /><br /> Becker J, Klein K, Wetzels M (2012).
&ldquo;Hierarchical Latent Variable Models in PLS-SEM: Guidelines for Using Reflective-Formative Type Models.&rdquo;
<em>Long Range Planning</em>, <b>45</b>(5-6), 359&ndash;394.
<a href="https://doi.org/10.1016/j.lrp.2012.10.001">doi:10.1016/j.lrp.2012.10.001</a>.<br /><br /> Beran R, Srivastava MS (1985).
&ldquo;Bootstrap Tests and Confidence Regions for Functions of a Covariance Matrix.&rdquo;
<em>The Annals of Statistics</em>, <b>13</b>(1), 95&ndash;115.
<a href="https://doi.org/10.1214/aos/1176346579">doi:10.1214/aos/1176346579</a>.<br /><br /> Chin WW (1998).
&ldquo;Modern Methods for Business Research.&rdquo;
In Marcoulides GA (ed.), chapter The Partial Least Squares Approach to Structural Equation Modeling, 295&ndash;358.
Mahwah, NJ: Lawrence Erlbaum.<br /><br /> Croon MA (2002).
&ldquo;Using predicted latent scores in general latent structure models.&rdquo;
In Marcoulides GA, Moustaki I (eds.), <em>Latent Variable and Latent Structure Models</em>, chapter 10, 195&ndash;224.
Lawrence Erlbaum.
ISBN 080584046X, Pagination: 288.<br /><br /> Dijkstra TK, Henseler J (2015).
&ldquo;Consistent and Asymptotically Normal PLS Estimators for Linear Structural Equations.&rdquo;
<em>Computational Statistics &amp; Data Analysis</em>, <b>81</b>, 10&ndash;23.<br /><br /> Dijkstra TK, Schermelleh-Engel K (2014).
&ldquo;Consistent Partial Least Squares For Nonlinear Structural Equation Models.&rdquo;
<em>Psychometrika</em>, <b>79</b>(4), 585&ndash;604.<br /><br /> Hair JF, Hult GTM, Ringle C, Sarstedt M (2016).
<em>A Primer on Partial Least Squares Structural Equation Modeling (PLS-SEM)</em>.
Sage publications.<br /><br /> Henseler J, Ringle CM, Sarstedt M (2016).
&ldquo;Testing Measurement Invariance of Composites Using Partial Least Squares.&rdquo;
<em>International Marketing Review</em>, <b>33</b>(3), 405&ndash;431.
<a href="https://doi.org/10.1108/imr-09-2014-0304">doi:10.1108/imr-09-2014-0304</a>.<br /><br /> Hwang H, Takane Y, Jung K (2017).
&ldquo;Generalized structured component analysis with uniqueness terms for accommodating measurement error.&rdquo;
<em>Frontiers in Psychology</em>, <b>8</b>(2137), 1&ndash;12.<br /><br /> Joereskog KG, Wold HO (1982).
<em>Systems under Indirect Observation: Causality, Structure, Prediction - Part II</em>, volume 139.
North Holland.<br /><br /> Ringle CM, Sarstedt M, Straub D (2012).
&ldquo;A Critical Look at the Use of PLS-SEM in MIS Quarterly.&rdquo;
<em>MIS Quarterly</em>, <b>36</b>(1), iii&ndash;xiv.<br /><br /> Schuberth F, Rademaker ME, Henseler J (2020).
&ldquo;Estimating and assessing second-order constructs using PLS-PM: the case of composites of composites.&rdquo;
<em>Industrial Management &amp; Data Systems</em>, <b>120</b>(12), 2211-2241.
<a href="https://doi.org/10.1108/imds-12-2019-0642">doi:10.1108/imds-12-2019-0642</a>.<br /><br /> Spiller SA, Fitzsimons GJ, Lynch JG, Mcclelland GH (2013).
&ldquo;Spotlights, Floodlights, and the Magic Number Zero: Simple Effects Tests in Moderated Regression.&rdquo;
<em>Journal of Marketing Research</em>, <b>50</b>(2), 277&ndash;288.
<a href="https://doi.org/10.1509/jmr.12.0420">doi:10.1509/jmr.12.0420</a>.<br /><br /> Van Riel ACR, Henseler J, Kemeny I, Sasovova Z (2017).
&ldquo;Estimating hierarchical constructs using Partial Least Squares: The case of second order composites of factors.&rdquo;
<em>Industrial Management &amp; Data Systems</em>, <b>117</b>(3), 459&ndash;477.
<a href="https://doi.org/10.1108/IMDS-07-2016-0286">doi:10.1108/IMDS-07-2016-0286</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+args_default">args_default()</a></code>, <a href="#topic+cSEMArguments">cSEMArguments</a>, <a href="#topic+cSEMResults">cSEMResults</a>, <code><a href="#topic+foreman">foreman()</a></code>, <code><a href="#topic+resamplecSEMResults">resamplecSEMResults()</a></code>,
<code><a href="#topic+assess">assess()</a></code>, <code><a href="#topic+infer">infer()</a></code>, <code><a href="#topic+predict">predict()</a></code>, <code><a href="#topic+summarize">summarize()</a></code>, <code><a href="#topic+verify">verify()</a></code>, <code><a href="#topic+testOMF">testOMF()</a></code>,
<code><a href="#topic+testMGD">testMGD()</a></code>, <code><a href="#topic+testMICOM">testMICOM()</a></code>, <code><a href="#topic+testHausman">testHausman()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># ===========================================================================
# Basic usage
# ===========================================================================
### Linear model ------------------------------------------------------------
# Most basic usage requires a dataset and a model. We use the 
#  `threecommonfactors` dataset. 

## Take a look at the dataset
#?threecommonfactors

## Specify the (correct) model
model &lt;- "
# Structural model
eta2 ~ eta1
eta3 ~ eta1 + eta2

# (Reflective) measurement model
eta1 =~ y11 + y12 + y13
eta2 =~ y21 + y22 + y23
eta3 =~ y31 + y32 + y33
"

## Estimate
res &lt;- csem(threecommonfactors, model)

## Postestimation
verify(res)
summarize(res)  
assess(res)

# Notes: 
#   1. By default no inferential quantities (e.g. Std. errors, p-values, or
#      confidence intervals) are calculated. Use resampling to obtain
#      inferential quantities. See "Resampling" in the "Extended usage"
#      section below.
#   2. `summarize()` prints the full output by default. For a more condensed
#       output use:
print(summarize(res), .full_output = FALSE)

## Dealing with endogeneity -------------------------------------------------

# See: ?testHausman()

### Models containing second constructs--------------------------------------
## Take a look at the dataset
#?dgp_2ndorder_cf_of_c

model &lt;- "
# Path model / Regressions 
c4   ~ eta1
eta2 ~ eta1 + c4

# Reflective measurement model
c1   &lt;~ y11 + y12 
c2   &lt;~ y21 + y22 + y23 + y24
c3   &lt;~ y31 + y32 + y33 + y34 + y35 + y36 + y37 + y38
eta1 =~ y41 + y42 + y43
eta2 =~ y51 + y52 + y53

# Composite model (second order)
c4   =~ c1 + c2 + c3
"

res_2stage &lt;- csem(dgp_2ndorder_cf_of_c, model, .approach_2ndorder = "2stage")
res_mixed  &lt;- csem(dgp_2ndorder_cf_of_c, model, .approach_2ndorder = "mixed")

# The standard repeated indicators approach is done by 1.) respecifying the model
# and 2.) adding the repeated indicators to the data set

# 1.) Respecify the model
model_RI &lt;- "
# Path model / Regressions 
c4   ~ eta1
eta2 ~ eta1 + c4
c4   ~ c1 + c2 + c3

# Reflective measurement model
c1   &lt;~ y11 + y12 
c2   &lt;~ y21 + y22 + y23 + y24
c3   &lt;~ y31 + y32 + y33 + y34 + y35 + y36 + y37 + y38
eta1 =~ y41 + y42 + y43
eta2 =~ y51 + y52 + y53

# c4 is a common factor measured by composites
c4 =~ y11_temp + y12_temp + y21_temp + y22_temp + y23_temp + y24_temp +
      y31_temp + y32_temp + y33_temp + y34_temp + y35_temp + y36_temp + 
      y37_temp + y38_temp
"

# 2.) Update data set
data_RI &lt;- dgp_2ndorder_cf_of_c
coln &lt;- c(colnames(data_RI), paste0(colnames(data_RI), "_temp"))
data_RI &lt;- data_RI[, c(1:ncol(data_RI), 1:ncol(data_RI))]
colnames(data_RI) &lt;- coln

# Estimate
res_RI &lt;- csem(data_RI, model_RI)
summarize(res_RI)

### Multigroup analysis -----------------------------------------------------

# See: ?testMGD()

# ===========================================================================
# Extended usage
# ===========================================================================
# `csem()` provides defaults for all arguments except `.data` and `.model`.
#   Below some common options/tasks that users are likely to be interested in.
#   We use the threecommonfactors data set again:

model &lt;- "
# Structural model
eta2 ~ eta1
eta3 ~ eta1 + eta2

# (Reflective) measurement model
eta1 =~ y11 + y12 + y13
eta2 =~ y21 + y22 + y23
eta3 =~ y31 + y32 + y33
"

### PLS vs PLSc and disattenuation
# In the model all concepts are modeled as common factors. If 
#   .approach_weights = "PLS-PM", csem() uses PLSc to disattenuate composite-indicator 
#   and composite-composite correlations.
res_plsc &lt;- csem(threecommonfactors, model, .approach_weights = "PLS-PM")
res$Information$Model$construct_type # all common factors

# To obtain "original" (inconsistent) PLS estimates use `.disattenuate = FALSE`
res_pls &lt;- csem(threecommonfactors, model, 
                .approach_weights = "PLS-PM",
                .disattenuate = FALSE
                )

s_plsc &lt;- summarize(res_plsc)
s_pls  &lt;- summarize(res_pls)

# Compare
data.frame(
  "Path"      = s_plsc$Estimates$Path_estimates$Name,
  "Pop_value" = c(0.6, 0.4, 0.35), # see ?threecommonfactors
  "PLSc"      = s_plsc$Estimates$Path_estimates$Estimate,
  "PLS"       = s_pls$Estimates$Path_estimates$Estimate
  )

### Resampling --------------------------------------------------------------
## Not run: 
## Basic resampling
res_boot &lt;- csem(threecommonfactors, model, .resample_method = "bootstrap")
res_jack &lt;- csem(threecommonfactors, model, .resample_method = "jackknife")

# See ?resamplecSEMResults for more examples

### Choosing a different weightning scheme ----------------------------------

res_gscam  &lt;- csem(threecommonfactors, model, .approach_weights = "GSCA")
res_gsca   &lt;- csem(threecommonfactors, model, 
                   .approach_weights = "GSCA",
                   .disattenuate = FALSE
)

s_gscam &lt;- summarize(res_gscam)
s_gsca  &lt;- summarize(res_gsca)

# Compare
data.frame(
  "Path"      = s_gscam$Estimates$Path_estimates$Name,
  "Pop_value" = c(0.6, 0.4, 0.35), # see ?threecommonfactors
  "GSCAm"      = s_gscam$Estimates$Path_estimates$Estimate,
  "GSCA"       = s_gsca$Estimates$Path_estimates$Estimate
)
## End(Not run)
### Fine-tuning a weighting scheme ------------------------------------------
## Setting starting values

sv &lt;- list("eta1" = c("y12" = 10, "y13" = 4, "y11" = 1))
res &lt;- csem(threecommonfactors, model, .starting_values = sv)

## Choosing a different inner weighting scheme 
#?args_csem_dotdotdot

res &lt;- csem(threecommonfactors, model, .PLS_weight_scheme_inner = "factorial",
            .PLS_ignore_structural_model = TRUE)


## Choosing different modes for PLS
# By default, concepts modeled as common factors uses PLS Mode A weights.
modes &lt;- list("eta1" = "unit", "eta2" = "modeB", "eta3" = "unit")
res   &lt;- csem(threecommonfactors, model, .PLS_modes = modes)
summarize(res) 
</code></pre>

<hr>
<h2 id='csem_arguments'>cSEMArguments</h2><span id='topic+csem_arguments'></span><span id='topic+cSEMArguments'></span>

<h3>Description</h3>

<p>An alphabetical list of all arguments used by functions of the <code>cSEM</code> package
including their description and defaults.
Mainly used for internal purposes (parameter inheritance). To list all arguments
and their defaults, use <code><a href="#topic+args_default">args_default()</a></code>. To list all arguments and
their possible choices, use <code>args_default(.choices = TRUE)</code>.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="csem_arguments_+3A_.alpha">.alpha</code></td>
<td>
<p>An integer or a numeric vector of significance levels.
Defaults to <code>0.05</code>.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.absolute">.absolute</code></td>
<td>
<p>Logical. Should the absolute HTMT values be returned?
Defaults to <code>TRUE</code> .</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.approach_gcca">.approach_gcca</code></td>
<td>
<p>Character string. The Kettenring approach to use for GCCA. One of
&quot;<em>SUMCORR</em>&quot;, &quot;<em>MAXVAR</em>&quot;, &quot;<em>SSQCORR</em>&quot;, &quot;<em>MINVAR</em>&quot; or &quot;<em>GENVAR</em>&quot;. Defaults to
&quot;<em>SUMCORR</em>&quot;.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.approach_2ndorder">.approach_2ndorder</code></td>
<td>
<p>Character string. Approach used for models containing
second-order constructs. One of: &quot;<em>2stage</em>&quot;, or &quot;<em>mixed</em>&quot;. Defaults to &quot;<em>2stage</em>&quot;.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.approach_alpha_adjust">.approach_alpha_adjust</code></td>
<td>
<p>Character string. Approach used to adjust the
significance level to accommodate multiple testing.
One of &quot;<em>none</em>&quot; or &quot;<em>bonferroni</em>&quot;. Defaults to &quot;<em>none</em>&quot;.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.approach_cor_robust">.approach_cor_robust</code></td>
<td>
<p>Character string. Approach used to obtain a robust
indicator correlation matrix. One of: &quot;<em>none</em>&quot; in which case the standard
Bravais-Pearson correlation is used,
&quot;<em>spearman</em>&quot; for the Spearman rank correlation, or
&quot;<em>mcd</em>&quot; via <code><a href="MASS.html#topic+cov.rob">MASS::cov.rob()</a></code> for a robust correlation matrix.
Defaults to &quot;<em>none</em>&quot;. Note that many postestimation procedures (such as
<code><a href="#topic+testOMF">testOMF()</a></code> or <code><a href="#topic+fit">fit()</a></code> implicitly assume a continuous
indicator correlation matrix (e.g. Bravais-Pearson correlation matrix).
Only use if you know what you are doing.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.approach_mgd">.approach_mgd</code></td>
<td>
<p>Character string or a vector of character strings.
Approach used for the multi-group comparison. One of: &quot;<em>all</em>&quot;, &quot;<em>Klesel</em>&quot;, &quot;<em>Chin</em>&quot;,
&quot;<em>Sarstedt</em>&quot;, &quot;<em>Keil</em>, &quot;<em>Nitzl</em>&quot;, &quot;<em>Henseler</em>&quot;, &quot;<em>CI_para</em>&quot;, or &quot;<em>CI_overlap</em>&quot;.
Default to &quot;<em>all</em>&quot; in which case all approaches are computed (if possible).</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.approach_nl">.approach_nl</code></td>
<td>
<p>Character string. Approach used to estimate nonlinear
structural relationships. One of: &quot;<em>sequential</em>&quot; or &quot;<em>replace</em>&quot;.
Defaults to &quot;<em>sequential</em>&quot;.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.approach_predict">.approach_predict</code></td>
<td>
<p>Character string. Which approach should be used to
predictions? One of &quot;<em>earliest</em>&quot; and &quot;<em>direct</em>&quot;. If &quot;<em>earliest</em>&quot; predictions
for indicators associated to endogenous constructs are performed using only
indicators associated to exogenous constructs. If &quot;<em>direct</em>&quot;, predictions for
indicators associated to endogenous constructs are based on indicators associated
to their direct antecedents. Defaults to &quot;<em>earliest</em>&quot;.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.approach_p_adjust">.approach_p_adjust</code></td>
<td>
<p>Character string or a vector of character strings.
Approach used to adjust the p-value for multiple testing.
See the <code>methods</code> argument of <code><a href="stats.html#topic+p.adjust">stats::p.adjust()</a></code> for a list of choices and
their description. Defaults to &quot;<em>none</em>&quot;.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.approach_paths">.approach_paths</code></td>
<td>
<p>Character string. Approach used to estimate the
structural coefficients. One of: &quot;<em>OLS</em>&quot; or &quot;<em>2SLS</em>&quot;. If &quot;<em>2SLS</em>&quot;, instruments
need to be supplied to <code>.instruments</code>. Defaults to &quot;<em>OLS</em>&quot;.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.approach_score_benchmark">.approach_score_benchmark</code></td>
<td>
<p>Character string. How should the aggregation
of the estimates of the truncated normal distribution be done for the
benchmark predictions? Ignored if not OrdPLS or OrdPLSc is used to obtain benchmark predictions.
One of &quot;<em>mean</em>&quot;, &quot;<em>median</em>&quot;, &quot;<em>mode</em>&quot; or &quot;<em>round</em>&quot;.
If &quot;<em>round</em>&quot;, the benchmark predictions are obtained using the traditional prediction
algorithm for PLS-PM which are rounded for categorical indicators.
If &quot;<em>mean</em>&quot;, the mean of the estimated endogenous indicators is calculated.
If &quot;<em>median</em>&quot;, the mean of the estimated endogenous indicators is calculated.
If &quot;<em>mode</em>&quot;, the maximum empirical density on the intervals defined by the thresholds
is used.
If <code>.treat_as_continuous = TRUE</code> or if all indicators are on a continuous scale,
<code>.approach_score_benchmark</code> is ignored. Defaults to &quot;<em>round</em>&quot;.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.approach_score_target">.approach_score_target</code></td>
<td>
<p>Character string. How should the aggregation of the estimates of
the truncated normal distribution for the predictions using OrdPLS/OrdPLSc be done?
One of &quot;<em>mean</em>&quot;, &quot;<em>median</em>&quot; or &quot;<em>mode</em>&quot;.
If &quot;<em>mean</em>&quot;, the mean of the estimated endogenous indicators is calculated.
If &quot;<em>median</em>&quot;, the mean of the estimated endogenous indicators is calculated.
If &quot;<em>mode</em>&quot;, the maximum empirical density on the intervals defined by the thresholds
is used. Defaults to &quot;<em>mean</em>&quot;.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.approach_weights">.approach_weights</code></td>
<td>
<p>Character string. Approach used to
obtain composite weights. One of: &quot;<em>PLS-PM</em>&quot;, &quot;<em>SUMCORR</em>&quot;, &quot;<em>MAXVAR</em>&quot;,
&quot;<em>SSQCORR</em>&quot;, &quot;<em>MINVAR</em>&quot;, &quot;<em>GENVAR</em>&quot;, &quot;<em>GSCA</em>&quot;, &quot;<em>PCA</em>&quot;, &quot;<em>unit</em>&quot;, &quot;<em>bartlett</em>&quot;,
or &quot;<em>regression</em>&quot;. Defaults to &quot;<em>PLS-PM</em>&quot;.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.args_used">.args_used</code></td>
<td>
<p>A list of function argument names whose value was modified
by the user.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.attrbutes">.attrbutes</code></td>
<td>
<p>Character string. Variables used as attributes in IPMA.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.benchmark">.benchmark</code></td>
<td>
<p>Character string. The procedure to obtain benchmark predictions.
One of &quot;<em>lm</em>&quot;, &quot;<em>unit</em>&quot;, &quot;<em>PLS-PM</em>&quot;, &quot;<em>GSCA</em>&quot;, &quot;<em>PCA</em>&quot;, &quot;<em>MAXVAR</em>&quot;, or &quot;<em>NA</em>&quot;.
Default to &quot;<em>lm</em>&quot;.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.bias_corrected">.bias_corrected</code></td>
<td>
<p>Logical. Should the standard and the tStat
confidence interval be bias-corrected using the bootstrapped bias estimate?
If <code>TRUE</code> the confidence interval for some estimated parameter <code>theta</code>
is centered at <code style="white-space: pre;">&#8288;2*theta - theta*_hat&#8288;</code>,
where <code style="white-space: pre;">&#8288;theta*_hat&#8288;</code> is the average over all <code>.R</code> bootstrap estimates of <code>theta</code>.
Defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.by_equation">.by_equation</code></td>
<td>
<p>Should the criteria be computed for each structural model
equation separately? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.c">.C</code></td>
<td>
<p>A (J x J) composite variance-covariance matrix.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.check_errors">.check_errors</code></td>
<td>
<p>Logical. Should the model to parse be checked for correctness
in a sense that all necessary components to estimate the model are given?
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.choices">.choices</code></td>
<td>
<p>Logical. Should candidate values for the arguments be returned?
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.ci">.ci</code></td>
<td>
<p>A vector of character strings naming the confidence interval to compute.
For possible choices see <code><a href="#topic+infer">infer()</a></code>.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.ci_colnames">.ci_colnames</code></td>
<td>
<p>Internal argument used by several print helper functions.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.closed_form_ci">.closed_form_ci</code></td>
<td>
<p>Logical. Should a closed-form confidence interval be computed?
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.conv_criterion">.conv_criterion</code></td>
<td>
<p>Character string. The criterion to use for the convergence check.
One of: &quot;<em>diff_absolute</em>&quot;, &quot;<em>diff_squared</em>&quot;, or &quot;<em>diff_relative</em>&quot;. Defaults
to &quot;<em>diff_absolute</em>&quot;.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.csem_model">.csem_model</code></td>
<td>
<p>A (possibly incomplete) <a href="#topic+cSEMModel">cSEMModel</a>-list.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.csem_resample">.csem_resample</code></td>
<td>
<p>A list resulting from a call to <code><a href="#topic+resamplecSEMResults">resamplecSEMResults()</a></code>.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.cv_folds">.cv_folds</code></td>
<td>
<p>Integer. The number of cross-validation folds to use. Setting
<code>.cv_folds</code> to <code>N</code> (the number of observations) produces
leave-one-out cross-validation samples. Defaults to <code>10</code>.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.data">.data</code></td>
<td>
<p>A <code>data.frame</code> or a <code>matrix</code> of standardized or unstandardized
data (indicators/items/manifest variables). Possible column types or classes
of the data provided are: &quot;<code>logical</code>&quot;, &quot;<code>numeric</code>&quot; (&quot;<code>double</code>&quot; or &quot;<code>integer</code>&quot;),
&quot;<code>factor</code>&quot; (&quot;<code>ordered</code>&quot; and/or &quot;<code>unordered</code>&quot;), &quot;<code>character</code>&quot; (converted to factor),
or a mix of several types.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.dependent">.dependent</code></td>
<td>
<p>Character string. The name of the dependent variable.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.disattenuate">.disattenuate</code></td>
<td>
<p>Logical. Should composite/proxy correlations
be disattenuated to yield consistent loadings and path estimates if at least
one of the construct is modeled as a common factor? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.dist">.dist</code></td>
<td>
<p>Character string. The distribution to use for the critical value.
One of <em>&quot;t&quot;</em> for Student's t-distribution or <em>&quot;z&quot;</em> for the standard normal distribution.
Defaults to <em>&quot;z&quot;</em>.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.distance">.distance</code></td>
<td>
<p>Character string. A distance measure. One of: &quot;<em>geodesic</em>&quot;
or &quot;<em>squared_euclidean</em>&quot;. Defaults to &quot;<em>geodesic</em>&quot;.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.df">.df</code></td>
<td>
<p>Character string. The method for obtaining the degrees of freedom.
Choices are &quot;<em>type1</em>&quot; and &quot;<em>type2</em>&quot;. Defaults to &quot;<em>type1</em>&quot; .</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.dominant_indicators">.dominant_indicators</code></td>
<td>
<p>A character vector of <code>"construct_name" = "indicator_name"</code> pairs,
where <code>"indicator_name"</code> is a character string giving the name of the dominant indicator
and <code>"construct_name"</code> a character string of the corresponding construct name.
Dominant indicators may be specified for a subset of the constructs.
Default to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.e">.E</code></td>
<td>
<p>A (J x J) matrix of inner weights.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.effect">.effect</code></td>
<td>
<p>Internal argument used by helper printEffects().</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.estimate_structural">.estimate_structural</code></td>
<td>
<p>Logical. Should the structural coefficients
be estimated? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.eval_plan">.eval_plan</code></td>
<td>
<p>Character string. The evaluation plan to use. One of
&quot;<em>sequential</em>&quot;, &quot;<em>multicore</em>&quot;, or &quot;<em>multisession</em>&quot;. In the two latter cases
all available cores will be used. Defaults to &quot;<em>sequential</em>&quot;.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.filename">.filename</code></td>
<td>
<p>Character string. The file name. Defaults to &quot;results.xlsx&quot;.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.first_resample">.first_resample</code></td>
<td>
<p>A list containing the <code>.R</code> resamples based on the original
data obtained by resamplecSEMResults().</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.fit_measures">.fit_measures</code></td>
<td>
<p>Logical. (EXPERIMENTAL) Should additional fit measures
be included? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.force">.force</code></td>
<td>
<p>Logical. Should .object be resampled even if it contains resamples
already?. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.full_output">.full_output</code></td>
<td>
<p>Logical. Should the full output of summarize be printed.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.h">.H</code></td>
<td>
<p>The (N x J) matrix of construct scores.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.handle_inadmissibles">.handle_inadmissibles</code></td>
<td>
<p>Character string. How should inadmissible results
be treated? One of &quot;<em>drop</em>&quot;, &quot;<em>ignore</em>&quot;, or &quot;<em>replace</em>&quot;. If &quot;<em>drop</em>&quot;, all
replications/resamples yielding an inadmissible result will be dropped
(i.e. the number of results returned will potentially be less than <code>.R</code>).
For &quot;<em>ignore</em>&quot; all results are returned even if all or some of the replications
yielded inadmissible results (i.e. number of results returned is equal to <code>.R</code>).
For &quot;<em>replace</em>&quot; resampling continues until there are exactly <code>.R</code> admissible solutions.
Depending on the frequency of inadmissible solutions this may significantly increase
computing time. Defaults to &quot;<em>drop</em>&quot;.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.id">.id</code></td>
<td>
<p>Character string or integer. A character string giving the name or
an integer of the position of the column of <code>.data</code> whose levels are used
to split <code>.data</code> into groups. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.inference">.inference</code></td>
<td>
<p>Logical. Should critical values be computed? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.independent">.independent</code></td>
<td>
<p>Character string. The name of the independent variable.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.instruments">.instruments</code></td>
<td>
<p>A named list of vectors of instruments. The names
of the list elements are the names of the dependent (LHS) constructs of the structural
equation whose explanatory variables are endogenous. The vectors
contain the names of the instruments corresponding to each equation. Note
that exogenous variables of a given equation <strong>must</strong> be supplied as
instruments for themselves. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.iter_max">.iter_max</code></td>
<td>
<p>Integer. The maximum number of iterations allowed.
If <code>iter_max = 1</code> and <code>.approach_weights = "PLS-PM"</code> one-step weights are returned.
If the algorithm exceeds the specified number, weights of iteration step
<code>.iter_max - 1</code>  will be returned with a warning. Defaults to <code>100</code>.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.level">.level</code></td>
<td>
<p>Character. Used in <code>plot.cSEMIPMA</code> to indicate whether IPMA should be done
for constructs or indicators.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.matrix1">.matrix1</code></td>
<td>
<p>A <code>matrix</code> to compare.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.matrix2">.matrix2</code></td>
<td>
<p>A <code>matrix</code> to compare.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.matrices">.matrices</code></td>
<td>
<p>A list of at least two matrices.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.metrics">.metrics</code></td>
<td>
<p>Character string or a vector of character strings.
Which prediction metrics should be displayed? One of: &quot;<em>MAE</em>&quot;, &quot;<em>RMSE</em>&quot;, &quot;<em>Q2</em>&quot;,
&quot;<em>MER</em>&quot;, &quot;<em>MAPE</em>, &quot;<em>MSE2</em>&quot;, &quot;<em>U1</em>&quot;, &quot;<em>U2</em>&quot;, &quot;<em>UM</em>&quot;, &quot;<em>UR</em>&quot;, or &quot;<em>UD</em>&quot;.
Default to c(&quot;<em>MAE</em>&quot;, &quot;<em>RMSE</em>&quot;, &quot;<em>Q2</em>&quot;).</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.model">.model</code></td>
<td>
<p>A model in <a href="lavaan.html#topic+model.syntax">lavaan model syntax</a>
or a <a href="#topic+cSEMModel">cSEMModel</a> list.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.moderator">.moderator</code></td>
<td>
<p>Character string. The name of the moderator variable.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.modes">.modes</code></td>
<td>
<p>A vector giving the mode for each construct in the form <code>"name" = "mode"</code>.
Only used internally.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.ms_criterion">.ms_criterion</code></td>
<td>
<p>Character string. Either a single character string or a vector
of character strings naming the model selection criterion to compute.
Defaults to <code>"all"</code>.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.n">.n</code></td>
<td>
<p>Integer. The number of observations of the original data.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.n_steps">.n_steps</code></td>
<td>
<p>Integer. A value giving the number of steps (the spotlights, i.e.,
values of .moderator in surface analysis or floodlight analysis)
between the minimum and maximum value of the moderator. Defaults to <code>100</code>.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.normality">.normality</code></td>
<td>
<p>Logical. Should joint normality of
<code class="reqn">[\eta_{1:p}; \zeta; \epsilon]</code>
be assumed in the nonlinear model? See (Dijkstra and Schermelleh-Engel 2014) for details.
Defaults to <code>FALSE</code>. Ignored if the model is not nonlinear.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.nr_comparisons">.nr_comparisons</code></td>
<td>
<p>Integer. The number of comparisons. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.null_model">.null_model</code></td>
<td>
<p>Logical. Should the degrees of freedom for the null model
be computed? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.object">.object</code></td>
<td>
<p>An R object of class <a href="#topic+cSEMResults">cSEMResults</a> resulting from a call to <code><a href="#topic+csem">csem()</a></code>.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.object1">.object1</code></td>
<td>
<p>An R object of class <a href="#topic+cSEMResults">cSEMResults</a> resulting from a call to <code><a href="#topic+csem">csem()</a></code>.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.object2">.object2</code></td>
<td>
<p>An R object of class <a href="#topic+cSEMResults">cSEMResults</a> resulting from a call to <code><a href="#topic+csem">csem()</a></code>.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.only_common_factors">.only_common_factors</code></td>
<td>
<p>Logical. Should only concepts modeled as common
factors be included when calculating one of the following quality criteria:
AVE, the Fornell-Larcker criterion, HTMT, and all reliability estimates.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.only_structural">.only_structural</code></td>
<td>
<p>Should the the log-likelihood be based on the
structural model? Ignored if <code>.by_equation == TRUE</code>. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.original_arguments">.original_arguments</code></td>
<td>
<p>The list of arguments used within <code><a href="#topic+csem">csem()</a></code>.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.output_type">.output_type</code></td>
<td>
<p>Character string. The type of output to return. One of
&quot;<em>complete</em>&quot; or &quot;<em>structured</em>&quot;. See the Value section for details. Defaults to
&quot;<em>complete</em>&quot;.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.p">.P</code></td>
<td>
<p>A (J x J) construct variance-covariance matrix (possibly disattenuated).</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.parameters_to_compare">.parameters_to_compare</code></td>
<td>
<p>A model in <a href="lavaan.html#topic+model.syntax">lavaan model syntax</a> indicating which
parameters (i.e, path (<code>~</code>), loadings (<code style="white-space: pre;">&#8288;=~&#8288;</code>), weights (<code style="white-space: pre;">&#8288;&lt;~&#8288;</code>), or correlations (<code style="white-space: pre;">&#8288;~~&#8288;</code>)) should be
compared across groups. Defaults to <code>NULL</code> in which case all weights, loadings and
path coefficients of the originally specified model are compared.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.path">.path</code></td>
<td>
<p>Character string. Path of the directory to save the file to. Defaults
to the current working directory.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.path_coefficients">.path_coefficients</code></td>
<td>
<p>List. A list that contains the resampled and the original
path coefficient estimates. Typically a part of a <code>cSEMResults_resampled</code> object.
Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.pls_approach_cf">.PLS_approach_cf</code></td>
<td>
<p>Character string. Approach used to obtain the correction
factors for PLSc. One of: &quot;<em>dist_squared_euclid</em>&quot;, &quot;<em>dist_euclid_weighted</em>&quot;,
&quot;<em>fisher_transformed</em>&quot;, &quot;<em>mean_arithmetic</em>&quot;, &quot;<em>mean_geometric</em>&quot;, &quot;<em>mean_harmonic</em>&quot;,
&quot;<em>geo_of_harmonic</em>&quot;. Defaults to &quot;<em>dist_squared_euclid</em>&quot;.
Ignored if <code>.disattenuate = FALSE</code> or if <code>.approach_weights</code> is not PLS-PM.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.plot_package">.plot_package</code></td>
<td>
<p>Character string. Indicates which packages should be used for plotting.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.plot_type">.plot_type</code></td>
<td>
<p>Character string. Indicates the type of plot that is produced.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.pls_ignore_structural_model">.PLS_ignore_structural_model</code></td>
<td>
<p>Logical. Should the structural model be ignored
when calculating the inner weights of the PLS-PM algorithm? Defaults to <code>FALSE</code>.
Ignored if <code>.approach_weights</code> is not PLS-PM.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.pls_modes">.PLS_modes</code></td>
<td>
<p>Either a named list specifying the mode that should be used for
each construct in the form <code>"construct_name" = mode</code>, a single character
string giving the mode that should be used for all constructs, or <code>NULL</code>.
Possible choices for <code>mode</code> are: &quot;<em>modeA</em>&quot;, &quot;<em>modeB</em>&quot;, &quot;<em>modeBNNLS</em>&quot;,
&quot;<em>unit</em>&quot;, &quot;<em>PCA</em>&quot;, a single integer or
a vector of fixed weights of the same length as there are indicators for the
construct given by <code>"construct_name"</code>. If only a single number is provided this is identical to
using unit weights, as weights are rescaled such that the related composite
has unit variance.  Defaults to <code>NULL</code>.
If <code>NULL</code> the appropriate mode according to the type
of construct used is chosen. Ignored if <code>.approach_weight</code> is not PLS-PM.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.pls_weight_scheme_inner">.PLS_weight_scheme_inner</code></td>
<td>
<p>Character string. The inner weighting scheme
used by PLS-PM. One of: &quot;<em>centroid</em>&quot;, &quot;<em>factorial</em>&quot;, or &quot;<em>path</em>&quot;.
Defaults to &quot;<em>path</em>&quot;. Ignored if <code>.approach_weight</code> is not PLS-PM.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.probs">.probs</code></td>
<td>
<p>A vector of probabilities.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.postestimation_object">.postestimation_object</code></td>
<td>
<p>An object resulting from a call to one of cSEM's
postestimation functions (e.g. <code><a href="#topic+summarize">summarize()</a></code>).</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.quality_criterion">.quality_criterion</code></td>
<td>
<p>Character string. A single character string or a
vector of character strings naming the quality criterion to compute. See
the Details section for a list of possible candidates.
Defaults to &quot;<em>all</em>&quot; in which case all possible quality criteria are computed.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.quantity">.quantity</code></td>
<td>
<p>Character string. Which statistic should be returned?
One of &quot;<em>all</em>&quot;, &quot;<em>mean</em>&quot;, &quot;<em>sd</em>&quot;, &quot;<em>bias</em>&quot;, &quot;<em>CI_standard_z</em>&quot;, &quot;<em>CI_standard_t</em>&quot;,
&quot;<em>CI_percentile</em>&quot;, &quot;<em>CI_basic</em>&quot;, &quot;<em>CI_bc</em>&quot;, &quot;<em>CI_bca</em>&quot;, &quot;<em>CI_t_interval</em>&quot;
Defaults to &quot;<em>all</em>&quot; in which case all quantities that do not require
additional resampling are returned, i.e., all quantities but &quot;<em>CI_bca</em>&quot;, &quot;<em>CI_t_interval</em>&quot;.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.q">.Q</code></td>
<td>
<p>A vector of composite-construct correlations with element names equal to
the names of the J construct names used in the measurement model. Note
Q^2 is also called the reliability coefficient.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.reliabilities">.reliabilities</code></td>
<td>
<p>A character vector of <code>"name" = value</code> pairs,
where <code>value</code> is a number between 0 and 1 and <code>"name"</code> a character string
of the corresponding construct name, or <code>NULL</code>. Reliabilities
may be given for a subset of the constructs. Defaults to <code>NULL</code> in which case
reliabilities are estimated by <code>csem()</code>. Currently, only supported for
<code>.approach_weights = "PLS-PM"</code>.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.resample_method">.resample_method</code></td>
<td>
<p>Character string. The resampling method to use. One of:
&quot;<em>none</em>&quot;, &quot;<em>bootstrap</em>&quot; or &quot;<em>jackknife</em>&quot;. Defaults to &quot;<em>none</em>&quot;.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.resample_method2">.resample_method2</code></td>
<td>
<p>Character string. The resampling method to use when resampling
from a resample. One of: &quot;<em>none</em>&quot;, &quot;<em>bootstrap</em>&quot; or &quot;<em>jackknife</em>&quot;. For
&quot;<em>bootstrap</em>&quot; the number of draws is provided via <code>.R2</code>. Currently,
resampling from each resample is only required for the studentized confidence
interval (&quot;<em>CI_t_interval</em>&quot;) computed by the <code><a href="#topic+infer">infer()</a></code> function. Defaults to &quot;<em>none</em>&quot;.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_+60.resample_object+60">`.resample_object`</code></td>
<td>
<p>An R object of class <code>cSEMResults_resampled</code>
obtained from <code><a href="#topic+resamplecSEMResults">resamplecSEMResults()</a></code> or by setting <code>.resample_method = "bootstrap"</code>
or <code>"jackknife"</code> when calling <code><a href="#topic+csem">csem()</a></code>.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.resample_sarstedt">.resample_sarstedt</code></td>
<td>
<p>A matrix containing the parameter estimates that
could potentially be compared and an id column indicating the group adherence
of each row.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.r">.r</code></td>
<td>
<p>Integer. The number of repetitions to use. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.r">.R</code></td>
<td>
<p>Integer. The number of bootstrap replications. Defaults to <code>499</code>.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.r2">.R2</code></td>
<td>
<p>Integer. The number of bootstrap replications to use when
resampling from a resample. Defaults to <code>199</code>.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.r_bootstrap">.R_bootstrap</code></td>
<td>
<p>Integer. The number of bootstrap runs. Ignored if <code>.object</code>
contains resamples. Defaults to <code>499</code></p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.r_permutation">.R_permutation</code></td>
<td>
<p>Integer. The number of permutations. Defaults to <code>499</code></p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.s">.S</code></td>
<td>
<p>The (K x K) empirical indicator correlation matrix.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.saturated">.saturated</code></td>
<td>
<p>Logical. Should a saturated structural model be used?
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.second_resample">.second_resample</code></td>
<td>
<p>A list containing <code>.R2</code> resamples for each of the <code>.R</code>
resamples of the first run.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.seed">.seed</code></td>
<td>
<p>Integer or <code>NULL</code>. The random seed to use. Defaults to <code>NULL</code> in which
case an arbitrary seed is chosen. Note that the scope of the seed is limited
to the body of the function it is used in. Hence, the global seed will
not be altered!</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.sign_change_option">.sign_change_option</code></td>
<td>
<p>Character string. Which sign change option should
be used to handle flipping signs when resampling? One of &quot;<em>none</em>&quot;,&quot;<em>individual</em>&quot;,
&quot;<em>individual_reestimate</em>&quot;, &quot;<em>construct_reestimate</em>&quot;. Defaults to &quot;<em>none</em>&quot;.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.sim_points">.sim_points</code></td>
<td>
<p>Integer. How many samples from the truncated normal distribution should
be simulated to estimate the exogenous construct scores? Defaults to &quot;<em>100</em>&quot;.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.stage">.stage</code></td>
<td>
<p>Character string. The stage the model is needed for.
One of &quot;<em>first</em>&quot; or &quot;<em>second</em>&quot;. Defaults to &quot;<em>first</em>&quot;.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.standardized">.standardized</code></td>
<td>
<p>Logical. Should standardized scores be returned? Defaults
to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.starting_values">.starting_values</code></td>
<td>
<p>A named list of vectors where the
list names are the construct names whose indicator weights the user
wishes to set. The vectors must be named vectors of <code>"indicator_name" = value</code>
pairs, where <code>value</code> is the (scaled or unscaled) starting weight. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.steps_mod">.steps_mod</code></td>
<td>
<p>A numeric vector. Steps used for the moderator variable in calculating
the simple effects of an independent variable on the dependent variable.
Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.terms">.terms</code></td>
<td>
<p>A vector of construct names to be classified.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.test_data">.test_data</code></td>
<td>
<p>A matrix of test data with the same column names as the
training data.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.testtype">.testtype</code></td>
<td>
<p>Character string. One of &quot;<em>twosided</em>&quot; (H1: The models do not
perform equally in predicting indicators belonging to endogenous constructs)&quot;
and <em>onesided</em>&quot; (H1: Model 1 performs better in predicting indicators belonging</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.tolerance">.tolerance</code></td>
<td>
<p>Double. The tolerance criterion for convergence.
Defaults to <code>1e-05</code>.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.treat_as_continuous">.treat_as_continuous</code></td>
<td>
<p>Logical. Should the indicators for the benchmark predictions
be treated as continuous? If <code>TRUE</code> all indicators are treated as continuous and PLS-PM/PLSc is applied.
If <code>FALSE</code> OrdPLS/OrdPLSc is applied. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.type_gfi">.type_gfi</code></td>
<td>
<p>Character string. Which fitting function should the GFI be based
on? One of <em>&quot;ML&quot;</em> for the maximum likelihood fitting function, <em>&quot;GLS&quot;</em> for
the generalized least squares fitting function or <em>&quot;ULS&quot;</em> for the
unweighted least squares fitting function (same as the squared Euclidean distance).
Defaults to <em>&quot;ML&quot;</em>.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.type_ci">.type_ci</code></td>
<td>
<p>Character string. Which confidence interval should be calculated?
For possible choices, see the <code>.quantity</code> argument of the <code><a href="#topic+infer">infer()</a></code> function.
Only used if <code>.approch_mgd</code> is one of &quot;<em>CI_para</em>&quot; or &quot;<em>CI_overlap</em>&quot;. Ignored otherwise.
Defaults to &quot;<em>CI_percentile</em>&quot;.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.type_htmt">.type_htmt</code></td>
<td>
<p>Character string indicating the type of HTMT that should be
calculated, i.e., the original HTMT (&quot;<em>htmt</em>&quot;) or the HTMT2 (&quot;<em>htmt2</em>&quot;).
Defaults to &quot;<em>htmt</em>&quot;</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.type_vcv">.type_vcv</code></td>
<td>
<p>Character string. Which model-implied correlation
matrix should be calculated?
One of &quot;<em>indicator</em>&quot; or &quot;<em>construct</em>&quot;. Defaults to &quot;<em>indicator</em>&quot;.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.verbose">.verbose</code></td>
<td>
<p>Logical. Should information (e.g., progress bar) be printed
to the console? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.user_funs">.user_funs</code></td>
<td>
<p>A function or a (named) list of functions to apply to every
resample. The functions must take <code>.object</code> as its first argument (e.g.,
<code style="white-space: pre;">&#8288;myFun &lt;- function(.object, ...) {body-of-the-function}&#8288;</code>).
Function output should preferably be a (named)
vector but matrices are also accepted. However, the output will be
vectorized (columnwise) in this case. See the examples section for details.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.value_independent">.value_independent</code></td>
<td>
<p>Integer. Only required for floodlight analysis;
The value of the independent variable in case that it appears as a
higher-order term.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.values_moderator">.values_moderator</code></td>
<td>
<p>A numeric vector. The values of the moderator in a
the simple effects analysis. Typically these are difference from the mean (=0)
measured in standard deviations. Defaults to <code>c(-2, -1, 0, 1, 2)</code>.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.vcv_asymptotic">.vcv_asymptotic</code></td>
<td>
<p>Logical. Should the asymptotic variance-covariance matrix be used, i.e.,
VCV(b0) - VCV(b1)= VCV(b1-b0), or should VCV(b1-b0) be computed directly?
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.vector1">.vector1</code></td>
<td>
<p>A vector of numeric values.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.vector2">.vector2</code></td>
<td>
<p>A vector of numeric values.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.w">.W</code></td>
<td>
<p>A (J x K) matrix of weights.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.what">.what</code></td>
<td>
<p>Internal argument used by several print helper functions.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.w_new">.W_new</code></td>
<td>
<p>A (J x K) matrix of weights.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.w_old">.W_old</code></td>
<td>
<p>A (J x K) matrix of weights.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.weighted">.weighted</code></td>
<td>
<p>Logical. Should estimation be based on a score that uses
the weights of the weight approach used to obtain <code>.object</code>?. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.x">.X</code></td>
<td>
<p>A matrix of processed data (scaled, cleaned and ordered).</p>
</td></tr>
<tr><td><code id="csem_arguments_+3A_.x_cleaned">.X_cleaned</code></td>
<td>
<p>A data.frame of processed data (cleaned and ordered). Note: <code>X_cleaned</code>
may not be scaled!</p>
</td></tr>
</table>

<hr>
<h2 id='csem_model'>cSEMModel</h2><span id='topic+csem_model'></span><span id='topic+cSEMModel'></span>

<h3>Description</h3>

<p>cSEMModel
</p>


<h3>Details</h3>

<p>A standardized list containing model-related information. To convert a
a model written in <a href="lavaan.html#topic+model.syntax">lavaan model syntax</a>
to a <a href="#topic+cSEMModel">cSEMModel</a> list use <code><a href="#topic+parseModel">parseModel()</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <a href="#topic+cSEMModel">cSEMModel</a> is a standardized list containing the
following components. J stands for the number of constructs and K for the number
of indicators.
</p>

<dl>
<dt><code style="white-space: pre;">&#8288;$structural&#8288;</code></dt><dd><p>A matrix mimicking the structural relationship between
constructs. If constructs are only linearly related, <code>structural</code> is
of dimension (J x J) with row- and column names equal to the construct
names. If the structural model contains nonlinear relationships
<code>structural</code> is (J x (J + J*)) where J* is the number of
nonlinear terms. Rows are ordered such that exogenous constructs are always
first, followed by constructs that only depend on exogenous constructs and/or
previously ordered constructs.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$measurement&#8288;</code></dt><dd><p>A (J x K) matrix mimicking the measurement/composite
relationship between constructs and their related indicators. Rows are in the same
order as the matrix <code style="white-space: pre;">&#8288;$structural&#8288;</code> with row names equal to
the construct names. The order of the columns is such that <code style="white-space: pre;">&#8288;$measurement&#8288;</code>
forms a block diagonal matrix.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$error_cor&#8288;</code></dt><dd><p>A (K x K) matrix mimicking the measurement error
correlation relationship. The row and column order is identical to
the column order of <code style="white-space: pre;">&#8288;$measurement&#8288;</code>.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$cor_specified&#8288;</code></dt><dd><p>A matrix indicating the correlation relationships
between any variables of the model as specified by the user. Mainly for internal purposes.
Note that <code style="white-space: pre;">&#8288;$cor_specified&#8288;</code> may also contain inadmissible correlations
such as a correlation between measurement errors indicators and constructs.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$construct_type&#8288;</code></dt><dd><p>A named vector containing the names of each construct
and their respective type (&quot;Common factor&quot; or &quot;Composite&quot;).</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$construct_order&#8288;</code></dt><dd><p>A named vector containing the names of each construct
and their respective order (&quot;First order&quot; or &quot;Second order&quot;).</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$model_type&#8288;</code></dt><dd><p>The type of model (&quot;Linear&quot; or &quot;Nonlinear&quot;).</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$instruments&#8288;</code></dt><dd><p>Only if instruments are supplied: a list of structural
equations relating endogenous RHS variables to instruments.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$indicators&#8288;</code></dt><dd><p>The names of the indicators
(i.e., observed variables and/or first-order constructs)</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$cons_exo&#8288;</code></dt><dd><p>The names of the exogenous constructs of the structural model
(i.e., variables that do not appear on the LHS of any structural equation)</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$cons_endo&#8288;</code></dt><dd><p>The names of the endogenous constructs of the structural model
(i.e., variables that appear on the LHS of at least one structural equation)</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$vars_2nd&#8288;</code></dt><dd><p>The names of the constructs modeled as second orders.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$vars_attached_to_2nd&#8288;</code></dt><dd><p>The names of the constructs forming or building
a second order construct.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$vars_not_attached_to_2nd&#8288;</code></dt><dd><p>The names of the constructs not forming or building
a second order construct.</p>
</dd>
</dl>

<p>It is possible to supply an incomplete list to <code><a href="#topic+parseModel">parseModel()</a></code>, resulting
in an incomplete <a href="#topic+cSEMModel">cSEMModel</a> list which can be passed
to all functions that require <code>.csem_model</code> as a mandatory argument. Currently,
only the structural and the measurement matrix are required.
However, specifying an incomplete <a href="#topic+cSEMModel">cSEMModel</a> list may lead to unexpected behavior
and errors. Use with care.
</p>


<h3>See Also</h3>

<p><a href="#topic+parseModel">parseModel</a>
</p>

<hr>
<h2 id='csem_results'>cSEMResults</h2><span id='topic+csem_results'></span><span id='topic+cSEMResults'></span>

<h3>Description</h3>

<p>A call to <code><a href="#topic+csem">csem()</a></code> results in an object with at least
two class attributes. The first class attribute is always <code>cSEMResults</code> no matter
the type of data or model provided.
The second is one of <code>cSEMResults_default</code>, <code>cSEMResults_multi</code>, or
<code>cSEMResults_2ndorder</code> and depends on the estimated model and/or the type of
data provided to the <code>.model</code> and <code>.data</code> arguments of <code><a href="#topic+csem">csem()</a></code>.
The third class attribute <code>cSEMResults_resampled</code> is only added if resampling
was conducted.
</p>


<h3>Details</h3>

<p>Depending on the type of data and/or model provided three different output
types exists.
</p>

<dl>
<dt>_default</dt><dd><p>This will be the structure for the vast majority of applications.
If the data is a single <code>matrix</code> or <code>data.frame</code> with no id-column,
the result is a <code>list</code> with elements:
</p>

<dl>
<dt><code style="white-space: pre;">&#8288;$Estimates&#8288;</code></dt><dd><p>A list containing a list of estimated quantities.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$Information&#8288;</code></dt><dd><p>A list containing a list of additional information.</p>
</dd>
</dl>

<p>The resulting object has classes <code>cSEMResults</code> and <code>cSEMResults_default</code>.
</p>
</dd>
<dt>_multi</dt><dd><p>If the data provided is a single <code>matrix</code> or <code>data.frame</code> containing
an id-column to split the data by <code>G</code> group levels
or if a list of <code>G</code> datasets is provided, the resulting object is a list of <code>G</code>
lists, where <code>G</code> is equal to the number of groups or the number of datasets
in the list of datasets provided. Each of the <code>G</code> list elements is itself
a <code>cSEMResults_default</code> object. Hence its structure is identical to
the structure described in <code style="white-space: pre;">&#8288;_default&#8288;</code>.
</p>
<p>The resulting object has classes <code>cSEMResults</code> and <code>cSEMResults_multi</code>.
</p>
</dd>
<dt>_2ndorder</dt><dd>
<p>A special output is generated if the model to estimate contains hierarchical constructs
<strong>and</strong> the &quot;2stage&quot; or &quot;mixed&quot; approach is used to estimate the model. In this case
the resulting object is a list containing two elements <code>First_stage</code> and
<code> Second_stage</code>.
</p>
<p>Each list element is itself a <code>cSEMResults_default</code> object. Hence its structure is identical to
the structure described in <code style="white-space: pre;">&#8288;_default&#8288;</code>.
</p>
</dd>
</dl>

<p>If <code>.resample_method = "bootstrap"</code> or <code>.resample_method = "jackknife"</code>, resamples
are attached to each object. For objects of class <code>cSEMResults_default</code> the resamples are
attached to <code>.object$Estimates$Estimates_resample</code>. For objects of class
<code>cSEMResults_multi</code> the same is done by group. For objects of class
<code>cSEMResults_2ndorder</code> the resamples are attached to the
<code>.object$Second_stage$Information$Resamples</code>. All objects containing
these elements gain the <code>cSEMResults_resampled</code> class.
</p>

<hr>
<h2 id='csem_summary'>cSEMSummarize</h2><span id='topic+csem_summary'></span><span id='topic+cSEMSummary'></span>

<h3>Description</h3>

<p>cSEMSummarize
</p>


<h3>Value</h3>

<p>An object of class <code>cSEMSummary</code>.
Technically <code>cSEMSummary</code> is a named list containing the following list elements:
</p>

<dl>
<dt>'...</dt><dd><p>Not finished yet.</p>
</dd>
</dl>


<hr>
<h2 id='csem_test'>cSEMTest</h2><span id='topic+csem_test'></span><span id='topic+cSEMTest'></span>

<h3>Description</h3>

<p>cSEMTest
</p>


<h3>Value</h3>

<p>A standardized list of class <code>cSEMTest</code>. Technically <code>cSEMTest</code> is a named
list containing the following list elements:
</p>

<dl>
<dt><code style="white-space: pre;">&#8288;$Test_statistic&#8288;</code></dt><dd><p>The value of test statistic(s).</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$Critical_value&#8288;</code></dt><dd><p>The critical value(s).</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$Decision&#8288;</code></dt><dd><p>The test decision. One of: <strong>Reject</strong> or <strong>Do not reject</strong></p>
</dd>
<dt><code style="white-space: pre;">&#8288;$Number_admissibles&#8288;</code></dt><dd><p>The number of admissible runs. See <code><a href="#topic+verify">verify()</a></code> for
what constitutes and inadmissible run.</p>
</dd>
</dl>


<hr>
<h2 id='dgp_2ndorder_cf_of_c'>Data: Second order common factor of composites</h2><span id='topic+dgp_2ndorder_cf_of_c'></span>

<h3>Description</h3>

<p>A dataset containing 500 standardized observations on 19 indicator generated from a
population model with 6 concepts, three of which (<code>c1-c3</code>) are composites
forming a second order common factor (<code>c4</code>). The remaining two (<code>eta1</code>, <code>eta2</code>)
are concepts modeled as common factors .
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgp_2ndorder_cf_of_c
</code></pre>


<h3>Format</h3>

<p>A matrix with 500 rows and 19 variables:
</p>

<dl>
<dt>y11-y12</dt><dd><p>Indicators attached  to <code>c1</code>.
Population weights are: 0.8; 0.4.
Population loadings are: 0.925; 0.65</p>
</dd>
<dt>y21-y24</dt><dd><p>Indicators attached  to <code>c2</code>.
Population weights are: 0.5; 0.3; 0.2; 0.4.
Population loadings are: 0.804; 0.68; 0.554; 0.708</p>
</dd>
<dt>y31-y38</dt><dd><p>Indicators attached  to <code>c3</code>.
Population weights are: 0.3; 0.3; 0.1; 0.1; 0.2; 0.3; 0.4; 0.2.
Population loadings are: 0.496; 0.61; 0.535; 0.391; 0.391; 0.6; 0.5285; 0.53</p>
</dd>
<dt>y41-y43</dt><dd><p>Indicators attached  to <code>eta1</code>.
Population loadings are: 0.8; 0.7; 0.7</p>
</dd>
<dt>y51-y53</dt><dd><p>Indicators attached  to <code>eta1</code>.
Population loadings are: 0.8; 0.8; 0.7</p>
</dd>
</dl>

<p>The model is:
</p>
<p style="text-align: center;"><code class="reqn">`c4` = gamma1 * `eta1` + zeta1</code>
</p>

<p style="text-align: center;"><code class="reqn">`eta2` = gamma2 * `eta1` + beta * `c4` + zeta2</code>
</p>

<p>with population values <code>gamma1</code> = 0.6, <code>gamma2</code> = 0.4 and <code>beta</code> = 0.35.
The second order common factor is
</p>
<p style="text-align: center;"><code class="reqn">`c4` = lambdac1 * `c1` + lambdac2 * `c2` + lambdac3 * `c3` + epsilon</code>
</p>


<hr>
<h2 id='distance_measures'>Calculate difference between S and Sigma_hat</h2><span id='topic+distance_measures'></span><span id='topic+calculateDG'></span><span id='topic+calculateDL'></span><span id='topic+calculateDML'></span>

<h3>Description</h3>

<p>Calculate the difference between the empirical (S)
and the model-implied indicator variance-covariance matrix (Sigma_hat)
using different distance measures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateDG(
  .object = NULL,
  .matrix1 = NULL,
  .matrix2 = NULL,
  .saturated = FALSE,
  ...
)

calculateDL(
  .object = NULL,
  .matrix1 = NULL,
  .matrix2 = NULL,
  .saturated = FALSE,
  ...
)

calculateDML(
  .object = NULL,
  .matrix1 = NULL,
  .matrix2 = NULL,
  .saturated = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distance_measures_+3A_.object">.object</code></td>
<td>
<p>An R object of class <a href="#topic+cSEMResults">cSEMResults</a> resulting from a call to <code><a href="#topic+csem">csem()</a></code>.</p>
</td></tr>
<tr><td><code id="distance_measures_+3A_.matrix1">.matrix1</code></td>
<td>
<p>A <code>matrix</code> to compare.</p>
</td></tr>
<tr><td><code id="distance_measures_+3A_.matrix2">.matrix2</code></td>
<td>
<p>A <code>matrix</code> to compare.</p>
</td></tr>
<tr><td><code id="distance_measures_+3A_.saturated">.saturated</code></td>
<td>
<p>Logical. Should a saturated structural model be used?
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="distance_measures_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The distances may also be computed for any two matrices A and B by supplying
A and B directly via the <code>.matrix1</code> and <code>.matrix2</code> arguments.
If A and B are supplied <code>.object</code> is ignored.
</p>


<h3>Value</h3>

<p>A single numeric value giving the distance between two matrices.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>calculateDG()</code>: The geodesic distance (dG).
</p>
</li>
<li> <p><code>calculateDL()</code>: The squared Euclidean distance
</p>
</li>
<li> <p><code>calculateDML()</code>: The distance measure (fit function) used by ML
</p>
</li></ul>

<hr>
<h2 id='doIPMA'>Do an importance-performance matrix analysis</h2><span id='topic+doIPMA'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#maturing"><img src="../help/figures/lifecycle-maturing.svg" alt='[Maturing]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doIPMA(.object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="doIPMA_+3A_.object">.object</code></td>
<td>
<p>A <code>cSEMResults</code> object.'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Performs an importance-performance matrix analysis (IPMA).
</p>
<p>To calculate the performance and importance, the weights of the indicators
are unstandardized using the standard deviation of the original
indicators but normed to have a length of 1.
Normed construct scores are calculated based on the original indicators and the
unstandardized weights.
</p>
<p>The importance is calculated as the mean of
the original indicators or the unstandardized construct scores, respectively.
The performance is calculated as the unstandardized total effect if
<code>.level == "construct"</code> and as the normed weight times the unstandardized
total effect if <code>.level == "indicator"</code>. The literature recommends to use an
estimation as input for '<code><a href="#topic+doIPMA">doIPMA()</a></code> that is based on normed
indicators, e.g., by scaling all indicators to 0 to 100,
see e.g., Henseler (2021); Ringle and Sarstedt (2016).
</p>
<p>Note, indicators are not normed internally, as theoretical maximum/minimum can
differ from the empirical maximum/minimum which would lead to an incorrect normalization.
</p>


<h3>Value</h3>

<p>A list of class <code>cSEMIPA</code> with a corresponding method for <code>plot()</code>.
See: <code><a href="#topic+plot.cSEMIPMA">plot.cSEMIPMA()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+csem">csem()</a></code>, <a href="#topic+cSEMResults">cSEMResults</a>, <code><a href="#topic+plot.cSEMIPMA">plot.cSEMIPMA()</a></code>
</p>

<hr>
<h2 id='doNonlinearEffectsAnalysis'>Do a nonlinear effects analysis</h2><span id='topic+doNonlinearEffectsAnalysis'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#maturing"><img src="../help/figures/lifecycle-maturing.svg" alt='[Maturing]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doNonlinearEffectsAnalysis(
 .object            = NULL,
 .dependent         = NULL, 
 .independent       = NULL,
 .moderator         = NULL,
 .n_steps           = 100,
 .values_moderator  = c(-2, -1, 0, 1, 2),
 .value_independent = 0,
 .alpha             = 0.05
 )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="doNonlinearEffectsAnalysis_+3A_.object">.object</code></td>
<td>
<p>An R object of class <a href="#topic+cSEMResults">cSEMResults</a> resulting from a call to <code><a href="#topic+csem">csem()</a></code>.</p>
</td></tr>
<tr><td><code id="doNonlinearEffectsAnalysis_+3A_.dependent">.dependent</code></td>
<td>
<p>Character string. The name of the dependent variable.</p>
</td></tr>
<tr><td><code id="doNonlinearEffectsAnalysis_+3A_.independent">.independent</code></td>
<td>
<p>Character string. The name of the independent variable.</p>
</td></tr>
<tr><td><code id="doNonlinearEffectsAnalysis_+3A_.moderator">.moderator</code></td>
<td>
<p>Character string. The name of the moderator variable.</p>
</td></tr>
<tr><td><code id="doNonlinearEffectsAnalysis_+3A_.n_steps">.n_steps</code></td>
<td>
<p>Integer. A value giving the number of steps (the spotlights, i.e.,
values of .moderator in surface analysis or floodlight analysis)
between the minimum and maximum value of the moderator. Defaults to <code>100</code>.</p>
</td></tr>
<tr><td><code id="doNonlinearEffectsAnalysis_+3A_.values_moderator">.values_moderator</code></td>
<td>
<p>A numeric vector. The values of the moderator in a
the simple effects analysis. Typically these are difference from the mean (=0)
measured in standard deviations. Defaults to <code>c(-2, -1, 0, 1, 2)</code>.</p>
</td></tr>
<tr><td><code id="doNonlinearEffectsAnalysis_+3A_.value_independent">.value_independent</code></td>
<td>
<p>Integer. Only required for floodlight analysis;
The value of the independent variable in case that it appears as a
higher-order term.</p>
</td></tr>
<tr><td><code id="doNonlinearEffectsAnalysis_+3A_.alpha">.alpha</code></td>
<td>
<p>An integer or a numeric vector of significance levels.
Defaults to <code>0.05</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculate the expected value of the dependent variable conditional on the values of
an independent variables and a moderator variable. All other variables in the model
are assumed to be zero, i.e., they are fixed at their mean levels. Moreover, it produces
the input for the floodlight analysis.
</p>


<h3>Value</h3>

<p>A list of class <code>cSEMNonlinearEffects</code> with a corresponding method
for <code>plot()</code>. See: <code><a href="#topic+plot.cSEMNonlinearEffects">plot.cSEMNonlinearEffects()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+csem">csem()</a></code>, <a href="#topic+cSEMResults">cSEMResults</a>, <code><a href="#topic+plot.cSEMNonlinearEffects">plot.cSEMNonlinearEffects()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
model_Int &lt;- "
# Measurement models
INV =~ INV1 + INV2 + INV3 +INV4
SAT =~ SAT1 + SAT2 + SAT3
INT =~ INT1 + INT2

# Structrual model containing an interaction term.
INT ~ INV + SAT + INV.SAT
"
  
# Estimate model
out &lt;- csem(.data = Switching, .model = model_Int,
            # ADANCO settings
            .PLS_weight_scheme_inner = 'factorial',
            .tolerance = 1e-06,
            .resample_method = 'bootstrap'
)
  
# Do nonlinear effects analysis
neffects &lt;- doNonlinearEffectsAnalysis(out, 
                                       .dependent = 'INT',
                                       .moderator = 'INV',
                                       .independent = 'SAT') 

# Get an overview
neffects

# Simple effects plot
plot(neffects, .plot_type = 'simpleeffects')

# Surface plot using plotly
plot(neffects, .plot_type = 'surface', .plot_package = 'plotly')

# Surface plot using persp
plot(neffects, .plot_type = 'surface', .plot_package = 'persp')

# Floodlight analysis
plot(neffects, .plot_type = 'floodlight')

## End(Not run)
</code></pre>

<hr>
<h2 id='doRedundancyAnalysis'>Do a redundancy analysis</h2><span id='topic+doRedundancyAnalysis'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doRedundancyAnalysis(.object = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="doRedundancyAnalysis_+3A_.object">.object</code></td>
<td>
<p>An R object of class <a href="#topic+cSEMResults">cSEMResults</a> resulting from a call to <code><a href="#topic+csem">csem()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Perform a redundancy analysis (RA) as proposed by Hair et al. (2016)
with reference to Chin (1998).
</p>
<p>RA is confined to PLS-PM, specifically PLS-PM with at least one construct
whose weights are obtained by mode B. In cSEM this is the case if the construct
is modeled as a composite or if argument <code>.PLS_modes</code> was explicitly set to
mode B for at least one construct.
Hence RA is only conducted if <code>.approach_weights = "PLS-PM"</code> and if at least
one construct's mode is mode B.
</p>
<p>The principal idea of RA is to take two different measures of the
same construct and regress the scores obtained for each measure on each
other. If they are similar they are likely to measure the same &quot;thing&quot;
which is then taken as evidence that both measurement models actually
measure what they are supposed to measure (validity).
</p>
<p>There are several issues with the terminology  and the reasoning behind this logic.
RA is therefore only implemented since reviewers are likely to demand
its computation, however, its actual application for validity assessment
is discouraged.
</p>
<p>Currently, the function is not applicable to models containing second-order
constructs.
</p>


<h3>Value</h3>

<p>A named numeric vector of correlations. If
the weighting approach used to obtain <code>.object</code> is not <code>"PLS-PM"</code> or
non of the PLS outer modes was mode B, the function silently returns <code>NA</code>.
</p>


<h3>References</h3>

<p>Chin WW (1998).
&ldquo;Modern Methods for Business Research.&rdquo;
In Marcoulides GA (ed.), chapter The Partial Least Squares Approach to Structural Equation Modeling, 295&ndash;358.
Mahwah, NJ: Lawrence Erlbaum.<br /><br /> Hair JF, Hult GTM, Ringle C, Sarstedt M (2016).
<em>A Primer on Partial Least Squares Structural Equation Modeling (PLS-SEM)</em>.
Sage publications.
</p>


<h3>See Also</h3>

<p><a href="#topic+cSEMResults">cSEMResults</a>
</p>

<hr>
<h2 id='estimatePath'>Internal: Estimate the structural coefficients</h2><span id='topic+estimatePath'></span>

<h3>Description</h3>

<p>Estimates the coefficients of the structural model (nonlinear and linear) using
OLS, 2SLS. The latter currently work for linear models only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimatePath(
 .approach_nl      = args_default()$.approach_nl,
 .approach_paths   = args_default()$.approach_paths,
 .csem_model       = args_default()$.csem_model,
 .H                = args_default()$.H,
 .normality        = args_default()$.normality,
 .P                = args_default()$.P,
 .Q                = args_default()$.Q
 )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimatePath_+3A_.approach_nl">.approach_nl</code></td>
<td>
<p>Character string. Approach used to estimate nonlinear
structural relationships. One of: &quot;<em>sequential</em>&quot; or &quot;<em>replace</em>&quot;.
Defaults to &quot;<em>sequential</em>&quot;.</p>
</td></tr>
<tr><td><code id="estimatePath_+3A_.approach_paths">.approach_paths</code></td>
<td>
<p>Character string. Approach used to estimate the
structural coefficients. One of: &quot;<em>OLS</em>&quot; or &quot;<em>2SLS</em>&quot;. If &quot;<em>2SLS</em>&quot;, instruments
need to be supplied to <code>.instruments</code>. Defaults to &quot;<em>OLS</em>&quot;.</p>
</td></tr>
<tr><td><code id="estimatePath_+3A_.csem_model">.csem_model</code></td>
<td>
<p>A (possibly incomplete) <a href="#topic+cSEMModel">cSEMModel</a>-list.</p>
</td></tr>
<tr><td><code id="estimatePath_+3A_.h">.H</code></td>
<td>
<p>The (N x J) matrix of construct scores.</p>
</td></tr>
<tr><td><code id="estimatePath_+3A_.normality">.normality</code></td>
<td>
<p>Logical. Should joint normality of
<code class="reqn">[\eta_{1:p}; \zeta; \epsilon]</code>
be assumed in the nonlinear model? See (Dijkstra and Schermelleh-Engel 2014) for details.
Defaults to <code>FALSE</code>. Ignored if the model is not nonlinear.</p>
</td></tr>
<tr><td><code id="estimatePath_+3A_.p">.P</code></td>
<td>
<p>A (J x J) construct variance-covariance matrix (possibly disattenuated).</p>
</td></tr>
<tr><td><code id="estimatePath_+3A_.q">.Q</code></td>
<td>
<p>A vector of composite-construct correlations with element names equal to
the names of the J construct names used in the measurement model. Note
Q^2 is also called the reliability coefficient.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list containing the estimated structural coefficients, the
R2, the adjusted R2, and the VIFs for each regression.
</p>

<hr>
<h2 id='exportToExcel'>Export to Excel (.xlsx)</h2><span id='topic+exportToExcel'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exportToExcel(
  .postestimation_object = NULL, 
  .filename              = "results.xlsx",
  .path                  = NULL
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exportToExcel_+3A_.postestimation_object">.postestimation_object</code></td>
<td>
<p>An object resulting from a call to one of cSEM's
postestimation functions (e.g. <code><a href="#topic+summarize">summarize()</a></code>).</p>
</td></tr>
<tr><td><code id="exportToExcel_+3A_.filename">.filename</code></td>
<td>
<p>Character string. The file name. Defaults to &quot;results.xlsx&quot;.</p>
</td></tr>
<tr><td><code id="exportToExcel_+3A_.path">.path</code></td>
<td>
<p>Character string. Path of the directory to save the file to. Defaults
to the current working directory.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Export results from postestimation functions <code><a href="#topic+assess">assess()</a></code>, <code><a href="#topic+predict">predict()</a></code>,
<code><a href="#topic+summarize">summarize()</a></code> and <code><a href="#topic+testOMF">testOMF()</a></code> to an .xlsx (Excel) file. The function uses the openxlsx
package which does not depend on Java!
</p>
<p>The function is deliberately kept simple: all it does is to take all the
relevant elements in <code>.postestimation_object</code> and write them (worksheet by worksheet) into
an .xlsx file named <code>.filename</code> in the directory given by <code>.path</code> (the current
working directory by default).
</p>
<p>If <code>.postestimation_object</code> has class attribute <code style="white-space: pre;">&#8288;_2ndorder&#8288;</code> two .xlsx files
named <code>".filename_first_stage.xlsx"</code> and <code>".filename_second_stage.xlsx"</code>
are created. If <code>.postestimation_object</code> is a list of appropriate objects,
one file for each list elements is created.
</p>
<p>Note: rerunning <code><a href="#topic+exportToExcel">exportToExcel()</a></code> without changing <code>.filename</code> and <code>.path</code>
overwrites the file!
</p>


<h3>See Also</h3>

<p><code><a href="#topic+assess">assess()</a></code>, <code><a href="#topic+summarize">summarize()</a></code>, <code><a href="#topic+predict">predict()</a></code>, <code><a href="#topic+testOMF">testOMF()</a></code>
</p>

<hr>
<h2 id='fit'>Model-implied indicator or construct variance-covariance matrix</h2><span id='topic+fit'></span>

<h3>Description</h3>

<p>Calculate the model-implied indicator or construct variance-covariance (VCV)
matrix. Currently only the model-implied VCV for recursive linear models
is implemented (including models containing second order constructs).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit(
  .object    = NULL, 
  .saturated = args_default()$.saturated,
  .type_vcv  = args_default()$.type_vcv
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_+3A_.object">.object</code></td>
<td>
<p>An R object of class <a href="#topic+cSEMResults">cSEMResults</a> resulting from a call to <code><a href="#topic+csem">csem()</a></code>.</p>
</td></tr>
<tr><td><code id="fit_+3A_.saturated">.saturated</code></td>
<td>
<p>Logical. Should a saturated structural model be used?
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fit_+3A_.type_vcv">.type_vcv</code></td>
<td>
<p>Character string. Which model-implied correlation
matrix should be calculated?
One of &quot;<em>indicator</em>&quot; or &quot;<em>construct</em>&quot;. Defaults to &quot;<em>indicator</em>&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Notation is taken from Bollen (1989).
If <code>.saturated = TRUE</code> the model-implied variance-covariance matrix is calculated
for a saturated structural model (i.e., the VCV of the constructs is replaced
by their correlation matrix). Hence: V(eta) = WSW' (possibly disattenuated).
</p>


<h3>Value</h3>

<p>Either a (K x K) matrix or a (J x J) matrix depending on the <code>type_vcv</code>.
</p>


<h3>References</h3>

<p>Bollen KA (1989).
<em>Structural Equations with Latent Variables</em>.
Wiley-Interscience.
ISBN 978-0471011712.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+csem">csem()</a></code>, <code><a href="#topic+foreman">foreman()</a></code>, <a href="#topic+cSEMResults">cSEMResults</a>
</p>

<hr>
<h2 id='fit_measures'>Model fit measures</h2><span id='topic+fit_measures'></span><span id='topic+calculateChiSquare'></span><span id='topic+calculateChiSquareDf'></span><span id='topic+calculateCFI'></span><span id='topic+calculateGFI'></span><span id='topic+calculateCN'></span><span id='topic+calculateIFI'></span><span id='topic+calculateNFI'></span><span id='topic+calculateNNFI'></span><span id='topic+calculateRMSEA'></span><span id='topic+calculateRMSTheta'></span><span id='topic+calculateSRMR'></span>

<h3>Description</h3>

<p>Calculate fit measures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateChiSquare(.object, .saturated = FALSE)

calculateChiSquareDf(.object)

calculateCFI(.object)

calculateGFI(.object, .type_gfi = c("ML", "GLS", "ULS"), ...)

calculateCN(.object, .alpha = 0.05, ...)

calculateIFI(.object)

calculateNFI(.object)

calculateNNFI(.object)

calculateRMSEA(.object)

calculateRMSTheta(.object)

calculateSRMR(
  .object = NULL,
  .matrix1 = NULL,
  .matrix2 = NULL,
  .saturated = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_measures_+3A_.object">.object</code></td>
<td>
<p>An R object of class <a href="#topic+cSEMResults">cSEMResults</a> resulting from a call to <code><a href="#topic+csem">csem()</a></code>.</p>
</td></tr>
<tr><td><code id="fit_measures_+3A_.saturated">.saturated</code></td>
<td>
<p>Logical. Should a saturated structural model be used?
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fit_measures_+3A_.type_gfi">.type_gfi</code></td>
<td>
<p>Character string. Which fitting function should the GFI be based
on? One of <em>&quot;ML&quot;</em> for the maximum likelihood fitting function, <em>&quot;GLS&quot;</em> for
the generalized least squares fitting function or <em>&quot;ULS&quot;</em> for the
unweighted least squares fitting function (same as the squared Euclidean distance).
Defaults to <em>&quot;ML&quot;</em>.</p>
</td></tr>
<tr><td><code id="fit_measures_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="fit_measures_+3A_.alpha">.alpha</code></td>
<td>
<p>An integer or a numeric vector of significance levels.
Defaults to <code>0.05</code>.</p>
</td></tr>
<tr><td><code id="fit_measures_+3A_.matrix1">.matrix1</code></td>
<td>
<p>A <code>matrix</code> to compare.</p>
</td></tr>
<tr><td><code id="fit_measures_+3A_.matrix2">.matrix2</code></td>
<td>
<p>A <code>matrix</code> to compare.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the <a href="https://m-e-rademaker.github.io/cSEM/articles/Using-assess.html#fit_indices">Fit indices</a>
section of the <a href="https://m-e-rademaker.github.io/cSEM/index.html">cSEM website</a>
for details on the implementation.
</p>


<h3>Value</h3>

<p>A single numeric value.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>calculateChiSquare()</code>: The chi square statistic.
</p>
</li>
<li> <p><code>calculateChiSquareDf()</code>: The Chi square statistic divided by its degrees of freedom.
</p>
</li>
<li> <p><code>calculateCFI()</code>: The comparative fit index (CFI).
</p>
</li>
<li> <p><code>calculateGFI()</code>: The goodness of fit index (GFI).
</p>
</li>
<li> <p><code>calculateCN()</code>: The Hoelter index alias Hoelter's (critical) N (CN).
</p>
</li>
<li> <p><code>calculateIFI()</code>: The incremental fit index (IFI).
</p>
</li>
<li> <p><code>calculateNFI()</code>: The normed fit index (NFI).
</p>
</li>
<li> <p><code>calculateNNFI()</code>: The non-normed fit index (NNFI). Also called the Tucker-Lewis index (TLI).
</p>
</li>
<li> <p><code>calculateRMSEA()</code>: The root mean square error of approximation (RMSEA).
</p>
</li>
<li> <p><code>calculateRMSTheta()</code>: The root mean squared residual covariance matrix of the outer model residuals (RMS theta).
</p>
</li>
<li> <p><code>calculateSRMR()</code>: The standardized root mean square residual (SRMR).
</p>
</li></ul>

<hr>
<h2 id='foreman'>Internal: Composite-based SEM</h2><span id='topic+foreman'></span>

<h3>Description</h3>

<p>The central hub of the <span class="pkg">cSEM</span> package. It acts like a
foreman by collecting all (estimation) tasks, distributing them to lower
level package functions, and eventually recollecting all of their results.
It is called by <code><a href="#topic+csem">csem()</a></code> to manage the actual calculations.
It may be called directly by the user, however, in most cases it will likely
be more convenient to use <code><a href="#topic+csem">csem()</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>foreman(
  .data                        = args_default()$.data,
  .model                       = args_default()$.model,
  .approach_cor_robust         = args_default()$.approach_cor_robust,
  .approach_nl                 = args_default()$.approach_nl,
  .approach_paths              = args_default()$.approach_paths,
  .approach_weights            = args_default()$.approach_weights,
  .conv_criterion              = args_default()$.conv_criterion,
  .disattenuate                = args_default()$.disattenuate,
  .dominant_indicators         = args_default()$.dominant_indicators,
  .estimate_structural         = args_default()$.estimate_structural,
  .id                          = args_default()$.id,
  .instruments                 = args_default()$.instruments,
  .iter_max                    = args_default()$.iter_max,
  .normality                   = args_default()$.normality,
  .PLS_approach_cf             = args_default()$.PLS_approach_cf,
  .PLS_ignore_structural_model = args_default()$.PLS_ignore_structural_model,
  .PLS_modes                   = args_default()$.PLS_modes,
  .PLS_weight_scheme_inner     = args_default()$.PLS_weight_scheme_inner,
  .reliabilities               = args_default()$.reliabilities,
  .starting_values             = args_default()$.starting_values,
  .tolerance                   = args_default()$.tolerance
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="foreman_+3A_.data">.data</code></td>
<td>
<p>A <code>data.frame</code> or a <code>matrix</code> of standardized or unstandardized
data (indicators/items/manifest variables). Possible column types or classes
of the data provided are: &quot;<code>logical</code>&quot;, &quot;<code>numeric</code>&quot; (&quot;<code>double</code>&quot; or &quot;<code>integer</code>&quot;),
&quot;<code>factor</code>&quot; (&quot;<code>ordered</code>&quot; and/or &quot;<code>unordered</code>&quot;), &quot;<code>character</code>&quot; (converted to factor),
or a mix of several types.</p>
</td></tr>
<tr><td><code id="foreman_+3A_.model">.model</code></td>
<td>
<p>A model in <a href="lavaan.html#topic+model.syntax">lavaan model syntax</a>
or a <a href="#topic+cSEMModel">cSEMModel</a> list.</p>
</td></tr>
<tr><td><code id="foreman_+3A_.approach_cor_robust">.approach_cor_robust</code></td>
<td>
<p>Character string. Approach used to obtain a robust
indicator correlation matrix. One of: &quot;<em>none</em>&quot; in which case the standard
Bravais-Pearson correlation is used,
&quot;<em>spearman</em>&quot; for the Spearman rank correlation, or
&quot;<em>mcd</em>&quot; via <code><a href="MASS.html#topic+cov.rob">MASS::cov.rob()</a></code> for a robust correlation matrix.
Defaults to &quot;<em>none</em>&quot;. Note that many postestimation procedures (such as
<code><a href="#topic+testOMF">testOMF()</a></code> or <code><a href="#topic+fit">fit()</a></code> implicitly assume a continuous
indicator correlation matrix (e.g. Bravais-Pearson correlation matrix).
Only use if you know what you are doing.</p>
</td></tr>
<tr><td><code id="foreman_+3A_.approach_nl">.approach_nl</code></td>
<td>
<p>Character string. Approach used to estimate nonlinear
structural relationships. One of: &quot;<em>sequential</em>&quot; or &quot;<em>replace</em>&quot;.
Defaults to &quot;<em>sequential</em>&quot;.</p>
</td></tr>
<tr><td><code id="foreman_+3A_.approach_paths">.approach_paths</code></td>
<td>
<p>Character string. Approach used to estimate the
structural coefficients. One of: &quot;<em>OLS</em>&quot; or &quot;<em>2SLS</em>&quot;. If &quot;<em>2SLS</em>&quot;, instruments
need to be supplied to <code>.instruments</code>. Defaults to &quot;<em>OLS</em>&quot;.</p>
</td></tr>
<tr><td><code id="foreman_+3A_.approach_weights">.approach_weights</code></td>
<td>
<p>Character string. Approach used to
obtain composite weights. One of: &quot;<em>PLS-PM</em>&quot;, &quot;<em>SUMCORR</em>&quot;, &quot;<em>MAXVAR</em>&quot;,
&quot;<em>SSQCORR</em>&quot;, &quot;<em>MINVAR</em>&quot;, &quot;<em>GENVAR</em>&quot;, &quot;<em>GSCA</em>&quot;, &quot;<em>PCA</em>&quot;, &quot;<em>unit</em>&quot;, &quot;<em>bartlett</em>&quot;,
or &quot;<em>regression</em>&quot;. Defaults to &quot;<em>PLS-PM</em>&quot;.</p>
</td></tr>
<tr><td><code id="foreman_+3A_.conv_criterion">.conv_criterion</code></td>
<td>
<p>Character string. The criterion to use for the convergence check.
One of: &quot;<em>diff_absolute</em>&quot;, &quot;<em>diff_squared</em>&quot;, or &quot;<em>diff_relative</em>&quot;. Defaults
to &quot;<em>diff_absolute</em>&quot;.</p>
</td></tr>
<tr><td><code id="foreman_+3A_.disattenuate">.disattenuate</code></td>
<td>
<p>Logical. Should composite/proxy correlations
be disattenuated to yield consistent loadings and path estimates if at least
one of the construct is modeled as a common factor? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="foreman_+3A_.dominant_indicators">.dominant_indicators</code></td>
<td>
<p>A character vector of <code>"construct_name" = "indicator_name"</code> pairs,
where <code>"indicator_name"</code> is a character string giving the name of the dominant indicator
and <code>"construct_name"</code> a character string of the corresponding construct name.
Dominant indicators may be specified for a subset of the constructs.
Default to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="foreman_+3A_.estimate_structural">.estimate_structural</code></td>
<td>
<p>Logical. Should the structural coefficients
be estimated? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="foreman_+3A_.id">.id</code></td>
<td>
<p>Character string or integer. A character string giving the name or
an integer of the position of the column of <code>.data</code> whose levels are used
to split <code>.data</code> into groups. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="foreman_+3A_.instruments">.instruments</code></td>
<td>
<p>A named list of vectors of instruments. The names
of the list elements are the names of the dependent (LHS) constructs of the structural
equation whose explanatory variables are endogenous. The vectors
contain the names of the instruments corresponding to each equation. Note
that exogenous variables of a given equation <strong>must</strong> be supplied as
instruments for themselves. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="foreman_+3A_.iter_max">.iter_max</code></td>
<td>
<p>Integer. The maximum number of iterations allowed.
If <code>iter_max = 1</code> and <code>.approach_weights = "PLS-PM"</code> one-step weights are returned.
If the algorithm exceeds the specified number, weights of iteration step
<code>.iter_max - 1</code>  will be returned with a warning. Defaults to <code>100</code>.</p>
</td></tr>
<tr><td><code id="foreman_+3A_.normality">.normality</code></td>
<td>
<p>Logical. Should joint normality of
<code class="reqn">[\eta_{1:p}; \zeta; \epsilon]</code>
be assumed in the nonlinear model? See (Dijkstra and Schermelleh-Engel 2014) for details.
Defaults to <code>FALSE</code>. Ignored if the model is not nonlinear.</p>
</td></tr>
<tr><td><code id="foreman_+3A_.pls_approach_cf">.PLS_approach_cf</code></td>
<td>
<p>Character string. Approach used to obtain the correction
factors for PLSc. One of: &quot;<em>dist_squared_euclid</em>&quot;, &quot;<em>dist_euclid_weighted</em>&quot;,
&quot;<em>fisher_transformed</em>&quot;, &quot;<em>mean_arithmetic</em>&quot;, &quot;<em>mean_geometric</em>&quot;, &quot;<em>mean_harmonic</em>&quot;,
&quot;<em>geo_of_harmonic</em>&quot;. Defaults to &quot;<em>dist_squared_euclid</em>&quot;.
Ignored if <code>.disattenuate = FALSE</code> or if <code>.approach_weights</code> is not PLS-PM.</p>
</td></tr>
<tr><td><code id="foreman_+3A_.pls_ignore_structural_model">.PLS_ignore_structural_model</code></td>
<td>
<p>Logical. Should the structural model be ignored
when calculating the inner weights of the PLS-PM algorithm? Defaults to <code>FALSE</code>.
Ignored if <code>.approach_weights</code> is not PLS-PM.</p>
</td></tr>
<tr><td><code id="foreman_+3A_.pls_modes">.PLS_modes</code></td>
<td>
<p>Either a named list specifying the mode that should be used for
each construct in the form <code>"construct_name" = mode</code>, a single character
string giving the mode that should be used for all constructs, or <code>NULL</code>.
Possible choices for <code>mode</code> are: &quot;<em>modeA</em>&quot;, &quot;<em>modeB</em>&quot;, &quot;<em>modeBNNLS</em>&quot;,
&quot;<em>unit</em>&quot;, &quot;<em>PCA</em>&quot;, a single integer or
a vector of fixed weights of the same length as there are indicators for the
construct given by <code>"construct_name"</code>. If only a single number is provided this is identical to
using unit weights, as weights are rescaled such that the related composite
has unit variance.  Defaults to <code>NULL</code>.
If <code>NULL</code> the appropriate mode according to the type
of construct used is chosen. Ignored if <code>.approach_weight</code> is not PLS-PM.</p>
</td></tr>
<tr><td><code id="foreman_+3A_.pls_weight_scheme_inner">.PLS_weight_scheme_inner</code></td>
<td>
<p>Character string. The inner weighting scheme
used by PLS-PM. One of: &quot;<em>centroid</em>&quot;, &quot;<em>factorial</em>&quot;, or &quot;<em>path</em>&quot;.
Defaults to &quot;<em>path</em>&quot;. Ignored if <code>.approach_weight</code> is not PLS-PM.</p>
</td></tr>
<tr><td><code id="foreman_+3A_.reliabilities">.reliabilities</code></td>
<td>
<p>A character vector of <code>"name" = value</code> pairs,
where <code>value</code> is a number between 0 and 1 and <code>"name"</code> a character string
of the corresponding construct name, or <code>NULL</code>. Reliabilities
may be given for a subset of the constructs. Defaults to <code>NULL</code> in which case
reliabilities are estimated by <code>csem()</code>. Currently, only supported for
<code>.approach_weights = "PLS-PM"</code>.</p>
</td></tr>
<tr><td><code id="foreman_+3A_.starting_values">.starting_values</code></td>
<td>
<p>A named list of vectors where the
list names are the construct names whose indicator weights the user
wishes to set. The vectors must be named vectors of <code>"indicator_name" = value</code>
pairs, where <code>value</code> is the (scaled or unscaled) starting weight. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="foreman_+3A_.tolerance">.tolerance</code></td>
<td>
<p>Double. The tolerance criterion for convergence.
Defaults to <code>1e-05</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+csem">csem</a>, <a href="#topic+cSEMResults">cSEMResults</a>
</p>

<hr>
<h2 id='getConstructScores'>Get construct scores</h2><span id='topic+getConstructScores'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getConstructScores(
 .object        = NULL,
 .standardized  = TRUE
 )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getConstructScores_+3A_.object">.object</code></td>
<td>
<p>An R object of class <a href="#topic+cSEMResults">cSEMResults</a> resulting from a call to <code><a href="#topic+csem">csem()</a></code>.</p>
</td></tr>
<tr><td><code id="getConstructScores_+3A_.standardized">.standardized</code></td>
<td>
<p>Logical. Should standardized scores be returned? Defaults
to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Get the standardized or unstandardized construct scores.
</p>


<h3>Value</h3>

<p>A list of three with elements <code>Construct_scores</code>, <code>W_used</code>,
<code>Indicators_used</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+csem">csem()</a></code>, <a href="#topic+cSEMResults">cSEMResults</a>
</p>

<hr>
<h2 id='getParameterNames'>Internal: Parameter names</h2><span id='topic+getParameterNames'></span>

<h3>Description</h3>

<p>Based on a model in <a href="lavaan.html#topic+model.syntax">lavaan model syntax</a>, returns the
names of the parameters of the structural
model, the measurement/composite model and the weight relationship. Used
by <code><a href="#topic+testMGD">testMGD()</a></code> to extract the names of the parameters to compare across groups
according to the test proposed by Chin and Dibbern (2010).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getParameterNames(
           .object  = args_default()$.object,
           .model   = args_default()$.model
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getParameterNames_+3A_.object">.object</code></td>
<td>
<p>An R object of class <a href="#topic+cSEMResults">cSEMResults</a> resulting from a call to <code><a href="#topic+csem">csem()</a></code>.</p>
</td></tr>
<tr><td><code id="getParameterNames_+3A_.model">.model</code></td>
<td>
<p>A model in <a href="lavaan.html#topic+model.syntax">lavaan model syntax</a> indicating which
parameters (i.e, path (<code>~</code>), loadings (<code style="white-space: pre;">&#8288;=~&#8288;</code>), or weights (<code style="white-space: pre;">&#8288;&lt;~&#8288;</code>)) should be
compared across groups. Defaults to <code>NULL</code> in which case all parameters of the model
are compared.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements <code>names_path</code>, <code>names_loadings</code>, and <code>names_weights</code>
containing the names of the structural parameters, the loadings,
and the weight to compare across groups.
</p>


<h3>References</h3>

<p>Chin WW, Dibbern J (2010).
&ldquo;An Introduction to a Permutation Based Procedure for Multi-Group PLS Analysis: Results of Tests of Differences on Simulated Data and a Cross Cultural Analysis of the Sourcing of Information System Services Between Germany and the USA.&rdquo;
In <em>Handbook of Partial Least Squares</em>, 171&ndash;193.
Springer Berlin Heidelberg.
<a href="https://doi.org/10.1007/978-3-540-32827-8_8">doi:10.1007/978-3-540-32827-8_8</a>.
</p>

<hr>
<h2 id='getRelevantParameters'>Internal: Extract relevant parameters from several cSEMResults_multi</h2><span id='topic+getRelevantParameters'></span>

<h3>Description</h3>

<p>Extract the relevant parameters from a cSEMResult_multi object in <code>.object</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRelevantParameters(
  .object     = args_default()$.object,
  .model      = args_default()$.model
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getRelevantParameters_+3A_.object">.object</code></td>
<td>
<p>An R object of class <a href="#topic+cSEMResults">cSEMResults</a> resulting from a call to <code><a href="#topic+csem">csem()</a></code>.</p>
</td></tr>
<tr><td><code id="getRelevantParameters_+3A_.model">.model</code></td>
<td>
<p>A model in <a href="lavaan.html#topic+model.syntax">lavaan model syntax</a> indicating which
parameters (i.e., path (<code>~</code>), loadings (<code style="white-space: pre;">&#8288;=~&#8288;</code>), or weights (<code style="white-space: pre;">&#8288;&lt;~&#8288;</code>)) should be
compared across groups. Defaults to <code>NULL</code> in which case all parameters of the model
are compared.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of length equal to the number of groups in <code>.object</code>.
Each list element is itself a list of three. The first list element contains
the relevant parameter estimates of the structural model, the second
list element the relevant estimated loadings, and the third
the relevant estimated weights.
</p>

<hr>
<h2 id='getValuesFloodlight'>Internal: Helper for doNonlinearEffectsAnalysis()</h2><span id='topic+getValuesFloodlight'></span>

<h3>Description</h3>

<p>Function that calculates the values required for the floodlight analysis,
namely 1) partial effect of the independent variable on the dependent variable
for each bootstrap run and for the original estimation for each step of the moderator
2) alpha/2 and 1-alpha/2 quantile of the bootstrap estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getValuesFloodlight(
  .model = NULL,
  .path_coefficients = args_default()$.path_coefficients,
  .dependent = args_default()$.dependent,
  .independent = args_default()$.independent,
  .moderator = args_default()$.moderator,
  .steps_mod = args_default()$.steps_mod,
  .value_independent = args_default()$.value_independent,
  .alpha = args_default()$.alpha
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getValuesFloodlight_+3A_.model">.model</code></td>
<td>
<p>A model in <a href="lavaan.html#topic+model.syntax">lavaan model syntax</a>
or a <a href="#topic+cSEMModel">cSEMModel</a> list.</p>
</td></tr>
<tr><td><code id="getValuesFloodlight_+3A_.path_coefficients">.path_coefficients</code></td>
<td>
<p>List. A list that contains the resampled and the original
path coefficient estimates. Typically a part of a <code>cSEMResults_resampled</code> object.
Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="getValuesFloodlight_+3A_.dependent">.dependent</code></td>
<td>
<p>Character string. The name of the dependent variable.</p>
</td></tr>
<tr><td><code id="getValuesFloodlight_+3A_.independent">.independent</code></td>
<td>
<p>Character string. The name of the independent variable.</p>
</td></tr>
<tr><td><code id="getValuesFloodlight_+3A_.moderator">.moderator</code></td>
<td>
<p>Character string. The name of the moderator variable.</p>
</td></tr>
<tr><td><code id="getValuesFloodlight_+3A_.steps_mod">.steps_mod</code></td>
<td>
<p>A numeric vector. Steps used for the moderator variable in calculating
the simple effects of an independent variable on the dependent variable.
Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="getValuesFloodlight_+3A_.value_independent">.value_independent</code></td>
<td>
<p>Integer. Only required for floodlight analysis;
The value of the independent variable in case that it appears as a
higher-order term.</p>
</td></tr>
<tr><td><code id="getValuesFloodlight_+3A_.alpha">.alpha</code></td>
<td>
<p>An integer or a numeric vector of significance levels.
Defaults to <code>0.05</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only variables that comprise the independent variable are taken into account.
If it contains a variable other than the independent variable and the moderator
the effect is set to zero as the other variables are evaluated at their means (=0),
hence the effect is zero.
</p>

<hr>
<h2 id='handleArgs'>Internal: Handle arguments</h2><span id='topic+handleArgs'></span>

<h3>Description</h3>

<p>Internal helper function to handle arguments passed to any function within <code>cSEM</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>handleArgs(.args_used)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="handleArgs_+3A_.args_used">.args_used</code></td>
<td>
<p>A list of argument names and user picked values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <a href="#topic+args_default">args_default</a> list, with default values
changed to the values given by the user.
</p>

<hr>
<h2 id='infer'>Inference</h2><span id='topic+infer'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>infer(
 .object            = NULL,
 .quantity          = c("all", "mean", "sd", "bias", "CI_standard_z", 
                        "CI_standard_t", "CI_percentile", "CI_basic", 
                        "CI_bc", "CI_bca", "CI_t_interval"),
 .alpha             = 0.05,
 .bias_corrected    = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="infer_+3A_.object">.object</code></td>
<td>
<p>An R object of class <a href="#topic+cSEMResults">cSEMResults</a> resulting from a call to <code><a href="#topic+csem">csem()</a></code>.</p>
</td></tr>
<tr><td><code id="infer_+3A_.quantity">.quantity</code></td>
<td>
<p>Character string. Which statistic should be returned?
One of &quot;<em>all</em>&quot;, &quot;<em>mean</em>&quot;, &quot;<em>sd</em>&quot;, &quot;<em>bias</em>&quot;, &quot;<em>CI_standard_z</em>&quot;, &quot;<em>CI_standard_t</em>&quot;,
&quot;<em>CI_percentile</em>&quot;, &quot;<em>CI_basic</em>&quot;, &quot;<em>CI_bc</em>&quot;, &quot;<em>CI_bca</em>&quot;, &quot;<em>CI_t_interval</em>&quot;
Defaults to &quot;<em>all</em>&quot; in which case all quantities that do not require
additional resampling are returned, i.e., all quantities but &quot;<em>CI_bca</em>&quot;, &quot;<em>CI_t_interval</em>&quot;.</p>
</td></tr>
<tr><td><code id="infer_+3A_.alpha">.alpha</code></td>
<td>
<p>An integer or a numeric vector of significance levels.
Defaults to <code>0.05</code>.</p>
</td></tr>
<tr><td><code id="infer_+3A_.bias_corrected">.bias_corrected</code></td>
<td>
<p>Logical. Should the standard and the tStat
confidence interval be bias-corrected using the bootstrapped bias estimate?
If <code>TRUE</code> the confidence interval for some estimated parameter <code>theta</code>
is centered at <code style="white-space: pre;">&#8288;2*theta - theta*_hat&#8288;</code>,
where <code style="white-space: pre;">&#8288;theta*_hat&#8288;</code> is the average over all <code>.R</code> bootstrap estimates of <code>theta</code>.
Defaults to <code>TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculate common inferential quantities. For users interested in the
estimated standard errors, t-values, p-values and/or confidences
intervals of the path, weight or loading estimates, calling <code><a href="#topic+summarize">summarize()</a></code>
directly will usually be more convenient as it has a much more
user-friendly print method. <code><a href="#topic+infer">infer()</a></code> is useful for comparing
different confidence interval estimates.
</p>
<p><code><a href="#topic+infer">infer()</a></code> is a convenience wrapper around a
number of internal functions that compute a particular inferential
quantity, i.e., a value or set of values to be used in statistical inference.
</p>
<p><span class="pkg">cSEM</span> relies on resampling (bootstrap and jackknife) as the basis for
the computation of e.g., standard errors or confidence intervals.
Consequently, <code><a href="#topic+infer">infer()</a></code> requires resamples to work. Technically,
the <a href="#topic+cSEMResults">cSEMResults</a> object used in the call to <code><a href="#topic+infer">infer()</a></code> must
therefore also have class attribute <code>cSEMResults_resampled</code>. If
the object provided by the user does not contain resamples yet,
<code><a href="#topic+infer">infer()</a></code> will obtain bootstrap resamples first.
Naturally, computation will take longer in this case.
</p>
<p><code><a href="#topic+infer">infer()</a></code> does as much as possible in the  background. Hence, every time
<code><a href="#topic+infer">infer()</a></code> is called on a <a href="#topic+cSEMResults">cSEMResults</a> object the quantities chosen by
the user are automatically computed for every estimated parameter
contained in the object. By default all possible quantities are
computed (<code>.quantity = all</code>). The following table list the available
inferential quantities alongside a brief description. Implementation and
terminology of the confidence intervals is based on
Hesterberg (2015) and
Davison and Hinkley (1997).
</p>

<dl>
<dt><code>"mean"</code>, <code>"sd"</code></dt><dd><p>The mean or the standard deviation
over all <code>M</code> resample estimates of a generic statistic or parameter.</p>
</dd>
<dt><code>"bias"</code></dt><dd><p>The difference between the resample mean and the original
estimate of a generic statistic or parameter.</p>
</dd>
<dt><code>"CI_standard_z"</code> and <code>"CI_standard_t"</code></dt><dd><p>The standard confidence interval
for a generic statistic or parameter with standard errors estimated by
the resample standard deviation. While <code>"CI_standard_z"</code> assumes a
standard normally distributed statistic,
<code>"CI_standard_t"</code> assumes a t-statistic with N - 1 degrees of freedom.</p>
</dd>
<dt><code>"CI_percentile"</code></dt><dd><p>The percentile confidence interval. The lower and
upper bounds of the confidence interval are estimated as the alpha and
1-alpha quantiles of the distribution of the resample estimates.</p>
</dd>
<dt><code>"CI_basic"</code></dt><dd><p>The basic confidence interval also called the reverse
bootstrap percentile confidence interval. See Hesterberg (2015)
for details.</p>
</dd>
<dt><code>"CI_bc"</code></dt><dd><p>The bias corrected (Bc) confidence interval. See
Davison and Hinkley (1997) for details.</p>
</dd>
<dt><code>"CI_bca"</code></dt><dd><p>The bias-corrected and accelerated (Bca) confidence interval.
Requires additional jackknife resampling to compute the influence values.
See Davison and Hinkley (1997) for details.</p>
</dd>
<dt><code>"CI_t_interval"</code></dt><dd><p>The &quot;studentized&quot; t-confidence interval. If based on bootstrap
resamples the interval is also called the bootstrap t-interval
confidence interval. See Hesterberg (2015) on page 381.
Requires resamples of resamples. See <code><a href="#topic+resamplecSEMResults">resamplecSEMResults()</a></code>.</p>
</dd>
</dl>

<p>By default, all but the studendized t-interval confidence interval and the
bias-corrected and accelerated confidence interval are calculated. The
reason for excluding these quantities by default are that both require
an additional resampling step. The former requires
jackknife estimates to compute influence values and the latter requires
double bootstrap. Both can potentially be time consuming.
Hence, computation is triggered only if explicitly chosen.
</p>


<h3>Value</h3>

<p>A list of class <code>cSEMInfer</code>.
</p>


<h3>References</h3>

<p>Davison AC, Hinkley DV (1997).
<em>Bootstrap Methods and their Application</em>.
Cambridge University Press.
<a href="https://doi.org/10.1017/cbo9780511802843">doi:10.1017/cbo9780511802843</a>.<br /><br /> Hesterberg TC (2015).
&ldquo;What Teachers Should Know About the Bootstrap: Resampling in the Undergraduate Statistics Curriculum.&rdquo;
<em>The American Statistician</em>, <b>69</b>(4), 371&ndash;386.
<a href="https://doi.org/10.1080/00031305.2015.1089789">doi:10.1080/00031305.2015.1089789</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+csem">csem()</a></code>, <code><a href="#topic+resamplecSEMResults">resamplecSEMResults()</a></code>, <code><a href="#topic+summarize">summarize()</a></code> <a href="#topic+cSEMResults">cSEMResults</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- "
# Structural model
QUAL ~ EXPE
EXPE ~ IMAG
SAT  ~ IMAG + EXPE + QUAL + VAL
LOY  ~ IMAG + SAT
VAL  ~ EXPE + QUAL

# Measurement model
EXPE =~ expe1 + expe2 + expe3 + expe4 + expe5
IMAG =~ imag1 + imag2 + imag3 + imag4 + imag5
LOY  =~ loy1  + loy2  + loy3  + loy4
QUAL =~ qual1 + qual2 + qual3 + qual4 + qual5
SAT  =~ sat1  + sat2  + sat3  + sat4
VAL  =~ val1  + val2  + val3  + val4
"
  
## Estimate the model with bootstrap resampling 
a &lt;- csem(satisfaction, model, .resample_method = "bootstrap", .R = 20,
          .handle_inadmissibles = "replace")

## Compute inferential quantities
inf &lt;- infer(a)

inf$Path_estimates$CI_basic
inf$Indirect_effect$sd

### Compute the bias-corrected and accelerated and/or the studentized t-inverval.
## For the studentied t-interval confidence interval a double bootstrap is required.
## This is pretty time consuming.
## Not run: 
  inf &lt;- infer(a, .quantity = c("all", "CI_bca")) # requires jackknife estimates 
  
## Estimate the model with double bootstrap resampling:
# Notes:
#   1. The .resample_method2 arguments triggers a bootstrap of each bootstrap sample
#   2. The double bootstrap is is very time consuming, consider setting 
#      `.eval_plan = "multisession`. 
a1 &lt;- csem(satisfaction, model, .resample_method = "bootstrap", .R = 499,
          .resample_method2 = "bootstrap", .R2 = 199, .handle_inadmissibles = "replace") 
infer(a1, .quantity = "CI_t_interval")
## End(Not run)

</code></pre>

<hr>
<h2 id='inference_helper'>Internal: Helper for infer()</h2><span id='topic+inference_helper'></span><span id='topic+MeanResample'></span><span id='topic+SdResample'></span><span id='topic+BiasResample'></span><span id='topic+StandardCIResample'></span><span id='topic+PercentilCIResample'></span><span id='topic+BasicCIResample'></span><span id='topic+TStatCIResample'></span><span id='topic+BcCIResample'></span><span id='topic+BcaCIResample'></span>

<h3>Description</h3>

<p>Collection of various functions that compute an inferential quantity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MeanResample(.first_resample)

SdResample(.first_resample, .resample_method, .n)

BiasResample(.first_resample, .resample_method, .n)

StandardCIResample(
  .first_resample,
  .bias_corrected,
  .dist = c("z", "t"),
  .df = c("type1", "type2"),
  .resample_method,
  .n,
  .probs
)

PercentilCIResample(.first_resample, .probs)

BasicCIResample(.first_resample, .bias_corrected, .probs)

TStatCIResample(
  .first_resample,
  .second_resample,
  .bias_corrected,
  .resample_method,
  .resample_method2,
  .n,
  .probs
)

BcCIResample(.first_resample, .probs)

BcaCIResample(.object, .first_resample, .probs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inference_helper_+3A_.first_resample">.first_resample</code></td>
<td>
<p>A list containing the <code>.R</code> resamples based on the original
data obtained by resamplecSEMResults().</p>
</td></tr>
<tr><td><code id="inference_helper_+3A_.resample_method">.resample_method</code></td>
<td>
<p>Character string. The resampling method to use. One of:
&quot;<em>none</em>&quot;, &quot;<em>bootstrap</em>&quot; or &quot;<em>jackknife</em>&quot;. Defaults to &quot;<em>none</em>&quot;.</p>
</td></tr>
<tr><td><code id="inference_helper_+3A_.n">.n</code></td>
<td>
<p>Integer. The number of observations of the original data.</p>
</td></tr>
<tr><td><code id="inference_helper_+3A_.bias_corrected">.bias_corrected</code></td>
<td>
<p>Logical. Should the standard and the tStat
confidence interval be bias-corrected using the bootstrapped bias estimate?
If <code>TRUE</code> the confidence interval for some estimated parameter <code>theta</code>
is centered at <code style="white-space: pre;">&#8288;2*theta - theta*_hat&#8288;</code>,
where <code style="white-space: pre;">&#8288;theta*_hat&#8288;</code> is the average over all <code>.R</code> bootstrap estimates of <code>theta</code>.
Defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="inference_helper_+3A_.dist">.dist</code></td>
<td>
<p>Character string. The distribution to use for the critical value.
One of <em>&quot;t&quot;</em> for Student's t-distribution or <em>&quot;z&quot;</em> for the standard normal distribution.
Defaults to <em>&quot;z&quot;</em>.</p>
</td></tr>
<tr><td><code id="inference_helper_+3A_.df">.df</code></td>
<td>
<p>Character string. The method for obtaining the degrees of freedom.
Choices are &quot;<em>type1</em>&quot; and &quot;<em>type2</em>&quot;. Defaults to &quot;<em>type1</em>&quot; .</p>
</td></tr>
<tr><td><code id="inference_helper_+3A_.probs">.probs</code></td>
<td>
<p>A vector of probabilities.</p>
</td></tr>
<tr><td><code id="inference_helper_+3A_.second_resample">.second_resample</code></td>
<td>
<p>A list containing <code>.R2</code> resamples for each of the <code>.R</code>
resamples of the first run.</p>
</td></tr>
<tr><td><code id="inference_helper_+3A_.resample_method2">.resample_method2</code></td>
<td>
<p>Character string. The resampling method to use when resampling
from a resample. One of: &quot;<em>none</em>&quot;, &quot;<em>bootstrap</em>&quot; or &quot;<em>jackknife</em>&quot;. For
&quot;<em>bootstrap</em>&quot; the number of draws is provided via <code>.R2</code>. Currently,
resampling from each resample is only required for the studentized confidence
interval (&quot;<em>CI_t_interval</em>&quot;) computed by the <code><a href="#topic+infer">infer()</a></code> function. Defaults to &quot;<em>none</em>&quot;.</p>
</td></tr>
<tr><td><code id="inference_helper_+3A_.object">.object</code></td>
<td>
<p>An R object of class <a href="#topic+cSEMResults">cSEMResults</a> resulting from a call to <code><a href="#topic+csem">csem()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Implementation and terminology of the confidence intervals is based on
Hesterberg (2015) and
Davison and Hinkley (1997).
</p>


<h3>References</h3>

<p>Davison AC, Hinkley DV (1997).
<em>Bootstrap Methods and their Application</em>.
Cambridge University Press.
<a href="https://doi.org/10.1017/cbo9780511802843">doi:10.1017/cbo9780511802843</a>.<br /><br /> Hesterberg TC (2015).
&ldquo;What Teachers Should Know About the Bootstrap: Resampling in the Undergraduate Statistics Curriculum.&rdquo;
<em>The American Statistician</em>, <b>69</b>(4), 371&ndash;386.
<a href="https://doi.org/10.1080/00031305.2015.1089789">doi:10.1080/00031305.2015.1089789</a>.
</p>

<hr>
<h2 id='ITFlex'>Data: ITFlex</h2><span id='topic+ITFlex'></span>

<h3>Description</h3>

<p>A data frame containing 16 variables with 100 observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ITFlex
</code></pre>


<h3>Format</h3>

<p>A data frame containing the following variables:
</p>

<dl>
<dt><code>ITCOMP1</code></dt><dd><p>Software applications can be easily transported and
used across multiple platforms.</p>
</dd>
<dt><code>ITCOMP2</code></dt><dd><p>Our firm provides multiple interfaces or entry points
(e.g., web access) for external end users.</p>
</dd>
<dt><code>ITCOMP3</code></dt><dd><p>Our firm establishes corporate rules and standards for
hardware and operating systems to ensure platform compatibility.</p>
</dd>
<dt><code>ITCOMP4</code></dt><dd><p>Data captured in one part of our organization are
immediately available to everyone in the firm.</p>
</dd>
<dt><code>ITCONN1</code></dt><dd><p>Our organization has electronic links and connections
throughout the entire firm.</p>
</dd>
<dt><code>ITCONN2</code></dt><dd><p>Our firm is linked to business partners through
electronic channels (e.g., websites, e-mail, wireless devices, electronic data interchange).</p>
</dd>
<dt><code>ITCONN3</code></dt><dd><p>All remote, branch, and mobile offices are connected to
the central office.</p>
</dd>
<dt><code>ITCONN4</code></dt><dd><p>There are very few identifiable communications
bottlenecks within our firm.</p>
</dd>
<dt><code>MOD1</code></dt><dd><p>Our firm possesses a great speed in developing new
business applications or modifying existing applications.</p>
</dd>
<dt><code>MOD2</code></dt><dd><p>Our corporate database is able to communicate in
several different protocols.</p>
</dd>
<dt><code>MOD3</code></dt><dd><p>Reusable software modules are widely used in new
systems development.</p>
</dd>
<dt><code>MOD4</code></dt><dd><p>IT personnel use object-oriented and prepackaged
modular tools to create software applications.</p>
</dd>
<dt><code>ITPSF1</code></dt><dd><p>Our IT personnel have the ability to work effectively in
cross-functional teams.</p>
</dd>
<dt><code>ITPSF2</code></dt><dd><p>Our IT personnel are able to interpret business problems
and develop appropriate technical solutions.</p>
</dd>
<dt><code>ITPSF3</code></dt><dd><p>Our IT personnel are self-directed and proactive.</p>
</dd>
<dt><code>ITPSF4</code></dt><dd><p>Our IT personnel are knowledgeable about the key
success factors in our firm.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The dataset was studied by Benitez et al. (2018) and is used in
Henseler (2021) for demonstration purposes, see the
corresponding tutorial.
All questionnaire items are measured on a 5-point scale.
</p>


<h3>Source</h3>

<p>The data was collected through a survey by Benitez et al. (2018).
</p>


<h3>References</h3>

<p>Benitez J, Ray G, Henseler J (2018).
&ldquo;Impact of Information Technology Infrastructure Flexibility on Mergers and Acquisitions.&rdquo;
<em>MIS Quarterly</em>, <b>42</b>(1), 25&ndash;43.<br /><br /> Henseler J (2021).
<em>Composite-Based Structural Equation Modeling: Analyzing Latent and Emergent Variables</em>.
Guilford Press, New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#============================================================================
# Example is taken from Henseler (2020)
#============================================================================
model_IT_Fex="
# Composite models
ITComp  &lt;~ ITCOMP1 + ITCOMP2 + ITCOMP3 + ITCOMP4
Modul   &lt;~ MOD1 + MOD2 + MOD3 + MOD4
ITConn  &lt;~ ITCONN1 + ITCONN2 + ITCONN3 + ITCONN4
ITPers  &lt;~ ITPSF1 + ITPSF2 + ITPSF3 + ITPSF4

# Saturated structural model
ITPers ~ ITComp + Modul + ITConn
Modul  ~ ITComp + ITConn 
ITConn ~ ITComp 
"

out &lt;- csem(.data = ITFlex, .model = model_IT_Fex,
           .PLS_weight_scheme_inner = 'factorial',
           .tolerance = 1e-06,
           .PLS_ignore_structural_model = TRUE)

</code></pre>

<hr>
<h2 id='LancelotMiltgenetal2016'>Data: LancelotMiltgenetal2016</h2><span id='topic+LancelotMiltgenetal2016'></span>

<h3>Description</h3>

<p>A data frame containing 10 variables with 1090 observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LancelotMiltgenetal2016
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 1090 rows and 11 columns.
</p>


<h3>Details</h3>

<p>The data was analysed by Lancelot-Miltgen et al. (2016)
to study young consumers’ adoption intentions of a location tracker technology
in the light of privacy concerns. It is also used in
Henseler (2021) for demonstration purposes, see the
corresponding tutorial.
</p>


<h3>Source</h3>

<p>This data has been collected through a cooperation with the European Commission
Joint Research Center Institute for Prospective Technological Studies, contract
“Young People and Emerging Digital Services: An Exploratory Survey on Motivations,
Perceptions, and Acceptance of Risk” (EC JRC Contract IPTS No: 150876-2007 F1ED-FR).
</p>


<h3>References</h3>

<p>Henseler J (2021).
<em>Composite-Based Structural Equation Modeling: Analyzing Latent and Emergent Variables</em>.
Guilford Press, New York.<br /><br /> Lancelot-Miltgen C, Henseler J, Gelhard C, Popovic A (2016).
&ldquo;Introducing new products that affect consumer privacy: A mediation model.&rdquo;
<em>Journal of Business Research</em>, <b>69</b>(10), 4659&ndash;4666.
<a href="https://doi.org/10.1016/j.jbusres.2016.04.015">doi:10.1016/j.jbusres.2016.04.015</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#============================================================================
# Example is taken from Henseler (2020)
#============================================================================
model_Med &lt;- "
# Reflective measurement model
Trust =~ trust1 + trust2
PrCon =~ privcon1 + privcon2 + privcon3 + privcon4
Risk  =~ risk1 + risk2 + risk3
Int   =~ intent1 + intent2

# Structural model
Int   ~ Trust + PrCon + Risk
Risk  ~ Trust + PrCon
Trust ~ PrCon
"

out &lt;- csem(.data = LancelotMiltgenetal2016, .model = model_Med,
            .PLS_weight_scheme_inner = 'factorial',
            .tolerance = 1e-06
)

</code></pre>

<hr>
<h2 id='moments'>Internal: Calculate consistent moments of a nonlinear model</h2><span id='topic+moments'></span><span id='topic+SingleSingle'></span><span id='topic+SingleQuadratic'></span><span id='topic+SingleCubic'></span><span id='topic+SingleTwInter'></span><span id='topic+SingleThrwInter'></span><span id='topic+SingleQuadTwInter'></span><span id='topic+QuadraticQuadratic'></span><span id='topic+QuadraticCubic'></span><span id='topic+QuadraticTwInter'></span><span id='topic+QuadraticThrwInter'></span><span id='topic+QuadraticQuadTwInter'></span><span id='topic+CubicCubic'></span><span id='topic+CubicTwInter'></span><span id='topic+CubicThrwInter'></span><span id='topic+CubicQuadTwInter'></span><span id='topic+TwInterTwInter'></span><span id='topic+TwInterThrwInter'></span><span id='topic+TwInterQuadTwInter'></span><span id='topic+ThrwInterThrwInter'></span><span id='topic+ThrwInterQuadTwInter'></span><span id='topic+QuadTwInercQuadTwInter'></span>

<h3>Description</h3>

<p>Collection of various moment estimators. See <a href="#topic+classifyConstructs">classifyConstructs</a> for a list of
possible moments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SingleSingle(.i, .j, .Q, .H)

SingleQuadratic(.i, .j, .Q, .H)

SingleCubic(.i, .j, .Q, .H)

SingleTwInter(.i, .j, .Q, .H)

SingleThrwInter(.i, .j, .Q, .H)

SingleQuadTwInter(.i, .j, .Q, .H)

QuadraticQuadratic(.i, .j, .Q, .H)

QuadraticCubic(.i, .j, .Q, .H)

QuadraticTwInter(.i, .j, .Q, .H)

QuadraticThrwInter(.i, .j, .Q, .H)

QuadraticQuadTwInter(.i, .j, .Q, .H)

CubicCubic(.i, .j, .Q, .H)

CubicTwInter(.i, .j, .Q, .H)

CubicThrwInter(.i, .j, .Q, .H)

CubicQuadTwInter(.i, .j, .Q, .H)

TwInterTwInter(.i, .j, .Q, .H)

TwInterThrwInter(.i, .j, .Q, .H)

TwInterQuadTwInter(.i, .j, .Q, .H)

ThrwInterThrwInter(.i, .j, .Q, .H)

ThrwInterQuadTwInter(.i, .j, .Q, .H)

QuadTwInercQuadTwInter(.i, .j, .Q, .H)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="moments_+3A_.i">.i</code></td>
<td>
<p>Row index</p>
</td></tr>
<tr><td><code id="moments_+3A_.j">.j</code></td>
<td>
<p>Column index</p>
</td></tr>
<tr><td><code id="moments_+3A_.q">.Q</code></td>
<td>
<p>A vector of composite-construct correlations with element names equal to
the names of the J construct names used in the measurement model. Note
Q^2 is also called the reliability coefficient.</p>
</td></tr>
<tr><td><code id="moments_+3A_.h">.H</code></td>
<td>
<p>The (N x J) matrix of construct scores.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>M is the matrix of the sample counterparts (estimates) of the
left-hand side terms in Equation (21) - (24) (Dijkstra and Schermelleh-Engel 2014).
The label &quot;M&quot; did not appear in the paper and is only used in the package.
Similar is suggested by Wall and Amemiya (2000) using classical factor scores.
</p>


<h3>References</h3>

<p>Dijkstra TK, Schermelleh-Engel K (2014).
&ldquo;Consistent Partial Least Squares For Nonlinear Structural Equation Models.&rdquo;
<em>Psychometrika</em>, <b>79</b>(4), 585&ndash;604.<br /><br /> Wall MM, Amemiya Y (2000).
&ldquo;Estimation for polynomial structural equation models.&rdquo;
<em>Journal of the American Statistical Association</em>, <b>95</b>(451), 929&ndash;940.
</p>

<hr>
<h2 id='nonlinear_estimation_utilities'>Internal: Utility functions for the estimation of nonlinear models</h2><span id='topic+nonlinear_estimation_utilities'></span><span id='topic+f1'></span><span id='topic+f2'></span><span id='topic+f3'></span><span id='topic+f4'></span><span id='topic+f5'></span>

<h3>Description</h3>

<p>Internal: Utility functions for the estimation of nonlinear models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f1(.i, .j)

f2(.i, .j, .select_from, .Q, .H)

f3(.i, .j, .Q, .H)

f4(.i, .j, .Q, .H, .var_struc_error, .temp = NULL)

f5(.i, .j, .H, .Q, .var_struc_error)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nonlinear_estimation_utilities_+3A_.i">.i</code></td>
<td>
<p>Row index</p>
</td></tr>
<tr><td><code id="nonlinear_estimation_utilities_+3A_.j">.j</code></td>
<td>
<p>Column index</p>
</td></tr>
<tr><td><code id="nonlinear_estimation_utilities_+3A_.select_from">.select_from</code></td>
<td>
<p>matrix to select from</p>
</td></tr>
<tr><td><code id="nonlinear_estimation_utilities_+3A_.q">.Q</code></td>
<td>
<p>A vector of composite-construct correlations with element names equal to
the names of the J construct names used in the measurement model. Note
Q^2 is also called the reliability coefficient.</p>
</td></tr>
<tr><td><code id="nonlinear_estimation_utilities_+3A_.h">.H</code></td>
<td>
<p>The (N x J) matrix of construct scores.</p>
</td></tr>
</table>

<hr>
<h2 id='parseModel'>Parse lavaan model</h2><span id='topic+parseModel'></span>

<h3>Description</h3>

<p>Turns a model written in <a href="lavaan.html#topic+model.syntax">lavaan model syntax</a> into a
<a href="#topic+cSEMModel">cSEMModel</a> list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parseModel(
  .model        = NULL, 
  .instruments  = NULL, 
  .check_errors = TRUE
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parseModel_+3A_.model">.model</code></td>
<td>
<p>A model in <a href="lavaan.html#topic+model.syntax">lavaan model syntax</a>
or a <a href="#topic+cSEMModel">cSEMModel</a> list.</p>
</td></tr>
<tr><td><code id="parseModel_+3A_.instruments">.instruments</code></td>
<td>
<p>A named list of vectors of instruments. The names
of the list elements are the names of the dependent (LHS) constructs of the structural
equation whose explanatory variables are endogenous. The vectors
contain the names of the instruments corresponding to each equation. Note
that exogenous variables of a given equation <strong>must</strong> be supplied as
instruments for themselves. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="parseModel_+3A_.check_errors">.check_errors</code></td>
<td>
<p>Logical. Should the model to parse be checked for correctness
in a sense that all necessary components to estimate the model are given?
Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Instruments must be supplied separately as a named list
of vectors of instruments.
The names of the list elements are the names of the dependent constructs of
the structural equation whose explanatory variables are endogenous.
The vectors contain the names of the instruments corresponding to each
equation. Note that exogenous variables of a given equation <strong>must</strong> be
supplied as instruments for themselves.
</p>
<p>By default <code>parseModel()</code> attempts to check if the model provided is correct
in a sense that all necessary components required to estimate the
model are specified (e.g., a construct of the structural model has at least
1 item). To prevent checking for errors use <code>.check_errors = FALSE</code>.
</p>


<h3>Value</h3>

<p>An object of class <a href="#topic+cSEMModel">cSEMModel</a> is a standardized list containing the
following components. J stands for the number of constructs and K for the number
of indicators.
</p>

<dl>
<dt><code style="white-space: pre;">&#8288;$structural&#8288;</code></dt><dd><p>A matrix mimicking the structural relationship between
constructs. If constructs are only linearly related, <code>structural</code> is
of dimension (J x J) with row- and column names equal to the construct
names. If the structural model contains nonlinear relationships
<code>structural</code> is (J x (J + J*)) where J* is the number of
nonlinear terms. Rows are ordered such that exogenous constructs are always
first, followed by constructs that only depend on exogenous constructs and/or
previously ordered constructs.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$measurement&#8288;</code></dt><dd><p>A (J x K) matrix mimicking the measurement/composite
relationship between constructs and their related indicators. Rows are in the same
order as the matrix <code style="white-space: pre;">&#8288;$structural&#8288;</code> with row names equal to
the construct names. The order of the columns is such that <code style="white-space: pre;">&#8288;$measurement&#8288;</code>
forms a block diagonal matrix.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$error_cor&#8288;</code></dt><dd><p>A (K x K) matrix mimicking the measurement error
correlation relationship. The row and column order is identical to
the column order of <code style="white-space: pre;">&#8288;$measurement&#8288;</code>.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$cor_specified&#8288;</code></dt><dd><p>A matrix indicating the correlation relationships
between any variables of the model as specified by the user. Mainly for internal purposes.
Note that <code style="white-space: pre;">&#8288;$cor_specified&#8288;</code> may also contain inadmissible correlations
such as a correlation between measurement errors indicators and constructs.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$construct_type&#8288;</code></dt><dd><p>A named vector containing the names of each construct
and their respective type (&quot;Common factor&quot; or &quot;Composite&quot;).</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$construct_order&#8288;</code></dt><dd><p>A named vector containing the names of each construct
and their respective order (&quot;First order&quot; or &quot;Second order&quot;).</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$model_type&#8288;</code></dt><dd><p>The type of model (&quot;Linear&quot; or &quot;Nonlinear&quot;).</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$instruments&#8288;</code></dt><dd><p>Only if instruments are supplied: a list of structural
equations relating endogenous RHS variables to instruments.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$indicators&#8288;</code></dt><dd><p>The names of the indicators
(i.e., observed variables and/or first-order constructs)</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$cons_exo&#8288;</code></dt><dd><p>The names of the exogenous constructs of the structural model
(i.e., variables that do not appear on the LHS of any structural equation)</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$cons_endo&#8288;</code></dt><dd><p>The names of the endogenous constructs of the structural model
(i.e., variables that appear on the LHS of at least one structural equation)</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$vars_2nd&#8288;</code></dt><dd><p>The names of the constructs modeled as second orders.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$vars_attached_to_2nd&#8288;</code></dt><dd><p>The names of the constructs forming or building
a second order construct.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$vars_not_attached_to_2nd&#8288;</code></dt><dd><p>The names of the constructs not forming or building
a second order construct.</p>
</dd>
</dl>

<p>It is possible to supply an incomplete list to <code><a href="#topic+parseModel">parseModel()</a></code>, resulting
in an incomplete <a href="#topic+cSEMModel">cSEMModel</a> list which can be passed
to all functions that require <code>.csem_model</code> as a mandatory argument. Currently,
only the structural and the measurement matrix are required.
However, specifying an incomplete <a href="#topic+cSEMModel">cSEMModel</a> list may lead to unexpected behavior
and errors. Use with care.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># ===========================================================================
# Providing a model in lavaan syntax 
# ===========================================================================
model &lt;- "
# Structural model
y1 ~ y2 + y3

# Measurement model
y1 =~ x1 + x2 + x3
y2 =~ x4 + x5
y3 =~ x6 + x7

# Error correlation
x1 ~~ x2
"

m &lt;- parseModel(model)
m

# ===========================================================================
# Providing a complete model in cSEM format (class cSEMModel)
# ===========================================================================
# If the model is already a cSEMModel object, the model is returned as is:

identical(m, parseModel(m)) # TRUE

# ===========================================================================
# Providing a list 
# ===========================================================================
# It is possible to provide a list that contains at least the
# elements "structural" and "measurement". This is generally discouraged
# as this may cause unexpected errors.

m_incomplete &lt;- m[c("structural", "measurement", "construct_type")]
parseModel(m_incomplete)

# Providing a list containing list names that are not part of a `cSEMModel`
# causes an error:

## Not run: 
m_incomplete[c("name_a", "name_b")] &lt;- c("hello world", "hello universe")
parseModel(m_incomplete)

## End(Not run)

# Failing to provide "structural" or "measurement" also causes an error:

## Not run: 
m_incomplete &lt;- m[c("structural", "construct_type")]
parseModel(m_incomplete)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.cSEMIPMA'><code>cSEMIPMA</code> method for <code>plot()</code></h2><span id='topic+plot.cSEMIPMA'></span>

<h3>Description</h3>

<p>Plot the importance-performance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cSEMIPMA'
plot(
  x = NULL,
  .dependent = NULL,
  .attributes = NULL,
  .level = c("construct", "indicator"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.cSEMIPMA_+3A_x">x</code></td>
<td>
<p>An R object of class <code>cSEMIPMA</code>.</p>
</td></tr>
<tr><td><code id="plot.cSEMIPMA_+3A_.dependent">.dependent</code></td>
<td>
<p>Character string. Name of the target construct for which the
importance-performance matrix should be created.</p>
</td></tr>
<tr><td><code id="plot.cSEMIPMA_+3A_.attributes">.attributes</code></td>
<td>
<p>Character string. A vector containing indicator/construct
names that should be plotted in the importance-performance matrix.
It must be at least of length 2.</p>
</td></tr>
<tr><td><code id="plot.cSEMIPMA_+3A_.level">.level</code></td>
<td>
<p>Character string. Indicates the level for which the
importance-performance matrix should be plotted. One of <code>"construct"</code> or
<code>"indicator"</code>. Defaults to <code>"construct"</code>.</p>
</td></tr>
<tr><td><code id="plot.cSEMIPMA_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+doIPMA">doIPMA()</a></code>
</p>

<hr>
<h2 id='plot.cSEMNonlinearEffects'><code>cSEMNonlinearEffects</code> method for <code>plot()</code></h2><span id='topic+plot.cSEMNonlinearEffects'></span>

<h3>Description</h3>

<p>This plot method can be used to create plots to analyze non-linear models in more
depth. In doing so the following plot types can be selected:
</p>

<dl>
<dt><code>.plot_type = "simpleeffects"</code>:</dt><dd>
<p>The plot of a simple effects analysis displays the predicted value of the
dependent variable for different values of the independent variable and the moderator.
As levels for the moderator the levels provided to the <code>doNonlinearEffectsAnalysis()</code> function
are used. Since the constructs are standardized the values of the moderator
equals the deviation from its mean measured in standard deviations.
</p>
</dd>
<dt><code>.plot_type = "surface"</code>:</dt><dd>
<p>The plot of a surface analysis displays the predicted values of an
independent variable (z). The values are predicted based on the values of the moderator
and the independent variable including all their higher-order terms.
For the values of the moderator and the independent variable steps between
their minimum and maximum values  are used.
</p>
</dd>
<dt><code>.plot_type = "floodlight"</code>:</dt><dd>
<p>The plot of a floodlight analysis displays the direct effect of an continuous
independent variable (z) on a dependent variable (y) conditional on the values
of a continuous moderator variable (x), including
the confidence interval and the Johnson-Neyman points. It is
noted that in the floodlight plot only moderation is taken into account and higher
order terms are ignored. For more details, see Spiller et al. (2013).
</p>
</dd>
</dl>

<p>Plot the predicted values of an independent variable (z)
The values are predicted based on a certain moderator and a certain
independent variable including all their higher-order terms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cSEMNonlinearEffects'
plot(x, .plot_type = "simpleeffects", .plot_package = "plotly", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.cSEMNonlinearEffects_+3A_x">x</code></td>
<td>
<p>An R object of class <code>cSEMNonlinearEffects</code>.</p>
</td></tr>
<tr><td><code id="plot.cSEMNonlinearEffects_+3A_.plot_type">.plot_type</code></td>
<td>
<p>A character string indicating the type of plot that should be produced.
Options are &quot;<em>simpleeffects</em>&quot;, &quot;<em>surface</em>&quot;, and &quot;<em>floodlight</em>&quot;. Defaults to &quot;<em>simpleeffects</em>&quot;.</p>
</td></tr>
<tr><td><code id="plot.cSEMNonlinearEffects_+3A_.plot_package">.plot_package</code></td>
<td>
<p>A character vector indicating the plot package used. Options are
&quot;<em>plotly</em>&quot;, and &quot;<em>persp</em>&quot;. Defaults to &quot;<em>plotly</em>&quot;.</p>
</td></tr>
<tr><td><code id="plot.cSEMNonlinearEffects_+3A_...">...</code></td>
<td>
<p>Additional parameters that can be passed to
<code><a href="graphics.html#topic+persp">graphics::persp</a></code>, e.g., to rotate the plot.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+doNonlinearEffectsAnalysis">doNonlinearEffectsAnalysis()</a></code>
</p>

<hr>
<h2 id='plot.cSEMPredict'><code>cSEMPredict</code> method for <code>plot()</code></h2><span id='topic+plot.cSEMPredict'></span>

<h3>Description</h3>

<p>The <code>cSEMPredict</code> method for the generic function <code><a href="graphics.html#topic+plot">plot()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cSEMPredict'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.cSEMPredict_+3A_x">x</code></td>
<td>
<p>An R object of class <code>cSEMPredict</code>.</p>
</td></tr>
<tr><td><code id="plot.cSEMPredict_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+predict">predict()</a></code>
</p>

<hr>
<h2 id='PoliticalDemocracy'>Data: political democracy</h2><span id='topic+PoliticalDemocracy'></span>

<h3>Description</h3>

<p>The Industrialization and Political Democracy dataset. This dataset is
used throughout Bollen's 1989 book (see pages 12, 17, 36 in chapter 2, pages
228 and following in chapter 7, pages 321 and following in chapter 8;
Bollen (1989)).
The dataset contains various measures of political democracy and
industrialization in developing countries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PoliticalDemocracy
</code></pre>


<h3>Format</h3>

<p>A data frame of 75 observations of 11 variables.
</p>

<dl>
<dt><code>y1</code></dt><dd><p>Expert ratings of the freedom of the press in 1960</p>
</dd>
<dt><code>y2</code></dt><dd><p>The freedom of political opposition in 1960</p>
</dd>
<dt><code>y3</code></dt><dd><p>The fairness of elections in 1960</p>
</dd>
<dt><code>y4</code></dt><dd><p>The effectiveness of the elected legislature in 1960</p>
</dd>
<dt><code>y5</code></dt><dd><p>Expert ratings of the freedom of the press in 1965</p>
</dd>
<dt><code>y6</code></dt><dd><p>The freedom of political opposition in 1965</p>
</dd>
<dt><code>y7</code></dt><dd><p>The fairness of elections in 1965</p>
</dd>
<dt><code>y8</code></dt><dd><p>The effectiveness of the elected legislature in 1965</p>
</dd>
<dt><code>x1</code></dt><dd><p>The gross national product (GNP) per capita in 1960</p>
</dd>
<dt><code>x2</code></dt><dd><p>The inanimate energy consumption per capita in 1960</p>
</dd>
<dt><code>x3</code></dt><dd><p>The percentage of the labor force in industry in 1960</p>
</dd>
</dl>



<h3>Source</h3>

<p>The <a href="https://lavaan.ugent.be/">lavaan</a> package (version 0.6-3).
</p>


<h3>References</h3>

<p>Bollen KA (1989).
<em>Structural Equations with Latent Variables</em>.
Wiley-Interscience.
ISBN 978-0471011712.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#============================================================================
# Example is taken from the lavaan website
#============================================================================
# Note: example is modified. Across-block correlations are removed
model &lt;- "
# Measurement model
  ind60 =~ x1 + x2 + x3
  dem60 =~ y1 + y2 + y3 + y4
  dem65 =~ y5 + y6 + y7 + y8
  
# Regressions / Path model
  dem60 ~ ind60
  dem65 ~ ind60 + dem60
  
# residual correlations
  y2 ~~ y4
  y6 ~~ y8
"

aa &lt;- csem(PoliticalDemocracy, model)
</code></pre>

<hr>
<h2 id='predict'>Predict indicator scores</h2><span id='topic+predict'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#maturing"><img src="../help/figures/lifecycle-maturing.svg" alt='[Maturing]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict(
 .object                   = NULL,
 .benchmark                = c("lm", "unit", "PLS-PM", "GSCA", "PCA", "MAXVAR", "NA"),
 .approach_predict         = c("earliest", "direct"),
 .cv_folds                 = 10,
 .handle_inadmissibles     = c("stop", "ignore", "set_NA"),
 .r                        = 1,
 .test_data                = NULL,
 .approach_score_target    = c("mean", "median", "mode"),
 .sim_points               = 100,
 .disattenuate             = TRUE,
 .treat_as_continuous      = TRUE,
 .approach_score_benchmark = c("mean", "median", "mode", "round"),
 .seed                     = NULL
 )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_+3A_.object">.object</code></td>
<td>
<p>An R object of class <a href="#topic+cSEMResults">cSEMResults</a> resulting from a call to <code><a href="#topic+csem">csem()</a></code>.</p>
</td></tr>
<tr><td><code id="predict_+3A_.benchmark">.benchmark</code></td>
<td>
<p>Character string. The procedure to obtain benchmark predictions.
One of &quot;<em>lm</em>&quot;, &quot;<em>unit</em>&quot;, &quot;<em>PLS-PM</em>&quot;, &quot;<em>GSCA</em>&quot;, &quot;<em>PCA</em>&quot;, &quot;<em>MAXVAR</em>&quot;, or &quot;<em>NA</em>&quot;.
Default to &quot;<em>lm</em>&quot;.</p>
</td></tr>
<tr><td><code id="predict_+3A_.approach_predict">.approach_predict</code></td>
<td>
<p>Character string. Which approach should be used to perform
predictions? One of &quot;<em>earliest</em>&quot; and &quot;<em>direct</em>&quot;. If &quot;<em>earliest</em>&quot; predictions
for indicators associated to endogenous constructs are performed using only
indicators associated to exogenous constructs. If &quot;<em>direct</em>&quot;, predictions for
indicators associated to endogenous constructs are based on indicators associated
to their direct antecedents. Defaults to &quot;<em>earliest</em>&quot;.</p>
</td></tr>
<tr><td><code id="predict_+3A_.cv_folds">.cv_folds</code></td>
<td>
<p>Integer. The number of cross-validation folds to use. Setting
<code>.cv_folds</code> to <code>N</code> (the number of observations) produces
leave-one-out cross-validation samples. Defaults to <code>10</code>.</p>
</td></tr>
<tr><td><code id="predict_+3A_.handle_inadmissibles">.handle_inadmissibles</code></td>
<td>
<p>Character string. How should inadmissible results
be treated? One of &quot;<em>stop</em>&quot;, &quot;<em>ignore</em>&quot;, or &quot;<em>set_NA</em>&quot;. If &quot;<em>stop</em>&quot;, <code><a href="#topic+predict">predict()</a></code>
will stop immediately if estimation yields an inadmissible result.
For &quot;<em>ignore</em>&quot; all results are returned even if all or some of the estimates
yielded inadmissible results.
For &quot;<em>set_NA</em>&quot; predictions based on inadmissible parameter estimates are
set to <code>NA</code>. Defaults to &quot;<em>stop</em>&quot;</p>
</td></tr>
<tr><td><code id="predict_+3A_.r">.r</code></td>
<td>
<p>Integer. The number of repetitions to use. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="predict_+3A_.test_data">.test_data</code></td>
<td>
<p>A matrix of test data with the same column names as the
training data.</p>
</td></tr>
<tr><td><code id="predict_+3A_.approach_score_target">.approach_score_target</code></td>
<td>
<p>Character string. How should the aggregation of the estimates of
the truncated normal distribution for the predictions using OrdPLS/OrdPLSc be done?
One of &quot;<em>mean</em>&quot;, &quot;<em>median</em>&quot; or &quot;<em>mode</em>&quot;.
If &quot;<em>mean</em>&quot;, the mean of the estimated endogenous indicators is calculated.
If &quot;<em>median</em>&quot;, the mean of the estimated endogenous indicators is calculated.
If &quot;<em>mode</em>&quot;, the maximum empirical density on the intervals defined by the thresholds
is used. Defaults to &quot;<em>mean</em>&quot;.</p>
</td></tr>
<tr><td><code id="predict_+3A_.sim_points">.sim_points</code></td>
<td>
<p>Integer. How many samples from the truncated normal distribution should
be simulated to estimate the exogenous construct scores? Defaults to &quot;<em>100</em>&quot;.</p>
</td></tr>
<tr><td><code id="predict_+3A_.disattenuate">.disattenuate</code></td>
<td>
<p>Logical. Should the benchmark predictions be based on
disattenuated parameter estimates? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="predict_+3A_.treat_as_continuous">.treat_as_continuous</code></td>
<td>
<p>Logical. Should the indicators for the benchmark predictions
be treated as continuous? If <code>TRUE</code> all indicators are treated as continuous and PLS-PM/PLSc is applied.
If <code>FALSE</code> OrdPLS/OrdPLSc is applied. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="predict_+3A_.approach_score_benchmark">.approach_score_benchmark</code></td>
<td>
<p>Character string. How should the aggregation
of the estimates of the truncated normal distribution be done for the
benchmark predictions? Ignored if not OrdPLS or OrdPLSc is used to obtain benchmark predictions.
One of &quot;<em>mean</em>&quot;, &quot;<em>median</em>&quot;, &quot;<em>mode</em>&quot; or &quot;<em>round</em>&quot;.
If &quot;<em>round</em>&quot;, the benchmark predictions are obtained using the traditional prediction
algorithm for PLS-PM which are rounded for categorical indicators.
If &quot;<em>mean</em>&quot;, the mean of the estimated endogenous indicators is calculated.
If &quot;<em>median</em>&quot;, the mean of the estimated endogenous indicators is calculated.
If &quot;<em>mode</em>&quot;, the maximum empirical density on the intervals defined by the thresholds
is used.
If <code>.treat_as_continuous = TRUE</code> or if all indicators are on a continuous scale,
<code>.approach_score_benchmark</code> is ignored. Defaults to &quot;<em>round</em>&quot;.</p>
</td></tr>
<tr><td><code id="predict_+3A_.seed">.seed</code></td>
<td>
<p>Integer or <code>NULL</code>. The random seed to use. Defaults to <code>NULL</code> in which
case an arbitrary seed is chosen. Note that the scope of the seed is limited
to the body of the function it is used in. Hence, the global seed will
not be altered!</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The predict function implements the procedure introduced by Shmueli et al. (2016) in the PLS context
known as &quot;PLSPredict&quot; (Shmueli et al. 2019) including its variants PLScPredcit, OrdPLSpredict and OrdPLScpredict.
It is used to predict the indicator scores of endogenous constructs and to evaluate the out-of-sample predictive power
of a model.
For that purpose, the predict function uses k-fold cross-validation to randomly
split the data into training and test datasets, and subsequently predicts the
values of the test data based on the model parameter estimates obtained
from the training data. The number of cross-validation folds is 10 by default but
may be changed using the <code>.cv_folds</code> argument.
By default, the procedure is not repeated (<code>.r = 1</code>). You may choose to repeat
cross-validation by setting a higher <code>.r</code> to be sure not to have a particular
(unfortunate) split. See Shmueli et al. (2019) for
details. Typically <code>.r = 1</code> should be sufficient though.
</p>
<p>Alternatively, users may supply a test dataset as matrix or a data frame of <code>.test_data</code> with
the same column names as those in the data used to obtain <code>.object</code> (the training data).
In this case, arguments <code>.cv_folds</code> and <code>.r</code> are
ignored and predict uses the estimated coefficients from <code>.object</code> to
predict the values in the columns of <code>.test_data</code>.
</p>
<p>In Shmueli et al. (2016) PLS-based predictions for indicator <code>i</code>
are compared to the predictions based on a multiple regression of indicator <code>i</code>
on all available exogenous indicators (<code>.benchmark = "lm"</code>) and
a simple mean-based prediction summarized in the Q2_predict metric.
<code>predict()</code> is more general in that is allows users to compare the predictions
based on a so-called target model/specification to predictions based on an
alternative benchmark. Available benchmarks include predictions
based on a linear model, PLS-PM weights, unit weights (i.e. sum scores),
GSCA weights, PCA weights, and MAXVAR weights.
</p>
<p>Each estimation run is checked for admissibility using <code><a href="#topic+verify">verify()</a></code>. If the
estimation yields inadmissible results, <code>predict()</code> stops with an error (<code>"stop"</code>).
Users may choose to <code>"ignore"</code> inadmissible results or to simply set predictions
to <code>NA</code> (<code>"set_NA"</code>) for the particular run that failed.
</p>


<h3>Value</h3>

<p>An object of class <code>cSEMPredict</code> with print and plot methods.
Technically, <code>cSEMPredict</code> is a
named list containing the following list elements:
</p>

<dl>
<dt><code style="white-space: pre;">&#8288;$Actual&#8288;</code></dt><dd><p>A matrix of the actual values/indicator scores of the endogenous constructs.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$Prediction_target&#8288;</code></dt><dd><p>A list containing matrices of the predicted indicator
scores of the endogenous constructs based on the target model for each repetition
.r. Target refers to procedure used to estimate the parameters in <code>.object</code>.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$Residuals_target&#8288;</code></dt><dd><p>A list of matrices of the residual indicator scores
of the endogenous constructs based on the target model in each repetition .r.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$Residuals_benchmark&#8288;</code></dt><dd><p>A list of matrices of the residual indicator scores
of the endogenous constructs based on a model estimated by the procedure
given to <code>.benchmark</code> for each repetition .r.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$Prediction_metrics&#8288;</code></dt><dd><p>A data frame containing the predictions metrics
MAE, RMSE, Q2_predict, the misclassification error rate (MER), the MAPE, the MSE2,
Theil's forecast accuracy (U1), Theil's forecast quality (U2), Bias proportion
of MSE (UM), Regression proportion of MSE (UR), and disturbance proportion
of MSE (UD) (Hora and Campos 2015; Watson and Teelucksingh 2002).</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$Information&#8288;</code></dt><dd><p>A list with elements
<code>Target</code>, <code>Benchmark</code>,
<code>Number_of_observations_training</code>, <code>Number_of_observations_test</code>, <code>Number_of_folds</code>,
<code>Number_of_repetitions</code>, and <code>Handle_inadmissibles</code>.</p>
</dd>
</dl>



<h3>References</h3>

<p>Hora J, Campos P (2015).
&ldquo;A review of performance criteria to validate simulation models.&rdquo;
<em>Expert Systems</em>, <b>32</b>(5), 578&ndash;595.
<a href="https://doi.org/10.1111/exsy.12111">doi:10.1111/exsy.12111</a>.<br /><br /> Shmueli G, Ray S, Estrada JMV, Chatla SB (2016).
&ldquo;The Elephant in the Room: Predictive Performance of PLS Models.&rdquo;
<em>Journal of Business Research</em>, <b>69</b>(10), 4552&ndash;4564.
<a href="https://doi.org/10.1016/j.jbusres.2016.03.049">doi:10.1016/j.jbusres.2016.03.049</a>.<br /><br /> Shmueli G, Sarstedt M, Hair JF, Cheah J, Ting H, Vaithilingam S, Ringle CM (2019).
&ldquo;Predictive Model Assessment in PLS-SEM: Guidelines for Using PLSpredict.&rdquo;
<em>European Journal of Marketing</em>, <b>53</b>(11), 2322&ndash;2347.
<a href="https://doi.org/10.1108/ejm-02-2019-0189">doi:10.1108/ejm-02-2019-0189</a>.<br /><br /> Watson PK, Teelucksingh SS (2002).
<em>A practical introduction to econometric methods: Classical and modern</em>.
University of West Indies Press, Mona, Jamaica.
</p>


<h3>See Also</h3>

<p><a href="#topic+csem">csem</a>, <a href="#topic+cSEMResults">cSEMResults</a>, <code><a href="#topic+exportToExcel">exportToExcel()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Anime example taken from https://github.com/ISS-Analytics/pls-predict/

# Load data
data(Anime) # data is similar to the Anime.csv found on 
            # https://github.com/ISS-Analytics/pls-predict/ but with irrelevant
            # columns removed

# Split into training and data the same way as it is done on 
# https://github.com/ISS-Analytics/pls-predict/
set.seed(123)

index     &lt;- sample.int(dim(Anime)[1], 83, replace = FALSE)
dat_train &lt;- Anime[-index, ]
dat_test  &lt;- Anime[index, ]

# Specify model
model &lt;- "
# Structural model

ApproachAvoidance ~ PerceivedVisualComplexity + Arousal

# Measurement/composite model

ApproachAvoidance         =~ AA0 + AA1 + AA2 + AA3
PerceivedVisualComplexity &lt;~ VX0 + VX1 + VX2 + VX3 + VX4
Arousal                   &lt;~ Aro1 + Aro2 + Aro3 + Aro4
"

# Estimate (replicating the results of the `simplePLS()` function)
res &lt;- csem(dat_train, 
            model, 
            .disattenuate = FALSE, # original PLS
            .iter_max = 300, 
            .tolerance = 1e-07, 
            .PLS_weight_scheme_inner = "factorial"
)

# Predict using a user-supplied training data set
pp &lt;- predict(res, .test_data = dat_test)
pp

### Compute prediction metrics  ------------------------------------------------
res2 &lt;- csem(Anime, # whole data set
            model, 
            .disattenuate = FALSE, # original PLS
            .iter_max = 300, 
            .tolerance = 1e-07, 
            .PLS_weight_scheme_inner = "factorial"
)

# Predict using 10-fold cross-validation
## Not run: 
pp2 &lt;- predict(res, .benchmark = "lm")
pp2
## There is a plot method available
plot(pp2)
## End(Not run)

### Example using OrdPLScPredict -----------------------------------------------
# Transform the numerical indicators into factors
## Not run: 
data("BergamiBagozzi2000")
data_new &lt;- data.frame(cei1    = as.ordered(BergamiBagozzi2000$cei1),
                       cei2    = as.ordered(BergamiBagozzi2000$cei2),
                       cei3    = as.ordered(BergamiBagozzi2000$cei3),
                       cei4    = as.ordered(BergamiBagozzi2000$cei4),
                       cei5    = as.ordered(BergamiBagozzi2000$cei5),
                       cei6    = as.ordered(BergamiBagozzi2000$cei6),
                       cei7    = as.ordered(BergamiBagozzi2000$cei7),
                       cei8    = as.ordered(BergamiBagozzi2000$cei8),
                       ma1     = as.ordered(BergamiBagozzi2000$ma1),
                       ma2     = as.ordered(BergamiBagozzi2000$ma2),
                       ma3     = as.ordered(BergamiBagozzi2000$ma3),
                       ma4     = as.ordered(BergamiBagozzi2000$ma4),
                       ma5     = as.ordered(BergamiBagozzi2000$ma5),
                       ma6     = as.ordered(BergamiBagozzi2000$ma6),
                       orgcmt1 = as.ordered(BergamiBagozzi2000$orgcmt1),
                       orgcmt2 = as.ordered(BergamiBagozzi2000$orgcmt2),
                       orgcmt3 = as.ordered(BergamiBagozzi2000$orgcmt3),
                       orgcmt5 = as.ordered(BergamiBagozzi2000$orgcmt5),
                       orgcmt6 = as.ordered(BergamiBagozzi2000$orgcmt6),
                       orgcmt7 = as.ordered(BergamiBagozzi2000$orgcmt7),
                       orgcmt8 = as.ordered(BergamiBagozzi2000$orgcmt8))

model &lt;- "
# Measurement models
OrgPres =~ cei1 + cei2 + cei3 + cei4 + cei5 + cei6 + cei7 + cei8
OrgIden =~ ma1 + ma2 + ma3 + ma4 + ma5 + ma6
AffJoy  =~ orgcmt1 + orgcmt2 + orgcmt3 + orgcmt7
AffLove =~ orgcmt5 + orgcmt 6 + orgcmt8

# Structural model
OrgIden ~ OrgPres
AffLove ~ OrgIden
AffJoy  ~ OrgIden 
"
# Estimate using cSEM; note: the fact that indicators are factors triggers OrdPLSc
res &lt;- csem(.model = model, .data = data_new[1:250,])
summarize(res)

# Predict using OrdPLSPredict
set.seed(123)
pred &lt;- predict(
  .object = res, 
  .benchmark = "PLS-PM",
  .test_data = data_new[(251):305,],
   .treat_as_continuous = TRUE, .approach_score_target = "median"
  )

pred 
round(pred$Prediction_metrics[, -1], 4)
## End(Not run)
</code></pre>

<hr>
<h2 id='print.cSEMAssess'><code>cSEMAssess</code> method for <code>print()</code></h2><span id='topic+print.cSEMAssess'></span>

<h3>Description</h3>

<p>The <code>cSEMAssess</code> method for the generic function <code><a href="base.html#topic+print">print()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cSEMAssess'
print(x, ...)
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+csem">csem()</a></code>, <code><a href="#topic+assess">assess()</a></code>
</p>

<hr>
<h2 id='print.cSEMNonlinearEffects'><code>cSEMNonlinearEffectsAnalysis</code> method for <code>print()</code></h2><span id='topic+print.cSEMNonlinearEffects'></span>

<h3>Description</h3>

<p>The <code>cSEMNonlinearEffectsAnalysis</code> method for the generic function <code><a href="base.html#topic+print">print()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cSEMNonlinearEffects'
print(x, ...)
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+csem">csem()</a></code>, <a href="#topic+cSEMResults">cSEMResults</a>, <code><a href="#topic+doNonlinearEffectsAnalysis">doNonlinearEffectsAnalysis()</a></code>, <code><a href="#topic+plot.cSEMNonlinearEffects">plot.cSEMNonlinearEffects()</a></code>
</p>

<hr>
<h2 id='print.cSEMPlotPredict'><code>cSEMPlotPredict</code> method for <code>print()</code></h2><span id='topic+print.cSEMPlotPredict'></span>

<h3>Description</h3>

<p>The <code>cSEMPlotPredict</code> method for the generic function <code><a href="base.html#topic+print">print()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cSEMPlotPredict'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.cSEMPlotPredict_+3A_x">x</code></td>
<td>
<p>An R object of class <code>cSEMPlotPredict</code>.</p>
</td></tr>
<tr><td><code id="print.cSEMPlotPredict_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+predict">predict()</a></code>, <code><a href="#topic+plot.cSEMPredict">plot.cSEMPredict()</a></code>
</p>

<hr>
<h2 id='print.cSEMPredict'><code>cSEMPredict</code> method for <code>print()</code></h2><span id='topic+print.cSEMPredict'></span>

<h3>Description</h3>

<p>The <code>cSEMPredict</code> method for the generic function <code><a href="base.html#topic+print">print()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cSEMPredict'
print(x, .metrics = c("MAE", "RMSE", "Q2"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.cSEMPredict_+3A_.metrics">.metrics</code></td>
<td>
<p>Character string or a vector of character strings.
Which prediction metrics should be displayed? One of: &quot;<em>MAE</em>&quot;, &quot;<em>RMSE</em>&quot;, &quot;<em>Q2</em>&quot;,
&quot;<em>MER</em>&quot;, &quot;<em>MAPE</em>, &quot;<em>MSE2</em>&quot;, &quot;<em>U1</em>&quot;, &quot;<em>U2</em>&quot;, &quot;<em>UM</em>&quot;, &quot;<em>UR</em>&quot;, or &quot;<em>UD</em>&quot;.
Default to c(&quot;<em>MAE</em>&quot;, &quot;<em>RMSE</em>&quot;, &quot;<em>Q2</em>&quot;).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+csem">csem()</a></code>, <a href="#topic+cSEMResults">cSEMResults</a>, <code><a href="#topic+predict">predict()</a></code>
</p>

<hr>
<h2 id='print.cSEMResults'><code>cSEMResults</code> method for <code>print()</code></h2><span id='topic+print.cSEMResults'></span>

<h3>Description</h3>

<p>The <a href="#topic+cSEMResults">cSEMResults</a> method for the generic function <code><a href="base.html#topic+print">print()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cSEMResults'
print(x, ...)
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+csem">csem()</a></code>, <a href="#topic+cSEMResults">cSEMResults</a>
</p>

<hr>
<h2 id='print.cSEMSummarize'><code>cSEMSummarize</code> method for <code>print()</code></h2><span id='topic+print.cSEMSummarize'></span>

<h3>Description</h3>

<p>The <a href="#topic+cSEMSummary">cSEMSummary</a> method for the generic function <code><a href="base.html#topic+print">print()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cSEMSummarize'
print(x, .full_output = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.cSEMSummarize_+3A_.full_output">.full_output</code></td>
<td>
<p>Logical. Should the full output of summarize be printed.
Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+csem">csem()</a></code>, <a href="#topic+cSEMResults">cSEMResults</a>, <code><a href="#topic+summarize">summarize()</a></code>
</p>

<hr>
<h2 id='print.cSEMTestCVPAT'><code>cSEMTestCVPAT</code> method for <code>print()</code></h2><span id='topic+print.cSEMTestCVPAT'></span>

<h3>Description</h3>

<p>The <code>cSEMTestCVAT</code> method for the generic function <code><a href="base.html#topic+print">print()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cSEMTestCVPAT'
print(x, ...)
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+csem">csem()</a></code>, <a href="#topic+cSEMResults">cSEMResults</a>, <code><a href="#topic+testCVPAT">testCVPAT()</a></code>
</p>

<hr>
<h2 id='print.cSEMTestHausman'><code>cSEMTestHausman</code> method for <code>print()</code></h2><span id='topic+print.cSEMTestHausman'></span>

<h3>Description</h3>

<p>The <code>cSEMTestHausman</code> method for the generic function <code><a href="base.html#topic+print">print()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cSEMTestHausman'
print(x, ...)
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+csem">csem()</a></code>, <a href="#topic+cSEMResults">cSEMResults</a>, <code><a href="#topic+testHausman">testHausman()</a></code>
</p>

<hr>
<h2 id='print.cSEMTestMGD'><code>cSEMTestMGD</code> method for <code>print()</code></h2><span id='topic+print.cSEMTestMGD'></span>

<h3>Description</h3>

<p>The <code>cSEMTestMGD</code> method for the generic function <code><a href="base.html#topic+print">print()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cSEMTestMGD'
print(
  x,
  .approach_mgd = c("none", "Klesel", "Chin", "Sarstedt", "Keil", "Nitzl", "Henseler",
    "CI_para", "CI_overlap"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.cSEMTestMGD_+3A_.approach_mgd">.approach_mgd</code></td>
<td>
<p>Character string or a vector of character strings.
For which approach should details be displayed? One of: &quot;<em>none</em>&quot;, &quot;<em>Klesel</em>&quot;, &quot;<em>Chin</em>&quot;,
&quot;<em>Sarstedt</em>&quot;, &quot;<em>Keil</em>, &quot;<em>Nitzl</em>&quot;, &quot;<em>Henseler</em>&quot;, &quot;<em>CI_para</em>&quot;, or &quot;<em>CI_overlap</em>&quot;.
Default to &quot;<em>none</em>&quot; in which case no details are displayed.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+csem">csem()</a></code>, <a href="#topic+cSEMResults">cSEMResults</a>, <code><a href="#topic+testMGD">testMGD()</a></code>
</p>

<hr>
<h2 id='print.cSEMTestMICOM'><code>cSEMTestMICOM</code> method for <code>print()</code></h2><span id='topic+print.cSEMTestMICOM'></span>

<h3>Description</h3>

<p>The <code>cSEMTestMICOM</code> method for the generic function <code><a href="base.html#topic+print">print()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cSEMTestMICOM'
print(x, ...)
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+csem">csem()</a></code>, <a href="#topic+cSEMResults">cSEMResults</a>, <code><a href="#topic+testMICOM">testMICOM()</a></code>
</p>

<hr>
<h2 id='print.cSEMTestOMF'><code>cSEMTestOMF</code> method for <code>print()</code></h2><span id='topic+print.cSEMTestOMF'></span>

<h3>Description</h3>

<p>The <code>cSEMTestOMF</code> method for the generic function <code><a href="base.html#topic+print">print()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cSEMTestOMF'
print(x, ...)
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+csem">csem()</a></code>, <a href="#topic+cSEMResults">cSEMResults</a>, <code><a href="#topic+testOMF">testOMF()</a></code>
</p>

<hr>
<h2 id='print.cSEMVerify'><code>cSEMVerify</code> method for <code>print()</code></h2><span id='topic+print.cSEMVerify'></span>

<h3>Description</h3>

<p>The <code>cSEMVerify</code> method for the generic function <code><a href="base.html#topic+print">print()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cSEMVerify'
print(x, ...)
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+csem">csem()</a></code>, <a href="#topic+cSEMResults">cSEMResults</a>, <code><a href="#topic+verify">verify()</a></code>
</p>

<hr>
<h2 id='processData'>Internal: Process data</h2><span id='topic+processData'></span>

<h3>Description</h3>

<p>Prepare, standardize, check, and clean data provided via the <code>.data</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>processData(
  .data        = NULL, 
  .model       = NULL, 
  .instruments = NULL
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="processData_+3A_.data">.data</code></td>
<td>
<p>A <code>data.frame</code> or a <code>matrix</code> of standardized or unstandardized
data (indicators/items/manifest variables). Possible column types or classes
of the data provided are: &quot;<code>logical</code>&quot;, &quot;<code>numeric</code>&quot; (&quot;<code>double</code>&quot; or &quot;<code>integer</code>&quot;),
&quot;<code>factor</code>&quot; (&quot;<code>ordered</code>&quot; and/or &quot;<code>unordered</code>&quot;), &quot;<code>character</code>&quot; (converted to factor),
or a mix of several types.</p>
</td></tr>
<tr><td><code id="processData_+3A_.model">.model</code></td>
<td>
<p>A model in <a href="lavaan.html#topic+model.syntax">lavaan model syntax</a>
or a <a href="#topic+cSEMModel">cSEMModel</a> list.</p>
</td></tr>
<tr><td><code id="processData_+3A_.instruments">.instruments</code></td>
<td>
<p>A named list of vectors of instruments. The names
of the list elements are the names of the dependent (LHS) constructs of the structural
equation whose explanatory variables are endogenous. The vectors
contain the names of the instruments corresponding to each equation. Note
that exogenous variables of a given equation <strong>must</strong> be supplied as
instruments for themselves. Defaults to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A (N x K) data.frame containing the standardized data with columns ordered
according to the order they appear in the measurement model equations provided
via the <code>.model</code> argument.
</p>

<hr>
<h2 id='reliability'>Reliability</h2><span id='topic+reliability'></span><span id='topic+calculateRhoC'></span><span id='topic+calculateRhoT'></span>

<h3>Description</h3>

<p>Compute several reliability estimates. See the
<a href="https://m-e-rademaker.github.io/cSEM/articles/Using-assess.html#reliability">Reliability</a>
section of the <a href="https://m-e-rademaker.github.io/cSEM/index.html">cSEM website</a>
for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateRhoC(
  .object = NULL,
  .model_implied = TRUE,
  .only_common_factors = TRUE,
  .weighted = FALSE
)

calculateRhoT(
  .object = NULL,
  .alpha = 0.05,
  .closed_form_ci = FALSE,
  .only_common_factors = TRUE,
  .output_type = c("vector", "data.frame"),
  .weighted = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reliability_+3A_.object">.object</code></td>
<td>
<p>An R object of class <a href="#topic+cSEMResults">cSEMResults</a> resulting from a call to <code><a href="#topic+csem">csem()</a></code>.</p>
</td></tr>
<tr><td><code id="reliability_+3A_.model_implied">.model_implied</code></td>
<td>
<p>Logical. Should weights be scaled using the model-implied
indicator correlation matrix? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="reliability_+3A_.only_common_factors">.only_common_factors</code></td>
<td>
<p>Logical. Should only concepts modeled as common
factors be included when calculating one of the following quality criteria:
AVE, the Fornell-Larcker criterion, HTMT, and all reliability estimates.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="reliability_+3A_.weighted">.weighted</code></td>
<td>
<p>Logical. Should estimation be based on a score that uses
the weights of the weight approach used to obtain <code>.object</code>?. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="reliability_+3A_.alpha">.alpha</code></td>
<td>
<p>An integer or a numeric vector of significance levels.
Defaults to <code>0.05</code>.</p>
</td></tr>
<tr><td><code id="reliability_+3A_.closed_form_ci">.closed_form_ci</code></td>
<td>
<p>Logical. Should a closed-form confidence interval be computed?
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="reliability_+3A_.output_type">.output_type</code></td>
<td>
<p>Character string. The type of output. One of &quot;vector&quot; or
&quot;data.frame&quot;. Defaults to &quot;vector&quot;.</p>
</td></tr>
<tr><td><code id="reliability_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Since reliability is defined with respect to a classical true score measurement
model only concepts modeled as common factors are considered by default.
For concepts modeled as composites reliability may be estimated by setting
<code>.only_common_factors = FALSE</code>, however, it is unclear how to
interpret reliability in this case.
</p>
<p>Reliability is traditionally based on a test score (proxy) based on unit weights.
To compute congeneric and tau-equivalent reliability based on a score that
uses the weights of the weight approach used to obtain <code>.object</code> use <code>.weighted = TRUE</code>
instead.
</p>
<p>For the tau-equivalent reliability (&quot;<code>rho_T</code>&quot; or &quot;<code>cronbachs_alpha</code>&quot;) a closed-form
confidence interval may be computed (Trinchera et al. 2018) by setting
<code>.closed_form_ci = TRUE</code> (default is <code>FALSE</code>). If <code>.alpha</code> is a vector
several CI's are returned.
</p>


<h3>Value</h3>

<p>For <code>calculateRhoC()</code> and <code>calculateRhoT()</code> (if <code>.output_type = "vector"</code>)
a named numeric vector containing the reliability estimates.
If <code>.output_type = "data.frame"</code> <code>calculateRhoT()</code> returns a <code>data.frame</code> with as many rows as there are
constructs modeled as common factors in the model (unless
<code>.only_common_factors = FALSE</code> in which case the number of rows equals the
total number of constructs in the model). The first column contains the name of the construct.
The second column the reliability estimate.
If <code>.closed_form_ci = TRUE</code> the remaining columns contain lower and upper bounds
for the (1 - <code>.alpha</code>) confidence interval(s).
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>calculateRhoC()</code>: Calculate the congeneric reliability
</p>
</li>
<li> <p><code>calculateRhoT()</code>: Calculate the tau-equivalent reliability
</p>
</li></ul>


<h3>References</h3>

<p>Trinchera L, Marie N, Marcoulides GA (2018).
&ldquo;A Distribution Free Interval Estimate for Coefficient Alpha.&rdquo;
<em>Structural Equation Modeling: A Multidisciplinary Journal</em>, <b>25</b>(6), 876&ndash;887.
<a href="https://doi.org/10.1080/10705511.2018.1431544">doi:10.1080/10705511.2018.1431544</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+assess">assess()</a></code>, <a href="#topic+cSEMResults">cSEMResults</a>
</p>

<hr>
<h2 id='resamplecSEMResults'>Resample cSEMResults</h2><span id='topic+resamplecSEMResults'></span>

<h3>Description</h3>

<p>Resample a <a href="#topic+cSEMResults">cSEMResults</a> object using bootstrap or jackknife resampling.
The function is called by <code><a href="#topic+csem">csem()</a></code> if the user sets
<code>csem(..., .resample_method = "bootstrap")</code> or
<code>csem(..., .resample_method = "jackknife")</code> but may also be called directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resamplecSEMResults(
 .object                = NULL,
 .resample_method       = c("bootstrap", "jackknife"), 
 .resample_method2      = c("none", "bootstrap", "jackknife"), 
 .R                     = 499,
 .R2                    = 199,
 .handle_inadmissibles  = c("drop", "ignore", "replace"),
 .user_funs             = NULL,
 .eval_plan             = c("sequential", "multicore", "multisession"),
 .force                 = FALSE,
 .seed                  = NULL,
 .sign_change_option    = c("none","individual","individual_reestimate",
                            "construct_reestimate"),
 ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resamplecSEMResults_+3A_.object">.object</code></td>
<td>
<p>An R object of class <a href="#topic+cSEMResults">cSEMResults</a> resulting from a call to <code><a href="#topic+csem">csem()</a></code>.</p>
</td></tr>
<tr><td><code id="resamplecSEMResults_+3A_.resample_method">.resample_method</code></td>
<td>
<p>Character string. The resampling method to use. One of:
&quot;<em>bootstrap</em>&quot; or &quot;<em>jackknife</em>&quot;. Defaults to &quot;<em>bootstrap</em>&quot;.</p>
</td></tr>
<tr><td><code id="resamplecSEMResults_+3A_.resample_method2">.resample_method2</code></td>
<td>
<p>Character string. The resampling method to use when resampling
from a resample. One of: &quot;<em>none</em>&quot;, &quot;<em>bootstrap</em>&quot; or &quot;<em>jackknife</em>&quot;. For
&quot;<em>bootstrap</em>&quot; the number of draws is provided via <code>.R2</code>. Currently,
resampling from each resample is only required for the studentized confidence
interval (&quot;<em>CI_t_interval</em>&quot;) computed by the <code><a href="#topic+infer">infer()</a></code> function. Defaults to &quot;<em>none</em>&quot;.</p>
</td></tr>
<tr><td><code id="resamplecSEMResults_+3A_.r">.R</code></td>
<td>
<p>Integer. The number of bootstrap replications. Defaults to <code>499</code>.</p>
</td></tr>
<tr><td><code id="resamplecSEMResults_+3A_.r2">.R2</code></td>
<td>
<p>Integer. The number of bootstrap replications to use when
resampling from a resample. Defaults to <code>199</code>.</p>
</td></tr>
<tr><td><code id="resamplecSEMResults_+3A_.handle_inadmissibles">.handle_inadmissibles</code></td>
<td>
<p>Character string. How should inadmissible results
be treated? One of &quot;<em>drop</em>&quot;, &quot;<em>ignore</em>&quot;, or &quot;<em>replace</em>&quot;. If &quot;<em>drop</em>&quot;, all
replications/resamples yielding an inadmissible result will be dropped
(i.e. the number of results returned will potentially be less than <code>.R</code>).
For &quot;<em>ignore</em>&quot; all results are returned even if all or some of the replications
yielded inadmissible results (i.e. number of results returned is equal to <code>.R</code>).
For &quot;<em>replace</em>&quot; resampling continues until there are exactly <code>.R</code> admissible solutions.
Depending on the frequency of inadmissible solutions this may significantly increase
computing time. Defaults to &quot;<em>drop</em>&quot;.</p>
</td></tr>
<tr><td><code id="resamplecSEMResults_+3A_.user_funs">.user_funs</code></td>
<td>
<p>A function or a (named) list of functions to apply to every
resample. The functions must take <code>.object</code> as its first argument (e.g.,
<code style="white-space: pre;">&#8288;myFun &lt;- function(.object, ...) {body-of-the-function}&#8288;</code>).
Function output should preferably be a (named)
vector but matrices are also accepted. However, the output will be
vectorized (columnwise) in this case. See the examples section for details.</p>
</td></tr>
<tr><td><code id="resamplecSEMResults_+3A_.eval_plan">.eval_plan</code></td>
<td>
<p>Character string. The evaluation plan to use. One of
&quot;<em>sequential</em>&quot;, &quot;<em>multicore</em>&quot;, or &quot;<em>multisession</em>&quot;. In the two latter cases
all available cores will be used. Defaults to &quot;<em>sequential</em>&quot;.</p>
</td></tr>
<tr><td><code id="resamplecSEMResults_+3A_.force">.force</code></td>
<td>
<p>Logical. Should .object be resampled even if it contains resamples
already?. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="resamplecSEMResults_+3A_.seed">.seed</code></td>
<td>
<p>Integer or <code>NULL</code>. The random seed to use. Defaults to <code>NULL</code> in which
case an arbitrary seed is chosen. Note that the scope of the seed is limited
to the body of the function it is used in. Hence, the global seed will
not be altered!</p>
</td></tr>
<tr><td><code id="resamplecSEMResults_+3A_.sign_change_option">.sign_change_option</code></td>
<td>
<p>Character string. Which sign change option should
be used to handle flipping signs when resampling? One of &quot;<em>none</em>&quot;,&quot;<em>individual</em>&quot;,
&quot;<em>individual_reestimate</em>&quot;, &quot;<em>construct_reestimate</em>&quot;. Defaults to &quot;<em>none</em>&quot;.</p>
</td></tr>
<tr><td><code id="resamplecSEMResults_+3A_...">...</code></td>
<td>
<p>Further arguments passed to functions supplied to <code>.user_funs</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given <code>M</code> resamples (for bootstrap <code>M = .R</code> and for jackknife <code>M = N</code>, where
<code>N</code> is the number of observations) based on the data used to compute the
<a href="#topic+cSEMResults">cSEMResults</a> object provided via <code>.object</code>, <code>resamplecSEMResults()</code> essentially calls
<code><a href="#topic+csem">csem()</a></code> on each resample using the arguments of the original call (ignoring any arguments
related to resampling) and returns estimates for each of a subset of
practically useful resampled parameters/statistics computed by <code><a href="#topic+csem">csem()</a></code>.
Currently, the following estimates are computed and returned by default based
on each resample: Path estimates, Loading estimates, Weight estimates.
</p>
<p>In practical application users may need to resample a specific statistic (e.g,
the heterotrait-monotrait ratio of correlations (HTMT) or differences between path
coefficients such as beta_1 - beta_2).
Such statistics may be provided by a function <code>fun(.object, ...)</code> or a list of
such functions via the <code>.user_funs</code> argument. The first argument of
these functions must always be <code>.object</code>.
Internally, the function will be applied on each
resample to produce the desired statistic. Hence, arbitrary complicated statistics
may be resampled as long as the body of the function draws on elements contained
in the <a href="#topic+cSEMResults">cSEMResults</a> object only. Output of <code>fun(.object, ...)</code> should preferably
be a (named) vector but matrices are also accepted.
However, the output will be vectorized (columnwise) in this case.
See the examples section for details.
</p>
<p>Both resampling the original <a href="#topic+cSEMResults">cSEMResults</a> object (call it &quot;first resample&quot;)
and resampling based on a resampled <a href="#topic+cSEMResults">cSEMResults</a> object (call it &quot;second resample&quot;)
are supported. Choices for the former
are &quot;<em>bootstrap</em>&quot; and &quot;<em>jackknife</em>&quot;. Resampling based on a resample is turned off
by default (<code>.resample_method2 = "none"</code>) as this significantly
increases computation time (there are now <code>M * M2</code> resamples to compute, where
<code>M2</code> is <code>.R2</code> or <code>N</code>).
Resamples of a resample are required, e.g., for the studentized confidence
interval computed by the <code><a href="#topic+infer">infer()</a></code> function. Typically, bootstrap resamples
are used in this case (Davison and Hinkley 1997).
</p>
<p>As <code><a href="#topic+csem">csem()</a></code> accepts a single data set, a list of data sets as well as data sets
that contain a column name used to split the data into groups,
the <a href="#topic+cSEMResults">cSEMResults</a> object may contain multiple data sets.
In this case, resampling is done by data set or group. Note that depending
on the number of data sets/groups, the computation may be considerably
slower as resampling will be repeated for each data set/group. However, apart
from speed considerations users don not need to worry about the type of
input used to compute the <a href="#topic+cSEMResults">cSEMResults</a> object as <code>resamplecSEMResults()</code>
is able to deal with each case.
</p>
<p>The number of bootstrap runs for the first and second run are given by <code>.R</code> and <code>.R2</code>.
The default is <code>499</code> for the first and <code>199</code> for the second run
but should be increased in real applications. See e.g.,
Hesterberg (2015), p.380,
Davison and Hinkley (1997), and
Efron and Hastie (2016) for recommendations.
For jackknife <code>.R</code> are <code>.R2</code> are ignored.
</p>
<p>Resampling may produce inadmissible results (as checked by <code><a href="#topic+verify">verify()</a></code>).
By default these results are dropped however users may choose to <code>"ignore"</code>
or <code>"replace"</code> inadmissible results in which resampling continuous until
the necessary number of admissible results is reached.
</p>
<p>The <span class="pkg">cSEM</span> package supports (multi)processing via the <a href="https://github.com/HenrikBengtsson/future/">future</a>
framework (Bengtsson 2018). Users may simply choose an evaluation plan
via <code>.eval_plan</code> and the package takes care of all the complicated backend
issues. Currently, users may choose between standard single-core/single-session
evaluation (<code>"sequential"</code>) and multiprocessing (<code>"multisession"</code> or <code>"multicore"</code>). The future package
provides other options (e.g., <code>"cluster"</code> or <code>"remote"</code>), however, they probably
will not be needed in the context of the <span class="pkg">cSEM</span> package as simulations usually
do not require high-performance clusters. Depending on the operating system, the future
package will manage to distribute tasks to multiple R sessions (Windows)
or multiple cores. Note that multiprocessing is not necessary always faster
when only a &quot;small&quot; number of replications is required as the overhead of
initializing new sessions or distributing tasks to different cores
will not immediately be compensated by the availability of multiple sessions/cores.
</p>
<p>Random number generation (RNG) uses the L'Ecuyer-CRMR RGN stream as implemented in the
<a href="https://github.com/HenrikBengtsson/future.apply/">future.apply package</a> (Bengtsson 2018).
It is independent of the evaluation plan. Hence, setting e.g., <code>.seed = 123</code> will
generate the same random number and replicates
for both <code>.eval_plan = "sequential"</code>, <code>.eval_plan = "multisession"</code>, and <code>.eval_plan = "multicore"</code>.
See <a href="future.apply.html#topic+future_lapply">?future_lapply</a> for details.
</p>


<h3>Value</h3>

<p>The core structure is the same structure as that of <code>.object</code> with
the following elements added:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;$Estimates_resamples&#8288;</code>: A list containing the <code>.R</code> resamples and
the original estimates for each of the resampled quantities (Path_estimates,
Loading_estimates, Weight_estimates, user defined functions).
Each list element is a list containing elements
<code style="white-space: pre;">&#8288;$Resamples&#8288;</code> and <code style="white-space: pre;">&#8288;$Original&#8288;</code>. <code style="white-space: pre;">&#8288;$Resamples&#8288;</code> is a <code style="white-space: pre;">&#8288;(.R x K)&#8288;</code> matrix with each
row representing one resample for each of the <code>K</code> parameters/statistics.
<code style="white-space: pre;">&#8288;$Original&#8288;</code> contains the original estimates (vectorized by column if the output of
the user provided function is a matrix.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$Information_resamples&#8288;</code>: A list containing additional information.
</p>
</li></ul>

<p>Use <code style="white-space: pre;">&#8288;str(&lt;.object&gt;, list.len = 3)&#8288;</code> on the resulting object for an overview.
</p>


<h3>References</h3>

<p>Bengtsson H (2018).
<em>future: Unified Parallel and Distributed Processing in R for Everyone</em>.
R package version 1.10.0, <a href="https://CRAN.R-project.org/package=future">https://CRAN.R-project.org/package=future</a>.<br /><br /> Bengtsson H (2018).
<em>future.apply: Apply Function to Elements in Parallel using Futures</em>.
R package version 1.0.1, <a href="https://CRAN.R-project.org/package=future.apply">https://CRAN.R-project.org/package=future.apply</a>.<br /><br /> Davison AC, Hinkley DV (1997).
<em>Bootstrap Methods and their Application</em>.
Cambridge University Press.
<a href="https://doi.org/10.1017/cbo9780511802843">doi:10.1017/cbo9780511802843</a>.<br /><br /> Efron B, Hastie T (2016).
<em>Computer Age Statistical Inference</em>.
Cambridge University Pr.
ISBN 1107149894.<br /><br /> Hesterberg TC (2015).
&ldquo;What Teachers Should Know About the Bootstrap: Resampling in the Undergraduate Statistics Curriculum.&rdquo;
<em>The American Statistician</em>, <b>69</b>(4), 371&ndash;386.
<a href="https://doi.org/10.1080/00031305.2015.1089789">doi:10.1080/00031305.2015.1089789</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+csem">csem</a>, <code><a href="#topic+summarize">summarize()</a></code>, <code><a href="#topic+infer">infer()</a></code>, <a href="#topic+cSEMResults">cSEMResults</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Note: example not run as resampling is time consuming
# ===========================================================================
# Basic usage
# ===========================================================================
model &lt;- "
# Structural model
QUAL ~ EXPE
EXPE ~ IMAG
SAT  ~ IMAG + EXPE + QUAL + VAL
LOY  ~ IMAG + SAT
VAL  ~ EXPE + QUAL

# Measurement model
EXPE =~ expe1 + expe2 + expe3 + expe4 + expe5
IMAG =~ imag1 + imag2 + imag3 + imag4 + imag5
LOY  =~ loy1  + loy2  + loy3  + loy4
QUAL =~ qual1 + qual2 + qual3 + qual4 + qual5
SAT  =~ sat1  + sat2  + sat3  + sat4
VAL  =~ val1  + val2  + val3  + val4
"

## Estimate the model without resampling 
a &lt;- csem(satisfaction, model)

## Bootstrap and jackknife estimation
boot &lt;- resamplecSEMResults(a)
jack &lt;- resamplecSEMResults(a, .resample_method = "jackknife") 

## Alternatively use .resample_method in csem()
boot_csem &lt;- csem(satisfaction, model, .resample_method = "bootstrap")
jack_csem &lt;- csem(satisfaction, model, .resample_method = "jackknife")

# ===========================================================================
# Extended usage
# ===========================================================================
### Double resampling  ------------------------------------------------------
# The confidence intervals (e.g. the bias-corrected and accelearated CI) 
# require double resampling. Use .resample_method2 for this.

boot1 &lt;- resamplecSEMResults(
  .object = a, 
  .resample_method  = "bootstrap", 
  .R                = 50,
  .resample_method2 = "bootstrap", 
  .R2               = 20,
  .seed             = 1303
  )

## Again, this is identical to using csem 
boot1_csem &lt;- csem(
  .data             = satisfaction, 
  .model            = model, 
  .resample_method  = "bootstrap",
  .R                = 50,
  .resample_method2 = "bootstrap",
  .R2               = 20,
  .seed             = 1303
  )

identical(boot1, boot1_csem) # only true if .seed was set

### Inference ---------------------------------------------------------------
# To get inferencial quanitites such as the estimated standard error or
# the percentile confidence intervall for each resampled quantity use 
# postestimation function infer()

inference &lt;- infer(boot1)
inference$Path_estimates$sd
inference$Path_estimates$CI_percentile

# As usual summarize() can be called directly
summarize(boot1)

# In the example above .R x .R2 = 50 x 20 = 1000. Multiprocessing will be
# faster on most systems here and is therefore recommended. Note that multiprocessing
# does not affect the random number generation

boot2 &lt;- resamplecSEMResults(
  .object           = a, 
  .resample_method  = "bootstrap", 
  .R                = 50,
  .resample_method2 = "bootstrap", 
  .R2               = 20,
  .eval_plan        = "multisession", 
  .seed             = 1303
  )

identical(boot1, boot2)
## End(Not run)
</code></pre>

<hr>
<h2 id='resampleData'>Resample data</h2><span id='topic+resampleData'></span>

<h3>Description</h3>

<p>Resample data from a data set using common resampling methods.
For bootstrap or jackknife resampling, package users usually do not need to
call this function but directly use <code><a href="#topic+resamplecSEMResults">resamplecSEMResults()</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resampleData(
 .object          = NULL,
 .data            = NULL,
 .resample_method = c("bootstrap", "jackknife", "permutation", 
                      "cross-validation"),
 .cv_folds        = 10,
 .id              = NULL,
 .R               = 499,
 .seed            = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resampleData_+3A_.object">.object</code></td>
<td>
<p>An R object of class <a href="#topic+cSEMResults">cSEMResults</a> resulting from a call to <code><a href="#topic+csem">csem()</a></code>.</p>
</td></tr>
<tr><td><code id="resampleData_+3A_.data">.data</code></td>
<td>
<p>A <code>data.frame</code>, a <code>matrix</code> or a <code>list</code> of data of either type.
Possible column types or classes of the data provided are:
&quot;<code>logical</code>&quot;, &quot;<code>numeric</code>&quot; (&quot;<code>double</code>&quot; or &quot;<code>integer</code>&quot;), &quot;<code>factor</code>&quot; (ordered and unordered)
or a mix of several types. The data may also include
<strong>one</strong> character column whose column name must be given to <code>.id</code>.
This column is assumed to contain group identifiers used to split the data into groups.
If <code>.data</code> is provided, <code>.object</code> is ignored. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="resampleData_+3A_.resample_method">.resample_method</code></td>
<td>
<p>Character string. The resampling method to use. One of:
&quot;<em>bootstrap</em>&quot;, &quot;<em>jackknife</em>&quot;, &quot;<em>permutation</em>&quot;, or &quot;<em>cross-validation</em>&quot;.
Defaults to &quot;<em>bootstrap</em>&quot;.</p>
</td></tr>
<tr><td><code id="resampleData_+3A_.cv_folds">.cv_folds</code></td>
<td>
<p>Integer. The number of cross-validation folds to use. Setting
<code>.cv_folds</code> to <code>N</code> (the number of observations) produces
leave-one-out cross-validation samples. Defaults to <code>10</code>.</p>
</td></tr>
<tr><td><code id="resampleData_+3A_.id">.id</code></td>
<td>
<p>Character string or integer. A character string giving the name or
an integer of the position of the column of <code>.data</code> whose levels are used
to split <code>.data</code> into groups. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="resampleData_+3A_.r">.R</code></td>
<td>
<p>Integer. The number of bootstrap runs, permutation runs
or cross-validation repetitions to use. Defaults to <code>499</code>.</p>
</td></tr>
<tr><td><code id="resampleData_+3A_.seed">.seed</code></td>
<td>
<p>Integer or <code>NULL</code>. The random seed to use. Defaults to <code>NULL</code> in which
case an arbitrary seed is chosen. Note that the scope of the seed is limited
to the body of the function it is used in. Hence, the global seed will
not be altered!</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>resampleData()</code> is general purpose. It simply resamples data
from a data set according to the resampling method provided
via the <code>.resample_method</code> argument and returns a list of resamples.
Currently, <code>bootstrap</code>, <code>jackknife</code>, <code>permutation</code>, and  <code>cross-validation</code>
(both leave-one-out (LOOCV) and k-fold cross-validation) are implemented.
</p>
<p>The user may provide the data set to resample either explicitly via the <code>.data</code>
argument or implicitly by providing a <a href="#topic+cSEMResults">cSEMResults</a> objects to <code>.object</code>
in which case the original data used in the call that created the
<a href="#topic+cSEMResults">cSEMResults</a> object is used for resampling.
If both, a <a href="#topic+cSEMResults">cSEMResults</a> object and a data set via <code>.data</code> are provided
the former is ignored.
</p>
<p>As <code><a href="#topic+csem">csem()</a></code> accepts a single data set, a list of data sets as well as data sets
that contain a column name used to split the data into groups,
the <a href="#topic+cSEMResults">cSEMResults</a> object may contain multiple data sets.
In this case, resampling is done by data set or group. Note that depending
on the number of data sets/groups provided this computation may be slower
as resampling will be repeated for each data set/group.
</p>
<p>To split data provided via the <code>.data</code> argument into groups, the column name or
the column index of the column containing the group levels to split the data
must be given to <code>.id</code>. If data that contains grouping is taken from
a <a href="#topic+cSEMResults">cSEMResults</a> object, <code>.id</code> is taken from the object information. Hence,
providing  <code>.id</code> is redundant in this case and therefore ignored.
</p>
<p>The number of bootstrap or permutation runs as well as the number of
cross-validation repetitions is given by <code>.R</code>. The default is
<code>499</code> but should be increased in real applications. See e.g.,
Hesterberg (2015), p.380 for recommendations concerning
the bootstrap. For jackknife <code>.R</code> is ignored as it is based on the N leave-one-out data sets.
</p>
<p>Choosing <code>resample_method = "permutation"</code> for ungrouped data causes an error
as permutation will simply reorder the observations which is usually not
meaningful. If a list of data is provided
each list element is assumed to represent the observations belonging to one
group. In this case, data is pooled and group adherence permuted.
</p>
<p>For cross-validation the number of folds (<code>k</code>) defaults to <code>10</code>. It may be
changed via the <code>.cv_folds</code> argument. Setting <code>k = 2</code> (not 1!) splits
the data into a single training and test data set. Setting <code>k = N</code> (where <code>N</code> is the
number of observations) produces leave-one-out cross-validation samples.
Note: 1.) At least 2 folds required  (<code>k &gt; 1</code>); 2.) <code>k</code> can not be larger than <code>N</code>;
3.) If <code>N/k</code> is not not an integer the last fold will have less observations.
</p>
<p>Random number generation (RNG) uses the L'Ecuyer-CRMR RGN stream as implemented
in the <a href="https://github.com/HenrikBengtsson/future.apply/">future.apply package</a>
(Bengtsson 2018).
See <a href="future.apply.html#topic+future_lapply">?future_lapply</a> for details. By default
a random seed is chosen.
</p>


<h3>Value</h3>

<p>The structure of the output depends on the type of input and the
resampling method:
</p>

<dl>
<dt>Bootstrap</dt><dd><p>If a <code>matrix</code> or <code>data.frame</code> without grouping variable
is provided (i.e., <code>.id = NULL</code>), the result is a list of length <code>.R</code>
(default <code>499</code>). Each element of that list is a bootstrap (re)sample.
If a grouping variable is specified or a list of data is provided
(where each list element is assumed to contain data for one group),
resampling is done by group. Hence,
the result is a list of length equal to the number of groups
with each list element containing <code>.R</code> bootstrap samples based on the
<code>N_g</code> observations of group <code>g</code>.</p>
</dd>
<dt>Jackknife</dt><dd><p>If a <code>matrix</code> or <code>data.frame</code> without grouping variable
is provided (<code>.id = NULL</code>), the result is a list of length equal to the number
of observations/rows (<code>N</code>) of the data set provided.
Each element of that list is a jackknife (re)sample.
If a grouping variable is specified or a list of data is provided
(where each list element is assumed to contain data for one group),
resampling is done by group. Hence,
the result is a list of length equal to the number of group levels
with each list element containing <code>N</code> jackknife samples based on the
<code>N_g</code> observations of group <code>g</code>.</p>
</dd>
<dt>Permutation</dt><dd><p>If a <code>matrix</code> or <code>data.frame</code> without grouping variable
is provided an error is returned as permutation will simply reorder the observations.
If a grouping variable is specified or a list of data is provided
(where each list element is assumed to contain data of one group),
group membership is permuted. Hence, the result is a list of length <code>.R</code>
where each element of that list is a permutation (re)sample.</p>
</dd>
<dt>Cross-validation</dt><dd><p>If a <code>matrix</code> or <code>data.frame</code> without grouping variable
is provided a list of length <code>.R</code> is returned. Each list element
contains a list containing the <code>k</code> splits/folds subsequently
used as test and training data sets.
If a grouping variable is specified or a list of data is provided
(where each list element is assumed to contain data for one group),
cross-validation is repeated <code>.R</code> times for each group. Hence,
the result is a list of length equal to the number of groups,
each containing <code>.R</code> list elements (the repetitions) which in turn contain
the <code>k</code> splits/folds.
</p>
</dd>
</dl>



<h3>References</h3>

<p>Bengtsson H (2018).
<em>future.apply: Apply Function to Elements in Parallel using Futures</em>.
R package version 1.0.1, <a href="https://CRAN.R-project.org/package=future.apply">https://CRAN.R-project.org/package=future.apply</a>.<br /><br /> Hesterberg TC (2015).
&ldquo;What Teachers Should Know About the Bootstrap: Resampling in the Undergraduate Statistics Curriculum.&rdquo;
<em>The American Statistician</em>, <b>69</b>(4), 371&ndash;386.
<a href="https://doi.org/10.1080/00031305.2015.1089789">doi:10.1080/00031305.2015.1089789</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+csem">csem()</a></code>, <a href="#topic+cSEMResults">cSEMResults</a>, <code><a href="#topic+resamplecSEMResults">resamplecSEMResults()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># ===========================================================================
# Using the raw data 
# ===========================================================================
### Bootstrap (default) -----------------------------------------------------

res_boot1 &lt;- resampleData(.data = satisfaction)
str(res_boot1, max.level = 3, list.len = 3)

## To replicate a bootstrap draw use .seed:
res_boot1a &lt;- resampleData(.data = satisfaction, .seed = 2364)
res_boot1b &lt;- resampleData(.data = satisfaction, .seed = 2364)
                           
identical(res_boot1, res_boot1a) # TRUE

### Jackknife ---------------------------------------------------------------

res_jack &lt;- resampleData(.data = satisfaction, .resample_method = "jackknife")
str(res_jack, max.level = 3, list.len = 3)

### Cross-validation --------------------------------------------------------
## Create dataset for illustration:
dat &lt;- data.frame(
  "x1" = rnorm(100),
  "x2" = rnorm(100),
  "group" = sample(c("male", "female"), size = 100, replace = TRUE),
  stringsAsFactors = FALSE)

## 10-fold cross-validation (repeated 100 times)
cv_10a &lt;- resampleData(.data = dat, .resample_method = "cross-validation", 
                      .R = 100)
str(cv_10a, max.level = 3, list.len = 3)

# Cross-validation can be done by group if a group identifyer is provided:
cv_10 &lt;- resampleData(.data = dat, .resample_method = "cross-validation", 
                      .id = "group", .R = 100)

## Leave-one-out-cross-validation (repeated 50 times)
cv_loocv  &lt;- resampleData(.data = dat[, -3], 
                          .resample_method = "cross-validation", 
                          .cv_folds = nrow(dat),
                          .R = 50)
str(cv_loocv, max.level = 2, list.len = 3)

### Permuation ---------------------------------------------------------------

res_perm &lt;- resampleData(.data = dat, .resample_method = "permutation",
                         .id = "group")
str(res_perm, max.level = 2, list.len = 3)

# Forgetting to set .id causes an error
## Not run: 
res_perm &lt;- resampleData(.data = dat, .resample_method = "permutation")

## End(Not run)

# ===========================================================================
# Using a cSEMResults object
# ===========================================================================

model &lt;- "
# Structural model
QUAL ~ EXPE
EXPE ~ IMAG
SAT  ~ IMAG + EXPE + QUAL + VAL
LOY  ~ IMAG + SAT
VAL  ~ EXPE + QUAL

# Measurement model
EXPE =~ expe1 + expe2 + expe3 + expe4 + expe5
IMAG =~ imag1 + imag2 + imag3 + imag4 + imag5
LOY  =~ loy1  + loy2  + loy3  + loy4
QUAL =~ qual1 + qual2 + qual3 + qual4 + qual5
SAT  =~ sat1  + sat2  + sat3  + sat4
VAL  =~ val1  + val2  + val3  + val4
"
a &lt;- csem(satisfaction, model)

# Create bootstrap and jackknife samples
res_boot &lt;- resampleData(a, .resample_method = "bootstrap", .R = 499)
res_jack &lt;- resampleData(a, .resample_method = "jackknife")

# Since `satisfaction` is the dataset used the following approaches yield
# identical results.
res_boot_data   &lt;- resampleData(.data = satisfaction, .seed = 2364)
res_boot_object &lt;- resampleData(a, .seed = 2364)

identical(res_boot_data, res_boot_object) # TRUE
</code></pre>

<hr>
<h2 id='Russett'>Data: Russett</h2><span id='topic+Russett'></span>

<h3>Description</h3>

<p>A data frame containing 10 variables with 47 observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Russett
</code></pre>


<h3>Format</h3>

<p>A data frame containing the following variables for 47 countries:
</p>

<dl>
<dt><code>gini</code></dt><dd><p>The Gini index of concentration</p>
</dd>
<dt><code>farm</code></dt><dd><p>The percentage of landholders who collectively occupy
one-half of all the agricultural land (starting with the farmers
with the smallest plots of land and working toward the largest)</p>
</dd>
<dt><code>rent</code></dt><dd><p>The percentage of the total number of farms that rent all
their land. Transformation: ln (x + 1)</p>
</dd>
<dt><code>gnpr</code></dt><dd><p>The 1955 gross national product per capita in U.S. dollars.
Transformation: ln (x)</p>
</dd>
<dt><code>labo</code></dt><dd><p>The percentage of the labor force employed in agriculture.
Transformation: ln (x)</p>
</dd>
<dt><code>inst</code></dt><dd><p>Instability of personnel based on the term of office of the
chief executive. Transformation: exp (x - 16.3)</p>
</dd>
<dt><code>ecks</code></dt><dd><p>The total number of politically motivated violent incidents,
from plots to protracted guerrilla warfare. Transformation: ln (x + 1)</p>
</dd>
<dt><code>deat</code></dt><dd><p>The number of people killed as a result of internal group
violence per 1,000,000 people. Transformation: ln (x + 1)</p>
</dd>
<dt><code>stab</code></dt><dd><p>One if the country has a stable democracy, and zero otherwise</p>
</dd>
<dt><code>dict</code></dt><dd><p>One if the country experiences a dictatorship, and zero otherwise</p>
</dd>
</dl>



<h3>Details</h3>

<p>The dataset was initially compiled by Russett (1964),
discussed and reprinted by Gifi (1990),
and partially transformed by Tenenhaus and Tenenhaus (2011).
It is also used in Henseler (2021) for demonstration
purposes.
</p>


<h3>Source</h3>

<p>From: Henseler (2021)
</p>


<h3>References</h3>

<p>Gifi A (1990).
<em>Nonlinear multivariate analysis</em>.
Wiley.<br /><br /> Henseler J (2021).
<em>Composite-Based Structural Equation Modeling: Analyzing Latent and Emergent Variables</em>.
Guilford Press, New York.<br /><br /> Russett BM (1964).
&ldquo;Inequality and Instability: The Relation of Land Tenure to Politics.&rdquo;
<em>World Politics</em>, <b>16</b>(3), 442&ndash;454.
<a href="https://doi.org/10.2307/2009581">doi:10.2307/2009581</a>.<br /><br /> Tenenhaus A, Tenenhaus M (2011).
&ldquo;Regularized generalized canonical correlation analysis.&rdquo;
<em>Psychometrika</em>, <b>76</b>(2), 257&ndash;284.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#============================================================================
# Example is taken from Henseler (2020)
#============================================================================
model_Russett="
# Composite model
AgrIneq &lt;~ gini + farm + rent
IndDev  &lt;~ gnpr + labo
PolInst &lt;~ inst + ecks + deat + stab + dict

# Structural model
PolInst ~ AgrIneq + IndDev
"

out &lt;- csem(.data = Russett, .model = model_Russett,
            .PLS_weight_scheme_inner = 'factorial',
            .tolerance = 1e-06
)

</code></pre>

<hr>
<h2 id='satisfaction'>Data: satisfaction</h2><span id='topic+satisfaction'></span>

<h3>Description</h3>

<p>A data frame with 250 observations and 27 variables.
Variables from 1 to 27 refer to six latent concepts: <code>IMAG</code>=Image,
<code>EXPE</code>=Expectations, <code>QUAL</code>=Quality, <code>VAL</code>=Value,
<code>SAT</code>=Satisfaction, and <code>LOY</code>=Loyalty.
</p>

<dl>
<dt>imag1-imag5</dt><dd><p>Indicators attached to concept <code>IMAG</code> which is supposed to
capture aspects such as the institutions reputation,
trustworthiness, seriousness, solidness, and caring
about customer.</p>
</dd>
<dt>expe1-expe5</dt><dd><p>Indicators attached to concept <code>EXPE</code> which is supposed to
capture aspects concerning products and
services provided, customer service, providing solutions,
and expectations for the overall quality.</p>
</dd>
<dt>qual1-qual5</dt><dd><p>Indicators attached to concept <code>QUAL</code> which is supposed to
capture aspects concerning reliability of products and services,
the range of products and services, personal advice,
and overall perceived quality.</p>
</dd>
<dt>val1-val4</dt><dd><p>Indicators attached to concept <code>VAL</code> which is supposed to
capture aspects related to beneficial services and
products, valuable investments, quality relative to
price, and price relative to quality.</p>
</dd>
<dt>sat1-sat4</dt><dd><p>Indicators attached to concept <code>SAT</code> which is supposed to
capture aspects concerning overall rating of satisfaction,
fulfillment of expectations, satisfaction relative to
other banks, and performance relative to customer's
ideal bank.</p>
</dd>
<dt>loy1-loy4</dt><dd><p>Indicators attached to concept <code>LOY</code> which is supposed to
capture aspects concerning propensity to choose the
same bank again, propensity to switch to other bank,
intention to recommend the bank to friends,
and the sense of loyalty.</p>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>satisfaction
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 250 rows and 27 columns.
</p>


<h3>Details</h3>

<p>This dataset contains the variables from a customer satisfaction study of
a Spanish credit institution on 250 customers. The data is identical to
the dataset provided by the <a href="https://github.com/gastonstat/plspm/">plspm</a> package
but with the last column  (<code>gender</code>) removed. If you are looking for the original
dataset use the <a href="#topic+satisfaction_gender">satisfaction_gender</a> dataset.
</p>


<h3>Source</h3>

<p>The <a href="https://github.com/gastonstat/plspm/">plspm</a> package (version  0.4.9).
Original source according to <span class="pkg">plspm</span>:
&quot;Laboratory of Information Analysis and Modeling (LIAM).
Facultat d'Informatica de Barcelona, Universitat Politecnica de Catalunya&quot;.
</p>

<hr>
<h2 id='satisfaction_gender'>Data: satisfaction including gender</h2><span id='topic+satisfaction_gender'></span>

<h3>Description</h3>

<p>A data frame with 250 observations and 28 variables.
Variables from 1 to 27 refer to six latent concepts: <code>IMAG</code>=Image,
<code>EXPE</code>=Expectations, <code>QUAL</code>=Quality, <code>VAL</code>=Value,
<code>SAT</code>=Satisfaction, and <code>LOY</code>=Loyalty.
</p>

<dl>
<dt>imag1-imag5</dt><dd><p>Indicators attached to concept <code>IMAG</code> which is supposed to
capture aspects such as the institutions reputation,
trustworthiness, seriousness, solidness, and caring
about customer.</p>
</dd>
<dt>expe1-expe5</dt><dd><p>Indicators attached to concept <code>EXPE</code> which is supposed to
capture aspects concerning products and
services provided, customer service, providing solutions,
and expectations for the overall quality.</p>
</dd>
<dt>qual1-qual5</dt><dd><p>Indicators attached to concept <code>QUAL</code> which is supposed to
capture aspects concerning reliability of products and services,
the range of products and services, personal advice,
and overall perceived quality.</p>
</dd>
<dt>val1-val4</dt><dd><p>Indicators attached to concept <code>VAL</code> which is supposed to
capture aspects related to beneficial services and
products, valuable investments, quality relative to
price, and price relative to quality.</p>
</dd>
<dt>sat1-sat4</dt><dd><p>Indicators attached to concept <code>SAT</code> which is supposed to
capture aspects concerning overall rating of satisfaction,
fulfillment of expectations, satisfaction relative to
other banks, and performance relative to customer's
ideal bank.</p>
</dd>
<dt>loy1-loy4</dt><dd><p>Indicators attached to concept <code>LOY</code> which is supposed to
capture aspects concerning propensity to choose the
same bank again, propensity to switch to other bank,
intention to recommend the bank to friends,
and the sense of loyalty.</p>
</dd>
<dt>gender</dt><dd><p>The sex of the respondent.</p>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>satisfaction_gender
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 250 rows and 28 columns.
</p>


<h3>Details</h3>

<p>This data set contains the variables from a customer satisfaction study of
a Spanish credit institution on 250 customers. The data is taken from the
<a href="https://github.com/gastonstat/plspm/">plspm</a> package. For convenience,
there is a version of the dataset with the last column (<code>gender</code>) removed: <a href="#topic+satisfaction">satisfaction</a>.
</p>


<h3>Source</h3>

<p>The <a href="https://github.com/gastonstat/plspm/">plspm</a> package (version  0.4.9).
Original source according to <span class="pkg">plspm</span>:
&quot;Laboratory of Information Analysis and Modeling (LIAM).
Facultat d'Informatica de Barcelona, Universitat Politecnica de Catalunya&quot;.
</p>

<hr>
<h2 id='scaleWeights'>Internal: Scale weights</h2><span id='topic+scaleWeights'></span>

<h3>Description</h3>

<p>Scale weights such that the formed composite has unit variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scaleWeights(
  .S = args_default()$.S, 
  .W = args_default()$.W
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scaleWeights_+3A_.s">.S</code></td>
<td>
<p>The (K x K) empirical indicator correlation matrix.</p>
</td></tr>
<tr><td><code id="scaleWeights_+3A_.w">.W</code></td>
<td>
<p>A (J x K) matrix of weights.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The (J x K) matrix of scaled weights.
</p>

<hr>
<h2 id='setDominantIndicator'>Internal: Set the dominant indicator</h2><span id='topic+setDominantIndicator'></span>

<h3>Description</h3>

<p>Set the dominant indicator for each construct. Since the sign of the weights,
and thus the loadings is often not determined, a dominant indicator can be chosen
per block. The sign of the weights are chosen that the correlation between the
dominant indicator and the composite is positive.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setDominantIndicator(
 .W                   = args_default()$.W,
 .dominant_indicators = args_default()$.dominant_indicators, 
 .S                   = args_default()$.S
 )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setDominantIndicator_+3A_.w">.W</code></td>
<td>
<p>A (J x K) matrix of weights.</p>
</td></tr>
<tr><td><code id="setDominantIndicator_+3A_.dominant_indicators">.dominant_indicators</code></td>
<td>
<p>A character vector of <code>"construct_name" = "indicator_name"</code> pairs,
where <code>"indicator_name"</code> is a character string giving the name of the dominant indicator
and <code>"construct_name"</code> a character string of the corresponding construct name.
Dominant indicators may be specified for a subset of the constructs.
Default to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="setDominantIndicator_+3A_.s">.S</code></td>
<td>
<p>The (K x K) empirical indicator correlation matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The (J x K) matrix of weights with the dominant indicator set.
</p>

<hr>
<h2 id='setStartingValues'>Internal: Set starting values</h2><span id='topic+setStartingValues'></span>

<h3>Description</h3>

<p>Set the starting values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setStartingValues(
  .W               = args_default()$.W,
  .starting_values = args_default()$.starting_values
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setStartingValues_+3A_.w">.W</code></td>
<td>
<p>A (J x K) matrix of weights.</p>
</td></tr>
<tr><td><code id="setStartingValues_+3A_.starting_values">.starting_values</code></td>
<td>
<p>A named list of vectors where the
list names are the construct names whose indicator weights the user
wishes to set. The vectors must be named vectors of <code>"indicator_name" = value</code>
pairs, where <code>value</code> is the (scaled or unscaled) starting weight. Defaults to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The (J x K) matrix of starting values.
</p>

<hr>
<h2 id='Sigma_Summers_composites'>Data: Summers</h2><span id='topic+Sigma_Summers_composites'></span>

<h3>Description</h3>

<p>A (18 x 18) indicator correlation matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Sigma_Summers_composites
</code></pre>


<h3>Format</h3>

<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 18 rows and 18 columns.
</p>


<h3>Details</h3>

<p>The indicator correlation matrix for a modified version of Summers (1965)
model. All constructs are modeled as composites.
</p>


<h3>Source</h3>

<p>Own calculation based on Dijkstra and Henseler (2015).
</p>


<h3>References</h3>

<p>Dijkstra TK, Henseler J (2015).
&ldquo;Consistent and Asymptotically Normal PLS Estimators for Linear Structural Equations.&rdquo;
<em>Computational Statistics &amp; Data Analysis</em>, <b>81</b>, 10&ndash;23.<br /><br /> Summers R (1965).
&ldquo;A Capital Intensive Approach to the Small Sample Properties of Various Simultaneous Equation Estimators.&rdquo;
<em>Econometrica</em>, <b>33</b>(1), 1&ndash;41.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(cSEM)

model &lt;- "
ETA1 ~ ETA2 + XI1 + XI2
ETA2 ~ ETA1 + XI3 +XI4

ETA1 ~~ ETA2

XI1  &lt;~ x1 + x2 + x3
XI2  &lt;~ x4 + x5 + x6
XI3  &lt;~ x7 + x8 + x9
XI4  &lt;~ x10 + x11 + x12
ETA1 &lt;~ y1 + y2 + y3
ETA2 &lt;~ y4 + y5 + y6
"

## Generate data
summers_dat &lt;- MASS::mvrnorm(n = 300, mu = rep(0, 18), 
                             Sigma = Sigma_Summers_composites, empirical = TRUE)

## Estimate
res &lt;- csem(.data = summers_dat, .model = model) # inconsistent

## 
# 2SLS
res_2SLS &lt;- csem(.data = summers_dat, .model = model, .approach_paths = "2SLS",
                 .instruments = list(ETA1 = c('XI1', 'XI2', 'XI3', 'XI4'),
                                     ETA2 = c('XI1', 'XI2', 'XI3', 'XI4'))
)

</code></pre>

<hr>
<h2 id='SQ'>Data: SQ</h2><span id='topic+SQ'></span>

<h3>Description</h3>

<p>A data frame containing 23 variables with 411 observations. The original
indicators were measured on a 6-point scale. In this version of the dataset,
the indicators are scaled to be between 0 and 100.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SQ
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 411 rows and 23 columns.
</p>


<h3>Details</h3>

<p>The data comes from a European manufacturer of durable consumer goods and was
studied by Bliemel et al. (2004) who focused on service quality.
It is also used in Henseler (2021)
for demonstration purposes, see the corresponding tutorial.
</p>


<h3>Source</h3>

<p>The dataset is provided by Jörg Henseler.
</p>


<h3>References</h3>

<p>Bliemel FW, Adolphs K, Henseler J (2004).
&ldquo;Reconceptualizing service quality. A formative measurement approach using PLS path modeling.&rdquo;
In Munuera-Aleman JL (ed.), <em>Proceedings of the 33rd EMAC Conference</em>, 224.<br /><br /> Henseler J (2021).
<em>Composite-Based Structural Equation Modeling: Analyzing Latent and Emergent Variables</em>.
Guilford Press, New York.
</p>

<hr>
<h2 id='structureTestMGDDecisions'>Internal: get structured cSEMTestMGD results</h2><span id='topic+structureTestMGDDecisions'></span>

<h3>Description</h3>

<p>Convenience function to summarize the results of all tests resulting from a
call to <code><a href="#topic+testMGD">testMGD()</a></code> in a user-friendly way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>structureTestMGDDecisions(.object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="structureTestMGDDecisions_+3A_.object">.object</code></td>
<td>
<p>An R object of class <a href="#topic+cSEMResults">cSEMResults</a> resulting from a call to <code><a href="#topic+csem">csem()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame.
</p>

<hr>
<h2 id='summarize'>Summarize model</h2><span id='topic+summarize'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize(
 .object = NULL, 
 .alpha  = 0.05,
 .ci     = NULL,
 ...
 )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarize_+3A_.object">.object</code></td>
<td>
<p>An R object of class <a href="#topic+cSEMResults">cSEMResults</a> resulting from a call to <code><a href="#topic+csem">csem()</a></code>.</p>
</td></tr>
<tr><td><code id="summarize_+3A_.alpha">.alpha</code></td>
<td>
<p>An integer or a numeric vector of significance levels.
Defaults to <code>0.05</code>.</p>
</td></tr>
<tr><td><code id="summarize_+3A_.ci">.ci</code></td>
<td>
<p>A vector of character strings naming the confidence interval to compute.
For possible choices see <code><a href="#topic+infer">infer()</a></code>.</p>
</td></tr>
<tr><td><code id="summarize_+3A_...">...</code></td>
<td>
<p>Further arguments to <code>summarize()</code>. Currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The summary is mainly focused on estimated parameters. For quality criteria
such as the average variance extracted (AVE), reliability estimates,
effect size estimates etc., use <code><a href="#topic+assess">assess()</a></code>.
</p>
<p>If <code>.object</code> contains resamples, standard errors, t-values and p-values
(assuming estimates are standard normally distributed) are printed as well.
By default the percentile confidence interval is given as well. For other
confidence intervals use the <code>.ci</code> argument. See <code><a href="#topic+infer">infer()</a></code> for possible choices
and a description.
</p>


<h3>Value</h3>

<p>An object of class <code>cSEMSummarize</code>. A <code>cSEMSummarize</code> object has
the same structure as the <a href="#topic+cSEMResults">cSEMResults</a> object with a couple differences:
</p>

<ol>
<li><p>Elements <code style="white-space: pre;">&#8288;$Path_estimates&#8288;</code>, <code style="white-space: pre;">&#8288;$Loadings_estimates&#8288;</code>, <code style="white-space: pre;">&#8288;$Weight_estimates&#8288;</code>,
<code style="white-space: pre;">&#8288;$Weight_estimates&#8288;</code>, and  <code style="white-space: pre;">&#8288;$Residual_correlation&#8288;</code> are standardized data frames instead of matrices.
</p>
</li>
<li><p>Data frames <code style="white-space: pre;">&#8288;$Effect_estimates&#8288;</code>, <code style="white-space: pre;">&#8288;$Indicator_correlation&#8288;</code>, and
<code style="white-space: pre;">&#8288;$Exo_construct_correlation&#8288;</code> are added to <code style="white-space: pre;">&#8288;$Estimates&#8288;</code>.
</p>
</li></ol>

<p>The data frame format is usually much more convenient if users intend to
present the results in e.g., a paper or a presentation.
</p>


<h3>See Also</h3>

<p><a href="#topic+csem">csem</a>, <code><a href="#topic+assess">assess()</a></code>, <a href="#topic+cSEMResults">cSEMResults</a>, <code><a href="#topic+exportToExcel">exportToExcel()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Take a look at the dataset
#?threecommonfactors

## Specify the (correct) model
model &lt;- "
# Structural model
eta2 ~ eta1
eta3 ~ eta1 + eta2

# (Reflective) measurement model
eta1 =~ y11 + y12 + y13
eta2 =~ y21 + y22 + y23
eta3 =~ y31 + y32 + y33
"

## Estimate
res &lt;- csem(threecommonfactors, model, .resample_method = "bootstrap", .R = 40)

## Postestimation
res_summarize &lt;- summarize(res)
res_summarize

# Extract e.g. the loadings
res_summarize$Estimates$Loading_estimates

## By default only the 95% percentile confidence interval is printed. User
## can have several confidence interval computed, however, only the first
## will be printed.

res_summarize &lt;- summarize(res, .ci = c("CI_standard_t", "CI_percentile"), 
                           .alpha = c(0.05, 0.01))
res_summarize

# Extract the loading including both confidence intervals
res_summarize$Estimates$Path_estimates
</code></pre>

<hr>
<h2 id='Switching'>Data: Switching</h2><span id='topic+Switching'></span>

<h3>Description</h3>

<p>A data frame containing 26 variables with 767 observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Switching
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 767 rows and 26 columns.
</p>


<h3>Details</h3>

<p>The data contains variables about the consumers’ intention to switch a
service provider. It is also used in Henseler (2021)
for demonstration purposes, see the corresponding tutorial.
</p>


<h3>Source</h3>

<p>The dataset is provided by Jörg Henseler.
</p>


<h3>References</h3>

<p>Henseler J (2021).
<em>Composite-Based Structural Equation Modeling: Analyzing Latent and Emergent Variables</em>.
Guilford Press, New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#============================================================================
# Example is taken from Henseler (2021)
#============================================================================
model_Int &lt;-"
# Measurement models
INV =~ INV1 + INV2 + INV3 +INV4
SAT =~ SAT1 + SAT2 + SAT3
INT =~ INT1 + INT2

# Structural model containing an interaction term.
INT ~ INV + SAT + INV.SAT
"

out &lt;- csem(.data = Switching, .model = model_Int,
            .PLS_weight_scheme_inner = 'factorial',
            .tolerance = 1e-06)

</code></pre>

<hr>
<h2 id='testCVPAT'>Perform a Cross-Validated Predictive Ability Test (CVPAT)</h2><span id='topic+testCVPAT'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#maturing"><img src="../help/figures/lifecycle-maturing.svg" alt='[Maturing]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testCVPAT(
.object1              = NULL,
.object2              = NULL,
.approach_predict     = c("earliest", "direct"),
.seed                 = NULL,
.cv_folds             = 10,
.handle_inadmissibles = c("stop", "ignore"),
.testtype             = c("twosided", "onesided"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testCVPAT_+3A_.object1">.object1</code></td>
<td>
<p>An R object of class <a href="#topic+cSEMResults">cSEMResults</a> resulting from a call to <code><a href="#topic+csem">csem()</a></code>.</p>
</td></tr>
<tr><td><code id="testCVPAT_+3A_.object2">.object2</code></td>
<td>
<p>An R object of class <a href="#topic+cSEMResults">cSEMResults</a> resulting from a call to <code><a href="#topic+csem">csem()</a></code>.</p>
</td></tr>
<tr><td><code id="testCVPAT_+3A_.approach_predict">.approach_predict</code></td>
<td>
<p>Character string. Which approach should be used to
predictions? One of &quot;<em>earliest</em>&quot; and &quot;<em>direct</em>&quot;. If &quot;<em>earliest</em>&quot; predictions
for indicators associated to endogenous constructs are performed using only
indicators associated to exogenous constructs. If &quot;<em>direct</em>&quot;, predictions for
indicators associated to endogenous constructs are based on indicators associated
to their direct antecedents. Defaults to &quot;<em>earliest</em>&quot;.</p>
</td></tr>
<tr><td><code id="testCVPAT_+3A_.seed">.seed</code></td>
<td>
<p>Integer or <code>NULL</code>. The random seed to use. Defaults to <code>NULL</code> in which
case an arbitrary seed is chosen. Note that the scope of the seed is limited
to the body of the function it is used in. Hence, the global seed will
not be altered!</p>
</td></tr>
<tr><td><code id="testCVPAT_+3A_.cv_folds">.cv_folds</code></td>
<td>
<p>Integer. The number of cross-validation folds to use. Setting
<code>.cv_folds</code> to <code>N</code> (the number of observations) produces
leave-one-out cross-validation samples. Defaults to <code>10</code>.</p>
</td></tr>
<tr><td><code id="testCVPAT_+3A_.handle_inadmissibles">.handle_inadmissibles</code></td>
<td>
<p>Character string. How should inadmissible results
be treated? One of &quot;<em>drop</em>&quot;, &quot;<em>ignore</em>&quot;, or &quot;<em>replace</em>&quot;. If &quot;<em>drop</em>&quot;, all
replications/resamples yielding an inadmissible result will be dropped
(i.e. the number of results returned will potentially be less than <code>.R</code>).
For &quot;<em>ignore</em>&quot; all results are returned even if all or some of the replications
yielded inadmissible results (i.e. number of results returned is equal to <code>.R</code>).
For &quot;<em>replace</em>&quot; resampling continues until there are exactly <code>.R</code> admissible solutions.
Depending on the frequency of inadmissible solutions this may significantly increase
computing time. Defaults to &quot;<em>drop</em>&quot;.</p>
</td></tr>
<tr><td><code id="testCVPAT_+3A_.testtype">.testtype</code></td>
<td>
<p>Character string. One of &quot;<em>twosided</em>&quot; (H1: The models do not
perform equally in predicting indicators belonging to endogenous constructs)&quot;
and <em>onesided</em>&quot; (H1: Model 1 performs better in predicting indicators belonging
to endogenous constructs than model2). Defaults to &quot;<em>twosided</em>&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Perform a Cross-Validated Predictive Ability Test (CVPAT) as described in
(Liengaard et al. 2020). The predictive performance of two models
based on the same dataset is compared. In doing so, the average difference in
losses in predictions is compared for both models.
</p>


<h3>Value</h3>

<p>An object of class <code>cSEMCVPAT</code> with print and plot methods.
Technically, <code>cSEMCVPAT</code> is a
named list containing the following list elements:
</p>

<dl>
<dt>'$Information'</dt><dd><p>Additional information.</p>
</dd>
</dl>



<h3>References</h3>

<p>Liengaard BD, Sharma PN, Hult GTM, Jensen MB, Sarstedt M, Hair JF, Ringle CM (2020).
&ldquo;Prediction: Coveted, Yet Forsaken? Introducing a Cross-Validated Predictive Ability Test in Partial Least Squares Path Modeling.&rdquo;
<em>Decision Sciences</em>, <b>52</b>(2), 362&ndash;392.
<a href="https://doi.org/10.1111/deci.12445">doi:10.1111/deci.12445</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+csem">csem</a>, <a href="#topic+cSEMResults">cSEMResults</a>, <code><a href="#topic+exportToExcel">exportToExcel()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Anime example taken from https://github.com/ISS-Analytics/pls-predict/

# Load data
data(Anime) # data is similar to the Anime.csv found on 
            # https://github.com/ISS-Analytics/pls-predict/ but with irrelevant
            # columns removed

# Split into training and data the same way as it is done on 
# https://github.com/ISS-Analytics/pls-predict/
set.seed(123)

index     &lt;- sample.int(dim(Anime)[1], 83, replace = FALSE)
dat_train &lt;- Anime[-index, ]
dat_test  &lt;- Anime[index, ]

# Specify model
model &lt;- "
# Structural model

ApproachAvoidance ~ PerceivedVisualComplexity + Arousal

# Measurement/composite model

ApproachAvoidance         =~ AA0 + AA1 + AA2 + AA3
PerceivedVisualComplexity &lt;~ VX0 + VX1 + VX2 + VX3 + VX4
Arousal                   &lt;~ Aro1 + Aro2 + Aro3 + Aro4
"

# Estimate (replicating the results of the `simplePLS()` function)
res &lt;- csem(dat_train, 
            model, 
            .disattenuate = FALSE, # original PLS
            .iter_max = 300, 
            .tolerance = 1e-07, 
            .PLS_weight_scheme_inner = "factorial"
)

# Predict using a user-supplied training data set
pp &lt;- predict(res, .test_data = dat_test)
pp

### Compute prediction metrics  ------------------------------------------------
res2 &lt;- csem(Anime, # whole data set
            model, 
            .disattenuate = FALSE, # original PLS
            .iter_max = 300, 
            .tolerance = 1e-07, 
            .PLS_weight_scheme_inner = "factorial"
)

# Predict using 10-fold cross-validation
## Not run: 
pp2 &lt;- predict(res, .benchmark = "lm")
pp2
## There is a plot method available
plot(pp2)
## End(Not run)

### Example using OrdPLScPredict -----------------------------------------------
# Transform the numerical indicators into factors
## Not run: 
data("BergamiBagozzi2000")
data_new &lt;- data.frame(cei1    = as.ordered(BergamiBagozzi2000$cei1),
                       cei2    = as.ordered(BergamiBagozzi2000$cei2),
                       cei3    = as.ordered(BergamiBagozzi2000$cei3),
                       cei4    = as.ordered(BergamiBagozzi2000$cei4),
                       cei5    = as.ordered(BergamiBagozzi2000$cei5),
                       cei6    = as.ordered(BergamiBagozzi2000$cei6),
                       cei7    = as.ordered(BergamiBagozzi2000$cei7),
                       cei8    = as.ordered(BergamiBagozzi2000$cei8),
                       ma1     = as.ordered(BergamiBagozzi2000$ma1),
                       ma2     = as.ordered(BergamiBagozzi2000$ma2),
                       ma3     = as.ordered(BergamiBagozzi2000$ma3),
                       ma4     = as.ordered(BergamiBagozzi2000$ma4),
                       ma5     = as.ordered(BergamiBagozzi2000$ma5),
                       ma6     = as.ordered(BergamiBagozzi2000$ma6),
                       orgcmt1 = as.ordered(BergamiBagozzi2000$orgcmt1),
                       orgcmt2 = as.ordered(BergamiBagozzi2000$orgcmt2),
                       orgcmt3 = as.ordered(BergamiBagozzi2000$orgcmt3),
                       orgcmt5 = as.ordered(BergamiBagozzi2000$orgcmt5),
                       orgcmt6 = as.ordered(BergamiBagozzi2000$orgcmt6),
                       orgcmt7 = as.ordered(BergamiBagozzi2000$orgcmt7),
                       orgcmt8 = as.ordered(BergamiBagozzi2000$orgcmt8))

model &lt;- "
# Measurement models
OrgPres =~ cei1 + cei2 + cei3 + cei4 + cei5 + cei6 + cei7 + cei8
OrgIden =~ ma1 + ma2 + ma3 + ma4 + ma5 + ma6
AffJoy  =~ orgcmt1 + orgcmt2 + orgcmt3 + orgcmt7
AffLove =~ orgcmt5 + orgcmt 6 + orgcmt8

# Structural model
OrgIden ~ OrgPres
AffLove ~ OrgIden
AffJoy  ~ OrgIden 
"
# Estimate using cSEM; note: the fact that indicators are factors triggers OrdPLSc
res &lt;- csem(.model = model, .data = data_new[1:250,])
summarize(res)

# Predict using OrdPLSPredict
set.seed(123)
pred &lt;- predict(
  .object = res, 
  .benchmark = "PLS-PM",
  .test_data = data_new[(251):305,],
   .treat_as_continuous = TRUE, .approach_score_target = "median"
  )

pred 
round(pred$Prediction_metrics[, -1], 4)
## End(Not run)
</code></pre>

<hr>
<h2 id='testHausman'>Regression-based Hausman test</h2><span id='topic+testHausman'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testHausman(
 .object               = NULL,
 .eval_plan            = c("sequential", "multicore", "multisession"),
 .handle_inadmissibles = c("drop", "ignore", "replace"),
 .R                    = 499,
 .resample_method      = c("bootstrap", "jackknife"),
 .seed                 = NULL
 )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testHausman_+3A_.object">.object</code></td>
<td>
<p>An R object of class <a href="#topic+cSEMResults">cSEMResults</a> resulting from a call to <code><a href="#topic+csem">csem()</a></code>.</p>
</td></tr>
<tr><td><code id="testHausman_+3A_.eval_plan">.eval_plan</code></td>
<td>
<p>Character string. The evaluation plan to use. One of
&quot;<em>sequential</em>&quot;, &quot;<em>multicore</em>&quot;, or &quot;<em>multisession</em>&quot;. In the two latter cases
all available cores will be used. Defaults to &quot;<em>sequential</em>&quot;.</p>
</td></tr>
<tr><td><code id="testHausman_+3A_.handle_inadmissibles">.handle_inadmissibles</code></td>
<td>
<p>Character string. How should inadmissible results
be treated? One of &quot;<em>drop</em>&quot;, &quot;<em>ignore</em>&quot;, or &quot;<em>replace</em>&quot;. If &quot;<em>drop</em>&quot;, all
replications/resamples yielding an inadmissible result will be dropped
(i.e. the number of results returned will potentially be less than <code>.R</code>).
For &quot;<em>ignore</em>&quot; all results are returned even if all or some of the replications
yielded inadmissible results (i.e. number of results returned is equal to <code>.R</code>).
For &quot;<em>replace</em>&quot; resampling continues until there are exactly <code>.R</code> admissible solutions.
Depending on the frequency of inadmissible solutions this may significantly increase
computing time. Defaults to &quot;<em>drop</em>&quot;.</p>
</td></tr>
<tr><td><code id="testHausman_+3A_.r">.R</code></td>
<td>
<p>Integer. The number of bootstrap replications. Defaults to <code>499</code>.</p>
</td></tr>
<tr><td><code id="testHausman_+3A_.resample_method">.resample_method</code></td>
<td>
<p>Character string. The resampling method to use. One of:
&quot;<em>none</em>&quot;, &quot;<em>bootstrap</em>&quot; or &quot;<em>jackknife</em>&quot;. Defaults to &quot;<em>none</em>&quot;.</p>
</td></tr>
<tr><td><code id="testHausman_+3A_.seed">.seed</code></td>
<td>
<p>Integer or <code>NULL</code>. The random seed to use. Defaults to <code>NULL</code> in which
case an arbitrary seed is chosen. Note that the scope of the seed is limited
to the body of the function it is used in. Hence, the global seed will
not be altered!</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the regression-based Hausman test to be used to compare
OLS to 2SLS estimates or 2SLS to 3SLS estimates. See e.g., Wooldridge (2010)
(pages 131 f.) for details.
</p>
<p>The function is somewhat experimental. Only use if you know what you are doing.
</p>


<h3>References</h3>

<p>Wooldridge JM (2010).
<em>Econometric Analysis of Cross Section and Panel Data</em>, 2 edition.
MIT Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+csem">csem()</a></code>, <a href="#topic+cSEMResults">cSEMResults</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Example from Dijkstra &amp; Hensler (2015)
## Prepartion (values are from p. 15-16 of the paper)
Lambda &lt;- t(kronecker(diag(6), c(0.7, 0.7, 0.7)))
Phi &lt;- matrix(c(1.0000, 0.5000, 0.5000, 0.5000, 0.0500, 0.4000, 
                0.5000, 1.0000, 0.5000, 0.5000, 0.5071, 0.6286,
                0.5000, 0.5000, 1.0000, 0.5000, 0.2929, 0.7714,
                0.5000, 0.5000, 0.5000, 1.0000, 0.2571, 0.6286,
                0.0500, 0.5071, 0.2929, 0.2571, 1.0000, sqrt(0.5),
                0.4000, 0.6286, 0.7714, 0.6286, sqrt(0.5), 1.0000), 
              ncol = 6)

## Create population indicator covariance matrix
Sigma &lt;- t(Lambda) %*% Phi %*% Lambda
diag(Sigma) &lt;- 1
dimnames(Sigma) &lt;- list(paste0("x", rep(1:6, each = 3), 1:3),
                        paste0("x", rep(1:6, each = 3), 1:3))

## Generate data
dat &lt;- MASS::mvrnorm(n = 500, mu = rep(0, 18), Sigma = Sigma, empirical = TRUE)
# empirical = TRUE to show that 2SLS is in fact able to recover the true population
# parameters.

## Model to estimate
model &lt;- "
## Structural model (nonrecurisve)
eta5 ~ eta6 + eta1 + eta2
eta6 ~ eta5 + eta3 + eta4

## Measurement model
eta1 =~ x11 + x12 + x13
eta2 =~ x21 + x22 + x23
eta3 =~ x31 + x32 + x33
eta4 =~ x41 + x42 + x43

eta5 =~ x51 + x52 + x53
eta6 =~ x61 + x62 + x63
"

library(cSEM)

## Estimate
res_ols &lt;- csem(dat, .model = model, .approach_paths = "OLS")
sum_res_ols &lt;- summarize(res_ols) 

# Note: For the example the model-implied indicator correlation is irrelevant
#       the warnings can be ignored.

res_2sls &lt;- csem(dat, .model = model, .approach_paths = "2SLS",
                 .instruments = list("eta5" = c('eta1','eta2','eta3','eta4'), 
                                     "eta6" = c('eta1','eta2','eta3','eta4')))
sum_res_2sls &lt;- summarize(res_2sls)
# Note that exogenous constructs are supplied as instruments for themselves!

## Test for endogeneity
test_ha &lt;- testHausman(res_2sls, .R = 200)
test_ha
</code></pre>

<hr>
<h2 id='testMGD'>Tests for multi-group comparisons</h2><span id='topic+testMGD'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testMGD(
 .object                = NULL,
 .alpha                 = 0.05,
 .approach_p_adjust     = "none",
 .approach_mgd          = c("all", "Klesel", "Chin", "Sarstedt", 
                            "Keil", "Nitzl", "Henseler", "CI_para","CI_overlap"),
 .output_type           = c("complete", "structured"),
 .parameters_to_compare = NULL,
 .eval_plan             = c("sequential", "multicore", "multisession"),                           
 .handle_inadmissibles  = c("replace", "drop", "ignore"),
 .R_permutation         = 499,
 .R_bootstrap           = 499,
 .saturated             = FALSE,
 .seed                  = NULL,
 .type_ci               = "CI_percentile",
 .type_vcv              = c("indicator", "construct"),
 .verbose               = TRUE
 )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testMGD_+3A_.object">.object</code></td>
<td>
<p>An R object of class <a href="#topic+cSEMResults">cSEMResults</a> resulting from a call to <code><a href="#topic+csem">csem()</a></code>.</p>
</td></tr>
<tr><td><code id="testMGD_+3A_.alpha">.alpha</code></td>
<td>
<p>An integer or a numeric vector of significance levels.
Defaults to <code>0.05</code>.</p>
</td></tr>
<tr><td><code id="testMGD_+3A_.approach_p_adjust">.approach_p_adjust</code></td>
<td>
<p>Character string or a vector of character strings.
Approach used to adjust the p-value for multiple testing.
See the <code>methods</code> argument of <code><a href="stats.html#topic+p.adjust">stats::p.adjust()</a></code> for a list of choices and
their description. Defaults to &quot;<em>none</em>&quot;.</p>
</td></tr>
<tr><td><code id="testMGD_+3A_.approach_mgd">.approach_mgd</code></td>
<td>
<p>Character string or a vector of character strings.
Approach used for the multi-group comparison. One of: &quot;<em>all</em>&quot;, &quot;<em>Klesel</em>&quot;, &quot;<em>Chin</em>&quot;,
&quot;<em>Sarstedt</em>&quot;, &quot;<em>Keil</em>, &quot;<em>Nitzl</em>&quot;, &quot;<em>Henseler</em>&quot;, &quot;<em>CI_para</em>&quot;, or &quot;<em>CI_overlap</em>&quot;.
Default to &quot;<em>all</em>&quot; in which case all approaches are computed (if possible).</p>
</td></tr>
<tr><td><code id="testMGD_+3A_.output_type">.output_type</code></td>
<td>
<p>Character string. The type of output to return. One of
&quot;<em>complete</em>&quot; or &quot;<em>structured</em>&quot;. See the Value section for details. Defaults to
&quot;<em>complete</em>&quot;.</p>
</td></tr>
<tr><td><code id="testMGD_+3A_.parameters_to_compare">.parameters_to_compare</code></td>
<td>
<p>A model in <a href="lavaan.html#topic+model.syntax">lavaan model syntax</a> indicating which
parameters (i.e, path (<code>~</code>), loadings (<code style="white-space: pre;">&#8288;=~&#8288;</code>), weights (<code style="white-space: pre;">&#8288;&lt;~&#8288;</code>), or correlations (<code style="white-space: pre;">&#8288;~~&#8288;</code>)) should be
compared across groups. Defaults to <code>NULL</code> in which case all weights, loadings and
path coefficients of the originally specified model are compared.</p>
</td></tr>
<tr><td><code id="testMGD_+3A_.eval_plan">.eval_plan</code></td>
<td>
<p>Character string. The evaluation plan to use. One of
&quot;<em>sequential</em>&quot;, &quot;<em>multicore</em>&quot;, or &quot;<em>multisession</em>&quot;. In the two latter cases
all available cores will be used. Defaults to &quot;<em>sequential</em>&quot;.</p>
</td></tr>
<tr><td><code id="testMGD_+3A_.handle_inadmissibles">.handle_inadmissibles</code></td>
<td>
<p>Character string. How should inadmissible results
be treated? One of &quot;<em>drop</em>&quot;, &quot;<em>ignore</em>&quot;, or &quot;<em>replace</em>&quot;. If &quot;<em>drop</em>&quot;, all
replications/resamples yielding an inadmissible result will be dropped
(i.e. the number of results returned will potentially be less than <code>.R</code>).
For &quot;<em>ignore</em>&quot; all results are returned even if all or some of the replications
yielded inadmissible results (i.e. number of results returned is equal to <code>.R</code>).
For &quot;<em>replace</em>&quot; resampling continues until there are exactly <code>.R</code> admissible solutions.
Defaults to &quot;<em>replace</em>&quot; to accommodate all approaches.</p>
</td></tr>
<tr><td><code id="testMGD_+3A_.r_permutation">.R_permutation</code></td>
<td>
<p>Integer. The number of permutations. Defaults to <code>499</code></p>
</td></tr>
<tr><td><code id="testMGD_+3A_.r_bootstrap">.R_bootstrap</code></td>
<td>
<p>Integer. The number of bootstrap runs. Ignored if <code>.object</code>
contains resamples. Defaults to <code>499</code></p>
</td></tr>
<tr><td><code id="testMGD_+3A_.saturated">.saturated</code></td>
<td>
<p>Logical. Should a saturated structural model be used?
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="testMGD_+3A_.seed">.seed</code></td>
<td>
<p>Integer or <code>NULL</code>. The random seed to use. Defaults to <code>NULL</code> in which
case an arbitrary seed is chosen. Note that the scope of the seed is limited
to the body of the function it is used in. Hence, the global seed will
not be altered!</p>
</td></tr>
<tr><td><code id="testMGD_+3A_.type_ci">.type_ci</code></td>
<td>
<p>Character string. Which confidence interval should be calculated?
For possible choices, see the <code>.quantity</code> argument of the <code><a href="#topic+infer">infer()</a></code> function.
Only used if <code>.approch_mgd</code> is one of &quot;<em>CI_para</em>&quot; or &quot;<em>CI_overlap</em>&quot;. Ignored otherwise.
Defaults to &quot;<em>CI_percentile</em>&quot;.</p>
</td></tr>
<tr><td><code id="testMGD_+3A_.type_vcv">.type_vcv</code></td>
<td>
<p>Character string. Which model-implied correlation
matrix should be calculated?
One of &quot;<em>indicator</em>&quot; or &quot;<em>construct</em>&quot;. Defaults to &quot;<em>indicator</em>&quot;.</p>
</td></tr>
<tr><td><code id="testMGD_+3A_.verbose">.verbose</code></td>
<td>
<p>Logical. Should information (e.g., progress bar) be printed
to the console? Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs various tests proposed in the context of multigroup analysis.
</p>
<p>The following tests are implemented:
</p>

<dl>
<dt><code>.approach_mgd = "Klesel"</code>: Approach suggested by Klesel et al. (2019)</dt><dd>
<p>The model-implied variance-covariance matrix (either indicator
(<code>.type_vcv = "indicator"</code>) or construct (<code>.type_vcv = "construct"</code>))
is compared across groups. If the model-implied indicator or construct correlation
matrix based on a saturated structural model should be compared, set <code>.saturated = TRUE</code>.
To measure the distance between the model-implied variance-covariance matrices,
the geodesic distance (dG) and the squared Euclidean distance (dL) are used.
If more than two groups are compared, the average distance over all groups
is used.</p>
</dd>
<dt><code>.approach_mgd = "Sarstedt"</code>: Approach suggested by Sarstedt et al. (2011)</dt><dd>
<p>Groups are compared in terms of parameter differences across groups.
Sarstedt et al. (2011) tests if parameter k is equal
across all groups. If several parameters are tested simultaneously
it is recommended to adjust the significance  level or the p-values (in <span class="pkg">cSEM</span> correction is
done by p-value). By default
no multiple testing correction is done, however, several common
adjustments are available via <code>.approach_p_adjust</code>. See
<code><a href="stats.html#topic+p.adjust">stats::p.adjust()</a></code> for details. Note: the
test has some severe shortcomings. Use with caution.</p>
</dd>
<dt><code>.approach_mgd = "Chin"</code>: Approach suggested by Chin and Dibbern (2010)</dt><dd>
<p>Groups are compared in terms of parameter differences across groups.
Chin and Dibbern (2010) tests if parameter k is equal
between two groups. If more than two groups are tested for equality, parameter
k is compared between all pairs of groups. In this case, it is recommended
to adjust the significance  level or the p-values (in <span class="pkg">cSEM</span> correction is
done by p-value) since this is essentially a multiple testing setup.
If several parameters are tested simultaneously, correction is by group
and number of parameters. By default
no multiple testing correction is done, however, several common
adjustments are available via <code>.approach_p_adjust</code>. See
<code><a href="stats.html#topic+p.adjust">stats::p.adjust()</a></code> for details.</p>
</dd>
<dt><code>.approach_mgd = "Keil"</code>: Approach suggested by Keil et al. (2000)</dt><dd>
<p>Groups are compared in terms of parameter differences across groups.
Keil et al. (2000) tests if parameter k is equal
between two groups. It is assumed, that the standard errors of the coefficients are
equal across groups. The calculation of the standard error of the parameter
difference is adjusted as proposed by Henseler et al. (2009).
If more than two groups are tested for equality, parameter k is compared
between all pairs of groups. In this case, it is recommended
to adjust the significance  level or the p-values (in <span class="pkg">cSEM</span> correction is
done by p-value) since this is essentially a multiple testing setup.
If several parameters are tested simultaneously, correction
is by group and number of parameters. By default
no multiple testing correction is done, however, several common
adjustments are available via <code>.approach_p_adjust</code>. See
<code><a href="stats.html#topic+p.adjust">stats::p.adjust()</a></code> for details.</p>
</dd>
<dt><code>.approach_mgd = "Nitzl"</code>: Approach suggested by Nitzl (2010)</dt><dd>
<p>Groups are compared in terms of parameter differences across groups.
Similarly to Keil et al. (2000), a single parameter k is tested
for equality between two groups. In contrast to Keil et al. (2000),
it is assumed, that the standard errors of the coefficients are
unequal across groups (Sarstedt et al. 2011).
If more than two groups are tested for equality, parameter k is compared
between all pairs of groups. In this case, it is recommended
to adjust the significance  level or the p-values (in <span class="pkg">cSEM</span> correction is
done by p-value) since this is essentially a multiple testing setup.
If several parameters are tested simultaneously, correction
is by group and number of parameters. By default
no multiple testing correction is done, however, several common
adjustments are available via <code>.approach_p_adjust</code>. See
<code><a href="stats.html#topic+p.adjust">stats::p.adjust()</a></code> for details.</p>
</dd>
<dt><code>.approach_mgd = "Henseler"</code>: Approach suggested by Henseler (2007)</dt><dd>
<p>Groups are compared in terms of parameter differences across groups.
In doing so, the bootstrap estimates of one parameter are compared across groups.
In the literature, this approach is also known as PLS-MGA.
Originally, this test was proposed as an one-sided test.
In this function we perform a left-sided and a right-sided test
to investigate whether a parameter differs across two groups. In doing so, the significance
level is divided by 2 and compared to p-value of the left and right-sided test.
Moreover, <code>.approach_p_adjust</code> is ignored and no overall decision
is returned.
For a more detailed description, see also Henseler et al. (2009).</p>
</dd>
<dt><code>.approach_mgd = "CI_param"</code>: Approach mentioned in Sarstedt et al. (2011)</dt><dd>
<p>This approach is based on the confidence intervals constructed around the
parameter estimates of the two groups. If the parameter of one group falls within
the confidence interval of the other group and/or vice versa, it can be concluded
that there is no group difference.
Since it is based on the confidence intervals <code>.approach_p_adjust</code> is ignored.</p>
</dd>
<dt><code>.approach_mgd = "CI_overlap"</code>: Approach mentioned in Sarstedt et al. (2011)</dt><dd>
<p>This approach is based on the confidence intervals (CIs) constructed around the
parameter estimates of the two groups. If the two CIs overlap, it can be concluded
that there is no group difference.
Since it is based on the confidence intervals <code>.approach_p_adjust</code> is ignored.</p>
</dd>
</dl>

<p>Use <code>.approach_mgd</code> to choose the approach. By default all approaches are computed
(<code>.approach_mgd = "all"</code>).
</p>
<p>For convenience, two types of output are available. See the &quot;Value&quot; section below.
</p>
<p>By default, approaches based on parameter differences across groups compare
all parameters (<code>.parameters_to_compare = NULL</code>). To compare only
a subset of parameters provide the parameters in <a href="lavaan.html#topic+model.syntax">lavaan model syntax</a>  just like
the model to estimate. Take the simple model:
</p>
<pre>
model_to_estimate &lt;- "
Structural model
eta2 ~ eta1
eta3 ~ eta1 + eta2

# Each concept os measured by 3 indicators, i.e., modeled as latent variable
eta1 =~ y11 + y12 + y13
eta2 =~ y21 + y22 + y23
eta3 =~ y31 + y32 + y33
"
</pre>
<p>If only the path from eta1 to eta3 and the loadings of eta1 are to be compared
across groups, write:
</p>
<pre>
to_compare &lt;- "
Structural parameters to compare
eta3 ~ eta1

# Loadings to compare
eta1 =~ y11 + y12 + y13
"
</pre>
<p>Note that the &quot;model&quot; provided to <code>.parameters_to_compare</code>
does not need to be an estimable model!
</p>
<p>Note also that compared to all other functions in <span class="pkg">cSEM</span> using the argument,
<code>.handle_inadmissibles</code> defaults to <code>"replace"</code> to accommodate the Sarstedt et al. (2011) approach.
</p>
<p>Argument <code>.R_permuation</code> is ignored for the <code>"Nitzl"</code> and the <code>"Keil"</code> approach.
<code>.R_bootstrap</code> is ignored if  <code>.object</code> already contains resamples,
i.e. has class <code>cSEMResults_resampled</code> and if only the <code>"Klesel"</code> or the <code>"Chin"</code>
approach are used.
</p>
<p>The argument <code>.saturated</code> is used by <code>"Klesel"</code> only. If <code>.saturated = TRUE</code>
the original structural model is ignored and replaced by a saturated model,
i.e. a model in which all constructs are allowed to correlate freely.
This is useful to test differences in the measurement models between groups
in isolation.
</p>


<h3>Value</h3>

<p>If <code>.output_type = "complete"</code> a list of class <code>cSEMTestMGD</code>. Technically, <code>cSEMTestMGD</code> is a
named list containing the following list elements:
</p>

<dl>
<dt><code style="white-space: pre;">&#8288;$Information&#8288;</code></dt><dd><p>Additional information.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$Klesel&#8288;</code></dt><dd><p>A list with elements, <code>Test_statistic</code>, <code>P_value</code>, and <code>Decision</code></p>
</dd>
<dt><code style="white-space: pre;">&#8288;$Chin&#8288;</code></dt><dd><p>A list with elements, <code>Test_statistic</code>, <code>P_value</code>, <code>Decision</code>, and <code>Decision_overall</code></p>
</dd>
<dt><code style="white-space: pre;">&#8288;$Sarstedt&#8288;</code></dt><dd><p>A list with elements, <code>Test_statistic</code>, <code>P_value</code>, <code>Decision</code>, and <code>Decision_overall</code></p>
</dd>
<dt><code style="white-space: pre;">&#8288;$Keil&#8288;</code></dt><dd><p>A list with elements, <code>Test_statistic</code>, <code>P_value</code>, <code>Decision</code>, and <code>Decision_overall</code></p>
</dd>
<dt><code style="white-space: pre;">&#8288;$Nitzl&#8288;</code></dt><dd><p>A list with elements, <code>Test_statistic</code>, <code>P_value</code>, <code>Decision</code>, and <code>Decision_overall</code></p>
</dd>
<dt><code style="white-space: pre;">&#8288;$Henseler&#8288;</code></dt><dd><p>A list with elements, <code>Test_statistic</code>, <code>P_value</code>, <code>Decision</code>, and <code>Decision_overall</code></p>
</dd>
<dt><code style="white-space: pre;">&#8288;$CI_para&#8288;</code></dt><dd><p>A list with elements,  <code>Decision</code>, and <code>Decision_overall</code></p>
</dd>
<dt><code style="white-space: pre;">&#8288;$CI_overlap&#8288;</code></dt><dd><p>A list with elements,  <code>Decision</code>, and <code>Decision_overall</code></p>
</dd>
</dl>

<p>If <code>.output_type = "structured"</code> a tibble (data frame) with the following columns
is returned.
</p>

<dl>
<dt><code>Test</code></dt><dd><p>The name of the test.</p>
</dd>
<dt><code>Comparision</code></dt><dd><p>The parameter that was compared across groups. If &quot;overall&quot;
the overall fit of the model was compared.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;alpha%&#8288;</code></dt><dd><p>The test decision for a given &quot;alpha&quot; level. If <code>TRUE</code> the null
hypotheses was rejected; if FALSE it was not rejected.</p>
</dd>
<dt><code>p-value_correction</code></dt><dd><p>The p-value correction.</p>
</dd>
<dt><code>CI_type</code></dt><dd><p>Only for the &quot;CI_para&quot; and the &quot;CI_overlap&quot; test. Which confidence interval was used.</p>
</dd>
<dt><code>Distance_metric</code></dt><dd><p>Only for Test = &quot;Klesel&quot;. Which distance metric was used.</p>
</dd>
</dl>



<h3>References</h3>

<p>Chin WW, Dibbern J (2010).
&ldquo;An Introduction to a Permutation Based Procedure for Multi-Group PLS Analysis: Results of Tests of Differences on Simulated Data and a Cross Cultural Analysis of the Sourcing of Information System Services Between Germany and the USA.&rdquo;
In <em>Handbook of Partial Least Squares</em>, 171&ndash;193.
Springer Berlin Heidelberg.
<a href="https://doi.org/10.1007/978-3-540-32827-8_8">doi:10.1007/978-3-540-32827-8_8</a>.<br /><br /> Henseler J (2007).
&ldquo;A new and simple approach to multi-group analysis in partial least squares path modeling.&rdquo;
In Martens H, Næ s T (eds.), <em>Proceedings of PLS'07 - The 5th International Symposium on PLS and Related Methods</em>, 104&ndash;107.
PLS, Norway: Matforsk, As.<br /><br /> Henseler J, Ringle CM, Sinkovics RR (2009).
&ldquo;The use of partial least squares path modeling in international marketing.&rdquo;
<em>Advances in International Marketing</em>, <b>20</b>, 277&ndash;320.
<a href="https://doi.org/10.1108/S1474-7979%282009%290000020014">doi:10.1108/S1474-7979(2009)0000020014</a>.<br /><br /> Keil M, Tan BC, Wei K, Saarinen T, Tuunainen V, Wassenaar A (2000).
&ldquo;A cross-cultural study on escalation of commitment behavior in software projects.&rdquo;
<em>MIS Quarterly</em>, <b>24</b>(2), 299&ndash;325.<br /><br /> Klesel M, Schuberth F, Henseler J, Niehaves B (2019).
&ldquo;A Test for Multigroup Comparison Using Partial Least Squares Path Modeling.&rdquo;
<em>Internet Research</em>, <b>29</b>(3), 464&ndash;477.
<a href="https://doi.org/10.1108/intr-11-2017-0418">doi:10.1108/intr-11-2017-0418</a>.<br /><br /> Nitzl C (2010).
&ldquo;Eine anwenderorientierte Einfuehrung in die Partial Least Square (PLS)-Methode.&rdquo;
In <em>Arbeitspapier</em>,  number 21.
Universitaet Hamburg, Institut fuer Industrielles Management, Hamburg.<br /><br /> Sarstedt M, Henseler J, Ringle CM (2011).
&ldquo;Multigroup Analysis in Partial Least Squares (PLS) Path Modeling: Alternative Methods and Empirical Results.&rdquo;
In <em>Advances in International Marketing</em>, 195&ndash;218.
Emerald Group Publishing Limited.
<a href="https://doi.org/10.1108/s1474-7979%282011%290000022012">doi:10.1108/s1474-7979(2011)0000022012</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+csem">csem()</a></code>, <a href="#topic+cSEMResults">cSEMResults</a>, <code><a href="#topic+testMICOM">testMICOM()</a></code>, <code><a href="#topic+testOMF">testOMF()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# ===========================================================================
# Basic usage
# ===========================================================================
model &lt;- "
# Structural model
QUAL ~ EXPE
EXPE ~ IMAG
SAT  ~ IMAG + EXPE + QUAL + VAL
LOY  ~ IMAG + SAT
VAL  ~ EXPE + QUAL

# Measurement model

EXPE &lt;~ expe1 + expe2 + expe3 + expe4 + expe5
IMAG &lt;~ imag1 + imag2 + imag3 + imag4 + imag5
LOY  =~ loy1  + loy2  + loy3  + loy4
QUAL =~ qual1 + qual2 + qual3 + qual4 + qual5
SAT  &lt;~ sat1  + sat2  + sat3  + sat4
VAL  &lt;~ val1  + val2  + val3  + val4
"

## Create list of virtually identical data sets
dat &lt;- list(satisfaction[-3,], satisfaction[-5, ], satisfaction[-10, ])
out &lt;- csem(dat, model, .resample_method = "bootstrap", .R = 40) 

## Test 
testMGD(out, .R_permutation = 40,.verbose = FALSE)

# Notes: 
#  1. .R_permutation (and .R in the call to csem) is small to make examples run quicker; 
#     should be higher in real applications.
#  2. Test will not reject their respective H0s since the groups are virtually
#     identical.
#  3. Only exception is the approach suggested by Sarstedt et al. (2011), a
#     sign that the test is unreliable.
#  4. As opposed to other functions involving the argument, 
#     '.handle_inadmissibles' the default is "replace" as this is
#     required by Sarstedt et al. (2011)'s approach.

# ===========================================================================
# Extended usage
# ===========================================================================
### Test only a subset ------------------------------------------------------
# By default all parameters are compared. Select a subset by providing a 
# model in lavaan model syntax:

to_compare &lt;- "
# Path coefficients
QUAL ~ EXPE

# Loadings
EXPE &lt;~ expe1 + expe2 + expe3 + expe4 + expe5
"

## Test 
testMGD(out, .parameters_to_compare = to_compare, .R_permutation = 20, 
        .R_bootstrap = 20, .verbose = FALSE)

### Different p_adjustments --------------------------------------------------
# To adjust p-values to accommodate multiple testing use .approach_p_adjust. 
# The number of tests to use for adjusting depends on the approach chosen. For
# the Chin approach for example it is the number of parameters to test times the
# number of possible group comparisons. To compare the results for different
# adjustments, a vector of p-adjustments may be chosen.

## Test 
testMGD(out, .parameters_to_compare = to_compare, 
        .approach_p_adjust = c("none", "bonferroni"),
        .R_permutation = 20, .R_bootstrap = 20, .verbose = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='testMICOM'>Test measurement invariance of composites</h2><span id='topic+testMICOM'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testMICOM(
 .object               = NULL,
 .approach_p_adjust    = "none",
 .handle_inadmissibles = c("drop", "ignore", "replace"), 
 .R                    = 499,
 .seed                 = NULL,
 .verbose              = TRUE
 )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testMICOM_+3A_.object">.object</code></td>
<td>
<p>An R object of class <a href="#topic+cSEMResults">cSEMResults</a> resulting from a call to <code><a href="#topic+csem">csem()</a></code>.</p>
</td></tr>
<tr><td><code id="testMICOM_+3A_.approach_p_adjust">.approach_p_adjust</code></td>
<td>
<p>Character string or a vector of character strings.
Approach used to adjust the p-value for multiple testing.
See the <code>methods</code> argument of <code><a href="stats.html#topic+p.adjust">stats::p.adjust()</a></code> for a list of choices and
their description. Defaults to &quot;<em>none</em>&quot;.</p>
</td></tr>
<tr><td><code id="testMICOM_+3A_.handle_inadmissibles">.handle_inadmissibles</code></td>
<td>
<p>Character string. How should inadmissible results
be treated? One of &quot;<em>drop</em>&quot;, &quot;<em>ignore</em>&quot;, or &quot;<em>replace</em>&quot;. If &quot;<em>drop</em>&quot;, all
replications/resamples yielding an inadmissible result will be dropped
(i.e. the number of results returned will potentially be less than <code>.R</code>).
For &quot;<em>ignore</em>&quot; all results are returned even if all or some of the replications
yielded inadmissible results (i.e. number of results returned is equal to <code>.R</code>).
For &quot;<em>replace</em>&quot; resampling continues until there are exactly <code>.R</code> admissible solutions.
Depending on the frequency of inadmissible solutions this may significantly increase
computing time. Defaults to &quot;<em>drop</em>&quot;.</p>
</td></tr>
<tr><td><code id="testMICOM_+3A_.r">.R</code></td>
<td>
<p>Integer. The number of bootstrap replications. Defaults to <code>499</code>.</p>
</td></tr>
<tr><td><code id="testMICOM_+3A_.seed">.seed</code></td>
<td>
<p>Integer or <code>NULL</code>. The random seed to use. Defaults to <code>NULL</code> in which
case an arbitrary seed is chosen. Note that the scope of the seed is limited
to the body of the function it is used in. Hence, the global seed will
not be altered!</p>
</td></tr>
<tr><td><code id="testMICOM_+3A_.verbose">.verbose</code></td>
<td>
<p>Logical. Should information (e.g., progress bar) be printed
to the console? Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions performs the permutation-based test for measurement invariance
of composites across groups proposed by Henseler et al. (2016).
According to the authors assessing measurement invariance in composite
models can be assessed by a three-step procedure. The first two steps
involve an assessment of configural and compositional invariance.
The third steps involves mean and variance comparisons across groups.
Assessment of configural invariance is qualitative in nature and hence
not assessed by the <code><a href="#topic+testMICOM">testMICOM()</a></code> function.
</p>
<p>As <code><a href="#topic+testMICOM">testMICOM()</a></code> requires at least two groups, <code>.object</code> must be of
class <code>cSEMResults_multi</code>. As of version 0.2.0 of the package, <code><a href="#topic+testMICOM">testMICOM()</a></code>
does not support models containing second-order constructs.
</p>
<p>It is possible to compare more than two groups, however, multiple-testing
issues arise in this case. To adjust p-values in this case several p-value
adjustments are available via the <code>approach_p_adjust</code> argument.
</p>
<p>The remaining arguments set the number of permutation runs to conduct
(<code>.R</code>), the random number seed (<code>.seed</code>),
instructions how inadmissible results are to be handled (<code>handle_inadmissibles</code>),
and whether the function should be verbose in a sense that progress is printed
to the console.
</p>
<p>The number of permutation runs defaults to <code>args_default()$.R</code> for
performance reasons. According to Henseler et al. (2016)
the number of permutations should be at least 5000 for assessment to be
sufficiently reliable.
</p>


<h3>Value</h3>

<p>A named list of class <code>cSEMTestMICOM</code> containing the following list element:
</p>

<dl>
<dt><code style="white-space: pre;">&#8288;$Step2&#8288;</code></dt><dd><p>A list containing the results of the test for compositional invariance (Step 2).</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$Step3&#8288;</code></dt><dd><p>A list containing the results of the test for mean and variance equality (Step 3).</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$Information&#8288;</code></dt><dd><p>A list of additional information on the test.</p>
</dd>
</dl>



<h3>References</h3>

<p>Henseler J, Ringle CM, Sarstedt M (2016).
&ldquo;Testing Measurement Invariance of Composites Using Partial Least Squares.&rdquo;
<em>International Marketing Review</em>, <b>33</b>(3), 405&ndash;431.
<a href="https://doi.org/10.1108/imr-09-2014-0304">doi:10.1108/imr-09-2014-0304</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+csem">csem()</a></code>, <a href="#topic+cSEMResults">cSEMResults</a>, <code><a href="#topic+testOMF">testOMF()</a></code>, <code><a href="#topic+testMGD">testMGD()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# NOTE: to run the example. Download and load the newst version of cSEM.DGP
# from GitHub using devtools::install_github("M-E-Rademaker/cSEM.DGP").

# Create two data generating processes (DGPs) that only differ in how the composite
# X is build. Hence, the two groups are not compositionally invariant.
dgp1 &lt;- "
# Structural model
Y ~ 0.6*X

# Measurement model
Y =~ 1*y1
X &lt;~ 0.4*x1 + 0.8*x2

x1 ~~ 0.3125*x2
"

dgp2 &lt;- "
# Structural model
Y ~ 0.6*X

# Measurement model
Y =~ 1*y1
X &lt;~ 0.8*x1 + 0.4*x2

x1 ~~ 0.3125*x2
"

g1 &lt;- generateData(dgp1, .N = 399, .empirical = TRUE) # requires cSEM.DGP 
g2 &lt;- generateData(dgp2, .N = 200, .empirical = TRUE) # requires cSEM.DGP

# Model is the same for both DGPs
model &lt;- "
# Structural model
Y ~ X

# Measurement model
Y =~ y1
X &lt;~ x1 + x2
"

# Estimate
csem_results &lt;- csem(.data = list("group1" = g1, "group2" = g2), model)

# Test
testMICOM(csem_results, .R = 50, .alpha = c(0.01, 0.05), .seed = 1987)

## End(Not run)
</code></pre>

<hr>
<h2 id='testOMF'>Test for overall model fit</h2><span id='topic+testOMF'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#maturing"><img src="../help/figures/lifecycle-maturing.svg" alt='[Maturing]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testOMF(
 .object                = NULL, 
 .alpha                 = 0.05,
 .fit_measures          = FALSE,
 .handle_inadmissibles  = c("drop", "ignore", "replace"), 
 .R                     = 499, 
 .saturated             = FALSE,
 .seed                  = NULL,
 ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testOMF_+3A_.object">.object</code></td>
<td>
<p>An R object of class <a href="#topic+cSEMResults">cSEMResults</a> resulting from a call to <code><a href="#topic+csem">csem()</a></code>.</p>
</td></tr>
<tr><td><code id="testOMF_+3A_.alpha">.alpha</code></td>
<td>
<p>An integer or a numeric vector of significance levels.
Defaults to <code>0.05</code>.</p>
</td></tr>
<tr><td><code id="testOMF_+3A_.fit_measures">.fit_measures</code></td>
<td>
<p>Logical. (EXPERIMENTAL) Should additional fit measures
be included? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="testOMF_+3A_.handle_inadmissibles">.handle_inadmissibles</code></td>
<td>
<p>Character string. How should inadmissible results
be treated? One of &quot;<em>drop</em>&quot;, &quot;<em>ignore</em>&quot;, or &quot;<em>replace</em>&quot;. If &quot;<em>drop</em>&quot;, all
replications/resamples yielding an inadmissible result will be dropped
(i.e. the number of results returned will potentially be less than <code>.R</code>).
For &quot;<em>ignore</em>&quot; all results are returned even if all or some of the replications
yielded inadmissible results (i.e. number of results returned is equal to <code>.R</code>).
For &quot;<em>replace</em>&quot; resampling continues until there are exactly <code>.R</code> admissible solutions.
Depending on the frequency of inadmissible solutions this may significantly increase
computing time. Defaults to &quot;<em>drop</em>&quot;.</p>
</td></tr>
<tr><td><code id="testOMF_+3A_.r">.R</code></td>
<td>
<p>Integer. The number of bootstrap replications. Defaults to <code>499</code>.</p>
</td></tr>
<tr><td><code id="testOMF_+3A_.saturated">.saturated</code></td>
<td>
<p>Logical. Should a saturated structural model be used?
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="testOMF_+3A_.seed">.seed</code></td>
<td>
<p>Integer or <code>NULL</code>. The random seed to use. Defaults to <code>NULL</code> in which
case an arbitrary seed is chosen. Note that the scope of the seed is limited
to the body of the function it is used in. Hence, the global seed will
not be altered!</p>
</td></tr>
<tr><td><code id="testOMF_+3A_...">...</code></td>
<td>
<p>Can be used to determine the fitting function used in the calculateGFI function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Bootstrap-based test for overall model fit originally proposed by Beran and Srivastava (1985).
See also Dijkstra and Henseler (2015) who first suggested the test in
the context of PLS-PM.
</p>
<p>By default, <code>testOMF()</code> tests the null hypothesis that the population indicator
correlation matrix equals the population model-implied indicator correlation matrix.
Several discrepancy measures may be used. By default, <code>testOMF()</code> uses four distance
measures to assess the distance between the sample indicator correlation matrix
and the estimated model-implied indicator correlation matrix, namely the geodesic distance,
the squared Euclidean distance, the standardized root mean square residual (SRMR),
and the distance based on the maximum likelihood fit function.
The reference distribution for each test statistic is obtained by
the bootstrap as proposed by Beran and Srivastava (1985).
</p>
<p>It is possible to perform the bootstrap-based test using fit measures such
as the CFI, RMSEA or the GFI if <code>.fit_measures = TRUE</code>. This is experimental.
To the best of our knowledge the applicability and usefulness of the fit
measures for model fit assessment have not been formally (statistically)
assessed yet. Theoretically, the logic of the test applies to these fit indices as well.
Hence, their applicability is theoretically justified.
Only use if you know what you are doing.
</p>
<p>If <code>.saturated = TRUE</code> the original structural model is ignored and replaced by
a saturated model, i.e., a model in which all constructs are allowed to correlate freely.
This is useful to test misspecification of the measurement model in isolation.
</p>


<h3>Value</h3>

<p>A list of class <code>cSEMTestOMF</code> containing the following list elements:
</p>

<dl>
<dt><code style="white-space: pre;">&#8288;$Test_statistic&#8288;</code></dt><dd><p>The value of the test statistics.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$Critical_value&#8288;</code></dt><dd><p>The corresponding  critical values obtained by the bootstrap.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$Decision&#8288;</code></dt><dd><p>The test decision. One of: <code>FALSE</code> (<strong>Reject</strong>) or <code>TRUE</code> (<strong>Do not reject</strong>).</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$Information&#8288;</code></dt><dd><p>The <code>.R</code> bootstrap values; The number of admissible results;
The seed used and the number of total runs.</p>
</dd>
</dl>



<h3>References</h3>

<p>Beran R, Srivastava MS (1985).
&ldquo;Bootstrap Tests and Confidence Regions for Functions of a Covariance Matrix.&rdquo;
<em>The Annals of Statistics</em>, <b>13</b>(1), 95&ndash;115.
<a href="https://doi.org/10.1214/aos/1176346579">doi:10.1214/aos/1176346579</a>.<br /><br /> Dijkstra TK, Henseler J (2015).
&ldquo;Consistent and Asymptotically Normal PLS Estimators for Linear Structural Equations.&rdquo;
<em>Computational Statistics &amp; Data Analysis</em>, <b>81</b>, 10&ndash;23.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+csem">csem()</a></code>, <code><a href="#topic+calculateSRMR">calculateSRMR()</a></code>, <code><a href="#topic+calculateDG">calculateDG()</a></code>, <code><a href="#topic+calculateDL">calculateDL()</a></code>, <a href="#topic+cSEMResults">cSEMResults</a>,
<code><a href="#topic+testMICOM">testMICOM()</a></code>, <code><a href="#topic+testMGD">testMGD()</a></code>, <code><a href="#topic+exportToExcel">exportToExcel()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># ===========================================================================
# Basic usage
# ===========================================================================
model &lt;- "
# Structural model
eta2 ~ eta1
eta3 ~ eta1 + eta2

# (Reflective) measurement model
eta1 =~ y11 + y12 + y13
eta2 =~ y21 + y22 + y23
eta3 =~ y31 + y32 + y33
"

## Estimate
out &lt;- csem(threecommonfactors, model, .approach_weights = "PLS-PM")

## Test
testOMF(out, .R = 50, .seed = 320)

</code></pre>

<hr>
<h2 id='threecommonfactors'>Data: threecommonfactors</h2><span id='topic+threecommonfactors'></span>

<h3>Description</h3>

<p>A dataset containing 500 standardized observations on 9 indicator generated from a
population model with three concepts modeled as common factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>threecommonfactors
</code></pre>


<h3>Format</h3>

<p>A matrix with 500 rows and 9 variables:
</p>

<dl>
<dt>y11-y13</dt><dd><p>Indicators attached to the first common factor (<code>eta1</code>).
Population loadings are: 0.7; 0.7; 0.7</p>
</dd>
<dt>y21-y23</dt><dd><p>Indicators attached to the second common factor (<code>eta2</code>).
Population loadings are: 0.5; 0.7; 0.8</p>
</dd>
<dt>y31-y33</dt><dd><p>Indicators attached to the third common factor (<code>eta3</code>).
Population loadings are: 0.8; 0.75; 0.7</p>
</dd>
</dl>

<p>The model is:
</p>
<p style="text-align: center;"><code class="reqn">`eta2` = gamma1 * `eta1` + zeta1</code>
</p>

<p style="text-align: center;"><code class="reqn">`eta3` = gamma2 * `eta1` + beta * `eta2` + zeta2</code>
</p>

<p>with population values <code>gamma1</code> = 0.6, <code>gamma2</code> = 0.4 and <code>beta</code> = 0.35.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#============================================================================
# Correct model (the model used to generate the data)
#============================================================================
model_correct &lt;- "
# Structural model
eta2 ~ eta1
eta3 ~ eta1 + eta2

# Measurement model
eta1 =~ y11 + y12 + y13
eta2 =~ y21 + y22 + y23
eta3 =~ y31 + y32 + y33 
"

a &lt;- csem(threecommonfactors, model_correct)

## The overall model fit is evidently almost perfect:
testOMF(a, .R = 30) # .R = 30 to speed up the example
</code></pre>

<hr>
<h2 id='verify'>Verify admissibility</h2><span id='topic+verify'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>verify(.object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="verify_+3A_.object">.object</code></td>
<td>
<p>An R object of class <a href="#topic+cSEMResults">cSEMResults</a> resulting from a call to <code><a href="#topic+csem">csem()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Verify admissibility of the results obtained using <code><a href="#topic+csem">csem()</a></code>.
</p>
<p>Results exhibiting one of the following defects are deemed inadmissible:
non-convergence of the algorithm used to obtain weights, loadings and/or
(congeneric) reliabilities larger than 1, a construct variance-covariance (VCV) and/or
model-implied VCV matrix that is not positive semi-definite.
</p>
<p>If <code>.object</code> is of class <code>cSEMResults_2ndorder</code> (i.e., estimates are
based on a model containing second-order constructs) both the first and the second stage are checked separately.
</p>
<p>Currently, a model-implied indicator VCV matrix for nonlinear model is not
available. <code>verify()</code> therefore skips the check for positive definiteness of the
model-implied indicator VCV matrix for nonlinear models and returns &quot;ok&quot;.
</p>


<h3>Value</h3>

<p>A logical vector indicating which (if any) problem occurred.
A <code>FALSE</code> indicates that the specific problem did not occurred. For models containing second-order
constructs estimated by the two/three-stage approach, a list of two such vectors
(one for the first and one for the second stage) is returned. Status codes are:
</p>

<ul>
<li><p> 1: The algorithm has converged.
</p>
</li>
<li><p> 2: All absolute standardized loading estimates are smaller than or equal to 1.
A violation implies either a negative variance of the measurement error or
a correlation larger than 1.
</p>
</li>
<li><p> 3: The construct VCV is positive semi-definite.
</p>
</li>
<li><p> 4: All reliability estimates are smaller than or equal to 1.
</p>
</li>
<li><p> 5: The model-implied indicator VCV is positive semi-definite.
This is only checked for linear models (including models containing
second-order constructs).
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+csem">csem()</a></code>, <code><a href="#topic+summarize">summarize()</a></code>, <a href="#topic+cSEMResults">cSEMResults</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Without higher order constructs --------------------------------------------
model &lt;- "
# Structural model
eta2 ~ eta1
eta3 ~ eta1 + eta2

# (Reflective) measurement model
eta1 =~ y11 + y12 + y13
eta2 =~ y21 + y22 + y23
eta3 =~ y31 + y32 + y33
"
  
# Estimate
out &lt;- csem(threecommonfactors, model)
  
# Check admissibility
verify(out) # ok!

## Examine the structure of a cSEMVerify object
str(verify(out))

### With higher order constructs -----------------------------------------------
# If the model containes higher order constructs both the first and the second-
# stage estimates estimates are checked for admissibility

## Not run: 
require(cSEM.DGP) # download from https://m-e-rademaker.github.io/cSEM.DGP/
  
# Create DGP with 2nd order construct. Loading for indicator y51 is set to 1.1
# to produce a failing first stage model
  
dgp_2ndorder &lt;- "
## Path model / Regressions
eta2 ~ 0.5*eta1
eta3 ~ 0.35*eta1 + 0.4*eta2

## Composite model
eta1 =~ 0.8*y41 + 0.6*y42 + 0.6*y43
eta2 =~ 1.1*y51 + 0.7*y52 + 0.7*y53
c1   =~ 0.8*y11 + 0.4*y12
c2   =~ 0.5*y21 + 0.3*y22

## Higher order composite
eta3 =~ 0.4*c1 + 0.4*c2
"
  
dat &lt;- generateData(dgp_2ndorder) # requires the cSEM.DGP package
out &lt;- csem(dat, .model = dgp_2ndorder)

verify(out) # not ok

## End(Not run)
</code></pre>

<hr>
<h2 id='Yooetal2000'>Data: Yooetal2000</h2><span id='topic+Yooetal2000'></span>

<h3>Description</h3>

<p>A data frame containing 34 variables with 569 observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Yooetal2000
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 569 rows and 34 columns.
</p>


<h3>Details</h3>

<p>The data is simulated and has the identical correlation matrix as the data
that was analysed by Yoo et al. (2000)
to examine how five elements of the marketing mix, namely price, store
image, distribution intensity, advertising spending, and price deals, are
related to the so-called dimensions of brand equity, i.e., perceived brand
quality, brand loyalty, and brand awareness/associations. It is also used in
Henseler (2017) and Henseler (2021)
for demonstration purposes, see the corresponding tutorial.
</p>


<h3>Source</h3>

<p>Simulated data with the same correlation matrix as the data studied
by Yoo et al. (2000).
</p>


<h3>References</h3>

<p>Henseler J (2017).
&ldquo;Bridging Design and Behavioral Research With Variance-Based Structural Equation Modeling.&rdquo;
<em>Journal of Advertising</em>, <b>46</b>(1), 178&ndash;192.
<a href="https://doi.org/10.1080/00913367.2017.1281780">doi:10.1080/00913367.2017.1281780</a>.<br /><br /> Henseler J (2021).
<em>Composite-Based Structural Equation Modeling: Analyzing Latent and Emergent Variables</em>.
Guilford Press, New York.<br /><br /> Yoo B, Donthu N, Lee S (2000).
&ldquo;An Examination of Selected Marketing Mix Elements and Brand Equity.&rdquo;
<em>Journal of the Academy of Marketing Science</em>, <b>28</b>(2), 195&ndash;211.
<a href="https://doi.org/10.1177/0092070300282002">doi:10.1177/0092070300282002</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#============================================================================
# Example is taken from Henseler (2021)
#============================================================================
model_HOC="
# Measurement models FOC
PR =~ PR1 + PR2 + PR3
IM =~ IM1 + IM2 + IM3
DI =~ DI1 + DI2 + DI3
AD =~ AD1 + AD2 + AD3
DL =~ DL1 + DL2 + DL3
AA =~ AA1 + AA2 + AA3 + AA4 + AA5 + AA6
LO =~ LO1 + LO3
QL =~ QL1 + QL2 + QL3 + QL4 + QL5 + QL6

# Composite model for SOC
BR &lt;~ QL + LO + AA

# Structural model
BR~ PR + IM + DI + AD + DL 
"

out &lt;- csem(.data = Yooetal2000, .model = model_HOC,
            .PLS_weight_scheme_inner = 'factorial',
            .tolerance = 1e-06)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
