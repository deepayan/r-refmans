<!DOCTYPE html><html><head><title>Help for package ModelMap</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ModelMap}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#build.rastLUT'><p>Build a raster Look-UP-Table for training dataset</p></a></li>
<li><a href='#col2trans'><p>colors to transparent colors</p></a></li>
<li><a href='#get.test'><p>Randomly Divide Data into Training and Test Sets</p></a></li>
<li><a href='#model.build'><p> Model Building</p></a></li>
<li><a href='#model.diagnostics'><p> Model Predictions and Diagnostics</p></a></li>
<li><a href='#model.explore'>
<p>Exploratory data analysis</p></a></li>
<li><a href='#model.importance.plot'><p>Compares the variable importance of two models with a back to back barchart.</p></a></li>
<li><a href='#model.interaction.plot'>
<p>plot of two-way model interactions</p></a></li>
<li><a href='#model.mapmake'><p> Map Making</p></a></li>
<li><a href='#ModelMap-internal'><p> Internal ModelMap Functions</p></a></li>
<li><a href='#ModelMap-package'>
<p>Modeling and Map Production using Random Forest and Related Stochastic Models</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Modeling and Map Production using Random Forest and Related
Stochastic Models</td>
</tr>
<tr>
<td>Version:</td>
<td>3.4.0.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-04-04</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.13.0), randomForest, raster</td>
</tr>
<tr>
<td>Suggests:</td>
<td>party, quantregForest</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics,grDevices,stats,utils,mgcv,corrplot,fields,HandTill2001,PresenceAbsence</td>
</tr>
<tr>
<td>Author:</td>
<td>Elizabeth Freeman, Tracey Frescino</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Elizabeth Freeman &lt;elizabeth.a.freeman@usda.gov&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Creates sophisticated models of training data and validates the models with an independent test set, cross validation, or Out Of Bag (OOB) predictions on the training data. Create graphs and tables of the model validation results. Applies these models to GIS .img files of predictors to create detailed prediction surfaces. Handles large predictor files for map making, by reading in the .img files in chunks, and output to the .txt file the prediction for each data chunk, before reading the next chunk of data.</td>
</tr>
<tr>
<td>License:</td>
<td>Unlimited</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-24 17:22:16 UTC; eafreeman</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-04-24 20:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='build.rastLUT'>Build a raster Look-UP-Table for training dataset</h2><span id='topic+build.rastLUT'></span>

<h3>Description</h3>

<p>GUI prompts will help the user build a Look-Up-Table to associated predictor variable with their corresponding spatial rasters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build.rastLUT(imageList=NULL,predList=NULL,qdata.trainfn=NULL,
rastLUTfn=NULL,folder=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build.rastLUT_+3A_imagelist">imageList</code></td>
<td>
<p> Vector. A vector of character strings giving names and full paths to all raster data files used in model. </p>
</td></tr>
<tr><td><code id="build.rastLUT_+3A_predlist">predList</code></td>
<td>
<p> Vector. A vector of character strings giving the predictor names used as headers in the model training data.</p>
</td></tr>
<tr><td><code id="build.rastLUT_+3A_qdata.trainfn">qdata.trainfn</code></td>
<td>
<p>String.  The name (full path or base name with path specified by <code>folder</code>) of the training data file used for building the model. The file must be a comma-delimited file <code>*.csv</code> with column headings. <code>qdata.trainfn</code> can also be an <code>R</code> dataframe. The column headers from <code>qdata.trainfn</code> are used to generate a list of possible predictors for the raster Look-UP-Table.</p>
</td></tr>
<tr><td><code id="build.rastLUT_+3A_rastlutfn">rastLUTfn</code></td>
<td>
<p> String. The name of the file output for the Look-Up-Table. By default, if a file name is provided by the <code>"qdatatrainfn"</code> argument <code>"_rastLUT.csv"</code> appended after <code>"qdatatrainfn"</code>. Otherwise, default filename for look-up-table is<code>"rastLUT.csv"</code></p>
</td></tr>
<tr><td><code id="build.rastLUT_+3A_folder">folder</code></td>
<td>
<p> String.  The folder used for output.  Do not add ending slash to path string.  If <code>folder = NULL</code> (default), a GUI interface prompts user to browse to a folder.  To use the working directory, specify <code>folder = getwd()</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function helps the user create a raster Look-Up-Table to be used later by <code>model.mapmake()</code>. Currently this function only works in a Windows environment. 
</p>
<p>First, if <code>"folder"</code> is not given, the user selects the output folder for the Look-UP-Table.
</p>
<p>Second, if <code>"predList"</code> or <code>"qdatatrainfn"</code>  are not given, the user selects the file containing the training data. The header of the file is used to generate a selection list of possible predictor variables.
</p>
<p>Third, if <code>"imageList"</code> is not provided, the user selects the rasters.
</p>
<p>Finally, the function steps through each band of each raster, and the user selects the appropriate predictor.
</p>


<h3>Value</h3>

<p>Returns a data frame containing the raster Look-Up-Table. Also Writes a <code>.csv</code> file containing the raster Look-Up-Table.
</p>


<h3>Author(s)</h3>

<p> Elizabeth Freeman </p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
folder&lt;-system.file("extdata", "helpexamples", package = "ModelMap")
qdata.trainfn = paste(folder,"/DATATRAIN.csv",sep="")

#build.rastLUT(	qdata.trainfn=qdata.trainfn,
#		folder=folder)

## End(Not run) # end dontrun

</code></pre>

<hr>
<h2 id='col2trans'>colors to transparent colors</h2><span id='topic+col2trans'></span>

<h3>Description</h3>

<p>transform color names to transparent versions of rgb color codes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col2trans(col.names,alpha=0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="col2trans_+3A_col.names">col.names</code></td>
<td>
<p> Vector. Vector of color names from <code><a href="grDevices.html#topic+colors">colors</a></code>. </p>
</td></tr>
<tr><td><code id="col2trans_+3A_alpha">alpha</code></td>
<td>
<p> Number. Number between 0 and 1 giving alpha channel (opacity) value  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Translates a vector of color names to a vector of transparent rgb color codes. Color names must be from names given by <code><a href="grDevices.html#topic+colors">colors</a></code>. 
</p>


<h3>Value</h3>

<p>Outputs a vector of transparent color codes.
</p>


<h3>Author(s)</h3>

<p> Elizabeth Freeman </p>


<h3>Examples</h3>

<pre><code class='language-R'>
col.names=c("blue","violetred4","thistle3","yellowgreen")
col2trans(col.names,alpha=.2)


###to see effect of alpha###

alpha&lt;-(0:10)/10
colmat&lt;-matrix(	1:(length(alpha)*length(col.names)),
			nrow=length(alpha),
			ncol=length(col.names),
			byrow=TRUE)

color.codes&lt;-vector("character",0)

for(i in 1:length(alpha)){
	color.codes&lt;-c(color.codes,col2trans(col.names,alpha=alpha[i]))
}

#make plot#
plot(	c(0,1),c(0,1),
	type="n",xlab="alpha",ylab="color name",yaxt="n",xaxs="i",yaxs="i")
abline(h=(0:100)/100)
image(	z=colmat,
		x=(0:length(alpha))/length(alpha),
		y=(0:length(col.names))/length(col.names),
		col=color.codes,
		add=TRUE
		)
op&lt;-par(xpd=TRUE)
text(	col.names,
	x=-.08,
	y=(1:length(col.names)-.5)/length(col.names),
	srt=90)
par(op)


</code></pre>

<hr>
<h2 id='get.test'>Randomly Divide Data into Training and Test Sets</h2><span id='topic+get.test'></span>

<h3>Description</h3>

<p>Uses random selection to split a dataset into training and test data sets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.test(proportion.test, qdatafn = NULL, seed = NULL, folder=NULL, 
qdata.trainfn = paste(strsplit(qdatafn, split = ".csv")[[1]], "_train.csv", sep = ""), 
qdata.testfn = paste(strsplit(qdatafn, split = ".csv")[[1]], "_test.csv", sep = ""))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.test_+3A_proportion.test">proportion.test</code></td>
<td>
<p> Number. The proportion of the training data that will be randomly extracted for use as a test set. Value between 0 and 1. </p>
</td></tr>
<tr><td><code id="get.test_+3A_qdatafn">qdatafn</code></td>
<td>
<p> String. The name (basename or full path) of the data file to be split into training and test data. This data should include both response and predictor variables. The file must be a comma-delimited file <code>*.csv)</code> with column headings and the predictor names in the file must match the raster layer files, if applying predictions (<code>predict = TRUE</code>). If <code>NULL</code> (the default), a GUI interface prompts user to browse to the data file. </p>
</td></tr>
<tr><td><code id="get.test_+3A_seed">seed</code></td>
<td>
<p> Integer. The number used to initialize randomization to randomly select rows for a test data set. If you want to produce the same model later, use the same seed. If <code>seed = NULL</code> (the default), a new one is created each time. </p>
</td></tr>
<tr><td><code id="get.test_+3A_folder">folder</code></td>
<td>
<p> String.  The folder used for all output from predictions and/or maps.  Do not add ending slash to path string.  If <code>folder = NULL</code> (default), a GUI interface prompts user to browse to a folder.  To use the working directory, specify <code>folder = getwd()</code>. </p>
</td></tr>
<tr><td><code id="get.test_+3A_qdata.trainfn">qdata.trainfn</code></td>
<td>
<p> String. The name of the file output of training data. By default, <code>_train</code> appended after <code>qdatafn</code>.</p>
</td></tr>
<tr><td><code id="get.test_+3A_qdata.testfn">qdata.testfn</code></td>
<td>
<p> String. The name of the file output of test data. By default, <code>_test</code> appended after <code>qdatafn</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function should be run once, before starting analysis to create training and test sets. If the cross validation option is to be used with RF or SGB models, or if the OOB option is to be used for RF models, then this step is unnecessary. 
</p>


<h3>Value</h3>

<p>Outputs a training data file and test data file. Unless <code>qdata.trainfn</code> or <code>qdata.testfn</code> are specified, the output will be located in <code>folder</code>. The output will have the same rows and columns as the original data.
</p>


<h3>Author(s)</h3>

<p> Elizabeth Freeman </p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
qdatafn&lt;-system.file("extdata", "helpexamples","DATATRAIN.csv", package = "ModelMap")

qdata&lt;-read.table(file=qdatafn,sep=",",header=TRUE,check.names=FALSE)

get.test(	proportion.test=0.2,
		qdatafn=qdatafn,
		seed=42,
		folder=getwd(),
		qdata.trainfn="example.train.csv",
		qdata.testfn="example.test.csv")

## End(Not run) # end dontrun

</code></pre>

<hr>
<h2 id='model.build'> Model Building</h2><span id='topic+model.build'></span>

<h3>Description</h3>

<p>Create sophisticated models using Random Forest, Quantile Regression Forests, Conditional Forests, or Stochastic Gradient Boosting from training data
</p>


<h3>Usage</h3>

<pre><code class='language-R'> 

model.build(model.type = NULL, qdata.trainfn = NULL, folder = NULL,
MODELfn = NULL, predList = NULL, predFactor = FALSE, response.name = NULL,
response.type = NULL, unique.rowname = NULL, seed = NULL, na.action = NULL,
keep.data = TRUE, ntree = switch(model.type,RF=500,QRF=1000,CF=500,500),
mtry = switch(model.type,RF=NULL,QRF=ceiling(length(predList)/3),
CF = min(5,length(predList)-1),NULL), replace = TRUE, strata = NULL,
sampsize = NULL, proximity = FALSE, importance=FALSE, 
quantiles=c(0.1,0.5,0.9), subset = NULL, weights = NULL,
controls = NULL, xtrafo = NULL, ytrafo = NULL, scores = NULL) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.build_+3A_model.type">model.type</code></td>
<td>
<p> String.  Model type.  <code>"RF"</code> (random forest), <code>"QRF"</code> (quantile random forest), or <code>"CF"</code> (conditional forest). The <code>ModelMap</code> package does not currently support <code>SGB</code> models. </p>
</td></tr>
<tr><td><code id="model.build_+3A_qdata.trainfn">qdata.trainfn</code></td>
<td>
<p>String.  The name (full path or base name with path specified by <code>folder</code>) of the training data file used for building the model (file should include columns for both response and predictor variables).  The file must be a comma-delimited file <code>*.csv</code> with column headings. <code>qdata.trainfn</code> can also be an <code>R</code> dataframe. If predictions will be made (<code>predict = TRUE</code> or <code>map=TRUE</code>) the predictor column headers must match the names of the raster layer files, or a <code>rastLUT</code> must be provided to match predictor columns to the appropriate raster and band.  If <code>qdata.trainfn = NULL</code> (the default), a GUI interface prompts user to browse to the training data file.  </p>
</td></tr>
<tr><td><code id="model.build_+3A_folder">folder</code></td>
<td>
<p> String.  The folder used for all output from predictions and/or maps.  Do not add ending slash to path string.  If <code>folder = NULL</code> (default), a GUI interface prompts user to browse to a folder.  To use the working directory, specify <code>folder = getwd()</code>.</p>
</td></tr>
<tr><td><code id="model.build_+3A_modelfn">MODELfn</code></td>
<td>
<p> String.  The file name to use to save files related to the model object.  If <code>MODELfn = NULL</code> (the default), a default name is generated by pasting <code>model.type</code>, <code>response.type</code>, and <code>response.name</code>, separated by underscores. If the other output filenames are left unspecified, <code>MODELfn</code> will be used as the basic name to generate other output filenames. The filename can be the full path, or it can be the simple basename, in which case the output will be to the folder specified by <code>folder</code>.</p>
</td></tr>
<tr><td><code id="model.build_+3A_predlist">predList</code></td>
<td>
<p> String.  A character vector of the predictor short names used to build the model.  These names must match the column names in the training/test data files and the names in column two of the <code>rastLUT</code>.  If <code>predList = NULL</code> (the default), a GUI interface prompts user to select predictors from column 2 of <code>rastLUT</code>. 
</p>
<p>If both <code>predList = NULL</code> and <code>rastLUT = NULL</code>, then a GUI interface prompts user to browse to rasters used as predictors, and select from a generated list, the individual layers (bands) of rasters used to build the model.  In this case (i.e., <code>rastLUT = NULL</code>), predictor column names of training data must be standard format, consisting of raster stack name followed by b1, b2, etc..., giving the band number within each stack (Example: <code>stacknameb1</code>, <code>stacknameb2</code>, <code>stacknameb3</code>, ...). 
</p>
</td></tr>
<tr><td><code id="model.build_+3A_predfactor">predFactor</code></td>
<td>
<p> String.  A character vector of predictor short names of the predictors from <code>predList</code> that are factors (i.e categorical predictors).  These must be a subset of the predictor names given in <code>predList</code> Categorical predictors may have multiple categories.</p>
</td></tr>
<tr><td><code id="model.build_+3A_response.name">response.name</code></td>
<td>
<p> String.  The name of the response variable used to build the model.  If <code>response.name = NULL</code>, a GUI interface prompts user to select a variable from the list of column names from training data file.  <code>response.name</code> must be column name from the training/test data files. </p>
</td></tr>
<tr><td><code id="model.build_+3A_response.type">response.type</code></td>
<td>
<p> String.  Response type: <code>"binary"</code>, <code>"categorical"</code> or <code>"continuous"</code>.  Binary response must be binary 0/1 variable with only 2 categories.  All zeros will be treated as one category, and everything else will be treated as the second category.</p>
</td></tr>
<tr><td><code id="model.build_+3A_unique.rowname">unique.rowname</code></td>
<td>
<p> String.  The name of the unique identifier used to identify each row in the training data.  If <code>unique.rowname = NULL</code>, a GUI interface prompts user to select a variable from the list of column names from the training data file.  If <code>unique.rowname = FALSE</code>, a variable is generated of numbers from <code>1</code> to <code>nrow(qdata)</code> to index each row. </p>
</td></tr>
<tr><td><code id="model.build_+3A_seed">seed</code></td>
<td>
<p> Integer.  The number used to initialize randomization to build RF or SGB models.  If you want to produce the same model later, use the same seed.  If <code>seed = NULL</code> (the default), a new seed is created each run. </p>
</td></tr>
<tr><td><code id="model.build_+3A_na.action">na.action</code></td>
<td>
<p>String.  Model validation.  Specifies the action to take if there are <code>NA</code> values in the predictor data. There are 2 options: (1) <code>na.action = na.omit</code> where any data point with missing predictors is removed from the model building data; (2) <code>na.action = na.roughfix</code> where a missing categorical predictor is replaced with the most common category, and a missing continuous predictor or response is replaced with the median. Note: it is not recommended that <code>na.roughfix</code> will just be used for missing predictor. Data points with missing response will always be omitted.  </p>
</td></tr>
<tr><td><code id="model.build_+3A_keep.data">keep.data</code></td>
<td>
<p>Logical.  RF and SGB models. Should a copy of the predictor data be included in the model object. Useful for if <code><a href="#topic+model.interaction.plot">model.interaction.plot</a></code> will be used later. </p>
</td></tr>
<tr><td><code id="model.build_+3A_ntree">ntree</code></td>
<td>
<p> Integer.  RF QRF and CF models.  The number of random forest trees for a RF model.  The default is 500 trees. </p>
</td></tr>
<tr><td><code id="model.build_+3A_mtry">mtry</code></td>
<td>
<p> Integer.  RF QRF and CF models.  Number of variables to try at each node of Random Forest trees.  By default, RF models will use the <code>"tuneRF()"</code> function to optimize <code>mtry</code>. </p>
</td></tr>
<tr><td><code id="model.build_+3A_replace">replace</code></td>
<td>
<p> Logical.  RF models.  Should sampling of cases be done with or without replacement? </p>
</td></tr>
<tr><td><code id="model.build_+3A_strata">strata</code></td>
<td>
<p> Factor or String.  RF models.  A (factor) variable that is used for stratified sampling. Can be in the form of either the name of the column in <code>qdata</code> or a factor or vector with one element for each row of <code>qdata</code>. </p>
</td></tr>
<tr><td><code id="model.build_+3A_sampsize">sampsize</code></td>
<td>
<p> Vector.  RF models.  Size(s) of sample to draw.  For classification, if <code>sampsize</code> is a vector of the length the number of factor levels <code>strata</code>, then sampling is stratified by <code>strata</code>, and the elements of <code>sampsize</code> indicate the numbers to be drawn from each strata. If argument <code>strata</code> is not provided, and <code>repsonse.type = "binary"</code> then sampling is stratified by presence/absence. If argument <code>sampsize</code> is not provided <code>model.build()</code> will use the default value from the <code>randomForest</code> package: <code>if (replace) nrow(data) else ceiling(.632*nrow(data))</code>. </p>
</td></tr>
<tr><td><code id="model.build_+3A_proximity">proximity</code></td>
<td>
<p> Logical.  RF models.  Should proximity measure among the rows be calculated for unsupervised models?</p>
</td></tr>
<tr><td><code id="model.build_+3A_importance">importance</code></td>
<td>
<p> Logical. QRF models. For QRF models only, importance must be specified at the time of model building. If TRUE importance of predictors is assessed at the given <code>quantiles</code>. Warning, on large datasets calculating QRF importances is very memory intensive and may require increasing memory limits with <code>memory.limit()</code>. NOTE: Importance currently unavailable for QRF models.</p>
</td></tr>
<tr><td><code id="model.build_+3A_quantiles">quantiles</code></td>
<td>
<p>Numeric. Used for QRF models if <code>importance=TRUE</code>. Specify which quantiles of response variable to use. Later importance plots can only be made for <code>quantiles</code> specified at the time of model building.</p>
</td></tr>
<tr><td><code id="model.build_+3A_subset">subset</code></td>
<td>
<p>CF models. An optional vector specifying a subset of observations to be used in the fitting process. Note: <code>subset</code> is not supported for cross validation diagnostics.</p>
</td></tr>
<tr><td><code id="model.build_+3A_weights">weights</code></td>
<td>
<p>CF models. An optional vector of weights to be used in the fitting process. Non-negative integer valued weights are allowed as well as non-negative real weights. Observations are sampled (with or without replacement) according to probabilities <code>weights/sum(weights)</code>. The fraction of observations to be sampled (without replacement) is computed based on the sum of the weights if all weights are integer-valued and based on the number of weights greater zero else. Alternatively, <code>weights</code> can be a double matrix defining case weights for all <code>ncol(weights)</code> trees in the forest directly. This requires more storage but gives the user more control. Note: <code>weights</code> is not supported for cross validation diagnostics.</p>
</td></tr>
<tr><td><code id="model.build_+3A_controls">controls</code></td>
<td>
<p>CF models. An object of class <code><a href="party.html#topic+ForestControl-class">ForestControl-class</a></code>, which can be obtained using cforest_control (and its convenience interfaces cforest_unbiased and cforest_classical). If <code>controls</code> is specified, then stand alone arguments <code>mtry</code> and <code>ntree</code> ignored and these parameters must be specified as part of the <code>controls</code> argument. If <code>controls</code> not specified, <code>model.build</code> defaults to <code>cforest_unbiased(mtry=mtry, ntree=ntree)</code> with the values of <code>mtry</code> and <code>ntree</code> specified by the stand alone arguments.</p>
</td></tr>
<tr><td><code id="model.build_+3A_xtrafo">xtrafo</code></td>
<td>
<p>CF models. A function to be applied to all input variables. By default, the <code>ptrafo</code> function from the <code>party</code> package is applied. Defaults to <code>xtrafo=ptrafo</code>.</p>
</td></tr>
<tr><td><code id="model.build_+3A_ytrafo">ytrafo</code></td>
<td>
<p>CF models. A function to be applied to all response variables. By default, the <code>ptrafo</code> function from the <code>party</code> package is applied. Defaults to <code>ytrafo=ptrafo</code>.</p>
</td></tr>
<tr><td><code id="model.build_+3A_scores">scores</code></td>
<td>
<p>CF models. An optional named list of scores to be attached to ordered factors. Note: <code>weights</code> is not supported for cross validation diagnostics.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This package provides a push button approach to complex model building and production mapping.  It contains three main functions: <code><a href="#topic+model.build">model.build</a></code>,<code><a href="#topic+model.diagnostics">model.diagnostics</a></code>, and <code><a href="#topic+model.mapmake">model.mapmake</a></code>. 
</p>
<p>In addition it contains a simple function <code><a href="#topic+get.test">get.test</a></code> that can be used to randomly divide a training dataset into training and test/validation sets; <code><a href="#topic+build.rastLUT">build.rastLUT</a></code> that uses GUI prompts to walk a user through the process of setting up a Raster look up table to link predictors from the training data with the rasters used for map contruction; <code><a href="#topic+model.explore">model.explore</a></code>, for preliminary data exploration; and, <code><a href="#topic+model.importance.plot">model.importance.plot</a></code> and <code><a href="#topic+model.interaction.plot">model.interaction.plot</a></code> for interpreting the effects of individual model predictors. 
</p>
<p>These functions can be run in a traditional R command mode, where all arguments are specified in the function call.  However they can also be used in a full push button mode, where you type in, for example, the simple command <code><a href="#topic+model.build">model.build</a></code>, and GUI pop up windows will ask questions about the type of model, the file locations of the data, etc...
</p>
<p>When running the <code>ModelMap</code> package on non-Windows platforms, file names and folders need to be specified in the argument list, but other pushbutton selections are handled by the <code>select.list()</code> function, which is platform independent. 
</p>
<p>Binary, categorical, and continuous response models are supported for Random Forest and Conditional Forest. Quantile Random Forest is appropriate for only continuous response models.
</p>
<p>Random Forest is implemented through the <code>randomForest</code> package within <code>R</code>.  Random Forest is more user friendly than Stochastic Gradient Boosting, as it has fewer parameters to be set by the user, and is less sensitive to tuning of these parameters.  A Random Forest model consists of multiple trees that vote on predictions.  For each tree a random subset of the training data is used to construct the tree, with the remaining data points used to construct out-of-bag (OOB) error estimates.  At each node of the tree a random selection of predictors is chosen to determine the split.  The number of predictors used to select the splits (argument <code>mtry</code>) is the primary user specified parameter that can affect model performance.  
</p>
<p>By default <code>mtry</code> will be automatically optimized using the <code>randomForest</code> package <code>tuneRF()</code> function. Note that this is a stochastic process. If there is a chance that models may be combined later with the <code>randomForest</code> package <code>combine</code> function then for consistency it is important to provide the <code>mtry</code> argument rather that using the default optimization process.
</p>
<p>Random Forest will not over fit data, therefore the only penalty of increasing the number of trees is computation time.  Random Forest can compute variable importance, an advantage over some &quot;black box&quot; modeling techniques if it is important to understand the ecological relationships underlying a model (Brieman, 2001).
</p>
<p>Quantile Regression Forests is implemented through the <code>quantregForest</code> package.
</p>
<p>Conditional Forests is implemented with the <code>cforest()</code> function in the <code>party</code> package. As stated in the <code>party</code> package, ensembles of conditional inference trees have not yet been extensively tested, so this routine is meant for the expert user only and its current state is rather experimental.
</p>
<p>For CF models, <code>ModelMap</code> currently only supports binary, categorical and continuous response models. Also, for some CF model parameters (<code>subset</code>, <code>weights</code>, and <code>scores</code>) <code>ModelMap</code> only provides OOB and independent test set diagnostics, and does not support cross validation diagnostics.
</p>
<p>Stochastic gradient boosting is not currently supported by <code>ModelMap</code>. 
</p>


<h3>Value</h3>

<p>The function will return the model object. Additionally, it will write a text file to disk, in the folder specified by <code>folder</code>. This file lists the values of each argument as chosen from GUI prompts used for the function call.
</p>


<h3>Author(s)</h3>

<p> Elizabeth Freeman and Tracey Frescino </p>


<h3>References</h3>

 
<p>Breiman, L. (2001) Random Forests. Machine Learning, 45:5-32.
</p>
<p>Elith, J., Leathwick, J. R. and Hastie, T. (2008). A working guide to boosted regression trees. Journal of Animal Ecology. 77:802-813.
</p>
<p>Liaw, A. and  Wiener, M. (2002). Classification and Regression by randomForest. R News 2(3), 18&ndash;22.
</p>
<p>N. Meinshausen (2006) &quot;Quantile Regression Forests&quot;, Journal of Machine Learning Research 7, 983-999 http://jmlr.csail.mit.edu/papers/v7/
</p>
<p>Ridgeway, G., (1999). The state of boosting. Comp. Sci. Stat. 31:172-181
</p>
<p>Carolin Strobl, Anne-Laure Boulesteix, Achim Zeileis and Torsten Hothorn (2007). Bias in Random Forest variable Importance Measures: Illustrations, Sources and a Solution. BMC Bioinformatics, 8, 25. http://www.biomedcentral.co,/1471-2105/8/25
</p>
<p>Carolin Strobl, James Malley and Gerhard Tutz (2009). An Introduction to Recursive Partitioning: Rationale, Application, and Characteristics of Classification and Regression Trees, Bagging, and Random forests. Phsycological Methods, 14(4), 323-348. 
</p>
<p>Torsten Hothorn, Berthold Lausen, Axel Benner and Martin Radespiel-Troeger (2004). Bagging Survival Trees. Statistics in Medicine, 23(1), 77-91.
</p>
<p>Torsten Hothorn, Peter Buhlmann, Sandrine Dudoit, Annette Molinaro and Mark J. ven der Laan (2006a). Survival Ensembles. Biostatistics, 7(3), 355-373. 
</p>
<p>Torston Hothorn, Kurt Hornik and Achim Zeileis (2006b). Unbiased Recursive Partitioning: A Conditional Inference Framework. Journal of Computational and Graphical Statistics, 15(3), 651-674. Preprint available from http://statmath.wu-wein.ac.at/~zeileis/papers/Hothorn+Hornik+Zeileis-2006.pdf
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+get.test">get.test</a></code>, <code><a href="#topic+model.diagnostics">model.diagnostics</a></code>, <code><a href="#topic+model.mapmake">model.mapmake</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
###########################################################################
############################# Run this set up code: #######################
###########################################################################

# set seed:
seed=38

# Define training and test files:

qdata.trainfn = system.file("extdata", "helpexamples","DATATRAIN.csv", package = "ModelMap")

# Define folder for all output:
folder=getwd()	

#identifier for individual training and test data points

unique.rowname="ID"


###########################################################################
############## Pick one of the following sets of definitions: #############
###########################################################################


########## Continuous Response, Continuous Predictors ############

#file name:
MODELfn="RF_Bio_TC"				

#predictors:
predList=c("TCB","TCG","TCW")	

#define which predictors are categorical:
predFactor=FALSE	

# Response name and type:
response.name="BIO"
response.type="continuous"


########## binary Response, Continuous Predictors ############

#file name to store model:
MODELfn="RF_CONIFTYP_TC"				

#predictors:
predList=c("TCB","TCG","TCW")		

#define which predictors are categorical:
predFactor=FALSE

# Response name and type:
response.name="CONIFTYP"

# This variable is 1 if a conifer or mixed conifer type is present, 
# otherwise 0.

response.type="binary"


########## Continuous Response, Categorical Predictors ############

# In this example, NLCD is a categorical predictor.
#
# You must decide what you want to happen if there are categories
# present in the data to be predicted (either the validation/test set
# or in the image file) that were not present in the original training data.
# Choices:
#       na.action = "na.omit"
#                    Any validation datapoint or image pixel with a value for any
#                    categorical predictor not found in the training data will be
#                    returned as NA.
#       na.action = "na.roughfix"
#                    Any validation datapoint or image pixel with a value for any
#                    categorical predictor not found in the training data will have
#                    the most common category for that predictor substituted,
#                    and the a prediction will be made.

# You must also let R know which of the predictors are categorical, in other
# words, which ones R needs to treat as factors.
# This vector must be a subset of the predictors given in predList

#file name to store model:
MODELfn="RF_BIO_TCandNLCD"			

#predictors:
predList=c("TCB","TCG","TCW","NLCD")

#define which predictors are categorical:
predFactor=c("NLCD")

# Response name and type:
response.name="BIO"
response.type="continuous"



###########################################################################
########################### build model: ##################################
###########################################################################


### create model before batching (only run this code once ever!) ###

model.obj = model.build( model.type="RF",
                       qdata.trainfn=qdata.trainfn,
                       folder=folder,		
                       unique.rowname=unique.rowname,	
                       MODELfn=MODELfn,
                       predList=predList,
                       predFactor=predFactor,
                       response.name=response.name,
                       response.type=response.type,
                       seed=seed,
                       na.action="na.roughfix"
)


## End(Not run) # end dontrun

</code></pre>

<hr>
<h2 id='model.diagnostics'> Model Predictions and Diagnostics </h2><span id='topic+model.diagnostics'></span>

<h3>Description</h3>

<p>Takes model object and makes predictions, runs model diagnostics, and creates graphs and tables of the results.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model.diagnostics(model.obj = NULL, qdata.trainfn = NULL, qdata.testfn = NULL, 
folder = NULL, MODELfn = NULL, response.name = NULL, unique.rowname = NULL,
 diagnostic.flag=NULL, seed = NULL, prediction.type=NULL, MODELpredfn = NULL, 
 na.action = NULL, v.fold = 10, device.type = NULL, DIAGNOSTICfn = NULL, 
 res=NULL, jpeg.res = 72, device.width = 7,  device.height = 7, units="in", 
 pointsize=12, cex=par()$cex, req.sens, req.spec, FPC, FNC, quantiles=NULL, 
 all=TRUE, subset = NULL, weights = NULL, mtry = NULL, controls = NULL, 
 xtrafo = NULL, ytrafo = NULL, scores = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.diagnostics_+3A_model.obj">model.obj</code></td>
<td>
 <p><code>R</code> model object.  The model object to use for prediction.  The model object must be of type <code>"RF"</code> (random forest), <code>"QRF"</code> (quantile random forest), or <code>"CF"</code> (conditional forest). The <code>ModelMap</code> package does not currently support <code>SGB</code> models. </p>
</td></tr>
<tr><td><code id="model.diagnostics_+3A_qdata.trainfn">qdata.trainfn</code></td>
<td>
<p>String.  The name (full path or base name with path specified by <code>folder</code>) of the training data file used for building the model (file should include columns for both response and predictor variables).  The file must be a comma-delimited file <code>*.csv</code> with column headings. <code>qdata.trainfn</code> can also be an <code>R</code> dataframe. If predictions will be made (<code>predict = TRUE</code> or <code>map=TRUE</code>) the predictor column headers must match the names of the raster layer files, or a <code>rastLUT</code> must be provided to match predictor columns to the appropriate raster and band.  If <code>qdata.trainfn = NULL</code> (the default), a GUI interface prompts user to browse to the training data file.  </p>
</td></tr>
<tr><td><code id="model.diagnostics_+3A_qdata.testfn">qdata.testfn</code></td>
<td>
<p>String.  The name (full path or base name with path specified by <code>folder</code>) of the independent data set for testing (validating) the model's predictions.  The file must be a comma-delimited file <code>".csv"</code> with column headings and the column headings must be the same as those in the training data file.  <code>qdata.testfn</code> can also be an <code>R</code> dataframe. If <code>qdata.testfn = NULL</code> (default), a GUI interface asks user if there is a test set available, then prompts user to browse to the test data file.  If no test set is desired (for example, cross-fold validation will be performed, or for RF models, Out-Of-Bag estimation, set <code>qdata.testfn = FALSE</code>. If no test set is given, and <code>qdata.testfn</code> is not set to <code>FALSE</code>, the GUI interface asks if a proportion of the data should be set aside as an independent test set.  If this is desired, the user will be prompted to specify the proportion to set aside as test data, and two new data files will be generated in the out put folder.  The new file names will be the original data file name with <code>"_train"</code> and <code>"_test"</code> appended to the end of the file names.</p>
</td></tr>
<tr><td><code id="model.diagnostics_+3A_folder">folder</code></td>
<td>
<p> String.  The folder used for all output from predictions and/or maps.  Do not add ending slash to path string.  If <code>folder = NULL</code> (default), a GUI interface prompts user to browse to a folder.  To use the working directory, specify <code>folder = getwd()</code>.</p>
</td></tr>
<tr><td><code id="model.diagnostics_+3A_modelfn">MODELfn</code></td>
<td>
<p> String.  The file name to use to save the generated model object.  If <code>MODELfn = NULL</code> (the default), a default name is generated by pasting <code>model.type_response.type_response.name</code>. If the other output filenames are left unspecified, <code>MODELfn</code> will be used as the basic name to generate other output filenames. The filename can be the full path, or it can be the simple basename, in which case the output will be to the folder specified by <code>folder</code>.</p>
</td></tr>
<tr><td><code id="model.diagnostics_+3A_response.name">response.name</code></td>
<td>
<p> String.  The name of the response variable used to build the model. The <code>response.name</code> must be column name from the training/test data files. If the <code>model.obj</code> was constructed in <code>ModelMap</code> with the <code>model.build()</code> function, then the <code>model.diagnostics()</code> can extract the <code>response.name</code> from the <code>model.obj</code>. If the model was constructed outside of <code>ModelMap</code> the you may need to specify the <code>response.name</code>. In particular, if a SGB model was constructed with the aid of Elith's code, it is necessary to specify the <code>response.name</code> argument, as all models constructed with this code are given a response name of <code>"y.data"</code>. If the <code>response.name</code> argument differs from the response name in the <code>model.obj</code>, the specified argument is giver preference, and a warning generated.</p>
</td></tr>
<tr><td><code id="model.diagnostics_+3A_unique.rowname">unique.rowname</code></td>
<td>
<p> String.  The name of the unique identifier used to identify each row in the training data.  If <code>unique.rowname = NULL</code>, a GUI interface prompts user to select a variable from the list of column names from the training data file.  If <code>unique.rowname = FALSE</code>, a variable is generated of numbers from <code>1</code> to <code>nrow(qdata)</code> to index each row. </p>
</td></tr>
<tr><td><code id="model.diagnostics_+3A_diagnostic.flag">diagnostic.flag</code></td>
<td>
<p> String.  The name of a column used to identify a subset of rows in the training data or test data to 
use for model diagnostics. This column must be either a logical vector (<code>TRUE</code> and <code>FALSE</code>) or a vector of zeros ond ones (where <code>0=FALSE</code> and <code>1=TRUE</code>. If this argument is used model diagnostics that depend on predicted and observed values will be calculated from a subset of the training or test data. These include confusion matrix and threshold criteria for binary response models and the scatterplot for continuous response models. The output file of predicted and observed values will have an aditional column, indicating which rows were used in the diagnostic calculations. Note that for cross validation, the entire training dataset will be used to create cross validation predictions, but that only the predictions on the the rows indicated by <code>diagnostic.flag</code> will be used for the diagnostics. </p>
</td></tr>
<tr><td><code id="model.diagnostics_+3A_seed">seed</code></td>
<td>
<p> Integer.  The number used to initialize randomization to build RF or SGB models.  If you want to produce the same model later, use the same seed.  If <code>seed = NULL</code> (the default), a new seed is created each run. </p>
</td></tr>
<tr><td><code id="model.diagnostics_+3A_prediction.type">prediction.type</code></td>
<td>
<p> String. Prediction type.  <code>"TEST"</code>, <code>"CV"</code>, <code>"OOB"</code> or <code>"TRAIN"</code>.  If <code>predict = "TEST"</code>, validation predictions will be made on the test set provided by <code>qdata.testfn</code>.  If <code>predict = "CV"</code>, cross validation will be used on the training data provided by <code>qdata.trainfn</code>. If <code>model.obj</code> is a Random Forest model and <code>predict = "OOB"</code> the Out-of-Bag predictions will be calculated on the training data. If <code>model.obj</code> is a Stochastic Gradient Boosting model and <code>predict = "TRAIN"</code> the predictions will be calculated on the training data, but these predictions should be used with caution as this will lead to over optimistic estimates of model quality. A <code>*.csv</code> file of the unique id, observed, and predicted values is generated and put in the specified (or default) folder.</p>
</td></tr>
<tr><td><code id="model.diagnostics_+3A_modelpredfn">MODELpredfn</code></td>
<td>
<p> String.  Model validation.  A character string used to construct the output file names for the validation diagnostics, for example the prediction <code>*.csv</code> file, and the graphics <code>*.jpg</code>, <code>*.pdf</code> and <code>*.ps</code> files.  The filename can be the full path, or it can be the simple basename, in which case the output will be to the folder specified by <code>folder</code>. If <code>MODELpredfn = NULL</code> (the default), a default name is created by pasting <code>modelfn</code> and <code>"_pred"</code>.</p>
</td></tr>
<tr><td><code id="model.diagnostics_+3A_na.action">na.action</code></td>
<td>
<p>String.  Model validation.  Specifies the action to take if there are <code>NA</code> values in the predictor data or if there is a level or class of a categorical predictor variable in the validation test set, but not in the training data set.  By default, <code>model.daignostics()</code> will use the same <code>na.action</code> as was given to <code>model.build</code>. There are 2 options: (1) <code>na.action = "na.omit"</code> where any data point with <code>NA</code> or any new levels for any of the factored predictors is removed from the data; (2) <code>na.action = "na.roughfix"</code> where a missing categorical predictor is replaced with the most common category, and a missing continuous predictor is replaced with the median. Note: data points with missing response values will always be omitted.  </p>
</td></tr>
<tr><td><code id="model.diagnostics_+3A_v.fold">v.fold</code></td>
<td>
<p> Integer (or logical <code>FALSE</code>).  Model validation.  The number of cross validation folds to use when making validation predictions on the training data.  Only used if  <code>prediction.type = "CV"</code>.</p>
</td></tr>
<tr><td><code id="model.diagnostics_+3A_device.type">device.type</code></td>
<td>
<p> String or vector of strings.  Model validation.  One or more device types for graphical output from model validation diagnostics. 
</p>
<p>Current choices:
</p>

<table>
<tr>
 <td style="text-align: left;">
	  </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>"default"</code> </td><td style="text-align: left;"> default graphics device</td>
</tr>
<tr>
 <td style="text-align: left;">
	  </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>"jpeg"</code> </td><td style="text-align: left;"> *.jpg files</td>
</tr>
<tr>
 <td style="text-align: left;">
	  </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>"none"</code> </td><td style="text-align: left;"> no graphics device generated</td>
</tr>
<tr>
 <td style="text-align: left;">	
	  </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>"pdf"</code> </td><td style="text-align: left;"> *.pdf files</td>
</tr>
<tr>
 <td style="text-align: left;">
	  </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>"png"</code> </td><td style="text-align: left;"> *.png files</td>
</tr>
<tr>
 <td style="text-align: left;">
	  </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>"postscript"</code> </td><td style="text-align: left;"> *.ps files</td>
</tr>
<tr>
 <td style="text-align: left;">
	  </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>"tiff"</code> </td><td style="text-align: left;"> *.tif files </td>
</tr>

</table>

</td></tr>
<tr><td><code id="model.diagnostics_+3A_diagnosticfn">DIAGNOSTICfn</code></td>
<td>
<p> String.  Model validation.  Name used as base to create names for output files from model validation diagnostics.  The filename can be the full path, or it can be the simple basename, in which case the output will be to the folder specified by <code>folder</code>.  Defaults to <code>DIAGNOSTICfn = MODELfn</code> followed by the appropriate suffixes (i.e. <code>".csv"</code>, <code>".jpg"</code>, etc...). </p>
</td></tr>
<tr><td><code id="model.diagnostics_+3A_res">res</code></td>
<td>
<p> Integer.  Model validation.  Pixels per inch for jpeg, png, and tiff plots.  The default is 72dpi, good for on screen viewing. For printing, suggested setting is 300dpi. </p>
</td></tr>
<tr><td><code id="model.diagnostics_+3A_jpeg.res">jpeg.res</code></td>
<td>
<p> Integer.  Model validation.  Deprecated. Ignored unless <code>res</code> not provided. </p>
</td></tr>
<tr><td><code id="model.diagnostics_+3A_device.width">device.width</code></td>
<td>
<p> Integer.  Model validation.  The device width for diagnostic plots in inches. </p>
</td></tr>
<tr><td><code id="model.diagnostics_+3A_device.height">device.height</code></td>
<td>
<p> Integer.  Model validation.  The device height for diagnostic plots in inches. </p>
</td></tr>
<tr><td><code id="model.diagnostics_+3A_units">units</code></td>
<td>
<p> Model validation.  The units in which <code>device.height</code> and <code>device.width</code> are given. Can be <code>"px"</code> (pixels), <code>"in"</code> (inches, the default), <code>"cm"</code> or <code>"mm"</code>. </p>
</td></tr>
<tr><td><code id="model.diagnostics_+3A_pointsize">pointsize</code></td>
<td>
<p> Integer.  Model validation.  The default pointsize of plotted text, interpreted as big points (1/72 inch) at <code>res</code> ppi</p>
</td></tr>
<tr><td><code id="model.diagnostics_+3A_cex">cex</code></td>
<td>
<p> Integer.  Model validation.  The cex for diagnostic plots. </p>
</td></tr>
<tr><td><code id="model.diagnostics_+3A_req.sens">req.sens</code></td>
<td>
<p> Numeric.  Model validation.  The required sensitivity for threshold optimization for binary response model evaluation. </p>
</td></tr>
<tr><td><code id="model.diagnostics_+3A_req.spec">req.spec</code></td>
<td>
<p> Numeric.  Model validation.  The required specificity for threshold optimization for binary response model evaluation. </p>
</td></tr>
<tr><td><code id="model.diagnostics_+3A_fpc">FPC</code></td>
<td>
<p> Numeric.  Model validation.  The False Positive Cost for threshold optimization for binary response model evaluation. </p>
</td></tr>
<tr><td><code id="model.diagnostics_+3A_fnc">FNC</code></td>
<td>
<p> Numeric.  Model validation.  The False Negative Cost for threshold optimization for binary response model evaluation. </p>
</td></tr>
<tr><td><code id="model.diagnostics_+3A_quantiles">quantiles</code></td>
<td>
<p> Numeric Vector.  QRF models.  The quantiles to predict. A numeric vector with values between zero and one. If model was built without specifying quantiles, quantile importance can not be calculated, but <code>quantiles</code> can still be used to specify prediction quantiles. If model was built with quantiles specified, then the model quantiles will be used for  importance graph.  If quantiles are not specified for model building or diagnostics, prediction quantiles will default to <code>quantiles=c(0.1,0.5,0.9)</code></p>
</td></tr>
<tr><td><code id="model.diagnostics_+3A_all">all</code></td>
<td>
<p> Logical.  QRF models. <code>all=TRUE</code> uses all observations for prediction. <code>all=FALSE</code> uses only a certain number of observations per node for prediction (set with argument obs). Unlike in the quantredForest package itself, the default in ModelMap is <code>all=TRUE</code>, to more closely parallel ordinary random forest models. </p>
</td></tr>
<tr><td><code id="model.diagnostics_+3A_subset">subset</code></td>
<td>
<p>CF models. NOT SUPPORTED. Only needed for <code>prediction.type="CV"</code> for CF models. An optional vector specifying a subset of observations to be used in the fitting process. Note: <code>subset</code> is not yet supported for cross validation diagnostics.</p>
</td></tr>
<tr><td><code id="model.diagnostics_+3A_weights">weights</code></td>
<td>
<p>CF models. NOT SUPPORTED. Only needed for <code>prediction.type="CV"</code> for CF models. An optional vector of weights to be used in the fitting process. Non-negative integer valued weights are allowed as well as non-negative real weights. Observations are sampled (with or without replacement) according to probabilities <code>weights/sum(weights)</code>. The fraction of observations to be sampled (without replacement) is computed based on the sum of the weights if all weights are integer-valued and based on the number of weights greater zero else. Alternatively, <code>weights</code> can be a double matrix defining case weights for all <code>ncol(weights)</code> trees in the forest directly. This requires more storage but gives the user more control. Note: <code>weights</code> is not yet supported for cross validation diagnostics.</p>
</td></tr>
<tr><td><code id="model.diagnostics_+3A_mtry">mtry</code></td>
<td>
<p> Integer. Only needed for <code>prediction.type="CV"</code> for CF models (for RF and QRF models mtry will be determined from the model object).  Number of variables to try at each node of Random Forest trees. </p>
</td></tr>
<tr><td><code id="model.diagnostics_+3A_controls">controls</code></td>
<td>
<p>CF models. Only needed for <code>prediction.type="CV"</code> for CF models. An object of class <code><a href="party.html#topic+ForestControl-class">ForestControl-class</a></code>, which can be obtained using cforest_control (and its convenience interfaces cforest_unbiased and cforest_classical). If <code>controls</code> is specified, then stand alone arguments <code>mtry</code> and <code>ntree</code> ignored and these parameters must be specified as part of the <code>controls</code> argument. If <code>controls</code> not specified, <code>model.build</code> defaults to <code>cforest_unbiased(mtry=mtry, ntree=ntree)</code> with the values of <code>mtry</code> and <code>ntree</code> specified by the stand alone arguments.</p>
</td></tr>
<tr><td><code id="model.diagnostics_+3A_xtrafo">xtrafo</code></td>
<td>
<p>CF models. Only needed for <code>prediction.type="CV"</code> for CF models. A function to be applied to all input variables. By default, the <code>ptrafo</code> function from the <code>party</code> package is applied. </p>
</td></tr>
<tr><td><code id="model.diagnostics_+3A_ytrafo">ytrafo</code></td>
<td>
<p>CF models. Only needed for <code>prediction.type="CV"</code> for CF models. A function to be applied to all response variables. By default, the <code>ptrafo</code> function from the <code>party</code> package is applied. </p>
</td></tr>
<tr><td><code id="model.diagnostics_+3A_scores">scores</code></td>
<td>
<p>CF models. NOT SUPPORTED. Only needed for <code>prediction.type="CV"</code> for CF models. An optional named list of scores to be attached to ordered factors. Note: <code>scores</code> is not yet supported for cross validation diagnostics.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>model.diagnostics()</code>takes model object and makes predictions, runs model diagnostics, and creates graphs and tables of the results.
</p>
<p><code>model.diagnostics()</code> can be run in a traditional R command mode, where all arguments are specified in the function call.  However it can also be used in a full push button mode, where you type in the simple command <code>model.map()</code>, and GUI pop up windows will ask questions about the type of model, the file locations of the data, etc...
</p>
<p>When running <code>model.map()</code> on non-Windows platforms, file names and folders need to be specified in the argument list, but other pushbutton selections are handled by the <code>select.list()</code> function, which is platform independent. 
</p>
<p>Diagnostic predictions are made my one of four methods, and a text file is generated consisting of three columns: Observation ID, observed values and predicted values. If <code>predition.type = "CV")</code> an additional column indicates which cross-fold each observation fell into. If the models response type is categorical then in addition a column giving the category predicted by majority vote, there are also categories for each possible response category giving the proportion of trees that predicted that category.
</p>
<p>A variable importance graph is made. If <code>response.type = "categorical"</code>, category specific graphs are generated for variable importance. These show how much the model accuracy for each category is affected when the values of each predictor variable is randomly permuted.
</p>
<p>The package <code>corrplot</code> is used to generate a plot of correlation between predictor variables. If there are highly correlated predictor variables, then the variable importances of <code>"RF"</code> and <code>"QRF"</code> models need to be interpreted with care, and users may want to consider looking at the conditional variable importances available for <code>"CF"</code> models produced by the <code>party</code> package.
</p>
<p>If <code>model.type = "RF"</code>, the OOB error is plotted as a function of number of trees in the model. If <code>response.type = "binary"</code> or If <code>response.type = "categorical"</code> category specific graphs are generated for  OOB error as a function of number of trees.
</p>
<p>If <code>response.type = "binary"</code>, a summary graph is made using the <code>PresenceAbsence</code> package and a <code>*.csv</code> spreadsheets are created of optimized thresholds by several methods with their associated error statistics, and predicted prevalence.
</p>
<p>If <code>response.type = "continuous"</code> a scatterplot of observed vs.  predicted is created with a simple linear regression line.  The graph is labeled with slope and intercept of this line as well as Pearson's and Spearman's correlation coefficients.
</p>
<p>If <code>response.type = "categorical"</code>, a confusion matrix is generated, that includes erros of ommission and comission, as well as Kappa, Percent Correctly Classified (PCC) and the Multicategorical Area Under the Curve (MAUC) as defined by Hand and Till (2001) and calculated by the package <code>HandTill2001</code>.
</p>


<h3>Value</h3>

<p>The function will return a dataframe of the row ID, and the Observed and predicted values. 
</p>
<p>For Binary response models the predicted probability of presence is returned. 
</p>
<p>For Categorical Response models the predicted category (by majority vote) is returned as well as a column for each category giving the probability of that category. If necessary, <code><a href="base.html#topic+make.names">make.names</a></code> is applied to the categories to create valid column names.
</p>
<p>For Continuous response models the predicted value is returned. 
</p>
<p>If <code>prediction.type = "CV"</code> the dataframe also includes a column indicating which cross-validation fold each datapoint was in. 
</p>


<h3>Note</h3>

<p>Importance currently unavailable for QRF models.
</p>
<p>If you are running cross validation diagnostics on a CF model, the model parameters will NOT automatically be passed to <code>model.diagnostics()</code>. For cross validation, it is the users responsibility to be certain that the CF arguments are the same in <code>model.build()</code> and <code>model.diagnostics()</code>.
</p>
<p>Also, for some CF model parameters (<code>subset</code>, <code>weights</code>, and <code>scores</code>) <code>ModelMap</code> only provides OOB and independent test set diagnostics, and does not support cross validation diagnostics.
</p>


<h3>Author(s)</h3>

<p> Elizabeth Freeman and Tracey Frescino </p>


<h3>References</h3>

 
<p>Breiman, L. (2001) Random Forests. Machine Learning, 45:5-32.
</p>
<p>Elith, J., Leathwick, J. R. and Hastie, T. (2008). A working guide to boosted regression trees. Journal of Animal Ecology. 77:802-813.
</p>
<p>Hand, D. J., &amp; Till, R. J. (2001). A simple generalisation of the area under the ROC curve for multiple class classification problems. Machine Learning, 45(2), 171-186.
</p>
<p>Liaw, A. and  Wiener, M. (2002). Classification and Regression by randomForest. R News 2(3), 18&ndash;22.
</p>
<p>Ridgeway, G., (1999). The state of boosting. Comp. Sci. Stat. 31:172-181
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+get.test">get.test</a></code>, <code><a href="#topic+model.build">model.build</a></code>, <code><a href="#topic+model.mapmake">model.mapmake</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

###########################################################################
############################# Run this set up code: #######################
###########################################################################

# set seed:
seed=38

# Define training and test files:

qdata.trainfn = system.file("extdata", "helpexamples","DATATRAIN.csv", package = "ModelMap")
qdata.testfn = system.file("extdata", "helpexamples","DATATEST.csv", package = "ModelMap")

# Define folder for all output:
folder=getwd()	

#identifier for individual training and test data points

unique.rowname="ID"


###########################################################################
############## Pick one of the following sets of definitions: #############
###########################################################################


########## Continuous Response, Continuous Predictors ############

#file name to store model:
MODELfn="RF_Bio_TC"				

#predictors:
predList=c("TCB","TCG","TCW")	

#define which predictors are categorical:
predFactor=FALSE	

# Response name and type:
response.name="BIO"
response.type="continuous"


########## binary Response, Continuous Predictors ############

#file name to store model:
MODELfn="RF_CONIFTYP_TC"				

#predictors:
predList=c("TCB","TCG","TCW")		

#define which predictors are categorical:
predFactor=FALSE

# Response name and type:
response.name="CONIFTYP"

# This variable is 1 if a conifer or mixed conifer type is present, 
# otherwise 0.

response.type="binary"


########## Continuous Response, Categorical Predictors ############

# In this example, NLCD is a categorical predictor.
#
# You must decide what you want to happen if there are categories
# present in the data to be predicted (either the validation/test set
# or in the image file) that were not present in the original training data.
# Choices:
#       na.action =  "na.omit"
#                    Any validation datapoint or image pixel with a value for any
#                    categorical predictor not found in the training data will be
#                    returned as NA.
#       na.action =  "na.roughfix"
#                    Any validation datapoint or image pixel with a value for any
#                    categorical predictor not found in the training data will have
#                    the most common category for that predictor substituted,
#                    and the a prediction will be made.

# You must also let R know which of the predictors are categorical, in other
# words, which ones R needs to treat as factors.
# This vector must be a subset of the predictors given in predList

#file name to store model:
MODELfn="RF_BIO_TCandNLCD"			

#predictors:
predList=c("TCB","TCG","TCW","NLCD")

#define which predictors are categorical:
predFactor=c("NLCD")

# Response name and type:
response.name="BIO"
response.type="continuous"



###########################################################################
########################### build model: ##################################
###########################################################################


### create model ###

model.obj = model.build( model.type="RF",
                       qdata.trainfn=qdata.trainfn,
                       folder=folder,		
                       unique.rowname=unique.rowname,	
                       MODELfn=MODELfn,
                       predList=predList,
                       predFactor=predFactor,
                       response.name=response.name,
                       response.type=response.type,
                       seed=seed,
                       na.action="na.roughfix"
)

###########################################################################
#### Then Run this code make validation predictions and diagnostics: ######
###########################################################################


### for Out-of-Bag predictions ###

MODELpredfn&lt;-paste(MODELfn,"_OOB",sep="")
PRED.OOB&lt;-model.diagnostics( 	model.obj=model.obj,
				qdata.trainfn=qdata.trainfn,
                   		folder=folder,		
                  	 	unique.rowname=unique.rowname,
                	# Model Validation Arguments
                   		prediction.type="OOB",
                   		MODELpredfn=MODELpredfn,
                   		device.type=c("default","jpeg","pdf"),	
                   		na.action="na.roughfix"
)
PRED.OOB

### for Cross-Validation predictions ###

#MODELpredfn&lt;-paste(MODELfn,"_CV",sep="")
#PRED.CV&lt;-model.diagnostics( 	model.obj=model.obj,
#                   		qdata.trainfn=qdata.trainfn,
#                   		folder=folder,		
#                   		unique.rowname=unique.rowname,
#                   		seed=seed,
#                	# Model Validation Arguments
#                   		prediction.type="CV",
#                   		MODELpredfn=MODELpredfn,
#                   		device.type=c("default","jpeg","pdf"),	
#                   		v.fold=10,
#                   		na.action="na.roughfix"
#)
#PRED.CV

### for Independent Test Set predictions ###

#MODELpredfn&lt;-paste(MODELfn,"_TEST",sep="")
#PRED.TEST&lt;-model.diagnostics( 	model.obj=model.obj,
#                   		qdata.testfn=qdata.testfn,
#                   		folder=folder,		
#                   		unique.rowname=unique.rowname,
#                	# Model Validation Arguments
#                   		prediction.type="TEST",
#                   		MODELpredfn=MODELpredfn,
#                   		device.type=c("default","jpeg","pdf"),	
#                   		na.action="na.roughfix"
#)
#PRED.TEST
)


## End(Not run) # end dontrun

</code></pre>

<hr>
<h2 id='model.explore'>
Exploratory data analysis
</h2><span id='topic+model.explore'></span>

<h3>Description</h3>

<p>Graphically explores the relationships between the training data and the predictor rasters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model.explore(qdata.trainfn = NULL, folder = NULL, predList = NULL, 
predFactor = FALSE, response.name = NULL, response.type = NULL, 
response.colors = NULL, unique.rowname = NULL, OUTPUTfn = NULL, 
device.type = NULL, allow.default.graphics=FALSE, res=NULL, jpeg.res = 72, 
MAXCELL=100000, device.width = NULL, device.height = NULL, units="in", 
pointsize=12, cex=1, rastLUTfn = NULL, create.extrapolation.masks = FALSE, 
na.value = -9999, col.ramp = rainbow(101, start = 0, end = 0.5), 
col.cat = palette()[-1])
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.explore_+3A_qdata.trainfn">qdata.trainfn</code></td>
<td>
<p>String.  The name (full path or base name with path specified by <code>folder</code>) of the training data file used for building the model (file should include columns for both response and predictor variables).  The file must be a comma-delimited file <code>*.csv</code> with column headings. <code>qdata.trainfn</code> can also be an <code>R</code> dataframe. If predictions will be made (<code>predict = TRUE</code> or <code>map=TRUE</code>) the predictor column headers must match the names of the raster layer files, or a <code>rastLUT</code> must be provided to match predictor columns to the appropriate raster and band. If <code>qdata.trainfn = NULL</code> (the default), a GUI interface prompts user to browse to the training data file.</p>
</td></tr>
<tr><td><code id="model.explore_+3A_folder">folder</code></td>
<td>
<p>String.  The folder used for all output from predictions and/or maps.  Do not add ending slash to path string.  If <code>folder = NULL</code> (default), a GUI interface prompts user to browse to a folder.  To use the working directory, specify <code>folder = getwd()</code>.</p>
</td></tr>
<tr><td><code id="model.explore_+3A_predlist">predList</code></td>
<td>
<p> String.  A character vector of the predictor short names used to build the model.  These names must match the column names in the training/test data files and the names in column two of the <code>rastLUT</code>.  If <code>predList = NULL</code> (the default), a GUI interface prompts user to select predictors from column 2 of <code>rastLUT</code>.</p>
</td></tr>
<tr><td><code id="model.explore_+3A_predfactor">predFactor</code></td>
<td>
<p> String.  A character vector of predictor short names of the predictors from <code>predList</code> that are factors (i.e categorical predictors).  These must be a subset of the predictor names given in <code>predList</code> Categorical predictors may have multiple categories.</p>
</td></tr>
<tr><td><code id="model.explore_+3A_response.name">response.name</code></td>
<td>
<p> String.  The name of the response variable used to build the model.  If <code>response.name = NULL</code>, a GUI interface prompts user to select a variable from the list of column names from training data file.  <code>response.name</code> must be column name from the training/test data files. </p>
</td></tr>
<tr><td><code id="model.explore_+3A_response.type">response.type</code></td>
<td>
<p> String.  Response type: <code>"binary"</code>, <code>"categorical"</code> or <code>"continuous"</code>.  Binary response must be binary 0/1 variable with only 2 categories.  All zeros will be treated as one category, and everything else will be treated as the second category.</p>
</td></tr>
<tr><td><code id="model.explore_+3A_response.colors">response.colors</code></td>
<td>
<p> Data frame. A two column data frame. Column names must be:<code>category</code>, the response categories; and, <code>color</code>, the colors associated with each category.</p>
</td></tr>
<tr><td><code id="model.explore_+3A_unique.rowname">unique.rowname</code></td>
<td>
<p> String.  The name of the unique identifier used to identify each row in the training data. If <code>unique.rowname = NULL</code>, a GUI interface prompts user to select a variable from the list of column names from the training data file.  If <code>unique.rowname = FALSE</code>, a variable is generated of numbers from <code>1</code> to <code>nrow(qdata)</code> to index each row. </p>
</td></tr>
<tr><td><code id="model.explore_+3A_outputfn">OUTPUTfn</code></td>
<td>
<p> String. Filename that ouput file names will be based on.</p>
</td></tr> 
<tr><td><code id="model.explore_+3A_device.type">device.type</code></td>
<td>
<p> String or vector of strings.  Model validation.  One or more device types for graphical output from model validation diagnostics. 
</p>
<p>Current choices:
</p>

<table>
<tr>
 <td style="text-align: left;">
	  </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>"default"</code> </td><td style="text-align: left;"> default graphics device</td>
</tr>
<tr>
 <td style="text-align: left;">
	  </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>"jpeg"</code> </td><td style="text-align: left;"> *.jpg files</td>
</tr>
<tr>
 <td style="text-align: left;">
	  </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>"none"</code> </td><td style="text-align: left;"> no graphics device generated</td>
</tr>
<tr>
 <td style="text-align: left;">	
	  </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>"pdf"</code> </td><td style="text-align: left;"> *.pdf files</td>
</tr>
<tr>
 <td style="text-align: left;">
	  </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>"png"</code> </td><td style="text-align: left;"> *.png files</td>
</tr>
<tr>
 <td style="text-align: left;">
	  </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>"postscript"</code> </td><td style="text-align: left;"> *.ps files</td>
</tr>
<tr>
 <td style="text-align: left;">
	  </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>"tiff"</code> </td><td style="text-align: left;"> *.tif files </td>
</tr>

</table>

<p>Note that the <code>"default"</code> device is disabled unless <code>allow.default.graphics=TRUE</code>. This is because these graphics are slow to produce, and if the onscreen graphics window is moved or closed while the function is in progress there is a risk of crashing the entire R session. </p>
</td></tr>
<tr><td><code id="model.explore_+3A_allow.default.graphics">allow.default.graphics</code></td>
<td>
<p> Logical.  Should the default on-screen graphics device be allowed. USE WITH CAUTION! These graphics are complicated and slow to produce. If the on-screen default graphics device is moved or closed before the plot is completed it can crash the entire R session.</p>
</td></tr>
<tr><td><code id="model.explore_+3A_res">res</code></td>
<td>
<p> Integer.  Model validation.  Pixels per inch for jpeg, png, and tiff plots.  The default is 72dpi, good for on screen viewing. For printing, suggested setting is 300dpi. </p>
</td></tr>
<tr><td><code id="model.explore_+3A_jpeg.res">jpeg.res</code></td>
<td>
<p> Integer. Graphical output. Deprecated. Ignored unless <code>res</code> not provided. </p>
</td></tr>
<tr><td><code id="model.explore_+3A_maxcell">MAXCELL</code></td>
<td>
<p> Integer.  Graphical output.  The maximum number of raster cells used to create the graphical output. Rasters larger than this value will be subsampled for the graphical maps and figures. The default value of <code>MAXCELL=100000</code> is generally a good resolution for onscreen viewing with the default jpeg resolution of 72dpi. Publication quality qraphics may require higher <code>MAXCELL</code>. Higher values require more memory and are slower to process.
</p>
<p>Note: <code>MAXCELL</code> only affects graphical figures. Output rasters generated when <code>create.extrapolation.masks=TRUE</code> are always done on full resolution rasters. </p>
</td></tr>
<tr><td><code id="model.explore_+3A_device.width">device.width</code></td>
<td>
<p> Integer.  Model validation.  The device width for diagnostic plots in inches. </p>
</td></tr>
<tr><td><code id="model.explore_+3A_device.height">device.height</code></td>
<td>
<p> Integer.  Model validation.  The device height for diagnostic plots in inches. </p>
</td></tr>
<tr><td><code id="model.explore_+3A_units">units</code></td>
<td>
<p> Model validation.  The units in which <code>device.height</code> and <code>device.width</code> are given. Can be <code>"px"</code> (pixels), <code>"in"</code> (inches, the default), <code>"cm"</code> or <code>"mm"</code>. </p>
</td></tr>
<tr><td><code id="model.explore_+3A_pointsize">pointsize</code></td>
<td>
<p> Integer.  Model validation.  The default pointsize of plotted text, interpreted as big points (1/72 inch) at <code>res</code> ppi</p>
</td></tr>
<tr><td><code id="model.explore_+3A_cex">cex</code></td>
<td>
<p> Integer.  Model validation.  The cex for diagnostic plots. </p>
</td></tr>
<tr><td><code id="model.explore_+3A_rastlutfn">rastLUTfn</code></td>
<td>
<p> String.  The file name (full path or base name with path specified by <code>folder</code>) of a <code>.csv</code> file for a <code>rastLUT</code>. Alternatively, a dataframe containing the same information. The <code>rastLUT</code> must include 3 columns: (1) the full path and name of the raster file; (2) the shortname of each predictor / raster layer (band); (3) the layer (band) number.  The shortname (column 2) must match the names <code>predList</code>, the predictor column names in training/test data set (<code>qdata.trainfn</code> and <code>qdata.testfn</code>, and the predictor names in <code>model.obj</code>. 
</p>
<p>Example of comma-delimited file:
</p>

<table>
<tr>
 <td style="text-align: left;">
	  </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>C:/button_test/tc99_2727subset.img,</code> </td><td style="text-align: left;"> <code>tc99_2727subsetb1,</code> </td><td style="text-align: left;"> <code>1</code></td>
</tr>
<tr>
 <td style="text-align: left;">
	  </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>C:/button_test/tc99_2727subset.img,</code> </td><td style="text-align: left;"> <code>tc99_2727subsetb2,</code> </td><td style="text-align: left;"> <code>2</code></td>
</tr>
<tr>
 <td style="text-align: left;">
	  </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>C:/button_test/tc99_2727subset.img,</code> </td><td style="text-align: left;"> <code>tc99_2727subsetb3,</code> </td><td style="text-align: left;"> <code>3</code></td>
</tr>

</table>
</td></tr>
<tr><td><code id="model.explore_+3A_create.extrapolation.masks">create.extrapolation.masks</code></td>
<td>
<p>Logical.  If <code>TRUE</code> then the raster brick containing the masks for all predictors from <code>predList</code> is saved as image file. The layers in this file will be in the same order as the predictors in <code>predList</code>   </p>
</td></tr>
<tr><td><code id="model.explore_+3A_na.value">na.value</code></td>
<td>
<p>Value used in rasters to indicate <code>NA</code>. Note this value is only used  for <code>NA</code> values in the predictor rasters.  Note: all predictor rasters must use the same value for <code>NA</code>. <code>NA</code> values in the training data should be indicated with <code>NA</code>. </p>
</td></tr>
<tr><td><code id="model.explore_+3A_col.ramp">col.ramp</code></td>
<td>
<p>Color ramp to use for continuous predictors</p>
</td></tr>
<tr><td><code id="model.explore_+3A_col.cat">col.cat</code></td>
<td>
<p>Vector. Vector of colors to use for categorical predictors. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>model.explore</code> function is intended to aid with preliminary data exploration before model building. It includes graphical tools to explore the relationships between the training data (both predictors and responses) as well as the predictor rasters. It uses the <code>corrplot</code> package to create a correlation plot of the continuous predictor. This can aid in interpreting the <code><a href="#topic+model.importance.plot">model.importance.plot</a></code> output from the models, as Random Forest models divide importance between correlated predictors, while Stochastic Gradient Boosting models assing the majority of the importance to the correlated predictor that is used earlies in the model.
</p>
<p>The <code>model.explore</code> function also can aid in identifying if additional training data is needed. For example, the maps of the extrapolation masks for the predictor rasters help spot areas of the map where the pixels lie outside the range of the training data, and therefore any model predictions will be extrapolations, and possibly unreliable. The user can decide to either collect additional training data, or mask out these areas of the final prediction output of <code><a href="#topic+model.mapmake">model.mapmake</a></code>.
</p>
<p>To increase speed, the default behavior for large predictor rasters is to create the graphics from subsampled rasters. (Note: for categorical predictors, the full raster is always used to identify all categories found in the map area.) If <code>create.extrapolation.masks=TRUE</code>, then the full rasters are used for the extrapolation masks, regardless of size of the reasters. This option runs much slower, as large rasters need to be read into R a block at a time.
</p>


<h3>Value</h3>

<p>Function does not return a value, but does create files. 
</p>
<p>Graphical files are created for each predictor variable, with file type determined by <code>device.type</code>. In addition, if <code>create.extrapolation.masks</code>, an extrapolation mask raster is created for each predictor as well as an overall extrapolation mask, with the value <code>1</code> for pixels with predictor values within the range of the training data, or categories found in the training data, and the value <code>0</code> for pixels outside the range of the training data, categories not found in the training data, or NA value. The overall extrapolation mask has <code>0</code> if any of the predictors for that pixel are extrapolated. Note that this option is much slower to run.
</p>


<h3>Note</h3>

<p>The default graphics device is disabled unless <code>allow.default.graphics</code> is set to <code>TRUE</code>. These graphics can be slow to produce, and if the on screen graphics device is moved or closed while the graphic is in progress, it can crash R. It is recomended that graphics be written to a file by using jpeg, pdf, etc... <code>device.type</code>.
</p>


<h3>Author(s)</h3>

<p>Elizabeth Freeman</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

###########################################################################
############################# Run this set up code: #######################
###########################################################################

###Define training and test files:
qdata.trainfn = system.file("extdata", "helpexamples","DATATRAIN.csv", package = "ModelMap")

###Define folder for all output:
folder=getwd()	

###identifier for individual training and test data points
unique.rowname="ID"			

###predictors:
predList=c("TCB","TCG","TCW","NLCD")

###define which predictors are categorical:
predFactor=c("NLCD")

###Create a the filename (including path) for the rast Look up Tables ###
rastLUTfn.2001 &lt;- system.file(	"extdata",
				"helpexamples",
				"LUT_2001.csv",
				package="ModelMap")

###Load rast LUT table, and add path to the predictor raster filenames in column 1 ###
rastLUT.2001 &lt;- read.table(rastLUTfn.2001,header=FALSE,sep=",",stringsAsFactors=FALSE)

for(i in 1:nrow(rastLUT.2001)){
	rastLUT.2001[i,1] &lt;- system.file("extdata",
					"helpexamples",
					rastLUT.2001[i,1],
					package="ModelMap")
}                                 

#################Continuous Response###################

###Response name and type:
response.name="BIO"
response.type="continuous"

###file name to store model:
OUTPUTfn="BIO_TCandNLCD.img"

###run model.explore

model.explore(	qdata.trainfn=qdata.trainfn,
		folder=folder,		
		predList=predList,
		predFactor=predFactor,

		response.name=response.name,
		response.type=response.type,
	
		unique.rowname=unique.rowname,

		OUTPUTfn=OUTPUTfn,
		device.type="jpeg",
		jpeg.res=144,


		# Raster arguments
		rastLUTfn=rastLUT.2001,
		na.value=-9999,

		# colors for continuous predictors
		col.ramp=rainbow(101,start=0,end=.5), 
		# colors for categorical predictors
		col.cat=c("wheat1","springgreen2","darkolivegreen4",
			  "darkolivegreen2","yellow","thistle2",
			  "brown2","brown4")
)

## End(Not run) # end dontrun



</code></pre>

<hr>
<h2 id='model.importance.plot'>Compares the variable importance of two models with a back to back barchart.</h2><span id='topic+model.importance.plot'></span>

<h3>Description</h3>

<p>Takes two models and produces a back to back bar chart to compare the importance of the predictor variables. Models can be any combination of Random Forest or Stochastic Gradient Boosting, as long as both models have the same predictor variables. </p>


<h3>Usage</h3>

<pre><code class='language-R'>model.importance.plot(model.obj.1 = NULL, model.obj.2 = NULL, 
model.name.1 = "Model 1", model.name.2 = "Model 2", imp.type.1 = NULL, 
imp.type.2 = NULL, type.label=TRUE, class.1 = NULL, class.2 = NULL, 
quantile.1=NULL, quantile.2=NULL,
col.1="grey", col.2="black", scale.by = "sum", sort.by = "model.obj.1", 
cf.mincriterion.1 = 0, cf.conditional.1 = FALSE, cf.threshold.1 = 0.2, 
cf.nperm.1 = 1, cf.mincriterion.2 = 0, cf.conditional.2 = FALSE, 
cf.threshold.2 = 0.2, cf.nperm.2 = 1, predList = NULL, folder = NULL, 
PLOTfn = NULL, device.type = NULL, res=NULL, jpeg.res = 72, 
device.width = 7,  device.height = 7, units="in", pointsize=12, 
cex=par()$cex,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.importance.plot_+3A_model.obj.1">model.obj.1</code></td>
<td>
<p><code>R</code> model object. The model object to use for left side of barchart. The model object must be of type <code>"RF"</code> (random forest), <code>"QRF"</code> (quantile random forest), or <code>"CF"</code> (conditional forest). The <code>ModelMap</code> package does not currently support <code>SGB</code> models. The model object must have the exact same predictors as <code>model.obj.2</code>.</p>
</td></tr>
<tr><td><code id="model.importance.plot_+3A_model.obj.2">model.obj.2</code></td>
<td>
<p><code>R</code> model object. The model object to use for right side of barchart. The model object must be of type <code>"RF"</code> (random forest), <code>"QRF"</code> (quantile random forest), or <code>"CF"</code> (conditional forest). The <code>ModelMap</code> package does not currently support <code>SGB</code> models. The model object must have the exact same predictors as <code>model.obj.1</code>.</p>
</td></tr>
<tr><td><code id="model.importance.plot_+3A_model.name.1">model.name.1</code></td>
<td>
<p>String. Label for left side of barchart.</p>
</td></tr>
<tr><td><code id="model.importance.plot_+3A_model.name.2">model.name.2</code></td>
<td>
<p>String. Label for right side of barchart.</p>
</td></tr>
<tr><td><code id="model.importance.plot_+3A_imp.type.1">imp.type.1</code></td>
<td>
<p>Number. Type of importance to use for model 1. Importance type 1 is permutation based, as described in Breiman (2001).  Importance type 2 is model based. For RF models is the decrease in node impurities attributable to each predictor variable. For SGB models, it is the reduction attributable to each variable in predicting the gradient on each iteration. Default for random forest models is <code>imp.type.1 = 1</code>. </p>
</td></tr>
<tr><td><code id="model.importance.plot_+3A_imp.type.2">imp.type.2</code></td>
<td>
<p>Number. Type of importance to use for model 2. Importance type 1 is permutation based, as described in Breiman (2001).  Importance type 2 is model based. For RF models is the decrease in node impurities attributable to each predictor variable. For SGB models, it is the reduction attributable to each variable in predicting the gradient on each iteration. Default for random forest models is <code>imp.type.2 = 1</code>. </p>
</td></tr>
<tr><td><code id="model.importance.plot_+3A_type.label">type.label</code></td>
<td>
<p>Logical. Should axis labels include importance type for each side of plot.</p>
</td></tr>
<tr><td><code id="model.importance.plot_+3A_class.1">class.1</code></td>
<td>
<p>String. For binary and categorical random forest models. If the name a class is specified, the class-specific relative influence is used for plot. If <code>class.1 = NULL</code> overall relative influence used for plot.</p>
</td></tr>
<tr><td><code id="model.importance.plot_+3A_class.2">class.2</code></td>
<td>
<p>String. For binary and categorical random forest models. If the name a class is specified, the class-specific relative influence is used for plot. If <code>class.2 = NULL</code> overall relative influence used for plot.</p>
</td></tr>
<tr><td><code id="model.importance.plot_+3A_quantile.1">quantile.1</code></td>
<td>
<p>Numeric. QRF models. Quantile to use for model 1. Must be one of the quantiles used in building the QRF model.</p>
</td></tr>
<tr><td><code id="model.importance.plot_+3A_quantile.2">quantile.2</code></td>
<td>
<p>Numeric. QRF models. Quantile to use for model 2. Must be one of the quantiles used in building the QRF model.</p>
</td></tr>
<tr><td><code id="model.importance.plot_+3A_col.1">col.1</code></td>
<td>
<p>String. For binary and categorical random forest models. Color to use for bars for model 1. Defaults to grey.</p>
</td></tr>
<tr><td><code id="model.importance.plot_+3A_col.2">col.2</code></td>
<td>
<p>String. For binary and categorical random forest models. Color to use for bars for model 2. Defaults to black.</p>
</td></tr>
<tr><td><code id="model.importance.plot_+3A_scale.by">scale.by</code></td>
<td>
<p>String. Scale by: <code>"max"</code> or <code>"sum"</code>. When <code>scale.by="max"</code> the importance are scaled for each model so that the maximum importance for each model fills the graph. When <code>scale.by="sum"</code>, the importance for each model are scaled to sum to 100.</p>
</td></tr>
<tr><td><code id="model.importance.plot_+3A_sort.by">sort.by</code></td>
<td>
<p>String. Sort by: <code>"model.obj.1"</code>, <code>"model.obj.2"</code>, <code>"predList"</code>. Gives the order to draw the bars for the predictor variables. When <code>sort.by="model.obj.1"</code> the predictors are sorted largest to smallest based on importance from model 1. When <code>sort.by="model.obj.2"</code> the predictors are sorted largest to smallest based on importance from model 2. When <code>sort.by="predList"</code> the predictors are sorted to match the order given in <code>"predList"</code>.</p>
</td></tr>
<tr><td><code id="model.importance.plot_+3A_cf.mincriterion.1">cf.mincriterion.1</code></td>
<td>
<p>Number. CF models. The value of the test statistic or 1 - p-value that must be exceeded in order to include a split in the computation of the importance. The default <code>cf.mincriterion.1 = 0</code> guarantees that all splits are included.</p>
</td></tr>
<tr><td><code id="model.importance.plot_+3A_cf.conditional.1">cf.conditional.1</code></td>
<td>
<p>Logical. CF models. A logical determining whether unconditional or conditional computation of the importance is performed for <code>model.obj.1</code>.</p>
</td></tr>
<tr><td><code id="model.importance.plot_+3A_cf.threshold.1">cf.threshold.1</code></td>
<td>
<p>Number. CF models. The value of the test statistic or 1 - p-value of the association between the variable of interest and a covariate that must be exceeded inorder to include the covariate in the conditioning scheme for the variable of interest (only relevant if <code>conditional = TRUE</code>).</p>
</td></tr>
<tr><td><code id="model.importance.plot_+3A_cf.nperm.1">cf.nperm.1</code></td>
<td>
<p>Number. CF models. The number of permutations performed.</p>
</td></tr>				 
<tr><td><code id="model.importance.plot_+3A_cf.mincriterion.2">cf.mincriterion.2</code></td>
<td>
<p>Number. CF models. The value of the test statistic or 1 - p-value that must be exceeded in order to include a split in the computation of the importance. The default <code>cf.mincriterion.2 = 0</code> guarantees that all splits are included.</p>
</td></tr>
<tr><td><code id="model.importance.plot_+3A_cf.conditional.2">cf.conditional.2</code></td>
<td>
<p>Logical. CF models. A logical determining whether unconditional or conditional computation of the importance is performed for <code>model.obj.2</code>.</p>
</td></tr>
<tr><td><code id="model.importance.plot_+3A_cf.threshold.2">cf.threshold.2</code></td>
<td>
<p>Number. CF models. The value of the test statistic or 1 - p-value of the association between the variable of interest and a covariate that must be exceeded inorder to include the covariate in the conditioning scheme for the variable of interest (only relevant if <code>conditional = TRUE</code>).</p>
</td></tr>
<tr><td><code id="model.importance.plot_+3A_cf.nperm.2">cf.nperm.2</code></td>
<td>
<p>Number. CF models. The number of permutations performed.</p>
</td></tr>					
<tr><td><code id="model.importance.plot_+3A_predlist">predList</code></td>
<td>
<p>String.  A character vector of the predictor short names used to build the models. If <code>sort.by="predList"</code>, then <code>predList</code> is used to specify the order to draw the predictors in the barchart.</p>
</td></tr>
<tr><td><code id="model.importance.plot_+3A_folder">folder</code></td>
<td>
<p> String.  The folder used for all output.  Do not add ending slash to path string.  If <code>folder = NULL</code> (default), a GUI interface prompts user to browse to a folder.  To use the working directory, specify <code>folder = getwd()</code>.</p>
</td></tr>
<tr><td><code id="model.importance.plot_+3A_plotfn">PLOTfn</code></td>
<td>
<p> String.  The file name to use to save the generated graphical plots. If <code>PLOTfn = NULL</code> a default name is generated by pasting <code>model.name.1_model.name.2</code>. The filename can be the full path, or it can be the simple basename, in which case the output will be to the folder specified by <code>folder</code>.</p>
</td></tr>
<tr><td><code id="model.importance.plot_+3A_device.type">device.type</code></td>
<td>
<p> String or vector of strings.  Model validation.  One or more device types for graphical output from model validation diagnostics. 
</p>
<p>Current choices:
</p>

<table>
<tr>
 <td style="text-align: left;">
	  </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>"default"</code> </td><td style="text-align: left;"> default graphics device</td>
</tr>
<tr>
 <td style="text-align: left;">
	  </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>"jpeg"</code> </td><td style="text-align: left;"> *.jpg files</td>
</tr>
<tr>
 <td style="text-align: left;">
	  </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>"none"</code> </td><td style="text-align: left;"> no graphics device generated</td>
</tr>
<tr>
 <td style="text-align: left;">	
	  </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>"pdf"</code> </td><td style="text-align: left;"> *.pdf files</td>
</tr>
<tr>
 <td style="text-align: left;">
	  </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>"png"</code> </td><td style="text-align: left;"> *.png files</td>
</tr>
<tr>
 <td style="text-align: left;">
	  </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>"postscript"</code> </td><td style="text-align: left;"> *.ps files</td>
</tr>
<tr>
 <td style="text-align: left;">
	  </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>"tiff"</code> </td><td style="text-align: left;"> *.tif files </td>
</tr>

</table>

</td></tr>
<tr><td><code id="model.importance.plot_+3A_res">res</code></td>
<td>
<p> Integer.  Model validation.  Pixels per inch for jpeg, png, and tiff plots.  The default is 72dpi, good for on screen viewing. For printing, suggested setting is 300dpi. </p>
</td></tr>
<tr><td><code id="model.importance.plot_+3A_jpeg.res">jpeg.res</code></td>
<td>
<p> Integer.  Model validation.  Deprecated. Ignored unless <code>res</code> not provided. </p>
</td></tr>
<tr><td><code id="model.importance.plot_+3A_device.width">device.width</code></td>
<td>
<p> Integer.  Model validation.  The device width for diagnostic plots in inches. </p>
</td></tr>
<tr><td><code id="model.importance.plot_+3A_device.height">device.height</code></td>
<td>
<p> Integer.  Model validation.  The device height for diagnostic plots in inches. </p>
</td></tr>
<tr><td><code id="model.importance.plot_+3A_units">units</code></td>
<td>
<p> Model validation.  The units in which <code>device.height</code> and <code>device.width</code> are given. Can be <code>"px"</code> (pixels), <code>"in"</code> (inches, the default), <code>"cm"</code> or <code>"mm"</code>. </p>
</td></tr>
<tr><td><code id="model.importance.plot_+3A_pointsize">pointsize</code></td>
<td>
<p> Integer.  Model validation.  The default pointsize of plotted text, interpreted as big points (1/72 inch) at <code>res</code> ppi</p>
</td></tr>
<tr><td><code id="model.importance.plot_+3A_cex">cex</code></td>
<td>
<p> Integer.  Model validation.  The cex for diagnostic plots. </p>
</td></tr>
<tr><td><code id="model.importance.plot_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to methods, such as graphical parameters (see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The importance measures used in this plot depend on the model type (RF verses SGB) and the response type (continuous, categorical, or binary). 
</p>
<p>Importance type 1 is permutation based, as described in Breiman (2001). Importance is calculated by randomly permuting each predictor variable and computing the associated reduction in predictive performance using Out Of Bag error for RF models and training error for SGB models. Note that for SGB models permutation based importance measures are still considered experimental.  Importance type 2 is model based. For RF models, importance type 2 is calculated by the decrease in node impurities attributable to each predictor variable. For SGB models, importance type 2 is the reduction attributable to each variable in predicting the gradient on each iteration as described in described in Friedman (2001). 
</p>
<p>For RF models:
</p>

<table>
<tr>
 <td style="text-align: left;">
	  </td><td style="text-align: left;"> </td><td style="text-align: left;">  <code>response type</code> </td><td style="text-align: center;"> <code>type</code>	</td><td style="text-align: left;">			</td><td style="text-align: left;"> </td><td style="text-align: left;"> Importance Measure </td>
</tr>
<tr>
 <td style="text-align: left;">	
	  </td><td style="text-align: left;"> </td><td style="text-align: left;">  <code>"continuous"</code>  </td><td style="text-align: center;"> <code>1</code>   	</td><td style="text-align: left;"> permutation 	</td><td style="text-align: left;"> </td><td style="text-align: left;"> %IncMSE </td>
</tr>
<tr>
 <td style="text-align: left;">
	  </td><td style="text-align: left;"> </td><td style="text-align: left;">  <code>"binary"</code>      </td><td style="text-align: center;"> <code>1</code>    	</td><td style="text-align: left;"> permutation 	</td><td style="text-align: left;"> </td><td style="text-align: left;"> Mean Decrease Accuracy </td>
</tr>
<tr>
 <td style="text-align: left;">
	  </td><td style="text-align: left;"> </td><td style="text-align: left;">  <code>"categorical"</code> </td><td style="text-align: center;"> <code>1</code>    	</td><td style="text-align: left;"> permutation 	</td><td style="text-align: left;"> </td><td style="text-align: left;"> Mean Decrease Accuracy </td>
</tr>
<tr>
 <td style="text-align: left;">
	  </td><td style="text-align: left;"> </td><td style="text-align: left;">  <code>"continuous"</code>  </td><td style="text-align: center;"> <code>2</code>    	</td><td style="text-align: left;"> node impurity	</td><td style="text-align: left;"> </td><td style="text-align: left;"> Residual sum of squares </td>
</tr>
<tr>
 <td style="text-align: left;">
	  </td><td style="text-align: left;"> </td><td style="text-align: left;">  <code>"binary"</code>      </td><td style="text-align: center;"> <code>2</code>    	</td><td style="text-align: left;"> node impurity	</td><td style="text-align: left;"> </td><td style="text-align: left;"> Mean Decrease Gini </td>
</tr>
<tr>
 <td style="text-align: left;">
	  </td><td style="text-align: left;"> </td><td style="text-align: left;">  <code>"categorical"</code> </td><td style="text-align: center;"> <code>2</code>    	</td><td style="text-align: left;"> node impurity	</td><td style="text-align: left;"> </td><td style="text-align: left;"> Mean Decrease Gini   </td>
</tr>

</table>

<p>For Random Forest models, if <code>imp.type</code> not specified, importance type defaults to <code>imp.type</code> of <code>1</code> - permutation importance. For SGB models, permutation importance is considered experimental so importance defaults to <code>imp.type</code> of <code>2</code> - reduction of gradient of the loss function.
</p>
<p>Also, for binary and categorical Random Forest models, class specific importance plots can be generated by the use of the <code>class</code> argument. Note that class specific importance is only available for Random Forest models with importance type 1.
</p>
<p>For CF models:
</p>

<table>
<tr>
 <td style="text-align: left;">
	  </td><td style="text-align: left;"> </td><td style="text-align: left;">  <code>response type</code> </td><td style="text-align: center;"> <code>type</code>	</td><td style="text-align: left;">			</td><td style="text-align: left;"> </td><td style="text-align: left;"> Importance Measure </td>
</tr>
<tr>
 <td style="text-align: left;">	
	  </td><td style="text-align: left;"> </td><td style="text-align: left;">  <code>"continuous"</code>  </td><td style="text-align: center;"> <code>1</code>   	</td><td style="text-align: left;"> permutation 	</td><td style="text-align: left;"> </td><td style="text-align: left;"> Mean Decrease Accuracy </td>
</tr>
<tr>
 <td style="text-align: left;">
	  </td><td style="text-align: left;"> </td><td style="text-align: left;">  <code>"binary"</code>      </td><td style="text-align: center;"> <code>1</code>    	</td><td style="text-align: left;"> permutation 	</td><td style="text-align: left;"> </td><td style="text-align: left;"> Mean Decrease Accuracy </td>
</tr>
<tr>
 <td style="text-align: left;">
	  </td><td style="text-align: left;"> </td><td style="text-align: left;">  <code>"categorical"</code> </td><td style="text-align: center;"> <code>1</code>    	</td><td style="text-align: left;"> permutation 	</td><td style="text-align: left;"> </td><td style="text-align: left;"> Mean Decrease Accuracy </td>
</tr>
<tr>
 <td style="text-align: left;">
	  </td><td style="text-align: left;"> </td><td style="text-align: left;">  <code>"continuous"</code>  </td><td style="text-align: center;"> <code>2</code>    	</td><td style="text-align: left;"> node impurity	</td><td style="text-align: left;"> </td><td style="text-align: left;"> Not Available </td>
</tr>
<tr>
 <td style="text-align: left;">
	  </td><td style="text-align: left;"> </td><td style="text-align: left;">  <code>"binary"</code>      </td><td style="text-align: center;"> <code>2</code>    	</td><td style="text-align: left;"> node impurity	</td><td style="text-align: left;"> </td><td style="text-align: left;"> Mean Decrease in AUC </td>
</tr>
<tr>
 <td style="text-align: left;">
	  </td><td style="text-align: left;"> </td><td style="text-align: left;">  <code>"categorical"</code> </td><td style="text-align: center;"> <code>2</code>    	</td><td style="text-align: left;"> node impurity	</td><td style="text-align: left;"> </td><td style="text-align: left;"> Not Available   </td>
</tr>

</table>
 
<p>For binary CF models, ifimportance.type = 2, function uses AUC-based variables importances as described by Janitza et al. (2012). Here, the area under the curve instead of the accuracy is used to calculate the importance of each variable. This AUC-based variable importance measure is more robust towards class imbalance. 
</p>
<p>Also, for CF models, if <code>cf.conditional = TRUE</code>, the importance of each variable is computed by permuting within a grid defined by the covariates that are associated (with 1 - p-value greater than threshold) to the variable of interest. The resulting variable importance score is conditional in the sense of beta coefficients in regression models, but represents the effect of a variable in both main effects and interactions. See Strobl et al. (2008) for details. Conditional improtance can be slow for large datasets.
</p>


<h3>Value</h3>

<p>The function returns a two element list: <code>IMP1</code> is the variable importance for <code>model.obj.1</code>; and, <code>IMP2</code> is the variable importance for <code>model.obj.2</code>. This is mostly intended for CF models, where calculating the conditional importance can represent a considerable time investment. For other model types it would be just as easy to recalcuate importances on the fly as needed.
</p>


<h3>Note</h3>

<p>Importance currently unavailable for QRF models.</p>


<h3>Author(s)</h3>

<p>Elizabeth Freeman</p>


<h3>References</h3>

<p>Breiman, L. (2001) Random Forests. Machine Learning, 45:5-32.
</p>
<p>Alexander Hapfelmeier, Torsten Hothorn, Kurt Ulm, and Carolin Strobl (2012). A New Variable Importance Measure for Random Forests with Missing Data. Statistics and Computing, http://dx.doi.org/10.1007/s11222-012-9349-1 
</p>
<p>Torsten Hothorn, Kurt Hornik, and Achim Zeileis (2006b). Unbiased Recursive Partitioning: A Conditional Inference Framework. Journal of Computational and Graphical Statistics, 15 (3), 651-674. Preprint available from http://statmath.wu-wien.ac.at/~zeileis/papers/Hothorn+Hornik+Zeileis-2006.pdf 
</p>
<p>Silke Janitza, Carolin Strobl and Anne-Laure Boulesteix (2013). An AUC-based Permutation Variable Importance Measure for Random Forests. BMC Bioinformatics.2013, 14 119. http://www.biomedcentral.com/1471-2105/14/119 
</p>
<p>Carolin Strobl, Anne-Laure Boulesteix, Thomas Kneib, Thomas Augustin, and Achim Zeileis (2008). Conditional Variable Importance for Random Forests. BMC Bioinformatics, 9, 307. http://www.biomedcentral.com/1471-2105/9/307
</p>


<h3>See Also</h3>

<p><code><a href="#topic+model.build">model.build</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

###########################################################################
############################# Run this set up code: #######################
###########################################################################

# set seed:
seed=38

# Define training and test files:

qdata.trainfn = system.file("extdata", "helpexamples","DATATRAIN.csv", package = "ModelMap")

# Define folder for all output:
folder=getwd()	


#identifier for individual training and test data points

unique.rowname="ID"

##################################################################
########## Continuous Response, Continuous Predictors ############
##################################################################

#file names:
MODELfn.RF="RF_Bio_TC"				

#predictors:
predList=c("TCB","TCG","TCW")	

#define which predictors are categorical:
predFactor=FALSE	

# Response name and type:
response.name="BIO"
response.type="continuous"

########## Build Models #################################

model.obj.RF = model.build( model.type="RF",
                       qdata.trainfn=qdata.trainfn,
                       folder=folder,		
                       unique.rowname=unique.rowname,		
                       MODELfn=MODELfn.RF,
                       predList=predList,
                       predFactor=predFactor,
                       response.name=response.name,
                       response.type=response.type,
                       seed=seed
)

########## Make Imortance Plot - RF Importance type 1 vs 2 #######

model.importance.plot(	model.obj.1=model.obj.RF, 
			model.obj.2=model.obj.RF, 
			model.name.1="PercentIncMSE", 
			model.name.2="IncNodePurity",
			imp.type.1=1,
			imp.type.2=2,
			scale.by="sum",
			sort.by="predList", 
			predList=predList,
			main="Imp type 1 vs Imp type 2",
			device.type="default")


##################################################################
########## Categorical Response, Continuous Predictors ###########
##################################################################

file name:
MODELfn="RF_NLCD_TC"				

predictors:
predList=c("TCB","TCG","TCW")	

define which predictors are categorical:
predFactor=FALSE	

 Response name and type:
response.name="NLCD"
response.type="categorical"

########## Build Model #################################

model.obj.NLCD = model.build( model.type="RF",
                       qdata.trainfn=qdata.trainfn,
                       folder=folder,		
                       unique.rowname=unique.rowname,	
                       MODELfn=MODELfn,
                       predList=predList,
                       predFactor=predFactor,
                       response.name=response.name,
                       response.type=response.type,
                       seed=seed)

############## Make Imortance Plot ###################

model.importance.plot(	model.obj.1=model.obj.NLCD, 
			model.obj.2=model.obj.NLCD, 
			model.name.1="NLCD=41", 
			model.name.2="NLCD=42",
			class.1="41",
			class.2="42",
			scale.by="sum",
			sort.by="predList", 
			predList=predList,
			main="Class 41 vs. Class 42",
			device.type="default")


##################################################################
############## Conditonal inference forest models ################
##################################################################

#predictors:
predList=c("TCB","TCG","TCW","NLCD")

#define which predictors are categorical:
predFactor=c("NLCD")

#binary response
response.name="CONIFTYP"
response.type="binary"
MODELfn.CF="CF_CONIFTYP_TCandNLCD"

####################### Build Model ##############################

model.obj.CF = model.build( model.type="CF",
                       qdata.trainfn=qdata.trainfn,
                       folder=folder,		
                       unique.rowname=unique.rowname,		
                       MODELfn=MODELfn.CF,
                       predList=predList,
                       predFactor=predFactor,
                       response.name=response.name,
                       response.type=response.type,
                       seed=seed
)

################## Make Imortance Plot ##########################

#Conditional vs. Unconditional importance#

model.importance.plot(	model.obj.1=model.obj.CF, 
			model.obj.2=model.obj.CF, 
			model.name.1="conditional",
			model.name.2="unconditional",
			imp.type.1=1,
			imp.type.2=1, 
			cf.conditional.1=TRUE,
			cf.conditional.2=FALSE,
			scale.by="sum",
			sort.by="predList", 
			predList=predList,
			main="Conditional verses Unconditional",
			device.type="default"
)


## End(Not run) # end dontrun

</code></pre>

<hr>
<h2 id='model.interaction.plot'>
plot of two-way model interactions
</h2><span id='topic+model.interaction.plot'></span>

<h3>Description</h3>

<p>Image or Perspective plot of two-way model interactions. Ranges of two specified predictor variables are plotted on X and Y axis, and fitted model values are plotted on the Z axis. The remaining predictor variables are fixed at their mean (for continuous predictors) or their most common value (for categorical predictors).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model.interaction.plot(model.obj = NULL, x = NULL, y = NULL, 
response.category=NULL, quantiles=NULL, all=FALSE, obs=1, qdata.trainfn = NULL, 
folder = NULL, MODELfn = NULL,  PLOTfn = NULL, pred.means = NULL, 
xlab = NULL, ylab = NULL, x.range = NULL, y.range = NULL, 
z.range = NULL, ticktype = "detailed", theta = 55, phi = 40, 
smooth = "none", plot.type = NULL, device.type = NULL, 
res=NULL, jpeg.res = 72, device.width = 7,  device.height = 7, 
units="in", pointsize=12, cex=par()$cex, 
col = NULL, xlim = NULL, ylim = NULL, zlim = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.interaction.plot_+3A_model.obj">model.obj</code></td>
<td>
 <p><code>R</code> model object.  The model object to use for prediction.  The model object must be of type <code>"RF"</code> (random forest), <code>"QRF"</code> (quantile random forest), or <code>"CF"</code> (conditional forest). The <code>ModelMap</code> package does not currently support <code>SGB</code> models. </p>
</td></tr>
<tr><td><code id="model.interaction.plot_+3A_x">x</code></td>
<td>
<p>String or Integer. Name of predictor variable to be plotted on the x axis. Alternativly, can be a number indicating a variable name from <code>predList</code>.</p>
</td></tr>
<tr><td><code id="model.interaction.plot_+3A_y">y</code></td>
<td>
<p>String or Integer. Name of predictor variable to be plotted on the y axis. Alternatively, can be a number indicating a variable name from <code>predList</code>.</p>
</td></tr>
<tr><td><code id="model.interaction.plot_+3A_response.category">response.category</code></td>
<td>
<p>String. Used for categorical response models. Specify which category of response variable to use. This category's probabilities will be plotted on the z axis.</p>
</td></tr>
<tr><td><code id="model.interaction.plot_+3A_quantiles">quantiles</code></td>
<td>
<p>Numeric. Used for QRF models. Specify which quantile of response variable to use. This quantile will be plotted on the z axis. Note: unlike other functions <code>model.interaction.plot</code> will only use a single quantile. If <code>quantiles</code> is a vector only the first value will be used.</p>
</td></tr>
<tr><td><code id="model.interaction.plot_+3A_all">all</code></td>
<td>
<p>Logical. Used for QRF models. A logical value. <code>all=TRUE</code> uses all observations for prediction. <code>all=FALSE</code> uses only a certain number of observations per node for prediction (set with argument <code>obs</code>). The default is <code>all=FALSE</code>.</p>
</td></tr>
<tr><td><code id="model.interaction.plot_+3A_obs">obs</code></td>
<td>
<p>Numeric. Used for QRF models. An integer number. Determines the maximal number of observations per node to use for prediction. The input is ignored for all=TRUE. The default is obs=1.</p>
</td></tr>
<tr><td><code id="model.interaction.plot_+3A_qdata.trainfn">qdata.trainfn</code></td>
<td>
<p>String.  The name (full path or base name with path specified by <code>folder</code>) of the training data file used for building the model (file should include columns for both response and predictor variables).  The file must be a comma-delimited file <code>*.csv</code> with column headings. <code>qdata.trainfn</code> can also be an <code>R</code> dataframe. If predictions will be made (<code>predict = TRUE</code> or <code>map=TRUE</code>) the predictor column headers must match the names of the raster layer files, or a <code>rastLUT</code> must be provided to match predictor columns to the appropriate raster and band.  If <code>qdata.trainfn = NULL</code> (the default), a GUI interface prompts user to browse to the training data file.  </p>
</td></tr>
<tr><td><code id="model.interaction.plot_+3A_folder">folder</code></td>
<td>
<p> String.  The folder used for all output.  Do not add ending slash to path string.  If <code>folder = NULL</code> (default), a GUI interface prompts user to browse to a folder.  To use the working directory, specify <code>folder = getwd()</code>.</p>
</td></tr>
<tr><td><code id="model.interaction.plot_+3A_modelfn">MODELfn</code></td>
<td>
<p> String.  The file name used to save the generated model object, only used if <code>PLOTfn = NULL</code>.  If <code>MODELfn</code> is supplied and If <code>PLOTfn = NULL</code>, a graphical file name is generated by pasting <code>MODELfn_plot.type_x.name_y.name</code>. If <code>PLOTfn = NULL</code> and <code>MODELfn = NULL</code>, a default name is generated by pasting <code>model.type_response.type_response.name_plot.type_x.name_y.name</code>. The filename can be the full path, or it can be the simple basename, in which case the output will be to the folder specified by <code>folder</code>.</p>
</td></tr>
<tr><td><code id="model.interaction.plot_+3A_plotfn">PLOTfn</code></td>
<td>
<p> String.  The file name to use to save the generated graphical plots. The filename can be the full path, or it can be the simple basename, in which case the output will be to the folder specified by <code>folder</code>.</p>
</td></tr>
<tr><td><code id="model.interaction.plot_+3A_pred.means">pred.means</code></td>
<td>
<p>Vector. Allows specification of values for other predictor variables. If Null, other predictors are set to their mean value (for continuous predictors) or their most common value (for factored predictors).</p>
</td></tr>
<tr><td><code id="model.interaction.plot_+3A_xlab">xlab</code></td>
<td>
<p>String. Allows manual specification of the x label.</p>
</td></tr>
<tr><td><code id="model.interaction.plot_+3A_ylab">ylab</code></td>
<td>
<p>String. Allows manual specification of the y label.</p>
</td></tr>
<tr><td><code id="model.interaction.plot_+3A_x.range">x.range</code></td>
<td>
<p>Vector. Manual range specification for the x axis. Alternate argument name for <code>xlim</code>. Use one or the other. Do not provide both <code>x.range</code> and <code>xlim</code>.</p>
</td></tr>
<tr><td><code id="model.interaction.plot_+3A_y.range">y.range</code></td>
<td>
<p>Vector. Manual range specification for the y axis. Alternate argument name for <code>ylim</code>. Use one or the other. Do not provide both <code>y.range</code> and <code>ylim</code>.</p>
</td></tr>
<tr><td><code id="model.interaction.plot_+3A_z.range">z.range</code></td>
<td>
<p>Vector. Manual range specification for the z axis. Alternate argument name for <code>zlim</code>. Use one or the other. Do not provide both <code>z.range</code> and <code>zlim</code>.</p>
</td></tr>
<tr><td><code id="model.interaction.plot_+3A_ticktype">ticktype</code></td>
<td>
<p>Character: &quot;simple&quot; draws just an arrow parallel to the axis to indicate direction of increase; &quot;detailed&quot; (default) draws normal ticks as per 2D plots. If <code>X</code> or <code>y</code> is factored, ticks will be drawn on both axes.</p>
</td></tr>
<tr><td><code id="model.interaction.plot_+3A_theta">theta</code></td>
<td>
<p>Numeric. Angles defining the viewing direction. <code>theta</code> gives the azimuthal direction.</p>
</td></tr>
<tr><td><code id="model.interaction.plot_+3A_phi">phi</code></td>
<td>
<p>Numeric. Angles defining the viewing direction. <code>phi</code> gives the colatitude.</p>
</td></tr>
<tr><td><code id="model.interaction.plot_+3A_smooth">smooth</code></td>
<td>
<p>String. controls smoothing of the predicted surface. Options are <code>"none"</code> (default), <code>"model"</code> which uses a glm model to smooth the surface, and <code>"average"</code> which applies a 3x3 smoothing average. Note: smoothing is not appropriate if <code>X</code> or <code>y</code> is factored.</p>
</td></tr>
<tr><td><code id="model.interaction.plot_+3A_plot.type">plot.type</code></td>
<td>
<p>Character. <code>"persp"</code> gives a 3-D perspective plot. <code>"image"</code> gives an image plot.</p>
</td></tr>
<tr><td><code id="model.interaction.plot_+3A_device.type">device.type</code></td>
<td>
<p> String or vector of strings.  Model validation.  One or more device types for graphical output from model validation diagnostics. 
</p>
<p>Current choices:
</p>

<table>
<tr>
 <td style="text-align: left;">
	  </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>"default"</code> </td><td style="text-align: left;"> default graphics device</td>
</tr>
<tr>
 <td style="text-align: left;">
	  </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>"jpeg"</code> </td><td style="text-align: left;"> *.jpg files</td>
</tr>
<tr>
 <td style="text-align: left;">
	  </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>"none"</code> </td><td style="text-align: left;"> no graphics device generated</td>
</tr>
<tr>
 <td style="text-align: left;">	
	  </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>"pdf"</code> </td><td style="text-align: left;"> *.pdf files</td>
</tr>
<tr>
 <td style="text-align: left;">
	  </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>"postscript"</code> </td><td style="text-align: left;"> *.ps files</td>
</tr>
<tr>
 <td style="text-align: left;">
	  </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>"win.metafile"</code> </td><td style="text-align: left;"> *.emf files </td>
</tr>

</table>

</td></tr>
<tr><td><code id="model.interaction.plot_+3A_res">res</code></td>
<td>
<p> Integer.  Model validation.  Pixels per inch for jpeg, png, and tiff plots.  The default is 72dpi, good for on screen viewing. For printing, suggested setting is 300dpi. </p>
</td></tr>
<tr><td><code id="model.interaction.plot_+3A_jpeg.res">jpeg.res</code></td>
<td>
<p> Integer.  Model validation.  Deprecated. Ignored unless <code>res</code> not provided. </p>
</td></tr>
<tr><td><code id="model.interaction.plot_+3A_device.width">device.width</code></td>
<td>
<p> Integer.  Model validation.  The device width for diagnostic plots in inches. </p>
</td></tr>
<tr><td><code id="model.interaction.plot_+3A_device.height">device.height</code></td>
<td>
<p> Integer.  Model validation.  The device height for diagnostic plots in inches. </p>
</td></tr>
<tr><td><code id="model.interaction.plot_+3A_units">units</code></td>
<td>
<p> Model validation.  The units in which <code>device.height</code> and <code>device.width</code> are given. Can be <code>"px"</code> (pixels), <code>"in"</code> (inches, the default), <code>"cm"</code> or <code>"mm"</code>. </p>
</td></tr>
<tr><td><code id="model.interaction.plot_+3A_pointsize">pointsize</code></td>
<td>
<p> Integer.  Model validation.  The default pointsize of plotted text, interpreted as big points (1/72 inch) at <code>res</code> ppi</p>
</td></tr>
<tr><td><code id="model.interaction.plot_+3A_cex">cex</code></td>
<td>
<p> Integer.  Model validation.  The cex for diagnostic plots. </p>
</td></tr>
<tr><td><code id="model.interaction.plot_+3A_col">col</code></td>
<td>
<p> Vector.  Color table to use for image plots ( see help file on image for details). </p>
</td></tr>
<tr><td><code id="model.interaction.plot_+3A_xlim">xlim</code></td>
<td>
<p>Vector. X limits. Alternate argument name for <code>x.range</code>. Use one or the other. Do not provide both <code>x.range</code> and <code>xlim</code>.</p>
</td></tr>
<tr><td><code id="model.interaction.plot_+3A_ylim">ylim</code></td>
<td>
<p>Vector. Y limits. Alternate argument name for <code>y.range</code>. Use one or the other. Do not provide both <code>y.range</code> and <code>ylim</code>.</p>
</td></tr>
<tr><td><code id="model.interaction.plot_+3A_zlim">zlim</code></td>
<td>
<p>Vector. Z limits. Alternate argument name for <code>z.range</code>. Use one or the other. Do not provide both <code>z.range</code> and <code>zlim</code>.</p>
</td></tr>
<tr><td><code id="model.interaction.plot_+3A_...">...</code></td>
<td>
<p>additional graphical parameters (see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides a diagnostic plot useful in visualizing two-way interactions between predictor variables. Two of the predictor variables from the model are used to produce a grid of possible combinations of predictor values over the range of both variables. The remaining predictor variables from the model are fixed at either their means (for continuous predictors) or their most common value (for categorical predictors). Model predictions are generated over this grid and plotted as the z axis.
</p>
<p>This function works with both continuous and categorical predictors, though the perspective plot should be interpreted with care for categorical predictors. In particular, the <code>smooth</code> option is not appropriate if either of the two selected predictor variables is categorical.
</p>
<p>For categorical response models, a particular value must be specified for the response using the <code>response.category</code> argument. 
</p>


<h3>Author(s)</h3>

<p> Elizabeth Freeman </p>


<h3>References</h3>

<p>This function is adapted from <code>gbm.perspec</code> version 2.9 April 2007, J Leathwick/J Elith. See appendix S3 from:
</p>
<p>Elith, J., Leathwick, J. R. and Hastie, T. (2008). A working guide to boosted regression trees. Journal of Animal Ecology. 77:802-813.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

###########################################################################
############################# Run this set up code: #######################
###########################################################################

# set seed:
seed=38

# Define training and test files:

qdata.trainfn = system.file("extdata", "helpexamples","DATATRAIN.csv", package = "ModelMap")
qdata.testfn = system.file("extdata", "helpexamples","DATATEST.csv", package = "ModelMap")

# Define folder for all output:
folder=getwd()	

########## Continuous Response, Categorical Predictors ############


#file name to store model:
MODELfn="RF_BIO_TCandNLCD"			

#predictors:
predList=c("TCB","TCG","TCW","NLCD")

#define which predictors are categorical:
predFactor=c("NLCD")

# Response name and type:
response.name="BIO"
response.type="continuous"

#identifier for individual training and test data points

unique.rowname="ID"


###########################################################################
########################### build model: ##################################
###########################################################################


### create model ###

model.obj = model.build( model.type="RF",
                       qdata.trainfn=qdata.trainfn,
                       folder=folder,		
                       unique.rowname=unique.rowname,		
                       MODELfn=MODELfn,
                       predList=predList,
                       predFactor=predFactor,
                       response.name=response.name,
                       response.type=response.type,
                       seed=seed,
                       na.action=na.roughfix
)

###########################################################################
###################### make interaction plots: ############################
###########################################################################

#########################
### Perspective Plots ###
#########################


### specify first and third  predictors in 'predList (both continuous) ###

model.interaction.plot(	model.obj,
			x=1,y=3, 
			main=response.name, 
			plot.type="persp", 
			device.type="default") 


### specify predictors in 'predList' by name (one continuous one factored) ###

model.interaction.plot(model.obj,
			x="TCB", y="NLCD", 
			main=response.name, 
			plot.type="persp", 
			device.type="default") 


###################
### Image Plots ###
###################

### same as previous example, but image plot ###


l &lt;- seq(100,0,length.out=101)
c &lt;- seq(0,100,length.out=101)
col.ramp &lt;- hcl(h = 120, c = c, l = l)
 

model.interaction.plot(	model.obj,
				x="TCB", y="NLCD",
				main=response.name,
				plot.type="image", 
				device.type="default",
				col = col.ramp) 


#########################
### 3-way Interaction ###
#########################

### use 'pred.means' argument to fix values of additional predictors ###

### factored 3rd predictor ###

interaction between TCG and TCW for 3 most common values of NLCD

nlcd&lt;-levels(model.obj$predictor.data$NLCD)
nlcd.counts&lt;-table(model.obj$predictor.data$NLCD)
nlcd.ordered&lt;-nlcd[order(nlcd.counts,decreasing=TRUE)]

for(i in nlcd.ordered[1:3]){
	pred.means=list(NLCD=i)

	model.interaction.plot(	model.obj,
				x="TCG", y="TCW",  
				main=paste("NLCD=",i," (",nlcd.counts[i]," plots)", sep=""),
				pred.means=pred.means, 
				z.range=c(0,110),
				theta=290,
				plot.type="persp", 
				device.type="default") 
}



### continuos 3rd predictor ###


tcb&lt;-seq(	min(model.obj$predictor.data$TCB),
		max(model.obj$predictor.data$TCB),
		length=3)

tcb&lt;-signif(tcb,2)

for(i in tcb){
	pred.means=list(TCB=i)

	model.interaction.plot(	model.obj,
				x="TCG", y="TCW",  
				main=paste("TCB =",i),
				pred.means=pred.means, 
				z.range=c(0,120),
				theta=290,
				plot.type="persp", 
				device.type="default") 
}



### 4-way Interesting combos ###


tcb=c(1300,2900,3400)
nlcd=c(11,90,95)

for(i in 1:3){
	pred.means=list(TCB=tcb[i],NLCD=nlcd[i])

	model.interaction.plot(	model.obj,
				x="TCG", y="TCW",  
				main=paste("TCB =",tcb[i],"        NLCD =",nlcd[i]),
				pred.means=pred.means, 
				z.range=c(0,120),
				theta=290,
				plot.type="persp", 
				device.type="default") 
}

## End(Not run) #end dontrun

</code></pre>

<hr>
<h2 id='model.mapmake'> Map Making </h2><span id='topic+model.mapmake'></span>

<h3>Description</h3>

<p>Applies models to either ERDAS Imagine image (.img) files or ESRI Grids of predictors to create detailed prediction surfaces.  It will handle large predictor files for map making, by reading in the <code>.img</code> files in rows, and output to the <code>.img</code> file the prediction for each data row, before reading the next row of data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model.mapmake(model.obj= NULL, folder = NULL, MODELfn = NULL, 
rastLUTfn = NULL, na.action = NULL, na.value=-9999, keep.predictor.brick=FALSE, 
map.sd = FALSE, OUTPUTfn = NULL, quantiles=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.mapmake_+3A_model.obj">model.obj</code></td>
<td>
 <p><code>R</code> model object.  The model object to use for prediction.  The model object must be of type <code>"RF"</code> (random forest), <code>"QRF"</code> (quantile random forest), or <code>"CF"</code> (conditional forest). The <code>ModelMap</code> package does not currently support <code>SGB</code> models. </p>
</td></tr>
<tr><td><code id="model.mapmake_+3A_folder">folder</code></td>
<td>
<p> String.  The folder used for all output from predictions and/or maps.  Do not add ending slash to path string.  If <code>folder = NULL</code> (default), a GUI interface prompts user to browse to a folder.  To use the working directory, specify <code>folder = getwd()</code>.</p>
</td></tr>
<tr><td><code id="model.mapmake_+3A_modelfn">MODELfn</code></td>
<td>
<p> String.  The file name to use to save the generated model object.  If <code>MODELfn = NULL</code> (the default), a default name is generated by pasting <code>model.type_response.type_response.name</code>. If the other output filenames are left unspecified, <code>MODELfn</code> will be used as the basic name to generate other output filenames. The filename can be the full path, or it can be the simple basename, in which case the output will be to the folder specified by <code>folder</code>.</p>
</td></tr>
<tr><td><code id="model.mapmake_+3A_rastlutfn">rastLUTfn</code></td>
<td>
<p> String.  The file name (full path or base name with path specified by <code>folder</code>) of a <code>.csv</code> file for a <code>rastLUT</code>. Alternatively, a dataframe containing the same information. The <code>rastLUT</code> must include 3 columns: (1) the full path and name of the raster file; (2) the shortname of each predictor / raster layer (band); (3) the layer (band) number.  The shortname (column 2) must match the names <code>predList</code>, the predictor column names in training/test data set (<code>qdata.trainfn</code> and <code>qdata.testfn</code>, and the predictor names in <code>model.obj</code>. 
</p>
<p>Example of comma-delimited file:
</p>

<table>
<tr>
 <td style="text-align: left;">
	  </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>C:/button_test/tc99_2727subset.img,</code> </td><td style="text-align: left;"> <code>tc99_2727subsetb1,</code> </td><td style="text-align: left;"> <code>1</code></td>
</tr>
<tr>
 <td style="text-align: left;">
	  </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>C:/button_test/tc99_2727subset.img,</code> </td><td style="text-align: left;"> <code>tc99_2727subsetb2,</code> </td><td style="text-align: left;"> <code>2</code></td>
</tr>
<tr>
 <td style="text-align: left;">
	  </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>C:/button_test/tc99_2727subset.img,</code> </td><td style="text-align: left;"> <code>tc99_2727subsetb3,</code> </td><td style="text-align: left;"> <code>3</code></td>
</tr>

</table>
</td></tr>
<tr><td><code id="model.mapmake_+3A_na.action">na.action</code></td>
<td>
<p>String.  Model validation.  Specifies the action to take if there are <code>NA</code> values in the prediction data or if there is a level or class of a categorical predictor variable in the validation test set or the production (mapping) data set, but not in the training data set.  Currently, the only supported option for map making is <code>na.action = "na.omit"</code> (the default) where any data point or pixel with any new levels for any of the factored predictors is returned as <code>NA</code> (<code>na.value</code>, defaults to <code>-9999</code>).   </p>
</td></tr>
<tr><td><code id="model.mapmake_+3A_na.value">na.value</code></td>
<td>
<p>Number. Value that indicates <code>NA</code> in the predictor rasters. Defaults to <code>-9999</code>. Note: all predictor rasters must use the same value for <code>NA</code>. </p>
</td></tr>
<tr><td><code id="model.mapmake_+3A_keep.predictor.brick">keep.predictor.brick</code></td>
<td>
<p>Logical.  Map Production. If <code>TRUE</code> then the raster brick containing the predictors from the model object is saved as a native raster package format file. If <code>FALSE</code> a temporary brick is created and then deleted at the end of map production.   </p>
</td></tr>
<tr><td><code id="model.mapmake_+3A_map.sd">map.sd</code></td>
<td>
<p> Logical.  Map Production.  If <code>map.sd = TRUE</code>, maps of mean, standard deviation, and coefficient of variation of the predictions from all the trees are generated for each pixel.  If <code>map.sd = FALSE</code> (the default), only the predicted probability map will be built. 
</p>
<p>This option is only available if the <code>model.type = "RF"</code> and the <code>response.type = "continuous"</code>.  Note: This option requires much more available memory.
</p>
<p>The names of the additional maps default to: 
</p>

<table>
<tr>
 <td style="text-align: left;">
	  </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>folder/model.type_response.type_response.name_mean.img</code>  </td>
</tr>
<tr>
 <td style="text-align: left;">
	  </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>folder/model.type_response.type_response.name_stdev.img</code>  </td>
</tr>
<tr>
 <td style="text-align: left;">
	  </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>folder/model.type_response.type_response.name_coefv.img</code> </td>
</tr>

</table>

</td></tr>
<tr><td><code id="model.mapmake_+3A_outputfn">OUTPUTfn</code></td>
<td>
<p> String.  Map Production.  Filename of output file for map production.  The filename can be the full path, or it can be the simple basename, in which case the output will be to the folder specified by <code>folder</code>. If <code>OUTPUTfn = NULL</code> (the default), a name is created by pasting <code>modelfn</code> and <code>"_map"</code>. 
</p>
<p>The <code>raster</code> package uses the filename extension to determine the output format of the map object. See  the <code>raster</code> package function <code><a href="raster.html#topic+writeFormats">writeFormats</a></code> for a list of valid write formats. Because of this, only use the <code>"."</code> in output filenames if it is indicating a valid file extension.
</p>
<p>If the output filename does not include an extension, the default extension of <code>".img"</code> will be added.
</p>
<p>For continuous random forest models with <code>map.sd = TRUE</code> then <code>OUTPUTfn</code> is also used to create output file names for maps of the mean, standard deviation and coeficient of variation of all the trees predictions for each pixel.</p>
</td></tr>
<tr><td><code id="model.mapmake_+3A_quantiles">quantiles</code></td>
<td>
<p> Numeric Vector.  QRF models.  The quantiles to predict. A numeric vector with values between zero and one. The quantile map output will be a multilayer raster with one layer for each quantile. If <code>model.obj</code> was created with the <code>ModelMap</code> package, there will also be a single layer outputraster giving the ordinary RF mean predicted values. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>model.mapmake()</code> can be run in a traditional R command mode, where all arguments are specified in the function call.  However it can also be used in a full push button mode, where you type in the simple command <code>model.mapmake()</code>, and GUI pop up windows will ask questions about the type of model, the file locations of the data, etc...
</p>
<p>When running <code>model.mapmake()</code> on non-Windows platforms, file names and folders need to be specified in the argument list, but other pushbutton selections are handled by the <code>select.list()</code> function, which is platform independent. 
</p>
<p>The R package <code>raster</code> is used to read spatial rasters into R. The data for production mapping should be in the form of pixel-based raster layers representing the predictors in the model. If there is more than one predictor or raster layer, the layers must all have the same number of columns and rows. The layers must also have the same extent, projection, and pixel size, for effective model development and accuracy. The <code>raster</code> package function <code>compareRaster()</code> is used to check predictor layers for consistency. 
</p>
<p>The layers must also be in (single or multi-band) raster data formats that can be read by package <code>raster</code>, for example ESRI Grid or ERDAS Imagine image files. The predictor layers must have continuous or categorical data values. See <code><a href="raster.html#topic+writeRaster">writeRaster</a></code> for a list of available formats.
</p>
<p>To improve processing speed, the <code>raster</code> package is used to create a raster brick object with a layer for each predictor in the model. By default, this brick is a temporary file that is automatically deleated as soon as the map is completed. If <code>keep.predictor.brick=TRUE</code>, the predictor brick with be saved as a native <code>raster</code> package file, with a file name created by appending <code>'_brick'</code> to the <code>OUTPUTfn</code>. Warning: these bricks can be quite large, as they contain all the predictor data for every pixel in the map.
</p>
<p>When creating maps of non-rectangular study regions there may be large portions of the rectangle where you have no predictors, and are uninterested in making predictions. The suggested value for the pixels outside the study area is <code>-9999</code>. These pixels will be ignored in the predictions, thus saving computing time. 
</p>
<p>The function <code>model.mapmake()</code> outputs an rater file of map information suitable to be imported into a GIS. Maps can also be imported back into R using the function <code>raster()</code> from the <code>raster</code> package. The file extension of <code>OUTPUTfn</code> determines the write format. If <code>OUTPUTfn</code> does not include a file extension, output will default to an ERDAS Imagine image file with extension <code>".img"</code>
</p>
<p>For Binary response models the output is in the form of predicted probability of presence for each pixel. For Continuous response models the output is the predicted value for each pixel. For Categorical response models the map output depends on the category labels. If the categorical response variable is numeric, the map output will use the original numeric categories. If the categories are non-numeric (for example, character strings), map output is in the form of integer class codes for each pixel, coded for each level of the factored response, and a CSV file containing a look up table is also generated to associate the integer codes with the original values of the response categories. 
</p>
<p>The first predictor from <code>predList</code> is used to determine projection of output Imagine Image file.
</p>


<h3>Value</h3>

<p>The <code>model.mapmake()</code> function does not return a value, instead it writes a raster file of map information (suitable for importing into a GIS) to the specified folder. The output raster is saved in the format specifed by the file extension of <code>OUTPUTfn</code>
</p>
<p>The <code>model.mapmake()</code> function also writes a text file listing the projections of all predictor rasters. 
</p>
<p>For categorical response models, a csv file map key is written giving the integer code associated with each response category.
</p>
<p>If <code>keep.predictor.brick = TRUE</code> then a raster brick of all the predictor rasters from the model is also saved to the specified folder. If <code>keep.predictor.brick = FALSE</code> (the default) then the predictor brick is written to a temprary file, and deleted. Warning: the predictor bricks can be quite large, and saving them can require quite a bit of memory.
</p>


<h3>Note</h3>

<p>If <code>model.mapmake()</code> is interupted it may leave orphan <code>.gri</code> and <code>.grd</code> files in your temporary directory. The <code>raster</code> package functions <code>showTmpFiles</code> and <code>removeTmpFiles</code> can be used to locate and remove these files, or they can be deleated manually from the temporary directory.
</p>


<h3>Author(s)</h3>

<p> Elizabeth Freeman and Tracey Frescino </p>


<h3>References</h3>

 
<p>Breiman, L. (2001) Random Forests. Machine Learning, 45:5-32.
</p>
<p>Liaw, A. and  Wiener, M. (2002). Classification and Regression by randomForest. R News 2(3), 18&ndash;22.
</p>
<p>Ridgeway, G., (1999). The state of boosting. Comp. Sci. Stat. 31:172-181
</p>
<p>Simpson, E. H. (1949). Measurement of diversity. Nature.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+get.test">get.test</a></code>, <code><a href="#topic+model.build">model.build</a></code>, <code><a href="#topic+model.diagnostics">model.diagnostics</a></code>, <code><a href="raster.html#topic+compareRaster">compareRaster</a></code>, <code><a href="raster.html#topic+writeRaster">writeRaster</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

###########################################################################
############################# Run this set up code: #######################
###########################################################################

# set seed:
seed=38

# Define training and test files:

qdata.trainfn = system.file("extdata", "helpexamples","DATATRAIN.csv", package = "ModelMap")

# Define folder for all output:
folder=getwd()	


#identifier for individual training and test data points

unique.rowname="ID"


###########################################################################
######################## Define the model: ################################
###########################################################################


########## Continuous Response, Continuous Predictors ############

#file name to store model:
MODELfn="RF_Bio_TC"				

#predictors:
predList=c("TCB","TCG","TCW")	

#define which predictors are categorical:
predFactor=FALSE	

# Response name and type:
response.name="BIO"
response.type="continuous"



###########################################################################
########################### build model: ##################################
###########################################################################


### create model ###

model.obj = model.build( model.type="RF",
                       qdata.trainfn=qdata.trainfn,
                       folder=folder,		
                       unique.rowname=unique.rowname,		
                       MODELfn=MODELfn,
                       predList=predList,
                       predFactor=predFactor,
                       response.name=response.name,
                       response.type=response.type,
                       seed=seed,
                       na.action="na.roughfix"
)



###########################################################################
############ Then Run this code to predict map pixels #####################
###########################################################################


### Create a the filename (including path) for the rast Look up Tables ###


rastLUTfn.2001 &lt;- system.file(	"extdata",
				"helpexamples",
				"LUT_2001.csv",
				package="ModelMap")
                         
                 



### Load rast LUT table, and add path to the predictor raster filenames in column 1 ###

rastLUT.2001 &lt;- read.table(rastLUTfn.2001,header=FALSE,sep=",",stringsAsFactors=FALSE)

for(i in 1:nrow(rastLUT.2001)){
	rastLUT.2001[i,1] &lt;- system.file("extdata",
					"helpexamples",
					rastLUT.2001[i,1],
					package="ModelMap")
}                                 


### Define filename for map  output ###

OUTPUTfn.2001 &lt;- "RF_BIO_TCandNLCD_01.img"
OUTPUTfn.2001 &lt;- paste(folder,OUTPUTfn.2001,sep="/")


### Create image files of predicted map data ###

model.mapmake( model.obj=model.obj,
               folder=folder,		
               rastLUTfn=rastLUT.2001,
           # Mapping arguments						
               OUTPUTfn=OUTPUTfn.2001
               )


###########################################################################
################ run this code to create maps in R ########################
###########################################################################

### Define Color Ramp ###

l &lt;- seq(100,0,length.out=101)
c &lt;- seq(0,100,length.out=101)
col.ramp &lt;- hcl(h = 120, c = c, l = l)


### read in map data ###

mapgrid.2001 &lt;- raster(OUTPUTfn.2001)

#mapgrid.2001 &lt;- setMinMax(mapgrid.2001)


### create map ###

dev.new(width = 5, height = 5)
opar &lt;- par(mar=c(3,3,2,1),oma=c(0,0,3,4),xpd=NA)

zlim &lt;- c(0,max(maxValue(mapgrid.2001)))
legend.label&lt;-rev(pretty(zlim,n=5))
legend.colors&lt;-col.ramp[trunc((legend.label/max(legend.label))*100)+1]

image(  mapgrid.2001, col = col.ramp, zlim=zlim, asp=1, bty="n", 
        xaxt="n", yaxt="n", main="", xlab="", ylab="")
mtext("2001 Imagery",side=3,line=1,cex=1.2)

legend(	x=xmax(mapgrid.2001),y=ymax(mapgrid.2001),
	legend=legend.label,
	fill=legend.colors,
	bty="n",
	cex=1.2
)
mtext("Predictions",side=3,line=1,cex=1.5,outer=TRUE)
par(opar)


## End(Not run) # end dontrun

</code></pre>

<hr>
<h2 id='ModelMap-internal'> Internal ModelMap Functions </h2><span id='topic+initialize.device'></span><span id='topic+REQUIRE.party'></span><span id='topic+REQUIRE.quantregForest'></span><span id='topic+REQUIRE.gbm'></span><span id='topic+mask.fun'></span><span id='topic+mask.graphic'></span><span id='topic+explore.continuous'></span><span id='topic+explore.categorical'></span><span id='topic+CF.list2df'></span><span id='topic+CF.int2num'></span><span id='topic+varImpPlot.MM'></span><span id='topic+check.device.type'></span><span id='topic+check.device.type.nodefault'></span><span id='topic+check.predList'></span><span id='topic+check.model.levels'></span><span id='topic+check.model.type'></span><span id='topic+check.response.type'></span><span id='topic+check.response.name'></span><span id='topic+imp.extract.sgb'></span><span id='topic+imp.extract.rf'></span><span id='topic+imp.extract.qrf'></span><span id='topic+imp.extract.cf'></span><span id='topic+imp.scale'></span><span id='topic+getRasts'></span><span id='topic+correlation.function'></span><span id='topic+diagnostics.function'></span><span id='topic+model.SGB'></span><span id='topic+prediction.SGB'></span><span id='topic+rF.binary'></span><span id='topic+prediction.rF.binary'></span><span id='topic+rF.categorical'></span><span id='topic+prediction.rF.categorical'></span><span id='topic+rF.continuous'></span><span id='topic+prediction.rF.continuous'></span><span id='topic+CF.binary'></span><span id='topic+prediction.CF.binary'></span><span id='topic+CF.categorical'></span><span id='topic+prediction.CF.categorical'></span><span id='topic+CF.continuous'></span><span id='topic+prediction.CF.continuous'></span><span id='topic+rF.quantreg'></span><span id='topic+prediction.rF.quantreg'></span><span id='topic+create.model'></span><span id='topic+prediction.model'></span><span id='topic+projcompare'></span><span id='topic+projfix'></span><span id='topic+FNcheck'></span><span id='topic+grd2gri'></span><span id='topic+production.prediction'></span>

<h3>Description</h3>

<p>Internal Subfunctions
</p>


<h3>Details</h3>

<p>These are not to be called by the user.  
</p>


<h3>Author(s)</h3>

<p> Elizabeth Freeman </p>

<hr>
<h2 id='ModelMap-package'>
Modeling and Map Production using Random Forest and Related Stochastic Models
</h2><span id='topic+ModelMap-package'></span><span id='topic+ModelMap'></span>

<h3>Description</h3>

<p>Creates sophisticated models of training data and validates the models with an independent test set, cross validation, or with Out Of Bag (OOB) predictions on the training data. Create graphs and tables of the model validation results. Applies these models to GIS .img files of predictors to create detailed prediction surfaces. Handles large predictor files for map making, by reading in the .img files in chunks, and output to the .txt file the prediction for each data chunk, before reading the next chunk of data.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> ModelMap</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 3.4.0.4</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-04-04
</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> Unlimited. This code was written and prepared by a U.S. Government employee on official time, 
and therefore it is in the public domain and not subject to copyright.</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>This package provides a push button approach to complex model building and production mapping.  It contains three main functions: <code><a href="#topic+model.build">model.build</a></code>,<code><a href="#topic+model.diagnostics">model.diagnostics</a></code>, and <code><a href="#topic+model.mapmake">model.mapmake</a></code>. 
</p>
<p>In addition it contains a simple function <code><a href="#topic+get.test">get.test</a></code> that can be used to randomly divide a training dataset into training and test/validation sets; <code><a href="#topic+build.rastLUT">build.rastLUT</a></code> that uses GUI prompts to walk a user through the process of setting up a Raster look up table to link predictors from the training data with the rasters used for map contruction; <code><a href="#topic+model.explore">model.explore</a></code>, for preliminary data exploration; and, <code><a href="#topic+model.importance.plot">model.importance.plot</a></code> and <code><a href="#topic+model.interaction.plot">model.interaction.plot</a></code> for interpreting the effects of individual model predictors. 
</p>
<p><code>ModelMap</code> can be run in a traditional R command mode, where all arguments are specified in the function call. However it can also be used in a full push button mode, where you type in the simple command such as <a href="#topic+model.build">model.build</a>, and GUI pop-up windows ask questions about the type of model, the file locations of the data, etc...
</p>
<p>Random Forest is implemented through the <code>randomForest</code> package within <code>R</code>. Random Forest is more user friendly than Stochastic Gradient Boosting, as it has fewer parameters to be set by the user, and is less sensitive to tuning of these parameters. A Random Forest model consists of multiple trees that vote on predictions. For each tree a random subset of the training data is used to construct the tree, with the remaining data points used to construct out-of-bag (OOB) error estimates. At each node of the tree a random selection of predictors is chosen to determine the split. The number of predictors used to select the splits is the primary user specified parameter that can affect model performance, and this parameter can be automatically optimized using the <code>randomForest</code> function <code>tuneRF()</code>. Random Forest will not over fit data, therefore the only penalty of increasing the number of trees is computation time. Random Forest can compute variable importance, an advantage over some &quot;black box&quot; modeling techniques if it is important to understand the ecological relationships underlying a model (Brieman, 2001).
</p>
<p>Quantile Regression Forests is implemented through the <code>quantregForest</code> package.
</p>
<p>Conditional Forests is implemented with the <code>cforest()</code> function in the <code>party</code> package. As stated in the <code>party</code> package, ensembles of conditional inference trees have not yet been extensively tested, so this routine is meant for the expert user only and its current state is rather experimental. 
</p>
<p>For Presence-Absence data, the package <code>PresenceAbsence</code> is used for model validation.
</p>
<p>For model diagnostics the package <code>corrplot</code> is used to plot the correlation between predictor variables.
</p>
<p>For map making, the <code>raster</code> is used to read and write <code>.img</code> files.
</p>
<p>For interaction plots, the <code>fields</code> package is used to produce image plots.
</p>


<h3>Author(s)</h3>

<p>Author: Elizabeth Freeman and Tracey Frescino
</p>
<p>Maintainer: Elizabeth Freeman &lt;elizabeth.a.freeman@usda.gov&gt;
</p>


<h3>References</h3>

<p>Breiman, L. (2001) Random Forests. Machine Learning, 45:5-32.
</p>
<p>Elith, J., Leathwick, J. R. and Hastie, T. (2008). A working guide to boosted regression trees. Journal of Animal Ecology. 77:802-813.
</p>
<p>Friedman, J.H. (2001). Greedy function approximation: a gradient boosting machine. Ann. Stat., 29(5):1189-1232.
</p>
<p>Friedman, J.H. (2002). Stochastic gradient boosting. Comput. Stat. Data An., 38(4):367-378.
</p>
<p>Liaw, A. and  Wiener, M. (2002). Classification and Regression by randomForest. R News 2(3), 18&ndash;22.
</p>
<p>N. Meinshausen (2006) &quot;Quantile Regression Forests&quot;, Journal of Machine Learning Research 7, 983-999 http://jmlr.csail.mit.edu/papers/v7/
</p>
<p>Ridgeway, G., (1999). The state of boosting. Comp. Sci. Stat. 31:172-181
</p>
<p>Carolin Strobl, Anne-Laure Boulesteix, Achim Zeileis and Torsten Hothorn (2007). Bias in Random Forest variable Importance Measures: Illustrations, Sources and a Solution. BMC Bioinformatics, 8, 25. http://www.biomedcentral.co,/1471-2105/8/25
</p>
<p>Carolin Strobl, James Malley and Gerhard Tutz (2009). An Introduction to Recursive Partitioning: Rationale, Application, and Characteristics of Classification and Regression Trees, Bagging, and Random forests. Phsycological Methods, 14(4), 323-348. 
</p>
<p>Torsten Hothorn, Berthold Lausen, Axel Benner and Martin Radespiel-Troeger (2004). Bagging Survival Trees. Statistics in Medicine, 23(1), 77-91.
</p>
<p>Torsten Hothorn, Peter Buhlmann, Sandrine Dudoit, Annette Molinaro and Mark J. ven der Laan (2006a). Survival Ensembles. Biostatistics, 7(3), 355-373. 
</p>
<p>Torston Hothorn, Kurt Hornik and Achim Zeileis (2006b). Unbiased Recursive Partitioning: A Conditional Inference Framework. JOurnal of Computational and Graphical Statistics, 15(3), 651-674. Preprint available from http://statmath.wu-wein.ac.at/~zeileis/papers/Hothorn+Hornik+Zeileis-2006.pdf
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
