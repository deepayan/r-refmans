<!DOCTYPE html><html><head><title>Help for package kdensity</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {kdensity}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_bw'><p>Add a new bw to <code>bw_environment</code>.</p></a></li>
<li><a href='#add_kernel'><p>Add a new kernel to <code>kernels_environment</code>.</p></a></li>
<li><a href='#add_start'><p>Add a new parametric start to <code>starts_environment</code>.</p></a></li>
<li><a href='#bandwidths'><p>Bandwidth Selectors</p></a></li>
<li><a href='#get_bw'><p>Get bandwidth functions from string.</p></a></li>
<li><a href='#get_kernel'><p>Helper function that gets a kernel function for kdensity.</p></a></li>
<li><a href='#get_kernel_start_support'><p>Fill in missing kernel, start or support given the supplied values.</p></a></li>
<li><a href='#get_range'><p>Supplies a plotting range from a kdensity object.</p></a></li>
<li><a href='#get_standard_bw'><p>Get a bandwidth string when 'bw' is unspecified.</p></a></li>
<li><a href='#get_start'><p>Get densities and estimators from strings.</p></a></li>
<li><a href='#kdensity'><p>Parametrically guided kernel density estimation</p></a></li>
<li><a href='#kernels'><p>Kernel functions</p></a></li>
<li><a href='#listmerge'><p>Merges two lists.</p></a></li>
<li><a href='#parametric_starts'><p>Parametric starts</p></a></li>
<li><a href='#plot_helper'><p>Helper function for the plot methods.</p></a></li>
<li><a href='#plot.kdensity'><p>Plot, Lines and Points Methods for Kernel Density Estimation</p></a></li>
<li><a href='#recycle'><p>Recycles arguments.</p></a></li>
<li><a href='#support_compatible'><p>Checks compatibility between supports.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Kernel Density Estimation with Parametric Starts and Asymmetric
Kernels</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Author:</td>
<td>Jonas Moss, Martin Tveten</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jonas Moss &lt;jonas.gjertsen@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Handles univariate non-parametric density estimation with 
    parametric starts and asymmetric kernels in a simple and flexible way. 
    Kernel density estimation with parametric starts involves fitting a
    parametric density to the data before making a correction with kernel 
    density estimation, see Hjort &amp; Glad (1995) &lt;<a href="https://doi.org/10.1214%2Faos%2F1176324627">doi:10.1214/aos/1176324627</a>&gt;.
    Asymmetric kernels make kernel density estimation more efficient on bounded
    intervals such as (0, 1) and the positive half-line. Supported asymmetric 
    kernels are the gamma kernel of Chen (2000) &lt;<a href="https://doi.org/10.1023%2FA%3A1004165218295">doi:10.1023/A:1004165218295</a>&gt;,
    the beta kernel of Chen (1999) &lt;<a href="https://doi.org/10.1016%2FS0167-9473%2899%2900010-9">doi:10.1016/S0167-9473(99)00010-9</a>&gt;, and the
    copula kernel of Jones &amp; Henderson (2007) &lt;<a href="https://doi.org/10.1093%2Fbiomet%2Fasm068">doi:10.1093/biomet/asm068</a>&gt;.
    User-supplied kernels, parametric starts, and bandwidths are supported.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/JonasMoss/kdensity">https://github.com/JonasMoss/kdensity</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/JonasMoss/kdensity/issues">https://github.com/JonasMoss/kdensity/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Suggests:</td>
<td>extraDistr, SkewHyperbolic, testthat, covr, knitr, rmarkdown</td>
</tr>
<tr>
<td>Imports:</td>
<td>assertthat, univariateML, EQL</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-09-30 07:46:39 UTC; jonas</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-09-30 09:00:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_bw'>Add a new bw to <code>bw_environment</code>.</h2><span id='topic+add_bw'></span>

<h3>Description</h3>

<p>Add a new bw to <code>bw_environment</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_bw(bw_str, bw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_bw_+3A_bw_str">bw_str</code></td>
<td>
<p>A string giving the name of the density.</p>
</td></tr>
<tr><td><code id="add_bw_+3A_bw">bw</code></td>
<td>
<p>The bw function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>

<hr>
<h2 id='add_kernel'>Add a new kernel to <code>kernels_environment</code>.</h2><span id='topic+add_kernel'></span>

<h3>Description</h3>

<p>Add a new kernel to <code>kernels_environment</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_kernel(kernel_str, kernel)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_kernel_+3A_kernel_str">kernel_str</code></td>
<td>
<p>A string giving the name of the density.</p>
</td></tr>
<tr><td><code id="add_kernel_+3A_kernel">kernel</code></td>
<td>
<p>The kernel function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>

<hr>
<h2 id='add_start'>Add a new parametric start to <code>starts_environment</code>.</h2><span id='topic+add_start'></span>

<h3>Description</h3>

<p>Add a new parametric start to <code>starts_environment</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_start(start_str, start)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_start_+3A_start_str">start_str</code></td>
<td>
<p>A string giving the name of the density.</p>
</td></tr>
<tr><td><code id="add_start_+3A_start">start</code></td>
<td>
<p>The parametric start function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>

<hr>
<h2 id='bandwidths'>Bandwidth Selectors</h2><span id='topic+bandwidths'></span>

<h3>Description</h3>

<p>The available options for bandwidth selectors, passed as the <code>bw</code>
argument to <code>kdensity</code>.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="bandwidths_+3A_x">x</code></td>
<td>
<p>The input data.</p>
</td></tr>
<tr><td><code id="bandwidths_+3A_kernel_str">kernel_str</code></td>
<td>
<p>A string specifying the kernel, e.g. &quot;gaussian.&quot;</p>
</td></tr>
<tr><td><code id="bandwidths_+3A_start_str">start_str</code></td>
<td>
<p>A string specifying the parametric start, e.g. &quot;normal&quot;.</p>
</td></tr>
<tr><td><code id="bandwidths_+3A_support">support</code></td>
<td>
<p>The domain of definition for the kernel. (-Inf, Inf) for
symmetric kernels.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The bandwidth functions are not exported. They are members of the
environment <code>bw_environments</code>, and can be accessed by
<code>kdensity:::bw_environments</code>.
</p>


<h3>Bandwidth selectors</h3>

<p><code style="white-space: pre;">&#8288;"nrd0", "nrd", "bcv", "SJ"&#8288;</code>: Bandwidth selectors from <code>stats</code>.
They are documented in <code style="white-space: pre;">&#8288;[bandwidth][stats::bandwidth] stats:bandwidth&#8288;</code>.
&quot;nrd0&quot; is the standard bandwidth selector for symmetric kernels with
constant parametric starts.
</p>
<p><code>"ucv"</code>: Unbiased cross validation. The standard option for
asymmetric kernels.
</p>
<p><code>"RHE"</code>: Selector for parametric starts with a symmetric kernel,
based on a reference rule with Hermite polynomials.
Described in Hjort &amp; Glad (1995). The default method in <code>kdensity</code> when a parametric
start is supplied and the kernel is symmetric.
</p>
<p><code>"JH"</code>: Selector for the Gaussian copula kernel, based on
normal reference rule. Described in Jones &amp; Henderson. The default method when
the <code>gcopula</code> kernel is used in <code>kdensity</code>.
</p>


<h3>Structure</h3>

<p>The bandwidth selector is a function of four arguments: The data
<code>x</code>, a kernel string <code>kernel</code>, a start string <code>start</code>,
and a support vector <code>support</code>. To obtain the functions associated
with these strings, use <code>get_kernel</code> and <code>get_start</code>. The
function should return a double.
</p>


<h3>References</h3>

<p>Jones, M. C., and D. A. Henderson. &quot;Kernel-type density estimation on the unit interval.&quot; Biometrika 94.4 (2007): 977-984.
Hjort, Nils Lid, and Ingrid K. Glad. &quot;Nonparametric density estimation with a parametric start.&quot; The Annals of Statistics (1995): 882-904.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kdensity">kdensity()</a></code>, <code><a href="stats.html#topic+kernel">stats::bandwidth.kernel()</a></code> for the
bandwidth selectors of <code><a href="stats.html#topic+density">stats::density()</a></code>. In addition,
<code><a href="#topic+kernels">kernels()</a></code>; <code><a href="#topic+parametric_starts">parametric_starts()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   ## Not a serious bandwidth function.
   silly_width = function(x, kernel = NULL, start = NULL, support = NULL) {
     rexp(1)
   }
   kdensity(mtcars$mpg, start = "gumbel", bw = silly_width)
</code></pre>

<hr>
<h2 id='get_bw'>Get bandwidth functions from string.</h2><span id='topic+get_bw'></span>

<h3>Description</h3>

<p>Get bandwidth functions from string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_bw(bw_str)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_bw_+3A_bw_str">bw_str</code></td>
<td>
<p>a string specifying the density of interest.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a bandwidth function.
</p>

<hr>
<h2 id='get_kernel'>Helper function that gets a kernel function for kdensity.</h2><span id='topic+get_kernel'></span>

<h3>Description</h3>

<p>Helper function that gets a kernel function for kdensity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_kernel(kernel_str)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_kernel_+3A_kernel_str">kernel_str</code></td>
<td>
<p>a string specifying which kernel to use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a kernel function of the format k(u) with integral normalized
to 1.
</p>

<hr>
<h2 id='get_kernel_start_support'>Fill in missing kernel, start or support given the supplied values.</h2><span id='topic+get_kernel_start_support'></span>

<h3>Description</h3>

<p>This function takes the supplied values of kernel, start, and support
and fills in the non-supplied ones. It also handles inconsistencies,
such as providing a support on (-Inf, Inf) but a kernel on (0, Inf).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_kernel_start_support(kernel, start, support)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_kernel_start_support_+3A_kernel">kernel</code></td>
<td>
<p>Supplied kernel; string or list.</p>
</td></tr>
<tr><td><code id="get_kernel_start_support_+3A_start">start</code></td>
<td>
<p>Supplied parametric start; string or list.</p>
</td></tr>
<tr><td><code id="get_kernel_start_support_+3A_support">support</code></td>
<td>
<p>Binary vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>kernel</code> and <code>start</code> parameters are either strings or
adhering to the kernel/start list structure. <code>support</code> is a
numeric vector of length two.
</p>


<h3>Value</h3>

<p>a list with members kernel, kernel_str, start, start_str,
and support.
</p>

<hr>
<h2 id='get_range'>Supplies a plotting range from a kdensity object.</h2><span id='topic+get_range'></span>

<h3>Description</h3>

<p>Supplies a plotting range from a kdensity object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_range(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_range_+3A_obj">obj</code></td>
<td>
<p>A kdensity object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>S vector of size 1000, used for plotting.
</p>

<hr>
<h2 id='get_standard_bw'>Get a bandwidth string when 'bw' is unspecified.</h2><span id='topic+get_standard_bw'></span>

<h3>Description</h3>

<p>Get a bandwidth string when 'bw' is unspecified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_standard_bw(kernel_str, start_str, support)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_standard_bw_+3A_kernel_str">kernel_str</code></td>
<td>
<p>a kernel string</p>
</td></tr>
<tr><td><code id="get_standard_bw_+3A_start_str">start_str</code></td>
<td>
<p>a parametric start string.</p>
</td></tr>
<tr><td><code id="get_standard_bw_+3A_support">support</code></td>
<td>
<p>the support.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a bandwidth string.
</p>

<hr>
<h2 id='get_start'>Get densities and estimators from strings.</h2><span id='topic+get_start'></span>

<h3>Description</h3>

<p>Get densities and estimators from strings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_start(start_str)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_start_+3A_start_str">start_str</code></td>
<td>
<p>A string specifying the density of interest.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two functions.
</p>

<hr>
<h2 id='kdensity'>Parametrically guided kernel density estimation</h2><span id='topic+kdensity'></span>

<h3>Description</h3>

<p><code>kdensity</code> computes a parametrically guided kernel density estimate
for univariate data. It supports asymmetric kernels and parametric starts
through the <code>kernel</code> and <code>start</code> arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kdensity(
  x,
  bw = NULL,
  adjust = 1,
  kernel = NULL,
  start = NULL,
  support = NULL,
  na.rm = FALSE,
  normalized = TRUE,
  tolerance = 0.01
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kdensity_+3A_x">x</code></td>
<td>
<p>Numeric vector containing the data.</p>
</td></tr>
<tr><td><code id="kdensity_+3A_bw">bw</code></td>
<td>
<p>A bandwidth function. Can be either a string, a custom-made
function, or a double. The supported bandwidth functions are documented
in <code><a href="#topic+bandwidths">bandwidths()</a></code>.</p>
</td></tr>
<tr><td><code id="kdensity_+3A_adjust">adjust</code></td>
<td>
<p>An adjustment constant, so that <code>h = adjust*bw*sd</code>, where <code>sd</code>
varies with the chosen kernel.</p>
</td></tr>
<tr><td><code id="kdensity_+3A_kernel">kernel</code></td>
<td>
<p>The kernel function. Can be chosen from the list of built-in
kernels or be custom-made. See <code><a href="#topic+kernels">kernels()</a></code> for details.</p>
</td></tr>
<tr><td><code id="kdensity_+3A_start">start</code></td>
<td>
<p>Parametric start. Can be chosen from the list of built-in
parametric starts or be custom-made. See <code><a href="#topic+parametric_starts">parametric_starts()</a></code> for
details.</p>
</td></tr>
<tr><td><code id="kdensity_+3A_support">support</code></td>
<td>
<p>The support of the data. Must be compatible with the supplied
<code>x</code> and the supplied <code>start</code> and <code>kernel</code>. Is used to find the
normalization constant, see <code>normalized</code>.</p>
</td></tr>
<tr><td><code id="kdensity_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical; if <code>TRUE</code>, <code>NA</code>s will be removed from <code>x</code>.</p>
</td></tr>
<tr><td><code id="kdensity_+3A_normalized">normalized</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the density is normalized.</p>
</td></tr>
<tr><td><code id="kdensity_+3A_tolerance">tolerance</code></td>
<td>
<p>Numeric; the relative error to tolerate in normalization.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default values for <code>bw</code>, <code>kernel</code>, <code>start</code>, and
<code>support</code> are interdependent, and are chosen to make sense. E.g.,
the default value for <code>support</code> when <code>start = beta</code> is
<code>c(0, 1)</code>.
</p>
<p>The <code>start</code> argument defaults to <code>uniform</code>, which corresponds
to ordinary kernel density estimation. The typical default value for
<code>kernel</code> is <code>gaussian</code>.
</p>
<p>If <code>normalized</code> is <code>FALSE</code> and <code>start != "uniform"</code>, the resulting
density will not integrate to 1 in general.
</p>


<h3>Value</h3>

<p><code>kdensity</code> returns an S3 function object of
<code><a href="base.html#topic+class">base::class()</a></code> &quot;kdensity&quot;. This is a callable function with the
following elements, accessible by '$':
</p>

<dl>
<dt><code>x</code></dt><dd><p>The data supplied in <code>x</code>.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;bw_str, bw, adjust, h&#8288;</code></dt><dd><p>The bandwidth function, the resulting
bandwidth, the <code>adjust</code> argument, and the adjusted
bandwidth.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;kernel_str, kernel, start, start_str, support&#8288;</code></dt><dd><p>Name of the kernel,
the kernel object, name of the parametric start, the start object,
and the support of the density.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;data.name, n, range, has.na, na.rm, normalized&#8288;</code></dt><dd><p>Name of the data, number of
observations, the range of the data, whether the data
<code>x</code> contained <code>NA</code> values, whether na.rm is <code>TRUE</code>
or not, and whether the density is normalized.</p>
</dd>
<dt><code>call</code></dt><dd><p>The <code>call</code> to <code>kdensity</code>.</p>
</dd>
<dt><code>estimates</code></dt><dd><p>Named numeric vector containing the parameter
estimates from the parametric start.</p>
</dd>
<dt><code>logLik</code></dt><dd><p>The log-likelihood of the parametric starts. Is <code>NA</code>
for the uniform start.</p>
</dd>
</dl>



<h3>References</h3>

<p>Hjort, Nils Lid, and Ingrid K. Glad. &quot;Nonparametric density estimation with a parametric start.&quot; The Annals of Statistics (1995): 882-904.
</p>
<p>Jones, M. C., and D. A. Henderson. &quot;Miscellanea kernel-type density estimation on the unit interval.&quot; Biometrika 94.4 (2007): 977-984.
</p>
<p>Chen, Song Xi. &quot;Probability density function estimation using gamma kernels.&quot; Annals of the Institute of Statistical Mathematics 52.3 (2000): 471-480.
</p>
<p>Silverman, Bernard W. Density estimation for statistics and data analysis. Vol. 26. CRC press, 1986.
</p>


<h3>See Also</h3>

<p>The <code>stats</code> package function <code><a href="stats.html#topic+density">stats::density()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Use gamma kernels to model positive data, the concentration of
## theophylline

concentration = Theoph$conc + 0.001
plot(kdensity(concentration, start = "gamma", kernel = "gamma", adjust = 1/3),
     ylim = c(0, 0.15), lwd = 2, main = "Concentration of theophylline")
lines(kdensity(concentration, start = "gamma", kernel = "gaussian"),
      lty = 2, col = "grey", lwd = 2)
lines(kdensity(concentration, start = "gaussian", kernel = "gaussian"),
      lty = 3, col = "blue", lwd = 2)
lines(kdensity(concentration, start = "gaussian", kernel = "gamma", adjust = 1/3),
      lty = 4, col = "red", lwd = 2)
rug(concentration)

## Using a density and and estimator from another package.

skew_hyperbolic = list(
  density   = SkewHyperbolic::dskewhyp,
  estimator = function(x) SkewHyperbolic::skewhypFit(x, printOut = FALSE)$param,
  support   = c(-Inf, Inf)
)

kde = kdensity(diff(LakeHuron), start = skew_hyperbolic)
plot(kde, lwd = 2, col = "blue",
     main = "Annual differences in water level (ft) of Lake Huron, 1875 - 1972")
lines(kde, plot_start = TRUE, lty = 2, lwd = 2) # Plots the skew hyperbolic density.
rug(diff(LakeHuron))

kde$estimates # Also: coef(kde)
# Displays the parameter estimates:
#        mu     delta      beta        nu
# -1.140713  3.301112  2.551657 26.462469

</code></pre>

<hr>
<h2 id='kernels'>Kernel functions</h2><span id='topic+kernels'></span>

<h3>Description</h3>

<p>Kernel functions are an important part of <code>kdensity</code>. This document
lists the available built-in functions and the structure of them. Any kernel
in the list can be used in <code>kdensity</code> by using <code>kernel = "kernel"</code>
for the intended kernel.
</p>


<h3>Details</h3>

<p>Be careful combining kernels with compact support with parametric starts,
as the normalizing integral typically fails to converge. Use <code>gaussian</code>
instead.
</p>


<h3>Symmetric kernels</h3>

<p><code style="white-space: pre;">&#8288;gaussian, normal&#8288;</code>: The Gaussian kernel. The default argument when
<code>starts</code> is supported on R.
<code style="white-space: pre;">&#8288;epanechnikov, rectangular (uniform), triangular, biweight, cosine, optcosine&#8288;</code>: Standard symmetric kernels, also used in
<code><a href="stats.html#topic+density">stats::density()</a></code>.
<code style="white-space: pre;">&#8288;tricube, triweight&#8288;</code>: Standard symmetric kernels. Not supported by
<code><a href="stats.html#topic+density">stats::density()</a></code>.
<code>laplace</code>: Uses the Laplace density, also known as the double
exponential density.
</p>


<h3>Asymmetric kernels</h3>

<p><code style="white-space: pre;">&#8288;gamma, gamma_biased&#8288;</code>: The gamma kernel of Chen (2000). For use on the positive
half-line. <code>gamma</code> is the recommended biased-corrected kernel.
<code>gcopula</code>: The Gaussian copula kernel of Jones &amp; Henderson (2007). For use
on the unit interval.
<code style="white-space: pre;">&#8288;beta, beta_biased&#8288;</code>: The beta kernel of Chen (1999). For use on the unit interval.
<code>beta</code> is the recommended bias-corrected kernel.
</p>


<h3>Structure</h3>

<p>A kernel is a list containing two mandatory elements and one optional
element. The mandatory element '<code>kernel</code>' is the kernel function.
It takes arguments <code style="white-space: pre;">&#8288;y, x, h&#8288;</code>, where <code>x</code> is the data supplied
to <code>kdensity</code> and <code>y</code> is the point of evaluation. <code>h</code> is
the bandwidth. Internally, the kernel function is evaluated as
<code>1/h*kernel(y, x, h)</code>. It should be vectorized in <code>x</code>, but
vectorization in <code>y</code> is not needed.
</p>
<p>The second mandatory element is <code>support</code>, stating the domain of
definition for the kernel. This is used to distinguish kernels on the
unit interval / positive half-line from kernels on R.
</p>
<p><code>sd</code> is used for symmetric kernels, and states the standard error
of the kernel. This is used to make kernels comparable to the Gaussian
kernel when calculating bandwidths.
</p>


<h3>References</h3>

<p>Chen, Song Xi. &quot;Probability density function estimation using gamma kernels.&quot; Annals of the Institute of Statistical Mathematics 52.3 (2000): 471-480.
Jones, M. C., and D. A. Henderson. &quot;Kernel-type density estimation on the unit interval.&quot; Biometrika 94.4 (2007): 977-984.
Chen, Song Xi. &quot;Beta kernel estimators for density functions.&quot; Computational Statistics &amp; Data Analysis 31.2 (1999): 131-145.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kdensity">kdensity()</a></code>; <code><a href="#topic+parametric_starts">parametric_starts()</a></code>;
<code><a href="#topic+bandwidths">bandwidths()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gaussian = list(
  kernel  = function(y, x, h) stats::dnorm((y-x)/h),
  sd = 1,
  support = c(-Inf, Inf)
)

gcopula = list(
  kernel  = function(y, x, h) {
    rho = 1 - h^2
    inside = rho^2*(qnorm(y)^2 + qnorm(x)^2)-2*rho*qnorm(y)*qnorm(x)
    exp(-inside/(2*(1-rho^2)))
  },
  support = c(0, 1)
)

</code></pre>

<hr>
<h2 id='listmerge'>Merges two lists.</h2><span id='topic+listmerge'></span>

<h3>Description</h3>

<p>Merges two lists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>listmerge(x, y, type = c("merge", "template"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="listmerge_+3A_x">x</code></td>
<td>
<p>A list of default arguments.</p>
</td></tr>
<tr><td><code id="listmerge_+3A_y">y</code></td>
<td>
<p>A list of supplied arguments</p>
</td></tr>
<tr><td><code id="listmerge_+3A_type">type</code></td>
<td>
<p>If <code>merge</code>, the list will be merge with y
having priority; if <code>template</code>, named the elements of
y not in x will be discarded after merging.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A merged list where conflicts are solved in favour
of y. Does not preserve ordering.
</p>

<hr>
<h2 id='parametric_starts'>Parametric starts</h2><span id='topic+parametric_starts'></span>

<h3>Description</h3>

<p>A parametric start is a density function with an associated estimator which
is used as a starting point in <code>kdensity</code>. Several parametric starts
are implemented, all with maximum likelihood estimation. Custom-made
parametric starts are possible, see the Structure section.
</p>


<h3>Structure</h3>

<p>The parametric start contains three elements: The density function, an
estimation function, and the support of the density. The parameters of
the density function must partially match the parameters of the estimator
function. The estimator function takes one argument, a numeric vector,
which is passed from <code>kdensity</code>.
</p>


<h3>Supported parametric starts</h3>

<p><code>kdensity</code> supports more than
20 built-in starts from the <a href="univariateML.html#topic+univariateML">univariateML</a> package, see
<code>univariateML::univariateML_models</code> for a list. Densities with variable
support, <code>power</code>, are not supported. The <code>pareto</code> density has its
support fixed to <code style="white-space: pre;">&#8288;(1,Inf)&#8288;</code>. The
options <code style="white-space: pre;">&#8288;uniform, constant&#8288;</code> makes <code>kdensity</code> estimate a kernel
density without parametric starts.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kdensity">kdensity()</a></code>; <code><a href="#topic+kernels">kernels()</a></code>; <code><a href="#topic+bandwidths">bandwidths()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>start_exponential = list(
 density = stats::dexp,
 estimator = function(data) {
   c(rate = 1/mean(data))
 },
 support = c(0, Inf)
)

start_inverse_gaussian = list(
 density = extraDistr::dwald,
 estimator = function(data) {
  c(mu = mean(data),
    lambda = mean(1/data - 1/mean(data)))
  },
 support = c(0, Inf)
)

</code></pre>

<hr>
<h2 id='plot_helper'>Helper function for the plot methods.</h2><span id='topic+plot_helper'></span>

<h3>Description</h3>

<p>A helper function for the plot methods that does most of the work under
the hood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_helper(
  x,
  range = NULL,
  plot_start = FALSE,
  zero_line = TRUE,
  ptype = c("plot", "lines", "points"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_helper_+3A_x">x</code></td>
<td>
<p>A <code>kdensity</code> object.</p>
</td></tr>
<tr><td><code id="plot_helper_+3A_range">range</code></td>
<td>
<p>An optional range vector; like <code>x</code> in <code>plot.default</code>.</p>
</td></tr>
<tr><td><code id="plot_helper_+3A_plot_start">plot_start</code></td>
<td>
<p>Logical; if <code>TRUE</code>, plots the parametric start only.</p>
</td></tr>
<tr><td><code id="plot_helper_+3A_zero_line">zero_line</code></td>
<td>
<p>Logical; if <code>TRUE</code>, adds a line at <code>y = 0</code>.</p>
</td></tr>
<tr><td><code id="plot_helper_+3A_ptype">ptype</code></td>
<td>
<p>The kind of plot to make</p>
</td></tr>
<tr><td><code id="plot_helper_+3A_...">...</code></td>
<td>
<p>Passed to plot.default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>

<hr>
<h2 id='plot.kdensity'>Plot, Lines and Points Methods for Kernel Density Estimation</h2><span id='topic+plot.kdensity'></span><span id='topic+lines.kdensity'></span><span id='topic+points.kdensity'></span>

<h3>Description</h3>

<p>The <code>plot</code> method for <code>kdensity</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'kdensity'
plot(x, range = NULL, plot_start = FALSE, zero_line = TRUE, ...)

## S3 method for class 'kdensity'
lines(x, range = NULL, plot_start = FALSE, zero_line = TRUE, ...)

## S3 method for class 'kdensity'
points(x, range = NULL, plot_start = FALSE, zero_line = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.kdensity_+3A_x">x</code></td>
<td>
<p>a <code>kdensity</code> object.</p>
</td></tr>
<tr><td><code id="plot.kdensity_+3A_range">range</code></td>
<td>
<p>range of x values.</p>
</td></tr>
<tr><td><code id="plot.kdensity_+3A_plot_start">plot_start</code></td>
<td>
<p>logical; if <code>TRUE</code>, plots the parametric start instead of the kernel density estimate.</p>
</td></tr>
<tr><td><code id="plot.kdensity_+3A_zero_line">zero_line</code></td>
<td>
<p>logical; if <code>TRUE</code>, add a base line at <code>y = 0</code>.</p>
</td></tr>
<tr><td><code id="plot.kdensity_+3A_...">...</code></td>
<td>
<p>further plotting parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kdensity">kdensity()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Using the data set "precip" to eye-ball the similarity between
## a kernel fit, a parametric fit, and a kernel with parametric start fit.
kde_gamma = kdensity(precip, kernel = "gaussian", start = "gamma")
kde = kdensity(precip, kernel = "gaussian", start = "uniform")

plot(kde_gamma, main = "Annual Precipitation in US Cities")
lines(kde_gamma, plot_start = TRUE, lty = 2)
lines(kde, lty = 3)
rug(precip)
</code></pre>

<hr>
<h2 id='recycle'>Recycles arguments.</h2><span id='topic+recycle'></span>

<h3>Description</h3>

<p>Recycles arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recycle(..., prototype)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recycle_+3A_...">...</code></td>
<td>
<p>A list of arguments to be recycled.</p>
</td></tr>
<tr><td><code id="recycle_+3A_prototype">prototype</code></td>
<td>
<p>an optional argument. If given, repeats all arguments
up to the length of the prototype. If an element of the list has the name,
it is used. If not, the variable itself is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Recycles arguments so that all vectors are equally long. If a
prototype is given, each vector will have the same size as the prototype.
</p>

<hr>
<h2 id='support_compatible'>Checks compatibility between supports.</h2><span id='topic+support_compatible'></span>

<h3>Description</h3>

<p>The supplied support must never be larger than the support of
the parametric start / kernel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>support_compatible(kernel, start, support)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="support_compatible_+3A_kernel">kernel</code>, <code id="support_compatible_+3A_start">start</code>, <code id="support_compatible_+3A_support">support</code></td>
<td>
<p>The kernel, start and support to check.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
