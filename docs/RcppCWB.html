<!DOCTYPE html><html><head><title>Help for package RcppCWB</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RcppCWB}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#RcppCWB-package'><p>Rcpp Bindings for the Corpus Workbench (CWB).</p></a></li>
<li><a href='#attribute_size'><p>Rcpp wrappers for CWB Corpus Library functions</p></a></li>
<li><a href='#check'><p>Check Input to Rcpp Functions.</p></a></li>
<li><a href='#check_pkg_registry_files'><p>Check Paths in Registry Files</p></a></li>
<li><a href='#cl_attribute_size'><p>Get Attribute Size (of Positional/Structural Attribute).</p></a></li>
<li><a href='#cl_charset_name'><p>Get charset of a corpus.</p></a></li>
<li><a href='#cl_delete_corpus'><p>Drop loaded corpus.</p></a></li>
<li><a href='#cl_find_corpus'><p>Load corpus.</p></a></li>
<li><a href='#cl_lexicon_size'><p>Get Lexicon Size.</p></a></li>
<li><a href='#cl_list_corpora'><p>Show CL corpora</p></a></li>
<li><a href='#cl_load_corpus'><p>Load corpus</p></a></li>
<li><a href='#cl_rework'><p>Low-level CL access.</p></a></li>
<li><a href='#cl_struc_values'><p>Check whether structural attribute has values</p></a></li>
<li><a href='#CL: p_attributes'><p>Using Positional Attributes.</p></a></li>
<li><a href='#CL: s_attributes'><p>Using Structural Attributes.</p></a></li>
<li><a href='#corpus_data_dir'><p>Get information from registry file</p></a></li>
<li><a href='#corpus_is_loaded'><p>Check whether corpus is loaded</p></a></li>
<li><a href='#cqp_initialize'><p>Initialize Corpus Query Processor (CQP).</p></a></li>
<li><a href='#cqp_list_corpora'><p>List Available CWB Corpora.</p></a></li>
<li><a href='#cqp_query'><p>Execute CQP Query and Retrieve Results.</p></a></li>
<li><a href='#cwb_charsets'><p>Character sets supported by CWB</p></a></li>
<li><a href='#cwb_encode'><p>CWB Tools for Creating Corpora</p></a></li>
<li><a href='#cwb_version'><p>Get CWB version</p></a></li>
<li><a href='#get_cbow_matrix'><p>Get CBOW Matrix.</p></a></li>
<li><a href='#get_count_vector'><p>Get Vector with Counts for Positional Attribute.</p></a></li>
<li><a href='#get_pkg_registry'><p>Get Registry Directory Within Package</p></a></li>
<li><a href='#get_region_matrix'><p>Get Matrix with Regions for Strucs.</p></a></li>
<li><a href='#ids_to_count_matrix'><p>Perform Count for Vector of IDs.</p></a></li>
<li><a href='#matrix_to_subcorpus'><p>Create CWB subcorpus from matrix with regions.</p></a></li>
<li><a href='#p_attr_default'><p>Get default p-attribute</p></a></li>
<li><a href='#region_matrix_ops'><p>Get IDs and Counts for Region Matrices.</p></a></li>
<li><a href='#region_matrix_to_struc_matrix'><p>Get min and max strucs of s-attribute present in region</p></a></li>
<li><a href='#s_attr_is_descendent'><p>Explore XML structure of CWB corpus</p></a></li>
<li><a href='#s_attr_regions'><p>Get regions defined by a structural attribute</p></a></li>
<li><a href='#s_attribute_decode'><p>Decode Structural Attribute.</p></a></li>
<li><a href='#subcorpus_get_ranges'><p>Get ranges of subcorpus</p></a></li>
<li><a href='#use_tmp_registry'><p>Use Temporary Registry</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>'Rcpp' Bindings for the 'Corpus Workbench' ('CWB')</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-29</td>
</tr>
<tr>
<td>Author:</td>
<td>Andreas Blaette [aut, cre],
  Bernard Desgraupes [aut],
  Sylvain Loiseau [aut],
  Oliver Christ [ctb],
  Bruno Maximilian Schulze [ctb],
  Stephanie Evert [ctb],
  Arne Fitschen [ctb],
  Jeroen Ooms [ctb],
  Marius Bertram [ctb],
  Tomas Kalibera [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andreas Blaette &lt;andreas.blaette@uni-due.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>'Rcpp' Bindings for the C code of the 'Corpus Workbench' ('CWB'), an indexing and query 
  engine to efficiently analyze large corpora (<a href="https://cwb.sourceforge.io">https://cwb.sourceforge.io</a>). 'RcppCWB' is licensed
  under the GNU GPL-3, in line with the GPL-3 license of the 'CWB' (<a href="https://www.r-project.org/Licenses/GPL-3">https://www.r-project.org/Licenses/GPL-3</a>).
  The 'CWB' relies on 'pcre2' (BSD license, see <a href="http://www.pcre.org/licence.txt">http://www.pcre.org/licence.txt</a>)
  and 'GLib' (LGPL license, see <a href="https://www.gnu.org/licenses/lgpl-3.0.en.html">https://www.gnu.org/licenses/lgpl-3.0.en.html</a>).
  See the file LICENSE.note for further information. The package includes modified code of the
  'rcqp' package (GPL-2, see <a href="https://cran.r-project.org/package=rcqp">https://cran.r-project.org/package=rcqp</a>). The original work of the authors
  of the 'rcqp' package is acknowledged with great respect, and they are listed as authors of this
  package. To achieve cross-platform portability (including Windows), using 'Rcpp' for wrapper code
  is the approach used by 'RcppCWB'.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Copyright:</td>
<td>For the copyrights for the 'Corpus Workbench' (CWB) and
acknowledgement of authorship, see file COPYRIGHTS.</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make, pcre2 (&gt;= 10.00), GLib (&gt;= 2.0.0). On
Windows, no prior installations are necessary, as pre-built
(i.e. cross-compiled) binaries of required libraries are
downloaded from a GitHub repository
(&lt;https://github.com/PolMine/libcl&gt;) during installation. On
macOS, static libraries of Glib are downloaded
(&lt;https://github.com/PolMine/libglib&gt;) if Glib is not present.</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.10), fs</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, testthat, rmarkdown</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/PolMine/RcppCWB">https://github.com/PolMine/RcppCWB</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/PolMine/RcppCWB/issues">https://github.com/PolMine/RcppCWB/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Collate:</td>
<td>'RcppCWB_package.R' 'cl.R' 'cqp.R' 'cwb.R' 'checks.R'
'count.R' 'RcppExports.R' 'decode.R' 'cbow.R' 'region_matrix.R'
'misc.R' 'zzz.R' 'xml.R'</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-29 14:17:25 UTC; andreasblatte</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-29 21:42:35 UTC</td>
</tr>
</table>
<hr>
<h2 id='RcppCWB-package'>Rcpp Bindings for the Corpus Workbench (CWB).</h2><span id='topic+RcppCWB-package'></span><span id='topic+RcppCWB'></span>

<h3>Description</h3>

<p>The <code>RcppCWB</code> package is a wrapper library to expose core functions of
the <code>Open Corpus Workbench</code> (CWB). This includes the low-level
functionality of the <code>Corpus Library</code> (CL) as well as capacities to use
the query syntax of the <code>Corpus Query Processor</code> (CQP).
</p>


<h3>The Idea Behind RcppCWB</h3>

<p>The <code>Open Corpus Workbench</code> (CWB) is an indexing and querying engine
popular in corpus-assisted research. Its core aim is to support working
efficiently with large, structurally and linguistically annotated corpora.
First of all, the CWB includes tools to index and compress corpora. Second,
the <code>Corpus Library</code> (CL) offers low-level functionality to retrieve
information from CWB indexed corpora. Third, the <code>Corpus Query
  Processor</code> (CQP) offers a syntax that allows to perform anything from
simple to complex queries, using different annotation layers of corpora.
</p>
<p>The CWB is a classical tool which has inspired a set of developments. A
persisting advantage of the CWB is its mature, open source code base that
is actively maintained by a community of developers. It is used as a robust
and efficient backend for widely used tools such as
TXM(<a href="https://txm.gitpages.huma-num.fr/textometrie/">https://txm.gitpages.huma-num.fr/textometrie/</a>) or CQPweb
(<a href="https://cwb.sourceforge.io/cqpweb.php">https://cwb.sourceforge.io/cqpweb.php</a>). Its uncompromising C
implementation guarantees speed and makes it well suited to be integrated
with R at the same time.
</p>
<p>The package <code>RcppCWB</code> is a follow-up on the <code>rcqp</code> package that
has pioneered to expose CWB functionality from within R. Indeed, the
<code>rcqp</code> package, published at CRAN in 2015, offers robust access to CWB
functionality. However, the &quot;pure C&quot; implementation of the <code>rcqp</code>
package creates difficulties to make the package portable to Windows. The
primary purpose of the <code>RcppCWB</code> package is to reimplement a wrapper
library for the CWB using a design that makes it easier to achieve
cross-platform portability.
</p>
<p>Even though <code>RcppCWB</code> functions may be used directly, the package is
designed to serve as an interface to CWB indexed corpora in packages with
higher-level functionality. In this regard, <code>RcppCWB</code> is the backend
of the <code>polmineR</code> package. It is deliberately open to be used in other
contexts. The package may stimulate using linguistically annotated, indexed
and compressed corpora on all platforms. The paradigm of working with text
as linguistic data may benefit from <code>RcppCWB</code>.
</p>


<h3>Implementation</h3>

<p>When building the package, the first step is to compile the relevant parts
of the CWB on Linux and macOS machines. On Windows, cross-compiled binaries
are downloaded from a GitHub repository of the PolMine Project
(<a href="https://github.com/PolMine/libcl">https://github.com/PolMine/libcl</a>). Second, <code>Rcpp</code> wrappers are
compiled and make the relevant functions of the Corpus Library and CQP
accessible. In addition to genuine CWB functions, <code>RcppCWB</code> offers a
set of higher level functions implemented using <code>Rcpp</code> for common
performance critical tasks.
</p>


<h3>Getting Started with RcppCWB</h3>

<p>To understand the data storage model of the CWB, in particular the notions
of positional and structural attributes (s- and p-attributes), the vignette
of the <code>rcqp</code> package is a very good starting point (see references).
</p>
<p>The CWB 'Corpus Encoding Tutorial' explains how to create your own corpus,
the 'CQP Query Language Tutorial' introduces the syntax of CQP (see
references).
</p>
<p>The <code>RcppCWB</code> package includes a sample corpus (REUTERS, the data also
included in the <code>tm</code> package). The examples in the documentation
of the functions may be a good starting point to understand how to use
<code>RcppCWB</code>.
</p>


<h3>Digging Deeper</h3>

<p>The original paper of Christ (1994) explains the design choices of the CWB.
The indexing and compression techniques of the CWB (Huffman coding) are
explained in Witten et al. (1999).
</p>


<h3>Acknowledgements</h3>

<p>The work of the all developers of the CWB is gratefully acknowledged. There
is a particular intellectual debt to Bernard Desgraupes and Sylvain
Loiseau, and the <code>rcqp</code> package they developed as the original R
wrapper to expose the functionality of the CWB.
</p>


<h3>Author(s)</h3>

<p>Andreas Blaette (andreas.blaette@uni-due.de)
</p>


<h3>References</h3>

<p>Christ, O. 1994. &quot;A modular and flexible architecture for an integrated
corpus query system&quot;, in: Proceedings of COMPLEX '94, pp. 23-32. Budapest.
Available online at <a href="https://cwb.sourceforge.io/files/Christ1994.pdf">https://cwb.sourceforge.io/files/Christ1994.pdf</a>
</p>
<p>Desgraupes, B.; Loiseau, S. 2012. Introduction to the rcqp package.
Vignette of the rcqp package. Available at the CRAN archive at
<a href="https://cran.r-project.org/src/contrib/Archive/rcqp/">https://cran.r-project.org/src/contrib/Archive/rcqp/</a>
</p>
<p>Evert, S. 2005. The CQP Query Language Tutorial. Available online at
<a href="https://cwb.sourceforge.io/files/CWB_Encoding_Tutorial.pdf">https://cwb.sourceforge.io/files/CWB_Encoding_Tutorial.pdf</a>
</p>
<p>Evert, S. 2005. The IMS Open Corpus Workbench (CWB). Corpus Encoding
Tutorial. Available online at
<a href="https://cwb.sourceforge.io/files/CWB_Encoding_Tutorial.pdf">https://cwb.sourceforge.io/files/CWB_Encoding_Tutorial.pdf</a>
</p>
<p>Open Corpus Workbench (<a href="https://cwb.sourceforge.io">https://cwb.sourceforge.io</a>)
</p>
<p>Witten, I.H.; Moffat, A.; Bell, T.C. (1999). Managing Gigabytes. Morgan
Kaufmann Publishing, San Francisco, 2nd edition.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># functions of the corpus library (starting with cl) expose the low-level
# access to the CWB corpus library (CL)

ids &lt;- cl_cpos2id("REUTERS", cpos = 1:20, p_attribute = "word", registry = get_tmp_registry())
tokens &lt;- cl_id2str("REUTERS", id = ids, p_attribute = "word", registry = get_tmp_registry())
print(paste(tokens, collapse = " "))

# To use the corpus query processor (CQP) and its syntax, it is necessary first
# to initialize CQP (example: get concordances of 'oil')

cqp_query("REUTERS", query = '[]{5} "oil" []{5}')
cpos_matrix &lt;- cqp_dump_subcorpus("REUTERS")
concordances_oil &lt;- apply(
  cpos_matrix, 1,
  function(row){
    ids &lt;- cl_cpos2id("REUTERS", p_attribute = "word", cpos = row[1]:row[2], get_tmp_registry())
    tokens &lt;- cl_id2str("REUTERS", p_attribute = "word", id = ids, get_tmp_registry())
    paste(tokens, collapse = " ")
  }
 )
</code></pre>

<hr>
<h2 id='attribute_size'>Rcpp wrappers for CWB Corpus Library functions</h2><span id='topic+attribute_size'></span><span id='topic+cpos2str'></span><span id='topic+cpos2id'></span><span id='topic+struc2cpos'></span><span id='topic+id2str'></span>

<h3>Description</h3>

<p>Rcpp wrappers for CWB Corpus Library functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>attribute_size(corpus, attribute, attribute_type, registry)

cpos2str(corpus, p_attribute, registry, cpos)

cpos2id(corpus, p_attribute, registry, cpos)

struc2cpos(corpus, s_attribute, registry, struc)

id2str(corpus, p_attribute, registry, id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="attribute_size_+3A_corpus">corpus</code></td>
<td>
<p>The ID of a CWB corpus.</p>
</td></tr>
<tr><td><code id="attribute_size_+3A_attribute">attribute</code></td>
<td>
<p>Either a positional, or a structural attribute.</p>
</td></tr>
<tr><td><code id="attribute_size_+3A_attribute_type">attribute_type</code></td>
<td>
<p>Either &quot;p&quot; (positional attribute) or &quot;s&quot; (structural attribute).</p>
</td></tr>
<tr><td><code id="attribute_size_+3A_registry">registry</code></td>
<td>
<p>Path to the corpus registry.</p>
</td></tr>
<tr><td><code id="attribute_size_+3A_p_attribute">p_attribute</code></td>
<td>
<p>A positional attribute.</p>
</td></tr>
<tr><td><code id="attribute_size_+3A_cpos">cpos</code></td>
<td>
<p>An integer vector of corpus positions.</p>
</td></tr>
<tr><td><code id="attribute_size_+3A_s_attribute">s_attribute</code></td>
<td>
<p>A structural attribute.</p>
</td></tr>
<tr><td><code id="attribute_size_+3A_struc">struc</code></td>
<td>
<p>An integer value with struc.</p>
</td></tr>
<tr><td><code id="attribute_size_+3A_id">id</code></td>
<td>
<p>An <code>integer</code> vector with token ids.</p>
</td></tr>
</table>

<hr>
<h2 id='check'>Check Input to Rcpp Functions.</h2><span id='topic+check'></span><span id='topic+check_registry'></span><span id='topic+check_corpus'></span><span id='topic+check_s_attribute'></span><span id='topic+check_p_attribute'></span><span id='topic+check_strucs'></span><span id='topic+check_region_matrix'></span><span id='topic+check_query'></span><span id='topic+check_cpos'></span><span id='topic+check_id'></span>

<h3>Description</h3>

<p>A set of functions to check whether the input values to the Rcpp
wrappers for the C functions of the Corpus Workbench potentially causing
crashes are valid. These auxiliary functions are called by the cl_ and cqp_
functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_registry(registry)

check_corpus(corpus, registry, cl = TRUE, cqp = TRUE)

check_s_attribute(
  s_attribute,
  corpus,
  registry = Sys.getenv("CORPUS_REGISTRY")
)

check_p_attribute(
  p_attribute,
  corpus,
  registry = Sys.getenv("CORPUS_REGISTRY")
)

check_strucs(corpus, s_attribute, strucs, registry)

check_region_matrix(region_matrix)

check_query(query)

check_cpos(
  corpus,
  p_attribute = "word",
  cpos,
  registry = Sys.getenv("CORPUS_REGISTRY")
)

check_id(corpus, p_attribute, id, registry = Sys.getenv("CORPUS_REGISTRY"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_+3A_registry">registry</code></td>
<td>
<p>path to registry directory</p>
</td></tr>
<tr><td><code id="check_+3A_corpus">corpus</code></td>
<td>
<p>name of a CWB corpus</p>
</td></tr>
<tr><td><code id="check_+3A_cl">cl</code></td>
<td>
<p>A <code>logical</code> value, whether CL availability of corpus is required
for positive result.</p>
</td></tr>
<tr><td><code id="check_+3A_cqp">cqp</code></td>
<td>
<p>A <code>logical</code> value, whether CQP availability of corpus is required
for positive result.</p>
</td></tr>
<tr><td><code id="check_+3A_s_attribute">s_attribute</code></td>
<td>
<p>a structural attribute</p>
</td></tr>
<tr><td><code id="check_+3A_p_attribute">p_attribute</code></td>
<td>
<p>a positional attribute</p>
</td></tr>
<tr><td><code id="check_+3A_strucs">strucs</code></td>
<td>
<p>strucs (indices of structural attributes)</p>
</td></tr>
<tr><td><code id="check_+3A_region_matrix">region_matrix</code></td>
<td>
<p>a region matrix</p>
</td></tr>
<tr><td><code id="check_+3A_query">query</code></td>
<td>
<p>a CQP query</p>
</td></tr>
<tr><td><code id="check_+3A_cpos">cpos</code></td>
<td>
<p>vector of corpus positions</p>
</td></tr>
<tr><td><code id="check_+3A_id">id</code></td>
<td>
<p>id (encoded p-attribute), integer value</p>
</td></tr>
</table>

<hr>
<h2 id='check_pkg_registry_files'>Check Paths in Registry Files</h2><span id='topic+check_pkg_registry_files'></span>

<h3>Description</h3>

<p>Check Paths in Registry Files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_pkg_registry_files(pkg = system.file(package = "RcppCWB"), set = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_pkg_registry_files_+3A_pkg">pkg</code></td>
<td>
<p>Full path to package directory</p>
</td></tr>
<tr><td><code id="check_pkg_registry_files_+3A_set">set</code></td>
<td>
<p>Logical, whether</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical value, whether home directories are set correctly.
</p>

<hr>
<h2 id='cl_attribute_size'>Get Attribute Size (of Positional/Structural Attribute).</h2><span id='topic+cl_attribute_size'></span>

<h3>Description</h3>

<p>Use <code>cl_attribute_size()</code> to get the total number of values of a positional
attribute (param <code>attribute_type</code> = &quot;p&quot;), or structural attribute (param
<code>attribute_type</code> = &quot;s&quot;). Note that indices are zero-based, i.e. the maximum
position of a positional / structural attribute is attribute size minus 1
(see examples).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cl_attribute_size(
  corpus,
  attribute,
  attribute_type,
  registry = Sys.getenv("CORPUS_REGISTRY")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cl_attribute_size_+3A_corpus">corpus</code></td>
<td>
<p>name of a CWB corpus (upper case)</p>
</td></tr>
<tr><td><code id="cl_attribute_size_+3A_attribute">attribute</code></td>
<td>
<p>name of a p- or s-attribute</p>
</td></tr>
<tr><td><code id="cl_attribute_size_+3A_attribute_type">attribute_type</code></td>
<td>
<p>either &quot;p&quot; or &quot;s&quot;, for structural/positional attribute</p>
</td></tr>
<tr><td><code id="cl_attribute_size_+3A_registry">registry</code></td>
<td>
<p>path to the registry directory, defaults to the value of the
environment variable CORPUS_REGISTRY</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>token_no &lt;- cl_attribute_size(
  "REUTERS",
  attribute = "word",
  attribute_type = "p",
  registry = get_tmp_registry()
)
corpus_positions &lt;- seq.int(from = 0, to = token_no - 1)
cl_cpos2id(
  "REUTERS",
  "word",
  cpos = corpus_positions,
  registry = get_tmp_registry()
)

places_no &lt;- cl_attribute_size(
  "REUTERS",
  attribute = "places",
  attribute_type = "s",
  registry = get_tmp_registry()
)
strucs &lt;- seq.int(from = 0, to = places_no - 1)
cl_struc2str(
  "REUTERS",
  "places",
  struc = strucs,
  registry = get_tmp_registry()
)
</code></pre>

<hr>
<h2 id='cl_charset_name'>Get charset of a corpus.</h2><span id='topic+cl_charset_name'></span>

<h3>Description</h3>

<p>The encoding of a corpus is declared in the registry file (corpus property
&quot;charset&quot;). Once a corpus is loaded, this information is available without
parsing the registry file again and again. The <code>cl_charset_name</code> offers
a quick access to this information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cl_charset_name(corpus, registry = Sys.getenv("CORPUS_REGISTRY"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cl_charset_name_+3A_corpus">corpus</code></td>
<td>
<p>Name of a CWB corpus (upper case).</p>
</td></tr>
<tr><td><code id="cl_charset_name_+3A_registry">registry</code></td>
<td>
<p>Path to the registry directory, defaults to the value of the
environment variable CORPUS_REGISTRY</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>cl_charset_name(
  corpus = "REUTERS",
  registry = system.file(package = "RcppCWB", "extdata", "cwb", "registry")
)
</code></pre>

<hr>
<h2 id='cl_delete_corpus'>Drop loaded corpus.</h2><span id='topic+cl_delete_corpus'></span>

<h3>Description</h3>

<p>Remove a corpus from the list of loaded corpora of the corpus library (CL).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cl_delete_corpus(corpus, registry = Sys.getenv("CORPUS_REGISTRY"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cl_delete_corpus_+3A_corpus">corpus</code></td>
<td>
<p>name of a CWB corpus (upper case)</p>
</td></tr>
<tr><td><code id="cl_delete_corpus_+3A_registry">registry</code></td>
<td>
<p>path to the registry directory, defaults to the value of the
environment variable CORPUS_REGISTRY</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The corpus library (CL) internally maintains a list of corpora including
information on positional and structural attributes so that the registry file
needs not be parsed again and again. However, when an attribute has been
added to the corpus, it will not yet be visible, because it is not part of
the data that has been loaded. The <code>cl_delete_corpus</code> function exposes a
CL function named identically, to force reloading the corpus (after it has
been deleted), which will include parsing an updated registry file.
</p>


<h3>Value</h3>

<p>An <code>integer</code> value 1 is returned invisibly if a previously loaded
corpus has been deleted, or 0 if the corpus has not been loaded and has not
been deleted.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cl_attribute_size("UNGA", attribute = "word", attribute_type = "p")
corpus_is_loaded("UNGA")
cl_delete_corpus("UNGA")
corpus_is_loaded("UNGA")
</code></pre>

<hr>
<h2 id='cl_find_corpus'>Load corpus.</h2><span id='topic+cl_find_corpus'></span>

<h3>Description</h3>

<p>Load corpus.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cl_find_corpus(corpus, registry)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cl_find_corpus_+3A_corpus">corpus</code></td>
<td>
<p>name of a CWB corpus (upper case)</p>
</td></tr>
<tr><td><code id="cl_find_corpus_+3A_registry">registry</code></td>
<td>
<p>path to the registry directory, defaults to the value of the
environment variable CORPUS_REGISTRY</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>externalptr</code> referencing the C representation of the corpus.
</p>

<hr>
<h2 id='cl_lexicon_size'>Get Lexicon Size.</h2><span id='topic+cl_lexicon_size'></span>

<h3>Description</h3>

<p>Get the total number of unique tokens/ids of a positional attribute. Note
that token ids are zero-based, i.e. when iterating through tokens, start at
0, the maximum will be <code>cl_lexicon_size()</code> minus 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cl_lexicon_size(corpus, p_attribute, registry = Sys.getenv("CORPUS_REGISTRY"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cl_lexicon_size_+3A_corpus">corpus</code></td>
<td>
<p>name of a CWB corpus (upper case)</p>
</td></tr>
<tr><td><code id="cl_lexicon_size_+3A_p_attribute">p_attribute</code></td>
<td>
<p>name of positional attribute</p>
</td></tr>
<tr><td><code id="cl_lexicon_size_+3A_registry">registry</code></td>
<td>
<p>path to the registry directory, defaults to the value of the
environment variable CORPUS_REGISTRY</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>lexicon_size &lt;- cl_lexicon_size(
  "REUTERS",
  p_attribute = "word",
  registry = get_tmp_registry()
)

token_ids &lt;- seq.int(from = 0, to = lexicon_size - 1)
cl_id2str(
  "REUTERS",
  p_attribute = "word",
  id = token_ids,
  registry = get_tmp_registry()
)
</code></pre>

<hr>
<h2 id='cl_list_corpora'>Show CL corpora</h2><span id='topic+cl_list_corpora'></span>

<h3>Description</h3>

<p>Show CL corpora
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cl_list_corpora()
</code></pre>


<h3>Value</h3>

<p>A <code>character</code> vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cl_list_corpora()
</code></pre>

<hr>
<h2 id='cl_load_corpus'>Load corpus</h2><span id='topic+cl_load_corpus'></span>

<h3>Description</h3>

<p>Load corpus
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cl_load_corpus(corpus, registry = Sys.getenv("CORPUS_REGISTRY"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cl_load_corpus_+3A_corpus">corpus</code></td>
<td>
<p>A length-one <code>character</code> vector with the corpus ID.</p>
</td></tr>
<tr><td><code id="cl_load_corpus_+3A_registry">registry</code></td>
<td>
<p>A length-one <code>character</code> vector with the registry directory.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if corpus could be loaded and <code>FALSE</code> if not.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cl_load_corpus("REUTERS")
</code></pre>

<hr>
<h2 id='cl_rework'>Low-level CL access.</h2><span id='topic+cl_rework'></span><span id='topic+s_attr'></span><span id='topic+p_attr'></span><span id='topic+p_attr_size'></span><span id='topic+s_attr_size'></span><span id='topic+p_attr_lexicon_size'></span><span id='topic+cpos_to_struc'></span><span id='topic+cpos_to_str'></span><span id='topic+cpos_to_id'></span><span id='topic+struc_to_cpos'></span><span id='topic+struc_to_str'></span><span id='topic+regex_to_id'></span><span id='topic+str_to_id'></span><span id='topic+id_to_freq'></span><span id='topic+id_to_cpos'></span><span id='topic+cpos_to_lbound'></span><span id='topic+cpos_to_rbound'></span>

<h3>Description</h3>

<p>Wrappers for CWB Corpus Library functions suited for writing performance
code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s_attr(corpus, s_attribute, registry)

p_attr(corpus, p_attribute, registry)

p_attr_size(p_attr)

s_attr_size(s_attr)

p_attr_lexicon_size(p_attr)

cpos_to_struc(s_attr, cpos)

cpos_to_str(p_attr, cpos)

cpos_to_id(p_attr, cpos)

struc_to_cpos(s_attr, struc)

struc_to_str(s_attr, struc)

regex_to_id(p_attr, regex)

str_to_id(p_attr, str)

id_to_freq(p_attr, id)

id_to_cpos(p_attr, id)

cpos_to_lbound(s_attr, cpos)

cpos_to_rbound(s_attr, cpos)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cl_rework_+3A_corpus">corpus</code></td>
<td>
<p>ID of a CWB corpus (length-one <code>character</code> vector).</p>
</td></tr>
<tr><td><code id="cl_rework_+3A_s_attribute">s_attribute</code></td>
<td>
<p>A structural attribute (length-one <code>character</code> vector).</p>
</td></tr>
<tr><td><code id="cl_rework_+3A_registry">registry</code></td>
<td>
<p>Registry directory.</p>
</td></tr>
<tr><td><code id="cl_rework_+3A_p_attribute">p_attribute</code></td>
<td>
<p>A positional attribute (length-one <code>character</code> vector).</p>
</td></tr>
<tr><td><code id="cl_rework_+3A_p_attr">p_attr</code></td>
<td>
<p>A <code>externalptr</code> referencing a p-attribute.</p>
</td></tr>
<tr><td><code id="cl_rework_+3A_s_attr">s_attr</code></td>
<td>
<p>A <code>externalptr</code> referencing a p-attribute.</p>
</td></tr>
<tr><td><code id="cl_rework_+3A_cpos">cpos</code></td>
<td>
<p>An <code>integer</code> vector of corpus positions.</p>
</td></tr>
<tr><td><code id="cl_rework_+3A_struc">struc</code></td>
<td>
<p>A length-one <code>integer</code> vector with a struc.</p>
</td></tr>
<tr><td><code id="cl_rework_+3A_regex">regex</code></td>
<td>
<p>A regular expression.</p>
</td></tr>
<tr><td><code id="cl_rework_+3A_str">str</code></td>
<td>
<p>A <code>character</code> vector.</p>
</td></tr>
<tr><td><code id="cl_rework_+3A_id">id</code></td>
<td>
<p>An <code>integer</code> vector with token ids.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default cl_* R wrappers for the functions of the CWB Corpus Library
involve a lookup of a corpus and its p- or s-attributes (using the corpus ID,
registry and attribute indicated by length-one character vectors) every time
one of these functions is called. It is more efficient looking up an
attribute only once. This set of functions passes &quot;externalptr&quot; classes to
reference attributes that have been looked up. A relevant scenario is writing
functions with a C++ implementation that are compiled and linked using
<code>Rcpp::cppFunction()</code> or <code>Rcpp::sourceCpp()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(Rcpp)

cppFunction(
  'Rcpp::StringVector get_str(
     SEXP corpus,
     SEXP p_attribute,
     SEXP registry,
     Rcpp::IntegerVector cpos
   ){
     SEXP attr;
     Rcpp::StringVector result;
     attr = RcppCWB::p_attr(corpus, p_attribute, registry);
     result = RcppCWB::cpos_to_str(attr, cpos);
     return(result);
  }',
  depends = "RcppCWB"
)

result &lt;- get_str("REUTERS", "word", RcppCWB::get_tmp_registry(), 0:50)

</code></pre>

<hr>
<h2 id='cl_struc_values'>Check whether structural attribute has values</h2><span id='topic+cl_struc_values'></span>

<h3>Description</h3>

<p>Structural attributes do not necessarily have values, structural attributes
(such as annotations of sentences or paragraphs) may just define regions of
corpus positions. Use this function to test whether an attribute has values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cl_struc_values(corpus, s_attribute, registry = Sys.getenv("CORPUS_REGISTRY"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cl_struc_values_+3A_corpus">corpus</code></td>
<td>
<p>Corpus ID, a length-one <code>character</code> vector.</p>
</td></tr>
<tr><td><code id="cl_struc_values_+3A_s_attribute">s_attribute</code></td>
<td>
<p>Structural attribute to check, a length-one <code>character</code> vector.</p>
</td></tr>
<tr><td><code id="cl_struc_values_+3A_registry">registry</code></td>
<td>
<p>The registry directory of the corpus.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if the attribute has values and <code>FALSE</code> if not. <code>NA</code> if the structural
attribute is not available.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cl_struc_values("REUTERS", "places") # TRUE - attribute has values
cl_struc_values("REUTERS", "date") # NA - attribute does not exist
</code></pre>

<hr>
<h2 id='CL+3A+20p_attributes'>Using Positional Attributes.</h2><span id='topic+CL+3A+20p_attributes'></span><span id='topic+cl_cpos2str'></span><span id='topic+cl_cpos2id'></span><span id='topic+cl_id2str'></span><span id='topic+cl_regex2id'></span><span id='topic+cl_str2id'></span><span id='topic+cl_id2freq'></span><span id='topic+cl_id2cpos'></span>

<h3>Description</h3>

<p>CWB indexed corpora store the text of a corpus as numbers: Every token
in the token stream of the corpus is identified by a unique corpus
position. The string value of every token is identified by a unique integer
id. The corpus library (CL) offers a set of functions to make the transitions
between corpus positions, token ids, and the character string of tokens.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cl_cpos2str(
  corpus,
  p_attribute,
  registry = Sys.getenv("CORPUS_REGISTRY"),
  cpos
)

cl_cpos2id(corpus, p_attribute, registry = Sys.getenv("CORPUS_REGISTRY"), cpos)

cl_id2str(corpus, p_attribute, registry = Sys.getenv("CORPUS_REGISTRY"), id)

cl_regex2id(
  corpus,
  p_attribute,
  regex,
  registry = Sys.getenv("CORPUS_REGISTRY")
)

cl_str2id(corpus, p_attribute, str, registry = Sys.getenv("CORPUS_REGISTRY"))

cl_id2freq(corpus, p_attribute, id, registry = Sys.getenv("CORPUS_REGISTRY"))

cl_id2cpos(corpus, p_attribute, id, registry = Sys.getenv("CORPUS_REGISTRY"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CL+2B3A+2B20p_attributes_+3A_corpus">corpus</code></td>
<td>
<p>name of a CWB corpus (upper case)</p>
</td></tr>
<tr><td><code id="CL+2B3A+2B20p_attributes_+3A_p_attribute">p_attribute</code></td>
<td>
<p>a p-attribute (positional attribute)</p>
</td></tr>
<tr><td><code id="CL+2B3A+2B20p_attributes_+3A_registry">registry</code></td>
<td>
<p>path to the registry directory, defaults to the value of the
environment variable CORPUS_REGISTRY</p>
</td></tr>
<tr><td><code id="CL+2B3A+2B20p_attributes_+3A_cpos">cpos</code></td>
<td>
<p>corpus positions (integer vector)</p>
</td></tr>
<tr><td><code id="CL+2B3A+2B20p_attributes_+3A_id">id</code></td>
<td>
<p>id of a token</p>
</td></tr>
<tr><td><code id="CL+2B3A+2B20p_attributes_+3A_regex">regex</code></td>
<td>
<p>a regular expression</p>
</td></tr>
<tr><td><code id="CL+2B3A+2B20p_attributes_+3A_str">str</code></td>
<td>
<p>a character string</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># registry directory and cpos_total will be needed in examples
cpos_total &lt;- cl_attribute_size(
  corpus = "REUTERS", attribute = "word",
  attribute_type = "p", registry = get_tmp_registry()
  )

# decode the token stream of the corpus (the quick way)
token_stream_str &lt;- cl_cpos2str(
  corpus = "REUTERS", p_attribute = "word",
  cpos = seq.int(from = 0, to = cpos_total - 1),
  registry = get_tmp_registry()
  )
  
# decode the token stream (cpos2id first, then id2str)
token_stream_ids &lt;- cl_cpos2id(
  corpus = "REUTERS", p_attribute = "word",
  cpos = seq.int(from = 0, to = cpos_total - 1),
  registry = get_tmp_registry()
  )
token_stream_str &lt;- cl_id2str(
  corpus = "REUTERS", p_attribute = "word",
  id = token_stream_ids, registry = get_tmp_registry()
)

# get corpus positions of a token
token_to_get &lt;- "oil"
id_oil &lt;- cl_str2id(
  corpus = "REUTERS", p_attribute = "word",
  str = token_to_get, registry = get_tmp_registry()
  )
cpos_oil &lt;- cl_id2cpos &lt;- cl_id2cpos(
  corpus = "REUTERS", p_attribute = "word",
  id = id_oil, registry = get_tmp_registry()
)

# get frequency of token
oil_freq &lt;- cl_id2freq(
  corpus = "REUTERS", p_attribute = "word", id = id_oil, registry = get_tmp_registry()
)
length(cpos_oil) # needs to be the same as oil_freq

# use regular expressions 
ids &lt;- cl_regex2id(
  corpus = "REUTERS", p_attribute = "word",
  regex = "M.*", registry = get_tmp_registry()
)
m_words &lt;- cl_id2str(
  corpus = "REUTERS", p_attribute = "word",
  id = ids, registry = get_tmp_registry()
)

</code></pre>

<hr>
<h2 id='CL+3A+20s_attributes'>Using Structural Attributes.</h2><span id='topic+CL+3A+20s_attributes'></span><span id='topic+cl_cpos2struc'></span><span id='topic+cl_struc2cpos'></span><span id='topic+cl_struc2str'></span><span id='topic+cl_cpos2lbound'></span><span id='topic+cl_cpos2rbound'></span>

<h3>Description</h3>

<p>Structural attributes store the metadata of texts in a CWB
corpus and/or any kind of annotation of a region of text. The fundamental
unit are so-called strucs, i.e. indices of regions identified by a left and
a right corpus position. The corpus library (CL) offers a set of functions
to make the translations between corpus positions (cpos) and strucs
(struc).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cl_cpos2struc(
  corpus,
  s_attribute,
  cpos,
  registry = Sys.getenv("CORPUS_REGISTRY")
)

cl_struc2cpos(
  corpus,
  s_attribute,
  registry = Sys.getenv("CORPUS_REGISTRY"),
  struc
)

cl_struc2str(
  corpus,
  s_attribute,
  struc,
  registry = Sys.getenv("CORPUS_REGISTRY")
)

cl_cpos2lbound(corpus, s_attribute, cpos, registry = NULL)

cl_cpos2rbound(corpus, s_attribute, cpos, registry = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CL+2B3A+2B20s_attributes_+3A_corpus">corpus</code></td>
<td>
<p>name of a CWB corpus (upper case)</p>
</td></tr>
<tr><td><code id="CL+2B3A+2B20s_attributes_+3A_s_attribute">s_attribute</code></td>
<td>
<p>name of structural attribute (character vector)</p>
</td></tr>
<tr><td><code id="CL+2B3A+2B20s_attributes_+3A_cpos">cpos</code></td>
<td>
<p>An <code>integer</code> vector with corpus positions.</p>
</td></tr>
<tr><td><code id="CL+2B3A+2B20s_attributes_+3A_registry">registry</code></td>
<td>
<p>path to the registry directory, defaults to the value of the
environment variable CORPUS_REGISTRY</p>
</td></tr>
<tr><td><code id="CL+2B3A+2B20s_attributes_+3A_struc">struc</code></td>
<td>
<p>a struc identifying a region</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>cl_cpos2rbound()</code> and <code>cl_cpos2lbound()</code> return <code>NA</code> for values of
cpos that are outside a struc for the structural attribute given.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get metadata for matches of token
# scenario: id of the texts with occurrence of 'oil'
token_to_get &lt;- "oil"
token_id &lt;- cl_str2id("REUTERS", p_attribute = "word", str = "oil", get_tmp_registry())
token_cpos &lt;- cl_id2cpos("REUTERS", p_attribute = "word", id = token_id, get_tmp_registry())
strucs &lt;- cl_cpos2struc("REUTERS", s_attribute = "id", cpos = token_cpos, get_tmp_registry())
strucs_unique &lt;- unique(strucs)
text_ids &lt;- cl_struc2str("REUTERS", s_attribute = "id", struc = strucs_unique, get_tmp_registry())

# get the full text of the first text with match for 'oil'
left_cpos &lt;- cl_cpos2lbound(
  "REUTERS", s_attribute = "id",
  cpos = min(token_cpos),
  registry = get_tmp_registry()
)
right_cpos &lt;- cl_cpos2rbound(
  "REUTERS",
  s_attribute = "id",
  cpos = min(token_cpos),
  registry = get_tmp_registry()
)
txt &lt;- cl_cpos2str(
  "REUTERS", p_attribute = "word",
  cpos = left_cpos:right_cpos,
  registry = get_tmp_registry()
)
fulltext &lt;- paste(txt, collapse = " ")

# alternativ approach to achieve same result
first_struc_match_oil &lt;- cl_cpos2struc(
  "REUTERS", s_attribute = "id",
  cpos = min(token_cpos),
  registry = get_tmp_registry()
  )
cpos_struc &lt;- cl_struc2cpos(
  "REUTERS", s_attribute = "id",
  struc = first_struc_match_oil,
  registry = get_tmp_registry()
)
txt &lt;- cl_cpos2str(
  "REUTERS",
  p_attribute = "word",
  cpos = cpos_struc[1]:cpos_struc[2],
  registry = get_tmp_registry()
)
fulltext &lt;- paste(txt, collapse = " ")
</code></pre>

<hr>
<h2 id='corpus_data_dir'>Get information from registry file</h2><span id='topic+corpus_data_dir'></span><span id='topic+corpus_info_file'></span><span id='topic+corpus_full_name'></span><span id='topic+corpus_p_attributes'></span><span id='topic+corpus_s_attributes'></span><span id='topic+corpus_properties'></span><span id='topic+corpus_property'></span><span id='topic+corpus_registry_dir'></span>

<h3>Description</h3>

<p>Extract information from the internal C representation of registry data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corpus_data_dir(corpus, registry = Sys.getenv("CORPUS_REGISTRY"))

corpus_info_file(corpus, registry = Sys.getenv("CORPUS_REGISTRY"))

corpus_full_name(corpus, registry = Sys.getenv("CORPUS_REGISTRY"))

corpus_p_attributes(corpus, registry = Sys.getenv("CORPUS_REGISTRY"))

corpus_s_attributes(corpus, registry = Sys.getenv("CORPUS_REGISTRY"))

corpus_properties(corpus, registry = Sys.getenv("CORPUS_REGISTRY"))

corpus_property(corpus, registry = Sys.getenv("CORPUS_REGISTRY"), property)

corpus_registry_dir(corpus)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corpus_data_dir_+3A_corpus">corpus</code></td>
<td>
<p>A length-one <code>character</code> vector with the corpus ID.</p>
</td></tr>
<tr><td><code id="corpus_data_dir_+3A_registry">registry</code></td>
<td>
<p>A length-one <code>character</code> vector with the registry directory.</p>
</td></tr>
<tr><td><code id="corpus_data_dir_+3A_property">property</code></td>
<td>
<p>A corpus property defined in the registry file (.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>corpus_data_dir()</code> will return the data directory (class <code>fs_path</code>)
where the binary files of a corpus are kept (a directory also known as
'home' directory).
</p>
<p><code>corpus_info_file()</code> will return the path to the info file for a
corpus (class <code>fs_path</code> object). If info file does not exist or INFO line
is missing in the registry file, <code>NA</code> is returned.
</p>
<p><code>corpus_full_name()</code> will return the full name of the corpus defined
in the registry file.
</p>
<p><code>corpus_p_attributes()</code> returns a <code>character</code> vector with the
positional attributes of a corpus.
</p>
<p><code>corpus_s_attributes()</code> returns a <code>character</code> vector with the
structural attributes of a corpus.
</p>
<p><code>corpus_properties()</code> returns a <code>character</code> vector with the corpus
properties defined in the registry file. If the corpus cannot be located,
<code>NA</code> is returned.
</p>
<p><code>corpus_property()</code> returns the value of a corpus property defined
in the registry file, or <code>NA</code> if the corpus does not exist, is not loaded
of if the property requested is undefined.
</p>
<p><code>corpus_get_registry()</code> will extract the registry directory with the
registry file defining a corpus from the internal C representation of
loaded corpora. The <code>character</code> vector that is returned may be &gt; 1 if there
are several corpora with the same id defined in registry files in different
(registry) directories. If the corpus is not found, <code>NA</code> is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>corpus_data_dir("REUTERS", registry = get_tmp_registry())
corpus_info_file("REUTERS", registry = get_tmp_registry())
corpus_full_name("REUTERS", registry = get_tmp_registry())
corpus_p_attributes("REUTERS", registry = get_tmp_registry())
corpus_s_attributes("REUTERS", registry = get_tmp_registry())
corpus_properties("REUTERS", registry = get_tmp_registry())
corpus_property(
  "REUTERS",
  registry = get_tmp_registry(),
  property = "language"
)
corpus_registry_dir("REUTERS")
corpus_registry_dir("FOO") # NA returned
</code></pre>

<hr>
<h2 id='corpus_is_loaded'>Check whether corpus is loaded</h2><span id='topic+corpus_is_loaded'></span>

<h3>Description</h3>

<p>Check whether corpus is loaded
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corpus_is_loaded(corpus, registry = Sys.getenv("CORPUS_REGISTRY"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corpus_is_loaded_+3A_corpus">corpus</code></td>
<td>
<p>A length-one <code>character</code> vector with the corpus ID.</p>
</td></tr>
<tr><td><code id="corpus_is_loaded_+3A_registry">registry</code></td>
<td>
<p>A length-one <code>character</code> vector with the registry directory.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if corpus is loaded and <code>FALSE</code> if not.
</p>

<hr>
<h2 id='cqp_initialize'>Initialize Corpus Query Processor (CQP).</h2><span id='topic+cqp_initialize'></span><span id='topic+cqp_is_initialized'></span><span id='topic+cqp_verbosity'></span><span id='topic+cqp_get_registry'></span><span id='topic+cqp_reset_registry'></span><span id='topic+cqp_load_corpus'></span>

<h3>Description</h3>

<p>CQP needs to know where to look for CWB indexed corpora. To initialize CQP,
call <code>cqp_initialize</code>. To reset the registry, use the function
<code>cqp_reset_registry</code>. To get the registry used by CQP, use
<code>cqp_get_registry</code>. To get the initialization status, use
<code>cqp_is_initialized</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cqp_initialize(registry = Sys.getenv("CORPUS_REGISTRY"))

cqp_is_initialized()

cqp_verbosity(silent, verbose)

cqp_get_registry()

cqp_reset_registry(registry = Sys.getenv("CORPUS_REGISTRY"))

cqp_load_corpus(corpus, registry)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cqp_initialize_+3A_registry">registry</code></td>
<td>
<p>the registry directory</p>
</td></tr>
<tr><td><code id="cqp_initialize_+3A_silent">silent</code></td>
<td>
<p>A single <code>logical</code> value, whether to be silent and suppress CQP
messages (<code>TRUE</code>), or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="cqp_initialize_+3A_verbose">verbose</code></td>
<td>
<p>A single <code>logical</code> value, whether to show verbose parser
output (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="cqp_initialize_+3A_corpus">corpus</code></td>
<td>
<p>ID of a CWB corpus (length-one <code>character</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>cqp_load_corpus</code> will return a <code>logical</code> value - <code>TRUE</code> if corpus
has been loaded successfully, <code>FALSE</code> if not.
</p>


<h3>Author(s)</h3>

<p>Andreas Blaette, Bernard Desgraupes, Sylvain Loiseau
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cqp_is_initialized() # check initialization status
if (!cqp_is_initialized()) cqp_initialize()
cqp_is_initialized() # check initialization status (TRUE now?)
cqp_get_registry() # get registry dir used by CQP
cqp_list_corpora() # get list of corpora
</code></pre>

<hr>
<h2 id='cqp_list_corpora'>List Available CWB Corpora.</h2><span id='topic+cqp_list_corpora'></span>

<h3>Description</h3>

<p>List the corpora described by the registry files in the registry directory
that is currently set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cqp_list_corpora()
</code></pre>


<h3>Author(s)</h3>

<p>Andreas Blaette, Bernard Desgraupes, Sylvain Loiseau
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cqp_list_corpora()
</code></pre>

<hr>
<h2 id='cqp_query'>Execute CQP Query and Retrieve Results.</h2><span id='topic+cqp_query'></span><span id='topic+cqp_dump_subcorpus'></span><span id='topic+cqp_subcorpus_size'></span><span id='topic+cqp_list_subcorpora'></span><span id='topic+cqp_drop_subcorpus'></span>

<h3>Description</h3>

<p>Using CQP queries requires a two-step procedure: At first, you execute a
query using <code>cqp_query</code>. Then, <code>cqp_dump_subcorpus</code> will return a
matrix with the regions of the matches for the query.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cqp_query(corpus, query, subcorpus = "QUERY")

cqp_dump_subcorpus(corpus, subcorpus = "QUERY")

cqp_subcorpus_size(corpus, subcorpus = "QUERY")

cqp_list_subcorpora(corpus)

cqp_drop_subcorpus(corpus)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cqp_query_+3A_corpus">corpus</code></td>
<td>
<p>a CWB corpus</p>
</td></tr>
<tr><td><code id="cqp_query_+3A_query">query</code></td>
<td>
<p>a CQP query</p>
</td></tr>
<tr><td><code id="cqp_query_+3A_subcorpus">subcorpus</code></td>
<td>
<p>subcorpus name</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>cqp_query</code> function executes a CQP query. The
<code>cqp_subcorpus_size</code> function returns the number of matches for the CQP
query. The <code>cqp_dump_subcorpus</code> function will return a two-column matrix
with the left and right corpus positions of the matches for the CQP query.
</p>


<h3>Author(s)</h3>

<p>Andreas Blaette, Bernard Desgraupes, Sylvain Loiseau
</p>


<h3>References</h3>

<p>Evert, S. 2005. The CQP Query Language Tutorial. Available online at
<a href="https://cwb.sourceforge.io/files/CWB_Encoding_Tutorial.pdf">https://cwb.sourceforge.io/files/CWB_Encoding_Tutorial.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cqp_query(corpus = "REUTERS", query = '"oil";')
cqp_subcorpus_size("REUTERS")
cqp_dump_subcorpus("REUTERS")

cqp_query(corpus = "REUTERS", query = '"crude" "oil";')
cqp_subcorpus_size("REUTERS", subcorpus = "QUERY")
cqp_dump_subcorpus("REUTERS")
</code></pre>

<hr>
<h2 id='cwb_charsets'>Character sets supported by CWB</h2><span id='topic+cwb_charsets'></span>

<h3>Description</h3>

<p>The function returns a <code>character</code> vector with characters sets (charsets)
supported by the Corpus Workbench (CWB). The vector is derived from the the
<code>CorpusCharset</code> object defined in the header file of the corpus library (CL).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cwb_charsets()
</code></pre>


<h3>Details</h3>

<p>Early versions of the CWB were developed for &quot;latin1&quot;, &quot;utf8&quot; support has
been introduced with CWB v3.2. Note that RcppCWB is tested only for &quot;latin1&quot;
and &quot;utf8&quot; and that R uses &quot;UTF-8&quot; rather than utf8&quot; (CWB) by convention.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cwb_charsets()
</code></pre>

<hr>
<h2 id='cwb_encode'>CWB Tools for Creating Corpora</h2><span id='topic+cwb_encode'></span><span id='topic+cwb_makeall'></span><span id='topic+cwb_huffcode'></span><span id='topic+cwb_compress_rdx'></span>

<h3>Description</h3>

<p>Wrappers for the CWB tools <code>cwb-makeall</code>, <code>cwb-huffcode</code> and
<code>cwb-compress-rdx</code>. Unlike the 'original' command line tools, these wrappers
will always perform a specific indexing/compression step on one positional
attribute, and produce all components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cwb_encode(
  corpus,
  registry = Sys.getenv("CORPUS_REGISTRY"),
  data_dir,
  vrt_dir,
  encoding = "utf8",
  p_attributes = c("word", "pos", "lemma"),
  s_attributes = list(),
  skip_blank_lines = TRUE,
  strip_whitespace = TRUE,
  xml = TRUE,
  quietly = FALSE,
  verbose = FALSE
)

cwb_makeall(
  corpus,
  p_attribute,
  registry = Sys.getenv("CORPUS_REGISTRY"),
  quietly = FALSE,
  logfile
)

cwb_huffcode(
  corpus,
  p_attribute,
  registry = Sys.getenv("CORPUS_REGISTRY"),
  quietly = FALSE,
  logfile,
  delete = TRUE
)

cwb_compress_rdx(
  corpus,
  p_attribute,
  registry = Sys.getenv("CORPUS_REGISTRY"),
  quietly = FALSE,
  logfile,
  delete = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cwb_encode_+3A_corpus">corpus</code></td>
<td>
<p>Name of a CWB corpus (upper case).</p>
</td></tr>
<tr><td><code id="cwb_encode_+3A_registry">registry</code></td>
<td>
<p>Path to the registry directory, defaults to the value of the
environment variable CORPUS_REGISTRY.</p>
</td></tr>
<tr><td><code id="cwb_encode_+3A_data_dir">data_dir</code></td>
<td>
<p>The data directory where <code>cwb_encode</code> will save the binary
files of the indexed corpus.  Tilde expansion is performed on <code>data_dir</code>
using <code>path.expand()</code> to avoid a crash.</p>
</td></tr>
<tr><td><code id="cwb_encode_+3A_vrt_dir">vrt_dir</code></td>
<td>
<p>Directory with input corpus files (verticalised format / file
ending *.vrt). Tilde expansion is performed on <code>vrt_dir</code> using
<code>path.expand()</code> to avoid a crash.</p>
</td></tr>
<tr><td><code id="cwb_encode_+3A_encoding">encoding</code></td>
<td>
<p>The encoding of the files to be encoded. Needs to be an
encoding supported by CWB, see <code>cwb_charsets()</code>. &quot;UTF-8&quot; is taken as
&quot;utf8&quot;. Defaults to &quot;utf8&quot; (recommended charset).</p>
</td></tr>
<tr><td><code id="cwb_encode_+3A_p_attributes">p_attributes</code></td>
<td>
<p>Positional attributes (p-attributes) to be declared.</p>
</td></tr>
<tr><td><code id="cwb_encode_+3A_s_attributes">s_attributes</code></td>
<td>
<p>A <code>list</code> of named <code>character</code> vectors to declare
structural attributes that shall be encoded. The names of the list are the
XML elements present in the corpus. Character vectors making up the list
declare the attributes that include the metadata of regions. To declare a
structural attribute without annotations, provide a zero-length character
vector using <code>character()</code> - see examples.</p>
</td></tr>
<tr><td><code id="cwb_encode_+3A_skip_blank_lines">skip_blank_lines</code></td>
<td>
<p>A <code>logical</code> value, whether to skip blank lines in the
input.</p>
</td></tr>
<tr><td><code id="cwb_encode_+3A_strip_whitespace">strip_whitespace</code></td>
<td>
<p>A <code>logical</code> value, whether to strip whitespace from
tokens</p>
</td></tr>
<tr><td><code id="cwb_encode_+3A_xml">xml</code></td>
<td>
<p>A <code>logical</code> value, whether input is XML.</p>
</td></tr>
<tr><td><code id="cwb_encode_+3A_quietly">quietly</code></td>
<td>
<p>A <code>logical</code> value, whether to turn off messages (including
warnings).</p>
</td></tr>
<tr><td><code id="cwb_encode_+3A_verbose">verbose</code></td>
<td>
<p>A <code>logical</code> value, whether to show progress information
(counter of tokens processed).</p>
</td></tr>
<tr><td><code id="cwb_encode_+3A_p_attribute">p_attribute</code></td>
<td>
<p>Name of p-attribute.</p>
</td></tr>
<tr><td><code id="cwb_encode_+3A_logfile">logfile</code></td>
<td>
<p>Redirect messages of <code>cwb_makeall()</code>, <code>cwb_huffcode()</code> or
<code>cwb_compress_rdx()</code> to this file. Requires that quietly is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="cwb_encode_+3A_delete">delete</code></td>
<td>
<p>A <code>logical</code> value, whether to remove redundant file
(p_attribute).corpus after compression.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Running <code>cwb_huffcode()</code> and <code>cwb_compress_rdx()</code> is optional. Corpora can be
fully used without compression. It is recommended when reducing the size of
corpus data has relevant benefits, e.g. for sharing data. On Windows,
compression is not stable and not recommended. A respective warning
is issued when running <code>cwb_huffcode()</code> and <code>cwb_compress_rdx()</code> on Windows.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data_dir &lt;- file.path(tempdir(), "bt_data_dir")
dir.create(data_dir)

cwb_encode(
  corpus = "BTMIN",
  registry = Sys.getenv("CORPUS_REGISTRY"),
  vrt_dir = system.file(package = "RcppCWB", "extdata", "vrt"),
  data_dir = data_dir,
  p_attributes = c("word", "pos", "lemma"),
  s_attributes = list(
    plenary_protocol = c(
      "lp", "protocol_no", "date", "year", "birthday", "version",
      "url", "filetype"
    ),
    speaker = c(
      "id", "type", "lp", "protocol_no", "date", "year", "ai_no", "ai_id",
      "ai_type", "who", "name", "parliamentary_group", "party", "role"
     ),
    p = character()
  )
)

unlink(data_dir)
unlink(file.path(Sys.getenv("CORPUS_REGISTRY"), "btmin"))
# The package includes and 'unfinished' corpus of debates in the UN General 
# Assembly ("UNGA"), i.e. it does not yet include the reverse index, and it 
# is not compressed.
#
# The first step in the following example is to copy the raw
# corpus to a temporary place.

home_dir &lt;- system.file(
  package = "RcppCWB",
  "extdata", "cwb", "indexed_corpora", "unga"
)

tmp_data_dir &lt;- file.path(tempdir(), "indexed_corpora")
tmp_unga_dir &lt;- file.path(tmp_data_dir, "unga2")
if (!file.exists(tmp_data_dir)) dir.create(tmp_data_dir)
if (!file.exists(tmp_unga_dir)){
  dir.create(tmp_unga_dir)
} else {
  file.remove(list.files(tmp_unga_dir, full.names = TRUE))
}

regfile &lt;- readLines(
  system.file(package = "RcppCWB", "extdata", "cwb", "registry", "unga")
)
regfile[grep("^HOME", regfile)] &lt;- sprintf('HOME "%s"', tmp_unga_dir)
regfile[grep("^ID", regfile)] &lt;- "ID unga2"
writeLines(text = regfile, con = file.path(get_tmp_registry(), "unga2"))
for (x in list.files(home_dir, full.names = TRUE)){
  file.copy(from = x, to = tmp_unga_dir)
}

# perform cwb_makeall (equivalent to cwb-makeall command line utility)
cwb_makeall(
  corpus = "UNGA2",
  p_attribute = "word",
  registry = get_tmp_registry()
)
cl_load_corpus("UNGA2", registry = get_tmp_registry())
cqp_load_corpus("UNGA2", registry = get_tmp_registry())

# see whether it works
ids_sentence_1 &lt;- cl_cpos2id(
  corpus = "UNGA2", p_attribute = "word", registry = get_tmp_registry(),
  cpos = 0:83
  )
tokens_sentence_1 &lt;- cl_id2str(
  corpus = "UNGA2", p_attribute = "word",
  registry = get_tmp_registry(), id = ids_sentence_1
  )
sentence &lt;- gsub(
  "\\s+([\\.,])",
  "\\1",
  paste(tokens_sentence_1, collapse = " ")
)

# perform cwb_huffcode (equivalent to cwb-makeall command line utility)
cwb_huffcode(
  corpus = "UNGA2",
  p_attribute = "word",
  registry = get_tmp_registry()
)
cwb_compress_rdx(
  corpus = "UNGA2",
  p_attribute = "word",
  registry = get_tmp_registry()
)
</code></pre>

<hr>
<h2 id='cwb_version'>Get CWB version</h2><span id='topic+cwb_version'></span>

<h3>Description</h3>

<p>Get the CWB version used and available when compiling the source code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cwb_version()
</code></pre>


<h3>Value</h3>

<p>A <code>numeric_version</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cwb_version()
</code></pre>

<hr>
<h2 id='get_cbow_matrix'>Get CBOW Matrix.</h2><span id='topic+get_cbow_matrix'></span>

<h3>Description</h3>

<p>Get matrix with moving windows. Negative integer values indicate absence of a
token at the respective position.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_cbow_matrix(
  corpus,
  p_attribute,
  registry = Sys.getenv("CORPUS_REGISTRY"),
  matrix,
  window
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_cbow_matrix_+3A_corpus">corpus</code></td>
<td>
<p>a CWB corpus</p>
</td></tr>
<tr><td><code id="get_cbow_matrix_+3A_p_attribute">p_attribute</code></td>
<td>
<p>a positional attribute</p>
</td></tr>
<tr><td><code id="get_cbow_matrix_+3A_registry">registry</code></td>
<td>
<p>the registry directory</p>
</td></tr>
<tr><td><code id="get_cbow_matrix_+3A_matrix">matrix</code></td>
<td>
<p>a matrix</p>
</td></tr>
<tr><td><code id="get_cbow_matrix_+3A_window">window</code></td>
<td>
<p>window size</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- get_region_matrix(
  corpus = "REUTERS", s_attribute = "places",
  strucs = 0L:5L, registry = get_tmp_registry()
  )
windowsize &lt;- 3L
m2 &lt;- get_cbow_matrix(
  corpus = "REUTERS", p_attribute = "word",
  registry = get_tmp_registry(), matrix = m, window = windowsize
  )
colnames(m2) &lt;- c(-windowsize:-1, "node", 1:windowsize)
</code></pre>

<hr>
<h2 id='get_count_vector'>Get Vector with Counts for Positional Attribute.</h2><span id='topic+get_count_vector'></span>

<h3>Description</h3>

<p>The return value is an integer vector. The length of the vector is the number of
unique tokens in the corpus / the number of unique ids. The order of the counts
corresponds to the number of ids.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_count_vector(corpus, p_attribute, registry = Sys.getenv("CORPUS_REGISTRY"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_count_vector_+3A_corpus">corpus</code></td>
<td>
<p>a CWB corpus</p>
</td></tr>
<tr><td><code id="get_count_vector_+3A_p_attribute">p_attribute</code></td>
<td>
<p>a positional attribute</p>
</td></tr>
<tr><td><code id="get_count_vector_+3A_registry">registry</code></td>
<td>
<p>registry directory</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- get_count_vector(
  corpus = "REUTERS", p_attribute = "word",
  registry = get_tmp_registry()
  )
df &lt;- data.frame(token_id = 0:(length(y) - 1), count = y)
df[["token"]] &lt;- cl_id2str(
  "REUTERS", p_attribute = "word",
  id = df[["token_id"]], registry = get_tmp_registry()
  )
df &lt;- df[,c("token", "token_id", "count")] # reorder columns
df &lt;- df[order(df[["count"]], decreasing = TRUE),]
head(df)
</code></pre>

<hr>
<h2 id='get_pkg_registry'>Get Registry Directory Within Package</h2><span id='topic+get_pkg_registry'></span>

<h3>Description</h3>

<p>Get Registry Directory Within Package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_pkg_registry(pkgname = "RcppCWB")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_pkg_registry_+3A_pkgname">pkgname</code></td>
<td>
<p>Name of package (character vector)</p>
</td></tr>
</table>

<hr>
<h2 id='get_region_matrix'>Get Matrix with Regions for Strucs.</h2><span id='topic+get_region_matrix'></span>

<h3>Description</h3>

<p>The return value is an <code>integer</code> matrix with the left and right corpus
positions of the strucs in columns one and two, respectively. For negative
struc values in the input vector, the matrix reports <code>NA</code> values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_region_matrix(
  corpus,
  s_attribute,
  strucs,
  registry = Sys.getenv("CORPUS_REGISTRY")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_region_matrix_+3A_corpus">corpus</code></td>
<td>
<p>A CWB corpus (length-one <code>character</code> vector).</p>
</td></tr>
<tr><td><code id="get_region_matrix_+3A_s_attribute">s_attribute</code></td>
<td>
<p>A structural attribute (length-one <code>character</code> vector).</p>
</td></tr>
<tr><td><code id="get_region_matrix_+3A_strucs">strucs</code></td>
<td>
<p>Integer vector with strucs.</p>
</td></tr>
<tr><td><code id="get_region_matrix_+3A_registry">registry</code></td>
<td>
<p>Registry directory with registry file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with integer values indicating left and right corpus
positions (columns 1 and 2, respectively).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- get_region_matrix(
  corpus = "REUTERS",
  s_attribute = "id",
  strucs = 0L:5L,
  registry = get_tmp_registry()
)
</code></pre>

<hr>
<h2 id='ids_to_count_matrix'>Perform Count for Vector of IDs.</h2><span id='topic+ids_to_count_matrix'></span>

<h3>Description</h3>

<p>The return value is a two-column integer matrix. Column one represents the
unique ids of the input vector, column two the respective number of
occurrences / counts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ids_to_count_matrix(ids)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ids_to_count_matrix_+3A_ids">ids</code></td>
<td>
<p>a vector of ids (integer values)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>ids &lt;- c(1L, 5L, 5L, 7L, 7L, 7L, 7L)
ids_to_count_matrix(ids)
table(ids) # alternative to get a similar result
</code></pre>

<hr>
<h2 id='matrix_to_subcorpus'>Create CWB subcorpus from matrix with regions.</h2><span id='topic+matrix_to_subcorpus'></span>

<h3>Description</h3>

<p>Create CWB subcorpus from matrix with regions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix_to_subcorpus(region_matrix, corpus, subcorpus)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix_to_subcorpus_+3A_region_matrix">region_matrix</code></td>
<td>
<p>A two-colum <code>matrix</code> with regions in rows: Start
position of region in first column, end position in second column.</p>
</td></tr>
<tr><td><code id="matrix_to_subcorpus_+3A_corpus">corpus</code></td>
<td>
<p>A <code>externalptr</code> referencing a corpus such as generated by
<code>cl_find_corpus()</code>.</p>
</td></tr>
<tr><td><code id="matrix_to_subcorpus_+3A_subcorpus">subcorpus</code></td>
<td>
<p>A length-one <code>character</code> vector providing the name for the
subcorpus.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# First we generate a subcorpus from a query result
oil_context &lt;- cqp_query("REUTERS", subcorpus = "OIL", query = '[]{3}"oil" []{3}')
m &lt;- subcorpus_get_ranges(oil_context)
reuters &lt;- cl_find_corpus("REUTERS", registry = get_tmp_registry())
p &lt;- matrix_to_subcorpus(subcorpus = "OIL2", corpus = reuters, region_matrix = m)
cqp_list_subcorpora("REUTERS")

x &lt;- cqp_query("REUTERS:OIL2", query = '"crude";', subcorpus = "CRUDEOIL")
subcorpus_get_ranges(x)

# clean up
cqp_drop_subcorpus("REUTERS:OIL")
cqp_drop_subcorpus("REUTERS:OIL2")
cqp_drop_subcorpus("REUTERS:CRUDEOIL")

## End(Not run)
</code></pre>

<hr>
<h2 id='p_attr_default'>Get default p-attribute</h2><span id='topic+p_attr_default'></span>

<h3>Description</h3>

<p>Usually the default p-attribute will be &quot;word&quot;. Use this function to avoid
a hard-coded solution. Extracts the default attribute defined in the CWB
source code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_attr_default()
</code></pre>


<h3>Value</h3>

<p>A length-one <code>character</code> vector.
</p>

<hr>
<h2 id='region_matrix_ops'>Get IDs and Counts for Region Matrices.</h2><span id='topic+region_matrix_ops'></span><span id='topic+region_matrix_to_ids'></span><span id='topic+region_matrix_to_count_matrix'></span><span id='topic+region_matrix_context'></span><span id='topic+ranges_to_cpos'></span>

<h3>Description</h3>

<p>Get IDs and Counts for Region Matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>region_matrix_to_ids(
  corpus,
  p_attribute,
  registry = Sys.getenv("CORPUS_REGISTRY"),
  matrix
)

region_matrix_to_count_matrix(
  corpus,
  p_attribute,
  registry = Sys.getenv("CORPUS_REGISTRY"),
  matrix
)

region_matrix_context(
  corpus,
  registry = Sys.getenv("CORPUS_REGISTRY"),
  matrix,
  p_attribute,
  s_attribute,
  boundary,
  left,
  right
)

ranges_to_cpos(ranges)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="region_matrix_ops_+3A_corpus">corpus</code></td>
<td>
<p>a CWB corpus</p>
</td></tr>
<tr><td><code id="region_matrix_ops_+3A_p_attribute">p_attribute</code></td>
<td>
<p>a positional attribute</p>
</td></tr>
<tr><td><code id="region_matrix_ops_+3A_registry">registry</code></td>
<td>
<p>registry directory</p>
</td></tr>
<tr><td><code id="region_matrix_ops_+3A_matrix">matrix</code></td>
<td>
<p>a regions matrix</p>
</td></tr>
<tr><td><code id="region_matrix_ops_+3A_s_attribute">s_attribute</code></td>
<td>
<p>If not <code>NULL</code>, a structural attribute (length-one
<code>character</code> vector), typically indicating a sentence (&quot;s&quot;).</p>
</td></tr>
<tr><td><code id="region_matrix_ops_+3A_boundary">boundary</code></td>
<td>
<p>Structural attribute (length-one <code>character</code> vector) that
serves as a boundary and that shall not be transgressed.</p>
</td></tr>
<tr><td><code id="region_matrix_ops_+3A_left">left</code></td>
<td>
<p>An <code>integer</code> value, number of strucs to move to the left.</p>
</td></tr>
<tr><td><code id="region_matrix_ops_+3A_right">right</code></td>
<td>
<p>An <code>integer</code> value, number of strucs to move to the right.</p>
</td></tr>
<tr><td><code id="region_matrix_ops_+3A_ranges">ranges</code></td>
<td>
<p>A two-column integer <code>matrix</code> of ranges (left and right corpus
positions in first and second column, respectively).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ranges_to_cpos()</code> will turn a <code>matrix</code> of ranges into an <code>integer</code>
vector with the individual corpus positions covered by the ranges.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Scenario 1: Get full text for a subcorpus defined by regions
m &lt;- get_region_matrix(
  corpus = "REUTERS", s_attribute = "places",
  strucs = 4L:5L, registry = get_tmp_registry()
  )
ids &lt;- region_matrix_to_ids(
  corpus = "REUTERS", p_attribute = "word",
  registry = get_tmp_registry(), matrix = m
  )
tokenstream &lt;- cl_id2str(
  corpus = "REUTERS", p_attribute = "word",
  registry = get_tmp_registry(), id = ids
  )
txt &lt;- paste(tokenstream, collapse = " ")
txt

# Scenario 2: Get data.frame with counts for region matrix
y &lt;- region_matrix_to_count_matrix(
  corpus = "REUTERS", p_attribute = "word",
  registry = get_tmp_registry(), matrix = m
  )
df &lt;- as.data.frame(y)
colnames(df) &lt;- c("token_id", "count")
df[["token"]] &lt;- cl_id2str(
  "REUTERS", p_attribute = "word",
  registry = get_tmp_registry(), id = df[["token_id"]]
  )
df[order(df[["count"]], decreasing = TRUE),]
head(df)
</code></pre>

<hr>
<h2 id='region_matrix_to_struc_matrix'>Get min and max strucs of s-attribute present in region</h2><span id='topic+region_matrix_to_struc_matrix'></span><span id='topic+region_to_strucs'></span>

<h3>Description</h3>

<p>Look up the minimum and maximum struc of a s-attribute within a region,
including scenario of nested s-attributes. If there are no regions of the
s-attribute within the region, <code>NA</code> values are returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>region_matrix_to_struc_matrix(
  corpus,
  s_attribute,
  region_matrix,
  registry = NULL
)

region_to_strucs(corpus, s_attribute, region, registry = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="region_matrix_to_struc_matrix_+3A_corpus">corpus</code></td>
<td>
<p>ID of a CWB corpus.</p>
</td></tr>
<tr><td><code id="region_matrix_to_struc_matrix_+3A_s_attribute">s_attribute</code></td>
<td>
<p>Name of structural attribute. The attribute may be
nested.</p>
</td></tr>
<tr><td><code id="region_matrix_to_struc_matrix_+3A_region_matrix">region_matrix</code></td>
<td>
<p>A two-column <code>matrix</code> with regions, left corpus
positions in column 1, right corpus positions in column 2.</p>
</td></tr>
<tr><td><code id="region_matrix_to_struc_matrix_+3A_registry">registry</code></td>
<td>
<p>Path of the registry directory. If <code>NULL</code> (default), value
of environment variable 'CORPUS_REGISTRY' will be used.</p>
</td></tr>
<tr><td><code id="region_matrix_to_struc_matrix_+3A_region">region</code></td>
<td>
<p>Vector with left and right corpus position of region.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending whether input is a vector (argument <code>region</code>) or a matrix
(argument <code>region_matrix</code>), a vector or a matrix.
</p>

<hr>
<h2 id='s_attr_is_descendent'>Explore XML structure of CWB corpus</h2><span id='topic+s_attr_is_descendent'></span><span id='topic+s_attr_is_sibling'></span><span id='topic+s_attr_relationship'></span>

<h3>Description</h3>

<p>The data format of the Corpus Workbench (CWB) allows nested XML as import
data. Auxiliary functions assist detecting whether two structural attributes
are nested or at the same level (i.e. defining the same regions).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s_attr_is_descendent(
  x,
  y,
  corpus,
  registry = Sys.getenv("CORPUS_REGISTRY"),
  sample = NULL
)

s_attr_is_sibling(x, y, corpus, registry = Sys.getenv("CORPUS_REGISTRY"))

s_attr_relationship(x, y, corpus, registry = Sys.getenv("CORPUS_REGISTRY"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s_attr_is_descendent_+3A_x">x</code></td>
<td>
<p>A structural attribute, stated as length-one <code>character</code> vector.</p>
</td></tr>
<tr><td><code id="s_attr_is_descendent_+3A_y">y</code></td>
<td>
<p>Another structural attribute, stated as length-one <code>character</code> vector.</p>
</td></tr>
<tr><td><code id="s_attr_is_descendent_+3A_corpus">corpus</code></td>
<td>
<p>A corpus ID (length-one <code>character</code> vector).</p>
</td></tr>
<tr><td><code id="s_attr_is_descendent_+3A_registry">registry</code></td>
<td>
<p>The directory with the registry file for the corpus.</p>
</td></tr>
<tr><td><code id="s_attr_is_descendent_+3A_sample">sample</code></td>
<td>
<p>An <code>integer</code> vector with a sample number of strucs to evaluate.
Evaluating only a sample may be an efficient choice for large corpora. If <code>NULL</code>
(default), all strucs are evaluated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>s_attr_is_descendent()</code> will evaluate whether s_attribute <code>x</code> is
a child of s_attribute <code>y</code>. The return value is <code>TRUE</code> (a single <code>logical</code>
value)  if all regions defined by <code>x</code> are within the regions defined by <code>y</code>.
If not, <code>FALSE</code> is returned. The return values is also <code>FALSE</code> if all regions
of <code>x</code> and <code>y</code> are idential. Attributes will be siblings in this case,
and not in an ancestor-sibling relationship.
</p>
<p><code>s_attr_is_sibling()</code> will test whether the regions defined for
structural attribute <code>x</code> and structural attribute <code>y</code> are identical. If
yes, <code>TRUE</code> is returned, assuming that both attributes are at the same
level (siblings). If not, <code>FALSE</code> is returned.
</p>
<p><code>s_attr_relationship()</code> will return <code>0</code> if s-attributes <code>x</code> and <code>y</code>
are siblings in the sense that they define identical regions. The return
value is <code>0</code> if <code>x</code> is an ancestor of <code>y</code> and <code>1</code> if <code>x</code> is a descencdent
of <code>y</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s_attr_is_descendent("id", "places", corpus = "REUTERS", registry = get_tmp_registry())
s_attr_is_sibling(x = "id", y = "places", corpus = "REUTERS", registry = get_tmp_registry())
s_attr_is_sibling(x = "id", y = "places", corpus = "REUTERS", registry = get_tmp_registry())
</code></pre>

<hr>
<h2 id='s_attr_regions'>Get regions defined by a structural attribute</h2><span id='topic+s_attr_regions'></span>

<h3>Description</h3>

<p>Get all regions defined by a structural attribute. Unlike
<code>get_region_matrix()</code> that returns a region matrix for a defined subset of
strucs, all regions are returned. As it is the fastest option, the function
reads the binary *.rng file for the structural attribute directly. The corpus
library (CL) is not used in this case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s_attr_regions(
  corpus,
  s_attr,
  registry = Sys.getenv("CORPUS_REGISTRY"),
  data_dir = corpus_data_dir(corpus = corpus, registry = registry)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s_attr_regions_+3A_corpus">corpus</code></td>
<td>
<p>A length-one <code>character</code> vector with a corpus ID.</p>
</td></tr>
<tr><td><code id="s_attr_regions_+3A_s_attr">s_attr</code></td>
<td>
<p>A length-one <code>character</code> vector stating a structural attribute.</p>
</td></tr>
<tr><td><code id="s_attr_regions_+3A_registry">registry</code></td>
<td>
<p>A length-one <code>character</code> vector stating the registry
directory (defaults to CORPUS_REGISTRY environment variable).</p>
</td></tr>
<tr><td><code id="s_attr_regions_+3A_data_dir">data_dir</code></td>
<td>
<p>The data directory of the corpus.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A two-colum <code>matrix</code> with the regions defined by the structural
attribute: Column 1 defines left corpus positions and column 2 right corpus
positions of regions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s_attr_regions("REUTERS", s_attr = "id", registry = get_tmp_registry())
</code></pre>

<hr>
<h2 id='s_attribute_decode'>Decode Structural Attribute.</h2><span id='topic+s_attribute_decode'></span>

<h3>Description</h3>

<p>Get <code>data.frame</code> with left and right corpus positions (cpos) for
structural attributes and values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s_attribute_decode(
  corpus,
  data_dir,
  s_attribute,
  encoding = NULL,
  registry = Sys.getenv("CORPUS_REGISTRY"),
  method = c("R", "Rcpp")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s_attribute_decode_+3A_corpus">corpus</code></td>
<td>
<p>A CWB corpus (ID in upper case).</p>
</td></tr>
<tr><td><code id="s_attribute_decode_+3A_data_dir">data_dir</code></td>
<td>
<p>The data directory where the binary files of the corpus are
stored.</p>
</td></tr>
<tr><td><code id="s_attribute_decode_+3A_s_attribute">s_attribute</code></td>
<td>
<p>A structural attribute (length 1 <code>character</code> vector).</p>
</td></tr>
<tr><td><code id="s_attribute_decode_+3A_encoding">encoding</code></td>
<td>
<p>Encoding of the values (&quot;latin-1&quot; or &quot;utf-8&quot;)</p>
</td></tr>
<tr><td><code id="s_attribute_decode_+3A_registry">registry</code></td>
<td>
<p>The CWB registry directory.</p>
</td></tr>
<tr><td><code id="s_attribute_decode_+3A_method">method</code></td>
<td>
<p>A length-one <code>character</code> vector, whether to use &quot;R&quot; or &quot;Rcpp&quot;
implementation for decoding structural attribute.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two approaches are implemented: A pure R solution will decode the files
directly in the directory specified by <code>data_dir</code>. An implementation
using Rcpp will use the registry file for <code>corpus</code> to find the data
directory.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with three columns, if the s-attribute has
values, or two columns, if not. Column <code>cpos_left</code> are the start
corpus positions of a structural annotation, <code>cpos_right</code> the end
corpus positions. Column <code>value</code> is the value of the annotation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># pure R implementation (Rcpp implementation fails on Windows in vanilla mode)
b &lt;- s_attribute_decode(
  corpus = "REUTERS",
  data_dir = system.file(package = "RcppCWB", "extdata", "cwb", "indexed_corpora", "reuters"),
  registry = get_tmp_registry(),
  s_attribute = "places", method = "R"
)

# Using Rcpp wrappers for CWB C code
b &lt;- s_attribute_decode(
  corpus = "REUTERS",
  data_dir = system.file(package = "RcppCWB", "extdata", "cwb", "indexed_corpora", "reuters"),
  s_attribute = "places",
  method = "Rcpp",
  registry = get_tmp_registry()
)
</code></pre>

<hr>
<h2 id='subcorpus_get_ranges'>Get ranges of subcorpus</h2><span id='topic+subcorpus_get_ranges'></span>

<h3>Description</h3>

<p>Get ranges of subcorpus
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subcorpus_get_ranges(subcorpus_pointer)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subcorpus_get_ranges_+3A_subcorpus_pointer">subcorpus_pointer</code></td>
<td>
<p>A pointer (class <code>externalptr</code>) referencing a CWB
subcorpus.</p>
</td></tr>
</table>

<hr>
<h2 id='use_tmp_registry'>Use Temporary Registry</h2><span id='topic+use_tmp_registry'></span><span id='topic+get_tmp_registry'></span>

<h3>Description</h3>

<p>Use and get temporary registry directory to describe and access the corpora
in a package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>use_tmp_registry(pkg = system.file(package = "RcppCWB"))

get_tmp_registry()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="use_tmp_registry_+3A_pkg">pkg</code></td>
<td>
<p>Full path to a package.</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
