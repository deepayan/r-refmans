<!DOCTYPE html><html><head><title>Help for package spc</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {spc}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#dphat'><p>Percent defective for normal samples</p></a></li>
<li><a href='#euklid.ewma.arl'><p>Compute ARLs of Poisson NCS-EWMA control charts</p></a></li>
<li><a href='#imr.arl'><p>Compute ARLs and control limit factors for I-MR combos in case of normal data</p></a></li>
<li><a href='#imr.RuRl_alone'><p>Compute control limits of MR charts for normal data</p></a></li>
<li><a href='#lns2ewma.arl'><p>Compute ARLs of EWMA ln <code class="reqn">S^2</code> control charts (variance charts)</p></a></li>
<li><a href='#lns2ewma.crit'><p>Compute critical values of EWMA ln <code class="reqn">S^2</code> control charts (variance charts)</p></a></li>
<li><a href='#mewma.arl'><p>Compute ARLs of MEWMA control charts</p></a></li>
<li><a href='#mewma.crit'><p>Compute alarm threshold of MEWMA control charts</p></a></li>
<li><a href='#mewma.psi'><p>Compute steady-state density of the MEWMA statistic</p></a></li>
<li><a href='#p.ewma.arl'><p>Compute ARLs of binomial EWMA p control charts</p></a></li>
<li><a href='#phat.ewma.arl'><p>Compute ARLs of EWMA phat control charts</p></a></li>
<li><a href='#pois.cusum.arl'><p>Compute ARLs of Poisson CUSUM control charts</p></a></li>
<li><a href='#pois.cusum.crit'><p>Compute alarm thresholds and randomization constants of Poisson CUSUM control charts</p></a></li>
<li><a href='#pois.cusum.crit.L0L1'><p>Compute the CUSUM k and h for given in-control ARL L0 and out-of-control ARL L1, Poisson case</p></a></li>
<li><a href='#pois.ewma.ad'><p>Compute steady-state ARLs of Poisson EWMA control charts</p></a></li>
<li><a href='#pois.ewma.arl'><p>Compute ARLs of Poisson EWMA control charts</p></a></li>
<li><a href='#pois.ewma.crit'><p>Compute ARLs of Poisson EWMA control charts</p></a></li>
<li><a href='#quadrature.nodes.weights'><p>Calculate quadrature nodes and weights</p></a></li>
<li><a href='#scusum.arl'><p>Compute ARLs of CUSUM control charts (variance charts)</p></a></li>
<li><a href='#scusum.crit'><p>Compute decision intervals of CUSUM control charts (variance charts)</p></a></li>
<li><a href='#scusums.arl'><p>Compute ARLs of CUSUM-Shewhart control charts (variance charts)</p></a></li>
<li><a href='#sewma.arl'><p>Compute ARLs of EWMA control charts (variance charts)</p></a></li>
<li><a href='#sewma.arl.prerun'><p>Compute ARLs of EWMA control charts (variance charts) in case of estimated parameters</p></a></li>
<li><a href='#sewma.crit'><p>Compute critical values of EWMA control charts (variance charts)</p></a></li>
<li><a href='#sewma.crit.prerun'><p>Compute critical values of of EWMA (variance charts) control charts under pre-run uncertainty</p></a></li>
<li><a href='#sewma.q'><p>Compute RL quantiles of EWMA (variance charts) control charts</p></a></li>
<li><a href='#sewma.q.prerun'><p>Compute RL quantiles of EWMA (variance charts) control charts under pre-run uncertainty</p></a></li>
<li><a href='#sewma.sf'><p>Compute the survival function of EWMA run length</p></a></li>
<li><a href='#sewma.sf.prerun'><p>Compute the survival function of EWMA run length</p></a></li>
<li><a href='#tewma.arl'><p>Compute ARLs of Poisson TEWMA control charts</p></a></li>
<li><a href='#tol.lim.fac'><p>Two-sided tolerance limit factors</p></a></li>
<li><a href='#x.res.ewma.arl'><p>Compute ARLs of EWMA residual control charts</p></a></li>
<li><a href='#xcusum.ad'><p>Compute steady-state ARLs of CUSUM control charts</p></a></li>
<li><a href='#xcusum.arl'><p>Compute ARLs of CUSUM control charts</p></a></li>
<li><a href='#xcusum.crit'><p>Compute decision intervals of CUSUM control charts</p></a></li>
<li><a href='#xcusum.crit.L0h'><p>Compute the CUSUM reference value k for given in-control ARL and threshold h</p></a></li>
<li><a href='#xcusum.crit.L0L1'><p>Compute the CUSUM k and h for given in-control ARL L0 and out-of-control L1</p></a></li>
<li><a href='#xcusum.q'><p>Compute RL quantiles of CUSUM control charts</p></a></li>
<li><a href='#xcusum.sf'><p>Compute the survival function of CUSUM run length</p></a></li>
<li><a href='#xDcusum.arl'><p>Compute ARLs of CUSUM control charts under drift</p></a></li>
<li><a href='#xDewma.arl'><p>Compute ARLs of EWMA control charts under drift</p></a></li>
<li><a href='#xDgrsr.arl'><p>Compute ARLs of Shiryaev-Roberts schemes under drift</p></a></li>
<li><a href='#xDshewhartrunsrules.arl'><p>Compute ARLs of Shewhart control charts with and without runs rules</p>
under drift</a></li>
<li><a href='#xewma.ad'><p>Compute steady-state ARLs of EWMA control charts</p></a></li>
<li><a href='#xewma.arl'><p>Compute ARLs of EWMA control charts</p></a></li>
<li><a href='#xewma.arl.f'><p>Compute ARL function of EWMA control charts</p></a></li>
<li><a href='#xewma.arl.prerun'><p>Compute ARLs of EWMA control charts in case of estimated parameters</p></a></li>
<li><a href='#xewma.crit'><p>Compute critical values of EWMA control charts</p></a></li>
<li><a href='#xewma.q'><p>Compute RL quantiles of EWMA control charts</p></a></li>
<li><a href='#xewma.q.prerun'><p>Compute RL quantiles of EWMA control charts in case of estimated parameters</p></a></li>
<li><a href='#xewma.sf'><p>Compute the survival function of EWMA run length</p></a></li>
<li><a href='#xewma.sf.prerun'><p>Compute the survival function of EWMA run length in case of estimated parameters</p></a></li>
<li><a href='#xgrsr.ad'><p>Compute steady-state ARLs of Shiryaev-Roberts schemes</p></a></li>
<li><a href='#xgrsr.arl'><p>Compute (zero-state) ARLs of Shiryaev-Roberts schemes</p></a></li>
<li><a href='#xgrsr.crit'><p>Compute alarm thresholds for Shiryaev-Roberts schemes</p></a></li>
<li><a href='#xsewma.arl'><p>Compute ARLs of simultaneous EWMA control charts (mean and variance charts)</p></a></li>
<li><a href='#xsewma.crit'><p>Compute critical values of simultaneous EWMA control charts (mean and variance charts)</p></a></li>
<li><a href='#xsewma.q'><p>Compute critical values of simultaneous EWMA control charts</p>
(mean and variance charts) for given RL quantile</a></li>
<li><a href='#xsewma.sf'><p>Compute the survival function of simultaneous EWMA control</p>
charts (mean and variance charts)</a></li>
<li><a href='#xshewhart.ar1.arl'><p>Compute ARLs of modified Shewhart control charts for AR(1) data</p></a></li>
<li><a href='#xshewhartrunsrules.arl'><p>Compute ARLs of Shewhart control charts with and without runs rules</p></a></li>
<li><a href='#xtcusum.arl'><p>Compute ARLs of CUSUM control charts</p></a></li>
<li><a href='#xtewma.ad'><p>Compute steady-state ARLs of EWMA control charts, t distributed data</p></a></li>
<li><a href='#xtewma.arl'><p>Compute ARLs of EWMA control charts, t distributed data</p></a></li>
<li><a href='#xtewma.q'><p>Compute RL quantiles of EWMA control charts</p></a></li>
<li><a href='#xtewma.sf'><p>Compute the survival function of EWMA run length</p></a></li>
<li><a href='#xtshewhart.ar1.arl'><p>Compute ARLs of modified Shewhart control charts for AR(1) data with Student t residuals</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.6.7</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-10-24</td>
</tr>
<tr>
<td>Title:</td>
<td>Statistical Process Control &ndash; Calculation of ARL and Other
Control Chart Performance Measures</td>
</tr>
<tr>
<td>Author:</td>
<td>Sven Knoth</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sven Knoth &lt;Sven.Knoth@gmx.de&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 1.8.0)</td>
</tr>
<tr>
<td>Description:</td>
<td>Evaluation of control charts by means of
        the zero-state, steady-state ARL (Average Run Length) and RL quantiles.
        Setting up control charts for given in-control ARL. The control charts
        under consideration are one- and two-sided EWMA, CUSUM, and
        Shiryaev-Roberts schemes for monitoring the mean or variance of normally
        distributed independent data. ARL calculation of the same set of schemes under drift (in the mean) are added.
        Eventually, all ARL measures for the multivariate EWMA (MEWMA) are provided.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.r-project.org">https://www.r-project.org</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-10-24 11:41:30 UTC; knoth</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-10-24 12:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='dphat'>Percent defective for normal samples</h2><span id='topic+dphat'></span><span id='topic+pphat'></span><span id='topic+qphat'></span>

<h3>Description</h3>

<p>Density, distribution function and quantile function
for the sample percent defective calculated on normal samples
with mean equal to <code>mu</code> and standard deviation equal to <code>sigma</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dphat(x, n, mu=0, sigma=1, type="known", LSL=-3, USL=3, nodes=30)

pphat(q, n, mu=0, sigma=1, type="known", LSL=-3, USL=3, nodes=30)

qphat(p, n, mu=0, sigma=1, type="known", LSL=-3, USL=3, nodes=30)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dphat_+3A_x">x</code>, <code id="dphat_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="dphat_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="dphat_+3A_n">n</code></td>
<td>
<p>sample size.</p>
</td></tr>
<tr><td><code id="dphat_+3A_mu">mu</code>, <code id="dphat_+3A_sigma">sigma</code></td>
<td>
<p>parameters of the underlying normal distribution.</p>
</td></tr>
<tr><td><code id="dphat_+3A_type">type</code></td>
<td>
<p>choose whether the standard deviation is given and fixed (<code>"known"</code>) or estimated and potententially monitored (<code>"estimated"</code>).</p>
</td></tr>
<tr><td><code id="dphat_+3A_lsl">LSL</code>, <code id="dphat_+3A_usl">USL</code></td>
<td>
<p>lower and upper specification limit, respectively.</p>
</td></tr>
<tr><td><code id="dphat_+3A_nodes">nodes</code></td>
<td>
<p>number of quadrature nodes needed for <code>type="estimated"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Bruhn-Suhr/Krumbholz (1990) derived the cumulative distribution function
of the sample percent defective calculated on normal samples to applying them for a new variables sampling plan.
These results were heavily used in Krumbholz/Z\&quot;oller (1995) for Shewhart and in Knoth/Steinmetz (2013) for EWMA control charts.
For algorithmic details see, essentially, Bruhn-Suhr/Krumbholz (1990).
Two design variants are treated: The simple case, <code>type="known"</code>, with known normal variance and the presumably much
more relevant and considerably intricate case, <code>type="estimated"</code>, where both parameters of
the normal distribution are unknown. Basically, given lower and upper specification limits and the normal distribution,
one estimates the expected yield based on a normal sample of size <code>n</code>.
</p>


<h3>Value</h3>

<p>Returns vector of pdf, cdf or qf values for the statistic phat.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>M. Bruhn-Suhr and W. Krumbholz (1990),
A new variables sampling plan for normally distributed lots with unknown standard deviation and double specification limits,
<em>Statistical Papers</em> 31(1), 195-207.
</p>
<p>W. Krumbholz and A. Z\&quot;oller (1995),
<code>p</code>-Karten vom Shewhartschen Typ f\&quot;ur die messende Pr\&quot;ufung,
<em>Allgemeines Statistisches Archiv</em> 79, 347-360.
</p>
<p>S. Knoth and S. Steinmetz (2013),
EWMA <code>p</code> charts  under sampling by variables,
<em>International Journal of Production Research</em> 51(13), 3795-3807.
</p>


<h3>See Also</h3>

<p><code>phat.ewma.arl</code> for routines using the herewith considered phat statistic.</p>


<h3>Examples</h3>

<pre><code class='language-R'># Figures 1 (c) and (d) from Knoth/Steinmetz (2013)
n      &lt;-  5
LSL    &lt;- -3
USL    &lt;-  3

par(mar=c(5, 5, 1, 1) + 0.1)

p.star &lt;- 2*pnorm( (LSL-USL)/2 ) # for p &lt;= p.star pdf and cdf vanish

p_ &lt;- seq(p.star+1e-10, 0.07, 0.0001) # define support of Figure 1

# Figure 1 (c)
pp_ &lt;- pphat(p_, n)
plot(p_, pp_, type="l", xlab="p", ylab=expression(P( hat(p) &lt;= p )),
     xlim=c(0, 0.06), ylim=c(0,1), lwd=2)
abline(h=0:1, v=p.star, col="grey")

# Figure 1 (d)
dp_ &lt;- dphat(p_, n)
plot(p_, dp_, type="l", xlab="p", ylab="f(p)", xlim=c(0, 0.06),
     ylim=c(0,50), lwd=2)
abline(h=0, v=p.star, col="grey")
</code></pre>

<hr>
<h2 id='euklid.ewma.arl'>Compute ARLs of Poisson NCS-EWMA control charts</h2><span id='topic+euklid.ewma.arl'></span>

<h3>Description</h3>

<p>Computation of the (zero-state) Average Run Length (ARL) at given Poisson mean <code>mu</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>euklid.ewma.arl(gX, gY, kL, kU, mu, y0, r0=0)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="euklid.ewma.arl_+3A_gx">gX</code></td>
<td>
<p>first and</p>
</td></tr>
<tr><td><code id="euklid.ewma.arl_+3A_gy">gY</code></td>
<td>
<p>second integer forming the rational lambda = gX/(gX+gY), lambda mimics the usual EWMA smoothing constant.</p>
</td></tr>
<tr><td><code id="euklid.ewma.arl_+3A_kl">kL</code></td>
<td>
<p>lower control limit of the NCS-EWMA control chart, integer.</p>
</td></tr>
<tr><td><code id="euklid.ewma.arl_+3A_ku">kU</code></td>
<td>
<p>upper control limit of the NCS-EWMA control chart, integer.</p>
</td></tr>
<tr><td><code id="euklid.ewma.arl_+3A_mu">mu</code></td>
<td>
<p>mean value of Poisson distribution.</p>
</td></tr>
<tr><td><code id="euklid.ewma.arl_+3A_y0">y0</code></td>
<td>
<p>headstart like value &ndash; it is proposed to use the in-control mean.</p>
</td></tr>
<tr><td><code id="euklid.ewma.arl_+3A_r0">r0</code></td>
<td>
<p>further element of the headstart &ndash; deviating from the default should be done only in case of full understanding of the scheme.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A new idea of applying EWMA smoothing to count data based on integer divison with remainders.
It is highly recommended to read the corresponding paper (see below).
</p>


<h3>Value</h3>

<p>Return single value which resemble the ARL.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>A. C. Rakitzis, P. Castagliola, P. E. Maravelakis (2015),
A new memory-type monitoring technique for count data,
Computers and Industrial Engineering 85, 235-247.
</p>


<h3>See Also</h3>

<p>later.</p>


<h3>Examples</h3>

<pre><code class='language-R'># RCM (2015), Table 12, page 243, first NCS column
gX &lt;- 5
gY &lt;- 24
kL &lt;- 16
kU &lt;- 24
mu0 &lt;- 20
#L0 &lt;- euklid.ewma.arl(gX, gY, kL, kU, mu0, mu0)
# should be 1219.2
 
</code></pre>

<hr>
<h2 id='imr.arl'>Compute ARLs and control limit factors for I-MR combos in case of normal data</h2><span id='topic+imr.arl'></span><span id='topic+imr.Ru_Mgiven'></span><span id='topic+imr.Rl_Mgiven'></span><span id='topic+imr.MandRu'></span><span id='topic+imr.MandRuRl'></span>

<h3>Description</h3>

<p>Computation of the (zero-state) Average Run Length (ARL) at given mean <code>mu</code> and <code>sigma</code> etc.</p>


<h3>Usage</h3>

<pre><code class='language-R'>imr.arl(M, Ru, mu, sigma, vsided="upper", Rl=0, cmode="coll", N=30, qm=30)

imr.Ru_Mgiven(M, L0, N=30, qm=30)

imr.Rl_Mgiven(M, L0, N=30, qm=30)

imr.MandRu(L0, N=30, qm=30)

imr.MandRuRl(L0, N=30, qm=30)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imr.arl_+3A_m">M</code></td>
<td>
<p>control limit multiple for mean chart.</p>
</td></tr>
<tr><td><code id="imr.arl_+3A_ru">Ru</code></td>
<td>
<p>upper control limit multiple for moving range chart.</p>
</td></tr>
<tr><td><code id="imr.arl_+3A_mu">mu</code></td>
<td>
<p>actual mean.</p>
</td></tr>
<tr><td><code id="imr.arl_+3A_sigma">sigma</code></td>
<td>
<p>actual standard deviation.</p>
</td></tr>
<tr><td><code id="imr.arl_+3A_vsided">vsided</code></td>
<td>
<p>switches between the more common &quot;upper&quot; and the less popular &quot;two&quot;(-sided) case of the MR chart.
Setting <code>vsided</code> to &quot;two&quot; and <code>Ru</code> sufficiently large (at least <code>2*M</code>), creates an I-MR chart
with a lower limit only for the MR part.</p>
</td></tr>
<tr><td><code id="imr.arl_+3A_rl">Rl</code></td>
<td>
<p>lower control limit multiple for moving range chart (not needed in the upper case, i.e. if <code>vsided</code>=&quot;upper&quot;).</p>
</td></tr>
<tr><td><code id="imr.arl_+3A_cmode">cmode</code></td>
<td>
<p>selects the numerical algorithm. The default <code>"coll"</code> picks the piecewise collocation, which is
the most accurate method. Selecting <code>"Crowder"</code>, the algorithm from Crowder (1987b) is chosen (re-implemented in R).
Taking a label from <code>"gl"</code>, <code>"rectangular"</code>, <code>"trapezoid"</code>, <code>"simpson"</code> or <code>"simpson3_8"</code>,
one decides for the quite common Nystroem procedure to numerically solve the considered integral equation.
It is astonishing that Crowder's modified Nystroem design with the trapezoidal quadrature works so well.
However, it is clearly dominated by the piecewise collocation algorithm.</p>
</td></tr>
<tr><td><code id="imr.arl_+3A_n">N</code></td>
<td>
<p>Controls the dimension of the linear equation system and consequently the accuracy of the result. See details.</p>
</td></tr>
<tr><td><code id="imr.arl_+3A_qm">qm</code></td>
<td>
<p>Number of quadrature nodes (and weights) to determine the collocation definite integrals.</p>
</td></tr>
<tr><td><code id="imr.arl_+3A_l0">L0</code></td>
<td>
<p>pre-defined in-control ARL, that is, determine <code>Ru</code>, <code>Rl</code>, or <code>M</code> and <code>Ru</code> or
all of them (essentially ending in a lower limit MR chart) so that the mean
number of observations until a false alarm is <code>L0</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Crowder (1987a) provided some math to determine the ARL of the so-called individual moving range (IMR) chart.
The given integral equation was approximated by a linear equation system applying trapezoidal quadratures.
Interestingly, Crowder did not recognize the specific behavior of the solution for <code>Ru</code> &gt;= <code>M</code> (which is
the more common case), where the resulting function L() is constant in the central part of the
considered domain. In addition, by performing collocation on two (<code>Ru</code> &gt; <code>M</code>)
or three (<code>Ru</code> &lt; <code>M</code>) subintervals piecewise, one obtains highly accurate
ARL numbers. Note that <code>imr.MandRu</code> yields <code>M</code> and <code>Ru</code> for the upper MR trace, whereas
<code>imr.MandRuRl</code> provides in addition the lower factor <code>Rl</code> for IMR consisting of two two-sided control charts.
Note that the underlying ARL unbiased condition suppresses the upper limit <code>Ru</code> in all considered cases so far.
This is not completely surprising, because the mean chart is already quite sensitive for increases in the variance.
The two functions <code>imr.Ru_Mgiven</code> and <code>imr.Rl_Mgiven</code> deliver the single upper and lower limit,
respectively, if a one-sided MR design is utilized and the control lmit factor <code>M</code> of
the mean chart is set already. Note that for <code>Ru</code> &gt; <code>2*M</code>, the upper MR limit is
not operative anymore. If it was initially an upper MR chart, then it reduces to a single mean chart.
If it was originally a two-sided MR design, then it becomes a two-sided mean/lower variance chart combo.
Within the latter scheme, the mean chart signals variance increases (a well-known pattern), whereas
the MR subchart delivers only decreasing variance signals. However, these simple Shewhart charts
exhibit in all configurations week variance decreases detection behavior.
Eventually, we should note that the scientific control chart community mainly recommends to
ignore MR charts, see, for example, Vardeman and Jobe (2016), whereas standards (such as ISO), commercial
SPC software and many training manuals provide the IMR scheme with completely wrong upper limits for the MR chart.</p>


<h3>Value</h3>

<p>Returns either the ARL or control limit factors (alias multiples).</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>S. V. Crowder (1987a)
Computation of ARL for Combined Individual Measurement and Moving Range Charts,
<em>Journal of Quality Technology</em> 19(2), 98-102.
</p>
<p>S. V. Crowder (1987b)
A Program for the Computation of ARL for Combined Individual Measurement and Moving Range Charts,
<em>Journal of Quality Technology</em> 19(2), 103-106.
</p>
<p>K. C. B. Roes, R. J. M. M. Does, Y. Schurink,
Shewhart-Type Control Charts for Individual Observations,
<em>Journal of Quality Technology</em> 25(3), 188-198.
</p>
<p>S. E. Rigdon, E. N. Cruthis, C. W. Champ (1994)
Design Strategies for Individuals and Moving Range Control Charts,
<em>Journal of Quality Technology</em> 26(4), 274-287.
</p>
<p>D. Radson, L. C. Alwan (1995)
Detecting Variance Reductions Using the Moving Range,
<em>Quality Engineering</em> 8(1), 165-178.
</p>
<p>S. R. Adke, X. Hong (1997)
A Supplementary Test Based on the Control Chart for Individuals,
<em>Journal of Quality Technology</em> 29(1), 16-20.
</p>
<p>R. W. Amin, R. A. Ethridge (1998)
A Note on Individual and Moving Range Control Charts,
<em>Journal of Quality Technology</em> 30(1), 70-74.
</p>
<p>C. A. Acosta-Mejia, J. J. Pignatiello (2000)
Monitoring process dispersion without subgrouping,
<em>Journal of Quality Technology</em> 32(2), 89-102.
</p>
<p>N. B. Marks, T. C. Krehbiel (2011)
Design And Application Of Individuals And Moving Range Control Charts,
<em>Journal of Applied Business Research (JABR)</em> 25(5), 31-40.
</p>
<p>D. Rahardja (2014)
Comparison of Individual and Moving Range Chart Combinations to Individual
Charts in Terms of ARL after Designing for a Common &ldquo;All OK&rdquo; ARL,
<em>Journal of Modern Applied Statistical Methods</em> 13(2), 364-378.
</p>
<p>S. B. Vardeman, J. M. Jobe (2016)
<em>Statistical Methods for Quality Assurance</em>,
Springer, 2nd edition.
</p>


<h3>See Also</h3>

<p>later.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Crowder (1987b), Output Listing 1, trapezoidal quadrature (less accurate)

M &lt;- 2
Ru &lt;- 3
mu &lt;- seq(0, 2, by=0.25)
LL &lt;- LL2 &lt;- rep(NA, length(mu))
for ( i in 1:length(mu) ) {
  LL[i] &lt;- round( imr.arl(M, Ru, mu[i], 1), digits=4)
  LL2[i] &lt;- round( imr.arl(M, Ru, mu[i], 1, cmode="Crowder", N=80), digits=4)
}
LL1987b &lt;- c(18.2164, 16.3541, 12.4282, 8.7559, 6.1071, 4.3582, 3.2260, 2.4878, 1.9989)
print( data.frame(mu, LL2, LL1987b, LL) )

## Crowder (1987a), Table 1, trapezoidal quadrature (less accurate)

M &lt;- 4
Ru &lt;- 3
mu &lt;- seq(0, 2, by=0.25)
LL &lt;- rep(NA, length(mu))
for ( i in 1:length(mu) ) LL[i] &lt;- round( imr.arl(M, Ru, mu[i], 1), digits=4)
LL1987a &lt;- c(34.44, 34.28, 34.07, 33.81, 33.45, 32.82, 31.50, 28.85, 24.49)
print( data.frame(mu, LL1987a, LL) )

## Rigdon, Cruthis, Champ (1994), Table 1, Monte Carlo based

M &lt;- 2.992
Ru &lt;- 4.139
icARL &lt;- imr.arl(M, Ru, 0, 1)
icARL1994 &lt;- 200
print( data.frame(icARL1994, icARL) )

M &lt;- 3.268
Ru &lt;- 4.556
icARL &lt;- imr.arl(M, Ru, 0, 1)
icARL1994 &lt;- 500
print( data.frame(icARL1994, icARL) )

## ..., Table 2, Monte Carlo based

M &lt;- 2.992
Ru &lt;- 4.139
tau &lt;- c(seq(1, 1.3, by=0.05), seq(1.4, 2, by=0.1))
LL &lt;- rep(NA, length(tau))
for ( i in 1:length(tau) ) LL[i] &lt;- round( imr.arl(M, Ru, 0, tau[i]), digits=2)
LL1994 &lt;- c(200.54, 132.25, 90.84, 65.66, 49.35, 38.92, 31.11, 21.35, 15.47,
12.04, 9.81, 8.21, 7.03, 6.14)
print( data.frame(tau, LL1994, LL) )

## Radson, Alwan (1995), Table 2 (Monte Carlo based), half-normal, known parameter case
## two-sided (!) MR-alone (!) chart, hence the ARL results has to be decreased by 1
## Here: a large M (=12) is deployed to mimic Inf
alpha &lt;- 0.00915
Ru &lt;- sqrt(2) * qnorm(1-alpha/4)
Rl &lt;- sqrt(2) * qnorm(0.5+alpha/4)
k &lt;- 1.5 - (0:7)/10
LL &lt;- rep(NA, length(k))
for ( i in 1:length(k) )
  LL[i] &lt;- round( imr.arl(12, Ru, 0, k[i], vsided="two", Rl=Rl), digits=2) - 1
RA1995 &lt;- c(18.61, 24.51, 34.21, 49.74, 75.08, 113.14, 150.15, 164.54)
print( data.frame(k, RA1995, LL) )

## Amin, Ethridge (1998), Table 2, column sigma/sigma_0 = 1.00

M &lt;- 3.27
Ru &lt;- 4.56
#M &lt;- 3.268
#Ru &lt;- 4.556
mu &lt;- seq(0, 2, by=0.25)
LL &lt;- rep(NA, length(mu))
for ( i in 1:length(mu) ) LL[i] &lt;- round( imr.arl(M, Ru, mu[i], 1), digits=1)
LL1998 &lt;- c(505.3, 427.6, 276.7, 156.2, 85.0, 46.9, 26.9, 16.1, 10.1)
print( data.frame(mu, LL1998, LL) )

## ..., column sigma/sigma_0 = 1.05

for ( i in 1:length(mu) ) LL[i] &lt;- round( imr.arl(M, Ru, mu[i], 1.05), digits=1)
LL1998 &lt;- c(296.8, 251.6, 169.6, 101.6, 58.9, 34.5, 20.9, 13.2, 8.7)
print( data.frame(mu, LL1998, LL) )

## Acosta-Mejia, Pignatiello (2000), Table 2
## AMP utilized Markov chain approximation
## However, the MR series is not Markovian!
## MR-alone (!) chart, hence the ARL results has to be decreased by 1
## Here: a large M (=8) is deployed to mimic Inf
Ru &lt;- 3.93
sigma &lt;- c(1, 1.05, 1.1, 1.15, 1.2, 1.3, 1.4, 1.5, 1.75)
LL &lt;- rep(NA, length(sigma))
for ( i in 1:length(sigma) ) LL[i] &lt;- round( imr.arl(8, Ru, 0, sigma[i], N=30), digits=1) - 1
AMP2000 &lt;- c(201.0, 136.8, 97.9, 73.0, 56.3, 36.4, 25.6, 19.1, 11.0)
print( data.frame(sigma, AMP2000, LL) )

## Mark, Krehbiel (2011), Table 2, deployment of Crowder (1987b), nominal ic ARL 500

M &lt;- c(3.09, 3.20, 3.30, 3.50, 4.00)
Ru &lt;- c(6.00, 4.67, 4.53, 4.42, 4.36)
LL0 &lt;- rep(NA, length(M))
for ( i in 1:length(M) ) LL0[i] &lt;- round( imr.arl(M[i], Ru[i], 0, 1), digits=1)
print( data.frame(M, Ru, LL0) )
</code></pre>

<hr>
<h2 id='imr.RuRl_alone'>Compute control limits of MR charts for normal data</h2><span id='topic+imr.RuRl_alone'></span><span id='topic+imr.RuRl_alone_s3'></span><span id='topic+imr.RuRl_alone_tail'></span><span id='topic+imr.Ru_Rlgiven'></span><span id='topic+imr.Rl_Rugiven'></span>

<h3>Description</h3>

<p>Computation of control limits of standalone MR charts.</p>


<h3>Usage</h3>

<pre><code class='language-R'>imr.RuRl_alone(L0, N=30, qm=30, M0=12, eps=1e-3)

imr.RuRl_alone_s3(L0, N=30, qm=30, M0=12)

imr.RuRl_alone_tail(L0, N=30, qm=30, M0=12)

imr.Ru_Rlgiven(Rl, L0, N=30, qm=30, M0=12)

imr.Rl_Rugiven(Ru, L0, N=30, qm=30, M0=12)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imr.RuRl_alone_+3A_l0">L0</code></td>
<td>
<p>pre-defined in-control ARL, that is, determine <code>Ru</code> and <code>Rl</code> so that the mean
number of observations until a false alarm is <code>L0</code>.</p>
</td></tr>
<tr><td><code id="imr.RuRl_alone_+3A_n">N</code></td>
<td>
<p>controls the dimension of the linear equation system and consequently the accuracy of the result. See details.</p>
</td></tr>
<tr><td><code id="imr.RuRl_alone_+3A_qm">qm</code></td>
<td>
<p>number of quadrature nodes (and weights) to determine the definite collocation integrals.</p>
</td></tr>
<tr><td><code id="imr.RuRl_alone_+3A_m0">M0</code></td>
<td>
<p>mimics Inf &mdash; by setting <code>M0</code> to some large value (having a standard normal distribution in mind),
the algorithm for IMR charts could be used as well for the standalone MR chart.</p>
</td></tr>
<tr><td><code id="imr.RuRl_alone_+3A_eps">eps</code></td>
<td>
<p>resolution parameter, which controls the approximation of the ARL slope at the in-control level of
the monitored standard deviation. It ensures the pattern that is called ARL unbiasedness. A small value is recommended.</p>
</td></tr>
<tr><td><code id="imr.RuRl_alone_+3A_rl">Rl</code></td>
<td>
<p>lower control limit multiple for moving range chart.</p>
</td></tr>
<tr><td><code id="imr.RuRl_alone_+3A_ru">Ru</code></td>
<td>
<p>upper control limit multiple for moving range chart.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Crowder (1987a) provided some math to determine the ARL of the so-called individual moving range (IMR) chart,
which consists of the mean X chart and the standard deviation MR chart. 
Making the alarm threshold, <code>M0</code>, huge (default value here is 12) for the X chart allows us to utilize Crowder's
setup for standalone MR charts. For details about the IMR numerics see <code>imr.arl</code>.
The three different versions of <code>imr.RuRl_alone</code> determine limits that form an ARL unbiased design, follow the restriction
<code>Rl</code> = <code>1/Ru^3</code> and feature equal probability tails for the MR's half-normal distribution,
respectively in the order given above).
The other two functions are helper routines for <code>imr.RuRl_alone</code>.
Note that the elegant approach given in Acosta-Mejia/Pignatiello (2000) is only an approximation,
because the MR series is not Markovian.
</p>


<h3>Value</h3>

<p>Returns control limit factors (alias multiples).</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>S. V. Crowder (1987a)
Computation of ARL for Combined Individual Measurement and Moving Range Charts,
<em>Journal of Quality Technology</em> 19(2), 98-102.
</p>
<p>S. V. Crowder (1987b)
A Program for the Computation of ARL for Combined Individual Measurement and Moving Range Charts,
<em>Journal of Quality Technology</em> 19(2), 103-106.
</p>
<p>D. Radson, L. C. Alwan (1995)
Detecting Variance Reductions Using the Moving Range,
<em>Quality Engineering</em> 8(1), 165-178.
</p>
<p>C. A. Acosta-Mejia, J. J. Pignatiello (2000)
Monitoring process dispersion without subgrouping,
<em>Journal of Quality Technology</em> 32(2), 89-102.
</p>


<h3>See Also</h3>

<p>later.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Radson, Alwan (1995), Table 2 (Monte Carlo based), half-normal, known parameter case
## two-sided MR-alone chart, hence the ARL results has to be decreased by 1
## Here: a large M0=12 (default of the functions above) is deployed to mimic Inf
alpha &lt;- 0.00915
Ru &lt;- sqrt(2) * qnorm(1-alpha/4)
Rl &lt;- sqrt(2) * qnorm(0.5+alpha/4)
M0 &lt;- 12
## Not run: 
ARL0 &lt;- imr.arl(M0, Ru, 0, 1, vsided="two", Rl=Rl)
RRR1995 &lt;- imr.RuRl_alone_tail(ARL0)
RRRs &lt;- imr.RuRl_alone_s3(ARL0)
RRR &lt;- imr.RuRl_alone(ARL0)
results &lt;- rbind(c(Rl, Ru), RRR1995, RRRs, RRR)
results
## End(Not run)
</code></pre>

<hr>
<h2 id='lns2ewma.arl'>Compute ARLs of EWMA ln <code class="reqn">S^2</code> control charts (variance charts)</h2><span id='topic+lns2ewma.arl'></span>

<h3>Description</h3>

<p>Computation of the (zero-state) Average Run Length (ARL)
for different types of EWMA control charts 
(based on the log of the sample variance <code class="reqn">S^2</code>) monitoring normal variance.</p>


<h3>Usage</h3>

<pre><code class='language-R'>lns2ewma.arl(l,cl,cu,sigma,df,hs=NULL,sided="upper",r=40)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lns2ewma.arl_+3A_l">l</code></td>
<td>
<p>smoothing parameter lambda of the EWMA control chart.</p>
</td></tr>
<tr><td><code id="lns2ewma.arl_+3A_cl">cl</code></td>
<td>
<p>lower control limit of the EWMA control chart.</p>
</td></tr>
<tr><td><code id="lns2ewma.arl_+3A_cu">cu</code></td>
<td>
<p>upper control limit of the EWMA control chart.</p>
</td></tr>
<tr><td><code id="lns2ewma.arl_+3A_sigma">sigma</code></td>
<td>
<p>true standard deviation.</p>
</td></tr>
<tr><td><code id="lns2ewma.arl_+3A_df">df</code></td>
<td>
<p>actual degrees of freedom, corresponds to subsample size (for known mean it is equal to the subsample size,
for unknown mean it is equal to subsample size minus one.</p>
</td></tr>
<tr><td><code id="lns2ewma.arl_+3A_hs">hs</code></td>
<td>
<p>so-called headstart (enables fast initial response) &ndash; the default value (hs=NULL) corresponds to the in-control
mean of ln <code class="reqn">S^2</code>.</p>
</td></tr>
<tr><td><code id="lns2ewma.arl_+3A_sided">sided</code></td>
<td>
<p>distinguishes between one- and two-sided two-sided EWMA-<code class="reqn">S^2</code> control charts 
by choosing <code>"upper"</code> (upper chart with reflection at <code>cl</code>), <code>"lower"</code> (lower chart with reflection at <code>cu</code>),
and <code>"two"</code> (two-sided chart), respectively.</p>
</td></tr> 
<tr><td><code id="lns2ewma.arl_+3A_r">r</code></td>
<td>
<p>dimension of the resulting linear equation system: the larger the better.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>lns2ewma.arl</code> determines the Average Run Length (ARL) by numerically
solving the related ARL integral equation by means of the Nystroem method
based on Gauss-Legendre quadrature.</p>


<h3>Value</h3>

<p>Returns a single value which resembles the ARL.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>S. V. Crowder and M. D. Hamilton (1992),
An EWMA for monitoring a process standard deviation,
<em>Journal of Quality Technology 24</em>, 12-21.
</p>
<p>S. Knoth (2005),
Accurate ARL computation for EWMA-<code class="reqn">S^2</code> control charts,
<em>Statistics and Computing 15</em>, 341-352.
</p>


<h3>See Also</h3>

<p><code>xewma.arl</code> for zero-state ARL computation of EWMA control charts for monitoring normal mean.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lns2ewma.ARL &lt;- Vectorize("lns2ewma.arl", "sigma")

## Crowder/Hamilton (1992)
## moments of ln S^2
E_log_gamma &lt;- function(df) log(2/df) + digamma(df/2)
V_log_gamma &lt;- function(df) trigamma(df/2)
E_log_gamma_approx &lt;- function(df) -1/df - 1/3/df^2 + 2/15/df^4
V_log_gamma_approx &lt;- function(df) 2/df + 2/df^2 + 4/3/df^3 - 16/15/df^5

## results from Table 3 ( upper chart with reflection at 0 = log(sigma0=1) )
## original entries are (lambda = 0.05, K = 1.06, df=n-1=4)
# sigma   ARL
# 1       200
# 1.1      43
# 1.2      18
# 1.3      11
# 1.4       7.6
# 1.5       6.0
# 2         3.2

df &lt;- 4
lambda &lt;- .05
K &lt;- 1.06
cu &lt;- K * sqrt( lambda/(2-lambda) * V_log_gamma_approx(df) )

sigmas &lt;- c(1 + (0:5)/10, 2)
arls &lt;- round(lns2ewma.ARL(lambda, 0, cu, sigmas, df, hs=0, sided="upper"), digits=1)
data.frame(sigmas, arls)

## Knoth (2005)
## compare with Table 3 (p. 351)
lambda &lt;- .05
df &lt;- 4
K &lt;- 1.05521
cu &lt;- 1.05521 * sqrt( lambda/(2-lambda) * V_log_gamma_approx(df) )

## upper chart with reflection at sigma0=1 in Table 4
## original entries are
# sigma   ARL_0    ARL_-.267
# 1       200.0    200.0
# 1.1      43.04    41.55
# 1.2      18.10    19.92
# 1.3      10.75    13.11
# 1.4       7.63     9.93
# 1.5       5.97     8.11
# 2         3.17     4.67

M &lt;- -0.267
cuM &lt;- lns2ewma.crit(lambda, 200, df, cl=M, hs=M, r=60)[2]
arls1 &lt;- round(lns2ewma.ARL(lambda, 0, cu, sigmas, df, hs=0, sided="upper"), digits=2)
arls2 &lt;- round(lns2ewma.ARL(lambda, M, cuM, sigmas, df, hs=M, sided="upper", r=60), digits=2)
data.frame(sigmas, arls1, arls2)
</code></pre>

<hr>
<h2 id='lns2ewma.crit'>Compute critical values of EWMA ln <code class="reqn">S^2</code> control charts (variance charts)</h2><span id='topic+lns2ewma.crit'></span>

<h3>Description</h3>

<p>Computation of the critical values (similar to alarm limits)
for different types of EWMA control charts 
(based on the log of the sample variance <code class="reqn">S^2</code>) monitoring normal variance.</p>


<h3>Usage</h3>

<pre><code class='language-R'>lns2ewma.crit(l,L0,df,sigma0=1,cl=NULL,cu=NULL,hs=NULL,sided="upper",mode="fixed",r=40)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lns2ewma.crit_+3A_l">l</code></td>
<td>
<p>smoothing parameter lambda of the EWMA control chart.</p>
</td></tr>
<tr><td><code id="lns2ewma.crit_+3A_l0">L0</code></td>
<td>
<p>in-control ARL.</p>
</td></tr>
<tr><td><code id="lns2ewma.crit_+3A_df">df</code></td>
<td>
<p>actual degrees of freedom, corresponds to subsample size
(for known mean it is equal to the subsample size,
for unknown mean it is equal to subsample size minus one.</p>
</td></tr>
<tr><td><code id="lns2ewma.crit_+3A_sigma0">sigma0</code></td>
<td>
<p>in-control standard deviation.</p>
</td></tr>
<tr><td><code id="lns2ewma.crit_+3A_cl">cl</code></td>
<td>
<p>deployed for <code>sided</code>=<code>"upper"</code>, that is, upper variance control chart with
lower reflecting barrier <code>cl</code>.</p>
</td></tr>
<tr><td><code id="lns2ewma.crit_+3A_cu">cu</code></td>
<td>
<p>for two-sided (<code>sided</code>=<code>"two"</code>) and fixed upper control limit (<code>mode</code>=<code>"fixed"</code>),
for all other cases <code>cu</code> is ignored.</p>
</td></tr>
<tr><td><code id="lns2ewma.crit_+3A_hs">hs</code></td>
<td>
<p>so-called headstart (enables fast initial response) &ndash; the default value (hs=NULL) corresponds to the
in-control mean of ln <code class="reqn">S^2</code>.</p>
</td></tr>
<tr><td><code id="lns2ewma.crit_+3A_sided">sided</code></td>
<td>
<p>distinguishes between one- and two-sided two-sided EWMA-<code class="reqn">S^2</code> control charts by choosing
<code>"upper"</code> (upper chart with reflection at <code>cl</code>), 
<code>"lower"</code> (lower chart with reflection at <code>cu</code>), and <code>"two"</code> (two-sided chart),  respectively.</p>
</td></tr> 
<tr><td><code id="lns2ewma.crit_+3A_mode">mode</code></td>
<td>
<p>only deployed for <code>sided</code>=<code>"two"</code> &ndash; with <code>"fixed"</code> an upper control limit (see <code>cu</code>)
is set and only the lower is
calculated to obtain the in-control ARL <code>L0</code>, while with <code>"unbiased"</code> a certain unbiasedness of the ARL
function is guaranteed (here, both the
lower and the upper control limit are calculated). With <code>"vanilla"</code> limits symmetric around the in-control
mean of ln <code class="reqn">S^2</code>
are determined, while for <code>"eq.tails"</code> the in-control ARL values of two single EWMA variance charts
(decompose the two-sided scheme into one lower and one upper scheme) are matched.</p>
</td></tr>
<tr><td><code id="lns2ewma.crit_+3A_r">r</code></td>
<td>
<p>dimension of the resulting linear equation system: the larger the more accurate.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>lns2ewma.crit</code> determines the critical values (similar to alarm limits) for given in-control ARL <code>L0</code>
by applying secant rule and using <code>lns2ewma.arl()</code>.
In case of <code>sided</code>=<code>"two"</code> and <code>mode</code>=<code>"unbiased"</code>
a two-dimensional secant rule is applied that also ensures that the
maximum of the ARL function for given standard deviation is attained
at <code>sigma0</code>. See Knoth (2010) and the related example.
</p>


<h3>Value</h3>

<p>Returns the lower and upper control limit <code>cl</code> and <code>cu</code>.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>C. A. Acosta-Mej\'ia and J. J. Pignatiello Jr. and B. V. Rao (1999),
A comparison of control charting procedures for monitoring process dispersion,
<em>IIE Transactions 31</em>, 569-579.
</p>
<p>S. V. Crowder and M. D. Hamilton (1992),
An EWMA for monitoring a process standard deviation,
<em>Journal of Quality Technology 24</em>, 12-21.
</p>
<p>S. Knoth (2005),
Accurate ARL computation for EWMA-<code class="reqn">S^2</code> control charts,
<em>Statistics and Computing 15</em>, 341-352.
</p>
<p>S. Knoth (2010),
Control Charting Normal Variance &ndash; Reflections, Curiosities, and Recommendations,
in <em>Frontiers in Statistical Quality Control 9</em>,
H.-J. Lenz and P.-T. Wilrich (Eds.),
Physica Verlag, Heidelberg, Germany, 3-18.
</p>


<h3>See Also</h3>

<p><code>lns2ewma.arl</code> for calculation of ARL of EWMA ln <code class="reqn">S^2</code> control charts.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Knoth (2005)
## compare with 1.05521 mentioned on page 350 third line from below
L0 &lt;- 200
lambda &lt;- .05
df &lt;- 4
limits &lt;- lns2ewma.crit(lambda, L0, df, cl=0, hs=0)
limits["cu"]/sqrt( lambda/(2-lambda)*(2/df+2/df^2+4/3/df^3-16/15/df^5) )
</code></pre>

<hr>
<h2 id='mewma.arl'>Compute ARLs of MEWMA control charts</h2><span id='topic+mewma.arl'></span><span id='topic+mewma.arl.f'></span><span id='topic+mewma.ad'></span>

<h3>Description</h3>

<p>Computation of the (zero-state) Average Run Length (ARL)
for multivariate exponentially weighted moving average (MEWMA) charts monitoring multivariate normal mean.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mewma.arl(l, cE, p, delta=0, hs=0, r=20, ntype=NULL, qm0=20, qm1=qm0)

mewma.arl.f(l, cE, p, delta=0, r=20, ntype=NULL, qm0=20, qm1=qm0)

mewma.ad(l, cE, p, delta=0, r=20, n=20, type="cond", hs=0, ntype=NULL, qm0=20, qm1=qm0)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mewma.arl_+3A_l">l</code></td>
<td>
<p>smoothing parameter lambda of the MEWMA control chart.</p>
</td></tr>
<tr><td><code id="mewma.arl_+3A_ce">cE</code></td>
<td>
<p>alarm threshold of the MEWMA control chart.</p>
</td></tr>
<tr><td><code id="mewma.arl_+3A_p">p</code></td>
<td>
<p>dimension of multivariate normal distribution.</p>
</td></tr>
<tr><td><code id="mewma.arl_+3A_delta">delta</code></td>
<td>
<p>magnitude of the potential change, <code>delta=0</code> refers to the in-control state.</p>
</td></tr>
<tr><td><code id="mewma.arl_+3A_hs">hs</code></td>
<td>
<p>so-called headstart (enables fast initial response) &ndash; must be non-negative.</p>
</td></tr>
<tr><td><code id="mewma.arl_+3A_r">r</code></td>
<td>
<p>number of quadrature nodes &ndash; dimension of the resulting linear equation system
for <code>delta</code> = 0. For non-zero <code>delta</code> this dimension is mostly r^2 (Markov chain approximation leads
to some larger values). Caution: If <code>ntype</code> is set to <code>"co"</code> (collocation), then values of <code>r</code>
larger than 20 lead to large computing times.
For the other selections this would happen for values larger than 40.</p>
</td></tr>
<tr><td><code id="mewma.arl_+3A_ntype">ntype</code></td>
<td>
<p>choose the numerical algorithm to solve the ARL integral equation. For <code>delta</code>=0:
Possible values are
<code>"gl"</code>, <code>"gl2"</code> (gauss-legendre, classic and with variables change: square),
<code>"co"</code> (collocation, for <code>delta</code> &gt; 0 with sin transformation),
<code>"ra"</code> (radau),
<code>"cc"</code> (clenshaw-curtis),
<code>"mc"</code> (markov chain),
and <code>"sr"</code> (simpson rule).
For <code>delta</code> larger than 0, some more values besides the others are possible:
<code>"gl3"</code>, <code>"gl4"</code>, <code>"gl5"</code> (gauss-legendre with a further change in variables: sin, tan, sinh),
<code>"co2"</code>, <code>"co3"</code> (collocation with some trimming and tan as quadrature stabilizing transformations, respectively).
If it is set to <code>NULL</code> (the default), then for <code>delta</code>=0 then <code>"gl2"</code> is chosen.
If <code>delta</code> larger than 0, then for <code>p</code> equal 2 or 4 <code>"gl3"</code> and for all other values <code>"gl5"</code> is taken.
<code>"ra"</code> denotes the method used in Rigdon (1995a). <code>"mc"</code> denotes the Markov chain approximation.</p>
</td></tr>
<tr><td><code id="mewma.arl_+3A_type">type</code></td>
<td>
<p>switch between <code>"cond"</code> and <code>"cycl"</code> for differentiating between the conditional
(no false alarm) and the cyclical (after false alarm re-start in <code>hs</code>), respectively.</p>
</td></tr>
<tr><td><code id="mewma.arl_+3A_n">n</code></td>
<td>
<p>number of quadrature nodes for Calculating the steady-state ARL integral(s).</p>
</td></tr>
<tr><td><code id="mewma.arl_+3A_qm0">qm0</code>, <code id="mewma.arl_+3A_qm1">qm1</code></td>
<td>
<p>number of collocation quadrature nodes for the out-of-control case (<code>qm0</code> for the inner integral,
<code>qm1</code> for the outer one), that is, for positive <code>delta</code>,
and for the in-control case (now only <code>qm0</code> is deployed) if via <code>ntype</code> the collocation procedure is requested.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Basically, this is the implementation of different numerical algorithms for
solving the integral equation for the MEWMA in-control (<code>delta</code> = 0) ARL introduced in Rigdon (1995a)
and out-of-control (<code>delta</code> != 0) ARL in Rigdon (1995b).
Most of them are nothing else than the Nystroem approach &ndash; the integral is replaced by a suitable quadrature.
Here, the Gauss-Legendre (more powerful), Radau (used by Rigdon, 1995a), Clenshaw-Curtis, and
Simpson rule (which is really bad) are provided.
Additionally, the collocation approach is offered as well, because it is much better for small odd values for <code>p</code>.
FORTRAN code for the Radau quadrature based Nystroem of Rigdon (1995a)
was published in Bodden and Rigdon (1999) &ndash; see also <a href="http://lib.stat.cmu.edu/jqt/31-1">http://lib.stat.cmu.edu/jqt/31-1</a>.
Furthermore, FORTRAN code for the Markov chain approximation (in- and out-ot-control)
could be found at
http://lib.stat.cmu.edu/jqt/33-4.
The related papers are Runger and Prabhu (1996) and Molnau et al. (2001).
The idea of the Clenshaw-Curtis quadrature was taken from
Capizzi and Masarotto (2010), who successfully deployed a modified Clenshaw-Curtis quadrature
to calculate the ARL of combined (univariate) Shewhart-EWMA charts. It turns out that it works also nicely for the
MEWMA ARL. The version <code>mewma.arl.f()</code> without the argument <code>hs</code> provides the ARL as function of one (in-control)
or two (out-of-control) arguments.
</p>


<h3>Value</h3>

<p>Returns a single value which is simply the zero-state ARL.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>Kevin M. Bodden and Steven E. Rigdon (1999),
A program for approximating the in-control ARL for the MEWMA chart,
<em>Journal of Quality Technology 31(1)</em>, 120-123.
</p>
<p>Giovanna Capizzi and Guido Masarotto (2010),
Evaluation of the run-length distribution for a combined Shewhart-EWMA control chart,
<em>Statistics and Computing 20(1)</em>, 23-33.
</p>
<p>Sven Knoth (2017),
ARL Numerics for MEWMA Charts,
<em>Journal of Quality Technology 49(1)</em>, 78-89.
</p>
<p>Wade E. Molnau et al. (2001),
A Program for ARL Calculation for Multivariate EWMA Charts,
<em>Journal of Quality Technology 33(4)</em>, 515-521.
</p>
<p>Sharad S. Prabhu and George C. Runger (1997),
Designing a multivariate EWMA control chart,
<em>Journal of Quality Technology 29(1)</em>, 8-15.
</p>
<p>Steven E. Rigdon (1995a), An integral equation for the in-control average run length of a multivariate
exponentially weighted moving average control chart, <em>J. Stat. Comput. Simulation 52(4)</em>, 351-365.
</p>
<p>Steven E. Rigdon (1995b), A double-integral equation for the average run length of a multivariate
exponentially weighted moving average control chart, <em>Stat. Probab. Lett. 24(4)</em>, 365-373.
</p>
<p>George C. Runger and Sharad S. Prabhu (1996),
A Markov Chain Model for the Multivariate Exponentially Weighted Moving Averages Control Chart,
<em>J. Amer. Statist. Assoc. 91(436)</em>, 1701-1706.
</p>


<h3>See Also</h3>

<p><code>mewma.crit</code> for getting the alarm threshold to attain a certain in-control ARL.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Rigdon (1995a), p. 357, Tab. 1
p &lt;- 2
r &lt;- 0.25
h4 &lt;- c(8.37, 9.90, 11.89, 13.36, 14.82, 16.72)
for ( i in 1:length(h4) ) cat(paste(h4[i], "\t", round(mewma.arl(r, h4[i], p, ntype="ra")), "\n"))

r &lt;- 0.1
h4 &lt;- c(6.98, 8.63, 10.77, 12.37, 13.88, 15.88)
for ( i in 1:length(h4) ) cat(paste(h4[i], "\t", round(mewma.arl(r, h4[i], p, ntype="ra")), "\n"))


# Rigdon (1995b), p. 372, Tab. 1
## Not run: 
r &lt;- 0.1
p &lt;- 4
h &lt;- 12.73
for ( sdelta in c(0, 0.125, 0.25, .5, 1, 2, 3) )
  cat(paste(sdelta, "\t",
      round(mewma.arl(r, h, p, delta=sdelta^2, ntype="ra", r=25), digits=2), "\n"))

p &lt;- 5
h &lt;- 14.56
for ( sdelta in c(0, 0.125, 0.25, .5, 1, 2, 3) )
  cat(paste(sdelta, "\t",
      round(mewma.arl(r, h, p, delta=sdelta^2, ntype="ra", r=25), digits=2), "\n"))

p &lt;- 10
h &lt;- 22.67
for ( sdelta in c(0, 0.125, 0.25, .5, 1, 2, 3) )
  cat(paste(sdelta, "\t",
      round(mewma.arl(r, h, p, delta=sdelta^2, ntype="ra", r=25), digits=2), "\n"))

## End(Not run)

# Runger/Prabhu (1996), p. 1704, Tab. 1
## Not run: 
r &lt;- 0.1
p &lt;- 4
H &lt;- 12.73
cat(paste(0, "\t", round(mewma.arl(r, H, p, delta=0, ntype="mc", r=50), digits=2), "\n"))
for ( delta in c(.5, 1, 1.5, 2, 3) )
  cat(paste(delta, "\t",
      round(mewma.arl(r, H, p, delta=delta, ntype="mc", r=25), digits=2), "\n"))
# compare with Fortran program (MEWMA-ARLs.f90) from Molnau et al. (2001) with m1 = m2 = 25
# H4      P     R   DEL  ARL
# 12.73  4.  0.10  0.00 199.78
# 12.73  4.  0.10  0.50  35.05
# 12.73  4.  0.10  1.00  12.17
# 12.73  4.  0.10  1.50   7.22
# 12.73  4.  0.10  2.00   5.19
# 12.73  4.  0.10  3.00   3.42

p &lt;- 20
H &lt;- 37.01
cat(paste(0, "\t",
    round(mewma.arl(r, H, p, delta=0, ntype="mc", r=50), digits=2), "\n"))
for ( delta in c(.5, 1, 1.5, 2, 3) )
  cat(paste(delta, "\t",
      round(mewma.arl(r, H, p, delta=delta, ntype="mc", r=25), digits=2), "\n"))
# compare with Fortran program (MEWMA-ARLs.f90) from Molnau et al. (2001) with m1 = m2 = 25
# H4      P     R   DEL  ARL
# 37.01 20.  0.10  0.00 199.09
# 37.01 20.  0.10  0.50  61.62
# 37.01 20.  0.10  1.00  20.17
# 37.01 20.  0.10  1.50  11.40
# 37.01 20.  0.10  2.00   8.03
# 37.01 20.  0.10  3.00   5.18

## End(Not run)

# Knoth (2017), p. 85, Tab. 3, rows with p=3
## Not run: 
p &lt;- 3
lambda &lt;- 0.05
h4 &lt;- mewma.crit(lambda, 200, p)
benchmark &lt;- mewma.arl(lambda, h4, p, delta=1, r=50)
  
mc.arl  &lt;- mewma.arl(lambda, h4, p, delta=1, r=25, ntype="mc")
ra.arl  &lt;- mewma.arl(lambda, h4, p, delta=1, r=27, ntype="ra")
co.arl  &lt;- mewma.arl(lambda, h4, p, delta=1, r=12, ntype="co2")
gl3.arl &lt;- mewma.arl(lambda, h4, p, delta=1, r=30, ntype="gl3")
gl5.arl &lt;- mewma.arl(lambda, h4, p, delta=1, r=25, ntype="gl5")
  
abs( benchmark - data.frame(mc.arl, ra.arl, co.arl, gl3.arl, gl5.arl) )

## End(Not run)

# Prabhu/Runger (1997), p. 13, Tab. 3
## Not run: 
p &lt;- 2
r &lt;- 0.1
H &lt;- 8.64
cat(paste(0, "\t",
    round(mewma.ad(r, H, p, delta=0, type="cycl", ntype="mc", r=60), digits=2), "\n"))
for ( delta in c(.5, 1, 1.5, 2, 3) )
  cat(paste(delta, "\t",
      round(mewma.ad(r, H, p, delta=delta, type="cycl", ntype="mc", r=30), digits=2), "\n"))

# better accuracy
for ( delta in c(0, .5, 1, 1.5, 2, 3) )
  cat(paste(delta, "\t",
      round(mewma.ad(r, H, p, delta=delta^2, type="cycl", r=30), digits=2), "\n"))

## End(Not run)
</code></pre>

<hr>
<h2 id='mewma.crit'>Compute alarm threshold of MEWMA control charts</h2><span id='topic+mewma.crit'></span>

<h3>Description</h3>

<p>Computation of the alarm threshold for multivariate exponentially weighted
moving average (MEWMA) charts monitoring multivariate normal mean.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mewma.crit(l, L0, p, hs=0, r=20)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mewma.crit_+3A_l">l</code></td>
<td>
<p>smoothing parameter lambda of the MEWMA control chart.</p>
</td></tr>
<tr><td><code id="mewma.crit_+3A_l0">L0</code></td>
<td>
<p>in-control ARL.</p>
</td></tr>
<tr><td><code id="mewma.crit_+3A_p">p</code></td>
<td>
<p>dimension of multivariate normal distribution.</p>
</td></tr>
<tr><td><code id="mewma.crit_+3A_hs">hs</code></td>
<td>
<p>so-called headstart (enables fast initial response) &ndash; must be non-negative.</p>
</td></tr>
<tr><td><code id="mewma.crit_+3A_r">r</code></td>
<td>
<p>number of quadrature nodes &ndash; dimension of the resulting linear equation system.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mewma.crit</code> determines the alarm threshold of for given in-control ARL <code>L0</code>
by applying secant rule and using <code>mewma.arl()</code> with <code>ntype="gl2"</code>.
</p>


<h3>Value</h3>

<p>Returns a single value which resembles the critical value <code>c</code>.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>Sven Knoth (2017),
ARL Numerics for MEWMA Charts,
<em>Journal of Quality Technology 49(1)</em>, 78-89.
</p>
<p>Steven E. Rigdon (1995),
An integral equation for the in-control average run length of a multivariate exponentially weighted moving average control chart,
<em>J. Stat. Comput. Simulation 52(4)</em>, 351-365.
</p>


<h3>See Also</h3>

<p><code>mewma.arl</code> for zero-state ARL computation.</p>


<h3>Examples</h3>

<pre><code class='language-R'># Rigdon (1995), p. 358, Tab. 1
p &lt;- 4
L0 &lt;- 500
r &lt;- .25
h4 &lt;- mewma.crit(r, L0, p)
h4
## original value is 16.38.

# Knoth (2017), p. 82, Tab. 2
p &lt;- 3
L0 &lt;- 1e3
lambda &lt;- c(0.25, 0.2, 0.15, 0.1, 0.05)
h4 &lt;- rep(NA, length(lambda) )
for ( i in 1:length(lambda) ) h4[i] &lt;- mewma.crit(lambda[i], L0, p, r=20)
round(h4, digits=2)
## original values are
## 15.82 15.62 15.31 14.76 13.60
</code></pre>

<hr>
<h2 id='mewma.psi'>Compute steady-state density of the MEWMA statistic</h2><span id='topic+mewma.psi'></span>

<h3>Description</h3>

<p>Computation of the (zero-state) steady-state density function of the statistic deployed in
multivariate exponentially weighted moving average (MEWMA) charts monitoring multivariate normal mean.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mewma.psi(l, cE, p, type="cond", hs=0, r=20)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mewma.psi_+3A_l">l</code></td>
<td>
<p>smoothing parameter lambda of the MEWMA control chart.</p>
</td></tr>
<tr><td><code id="mewma.psi_+3A_ce">cE</code></td>
<td>
<p>alarm threshold of the MEWMA control chart.</p>
</td></tr>
<tr><td><code id="mewma.psi_+3A_p">p</code></td>
<td>
<p>dimension of multivariate normal distribution.</p>
</td></tr>
<tr><td><code id="mewma.psi_+3A_type">type</code></td>
<td>
<p>switch between <code>"cond"</code> and <code>"cycl"</code> for differentiating between the conditional
(no false alarm) and the cyclical (after false alarm re-start in <code>hs</code>), respectively.</p>
</td></tr>
<tr><td><code id="mewma.psi_+3A_hs">hs</code></td>
<td>
<p>the re-starting point for the cyclical steady-state framework.</p>
</td></tr>
<tr><td><code id="mewma.psi_+3A_r">r</code></td>
<td>
<p>number of quadrature nodes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Basically, ideas from Knoth (2017, MEWMA numerics) and Knoth (2016, steady-state ARL concepts) are merged.
More details will follow.</p>


<h3>Value</h3>

<p>Returns a function.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>Sven Knoth (2016),
The Case Against the Use of Synthetic Control Charts,
<em>Journal of Quality Technology 48(2)</em>, 178-195.
</p>
<p>Sven Knoth (2017),
ARL Numerics for MEWMA Charts,
<em>Journal of Quality Technology 49(1)</em>, 78-89.
</p>
<p>Sven Knoth (2018),
The Steady-State Behavior of Multivariate Exponentially Weighted Moving Average Control Charts,
<em>Sequential Analysis 37(4)</em>, 511-529.
</p>


<h3>See Also</h3>

<p><code>mewma.arl</code> for calculating the in-control ARL of MEWMA.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lambda &lt;- 0.1
L0 &lt;- 200
p &lt;- 3
h4 &lt;- mewma.crit(lambda, L0, p)
x_ &lt;- seq(0, h4*lambda/(2-lambda), by=0.002)
psi &lt;- mewma.psi(lambda, h4, p)
psi_ &lt;- psi(x_)
# plot(x_, psi_, type="l", xlab="x", ylab=expression(psi(x)), xlim=c(0,1.2))
# cf. to Figure 1 in Knoth (2018), p. 514, p=3
</code></pre>

<hr>
<h2 id='p.ewma.arl'>Compute ARLs of binomial EWMA p control charts</h2><span id='topic+p.ewma.arl'></span>

<h3>Description</h3>

<p>Computation of the (zero-state) Average Run Length (ARL) at given rate <code>p</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>p.ewma.arl(lambda, ucl, n, p, z0, sided="upper", lcl=NULL, d.res=1,
r.mode="ieee.round", i.mode="integer")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p.ewma.arl_+3A_lambda">lambda</code></td>
<td>
<p>smoothing parameter of the EWMA p control chart.</p>
</td></tr>
<tr><td><code id="p.ewma.arl_+3A_ucl">ucl</code></td>
<td>
<p>upper control limit of the EWMA p control chart.</p>
</td></tr>
<tr><td><code id="p.ewma.arl_+3A_n">n</code></td>
<td>
<p>subgroup size.</p>
</td></tr>
<tr><td><code id="p.ewma.arl_+3A_p">p</code></td>
<td>
<p>(failure/success) rate.</p>
</td></tr>
<tr><td><code id="p.ewma.arl_+3A_z0">z0</code></td>
<td>
<p>so-called headstart (give fast initial response).</p>
</td></tr>
<tr><td><code id="p.ewma.arl_+3A_sided">sided</code></td>
<td>
<p>distinguishes between one- and two-sided EWMA control chart by choosing <code>"upper"</code>, <code>"lower"</code>, and <code>"two"</code>, respectively.</p>
</td></tr>
<tr><td><code id="p.ewma.arl_+3A_lcl">lcl</code></td>
<td>
<p>lower control limit of the EWMA p control chart; needed for two-sided design.</p>
</td></tr>
<tr><td><code id="p.ewma.arl_+3A_d.res">d.res</code></td>
<td>
<p>resolution (see details).</p>
</td></tr>
<tr><td><code id="p.ewma.arl_+3A_r.mode">r.mode</code></td>
<td>
<p>round mode &ndash; allowed modes are <code>"gan.floor"</code>, <code>"floor"</code>, <code>"ceil"</code>,
<code>"ieee.round"</code>, <code>"round"</code>, <code>"mix"</code>.</p>
</td></tr>
<tr><td><code id="p.ewma.arl_+3A_i.mode">i.mode</code></td>
<td>
<p>type of interval center &ndash; <code>"integer"</code> or <code>"half"</code> integer.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The monitored data follow a binomial distribution with size <code>n</code> and failure/success probability <code>p</code>.
The ARL values of the resulting EWMA control chart are determined by Markov chain approximation.
Here, the original EWMA values are approximated by
multiples of one over <code>d.res</code>. Different ways of rounding (see <code>r.mode</code>) to the next multiple are implemented.
Besides Gan's paper nothing is published about the numerical subtleties.
</p>


<h3>Value</h3>

<p>Return single value which resemble the ARL.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>F. F. Gan (1990),
Monitoring observations generated from a binomial distribution using modified
exponentially weighted moving average control chart,
<em>J. Stat. Comput. Simulation</em> 37, 45-60.
</p>
<p>S. Knoth and S. Steinmetz (2013),
EWMA <code>p</code> charts  under sampling by variables,
<em>International Journal of Production Research</em> 51, 3795-3807.
</p>


<h3>See Also</h3>

<p>later.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Gan (1990)

# Table 1

n &lt;- 150
p0 &lt;- .1
z0 &lt;- n*p0

lambda &lt;- c(1, .51, .165)
hu &lt;- c(27, 22, 18)

p.value &lt;- .1 + (0:20)/200

p.EWMA.arl &lt;- Vectorize(p.ewma.arl, "p")

arl1.value &lt;- round(p.EWMA.arl(lambda[1], hu[1], n, p.value, z0, r.mode="round"), digits=2)
arl2.value &lt;- round(p.EWMA.arl(lambda[2], hu[2], n, p.value, z0, r.mode="round"), digits=2)
arl3.value &lt;- round(p.EWMA.arl(lambda[3], hu[3], n, p.value, z0, r.mode="round"), digits=2)

arls &lt;- matrix(c(arl1.value, arl2.value, arl3.value), ncol=length(lambda))
rownames(arls) &lt;- p.value
colnames(arls) &lt;- paste("lambda =", lambda)
arls

## Knoth/Steinmetz (2013)

n &lt;- 5
p0 &lt;- 0.02
z0 &lt;- n*p0
lambda &lt;- 0.3
ucl &lt;- 0.649169922 ## in-control ARL 370.4 (determined with d.res = 2^14 = 16384)

res.list &lt;- 2^(1:11)
arl.list &lt;- NULL
for ( res in res.list ) {
  arl &lt;- p.ewma.arl(lambda, ucl, n, p0, z0, d.res=res)
  arl.list &lt;- c(arl.list, arl)
}
cbind(res.list, arl.list)
</code></pre>

<hr>
<h2 id='phat.ewma.arl'>Compute ARLs of EWMA phat control charts</h2><span id='topic+phat.ewma.arl'></span><span id='topic+phat.ewma.crit'></span><span id='topic+phat.ewma.lambda'></span>

<h3>Description</h3>

<p>Computation of the (zero-state) Average Run Length (ARL), upper control limit (ucl)
for given in-control ARL, and lambda for minimal out-of control ARL at given shift.</p>


<h3>Usage</h3>

<pre><code class='language-R'>phat.ewma.arl(lambda, ucl, mu, n, z0, sigma=1, type="known", LSL=-3, USL=3, N=15,
qm=25, ntype="coll")

phat.ewma.crit(lambda, L0, mu, n, z0, sigma=1, type="known", LSL=-3, USL=3, N=15, qm=25)

phat.ewma.lambda(L0, mu, n, z0, sigma=1, type="known", max_l=1, min_l=.001, LSL=-3, USL=3,
qm=25)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phat.ewma.arl_+3A_lambda">lambda</code></td>
<td>
<p>smoothing parameter of the EWMA control chart.</p>
</td></tr>
<tr><td><code id="phat.ewma.arl_+3A_ucl">ucl</code></td>
<td>
<p>upper control limit of the EWMA phat control chart.</p>
</td></tr>
<tr><td><code id="phat.ewma.arl_+3A_l0">L0</code></td>
<td>
<p>pre-defined in-control ARL (Average Run Length).</p>
</td></tr>
<tr><td><code id="phat.ewma.arl_+3A_mu">mu</code></td>
<td>
<p>true mean or mean where the ARL should be minimized (then the in-control mean is simply 0).</p>
</td></tr>
<tr><td><code id="phat.ewma.arl_+3A_n">n</code></td>
<td>
<p>subgroup size.</p>
</td></tr>
<tr><td><code id="phat.ewma.arl_+3A_z0">z0</code></td>
<td>
<p>so-called headstart (gives fast initial response).</p>
</td></tr>
<tr><td><code id="phat.ewma.arl_+3A_type">type</code></td>
<td>
<p>choose whether the standard deviation is given and fixed (<code>"known"</code>) or estimated and potentially monitored (<code>"estimated"</code>).</p>
</td></tr>
<tr><td><code id="phat.ewma.arl_+3A_sigma">sigma</code></td>
<td>
<p>actual standard deviation of the data &ndash; the in-control value is 1.</p>
</td></tr>
<tr><td><code id="phat.ewma.arl_+3A_max_l">max_l</code>, <code id="phat.ewma.arl_+3A_min_l">min_l</code></td>
<td>
<p>maximal and minimal value for optimal lambda search.</p>
</td></tr>
<tr><td><code id="phat.ewma.arl_+3A_lsl">LSL</code>, <code id="phat.ewma.arl_+3A_usl">USL</code></td>
<td>
<p>lower and upper specification limit, respectively.</p>
</td></tr>
<tr><td><code id="phat.ewma.arl_+3A_n">N</code></td>
<td>
<p>size of collocation base, dimension of the resulting linear equation system is equal to <code>N</code>.</p>
</td></tr>
<tr><td><code id="phat.ewma.arl_+3A_qm">qm</code></td>
<td>
<p>number of nodes for collocation quadratures.</p>
</td></tr>
<tr><td><code id="phat.ewma.arl_+3A_ntype">ntype</code></td>
<td>
<p>switch between the default method <code>coll</code> (collocation) and the classic one <code>markov</code> (Markov chain approximation)
for calculating the ARL numerically.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The three implemented functions allow to apply a new type control chart. Basically, lower and upper
specification limits are given. The monitoring
vehicle then is the empirical probability that an item will not follow these specification given the
sequence of sample means. If
the related EWMA sequence violates the control limits, then the alarm indicates a significant process
deterioration. For details see the
paper mentioned in the references. To be able to construct the control charts, see the first example.
</p>


<h3>Value</h3>

<p>Return single values which resemble the ARL, the critical value, and the optimal lambda, respectively.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>S. Knoth and S. Steinmetz (2013),
EWMA <code>p</code> charts  under sampling by variables,
<em>International Journal of Production Research</em> 51, 3795-3807.
</p>


<h3>See Also</h3>

<p><code>sewma.arl</code> for a further collocation based ARL calculation routine.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simple example to demonstrate the chart.

# some functions
h.mu &lt;- function(mu) pnorm(LSL-mu) + pnorm(mu-USL)
ewma &lt;- function(x, lambda=0.1, z0=0) filter(lambda*x, 1-lambda, m="r", init=z0)

# parameters
LSL &lt;- -3       # lower specification limit
USL &lt;-  3	# upper specification limit
n &lt;- 5		# batch size
lambda &lt;- 0.1	# EWMA smoothing parameter
L0 &lt;- 1000	# in-control Average Run Length (ARL)
z0 &lt;- h.mu(0)	# start at minimal defect level
ucl &lt;- phat.ewma.crit(lambda, L0, 0, n, z0, LSL=LSL, USL=USL)

# data
x0 &lt;- matrix(rnorm(50*n), ncol=5)	# in-control data
x1 &lt;- matrix(rnorm(50*n, mean=0.5), ncol=5)# out-of-control data
x &lt;- rbind(x0,x1)			# all data

# create chart
xbar &lt;- apply(x, 1, mean)
phat &lt;- h.mu(xbar)
z &lt;- ewma(phat, lambda=lambda, z0=z0)
plot(1:length(z), z, type="l", xlab="batch", ylim=c(0,.02))
abline(h=z0, col="grey", lwd=.7)
abline(h=ucl, col="red")


## S. Knoth, S. Steinmetz (2013)

# Table 1

lambdas &lt;- c(.5, .25, .2, .1)
L0 &lt;- 370.4
n &lt;- 5
LSL &lt;- -3
USL &lt;- 3

phat.ewma.CRIT &lt;- Vectorize("phat.ewma.crit", "lambda")
p.star &lt;- pnorm( LSL ) + pnorm( -USL ) ## lower bound of the chart
ucls &lt;- phat.ewma.CRIT(lambdas, L0, 0, n, p.star, LSL=LSL, USL=USL)
print(cbind(lambdas, ucls))

# Table 2

mus &lt;- c((0:4)/4, 1.5, 2, 3)
phat.ewma.ARL &lt;- Vectorize("phat.ewma.arl", "mu")
arls &lt;- NULL
for ( i in 1:length(lambdas) ) {
  arls &lt;- cbind(arls, round(phat.ewma.ARL(lambdas[i], ucls[i], mus,
                n, p.star, LSL=LSL, USL=USL), digits=2))
}
arls &lt;- data.frame(arls, row.names=NULL)
names(arls) &lt;- lambdas
print(arls)

# Table 3

## Not run: 
mus &lt;- c(.25, .5, 1, 2)
phat.ewma.LAMBDA &lt;- Vectorize("phat.ewma.lambda", "mu")
lambdas &lt;- phat.ewma.LAMBDA(L0, mus, n, p.star, LSL=LSL, USL=USL)
print(cbind(mus, lambdas))
## End(Not run)
</code></pre>

<hr>
<h2 id='pois.cusum.arl'>Compute ARLs of Poisson CUSUM control charts</h2><span id='topic+pois.cusum.arl'></span>

<h3>Description</h3>

<p>Computation of the (zero-state) Average Run Length (ARL) at given mean <code>mu</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>pois.cusum.arl(mu, km, hm, m, i0=0, sided="upper", rando=FALSE,
gamma=0, km2=0, hm2=0, m2=0, i02=0, gamma2=0)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pois.cusum.arl_+3A_mu">mu</code></td>
<td>
<p>actual mean.</p>
</td></tr>
<tr><td><code id="pois.cusum.arl_+3A_km">km</code></td>
<td>
<p>enumerator of rational approximation of reference value <code>k</code>.</p>
</td></tr>
<tr><td><code id="pois.cusum.arl_+3A_hm">hm</code></td>
<td>
<p>enumerator of rational approximation of reference value <code>h</code>.</p>
</td></tr>
<tr><td><code id="pois.cusum.arl_+3A_m">m</code></td>
<td>
<p>denominator of rational approximation of reference value.</p>
</td></tr>
<tr><td><code id="pois.cusum.arl_+3A_i0">i0</code></td>
<td>
<p>head start value as integer multiple of <code>1/m</code>; should be an element of <code>0:hm</code>.</p>
</td></tr>
<tr><td><code id="pois.cusum.arl_+3A_sided">sided</code></td>
<td>
<p>distinguishes between different one- and two-sided CUSUM control chart by choosing
<code>"upper"</code>, <code>"lower"</code> and <code>"two"</code>, respectively.</p>
</td></tr>
<tr><td><code id="pois.cusum.arl_+3A_rando">rando</code></td>
<td>
<p>Switch for activating randomization in order to allow continuous ARL control.</p>
</td></tr>
<tr><td><code id="pois.cusum.arl_+3A_gamma">gamma</code></td>
<td>
<p>Randomization probability. If the CUSUM statistic is equal to the threshold <code>h</code>,
an control chart alarm is triggered with probability <code>gamma</code>.</p>
</td></tr>
<tr><td><code id="pois.cusum.arl_+3A_km2">km2</code>, <code id="pois.cusum.arl_+3A_hm2">hm2</code>, <code id="pois.cusum.arl_+3A_m2">m2</code>, <code id="pois.cusum.arl_+3A_i02">i02</code>, <code id="pois.cusum.arl_+3A_gamma2">gamma2</code></td>
<td>
<p>corresponding values of the second CUSUM chart (to building a two-sided CUSUM scheme).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The monitored data follow a Poisson distribution with <code>mu</code>.
The ARL values of the resulting EWMA control chart are determined via Markov chain calculations.
We follow the algorithm given in Lucas (1985) expanded with some arithmetic 'tricks' (e.g., by deploying
Toeplitz matrix algebra). A paper explaining it is under preparation.
</p>


<h3>Value</h3>

<p>Returns a single value which resembles the ARL.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>J. M. Lucas (1985)
Counted data CUSUM's,
<em>Technometrics</em> 27(2), 129-144.
</p>
<p>C. H. White and J. B. Keats (1996)
ARLs and Higher-Order Run-Length Moments for the Poisson CUSUM,
<em>Journal of Quality Technology</em> 28(3), 363-369.
</p>
<p>C. H. White, J. B. Keats and J. Stanley (1997)
Poisson CUSUM versus c chart for defect data,
<em>Quality Engineering</em> 9(4), 673-679.
</p>
<p>G. Rossi and L. Lampugnani and M. Marchi (1999),
An approximate CUSUM procedure for surveillance of health events,
<em>Statistics in Medicine</em> 18(16), 2111-2122.
</p>
<p>S. W. Han, K.-L. Tsui, B. Ariyajunya, and S. B. Kim (2010),
A comparison of CUSUM, EWMA, and temporal scan statistics for detection of increases in poisson rates,
<em>Quality and Reliability Engineering International</em> 26(3), 279-289.
</p>
<p>M. B. Perry and J. J. Pignatiello Jr. (2011)
Estimating the time of step change with Poisson CUSUM and EWMA control charts,
<em>International Journal of Production Research</em> 49(10), 2857-2871.
</p>


<h3>See Also</h3>

<p>later.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Lucas 1985, upper chart (Tables 2 and 3)
k   &lt;- .25
h   &lt;- 10
m   &lt;- 4
km  &lt;- m * k
hm  &lt;- m * h
mu0 &lt;- 1 * k
ARL &lt;- pois.cusum.arl(mu0, km, hm-1, m)
# Lucas reported 438 (in Table 2, first block, row 10.0 .25 .0 ..., column 1.0
# Recall that Lucas and other trigger an alarm, if the CUSUM statistic is greater than
# or equal to the alarm threshold h
print(ARL)

ARL &lt;- pois.cusum.arl(mu0, km, hm-1, m, i0=round((hm-1)/2))
# Lucas reported 333 (in Table 3, first block, row 10.0 .25 .0 ..., column 1.0
print(ARL)

## Lucas 1985, lower chart (Tables 4 and 5)
ARL &lt;- pois.cusum.arl(mu0, km, hm-1, m, sided="lower")
# Lucas reported 437 (in Table 4, first block, row 10.0 .25 .0 ..., column 1.0
print(ARL)

ARL &lt;- pois.cusum.arl(mu0, km, hm-1, m, i0=round((hm-1)/2), sided="lower")
# Lucas reported 318 (in Table 5, first block, row 10.0 .25 .0 ..., column 1.0
print(ARL)
</code></pre>

<hr>
<h2 id='pois.cusum.crit'>Compute alarm thresholds and randomization constants of Poisson CUSUM control charts</h2><span id='topic+pois.cusum.crit'></span>

<h3>Description</h3>

<p>Computation of the CUSUM upper limit and, if needed, of the randomization probability, given mean <code>mu0</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>pois.cusum.crit(mu0, km, A, m, i0=0, sided="upper", rando=FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pois.cusum.crit_+3A_mu0">mu0</code></td>
<td>
<p>actual in-control mean.</p>
</td></tr>
<tr><td><code id="pois.cusum.crit_+3A_km">km</code></td>
<td>
<p>enumerator of rational approximation of reference value <code>k</code>.</p>
</td></tr>
<tr><td><code id="pois.cusum.crit_+3A_a">A</code></td>
<td>
<p>target in-control ARL (average run length).</p>
</td></tr>
<tr><td><code id="pois.cusum.crit_+3A_m">m</code></td>
<td>
<p>denominator of rational approximation of reference value.</p>
</td></tr>
<tr><td><code id="pois.cusum.crit_+3A_i0">i0</code></td>
<td>
<p>head start value as integer multiple of <code>1/m</code>; should be an element of <code>0:100</code> (a more reasonable upper limit will be established soon). It is planned, to set <code>i0</code> as a fraction of the final threshold.</p>
</td></tr>
<tr><td><code id="pois.cusum.crit_+3A_sided">sided</code></td>
<td>
<p>distinguishes between different one- and two-sided CUSUM control chart by choosing
<code>"upper"</code>, <code>"lower"</code> and <code>"two"</code>, respectively.</p>
</td></tr>
<tr><td><code id="pois.cusum.crit_+3A_rando">rando</code></td>
<td>
<p>Switch for activating randomization in order to allow continuous ARL control.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The monitored data follow a Poisson distribution with <code>mu</code> (here the in-control level <code>mu0</code>).
The ARL values of the resulting EWMA control chart are determined via Markov chain calculations.
With some grid search, we obtain the smallest value for the integer threshold component <code>hm</code> so that
the resulting ARL is not smaller than <code>A</code>. If equality is needed, then activating <code>rando=TRUE</code>
yields the corresponding randomization probability <code>gamma</code>.
More details will follow in a paper that will be submitted in 2020.
</p>


<h3>Value</h3>

<p>Returns two single values, integer threshold <code>hm</code> resulting in the final
alarm threshold <code>h=hm/m</code>, and the randomization probability.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>J. M. Lucas (1985)
Counted data CUSUM's,
<em>Technometrics</em> 27(2), 129-144.
</p>
<p>C. H. White and J. B. Keats (1996)
ARLs and Higher-Order Run-Length Moments for the Poisson CUSUM,
<em>Journal of Quality Technology</em> 28(3), 363-369.
</p>
<p>C. H. White, J. B. Keats and J. Stanley (1997)
Poisson CUSUM versus c chart for defect data,
<em>Quality Engineering</em> 9(4), 673-679.
</p>
<p>G. Rossi and L. Lampugnani and M. Marchi (1999),
An approximate CUSUM procedure for surveillance of health events,
<em>Statistics in Medicine</em> 18(16), 2111-2122.
</p>
<p>S. W. Han, K.-L. Tsui, B. Ariyajunya, and S. B. Kim (2010),
A comparison of CUSUM, EWMA, and temporal scan statistics for detection of increases in poisson rates,
<em>Quality and Reliability Engineering International</em> 26(3), 279-289.
</p>
<p>M. B. Perry and J. J. Pignatiello Jr. (2011)
Estimating the time of step change with Poisson CUSUM and EWMA control charts,
<em>International Journal of Production Research</em> 49(10), 2857-2871.
</p>


<h3>See Also</h3>

<p>later.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Lucas 1985
mu0 &lt;- 0.25
km &lt;- 1
A &lt;- 430
m  &lt;- 4
#cv &lt;- pois.cusum.crit(mu0, km, A, m)
cv &lt;- c(40, 0)
# Lucas reported h = 10 alias hm = 40 (in Table 2, first block, row 10.0 .25 .0 ..., column 1.0
# Recall that Lucas and other trigger an alarm, if the CUSUM statistic is greater than
# or equal to the alarm threshold h
print(cv)
</code></pre>

<hr>
<h2 id='pois.cusum.crit.L0L1'>Compute the CUSUM k and h for given in-control ARL L0 and out-of-control ARL L1, Poisson case</h2><span id='topic+pois.cusum.crit.L0L1'></span>

<h3>Description</h3>

<p>Computation of the reference value k and the alarm threshold h
for one-sided CUSUM control charts monitoring Poisson data, if the in-control ARL L0 and the out-of-control ARL L1 are given.</p>


<h3>Usage</h3>

<pre><code class='language-R'>pois.cusum.crit.L0L1(mu0, L0, L1, sided="upper", OUTPUT=FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pois.cusum.crit.L0L1_+3A_mu0">mu0</code></td>
<td>
<p>in-control Poisson mean.</p>
</td></tr>
<tr><td><code id="pois.cusum.crit.L0L1_+3A_l0">L0</code></td>
<td>
<p>in-control ARL.</p>
</td></tr>
<tr><td><code id="pois.cusum.crit.L0L1_+3A_l1">L1</code></td>
<td>
<p>out-of-control ARL.</p>
</td></tr>
<tr><td><code id="pois.cusum.crit.L0L1_+3A_sided">sided</code></td>
<td>
<p>distinguishes between <code>"upper"</code> and <code>"lower"</code> CUSUM designs.</p>
</td></tr>
<tr><td><code id="pois.cusum.crit.L0L1_+3A_output">OUTPUT</code></td>
<td>
<p>controls whether iteration details are printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pois.cusum.crit.L0L1</code> determines the reference value k and the alarm threshold h
for given in-control ARL <code>L0</code> and out-of-control ARL <code>L1</code>
by applying grid search and using <code>pois.cusum.arl()</code> and <code>pois.cusum.crit()</code>.
These CUSUM design rules were firstly (and quite rarely afterwards) used by Ewan and Kemp.
In the Poisson case, Rossi et al. applied them while analyzing three different normal
approximations of the Poisson distribution. See the example which illustrates
the validity of all these approaches.
</p>


<h3>Value</h3>

<p>Returns a data frame with results for the denominator <code>m</code> of the rational approximation,
<code>km</code> as (integer) enumerator of the reference value (approximation), the corresponding
out-of-control mean <code>mu1</code>, the final approximation <code>k</code> of the reference value,
the threshold values <code>hm</code> (integer) and <code>h</code> (<code>=hm/m</code>), and the randomization constant
<code>gamma</code> (the target in-control ARL is exactly matched).</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>W. D. Ewan and K. W. Kemp (1960),
Sampling inspection of continuous processes with no autocorrelation between successive results,
<em>Biometrika</em> 47 (3/4), 363-380.
</p>
<p>K. W. Kemp (1962),
The Use of Cumulative Sums for Sampling Inspection Schemes,
<em>Journal of the Royal Statistical Sociecty C, Applied Statistics</em> 11(1), 16-31.
</p>
<p>G. Rossi, L. Lampugnani and M. Marchi (1999),
An approximate CUSUM procedure for surveillance of health events,
<em>Statistics in Medicine</em> 18(16), 2111-2122.
</p>


<h3>See Also</h3>

<p><code>pois.cusum.arl</code> for zero-state ARL and <code>pois.cusum.crit</code> for threshold h computation.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Table 1 from Rossi et al. (1999) -- one-sided CUSUM
La &lt;- 500 # in-control ARL
Lr &lt;- 7 # out-of-control ARL
m_a &lt;- 0.52 # in-control mean of the Poisson variate
## Not run: kh &lt;- xcusum.crit.L0L1(La, Lr, sided="one") # instead of deploying EK1960, one could use more accurate numbers
EK_k &lt;- 0.60 # EK1960 results in
EK_h &lt;- 3.80 # Table 2 on p. 372
eZR &lt;- 2*EK_h # reproduce normal ooc mean from reference value k
m_r &lt;- 1.58 # EK1960 Table 3 on p. 377 for m_a = 0.52
R1 &lt;- round( eZR/sqrt(m_a) + 1, digits=2)
R2 &lt;- round( ( eZR/2/sqrt(m_a) + 1 )^2, digits=2)
R3 &lt;- round(( sqrt(4 + 2*eZR/sqrt(m_a)) - 1 )^2, digits=2)
RS &lt;- round( m_r / m_a, digits=2 )
## Not run: K_hk &lt;- pois.cusum.crit.L0L1(m_a, La, Lr) # 'our' 'exact' approach
K_hk &lt;- data.frame(m=1000, km=948, mu1=1.563777, k=0.948, hm=3832, h=3.832, gamma=0.1201901)
# get k for competing means mu0 (m_a) and mu1 (m_r)
k_m01 &lt;- function(mu0, mu1) (mu1 - mu0) / (log(mu1) - log(mu0))
# get ooc mean mu1 (m_r) for given mu0 (m_a) and reference value k
m1_km0 &lt;- function(mu0, k) {
  zero &lt;- function(x) k - k_m01(mu0,x)
  upper &lt;- mu0 + .5
  while ( zero(upper) &gt; 0 ) upper &lt;- upper + 0.5
  mu1 &lt;- uniroot(zero, c(mu0*1.00000001, upper), tol=1e-9)$root
  mu1
}
K_m_r &lt;- m1_km0(m_a, K_hk$k)
RK &lt;- round( K_m_r / m_a, digits=2 )
cat(paste(m_a, R1, R2, R3, RS, RK, "\n", sep="\t"))
</code></pre>

<hr>
<h2 id='pois.ewma.ad'>Compute steady-state ARLs of Poisson EWMA control charts</h2><span id='topic+pois.ewma.ad'></span>

<h3>Description</h3>

<p>Computation of the steady-state Average Run Length (ARL) at given mean <code>mu</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>pois.ewma.ad(lambda, AL, AU, mu0, mu, sided="two", rando=FALSE, gL=0, gU=0,
mcdesign="classic", N=101)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pois.ewma.ad_+3A_lambda">lambda</code></td>
<td>
<p>smoothing parameter of the EWMA p control chart.</p>
</td></tr>
<tr><td><code id="pois.ewma.ad_+3A_al">AL</code>, <code id="pois.ewma.ad_+3A_au">AU</code></td>
<td>
<p>factors to build the lower and upper control limit, respectively, of the Poisson EWMA control chart.</p>
</td></tr>
<tr><td><code id="pois.ewma.ad_+3A_mu0">mu0</code></td>
<td>
<p>in-control mean.</p>
</td></tr>
<tr><td><code id="pois.ewma.ad_+3A_mu">mu</code></td>
<td>
<p>actual mean.</p>
</td></tr>
<tr><td><code id="pois.ewma.ad_+3A_sided">sided</code></td>
<td>
<p>distinguishes between one- and two-sided EWMA control chart by choosing
<code>"upper"</code>, <code>"lower"</code>, and <code>"two"</code>, and <code>"zwei"</code>, respectively.</p>
</td></tr>
<tr><td><code id="pois.ewma.ad_+3A_rando">rando</code></td>
<td>
<p>Switch between the standard limit treatment, <code>FALSE</code>,
and an additional randomisation (to allow &lsquo;perfect&rsquo; ARL calibration) by setting <code>TRUE</code>.
If randomisation is used, then set the corresponding probailities, <code>gL</code> and <code>gU</code>, appropriately.</p>
</td></tr>
<tr><td><code id="pois.ewma.ad_+3A_gl">gL</code>, <code id="pois.ewma.ad_+3A_gu">gU</code></td>
<td>
<p>If the EWMA statistic is at the limit (approximately), then an alarm is triggered with probability
<code>gL</code> and <code>gU</code> for the lower and upper limit, respectively.</p>
</td></tr>
<tr><td><code id="pois.ewma.ad_+3A_mcdesign">mcdesign</code></td>
<td>
<p>choose either <code>"classic"</code> which follows Borror, Champ and Rigdon (1998), or the more
sophisticated <code>"transfer"</code> which improves the accuracy heavily.</p>
</td></tr>
<tr><td><code id="pois.ewma.ad_+3A_n">N</code></td>
<td>
<p>number of states of the approximating Markov chain; is equal to the dimension of the
resulting linear equation system.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The monitored data follow a Poisson distribution with <code>mu</code>.
The ARL values of the resulting EWMA control chart are determined by Markov chain approximation.
We follow the algorithm given in Borror, Champ and Rigdon (1998). The function is in an early development phase.
</p>


<h3>Value</h3>

<p>Return single value which resembles the steady-state ARL.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>C. M. Borror, C. W. Champ and S. E. Rigdon (1998)
Poisson EWMA control charts,
<em>Journal of Quality Technonlogy</em> 30(4), 352-361.
</p>
<p>M. C. Morais and S. Knoth (2020)
Improving the ARL profile and the accuracy of its calculation for Poisson EWMA charts,
<em>Quality and Reliability Engineering International</em> 36(3), 876-889.
</p>


<h3>See Also</h3>

<p>later.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Borror, Champ and Rigdon (1998), Table 2, PEWMA column
mu0 &lt;- 20
lambda &lt;- 0.27
A &lt;- 3.319
mu1  &lt;- c(2*(3:15), 35)
ARL1 &lt;- AD1 &lt;- rep(NA, length(mu1))
for ( i in 1:length(mu1) ) {
  ARL1[i] &lt;- round(pois.ewma.arl(lambda,A,A,mu0,mu0,mu1[i],mcdesign="classic"),digits=1)
  AD1[i]  &lt;- round(pois.ewma.ad(lambda,A,A,mu0,mu1[i],mcdesign="classic"),digits=1)
}
print( cbind(mu1, ARL1, AD1) )

## Morais and Knoth (2020), Table 2, lambda = 0.27 column
## randomisation not implemented for pois.ewma.ad()
lambda &lt;- 0.27
AL &lt;- 3.0870
AU &lt;- 3.4870
gL &lt;- 0.001029
gU &lt;- 0.000765
mu2  &lt;- c(16, 18, 19.99, mu0, 20.01, 22, 24)
ARL2 &lt;- AD2 &lt;- rep(NA, length(mu2))
for ( i in 1:length(mu2) ) {
  ARL2[i] &lt;- round(pois.ewma.arl(lambda,AL,AU,mu0,mu0,mu2[i],rando=FALSE), digits=1)
  AD2[i] &lt;- round(pois.ewma.ad(lambda,AL,AU,mu0,mu2[i],rando=FALSE), digits=1)
}
print( cbind(mu2, ARL2, AD2) )
</code></pre>

<hr>
<h2 id='pois.ewma.arl'>Compute ARLs of Poisson EWMA control charts</h2><span id='topic+pois.ewma.arl'></span>

<h3>Description</h3>

<p>Computation of the (zero-state) Average Run Length (ARL) at given mean <code>mu</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>pois.ewma.arl(lambda, AL, AU, mu0, z0, mu, sided="two", rando=FALSE, gL=0, gU=0,
mcdesign="transfer", N=101)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pois.ewma.arl_+3A_lambda">lambda</code></td>
<td>
<p>smoothing parameter of the EWMA p control chart.</p>
</td></tr>
<tr><td><code id="pois.ewma.arl_+3A_al">AL</code>, <code id="pois.ewma.arl_+3A_au">AU</code></td>
<td>
<p>factors to build the lower and upper control limit, respectively, of the Poisson EWMA control chart.</p>
</td></tr>
<tr><td><code id="pois.ewma.arl_+3A_mu0">mu0</code></td>
<td>
<p>in-control mean.</p>
</td></tr>
<tr><td><code id="pois.ewma.arl_+3A_z0">z0</code></td>
<td>
<p>so-called headstart (give fast initial response).</p>
</td></tr>
<tr><td><code id="pois.ewma.arl_+3A_mu">mu</code></td>
<td>
<p>actual mean.</p>
</td></tr>
<tr><td><code id="pois.ewma.arl_+3A_sided">sided</code></td>
<td>
<p>distinguishes between one- and two-sided EWMA control chart by choosing
<code>"upper"</code>, <code>"lower"</code>, and <code>"two"</code>, and <code>"zwei"</code>, respectively.</p>
</td></tr>
<tr><td><code id="pois.ewma.arl_+3A_rando">rando</code></td>
<td>
<p>Switch between the standard limit treatment, <code>FALSE</code>,
and an additional randomisation (to allow &lsquo;perfect&rsquo; ARL calibration) by setting <code>TRUE</code>.
If randomisation is used, then set the corresponding probailities, <code>gL</code> and <code>gU</code>, appropriately.</p>
</td></tr>
<tr><td><code id="pois.ewma.arl_+3A_gl">gL</code>, <code id="pois.ewma.arl_+3A_gu">gU</code></td>
<td>
<p>If the EWMA statistic is at the limit (approximately), then an alarm is triggered with probability
<code>gL</code> and <code>gU</code> for the lower and upper limit, respectively.</p>
</td></tr>
<tr><td><code id="pois.ewma.arl_+3A_mcdesign">mcdesign</code></td>
<td>
<p>choose either <code>"classic"</code> which follows Borror, Champ and Rigdon (1998), or the more
sophisticated <code>"transfer"</code> which improves the accuracy heavily.</p>
</td></tr>
<tr><td><code id="pois.ewma.arl_+3A_n">N</code></td>
<td>
<p>number of states of the approximating Markov chain; is equal to the dimension of the
resulting linear equation system.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The monitored data follow a Poisson distribution with <code>mu</code>.
The ARL values of the resulting EWMA control chart are determined by Markov chain approximation.
We follow the algorithm given in Borror, Champ and Rigdon (1998).
However, by setting <code>mcdesign="transfer"</code> (now the default) from Morais and Knoth (2020),
the accuracy is considerably improved.
</p>


<h3>Value</h3>

<p>Return single value which resembles the ARL.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>C. M. Borror, C. W. Champ and S. E. Rigdon (1998)
Poisson EWMA control charts,
<em>Journal of Quality Technonlogy</em> 30(4), 352-361.
</p>
<p>M. C. Morais and S. Knoth (2020)
Improving the ARL profile and the accuracy of its calculation for Poisson EWMA charts,
<em>Quality and Reliability Engineering International</em> 36(3), 876-889.
</p>


<h3>See Also</h3>

<p>later.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Borror, Champ and Rigdon (1998), Table 2, PEWMA column
mu0 &lt;- 20
lambda &lt;- 0.27
A &lt;- 3.319
mu1  &lt;- c(2*(3:15), 35)
ARL1 &lt;- rep(NA, length(mu1))
for ( i in 1:length(mu1) )
  ARL1[i] &lt;- pois.ewma.arl(lambda, A, A, mu0, mu0, mu1[i], mcdesign="classic")
print(cbind(mu1, round(ARL1, digits=1)))

## the same numbers with improved accuracy
ARL2 &lt;- rep(NA, length(mu1))
for ( i in 1:length(mu1) )
  ARL2[i] &lt;- pois.ewma.arl(lambda, A, A, mu0, mu0, mu1[i], mcdesign="transfer")
print(cbind(mu1, round(ARL2, digits=1)))

## Morais and Knoth (2020), Table 2, lambda = 0.27 column
lambda &lt;- 0.27
AL &lt;- 3.0870
AU &lt;- 3.4870
gL &lt;- 0.001029
gU &lt;- 0.000765
mu0 &lt;- 20
mu1  &lt;- c(16, 18, 19.99, mu0, 20.01, 22, 24)
ARL3 &lt;- rep(NA, length(mu1))
for ( i in 1:length(mu1) )
  ARL3[i] &lt;- pois.ewma.arl(lambda,AL,AU,mu0,mu0,mu1[i],rando=TRUE,gL=gL,gU=gU, N=101)
print(cbind(mu1, round(ARL3, digits=1)))
</code></pre>

<hr>
<h2 id='pois.ewma.crit'>Compute ARLs of Poisson EWMA control charts</h2><span id='topic+pois.ewma.crit'></span>

<h3>Description</h3>

<p>Computation of the (zero-state) Average Run Length (ARL) at given mean <code>mu</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>pois.ewma.crit(lambda, L0, mu0, z0, AU=3, sided="two", design="sym", rando=FALSE,
mcdesign="transfer", N=101, jmax=4)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pois.ewma.crit_+3A_lambda">lambda</code></td>
<td>
<p>smoothing parameter of the EWMA p control chart.</p>
</td></tr>
<tr><td><code id="pois.ewma.crit_+3A_l0">L0</code></td>
<td>
<p>value of the so-called in-control Average Run Length (ARL) for the Poisson EWMA control chart.</p>
</td></tr>
<tr><td><code id="pois.ewma.crit_+3A_mu0">mu0</code></td>
<td>
<p>in-control mean.</p>
</td></tr>
<tr><td><code id="pois.ewma.crit_+3A_z0">z0</code></td>
<td>
<p>so-called headstart (give fast initial response).</p>
</td></tr>
<tr><td><code id="pois.ewma.crit_+3A_au">AU</code></td>
<td>
<p>in case of the lower chart deployed as reflecting upper barrier &ndash; might be increased step by step until the resulting lower limit
does not change anymore.</p>
</td></tr>
<tr><td><code id="pois.ewma.crit_+3A_sided">sided</code></td>
<td>
<p>distinguishes between one- and two-sided EWMA control chart by choosing <code>"upper"</code>, <code>"lower"</code>, and <code>"two"</code>, respectively.</p>
</td></tr>
<tr><td><code id="pois.ewma.crit_+3A_design">design</code></td>
<td>
<p>distinguishes between limits symmetric to the in-control mean <code>mu0</code> and an ARL-unbiased design (ARL maximum at <code>mu0</code>); use the shortcuts <code>"sym"</code> and <code>"unb"</code>, respectively, please.</p>
</td></tr>
<tr><td><code id="pois.ewma.crit_+3A_rando">rando</code></td>
<td>
<p>Switch between the standard limit treatment, <code>FALSE</code>,
and an additional randomisation (to allow &lsquo;perfect&rsquo; ARL calibration) by setting <code>TRUE</code>.
If randomisation is used, then the corresponding probailities, <code>gL</code> and <code>gU</code> are determined, appropriately.</p>
</td></tr>
<tr><td><code id="pois.ewma.crit_+3A_mcdesign">mcdesign</code></td>
<td>
<p>choose either <code>"classic"</code> which follows Borror, Champ and Rigdon (1998), or the more
sophisticated <code>"transfer"</code> which improves the accuracy heavily.</p>
</td></tr>
<tr><td><code id="pois.ewma.crit_+3A_n">N</code></td>
<td>
<p>number of states of the approximating Markov chain; is equal to the dimension of the resulting linear equation system.</p>
</td></tr>
<tr><td><code id="pois.ewma.crit_+3A_jmax">jmax</code></td>
<td>
<p>number of digits for the to be calculated factors <code>A</code> (sort of accuracy).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The monitored data follow a Poisson distribution with <code>mu</code>.
Here we solve the inverse task to the usual ARL calculation. Hence, determine the control limit factors
so that the in-control ARL is (roughly) equal to <code>L0</code>.
The ARL values underneath the routine are determined by Markov chain approximation.
The algorithm is just a grid search that takes care of the discrete ARL behavior.
</p>


<h3>Value</h3>

<p>Return one or two values being he control limit factors.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>C. M. Borror, C. W. Champ and S. E. Rigdon (1998)
Poisson EWMA control charts,
<em>Journal of Quality Technonlogy</em> 30(4), 352-361.
</p>
<p>M. C. Morais and S. Knoth (2020)
Improving the ARL profile and the accuracy of its calculation for Poisson EWMA charts,
<em>Quality and Reliability Engineering International</em> 36(3), 876-889.
</p>


<h3>See Also</h3>

<p>later.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Borror, Champ and Rigdon (1998), page 30, original value is A = 2.8275
mu0 &lt;- 4
lambda &lt;- 0.2
L0 &lt;- 351
A &lt;- pois.ewma.crit(lambda, L0, mu0, mu0, mcdesign="classic")
print(round(A, digits=4))

## Morais and Knoth (2020), Table 2, lambda = 0.27 column
lambda &lt;- 0.27
L0 &lt;- 1233.4
ccgg &lt;- pois.ewma.crit(lambda,1233.4,mu0,mu0,design="unb",rando=TRUE,mcdesign="transfer")
print(ccgg, digits=3)
</code></pre>

<hr>
<h2 id='quadrature.nodes.weights'>Calculate quadrature nodes and weights</h2><span id='topic+quadrature.nodes.weights'></span>

<h3>Description</h3>

<p>Computation of the nodes and weights to enable numerical quadrature.</p>


<h3>Usage</h3>

<pre><code class='language-R'>quadrature.nodes.weights(n, type="GL", x1=-1, x2=1)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quadrature.nodes.weights_+3A_n">n</code></td>
<td>
<p>number of nodes (and weights).</p>
</td></tr>
<tr><td><code id="quadrature.nodes.weights_+3A_type">type</code></td>
<td>
<p>quadrature type &ndash; currently Gauss-Legendre, <code>"GL"</code>, and Radau, <code>"Ra"</code>, are supported.</p>
</td></tr>
<tr><td><code id="quadrature.nodes.weights_+3A_x1">x1</code></td>
<td>
<p>lower limit of the integration interval.</p>
</td></tr>
<tr><td><code id="quadrature.nodes.weights_+3A_x2">x2</code></td>
<td>
<p>upper limit of the integration interval.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A more detailed description will follow soon. The algorithm for the Gauss-Legendre quadrature was delivered by
Knut Petras to me, while the one for the Radau quadrature was taken from John Burkardt.
</p>


<h3>Value</h3>

<p>Returns two vectors which hold the needed quadrature nodes and weights.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>H. Brass and K. Petras (2011),
<em>Quadrature Theory. The Theory of Numerical Integration on a Compact Interval,</em>
Mathematical Surveys and Monographs, American Mathematical Society.
</p>
<p>John Burkardt (2015),
<a href="https://people.sc.fsu.edu/~jburkardt/f_src/quadrule/quadrule.html">https://people.sc.fsu.edu/~jburkardt/f_src/quadrule/quadrule.html</a>
</p>


<h3>See Also</h3>

<p>Many of the ARL routines use the Gauss-Legendre nodes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># GL
n &lt;- 10
qnw &lt;-quadrature.nodes.weights(n, type="GL")
qnw

# Radau
n &lt;- 10
qnw &lt;-quadrature.nodes.weights(n, type="Ra")
qnw
</code></pre>

<hr>
<h2 id='scusum.arl'>Compute ARLs of CUSUM control charts (variance charts)</h2><span id='topic+scusum.arl'></span>

<h3>Description</h3>

<p>Computation of the (zero-state) Average Run Length (ARL)
for different types of CUSUM control charts (based on the sample variance
<code class="reqn">S^2</code>) monitoring normal variance.</p>


<h3>Usage</h3>

<pre><code class='language-R'>scusum.arl(k, h, sigma, df, hs=0, sided="upper", k2=NULL,
h2=NULL, hs2=0, r=40, qm=30, version=2)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scusum.arl_+3A_k">k</code></td>
<td>
<p>reference value of the CUSUM control chart.</p>
</td></tr>
<tr><td><code id="scusum.arl_+3A_h">h</code></td>
<td>
<p>decision interval (alarm limit, threshold) of the CUSUM control chart.</p>
</td></tr>
<tr><td><code id="scusum.arl_+3A_sigma">sigma</code></td>
<td>
<p>true standard deviation.</p>
</td></tr>
<tr><td><code id="scusum.arl_+3A_df">df</code></td>
<td>
<p>actual degrees of freedom, corresponds to subgroup size (for known mean it is equal to the subgroup size,
for unknown mean it is equal to subgroup size minus one.</p>
</td></tr>
<tr><td><code id="scusum.arl_+3A_hs">hs</code></td>
<td>
<p>so-called headstart (enables fast initial response).</p>
</td></tr>
<tr><td><code id="scusum.arl_+3A_sided">sided</code></td>
<td>
<p>distinguishes between one- and two-sided two-sided CUSUM-<code class="reqn">S^2</code> control charts 
by choosing <code>"upper"</code> (upper chart), <code>"lower"</code> (lower chart), and <code>"two"</code> (two-sided chart), 
respectively. Note that for the two-sided chart the parameters <code>"k2"</code> and <code>"h2"</code> have to be set too.</p>
</td></tr>
<tr><td><code id="scusum.arl_+3A_k2">k2</code></td>
<td>
<p>In case of a two-sided CUSUM chart for variance the reference value of the lower chart.</p>
</td></tr>
<tr><td><code id="scusum.arl_+3A_h2">h2</code></td>
<td>
<p>In case of a two-sided CUSUM chart for variance the decision interval of the lower chart.</p>
</td></tr>
<tr><td><code id="scusum.arl_+3A_hs2">hs2</code></td>
<td>
<p>In case of a two-sided CUSUM chart for variance the headstart of the lower chart.</p>
</td></tr>
<tr><td><code id="scusum.arl_+3A_r">r</code></td>
<td>
<p>Dimension of the resulting linear equation system (highest order of the collocation
polynomials times number of intervals &ndash; see Knoth 2006).</p>
</td></tr>
<tr><td><code id="scusum.arl_+3A_qm">qm</code></td>
<td>
<p>Number of quadrature nodes for calculating the collocation definite integrals.</p>
</td></tr>
<tr><td><code id="scusum.arl_+3A_version">version</code></td>
<td>
<p>Distinguish version numbers (1,2,...). For internal use only.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>scusum.arl</code> determines the Average Run Length (ARL) by numerically
solving the related ARL integral equation by means of collocation (piecewise Chebyshev polynomials).</p>


<h3>Value</h3>

<p>Returns a single value which resembles the ARL.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>S. Knoth (2005),
Accurate ARL computation for EWMA-<code class="reqn">S^2</code> control charts,
<em>Statistics and Computing 15</em>, 341-352.
</p>
<p>S. Knoth (2006),
Computation of the ARL for CUSUM-<code class="reqn">S^2</code> schemes,
<em>Computational Statistics &amp; Data Analysis 51</em>, 499-512.
</p>


<h3>See Also</h3>

<p><code>xcusum.arl</code> for zero-state ARL computation of CUSUM control charts for monitoring normal mean.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Knoth (2006)
## compare with Table 1 (p. 507)
k &lt;- 1.46 # sigma1 = 1.5
df &lt;- 1
h &lt;- 10

# original values
# sigma coll63       BE     Hawkins  MC 10^9 (s.e.)
# 1     260.7369  260.7546  261.32  260.7399 (0.0081)
# 1.1    90.1319   90.1389   90.31   90.1319 (0.0027)
# 1.2    43.6867   43.6897   43.75   43.6845 (0.0013)
# 1.3    26.2916   26.2932   26.32   26.2929 (0.0007)
# 1.4    18.1231   18.1239   18.14   18.1235 (0.0005)
# 1.5    13.6268   13.6273   13.64   13.6272 (0.0003)
# 2       5.9904    5.9910    5.99    5.9903 (0.0001)
# replicate the column coll63
sigma &lt;- c(1, 1.1, 1.2, 1.3, 1.4, 1.5, 2)
arl &lt;- rep(NA, length(sigma))
for ( i in 1:length(sigma) )
  arl[i] &lt;- round(scusum.arl(k, h, sigma[i], df, r=63, qm=20, version=2), digits=4)
data.frame(sigma, arl)
</code></pre>

<hr>
<h2 id='scusum.crit'>Compute decision intervals of CUSUM control charts (variance charts)</h2><span id='topic+scusum.crit'></span>

<h3>Description</h3>

<p>omputation of the decision intervals (alarm limits)
for different types of CUSUM control charts (based on the sample
variance <code class="reqn">S^2</code>) monitoring normal variance.</p>


<h3>Usage</h3>

<pre><code class='language-R'>scusum.crit(k, L0, sigma, df, hs=0, sided="upper", mode="eq.tails",
k2=NULL, hs2=0, r=40, qm=30)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scusum.crit_+3A_k">k</code></td>
<td>
<p>reference value of the CUSUM control chart.</p>
</td></tr>
<tr><td><code id="scusum.crit_+3A_l0">L0</code></td>
<td>
<p>in-control ARL.</p>
</td></tr>
<tr><td><code id="scusum.crit_+3A_sigma">sigma</code></td>
<td>
<p>true standard deviation.</p>
</td></tr>
<tr><td><code id="scusum.crit_+3A_df">df</code></td>
<td>
<p>actual degrees of freedom, corresponds to subgroup size (for known mean it is equal
to the subgroup size, for unknown mean it is equal to subgroup size minus one.</p>
</td></tr>
<tr><td><code id="scusum.crit_+3A_hs">hs</code></td>
<td>
<p>so-called headstart (enables fast initial response).</p>
</td></tr>
<tr><td><code id="scusum.crit_+3A_sided">sided</code></td>
<td>
<p>distinguishes between one- and two-sided two-sided CUSUM-<code class="reqn">S^2</code> control charts 
by choosing <code>"upper"</code> (upper chart), <code>"lower"</code> (lower chart),
and <code>"two"</code> (two-sided chart), respectively. Note that for the two-sided chart the parameters
<code>"k2"</code> and <code>"h2"</code> have to be set too.</p>
</td></tr>
<tr><td><code id="scusum.crit_+3A_mode">mode</code></td>
<td>
<p>only deployed for <code>sided</code>=<code>"two"</code> &ndash; with <code>"eq.tails"</code>
two one-sided CUSUM charts (lower and upper) with the same in-control ARL are coupled.
With <code>"unbiased"</code> a certain unbiasedness of the ARL function is guaranteed (here, both the
lower and the upper control limit are calculated).</p>
</td></tr>
<tr><td><code id="scusum.crit_+3A_k2">k2</code></td>
<td>
<p>in case of a two-sided CUSUM chart for variance the reference value of the lower chart.</p>
</td></tr>
<tr><td><code id="scusum.crit_+3A_hs2">hs2</code></td>
<td>
<p>in case of a two-sided CUSUM chart for variance the headstart of the lower chart.</p>
</td></tr>
<tr><td><code id="scusum.crit_+3A_r">r</code></td>
<td>
<p>Dimension of the resulting linear equation system (highest order of the collocation
polynomials times number of intervals &ndash; see Knoth 2006).</p>
</td></tr>
<tr><td><code id="scusum.crit_+3A_qm">qm</code></td>
<td>
<p>Number of quadrature nodes for calculating the collocation definite integrals.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>scusum.crit</code> ddetermines the decision interval (alarm limit)
for given in-control ARL <code>L0</code> by applying secant rule and using <code>scusum.arl()</code>.</p>


<h3>Value</h3>

<p>Returns a single value which resembles the decision interval <code>h</code>.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>S. Knoth (2005),
Accurate ARL computation for EWMA-<code class="reqn">S^2</code> control charts,
<em>Statistics and Computing 15</em>, 341-352.
</p>
<p>S. Knoth (2006),
Computation of the ARL for CUSUM-<code class="reqn">S^2</code> schemes,
<em>Computational Statistics &amp; Data Analysis 51</em>, 499-512.
</p>


<h3>See Also</h3>

<p><code>xcusum.arl</code> for zero-state ARL computation of CUSUM control charts monitoring normal mean.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Knoth (2006)
## compare with Table 1 (p. 507)
k &lt;- 1.46 # sigma1 = 1.5
df &lt;- 1
L0 &lt;- 260.74
h &lt;- scusum.crit(k, L0, 1, df)
h
# original value is 10
</code></pre>

<hr>
<h2 id='scusums.arl'>Compute ARLs of CUSUM-Shewhart control charts (variance charts)</h2><span id='topic+scusums.arl'></span>

<h3>Description</h3>

<p>Computation of the (zero-state) Average Run Length (ARL)
for different types of CUSUM-Shewhart combo control charts (based on the sample variance
<code class="reqn">S^2</code>) monitoring normal variance.</p>


<h3>Usage</h3>

<pre><code class='language-R'>scusums.arl(k, h, cS, sigma, df, hs=0, sided="upper", k2=NULL,
h2=NULL, hs2=0, r=40, qm=30, version=2)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scusums.arl_+3A_k">k</code></td>
<td>
<p>reference value of the CUSUM control chart.</p>
</td></tr>
<tr><td><code id="scusums.arl_+3A_h">h</code></td>
<td>
<p>decision interval (alarm limit, threshold) of the CUSUM control chart.</p>
</td></tr>
<tr><td><code id="scusums.arl_+3A_cs">cS</code></td>
<td>
<p>Shewhart limit.</p>
</td></tr>
<tr><td><code id="scusums.arl_+3A_sigma">sigma</code></td>
<td>
<p>true standard deviation.</p>
</td></tr>
<tr><td><code id="scusums.arl_+3A_df">df</code></td>
<td>
<p>actual degrees of freedom, corresponds to subgroup size (for known mean it is equal to the subgroup size,
for unknown mean it is equal to subgroup size minus one.</p>
</td></tr>
<tr><td><code id="scusums.arl_+3A_hs">hs</code></td>
<td>
<p>so-called headstart (enables fast initial response).</p>
</td></tr>
<tr><td><code id="scusums.arl_+3A_sided">sided</code></td>
<td>
<p>distinguishes between one- and two-sided two-sided CUSUM-<code class="reqn">S^2</code> control charts 
by choosing <code>"upper"</code> (upper chart), <code>"lower"</code> (lower chart), and <code>"two"</code> (two-sided chart), 
respectively. Note that for the two-sided chart the parameters <code>"k2"</code> and <code>"h2"</code> have to be set too.</p>
</td></tr>
<tr><td><code id="scusums.arl_+3A_k2">k2</code></td>
<td>
<p>In case of a two-sided CUSUM chart for variance the reference value of the lower chart.</p>
</td></tr>
<tr><td><code id="scusums.arl_+3A_h2">h2</code></td>
<td>
<p>In case of a two-sided CUSUM chart for variance the decision interval of the lower chart.</p>
</td></tr>
<tr><td><code id="scusums.arl_+3A_hs2">hs2</code></td>
<td>
<p>In case of a two-sided CUSUM chart for variance the headstart of the lower chart.</p>
</td></tr>
<tr><td><code id="scusums.arl_+3A_r">r</code></td>
<td>
<p>Dimension of the resulting linear equation system (highest order of the collocation
polynomials times number of intervals &ndash; see Knoth 2006).</p>
</td></tr>
<tr><td><code id="scusums.arl_+3A_qm">qm</code></td>
<td>
<p>Number of quadrature nodes for calculating the collocation definite integrals.</p>
</td></tr>
<tr><td><code id="scusums.arl_+3A_version">version</code></td>
<td>
<p>Distinguish version numbers (1,2,...). For internal use only.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>scusums.arl</code> determines the Average Run Length (ARL) by numerically
solving the related ARL integral equation by means of collocation (piecewise Chebyshev polynomials).</p>


<h3>Value</h3>

<p>Returns a single value which resembles the ARL.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>S. Knoth (2006),
Computation of the ARL for CUSUM-<code class="reqn">S^2</code> schemes,
<em>Computational Statistics &amp; Data Analysis 51</em>, 499-512.
</p>


<h3>See Also</h3>

<p><code>scusum.arl</code> for zero-state ARL computation of standalone CUSUM control charts for monitoring normal variance.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## will follow
</code></pre>

<hr>
<h2 id='sewma.arl'>Compute ARLs of EWMA control charts (variance charts)</h2><span id='topic+sewma.arl'></span>

<h3>Description</h3>

<p>Computation of the (zero-state) Average Run Length (ARL)
for different types of EWMA control charts (based on the sample variance
<code class="reqn">S^2</code>) monitoring normal variance.</p>


<h3>Usage</h3>

<pre><code class='language-R'>sewma.arl(l,cl,cu,sigma,df,s2.on=TRUE,hs=NULL,sided="upper",r=40,qm=30)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sewma.arl_+3A_l">l</code></td>
<td>
<p>smoothing parameter lambda of the EWMA control chart.</p>
</td></tr>
<tr><td><code id="sewma.arl_+3A_cl">cl</code></td>
<td>
<p>lower control limit of the EWMA control chart.</p>
</td></tr>
<tr><td><code id="sewma.arl_+3A_cu">cu</code></td>
<td>
<p>upper control limit of the EWMA control chart.</p>
</td></tr>
<tr><td><code id="sewma.arl_+3A_sigma">sigma</code></td>
<td>
<p>true standard deviation.</p>
</td></tr>
<tr><td><code id="sewma.arl_+3A_df">df</code></td>
<td>
<p>actual degrees of freedom, corresponds to subgroup
size (for known mean it is equal to the subgroup size,
for unknown mean it is equal to subgroup size minus one.</p>
</td></tr>
<tr><td><code id="sewma.arl_+3A_s2.on">s2.on</code></td>
<td>
<p>distinguishes between <code class="reqn">S^2</code> and <code class="reqn">S</code> chart.</p>
</td></tr>
<tr><td><code id="sewma.arl_+3A_hs">hs</code></td>
<td>
<p>so-called headstart (enables fast initial response);
the default (<code>NULL</code>) yields the expected in-control value of
<code class="reqn">S^2</code> (1) and <code class="reqn">S</code> (<code class="reqn">c_4</code>), respectively.</p>
</td></tr>
<tr><td><code id="sewma.arl_+3A_sided">sided</code></td>
<td>
<p>distinguishes between one- and two-sided 
two-sided EWMA-<code class="reqn">S^2</code> control charts 
by choosing <code>"upper"</code> (upper chart
without reflection at <code>cl</code> &ndash; the actual value of
<code>cl</code> is not used),
<code>"Rupper"</code> (upper chart with reflection at <code>cl</code>),
<code>"Rlower"</code> (lower chart with reflection at <code>cu</code>),
and <code>"two"</code> (two-sided chart), 
respectively.</p>
</td></tr> 
<tr><td><code id="sewma.arl_+3A_r">r</code></td>
<td>
<p>dimension of the resulting linear equation system (highest order of
the collocation polynomials).</p>
</td></tr>
<tr><td><code id="sewma.arl_+3A_qm">qm</code></td>
<td>
<p>number of quadrature nodes for calculating the collocation
definite integrals.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sewma.arl</code> determines the Average Run Length (ARL) by numerically
solving the related ARL integral equation by means of 
collocation (Chebyshev polynomials).</p>


<h3>Value</h3>

<p>Returns a single value which resembles the ARL.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>S. Knoth (2005),
Accurate ARL computation for EWMA-<code class="reqn">S^2</code> control charts,
<em>Statistics and Computing 15</em>, 341-352.
</p>
<p>S. Knoth (2006),
Computation of the ARL for CUSUM-<code class="reqn">S^2</code> schemes,
<em>Computational Statistics &amp; Data Analysis 51</em>, 499-512.
</p>


<h3>See Also</h3>

<p><code>xewma.arl</code> for zero-state ARL computation of EWMA control charts
for monitoring normal mean.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Knoth (2005)
## compare with Table 1 (p. 347): 249.9997
## Monte Carlo with 10^9 replicates: 249.9892 +/- 0.008
l &lt;- .025
df &lt;- 1
cu &lt;- 1 + 1.661865*sqrt(l/(2-l))*sqrt(2/df)
sewma.arl(l,0,cu,1,df)

## ARL values for upper and lower EWMA charts with reflecting barriers
## (reflection at in-control level sigma0 = 1)
## examples from Knoth (2006), Tables 4 and 5

Ssewma.arl &lt;- Vectorize("sewma.arl", "sigma")

## upper chart with reflection at sigma0=1 in Table 4
## original entries are
# sigma   ARL
# 1       100.0
# 1.01    85.3
# 1.02    73.4
# 1.03    63.5
# 1.04    55.4
# 1.05    48.7
# 1.1     27.9
# 1.2     12.9
# 1.3     7.86
# 1.4     5.57
# 1.5     4.30
# 2       2.11

## Not run: 
l &lt;- 0.15
df &lt;- 4
cu &lt;- 1 + 2.4831*sqrt(l/(2-l))*sqrt(2/df)
sigmas &lt;- c(1 + (0:5)/100, 1 + (1:5)/10, 2)
arls &lt;- round(Ssewma.arl(l, 1, cu, sigmas, df, sided="Rupper", r=100), digits=2)
data.frame(sigmas, arls)
## End(Not run)

## lower chart with reflection at sigma0=1 in Table 5
## original entries are
# sigma   ARL
# 1       200.04
# 0.9     38.47
# 0.8     14.63
# 0.7     8.65
# 0.6     6.31

## Not run: 
l &lt;- 0.115
df &lt;- 5
cl &lt;- 1 - 2.0613*sqrt(l/(2-l))*sqrt(2/df)
sigmas &lt;- c((10:6)/10)
arls &lt;- round(Ssewma.arl(l, cl, 1, sigmas, df, sided="Rlower", r=100), digits=2)
data.frame(sigmas, arls)
## End(Not run)
</code></pre>

<hr>
<h2 id='sewma.arl.prerun'>Compute ARLs of EWMA control charts (variance charts) in case of estimated parameters</h2><span id='topic+sewma.arl.prerun'></span>

<h3>Description</h3>

<p>Computation of the (zero-state) Average Run Length (ARL)
for EWMA control charts  (based on the sample variance <code class="reqn">S^2</code>)
monitoring normal variance with estimated parameters.</p>


<h3>Usage</h3>

<pre><code class='language-R'>sewma.arl.prerun(l, cl, cu, sigma, df1, df2, hs=1, sided="upper",
r=40, qm=30, qm.sigma=30, truncate=1e-10)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sewma.arl.prerun_+3A_l">l</code></td>
<td>
<p>smoothing parameter lambda of the EWMA control chart.</p>
</td></tr>
<tr><td><code id="sewma.arl.prerun_+3A_cl">cl</code></td>
<td>
<p>lower control limit of the EWMA control chart.</p>
</td></tr>
<tr><td><code id="sewma.arl.prerun_+3A_cu">cu</code></td>
<td>
<p>upper control limit of the EWMA control chart.</p>
</td></tr>
<tr><td><code id="sewma.arl.prerun_+3A_sigma">sigma</code></td>
<td>
<p>true standard deviation.</p>
</td></tr>
<tr><td><code id="sewma.arl.prerun_+3A_df1">df1</code></td>
<td>
<p>actual degrees of freedom, corresponds to subgroup size (for known mean it is equal to the subgroup size,
for unknown mean it is equal to subgroup size minus one.</p>
</td></tr>
<tr><td><code id="sewma.arl.prerun_+3A_df2">df2</code></td>
<td>
<p>degrees of freedom of the pre-run variance estimator.</p>
</td></tr>
<tr><td><code id="sewma.arl.prerun_+3A_hs">hs</code></td>
<td>
<p>so-called headstart (enables fast initial response).</p>
</td></tr>
<tr><td><code id="sewma.arl.prerun_+3A_sided">sided</code></td>
<td>
<p>distinguishes between one- and two-sided two-sided EWMA-<code class="reqn">S^2</code> control charts 
by choosing <code>"upper"</code> (upper chart without reflection at <code>cl</code> &ndash; the actual value of
<code>cl</code> is not used), <code>"Rupper"</code> (upper chart with reflection at <code>cl</code>),<code>"Rlower"</code>
(lower chart with reflection at <code>cu</code>),
and <code>"two"</code> (two-sided chart), respectively.</p>
</td></tr>
<tr><td><code id="sewma.arl.prerun_+3A_r">r</code></td>
<td>
<p>dimension of the resulting linear equation system (highest order of the collocation polynomials).</p>
</td></tr>
<tr><td><code id="sewma.arl.prerun_+3A_qm">qm</code></td>
<td>
<p>number of quadrature nodes for calculating the collocation definite integrals.</p>
</td></tr>
<tr><td><code id="sewma.arl.prerun_+3A_qm.sigma">qm.sigma</code></td>
<td>
<p>number of quadrature nodes for convoluting the standard deviation uncertainty.</p>
</td></tr>
<tr><td><code id="sewma.arl.prerun_+3A_truncate">truncate</code></td>
<td>
<p>size of truncated tail.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Essentially, the ARL function <code>sewma.arl</code> is convoluted with the
distribution of the sample standard deviation.
For details see Jones/Champ/Rigdon (2001) and Knoth (2014?).</p>


<h3>Value</h3>

<p>Returns a single value which resembles the ARL.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>L. A. Jones, C. W. Champ, S. E. Rigdon (2001),
The performance of exponentially weighted moving average charts with estimated parameters,
<em>Technometrics 43</em>, 156-167.
</p>
<p>S. Knoth (2005),
Accurate ARL computation for EWMA-<code class="reqn">S^2</code> control charts,
<em>Statistics and Computing 15</em>, 341-352.
</p>
<p>S. Knoth (2006),
Computation of the ARL for CUSUM-<code class="reqn">S^2</code> schemes,
<em>Computational Statistics &amp; Data Analysis 51</em>, 499-512.
</p>


<h3>See Also</h3>

<p><code>sewma.arl</code> for zero-state ARL function of EWMA control charts w/o pre run uncertainty.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## will follow
</code></pre>

<hr>
<h2 id='sewma.crit'>Compute critical values of EWMA control charts (variance charts)</h2><span id='topic+sewma.crit'></span>

<h3>Description</h3>

<p>Computation of the critical values (similar to alarm limits)
for different types of EWMA control charts (based on the sample variance
<code class="reqn">S^2</code>) monitoring normal variance.</p>


<h3>Usage</h3>

<pre><code class='language-R'>sewma.crit(l,L0,df,sigma0=1,cl=NULL,cu=NULL,hs=NULL,s2.on=TRUE,
sided="upper",mode="fixed",ur=4,r=40,qm=30)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sewma.crit_+3A_l">l</code></td>
<td>
<p>smoothing parameter lambda of the EWMA control chart.</p>
</td></tr>
<tr><td><code id="sewma.crit_+3A_l0">L0</code></td>
<td>
<p>in-control ARL.</p>
</td></tr>
<tr><td><code id="sewma.crit_+3A_df">df</code></td>
<td>
<p>actual degrees of freedom, corresponds to subgroup size (for known mean it is equal to the subgroup size,
for unknown mean it is equal to subgroup size minus one.</p>
</td></tr>
<tr><td><code id="sewma.crit_+3A_sigma0">sigma0</code></td>
<td>
<p>in-control standard deviation.</p>
</td></tr>
<tr><td><code id="sewma.crit_+3A_cl">cl</code></td>
<td>
<p>deployed for <code>sided</code>=<code>"Rupper"</code>, that is, upper variance control chart
with lower reflecting barrier <code>cl</code>.</p>
</td></tr>
<tr><td><code id="sewma.crit_+3A_cu">cu</code></td>
<td>
<p>for two-sided (<code>sided</code>=<code>"two"</code>) and fixed upper
control limit (<code>mode</code>=<code>"fixed"</code>) a value larger than <code>sigma0</code>
has to been given, for all other cases <code>cu</code> is ignored.</p>
</td></tr>
<tr><td><code id="sewma.crit_+3A_hs">hs</code></td>
<td>
<p>so-called headstart (enables fast initial response); the default (<code>NULL</code>)
yields the expected in-control value of <code class="reqn">S^2</code> (1) and <code class="reqn">S</code> (<code class="reqn">c_4</code>),
respectively.</p>
</td></tr>
<tr><td><code id="sewma.crit_+3A_s2.on">s2.on</code></td>
<td>
<p>distinguishes between <code class="reqn">S^2</code> and <code class="reqn">S</code> chart.</p>
</td></tr>
<tr><td><code id="sewma.crit_+3A_sided">sided</code></td>
<td>
<p>distinguishes between one- and two-sided
two-sided EWMA-<code class="reqn">S^2</code> control charts
by choosing <code>"upper"</code> (upper chart
without reflection at <code>cl</code> &ndash; the actual value of
<code>cl</code> is not used),
<code>"Rupper"</code> (upper chart with reflection at <code>cl</code>),
<code>"Rlower"</code> (lower chart with reflection at <code>cu</code>),
and <code>"two"</code> (two-sided chart),
respectively.</p>
</td></tr>
<tr><td><code id="sewma.crit_+3A_mode">mode</code></td>
<td>
<p>only deployed for <code>sided</code>=<code>"two"</code> &ndash; with <code>"fixed"</code>
an upper control limit (see <code>cu</code>) is set and only the lower is
calculated to obtain the in-control ARL <code>L0</code>, while with <code>"unbiased"</code>
a certain unbiasedness of the ARL function is guaranteed (here, both the
lower and the upper control limit are calculated). With <code>"vanilla"</code> limits symmetric
around 1 (the in-control value of the variance)
are determined, while for <code>"eq.tails"</code> the in-control ARL values of two single EWMA
variance charts (decompose the two-sided
scheme into one lower and one upper scheme) are matched.</p>
</td></tr>
<tr><td><code id="sewma.crit_+3A_ur">ur</code></td>
<td>
<p>truncation of lower chart for <code>eq.tails</code> mode.</p>
</td></tr>
<tr><td><code id="sewma.crit_+3A_r">r</code></td>
<td>
<p>dimension of the resulting linear equation system
(highest order of the collocation polynomials).</p>
</td></tr>
<tr><td><code id="sewma.crit_+3A_qm">qm</code></td>
<td>
<p>number of quadrature nodes for calculating the collocation definite integrals.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sewma.crit</code> determines the critical values (similar to alarm limits)
for given in-control ARL <code>L0</code>
by applying secant rule and using <code>sewma.arl()</code>.
In case of <code>sided</code>=<code>"two"</code> and <code>mode</code>=<code>"unbiased"</code>
a two-dimensional secant rule is applied that also ensures that the
maximum of the ARL function for given standard deviation is attained
at <code>sigma0</code>. See Knoth (2010) and the related example.
</p>


<h3>Value</h3>

<p>Returns the lower and upper control limit <code>cl</code> and <code>cu</code>.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>H.-J. Mittag and D. Stemann and B. Tewes (1998),
EWMA-Karten zur \&quot;Uberwachung der Streuung von Qualit\&quot;atsmerkmalen,
<em>Allgemeines Statistisches Archiv 82</em>, 327-338,
</p>
<p>C. A. Acosta-Mej\'ia and J. J. Pignatiello Jr. and B. V. Rao (1999),
A comparison of control charting procedures for monitoring process dispersion,
<em>IIE Transactions 31</em>, 569-579.
</p>
<p>S. Knoth (2005),
Accurate ARL computation for EWMA-<code class="reqn">S^2</code> control charts,
<em>Statistics and Computing 15</em>, 341-352.
</p>
<p>S. Knoth (2006a),
Computation of the ARL for CUSUM-<code class="reqn">S^2</code> schemes,
<em>Computational Statistics &amp; Data Analysis 51</em>, 499-512.
</p>
<p>S. Knoth (2006b), 
The art of evaluating monitoring schemes &ndash; how to measure the performance of control charts?
in <em>Frontiers in Statistical Quality Control 8</em>,
H.-J. Lenz and P.-T. Wilrich (Eds.),
Physica Verlag, Heidelberg, Germany, 74-99.
</p>
<p>S. Knoth (2010),
Control Charting Normal Variance &ndash; Reflections, Curiosities, and Recommendations,
in <em>Frontiers in Statistical Quality Control 9</em>,
H.-J. Lenz and P.-T. Wilrich (Eds.),
Physica Verlag, Heidelberg, Germany, 3-18.
</p>


<h3>See Also</h3>

<p><code>sewma.arl</code> for calculation of ARL of variance charts.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Mittag et al. (1998)
## compare their upper critical value 2.91 that
## leads to the upper control limit via the formula shown below
## (for the usual upper EWMA \eqn{S^2}{S^2}).
## See Knoth (2006b) for a discussion of this EWMA setup and it's evaluation.

l  &lt;- 0.18
L0 &lt;- 250
df &lt;- 4
limits &lt;- sewma.crit(l, L0, df)
limits["cu"]

limits.cu.mittag_et_al &lt;- 1 + sqrt(l/(2-l))*sqrt(2/df)*2.91
limits.cu.mittag_et_al

## Knoth (2005)
## reproduce the critical value given in Figure 2 (c=1.661865) for
## upper EWMA \eqn{S^2}{S^2} with df=1

l  &lt;- 0.025
L0 &lt;- 250
df &lt;- 1
limits &lt;- sewma.crit(l, L0, df)
cv.Fig2 &lt;- (limits["cu"]-1)/( sqrt(l/(2-l))*sqrt(2/df) )
cv.Fig2

## the small difference (sixth digit after decimal point) stems from
## tighter criterion in the secant rule implemented in the R package.

## demo of unbiased ARL curves
## Deploy, please, not matrix dimensions smaller than 50 -- for the
## sake of accuracy, the value 80 was used.
## Additionally, this example needs between 1 and 2 minutes on a 1.6 Ghz box. 

## Not run: 
l  &lt;- 0.1
L0 &lt;- 500
df &lt;- 4
limits &lt;- sewma.crit(l, L0, df, sided="two", mode="unbiased", r=80)
SEWMA.arl &lt;- Vectorize(sewma.arl, "sigma")
SEWMA.ARL &lt;- function(sigma) 
  SEWMA.arl(l, limits[1], limits[2], sigma, df, sided="two", r=80)
layout(matrix(1:2, nrow=1))
curve(SEWMA.ARL, .75, 1.25, log="y")
curve(SEWMA.ARL, .95, 1.05, log="y")
## End(Not run)
# the above stuff needs about 1 minute

## control limits for upper and lower EWMA charts with reflecting barriers
## (reflection at in-control level sigma0 = 1)
## examples from Knoth (2006a), Tables 4 and 5

## Not run: 
## upper chart with reflection at sigma0=1 in Table 4: c = 2.4831
l &lt;- 0.15
L0 &lt;- 100
df &lt;- 4
limits &lt;- sewma.crit(l, L0, df, cl=1, sided="Rupper", r=100)
cv.Tab4 &lt;- (limits["cu"]-1)/( sqrt(l/(2-l))*sqrt(2/df) )
cv.Tab4

## lower chart with reflection at sigma0=1 in Table 5: c = 2.0613
l &lt;- 0.115
L0 &lt;- 200
df &lt;- 5
limits &lt;- sewma.crit(l, L0, df, cu=1, sided="Rlower", r=100)
cv.Tab5 &lt;- -(limits["cl"]-1)/( sqrt(l/(2-l))*sqrt(2/df) )
cv.Tab5
## End(Not run)
</code></pre>

<hr>
<h2 id='sewma.crit.prerun'>Compute critical values of of EWMA (variance charts) control charts under pre-run uncertainty</h2><span id='topic+sewma.crit.prerun'></span>

<h3>Description</h3>

<p>Computation of quantiles of the Run Length (RL) for EWMA control
charts monitoring normal variance.</p>


<h3>Usage</h3>

<pre><code class='language-R'>sewma.crit.prerun(l,L0,df1,df2,sigma0=1,cl=NULL,cu=NULL,hs=1,sided="upper",
mode="fixed",r=40,qm=30,qm.sigma=30,truncate=1e-10,
tail_approx=TRUE,c.error=1e-10,a.error=1e-9)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sewma.crit.prerun_+3A_l">l</code></td>
<td>
<p>smoothing parameter lambda of the EWMA control chart.</p>
</td></tr>
<tr><td><code id="sewma.crit.prerun_+3A_l0">L0</code></td>
<td>
<p>in-control quantile value.</p>
</td></tr>
<tr><td><code id="sewma.crit.prerun_+3A_df1">df1</code></td>
<td>
<p>actual degrees of freedom, corresponds to subgroup size
(for known mean it is equal to the subgroup size,
for unknown mean it is equal to subgroup size minus one.</p>
</td></tr>
<tr><td><code id="sewma.crit.prerun_+3A_df2">df2</code></td>
<td>
<p>degrees of freedom of the pre-run variance estimator.</p>
</td></tr>
<tr><td><code id="sewma.crit.prerun_+3A_sigma">sigma</code>, <code id="sewma.crit.prerun_+3A_sigma0">sigma0</code></td>
<td>
<p>true and in-control standard deviation, respectively.</p>
</td></tr>
<tr><td><code id="sewma.crit.prerun_+3A_cl">cl</code></td>
<td>
<p>deployed for <code>sided</code>=<code>"Rupper"</code>, that is, upper variance control chart with lower
reflecting barrier <code>cl</code>.</p>
</td></tr>
<tr><td><code id="sewma.crit.prerun_+3A_cu">cu</code></td>
<td>
<p>for two-sided (<code>sided</code>=<code>"two"</code>) and fixed upper control limit
(<code>mode</code>=<code>"fixed"</code>) a value larger than <code>sigma0</code>
has to been given, for all other cases <code>cu</code> is ignored.</p>
</td></tr>
<tr><td><code id="sewma.crit.prerun_+3A_hs">hs</code></td>
<td>
<p>so-called headstart (enables fast initial response).</p>
</td></tr>
<tr><td><code id="sewma.crit.prerun_+3A_sided">sided</code></td>
<td>
<p>distinguishes between one- and two-sided two-sided EWMA-<code class="reqn">S^2</code> control charts
by choosing <code>"upper"</code> (upper chart without reflection at <code>cl</code> &ndash; the actual value of <code>cl</code>
is not used), <code>"Rupper"</code> (upper chart with reflection at <code>cl</code>), <code>"Rlower"</code> (lower chart
with reflection at <code>cu</code>),and <code>"two"</code> (two-sided chart), respectively.</p>
</td></tr>
<tr><td><code id="sewma.crit.prerun_+3A_mode">mode</code></td>
<td>
<p>only deployed for <code>sided</code>=<code>"two"</code> &ndash; with <code>"fixed"</code> an upper control limit
(see <code>cu</code>) is set and only the lower is calculated to obtain the in-control ARL <code>L0</code>, while
with <code>"unbiased"</code> a certain unbiasedness of the ARL function is guaranteed (here, both the
lower and the upper control limit are calculated).</p>
</td></tr>
<tr><td><code id="sewma.crit.prerun_+3A_r">r</code></td>
<td>
<p>dimension of the resulting linear equation system (highest order
of the collocation polynomials).</p>
</td></tr>
<tr><td><code id="sewma.crit.prerun_+3A_qm">qm</code></td>
<td>
<p>number of quadrature nodes for calculating the collocation definite integrals.</p>
</td></tr>
<tr><td><code id="sewma.crit.prerun_+3A_qm.sigma">qm.sigma</code></td>
<td>
<p>number of quadrature nodes for convoluting the standard deviation uncertainty.</p>
</td></tr>
<tr><td><code id="sewma.crit.prerun_+3A_truncate">truncate</code></td>
<td>
<p>size of truncated tail.</p>
</td></tr>
<tr><td><code id="sewma.crit.prerun_+3A_tail_approx">tail_approx</code></td>
<td>
<p>controls whether the geometric tail approximation is used (is faster) or not.</p>
</td></tr>
<tr><td><code id="sewma.crit.prerun_+3A_c.error">c.error</code></td>
<td>
<p>error bound for two succeeding values of the critical value
during applying the secant rule.</p>
</td></tr>
<tr><td><code id="sewma.crit.prerun_+3A_a.error">a.error</code></td>
<td>
<p>error bound for the quantile level <code>alpha</code> during applying the secant rule.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sewma.crit.prerun</code> determines the critical values (similar to alarm limits)
for given in-control ARL <code>L0</code>
by applying secant rule and using <code>sewma.arl.prerun()</code>.
In case of <code>sided</code>=<code>"two"</code> and <code>mode</code>=<code>"unbiased"</code>
a two-dimensional secant rule is applied that also ensures that the
maximum of the ARL function for given standard deviation is attained
at <code>sigma0</code>. See Knoth (2010) for some details of the algorithm involved.
</p>


<h3>Value</h3>

<p>Returns the lower and upper control limit <code>cl</code> and <code>cu</code>.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>H.-J. Mittag and D. Stemann and B. Tewes (1998),
EWMA-Karten zur \&quot;Uberwachung der Streuung von Qualit\&quot;atsmerkmalen,
<em>Allgemeines Statistisches Archiv 82</em>, 327-338,
S. Knoth (2005),
Accurate ARL computation for EWMA-<code class="reqn">S^2</code> control charts,
<em>Statistics and Computing 15</em>, 341-352.
</p>
<p>S. Knoth (2010),
Control Charting Normal Variance &ndash; Reflections, Curiosities, and Recommendations,
in <em>Frontiers in Statistical Quality Control 9</em>,
H.-J. Lenz and P.-T. Wilrich (Eds.),
Physica Verlag, Heidelberg, Germany, 3-18.
</p>


<h3>See Also</h3>

<p><code>sewma.arl.prerun</code> for calculation of ARL of variance charts under
pre-run uncertainty and <code>sewma.crit</code> for
the algorithm w/o pre-run uncertainty.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## will follow
</code></pre>

<hr>
<h2 id='sewma.q'>Compute RL quantiles of EWMA (variance charts) control charts</h2><span id='topic+sewma.q'></span><span id='topic+sewma.q.crit'></span>

<h3>Description</h3>

<p>Computation of quantiles of the Run Length (RL)
for EWMA control charts monitoring normal variance.</p>


<h3>Usage</h3>

<pre><code class='language-R'>sewma.q(l, cl, cu, sigma, df, alpha, hs=1, sided="upper", r=40, qm=30)

sewma.q.crit(l,L0,alpha,df,sigma0=1,cl=NULL,cu=NULL,hs=1,sided="upper",
mode="fixed",ur=4,r=40,qm=30,c.error=1e-12,a.error=1e-9)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sewma.q_+3A_l">l</code></td>
<td>
<p>smoothing parameter lambda of the EWMA control chart.</p>
</td></tr>
<tr><td><code id="sewma.q_+3A_cl">cl</code></td>
<td>
<p>deployed for <code>sided</code>=<code>"Rupper"</code>, that is, upper variance control
chart with lower reflecting barrier <code>cl</code>.</p>
</td></tr>
<tr><td><code id="sewma.q_+3A_cu">cu</code></td>
<td>
<p>for two-sided (<code>sided</code>=<code>"two"</code>) and fixed upper control limit
(<code>mode</code>=<code>"fixed"</code>) a value larger than <code>sigma0</code>
has to been given, for all other cases <code>cu</code> is ignored.</p>
</td></tr>
<tr><td><code id="sewma.q_+3A_sigma">sigma</code>, <code id="sewma.q_+3A_sigma0">sigma0</code></td>
<td>
<p>true and in-control standard deviation, respectively.</p>
</td></tr>
<tr><td><code id="sewma.q_+3A_df">df</code></td>
<td>
<p>actual degrees of freedom, corresponds to subgroup size (for known mean it
is equal to the subgroup size,
for unknown mean it is equal to subgroup size minus one.</p>
</td></tr>
<tr><td><code id="sewma.q_+3A_alpha">alpha</code></td>
<td>
<p>quantile level.</p>
</td></tr>
<tr><td><code id="sewma.q_+3A_hs">hs</code></td>
<td>
<p>so-called headstart (enables fast initial response).</p>
</td></tr>
<tr><td><code id="sewma.q_+3A_sided">sided</code></td>
<td>
<p>distinguishes between one- and two-sided two-sided EWMA-<code class="reqn">S^2</code>
control charts by choosing <code>"upper"</code> (upper chart
without reflection at <code>cl</code> &ndash; the actual value of <code>cl</code> is not used), <code>"Rupper"</code>
(upper chart with reflection at <code>cl</code>),
<code>"Rlower"</code> (lower chart with reflection at <code>cu</code>),and <code>"two"</code>
(two-sided chart), respectively.</p>
</td></tr>
<tr><td><code id="sewma.q_+3A_mode">mode</code></td>
<td>
<p>only deployed for <code>sided</code>=<code>"two"</code> &ndash; with <code>"fixed"</code> an upper
control limit (see <code>cu</code>) is set and only the lower is
calculated to obtain the in-control ARL <code>L0</code>, while with <code>"unbiased"</code> a
certain unbiasedness of the ARL function is guaranteed (here, both the
lower and the upper control limit are calculated).</p>
</td></tr>
<tr><td><code id="sewma.q_+3A_ur">ur</code></td>
<td>
<p>truncation of lower chart for <code>classic</code> mode.</p>
</td></tr>
<tr><td><code id="sewma.q_+3A_r">r</code></td>
<td>
<p>dimension of the resulting linear equation system (highest order of the
collocation polynomials).</p>
</td></tr>
<tr><td><code id="sewma.q_+3A_qm">qm</code></td>
<td>
<p>number of quadrature nodes for calculating the collocation definite integrals.</p>
</td></tr>
<tr><td><code id="sewma.q_+3A_l0">L0</code></td>
<td>
<p>in-control quantile value.</p>
</td></tr>
<tr><td><code id="sewma.q_+3A_c.error">c.error</code></td>
<td>
<p>error bound for two succeeding values of the critical value during
applying the secant rule.</p>
</td></tr>
<tr><td><code id="sewma.q_+3A_a.error">a.error</code></td>
<td>
<p>error bound for the quantile level <code>alpha</code>
during applying the secant rule.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Instead of the popular ARL (Average Run Length) quantiles of the EWMA
stopping time (Run Length) are determined. The algorithm is based on
Waldmann's survival function iteration procedure.
Thereby the ideas presented in Knoth (2007) are used.
<code>sewma.q.crit</code> determines the critical values (similar to alarm limits)
for given in-control RL quantile <code>L0</code> at level <code>alpha</code> by applying
secant rule and using <code>sewma.sf()</code>.
In case of <code>sided</code>=<code>"two"</code> and <code>mode</code>=<code>"unbiased"</code> a two-dimensional
secant rule is applied that also ensures that the
minimum of the cdf for given standard deviation is attained at <code>sigma0</code>.
</p>


<h3>Value</h3>

<p>Returns a single value which resembles the RL quantile of order <code>alpha</code> and
the lower and upper control limit <code>cl</code> and <code>cu</code>, respectively.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>H.-J. Mittag and D. Stemann and B. Tewes (1998),
EWMA-Karten zur \&quot;Uberwachung der Streuung von Qualit\&quot;atsmerkmalen,
<em>Allgemeines Statistisches Archiv 82</em>, 327-338,
</p>
<p>C. A. Acosta-Mej\'ia and J. J. Pignatiello Jr. and B. V. Rao (1999),
A comparison of control charting procedures for monitoring process dispersion,
<em>IIE Transactions 31</em>, 569-579.
</p>
<p>S. Knoth (2005),
Accurate ARL computation for EWMA-<code class="reqn">S^2</code> control charts,
<em>Statistics and Computing 15</em>, 341-352.
</p>
<p>S. Knoth (2007),
Accurate ARL calculation for EWMA control charts monitoring simultaneously normal mean and variance,
<em>Sequential Analysis 26</em>, 251-264.
</p>
<p>S. Knoth (2010),
Control Charting Normal Variance &ndash; Reflections, Curiosities, and Recommendations,
in <em>Frontiers in Statistical Quality Control 9</em>,
H.-J. Lenz and P.-T. Wilrich (Eds.),
Physica Verlag, Heidelberg, Germany, 3-18.
</p>
<p>K.-H. Waldmann (1986),
Bounds for the distribution of the run length of geometric moving 
average charts, <em>Appl. Statist. 35</em>, 151-158.
</p>


<h3>See Also</h3>

<p><code>sewma.arl</code> for calculation of ARL of variance charts and
<code>sewma.sf</code> for the RL survival function.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## will follow
</code></pre>

<hr>
<h2 id='sewma.q.prerun'>Compute RL quantiles of EWMA (variance charts) control charts under pre-run uncertainty</h2><span id='topic+sewma.q.prerun'></span><span id='topic+sewma.q.crit.prerun'></span>

<h3>Description</h3>

<p>Computation of quantiles of the Run Length (RL) for EWMA control charts monitoring
normal variance.</p>


<h3>Usage</h3>

<pre><code class='language-R'>sewma.q.prerun(l,cl,cu,sigma,df1,df2,alpha,hs=1,sided="upper",
r=40,qm=30,qm.sigma=30,truncate=1e-10)

sewma.q.crit.prerun(l,L0,alpha,df1,df2,sigma0=1,cl=NULL,cu=NULL,hs=1,
sided="upper",mode="fixed",r=40, qm=30,qm.sigma=30,truncate=1e-10,
tail_approx=TRUE,c.error=1e-10,a.error=1e-9)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sewma.q.prerun_+3A_l">l</code></td>
<td>
<p>smoothing parameter lambda of the EWMA control chart.</p>
</td></tr>
<tr><td><code id="sewma.q.prerun_+3A_cl">cl</code></td>
<td>
<p>deployed for <code>sided</code>=<code>"Rupper"</code>, that is, upper variance control chart
with lower reflecting barrier <code>cl</code>.</p>
</td></tr>
<tr><td><code id="sewma.q.prerun_+3A_cu">cu</code></td>
<td>
<p>for two-sided (<code>sided</code>=<code>"two"</code>) and fixed upper control limit
(<code>mode</code>=<code>"fixed"</code>) a value larger than <code>sigma0</code>
has to been given, for all other cases <code>cu</code> is ignored.</p>
</td></tr>
<tr><td><code id="sewma.q.prerun_+3A_sigma">sigma</code>, <code id="sewma.q.prerun_+3A_sigma0">sigma0</code></td>
<td>
<p>true and in-control standard deviation, respectively.</p>
</td></tr>
<tr><td><code id="sewma.q.prerun_+3A_l0">L0</code></td>
<td>
<p>in-control quantile value.</p>
</td></tr>
<tr><td><code id="sewma.q.prerun_+3A_alpha">alpha</code></td>
<td>
<p>quantile level.</p>
</td></tr>
<tr><td><code id="sewma.q.prerun_+3A_df1">df1</code></td>
<td>
<p>actual degrees of freedom, corresponds to subgroup size (for known mean it is
equal to the subgroup size, for unknown mean it is equal to subgroup size minus one.</p>
</td></tr>
<tr><td><code id="sewma.q.prerun_+3A_df2">df2</code></td>
<td>
<p>degrees of freedom of the pre-run variance estimator.</p>
</td></tr>
<tr><td><code id="sewma.q.prerun_+3A_hs">hs</code></td>
<td>
<p>so-called headstart (enables fast initial response).</p>
</td></tr>
<tr><td><code id="sewma.q.prerun_+3A_sided">sided</code></td>
<td>
<p>distinguishes between one- and two-sided two-sided EWMA-<code class="reqn">S^2</code>
control charts by choosing <code>"upper"</code> (upper chart
without reflection at <code>cl</code> &ndash; the actual value of <code>cl</code> is not used),
<code>"Rupper"</code> (upper chart with reflection at <code>cl</code>),
<code>"Rlower"</code> (lower chart with reflection at <code>cu</code>),
and <code>"two"</code> (two-sided chart), respectively.</p>
</td></tr>
<tr><td><code id="sewma.q.prerun_+3A_mode">mode</code></td>
<td>
<p>only deployed for <code>sided</code>=<code>"two"</code> &ndash; with <code>"fixed"</code>
an upper control limit (see <code>cu</code>) is set and only the lower is
calculated to obtain the in-control ARL <code>L0</code>, while with <code>"unbiased"</code> a certain unbiasedness
of the ARL function is guaranteed (here, both the
lower and the upper control limit are calculated).</p>
</td></tr>
<tr><td><code id="sewma.q.prerun_+3A_r">r</code></td>
<td>
<p>dimension of the resulting linear equation system (highest order
of the collocation polynomials).</p>
</td></tr>
<tr><td><code id="sewma.q.prerun_+3A_qm">qm</code></td>
<td>
<p>number of quadrature nodes for calculating the collocation definite integrals.</p>
</td></tr>
<tr><td><code id="sewma.q.prerun_+3A_qm.sigma">qm.sigma</code></td>
<td>
<p>number of quadrature nodes for convoluting the standard deviation uncertainty.</p>
</td></tr>
<tr><td><code id="sewma.q.prerun_+3A_truncate">truncate</code></td>
<td>
<p>size of truncated tail.</p>
</td></tr>
<tr><td><code id="sewma.q.prerun_+3A_tail_approx">tail_approx</code></td>
<td>
<p>controls whether the geometric tail approximation is used (is faster) or not.</p>
</td></tr>
<tr><td><code id="sewma.q.prerun_+3A_c.error">c.error</code></td>
<td>
<p>error bound for two succeeding values of the critical value
during applying the secant rule.</p>
</td></tr>
<tr><td><code id="sewma.q.prerun_+3A_a.error">a.error</code></td>
<td>
<p>error bound for the quantile level <code>alpha</code> during applying the secant rule.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Instead of the popular ARL (Average Run Length) quantiles of the EWMA
stopping time (Run Length) are determined. The algorithm is based on
Waldmann's survival function iteration procedure.
Thereby the ideas presented in Knoth (2007) are used.
<code>sewma.q.crit.prerun</code> determines the critical values (similar to alarm limits)
for given in-control RL quantile <code>L0</code> at level <code>alpha</code> by applying secant
rule and using <code>sewma.sf()</code>.
In case of <code>sided</code>=<code>"two"</code> and <code>mode</code>=<code>"unbiased"</code>
a two-dimensional secant rule is applied that also ensures that the
minimum of the cdf for given standard deviation is attained at <code>sigma0</code>.
</p>


<h3>Value</h3>

<p>Returns a single value which resembles the RL quantile of order <code>alpha</code> and
the lower and upper control limit <code>cl</code> and <code>cu</code>, respectively.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>S. Knoth (2007),
Accurate ARL calculation for EWMA control charts monitoring simultaneously normal mean and variance,
<em>Sequential Analysis 26</em>, 251-264.
</p>
<p>K.-H. Waldmann (1986),
Bounds for the distribution of the run length of geometric moving 
average charts, <em>Appl. Statist. 35</em>, 151-158.
</p>


<h3>See Also</h3>

<p><code>sewma.q</code>  and <code>sewma.q.crit</code> for the version w/o pre-run uncertainty.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## will follow
</code></pre>

<hr>
<h2 id='sewma.sf'>Compute the survival function of EWMA run length</h2><span id='topic+sewma.sf'></span>

<h3>Description</h3>

<p>Computation of the survival function of the Run Length (RL)
for EWMA control charts monitoring normal variance.</p>


<h3>Usage</h3>

<pre><code class='language-R'>sewma.sf(n, l, cl, cu, sigma, df, hs=1, sided="upper", r=40, qm=30)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sewma.sf_+3A_n">n</code></td>
<td>
<p>calculate sf up to value <code>n</code>.</p>
</td></tr>
<tr><td><code id="sewma.sf_+3A_l">l</code></td>
<td>
<p>smoothing parameter lambda of the EWMA control chart.</p>
</td></tr>
<tr><td><code id="sewma.sf_+3A_cl">cl</code></td>
<td>
<p>lower control limit of the EWMA control chart.</p>
</td></tr>
<tr><td><code id="sewma.sf_+3A_cu">cu</code></td>
<td>
<p>upper control limit of the EWMA control chart.</p>
</td></tr>
<tr><td><code id="sewma.sf_+3A_sigma">sigma</code></td>
<td>
<p>true standard deviation.</p>
</td></tr>
<tr><td><code id="sewma.sf_+3A_df">df</code></td>
<td>
<p>actual degrees of freedom, corresponds to subgroup size
(for known mean it is equal to the subgroup size,
for unknown mean it is equal to subgroup size minus one.</p>
</td></tr>
<tr><td><code id="sewma.sf_+3A_hs">hs</code></td>
<td>
<p>so-called headstart (enables fast initial response).</p>
</td></tr>
<tr><td><code id="sewma.sf_+3A_sided">sided</code></td>
<td>
<p>distinguishes between one- and two-sided two-sided
EWMA-<code class="reqn">S^2</code> control charts 
by choosing <code>"upper"</code> (upper chart without reflection at <code>cl</code> &ndash;
the actual value of <code>cl</code> is not used),
<code>"Rupper"</code> (upper chart with reflection at <code>cl</code>), <code>"Rlower"</code>
(lower chart with reflection at <code>cu</code>),
and <code>"two"</code> (two-sided chart), respectively.</p>
</td></tr> 
<tr><td><code id="sewma.sf_+3A_r">r</code></td>
<td>
<p>dimension of the resulting linear equation system
(highest order of the collocation polynomials).</p>
</td></tr>
<tr><td><code id="sewma.sf_+3A_qm">qm</code></td>
<td>
<p>number of quadrature nodes for calculating the
collocation definite integrals.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The survival function P(L&gt;n) and derived from it also the cdf P(L&lt;=n)
and the pmf P(L=n) illustrate
the distribution of the EWMA run length. For large n the
geometric tail could be exploited. That is,
with reasonable large n the complete distribution is characterized.
The algorithm is based on Waldmann's survival function iteration procedure and
on results in Knoth (2007).
</p>


<h3>Value</h3>

<p>Returns a vector which resembles the survival function up to a certain point.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>S. Knoth (2007),
Accurate ARL calculation for EWMA control charts monitoring simultaneously
normal mean and variance,
<em>Sequential Analysis 26</em>, 251-264.
</p>
<p>K.-H. Waldmann (1986),
Bounds for the distribution of the run length of geometric moving 
average charts, <em>Appl. Statist. 35</em>, 151-158.
</p>


<h3>See Also</h3>

<p><code>sewma.arl</code> for zero-state ARL computation of variance EWMA control charts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## will follow
</code></pre>

<hr>
<h2 id='sewma.sf.prerun'>Compute the survival function of EWMA run length</h2><span id='topic+sewma.sf.prerun'></span>

<h3>Description</h3>

<p>Computation of the survival function of the Run Length (RL)
for EWMA control charts monitoring normal variance.</p>


<h3>Usage</h3>

<pre><code class='language-R'>sewma.sf.prerun(n, l, cl, cu, sigma, df1, df2, hs=1, sided="upper",
qm=30, qm.sigma=30, truncate=1e-10, tail_approx=TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sewma.sf.prerun_+3A_n">n</code></td>
<td>
<p>calculate sf up to value <code>n</code>.</p>
</td></tr>
<tr><td><code id="sewma.sf.prerun_+3A_l">l</code></td>
<td>
<p>smoothing parameter lambda of the EWMA control chart.</p>
</td></tr>
<tr><td><code id="sewma.sf.prerun_+3A_cl">cl</code></td>
<td>
<p>lower control limit of the EWMA control chart.</p>
</td></tr>
<tr><td><code id="sewma.sf.prerun_+3A_cu">cu</code></td>
<td>
<p>upper control limit of the EWMA control chart.</p>
</td></tr>
<tr><td><code id="sewma.sf.prerun_+3A_sigma">sigma</code></td>
<td>
<p>true standard deviation.</p>
</td></tr>
<tr><td><code id="sewma.sf.prerun_+3A_df1">df1</code></td>
<td>
<p>actual degrees of freedom, corresponds to subgroup size
(for known mean it is equal to the subgroup size,
for unknown mean it is equal to subgroup size minus one.</p>
</td></tr>
<tr><td><code id="sewma.sf.prerun_+3A_df2">df2</code></td>
<td>
<p>degrees of freedom of the pre-run variance estimator.</p>
</td></tr>
<tr><td><code id="sewma.sf.prerun_+3A_hs">hs</code></td>
<td>
<p>so-called headstart (enables fast initial response).</p>
</td></tr>
<tr><td><code id="sewma.sf.prerun_+3A_sided">sided</code></td>
<td>
<p>distinguishes between one- and two-sided two-sided
EWMA-<code class="reqn">S^2</code> control charts 
by choosing <code>"upper"</code> (upper chart without reflection at <code>cl</code> &ndash;
the actual value of <code>cl</code> is not used),
<code>"Rupper"</code> (upper chart with reflection at <code>cl</code>), <code>"Rlower"</code>
(lower chart with reflection at <code>cu</code>),
and <code>"two"</code> (two-sided chart), respectively.</p>
</td></tr> 
<tr><td><code id="sewma.sf.prerun_+3A_qm">qm</code></td>
<td>
<p>number of quadrature nodes for calculating the collocation
definite integrals.</p>
</td></tr>
<tr><td><code id="sewma.sf.prerun_+3A_qm.sigma">qm.sigma</code></td>
<td>
<p>number of quadrature nodes for convoluting the
standard deviation uncertainty.</p>
</td></tr>
<tr><td><code id="sewma.sf.prerun_+3A_truncate">truncate</code></td>
<td>
<p>size of truncated tail.</p>
</td></tr>
<tr><td><code id="sewma.sf.prerun_+3A_tail_approx">tail_approx</code></td>
<td>
<p>Controls whether the geometric tail approximation
is used (is faster) or not.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The survival function P(L&gt;n) and derived from it also the cdf P(L&lt;=n) and
the pmf P(L=n) illustrate
the distribution of the EWMA run length. For large n the geometric tail
could be exploited. That is,
with reasonable large n the complete distribution is characterized.
The algorithm is based on Waldmann's survival function iteration
procedure and on results in Knoth (2007)...
</p>


<h3>Value</h3>

<p>Returns a vector which resembles the survival function up to a certain point.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>S. Knoth (2007),
Accurate ARL calculation for EWMA control charts monitoring simultaneously normal mean and variance,
<em>Sequential Analysis 26</em>, 251-264.
</p>
<p>K.-H. Waldmann (1986),
Bounds for the distribution of the run length of geometric moving 
average charts, <em>Appl. Statist. 35</em>, 151-158.
</p>


<h3>See Also</h3>

<p><code>sewma.sf</code> for the RL survival function of EWMA control charts w/o pre-run uncertainty.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## will follow
</code></pre>

<hr>
<h2 id='tewma.arl'>Compute ARLs of Poisson TEWMA control charts</h2><span id='topic+tewma.arl'></span>

<h3>Description</h3>

<p>Computation of the (zero-state) Average Run Length (ARL) at given Poisson mean <code>mu</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>tewma.arl(lambda, k, lk, uk, mu, z0, rando=FALSE, gl=0, gu=0)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tewma.arl_+3A_lambda">lambda</code></td>
<td>
<p>smoothing parameter of the EWMA p control chart.</p>
</td></tr>
<tr><td><code id="tewma.arl_+3A_k">k</code></td>
<td>
<p>resolution of grid (natural number).</p>
</td></tr>
<tr><td><code id="tewma.arl_+3A_lk">lk</code></td>
<td>
<p>lower control limit of the TEWMA control chart, integer.</p>
</td></tr>
<tr><td><code id="tewma.arl_+3A_uk">uk</code></td>
<td>
<p>upper control limit of the TEWMA control chart, integer.</p>
</td></tr>
<tr><td><code id="tewma.arl_+3A_mu">mu</code></td>
<td>
<p>mean value of Poisson distribution.</p>
</td></tr>
<tr><td><code id="tewma.arl_+3A_z0">z0</code></td>
<td>
<p>so-called headstart (give fast initial response) &ndash; it is proposed to use the in-control mean.</p>
</td></tr>
<tr><td><code id="tewma.arl_+3A_rando">rando</code></td>
<td>
<p>Distinguish between control chart design without or with randomisation. In the latter case some
meaningful values for <code>gl</code> and <code>gu</code> should be provided.</p>
</td></tr>
<tr><td><code id="tewma.arl_+3A_gl">gl</code></td>
<td>
<p>randomisation probability at the lower limit.</p>
</td></tr>
<tr><td><code id="tewma.arl_+3A_gu">gu</code></td>
<td>
<p>randomisation probability at the upper limit.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A new idea of applying EWMA smoothing to count data. Here, the thinning operation is
applied to independent Poisson variates is performed. 
Moreover, the original thinning principle is expanded to multiples of one over <code>k</code> to allow finer
grids and finally better detection perfomance. It is highly recommended to read the
corresponding paper (see below).
</p>


<h3>Value</h3>

<p>Return single value which resemble the ARL.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>M. C. Morais, C. H. Weiss, S. Knoth (2019),
A thinning-based EWMA chart to monitor counts, submitted.
</p>


<h3>See Also</h3>

<p>later.</p>


<h3>Examples</h3>

<pre><code class='language-R'># MWK (2018)
lambda &lt;- 0.1 # (T)EWMA smoothing constant
mu0 &lt;- 5 # in-control mean
k &lt;- 10 # resolution
z0 &lt;- round(k*mu0) # starting value of (T)EWMA sequence
# (i) without randomisation
lk &lt;- 28
uk &lt;- 75
L0 &lt;- tewma.arl(lambda, k, lk, uk, mu0, z0)
# should be 501.9703
# (ii) with randomisation
uk &lt;- 76 # lk is not changed
gl &lt;- 0.5446310
gu &lt;- 0.1375617
L0 &lt;- tewma.arl(lambda, k, lk, uk, mu0, z0, rando=TRUE, gl=gl, gu=gu)
# should be 500
</code></pre>

<hr>
<h2 id='tol.lim.fac'>Two-sided tolerance limit factors</h2><span id='topic+tol.lim.fac'></span>

<h3>Description</h3>

<p>For constructing tolerance intervals, which
cover a given proportion <code class="reqn">p</code> of a normal distribution with
unknown mean and variance with confidence 
<code class="reqn">1-\alpha</code>, one needs to calculate
the so-called tolerance limit factors <code class="reqn">k</code>. These values
are computed for a given sample size <code class="reqn">n</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>tol.lim.fac(n,p,a,mode="WW",m=30)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tol.lim.fac_+3A_n">n</code></td>
<td>
<p>sample size.</p>
</td></tr>
<tr><td><code id="tol.lim.fac_+3A_p">p</code></td>
<td>
<p>coverage.</p>
</td></tr>
<tr><td><code id="tol.lim.fac_+3A_a">a</code></td>
<td>
<p>error probability <code class="reqn">\alpha</code>, resulting interval covers at least proportion <code>p</code>
with confidence of at least <code class="reqn">1-\alpha</code>.</p>
</td></tr>
<tr><td><code id="tol.lim.fac_+3A_mode">mode</code></td>
<td>
<p>distinguish between Wald/Wolfowitz' approximation method (<code>"WW"</code>) and the more
accurate approach (<code>"exact"</code>)
based on Gauss-Legendre quadrature.</p>
</td></tr>
<tr><td><code id="tol.lim.fac_+3A_m">m</code></td>
<td>
<p>number of abscissas for the quadrature (needed only for <code>method="exact"</code>),
of course, the larger the more accurate.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tol.lim.fac</code> determines tolerance limits factors 
<code class="reqn">k</code>
by means of the fast and simple approximation due to
Wald/Wolfowitz (1946) and of Gauss-Legendre quadrature like Odeh/Owen
(1980), respectively, who used in fact the Simpson Rule. Then, by
<code class="reqn">\bar x \pm k \cdot s</code> 
one can build the tolerance intervals
which cover at least proportion <code class="reqn">p</code> of a normal distribution for
given confidence level of 
<code class="reqn">1-\alpha</code>. <code class="reqn">\bar x</code> and <code class="reqn">s</code> stand
for the sample mean and the sample standard deviation, respectively.</p>


<h3>Value</h3>

<p>Returns a single value which resembles the tolerance limit factor.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>A. Wald, J. Wolfowitz (1946), Tolerance limits for a normal distribution,
<em>Annals of Mathematical Statistics 17</em>, 208-215.
</p>
<p>R. E. Odeh, D. B. Owen (1980), <em>Tables for Normal Tolerance Limits</em>,
Sampling Plans, and Screening, Marcel Dekker, New York.
</p>


<h3>See Also</h3>

<p><code>qnorm</code> for the &rdquo;asymptotic&rdquo; case &ndash; cf. second example.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 2:10
p &lt;- .95
a &lt;- .05
kWW &lt;- sapply(n,p=p,a=a,tol.lim.fac)
kEX &lt;- sapply(n,p=p,a=a,mode="exact",tol.lim.fac)
print(cbind(n,kWW,kEX),digits=4)
## Odeh/Owen (1980), page 98, in Table 3.4.1
##  n  factor k
##  2  36.519
##  3   9.789
##  4   6.341
##  5   5.077
##  6   4.422
##  7   4.020
##  8   3.746
##  9   3.546
## 10   3.393

## n -&gt; infty
n &lt;- 10^{1:7}
p &lt;- .95
a &lt;- .05
kEX &lt;- round(sapply(n,p=p,a=a,mode="exact",tol.lim.fac),digits=4)
kEXinf &lt;- round(qnorm(1-a/2),digits=4)
print(rbind(cbind(n,kEX),c("infinity",kEXinf)),quote=FALSE)
</code></pre>

<hr>
<h2 id='x.res.ewma.arl'>Compute ARLs of EWMA residual control charts</h2><span id='topic+x.res.ewma.arl'></span><span id='topic+s.res.ewma.arl'></span><span id='topic+xs.res.ewma.arl'></span><span id='topic+xs.res.ewma.pms'></span>

<h3>Description</h3>

<p>Computation of the (zero-state) Average Run Length (ARL)
for  EWMA residual control charts monitoring normal mean,
variance, or mean and variance simultaneously. Additionally,
the probability of misleading signals (PMS) is calculated.</p>


<h3>Usage</h3>

<pre><code class='language-R'>x.res.ewma.arl(l, c, mu, alpha=0, n=5, hs=0, r=40)

s.res.ewma.arl(l, cu, sigma, mu=0, alpha=0, n=5, hs=1, r=40, qm=30)

xs.res.ewma.arl(lx, cx, ls, csu, mu, sigma, alpha=0,
n=5, hsx=0, rx=40, hss=1, rs=40, qm=30)

xs.res.ewma.pms(lx, cx, ls, csu, mu, sigma, type="3",
alpha=0, n=5, hsx=0, rx=40, hss=1, rs=40, qm=30)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="x.res.ewma.arl_+3A_l">l</code>, <code id="x.res.ewma.arl_+3A_lx">lx</code>, <code id="x.res.ewma.arl_+3A_ls">ls</code></td>
<td>
<p>smoothing parameter(s) lambda of the EWMA control chart.</p>
</td></tr>
<tr><td><code id="x.res.ewma.arl_+3A_c">c</code>, <code id="x.res.ewma.arl_+3A_cu">cu</code>, <code id="x.res.ewma.arl_+3A_cx">cx</code>, <code id="x.res.ewma.arl_+3A_csu">csu</code></td>
<td>
<p>critical value (similar to alarm limit) of the EWMA control charts.</p>
</td></tr>
<tr><td><code id="x.res.ewma.arl_+3A_mu">mu</code></td>
<td>
<p>true mean.</p>
</td></tr>
<tr><td><code id="x.res.ewma.arl_+3A_sigma">sigma</code></td>
<td>
<p>true standard deviation.</p>
</td></tr>
<tr><td><code id="x.res.ewma.arl_+3A_alpha">alpha</code></td>
<td>
<p>the AR(1) coefficient &ndash; first order autocorrelation of the original data.</p>
</td></tr>
<tr><td><code id="x.res.ewma.arl_+3A_n">n</code></td>
<td>
<p>batch size.</p>
</td></tr>
<tr><td><code id="x.res.ewma.arl_+3A_hs">hs</code>, <code id="x.res.ewma.arl_+3A_hsx">hsx</code>, <code id="x.res.ewma.arl_+3A_hss">hss</code></td>
<td>
<p>so-called headstart (enables fast initial response).</p>
</td></tr>
<tr><td><code id="x.res.ewma.arl_+3A_r">r</code>, <code id="x.res.ewma.arl_+3A_rx">rx</code>, <code id="x.res.ewma.arl_+3A_rs">rs</code></td>
<td>
<p>number of quadrature nodes or size of collocation base,
dimension of the resulting linear
equation system is equal to <code>r</code> (two-sided).</p>
</td></tr>
<tr><td><code id="x.res.ewma.arl_+3A_qm">qm</code></td>
<td>
<p>number of nodes for collocation quadratures.</p>
</td></tr>
<tr><td><code id="x.res.ewma.arl_+3A_type">type</code></td>
<td>
<p>PMS type, for <code>PMS</code>=&quot;3&quot; (the default) the probability of
getting a mean signal despite the variance
changed, and for <code>PMS</code>=&quot;4&quot; the opposite case is dealt with.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The above list of functions provides the application of
algorithms developed for iid data to
the residual case. To be more precise, the underlying model is a sequence of normally
distributed batches with size <code>n</code> with autocorrelation within
the batch and independence between the batches
(see also the references below). It is restricted to the
classical EWMA chart types, that
is two-sided for the mean, upper charts for the variance,
and all equipped with fixed limits.
The autocorrelation is modeled by an AR(1) process with parameter
<code>alpha</code>. Additionally,
with <code>xs.res.ewma.pms</code> the probability of misleading signals
(PMS) of <code>type</code> is
calculated. This is offered exclusively in this small
collection so that for iid data
this function has to be used too (with <code>alpha=0</code>).
</p>


<h3>Value</h3>

<p>Return single values which resemble the ARL and the PMS, respectively.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>S. Knoth, M. C. Morais, A. Pacheco, W. Schmid (2009),
Misleading Signals in Simultaneous Residual Schemes for the Mean and
Variance of a Stationary Process,
<em>Commun. Stat., Theory Methods 38</em>, 2923-2943.
</p>
<p>S. Knoth, W. Schmid, A. Schoene (2001),
Simultaneous Shewhart-Type Charts for the Mean and the Variance of a Time Series,
<em>Frontiers of Statistical Quality Control 6,
A. Lenz, H.-J. &amp; Wilrich, P.-T. (Eds.)</em>, 6, 61-79.
</p>
<p>S. Knoth, W. Schmid (2002)
Monitoring the mean and the variance of a stationary process,
<em>Statistica Neerlandica 56</em>, 77-100.
</p>


<h3>See Also</h3>

<p><code>xewma.arl</code>, <code>sewma.arl</code>, and <code>xsewma.arl</code> as more
elaborated functions in the iid case.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## S. Knoth, W. Schmid (2002)

cat("\nFragments of Table 2 (n=5, lambda.1=lambda.2)\n")

lambdas &lt;- c(.5, .25, .1, .05)
L0 &lt;- 500
n &lt;- 5

crit &lt;- NULL
for ( lambda in lambdas ) {
  cs &lt;- xsewma.crit(lambda, lambda, L0, n-1) 
  x.e &lt;- round(cs[1], digits=4)
  names(x.e) &lt;- NULL
  s.e &lt;- round((cs[3]-1) * sqrt((2-lambda)/lambda)*sqrt((n-1)/2), digits=4)
  names(s.e) &lt;- NULL
  crit &lt;- rbind(crit, data.frame(lambda, x.e, s.e))
}


## orinal values are (Markov chain approximation with 50 states)
# lambda x.e    s.e
#   0.50 3.2765 4.6439
#   0.25 3.2168 4.0149
#   0.10 3.0578 3.3376
#   0.05 2.8817 2.9103

print(crit)


cat("\nFragments of Table 4 (n=5, lambda.1=lambda.2=0.1)\n\n")

lambda &lt;- .1
# the algorithm used in Knoth/Schmid is less accurate -- proceed with their values
cx &lt;- x.e &lt;- 3.0578
s.e &lt;- 3.3376
csu &lt;- 1 + s.e * sqrt(lambda/(2-lambda))*sqrt(2/(n-1))

alpha &lt;- .3

a.values &lt;- c((0:6)/4, 2)
d.values &lt;- c(1 + (0:5)/10, 1.75 , 2)

arls &lt;- NULL
for ( delta in d.values ) {
  row &lt;- NULL
  for ( mu in a.values ) {
    arl &lt;- round(xs.res.ewma.arl(lambda, cx, lambda, csu, mu*sqrt(n), delta, alpha=alpha, n=n),
                 digits=2)
    names(arl) &lt;- NULL
    row &lt;- c(row, arl)   
  }
  arls &lt;- rbind(arls, data.frame(t(row)))
}
names(arls) &lt;- a.values
rownames(arls) &lt;- d.values

## orinal values are (now Monte-Carlo with 10^6 replicates)
#          0  0.25   0.5 0.75    1 1.25  1.5    2
#1    502.44 49.50 14.21 7.93 5.53 4.28 3.53 2.65
#1.1   73.19 32.91 13.33 7.82 5.52 4.29 3.54 2.66
#1.2   24.42 18.88 11.37 7.44 5.42 4.27 3.54 2.67
#1.3   13.11 11.83  9.09 6.74 5.18 4.17 3.50 2.66
#1.4    8.74  8.31  7.19 5.89 4.81 4.00 3.41 2.64
#1.5    6.50  6.31  5.80 5.08 4.37 3.76 3.28 2.59
#1.75   3.94  3.90  3.78 3.59 3.35 3.09 2.83 2.40
#2      2.85  2.84  2.80 2.73 2.63 2.51 2.39 2.14

print(arls)


## S. Knoth, M. C. Morais, A. Pacheco, W. Schmid (2009)

cat("\nFragments of Table 5 (n=5, lambda=0.1)\n\n")

d.values &lt;- c(1.02, 1 + (1:5)/10, 1.75 , 2)

arl.x &lt;- arl.s &lt;- arl.xs &lt;- PMS.3 &lt;- NULL
for ( delta in d.values ) {
  arl.x  &lt;- c(arl.x,  round(x.res.ewma.arl(lambda, cx/delta, 0, n=n),
                            digits=3))
  arl.s  &lt;- c(arl.s,  round(s.res.ewma.arl(lambda, csu, delta, n=n),
                            digits=3))
  arl.xs &lt;- c(arl.xs, round(xs.res.ewma.arl(lambda, cx, lambda, csu, 0, delta, n=n),
                            digits=3))
  PMS.3  &lt;- c(PMS.3,  round(xs.res.ewma.pms(lambda, cx, lambda, csu, 0, delta, n=n),
                            digits=6))
}

## orinal values are (Markov chain approximation)
# delta   arl.x   arl.s  arl.xs PMS.3
#  1.02 833.086 518.935 323.324 0.381118
#  1.10 454.101  84.208  73.029 0.145005
#  1.20 250.665  25.871  24.432 0.071024
#  1.30 157.343  13.567  13.125 0.047193
#  1.40 108.112   8.941   8.734 0.035945
#  1.50  79.308   6.614   6.493 0.029499
#  1.75  44.128   3.995   3.942 0.021579
#  2.00  28.974   2.887   2.853 0.018220

print(cbind(delta=d.values, arl.x, arl.s, arl.xs, PMS.3))


cat("\nFragments of Table 6 (n=5, lambda=0.1)\n\n")

alphas &lt;- c(-0.9, -0.5, -0.3, 0, 0.3, 0.5, 0.9)
deltas &lt;- c(0.05, 0.25, 0.5, 0.75, 1, 1.25, 1.5, 2)

PMS.4 &lt;- NULL
for ( ir in 1:length(deltas) ) {
  mu &lt;- deltas[ir]*sqrt(n)
  pms &lt;- NULL
  for ( alpha in alphas ) {
    pms &lt;- c(pms, round(xs.res.ewma.pms(lambda, cx, lambda, csu, mu, 1, type="4", alpha=alpha, n=n),
                        digits=6))
  }
  PMS.4 &lt;- rbind(PMS.4, data.frame(delta=deltas[ir], t(pms)))
}
names(PMS.4) &lt;- c("delta", alphas)
rownames(PMS.4) &lt;- NULL

## orinal values are (Markov chain approximation)
#  delta     -0.9     -0.5     -0.3        0      0.3      0.5      0.9
#   0.05 0.055789 0.224521 0.279842 0.342805 0.391299 0.418915 0.471386
#   0.25 0.003566 0.009522 0.014580 0.025786 0.044892 0.066584 0.192023
#   0.50 0.002994 0.001816 0.002596 0.004774 0.009259 0.015303 0.072945
#   0.75 0.006967 0.000703 0.000837 0.001529 0.003400 0.006424 0.046602
#   1.00 0.005098 0.000402 0.000370 0.000625 0.001589 0.003490 0.039978
#   1.25 0.000084 0.000266 0.000202 0.000300 0.000867 0.002220 0.039773
#   1.50 0.000000 0.000256 0.000120 0.000163 0.000531 0.001584 0.042734
#   2.00 0.000000 0.000311 0.000091 0.000056 0.000259 0.001029 0.054543

print(PMS.4)

## End(Not run)
</code></pre>

<hr>
<h2 id='xcusum.ad'>Compute steady-state ARLs of CUSUM control charts</h2><span id='topic+xcusum.ad'></span>

<h3>Description</h3>

<p>Computation of the steady-state Average Run Length (ARL)
for different types of CUSUM control charts monitoring normal mean.</p>


<h3>Usage</h3>

<pre><code class='language-R'>xcusum.ad(k, h, mu1, mu0 = 0, sided = "one", r = 30)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xcusum.ad_+3A_k">k</code></td>
<td>
<p>reference value of the CUSUM control chart.</p>
</td></tr>
<tr><td><code id="xcusum.ad_+3A_h">h</code></td>
<td>
<p>decision interval (alarm limit, threshold) of the CUSUM control chart.</p>
</td></tr>
<tr><td><code id="xcusum.ad_+3A_mu1">mu1</code></td>
<td>
<p>out-of-control mean.</p>
</td></tr>
<tr><td><code id="xcusum.ad_+3A_mu0">mu0</code></td>
<td>
<p>in-control mean.</p>
</td></tr>
<tr><td><code id="xcusum.ad_+3A_sided">sided</code></td>
<td>
<p>distinguish between one-, two-sided and Crosier's modified
two-sided CUSUM scheme by choosing <code>"one"</code>, <code>"two"</code>,
and <code>"Crosier"</code>, respectively.</p>
</td></tr>
<tr><td><code id="xcusum.ad_+3A_r">r</code></td>
<td>
<p>number of quadrature nodes, dimension of the resulting linear
equation system is equal to <code>r+1</code> (one-, two-sided) or <code>2r+1</code>
(Crosier).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>xcusum.ad</code> determines the steady-state Average Run Length (ARL)
by numerically solving the related ARL integral equation by means
of the Nystroem method based on Gauss-Legendre quadrature
and using the power method for deriving the largest in magnitude
eigenvalue and the related left eigenfunction.
</p>


<h3>Value</h3>

<p>Returns a single value which resembles the steady-state ARL.</p>


<h3>Note</h3>

<p>Be cautious in increasing the dimension parameter <code>r</code> for
two-sided CUSUM schemes. The resulting matrix dimension is <code>r^2</code> times
<code>r^2</code>. Thus, go beyond 30 only on fast machines. This is the only case,
were the package routines are based on the Markov chain approach. Moreover,
the two-sided CUSUM scheme needs a two-dimensional Markov chain.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>R. B. Crosier (1986),
A new two-sided cumulative quality control scheme,
<em>Technometrics 28</em>, 187-194.
</p>


<h3>See Also</h3>

<p><code>xcusum.arl</code> for zero-state ARL computation and
<code>xewma.ad</code> for the steady-state ARL of EWMA control charts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## comparison of zero-state (= worst case ) and steady-state performance
## for one-sided CUSUM control charts

k &lt;- .5
h &lt;- xcusum.crit(k,500)
mu &lt;- c(0,.5,1,1.5,2)
arl &lt;- sapply(mu,k=k,h=h,xcusum.arl)
ad &lt;- sapply(mu,k=k,h=h,xcusum.ad)
round(cbind(mu,arl,ad),digits=2)

## Crosier (1986), Crosier's modified two-sided CUSUM
## He introduced the modification and evaluated it by means of
## Markov chain approximation

k &lt;- .5
h2 &lt;- 4
hC &lt;- 3.73
mu &lt;- c(0,.25,.5,.75,1,1.5,2,2.5,3,4,5)
ad2 &lt;- sapply(mu,k=k,h=h2,sided="two",r=20,xcusum.ad)
adC &lt;- sapply(mu,k=k,h=hC,sided="Crosier",xcusum.ad)
round(cbind(mu,ad2,adC),digits=2)

## results in the original paper are (in Table 5)
## 0.00 163.   164.
## 0.25  71.6   69.0
## 0.50  25.2   24.3
## 0.75  12.3   12.1
## 1.00   7.68   7.69
## 1.50   4.31   4.39
## 2.00   3.03   3.12
## 2.50   2.38   2.46
## 3.00   2.00   2.07
## 4.00   1.55   1.60
## 5.00   1.22   1.29
</code></pre>

<hr>
<h2 id='xcusum.arl'>Compute ARLs of CUSUM control charts</h2><span id='topic+xcusum.arl'></span>

<h3>Description</h3>

<p>Computation of the (zero-state) Average Run Length (ARL)
for different types of CUSUM control charts monitoring normal mean.</p>


<h3>Usage</h3>

<pre><code class='language-R'>xcusum.arl(k, h, mu, hs = 0, sided = "one", method = "igl", q = 1, r = 30)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xcusum.arl_+3A_k">k</code></td>
<td>
<p>reference value of the CUSUM control chart.</p>
</td></tr>
<tr><td><code id="xcusum.arl_+3A_h">h</code></td>
<td>
<p>decision interval (alarm limit, threshold) of the CUSUM control chart.</p>
</td></tr>
<tr><td><code id="xcusum.arl_+3A_mu">mu</code></td>
<td>
<p>true mean.</p>
</td></tr>
<tr><td><code id="xcusum.arl_+3A_hs">hs</code></td>
<td>
<p>so-called headstart (give fast initial response).</p>
</td></tr>
<tr><td><code id="xcusum.arl_+3A_sided">sided</code></td>
<td>
<p>distinguish between one-, two-sided and Crosier's modified
two-sided CUSUM scheme by choosing <code>"one"</code>, <code>"two"</code>,
and <code>"Crosier"</code>, respectively.</p>
</td></tr>
<tr><td><code id="xcusum.arl_+3A_method">method</code></td>
<td>
<p>deploy the integral equation (<code>"igl"</code>) or Markov chain approximation
(<code>"mc"</code>) method to calculate the ARL (currently only for two-sided CUSUM implemented).</p>
</td></tr>
<tr><td><code id="xcusum.arl_+3A_q">q</code></td>
<td>
<p>change point position. For <code class="reqn">q=1</code> and
<code class="reqn">\mu=\mu_0</code> and <code class="reqn">\mu=\mu_1</code>, the usual
zero-state ARLs for the in-control and out-of-control case, respectively,
are calculated. For <code class="reqn">q&gt;1</code> and <code class="reqn">\mu!=0</code> conditional delays, that is,
<code class="reqn">E_q(L-q+1|L\ge q)</code>, will be determined.
Note that mu0=0 is implicitely fixed.</p>
</td></tr>
<tr><td><code id="xcusum.arl_+3A_r">r</code></td>
<td>
<p>number of quadrature nodes, dimension of the resulting linear
equation system is equal to <code>r+1</code> (one-, two-sided) or <code>2r+1</code>
(Crosier).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>xcusum.arl</code> determines the Average Run Length (ARL) by numerically
solving the related ARL integral equation by means of the Nystroem method
based on Gauss-Legendre quadrature.
</p>


<h3>Value</h3>

<p>Returns a vector of length <code>q</code> which resembles the ARL and the sequence of conditional expected delays for
<code>q</code>=1 and <code>q</code>&gt;1, respectively.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>A. L. Goel, S. M. Wu (1971),
Determination of A.R.L. and a contour nomogram for CUSUM charts to
control normal mean, <em>Technometrics 13</em>, 221-230.
</p>
<p>D. Brook, D. A. Evans (1972),
An approach to the probability distribution of cusum run length,
<em>Biometrika 59</em>, 539-548.
</p>
<p>J. M. Lucas, R. B. Crosier (1982),
Fast initial response for cusum quality-control schemes: 
Give your cusum a headstart, <em>Technometrics 24</em>, 199-205.
</p>
<p>L. C. Vance (1986), 
Average run lengths of cumulative sum control charts for controlling 
normal means, <em>Journal of Quality Technology 18</em>, 189-193.
</p>
<p>K.-H. Waldmann (1986),
Bounds for the distribution of the run length of one-sided and
two-sided CUSUM quality control schemes,
<em>Technometrics 28</em>, 61-67.
</p>
<p>R. B. Crosier (1986),
A new two-sided cumulative quality control scheme,
<em>Technometrics 28</em>, 187-194.
</p>


<h3>See Also</h3>

<p><code>xewma.arl</code> for zero-state ARL computation of EWMA control charts
and <code>xcusum.ad</code> for the steady-state ARL.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Brook/Evans (1972), one-sided CUSUM
## Their results are based on the less accurate Markov chain approach.

k &lt;- .5
h &lt;- 3
round(c( xcusum.arl(k,h,0), xcusum.arl(k,h,1.5) ),digits=2)

## results in the original paper are L0 = 117.59, L1 = 3.75 (in Subsection 4.3).

## Lucas, Crosier (1982)
## (one- and) two-sided CUSUM with possible headstarts

k &lt;- .5
h &lt;- 4
mu &lt;- c(0,.25,.5,.75,1,1.5,2,2.5,3,4,5)
arl1 &lt;- sapply(mu,k=k,h=h,sided="two",xcusum.arl)
arl2 &lt;- sapply(mu,k=k,h=h,hs=h/2,sided="two",xcusum.arl)
round(cbind(mu,arl1,arl2),digits=2)

## results in the original paper are (in Table 1)
## 0.00 168.   149.
## 0.25  74.2   62.7
## 0.50  26.6   20.1
## 0.75  13.3    8.97
## 1.00   8.38   5.29
## 1.50   4.75   2.86
## 2.00   3.34   2.01
## 2.50   2.62   1.59
## 3.00   2.19   1.32
## 4.00   1.71   1.07
## 5.00   1.31   1.01

## Vance (1986), one-sided CUSUM
## The first paper on using Nystroem method and Gauss-Legendre quadrature
## for solving the ARL integral equation (see as well Goel/Wu, 1971)

k &lt;- 0
h &lt;- 10
mu &lt;- c(-.25,-.125,0,.125,.25,.5,.75,1)
round(cbind(mu,sapply(mu,k=k,h=h,xcusum.arl)),digits=2)

## results in the original paper are (in Table 1 incl. Goel/Wu (1971) results)
##  -0.25  2071.51
##  -0.125  400.28
##   0.0    124.66
##   0.125   59.30
##   0.25    36.71
##   0.50    20.37
##   0.75    14.06
##   1.00    10.75

## Waldmann (1986),
## one- and two-sided CUSUM

## one-sided case

k &lt;- .5
h &lt;- 3
mu &lt;- c(-.5,0,.5)
round(sapply(mu,k=k,h=h,xcusum.arl),digits=2)

## results in the original paper are 1963, 117.4, and 17.35, resp.
## (in Tables 3, 1, and 5, resp.).

## two-sided case

k &lt;- .6
h &lt;- 3
round(xcusum.arl(k,h,-.2,sided="two"),digits=1)  # fits to Waldmann's setup

## result in the original paper is 65.4 (in Table 6).

## Crosier (1986), Crosier's modified two-sided CUSUM
## He introduced the modification and evaluated it by means of
## Markov chain approximation

k &lt;- .5
h &lt;- 3.73
mu &lt;- c(0,.25,.5,.75,1,1.5,2,2.5,3,4,5)
round(cbind(mu,sapply(mu,k=k,h=h,sided="Crosier",xcusum.arl)),digits=2)

## results in the original paper are (in Table 3)
## 0.00 168.
## 0.25  70.7
## 0.50  25.1
## 0.75  12.5
## 1.00   7.92
## 1.50   4.49
## 2.00   3.17
## 2.50   2.49
## 3.00   2.09
## 4.00   1.60
## 5.00   1.22

## SAS/QC manual 1999
## one- and two-sided CUSUM schemes

## one-sided

k &lt;- .25
h &lt;- 8
mu &lt;- 2.5
print(xcusum.arl(k,h,mu),digits=12)
print(xcusum.arl(k,h,mu,hs=.1),digits=12)

## original results are 4.1500836225 and 4.1061588131.

## two-sided

print(xcusum.arl(k,h,mu,sided="two"),digits=12)

## original result is 4.1500826715.
</code></pre>

<hr>
<h2 id='xcusum.crit'>Compute decision intervals of CUSUM control charts</h2><span id='topic+xcusum.crit'></span>

<h3>Description</h3>

<p>Computation of the decision intervals (alarm limits)
for different types of CUSUM control charts monitoring normal mean.</p>


<h3>Usage</h3>

<pre><code class='language-R'>xcusum.crit(k, L0, mu0 = 0, hs = 0, sided = "one", r = 30)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xcusum.crit_+3A_k">k</code></td>
<td>
<p>reference value of the CUSUM control chart.</p>
</td></tr>
<tr><td><code id="xcusum.crit_+3A_l0">L0</code></td>
<td>
<p>in-control ARL.</p>
</td></tr>
<tr><td><code id="xcusum.crit_+3A_mu0">mu0</code></td>
<td>
<p>in-control mean.</p>
</td></tr>
<tr><td><code id="xcusum.crit_+3A_hs">hs</code></td>
<td>
<p>so-called headstart (enables fast initial response).</p>
</td></tr>
<tr><td><code id="xcusum.crit_+3A_sided">sided</code></td>
<td>
<p>distinguishes between one-, two-sided and Crosier's modified
two-sided CUSUM scheme by choosing <code>"one"</code>, <code>"two"</code>, and <code>"Crosier"</code>, respectively.</p>
</td></tr>
<tr><td><code id="xcusum.crit_+3A_r">r</code></td>
<td>
<p>number of quadrature nodes, dimension of the resulting linear
equation system is equal to <code>r+1</code> (one-, two-sided) or <code>2r+1</code>
(Crosier).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>xcusum.crit</code> determines the decision interval (alarm limit)
for given in-control ARL <code>L0</code> by applying secant rule and using <code>xcusum.arl()</code>.
</p>


<h3>Value</h3>

<p>Returns a single value which resembles the decision interval
<code>h</code>.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>See Also</h3>

<p><code>xcusum.arl</code> for zero-state ARL computation.</p>


<h3>Examples</h3>

<pre><code class='language-R'>k &lt;- .5
incontrolARL &lt;- c(500,5000,50000)
sapply(incontrolARL,k=k,xcusum.crit,r=10) # accuracy with 10 nodes
sapply(incontrolARL,k=k,xcusum.crit,r=20) # accuracy with 20 nodes
sapply(incontrolARL,k=k,xcusum.crit)      # accuracy with 30 nodes
</code></pre>

<hr>
<h2 id='xcusum.crit.L0h'>Compute the CUSUM reference value k for given in-control ARL and threshold h</h2><span id='topic+xcusum.crit.L0h'></span>

<h3>Description</h3>

<p>Computation of the reference value k
for one-sided CUSUM control charts monitoring normal mean, if the in-control ARL L0 and
the alarm threshold h are given.</p>


<h3>Usage</h3>

<pre><code class='language-R'>xcusum.crit.L0h(L0, h, hs=0, sided="one", r=30, L0.eps=1e-6, k.eps=1e-8)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xcusum.crit.L0h_+3A_l0">L0</code></td>
<td>
<p>in-control ARL.</p>
</td></tr>
<tr><td><code id="xcusum.crit.L0h_+3A_h">h</code></td>
<td>
<p>alarm level of the CUSUM control chart.</p>
</td></tr>
<tr><td><code id="xcusum.crit.L0h_+3A_hs">hs</code></td>
<td>
<p>so-called headstart (enables fast initial response).</p>
</td></tr>
<tr><td><code id="xcusum.crit.L0h_+3A_sided">sided</code></td>
<td>
<p>distinguishes between one-, two-sided and Crosier's modified
two-sided CUSUM scheme choosing <code>"one"</code>, <code>"two"</code>, and <code>"Crosier"</code>, respectively.</p>
</td></tr>
<tr><td><code id="xcusum.crit.L0h_+3A_r">r</code></td>
<td>
<p>number of quadrature nodes, dimension of the resulting linear
equation system is equal to <code>r+1</code> (one-, two-sided) or <code>2r+1</code> (Crosier).</p>
</td></tr>
<tr><td><code id="xcusum.crit.L0h_+3A_l0.eps">L0.eps</code></td>
<td>
<p>error bound for the L0 error.</p>
</td></tr>
<tr><td><code id="xcusum.crit.L0h_+3A_k.eps">k.eps</code></td>
<td>
<p>bound for the difference of two successive values of k.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>xcusum.crit.L0h</code> determines the reference value k
for given in-control ARL <code>L0</code> and alarm level <code>h</code>
by applying secant rule and using <code>xcusum.arl()</code>. Note that
not for any combination of <code>L0</code> and <code>h</code> a solution exists
&ndash; for given <code>L0</code> there is a maximal value for <code>h</code> to get a valid result <code>k</code>.
</p>


<h3>Value</h3>

<p>Returns a single value which resembles the reference value <code>k</code>.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>See Also</h3>

<p><code>xcusum.arl</code> for zero-state ARL computation.</p>


<h3>Examples</h3>

<pre><code class='language-R'>L0 &lt;- 100
h.max &lt;- xcusum.crit(0, L0, 0)
hs &lt;- (300:1)/100
hs &lt;- hs[hs &lt; h.max]
ks &lt;- NULL
for ( h in hs ) ks &lt;- c(ks, xcusum.crit.L0h(L0, h))  
k.max &lt;- qnorm( 1 - 1/L0 )
plot(hs, ks, type="l", ylim=c(0, max(k.max, ks)), xlab="h", ylab="k")
abline(h=c(0, k.max), col="red")
</code></pre>

<hr>
<h2 id='xcusum.crit.L0L1'>Compute the CUSUM k and h for given in-control ARL L0 and out-of-control L1</h2><span id='topic+xcusum.crit.L0L1'></span>

<h3>Description</h3>

<p>Computation of the reference value k and the alarm threshold h
for one-sided CUSUM control charts monitoring normal mean, if the in-control ARL L0 and the out-of-control L1 are given.</p>


<h3>Usage</h3>

<pre><code class='language-R'>xcusum.crit.L0L1(L0, L1, hs=0, sided="one", r=30, L1.eps=1e-6, k.eps=1e-8)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xcusum.crit.L0L1_+3A_l0">L0</code></td>
<td>
<p>in-control ARL.</p>
</td></tr>
<tr><td><code id="xcusum.crit.L0L1_+3A_l1">L1</code></td>
<td>
<p>out-of-control ARL.</p>
</td></tr>
<tr><td><code id="xcusum.crit.L0L1_+3A_hs">hs</code></td>
<td>
<p>so-called headstart (enables fast initial response).</p>
</td></tr>
<tr><td><code id="xcusum.crit.L0L1_+3A_sided">sided</code></td>
<td>
<p>distinguishes between one-, two-sided and Crosier's modified
two-sided CUSUM schemoosing <code>"one"</code>, <code>"two"</code>, and <code>"Crosier"</code>, respectively.</p>
</td></tr>
<tr><td><code id="xcusum.crit.L0L1_+3A_r">r</code></td>
<td>
<p>number of quadrature nodes, dimension of the resulting linear
equation system is equal to <code>r+1</code> (one-, two-sided) or <code>2r+1</code> (Crosier).</p>
</td></tr>
<tr><td><code id="xcusum.crit.L0L1_+3A_l1.eps">L1.eps</code></td>
<td>
<p>error bound for the L1 error.</p>
</td></tr>
<tr><td><code id="xcusum.crit.L0L1_+3A_k.eps">k.eps</code></td>
<td>
<p>bound for the difference of two successive values of k.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>xcusum.crit.L0L1</code> determines the reference value k and the alarm threshold h
for given in-control ARL <code>L0</code> and out-of-control ARL <code>L1</code>
by applying secant rule and using <code>xcusum.arl()</code> and <code>xcusum.crit()</code>.
These CUSUM design rules were firstly (and quite rarely afterwards) used by Ewan and Kemp.
</p>


<h3>Value</h3>

<p>Returns two values which resemble the reference value <code>k</code> and the threshold <code>h</code>.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>W. D. Ewan and K. W. Kemp (1960),
Sampling inspection of continuous processes with no autocorrelation between successive results,
<em>Biometrika 47</em>, 363-380.
</p>
<p>K. W. Kemp (1962),
The Use of Cumulative Sums for Sampling Inspection Schemes,
<em>Journal of the Royal Statistical Sociecty C, Applied Statistics, 10</em>, 16-31.
</p>


<h3>See Also</h3>

<p><code>xcusum.arl</code> for zero-state ARL and <code>xcusum.crit</code> for threshold h computation.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Table 2 from Ewan/Kemp (1960) -- one-sided CUSUM
#
# A.R.L. at A.Q.L.   A.R.L. at A.Q.L.     k      h
#       1000                3           1.12   2.40
#       1000                7           0.65   4.06
#        500                3           1.04   2.26
#        500                7           0.60   3.80
#        250                3           0.94   2.11
#        250                7           0.54   3.51
#
L0.set &lt;- c(1000, 500, 250)
L1.set &lt;- c(3, 7)
cat("\nL0\tL1\tk\th\n")
for ( L0 in L0.set ) {
  for ( L1 in L1.set ) {
    result &lt;- round(xcusum.crit.L0L1(L0, L1), digits=2)
    cat(paste(L0, L1, result[1], result[2], sep="\t"), "\n")
  }
}
#
# two confirmation runs
xcusum.arl(0.54, 3.51, 0) # Ewan/Kemp
xcusum.arl(result[1], result[2], 0) # here
xcusum.arl(0.54, 3.51, 2*0.54) # Ewan/Kemp
xcusum.arl(result[1], result[2], 2*result[1]) # here
#
## Table II from Kemp (1962) -- two-sided CUSUM
#
#    Lr                  k
#             La=250   La=500   La=1000
#    2.5       1.05     1.17     1.27
#    3.0       0.94     1.035    1.13
#    4.0       0.78     0.85     0.92
#    5.0       0.68     0.74     0.80
#    6.0       0.60     0.655    0.71
#    7.5       0.52     0.57     0.62
#   10.0       0.43     0.48     0.52
#
L0.set &lt;- c(250, 500, 1000)
L1.set &lt;- c(2.5, 3:6, 7.5, 10)
cat("\nL1\tL0=250\tL0=500\tL0=1000\n")
for ( L1 in L1.set ) {
  cat(L1)
  for ( L0 in L0.set ) {
    result &lt;- round(xcusum.crit.L0L1(L0, L1, sided="two"), digits=2)
    cat("\t", result[1])
  }
  cat("\n")
}
</code></pre>

<hr>
<h2 id='xcusum.q'>Compute RL quantiles of CUSUM control charts</h2><span id='topic+xcusum.q'></span>

<h3>Description</h3>

<p>Computation of quantiles of the Run Length (RL)for CUSUM control charts monitoring normal mean.</p>


<h3>Usage</h3>

<pre><code class='language-R'>xcusum.q(k, h, mu, alpha, hs=0, sided="one", r=40)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xcusum.q_+3A_k">k</code></td>
<td>
<p>reference value of the CUSUM control chart.</p>
</td></tr>
<tr><td><code id="xcusum.q_+3A_h">h</code></td>
<td>
<p>decision interval (alarm limit, threshold) of the CUSUM control chart.</p>
</td></tr>
<tr><td><code id="xcusum.q_+3A_mu">mu</code></td>
<td>
<p>true mean.</p>
</td></tr>
<tr><td><code id="xcusum.q_+3A_alpha">alpha</code></td>
<td>
<p>quantile level.</p>
</td></tr>
<tr><td><code id="xcusum.q_+3A_hs">hs</code></td>
<td>
<p>so-called headstart (enables fast initial response).</p>
</td></tr>
<tr><td><code id="xcusum.q_+3A_sided">sided</code></td>
<td>
<p>distinguishes between one- and two-sided CUSUM control chart by choosing <code>"one"</code> and <code>"two"</code>, respectively.</p>
</td></tr>
<tr><td><code id="xcusum.q_+3A_r">r</code></td>
<td>
<p>number of quadrature nodes, dimension of the resulting linear equation system is equal to <code>r+1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Instead of the popular ARL (Average Run Length) quantiles of the CUSUM
stopping time (Run Length) are determined. The algorithm is based on
Waldmann's survival function iteration procedure.
</p>


<h3>Value</h3>

<p>Returns a single value which resembles the RL quantile of order <code>q</code>.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>K.-H. Waldmann (1986),
Bounds for the distribution of the run length of one-sided and two-sided CUSUM quality control schemes,
<em>Technometrics 28</em>, 61-67.
</p>


<h3>See Also</h3>

<p><code>xcusum.arl</code> for zero-state ARL computation of CUSUM control charts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Waldmann (1986), one-sided CUSUM, Table 2
## original values are 345, 82, 9

XCUSUM.Q &lt;- Vectorize("xcusum.q", "alpha")
k &lt;- .5
h &lt;- 3
mu &lt;- 0 # corresponds to Waldmann's -0.5
a.list &lt;- c(.95, .5, .05)
rl.quantiles &lt;- ceiling(XCUSUM.Q(k, h, mu, a.list))
cbind(a.list, rl.quantiles)
</code></pre>

<hr>
<h2 id='xcusum.sf'>Compute the survival function of CUSUM run length</h2><span id='topic+xcusum.sf'></span>

<h3>Description</h3>

<p>Computation of the survival function of the Run Length (RL) for CUSUM control charts monitoring normal mean.</p>


<h3>Usage</h3>

<pre><code class='language-R'>xcusum.sf(k, h, mu, n, hs=0, sided="one", r=40)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xcusum.sf_+3A_k">k</code></td>
<td>
<p>reference value of the CUSUM control chart.</p>
</td></tr>
<tr><td><code id="xcusum.sf_+3A_h">h</code></td>
<td>
<p>decision interval (alarm limit, threshold) of the CUSUM control chart.</p>
</td></tr>
<tr><td><code id="xcusum.sf_+3A_mu">mu</code></td>
<td>
<p>true mean.</p>
</td></tr>
<tr><td><code id="xcusum.sf_+3A_n">n</code></td>
<td>
<p>calculate sf up to value <code>n</code>.</p>
</td></tr>
<tr><td><code id="xcusum.sf_+3A_hs">hs</code></td>
<td>
<p>so-called headstart (enables fast initial response).</p>
</td></tr>
<tr><td><code id="xcusum.sf_+3A_sided">sided</code></td>
<td>
<p>distinguishes between one- and two-sided CUSUM control chart by choosing <code>"one"</code> and <code>"two"</code>, respectively.</p>
</td></tr>
<tr><td><code id="xcusum.sf_+3A_r">r</code></td>
<td>
<p>number of quadrature nodes, dimension of the resulting linear equation system is equal to <code>r+1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The survival function P(L&gt;n) and derived from it also the cdf P(L&lt;=n) and the pmf P(L=n) illustrate
the distribution of the CUSUM run length. For large n the geometric tail could be exploited. That is,
with reasonable large n the complete distribution is characterized.
The algorithm is based on Waldmann's survival function iteration procedure.
</p>


<h3>Value</h3>

<p>Returns a vector which resembles the survival function up to a certain point.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>K.-H. Waldmann (1986),
Bounds for the distribution of the run length of one-sided and two-sided CUSUM quality control schemes,
<em>Technometrics 28</em>, 61-67.
</p>


<h3>See Also</h3>

<p><code>xcusum.q</code> for computation of CUSUM run length quantiles.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Waldmann (1986), one-sided CUSUM, Table 2

k &lt;- .5
h &lt;- 3
mu &lt;- 0 # corresponds to Waldmann's -0.5
SF &lt;- xcusum.sf(k, h, 0, 1000)
plot(1:length(SF), SF, type="l", xlab="n", ylab="P(L&gt;n)", ylim=c(0,1))
#
</code></pre>

<hr>
<h2 id='xDcusum.arl'>Compute ARLs of CUSUM control charts under drift</h2><span id='topic+xDcusum.arl'></span>

<h3>Description</h3>

<p>Computation of the (zero-state and other) Average Run Length (ARL)
under drift for one-sided CUSUM control charts monitoring normal mean.</p>


<h3>Usage</h3>

<pre><code class='language-R'>xDcusum.arl(k, h, delta, hs = 0, sided = "one",
    mode = "Gan", m = NULL, q = 1, r = 30, with0 = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xDcusum.arl_+3A_k">k</code></td>
<td>
<p>reference value of the CUSUM control chart.</p>
</td></tr>
<tr><td><code id="xDcusum.arl_+3A_h">h</code></td>
<td>
<p>decision interval (alarm limit, threshold) of the CUSUM control chart.</p>
</td></tr>
<tr><td><code id="xDcusum.arl_+3A_delta">delta</code></td>
<td>
<p>true drift parameter.</p>
</td></tr>
<tr><td><code id="xDcusum.arl_+3A_hs">hs</code></td>
<td>
<p>so-called headstart (enables fast initial response).</p>
</td></tr>
<tr><td><code id="xDcusum.arl_+3A_sided">sided</code></td>
<td>
<p>distinguishes between one- and two-sided CUSUM control chart
by choosing <code>"one"</code> and <code>"two"</code>, respectively. Currentlly,
the two-sided scheme is not implemented.</p>
</td></tr>
<tr><td><code id="xDcusum.arl_+3A_mode">mode</code></td>
<td>
<p>decide whether Gan's or Knoth's approach is used. Use
<code>"Gan"</code> and <code>"Knoth"</code>, respectively.</p>
</td></tr>
<tr><td><code id="xDcusum.arl_+3A_m">m</code></td>
<td>
<p>parameter used if <code>mode="Gan"</code>. <code>m</code> is design
parameter of Gan's approach. If <code>m=NULL</code>, then <code>m</code>
will increased until the resulting ARL does not change anymore.</p>
</td></tr>
<tr><td><code id="xDcusum.arl_+3A_q">q</code></td>
<td>
<p>change point position. For <code class="reqn">q=1</code> and
<code class="reqn">\mu=\mu_0</code> and <code class="reqn">\mu=\mu_1</code>, the usual
zero-state ARLs for the in-control and out-of-control case, respectively,
are calculated. For <code class="reqn">q&gt;1</code> and <code class="reqn">\mu!=0</code> conditional delays, that is,
<code class="reqn">E_q(L-q+1|L\geq)</code>, will be determined.
Note that mu0=0 is implicitely fixed. Deploy large <code>q</code> to mimic
steady-state. It works only for <code>mode="Knoth"</code>.</p>
</td></tr>
<tr><td><code id="xDcusum.arl_+3A_r">r</code></td>
<td>
<p>number of quadrature nodes, dimension of the resulting linear
equation system is equal to <code>r+1</code> (one-sided) or <code>r</code>
(two-sided).</p>
</td></tr>
<tr><td><code id="xDcusum.arl_+3A_with0">with0</code></td>
<td>
<p>defines whether the first observation used for the RL
calculation follows already 1*delta or still 0*delta.
With <code>q</code> additional flexibility is given.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Based on Gan (1991) or Knoth (2003), the ARL is calculated for
one-sided CUSUM
control charts under drift. In case of Gan's framework, the usual
ARL function with mu=m*delta is determined and recursively via
m-1, m-2, ... 1 (or 0) the drift ARL determined. The framework
of Knoth allows to calculate ARLs for varying parameters, such as
control limits and distributional parameters.
For details see the cited papers. Note that two-sided CUSUM charts
under drift are difficult to treat.
</p>


<h3>Value</h3>

<p>Returns a single value which resembles the ARL.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>F. F. Gan (1992),
CUSUM control charts under linear drift,
<em>Statistician 41</em>, 71-84.
</p>
<p>F. F. Gan (1996),
Average Run Lengths for Cumulative Sum control chart under linear trend,
<em>Applied Statistics 45</em>, 505-512.
</p>
<p>S. Knoth (2003),
EWMA schemes with non-homogeneous transition kernels,
<em>Sequential Analysis 22</em>, 241-255.
</p>
<p>S. Knoth (2012),
More on Control Charting under Drift,
in: <em>Frontiers in Statistical Quality Control 10</em>,
H.-J. Lenz, W. Schmid and P.-T. Wilrich (Eds.),
Physica Verlag, Heidelberg, Germany, 53-68.
</p>
<p>C. Zou, Y. Liu and Z. Wang (2009),
Comparisons of control schemes for monitoring
the means of processes subject to drifts,
<em>Metrika 70</em>, 141-163.
</p>


<h3>See Also</h3>

<p><code>xcusum.arl</code> and <code>xcusum.ad</code> for zero-state and
steady-state ARL computation of CUSUM control charts
for the classical step change model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Gan (1992)
## Table 1
## original values are
#   deltas  arl
#   0.0001  475
#   0.0005  261
#   0.0010  187
#   0.0020  129
#   0.0050  76.3
#   0.0100  52.0
#   0.0200  35.2
#   0.0500  21.4
#   0.1000  15.0
#   0.5000  6.95
#   1.0000  5.16
#   3.0000  3.30
## Not run: k &lt;- .25
h &lt;- 8
r &lt;- 50
DxDcusum.arl &lt;- Vectorize(xDcusum.arl, "delta")
deltas &lt;- c(0.0001, 0.0005, 0.001, 0.002, 0.005, 0.01, 0.02, 0.05, 0.1, 0.5, 1, 3)
arl.like.Gan   &lt;-
  round(DxDcusum.arl(k, h, deltas, r=r, with0=TRUE), digits=2)
arl.like.Knoth &lt;-
  round(DxDcusum.arl(k, h, deltas, r=r, mode="Knoth", with0=TRUE), digits=2)
data.frame(deltas, arl.like.Gan, arl.like.Knoth)
## End(Not run)

## Zou et al. (2009)
## Table 1
## original values are
#  delta   arl1  arl2  arl3
#  0           ~ 1730
#  0.0005  345   412   470
#  0.001   231   275   317
#  0.005   86.6  98.6  112
#  0.01    56.9  61.8  69.3
#  0.05    22.6  21.6  22.7
#  0.1     15.4  14.7  14.2
#  0.5     6.60  5.54  5.17
#  1.0     4.63  3.80  3.45
#  2.0     3.17  2.67  2.32
#  3.0     2.79  2.04  1.96
#  4.0     2.10  1.98  1.74
## Not run: 
k1 &lt;- 0.25
k2 &lt;- 0.5
k3 &lt;- 0.75
h1 &lt;- 9.660
h2 &lt;- 5.620
h3 &lt;- 3.904
deltas &lt;- c(0.0005, 0.001, 0.005, 0.01, 0.05, 0.1, 0.5, 1:4)
arl1 &lt;- c(round(xcusum.arl(k1, h1, 0, r=r), digits=2),
          round(DxDcusum.arl(k1, h1, deltas, r=r), digits=2))
arl2 &lt;- c(round(xcusum.arl(k2, h2, 0), digits=2),
          round(DxDcusum.arl(k2, h2, deltas, r=r), digits=2))
arl3 &lt;- c(round(xcusum.arl(k3, h3, 0, r=r), digits=2),
          round(DxDcusum.arl(k3, h3, deltas, r=r), digits=2))
data.frame(delta=c(0, deltas), arl1, arl2, arl3)
## End(Not run)
</code></pre>

<hr>
<h2 id='xDewma.arl'>Compute ARLs of EWMA control charts under drift</h2><span id='topic+xDewma.arl'></span>

<h3>Description</h3>

<p>Computation of the (zero-state and other)
Average Run Length (ARL) under drift
for different types of EWMA control charts monitoring normal mean.</p>


<h3>Usage</h3>

<pre><code class='language-R'>xDewma.arl(l, c, delta, zr = 0, hs = 0, sided = "one", limits = "fix",
    mode = "Gan", m = NULL, q = 1, r = 40, with0 = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xDewma.arl_+3A_l">l</code></td>
<td>
<p>smoothing parameter lambda of the EWMA control chart.</p>
</td></tr>
<tr><td><code id="xDewma.arl_+3A_c">c</code></td>
<td>
<p>critical value (similar to alarm limit) of the EWMA control chart.</p>
</td></tr>
<tr><td><code id="xDewma.arl_+3A_delta">delta</code></td>
<td>
<p>true drift parameter.</p>
</td></tr>
<tr><td><code id="xDewma.arl_+3A_zr">zr</code></td>
<td>
<p>reflection border for the one-sided chart.</p>
</td></tr>
<tr><td><code id="xDewma.arl_+3A_hs">hs</code></td>
<td>
<p>so-called headstart (enables fast initial response).</p>
</td></tr>
<tr><td><code id="xDewma.arl_+3A_sided">sided</code></td>
<td>
<p>distinguish between one- and two-sided EWMA control chart 
by choosing <code>"one"</code> and <code>"two"</code>, respectively.</p>
</td></tr>
<tr><td><code id="xDewma.arl_+3A_limits">limits</code></td>
<td>
<p>distinguishes between different control limits behavior.</p>
</td></tr>
<tr><td><code id="xDewma.arl_+3A_mode">mode</code></td>
<td>
<p>decide whether Gan's or Knoth's approach is used. Use
<code>"Gan"</code> and <code>"Knoth"</code>, respectively.</p>
</td></tr>
<tr><td><code id="xDewma.arl_+3A_m">m</code></td>
<td>
<p>parameter used if <code>mode="Gan"</code>. <code>m</code> is design
parameter of Gan's approach. If <code>m=NULL</code>, then <code>m</code>
will increased until the resulting ARL does not change anymore.</p>
</td></tr>
<tr><td><code id="xDewma.arl_+3A_q">q</code></td>
<td>
<p>change point position. For <code class="reqn">q=1</code> and
<code class="reqn">\mu=\mu_0</code> and <code class="reqn">\mu=\mu_1</code>, the usual
zero-state ARLs for the in-control and out-of-control case, respectively,
are calculated. For <code class="reqn">q&gt;1</code> and <code class="reqn">\mu!=0</code> conditional delays, that is,
<code class="reqn">E_q(L-q+1|L\geq)</code>, will be determined.
Note that mu0=0 is implicitely fixed. Deploy large <code>q</code> to mimic
steady-state. It works only for <code>mode="Knoth"</code>.</p>
</td></tr>
<tr><td><code id="xDewma.arl_+3A_r">r</code></td>
<td>
<p>number of quadrature nodes, dimension of the resulting linear
equation system is equal to <code>r+1</code> (one-sided) or <code>r</code>
(two-sided).</p>
</td></tr>
<tr><td><code id="xDewma.arl_+3A_with0">with0</code></td>
<td>
<p>defines whether the first observation used for the RL calculation
follows already 1*delta or still 0*delta.
With <code>q</code> additional flexibility is given.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Based on Gan (1991) or Knoth (2003), the ARL is calculated for EWMA
control charts under drift. In case of Gan's framework, the usual
ARL function with mu=m*delta is determined and recursively via
m-1, m-2, ... 1 (or 0) the drift ARL determined. The framework
of Knoth allows to calculate ARLs for varying parameters, such as
control limits and distributional parameters.
For details see the cited papers.
</p>


<h3>Value</h3>

<p>Returns a single value which resembles the ARL.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>F. F. Gan (1991),
EWMA control chart under linear drift,
<em>J. Stat. Comput. Simulation 38</em>, 181-200.
</p>
<p>L. A. Aerne, C. W. Champ and S. E. Rigdon (1991),
Evaluation of control charts under linear trend,
<em>Commun. Stat., Theory Methods 20</em>, 3341-3349.
</p>
<p>S. Knoth (2003),
EWMA schemes with non-homogeneous transition kernels,
<em>Sequential Analysis 22</em>, 241-255.
</p>
<p>H. M. Fahmy and E. A. Elsayed (2006),
Detection of linear trends in process mean,
<em>International Journal of Production Research 44</em>, 487-504.
</p>
<p>S. Knoth (2012),
More on Control Charting under Drift,
in: <em>Frontiers in Statistical Quality Control 10</em>,
H.-J. Lenz, W. Schmid and P.-T. Wilrich (Eds.),
Physica Verlag, Heidelberg, Germany, 53-68.
</p>
<p>C. Zou, Y. Liu and Z. Wang (2009),
Comparisons of control schemes for monitoring
the means of processes subject to drifts,
<em>Metrika 70</em>, 141-163.
</p>


<h3>See Also</h3>

<p><code>xewma.arl</code> and <code>xewma.ad</code> for zero-state and
steady-state ARL computation of EWMA control charts
for the classical step change model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
DxDewma.arl &lt;- Vectorize(xDewma.arl, "delta")
## Gan (1991)
## Table 1
## original values are
#  delta   arlE1  arlE2  arlE3
#  0       500    500    500
#  0.0001  482    460    424
#  0.0010  289    231    185
#  0.0020  210    162    129
#  0.0050  126     94.6   77.9
#  0.0100   81.7   61.3   52.7
#  0.0500   27.5   21.8   21.9
#  0.1000   17.0   14.2   15.3
#  1.0000    4.09   4.28   5.25
#  3.0000    2.60   2.90   3.43
#
lambda1 &lt;- 0.676
lambda2 &lt;- 0.242
lambda3 &lt;- 0.047
h1 &lt;- 2.204/sqrt(lambda1/(2-lambda1))
h2 &lt;- 1.111/sqrt(lambda2/(2-lambda2))
h3 &lt;- 0.403/sqrt(lambda3/(2-lambda3))
deltas &lt;- c(.0001, .001, .002, .005, .01, .05, .1, 1, 3)
arlE10 &lt;- round(xewma.arl(lambda1, h1, 0, sided="two"), digits=2)
arlE1 &lt;- c(arlE10, round(DxDewma.arl(lambda1, h1, deltas, sided="two", with0=TRUE),
                         digits=2))
arlE20 &lt;- round(xewma.arl(lambda2, h2, 0, sided="two"), digits=2)
arlE2 &lt;- c(arlE20, round(DxDewma.arl(lambda2, h2, deltas, sided="two", with0=TRUE),
                         digits=2))
arlE30 &lt;- round(xewma.arl(lambda3, h3, 0, sided="two"), digits=2)
arlE3 &lt;- c(arlE30, round(DxDewma.arl(lambda3, h3, deltas, sided="two", with0=TRUE),
                         digits=2))
data.frame(delta=c(0, deltas), arlE1, arlE2, arlE3)

## do the same with more digits for the alarm threshold
L0 &lt;- 500
h1 &lt;- xewma.crit(lambda1, L0, sided="two")
h2 &lt;- xewma.crit(lambda2, L0, sided="two")
h3 &lt;- xewma.crit(lambda3, L0, sided="two")
lambdas &lt;- c(lambda1, lambda2, lambda3)
hs &lt;- c(h1, h2, h3) * sqrt(lambdas/(2-lambdas))
hs
# compare with Gan's values 2.204, 1.111, 0.403
round(hs, digits=3)

arlE10 &lt;- round(xewma.arl(lambda1, h1, 0, sided="two"), digits=2)
arlE1 &lt;- c(arlE10, round(DxDewma.arl(lambda1, h1, deltas, sided="two", with0=TRUE),
                         digits=2))
arlE20 &lt;- round(xewma.arl(lambda2, h2, 0, sided="two"), digits=2)
arlE2 &lt;- c(arlE20, round(DxDewma.arl(lambda2, h2, deltas, sided="two", with0=TRUE),
                         digits=2))
arlE30 &lt;- round(xewma.arl(lambda3, h3, 0, sided="two"), digits=2)
arlE3 &lt;- c(arlE30, round(DxDewma.arl(lambda3, h3, deltas, sided="two", with0=TRUE),
                         digits=2))
data.frame(delta=c(0, deltas), arlE1, arlE2, arlE3)

## Aerne et al. (1991) -- two-sided EWMA
## Table I (continued)
## original numbers are
#     delta  arlE1  arlE2  arlE3
#  0.000000  465.0  465.0  465.0
#  0.005623  77.01  85.93  102.68
#  0.007499  64.61  71.78  85.74
#  0.010000  54.20  59.74  71.22
#  0.013335  45.20  49.58  58.90
#  0.017783  37.76  41.06  48.54
#  0.023714  31.54  33.95  39.87
#  0.031623  26.36  28.06  32.68
#  0.042170  22.06  23.19  26.73
#  0.056234  18.49  19.17  21.84
#  0.074989  15.53  15.87  17.83
#  0.100000  13.07  13.16  14.55
#  0.133352  11.03  10.94  11.88
#  0.177828   9.33   9.12   9.71
#  0.237137   7.91   7.62   7.95
#  0.316228   6.72   6.39   6.52
#  0.421697   5.72   5.38   5.37
#  0.562341   4.88   4.54   4.44
#  0.749894   4.18   3.84   3.68
#  1.000000   3.58   3.27   3.07
#
lambda1 &lt;- .133
lambda2 &lt;- .25
lambda3 &lt;- .5
cE1 &lt;- 2.856
cE2 &lt;- 2.974
cE3 &lt;- 3.049
deltas &lt;- 10^(-(18:0)/8)
arlE10 &lt;- round(xewma.arl(lambda1, cE1, 0, sided="two"), digits=2)
arlE1 &lt;- c(arlE10, round(DxDewma.arl(lambda1, cE1, deltas, sided="two"), digits=2))
arlE20 &lt;- round(xewma.arl(lambda2, cE2, 0, sided="two"), digits=2)
arlE2 &lt;- c(arlE20, round(DxDewma.arl(lambda2, cE2, deltas, sided="two"), digits=2))
arlE30 &lt;- round(xewma.arl(lambda3, cE3, 0, sided="two"), digits=2)
arlE3 &lt;- c(arlE30, round(DxDewma.arl(lambda3, cE3, deltas, sided="two"), digits=2))
data.frame(delta=c(0, round(deltas, digits=6)), arlE1, arlE2, arlE3)


## Fahmy/Elsayed (2006) -- two-sided EWMA
## Table 4 (Monte Carlo results, 10^4 replicates, change point at t=51!)
## original numbers are
#   delta     arl  s.e.
#   0.00  365.749  3.598
#   0.10   12.971  0.029
#   0.25    7.738  0.015
#   0.50    5.312  0.009
#   0.75    4.279  0.007
#   1.00    3.680  0.006
#   1.25    3.271  0.006
#   1.50    2.979  0.005
#   1.75    2.782  0.004
#   2.00    2.598  0.005
#
lambda &lt;- 0.1
cE &lt;- 2.7
deltas &lt;- c(.1, (1:8)/4)
arlE1 &lt;- c(round(xewma.arl(lambda, cE, 0, sided="two"), digits=3),
           round(DxDewma.arl(lambda, cE, deltas, sided="two"), digits=3))
arlE51 &lt;- c(round(xewma.arl(lambda, cE, 0, sided="two", q=51)[51], digits=3),
     round(DxDewma.arl(lambda, cE, deltas, sided="two", mode="Knoth", q=51),
           digits=3))
data.frame(delta=c(0, deltas), arlE1, arlE51)

## additional Monte Carlo results with 10^8 replicates
#   delta   arl.q=1   s.e.    arl.q=51  s.e.
#   0.00    368.910   0.036   361.714   0.038
#   0.10     12.986   0.000    12.781   0.000
#   0.25      7.758   0.000     7.637   0.000
#   0.50      5.318   0.000     5.235   0.000
#   0.75      4.285   0.000     4.218   0.000
#   1.00      3.688   0.000     3.628   0.000
#   1.25      3.274   0.000     3.233   0.000
#   1.50      2.993   0.000     2.942   0.000
#   1.75      2.808   0.000     2.723   0.000
#   2.00      2.616   0.000     2.554   0.000

## Zou et al. (2009) -- one-sided EWMA
## Table 1
## original values are
#  delta   arl1  arl2  arl3
#  0           ~ 1730
#  0.0005  317   377   440
#  0.001   215   253   297
#  0.005   83.6  92.6  106
#  0.01    55.6  58.8  66.1
#  0.05    22.6  21.1  22.0
#  0.1     15.5  13.9  13.8
#  0.5     6.65  5.56  5.09
#  1.0     4.67  3.83  3.43
#  2.0     3.21  2.74  2.32
#  3.0     2.86  2.06  1.98
#  4.0     2.14  2.00  1.83
l1 &lt;- 0.03479
l2 &lt;- 0.11125
l3 &lt;- 0.23052
c1 &lt;- 2.711
c2 &lt;- 3.033
c3 &lt;- 3.161
zr &lt;- -6
r  &lt;- 50
deltas &lt;- c(0.0005, 0.001, 0.005, 0.01, 0.05, 0.1, 0.5, 1:4)
arl1 &lt;- c(round(xewma.arl(l1, c1, 0, zr=zr, r=r), digits=2),
          round(DxDewma.arl(l1, c1, deltas, zr=zr, r=r), digits=2))
arl2 &lt;- c(round(xewma.arl(l2, c2, 0, zr=zr), digits=2),
          round(DxDewma.arl(l2, c2, deltas, zr=zr, r=r), digits=2))
arl3 &lt;- c(round(xewma.arl(l3, c3, 0, zr=zr, r=r), digits=2),
          round(DxDewma.arl(l3, c3, deltas, zr=zr, r=r), digits=2))
data.frame(delta=c(0, deltas), arl1, arl2, arl3)

## End(Not run)
</code></pre>

<hr>
<h2 id='xDgrsr.arl'>Compute ARLs of Shiryaev-Roberts schemes under drift</h2><span id='topic+xDgrsr.arl'></span>

<h3>Description</h3>

<p>Computation of the (zero-state and other)
Average Run Length (ARL) under drift
for Shiryaev-Roberts schemes monitoring normal mean.</p>


<h3>Usage</h3>

<pre><code class='language-R'>xDgrsr.arl(k, g, delta, zr = 0, hs = NULL, sided = "one", m = NULL,
mode = "Gan", q = 1, r = 30, with0 = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xDgrsr.arl_+3A_k">k</code></td>
<td>
<p>reference value of the Shiryaev-Roberts scheme.</p>
</td></tr>
<tr><td><code id="xDgrsr.arl_+3A_g">g</code></td>
<td>
<p>control limit (alarm threshold) of Shiryaev-Roberts scheme.</p>
</td></tr>
<tr><td><code id="xDgrsr.arl_+3A_delta">delta</code></td>
<td>
<p>true drift parameter.</p>
</td></tr>
<tr><td><code id="xDgrsr.arl_+3A_zr">zr</code></td>
<td>
<p>reflection border for the one-sided chart.</p>
</td></tr>
<tr><td><code id="xDgrsr.arl_+3A_hs">hs</code></td>
<td>
<p>so-called headstart (enables fast initial response).</p>
</td></tr>
<tr><td><code id="xDgrsr.arl_+3A_sided">sided</code></td>
<td>
<p>distinguishes between one- and two-sided 
Shiryaev-Roberts schemes
by choosing <code>"one"</code> and <code>"two"</code>, respectively. Currentlly,
the two-sided scheme is not implemented.</p>
</td></tr>
<tr><td><code id="xDgrsr.arl_+3A_m">m</code></td>
<td>
<p>parameter used if <code>mode="Gan"</code>. <code>m</code> is design
parameter of Gan's approach. If <code>m=NULL</code>, then <code>m</code>
will increased until the resulting ARL does not change anymore.</p>
</td></tr>
<tr><td><code id="xDgrsr.arl_+3A_q">q</code></td>
<td>
<p>change point position. For <code class="reqn">q=1</code> and
<code class="reqn">\mu=\mu_0</code> and <code class="reqn">\mu=\mu_1</code>, the usual
zero-state ARLs for the in-control and out-of-control case, respectively,
are calculated. For <code class="reqn">q&gt;1</code> and <code class="reqn">\mu!=0</code> conditional delays, that is,
<code class="reqn">E_q(L-q+1|L\geq)</code>, will be determined.
Note that mu0=0 is implicitely fixed. Deploy large <code>q</code> to mimic
steady-state. It works only for <code>mode="Knoth"</code>.</p>
</td></tr>
<tr><td><code id="xDgrsr.arl_+3A_mode">mode</code></td>
<td>
<p>decide whether Gan's or Knoth's approach is used. Use
<code>"Gan"</code> and <code>"Knoth"</code>, respectively.
<code>"Knoth"</code> is not implemented yet.</p>
</td></tr>
<tr><td><code id="xDgrsr.arl_+3A_r">r</code></td>
<td>
<p>number of quadrature nodes, dimension of the resulting linear
equation system is equal to <code>r+1</code> (one-sided) or <code>r</code> (two-sided).</p>
</td></tr>
<tr><td><code id="xDgrsr.arl_+3A_with0">with0</code></td>
<td>
<p>defines whether the first observation used for the RL calculation
follows already 1*delta or still 0*delta.
With <code>q</code> additional flexibility is given.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Based on Gan (1991) or Knoth (2003), the ARL is calculated for Shiryaev-Roberts schemes under drift.
In case of Gan's framework, the usual
ARL function with mu=m*delta is determined and recursively via
m-1, m-2, ... 1 (or 0) the drift ARL determined. The framework
of Knoth allows to calculate ARLs for varying parameters, such as
control limits and distributional parameters.
For details see the cited papers.
</p>


<h3>Value</h3>

<p>Returns a single value which resembles the ARL.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>F. F. Gan (1991),
EWMA control chart under linear drift,
<em>J. Stat. Comput. Simulation 38</em>, 181-200.
</p>
<p>S. Knoth (2003),
EWMA schemes with non-homogeneous transition kernels,
<em>Sequential Analysis 22</em>, 241-255.
</p>
<p>S. Knoth (2012),
More on Control Charting under Drift,
in: <em>Frontiers in Statistical Quality Control 10</em>,
H.-J. Lenz, W. Schmid and P.-T. Wilrich (Eds.),
Physica Verlag, Heidelberg, Germany, 53-68.
</p>
<p>C. Zou, Y. Liu and Z. Wang (2009),
Comparisons of control schemes for monitoring
the means of processes subject to drifts,
<em>Metrika 70</em>, 141-163.
</p>


<h3>See Also</h3>

<p><code>xewma.arl</code> and <code>xewma.ad</code> for zero-state and
steady-state ARL computation of EWMA control charts
for the classical step change model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Monte Carlo example with 10^8 replicates
#   delta      arl    s.e.
#   0.0001 381.8240   0.0304
#   0.0005 238.4630   0.0148
#   0.001  177.4061   0.0097
#   0.002  125.9055   0.0061
#   0.005   75.7574   0.0031
#   0.01    50.2203   0.0018
#   0.02    32.9458   0.0011
#   0.05    18.9213   0.0005
#   0.1     12.6054   0.0003
#   0.5      5.2157   0.0001
#   1        3.6537   0.0001
#   3        2.0289   0.0000
k &lt;- .5
L0 &lt;- 500
zr &lt;- -7
r &lt;- 50
g &lt;- xgrsr.crit(k, L0, zr=zr, r=r)
DxDgrsr.arl &lt;- Vectorize(xDgrsr.arl, "delta")
deltas &lt;- c(0.0001, 0.0005, 0.001, 0.002, 0.005, 0.01, 0.02, 0.05, 0.1, 0.5, 1, 3)
arls &lt;- round(DxDgrsr.arl(k, g, deltas, zr=zr, r=r), digits=4)
data.frame(deltas, arls)

## End(Not run)
</code></pre>

<hr>
<h2 id='xDshewhartrunsrules.arl'>Compute ARLs of Shewhart control charts with and without runs rules
under drift</h2><span id='topic+xDshewhartrunsrules.arl'></span><span id='topic+xDshewhartrunsrulesFixedm.arl'></span>

<h3>Description</h3>

<p>Computation of the zero-state Average Run Length (ARL)
under drift for Shewhart control charts with and without runs rules
monitoring normal mean.</p>


<h3>Usage</h3>

<pre><code class='language-R'>xDshewhartrunsrules.arl(delta, c = 1, m = NULL, type = "12")

xDshewhartrunsrulesFixedm.arl(delta, c = 1, m = 100, type = "12")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xDshewhartrunsrules.arl_+3A_delta">delta</code></td>
<td>
<p>true drift parameter.</p>
</td></tr>
<tr><td><code id="xDshewhartrunsrules.arl_+3A_c">c</code></td>
<td>
<p>normalizing constant to ensure specific alarming behavior.</p>
</td></tr>
<tr><td><code id="xDshewhartrunsrules.arl_+3A_type">type</code></td>
<td>
<p>controls the type of Shewhart chart used, seed details section.</p>
</td></tr>
<tr><td><code id="xDshewhartrunsrules.arl_+3A_m">m</code></td>
<td>
<p>parameter of Gan's approach. If <code>m=NULL</code>, then <code>m</code> will increased until
the resulting ARL does not change anymore.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Based on Gan (1991), the ARL is calculated for
Shewhart control charts with and without runs rules
under drift. The usual ARL function with mu=m*delta is determined and recursively via
m-1, m-2, ... 1 (or 0) the drift ARL determined.
<code>xDshewhartrunsrulesFixedm.arl</code> is the actual work horse, while
<code>xDshewhartrunsrules.arl</code> provides a convenience wrapper.
Note that Aerne et al. (1991) deployed a method that is
quite similar to Gan's algorithm. For <code>type</code> see
the help page of <code>xshewhartrunsrules.arl</code>.
</p>


<h3>Value</h3>

<p>Returns a single value which resembles the ARL.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>F. F. Gan (1991),
EWMA control chart under linear drift,
<em>J. Stat. Comput. Simulation 38</em>, 181-200.
</p>
<p>L. A. Aerne, C. W. Champ and S. E. Rigdon (1991),
Evaluation of control charts under linear trend,
<em>Commun. Stat., Theory Methods 20</em>, 3341-3349.
</p>


<h3>See Also</h3>

<p><code>xshewhartrunsrules.arl</code> for zero-state ARL computation of
Shewhart control charts with and without runs rules
for the classical step change model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Aerne et al. (1991)
## Table I (continued)
## original numbers are
#     delta arl1of1 arl2of3 arl4of5  arl10
#  0.005623  136.67  120.90  105.34 107.08
#  0.007499  114.98  101.23   88.09  89.94
#  0.010000   96.03   84.22   73.31  75.23
#  0.013335   79.69   69.68   60.75  62.73
#  0.017783   65.75   57.38   50.18  52.18
#  0.023714   53.99   47.06   41.33  43.35
#  0.031623   44.15   38.47   33.99  36.00
#  0.042170   35.97   31.36   27.91  29.90
#  0.056234   29.21   25.51   22.91  24.86
#  0.074989   23.65   20.71   18.81  20.70
#  0.100000   19.11   16.79   15.45  17.29
#  0.133352   15.41   13.61   12.72  14.47
#  0.177828   12.41   11.03   10.50  12.14
#  0.237137    9.98    8.94    8.71  10.18
#  0.316228    8.02    7.25    7.26   8.45
#  0.421697    6.44    5.89    6.09   6.84
#  0.562341    5.17    4.80    5.15   5.48
#  0.749894    4.16    3.92    4.36   4.39
#  1.000000    3.35    3.22    3.63   3.52
c1of1 &lt;- 3.069/3
c2of3 &lt;- 2.1494/2
c4of5 &lt;- 1.14
c10   &lt;- 3.2425/3
DxDshewhartrunsrules.arl &lt;- Vectorize(xDshewhartrunsrules.arl, "delta")
deltas &lt;- 10^(-(18:0)/8)
arl1of1 &lt;-
round(DxDshewhartrunsrules.arl(deltas, c=c1of1, type="1"), digits=2)
arl2of3 &lt;-
round(DxDshewhartrunsrules.arl(deltas, c=c2of3, type="12"), digits=2)
arl4of5 &lt;-
round(DxDshewhartrunsrules.arl(deltas, c=c4of5, type="13"), digits=2)
arl10 &lt;- 
round(DxDshewhartrunsrules.arl(deltas, c=c10, type="SameSide10"), digits=2)
data.frame(delta=round(deltas, digits=6), arl1of1, arl2of3, arl4of5, arl10)
</code></pre>

<hr>
<h2 id='xewma.ad'>Compute steady-state ARLs of EWMA control charts</h2><span id='topic+xewma.ad'></span>

<h3>Description</h3>

<p>Computation of the steady-state Average Run Length (ARL)
for different types of EWMA control charts monitoring normal mean.</p>


<h3>Usage</h3>

<pre><code class='language-R'>xewma.ad(l, c, mu1, mu0=0, zr=0, z0=0, sided="one", limits="fix",
steady.state.mode="conditional", r=40)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xewma.ad_+3A_l">l</code></td>
<td>
<p>smoothing parameter lambda of the EWMA control chart.</p>
</td></tr>
<tr><td><code id="xewma.ad_+3A_c">c</code></td>
<td>
<p>critical value (similar to alarm limit) of the EWMA control chart.</p>
</td></tr>
<tr><td><code id="xewma.ad_+3A_mu1">mu1</code></td>
<td>
<p>out-of-control mean.</p>
</td></tr>
<tr><td><code id="xewma.ad_+3A_mu0">mu0</code></td>
<td>
<p>in-control mean.</p>
</td></tr>
<tr><td><code id="xewma.ad_+3A_zr">zr</code></td>
<td>
<p>reflection border for the one-sided chart.</p>
</td></tr>
<tr><td><code id="xewma.ad_+3A_z0">z0</code></td>
<td>
<p>restarting value of the EWMA sequence in case of a false alarm in
<code>steady.state.mode="cyclical"</code>.</p>
</td></tr>
<tr><td><code id="xewma.ad_+3A_sided">sided</code></td>
<td>
<p>distinguishes between one- and two-sided two-sided EWMA control
chart by choosing <code>"one"</code> and <code>"two"</code>, respectively.</p>
</td></tr>
<tr><td><code id="xewma.ad_+3A_limits">limits</code></td>
<td>
<p>distinguishes between different control limits behavior.</p>
</td></tr>
<tr><td><code id="xewma.ad_+3A_steady.state.mode">steady.state.mode</code></td>
<td>
<p>distinguishes between two steady-state modes &ndash; conditional and cyclical.</p>
</td></tr>
<tr><td><code id="xewma.ad_+3A_r">r</code></td>
<td>
<p>number of quadrature nodes, dimension of the resulting linear
equation system is equal to <code>r+1</code> (one-sided) or <code>r</code>
(two-sided).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>xewma.ad</code> determines the steady-state Average Run Length (ARL)
by numerically solving the related ARL integral equation by means
of the Nystroem method based on Gauss-Legendre quadrature
and using the power method for deriving the largest in magnitude
eigenvalue and the related left eigenfunction.
</p>


<h3>Value</h3>

<p>Returns a single value which resembles the steady-state ARL.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>R. B. Crosier (1986),
A new two-sided cumulative quality control scheme,
<em>Technometrics 28</em>, 187-194.
</p>
<p>S. V. Crowder (1987),
A simple method for studying run-length distributions of exponentially weighted
moving average charts,
<em>Technometrics 29</em>, 401-407.
</p>
<p>J. M. Lucas and M. S. Saccucci (1990),
Exponentially weighted moving average control schemes: Properties and enhancements,
<em>Technometrics 32</em>, 1-12.
</p>


<h3>See Also</h3>

<p><code>xewma.arl</code> for zero-state ARL computation and
<code>xcusum.ad</code> for the steady-state ARL of CUSUM control charts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## comparison of zero-state (= worst case ) and steady-state performance
## for two-sided EWMA control charts

l &lt;- .1
c &lt;- xewma.crit(l,500,sided="two")
mu &lt;- c(0,.5,1,1.5,2)
arl &lt;- sapply(mu,l=l,c=c,sided="two",xewma.arl)
ad &lt;- sapply(mu,l=l,c=c,sided="two",xewma.ad)
round(cbind(mu,arl,ad),digits=2)

## Lucas/Saccucci (1990)
## two-sided EWMA

## with fixed limits
l1 &lt;- .5
l2 &lt;- .03
c1 &lt;- 3.071
c2 &lt;- 2.437
mu &lt;- c(0,.25,.5,.75,1,1.5,2,2.5,3,3.5,4,5)
ad1 &lt;- sapply(mu,l=l1,c=c1,sided="two",xewma.ad)
ad2 &lt;- sapply(mu,l=l2,c=c2,sided="two",xewma.ad)
round(cbind(mu,ad1,ad2),digits=2)

## original results are (in Table 3)
## 0.00 499.   480.  
## 0.25 254.    74.1
## 0.50  88.4   28.6
## 0.75  35.7   17.3
## 1.00  17.3   12.5
## 1.50   6.44   8.00
## 2.00   3.58   5.95
## 2.50   2.47   4.78
## 3.00   1.91   4.02
## 3.50   1.58   3.49
## 4.00   1.36   3.09
## 5.00   1.10   2.55
</code></pre>

<hr>
<h2 id='xewma.arl'>Compute ARLs of EWMA control charts</h2><span id='topic+xewma.arl'></span>

<h3>Description</h3>

<p>Computation of the (zero-state) Average Run Length (ARL)
for different types of EWMA control charts monitoring normal mean.</p>


<h3>Usage</h3>

<pre><code class='language-R'>xewma.arl(l,c,mu,zr=0,hs=0,sided="one",limits="fix",q=1,
steady.state.mode="conditional",r=40)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xewma.arl_+3A_l">l</code></td>
<td>
<p>smoothing parameter lambda of the EWMA control chart.</p>
</td></tr>
<tr><td><code id="xewma.arl_+3A_c">c</code></td>
<td>
<p>critical value (similar to alarm limit) of the EWMA control chart.</p>
</td></tr>
<tr><td><code id="xewma.arl_+3A_mu">mu</code></td>
<td>
<p>true mean.</p>
</td></tr>
<tr><td><code id="xewma.arl_+3A_zr">zr</code></td>
<td>
<p>reflection border for the one-sided chart.</p>
</td></tr>
<tr><td><code id="xewma.arl_+3A_hs">hs</code></td>
<td>
<p>so-called headstart (enables fast initial response).</p>
</td></tr>
<tr><td><code id="xewma.arl_+3A_sided">sided</code></td>
<td>
<p>distinguishes between one- and two-sided EWMA control chart 
by choosing <code>"one"</code> and <code>"two"</code>, respectively.</p>
</td></tr>
<tr><td><code id="xewma.arl_+3A_limits">limits</code></td>
<td>
<p>distinguishes between different control limits behavior.</p>
</td></tr>
<tr><td><code id="xewma.arl_+3A_q">q</code></td>
<td>
<p>change point position. For <code class="reqn">q=1</code> and
<code class="reqn">\mu=\mu_0</code> and <code class="reqn">\mu=\mu_1</code>, the usual
zero-state ARLs for the in-control and out-of-control case, respectively,
are calculated. For <code class="reqn">q&gt;1</code> and <code class="reqn">\mu!=0</code> conditional delays, that is,
<code class="reqn">E_q(L-q+1|L\ge q)</code>, will be determined. Note that mu0=0 is implicitely fixed.</p>
</td></tr>
<tr><td><code id="xewma.arl_+3A_steady.state.mode">steady.state.mode</code></td>
<td>
<p>distinguishes between two steady-state modes &ndash; conditional and cyclical
(needed for <code>q&gt;1</code>).</p>
</td></tr>
<tr><td><code id="xewma.arl_+3A_r">r</code></td>
<td>
<p>number of quadrature nodes, dimension of the resulting linear
equation system is equal to <code>r+1</code> (one-sided) or <code>r</code>
(two-sided).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In case of the EWMA chart with fixed control limits,
<code>xewma.arl</code> determines the Average Run Length (ARL) by numerically
solving the related ARL integral equation by means of the Nystroem method
based on Gauss-Legendre quadrature.
If <code>limits</code> is not <code>"fix"</code>, then the method presented in Knoth (2003) is utilized.
Note that for one-sided EWMA charts (<code>sided</code>=<code>"one"</code>), only
<code>"vacl"</code> and <code>"stat"</code> are deployed, while for two-sided ones
(<code>sided</code>=<code>"two"</code>) also <code>"fir"</code>, <code>"both"</code>
(combination of <code>"fir"</code> and <code>"vacl"</code>), and <code>"Steiner"</code> are implemented.
For details see Knoth (2004).
</p>


<h3>Value</h3>

<p>Except for the fixed limits EWMA charts it returns a single value which resembles the ARL.
For fixed limits charts, it returns a vector of length <code>q</code> which resembles the ARL and the
sequence of conditional expected delays for
<code>q</code>=1 and <code>q</code>&gt;1, respectively.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>K.-H. Waldmann (1986),
Bounds for the distribution of the run length of geometric moving 
average charts, <em>Appl. Statist. 35</em>, 151-158.
</p>
<p>S. V. Crowder (1987),
A simple method for studying run-length distributions of
exponentially weighted moving average charts,
<em>Technometrics 29</em>, 401-407.
</p>
<p>J. M. Lucas and M. S. Saccucci (1990),
Exponentially weighted moving average control schemes: Properties
and enhancements, <em>Technometrics 32</em>, 1-12.
</p>
<p>S. Chandrasekaran, J. R. English and R. L. Disney (1995), 
Modeling and analysis of EWMA control schemes with variance-adjusted 
control limits, <em>IIE Transactions 277</em>, 282-290.
</p>
<p>T. R. Rhoads, D. C. Montgomery and C. M. Mastrangelo (1996),
Fast initial response scheme for exponentially weighted moving average
control chart, <em>Quality Engineering 9</em>, 317-327.
</p>
<p>S. H. Steiner (1999),
EWMA control charts with time-varying control limits and fast initial response, 
<em>Journal of Quality Technology 31</em>, 75-86.
</p>
<p>S. Knoth (2003),
EWMA schemes with non-homogeneous transition kernels,
<em>Sequential Analysis 22</em>, 241-255.
</p>
<p>S. Knoth (2004),
Fast initial response features for EWMA Control Charts,
<em>Statistical Papers 46</em>, 47-64.
</p>


<h3>See Also</h3>

<p><code>xcusum.arl</code> for zero-state ARL computation of CUSUM control charts
and <code>xewma.ad</code> for the steady-state ARL.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Waldmann (1986), one-sided EWMA
l &lt;- .75
round(xewma.arl(l,2*sqrt((2-l)/l),0,zr=-4*sqrt((2-l)/l)),digits=1)
l &lt;- .5
round(xewma.arl(l,2*sqrt((2-l)/l),0,zr=-4*sqrt((2-l)/l)),digits=1)
## original values are 209.3 and 3907.5 (in Table 2).

## Waldmann (1986), two-sided EWMA with fixed control limits
l &lt;- .75
round(xewma.arl(l,2*sqrt((2-l)/l),0,sided="two"),digits=1)
l &lt;- .5
round(xewma.arl(l,2*sqrt((2-l)/l),0,sided="two"),digits=1)
## original values are 104.0 and 1952 (in Table 1).

## Crowder (1987), two-sided EWMA with fixed control limits
l1 &lt;- .5
l2 &lt;- .05
c &lt;- 2
mu &lt;- (0:16)/4
arl1 &lt;- sapply(mu,l=l1,c=c,sided="two",xewma.arl)
arl2 &lt;- sapply(mu,l=l2,c=c,sided="two",xewma.arl)
round(cbind(mu,arl1,arl2),digits=2)

## original results are (in Table 1)
## 0.00 26.45 127.53
## 0.25 20.12  43.94
## 0.50 11.89  18.97
## 0.75  7.29  11.64
## 1.00  4.91   8.38
## 1.25  3.95*  6.56
## 1.50  2.80   5.41
## 1.75  2.29   4.62
## 2.00  1.94   4.04
## 2.25  1.70   3.61
## 2.50  1.51   3.26
## 2.75  1.37   2.99
## 3.00  1.26   2.76
## 3.25  1.18   2.56
## 3.50  1.12   2.39
## 3.75  1.08   2.26
## 4.00  1.05   2.15  (* -- in Crowder (1987) typo!?)

## Lucas/Saccucci (1990)
## two-sided EWMA

## with fixed limits
l1 &lt;- .5
l2 &lt;- .03
c1 &lt;- 3.071
c2 &lt;- 2.437
mu &lt;- c(0,.25,.5,.75,1,1.5,2,2.5,3,3.5,4,5)
arl1 &lt;- sapply(mu,l=l1,c=c1,sided="two",xewma.arl)
arl2 &lt;- sapply(mu,l=l2,c=c2,sided="two",xewma.arl)
round(cbind(mu,arl1,arl2),digits=2)

## original results are (in Table 3)
## 0.00 500.   500.
## 0.25 255.    76.7
## 0.50  88.8   29.3
## 0.75  35.9   17.6
## 1.00  17.5   12.6
## 1.50   6.53   8.07
## 2.00   3.63   5.99
## 2.50   2.50   4.80
## 3.00   1.93   4.03
## 3.50   1.58   3.49
## 4.00   1.34   3.11
## 5.00   1.07   2.55

## Not run: 
## with fir feature
l1 &lt;- .5
l2 &lt;- .03
c1 &lt;- 3.071
c2 &lt;- 2.437
hs1 &lt;- c1/2
hs2 &lt;- c2/2
mu &lt;- c(0,.5,1,2,3,5)
arl1 &lt;- sapply(mu,l=l1,c=c1,hs=hs1,sided="two",limits="fir",xewma.arl)
arl2 &lt;- sapply(mu,l=l2,c=c2,hs=hs2,sided="two",limits="fir",xewma.arl)
round(cbind(mu,arl1,arl2),digits=2)

## original results are (in Table 5)
## 0.0 487.   406.
## 0.5  86.1   18.4
## 1.0  15.9    7.36
## 2.0   2.87   3.43
## 3.0   1.45   2.34
## 5.0   1.01   1.57

## Chandrasekaran, English, Disney (1995)
## two-sided EWMA with fixed and variance adjusted limits (vacl)

l1 &lt;- .25
l2 &lt;- .1
c1s &lt;- 2.9985
c1n &lt;- 3.0042
c2s &lt;- 2.8159
c2n &lt;- 2.8452
mu &lt;- c(0,.25,.5,.75,1,2)
arl1s &lt;- sapply(mu,l=l1,c=c1s,sided="two",xewma.arl)
arl1n &lt;- sapply(mu,l=l1,c=c1n,sided="two",limits="vacl",xewma.arl)
arl2s &lt;- sapply(mu,l=l2,c=c2s,sided="two",xewma.arl)
arl2n &lt;- sapply(mu,l=l2,c=c2n,sided="two",limits="vacl",xewma.arl)
round(cbind(mu,arl1s,arl1n,arl2s,arl2n),digits=2)

## original results are (in Table 2)
## 0.00 500.   500.   500.   500.
## 0.25 170.09 167.54 105.90  96.6
## 0.50  48.14  45.65  31.08  24.35
## 0.75  20.02  19.72  15.71  10.74
## 1.00  11.07   9.37  10.23   6.35
## 2.00   3.59   2.64   4.32   2.73

## The results in Chandrasekaran, English, Disney (1995) are not
## that accurate. Let us consider the more appropriate comparison

c1s &lt;- xewma.crit(l1,500,sided="two")
c1n &lt;- xewma.crit(l1,500,sided="two",limits="vacl")
c2s &lt;- xewma.crit(l2,500,sided="two")
c2n &lt;- xewma.crit(l2,500,sided="two",limits="vacl")
mu &lt;- c(0,.25,.5,.75,1,2)
arl1s &lt;- sapply(mu,l=l1,c=c1s,sided="two",xewma.arl)
arl1n &lt;- sapply(mu,l=l1,c=c1n,sided="two",limits="vacl",xewma.arl)
arl2s &lt;- sapply(mu,l=l2,c=c2s,sided="two",xewma.arl)
arl2n &lt;- sapply(mu,l=l2,c=c2n,sided="two",limits="vacl",xewma.arl)
round(cbind(mu,arl1s,arl1n,arl2s,arl2n),digits=2)

## which demonstrate the abilities of the variance-adjusted limits
## scheme more explicitely.

## Rhoads, Montgomery, Mastrangelo (1996)
## two-sided EWMA with fixed and variance adjusted limits (vacl),
## with fir and both features

l &lt;- .03
c &lt;- 2.437
mu &lt;- c(0,.5,1,1.5,2,3,4)
sl &lt;- sqrt(l*(2-l))
arlfix  &lt;- sapply(mu,l=l,c=c,sided="two",xewma.arl)
arlvacl &lt;- sapply(mu,l=l,c=c,sided="two",limits="vacl",xewma.arl)
arlfir  &lt;- sapply(mu,l=l,c=c,hs=c/2,sided="two",limits="fir",xewma.arl)
arlboth &lt;- sapply(mu,l=l,c=c,hs=c/2*sl,sided="two",limits="both",xewma.arl)
round(cbind(mu,arlfix,arlvacl,arlfir,arlboth),digits=1)

## original results are (in Table 1)
## 0.0 477.3* 427.9* 383.4* 286.2*
## 0.5  29.7   20.0   18.6   12.8
## 1.0  12.5    6.5    7.4    3.6
## 1.5   8.1    3.3    4.6    1.9
## 2.0   6.0    2.2    3.4    1.4
## 3.0   4.0    1.3    2.4    1.0
## 4.0   3.1    1.1    1.9    1.0
## * -- the in-control values differ sustainably from the true values!

## Steiner (1999)
## two-sided EWMA control charts with various modifications

## fixed vs. variance adjusted limits

l &lt;- .05
c &lt;- 3
mu &lt;- c(0,.25,.5,.75,1,1.5,2,2.5,3,3.5,4)
arlfix &lt;- sapply(mu,l=l,c=c,sided="two",xewma.arl)
arlvacl &lt;- sapply(mu,l=l,c=c,sided="two",limits="vacl",xewma.arl)
round(cbind(mu,arlfix,arlvacl),digits=1)

## original results are (in Table 2)
## 0.00 1379.0   1353.0
## 0.25  135.0    127.0
## 0.50   37.4     32.5 
## 0.75   20.0     15.6
## 1.00   13.5      9.0
## 1.50    8.3      4.5
## 2.00    6.0      2.8
## 2.50    4.8      2.0
## 3.00    4.0      1.6
## 3.50    3.4      1.3
## 4.00    3.0      1.1

## fir, both, and Steiner's modification

l &lt;- .03
cfir &lt;- 2.44
cboth &lt;- 2.54
cstein &lt;- 2.55
hsfir &lt;- cfir/2
hsboth &lt;- cboth/2*sqrt(l*(2-l))
mu &lt;- c(0,.5,1,1.5,2,3,4)
arlfir &lt;- sapply(mu,l=l,c=cfir,hs=hsfir,sided="two",limits="fir",xewma.arl)
arlboth &lt;- sapply(mu,l=l,c=cboth,hs=hsboth,sided="two",limits="both",xewma.arl)
arlstein &lt;- sapply(mu,l=l,c=cstein,sided="two",limits="Steiner",xewma.arl)
round(cbind(mu,arlfir,arlboth,arlstein),digits=1)

## original values are (in Table 5)
## 0.0 383.0   384.0   391.0
## 0.5  18.6    14.9    13.8
## 1.0   7.4     3.9     3.6
## 1.5   4.6     2.0     1.8
## 2.0   3.4     1.4     1.3
## 3.0   2.4     1.1     1.0
## 4.0   1.9     1.0     1.0

## SAS/QC manual 1999
## two-sided EWMA control charts with fixed limits

l &lt;- .25
c &lt;- 3
mu &lt;- 1
print(xewma.arl(l,c,mu,sided="two"),digits=11)

# original value is 11.154267016.

## Some recent examples for one-sided EWMA charts
## with varying limits and in the so-called stationary mode

# 1. varying limits = "vacl"

lambda &lt;- .1
L0 &lt;- 500

## Monte Carlo results (10^9 replicates)
# mu    ARL      s.e.
# 0     500.00   0.0160
# 0.5   21.637   0.0006
# 1     6.7596   0.0001
# 1.5   3.5398   0.0001
# 2     2.3038   0.0000
# 2.5   1.7004   0.0000
# 3     1.3675   0.0000

zr &lt;- -6
r &lt;- 50
c &lt;- xewma.crit(lambda, L0, zr=zr, limits="vacl", r=r)
Mxewma.arl &lt;- Vectorize(xewma.arl, "mu")
mus &lt;- (0:6)/2
arls &lt;- round(Mxewma.arl(lambda, c, mus, zr=zr, limits="vacl", r=r), digits=4)
data.frame(mus, arls)

# 2. stationary mode, i. e. limits = "stat"

## Monte Carlo results (10^9 replicates)
# mu    ARL      s.e.
# 0     500.00   0.0159
# 0.5   22.313   0.0006
# 1     7.2920   0.0001
# 1.5   3.9064   0.0001
# 2     2.5131   0.0000
# 2.5   1.7983   0.0000
# 3     1.4029   0.0000

c &lt;- xewma.crit(lambda, L0, zr=zr, limits="stat", r=r)
arls &lt;- round(Mxewma.arl(lambda, c, mus, zr=zr, limits="stat", r=r), digits=4)
data.frame(mus, arls)

## End(Not run)
</code></pre>

<hr>
<h2 id='xewma.arl.f'>Compute ARL function of EWMA control charts</h2><span id='topic+xewma.arl.f'></span>

<h3>Description</h3>

<p>Computation of the (zero-state) Average Run Length (ARL) function for different types of EWMA control charts monitoring normal mean.</p>


<h3>Usage</h3>

<pre><code class='language-R'>xewma.arl.f(l,c,mu,zr=0,sided="one",limits="fix",r=40)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xewma.arl.f_+3A_l">l</code></td>
<td>
<p>smoothing parameter lambda of the EWMA control chart.</p>
</td></tr>
<tr><td><code id="xewma.arl.f_+3A_c">c</code></td>
<td>
<p>critical value (similar to alarm limit) of the EWMA control chart.</p>
</td></tr>
<tr><td><code id="xewma.arl.f_+3A_mu">mu</code></td>
<td>
<p>true mean.</p>
</td></tr>
<tr><td><code id="xewma.arl.f_+3A_zr">zr</code></td>
<td>
<p>reflection border for the one-sided chart.</p>
</td></tr>
<tr><td><code id="xewma.arl.f_+3A_sided">sided</code></td>
<td>
<p>distinguishes between one- and two-sided EWMA control chart by choosing <code>"one"</code> and <code>"two"</code>, respectively.</p>
</td></tr>
<tr><td><code id="xewma.arl.f_+3A_limits">limits</code></td>
<td>
<p>distinguishes between different control limits behavior.</p>
</td></tr>
<tr><td><code id="xewma.arl.f_+3A_r">r</code></td>
<td>
<p>number of quadrature nodes, dimension of the resulting linear equation system is equal to <code>r+1</code> (one-sided) or <code>r</code> (two-sided).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is a convenience function to yield the ARL as function of the head start <code>hs</code>. For more details see <code>xewma.arl</code>.
</p>


<h3>Value</h3>

<p>It returns a function of a single argument, <code>hs=x</code> which maps the head-start value <code>hs</code> to the ARL.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>S. V. Crowder (1987),
A simple method for studying run-length distributions of exponentially weighted moving average charts,
<em>Technometrics 29</em>, 401-407.
</p>


<h3>See Also</h3>

<p><code>xewma.arl</code> for zero-state ARL for one specific head-start <code>hs</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will follow
</code></pre>

<hr>
<h2 id='xewma.arl.prerun'>Compute ARLs of EWMA control charts in case of estimated parameters</h2><span id='topic+xewma.arl.prerun'></span><span id='topic+xewma.crit.prerun'></span>

<h3>Description</h3>

<p>Computation of the (zero-state) Average Run Length (ARL)
for different types of EWMA control charts monitoring normal mean
if the in-control mean, standard deviation, or both are estimated by a pre run.</p>


<h3>Usage</h3>

<pre><code class='language-R'>xewma.arl.prerun(l, c, mu, zr=0, hs=0, sided="two", limits="fix", q=1,
size=100, df=NULL, estimated="mu", qm.mu=30, qm.sigma=30, truncate=1e-10)

xewma.crit.prerun(l, L0, mu, zr=0, hs=0, sided="two", limits="fix", size=100,
df=NULL, estimated="mu", qm.mu=30, qm.sigma=30, truncate=1e-10,
c.error=1e-12, L.error=1e-9, OUTPUT=FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xewma.arl.prerun_+3A_l">l</code></td>
<td>
<p>smoothing parameter lambda of the EWMA control chart.</p>
</td></tr>
<tr><td><code id="xewma.arl.prerun_+3A_c">c</code></td>
<td>
<p>critical value (similar to alarm limit) of the EWMA control chart.</p>
</td></tr>
<tr><td><code id="xewma.arl.prerun_+3A_mu">mu</code></td>
<td>
<p>true mean shift.</p>
</td></tr>
<tr><td><code id="xewma.arl.prerun_+3A_zr">zr</code></td>
<td>
<p>reflection border for the one-sided chart.</p>
</td></tr>
<tr><td><code id="xewma.arl.prerun_+3A_hs">hs</code></td>
<td>
<p>so-called headstart (give fast initial response).</p>
</td></tr>
<tr><td><code id="xewma.arl.prerun_+3A_sided">sided</code></td>
<td>
<p>distinguish between one- and two-sided EWMA control chart 
by choosing <code>"one"</code> and <code>"two"</code>, respectively.</p>
</td></tr>
<tr><td><code id="xewma.arl.prerun_+3A_limits">limits</code></td>
<td>
<p>distinguish between different control limits behavior.</p>
</td></tr>
<tr><td><code id="xewma.arl.prerun_+3A_q">q</code></td>
<td>
<p>change point position. For <code class="reqn">q=1</code> and
<code class="reqn">\mu=\mu_0</code> and <code class="reqn">\mu=\mu_1</code>, the usual
zero-state ARLs for the in-control and out-of-control case, respectively,
are calculated. For <code class="reqn">q&gt;1</code> and <code class="reqn">\mu!=0</code> conditional delays, that is,
<code class="reqn">E_q(L-q+1|L\ge q)</code>, will be determined.
Note that mu0=0 is implicitely fixed.</p>
</td></tr>
<tr><td><code id="xewma.arl.prerun_+3A_size">size</code></td>
<td>
<p>pre run sample size.</p>
</td></tr>
<tr><td><code id="xewma.arl.prerun_+3A_df">df</code></td>
<td>
<p>Degrees of freedom of the pre run variance estimator. Typically it is simply <code>size</code> - 1.
If the pre run is collected in batches, then also other values are needed.</p>
</td></tr>
<tr><td><code id="xewma.arl.prerun_+3A_estimated">estimated</code></td>
<td>
<p>name the parameter to be estimated within
the <code>"mu"</code>, <code>"sigma"</code>, <code>"both"</code>.</p>
</td></tr>
<tr><td><code id="xewma.arl.prerun_+3A_qm.mu">qm.mu</code></td>
<td>
<p>number of quadrature nodes for convoluting the mean uncertainty.</p>
</td></tr>
<tr><td><code id="xewma.arl.prerun_+3A_qm.sigma">qm.sigma</code></td>
<td>
<p>number of quadrature nodes for convoluting the standard deviation uncertainty.</p>
</td></tr>
<tr><td><code id="xewma.arl.prerun_+3A_truncate">truncate</code></td>
<td>
<p>size of truncated tail.</p>
</td></tr>
<tr><td><code id="xewma.arl.prerun_+3A_l0">L0</code></td>
<td>
<p>in-control ARL.</p>
</td></tr>
<tr><td><code id="xewma.arl.prerun_+3A_c.error">c.error</code></td>
<td>
<p>error bound for two succeeding values of the critical value
during applying the secant rule.</p>
</td></tr>
<tr><td><code id="xewma.arl.prerun_+3A_l.error">L.error</code></td>
<td>
<p>error bound for the ARL level <code>L0</code> during applying the secant rule.</p>
</td></tr>
<tr><td><code id="xewma.arl.prerun_+3A_output">OUTPUT</code></td>
<td>
<p>activate or deactivate additional output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Essentially, the ARL function <code>xewma.arl</code> is convoluted with the
distribution of the sample mean, standard deviation or both.
For details see Jones/Champ/Rigdon (2001) and Knoth (2014?).
</p>


<h3>Value</h3>

<p>Returns a single value which resembles the ARL.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>L. A. Jones, C. W. Champ, S. E. Rigdon (2001),
The performance of exponentially weighted moving average charts
with estimated parameters,
<em>Technometrics 43</em>, 156-167.
</p>
<p>S. Knoth (2003),
EWMA schemes with non-homogeneous transition kernels,
<em>Sequential Analysis 22</em>, 241-255.
</p>
<p>S. Knoth (2004),
Fast initial response features for EWMA Control Charts,
<em>Statistical Papers 46</em>, 47-64.
</p>
<p>S. Knoth (2014?),
tbd,
<em>tbd</em>, tbd-tbd.
</p>


<h3>See Also</h3>

<p><code>xewma.arl</code> for the usual zero-state ARL computation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Jones/Champ/Rigdon (2001)

c4m &lt;- function(m, n) sqrt(2)*gamma( (m*(n-1)+1)/2 )/sqrt( m*(n-1) )/gamma( m*(n-1)/2 )

n &lt;- 5 # sample size
m &lt;- 20 # pre run with 20 samples of size n = 5
C4m &lt;- c4m(m, n) # needed for bias correction

# Table 1, 3rd column
lambda &lt;- 0.2
L &lt;- 2.636

xewma.ARL &lt;- Vectorize("xewma.arl", "mu")
xewma.ARL.prerun &lt;- Vectorize("xewma.arl.prerun", "mu")

mu &lt;- c(0, .25, .5, 1, 1.5, 2)
ARL &lt;- round(xewma.ARL(lambda, L, mu, sided="two"), digits=2)
p.ARL &lt;- round(xewma.ARL.prerun(lambda, L/C4m, mu, sided="two",
size=m, df=m*(n-1), estimated="both", qm.mu=70), digits=2)

# Monte-Carlo with 10^8 repetitions: 200.325 (0.020) and 144.458 (0.022)
cbind(mu, ARL, p.ARL)

## Not run: 
# Figure 5, subfigure r = 0.2
mu_ &lt;- (0:85)/40
ARL_ &lt;- round(xewma.ARL(lambda, L, mu_, sided="two"), digits=2)
p.ARL_ &lt;- round(xewma.ARL.prerun(lambda, L/C4m, mu_, sided="two",
size=m, df=m*(n-1), estimated="both"), digits=2)

plot(mu_, ARL_, type="l", xlab=expression(delta), ylab="ARL", xlim=c(0,2))
abline(v=0, h=0, col="grey", lwd=.7)
points(mu, ARL, pch=5)
lines(mu_, p.ARL_, col="blue")
points(mu, p.ARL, pch=18, col ="blue")
legend("topright", c("Known", "Estimated"), col=c("black", "blue"),
lty=1, pch=c(5, 18))

## End(Not run)
</code></pre>

<hr>
<h2 id='xewma.crit'>Compute critical values of EWMA control charts</h2><span id='topic+xewma.crit'></span>

<h3>Description</h3>

<p>Computation of the critical values (similar to alarm limits)
for different types of EWMA control charts monitoring normal mean.</p>


<h3>Usage</h3>

<pre><code class='language-R'>xewma.crit(l,L0,mu0=0,zr=0,hs=0,sided="one",limits="fix",r=40,c0=NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xewma.crit_+3A_l">l</code></td>
<td>
<p>smoothing parameter lambda of the EWMA control chart.</p>
</td></tr>
<tr><td><code id="xewma.crit_+3A_l0">L0</code></td>
<td>
<p>in-control ARL.</p>
</td></tr>
<tr><td><code id="xewma.crit_+3A_mu0">mu0</code></td>
<td>
<p>in-control mean.</p>
</td></tr>
<tr><td><code id="xewma.crit_+3A_zr">zr</code></td>
<td>
<p>reflection border for the one-sided chart.</p>
</td></tr>
<tr><td><code id="xewma.crit_+3A_hs">hs</code></td>
<td>
<p>so-called headstart (enables fast initial response).</p>
</td></tr>
<tr><td><code id="xewma.crit_+3A_sided">sided</code></td>
<td>
<p>distinguishes between one- and two-sided
two-sided EWMA control chart by choosing <code>"one"</code> and <code>"two"</code>,
respectively.</p>
</td></tr>
<tr><td><code id="xewma.crit_+3A_limits">limits</code></td>
<td>
<p>distinguishes between different control limits behavior.</p>
</td></tr>
<tr><td><code id="xewma.crit_+3A_r">r</code></td>
<td>
<p>number of quadrature nodes, dimension of the resulting linear
equation system is equal to <code>r+1</code> (one-sided) or <code>r</code>
(two-sided).</p>
</td></tr>
<tr><td><code id="xewma.crit_+3A_c0">c0</code></td>
<td>
<p>starting value for iteration rule.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>xewma.crit</code> determines the critical values (similar to alarm limits)
for given in-control ARL <code>L0</code>
by applying secant rule and using <code>xewma.arl()</code>.
</p>


<h3>Value</h3>

<p>Returns a single value which resembles the critical value
<code>c</code>.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>S. V. Crowder (1989), Design of exponentially weighted moving average
schemes, <em>Journal of Quality Technology 21</em>, 155-162.
</p>


<h3>See Also</h3>

<p><code>xewma.arl</code> for zero-state ARL computation.</p>


<h3>Examples</h3>

<pre><code class='language-R'>l &lt;- .1
incontrolARL &lt;- c(500,5000,50000)
sapply(incontrolARL,l=l,sided="two",xewma.crit,r=35) # accuracy with 35 nodes
sapply(incontrolARL,l=l,sided="two",xewma.crit)      # accuracy with 40 nodes
sapply(incontrolARL,l=l,sided="two",xewma.crit,r=50) # accuracy with 50 nodes

## Crowder (1989)
## two-sided EWMA control charts with fixed limits

l &lt;- c(.05,.1,.15,.2,.25)
L0 &lt;- 250
round(sapply(l,L0=L0,sided="two",xewma.crit),digits=2)

## original values are 2.32, 2.55, 2.65, 2.72, and 2.76.
</code></pre>

<hr>
<h2 id='xewma.q'>Compute RL quantiles of EWMA control charts</h2><span id='topic+xewma.q'></span><span id='topic+xewma.q.crit'></span>

<h3>Description</h3>

<p>Computation of quantiles of the Run Length (RL)
for EWMA control charts monitoring normal mean.</p>


<h3>Usage</h3>

<pre><code class='language-R'>xewma.q(l, c, mu, alpha, zr=0, hs=0, sided="two", limits="fix", q=1, r=40)

xewma.q.crit(l, L0, mu, alpha, zr=0, hs=0, sided="two", limits="fix", r=40,
c.error=1e-12, a.error=1e-9, OUTPUT=FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xewma.q_+3A_l">l</code></td>
<td>
<p>smoothing parameter lambda of the EWMA control chart.</p>
</td></tr>
<tr><td><code id="xewma.q_+3A_c">c</code></td>
<td>
<p>critical value (similar to alarm limit) of the EWMA control chart.</p>
</td></tr>
<tr><td><code id="xewma.q_+3A_mu">mu</code></td>
<td>
<p>true mean.</p>
</td></tr>
<tr><td><code id="xewma.q_+3A_alpha">alpha</code></td>
<td>
<p>quantile level.</p>
</td></tr>
<tr><td><code id="xewma.q_+3A_zr">zr</code></td>
<td>
<p>reflection border for the one-sided chart.</p>
</td></tr>
<tr><td><code id="xewma.q_+3A_hs">hs</code></td>
<td>
<p>so-called headstart (enables fast initial response).</p>
</td></tr>
<tr><td><code id="xewma.q_+3A_sided">sided</code></td>
<td>
<p>distinguishes between one- and two-sided EWMA control chart 
by choosing <code>"one"</code> and <code>"two"</code>, respectively.</p>
</td></tr>
<tr><td><code id="xewma.q_+3A_limits">limits</code></td>
<td>
<p>distinguishes between different control limits behavior.</p>
</td></tr>
<tr><td><code id="xewma.q_+3A_q">q</code></td>
<td>
<p>change point position. For <code class="reqn">q=1</code> and
<code class="reqn">\mu=\mu_0</code> and <code class="reqn">\mu=\mu_1</code>, the usual
zero-state ARLs for the in-control and out-of-control case, respectively,
are calculated. For <code class="reqn">q&gt;1</code> and <code class="reqn">\mu!=0</code> conditional delays, that is,
<code class="reqn">E_q(L-q+1|L\geq)</code>, will be determined.
Note that mu0=0 is implicitely fixed.</p>
</td></tr>
<tr><td><code id="xewma.q_+3A_r">r</code></td>
<td>
<p>number of quadrature nodes, dimension of the resulting linear
equation system is equal to <code>r+1</code> (one-sided) or <code>r</code>
(two-sided).</p>
</td></tr>
<tr><td><code id="xewma.q_+3A_l0">L0</code></td>
<td>
<p>in-control quantile value.</p>
</td></tr>
<tr><td><code id="xewma.q_+3A_c.error">c.error</code></td>
<td>
<p>error bound for two succeeding values of the critical value
during applying the secant rule.</p>
</td></tr>
<tr><td><code id="xewma.q_+3A_a.error">a.error</code></td>
<td>
<p>error bound for the quantile level <code>alpha</code> during applying
the secant rule.</p>
</td></tr>
<tr><td><code id="xewma.q_+3A_output">OUTPUT</code></td>
<td>
<p>activate or deactivate additional output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Instead of the popular ARL (Average Run Length) quantiles of the EWMA
stopping time (Run Length) are determined. The algorithm is based on
Waldmann's survival function iteration procedure.
If <code>limits</code> is not <code>"fix"</code>, then the method presented
in Knoth (2003) is utilized.
Note that for one-sided EWMA charts (<code>sided</code>=<code>"one"</code>), only
<code>"vacl"</code> and <code>"stat"</code> are deployed, while for two-sided ones
(<code>sided</code>=<code>"two"</code>) also <code>"fir"</code>, <code>"both"</code>
(combination of <code>"fir"</code> and <code>"vacl"</code>), and <code>"Steiner"</code> are
implemented. For details see Knoth (2004).
</p>


<h3>Value</h3>

<p>Returns a single value which resembles the RL quantile of order <code>q</code>.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>F. F. Gan (1993),
An optimal design of EWMA control charts based on the median run length,
<em>J. Stat. Comput. Simulation 45</em>, 169-184.
</p>
<p>S. Knoth (2003),
EWMA schemes with non-homogeneous transition kernels,
<em>Sequential Analysis 22</em>, 241-255.
</p>
<p>S. Knoth (2004),
Fast initial response features for EWMA Control Charts,
<em>Statistical Papers 46</em>, 47-64.
</p>
<p>S. Knoth (2015),
Run length quantiles of EWMA control charts monitoring normal mean or/and variance,
<em>International Journal of Production Research 53</em>, 4629-4647.
</p>
<p>K.-H. Waldmann (1986),
Bounds for the distribution of the run length of geometric moving 
average charts, <em>Appl. Statist. 35</em>, 151-158.
</p>


<h3>See Also</h3>

<p><code>xewma.arl</code> for zero-state ARL computation of EWMA control charts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Gan (1993), two-sided EWMA with fixed control limits
## some values of his Table 1 -- any median RL should be 500
XEWMA.Q &lt;- Vectorize("xewma.q", c("l", "c"))
G.lambda &lt;- c(.05, .1, .15, .2, .25)
G.h &lt;- c(.441, .675, .863, 1.027, 1.177)
MEDIAN &lt;- ceiling(XEWMA.Q(G.lambda, G.h/sqrt(G.lambda/(2-G.lambda)),
0, .5, sided="two"))
print(cbind(G.lambda, MEDIAN))

## increase accuracy of thresholds

# (i) calculate threshold for given in-control median value by
#     deplyoing secant rule
XEWMA.q.crit &lt;- Vectorize("xewma.q.crit", "l")

# (ii) re-calculate the thresholds and remove the standardization step
L0 &lt;- 500
G.h.new &lt;- XEWMA.q.crit(G.lambda, L0, 0, .5, sided="two")
G.h.new &lt;- round(G.h.new * sqrt(G.lambda/(2-G.lambda)), digits=5)

# (iii) compare Gan's original values and the new ones with 5 digits
print(cbind(G.lambda, G.h.new, G.h))

# (iv) calculate the new medians
MEDIAN &lt;- ceiling(XEWMA.Q(G.lambda, G.h.new/sqrt(G.lambda/(2-G.lambda)),
0, .5, sided="two"))
print(cbind(G.lambda, MEDIAN))
</code></pre>

<hr>
<h2 id='xewma.q.prerun'>Compute RL quantiles of EWMA control charts in case of estimated parameters</h2><span id='topic+xewma.q.prerun'></span><span id='topic+xewma.q.crit.prerun'></span>

<h3>Description</h3>

<p>Computation of quantiles of the Run Length (RL)
for EWMA control charts monitoring normal mean
if the in-control mean, standard deviation, or both are estimated by a pre run.</p>


<h3>Usage</h3>

<pre><code class='language-R'>xewma.q.prerun(l, c, mu, p, zr=0, hs=0, sided="two", limits="fix", q=1, size=100,
df=NULL, estimated="mu", qm.mu=30, qm.sigma=30, truncate=1e-10, bound=1e-10)

xewma.q.crit.prerun(l, L0, mu, p, zr=0, hs=0, sided="two", limits="fix", size=100,
df=NULL, estimated="mu", qm.mu=30, qm.sigma=30, truncate=1e-10, bound=1e-10,
c.error=1e-10, p.error=1e-9, OUTPUT=FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xewma.q.prerun_+3A_l">l</code></td>
<td>
<p>smoothing parameter lambda of the EWMA control chart.</p>
</td></tr>
<tr><td><code id="xewma.q.prerun_+3A_c">c</code></td>
<td>
<p>critical value (similar to alarm limit) of the EWMA control chart.</p>
</td></tr>
<tr><td><code id="xewma.q.prerun_+3A_mu">mu</code></td>
<td>
<p>true mean shift.</p>
</td></tr>
<tr><td><code id="xewma.q.prerun_+3A_p">p</code></td>
<td>
<p>quantile level.</p>
</td></tr>
<tr><td><code id="xewma.q.prerun_+3A_zr">zr</code></td>
<td>
<p>reflection border for the one-sided chart.</p>
</td></tr>
<tr><td><code id="xewma.q.prerun_+3A_hs">hs</code></td>
<td>
<p>so-called headstart (give fast initial response).</p>
</td></tr>
<tr><td><code id="xewma.q.prerun_+3A_sided">sided</code></td>
<td>
<p>distinguish between one- and two-sided EWMA control chart 
by choosing <code>"one"</code> and <code>"two"</code>, respectively.</p>
</td></tr>
<tr><td><code id="xewma.q.prerun_+3A_limits">limits</code></td>
<td>
<p>distinguish between different control limits behavior.</p>
</td></tr>
<tr><td><code id="xewma.q.prerun_+3A_q">q</code></td>
<td>
<p>change point position. For <code class="reqn">q=1</code> and
<code class="reqn">\mu=\mu_0</code> and <code class="reqn">\mu=\mu_1</code>, the usual
zero-state ARLs for the in-control and out-of-control case, respectively,
are calculated. For <code class="reqn">q&gt;1</code> and <code class="reqn">\mu!=0</code> conditional delays, that is,
<code class="reqn">E_q(L-q+1|L\geq)</code>, will be determined.
Note that mu0=0 is implicitely fixed.</p>
</td></tr>
<tr><td><code id="xewma.q.prerun_+3A_size">size</code></td>
<td>
<p>pre run sample size.</p>
</td></tr>
<tr><td><code id="xewma.q.prerun_+3A_df">df</code></td>
<td>
<p>Degrees of freedom of the pre run variance estimator. Typically it is simply <code>size</code> - 1.
If the pre run is collected in batches, then also other values are needed.</p>
</td></tr>
<tr><td><code id="xewma.q.prerun_+3A_estimated">estimated</code></td>
<td>
<p>name the parameter to be estimated within the <code>"mu"</code>, <code>"sigma"</code>,
<code>"both"</code>.</p>
</td></tr>
<tr><td><code id="xewma.q.prerun_+3A_qm.mu">qm.mu</code></td>
<td>
<p>number of quadrature nodes for convoluting the mean uncertainty.</p>
</td></tr>
<tr><td><code id="xewma.q.prerun_+3A_qm.sigma">qm.sigma</code></td>
<td>
<p>number of quadrature nodes for convoluting the standard deviation uncertainty.</p>
</td></tr>
<tr><td><code id="xewma.q.prerun_+3A_truncate">truncate</code></td>
<td>
<p>size of truncated tail.</p>
</td></tr>
<tr><td><code id="xewma.q.prerun_+3A_bound">bound</code></td>
<td>
<p>control when the geometric tail kicks in; the larger the quicker and less accurate; <code>bound</code> should be larger than 0 and less than 0.001.</p>
</td></tr>
<tr><td><code id="xewma.q.prerun_+3A_l0">L0</code></td>
<td>
<p>in-control quantile value.</p>
</td></tr>
<tr><td><code id="xewma.q.prerun_+3A_c.error">c.error</code></td>
<td>
<p>error bound for two succeeding values of the critical value during
applying the secant rule.</p>
</td></tr>
<tr><td><code id="xewma.q.prerun_+3A_p.error">p.error</code></td>
<td>
<p>error bound for the quantile level <code>p</code> during applying the secant rule.</p>
</td></tr>
<tr><td><code id="xewma.q.prerun_+3A_output">OUTPUT</code></td>
<td>
<p>activate or deactivate additional output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Essentially, the ARL function <code>xewma.q</code> is convoluted with the
distribution of the sample mean, standard deviation or both.
For details see Jones/Champ/Rigdon (2001) and Knoth (2014?).
</p>


<h3>Value</h3>

<p>Returns a single value which resembles the RL quantile of order <code>q</code>.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>L. A. Jones, C. W. Champ, S. E. Rigdon (2001),
The performance of exponentially weighted moving average charts
with estimated parameters,
<em>Technometrics 43</em>, 156-167.
</p>
<p>S. Knoth (2003),
EWMA schemes with non-homogeneous transition kernels,
<em>Sequential Analysis 22</em>, 241-255.
</p>
<p>S. Knoth (2004),
Fast initial response features for EWMA Control Charts,
<em>Statistical Papers 46</em>, 47-64.
</p>
<p>S. Knoth (2014?),
tbd,
<em>tbd</em>, tbd-tbd.
</p>
<p>K.-H. Waldmann (1986),
Bounds for the distribution of the run length of geometric moving 
average charts, <em>Appl. Statist. 35</em>, 151-158.
</p>


<h3>See Also</h3>

<p><code>xewma.q</code> for the usual RL quantiles computation of EWMA control charts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Jones/Champ/Rigdon (2001)

c4m &lt;- function(m, n) sqrt(2)*gamma( (m*(n-1)+1)/2 )/sqrt( m*(n-1) )/gamma( m*(n-1)/2 )

n &lt;- 5 # sample size
m &lt;- 20 # pre run with 20 samples of size n = 5
C4m &lt;- c4m(m, n) # needed for bias correction

# Table 1, 3rd column
lambda &lt;- 0.2
L &lt;- 2.636

xewma.Q &lt;- Vectorize("xewma.q", "mu")
xewma.Q.prerun &lt;- Vectorize("xewma.q.prerun", "mu")

mu &lt;- c(0, .25, .5, 1, 1.5, 2)
Q1  &lt;- ceiling(xewma.Q(lambda, L, mu, 0.1, sided="two"))
Q2  &lt;- ceiling(xewma.Q(lambda, L, mu, 0.5, sided="two"))
Q3  &lt;- ceiling(xewma.Q(lambda, L, mu, 0.9, sided="two"))

cbind(mu, Q1, Q2, Q3)

## Not run: 
p.Q1 &lt;- xewma.Q.prerun(lambda, L/C4m, mu, 0.1, sided="two", 
size=m, df=m*(n-1), estimated="both")
p.Q2 &lt;- xewma.Q.prerun(lambda, L/C4m, mu, 0.5, sided="two",
size=m, df=m*(n-1), estimated="both")
p.Q3 &lt;- xewma.Q.prerun(lambda, L/C4m, mu, 0.9, sided="two",
size=m, df=m*(n-1), estimated="both")

cbind(mu, p.Q1, p.Q2, p.Q3)

## End(Not run)

## original values are
#    mu Q1  Q2  Q3 p.Q1 p.Q2 p.Q3
#  0.00 25 140 456   13   73  345
#  0.25 12  56 174    9   46  253
#  0.50  7  20  56    6   20  101
#  1.00  4   7  15    3    7   18
#  1.50  3   4   7    2    4    8
#  2.00  2   3   5    2    3    5
</code></pre>

<hr>
<h2 id='xewma.sf'>Compute the survival function of EWMA run length</h2><span id='topic+xewma.sf'></span>

<h3>Description</h3>

<p>Computation of the survival function of the Run Length (RL) for EWMA control charts monitoring normal mean.</p>


<h3>Usage</h3>

<pre><code class='language-R'>xewma.sf(l, c, mu, n, zr=0, hs=0, sided="one", limits="fix", q=1, r=40)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xewma.sf_+3A_l">l</code></td>
<td>
<p>smoothing parameter lambda of the EWMA control chart.</p>
</td></tr>
<tr><td><code id="xewma.sf_+3A_c">c</code></td>
<td>
<p>critical value (similar to alarm limit) of the EWMA control chart.</p>
</td></tr>
<tr><td><code id="xewma.sf_+3A_mu">mu</code></td>
<td>
<p>true mean.</p>
</td></tr>
<tr><td><code id="xewma.sf_+3A_n">n</code></td>
<td>
<p>calculate sf up to value <code>n</code>.</p>
</td></tr>
<tr><td><code id="xewma.sf_+3A_zr">zr</code></td>
<td>
<p>reflection border for the one-sided chart.</p>
</td></tr>
<tr><td><code id="xewma.sf_+3A_hs">hs</code></td>
<td>
<p>so-called headstart (enables fast initial response).</p>
</td></tr>
<tr><td><code id="xewma.sf_+3A_sided">sided</code></td>
<td>
<p>distinguishes between one- and two-sided EWMA control chart 
by choosing <code>"one"</code> and <code>"two"</code>, respectively.</p>
</td></tr>
<tr><td><code id="xewma.sf_+3A_limits">limits</code></td>
<td>
<p>distinguishes between different control limits behavior.</p>
</td></tr>
<tr><td><code id="xewma.sf_+3A_q">q</code></td>
<td>
<p>change point position. For <code class="reqn">q=1</code> and
<code class="reqn">\mu=\mu_0</code> and <code class="reqn">\mu=\mu_1</code>, the usual
zero-state situation for the in-control and out-of-control case, respectively,
are calculated. Note that mu0=0 is implicitely fixed.</p>
</td></tr>
<tr><td><code id="xewma.sf_+3A_r">r</code></td>
<td>
<p>number of quadrature nodes, dimension of the resulting linear
equation system is equal to <code>r+1</code> (one-sided) or <code>r</code> (two-sided).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The survival function P(L&gt;n) and derived from it also the cdf P(L&lt;=n) and the pmf P(L=n) illustrate
the distribution of the EWMA run length. For large n the geometric tail could be exploited. That is,
with reasonable large n the complete distribution is characterized.
The algorithm is based on Waldmann's survival function iteration procedure.
For varying limits and for change points after 1 the algorithm from Knoth (2004) is applied.
Note that for one-sided EWMA charts (<code>sided</code>=<code>"one"</code>), only
<code>"vacl"</code> and <code>"stat"</code> are deployed, while for two-sided ones
(<code>sided</code>=<code>"two"</code>) also <code>"fir"</code>, <code>"both"</code>
(combination of <code>"fir"</code> and <code>"vacl"</code>), and <code>"Steiner"</code> are implemented.
For details see Knoth (2004).
</p>


<h3>Value</h3>

<p>Returns a vector which resembles the survival function up to a certain point.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>F. F. Gan (1993),
An optimal design of EWMA control charts based on the median run length,
<em>J. Stat. Comput. Simulation 45</em>, 169-184.
</p>
<p>S. Knoth (2003),
EWMA schemes with non-homogeneous transition kernels,
<em>Sequential Analysis 22</em>, 241-255.
</p>
<p>S. Knoth (2004),
Fast initial response features for EWMA Control Charts,
<em>Statistical Papers 46</em>, 47-64.
</p>
<p>K.-H. Waldmann (1986),
Bounds for the distribution of the run length of geometric moving 
average charts, <em>Appl. Statist. 35</em>, 151-158.
</p>


<h3>See Also</h3>

<p><code>xewma.arl</code> for zero-state ARL computation of EWMA control charts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Gan (1993), two-sided EWMA with fixed control limits
## some values of his Table 1 -- any median RL should be 500

G.lambda &lt;- c(.05, .1, .15, .2, .25)
G.h &lt;- c(.441, .675, .863, 1.027, 1.177)/sqrt(G.lambda/(2-G.lambda))

for ( i in 1:length(G.lambda) ) {
  SF &lt;- xewma.sf(G.lambda[i], G.h[i], 0, 1000)
  if (i==1) plot(1:length(SF), SF, type="l", xlab="n", ylab="P(L&gt;n)")
  else lines(1:length(SF), SF, col=i)
}
</code></pre>

<hr>
<h2 id='xewma.sf.prerun'>Compute the survival function of EWMA run length in case of estimated parameters</h2><span id='topic+xewma.sf.prerun'></span>

<h3>Description</h3>

<p>Computation of the survival function of the Run Length (RL) for EWMA
control charts monitoring normal mean
if the in-control mean, standard deviation, or both are estimated by a pre run.</p>


<h3>Usage</h3>

<pre><code class='language-R'>xewma.sf.prerun(l, c, mu, n, zr=0, hs=0, sided="one", limits="fix", q=1,
size=100, df=NULL, estimated="mu", qm.mu=30, qm.sigma=30,
truncate=1e-10, tail_approx=TRUE, bound=1e-10)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xewma.sf.prerun_+3A_l">l</code></td>
<td>
<p>smoothing parameter lambda of the EWMA control chart.</p>
</td></tr>
<tr><td><code id="xewma.sf.prerun_+3A_c">c</code></td>
<td>
<p>critical value (similar to alarm limit) of the EWMA control chart.</p>
</td></tr>
<tr><td><code id="xewma.sf.prerun_+3A_mu">mu</code></td>
<td>
<p>true mean.</p>
</td></tr>
<tr><td><code id="xewma.sf.prerun_+3A_n">n</code></td>
<td>
<p>calculate sf up to value <code>n</code>.</p>
</td></tr>
<tr><td><code id="xewma.sf.prerun_+3A_zr">zr</code></td>
<td>
<p>reflection border for the one-sided chart.</p>
</td></tr>
<tr><td><code id="xewma.sf.prerun_+3A_hs">hs</code></td>
<td>
<p>so-called headstart (give fast initial response).</p>
</td></tr>
<tr><td><code id="xewma.sf.prerun_+3A_sided">sided</code></td>
<td>
<p>distinguish between one- and two-sided EWMA control chart 
by choosing <code>"one"</code> and <code>"two"</code>, respectively.</p>
</td></tr>
<tr><td><code id="xewma.sf.prerun_+3A_limits">limits</code></td>
<td>
<p>distinguish between different control limits behavior.</p>
</td></tr>
<tr><td><code id="xewma.sf.prerun_+3A_q">q</code></td>
<td>
<p>change point position. For <code class="reqn">q=1</code> and
<code class="reqn">\mu=\mu_0</code> and <code class="reqn">\mu=\mu_1</code>, the usual
zero-state situation for the in-control and out-of-control case, respectively,
are calculated. Note that mu0=0 is implicitely fixed.</p>
</td></tr>
<tr><td><code id="xewma.sf.prerun_+3A_size">size</code></td>
<td>
<p>pre run sample size.</p>
</td></tr>
<tr><td><code id="xewma.sf.prerun_+3A_df">df</code></td>
<td>
<p>degrees of freedom of the pre run variance estimator. Typically it is simply <code>size</code> - 1.
If the pre run is collected in batches, then also other
values are needed.</p>
</td></tr>
<tr><td><code id="xewma.sf.prerun_+3A_estimated">estimated</code></td>
<td>
<p>name the parameter to be estimated within the <code>"mu"</code>,
<code>"sigma"</code>, <code>"both"</code>.</p>
</td></tr>
<tr><td><code id="xewma.sf.prerun_+3A_qm.mu">qm.mu</code></td>
<td>
<p>number of quadrature nodes for convoluting the mean uncertainty.</p>
</td></tr>
<tr><td><code id="xewma.sf.prerun_+3A_qm.sigma">qm.sigma</code></td>
<td>
<p>number of quadrature nodes for convoluting the standard deviation uncertainty.</p>
</td></tr>
<tr><td><code id="xewma.sf.prerun_+3A_truncate">truncate</code></td>
<td>
<p>size of truncated tail.</p>
</td></tr>
<tr><td><code id="xewma.sf.prerun_+3A_tail_approx">tail_approx</code></td>
<td>
<p>Controls whether the geometric tail approximation is used (is faster) or not.</p>
</td></tr>
<tr><td><code id="xewma.sf.prerun_+3A_bound">bound</code></td>
<td>
<p>control when the geometric tail kicks in; the larger the quicker and less accurate; <code>bound</code> should be larger than 0 and less than 0.001.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The survival function P(L&gt;n) and derived from it also the cdf P(L&lt;=n) and
the pmf P(L=n) illustrate the distribution of the EWMA run length...
</p>


<h3>Value</h3>

<p>Returns a vector which resembles the survival function up to a certain point.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>F. F. Gan (1993),
An optimal design of EWMA control charts based on the median run length,
<em>J. Stat. Comput. Simulation 45</em>, 169-184.
</p>
<p>S. Knoth (2003),
EWMA schemes with non-homogeneous transition kernels,
<em>Sequential Analysis 22</em>, 241-255.
</p>
<p>S. Knoth (2004),
Fast initial response features for EWMA Control Charts,
<em>Statistical Papers 46</em>, 47-64.
</p>
<p>L. A. Jones, C. W. Champ, S. E. Rigdon (2001),
The performance of exponentially weighted moving average charts
with estimated parameters,
<em>Technometrics 43</em>, 156-167.
</p>
<p>K.-H. Waldmann (1986),
Bounds for the distribution of the run length of geometric moving 
average charts, <em>Appl. Statist. 35</em>, 151-158.
</p>


<h3>See Also</h3>

<p><code>xewma.sf</code> for the RL survival function of EWMA control charts
w/o pre run uncertainty.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Jones/Champ/Rigdon (2001)

c4m &lt;- function(m, n) sqrt(2)*gamma( (m*(n-1)+1)/2 )/sqrt( m*(n-1) )/gamma( m*(n-1)/2 )

n &lt;- 5 # sample size

# Figure 6, subfigure r=0.1
lambda &lt;- 0.1
L &lt;- 2.454

CDF0 &lt;- 1 - xewma.sf(lambda, L, 0, 600, sided="two")
m &lt;- 10 # pre run size
CDF1 &lt;- 1 - xewma.sf.prerun(lambda, L/c4m(m,n), 0, 600, sided="two",
size=m, df=m*(n-1), estimated="both")
m &lt;- 20
CDF2 &lt;- 1 - xewma.sf.prerun(lambda, L/c4m(m,n), 0, 600, sided="two",
size=m, df=m*(n-1), estimated="both")
m &lt;- 50
CDF3 &lt;- 1 - xewma.sf.prerun(lambda, L/c4m(m,n), 0, 600, sided="two",
size=m, df=m*(n-1), estimated="both")

plot(CDF0, type="l", xlab="t", ylab=expression(P(T&lt;=t)), xlim=c(0,500), ylim=c(0,1))
abline(v=0, h=c(0,1), col="grey", lwd=.7)
points((1:5)*100, CDF0[(1:5)*100], pch=18)
lines(CDF1, col="blue")
points((1:5)*100, CDF1[(1:5)*100], pch=2, col="blue")
lines(CDF2, col="red")
points((1:5)*100, CDF2[(1:5)*100], pch=16, col="red")
lines(CDF3, col="green")
points((1:5)*100, CDF3[(1:5)*100], pch=5, col="green")

legend("bottomright", c("Known", "m=10, n=5", "m=20, n=5", "m=50, n=5"),
       col=c("black", "blue", "red", "green"), pch=c(18, 2, 16, 5), lty=1)
</code></pre>

<hr>
<h2 id='xgrsr.ad'>Compute steady-state ARLs of Shiryaev-Roberts schemes</h2><span id='topic+xgrsr.ad'></span>

<h3>Description</h3>

<p>Computation of the steady-state Average Run Length (ARL)
for Shiryaev-Roberts schemes monitoring normal mean.</p>


<h3>Usage</h3>

<pre><code class='language-R'>xgrsr.ad(k, g, mu1, mu0 = 0, zr = 0, sided = "one", MPT = FALSE, r = 30)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xgrsr.ad_+3A_k">k</code></td>
<td>
<p>reference value of the Shiryaev-Roberts scheme.</p>
</td></tr>
<tr><td><code id="xgrsr.ad_+3A_g">g</code></td>
<td>
<p>control limit (alarm threshold) of Shiryaev-Roberts scheme.</p>
</td></tr>
<tr><td><code id="xgrsr.ad_+3A_mu1">mu1</code></td>
<td>
<p>out-of-control mean.</p>
</td></tr>
<tr><td><code id="xgrsr.ad_+3A_mu0">mu0</code></td>
<td>
<p>in-control mean.</p>
</td></tr>
<tr><td><code id="xgrsr.ad_+3A_zr">zr</code></td>
<td>
<p>reflection border to enable the numerical algorithms used here.</p>
</td></tr>
<tr><td><code id="xgrsr.ad_+3A_sided">sided</code></td>
<td>
<p>distinguishes between one- and two-sided schemes by choosing 
<code>"one"</code> and<code>"two"</code>, respectively. Currently only one-sided schemes are
implemented.</p>
</td></tr>
<tr><td><code id="xgrsr.ad_+3A_mpt">MPT</code></td>
<td>
<p>switch between the old implementation (<code>FALSE</code>) and the new one (<code>TRUE</code>) that considers the completed
likelihood ratio. MPT contains the initials of G. Moustakides, A. Polunchenko and A. Tartakovsky.</p>
</td></tr>
<tr><td><code id="xgrsr.ad_+3A_r">r</code></td>
<td>
<p>number of quadrature nodes, dimension of the resulting linear
equation system is equal to <code>r+1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>xgrsr.ad</code> determines the steady-state Average Run Length (ARL) by numerically
solving the related ARL integral equation by means of the Nystroem method
based on Gauss-Legendre quadrature.
</p>


<h3>Value</h3>

<p>Returns a single value which resembles the steady-state ARL.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>S. Knoth (2006),
The art of evaluating monitoring schemes &ndash;
how to measure the performance of control charts?
S. Lenz, H. &amp; Wilrich, P. (ed.),
<em>Frontiers in Statistical Quality Control 8</em>, Physica Verlag, Heidelberg, Germany, 74-99.
</p>
<p>G. Moustakides, A. Polunchenko, A. Tartakovsky (2009),
Numerical comparison of CUSUM and Shiryaev-Roberts procedures for
detectin changes in distributions,
<em>Communications in Statistics: Theory and Methods 38</em>, 3225-3239.
</p>


<h3>See Also</h3>

<p><code>xewma.arl</code> and <code>xcusum-arl</code> for zero-state ARL computation of EWMA and CUSUM control charts,
respectively, and <code>xgrsr.arl</code> for the zero-state ARL.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Small study to identify appropriate reflection border to mimic unreflected schemes
k &lt;- .5
g &lt;- log(390)
zrs &lt;- -(0:10)
ZRxgrsr.ad &lt;- Vectorize(xgrsr.ad, "zr")
ads &lt;- ZRxgrsr.ad(k, g, 0, zr=zrs)
data.frame(zrs, ads)

## Table 2 from Knoth (2006)
## original values are
#  mu   arl
#  0    689
#  0.5  30
#  1    8.9
#  1.5  5.1
#  2    3.6
#  2.5  2.8
#  3    2.4
#
k &lt;- .5
g &lt;- log(390)
zr &lt;- -5 # see first example
mus &lt;- (0:6)/2
Mxgrsr.ad &lt;- Vectorize(xgrsr.ad, "mu1")
ads &lt;- round(Mxgrsr.ad(k, g, mus, zr=zr), digits=1)
data.frame(mus, ads)

## Table 4 from Moustakides et al. (2009)
## original values are
# gamma  A        STADD/steady-state ARL
# 50     28.02    4.37
# 100    56.04    5.46
# 500    280.19   8.33
# 1000   560.37   9.64
# 5000   2801.75  12.79
# 10000  5603.7   14.17
Gxgrsr.ad  &lt;- Vectorize("xgrsr.ad", "g")
As &lt;- c(28.02, 56.04, 280.19, 560.37, 2801.75, 5603.7)
gs &lt;- log(As)
theta &lt;- 1
zr &lt;- -6
ads &lt;- round(Gxgrsr.ad(theta/2, gs, theta, zr=zr, r=100), digits=2)
data.frame(As, ads)
</code></pre>

<hr>
<h2 id='xgrsr.arl'>Compute (zero-state) ARLs of Shiryaev-Roberts schemes</h2><span id='topic+xgrsr.arl'></span>

<h3>Description</h3>

<p>Computation of the (zero-state) Average Run Length (ARL)
for Shiryaev-Roberts schemes monitoring normal mean.</p>


<h3>Usage</h3>

<pre><code class='language-R'>xgrsr.arl(k, g, mu, zr = 0, hs=NULL, sided = "one", q = 1, MPT = FALSE, r = 30)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xgrsr.arl_+3A_k">k</code></td>
<td>
<p>reference value of the Shiryaev-Roberts scheme.</p>
</td></tr>
<tr><td><code id="xgrsr.arl_+3A_g">g</code></td>
<td>
<p>control limit (alarm threshold) of Shiryaev-Roberts scheme.</p>
</td></tr>
<tr><td><code id="xgrsr.arl_+3A_mu">mu</code></td>
<td>
<p>true mean.</p>
</td></tr>
<tr><td><code id="xgrsr.arl_+3A_zr">zr</code></td>
<td>
<p>reflection border to enable the numerical algorithms used here.</p>
</td></tr>
<tr><td><code id="xgrsr.arl_+3A_hs">hs</code></td>
<td>
<p>so-called headstart (enables fast initial response). If <code>hs=NULL</code>, then
the classical headstart -Inf is used (corresponds to 0 for the non-log scheme).</p>
</td></tr>
<tr><td><code id="xgrsr.arl_+3A_sided">sided</code></td>
<td>
<p>distinguishes between one- and two-sided schemes by choosing 
<code>"one"</code> and<code>"two"</code>, respectively. Currently only one-sided schemes are
implemented.</p>
</td></tr>
<tr><td><code id="xgrsr.arl_+3A_q">q</code></td>
<td>
<p>change point position. For <code class="reqn">q=1</code> and
<code class="reqn">\mu=\mu_0</code> and <code class="reqn">\mu=\mu_1</code>, the usual
zero-state ARLs for the in-control and out-of-control case, respectively,
are calculated. For <code class="reqn">q&gt;1</code> and <code class="reqn">\mu!=0</code> conditional delays, that is,
<code class="reqn">E_q(L-q+1|L\ge q)</code>, will be determined.
Note that mu0=0 is implicitely fixed.</p>
</td></tr>
<tr><td><code id="xgrsr.arl_+3A_mpt">MPT</code></td>
<td>
<p>switch between the old implementation (<code>FALSE</code>) and the new one (<code>TRUE</code>) that considers the complete
likelihood ratio. MPT stands for the initials of G. Moustakides, A. Polunchenko and A. Tartakovsky.</p>
</td></tr>
<tr><td><code id="xgrsr.arl_+3A_r">r</code></td>
<td>
<p>number of quadrature nodes, dimension of the resulting linear
equation system is equal to <code>r+1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>xgrsr.arl</code> determines the Average Run Length (ARL) by numerically
solving the related ARL integral equation by means of the Nystroem method
based on Gauss-Legendre quadrature.
</p>


<h3>Value</h3>

<p>Returns a vector of length <code>q</code> which resembles the ARL and the sequence of conditional expected delays for
<code>q</code>=1 and <code>q</code>&gt;1, respectively.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>S. Knoth (2006),
The art of evaluating monitoring schemes &ndash;
how to measure the performance of control charts?
S. Lenz, H. &amp; Wilrich, P. (ed.),
<em>Frontiers in Statistical Quality Control 8</em>, Physica Verlag, Heidelberg, Germany, 74-99.
</p>
<p>G. Moustakides, A. Polunchenko, A. Tartakovsky (2009),
Numerical comparison of CUSUM and Shiryaev-Roberts procedures for detecting changes in distributions,
<em>Communications in Statistics: Theory and Methods 38</em>, 3225-3239.
</p>


<h3>See Also</h3>

<p><code>xewma.arl</code> and <code>xcusum-arl</code> for zero-state ARL computation of EWMA and CUSUM control charts,
respectively, and <code>xgrsr.ad</code> for the steady-state ARL.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Small study to identify appropriate reflection border to mimic unreflected schemes
k &lt;- .5
g &lt;- log(390)
zrs &lt;- -(0:10)
ZRxgrsr.arl &lt;- Vectorize(xgrsr.arl, "zr")
arls &lt;- ZRxgrsr.arl(k, g, 0, zr=zrs)
data.frame(zrs, arls)

## Table 2 from Knoth (2006)
## original values are
#  mu   arl
#  0    697
#  0.5  33
#  1    10.4
#  1.5  6.2
#  2    4.4
#  2.5  3.5
#  3    2.9
#
k &lt;- .5
g &lt;- log(390)
zr &lt;- -5 # see first example
mus &lt;- (0:6)/2
Mxgrsr.arl &lt;- Vectorize(xgrsr.arl, "mu")
arls &lt;- round(Mxgrsr.arl(k, g, mus, zr=zr), digits=1)
data.frame(mus, arls)

XGRSR.arl  &lt;- Vectorize("xgrsr.arl", "g")
zr &lt;- -6

## Table 2 from Moustakides et al. (2009)
## original values are
# gamma   A     ARL/E_infty(L) SADD/E_1(L)
#   50   47.17      50.29        41.40
#  100   94.34     100.28        72.32
#  500  471.70     500.28       209.44
# 1000  943.41    1000.28       298.50
# 5000 4717.04    5000.24       557.87
#10000 9434.08   10000.17       684.17

theta &lt;- .1
As2 &lt;- c(47.17, 94.34, 471.7, 943.41, 4717.04, 9434.08)
gs2 &lt;- log(As2)
arls0 &lt;- round(XGRSR.arl(theta/2, gs2, 0, zr=-5, r=300, MPT=TRUE), digits=2)
arls1 &lt;- round(XGRSR.arl(theta/2, gs2, theta, zr=-5, r=300, MPT=TRUE), digits=2)
data.frame(As2, arls0, arls1)

## Table 3 from Moustakides et al. (2009)
## original values are
# gamma   A     ARL/E_infty(L) SADD/E_1(L)
#   50   37.38      49.45        12.30
#  100   74.76      99.45        16.60
#  500  373.81     499.45        28.05
# 1000  747.62     999.45        33.33
# 5000 3738.08    4999.45        45.96
#10000 7476.15    9999.24        51.49

theta &lt;- .5
As3 &lt;- c(37.38, 74.76, 373.81, 747.62, 3738.08, 7476.15)
gs3 &lt;- log(As3)
arls0 &lt;- round(XGRSR.arl(theta/2, gs3, 0, zr=-5, r=70, MPT=TRUE), digits=2)
arls1 &lt;- round(XGRSR.arl(theta/2, gs3, theta, zr=-5, r=70, MPT=TRUE), digits=2)
data.frame(As3, arls0, arls1)

## Table 4 from Moustakides et al. (2009)
## original values are
# gamma   A     ARL/E_infty(L) SADD/E_1(L)
#   50   28.02      49.78         4.98
#  100   56.04      99.79         6.22
#  500  280.19     499.79         9.30
# 1000  560.37     999.79        10.66
# 5000 2801.85    5000.93        13.86
#10000 5603.70    9999.87        15.24

theta &lt;- 1
As4 &lt;- c(28.02, 56.04, 280.19, 560.37, 2801.85, 5603.7)
gs4 &lt;- log(As4)
arls0 &lt;- round(XGRSR.arl(theta/2, gs4, 0, zr=-6, r=40, MPT=TRUE), digits=2)
arls1 &lt;- round(XGRSR.arl(theta/2, gs4, theta, zr=-6, r=40, MPT=TRUE), digits=2)
data.frame(As4, arls0, arls1)
</code></pre>

<hr>
<h2 id='xgrsr.crit'>Compute alarm thresholds for Shiryaev-Roberts schemes</h2><span id='topic+xgrsr.crit'></span>

<h3>Description</h3>

<p>Computation of the alarm thresholds (alarm limits)
for Shiryaev-Roberts schemes monitoring normal mean.</p>


<h3>Usage</h3>

<pre><code class='language-R'>xgrsr.crit(k, L0, mu0 = 0, zr = 0, hs = NULL, sided = "one", MPT = FALSE, r = 30)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xgrsr.crit_+3A_k">k</code></td>
<td>
<p>reference value of the Shiryaev-Roberts scheme.</p>
</td></tr>
<tr><td><code id="xgrsr.crit_+3A_l0">L0</code></td>
<td>
<p>in-control ARL.</p>
</td></tr>
<tr><td><code id="xgrsr.crit_+3A_mu0">mu0</code></td>
<td>
<p>in-control mean.</p>
</td></tr>
<tr><td><code id="xgrsr.crit_+3A_zr">zr</code></td>
<td>
<p>reflection border to enable the numerical algorithms used here.</p>
</td></tr>
<tr><td><code id="xgrsr.crit_+3A_hs">hs</code></td>
<td>
<p>so-called headstart (enables fast initial response). If <code>hs=NULL</code>, then
the classical headstart -Inf is used (corresponds to 0 for the non-log scheme).</p>
</td></tr>
<tr><td><code id="xgrsr.crit_+3A_sided">sided</code></td>
<td>
<p>distinguishes between one- and two-sided schemes by choosing 
<code>"one"</code> and<code>"two"</code>, respectively. Currently only one-sided schemes are
implemented.</p>
</td></tr>
<tr><td><code id="xgrsr.crit_+3A_mpt">MPT</code></td>
<td>
<p>switch between the old implementation (<code>FALSE</code>) and the new one (<code>TRUE</code>) that considers the completed
likelihood ratio. MPT contains the initials of G. Moustakides, A. Polunchenko and A. Tartakovsky.</p>
</td></tr>
<tr><td><code id="xgrsr.crit_+3A_r">r</code></td>
<td>
<p>number of quadrature nodes, dimension of the resulting linear
equation system is equal to <code>r+1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>xgrsr.crit</code> determines the alarm threshold (alarm limit)
for given in-control ARL <code>L0</code>
by applying secant rule and using <code>xgrsr.arl()</code>.
</p>


<h3>Value</h3>

<p>Returns a single value which resembles the alarm limit <code>g</code>.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>G. Moustakides, A. Polunchenko, A. Tartakovsky (2009),
Numerical comparison of CUSUM and Shiryaev-Roberts procedures for detecting changes in distributions,
<em>Communications in Statistics: Theory and Methods 38</em>, 3225-3239.r.
</p>


<h3>See Also</h3>

<p><code>xgrsr.arl</code> for zero-state ARL computation.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Table 4 from Moustakides et al. (2009)
## original values are
# gamma/L0  A/exp(g)
# 50        28.02
# 100       56.04
# 500       280.19
# 1000      560.37
# 5000      2801.75
# 10000     5603.7
theta &lt;- 1
zr &lt;- -6
r &lt;- 100
Lxgrsr.crit  &lt;- Vectorize("xgrsr.crit", "L0")
L0s &lt;- c(50, 100, 500, 1000, 5000, 10000)
gs &lt;- Lxgrsr.crit(theta/2, L0s, zr=zr, r=r)
data.frame(L0s, gs, A=round(exp(gs), digits=2))
</code></pre>

<hr>
<h2 id='xsewma.arl'>Compute ARLs of simultaneous EWMA control charts (mean and variance charts)</h2><span id='topic+xsewma.arl'></span>

<h3>Description</h3>

<p>Computation of the (zero-state) Average Run Length (ARL)
for different types of simultaneous EWMA control charts 
(based on the sample mean and the sample variance <code class="reqn">S^2</code>)
monitoring normal mean and variance.</p>


<h3>Usage</h3>

<pre><code class='language-R'>xsewma.arl(lx, cx, ls, csu, df, mu, sigma, hsx=0, Nx=40, csl=0,
hss=1, Ns=40, s2.on=TRUE, sided="upper", qm=30)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xsewma.arl_+3A_lx">lx</code></td>
<td>
<p>smoothing parameter lambda of the two-sided mean EWMA chart.</p>
</td></tr>
<tr><td><code id="xsewma.arl_+3A_cx">cx</code></td>
<td>
<p>control limit of the two-sided mean EWMA control chart.</p>
</td></tr>
<tr><td><code id="xsewma.arl_+3A_ls">ls</code></td>
<td>
<p>smoothing parameter lambda of the variance EWMA chart.</p>
</td></tr>
<tr><td><code id="xsewma.arl_+3A_csu">csu</code></td>
<td>
<p>upper control limit of the variance EWMA control chart.</p>
</td></tr>
<tr><td><code id="xsewma.arl_+3A_df">df</code></td>
<td>
<p>actual degrees of freedom, corresponds to subgroup size (for known mean
it is equal to the subgroup size,
for unknown mean it is equal to subgroup size minus one.</p>
</td></tr>
<tr><td><code id="xsewma.arl_+3A_mu">mu</code></td>
<td>
<p>true mean.</p>
</td></tr>
<tr><td><code id="xsewma.arl_+3A_sigma">sigma</code></td>
<td>
<p>true standard deviation.</p>
</td></tr>
<tr><td><code id="xsewma.arl_+3A_hsx">hsx</code></td>
<td>
<p>so-called headstart (enables fast initial response) of the mean chart &ndash; 
do not confuse with the true FIR feature considered in xewma.arl; will be updated.</p>
</td></tr>
<tr><td><code id="xsewma.arl_+3A_nx">Nx</code></td>
<td>
<p>dimension of the approximating matrix of the mean chart.</p>
</td></tr>
<tr><td><code id="xsewma.arl_+3A_csl">csl</code></td>
<td>
<p>lower control limit of the variance EWMA control chart; default value is 0;
not considered if <code>sided</code> is <code>"upper"</code>.</p>
</td></tr>
<tr><td><code id="xsewma.arl_+3A_hss">hss</code></td>
<td>
<p>headstart (enables fast initial response) of the variance chart.</p>
</td></tr>
<tr><td><code id="xsewma.arl_+3A_ns">Ns</code></td>
<td>
<p>dimension of the approximating matrix of the variance chart.</p>
</td></tr>
<tr><td><code id="xsewma.arl_+3A_s2.on">s2.on</code></td>
<td>
<p>distinguishes between <code class="reqn">S^2</code> and <code class="reqn">S</code> chart.</p>
</td></tr>
<tr><td><code id="xsewma.arl_+3A_sided">sided</code></td>
<td>
<p>distinguishes between one- and two-sided two-sided EWMA-<code class="reqn">S^2</code>
control charts by choosing <code>"upper"</code> (upper chart without reflection at <code>cl</code>
&ndash; the actual value of <code>cl</code> is not used), <code>"Rupper"</code> (upper chart with
reflection at <code>cl</code>),
<code>"Rlower"</code> (lower chart with reflection at <code>cu</code>), and <code>"two"</code>
(two-sided chart), respectively.</p>
</td></tr> 
<tr><td><code id="xsewma.arl_+3A_qm">qm</code></td>
<td>
<p>number of quadrature nodes used for the collocation integrals.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>xsewma.arl</code> determines the Average Run Length (ARL) by 
an extension of Gan's (derived from ideas already published by Waldmann)
algorithm. The variance EWMA part is treated
similarly to the ARL calculation method
deployed for the single variance EWMA charts in Knoth (2005), that is, by means of 
collocation (Chebyshev polynomials). For more details see Knoth (2007).</p>


<h3>Value</h3>

<p>Returns a single value which resembles the ARL.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>K. Waldmann (1986),
Bounds for the distribution of the run length of geometric moving average charts,
<em>J. R. Stat. Soc., Ser. C, Appl. Stat. 35</em>, 151-158.
</p>
<p>F. F. Gan (1995),
Joint monitoring of process mean and variance using exponentially weighted moving
average control charts,
<em>Technometrics 37</em>, 446-453.
</p>
<p>S. Knoth (2005),
Accurate ARL computation for EWMA-<code class="reqn">S^2</code> control charts,
<em>Statistics and Computing 15</em>, 341-352.
</p>
<p>S. Knoth (2007),
Accurate ARL calculation for EWMA control charts monitoring simultaneously normal
mean and variance,
<em>Sequential Analysis 26</em>, 251-264.
</p>


<h3>See Also</h3>

<p><code>xewma.arl</code> and <code>sewma.arl</code> for zero-state ARL computation of
single mean and variance EWMA control charts, respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Knoth (2007)
## collocation results in Table 1
## Monte Carlo with 10^9 replicates: 252.307 +/- 0.0078

# process parameters
mu &lt;- 0
sigma &lt;- 1
# subgroup size n=5, df=n-1
df  &lt;- 4
# lambda of mean chart
lx  &lt;- .134
# c_mu^* = .345476571 = cx/sqrt(n) * sqrt(lx/(2-lx)
cx  &lt;- .345476571*sqrt(df+1)/sqrt(lx/(2-lx))
# lambda of variance chart
ls  &lt;- .1
# c_sigma = .477977
csu &lt;- 1 + .477977
# matrix dimensions for mean and variance part
Nx  &lt;- 25
Ns  &lt;- 25
# mode of variance chart
SIDED &lt;- "upper"

arl &lt;- xsewma.arl(lx, cx, ls, csu, df, mu, sigma, Nx=Nx, Ns=Ns, sided=SIDED)
arl
</code></pre>

<hr>
<h2 id='xsewma.crit'>Compute critical values of simultaneous EWMA control charts (mean and variance charts)</h2><span id='topic+xsewma.crit'></span>

<h3>Description</h3>

<p>Computation of the critical values (similar to alarm limits)
for different types of simultaneous EWMA control charts 
(based on the sample mean and the sample variance <code class="reqn">S^2</code>)
monitoring normal mean and variance.</p>


<h3>Usage</h3>

<pre><code class='language-R'>xsewma.crit(lx, ls, L0, df, mu0=0, sigma0=1, cu=NULL, hsx=0,
hss=1, s2.on=TRUE, sided="upper", mode="fixed", Nx=30, Ns=40, qm=30)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xsewma.crit_+3A_lx">lx</code></td>
<td>
<p>smoothing parameter lambda of the two-sided mean EWMA chart.</p>
</td></tr>
<tr><td><code id="xsewma.crit_+3A_ls">ls</code></td>
<td>
<p>smoothing parameter lambda of the variance EWMA chart.</p>
</td></tr>
<tr><td><code id="xsewma.crit_+3A_l0">L0</code></td>
<td>
<p>in-control ARL.</p>
</td></tr>
<tr><td><code id="xsewma.crit_+3A_mu0">mu0</code></td>
<td>
<p>in-control mean.</p>
</td></tr>
<tr><td><code id="xsewma.crit_+3A_sigma0">sigma0</code></td>
<td>
<p>in-control standard deviation.</p>
</td></tr>
<tr><td><code id="xsewma.crit_+3A_cu">cu</code></td>
<td>
<p>for two-sided (<code>sided</code>=<code>"two"</code>) and fixed upper
control limit (<code>mode</code>=<code>"fixed"</code>) a value larger than <code>sigma0</code>
has to been given, for all other cases <code>cu</code> is ignored.</p>
</td></tr>
<tr><td><code id="xsewma.crit_+3A_hsx">hsx</code></td>
<td>
<p>so-called headstart (enables fast initial response) of the mean chart &ndash; 
do not confuse with the true FIR feature considered in xewma.arl; will be updated.</p>
</td></tr>
<tr><td><code id="xsewma.crit_+3A_hss">hss</code></td>
<td>
<p>headstart (enables fast initial response) of the variance chart.</p>
</td></tr>
<tr><td><code id="xsewma.crit_+3A_df">df</code></td>
<td>
<p>actual degrees of freedom, corresponds to subgroup size
(for known mean it is equal to the subgroup size,
for unknown mean it is equal to subgroup size minus one.</p>
</td></tr>
<tr><td><code id="xsewma.crit_+3A_s2.on">s2.on</code></td>
<td>
<p>distinguishes between <code class="reqn">S^2</code> and <code class="reqn">S</code> chart.</p>
</td></tr>
<tr><td><code id="xsewma.crit_+3A_sided">sided</code></td>
<td>
<p>distinguishes between one- and two-sided two-sided EWMA-<code class="reqn">S^2</code>
control charts by choosing <code>"upper"</code> (upper chart without reflection at <code>cl</code>
&ndash; the actual value of <code>cl</code> is not used), <code>"Rupper"</code> (upper chart with
reflection at <code>cl</code>), <code>"Rlower"</code> (lower chart with reflection at <code>cu</code>),
and <code>"two"</code> (two-sided chart), respectively.</p>
</td></tr>
<tr><td><code id="xsewma.crit_+3A_mode">mode</code></td>
<td>
<p>only deployed for <code>sided</code>=<code>"two"</code> &ndash; with <code>"fixed"</code>
an upper control limit (see <code>cu</code>) is set and only the lower is
determined to obtain the in-control ARL <code>L0</code>, while with <code>"unbiased"</code>
a certain unbiasedness of the ARL function is guaranteed (here, both the
lower and the upper control limit are calculated).</p>
</td></tr>
<tr><td><code id="xsewma.crit_+3A_nx">Nx</code></td>
<td>
<p>dimension of the approximating matrix of the mean chart.</p>
</td></tr>
<tr><td><code id="xsewma.crit_+3A_ns">Ns</code></td>
<td>
<p>dimension of the approximating matrix of the variance chart.</p>
</td></tr>
<tr><td><code id="xsewma.crit_+3A_qm">qm</code></td>
<td>
<p>number of quadrature nodes used for the collocation integrals.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>xsewma.crit</code> determines the critical values (similar to alarm limits)
for given in-control ARL <code>L0</code>
by applying secant rule and using <code>xsewma.arl()</code>.
In case of <code>sided</code>=<code>"two"</code> and <code>mode</code>=<code>"unbiased"</code>
a two-dimensional secant rule is applied that also ensures that the
maximum of the ARL function for given standard deviation is attained
at <code>sigma0</code>. See Knoth (2007) for details and application.
</p>


<h3>Value</h3>

<p>Returns the critical value of the two-sided mean EWMA chart and
the lower and upper controls limit <code>cl</code> and <code>cu</code> of the variance EWMA chart.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>S. Knoth (2007),
Accurate ARL calculation for EWMA control charts monitoring simultaneously
normal mean and variance,
<em>Sequential Analysis 26</em>, 251-264.
</p>


<h3>See Also</h3>

<p><code>xsewma.arl</code> for calculation of ARL of simultaneous EWMA charts.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Knoth (2007)
## results in Table 2

# subgroup size n=5, df=n-1
df  &lt;- 4
# lambda of mean chart
lx  &lt;- .134
# lambda of variance chart
ls  &lt;- .1
# in-control ARL 
L0 &lt;- 252.3
# matrix dimensions for mean and variance part
Nx  &lt;- 25
Ns  &lt;- 25
# mode of variance chart
SIDED &lt;- "upper"

crit &lt;- xsewma.crit(lx, ls, L0, df, sided=SIDED, Nx=Nx, Ns=Ns)
crit

## output as used in Knoth (2007)
crit["cx"]/sqrt(df+1)*sqrt(lx/(2-lx))
crit["cu"] - 1
</code></pre>

<hr>
<h2 id='xsewma.q'>Compute critical values of simultaneous EWMA control charts
(mean and variance charts) for given RL quantile</h2><span id='topic+xsewma.q'></span><span id='topic+xsewma.q.crit'></span>

<h3>Description</h3>

<p>Computation of the critical values (similar to alarm limits)
for different types of simultaneous EWMA control charts 
(based on the sample mean and the sample variance <code class="reqn">S^2</code>)
monitoring normal mean and variance.</p>


<h3>Usage</h3>

<pre><code class='language-R'>xsewma.q(lx, cx, ls, csu, df, alpha, mu, sigma, hsx=0,
Nx=40, csl=0, hss=1, Ns=40, sided="upper", qm=30)

xsewma.q.crit(lx, ls, L0, alpha, df, mu0=0, sigma0=1, csu=NULL,
hsx=0, hss=1, sided="upper", mode="fixed", Nx=20, Ns=40, qm=30,
c.error=1e-12, a.error=1e-9)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xsewma.q_+3A_lx">lx</code></td>
<td>
<p>smoothing parameter lambda of the two-sided mean EWMA chart.</p>
</td></tr>
<tr><td><code id="xsewma.q_+3A_cx">cx</code></td>
<td>
<p>control limit of the two-sided mean EWMA control chart.</p>
</td></tr>
<tr><td><code id="xsewma.q_+3A_ls">ls</code></td>
<td>
<p>smoothing parameter lambda of the variance EWMA chart.</p>
</td></tr>
<tr><td><code id="xsewma.q_+3A_csu">csu</code></td>
<td>
<p>for two-sided (<code>sided</code>=<code>"two"</code>) and fixed upper
control limit (<code>mode</code>=<code>"fixed"</code>, only for <code>xsewma.q.crit</code>)
a value larger than <code>sigma0</code>
has to been given, for all other cases <code>cu</code> is ignored.
It is the upper control limit of the variance EWMA control chart.</p>
</td></tr>
<tr><td><code id="xsewma.q_+3A_l0">L0</code></td>
<td>
<p>in-control RL quantile at level <code>alpha</code>.</p>
</td></tr>
<tr><td><code id="xsewma.q_+3A_df">df</code></td>
<td>
<p>actual degrees of freedom, corresponds to subgroup size
(for known mean it is equal to the subgroup size,
for unknown mean it is equal to subgroup size minus one.</p>
</td></tr>
<tr><td><code id="xsewma.q_+3A_alpha">alpha</code></td>
<td>
<p>quantile level.</p>
</td></tr>
<tr><td><code id="xsewma.q_+3A_mu">mu</code></td>
<td>
<p>true mean.</p>
</td></tr>
<tr><td><code id="xsewma.q_+3A_sigma">sigma</code></td>
<td>
<p>true standard deviation.</p>
</td></tr>
<tr><td><code id="xsewma.q_+3A_mu0">mu0</code></td>
<td>
<p>in-control mean.</p>
</td></tr>
<tr><td><code id="xsewma.q_+3A_sigma0">sigma0</code></td>
<td>
<p>in-control standard deviation.</p>
</td></tr>
<tr><td><code id="xsewma.q_+3A_hsx">hsx</code></td>
<td>
<p>so-called headstart (enables fast initial response) of the mean chart &ndash; 
do not confuse with the true FIR feature considered in xewma.arl; will be updated.</p>
</td></tr>
<tr><td><code id="xsewma.q_+3A_nx">Nx</code></td>
<td>
<p>dimension of the approximating matrix of the mean chart.</p>
</td></tr>
<tr><td><code id="xsewma.q_+3A_csl">csl</code></td>
<td>
<p>lower control limit of the variance EWMA control chart; default value is 0;
not considered if <code>sided</code> is <code>"upper"</code>.</p>
</td></tr>
<tr><td><code id="xsewma.q_+3A_hss">hss</code></td>
<td>
<p>headstart (enables fast initial response) of the variance chart.</p>
</td></tr>
<tr><td><code id="xsewma.q_+3A_ns">Ns</code></td>
<td>
<p>dimension of the approximating matrix of the variance chart.</p>
</td></tr>
<tr><td><code id="xsewma.q_+3A_sided">sided</code></td>
<td>
<p>distinguishes between one- and two-sided two-sided
EWMA-<code class="reqn">S^2</code> control charts by choosing <code>"upper"</code> (upper chart without
reflection at <code>cl</code> &ndash; the actual value of of <code>cl</code> is not used).</p>
</td></tr>
<tr><td><code id="xsewma.q_+3A_mode">mode</code></td>
<td>
<p>only deployed for <code>sided</code>=<code>"two"</code> &ndash; with <code>"fixed"</code>
an upper control limit (see <code>cu</code>) is set and only the lower is
determined to obtain the in-control ARL <code>L0</code>, while with <code>"unbiased"</code>
a certain unbiasedness of the ARL function is guaranteed (here, both the
lower and the upper control limit are calculated).</p>
</td></tr>
<tr><td><code id="xsewma.q_+3A_qm">qm</code></td>
<td>
<p>number of quadrature nodes used for the collocation integrals.</p>
</td></tr>
<tr><td><code id="xsewma.q_+3A_c.error">c.error</code></td>
<td>
<p>error bound for two succeeding values of the critical value
during applying the secant rule.</p>
</td></tr>
<tr><td><code id="xsewma.q_+3A_a.error">a.error</code></td>
<td>
<p>error bound for the quantile level <code>alpha</code> during
applying the secant rule.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Instead of the popular ARL (Average Run Length) quantiles of the EWMA
stopping time (Run Length) are determined. The algorithm is based on
Waldmann's survival function iteration procedure and on Knoth (2007).
<code>xsewma.q.crit</code> determines the critical values (similar to alarm limits)
for given in-control RL quantile <code>L0</code> at level <code>alpha</code> by applying secant
rule and using <code>xsewma.sf()</code>.
In case of <code>sided</code>=<code>"two"</code> and <code>mode</code>=<code>"unbiased"</code>
a two-dimensional secant rule is applied that also ensures that the
maximum of the RL cdf for given standard deviation is attained at <code>sigma0</code>.
</p>


<h3>Value</h3>

<p>Returns a single value which resembles the RL quantile of order <code>alpha</code> and
the critical value of the two-sided mean EWMA chart and
the lower and upper controls limit <code>csl</code> and <code>csu</code> of the
variance EWMA chart, respectively.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>S. Knoth (2007),
Accurate ARL calculation for EWMA control charts monitoring simultaneously
normal mean and variance,
<em>Sequential Analysis 26</em>, 251-264.
</p>


<h3>See Also</h3>

<p><code>xsewma.arl</code> for calculation of ARL of simultaneous EWMA charts and
<code>xsewma.sf</code> for the RL survival function.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## will follow
</code></pre>

<hr>
<h2 id='xsewma.sf'>Compute the survival function of simultaneous EWMA control
charts (mean and variance charts)</h2><span id='topic+xsewma.sf'></span>

<h3>Description</h3>

<p>Computation of the survival function of the Run Length (RL)
for EWMA control charts monitoring simultaneously normal mean and variance.</p>


<h3>Usage</h3>

<pre><code class='language-R'>xsewma.sf(n, lx, cx, ls, csu, df, mu, sigma, hsx=0, Nx=40,
csl=0, hss=1, Ns=40, sided="upper", qm=30) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xsewma.sf_+3A_n">n</code></td>
<td>
<p>calculate sf up to value <code>n</code>.</p>
</td></tr>
<tr><td><code id="xsewma.sf_+3A_lx">lx</code></td>
<td>
<p>smoothing parameter lambda of the two-sided mean EWMA chart.</p>
</td></tr>
<tr><td><code id="xsewma.sf_+3A_cx">cx</code></td>
<td>
<p>control limit of the two-sided mean EWMA control chart.</p>
</td></tr>
<tr><td><code id="xsewma.sf_+3A_ls">ls</code></td>
<td>
<p>smoothing parameter lambda of the variance EWMA chart.</p>
</td></tr>
<tr><td><code id="xsewma.sf_+3A_csu">csu</code></td>
<td>
<p>upper control limit of the variance EWMA control chart.</p>
</td></tr>
<tr><td><code id="xsewma.sf_+3A_df">df</code></td>
<td>
<p>actual degrees of freedom, corresponds to subgroup size (for known mean it is
equal to the subgroup size, for unknown mean it is equal to subgroup size minus one.</p>
</td></tr>
<tr><td><code id="xsewma.sf_+3A_mu">mu</code></td>
<td>
<p>true mean.</p>
</td></tr>
<tr><td><code id="xsewma.sf_+3A_sigma">sigma</code></td>
<td>
<p>true standard deviation.</p>
</td></tr>
<tr><td><code id="xsewma.sf_+3A_hsx">hsx</code></td>
<td>
<p>so-called headstart (enables fast initial response) of the mean chart &ndash;
do not confuse with the true FIR feature considered in xewma.arl; will be updated.</p>
</td></tr>
<tr><td><code id="xsewma.sf_+3A_nx">Nx</code></td>
<td>
<p>dimension of the approximating matrix of the mean chart.</p>
</td></tr>
<tr><td><code id="xsewma.sf_+3A_csl">csl</code></td>
<td>
<p>lower control limit of the variance EWMA control chart; default value is 0;
not considered if <code>sided</code> is <code>"upper"</code>.</p>
</td></tr>
<tr><td><code id="xsewma.sf_+3A_hss">hss</code></td>
<td>
<p>headstart (enables fast initial response) of the variance chart.</p>
</td></tr>
<tr><td><code id="xsewma.sf_+3A_ns">Ns</code></td>
<td>
<p>dimension of the approximating matrix of the variance chart.</p>
</td></tr>
<tr><td><code id="xsewma.sf_+3A_sided">sided</code></td>
<td>
<p>distinguishes between one- and two-sided two-sided
EWMA-<code class="reqn">S^2</code> control charts by choosing <code>"upper"</code> (upper chart
without reflection at <code>cl</code> &ndash; the actual value of
<code>cl</code> is not used), <code>"Rupper"</code> (upper chart with reflection at <code>cl</code>),
<code>"Rlower"</code> (lower chart with reflection at <code>cu</code>), and <code>"two"</code>
(two-sided chart), respectively.</p>
</td></tr> 
<tr><td><code id="xsewma.sf_+3A_qm">qm</code></td>
<td>
<p>number of quadrature nodes used for the collocation integrals.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The survival function P(L&gt;n) and derived from it also the cdf P(L&lt;=n) and
the pmf P(L=n) illustrate
the distribution of the EWMA run length. For large n the geometric tail
could be exploited. That is,
with reasonable large n the complete distribution is characterized.
The algorithm is based on Waldmann's survival function iteration procedure and
on results in Knoth (2007).
</p>


<h3>Value</h3>

<p>Returns a vector which resembles the survival function up to a certain point.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>S. Knoth (2007),
Accurate ARL calculation for EWMA control charts monitoring simultaneously
normal mean and variance,
<em>Sequential Analysis 26</em>, 251-264.
</p>
<p>K.-H. Waldmann (1986),
Bounds for the distribution of the run length of geometric moving 
average charts, <em>Appl. Statist. 35</em>, 151-158.
</p>


<h3>See Also</h3>

<p><code>xsewma.arl</code> for zero-state ARL computation of simultaneous EWMA
control charts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## will follow
</code></pre>

<hr>
<h2 id='xshewhart.ar1.arl'>Compute ARLs of modified Shewhart control charts for AR(1) data</h2><span id='topic+xshewhart.ar1.arl'></span>

<h3>Description</h3>

<p>Computation of the (zero-state) Average Run Length (ARL)
for modified Shewhart charts deployed to the original AR(1) data.</p>


<h3>Usage</h3>

<pre><code class='language-R'>xshewhart.ar1.arl(alpha, cS, delta=0, N1=50, N2=30)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xshewhart.ar1.arl_+3A_alpha">alpha</code></td>
<td>
<p>lag 1 correlation of the data.</p>
</td></tr>
<tr><td><code id="xshewhart.ar1.arl_+3A_cs">cS</code></td>
<td>
<p>critical value (alias to alarm limit) of the Shewhart control chart.</p>
</td></tr>
<tr><td><code id="xshewhart.ar1.arl_+3A_delta">delta</code></td>
<td>
<p>potential shift in the data (in-control mean is zero.</p>
</td></tr>
<tr><td><code id="xshewhart.ar1.arl_+3A_n1">N1</code></td>
<td>
<p>number of quadrature nodes for solving the ARL integral equation, dimension of the resulting linear equation system is <code>N1</code>.</p>
</td></tr>
<tr><td><code id="xshewhart.ar1.arl_+3A_n2">N2</code></td>
<td>
<p>second number of quadrature nodes for combining the probability density function of the first observation following the margin distribution and the solution of the ARL integral equation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Following the idea of Schmid (1995), <code>1- alpha</code> times the data turns out to be an
EWMA smoothing of the underlying AR(1) residuals. Hence, by combining the solution of
the EWMA ARL integral equation and the stationary distribution of the AR(1) data
(normal distribution is assumed) one gets easily the overall ARL.
</p>


<h3>Value</h3>

<p>It returns a single value resembling the zero-state ARL of a modified Shewhart chart.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>S. Knoth, W. Schmid (2004).
Control charts for time series: A review.
In <em>Frontiers in Statistical Quality Control 7</em>,
edited by H.-J. Lenz, P.-T. Wilrich, 210-236, Physica-Verlag.
</p>
<p>H. Kramer, W. Schmid (2000).
The influence of parameter estimation on the ARL of Shewhart type charts for time series.
<em>Statistical Papers 41</em>(2), 173-196.
</p>
<p>W. Schmid (1995).
On the run length of a Shewhart chart for correlated data. 
<em>Statistical Papers 36</em>(1), 111-130.
</p>


<h3>See Also</h3>

<p><code>xewma.arl</code> for zero-state ARL computation of EWMA control charts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Table 1 in Kramer/Schmid (2000)

cS &lt;- 3.09023
a  &lt;- seq(0, 4, by=.5)
row1 &lt;- row2 &lt;- row3 &lt;- NULL
for ( i in 1:length(a) ) {
  row1 &lt;- c(row1, round(xshewhart.ar1.arl( 0.4, cS, delta=a[i]), digits=2))
  row2 &lt;- c(row2, round(xshewhart.ar1.arl( 0.2, cS, delta=a[i]), digits=2))
  row3 &lt;- c(row3, round(xshewhart.ar1.arl(-0.2, cS, delta=a[i]), digits=2))
}

results &lt;- rbind(row1, row2, row3)
results

# original values are
# row1 515.44 215.48 61.85 21.63 9.19 4.58 2.61 1.71 1.29
# row2 502.56 204.97 56.72 19.13 7.95 3.97 2.33 1.59 1.25
# row3 502.56 201.41 54.05 17.42 6.89 3.37 2.03 1.46 1.20
</code></pre>

<hr>
<h2 id='xshewhartrunsrules.arl'>Compute ARLs of Shewhart control charts with and without runs rules</h2><span id='topic+xshewhartrunsrules.arl'></span><span id='topic+xshewhartrunsrules.crit'></span><span id='topic+xshewhartrunsrules.ad'></span><span id='topic+xshewhartrunsrules.matrix'></span>

<h3>Description</h3>

<p>Computation of the (zero-state and steady-state) Average Run Length (ARL)
for Shewhart control charts with and without runs rules
monitoring normal mean.</p>


<h3>Usage</h3>

<pre><code class='language-R'>xshewhartrunsrules.arl(mu, c = 1, type = "12")

xshewhartrunsrules.crit(L0, mu = 0, type = "12")

xshewhartrunsrules.ad(mu1, mu0 = 0, c = 1, type = "12")

xshewhartrunsrules.matrix(mu, c = 1, type = "12")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xshewhartrunsrules.arl_+3A_mu">mu</code></td>
<td>
<p>true mean.</p>
</td></tr>
<tr><td><code id="xshewhartrunsrules.arl_+3A_l0">L0</code></td>
<td>
<p>pre-defined in-control ARL, that is, determine <code>c</code> so that the mean
number of observations until a false alarm is <code>L0</code>.</p>
</td></tr>
<tr><td><code id="xshewhartrunsrules.arl_+3A_mu1">mu1</code>, <code id="xshewhartrunsrules.arl_+3A_mu0">mu0</code></td>
<td>
<p>for the steady-state ARL two means are specified, mu0 is the in-control one
and usually equal to 0 , and mu1 must be given.</p>
</td></tr>
<tr><td><code id="xshewhartrunsrules.arl_+3A_c">c</code></td>
<td>
<p>normalizing constant to ensure specific alarming behavior.</p>
</td></tr>
<tr><td><code id="xshewhartrunsrules.arl_+3A_type">type</code></td>
<td>
<p>controls the type of Shewhart chart used, seed details section.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>xshewhartrunsrules.arl</code> determines the zero-state Average Run Length (ARL)
based on the Markov chain approach given in Champ and Woodall (1987).
<code>xshewhartrunsrules.matrix</code> provides the corresponding
transition matrix that is also used in <code>xDshewhartrunsrules.arl</code> (ARL for control charting drift).
<code>xshewhartrunsrules.crit</code> allows to find the normalization constant <code>c</code> to
attain a fixed in-control ARL. Typically this is needed to calibrate the chart.
With <code>xshewhartrunsrules.ad</code> the steady-state ARL is calculated.
With the argument <code>type</code> certain runs rules could be set. The following list gives an overview.
</p>

<ul>
<li><p>&quot;1&quot; The classical Shewhart chart with <code>+/- 3 c sigma</code> control limits (<code>c</code> is typically
equal to 1 and can be changed by the argument <code>c</code>).
</p>
</li>
<li><p>&quot;12&quot; The classic and the following runs rule: 2 of 3 are beyond <code>+/- 2 c sigma</code> on the same
side of the chart.
</p>
</li>
<li><p>&quot;13&quot; The classic and the following runs rule: 4 of 5 are beyond <code>+/- 1 c sigma</code> on the same
side of the chart.
</p>
</li>
<li><p>&quot;14&quot; The classic and the following runs rule: 8 of 8 are on the same side of the chart
(referring to the center line).</p>
</li></ul>



<h3>Value</h3>

<p>Returns a single value which resembles the zero-state or steady-state ARL.
<code>xshewhartrunsrules.matrix</code> returns a matrix.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>C. W. Champ and W. H. Woodall (1987),
Exact results for Shewhart control charts with supplementary runs rules,
<em>Technometrics 29</em>, 393-399.
</p>


<h3>See Also</h3>

<p><code>xDshewhartrunsrules.arl</code> for zero-state ARL of Shewhart control charts
with or without runs rules under drift.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Champ/Woodall (1987)
## Table 1
mus &lt;- (0:15)/5
Mxshewhartrunsrules.arl &lt;- Vectorize(xshewhartrunsrules.arl, "mu")
# standard (1 of 1 beyond 3 sigma) Shewhart chart without runs rules
C1 &lt;- round(Mxshewhartrunsrules.arl(mus, type="1"), digits=2)
# standard + runs rule: 2 of 3 beyond 2 sigma on the same side
C12 &lt;- round(Mxshewhartrunsrules.arl(mus, type="12"), digits=2)
# standard + runs rule: 4 of 5 beyond 1 sigma on the same side
C13 &lt;- round(Mxshewhartrunsrules.arl(mus, type="13"), digits=2)
# standard + runs rule: 8 of 8 on the same side of the center line
C14 &lt;- round(Mxshewhartrunsrules.arl(mus, type="14"), digits=2)

## original results are
#  mus     C1    C12    C13    C14                                    
#  0.0 370.40 225.44 166.05 152.73                                    
#  0.2 308.43 177.56 120.70 110.52                                    
#  0.4 200.08 104.46  63.88  59.76                                    
#  0.6 119.67  57.92  33.99  33.64                                    
#  0.8  71.55  33.12  19.78  21.07                                    
#  1.0  43.89  20.01  12.66  14.58                                    
#  1.2  27.82  12.81   8.84  10.90                                    
#  1.4  18.25   8.69   6.62   8.60                                    
#  1.6  12.38   6.21   5.24   7.03                                    
#  1.8   8.69   4.66   4.33   5.85                                    
#  2.0   6.30   3.65   3.68   4.89                                    
#  2.2   4.72   2.96   3.18   4.08                                    
#  2.4   3.65   2.48   2.78   3.38                                    
#  2.6   2.90   2.13   2.43   2.81                                    
#  2.8   2.38   1.87   2.14   2.35                                    
#  3.0   2.00   1.68   1.89   1.99

data.frame(mus, C1, C12, C13, C14)

## plus calibration, i. e. L0=250 (the maximal value for "14" is 255!
L0 &lt;- 250
c1  &lt;- xshewhartrunsrules.crit(L0, type = "1")
c12 &lt;- xshewhartrunsrules.crit(L0, type = "12")
c13 &lt;- xshewhartrunsrules.crit(L0, type = "13")
c14 &lt;- xshewhartrunsrules.crit(L0, type = "14")
C1  &lt;- round(Mxshewhartrunsrules.arl(mus, c=c1,  type="1"), digits=2)
C12 &lt;- round(Mxshewhartrunsrules.arl(mus, c=c12, type="12"), digits=2)
C13 &lt;- round(Mxshewhartrunsrules.arl(mus, c=c13, type="13"), digits=2)
C14 &lt;- round(Mxshewhartrunsrules.arl(mus, c=c14, type="14"), digits=2)
data.frame(mus, C1, C12, C13, C14)

## and the steady-state ARL
Mxshewhartrunsrules.ad &lt;- Vectorize(xshewhartrunsrules.ad, "mu1")
C1  &lt;- round(Mxshewhartrunsrules.ad(mus, c=c1,  type="1"), digits=2)
C12 &lt;- round(Mxshewhartrunsrules.ad(mus, c=c12, type="12"), digits=2)
C13 &lt;- round(Mxshewhartrunsrules.ad(mus, c=c13, type="13"), digits=2)
C14 &lt;- round(Mxshewhartrunsrules.ad(mus, c=c14, type="14"), digits=2)
data.frame(mus, C1, C12, C13, C14)
</code></pre>

<hr>
<h2 id='xtcusum.arl'>Compute ARLs of CUSUM control charts</h2><span id='topic+xtcusum.arl'></span>

<h3>Description</h3>

<p>Computation of the (zero-state) Average Run Length (ARL)
for different types of CUSUM control charts monitoring normal mean.</p>


<h3>Usage</h3>

<pre><code class='language-R'>xtcusum.arl(k, h, df, mu, hs = 0, sided="one", mode="tan", r=30)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xtcusum.arl_+3A_k">k</code></td>
<td>
<p>reference value of the CUSUM control chart.</p>
</td></tr>
<tr><td><code id="xtcusum.arl_+3A_h">h</code></td>
<td>
<p>decision interval (alarm limit, threshold) of the CUSUM control chart.</p>
</td></tr>
<tr><td><code id="xtcusum.arl_+3A_df">df</code></td>
<td>
<p>degrees of freedom &ndash; parameter of the t distribution.</p>
</td></tr>
<tr><td><code id="xtcusum.arl_+3A_mu">mu</code></td>
<td>
<p>true mean.</p>
</td></tr>
<tr><td><code id="xtcusum.arl_+3A_hs">hs</code></td>
<td>
<p>so-called headstart (give fast initial response).</p>
</td></tr>
<tr><td><code id="xtcusum.arl_+3A_sided">sided</code></td>
<td>
<p>distinguish between one- and  two-sided CUSUM schemes by choosing <code>"one"</code> and <code>"two"</code>, respectively.</p>
</td></tr>
<tr><td><code id="xtcusum.arl_+3A_r">r</code></td>
<td>
<p>number of quadrature nodes, dimension of the resulting linear equation system is equal to <code>r+1</code>.</p>
</td></tr>
<tr><td><code id="xtcusum.arl_+3A_mode">mode</code></td>
<td>
<p>Controls the type of variables substitution that might improve the numerical performance. Currently, <code>"identity"</code>, <code>"sin"</code>, <code>"sinh"</code>, and <code>"tan"</code> (default) are provided.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>xtcusum.arl</code> determines the Average Run Length (ARL) by numerically
solving the related ARL integral equation by means of the Nystroem method
based on Gauss-Legendre quadrature.
</p>


<h3>Value</h3>

<p>Returns a single value which resembles the ARL.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>A. L. Goel, S. M. Wu (1971),
Determination of A.R.L. and a contour nomogram for CUSUM charts to
control normal mean, <em>Technometrics 13</em>, 221-230.
</p>
<p>D. Brook, D. A. Evans (1972),
An approach to the probability distribution of cusum run length,
<em>Biometrika 59</em>, 539-548.
</p>
<p>J. M. Lucas, R. B. Crosier (1982),
Fast initial response for cusum quality-control schemes: 
Give your cusum a headstart, <em>Technometrics 24</em>, 199-205.
</p>
<p>L. C. Vance (1986), 
Average run lengths of cumulative sum control charts for controlling 
normal means, <em>Journal of Quality Technology 18</em>, 189-193.
</p>
<p>K.-H. Waldmann (1986),
Bounds for the distribution of the run length of one-sided and
two-sided CUSUM quality control schemes,
<em>Technometrics 28</em>, 61-67.
</p>
<p>R. B. Crosier (1986),
A new two-sided cumulative quality control scheme,
<em>Technometrics 28</em>, 187-194.
</p>


<h3>See Also</h3>

<p><code>xtewma.arl</code> for zero-state ARL computation of EWMA control charts and <code>xtcusum.arl</code> for the zero-state ARL of CUSUM for normal data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## will follow
</code></pre>

<hr>
<h2 id='xtewma.ad'>Compute steady-state ARLs of EWMA control charts, t distributed data</h2><span id='topic+xtewma.ad'></span>

<h3>Description</h3>

<p>Computation of the steady-state Average Run Length (ARL)
for different types of EWMA control charts monitoring the mean of t distributed data.</p>


<h3>Usage</h3>

<pre><code class='language-R'>xtewma.ad(l, c, df, mu1, mu0=0, zr=0, z0=0, sided="one", limits="fix",
steady.state.mode="conditional", mode="tan", r=40)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xtewma.ad_+3A_l">l</code></td>
<td>
<p>smoothing parameter lambda of the EWMA control chart.</p>
</td></tr>
<tr><td><code id="xtewma.ad_+3A_c">c</code></td>
<td>
<p>critical value (similar to alarm limit) of the EWMA control chart.</p>
</td></tr>
<tr><td><code id="xtewma.ad_+3A_df">df</code></td>
<td>
<p>degrees of freedom &ndash; parameter of the t distribution.</p>
</td></tr>
<tr><td><code id="xtewma.ad_+3A_mu1">mu1</code></td>
<td>
<p>in-control mean.</p>
</td></tr>
<tr><td><code id="xtewma.ad_+3A_mu0">mu0</code></td>
<td>
<p>out-of-control mean.</p>
</td></tr>
<tr><td><code id="xtewma.ad_+3A_zr">zr</code></td>
<td>
<p>reflection border for the one-sided chart.</p>
</td></tr>
<tr><td><code id="xtewma.ad_+3A_z0">z0</code></td>
<td>
<p>restarting value of the EWMA sequence in case of a false alarm in
<code>steady.state.mode="cyclical"</code>.</p>
</td></tr>
<tr><td><code id="xtewma.ad_+3A_sided">sided</code></td>
<td>
<p>distinguishes between one- and two-sided two-sided EWMA control
chart by choosing <code>"one"</code> and <code>"two"</code>, respectively.</p>
</td></tr>
<tr><td><code id="xtewma.ad_+3A_limits">limits</code></td>
<td>
<p>distinguishes between different control limits behavior.</p>
</td></tr>
<tr><td><code id="xtewma.ad_+3A_steady.state.mode">steady.state.mode</code></td>
<td>
<p>distinguishes between two steady-state modes &ndash; conditional and cyclical.</p>
</td></tr>
<tr><td><code id="xtewma.ad_+3A_mode">mode</code></td>
<td>
<p>Controls the type of variables substitution that might improve the numerical performance. Currently,
<code>"identity"</code>, <code>"sin"</code>, <code>"sinh"</code>, and <code>"tan"</code> (default) are provided.</p>
</td></tr>
<tr><td><code id="xtewma.ad_+3A_r">r</code></td>
<td>
<p>number of quadrature nodes, dimension of the resulting linear
equation system is equal to <code>r+1</code> (one-sided) or <code>r</code>
(two-sided).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>xtewma.ad</code> determines the steady-state Average Run Length (ARL)
by numerically solving the related ARL integral equation by means
of the Nystroem method based on Gauss-Legendre quadrature
and using the power method for deriving the largest in magnitude
eigenvalue and the related left eigenfunction.
</p>


<h3>Value</h3>

<p>Returns a single value which resembles the steady-state ARL.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>R. B. Crosier (1986),
A new two-sided cumulative quality control scheme,
<em>Technometrics 28</em>, 187-194.
</p>
<p>S. V. Crowder (1987),
A simple method for studying run-length distributions of exponentially weighted
moving average charts,
<em>Technometrics 29</em>, 401-407.
</p>
<p>J. M. Lucas and M. S. Saccucci (1990),
Exponentially weighted moving average control schemes: Properties and enhancements,
<em>Technometrics 32</em>, 1-12.
</p>


<h3>See Also</h3>

<p><code>xtewma.arl</code> for zero-state ARL computation and
<code>xewma.ad</code> for the steady-state ARL for normal data.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## will follow
</code></pre>

<hr>
<h2 id='xtewma.arl'>Compute ARLs of EWMA control charts, t distributed data</h2><span id='topic+xtewma.arl'></span>

<h3>Description</h3>

<p>Computation of the (zero-state) Average Run Length (ARL)
for different types of EWMA control charts monitoring the mean of t distributed data.</p>


<h3>Usage</h3>

<pre><code class='language-R'>xtewma.arl(l,c,df,mu,zr=0,hs=0,sided="two",limits="fix",mode="tan",q=1,r=40)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xtewma.arl_+3A_l">l</code></td>
<td>
<p>smoothing parameter lambda of the EWMA control chart.</p>
</td></tr>
<tr><td><code id="xtewma.arl_+3A_c">c</code></td>
<td>
<p>critical value (similar to alarm limit) of the EWMA control chart.</p>
</td></tr>
<tr><td><code id="xtewma.arl_+3A_df">df</code></td>
<td>
<p>degrees of freedom &ndash; parameter of the t distribution.</p>
</td></tr>
<tr><td><code id="xtewma.arl_+3A_mu">mu</code></td>
<td>
<p>true mean.</p>
</td></tr>
<tr><td><code id="xtewma.arl_+3A_zr">zr</code></td>
<td>
<p>reflection border for the one-sided chart.</p>
</td></tr>
<tr><td><code id="xtewma.arl_+3A_hs">hs</code></td>
<td>
<p>so-called headstart (enables fast initial response).</p>
</td></tr>
<tr><td><code id="xtewma.arl_+3A_sided">sided</code></td>
<td>
<p>distinguishes between one- and two-sided EWMA control chart 
by choosing <code>"one"</code> and <code>"two"</code>, respectively.</p>
</td></tr>
<tr><td><code id="xtewma.arl_+3A_limits">limits</code></td>
<td>
<p>distinguishes between different control limits behavior.</p>
</td></tr>
<tr><td><code id="xtewma.arl_+3A_mode">mode</code></td>
<td>
<p>Controls the type of variables substitution that might improve the numerical performance. Currently,
<code>"identity"</code>, <code>"sin"</code>, <code>"sinh"</code>, and <code>"tan"</code> (default) are provided.</p>
</td></tr>
<tr><td><code id="xtewma.arl_+3A_q">q</code></td>
<td>
<p>change point position. For <code class="reqn">q=1</code> and
<code class="reqn">\mu=\mu_0</code> and <code class="reqn">\mu=\mu_1</code>, the usual
zero-state ARLs for the in-control and out-of-control case, respectively,
are calculated. For <code class="reqn">q&gt;1</code> and <code class="reqn">\mu!=0</code> conditional delays, that is,
<code class="reqn">E_q(L-q+1|L\ge q)</code>, will be determined.
Note that mu0=0 is implicitely fixed.</p>
</td></tr>
<tr><td><code id="xtewma.arl_+3A_r">r</code></td>
<td>
<p>number of quadrature nodes, dimension of the resulting linear
equation system is equal to <code>r+1</code> (one-sided) or <code>r</code>
(two-sided).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In case of the EWMA chart with fixed control limits,
<code>xtewma.arl</code> determines the Average Run Length (ARL) by numerically
solving the related ARL integral equation by means of the Nystroem method
based on Gauss-Legendre quadrature.
If <code>limits</code> is <code>"vacl"</code>, then the method presented in Knoth (2003) is utilized.
Other values (normal case) for <code>limits</code> are not yet supported.
</p>


<h3>Value</h3>

<p>Except for the fixed limits EWMA charts it returns a single value which resembles the ARL.
For fixed limits charts, it returns a vector of length <code>q</code> which resembles the ARL and the
sequence of conditional expected delays for <code>q</code>=1 and <code>q</code>&gt;1, respectively.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>K.-H. Waldmann (1986),
Bounds for the distribution of the run length of geometric moving 
average charts, <em>Appl. Statist. 35</em>, 151-158.
</p>
<p>S. V. Crowder (1987),
A simple method for studying run-length distributions of
exponentially weighted moving average charts,
<em>Technometrics 29</em>, 401-407.
</p>
<p>J. M. Lucas and M. S. Saccucci (1990),
Exponentially weighted moving average control schemes: Properties
and enhancements, <em>Technometrics 32</em>, 1-12.
</p>
<p>C. M. Borror, D. C. Montgomery, and G. C. Runger (1999),
Robustness of the EWMA control chart to non-normality ,
<em>Journal of Quality Technology 31</em>, 309-316.
</p>
<p>S. Knoth (2003),
EWMA schemes with non-homogeneous transition kernels,
<em>Sequential Analysis 22</em>, 241-255.
</p>
<p>S. Knoth (2004),
Fast initial response features for EWMA Control Charts,
<em>Statistical Papers 46</em>, 47-64.
</p>


<h3>See Also</h3>

<p><code>xewma.arl</code> for zero-state ARL computation of EWMA control charts in the normal case.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##  Borror/Montgomery/Runger (1999), Table 3
lambda &lt;- 0.1
cE &lt;- 2.703
df &lt;- c(4, 6, 8, 10, 15, 20, 30, 40, 50)
L0 &lt;- rep(NA, length(df))
for ( i in 1:length(df) ) {
  L0[i] &lt;- round(xtewma.arl(lambda, cE*sqrt(df[i]/(df[i]-2)), df[i], 0), digits=0)
}
data.frame(df, L0)
</code></pre>

<hr>
<h2 id='xtewma.q'>Compute RL quantiles of EWMA control charts</h2><span id='topic+xtewma.q'></span><span id='topic+xtewma.q.crit'></span>

<h3>Description</h3>

<p>Computation of quantiles of the Run Length (RL)
for EWMA control charts monitoring normal mean.</p>


<h3>Usage</h3>

<pre><code class='language-R'>xtewma.q(l, c, df, mu, alpha, zr=0, hs=0, sided="two", limits="fix", mode="tan",
q=1, r=40)

xtewma.q.crit(l, L0, df, mu, alpha, zr=0, hs=0, sided="two", limits="fix", mode="tan",
r=40, c.error=1e-12, a.error=1e-9, OUTPUT=FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xtewma.q_+3A_l">l</code></td>
<td>
<p>smoothing parameter lambda of the EWMA control chart.</p>
</td></tr>
<tr><td><code id="xtewma.q_+3A_c">c</code></td>
<td>
<p>critical value (similar to alarm limit) of the EWMA control chart.</p>
</td></tr>
<tr><td><code id="xtewma.q_+3A_df">df</code></td>
<td>
<p>degrees of freedom &ndash; parameter of the t distribution.</p>
</td></tr>
<tr><td><code id="xtewma.q_+3A_mu">mu</code></td>
<td>
<p>true mean.</p>
</td></tr>
<tr><td><code id="xtewma.q_+3A_alpha">alpha</code></td>
<td>
<p>quantile level.</p>
</td></tr>
<tr><td><code id="xtewma.q_+3A_zr">zr</code></td>
<td>
<p>reflection border for the one-sided chart.</p>
</td></tr>
<tr><td><code id="xtewma.q_+3A_hs">hs</code></td>
<td>
<p>so-called headstart (enables fast initial response).</p>
</td></tr>
<tr><td><code id="xtewma.q_+3A_sided">sided</code></td>
<td>
<p>distinguishes between one- and two-sided EWMA control chart 
by choosing <code>"one"</code> and <code>"two"</code>, respectively.</p>
</td></tr>
<tr><td><code id="xtewma.q_+3A_limits">limits</code></td>
<td>
<p>distinguishes between different control limits behavior.</p>
</td></tr>
<tr><td><code id="xtewma.q_+3A_mode">mode</code></td>
<td>
<p>Controls the type of variables substitution that might improve the numerical performance. Currently,
<code>"identity"</code>, <code>"sin"</code>, <code>"sinh"</code>, and <code>"tan"</code> (default) are provided.</p>
</td></tr>
<tr><td><code id="xtewma.q_+3A_q">q</code></td>
<td>
<p>change point position. For <code class="reqn">q=1</code> and
<code class="reqn">\mu=\mu_0</code> and <code class="reqn">\mu=\mu_1</code>, the usual
zero-state ARLs for the in-control and out-of-control case, respectively,
are calculated. For <code class="reqn">q&gt;1</code> and <code class="reqn">\mu!=0</code> conditional delays, that is,
<code class="reqn">E_q(L-q+1|L\geq)</code>, will be determined.
Note that mu0=0 is implicitely fixed.</p>
</td></tr>
<tr><td><code id="xtewma.q_+3A_r">r</code></td>
<td>
<p>number of quadrature nodes, dimension of the resulting linear
equation system is equal to <code>r+1</code> (one-sided) or <code>r</code>
(two-sided).</p>
</td></tr>
<tr><td><code id="xtewma.q_+3A_l0">L0</code></td>
<td>
<p>in-control quantile value.</p>
</td></tr>
<tr><td><code id="xtewma.q_+3A_c.error">c.error</code></td>
<td>
<p>error bound for two succeeding values of the critical value
during applying the secant rule.</p>
</td></tr>
<tr><td><code id="xtewma.q_+3A_a.error">a.error</code></td>
<td>
<p>error bound for the quantile level <code>alpha</code> during applying
the secant rule.</p>
</td></tr>
<tr><td><code id="xtewma.q_+3A_output">OUTPUT</code></td>
<td>
<p>activate or deactivate additional output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Instead of the popular ARL (Average Run Length) quantiles of the EWMA
stopping time (Run Length) are determined. The algorithm is based on
Waldmann's survival function iteration procedure.
If <code>limits</code> is <code>"vacl"</code>, then the method presented in Knoth (2003) is utilized.
For details see Knoth (2004).
</p>


<h3>Value</h3>

<p>Returns a single value which resembles the RL quantile of order <code>q</code>.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>F. F. Gan (1993),
An optimal design of EWMA control charts based on the median run length,
<em>J. Stat. Comput. Simulation 45</em>, 169-184.
</p>
<p>S. Knoth (2003),
EWMA schemes with non-homogeneous transition kernels,
<em>Sequential Analysis 22</em>, 241-255.
</p>
<p>S. Knoth (2004),
Fast initial response features for EWMA Control Charts,
<em>Statistical Papers 46</em>, 47-64.
</p>
<p>K.-H. Waldmann (1986),
Bounds for the distribution of the run length of geometric moving 
average charts, <em>Appl. Statist. 35</em>, 151-158.
</p>


<h3>See Also</h3>

<p><code>xewma.q</code> for RL quantile computation of EWMA control charts in the normal case.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## will follow
</code></pre>

<hr>
<h2 id='xtewma.sf'>Compute the survival function of EWMA run length</h2><span id='topic+xtewma.sf'></span>

<h3>Description</h3>

<p>Computation of the survival function of the Run Length (RL) for EWMA control charts monitoring normal mean.</p>


<h3>Usage</h3>

<pre><code class='language-R'>xtewma.sf(l, c, df, mu, n, zr=0, hs=0, sided="two", limits="fix", mode="tan", q=1, r=40)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xtewma.sf_+3A_l">l</code></td>
<td>
<p>smoothing parameter lambda of the EWMA control chart.</p>
</td></tr>
<tr><td><code id="xtewma.sf_+3A_c">c</code></td>
<td>
<p>critical value (similar to alarm limit) of the EWMA control chart.</p>
</td></tr>
<tr><td><code id="xtewma.sf_+3A_df">df</code></td>
<td>
<p>degrees of freedom &ndash; parameter of the t distribution.</p>
</td></tr>
<tr><td><code id="xtewma.sf_+3A_mu">mu</code></td>
<td>
<p>true mean.</p>
</td></tr>
<tr><td><code id="xtewma.sf_+3A_n">n</code></td>
<td>
<p>calculate sf up to value <code>n</code>.</p>
</td></tr>
<tr><td><code id="xtewma.sf_+3A_zr">zr</code></td>
<td>
<p>reflection border for the one-sided chart.</p>
</td></tr>
<tr><td><code id="xtewma.sf_+3A_hs">hs</code></td>
<td>
<p>so-called headstart (enables fast initial response).</p>
</td></tr>
<tr><td><code id="xtewma.sf_+3A_sided">sided</code></td>
<td>
<p>distinguishes between one- and two-sided EWMA control chart 
by choosing <code>"one"</code> and <code>"two"</code>, respectively.</p>
</td></tr>
<tr><td><code id="xtewma.sf_+3A_limits">limits</code></td>
<td>
<p>distinguishes between different conrol limits behavior.</p>
</td></tr>
<tr><td><code id="xtewma.sf_+3A_mode">mode</code></td>
<td>
<p>Controls the type of variables substitution that might improve the numerical performance. Currently,
<code>"identity"</code>, <code>"sin"</code>, <code>"sinh"</code>, and <code>"tan"</code> (default) are provided.</p>
</td></tr>
<tr><td><code id="xtewma.sf_+3A_q">q</code></td>
<td>
<p>change point position. For <code class="reqn">q=1</code> and
<code class="reqn">\mu=\mu_0</code> and <code class="reqn">\mu=\mu_1</code>, the usual
zero-state situation for the in-control and out-of-control case, respectively,
are calculated. Note that mu0=0 is implicitely fixed.</p>
</td></tr>
<tr><td><code id="xtewma.sf_+3A_r">r</code></td>
<td>
<p>number of quadrature nodes, dimension of the resulting linear
equation system is equal to <code>r+1</code> (one-sided) or <code>r</code> (two-sided).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The survival function P(L&gt;n) and derived from it also the cdf P(L&lt;=n) and the pmf P(L=n) illustrate
the distribution of the EWMA run length. For large n the geometric tail could be exploited. That is,
with reasonable large n the complete distribution is characterized.
The algorithm is based on Waldmann's survival function iteration procedure.
For varying limits and for change points after 1 the algorithm from Knoth (2004) is applied.
For details see Knoth (2004).
</p>


<h3>Value</h3>

<p>Returns a vector which resembles the survival function up to a certain point.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>F. F. Gan (1993),
An optimal design of EWMA control charts based on the median run length,
<em>J. Stat. Comput. Simulation 45</em>, 169-184.
</p>
<p>S. Knoth (2003),
EWMA schemes with non-homogeneous transition kernels,
<em>Sequential Analysis 22</em>, 241-255.
</p>
<p>S. Knoth (2004),
Fast initial response features for EWMA Control Charts,
<em>Statistical Papers 46</em>, 47-64.
</p>
<p>K.-H. Waldmann (1986),
Bounds for the distribution of the run length of geometric moving 
average charts, <em>Appl. Statist. 35</em>, 151-158.
</p>


<h3>See Also</h3>

<p><code>xewma.sf</code> for survival function computation of EWMA control charts in the normal case.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## will follow
</code></pre>

<hr>
<h2 id='xtshewhart.ar1.arl'>Compute ARLs of modified Shewhart control charts for AR(1) data with Student t residuals</h2><span id='topic+xtshewhart.ar1.arl'></span>

<h3>Description</h3>

<p>Computation of the (zero-state) Average Run Length (ARL)
for modified Shewhart charts deployed to the original AR(1) data where the residuals follow a Student t distribution.</p>


<h3>Usage</h3>

<pre><code class='language-R'>xtshewhart.ar1.arl(alpha, cS, df, delta=0, N1=50, N2=30, N3=2*N2, INFI=10, mode="tan")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xtshewhart.ar1.arl_+3A_alpha">alpha</code></td>
<td>
<p>lag 1 correlation of the data.</p>
</td></tr>
<tr><td><code id="xtshewhart.ar1.arl_+3A_cs">cS</code></td>
<td>
<p>critical value (alias to alarm limit) of the Shewhart control chart.</p>
</td></tr>
<tr><td><code id="xtshewhart.ar1.arl_+3A_df">df</code></td>
<td>
<p>degrees of freedom &ndash; parameter of the t distribution.</p>
</td></tr>
<tr><td><code id="xtshewhart.ar1.arl_+3A_delta">delta</code></td>
<td>
<p>potential shift in the data (in-control mean is zero.</p>
</td></tr>
<tr><td><code id="xtshewhart.ar1.arl_+3A_n1">N1</code></td>
<td>
<p>number of quadrature nodes for solving the ARL integral equation, dimension of the resulting linear equation system is <code>N1</code>.</p>
</td></tr>
<tr><td><code id="xtshewhart.ar1.arl_+3A_n2">N2</code></td>
<td>
<p>second number of quadrature nodes for combining the probability density function of the first observation following the margin distribution and the solution of the ARL integral equation.</p>
</td></tr>
<tr><td><code id="xtshewhart.ar1.arl_+3A_n3">N3</code></td>
<td>
<p>third number of quadrature nodes for solving the left eigenfunction integral equation to determine the margin density (see Andel/Hrach, 2000),
dimension of the resulting linear equation system is <code>N3</code>.</p>
</td></tr>
<tr><td><code id="xtshewhart.ar1.arl_+3A_infi">INFI</code></td>
<td>
<p>substitute of <code>Inf</code> &ndash; the left eigenfunction integral equation is defined on the whole real axis; now it is reduced to <code>(-INFI,INFI)</code>.</p>
</td></tr>
<tr><td><code id="xtshewhart.ar1.arl_+3A_mode">mode</code></td>
<td>
<p>Controls the type of variables substitution that might improve the numerical performance. Currently, <code>"identity"</code>, <code>"sin"</code>, <code>"sinh"</code>, and <code>"tan"</code> (default) are provided.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Following the idea of Schmid (1995), <code>1-alpha</code> times the data turns out to be an
EWMA smoothing of the underlying AR(1) residuals. Hence, by combining the solution of
the EWMA ARL integral equation and the stationary distribution of the AR(1) data
(here Student t distribution is assumed) one gets easily the overall ARL.
</p>


<h3>Value</h3>

<p>It returns a single value resembling the zero-state ARL of a modified Shewhart chart.</p>


<h3>Author(s)</h3>

<p>Sven Knoth</p>


<h3>References</h3>

<p>J. Andel, K. Hrach (2000).
On calculation of stationary density of autoregressive processes.
<em>Kybernetika, Institute of Information Theory and Automation AS CR 36</em>(3), 311-319.
</p>
<p>H. Kramer, W. Schmid (2000).
The influence of parameter estimation on the ARL of Shewhart type charts for time series.
<em>Statistical Papers 41</em>(2), 173-196.
</p>
<p>W. Schmid (1995).
On the run length of a Shewhart chart for correlated data. 
<em>Statistical Papers 36</em>(1), 111-130.
</p>


<h3>See Also</h3>

<p><code>xtewma.arl</code> for zero-state ARL computation of EWMA control charts in case of Student t distributed data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## will follow
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
