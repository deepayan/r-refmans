<!DOCTYPE html><html lang="en"><head><title>Help for package JOPS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {JOPS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#JOPS'><p>Joys of P-Splines</p></a></li>
<li><a href='#bbase'><p>Compute a B-spline basis matrix</p></a></li>
<li><a href='#binit'><p>Translated number vector to bin index.</p></a></li>
<li><a href='#bone_data'><p>Spinal bone relative mineral density</p></a></li>
<li><a href='#cbase'><p>Compute a circular B-spline basis matrix</p></a></li>
<li><a href='#cdiff'><p>Compute a second order circular differencing matrix</p></a></li>
<li><a href='#CGHsim'><p>Simulation of CGH data</p></a></li>
<li><a href='#clone_base'><p>Clone a B-spline basis for new x</p></a></li>
<li><a href='#Complaints'><p>Environmental complaints from the Rijnomond area of The Netherlands</p></a></li>
<li><a href='#count2d'><p>Create a matrix of counts.</p></a></li>
<li><a href='#dev_calc'><p>Deviance calculation for GLM P-spline fitting.</p></a></li>
<li><a href='#Disks'><p>Prices of hard disk drives</p></a></li>
<li><a href='#ECG'><p>A section of an ECG (electrocardiogram)</p></a></li>
<li><a href='#fitampl'><p>Fit amplitude coeffcients in the bundle model for expectiles</p></a></li>
<li><a href='#fitasy'><p>Fit asymmetry parameters in the expectile bundle model</p></a></li>
<li><a href='#G519C18'><p>Chromosome G519C18 data</p></a></li>
<li><a href='#Greece_deaths'><p>Deaths in Greece in 1960.</p></a></li>
<li><a href='#Hepatitis'><p>Prevalence of Hepatitis among a sample of Bulgarian males.</p></a></li>
<li><a href='#hist2d'><p>Compute a 2D histogram</p></a></li>
<li><a href='#hist2dsm'><p>Smooth a 2D histogram</p></a></li>
<li><a href='#indiumoxide'><p>An X-ray diffractogram.</p></a></li>
<li><a href='#inverse_link'><p>Inverse link function, used for GLM fitting.</p></a></li>
<li><a href='#JOPS_colors'><p>Custom color ramp.</p></a></li>
<li><a href='#JOPS_point'><p>Themeing functions used to unify ggplot features</p></a></li>
<li><a href='#JOPS_theme'><p>Custom theme for ggplot</p></a></li>
<li><a href='#LAPS_dens'><p>Bayesian density estimation</p></a></li>
<li><a href='#Mixture'><p>Mixture Data</p></a></li>
<li><a href='#ova'><p>Ovarian cancer data</p></a></li>
<li><a href='#pclm'><p>Fit a composite link model</p></a></li>
<li><a href='#plot.ps2dglm'><p>Plotting function for <code>ps2DGLM</code></p></a></li>
<li><a href='#plot.ps2dnormal'><p>Plotting function for <code>ps2DNormal</code></p></a></li>
<li><a href='#plot.ps2dsignal'><p>Plotting function for <code>ps2DSignal</code></p></a></li>
<li><a href='#plot.pspfit'><p>Plotting function for <code>psNormal</code>, <code>psPoisson</code>, <code>psBinomial</code></p></a></li>
<li><a href='#plot.pssignal'><p>Plotting function for <code>psSignal</code></p></a></li>
<li><a href='#plot.psvcsignal'><p>Plotting function for <code>psVCSignal</code></p></a></li>
<li><a href='#plot.simpsr'><p>Plotting function for <code>sim_psr</code></p></a></li>
<li><a href='#plot.simvcpsr'><p>Plotting function for <code>sim_vcpsr</code></p></a></li>
<li><a href='#predict.ps2dglm'><p>Predict function for <code>ps2DGLM</code></p></a></li>
<li><a href='#predict.ps2dnormal'><p>Predict function for <code>ps2DNormal</code></p></a></li>
<li><a href='#predict.ps2dsignal'><p>Predict function for <code>ps2DSignal</code></p></a></li>
<li><a href='#predict.pspfit'><p>Predict function for <code>psNormal</code>, <code>psBinomial</code>, <code>psPoisson</code></p></a></li>
<li><a href='#predict.pssignal'><p>Predict function for <code>psSignal</code></p></a></li>
<li><a href='#predict.psvcsignal'><p>Predict function for <code>psVCSignal</code></p></a></li>
<li><a href='#predict.simpsr'><p>Predict function for <code>sim_psr</code></p></a></li>
<li><a href='#predict.simvcpsr'><p>Predict function for <code>sim_vcpsr</code></p></a></li>
<li><a href='#ps2D_PartialDeriv'><p>Partial derivative two-dimensional smoothing scattered (normal)</p>
data using P-splines.</a></li>
<li><a href='#ps2DGLM'><p>Two-dimensional smoothing of scattered normal or non-normal (GLM)</p>
responses using tensor product P-splines.</a></li>
<li><a href='#ps2DNormal'><p>Two-dimensional smoothing scattered (normal) data using P-splines.</p></a></li>
<li><a href='#ps2DSignal'><p>Two-dimensional penalized signal regression using P-splines.</p></a></li>
<li><a href='#psBinomial'><p>Smoothing scattered binomial data using P-splines.</p></a></li>
<li><a href='#psNormal'><p>Smoothing scattered (normal) data using P-splines.</p></a></li>
<li><a href='#psNormal_Deriv'><p>Derivative for a P-spline fit of scattered (normal)</p>
data.</a></li>
<li><a href='#pspline_checker'><p>P-spline checking algorithm for the GLM.</p></a></li>
<li><a href='#pspline_fitter'><p>P-spline fitting algorithm for the GLM.</p></a></li>
<li><a href='#pspline2d_checker'><p>P-spline 2D tensor product checking algorithm for the GLM.</p></a></li>
<li><a href='#psPoisson'><p>Smoothing scattered Poisson data using P-splines.</p></a></li>
<li><a href='#psSignal'><p>Smooth signal (multivariate calibration) regression using P-splines.</p></a></li>
<li><a href='#psVCSignal'><p>Varying-coefficient penalized signal regression using P-splines.</p></a></li>
<li><a href='#rdw'><p>Observations on the widths of red blood cell distributions (RDW).</p></a></li>
<li><a href='#rowtens'><p>Compute the row tensor product of two matrices</p></a></li>
<li><a href='#save_PDF'><p>Save a plot as a PDF file.</p></a></li>
<li><a href='#set_panels'><p>Prepare graphics layout for multiple panels</p></a></li>
<li><a href='#set_window'><p>Open a graphics window.</p></a></li>
<li><a href='#sim_psr'><p>Single-Index signal regression using P-splines</p></a></li>
<li><a href='#sim_vcpsr'><p>Varying-coefficient single-index signal regression using tensor P-splines.</p></a></li>
<li><a href='#SpATS.nogeno'><p>Two-dimensional P-spline smoothing</p></a></li>
<li><a href='#spbase'><p>Compute a sparse B-spline basis on evenly spaced knots</p></a></li>
<li><a href='#Sugar'><p>Sugar Processing Data</p></a></li>
<li><a href='#Suicide'><p>Suicide Data Set</p></a></li>
<li><a href='#tpower'><p>Compute a truncated power function.</p></a></li>
<li><a href='#Varstar'><p>Brightness of a variable star.</p></a></li>
<li><a href='#Woodsurf'><p>Profile of a sanded piece of wood.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Practical Smoothing with P-Splines</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.19</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Paul Eilers &lt;p.eilers@erasmusmc.nl&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions and data to reproduce all plots in the book "Practical Smoothing. 
 The Joys of P-splines" by Paul H.C. Eilers and Brian D. Marx (2021, ISBN:978-1108482950). </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0), SpATS (&ge; 1.0-13)</td>
</tr>
<tr>
<td>Imports:</td>
<td>colorspace, MASS, boot, fds, rpart, ggplot2, fields, spam,
SemiPar, stats, graphics, grDevices</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-04 19:06:10 UTC; peile</td>
</tr>
<tr>
<td>Author:</td>
<td>Paul Eilers [aut, cre],
  Brian Marx [aut],
  Bin Li [aut],
  Jutta Gampe [aut],
  Maria Xose Rodriguez-Alvarez [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-05 09:20:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='JOPS'>Joys of P-Splines</h2><span id='topic+JOPS'></span><span id='topic+JOPS-package'></span>

<h3>Description</h3>

<p>A package for working with and learning about P-splines. P-splines combine B-splines with discrete penalties to build a very flexible and effective smooth models. They can handle non-normal data in the style of generalized linear models.
</p>
<p>This package provides functions for constructing B-spline bases and penalty matrices. It solves the penalized likelihood equations efficiently.
</p>
<p>Several methods are provided to determine the values of penalty  parameters automatically, using cross-validation, AIC, mixed models or fast Bayesian algorithms.
</p>
<p>This package is a companion to the book by Eilers and Marx (2021). The book presents the underlying theory and contains many examples and the code <code>R</code> for each example is available on the website <a href="https://psplines.bitbucket.io">https://psplines.bitbucket.io</a>
</p>


<h3>References</h3>

<p>Eilers, P.H.C. and Marx, B.D. (2021). <em>Practical Smoothing, The Joys of
P-splines.</em> Cambridge University Press.
</p>
<p>Eilers, P.H.C. and Marx, B.D. (1996). Flexible smoothing with
B-splines and penalties (with comments and rejoinder),
<em>Statistical Science</em>, 11: 89-121.
</p>

<hr>
<h2 id='bbase'>Compute a B-spline basis matrix</h2><span id='topic+bbase'></span>

<h3>Description</h3>

<p>Compute a B-spline basis matrix using evenly spaced knots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bbase(x, xl = min(x), xr = max(x), nseg = 10, bdeg = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bbase_+3A_x">x</code></td>
<td>
<p>a vector of argument values, at which the B-spline basis functions
are to be evaluated.</p>
</td></tr>
<tr><td><code id="bbase_+3A_xl">xl</code></td>
<td>
<p>the lower limit of the domain of x; default is <code>min(x)</code>.</p>
</td></tr>
<tr><td><code id="bbase_+3A_xr">xr</code></td>
<td>
<p>the upper limit of the domain of x; default is <code>max(x)</code>.</p>
</td></tr>
<tr><td><code id="bbase_+3A_nseg">nseg</code></td>
<td>
<p>the number of equally sized segments between xl and xr; default is 10.</p>
</td></tr>
<tr><td><code id="bbase_+3A_bdeg">bdeg</code></td>
<td>
<p>the degree of the splines, usually 1, 2, or 3 (default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>xl</code> is larger than <code>min(x)</code>, it will be adjusted to <code>min(x)</code> and a warning wil be given.
If <code>xr</code> is smaller than <code>max(x)</code>, it will be adjusted to <code>max(x)</code> and a warning wil be given.
The values of the design parameters <code>x, xl, xr, ndeg, bdeg</code> and <code>type = 'bbase'</code> are added to the list of attributes of the matrix.
</p>


<h3>Value</h3>

<p>A matrix with  <code>length(x)</code> rows and <code>nseg + bdeg</code> columns.
</p>


<h3>Author(s)</h3>

<p>Paul Eilers and Brian Marx
</p>


<h3>References</h3>

<p>Eilers, P.H.C. and Marx, B.D. (2021). <em>Practical Smoothing, The Joys of
P-splines.</em> Cambridge University Press.
</p>
<p>Eilers, P.H.C. and Marx, B.D. (1996). Flexible smoothing with
B-splines and penalties (with comments and rejoinder), <em>Statistical Science</em>,
11: 89-121.
</p>
<p>Eilers, P.H.C. and B.D. Marx (2010).
Splines, knots and penalties. Wiley Interdisciplinary
Reviews: Computational Statistics. Wiley: NY. DOI: 10.1002/wics.125
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute and plot a B-spline basis matrix
x = seq(0, 360, by = 2)
B = bbase(x, 0, 360, nseg = 8, bdeg = 3)
matplot(x, B, type = 'l', lty = 1, lwd = 2, xlab = 'x', ylab = '')

</code></pre>

<hr>
<h2 id='binit'>Translated number vector to bin index.</h2><span id='topic+binit'></span>

<h3>Description</h3>

<p>Translates number vector to bin index, given lower and
upper limits of the domain and number of bins. A support function
for (smoothing) histograms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binit(x, xmin = min(x), xmax = max(x), nbin = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="binit_+3A_x">x</code></td>
<td>
<p>a numerical vector.</p>
</td></tr>
<tr><td><code id="binit_+3A_xmin">xmin</code></td>
<td>
<p>the lower limit of the domain.</p>
</td></tr>
<tr><td><code id="binit_+3A_xmax">xmax</code></td>
<td>
<p>the upper limit of the domain.</p>
</td></tr>
<tr><td><code id="binit_+3A_nbin">nbin</code></td>
<td>
<p>the number of bins (default=100).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components:
</p>
<table role = "presentation">
<tr><td><code>xbin</code></td>
<td>
<p>a vector of <code>length(x)</code> with elements giving the bin index.</p>
</td></tr>
<tr><td><code>xgrid</code></td>
<td>
<p>a vector of <code>length(nbin)</code> with the midpoints of the bins.</p>
</td></tr>
<tr><td><code>nbin</code></td>
<td>
<p>the number of bins.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Eilers, P.H.C. and Marx, B.D. (2021). <em>Practical Smoothing, The Joys of
P-splines.</em> Cambridge University Press.
</p>

<hr>
<h2 id='bone_data'>Spinal bone relative mineral density</h2><span id='topic+bone_data'></span>

<h3>Description</h3>

<p>Relative spinal bone mineral density measurements on 261 North
American adolescents.  Each value is the difference in <code>spnbmd</code>
taken on two consecutive visits, divided by the average. The age is
the average age over the two visits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bone_data)
</code></pre>


<h3>Format</h3>

<p>A dataframe with four columns:
</p>

<dl>
<dt><code>idnum</code></dt><dd><p>ID of the child</p>
</dd>
<dt><code>age</code></dt><dd><p>age</p>
</dd>
<dt><code>gender</code></dt><dd><p>male or female</p>
</dd>
<dt><code>spnbmd</code></dt><dd><p>Relative Spinal bone mineral density.</p>
</dd>
</dl>



<h3>Source</h3>

<p>https://web.stanford.edu/~hastie/ElemStatLearn/datasets/bone.data
</p>


<h3>References</h3>

<p>Bachrach, L.K., Hastie, T., Wang, M.-C., Narasimhan, B., Marcus, R. (1999). Bone Mineral
Acquisition in Healthy Asian, Hispanic, Black and Caucasian Youth. A
Longitudinal Study. <em>J Clin Endocrinol Metab</em> 84, 4702-12.
</p>
<p>Eilers, P.H.C. and Marx, B.D. (2021). <em>Practical Smoothing, The Joys of
P-splines.</em> Cambridge University Press.
</p>

<hr>
<h2 id='cbase'>Compute a circular B-spline basis matrix</h2><span id='topic+cbase'></span>

<h3>Description</h3>

<p>Computes a circular B-spline basis matrix using evenly spaced knots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cbase(x, xl = min(x), xr = max(x), nseg = 10, bdeg = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cbase_+3A_x">x</code></td>
<td>
<p>a vector of argument values, at which the B-spline basis functions
are to be evaluated.</p>
</td></tr>
<tr><td><code id="cbase_+3A_xl">xl</code></td>
<td>
<p>the lower limit of the domain of x; default is <code>min(x)</code>.</p>
</td></tr>
<tr><td><code id="cbase_+3A_xr">xr</code></td>
<td>
<p>the upper limit of the domain of x; default is <code>max(x)</code>.</p>
</td></tr>
<tr><td><code id="cbase_+3A_nseg">nseg</code></td>
<td>
<p>the number of B-spline segments (default 10) between xl and xr.</p>
</td></tr>
<tr><td><code id="cbase_+3A_bdeg">bdeg</code></td>
<td>
<p>the degree of the basis, usually 1, 2, or 3 (default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>xl</code> is larger than <code>min(x)</code>, it wil be adjusted to <code>min(x)</code> and a warning wil be given.
If <code>xr</code> is smaller than <code>max(x)</code>, it wil be adjusted to <code>max(x)</code> and a warning wil be given.
</p>
<p>The design parameters <code>x, xl, xr, ndeg, bdeg</code> and <code>type = 'cbase'</code> are added to the list of attributes.
</p>
<p>In a circular basis, the B-splines are wrapped around the boundaries of the domain. Use a circular basis for data
like directions or angles. It should be combined with a circular penalty matrix, as computed by <code>cdiff()</code>.
</p>


<h3>Value</h3>

<p>A matrix with <code>length(x)</code> rows and <code>nseg</code> columns.
</p>


<h3>Author(s)</h3>

<p>Paul Eilers and Brian Marx
</p>


<h3>References</h3>

<p>Eilers, P.H.C. and Marx, B.D. (2021). <em>Practical Smoothing, The Joys of
P-splines.</em> Cambridge University Press.
</p>
<p>Eilers, P.H.C., Marx, B.D., and Durban, M.
(2015). Twenty years of P-splines, <em>SORT</em>, 39(2): 149-186.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute and plot a circular B-spline basis matrix
x = seq(0, 360, by = 2)
B = cbase(x, 0, 360, nseg = 8, bdeg = 3)
matplot(x, B, type = 'l', lty = 1, lwd = 2, xlab = 'x', ylab = '')
title('Note how the ends connect smoothly meet at boundaries' )

</code></pre>

<hr>
<h2 id='cdiff'>Compute a second order circular differencing matrix</h2><span id='topic+cdiff'></span>

<h3>Description</h3>

<p>Compute difference matrix used for circular penalities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdiff(n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cdiff_+3A_n">n</code></td>
<td>
<p>number of rows (and columns) of the square differencing matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A square matrix with <code>n</code> rows and columns.
</p>


<h3>Author(s)</h3>

<p>Paul Eilers
</p>


<h3>References</h3>

<p>Eilers, P.H.C. and Marx, B.D. (2021). <em>Practical Smoothing, The Joys of
P-splines.</em> Cambridge University Press.
</p>
<p>Eilers, P.H.C., Marx, B.D., and Durban, M. (2015).
Twenty years of P-splines, <em>SORT</em>, 39(2): 149-186.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compare standard and circular differencing matrix
n = 8
D1 = diff(diag(n), diff = 2)
D2 = cdiff(n)
oldpar = par(no.readonly = TRUE)
on.exit(par(oldpar))
par(mfrow = c(1, 2))
image(t(D1))
title('Linear differencing matrix')
image(t(D2))
title('Circular differencing matrix')


</code></pre>

<hr>
<h2 id='CGHsim'>Simulation of CGH data</h2><span id='topic+CGHsim'></span>

<h3>Description</h3>

<p>A crude simulation of comparative genomic hybridization (CGH) data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(CGHsim)
</code></pre>


<h3>Format</h3>

<p>A data frame with 400 rows and two columns:
</p>

<dl>
<dt><code>y</code></dt><dd><p>Log R ratio</p>
</dd>
<dt><code>x</code></dt><dd><p>Genomic position (but in fact the row number).</p>
</dd>
</dl>



<h3>Source</h3>

<p>The simulation program could not be located anymore. But the data have a very simple structure.
</p>

<hr>
<h2 id='clone_base'>Clone a B-spline basis for new x</h2><span id='topic+clone_base'></span>

<h3>Description</h3>

<p>Extract basis parameters from an existing B-splines basis matrix,
and use them for computing a new basis at new values of <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clone_base(B, x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clone_base_+3A_b">B</code></td>
<td>
<p>a B-splines basis matrix, computed with <code>bbase()</code> or <code>cbase()</code>.</p>
</td></tr>
<tr><td><code id="clone_base_+3A_x">x</code></td>
<td>
<p>a vector of new argument values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If values in <code>x</code> are outside the domain used for computing <code>B</code>, they will be discarded, with a warning.
</p>


<h3>Value</h3>

<p>A matrix with number of rows=<code>length(xnew)</code>.
</p>


<h3>Author(s)</h3>

<p>Paul Eilers
</p>


<h3>References</h3>

<p>Eilers, P.H.C. and Marx, B.D. (2021). <em>Practical Smoothing, The Joys of
P-splines.</em> Cambridge University Press.
</p>
<p>Eilers, P.H.C., Marx, B.D., and Durban, M.
(2015). Twenty years of P-splines, <em>SORT</em>, 39(2): 149-186.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x = seq(0, 10, length = 20)
n = length(x)
y = sin(x / 2) + rnorm(n) * 0.2
B = bbase(x)
nb = ncol(B)
D = diff(diag(nb), diff = 2)
lambda = 1
a = solve(t(B) %*% B + lambda * t(D)%*% D, t(B) %*% y)
# Clone basis on finer grid
xg = seq(0, 10, length = 200)
Bg = clone_base(B, xg)
yg = Bg %*% a
plot(x, y)
lines(xg, yg, col = 'blue')

</code></pre>

<hr>
<h2 id='Complaints'>Environmental complaints from the Rijnomond area of The Netherlands</h2><span id='topic+Complaints'></span>

<h3>Description</h3>

<p>Environmental complaints about odors from the Rijnmond region (near Rotterdam in the Netherlands) in 1988.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Complaints)
</code></pre>


<h3>Format</h3>

<p>A dataframe with two columns:
</p>

<dl>
<dt><code>freq</code></dt><dd><p>The daily number of complaints.</p>
</dd>
<dt><code>count</code></dt><dd><p>The number of days the specific complaint frequency occurred.</p>
</dd>
</dl>



<h3>Details</h3>

<p>In 1988, the Rijnmond Environmental Agency registered approximately 20,000
complaints about odors from regional inhabitants.
</p>


<h3>Source</h3>

<p>Personal information from Paul Eilers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(Complaints$freq, Complaints$count, type = 'h',
xlab = 'Number of complaints per day', ylab = 'Frequency')
</code></pre>

<hr>
<h2 id='count2d'>Create a matrix of counts.</h2><span id='topic+count2d'></span>

<h3>Description</h3>

<p>Count the number of occurrences of pairs of positive integers in two vectors,
producing a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count2d(xb, yb, nb)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="count2d_+3A_xb">xb</code></td>
<td>
<p>a vector of integers.</p>
</td></tr>
<tr><td><code id="count2d_+3A_yb">yb</code></td>
<td>
<p>a vector of integers.</p>
</td></tr>
<tr><td><code id="count2d_+3A_nb">nb</code></td>
<td>
<p>a vector of length 2 that provides the number of bins for the 2D histogram on <code>x</code> and <code>y</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function builds a two-dimensional histogram, based on two two vectors of bin numbers (obtained
with <code>binit</code>). Rows where <code>x[i] &gt; nb[1]</code>  or <code>y[i] &gt; nb[2]</code> are discarded without a warning.
</p>


<h3>Value</h3>

<p>A matrix with <code>nb[1]</code> rows and <code>nb[2]</code> columns with counts.
It serves as the input for two-dimensional histogram smoothing.
</p>

<hr>
<h2 id='dev_calc'>Deviance calculation for GLM P-spline fitting.</h2><span id='topic+dev_calc'></span>

<h3>Description</h3>

<p>Calculates the deviance and returns the ML estimated dispersion parameter
for a variety of response distributions for P-spline fitting within the GLM framework.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dev_calc(
  family = "gaussian",
  y,
  mu,
  m_binomial = 0 * y + 1,
  r_gamma = 0 * y + 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dev_calc_+3A_family">family</code></td>
<td>
<p>the response distribution, e.g. <code>"gaussian", "binomial", "poisson", "Gamma"</code> distribution. Quotes are needed; default <code>"family = gaussian"</code>.</p>
</td></tr>
<tr><td><code id="dev_calc_+3A_y">y</code></td>
<td>
<p>the glm response vector of length <code>m</code>.</p>
</td></tr>
<tr><td><code id="dev_calc_+3A_mu">mu</code></td>
<td>
<p>the P-spline estimated mean for the glm response vector of length <code>m</code>.</p>
</td></tr>
<tr><td><code id="dev_calc_+3A_m_binomial">m_binomial</code></td>
<td>
<p>a vector of binomial trials having <code>length(y)</code>, when <code>family = "binomial"</code>. Default is 1 vector.</p>
</td></tr>
<tr><td><code id="dev_calc_+3A_r_gamma">r_gamma</code></td>
<td>
<p>a vector of gamma shape parameters, when <code>family = "Gamma"</code>. Default is 1 vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two fields:
</p>
<table role = "presentation">
<tr><td><code>dev</code></td>
<td>
<p>the estimated deviance.</p>
</td></tr>
<tr><td><code>dispersion_parm</code></td>
<td>
<p>the ML estimated dispersion parameter.</p>
</td></tr>
</table>

<hr>
<h2 id='Disks'>Prices of hard disk drives</h2><span id='topic+Disks'></span>

<h3>Description</h3>

<p>Prices and capacities of hard disk drives,
as advertised in a Dutch computer monthly in 1999.
Prices are given in Dutch guilders; the Euro did not yet exist.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Disks)
</code></pre>


<h3>Format</h3>

<p>A dataframe with six columns:
</p>

<dl>
<dt><code>Year</code></dt><dd><p>1999-2000</p>
</dd>
<dt><code>Month</code></dt><dd><p>month, 1-12</p>
</dd>
<dt><code>Size</code></dt><dd><p>capacity in Gb</p>
</dd>
<dt><code>Buffer</code></dt><dd><p>buffer size (Mb)</p>
</dd>
<dt><code>RPM</code></dt><dd><p>rotating speed (rpm)</p>
</dd>
<dt><code>PriceDG</code></dt><dd><p>in Dutch Guilders, divide by 2.2 for Euro.</p>
</dd></dl>



<h3>Source</h3>

<p>Personal information from Paul Eilers.
</p>

<hr>
<h2 id='ECG'>A section of an ECG (electrocardiogram)</h2><span id='topic+ECG'></span>

<h3>Description</h3>

<p>The data set includes two signals, respiration and the ECG.
Both signals are distorted by strong 60Hz interference from the mains power.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ECG)
</code></pre>


<h3>Format</h3>

<p>A data frame with three columns:
</p>

<dl>
<dt>time</dt><dd><p>time in seconds</p>
</dd>
<dt>resp</dt><dd><p>respiration, arbitrary units</p>
</dd>
<dt>ecg</dt><dd><p>ECG, arbitrary units.</p>
</dd>
</dl>



<h3>Source</h3>

<p>https://physionet.org/content/fantasia/1.0.0/
</p>


<h3>References</h3>

<p>Iyengar N, Peng C-K, Morin R, Goldberger AL, Lipsitz LA.
Age-related alterations in the fractal scaling of cardiac interbeat interval dynamics.
<em>Am J Physiol</em>, 1996; 271: 1078-1084.
</p>
<p>Standard citation for PhysioNet:
Goldberger AL, Amaral LAN, Glass L, Hausdorff JM, Ivanov PCh, Mark RG, Mietus JE, Moody GB, Peng C-K, Stanley HE.
PhysioBank, PhysioToolkit, and PhysioNet: Components of a New Research Resource for Complex Physiologic Signals (2003).
Circulation. 101(23):e215-e220.
</p>

<hr>
<h2 id='fitampl'>Fit amplitude coeffcients in the bundle model for expectiles</h2><span id='topic+fitampl'></span>

<h3>Description</h3>

<p>There are two functions for fitting the expectile bundle model, one for estimating asymmetry parameters (<code>fitasy</code>),
the other for estimating the amplitude function, <code>fitampl</code>, this function. See the details below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitampl(y, B, alpha, p, a, pord = 2, lambda)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitampl_+3A_y">y</code></td>
<td>
<p>a response vector.</p>
</td></tr>
<tr><td><code id="fitampl_+3A_b">B</code></td>
<td>
<p>a proper B-spline basis matrix, see <code>bbase()</code>.</p>
</td></tr>
<tr><td><code id="fitampl_+3A_alpha">alpha</code></td>
<td>
<p>a vector of B-spline coefficients.</p>
</td></tr>
<tr><td><code id="fitampl_+3A_p">p</code></td>
<td>
<p>a vector of asymmetries.</p>
</td></tr>
<tr><td><code id="fitampl_+3A_a">a</code></td>
<td>
<p>a vector of asymmetry parameters.</p>
</td></tr>
<tr><td><code id="fitampl_+3A_pord">pord</code></td>
<td>
<p>the order of the difference penalty, default is 2.</p>
</td></tr>
<tr><td><code id="fitampl_+3A_lambda">lambda</code></td>
<td>
<p>the positive tuning parameter for the penalty.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The expectile bundle model determines a set of expectile curves for a point cloud with data vectors <code>x</code> and <code>y</code>,
as <code class="reqn">\psi_j{x_i} = a_j g(x_i)</code>. Here <code class="reqn">a_j</code> is the asymmetry parameter corresponding to a given asymmetry <code class="reqn">p_j</code>.
A vector of asymmetries with all <code class="reqn">0 &lt;p_j &lt; 1</code> is specified by the user.
</p>
<p>The asymmetric least squares objective function is
</p>
<p style="text-align: center;"><code class="reqn">\sum_j \sum_i w_{ij}(y_i - \sum_j a_j g_j(x_i))^2.</code>
</p>

<p>The function <code class="reqn">g(\cdot)</code> is called the amplitude. The weights depend on the residuals:
</p>
<p style="text-align: center;"><code class="reqn">w_{ij} = p_j</code>
</p>
<p> if <code class="reqn">y_i &gt; a_jg(x_i)</code> and <code class="reqn">w_{ij} = 1- p_j</code> otherwise.
</p>
<p>The amplitude function is a sum of B-splines with coefficients <code>alpha</code>. There is no direct solution, so <code>alpha</code>
and the asymmetry parameters <code>a</code> must be updated alternatingly. See the example.
</p>


<h3>Value</h3>

<p>a vector of estimated B-spline coefficients.
</p>


<h3>Note</h3>

<p>This is a simplification of the model described in the reference. There is no explict term for the trend.
</p>


<h3>Author(s)</h3>

<p>Paul Eilers
</p>


<h3>References</h3>

<p>Schnabel, S.K. and Eilers, P.H.C. (2013) A location-scale model for non-crossing expectile curves. <em>Stat</em> 2: 171–183.
</p>
<p>Eilers, P.H.C. and Marx, B.D. (2021). <em>Practical Smoothing, The Joys of
P-splines.</em> Cambridge University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get the data
data(bone_data)
x = bone_data$age
y = bone_data$spnbmd
m &lt;- length(x)

# Set asymmetry levels
p = c(0.005, 0.01, 0.02, 0.05, 0.2, 0.5, 0.8, 0.9, 0.95, 0.98, 0.99, 0.995)
np &lt;- length(p)

# Set P-spline parameters
x0 &lt;- 5
x1 &lt;- 30
ndx &lt;- 20
bdeg &lt;- 3
pord &lt;- 2

# Compute bases
B &lt;- bbase(x, x0, x1, ndx, bdeg)
xg &lt;- seq(from = min(x), to = max(x), length = 100)
Bg &lt;- clone_base(B, xg)
n &lt;- ncol(B)

lambda = 1
alpha &lt;- rep(1,n)
a = p
for (it in 1:20){
  alpha &lt;- fitampl(y, B, alpha, p, a, pord, lambda)
  alpha &lt;- alpha / sqrt(mean(alpha ^ 2))
  anew &lt;- fitasy(y, B, alpha, p, a)
  da = max(abs(a - anew))
  a = anew
  cat(it, da, '\n')
     if (da &lt; 1e-6) break
}

# Compute bundle on grid
ampl &lt;- Bg %*% alpha
Z &lt;- ampl %*% a

# Plot data and bundle
plot(x, y, pch = 15, cex = 0.7, col = 'grey', xlab = 'Age', ylab = 'Density')
cols = colorspace::rainbow_hcl(np, start = 10, end = 350)
matlines(xg, Z, lty = 1, lwd = 2, col = cols)

</code></pre>

<hr>
<h2 id='fitasy'>Fit asymmetry parameters in the expectile bundle model</h2><span id='topic+fitasy'></span>

<h3>Description</h3>

<p>There are two functions for fitting the expectile bundle model, the present one for estimating asymmetry parameters (<code>fitasy</code>),
the other for estimating the amplitude function, <code>fitampl</code>. See the details below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitasy(y, B, b, p, c0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitasy_+3A_y">y</code></td>
<td>
<p>a response vector.</p>
</td></tr>
<tr><td><code id="fitasy_+3A_b">B</code></td>
<td>
<p>a proper B-spline basis matrix, see <code>bbase()</code>.</p>
</td></tr>
<tr><td><code id="fitasy_+3A_b">b</code></td>
<td>
<p>a vector of B-spline coefficients.</p>
</td></tr>
<tr><td><code id="fitasy_+3A_p">p</code></td>
<td>
<p>a vector of asymmetries with values between  0 and 1.</p>
</td></tr>
<tr><td><code id="fitasy_+3A_c0">c0</code></td>
<td>
<p>a vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The expectile bundle model determines a set of expectile curves for a point cloud with data vectors <code>x</code> and <code>y</code>,
as <code class="reqn">\psi_j{x_i} = a_j g(x_i)</code>. Here <code class="reqn">a_j</code> is the asymmetry parameter corresponding to a given asymmetry <code class="reqn">p_j</code>.
A vector of asymmetries with all <code class="reqn">0 &lt;p_j &lt; 1</code> is specified by the user.
</p>
<p>The asymmetric least squares objective function is
</p>
<p style="text-align: center;"><code class="reqn">\sum_j \sum_i w_{ij}(y_i - \sum_j a_j g_j(x_i))^2.</code>
</p>

<p>The function <code class="reqn">g(\cdot)</code> is called the amplitude. The weights depend on the residuals:
</p>
<p style="text-align: center;"><code class="reqn">w_{ij} = p_j</code>
</p>
<p> if <code class="reqn">y_i &gt; a_jg(x_i)</code> and <code class="reqn">w_{ij} = 1- p_j</code> otherwise.
</p>
<p>The amplitude function is a sum of B-splines with coefficients <code>alpha</code>. There is no direct solution, so <code>alpha</code>
and the asymmetry parameters <code>a</code> must be updated alternatingly. See the example.
</p>


<h3>Value</h3>

<p>a vector of estimated asymmetry parameters .
</p>


<h3>Note</h3>

<p>This is a simplification of the model described in the reference. There is no explict term for the trend.
</p>


<h3>Author(s)</h3>

<p>Paul Eilers
</p>


<h3>References</h3>

<p>Schnabel, S.K. and Eilers, P.H.C. (2013) A location-scale model for non-crossing expectile curves. <em>Stat</em> 2: 171–183.
</p>
<p>Eilers, P.H.C. and Marx, B.D. (2021). <em>Practical Smoothing, The Joys of
P-splines.</em> Cambridge University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get the data
data(bone_data)
x = bone_data$age
y = bone_data$spnbmd
m &lt;- length(x)

# Set asymmetry levels
p = c(0.005, 0.01, 0.02, 0.05, 0.2, 0.5, 0.8, 0.9, 0.95, 0.98, 0.99, 0.995)
np &lt;- length(p)

# Set P-spline parameters
x0 &lt;- 5
x1 &lt;- 30
ndx &lt;- 20
bdeg &lt;- 3
pord &lt;- 2

# Compute bases
B &lt;- bbase(x, x0, x1, ndx, bdeg)
xg &lt;- seq(from = min(x), to = max(x), length = 100)
Bg &lt;- clone_base(B, xg)
n &lt;- ncol(B)

lambda = 1
alpha &lt;- rep(1,n)
a = p
for (it in 1:20){
  alpha &lt;- fitampl(y, B, alpha, p, a, pord, lambda)
  alpha &lt;- alpha / sqrt(mean(alpha ^ 2))
  anew &lt;- fitasy(y, B, alpha, p, a)
  da = max(abs(a - anew))
  a = anew
  cat(it, da, '\n')
     if (da &lt; 1e-6) break
}

# Compute bundle on grid
ampl &lt;- Bg %*% alpha
Z &lt;- ampl %*% a

# Plot data and bundle
plot(x, y, pch = 15, cex = 0.7, col = 'grey', xlab = 'Age', ylab = 'Density')
cols = colorspace::rainbow_hcl(np, start = 10, end = 350)
matlines(xg, Z, lty = 1, lwd = 2, col = cols)


</code></pre>

<hr>
<h2 id='G519C18'>Chromosome G519C18 data</h2><span id='topic+G519C18'></span>

<h3>Description</h3>

<p>An extract of the data set <code>G519</code> in the Bioconductor package <code>Vega</code>, for chromosome 18.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(G519C18)
</code></pre>


<h3>Format</h3>

<p>A dataframe with two columns:
</p>

<dl>
<dt><code>y</code></dt><dd><p>Probe position</p>
</dd>
<dt><code>x</code></dt><dd><p>Log R Ratio</p>
</dd></dl>
<p>. 
</p>


<h3>References</h3>

<p>https://www.bioconductor.org/packages/release/bioc/html/Vega.html
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(G519C18$x, G519C18$y, type = 'l', ylab = 'LRR', xlab = 'Position', main = 'Chromosome 18')
</code></pre>

<hr>
<h2 id='Greece_deaths'>Deaths in Greece in 1960.</h2><span id='topic+Greece_deaths'></span>

<h3>Description</h3>

<p>Deaths in Greece in 1960.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Greece_deaths)
</code></pre>


<h3>Format</h3>

<p>A dataframe with three columns:
</p>

<dl>
<dt><code>Age</code></dt><dd><p>0 - 85</p>
</dd>
<dt><code>Male</code></dt><dd><p>male deaths</p>
</dd>
<dt><code>Female</code></dt><dd><p>female deaths.</p>
</dd>
</dl>



<h3>Details</h3>

<p>All counts for ages above 84 have been grouped to one number for age 85.
</p>


<h3>Source</h3>

<p>Personal information from Aris Perperoglou.
</p>

<hr>
<h2 id='Hepatitis'>Prevalence of Hepatitis among a sample of Bulgarian males.</h2><span id='topic+Hepatitis'></span>

<h3>Description</h3>

<p>Prevalence of Hepatitis among a sample of Bulgarian males.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Hepatitis)
</code></pre>


<h3>Format</h3>

<p>A data frame with three columns:
</p>

<dl>
<dt><code>Age</code></dt><dd><p>years</p>
</dd>
<dt><code>Infected</code></dt><dd><p>number of infected persons</p>
</dd>
<dt><code>Sampled</code></dt><dd><p>number of sampled persons.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Table 2 in Keiding (1991).
</p>


<h3>References</h3>

<p>N. Keiding (1991) Age-Specific Incidence and Prevalence: A Statistical Perspective.
<em>JRSS-A</em> 154, 371-396.
</p>

<hr>
<h2 id='hist2d'>Compute a 2D histogram</h2><span id='topic+hist2d'></span>

<h3>Description</h3>

<p>Compute a two-dimesnional histogram from two vectors (of the same length), <code>x</code> and <code>y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hist2d(x, y, nb = c(100, 100), xlim = range(x), ylim = range(y))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hist2d_+3A_x">x</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
<tr><td><code id="hist2d_+3A_y">y</code></td>
<td>
<p>a numeric vector of the same length as <code>x</code>.</p>
</td></tr>
<tr><td><code id="hist2d_+3A_nb">nb</code></td>
<td>
<p>a vector <code>c(nbx, nby)</code>, or a scalar <code>nb</code>, providing the number of bins for x, and y; default is 100; see details.</p>
</td></tr>
<tr><td><code id="hist2d_+3A_xlim">xlim</code></td>
<td>
<p>a vector <code>c(xmin, xmax)</code> containing the limits of the domain of <code>x</code>; default <code>range(x)</code>.</p>
</td></tr>
<tr><td><code id="hist2d_+3A_ylim">ylim</code></td>
<td>
<p>a vector <code>c(ymin, ymax)</code> containing the limits of the domain of <code>y</code>; default <code>range(y)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>nb</code> is scalar, it is extended to <code>c(nb, nb)</code>, so that both dimensions will have the same number of bins.
</p>
<p>Elements of <code>x</code> (<code>y</code>) that fall outside the range specified by <code>xlim</code> (<code>ylim</code>) are not counted.
</p>


<h3>Value</h3>

<p>A list with components:
</p>
<table role = "presentation">
<tr><td><code>H</code></td>
<td>
<p>a matrix of dimension <code>nbx</code> by <code>nby</code> containing bin counts.</p>
</td></tr>
<tr><td><code>xgrid</code></td>
<td>
<p>a vector of length <code>nbx</code> representing centers of the bins for <code>x</code>.</p>
</td></tr>
<tr><td><code>ygrid</code></td>
<td>
<p>a vector of length <code>nby</code> representing centers of the bins for <code>y</code>.</p>
</td></tr>
<tr><td><code>xbin</code></td>
<td>
<p>a vector giving the bin number of each element of <code>x</code>.</p>
</td></tr>
<tr><td><code>ybin</code></td>
<td>
<p>a vector giving the bin number of each element of <code>y</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Eilers, P.H.C. and Marx, B.D. (2021). <em>Practical Smoothing, The Joys of
P-splines.</em> Cambridge University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(faithful)
x = faithful$eruptions
y = faithful$waiting
C = hist2d(x, y, c(50,50))
image(C$xgrid, C$ygrid, C$H, xlab='Eruption length (min)', ylab='Waiting time (min)')
title('Old Faithful geyser')

</code></pre>

<hr>
<h2 id='hist2dsm'>Smooth a 2D histogram</h2><span id='topic+hist2dsm'></span>

<h3>Description</h3>

<p>Fit a 2D smooth P-spline surface to a matrix of counts, assuming Poisson distributed observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hist2dsm(
  Y,
  nsegx = 10,
  nsegy = nsegx,
  bdeg = 3,
  lambdax = 10,
  lambday = lambdax,
  dx = 3,
  dy = dx,
  Mu = Y + 0.01,
  kappa = 1e-04,
  tol = 1e-05
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hist2dsm_+3A_y">Y</code></td>
<td>
<p>a matrix of counts.</p>
</td></tr>
<tr><td><code id="hist2dsm_+3A_nsegx">nsegx</code></td>
<td>
<p>the number of knots along <code>x</code> (default=10).</p>
</td></tr>
<tr><td><code id="hist2dsm_+3A_nsegy">nsegy</code></td>
<td>
<p>the number of evenly spaced knots along <code>y</code> for Tensor product B-spline basis (default=10).</p>
</td></tr>
<tr><td><code id="hist2dsm_+3A_bdeg">bdeg</code></td>
<td>
<p>the degree of the basis, default is 3.</p>
</td></tr>
<tr><td><code id="hist2dsm_+3A_lambdax">lambdax</code></td>
<td>
<p>the positive number for the tuning parameter along <code>x</code>.</p>
</td></tr>
<tr><td><code id="hist2dsm_+3A_lambday">lambday</code></td>
<td>
<p>the positive number for the tuning parameter along <code>y</code>.</p>
</td></tr>
<tr><td><code id="hist2dsm_+3A_dx">dx</code></td>
<td>
<p>the order of the difference penalty along <code>x</code>, default is 3.</p>
</td></tr>
<tr><td><code id="hist2dsm_+3A_dy">dy</code></td>
<td>
<p>the order of the difference penalty along <code>y</code>, default is 3.</p>
</td></tr>
<tr><td><code id="hist2dsm_+3A_mu">Mu</code></td>
<td>
<p>the initialization of the mean (default <code>Y + 0.01</code>).</p>
</td></tr>
<tr><td><code id="hist2dsm_+3A_kappa">kappa</code></td>
<td>
<p>a (small, positive) number for ridge tuning parameter to stabilize estimation (default <code>1e-4</code>).</p>
</td></tr>
<tr><td><code id="hist2dsm_+3A_tol">tol</code></td>
<td>
<p>the convergence criterion (default <code>1e-5</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements:
</p>
<table role = "presentation">
<tr><td><code>ed</code></td>
<td>
<p>the effective dimension of the smooth 2D surface.</p>
</td></tr>
<tr><td><code>Mu</code></td>
<td>
<p>a matrix with the smooth estimates, with dimensions of <code>dim(Y)</code></p>
</td></tr>
<tr><td><code>pen</code></td>
<td>
<p>the numerical value of the penalty.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paul Eilers
</p>


<h3>References</h3>

<p>Eilers, P.H.C., Marx, B.D., and Durban, M. (2015).
Twenty years of P-splines, <em>SORT</em>, 39(2): 149-186.
</p>
<p>Eilers, P.H.C. and Marx, B.D. (2021). <em>Practical Smoothing, The Joys of
P-splines.</em> Cambridge University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = faithful$eruptions
y = faithful$waiting
h = hist2d(x, y, c(100, 100))
sm = hist2dsm(h$H, nsegx = 25, nsegy = 25, bdeg = 3, lambdax = 10, lambday = 10)
image(h$xgrid, h$ygrid, sm$Mu, xlab = 'Eruption length (min)',
      ylab = 'Waiting time (min)', main = 'Old Faithful')

</code></pre>

<hr>
<h2 id='indiumoxide'>An X-ray diffractogram.</h2><span id='topic+indiumoxide'></span>

<h3>Description</h3>

<p>An X-ray diffractogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(indiumoxide)
</code></pre>


<h3>Format</h3>

<p>A matrix with two columns:
</p>

<dl>
<dt><code>angle</code></dt><dd><p>the angles (degrees) of diffraction</p>
</dd>
<dt><code>count</code></dt><dd><p>corresponding photon counts.</p>
</dd>
</dl>



<h3>Details</h3>

<p>An X-ray diffractogram of Indium-Tin oxide.
</p>
<p>These data have been taken from the source of package <code>Diffractometry</code>,
which is no longer available from CRAN in binary form.
</p>


<h3>Source</h3>

<p>P.L. Davies, U. Gather, M. Meise, D. Mergel, T. Mildenberger (2008).
Residual based localization and quantification of peaks in x-ray diffractograms,
<em>Annals of Applied Statistics</em>, Vol. 2, No. 3, 861-886.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>angle = indiumoxide[,1]
photon = indiumoxide[,2]
plot(angle, type = 'l', photon, xlab = 'Angle', ylab = 'Photon count')
</code></pre>

<hr>
<h2 id='inverse_link'>Inverse link function, used for GLM fitting.</h2><span id='topic+inverse_link'></span>

<h3>Description</h3>

<p>Inverse link function, used for GLM fitting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inverse_link(x, link)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inverse_link_+3A_x">x</code></td>
<td>
<p>scalar, vector, or matrix input.</p>
</td></tr>
<tr><td><code id="inverse_link_+3A_link">link</code></td>
<td>
<p>the link function, one of <code>"identity"</code>, <code>"log"</code>, <code>"sqrt"</code>,
<code>"logit"</code>, <code>"probit"</code>, <code>"cloglog"</code>, <code>"loglog"</code>, <code>"reciprocal"</code>;
quotes are needed (default <code>"identity"</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The inverse link function applied to <code>x</code>.
If <code>link</code> is not in the above list of allowed  names, <code>NULL</code> will be returned.
</p>

<hr>
<h2 id='JOPS_colors'>Custom color ramp.</h2><span id='topic+JOPS_colors'></span>

<h3>Description</h3>

<p>Custom color ramp.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>JOPS_colors(n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="JOPS_colors_+3A_n">n</code></td>
<td>
<p>number of steps.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>custom color ramp.
</p>


<h3>References</h3>

<p>Eilers, P.H.C. and Marx, B.D. (2021). <em>Practical Smoothing, The Joys of
P-splines.</em> Cambridge University Press.
</p>

<hr>
<h2 id='JOPS_point'>Themeing functions used to unify ggplot features</h2><span id='topic+JOPS_point'></span>

<h3>Description</h3>

<p>Custom size and color of points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>JOPS_point(s_size = 1.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="JOPS_point_+3A_s_size">s_size</code></td>
<td>
<p>point size parameter for ggplot2 (default = 1.5).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>themeing function for ggplot2 features.
</p>

<hr>
<h2 id='JOPS_theme'>Custom theme for ggplot</h2><span id='topic+JOPS_theme'></span>

<h3>Description</h3>

<p>Set a ggplot theme in black and white, with centered titles.
</p>
<p>Set a ggplot theme in black and white, with centered titles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>JOPS_theme(h_just = 0.5)

JOPS_theme(h_just = 0.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="JOPS_theme_+3A_h_just">h_just</code></td>
<td>
<p>horizontal justification for ggplot2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>custom theme for ggplot.
</p>
<p>Custom theming function used to unify ggplot features.
</p>


<h3>References</h3>

<p>Eilers, P.H.C. and Marx, B.D. (2021). <em>Practical Smoothing, The Joys of
P-splines.</em> Cambridge University Press.
</p>
<p>Eilers, P.H.C. and Marx, B.D. (2021). <em>Practical Smoothing, The Joys of
P-splines.</em> Cambridge University Press.
</p>

<hr>
<h2 id='LAPS_dens'>Bayesian density estimation</h2><span id='topic+LAPS_dens'></span>

<h3>Description</h3>

<p>Bayesian density estimation with P-splines and Laplace approximation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LAPS_dens(B, P, y, loglambdas, tol = 1e-05, mon = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LAPS_dens_+3A_b">B</code></td>
<td>
<p>matrix (<code>m</code> by <code>n</code>) with B-spline basis, see <code>bbase()</code>.</p>
</td></tr>
<tr><td><code id="LAPS_dens_+3A_p">P</code></td>
<td>
<p>penalty matrix (<code>n</code> by <code>n</code>).</p>
</td></tr>
<tr><td><code id="LAPS_dens_+3A_y">y</code></td>
<td>
<p>vector (length <code>m</code>) of counts, usually a histogram.</p>
</td></tr>
<tr><td><code id="LAPS_dens_+3A_loglambdas">loglambdas</code></td>
<td>
<p>a vector of values of logarithms of <code>lambda</code> to explore.</p>
</td></tr>
<tr><td><code id="LAPS_dens_+3A_tol">tol</code></td>
<td>
<p>convergence tolerance (relative change in coefficients), default <code>1e-5</code>.</p>
</td></tr>
<tr><td><code id="LAPS_dens_+3A_mon">mon</code></td>
<td>
<p>TRUE or FALSE to monitor the iteration history (default FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The B-spline basis should be based on the midpoints of the histogram bins.
See the example below.
This function is based on the paper of Gressani and Lambert (2018) and code input by Oswaldo Gressani.
</p>


<h3>Value</h3>

<p>A list with elements:
</p>
<table role = "presentation">
<tr><td><code>alpha</code></td>
<td>
<p>P-spline coefficients of length <code>n</code>.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>weights from the Laplace approximation, which sum to 1 and are
the same length as <code>loglambdas</code>.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>a vector of length <code>m</code> of expected values.</p>
</td></tr>
<tr><td><code>Cov</code></td>
<td>
<p>covariance matrix (<code>m</code> by <code>m</code>) of <code>log(mu)</code>.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>the penalty parameter.</p>
</td></tr>
<tr><td><code>ed</code></td>
<td>
<p>the effective model dimension.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paul Eilers
</p>


<h3>References</h3>

<p>Eilers, P.H.C. and Marx, B.D. (2021). <em>Practical Smoothing, The Joys of
P-splines.</em> Cambridge University Press.
</p>
<p>Gressani, O. and Lambert, P. (2018).
Fast Bayesian inference using Laplace approximations in a flexible promotion time cure model based on P-splines.
<em>Computational Statistics and Data Analysis</em> 124, 151-167.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Smoothing a histogram of Old Faithful eruption durations
data(faithful)
durations = faithful[, 1]  # Eruption length

# Histogram with narrow bin widths
bw = 0.05
hst = hist(durations, breaks = seq(1, 6, by = bw), plot = TRUE)
x = hst$mids
y = hst$counts

# B-spline basis matrices, for fitting and plotting
nseg = 30
B = bbase(x, nseg = nseg)
xg = seq(min(x), max(x), by = 0.01)
Bg = bbase(xg, nseg = nseg)
n = ncol(B)

# Penalty matrix
D2 = diff(diag(n), diff = 2)
P2 = t(D2) %*% D2

# Fit the model
loglambs = seq(-1, 2, by = 0.05)
laps2 = LAPS_dens(B, P2, y, loglambs, mon = FALSE)
fhat2 = exp(Bg %*% laps2$alpha)
lines(xg, fhat2, col = "blue", lwd = 2)
</code></pre>

<hr>
<h2 id='Mixture'>Mixture Data</h2><span id='topic+Mixture'></span>

<h3>Description</h3>

<p>The mixture data were obtained in an unpublished experiment in
2001 by Zhenyu Wang at University of Amsterdam, under the
supervision of Age Smilde. We are grateful for the permission
to use the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Mixture)
</code></pre>


<h3>Format</h3>

<p>A list consisting of the following:
</p>

<dl>
<dt><code>fractions</code></dt><dd><p>a 34 x 3 matrix of mixure fractions (rows sum to unity):
<code>Water</code> (subboiled demi water (self made)),
<code>1,2ethanediol</code> (99.8% Sigma-Aldrich Germany),
<code>3amino1propanol</code> (99% Merk Schuchardt Germany)</p>
</dd>
<dt><code>xspectra</code></dt><dd><p>spectra array, 34 (observations) x 401 (wavelenths
channels) x 12 (temperatures (C):
30, 35, 37.5, 40, 45, 47.5, 50, 55, 60, 62.5, 65, 70 )</p>
</dd>
<dt><code>wl</code></dt><dd><p>wavelengths for the spectra, 700 to 1100 (nm), by 1nm.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The following instruments and chemicals were used in the
experiment: HP 8453 spectrophotometer (Hewlett-Packard, Palo
Alto, CA); 2cm closed quartz cuvette with glass thermostatable
jacket; Pt-100 temperature sensor; Neslab microprocessor EX-111 circulator bath;
UV-visible Chemstation software (Rev A.02.04) on a
Hewlett-Packard Vectra XM2 PC.
</p>


<h3>References</h3>

<p>Eilers, P. H. C., and Marx, B. D. (2003). Multivariate calibration with temperature interaction
using two-dimensional penalized signal regression. <em>Chemometrics and
Intellegent Laboratory Systems</em>, 66, 159–174.
</p>
<p>Marx, B. D., Eilers, P. H. C., and Li, B. (2011). Multidimensional single-index signal
regression. <em>Chemometrics and Intelligent Laboratory Systems</em>, 109(2), 120–130.
[see the Appendix within]
</p>
<p>Zhenyou Wang and Age Smilde, Univeristy of Amsterdam,
The Netherlands. Personal communication.
</p>

<hr>
<h2 id='ova'>Ovarian cancer data</h2><span id='topic+ova'></span>

<h3>Description</h3>

<p>Ovarian cancer data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ova)
</code></pre>


<h3>Format</h3>

<p>A dataframe with five columns:
</p>

<dl>
<dt><code>Diameter</code></dt><dd></dd>
<dt><code>FIGO</code></dt><dd></dd>
<dt><code>Karnofsky</code></dt><dd></dd>
<dt><code>time</code></dt><dd></dd>
<dt><code>death</code></dt><dd><p>death</p>
</dd>
</dl>



<h3>Source</h3>

<p>tba
</p>

<hr>
<h2 id='pclm'>Fit a composite link model</h2><span id='topic+pclm'></span>

<h3>Description</h3>

<p>Fit a smooth latent distribution using the penalized composite link model (PCLM).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pclm(y, C, B, lambda = 1, pord = 2, itmax = 50, show = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pclm_+3A_y">y</code></td>
<td>
<p>a vector of counts, length <code>m</code>.</p>
</td></tr>
<tr><td><code id="pclm_+3A_c">C</code></td>
<td>
<p>a composition matrix, <code>m</code> by <code>q</code>.</p>
</td></tr>
<tr><td><code id="pclm_+3A_b">B</code></td>
<td>
<p>a B-spline basis matrix, <code>q</code> by <code>n</code>.</p>
</td></tr>
<tr><td><code id="pclm_+3A_lambda">lambda</code></td>
<td>
<p>the penalty parameter.</p>
</td></tr>
<tr><td><code id="pclm_+3A_pord">pord</code></td>
<td>
<p>the  the order of the difference penalty (default = 2).</p>
</td></tr>
<tr><td><code id="pclm_+3A_itmax">itmax</code></td>
<td>
<p>the maximum number of iterations (default = 50).</p>
</td></tr>
<tr><td><code id="pclm_+3A_show">show</code></td>
<td>
<p>Set to TRUE or FALSE to display iteration history (default = FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The composite link model assumes that <code class="reqn">E(y) = \mu = C\exp(B \alpha)</code>, where <code class="reqn">\exp(B\alpha)</code> is
a latent discrete distribution, usually on a finer grid than that for <code class="reqn">y</code>.
</p>
<p>Note that <code>sum(gamma) == sum(mu)</code>.
</p>


<h3>Value</h3>

<p>A list with the following items:
</p>
<table role = "presentation">
<tr><td><code>alpha</code></td>
<td>
<p>the estimated B-spline coefficients, length <code>n</code>.</p>
</td></tr>
<tr><td><code>gamma</code></td>
<td>
<p>the estimated latent distribution, length <code>q</code>.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>estimated values of <code>y</code>, length <code>m</code>.</p>
</td></tr>
<tr><td><code>dev</code></td>
<td>
<p>the deviance of the model.</p>
</td></tr>
<tr><td><code>ed</code></td>
<td>
<p>the effective model dimension.</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>Akaike's Information Criterion.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paul Eilers and Jutta Gampe
</p>


<h3>References</h3>

<p>Eilers, P. H. C. (2007). III-posed problems with counts, the composite link
model and penalized likelihood. <em>Statistical Modelling</em>, 7(3), 239–254.
</p>
<p>Eilers, P.H.C. and Marx, B.D. (2021). <em>Practical Smoothing, The Joys of
P-splines.</em> Cambridge University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Left and right boundaries, and counts, of wide intervals of the data
cb &lt;- c( 0, 20, 30, 40, 50, 60)
ce &lt;- c(20, 30, 40, 50, 60, 70)
y &lt;- c(79, 54, 19, 1, 1, 0)

# Construct the composition matrix
m &lt;- length(y)
n &lt;- max(ce)
C &lt;- matrix(0, m, n)
for (i in 1:m) C[i, cb[i]:ce[i]] &lt;- 1

mids = (cb + ce) / 2 - 0.5
widths = ce - cb + 1
dens = y / widths / sum(y)
x = (1:n) - 0.5
B = bbase(x)
fit = pclm(y, C, B, lambda = 2, pord = 2, show = TRUE)
gamma = fit$gamma / sum(fit$gamma)
# Plot density estimate and data
plot(x, gamma, type = 'l', lwd = 2, xlab = "Lead Concentration", ylab = "Density")
rect(cb, 0, ce, dens, density = rep(10, 6), angle = rep(45, 6))
</code></pre>

<hr>
<h2 id='plot.ps2dglm'>Plotting function for <code>ps2DGLM</code></h2><span id='topic+plot.ps2dglm'></span>

<h3>Description</h3>

<p>Plotting function for 2D P-spline (GLM) smooothing
(using <code>ps2DGLM</code> with <code>class ps2dglm</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ps2dglm'
plot(x, ..., xlab = " ", ylab = " ", Resol = 100, se = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.ps2dglm_+3A_x">x</code></td>
<td>
<p>the P-spline object, usually from <code>ps2DGLM</code>.</p>
</td></tr>
<tr><td><code id="plot.ps2dglm_+3A_...">...</code></td>
<td>
<p>other parameters.</p>
</td></tr>
<tr><td><code id="plot.ps2dglm_+3A_xlab">xlab</code></td>
<td>
<p>label for the x-axis, e.g. &quot;my x&quot; (quotes required).</p>
</td></tr>
<tr><td><code id="plot.ps2dglm_+3A_ylab">ylab</code></td>
<td>
<p>label for the y-axis, e.g. &quot;my y&quot; (quotes required).</p>
</td></tr>
<tr><td><code id="plot.ps2dglm_+3A_resol">Resol</code></td>
<td>
<p>resolution for plotting, default <code>Resol = 100</code>.</p>
</td></tr>
<tr><td><code id="plot.ps2dglm_+3A_se">se</code></td>
<td>
<p>a scalar, e.g. <code>se = 2</code> to produce twice se surfaces,
set <code>se</code> &gt; 0 (or set <code>se = 0</code> to supress).</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Plot</code></td>
<td>
<p>a plot of the mean (inverse link) 2D P-spline (GLM) smooth surface.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paul Eilers and Brian Marx
</p>


<h3>References</h3>

<p>Eilers, P.H.C. and Marx, B.D. (2021). <em>Practical Smoothing, The Joys of
P-splines.</em> Cambridge University Press.
</p>
<p>Eilers, P.H.C., Marx, B.D., and Durban, M. (2015).
Twenty years of P-splines, <em>SORT</em>, 39(2): 149-186.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(fields)
library(JOPS)
# Extract data
library(rpart)
Kyphosis &lt;- kyphosis$Kyphosis
Age &lt;- kyphosis$Age
Start &lt;- kyphosis$Start
y &lt;- 1 * (Kyphosis == "present") # make y 0/1
fit &lt;- ps2DGLM(
  Data = cbind(Start, Age, y),
  Pars = rbind(c(1, 18, 10, 3, .1, 2), c(1, 206, 10, 3, .1, 2)),
  family = "binomial"
)
plot(fit, xlab = "Start", ylab = "Age")
#title(main = "Probability of Kyphosis")
</code></pre>

<hr>
<h2 id='plot.ps2dnormal'>Plotting function for <code>ps2DNormal</code></h2><span id='topic+plot.ps2dnormal'></span>

<h3>Description</h3>

<p>Plotting function for 2D P-spline smooothing
(using <code>ps2DNormal</code> with <code>class ps2dnormal</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ps2dnormal'
plot(x, ..., xlab = " ", ylab = " ", Resol = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.ps2dnormal_+3A_x">x</code></td>
<td>
<p>the P-spline object, usually from <code>ps2DNormal</code>.</p>
</td></tr>
<tr><td><code id="plot.ps2dnormal_+3A_...">...</code></td>
<td>
<p>other parameters.</p>
</td></tr>
<tr><td><code id="plot.ps2dnormal_+3A_xlab">xlab</code></td>
<td>
<p>label for the x-axis, e.g. &quot;my x&quot; (quotes required).</p>
</td></tr>
<tr><td><code id="plot.ps2dnormal_+3A_ylab">ylab</code></td>
<td>
<p>label for the y-axis, e.g. &quot;my y&quot; (quotes required).</p>
</td></tr>
<tr><td><code id="plot.ps2dnormal_+3A_resol">Resol</code></td>
<td>
<p>resolution for plotting, default <code>Resol = 100</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Plot</code></td>
<td>
<p>a plot of the smooth 2D P-spline smooth surface.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paul Eilers and Brian Marx
</p>


<h3>References</h3>

<p>Eilers, P.H.C. and Marx, B.D. (2021). <em>Practical Smoothing, The Joys of
P-splines.</em> Cambridge University Press.
</p>
<p>Eilers, P.H.C., Marx, B.D., and Durban, M. (2015).
Twenty years of P-splines, <em>SORT</em>, 39(2): 149-186.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(SemiPar)
library(fields)
library(spam)
library(JOPS)

# Get the data
data(ethanol)
x &lt;- ethanol$C
y &lt;- ethanol$E
z &lt;- ethanol$NOx

# Set parameters for domain
xlo &lt;- 7
xhi &lt;- 19
ylo &lt;- 0.5
yhi &lt;- 1.25

# Set P-spline parameters, fit and compute surface
xpars &lt;- c(xlo, xhi, 10, 3, 3, 1)
ypars &lt;- c(ylo, yhi, 10, 3, 3, 1)
Pars1 &lt;- rbind(xpars, ypars)
fit &lt;- ps2DNormal(cbind(x, y, z), Pars = Pars1)
plot(fit, xlab = "C", ylab = "E")
</code></pre>

<hr>
<h2 id='plot.ps2dsignal'>Plotting function for <code>ps2DSignal</code></h2><span id='topic+plot.ps2dsignal'></span>

<h3>Description</h3>

<p>Plotting function for 2D P-spline signal regression
coefficients (using <code>ps2DSignal</code> with <code>class ps2dsignal</code>). Although
standard error surface bands
can be comuputed they are intentially left out as they are not
interpretable, and there is generally little data to steer
such a high-dimensional parameterization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ps2dsignal'
plot(x, ..., xlab = " ", ylab = " ", Resol = 200)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.ps2dsignal_+3A_x">x</code></td>
<td>
<p>the P-spline object, usually from <code>ps2DSignal</code>.</p>
</td></tr>
<tr><td><code id="plot.ps2dsignal_+3A_...">...</code></td>
<td>
<p>other parameters.</p>
</td></tr>
<tr><td><code id="plot.ps2dsignal_+3A_xlab">xlab</code></td>
<td>
<p>label for the x-axis, e.g. &quot;my x&quot; (quotes required).</p>
</td></tr>
<tr><td><code id="plot.ps2dsignal_+3A_ylab">ylab</code></td>
<td>
<p>label for the y-axis, e.g. &quot;my y&quot; (quotes required).</p>
</td></tr>
<tr><td><code id="plot.ps2dsignal_+3A_resol">Resol</code></td>
<td>
<p>Resolution of bgrid (default <code>Resol = 200</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Plot</code></td>
<td>
<p>a plot of the 2D P-spline signal coefficent surface.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paul Eilers and Brian Marx
</p>


<h3>References</h3>

<p>Marx, B.D. and Eilers, P.H.C. (2005).
Multidimensional penalized signal regression, <em>Technometrics</em>, 47: 13-22.
</p>
<p>Eilers, P.H.C. and Marx, B.D. (2021). <em>Practical Smoothing, The Joys of
P-splines.</em> Cambridge University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(fields)
library(JOPS)

# Get the data
x0 &lt;- Sugar$X
x0 &lt;- x0 - apply(x0, 1, mean) # center Signal
y &lt;- as.vector(Sugar$y[, 3]) # Response is Ash

# Inputs for two-dimensional signal regression
nseg &lt;- c(7, 37)
pord &lt;- c(3, 3)
min_ &lt;- c(230, 275)
max_ &lt;- c(340, 560)
M1_index &lt;- rev(c(340, 325, 305, 290, 255, 240, 230))
M2_index &lt;- seq(from = 275, to = 560, by = .5)
p1 &lt;- length(M1_index)
p2 &lt;- length(M2_index)

# Fit optimal model based on LOOCV
opt_lam &lt;- c(8858.6679, 428.1332) # Found via svcm
Pars_opt &lt;- rbind(
 c(min_[1], max_[1], nseg[1], 3, opt_lam[1], pord[1]),
 c(min_[2], max_[2], nseg[2], 3, opt_lam[2], pord[2]))

fit &lt;- ps2DSignal(y, x0, p1, p2, "unfolded", M1_index, M2_index,
       Pars_opt, int = FALSE, ridge_adj = 1e-4 )

# Plotting coefficient image
plot(fit)
</code></pre>

<hr>
<h2 id='plot.pspfit'>Plotting function for <code>psNormal</code>, <code>psPoisson</code>, <code>psBinomial</code></h2><span id='topic+plot.pspfit'></span>

<h3>Description</h3>

<p>Plotting function for P-spline smooth with normal, Poisson, or binomial responses
(<code>class pspfit</code>), with or without standard error bands.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pspfit'
plot(x, ..., se = 2, xlab = "", ylab = "", col = "black", pch = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.pspfit_+3A_x">x</code></td>
<td>
<p>the P-spline object, usually from psNormal, psPoisson, psBinomial.</p>
</td></tr>
<tr><td><code id="plot.pspfit_+3A_...">...</code></td>
<td>
<p>other parameters.</p>
</td></tr>
<tr><td><code id="plot.pspfit_+3A_se">se</code></td>
<td>
<p>a scalar, e.g. <code>se = 2</code> to produce twice se bands, set <code>se</code> &gt; 0 (or set <code>se</code>=0 to supress).</p>
</td></tr>
<tr><td><code id="plot.pspfit_+3A_xlab">xlab</code></td>
<td>
<p>label for the x-axis.</p>
</td></tr>
<tr><td><code id="plot.pspfit_+3A_ylab">ylab</code></td>
<td>
<p>label for the y-axis.</p>
</td></tr>
<tr><td><code id="plot.pspfit_+3A_col">col</code></td>
<td>
<p>color for points.</p>
</td></tr>
<tr><td><code id="plot.pspfit_+3A_pch">pch</code></td>
<td>
<p>point character.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Plot</code></td>
<td>
<p>a plot of the mean (inverse link) smoothed normal, Poisson, or binomial responses, with or without se bands.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paul Eilers and Brian Marx
</p>


<h3>References</h3>

<p>Eilers, P.H.C. and Marx, B.D. (2021). <em>Practical Smoothing, The Joys of
P-splines.</em> Cambridge University Press.
</p>
<p>Eilers, P.H.C., Marx, B.D., and Durban, M. (2015).
Twenty years of P-splines, <em>SORT</em>, 39(2): 149-186.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(JOPS)
#Extract data
library(MASS)
# Get the data
data(mcycle)
x = mcycle$times
y = mcycle$accel
fit1 = psNormal(x, y, nseg = 20, bdeg = 3, pord = 2, lambda = .8)
plot(fit1, se = 2, xlab = "time (ms)", ylab = "accel")

library(JOPS)
library(boot)
# Extract the data
Count = hist(boot::coal$date, breaks=c(1851:1963), plot = FALSE)$counts
Year = c(1851:1962)
xl = min(Year)
xr = max(Year)

# Poisson smoothing
nseg = 20
bdeg = 3
fit1=psPoisson(Year, Count, xl, xr, nseg, bdeg, pord = 2,
lambda = 1)
names(fit1)
plot(fit1, xlab = "Year", ylab = "Count", se = 2)

library(JOPS)
#Extract data
library(rpart)
Kyphosis = kyphosis$Kyphosis
Age  =kyphosis$Age
y = 1 * (Kyphosis == "present")  # make y 0/1
# Binomial smoothing
fit1 = psBinomial(Age, y, xl = min(Age), xr = max(Age), nseg = 20,
                 bdeg = 3, pord = 2, lambda = 1)
names(fit1)
plot(fit1, xlab = "Age", ylab = '0/1', se = 2)

</code></pre>

<hr>
<h2 id='plot.pssignal'>Plotting function for <code>psSignal</code></h2><span id='topic+plot.pssignal'></span>

<h3>Description</h3>

<p>Plotting function for signal regression P-spline smooth coefficients (using <code>psSignal</code> with <code>class pssignal</code>), with or
without standard error bands.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pssignal'
plot(x, ..., se = 2, xlab = "", ylab = "", col = "black", lty = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.pssignal_+3A_x">x</code></td>
<td>
<p>the P-spline x, usually from <code>psSignal</code>.</p>
</td></tr>
<tr><td><code id="plot.pssignal_+3A_...">...</code></td>
<td>
<p>other parameters.</p>
</td></tr>
<tr><td><code id="plot.pssignal_+3A_se">se</code></td>
<td>
<p>a scalar, e.g. <code>se = 2</code> to produce twice se bands, set <code>se</code> &gt; 0 (or set <code>se = 0</code> to supress).</p>
</td></tr>
<tr><td><code id="plot.pssignal_+3A_xlab">xlab</code></td>
<td>
<p>label for the x-axis, e.g. &quot;my x&quot; (quotes required).</p>
</td></tr>
<tr><td><code id="plot.pssignal_+3A_ylab">ylab</code></td>
<td>
<p>label for the y-axis, e.g. &quot;my y&quot; (quotes required).</p>
</td></tr>
<tr><td><code id="plot.pssignal_+3A_col">col</code></td>
<td>
<p>color.</p>
</td></tr>
<tr><td><code id="plot.pssignal_+3A_lty">lty</code></td>
<td>
<p>line type for plotting e.g. <code>lty = 2</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Plot</code></td>
<td>
<p>a plot of the smooth P-spline signal coefficent vector, with or without standard error bands.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paul Eilers and Brian Marx
</p>


<h3>References</h3>

<p>Marx, B.D. and Eilers, P.H.C. (1999). Generalized linear regression for sampled signals and
curves: A P-spline approach. <em>Technometrics</em>, 41(1): 1-13.
</p>
<p>Eilers, P.H.C. and Marx, B.D. (2021). <em>Practical Smoothing, The Joys of
P-splines.</em> Cambridge University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(JOPS)
# Get the data
library(fds)
data(nirc)
iindex=nirc$x
X=nirc$y
sel= 50:650 #1200 &lt;= x &amp; x&lt;= 2400
X=X[sel, ]
iindex=iindex[sel]
dX=diff(X)
diindex=iindex[-1]
y=as.vector(labc[1,1:40])
oout = 23
dX=t(dX[,-oout])
y=y[-oout]
fit2 = psSignal(y, dX, diindex, nseg = 25,lambda = 0.0001)
plot(fit2, se = 2, xlab = 'Coefficient Index', ylab= "ps Smooth Coeff")
title(main='25 B-spline segments with tuning=0.0001')
names(fit2)

</code></pre>

<hr>
<h2 id='plot.psvcsignal'>Plotting function for <code>psVCSignal</code></h2><span id='topic+plot.psvcsignal'></span>

<h3>Description</h3>

<p>Plotting function for varying-coefficent signal
regression P-spline smooth coefficients (using <code>psVCSignal</code> with <code>class psvcsignal</code>).
Although se surface bands can be comuputed they are intentially left out as they are not
interpretable, and there is generally little data to steer
such a high-dimensional parameterization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'psvcsignal'
plot(x, ..., xlab = " ", ylab = " ", Resol = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.psvcsignal_+3A_x">x</code></td>
<td>
<p>the P-spline object, usually from <code>psVCSignal</code>.</p>
</td></tr>
<tr><td><code id="plot.psvcsignal_+3A_...">...</code></td>
<td>
<p>other parameters.</p>
</td></tr>
<tr><td><code id="plot.psvcsignal_+3A_xlab">xlab</code></td>
<td>
<p>label for the x-axis, e.g. &quot;my x&quot; (quotes required).</p>
</td></tr>
<tr><td><code id="plot.psvcsignal_+3A_ylab">ylab</code></td>
<td>
<p>label for the y-axis, e.g. &quot;my y&quot; (quotes required).</p>
</td></tr>
<tr><td><code id="plot.psvcsignal_+3A_resol">Resol</code></td>
<td>
<p>resolution for plotting, default <code>Resol = 100</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Plot</code></td>
<td>
<p>a two panel plot, one of the 2D P-spline signal coefficient surface
and another that displays several slices of the smooth coefficient vectors at fixed levels of the
varying index.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paul Eilers and Brian Marx
</p>


<h3>References</h3>

<p>Eilers, P. H. C. and Marx, B. D. (2003). Multivariate calibration with temperature
interaction using two-dimensional penalized signal regression. <em>Chemometrics
and Intellegent Laboratory Systems</em>, 66, 159–174.
</p>
<p>Eilers, P.H.C. and Marx, B.D. (2021). <em>Practical Smoothing, The Joys of
P-splines.</em> Cambridge University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(fds)
data(nirc)
iindex &lt;- nirc$x
X &lt;- nirc$y
sel &lt;- 50:650 # 1200 &lt;= x &amp; x&lt;= 2400
X &lt;- X[sel, ]
iindex &lt;- iindex[sel]
dX &lt;- diff(X)
diindex &lt;- iindex[-1]
y &lt;- as.vector(labc[1, 1:40]) # percent fat
t_var &lt;- as.vector(labc[4, 1:40]) # percent flour
oout &lt;- 23
dX &lt;- t(dX[, -oout])
y &lt;- y[-oout]
t_var = t_var[-oout]
Pars = rbind(c(min(diindex), max(diindex), 25, 3, 1e-7, 2),
c(min(t_var), max(t_var), 20, 3, 0.0001, 2))
fit1 &lt;- psVCSignal(y, dX, diindex, t_var, Pars = Pars,
family = "gaussian", link = "identity", int = TRUE)
plot(fit1, xlab = "Coefficient Index", ylab = "VC: % Flour")
names(fit1)
</code></pre>

<hr>
<h2 id='plot.simpsr'>Plotting function for <code>sim_psr</code></h2><span id='topic+plot.simpsr'></span>

<h3>Description</h3>

<p>Plotting function for single-index signal
regression with tensor product P-splines (using <code>sim_psr</code> with <code>class simpsr</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'simpsr'
plot(x, ..., xlab = " ", ylab = " ", Resol = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.simpsr_+3A_x">x</code></td>
<td>
<p>the P-spline object, usually from <code>sim_psr</code>.</p>
</td></tr>
<tr><td><code id="plot.simpsr_+3A_...">...</code></td>
<td>
<p>other parameters.</p>
</td></tr>
<tr><td><code id="plot.simpsr_+3A_xlab">xlab</code></td>
<td>
<p>label for the x-axis, e.g. &quot;my x&quot; (quotes required).</p>
</td></tr>
<tr><td><code id="plot.simpsr_+3A_ylab">ylab</code></td>
<td>
<p>label for the y-axis, e.g. &quot;my y&quot; (quotes required).</p>
</td></tr>
<tr><td><code id="plot.simpsr_+3A_resol">Resol</code></td>
<td>
<p>resolution for plotting, default <code>Resol = 100</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Plot</code></td>
<td>
<p>a two panel plot, one for the estimated P-spline signal coefficent vector, and another for
the estimated (unkown) P-spline smooth link function.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paul Eilers, Brian Marx, and Bin Li
</p>


<h3>References</h3>

<p>Eilers, P.H.C., B. Li, B.D. Marx (2009).
Multivariate calibration with single-index signal regression,
<em>Chemometrics and Intellegent Laboratory Systems</em>, 96(2), 196-202.
</p>
<p>Eilers, P.H.C. and Marx, B.D. (2021). <em>Practical Smoothing, The Joys of
P-splines.</em> Cambridge University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(JOPS)
# Get the data
library(fds)
data(nirc)
iindex &lt;- nirc$x
X &lt;- nirc$y
sel &lt;- 50:650 # 1200 &lt;= x &amp; x&lt;= 2400
X &lt;- X[sel, ]
iindex &lt;- iindex[sel]
dX &lt;- diff(X)
diindex &lt;- iindex[-1]
y &lt;- as.vector(labc[1, 1:40])
oout &lt;- 23
dX &lt;- t(dX[, -oout])
y &lt;- y[-oout]

pords &lt;- c(2, 2)
nsegs &lt;- c(27, 7)
bdegs = c(3, 3)
lambdas &lt;- c(1e-6, .1)
max_iter &lt;- 100

# Single-index model
fit &lt;- sim_psr(y, dX, diindex, nsegs, bdegs, lambdas, pords,
             max_iter)
plot(fit, xlab = "Wavelength (nm)", ylab = " ")

</code></pre>

<hr>
<h2 id='plot.simvcpsr'>Plotting function for <code>sim_vcpsr</code></h2><span id='topic+plot.simvcpsr'></span>

<h3>Description</h3>

<p>Plotting function for varying-coefficient single-index signal
regression using tensor product P-splines (using <code>sim_vcpsr</code> with <code>class simvcpsr</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'simvcpsr'
plot(x, ..., xlab = " ", ylab = " ", Resol = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.simvcpsr_+3A_x">x</code></td>
<td>
<p>the P-spline object, usually from <code>sim_vcpsr</code>.</p>
</td></tr>
<tr><td><code id="plot.simvcpsr_+3A_...">...</code></td>
<td>
<p>other parameters.</p>
</td></tr>
<tr><td><code id="plot.simvcpsr_+3A_xlab">xlab</code></td>
<td>
<p>label for the x-axis, e.g. &quot;my x&quot; (quotes required).</p>
</td></tr>
<tr><td><code id="plot.simvcpsr_+3A_ylab">ylab</code></td>
<td>
<p>label for the y-axis, e.g. &quot;my y&quot; (quotes required).</p>
</td></tr>
<tr><td><code id="plot.simvcpsr_+3A_resol">Resol</code></td>
<td>
<p>resolution for plotting, default <code>Resol = 100</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Plot</code></td>
<td>
<p>a plot of the estimated 2D P-spline signal coefficient surface along with the companion plot of the estimated
2D P-spline varying link function surface. Slices of these plots, at fixed levels of the indexing covariate, are also provided.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paul Eilers and Brian Marx
</p>


<h3>References</h3>

<p>Marx, B. D. (2015). Varying-coefficient single-index signal
regression. <em>Chemometrics and Intellegent Laboratory Systems</em>, 143, 111–121.
</p>
<p>Eilers, P.H.C. and Marx, B.D. (2021). <em>Practical Smoothing, The Joys of
P-splines.</em> Cambridge University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load libraries
library(fields) # Needed for plotting

# Get the data
Dat &lt;- Mixture

# Dimensions: observations, temperature index, signal
m &lt;- 34
p1 &lt;- 401
p2 &lt;- 12

# Stacking mixture data, each mixture has 12 signals stacked
# The first differenced spectra are also computed.
mixture_data &lt;- matrix(0, nrow = p2 * m, ncol = p1)
for (ii in 1:m)
{
  mixture_data[((ii - 1) * p2 + 1):(ii * p2), 1:p1] &lt;-
    t(as.matrix(Dat$xspectra[ii, , ]))
  d_mixture_data &lt;- t(diff(t(mixture_data)))
}

# Response (typo fixed) and index for signal
y_mixture &lt;- Dat$fractions
y_mixture[17, 3] &lt;- 0.1501
index_mixture &lt;- Dat$wl

# Select response and replicated for the 12 temps
# Column 1: water; 2: ethanediol; 3: amino-1-propanol
y &lt;- as.vector(y_mixture[, 2])
y &lt;- rep(y, each = p2)

bdegs = c(3, 3, 3, 3)
pords &lt;- c(2, 2, 2, 2)
nsegs &lt;- c(12, 5, 5, 5) # Set to c(27, 7, 7 ,7) for given lambdas
mins &lt;- c(700, 30)
maxs &lt;- c(1100, 70)
lambdas &lt;- c(1e-11, 100, 0.5, 1) # based on svcm search
x_index &lt;- seq(from = 701, to = 1100, by = 1) # for dX
t_var_sub &lt;- c(30, 35, 37.5, 40, 45, 47.5, 50, 55, 60, 62.5, 65, 70)
t_var &lt;- rep(t_var_sub, m)
max_iter &lt;- 2 # Set higher in practice, e.g. 100
int &lt;- TRUE

# Defining x as first differenced spectra, number of channels.
x &lt;- d_mixture_data


# Single-index VC model using optimal tuning
fit &lt;- sim_vcpsr(y, x, t_var, x_index, nsegs, bdegs, lambdas, pords,
             max_iter = max_iter, mins = mins, maxs = maxs)

plot(fit, xlab = "Wavelength (nm)", ylab = "Temp C")


</code></pre>

<hr>
<h2 id='predict.ps2dglm'>Predict function for <code>ps2DGLM</code></h2><span id='topic+predict.ps2dglm'></span>

<h3>Description</h3>

<p>Prediction function which returns both linear
predictor and inverse link predictions at arbitrary (x, y) data locations
(using <code>ps2DGLM</code> with <code>class ps2dglm</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ps2dglm'
predict(object, ..., XY, type = "mu")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.ps2dglm_+3A_object">object</code></td>
<td>
<p>an object using <code>ps2DGLM</code>.</p>
</td></tr>
<tr><td><code id="predict.ps2dglm_+3A_...">...</code></td>
<td>
<p>other parameters.</p>
</td></tr>
<tr><td><code id="predict.ps2dglm_+3A_xy">XY</code></td>
<td>
<p>a matrix of arbitrary (<code>x</code>, <code>y</code>) locations for
desired prediction.</p>
</td></tr>
<tr><td><code id="predict.ps2dglm_+3A_type">type</code></td>
<td>
<p>the mean value <code>type = "mu"</code> (default) or linear predictor
<code>type = "eta"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>pred</code></td>
<td>
<p>the estimated mean (inverse link function) (default)
or the linear predictor prediction with <code>type =
"eta"</code>, for arbitary (x, y) locations in <code>XY</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paul Eilers and Brian Marx
</p>


<h3>References</h3>

<p>Eilers, P.H.C., Marx, B.D., and Durban, M. (2015).
Twenty years of P-splines, <em>SORT</em>, 39(2): 149-186.
</p>
<p>Eilers, P.H.C. and Marx, B.D. (2021). <em>Practical Smoothing, The Joys of
P-splines.</em> Cambridge University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(fields)
library(JOPS)
# Extract data
library(rpart)
Kyphosis &lt;- kyphosis$Kyphosis
Age &lt;- kyphosis$Age
Start &lt;- kyphosis$Start
y &lt;- 1 * (Kyphosis == "present") # make y 0/1
fit &lt;- ps2DGLM(
  Data = cbind(Start, Age, y),
  Pars = rbind(c(1, 18, 10, 3, .1, 2), c(1, 206, 10, 3, .1, 2)),
  family = "binomial", link = "logit")
predict(fit, XY = cbind(Start, Age)[1:5,])
</code></pre>

<hr>
<h2 id='predict.ps2dnormal'>Predict function for <code>ps2DNormal</code></h2><span id='topic+predict.ps2dnormal'></span>

<h3>Description</h3>

<p>Prediction function which returns linear
predictions at arbitrary (x, y) data locations (using <code>ps2DNormal</code>
with <code>class ps2dnormal</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ps2dnormal'
predict(object, ..., XY)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.ps2dnormal_+3A_object">object</code></td>
<td>
<p>an object using ps2DNormal.</p>
</td></tr>
<tr><td><code id="predict.ps2dnormal_+3A_...">...</code></td>
<td>
<p>other parameters.</p>
</td></tr>
<tr><td><code id="predict.ps2dnormal_+3A_xy">XY</code></td>
<td>
<p>a matrix of arbitrary (<code>x</code>, <code>y</code>) locations for
desired prediction.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>pred</code></td>
<td>
<p>the estimated mean at (<code>x</code>, <code>y</code>) locations, in <code>XY</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paul Eilers and Brian Marx
</p>


<h3>References</h3>

<p>Eilers, P.H.C., Marx, B.D., and Durban, M. (2015).
Twenty years of P-splines, <em>SORT</em>, 39(2): 149-186.
</p>
<p>Eilers, P.H.C. and Marx, B.D. (2021). <em>Practical Smoothing, The Joys of
P-splines.</em> Cambridge University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(SemiPar)
library(fields)
library(spam)
library(JOPS)

# Get the data
data(ethanol)
x &lt;- ethanol$C
y &lt;- ethanol$E
z &lt;- ethanol$NOx

# Set parameters for domain
xlo &lt;- 7
xhi &lt;- 19
ylo &lt;- 0.5
yhi &lt;- 1.25

# Set P-spline parameters, fit and compute surface
xpars &lt;- c(xlo, xhi, 10, 3, 0.01, 1)
ypars &lt;- c(ylo, yhi, 10, 3, 0.1, 1)
Pars1 &lt;- rbind(xpars, ypars)
fit &lt;- ps2DNormal(cbind(x, y, z), Pars = Pars1)
predict(fit, XY = cbind(x, y)[1:5, ])
</code></pre>

<hr>
<h2 id='predict.ps2dsignal'>Predict function for <code>ps2DSignal</code></h2><span id='topic+predict.ps2dsignal'></span>

<h3>Description</h3>

<p>Prediction function which returns both linear
predictor and inverse link predictions for arbitrary 2D signals (using
<code>ps2DSignal</code> with <code>class ps2dsignal</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ps2dsignal'
predict(object, ..., M_pred, M_type = "unfolded", type = "mu")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.ps2dsignal_+3A_object">object</code></td>
<td>
<p>an object using <code>ps2DSignal</code>.</p>
</td></tr>
<tr><td><code id="predict.ps2dsignal_+3A_...">...</code></td>
<td>
<p>other parameters.</p>
</td></tr>
<tr><td><code id="predict.ps2dsignal_+3A_m_pred">M_pred</code></td>
<td>
<p>a matrix of <code>q</code> arbitrary &quot;stacked&quot; or &quot;unfolded&quot; signal matrices
of dimension (<code>q</code> by <code>p1</code>) by <code>p2</code> or <code>q</code> by (<code>p1</code>
by <code>p2</code>, respectively,
for desired prediction (default &quot;unfolded&quot;).</p>
</td></tr>
<tr><td><code id="predict.ps2dsignal_+3A_m_type">M_type</code></td>
<td>
<p>&quot;stacked&quot; or &quot;unfolded&quot; (default).</p>
</td></tr>
<tr><td><code id="predict.ps2dsignal_+3A_type">type</code></td>
<td>
<p>the mean value <code>type = "mu"</code> (default) or linear predictor
<code>type = "eta"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>pred</code></td>
<td>
<p>the estimated mean (inverse link function)
or the linear predictor prediction with <code>type =
"eta"</code>, for arbitary 2D signals in <code>M_pred</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paul Eilers and Brian Marx
</p>


<h3>References</h3>

<p>Marx, B.D. and Eilers, P.H.C. (2005).
Multidimensional penalized signal regression, <em>Technometrics</em>, 47: 13-22.
</p>
<p>Eilers, P.H.C. and Marx, B.D. (2021). <em>Practical Smoothing, The Joys of
P-splines.</em> Cambridge University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(fields)
library(JOPS)

# Get the data
x0 &lt;- Sugar$X
x0 &lt;- x0 - apply(x0, 1, mean) # center Signal
y &lt;- as.vector(Sugar$y[, 3]) # Response is Ash

# Inputs for two-dimensional signal regression
nseg &lt;- c(7, 37)
pord &lt;- c(3, 3)
min_ &lt;- c(230, 275)
max_ &lt;- c(340, 560)
M1_index &lt;- rev(c(340, 325, 305, 290, 255, 240, 230))
M2_index &lt;- seq(from = 275, to = 560, by = .5)
p1 &lt;- length(M1_index)
p2 &lt;- length(M2_index)

# Fit optimal model based on LOOCV
opt_lam &lt;- c(8858.6679, 428.1332) # Found via svcm
Pars_opt &lt;- rbind(
  c(min_[1], max_[1], nseg[1], 3, opt_lam[1], pord[1]),
  c(min_[2], max_[2], nseg[2], 3, opt_lam[2], pord[2])
)
fit &lt;- ps2DSignal(y, x0, p1, p2, "unfolded", M1_index, M2_index,
  Pars_opt,int = TRUE, ridge_adj = 0.0001,
  M_pred = x0 )


predict(fit, M_pred= x0, type = "mu", M_type = "unfolded")
</code></pre>

<hr>
<h2 id='predict.pspfit'>Predict function for <code>psNormal</code>, <code>psBinomial</code>, <code>psPoisson</code></h2><span id='topic+predict.pspfit'></span>

<h3>Description</h3>

<p>Prediction function which returns both linear
predictor and inverse link predictions at arbitrary data locations
(using <code>psNormal</code>, <code>psBinomial</code>, <code>psPoisson</code> with <code>class pspfit</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pspfit'
predict(object, ..., x, type = "mu")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.pspfit_+3A_object">object</code></td>
<td>
<p>an object using <code>psNormal</code>, <code>psBinomial</code>, or <code>psPoisson</code> .</p>
</td></tr>
<tr><td><code id="predict.pspfit_+3A_...">...</code></td>
<td>
<p>other parameters.</p>
</td></tr>
<tr><td><code id="predict.pspfit_+3A_x">x</code></td>
<td>
<p>a scalar or vector of arbitrary <code>x</code> locations for
desired prediction.</p>
</td></tr>
<tr><td><code id="predict.pspfit_+3A_type">type</code></td>
<td>
<p>the mean value <code>type = "mu"</code> (default) or linear predictor
<code>type = "eta"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>pred</code></td>
<td>
<p>the estimated mean (inverse link function) (default)
or the linear predictor prediction with <code>type =
"eta"</code>, at arbitary <code>x</code> locations.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paul Eilers and Brian Marx
</p>


<h3>References</h3>

<p>Eilers, P.H.C., Marx, B.D., and Durban, M. (2015).
Twenty years of P-splines, <em>SORT</em>, 39(2): 149-186.
</p>
<p>Eilers, P.H.C. and Marx, B.D. (2021). <em>Practical Smoothing, The Joys of
P-splines.</em> Cambridge University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(JOPS)
library(boot)

# Extract the data
Count &lt;- hist(boot::coal$date, breaks = c(1851:1963), plot = FALSE)$counts
Year &lt;- c(1851:1962)
xl &lt;- min(Year)
xr &lt;- max(Year)

# Poisson smoothing
nseg &lt;- 20
bdeg &lt;- 3
fit1 &lt;- psPoisson(Year, Count, xl, xr, nseg, bdeg, pord = 2, lambda = 1)
names(fit1)
plot(fit1, xlab = "Year", ylab = "Count", se = 2)
predict(fit1, x = fit1$x[1:5])
predict(fit1, x = fit1$x[1:5], type = "eta")
</code></pre>

<hr>
<h2 id='predict.pssignal'>Predict function for <code>psSignal</code></h2><span id='topic+predict.pssignal'></span>

<h3>Description</h3>

<p>Prediction function which returns both linear
predictor and inverse link predictions, for an arbitrary matrix of signals
(using <code>psSignal</code> with <code>class pssignal</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pssignal'
predict(object, ..., X_pred, type = "mu")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.pssignal_+3A_object">object</code></td>
<td>
<p>an object using <code>psSignal</code>.</p>
</td></tr>
<tr><td><code id="predict.pssignal_+3A_...">...</code></td>
<td>
<p>other parameters.</p>
</td></tr>
<tr><td><code id="predict.pssignal_+3A_x_pred">X_pred</code></td>
<td>
<p>a matrix of arbitrary signals with <code>ncol(X) == length(x_index)</code> locations for
desired prediction.</p>
</td></tr>
<tr><td><code id="predict.pssignal_+3A_type">type</code></td>
<td>
<p>the mean value <code>type = "mu"</code> (default) or linear predictor
<code>type = "eta"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>pred</code></td>
<td>
<p>the estimated mean (inverse link function) (default)
or the linear predictor prediction with <code>type =
"eta"</code>, for a matrix of signals in <code>X_pred</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paul Eilers and Brian Marx
</p>


<h3>References</h3>

<p>Marx, B.D. and Eilers, P.H.C. (1999). Generalized linear regression for sampled signals and
curves: A P-spline approach. <em>Technometrics</em>, 41(1): 1-13.
</p>
<p>Eilers, P.H.C. and Marx, B.D. (2021). <em>Practical Smoothing, The Joys of
P-splines.</em> Cambridge University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(JOPS)
# Get the data
library(fds)
data(nirc)
iindex=nirc$x
X=nirc$y
sel= 50:650 #1200 &lt;= x &amp; x&lt;= 2400
X=X[sel,]
iindex=iindex[sel]
dX=diff(X)
diindex=iindex[-1]
y=as.vector(labc[1,1:40])
oout=23
dX=t(dX[,-oout])
y=y[-oout]
fit1 = psSignal(y, dX, diindex, nseg = 25,lambda = 0.0001)
predict(fit1, X_pred = dX[1:5, ])
predict(fit1, X_pred = dX[1:5, ], type = 'eta')
</code></pre>

<hr>
<h2 id='predict.psvcsignal'>Predict function for <code>psVCSignal</code></h2><span id='topic+predict.psvcsignal'></span>

<h3>Description</h3>

<p>Prediction function which returns both linear
predictor and inverse link predictions for an arbitrary matrix of
signals with their vector of companion indexing covariates (using
<code>psVCSignal</code> with <code>class psvcsignal</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'psvcsignal'
predict(object, ..., X_pred, t_pred, type = "mu")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.psvcsignal_+3A_object">object</code></td>
<td>
<p>an object using <code>psVCSignal</code>.</p>
</td></tr>
<tr><td><code id="predict.psvcsignal_+3A_...">...</code></td>
<td>
<p>other parameters.</p>
</td></tr>
<tr><td><code id="predict.psvcsignal_+3A_x_pred">X_pred</code></td>
<td>
<p>a matrix of <code>q</code> arbitrary signal vectors
of dimension <code>q</code> by <code>p1</code> for desired prediction.</p>
</td></tr>
<tr><td><code id="predict.psvcsignal_+3A_t_pred">t_pred</code></td>
<td>
<p>a <code>q</code> vector for the varying index variable associated with <code>X_pred</code>.</p>
</td></tr>
<tr><td><code id="predict.psvcsignal_+3A_type">type</code></td>
<td>
<p>the mean value <code>type = "mu"</code> (default) or linear predictor
<code>type = "eta"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>pred</code></td>
<td>
<p>the estimated mean (inverse link function) (default)
or the linear predictor prediction with <code>type =
"eta"</code>, at signals in matrix <code>X_pred</code> and covariates in vector <code>t_pred</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paul Eilers and Brian Marx
</p>


<h3>References</h3>

<p>Eilers, P. H. C. and Marx, B. D. (2003). Multivariate calibration with temperature
interaction using two-dimensional penalized signal regression. <em>Chemometrics
and Intellegent Laboratory Systems</em>, 66, 159–174.
</p>
<p>Eilers, P.H.C. and Marx, B.D. (2021). <em>Practical Smoothing, The Joys of
P-splines.</em> Cambridge University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(fds)
data(nirc)
iindex &lt;- nirc$x
X &lt;- nirc$y
sel &lt;- 50:650 # 1200 &lt;= x &amp; x&lt;= 2400
X &lt;- X[sel, ]
iindex &lt;- iindex[sel]
dX &lt;- diff(X)
diindex &lt;- iindex[-1]
y &lt;- as.vector(labc[1, 1:40]) # percent fat
t_var &lt;- as.vector(labc[4, 1:40]) # percent flour
oout &lt;- 23
dX &lt;- t(dX[, -oout])
y &lt;- y[-oout]
t_var = t_var[-oout]
Pars = rbind(c(min(diindex), max(diindex), 25, 3, 1e-7, 2),
c(min(t_var), max(t_var), 20, 3, 0.0001, 2))
fit1 &lt;- psVCSignal(y, dX, diindex, t_var, Pars = Pars,
family = "gaussian", link = "identity", int = TRUE)
predict(fit1, X_pred = dX[1:5,], t_pred = t_var[1:5])
</code></pre>

<hr>
<h2 id='predict.simpsr'>Predict function for <code>sim_psr</code></h2><span id='topic+predict.simpsr'></span>

<h3>Description</h3>

<p>Prediction function which returns single-index
inverse link linear predictions at arbitrary data locations (using
<code>sim_psr</code> with <code>class simpsr</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'simpsr'
predict(object, ..., X_pred)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.simpsr_+3A_object">object</code></td>
<td>
<p>an object using <code>sim_psr</code>.</p>
</td></tr>
<tr><td><code id="predict.simpsr_+3A_...">...</code></td>
<td>
<p>other parameters.</p>
</td></tr>
<tr><td><code id="predict.simpsr_+3A_x_pred">X_pred</code></td>
<td>
<p>a matrix of arbitrary signals with <code>ncol(X_pred) = length(x_index)</code> locations for
desired prediction.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>pred</code></td>
<td>
<p>the estimated (inverse single-index) mean for the signals in <code>X_pred</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paul Eilers and Brian Marx
</p>


<h3>References</h3>

<p>Eilers, P.H.C., B. Li, B.D. Marx (2009).
Multivariate calibration with single-index signal regression,
<em>Chemometrics and Intellegent Laboratory Systems</em>, 96(2), 196-202.
</p>
<p>Eilers, P.H.C. and Marx, B.D. (2021). <em>Practical Smoothing, The Joys of
P-splines.</em> Cambridge University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(JOPS)
# Get the data
library(fds)
data(nirc)
iindex &lt;- nirc$x
X &lt;- nirc$y
sel &lt;- 50:650 # 1200 &lt;= x &amp; x&lt;= 2400
X &lt;- X[sel, ]
iindex &lt;- iindex[sel]
dX &lt;- diff(X)
diindex &lt;- iindex[-1]
y &lt;- as.vector(labc[1, 1:40])
oout &lt;- 23
dX &lt;- t(dX[, -oout])
y &lt;- y[-oout]

pords &lt;- c(2, 2)
nsegs &lt;- c(27, 7)
bdegs = c(3, 3)
lambdas &lt;- c(1e-6, .1)
max_iter &lt;- 100

# Single-index model
fit &lt;- sim_psr(y, dX, diindex, nsegs, bdegs, lambdas, pords,
             max_iter)
predict(fit, X_pred = dX)

</code></pre>

<hr>
<h2 id='predict.simvcpsr'>Predict function for <code>sim_vcpsr</code></h2><span id='topic+predict.simvcpsr'></span>

<h3>Description</h3>

<p>Prediction function which returns varying-coefficient single-index
inverse link linear predictions at arbitrary data locations (using <code>sim_vcpsr</code> with
<code>class simvcpsr</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'simvcpsr'
predict(object, ..., X_pred, t_pred)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.simvcpsr_+3A_object">object</code></td>
<td>
<p>an object using <code>sim_vcpsr</code>.</p>
</td></tr>
<tr><td><code id="predict.simvcpsr_+3A_...">...</code></td>
<td>
<p>other parameters.</p>
</td></tr>
<tr><td><code id="predict.simvcpsr_+3A_x_pred">X_pred</code></td>
<td>
<p>a matrix of arbitrary signals with <code>ncol(X_pred) = length(x_index)</code> locations for
desired prediction.</p>
</td></tr>
<tr><td><code id="predict.simvcpsr_+3A_t_pred">t_pred</code></td>
<td>
<p>a <code>q</code> vector for the VC index variable associated with <code>X_pred</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>pred</code></td>
<td>
<p>the estimated (inverse single-index) mean for the signals in the matrix <code>X_pred</code>,
with the companion vector of indexing covariates in <code>t_pred</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paul Eilers and Brian Marx
</p>


<h3>References</h3>

<p>Marx, B. D. (2015). Varying-coefficient single-index signal
regression. <em>Chemometrics and Intellegent Laboratory Systems</em>, 143, 111–121.
</p>
<p>Eilers, P.H.C. and Marx, B.D. (2021). <em>Practical Smoothing, The Joys of
P-splines.</em> Cambridge University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load libraries
library(fields) # Needed for plotting

# Get the data
Dat &lt;- Mixture

# Dimensions: observations, temperature index, signal
m &lt;- 34
p1 &lt;- 401
p2 &lt;- 12

# Stacking mixture data, each mixture has 12 signals stacked
# The first differenced spectra are also computed.
mixture_data &lt;- matrix(0, nrow = p2 * m, ncol = p1)
for (ii in 1:m)
{
  mixture_data[((ii - 1) * p2 + 1):(ii * p2), 1:p1] &lt;-
    t(as.matrix(Dat$xspectra[ii, , ]))
  d_mixture_data &lt;- t(diff(t(mixture_data)))
}

# Response (typo fixed) and index for signal
y_mixture &lt;- Dat$fractions
y_mixture[17, 3] &lt;- 0.1501
index_mixture &lt;- Dat$wl

# Select response and replicated for the 12 temps
# Column 1: water; 2: ethanediol; 3: amino-1-propanol
y &lt;- as.vector(y_mixture[, 2])
y &lt;- rep(y, each = p2)

bdegs = c(3, 3, 3, 3)
pords &lt;- c(2, 2, 2, 2)
nsegs &lt;- c(12, 5, 5, 5) # Set to c(27, 7, 7 ,7) for given lambdas
mins &lt;- c(700, 30)
maxs &lt;- c(1100, 70)
lambdas &lt;- c(1e-11, 100, 0.5, 1) # based on svcm search
x_index &lt;- seq(from = 701, to = 1100, by = 1) # for dX
t_var_sub &lt;- c(30, 35, 37.5, 40, 45, 47.5, 50, 55, 60, 62.5, 65, 70)
t_var &lt;- rep(t_var_sub, m)
max_iter &lt;- 2 # Set higher in practice, e.g. 100
int &lt;- TRUE

# Defining x as first differenced spectra, number of channels.
x &lt;- d_mixture_data


# Single-index VC model using optimal tuning
fit &lt;- sim_vcpsr(y, x, t_var, x_index, nsegs, bdegs, lambdas, pords,
             max_iter = max_iter, mins = mins, maxs = maxs)

predict(fit, X_pred = x, t_pred = t_var)
</code></pre>

<hr>
<h2 id='ps2D_PartialDeriv'>Partial derivative two-dimensional smoothing scattered (normal)
data using P-splines.</h2><span id='topic+ps2D_PartialDeriv'></span>

<h3>Description</h3>

<p><code>ps2D_PartialDeriv</code> provides the partial derivative
P-spline surface along <code>x</code>, with aniosotripic penalization of
tensor product B-splines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ps2D_PartialDeriv(
  Data,
  Pars = rbind(c(min(Data[, 1]), max(Data[, 1]), 10, 3, 1, 2), c(min(Data[, 2]),
    max(Data[, 2]), 10, 3, 1, 2)),
  XYpred = cbind(Data[, 1], Data[, 2])
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ps2D_PartialDeriv_+3A_data">Data</code></td>
<td>
<p>a matrix of 3 columns <code>x, y, z</code> of equal length;
the response is <code>z</code>.</p>
</td></tr>
<tr><td><code id="ps2D_PartialDeriv_+3A_pars">Pars</code></td>
<td>
<p>a matrix of 2 rows, where the first and second row
sets the P-spline paramters for <code>x</code> and <code>y</code>, respectively.
Each row consists of: <code>min max nseg bdeg lambda pord</code>.
The <code>min</code> and <code>max</code> set the ranges, <code>nseg</code> (default 10)
is the number of evenly spaced segments between <code>min</code> and <code>max</code>,
<code>bdeg</code> is the degree of the basis (default 3 for cubic),
<code>lambda</code> is the (positive) tuning parameter for the penalty (default 1),
<code>pord</code> is the number for the order of the difference penalty (default 2).</p>
</td></tr>
<tr><td><code id="ps2D_PartialDeriv_+3A_xypred">XYpred</code></td>
<td>
<p>a matrix with two columns <code>(x, y)</code> that give the coordinates
of (future) prediction; the default is the data locations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is support function for <code>sim_vcpsr</code>.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>coef</code></td>
<td>
<p>a vector of length <code>(Pars[1, 3] + Pars[1, 4]) * (Pars[1, 3] + Pars[1, 4]).</code>
of (unfolded) estimated P-spline coefficients.</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>the tensor product B-spline matrix of dimensions <code>m</code> by <code>length(coef)</code>.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>a vector of <code>length(y)</code> of smooth estimated means (at the <code>x, y</code> locations).</p>
</td></tr>
<tr><td><code>pred</code></td>
<td>
<p>a vector of length <code>nrow(XYpred)</code> of (future) predictions.</p>
</td></tr>
<tr><td><code>d_coef</code></td>
<td>
<p>a vector of length <code>(Pars[1, 3] + Pars[1,4] - 1) * (Pars[1,3]+Pars[1,4]).</code>
of (unfolded) partial derivative estimated P-spline coefficients.</p>
</td></tr>
<tr><td><code>B_d</code></td>
<td>
<p>the tensor product B-spline matrix of dimensions <code>m</code> by <code>lengh(d_coef)</code>, associated with
the partial derivative of the tensor basis.</p>
</td></tr>
<tr><td><code>d_fit</code></td>
<td>
<p>a vector of <code>length(y)</code> of partial derivative (along <code>x</code>)
of the smooth estimated means (at the <code>x, y</code> locations).</p>
</td></tr>
<tr><td><code>d_pred</code></td>
<td>
<p>a vector of length <code>nrow(XYpred)</code> of partial derivative (future) predictions.</p>
</td></tr>
<tr><td><code>Pars</code></td>
<td>
<p>a matrix of 2 rows, where each the first (second) row
sets the P-spline paramters for <code>x (y)</code>: <code>min max nseg bdeg lambda pord</code>. See the argument above.</p>
</td></tr>
<tr><td><code>cv</code></td>
<td>
<p>root leave-one-out CV or root average PRESS.</p>
</td></tr>
<tr><td><code>XYpred</code></td>
<td>
<p>a matrix with two columns <code>(x, y)</code> that give the coordinates
of (future) prediction; the default is the data locations.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Brian Marx
</p>


<h3>References</h3>

<p>Marx, B. D. (2015). Varying-coefficient single-index signal
regression. <em>Chemometrics and Intelligent Laboratory Systems</em>, 143, 111–121.
</p>
<p>Eilers, P.H.C. and Marx, B.D. (2021). <em>Practical Smoothing, The Joys of
P-splines.</em> Cambridge University Press.
</p>

<hr>
<h2 id='ps2DGLM'>Two-dimensional smoothing of scattered normal or non-normal (GLM)
responses using tensor product P-splines.</h2><span id='topic+ps2DGLM'></span>

<h3>Description</h3>

<p><code>ps2DGLM</code> is used to smooth scattered
normal or non-normal responses, with aniosotripic
penalization of tensor product P-splines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ps2DGLM(
  Data,
  Pars = rbind(c(min(Data[, 1]), max(Data[, 1]), 10, 3, 1, 2), c(min(Data[, 2]),
    max(Data[, 2]), 10, 3, 1, 2)),
  ridge_adj = 0,
  XYpred = Data[, 1:2],
  z_predicted = NULL,
  se_pred = 2,
  family = "gaussian",
  link = "default",
  m_binomial = rep(1, nrow(Data)),
  wts = rep(1, nrow(Data)),
  r_gamma = rep(1, nrow(Data))
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ps2DGLM_+3A_data">Data</code></td>
<td>
<p>a matrix of 3 columns <code>x, y, z</code> of equal length;
the response is <code>z</code>.</p>
</td></tr>
<tr><td><code id="ps2DGLM_+3A_pars">Pars</code></td>
<td>
<p>a matrix of 2 rows, where the first and second row
sets the P-spline paramters for <code>x</code> and <code>y</code>, respectively.
Each row consists of: <code>min max nseg bdeg lambda pord</code>.
The <code>min</code> and <code>max</code> set the ranges, <code>nseg</code> (default 10)
is the number of evenly spaced segments between <code>min</code> and <code>max</code>,
<code>bdeg</code> is the degree of the basis (default 3 for cubic),
<code>lambda</code> is the (positive) tuning parameter for the penalty (default 1),
<code>pord</code> is the number for the order of the difference penalty (default 2).</p>
</td></tr>
<tr><td><code id="ps2DGLM_+3A_ridge_adj">ridge_adj</code></td>
<td>
<p>a ridge penalty tuning parameter, usually set to small value, e.g. <code>1e-8</code> to stabilize estimation (default 0).</p>
</td></tr>
<tr><td><code id="ps2DGLM_+3A_xypred">XYpred</code></td>
<td>
<p>a matrix with two columns <code>(x, y)</code> that give the coordinates
of (future) prediction; the default is the data locations.</p>
</td></tr>
<tr><td><code id="ps2DGLM_+3A_z_predicted">z_predicted</code></td>
<td>
<p>a vector of responses associated with <code>XYpred</code>, useful for external validation with <code>family = "gaussian"</code>.</p>
</td></tr>
<tr><td><code id="ps2DGLM_+3A_se_pred">se_pred</code></td>
<td>
<p>a scalar, default <code>se_pred = 2</code> to produce se surfaces,
set <code>se_pred</code> &gt; 0. Used for CIs for <code>XYpred</code> locations.</p>
</td></tr>
<tr><td><code id="ps2DGLM_+3A_family">family</code></td>
<td>
<p><code>"gaussian", "binomial", "poisson", "Gamma"</code> (quotes needed). Default is &quot;gaussian&quot;.</p>
</td></tr>
<tr><td><code id="ps2DGLM_+3A_link">link</code></td>
<td>
<p>the link function, one of <code>"identity"</code>, <code>"log"</code>, <code>"sqrt"</code>,
<code>"logit"</code>, <code>"probit"</code>, <code>"cloglog"</code>, <code>"loglog"</code>, <code>"reciprocal"</code>;
quotes are needed (default <code>"identity"</code>).</p>
</td></tr>
<tr><td><code id="ps2DGLM_+3A_m_binomial">m_binomial</code></td>
<td>
<p>vector of binomial trials, default is vector of ones with <code>family = "binomial"</code>, NULL otherwise.</p>
</td></tr>
<tr><td><code id="ps2DGLM_+3A_wts">wts</code></td>
<td>
<p>non-negative weights, which can be zero (default ones).</p>
</td></tr>
<tr><td><code id="ps2DGLM_+3A_r_gamma">r_gamma</code></td>
<td>
<p>gamma scale parameter, default is vector ones with <code>family = "Gamma"</code>, NULL otherwise.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Support functions needed: <code>pspline_fitter</code>, <code>bbase</code>, and <code>pspline_2dchecker</code>.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>pcoef</code></td>
<td>
<p>a vector of length <code>(Pars[1,3]+Pars[1,4])*(Pars[2,3]+Pars[2,4])</code>
of (unfolded) estimated P-spline coefficients.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>a vector of <code>length(z)</code> of smooth estimated means (at the <code>x,y</code> locations).</p>
</td></tr>
<tr><td><code>dev</code></td>
<td>
<p>the deviance of fit.</p>
</td></tr>
<tr><td><code>eff_df</code></td>
<td>
<p>the approximate effective dimension of fit.</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>AIC.</p>
</td></tr>
<tr><td><code>df_resid</code></td>
<td>
<p>approximate df residual.</p>
</td></tr>
<tr><td><code>cv</code></td>
<td>
<p>leave-one-out standard error prediction, when <code>family = 'gaussian'</code>.</p>
</td></tr>
<tr><td><code>cv_predicted</code></td>
<td>
<p>standard error prediction for <code>y_predict</code>, when <code>family = 'gaussian'</code>.</p>
</td></tr>
<tr><td><code>avediff_pred</code></td>
<td>
<p>mean absolute difference prediction, when <code>family = 'gaussian'</code>.</p>
</td></tr>
<tr><td><code>Pars</code></td>
<td>
<p>the design and tuning parameters (see arguments above).</p>
</td></tr>
<tr><td><code>dispersion_parm</code></td>
<td>
<p>estimate of dispersion, <code>dev/df_resid</code>.</p>
</td></tr>
<tr><td><code>summary_predicted</code></td>
<td>
<p>inverse link prediction vectors, and <code>se_pred</code> bands.</p>
</td></tr>
<tr><td><code>eta_predicted</code></td>
<td>
<p>estimated linear predictor of <code>length(z)</code>.</p>
</td></tr>
<tr><td><code>press_mu</code></td>
<td>
<p>leave-one-out prediction of mean, when <code>family = 'gaussian'</code>.</p>
</td></tr>
<tr><td><code>bin_percent_correct</code></td>
<td>
<p>percent correct classification based on 0.5 cut-off (when <code>family = "binomial"</code>).</p>
</td></tr>
<tr><td><code>Data</code></td>
<td>
<p>a matrix of 3 columns <code>x, y, z</code> of equal length;
the response is <code>z</code>.</p>
</td></tr>
<tr><td><code>Q</code></td>
<td>
<p>the tensor product B-spline basis.</p>
</td></tr>
<tr><td><code>qr</code></td>
<td>
<p>the Q-R of the model.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paul Eilers and Brian Marx
</p>


<h3>References</h3>

<p>Eilers, P.H.C. and Marx, B.D. (2021). <em>Practical Smoothing, The Joys of
P-splines.</em> Cambridge University Press.
</p>
<p>Eilers, P.H.C., Marx, B.D., and Durban, M. (2015).
Twenty years of P-splines, <em>SORT</em>, 39(2): 149-186.
</p>


<h3>See Also</h3>

<p>ps2DNormal
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(fields)
library(JOPS)
# Extract data
library(rpart)
Kyphosis &lt;- kyphosis$Kyphosis
Age &lt;- kyphosis$Age
Start &lt;- kyphosis$Start
y &lt;- 1 * (Kyphosis == "present") # make y 0/1
fit &lt;- ps2DGLM(
  Data = cbind(Start, Age, y),
  Pars = rbind(c(1, 18, 10, 3, .1, 2), c(1, 206, 10, 3, .1, 2)),
  family = "binomial", link = "logit")
plot(fit, xlab = "Start", ylab = "Age")
#title(main = "Probability of Kyphosis")
</code></pre>

<hr>
<h2 id='ps2DNormal'>Two-dimensional smoothing scattered (normal) data using P-splines.</h2><span id='topic+ps2DNormal'></span>

<h3>Description</h3>

<p>ps2DNormal is used to smooth scattered
(normal) data, with aniosotripic penalization of
tensor product P-splines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ps2DNormal(
  Data,
  Pars = rbind(c(min(Data[, 1]), max(Data[, 1]), 10, 3, 1, 2), c(min(Data[, 2]),
    max(Data[, 2]), 10, 3, 1, 2)),
  XYpred = expand.grid(Data[, 1], Data[, 2])
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ps2DNormal_+3A_data">Data</code></td>
<td>
<p>a matrix of 3 columns <code>x, y, z</code> of equal length;
the response is <code>z</code>.</p>
</td></tr>
<tr><td><code id="ps2DNormal_+3A_pars">Pars</code></td>
<td>
<p>a matrix of 2 rows, where the first and second row
sets the P-spline paramters for <code>x</code> and <code>y</code>, respectively.
Each row consists of: <code>min max nseg bdeg lambda pord</code>.
The <code>min</code> and <code>max</code> set the ranges, <code>nseg</code> (default 10)
is the number of evenly spaced segments between <code>min</code> and <code>max</code>,
<code>bdeg</code> is the degree of the basis (default 3 for cubic),
<code>lambda</code> is the (positive) tuning parameter for the penalty (default 1),
<code>pord</code> is the number for the order of the difference penalty (default 2),</p>
</td></tr>
<tr><td><code id="ps2DNormal_+3A_xypred">XYpred</code></td>
<td>
<p>a matrix with two columns <code>(x,y)</code> that give the coordinates
of (future) prediction; the default is the data locations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Support functions needed: <code>pspline_fitter</code>, <code>bbase</code>, and <code>pspline_2dchecker</code>.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>coef</code></td>
<td>
<p>a vector of length <code>(Pars[1,3]+Pars[1,4])*(Pars[2,3]+Pars[2,4])</code>
of (unfolded) estimated P-spline coefficients.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>a vector of <code>length(y)</code> of smooth estimated means (at the <code>x,y</code> locations).</p>
</td></tr>
<tr><td><code>pred</code></td>
<td>
<p>a vector of length <code>nrow(XYpred)</code> of (future) predictions.</p>
</td></tr>
<tr><td><code>Pars</code></td>
<td>
<p>the design and tuning parameters (see arguments above).</p>
</td></tr>
<tr><td><code>cv</code></td>
<td>
<p>leave-one-out standard error of prediction or root average PRESS.</p>
</td></tr>
<tr><td><code>h</code></td>
<td>
<p>&quot;hat&quot; diagonals of tensor P-spline fit.</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>tensor product B-spline basis used for fitting.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paul Eilers and Brian Marx
</p>


<h3>References</h3>

<p>Eilers, P.H.C. and Marx, B.D. (2021). <em>Practical Smoothing, The Joys of
P-splines.</em> Cambridge University Press.
</p>
<p>Eilers, P.H.C., Marx, B.D., and Durban, M. (2015).
Twenty years of P-splines, <em>SORT</em>, 39(2): 149-186.
</p>


<h3>See Also</h3>

<p>ps2DGLM
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(SemiPar)
library(fields)
library(spam)
library(JOPS)

# Get the data
data(ethanol)
x &lt;- ethanol$C
y &lt;- ethanol$E
z &lt;- ethanol$NOx

# Set parameters for domain
xlo &lt;- 7
xhi &lt;- 19
ylo &lt;- 0.5
yhi &lt;- 1.25

# Set P-spline parameters, fit and compute surface
xpars &lt;- c(xlo, xhi, 10, 3, 3, 1)
ypars &lt;- c(ylo, yhi, 10, 3, 3, 1)
Pars1 &lt;- rbind(xpars, ypars)
fit &lt;- ps2DNormal(cbind(x, y, z), Pars = Pars1)
plot(fit, xlab = "C", ylab = "E")
</code></pre>

<hr>
<h2 id='ps2DSignal'>Two-dimensional penalized signal regression using P-splines.</h2><span id='topic+ps2DSignal'></span>

<h3>Description</h3>

<p><code>ps2DSignal</code> is a function used to regress a (glm) response onto a two-dimensional
signal or image, with aniosotripic penalization of tensor product P-splines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ps2DSignal(
  y,
  M,
  p1,
  p2,
  M_type = "stacked",
  M1_index = c(1:p1),
  M2_index = c(1:p2),
  Pars = rbind(c(1, p1, 10, 3, 1, 2), c(1, p2, 10, 3, 1, 2)),
  ridge_adj = 1e-06,
  M_pred = M,
  y_predicted = NULL,
  family = "gaussian",
  link = "default",
  m_binomial = 1 + 0 * y,
  wts = 1 + 0 * y,
  r_gamma = 1 + 0 * y,
  int = TRUE,
  se_pred = 2
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ps2DSignal_+3A_y">y</code></td>
<td>
<p>a response vector of length <code>m</code>, usually continuous, binary/bimomial or counts.</p>
</td></tr>
<tr><td><code id="ps2DSignal_+3A_m">M</code></td>
<td>
<p>The signal/image regressors, which are either &quot;stacked&quot; or &quot;unfolded&quot;,
with dimensions (<code>m</code> * <code>p1</code>) by <code>p2</code> (i.e. <code>m</code> stacked matrices each of <code>p1</code> by <code>p2</code>)
or with dimensions <code>m</code> by (<code>p1</code> * <code>p2</code>) (i.e. regressor matrix with <code>m</code> regressor rows, each with column
length <code>p1 * p2</code>), respectively.</p>
</td></tr>
<tr><td><code id="ps2DSignal_+3A_p1">p1</code></td>
<td>
<p>the row dimension of the image.</p>
</td></tr>
<tr><td><code id="ps2DSignal_+3A_p2">p2</code></td>
<td>
<p>the column dimension of the image.</p>
</td></tr>
<tr><td><code id="ps2DSignal_+3A_m_type">M_type</code></td>
<td>
<p>&quot;stacked&quot; (signal as matrix) or &quot;unfolded&quot; (signal as vector).</p>
</td></tr>
<tr><td><code id="ps2DSignal_+3A_m1_index">M1_index</code></td>
<td>
<p>an index of length <code>p1</code> for rows of regressor matrix (default is a simple sequence).</p>
</td></tr>
<tr><td><code id="ps2DSignal_+3A_m2_index">M2_index</code></td>
<td>
<p>an index of length <code>p2</code> for columns of regressor matrix (default is a simple sequence).</p>
</td></tr>
<tr><td><code id="ps2DSignal_+3A_pars">Pars</code></td>
<td>
<p>a matrix of 2 rows, where the first and second row
sets the P-spline paramters for <code>x</code> and <code>y</code>, respectively.
Each row consists of: <code>min max nseg bdeg lambda pord</code>.
The <code>min</code> and <code>max</code> set the ranges, <code>nseg</code> (default 10)
is the number of evenly spaced segments between <code>min</code> and <code>max</code>,
<code>bdeg</code> is the degree of the basis (default 3 for cubic),
<code>lambda</code> is the (positive) tuning parameter for the penalty (default 1),
<code>pord</code> is the number for the order of the difference penalty (default 2).</p>
</td></tr>
<tr><td><code id="ps2DSignal_+3A_ridge_adj">ridge_adj</code></td>
<td>
<p>A ridge penalty tuning parameter (usually set to small value, default <code>1e-6</code>, to stabilize estimation).</p>
</td></tr>
<tr><td><code id="ps2DSignal_+3A_m_pred">M_pred</code></td>
<td>
<p>(e.g. stacked (<code>q</code> * <code>p1</code>) by <code>p2</code>
signal inputs  or (unfolded) <code>q</code> by (<code>p1</code> * <code>p2</code>) signal
inputs for <code>q</code> new predictions.</p>
</td></tr>
<tr><td><code id="ps2DSignal_+3A_y_predicted">y_predicted</code></td>
<td>
<p>a vector of responses from a cv data set (assoc. with <code>M_pred</code>), when <code>family = "gaussian"</code>.</p>
</td></tr>
<tr><td><code id="ps2DSignal_+3A_family">family</code></td>
<td>
<p>the response distribution, e.g.
<code>"gaussian", "binomial", "poisson", "Gamma"</code> distribution. Quotes are needed. Default is &quot;gaussian&quot;.</p>
</td></tr>
<tr><td><code id="ps2DSignal_+3A_link">link</code></td>
<td>
<p>the link function, one of <code>"identity"</code>, <code>"log"</code>, <code>"sqrt"</code>,
<code>"logit"</code>, <code>"probit"</code>, <code>"cloglog"</code>, <code>"loglog"</code>, <code>"reciprocal"</code>;
quotes are needed (default <code>"identity"</code>).</p>
</td></tr>
<tr><td><code id="ps2DSignal_+3A_m_binomial">m_binomial</code></td>
<td>
<p>a vector of binomial trials having <code>length(y)</code>. Default is 1 vector for <code>family = "binomial"</code>, NULL otherwise.</p>
</td></tr>
<tr><td><code id="ps2DSignal_+3A_wts">wts</code></td>
<td>
<p>the weight vector of <code>length(y)</code>. Default is 1.</p>
</td></tr>
<tr><td><code id="ps2DSignal_+3A_r_gamma">r_gamma</code></td>
<td>
<p>a vector of gamma shape parameters. Default is 1 vector for for <code>family = "Gamma"</code>, NULL otherwise.</p>
</td></tr>
<tr><td><code id="ps2DSignal_+3A_int">int</code></td>
<td>
<p>set to TRUE or FALSE to include intercept term in linear predictor (default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="ps2DSignal_+3A_se_pred">se_pred</code></td>
<td>
<p>a scalar, e.g. <code>se = 2</code> (default) to produce twice se surfaces,
set <code>se</code> &gt; 0. Used for CIs at <code>XYpred</code> locations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Support functions needed: <code>pspline_fitter</code>, <code>bbase</code>, and <code>pspline_2dchecker</code>.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>pcoef</code></td>
<td>
<p>a vector of length <code>(Pars[1,3]+Pars[1,4])*(Pars[2,3]+Pars[2,4])</code>
of (unfolded) estimated P-spline coefficients for tensor surface.</p>
</td></tr>
<tr><td><code>summary_predicted</code></td>
<td>
<p>inverse link prediction vectors, and standard error surfaces.</p>
</td></tr>
<tr><td><code>dev</code></td>
<td>
<p>deviance of fit.</p>
</td></tr>
<tr><td><code>eff_df</code></td>
<td>
<p>the approximate effective dimension of fit.</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>AIC.</p>
</td></tr>
<tr><td><code>df_resid</code></td>
<td>
<p>approximate df residual.</p>
</td></tr>
<tr><td><code>cv</code></td>
<td>
<p>leave-one-out standard error prediction, when <code>family = "gaussian"</code>.</p>
</td></tr>
<tr><td><code>cv_predicted</code></td>
<td>
<p>standard error prediction for <code>y_predict</code>, when <code>family = "gaussian"</code>.</p>
</td></tr>
<tr><td><code>avediff_pred</code></td>
<td>
<p>mean absolute difference prediction, when <code>family = 'gaussian'</code>.</p>
</td></tr>
<tr><td><code>Pars</code></td>
<td>
<p>design and tuning parameters (see above arguments).</p>
</td></tr>
<tr><td><code>Dispersion_parm</code></td>
<td>
<p>estimate of dispersion, <code>dev/df_resid</code>.</p>
</td></tr>
<tr><td><code>summary_predicted</code></td>
<td>
<p>inverse link prediction vectors at <code>M_pred</code>, and standard error bands.</p>
</td></tr>
<tr><td><code>eta_predicted</code></td>
<td>
<p>estimated linear predictor of <code>length(y)</code>.</p>
</td></tr>
<tr><td><code>press_mu</code></td>
<td>
<p>leave-one-out prediction of mean, when <code>family = "gaussian"</code>.</p>
</td></tr>
<tr><td><code>bin_percent_correct</code></td>
<td>
<p>percent correct classification based on 0.5 cut-off,
when <code>family = "binomial"</code>, NULL otherwise.</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>Tensor basis (<code>p1</code> x <code>p2</code>) by (<code>n1</code> x <code>n2</code>) for 2D signal regression.</p>
</td></tr>
<tr><td><code>Q</code></td>
<td>
<p>Effective regressors (<code>m</code> by <code>n1</code> * <code>n2</code>) for 2D signal regression.</p>
</td></tr>
<tr><td><code>Ahat</code></td>
<td>
<p>smooth P-spline coefficient vector of length <code>p1</code> x <code>p2</code>,
constructed by <code>B</code> %*% <code>pcoef</code>.</p>
</td></tr>
<tr><td><code>M</code></td>
<td>
<p>the signal/image regressors.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the response vector.</p>
</td></tr>
<tr><td><code>M1index</code></td>
<td>
<p>index of length <code>p1</code> for rows of regressor matrix.</p>
</td></tr>
<tr><td><code>M2index</code></td>
<td>
<p>index of length <code>p2</code> for columns of regressor matrix.</p>
</td></tr>
<tr><td><code>M_type</code></td>
<td>
<p>&quot;stacked&quot; or &quot;unfolded&quot;.</p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p>GLM weight vector of length <code>m</code>.</p>
</td></tr>
<tr><td><code>h</code></td>
<td>
<p>&quot;hat&quot; diagonals.</p>
</td></tr>
<tr><td><code>ridge_adj</code></td>
<td>
<p>additional ridge tuning parameter to stabilize estimation.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paul Eilers and Brian Marx
</p>


<h3>References</h3>

<p>Marx, B.D. and Eilers, P.H.C. (2005).
Multidimensional penalized signal regression, <em>Technometrics</em>, 47: 13-22.
</p>
<p>Eilers, P.H.C. and Marx, B.D. (2021). <em>Practical Smoothing, The Joys of
P-splines.</em> Cambridge University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(fields)
library(JOPS)

# Get the data
x0 &lt;- Sugar$X
x0 &lt;- x0 - apply(x0, 1, mean) # center Signal
y &lt;- as.vector(Sugar$y[, 3]) # Response is Ash

# Inputs for two-dimensional signal regression
nseg &lt;- c(7, 37)
pord &lt;- c(3, 3)
min_ &lt;- c(230, 275)
max_ &lt;- c(340, 560)
M1_index &lt;- rev(c(340, 325, 305, 290, 255, 240, 230))
M2_index &lt;- seq(from = 275, to = 560, by = .5)
p1 &lt;- length(M1_index)
p2 &lt;- length(M2_index)

# Fit optimal model based on LOOCV
opt_lam &lt;- c(8858.6679, 428.1332) # Found via svcm
Pars_opt &lt;- rbind(
  c(min_[1], max_[1], nseg[1], 3, opt_lam[1], pord[1]),
  c(min_[2], max_[2], nseg[2], 3, opt_lam[2], pord[2])
)
fit &lt;- ps2DSignal(y, x0, p1, p2, "unfolded", M1_index, M2_index,
  Pars_opt,int = TRUE, ridge_adj = 0.0001,
  M_pred = x0 )

# Plotting coefficient image
 plot(fit)
</code></pre>

<hr>
<h2 id='psBinomial'>Smoothing scattered binomial data using P-splines.</h2><span id='topic+psBinomial'></span>

<h3>Description</h3>

<p><code>psBinomial</code> is used to smooth scattered
binomial data using P-splines using a logit link function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psBinomial(
  x,
  y,
  xl = min(x),
  xr = max(x),
  nseg = 10,
  bdeg = 3,
  pord = 2,
  lambda = 1,
  ntrials = 0 * y + 1,
  wts = NULL,
  show = FALSE,
  iter = 100,
  xgrid = 100
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="psBinomial_+3A_x">x</code></td>
<td>
<p>the vector for the continuous regressor of <code>length(y)</code> and
the abcissae, on which the B-spline basis is constructed.</p>
</td></tr>
<tr><td><code id="psBinomial_+3A_y">y</code></td>
<td>
<p>the response vector, usually 0/1 or binomial counts.</p>
</td></tr>
<tr><td><code id="psBinomial_+3A_xl">xl</code></td>
<td>
<p>the lower limit for the domain of <code>x</code> (default is min(<code>x</code>)).</p>
</td></tr>
<tr><td><code id="psBinomial_+3A_xr">xr</code></td>
<td>
<p>the upper limit for the domain of <code>x</code> (default is max(<code>x</code>)).</p>
</td></tr>
<tr><td><code id="psBinomial_+3A_nseg">nseg</code></td>
<td>
<p>the number of evenly spaced segments between xl and xr.</p>
</td></tr>
<tr><td><code id="psBinomial_+3A_bdeg">bdeg</code></td>
<td>
<p>the number of the degree of the basis, usually 1, 2 (default), or 3.</p>
</td></tr>
<tr><td><code id="psBinomial_+3A_pord">pord</code></td>
<td>
<p>the number of the order of the difference penalty, usually 1, 2, or 3 (defalult).</p>
</td></tr>
<tr><td><code id="psBinomial_+3A_lambda">lambda</code></td>
<td>
<p>the (positive) number for the tuning parameter for the penalty.</p>
</td></tr>
<tr><td><code id="psBinomial_+3A_ntrials">ntrials</code></td>
<td>
<p>the vector for the number of binomial trials (default = 1).</p>
</td></tr>
<tr><td><code id="psBinomial_+3A_wts">wts</code></td>
<td>
<p>the vector of weights, default is 1, zeros allowed.</p>
</td></tr>
<tr><td><code id="psBinomial_+3A_show">show</code></td>
<td>
<p>Set to TRUE or FALSE to display iteration history.</p>
</td></tr>
<tr><td><code id="psBinomial_+3A_iter">iter</code></td>
<td>
<p>a scalar to set the maximum number of iterations, default <code>iter = 100</code>.</p>
</td></tr>
<tr><td><code id="psBinomial_+3A_xgrid">xgrid</code></td>
<td>
<p>a scalar or a vector that gives the <code>x</code> locations for prediction, useful for plotting.
If a scalar (default 100) is used then a uniform grid of this size along (<code>xl</code>, <code>xr</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>pcoef</code></td>
<td>
<p>a vector of length <code>n</code> of estimated P-spline coefficients.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>a vector of length <code>m</code> of estimated probabilities.</p>
</td></tr>
<tr><td><code>muhat</code></td>
<td>
<p>a vector of length <code>m</code> of estimated means (<code>ntrials*p</code>).</p>
</td></tr>
<tr><td><code>dev</code></td>
<td>
<p>deviance</p>
</td></tr>
<tr><td><code>effdim</code></td>
<td>
<p>effective dimension of the smooth.</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>AIC</p>
</td></tr>
<tr><td><code>wts</code></td>
<td>
<p>a vector of preset weights (default = 1).</p>
</td></tr>
<tr><td><code>nseg</code></td>
<td>
<p>the number of B-spline segments.</p>
</td></tr>
<tr><td><code>bdeg</code></td>
<td>
<p>the degree of the B-spline basis.</p>
</td></tr>
<tr><td><code>pord</code></td>
<td>
<p>the order of the difference penalty.</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>the GLM family (repsonse distribution).</p>
</td></tr>
<tr><td><code>link</code></td>
<td>
<p>the link function.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the binomial response.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>the regressor on which the basis is constructed.</p>
</td></tr>
<tr><td><code>P</code></td>
<td>
<p>&quot;half&quot; of the penalty matrix, <code>P'P = lambda*D'D</code>.</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>the B-spline basis.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>the positive tuning parameter.</p>
</td></tr>
<tr><td><code>dispersion</code></td>
<td>
<p>dispersion parameter estimated <code>dev/(m-effdim)</code>.</p>
</td></tr>
<tr><td><code>xgrid</code></td>
<td>
<p>gridded <code>x</code> values,useful for plotting.</p>
</td></tr>
<tr><td><code>ygrid</code></td>
<td>
<p>gridded fitted linear predictor values, useful for plotting.</p>
</td></tr>
<tr><td><code>pgrid</code></td>
<td>
<p>gridded (inverse link) fitted probability values, useful for plotting.</p>
</td></tr>
<tr><td><code>se_eta</code></td>
<td>
<p>gridded standard errors for the linear predictor.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paul Eilers and Brian Marx
</p>


<h3>References</h3>

<p>Eilers, P.H.C. and Marx, B.D. (2021). <em>Practical Smoothing, The Joys of
P-splines.</em> Cambridge University Press.
</p>
<p>Eilers, P.H.C., Marx, B.D., and Durban, M. (2015).
Twenty years of P-splines, <em>SORT</em>, 39(2): 149-186.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(JOPS)
# Extract data
library(rpart)
Kyphosis &lt;- kyphosis$Kyphosis
Age &lt;- kyphosis$Age
y &lt;- 1 * (Kyphosis == "present") # make y 0/1
fit1 &lt;- psBinomial(Age, y,
  xl = min(Age), xr = max(Age), nseg = 20,
  bdeg = 3, pord = 2, lambda = 10
)
names(fit1)
plot(fit1, xlab = "Age", ylab = "0/1", se = 2)
</code></pre>

<hr>
<h2 id='psNormal'>Smoothing scattered (normal) data using P-splines.</h2><span id='topic+psNormal'></span>

<h3>Description</h3>

<p><code>psNormal</code> is used to smooth scattered (normal) data using P-splines (with identity link function).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psNormal(
  x,
  y,
  xl = min(x),
  xr = max(x),
  nseg = 10,
  bdeg = 3,
  pord = 2,
  lambda = 1,
  wts = NULL,
  xgrid = 100
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="psNormal_+3A_x">x</code></td>
<td>
<p>the vector for the continuous regressor of <code>length(y)</code> and the abcissae used to build the B-spline basis.</p>
</td></tr>
<tr><td><code id="psNormal_+3A_y">y</code></td>
<td>
<p>the response vector, usually continuous data.</p>
</td></tr>
<tr><td><code id="psNormal_+3A_xl">xl</code></td>
<td>
<p>the number for the min along <code>x</code> (default is min(<code>x</code>)) .</p>
</td></tr>
<tr><td><code id="psNormal_+3A_xr">xr</code></td>
<td>
<p>the number for the max along <code>x</code> (default is max(<code>x</code>)).</p>
</td></tr>
<tr><td><code id="psNormal_+3A_nseg">nseg</code></td>
<td>
<p>the number of evenly spaced segments between <code>xl</code> and <code>xr</code>.</p>
</td></tr>
<tr><td><code id="psNormal_+3A_bdeg">bdeg</code></td>
<td>
<p>the number of the degree of the basis, usually 1, 2 (default), or 3.</p>
</td></tr>
<tr><td><code id="psNormal_+3A_pord">pord</code></td>
<td>
<p>the number of the order of the difference penalty, usually 1, 2, or 3 (defalult).</p>
</td></tr>
<tr><td><code id="psNormal_+3A_lambda">lambda</code></td>
<td>
<p>the (positive) number for the tuning parameter for the penalty (default 1).</p>
</td></tr>
<tr><td><code id="psNormal_+3A_wts">wts</code></td>
<td>
<p>the vector of general weights, default is 1; zero allowed.</p>
</td></tr>
<tr><td><code id="psNormal_+3A_xgrid">xgrid</code></td>
<td>
<p>a scalar or a vector that gives the <code>x</code> locations for prediction, useful for plotting.
If a scalar (default 100) is used then a uniform grid of this size along (<code>xl</code>, <code>xr</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>pcoeff</code></td>
<td>
<p>a vector of length <code>n</code> of estimated P-spline coefficients.</p>
</td></tr>
<tr><td><code>muhat</code></td>
<td>
<p>a vector of length <code>m</code> of smooth estimated means.</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>a matrix of dimension <code>m</code> by <code>n</code> for the B-spline basis matrix.</p>
</td></tr>
<tr><td><code>wts</code></td>
<td>
<p>a vector of length <code>m</code> of weights.</p>
</td></tr>
<tr><td><code>effdim</code></td>
<td>
<p>estimated effective dimension.</p>
</td></tr>
<tr><td><code>ed_resid</code></td>
<td>
<p>approximate df residual.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>square root of MSE.</p>
</td></tr>
<tr><td><code>cv</code></td>
<td>
<p>standard error of leave-one-out prediction or root average PRESS.</p>
</td></tr>
<tr><td><code>nseg</code></td>
<td>
<p>the number of B-spline segments.</p>
</td></tr>
<tr><td><code>bdeg</code></td>
<td>
<p>the degree of the B-spline basis.</p>
</td></tr>
<tr><td><code>pord</code></td>
<td>
<p>the order of the difference penalty.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>the positive tuning parameter.</p>
</td></tr>
<tr><td><code>xgrid</code></td>
<td>
<p>gridded x values, useful for plotting.</p>
</td></tr>
<tr><td><code>ygrid</code></td>
<td>
<p>gridded fitted mean values, useful for plotting.</p>
</td></tr>
<tr><td><code>se_eta</code></td>
<td>
<p>gridded standard errors for the fitted mean values, useful for plotting.</p>
</td></tr>
<tr><td><code>P</code></td>
<td>
<p>&quot;half&quot; of the penalty, such that <code>P'P= lambda D'D</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paul Eilers and Brian Marx
</p>


<h3>References</h3>

<p>Eilers, P.H.C. and Marx, B.D. (2021). <em>Practical Smoothing, The Joys of
P-splines.</em> Cambridge University Press.
</p>
<p>Eilers, P.H.C., Marx, B.D., and Durban, M. (2015).
Twenty years of P-splines, <em>SORT</em>, 39(2): 149-186.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(JOPS)
library(MASS)
data(mcycle)
x &lt;- mcycle$times
y &lt;- mcycle$accel
fit1 &lt;- psNormal(x, y, nseg = 20, bdeg = 3, pord = 2, lambda = .8)
plot(fit1, se = 2, xlab = "Time (ms)", ylab = "Acceleration")
</code></pre>

<hr>
<h2 id='psNormal_Deriv'>Derivative for a P-spline fit of scattered (normal)
data.</h2><span id='topic+psNormal_Deriv'></span>

<h3>Description</h3>

<p><code>psNormal_Deriv</code> provides the derivative
P-spline fit along <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psNormal_Deriv(
  x,
  y,
  xl = min(x),
  xr = max(x),
  nseg = 10,
  bdeg = 3,
  pord = 2,
  lambda = 1,
  wts = rep(1, length(y)),
  xgrid = x
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="psNormal_Deriv_+3A_x">x</code></td>
<td>
<p>the vector for the continuous regressor of <code>length(y)</code> and the abcissae of fit.</p>
</td></tr>
<tr><td><code id="psNormal_Deriv_+3A_y">y</code></td>
<td>
<p>the response vector, usually continuous data.</p>
</td></tr>
<tr><td><code id="psNormal_Deriv_+3A_xl">xl</code></td>
<td>
<p>the number for the min along <code>x</code> (default is min(<code>x</code>)) .</p>
</td></tr>
<tr><td><code id="psNormal_Deriv_+3A_xr">xr</code></td>
<td>
<p>the number for the max along <code>x</code> (default is max(<code>x</code>)).</p>
</td></tr>
<tr><td><code id="psNormal_Deriv_+3A_nseg">nseg</code></td>
<td>
<p>the number of evenly spaced segments between <code>xl</code> and <code>xr</code>.</p>
</td></tr>
<tr><td><code id="psNormal_Deriv_+3A_bdeg">bdeg</code></td>
<td>
<p>the number of the degree of the basis, usually 1, 2, or 3 (defalult).</p>
</td></tr>
<tr><td><code id="psNormal_Deriv_+3A_pord">pord</code></td>
<td>
<p>the number of the order of the difference penalty, usually 1, 2 (defalult), or 3.</p>
</td></tr>
<tr><td><code id="psNormal_Deriv_+3A_lambda">lambda</code></td>
<td>
<p>the positive tuning parameter (default 1).</p>
</td></tr>
<tr><td><code id="psNormal_Deriv_+3A_wts">wts</code></td>
<td>
<p>the vector of weights, default is 1; 0/1 allowed.</p>
</td></tr>
<tr><td><code id="psNormal_Deriv_+3A_xgrid">xgrid</code></td>
<td>
<p>a scalar or a vector that gives the <code>x</code> locations for prediction, useful for plotting.
If a scalar (default 100) is used then a uniform grid of this size along (<code>xl</code>, <code>xr</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is also a
support function needed for <code>sim_psr</code> and <code>sim_vcpsr</code>.
SISR (Eilers, Li, Marx, 2009).
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>coef</code></td>
<td>
<p>a vector of <code>length(nsegs + bdeg)</code>
of estimated P-spline coefficients.</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>The B-spline matrix of dimensions <code>m</code> by <code>length(coef)</code>.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>a vector of <code>length(y)</code> of smooth estimated means (at the <code>x</code> locations).</p>
</td></tr>
<tr><td><code>pred</code></td>
<td>
<p>a vector of <code>length(xgrid)</code> of (future) predictions.</p>
</td></tr>
<tr><td><code>d_coef</code></td>
<td>
<p>a vector of <code>length(nsegs + bdeg - 1)</code>
of differenced (derivative) estimated P-spline coefficients.</p>
</td></tr>
<tr><td><code>B_d</code></td>
<td>
<p>The first derivative B-spline matrix of dimensions <code>m</code> by <code>lengh(d_coef)</code>.</p>
</td></tr>
<tr><td><code>d_fit</code></td>
<td>
<p>a vector of <code>length(y)</code> of partial derivative (along <code>x</code>)
of the smooth estimated means (at the <code>x</code> locations).</p>
</td></tr>
<tr><td><code>d_pred</code></td>
<td>
<p>a vector of length <code>lenght(xgrid)</code> of partial derivative (future) predictions.</p>
</td></tr>
<tr><td><code>xl</code></td>
<td>
<p>the number for the min along <code>x</code> (default is min(<code>x</code>)).</p>
</td></tr>
<tr><td><code>xr</code></td>
<td>
<p>the number for the max along <code>x</code> (default is max(<code>x</code>)).</p>
</td></tr>
<tr><td><code>nseg</code></td>
<td>
<p>the number of evenly spaced segments between <code>xl</code> and <code>xr</code>.</p>
</td></tr>
<tr><td><code>bdeg</code></td>
<td>
<p>the number of the degree of the basis, usually 1, 2, or 3 (default).</p>
</td></tr>
<tr><td><code>pord</code></td>
<td>
<p>the number of the order of the difference penalty, usually 1, 2 (default), or 3.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>the positive tuning parameter (default 1).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paul Eilers and Brian Marx
</p>


<h3>References</h3>

<p>Marx, B. D. (2015). Varying-coefficient single-index signal
regression. <em>Chemometrics and Intelligent Laboratory Systems</em>, 143, 111–121.
</p>
<p>Eilers, P.H.C., B. Li, B.D. Marx (2009).
Multivariate calibration with single-index signal regression,
<em>Chemometrics and Intellegent Laboratory Systems</em>, 96(2), 196-202.
</p>
<p>Eilers, P.H.C. and Marx, B.D. (2021). <em>Practical Smoothing, The Joys of
P-splines.</em> Cambridge University Press.
</p>


<h3>See Also</h3>

<p>sim_psr sim_vcpsr
</p>

<hr>
<h2 id='pspline_checker'>P-spline checking algorithm for the GLM.</h2><span id='topic+pspline_checker'></span>

<h3>Description</h3>

<p><code>pspline_checker</code> checks to see if all the inputs associated
for P-spines are properly defined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pspline_checker(family, link, bdeg, pord, nseg, lambda, ridge_adj, wts)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pspline_checker_+3A_family">family</code></td>
<td>
<p>the response distribution, e.g. <code>"gaussian", "binomial", "poisson", "Gamma"</code> distribution. Quotes are needed.</p>
</td></tr>
<tr><td><code id="pspline_checker_+3A_link">link</code></td>
<td>
<p>the link function, one of <code>"identity"</code>, <code>"log"</code>, <code>"sqrt"</code>,
<code>"logit"</code>, <code>"probit"</code>, <code>"cloglog"</code>, <code>"loglog"</code>, <code>"reciprocal"</code>;</p>
</td></tr>
<tr><td><code id="pspline_checker_+3A_bdeg">bdeg</code></td>
<td>
<p>the degree of B-splines.</p>
</td></tr>
<tr><td><code id="pspline_checker_+3A_pord">pord</code></td>
<td>
<p>the order of the penalty.</p>
</td></tr>
<tr><td><code id="pspline_checker_+3A_nseg">nseg</code></td>
<td>
<p>the number of evenly-spaced B-spline segmements.</p>
</td></tr>
<tr><td><code id="pspline_checker_+3A_lambda">lambda</code></td>
<td>
<p>the positive tuning parameter for the difference penalty.</p>
</td></tr>
<tr><td><code id="pspline_checker_+3A_ridge_adj">ridge_adj</code></td>
<td>
<p>the positive tuning parameter for the ridge penalty.</p>
</td></tr>
<tr><td><code id="pspline_checker_+3A_wts">wts</code></td>
<td>
<p>the weight vector, separate from GLM weights.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>list</code></td>
<td>
<p>same as inputs, with warnings if required.</p>
</td></tr>
</table>

<hr>
<h2 id='pspline_fitter'>P-spline fitting algorithm for the GLM.</h2><span id='topic+pspline_fitter'></span>

<h3>Description</h3>

<p><code>pspline_fitter</code> appies the method of scoring
to a variety of response distributions and link functions within
for P-spline fitting within the GLM framework.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pspline_fitter(
  y,
  B,
  family = "gaussian",
  link = "identity",
  P,
  P_ridge = 0 * diag(ncol(B)),
  wts = 0 * y + 1,
  m_binomial = 0 * y + 1,
  r_gamma = 0 * y + 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pspline_fitter_+3A_y">y</code></td>
<td>
<p>the glm response vector of length <code>m</code>.</p>
</td></tr>
<tr><td><code id="pspline_fitter_+3A_b">B</code></td>
<td>
<p>The effective P-spline regressors, e.g. <code>B</code> for B-splines, <code>Q=X %*% B</code> for PSR.</p>
</td></tr>
<tr><td><code id="pspline_fitter_+3A_family">family</code></td>
<td>
<p>the response distribution, e.g. <code>"gaussian", "binomial", "poisson", "Gamma"</code> distribution; quotes are needed
(default <code>family = "gaussian"</code>.)</p>
</td></tr>
<tr><td><code id="pspline_fitter_+3A_link">link</code></td>
<td>
<p>the link function, one of <code>"identity"</code>, <code>"log"</code>, <code>"sqrt"</code>,
<code>"logit"</code>, <code>"probit"</code>, <code>"cloglog"</code>, <code>"loglog"</code>, <code>"reciprocal"</code>;
quotes are needed (default <code>link = "identity"</code>).</p>
</td></tr>
<tr><td><code id="pspline_fitter_+3A_p">P</code></td>
<td>
<p>P-spline (&quot;half&quot;) penalty matrix for data augmentation, such that <code>P'P = lambda D'D</code>.</p>
</td></tr>
<tr><td><code id="pspline_fitter_+3A_p_ridge">P_ridge</code></td>
<td>
<p>ridge (&quot;half&quot;) penalty for data augmentation, usually <code>sqrt(lambda_r)*I</code> (default 0).</p>
</td></tr>
<tr><td><code id="pspline_fitter_+3A_wts">wts</code></td>
<td>
<p>the weight vector of <code>length(y)</code>, separate from GLM weights.</p>
</td></tr>
<tr><td><code id="pspline_fitter_+3A_m_binomial">m_binomial</code></td>
<td>
<p>a vector of binomial trials having <code>length(y)</code>, when <code>family = "binomial"</code>.
Default is 1 vector.</p>
</td></tr>
<tr><td><code id="pspline_fitter_+3A_r_gamma">r_gamma</code></td>
<td>
<p>a vector of gamma shape parameters, when <code>family = "Gamma"</code>. Default is 1 vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>coef</code></td>
<td>
<p>the estimated P-spline coefficient regressor, using the effective regressors.</p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p><code>wts*w</code>, GLM weight vector times input weights of length m.</p>
</td></tr>
<tr><td><code>f</code></td>
<td>
<p>the <code>lsfit</code> object using data augmentation to get P-spline coefficient estimates.</p>
</td></tr>
<tr><td><code>eta</code></td>
<td>
<p>the linear predictor from <code>f</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='pspline2d_checker'>P-spline 2D tensor product checking algorithm for the GLM.</h2><span id='topic+pspline2d_checker'></span>

<h3>Description</h3>

<p><code>pspline_2dchecker</code> checks to see if all the 2D tensor inputs associated
for P-spines are properly defined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pspline2d_checker(
  family,
  link,
  bdeg1,
  bdeg2,
  pord1,
  pord2,
  nseg1,
  nseg2,
  lambda1,
  lambda2,
  ridge_adj,
  wts
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pspline2d_checker_+3A_family">family</code></td>
<td>
<p>the response distribution, e.g. <code>"gaussian", "binomial", "poisson", "Gamma"</code> distribution. Quotes are needed.</p>
</td></tr>
<tr><td><code id="pspline2d_checker_+3A_link">link</code></td>
<td>
<p>the link function, one of <code>"identity"</code>, <code>"log"</code>, <code>"sqrt"</code>,
<code>"logit"</code>, <code>"probit"</code>, <code>"cloglog"</code>, <code>"loglog"</code>, <code>"reciprocal"</code>;
quotes are needed.</p>
</td></tr>
<tr><td><code id="pspline2d_checker_+3A_bdeg1">bdeg1</code></td>
<td>
<p>the degree of B-splines.</p>
</td></tr>
<tr><td><code id="pspline2d_checker_+3A_bdeg2">bdeg2</code></td>
<td>
<p>the degree of B-splines.</p>
</td></tr>
<tr><td><code id="pspline2d_checker_+3A_pord1">pord1</code></td>
<td>
<p>the order of the penalty.</p>
</td></tr>
<tr><td><code id="pspline2d_checker_+3A_pord2">pord2</code></td>
<td>
<p>the order of the penalty.</p>
</td></tr>
<tr><td><code id="pspline2d_checker_+3A_nseg1">nseg1</code></td>
<td>
<p>the number of evenly spaced B-spline segmements.</p>
</td></tr>
<tr><td><code id="pspline2d_checker_+3A_nseg2">nseg2</code></td>
<td>
<p>the number of evenly spaced B-spline segmements.</p>
</td></tr>
<tr><td><code id="pspline2d_checker_+3A_lambda1">lambda1</code></td>
<td>
<p>the positive tuning parameter for the difference penalty.</p>
</td></tr>
<tr><td><code id="pspline2d_checker_+3A_lambda2">lambda2</code></td>
<td>
<p>the positive tuning parameter for the difference penalty.</p>
</td></tr>
<tr><td><code id="pspline2d_checker_+3A_ridge_adj">ridge_adj</code></td>
<td>
<p>the positive tuning parameter for the ridge penalty.</p>
</td></tr>
<tr><td><code id="pspline2d_checker_+3A_wts">wts</code></td>
<td>
<p>the weight vector, separate from GLM weights.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>list</code></td>
<td>
<p>same as inputs, with warnings if required.</p>
</td></tr>
</table>

<hr>
<h2 id='psPoisson'>Smoothing scattered Poisson data using P-splines.</h2><span id='topic+psPoisson'></span>

<h3>Description</h3>

<p><code>psPoisson</code> is used to smooth scattered
Poisson data using P-splines with a log link function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psPoisson(
  x,
  y,
  xl = min(x),
  xr = max(x),
  nseg = 10,
  bdeg = 3,
  pord = 2,
  lambda = 1,
  wts = NULL,
  show = FALSE,
  iter = 100,
  xgrid = 100
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="psPoisson_+3A_x">x</code></td>
<td>
<p>the vector for the continuous regressor of <code>length(y)</code> and
the abcissae used to build the B-spline basis.</p>
</td></tr>
<tr><td><code id="psPoisson_+3A_y">y</code></td>
<td>
<p>the response vector, usually count data.</p>
</td></tr>
<tr><td><code id="psPoisson_+3A_xl">xl</code></td>
<td>
<p>the number for the min along <code>x</code> (default is min(<code>x</code>)).</p>
</td></tr>
<tr><td><code id="psPoisson_+3A_xr">xr</code></td>
<td>
<p>the number for the max along <code>x</code> (default is max(<code>x</code>)).</p>
</td></tr>
<tr><td><code id="psPoisson_+3A_nseg">nseg</code></td>
<td>
<p>the number of evenly spaced segments between <code>xl</code> and <code>xr</code> (default 10).</p>
</td></tr>
<tr><td><code id="psPoisson_+3A_bdeg">bdeg</code></td>
<td>
<p>the number of the degree of the basis, usually 1, 2, or 3 (defalult).</p>
</td></tr>
<tr><td><code id="psPoisson_+3A_pord">pord</code></td>
<td>
<p>the number of the order of the difference penalty, usually 1, 2 (default), or 3.</p>
</td></tr>
<tr><td><code id="psPoisson_+3A_lambda">lambda</code></td>
<td>
<p>the (positive) number for the tuning parameter for the penalty (default 1).</p>
</td></tr>
<tr><td><code id="psPoisson_+3A_wts">wts</code></td>
<td>
<p>the vector of general weights, zeros are allowed (default 1).</p>
</td></tr>
<tr><td><code id="psPoisson_+3A_show">show</code></td>
<td>
<p>Set to TRUE or FALSE to display iteration history (default FALSE).</p>
</td></tr>
<tr><td><code id="psPoisson_+3A_iter">iter</code></td>
<td>
<p>a scalar to set the maximum number of iterations, default <code>iter=100</code>.</p>
</td></tr>
<tr><td><code id="psPoisson_+3A_xgrid">xgrid</code></td>
<td>
<p>a scalar or a vector that gives the <code>x</code> locations for prediction, useful for plotting.
If a scalar (default 100) is used then a uniform grid of this size along (<code>xl</code>, <code>xr</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>pcoef</code></td>
<td>
<p>a vector of length <code>n</code> of estimated P-spline coefficients.</p>
</td></tr>
<tr><td><code>muhat</code></td>
<td>
<p>a vector of length <code>m</code> of estimated means.</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>the <code>m</code> by <code>n</code> B-spline basis.</p>
</td></tr>
<tr><td><code>dev</code></td>
<td>
<p>deviance of fit.</p>
</td></tr>
<tr><td><code>effdim</code></td>
<td>
<p>effective dimension of fit.</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>AIC.</p>
</td></tr>
<tr><td><code>wts</code></td>
<td>
<p>the vector of given prior weights.</p>
</td></tr>
<tr><td><code>nseg</code></td>
<td>
<p>the number of B-spline segments.</p>
</td></tr>
<tr><td><code>bdeg</code></td>
<td>
<p>the degree of the B-spline basis.</p>
</td></tr>
<tr><td><code>pord</code></td>
<td>
<p>the order of the difference penalty.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>the positive tuning parameter.</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>the family of the response (
<code>"Poisson"</code>).</p>
</td></tr>
<tr><td><code>link</code></td>
<td>
<p>the link function used (<code>"log"</code>).</p>
</td></tr>
<tr><td><code>xgrid</code></td>
<td>
<p>gridded x values, useful for plotting.</p>
</td></tr>
<tr><td><code>ygrid</code></td>
<td>
<p>gridded fitted linear predictor values, useful for plotting.</p>
</td></tr>
<tr><td><code>mugrid</code></td>
<td>
<p>gridded (inverse link) fitted mean values, useful for plotting.</p>
</td></tr>
<tr><td><code>se_eta</code></td>
<td>
<p>gridded standard errors for the linear predictor.</p>
</td></tr>
<tr><td><code>dispersion</code></td>
<td>
<p>Dispersion parameter estimated <code>dev/(m-effdim)</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paul Eilers and Brian Marx
</p>


<h3>References</h3>

<p>Eilers, P.H.C. and Marx, B.D. (2021). <em>Practical Smoothing, The Joys of
P-splines.</em> Cambridge University Press.
</p>
<p>Eilers, P.H.C., Marx, B.D., and Durban, M. (2015).
Twenty years of P-splines, <em>SORT</em>, 39(2): 149-186.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(JOPS)
library(boot)

# Extract the data
Count &lt;- hist(boot::coal$date, breaks = c(1851:1963), plot = FALSE)$counts
Year &lt;- c(1851:1962)
xl &lt;- min(Year)
xr &lt;- max(Year)

# Poisson smoothing
nseg &lt;- 20
bdeg &lt;- 3
fit1 &lt;- psPoisson(Year, Count, xl, xr, nseg, bdeg, pord = 2, lambda = 1)
plot(fit1, xlab = "Year", ylab = "Count", se = 2)
</code></pre>

<hr>
<h2 id='psSignal'>Smooth signal (multivariate calibration) regression using P-splines.</h2><span id='topic+psSignal'></span>

<h3>Description</h3>

<p>Smooth signal (multivariate calibration) regression using P-splines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psSignal(
  y,
  x_signal,
  x_index = c(1:ncol(x_signal)),
  nseg = 10,
  bdeg = 3,
  pord = 3,
  lambda = 1,
  wts = 1 + 0 * y,
  family = "gaussian",
  link = "default",
  m_binomial = 1 + 0 * y,
  r_gamma = wts,
  y_predicted = NULL,
  x_predicted = x_signal,
  ridge_adj = 0,
  int = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="psSignal_+3A_y">y</code></td>
<td>
<p>a (glm) response vector, usually continuous, binomial or count data.</p>
</td></tr>
<tr><td><code id="psSignal_+3A_x_signal">x_signal</code></td>
<td>
<p>a matrix of continuous regressor with <code>nrow(x_signal) == length(y)</code>, often
a discrete digitization of a signal or histogram or time series.</p>
</td></tr>
<tr><td><code id="psSignal_+3A_x_index">x_index</code></td>
<td>
<p>a vector to of length <code>ncol(x_signal) == p</code>, associated with the
ordering index of the signal. Default is <code>1:ncol(x_signal)</code>.</p>
</td></tr>
<tr><td><code id="psSignal_+3A_nseg">nseg</code></td>
<td>
<p>the number of evenly spaced segments between <code>xl</code> and <code>xr</code> (default 10).</p>
</td></tr>
<tr><td><code id="psSignal_+3A_bdeg">bdeg</code></td>
<td>
<p>the degree of the basis, usually 1, 2, or 3 (defalult).</p>
</td></tr>
<tr><td><code id="psSignal_+3A_pord">pord</code></td>
<td>
<p>the order of the difference penalty, usually 1, 2, or 3 (defalult).</p>
</td></tr>
<tr><td><code id="psSignal_+3A_lambda">lambda</code></td>
<td>
<p>the (positive) tuning parameter for the penalty (default 1).</p>
</td></tr>
<tr><td><code id="psSignal_+3A_wts">wts</code></td>
<td>
<p>the weight vector of <code>length(y)</code>; default is 1.</p>
</td></tr>
<tr><td><code id="psSignal_+3A_family">family</code></td>
<td>
<p>the response distribution, e.g.
<code>"gaussian", "binomial", "poisson", "Gamma"</code> distribution; quotes are needed. Default is <code>"gaussian"</code>.</p>
</td></tr>
<tr><td><code id="psSignal_+3A_link">link</code></td>
<td>
<p>the link function, one of <code>"identity"</code>, <code>"log"</code>, <code>"sqrt"</code>,
<code>"logit"</code>, <code>"probit"</code>, <code>"cloglog"</code>, <code>"loglog"</code>, <code>"reciprocal"</code>;
quotes are needed (default <code>"identity"</code>).</p>
</td></tr>
<tr><td><code id="psSignal_+3A_m_binomial">m_binomial</code></td>
<td>
<p>a vector of binomial trials having length(y); default is 1 vector for <code>family = "binomial"</code>, NULL otherwise.</p>
</td></tr>
<tr><td><code id="psSignal_+3A_r_gamma">r_gamma</code></td>
<td>
<p>a vector of gamma shape parameters. Default is 1 vector for <code>family = "Gamma"</code>, NULL otherwise.</p>
</td></tr>
<tr><td><code id="psSignal_+3A_y_predicted">y_predicted</code></td>
<td>
<p>a vector of responses associated
with <code>x_predicted</code> which are used to calculate standard error of external prediction. Default is NULL.</p>
</td></tr>
<tr><td><code id="psSignal_+3A_x_predicted">x_predicted</code></td>
<td>
<p>a matrix of external signals to yield external prediction.</p>
</td></tr>
<tr><td><code id="psSignal_+3A_ridge_adj">ridge_adj</code></td>
<td>
<p>A ridge penalty tuning parameter, which can be set to small value, e.g. <code>1e-8</code> to stabilize estimation, (default 0).</p>
</td></tr>
<tr><td><code id="psSignal_+3A_int">int</code></td>
<td>
<p>set to TRUE or FALSE to include intercept term in linear predictor (default TRUE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Support functions needed: <code>pspline_fitter</code>, <code>bbase</code> and <code>pspline_checker</code>.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>coef</code></td>
<td>
<p>a vector with <code>length(n)</code> of estimated P-spline coefficients.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>a vector with <code>length(m)</code> of estimated means.</p>
</td></tr>
<tr><td><code>eta</code></td>
<td>
<p>a vector of <code>length(m)</code> of estimated linear predictors.</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>the B-spline basis (for the coefficients), with dimension <code>p</code> by <code>n</code>.</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>the deviance of fit.</p>
</td></tr>
<tr><td><code>eff_df</code></td>
<td>
<p>the approximate effective dimension of fit.</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>AIC.</p>
</td></tr>
<tr><td><code>df_resid</code></td>
<td>
<p>approximate df residual.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>a vector of length <code>p</code>, containing estimated smooth signal coefficients.</p>
</td></tr>
<tr><td><code>std_beta</code></td>
<td>
<p>a vector of length <code>p</code>, containing standard errors of smooth signal coefficients.</p>
</td></tr>
<tr><td><code>cv</code></td>
<td>
<p>leave-one-out standard error prediction, when <code>family = "gaussian"</code>.</p>
</td></tr>
<tr><td><code>cv_predicted</code></td>
<td>
<p>standard error prediction for <code>y_predict</code>, when <code>family = "gaussian"</code>, NULL otherwise.</p>
</td></tr>
<tr><td><code>nseg</code></td>
<td>
<p>the number of evenly spaced B-spline segments.</p>
</td></tr>
<tr><td><code>bdeg</code></td>
<td>
<p>the degree of B-splines.</p>
</td></tr>
<tr><td><code>pord</code></td>
<td>
<p>the order of the difference penalty.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>the positive tuning parameter.</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>the family of the response.</p>
</td></tr>
<tr><td><code>link</code></td>
<td>
<p>the link function.</p>
</td></tr>
<tr><td><code>y_intercept</code></td>
<td>
<p>the estimated y-intercept (when <code>int = TRUE</code>.)</p>
</td></tr>
<tr><td><code>int</code></td>
<td>
<p>a logical variable related to use of y-intercept in model.</p>
</td></tr>
<tr><td><code>dispersion_param</code></td>
<td>
<p>estimate of dispersion, <code>Dev/df_resid</code>.</p>
</td></tr>
<tr><td><code>summary_predicted</code></td>
<td>
<p>inverse link prediction vectors, and twice se bands.</p>
</td></tr>
<tr><td><code>eta_predicted</code></td>
<td>
<p>estimated linear predictor of <code>length(y)</code>.</p>
</td></tr>
<tr><td><code>press_mu</code></td>
<td>
<p>leave-one-out prediction of mean, when <code>family = "gaussian"</code>, NULL otherwise.</p>
</td></tr>
<tr><td><code>bin_percent_correct</code></td>
<td>
<p>percent correct classification based on 0.5 cut-off, when <code>family = binomial</code>, NULL otherwise.</p>
</td></tr>
<tr><td><code>x_index</code></td>
<td>
<p>a vector to of length <code>ncol(x_signal) == p</code>, associated with the ordering of the signal.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Brian Marx
</p>


<h3>References</h3>

<p>Marx, B.D. and Eilers, P.H.C. (1999). Generalized linear regression for sampled signals and
curves: A P-spline approach. <em>Technometrics</em>, 41(1): 1-13.
</p>
<p>Eilers, P.H.C. and Marx, B.D. (2021). <em>Practical Smoothing, The Joys of
P-splines.</em> Cambridge University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(JOPS)
# Get the data
library(fds)
data(nirc)
iindex &lt;- nirc$x
X &lt;- nirc$y
sel &lt;- 50:650 # 1200 &lt;= x &amp; x&lt;= 2400
X &lt;- X[sel, ]
iindex &lt;- iindex[sel]
dX &lt;- diff(X)
diindex &lt;- iindex[-1]
y &lt;- as.vector(labc[1, 1:40]) # percent fat
oout &lt;- 23
dX &lt;- t(dX[, -oout])
y &lt;- y[-oout]
fit1 &lt;- psSignal(y, dX, diindex, nseg = 25, bdeg = 3, lambda = 0.0001,
pord = 2, family = "gaussian", link = "identity", x_predicted = dX, int = TRUE)
plot(fit1, xlab = "Coefficient Index", ylab = "ps Smooth Coeff")
title(main = "25 B-spline segments with tuning = 0.0001")
names(fit1)
</code></pre>

<hr>
<h2 id='psVCSignal'>Varying-coefficient penalized signal regression using P-splines.</h2><span id='topic+psVCSignal'></span>

<h3>Description</h3>

<p><code>psVCSignal</code> is used to regress a (glm) response onto a
signal such that the signal coefficients can vary over another covariate <code>t</code>.
Anisotripic penalization of tensor product B-splines produces a 2D coefficient surface that
can be sliced at <code>t</code>.
</p>
<p>@details Support functions needed: <code>pspline_fitter</code>, <code>pspline_2dchecker</code>,
and <code>bbase</code>.
</p>
<p>@import stats
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psVCSignal(
  y,
  X,
  x_index,
  t_var,
  Pars = rbind(c(min(x_index), max(x_index), 10, 3, 1, 2), c(min(t_var), max(t_var), 10,
    3, 1, 2)),
  family = "gaussian",
  link = "default",
  m_binomial = 1 + 0 * y,
  wts = 1 + 0 * y,
  r_gamma = 1 + 0 * y,
  X_pred = X,
  t_pred = t_var,
  y_predicted = NULL,
  ridge_adj = 1e-08,
  int = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="psVCSignal_+3A_y">y</code></td>
<td>
<p>a glm response vector of length <code>m</code>, usually continuous, binary/bimomial or counts.</p>
</td></tr>
<tr><td><code id="psVCSignal_+3A_x">X</code></td>
<td>
<p>a <code>m</code> by <code>p1</code> Signal matrix of regressors.</p>
</td></tr>
<tr><td><code id="psVCSignal_+3A_x_index">x_index</code></td>
<td>
<p><code>p1</code>-vector for index of Signal (e.g. wavelength).</p>
</td></tr>
<tr><td><code id="psVCSignal_+3A_t_var">t_var</code></td>
<td>
<p><code>p2</code>-vector with other (indexing) variable in coefficient surface (e.g. temperature, depth, time).</p>
</td></tr>
<tr><td><code id="psVCSignal_+3A_pars">Pars</code></td>
<td>
<p>a matrix with 2 rows, each with P-spline parameters:
<code>min max nseg bdeg lambda pord</code>, for row and columns of tensor product surface; defaults are min and
max for <code>x_index</code> and <code>t_var</code> (resp.), <code>nseg</code> = 10, <code>bdeg</code> =3,
<code>lambda</code> = 1, <code>pord</code> = 2.</p>
</td></tr>
<tr><td><code id="psVCSignal_+3A_family">family</code></td>
<td>
<p>the response distribution, e.g.
<code>"gaussian", "binomial", "poisson", "Gamma"</code> distribution; quotes are needed (default <code>"gaussian"</code>.</p>
</td></tr>
<tr><td><code id="psVCSignal_+3A_link">link</code></td>
<td>
<p>the link function, one of <code>"identity"</code>, <code>"log"</code>, <code>"sqrt"</code>,
<code>"logit"</code>, <code>"probit"</code>, <code>"cloglog"</code>, <code>"loglog"</code>, <code>"reciprocal"</code>);
quotes are needed (default <code>"identity"</code>.</p>
</td></tr>
<tr><td><code id="psVCSignal_+3A_m_binomial">m_binomial</code></td>
<td>
<p>a vector of binomial trials having <code>length(y)</code>. Default is 1 vector for <code>family = "binomial"</code>, NULL otherwise.</p>
</td></tr>
<tr><td><code id="psVCSignal_+3A_wts">wts</code></td>
<td>
<p>a <code>m</code> vector of weights (default 1).</p>
</td></tr>
<tr><td><code id="psVCSignal_+3A_r_gamma">r_gamma</code></td>
<td>
<p>a vector of gamma shape parameters. Default is 1 vector for <code>family = "Gamma"</code>, NULL otherwise.</p>
</td></tr>
<tr><td><code id="psVCSignal_+3A_x_pred">X_pred</code></td>
<td>
<p>a matrix of signals with <code>ncol(X)</code> columns for prediction, default is <code>X</code>.</p>
</td></tr>
<tr><td><code id="psVCSignal_+3A_t_pred">t_pred</code></td>
<td>
<p>a vector for the VC indexing variable with length <code>nrow(X_pred)</code>, default is <code>t_var</code>.</p>
</td></tr>
<tr><td><code id="psVCSignal_+3A_y_predicted">y_predicted</code></td>
<td>
<p>a vector for the responses associated with <code>X_pred</code>
with length <code>nrow(X_pred)</code> useful for CV when <code>family = "binomial"</code>, default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="psVCSignal_+3A_ridge_adj">ridge_adj</code></td>
<td>
<p>a small ridge penalty tuning parameter to regularize estimation (default <code>1e-8</code>).</p>
</td></tr>
<tr><td><code id="psVCSignal_+3A_int">int</code></td>
<td>
<p>intercept set to TRUE or FALSE for intercept term.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>pcoef</code></td>
<td>
<p>a vector of length <code>(Pars[1,3]+Pars[1,4])</code>*<code>(Pars[2,3]+Pars[2,4])</code>
of estimated P-spline coefficients for tensor surface.</p>
</td></tr>
<tr><td><code>summary_predicted</code></td>
<td>
<p>inverse link prediction vectors, and twice se bands.</p>
</td></tr>
<tr><td><code>dev</code></td>
<td>
<p> the deviance of fit.</p>
</td></tr>
<tr><td><code>eff_dim</code></td>
<td>
<p>the approximate effective dimension of fit.</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>the family of the response.</p>
</td></tr>
<tr><td><code>link</code></td>
<td>
<p>the link function.</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>AIC.</p>
</td></tr>
<tr><td><code>df_resid</code></td>
<td>
<p>approximate df residual.</p>
</td></tr>
<tr><td><code>cv</code></td>
<td>
<p>leave-one-out standard error prediction when <code>family = "gaussian"</code>, NULL otherwise.</p>
</td></tr>
<tr><td><code>cv_predicted</code></td>
<td>
<p>standard error prediction for <code>y_predict</code> when <code>family = "gaussian"</code>, NULL otherwise.</p>
</td></tr>
<tr><td><code>Pars</code></td>
<td>
<p>design and tuning parameters; see arguments above.</p>
</td></tr>
<tr><td><code>dispersion_parm</code></td>
<td>
<p>estimate of dispersion, <code>Dev/df_resid</code>.</p>
</td></tr>
<tr><td><code>summary_predicted</code></td>
<td>
<p>inverse link prediction vectors, and twice se bands.</p>
</td></tr>
<tr><td><code>eta_predicted</code></td>
<td>
<p>estimated linear predictor of <code>length(y)</code>.</p>
</td></tr>
<tr><td><code>press_mu</code></td>
<td>
<p>leave-one-out prediction of mean when <code>family = "gaussian"</code>, NULL otherwise.</p>
</td></tr>
<tr><td><code>bin_percent_correct</code></td>
<td>
<p>percent correct classification based on 0.5 cut-off when <code>family = "binomial"</code>, NULL otherwise.</p>
</td></tr>
<tr><td><code>Bx</code></td>
<td>
<p>B-spline basis matrix of dimension <code>p1</code> by <code>n1</code>, along <code>x_index</code>.</p>
</td></tr>
<tr><td><code>By</code></td>
<td>
<p>B-spline basis matrix of dimension <code>p2</code> by <code>n2</code>, along <code>t_var</code>.</p>
</td></tr>
<tr><td><code>Q</code></td>
<td>
<p>Modified tensor basis (<code>m</code> by <code>(n1*n2)</code>) for VC signal regression.</p>
</td></tr>
<tr><td><code>yint</code></td>
<td>
<p>the estimated y-intercept (when <code>int = TRUE</code>.)</p>
</td></tr>
<tr><td><code>int</code></td>
<td>
<p>a logical variable related to use of y-intercept in model.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paul Eilers and Brian Marx
</p>


<h3>References</h3>

<p>Eilers, P.H.C. and Marx, B.D. (2003). Multivariate calibration with temperature
interaction using two-dimensional penalized signal regression. <em>Chemometrics
and Intellegent Laboratory Systems</em>, 66, 159–174.
</p>
<p>Eilers, P.H.C. and Marx, B.D. (2021). <em>Practical Smoothing, The Joys of
P-splines.</em> Cambridge University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(fds)
data(nirc)
iindex &lt;- nirc$x
X &lt;- nirc$y
sel &lt;- 50:650 # 1200 &lt;= x &amp; x&lt;= 2400
X &lt;- X[sel, ]
iindex &lt;- iindex[sel]
dX &lt;- diff(X)
diindex &lt;- iindex[-1]
y &lt;- as.vector(labc[1, 1:40]) # percent fat
t_var &lt;- as.vector(labc[4, 1:40]) # percent flour
oout &lt;- 23
dX &lt;- t(dX[, -oout])
y &lt;- y[-oout]
t_var = t_var[-oout]
Pars = rbind(c(min(diindex), max(diindex), 25, 3, 1e-7, 2),
c(min(t_var), max(t_var), 20, 3, 0.0001, 2))
fit1 &lt;- psVCSignal(y, dX, diindex, t_var, Pars = Pars,
family = "gaussian", link = "identity", int = TRUE)
plot(fit1, xlab = "Coefficient Index", ylab = "VC: % Flour")
names(fit1)
</code></pre>

<hr>
<h2 id='rdw'>Observations on the widths of red blood cell distributions (RDW).</h2><span id='topic+rdw'></span>

<h3>Description</h3>

<p>Observations on the widths of red blood cell distributions (RDW).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(rdw)
</code></pre>


<h3>Format</h3>

<p>A vector.
</p>


<h3>Source</h3>

<p>Erasmus University Medical Centre, Rotterdam, The Netherlands
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rdw)
hist(rdw, breaks = 20)
</code></pre>

<hr>
<h2 id='rowtens'>Compute the row tensor product of two matrices</h2><span id='topic+rowtens'></span>

<h3>Description</h3>

<p>Compute the row tensor product of two matrices with identical numbers of rows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowtens(X, Y = X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rowtens_+3A_x">X</code></td>
<td>
<p>a numeric matrix.</p>
</td></tr>
<tr><td><code id="rowtens_+3A_y">Y</code></td>
<td>
<p>a numeric matrix (if missing, <code>Y = x</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input matrices must have the same number of rows, say <code>m</code>. If their numbers of columns are <code>n1</code> and <code>n2</code>,
the result is a matrix with <code>m</code> rows and <code>n1 * n2</code> columns. Each row of the result is the Kronecker
product of the corresponding rows of <code>X</code> and <code>Y</code>.
</p>


<h3>Value</h3>

<p>The row-wise tensor product of the two matrices.
</p>


<h3>Author(s)</h3>

<p>Paul Eilers
</p>


<h3>References</h3>

<p>Eilers, P. H. C. and Currie, I. D. and Durban, M. (2006)
Fast and compact smoothing on large multidimensional grids
<em>CSDA</em> 50, 61&ndash;76.
</p>

<hr>
<h2 id='save_PDF'>Save a plot as a PDF file.</h2><span id='topic+save_PDF'></span>

<h3>Description</h3>

<p>Save a plot as a PDF file in a (default) folder.
The present default is determined by the folder structure for the production of the book.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save_PDF(
  fname = "scratch",
  folder = "../../Graphs",
  show = T,
  width = 6,
  height = 4.5
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="save_PDF_+3A_fname">fname</code></td>
<td>
<p>the file name without the extension PDF (default: <code>scratch</code>).</p>
</td></tr>
<tr><td><code id="save_PDF_+3A_folder">folder</code></td>
<td>
<p>the folder for saving PDF plots (default <code>../../Graphs)</code>.</p>
</td></tr>
<tr><td><code id="save_PDF_+3A_show">show</code></td>
<td>
<p>a logical parameter; if TRUE the full file name will be displayed.</p>
</td></tr>
<tr><td><code id="save_PDF_+3A_width">width</code></td>
<td>
<p>figure width in inches (default = 6).</p>
</td></tr>
<tr><td><code id="save_PDF_+3A_height">height</code></td>
<td>
<p>figure height in inches (default = 4.5).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>save a plot as a PDF file.
</p>


<h3>Author(s)</h3>

<p>Paul Eilers
</p>


<h3>References</h3>

<p>Eilers, P.H.C. and Marx, B.D. (2021). <em>Practical Smoothing, The Joys of
P-splines.</em> Cambridge University Press.
</p>

<hr>
<h2 id='set_panels'>Prepare graphics layout for multiple panels</h2><span id='topic+set_panels'></span>

<h3>Description</h3>

<p>Adapt margins and axes layout for multiple panels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_panels(rows = 1, cols = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_panels_+3A_rows">rows</code></td>
<td>
<p>number of rows.</p>
</td></tr>
<tr><td><code id="set_panels_+3A_cols">cols</code></td>
<td>
<p>number of columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prepare graphics layout for multiple panels
</p>


<h3>Author(s)</h3>

<p>Paul Eilers
</p>


<h3>References</h3>

<p>Eilers, P.H.C. and Marx, B.D. (2021). <em>Practical Smoothing, The Joys of
P-splines.</em> Cambridge University Press.
</p>

<hr>
<h2 id='set_window'>Open a graphics window.</h2><span id='topic+set_window'></span>

<h3>Description</h3>

<p>Open a a window for graphics, with specified width and height.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_window(width = 6, height = 4.5, kill = TRUE, noRStudioGD = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_window_+3A_width">width</code></td>
<td>
<p>figure width in inches (default = 6).</p>
</td></tr>
<tr><td><code id="set_window_+3A_height">height</code></td>
<td>
<p>figure height in inches (default = 4.5).</p>
</td></tr>
<tr><td><code id="set_window_+3A_kill">kill</code></td>
<td>
<p>if TRUE (default) closes all graphics windows. Works only for Windows.</p>
</td></tr>
<tr><td><code id="set_window_+3A_norstudiogd">noRStudioGD</code></td>
<td>
<p>if TRUE: do not use the RStudio device (which does not accept width and height).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>open a graphics window.
</p>


<h3>Note</h3>

<p>Currently only works for Windows!
</p>


<h3>References</h3>

<p>Eilers, P.H.C. and Marx, B.D. (2021). <em>Practical Smoothing, The Joys of
P-splines.</em> Cambridge University Press.
</p>

<hr>
<h2 id='sim_psr'>Single-Index signal regression using P-splines</h2><span id='topic+sim_psr'></span>

<h3>Description</h3>

<p><code>sim_psr</code> is a single-index
signal regression model that estimates both the signal coefficients
vector and the unknown link function using P-splines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_psr(
  y,
  X,
  x_index = c(1:ncol(X)),
  nsegs = rep(10, 2),
  bdegs = rep(3, 3),
  lambdas = rep(1, 2),
  pords = rep(2, 2),
  max_iter = 100
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_psr_+3A_y">y</code></td>
<td>
<p>a response vector of length <code>m</code>, usually continuous.</p>
</td></tr>
<tr><td><code id="sim_psr_+3A_x">X</code></td>
<td>
<p>The signal regressors with dimension <code>m</code> by <code>p</code>.</p>
</td></tr>
<tr><td><code id="sim_psr_+3A_x_index">x_index</code></td>
<td>
<p>an index of length <code>p</code> for columns of signal matrix;
default is simple sequence, <code>c(1: ncol(X))</code>.</p>
</td></tr>
<tr><td><code id="sim_psr_+3A_nsegs">nsegs</code></td>
<td>
<p>a vector of length 2 containing
the number of evenly spaced segments between min and max, for each
the coefficient vector and the (unknown) link function,
resp. (default <code>c(10, 10)</code>).</p>
</td></tr>
<tr><td><code id="sim_psr_+3A_bdegs">bdegs</code></td>
<td>
<p>a vector of length 2 containing
the degree of B-splines, for the coefficient vector and
the (unknown) link function, resp. (default cubic or <code>c(3, 3)</code>).</p>
</td></tr>
<tr><td><code id="sim_psr_+3A_lambdas">lambdas</code></td>
<td>
<p>a vector of length 2 containing
the positive tuning parameters, for each
the coefficient vector and the (unknown) link function, resp. (default <code>c(1, 1)</code>).</p>
</td></tr>
<tr><td><code id="sim_psr_+3A_pords">pords</code></td>
<td>
<p>a vector of length 2 containing
the difference penalty order, for each
the coefficient vector and the (unknown) link function, resp. (default<code>c(2, 2)</code> ).</p>
</td></tr>
<tr><td><code id="sim_psr_+3A_max_iter">max_iter</code></td>
<td>
<p>a scalar for the maximum number of iterations (default 100).</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>y</code></td>
<td>
<p>the response vector of length <code>m</code>.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>the P-spline coefficient vector of length <code>(nsegs[1]+bdeg[1])</code>.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>the number of iterations used for the single-index fit.</p>
</td></tr>
<tr><td><code>yint</code></td>
<td>
<p>the estimated y-intercept for the single-index model.</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>the B-spline matrix built along the signal index, using <code>nsegs[1]</code>, used for the coefficient vector.</p>
</td></tr>
<tr><td><code>Q</code></td>
<td>
<p>the effective regressors from the <code>psVCSignal</code> portion of the single-index
fit with dimension <code>m</code> by <code>length(alpha)</code>.</p>
</td></tr>
<tr><td><code>nsegs</code></td>
<td>
<p>a vector of length 2 containing
the number of evenly spaced segments between min and max, for each
the coefficient vector and the link function, resp.</p>
</td></tr>
<tr><td><code>bdegs</code></td>
<td>
<p>a vector of length 2 containing
the degree of B-splines, for each
the coefficient vector and the link function, resp.</p>
</td></tr>
<tr><td><code>lambdas</code></td>
<td>
<p>a vector of length 2 containing
the positive tuning parameters, for each
the coefficient vector and the link function, resp.</p>
</td></tr>
<tr><td><code>pords</code></td>
<td>
<p>a vector of length 2 containing
the difference penalty order, for each
the coefficient vector and the link function, resp.</p>
</td></tr>
<tr><td><code>eta</code></td>
<td>
<p>the estimated linear predictor for the single-index fit.</p>
</td></tr>
<tr><td><code>cv</code></td>
<td>
<p>the leave-one-out cross-validation statistic or the standard error of prediction for the single-index fit.</p>
</td></tr>
<tr><td><code>delta_alpha</code></td>
<td>
<p>change measure in signal-coefficent parameters at
convervence.</p>
</td></tr>
<tr><td><code>x_index</code></td>
<td>
<p>the index of length <code>p</code> for columns of signal matrix.</p>
</td></tr>
<tr><td><code>f_fit</code></td>
<td>
<p>the <code>psNormal</code> object, fitting link function f(<code>eta</code>).</p>
</td></tr>
<tr><td><code>f_eta</code></td>
<td>
<p>the predicted values of the link function estimated with <code>f_fit</code> or estimated f(<code>eta</code>), at <code>x = eta</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paul Eilers, Brian Marx, and Bin Li
</p>


<h3>References</h3>

<p>Eilers, P.H.C., B. Li, B.D. Marx (2009).
Multivariate calibration with single-index signal regression,
<em>Chemometrics and Intellegent Laboratory Systems</em>, 96(2), 196-202.
</p>
<p>Eilers, P.H.C. and Marx, B.D. (2021). <em>Practical Smoothing, The Joys of
P-splines.</em> Cambridge University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(JOPS)
# Get the data
library(fds)
data(nirc)
iindex &lt;- nirc$x
X &lt;- nirc$y
sel &lt;- 50:650 # 1200 &lt;= x &amp; x&lt;= 2400
X &lt;- X[sel, ]
iindex &lt;- iindex[sel]
dX &lt;- diff(X)
diindex &lt;- iindex[-1]
y &lt;- as.vector(labc[1, 1:40])
oout &lt;- 23
dX &lt;- t(dX[, -oout])
y &lt;- y[-oout]

pords &lt;- c(2, 2)
nsegs &lt;- c(27, 7)
bdegs = c(3, 3)
lambdas &lt;- c(1e-6, .1)
max_iter &lt;- 100

# Single-index model
fit &lt;- sim_psr(y, dX, diindex, nsegs, bdegs, lambdas, pords,
             max_iter)

plot(fit, xlab = "Wavelength (nm)", ylab = " ")

</code></pre>

<hr>
<h2 id='sim_vcpsr'>Varying-coefficient single-index signal regression using tensor P-splines.</h2><span id='topic+sim_vcpsr'></span>

<h3>Description</h3>

<p><code>sim_vcpsr</code> is a varying-coefficient single-index
signal regression approach that allows both the signal coefficients
and the unknown link function to vary with
an indexing variable <code>t</code>, e.g. temperature. Two surfaces
are estimated (coefficent and link) that can be sliced at arbitary <code>t</code>.
Anisotripic penalization with P-splines is used on both.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_vcpsr(
  y,
  X,
  t_var,
  x_index = c(1:ncol(X)),
  nsegs = rep(10, 4),
  bdegs = rep(3, 4),
  lambdas = rep(1, 4),
  pords = rep(2, 4),
  max_iter = 100,
  mins = c(min(x_index), min(t_var)),
  maxs = c(max(x_index), max(t_var))
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_vcpsr_+3A_y">y</code></td>
<td>
<p>a response vector of length <code>m</code>, usually continuous.</p>
</td></tr>
<tr><td><code id="sim_vcpsr_+3A_x">X</code></td>
<td>
<p>the signal regressors with dimension <code>m</code> by <code>p1</code>.</p>
</td></tr>
<tr><td><code id="sim_vcpsr_+3A_t_var">t_var</code></td>
<td>
<p>the varying coeffient indexing variable of length <code>m</code>.</p>
</td></tr>
<tr><td><code id="sim_vcpsr_+3A_x_index">x_index</code></td>
<td>
<p>an index of length <code>p</code> for columns of signal matrix;
default is simple sequence.</p>
</td></tr>
<tr><td><code id="sim_vcpsr_+3A_nsegs">nsegs</code></td>
<td>
<p>a vector of length 4 containing
the number of evenly spaced segments between min and max, for each
the coefficient surface (row and col) and
link surface (row and col), resp. (default <code>rep(10, 4)</code>.</p>
</td></tr>
<tr><td><code id="sim_vcpsr_+3A_bdegs">bdegs</code></td>
<td>
<p>a vector of length 4 containing
the degree of B-splines, for each
the coefficient surface (row and col) and link surface (row and col), resp.
(default cubic <code>rep(3, 4)</code>).</p>
</td></tr>
<tr><td><code id="sim_vcpsr_+3A_lambdas">lambdas</code></td>
<td>
<p>a vector of length 4 containing
the positive tuning parameters, for each
the coefficient surface (row and col) and link surface (row and col), resp.
(default <code>rep(1, 4)</code>).</p>
</td></tr>
<tr><td><code id="sim_vcpsr_+3A_pords">pords</code></td>
<td>
<p>a vector of length 4 containing
the difference penalty order, for each
the coefficient surface (row and col) and link surface (row and col), resp.
(default <code>rep(2, 4)</code>).</p>
</td></tr>
<tr><td><code id="sim_vcpsr_+3A_max_iter">max_iter</code></td>
<td>
<p>a scalar for the maximum number of iterations (default 100)</p>
</td></tr>
<tr><td><code id="sim_vcpsr_+3A_mins">mins</code></td>
<td>
<p>A vector length 2, containing min for signal index and <code>t_var</code>, default
associated with <code>x_index</code> and <code>t_var</code> minimums; default is respective minimums.</p>
</td></tr>
<tr><td><code id="sim_vcpsr_+3A_maxs">maxs</code></td>
<td>
<p>A vector length 2, containing max for signal index and <code>t_var</code>, default
associated with <code>x_index</code> and <code>t_var</code> maximums; default is respective maximums.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>y</code></td>
<td>
<p>the response vector of length <code>m</code>.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>the P-spline coefficient vector (unfolded) of length <code>(nsegs[1]+bdeg[1])*(negs[2]+bdeg[2])</code>.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>the number of iterations used for the single-index fit.</p>
</td></tr>
<tr><td><code>yint</code></td>
<td>
<p>the estimated y-intercept for the single-index model.</p>
</td></tr>
<tr><td><code>Bx</code></td>
<td>
<p>the B-spline matrix built along the signal index, using <code>nsegs[1]</code>, used for the coefficient surface.</p>
</td></tr>
<tr><td><code>By</code></td>
<td>
<p>the B-spline matrix built along the <code>t_var</code> index,
using <code>nsegs[2]</code>, used for the coefficient surface.</p>
</td></tr>
<tr><td><code>Q</code></td>
<td>
<p>the effective regressors from the <code>psVCSignal</code> portion of the single-index
fit with dimension <code>m</code> by <code>length(alpha)</code>.</p>
</td></tr>
<tr><td><code>t_var</code></td>
<td>
<p>the VC indexing variable of length <code>m</code>.</p>
</td></tr>
<tr><td><code>nsegs</code></td>
<td>
<p>a vector of length 4 containing
the number of evenly spaced segments between min and max, for each
the coefficient surface (row and col) and
link surface (row and col).</p>
</td></tr>
<tr><td><code>bdegs</code></td>
<td>
<p>a vector of length 4 containing
the degree of B-splines, for each
the coefficient surface (row and col) and link surface (row and col).</p>
</td></tr>
<tr><td><code>lambdas</code></td>
<td>
<p>a vector of length 4 containing
the positive tuning parameters, for each
the coefficient surface (row and col) and link surface (row and col).</p>
</td></tr>
<tr><td><code>pords</code></td>
<td>
<p>a vector of length 4 containing
the difference penalty order, for each
the coefficient surface (row and col) and link surface (row and col).</p>
</td></tr>
<tr><td><code>mins</code></td>
<td>
<p>a vector length 2, containing min for signal index and <code>t_var</code>.</p>
</td></tr>
<tr><td><code>maxs</code></td>
<td>
<p>a vector length 2, containing max for signal index and <code>t_var</code>.</p>
</td></tr>
<tr><td><code>eta</code></td>
<td>
<p>the estimated linear predictor for the single-index fit.</p>
</td></tr>
<tr><td><code>Pars</code></td>
<td>
<p>a matrix of 2 rows associated with the signal coefficient surface
design parameters, each row: <code>c(min, max, nseg, bdeg, lambda, pord)</code> for
linear predictor <code>x_index</code> and <code>t_var</code>, resp.</p>
</td></tr>
<tr><td><code>pPars</code></td>
<td>
<p>a matrix of 2 rows associated with the link function
design parameters, each row: <code>c(min, max, nseg, bdeg, lambda, pord)</code> for linear
predictor <code>eta</code> and <code>t_var</code>, resp.</p>
</td></tr>
<tr><td><code>cv</code></td>
<td>
<p>the leave-one-out cross-validation statistic
or the standard error of prediction for the single-index fit.</p>
</td></tr>
<tr><td><code>delta_alpha</code></td>
<td>
<p>change measure in signal-coefficent parameters at
convergence.</p>
</td></tr>
<tr><td><code>fit2D</code></td>
<td>
<p><code>ps2DNormal</code> object, fitting f(<code>eta</code>, <code>t_var</code>).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paul Eilers and Brian Marx
</p>


<h3>References</h3>

<p>Marx, B. D. (2015). Varying-coefficient single-index signal
regression. <em>Chemometrics and Intelligent Laboratory Systems</em>, 143, 111–121.
</p>
<p>Eilers, P.H.C. and Marx, B.D. (2021). <em>Practical Smoothing, The Joys of
P-splines.</em> Cambridge University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load libraries
library(fields) # Needed for plotting

# Get the data
Dat &lt;- Mixture

# Dimensions: observations, temperature index, signal
m &lt;- 34
p1 &lt;- 401
p2 &lt;- 12

# Stacking mixture data, each mixture has 12 signals stacked
# The first differenced spectra are also computed.
mixture_data &lt;- matrix(0, nrow = p2 * m, ncol = p1)
for (ii in 1:m)
{
  mixture_data[((ii - 1) * p2 + 1):(ii * p2), 1:p1] &lt;-
    t(as.matrix(Dat$xspectra[ii, , ]))
  d_mixture_data &lt;- t(diff(t(mixture_data)))
}

# Response (typo fixed) and index for signal
y_mixture &lt;- Dat$fractions
y_mixture[17, 3] &lt;- 0.1501
index_mixture &lt;- Dat$wl

# Select response and replicated for the 12 temps
# Column 1: water; 2: ethanediol; 3: amino-1-propanol
y &lt;- as.vector(y_mixture[, 2])
y &lt;- rep(y, each = p2)

bdegs = c(3, 3, 3, 3)
pords &lt;- c(2, 2, 2, 2)
nsegs &lt;- c(12, 5, 5, 5) # Set to c(27, 7, 7 ,7) for given lambdas
mins &lt;- c(700, 30)
maxs &lt;- c(1100, 70)
lambdas &lt;- c(1e-11, 100, 0.5, 1) # based on svcm search
x_index &lt;- seq(from = 701, to = 1100, by = 1) # for dX
t_var_sub &lt;- c(30, 35, 37.5, 40, 45, 47.5, 50, 55, 60, 62.5, 65, 70)
t_var &lt;- rep(t_var_sub, m)
max_iter &lt;- 2 # Set higher in practice, e.g. 100
int &lt;- TRUE

# Defining x as first differenced spectra, number of channels.
x &lt;- d_mixture_data


# Single-index VC model using optimal tuning
fit &lt;- sim_vcpsr(y, x, t_var, x_index, nsegs, bdegs, lambdas, pords,
             max_iter = max_iter, mins = mins, maxs = maxs)

plot(fit, xlab = "Wavelength (nm)", ylab = "Temp C")
</code></pre>

<hr>
<h2 id='SpATS.nogeno'>Two-dimensional P-spline smoothing</h2><span id='topic+SpATS.nogeno'></span>

<h3>Description</h3>

<p>Two-dimensional smoothing of scattered data points with tensor product P-splines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SpATS.nogeno(
  response,
  spatial,
  fixed = NULL,
  random = NULL,
  data,
  family = gaussian(),
  offset = 0,
  weights = NULL,
  control = list(maxit = 100)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SpATS.nogeno_+3A_response">response</code></td>
<td>
<p>a character string with the name of the variable that contains the response variable of interest.</p>
</td></tr>
<tr><td><code id="SpATS.nogeno_+3A_spatial">spatial</code></td>
<td>
<p>a right hand <code><a href="stats.html#topic+formula">formula</a></code> object specifying the spatial P-Spline model. See <code>SAP</code> and <code>PSANOVA</code> for more details about how to specify the spatial trend.</p>
</td></tr>
<tr><td><code id="SpATS.nogeno_+3A_fixed">fixed</code></td>
<td>
<p>an optional right hand <code><a href="stats.html#topic+formula">formula</a></code> object specifying the fixed effects.</p>
</td></tr>
<tr><td><code id="SpATS.nogeno_+3A_random">random</code></td>
<td>
<p>an optional right hand <code><a href="stats.html#topic+formula">formula</a></code> object specifying the random effects. Currently, only sets of independent and identically distributed random effects can be incorporated.</p>
</td></tr>
<tr><td><code id="SpATS.nogeno_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables.</p>
</td></tr>
<tr><td><code id="SpATS.nogeno_+3A_family">family</code></td>
<td>
<p>object of class <code><a href="stats.html#topic+family">family</a></code> specifying the distribution and link function.</p>
</td></tr>
<tr><td><code id="SpATS.nogeno_+3A_offset">offset</code></td>
<td>
<p>an optional numerical vector containing an a priori known component to be included in the linear predictor during fitting.</p>
</td></tr>
<tr><td><code id="SpATS.nogeno_+3A_weights">weights</code></td>
<td>
<p>an optional numerical vector of weights to be used in the fitting process. By default, the weights are considered to be one.</p>
</td></tr>
<tr><td><code id="SpATS.nogeno_+3A_control">control</code></td>
<td>
<p>a list of control values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a modified version of the function  <code>SpATS</code> in the package <code>SpATS</code>. The difference is that genotypes have been removed.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>the original supplied data argument with a new column with the weights used during the fitting process.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>a list with the model components: response, spatial, fixed and/or random.</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>a numeric vector with the fitted values.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>a numeric vector with deviance residuals.</p>
</td></tr>
<tr><td><code>psi</code></td>
<td>
<p>a two-length vector with the values of the dispersion parameters at convergence. For Gaussian responses both elements coincide, being the (REML) estimate of dispersion parameter. For non-Gaussian responses, the result depends on the argument <code>update.psi</code> of the <code>controlSpATS</code> function. If this argument was specified to <code>FALSE</code> (the default), the first component of the vector corresponds to the default value used for the dispersion parameter (usually 1). The second element, correspond to the (REML) estimate of the dispersion parameter at convergence. If the argument <code>update.psi</code> was specified to <code>TRUE</code>, both components coincide (as in the Gaussian case).</p>
</td></tr>
<tr><td><code>var.comp</code></td>
<td>
<p>a numeric vector with the (REML) variance component estimates. This vector contains the variance components associated with the spatial trend, as well as those related with the random model terms.</p>
</td></tr>
<tr><td><code>eff.dim</code></td>
<td>
<p>a numeric vector with the estimated effective dimension (or effective degrees of freedom) for each model component (spatial, fixed and/or random).</p>
</td></tr>
<tr><td><code>dim</code></td>
<td>
<p>a numeric vector with the (model) dimension of each model component (spatial, fixed and/or random). This value corresponds to the number of parameters to be estimated.</p>
</td></tr>
<tr><td><code>dim.nom</code></td>
<td>
<p>a numeric vector with the (nominal) dimension of each component (spatial, fixed and/or random). For the random terms of the model, this value corresponds to upper bound for the effective dimension (i.e., the maximum effective dimension a random term can achive). This nominal dimension is <code class="reqn">rank[X, Z_k] - rank[X]</code>, where <code class="reqn">Z_k</code> is the design matrix of the <code class="reqn">k</code>th random factor and <code class="reqn">X</code> is the design matrix of the fixed part of the model. In most cases (but not always), the nominal dimension corresponds to the model dimension minus one, &ldquo;lost&rdquo; due to the implicit constraint that ensures the mean of the random effects to be zero.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>number of observations used to fit the model.</p>
</td></tr>
<tr><td><code>niterations</code></td>
<td>
<p>number of iterations EM-algorithm.</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>the (REML) deviance at convergence (i.e., <code class="reqn">-2</code> times the restricted log-likelihood).</p>
</td></tr>
<tr><td><code>coeff</code></td>
<td>
<p>a numeric vector with the estimated fixed and random effect coefficients.</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>a list with the model terms: response, spatial, fixed and/or random. The information provided here is useful for printing and prediction purposes.</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p>inverse of the coefficient matrix of the mixed models equations. The inverse is needed for the computation of standard errors. For computational issues, the inverse is returned as a list: C22_inv corresponds to the coefficient matrix associated with the spatial, the fixed and the random components.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maria-Xose Rodriguez-Alvarez and Paul Eilers
</p>


<h3>References</h3>

<p>Rodriguez-Alvarez, M.X, Boer, M.P., van Eeuwijk, F.A., and Eilers, P.H.C. (2018). Correcting for spatial heterogeneity in plant breeding experiments with P-splines. Spatial Statistics, 23, 52 - 71. https://doi.org/10.1016/j.spasta.2017.10.003.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get the data
library(SemiPar)
data(ethanol)

# Fit the PS-ANOVA model
ps2d &lt;- SpATS.nogeno(response = "NOx",
                     spatial = ~PSANOVA(E, C,  nseg = c(20, 20), nest.div = c(2, 2)),
                     data = ethanol,
                     control = list(maxit = 100, tolerance = 1e-05,
                                    monitoring = 0, update.psi = FALSE))

# Report effective dimensions, if desired
# print(summary(ps2d))

# Compute component surface and their sum on a fine grid
Tr = obtain.spatialtrend(ps2d, grid = c(100, 100))

# Plot surface and contours
image(Tr$row.p, Tr$col.p, Tr$fit, col = terrain.colors(100), xlab = 'C', ylab = 'E')
contour(Tr$row.p, Tr$col.p, Tr$fit, add = TRUE, col = 'blue')
points(ethanol$C, ethanol$E, pch = '+')
</code></pre>

<hr>
<h2 id='spbase'>Compute a sparse B-spline basis on evenly spaced knots</h2><span id='topic+spbase'></span>

<h3>Description</h3>

<p>Constructs a sparse B-spline basis on evenly spaced knots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spbase(x, xl = min(x), xr = max(x), nseg = 10, bdeg = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spbase_+3A_x">x</code></td>
<td>
<p>a vector of argument values, at which the B-spline basis functions
are to be evaluated.</p>
</td></tr>
<tr><td><code id="spbase_+3A_xl">xl</code></td>
<td>
<p>the lower limit of the domain of <code>x</code> (default <code>min(x)</code>).</p>
</td></tr>
<tr><td><code id="spbase_+3A_xr">xr</code></td>
<td>
<p>the upper limit of the domain of <code>x</code> (default <code>max(x)</code>) .</p>
</td></tr>
<tr><td><code id="spbase_+3A_nseg">nseg</code></td>
<td>
<p>the number of evenly spaced segments between <code>xl</code> and <code>xr</code> (default 10).</p>
</td></tr>
<tr><td><code id="spbase_+3A_bdeg">bdeg</code></td>
<td>
<p>the degree of the basis, usually 1, 2, or 3 (default).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sparse matrix (in <code>spam</code> format) with <code>length(x)</code>  of rows= and <code>nseg + bdeg</code> columns.
</p>


<h3>Author(s)</h3>

<p>Paul Eilers
</p>


<h3>References</h3>

<p>Eilers, P.H.C. and Marx, B.D. (1996). Flexible smoothing with
B-splines and penalties (with comments and rejoinder), <em>Statistical Science</em>, 11: 89-121.
</p>
<p>Eilers, P.H.C. and Marx, B.D. (2021). <em>Practical Smoothing, The Joys of
P-splines.</em> Cambridge University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(JOPS)
# Basis  on grid
x = seq(0, 4, length = 1000)
B = spbase(x, 0, 4, nseg = 50, bdeg = 3)
nb1 = ncol(B)
matplot(x, B, type = 'l', lty = 1, lwd = 1, xlab = 'x', ylab = '')
cat('Dimensions of B:', nrow(B), 'by', ncol(B), 'with', length(B@entries), 'non-zero elements' )

</code></pre>

<hr>
<h2 id='Sugar'>Sugar Processing Data</h2><span id='topic+Sugar'></span>

<h3>Description</h3>

<p>Sugar was sampled continuously during eight hours to make
a mean sample representative for one &quot;shift&quot;
(eight hour period). Samples were taken during the
three months of operation (the so-called campaign) in
late autumn from a sugar plant in Scandinavia giving a
total of 268 samples. The sugar was sampled directly
from the final unit operation (centrifuge) of the process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Sugar)
</code></pre>


<h3>Format</h3>

<p>A list consisting of the following:
</p>

<dl>
<dt><code>y</code></dt><dd><p>a 268 x 3 matrix of quality parameters: <code>date</code>, <code>color</code>, <code>ash</code>*1000</p>
</dd>
<dt><code>X</code></dt><dd><p>fluoresence array, 268 (observations) x [571 (emission channels) x 7 (excitation channels)]</p>
</dd>
<dt><code>Lab</code></dt><dd><p>Lab information</p>
</dd>
<dt><code>DimX</code></dt><dd><p>array dimension for <code>X</code></p>
</dd>
<dt><code>Yidx</code></dt><dd><p>names (id) for <code>y</code></p>
</dd>
<dt><code>EmAx</code></dt><dd><p>Emmission levels for axis (nm)</p>
</dd>
<dt><code>ExAx</code></dt><dd><p>Excitation levels for axis (nm)</p>
</dd>
<dt><code>time</code></dt><dd> </dd>
<dt><code>readmetime</code></dt><dd> </dd>
<dt><code>Lname</code></dt><dd> </dd>
<dt><code>LabNumber</code></dt><dd> </dd>
<dt><code>ProcNumber</code></dt><dd> </dd>
<dt><code>Proc</code></dt><dd> </dd>
<dt><code>DimLab</code></dt><dd> </dd>
<dt><code>DimProc</code></dt><dd> </dd></dl>



<h3>Source</h3>

<p><a href="https://ucphchemometrics.com/sugar-process-data/">https://ucphchemometrics.com/sugar-process-data/</a>
</p>


<h3>References</h3>

<p>R. Bro, Exploratory study of sugar production using fluorescence spectroscopy and multi-way analysis,
<em>Chemom. Intell. Lab. Syst.</em>, 1999, (46), 133-147.
</p>

<hr>
<h2 id='Suicide'>Suicide Data Set</h2><span id='topic+Suicide'></span>

<h3>Description</h3>

<p>The dataset comprises lengths (in days) of psychiatric treatment spells for patients used as controls
in a study of suicide risks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Suicide)
</code></pre>


<h3>Format</h3>

<p>A dataframe with one column: <code>y</code>.
</p>


<h3>Source</h3>

<p>Silverman, B. (1986).
Density Estimation for Statistics and Data Analysis. Chapman &amp; Hall.
</p>


<h3>References</h3>

<p>Silverman, B. (1986).
Density Estimation for Statistics and Data Analysis. Chapman &amp; Hall.
</p>

<hr>
<h2 id='tpower'>Compute a truncated power function.</h2><span id='topic+tpower'></span>

<h3>Description</h3>

<p>Compute a truncated power function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tpower(x, knot, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tpower_+3A_x">x</code></td>
<td>
<p>a vector on which the basis is calculated.</p>
</td></tr>
<tr><td><code id="tpower_+3A_knot">knot</code></td>
<td>
<p>a scalar giving the truncation point.</p>
</td></tr>
<tr><td><code id="tpower_+3A_p">p</code></td>
<td>
<p>a scalar power for the basis, e.g. <code>p = 3</code> for cubic TPF.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector with the truncated power function.
</p>


<h3>Author(s)</h3>

<p>Paul Eilers
</p>


<h3>References</h3>

<p>Eilers, P.H.C. and Marx, B.D. (2021). <em>Practical Smoothing, The Joys of
P-splines.</em> Cambridge University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(JOPS)
# Basis  on grid
x = seq(0, 4, length = 500)
knots = 0:3
Y = outer(x, knots, tpower, 1)
matplot(x, Y, type ='l', lwd = 2, xlab = 'x', ylab = '',
main ='Linear TPF basis')

</code></pre>

<hr>
<h2 id='Varstar'>Brightness of a variable star.</h2><span id='topic+Varstar'></span>

<h3>Description</h3>

<p>Brightness of a variable star.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Varstar)
</code></pre>


<h3>Format</h3>

<p>A dataframe with eleven columns (<code>V1-V11</code>):
</p>

<dl>
<dt><code>V1</code></dt><dd><p>day index</p>
</dd>
<dt><code>V2</code></dt><dd><p>brightness</p>
</dd>
<dt><code>V3-V11</code></dt><dd><p>Paul Eilers, personal communication.</p>
</dd>
</dl>



<h3>References</h3>

<p>Paul Eilers (personal communication).
</p>

<hr>
<h2 id='Woodsurf'>Profile of a sanded piece of wood.</h2><span id='topic+Woodsurf'></span>

<h3>Description</h3>

<p>Profile of a sanded piece of wood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Woodsurf)
</code></pre>


<h3>Format</h3>

<p>A data frame with one column: <code>y</code>.
</p>


<h3>Source</h3>

<p>Pandit, S.M. and Wu, S.M. (1993).
<em>Time Series and System Analysis with Applications</em>.
Krieger Publishing Company.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
