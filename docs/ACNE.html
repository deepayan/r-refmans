<!DOCTYPE html><html><head><title>Help for package ACNE</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ACNE}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ACNE-package'><p>Package ACNE</p></a></li>
<li><a href='#doACNE'><p>(ACNE)</p></a></li>
<li><a href='#fitSnpNmf'><p>Non-negative matrix factorization (NMF) of a matrix containing SNP probe signals</p></a></li>
<li><a href='#fitSnpNmfArray'><p>Allele-specific copy number estimation using non-negative matrix factorization (NMF)</p></a></li>
<li><a href='#NmfPlm'><p>The NmfPlm class</p></a></li>
<li><a href='#NmfSnpPlm'><p>The NmfSnpPlm class</p></a></li>
<li><a href='#Non-documented objects'><p>Non-documented objects</p></a></li>
<li><a href='#plot.SnpNmfFit'><p>Generates a multi-panel plot summarizing the NMF SNP fit</p></a></li>
<li><a href='#pseudoinverse'><p>Calculates the pseudo inverse of a matrix</p></a></li>
<li><a href='#removeOutliers'><p>Removes outliers in matrix containing SNP signals</p></a></li>
<li><a href='#robustHInit'><p>Robust initialization of the H (copy number) matrix</p></a></li>
<li><a href='#robustWInit'><p>Robust initialization of the W (affinity) matrix</p></a></li>
<li><a href='#snpArrayToMatrix'><p>Reshapes SNP data in matrix form to array form and vice versa</p></a></li>
<li><a href='#WHInit'><p>Initialization of the W and H matrices</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.9.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), aroma.affymetrix (&ge; 2.14.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, R.methodsS3 (&ge; 1.7.0), R.oo (&ge; 1.23.0), R.utils (&ge;
2.1.0), matrixStats (&ge; 0.50.0), R.filesets (&ge; 2.9.0),
aroma.core (&ge; 2.14.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>DNAcopy</td>
</tr>
<tr>
<td>Title:</td>
<td>Affymetrix SNP Probe-Summarization using Non-Negative Matrix
Factorization</td>
</tr>
<tr>
<td>Description:</td>
<td>A summarization method to estimate allele-specific copy number signals for Affymetrix SNP microarrays using non-negative matrix factorization (NMF).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-2.1">LGPL-2.1</a> | <a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a> [expanded from: LGPL (&ge; 2.1)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/HenrikBengtsson/ACNE">https://github.com/HenrikBengtsson/ACNE</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/HenrikBengtsson/ACNE/issues">https://github.com/HenrikBengtsson/ACNE/issues</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>TRUE</td>
</tr>
<tr>
<td>biocViews:</td>
<td>aCGH, CopyNumberVariants, SNP, Microarray, OneChannel,
TwoChannel, Genetics</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-17 20:36:57 UTC; henrik</td>
</tr>
<tr>
<td>Author:</td>
<td>Maria Ortiz [aut],
  Henrik Bengtsson [aut, cre, cph],
  Angel Rubio [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Henrik Bengtsson &lt;henrikb@braju.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-17 21:10:22 UTC</td>
</tr>
</table>
<hr>
<h2 id='ACNE-package'>Package ACNE</h2><span id='topic+ACNE-package'></span><span id='topic+ACNE'></span>

<h3>Description</h3>

<p>A summarization method to estimate allele-specific copy number signals for Affymetrix SNP microarrays using non-negative matrix factorization (NMF).
</p>


<h3>Installation and updates</h3>

<p>This package requires the <span class="pkg">aroma.affymetrix</span> package.
To install this package, do:
<code>install.packages("ACNE")</code>
</p>


<h3>To get started</h3>


<ol>
<li><p> For a one-command pipeline, see the <code><a href="#topic+doACNE">doACNE</a></code>() method.
</p>
</li>
<li><p> For other usages, see the <code><a href="#topic+NmfPlm">NmfPlm</a></code> class.
</p>
</li></ol>



<h3>License</h3>

<p>LGPL (&gt;= 2.1)
</p>


<h3>Author(s)</h3>

<p>Maria Ortiz, Henrik Bengtsson, Angel Rubio</p>


<h3>References</h3>

<p>[1] M. Ortiz-Estevez, H. Bengtsson, A. Rubio, <em>ACNE: a summarization method to estimate allele-specific copy numbers for Affymetrix SNP arrays</em>, Bioinformatics, 2010 [PMC2913655].
<br />
</p>

<hr>
<h2 id='doACNE'>(ACNE)</h2><span id='topic+doACNE.default'></span><span id='topic+doACNE'></span><span id='topic+doACNE.AffymetrixCelSet'></span>

<h3>Description</h3>

<p>(ACNE) based on [1].
The algorithm is processed in bounded memory, meaning virtually
any number of arrays can be analyzed on also very limited computer
systems.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'AffymetrixCelSet'
doACNE(csR, fln=FALSE, drop=TRUE, verbose=FALSE, ...)
  ## Default S3 method:
doACNE(dataSet, ..., verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="doACNE_+3A_csr">csR</code>, <code id="doACNE_+3A_dataset">dataSet</code></td>
<td>
<p>An <code>AffymetrixCelSet</code> (or the name of an
<code>AffymetrixCelSet</code>).</p>
</td></tr>
<tr><td><code id="doACNE_+3A_fln">fln</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, CRMAv2-style PCR fragment-length normalization
is performed, otherwise not.</p>
</td></tr>
<tr><td><code id="doACNE_+3A_drop">drop</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, the RMA summaries are returned, otherwise
a named <code><a href="base.html#topic+list">list</a></code> of all intermediate and final results.</p>
</td></tr>
<tr><td><code id="doACNE_+3A_verbose">verbose</code></td>
<td>
<p>See <code>Verbose</code>.</p>
</td></tr>
<tr><td><code id="doACNE_+3A_...">...</code></td>
<td>
<p>Additional arguments used to set up <code>AffymetrixCelSet</code>
(when argument <code>dataSet</code> is specified).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a named <code><a href="base.html#topic+list">list</a></code>, iff <code>drop == FALSE</code>, otherwise
a named <code><a href="base.html#topic+list">list</a></code> of <code><a href="aroma.core.html#topic+AromaUnitTotalCnBinarySet">AromaUnitTotalCnBinarySet</a></code>
and <code><a href="aroma.core.html#topic+AromaUnitFracBCnBinarySet">AromaUnitFracBCnBinarySet</a></code>.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>References</h3>

<p>[1] M. Ortiz-Estevez, H. Bengtsson, A. Rubio, <em>ACNE: a summarization method to estimate allele-specific copy numbers for Affymetrix SNP arrays</em>, Bioinformatics, 2010 [PMC2913655].
<br />
</p>

<hr>
<h2 id='fitSnpNmf'>Non-negative matrix factorization (NMF) of a matrix containing SNP probe signals</h2><span id='topic+fitSnpNmf'></span>

<h3>Description</h3>

<p>Non-negative matrix factorization (NMF) of a matrix containing SNP probe signals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitSnpNmf(V, acc=0.02, maxIter=10, maxIterRlm=20, refs=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitSnpNmf_+3A_v">V</code></td>
<td>
<p>An KxI <code><a href="base.html#topic+matrix">matrix</a></code> where I is the number of arrays and K is the
number of probe where K should be even (K=2L).</p>
</td></tr>
<tr><td><code id="fitSnpNmf_+3A_acc">acc</code></td>
<td>
<p>A positive <code><a href="base.html#topic+double">double</a></code> specifying the converence threshold. For
more details on convergence, see below.</p>
</td></tr>
<tr><td><code id="fitSnpNmf_+3A_maxiter">maxIter</code></td>
<td>
<p>A positive <code><a href="base.html#topic+integer">integer</a></code> specifying the maximum number of
iterations used to calculate the decomposition.</p>
</td></tr>
<tr><td><code id="fitSnpNmf_+3A_maxiterrlm">maxIterRlm</code></td>
<td>
<p>A positive <code><a href="base.html#topic+integer">integer</a></code> specifying the maximum number of
iterations used in rlm.</p>
</td></tr>
<tr><td><code id="fitSnpNmf_+3A_refs">refs</code></td>
<td>
<p>An index <code><a href="base.html#topic+vector">vector</a></code> (<code><a href="base.html#topic+integer">integer</a></code> or <code><a href="base.html#topic+logical">logical</a></code>) specifying the
reference samples.  If <code><a href="base.html#topic+NULL">NULL</a></code>, all samples are used as a reference.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm is considered to have converged when the maximum update
of any allele-specific copy number of any array (<code>H</code>) is greater
than <code>acc</code>.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+list">list</a></code>:
</p>
<table>
<tr><td><code>W</code></td>
<td>
<p>The Kx2 <code><a href="base.html#topic+matrix">matrix</a></code> containing allele-specific affinity estimates.</p>
</td></tr>
<tr><td><code>H</code></td>
<td>
<p>A 2xI <code><a href="base.html#topic+matrix">matrix</a></code> containing allele-specific copy number estimates.</p>
</td></tr>
<tr><td><code>hasConverged</code></td>
<td>
<p><code><a href="base.html#topic+logical">TRUE</a></code> if the algorithm converged, otherwise <code><a href="base.html#topic+logical">FALSE</a></code>.
If not applicable, it is <code><a href="base.html#topic+NA">NA</a></code>.</p>
</td></tr>
<tr><td><code>nbrOfIterations</code></td>
<td>
<p>The number of iteration ran before stopping.
If not applicable, it is <code><a href="base.html#topic+NA">NA</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+WHInit">WHInit</a></code>(), <code><a href="#topic+robustWInit">robustWInit</a></code>(), <code><a href="#topic+robustHInit">robustHInit</a></code>(), and
<code><a href="#topic+removeOutliers">removeOutliers</a></code>().
</p>

<hr>
<h2 id='fitSnpNmfArray'>Allele-specific copy number estimation using non-negative matrix factorization (NMF)</h2><span id='topic+fitSnpNmfArray'></span>

<h3>Description</h3>

<p>Allele-specific copy number estimation using non-negative matrix factorization (NMF).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitSnpNmfArray(Y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitSnpNmfArray_+3A_y">Y</code></td>
<td>
<p>An Lx2xI <code><a href="base.html#topic+array">array</a></code> where L is number of probe pairs,
2 is the number of alleles (A and B),
and I is the number of arrays.</p>
</td></tr>
<tr><td><code id="fitSnpNmfArray_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+fitSnpNmf">fitSnpNmf</a></code>().</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm is considered to have converged when the maximum update
of any allele-specific copy number of any array (<code>H</code>) is greater
than <code>acc</code>.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+list">list</a></code> of class <code>SnpNmfFit</code>:
</p>
<table>
<tr><td><code>Y</code></td>
<td>
<p>The Lx2xI <code><a href="base.html#topic+array">array</a></code> <code>Y</code>.</p>
</td></tr>
<tr><td><code>W</code></td>
<td>
<p>The Kx2 <code><a href="base.html#topic+matrix">matrix</a></code> containing allele-specific affinity estimates
where K=2L.</p>
</td></tr>
<tr><td><code>H</code></td>
<td>
<p>A 2xI <code><a href="base.html#topic+matrix">matrix</a></code> containing allele-specific copy number estimates.</p>
</td></tr>
<tr><td><code>hasConverged</code></td>
<td>
<p><code><a href="base.html#topic+logical">TRUE</a></code> if the algorithm converged, otherwise <code><a href="base.html#topic+logical">FALSE</a></code>.
If not applicable, it is <code><a href="base.html#topic+NA">NA</a></code>.</p>
</td></tr>
<tr><td><code>nbrOfIterations</code></td>
<td>
<p>The number of iteration ran before stopping.
If not applicable, it is <code><a href="base.html#topic+NA">NA</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Internally, the array is stacked into a 2LxI matrix and decomposed
using <code><a href="#topic+fitSnpNmf">fitSnpNmf</a></code>().
See <code><a href="#topic+plot.SnpNmfFit">plot.SnpNmfFit</a></code>().
</p>


<h3>Examples</h3>

<pre><code class='language-R'># - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# DATA: Lx2xI allele-specific signals for six different SNPs
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
filenames &lt;- sprintf("V%d.Rbin", 1:6)
pathnames &lt;- system.file("extData", filenames, package="ACNE")
Ys &lt;- lapply(pathnames, FUN=function(p) snpMatrixToArray(loadToEnv(p)$V))
names(Ys) &lt;- sprintf("SNP #%d", seq_along(Ys))


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# ACNE fitting of NMF to the six SNPs
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
for (name in names(Ys)) {
  Y &lt;- Ys[[name]]
  fit &lt;- fitSnpNmfArray(Y)
  str(fit)
  plot(fit, lim=c(0,2^14), main=name)
}
</code></pre>

<hr>
<h2 id='NmfPlm'>The NmfPlm class</h2><span id='topic+NmfPlm'></span>

<h3>Description</h3>

<p>Package:  ACNE <br />
<b>Class NmfPlm</b><br />
</p>
<p><code><a href="R.oo.html#topic+Object">Object</a></code><br />
<code>~~|</code><br />
<code>~~+--</code><code><a href="aroma.core.html#topic+ParametersInterface">ParametersInterface</a></code><br />
<code>~~~~~~~|</code><br />
<code>~~~~~~~+--</code><code><a href="aroma.affymetrix.html#topic+Model">Model</a></code><br />
<code>~~~~~~~~~~~~|</code><br />
<code>~~~~~~~~~~~~+--</code><code><a href="aroma.affymetrix.html#topic+UnitModel">UnitModel</a></code><br />
<code>~~~~~~~~~~~~~~~~~|</code><br />
<code>~~~~~~~~~~~~~~~~~+--</code><code><a href="aroma.affymetrix.html#topic+MultiArrayUnitModel">MultiArrayUnitModel</a></code><br />
<code>~~~~~~~~~~~~~~~~~~~~~~|</code><br />
<code>~~~~~~~~~~~~~~~~~~~~~~+--</code><code><a href="aroma.affymetrix.html#topic+ProbeLevelModel">ProbeLevelModel</a></code><br />
<code>~~~~~~~~~~~~~~~~~~~~~~~~~~~|</code><br />
<code>~~~~~~~~~~~~~~~~~~~~~~~~~~~+--</code><em><code>NmfPlm</code></em><br />
</p>
<p><b>Directly known subclasses:</b><br />
<em><a href="#topic+NmfSnpPlm">NmfSnpPlm</a></em><br />
</p>
<p>public abstract static class <b>NmfPlm</b><br />
extends <em><a href="aroma.affymetrix.html#topic+ProbeLevelModel">ProbeLevelModel</a></em><br />
</p>
<p>This class represents the NMF model of [REF].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NmfPlm(..., maxIter=10L, maxIterRlm=20L, refs=NULL, flavor=c("v4", "v3", "v2", "v1"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NmfPlm_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="aroma.affymetrix.html#topic+ProbeLevelModel">ProbeLevelModel</a></code>.</p>
</td></tr>
<tr><td><code id="NmfPlm_+3A_maxiter">maxIter</code></td>
<td>
<p>The maximum number of iteration in the NMF step.</p>
</td></tr>
<tr><td><code id="NmfPlm_+3A_maxiterrlm">maxIterRlm</code></td>
<td>
<p>A positive <code><a href="base.html#topic+integer">integer</a></code> specifying the maximum number of
iterations used in rlm.</p>
</td></tr>
<tr><td><code id="NmfPlm_+3A_refs">refs</code></td>
<td>
<p>An index <code><a href="base.html#topic+vector">vector</a></code> (<code><a href="base.html#topic+integer">integer</a></code> or <code><a href="base.html#topic+logical">logical</a></code>) specifying the
reference samples.  If <code><a href="base.html#topic+NULL">NULL</a></code>, all samples are used as a reference.</p>
</td></tr>
<tr><td><code id="NmfPlm_+3A_flavor">flavor</code></td>
<td>
<p>(Internal/developmental only)
A <code><a href="base.html#topic+character">character</a></code> string specifying which algorithm to use.</p>
</td></tr>
</table>


<h3>Fields and Methods</h3>

<p><b>Methods:</b><br />
</p>

<table>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code>getAsteriskTags</code> </td><td style="text-align: left;">  -</td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>

<p><b>Methods inherited from ProbeLevelModel</b>:<br />
calculateResidualSet, calculateWeights, fit, getAsteriskTags, getCalculateResidualsFunction, getChipEffectSet, getProbeAffinityFile, getResidualSet, getRootPath, getWeightsSet
</p>
<p><b>Methods inherited from MultiArrayUnitModel</b>:<br />
getListOfPriors, setListOfPriors, validate
</p>
<p><b>Methods inherited from UnitModel</b>:<br />
findUnitsTodo, getAsteriskTags, getFitSingleCellUnitFunction, getParameters
</p>
<p><b>Methods inherited from Model</b>:<br />
as.character, fit, getAlias, getAsteriskTags, getDataSet, getFullName, getName, getPath, getRootPath, getTags, setAlias, setTags
</p>
<p><b>Methods inherited from ParametersInterface</b>:<br />
getParameterSets, getParameters, getParametersAsString
</p>
<p><b>Methods inherited from Object</b>:<br />
$, $&lt;-, [[, [[&lt;-, as.character, attach, attachLocally, clearCache, clearLookupCache, clone, detach, equals, extend, finalize, getEnvironment, getFieldModifier, getFieldModifiers, getFields, getInstantiationTime, getStaticInstance, hasField, hashCode, ll, load, names, objectSize, print, save, asThis
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>References</h3>

<p>[1] M. Ortiz-Estevez, H. Bengtsson, A. Rubio, <em>ACNE: a summarization method to estimate allele-specific copy numbers for Affymetrix SNP arrays</em>, Bioinformatics, 2010 [PMC2913655].
<br />
</p>


<h3>See Also</h3>

<p>Internally, for each SNP the NMF model is fitted using the
<code><a href="#topic+fitSnpNmf">fitSnpNmf</a></code>() function.
</p>

<hr>
<h2 id='NmfSnpPlm'>The NmfSnpPlm class</h2><span id='topic+NmfSnpPlm'></span>

<h3>Description</h3>

<p>Package:  ACNE <br />
<b>Class NmfSnpPlm</b><br />
</p>
<p><code><a href="R.oo.html#topic+Object">Object</a></code><br />
<code>~~|</code><br />
<code>~~+--</code><code><a href="aroma.core.html#topic+ParametersInterface">ParametersInterface</a></code><br />
<code>~~~~~~~|</code><br />
<code>~~~~~~~+--</code><code><a href="aroma.affymetrix.html#topic+Model">Model</a></code><br />
<code>~~~~~~~~~~~~|</code><br />
<code>~~~~~~~~~~~~+--</code><code><a href="aroma.affymetrix.html#topic+UnitModel">UnitModel</a></code><br />
<code>~~~~~~~~~~~~~~~~~|</code><br />
<code>~~~~~~~~~~~~~~~~~+--</code><code><a href="aroma.affymetrix.html#topic+MultiArrayUnitModel">MultiArrayUnitModel</a></code><br />
<code>~~~~~~~~~~~~~~~~~~~~~~|</code><br />
<code>~~~~~~~~~~~~~~~~~~~~~~+--</code><code><a href="aroma.affymetrix.html#topic+ProbeLevelModel">ProbeLevelModel</a></code><br />
<code>~~~~~~~~~~~~~~~~~~~~~~~~~~~|</code><br />
<code>~~~~~~~~~~~~~~~~~~~~~~~~~~~+--</code><code><a href="#topic+NmfPlm">NmfPlm</a></code><br />
<code>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|</code><br />
<code>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+--</code><code><a href="aroma.affymetrix.html#topic+SnpPlm">SnpPlm</a></code><br />
<code>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|</code><br />
<code>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+--</code><em><code>NmfSnpPlm</code></em><br />
</p>
<p><b>Directly known subclasses:</b><br />
<br />
</p>
<p>public abstract static class <b>NmfSnpPlm</b><br />
extends <a href="aroma.affymetrix.html#topic+SnpPlm">SnpPlm</a><br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NmfSnpPlm(..., mergeStrands=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NmfSnpPlm_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+NmfPlm">NmfPlm</a></code>.</p>
</td></tr>
<tr><td><code id="NmfSnpPlm_+3A_mergestrands">mergeStrands</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, the sense and the anti-sense strands are
fitted together, otherwise separately.</p>
</td></tr>
</table>


<h3>Fields and Methods</h3>

<p><b>Methods:</b><br />
<em>No methods defined</em>.
</p>
<p><b>Methods inherited from SnpPlm</b>:<br />
getCellIndices, getChipEffectSet, getMergeStrands, getParameters, getProbeAffinityFile, setMergeStrands
</p>
<p><b>Methods inherited from NmfPlm</b>:<br />
getAsteriskTags
</p>
<p><b>Methods inherited from ProbeLevelModel</b>:<br />
calculateResidualSet, calculateWeights, fit, getAsteriskTags, getCalculateResidualsFunction, getChipEffectSet, getProbeAffinityFile, getResidualSet, getRootPath, getWeightsSet
</p>
<p><b>Methods inherited from MultiArrayUnitModel</b>:<br />
getListOfPriors, setListOfPriors, validate
</p>
<p><b>Methods inherited from UnitModel</b>:<br />
findUnitsTodo, getAsteriskTags, getFitSingleCellUnitFunction, getParameters
</p>
<p><b>Methods inherited from Model</b>:<br />
as.character, fit, getAlias, getAsteriskTags, getDataSet, getFullName, getName, getPath, getRootPath, getTags, setAlias, setTags
</p>
<p><b>Methods inherited from ParametersInterface</b>:<br />
getParameterSets, getParameters, getParametersAsString
</p>
<p><b>Methods inherited from Object</b>:<br />
$, $&lt;-, [[, [[&lt;-, as.character, attach, attachLocally, clearCache, clearLookupCache, clone, detach, equals, extend, finalize, getEnvironment, getFieldModifier, getFieldModifiers, getFields, getInstantiationTime, getStaticInstance, hasField, hashCode, ll, load, names, objectSize, print, save, asThis
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>

<hr>
<h2 id='Non-documented+20objects'>Non-documented objects</h2><span id='topic+Non-documented+20objects'></span><span id='topic+Nmf'></span><span id='topic+RemoveOutliers'></span><span id='topic+RobustHinit'></span><span id='topic+RobustWinit'></span><span id='topic+getAsteriskTags.NmfPlm'></span><span id='topic+getAsteriskTags.NmfSnpPlm'></span><span id='topic+getFitUnitFunction.NmfPlm'></span><span id='topic+getProbeAffinityFile.NmfPlm'></span><span id='topic+plotFreqB'></span><span id='topic+miqr.solve'></span><span id='topic+cat'></span>

<h3>Description</h3>

<p>This page contains aliases for all &quot;non-documented&quot; objects that
<code>R CMD check</code> detects in this package.
</p>
<p>Almost all of them are <em>generic</em> functions that have specific
document for the corresponding method coupled to a specific class.
Other functions are re-defined by <code>setMethodS3()</code> to
<em>default</em> methods. Neither of these two classes are non-documented
in reality.
The rest are deprecated methods.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>

<hr>
<h2 id='plot.SnpNmfFit'>Generates a multi-panel plot summarizing the NMF SNP fit</h2><span id='topic+plot.SnpNmfFit'></span><span id='topic+SnpNmfFit.plot'></span><span id='topic+plot+2CSnpNmfFit-method'></span>

<h3>Description</h3>

<p>Generates a multi-panel plot summarizing the NMF SNP fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SnpNmfFit'
plot(x, lim=c(0, 2^16), cnLim=c(0, 4), epsLim=c(-1, 1) * 2^12, main=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.SnpNmfFit_+3A_lim">lim</code>, <code id="plot.SnpNmfFit_+3A_cnlim">cnLim</code>, <code id="plot.SnpNmfFit_+3A_epslim">epsLim</code></td>
<td>
<p>The plot ranges for the probe data,
the CN estimates, and the probe-affinity estimates.</p>
</td></tr>
<tr><td><code id="plot.SnpNmfFit_+3A_main">main</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string to be the main title of the plot.</p>
</td></tr>
<tr><td><code id="plot.SnpNmfFit_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return nothing.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+fitSnpNmfArray">fitSnpNmfArray</a></code>().
</p>

<hr>
<h2 id='pseudoinverse'>Calculates the pseudo inverse of a matrix</h2><span id='topic+pseudoinverse'></span>

<h3>Description</h3>

<p>Calculates the pseudo inverse of a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pseudoinverse(X, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pseudoinverse_+3A_x">X</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+matrix">matrix</a></code>.</p>
</td></tr>
<tr><td><code id="pseudoinverse_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+matrix">matrix</a></code>.
</p>


<h3>See Also</h3>

<p>Internally <code><a href="base.html#topic+svd">svd</a></code>() is used.
</p>

<hr>
<h2 id='removeOutliers'>Removes outliers in matrix containing SNP signals</h2><span id='topic+removeOutliers'></span>

<h3>Description</h3>

<p>Removes outliers in matrix containing SNP signals by identifying outlier elements.  The values of the
elements that are outliers are substituted by corresponding values
predicted values <code>Yest=W*H</code> from the current affinity (<code>W</code>)
and copy number (<code>H</code>) estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>removeOutliers(Y, W, H, tau=10, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="removeOutliers_+3A_y">Y</code></td>
<td>
<p>An IxK <code><a href="base.html#topic+matrix">matrix</a></code>.</p>
</td></tr>
<tr><td><code id="removeOutliers_+3A_w">W</code></td>
<td>
<p>A Kx2 <code><a href="base.html#topic+matrix">matrix</a></code> of probe-affinity estimates.</p>
</td></tr>
<tr><td><code id="removeOutliers_+3A_h">H</code></td>
<td>
<p>A 2xI <code><a href="base.html#topic+matrix">matrix</a></code> of allele-specific copy-number estimates.</p>
</td></tr>
<tr><td><code id="removeOutliers_+3A_tau">tau</code></td>
<td>
<p>A scalar specifying the threshold for identifying outliers.</p>
</td></tr>
<tr><td><code id="removeOutliers_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an IxK <code><a href="base.html#topic+matrix">matrix</a></code> where outliers have been &quot;pruned&quot;.
Outliers are substituted by the corresponding value of <code>Yest</code>.
</p>

<hr>
<h2 id='robustHInit'>Robust initialization of the H (copy number) matrix</h2><span id='topic+robustHInit'></span>

<h3>Description</h3>

<p>Robust initialization of the H (copy number) matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robustHInit(V, W, maxIter=5L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="robustHInit_+3A_v">V</code></td>
<td>
<p>An KxI <code><a href="base.html#topic+matrix">matrix</a></code> where I is the number of arrays and K is the
number of probes where K should be even (K=2L).</p>
</td></tr>
<tr><td><code id="robustHInit_+3A_w">W</code></td>
<td>
<p>A Kx2 <code><a href="base.html#topic+matrix">matrix</a></code> of probe-affinity estimates.</p>
</td></tr>
<tr><td><code id="robustHInit_+3A_maxiter">maxIter</code></td>
<td>
<p>The maximum number of iteration.</p>
</td></tr>
<tr><td><code id="robustHInit_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function utilized a random number generator.
</p>


<h3>Value</h3>

<p>Returns a 2xI <code><a href="base.html#topic+matrix">matrix</a></code> of robustified allele-specific copy-number estimates.
</p>

<hr>
<h2 id='robustWInit'>Robust initialization of the W (affinity) matrix</h2><span id='topic+robustWInit'></span>

<h3>Description</h3>

<p>Robust initialization of the W (affinity) matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robustWInit(V, H, maxIter=50L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="robustWInit_+3A_v">V</code></td>
<td>
<p>An KxI <code><a href="base.html#topic+matrix">matrix</a></code> where I is the number of arrays and K is the
number of probes where K should be even (K=2L).</p>
</td></tr>
<tr><td><code id="robustWInit_+3A_h">H</code></td>
<td>
<p>A 2xI <code><a href="base.html#topic+matrix">matrix</a></code> of allele-specific copy-number estimates.</p>
</td></tr>
<tr><td><code id="robustWInit_+3A_maxiter">maxIter</code></td>
<td>
<p>The maximum number of iterations.</p>
</td></tr>
<tr><td><code id="robustWInit_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function utilized a random number generator.
</p>


<h3>Value</h3>

<p>Returns a Kx2 <code><a href="base.html#topic+matrix">matrix</a></code> of robustified probe-affinity estimates.
</p>

<hr>
<h2 id='snpArrayToMatrix'>Reshapes SNP data in matrix form to array form and vice versa</h2><span id='topic+snpArrayToMatrix'></span><span id='topic+snpMatrixToArray'></span>

<h3>Description</h3>

<p>Reshapes SNP data in matrix form to array form and vice versa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snpArrayToMatrix(Y, dropNames=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="snpArrayToMatrix_+3A_y">Y</code></td>
<td>
<p>A 2LxI <code><a href="base.html#topic+matrix">matrix</a></code> or a Lx2xI <code><a href="base.html#topic+array">array</a></code>,
where L is the number of probe pairs and I is the number of arrays.</p>
</td></tr>
<tr><td><code id="snpArrayToMatrix_+3A_dropnames">dropNames</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, dimension names are dropped,
otherwise preserved.</p>
</td></tr>
<tr><td><code id="snpArrayToMatrix_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a Lx2xI <code><a href="base.html#topic+array">array</a></code> or a 2LxI matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Y &lt;- matrix(rnorm(200), nrow=20, ncol=10)
str(Y)

V &lt;- snpMatrixToArray(Y)
str(V)

Y2 &lt;- snpArrayToMatrix(V)
str(Y2)

stopifnot(identical(Y2, Y))

</code></pre>

<hr>
<h2 id='WHInit'>Initialization of the W and H matrices</h2><span id='topic+WHInit'></span>

<h3>Description</h3>

<p>Initialization of the W and H matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WHInit(V, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WHInit_+3A_v">V</code></td>
<td>
<p>An KxI <code><a href="base.html#topic+matrix">matrix</a></code> where I is the number of arrays and
K is the number of probes where K should be even (K=2L).</p>
</td></tr>
<tr><td><code id="WHInit_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The allele-specific copy number estimates are estimated using a
naive genotyping algorithm.
The probe-affinities are estimated using a pseudo inverse.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+list">list</a></code>:
</p>
<table>
<tr><td><code>W</code></td>
<td>
<p>A Kx2 <code><a href="base.html#topic+matrix">matrix</a></code> of initial probe-affinity estimates.</p>
</td></tr>
<tr><td><code>H</code></td>
<td>
<p>A 2xI <code><a href="base.html#topic+matrix">matrix</a></code> of initial allele-specific copy-number estimates.</p>
</td></tr>
<tr><td><code>status</code></td>
<td>
<p>An <code><a href="base.html#topic+integer">integer</a></code> specifying the status of the initialization:
0=normal case, 1=only one allele (either AA or BB), or
2=all samples are AB.
</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
