<!DOCTYPE html><html><head><title>Help for package DiffCorr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DiffCorr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#DiffCorr-package'><p>Differential correlations in omics datasets</p></a></li>
<li><a href='#AraMetLeaves'><p>A metabolite data set from Arabidopsis leaves by GC-TOF/MS</p></a></li>
<li><a href='#AraMetRoots'><p>A metabolite data set from Arabidopsis roots by GC-TOF/MS</p></a></li>
<li><a href='#cluster.molecule'><p>Hierarchical clustering of molecules</p></a></li>
<li><a href='#comp.2.cc.fdr'><p>Export differential correlations between two conditions</p></a></li>
<li><a href='#compcorr'><p>Compare two correlation coefficients</p></a></li>
<li><a href='#cor.dist'><p>Additional distance functions correlation distance (1-r)</p></a></li>
<li><a href='#cor2.test'><p>Correlation Test</p></a></li>
<li><a href='#generate_g'><p>Generating graph from data matrix</p></a></li>
<li><a href='#get.eigen.molecule'><p>Get eigen molecule</p></a></li>
<li><a href='#get.eigen.molecule.graph'><p>Getting graph from eigengene module list</p></a></li>
<li><a href='#get.lfdr'><p>Getting local false discovery rate (lfdr)</p></a></li>
<li><a href='#get.min.max'><p>Get minimum and maximum</p></a></li>
<li><a href='#plotClusterMolecules'><p>Plot cluster molecules</p></a></li>
<li><a href='#plotDiffCorrGroup'><p>Plot DiffCorr group</p></a></li>
<li><a href='#scalingMethods'><p>scalingMethods</p></a></li>
<li><a href='#uncent.cor2dist'><p>Additional distance functions correlation distance (uncentered)</p></a></li>
<li><a href='#uncent.cordist'><p>Calculating all pairwise distances using correlation distance</p></a></li>
<li><a href='#write.modules'><p>Writing modules into a text file</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Analyzing and Visualizing Differential Correlation Networks in
Biological Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-20</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Atsushi Fukushima &lt;afukushima@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>pcaMethods, igraph, fdrtool, multtest</td>
</tr>
<tr>
<td>Description:</td>
<td>A method for identifying pattern changes between 2 experimental
         conditions in correlation networks (e.g., gene co-expression networks),
         which builds on a commonly used association measure, such as Pearson's
         correlation coefficient. This package includes functions to calculate
         correlation matrices for high-dimensional dataset and to test
         differential correlation, which means the changes in the correlation
         relationship among variables (e.g., genes and metabolites) between 2
         experimental conditions. </td>
</tr>
<tr>
<td>License:</td>
<td></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-25 01:05:11 UTC; fuku</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-25 09:40:06 UTC</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Author:</td>
<td>Atsushi Fukushima [aut, cre],
  Kozo Nishida [aut]</td>
</tr>
</table>
<hr>
<h2 id='DiffCorr-package'>Differential correlations in omics datasets</h2><span id='topic+DiffCorr-package'></span><span id='topic+_PACKAGE'></span>

<h3>Description</h3>

<p>Analyze and visualize differential correlations in biological networks
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Atsushi Fukushima <a href="mailto:afukushima@gmail.com">afukushima@gmail.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Kozo Nishida <a href="mailto:kozo.nishida@gmail.com">kozo.nishida@gmail.com</a>
</p>
</li></ul>


<hr>
<h2 id='AraMetLeaves'>A metabolite data set from Arabidopsis leaves by GC-TOF/MS</h2><span id='topic+AraMetLeaves'></span>

<h3>Description</h3>

<p>A metabolite data set. The Arabidopsis metabolome of the aerial
regions of individual WT plants and the mto1 and tt4 mutants
were analyzed by GC-TOF/MS.
</p>


<h3>Details</h3>

<p>50 samples (WT, n = 17; mto1, n = 13; and tt4, n = 20, biological
replicates).
</p>
<p>A matrix containing  59 metabolites (rows) and 50 observations 
(columns).
</p>
<p>MetaboLights accession no.: MTBLS40
</p>
<p>For comparisons with data from roots (Fukushima et al. 2011) we selected 
59 commonly-detected metabolites in both datasets using 
MetMask http://metmask.sourceforge.net.
</p>


<h3>Author(s)</h3>

<p>Atsushi Fukushima
</p>


<h3>References</h3>

<p>Miyako Kusano, Atsushi Fukushima et al. BMC Syst Biol 2007 1:53
</p>

<hr>
<h2 id='AraMetRoots'>A metabolite data set from Arabidopsis roots by GC-TOF/MS</h2><span id='topic+AraMetRoots'></span>

<h3>Description</h3>

<p>A metabolite data set. The Arabidopsis metabolome of the roots 
of individual WT plants and the mto1 and tt4 mutants were
analyzed by GC-TOF/MS.
</p>


<h3>Details</h3>

<p>53 root samples (WT, n = 17; mto1 n = 16; and tt4, n = 20,
biological replicates).
</p>
<p>A matrix containing  59 metabolites (rows) and 53 observations 
(columns).
</p>
<p>MetaboLights accession no.: MTBLS45
</p>
<p>For comparisons with data from aerial parts (Kusano, Fukushima et al. 2007) 
we selected 59 commonly-detected metabolites in both datasets using 
MetMask http://metmask.sourceforge.net.
</p>


<h3>Author(s)</h3>

<p>Atsushi Fukushima
</p>


<h3>References</h3>

<p>Atsushi Fukushima et al. BMC Syst Biol 2011 5:1.
</p>

<hr>
<h2 id='cluster.molecule'>Hierarchical clustering of molecules</h2><span id='topic+cluster.molecule'></span>

<h3>Description</h3>

<p>Cluster molecules
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster.molecule(
  data,
  method = "pearson",
  linkage = "average",
  absolute = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluster.molecule_+3A_data">data</code></td>
<td>
<p>matrix or data frame</p>
</td></tr>
<tr><td><code id="cluster.molecule_+3A_method">method</code></td>
<td>
<p>c(&quot;pearson&quot;, &quot;spearman&quot;, &quot;kendall&quot;, &quot;euclidean&quot;,
&quot;maximum&quot;, &quot;manhattan&quot;, &quot;canberra&quot;, &quot;binary&quot;, or &quot;minkowski&quot;)</p>
</td></tr>
<tr><td><code id="cluster.molecule_+3A_linkage">linkage</code></td>
<td>
<p>c(&quot;average&quot;, &quot;ward&quot;, &quot;single&quot;, &quot;complete&quot;, &quot;mcquitty&quot;,
&quot;median&quot;, &quot;centroid&quot;)</p>
</td></tr>
<tr><td><code id="cluster.molecule_+3A_absolute">absolute</code></td>
<td>
<p>if TRUE, then 1-|COR| else 1-COR, default is FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class 'hclust'
</p>


<h3>Author(s)</h3>

<p>Atsushi Fukushima
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cluster.molecule(as.matrix(t(iris[,1:4])), "pearson", "average")
</code></pre>

<hr>
<h2 id='comp.2.cc.fdr'>Export differential correlations between two conditions</h2><span id='topic+comp.2.cc.fdr'></span>

<h3>Description</h3>

<p>Export differential correlations of comparison of two correlation matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comp.2.cc.fdr(
  output.file = "res.txt",
  data1,
  data2,
  method = "pearson",
  p.adjust.methods = "local",
  threshold = 0.05
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comp.2.cc.fdr_+3A_output.file">output.file</code></td>
<td>
<p>can specify file name of the results exported</p>
</td></tr>
<tr><td><code id="comp.2.cc.fdr_+3A_data1">data1</code></td>
<td>
<p>data matrix under condition 1</p>
</td></tr>
<tr><td><code id="comp.2.cc.fdr_+3A_data2">data2</code></td>
<td>
<p>data matrix under condition 2</p>
</td></tr>
<tr><td><code id="comp.2.cc.fdr_+3A_method">method</code></td>
<td>
<p>c(&quot;pearson&quot;, &quot;spearman&quot;, &quot;kendall&quot;)</p>
</td></tr>
<tr><td><code id="comp.2.cc.fdr_+3A_p.adjust.methods">p.adjust.methods</code></td>
<td>
<p>c(&quot;local&quot;, holm&quot;, &quot;hochberg&quot;, &quot;hommel&quot;, &quot;bonferroni&quot;, &quot;BH&quot;, &quot;BY&quot;, &quot;fdr&quot;, &quot;none&quot;)</p>
</td></tr>
<tr><td><code id="comp.2.cc.fdr_+3A_threshold">threshold</code></td>
<td>
<p>a threshold of significance levels of differential correlation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a text file
</p>


<h3>Author(s)</h3>

<p>Atsushi Fukushima
</p>


<h3>References</h3>

<p>Fukushima, A. Gene (2013) 518, 209-214
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(AraMetRoots)
AraMetRoots[AraMetRoots==0] &lt;- NA
AraMetRootsImp &lt;- completeObs(pca(log2(AraMetRoots), nPcs=3, method="ppca"))
comp.2.cc.fdr(output.file="res.txt", AraMetRootsImp[,1:17], method="spearman",
              AraMetRootsImp[,18:37], threshold=0.05)

## End(Not run)
</code></pre>

<hr>
<h2 id='compcorr'>Compare two correlation coefficients</h2><span id='topic+compcorr'></span>

<h3>Description</h3>

<p>Compare two correlation coefficients using Fisher's Z-transformation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compcorr(n1, r1, n2, r2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compcorr_+3A_n1">n1</code></td>
<td>
<p>sample size under condition 1</p>
</td></tr>
<tr><td><code id="compcorr_+3A_r1">r1</code></td>
<td>
<p>correlation coefficient under condition 1</p>
</td></tr>
<tr><td><code id="compcorr_+3A_n2">n2</code></td>
<td>
<p>sample size under condition 2</p>
</td></tr>
<tr><td><code id="compcorr_+3A_r2">r2</code></td>
<td>
<p>correlation coefficient under condition 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of result (diff and p-value)
</p>


<h3>Author(s)</h3>

<p>Atsushi Fukushima
</p>


<h3>References</h3>

<p>http://www.fon.hum.uva.nl/Service/Statistics/Two_Correlations.html
http://support.sas.com/ctx/samples/index.jsp?sid=494
http://support.sas.com/ctx/samples/index.jsp?sid=494
</p>


<h3>Examples</h3>

<pre><code class='language-R'>compcorr(10, 0.1, 10, 0.9)
</code></pre>

<hr>
<h2 id='cor.dist'>Additional distance functions correlation distance (1-r)</h2><span id='topic+cor.dist'></span>

<h3>Description</h3>

<p>Additional distance functions Correlation distance (1-r)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor.dist(data, methods = "pearson", absolute = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cor.dist_+3A_data">data</code></td>
<td>
<p>a data matrix ([data.frame object] row: metabolites,
col: samples or replicates)</p>
</td></tr>
<tr><td><code id="cor.dist_+3A_methods">methods</code></td>
<td>
<p>a character string indicating which correlation coefficient is to be calculated. One of &quot;pearson&quot; (default), &quot;spearman&quot;, or &quot;kendall&quot; can be abbreviated.</p>
</td></tr>
<tr><td><code id="cor.dist_+3A_absolute">absolute</code></td>
<td>
<p>TRUE means that absolute value of the correlation coefficient is used (Default: FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions were originally from 'hybridHclust' package.
We modified the functions slightly. See also the reference manual in detail.
</p>


<h3>Value</h3>

<p>the resulting correlation matrix
</p>


<h3>Author(s)</h3>

<p>Atsushi Fukushima
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cor.dist(as.matrix(t(iris[,1:4])))
</code></pre>

<hr>
<h2 id='cor2.test'>Correlation Test</h2><span id='topic+cor2.test'></span>

<h3>Description</h3>

<p>Correlation Test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor2.test(n, r, method = c("pearson", "kendall", "spearman"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cor2.test_+3A_n">n</code></td>
<td>
<p>the number of samples</p>
</td></tr>
<tr><td><code id="cor2.test_+3A_r">r</code></td>
<td>
<p>the correlation coefficient</p>
</td></tr>
<tr><td><code id="cor2.test_+3A_method">method</code></td>
<td>
<p>&quot;pearson&quot; and &quot;spearman&quot; can be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>p-value
</p>


<h3>Author(s)</h3>

<p>Atsushi Fukushima
</p>


<h3>References</h3>

<p>http://aoki2.si.gunma-u.ac.jp/R/cor2.html
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cor2.test(30, 0.6)
</code></pre>

<hr>
<h2 id='generate_g'>Generating graph from data matrix</h2><span id='topic+generate_g'></span>

<h3>Description</h3>

<p>Generating graph from data matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_g(
  data,
  method = "pearson",
  cor.thr = 0.6,
  neg.flag = 1,
  node.col = "red",
  node.size = 7,
  edge.col = "blue",
  edge.width = 3
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_g_+3A_data">data</code></td>
<td>
<p>data matrix or data frame</p>
</td></tr>
<tr><td><code id="generate_g_+3A_method">method</code></td>
<td>
<p>c(&quot;Pearson&quot;, &quot;Spearman&quot;, &quot;Kendall&quot;)</p>
</td></tr>
<tr><td><code id="generate_g_+3A_cor.thr">cor.thr</code></td>
<td>
<p>a threshold of correlation coefficient (default: r &gt;= 0.6)</p>
</td></tr>
<tr><td><code id="generate_g_+3A_neg.flag">neg.flag</code></td>
<td>
<p>flag where uses or not negative correlations</p>
</td></tr>
<tr><td><code id="generate_g_+3A_node.col">node.col</code></td>
<td>
<p>specifies color of nodes in a graph (default: red)</p>
</td></tr>
<tr><td><code id="generate_g_+3A_node.size">node.size</code></td>
<td>
<p>specifies size of nodes in a graph (default: 7)</p>
</td></tr>
<tr><td><code id="generate_g_+3A_edge.col">edge.col</code></td>
<td>
<p>specifies color of edges in a graph (default: blue)</p>
</td></tr>
<tr><td><code id="generate_g_+3A_edge.width">edge.width</code></td>
<td>
<p>specifies width of edges in a graph (default: 3)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>igraph object
</p>


<h3>Author(s)</h3>

<p>Atsushi Fukushima
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)
mat &lt;- matrix(runif(100), nr=10)
rownames(mat) &lt;- as.character(1:10)
generate_g(mat)
</code></pre>

<hr>
<h2 id='get.eigen.molecule'>Get eigen molecule</h2><span id='topic+get.eigen.molecule'></span>

<h3>Description</h3>

<p>Get eigen molecule
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.eigen.molecule(data, groups, whichgroups = NULL, methods = "svd", n = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.eigen.molecule_+3A_data">data</code></td>
<td>
<p>a data matrix ([data.frame object] row: molecules,
col: samples or replicates)</p>
</td></tr>
<tr><td><code id="get.eigen.molecule_+3A_groups">groups</code></td>
<td>
<p>a vector of group memberships as returned by cutree</p>
</td></tr>
<tr><td><code id="get.eigen.molecule_+3A_whichgroups">whichgroups</code></td>
<td>
<p>a vector of group numbers to examine</p>
</td></tr>
<tr><td><code id="get.eigen.molecule_+3A_methods">methods</code></td>
<td>
<p>c(&quot;svd&quot;, &quot;nipals&quot;, &quot;rnipals&quot;, &quot;bpca&quot;, &quot;ppca&quot;). See also pca() function in pcaMethods package</p>
</td></tr>
<tr><td><code id="get.eigen.molecule_+3A_n">n</code></td>
<td>
<p>top n principal components</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the resulting vector.
</p>


<h3>Author(s)</h3>

<p>Atsushi Fukushima
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(pcaMethods)
data(golub, package = "multtest")
hc.mol1 &lt;- cluster.molecule(golub[1:100, 1:27], "pearson", "average")
g1 &lt;- cutree(hc.mol1, h=0.6)
res1 &lt;- get.eigen.molecule(golub[1:100,], g1)
</code></pre>

<hr>
<h2 id='get.eigen.molecule.graph'>Getting graph from eigengene module list</h2><span id='topic+get.eigen.molecule.graph'></span>

<h3>Description</h3>

<p>Getting graph from eigengene module list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.eigen.molecule.graph(eigen.list, label = "Module")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.eigen.molecule.graph_+3A_eigen.list">eigen.list</code></td>
<td>
<p>the resulting vector from get.eigen.molecule</p>
</td></tr>
<tr><td><code id="get.eigen.molecule.graph_+3A_label">label</code></td>
<td>
<p>a label of module extracted (default: &quot;Module&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>igraph object
</p>


<h3>Author(s)</h3>

<p>Atsushi Fukushima
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(pcaMethods)
library(igraph)
data(golub, package = "multtest")
hc.mol1 &lt;- cluster.molecule(golub[, 1:27], "pearson", "average")
g1 &lt;- cutree(hc.mol1, h=0.4)
res1 &lt;- get.eigen.molecule(golub, g1)
g1.eigen &lt;- get.eigen.molecule.graph(res1)
</code></pre>

<hr>
<h2 id='get.lfdr'>Getting local false discovery rate (lfdr)</h2><span id='topic+get.lfdr'></span>

<h3>Description</h3>

<p>Getting local false discovery rate (lfdr) using 'fdrtool' package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.lfdr(r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.lfdr_+3A_r">r</code></td>
<td>
<p>a vector of correlation coefficient under condition</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of lfdr
</p>


<h3>Author(s)</h3>

<p>Atsushi Fukushima
</p>


<h3>References</h3>

<p>Strimmer, K. Bioinformatics (2008) 24, 1461-1462
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("fdrtool")
data(pvalues)
get.lfdr(pvalues)
</code></pre>

<hr>
<h2 id='get.min.max'>Get minimum and maximum</h2><span id='topic+get.min.max'></span>

<h3>Description</h3>

<p>Get minimum and maximum
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.min.max(d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.min.max_+3A_d">d</code></td>
<td>
<p>data matrix or data frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list object of minimum value or maximum value in a data
</p>


<h3>Author(s)</h3>

<p>Atsushi Fukushima
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get.min.max(iris[,1:2])
</code></pre>

<hr>
<h2 id='plotClusterMolecules'>Plot cluster molecules</h2><span id='topic+plotClusterMolecules'></span>

<h3>Description</h3>

<p>Plot cluster molecules
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotClusterMolecules(
  data,
  groups = NULL,
  group.no = NULL,
  title = NULL,
  ylim = NULL,
  order = NULL,
  scale.center = FALSE,
  scale.scale = FALSE,
  frame = "white",
  col = NULL,
  bottom.mar = 5,
  xlab = "Samples",
  ylab = "Relative abundance"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotClusterMolecules_+3A_data">data</code></td>
<td>
<p>data matrix or data frame</p>
</td></tr>
<tr><td><code id="plotClusterMolecules_+3A_groups">groups</code></td>
<td>
<p>a vector of group memberships as returned by cutree</p>
</td></tr>
<tr><td><code id="plotClusterMolecules_+3A_group.no">group.no</code></td>
<td>
<p>the group number to be plotted</p>
</td></tr>
<tr><td><code id="plotClusterMolecules_+3A_title">title</code></td>
<td>
<p>a title for the graph</p>
</td></tr>
<tr><td><code id="plotClusterMolecules_+3A_ylim">ylim</code></td>
<td>
<p>a vector indicating the upper and lower limit for the y-axis</p>
</td></tr>
<tr><td><code id="plotClusterMolecules_+3A_order">order</code></td>
<td>
<p>whether or not to order the columns of the data matrix</p>
</td></tr>
<tr><td><code id="plotClusterMolecules_+3A_scale.center">scale.center</code></td>
<td>
<p>unless NULL, each row is scaled using scale</p>
</td></tr>
<tr><td><code id="plotClusterMolecules_+3A_scale.scale">scale.scale</code></td>
<td>
<p>unless NULL, each row is scaled using scale.</p>
</td></tr>
<tr><td><code id="plotClusterMolecules_+3A_frame">frame</code></td>
<td>
<p>the color of the frame that is drawn as the background of the plot</p>
</td></tr>
<tr><td><code id="plotClusterMolecules_+3A_col">col</code></td>
<td>
<p>If NULL, all genes will be drawn in the default color (blue).
If the text &quot;random&quot; is given, then a set of colors will be generated by</p>
</td></tr>
<tr><td><code id="plotClusterMolecules_+3A_bottom.mar">bottom.mar</code></td>
<td>
<p>The size of the bottom margin of the plots as sent in par(mar=c(...))</p>
</td></tr>
<tr><td><code id="plotClusterMolecules_+3A_xlab">xlab</code></td>
<td>
<p>a lalel of x axis (defalt: &quot;Samples&quot;)</p>
</td></tr>
<tr><td><code id="plotClusterMolecules_+3A_ylab">ylab</code></td>
<td>
<p>a lalel of y axis (defalt: &quot;Relative abundance&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a graph
</p>


<h3>Author(s)</h3>

<p>Atsushi Fukushima
</p>


<h3>References</h3>

<p>this function was originally from Watson M (2005) BMC Bioinformatics 7:509
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(pcaMethods)
data(golub, package = "multtest")
hc.mol1 &lt;- cluster.molecule(golub[, 1:27], "pearson", "average")
g1 &lt;- cutree(hc.mol1, h=0.4)
plotClusterMolecules(golub[,1:27], g1, 3)
</code></pre>

<hr>
<h2 id='plotDiffCorrGroup'>Plot DiffCorr group</h2><span id='topic+plotDiffCorrGroup'></span>

<h3>Description</h3>

<p>Plot DiffCorr group
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotDiffCorrGroup(
  data,
  groups1 = NULL,
  groups2 = NULL,
  group1.no = NULL,
  group2.no = NULL,
  g1,
  g2,
  g1.order = NULL,
  g2.order = NULL,
  title1 = NULL,
  title2 = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotDiffCorrGroup_+3A_data">data</code></td>
<td>
<p>a data matrix or data frame</p>
</td></tr>
<tr><td><code id="plotDiffCorrGroup_+3A_groups1">groups1</code></td>
<td>
<p>a vector of row group membership as produced by cutree under condition 1</p>
</td></tr>
<tr><td><code id="plotDiffCorrGroup_+3A_groups2">groups2</code></td>
<td>
<p>a vector of row group membership as produced by cutree under condition 2</p>
</td></tr>
<tr><td><code id="plotDiffCorrGroup_+3A_group1.no">group1.no</code></td>
<td>
<p>the group number to be plotted (condition 1)</p>
</td></tr>
<tr><td><code id="plotDiffCorrGroup_+3A_group2.no">group2.no</code></td>
<td>
<p>the group number to be plotted (condition 2)</p>
</td></tr>
<tr><td><code id="plotDiffCorrGroup_+3A_g1">g1</code></td>
<td>
<p>a vector describing the columns of the data belonging to condition 1</p>
</td></tr>
<tr><td><code id="plotDiffCorrGroup_+3A_g2">g2</code></td>
<td>
<p>a vector describing the columns of the data belonging to condition 2</p>
</td></tr>
<tr><td><code id="plotDiffCorrGroup_+3A_g1.order">g1.order</code></td>
<td>
<p>whether or not to order the columns of the data
matrix for condition 1.  If &quot;average&quot;, then the columns are ordered
by the average expression value.  If the name of a gene (row),
then the columns are orderd according to the expression levels of
that gene.  If NULL, columns remain in their original order.</p>
</td></tr>
<tr><td><code id="plotDiffCorrGroup_+3A_g2.order">g2.order</code></td>
<td>
<p>See g1.order</p>
</td></tr>
<tr><td><code id="plotDiffCorrGroup_+3A_title1">title1</code></td>
<td>
<p>A title for the left hand graph</p>
</td></tr>
<tr><td><code id="plotDiffCorrGroup_+3A_title2">title2</code></td>
<td>
<p>A title for the right hand graph</p>
</td></tr>
<tr><td><code id="plotDiffCorrGroup_+3A_...">...</code></td>
<td>
<p>other parameters to be passed to this function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a graph
</p>


<h3>Author(s)</h3>

<p>Atsushi Fukushima
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(pcaMethods)
data(golub, package = "multtest")
hc.mol1 &lt;- cluster.molecule(golub[, 1:27], "pearson", "average")
hc.mol2 &lt;- cluster.molecule(golub[, 28:38], "pearson", "average")
g1 &lt;- cutree(hc.mol1, h=0.4)
g2 &lt;- cutree(hc.mol2, h=0.4)
##
plotDiffCorrGroup(golub, g1, g2, 21, 24, 1:27, 28:38,
                   scale.center=TRUE, scale.scale=TRUE,
                   ylim=c(-5,5))
</code></pre>

<hr>
<h2 id='scalingMethods'>scalingMethods</h2><span id='topic+scalingMethods'></span>

<h3>Description</h3>

<p>The pre-treatment methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scalingMethods(
  data,
  methods = c("auto", "range", "pareto", "vast", "level", "power")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scalingMethods_+3A_data">data</code></td>
<td>
<p>a data matrix ([data.frame object] row: molecules,
col: samples or replicates)</p>
</td></tr>
<tr><td><code id="scalingMethods_+3A_methods">methods</code></td>
<td>
<p>the chosen methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the resulting data frame (or scaled data matrix)
</p>


<h3>Author(s)</h3>

<p>Atsushi Fukushima
</p>


<h3>Examples</h3>

<pre><code class='language-R'>scalingMethods(iris[,1:4], "level")
</code></pre>

<hr>
<h2 id='uncent.cor2dist'>Additional distance functions correlation distance (uncentered)</h2><span id='topic+uncent.cor2dist'></span>

<h3>Description</h3>

<p>Additional distance functions correlation distance (uncentered)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uncent.cor2dist(data, i, absolute = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uncent.cor2dist_+3A_data">data</code></td>
<td>
<p>a data matrix ([data.frame object] row: metabolites,
col: samples or replicates)</p>
</td></tr>
<tr><td><code id="uncent.cor2dist_+3A_i">i</code></td>
<td>
<p>i-th row of data</p>
</td></tr>
<tr><td><code id="uncent.cor2dist_+3A_absolute">absolute</code></td>
<td>
<p>TRUE means that absolute value of the correlation coefficient is used (Default: FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions were originally from 'hybridHclust' package.
We modified the functions slightly. See also the reference manual in detail.
</p>


<h3>Value</h3>

<p>the resulting correlation matrix
</p>


<h3>Author(s)</h3>

<p>Atsushi Fukushima
</p>


<h3>Examples</h3>

<pre><code class='language-R'>uncent.cor2dist(as.matrix(t(iris[,1:4])), 1) ## NOT RUN!
</code></pre>

<hr>
<h2 id='uncent.cordist'>Calculating all pairwise distances using correlation distance</h2><span id='topic+uncent.cordist'></span>

<h3>Description</h3>

<p>Calculating all pairwise distances using correlation distance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uncent.cordist(data, absolute = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uncent.cordist_+3A_data">data</code></td>
<td>
<p>a data matrix ([data.frame object] row: metabolites,
col: samples or replicates)</p>
</td></tr>
<tr><td><code id="uncent.cordist_+3A_absolute">absolute</code></td>
<td>
<p>TRUE means that absolute value of the correlation coefficient is used (Default: FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions were originally from 'hybridHclust' package.
We modified the functions slightly. See also the reference manual in detail.
</p>


<h3>Value</h3>

<p>the resulting correlation matrix
</p>


<h3>Author(s)</h3>

<p>Atsushi Fukushima
</p>


<h3>Examples</h3>

<pre><code class='language-R'>uncent.cordist(as.matrix(t(iris[,1:4]))) ## NOT RUN!
</code></pre>

<hr>
<h2 id='write.modules'>Writing modules into a text file</h2><span id='topic+write.modules'></span>

<h3>Description</h3>

<p>Writing modules into a text file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.modules(cutree.res, mod.list, outfile = "module_list.txt")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.modules_+3A_cutree.res">cutree.res</code></td>
<td>
<p>the result of cutree function</p>
</td></tr>
<tr><td><code id="write.modules_+3A_mod.list">mod.list</code></td>
<td>
<p>the result of get.eigen.molecule</p>
</td></tr>
<tr><td><code id="write.modules_+3A_outfile">outfile</code></td>
<td>
<p>file name of output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a text file
</p>


<h3>Author(s)</h3>

<p>Atsushi Fukushima
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(golub, package = "multtest")
hc.mol1 &lt;- cluster.molecule(golub[, 1:27], "pearson", "average")
g1 &lt;- cutree(hc.mol1, h=0.4)
res1 &lt;- get.eigen.molecule(golub, g1)
write.modules(g1, res1)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
