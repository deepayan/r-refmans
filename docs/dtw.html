<!DOCTYPE html><html><head><title>Help for package dtw</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dtw}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#aami'><p>ANSI/AAMI EC13 Test Waveforms, 3a and 3b</p></a></li>
<li><a href='#countPaths'><p>Count the number of warping paths consistent with the constraints.</p></a></li>
<li><a href='#dtw'><p>Dynamic Time Warp</p></a></li>
<li><a href='#dtw-internal'><p>Internal dtw Functions</p></a></li>
<li><a href='#dtw-package'><p>Comprehensive implementation of Dynamic Time Warping (DTW) algorithms in R.</p></a></li>
<li><a href='#dtwDist'><p>Compute a dissimilarity matrix</p></a></li>
<li><a href='#dtwPlot'><p>Plotting of dynamic time warp results</p></a></li>
<li><a href='#dtwPlotDensity'><p>Display the cumulative cost density with the warping path overimposed</p></a></li>
<li><a href='#dtwPlotThreeWay'><p>Plotting of dynamic time warp results: annotated warping function</p></a></li>
<li><a href='#dtwPlotTwoWay'><p>Plotting of dynamic time warp results: pointwise comparison</p></a></li>
<li><a href='#dtwWindowingFunctions'><p>Global constraints and windowing functions for DTW</p></a></li>
<li><a href='#mvm'><p>Minimum Variance Matching algorithm</p></a></li>
<li><a href='#stepPattern'><p>Step patterns for DTW</p></a></li>
<li><a href='#warp'><p>Apply a warping to a given timeseries</p></a></li>
<li><a href='#warpArea'><p>Compute Warping Path Area</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Dynamic Time Warping Algorithms</td>
</tr>
<tr>
<td>Description:</td>
<td>A comprehensive implementation of dynamic time warping
    (DTW) algorithms in R.  DTW computes the optimal (least cumulative
    distance) alignment between points of two time series.  Common DTW
    variants covered include local (slope) and global (window)
    constraints, subsequence matches, arbitrary distance definitions,
    normalizations, minimum variance matching, and so on.  Provides
    cumulative distances, alignments, specialized plot styles, etc.,
    as described in Giorgino (2009) &lt;<a href="https://doi.org/10.18637%2Fjss.v031.i07">doi:10.18637/jss.v031.i07</a>&gt;.</td>
</tr>
<tr>
<td>Version:</td>
<td>1.23-1</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-9-19</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10.0), proxy</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, grDevices, stats, utils</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://dynamictimewarping.github.io/">https://dynamictimewarping.github.io/</a>,
<a href="http://dtw.r-forge.r-project.org/">http://dtw.r-forge.r-project.org/</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-09-19 17:02:06 UTC; toni</td>
</tr>
<tr>
<td>Author:</td>
<td>Toni Giorgino [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Toni Giorgino &lt;toni.giorgino@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-09-19 17:36:11 UTC</td>
</tr>
</table>
<hr>
<h2 id='aami'>ANSI/AAMI EC13 Test Waveforms, 3a and 3b</h2><span id='topic+aami'></span><span id='topic+aami3a'></span><span id='topic+aami3b'></span>

<h3>Description</h3>

<p>ANSI/AAMI EC13 Test Waveforms 3a and 3b, as obtained from the PhysioBank
database.
</p>


<h3>Format</h3>

<p>Time-series objects (class <code>ts</code>).
</p>


<h3>Details</h3>

<p>The following text is reproduced (abridged) from PhysioBank, page
<a href="https://www.physionet.org/content/aami-ec13/1.0.0/">https://www.physionet.org/content/aami-ec13/1.0.0/</a>.  Other
recordings belong to the dataset and can be obtained from the same page.
</p>
<p>The files in this set can be used for testing a variety of devices that
monitor the electrocardiogram.  The recordings include both synthetic and
real waveforms. For details on these test waveforms and how to use them,
please refer to section 5.1.2.1, paragraphs (e) and (g) in the reference
below.  Each recording contains one ECG signal sampled at 720 Hz with 12-bit
resolution.
</p>


<h3>Note</h3>

<p>Timestamps in the datasets have been re-created at the indicated
frequency of 720 Hz, whereas the original timestamps in ms (at least in text
format) only had three decimal digits' precision, and were therefore
affected by substantial jittering.
</p>


<h3>Source</h3>

<p><a href="https://www.physionet.org/content/aami-ec13/1.0.0/">https://www.physionet.org/content/aami-ec13/1.0.0/</a>
</p>


<h3>References</h3>


<ul>
<li><p> Goldberger AL, Amaral LAN, Glass L, Hausdorff JM, Ivanov PCh,
Mark RG, Mietus JE, Moody GB, Peng CK, Stanley HE. <em>PhysioBank,
PhysioToolkit, and PhysioNet: Components of a New Research Resource for
Complex Physiologic Signals.</em> Circulation 101(23):e215-e220; 2000 (June
13).
</p>
</li>
<li><p> Cardiac monitors, heart rate meters, and alarms; American National
Standard (ANSI/AAMI EC13:2002). Arlington, VA: Association for the
Advancement of Medical Instrumentation, 2002.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(aami3a);
data(aami3b);

## Plot both as a multivariate TS object
##  only extract the first 10 seconds

plot( main="ECG (mV)",
 window(
  cbind(aami3a,aami3b)   ,end=10)
)




</code></pre>

<hr>
<h2 id='countPaths'>Count the number of warping paths consistent with the constraints.</h2><span id='topic+countPaths'></span>

<h3>Description</h3>

<p>Count how many possible warping paths exist in the alignment problem passed
as an argument. The object passed as an argument is used to look up the
problem parameters such as the used step pattern, windowing, open ends, and
so on. The actual alignment is ignored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>countPaths(d, debug = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="countPaths_+3A_d">d</code></td>
<td>
<p>an object of class <code>dtw</code></p>
</td></tr>
<tr><td><code id="countPaths_+3A_debug">debug</code></td>
<td>
<p>return an intermediate result</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the number of paths grows exponentially with problems size. The
result may be approximate when windowing functions are used.
</p>
<p>If <code>debug=TRUE</code>, a matrix used for the computation is
returned instead of the final result.
</p>


<h3>Value</h3>

<p>The number of paths.
</p>


<h3>Author(s)</h3>

<p>Toni Giorgino
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ds&lt;-dtw(1:7+2,1:8,keep=TRUE,step=asymmetric);
  countPaths(ds)
  ## Result: 126

</code></pre>

<hr>
<h2 id='dtw'>Dynamic Time Warp</h2><span id='topic+dtw'></span><span id='topic+is.dtw'></span><span id='topic+print.dtw'></span>

<h3>Description</h3>

<p>Compute Dynamic Time Warp and find optimal alignment between two time
series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtw(
  x,
  y = NULL,
  dist.method = "Euclidean",
  step.pattern = symmetric2,
  window.type = "none",
  keep.internals = FALSE,
  distance.only = FALSE,
  open.end = FALSE,
  open.begin = FALSE,
  ...
)

is.dtw(d)

## S3 method for class 'dtw'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dtw_+3A_x">x</code></td>
<td>
<p>query vector <em>or</em> local cost matrix</p>
</td></tr>
<tr><td><code id="dtw_+3A_y">y</code></td>
<td>
<p>reference vector, or NULL if <code>x</code> given as a local cost matrix</p>
</td></tr>
<tr><td><code id="dtw_+3A_dist.method">dist.method</code></td>
<td>
<p>pointwise (local) distance function to use. See
<code><a href="proxy.html#topic+dist">proxy::dist()</a></code> in package <a href="https://CRAN.R-project.org/package=proxy"><span class="pkg">proxy</span></a></p>
</td></tr>
<tr><td><code id="dtw_+3A_step.pattern">step.pattern</code></td>
<td>
<p>a stepPattern object describing the local warping steps
allowed with their cost (see <code><a href="#topic+stepPattern">stepPattern()</a></code>)</p>
</td></tr>
<tr><td><code id="dtw_+3A_window.type">window.type</code></td>
<td>
<p>windowing function. Character: &quot;none&quot;, &quot;itakura&quot;,
&quot;sakoechiba&quot;, &quot;slantedband&quot;, or a function (see details).</p>
</td></tr>
<tr><td><code id="dtw_+3A_keep.internals">keep.internals</code></td>
<td>
<p>preserve the cumulative cost matrix, inputs, and other
internal structures</p>
</td></tr>
<tr><td><code id="dtw_+3A_distance.only">distance.only</code></td>
<td>
<p>only compute distance (no backtrack, faster)</p>
</td></tr>
<tr><td><code id="dtw_+3A_open.begin">open.begin</code>, <code id="dtw_+3A_open.end">open.end</code></td>
<td>
<p>perform open-ended alignments</p>
</td></tr>
<tr><td><code id="dtw_+3A_...">...</code></td>
<td>
<p>additional arguments, passed to <code>window.type</code></p>
</td></tr>
<tr><td><code id="dtw_+3A_d">d</code></td>
<td>
<p>an arbitrary R object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function performs Dynamic Time Warp (DTW) and computes the optimal
alignment between two time series <code>x</code> and <code>y</code>, given as numeric
vectors.  The &quot;optimal&quot; alignment minimizes the sum of distances between
aligned elements. Lengths of <code>x</code> and <code>y</code> may differ.
</p>
<p>The local distance between elements of <code>x</code> (query) and <code>y</code>
(reference) can be computed in one of the following ways:
</p>

<ol>
<li><p> if <code>dist.method</code> is a string, <code>x</code> and <code>y</code> are passed to the <code><a href="proxy.html#topic+dist">proxy::dist()</a></code> function in package <a href="https://CRAN.R-project.org/package=proxy"><span class="pkg">proxy</span></a> with the method given;
</p>
</li>
<li><p> if <code>dist.method</code> is a function of two arguments, it invoked repeatedly on all pairs <code style="white-space: pre;">&#8288;x[i],y[j]&#8288;</code> to build the local cost matrix;
</p>
</li>
<li><p> multivariate time series and arbitrary distance metrics can be handled by supplying a precomputed local cost matrix. Element <code style="white-space: pre;">&#8288;[i,j]&#8288;</code> of the local cost matrix is understood as the distance between element <code>x[i]</code> and <code>y[j]</code>. The distance matrix has therefore <code>n=length(x)</code> rows and <code>m=length(y)</code> columns (see note below).
</p>
</li></ol>

<p>Several common variants of the DTW recursion are supported via the
<code>step.pattern</code> argument, which defaults to <code>symmetric2</code>. Step
patterns are commonly used to <em>locally</em> constrain the slope of the
alignment function. See <code><a href="#topic+stepPattern">stepPattern()</a></code> for details.
</p>
<p>Windowing enforces a <em>global</em> constraint on the envelope of the warping
path. It is selected by passing a string or function to the
<code>window.type</code> argument. Commonly used windows are (abbreviations
allowed):
</p>

<ul>
<li> <p><code>"none"</code> No windowing (default)
</p>
</li>
<li> <p><code>"sakoechiba"</code> A band around main diagonal
</p>
</li>
<li> <p><code>"slantedband"</code> A band around slanted diagonal
</p>
</li>
<li> <p><code>"itakura"</code> So-called Itakura parallelogram
</p>
</li></ul>

<p><code>window.type</code> can also be an user-defined windowing function.  See
<code><a href="#topic+dtwWindowingFunctions">dtwWindowingFunctions()</a></code> for all available windowing functions,
details on user-defined windowing, and a discussion of the (mis)naming of
the &quot;Itakura&quot; parallelogram as a global constraint.  Some windowing
functions may require parameters, such as the <code>window.size</code> argument.
</p>
<p>Open-ended alignment, i.e. semi-unconstrained alignment, can be selected via
the <code>open.end</code> switch.  Open-end DTW computes the alignment which best
matches all of the query with a <em>leading part</em> of the reference. This
is proposed e.g. by Mori (2006), Sakoe (1979) and others. Similarly,
open-begin is enabled via <code>open.begin</code>; it makes sense when
<code>open.end</code> is also enabled (subsequence finding). Subsequence
alignments are similar e.g. to UE2-1 algorithm by Rabiner (1978) and others.
Please find a review in Tormene et al. (2009).
</p>
<p>If the warping function is not required, computation can be sped up enabling
the <code>distance.only=TRUE</code> switch, which skips the backtracking step. The
output object will then lack the <code style="white-space: pre;">&#8288;index{1,2,1s,2s}&#8288;</code> and
<code>stepsTaken</code> fields.
</p>
<p><code>is.dtw</code> tests whether the argument is of class <code>dtw</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>dtw</code> with
the following items:
</p>

<ul>
<li> <p><code>distance</code> the minimum global distance computed, <em>not</em> normalized.
</p>
</li>
<li> <p><code>normalizedDistance</code> distance computed, <em>normalized</em> for path length, if normalization is known for chosen step pattern.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;N,M&#8288;</code> query and reference length
</p>
</li>
<li> <p><code>call</code> the function call that created the object
</p>
</li>
<li> <p><code>index1</code> matched elements: indices in <code>x</code>
</p>
</li>
<li> <p><code>index2</code> corresponding mapped indices in <code>y</code>
</p>
</li>
<li> <p><code>stepPattern</code> the <code>stepPattern</code> object used for the computation
</p>
</li>
<li> <p><code>jmin</code> last element of reference matched, if <code>open.end=TRUE</code>
</p>
</li>
<li> <p><code>directionMatrix</code> if <code>keep.internals=TRUE</code>, the directions of steps that would be taken at each alignment pair (integers indexing  production rules in the chosen step pattern)
</p>
</li>
<li> <p><code>stepsTaken</code> the list of steps taken from the beginning to the end of the alignment (integers indexing chosen step pattern)
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;index1s, index2s&#8288;</code> same as <code>index1/2</code>, excluding intermediate steps for multi-step patterns like <code><a href="#topic+asymmetricP05">asymmetricP05()</a></code>
</p>
</li>
<li> <p><code>costMatrix</code> if <code>keep.internals=TRUE</code>, the cumulative cost matrix
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;query, reference&#8288;</code> if <code>keep.internals=TRUE</code> and passed as the <code>x</code> and <code>y</code> arguments, the query and reference timeseries.
</p>
</li></ul>



<h3>Note</h3>

<p>Cost matrices (both input and output) have query elements arranged
row-wise (first index), and reference elements column-wise (second index).
They print according to the usual convention, with indexes increasing down-
and rightwards.  Many DTW papers and tutorials show matrices according to
plot-like conventions, i.e.  reference index growing upwards. This may be
confusing.
</p>


<h3>Author(s)</h3>

<p>Toni Giorgino
</p>


<h3>References</h3>


<ol>
<li><p> Toni Giorgino. <em>Computing and Visualizing Dynamic Time
Warping Alignments in R: The dtw Package.</em> Journal of Statistical Software,
31(7), 1-24.  <a href="https://doi.org/10.18637/jss.v031.i07">doi:10.18637/jss.v031.i07</a>
</p>
</li>
<li><p> Tormene, P.;
Giorgino, T.; Quaglini, S. &amp; Stefanelli, M. <em>Matching incomplete time
series with dynamic time warping: an algorithm and an application to
post-stroke rehabilitation.</em> Artif Intell Med, 2009, 45, 11-34.
<a href="https://doi.org/10.1016/j.artmed.2008.11.007">doi:10.1016/j.artmed.2008.11.007</a>
</p>
</li>
<li><p> Sakoe, H.;
Chiba, S., <em>Dynamic programming algorithm optimization for spoken word
recognition,</em> Acoustics, Speech, and Signal Processing,
IEEE Transactions on , vol.26, no.1, pp. 43-49, Feb 1978.
<a href="https://doi.org/10.1109/TASSP.1978.1163055">doi:10.1109/TASSP.1978.1163055</a>
</p>
</li>
<li><p> Mori, A.; Uchida, S.; Kurazume, R.; Taniguchi, R.; Hasegawa, T. &amp; Sakoe, H.
<em>Early Recognition and Prediction of Gestures</em> Proc. 18th International
Conference on Pattern Recognition ICPR 2006, 2006, 3, 560-563 <a href="https://doi.org/10.1109/ICPR.2006.467">doi:10.1109/ICPR.2006.467</a>
</p>
</li>
<li><p> Sakoe,
H. <em>Two-level DP-matching&ndash;A dynamic programming-based pattern matching
algorithm for connected word recognition</em> Acoustics, Speech, and Signal
Processing, IEEE Transactions on, 1979, 27, 588-595 <a href="https://doi.org/10.1109/TASSP.1979.1163310">doi:10.1109/TASSP.1979.1163310</a>
</p>
</li>
<li><p> Rabiner L, Rosenberg A, Levinson
S (1978). <em>Considerations in dynamic time warping algorithms for
discrete word recognition.</em> IEEE Trans. Acoust., Speech, Signal Process.,
26(6), 575-582.  <a href="https://doi.org/10.1109/TASSP.1978.1163164">doi:10.1109/TASSP.1978.1163164</a>
</p>
</li>
<li><p> Muller M. <em>Dynamic Time
Warping</em> in <em>Information Retrieval for Music and Motion</em>. Springer
Berlin Heidelberg; 2007. p. 69-84. <a href="https://doi.org/10.1007/978-3-540-74048-3_4">doi:10.1007/978-3-540-74048-3_4</a>
</p>
</li></ol>



<h3>See Also</h3>

<p><code><a href="#topic+dtwDist">dtwDist()</a></code>, for iterating dtw over a set of timeseries;
<code><a href="#topic+dtwWindowingFunctions">dtwWindowingFunctions()</a></code>, for windowing and global constraints;
<code><a href="#topic+stepPattern">stepPattern()</a></code>, step patterns and local constraints;
<code><a href="#topic+plot.dtw">plot.dtw()</a></code>, plot methods for DTW objects.  To generate a local
cost matrix, the functions <code><a href="proxy.html#topic+dist">proxy::dist()</a></code>,
<code>analogue::distance()</code>, <code>vegan::vegdist()</code>, or <code><a href="base.html#topic+outer">outer()</a></code> may come handy.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## A noisy sine wave as query
idx&lt;-seq(0,6.28,len=100);
query&lt;-sin(idx)+runif(100)/10;

## A cosine is for reference; sin and cos are offset by 25 samples
reference&lt;-cos(idx)
plot(reference); lines(query,col="blue");

## Find the best match
alignment&lt;-dtw(query,reference);


## Display the mapping, AKA warping function - may be multiple-valued
## Equivalent to: plot(alignment,type="alignment")
plot(alignment$index1,alignment$index2,main="Warping function");

## Confirm: 25 samples off-diagonal alignment
lines(1:100-25,col="red")




#########
##
## Partial alignments are allowed.
##

alignmentOBE &lt;-
  dtw(query[44:88],reference,
      keep=TRUE,step=asymmetric,
      open.end=TRUE,open.begin=TRUE);
plot(alignmentOBE,type="two",off=1);


#########
##
## Subsetting allows warping and unwarping of
## timeseries according to the warping curve. 
## See first example below.
##

## Most useful: plot the warped query along with reference 
plot(reference)
lines(query[alignment$index1]~alignment$index2,col="blue")

## Plot the (unwarped) query and the inverse-warped reference
plot(query,type="l",col="blue")
points(reference[alignment$index2]~alignment$index1)



#########
##
## Contour plots of the cumulative cost matrix
##    similar to: plot(alignment,type="density") or
##                dtwPlotDensity(alignment)
## See more plots in ?plot.dtw 
##

## keep = TRUE so we can look into the cost matrix

alignment&lt;-dtw(query,reference,keep=TRUE);

contour(alignment$costMatrix,col=terrain.colors(100),x=1:100,y=1:100,
	xlab="Query (noisy sine)",ylab="Reference (cosine)");

lines(alignment$index1,alignment$index2,col="red",lwd=2);




#########
##
## An hand-checkable example
##

ldist&lt;-matrix(1,nrow=6,ncol=6);  # Matrix of ones
ldist[2,]&lt;-0; ldist[,5]&lt;-0;      # Mark a clear path of zeroes
ldist[2,5]&lt;-.01;		 # Forcely cut the corner

ds&lt;-dtw(ldist);			 # DTW with user-supplied local
                                 #   cost matrix
da&lt;-dtw(ldist,step=asymmetric);	 # Also compute the asymmetric 
plot(ds$index1,ds$index2,pch=3); # Symmetric: alignment follows
                                 #   the low-distance marked path
points(da$index1,da$index2,col="red");  # Asymmetric: visiting
                                        #   1 is required twice

ds$distance;
da$distance;




</code></pre>

<hr>
<h2 id='dtw-internal'>Internal dtw Functions</h2><span id='topic+dtw-internal'></span><span id='topic+backtrack'></span><span id='topic+dtwpairdist'></span><span id='topic+globalCostMatrix'></span>

<h3>Description</h3>

<p>Internal dtw functions
</p>


<h3>Details</h3>

<p>These are not to be called by the user. Frontend to the DTW package is the
<code><a href="#topic+dtw">dtw()</a></code> function.
</p>

<hr>
<h2 id='dtw-package'>Comprehensive implementation of Dynamic Time Warping (DTW) algorithms in R.</h2><span id='topic+dtw-package'></span>

<h3>Description</h3>

<p>The DTW algorithm computes the stretch of the time axis which optimally maps
one given timeseries (query) onto whole or part of another (reference). It
yields the remaining cumulative distance after the alignment and the
point-by-point correspondence (warping function). DTW is widely used e.g.
for classification and clustering tasks in econometrics, chemometrics and
general timeseries mining.
</p>


<h3>Details</h3>

<p>Please see documentation for function <code><a href="#topic+dtw">dtw()</a></code>, which is the main
entry point to the package.
</p>
<p>The R implementation in dtw provides:
</p>

<ul>
<li><p> arbitrary windowing functions (global constraints), eg. the
Sakoe-Chiba band; see <code><a href="#topic+dtwWindowingFunctions">dtwWindowingFunctions()</a></code>
</p>
</li>
<li><p> arbitrary
transition types (also known as step patterns, slope constraints, local
constraints, or DP-recursion rules). This includes dozens of well-known
types; see <code><a href="#topic+stepPattern">stepPattern()</a></code>:
</p>

<ul>
<li><p> all step patterns classified by Rabiner-Juang, Sakoe-Chiba, and Rabiner-Myers;
</p>
</li>
<li><p> symmetric and asymmetric;
</p>
</li>
<li><p> Rabiner's smoothed variants;
</p>
</li>
<li><p> arbitrary, user-defined slope constraints
</p>
</li></ul>

</li>
<li><p> partial matches: open-begin, open-end, substring matches
</p>
</li>
<li><p> proper, pattern-dependent, normalization (exact average distance per step)
</p>
</li>
<li><p> the Minimum Variance Matching (MVM) algorithm (Latecki et al.)
</p>
</li></ul>

<p>Multivariate timeseries can be aligned with arbitrary local distance
definitions, leveraging the <code><a href="proxy.html#topic+dist">proxy::dist()</a></code> function of package
<a href="https://CRAN.R-project.org/package=proxy"><span class="pkg">proxy</span></a>. DTW itself becomes a distance function with the dist semantics.
</p>
<p>In addition to computing alignments, the package provides:
</p>

<ul>
<li><p> methods for plotting alignments and warping functions in several classic
styles (see plot gallery);
</p>
</li>
<li><p> graphical representation of step patterns;
</p>
</li>
<li><p> functions for applying a warping function, either direct or inverse;
and more.
</p>
</li></ul>

<p>If you use this software, please cite it according to
<code>citation("dtw")</code>.  The package home page is at
<a href="https://dynamictimewarping.github.io">https://dynamictimewarping.github.io</a>.
</p>


<h3>Author(s)</h3>

<p>Toni Giorgino
</p>


<h3>References</h3>


<ul>
<li><p> Toni Giorgino. <em>Computing and Visualizing Dynamic Time
Warping Alignments in R: The dtw Package.</em> Journal of Statistical Software,
31(7), 1-24. <a href="https://doi.org/10.18637/jss.v031.i07">doi:10.18637/jss.v031.i07</a>
</p>
</li>
<li><p> Tormene, P.; Giorgino, T.; Quaglini, S. &amp; Stefanelli, M. <em>Matching incomplete time
series with dynamic time warping: an algorithm and an application to
post-stroke rehabilitation.</em> Artif Intell Med, 2009, 45, 11-34
<a href="https://doi.org/10.1016/j.artmed.2008.11.007">doi:10.1016/j.artmed.2008.11.007</a>
</p>
</li>
<li><p> Rabiner, L. R., &amp; Juang, B.-H. (1993). Chapter 4 in <em>Fundamentals of
speech recognition.</em> Englewood Cliffs, NJ: Prentice Hall.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+dtw">dtw()</a></code> for the main entry point to the package;
<code><a href="#topic+dtwWindowingFunctions">dtwWindowingFunctions()</a></code> for global constraints;
<code><a href="#topic+stepPattern">stepPattern()</a></code> for local constraints;
<code><a href="proxy.html#topic+dist">proxy::dist()</a></code>, <code>analogue::distance()</code>, <code>vegan::vegdist()</code> to build local
cost matrices for multivariate timeseries and custom distance functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 library(dtw);
 ## demo(dtw);

</code></pre>

<hr>
<h2 id='dtwDist'>Compute a dissimilarity matrix</h2><span id='topic+dtwDist'></span>

<h3>Description</h3>

<p>Compute the dissimilarity matrix between a set of single-variate timeseries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtwDist(mx, my = mx, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dtwDist_+3A_mx">mx</code></td>
<td>
<p>numeric matrix, containing timeseries as rows</p>
</td></tr>
<tr><td><code id="dtwDist_+3A_my">my</code></td>
<td>
<p>numeric matrix, containing timeseries as rows (for cross-distance)</p>
</td></tr>
<tr><td><code id="dtwDist_+3A_...">...</code></td>
<td>
<p>arguments passed to the <code><a href="#topic+dtw">dtw()</a></code> call</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dtwDist</code> computes a dissimilarity matrix, akin to <code><a href="stats.html#topic+dist">dist()</a></code>,
based on the Dynamic Time Warping definition of a distance between
single-variate timeseries.
</p>
<p>The <code>dtwDist</code> command is a synonym for the <code><a href="proxy.html#topic+dist">proxy::dist()</a></code>
function of package <a href="https://CRAN.R-project.org/package=proxy"><span class="pkg">proxy</span></a>; the DTW distance is registered as
<code>method="DTW"</code> (see examples below).
</p>
<p>The timeseries are stored as rows in the matrix argument <code>m</code>. In other
words, if <code>m</code> is an N * T matrix, <code>dtwDist</code> will build N<em>N ordered
pairs of timeseries, perform the corresponding N</em>N <code>dtw</code> alignments,
and return all of the results in a matrix. Each of the timeseries is T
elements long.
</p>
<p><code>dtwDist</code> returns a square matrix, whereas the <code>dist</code> object is
lower-triangular. This makes sense because in general the DTW &quot;distance&quot; is
not symmetric (see e.g.  asymmetric step patterns).  To make a square matrix
with the <code><a href="proxy.html#topic+dist">proxy::dist()</a></code> function semantics, use the two-arguments
call as <code>dist(m,m)</code>. This will return a square <code>crossdist</code> object.
</p>


<h3>Value</h3>

<p>A square matrix whose element <code style="white-space: pre;">&#8288;[i,j]&#8288;</code> holds the Dynamic Time
Warp distance between row <code>i</code> (query) and <code>j</code> (reference) of
<code>mx</code> and <code>my</code>, i.e.  <code>dtw(mx[i,],my[j,])$distance</code>.
</p>


<h3>Note</h3>

<p>To convert a square cross-distance matrix (<code>crossdist</code> object) to
a symmetric <code><a href="stats.html#topic+dist">dist()</a></code> object, use a suitable conversion strategy
(see examples).
</p>


<h3>Author(s)</h3>

<p>Toni Giorgino
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Symmetric step pattern =&gt; symmetric dissimilarity matrix;
## no problem coercing it to a dist object:

m &lt;- matrix(0,ncol=3,nrow=4)
m &lt;- row(m)
dist(m,method="DTW");

# Old-fashioned call style would be:
#   dtwDist(m)
#   as.dist(dtwDist(m))



## Find the optimal warping _and_ scale factor at the same time.
## (There may be a better, analytic way)

# Prepare a query and a reference

query&lt;-sin(seq(0,4*pi,len=100))
reference&lt;-cos(seq(0,4*pi,len=100))

# Make a set of several references, scaled from 0 to 3 in .1 increments.
# Put them in a matrix, in rows

scaleSet &lt;- seq(0.1,3,by=.1)
referenceSet&lt;-outer(1/scaleSet,reference)

# The query has to be made into a 1-row matrix.
# Perform all of the alignments at once, and normalize the result.

dist(t(query),referenceSet,meth="DTW")-&gt;distanceSet

# The optimal scale for the reference is 1.0
plot(scaleSet,scaleSet*distanceSet,
  xlab="Reference scale factor (denominator)",
  ylab="DTW distance",type="o",
  main="Sine vs scaled cosine alignment, 0 to 4 pi")





## Asymmetric step pattern: we can either disregard part of the pairs
## (as.dist), or average with the transpose

mm &lt;- matrix(runif(12),ncol=3)
dm &lt;- dist(mm,mm,method="DTW",step=asymmetric); # a crossdist object

# Old-fashioned call style would be:
#   dm &lt;- dtwDist(mm,step=asymmetric)
#   as.dist(dm)


## Symmetrize by averaging:
(dm+t(dm))/2


## check definition
stopifnot(dm[2,1]==dtw(mm[2,],mm[1,],step=asymmetric)$distance)



</code></pre>

<hr>
<h2 id='dtwPlot'>Plotting of dynamic time warp results</h2><span id='topic+dtwPlot'></span><span id='topic+plot.dtw'></span><span id='topic+dtwPlotAlignment'></span>

<h3>Description</h3>

<p>Methods for plotting dynamic time warp alignment objects returned by
<code><a href="#topic+dtw">dtw()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dtw'
plot(x, type = "alignment", ...)

dtwPlotAlignment(
  d,
  xlab = "Query index",
  ylab = "Reference index",
  plot.type = "l",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dtwPlot_+3A_x">x</code>, <code id="dtwPlot_+3A_d">d</code></td>
<td>
<p><code>dtw</code> object, usually result of call to <code><a href="#topic+dtw">dtw()</a></code></p>
</td></tr>
<tr><td><code id="dtwPlot_+3A_type">type</code></td>
<td>
<p>general style for the plot, see below</p>
</td></tr>
<tr><td><code id="dtwPlot_+3A_...">...</code></td>
<td>
<p>additional arguments, passed to plotting functions</p>
</td></tr>
<tr><td><code id="dtwPlot_+3A_xlab">xlab</code></td>
<td>
<p>label for the query axis</p>
</td></tr>
<tr><td><code id="dtwPlot_+3A_ylab">ylab</code></td>
<td>
<p>label for the reference axis</p>
</td></tr>
<tr><td><code id="dtwPlot_+3A_plot.type">plot.type</code></td>
<td>
<p>type of line to be drawn, used as the <code>type</code> argument
in the underlying <code>plot</code> call</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dtwPlot</code> displays alignment contained in <code>dtw</code> objects.
</p>
<p>Various plotting styles are available, passing strings to the <code>type</code>
argument (may be abbreviated):
</p>

<ul>
<li> <p><code>alignment</code> plots the warping curve in <code>d</code>;
</p>
</li>
<li> <p><code>twoway</code> plots a point-by-point comparison, with matching lines; see <code><a href="#topic+dtwPlotTwoWay">dtwPlotTwoWay()</a></code>;
</p>
</li>
<li> <p><code>threeway</code> vis-a-vis inspection of the timeseries and their warping curve; see <code><a href="#topic+dtwPlotThreeWay">dtwPlotThreeWay()</a></code>;
</p>
</li>
<li> <p><code>density</code> displays the cumulative cost landscape with the warping path overimposed; see <code><a href="#topic+dtwPlotDensity">dtwPlotDensity()</a></code>
</p>
</li></ul>

<p>Additional parameters are passed to the plotting functions: use with
care.
</p>


<h3>Warning</h3>

<p>These functions are incompatible with mechanisms for
arranging plots on a device: <code>par(mfrow)</code>, <code>layout</code> and
<code>split.screen</code>.
</p>


<h3>Author(s)</h3>

<p>Toni Giorgino
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dtwPlotTwoWay">dtwPlotTwoWay()</a></code>, <code><a href="#topic+dtwPlotThreeWay">dtwPlotThreeWay()</a></code> and  <code><a href="#topic+dtwPlotDensity">dtwPlotDensity()</a></code> for details
on the respective plotting styles.
</p>
<p>Other plot: 
<code><a href="#topic+dtwPlotDensity">dtwPlotDensity</a>()</code>,
<code><a href="#topic+dtwPlotThreeWay">dtwPlotThreeWay</a>()</code>,
<code><a href="#topic+dtwPlotTwoWay">dtwPlotTwoWay</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Same example as in dtw

idx&lt;-seq(0,6.28,len=100);
query&lt;-sin(idx)+runif(100)/10;
reference&lt;-cos(idx)

alignment&lt;-dtw(query,reference,keep=TRUE);

# A sample of the plot styles. See individual plotting functions for details

plot(alignment, type="alignment",
  main="DTW sine/cosine: simple alignment plot")
  
plot(alignment, type="twoway",
  main="DTW sine/cosine: dtwPlotTwoWay")

plot(alignment, type="threeway",
  main="DTW sine/cosine: dtwPlotThreeWay")
  
plot(alignment, type="density",
  main="DTW sine/cosine: dtwPlotDensity")
  
</code></pre>

<hr>
<h2 id='dtwPlotDensity'>Display the cumulative cost density with the warping path overimposed</h2><span id='topic+dtwPlotDensity'></span>

<h3>Description</h3>

<p>The plot is based on the cumulative cost matrix. It displays the optimal alignment
as a &quot;ridge&quot; in the global cost landscape.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtwPlotDensity(
  d,
  normalize = FALSE,
  xlab = "Query index",
  ylab = "Reference index",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dtwPlotDensity_+3A_d">d</code></td>
<td>
<p>an alignment result, object of class <code>dtw</code></p>
</td></tr>
<tr><td><code id="dtwPlotDensity_+3A_normalize">normalize</code></td>
<td>
<p>show per-step average cost instead of cumulative cost</p>
</td></tr>
<tr><td><code id="dtwPlotDensity_+3A_xlab">xlab</code></td>
<td>
<p>label for the query axis</p>
</td></tr>
<tr><td><code id="dtwPlotDensity_+3A_ylab">ylab</code></td>
<td>
<p>label for the reference axis</p>
</td></tr>
<tr><td><code id="dtwPlotDensity_+3A_...">...</code></td>
<td>
<p>additional parameters forwarded to plotting functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The alignment must have been
constructed with the <code>keep.internals=TRUE</code> parameter set.
</p>
<p>If <code>normalize</code> is <code>TRUE</code>, the <em>average</em> cost per step is
plotted instead of the cumulative one. Step averaging depends on the
<code><a href="#topic+stepPattern">stepPattern()</a></code> used.
</p>


<h3>See Also</h3>

<p>Other plot: 
<code><a href="#topic+dtwPlotThreeWay">dtwPlotThreeWay</a>()</code>,
<code><a href="#topic+dtwPlotTwoWay">dtwPlotTwoWay</a>()</code>,
<code><a href="#topic+dtwPlot">dtwPlot</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## A study of the "Itakura" parallelogram
##
## A widely held misconception is that the "Itakura parallelogram" (as
## described in the original article) is a global constraint.  Instead,
## it arises from local slope restrictions. Anyway, an "itakuraWindow",
## is provided in this package. A comparison between the two follows.

## The local constraint: three sides of the parallelogram are seen
idx&lt;-seq(0,6.28,len=100);
query&lt;-sin(idx)+runif(100)/10;
reference&lt;-cos(idx)

ita &lt;- dtw(query,reference,keep=TRUE,step=typeIIIc)
dtwPlotDensity(ita, main="Slope-limited asymmetric step (Itakura)")

## Symmetric step with global parallelogram-shaped constraint. Note how
## long (&gt;2 steps) horizontal stretches are allowed within the window.

dtw(query,reference,keep=TRUE,window=itakuraWindow)-&gt;ita;
dtwPlotDensity(ita,
        main="Symmetric step with Itakura parallelogram window")

</code></pre>

<hr>
<h2 id='dtwPlotThreeWay'>Plotting of dynamic time warp results: annotated warping function</h2><span id='topic+dtwPlotThreeWay'></span>

<h3>Description</h3>

<p>Display the query and reference time series and their warping curve,
arranged for visual inspection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtwPlotThreeWay(
  d,
  xts = NULL,
  yts = NULL,
  type.align = "l",
  type.ts = "l",
  match.indices = NULL,
  margin = 4,
  inner.margin = 0.2,
  title.margin = 1.5,
  xlab = "Query index",
  ylab = "Reference index",
  main = "Timeseries alignment",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dtwPlotThreeWay_+3A_d">d</code></td>
<td>
<p>an alignment result, object of class <code>dtw</code></p>
</td></tr>
<tr><td><code id="dtwPlotThreeWay_+3A_xts">xts</code></td>
<td>
<p>query vector</p>
</td></tr>
<tr><td><code id="dtwPlotThreeWay_+3A_yts">yts</code></td>
<td>
<p>reference vector</p>
</td></tr>
<tr><td><code id="dtwPlotThreeWay_+3A_type.align">type.align</code></td>
<td>
<p>line style for warping curve plot</p>
</td></tr>
<tr><td><code id="dtwPlotThreeWay_+3A_type.ts">type.ts</code></td>
<td>
<p>line style for timeseries plot</p>
</td></tr>
<tr><td><code id="dtwPlotThreeWay_+3A_match.indices">match.indices</code></td>
<td>
<p>indices for which to draw a visual guide</p>
</td></tr>
<tr><td><code id="dtwPlotThreeWay_+3A_margin">margin</code></td>
<td>
<p>outer figure margin</p>
</td></tr>
<tr><td><code id="dtwPlotThreeWay_+3A_inner.margin">inner.margin</code></td>
<td>
<p>inner figure margin</p>
</td></tr>
<tr><td><code id="dtwPlotThreeWay_+3A_title.margin">title.margin</code></td>
<td>
<p>space on the top of figure</p>
</td></tr>
<tr><td><code id="dtwPlotThreeWay_+3A_xlab">xlab</code></td>
<td>
<p>label for the query axis</p>
</td></tr>
<tr><td><code id="dtwPlotThreeWay_+3A_ylab">ylab</code></td>
<td>
<p>label for the reference axis</p>
</td></tr>
<tr><td><code id="dtwPlotThreeWay_+3A_main">main</code></td>
<td>
<p>main title</p>
</td></tr>
<tr><td><code id="dtwPlotThreeWay_+3A_...">...</code></td>
<td>
<p>additional arguments, used for the warping curve</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The query time series is plotted in the bottom panel, with indices growing
rightwards and values upwards. Reference is in the left panel, indices
growing upwards and values leftwards. The warping curve panel matches
indices, and therefore element (1,1) will be at the lower left, (N,M) at the
upper right.
</p>
<p>Argument <code>match.indices</code> is used to draw a visual guide to matches; if
a vector is given, guides are drawn for the corresponding indices in the
warping curve (match lines). If integer, it is used as the number of guides
to be plotted. The corresponding style is customized via the
<code>match.col</code> and <code>match.lty</code> arguments.
</p>
<p>If <code>xts</code> and <code>yts</code> are not supplied, they will be recovered from
<code>d</code>, as long as it was created with the two-argument call of
<code><a href="#topic+dtw">dtw()</a></code> with <code>keep.internals=TRUE</code>.  Only single-variate time
series can be plotted.
</p>


<h3>Warning</h3>

<p>The function is incompatible with mechanisms for arranging
plots on a device: <code>par(mfrow)</code>, <code>layout</code> and <code>split.screen</code>.
Appearance of the match lines and timeseries currently can not be
customized.
</p>


<h3>Author(s)</h3>

<p>Toni Giorgino
</p>


<h3>See Also</h3>

<p>Other plot: 
<code><a href="#topic+dtwPlotDensity">dtwPlotDensity</a>()</code>,
<code><a href="#topic+dtwPlotTwoWay">dtwPlotTwoWay</a>()</code>,
<code><a href="#topic+dtwPlot">dtwPlot</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## A noisy sine wave as query
## A cosine is for reference; sin and cos are offset by 25 samples

idx&lt;-seq(0,6.28,len=100);
query&lt;-sin(idx)+runif(100)/10;
reference&lt;-cos(idx)
dtw(query,reference,keep=TRUE)-&gt;alignment;


## Beware of the reference's y axis, may be confusing
## Equivalent to plot(alignment,type="three");
dtwPlotThreeWay(alignment);


## Highlight matches of chosen QUERY indices. We will do some index
## arithmetics to recover the corresponding indices along the warping
## curve

hq &lt;- (0:8)/8              
hq &lt;- round(hq*100)      #  indices in query for  pi/4 .. 7/4 pi

hw &lt;- (alignment$index1 %in% hq)   # where are they on the w. curve?
hi &lt;- (1:length(alignment$index1))[hw];   # get the indices of TRUE elems

dtwPlotThreeWay(alignment,match.indices=hi);

</code></pre>

<hr>
<h2 id='dtwPlotTwoWay'>Plotting of dynamic time warp results: pointwise comparison</h2><span id='topic+dtwPlotTwoWay'></span>

<h3>Description</h3>

<p>Display the query and reference time series and their alignment, arranged
for visual inspection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtwPlotTwoWay(
  d,
  xts = NULL,
  yts = NULL,
  offset = 0,
  ts.type = "l",
  pch = 21,
  match.indices = NULL,
  match.col = "gray70",
  match.lty = 3,
  xlab = "Index",
  ylab = "Query value",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dtwPlotTwoWay_+3A_d">d</code></td>
<td>
<p>an alignment result, object of class <code>dtw</code></p>
</td></tr>
<tr><td><code id="dtwPlotTwoWay_+3A_xts">xts</code></td>
<td>
<p>query vector</p>
</td></tr>
<tr><td><code id="dtwPlotTwoWay_+3A_yts">yts</code></td>
<td>
<p>reference vector</p>
</td></tr>
<tr><td><code id="dtwPlotTwoWay_+3A_offset">offset</code></td>
<td>
<p>displacement between the timeseries, summed to reference</p>
</td></tr>
<tr><td><code id="dtwPlotTwoWay_+3A_ts.type">ts.type</code>, <code id="dtwPlotTwoWay_+3A_pch">pch</code></td>
<td>
<p>graphical parameters for timeseries plotting, passed to
<code>matplot</code></p>
</td></tr>
<tr><td><code id="dtwPlotTwoWay_+3A_match.indices">match.indices</code></td>
<td>
<p>indices for which to draw a visual guide</p>
</td></tr>
<tr><td><code id="dtwPlotTwoWay_+3A_match.col">match.col</code>, <code id="dtwPlotTwoWay_+3A_match.lty">match.lty</code></td>
<td>
<p>color and line type of the match guide lines</p>
</td></tr>
<tr><td><code id="dtwPlotTwoWay_+3A_xlab">xlab</code>, <code id="dtwPlotTwoWay_+3A_ylab">ylab</code></td>
<td>
<p>axis labels</p>
</td></tr>
<tr><td><code id="dtwPlotTwoWay_+3A_...">...</code></td>
<td>
<p>additional arguments, passed to <code>matplot</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The two vectors are displayed via the <code><a href="graphics.html#topic+matplot">matplot()</a></code> functions; their
appearance can be customized via the <code>type</code> and <code>pch</code> arguments
(constants or vectors of two elements).  If <code>offset</code> is set, the
reference is shifted vertically by the given amount; this will be reflected
by the <em>right-hand</em> axis.
</p>
<p>Argument <code>match.indices</code> is used to draw a visual guide to matches; if
a vector is given, guides are drawn for the corresponding indices in the
warping curve (match lines). If integer, it is used as the number of guides
to be plotted. The corresponding style is customized via the
<code>match.col</code> and <code>match.lty</code> arguments.
</p>
<p>If <code>xts</code> and <code>yts</code> are not supplied, they will be recovered from
<code>d</code>, as long as it was created with the two-argument call of
<code><a href="#topic+dtw">dtw()</a></code> with <code>keep.internals=TRUE</code>.  Only single-variate time
series can be plotted this way.
</p>


<h3>Warning</h3>

<p>The function is incompatible with mechanisms for arranging
plots on a device: <code>par(mfrow)</code>, <code>layout</code> and <code>split.screen</code>.
</p>


<h3>Note</h3>

<p>When <code>offset</code> is set values on the left axis only apply to the
query.
</p>


<h3>Author(s)</h3>

<p>Toni Giorgino
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dtwPlot">dtwPlot()</a></code> for other dtw plotting functions,
<code><a href="graphics.html#topic+matplot">matplot()</a></code> for graphical parameters.
</p>
<p>Other plot: 
<code><a href="#topic+dtwPlotDensity">dtwPlotDensity</a>()</code>,
<code><a href="#topic+dtwPlotThreeWay">dtwPlotThreeWay</a>()</code>,
<code><a href="#topic+dtwPlot">dtwPlot</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## A noisy sine wave as query
## A cosine is for reference; sin and cos are offset by 25 samples

idx&lt;-seq(0,6.28,len=100);
query&lt;-sin(idx)+runif(100)/10;
reference&lt;-cos(idx)
dtw(query,reference,step=asymmetricP1,keep=TRUE)-&gt;alignment;


## Equivalent to plot(alignment,type="two");
dtwPlotTwoWay(alignment);


## Highlight matches of chosen QUERY indices. We will do some index
## arithmetics to recover the corresponding indices along the warping
## curve

hq &lt;- (0:8)/8              
hq &lt;- round(hq*100)      #  indices in query for  pi/4 .. 7/4 pi

hw &lt;- (alignment$index1 %in% hq)   # where are they on the w. curve?
hi &lt;- (1:length(alignment$index1))[hw];   # get the indices of TRUE elems


## Beware of the reference's y axis, may be confusing
plot(alignment,offset=-2,type="two", lwd=3, match.col="grey50",
     match.indices=hi,main="Match lines shown every pi/4 on query");

legend("topright",c("Query","Reference (rt. axis)"), pch=21, col=1:6)



</code></pre>

<hr>
<h2 id='dtwWindowingFunctions'>Global constraints and windowing functions for DTW</h2><span id='topic+dtwWindowingFunctions'></span><span id='topic+noWindow'></span><span id='topic+sakoeChibaWindow'></span><span id='topic+slantedBandWindow'></span><span id='topic+itakuraWindow'></span><span id='topic+dtwWindow.plot'></span>

<h3>Description</h3>

<p>Various global constraints (windows) which can be applied to the
<code>window.type</code> argument of <code><a href="#topic+dtw">dtw()</a></code>, including the Sakoe-Chiba
band, the Itakura parallelogram, and custom functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sakoeChibaWindow(iw, jw, window.size, ...)

slantedBandWindow(iw, jw, query.size, reference.size, window.size, ...)

itakuraWindow(iw, jw, query.size, reference.size, ...)

dtwWindow.plot(fun, query.size = 200, reference.size = 220, ...)

noWindow(iw, jw, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dtwWindowingFunctions_+3A_iw">iw</code></td>
<td>
<p>index in the query (row) &ndash; automatically set</p>
</td></tr>
<tr><td><code id="dtwWindowingFunctions_+3A_jw">jw</code></td>
<td>
<p>index in the reference (column) &ndash; automatically set</p>
</td></tr>
<tr><td><code id="dtwWindowingFunctions_+3A_window.size">window.size</code></td>
<td>
<p>window size, used by some windowing functions &ndash; must be
set</p>
</td></tr>
<tr><td><code id="dtwWindowingFunctions_+3A_...">...</code></td>
<td>
<p>additional arguments passed to windowing functions</p>
</td></tr>
<tr><td><code id="dtwWindowingFunctions_+3A_query.size">query.size</code></td>
<td>
<p>size of the query time series &ndash; automatically set</p>
</td></tr>
<tr><td><code id="dtwWindowingFunctions_+3A_reference.size">reference.size</code></td>
<td>
<p>size of the reference time series &ndash; automatically set</p>
</td></tr>
<tr><td><code id="dtwWindowingFunctions_+3A_fun">fun</code></td>
<td>
<p>a windowing function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Windowing functions can be passed to the <code>window.type</code> argument in
<code><a href="#topic+dtw">dtw()</a></code> to put a global constraint to the warping paths allowed.
They take two integer arguments (plus optional parameters) and must return a
boolean value <code>TRUE</code> if the coordinates fall within the allowed region
for warping paths, <code>FALSE</code> otherwise.
</p>
<p>User-defined functions can read variables <code>reference.size</code>,
<code>query.size</code> and <code>window.size</code>; these are pre-set upon invocation.
Some functions require additional parameters which must be set (e.g.
<code>window.size</code>).  User-defined functions are free to implement any
window shape, as long as at least one path is allowed between the initial
and final alignment points, i.e., they are compatible with the DTW
constraints.
</p>
<p>The <code>sakoeChibaWindow</code> function implements the Sakoe-Chiba band, i.e.
<code>window.size</code> elements around the <code>main</code> diagonal. If the window
size is too small, i.e. if <code>reference.size</code>-<code>query.size</code> &gt;
<code>window.size</code>, warping becomes impossible.
</p>
<p>An <code>itakuraWindow</code> global constraint is still provided with this
package.  See example below for a demonstration of the difference between a
local the two.
</p>
<p>The <code>slantedBandWindow</code> (package-specific) is a band centered around
the (jagged) line segment which joins element <code style="white-space: pre;">&#8288;[1,1]&#8288;</code> to element
<code style="white-space: pre;">&#8288;[query.size,reference.size]&#8288;</code>, and will be <code>window.size</code> columns
wide. In other words, the &quot;diagonal&quot; goes from one corner to the other of
the possibly rectangular cost matrix, therefore having a slope of
<code>M/N</code>, not 1.
</p>
<p><code>dtwWindow.plot</code> visualizes a windowing function. By default it plots a
200 x 220 rectangular region, which can be changed via <code>reference.size</code>
and <code>query.size</code> arguments.
</p>


<h3>Value</h3>

<p>Windowing functions return <code>TRUE</code> if the coordinates passed as
arguments fall within the chosen warping window, <code>FALSE</code> otherwise.
User-defined functions should do the same.
</p>


<h3>Note</h3>

<p>Although <code>dtwWindow.plot</code> resembles object-oriented notation,
there is not a such a dtwWindow class currently.
</p>
<p>A widely held misconception is that the &quot;Itakura parallelogram&quot; (as
described in reference 2) is a <em>global</em> constraint, i.e. a window.
To the author's knowledge, it instead arises from the local slope
restrictions imposed to the warping path, such as the one implemented by the
<code><a href="#topic+typeIIIc">typeIIIc()</a></code> step pattern.
</p>


<h3>Author(s)</h3>

<p>Toni Giorgino
</p>


<h3>References</h3>


<ol>
<li><p> Sakoe, H.; Chiba, S., <em>Dynamic programming algorithm
optimization for spoken word recognition,</em> Acoustics, Speech, and Signal
Processing, IEEE Transactions on , vol.26, no.1, pp. 43-49, Feb 1978
<a href="https://doi.org/10.1109/TASSP.1978.1163055">doi:10.1109/TASSP.1978.1163055</a>
</p>
</li>
<li><p> Itakura, F., <em>Minimum prediction residual principle applied to
speech recognition,</em> Acoustics, Speech, and Signal Processing,
IEEE Transactions on , vol.23, no.1, pp.
67-72, Feb 1975. <a href="https://doi.org/10.1109/TASSP.1975.1162641">doi:10.1109/TASSP.1975.1162641</a>
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>

## Display some windowing functions
dtwWindow.plot(itakuraWindow, main="So-called Itakura parallelogram window")
dtwWindow.plot(slantedBandWindow, window.size=2,
  reference=13, query=17, main="The slantedBandWindow at window.size=2")


## Asymmetric step with Sakoe-Chiba band

idx&lt;-seq(0,6.28,len=100); 
query&lt;-sin(idx)+runif(100)/10;
reference&lt;-cos(idx);

asyband&lt;-dtw(query,reference,keep=TRUE,
             step=asymmetric,
             window.type=sakoeChibaWindow,
             window.size=30                  );

dtwPlot(asyband,type="density",main="Sine/cosine: asymmetric step, S-C window")



</code></pre>

<hr>
<h2 id='mvm'>Minimum Variance Matching algorithm</h2><span id='topic+mvm'></span><span id='topic+mvmStepPattern'></span>

<h3>Description</h3>

<p>Step patterns to compute the Minimum Variance Matching (MVM) correspondence
between time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvmStepPattern(elasticity = 20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvm_+3A_elasticity">elasticity</code></td>
<td>
<p>integer: maximum consecutive reference elements skippable</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Minimum Variance Matching algorithm (1) finds the non-contiguous parts
of reference which best match the query, allowing for arbitrarily long
&quot;stretches&quot; of reference to be excluded from the match. All elements of the
query have to be matched. First and last elements of the query are anchored
at the boundaries of the reference.
</p>
<p>The <code>mvmStepPattern</code> function creates a <code>stepPattern</code> object which
implements this behavior, to be used with the usual <code><a href="#topic+dtw">dtw()</a></code> call
(see example). MVM is computed as a special case of DTW, with a very large,
asymmetric-like step pattern.
</p>
<p>The <code>elasticity</code> argument limits the maximum run length of reference
which can be skipped at once. If no limit is desired, set <code>elasticity</code>
to an integer at least as large as the reference (computation time grows
linearly).
</p>


<h3>Value</h3>

<p>A step pattern object.
</p>


<h3>Author(s)</h3>

<p>Toni Giorgino
</p>


<h3>References</h3>

<p>Latecki, L. J.; Megalooikonomou, V.; Wang, Q. &amp; Yu, D.
<em>An elastic partial shape matching technique</em> Pattern Recognition,
2007, 40, 3069-3080. <a href="https://doi.org/10.1016/j.patcog.2007.03.004">doi:10.1016/j.patcog.2007.03.004</a>
</p>


<h3>See Also</h3>

<p>Other objects in <code><a href="#topic+stepPattern">stepPattern()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## The hand-checkable example given in Fig. 5, ref. [1] above
diffmx &lt;- matrix( byrow=TRUE, nrow=5, c(
  0,  1,  8,  2,  2,  4,  8,
  1,  0,  7,  1,  1,  3,  7,
 -7, -6,  1, -5, -5, -3,  1,
 -5, -4,  3, -3, -3, -1,  3,
 -7, -6,  1, -5, -5, -3,  1 ) ) ;

## Cost matrix
costmx &lt;- diffmx^2;

## Compute the alignment
al &lt;- dtw(costmx,step.pattern=mvmStepPattern(10))

## Elements 4,5 are skipped
print(al$index2)

plot(al,main="Minimum Variance Matching alignment")



</code></pre>

<hr>
<h2 id='stepPattern'>Step patterns for DTW</h2><span id='topic+stepPattern'></span><span id='topic+is.stepPattern'></span><span id='topic+print.stepPattern'></span><span id='topic+t.stepPattern'></span><span id='topic+plot.stepPattern'></span><span id='topic+symmetric1'></span><span id='topic+symmetric2'></span><span id='topic+asymmetric'></span><span id='topic+rabinerJuangStepPattern'></span><span id='topic+symmetricP0'></span><span id='topic+asymmetricP0'></span><span id='topic+symmetricP05'></span><span id='topic+asymmetricP05'></span><span id='topic+symmetricP1'></span><span id='topic+asymmetricP1'></span><span id='topic+symmetricP2'></span><span id='topic+asymmetricP2'></span><span id='topic+typeIa'></span><span id='topic+typeIas'></span><span id='topic+typeIb'></span><span id='topic+typeIbs'></span><span id='topic+typeIc'></span><span id='topic+typeIcs'></span><span id='topic+typeId'></span><span id='topic+typeIds'></span><span id='topic+typeIIa'></span><span id='topic+typeIIb'></span><span id='topic+typeIIc'></span><span id='topic+typeIId'></span><span id='topic+typeIIIc'></span><span id='topic+typeIVc'></span><span id='topic+mori2006'></span><span id='topic+rigid'></span>

<h3>Description</h3>

<p>A <code>stepPattern</code> object lists the transitions allowed while searching
for the minimum-distance path.  DTW variants are implemented by passing one
of the objects described in this page to the <code>stepPattern</code> argument of
the <code><a href="#topic+dtw">dtw()</a></code> call.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stepPattern'
t(x)

## S3 method for class 'stepPattern'
plot(x, ...)

## S3 method for class 'stepPattern'
print(x, ...)

rabinerJuangStepPattern(type, slope.weighting = "d", smoothed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stepPattern_+3A_x">x</code></td>
<td>
<p>a step pattern object</p>
</td></tr>
<tr><td><code id="stepPattern_+3A_...">...</code></td>
<td>
<p>additional arguments to <code><a href="base.html#topic+print">print()</a></code>.</p>
</td></tr>
<tr><td><code id="stepPattern_+3A_type">type</code></td>
<td>
<p>path specification, integer 1..7 (see (Rabiner1993), table 4.5)</p>
</td></tr>
<tr><td><code id="stepPattern_+3A_slope.weighting">slope.weighting</code></td>
<td>
<p>slope weighting rule: character <code>"a"</code> to <code>"d"</code> (see (Rabiner1993), sec. 4.7.2.5)</p>
</td></tr>
<tr><td><code id="stepPattern_+3A_smoothed">smoothed</code></td>
<td>
<p>logical, whether to use smoothing (see (Rabiner1993), fig. 4.44)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A step pattern characterizes the matching model and slope constraint
specific of a DTW variant. They also known as local- or slope-constraints,
transition types, production or recursion rules (GiorginoJSS).
</p>
<p><strong>Pre-defined step patterns</strong>
</p>
<div class="sourceCode"><pre>   ## Well-known step patterns
   symmetric1
   symmetric2
   asymmetric
   
   ## Step patterns classified according to Rabiner-Juang (Rabiner1993)
   rabinerJuangStepPattern(type,slope.weighting="d",smoothed=FALSE)
   
   ## Slope-constrained step patterns from Sakoe-Chiba (Sakoe1978)
   symmetricP0;  asymmetricP0
   symmetricP05; asymmetricP05
   symmetricP1;  asymmetricP1
   symmetricP2;  asymmetricP2
   
   ## Step patterns classified according to Rabiner-Myers (Myers1980)
   typeIa;   typeIb;   typeIc;   typeId;
   typeIas;  typeIbs;  typeIcs;  typeIds;  # smoothed
   typeIIa;  typeIIb;  typeIIc;  typeIId;
   typeIIIc; typeIVc;
   
   ## Miscellaneous
   mori2006;
   rigid;
</pre></div>
<p>A variety of classification schemes have been proposed for step patterns, including
Sakoe-Chiba (Sakoe1978); Rabiner-Juang (Rabiner1993); and Rabiner-Myers
(Myers1980).  The <code>dtw</code> package implements all of the transition types
found in those papers, with the exception of Itakura's and
Velichko-Zagoruyko's steps, which require subtly different algorithms (this
may be rectified in the future). Itakura recursion is almost, but not quite,
equivalent to <code>typeIIIc</code>.
</p>
<p>For convenience, we shall review pre-defined step patterns grouped by
classification. Note that the same pattern may be listed under different
names. Refer to paper (GiorginoJSS) for full details.
</p>
<p><strong>1. Well-known step patterns</strong>
</p>
<p>Common DTW implementations are based on one of the following transition
types.
</p>
<p><code>symmetric2</code> is the normalizable, symmetric, with no local slope
constraints.  Since one diagonal step costs as much as the two equivalent
steps along the sides, it can be normalized dividing by <code>N+M</code>
(query+reference lengths). It is widely used and the default.
</p>
<p><code>asymmetric</code> is asymmetric, slope constrained between 0 and 2. Matches
each element of the query time series exactly once, so the warping path
<code>index2~index1</code> is guaranteed to be single-valued.  Normalized by
<code>N</code> (length of query).
</p>
<p><code>symmetric1</code> (or White-Neely) is quasi-symmetric, no local constraint,
non-normalizable. It is biased in favor of oblique steps.
</p>
<p><strong>2. The Rabiner-Juang set</strong>
</p>
<p>A comprehensive table of step patterns is proposed in Rabiner-Juang's book
(Rabiner1993), tab. 4.5.  All of them can be constructed through the
<code>rabinerJuangStepPattern(type,slope.weighting,smoothed)</code> function.
</p>
<p>The classification foresees seven families, labelled with Roman numerals
I-VII; here, they are selected through the integer argument <code>type</code>.
Each family has four slope weighting sub-types, named in sec. 4.7.2.5 as
&quot;Type (a)&quot; to &quot;Type (d)&quot;; they are selected passing a character argument
<code>slope.weighting</code>, as in the table below. Furthermore, each subtype can
be either plain or smoothed (figure 4.44); smoothing is enabled setting the
logical argument <code>smoothed</code>.  (Not all combinations of arguments make
sense.)
</p>
<div class="sourceCode"><pre>  Subtype | Rule       | Norm | Unbiased 
  --------|------------|------|---------
     a    | min step   |  --  |   NO 
     b    | max step   |  --  |   NO 
     c    | Di step    |   N  |  YES 
     d    | Di+Dj step | N+M  |  YES 
</pre></div>
<p><strong>3. The Sakoe-Chiba set</strong>
</p>
<p>Sakoe-Chiba (Sakoe1978) discuss a family of slope-constrained patterns; they
are implemented as shown in page 47, table I.  Here, they are called
<code style="white-space: pre;">&#8288;symmetricP&lt;x&gt;&#8288;</code> and <code style="white-space: pre;">&#8288;asymmetricP&lt;x&gt;&#8288;</code>, where <code style="white-space: pre;">&#8288;&lt;x&gt;&#8288;</code> corresponds
to Sakoe's integer slope parameter <em>P</em>.  Values available are
accordingly: <code>0</code> (no constraint), <code>1</code>, <code>05</code> (one half) and
<code>2</code>. See (Sakoe1978) for details.
</p>
<p><strong>4. The Rabiner-Myers set</strong>
</p>
<p>The <code style="white-space: pre;">&#8288;type&lt;XX&gt;&lt;y&gt;&#8288;</code> step patterns follow the older Rabiner-Myers'
classification proposed in (Myers1980) and (MRR1980). Note that this is a
subset of the Rabiner-Juang set (Rabiner1993), and the latter should be
preferred in order to avoid confusion. <code style="white-space: pre;">&#8288;&lt;XX&gt;&#8288;</code> is a Roman numeral
specifying the shape of the transitions; <code style="white-space: pre;">&#8288;&lt;y&gt;&#8288;</code> is a letter in the range
<code>a-d</code> specifying the weighting used per step, as above; <code>typeIIx</code>
patterns also have a version ending in <code>s</code>, meaning the smoothing is
used (which does not permit skipping points). The <code style="white-space: pre;">&#8288;typeId, typeIId&#8288;</code> and
<code>typeIIds</code> are unbiased and symmetric.
</p>
<p><strong>5. Others</strong>
</p>
<p>The <code>rigid</code> pattern enforces a fixed unitary slope. It only makes sense
in combination with <code>open.begin=TRUE</code>, <code>open.end=TRUE</code> to find gapless
subsequences. It may be seen as the <code>P-&gt;inf</code> limiting case in Sakoe's classification.
</p>
<p><code>mori2006</code> is Mori's asymmetric step-constrained pattern (Mori2006). It
is normalized by the matched reference length.
</p>
<p><code><a href="#topic+mvmStepPattern">mvmStepPattern()</a></code> implements Latecki's Minimum Variance
Matching algorithm, and it is described in its own page.
</p>
<p><strong>Methods</strong>
</p>
<p><code>print.stepPattern</code> prints an user-readable description of the
recurrence equation defined by the given pattern.
</p>
<p><code>plot.stepPattern</code> graphically displays the step patterns productions
which can lead to element (0,0). Weights are shown along the step leading to
the corresponding element.
</p>
<p><code>t.stepPattern</code> transposes the productions and normalization hint so
that roles of query and reference become reversed.
</p>


<h3>Note</h3>

<p>Constructing <code>stepPattern</code> objects is tricky and thus undocumented. For a commented example please see source code for  <code>symmetricP1</code>.
</p>


<h3>Author(s)</h3>

<p>Toni Giorgino
</p>


<h3>References</h3>


<ul>
<li><p> (GiorginoJSS) Toni Giorgino. <em>Computing and Visualizing
Dynamic Time Warping Alignments in R: The dtw Package.</em> Journal of
Statistical Software, 31(7), 1-24. <a href="https://doi.org/10.18637/jss.v031.i07">doi:10.18637/jss.v031.i07</a>
</p>
</li>
<li><p> (Itakura1975) Itakura, F., <em>Minimum prediction residual
principle applied to speech recognition,</em> Acoustics, Speech, and Signal
Processing, IEEE Transactions on , vol.23, no.1, pp.  67-72, Feb 1975.
<a href="https://doi.org/10.1109/TASSP.1975.1162641">doi:10.1109/TASSP.1975.1162641</a>
</p>
</li>
<li><p> (MRR1980) Myers,
C.; Rabiner, L. &amp; Rosenberg, A. <em>Performance tradeoffs in dynamic time
warping algorithms for isolated word recognition</em>, IEEE Trans. Acoust.,
Speech, Signal Process., 1980, 28, 623-635.
<a href="https://doi.org/10.1109/TASSP.1980.1163491">doi:10.1109/TASSP.1980.1163491</a>
</p>
</li>
<li><p> (Mori2006) Mori,
A.; Uchida, S.; Kurazume, R.; Taniguchi, R.; Hasegawa, T. &amp; Sakoe, H. Early
Recognition and Prediction of Gestures Proc. 18th International Conference
on Pattern Recognition ICPR 2006, 2006, 3, 560-563.
<a href="https://doi.org/10.1109/ICPR.2006.467">doi:10.1109/ICPR.2006.467</a>
</p>
</li>
<li><p> (Myers1980) Myers,
Cory S.  <em>A Comparative Study Of Several Dynamic Time Warping
Algorithms For Speech Recognition</em>, MS and BS thesis, Dept. of Electrical
Engineering and Computer Science, Massachusetts Institute of Technology,
archived Jun 20 1980, <a href="https://hdl.handle.net/1721.1/27909">https://hdl.handle.net/1721.1/27909</a>
</p>
</li>
<li><p> (Rabiner1993) Rabiner, L. R., &amp; Juang, B.-H. (1993). <em>Fundamentals of
speech recognition.</em> Englewood Cliffs, NJ: Prentice Hall.
</p>
</li>
<li><p> (Sakoe1978) Sakoe, H.; Chiba, S., <em>Dynamic programming algorithm
optimization for spoken word recognition,</em> Acoustics, Speech, and Signal
Processing, IEEE Transactions on , vol.26, no.1, pp. 43-49, Feb 1978
<a href="https://doi.org/10.1109/TASSP.1978.1163055">doi:10.1109/TASSP.1978.1163055</a>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+mvmStepPattern">mvmStepPattern()</a></code>, implementing Latecki's Minimal
Variance Matching algorithm.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#########
##
## The usual (normalizable) symmetric step pattern
## Step pattern recursion, defined as:
## g[i,j] = min(
##      g[i,j-1] + d[i,j] ,
##      g[i-1,j-1] + 2 * d[i,j] ,
##      g[i-1,j] + d[i,j] ,
##   )

print(symmetric2)   # or just "symmetric2"



#########
##
## The well-known plotting style for step patterns

plot(symmetricP2,main="Sakoe's Symmetric P=2 recursion")



#########
##
## Same example seen in ?dtw , now with asymmetric step pattern

idx&lt;-seq(0,6.28,len=100);
query&lt;-sin(idx)+runif(100)/10;
reference&lt;-cos(idx);

## Do the computation 
asy&lt;-dtw(query,reference,keep=TRUE,step=asymmetric);

dtwPlot(asy,type="density",main="Sine and cosine, asymmetric step")


#########
##
##  Hand-checkable example given in [Myers1980] p 61
##

`tm` &lt;-
structure(c(1, 3, 4, 4, 5, 2, 2, 3, 3, 4, 3, 1, 1, 1, 3, 4, 2,
3, 3, 2, 5, 3, 4, 4, 1), .Dim = c(5L, 5L))

</code></pre>

<hr>
<h2 id='warp'>Apply a warping to a given timeseries</h2><span id='topic+warp'></span>

<h3>Description</h3>

<p>Returns the indexing required to apply the optimal warping curve to a given
timeseries (warps either into a query or into a reference).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>warp(d, index.reference = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="warp_+3A_d">d</code></td>
<td>
<p><code>dtw</code> object specifying the warping curve to apply</p>
</td></tr>
<tr><td><code id="warp_+3A_index.reference">index.reference</code></td>
<td>
<p><code>TRUE</code> to warp a reference, <code>FALSE</code> to warp
a query</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The warping is returned as a set of indices, which can be used to subscript
the timeseries to be warped (or rows in a matrix, if one wants to warp a
multivariate time series).  In other words, <code>warp</code> converts the warping
curve, or its inverse, into a function in the explicit form.
</p>
<p>Multiple indices that would be mapped to a single point are averaged, with a
warning. Gaps in the index sequence are filled by linear interpolation.
</p>


<h3>Value</h3>

<p>A list of indices to subscript the timeseries.
</p>


<h3>Author(s)</h3>

<p>Toni Giorgino
</p>


<h3>See Also</h3>

<p>Examples in <code><a href="#topic+dtw">dtw()</a></code> show how to <em>graphically</em> apply
the warping via parametric plots.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
idx&lt;-seq(0,6.28,len=100);
query&lt;-sin(idx)+runif(100)/10;
reference&lt;-cos(idx)

alignment&lt;-dtw(query,reference);


wq&lt;-warp(alignment,index.reference=FALSE);
wt&lt;-warp(alignment,index.reference=TRUE);

old.par &lt;- par(no.readonly = TRUE);
par(mfrow=c(2,1));

plot(reference,main="Warping query");
  lines(query[wq],col="blue");

plot(query,type="l",col="blue",
  main="Warping reference");
  points(reference[wt]);

par(old.par);


##############
##
## Asymmetric step makes it "natural" to warp
## the reference, because every query index has
## exactly one image (q-&gt;t is a function)
##

alignment&lt;-dtw(query,reference,step=asymmetric)
wt&lt;-warp(alignment,index.reference=TRUE);

plot(query,type="l",col="blue",
  main="Warping reference, asymmetric step");
  points(reference[wt]);




</code></pre>

<hr>
<h2 id='warpArea'>Compute Warping Path Area</h2><span id='topic+warpArea'></span>

<h3>Description</h3>

<p>Compute the area between the warping function and the diagonal (no-warping)
path, in unit steps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>warpArea(d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="warpArea_+3A_d">d</code></td>
<td>
<p>an object of class <code>dtw</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Above- and below- diagonal unit areas all count <em>plus</em> one (they do not
cancel with each other).  The &quot;diagonal&quot; goes from one corner to the other
of the possibly rectangular cost matrix, therefore having a slope of
<code>M/N</code>, not 1, as in <code><a href="#topic+slantedBandWindow">slantedBandWindow()</a></code>.
</p>
<p>The computation is approximate: points having multiple correspondences are
averaged, and points without a match are interpolated. Therefore, the area
can be fractionary.
</p>


<h3>Value</h3>

<p>The area, not normalized by path length or else.
</p>


<h3>Note</h3>

<p>There could be alternative definitions to the area, including
considering the envelope of the path.
</p>


<h3>Author(s)</h3>

<p>Toni Giorgino
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ds&lt;-dtw(1:4,1:8);

  plot(ds);lines(seq(1,8,len=4),col="red");

  warpArea(ds)

  ## Result: 6
  ##  index 2 is 2 while diag is 3.3  (+1.3)
  ##        3    3               5.7  (+2.7)
  ##        4   4:8 (avg to 6)    8   (+2  )
  ##                                 --------
  ##                                     6

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
