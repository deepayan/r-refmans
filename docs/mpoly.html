<!DOCTYPE html><html lang="en"><head><title>Help for package mpoly</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mpoly}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as.function.mpoly'><p>Change a multivariate polynomial into a function.</p></a></li>
<li><a href='#as.function.mpolyList'><p>Change a vector of multivariate polynomials into a function.</p></a></li>
<li><a href='#as.mpoly'><p>Convert an object to an mpoly</p></a></li>
<li><a href='#bernstein'><p>Bernstein polynomials</p></a></li>
<li><a href='#bernstein-approx'><p>Bernstein polynomial approximation</p></a></li>
<li><a href='#bezier'><p>Bezier polynomials</p></a></li>
<li><a href='#bezier_function'><p>Bezier function</p></a></li>
<li><a href='#burst'><p>Enumerate integer r-vectors summing to n</p></a></li>
<li><a href='#chebyshev'><p>Chebyshev polynomials</p></a></li>
<li><a href='#components'><p>Polynomial components</p></a></li>
<li><a href='#deriv.mpoly'><p>Compute partial derivatives of a multivariate polynomial.</p></a></li>
<li><a href='#eq_mp'><p>Convert an equation to a polynomial</p></a></li>
<li><a href='#gradient'><p>Compute gradient of a multivariate polynomial.</p></a></li>
<li><a href='#hermite'><p>Hermite polynomials</p></a></li>
<li><a href='#homogenize'><p>Homogenize a polynomial</p></a></li>
<li><a href='#insert'><p>Insert an element into a vector.</p></a></li>
<li><a href='#is.wholenumber'><p>Test whether an object is a whole number</p></a></li>
<li><a href='#jacobi'><p>Jacobi polynomials</p></a></li>
<li><a href='#laguerre'><p>Generalized Laguerre polynomials</p></a></li>
<li><a href='#LCM'><p>Compute the least common multiple of two numbers.</p></a></li>
<li><a href='#legendre'><p>Legendre polynomials</p></a></li>
<li><a href='#lissajous'><p>Lissajous polynomials</p></a></li>
<li><a href='#mp'><p>Define a multivariate polynomial.</p></a></li>
<li><a href='#mpoly'><p>Multivariate polynomials in R.</p></a></li>
<li><a href='#mpoly-defunct'><p>Defunct mpoly functions</p></a></li>
<li><a href='#mpoly-equal'><p>Determine whether two multivariate polynomials are equal.</p></a></li>
<li><a href='#mpolyArithmetic'><p>Arithmetic with multivariate polynomials</p></a></li>
<li><a href='#mpolyList'><p>Define a collection of multivariate polynomials.</p></a></li>
<li><a href='#mpolyListArithmetic'><p>Element-wise arithmetic with vectors of multivariate polynomials.</p></a></li>
<li><a href='#partitions'><p>Enumerate the partitions of an integer</p></a></li>
<li><a href='#permutations'><p>Determine all permutations of a set.</p></a></li>
<li><a href='#plug'><p>Switch indeterminates in a polynomial</p></a></li>
<li><a href='#predicates'><p>mpoly predicate functions</p></a></li>
<li><a href='#print.mpoly'><p>Pretty printing of multivariate polynomials.</p></a></li>
<li><a href='#print.mpolyList'><p>Pretty printing of a list of multivariate polynomials.</p></a></li>
<li><a href='#reorder.mpoly'><p>Reorder a multivariate polynomial.</p></a></li>
<li><a href='#round.mpoly'><p>Round the coefficients of a polynomial</p></a></li>
<li><a href='#solve_unipoly'><p>Solve a univariate mpoly with polyroot</p></a></li>
<li><a href='#swap'><p>Swap polynomial indeterminates</p></a></li>
<li><a href='#terms.mpoly'><p>Extract the terms of a multivariate polynomial.</p></a></li>
<li><a href='#tuples'><p>Determine all n-tuples using the elements of a set.</p></a></li>
<li><a href='#vars'><p>Determine the variables in a mpoly object.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Symbolic Computation and More with Multivariate Polynomials</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/dkahle/mpoly">https://github.com/dkahle/mpoly</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/dkahle/mpoly/issues">https://github.com/dkahle/mpoly/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Symbolic computing with multivariate polynomials in R.</td>
</tr>
<tr>
<td>Imports:</td>
<td>stringr (&ge; 1.0.0), stringi, partitions, plyr, stats, ggplot2,
polynom, orthopolynom, tidyr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.1.0), magrittr, dplyr, covr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.0.2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-02-19 19:28:27 UTC; david_kahle</td>
</tr>
<tr>
<td>Author:</td>
<td>David Kahle <a href="https://orcid.org/0000-0002-9999-1558"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David Kahle &lt;david@kahle.io&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-02-20 07:00:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='as.function.mpoly'>Change a multivariate polynomial into a function.</h2><span id='topic+as.function.mpoly'></span>

<h3>Description</h3>

<p>Transforms an mpoly object into a function which can be evaluated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mpoly'
as.function(x, varorder = vars(x), vector = TRUE,
  silent = FALSE, ..., plus_pad = 1L, times_pad = 1L, squeeze = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.function.mpoly_+3A_x">x</code></td>
<td>
<p>an object of class mpoly</p>
</td></tr>
<tr><td><code id="as.function.mpoly_+3A_varorder">varorder</code></td>
<td>
<p>the order of the variables</p>
</td></tr>
<tr><td><code id="as.function.mpoly_+3A_vector">vector</code></td>
<td>
<p>whether the function should take a vector argument (TRUE) or a
series of arguments (FALSE)</p>
</td></tr>
<tr><td><code id="as.function.mpoly_+3A_silent">silent</code></td>
<td>
<p>logical; if TRUE, suppresses output</p>
</td></tr>
<tr><td><code id="as.function.mpoly_+3A_...">...</code></td>
<td>
<p>any additional arguments</p>
</td></tr>
<tr><td><code id="as.function.mpoly_+3A_plus_pad">plus_pad</code></td>
<td>
<p>number of spaces to the left and right of plus sign</p>
</td></tr>
<tr><td><code id="as.function.mpoly_+3A_times_pad">times_pad</code></td>
<td>
<p>number of spaces to the left and right of times sign</p>
</td></tr>
<tr><td><code id="as.function.mpoly_+3A_squeeze">squeeze</code></td>
<td>
<p>minify code in the created function</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+plug">plug()</a></code>, <code><a href="#topic+as.function.mpolyList">as.function.mpolyList()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
p &lt;- mp("(x - 1)^2")
(f &lt;- as.function(p))
f(1)
f(seq(0, 2, .1))

p &lt;- mp("x + 3 x y + z^2 x")
(f &lt;- as.function(p))
f(1:3) # -&gt; 16
f(c(1,1,1)) # -&gt; 5

f &lt;- as.function(p, vector = FALSE)
f(1, 2, 3) # -&gt; 16
f(1, 1, 1) # -&gt; 5

f &lt;- as.function(p, varorder = c("z","y","x"), vector = FALSE)
f(3, 2, 1) # -&gt; 16
f(1, 1, 1) # -&gt; 5

# for univariate mpolys, as.function() returns a vectorized function
# that can even apply to arrays
p &lt;- mp("x^2")
f &lt;- as.function(p)
f(1:10)
(mat &lt;- matrix(1:4, 2))
f(mat)


p &lt;- mp("1 2 3 4")
f &lt;- as.function(p)
f(10) # -&gt; 24

bernstein(1, 2)
s &lt;- seq(0, 1, .01)
as.function(bernstein(1, 2))(s)
plot(
  s,
  as.function(bernstein(1, 2))(s)
)


as.function(mp("x + xx"))
as.function(mp("x + xx"), squeeze = FALSE)


</code></pre>

<hr>
<h2 id='as.function.mpolyList'>Change a vector of multivariate polynomials into a function.</h2><span id='topic+as.function.mpolyList'></span><span id='topic+as.function.bezier'></span>

<h3>Description</h3>

<p>Transforms an mpolyList object into a function which can be evaluated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mpolyList'
as.function(x, varorder = vars(x), vector = TRUE,
  silent = FALSE, ..., plus_pad = 1L, times_pad = 1L, squeeze = TRUE)

## S3 method for class 'bezier'
as.function(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.function.mpolyList_+3A_x">x</code></td>
<td>
<p>an object of class mpoly</p>
</td></tr>
<tr><td><code id="as.function.mpolyList_+3A_varorder">varorder</code></td>
<td>
<p>the order of the variables</p>
</td></tr>
<tr><td><code id="as.function.mpolyList_+3A_vector">vector</code></td>
<td>
<p>whether the function should take a vector argument (TRUE) or a
series of arguments (FALSE)</p>
</td></tr>
<tr><td><code id="as.function.mpolyList_+3A_silent">silent</code></td>
<td>
<p>logical; if TRUE, suppresses output</p>
</td></tr>
<tr><td><code id="as.function.mpolyList_+3A_...">...</code></td>
<td>
<p>any additional arguments</p>
</td></tr>
<tr><td><code id="as.function.mpolyList_+3A_plus_pad">plus_pad</code></td>
<td>
<p>number of spaces to the left and right of plus sign</p>
</td></tr>
<tr><td><code id="as.function.mpolyList_+3A_times_pad">times_pad</code></td>
<td>
<p>number of spaces to the left and right of times sign</p>
</td></tr>
<tr><td><code id="as.function.mpolyList_+3A_squeeze">squeeze</code></td>
<td>
<p>minify code in the created function</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+plug">plug()</a></code>, <code><a href="#topic+as.function.mpolyList">as.function.mpolyList()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# basic examples
(mpolyList &lt;- mp(c("2 x + 1", "x - z^2")))
(f &lt;- as.function(mpolyList))
f(c(1,2)) # -&gt; (2*1 + 1, 1-2^2) = 3 -3

f &lt;- as.function(mpolyList, varorder = c("x","y","z"))
f(c(1,0,2)) # -&gt; 3 -3
f(c(1,4,2)) # -&gt; 3 -3

f &lt;- as.function(mpolyList, varorder = c("x","y","z"), vector = FALSE)
f(1, 0, 2) # -&gt; 3 -3
f(1, 4, 2) # -&gt; 3 -3



# making a gradient function (useful for optim)
mpoly &lt;- mp("x + y^2 + y z")
mpolyList &lt;- gradient(mpoly)
f &lt;- as.function(mpolyList, varorder = vars(mpoly))
f(c(0,2,3)) # -&gt; 1 7 2



# a univariate mpolyList creates a vectorized function
ps &lt;- mp(c("x", "x^2", "x^3"))
f &lt;- as.function(ps)
f
s &lt;- seq(-1, 1, length.out = 11)
f(s)

# another example
ps &lt;- chebyshev(1:3)
f &lt;- as.function(ps)
f(s)

# the binomial pmf as an algebraic (polynomial) map
# from [0,1] to [0,1]^size
# p |-&gt; {choose(size, x) p^x (1-p)^(size-x)}_{x = 0, ..., size}
abinom &lt;- function(size, indet = "p"){
  chars4mp &lt;- vapply(as.list(0:size), function(x){
    sprintf("%d %s^%d (1-%s)^%d", choose(size, x), indet, x, indet, size-x)
  }, character(1))
  mp(chars4mp)
}
(ps &lt;- abinom(2, "p")) # = mp(c("(1-p)^2", "2 p (1-p)", "p^2"))
f &lt;- as.function(ps)

f(.5) # P[X = 0], P[X = 1], and P[X = 2] for X ~ Bin(2, .5)
dbinom(0:2, 2, .5)

f(.75) # P[X = 0], P[X = 1], and P[X = 2] for X ~ Bin(2, .75)
dbinom(0:2, 2, .75)

# as the degree gets larger, you'll need to be careful when evaluating
# the polynomial.  as.function() is not currently optimized for
# stable numerical evaluation of polynomials; it evaluates them in
# the naive way
all.equal(
  as.function(abinom(10))(.5),
  dbinom(0:10, 10, .5)
)

all.equal(
  as.function(abinom(30))(.5),
  dbinom(0:30, 20, .5)
)


# the function produced is vectorized:
number_of_probs &lt;- 11
probs &lt;- seq(0, 1, length.out = number_of_probs)
(mat &lt;- f(probs))
colnames(mat) &lt;- sprintf("P[X = %d]", 0:2)
rownames(mat) &lt;- sprintf("p = %.2f", s)
mat

</code></pre>

<hr>
<h2 id='as.mpoly'>Convert an object to an mpoly</h2><span id='topic+as.mpoly'></span>

<h3>Description</h3>

<p>mpoly is the most basic function used to create objects of class mpoly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.mpoly(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.mpoly_+3A_x">x</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="as.mpoly_+3A_...">...</code></td>
<td>
<p>additional arguments to pass to methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the object formated as a mpoly object.
</p>


<h3>Author(s)</h3>

<p>David Kahle <a href="mailto:david@kahle.io">david@kahle.io</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mp">mp()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(ggplot2); theme_set(theme_classic())
library(dplyr)

n &lt;- 101
s &lt;- seq(-5, 5, length.out = n)



# one dimensional case

df &lt;- data.frame(x = seq(-5, 5, length.out = n)) %&gt;%
  mutate(y = -x^2 + 2*x - 3 + rnorm(n, 0, 2))

(mod &lt;- lm(y ~ x + I(x^2), data = df))
(p &lt;- as.mpoly(mod))
qplot(x, y, data = df) +
  stat_function(fun = as.function(p), colour = "red", size = 1)

(mod &lt;- lm(y ~ poly(x, 2, raw = TRUE), data = df))
(p &lt;- as.mpoly(mod))
qplot(x, y, data = df) +
  stat_function(fun = as.function(p), colour = "red", size = 1)

(mod &lt;- lm(y ~ poly(x, 1, raw = TRUE), data = df))
(p &lt;- as.mpoly(mod))
qplot(x, y, data = df) +
  stat_function(fun = as.function(p), colour = "red", size = 1)



# two dimensional case with ggplot2

df &lt;- expand.grid(x = s, y = s) %&gt;%
  mutate(z = x^2 - y^2 + 3*x*y + rnorm(n^2, 0, 3))
qplot(x, y, data = df, geom = "raster", fill = z)

(mod &lt;- lm(z ~ x + y + I(x^2) + I(y^2) + I(x*y), data = df))
(mod &lt;- lm(z ~ poly(x, y, degree = 2, raw = TRUE), data = df))
(p &lt;- as.mpoly(mod))
df$fit &lt;- apply(df[,c("x","y")], 1, as.function(p))

qplot(x, y, data = df, geom = "raster", fill = fit)

qplot(x, y, data = df, geom = "raster", fill = z - fit) # residuals







</code></pre>

<hr>
<h2 id='bernstein'>Bernstein polynomials</h2><span id='topic+bernstein'></span>

<h3>Description</h3>

<p>Bernstein polynomials
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bernstein(k, n, indeterminate = "x")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bernstein_+3A_k">k</code></td>
<td>
<p>Bernstein polynomial k</p>
</td></tr>
<tr><td><code id="bernstein_+3A_n">n</code></td>
<td>
<p>Bernstein polynomial degree</p>
</td></tr>
<tr><td><code id="bernstein_+3A_indeterminate">indeterminate</code></td>
<td>
<p>indeterminate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a mpoly object
</p>


<h3>Author(s)</h3>

<p>David Kahle
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
bernstein(0, 0)

bernstein(0, 1)
bernstein(1, 1)

bernstein(0, 1, "t")

bernstein(0:2, 2)
bernstein(0:3, 3)
bernstein(0:3, 3, "t")


bernstein(0:4, 4)
bernstein(0:10, 10)
bernstein(0:10, 10, "t")
bernstein(0:20, 20, "t")

## Not run:   # visualize the bernstein polynomials

library(ggplot2); theme_set(theme_classic())
library(tidyr)

s &lt;- seq(0, 1, length.out = 101)
N &lt;- 10 # number of bernstein polynomials to plot
(bernPolys &lt;- bernstein(0:N, N))

df &lt;- data.frame(s, as.function(bernPolys)(s))
names(df) &lt;- c("x", paste0("B_", 0:N))
head(df)

mdf &lt;- gather(df, degree, value, -x)
head(mdf)

qplot(x, value, data = mdf, geom = "line", color = degree)


## End(Not run)


</code></pre>

<hr>
<h2 id='bernstein-approx'>Bernstein polynomial approximation</h2><span id='topic+bernstein-approx'></span><span id='topic+bernstein_approx'></span><span id='topic+bernsteinApprox'></span>

<h3>Description</h3>

<p>Bernstein polynomial approximation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bernstein_approx(f, n, lower = 0, upper = 1, indeterminate = "x")

bernsteinApprox(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bernstein-approx_+3A_f">f</code></td>
<td>
<p>the function to approximate</p>
</td></tr>
<tr><td><code id="bernstein-approx_+3A_n">n</code></td>
<td>
<p>Bernstein polynomial degree</p>
</td></tr>
<tr><td><code id="bernstein-approx_+3A_lower">lower</code></td>
<td>
<p>lower bound for approximation</p>
</td></tr>
<tr><td><code id="bernstein-approx_+3A_upper">upper</code></td>
<td>
<p>upper bound for approximation</p>
</td></tr>
<tr><td><code id="bernstein-approx_+3A_indeterminate">indeterminate</code></td>
<td>
<p>indeterminate</p>
</td></tr>
<tr><td><code id="bernstein-approx_+3A_...">...</code></td>
<td>
<p>...</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a mpoly object
</p>


<h3>Author(s)</h3>

<p>David Kahle
</p>


<h3>Examples</h3>

<pre><code class='language-R'>




## Not run:   # visualize the bernstein polynomials

library(ggplot2); theme_set(theme_bw())
library(reshape2)




f &lt;- function(x) sin(2*pi*x)
p &lt;- bernstein_approx(f, 20)
round(p, 3)

x &lt;- seq(0, 1, length.out = 101)
df &lt;- data.frame(
  x = rep(x, 2),
  y = c(f(x), as.function(p)(x)),
  which = rep(c("actual", "approx"), each = 101)
)
qplot(x, y, data = df, geom = "line", color = which)






p &lt;- bernstein_approx(sin, 20, pi/2, 1.5*pi)
round(p, 4)

x &lt;- seq(0, 2*pi, length.out = 101)
df &lt;- data.frame(
  x = rep(x, 2),
  y = c(sin(x), as.function(p)(x)),
  which = rep(c("actual", "approx"), each = 101)
)
qplot(x, y, data = df, geom = "line", color = which)








p &lt;- bernstein_approx(dnorm, 15, -1.25, 1.25)
round(p, 4)

x &lt;- seq(-3, 3, length.out = 101)
df &lt;- data.frame(
  x = rep(x, 2),
  y = c(dnorm(x), as.function(p)(x)),
  which = rep(c("actual", "approx"), each = 101)
)
qplot(x, y, data = df, geom = "line", color = which)







## End(Not run)

</code></pre>

<hr>
<h2 id='bezier'>Bezier polynomials</h2><span id='topic+bezier'></span>

<h3>Description</h3>

<p>Compute the Bezier polynomials of a given collection of points. Note that
using <code><a href="#topic+as.function.mpoly">mpoly::as.function.mpoly()</a></code> on the resulting Bezier polynomials is
made numerically stable by taking advantage of de Casteljau's algorithm; it
does not use the polynomial that is printed to the screen.  See
<code><a href="#topic+bezier_function">bezier_function()</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bezier(..., indeterminate = "t")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bezier_+3A_...">...</code></td>
<td>
<p>either a sequence of points or a matrix/data frame of points, see
examples</p>
</td></tr>
<tr><td><code id="bezier_+3A_indeterminate">indeterminate</code></td>
<td>
<p>the indeterminate of the resulting polynomial</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a mpoly object
</p>


<h3>Author(s)</h3>

<p>David Kahle
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bezier_function">bezier_function()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
p1 &lt;- c(0,  0)
p2 &lt;- c(1,  1)
p3 &lt;- c(2, -1)
p4 &lt;- c(3,  0)
bezier(p1, p2, p3, p4)


points &lt;- data.frame(x = 0:3, y = c(0,1,-1,0))
bezier(points)


points &lt;- data.frame(x = 0:2, y = c(0,1,0))
bezier(points)







# visualize the bernstein polynomials

library(ggplot2); theme_set(theme_bw())

s &lt;- seq(0, 1, length.out = 101)



## example 1
points &lt;- data.frame(x = 0:3, y = c(0,1,-1,0))
(bezPolys &lt;- bezier(points))

f &lt;- as.function(bezPolys)
df &lt;- as.data.frame(f(s))

ggplot(aes(x = x, y = y), data = df) +
  geom_point(data = points, color = "red") +
  geom_path(data = points, color = "red") +
  geom_path()




## example 1 with weights
f &lt;- as.function(bezPolys, weights = c(1,5,5,1))
df &lt;- as.data.frame(f(s))

ggplot(aes(x = x, y = y), data = df) +
  geom_point(data = points, color = "red") +
  geom_path(data = points, color = "red") +
  geom_path()





## example 2
points &lt;- data.frame(x = 0:2, y = c(0,1,0))
(bezPolys &lt;- bezier(points))
f &lt;- as.function(bezPolys)
df &lt;- as.data.frame(f(s))

ggplot(aes(x = x, y = y), data = df) +
  geom_point(data = points, color = "red") +
  geom_path(data = points, color = "red") +
  geom_path()




## example 3
points &lt;- data.frame(x = c(-1,-2,2,1), y = c(0,1,1,0))
(bezPolys &lt;- bezier(points))
f &lt;- as.function(bezPolys)
df &lt;- as.data.frame(f(s))

ggplot(aes(x = x, y = y), data = df) +
  geom_point(data = points, color = "red") +
  geom_path(data = points, color = "red") +
  geom_path()




## example 4
points &lt;- data.frame(x = c(-1,2,-2,1), y = c(0,1,1,0))
(bezPolys &lt;- bezier(points))
f &lt;- as.function(bezPolys)
df &lt;- as.data.frame(f(s))

ggplot(aes(x = x, y = y), data = df) +
  geom_point(data = points, color = "red") +
  geom_path(data = points, color = "red") +
  geom_path()




## example 5
qplot(speed, dist, data = cars)

s &lt;- seq(0, 1, length.out = 201)
p &lt;- bezier(cars)
f &lt;- as.function(p)
df &lt;- as.data.frame(f(s))
qplot(speed, dist, data = cars) +
  geom_path(data = df, color = "red")

# the curve is not invariant to permutations of the points
# but it always goes through the first and last points
permute_rows &lt;- function(df) df[sample(nrow(df)),]
p &lt;- bezier(permute_rows(cars))
f &lt;- as.function(p)
df &lt;- as.data.frame(f(s))
qplot(speed, dist, data = cars) +
  geom_path(data = df, color = "red")



</code></pre>

<hr>
<h2 id='bezier_function'>Bezier function</h2><span id='topic+bezier_function'></span><span id='topic+bezierFunction'></span>

<h3>Description</h3>

<p>Compute the Bezier function of a collection of polynomials.  By Bezier
function we mean the Bezier curve function, a parametric map running from t =
0, the first point, to t = 1, the last point, where the coordinate mappings
are linear combinations of Bernstein polynomials.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bezier_function(points, weights = rep(1L, nrow(points)))

bezierFunction(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bezier_function_+3A_points">points</code></td>
<td>
<p>a matrix or data frame of numerics.  the rows represent points.</p>
</td></tr>
<tr><td><code id="bezier_function_+3A_weights">weights</code></td>
<td>
<p>the weights in a weighted Bezier curve</p>
</td></tr>
<tr><td><code id="bezier_function_+3A_...">...</code></td>
<td>
<p>...; used internally</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function returned is vectorized and evaluates the Bezier curve in a
numerically stable way with de Castlejau's algorithm (implemented in R).
</p>


<h3>Value</h3>

<p>function of a single parameter
</p>


<h3>Author(s)</h3>

<p>David Kahle
</p>


<h3>References</h3>

<p><a href="http://en.wikipedia.org/wiki/Bezier_curve">http://en.wikipedia.org/wiki/Bezier_curve</a>,
<a href="http://en.wikipedia.org/wiki/De_Casteljau's_algorithm">http://en.wikipedia.org/wiki/De_Casteljau's_algorithm</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bezier">bezier()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(ggplot2); theme_set(theme_bw())


t &lt;- seq(0, 1, length.out = 201)
points &lt;- data.frame(x = 0:3, y = c(0,1,-1,0))


f &lt;- bezier_function(points)
df &lt;- as.data.frame(f(t))

ggplot(aes(x = x, y = y), data = df) +
  geom_point(data = points, color = "red", size = 8) +
  geom_path(data = points, color = "red") +
  geom_path()




f &lt;- bezier_function(points, weights = c(1,5,5,1))
df &lt;- as.data.frame(f(t))

ggplot(aes(x = x, y = y), data = df) +
  geom_point(data = points, color = "red", size = 8) +
  geom_path(data = points, color = "red") +
  geom_path()




f &lt;- bezier_function(points, weights = c(1,10,10,1))
df &lt;- as.data.frame(f(t))

ggplot(aes(x = x, y = y), data = df) +
  geom_point(data = points, color = "red", size = 8) +
  geom_path(data = points, color = "red") +
  geom_path()









  
</code></pre>

<hr>
<h2 id='burst'>Enumerate integer r-vectors summing to n</h2><span id='topic+burst'></span>

<h3>Description</h3>

<p>Determine all r-vectors with nonnegative integer entries summing to n.  Note
that this is not intended to be optimized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>burst(n, r = n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="burst_+3A_n">n</code></td>
<td>
<p>integer to sum to</p>
</td></tr>
<tr><td><code id="burst_+3A_r">r</code></td>
<td>
<p>number of components</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix whose rows are the n-tuples
</p>


<h3>Examples</h3>

<pre><code class='language-R'>burst(4)

burst(4, 4)
burst(4, 3)
burst(4, 2)

rowSums(burst(4))
rowSums(burst(4, 3))
rowSums(burst(4, 2))


burst(10, 4) # all possible 2x2 contingency tables with n=10
burst(10, 4) / 10 # all possible empirical relative frequencies

</code></pre>

<hr>
<h2 id='chebyshev'>Chebyshev polynomials</h2><span id='topic+chebyshev'></span><span id='topic+chebyshev_roots'></span>

<h3>Description</h3>

<p>Chebyshev polynomials as computed by orthopolynom.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chebyshev(degree, kind = "t", indeterminate = "x", normalized = FALSE)

chebyshev_roots(k, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chebyshev_+3A_degree">degree</code></td>
<td>
<p>degree of polynomial</p>
</td></tr>
<tr><td><code id="chebyshev_+3A_kind">kind</code></td>
<td>
<p><code>"t"</code> or <code>"u"</code> (Chebyshev polynomials of the first and
second kinds), or <code>"c"</code> or <code>"s"</code></p>
</td></tr>
<tr><td><code id="chebyshev_+3A_indeterminate">indeterminate</code></td>
<td>
<p>indeterminate</p>
</td></tr>
<tr><td><code id="chebyshev_+3A_normalized">normalized</code></td>
<td>
<p>provide normalized coefficients</p>
</td></tr>
<tr><td><code id="chebyshev_+3A_k">k</code>, <code id="chebyshev_+3A_n">n</code></td>
<td>
<p>the k'th root of the n'th chebyshev polynomial</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a mpoly object or mpolyList object
</p>


<h3>Author(s)</h3>

<p>David Kahle calling code from the orthopolynom package
</p>


<h3>See Also</h3>

<p><code><a href="orthopolynom.html#topic+chebyshev.t.polynomials">orthopolynom::chebyshev.t.polynomials()</a></code>,
<code><a href="orthopolynom.html#topic+chebyshev.u.polynomials">orthopolynom::chebyshev.u.polynomials()</a></code>,
<code><a href="orthopolynom.html#topic+chebyshev.c.polynomials">orthopolynom::chebyshev.c.polynomials()</a></code>,
<code><a href="orthopolynom.html#topic+chebyshev.s.polynomials">orthopolynom::chebyshev.s.polynomials()</a></code>,
<a href="http://en.wikipedia.org/wiki/Chebyshev_polynomials">http://en.wikipedia.org/wiki/Chebyshev_polynomials</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
chebyshev(0)
chebyshev(1)
chebyshev(2)
chebyshev(3)
chebyshev(4)
chebyshev(5)
chebyshev(6)
chebyshev(10)

chebyshev(0:5)
chebyshev(0:5, normalized = TRUE)
chebyshev(0:5, kind = "u")
chebyshev(0:5, kind = "c")
chebyshev(0:5, kind = "s")
chebyshev(0:5, indeterminate = "t")



# visualize the chebyshev polynomials

library(ggplot2); theme_set(theme_classic())
library(tidyr)

s &lt;- seq(-1, 1, length.out = 201)
N &lt;- 5 # number of chebyshev polynomials to plot
(cheb_polys &lt;- chebyshev(0:N))

# see ?bernstein for a better understanding of
# how the code below works

df &lt;- data.frame(s, as.function(cheb_polys)(s))
names(df) &lt;- c("x", paste0("T_", 0:N))
mdf &lt;- gather(df, degree, value, -x)
qplot(x, value, data = mdf, geom = "line", color = degree)



# roots of chebyshev polynomials
N &lt;- 5
cheb_roots &lt;- chebyshev_roots(1:N, N)
cheb_fun &lt;- as.function(chebyshev(N))
cheb_fun(cheb_roots)



# chebyshev polynomials are orthogonal in two ways:
T2 &lt;- as.function(chebyshev(2))
T3 &lt;- as.function(chebyshev(3))
T4 &lt;- as.function(chebyshev(4))

w &lt;- function(x) 1 / sqrt(1 - x^2)
integrate(function(x) T2(x) * T3(x) * w(x), lower = -1, upper = 1)
integrate(function(x) T2(x) * T4(x) * w(x), lower = -1, upper = 1)
integrate(function(x) T3(x) * T4(x) * w(x), lower = -1, upper = 1)

(cheb_roots &lt;- chebyshev_roots(1:4, 4))
sum(T2(cheb_roots) * T3(cheb_roots) * w(cheb_roots))
sum(T2(cheb_roots) * T4(cheb_roots) * w(cheb_roots))
sum(T3(cheb_roots) * T4(cheb_roots) * w(cheb_roots))

sum(T2(cheb_roots) * T3(cheb_roots))
sum(T2(cheb_roots) * T4(cheb_roots))
sum(T3(cheb_roots) * T4(cheb_roots))


</code></pre>

<hr>
<h2 id='components'>Polynomial components</h2><span id='topic+components'></span><span id='topic++5B.mpoly'></span><span id='topic+LT'></span><span id='topic+LC'></span><span id='topic+LM'></span><span id='topic+multideg'></span><span id='topic+totaldeg'></span><span id='topic+monomials'></span><span id='topic+exponents'></span>

<h3>Description</h3>

<p>Compute quantities/expressions related to a multivariate polynomial.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mpoly'
x[ndx]

LT(x, varorder = vars(x), order = "lex")

LC(x, varorder = vars(x), order = "lex")

LM(x, varorder = vars(x), order = "lex")

multideg(x, varorder = vars(x), order = "lex")

totaldeg(x)

monomials(x)

exponents(x, reduced = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="components_+3A_x">x</code></td>
<td>
<p>an object of class mpoly</p>
</td></tr>
<tr><td><code id="components_+3A_ndx">ndx</code></td>
<td>
<p>a subsetting index</p>
</td></tr>
<tr><td><code id="components_+3A_varorder">varorder</code></td>
<td>
<p>the order of the variables</p>
</td></tr>
<tr><td><code id="components_+3A_order">order</code></td>
<td>
<p>a total order used to order the terms</p>
</td></tr>
<tr><td><code id="components_+3A_reduced">reduced</code></td>
<td>
<p>if TRUE, don't include zero degrees</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class mpoly or mpolyList, depending on the context
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(p &lt;- mp("x y^2 + x (x+1) (x+2) x z + 3 x^10"))
p[2]
p[-2]
p[2:3]

LT(p)
LC(p)
LM(p)

multideg(p)
totaldeg(p)
monomials(p)

exponents(p)
exponents(p, reduce = TRUE)
lapply(exponents(p), is.integer)

homogeneous_components(p)

</code></pre>

<hr>
<h2 id='deriv.mpoly'>Compute partial derivatives of a multivariate polynomial.</h2><span id='topic+deriv.mpoly'></span>

<h3>Description</h3>

<p>This is a deriv method for mpoly objects.  It does not call the
<code><a href="stats.html#topic+deriv">stats::deriv()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mpoly'
deriv(expr, var, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="deriv.mpoly_+3A_expr">expr</code></td>
<td>
<p>an object of class mpoly</p>
</td></tr>
<tr><td><code id="deriv.mpoly_+3A_var">var</code></td>
<td>
<p>character - the partial derivative desired</p>
</td></tr>
<tr><td><code id="deriv.mpoly_+3A_...">...</code></td>
<td>
<p>any additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class mpoly or mpolyList.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- mp("x y + y z + z^2")
deriv(m, "x")
deriv(m, "y")
deriv(m, "z")
deriv(m, c("x","y","z"))
deriv(m, "a")
is.mpoly(deriv(m, "x"))
is.mpolyList( deriv(m, c("x","y","z")) )
</code></pre>

<hr>
<h2 id='eq_mp'>Convert an equation to a polynomial</h2><span id='topic+eq_mp'></span>

<h3>Description</h3>

<p>Convert characters of the form <code>"p1 = p2"</code> (or similar) to an mpoly
object representing <code>p1 - p2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eq_mp(string, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eq_mp_+3A_string">string</code></td>
<td>
<p>a character string containing a polynomial, see examples</p>
</td></tr>
<tr><td><code id="eq_mp_+3A_...">...</code></td>
<td>
<p>arguments to pass to <code><a href="#topic+mpoly">mpoly()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class mpoly or mpolyList.
</p>


<h3>Author(s)</h3>

<p>David Kahle <a href="mailto:david@kahle.io">david@kahle.io</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mpoly">mpoly()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
eq_mp(c("y = x", "y ==  (x + 2)"))



</code></pre>

<hr>
<h2 id='gradient'>Compute gradient of a multivariate polynomial.</h2><span id='topic+gradient'></span>

<h3>Description</h3>

<p>This is a wrapper for deriv.mpoly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gradient(mpoly)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gradient_+3A_mpoly">mpoly</code></td>
<td>
<p>an object of class mpoly</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class mpoly or mpolyList.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+deriv.mpoly">deriv.mpoly()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- mp("x y + y z + z^2")
gradient(m)


# gradient descent illustration using the symbolically
# computed gradient of the rosenbrock function (shifted)
rosenbrock &lt;- mp("(1 - x)^2 + 100 (y - x^2)^2")
fn &lt;- as.function(rosenbrock)
(rosenbrock_gradient &lt;- gradient(rosenbrock))
gr &lt;- as.function(rosenbrock_gradient)

# visualize the function
library(ggplot2)
s &lt;- seq(-5, 5, .05)
df &lt;- expand.grid(x = s, y = s)
df$z &lt;- apply(df, 1, fn)
ggplot(df, aes(x = x, y = y)) +
  geom_raster(aes(fill = z + 1e-10)) +
  scale_fill_continuous(trans = "log10")
  
# run the gradient descent algorithm using line-search
# step sizes computed with optimize()
current &lt;- steps &lt;- c(-3,-4)
change &lt;- 1
tol &lt;- 1e-5
while(change &gt; tol){
  last  &lt;- current
  delta &lt;- optimize(
    function(delta) fn(current - delta*gr(current)),
    interval = c(1e-10, .1)
  )$minimum
  current &lt;- current - delta*gr(current)
  steps   &lt;- unname(rbind(steps, current))
  change  &lt;- abs(fn(current) - fn(last))
}
steps &lt;- as.data.frame(steps)
names(steps) &lt;- c("x", "y")
  
# visualize steps, note the optim at c(1,1)
# the routine took 5748 steps
ggplot(df, aes(x = x, y = y)) +
  geom_raster(aes(fill = z + 1e-10)) +
  geom_path(data = steps, color = "red") +
  geom_point(data = steps, color = "red", size = .5) +
  scale_fill_continuous(trans = "log10")

# it gets to the general region of space quickly
# but once it gets on the right arc, it's terrible
# here's what the end game looks like
last_steps &lt;- tail(steps, 100)
rngx &lt;- range(last_steps$x); sx &lt;- seq(rngx[1], rngx[2], length.out = 201)
rngy &lt;- range(last_steps$y); sy &lt;- seq(rngy[1], rngy[2], length.out = 201)
df &lt;- expand.grid(x = sx, y = sy)
df$z &lt;- apply(df, 1, fn) 
ggplot(df, aes(x = x, y = y)) +
  geom_raster(aes(fill = z)) +
  geom_path(data = last_steps, color = "red", size = .25) +
  geom_point(data = last_steps, color = "red", size = 1) +
  scale_fill_continuous(trans = "log10") 
  

</code></pre>

<hr>
<h2 id='hermite'>Hermite polynomials</h2><span id='topic+hermite'></span>

<h3>Description</h3>

<p>Hermite polynomials as computed by orthopolynom.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hermite(degree, kind = "he", indeterminate = "x", normalized = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hermite_+3A_degree">degree</code></td>
<td>
<p>degree of polynomial</p>
</td></tr>
<tr><td><code id="hermite_+3A_kind">kind</code></td>
<td>
<p>&quot;he&quot; (default, probabilists', see Wikipedia article) or &quot;h&quot;
(physicists)</p>
</td></tr>
<tr><td><code id="hermite_+3A_indeterminate">indeterminate</code></td>
<td>
<p>indeterminate</p>
</td></tr>
<tr><td><code id="hermite_+3A_normalized">normalized</code></td>
<td>
<p>provide normalized coefficients</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a mpoly object or mpolyList object
</p>


<h3>Author(s)</h3>

<p>David Kahle calling code from the orthopolynom package
</p>


<h3>See Also</h3>

<p><code><a href="orthopolynom.html#topic+hermite.h.polynomials">orthopolynom::hermite.h.polynomials()</a></code>,
<code><a href="orthopolynom.html#topic+hermite.he.polynomials">orthopolynom::hermite.he.polynomials()</a></code>,
<a href="http://en.wikipedia.org/wiki/Hermite_polynomials">http://en.wikipedia.org/wiki/Hermite_polynomials</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
hermite(0)
hermite(1)
hermite(2)
hermite(3)
hermite(4)
hermite(5)
hermite(6)
hermite(10)

hermite(0:5)
hermite(0:5, normalized = TRUE)
hermite(0:5, indeterminate = "t")



# visualize the hermite polynomials

library(ggplot2); theme_set(theme_classic())
library(tidyr)

s &lt;- seq(-3, 3, length.out = 201)
N &lt;- 5 # number of hermite polynomials to plot
(hermPolys &lt;- hermite(0:N))

# see ?bernstein for a better understanding of
# how the code below works

df &lt;- data.frame(s, as.function(hermPolys)(s))
names(df) &lt;- c("x", paste0("T_", 0:N))
mdf &lt;- gather(df, degree, value, -x)
qplot(x, value, data = mdf, geom = "line", color = degree)


# hermite polynomials are orthogonal with respect to the gaussian kernel:
He2 &lt;- as.function(hermite(2))
He3 &lt;- as.function(hermite(3))
He4 &lt;- as.function(hermite(4))

w &lt;- dnorm
integrate(function(x) He2(x) * He3(x) * w(x), lower = -Inf, upper = Inf)
integrate(function(x) He2(x) * He4(x) * w(x), lower = -Inf, upper = Inf)
integrate(function(x) He3(x) * He4(x) * w(x), lower = -Inf, upper = Inf)



</code></pre>

<hr>
<h2 id='homogenize'>Homogenize a polynomial</h2><span id='topic+homogenize'></span><span id='topic+dehomogenize'></span><span id='topic+is.homogeneous'></span><span id='topic+homogeneous_components'></span>

<h3>Description</h3>

<p>Homogenize a polynomial.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>homogenize(x, indeterminate = "t")

dehomogenize(x, indeterminate = "t")

is.homogeneous(x)

homogeneous_components(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="homogenize_+3A_x">x</code></td>
<td>
<p>an mpoly object, see <code><a href="#topic+mpoly">mpoly()</a></code></p>
</td></tr>
<tr><td><code id="homogenize_+3A_indeterminate">indeterminate</code></td>
<td>
<p>name of homogenization</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a (de/homogenized) mpoly or an mpolyList
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- mp("x^4 + y + 2 x y^2 - 3 z")
is.homogeneous(x)
(xh &lt;- homogenize(x))
is.homogeneous(xh)

homogeneous_components(x)

homogenize(x, "o")

xh &lt;- homogenize(x)
dehomogenize(xh) # assumes indeterminate = "t"
plug(xh, "t", 1) # same effect, but dehomogenize is faster



# the functions are vectorized
(ps &lt;- mp(c("x + y^2", "x + y^3")))
(psh &lt;- homogenize(ps))
dehomogenize(psh)


# demonstrating a leading property of homogeneous polynomials
library(magrittr)
p  &lt;- mp("x^2 + 2 x + 3")
(ph &lt;- homogenize(p, "y"))
lambda &lt;- 3
(d &lt;- totaldeg(p))
ph %&gt;%
  plug("x", lambda*mp("x")) %&gt;%
  plug("y", lambda*mp("y"))
lambda^d * ph

</code></pre>

<hr>
<h2 id='insert'>Insert an element into a vector.</h2><span id='topic+insert'></span>

<h3>Description</h3>

<p>Insert an element into a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>insert(elem, slot, v)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="insert_+3A_elem">elem</code></td>
<td>
<p>element to insert</p>
</td></tr>
<tr><td><code id="insert_+3A_slot">slot</code></td>
<td>
<p>location of insert</p>
</td></tr>
<tr><td><code id="insert_+3A_v">v</code></td>
<td>
<p>vector to insert into</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector with element inserted
</p>


<h3>Examples</h3>

<pre><code class='language-R'>insert(2, 1, 1)
insert(2, 2, 1) 
insert('x', 5, letters) 
</code></pre>

<hr>
<h2 id='is.wholenumber'>Test whether an object is a whole number</h2><span id='topic+is.wholenumber'></span>

<h3>Description</h3>

<p>Test whether an object is a whole number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.wholenumber(x, tol = .Machine$double.eps^0.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.wholenumber_+3A_x">x</code></td>
<td>
<p>object to be tested</p>
</td></tr>
<tr><td><code id="is.wholenumber_+3A_tol">tol</code></td>
<td>
<p>tolerance within which a number is said to be whole</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of logicals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is.wholenumber(seq(-3,3,.5))
</code></pre>

<hr>
<h2 id='jacobi'>Jacobi polynomials</h2><span id='topic+jacobi'></span>

<h3>Description</h3>

<p>Jacobi polynomials as computed by orthopolynom.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jacobi(
  degree,
  alpha = 1,
  beta = 1,
  kind = "p",
  indeterminate = "x",
  normalized = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jacobi_+3A_degree">degree</code></td>
<td>
<p>degree of polynomial</p>
</td></tr>
<tr><td><code id="jacobi_+3A_alpha">alpha</code></td>
<td>
<p>the first parameter, also called p</p>
</td></tr>
<tr><td><code id="jacobi_+3A_beta">beta</code></td>
<td>
<p>the second parameter, also called q</p>
</td></tr>
<tr><td><code id="jacobi_+3A_kind">kind</code></td>
<td>
<p>&quot;g&quot; or &quot;p&quot;</p>
</td></tr>
<tr><td><code id="jacobi_+3A_indeterminate">indeterminate</code></td>
<td>
<p>indeterminate</p>
</td></tr>
<tr><td><code id="jacobi_+3A_normalized">normalized</code></td>
<td>
<p>provide normalized coefficients</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a mpoly object or mpolyList object
</p>


<h3>Author(s)</h3>

<p>David Kahle calling code from the orthopolynom package
</p>


<h3>See Also</h3>

<p><code><a href="orthopolynom.html#topic+jacobi.g.polynomials">orthopolynom::jacobi.g.polynomials()</a></code>,
<code><a href="orthopolynom.html#topic+jacobi.p.polynomials">orthopolynom::jacobi.p.polynomials()</a></code>,
<a href="http://en.wikipedia.org/wiki/Jacobi_polynomials">http://en.wikipedia.org/wiki/Jacobi_polynomials</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
jacobi(0)
jacobi(1)
jacobi(2)
jacobi(3)
jacobi(4)
jacobi(5)
jacobi(6)
jacobi(10, 2, 2, normalized = TRUE)

jacobi(0:5)
jacobi(0:5, normalized = TRUE)
jacobi(0:5, kind = "g")
jacobi(0:5, indeterminate = "t")



# visualize the jacobi polynomials

library(ggplot2); theme_set(theme_classic())
library(tidyr)

s &lt;- seq(-1, 1, length.out = 201)
N &lt;- 5 # number of jacobi polynomials to plot
(jacPolys &lt;- jacobi(0:N, 2, 2))

df &lt;- data.frame(s, as.function(jacPolys)(s))
names(df) &lt;- c("x", paste0("P_", 0:N))
mdf &lt;- gather(df, degree, value, -x)
qplot(x, value, data = mdf, geom = "line", color = degree)

qplot(x, value, data = mdf, geom = "line", color = degree) +
  coord_cartesian(ylim = c(-30, 30))



</code></pre>

<hr>
<h2 id='laguerre'>Generalized Laguerre polynomials</h2><span id='topic+laguerre'></span>

<h3>Description</h3>

<p>Generalized Laguerre polynomials as computed by orthopolynom.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>laguerre(degree, alpha = 0, indeterminate = "x", normalized = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="laguerre_+3A_degree">degree</code></td>
<td>
<p>degree of polynomial</p>
</td></tr>
<tr><td><code id="laguerre_+3A_alpha">alpha</code></td>
<td>
<p>generalization constant</p>
</td></tr>
<tr><td><code id="laguerre_+3A_indeterminate">indeterminate</code></td>
<td>
<p>indeterminate</p>
</td></tr>
<tr><td><code id="laguerre_+3A_normalized">normalized</code></td>
<td>
<p>provide normalized coefficients</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a mpoly object or mpolyList object
</p>


<h3>Author(s)</h3>

<p>David Kahle calling code from the orthopolynom package
</p>


<h3>See Also</h3>

<p><code><a href="orthopolynom.html#topic+glaguerre.polynomials">orthopolynom::glaguerre.polynomials()</a></code>,
<a href="http://en.wikipedia.org/wiki/Laguerre_polynomials">http://en.wikipedia.org/wiki/Laguerre_polynomials</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
laguerre(0)
laguerre(1)
laguerre(2)
laguerre(3)
laguerre(4)
laguerre(5)
laguerre(6)

laguerre(2)
laguerre(2, normalized = TRUE)

laguerre(0:5)
laguerre(0:5, normalized = TRUE)
laguerre(0:5, indeterminate = "t")



# visualize the laguerre polynomials

library(ggplot2); theme_set(theme_classic())
library(tidyr)

s &lt;- seq(-5, 20, length.out = 201)
N &lt;- 5 # number of laguerre polynomials to plot
(lagPolys &lt;- laguerre(0:N))

# see ?bernstein for a better understanding of
# how the code below works

df &lt;- data.frame(s, as.function(lagPolys)(s))
names(df) &lt;- c("x", paste0("L_", 0:N))
mdf &lt;- gather(df, degree, value, -x)
qplot(x, value, data = mdf, geom = "line", color = degree)

qplot(x, value, data = mdf, geom = "line", color = degree) +
  coord_cartesian(ylim = c(-25, 25))


# laguerre polynomials are orthogonal with respect to the exponential kernel:
L2 &lt;- as.function(laguerre(2))
L3 &lt;- as.function(laguerre(3))
L4 &lt;- as.function(laguerre(4))

w &lt;- dexp
integrate(function(x) L2(x) * L3(x) * w(x), lower = 0, upper = Inf)
integrate(function(x) L2(x) * L4(x) * w(x), lower = 0, upper = Inf)
integrate(function(x) L3(x) * L4(x) * w(x), lower = 0, upper = Inf)


</code></pre>

<hr>
<h2 id='LCM'>Compute the least common multiple of two numbers.</h2><span id='topic+LCM'></span>

<h3>Description</h3>

<p>A simple algorithm to compute the least common multiple of two numbers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LCM(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LCM_+3A_x">x</code></td>
<td>
<p>an object of class numeric</p>
</td></tr>
<tr><td><code id="LCM_+3A_y">y</code></td>
<td>
<p>an object of class numeric</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The least common multiple of x and y.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>LCM(5,7)
LCM(5,8)
LCM(5,9)
LCM(5,10)
Reduce(LCM, 1:10) # -&gt; 2520
</code></pre>

<hr>
<h2 id='legendre'>Legendre polynomials</h2><span id='topic+legendre'></span>

<h3>Description</h3>

<p>Legendre polynomials as computed by orthopolynom.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>legendre(degree, indeterminate = "x", normalized = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="legendre_+3A_degree">degree</code></td>
<td>
<p>degree of polynomial</p>
</td></tr>
<tr><td><code id="legendre_+3A_indeterminate">indeterminate</code></td>
<td>
<p>indeterminate</p>
</td></tr>
<tr><td><code id="legendre_+3A_normalized">normalized</code></td>
<td>
<p>provide normalized coefficients</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a mpoly object or mpolyList object
</p>


<h3>Author(s)</h3>

<p>David Kahle calling code from the orthopolynom package
</p>


<h3>See Also</h3>

<p><code><a href="orthopolynom.html#topic+legendre.polynomials">orthopolynom::legendre.polynomials()</a></code>,
<a href="http://en.wikipedia.org/wiki/Legendre_polynomials">http://en.wikipedia.org/wiki/Legendre_polynomials</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
legendre(0)
legendre(1)
legendre(2)
legendre(3)
legendre(4)
legendre(5)
legendre(6)

legendre(2)
legendre(2, normalized = TRUE)

legendre(0:5)
legendre(0:5, normalized = TRUE)
legendre(0:5, indeterminate = "t")



# visualize the legendre polynomials

library(ggplot2); theme_set(theme_classic())
library(tidyr)

s &lt;- seq(-1, 1, length.out = 201)
N &lt;- 5 # number of legendre polynomials to plot
(legPolys &lt;- legendre(0:N))

# see ?bernstein for a better understanding of
# how the code below works

df &lt;- data.frame(s, as.function(legPolys)(s))
names(df) &lt;- c("x", paste0("P_", 0:N))
mdf &lt;- gather(df, degree, value, -x)
qplot(x, value, data = mdf, geom = "line", color = degree)


# legendre polynomials and the QR decomposition
n &lt;- 201
x &lt;- seq(-1, 1, length.out = n)
mat &lt;- cbind(1, x, x^2, x^3, x^4, x^5)
Q &lt;- qr.Q(qr(mat))
df &lt;- as.data.frame(cbind(x, Q))
names(df) &lt;- c("x", 0:5)
mdf &lt;- gather(df, degree, value, -x)
qplot(x, value, data = mdf, geom = "line", color = degree)

Q &lt;- apply(Q, 2, function(x) x / x[n])
df &lt;- as.data.frame(cbind(x, Q))
names(df) &lt;- c("x", paste0("P_", 0:5))
mdf &lt;- gather(df, degree, value, -x)
qplot(x, value, data = mdf, geom = "line", color = degree)


# chebyshev polynomials are orthogonal in two ways:
P2 &lt;- as.function(legendre(2))
P3 &lt;- as.function(legendre(3))
P4 &lt;- as.function(legendre(4))

integrate(function(x) P2(x) * P3(x), lower = -1, upper = 1)
integrate(function(x) P2(x) * P4(x), lower = -1, upper = 1)
integrate(function(x) P3(x) * P4(x), lower = -1, upper = 1)

n &lt;- 10000L
u &lt;- runif(n, -1, 1)
2 * mean(P2(u) * P3(u))
2 * mean(P2(u) * P4(u))
2 * mean(P3(u) * P4(u))

(2/n) * sum(P2(u) * P3(u))
(2/n) * sum(P2(u) * P4(u))
(2/n) * sum(P3(u) * P4(u))

</code></pre>

<hr>
<h2 id='lissajous'>Lissajous polynomials</h2><span id='topic+lissajous'></span>

<h3>Description</h3>

<p>The Lissajous polynomials are the implicit (variety) descriptions of the
image of the parametric map x = cos(m t + p), y = sin(n t + q).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lissajous(m, n, p, q, digits = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lissajous_+3A_m">m</code>, <code id="lissajous_+3A_n">n</code>, <code id="lissajous_+3A_p">p</code>, <code id="lissajous_+3A_q">q</code></td>
<td>
<p>Trigonometric coefficients, see examples for description</p>
</td></tr>
<tr><td><code id="lissajous_+3A_digits">digits</code></td>
<td>
<p>The number of digits to round coefficients to, see
<code><a href="#topic+round.mpoly">round.mpoly()</a></code>. This is useful for cleaning terms that are numerically
nonzero, but should be.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a mpoly object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+chebyshev">chebyshev()</a></code>, Merino, J. C (2003). Lissajous figures and Chebyshev
polynomials. The College Mathematics Journal, 34(2), pp. 122-127.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
lissajous(3, 2,  -pi/2, 0)
lissajous(4, 3,  -pi/2, 0)

</code></pre>

<hr>
<h2 id='mp'>Define a multivariate polynomial.</h2><span id='topic+mp'></span><span id='topic+make_indeterminate_list'></span>

<h3>Description</h3>

<p>mp is a smart function which attempts to create a formal mpoly object from a
character string containing the usual representation  of a multivariate
polynomial.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_indeterminate_list(vars)

mp(string, varorder, stars_only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mp_+3A_vars">vars</code></td>
<td>
<p>a character vector of indeterminates</p>
</td></tr>
<tr><td><code id="mp_+3A_string">string</code></td>
<td>
<p>a character string containing a polynomial, see examples</p>
</td></tr>
<tr><td><code id="mp_+3A_varorder">varorder</code></td>
<td>
<p>(optional) order of variables in string</p>
</td></tr>
<tr><td><code id="mp_+3A_stars_only">stars_only</code></td>
<td>
<p>if you format your multiplications using asterisks, setting
this to <code>TRUE</code> will reduce preprocessing time</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class mpoly.
</p>


<h3>Author(s)</h3>

<p>David Kahle <a href="mailto:david@kahle.io">david@kahle.io</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mpoly">mpoly()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
( m &lt;- mp("x + y + x y") )
is.mpoly( m )
unclass(m)


mp("x + 2 y + x^2 y + x y z")
mp("x + 2 y + x^2 y + x y z", varorder = c("y", "z", "x"))

( ms &lt;- mp(c("x + y", "2 x")) )
is.mpolyList(ms)


gradient( mp("x + 2 y + x^2 y + x y z") )
gradient( mp("(x + y)^10") )

# mp and the print methods are kinds of inverses of each other
( polys &lt;- mp(c("x + y", "x - y")) )
strings &lt;- print(polys, silent = TRUE)
strings
mp(strings)

</code></pre>

<hr>
<h2 id='mpoly'>Multivariate polynomials in R.</h2><span id='topic+mpoly'></span><span id='topic+package-mpoly'></span>

<h3>Description</h3>

<p>A package for symbolic computation and more with multivariate polynomials
</p>
<p>mpoly is the most basic function used to create objects of class mpoly.
However, it is not a general purpose function; for that see <code><a href="#topic+mp">mp()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpoly(list, varorder)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mpoly_+3A_list">list</code></td>
<td>
<p>a list from which to construct an mpoly object</p>
</td></tr>
<tr><td><code id="mpoly_+3A_varorder">varorder</code></td>
<td>
<p>(optional) a character vector setting the intrinsic variable
order of the polynomial</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class mpoly.
</p>


<h3>Author(s)</h3>

<p>David Kahle <a href="mailto:david@kahle.io">david@kahle.io</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mp">mp()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>list &lt;- list(
  c(x = 1, coef = 1, y = 0),
  c(x = 0, y = 1, coef = 2),
  c(y = 1, coef = -6),
  c(z = 1, coef = -3, x = 2),
  c(x = 1, coef = 0, x = 3),
  c(t = 1, coef = 4, t = 2, y = 4),
  c(x = 1),
  c(x = 1),
  c(coef = 5),
  c(coef = 5),
  c(coef = -5)
)

mpoly(list) # 3 x  -  4 y  -  3 x^2 z  +  4 y^4 t^3  +  5
mpoly(list, varorder = c("y", "z", "t", "x"))

list &lt;- list(  c(x = 5, x = 2, coef = 5, coef = 6, y = 0) )
mpoly(list)


</code></pre>

<hr>
<h2 id='mpoly-defunct'>Defunct mpoly functions</h2><span id='topic+mpoly-defunct'></span>

<h3>Description</h3>

<p>This is a list of past functions of the mpoly package.
</p>


<h3>Details</h3>

<p>The following are defunct mpoly functions:
</p>

<ul>
<li><p> grobner
</p>
</li></ul>


<hr>
<h2 id='mpoly-equal'>Determine whether two multivariate polynomials are equal.</h2><span id='topic+mpoly-equal'></span><span id='topic++3D+3D.mpoly'></span><span id='topic++3D+3D'></span><span id='topic++21+3D.mpoly'></span>

<h3>Description</h3>

<p>Determine whether two multivariate polynomials are equal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mpoly'
e1 == e2

## S3 method for class 'mpoly'
e1 != e2
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mpoly-equal_+3A_e1">e1</code></td>
<td>
<p>an object of class mpoly</p>
</td></tr>
<tr><td><code id="mpoly-equal_+3A_e2">e2</code></td>
<td>
<p>an object of class mpoly</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
p1 &lt;- mp("x + y + 2 z")
p1 == p1

p2 &lt;- reorder(p1, order = "lex", varorder = c("z","y","x"))
p1 == p2
p2 &lt;- reorder(p1, order = "lex", varorder = c("z","w","y","x"))
p1 == p2
p1 == ( 2 * p2 )

p1 &lt;- mp("x + 1")
p2 &lt;- mp("x + 1")
identical(p1, p2)
p1 == p2

mp("x + 1") == mp("y + 1")
mp("2") == mp("1")
mp("1") == mp("1")
mp("0") == mp("-0")


</code></pre>

<hr>
<h2 id='mpolyArithmetic'>Arithmetic with multivariate polynomials</h2><span id='topic+mpolyArithmetic'></span><span id='topic++2B.mpoly'></span><span id='topic+-.mpoly'></span><span id='topic++2A.mpoly'></span><span id='topic++5E.mpoly'></span><span id='topic++5E.mpolyList'></span>

<h3>Description</h3>

<p>Arithmetic with multivariate polynomials
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mpoly'
e1 + e2

## S3 method for class 'mpoly'
e1 - e2

## S3 method for class 'mpoly'
e1 * e2

## S3 method for class 'mpoly'
e1 ^ e2

## S3 method for class 'mpolyList'
e1 ^ e2
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mpolyArithmetic_+3A_e1">e1</code></td>
<td>
<p>an object of class mpoly</p>
</td></tr>
<tr><td><code id="mpolyArithmetic_+3A_e2">e2</code></td>
<td>
<p>an object of class mpoly</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class mpoly
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
p &lt;- mp("x + y")
p + p
p - p
p * p
p^2
p^10


mp("(x+1)^10")
p + 1
2*p



</code></pre>

<hr>
<h2 id='mpolyList'>Define a collection of multivariate polynomials.</h2><span id='topic+mpolyList'></span>

<h3>Description</h3>

<p>Combine a series of mpoly objects into a mpolyList.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpolyList(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mpolyList_+3A_...">...</code></td>
<td>
<p>a series of mpoly objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class mpolyList.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>( p1 &lt;- mp("t^4 - x") )
( p2 &lt;- mp("t^3 - y") )
( p3 &lt;- mp("t^2 - z") )
( ms &lt;- mpolyList(p1, p2, p3) )
is.mpolyList( ms )

mpolyList(mp("x + 1"))
p &lt;- mp("x + 1")
mpolyList(p)

ps &lt;- mp(c("x + 1", "y + 2"))
is.mpolyList(ps)


f &lt;- function(){
  a &lt;- mp("1")
  mpolyList(a)
}
f()


</code></pre>

<hr>
<h2 id='mpolyListArithmetic'>Element-wise arithmetic with vectors of multivariate polynomials.</h2><span id='topic+mpolyListArithmetic'></span><span id='topic++2B.mpolyList'></span><span id='topic+-.mpolyList'></span><span id='topic++2A.mpolyList'></span>

<h3>Description</h3>

<p>Element-wise arithmetic with vectors of multivariate polynomials.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mpolyList'
e1 + e2

## S3 method for class 'mpolyList'
e1 - e2

## S3 method for class 'mpolyList'
e1 * e2
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mpolyListArithmetic_+3A_e1">e1</code></td>
<td>
<p>an object of class mpolyList</p>
</td></tr>
<tr><td><code id="mpolyListArithmetic_+3A_e2">e2</code></td>
<td>
<p>an object of class mpolyList</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class mpolyList.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
( ms1 &lt;- mp( c("x", 'y') ) )
( ms2 &lt;- mp( c("y", '2 x^2') ) )
ms1 + ms2
ms1 - ms2
ms1 * ms2
ms1^3

</code></pre>

<hr>
<h2 id='partitions'>Enumerate the partitions of an integer</h2><span id='topic+partitions'></span>

<h3>Description</h3>

<p>Determine all unrestricted partitions of an integer.  This function is
equivalent to the function parts in the partitions package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partitions(n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="partitions_+3A_n">n</code></td>
<td>
<p>an integer</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix whose rows are the n-tuples
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin, from package partitions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>partitions(5)
str(partitions(5))
</code></pre>

<hr>
<h2 id='permutations'>Determine all permutations of a set.</h2><span id='topic+permutations'></span>

<h3>Description</h3>

<p>An implementation of the Steinhaus-Johnson-Trotter permutation algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permutations(set)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="permutations_+3A_set">set</code></td>
<td>
<p>a set</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix whose rows are the permutations of set
</p>


<h3>Examples</h3>

<pre><code class='language-R'>permutations(1:3)
permutations(c('first','second','third'))
permutations(c(1,1,3))
apply(permutations(letters[1:6]), 1, paste, collapse = '')
</code></pre>

<hr>
<h2 id='plug'>Switch indeterminates in a polynomial</h2><span id='topic+plug'></span>

<h3>Description</h3>

<p>Switch indeterminates in a polynomial
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plug(p, indeterminate, value)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plug_+3A_p">p</code></td>
<td>
<p>a polynomial</p>
</td></tr>
<tr><td><code id="plug_+3A_indeterminate">indeterminate</code></td>
<td>
<p>the indeterminate in the polynomial to switch</p>
</td></tr>
<tr><td><code id="plug_+3A_value">value</code></td>
<td>
<p>the value/indeterminate to substitute</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an mpoly object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# on an mpoly
(p &lt;- mp("(x+y)^3"))
plug(p, "x", 5)
plug(p, "x", "t")
plug(p, "x", "y")
plug(p, "x", mp("2 y"))

plug(p, "x", mp("x + y"))
mp("((x+y)+y)^3")

# on an mpolyList
ps &lt;- mp(c("x+y", "x+1"))
plug(ps, "x", 1)

</code></pre>

<hr>
<h2 id='predicates'>mpoly predicate functions</h2><span id='topic+predicates'></span><span id='topic+is.constant'></span><span id='topic+is.mpoly'></span><span id='topic+is.unipoly'></span><span id='topic+is.bernstein'></span><span id='topic+is.bezier'></span><span id='topic+is.chebyshev'></span><span id='topic+is.mpolyList'></span><span id='topic+is.linear'></span>

<h3>Description</h3>

<p>Various functions to deal with mpoly and mpolyList objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.constant(x)

is.mpoly(x)

is.unipoly(x)

is.bernstein(x)

is.bezier(x)

is.chebyshev(x)

is.mpolyList(x)

is.linear(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predicates_+3A_x">x</code></td>
<td>
<p>object to be tested</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of logicals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
p &lt;- mp("5")
is.mpoly(p)
is.constant(p)

is.constant(mp(c("x + 1", "7", "y - 2")))

p &lt;- mp("x + y")
is.mpoly(p)

is.mpolyList(mp(c("x + 1", "y - 1")))



is.linear(mp("0"))
is.linear(mp("x + 1"))
is.linear(mp("x + y"))
is.linear(mp(c("0", "x + y")))

is.linear(mp("x + x y"))
is.linear(mp(c("x + x y", "x")))


(p &lt;- bernstein(2, 5))
is.mpoly(p)
is.bernstein(p)

(p &lt;- chebyshev(5))
is.mpoly(p)
is.chebyshev(p)
str(p)
</code></pre>

<hr>
<h2 id='print.mpoly'>Pretty printing of multivariate polynomials.</h2><span id='topic+print.mpoly'></span>

<h3>Description</h3>

<p>This is the major function used to view multivariate polynomials.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mpoly'
print(x, varorder, order, stars = FALSE, silent =
  FALSE, ..., plus_pad = 2L, times_pad = 1L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.mpoly_+3A_x">x</code></td>
<td>
<p>an object of class mpoly</p>
</td></tr>
<tr><td><code id="print.mpoly_+3A_varorder">varorder</code></td>
<td>
<p>the order of the variables</p>
</td></tr>
<tr><td><code id="print.mpoly_+3A_order">order</code></td>
<td>
<p>a total order used to order the monomials in the printing</p>
</td></tr>
<tr><td><code id="print.mpoly_+3A_stars">stars</code></td>
<td>
<p>print the multivariate polynomial in the more computer-friendly
asterisk notation (default FALSE)</p>
</td></tr>
<tr><td><code id="print.mpoly_+3A_silent">silent</code></td>
<td>
<p>logical; if TRUE, suppresses output</p>
</td></tr>
<tr><td><code id="print.mpoly_+3A_...">...</code></td>
<td>
<p>additional parameters to go to <code><a href="base.html#topic+cat">base::cat()</a></code></p>
</td></tr>
<tr><td><code id="print.mpoly_+3A_plus_pad">plus_pad</code></td>
<td>
<p>number of spaces to the left and right of plus sign</p>
</td></tr>
<tr><td><code id="print.mpoly_+3A_times_pad">times_pad</code></td>
<td>
<p>number of spaces to the left and right of times sign</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisible string of the printed object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mp("-x^5 - 3 y^2 + x y^3 - 1")


(p &lt;- mp("2 x^5  -  3 y^2  +  x y^3"))
print(p) # same
print(p, silent = TRUE)
s &lt;- print(p, silent = TRUE)
s

print(p, order = "lex") # -&gt; 2 x^5  +  x y^3  -  3 y^2
print(p, order = "lex", varorder = c("y","x")) # -&gt; y^3 x  -  3 y^2  +  2 x^5
print(p, varorder = c("y","x")) # -&gt; y^3 x  -  3 y^2  +  2 x^5

# this is mostly used internally
print(p, stars = TRUE)
print(p, stars = TRUE, times_pad = 0L)
print(p, stars = TRUE, times_pad = 0L, plus_pad = 1L)
print(p, stars = TRUE, times_pad = 0L, plus_pad = 0L)
print(p, plus_pad = 1L)

</code></pre>

<hr>
<h2 id='print.mpolyList'>Pretty printing of a list of multivariate polynomials.</h2><span id='topic+print.mpolyList'></span>

<h3>Description</h3>

<p>This function iterates print.mpoly on an object of class mpolyList.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mpolyList'
print(
  x,
  varorder = vars(x),
  stars = FALSE,
  order,
  silent = FALSE,
  ...,
  plus_pad = 2L,
  times_pad = 1L
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.mpolyList_+3A_x">x</code></td>
<td>
<p>an object of class mpoly</p>
</td></tr>
<tr><td><code id="print.mpolyList_+3A_varorder">varorder</code></td>
<td>
<p>the order of the variables</p>
</td></tr>
<tr><td><code id="print.mpolyList_+3A_stars">stars</code></td>
<td>
<p>print the multivariate polynomial in the more computer-friendly
asterisk notation (default FALSE)</p>
</td></tr>
<tr><td><code id="print.mpolyList_+3A_order">order</code></td>
<td>
<p>a total order used to order the monomials in the printing</p>
</td></tr>
<tr><td><code id="print.mpolyList_+3A_silent">silent</code></td>
<td>
<p>logical; if TRUE, suppresses output</p>
</td></tr>
<tr><td><code id="print.mpolyList_+3A_...">...</code></td>
<td>
<p>additional parameters to go to <code><a href="base.html#topic+cat">base::cat()</a></code></p>
</td></tr>
<tr><td><code id="print.mpolyList_+3A_plus_pad">plus_pad</code></td>
<td>
<p>number of spaces to the left and right of plus sign</p>
</td></tr>
<tr><td><code id="print.mpolyList_+3A_times_pad">times_pad</code></td>
<td>
<p>number of spaces to the left and right of times sign</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisible character vector of the printed objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mL &lt;- mp(c("x + 1", "y - 1", "x y^2 z  +  x^2 z^2  +  z^2  +  x^3"))
mL
print(mL, order = "lex")
print(mL, order = "glex")
print(mL, order = "grlex")
print(mL, order = "glex", varorder = c("z","y","x"))
print(mL, order = "grlex", varorder = c("z","y","x"))
print(mL, varorder = c("z","y","x"))

(print(mL, varorder = c("z","y","x"), plus_pad = 1L, silent = TRUE))

(print(mL, silent = TRUE, stars = TRUE, plus_pad = 1L, times_pad = 0L))

</code></pre>

<hr>
<h2 id='reorder.mpoly'>Reorder a multivariate polynomial.</h2><span id='topic+reorder.mpoly'></span>

<h3>Description</h3>

<p>This function is used to set the intrinsic order of a multivariate
polynomial. It is used for both the in-term variables and the
terms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mpoly'
reorder(x, varorder = vars(x), order, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reorder.mpoly_+3A_x">x</code></td>
<td>
<p>an object of class mpoly</p>
</td></tr>
<tr><td><code id="reorder.mpoly_+3A_varorder">varorder</code></td>
<td>
<p>the order of the variables</p>
</td></tr>
<tr><td><code id="reorder.mpoly_+3A_order">order</code></td>
<td>
<p>a total order used to order the terms, <code>"lex"</code>, <code>"glex"</code>, or <code>"grlex"</code></p>
</td></tr>
<tr><td><code id="reorder.mpoly_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class mpoly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
list &lt;- list(
  c(x = 1, y = 2, z = 1, coef = 1),
  c(x = 2, y = 0, z = 2, coef = 1),
  c(x = 0, y = 0, z = 2, coef = 1),
  c(x = 3, y = 0, z = 0, coef = 1)
)
(p &lt;- mpoly(list)) # -&gt; x y^2 z  +  x^2 z^2  +  z^2  +  x^3
reorder(p) # -&gt; x y^2 z  +  x^2 z^2  +  z^2  +  x^3
reorder(p, varorder = c("x","y","z"), order = "lex")
    # -&gt; x^3  +  x^2 z^2  +  x y^2 z  +  z^2
reorder(p, varorder = c("x","y","z"), order = "glex")
    # -&gt; x^2 z^2  +  x y^2 z  +  x^3  +  z^2
reorder(p, varorder = c("x","y","z"), order = "grlex")
    # -&gt; x y^2 z  +  x^2 z^2  +  x^3  +  z^2

reorder(mp("x + 1"), varorder = c("y","x","z"), order = "lex")
reorder(mp("x + y"), varorder = c("y","x","z"), order = "lex")
reorder(mp("x y + y + 2 x y z^2"), varorder = c("y","x","z"))
reorder(mp("x^2 + y x + y"), order = "lex")


</code></pre>

<hr>
<h2 id='round.mpoly'>Round the coefficients of a polynomial</h2><span id='topic+round.mpoly'></span>

<h3>Description</h3>

<p>Round the coefficients of an mpoly object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mpoly'
round(x, digits = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="round.mpoly_+3A_x">x</code></td>
<td>
<p>an mpoly object</p>
</td></tr>
<tr><td><code id="round.mpoly_+3A_digits">digits</code></td>
<td>
<p>number of digits to round to</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the rounded mpoly object
</p>


<h3>Author(s)</h3>

<p>David Kahle <a href="mailto:david@kahle.io">david@kahle.io</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mp">mp()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
p &lt;- mp("x + 3.14159265")^4
p
round(p)
round(p, 0)

## Not run: 
library(plyr)
library(ggplot2)
library(stringr)

n &lt;- 101
s &lt;- seq(-5, 5, length.out = n)

# one dimensional case
df &lt;- data.frame(x = s)
df &lt;- mutate(df, y = -x^2 + 2*x - 3 + rnorm(n, 0, 2))
qplot(x, y, data = df)
mod &lt;- lm(y ~ x + I(x^2), data = df)
p &lt;- as.mpoly(mod)
qplot(x, y, data = df) +
  stat_function(fun = as.function(p), colour = 'red')

p
round(p, 1)
qplot(x, y, data = df) +
  stat_function(fun = as.function(p), colour = 'red') +
  stat_function(fun = as.function(round(p,1)), colour = 'blue')



## End(Not run)

</code></pre>

<hr>
<h2 id='solve_unipoly'>Solve a univariate mpoly with polyroot</h2><span id='topic+solve_unipoly'></span>

<h3>Description</h3>

<p>Solve a univariate mpoly with polyroot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solve_unipoly(mpoly, real_only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="solve_unipoly_+3A_mpoly">mpoly</code></td>
<td>
<p>an mpoly</p>
</td></tr>
<tr><td><code id="solve_unipoly_+3A_real_only">real_only</code></td>
<td>
<p>return only real solutions?</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
solve_unipoly(mp("x^2 - 1")) # check x = -1, 1
solve_unipoly(mp("x^2 - 1"), real_only = TRUE)

</code></pre>

<hr>
<h2 id='swap'>Swap polynomial indeterminates</h2><span id='topic+swap'></span>

<h3>Description</h3>

<p>Swap polynomial indeterminates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swap(p, variable, replacement)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="swap_+3A_p">p</code></td>
<td>
<p>polynomial</p>
</td></tr>
<tr><td><code id="swap_+3A_variable">variable</code></td>
<td>
<p>the variable in the polynomial to replace</p>
</td></tr>
<tr><td><code id="swap_+3A_replacement">replacement</code></td>
<td>
<p>the replacement variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a mpoly object
</p>


<h3>Author(s)</h3>

<p>David Kahle
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
(p &lt;- mp("(x + y)^2"))
swap(p, "x", "t")

## the meta data is retained
(p &lt;- bernstein(3, 5))
(p2 &lt;- swap(p, "x", "t"))
is.bernstein(p2)

(p &lt;- chebyshev(3))
(p2 &lt;- swap(p, "x", "t"))
is.chebyshev(p2)


</code></pre>

<hr>
<h2 id='terms.mpoly'>Extract the terms of a multivariate polynomial.</h2><span id='topic+terms.mpoly'></span>

<h3>Description</h3>

<p>Compute the terms of an mpoly object as a mpolyList.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mpoly'
terms(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="terms.mpoly_+3A_x">x</code></td>
<td>
<p>an object of class mpoly</p>
</td></tr>
<tr><td><code id="terms.mpoly_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class mpolyList.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run:  .Deprecated issues a warning

x &lt;- mp("x^2 - y + x y z")
terms(x)
monomials(x)


## End(Not run)

</code></pre>

<hr>
<h2 id='tuples'>Determine all n-tuples using the elements of a set.</h2><span id='topic+tuples'></span>

<h3>Description</h3>

<p>Determine all n-tuples using the elements of a set.  This is really just a
simple wrapper for expand.grid, so it is not optimized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tuples(set, n = length(set), repeats = FALSE, list = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tuples_+3A_set">set</code></td>
<td>
<p>a set</p>
</td></tr>
<tr><td><code id="tuples_+3A_n">n</code></td>
<td>
<p>length of each tuple</p>
</td></tr>
<tr><td><code id="tuples_+3A_repeats">repeats</code></td>
<td>
<p>if set contains duplicates, should the result?</p>
</td></tr>
<tr><td><code id="tuples_+3A_list">list</code></td>
<td>
<p>tuples as list?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix whose rows are the n-tuples
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tuples(1:2, 3)
tuples(1:2, 3, list = TRUE)

apply(tuples(c("x","y","z"), 3), 1, paste, collapse = "")

# multinomial coefficients
r &lt;- 2 # number of variables, e.g. x, y
n &lt;- 2 # power, e.g. (x+y)^2
apply(burst(n,r), 1, function(v) factorial(n)/ prod(factorial(v))) # x, y, xy
mp("x + y")^n

r &lt;- 2 # number of variables, e.g. x, y
n &lt;- 3 # power, e.g. (x+y)^3
apply(burst(n,r), 1, function(v) factorial(n)/ prod(factorial(v)))
mp("x + y")^n

r &lt;- 3 # number of variables, e.g. x, y, z
n &lt;- 2 # power, e.g. (x+y+z)^2
apply(burst(n,r), 1, function(v) factorial(n)/ prod(factorial(v))) # x, y, z, xy, xz, yz
mp("x + y + z")^n


</code></pre>

<hr>
<h2 id='vars'>Determine the variables in a mpoly object.</h2><span id='topic+vars'></span>

<h3>Description</h3>

<p>Determine the variables in a mpoly object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vars(p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vars_+3A_p">p</code></td>
<td>
<p>An mpoly or mpolyList object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of the variable names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
p &lt;- mp("x + y^2")
vars(p)

p &lt;- mp(c("x + y^2", "y - 2 x"))
vars(p)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
