<!DOCTYPE html><html><head><title>Help for package APPEstimation</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {APPEstimation}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#APPEstimation-package'>
<p>R function to calculate model performance measure adjusted for</p>
predictor distributions.</a></li>
<li><a href='#appe.glm'>
<p><code class="reqn">C</code>-statistics adjusted for predictor distributions</p></a></li>
<li><a href='#appe.lm'>
<p><code class="reqn">L_1</code> and <code class="reqn">L_2</code> errors adjusted for predictor distributions</p></a></li>
<li><a href='#cvalest.bin'>
<p>Estimation of <code class="reqn">C</code>-statistics</p></a></li>
<li><a href='#densratio.appe'>
<p>A wrapper function</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Adjusted Prediction Model Performance Estimation</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>densratio</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-1-4</td>
</tr>
<tr>
<td>Author:</td>
<td>Eisuke Inoue, Hajime Uno</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Eisuke Inoue &lt;eisuke.inoue@marianna-u.ac.jp&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Calculating predictive model performance measures adjusted for predictor distributions using density ratio method (Sugiyama et al., (2012, ISBN:9781139035613)). L1 and L2 error for continuous outcome and C-statistics for binomial outcome are computed. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-01-05 02:55:47 UTC; inoue</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-01-05 12:30:40 UTC</td>
</tr>
</table>
<hr>
<h2 id='APPEstimation-package'>
R function to calculate model performance measure adjusted for
predictor distributions. 
</h2><span id='topic+APPEstimation-package'></span><span id='topic+APPEstimation'></span>

<h3>Description</h3>

<p>This package provides the function to estimate model performance
measures (<code class="reqn">L_1</code>, <code class="reqn">L_2</code>, <code class="reqn">C</code>-statistics). The difference in
the distribution of predictors between two datasets (training and
validation) is adjusted by a density ratio estimate. 
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> APPEstimation</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Adjusted Prediction Model Performance Estimation</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.1.1</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> densratio</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2018-1-4</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Eisuke Inoue, Hajime Uno</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Eisuke Inoue &lt;eisuke.inoue@marianna-u.ac.jp&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Calculating predictive model performance measures adjusted for predictor distributions using density ratio method (Sugiyama et al., (2012, ISBN:9781139035613)). L1 and L2 error for continuous outcome and C-statistics for binomial outcome are computed. </td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Index of help topics:
</p>
<pre>
APPEstimation-package   R function to calculate model performance
                        measure adjusted for predictor distributions.
appe.glm                C-statistics adjusted for predictor
                        distributions
appe.lm                 L_1 and L_2 errors adjusted for predictor
                        distributions
cvalest.bin             Estimation of C-statistics
densratio.appe          A wrapper function
</pre>


<h3>Author(s)</h3>

<p>Eisuke Inoue, Hajime Uno
</p>
<p>Maintainer: Eisuke Inoue &lt;eisuke.inoue@marianna-u.ac.jp&gt;
</p>


<h3>References</h3>

<p>Sugiyama, M., Suzuki, T. &amp; Kanamori, T. Density Ratio Estimation in
Machine Learning. Cambridge University Press
2012. ISBN:9781139035613.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(100)

# generating learning data
n0  = 100
Z   = cbind(rbeta(n0, 5, 5), rbeta(n0, 5, 5))
Y   = apply(Z, 1, function (xx) {
        rbinom(1, 1, (1/(1+exp(-(sum(c(-2,2,2) * c(1,xx)))))))})
dat = data.frame(Y=Y, Za=Z[,1], Zb=Z[,2])

# the model to be evaluated
mdl = glm(Y~., binomial, data=dat)

# validation dataset, with different centers on predictors
n1   = 100
Z1   = cbind(rbeta(n1, 6, 4), rbeta(n1, 6, 4))
Y1   = apply(Z1, 1, function (xx) {
         rbinom(1, 1, (1/(1+exp(-(sum(c(-2,2,2) * c(1,xx)))))))})
dat1 = data.frame(Y=Y1, Za=Z1[,1], Zb=Z1[,2])

# calculation of L1 and L2 for this model
appe.glm(mdl, dat, dat1, reps=0)
</code></pre>

<hr>
<h2 id='appe.glm'>
<code class="reqn">C</code>-statistics adjusted for predictor distributions
</h2><span id='topic+appe.glm'></span>

<h3>Description</h3>

<p>Calculates adjusted <code class="reqn">C</code> statistics by predictor distributions for
a generalized linear model with binary outcome. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>appe.glm(mdl, dat.train, dat.test, method = "uLSIF", sigma = NULL,
         lambda = NULL, kernel_num = NULL, fold = 5, stabilize = TRUE, 
         qstb = 0.025, reps = 2000, conf.level = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="appe.glm_+3A_mdl">mdl</code></td>
<td>

<p>a <code>glm</code> object describing a prediction model to be evaluated. 
</p>
</td></tr>
<tr><td><code id="appe.glm_+3A_dat.train">dat.train</code></td>
<td>

<p>a dataframe used to construct a prediction model (specified in
<code>mdl</code>), corresponding to a training data. Need to include
outcome and all predictors. 
</p>
</td></tr>
<tr><td><code id="appe.glm_+3A_dat.test">dat.test</code></td>
<td>

<p>a dataframe corresponding to a validation (testing) data. 
Need to include outcome and all predictors. 
</p>
</td></tr>
<tr><td><code id="appe.glm_+3A_method">method</code></td>
<td>

<p>uLSIF or KLIEP.
Same as the argument in <code>densratio</code> function from densratio
package.
</p>
</td></tr>
<tr><td><code id="appe.glm_+3A_sigma">sigma</code></td>
<td>

<p>a positive numeric vector corresponding to candidate values of a
bandwidth for Gaussian kernel.
Same as the argument in <code>densratio</code> function from densratio
package.
</p>
</td></tr>
<tr><td><code id="appe.glm_+3A_lambda">lambda</code></td>
<td>

<p>a positive numeric vector corresponding to candidate values of a
regularization parameter.
Same as the argument in <code>densratio</code> function from densratio
package.
</p>
</td></tr>
<tr><td><code id="appe.glm_+3A_kernel_num">kernel_num</code></td>
<td>

<p>a positive integer corresponding to number of kernels.
Same as the argument in <code>densratio</code> function from densratio
package.
</p>
</td></tr>
<tr><td><code id="appe.glm_+3A_fold">fold</code></td>
<td>

<p>a positive integer corresponding to a number of the folds of
cross-validation in the KLIEP method.
Same as the argument in <code>densratio</code> function from densratio
package.
</p>
</td></tr>
<tr><td><code id="appe.glm_+3A_stabilize">stabilize</code></td>
<td>

<p>a logical value as to whether tail weight stabilization is performed
or not. 
If TRUE, both tails of the estimated density ratio distribution are
replaced by the constant value which is specified at <code>qstb</code>
option. 
</p>
</td></tr>
<tr><td><code id="appe.glm_+3A_qstb">qstb</code></td>
<td>

<p>a positive numerical value less than 1 to control the degree of
weight stabilization. Default value is 0.025, indicating estimated
density ratio values less than the 2.5 percentile and more than the
97.5 percentile are set to 2.5 percentile and 97.5 percentile,
respectively.  
</p>
</td></tr>
<tr><td><code id="appe.glm_+3A_reps">reps</code></td>
<td>

<p>a positive integer to specify bootstrap repetitions. If 0, bootstrap
calculations are not performed. 
</p>
</td></tr>
<tr><td><code id="appe.glm_+3A_conf.level">conf.level</code></td>
<td>

<p>a numerical value indicating a confidence level of interval. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Adjusted and non-adjusted estimates of <code class="reqn">C</code>-statistics are provided
as matrix form.
&quot;Cstat&quot; indicates non-adjusted version, &quot;C adjusted by score&quot;
indicates adjusted version by linear predictors distribution, and
&quot;C adjusted by predictors&quot; indicates adjusted version by
predictor distributions (multi-dimensionally). 
For confidence intervals, &quot;Percentile&quot; indicates a confidence interval
by percentile method and &quot;Approx&quot; indicates approximated versions
by Normal distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(100)

# generating learning data
n0  = 100
Z   = cbind(rbeta(n0, 5, 5), rbeta(n0, 5, 5))
Y   = apply(Z, 1, function (xx) {
        rbinom(1, 1, (1/(1+exp(-(sum(c(-2,2,2) * c(1,xx)))))))})
dat = data.frame(Y=Y, Za=Z[,1], Zb=Z[,2])

# the model to be evaluated
mdl = glm(Y~., binomial, data=dat)

# validation dataset, with different centers on predictors
n1   = 100
Z1   = cbind(rbeta(n1, 6, 4), rbeta(n1, 6, 4))
Y1   = apply(Z1, 1, function (xx) {
         rbinom(1, 1, (1/(1+exp(-(sum(c(-2,2,2) * c(1,xx)))))))})
dat1 = data.frame(Y=Y1, Za=Z1[,1], Zb=Z1[,2])

# calculation of L1 and L2 for this model
appe.glm(mdl, dat, dat1, reps=0)
</code></pre>

<hr>
<h2 id='appe.lm'>
<code class="reqn">L_1</code> and <code class="reqn">L_2</code> errors adjusted for predictor distributions
</h2><span id='topic+appe.lm'></span>

<h3>Description</h3>

<p>Calculates adjusted <code class="reqn">L_1</code> and <code class="reqn">L_2</code> errors by predictor
distributions for a linear model. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>appe.lm(mdl, dat.train, dat.test, method = "uLSIF", sigma = NULL,
        lambda = NULL, kernel_num = NULL, fold = 5, stabilize = TRUE,
        qstb = 0.025, reps = 2000, conf.level = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="appe.lm_+3A_mdl">mdl</code></td>
<td>

<p>a <code>lm</code> object describing a prediction model to be evaluated. 
</p>
</td></tr>
<tr><td><code id="appe.lm_+3A_dat.train">dat.train</code></td>
<td>

<p>same as in <code>appe.glm</code>.
</p>
</td></tr>
<tr><td><code id="appe.lm_+3A_dat.test">dat.test</code></td>
<td>

<p>same as in <code>appe.glm</code>.
</p>
</td></tr>
<tr><td><code id="appe.lm_+3A_method">method</code></td>
<td>

<p>same as in <code>appe.glm</code>.
</p>
</td></tr>
<tr><td><code id="appe.lm_+3A_sigma">sigma</code></td>
<td>

<p>same as in <code>appe.glm</code>.
</p>
</td></tr>
<tr><td><code id="appe.lm_+3A_lambda">lambda</code></td>
<td>

<p>same as in <code>appe.glm</code>.
</p>
</td></tr>
<tr><td><code id="appe.lm_+3A_kernel_num">kernel_num</code></td>
<td>

<p>same as in <code>appe.glm</code>.
</p>
</td></tr>
<tr><td><code id="appe.lm_+3A_fold">fold</code></td>
<td>

<p>same as in <code>appe.glm</code>.
</p>
</td></tr>
<tr><td><code id="appe.lm_+3A_stabilize">stabilize</code></td>
<td>

<p>same as in <code>appe.glm</code>.
</p>
</td></tr>
<tr><td><code id="appe.lm_+3A_qstb">qstb</code></td>
<td>

<p>same as in <code>appe.glm</code>.
</p>
</td></tr>
<tr><td><code id="appe.lm_+3A_reps">reps</code></td>
<td>

<p>same as in <code>appe.glm</code>.
</p>
</td></tr>
<tr><td><code id="appe.lm_+3A_conf.level">conf.level</code></td>
<td>

<p>same as in <code>appe.glm</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Adjusted and non-adjusted estimates of <code class="reqn">L_1</code> and <code class="reqn">L_2</code> errors
are provided as matrix form. 
&quot;L1&quot; and &quot;L2&quot; indicate non-adjusted versions, &quot;L1 adjusted by score&quot;
and &quot;L2 adjusted by score&quot; indicate adjusted versions by linear
predictors distribution, &quot;L1 adjusted by predictors&quot; and
&quot;L2 adjusted by predictors&quot; indicate adjusted versions by
predictor distributions (multi-dimensionally). 
For confidence intervals, &quot;Percentile&quot; indicates a confidence interval
by percentile method and &quot;Approx&quot; indicates approximated versions
by Normal distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(100)

# generating development data
n0  = 100
Z   = cbind(rbeta(n0, 3, 3), rbeta(n0, 3, 3))
Y   = apply(Z, 1, function(xx) { rlnorm(1, sum(c(1, 1) * xx), 0.3) })
dat = data.frame(Za=Z[,1], Zb=Z[,2], Y=Y)

# the model to be evaluated
mdl = lm(Y~ Za + Zb, data=dat)

# generating validation dataset 
n1   = 100
Z1   = cbind(rbeta(n0, 3.5, 2.5), rbeta(n0, 3.5, 2.5))
Y1   = apply(Z1, 1, function(xx) { rlnorm(1, sum(c(1, 1) * xx), 0.3) })
dat1 = data.frame(Za=Z1[,1], Zb=Z1[,2], Y=Y1)

# calculation of L1 and L2 for this model
appe.lm(mdl, dat, dat1, reps=0)
</code></pre>

<hr>
<h2 id='cvalest.bin'>
Estimation of <code class="reqn">C</code>-statistics
</h2><span id='topic+cvalest.bin'></span>

<h3>Description</h3>

<p>Calculates <code class="reqn">C</code>-statistics. Individual case  weight can be
incorporated. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  cvalest.bin(Y, scr, wgt = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cvalest.bin_+3A_y">Y</code></td>
<td>

<p>a numerical vector of inary outcome, either 0 or 1. 
</p>
</td></tr>
<tr><td><code id="cvalest.bin_+3A_scr">scr</code></td>
<td>

<p>a numerical vector of continuous variable. 
</p>
</td></tr>
<tr><td><code id="cvalest.bin_+3A_wgt">wgt</code></td>
<td>

<p>a numerical vector corresponding to individuatl weight.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code class="reqn">C</code>-statistics is provided. 
</p>

<hr>
<h2 id='densratio.appe'>
A wrapper function
</h2><span id='topic+densratio.appe'></span>

<h3>Description</h3>

<p>A wrapper function to use &quot;densratio&quot; function from the densratio package. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>densratio.appe(xtrain, xtest, method = "uLSIF", sigma = NULL,
               lambda = NULL, kernel_num = NULL, fold = 5,
               stabilize = TRUE,  qstb = 0.025)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="densratio.appe_+3A_xtrain">xtrain</code></td>
<td>

<p>a dataframe used to construct a prediction model. 
</p>
</td></tr>
<tr><td><code id="densratio.appe_+3A_xtest">xtest</code></td>
<td>

<p>a dataframe corresponding to a validation (testing) data. 
</p>
</td></tr>
<tr><td><code id="densratio.appe_+3A_method">method</code></td>
<td>

<p>same as in <code>appe.glm</code>.
</p>
</td></tr>
<tr><td><code id="densratio.appe_+3A_sigma">sigma</code></td>
<td>

<p>same as in <code>appe.glm</code>.
</p>
</td></tr>
<tr><td><code id="densratio.appe_+3A_lambda">lambda</code></td>
<td>

<p>same as in <code>appe.glm</code>.
</p>
</td></tr>
<tr><td><code id="densratio.appe_+3A_kernel_num">kernel_num</code></td>
<td>

<p>same as in <code>appe.glm</code>.
</p>
</td></tr>
<tr><td><code id="densratio.appe_+3A_fold">fold</code></td>
<td>

<p>same as in <code>appe.glm</code>.
</p>
</td></tr>
<tr><td><code id="densratio.appe_+3A_stabilize">stabilize</code></td>
<td>

<p>same as in <code>appe.glm</code>.
</p>
</td></tr>
<tr><td><code id="densratio.appe_+3A_qstb">qstb</code></td>
<td>

<p>same as in <code>appe.glm</code>.
</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
