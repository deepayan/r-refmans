<!DOCTYPE html><html><head><title>Help for package rquery</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rquery}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#actualize_join_plan'><p>Execute an ordered sequence of left joins.</p></a></li>
<li><a href='#affine_transform'><p>Implement an affine transformaton</p></a></li>
<li><a href='#apply_right_S4,ANY,rquery_db_info-method'><p>Apply pipeline to a database.</p></a></li>
<li><a href='#apply_right_S4,data.frame,relop_arrow-method'><p>S4 dispatch method for apply_right.</p></a></li>
<li><a href='#apply_right_S4,relop_arrow,relop_arrow-method'><p>S4 dispatch method for apply_right.</p></a></li>
<li><a href='#apply_right.relop'><p>Execute pipeline treating pipe_left_arg as local data to</p>
be copied into database.</a></li>
<li><a href='#arrow'><p>Data arrow</p></a></li>
<li><a href='#assign_slice'><p>Assign a value to a slice of data (set of rows meeting a condition, and specified set of columns).</p></a></li>
<li><a href='#build_join_plan'><p>Build a join plan.</p></a></li>
<li><a href='#column_names'><p>Return column names</p></a></li>
<li><a href='#columns_used'><p>Return columns used</p></a></li>
<li><a href='#commencify'><p>Hyderdrive (science fiction show) synonym for <code>execute</code></p></a></li>
<li><a href='#complete_design'><p>Complete an experimental design.</p></a></li>
<li><a href='#convert_yaml_to_pipeline'><p>Convert a series of simple objects (from YAML deserializaton) to an rquery pipeline.</p></a></li>
<li><a href='#count_null_cols'><p>Count NULLs per row for given column set.</p></a></li>
<li><a href='#db_td'><p>Construct a table description from a database source.</p></a></li>
<li><a href='#describe_tables'><p>Build a nice description of a table.</p></a></li>
<li><a href='#drop_columns'><p>Make a drop columns node (not a relational operation).</p></a></li>
<li><a href='#ex'><p>Execute a wrapped execution pipeline.</p></a></li>
<li><a href='#example_employee_date'><p>Build some example tables (requires DBI).</p></a></li>
<li><a href='#execute'><p>Execute an operator tree, bringing back the result to memory.</p></a></li>
<li><a href='#expand_grid'><p>Cross product vectors in database.</p></a></li>
<li><a href='#extend'><p>Extend data by adding more columns.</p></a></li>
<li><a href='#extend_se'><p>Extend data by adding more columns.</p></a></li>
<li><a href='#format_node'><p>Format a single node for printing.</p></a></li>
<li><a href='#getDBOption'><p>Get a database connection option.</p></a></li>
<li><a href='#graph_join_plan'><p>Build a draw-able specification of the join diagram</p></a></li>
<li><a href='#if_else_block'><p>Build a sequence of statements simulating an if/else block-<code>if(){}else{}</code>.</p></a></li>
<li><a href='#if_else_op'><p>Build a <code>relop</code> node simulating a per-row block-<code>if(){}else{}</code>.</p></a></li>
<li><a href='#inspect_join_plan'><p>check that a join plan is consistent with table descriptions.</p></a></li>
<li><a href='#key_inspector_all_cols'><p>Return all columns as guess of preferred primary keys.</p></a></li>
<li><a href='#key_inspector_postgresql'><p>Return all primary key columns as guess at preferred primary keys for a PostgreSQL handle.</p></a></li>
<li><a href='#key_inspector_sqlite'><p>Return all primary key columns as guess at preferred primary keys for a SQLite handle.</p></a></li>
<li><a href='#local_td'><p>Construct a table description of a local data.frame.</p></a></li>
<li><a href='#lookup_by_column'><p>Use one column to pick values from other columns.</p></a></li>
<li><a href='#make_assignments'><p>Make a list of assignments, applying many functions to many columns.</p></a></li>
<li><a href='#map_column_values'><p>Remap values in a set of columns.</p></a></li>
<li><a href='#mark_null_cols'><p>Indicate NULLs per row for given column set.</p></a></li>
<li><a href='#materialize'><p>Materialize an optree as a table.</p></a></li>
<li><a href='#materialize_node'><p>Create a materialize node.</p></a></li>
<li><a href='#materialize_sql'><p>Materialize a user supplied SQL statement as a table.</p></a></li>
<li><a href='#mk_td'><p>Make a table description directly.</p></a></li>
<li><a href='#natural_join'><p>Make a natural_join node.</p></a></li>
<li><a href='#non_sql_node'><p>Wrap a non-SQL node.</p></a></li>
<li><a href='#normalize_cols'><p>Build an optree pipeline that normalizes a set of columns so each column sums to one in each partition.</p></a></li>
<li><a href='#null_replace'><p>Create a null_replace node.</p></a></li>
<li><a href='#op_diagram'><p>Build a diagram of a optree pipeline.</p></a></li>
<li><a href='#order_expr'><p>Make a order_expr node.</p></a></li>
<li><a href='#order_expr_se'><p>Make a order_expr node.</p></a></li>
<li><a href='#order_rows'><p>Make an orderby node (not a relational operation).</p></a></li>
<li><a href='#orderby'><p>Make an orderby node (not a relational operation).</p></a></li>
<li><a href='#pick_top_k'><p>Build an optree pipeline that selects up to the top k rows from each group in the given order.</p></a></li>
<li><a href='#pre_sql_fn'><p>pre_sql_token funtion name</p></a></li>
<li><a href='#pre_sql_identifier'><p>pre_sql_identifier: abstract name of a column and where it is comming from</p></a></li>
<li><a href='#pre_sql_string'><p>pre_sql_string</p></a></li>
<li><a href='#pre_sql_sub_expr'><p>pre_sql_sub_expr</p></a></li>
<li><a href='#pre_sql_to_query'><p>Return SQL transform of tokens.</p></a></li>
<li><a href='#pre_sql_to_query.pre_sql_sub_expr'><p>Convert a pre_sql token object to SQL query text.</p></a></li>
<li><a href='#pre_sql_to_query.pre_sql_token'><p>Convert a pre_sql token object to SQL query text.</p></a></li>
<li><a href='#pre_sql_token'><p>pre_sql_token</p></a></li>
<li><a href='#project'><p>project data by grouping, and adding aggregate columns.</p></a></li>
<li><a href='#project_se'><p>project data by grouping, and adding aggregate columns.</p></a></li>
<li><a href='#quantile_cols'><p>Compute quantiles of specified columns</p>
(without interpolation, needs a database with window functions).</a></li>
<li><a href='#quantile_node'><p>Compute quantiles over non-NULL values</p>
(without interpolation, needs a database with window functions).</a></li>
<li><a href='#quote_identifier'><p>Quote an identifier.</p></a></li>
<li><a href='#quote_literal'><p>Quote a value</p></a></li>
<li><a href='#quote_string'><p>Quote a string</p></a></li>
<li><a href='#quote_table_name'><p>Quote a table name.</p></a></li>
<li><a href='#rename_columns'><p>Make a rename columns node (copies columns not renamed).</p></a></li>
<li><a href='#row_counts'><p>Build an optree pipeline counts rows.</p></a></li>
<li><a href='#rq_colnames'><p>List table column names.</p></a></li>
<li><a href='#rq_coltypes'><p>Get column types by example values as a data.frame.</p></a></li>
<li><a href='#rq_connection_advice'><p>Get advice for a DB connection (beyond tests).</p></a></li>
<li><a href='#rq_connection_name'><p>Build a canonical name for a db connection class.</p></a></li>
<li><a href='#rq_connection_tests'><p>Try and test database for some option settings.</p></a></li>
<li><a href='#rq_copy_to'><p>Copy local R table to remote data handle.</p></a></li>
<li><a href='#rq_execute'><p>Execute a query, typically an update that is not supposed to return results.</p></a></li>
<li><a href='#rq_function_mappings'><p>Return function mappings for a connection</p></a></li>
<li><a href='#rq_get_query'><p>Execute a get query, typically a non-update that is supposed to return results.</p></a></li>
<li><a href='#rq_head'><p>Get head of db table</p></a></li>
<li><a href='#rq_nrow'><p>Count rows and return as numeric</p></a></li>
<li><a href='#rq_remove_table'><p>Remove table</p></a></li>
<li><a href='#rq_table_exists'><p>Check if a table exists.</p></a></li>
<li><a href='#rquery_apply_to_data_frame'><p>Execute optree in an environment where d is the only data.</p></a></li>
<li><a href='#rquery_db_info'><p>Build a db information stand-in</p></a></li>
<li><a href='#rquery_default_db_info'><p>An example <code>rquery_db_info</code> object useful for formatting <code>SQL</code> without a database connection.</p></a></li>
<li><a href='#rquery_default_methods'><p>Default to_sql method implementations.</p></a></li>
<li><a href='#rquery-package'><p><code>rquery</code>: Relational Query Generator for Data Manipulation</p></a></li>
<li><a href='#rstr'><p>Quick look at remote data</p></a></li>
<li><a href='#rsummary'><p>Compute usable summary of columns of remote table.</p></a></li>
<li><a href='#rsummary_node'><p>Create an rsumary relop operator node.</p></a></li>
<li><a href='#select_columns'><p>Make a select columns node (not a relational operation).</p></a></li>
<li><a href='#select_rows'><p>Make a select rows node.</p></a></li>
<li><a href='#select_rows_se'><p>Make a select rows node.</p></a></li>
<li><a href='#set_indicator'><p>Make a set indicator node.</p></a></li>
<li><a href='#setDBOpt'><p>Set a database connection option.</p></a></li>
<li><a href='#setDBOption'><p>Set a database connection option.</p></a></li>
<li><a href='#sql_expr_set'><p>Build a query that applies a SQL expression to a set of columns.</p></a></li>
<li><a href='#sql_node'><p>Make a general SQL node.</p></a></li>
<li><a href='#str_pre_sql_sub_expr'><p>Structure of a pre_sql_sub_expr</p></a></li>
<li><a href='#tables_used'><p>Return vector of table names used.</p></a></li>
<li><a href='#theta_join'><p>Make a theta_join node.</p></a></li>
<li><a href='#theta_join_se'><p>Make a theta_join node.</p></a></li>
<li><a href='#to_sql'><p>Return SQL implementation of operation tree.</p></a></li>
<li><a href='#to_transport_representation'><p>Convert an rquery op diagram to a simple representation, appropriate for conversion to YAML.</p></a></li>
<li><a href='#tokenize_for_SQL'><p>Cross-parse from an R parse tree into SQL.</p></a></li>
<li><a href='#topo_sort_tables'><p>Topologically sort join plan so values are available before uses.</p></a></li>
<li><a href='#unionall'><p>Make an unionall node (not a relational operation).</p></a></li>
<li><a href='#wrap'><p>Wrap a data frame for later execution.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Relational Query Generator for Data Manipulation at Scale</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.99</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-19</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>John Mount &lt;jmount@win-vector.com&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/WinVector/rquery/">https://github.com/WinVector/rquery/</a>,
<a href="https://winvector.github.io/rquery/">https://winvector.github.io/rquery/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/WinVector/rquery/issues">https://github.com/WinVector/rquery/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>A piped query generator based on Edgar F. Codd's relational
    algebra, and on production experience using 'SQL' and 'dplyr' at big data
    scale.  The design represents an attempt to make 'SQL' more teachable by
    denoting composition by a sequential pipeline notation instead of nested
    queries or functions.   The implementation delivers reliable high 
    performance data processing on large data systems such as 'Spark',
    databases, and 'data.table'. Package features include: data processing trees
    or pipelines as observable objects (able to report both columns
    produced and columns used), optimized 'SQL' generation as an explicit
    user visible table modeling step, plus explicit query reasoning and checking.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0), wrapr (&ge; 2.0.9)</td>
</tr>
<tr>
<td>Imports:</td>
<td>utils, stats, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>DBI, RSQLite, rqdatatable (&ge; 1.3.2), igraph, knitr,
rmarkdown, yaml, tinytest</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-20 00:51:57 UTC; johnmount</td>
</tr>
<tr>
<td>Author:</td>
<td>John Mount [aut, cre],
  Win-Vector LLC [cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-20 02:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='actualize_join_plan'>Execute an ordered sequence of left joins.</h2><span id='topic+actualize_join_plan'></span>

<h3>Description</h3>

<p>Please see <code>vignette('DependencySorting', package = 'rquery')</code> and <code>vignette('joinController', package= 'rquery')</code> for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>actualize_join_plan(
  columnJoinPlan,
  ...,
  jointype = "LEFT",
  add_ind_cols = FALSE,
  checkColClasses = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="actualize_join_plan_+3A_columnjoinplan">columnJoinPlan</code></td>
<td>
<p>columns to join, from <code><a href="#topic+build_join_plan">build_join_plan</a></code> (and likely altered by user).  Note: no column names must intersect with names of the form <code>table_CLEANEDTABNAME_present</code>.</p>
</td></tr>
<tr><td><code id="actualize_join_plan_+3A_...">...</code></td>
<td>
<p>force later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="actualize_join_plan_+3A_jointype">jointype</code></td>
<td>
<p>character, type of join to perform (&quot;LEFT&quot;, &quot;INNER&quot;, &quot;RIGHT&quot;, ...).</p>
</td></tr>
<tr><td><code id="actualize_join_plan_+3A_add_ind_cols">add_ind_cols</code></td>
<td>
<p>logical, if TRUE add indicators showing which tables supplied rows.</p>
</td></tr>
<tr><td><code id="actualize_join_plan_+3A_checkcolclasses">checkColClasses</code></td>
<td>
<p>logical if true check for exact class name matches</p>
</td></tr>
</table>


<h3>Value</h3>

<p>join optree
</p>


<h3>See Also</h3>

<p><code><a href="#topic+describe_tables">describe_tables</a></code>, <code><a href="#topic+build_join_plan">build_join_plan</a></code>, <code><a href="#topic+inspect_join_plan">inspect_join_plan</a></code>, <code><a href="#topic+graph_join_plan">graph_join_plan</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("DBI", quietly = TRUE) &amp;&amp; requireNamespace("RSQLite", quietly = TRUE)) {
  my_db &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
  # example data
  DBI::dbWriteTable(my_db,
                    "meas1",
                    data.frame(id= c(1,2),
                               weight= c(200, 120),
                               height= c(60, 14)))
  DBI::dbWriteTable(my_db,
                    "meas2",
                    data.frame(pid= c(2,3),
                               weight= c(105, 110),
                               width= 1))
  # get the initial description of table defs
  tDesc &lt;- describe_tables(my_db, qc(meas1, meas2))
  # declare keys (and give them consitent names)
  tDesc$keys[[1]] &lt;- list(PatientID= 'id')
  tDesc$keys[[2]] &lt;- list(PatientID= 'pid')
  # build the column join plan
  columnJoinPlan &lt;- build_join_plan(tDesc)
  # decide we don't want the width column
  columnJoinPlan$want[columnJoinPlan$resultColumn=='width'] &lt;- FALSE
  # double check our plan
  if(!is.null(inspect_join_plan(tDesc, columnJoinPlan,
                                checkColClasses= TRUE))) {
    stop("bad join plan")
  }
  # actualize as left join op_tree
  optree &lt;- actualize_join_plan(columnJoinPlan,
                                checkColClasses= TRUE)
  cat(format(optree))
  print(execute(my_db, optree))
  # if(requireNamespace("DiagrammeR", quietly = TRUE)) {
  #   DiagrammeR::grViz(op_diagram(optree))
  # }
  DBI::dbDisconnect(my_db)
}

</code></pre>

<hr>
<h2 id='affine_transform'>Implement an affine transformaton</h2><span id='topic+affine_transform'></span>

<h3>Description</h3>

<p>Implement an affine transformaton
</p>


<h3>Usage</h3>

<pre><code class='language-R'>affine_transform(source, linear_transform, offset, ..., env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="affine_transform_+3A_source">source</code></td>
<td>
<p>relop source (or data.frame source)</p>
</td></tr>
<tr><td><code id="affine_transform_+3A_linear_transform">linear_transform</code></td>
<td>
<p>matrix with row names taken from source column names (inputs), and column names are outputs.</p>
</td></tr>
<tr><td><code id="affine_transform_+3A_offset">offset</code></td>
<td>
<p>vector of offsets with names same as column names of linear_transform.</p>
</td></tr>
<tr><td><code id="affine_transform_+3A_...">...</code></td>
<td>
<p>force later arguments to bind by name</p>
</td></tr>
<tr><td><code id="affine_transform_+3A_env">env</code></td>
<td>
<p>environment to look for values in.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>relop node
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("DBI", quietly = TRUE) &amp;&amp;
    requireNamespace("RSQLite", quietly = TRUE)) {
  my_db &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
  d &lt;- data.frame(AUC = 0.6, R2 = 0.2)
  source &lt;- rq_copy_to(my_db, 'd',
                       d,
                       overwrite = TRUE,
                       temporary = TRUE)
  linear_transform &lt;- matrix(c(1 ,1, 2, -1, 1, 0, 0, 0), nrow = 2)
  rownames(linear_transform) &lt;- c("AUC", "R2")
  colnames(linear_transform) &lt;- c("res1", "res2", "res3", "res4")
  offset &lt;- c(5, 7, 1, 0)
  names(offset) &lt;- colnames(linear_transform)

  optree &lt;- affine_transform(source, linear_transform, offset)
  cat(format(optree))

  sql &lt;- to_sql(optree, my_db)
  cat(sql)

  print(DBI::dbGetQuery(my_db, sql))
  print(as.matrix(d) %*% linear_transform + offset)

  DBI::dbDisconnect(my_db)
}

</code></pre>

<hr>
<h2 id='apply_right_S4+2CANY+2Crquery_db_info-method'>Apply pipeline to a database.</h2><span id='topic+apply_right_S4+2CANY+2Crquery_db_info-method'></span>

<h3>Description</h3>

<p>Apply pipeline to a database with relop 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ANY,rquery_db_info'
apply_right_S4(
  pipe_left_arg,
  pipe_right_arg,
  pipe_environment,
  left_arg_name,
  pipe_string,
  right_arg_name
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply_right_S4+2B2CANY+2B2Crquery_db_info-method_+3A_pipe_left_arg">pipe_left_arg</code></td>
<td>
<p>relop operation tree</p>
</td></tr>
<tr><td><code id="apply_right_S4+2B2CANY+2B2Crquery_db_info-method_+3A_pipe_right_arg">pipe_right_arg</code></td>
<td>
<p>rquery_db_info</p>
</td></tr>
<tr><td><code id="apply_right_S4+2B2CANY+2B2Crquery_db_info-method_+3A_pipe_environment">pipe_environment</code></td>
<td>
<p>environment to evaluate in.</p>
</td></tr>
<tr><td><code id="apply_right_S4+2B2CANY+2B2Crquery_db_info-method_+3A_left_arg_name">left_arg_name</code></td>
<td>
<p>name, if not NULL name of left argument.</p>
</td></tr>
<tr><td><code id="apply_right_S4+2B2CANY+2B2Crquery_db_info-method_+3A_pipe_string">pipe_string</code></td>
<td>
<p>character, name of pipe operator.</p>
</td></tr>
<tr><td><code id="apply_right_S4+2B2CANY+2B2Crquery_db_info-method_+3A_right_arg_name">right_arg_name</code></td>
<td>
<p>name, if not NULL name of right argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>result
</p>

<hr>
<h2 id='apply_right_S4+2Cdata.frame+2Crelop_arrow-method'>S4 dispatch method for apply_right.</h2><span id='topic+apply_right_S4+2Cdata.frame+2Crelop_arrow-method'></span>

<h3>Description</h3>

<p>compose a data.frame and a relop_arrow class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'data.frame,relop_arrow'
apply_right_S4(
  pipe_left_arg,
  pipe_right_arg,
  pipe_environment,
  left_arg_name,
  pipe_string,
  right_arg_name
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply_right_S4+2B2Cdata.frame+2B2Crelop_arrow-method_+3A_pipe_left_arg">pipe_left_arg</code></td>
<td>
<p>left argument</p>
</td></tr>
<tr><td><code id="apply_right_S4+2B2Cdata.frame+2B2Crelop_arrow-method_+3A_pipe_right_arg">pipe_right_arg</code></td>
<td>
<p>pipe_right_arg argument</p>
</td></tr>
<tr><td><code id="apply_right_S4+2B2Cdata.frame+2B2Crelop_arrow-method_+3A_pipe_environment">pipe_environment</code></td>
<td>
<p>environment to evaluate in</p>
</td></tr>
<tr><td><code id="apply_right_S4+2B2Cdata.frame+2B2Crelop_arrow-method_+3A_left_arg_name">left_arg_name</code></td>
<td>
<p>name, if not NULL name of left argument.</p>
</td></tr>
<tr><td><code id="apply_right_S4+2B2Cdata.frame+2B2Crelop_arrow-method_+3A_pipe_string">pipe_string</code></td>
<td>
<p>character, name of pipe operator.</p>
</td></tr>
<tr><td><code id="apply_right_S4+2B2Cdata.frame+2B2Crelop_arrow-method_+3A_right_arg_name">right_arg_name</code></td>
<td>
<p>name, if not NULL name of right argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>result
</p>

<hr>
<h2 id='apply_right_S4+2Crelop_arrow+2Crelop_arrow-method'>S4 dispatch method for apply_right.</h2><span id='topic+apply_right_S4+2Crelop_arrow+2Crelop_arrow-method'></span>

<h3>Description</h3>

<p>compose two relop_arrow classes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'relop_arrow,relop_arrow'
apply_right_S4(
  pipe_left_arg,
  pipe_right_arg,
  pipe_environment,
  left_arg_name,
  pipe_string,
  right_arg_name
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply_right_S4+2B2Crelop_arrow+2B2Crelop_arrow-method_+3A_pipe_left_arg">pipe_left_arg</code></td>
<td>
<p>left argument</p>
</td></tr>
<tr><td><code id="apply_right_S4+2B2Crelop_arrow+2B2Crelop_arrow-method_+3A_pipe_right_arg">pipe_right_arg</code></td>
<td>
<p>pipe_right_arg argument</p>
</td></tr>
<tr><td><code id="apply_right_S4+2B2Crelop_arrow+2B2Crelop_arrow-method_+3A_pipe_environment">pipe_environment</code></td>
<td>
<p>environment to evaluate in</p>
</td></tr>
<tr><td><code id="apply_right_S4+2B2Crelop_arrow+2B2Crelop_arrow-method_+3A_left_arg_name">left_arg_name</code></td>
<td>
<p>name, if not NULL name of left argument.</p>
</td></tr>
<tr><td><code id="apply_right_S4+2B2Crelop_arrow+2B2Crelop_arrow-method_+3A_pipe_string">pipe_string</code></td>
<td>
<p>character, name of pipe operator.</p>
</td></tr>
<tr><td><code id="apply_right_S4+2B2Crelop_arrow+2B2Crelop_arrow-method_+3A_right_arg_name">right_arg_name</code></td>
<td>
<p>name, if not NULL name of right argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>result
</p>

<hr>
<h2 id='apply_right.relop'>Execute pipeline treating pipe_left_arg as local data to
be copied into database.</h2><span id='topic+apply_right.relop'></span>

<h3>Description</h3>

<p>Execute pipeline treating pipe_left_arg as local data to
be copied into database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'relop'
apply_right(
  pipe_left_arg,
  pipe_right_arg,
  pipe_environment,
  left_arg_name,
  pipe_string,
  right_arg_name
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply_right.relop_+3A_pipe_left_arg">pipe_left_arg</code></td>
<td>
<p>left argument.</p>
</td></tr>
<tr><td><code id="apply_right.relop_+3A_pipe_right_arg">pipe_right_arg</code></td>
<td>
<p>pipe_right_arg argument.</p>
</td></tr>
<tr><td><code id="apply_right.relop_+3A_pipe_environment">pipe_environment</code></td>
<td>
<p>environment to evaluate in.</p>
</td></tr>
<tr><td><code id="apply_right.relop_+3A_left_arg_name">left_arg_name</code></td>
<td>
<p>name, if not NULL name of left argument.</p>
</td></tr>
<tr><td><code id="apply_right.relop_+3A_pipe_string">pipe_string</code></td>
<td>
<p>character, name of pipe operator.</p>
</td></tr>
<tr><td><code id="apply_right.relop_+3A_right_arg_name">right_arg_name</code></td>
<td>
<p>name, if not NULL name of right argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rquery_apply_to_data_frame">rquery_apply_to_data_frame</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# WARNING: example tries to change rquery.rquery_db_executor option to RSQLite and back.
if (requireNamespace("DBI", quietly = TRUE) &amp;&amp; requireNamespace("RSQLite", quietly = TRUE)) {
  # set up example database and
  # db execution helper
  db &lt;- DBI::dbConnect(RSQLite::SQLite(),
                       ":memory:")
  RSQLite::initExtension(db)
  old_o &lt;- options(list("rquery.rquery_db_executor" = list(db = db)))

  # operations pipeline/tree
  optree &lt;- mk_td("d", "x") %.&gt;%
    extend(., y = x*x)

  # wrapr dot pipe apply_right dispatch
  # causes this statment to apply optree
  # to d.
  data.frame(x = 1:3) %.&gt;% optree %.&gt;% print(.)

  # remote example
  rq_copy_to(db, "d",
              data.frame(x = 7:8),
              overwrite = TRUE,
              temporary = TRUE)

  # wrapr dot pipe apply_right dispatch
  # causes this statment to apply optree
  # to db.
  db %.&gt;% optree %.&gt;% print(.)

  # clean up
  options(old_o)
  DBI::dbDisconnect(db)
}

</code></pre>

<hr>
<h2 id='arrow'>Data arrow</h2><span id='topic+arrow'></span>

<h3>Description</h3>

<p>A categorical arrow mapping a table to a table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arrow(pipeline, ..., free_table_key = NULL, strict = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arrow_+3A_pipeline">pipeline</code></td>
<td>
<p>pipeline with one source table</p>
</td></tr>
<tr><td><code id="arrow_+3A_...">...</code></td>
<td>
<p>not used, force later argument to be referred to by name.</p>
</td></tr>
<tr><td><code id="arrow_+3A_free_table_key">free_table_key</code></td>
<td>
<p>name of table to consider free (input) to the pipeline</p>
</td></tr>
<tr><td><code id="arrow_+3A_strict">strict</code></td>
<td>
<p>logical, if TRUE excess columns are considered an error</p>
</td></tr>
</table>


<h3>Value</h3>

<p>relop_arrow wrapping of pipeline
</p>

<hr>
<h2 id='assign_slice'>Assign a value to a slice of data (set of rows meeting a condition, and specified set of columns).</h2><span id='topic+assign_slice'></span>

<h3>Description</h3>

<p>Uses <code>if_else_block</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assign_slice(source, testexpr, columns, value, env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assign_slice_+3A_source">source</code></td>
<td>
<p>optree relop node or data.frame.</p>
</td></tr>
<tr><td><code id="assign_slice_+3A_testexpr">testexpr</code></td>
<td>
<p>character containing the test expression.</p>
</td></tr>
<tr><td><code id="assign_slice_+3A_columns">columns</code></td>
<td>
<p>character vector of column names to alter.</p>
</td></tr>
<tr><td><code id="assign_slice_+3A_value">value</code></td>
<td>
<p>value to set in matching rows and columns (scalar).</p>
</td></tr>
<tr><td><code id="assign_slice_+3A_env">env</code></td>
<td>
<p>environment to look to.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: <code>ifebtest_*</code>
is a reserved column name for this procedure.
</p>


<h3>Value</h3>

<p>optree or data.frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("DBI", quietly = TRUE) &amp;&amp; requireNamespace("RSQLite", quietly = TRUE)) {
  my_db &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
  d &lt;- rq_copy_to(
    my_db,
    'd',
    data.frame(i = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10),
               a = c(0, 0, 1, 1, 1, 1, 1, 1, 1, 1),
               b = c(0, 1, 0, 1, 1, 1, 1, 1, 1, 1),
               r = runif(10)),
    temporary=TRUE, overwrite=TRUE)

  optree &lt;- d %.&gt;%
    assign_slice(.,
                 testexpr = qe(r&lt;0.5),
                 columns = qc(a, b),
                 value = 2)
  cat(format(optree))

  sql &lt;- to_sql(optree, my_db)
  cat(sql)

  print(DBI::dbGetQuery(my_db, sql))

  DBI::dbDisconnect(my_db)
}

</code></pre>

<hr>
<h2 id='build_join_plan'>Build a join plan.</h2><span id='topic+build_join_plan'></span>

<h3>Description</h3>

<p>Please see <code>vignette('DependencySorting', package = 'rquery')</code> and <code>vignette('joinController', package= 'rquery')</code> for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_join_plan(tDesc, ..., check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_join_plan_+3A_tdesc">tDesc</code></td>
<td>
<p>description of tables from <code><a href="#topic+describe_tables">describe_tables</a></code> (and likely altered by user). Note: no column names must intersect with names of the form <code>table_CLEANEDTABNAME_present</code>.</p>
</td></tr>
<tr><td><code id="build_join_plan_+3A_...">...</code></td>
<td>
<p>force later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="build_join_plan_+3A_check">check</code></td>
<td>
<p>logical, if TRUE check the join plan for consistency.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>detailed column join plan (appropriate for editing)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+describe_tables">describe_tables</a></code>, <code><a href="#topic+inspect_join_plan">inspect_join_plan</a></code>, <code><a href="#topic+graph_join_plan">graph_join_plan</a></code>, <code><a href="#topic+actualize_join_plan">actualize_join_plan</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("DBI", quietly = TRUE) &amp;&amp; requireNamespace("RSQLite", quietly = TRUE)) {
  my_db &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
  d &lt;- data.frame(id=1:3, weight= c(200, 140, 98))
  DBI::dbWriteTable(my_db,"d1", d)
  DBI::dbWriteTable(my_db,"d2", d)
  tDesc &lt;- describe_tables(my_db, c("d1", "d2"))
  tDesc$keys[[1]] &lt;- list(PrimaryKey= 'id')
  tDesc$keys[[2]] &lt;- list(PrimaryKey= 'id')
  print(build_join_plan(tDesc))
  DBI::dbDisconnect(my_db)
}

</code></pre>

<hr>
<h2 id='column_names'>Return column names</h2><span id='topic+column_names'></span>

<h3>Description</h3>

<p>Return column names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>column_names(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="column_names_+3A_x">x</code></td>
<td>
<p>rquery operation tree.</p>
</td></tr>
<tr><td><code id="column_names_+3A_...">...</code></td>
<td>
<p>generic additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of column names
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("DBI", quietly = TRUE) &amp;&amp; requireNamespace("RSQLite", quietly = TRUE)) {
  my_db &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
  d1 &lt;- rq_copy_to(my_db, 'd1',
                    data.frame(AUC = 0.6, R2 = 0.2))
  d2 &lt;- rq_copy_to(my_db, 'd2',
                    data.frame(AUC = 0.6, D = 0.3))
  optree &lt;- natural_join(d1, d2, by = "AUC")
  cat(format(optree))
  print(column_names(optree))
  DBI::dbDisconnect(my_db)
}

</code></pre>

<hr>
<h2 id='columns_used'>Return columns used</h2><span id='topic+columns_used'></span>

<h3>Description</h3>

<p>Return columns used
</p>


<h3>Usage</h3>

<pre><code class='language-R'>columns_used(x, ..., using = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="columns_used_+3A_x">x</code></td>
<td>
<p>rquery operation tree.</p>
</td></tr>
<tr><td><code id="columns_used_+3A_...">...</code></td>
<td>
<p>generic additional arguments (not used)</p>
</td></tr>
<tr><td><code id="columns_used_+3A_using">using</code></td>
<td>
<p>character, if not NULL set of columns used from above.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of table qualified column names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("DBI", quietly = TRUE) &amp;&amp; requireNamespace("RSQLite", quietly = TRUE)) {
  my_db &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
  d1 &lt;- rq_copy_to(my_db, 'd1',
                    data.frame(AUC = 0.6, R2 = 0.2))
  d2 &lt;- rq_copy_to(my_db, 'd2',
                    data.frame(AUC = 0.6, D = 0.3))
  optree &lt;- natural_join(d1, d2, by = "AUC")
  cat(format(optree))
  print(columns_used(optree))
  DBI::dbDisconnect(my_db)
}

</code></pre>

<hr>
<h2 id='commencify'>Hyderdrive (science fiction show) synonym for <code><a href="#topic+execute">execute</a></code></h2><span id='topic+commencify'></span>

<h3>Description</h3>

<p>Run the data query.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>commencify(
  source,
  optree,
  ...,
  limit = NULL,
  source_limit = NULL,
  overwrite = TRUE,
  temporary = TRUE,
  allow_executor = TRUE,
  temp_source = mk_tmp_name_source("rquery_ex"),
  env = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="commencify_+3A_source">source</code></td>
<td>
<p>data.frame or database connecton (rquery_db_info class or DBI connections preferred).</p>
</td></tr>
<tr><td><code id="commencify_+3A_optree">optree</code></td>
<td>
<p>relop operation tree.</p>
</td></tr>
<tr><td><code id="commencify_+3A_...">...</code></td>
<td>
<p>force later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="commencify_+3A_limit">limit</code></td>
<td>
<p>numeric, if set limit to this many rows during data bring back (not used when landing a table).</p>
</td></tr>
<tr><td><code id="commencify_+3A_source_limit">source_limit</code></td>
<td>
<p>numeric if not NULL limit sources to this many rows.</p>
</td></tr>
<tr><td><code id="commencify_+3A_overwrite">overwrite</code></td>
<td>
<p>logical if TRUE drop an previous table.</p>
</td></tr>
<tr><td><code id="commencify_+3A_temporary">temporary</code></td>
<td>
<p>logical if TRUE try to create a temporary table.</p>
</td></tr>
<tr><td><code id="commencify_+3A_allow_executor">allow_executor</code></td>
<td>
<p>logical if TRUE allow any executor set as rquery.rquery_executor to be used.</p>
</td></tr>
<tr><td><code id="commencify_+3A_temp_source">temp_source</code></td>
<td>
<p>temporary name generator.</p>
</td></tr>
<tr><td><code id="commencify_+3A_env">env</code></td>
<td>
<p>environment to work in.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame
</p>


<h3>See Also</h3>

<p><code><a href="#topic+execute">execute</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# WARNING: example tries to change rquery.rquery_db_executor option to RSQLite and back.
if (requireNamespace("DBI", quietly = TRUE) &amp;&amp; requireNamespace("RSQLite", quietly = TRUE)) {
  my_db &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
  old_o &lt;- options(list("rquery.rquery_db_executor" = list(db = my_db)))
  d &lt;- rq_copy_to(my_db, 'd',
                   data.frame(AUC = 0.6, R2 = 0.2))
  optree &lt;- extend_se(d, c("v" %:=% "AUC + R2", "x" %:=% "pmax(AUC,v)"))

  print(optree)

  cat(format(optree))

  v &lt;- execute(my_db, optree)
  print(v)

  v2 &lt;- execute(data.frame(AUC = 1, R2 = 2), optree)
  print(v2)

  options(old_o)
  DBI::dbDisconnect(my_db)
}

</code></pre>

<hr>
<h2 id='complete_design'>Complete an experimental design.</h2><span id='topic+complete_design'></span>

<h3>Description</h3>

<p>Complete an experimental design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>complete_design(design_table, data_table)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="complete_design_+3A_design_table">design_table</code></td>
<td>
<p>optree or for experimental design.</p>
</td></tr>
<tr><td><code id="complete_design_+3A_data_table">data_table</code></td>
<td>
<p>optree for data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>joined and annotated table optree.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("DBI", quietly = TRUE) &amp;&amp;
    requireNamespace("RSQLite", quietly = TRUE)) {
  my_db &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")

  # example experimental design
  values &lt;- list(nums = 1:3, lets = c("a", "b"))
  design &lt;- expand_grid(my_db, values)

  # not quite matching data
  data &lt;- build_frame(
    "nums", "lets"   |
      1L    , "a"    |
      1L    , "b"    |
      77L   , "a"    |  # out of place ID
      2L    , "b"    |
      3L    , "a"    |
      3L    , "a"    | # duplicated
      3L    , "b"    )
  data$row_number &lt;- seq_len(nrow(data))
  data &lt;- rq_copy_to(my_db, "data", data)

  # compare/augment
  res &lt;- complete_design(design, data)
  cat(format(res))
  res &lt;- materialize(my_db, res)

  print("completed data design")
  print(execute(my_db, res))

  # look for dups (can use extende_se(partation) on
  # databases with window fns.
  print("duplicate key rows:")
  res %.&gt;%
    project_se(.,
               groupby = column_names(design),
               "count" %:=% "SUM(1)") %.&gt;%
    select_rows_se(., "count&gt;1") %.&gt;%
    execute(my_db, .) %.&gt;%
    print(.)

  # look for data that was not in design
  print("data rows not in design:")
  data %.&gt;%
    natural_join(., res,
                 jointype = "LEFT",
                 by = column_names(design)) %.&gt;%
    select_rows_se(., "is.na(row_in_design_table)") %.&gt;%
    execute(my_db, .) %.&gt;%
    print(.)

  DBI::dbDisconnect(my_db)
}

</code></pre>

<hr>
<h2 id='convert_yaml_to_pipeline'>Convert a series of simple objects (from YAML deserializaton) to an rquery pipeline.</h2><span id='topic+convert_yaml_to_pipeline'></span>

<h3>Description</h3>

<p>Convert a series of simple objects (from YAML deserializaton) to an rquery pipeline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_yaml_to_pipeline(rep, ..., source = NULL, env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_yaml_to_pipeline_+3A_rep">rep</code></td>
<td>
<p>input objects</p>
</td></tr>
<tr><td><code id="convert_yaml_to_pipeline_+3A_...">...</code></td>
<td>
<p>not used, force later arguments to bind by name</p>
</td></tr>
<tr><td><code id="convert_yaml_to_pipeline_+3A_source">source</code></td>
<td>
<p>input rquery node</p>
</td></tr>
<tr><td><code id="convert_yaml_to_pipeline_+3A_env">env</code></td>
<td>
<p>environment to evaluate in</p>
</td></tr>
</table>


<h3>Value</h3>

<p>rquery operator tree
</p>

<hr>
<h2 id='count_null_cols'>Count NULLs per row for given column set.</h2><span id='topic+count_null_cols'></span>

<h3>Description</h3>

<p>Build a query that counts the number of nulls in each row.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_null_cols(source, cols, count)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_null_cols_+3A_source">source</code></td>
<td>
<p>incoming rel_op tree or data.frame.</p>
</td></tr>
<tr><td><code id="count_null_cols_+3A_cols">cols</code></td>
<td>
<p>character, columns to track</p>
</td></tr>
<tr><td><code id="count_null_cols_+3A_count">count</code></td>
<td>
<p>character, column to write count in.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>rel_op node or data.frame (depending on input).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+null_replace">null_replace</a></code>, <code><a href="#topic+mark_null_cols">mark_null_cols</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# WARNING: example tries to change rquery.rquery_db_executor option to RSQLite and back.
if (requireNamespace("DBI", quietly = TRUE) &amp;&amp; requireNamespace("RSQLite", quietly = TRUE)) {
  my_db &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
  RSQLite::initExtension(my_db)
  old_o &lt;- options(list("rquery.rquery_db_executor" = list(db = my_db)))

  d &lt;- rq_copy_to(my_db, 'd',
                   data.frame(AUC = c(0.6, 0.5, NA),
                              R2 = c(1.0, 0.9, NA)))
  op_tree &lt;- d %.&gt;% count_null_cols(., c("AUC", "R2"), "nnull")
  cat(format(op_tree))
  sql &lt;- to_sql(op_tree, my_db)
  cat(sql)
  print(DBI::dbGetQuery(my_db, sql))

  # ad-hoc mode
  data.frame(AUC=c(1,NA,0.5), R2=c(NA,1,0)) %.&gt;%
     op_tree %.&gt;%
     print(.)

  # cleanup
  options(old_o)
  DBI::dbDisconnect(my_db)
}

</code></pre>

<hr>
<h2 id='db_td'>Construct a table description from a database source.</h2><span id='topic+db_td'></span><span id='topic+dbi_table'></span>

<h3>Description</h3>

<p>Build structures (table name, column names, and quoting
strategy) needed to represent data from a remote table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_td(db, table_name, ..., qualifiers = NULL, limit_was = 6L)

dbi_table(db, table_name, ..., qualifiers = NULL, limit_was = 6L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="db_td_+3A_db">db</code></td>
<td>
<p>database connection</p>
</td></tr>
<tr><td><code id="db_td_+3A_table_name">table_name</code></td>
<td>
<p>name of table</p>
</td></tr>
<tr><td><code id="db_td_+3A_...">...</code></td>
<td>
<p>not used, force later argument to bind by name</p>
</td></tr>
<tr><td><code id="db_td_+3A_qualifiers">qualifiers</code></td>
<td>
<p>optional named ordered vector of strings carrying additional db hierarchy terms, such as schema.</p>
</td></tr>
<tr><td><code id="db_td_+3A_limit_was">limit_was</code></td>
<td>
<p>optional, row limit used to produce head_sample.  If NULL no head_sample is produced and rq_colnames is used to get column names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: in examples we use <code>rq_copy_to()</code> to create data.  This is only for the purpose of having
easy portable examples.  With big data the data is usually already in the remote database or
Spark system. The task is almost always to connect and work with this pre-existing remote data
and the method to do this is <code>db_td</code>
which builds a reference to a remote table given the table name.
</p>


<h3>Value</h3>

<p>a relop representation of the data
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>dbi_table()</code>: old name for db_td
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+mk_td">mk_td</a></code>, <code><a href="#topic+local_td">local_td</a></code>, <code><a href="#topic+rq_copy_to">rq_copy_to</a></code>, <code><a href="#topic+materialize">materialize</a></code>, <code><a href="#topic+execute">execute</a></code>, <code><a href="#topic+to_sql">to_sql</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("DBI", quietly = TRUE) &amp;&amp; requireNamespace("RSQLite", quietly = TRUE)) {
  my_db &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
  rq_copy_to(my_db,
              'd',
              data.frame(AUC = 0.6, R2 = 0.2),
              overwrite = TRUE,
              temporary = TRUE)
  d &lt;- db_td(my_db, 'd')
  print(d)
  sql &lt;- to_sql(d, my_db)
  cat(sql)
  print(DBI::dbGetQuery(my_db, sql))
  cols &lt;- columns_used(d)
  print(cols)

  sql2 &lt;- to_sql(d, my_db, using = "AUC")
  cat(sql2)
  print(DBI::dbGetQuery(my_db, sql2))
  DBI::dbDisconnect(my_db)
}

</code></pre>

<hr>
<h2 id='describe_tables'>Build a nice description of a table.</h2><span id='topic+describe_tables'></span>

<h3>Description</h3>

<p>Please see <a href="https://win-vector.com/2017/05/26/managing-spark-data-handles-in-r/">https://win-vector.com/2017/05/26/managing-spark-data-handles-in-r/</a> for details.
Note: one usually needs to alter the keys column which is just populated with all columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>describe_tables(db, tablenames, ..., keyInspector = key_inspector_all_cols)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="describe_tables_+3A_db">db</code></td>
<td>
<p>database handle</p>
</td></tr>
<tr><td><code id="describe_tables_+3A_tablenames">tablenames</code></td>
<td>
<p>character, names of tables to describe.</p>
</td></tr>
<tr><td><code id="describe_tables_+3A_...">...</code></td>
<td>
<p>force later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="describe_tables_+3A_keyinspector">keyInspector</code></td>
<td>
<p>function that determines preferred primary key set for tables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please see <code>vignette('DependencySorting', package = 'rquery')</code> and <code>vignette('joinController', package= 'rquery')</code> for more details.
</p>


<h3>Value</h3>

<p>table describing the data.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+build_join_plan">build_join_plan</a></code>, <code><a href="#topic+graph_join_plan">graph_join_plan</a></code>, <code><a href="#topic+actualize_join_plan">actualize_join_plan</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("DBI", quietly = TRUE) &amp;&amp; requireNamespace("RSQLite", quietly = TRUE)) {
  my_db &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
  ex &lt;- example_employee_date(my_db)
  print(describe_tables(my_db, ex$tableName,
                         keyInspector = key_inspector_sqlite))
  DBI::dbDisconnect(my_db)
}


</code></pre>

<hr>
<h2 id='drop_columns'>Make a drop columns node (not a relational operation).</h2><span id='topic+drop_columns'></span>

<h3>Description</h3>

<p>Note: must keep at least one column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop_columns(source, drops, ..., strict = FALSE, env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drop_columns_+3A_source">source</code></td>
<td>
<p>source to drop columns from.</p>
</td></tr>
<tr><td><code id="drop_columns_+3A_drops">drops</code></td>
<td>
<p>list of distinct column names.</p>
</td></tr>
<tr><td><code id="drop_columns_+3A_...">...</code></td>
<td>
<p>force later arguments to bind by name</p>
</td></tr>
<tr><td><code id="drop_columns_+3A_strict">strict</code></td>
<td>
<p>logical, if TRUE do check columns to be dropped are actually present.</p>
</td></tr>
<tr><td><code id="drop_columns_+3A_env">env</code></td>
<td>
<p>environment to look to.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>drop columns node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("DBI", quietly = TRUE) &amp;&amp; requireNamespace("RSQLite", quietly = TRUE)) {
  my_db &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
  d &lt;- rq_copy_to(my_db, 'd',
                   data.frame(AUC = 0.6, R2 = 0.2))
  optree &lt;- drop_columns(d, 'AUC')
  cat(format(optree))
  sql &lt;- to_sql(optree, my_db)
  cat(sql)
  print(DBI::dbGetQuery(my_db, sql))
  DBI::dbDisconnect(my_db)
}

</code></pre>

<hr>
<h2 id='ex'>Execute a wrapped execution pipeline.</h2><span id='topic+ex'></span>

<h3>Description</h3>

<p>Execute a ops-dag using 'codewrap()' data as values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ex(ops, ..., env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ex_+3A_ops">ops</code></td>
<td>
<p>rquery pipeline with tables formed by 'wrap()'.</p>
</td></tr>
<tr><td><code id="ex_+3A_...">...</code></td>
<td>
<p>not used, force later argument to be referred by name</p>
</td></tr>
<tr><td><code id="ex_+3A_env">env</code></td>
<td>
<p>environment to work in.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame result
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(requireNamespace('rqdatatable')) {
 d &lt;- data.frame(x = 1:3, y = 4:6)
 d %.&gt;%
   wrap(.) %.&gt;%
   extend(., z := x + y) %.&gt;%
   ex(.)
}

</code></pre>

<hr>
<h2 id='example_employee_date'>Build some example tables (requires DBI).</h2><span id='topic+example_employee_date'></span>

<h3>Description</h3>

<p>Build some example tables (requires DBI).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example_employee_date(con)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="example_employee_date_+3A_con">con</code></td>
<td>
<p>db connection</p>
</td></tr>
</table>


<h3>Value</h3>

<p>example tables
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("DBI", quietly = TRUE) &amp;&amp; requireNamespace("RSQLite", quietly = TRUE)) {
  my_db &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
  example_employee_date(my_db)
  DBI::dbDisconnect(my_db)
}

</code></pre>

<hr>
<h2 id='execute'>Execute an operator tree, bringing back the result to memory.</h2><span id='topic+execute'></span>

<h3>Description</h3>

<p>Run the data query.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>execute(
  source,
  optree,
  ...,
  limit = NULL,
  source_limit = NULL,
  overwrite = TRUE,
  temporary = TRUE,
  allow_executor = TRUE,
  temp_source = mk_tmp_name_source("rquery_ex"),
  env = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="execute_+3A_source">source</code></td>
<td>
<p>data.frame or database connecton (rquery_db_info class or DBI connections preferred).</p>
</td></tr>
<tr><td><code id="execute_+3A_optree">optree</code></td>
<td>
<p>relop operation tree.</p>
</td></tr>
<tr><td><code id="execute_+3A_...">...</code></td>
<td>
<p>force later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="execute_+3A_limit">limit</code></td>
<td>
<p>numeric, if set limit to this many rows during data bring back (not used when landing a table).</p>
</td></tr>
<tr><td><code id="execute_+3A_source_limit">source_limit</code></td>
<td>
<p>numeric if not NULL limit sources to this many rows.</p>
</td></tr>
<tr><td><code id="execute_+3A_overwrite">overwrite</code></td>
<td>
<p>logical if TRUE drop an previous table.</p>
</td></tr>
<tr><td><code id="execute_+3A_temporary">temporary</code></td>
<td>
<p>logical if TRUE try to create a temporary table.</p>
</td></tr>
<tr><td><code id="execute_+3A_allow_executor">allow_executor</code></td>
<td>
<p>logical if TRUE allow any executor set as rquery.rquery_executor to be used.</p>
</td></tr>
<tr><td><code id="execute_+3A_temp_source">temp_source</code></td>
<td>
<p>temporary name generator.</p>
</td></tr>
<tr><td><code id="execute_+3A_env">env</code></td>
<td>
<p>environment to work in.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame
</p>


<h3>See Also</h3>

<p><code><a href="#topic+materialize">materialize</a></code>, <code><a href="#topic+db_td">db_td</a></code>, <code><a href="#topic+to_sql">to_sql</a></code>, <code><a href="#topic+rq_copy_to">rq_copy_to</a></code>, <code><a href="#topic+mk_td">mk_td</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# WARNING: example tries to change rquery.rquery_db_executor option to RSQLite and back.
if (requireNamespace("DBI", quietly = TRUE) &amp;&amp; requireNamespace("RSQLite", quietly = TRUE)) {
  my_db &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
  old_o &lt;- options(list("rquery.rquery_db_executor" = list(db = my_db)))
  d &lt;- rq_copy_to(my_db, 'd',
                   data.frame(AUC = 0.6, R2 = 0.2))
  optree &lt;- extend_se(d, c("v" %:=% "AUC + R2", "x" %:=% "pmax(AUC,v)"))

  print(optree)

  cat(format(optree))

  v &lt;- execute(my_db, optree)
  print(v)

  v2 &lt;- execute(data.frame(AUC = 1, R2 = 2), optree)
  print(v2)

  options(old_o)
  DBI::dbDisconnect(my_db)
}

</code></pre>

<hr>
<h2 id='expand_grid'>Cross product vectors in database.</h2><span id='topic+expand_grid'></span>

<h3>Description</h3>

<p>Cross product vectors in database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_grid(
  db,
  values,
  ...,
  temporary = TRUE,
  table_name = (wrapr::mk_tmp_name_source("eg"))(),
  qualifiers = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand_grid_+3A_db">db</code></td>
<td>
<p>database handle</p>
</td></tr>
<tr><td><code id="expand_grid_+3A_values">values</code></td>
<td>
<p>named list of value vectors.</p>
</td></tr>
<tr><td><code id="expand_grid_+3A_...">...</code></td>
<td>
<p>force later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="expand_grid_+3A_temporary">temporary</code></td>
<td>
<p>logical if TRUE try to make temporary table.</p>
</td></tr>
<tr><td><code id="expand_grid_+3A_table_name">table_name</code></td>
<td>
<p>name to land result as.</p>
</td></tr>
<tr><td><code id="expand_grid_+3A_qualifiers">qualifiers</code></td>
<td>
<p>optional named ordered vector of strings carrying additional db hierarchy terms, such as schema.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>table handle.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("DBI", quietly = TRUE) &amp;&amp;
    requireNamespace("RSQLite", quietly = TRUE)) {
  my_db &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
  values &lt;- list(nums = 1:3, lets = c("a", "b"))
  res &lt;- expand_grid(my_db, values)
  print(res)
  execute(my_db, res)
  DBI::dbDisconnect(my_db)
}

</code></pre>

<hr>
<h2 id='extend'>Extend data by adding more columns.</h2><span id='topic+extend'></span><span id='topic+extend_nse'></span>

<h3>Description</h3>

<p>Create a node similar to a Codd extend relational operator (add derived columns).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extend(
  source,
  ...,
  partitionby = NULL,
  orderby = NULL,
  reverse = NULL,
  display_form = NULL,
  env = parent.frame()
)

extend_nse(
  source,
  ...,
  partitionby = NULL,
  orderby = NULL,
  reverse = NULL,
  display_form = NULL,
  env = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extend_+3A_source">source</code></td>
<td>
<p>source to select from.</p>
</td></tr>
<tr><td><code id="extend_+3A_...">...</code></td>
<td>
<p>new column assignment expressions.</p>
</td></tr>
<tr><td><code id="extend_+3A_partitionby">partitionby</code></td>
<td>
<p>partitioning (window function) terms.</p>
</td></tr>
<tr><td><code id="extend_+3A_orderby">orderby</code></td>
<td>
<p>ordering (in window function) terms.</p>
</td></tr>
<tr><td><code id="extend_+3A_reverse">reverse</code></td>
<td>
<p>reverse ordering (in window function) terms.</p>
</td></tr>
<tr><td><code id="extend_+3A_display_form">display_form</code></td>
<td>
<p>chacter presentation form</p>
</td></tr>
<tr><td><code id="extend_+3A_env">env</code></td>
<td>
<p>environment to look for values in.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Partitionby and orderby can only be used with a database that supports window-functions
(such as PostgreSQL, Spark, and so on).
</p>
<p>Supports <code>bquote()</code> <code>.()</code>-style name abstraction with the extenson that <code>-</code> promotes strings to names
(please see here: <a href="https://github.com/WinVector/rquery/blob/master/Examples/Substitution/Substitution.md">https://github.com/WinVector/rquery/blob/master/Examples/Substitution/Substitution.md</a>).
</p>
<p>Note: if any window/aggregation functions are present then at least one of partitionby or orderby
must be non empty.  For this purpose partitionby=1 is allowed and means &quot;single partition on the constant 1.&quot;
</p>


<h3>Value</h3>

<p>extend node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("DBI", quietly = TRUE) &amp;&amp; requireNamespace("RSQLite", quietly = TRUE)) {
  my_db &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
  d &lt;- rq_copy_to(my_db, 'd',
                   data.frame(AUC = 0.6, R2 = 0.2))
  NEWCOL &lt;- as.name("v")
  NEWVALUE = "zz"
  optree &lt;- extend(d, .(NEWCOL) %:=% ifelse(AUC&gt;0.5, R2, 1.0), .(NEWVALUE) %:=% 6)
  cat(format(optree))
  sql &lt;- to_sql(optree, my_db)
  cat(sql)
  print(DBI::dbGetQuery(my_db, sql))
  DBI::dbDisconnect(my_db)
}

</code></pre>

<hr>
<h2 id='extend_se'>Extend data by adding more columns.</h2><span id='topic+extend_se'></span>

<h3>Description</h3>

<p>Create a node similar to a Codd extend relational operator (add derived columns).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extend_se(
  source,
  assignments,
  ...,
  partitionby = NULL,
  orderby = NULL,
  reverse = NULL,
  display_form = NULL,
  env = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extend_se_+3A_source">source</code></td>
<td>
<p>source to select from.</p>
</td></tr>
<tr><td><code id="extend_se_+3A_assignments">assignments</code></td>
<td>
<p>new column assignment expressions.</p>
</td></tr>
<tr><td><code id="extend_se_+3A_...">...</code></td>
<td>
<p>force later arguments to bind by name</p>
</td></tr>
<tr><td><code id="extend_se_+3A_partitionby">partitionby</code></td>
<td>
<p>partitioning (window function) terms.</p>
</td></tr>
<tr><td><code id="extend_se_+3A_orderby">orderby</code></td>
<td>
<p>ordering (in window function) terms.</p>
</td></tr>
<tr><td><code id="extend_se_+3A_reverse">reverse</code></td>
<td>
<p>reverse ordering (in window function) terms.</p>
</td></tr>
<tr><td><code id="extend_se_+3A_display_form">display_form</code></td>
<td>
<p>chacter presentation form</p>
</td></tr>
<tr><td><code id="extend_se_+3A_env">env</code></td>
<td>
<p>environment to look for values in.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Partitionby and orderby can only be used with a database that supports window-functions
(such as PostgreSQL, Spark and so on).
</p>
<p>Note: if any window/aggregation functions are present then at least one of partitionby or orderby
must be non empty.  For this purpose partitionby=1 is allowed and means &quot;single partition on the constant 1.&quot;
</p>


<h3>Value</h3>

<p>extend node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("DBI", quietly = TRUE) &amp;&amp; requireNamespace("RSQLite", quietly = TRUE)) {
  my_db &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
  d &lt;- rq_copy_to(my_db, 'd',
                   data.frame(AUC = 0.6, R2 = 0.2))
  optree &lt;- extend_se(d, c("v" %:=% "AUC + R2", "x" %:=% "pmax(AUC,v)"))
  cat(format(optree))
  sql &lt;- to_sql(optree, my_db)
  cat(sql)
  print(DBI::dbGetQuery(my_db, sql))

  DBI::dbDisconnect(my_db)
}

</code></pre>

<hr>
<h2 id='format_node'>Format a single node for printing.</h2><span id='topic+format_node'></span>

<h3>Description</h3>

<p>Format a single node for printing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_node(node)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_node_+3A_node">node</code></td>
<td>
<p>node of operator tree to be formatted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character display form of the node
</p>

<hr>
<h2 id='getDBOption'>Get a database connection option.</h2><span id='topic+getDBOption'></span>

<h3>Description</h3>

<p>Note: we are moving away from global options to options in the DB handle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDBOption(db, optname, default, connection_options = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getDBOption_+3A_db">db</code></td>
<td>
<p>database connection handle.</p>
</td></tr>
<tr><td><code id="getDBOption_+3A_optname">optname</code></td>
<td>
<p>character, single option name.</p>
</td></tr>
<tr><td><code id="getDBOption_+3A_default">default</code></td>
<td>
<p>what to return if not set.</p>
</td></tr>
<tr><td><code id="getDBOption_+3A_connection_options">connection_options</code></td>
<td>
<p>name list of per connection options.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>option value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(requireNamespace("DBI", quietly = TRUE) &amp;&amp; requireNamespace("RSQLite", quietly = TRUE)) {
  my_db &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
  print(getDBOption(my_db, "use_DBI_dbExecute"))
  DBI::dbDisconnect(my_db)
}

</code></pre>

<hr>
<h2 id='graph_join_plan'>Build a draw-able specification of the join diagram</h2><span id='topic+graph_join_plan'></span>

<h3>Description</h3>

<p>Please see <code>vignette('DependencySorting', package = 'rquery')</code> and <code>vignette('joinController', package= 'rquery')</code> for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_join_plan(columnJoinPlan, ..., groupByKeys = TRUE, graphOpts = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph_join_plan_+3A_columnjoinplan">columnJoinPlan</code></td>
<td>
<p>join plan</p>
</td></tr>
<tr><td><code id="graph_join_plan_+3A_...">...</code></td>
<td>
<p>force later arguments to bind by name</p>
</td></tr>
<tr><td><code id="graph_join_plan_+3A_groupbykeys">groupByKeys</code></td>
<td>
<p>logical if true build key-equivalent sub-graphs</p>
</td></tr>
<tr><td><code id="graph_join_plan_+3A_graphopts">graphOpts</code></td>
<td>
<p>options for graphViz</p>
</td></tr>
</table>


<h3>Value</h3>

<p>grViz diagram spec
</p>


<h3>See Also</h3>

<p><code><a href="#topic+describe_tables">describe_tables</a></code>, <code><a href="#topic+build_join_plan">build_join_plan</a></code>, <code><a href="#topic+actualize_join_plan">actualize_join_plan</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

if (requireNamespace("DBI", quietly = TRUE) &amp;&amp; requireNamespace("RSQLite", quietly = TRUE)) {
  # note: employeeanddate is likely built as a cross-product
  #       join of an employee table and set of dates of interest
  #       before getting to the join controller step.  We call
  #       such a table "row control" or "experimental design."
  my_db &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
  RSQLite::initExtension(my_db)
  tDesc &lt;- example_employee_date(my_db)
  # fix order by hand, please see rquery::topo_sort_tables for
  # how to automate this.
  ord &lt;- match(c('employeeanddate', 'orgtable', 'activity', 'revenue'),
               tDesc$tableName)
  tDesc &lt;- tDesc[ord, , drop=FALSE]
  columnJoinPlan &lt;- build_join_plan(tDesc, check= FALSE)
  # unify keys
  columnJoinPlan$resultColumn[columnJoinPlan$resultColumn=='id'] &lt;- 'eid'
  # look at plan defects
  print(paste('problems:',
              inspect_join_plan(tDesc, columnJoinPlan)))
  diagramSpec &lt;- graph_join_plan(columnJoinPlan)
  # # to render as JavaScript:
  # if(requireNamespace("DiagrammeR", quietly = TRUE)) {
  #   print(DiagrammeR::grViz(diagramSpec))
  # }
  DBI::dbDisconnect(my_db)
  my_db &lt;- NULL
}

</code></pre>

<hr>
<h2 id='if_else_block'>Build a sequence of statements simulating an if/else block-<code>if(){}else{}</code>.</h2><span id='topic+if_else_block'></span>

<h3>Description</h3>

<p>This device uses expression-<code>ifelse(,,)</code> to simulate the
more powerful per-row block-<code>if(){}else{}</code>.  The difference is
expression-<code>ifelse(,,)</code> can choose per-row what value to express,
whereas block-<code>if(){}else{}</code> can choose per-row where to assign multiple
values. By simulation we mean: a sequence of quoted mutate expressions
are emitted that implement the transform.  These expressions can then
be optimized into a minimal number of no-dependency
blocks by <code><a href="#topic+extend_se">extend_se</a></code> for efficient execution.
The idea is the user can write legible code in this notation, and
the translation turns it into safe and efficient code suitable for
execution either on <code>data.frame</code>s or at a big data scale using
<code>RPostgreSQL</code> or <code>sparklyr</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>if_else_block(testexpr, ..., thenexprs = NULL, elseexprs = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="if_else_block_+3A_testexpr">testexpr</code></td>
<td>
<p>character containing the test expression.</p>
</td></tr>
<tr><td><code id="if_else_block_+3A_...">...</code></td>
<td>
<p>force later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="if_else_block_+3A_thenexprs">thenexprs</code></td>
<td>
<p>named character then assignments (altering columns, not creating).</p>
</td></tr>
<tr><td><code id="if_else_block_+3A_elseexprs">elseexprs</code></td>
<td>
<p>named character else assignments (altering columns, not creating).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: <code>ifebtest_*</code>
is a reserved column name for this procedure.
</p>


<h3>Value</h3>

<p>sequence of statements for extend_se().
</p>


<h3>See Also</h3>

<p><code><a href="#topic+if_else_op">if_else_op</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("DBI", quietly = TRUE) &amp;&amp; requireNamespace("RSQLite", quietly = TRUE)) {
  # Example: clear one of a or b in any row where both are set.
  # Land random selections early to avoid SQLite bug.
  my_db &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
  d &lt;- rq_copy_to(
    my_db,
    'd',
    data.frame(i = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10),
               a = c(0, 0, 1, 1, 1, 1, 1, 1, 1, 1),
               b = c(0, 1, 0, 1, 1, 1, 1, 1, 1, 1),
               r = runif(10),
               edited = 0),
    temporary=TRUE, overwrite=TRUE)

  program &lt;- if_else_block(
    testexpr = qe((a+b)&gt;1),
    thenexprs = c(
      if_else_block(
        testexpr = qe(r &gt;= 0.5),
        thenexprs = qae(a %:=% 0),
        elseexprs = qae(b %:=% 0)),
      qae(edited %:=% 1)))
  print(program)

  optree &lt;- extend_se(d, program)
  cat(format(optree))

  sql &lt;- to_sql(optree, my_db)
  cat(sql)

  print(DBI::dbGetQuery(my_db, sql))

  # Why we need to land the random selection early
  # for SQLIte:
  q &lt;- "SELECT r AS r1, r AS r2 FROM (
          SELECT random() AS r FROM (
             SELECT * from ( VALUES(1),(2) )
          ) a
       ) b"
  print(DBI::dbGetQuery(my_db, q))

  DBI::dbDisconnect(my_db)
}

</code></pre>

<hr>
<h2 id='if_else_op'>Build a <code>relop</code> node simulating a per-row block-<code>if(){}else{}</code>.</h2><span id='topic+if_else_op'></span>

<h3>Description</h3>

<p>This device uses expression-<code>ifelse(,,)</code> to simulate the
more powerful per-row block-<code>if(){}else{}</code>.  The difference is
expression-<code>ifelse(,,)</code> can choose per-row what value to express,
whereas block-<code>if(){}else{}</code> can choose per-row where to assign multiple
values. By simulation we mean: a sequence of quoted mutate expressions
are emitted that implement the transform.  These expressions can then
be optimized into a minimal number of no-dependency
blocks by <code><a href="#topic+extend_se">extend_se</a></code> for efficient execution.
The idea is the user can write legible code in this notation, and
the translation turns it into safe and efficient code suitable for
execution either on <code>data.frame</code>s or at a big data scale using
<code>RPostgreSQL</code> or <code>sparklyr</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>if_else_op(
  source,
  testexpr,
  ...,
  thenexprs = NULL,
  elseexprs = NULL,
  env = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="if_else_op_+3A_source">source</code></td>
<td>
<p>optree relop node or data.frame.</p>
</td></tr>
<tr><td><code id="if_else_op_+3A_testexpr">testexpr</code></td>
<td>
<p>character containing the test expression.</p>
</td></tr>
<tr><td><code id="if_else_op_+3A_...">...</code></td>
<td>
<p>force later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="if_else_op_+3A_thenexprs">thenexprs</code></td>
<td>
<p>named character then assignments (altering columns, not creating).</p>
</td></tr>
<tr><td><code id="if_else_op_+3A_elseexprs">elseexprs</code></td>
<td>
<p>named character else assignments (altering columns, not creating).</p>
</td></tr>
<tr><td><code id="if_else_op_+3A_env">env</code></td>
<td>
<p>environment to look to.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: <code>ifebtest_*</code>
is a reserved column name for this procedure.
</p>


<h3>Value</h3>

<p>operator tree or data.frame.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+if_else_block">if_else_block</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("DBI", quietly = TRUE) &amp;&amp; requireNamespace("RSQLite", quietly = TRUE)) {
  # Example: clear one of a or b in any row where both are set.
  my_db &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
  d &lt;- rq_copy_to(
    my_db,
    'd',
    data.frame(i = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10),
               a = c(0, 0, 1, 1, 1, 1, 1, 1, 1, 1),
               b = c(0, 1, 0, 1, 1, 1, 1, 1, 1, 1),
               edited = NA),
    temporary=TRUE, overwrite=TRUE)

  optree &lt;- d %.&gt;%
    if_else_op(.,
               testexpr = qe((a+b)&gt;1),
               thenexprs = qae(a %:=% 0,
                               b %:=% 0,
                               edited %:=% 1),
               elseexprs = qae(edited %:=% 0))
  cat(format(optree))

  sql &lt;- to_sql(optree, my_db)
  cat(sql)

  print(DBI::dbGetQuery(my_db, sql))

  DBI::dbDisconnect(my_db)
}


</code></pre>

<hr>
<h2 id='inspect_join_plan'>check that a join plan is consistent with table descriptions.</h2><span id='topic+inspect_join_plan'></span>

<h3>Description</h3>

<p>Please see <code>vignette('DependencySorting', package = 'rquery')</code> and <code>vignette('joinController', package= 'rquery')</code> for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inspect_join_plan(tDesc, columnJoinPlan, ..., checkColClasses = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inspect_join_plan_+3A_tdesc">tDesc</code></td>
<td>
<p>description of tables, from <code><a href="#topic+describe_tables">describe_tables</a></code> (and likely altered by user).</p>
</td></tr>
<tr><td><code id="inspect_join_plan_+3A_columnjoinplan">columnJoinPlan</code></td>
<td>
<p>columns to join, from <code><a href="#topic+build_join_plan">build_join_plan</a></code> (and likely altered by user). Note: no column names must intersect with names of the form <code>table_CLEANEDTABNAME_present</code>.</p>
</td></tr>
<tr><td><code id="inspect_join_plan_+3A_...">...</code></td>
<td>
<p>force later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="inspect_join_plan_+3A_checkcolclasses">checkColClasses</code></td>
<td>
<p>logical if true check for exact class name matches</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL if okay, else a string
</p>


<h3>See Also</h3>

<p><code><a href="#topic+describe_tables">describe_tables</a></code>, <code><a href="#topic+build_join_plan">build_join_plan</a></code>, <code><a href="#topic+graph_join_plan">graph_join_plan</a></code>, <code><a href="#topic+actualize_join_plan">actualize_join_plan</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("DBI", quietly = TRUE) &amp;&amp; requireNamespace("RSQLite", quietly = TRUE)) {
  my_db &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
  # example data
  DBI::dbWriteTable(my_db,
                    "d1",
                    data.frame(id= 1:3,
                               weight= c(200, 140, 98),
                               height= c(60, 24, 12)))
  DBI::dbWriteTable(my_db,
                    "d2",
                    data.frame(pid= 2:3,
                               weight= c(130, 110),
                               width= 1))
  # get the initial description of table defs
  tDesc &lt;- describe_tables(my_db, qc(d1, d2))
  # declare keys (and give them consistent names)
  tDesc$keys[[1]] &lt;- list(PrimaryKey= 'id')
  tDesc$keys[[2]] &lt;- list(PrimaryKey= 'pid')
  # build the join plan
  columnJoinPlan &lt;- build_join_plan(tDesc)
  # confirm the plan
  print(inspect_join_plan(tDesc, columnJoinPlan,
                          checkColClasses= TRUE))
  # damage the plan
  columnJoinPlan$sourceColumn[columnJoinPlan$sourceColumn=='width'] &lt;- 'wd'
  # find a problem
  print(inspect_join_plan(tDesc, columnJoinPlan,
                          checkColClasses= TRUE))
  DBI::dbDisconnect(my_db)
}

</code></pre>

<hr>
<h2 id='key_inspector_all_cols'>Return all columns as guess of preferred primary keys.</h2><span id='topic+key_inspector_all_cols'></span>

<h3>Description</h3>

<p>Return all columns as guess of preferred primary keys.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>key_inspector_all_cols(db, tablename)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="key_inspector_all_cols_+3A_db">db</code></td>
<td>
<p>database handle</p>
</td></tr>
<tr><td><code id="key_inspector_all_cols_+3A_tablename">tablename</code></td>
<td>
<p>character, name of table</p>
</td></tr>
</table>


<h3>Value</h3>

<p>map of keys to keys
</p>


<h3>See Also</h3>

<p><code>describe_tables</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("DBI", quietly = TRUE) &amp;&amp; requireNamespace("RSQLite", quietly = TRUE)) {
  my_db &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
  DBI::dbWriteTable(my_db,
                    "d",
                    data.frame(x=1:3, y=NA))
  print(key_inspector_all_cols(my_db, "d"))
  DBI::dbDisconnect(my_db)
}

</code></pre>

<hr>
<h2 id='key_inspector_postgresql'>Return all primary key columns as guess at preferred primary keys for a PostgreSQL handle.</h2><span id='topic+key_inspector_postgresql'></span>

<h3>Description</h3>

<p>Return all primary key columns as guess at preferred primary keys for a PostgreSQL handle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>key_inspector_postgresql(db, tablename)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="key_inspector_postgresql_+3A_db">db</code></td>
<td>
<p>database handle</p>
</td></tr>
<tr><td><code id="key_inspector_postgresql_+3A_tablename">tablename</code></td>
<td>
<p>character, name of table</p>
</td></tr>
</table>


<h3>Value</h3>

<p>map of keys to keys
</p>


<h3>See Also</h3>

<p><code>describe_tables</code>
</p>

<hr>
<h2 id='key_inspector_sqlite'>Return all primary key columns as guess at preferred primary keys for a SQLite handle.</h2><span id='topic+key_inspector_sqlite'></span>

<h3>Description</h3>

<p>Return all primary key columns as guess at preferred primary keys for a SQLite handle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>key_inspector_sqlite(db, tablename)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="key_inspector_sqlite_+3A_db">db</code></td>
<td>
<p>database handle</p>
</td></tr>
<tr><td><code id="key_inspector_sqlite_+3A_tablename">tablename</code></td>
<td>
<p>character, name of table</p>
</td></tr>
</table>


<h3>Value</h3>

<p>map of keys to keys
</p>


<h3>See Also</h3>

<p><code>describe_tables</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("DBI", quietly = TRUE) &amp;&amp; requireNamespace("RSQLite", quietly = TRUE)) {
  my_db &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
  DBI::dbExecute(my_db, "
    CREATE TABLE orgtable (
      eid TEXT,
      date INTEGER,
      dept TEXT,
      location TEXT,
    PRIMARY KEY (eid, date)
    )
    ")
  print(key_inspector_sqlite(my_db, "orgtable"))
  DBI::dbDisconnect(my_db)
}

</code></pre>

<hr>
<h2 id='local_td'>Construct a table description of a local data.frame.</h2><span id='topic+local_td'></span>

<h3>Description</h3>

<p>Construct a table description of a local data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_td(
  d,
  ...,
  name = NULL,
  name_source = wrapr::mk_tmp_name_source("rqltd"),
  env = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="local_td_+3A_d">d</code></td>
<td>
<p>data.frame or name of data.frame to use as a data source.</p>
</td></tr>
<tr><td><code id="local_td_+3A_...">...</code></td>
<td>
<p>not used, force later arguments to be optional.</p>
</td></tr>
<tr><td><code id="local_td_+3A_name">name</code></td>
<td>
<p>if not null name to user for table.</p>
</td></tr>
<tr><td><code id="local_td_+3A_name_source">name_source</code></td>
<td>
<p>temporary name source.</p>
</td></tr>
<tr><td><code id="local_td_+3A_env">env</code></td>
<td>
<p>environment to work in.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a relop representation of the data
</p>


<h3>See Also</h3>

<p><code><a href="#topic+db_td">db_td</a></code>, <code><a href="#topic+mk_td">mk_td</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
d &lt;- data.frame(x = 1)
local_td(d)
local_td("d")
local_td(as.name("d"))
local_td(data.frame(x = 1))
d %.&gt;% local_td # needs wrapr 1.5.0 or newer to capture name

</code></pre>

<hr>
<h2 id='lookup_by_column'>Use one column to pick values from other columns.</h2><span id='topic+lookup_by_column'></span>

<h3>Description</h3>

<p>The <code>pick</code> column selects values from the columns it names (per-row).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lookup_by_column(
  source,
  pick,
  result,
  ...,
  tmp_name_source = wrapr::mk_tmp_name_source("qn"),
  temporary = TRUE,
  qualifiers = NULL,
  f_dt_factory = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lookup_by_column_+3A_source">source</code></td>
<td>
<p>source to select from (relop or data.frame).</p>
</td></tr>
<tr><td><code id="lookup_by_column_+3A_pick">pick</code></td>
<td>
<p>character scalar, name of column to control value choices.</p>
</td></tr>
<tr><td><code id="lookup_by_column_+3A_result">result</code></td>
<td>
<p>character scalar, name of column to place values in.</p>
</td></tr>
<tr><td><code id="lookup_by_column_+3A_...">...</code></td>
<td>
<p>force later arguments to be bound by name</p>
</td></tr>
<tr><td><code id="lookup_by_column_+3A_tmp_name_source">tmp_name_source</code></td>
<td>
<p>wrapr::mk_tmp_name_source(), temporary name generator.</p>
</td></tr>
<tr><td><code id="lookup_by_column_+3A_temporary">temporary</code></td>
<td>
<p>logical, if TRUE use temporary tables.</p>
</td></tr>
<tr><td><code id="lookup_by_column_+3A_qualifiers">qualifiers</code></td>
<td>
<p>optional named ordered vector of strings carrying additional db hierarchy terms, such as schema.</p>
</td></tr>
<tr><td><code id="lookup_by_column_+3A_f_dt_factory">f_dt_factory</code></td>
<td>
<p>optional signature f_dt_factory(pick, result) returns function with signature f_dt(d, nd) where d is a data.table.  The point is the function must come from a data.table enabled package. Please see <code>rqdatatable::make_dt_lookup_by_column</code> for an example.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
df = data.frame(x = c(1, 2, 3, 4),
                y = c(5, 6, 7, 8),
                choice = c("x", "y", "x", "z"),
                stringsAsFactors = FALSE)

# library("rqdatatable")
# df %.&gt;%
#   lookup_by_column(., "choice", "derived")

if (requireNamespace("DBI", quietly = TRUE) &amp;&amp;
    requireNamespace("RSQLite", quietly = TRUE)) {
  db &lt;- DBI::dbConnect(RSQLite::SQLite(),
                       ":memory:")
  RSQLite::initExtension(db)
  dr &lt;- rq_copy_to(db, "dRemote", df,
                   overwrite = TRUE,
                   temporary = TRUE)

  ops &lt;- dr %.&gt;%
    lookup_by_column(., "choice", "derived")
  cat(format(ops))

  execute(db, ops) %.&gt;%
     print(.)

  DBI::dbDisconnect(db)
}


</code></pre>

<hr>
<h2 id='make_assignments'>Make a list of assignments, applying many functions to many columns.</h2><span id='topic+make_assignments'></span>

<h3>Description</h3>

<p>Make a list of assignments, applying each function to each column named.
Intended to be used as an argument in <code>extend_se()</code> or <code>project_se()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_assignments(columns, funs, ..., sep = "_", prefix = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_assignments_+3A_columns">columns</code></td>
<td>
<p>character, vector of column names to take values from.</p>
</td></tr>
<tr><td><code id="make_assignments_+3A_funs">funs</code></td>
<td>
<p>character, names of functions to apply.</p>
</td></tr>
<tr><td><code id="make_assignments_+3A_...">...</code></td>
<td>
<p>not used, forced later parameters to bind by name</p>
</td></tr>
<tr><td><code id="make_assignments_+3A_sep">sep</code></td>
<td>
<p>character, naming separator</p>
</td></tr>
<tr><td><code id="make_assignments_+3A_prefix">prefix</code></td>
<td>
<p>logical, if TRUE place function names prior, else after in results.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
assignments &lt;- make_assignments(c('x', 'y'), c('mean', med = 'median'))
print(assignments)
ops &lt;- mk_td('d', c('x', 'y')) %.&gt;% project_se(., assignments)
cat(format(ops))

</code></pre>

<hr>
<h2 id='map_column_values'>Remap values in a set of columns.</h2><span id='topic+map_column_values'></span>

<h3>Description</h3>

<p>Remap values in a set of columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map_column_values(source, colmap, ..., null_default = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map_column_values_+3A_source">source</code></td>
<td>
<p>optree relop node or data.frame.</p>
</td></tr>
<tr><td><code id="map_column_values_+3A_colmap">colmap</code></td>
<td>
<p>data.frame with columns column_name, old_value, new_value.</p>
</td></tr>
<tr><td><code id="map_column_values_+3A_...">...</code></td>
<td>
<p>force later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="map_column_values_+3A_null_default">null_default</code></td>
<td>
<p>logical, if TRUE map non-matching values to NULL (else they map to self).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>implementing optree or altered data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("DBI", quietly = TRUE) &amp;&amp; requireNamespace("RSQLite", quietly = TRUE)) {
  my_db &lt;- DBI::dbConnect(RSQLite::SQLite(),
                          ":memory:")

  d &lt;- rq_copy_to(my_db, 'd',
                   data.frame(a = c("1", "2", "1", "3"),
                              b = c("1", "1", "3", "2"),
                              c = c("1", "2", "3", "4"),
                              stringsAsFactors = FALSE),
                   temporary = TRUE,
                   overwrite = TRUE)
  mp &lt;- build_frame(
      "column_name", "old_value", "new_value" |
      "a"          , "1"        , "10"        |
      "a"          , "2"        , "20"        |
      "b"          , "1"        , "100"       |
      "b"          , "3"        , "300"       )

  # example
  op_tree &lt;- d %.&gt;%
    map_column_values(., mp)
  cat(format(op_tree))
  sql &lt;- to_sql(op_tree, my_db)
  cat(sql)
  print(DBI::dbGetQuery(my_db, sql))

  # cleanup
  DBI::dbDisconnect(my_db)
}

</code></pre>

<hr>
<h2 id='mark_null_cols'>Indicate NULLs per row for given column set.</h2><span id='topic+mark_null_cols'></span>

<h3>Description</h3>

<p>Build a query that creates NULL indicators for nulls in selected columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mark_null_cols(source, cols)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mark_null_cols_+3A_source">source</code></td>
<td>
<p>incoming rel_op tree or data.frame.</p>
</td></tr>
<tr><td><code id="mark_null_cols_+3A_cols">cols</code></td>
<td>
<p>named character, values are columns to track, names are where to land indicators.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>rel_op node or data.frame (depending on input).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+null_replace">null_replace</a></code>, <code><a href="#topic+count_null_cols">count_null_cols</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# WARNING: example tries to change rquery.rquery_db_executor option to RSQLite and back.
if (requireNamespace("DBI", quietly = TRUE) &amp;&amp; requireNamespace("RSQLite", quietly = TRUE)) {
  my_db &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
  RSQLite::initExtension(my_db)
  old_o &lt;- options(list("rquery.rquery_db_executor" = list(db = my_db)))

  d &lt;- rq_copy_to(my_db, 'd',
                   data.frame(AUC = c(0.6, 0.5, NA),
                              R2 = c(1.0, 0.9, NA)))
  op_tree &lt;- d %.&gt;% mark_null_cols(., qc(AUC_NULL, R2_NULL) %:=%
                                     qc(AUC, R2))
  cat(format(op_tree))
  sql &lt;- to_sql(op_tree, my_db)
  cat(sql)
  print(DBI::dbGetQuery(my_db, sql))

  # ad-hoc mode
  data.frame(AUC=c(1,NA,0.5), R2=c(NA,1,0)) %.&gt;%
     op_tree %.&gt;%
     print(.)

  # cleanup
  options(old_o)
  DBI::dbDisconnect(my_db)
}

</code></pre>

<hr>
<h2 id='materialize'>Materialize an optree as a table.</h2><span id='topic+materialize'></span>

<h3>Description</h3>

<p>Run the data query as a CREATE TABLE AS . Think of as a function
that can be applied to relop trees, not as a component to place
in pipelines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>materialize(
  db,
  optree,
  table_name = mk_tmp_name_source("rquery_mat")(),
  ...,
  limit = NULL,
  source_limit = NULL,
  overwrite = TRUE,
  temporary = FALSE,
  qualifiers = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="materialize_+3A_db">db</code></td>
<td>
<p>database connecton (rquery_db_info class or DBI connections preferred).</p>
</td></tr>
<tr><td><code id="materialize_+3A_optree">optree</code></td>
<td>
<p>relop operation tree.</p>
</td></tr>
<tr><td><code id="materialize_+3A_table_name">table_name</code></td>
<td>
<p>character, name of table to create.</p>
</td></tr>
<tr><td><code id="materialize_+3A_...">...</code></td>
<td>
<p>force later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="materialize_+3A_limit">limit</code></td>
<td>
<p>numeric if not NULL result limit (to use this, last statement must not have a limit).</p>
</td></tr>
<tr><td><code id="materialize_+3A_source_limit">source_limit</code></td>
<td>
<p>numeric if not NULL limit sources to this many rows.</p>
</td></tr>
<tr><td><code id="materialize_+3A_overwrite">overwrite</code></td>
<td>
<p>logical if TRUE drop an previous table.</p>
</td></tr>
<tr><td><code id="materialize_+3A_temporary">temporary</code></td>
<td>
<p>logical if TRUE try to create a temporary table.</p>
</td></tr>
<tr><td><code id="materialize_+3A_qualifiers">qualifiers</code></td>
<td>
<p>optional named ordered vector of strings carrying additional db hierarchy terms, such as schema.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>table description
</p>


<h3>See Also</h3>

<p><code><a href="#topic+db_td">db_td</a></code>, <code><a href="#topic+execute">execute</a></code>, <code><a href="#topic+to_sql">to_sql</a></code>, <code><a href="#topic+rq_copy_to">rq_copy_to</a></code>, <code><a href="#topic+mk_td">mk_td</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("DBI", quietly = TRUE) &amp;&amp; requireNamespace("RSQLite", quietly = TRUE)) {
  my_db &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")

  d &lt;- rq_copy_to(my_db, 'd',
                   data.frame(AUC = 0.6, R2 = 0.2),
                   temporary = TRUE, overwrite = TRUE)
  optree &lt;- extend_se(d, c("v" %:=% "AUC + R2", "x" %:=% "pmax(AUC,v)"))
  cat(format(optree))
  res &lt;- materialize(my_db, optree, "example")
  cat(format(res))
  sql &lt;- to_sql(res, my_db)
  cat(sql)
  print(DBI::dbGetQuery(my_db, sql))

  DBI::dbDisconnect(my_db)
}

</code></pre>

<hr>
<h2 id='materialize_node'>Create a materialize node.</h2><span id='topic+materialize_node'></span>

<h3>Description</h3>

<p>Write results into a specified table.  Result is transient, lives only for the duration of the
pipeline calculation.  This node is only used to break up or un-nest calculations, not for value sharing or
re-use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>materialize_node(
  source,
  table_name = (wrapr::mk_tmp_name_source("rquerymn"))(),
  ...,
  qualifiers = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="materialize_node_+3A_source">source</code></td>
<td>
<p>source to work from (relop node)</p>
</td></tr>
<tr><td><code id="materialize_node_+3A_table_name">table_name</code></td>
<td>
<p>character, name of caching table</p>
</td></tr>
<tr><td><code id="materialize_node_+3A_...">...</code></td>
<td>
<p>not used, force later argument to bind by name</p>
</td></tr>
<tr><td><code id="materialize_node_+3A_qualifiers">qualifiers</code></td>
<td>
<p>optional named ordered vector of strings carrying additional db hierarchy terms, such as schema.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note this node can not be used in multiple paths in the same rel_op tree as it re-uses table names and
re-computes each time called.
</p>


<h3>Value</h3>

<p>relop materialize_node
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rsummary_node">rsummary_node</a></code>, <code><a href="#topic+non_sql_node">non_sql_node</a></code>
</p>

<hr>
<h2 id='materialize_sql'>Materialize a user supplied SQL statement as a table.</h2><span id='topic+materialize_sql'></span>

<h3>Description</h3>

<p>Run the data query with a CREATE TABLE AS .
</p>


<h3>Usage</h3>

<pre><code class='language-R'>materialize_sql(
  db,
  sql,
  table_name = mk_tmp_name_source("rqms")(),
  ...,
  overwrite = TRUE,
  temporary = FALSE,
  qualifiers = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="materialize_sql_+3A_db">db</code></td>
<td>
<p>database connecton (rquery_db_info class or DBI connections preferred).</p>
</td></tr>
<tr><td><code id="materialize_sql_+3A_sql">sql</code></td>
<td>
<p>character, user supplied SQL statement.</p>
</td></tr>
<tr><td><code id="materialize_sql_+3A_table_name">table_name</code></td>
<td>
<p>character, name of table to create.</p>
</td></tr>
<tr><td><code id="materialize_sql_+3A_...">...</code></td>
<td>
<p>force later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="materialize_sql_+3A_overwrite">overwrite</code></td>
<td>
<p>logical if TRUE drop an previous table.</p>
</td></tr>
<tr><td><code id="materialize_sql_+3A_temporary">temporary</code></td>
<td>
<p>logical if TRUE try to create a temporary table.</p>
</td></tr>
<tr><td><code id="materialize_sql_+3A_qualifiers">qualifiers</code></td>
<td>
<p>optional named ordered vector of strings carrying additional db hierarchy terms, such as schema.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>table description
</p>


<h3>See Also</h3>

<p><code><a href="#topic+db_td">db_td</a></code>, <code><a href="#topic+materialize">materialize</a></code>, <code><a href="#topic+to_sql">to_sql</a></code>, <code><a href="#topic+rq_copy_to">rq_copy_to</a></code>, <code><a href="#topic+mk_td">mk_td</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("DBI", quietly = TRUE) &amp;&amp; requireNamespace("RSQLite", quietly = TRUE)) {
  my_db &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")

  d &lt;- rq_copy_to(my_db, 'd',
                   data.frame(AUC = 0.6, R2 = 0.2),
                   temporary = TRUE, overwrite = TRUE)
  t &lt;- materialize_sql(my_db, "SELECT AUC, R2, AUC - R2 AS d FROM d")
  print(t)
  print(execute(my_db, t))

  DBI::dbDisconnect(my_db)
}

</code></pre>

<hr>
<h2 id='mk_td'>Make a table description directly.</h2><span id='topic+mk_td'></span><span id='topic+table_source'></span>

<h3>Description</h3>

<p>Build minimal structures (table name and column names) needed to represent data from a remote table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mk_td(
  table_name,
  columns,
  ...,
  qualifiers = NULL,
  q_table_name = NULL,
  head_sample = NULL,
  limit_was = NULL
)

table_source(
  table_name,
  columns,
  ...,
  qualifiers = NULL,
  q_table_name = NULL,
  head_sample = NULL,
  limit_was = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mk_td_+3A_table_name">table_name</code></td>
<td>
<p>character, name of table</p>
</td></tr>
<tr><td><code id="mk_td_+3A_columns">columns</code></td>
<td>
<p>character, column names of table (non-empty and unique values).</p>
</td></tr>
<tr><td><code id="mk_td_+3A_...">...</code></td>
<td>
<p>not used, force later argument to bind by name</p>
</td></tr>
<tr><td><code id="mk_td_+3A_qualifiers">qualifiers</code></td>
<td>
<p>optional named ordered vector of strings carrying additional db hierarchy terms, such as schema.</p>
</td></tr>
<tr><td><code id="mk_td_+3A_q_table_name">q_table_name</code></td>
<td>
<p>optional character, qualified table name, note: has to be re-generated for different DB connections.</p>
</td></tr>
<tr><td><code id="mk_td_+3A_head_sample">head_sample</code></td>
<td>
<p>optional, head_sample of table as an example</p>
</td></tr>
<tr><td><code id="mk_td_+3A_limit_was">limit_was</code></td>
<td>
<p>optional, row limit used to produce head_sample.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generate a query that returns contents of a table, we
could try to eliminate this (replace the query with the table name),
but there are features one can work with with the query in place and
SQL optimizers likely make this zero-cost anyway.
</p>


<h3>Value</h3>

<p>a relop representation of the data
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>table_source()</code>: old name for mk_td
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+db_td">db_td</a></code>, <code><a href="#topic+local_td">local_td</a></code>
</p>
<p><code><a href="#topic+db_td">db_td</a></code>, <code><a href="#topic+local_td">local_td</a></code>, <code><a href="#topic+rq_copy_to">rq_copy_to</a></code>, <code><a href="#topic+materialize">materialize</a></code>, <code><a href="#topic+execute">execute</a></code>, <code><a href="#topic+to_sql">to_sql</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("DBI", quietly = TRUE) &amp;&amp; requireNamespace("RSQLite", quietly = TRUE)) {
  my_db &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
  rq_copy_to(my_db,
             'd',
             data.frame(AUC = 0.6, R2 = 0.2),
             overwrite = TRUE,
             temporary = TRUE)
  d &lt;- mk_td('d',
                    columns = c("AUC", "R2"))
  print(d)
  sql &lt;- to_sql(d, my_db)
  cat(sql)
  print(DBI::dbGetQuery(my_db, sql))
  DBI::dbDisconnect(my_db)
}

</code></pre>

<hr>
<h2 id='natural_join'>Make a natural_join node.</h2><span id='topic+natural_join'></span>

<h3>Description</h3>

<p>Natural join is a join by identity on all common columns specified in the <code>by</code>
argument.
Any common columns not specified in the <code>by</code> argument
are coalesced into a single column preferring the first or &quot;a&quot; table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>natural_join(a, b, ..., by, jointype = "INNER", env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="natural_join_+3A_a">a</code></td>
<td>
<p>source to select from.</p>
</td></tr>
<tr><td><code id="natural_join_+3A_b">b</code></td>
<td>
<p>source to select from.</p>
</td></tr>
<tr><td><code id="natural_join_+3A_...">...</code></td>
<td>
<p>force later arguments to bind by name</p>
</td></tr>
<tr><td><code id="natural_join_+3A_by">by</code></td>
<td>
<p>character, set of columns to match.  If by is a named character vector the right table will have columns renamed.</p>
</td></tr>
<tr><td><code id="natural_join_+3A_jointype">jointype</code></td>
<td>
<p>type of join ('INNER', 'LEFT', 'RIGHT', 'FULL').</p>
</td></tr>
<tr><td><code id="natural_join_+3A_env">env</code></td>
<td>
<p>environment to look to.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>natural_join node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(requireNamespace("DBI", quietly = TRUE) &amp;&amp;
   requireNamespace("RSQLite", quietly = TRUE)) {
  my_db &lt;- DBI::dbConnect(RSQLite::SQLite(),
                          ":memory:")

  d1 &lt;- rq_copy_to(
    my_db, 'd1',
    build_frame(
      "key", "val", "val1" |
        "a"  , 1  ,  10    |
        "b"  , 2  ,  11    |
        "c"  , 3  ,  12    ))
  d2 &lt;- rq_copy_to(
    my_db, 'd2',
    build_frame(
      "key", "val", "val2" |
        "a"  , 5  ,  13    |
        "b"  , 6  ,  14    |
        "d"  , 7  ,  15    ))

  # key matching join
  optree &lt;- natural_join(d1, d2,
                         jointype = "LEFT", by = 'key')
  execute(my_db, optree) %.&gt;%
    print(.)

  DBI::dbDisconnect(my_db)
}

</code></pre>

<hr>
<h2 id='non_sql_node'>Wrap a non-SQL node.</h2><span id='topic+non_sql_node'></span>

<h3>Description</h3>

<p>Note: non-SQL nodes are allowed to delete/overwrite both
both the incoming and outgoing tables, so do not point them
to non-temporary structures.  Also they tend to land all columns
(losing narrowing optimization),
so can be expensive and should be used sparingly.  Finally their
result can only be used once in a pipeline (else they will try to clobber their own result).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>non_sql_node(
  source,
  ...,
  f_db = NULL,
  f_df = NULL,
  f_dt = NULL,
  incoming_table_name,
  incoming_qualifiers = NULL,
  outgoing_table_name,
  outgoing_qualifiers = NULL,
  columns_produced,
  display_form = "non_sql_node",
  orig_columns = TRUE,
  temporary = TRUE,
  check_result_details = TRUE,
  env = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="non_sql_node_+3A_source">source</code></td>
<td>
<p>source to work from (data.frame or relop node)</p>
</td></tr>
<tr><td><code id="non_sql_node_+3A_...">...</code></td>
<td>
<p>force later arguments to bind by name</p>
</td></tr>
<tr><td><code id="non_sql_node_+3A_f_db">f_db</code></td>
<td>
<p>database implementation signature: f_db(db, incoming_table_name, outgoing_table_name, nd, ...) (db being a database handle)</p>
</td></tr>
<tr><td><code id="non_sql_node_+3A_f_df">f_df</code></td>
<td>
<p>data.frame implementation signature: f_df(data.frame, nd) (NULL defaults to taking from database).</p>
</td></tr>
<tr><td><code id="non_sql_node_+3A_f_dt">f_dt</code></td>
<td>
<p>data.table implementation signature: f_dt(data.table, nd) (NULL defaults f_df).</p>
</td></tr>
<tr><td><code id="non_sql_node_+3A_incoming_table_name">incoming_table_name</code></td>
<td>
<p>character, name of incoming table</p>
</td></tr>
<tr><td><code id="non_sql_node_+3A_incoming_qualifiers">incoming_qualifiers</code></td>
<td>
<p>optional named ordered vector of strings carrying additional db hierarchy terms, such as schema.</p>
</td></tr>
<tr><td><code id="non_sql_node_+3A_outgoing_table_name">outgoing_table_name</code></td>
<td>
<p>character, name of produced table</p>
</td></tr>
<tr><td><code id="non_sql_node_+3A_outgoing_qualifiers">outgoing_qualifiers</code></td>
<td>
<p>optional named ordered vector of strings carrying additional db hierarchy terms, such as schema.</p>
</td></tr>
<tr><td><code id="non_sql_node_+3A_columns_produced">columns_produced</code></td>
<td>
<p>character, names of additional columns produced</p>
</td></tr>
<tr><td><code id="non_sql_node_+3A_display_form">display_form</code></td>
<td>
<p>character, how to print node</p>
</td></tr>
<tr><td><code id="non_sql_node_+3A_orig_columns">orig_columns</code></td>
<td>
<p>logical if TRUE select all original columns.</p>
</td></tr>
<tr><td><code id="non_sql_node_+3A_temporary">temporary</code></td>
<td>
<p>logical, if TRUE mark tables temporary.</p>
</td></tr>
<tr><td><code id="non_sql_node_+3A_check_result_details">check_result_details</code></td>
<td>
<p>logical, if TRUE enforce result type and columns.</p>
</td></tr>
<tr><td><code id="non_sql_node_+3A_env">env</code></td>
<td>
<p>environment to look to.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>non-sql node.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rsummary_node">rsummary_node</a></code>, <code><a href="#topic+quantile_node">quantile_node</a></code>
</p>

<hr>
<h2 id='normalize_cols'>Build an optree pipeline that normalizes a set of columns so each column sums to one in each partition.</h2><span id='topic+normalize_cols'></span>

<h3>Description</h3>

<p>This is an example of building up a desired pre-prepared pipeline fragment from relop nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize_cols(source, columns, ..., partitionby = NULL, env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalize_cols_+3A_source">source</code></td>
<td>
<p>relop tree or data.frame source.</p>
</td></tr>
<tr><td><code id="normalize_cols_+3A_columns">columns</code></td>
<td>
<p>character, columns to normalize.</p>
</td></tr>
<tr><td><code id="normalize_cols_+3A_...">...</code></td>
<td>
<p>force later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="normalize_cols_+3A_partitionby">partitionby</code></td>
<td>
<p>partitioning (window function) column names to define partitions.</p>
</td></tr>
<tr><td><code id="normalize_cols_+3A_env">env</code></td>
<td>
<p>environment to look for values in.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# by hand logistic regression example
scale &lt;- 0.237
d &lt;- mk_td("survey_table",
                  c("subjectID", "surveyCategory", "assessmentTotal"))
optree &lt;- d %.&gt;%
  extend(.,
             probability %:=%
               exp(assessmentTotal * scale))  %.&gt;%
  normalize_cols(.,
                 "probability",
                 partitionby = 'subjectID') %.&gt;%
  pick_top_k(.,
             partitionby = 'subjectID',
             orderby = c('probability', 'surveyCategory'),
             reverse = c('probability')) %.&gt;%
  rename_columns(., 'diagnosis' %:=% 'surveyCategory') %.&gt;%
  select_columns(., c('subjectID',
                      'diagnosis',
                      'probability')) %.&gt;%
  orderby(., 'subjectID')
cat(format(optree))

</code></pre>

<hr>
<h2 id='null_replace'>Create a null_replace node.</h2><span id='topic+null_replace'></span>

<h3>Description</h3>

<p>Replace NA/NULL is specified columns with the given replacement value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>null_replace(src, cols, value, ..., note_col = NULL, env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="null_replace_+3A_src">src</code></td>
<td>
<p>relop or data.frame data source.</p>
</td></tr>
<tr><td><code id="null_replace_+3A_cols">cols</code></td>
<td>
<p>character, columns to work on.</p>
</td></tr>
<tr><td><code id="null_replace_+3A_value">value</code></td>
<td>
<p>scalar, value to write.</p>
</td></tr>
<tr><td><code id="null_replace_+3A_...">...</code></td>
<td>
<p>force later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="null_replace_+3A_note_col">note_col</code></td>
<td>
<p>character, if not NULL record number of columns altered per-row in this column.</p>
</td></tr>
<tr><td><code id="null_replace_+3A_env">env</code></td>
<td>
<p>environment to look to.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>null_replace node or data.frame.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+count_null_cols">count_null_cols</a></code>, <code><a href="#topic+mark_null_cols">mark_null_cols</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("DBI", quietly = TRUE) &amp;&amp; requireNamespace("RSQLite", quietly = TRUE)) {
  my_db &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
  d1 &lt;- rq_copy_to(my_db, 'd1',
                    data.frame(A = c(NA, 2, 3, NA), B = c(3, NA, 4, NA)))
  optree &lt;- null_replace(d1, qc(A, B),
                         0.0, note_col = "alterations")
  cat(format(optree))
  sql &lt;- to_sql(optree, my_db)
  cat(sql)
  print(DBI::dbGetQuery(my_db, sql))
  DBI::dbDisconnect(my_db)
}

</code></pre>

<hr>
<h2 id='op_diagram'>Build a diagram of a optree pipeline.</h2><span id='topic+op_diagram'></span>

<h3>Description</h3>

<p>Build a diagram of a optree pipeline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>op_diagram(optree, ..., merge_tables = FALSE, show_table_columns = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="op_diagram_+3A_optree">optree</code></td>
<td>
<p>operation tree pipeline (or list of such).</p>
</td></tr>
<tr><td><code id="op_diagram_+3A_...">...</code></td>
<td>
<p>force other argument to be by name.</p>
</td></tr>
<tr><td><code id="op_diagram_+3A_merge_tables">merge_tables</code></td>
<td>
<p>logical, if TRUE merge all same table references into one node.  rel_op nodes that declare a materialize_as name will be cross-linked.</p>
</td></tr>
<tr><td><code id="op_diagram_+3A_show_table_columns">show_table_columns</code></td>
<td>
<p>logical, if TRUE show table columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character DiagrammeR::grViz() ready text.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
d &lt;- mk_td('d',
             columns = qc(AUC, R2))
optree &lt;- d %.&gt;%
  extend(., v %:=% ifelse(AUC&gt;0.5, R2, 1.0)) %.&gt;%
  quantile_node(.) %.&gt;%
  natural_join(., d, jointype = "LEFT", by = "AUC") %.&gt;%
  orderby(., "AUC")

cat(format(optree))

cat(op_diagram(optree))

# if(requireNamespace("DiagrammeR", quietly = TRUE)) {
#   optree %.&gt;%
#     op_diagram(., merge_tables = TRUE) %.&gt;%
#     DiagrammeR::grViz(.) %.&gt;%
#     print(.)
#  # # or to render to png
#  # optree %.&gt;%
#  #   op_diagram(., merge_tables = TRUE) %.&gt;%
#  #   DiagrammeR::DiagrammeR(diagram = ., type = "grViz") %.&gt;%
#  #     DiagrammeRsvg::export_svg(.) %.&gt;%
#  #     charToRaw(.) %.&gt;%
#  #     rsvg::rsvg_png(., file = "diagram1.png")
# }

</code></pre>

<hr>
<h2 id='order_expr'>Make a order_expr node.</h2><span id='topic+order_expr'></span><span id='topic+order_expr_nse'></span>

<h3>Description</h3>

<p>order_expr() uses bquote() .()-style escaping.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>order_expr(source, expr, env = parent.frame())

order_expr_nse(source, expr, env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="order_expr_+3A_source">source</code></td>
<td>
<p>source to select from.</p>
</td></tr>
<tr><td><code id="order_expr_+3A_expr">expr</code></td>
<td>
<p>expression to order_expr.</p>
</td></tr>
<tr><td><code id="order_expr_+3A_env">env</code></td>
<td>
<p>environment to look to.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>select columns node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("DBI", quietly = TRUE) &amp;&amp; requireNamespace("RSQLite", quietly = TRUE)) {
  my_db &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
  d &lt;- rq_copy_to(my_db, 'd',
                   data.frame(AUC = 0.6, R2 = 0.2, z = 3))
  TARGETCOL = as.name("AUC")
  optree &lt;- order_expr(d, .(TARGETCOL)/R2) %.&gt;%
    select_columns(., "R2")
  cat(format(optree))
  sql &lt;- to_sql(optree, my_db)
  cat(sql)
  print(DBI::dbGetQuery(my_db, sql))
  DBI::dbDisconnect(my_db)
}

</code></pre>

<hr>
<h2 id='order_expr_se'>Make a order_expr node.</h2><span id='topic+order_expr_se'></span>

<h3>Description</h3>

<p>Make a order_expr node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>order_expr_se(source, expr, env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="order_expr_se_+3A_source">source</code></td>
<td>
<p>source to select from.</p>
</td></tr>
<tr><td><code id="order_expr_se_+3A_expr">expr</code></td>
<td>
<p>expression to order_expr in ascending order.</p>
</td></tr>
<tr><td><code id="order_expr_se_+3A_env">env</code></td>
<td>
<p>environment to look for values in.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>select columns node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("DBI", quietly = TRUE) &amp;&amp; requireNamespace("RSQLite", quietly = TRUE)) {
  my_db &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
  d &lt;- rq_copy_to(my_db, 'd',
                   data.frame(AUC = 0.6, R2 = 0.2))
  optree &lt;- order_expr_se(d, "AUC/R2")
  cat(format(optree))
  sql &lt;- to_sql(optree, my_db)
  cat(sql)
  print(DBI::dbGetQuery(my_db, sql))
  DBI::dbDisconnect(my_db)
}
</code></pre>

<hr>
<h2 id='order_rows'>Make an orderby node (not a relational operation).</h2><span id='topic+order_rows'></span>

<h3>Description</h3>

<p>Order a table by a set of columns (not general expressions) and
limit number of rows in that order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>order_rows(
  source,
  cols = NULL,
  ...,
  reverse = NULL,
  limit = NULL,
  env = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="order_rows_+3A_source">source</code></td>
<td>
<p>source to select from.</p>
</td></tr>
<tr><td><code id="order_rows_+3A_cols">cols</code></td>
<td>
<p>order by columns ascending.</p>
</td></tr>
<tr><td><code id="order_rows_+3A_...">...</code></td>
<td>
<p>force later arguments to be bound by name</p>
</td></tr>
<tr><td><code id="order_rows_+3A_reverse">reverse</code></td>
<td>
<p>character, which columns to reverse ordering of to descending.</p>
</td></tr>
<tr><td><code id="order_rows_+3A_limit">limit</code></td>
<td>
<p>number limit row count.</p>
</td></tr>
<tr><td><code id="order_rows_+3A_env">env</code></td>
<td>
<p>environment to look to.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: this is a relational operator in that it takes a table that
is a relation (has unique rows) to a table that is still a relation.
However, most relational systems do not preserve row order in storage or between
operations.  So without the limit set this is not a useful operator except
as a last step prior to pulling data to an in-memory <code>data.frame</code> (
which does preserve row order).
</p>


<h3>Value</h3>

<p>order_by node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("DBI", quietly = TRUE) &amp;&amp; requireNamespace("RSQLite", quietly = TRUE)) {
  my_db &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
  d &lt;- rq_copy_to(my_db, 'd',
                   data.frame(AUC = 0.6, R2 = 0.2))
  optree &lt;- order_rows(d, cols = "AUC", reverse = "AUC", limit=4)
  cat(format(optree))
  sql &lt;- to_sql(optree, my_db)
  cat(sql)
  print(DBI::dbGetQuery(my_db, sql))
  DBI::dbDisconnect(my_db)
}

</code></pre>

<hr>
<h2 id='orderby'>Make an orderby node (not a relational operation).</h2><span id='topic+orderby'></span>

<h3>Description</h3>

<p>Order a table by a set of columns (not general expressions) and
limit number of rows in that order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orderby(
  source,
  cols = NULL,
  ...,
  reverse = NULL,
  limit = NULL,
  env = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="orderby_+3A_source">source</code></td>
<td>
<p>source to select from.</p>
</td></tr>
<tr><td><code id="orderby_+3A_cols">cols</code></td>
<td>
<p>order by named columns ascending.</p>
</td></tr>
<tr><td><code id="orderby_+3A_...">...</code></td>
<td>
<p>force later arguments to be bound by name</p>
</td></tr>
<tr><td><code id="orderby_+3A_reverse">reverse</code></td>
<td>
<p>character, which columns to reverse ordering of top descending.</p>
</td></tr>
<tr><td><code id="orderby_+3A_limit">limit</code></td>
<td>
<p>number limit row count.</p>
</td></tr>
<tr><td><code id="orderby_+3A_env">env</code></td>
<td>
<p>environment to look to.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: this is a relational operator in that it takes a table that
is a relation (has unique rows) to a table that is still a relation.
However, most relational systems do not preserve row order in storage or between
operations.  So without the limit set this is not a useful operator except
as a last step prior to pulling data to an in-memory <code>data.frame</code> (
which does preserve row order).
</p>


<h3>Value</h3>

<p>order_by node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("DBI", quietly = TRUE) &amp;&amp; requireNamespace("RSQLite", quietly = TRUE)) {
  my_db &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
  d &lt;- rq_copy_to(my_db, 'd',
                   data.frame(AUC = 0.6, R2 = 0.2))
  optree &lt;- orderby(d, cols = "AUC", reverse = "AUC", limit=4)
  cat(format(optree))
  sql &lt;- to_sql(optree, my_db)
  cat(sql)
  print(DBI::dbGetQuery(my_db, sql))
  DBI::dbDisconnect(my_db)
}

</code></pre>

<hr>
<h2 id='pick_top_k'>Build an optree pipeline that selects up to the top k rows from each group in the given order.</h2><span id='topic+pick_top_k'></span>

<h3>Description</h3>

<p>This is an example of building up a desired pre-prepared pipeline fragment from relop nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pick_top_k(
  source,
  ...,
  partitionby = NULL,
  orderby = NULL,
  reverse = NULL,
  k = 1L,
  order_expression = "row_number()",
  order_column = "row_number",
  keep_order_column = TRUE,
  env = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pick_top_k_+3A_source">source</code></td>
<td>
<p>relop tree or data.frame source.</p>
</td></tr>
<tr><td><code id="pick_top_k_+3A_...">...</code></td>
<td>
<p>force later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="pick_top_k_+3A_partitionby">partitionby</code></td>
<td>
<p>partitioning (window function) column names.</p>
</td></tr>
<tr><td><code id="pick_top_k_+3A_orderby">orderby</code></td>
<td>
<p>character, ordering (in window function) column names.</p>
</td></tr>
<tr><td><code id="pick_top_k_+3A_reverse">reverse</code></td>
<td>
<p>character, reverse ordering (in window function) of these column names.</p>
</td></tr>
<tr><td><code id="pick_top_k_+3A_k">k</code></td>
<td>
<p>integer, number of rows to limit to in each group.</p>
</td></tr>
<tr><td><code id="pick_top_k_+3A_order_expression">order_expression</code></td>
<td>
<p>character, command to compute row-order/rank.</p>
</td></tr>
<tr><td><code id="pick_top_k_+3A_order_column">order_column</code></td>
<td>
<p>character, column name to write per-group rank in (no ties).</p>
</td></tr>
<tr><td><code id="pick_top_k_+3A_keep_order_column">keep_order_column</code></td>
<td>
<p>logical, if TRUE retain the order column in the result.</p>
</td></tr>
<tr><td><code id="pick_top_k_+3A_env">env</code></td>
<td>
<p>environment to look for values in.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# by hand logistic regression example
scale &lt;- 0.237
d &lt;- mk_td("survey_table",
           c("subjectID", "surveyCategory", "assessmentTotal"))
optree &lt;- d %.&gt;%
  extend(.,
             probability %:=%
               exp(assessmentTotal * scale))  %.&gt;%
  normalize_cols(.,
                 "probability",
                 partitionby = 'subjectID') %.&gt;%
  pick_top_k(.,
             partitionby = 'subjectID',
             orderby = c('probability', 'surveyCategory'),
             reverse = c('probability', 'surveyCategory')) %.&gt;%
  rename_columns(., 'diagnosis' %:=% 'surveyCategory') %.&gt;%
  select_columns(., c('subjectID',
                      'diagnosis',
                      'probability')) %.&gt;%
  orderby(., 'subjectID')
cat(format(optree))

</code></pre>

<hr>
<h2 id='pre_sql_fn'>pre_sql_token funtion name</h2><span id='topic+pre_sql_fn'></span>

<h3>Description</h3>

<p>pre_sql_token funtion name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pre_sql_fn(value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pre_sql_fn_+3A_value">value</code></td>
<td>
<p>character, token string</p>
</td></tr>
</table>


<h3>Value</h3>

<p>pre_sql_token
</p>
<p>pre_sql_token
</p>

<hr>
<h2 id='pre_sql_identifier'>pre_sql_identifier: abstract name of a column and where it is comming from</h2><span id='topic+pre_sql_identifier'></span>

<h3>Description</h3>

<p>represents a value from a given sub-table or sub-expression
source is name of source
name is name for term
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pre_sql_identifier(column_name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pre_sql_identifier_+3A_column_name">column_name</code></td>
<td>
<p>character name of column</p>
</td></tr>
</table>


<h3>Value</h3>

<p>pre_sql_token
</p>

<hr>
<h2 id='pre_sql_string'>pre_sql_string</h2><span id='topic+pre_sql_string'></span>

<h3>Description</h3>

<p>represents a string constant
value character string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pre_sql_string(value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pre_sql_string_+3A_value">value</code></td>
<td>
<p>string</p>
</td></tr>
</table>


<h3>Value</h3>

<p>pre_sql_token
</p>

<hr>
<h2 id='pre_sql_sub_expr'>pre_sql_sub_expr</h2><span id='topic+pre_sql_sub_expr'></span>

<h3>Description</h3>

<p>represents an expression.  Unnamed list of pre_sql_terms and character.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pre_sql_sub_expr(terms, info = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pre_sql_sub_expr_+3A_terms">terms</code></td>
<td>
<p>list of pre_sql tokens</p>
</td></tr>
<tr><td><code id="pre_sql_sub_expr_+3A_info">info</code></td>
<td>
<p>named list of extra info with a name slot containing a single string without spaces.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>pre_sql_sub_expr
</p>

<hr>
<h2 id='pre_sql_to_query'>Return SQL transform of tokens.</h2><span id='topic+pre_sql_to_query'></span>

<h3>Description</h3>

<p>Return SQL transform of tokens.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pre_sql_to_query(
  x,
  db_info,
  ...,
  source_table = NULL,
  source_limit = NA_real_,
  using = NULL,
  qualifiers = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pre_sql_to_query_+3A_x">x</code></td>
<td>
<p>parsed tokens.</p>
</td></tr>
<tr><td><code id="pre_sql_to_query_+3A_db_info">db_info</code></td>
<td>
<p>DBI connnection or rquery_db_info object</p>
</td></tr>
<tr><td><code id="pre_sql_to_query_+3A_...">...</code></td>
<td>
<p>generic additional arguments (not used).</p>
</td></tr>
<tr><td><code id="pre_sql_to_query_+3A_source_table">source_table</code></td>
<td>
<p>character if not NULL name of source table.</p>
</td></tr>
<tr><td><code id="pre_sql_to_query_+3A_source_limit">source_limit</code></td>
<td>
<p>numeric if not NULL limit sources to this many rows.</p>
</td></tr>
<tr><td><code id="pre_sql_to_query_+3A_using">using</code></td>
<td>
<p>character, if not NULL set of columns used from above.</p>
</td></tr>
<tr><td><code id="pre_sql_to_query_+3A_qualifiers">qualifiers</code></td>
<td>
<p>named ordered vector of strings carrying additional db hierarchy terms, such as schema.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SQL command
</p>

<hr>
<h2 id='pre_sql_to_query.pre_sql_sub_expr'>Convert a pre_sql token object to SQL query text.</h2><span id='topic+pre_sql_to_query.pre_sql_sub_expr'></span>

<h3>Description</h3>

<p>Convert a pre_sql token object to SQL query text.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pre_sql_sub_expr'
pre_sql_to_query(
  x,
  db_info,
  ...,
  source_table = NULL,
  source_limit = NA_real_,
  using = NULL,
  qualifiers = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pre_sql_to_query.pre_sql_sub_expr_+3A_x">x</code></td>
<td>
<p>the pre_sql token</p>
</td></tr>
<tr><td><code id="pre_sql_to_query.pre_sql_sub_expr_+3A_db_info">db_info</code></td>
<td>
<p>representation of the database to convert to</p>
</td></tr>
<tr><td><code id="pre_sql_to_query.pre_sql_sub_expr_+3A_...">...</code></td>
<td>
<p>force later arguments to be by name</p>
</td></tr>
<tr><td><code id="pre_sql_to_query.pre_sql_sub_expr_+3A_source_table">source_table</code></td>
<td>
<p>concrete table for query</p>
</td></tr>
<tr><td><code id="pre_sql_to_query.pre_sql_sub_expr_+3A_source_limit">source_limit</code></td>
<td>
<p>numeric limit on rows from this source table</p>
</td></tr>
<tr><td><code id="pre_sql_to_query.pre_sql_sub_expr_+3A_using">using</code></td>
<td>
<p>TBD</p>
</td></tr>
<tr><td><code id="pre_sql_to_query.pre_sql_sub_expr_+3A_qualifiers">qualifiers</code></td>
<td>
<p>named ordered vector of strings carrying additional db hierarchy terms, such as schema.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SQL query text
</p>

<hr>
<h2 id='pre_sql_to_query.pre_sql_token'>Convert a pre_sql token object to SQL query text.</h2><span id='topic+pre_sql_to_query.pre_sql_token'></span>

<h3>Description</h3>

<p>Convert a pre_sql token object to SQL query text.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pre_sql_token'
pre_sql_to_query(
  x,
  db_info,
  ...,
  source_table = NULL,
  source_limit = NA_real_,
  using = NULL,
  qualifiers = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pre_sql_to_query.pre_sql_token_+3A_x">x</code></td>
<td>
<p>the pre_sql token</p>
</td></tr>
<tr><td><code id="pre_sql_to_query.pre_sql_token_+3A_db_info">db_info</code></td>
<td>
<p>representation of the database to convert to</p>
</td></tr>
<tr><td><code id="pre_sql_to_query.pre_sql_token_+3A_...">...</code></td>
<td>
<p>force later arguments to be by name</p>
</td></tr>
<tr><td><code id="pre_sql_to_query.pre_sql_token_+3A_source_table">source_table</code></td>
<td>
<p>concrete table for query</p>
</td></tr>
<tr><td><code id="pre_sql_to_query.pre_sql_token_+3A_source_limit">source_limit</code></td>
<td>
<p>numeric limit on rows from this source table</p>
</td></tr>
<tr><td><code id="pre_sql_to_query.pre_sql_token_+3A_using">using</code></td>
<td>
<p>TBD</p>
</td></tr>
<tr><td><code id="pre_sql_to_query.pre_sql_token_+3A_qualifiers">qualifiers</code></td>
<td>
<p>named ordered vector of strings carrying additional db hierarchy terms, such as schema.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SQL query text
</p>

<hr>
<h2 id='pre_sql_token'>pre_sql_token</h2><span id='topic+pre_sql_token'></span>

<h3>Description</h3>

<p>general token
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pre_sql_token(value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pre_sql_token_+3A_value">value</code></td>
<td>
<p>character, token string</p>
</td></tr>
</table>


<h3>Value</h3>

<p>pre_sql_token
</p>

<hr>
<h2 id='project'>project data by grouping, and adding aggregate columns.</h2><span id='topic+project'></span><span id='topic+project_nse'></span><span id='topic+aggregate_nse'></span>

<h3>Description</h3>

<p>Supports <code>bquote()</code> <code>.()</code>-style name abstraction including <code>.(-)</code> notation to promote strings to names
(please see here: <a href="https://github.com/WinVector/rquery/blob/master/Examples/Substitution/Substitution.md">https://github.com/WinVector/rquery/blob/master/Examples/Substitution/Substitution.md</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>project(source, ..., groupby = c(), env = parent.frame())

project_nse(source, ..., groupby = c(), env = parent.frame())

aggregate_nse(source, ..., groupby = c(), env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="project_+3A_source">source</code></td>
<td>
<p>source to select from.</p>
</td></tr>
<tr><td><code id="project_+3A_...">...</code></td>
<td>
<p>new column assignment expressions.</p>
</td></tr>
<tr><td><code id="project_+3A_groupby">groupby</code></td>
<td>
<p>grouping columns.</p>
</td></tr>
<tr><td><code id="project_+3A_env">env</code></td>
<td>
<p>environment to look for values in.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>project node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("DBI", quietly = TRUE) &amp;&amp; requireNamespace("RSQLite", quietly = TRUE)) {
  my_db &lt;- DBI::dbConnect(RSQLite::SQLite(),
                          ":memory:")
  d &lt;- rq_copy_to(
    my_db, 'd',
    data.frame(group = c('a', 'a', 'b', 'b'),
               val = 1:4,
               stringsAsFactors = FALSE))

  op_tree &lt;- d %.&gt;%
    project(., groupby = "group", vmax %:=% max(val))
  cat(format(op_tree))
  sql &lt;- to_sql(op_tree, my_db)
  cat(sql)
  execute(my_db, op_tree) %.&gt;%
     print(.)

  op_tree &lt;- d %.&gt;%
    project(., groupby = NULL, vmax %:=% max(val))
  cat(format(op_tree))
  sql &lt;- to_sql(op_tree, my_db)
  cat(sql)
  execute(my_db, op_tree) %.&gt;%
    print(.)

  DBI::dbDisconnect(my_db)
}

</code></pre>

<hr>
<h2 id='project_se'>project data by grouping, and adding aggregate columns.</h2><span id='topic+project_se'></span><span id='topic+aggregate_se'></span>

<h3>Description</h3>

<p>project data by grouping, and adding aggregate columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>project_se(source, assignments, ..., groupby = c(), env = parent.frame())

aggregate_se(source, assignments, ..., groupby = c(), env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="project_se_+3A_source">source</code></td>
<td>
<p>source to select from.</p>
</td></tr>
<tr><td><code id="project_se_+3A_assignments">assignments</code></td>
<td>
<p>new column assignment expressions.</p>
</td></tr>
<tr><td><code id="project_se_+3A_...">...</code></td>
<td>
<p>not used, force later arguments to be by name</p>
</td></tr>
<tr><td><code id="project_se_+3A_groupby">groupby</code></td>
<td>
<p>grouping columns.</p>
</td></tr>
<tr><td><code id="project_se_+3A_env">env</code></td>
<td>
<p>environment to look for values in.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>project node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("DBI", quietly = TRUE) &amp;&amp; requireNamespace("RSQLite", quietly = TRUE)) {
  my_db &lt;- DBI::dbConnect(RSQLite::SQLite(),
                          ":memory:")
  d &lt;- rq_copy_to(
    my_db, 'd',
    data.frame(group = c('a', 'a', 'b', 'b'),
               val = 1:4,
               stringsAsFactors = FALSE))

  op_tree &lt;- d %.&gt;%
    project_se(., groupby = "group", "vmax" %:=% "max(val)")
  cat(format(op_tree))
  sql &lt;- to_sql(op_tree, my_db)
  cat(sql)
  execute(my_db, op_tree) %.&gt;%
     print(.)

  op_tree &lt;- d %.&gt;%
    project_se(., groupby = NULL, "vmax" %:=% "max(val)")
  cat(format(op_tree))
  sql &lt;- to_sql(op_tree, my_db)
  cat(sql)
  execute(my_db, op_tree) %.&gt;%
     print(.)

  DBI::dbDisconnect(my_db)
}

</code></pre>

<hr>
<h2 id='quantile_cols'>Compute quantiles of specified columns
(without interpolation, needs a database with window functions).</h2><span id='topic+quantile_cols'></span>

<h3>Description</h3>

<p>Compute quantiles of specified columns
(without interpolation, needs a database with window functions).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantile_cols(
  db,
  incoming_table_name,
  ...,
  probs = seq(0, 1, 0.25),
  probs_name = "quantile_probability",
  cols = rq_colnames(db, incoming_table_name),
  qualifiers = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile_cols_+3A_db">db</code></td>
<td>
<p>database connection</p>
</td></tr>
<tr><td><code id="quantile_cols_+3A_incoming_table_name">incoming_table_name</code></td>
<td>
<p>name of table to compute quantiles of</p>
</td></tr>
<tr><td><code id="quantile_cols_+3A_...">...</code></td>
<td>
<p>force later arguments to bind by name</p>
</td></tr>
<tr><td><code id="quantile_cols_+3A_probs">probs</code></td>
<td>
<p>numeric, probabilities to compute quantiles of</p>
</td></tr>
<tr><td><code id="quantile_cols_+3A_probs_name">probs_name</code></td>
<td>
<p>character name for probability column</p>
</td></tr>
<tr><td><code id="quantile_cols_+3A_cols">cols</code></td>
<td>
<p>character, columns to compute quantiles of</p>
</td></tr>
<tr><td><code id="quantile_cols_+3A_qualifiers">qualifiers</code></td>
<td>
<p>optional named ordered vector of strings carrying additional db hierarchy terms, such as schema.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame of quantiles
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quantile_node">quantile_node</a></code>, <code><a href="#topic+rsummary">rsummary</a></code>
</p>

<hr>
<h2 id='quantile_node'>Compute quantiles over non-NULL values
(without interpolation, needs a database with window functions).</h2><span id='topic+quantile_node'></span>

<h3>Description</h3>

<p>Please see <a href="https://github.com/WinVector/rquery/blob/master/extras/Summary_Example.md">https://github.com/WinVector/rquery/blob/master/extras/Summary_Example.md</a> for an example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantile_node(
  source,
  cols = NULL,
  ...,
  probs_name = "quantile_probability",
  probs = seq(0, 1, 0.25),
  tmp_name_source = wrapr::mk_tmp_name_source("qn"),
  temporary = TRUE,
  qualifiers = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile_node_+3A_source">source</code></td>
<td>
<p>source to select from (relop or data.frame).</p>
</td></tr>
<tr><td><code id="quantile_node_+3A_cols">cols</code></td>
<td>
<p>character, compute quantiles for these columns (NULL indicates all columns).</p>
</td></tr>
<tr><td><code id="quantile_node_+3A_...">...</code></td>
<td>
<p>force later arguments to be bound by name</p>
</td></tr>
<tr><td><code id="quantile_node_+3A_probs_name">probs_name</code></td>
<td>
<p>character, column name to write probs in.</p>
</td></tr>
<tr><td><code id="quantile_node_+3A_probs">probs</code></td>
<td>
<p>numeric quantiles to compute</p>
</td></tr>
<tr><td><code id="quantile_node_+3A_tmp_name_source">tmp_name_source</code></td>
<td>
<p>wrapr::mk_tmp_name_source(), temporary name generator.</p>
</td></tr>
<tr><td><code id="quantile_node_+3A_temporary">temporary</code></td>
<td>
<p>logical, if TRUE use temporary tables</p>
</td></tr>
<tr><td><code id="quantile_node_+3A_qualifiers">qualifiers</code></td>
<td>
<p>optional named ordered vector of strings carrying additional db hierarchy terms, such as schema.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a non_sql_node, so please see <code><a href="#topic+non_sql_node">non_sql_node</a></code> for some of the issues for this node type.
</p>


<h3>Value</h3>

<p>table of quantiles
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quantile_cols">quantile_cols</a></code>, <code><a href="#topic+rsummary">rsummary</a></code>, <code><a href="#topic+non_sql_node">non_sql_node</a></code>
</p>

<hr>
<h2 id='quote_identifier'>Quote an identifier.</h2><span id='topic+quote_identifier'></span>

<h3>Description</h3>

<p>Quote an identifier.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quote_identifier(x, id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quote_identifier_+3A_x">x</code></td>
<td>
<p>database handle or rquery_db_info object.</p>
</td></tr>
<tr><td><code id="quote_identifier_+3A_id">id</code></td>
<td>
<p>character to quote</p>
</td></tr>
</table>


<h3>Value</h3>

<p>quoted identifier
</p>

<hr>
<h2 id='quote_literal'>Quote a value</h2><span id='topic+quote_literal'></span>

<h3>Description</h3>

<p>Quote a value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quote_literal(x, o)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quote_literal_+3A_x">x</code></td>
<td>
<p>database handle or rquery_db_info object.</p>
</td></tr>
<tr><td><code id="quote_literal_+3A_o">o</code></td>
<td>
<p>value to quote</p>
</td></tr>
</table>


<h3>Value</h3>

<p>quoted string
</p>

<hr>
<h2 id='quote_string'>Quote a string</h2><span id='topic+quote_string'></span>

<h3>Description</h3>

<p>Quote a string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quote_string(x, s)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quote_string_+3A_x">x</code></td>
<td>
<p>database handle or rquery_db_info object.</p>
</td></tr>
<tr><td><code id="quote_string_+3A_s">s</code></td>
<td>
<p>character to quote</p>
</td></tr>
</table>


<h3>Value</h3>

<p>quoted string
</p>

<hr>
<h2 id='quote_table_name'>Quote a table name.</h2><span id='topic+quote_table_name'></span>

<h3>Description</h3>

<p>Quote a table name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quote_table_name(x, id, ..., qualifiers = character(0))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quote_table_name_+3A_x">x</code></td>
<td>
<p>database handle or rquery_db_info object.</p>
</td></tr>
<tr><td><code id="quote_table_name_+3A_id">id</code></td>
<td>
<p>character to quote</p>
</td></tr>
<tr><td><code id="quote_table_name_+3A_...">...</code></td>
<td>
<p>not used, force later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="quote_table_name_+3A_qualifiers">qualifiers</code></td>
<td>
<p>named ordered vector of strings carrying additional db hierarchy terms, such as schema.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>quoted identifier
</p>

<hr>
<h2 id='rename_columns'>Make a rename columns node (copies columns not renamed).</h2><span id='topic+rename_columns'></span>

<h3>Description</h3>

<p>Make a rename columns node (copies columns not renamed).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rename_columns(source, cmap, env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rename_columns_+3A_source">source</code></td>
<td>
<p>source to rename from.</p>
</td></tr>
<tr><td><code id="rename_columns_+3A_cmap">cmap</code></td>
<td>
<p>map written as new column names as keys and old column names as values.</p>
</td></tr>
<tr><td><code id="rename_columns_+3A_env">env</code></td>
<td>
<p>environment to look to.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>rename columns node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("DBI", quietly = TRUE) &amp;&amp; requireNamespace("RSQLite", quietly = TRUE)) {
  my_db &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
  d &lt;- rq_copy_to(my_db, 'd',
                   data.frame(AUC = 0.6, R2 = 0.2, z = 3))
  op_tree &lt;- rename_columns(d, c('R2' %:=% 'AUC', 'AUC' %:=% 'R2'))
  cat(format(op_tree))
  sql &lt;- to_sql(op_tree, my_db)
  cat(sql)
  print(DBI::dbGetQuery(my_db, sql))
  DBI::dbDisconnect(my_db)
}

</code></pre>

<hr>
<h2 id='row_counts'>Build an optree pipeline counts rows.</h2><span id='topic+row_counts'></span>

<h3>Description</h3>

<p>This is an example of building up a desired pre-prepared pipeline fragment from relop nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>row_counts(source, ..., groupby = character(0), env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="row_counts_+3A_source">source</code></td>
<td>
<p>relop tree or data.frame source.</p>
</td></tr>
<tr><td><code id="row_counts_+3A_...">...</code></td>
<td>
<p>force later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="row_counts_+3A_groupby">groupby</code></td>
<td>
<p>partitioning (window function) column names.</p>
</td></tr>
<tr><td><code id="row_counts_+3A_env">env</code></td>
<td>
<p>environment to look for values in.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# by hand logistic regression example
d &lt;- mk_td("survey_table",
           c("subjectID", "surveyCategory", "assessmentTotal"))
optree &lt;- d %.&gt;%
  row_counts(., groupby = "subjectID")
cat(format(optree))

</code></pre>

<hr>
<h2 id='rq_colnames'>List table column names.</h2><span id='topic+rq_colnames'></span>

<h3>Description</h3>

<p>List table column names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rq_colnames(db, table_name, ..., qualifiers = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rq_colnames_+3A_db">db</code></td>
<td>
<p>Connection handle</p>
</td></tr>
<tr><td><code id="rq_colnames_+3A_table_name">table_name</code></td>
<td>
<p>character table name</p>
</td></tr>
<tr><td><code id="rq_colnames_+3A_...">...</code></td>
<td>
<p>not used, force later argument to bind by name</p>
</td></tr>
<tr><td><code id="rq_colnames_+3A_qualifiers">qualifiers</code></td>
<td>
<p>optional named ordered vector of strings carrying additional db hierarchy terms, such as schema.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character list of column names
</p>

<hr>
<h2 id='rq_coltypes'>Get column types by example values as a data.frame.</h2><span id='topic+rq_coltypes'></span>

<h3>Description</h3>

<p>Example values not necessarily all from same row.  Taking values from different rows is
to try to work around NA not carrying type/class info in many cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rq_coltypes(
  db,
  table_name,
  ...,
  qualifiers = NULL,
  prefer_not_NA = FALSE,
  force_check = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rq_coltypes_+3A_db">db</code></td>
<td>
<p>Connection handle.</p>
</td></tr>
<tr><td><code id="rq_coltypes_+3A_table_name">table_name</code></td>
<td>
<p>character table name referring to a non-empty table.</p>
</td></tr>
<tr><td><code id="rq_coltypes_+3A_...">...</code></td>
<td>
<p>force later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="rq_coltypes_+3A_qualifiers">qualifiers</code></td>
<td>
<p>optional named ordered vector of strings carrying additional db hierarchy terms, such as schema.</p>
</td></tr>
<tr><td><code id="rq_coltypes_+3A_prefer_not_na">prefer_not_NA</code></td>
<td>
<p>logical, if TRUE try to find an non-NA example for all columns (FALSE just for logical columns).</p>
</td></tr>
<tr><td><code id="rq_coltypes_+3A_force_check">force_check</code></td>
<td>
<p>logical, if TRUE perform checks regardless of check_logical_column_types option setting.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>single row data.frame with example values, not all values necessarily from same database row.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(requireNamespace("DBI", quietly = TRUE) &amp;&amp; requireNamespace("RSQLite", quietly = TRUE)) {
  db &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")

  # getDBOption(db, "check_logical_column_types", FALSE)
  # options(rq_connection_tests(db))
  # getDBOption(db, "check_logical_column_types", FALSE)

  d &lt;- data.frame(w= c(NA, 1L),
                  x= c(NA, 2.0),
                  y= factor(c(NA, "x")),
                  z= c(NA, "y"),
                  want = c(1, 0),
                  stringsAsFactors=FALSE)
  d &lt;- rq_copy_to(db, "d", d,
                   overwrite = TRUE,
                   temporary = TRUE)
  res &lt;- d %.&gt;%
    extend(.,
               wc %:=% ifelse(w&gt;1, "x", "y"),
               wn %:=% ifelse(w&gt;1, 1, 2),
               xc %:=% ifelse(x&gt;1, "x", "y"),
               xn %:=% ifelse(x&gt;1, 1, 2),
               yc %:=% ifelse(y=="a", "x", "y"),
               yn %:=% ifelse(y=="a", "x", "y")) %.&gt;%
    materialize(db, .)
  resn &lt;- DBI::dbQuoteIdentifier(db, res$table_name)
  print("full table types")
  print(str(DBI::dbGetQuery(db, paste("SELECT * FROM", resn))))
  print("single row mis-reported types")
  print(str(DBI::dbGetQuery(db, paste("SELECT * FROM", resn, "WHERE want=1"))))
  print("rq_coltypes correct synthetic example row types")
  print(str(rq_coltypes(db, res$table_name, force_check = TRUE)))
  DBI::dbDisconnect(db)
}

</code></pre>

<hr>
<h2 id='rq_connection_advice'>Get advice for a DB connection (beyond tests).</h2><span id='topic+rq_connection_advice'></span>

<h3>Description</h3>

<p>These settings are set by the package maintainers based on experience with
specific databases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rq_connection_advice(db)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rq_connection_advice_+3A_db">db</code></td>
<td>
<p>database connection handle</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list of options
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rq_connection_tests">rq_connection_tests</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(requireNamespace("DBI", quietly = TRUE) &amp;&amp; requireNamespace("RSQLite", quietly = TRUE)) {
  my_db &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
  print(rq_connection_name(my_db))
  print(rq_connection_advice(my_db))
  DBI::dbDisconnect(my_db)
}

</code></pre>

<hr>
<h2 id='rq_connection_name'>Build a canonical name for a db connection class.</h2><span id='topic+rq_connection_name'></span>

<h3>Description</h3>

<p>Build a canonical name for a db connection class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rq_connection_name(db)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rq_connection_name_+3A_db">db</code></td>
<td>
<p>Database connection handle.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character, key version of handle for option lookups.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(requireNamespace("DBI", quietly = TRUE) &amp;&amp; requireNamespace("RSQLite", quietly = TRUE)) {
  my_db &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
  print(rq_connection_name(my_db))
  DBI::dbDisconnect(my_db)
}

</code></pre>

<hr>
<h2 id='rq_connection_tests'>Try and test database for some option settings.</h2><span id='topic+rq_connection_tests'></span>

<h3>Description</h3>

<p>These settings are estimated by experiments.  This is not
the full set of options- but just the ones tested here.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rq_connection_tests(db, ..., overrides = NULL, use_advice = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rq_connection_tests_+3A_db">db</code></td>
<td>
<p>database connection handle.</p>
</td></tr>
<tr><td><code id="rq_connection_tests_+3A_...">...</code></td>
<td>
<p>force later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="rq_connection_tests_+3A_overrides">overrides</code></td>
<td>
<p>named character vector or list, options (just name, not DB qualification) to force</p>
</td></tr>
<tr><td><code id="rq_connection_tests_+3A_use_advice">use_advice</code></td>
<td>
<p>logical if TRUE incorporate hard-coded advice.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: tests are currently run in the default schema. Also it is normal to see some warning/error
messages as different database capabilities are tested.
</p>


<h3>Value</h3>

<p>named list of options
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rq_connection_advice">rq_connection_advice</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(requireNamespace("DBI", quietly = TRUE) &amp;&amp; requireNamespace("RSQLite", quietly = TRUE)) {
  my_db &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
  print(rq_connection_name(my_db))
  print(rq_connection_tests(my_db,
     overrides = c("use_DBI_dbExistsTable" = FALSE)))
  # the following would set options
  # print(options(rq_connection_tests(my_db)))
  DBI::dbDisconnect(my_db)
}

</code></pre>

<hr>
<h2 id='rq_copy_to'>Copy local R table to remote data handle.</h2><span id='topic+rq_copy_to'></span>

<h3>Description</h3>

<p>Copy local R table to remote data handle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rq_copy_to(
  db,
  table_name,
  d,
  ...,
  qualifiers = NULL,
  overwrite = FALSE,
  temporary = TRUE,
  rowidcolumn = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rq_copy_to_+3A_db">db</code></td>
<td>
<p>database connection handle.</p>
</td></tr>
<tr><td><code id="rq_copy_to_+3A_table_name">table_name</code></td>
<td>
<p>name of table to create.</p>
</td></tr>
<tr><td><code id="rq_copy_to_+3A_d">d</code></td>
<td>
<p>data.frame to copy to database.</p>
</td></tr>
<tr><td><code id="rq_copy_to_+3A_...">...</code></td>
<td>
<p>force later argument to be by name</p>
</td></tr>
<tr><td><code id="rq_copy_to_+3A_qualifiers">qualifiers</code></td>
<td>
<p>optional named ordered vector of strings carrying additional db hierarchy terms, such as schema.</p>
</td></tr>
<tr><td><code id="rq_copy_to_+3A_overwrite">overwrite</code></td>
<td>
<p>logical, if TRUE try to overwrite existing table.</p>
</td></tr>
<tr><td><code id="rq_copy_to_+3A_temporary">temporary</code></td>
<td>
<p>logical, if TRUE try to mark table as temporary.</p>
</td></tr>
<tr><td><code id="rq_copy_to_+3A_rowidcolumn">rowidcolumn</code></td>
<td>
<p>character, name to land row-ids.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a relop representation of the data
</p>


<h3>See Also</h3>

<p><code><a href="#topic+db_td">db_td</a></code>, <code><a href="#topic+mk_td">mk_td</a></code>, <code><a href="#topic+materialize">materialize</a></code>, <code><a href="#topic+execute">execute</a></code>, <code><a href="#topic+to_sql">to_sql</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("DBI", quietly = TRUE) &amp;&amp; requireNamespace("RSQLite", quietly = TRUE)) {
  db &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
  d &lt;- rq_copy_to(db, 'd',
                   data.frame(AUC = 0.6, R2 = 0.2))

  sql &lt;- to_sql(d, db)
  cat(sql)
  print(DBI::dbGetQuery(db, "SELECT * FROM d"))
  DBI::dbDisconnect(db)
}

</code></pre>

<hr>
<h2 id='rq_execute'>Execute a query, typically an update that is not supposed to return results.</h2><span id='topic+rq_execute'></span>

<h3>Description</h3>

<p>Execute a query, typically an update that is not supposed to return results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rq_execute(db, q)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rq_execute_+3A_db">db</code></td>
<td>
<p>database connection handle</p>
</td></tr>
<tr><td><code id="rq_execute_+3A_q">q</code></td>
<td>
<p>character query</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing
</p>


<h3>See Also</h3>

<p><code><a href="#topic+db_td">db_td</a></code>
</p>

<hr>
<h2 id='rq_function_mappings'>Return function mappings for a connection</h2><span id='topic+rq_function_mappings'></span>

<h3>Description</h3>

<p>Return function mappings for a connection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rq_function_mappings(db, ..., qualifiers = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rq_function_mappings_+3A_db">db</code></td>
<td>
<p>a rquery_db_info</p>
</td></tr>
<tr><td><code id="rq_function_mappings_+3A_...">...</code></td>
<td>
<p>not used, force later arguments to bind by name</p>
</td></tr>
<tr><td><code id="rq_function_mappings_+3A_qualifiers">qualifiers</code></td>
<td>
<p>optional named ordered vector of strings carrying additional db hierarchy terms, such as schema.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame of function mappings
</p>

<hr>
<h2 id='rq_get_query'>Execute a get query, typically a non-update that is supposed to return results.</h2><span id='topic+rq_get_query'></span>

<h3>Description</h3>

<p>Execute a get query, typically a non-update that is supposed to return results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rq_get_query(db, q)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rq_get_query_+3A_db">db</code></td>
<td>
<p>database connection handle</p>
</td></tr>
<tr><td><code id="rq_get_query_+3A_q">q</code></td>
<td>
<p>character query</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing
</p>


<h3>See Also</h3>

<p><code><a href="#topic+db_td">db_td</a></code>
</p>

<hr>
<h2 id='rq_head'>Get head of db table</h2><span id='topic+rq_head'></span>

<h3>Description</h3>

<p>Get head of db table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rq_head(db, table_name, ..., qualifiers = NULL, limit = 6L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rq_head_+3A_db">db</code></td>
<td>
<p>Connection handle</p>
</td></tr>
<tr><td><code id="rq_head_+3A_table_name">table_name</code></td>
<td>
<p>character table name</p>
</td></tr>
<tr><td><code id="rq_head_+3A_...">...</code></td>
<td>
<p>not used, force later argument to bind by name</p>
</td></tr>
<tr><td><code id="rq_head_+3A_qualifiers">qualifiers</code></td>
<td>
<p>optional named ordered vector of strings carrying additional db hierarchy terms, such as schema.</p>
</td></tr>
<tr><td><code id="rq_head_+3A_limit">limit</code></td>
<td>
<p>integer, how many rows to take</p>
</td></tr>
</table>


<h3>Value</h3>

<p>first few rows
</p>

<hr>
<h2 id='rq_nrow'>Count rows and return as numeric</h2><span id='topic+rq_nrow'></span>

<h3>Description</h3>

<p>Count rows and return as numeric
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rq_nrow(db, table_name, ..., qualifiers = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rq_nrow_+3A_db">db</code></td>
<td>
<p>database connection</p>
</td></tr>
<tr><td><code id="rq_nrow_+3A_table_name">table_name</code></td>
<td>
<p>character, name of table</p>
</td></tr>
<tr><td><code id="rq_nrow_+3A_...">...</code></td>
<td>
<p>not used, force later argument to bind by name</p>
</td></tr>
<tr><td><code id="rq_nrow_+3A_qualifiers">qualifiers</code></td>
<td>
<p>optional named ordered vector of strings carrying additional db hierarchy terms, such as schema.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric row count
</p>


<h3>See Also</h3>

<p><code><a href="#topic+db_td">db_td</a></code>
</p>

<hr>
<h2 id='rq_remove_table'>Remove table</h2><span id='topic+rq_remove_table'></span>

<h3>Description</h3>

<p>Remove table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rq_remove_table(db, table_name, ..., qualifiers = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rq_remove_table_+3A_db">db</code></td>
<td>
<p>database connection.</p>
</td></tr>
<tr><td><code id="rq_remove_table_+3A_table_name">table_name</code></td>
<td>
<p>character, name of table to create.</p>
</td></tr>
<tr><td><code id="rq_remove_table_+3A_...">...</code></td>
<td>
<p>not used, force later argument to bind by name</p>
</td></tr>
<tr><td><code id="rq_remove_table_+3A_qualifiers">qualifiers</code></td>
<td>
<p>optional named ordered vector of strings carrying additional db hierarchy terms, such as schema.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical TRUE if table existed, else FALSE
</p>


<h3>See Also</h3>

<p><code><a href="#topic+db_td">db_td</a></code>
</p>

<hr>
<h2 id='rq_table_exists'>Check if a table exists.</h2><span id='topic+rq_table_exists'></span>

<h3>Description</h3>

<p>Check if a table exists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rq_table_exists(db, table_name, ..., qualifiers = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rq_table_exists_+3A_db">db</code></td>
<td>
<p>Connection handle</p>
</td></tr>
<tr><td><code id="rq_table_exists_+3A_table_name">table_name</code></td>
<td>
<p>character table name</p>
</td></tr>
<tr><td><code id="rq_table_exists_+3A_...">...</code></td>
<td>
<p>not used, force later argument to bind by name</p>
</td></tr>
<tr><td><code id="rq_table_exists_+3A_qualifiers">qualifiers</code></td>
<td>
<p>optional named ordered vector of strings carrying additional db hierarchy terms, such as schema.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical TRUE if table exists.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+db_td">db_td</a></code>
</p>

<hr>
<h2 id='rquery_apply_to_data_frame'>Execute optree in an environment where d is the only data.</h2><span id='topic+rquery_apply_to_data_frame'></span>

<h3>Description</h3>

<p>Default DB uses RSQLite (so some functions are not supported).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rquery_apply_to_data_frame(
  d,
  optree,
  ...,
  limit = NULL,
  source_limit = NULL,
  allow_executor = TRUE,
  env = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rquery_apply_to_data_frame_+3A_d">d</code></td>
<td>
<p>data.frame or named list of data.frames.</p>
</td></tr>
<tr><td><code id="rquery_apply_to_data_frame_+3A_optree">optree</code></td>
<td>
<p>rquery rel_op operation tree.</p>
</td></tr>
<tr><td><code id="rquery_apply_to_data_frame_+3A_...">...</code></td>
<td>
<p>force later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="rquery_apply_to_data_frame_+3A_limit">limit</code></td>
<td>
<p>integer, if not NULL limit result to no more than this many rows.</p>
</td></tr>
<tr><td><code id="rquery_apply_to_data_frame_+3A_source_limit">source_limit</code></td>
<td>
<p>numeric if not NULL limit sources to this many rows.</p>
</td></tr>
<tr><td><code id="rquery_apply_to_data_frame_+3A_allow_executor">allow_executor</code></td>
<td>
<p>logical if TRUE allow any executor set as rquery.rquery_executor to be used.</p>
</td></tr>
<tr><td><code id="rquery_apply_to_data_frame_+3A_env">env</code></td>
<td>
<p>environment to look to.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame result
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# WARNING: example tries to change rquery.rquery_db_executor option to RSQLite and back.
if (requireNamespace("DBI", quietly = TRUE) &amp;&amp; requireNamespace("RSQLite", quietly = TRUE)) {
  db &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
  RSQLite::initExtension(db)
  old_o &lt;- options(list("rquery.rquery_db_executor" = list(db = db)))

  optree &lt;- mk_td("d", c("AUC", "R2", "D")) %.&gt;%
  	extend(., c %:=% sqrt(R2)) %.&gt;%
    orderby(., cols = "R2", reverse = "R2")

  d &lt;- data.frame(AUC = 0.6, R2 = c(0.1, 0.2), D = NA, z = 2)
  v &lt;- rquery_apply_to_data_frame(d, optree)
  print(v)

  # now load up a table without an R2 column,
  # want to show this is caught
  d &lt;- data.frame(z = 1)
  tryCatch(
     rquery_apply_to_data_frame(d, optree),
     error = function(e) { as.character(e) }
    ) %.&gt;%
    print(.)

  options(old_o)
  DBI::dbDisconnect(db)
}

</code></pre>

<hr>
<h2 id='rquery_db_info'>Build a db information stand-in</h2><span id='topic+rquery_db_info'></span>

<h3>Description</h3>

<p>Build a db information stand-in
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rquery_db_info(
  ...,
  connection = NULL,
  is_dbi = FALSE,
  identifier_quote_char = "\"",
  string_quote_char = "'",
  overrides = NULL,
  note = "",
  connection_options = rq_connection_advice(connection),
  db_methods = rquery_default_methods()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rquery_db_info_+3A_...">...</code></td>
<td>
<p>force all arguments to be by name.</p>
</td></tr>
<tr><td><code id="rquery_db_info_+3A_connection">connection</code></td>
<td>
<p>connection handle to database or Spark.</p>
</td></tr>
<tr><td><code id="rquery_db_info_+3A_is_dbi">is_dbi</code></td>
<td>
<p>if TRUE the database connection can be used with DBI.</p>
</td></tr>
<tr><td><code id="rquery_db_info_+3A_identifier_quote_char">identifier_quote_char</code></td>
<td>
<p>character, quote to put around identifiers.</p>
</td></tr>
<tr><td><code id="rquery_db_info_+3A_string_quote_char">string_quote_char</code></td>
<td>
<p>character, quote to put around strings.</p>
</td></tr>
<tr><td><code id="rquery_db_info_+3A_overrides">overrides</code></td>
<td>
<p>named list of functions to place in info.</p>
</td></tr>
<tr><td><code id="rquery_db_info_+3A_note">note</code></td>
<td>
<p>character note to add to display form.</p>
</td></tr>
<tr><td><code id="rquery_db_info_+3A_connection_options">connection_options</code></td>
<td>
<p>named list of per-connection options.</p>
</td></tr>
<tr><td><code id="rquery_db_info_+3A_db_methods">db_methods</code></td>
<td>
<p>named list of to_sql methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>rquery_db_info object
</p>

<hr>
<h2 id='rquery_default_db_info'>An example <code>rquery_db_info</code> object useful for formatting <code>SQL</code> without a database connection.</h2><span id='topic+rquery_default_db_info'></span>

<h3>Description</h3>

<p>An example <code>rquery_db_info</code> object useful for formatting <code>SQL</code> without a database connection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rquery_default_db_info()
</code></pre>


<h3>Value</h3>

<p>a rquery_db_info without a connection and vanilla settings.
</p>

<hr>
<h2 id='rquery_default_methods'>Default to_sql method implementations.</h2><span id='topic+rquery_default_methods'></span>

<h3>Description</h3>

<p>Default to_sql method implementations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rquery_default_methods()
</code></pre>


<h3>Value</h3>

<p>default implementation methods
</p>

<hr>
<h2 id='rquery-package'><code>rquery</code>: Relational Query Generator for Data Manipulation</h2><span id='topic+rquery'></span><span id='topic+rquery-package'></span>

<h3>Description</h3>

<p><code>rquery</code> supplies a piped query generator based on Edgar F. Codd's relational
algebra and operator names (plus experience using <code>SQL</code> and <code>dplyr</code> at big data
scale).  The design represents an attempt to make <code>SQL</code> more teachable by
denoting composition a sequential pipeline notation instead of nested
queries or functions.  Package features include: data processing trees
or pipelines as observable objects (able to report both columns
produced and columns used), optimized <code>SQL</code> generation as an explicit
user visible modeling step, and convenience methods for applying query
trees to in-memory data.frames.
</p>


<h3>Details</h3>

<p>Note: <code>rquery</code> is a &quot;database first&quot; design.  This means choices are made that
favor database implementation. These include: capturing the entire calculation prior
to doing any work (and using recursive methods to inspect this object, which can limit
the calculation depth to under 1000 steps at a time), preferring &quot;tame column names&quot;
(which isn't a bad idea in 'R' anyway as columns and variables are often seen as cousins),
and not preserving row or column order (or supporting numeric column indexing).  Also,
<code>rquery</code> does have a fast in-memory implementation: <code>rqdatatable</code>
(thanks to the <code>data.table</code>, so one can in fact use 'rquery' without a database.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: John Mount <a href="mailto:jmount@win-vector.com">jmount@win-vector.com</a>
</p>
<p>Other contributors:
</p>

<ul>
<li><p>  Win-Vector LLC [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/WinVector/rquery/">https://github.com/WinVector/rquery/</a>
</p>
</li>
<li> <p><a href="https://winvector.github.io/rquery/">https://winvector.github.io/rquery/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/WinVector/rquery/issues">https://github.com/WinVector/rquery/issues</a>
</p>
</li></ul>


<hr>
<h2 id='rstr'>Quick look at remote data</h2><span id='topic+rstr'></span><span id='topic+rlook'></span>

<h3>Description</h3>

<p>Quick look at remote data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rstr(
  my_db,
  tableName,
  ...,
  displayRows = 10,
  countRows = TRUE,
  qualifiers = NULL
)

rlook(
  my_db,
  tableName,
  ...,
  displayRows = 10,
  countRows = TRUE,
  qualifiers = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rstr_+3A_my_db">my_db</code></td>
<td>
<p>database handle</p>
</td></tr>
<tr><td><code id="rstr_+3A_tablename">tableName</code></td>
<td>
<p>name of table to look at</p>
</td></tr>
<tr><td><code id="rstr_+3A_...">...</code></td>
<td>
<p>not used, force later arguments to bind by name</p>
</td></tr>
<tr><td><code id="rstr_+3A_displayrows">displayRows</code></td>
<td>
<p>number of rows to sample</p>
</td></tr>
<tr><td><code id="rstr_+3A_countrows">countRows</code></td>
<td>
<p>logical, if TRUE return row count.</p>
</td></tr>
<tr><td><code id="rstr_+3A_qualifiers">qualifiers</code></td>
<td>
<p>optional named ordered vector of strings carrying additional db hierarchy terms, such as schema.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>str view of data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if ( requireNamespace("DBI", quietly = TRUE) &amp;&amp;
  requireNamespace("RSQLite", quietly = TRUE)) {
  my_db &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
  DBI::dbWriteTable(my_db,
                    'd',
                    data.frame(AUC = 0.6, R2 = 0.2),
                    overwrite = TRUE,
                    temporary = TRUE)
  rlook(my_db, 'd')
  DBI::dbDisconnect(my_db)
}

</code></pre>

<hr>
<h2 id='rsummary'>Compute usable summary of columns of remote table.</h2><span id='topic+rsummary'></span>

<h3>Description</h3>

<p>Compute per-column summaries and return as a <code>data.frame</code>.  Warning: can be an expensive operation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsummary(
  db,
  tableName,
  ...,
  countUniqueNum = FALSE,
  quartiles = FALSE,
  cols = NULL,
  qualifiers = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsummary_+3A_db">db</code></td>
<td>
<p>database connection.</p>
</td></tr>
<tr><td><code id="rsummary_+3A_tablename">tableName</code></td>
<td>
<p>name of table.</p>
</td></tr>
<tr><td><code id="rsummary_+3A_...">...</code></td>
<td>
<p>force additional arguments to be bound by name.</p>
</td></tr>
<tr><td><code id="rsummary_+3A_countuniquenum">countUniqueNum</code></td>
<td>
<p>logical, if TRUE include unique non-NA counts for numeric cols.</p>
</td></tr>
<tr><td><code id="rsummary_+3A_quartiles">quartiles</code></td>
<td>
<p>logical, if TRUE add Q1 (25%), median (50%), Q3 (75%) quartiles.</p>
</td></tr>
<tr><td><code id="rsummary_+3A_cols">cols</code></td>
<td>
<p>if not NULL set of columns to restrict to.</p>
</td></tr>
<tr><td><code id="rsummary_+3A_qualifiers">qualifiers</code></td>
<td>
<p>optional named ordered vector of strings carrying additional db hierarchy terms, such as schema.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For numeric columns includes <code>NaN</code> in <code>nna</code> count (as is typical for <code>R</code>, e.g.,
<code>is.na(NaN)</code>).
</p>


<h3>Value</h3>

<p>data.frame summary of columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("DBI", quietly = TRUE) &amp;&amp;
  requireNamespace("RSQLite", quietly = TRUE)) {
  d &lt;- data.frame(p= c(TRUE, FALSE, NA),
                  s= NA,
                  w= 1:3,
                  x= c(NA,2,3),
                  y= factor(c(3,5,NA)),
                  z= c('a',NA,'a'),
                  stringsAsFactors=FALSE)
  db &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
  RSQLite::initExtension(db)
  rq_copy_to(db, "dRemote", d,
              overwrite = TRUE, temporary = TRUE)
  print(rsummary(db, "dRemote"))
  DBI::dbDisconnect(db)
}

</code></pre>

<hr>
<h2 id='rsummary_node'>Create an rsumary relop operator node.</h2><span id='topic+rsummary_node'></span>

<h3>Description</h3>

<p>This is a non_sql_node, so please see <code><a href="#topic+non_sql_node">non_sql_node</a></code> for some of the issues for this node type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsummary_node(
  source,
  ...,
  quartiles = FALSE,
  tmp_name_source = wrapr::mk_tmp_name_source("sn"),
  temporary = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsummary_node_+3A_source">source</code></td>
<td>
<p>incoming source (relop node or data.frame).</p>
</td></tr>
<tr><td><code id="rsummary_node_+3A_...">...</code></td>
<td>
<p>force later arguments to be by name</p>
</td></tr>
<tr><td><code id="rsummary_node_+3A_quartiles">quartiles</code></td>
<td>
<p>logical, if TRUE add Q1 (25%), median (50%), Q3 (75%) quartiles.</p>
</td></tr>
<tr><td><code id="rsummary_node_+3A_tmp_name_source">tmp_name_source</code></td>
<td>
<p>wrapr::mk_tmp_name_source(), temporary name generator.</p>
</td></tr>
<tr><td><code id="rsummary_node_+3A_temporary">temporary</code></td>
<td>
<p>logical, if TRUE use temporary tables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>rsummary node
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quantile_node">quantile_node</a></code>, <code><a href="#topic+non_sql_node">non_sql_node</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("DBI", quietly = TRUE) &amp;&amp; requireNamespace("RSQLite", quietly = TRUE)) {
  d &lt;- data.frame(p= c(TRUE, FALSE, NA),
                  s= NA,
                  w= 1:3,
                  x= c(NA,2,3),
                  y= factor(c(3,5,NA)),
                  z= c('a',NA,'a'),
                  stringsAsFactors=FALSE)
  db &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
  RSQLite::initExtension(db)
  rq_copy_to(db, "dRemote", d,
              overwrite = TRUE,
              temporary = TRUE)

  ops &lt;- db_td(db, "dRemote") %.&gt;%
    extend(., v %:=% ifelse(x&gt;2, "x", "y")) %.&gt;%
    rsummary_node(.)
  cat(format(ops))

  print(to_sql(ops, db))

  reshdl &lt;- materialize(db, ops)
  print(DBI::dbGetQuery(db, to_sql(reshdl, db)))

  DBI::dbDisconnect(db)
}

</code></pre>

<hr>
<h2 id='select_columns'>Make a select columns node (not a relational operation).</h2><span id='topic+select_columns'></span>

<h3>Description</h3>

<p>Make a select columns node (not a relational operation).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_columns(source, columns, env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_columns_+3A_source">source</code></td>
<td>
<p>source to select from.</p>
</td></tr>
<tr><td><code id="select_columns_+3A_columns">columns</code></td>
<td>
<p>list of distinct column names.</p>
</td></tr>
<tr><td><code id="select_columns_+3A_env">env</code></td>
<td>
<p>environment to look to.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>select columns node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("DBI", quietly = TRUE) &amp;&amp; requireNamespace("RSQLite", quietly = TRUE)) {
  my_db &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
  d &lt;- rq_copy_to(my_db, 'd',
                   data.frame(AUC = 0.6, R2 = 0.2))
  optree &lt;- select_columns(d, 'AUC')
  cat(format(optree))
  sql &lt;- to_sql(optree, my_db)
  cat(sql)
  print(DBI::dbGetQuery(my_db, sql))
  DBI::dbDisconnect(my_db)
}

</code></pre>

<hr>
<h2 id='select_rows'>Make a select rows node.</h2><span id='topic+select_rows'></span><span id='topic+select_rows_nse'></span>

<h3>Description</h3>

<p>Supports <code>bquote()</code> <code>.()</code>-style name abstraction including <code>.(-)</code> notation to promote strings to names
(please see here: <a href="https://github.com/WinVector/rquery/blob/master/Examples/Substitution/Substitution.md">https://github.com/WinVector/rquery/blob/master/Examples/Substitution/Substitution.md</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_rows(source, expr, env = parent.frame())

select_rows_nse(source, expr, env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_rows_+3A_source">source</code></td>
<td>
<p>source to select from.</p>
</td></tr>
<tr><td><code id="select_rows_+3A_expr">expr</code></td>
<td>
<p>expression to select rows.</p>
</td></tr>
<tr><td><code id="select_rows_+3A_env">env</code></td>
<td>
<p>environment to look to.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>select rows node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("DBI", quietly = TRUE) &amp;&amp; requireNamespace("RSQLite", quietly = TRUE)) {
  my_db &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
  d &lt;- rq_copy_to(my_db, 'd',
                   data.frame(AUC = 0.6, R2 = 0.2, z = 3))
  TARGETCOL = as.name("AUC")
  optree &lt;- select_rows(d, .(TARGETCOL) &gt;= 0.5) %.&gt;%
    select_columns(., "R2")
  cat(format(optree))
  sql &lt;- to_sql(optree, my_db)
  cat(sql)
  print(DBI::dbGetQuery(my_db, sql))
  DBI::dbDisconnect(my_db)
}

</code></pre>

<hr>
<h2 id='select_rows_se'>Make a select rows node.</h2><span id='topic+select_rows_se'></span>

<h3>Description</h3>

<p>Make a select rows node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_rows_se(source, expr, env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_rows_se_+3A_source">source</code></td>
<td>
<p>source to select from.</p>
</td></tr>
<tr><td><code id="select_rows_se_+3A_expr">expr</code></td>
<td>
<p>expression to select rows.</p>
</td></tr>
<tr><td><code id="select_rows_se_+3A_env">env</code></td>
<td>
<p>environment to look for values in.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>select rows node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("DBI", quietly = TRUE) &amp;&amp; requireNamespace("RSQLite", quietly = TRUE)) {
  my_db &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
  d &lt;- rq_copy_to(my_db, 'd',
                   data.frame(AUC = 0.6, R2 = 0.2))
  optree &lt;- select_rows_se(d, "AUC &gt;= 0.5")
  cat(format(optree))
  sql &lt;- to_sql(optree, my_db)
  cat(sql)
  print(DBI::dbGetQuery(my_db, sql))
  DBI::dbDisconnect(my_db)
}
</code></pre>

<hr>
<h2 id='set_indicator'>Make a set indicator node.</h2><span id='topic+set_indicator'></span>

<h3>Description</h3>

<p>Create a new column indicating the membership of another column in a given set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_indicator(
  source,
  rescol,
  testcol,
  testvalues,
  ...,
  translate_quotes = FALSE,
  env = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_indicator_+3A_source">source</code></td>
<td>
<p>source to select from.</p>
</td></tr>
<tr><td><code id="set_indicator_+3A_rescol">rescol</code></td>
<td>
<p>name of column to land indicator in.</p>
</td></tr>
<tr><td><code id="set_indicator_+3A_testcol">testcol</code></td>
<td>
<p>name of column to check.</p>
</td></tr>
<tr><td><code id="set_indicator_+3A_testvalues">testvalues</code></td>
<td>
<p>values to check for.</p>
</td></tr>
<tr><td><code id="set_indicator_+3A_...">...</code></td>
<td>
<p>force later arguments to bind by name</p>
</td></tr>
<tr><td><code id="set_indicator_+3A_translate_quotes">translate_quotes</code></td>
<td>
<p>logical if TRUE translate quotes to SQL choice (simple replacement, no escaping).</p>
</td></tr>
<tr><td><code id="set_indicator_+3A_env">env</code></td>
<td>
<p>environment to look to.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>set_indicator node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("DBI", quietly = TRUE) &amp;&amp; requireNamespace("RSQLite", quietly = TRUE)) {
  my_db &lt;- DBI::dbConnect(RSQLite::SQLite(),
                          ":memory:")

  d &lt;- rq_copy_to(my_db, 'd',
                   data.frame(a = c("1", "2", "1", "3"),
                              b = c("1", "1", "3", "2"),
                              q = 1,
                              stringsAsFactors = FALSE),
                   temporary = TRUE,
                   overwrite = TRUE)
  # example
  set &lt;- c("1", "2")
  op_tree &lt;- d %.&gt;%
    set_indicator(., "one_two", "a", set) %.&gt;%
    set_indicator(., "z", "a", c())
  print(column_names(op_tree))
  print(columns_used(op_tree))
  cat(format(op_tree))
  sql &lt;- to_sql(op_tree, my_db)
  cat(sql)
  print(DBI::dbGetQuery(my_db, sql))

  op_tree2 &lt;- d %.&gt;%
    set_indicator(., "one_two", "a", set) %.&gt;%
    set_indicator(., "z", "b", c()) %.&gt;%
    select_columns(., c("z", "one_two"))
  print(column_names(op_tree2))
  print(columns_used(op_tree2))

  # cleanup
  DBI::dbDisconnect(my_db)
}

</code></pre>

<hr>
<h2 id='setDBOpt'>Set a database connection option.</h2><span id='topic+setDBOpt'></span>

<h3>Description</h3>

<p>If db is of class rquery_db_info it sets the appropriate connection option, not the global state.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setDBOpt(db, optname, val)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setDBOpt_+3A_db">db</code></td>
<td>
<p>rquery_db_info instance</p>
</td></tr>
<tr><td><code id="setDBOpt_+3A_optname">optname</code></td>
<td>
<p>character, single option name.</p>
</td></tr>
<tr><td><code id="setDBOpt_+3A_val">val</code></td>
<td>
<p>value to set</p>
</td></tr>
</table>


<h3>Value</h3>

<p>db
</p>

<hr>
<h2 id='setDBOption'>Set a database connection option.</h2><span id='topic+setDBOption'></span>

<h3>Description</h3>

<p>Note: we are moving away from global options to options in the DB handle.
Prefer <code><a href="#topic+setDBOpt">setDBOpt</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setDBOption(db, optname, val)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setDBOption_+3A_db">db</code></td>
<td>
<p>database connection handle.</p>
</td></tr>
<tr><td><code id="setDBOption_+3A_optname">optname</code></td>
<td>
<p>character, single option name.</p>
</td></tr>
<tr><td><code id="setDBOption_+3A_val">val</code></td>
<td>
<p>value to set</p>
</td></tr>
</table>


<h3>Value</h3>

<p>original options value
</p>

<hr>
<h2 id='sql_expr_set'>Build a query that applies a SQL expression to a set of columns.</h2><span id='topic+sql_expr_set'></span>

<h3>Description</h3>

<p>Build a query that applies a SQL expression to a set of columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sql_expr_set(source, cols, expr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sql_expr_set_+3A_source">source</code></td>
<td>
<p>incoming rel_op tree or data.frame.</p>
</td></tr>
<tr><td><code id="sql_expr_set_+3A_cols">cols</code></td>
<td>
<p>character, columns to operate in.  If a named array names are where results are landed, values names of value columns.</p>
</td></tr>
<tr><td><code id="sql_expr_set_+3A_expr">expr</code></td>
<td>
<p>character or list of character and names, expression to apply to columns &quot;.&quot; stands for column value to use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>rel_op node or data.frame (depending on input).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+null_replace">null_replace</a></code>, <code><a href="#topic+count_null_cols">count_null_cols</a></code>, <code><a href="#topic+mark_null_cols">mark_null_cols</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# WARNING: example tries to change rquery.rquery_db_executor option to RSQLite and back.
if (requireNamespace("DBI", quietly = TRUE) &amp;&amp; requireNamespace("RSQLite", quietly = TRUE)) {
  my_db &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
  RSQLite::initExtension(my_db)
  old_o &lt;- options(list("rquery.rquery_db_executor" = list(db = my_db)))

  d &lt;- rq_copy_to(my_db, 'd',
                   data.frame(AUC = c(NA, 0.5, NA),
                              R2 = c(1.0, 0.9, NA),
                              delta = 3,
                              cat = c("a", NA, "c"),
                              stringsAsFactors = FALSE))

  # example
  op_tree &lt;- d %.&gt;% sql_expr_set(., qc(AUC, R2), ". + 1")
  cat(format(op_tree))
  sql &lt;- to_sql(op_tree, my_db)
  cat(sql)
  print(DBI::dbGetQuery(my_db, sql))

  # ex2 names (but not marked as names)
  op_tree2 &lt;- d %.&gt;% sql_expr_set(., qc(AUC, R2),
     ". + 1 + delta")
  cat(to_sql(op_tree2, my_db))

  # ex3 names (also so marked)
  op_tree3 &lt;- d %.&gt;% sql_expr_set(., qc(AUC, R2),
     list(". + 1 +", as.name("delta")))
  cat(to_sql(op_tree3, my_db))

  # cleanup
  options(old_o)
  DBI::dbDisconnect(my_db)
}

</code></pre>

<hr>
<h2 id='sql_node'>Make a general SQL node.</h2><span id='topic+sql_node'></span>

<h3>Description</h3>

<p>Make a general SQL node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sql_node(
  source,
  exprs,
  ...,
  mods = NULL,
  orig_columns = TRUE,
  expand_braces = TRUE,
  translate_quotes = TRUE,
  env = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sql_node_+3A_source">source</code></td>
<td>
<p>source to work from.</p>
</td></tr>
<tr><td><code id="sql_node_+3A_exprs">exprs</code></td>
<td>
<p>SQL expressions</p>
</td></tr>
<tr><td><code id="sql_node_+3A_...">...</code></td>
<td>
<p>force later arguments to bind by name</p>
</td></tr>
<tr><td><code id="sql_node_+3A_mods">mods</code></td>
<td>
<p>SQL modifiers (GROUP BY, ORDER BY, and so on)</p>
</td></tr>
<tr><td><code id="sql_node_+3A_orig_columns">orig_columns</code></td>
<td>
<p>logical if TRUE select all original columns.</p>
</td></tr>
<tr><td><code id="sql_node_+3A_expand_braces">expand_braces</code></td>
<td>
<p>logical if TRUE use col notation to ensure col is a column name.</p>
</td></tr>
<tr><td><code id="sql_node_+3A_translate_quotes">translate_quotes</code></td>
<td>
<p>logical if TRUE translate quotes to SQL choice (simple replacement, no escaping).</p>
</td></tr>
<tr><td><code id="sql_node_+3A_env">env</code></td>
<td>
<p>environment to look to.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sql node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("DBI", quietly = TRUE) &amp;&amp; requireNamespace("RSQLite", quietly = TRUE)) {
  # example database connection
  my_db &lt;- DBI::dbConnect(RSQLite::SQLite(),
                          ":memory:")
  # load up example data
  d &lt;- rq_copy_to(
    my_db, 'd',
    data.frame(v1 = c(1, 2, NA, 3),
               v2 = c(NA, "b", NA, "c"),
               v3 = c(NA, NA, 7, 8),
               stringsAsFactors = FALSE))

  # look at table
  execute(my_db, d)

  # get list of columns
  vars &lt;- column_names(d)
  print(vars)

  # build a NA/NULLs per-row counting expression.
  # names are "quoted" by wrapping them with as.name().
  # constants can be quoted by an additional list wrapping.
  expr &lt;- lapply(vars,
                 function(vi) {
                   list("+ (CASE WHEN (",
                        as.name(vi),
                        "IS NULL ) THEN 1.0 ELSE 0.0 END)")
                 })
  expr &lt;- unlist(expr, recursive = FALSE)
  expr &lt;- c(list(0.0), expr)
  cat(paste(unlist(expr), collapse = " "))

  # instantiate the operator node
  op_tree &lt;- d %.&gt;%
    sql_node(., "num_missing" %:=% list(expr))
  cat(format(op_tree))

  # examine produced SQL
  sql &lt;- to_sql(op_tree, my_db)
  cat(sql)

  # execute
  execute(my_db, op_tree) %.&gt;%
     print(.)

  # whole process wrapped in convenience node
  op_tree2 &lt;- d %.&gt;%
    count_null_cols(., vars, "nnull")
  execute(my_db, op_tree2) %.&gt;%
    print(.)

  # sql_node also allows marking variable in quoted expressions
  ops &lt;- d %.&gt;%
     sql_node(., qae(sqrt_v1 = sqrt(.[v1])))
  execute(my_db, ops) %.&gt;%
     print(.)
  # marking variables allows for error-checking of column names
  tryCatch({
    ops &lt;- d %.&gt;%
      sql_node(., qae(sqrt_v1 = sqrt(.[v1_misspellled])))
    },
    error = function(e) {print(e)})

  DBI::dbDisconnect(my_db)
}

</code></pre>

<hr>
<h2 id='str_pre_sql_sub_expr'>Structure of a pre_sql_sub_expr</h2><span id='topic+str_pre_sql_sub_expr'></span>

<h3>Description</h3>

<p>Structure of a pre_sql_sub_expr
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_pre_sql_sub_expr(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_pre_sql_sub_expr_+3A_x">x</code></td>
<td>
<p>a pre_sql_sub_expr</p>
</td></tr>
</table>


<h3>Value</h3>

<p>charcter presentation with  denoting nesting
</p>

<hr>
<h2 id='tables_used'>Return vector of table names used.</h2><span id='topic+tables_used'></span>

<h3>Description</h3>

<p>Return vector of table names used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tables_used(node, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tables_used_+3A_node">node</code></td>
<td>
<p>rquery tree to examine.</p>
</td></tr>
<tr><td><code id="tables_used_+3A_...">...</code></td>
<td>
<p>(not used)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>names of tables used.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("DBI", quietly = TRUE) &amp;&amp; requireNamespace("RSQLite", quietly = TRUE)) {
  my_db &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
  d1 &lt;- rq_copy_to(my_db, 'd1',
                    data.frame(AUC = 0.6, R2 = 0.2))
  d2 &lt;- rq_copy_to(my_db, 'd2',
                    data.frame(AUC = 0.6, D = 0.3))
  optree &lt;- natural_join(d1, d2, by = "AUC")
  cat(format(optree))
  print(tables_used(optree))
  DBI::dbDisconnect(my_db)
}

</code></pre>

<hr>
<h2 id='theta_join'>Make a theta_join node.</h2><span id='topic+theta_join'></span><span id='topic+theta_join_nse'></span>

<h3>Description</h3>

<p>Theta join is a join on an arbitrary predicate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theta_join(
  a,
  b,
  expr,
  ...,
  jointype = "INNER",
  suffix = c("_a", "_b"),
  env = parent.frame()
)

theta_join_nse(
  a,
  b,
  expr,
  ...,
  jointype = "INNER",
  suffix = c("_a", "_b"),
  env = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="theta_join_+3A_a">a</code></td>
<td>
<p>source to select from.</p>
</td></tr>
<tr><td><code id="theta_join_+3A_b">b</code></td>
<td>
<p>source to select from.</p>
</td></tr>
<tr><td><code id="theta_join_+3A_expr">expr</code></td>
<td>
<p>unquoted join condition</p>
</td></tr>
<tr><td><code id="theta_join_+3A_...">...</code></td>
<td>
<p>force later arguments to be by name</p>
</td></tr>
<tr><td><code id="theta_join_+3A_jointype">jointype</code></td>
<td>
<p>type of join ('INNER', 'LEFT', 'RIGHT', 'FULL').</p>
</td></tr>
<tr><td><code id="theta_join_+3A_suffix">suffix</code></td>
<td>
<p>character length 2, suffices to disambiguate columns.</p>
</td></tr>
<tr><td><code id="theta_join_+3A_env">env</code></td>
<td>
<p>environment to look for values in.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>theta_join node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("DBI", quietly = TRUE) &amp;&amp; requireNamespace("RSQLite", quietly = TRUE)) {
  my_db &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
  d1 &lt;- rq_copy_to(my_db, 'd1',
                    data.frame(AUC = 0.6, R2 = 0.2))
  d2 &lt;- rq_copy_to(my_db, 'd2',
                    data.frame(AUC2 = 0.4, R2 = 0.3))
  optree &lt;- theta_join(d1, d2, AUC &gt;= AUC2)
  cat(format(optree))
  sql &lt;- to_sql(optree, my_db)
  cat(sql)
  print(DBI::dbGetQuery(my_db, sql))
  DBI::dbDisconnect(my_db)
}

</code></pre>

<hr>
<h2 id='theta_join_se'>Make a theta_join node.</h2><span id='topic+theta_join_se'></span>

<h3>Description</h3>

<p>Theta join is a join on an arbitrary predicate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theta_join_se(
  a,
  b,
  expr,
  ...,
  jointype = "INNER",
  suffix = c("_a", "_b"),
  env = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="theta_join_se_+3A_a">a</code></td>
<td>
<p>source to select from.</p>
</td></tr>
<tr><td><code id="theta_join_se_+3A_b">b</code></td>
<td>
<p>source to select from.</p>
</td></tr>
<tr><td><code id="theta_join_se_+3A_expr">expr</code></td>
<td>
<p>quoted join conditions</p>
</td></tr>
<tr><td><code id="theta_join_se_+3A_...">...</code></td>
<td>
<p>force later arguments to be by name</p>
</td></tr>
<tr><td><code id="theta_join_se_+3A_jointype">jointype</code></td>
<td>
<p>type of join ('INNER', 'LEFT', 'RIGHT', 'FULL').</p>
</td></tr>
<tr><td><code id="theta_join_se_+3A_suffix">suffix</code></td>
<td>
<p>character length 2, suffices to disambiguate columns.</p>
</td></tr>
<tr><td><code id="theta_join_se_+3A_env">env</code></td>
<td>
<p>environment to look for values in.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>theta_join node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("DBI", quietly = TRUE) &amp;&amp; requireNamespace("RSQLite", quietly = TRUE)) {
  my_db &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
  d1 &lt;- rq_copy_to(my_db, 'd1',
                    data.frame(AUC = 0.6, R2 = 0.2))
  d2 &lt;- rq_copy_to(my_db, 'd2',
                    data.frame(AUC2 = 0.4, R2 = 0.3))
  optree &lt;- theta_join_se(d1, d2, "AUC &gt;= AUC2")
  cat(format(optree))
  sql &lt;- to_sql(optree, my_db)
  cat(sql)
  print(DBI::dbGetQuery(my_db, sql))
  DBI::dbDisconnect(my_db)
}

</code></pre>

<hr>
<h2 id='to_sql'>Return SQL implementation of operation tree.</h2><span id='topic+to_sql'></span>

<h3>Description</h3>

<p>Add to last argument and pass all others through.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_sql(
  x,
  db,
  ...,
  limit = NULL,
  source_limit = NULL,
  indent_level = 0,
  tnum = mk_tmp_name_source("tsql"),
  append_cr = TRUE,
  using = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_sql_+3A_x">x</code></td>
<td>
<p>rquery operation tree.</p>
</td></tr>
<tr><td><code id="to_sql_+3A_db">db</code></td>
<td>
<p>DBI database handle or rquery_db_info object.</p>
</td></tr>
<tr><td><code id="to_sql_+3A_...">...</code></td>
<td>
<p>generic additional arguments (not used).</p>
</td></tr>
<tr><td><code id="to_sql_+3A_limit">limit</code></td>
<td>
<p>numeric if not NULL limit result to this many rows.</p>
</td></tr>
<tr><td><code id="to_sql_+3A_source_limit">source_limit</code></td>
<td>
<p>numeric if not NULL limit sources to this many rows.</p>
</td></tr>
<tr><td><code id="to_sql_+3A_indent_level">indent_level</code></td>
<td>
<p>level to indent.</p>
</td></tr>
<tr><td><code id="to_sql_+3A_tnum">tnum</code></td>
<td>
<p>temp sub-query name generator.</p>
</td></tr>
<tr><td><code id="to_sql_+3A_append_cr">append_cr</code></td>
<td>
<p>logical if TRUE end with CR.</p>
</td></tr>
<tr><td><code id="to_sql_+3A_using">using</code></td>
<td>
<p>character, if not NULL set of columns used from above.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SQL command
</p>


<h3>See Also</h3>

<p><code><a href="#topic+db_td">db_td</a></code>, <code><a href="#topic+materialize">materialize</a></code>, <code><a href="#topic+execute">execute</a></code>, <code><a href="#topic+rq_copy_to">rq_copy_to</a></code>, <code><a href="#topic+mk_td">mk_td</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("DBI", quietly = TRUE) &amp;&amp; requireNamespace("RSQLite", quietly = TRUE)) {
  my_db &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
  d1 &lt;- rq_copy_to(my_db, 'd1',
                    data.frame(AUC = 0.6, R2 = 0.2))
  d2 &lt;- rq_copy_to(my_db, 'd2',
                    data.frame(AUC = 0.6, D = 0.3))
  optree &lt;- natural_join(d1, d2, by = "AUC")
  cat(format(optree))
  print(to_sql(optree, my_db))
  DBI::dbDisconnect(my_db)
}

</code></pre>

<hr>
<h2 id='to_transport_representation'>Convert an rquery op diagram to a simple representation, appropriate for conversion to YAML.</h2><span id='topic+to_transport_representation'></span>

<h3>Description</h3>

<p>Convert an rquery op diagram to a simple representation, appropriate for conversion to YAML.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_transport_representation(ops, ..., convert_named_vectors_to_lists = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_transport_representation_+3A_ops">ops</code></td>
<td>
<p>rquery operator dag</p>
</td></tr>
<tr><td><code id="to_transport_representation_+3A_...">...</code></td>
<td>
<p>not used, force later arguments to be by name</p>
</td></tr>
<tr><td><code id="to_transport_representation_+3A_convert_named_vectors_to_lists">convert_named_vectors_to_lists</code></td>
<td>
<p>logical, if TRUE convert named vectors to lists</p>
</td></tr>
</table>


<h3>Value</h3>

<p>represenation structure
</p>

<hr>
<h2 id='tokenize_for_SQL'>Cross-parse from an R parse tree into SQL.</h2><span id='topic+tokenize_for_SQL'></span>

<h3>Description</h3>

<p>Cross-parse from an R parse tree into SQL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tokenize_for_SQL(lexpr, colnames, env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tokenize_for_SQL_+3A_lexpr">lexpr</code></td>
<td>
<p>item from  <code>substitute</code></p>
</td></tr>
<tr><td><code id="tokenize_for_SQL_+3A_colnames">colnames</code></td>
<td>
<p>column names of table</p>
</td></tr>
<tr><td><code id="tokenize_for_SQL_+3A_env">env</code></td>
<td>
<p>environment to look for values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sql info: list(presentation, parsed_toks(list of tokens), sql_text, symbols_used, symbols_produced, free_symbols)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tokenize_for_SQL(substitute(1 + 2), colnames= NULL)
tokenize_for_SQL(substitute(a := 3), colnames= NULL)
tokenize_for_SQL(substitute(a %:=% ( 3 + 4 )), colnames= NULL)

</code></pre>

<hr>
<h2 id='topo_sort_tables'>Topologically sort join plan so values are available before uses.</h2><span id='topic+topo_sort_tables'></span>

<h3>Description</h3>

<p>Depends on <code>igraph</code> package.
Please see <code>vignette('DependencySorting', package = 'rquery')</code> and <code>vignette('joinController', package= 'rquery')</code> for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>topo_sort_tables(columnJoinPlan, leftTableName, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="topo_sort_tables_+3A_columnjoinplan">columnJoinPlan</code></td>
<td>
<p>join plan</p>
</td></tr>
<tr><td><code id="topo_sort_tables_+3A_lefttablename">leftTableName</code></td>
<td>
<p>which table is left</p>
</td></tr>
<tr><td><code id="topo_sort_tables_+3A_...">...</code></td>
<td>
<p>force later arguments to bind by name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with dependencyGraph and sorted columnJoinPlan
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("DBI", quietly = TRUE) &amp;&amp; requireNamespace("RSQLite", quietly = TRUE) &amp;&amp;
    requireNamespace('igraph', quietly = TRUE)) {
  # note: employeeanddate is likely built as a cross-product
  #       join of an employee table and set of dates of interest
  #       before getting to the join controller step.  We call
  #       such a table "row control" or "experimental design."
  my_db &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
  RSQLite::initExtension(my_db)
  tDesc &lt;- example_employee_date(my_db)
  columnJoinPlan &lt;- build_join_plan(tDesc, check= FALSE)
  # unify keys
  columnJoinPlan$resultColumn[columnJoinPlan$resultColumn=='id'] &lt;- 'eid'
  # look at plan defects
  print(paste('problems:',
              inspect_join_plan(tDesc, columnJoinPlan)))
  # fix plan
  sorted &lt;- topo_sort_tables(columnJoinPlan, 'employeeanddate')
  print(paste('problems:',
              inspect_join_plan(tDesc, sorted$columnJoinPlan)))
  print(plot(sorted$dependencyGraph))
  DBI::dbDisconnect(my_db)
  my_db &lt;- NULL
}

</code></pre>

<hr>
<h2 id='unionall'>Make an unionall node (not a relational operation).</h2><span id='topic+unionall'></span>

<h3>Description</h3>

<p>Concatenate tables by rows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unionall(sources, env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unionall_+3A_sources">sources</code></td>
<td>
<p>list of relop trees or list of data.frames</p>
</td></tr>
<tr><td><code id="unionall_+3A_env">env</code></td>
<td>
<p>environment to look to.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>order_by node or altered data.frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("DBI", quietly = TRUE) &amp;&amp; requireNamespace("RSQLite", quietly = TRUE)) {
  my_db &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
  d &lt;- rq_copy_to(my_db, 'd',
                   data.frame(AUC = 0.6, R2 = 0.2))
  optree &lt;- unionall(list(d, d, d))
  cat(format(optree))
  sql &lt;- to_sql(optree, my_db, limit = 2)
  cat(sql)
  print(DBI::dbGetQuery(my_db, sql))
  DBI::dbDisconnect(my_db)
}

</code></pre>

<hr>
<h2 id='wrap'>Wrap a data frame for later execution.</h2><span id='topic+wrap'></span>

<h3>Description</h3>

<p>Create a table description that includes the actual data.  Prevents wastefull table copies in
immediate pipelines.  Used with <code>ex()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wrap(d, ..., table_name = NULL, env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wrap_+3A_d">d</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="wrap_+3A_...">...</code></td>
<td>
<p>not used, force later argument to be referred by name</p>
</td></tr>
<tr><td><code id="wrap_+3A_table_name">table_name</code></td>
<td>
<p>character, name of table</p>
</td></tr>
<tr><td><code id="wrap_+3A_env">env</code></td>
<td>
<p>environment to work in.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a table description, with data attached
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(requireNamespace('rqdatatable')) {
 d &lt;- data.frame(x = 1:3, y = 4:6)
 d %.&gt;%
   wrap(.) %.&gt;%
   extend(., z := x + y) %.&gt;%
   ex(.)
}

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
