<!DOCTYPE html><html lang="en"><head><title>Help for package ShapeSelectForest</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ShapeSelectForest}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ShapeSelectForest-package'><p>Shape Selection for Landsat Time Series of Forest Dynamics</p></a></li>
<li><a href='#edf0s'><p>A 21 by 7 Matrix Storing Edf0 Vectors</p></a></li>
<li><a href='#f2a.map.jpeg'><p>f2a.map.jpeg</p></a></li>
<li><a href='#f2a.raster'>
<p>Raster based flat-to-annual function.</p></a></li>
<li><a href='#f2p.raster'>
<p>Raster based flat-to-parameter function.</p></a></li>
<li><a href='#flat2annual'>
<p>flat2annual</p></a></li>
<li><a href='#flat2parameter'><p>flat2parameter</p></a></li>
<li><a href='#getedf0'><p>Get the Edf0 Vector for the Shape Routine</p></a></li>
<li><a href='#plotshape'><p>The Plot Routine for an Object of the Shape Routine</p></a></li>
<li><a href='#shape'><p>Shape Selection</p></a></li>
<li><a href='#shapeparams'><p>Shape Parameters</p></a></li>
<li><a href='#ymat'><p>Response Variable Matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Shape Selection for Landsat Time Series of Forest Dynamics</td>
</tr>
<tr>
<td>Version:</td>
<td>1.7</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-19</td>
</tr>
<tr>
<td>Description:</td>
<td>Landsat satellites collect important data about global forest conditions. Documentation about Landsat's role in forest disturbance estimation is available at the site <a href="https://landsat.gsfc.nasa.gov/">https://landsat.gsfc.nasa.gov/</a>. By constrained quadratic B-splines, this package delivers an optimal shape-restricted trajectory to a time series of Landsat imagery for the purpose of modeling annual forest disturbance dynamics to behave in an ecologically sensible manner assuming one of seven possible "shapes", namely, flat, decreasing, one-jump (decreasing, jump up, decreasing), inverted vee (increasing then decreasing), vee (decreasing then increasing), linear increasing, and double-jump (decreasing, jump up, decreasing, jump up, decreasing). The main routine selects the best shape according to the minimum Bayes information criterion (BIC) or the cone information criterion (CIC), which is defined as the log of the estimated predictive squared error. The package also provides parameters summarizing the temporal pattern including year(s) of inflection, magnitude of change, pre- and post-inflection rates of growth or recovery. In addition, it contains routines for converting a flat map of disturbance agents to time-series disturbance maps and a graphical routine displaying the fitted trajectory of Landsat imagery. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>coneproj (&ge; 1.6), raster (&ge; 2.3-40), R (&ge; 3.0.2)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Suggests:</td>
<td>stats, MASS, graphics, grDevices, utils</td>
</tr>
<tr>
<td>Author:</td>
<td>Xiyue Liao <a href="https://orcid.org/0000-0002-4508-9219"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Mary Meyer [aut],
  Elizabeth Freeman [aut],
  Gretchen Moisen [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Xiyue Liao &lt;xliao@sdsu.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-19 16:05:16 UTC; xliao</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-19 16:42:35 UTC</td>
</tr>
</table>
<hr>
<h2 id='ShapeSelectForest-package'>Shape Selection for Landsat Time Series of Forest Dynamics</h2><span id='topic+ShapeSelectForest-package'></span><span id='topic+ShapeSelectForest'></span>

<h3>Description</h3>

<p>Given a scatterplot of <code class="reqn">(x_i, y_i)</code>, <code class="reqn">i = 1,\ldots,n</code>, where <code class="reqn">\bold{x}</code> could be a vector of years and <code class="reqn">\bold{y}</code> could be a vector of Landsat signals, constrained least-squares spline fits are obtained for the following shapes:
</p>

<ul>
<li><p>1. flat
</p>
</li>
<li><p>2. decreasing
</p>
</li>
<li><p>3. one-jump, i.e., decreasing, jump up, decreasing
</p>
</li>
<li><p>4. inverted vee (increasing then decreasing)
</p>
</li>
<li><p>5. vee (decreasing then increasing)
</p>
</li>
<li><p>6. linear increasing
</p>
</li>
<li><p>7. double-jump, i.e., decreasing, jump up, decreasing, jump up, decreasing.
</p>
</li></ul>

<p>The shape with the smallest information criterion may be considered a &quot;best&quot; fit. This shape-selection problem was motivated by a need to identify types of disturbances to areas of forest, given Landsat signals over a number of years. The satellite signal is constant or slowly decreasing for a healthy forest, with a jump upward in the signal caused by mass destruction of trees.
</p>
<p>The main routine to select the shape for a scatterplot is &quot;shape&quot;. See <code><a href="#topic+shape">shape</a></code> for more details.
</p>


<h3>Author(s)</h3>

<p>Mary C. Meyer, Xiyue Liao, Elizabeth Freeman, Gretchen G. Moisen 
</p>
<p>Maintainer: Xiyue Liao &lt;xiyue@rams.colostate.edu&gt;
</p>


<h3>References</h3>

<p>Meyer, M. C. and Woodroofe M (2000) On the Degrees of Freedom in Shape-Restricted Regression. <em>The Annals of Statistics <b>28</b></em>, 1083&ndash;1104.
</p>
<p>Meyer, M. C. (2013a) Semi-parametric additive constrained regression. 
<em>Journal of Nonparametric Statistics <b>25(3)</b></em>, 715.
</p>
<p>Meyer, M. C. (2013b) A simple new algorithm for quadratic programming with applications in statistics. <em>Communications in Statistics <b>42(5)</b></em>, 1126&ndash;1139.  
</p>
<p>Liao, X. and M. C. Meyer (2014) coneproj: An R package for the primal or dual cone projections with routines for constrained regression. <em>Journal of Statistical Software <b>61(12)</b></em>, 1&ndash;22.
</p>

<hr>
<h2 id='edf0s'>A 21 by 7 Matrix Storing Edf0 Vectors</h2><span id='topic+edf0s'></span>

<h3>Description</h3>

<p>The object &quot;edf0s&quot; is a <code class="reqn">21</code> by <code class="reqn">7</code> matrix. Each row is an edf0 vector of <code class="reqn">7</code> elements corresponding to the <code class="reqn">7</code> shapes in this package. Such a vector will be used in the main routine &quot;shape&quot; to select the best shape for a scatterplot of Landsat signals. Each edf0 vector is simulated through a subroutine called &quot;getedf0&quot;, using a total of <code class="reqn">1000</code> simulations with the random seed being set to <code class="reqn">123</code>. Each row is an edf0 vector for an equally spaced <code class="reqn">\bold{x}</code> vector of <code class="reqn">n</code> elements (e.g., years). From the first row to the last row, the edf0 vector is for a predictor vector <code class="reqn">\bold{x}</code> of length <code class="reqn">n</code> which is an integer ranging from <code class="reqn">20</code> to <code class="reqn">40</code>. The matrix is built for the convenience of users when they call the routine &quot;shape&quot;. 
</p>
<p>If the <code class="reqn">\bold{x}</code> vector is equally spaced and its number of elements <code class="reqn">n</code> is between <code class="reqn">20</code> and <code class="reqn">40</code>, then a corresponding edf0 vector will be extracted directly from this matrix and no simulation will be done, which saves a lot of time; otherwise, the subroutine &quot;getedf0&quot; will be called inside the routine &quot;shape&quot; to get an edf0 vector for <code class="reqn">\bold{x}</code>. The timing depends on the number of elements in <code class="reqn">\bold{x}</code> and the shape options allowed by the user. For example, when <code class="reqn">\bold{x}</code> is an equally spaced vector of <code class="reqn">26</code> elements, the timing is about <code class="reqn">167</code> seconds if the user allows a double-jump shape and the timing is about <code class="reqn">12</code> seconds if the user doesn't allow a double-jump shape. Also, when <code class="reqn">\bold{x}</code> is not an equally spaced vector, no matter how many elements it has, &quot;getedf0&quot; should be called.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("edf0s")</code></pre>


<h3>Format</h3>

<p>A 21 by 7 matrix.</p>


<h3>See Also</h3>

<p><code><a href="#topic+shape">shape</a></code>, <code><a href="#topic+ShapeSelectForest-package">ShapeSelectForest-package</a></code></p>

<hr>
<h2 id='f2a.map.jpeg'>f2a.map.jpeg</h2><span id='topic+f2a.map.jpeg'></span>

<h3>Description</h3>

<p>Creates a time series of jpegs. One jpeg is created for each year of the map output of <code><a href="#topic+f2a.raster">f2a.raster</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f2a.map.jpeg(years, folder, OUTPUT.fn, height = 10, 
width = 10 * (dim(mapgrid.dist)[2] / dim(mapgrid.dist)[1]), 
units = "in", res = 400)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="f2a.map.jpeg_+3A_years">years</code></td>
<td>
<p>Vector of the years included in the time series data.</p>
</td></tr>
<tr><td><code id="f2a.map.jpeg_+3A_folder">folder</code></td>
<td>
<p>Folder (full path) containing the input rasters. This is also the folder where the output will be written.</p>
</td></tr>
<tr><td><code id="f2a.map.jpeg_+3A_output.fn">OUTPUT.fn</code></td>
<td>
<p>Filename of output from <code><a href="#topic+f2a.raster">f2a.raster</a></code>.</p>
</td></tr>
<tr><td><code id="f2a.map.jpeg_+3A_height">height</code></td>
<td>
<p>The height of the device.</p>
</td></tr>
<tr><td><code id="f2a.map.jpeg_+3A_width">width</code></td>
<td>
<p>The width of the device.  The default is the width that will give accurate ratio of height to width for a raster.</p>
</td></tr>
<tr><td><code id="f2a.map.jpeg_+3A_units">units</code></td>
<td>
<p>The units in which <code>height</code> and <code>width</code> are given, which can be <code>px</code> (pixels, the default), <code>in</code> (inches), <code>cm</code> or <code>mm</code>.</p>
</td></tr>
<tr><td><code id="f2a.map.jpeg_+3A_res">res</code></td>
<td>
<p>The nominal resolution in ppi which will be recorded in the bitmap file, if a positive integer. Also used for units other than the default. If not specified, taken as 300 ppi to set the size of text and line widths.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates one jpeg for each year in <code>years</code>.
</p>


<h3>Value</h3>

<p>Returns nothing
</p>


<h3>Author(s)</h3>

<p>Liz Freeman
</p>


<h3>See Also</h3>

<p><code><a href="#topic+f2a.raster">f2a.raster</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
	# define years
	years &lt;- c(1984, 1986:2010)
	
	# define a folder for all outputs
	folder.in &lt;- paste(system.file(package = "ShapeSelectForest"), 
	"extdata", "helpexamples", sep = "/")
	folder.out &lt;- getwd()

	# define filenames
	flat.pred.fn &lt;- "MINI_FLATPRED.img"
	b5.fn &lt;- "MINI_B5.img"
	fi.fn &lt;- "MINI_FI.img"
	nbr.fn &lt;- "MINI_NBR.img"
	ndvi.fn &lt;- "MINI_NDVI.img"
	INPUT.bands &lt;- c(b5.fn, fi.fn, nbr.fn, ndvi.fn)

	# call f2a.raster
	ans1 &lt;- f2a.raster(years = years, folder.in = folder.in, folder.out = folder.out, 
	OUTPUT.fn &lt;- "f2a_example.img", flat.pred.fn = flat.pred.fn, INPUT.bands = INPUT.bands)

	# create jpegs 
	ans2 &lt;- f2a.map.jpeg(years = years, folder = folder.out, OUTPUT.fn = "f2a_example.img")

## End(Not run)
</code></pre>

<hr>
<h2 id='f2a.raster'>
Raster based flat-to-annual function.
</h2><span id='topic+f2a.raster'></span>

<h3>Description</h3>

<p>Applies <code><a href="#topic+flat2annual">flat2annual</a></code> to each pixel in a raster to produce time series maps of disturbance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f2a.raster(years, folder.in, folder.out, OUTPUT.fn, flat.pred.fn, INPUT.bands,
layer.shape = 1, layer.dyr = 2, layer.dur = 5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="f2a.raster_+3A_years">years</code></td>
<td>
<p>Vector of the years included in the time series data.
</p>
</td></tr>
<tr><td><code id="f2a.raster_+3A_folder.in">folder.in</code></td>
<td>
<p>Folder (full path) containing the input rasters.
</p>
</td></tr>
<tr><td><code id="f2a.raster_+3A_folder.out">folder.out</code></td>
<td>
<p>Folder where the output will be written.
</p>
</td></tr>
<tr><td><code id="f2a.raster_+3A_output.fn">OUTPUT.fn</code></td>
<td>
<p>Filename for output. The extension of this filename will specify the output file type. For image files, <code>OUTPUT.fn</code> should end in <code>.img</code>. 
</p>
</td></tr>
<tr><td><code id="f2a.raster_+3A_flat.pred.fn">flat.pred.fn</code></td>
<td>
<p>Filename of a single layer <code>.img</code> file of the disturbance agents. The agents are specified by the integers from 0 to 6.
</p>

<table>
<tr>
 <td style="text-align: left;">
	  </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>0</code> </td><td style="text-align: left;"> Unclassified</td>
</tr>
<tr>
 <td style="text-align: left;">
	  </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>1</code> </td><td style="text-align: left;"> Conversion</td>
</tr>
<tr>
 <td style="text-align: left;">
	  </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>2</code> </td><td style="text-align: left;"> Fire</td>
</tr>
<tr>
 <td style="text-align: left;">
	  </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>3</code> </td><td style="text-align: left;"> Harvest</td>
</tr>
<tr>
 <td style="text-align: left;">	
	  </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>4</code> </td><td style="text-align: left;"> Stable</td>
</tr>
<tr>
 <td style="text-align: left;">
	  </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>5</code> </td><td style="text-align: left;"> Stress</td>
</tr>
<tr>
 <td style="text-align: left;">
	  </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>6</code> </td><td style="text-align: left;"> Recovery</td>
</tr>

</table>

</td></tr>
<tr><td><code id="f2a.raster_+3A_input.bands">INPUT.bands</code></td>
<td>
<p> Filenames of the multi-layer <code>.img</code> files of the shapes to be used.
</p>
</td></tr>
<tr><td><code id="f2a.raster_+3A_layer.shape">layer.shape</code></td>
<td>
<p> Number giving the layer of the shape files containing the shape data.
</p>
</td></tr>
<tr><td><code id="f2a.raster_+3A_layer.dyr">layer.dyr</code></td>
<td>
<p> Number giving the layer of the shape files containing the disturbance year data.
</p>
</td></tr>
<tr><td><code id="f2a.raster_+3A_layer.dur">layer.dur</code></td>
<td>
<p> Number giving the layer of the shape files containing the disturbance duration data.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function writes a multi-layer raster with one layer for each year in <code>years</code> given the predicted agent for each pixel at each year.
</p>
<p>The layers for shape, dyr and dur need to be the same in all files named in <code>INPUT.bands</code>. The default is <code>layer.shape = 1</code>, <code>layer.dyr = 2</code>, and <code>layer.dur = 5</code>.
</p>


<h3>Value</h3>

<p>The function does not return a value. Instead, a multi-band <code>.img</code> map file is created.
</p>


<h3>Author(s)</h3>

<p>Liz Freeman
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flat2annual">flat2annual</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
	# define years
	years &lt;- c(1984, 1986:2010)

	# define a folder for all output
	folder.in &lt;- paste(system.file(package = "ShapeSelectForest"), 
	"extdata", "helpexamples", sep = "/")
	folder.out &lt;- getwd()	

	# define filenames
	flat.pred.fn &lt;- "MINI_FLATPRED.img"
	b5.fn &lt;- "MINI_B5.img"
	fi.fn &lt;- "MINI_FI.img"
	nbr.fn &lt;- "MINI_NBR.img"
	ndvi.fn &lt;- "MINI_NDVI.img"
	INPUT.bands &lt;- c(b5.fn, fi.fn, nbr.fn, ndvi.fn)

	# call f2a.raster
	ans &lt;- f2a.raster(years = years, folder.in = folder.in, folder.out = folder.out, 
	OUTPUT.fn = "f2a_example.img", flat.pred.fn = flat.pred.fn, INPUT.bands = INPUT.bands)

## End(Not run)
</code></pre>

<hr>
<h2 id='f2p.raster'>
Raster based flat-to-parameter function.
</h2><span id='topic+f2p.raster'></span>

<h3>Description</h3>

<p>Applies <code><a href="#topic+flat2parameter">flat2parameter</a></code> to each pixel in a raster to produce maps of disturbance parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f2p.raster(years, folder.in, folder.out, OUTPUT.fn, flat.pred.fn, INPUT.bands,
layer.shape = 1, layer.dyr = 2, layer.dur = 5, layer.mag = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="f2p.raster_+3A_years">years</code></td>
<td>
<p> Vector of the years included in the time series data.
</p>
</td></tr>
<tr><td><code id="f2p.raster_+3A_folder.in">folder.in</code></td>
<td>
<p> Folder (full path) containing the input rasters.
</p>
</td></tr>
<tr><td><code id="f2p.raster_+3A_folder.out">folder.out</code></td>
<td>
<p> Folder where the output will be written.
</p>
</td></tr>
<tr><td><code id="f2p.raster_+3A_output.fn">OUTPUT.fn</code></td>
<td>
<p> Filename for output. The extension of this filename will specify the output file type. For image files, <code>OUTPUT.fn</code> should end in <code>.img</code> 
</p>
</td></tr>
<tr><td><code id="f2p.raster_+3A_flat.pred.fn">flat.pred.fn</code></td>
<td>
<p> Filename of a single layer <code>.img</code> file of the disturbance agents. The agents are specified by the integers from 0 to 6.
</p>

<table>
<tr>
 <td style="text-align: left;">
	  </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>0</code> </td><td style="text-align: left;"> Unclassified</td>
</tr>
<tr>
 <td style="text-align: left;">
	  </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>1</code> </td><td style="text-align: left;"> Conversion</td>
</tr>
<tr>
 <td style="text-align: left;">
	  </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>2</code> </td><td style="text-align: left;"> Fire</td>
</tr>
<tr>
 <td style="text-align: left;">
	  </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>3</code> </td><td style="text-align: left;"> Harvest</td>
</tr>
<tr>
 <td style="text-align: left;">	
	  </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>4</code> </td><td style="text-align: left;"> Stable</td>
</tr>
<tr>
 <td style="text-align: left;">
	  </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>5</code> </td><td style="text-align: left;"> Stress</td>
</tr>
<tr>
 <td style="text-align: left;">
	  </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>6</code> </td><td style="text-align: left;"> Recovery</td>
</tr>

</table>

</td></tr>
<tr><td><code id="f2p.raster_+3A_input.bands">INPUT.bands</code></td>
<td>
<p> Filenames of the multi-layer <code>.img</code> files of the shapes to be used.
</p>
</td></tr>
<tr><td><code id="f2p.raster_+3A_layer.shape">layer.shape</code></td>
<td>
<p> Number giving the layer of the shape files containing the shape data.
</p>
</td></tr>
<tr><td><code id="f2p.raster_+3A_layer.dyr">layer.dyr</code></td>
<td>
<p> Number giving the layer of the shape files containing the disturbance year data.
</p>
</td></tr>
<tr><td><code id="f2p.raster_+3A_layer.dur">layer.dur</code></td>
<td>
<p> Number giving the layer of the shape files containing the disturbance duration data.
</p>
</td></tr>
<tr><td><code id="f2p.raster_+3A_layer.mag">layer.mag</code></td>
<td>
<p> Number giving the layer of the shape files containing the disturbance magnitude data.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function writes a seven-layer raster with layers for disturbance agent, median disturbance year, median disturbance duration and magnitude of all image files given in <code>INPUT.bands</code>, in the order the filenames are listed in <code>INPUT.bands</code>.
</p>
<p>The layers for shape, dyr and dur need to be the same in all files named in <code>INPUT.bands</code>. The default is <code>layer.shape = 1</code>, <code>layer.dyr = 2</code>, <code>layer.dur = 5</code>, and <code>layer.mag = 3</code>.
</p>
<p>If, for example, <code>INPUT.bands = c(b5.fn, fi.fn, nbr.fn, and ndvi.fn)</code>, then the layers of the output file are:
</p>

<table>
<tr>
 <td style="text-align: left;">
	  </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>1</code> </td><td style="text-align: left;"> Disturbance Agent</td>
</tr>
<tr>
 <td style="text-align: left;">
	  </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>2</code> </td><td style="text-align: left;"> Disturbance Year</td>
</tr>
<tr>
 <td style="text-align: left;">
	  </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>3</code> </td><td style="text-align: left;"> Disturbance Duration</td>
</tr>
<tr>
 <td style="text-align: left;">	
	  </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>4</code> </td><td style="text-align: left;"> Magnitude B5</td>
</tr>
<tr>
 <td style="text-align: left;">
	  </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>5</code> </td><td style="text-align: left;"> Magnitude FI</td>
</tr>
<tr>
 <td style="text-align: left;">
	  </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>6</code> </td><td style="text-align: left;"> Magnitude NBR</td>
</tr>
<tr>
 <td style="text-align: left;">
	  </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>7</code> </td><td style="text-align: left;"> Magnitude NDVI</td>
</tr>

</table>



<h3>Value</h3>

<p>The function does not return a value. Instead, a multi-band <code>.img</code> map file is created.
</p>


<h3>Author(s)</h3>

<p>Liz Freeman
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flat2annual">flat2annual</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
	# define years
	years &lt;- c(1984, 1986:2010)

	# define a folder for all output
	folder.in &lt;- paste(system.file(package = "ShapeSelectForest"), 
	"extdata", "helpexamples", sep = "/")
	folder.out &lt;- getwd()	

	# define filenames
	flat.pred.fn &lt;- "MINI_FLATPRED.img"
	b5.fn &lt;- "MINI_B5.img"
	fi.fn &lt;- "MINI_FI.img"
	nbr.fn &lt;- "MINI_NBR.img"
	ndvi.fn &lt;- "MINI_NDVI.img"
	INPUT.bands &lt;- c(b5.fn, fi.fn, nbr.fn, ndvi.fn)

	# call f2p.raster
	ans &lt;- f2p.raster(years = years, folder.in = folder.in, folder.out = folder.out, 
	OUTPUT.fn = "f2p_example.img", flat.pred.fn = flat.pred.fn, INPUT.bands = INPUT.bands)

## End(Not run)
</code></pre>

<hr>
<h2 id='flat2annual'>
flat2annual
</h2><span id='topic+flat2annual'></span>

<h3>Description</h3>

<p>Identifies the disturbance year of a single pixel or a plot location.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flat2annual(years, all.shapes, all.durs, all.dyrs, mtbs, flat.pred)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="flat2annual_+3A_years">years</code></td>
<td>
<p> Vector of the years included in the time series data.</p>
</td></tr>
<tr><td><code id="flat2annual_+3A_all.shapes">all.shapes</code></td>
<td>
<p> Vector (length 4) of the shapes of the four remote sensing bands. Shape values range from 1 to 7.</p>
</td></tr>
<tr><td><code id="flat2annual_+3A_all.durs">all.durs</code></td>
<td>
<p> Vector (length 4) of the duration of each shape.</p>
</td></tr>
<tr><td><code id="flat2annual_+3A_all.dyrs">all.dyrs</code></td>
<td>
<p> Vector (length 4) of the year of each shape. </p>
</td></tr>
<tr><td><code id="flat2annual_+3A_mtbs">mtbs</code></td>
<td>
<p>MTBS</p>
</td></tr>
<tr><td><code id="flat2annual_+3A_flat.pred">flat.pred</code></td>
<td>
<p> Predicted disturbance Agent. Agent values range from 0 to 6.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>flat2annual</code> can be used on either a single pixel or on a single data point in a data frame.
</p>


<h3>Value</h3>

<p>Returns a vector of the same length as <code>years</code> with a predicted agent for each year in <code>years</code>.
</p>


<h3>Author(s)</h3>

<p>Liz Freeman</p>


<h3>Examples</h3>

<pre><code class='language-R'>	# define years
	years &lt;- c(2001:2010)

	# define parameters
	all.shapes &lt;- c(1, 4, 5, 3)
	all.dyrs &lt;- c(2001, 0, 2004, 2004)
	all.durs &lt;- c(1, 0, 3, 5)
	flat.pred &lt;- 5

	# call flat2annual
	ans &lt;- flat2annual(years = years, all.shapes = all.shapes, all.durs = all.durs,
	all.dyrs = all.dyrs, mtbs = mtbs, flat.pred = flat.pred)
</code></pre>

<hr>
<h2 id='flat2parameter'>flat2parameter</h2><span id='topic+flat2parameter'></span>

<h3>Description</h3>

<p>Based on the disturbance type and the shapes of the four remote sensing bands, a vector of averaged parameters is produced. Which bands are included in the average depends on both the predicted disturbance type and the shapes of the four bands.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flat2parameter(years, all.shapes, all.durs, all.dyrs, all.mags, mtbs, flat.pred)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="flat2parameter_+3A_years">years</code></td>
<td>
<p>Vector of the years included in the time series data.</p>
</td></tr>
<tr><td><code id="flat2parameter_+3A_all.shapes">all.shapes</code></td>
<td>
<p>Vector (length 4) of the shapes of the four remote sensing bands. Shape values range from 1 to 7.</p>
</td></tr>
<tr><td><code id="flat2parameter_+3A_all.durs">all.durs</code></td>
<td>
<p> Vector (length 4) of the duration of each shape.</p>
</td></tr>
<tr><td><code id="flat2parameter_+3A_all.dyrs">all.dyrs</code></td>
<td>
<p> Vector (length 4) of the year of each shape. </p>
</td></tr>
<tr><td><code id="flat2parameter_+3A_all.mags">all.mags</code></td>
<td>
<p> Vector (length 4) of the magnitude of each shape. </p>
</td></tr>
<tr><td><code id="flat2parameter_+3A_mtbs">mtbs</code></td>
<td>
<p>MTBS.</p>
</td></tr>
<tr><td><code id="flat2parameter_+3A_flat.pred">flat.pred</code></td>
<td>
<p> Predicted disturbance Agent. Agent values range from 0 to 6.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>flat2parameter</code> can be used on either a single pixel or on a single data point in a data frame.
</p>


<h3>Value</h3>

<p>Returns a vector of length 4 containing the average disturbance year, the duration, the magnitude, and the predicted type.
</p>


<h3>Author(s)</h3>

<p>Liz Freeman</p>


<h3>Examples</h3>

<pre><code class='language-R'>	# define years
	years &lt;- c(2001:2010)

	# define parameters
	all.shapes &lt;- c(1, 4, 5, 3)
	all.dyrs &lt;- c(2001, 0, 2004, 2004)
	all.durs &lt;- c(1, 0, 3, 5)
	all.mags &lt;- c(100, 0, 1000, 1500)
	flat.pred &lt;- 5

	# call flat2parameter
	ans &lt;- flat2parameter(years = years, all.shapes = all.shapes, all.durs = all.durs,
	all.dyrs = all.dyrs, all.mags = all.mags, mtbs = mtbs, flat.pred = flat.pred)
</code></pre>

<hr>
<h2 id='getedf0'>Get the Edf0 Vector for the Shape Routine</h2><span id='topic+getedf0'></span>

<h3>Description</h3>

<p>An edf0 vector is the estimated &quot;null expected degrees of freedom&quot; for shapes allowed by the user. It is an input of the main routine &quot;shape&quot; and it is used to select the best shape for a scatterplot. See Meyer (2013a) and Meyer (2013b) for further details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getedf0(x, flat = TRUE, dec = TRUE, jp = TRUE, invee = TRUE, 
vee = TRUE, inc = TRUE, db = TRUE, nsim = 1e+3, random = FALSE, msg = FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getedf0_+3A_x">x</code></td>
<td>
<p>A <code class="reqn">n</code> by <code class="reqn">1</code> predictor vector, for example, years.</p>
</td></tr>
<tr><td><code id="getedf0_+3A_flat">flat</code></td>
<td>
<p>A logical flag. If it is TRUE, there is a flat shape choice; otherwise, there is no such a shape option.</p>
</td></tr>
<tr><td><code id="getedf0_+3A_dec">dec</code></td>
<td>
<p>A logical flag. If it is TRUE, there is a decreasing shape choice; otherwise, there is no such a shape option.</p>
</td></tr>
<tr><td><code id="getedf0_+3A_jp">jp</code></td>
<td>
<p>A logical flag. If it is TRUE, there is a one-jump shape choice; otherwise, there is no such a shape option.</p>
</td></tr>
<tr><td><code id="getedf0_+3A_invee">invee</code></td>
<td>
<p>A logical flag. If it is TRUE, there is an inverted-vee shape choice; otherwise, there is no such a shape option.</p>
</td></tr>
<tr><td><code id="getedf0_+3A_vee">vee</code></td>
<td>
<p>A logical flag. If it is TRUE, there is a vee shape choice; otherwise, there is no such a shape option.</p>
</td></tr>
<tr><td><code id="getedf0_+3A_inc">inc</code></td>
<td>
<p>A logical flag. If it is TRUE, there is an increasing shape choice; otherwise, there is no such a shape option.</p>
</td></tr>
<tr><td><code id="getedf0_+3A_db">db</code></td>
<td>
<p>A logical flag. If it is TRUE, there is a double-jump option; otherwise, there is no such a shape option.</p>
</td></tr>
<tr><td><code id="getedf0_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulations used to get the edf0 vector. The default is nsim = 1e+3.</p>
</td></tr>
<tr><td><code id="getedf0_+3A_random">random</code></td>
<td>
<p>A parameter used by the maintainer to test if each shape option can be both included and excluded.</p>
</td></tr>
<tr><td><code id="getedf0_+3A_msg">msg</code></td>
<td>
<p>A logical flag. If msg is TRUE, then a warning message will be printed when there is a non-convergence problem; otherwise no warning message will be printed. The default is msg = FALSE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Because the calculations for the edf0 vector for a given set of <code class="reqn">\bold{x}</code> values (e.g., years) is time-consuming, this is accomplished in the subroutine &quot;getedf0&quot;, and the edf0 vector is an input to the main routine &quot;shape&quot;. In this way the edf0 values can be determined for one set of years and used for many scatterplots. 
</p>


<h3>Value</h3>

<p>The edf0 values for all shape options allowed by the user.
</p>


<h3>Author(s)</h3>

<p>Mary C. Meyer and Xiyue Liao
</p>


<h3>References</h3>

<p>Meyer, M. C. (2013a) Semi-parametric additive constrained regression. 
<em>Journal of Nonparametric Statistics <b>25(3)</b></em>, 715
</p>
<p>Meyer, M. C. (2013b) A simple new algorithm for quadratic programming with applications in statistics. <em>Communications in Statistics <b>42(5)</b></em>, 1126&ndash;1139.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+shape">shape</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
	# define the predictor vector: the year 1985 to the year 2010
	x &lt;- 1985:2010

	# call the getedf0 routine without a double-jump option
	edf0 &lt;- getedf0(x, db = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='plotshape'>The Plot Routine for an Object of the Shape Routine</h2><span id='topic+plotshape'></span>

<h3>Description</h3>

<p>This routine can plot the best shape selected by the shape routine for each scatterplot of Landsat signals. It can also plot the &quot;BIC&quot; or &quot;CIC&quot; values against shapes for each scatterplot, which is a way to verify that the best shape selected has the smallest &quot;BIC&quot; or &quot;CIC&quot; value.</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotshape(object, ids = 1, color = "mediumorchid4", lty = 1, lwd = 1, 
cex = .83, cex.main = .93, form = TRUE, icpic = FALSE, both = TRUE, 
tt = NULL, transpose = FALSE, plot = graphics::plot)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotshape_+3A_object">object</code></td>
<td>
<p>An object of the shape routine.</p>
</td></tr>
<tr><td><code id="plotshape_+3A_ids">ids</code></td>
<td>
<p>An integer vector representing a subset of the columns of ymat in the shape routine. Each column of ymat is a time series of Landsat imagery. Suppose that the dimension of ymat is <code class="reqn">n</code> by <code class="reqn">k</code>, then each element of &quot;ids&quot; should be an integer between <code class="reqn">1</code> and <code class="reqn">k</code>. The default is ids = 1.</p>
</td></tr>
<tr><td><code id="plotshape_+3A_color">color</code></td>
<td>
<p>The col argument inherited from the plot routine. The default is color = &quot;mediumorchid4&quot;.</p>
</td></tr>
<tr><td><code id="plotshape_+3A_lty">lty</code></td>
<td>
<p>The lty argument inherited from the lines routine. The default is lty = 1.</p>
</td></tr>
<tr><td><code id="plotshape_+3A_lwd">lwd</code></td>
<td>
<p>The lwd argument inherited from the lines routine. The default is lwd = 1.</p>
</td></tr>
<tr><td><code id="plotshape_+3A_cex">cex</code></td>
<td>
<p>The cex argument inherited from the plot routine. The default is cex = .83.</p>
</td></tr>
<tr><td><code id="plotshape_+3A_cex.main">cex.main</code></td>
<td>
<p>The cex.main argument inherited from the par routine. The default is cex.main = .93.</p>
</td></tr>
<tr><td><code id="plotshape_+3A_form">form</code></td>
<td>
<p>A logical flag. If it is TRUE, the user will let the plotshape routine to decide the layout of pictures corresponding to the elements in the &quot;ids&quot; vector; otherwise, the user needs to define the layout of pictures before they call the plotshape routine using <b>par(mfrow = ...)</b> or <b>par(mfcol = ...)</b>. The default is form = TRUE.</p>
</td></tr>
<tr><td><code id="plotshape_+3A_icpic">icpic</code></td>
<td>
<p>A logical flag. Given an &quot;ids&quot; vector, if it is TRUE, &quot;BIC&quot; or &quot;CIC&quot; values will be plotted against all shapes allowed by the user and the fitted trajectory will not be plotted; otherwise, the fitted trajectory will also be plotted. The default is icpic = FALSE.</p>
</td></tr>
<tr><td><code id="plotshape_+3A_both">both</code></td>
<td>
<p>A logical flag. If it is TRUE, then for each element of the &quot;ids&quot; vector, both the fitted trajectory and the &quot;BIC&quot; or &quot;CIC&quot; plot will be made; otherwise, the &quot;BIC&quot; or &quot;CIC&quot; values will not be plotted. The default is both = TRUE.</p>
</td></tr>
<tr><td><code id="plotshape_+3A_tt">tt</code></td>
<td>
<p>A vector of titles. The user can define its element as a name of the location for a scatterplot, like &quot;Pixel 420&quot;. The default is tt = NULL.</p>
</td></tr>
<tr><td><code id="plotshape_+3A_transpose">transpose</code></td>
<td>
<p>A logical flag which can be used only when form is TRUE. If form is TRUE, then the user can transpose the layout the plotshape routine uses to arrange the pictures. For example, the user wants to make 2 pictures, and the default layout of this routine is 2 rows and 1 column. By setting transpose equal to TRUE, the layout will be 1 row and 2 columns. The default is transpose = TRUE.</p>
</td></tr>
<tr><td><code id="plotshape_+3A_plot">plot</code></td>
<td>
<p>The genetic plot routine in graphics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot showing the fitted trajectory of the best shape, or showing the &quot;BIC&quot; or &quot;CIC&quot; values against shapes of an object of the shape routine.
</p>


<h3>Author(s)</h3>

<p>Xiyue Liao
</p>


<h3>See Also</h3>

<p><code><a href="#topic+shape">shape</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
	# import the matrix of Landsat signals 
	data("ymat")	

	# define the predictor vector: the year 1985 to the year 2010
	x &lt;- 1985:2010

	# make a fit by the shape routine using "CIC" 
	# and not allow a double jump shape.
	ans &lt;- shape(x, ymat, "CIC", db = FALSE)

	# make a plot for the 1st column of ymat 
	plotshape(ans, ids = 1, both = TRUE, form = TRUE, tt = "Pixel 420")

	# transpose the layout
	plotshape(ans, ids = 1, both = TRUE, form = TRUE, tt = "Pixel 420", transpose = TRUE)

	# make a plot for each of the first 6 columns of ymat 
	# showing the best shape 
	# and "CIC" values against the 7 shapes for each plot.
	par(mfrow = c(3, 2))
	plotshape(ans, ids = 1:6)

	# make a plot for each of the first 6 columns of ymat
	# showing both the best shape
	# and "CIC" values against the 7 shapes for each plot. 		
	# Let the routine make the layout.  
	plotshape(ans, ids = 1:6, form = TRUE, col = 2)

	# plot the ic values only
	plotshape(ans, ids = 1:6, form = TRUE, col = 5, icpic = TRUE)

	# make a title vector
	tts &lt;- paste('Pixel', 1:36, sep = " ")

	# make all plots for the 36 scatterplots with the title vector 
	plotshape(ans, ids = 1:15, both = TRUE, form = TRUE, tt = tts[1:15], cex = .5)
	plotshape(ans, ids = 16:30, both = TRUE, form = TRUE, tt = tts[16:30], lty = 2, cex = .3)
	plotshape(ans, ids = 31:36, both = TRUE, form = TRUE, tt = tts[31:36], lty = 2, cex = .1)

## End(Not run)
</code></pre>

<hr>
<h2 id='shape'>Shape Selection</h2><span id='topic+shape'></span>

<h3>Description</h3>

<p>Given a predictor vector <code class="reqn">\bold{x}</code>, e.g., years, and a matrix <code class="reqn">\bold{ymat}</code> whose columns are response vectors, e.g., Landsat signals. The shape routine will select a shape that is the best fit for each response vector according to the Bayes information criterion (BIC) or the cone information criterion (CIC).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shape(x, ymat, infocrit = "CIC", flat = TRUE, dec = TRUE, jp = TRUE, 
invee = TRUE, vee = TRUE, inc = TRUE, db = TRUE, nsim = 1e+3, 
edf0 = NULL, get.edf0 = FALSE, random = FALSE, msg = FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shape_+3A_x">x</code></td>
<td>
<p>A <code class="reqn">n</code> by <code class="reqn">1</code> predictor vector, for example, years.</p>
</td></tr>
<tr><td><code id="shape_+3A_ymat">ymat</code></td>
<td>
<p>A <code class="reqn">n</code> by <code class="reqn">N</code> matrix whose columns are response vectors corresponding to x, for example, Landsat signals.</p>
</td></tr>
<tr><td><code id="shape_+3A_infocrit">infocrit</code></td>
<td>
<p>The criterion used to select the best shape for a scatterplot. It can either be the Bayes information criterion (BIC) or the cone information criterion (CIC).</p>
</td></tr>
<tr><td><code id="shape_+3A_flat">flat</code></td>
<td>
<p>A logical flag. If it is TRUE, there is a flat shape choice; otherwise, there is no such a shape option.</p>
</td></tr>
<tr><td><code id="shape_+3A_dec">dec</code></td>
<td>
<p>A logical flag. If it is TRUE, there is a decreasing shape choice; otherwise, there is no such a shape option.</p>
</td></tr>
<tr><td><code id="shape_+3A_jp">jp</code></td>
<td>
<p>A logical flag. If it is TRUE, there is a one-jump shape choice; otherwise, there is no such a shape option.</p>
</td></tr>
<tr><td><code id="shape_+3A_invee">invee</code></td>
<td>
<p>A logical flag. If it is TRUE, there is an inverted-vee shape choice; otherwise, there is no such a shape option.</p>
</td></tr>
<tr><td><code id="shape_+3A_vee">vee</code></td>
<td>
<p>A logical flag. If it is TRUE, there is a vee shape choice; otherwise, there is no such a shape option.</p>
</td></tr>
<tr><td><code id="shape_+3A_inc">inc</code></td>
<td>
<p>A logical flag. If it is TRUE, there is an increasing shape choice; otherwise, there is no such a shape option.</p>
</td></tr>
<tr><td><code id="shape_+3A_db">db</code></td>
<td>
<p>A logical flag. If it is TRUE, there is a double-jump shape choice; otherwise, there is no such a shape option. The routine is usually slower when there is a double-jump shape choice than it is when there is no such a choice.</p>
</td></tr>
<tr><td><code id="shape_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulations used to get the edf0 vector. The default is nsim = 1e+3. See references in this section
for more details about edf0.</p>
</td></tr>
<tr><td><code id="shape_+3A_edf0">edf0</code></td>
<td>
<p>The edf0 given by the user. When <code class="reqn">\bold{x}</code> is an equally spaced vector whose number of elements is between <code class="reqn">20</code> and <code class="reqn">40</code>. The user doesn't need to provide an edf0 vector; otherwise, the user has to set get.edf0 to be TRUE such that the shape routine will simulate an edf0 vector, or the user can choose to simulate an edf0 vector by the getedf0 routine and provide the edf0 vector to the shape routine with this argument. The default is edf0 = NULL.</p>
</td></tr>
<tr><td><code id="shape_+3A_get.edf0">get.edf0</code></td>
<td>
<p>A logical flag. When <code class="reqn">\bold{x}</code> is not an equally spaced vector whose number of elements is between <code class="reqn">20</code> and <code class="reqn">40</code>. The user has to set get.edf0 to be TRUE such that the shape routine will simulate an edf0 vector, or the user can choose to simulate an edf0 vector by the &ldquo;getedf0&rdquo; routine and provide the edf0 vector to the shape routine with the edf0 argument. The default is get.edf0 = FALSE.</p>
</td></tr>
<tr><td><code id="shape_+3A_random">random</code></td>
<td>
<p>A parameter used by the maintainer to test if each shape option can be both included and excluded.</p>
</td></tr>
<tr><td><code id="shape_+3A_msg">msg</code></td>
<td>
<p>A logical flag. If msg is TRUE, then a warning message will be printed when there is a non-convergence problem; otherwise no warning message will be printed. The default is msg = FALSE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a scatterplot of <code class="reqn">(x_i, y_i)</code>, <code class="reqn">i=1,\ldots,n</code>, where <code class="reqn">\bold{x}</code> could be a vector of years and <code class="reqn">\bold{y}</code> could be a vector of Landsat signals, constrained least-squares spline fits are obtained for the following shapes:
</p>

<ul>
<li><p>1. flat
</p>
</li>
<li><p>2. decreasing
</p>
</li>
<li><p>3. one-jump, i.e., decreasing, jump up, decreasing
</p>
</li>
<li><p>4. inverted vee (increasing then decreasing)
</p>
</li>
<li><p>5. vee (decreasing then increasing)
</p>
</li>
<li><p>6. linear increasing
</p>
</li>
<li><p>7. double-jump, i.e., decreasing, jump up, decreasing, jump up, decreasing.
</p>
</li></ul>

<p>The &quot;shape&quot; routine chooses one of the shapes allowed by the user based on the minimum Bayes information criterion (BIC) or the cone information criterion (CIC). It also returns the information criterion (IC) values for shapes allowed by the user. Fitting method is constrained quadratic B-splines, number of knots depends on number of observations. The cone projection algorithm used in this routine is implemented by the <b>R</b> package <b>coneproj</b>. 
</p>
<p>See references cited in this section and the official manual (<a href="https://cran.r-project.org/package=coneproj">https://cran.r-project.org/package=coneproj</a>) for the <b>R</b> package <b>coneproj</b> for more details.</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>shape</code></td>
<td>
<p> A <code class="reqn">N</code> by <code class="reqn">1</code> vector. The <code class="reqn">i</code>th element is the best shape for each of the <code class="reqn">i</code>th scatterplot.</p>
</td></tr>
<tr><td><code>ic</code></td>
<td>
<p>A <code class="reqn">k</code> by <code class="reqn">N</code> matrix where the <code class="reqn">i</code>th column is the vector of &quot;BIC&quot; or &quot;CIC&quot; values used to choose the best shape for the <code class="reqn">i</code>th scatterplot. <code class="reqn">k</code> is the number of shapes allowed by the user.</p>
</td></tr>
<tr><td><code>thetab</code></td>
<td>
<p>A <code class="reqn">n</code> by <code class="reqn">N</code> matrix where the <code class="reqn">i</code>th column is the vector of predicted values for the chosen shape for the <code class="reqn">i</code>th scatterplot.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>The argument x.</p>
</td></tr>
<tr><td><code>ymat</code></td>
<td>
<p>The argument ymat.</p>
</td></tr>
<tr><td><code>infocrit</code></td>
<td>
<p>The argument infocrit.</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>The number of knots used.</p>
</td></tr>
<tr><td><code>bs</code></td>
<td>
<p>A list of coefficient vectors. Each vector is the vector of coefficients for regression basis functions for each scatterplot.</p>
</td></tr>
<tr><td><code>ijps</code></td>
<td>
<p>A list storing the position of the first jump for scatterplots whose best shape is one-jump or double-jump. It also stores the position of the knot from where <code class="reqn">\bold{f}</code> starts increasing (decreasing) for scatterplots whose best shape is vee (inverted vee).</p>
</td></tr>
<tr><td><code>jjps</code></td>
<td>
<p>A list storing the position of the second jump for scatterplots whose best shape is double-jump.</p>
</td></tr>
<tr><td><code>m_is</code></td>
<td>
<p>A vector storing the centering values for the first ramp edge for scatterplots whose best shape is one-jump or double-jump.</p>
</td></tr>
<tr><td><code>m_js</code></td>
<td>
<p>A vector storing the centering values for the second ramp edge for scatterplots whose best shape is double-jump.</p>
</td></tr>
<tr><td><code>tm</code></td>
<td>
<p>Total cpu running time.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mary C. Meyer and Xiyue Liao 
</p>


<h3>References</h3>

<p>Meyer, M. C. (2013a) Semi-parametric additive constrained regression. 
<em>Journal of Nonparametric Statistics <b>25(3)</b></em>, 715.
</p>
<p>Meyer, M. C. (2013b) A simple new algorithm for quadratic programming with applications in statistics. <em>Communications in Statistics <b>42(5)</b></em>, 1126&ndash;1139.  
</p>
<p>Liao, X. and M. C. Meyer (2014) coneproj: An R package for the primal or dual cone projections with routines for constrained regression. <em>Journal of Statistical Software <b>61(12)</b></em>, 1&ndash;22.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotshape">plotshape</a></code>, <code><a href="#topic+edf0s">edf0s</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>	# import the matrix of Landsat signals 
	data("ymat")

	# define the predictor vector: the year 1985 to the year 2010	
	x &lt;- 1985:2010
## Not run: 
	# Example 1:	
	# call the shape routine allowing a double jump shape using "BIC"
	ans &lt;- shape(x, ymat, "BIC")
	plotshape(ans, ids = 1:6, both = TRUE, form = TRUE)

## End(Not run)
## Not run: 
	# Example 2:
	# call the shape routine not allowing a double jump shape using "CIC"
	ans &lt;- shape(x, ymat, "CIC", db = FALSE)
	plotshape(ans, ids = 1:6, both = TRUE, form = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='shapeparams'>Shape Parameters</h2><span id='topic+shapeparams'></span>

<h3>Description</h3>

<p>Given the output from the shape function (including the chosen shape, chosen information criteria value ic, vector of fitted values thetab, and corresponding <code class="reqn">\bold{x}</code>, e.g., years), this routine calculates a set of parameters that describe the behavior of the fitted trajectory.</p>


<h3>Usage</h3>

<pre><code class='language-R'>shapeparams(shapenum, ic, thetab, x)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shapeparams_+3A_shapenum">shapenum</code></td>
<td>
<p>A number with the index <code class="reqn">1</code> to <code class="reqn">7</code>.</p>
</td></tr>
<tr><td><code id="shapeparams_+3A_ic">ic</code></td>
<td>
<p>A <code class="reqn">k</code> by <code class="reqn">N</code> matrix where the <code class="reqn">i</code>th column is the vector of &quot;BIC&quot; or &quot;CIC&quot; values used to choose the best shape for the <code class="reqn">i</code>th scatterplot. <code class="reqn">k</code> is the number of shapes allowed by the user.</p>
</td></tr>
<tr><td><code id="shapeparams_+3A_thetab">thetab</code></td>
<td>
<p>A <code class="reqn">n</code> by <code class="reqn">N</code> matrix where the <code class="reqn">i</code>th column is the vector of predicted values for the chosen shape for the <code class="reqn">i</code>th scatterplot.</p>
</td></tr>
<tr><td><code id="shapeparams_+3A_x">x</code></td>
<td>
<p>A <code class="reqn">n</code> by <code class="reqn">1</code> predictor vector, e.g., years.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>shapenum</code></td>
<td>
<p>the shapenum argument</p>
</td></tr> 
<tr><td><code>pre.rate</code></td>
<td>
<p>annual rate of decline prior to the primary change point</p>
</td></tr>
<tr><td><code>pre.rate2</code></td>
<td>
<p>annual rate of decline prior to the secondary change point</p>
</td></tr>
<tr><td><code>dist.yr</code></td>
<td>
<p>year of the primary change points</p>
</td></tr>
<tr><td><code>dist2.yr</code></td>
<td>
<p>year of the secondary change points</p>
</td></tr>
<tr><td><code>dist.mag</code></td>
<td>
<p>difference in predicted values before and after primary change events</p>
</td></tr>
<tr><td><code>dist2.mag</code></td>
<td>
<p>difference in predicted values before and after secondary change events</p>
</td></tr>
<tr><td><code>dist.mag2</code></td>
<td>
<p>difference in predicted values before and after primary change points scaled by starting value</p>
</td></tr>
<tr><td><code>dist2.mag2</code></td>
<td>
<p>difference in predicted values before and after secondary change points scaled by starting value</p>
</td></tr>
<tr><td><code>dist.dur</code></td>
<td>
<p>duration of the change event before resuming a downward turn</p>
</td></tr>
<tr><td><code>dist2.dur</code></td>
<td>
<p>duration of the change event before resuming a downward turn</p>
</td></tr>
<tr><td><code>post.rate</code></td>
<td>
<p>annual rate of decline after the end of the primary change event</p>
</td></tr>
<tr><td><code>post2.rate</code></td>
<td>
<p>annual rate of decline after the end of the secondary change event</p>
</td></tr>
<tr><td><code>my.ic</code></td>
<td>
<p>information criteria value for the chosen shape</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gretchen G. Moisen
</p>


<h3>References</h3>

<p>Moisen, G.G., M. Meyer, T.A. Schroeder, C. Toney, X. Liao, E.A. Freeman, K. Schleeweis. <em>Shape-selection in Landsat time series: A tool for monitoring forest dynamics (In Review).</em> Global Change Biology.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+shape">shape</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
	# import the matrix of Landsat signals 
	data("ymat")
	
	# define the predictor vector: the year 1985 to the year 2010
	x &lt;- 1985:2010
 	
	# call the shape routine allowing a double-jump shape using "CIC"
	ans &lt;- shape(x, ymat, "CIC")

	# Example 1: parameters for a flat shape
	flat_id &lt;- which(ans$shape == 1)
	i &lt;- flat_id[1]
	ans_flat &lt;- shapeparams(ans$shape[i], ans$ic[, i], ans$thetab[, i], x)	

	# Example 2: parameters for a one-jump shape
	jp_id &lt;- which(ans$shape == 3)
	i &lt;- jp_id[1]
	ans_jp &lt;- shapeparams(ans$shape[i], ans$ic[, i], ans$thetab[, i], x)	

	# Example 3: parameters for a double-jump shape
	db_id &lt;- which(ans$shape == 7)
	i &lt;- db_id[1]
	ans_db &lt;- shapeparams(ans$shape[i], ans$ic[, i], ans$thetab[, i], x)		

## End(Not run)
</code></pre>

<hr>
<h2 id='ymat'>Response Variable Matrix 
</h2><span id='topic+ymat'></span>

<h3>Description</h3>

<p>This is a <code class="reqn">26</code> by <code class="reqn">36</code> matrix. Each column is a trajectory of Landsat signals corresponding to <code class="reqn">26</code> consecutive years ranging from <code class="reqn">1985</code> to <code class="reqn">2010</code>. It will be used in some examples of this package. They are trajectories from <code class="reqn">36</code> pixels in South Carolina.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("ymat")</code></pre>


<h3>Format</h3>

<p>A <code class="reqn">26</code> by <code class="reqn">36</code> matrix. 
</p>


<h3>Source</h3>

<p>US Forest Service</p>


<h3>See Also</h3>

<p><code><a href="#topic+shape">shape</a></code>, <code><a href="#topic+plotshape">plotshape</a></code></p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
