<!DOCTYPE html><html><head><title>Help for package rebus.base</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rebus.base}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Anchors'><p>The start or end of a string.</p></a></li>
<li><a href='#as.regex'><p>Convert or test for regex objects</p></a></li>
<li><a href='#Backreferences'><p>Backreferences</p></a></li>
<li><a href='#capture'><p>Capture a token, or not</p></a></li>
<li><a href='#char_class'><p>A range or char_class of characters</p></a></li>
<li><a href='#CharacterClasses'><p>Class Constants</p></a></li>
<li><a href='#ClassGroups'><p>Character classes</p></a></li>
<li><a href='#Concatenation'><p>Combine strings together</p></a></li>
<li><a href='#escape_special'><p>Escape special characters</p></a></li>
<li><a href='#format.regex'><p>Print or format regex objects</p></a></li>
<li><a href='#literal'><p>Treat part of a regular expression literally</p></a></li>
<li><a href='#lookahead'><p>Lookaround</p></a></li>
<li><a href='#modify_mode'><p>Apply mode modifiers</p></a></li>
<li><a href='#or'><p>Alternation</p></a></li>
<li><a href='#recursive'><p>Make the regular expression recursive.</p></a></li>
<li><a href='#regex'><p>Create a regex</p></a></li>
<li><a href='#repeated'><p>Repeat values</p></a></li>
<li><a href='#ReplacementCase'><p>Force the case of replacement values</p></a></li>
<li><a href='#SpecialCharacters'><p>Special characters</p></a></li>
<li><a href='#WordBoundaries'><p>Word boundaries</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Core Functionality for the 'rebus' Package</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0-3</td>
</tr>
<tr>
<td>Date:</td>
<td>2017-04-25</td>
</tr>
<tr>
<td>Author:</td>
<td>Richard Cotton [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Richard Cotton &lt;richierocks@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Build regular expressions piece by piece using human readable code.
    This package contains core functionality, and is primarily intended to be
    used by package developers.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/richierocks/rebus.base">https://github.com/richierocks/rebus.base</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/richierocks/rebus.base/issues">https://github.com/richierocks/rebus.base/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>stringi, testthat</td>
</tr>
<tr>
<td>License:</td>
<td>Unlimited</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>Collate:</td>
<td>'alternation.R' 'regex-methods.R' 'backreferences.R'
'capture.R' 'internal.R' 'grouping-and-repetition.R'
'constants.R' 'class-groups.R' 'concatenation.R'
'compound-constants.R' 'escape_special.R' 'lookaround.R'
'misc.R' 'mode-modifiers.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-04-25 15:22:09 UTC; richierocks</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-04-25 21:45:26 UTC</td>
</tr>
</table>
<hr>
<h2 id='Anchors'>The start or end of a string.</h2><span id='topic+Anchors'></span><span id='topic+START'></span><span id='topic+END'></span><span id='topic+exactly'></span>

<h3>Description</h3>

<p><code>START</code> matches the start of a string.
<code>END</code> matches the end of a string.
<code>exactly</code> makes the regular expression match the whole string, from
start to end.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>START

END

exactly(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Anchors_+3A_x">x</code></td>
<td>
<p>A character vector.</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>regex</code> (inherits from <code>character</code>) of length 1.</p>


<h3>Value</h3>

<p>A character vector representing part or all of a regular expression.
</p>


<h3>Note</h3>

<p>Caret and dollar are used as start/end delimiters, since <code>\A</code> and
<code>\Z</code> are not supported by R's internal PRCE engine or <code>stringi</code>'s
ICU engine.
</p>


<h3>References</h3>

<p><a href="http://www.regular-expressions.info/anchors.html">http://www.regular-expressions.info/anchors.html</a> and
<a href="http://www.rexegg.com/regex-anchors.html">http://www.rexegg.com/regex-anchors.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+whole_word">whole_word</a></code> and <code><a href="#topic+modify_mode">modify_mode</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>START
END

# Usage
x &lt;- c("catfish", "tomcat", "cat")
(rx_start &lt;- START %R% "cat")
(rx_end &lt;- "cat" %R% END)
(rx_exact &lt;- exactly("cat"))
stringi::stri_detect_regex(x, rx_start)
stringi::stri_detect_regex(x, rx_end)
stringi::stri_detect_regex(x, rx_exact)
</code></pre>

<hr>
<h2 id='as.regex'>Convert or test for regex objects</h2><span id='topic+as.regex'></span><span id='topic+is.regex'></span>

<h3>Description</h3>

<p><code>as.regex</code> gives objects the class <code>"regex"</code>. <code>is.regex</code>
tests for objects of class <code>"regex"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.regex(x)

is.regex(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.regex_+3A_x">x</code></td>
<td>
<p>An object to test or convert.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>as.regex</code> returns the inputs object, with class
<code>c("regex", "character")</code>.
<code>is.regex</code> returns <code>TRUE</code> when the input inherits from class
<code>"regex"</code> and <code>FALSE</code> otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.regex("month.abb")
is.regex(x)
</code></pre>

<hr>
<h2 id='Backreferences'>Backreferences</h2><span id='topic+Backreferences'></span><span id='topic+REF1'></span><span id='topic+Backreferences'></span><span id='topic+REF2'></span><span id='topic+Backreferences'></span><span id='topic+REF3'></span><span id='topic+Backreferences'></span><span id='topic+REF4'></span><span id='topic+Backreferences'></span><span id='topic+REF5'></span><span id='topic+Backreferences'></span><span id='topic+REF6'></span><span id='topic+Backreferences'></span><span id='topic+REF7'></span><span id='topic+Backreferences'></span><span id='topic+REF8'></span><span id='topic+Backreferences'></span><span id='topic+REF9'></span><span id='topic+Backreferences'></span><span id='topic+ICU_REF1'></span><span id='topic+Backreferences'></span><span id='topic+ICU_REF2'></span><span id='topic+Backreferences'></span><span id='topic+ICU_REF3'></span><span id='topic+Backreferences'></span><span id='topic+ICU_REF4'></span><span id='topic+Backreferences'></span><span id='topic+ICU_REF5'></span><span id='topic+Backreferences'></span><span id='topic+ICU_REF6'></span><span id='topic+Backreferences'></span><span id='topic+ICU_REF7'></span><span id='topic+Backreferences'></span><span id='topic+ICU_REF8'></span><span id='topic+Backreferences'></span><span id='topic+ICU_REF9'></span>

<h3>Description</h3>

<p>Backreferences for replacement operations.  These are used by replacement
functions such as <code><a href="base.html#topic+sub">sub</a></code> and
<code><a href="stringi.html#topic+stri_replace_first_regex">stri_replace_first_regex</a></code>, and by the <code>stringi</code>
and <code>stringr</code> match functions such as
<code><a href="stringi.html#topic+stri_match_first_regex">stri_match_first_regex</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>REF1

REF2

REF3

REF4

REF5

REF6

REF7

REF8

REF9

ICU_REF1

ICU_REF2

ICU_REF3

ICU_REF4

ICU_REF5

ICU_REF6

ICU_REF7

ICU_REF8

ICU_REF9
</code></pre>


<h3>Format</h3>

<p>An object of class <code>regex</code> (inherits from <code>character</code>) of length 1.</p>


<h3>References</h3>

<p><a href="http://www.regular-expressions.info/backref.html">http://www.regular-expressions.info/backref.html</a> and
<a href="http://www.rexegg.com/regex-capture.html">http://www.rexegg.com/regex-capture.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+capture">capture</a></code>, for creating capture groups that can be
referred to.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For R's PCRE and Perl engines
REF1
REF2
# and so on, up to
REF9

# For stringi/stringr's ICU engine
ICU_REF1
ICU_REF2
# and so on, up to
ICU_REF9

# Usage
sub("a(b)c(d)", REF1 %R% REF2, "abcd")
stringi::stri_replace_first_regex("abcd", "a(b)c(d)", ICU_REF1 %R% ICU_REF2)
</code></pre>

<hr>
<h2 id='capture'>Capture a token, or not</h2><span id='topic+capture'></span><span id='topic+group'></span><span id='topic+token'></span><span id='topic+engroup'></span>

<h3>Description</h3>

<p>Create a token to capture or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>capture(x)

group(x)

token(x)

engroup(x, capture)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="capture_+3A_x">x</code></td>
<td>
<p>A character vector.</p>
</td></tr>
<tr><td><code id="capture_+3A_capture">capture</code></td>
<td>
<p>Logical If <code>TRUE</code>, call <code>capture</code>; if <code>FALSE</code>,
call <code>group</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector representing part or all of a regular expression.
</p>


<h3>References</h3>

<p><a href="http://www.regular-expressions.info/brackets.html">http://www.regular-expressions.info/brackets.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+or">or</a></code> for more examples
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- "foo"
capture(x)
group(x)

# Usage
# capture is good with match functions
(rx_price &lt;- capture(digit(1, Inf) %R% DOT %R% digit(2)))
(rx_quantity &lt;- capture(digit(1, Inf)))
(rx_all &lt;- DOLLAR %R% rx_price %R% " for " %R% rx_quantity)
stringi::stri_match_first_regex("The price was $123.99 for 12.", rx_all)

# group is mostly used with alternation.  See ?or.
(rx_spread &lt;- group("peanut butter" %|% "jam" %|% "marmalade"))
stringi::stri_extract_all_regex(
  "You can have peanut butter, jam, or marmalade on your toast.",
  rx_spread
)
</code></pre>

<hr>
<h2 id='char_class'>A range or char_class of characters</h2><span id='topic+char_class'></span><span id='topic+negated_char_class'></span><span id='topic+negate_and_group'></span>

<h3>Description</h3>

<p>Group characters together in a class to match any of them (<code>char_class</code>)
or none of them (<code>negated_char_class</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>char_class(...)

negated_char_class(...)

negate_and_group(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="char_class_+3A_...">...</code></td>
<td>
<p>Character vectors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector representing part or all of a regular expression.
</p>


<h3>References</h3>

<p><a href="http://www.regular-expressions.info/charclass.html">http://www.regular-expressions.info/charclass.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>char_class(LOWER, "._")
negated_char_class(LOWER, "._")

# Usage
x &lt;- (1:10) ^ 2
(rx_odd &lt;- char_class(1, 3, 5, 7, 9))
(rx_not_odd &lt;- negated_char_class(1, 3, 5, 7, 9))
stringi::stri_detect_regex(x, rx_odd)
stringi::stri_detect_regex(x, rx_not_odd)
</code></pre>

<hr>
<h2 id='CharacterClasses'>Class Constants</h2><span id='topic+CharacterClasses'></span><span id='topic+ALPHA'></span><span id='topic+ALNUM'></span><span id='topic+BLANK'></span><span id='topic+CNTRL'></span><span id='topic+DIGIT'></span><span id='topic+GRAPH'></span><span id='topic+LOWER'></span><span id='topic+PRINT'></span><span id='topic+PUNCT'></span><span id='topic+SPACE'></span><span id='topic+UPPER'></span><span id='topic+HEX_DIGIT'></span><span id='topic+ANY_CHAR'></span><span id='topic+GRAPHEME'></span><span id='topic+NEWLINE'></span><span id='topic+DGT'></span><span id='topic+WRD'></span><span id='topic+SPC'></span><span id='topic+NOT_DGT'></span><span id='topic+NOT_WRD'></span><span id='topic+NOT_SPC'></span><span id='topic+ASCII_DIGIT'></span><span id='topic+ASCII_LOWER'></span><span id='topic+ASCII_UPPER'></span><span id='topic+ASCII_ALPHA'></span><span id='topic+ASCII_ALNUM'></span><span id='topic+UNMATCHABLE'></span>

<h3>Description</h3>

<p>Match a class of values. These are typically used in combination with
<code><a href="#topic+char_class">char_class</a></code> to create new character classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ALPHA

ALNUM

BLANK

CNTRL

DIGIT

GRAPH

LOWER

PRINT

PUNCT

SPACE

UPPER

HEX_DIGIT

ANY_CHAR

GRAPHEME

NEWLINE

DGT

WRD

SPC

NOT_DGT

NOT_WRD

NOT_SPC

ASCII_DIGIT

ASCII_LOWER

ASCII_UPPER

ASCII_ALPHA

ASCII_ALNUM

UNMATCHABLE
</code></pre>


<h3>Format</h3>

<p>An object of class <code>regex</code> (inherits from <code>character</code>) of length 1.</p>


<h3>See Also</h3>

<p><code><a href="#topic+ClassGroups">ClassGroups</a></code> for the functional form,
<code><a href="#topic+SpecialCharacters">SpecialCharacters</a></code> for regex metacharacters,
<code><a href="#topic+Anchors">Anchors</a></code> for constants to match the start/end of a string,
<code><a href="#topic+WordBoundaries">WordBoundaries</a></code> for contants to match the start/end of a word.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># R character classes
ALNUM
ALPHA
BLANK
CNTRL
DIGIT
GRAPH
LOWER
PRINT
PUNCT
SPACE
UPPER
HEX_DIGIT

# Special chars
ANY_CHAR
GRAPHEME
NEWLINE

# Generic classes
DGT
WRD
SPC

# Generic negated classes
NOT_DGT
NOT_WRD
NOT_SPC

# Non-locale-specific classes
ASCII_DIGIT
ASCII_LOWER
ASCII_UPPER
ASCII_ALPHA
ASCII_ALNUM

# An oxymoron
UNMATCHABLE

# Usage
x &lt;- c("a1 A", "a1 a")
rx &lt;- LOWER %R% DIGIT %R% SPACE %R% UPPER
stringi::stri_detect_regex(x, rx)
</code></pre>

<hr>
<h2 id='ClassGroups'>Character classes</h2><span id='topic+ClassGroups'></span><span id='topic+alnum'></span><span id='topic+alpha'></span><span id='topic+blank'></span><span id='topic+cntrl'></span><span id='topic+digit'></span><span id='topic+graph'></span><span id='topic+lower'></span><span id='topic+printable'></span><span id='topic+punct'></span><span id='topic+space'></span><span id='topic+upper'></span><span id='topic+hex_digit'></span><span id='topic+any_char'></span><span id='topic+grapheme'></span><span id='topic+newline'></span><span id='topic+dgt'></span><span id='topic+wrd'></span><span id='topic+spc'></span><span id='topic+not_dgt'></span><span id='topic+not_wrd'></span><span id='topic+not_spc'></span><span id='topic+ascii_digit'></span><span id='topic+ascii_lower'></span><span id='topic+ascii_upper'></span><span id='topic+ascii_alpha'></span><span id='topic+ascii_alnum'></span><span id='topic+char_range'></span>

<h3>Description</h3>

<p>Match character classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alnum(lo, hi, char_class = TRUE)

alpha(lo, hi, char_class = TRUE)

blank(lo, hi, char_class = TRUE)

cntrl(lo, hi, char_class = TRUE)

digit(lo, hi, char_class = TRUE)

graph(lo, hi, char_class = TRUE)

lower(lo, hi, char_class = TRUE)

printable(lo, hi, char_class = TRUE)

punct(lo, hi, char_class = TRUE)

space(lo, hi, char_class = TRUE)

upper(lo, hi, char_class = TRUE)

hex_digit(lo, hi, char_class = TRUE)

any_char(lo, hi)

grapheme(lo, hi)

newline(lo, hi)

dgt(lo, hi, char_class = FALSE)

wrd(lo, hi, char_class = FALSE)

spc(lo, hi, char_class = FALSE)

not_dgt(lo, hi, char_class = FALSE)

not_wrd(lo, hi, char_class = FALSE)

not_spc(lo, hi, char_class = FALSE)

ascii_digit(lo, hi, char_class = TRUE)

ascii_lower(lo, hi, char_class = TRUE)

ascii_upper(lo, hi, char_class = TRUE)

ascii_alpha(lo, hi, char_class = TRUE)

ascii_alnum(lo, hi, char_class = TRUE)

char_range(lo, hi, char_class = lo &lt; hi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ClassGroups_+3A_lo">lo</code></td>
<td>
<p>A non-negative integer. Minimum number of repeats, when grouped.</p>
</td></tr>
<tr><td><code id="ClassGroups_+3A_hi">hi</code></td>
<td>
<p>positive integer. Maximum number of repeats, when grouped.</p>
</td></tr>
<tr><td><code id="ClassGroups_+3A_char_class">char_class</code></td>
<td>
<p>A logical value. Should <code>x</code> be wrapped in a character
class?  If <code>NA</code>, the function guesses whether that's a good idea.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector representing part or all of a regular expression.
</p>


<h3>Note</h3>

<p>R has many built-in locale-dependent character classes, like
<code>[:alnum:]</code> (representing alphanumeric characters, that is lower or
upper case letters or numbers). Some of these behave in unexpected ways
when using the ICU engine (that is, when using <code>stringi</code> or
<code>stringr</code>). See the punctuation example. For these engines, using
Unicode properties (<code><a href="rebus.unicode.html#topic+UnicodeProperty">UnicodeProperty</a></code>) may give
you a more reliable match.
There are also some generic character classes like <code>\w</code> (representing
lower or upper case letters or numbers or underscores). Since version 0.0-3,
these use the default <code>char_class = FALSE</code>, since they already act as
character classes.
Finally, there are ASCII-only ways of specifying letters like <code>a-zA-Z</code>.
Which version you want depends upon how you want to deal with international
characters, and the vagaries of the underlying regular expression engine.
I suggest reading the <code><a href="base.html#topic+regex">regex</a></code> help page and doing lots of
testing.
</p>


<h3>References</h3>

<p><a href="http://www.regular-expressions.info/shorthand.html">http://www.regular-expressions.info/shorthand.html</a> and
<a href="http://www.rexegg.com/regex-quickstart.html#posix">http://www.rexegg.com/regex-quickstart.html#posix</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+regex">regex</a></code>, <code><a href="rebus.unicode.html#topic+Unicode">Unicode</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># R character classes
alnum()
alpha()
blank()
cntrl()
digit()
graph()
lower()
printable()
punct()
space()
upper()
hex_digit()

# Special chars
any_char()
grapheme()
newline()

# Generic classes
dgt()
wrd()
spc()

# Generic negated classes
not_dgt()
not_wrd()
not_spc()

# Non-locale-specific classes
ascii_digit()
ascii_lower()
ascii_upper()

# Don't provide a class wrapper
digit(char_class = FALSE) # same as DIGIT

# Match repeated values
digit(3)
digit(3, 5)
digit(0)
digit(1)
digit(0, 1)

# Ranges of characters
char_range(0, 7) # octal number

# Usage
(rx &lt;- digit(3))
stringi::stri_detect_regex(c("123", "one23"), rx)

# Some classes behave differently under different engines
# In particular PRCE and Perl recognise all these characters
# as punctuation but ICU does not
p &lt;- c(
  "!", "@", "#", "$", "%", "^", "&amp;", "*", "(", ")", "[", "]", "{", "}", ";",
  ":", "'", '"', ",", "&lt;", "&gt;", ".", "/", "?", "\\", "|", "`", "~"
)
icu_matched &lt;- stringi::stri_detect_regex(p, punct())
p[icu_matched]
p[!icu_matched]
pcre_matched &lt;- grepl(punct(), p)
p[pcre_matched]
p[!pcre_matched]

# A grapheme is a character that can be defined by more than one code point
# PCRE does not recognise the concept.
x &lt;- c("Chloe", "Chlo\u00e9", "Chlo\u0065\u0301")
stringi::stri_match_first_regex(x, "Chlo" %R% capture(grapheme()))

# newline() matches three types of line ending: \r, \n, \r\n.
# You can standardize line endings using
stringi::stri_replace_all_regex("foo\nbar\r\nbaz\rquux", NEWLINE, "\n")
</code></pre>

<hr>
<h2 id='Concatenation'>Combine strings together</h2><span id='topic+Concatenation'></span><span id='topic++25c+25'></span><span id='topic++25R+25'></span>

<h3>Description</h3>

<p>Operator equivalent of <code>regex</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %c% y

x %R% y
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Concatenation_+3A_x">x</code></td>
<td>
<p>A character vector.</p>
</td></tr>
<tr><td><code id="Concatenation_+3A_y">y</code></td>
<td>
<p>A character vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector representing part or all of a regular expression.
</p>


<h3>Note</h3>

<p><code>%c%</code> was the original operator for this ('c' for
'concatenate').  This is hard work to type on a QWERTY keyboard
though, so it has been replaced with <code>%R%</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+regex">regex</a></code>, <code><a href="base.html#topic+paste">paste</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Notice the recycling
letters %R% month.abb
</code></pre>

<hr>
<h2 id='escape_special'>Escape special characters</h2><span id='topic+escape_special'></span>

<h3>Description</h3>

<p>Prefix the special characters with a blackslash to make them literal
characters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>escape_special(x, escape_brace = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="escape_special_+3A_x">x</code></td>
<td>
<p>A character vector.</p>
</td></tr>
<tr><td><code id="escape_special_+3A_escape_brace">escape_brace</code></td>
<td>
<p>A logical value indicating if opening braces should be
escaped.  If using R's internal PRCE engine or <code>stringi</code>'s ICU engine,
you want this.  If using the perl engine, you don't.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector, with regex meta-characters escaped.
</p>


<h3>Note</h3>

<p>Special characters inside character classes (except caret, hypen and
closing bracket in certain positions) do not need to be escaped. This
function makes no attempt to parse your regular expression and decide whether
or not the special character is inside a character class or not.  It simply
escapes every value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>escape_special("\\ ^ $ . | ? * + ( ) { } [ ]")
</code></pre>

<hr>
<h2 id='format.regex'>Print or format regex objects</h2><span id='topic+format.regex'></span><span id='topic+print.regex'></span>

<h3>Description</h3>

<p>Prints/formats objects of class <code>regex</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'regex'
format(x, ...)

## S3 method for class 'regex'
print(x, encode_string = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format.regex_+3A_x">x</code></td>
<td>
<p>A regex object.</p>
</td></tr>
<tr><td><code id="format.regex_+3A_...">...</code></td>
<td>
<p>Passed from other format methods.  Currently ignored.</p>
</td></tr>
<tr><td><code id="format.regex_+3A_encode_string">encode_string</code></td>
<td>
<p>If <code>TRUE</code>, the regex is encoded with
<code><a href="base.html#topic+encodeString">encodeString</a></code>. This means that backslashes are doubled,
compared to the default of <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>format.regex</code> returns a character vector. <code>print.regex</code>
is invoked for the side effect of printing the regex object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>group(1:5)
lookahead(1:5)
</code></pre>

<hr>
<h2 id='literal'>Treat part of a regular expression literally</h2><span id='topic+literal'></span>

<h3>Description</h3>

<p>Treats its contents as literal characters. Equivalent to using
<code>fixed = TRUE</code>, but for part of the pattern rather than all of it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>literal(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="literal_+3A_x">x</code></td>
<td>
<p>A character vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector representing part or all of a regular expression.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(rx &lt;- digit(1, 3))
(rx_literal &lt;- literal(rx))

# Usage
stringi::stri_detect_regex("123", rx)
stringi::stri_detect_regex("123", rx_literal)
stringi::stri_detect_regex("[[:digit:]]{1,3}", rx_literal)
</code></pre>

<hr>
<h2 id='lookahead'>Lookaround</h2><span id='topic+lookahead'></span><span id='topic+negative_lookahead'></span><span id='topic+lookbehind'></span><span id='topic+negative_lookbehind'></span>

<h3>Description</h3>

<p>Zero length matching.  That is, the characters are matched when detecting,
but not matching or extrcting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lookahead(x)

negative_lookahead(x)

lookbehind(x)

negative_lookbehind(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lookahead_+3A_x">x</code></td>
<td>
<p>A character vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector representing part or all of a regular expression.
</p>


<h3>Note</h3>

<p>Lookbehind is not supported by R's PRCE engine.  Use R's Perl engine
or <code>stringi</code>/<code>stringr</code>'s ICU engine.
</p>


<h3>References</h3>

<p><a href="http://www.regular-expressions.info/lookaround.html">http://www.regular-expressions.info/lookaround.html</a> and
<a href="http://www.rexegg.com/regex-lookarounds.html">http://www.rexegg.com/regex-lookarounds.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- "foo"
lookahead(x)
negative_lookahead(x)
lookbehind(x)
negative_lookbehind(x)

# Usage
x &lt;- c("mozambique", "qatar", "iraq")
# q followed by a character that isn't u
(rx_neg_class &lt;- "q" %R% negated_char_class("u"))
# q not followed by a u
(rx_neg_lookahead &lt;- "q" %R% negative_lookahead("u"))
stringi::stri_detect_regex(x, rx_neg_class)
stringi::stri_detect_regex(x, rx_neg_lookahead)
stringi::stri_extract_first_regex(x, rx_neg_class)
stringi::stri_extract_first_regex(x, rx_neg_lookahead)

# PRCE engine doesn't support lookbehind
x2 &lt;- c("queen", "vacuum")
(rx_lookbehind &lt;- lookbehind("q")) %R% "u"
stringi::stri_detect_regex(x2, rx_lookbehind)
try(grepl(rx_lookbehind, x2))
grepl(rx_lookbehind, x2, perl = TRUE)
</code></pre>

<hr>
<h2 id='modify_mode'>Apply mode modifiers</h2><span id='topic+modify_mode'></span><span id='topic+case_insensitive'></span><span id='topic+free_spacing'></span><span id='topic+single_line'></span><span id='topic+multi_line'></span><span id='topic+duplicate_group_names'></span><span id='topic+no_backslash_escaping'></span>

<h3>Description</h3>

<p>Applies one or more mode modifiers to the regular expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modify_mode(x, modes = c("i", "x", "s", "m", "J", "X"))

case_insensitive(x)

free_spacing(x)

single_line(x)

multi_line(x)

duplicate_group_names(x)

no_backslash_escaping(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modify_mode_+3A_x">x</code></td>
<td>
<p>A character vector.</p>
</td></tr>
<tr><td><code id="modify_mode_+3A_modes">modes</code></td>
<td>
<p>A character vector of mode modifiers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector representing part or all of a regular expression.
</p>


<h3>References</h3>

<p><a href="http://www.regular-expressions.info/modifiers.html">http://www.regular-expressions.info/modifiers.html</a> and
<a href="http://www.rexegg.com/regex-modifiers.html">http://www.rexegg.com/regex-modifiers.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- "foo"
case_insensitive(x)
free_spacing(x)
single_line(x)
multi_line(x)
duplicate_group_names(x)
no_backslash_escaping(x)
modify_mode(x, c("i", "J", "X"))
</code></pre>

<hr>
<h2 id='or'>Alternation</h2><span id='topic+or'></span><span id='topic++25+7C+25'></span><span id='topic+or1'></span>

<h3>Description</h3>

<p>Match one string or another.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>or(..., capture = FALSE)

x %|% y

or1(x, capture = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="or_+3A_...">...</code></td>
<td>
<p>Character vectors.</p>
</td></tr>
<tr><td><code id="or_+3A_capture">capture</code></td>
<td>
<p>A logical value indicating whether or not the result should be
captured.  See note.</p>
</td></tr>
<tr><td><code id="or_+3A_x">x</code></td>
<td>
<p>A character vector.</p>
</td></tr>
<tr><td><code id="or_+3A_y">y</code></td>
<td>
<p>A character vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector representing part or all of a regular expression.
</p>


<h3>Note</h3>

<p><code>or</code> takes multiple character vector inputs and returns a
character vector of the inputs separated by pipes. <code>%|%</code> is an operator
interface to this function. <code>or1</code> takes a single character vector and
returns a string collapsed by pipes.
</p>
<p>When <code>capture</code> is <code>TRUE</code>, the values are wrapped in a capture
group (see <code><a href="#topic+capture">capture</a></code>).  When <code>capture</code> is <code>FALSE</code> (the
default for <code>or</code> and <code>or1</code>), the values are wrapped in a
non-capture group (see <code><a href="#topic+token">token</a></code>).  When <code>capture</code> is
<code>NA</code>, (the case for <code>%|%</code>) the values are not wrapped in
anything.
</p>


<h3>References</h3>

<p><a href="http://www.regular-expressions.info/alternation.html">http://www.regular-expressions.info/alternation.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+paste">paste</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># or takes an arbitrary number of arguments and groups them without capture
# Notice the recycling of inputs
or(letters, month.abb, "foo")

# or1 takes a single character vector
or1(c(letters, month.abb, "foo")) # Not the same as before!

# Capture the group
or1(letters, capture = TRUE)

# Don't create a group
or1(letters, capture = NA)

# The pipe operator doesn't group
letters %|% month.abb %|% "foo"

# Usage
(rx &lt;- or("dog", "cat", "hippopotamus"))
stringi::stri_detect_regex(c("boondoggle", "caterwaul", "water-horse"), rx)
</code></pre>

<hr>
<h2 id='recursive'>Make the regular expression recursive.</h2><span id='topic+recursive'></span>

<h3>Description</h3>

<p>Makes the regular expression (or part of it) recursive.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recursive(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recursive_+3A_x">x</code></td>
<td>
<p>A character vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector representing part or all of a regular expression.
</p>


<h3>Note</h3>

<p>Recursion is not supported by R's internal PRCE engine or
<code>stringi</code>'s ICU engine.
</p>


<h3>References</h3>

<p><a href="http://www.regular-expressions.info/recurse.html">http://www.regular-expressions.info/recurse.html</a> and
<a href="http://www.rexegg.com/regex-recursion.html">http://www.rexegg.com/regex-recursion.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>recursive("a")

# Recursion isn't supported by R's PRCE engine or
# stringi/stringr's ICU engine
x &lt;- c("ab222z", "ababz", "ab", "abab")
rx &lt;- "ab(?R)?z"
grepl(rx, x, perl = TRUE)
try(grepl(rx, x))
try(stringi::stri_detect_regex(x, rx))
</code></pre>

<hr>
<h2 id='regex'>Create a regex</h2><span id='topic+regex'></span>

<h3>Description</h3>

<p>Creates a regex object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regex(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regex_+3A_...">...</code></td>
<td>
<p>Passed to <code>paste0</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>regex</code>.
</p>


<h3>Note</h3>

<p>This works like <code>paste0</code>, but the returns value has class
<code>c("regex", "character")</code>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+paste0">paste0</a></code>
as.regex(month.abb)
regex(letters[1:5], &quot;?&quot;)
</p>

<hr>
<h2 id='repeated'>Repeat values</h2><span id='topic+repeated'></span><span id='topic+optional'></span><span id='topic+lazy'></span><span id='topic+zero_or_more'></span><span id='topic+one_or_more'></span>

<h3>Description</h3>

<p>Match repeated values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repeated(x, lo, hi, lazy = FALSE, char_class = NA)

optional(x, char_class = NA)

lazy(x)

zero_or_more(x, char_class = NA)

one_or_more(x, char_class = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="repeated_+3A_x">x</code></td>
<td>
<p>A character vector.</p>
</td></tr>
<tr><td><code id="repeated_+3A_lo">lo</code></td>
<td>
<p>A non-negative integer. Minimum number of repeats, when grouped.</p>
</td></tr>
<tr><td><code id="repeated_+3A_hi">hi</code></td>
<td>
<p>positive integer. Maximum number of repeats, when grouped.</p>
</td></tr>
<tr><td><code id="repeated_+3A_lazy">lazy</code></td>
<td>
<p>A logical value.  Should repetition be matched lazily or
greedily?</p>
</td></tr>
<tr><td><code id="repeated_+3A_char_class">char_class</code></td>
<td>
<p>A logical value. Should <code>x</code> be wrapped in a character
class?  If <code>NA</code>, the function guesses whether that's a good idea.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector representing part or all of a regular expression.
</p>


<h3>References</h3>

<p><a href="http://www.regular-expressions.info/repeat.html">http://www.regular-expressions.info/repeat.html</a> and
<a href="http://www.rexegg.com/regex-quantifiers.html">http://www.rexegg.com/regex-quantifiers.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Can match constants or class values
repeated(GRAPH, 2, 5)
repeated(graph(), 2, 5)   # same

# Short cuts for special cases
optional(blank())         # same as repeated(blank(), 0, 1)
zero_or_more(hex_digit()) # same as repeated(hex_digit(), 0, Inf)
one_or_more(printable())  # same as repeated(printable(), 1, Inf)

# 'Lazy' matching (match smallest no. of chars)
repeated(cntrl(), 2, 5, lazy = TRUE)
lazy(one_or_more(cntrl()))

# Overriding character class wrapping
repeated(ANY_CHAR, 2, 5, char_class = FALSE)

# Usage
x &lt;- "1234567890"
stringi::stri_extract_first_regex(x, one_or_more(DIGIT))
stringi::stri_extract_first_regex(x, repeated(DIGIT, lo = 3, hi = 6))
stringi::stri_extract_first_regex(x, lazy(repeated(DIGIT, lo = 3, hi = 6)))

col &lt;- c("color", "colour")
stringi::stri_detect_regex(col, "colo" %R% optional("u") %R% "r")
</code></pre>

<hr>
<h2 id='ReplacementCase'>Force the case of replacement values</h2><span id='topic+ReplacementCase'></span><span id='topic+as_lower'></span><span id='topic+as_upper'></span>

<h3>Description</h3>

<p>Forces replacement values to be upper or lower case. Only supported by Perl
regular expressions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_lower(x)

as_upper(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ReplacementCase_+3A_x">x</code></td>
<td>
<p>A character vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector representing part or all of a regular expression.
</p>


<h3>References</h3>

<p><a href="http://www.regular-expressions.info/replacecase.html">http://www.regular-expressions.info/replacecase.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Convert to title case using Perl regex
x &lt;- "In caSE of DISASTER, PuLl tHe CoRd"
matching_rx &lt;- capture(WRD) %R% capture(wrd(1, Inf))
replacement_rx &lt;- as_upper(REF1) %R% as_lower(REF2)
gsub(matching_rx, replacement_rx, x, perl = TRUE)

# PCRE and ICU do not currently support this operation
# The next lines are intended to return gibberish
gsub(matching_rx, replacement_rx, x)
replacement_rx_icu &lt;- as_upper(ICU_REF1) %R% as_lower(ICU_REF2)
stringi::stri_replace_all_regex(x, matching_rx, replacement_rx_icu)
</code></pre>

<hr>
<h2 id='SpecialCharacters'>Special characters</h2><span id='topic+SpecialCharacters'></span><span id='topic+BACKSLASH'></span><span id='topic+CARET'></span><span id='topic+DOLLAR'></span><span id='topic+DOT'></span><span id='topic+PIPE'></span><span id='topic+QUESTION'></span><span id='topic+STAR'></span><span id='topic+PLUS'></span><span id='topic+OPEN_PAREN'></span><span id='topic+CLOSE_PAREN'></span><span id='topic+OPEN_BRACKET'></span><span id='topic+CLOSE_BRACKET'></span><span id='topic+OPEN_BRACE'></span>

<h3>Description</h3>

<p>Constants to match special characters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BACKSLASH

CARET

DOLLAR

DOT

PIPE

QUESTION

STAR

PLUS

OPEN_PAREN

CLOSE_PAREN

OPEN_BRACKET

CLOSE_BRACKET

OPEN_BRACE
</code></pre>


<h3>Format</h3>

<p>An object of class <code>regex</code> (inherits from <code>character</code>) of length 1.</p>


<h3>References</h3>

<p><a href="http://www.regular-expressions.info/characters.html">http://www.regular-expressions.info/characters.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+escape_special">escape_special</a></code> for the functional form,
<code><a href="#topic+CharacterClasses">CharacterClasses</a></code> for regex metacharacters,
<code><a href="#topic+Anchors">Anchors</a></code> for constants to match the start/end of a string,
<code><a href="#topic+WordBoundaries">WordBoundaries</a></code> for contants to match the start/end of a word.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>BACKSLASH
CARET
DOLLAR
DOT
PIPE
QUESTION
STAR
PLUS
OPEN_PAREN
CLOSE_PAREN
OPEN_BRACKET
CLOSE_BRACKET
OPEN_BRACE

# Usage
x &lt;- "\\^$."
rx &lt;- BACKSLASH %R% CARET %R% DOLLAR %R% DOT
stringi::stri_detect_regex(x, rx)
# No escapes - these chars have special meaning inside regex
stringi::stri_detect_regex(x, x)

# Usually closing brackets can be matched without escaping
stringi::stri_detect_regex("]", "]")
# If you want to match a closing bracket inside a character class
# the closing bracket must be placed first
(rx &lt;- char_class("]a"))
stringi::stri_detect_regex("]", rx)
# ICU and Perl also allows you to place the closing bracket in
# other positions if you escape it
(rx &lt;- char_class("a", CLOSE_BRACKET))
stringi::stri_detect_regex("]", rx)
grepl(rx, "]", perl = TRUE)
# PCRE does not allow this
grepl(rx, "]")
</code></pre>

<hr>
<h2 id='WordBoundaries'>Word boundaries</h2><span id='topic+WordBoundaries'></span><span id='topic+BOUNDARY'></span><span id='topic+NOT_BOUNDARY'></span><span id='topic+whole_word'></span>

<h3>Description</h3>

<p><code>BOUNDARY</code> matches a word boundary.
<code>whole_word</code> wraps a regex in word boundary tokens to match a whole
word.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BOUNDARY

NOT_BOUNDARY

whole_word(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WordBoundaries_+3A_x">x</code></td>
<td>
<p>A character vector.</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>regex</code> (inherits from <code>character</code>) of length 1.</p>


<h3>Value</h3>

<p>A character vector representing part or all of a regular expression.
</p>


<h3>References</h3>

<p><a href="http://www.regular-expressions.info/wordboundaries.html">http://www.regular-expressions.info/wordboundaries.html</a> and
<a href="http://www.rexegg.com/regex-boundaries.html">http://www.rexegg.com/regex-boundaries.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ALPHA">ALPHA</a></code>, <code><a href="#topic+BACKSLASH">BACKSLASH</a></code>, <code><a href="#topic+START">START</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>BOUNDARY
NOT_BOUNDARY

# Usage
x &lt;- c("the catfish miaowed", "the tomcat miaowed", "the cat miaowed")
(rx_before &lt;- BOUNDARY %R% "cat")
(rx_after &lt;- "cat" %R% BOUNDARY)
(rx_whole_word &lt;- whole_word("cat"))
stringi::stri_detect_regex(x, rx_before)
stringi::stri_detect_regex(x, rx_after)
stringi::stri_detect_regex(x, rx_whole_word)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
