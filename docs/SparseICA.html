<!DOCTYPE html><html lang="en"><head><title>Help for package SparseICA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SparseICA}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BIC_sparseICA'><p>BIC-like Criterion for Tuning Parameter Selection in Sparse ICA</p></a></li>
<li><a href='#create_group_list'><p>Create a List of fMRI Files for Group ICA Analysis</p></a></li>
<li><a href='#est.M.ols'><p>Estimate mixing matrix from estimates of components</p></a></li>
<li><a href='#example_sim123'><p>Example sim123 Dataset</p></a></li>
<li><a href='#gen_groupPC'><p>Generate Group-Level Principal Components (PCs) for fMRI Data</p></a></li>
<li><a href='#gen.inits'><p>Function for generating random starting points</p></a></li>
<li><a href='#givens.rotation'><p>For a given angle theta, returns a d x d Givens rotation matrix</p></a></li>
<li><a href='#group_sparseICA'><p>Perform Group Sparse Independent Component Analysis (Sparse ICA)</p></a></li>
<li><a href='#matchICA'><p>Match ICA results based on L2 distances and Hungarian</p></a></li>
<li><a href='#relax_and_split_ICA'><p>Relax-and-split ICA Function for Sparse ICA wrapper</p></a></li>
<li><a href='#signchange'><p>Change the sign of S and M matrices to positive skewness.</p></a></li>
<li><a href='#soft_thresh_R'><p>Soft-threshold function</p></a></li>
<li><a href='#sparseICA'><p>Sparse Independent Component Analysis (Sparse ICA) Function</p></a></li>
<li><a href='#theta2W'><p>Convert angle vector into orthodox matrix</p></a></li>
<li><a href='#whitener'><p>The function for perform whitening.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Sparse Independent Component Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-01-15</td>
</tr>
<tr>
<td>Author:</td>
<td>Zihang Wang <a href="https://orcid.org/0000-0001-9032-5412"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Irina Gaynanova <a href="https://orcid.org/0000-0002-4116-0268"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Aleksandr Aravkin <a href="https://orcid.org/0000-0002-1875-1801"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Benjamin Risk <a href="https://orcid.org/0000-0003-1090-0777"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Zihang Wang &lt;zhwang0378@gmail.com&gt;</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/thebrisklab/SparseICA/issues">https://github.com/thebrisklab/SparseICA/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/thebrisklab/SparseICA">https://github.com/thebrisklab/SparseICA</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Provides an implementation of the Sparse ICA method in Wang et al. (2024) &lt;<a href="https://doi.org/10.1080%2F01621459.2024.2370593">doi:10.1080/01621459.2024.2370593</a>&gt; for estimating sparse independent source components of cortical surface functional MRI data, by addressing a non-smooth, non-convex optimization problem through the relax-and-split framework. This method effectively balances statistical independence and sparsity while maintaining computational efficiency.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.13), MASS (&ge; 7.3-58), irlba (&ge; 2.3.5), clue (&ge;
0.3), ciftiTools (&ge; 0.16), parallel (&ge; 4.1)</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-26 19:35:28 UTC; zihang</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-29 18:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='BIC_sparseICA'>BIC-like Criterion for Tuning Parameter Selection in Sparse ICA</h2><span id='topic+BIC_sparseICA'></span>

<h3>Description</h3>

<p>This function uses a BIC-like criterion to select the optimal tuning parameter <code>nu</code> for Sparse ICA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BIC_sparseICA(
  xData,
  n.comp,
  nu_list = seq(0.1, 4, 0.1),
  whiten = c("eigenvec", "sqrtprec", "none"),
  lngca = FALSE,
  orth.method = c("svd", "givens"),
  method = c("C", "R"),
  use_irlba = TRUE,
  eps = 1e-06,
  maxit = 500,
  verbose = FALSE,
  col.stand = TRUE,
  row.stand = FALSE,
  iter.stand = 0,
  BIC_plot = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BIC_sparseICA_+3A_xdata">xData</code></td>
<td>
<p>A numeric matrix of input data with dimensions P x T, where P is the number of features and T is the number of samples.</p>
</td></tr>
<tr><td><code id="BIC_sparseICA_+3A_n.comp">n.comp</code></td>
<td>
<p>An integer specifying the number of components to estimate.</p>
</td></tr>
<tr><td><code id="BIC_sparseICA_+3A_nu_list">nu_list</code></td>
<td>
<p>A numeric vector specifying the list of candidate tuning parameters. Default is <code>seq(0.1, 4, 0.1)</code>.</p>
</td></tr>
<tr><td><code id="BIC_sparseICA_+3A_whiten">whiten</code></td>
<td>
<p>A character string specifying the method for whitening the input <code>xData</code>. Options are <code>"eigenvec"</code>, <code>"sqrtprec"</code>, or <code>"none"</code>. Default is <code>"eigenvec"</code>.</p>
</td></tr>
<tr><td><code id="BIC_sparseICA_+3A_lngca">lngca</code></td>
<td>
<p>A logical value indicating whether to perform Linear Non-Gaussian Component Analysis (LNGCA). Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="BIC_sparseICA_+3A_orth.method">orth.method</code></td>
<td>
<p>A character string specifying the method for generating initial values of the U matrix. Default is <code>"svd"</code>.</p>
</td></tr>
<tr><td><code id="BIC_sparseICA_+3A_method">method</code></td>
<td>
<p>A character string specifying the computation method. If <code>"C"</code> (default), C code is used for Sparse ICA to improve performance. If <code>"R"</code>, computations are performed entirely in R.</p>
</td></tr>
<tr><td><code id="BIC_sparseICA_+3A_use_irlba">use_irlba</code></td>
<td>
<p>A logical value indicating whether to use the <code>irlba</code> method for fast truncated Singular Value Decomposition (SVD) during whitening. This can improve memory efficiency for intermediate datasets. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="BIC_sparseICA_+3A_eps">eps</code></td>
<td>
<p>A numeric value specifying the convergence threshold. Default is <code>1e-6</code>.</p>
</td></tr>
<tr><td><code id="BIC_sparseICA_+3A_maxit">maxit</code></td>
<td>
<p>An integer specifying the maximum number of iterations for the Sparse ICA method using Laplace density. Default is 500.</p>
</td></tr>
<tr><td><code id="BIC_sparseICA_+3A_verbose">verbose</code></td>
<td>
<p>A logical value indicating whether to print convergence information during execution. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="BIC_sparseICA_+3A_col.stand">col.stand</code></td>
<td>
<p>A logical value indicating whether to standardize columns. For each column, the mean of the entries in the column equals 0, and the variance of the entries in the column equals 1. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="BIC_sparseICA_+3A_row.stand">row.stand</code></td>
<td>
<p>A logical value indicating whether to standardize rows. For each row, the mean of the entries in the row equals 0, and the variance of the entries in the row equals 1. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="BIC_sparseICA_+3A_iter.stand">iter.stand</code></td>
<td>
<p>An integer specifying the number of iterations for achieving both row and column standardization when <code>col.stand = TRUE</code> and <code>row.stand = TRUE</code>. Default is 5.</p>
</td></tr>
<tr><td><code id="BIC_sparseICA_+3A_bic_plot">BIC_plot</code></td>
<td>
<p>A logical value indicating whether to generate a plot showing the trace of BIC values for different <code>nu</code> candidates. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following elements:
</p>

<dl>
<dt><code>BIC</code></dt><dd><p>A numeric vector of BIC values corresponding to each candidate <code>nu</code> in <code>nu_list</code>.</p>
</dd>
<dt><code>nu_list</code></dt><dd><p>A numeric vector of candidate tuning parameter values.</p>
</dd>
<dt><code>best_nu</code></dt><dd><p>The optimal <code>nu</code> selected based on the BIC-like criterion.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
#get simulated data
data(example_sim123)

select_sparseICA = BIC_sparseICA(xData = example_sim123$xmat, n.comp = 3, 
      method="C", BIC_plot = TRUE,verbose = TRUE, nu_list = seq(0.1,4,0.1))

(my_nu = select_sparseICA$best_nu)


</code></pre>

<hr>
<h2 id='create_group_list'>Create a List of fMRI Files for Group ICA Analysis</h2><span id='topic+create_group_list'></span>

<h3>Description</h3>

<p>This function scans a BIDS-formatted directory for subject-specific fMRI files that match a specified pattern 
and returns a list of these files for use in group ICA analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_group_list(bids_path, pattern = "task-rest.*\\.dtseries\\.nii$")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_group_list_+3A_bids_path">bids_path</code></td>
<td>
<p>A character string specifying the path to the root directory of the BIDS-formatted dataset. This directory should contain subject folders (e.g., <code>sub-*</code>).</p>
</td></tr>
<tr><td><code id="create_group_list_+3A_pattern">pattern</code></td>
<td>
<p>A character string specifying the pattern to match fMRI files. The default is <code>"task-rest.*\.dtseries\.nii$"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list where each element corresponds to a subject directory and contains a vector of matched fMRI file paths. The names of the list are the subject IDs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example usage:
# Assuming `bids_dir` is the path to a BIDS dataset:
# group_list &lt;- create_group_list(bids_path = bids_dir, pattern = "task-rest.*\.dtseries\.nii$")
# Print the structure of the list:
# str(group_list)

</code></pre>

<hr>
<h2 id='est.M.ols'>Estimate mixing matrix from estimates of components</h2><span id='topic+est.M.ols'></span>

<h3>Description</h3>

<p>Estimate mixing matrix from estimates of components
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est.M.ols(sData, xData, intercept = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="est.M.ols_+3A_sdata">sData</code></td>
<td>
<p>S Dimension: P x Q</p>
</td></tr>
<tr><td><code id="est.M.ols_+3A_xdata">xData</code></td>
<td>
<p>X Dimension: P x T</p>
</td></tr>
<tr><td><code id="est.M.ols_+3A_intercept">intercept</code></td>
<td>
<p>default = TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a mixing matrix M, dimension Q x T.
</p>

<hr>
<h2 id='example_sim123'>Example sim123 Dataset</h2><span id='topic+example_sim123'></span>

<h3>Description</h3>

<p>A simple dataset for demonstration purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example_sim123
</code></pre>


<h3>Format</h3>

<p>A list containing 3 data frames:
</p>

<dl>
<dt>smat</dt><dd><p>A 1089 x 3 numeric matrix of the true source signals. Each column is an 33 x 33 image.</p>
</dd>
<dt>mmat</dt><dd><p>A 3 x 50 numeric mixing matrix of the true time series. Each row is a time series of corresponding column in <code>smat</code>.</p>
</dd>
<dt>xmat</dt><dd><p>A 1089 x 50 numeric matrix of the simulated data. Each column is the simulated mixed signal at a time point.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(example_sim123)
str(example_sim123)
</code></pre>

<hr>
<h2 id='gen_groupPC'>Generate Group-Level Principal Components (PCs) for fMRI Data</h2><span id='topic+gen_groupPC'></span>

<h3>Description</h3>

<p>This function computes subject-level principal components (PCs) from fMRI data and performs a group-level PCA for dimension reduction, designed for cortical surface fMRI data in BIDS format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_groupPC(
  bids_path,
  subj_list,
  n.comp = 30,
  ncore = 1,
  npc = 85,
  iter_std = 5,
  brainstructures = c("left", "right"),
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gen_groupPC_+3A_bids_path">bids_path</code></td>
<td>
<p>A character string specifying the root directory of the BIDS-formatted dataset.</p>
</td></tr>
<tr><td><code id="gen_groupPC_+3A_subj_list">subj_list</code></td>
<td>
<p>A named list generated from <code>create_group_list</code> containing fMRI file paths for each subject.</p>
</td></tr>
<tr><td><code id="gen_groupPC_+3A_n.comp">n.comp</code></td>
<td>
<p>An integer specifying the number of components to retain during group-level PCA. Default is 30.</p>
</td></tr>
<tr><td><code id="gen_groupPC_+3A_ncore">ncore</code></td>
<td>
<p>An integer specifying the number of cores to use for parallel processing. Default is 1.</p>
</td></tr>
<tr><td><code id="gen_groupPC_+3A_npc">npc</code></td>
<td>
<p>An integer specifying the number of components to retain during subject-level PCA. Default is 85.</p>
</td></tr>
<tr><td><code id="gen_groupPC_+3A_iter_std">iter_std</code></td>
<td>
<p>An integer specifying the number of iterative standardization steps to apply to fMRI data. Default is 5.</p>
</td></tr>
<tr><td><code id="gen_groupPC_+3A_brainstructures">brainstructures</code></td>
<td>
<p>A character vector specifying the brain structures to include in the analysis. Options are <code>"left"</code> (left cortex), <code>"right"</code> (right cortex), and/or <code>"subcortical"</code> (subcortex and cerebellum). Can also be <code>"all"</code> (obtain all three brain structures). Default is <code>c("left", "right")</code>.</p>
</td></tr>
<tr><td><code id="gen_groupPC_+3A_verbose">verbose</code></td>
<td>
<p>A logical value indicating whether to print convergence information during execution. Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NOTE: This function requires the <code>ciftiTools</code> package to be installed, and set up the path to the Connectome Workbench folder by <code>ciftiTools.setOption()</code>. See the package <code>ciftiTools</code> documentation for more information.
</p>


<h3>Value</h3>

<p>A numeric matrix containing the group-level principal components, with dimensions determined by the number of retained components (<code>n.comp</code>) and the concatenated data across all subjects.
</p>

<hr>
<h2 id='gen.inits'>Function for generating random starting points</h2><span id='topic+gen.inits'></span>

<h3>Description</h3>

<p>Function for generating random starting points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.inits(p, d, runs, orth.method = c("svd", "givens"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gen.inits_+3A_p">p</code></td>
<td>
<p>The number of rows.</p>
</td></tr>
<tr><td><code id="gen.inits_+3A_d">d</code></td>
<td>
<p>The number of columns.</p>
</td></tr>
<tr><td><code id="gen.inits_+3A_runs">runs</code></td>
<td>
<p>The number of random starts.</p>
</td></tr>
<tr><td><code id="gen.inits_+3A_orth.method">orth.method</code></td>
<td>
<p>The method used for generating initial values of U matrix. The default is &quot;svd&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of random initialization of matrices.
</p>

<hr>
<h2 id='givens.rotation'>For a given angle theta, returns a d x d Givens rotation matrix</h2><span id='topic+givens.rotation'></span>

<h3>Description</h3>

<p>For a given angle theta, returns a d x d Givens rotation matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>givens.rotation(theta = 0, d = 2, which = c(1, 2))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="givens.rotation_+3A_theta">theta</code></td>
<td>
<p>The value of theta.</p>
</td></tr>
<tr><td><code id="givens.rotation_+3A_d">d</code></td>
<td>
<p>The value of d.</p>
</td></tr>
<tr><td><code id="givens.rotation_+3A_which">which</code></td>
<td>
<p>The value of which.</p>
</td></tr>
</table>

<hr>
<h2 id='group_sparseICA'>Perform Group Sparse Independent Component Analysis (Sparse ICA)</h2><span id='topic+group_sparseICA'></span>

<h3>Description</h3>

<p>This function performs Sparse ICA on group-level fMRI data. It processes BIDS-formatted fMRI datasets, performs PCA to reduce dimensionality, selects a tuning parameter <code>nu</code> (optionally using a BIC-like criterion), and executes Sparse ICA to estimate independent components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_sparseICA(
  bids_path,
  subj_list = NULL,
  nu = "BIC",
  n.comp = 30,
  method = "C",
  ncore = 1,
  npc = 85,
  iter_std = 5,
  brainstructures = c("left", "right"),
  restarts = 40,
  positive_skewness = TRUE,
  use_irlba = TRUE,
  eps = 1e-06,
  maxit = 500,
  BIC_plot = TRUE,
  nu_list = seq(0.1, 4, 0.05),
  verbose = TRUE,
  BIC_verbose = FALSE,
  converge_plot = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="group_sparseICA_+3A_bids_path">bids_path</code></td>
<td>
<p>A character string specifying the root directory of the BIDS-formatted dataset.</p>
</td></tr>
<tr><td><code id="group_sparseICA_+3A_subj_list">subj_list</code></td>
<td>
<p>A named list where each element corresponds to a subject and contains vectors of fMRI file names. If <code>NULL</code>, the subject list is generated automatically using <code><a href="#topic+create_group_list">create_group_list</a></code>. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="group_sparseICA_+3A_nu">nu</code></td>
<td>
<p>A numeric value for the tuning parameter, or <code>"BIC"</code> to select <code>nu</code> using a BIC-like criterion. Default is <code>"BIC"</code>.</p>
</td></tr>
<tr><td><code id="group_sparseICA_+3A_n.comp">n.comp</code></td>
<td>
<p>An integer specifying the number of components to estimate. Default is 30.</p>
</td></tr>
<tr><td><code id="group_sparseICA_+3A_method">method</code></td>
<td>
<p>A character string specifying the computation method for Sparse ICA. Options are <code>"C"</code> (default) for C-based computation or <code>"R"</code> for R-based computation.</p>
</td></tr>
<tr><td><code id="group_sparseICA_+3A_ncore">ncore</code></td>
<td>
<p>An integer specifying the number of cores to use for parallel processing. Default is 1.</p>
</td></tr>
<tr><td><code id="group_sparseICA_+3A_npc">npc</code></td>
<td>
<p>An integer specifying the number of components to retain during subject-level PCA. Default is 85.</p>
</td></tr>
<tr><td><code id="group_sparseICA_+3A_iter_std">iter_std</code></td>
<td>
<p>An integer specifying the number of iterative standardization steps to apply to fMRI data. Default is 5.</p>
</td></tr>
<tr><td><code id="group_sparseICA_+3A_brainstructures">brainstructures</code></td>
<td>
<p>A character vector specifying the brain structures to include in the analysis. Options are <code>"left"</code> (left cortex), <code>"right"</code> (right cortex), and/or <code>"subcortical"</code> (subcortex and cerebellum). Can also be <code>"all"</code> (obtain all three brain structures). Default is <code>c("left", "right")</code>.</p>
</td></tr>
<tr><td><code id="group_sparseICA_+3A_restarts">restarts</code></td>
<td>
<p>An integer specifying the number of random initializations for Sparse ICA. Default is 40.</p>
</td></tr>
<tr><td><code id="group_sparseICA_+3A_positive_skewness">positive_skewness</code></td>
<td>
<p>A logical value indicating whether to enforce positive skewness on the estimated components. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="group_sparseICA_+3A_use_irlba">use_irlba</code></td>
<td>
<p>A logical value indicating whether to use the <code>irlba</code> method for fast truncated Singular Value Decomposition (SVD) during whitening. This can improve memory efficiency for intermediate datasets. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="group_sparseICA_+3A_eps">eps</code></td>
<td>
<p>A numeric value specifying the convergence threshold. Default is <code>1e-6</code>.</p>
</td></tr>
<tr><td><code id="group_sparseICA_+3A_maxit">maxit</code></td>
<td>
<p>An integer specifying the maximum number of iterations for Sparse ICA. Default is 500.</p>
</td></tr>
<tr><td><code id="group_sparseICA_+3A_bic_plot">BIC_plot</code></td>
<td>
<p>A logical value indicating whether to generate a plot of BIC values for different <code>nu</code> candidates when selecting <code>nu</code>. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="group_sparseICA_+3A_nu_list">nu_list</code></td>
<td>
<p>A numeric vector specifying candidate values for <code>nu</code> when selecting it using a BIC-like criterion. Default is <code>seq(0.1, 4, 0.05)</code>.</p>
</td></tr>
<tr><td><code id="group_sparseICA_+3A_verbose">verbose</code></td>
<td>
<p>A logical value indicating whether to print progress messages. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="group_sparseICA_+3A_bic_verbose">BIC_verbose</code></td>
<td>
<p>A logical value indicating whether to print detailed messages during the BIC-based selection of <code>nu</code>. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="group_sparseICA_+3A_converge_plot">converge_plot</code></td>
<td>
<p>A logical value indicating whether to generate a plot showing the convergence trace during Sparse ICA. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function operates in four main steps:
</p>

<ol>
<li><p> If <code>subj_list</code> is not provided, it creates a list of subject-specific fMRI files using <code><a href="#topic+create_group_list">create_group_list</a></code>.
</p>
</li>
<li><p> Performs subject-level PCA using <code><a href="#topic+gen_groupPC">gen_groupPC</a></code> to reduce data dimensionality.
</p>
</li>
<li><p> Selects the tuning parameter <code>nu</code> using a BIC-like criterion (if <code>nu = "BIC"</code>) or uses the provided <code>nu</code>.
</p>
</li>
<li><p> Executes Sparse ICA on the group-level PCs to estimate independent components.
</p>
</li></ol>



<h3>Value</h3>

<p>A list containing the results of the group Sparse ICA analysis, including:
</p>

<dl>
<dt><code>loglik</code></dt><dd><p>The minimal log-likelihood value among the random initializations.</p>
</dd>
<dt><code>estS</code></dt><dd><p>A numeric matrix of estimated sparse independent components with dimensions P x Q.</p>
</dd>
<dt><code>estU</code></dt><dd><p>The estimated U matrix with dimensions Q x Q.</p>
</dd>
<dt><code>whitener</code></dt><dd><p>The whitener matrix used for data whitening.</p>
</dd>
<dt><code>converge</code></dt><dd><p>The trace of convergence for the U matrix.</p>
</dd>
<dt><code>best_nu</code></dt><dd><p>The selected <code>nu</code> value (if <code>nu = "BIC"</code>).</p>
</dd>
<dt><code>BIC</code></dt><dd><p>A numeric vector of BIC values for each <code>nu</code> candidate (if <code>nu = "BIC"</code>).</p>
</dd>
<dt><code>nu_list</code></dt><dd><p>The list of <code>nu</code> candidates used in the BIC-based selection (if <code>nu = "BIC"</code>).</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+create_group_list">create_group_list</a></code>, <code><a href="#topic+gen_groupPC">gen_groupPC</a></code>, <code><a href="#topic+BIC_sparseICA">BIC_sparseICA</a></code>, <code><a href="#topic+sparseICA">sparseICA</a></code>
</p>

<hr>
<h2 id='matchICA'>Match ICA results based on L2 distances and Hungarian</h2><span id='topic+matchICA'></span>

<h3>Description</h3>

<p>Match ICA results based on L2 distances and Hungarian
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matchICA(S, template, M = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="matchICA_+3A_s">S</code></td>
<td>
<p>loading variable matrix</p>
</td></tr>
<tr><td><code id="matchICA_+3A_template">template</code></td>
<td>
<p>template for match</p>
</td></tr>
<tr><td><code id="matchICA_+3A_m">M</code></td>
<td>
<p>subject score matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the match result
</p>

<hr>
<h2 id='relax_and_split_ICA'>Relax-and-split ICA Function for Sparse ICA wrapper</h2><span id='topic+relax_and_split_ICA'></span>

<h3>Description</h3>

<p>This function performs Sparse Independent Component Analysis (Sparse ICA), implemented in both pure R and RCpp for efficiency.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relax_and_split_ICA(
  xData,
  n.comp,
  nu = 1,
  U.list = NULL,
  whiten = c("eigenvec", "sqrtprec", "none"),
  lngca = FALSE,
  orth.method = c("svd", "givens"),
  method = c("C", "R"),
  restarts = 40,
  use_irlba = TRUE,
  eps = 1e-06,
  maxit = 500,
  verbose = FALSE,
  converge_plot = FALSE,
  col.stand = TRUE,
  row.stand = FALSE,
  iter.stand = 5,
  positive_skewness = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="relax_and_split_ICA_+3A_xdata">xData</code></td>
<td>
<p>A numeric matrix of input data with dimensions P x T, where P is the number of features and T is the number of samples.</p>
</td></tr>
<tr><td><code id="relax_and_split_ICA_+3A_n.comp">n.comp</code></td>
<td>
<p>An integer specifying the number of components to estimate.</p>
</td></tr>
<tr><td><code id="relax_and_split_ICA_+3A_nu">nu</code></td>
<td>
<p>A numeric tuning parameter controlling the balance between accuracy and sparsity of the results. It can be selected using a BIC-like criterion or based on expert knowledge. Default is 1.</p>
</td></tr>
<tr><td><code id="relax_and_split_ICA_+3A_u.list">U.list</code></td>
<td>
<p>An optional matrix specifying the initialization of the U matrix. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="relax_and_split_ICA_+3A_whiten">whiten</code></td>
<td>
<p>A character string specifying the method for whitening the input <code>xData</code>. Options are <code>"eigenvec"</code>, <code>"sqrtprec"</code>, <code>"lngca"</code>, or <code>"none"</code>. Default is <code>"eigenvec"</code>.</p>
</td></tr>
<tr><td><code id="relax_and_split_ICA_+3A_lngca">lngca</code></td>
<td>
<p>A logical value indicating whether to perform Linear Non-Gaussian Component Analysis (LNGCA). Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="relax_and_split_ICA_+3A_orth.method">orth.method</code></td>
<td>
<p>A character string specifying the method used for generating initial values for the U matrix. Default is <code>"svd"</code>.</p>
</td></tr>
<tr><td><code id="relax_and_split_ICA_+3A_method">method</code></td>
<td>
<p>A character string specifying the computation method. If <code>"C"</code> (default), C code is used for most computations for better performance. If <code>"R"</code>, computations are performed entirely in R.</p>
</td></tr>
<tr><td><code id="relax_and_split_ICA_+3A_restarts">restarts</code></td>
<td>
<p>An integer specifying the number of random initializations for optimization. Default is 40.</p>
</td></tr>
<tr><td><code id="relax_and_split_ICA_+3A_use_irlba">use_irlba</code></td>
<td>
<p>A logical value indicating whether to use the <code>irlba</code> method for fast truncated Singular Value Decomposition (SVD) during whitening. This can improve memory efficiency for intermediate datasets. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="relax_and_split_ICA_+3A_eps">eps</code></td>
<td>
<p>A numeric value specifying the convergence threshold. Default is <code>1e-6</code>.</p>
</td></tr>
<tr><td><code id="relax_and_split_ICA_+3A_maxit">maxit</code></td>
<td>
<p>An integer specifying the maximum number of iterations for the Sparse ICA method using Laplace density. Default is 500.</p>
</td></tr>
<tr><td><code id="relax_and_split_ICA_+3A_verbose">verbose</code></td>
<td>
<p>A logical value indicating whether to print convergence information during execution. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="relax_and_split_ICA_+3A_converge_plot">converge_plot</code></td>
<td>
<p>A logical value indicating whether to generate a line plot showing the convergence trace. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="relax_and_split_ICA_+3A_col.stand">col.stand</code></td>
<td>
<p>A logical value indicating whether to standardize columns. For each column, the mean of the entries in the column equals 0, and the variance of the entries in the column equals 1. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="relax_and_split_ICA_+3A_row.stand">row.stand</code></td>
<td>
<p>A logical value indicating whether to standardize rows. For each row, the mean of the entries in the row equals 0, and the variance of the entries in the row equals 1. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="relax_and_split_ICA_+3A_iter.stand">iter.stand</code></td>
<td>
<p>An integer specifying the number of iterations for achieving both row and column standardization when <code>col.stand = TRUE</code> and <code>row.stand = TRUE</code>. Default is 5.</p>
</td></tr>
<tr><td><code id="relax_and_split_ICA_+3A_positive_skewness">positive_skewness</code></td>
<td>
<p>A logical value indicating whether to enforce positive skewness on the estimated components. Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following elements:
</p>

<dl>
<dt><code>loglik</code></dt><dd><p>The minimal log-likelihood value among the random initializations.</p>
</dd>
<dt><code>estS</code></dt><dd><p>A numeric matrix of estimated sparse independent components with dimensions P x Q.</p>
</dd>
<dt><code>estU</code></dt><dd><p>The estimated U matrix with dimensions Q x Q.</p>
</dd>
<dt><code>estM</code></dt><dd><p>The estimated mixing matrix with dimensions Q x T.</p>
</dd>
<dt><code>whitener</code></dt><dd><p>The whitener matrix used for data whitening.</p>
</dd>
<dt><code>converge</code></dt><dd><p>Convergence information for the U matrix.</p>
</dd>
</dl>


<hr>
<h2 id='signchange'>Change the sign of S and M matrices to positive skewness.</h2><span id='topic+signchange'></span>

<h3>Description</h3>

<p>Change the sign of S and M matrices to positive skewness.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signchange(S, M = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="signchange_+3A_s">S</code></td>
<td>
<p>The S matrix with dimension P x Q.</p>
</td></tr>
<tr><td><code id="signchange_+3A_m">M</code></td>
<td>
<p>The M matrix with dimension Q x T.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of S and M matrices with positive skewness.
</p>

<hr>
<h2 id='soft_thresh_R'>Soft-threshold function</h2><span id='topic+soft_thresh_R'></span>

<h3>Description</h3>

<p>Soft-threshold function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>soft_thresh_R(x, nu = 1, lambda = sqrt(2)/2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="soft_thresh_R_+3A_x">x</code></td>
<td>
<p>The input scalar.</p>
</td></tr>
<tr><td><code id="soft_thresh_R_+3A_nu">nu</code></td>
<td>
<p>The tuning parameter.</p>
</td></tr>
<tr><td><code id="soft_thresh_R_+3A_lambda">lambda</code></td>
<td>
<p>The lambda parameter of the Laplace density.</p>
</td></tr>
</table>

<hr>
<h2 id='sparseICA'>Sparse Independent Component Analysis (Sparse ICA) Function</h2><span id='topic+sparseICA'></span>

<h3>Description</h3>

<p>This function performs Sparse Independent Component Analysis (Sparse ICA), implemented in both pure R and RCpp for efficiency.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparseICA(
  xData,
  n.comp,
  nu = "BIC",
  nu_list = seq(0.1, 4, 0.1),
  U.list = NULL,
  whiten = c("eigenvec", "sqrtprec", "none"),
  lngca = FALSE,
  orth.method = c("svd", "givens"),
  method = c("C", "R"),
  restarts = 40,
  use_irlba = TRUE,
  eps = 1e-06,
  maxit = 500,
  verbose = TRUE,
  BIC_verbose = FALSE,
  converge_plot = FALSE,
  col.stand = TRUE,
  row.stand = FALSE,
  iter.stand = 5,
  positive_skewness = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sparseICA_+3A_xdata">xData</code></td>
<td>
<p>A numeric matrix of input data with dimensions P x T, where P is the number of features and T is the number of samples.</p>
</td></tr>
<tr><td><code id="sparseICA_+3A_n.comp">n.comp</code></td>
<td>
<p>An integer specifying the number of components to estimate.</p>
</td></tr>
<tr><td><code id="sparseICA_+3A_nu">nu</code></td>
<td>
<p>A positive numeric value or a character &quot;BIC&quot; specifying the tuning parameter controlling the balance between accuracy and sparsity of the results. It can be selected using a BIC-like criterion (<code>"BIC"</code>) or based on expert knowledge (a positive number). Default is &quot;BIC&quot;.</p>
</td></tr>
<tr><td><code id="sparseICA_+3A_nu_list">nu_list</code></td>
<td>
<p>A numeric vector specifying the list of candidate tuning parameters. Default is <code>seq(0.1, 4, 0.1)</code>.</p>
</td></tr>
<tr><td><code id="sparseICA_+3A_u.list">U.list</code></td>
<td>
<p>An optional matrix specifying the initialization of the U matrix. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="sparseICA_+3A_whiten">whiten</code></td>
<td>
<p>A character string specifying the method for whitening the input <code>xData</code>. Options are <code>"eigenvec"</code>, <code>"sqrtprec"</code>, <code>"lngca"</code>, or <code>"none"</code>. Default is <code>"eigenvec"</code>.</p>
</td></tr>
<tr><td><code id="sparseICA_+3A_lngca">lngca</code></td>
<td>
<p>A logical value indicating whether to perform Linear Non-Gaussian Component Analysis (LNGCA). Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="sparseICA_+3A_orth.method">orth.method</code></td>
<td>
<p>A character string specifying the method used for generating initial values for the U matrix. Default is <code>"svd"</code>.</p>
</td></tr>
<tr><td><code id="sparseICA_+3A_method">method</code></td>
<td>
<p>A character string specifying the computation method. If <code>"C"</code> (default), C code is used for most computations for better performance. If <code>"R"</code>, computations are performed entirely in R.</p>
</td></tr>
<tr><td><code id="sparseICA_+3A_restarts">restarts</code></td>
<td>
<p>An integer specifying the number of random initializations for optimization. Default is 40.</p>
</td></tr>
<tr><td><code id="sparseICA_+3A_use_irlba">use_irlba</code></td>
<td>
<p>A logical value indicating whether to use the <code>irlba</code> method for fast truncated Singular Value Decomposition (SVD) during whitening. This can improve memory efficiency for intermediate datasets. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="sparseICA_+3A_eps">eps</code></td>
<td>
<p>A numeric value specifying the convergence threshold. Default is <code>1e-6</code>.</p>
</td></tr>
<tr><td><code id="sparseICA_+3A_maxit">maxit</code></td>
<td>
<p>An integer specifying the maximum number of iterations for the Sparse ICA method using Laplace density. Default is 500.</p>
</td></tr>
<tr><td><code id="sparseICA_+3A_verbose">verbose</code></td>
<td>
<p>A logical value indicating whether to print convergence information during execution. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="sparseICA_+3A_bic_verbose">BIC_verbose</code></td>
<td>
<p>A logical value indicating whether to print BIC selection information. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="sparseICA_+3A_converge_plot">converge_plot</code></td>
<td>
<p>A logical value indicating whether to generate a line plot showing the convergence trace. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="sparseICA_+3A_col.stand">col.stand</code></td>
<td>
<p>A logical value indicating whether to standardize columns. For each column, the mean of the entries in the column equals 0, and the variance of the entries in the column equals 1. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="sparseICA_+3A_row.stand">row.stand</code></td>
<td>
<p>A logical value indicating whether to standardize rows. For each row, the mean of the entries in the row equals 0, and the variance of the entries in the row equals 1. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="sparseICA_+3A_iter.stand">iter.stand</code></td>
<td>
<p>An integer specifying the number of iterations for achieving both row and column standardization when <code>col.stand = TRUE</code> and <code>row.stand = TRUE</code>. Default is 5.</p>
</td></tr>
<tr><td><code id="sparseICA_+3A_positive_skewness">positive_skewness</code></td>
<td>
<p>A logical value indicating whether to enforce positive skewness on the estimated components. Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following elements:
</p>

<dl>
<dt><code>loglik</code></dt><dd><p>The minimal log-likelihood value among the random initializations.</p>
</dd>
<dt><code>estS</code></dt><dd><p>A numeric matrix of estimated sparse independent components with dimensions P x Q.</p>
</dd>
<dt><code>estM</code></dt><dd><p>The estimated mixing matrix with dimensions Q x T.</p>
</dd>
<dt><code>estU</code></dt><dd><p>The estimated U matrix with dimensions Q x Q.</p>
</dd>
<dt><code>whitener</code></dt><dd><p>The whitener matrix used for data whitening.</p>
</dd>
<dt><code>converge</code></dt><dd><p>The trace of convergence for the U matrix.</p>
</dd>
<dt><code>BIC</code></dt><dd><p>A numeric vector of BIC values corresponding to each candidate <code>nu</code> in <code>nu_list</code>.</p>
</dd>
<dt><code>nu_list</code></dt><dd><p>A numeric vector of candidate tuning parameter values.</p>
</dd>
<dt><code>best_nu</code></dt><dd><p>The optimal <code>nu</code> selected based on the BIC-like criterion.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
#get simulated data
data(example_sim123)

my_sparseICA &lt;- sparseICA(xData = example_sim123$xmat, n.comp = 3, nu = "BIC", method="C",
      restarts = 40, eps = 1e-6, maxit = 500, verbose=TRUE)

res_matched &lt;- matchICA(my_sparseICA$estS,example_sim123$smat)

# Visualize the estimated components
oldpar &lt;- par()$mfrow
par(mfrow=c(1,3))
image(matrix(res_matched[,1],33,33))
image(matrix(res_matched[,2],33,33))
image(matrix(res_matched[,3],33,33))
par(mfrow=oldpar)


</code></pre>

<hr>
<h2 id='theta2W'>Convert angle vector into orthodox matrix</h2><span id='topic+theta2W'></span>

<h3>Description</h3>

<p>Convert angle vector into orthodox matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theta2W(theta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="theta2W_+3A_theta">theta</code></td>
<td>
<p>A vector of angles theta.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An orthodox matrix.
</p>

<hr>
<h2 id='whitener'>The function for perform whitening.</h2><span id='topic+whitener'></span>

<h3>Description</h3>

<p>The function for perform whitening.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>whitener(X, n.comp = ncol(X), center.row = FALSE, use_irlba = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="whitener_+3A_x">X</code></td>
<td>
<p>The data matrix with dimension P x T.</p>
</td></tr>
<tr><td><code id="whitener_+3A_n.comp">n.comp</code></td>
<td>
<p>The number of components.</p>
</td></tr>
<tr><td><code id="whitener_+3A_center.row">center.row</code></td>
<td>
<p>Whether to center the row of data. Default is FALSE.</p>
</td></tr>
<tr><td><code id="whitener_+3A_use_irlba">use_irlba</code></td>
<td>
<p>Whether to use the irlba method to perform fast truncated singular value decomposition in whitening step, helpful for memorying intermediate dataset. Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list including the whitener matrix, the whitened data matrix, and the mean of the input data.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
