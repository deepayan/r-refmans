<!DOCTYPE html><html lang="en"><head><title>Help for package microdiluteR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {microdiluteR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_concentration'><p>Add concentration metadata</p></a></li>
<li><a href='#add_treatment'><p>Add treatment metadata</p></a></li>
<li><a href='#apply_sign_test'><p>Apply sign test</p></a></li>
<li><a href='#bma'><p>Absorption values from six broth microdilution assays conducted on 96-well plates</p></a></li>
<li><a href='#calculate_growth_performance'><p>Calculate and visualize growth performance</p></a></li>
<li><a href='#check_well_positions'><p>Check monotonicity of well positions across groups</p></a></li>
<li><a href='#generate_experiment_list'><p>Generate list of experiment names from user parameters</p></a></li>
<li><a href='#generate_group_list'><p>Generate list of group IDs from user parameters</p></a></li>
<li><a href='#read_plates'><p>Read multiple text files from photometer measurement</p></a></li>
<li><a href='#subtract_T0'><p>Subtract timepoint T0 and remove from data</p></a></li>
<li><a href='#tidy_plates'><p>Add metadata to values from photometer measurements</p></a></li>
<li><a href='#tidy_plates_via_params'><p>Tidy multiple 96-well plates via parameters</p></a></li>
<li><a href='#tidy_plates_via_prompts'><p>Read raw photometry data and add meta data based on user input</p></a></li>
<li><a href='#tidy_single_plate'><p>Tidy single 96-well plate via parameters</p></a></li>
<li><a href='#validate_cells'><p>Check validity of each cell in data frame.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Analysis of Broth Microdilution Assays</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-04-16</td>
</tr>
<tr>
<td>Description:</td>
<td>A framework for analyzing broth microdilution assays in various
    96-well plate designs, visualizing results and providing descriptive and (simple)
    inferential statistics (i.e. summary statistics and sign test). The functions are 
    designed to add metadata to 8 x 12 tables of absorption values, creating a tidy
    data frame. Users can choose between clean-up procedures via function 
    parameters (which covers most cases) or user prompts (in cases with complex 
    experimental designs). Users can also choose between two validation methods,
    i.e. exclusion of absorbance values above a certain threshold or manual exclusion 
    of samples. A function for visual inspection of samples with their absorption values
    over time for certain group combinations helps with the decision. In addition,
    the package includes functions to subtract the background absorption (usually
    at time T0) and to calculate the growth performance compared to a baseline.
    Samples can be visually inspected with their absorption values displayed across
    time points for specific group combinations. Core functions of this package (i.e.
    background subtraction, sample validation and statistics) were inspired by the
    manual calculations that were applied in Tewes and Muller (2020)
    &lt;<a href="https://doi.org/10.1038%2Fs41598-020-67600-7">doi:10.1038/s41598-020-67600-7</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://silvia-eckert.github.io/microdiluteR/">https://silvia-eckert.github.io/microdiluteR/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/silvia-eckert/microdiluteR/issues">https://github.com/silvia-eckert/microdiluteR/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.3)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr (&ge; 1.1.4), ggh4x (&ge; 0.2.8), ggplot2 (&ge; 3.5.0),
ggthemes (&ge; 5.0.1), magrittr (&ge; 2.0.3), purrr (&ge; 1.0.2),
rlang (&ge; 1.1.3), rstatix (&ge; 0.7.2), stringr (&ge; 1.5.1),
tibble (&ge; 3.2.1), tools (&ge; 4.3.3), vctrs (&ge; 0.6.5)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr (&ge; 1.4.6), rmarkdown (&ge; 2.26), testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-10 18:10:52 UTC; Silvia</td>
</tr>
<tr>
<td>Author:</td>
<td>Silvia Eckert <a href="https://orcid.org/0000-0002-8896-1046"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Silvia Eckert &lt;seckert-dev@posteo.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-13 11:23:25 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_concentration'>Add concentration metadata</h2><span id='topic+add_concentration'></span><span id='topic+generate_concentration_list'></span><span id='topic+ask_concentration_list'></span><span id='topic+match_concentration'></span>

<h3>Description</h3>

<p><code>add_concentration</code> adds concentration metadata to photometer data that is specified in long format.
For this function to work properly, the column containing the well positions should be named 'Position'
and the column containing the corresponding absorption values should be named 'Values'.
</p>
<p><code>generate_concentration_list</code> generates a list of provided concentration levels mapped to the user-specified
plate layout. The plate layout is based on a 96-well plate and can be either horizontal (i.e. letters A-H) or vertical (i.e. numbers 1-12).
</p>
<p><code>ask_concentration_list</code> works the same way as <code>generate_concentration_list</code>, but retrieves the
concentration levels based on a user prompt instead of user-set parameters. The plate axis can be either in horizontal direction
providing letters A-H or in vertical direction providing numbers 1-12 based on a 96-well plate layout.
</p>
<p><code>match_concentration</code> maps concentration levels to corresponding well positions and returns 'NA' otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_concentration(
  input_data,
  concentration_list = NULL,
  ask_concentration_list = TRUE,
  ...
)

generate_concentration_list(concentration_levels, direction)

ask_concentration_list(direction = c("horizontal", "vertical"))

match_concentration(well_position, concentration_list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_concentration_+3A_input_data">input_data</code></td>
<td>
<p>A data frame with well positions and their corresponding values.</p>
</td></tr>
<tr><td><code id="add_concentration_+3A_concentration_list">concentration_list</code></td>
<td>
<p>A list containing concentration information</p>
</td></tr>
<tr><td><code id="add_concentration_+3A_ask_concentration_list">ask_concentration_list</code></td>
<td>
<p>A boolean parameter indicating whether concentration levels should be retrieved via user prompt (default) or not.</p>
</td></tr>
<tr><td><code id="add_concentration_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code><a href="#topic+ask_concentration_list">ask_concentration_list</a></code>.</p>
</td></tr>
<tr><td><code id="add_concentration_+3A_concentration_levels">concentration_levels</code></td>
<td>
<p>A numeric vector containing concentration levels.</p>
</td></tr>
<tr><td><code id="add_concentration_+3A_direction">direction</code></td>
<td>
<p>A character vector specifying the orientation of the plate layout. 
It can be either &quot;horizontal&quot; or &quot;vertical&quot;.</p>
</td></tr>
<tr><td><code id="add_concentration_+3A_well_position">well_position</code></td>
<td>
<p>The sample position(s) to check</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>generate_concentration_list</code> checks if the length of <code>concentration_levels</code> matches the specified 
number of rows or columns based on the direction parameter. If not, it throws an error.
If the lengths match, it generates a list of concentration levels where each level is 
assigned to a corresponding row or column based on the direction parameter.
</p>


<h3>Value</h3>

<p><code>add_concentration</code> returns a data frame with concentration metadata added.
</p>
<p><code>generate_concentration_list</code> returns a list of concentration levels where each level is assigned to a corresponding 
row or column based on the selected direction parameter.
</p>
<p><code>ask_concentration_list</code> returns a list containing plate axes as keys and concentration information as values.
</p>
<p><code>match_concentration</code> returns the corresponding concentration level if sample position matches concentration criteria, &quot;NA&quot; otherwise
</p>


<h3>See Also</h3>

<p><code><a href="#topic+generate_experiment_list">generate_experiment_list</a></code>, <code><a href="#topic+ask_experiment_list">ask_experiment_list</a></code>,
<code><a href="#topic+generate_group_list">generate_group_list</a></code>, <code><a href="#topic+ask_group_list">ask_group_list</a></code>,
<code><a href="#topic+add_treatment">add_treatment</a></code>, <code><a href="#topic+validate_cells">validate_cells</a></code>
</p>

<hr>
<h2 id='add_treatment'>Add treatment metadata</h2><span id='topic+add_treatment'></span><span id='topic+generate_treatment_list'></span><span id='topic+ask_treatment_list'></span><span id='topic+match_treatment'></span>

<h3>Description</h3>

<p><code>add_treatment</code> adds treatment metadata to photometer data that is specified in long format.
For this function to work properly, the column containing the well positions should be named 'Position'
and the column containing the corresponding absorption values should be named 'Values'.
</p>
<p><code>generate_treatment_list</code> generates a list of provided treatment labels mapped to the user-specified
plate layout. The plate layout is based on a 96-well plate and can be either horizontal (i.e. letters A-H) or vertical (i.e. numbers 1-12).
</p>
<p><code>ask_treatment_list</code> works the same way as <code>generate_treatment_list</code>, but retrieves the
treatment labels based on a user prompt instead of user-set parameters. The plate axis can be either in horizontal direction
providing letters A-H or in vertical direction providing numbers 1-12 based on a 96-well plate layout.
</p>
<p><code>match_treatment</code> maps treatment labels to corresponding well positions and returns 'NA' otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_treatment(
  input_data,
  treatment_list = NULL,
  ask_treatment_list = TRUE,
  ...
)

generate_treatment_list(treatment_labels, direction)

ask_treatment_list(direction = c("horizontal", "vertical"))

match_treatment(well_position, treatment_list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_treatment_+3A_input_data">input_data</code></td>
<td>
<p>A data frame with well positions and their corresponding values.</p>
</td></tr>
<tr><td><code id="add_treatment_+3A_treatment_list">treatment_list</code></td>
<td>
<p>A list containing treatment information</p>
</td></tr>
<tr><td><code id="add_treatment_+3A_ask_treatment_list">ask_treatment_list</code></td>
<td>
<p>A boolean parameter indicating whether treatment labels should be retrieved via user prompt (default) or not.</p>
</td></tr>
<tr><td><code id="add_treatment_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code><a href="#topic+ask_treatment_list">ask_treatment_list</a></code>.</p>
</td></tr>
<tr><td><code id="add_treatment_+3A_treatment_labels">treatment_labels</code></td>
<td>
<p>A character vector containing treatment labels.</p>
</td></tr>
<tr><td><code id="add_treatment_+3A_direction">direction</code></td>
<td>
<p>A character vector specifying the orientation of the plate layout. 
It can be either &quot;horizontal&quot; or &quot;vertical&quot;.</p>
</td></tr>
<tr><td><code id="add_treatment_+3A_well_position">well_position</code></td>
<td>
<p>The sample position(s) to check</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>generate_treatment_list</code> checks if the length of treatment_labels matches the specified 
number of rows or columns based on the direction parameter. If not, it throws an error.
If the lengths match, it generates a list of treatment_labels where each label is 
assigned to a corresponding row or column based on the direction parameter.
</p>


<h3>Value</h3>

<p><code>add_treatment</code> returns a data frame with treatment information added.
</p>
<p><code>generate_treatment_list</code> returns a list of treatment labels where each level is assigned to a corresponding 
row or column based on the selected direction parameter.
</p>
<p><code>ask_treatment_list</code> returns a list containing plate axes as keys and treatment labels as values.
</p>
<p><code>match_treatment</code> returns the corresponding treatment labels if sample position matches treatment criteria, &quot;NA&quot; otherwise
</p>


<h3>See Also</h3>

<p><code><a href="#topic+generate_experiment_list">generate_experiment_list</a></code>, <code><a href="#topic+ask_experiment_list">ask_experiment_list</a></code>,
<code><a href="#topic+generate_group_list">generate_group_list</a></code>, <code><a href="#topic+ask_group_list">ask_group_list</a></code>,
<code><a href="#topic+add_concentration">add_concentration</a></code>, <code><a href="#topic+validate_cells">validate_cells</a></code>
</p>

<hr>
<h2 id='apply_sign_test'>Apply sign test</h2><span id='topic+apply_sign_test'></span>

<h3>Description</h3>

<p>This function applies the one-sample sign test to input data grouped by specified variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_sign_test(
  stats_data,
  summarized_data,
  value = "Value",
  p.signif = "p.signif",
  grouping = NULL,
  na = "NA"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apply_sign_test_+3A_stats_data">stats_data</code></td>
<td>
<p>A data frame containing the calculated growth performance data,
e.g. via a function call to <code>calculate_growth_performance</code>.</p>
</td></tr>
<tr><td><code id="apply_sign_test_+3A_summarized_data">summarized_data</code></td>
<td>
<p>A data frame containing corresponding summarized data, e.g. via function call
<code>summarize_growth_performance</code>.</p>
</td></tr>
<tr><td><code id="apply_sign_test_+3A_value">value</code></td>
<td>
<p>The column containing absorption values to be tested. Defaults to 'Value'.</p>
</td></tr>
<tr><td><code id="apply_sign_test_+3A_p.signif">p.signif</code></td>
<td>
<p>The column containing significance denoted in asterisk notation. Defaults
to 'p.signif'.</p>
</td></tr>
<tr><td><code id="apply_sign_test_+3A_grouping">grouping</code></td>
<td>
<p>A character vector specifying the grouping variables.</p>
</td></tr>
<tr><td><code id="apply_sign_test_+3A_na">na</code></td>
<td>
<p>A character value specifying the keyword to display if sign tests cannot be applied
on subsets of the data (e.g. because of too small sample sizes). Defaults to &quot;NA&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the summarized data with sign test results added.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calculate_growth_performance">calculate_growth_performance</a></code>, <code><a href="#topic+summarize_growth_performance">summarize_growth_performance</a></code>,
<code><a href="#topic+plot_growth_performance">plot_growth_performance</a></code>,
</p>

<hr>
<h2 id='bma'>Absorption values from six broth microdilution assays conducted on 96-well plates</h2><span id='topic+bma'></span>

<h3>Description</h3>

<p>A list of six sample data sets with absorption values from broth
microdilution assays on 96-well plates, applied to two groups with one experiment
each at two time points T0 and T3.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bma
</code></pre>


<h3>Format</h3>

<p>A list with six data frames:
</p>

<dl>
<dt>bma_grp1_exp2_T0</dt><dd><p>Absorption values from a broth microdilution assay
applied on group 1 from experiment 2 on 96-well plate at timepoint T0.</p>
</dd>
<dt>bma_grp1_exp2_T3</dt><dd><p>Absorption values from a broth microdilution assay
applied on group 1 from experiment 2 on 96-well plate at timepoint T3.</p>
</dd>
<dt>bma_grp2_exp1_T0</dt><dd><p>Absorption values from a broth microdilution assay
applied on group 2 from experiment 1 on 96-well plate at timepoint T0.</p>
</dd>
<dt>bma_grp2_exp1_T3</dt><dd><p>Absorption values from a broth microdilution assay
applied on group 2 from experiment 1 on 96-well plate at timepoint T3.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data was derived from two broth microdilution assay experiments testing the
growth performance of <em>Botrytis cinerea</em> conidia on two <em>Tanacetum vulgare</em>
chemotypes (defined as <code>groups</code>). Leaf extracts from chemotypes were fractionated using
solid-phase extraction with a water-methanol polarity gradient (defined as <code>treatment</code>)
and fractions were subjected to assays in two concentrations (100 ppm and 200 ppm) plus
a positive control for each concentration level. The 96-well plate design was assigned in
horizontal direction (provided as <code>plate_axis</code>) and is stored in the metadata attribute
of the list. The data was generated for teaching purposes and is unrestricted by any
licensing constraints.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bma)
attr(bma, "metadata")
</code></pre>

<hr>
<h2 id='calculate_growth_performance'>Calculate and visualize growth performance</h2><span id='topic+calculate_growth_performance'></span><span id='topic+calculate_percentage_change'></span><span id='topic+summarize_growth_performance'></span><span id='topic+summarise_growth_performance'></span><span id='topic+plot_growth_performance'></span>

<h3>Description</h3>

<p><code>calculate_growth_performance</code> standardizes data by subtracting the average value of the control group from each treatment level
for each concentration level, applied within each experiment. It assumes the input data is a data frame with columns 'Experiment', 'Concentration', 'Treatment', 
and 'Value', where 'Concentration' represents different concentration levels, 'Treatment' represents different 
treatment groups, and 'Value' represents the corresponding absorption values.
</p>
<p><code>calculate_percentage_change</code> calculates the percentage change between a vector of values (or a
single value) and a reference value as the baseline. If a value in the vector is less than the reference, it returns
the negative percentage difference; otherwise, it returns the positive percentage difference.
</p>
<p><code>summarize_growth_performance</code> summarizes a data frame containing growth performance by
computing the mean and either the standard error or standard deviation.
</p>
<p><code>plot_growth_performance</code> visualizes growth performance using bar charts with error bars.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_growth_performance(
  input_data,
  treatment_grouping = FALSE,
  concentration_grouping = FALSE,
  group = "Group",
  experiment = "Experiment",
  treatment = "Treatment",
  concentration = "Concentration",
  timepoint = "Timepoint",
  value = "Value",
  control_mean = "control_mean"
)

calculate_percentage_change(input, reference)

summarize_growth_performance(
  input_data,
  compute_sd = FALSE,
  grouping = c("Group", "Treatment", "Concentration", "Timepoint"),
  treatment = "Treatment",
  value = "Value"
)

plot_growth_performance(
  input_data,
  stats_data = NULL,
  level_unit = NULL,
  treatment_order = NULL,
  apply_sign_test = FALSE,
  grouping = NULL,
  x_var = "Treatment",
  y_var = "mean",
  error_var = "stderr",
  x_lab = "Treatment",
  y_lab = NULL,
  fill_var = "Concentration",
  row_facets = NULL,
  col_facets = "Group",
  value = "Value",
  p_values = "p.signif",
  level_colors = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_growth_performance_+3A_input_data">input_data</code></td>
<td>
<p>A data frame containing summarized data, e.g. from function call to <code>summarize_growth_performance</code>.</p>
</td></tr>
<tr><td><code id="calculate_growth_performance_+3A_treatment_grouping">treatment_grouping</code></td>
<td>
<p>A Boolean value that specifies whether or not (default) there is a treatment grouping within the plate.</p>
</td></tr>
<tr><td><code id="calculate_growth_performance_+3A_concentration_grouping">concentration_grouping</code></td>
<td>
<p>A Boolean value that specifies whether or not (default) there is a concentration grouping within the plate.</p>
</td></tr>
<tr><td><code id="calculate_growth_performance_+3A_group">group</code></td>
<td>
<p>The column containing group information. Defaults to 'Group'.</p>
</td></tr>
<tr><td><code id="calculate_growth_performance_+3A_experiment">experiment</code></td>
<td>
<p>The column containing experiment information. Defaults to 'Experiment'. The hierarchy is group &gt; experiment, i.e.
within a single group, there might be several experiments taking place (e.g. multiple extracts from the same plant species
tested with plant species being the group and type of extract being the experiment).</p>
</td></tr>
<tr><td><code id="calculate_growth_performance_+3A_treatment">treatment</code></td>
<td>
<p>The column containing treatment information. Defaults to 'Treatment'.</p>
</td></tr>
<tr><td><code id="calculate_growth_performance_+3A_concentration">concentration</code></td>
<td>
<p>The column containing concentration information. Defaults to 'Concentration'.</p>
</td></tr>
<tr><td><code id="calculate_growth_performance_+3A_timepoint">timepoint</code></td>
<td>
<p>The column containing timepoint information. Defaults to 'Timepoint'.</p>
</td></tr>
<tr><td><code id="calculate_growth_performance_+3A_value">value</code></td>
<td>
<p>The column containing the absorption values to be assessed via <code>apply_sign_test</code>. Defaults to 'Value'.</p>
</td></tr>
<tr><td><code id="calculate_growth_performance_+3A_control_mean">control_mean</code></td>
<td>
<p>he column containing the absorption values to calculate growth performance. Defaults to 'control_mean'.</p>
</td></tr>
<tr><td><code id="calculate_growth_performance_+3A_input">input</code></td>
<td>
<p>A single numeric value.</p>
</td></tr>
<tr><td><code id="calculate_growth_performance_+3A_reference">reference</code></td>
<td>
<p>A single numeric value serving as the baseline for comparison.</p>
</td></tr>
<tr><td><code id="calculate_growth_performance_+3A_compute_sd">compute_sd</code></td>
<td>
<p>Logical, indicating whether to compute the standard deviation (default) or standard error.</p>
</td></tr>
<tr><td><code id="calculate_growth_performance_+3A_grouping">grouping</code></td>
<td>
<p>Optional. A character vector specifying the grouping variables on which to apply the sign
test. If not specified and 'apply_sign_test' is set to TRUE, then the test will be applied on the
whole dataset.</p>
</td></tr>
<tr><td><code id="calculate_growth_performance_+3A_stats_data">stats_data</code></td>
<td>
<p>Optional. A data frame containing growth performance data, e.g. from function call to
<code>calculate_growth_performance</code>. Only necessary, if 'apply_sign_test' parameter is set to TRUE.</p>
</td></tr>
<tr><td><code id="calculate_growth_performance_+3A_level_unit">level_unit</code></td>
<td>
<p>Optional. The unit of applied concentrations to display on the y-axis.</p>
</td></tr>
<tr><td><code id="calculate_growth_performance_+3A_treatment_order">treatment_order</code></td>
<td>
<p>Optional. An alternative order of factor levels on the x-axis.</p>
</td></tr>
<tr><td><code id="calculate_growth_performance_+3A_apply_sign_test">apply_sign_test</code></td>
<td>
<p>Logical. Should the sign test be applied to specified levels? For this, the 'stats_data' and
'grouping' parameters need to be specified.</p>
</td></tr>
<tr><td><code id="calculate_growth_performance_+3A_x_var">x_var</code></td>
<td>
<p>The variable name for the x-axis. Defaults to &quot;Treatment&quot;.</p>
</td></tr>
<tr><td><code id="calculate_growth_performance_+3A_y_var">y_var</code></td>
<td>
<p>The variable name for the y-axis. Defaults to &quot;mean&quot;.</p>
</td></tr>
<tr><td><code id="calculate_growth_performance_+3A_error_var">error_var</code></td>
<td>
<p>The variable name to generate the error bars. Defaults to 'stderr'.</p>
</td></tr>
<tr><td><code id="calculate_growth_performance_+3A_x_lab">x_lab</code></td>
<td>
<p>The label for the x-axis. Defaults to &quot;Treatment&quot;.</p>
</td></tr>
<tr><td><code id="calculate_growth_performance_+3A_y_lab">y_lab</code></td>
<td>
<p>Optional. The label for the y-axis. If not provided will return &quot;Relative growth performance&quot;.</p>
</td></tr>
<tr><td><code id="calculate_growth_performance_+3A_fill_var">fill_var</code></td>
<td>
<p>The variable used to fill facets. Defaults to &quot;Concentration&quot;.</p>
</td></tr>
<tr><td><code id="calculate_growth_performance_+3A_row_facets">row_facets</code></td>
<td>
<p>A character vector specifying nested column facets. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="calculate_growth_performance_+3A_col_facets">col_facets</code></td>
<td>
<p>A character vector specifying nested row facets. Defaults to &quot;Group&quot;.</p>
</td></tr>
<tr><td><code id="calculate_growth_performance_+3A_p_values">p_values</code></td>
<td>
<p>The column containing the (adjusted) p-values. Defaults to 'p.adj.signif' from a
function call to <code>apply_sign_test</code> and <code>rstatix::sign_test</code>.</p>
</td></tr>
<tr><td><code id="calculate_growth_performance_+3A_level_colors">level_colors</code></td>
<td>
<p>Optional. The colors for different levels. If not specified, will be determined
based on levels of 'fill_var' using <code>gray.colors</code>.</p>
</td></tr>
<tr><td><code id="calculate_growth_performance_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code><a href="#topic+apply_sign_test">apply_sign_test</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plot_growth_performance</code> uses ggplot2 to create bar charts of summarized data with error bars.
</p>


<h3>Value</h3>

<p><code>calculate_growth_performance</code> returns a modified data frame with the control mean subtracted from each treatment level for each concentration level, applied within each experiment.
</p>
<p><code>calculate_percentage_change</code> returns a numeric vector containing the percentage change for each value in the vector compared to the reference.
</p>
<p><code>summarize_growth_performance</code> returns a data frame containing the summary statistics.
</p>
<p><code>plot_growth_performance</code> returns a ggplot object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tidy_single_plate">tidy_single_plate</a></code>, <code><a href="#topic+tidy_plates_via_params">tidy_plates_via_params</a></code>, <code><a href="#topic+tidy_plates_via_prompts">tidy_plates_via_prompts</a></code>
</p>

<hr>
<h2 id='check_well_positions'>Check monotonicity of well positions across groups</h2><span id='topic+check_well_positions'></span><span id='topic+check_monotonicity'></span>

<h3>Description</h3>

<p><code>check_well_positions</code> checks if well positions across groups, i.e.
experiments, monotonically increase or decrease with timepoints measured.
</p>
<p><code>check_monotonicity</code> checks whether the values in a numeric vector are monotonically
increasing or decreasing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_well_positions(
  input_data,
  x_var = "Timepoint",
  y_var = "Value",
  grouping = "Position",
  v_var = "Validity",
  wp_var = "Position"
)

check_monotonicity(vec)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_well_positions_+3A_input_data">input_data</code></td>
<td>
<p>A data.frame containing the input data, e.g. from a function call to
<code>tidy_single_plate</code>, <code>tidy_plates_via_params</code> or <code>tidy_plates_via_prompts</code>.</p>
</td></tr>
<tr><td><code id="check_well_positions_+3A_x_var">x_var</code></td>
<td>
<p>A character string specifying the variable to be plotted on the x-axis. Defaults to
'Timepoint'.</p>
</td></tr>
<tr><td><code id="check_well_positions_+3A_y_var">y_var</code></td>
<td>
<p>A character string specifying the variable to be plotted on the y-axis. Defaults to
'Value'.</p>
</td></tr>
<tr><td><code id="check_well_positions_+3A_grouping">grouping</code></td>
<td>
<p>A vector of character strings specifying the grouping variables.
Defaults to 'Position' if no grouping is provided.</p>
</td></tr>
<tr><td><code id="check_well_positions_+3A_v_var">v_var</code></td>
<td>
<p>A character string specifying the validity information. Usually a column
with all rows being 'valid'. Rows are set to 'invalid' based on user selection. Defaults to
&quot;Validity&quot;.</p>
</td></tr>
<tr><td><code id="check_well_positions_+3A_wp_var">wp_var</code></td>
<td>
<p>A character string specifying the column providing the well positions. Defaults to
&quot;Position&quot;.</p>
</td></tr>
<tr><td><code id="check_well_positions_+3A_vec">vec</code></td>
<td>
<p>A numeric vector to be checked for monotonicity.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If non-monotonic groups of well positions are detected, <code>check_well_positions</code>
plots them as line graphs and returns a list with both the corresponding subset of the data for
further inspection and the input data adjusted for invalid well positions from visual inspection.
</p>
<p><code>check_monotonicity</code> checks if all differences between consecutive elements 
in the vector 'vec' are non-negative (indicating monotonic non-decreasing 
behavior) or non-positive (indicating monotonic non-increasing behavior).
</p>


<h3>Value</h3>

<p><code>check_well_positions</code> returns a subset of the input data containing
only the data from non-monotonic groups, if non-monotonic groups are detected.
Otherwise, NULL is returned.
</p>
<p><code>check_monotonicity</code> returns a logical value.
</p>


<h3>See Also</h3>

<p><code>tidy_plate</code>, <code>tidy_plates_via_params</code>, <code>tidy_plates_via_prompts</code>
</p>
<p><code><a href="#topic+validate_cells">validate_cells</a></code>, <code><a href="#topic+update_validity">update_validity</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate example data
set.seed(123)
df &lt;- data.frame(Position = rep(1:21, 2),
                 Value = c(1:21, sample(1:21,21, TRUE)),
                 Timepoint = rep(paste0("T",1:3),14),
                 Validity = "valid",
                 Group_1 = rep(LETTERS[1:2], each=21),
                 Group_2 = rep(letters[1:14], each = 3))
# All groups behave monotonically
check_well_positions(df[df$Group_1 == "A",],
                     x_var = "Timepoint",
                     y_var = "Value",
                     grouping = c("Group_1", "Group_2"))
# Six groups behave non-monotonically
check_well_positions(df[df$Group_1 == "B",],
                     x_var = "Timepoint",
                     y_var = "Value",
                     grouping = c("Group_1", "Group_2"))
# Check if a vector is monotonically increasing (will return TRUE)
check_monotonicity(c(1, 2, 3, 4, 5))
# Check if a vector is monotonically decreasing (will return FALSE)
check_monotonicity(c(5, 80, 3, 2, 1))
</code></pre>

<hr>
<h2 id='generate_experiment_list'>Generate list of experiment names from user parameters</h2><span id='topic+generate_experiment_list'></span><span id='topic+ask_experiment_list'></span>

<h3>Description</h3>

<p><code>generate_experiment_list</code> generates a list of provided experiment names extracted
from file names.
</p>
<p><code>ask_experiment_list</code> works the same way as <code>generate_experiment_list</code>, but retrieves the
experiment names based on a user prompt instead of user-set parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_experiment_list(experiment_names, file_list)

ask_experiment_list(file_list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_experiment_list_+3A_experiment_names">experiment_names</code></td>
<td>
<p>A character vector containing names for each experiment.</p>
</td></tr>
<tr><td><code id="generate_experiment_list_+3A_file_list">file_list</code></td>
<td>
<p>A character vector of file IDs. Used to extract experiment IDs from.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>generate_experiment_list</code> extracts unique identifiers from file names and matches them with the 
provided experiment names. If the number of experiment names does not match the number 
of unique identifiers extracted from the file names, it throws an error. If the lengths match,
it generates a list of experiment names where each name is associated with a unique
identifier extracted from the file names.
</p>


<h3>Value</h3>

<p><code>generate_experiment_list</code> returns a list of experiment names where each level is assigned to a corresponding 
row or column based on the selected direction parameter.
</p>
<p><code>ask_experiment_list</code> returns a list containing experiment identifiers as keys and experiment names as values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+generate_group_list">generate_group_list</a></code>, <code><a href="#topic+ask_group_list">ask_group_list</a></code>,
<code><a href="#topic+add_treatment">add_treatment</a></code>, <code><a href="#topic+add_concentration">add_concentration</a></code>
</p>

<hr>
<h2 id='generate_group_list'>Generate list of group IDs from user parameters</h2><span id='topic+generate_group_list'></span><span id='topic+ask_group_list'></span>

<h3>Description</h3>

<p><code>generate_group_list</code> generates a list of provided group IDs extracted
from file IDs.
</p>
<p><code>ask_group_list</code> works the same way as <code>generate_group_list</code>, but retrieves the
group IDs based on a user prompt instead of user-set parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_group_list(group_names, file_list)

ask_group_list(file_list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_group_list_+3A_group_names">group_names</code></td>
<td>
<p>A character vector containing IDs for each group.</p>
</td></tr>
<tr><td><code id="generate_group_list_+3A_file_list">file_list</code></td>
<td>
<p>A character vector of file IDs. Used to extract group IDs from.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>generate_group_list</code> extracts unique identifiers from file IDs and matches them with the 
provided group IDs. If the number of group IDs does not match the number 
of unique identifiers extracted from the file IDs, it throws an error. If the lengths match,
it generates a list of group IDs where each ID is associated with a unique
identifier extracted from the file IDs.
</p>


<h3>Value</h3>

<p><code>generate_group_list</code> returns a list of group IDs where each level is assigned to a corresponding 
row or column based on the selected direction parameter.
</p>
<p><code>ask_group_list</code> returns a list containing group identifiers as keys and group IDs as values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+generate_experiment_list">generate_experiment_list</a></code>, <code><a href="#topic+ask_experiment_list">ask_experiment_list</a></code>,
<code><a href="#topic+add_treatment">add_treatment</a></code>, <code><a href="#topic+add_concentration">add_concentration</a></code>
</p>

<hr>
<h2 id='read_plates'>Read multiple text files from photometer measurement</h2><span id='topic+read_plates'></span><span id='topic+read_plate'></span>

<h3>Description</h3>

<p><code>read_plates</code> reads raw text files generated from photometer measurements of
96-well plates. The data is returned as a list but without additional first lines that are sometimes
used to provide additional information, for example, wavelength used or the date of measurement.
For comparison, this information is saved as an attribute of the list and can be retrieved
via the <code>"info"</code> parameter.
</p>
<p><code>read_plate</code> reads a raw text file generated from a photometer measurement of a
96-well plate. The data is returned as is but without additional first lines that are sometimes
used to provide additional information, for example, wavelength used or the date of measurement.
For comparison, this information is saved as an attribute of the raw data and can be retrieved
via the <code>"info"</code> parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_plates(input_data, pattern = NULL, skip_lines = 2)

read_plate(file_path, skip_lines = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_plates_+3A_input_data">input_data</code></td>
<td>
<p>Either a folder path containing raw data files or a list of data frames.</p>
</td></tr>
<tr><td><code id="read_plates_+3A_pattern">pattern</code></td>
<td>
<p>A character value providing the file pattern to search for. If not provided,
defaults to <code>"^BMA|bma"</code>.</p>
</td></tr>
<tr><td><code id="read_plates_+3A_skip_lines">skip_lines</code></td>
<td>
<p>A numerical value that specifies the number of lines to be skipped until data is
provided. These lines will be saved as an attribute and are accessible via the <code>"info"</code> parameter.
Defaults to 2.</p>
</td></tr>
<tr><td><code id="read_plates_+3A_file_path">file_path</code></td>
<td>
<p>The file path to the file containing the raw data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>read_plates</code> returns a list of data frames containing the raw photometer data.
</p>
<p><code>read_plate</code> returns a data frame containing the raw photometer data
</p>

<hr>
<h2 id='subtract_T0'>Subtract timepoint T0 and remove from data</h2><span id='topic+subtract_T0'></span>

<h3>Description</h3>

<p>This function subtracts the values at timepoint T0 from all other timepoints
and removes it from the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subtract_T0(
  input_data,
  grouping = c("Group", "Experiment", "Position"),
  value = "Value",
  timepoint = "Timepoint",
  validity = "Validity"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subtract_T0_+3A_input_data">input_data</code></td>
<td>
<p>A data frame containing columns preferably named as 'Position', 'Value', 
'Experiment','Validity', and 'Timepoint'.</p>
</td></tr>
<tr><td><code id="subtract_T0_+3A_grouping">grouping</code></td>
<td>
<p>A character vector specifying the columns to use for grouping.
Defaults to c(&quot;Experiment&quot;, &quot;Position&quot;).</p>
</td></tr>
<tr><td><code id="subtract_T0_+3A_value">value</code></td>
<td>
<p>The column containing the values to be modified. Defaults to &quot;Value&quot;.</p>
</td></tr>
<tr><td><code id="subtract_T0_+3A_timepoint">timepoint</code></td>
<td>
<p>The column containing the timepoint information. Defaults to &quot;Timepoint&quot;.</p>
</td></tr>
<tr><td><code id="subtract_T0_+3A_validity">validity</code></td>
<td>
<p>The column containing validity information. Defaults to &quot;Validity&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function modifies the input data frame by subtracting the value at 
T0 timepoint from all other timepoints for each plate (i.e. experiment). It then removes the rows with 
this timepoint from the data frame.
</p>


<h3>Value</h3>

<p>A modified data frame with timepoint T0 subtracted and removed.
</p>

<hr>
<h2 id='tidy_plates'>Add metadata to values from photometer measurements</h2><span id='topic+tidy_plates'></span>

<h3>Description</h3>

<p>Cleans a list of data frames with different structures. This function reads data
from either a folder containing text files or from a list of data frames. It then cleans each
data frame using the function <code>tidy_plates_via_prompts()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_plates(
  input_data,
  how_many = c("single", "multiple"),
  user_prompt = FALSE,
  multiple_structures = FALSE,
  direction = c("horizontal", "vertical"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tidy_plates_+3A_input_data">input_data</code></td>
<td>
<p>Either a folder path containing text files or a list of data frames.</p>
</td></tr>
<tr><td><code id="tidy_plates_+3A_how_many">how_many</code></td>
<td>
<p>A character vector specifying if metadata should be added to only a single plate or multiple plates.</p>
</td></tr>
<tr><td><code id="tidy_plates_+3A_user_prompt">user_prompt</code></td>
<td>
<p>Logical indicating whether adding metadata should be applied via user prompts. Only applied
if <code>user_prompt</code> is set to <code>TRUE</code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy_plates_+3A_multiple_structures">multiple_structures</code></td>
<td>
<p>Logical indicating whether adding metadata should be applied for each plate separately,
because plates have different metadata structures. Will be applied  via user prompts for each plate separately. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy_plates_+3A_direction">direction</code></td>
<td>
<p>A character vector specifying the orientation of the plate layout.
It can be either &quot;horizontal&quot; or &quot;vertical&quot;.</p>
</td></tr>
<tr><td><code id="tidy_plates_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code><a href="#topic+read_plates">read_plates</a></code>, <code><a href="#topic+tidy_single_plate">tidy_single_plate</a></code>,
<code><a href="#topic+tidy_plates_via_params">tidy_plates_via_params</a></code>, or <code><a href="#topic+tidy_plates_via_prompts">tidy_plates_via_prompts</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of cleaned data frames.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read_plates">read_plates</a></code>, <code><a href="#topic+tidy_plates_via_prompts">tidy_plates_via_prompts</a></code>, <code><a href="#topic+tidy_plates_via_params">tidy_plates_via_params</a></code>, <code><a href="#topic+tidy_single_plate">tidy_single_plate</a></code>
</p>

<hr>
<h2 id='tidy_plates_via_params'>Tidy multiple 96-well plates via parameters</h2><span id='topic+tidy_plates_via_params'></span>

<h3>Description</h3>

<p>This function processes raw plates data from photometer measurements, adds metadata via user-specified parameter values, and combines processed data into a single data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_plates_via_params(
  input_data,
  direction = c("horizontal", "vertical"),
  group_IDs = NULL,
  experiment_names = NULL,
  validity_method = c("threshold", "invalid"),
  threshold = NULL,
  invalid_samples = NULL,
  treatment_labels,
  concentration_levels,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tidy_plates_via_params_+3A_input_data">input_data</code></td>
<td>
<p>Either a folder path containing raw data files or a list of data frames.</p>
</td></tr>
<tr><td><code id="tidy_plates_via_params_+3A_direction">direction</code></td>
<td>
<p>A character vector specifying the orientation of the plate layout.
It can be either &quot;horizontal&quot; or &quot;vertical&quot;.</p>
</td></tr>
<tr><td><code id="tidy_plates_via_params_+3A_group_ids">group_IDs</code></td>
<td>
<p>A character vector providing group identifiers for each experiment.</p>
</td></tr>
<tr><td><code id="tidy_plates_via_params_+3A_experiment_names">experiment_names</code></td>
<td>
<p>A character vector providing names for each experiment. The hierarchy is group &gt; experiment, i.e.
within a single group, there might be several experiments taking place (e.g. multiple extracts from the same plant species
tested with plant species being the group and type of extract being the experiment).</p>
</td></tr>
<tr><td><code id="tidy_plates_via_params_+3A_validity_method">validity_method</code></td>
<td>
<p>A character vector specifying the method for determining cell validity. 
It can be either &quot;threshold&quot; (i.e. samples are validated based on a common absorption maximum) or &quot;samples&quot; (i.e. samples are manually specified as invalid).</p>
</td></tr>
<tr><td><code id="tidy_plates_via_params_+3A_threshold">threshold</code></td>
<td>
<p>A numeric threshold value. Applied if <code>validity_method</code> is set to 'threshold'.</p>
</td></tr>
<tr><td><code id="tidy_plates_via_params_+3A_invalid_samples">invalid_samples</code></td>
<td>
<p>A character vector containing well positions (e.g. &quot;A-3&quot;, &quot;B-8&quot;,...) of invalid samples. Applied if <code>validity_method</code> is set to 'samples'.</p>
</td></tr>
<tr><td><code id="tidy_plates_via_params_+3A_treatment_labels">treatment_labels</code></td>
<td>
<p>A character vector containing treatment labels.</p>
</td></tr>
<tr><td><code id="tidy_plates_via_params_+3A_concentration_levels">concentration_levels</code></td>
<td>
<p>A numeric vector containing concentration levels.</p>
</td></tr>
<tr><td><code id="tidy_plates_via_params_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code><a href="#topic+read_plates">read_plates</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function processes photometer data from multiple experiments and adds metadata based on user-set parameters if
the experimental layout is repeated across plates and should by synchronized. It supports two methods for 
determining cell validity: &quot;threshold&quot; and &quot;invalid&quot;. If &quot;threshold&quot; method is chosen, the validity of each cell
is determined based on a specified threshold value. If &quot;sample&quot; method is chosen, samples at specified well positions
on the plate are considered invalid. The function generates lists of treatments and concentration levels based on the
direction parameter, i.e. the direction of the treatments and concentration levels applied (either horizontally or
vertically on the plate). If the plate layout and, thus, the metadata changes across plates, then function
<code>tidy_plates_via_prompts</code> might be a better choice since it helps the user to add metadata for each plate separately
based on user prompts. If there is only one plate, where metadata should be added, then <code>tidy_single_plate</code> should be used.
</p>
<p>For all three functions, <code>tidy_single_plate</code>, <code>tidy_plates_via_params</code>, and <code>tidy_plates_via_prompts</code>, to work
properly, file names should provide a file identifier (i.e. &quot;bma&quot; in case there are additional but not relevant files in
the folder), a group identifier (i.e. starting with &quot;grp&quot; followed by an incrementing number), an identifier for 
experiments (starting with &quot;exp&quot; followed by a number, e.g. &quot;exp1&quot;) and an identifier for timepoints (starting with the
upper- or lower-case letter t followed by an incrementing number, e.g. &quot;T0&quot; or &quot;t0&quot;).
</p>


<h3>Value</h3>

<p>A tidy tibble containing combined data and metadata from all input plates.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tidy_single_plate">tidy_single_plate</a></code>, <code><a href="#topic+tidy_plates_via_prompts">tidy_plates_via_prompts</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load example data
data(bma)
# Add metadata from user parameters
bma_tidy &lt;- tidy_plates_via_params(input_data = bma,
                                   direction = "horizontal",
                                   group_IDs = paste0("Group_", letters[1:2]),
                                   experiment_names = c("Experiment 1", "Experiment 2"),
                                   validity_method = "threshold",
                                   threshold = 1,
                                   treatment_labels = LETTERS[1:8],
                                   concentration_levels = seq(from=80, to=10, length.out=8))
bma_tidy # View tidy data
</code></pre>

<hr>
<h2 id='tidy_plates_via_prompts'>Read raw photometry data and add meta data based on user input</h2><span id='topic+tidy_plates_via_prompts'></span>

<h3>Description</h3>

<p>Most old photometer devices save the data in plain text files. If there was ever analysis software, 
this is often no longer available due to increasing technical requirements or proprietary software 
should generally be avoided. Especially for broth microdilution assays, it is necessary to measure 
the photometer plates at several points in time, which means that the same samples are represented 
in several files with their corresponding values. Usually the data is then merged manually, which can 
lead to mistakes and takes up unnecessary time. In this case, the 'tidy_plates()' function provides a convenient 
way to read in the raw files and, based on user input, add metadata on the validity of the samples, 
as well as treatment groups and concentration levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_plates_via_prompts(
  input_data,
  direction = c("horizontal", "vertical"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tidy_plates_via_prompts_+3A_input_data">input_data</code></td>
<td>
<p>The folder path to the files containing the raw photometer data. Data files should 
be given as plain text files and with timepoint identifiers in their file names (e.g. &quot;file_T0.txt&quot; or 
&quot;file_t0.txt&quot;).</p>
</td></tr>
<tr><td><code id="tidy_plates_via_prompts_+3A_direction">direction</code></td>
<td>
<p>A character vector specifying the orientation of the plate layout.
It can be either &quot;horizontal&quot; or &quot;vertical&quot;.</p>
</td></tr>
<tr><td><code id="tidy_plates_via_prompts_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code><a href="#topic+read_plates">read_plates</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tidy data frame containing absorption values and meta data (validity of samples as well as 
treatment and concentration level information).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tidy_single_plate">tidy_single_plate</a></code>, <code><a href="#topic+tidy_plates_via_params">tidy_plates_via_params</a></code>
</p>

<hr>
<h2 id='tidy_single_plate'>Tidy single 96-well plate via parameters</h2><span id='topic+tidy_single_plate'></span>

<h3>Description</h3>

<p>This function processes a single raw 96-well plate data from a photometer measurement by adding metadata via user-specified parameter values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_single_plate(
  input_data,
  direction = c("horizontal", "vertical"),
  group_ID = NULL,
  experiment_name = NULL,
  validity_method = c("threshold", "invalid"),
  threshold = NULL,
  invalid_samples = NULL,
  treatment_labels,
  concentration_levels,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tidy_single_plate_+3A_input_data">input_data</code></td>
<td>
<p>Either a file path or a data frames with 8 rows and 12 columns.</p>
</td></tr>
<tr><td><code id="tidy_single_plate_+3A_direction">direction</code></td>
<td>
<p>A character vector specifying the orientation of the plate layout.
It can be either &quot;horizontal&quot; or &quot;vertical&quot;.</p>
</td></tr>
<tr><td><code id="tidy_single_plate_+3A_group_id">group_ID</code></td>
<td>
<p>A character vector providing group identifiers for each experiment.</p>
</td></tr>
<tr><td><code id="tidy_single_plate_+3A_experiment_name">experiment_name</code></td>
<td>
<p>A string providing the name of the experiment. The hierarchy is group &gt; experiment, i.e.
within a single group, there might be several experiments taking place (e.g. multiple extracts from the same plant species
tested with plant species being the group and type of extract being the experiment).</p>
</td></tr>
<tr><td><code id="tidy_single_plate_+3A_validity_method">validity_method</code></td>
<td>
<p>A character vector specifying the method for determining cell validity. 
It can be either &quot;threshold&quot; (i.e. samples are validated based on a common absorption maximum) or &quot;samples&quot; (i.e. samples are manually specified as invalid).</p>
</td></tr>
<tr><td><code id="tidy_single_plate_+3A_threshold">threshold</code></td>
<td>
<p>A numeric threshold value. Applied if <code>validity_method</code> is set to 'threshold'.</p>
</td></tr>
<tr><td><code id="tidy_single_plate_+3A_invalid_samples">invalid_samples</code></td>
<td>
<p>A character vector containing well positions (e.g. &quot;A-3&quot;, &quot;B-8&quot;,...) of invalid samples. Applied if <code>validity_method</code> is set to 'samples'.</p>
</td></tr>
<tr><td><code id="tidy_single_plate_+3A_treatment_labels">treatment_labels</code></td>
<td>
<p>A character vector containing treatment labels.</p>
</td></tr>
<tr><td><code id="tidy_single_plate_+3A_concentration_levels">concentration_levels</code></td>
<td>
<p>A numeric vector containing concentration levels.</p>
</td></tr>
<tr><td><code id="tidy_single_plate_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code><a href="#topic+read_plates">read_plates</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function processes photometer data from a single measurement and adds metadata based on user-set parameters.
It supports two methods for determining cell validity: &quot;threshold&quot; and &quot;invalid&quot;. If &quot;threshold&quot; method is chosen,
the validity of each cell is determined based on a specified threshold value. If &quot;sample&quot; method is chosen, samples
at specified well positions on the plate are considered invalid. The function generates lists of treatments and
concentration levels based on the direction parameter, i.e. the direction of the treatments and concentration levels
applied (either horizontally or vertically on the plate). To add metadata to several plates at the same time, the
functions <code>tidy_plates_via_params</code> and <code>tidy_plates_via_prompts</code> are recommended.
</p>
<p>For all three functions, <code>tidy_plate</code>, <code>tidy_plates_via_params</code>, and <code>tidy_plates_via_prompts</code>, to work
properly, file names should provide a file identifier (i.e. &quot;bma&quot; in
case there are additional but unused files in the folder), an identifier for experiments (starting with &quot;exp&quot; followed
by a number, e.g. &quot;exp1&quot;) and an identifier for timepoints (starting with the upper- or lower-case letter t followed
by a number, e.g. &quot;T0&quot; or &quot;t0&quot;).
</p>


<h3>Value</h3>

<p>A tidy tibble containing data and metadata.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tidy_plates_via_params">tidy_plates_via_params</a></code>, <code><a href="#topic+tidy_plates_via_prompts">tidy_plates_via_prompts</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load example data
data(bma)
# Add metadata from user parameters
bma_tidy &lt;- tidy_single_plate(input_data = bma[1],
                       direction = "horizontal",
                       group_ID = "Group A",
                       experiment_name = "Experiment 1",
                       validity_method = "threshold",
                       threshold = 1,
                       treatment_labels = LETTERS[1:8],
                       concentration_levels = seq(from=80, to=10, length.out=8))
bma_tidy # View tidy data
</code></pre>

<hr>
<h2 id='validate_cells'>Check validity of each cell in data frame.</h2><span id='topic+validate_cells'></span><span id='topic+apply_validation_method'></span><span id='topic+ask_validity_method'></span><span id='topic+ask_threshold'></span><span id='topic+ask_invalid_samples'></span><span id='topic+update_validity'></span>

<h3>Description</h3>

<p><code>validate_cells</code> checks if samples are valid based on either a user-set threshold (i.e.
a maximum absorption value) or a list of invalid samples provided by the user.
</p>
<p><code>apply_validation_method</code> evaluates whether a sample meets a user-set validity criteria based 
on a specified validity method.
</p>
<p><code>ask_validity_method</code> applies a user prompt to check for the validation method to apply
on the samples. This can be either 'threshold' (then a maximum absorption value is asked via a call to function
<code>ask_threshold</code>) or 'samples'
</p>
<p><code>ask_threshold</code> applies a user prompt to check for a valid absorption maximum used as a threshold.
</p>
<p><code>ask_invalid_samples</code> applies a user prompt to check for invalid samples.
</p>
<p><code>update_validity</code> updates the Validity column in a dataframe based on a specified position
and combinations of factors. It sets the Validity to &quot;invalid&quot; for rows where the Position
matches the specified position and where the combinations of factors A, B, and C match the
provided group levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_cells(
  raw_data,
  row_names,
  col_names,
  validity_method = c("threshold", "samples"),
  threshold = NULL,
  invalid_samples = NULL
)

apply_validation_method(
  value,
  i,
  j,
  row_names,
  col_names,
  validity_method = c("threshold", "samples"),
  threshold = NULL,
  invalid_samples = NULL
)

ask_validity_method()

ask_threshold()

ask_invalid_samples()

update_validity(
  input_data,
  wp_var = "Position",
  well_positions,
  group_levels = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_cells_+3A_raw_data">raw_data</code></td>
<td>
<p>The original data frame.</p>
</td></tr>
<tr><td><code id="validate_cells_+3A_row_names">row_names</code></td>
<td>
<p>Names or identifiers of rows in the matrix or data frame.</p>
</td></tr>
<tr><td><code id="validate_cells_+3A_col_names">col_names</code></td>
<td>
<p>Names or identifiers of columns in the matrix or data frame.</p>
</td></tr>
<tr><td><code id="validate_cells_+3A_validity_method">validity_method</code></td>
<td>
<p>The method used to determine validity. Either 'threshold' or 'samples'.</p>
</td></tr>
<tr><td><code id="validate_cells_+3A_threshold">threshold</code></td>
<td>
<p>A threshold value used for determining validity. Only applied if 'validity_method
is set to 'threshold'.</p>
</td></tr>
<tr><td><code id="validate_cells_+3A_invalid_samples">invalid_samples</code></td>
<td>
<p>A container for storing invalid samples or their indices. Only applied if 'validity_method
is set to 'samples'.</p>
</td></tr>
<tr><td><code id="validate_cells_+3A_value">value</code></td>
<td>
<p>The value to be checked for validity.</p>
</td></tr>
<tr><td><code id="validate_cells_+3A_i">i</code></td>
<td>
<p>The row index of the value in the matrix or data frame.</p>
</td></tr>
<tr><td><code id="validate_cells_+3A_j">j</code></td>
<td>
<p>The column index of the value in the matrix or data frame.</p>
</td></tr>
<tr><td><code id="validate_cells_+3A_input_data">input_data</code></td>
<td>
<p>A dataframe containing the data to be updated.</p>
</td></tr>
<tr><td><code id="validate_cells_+3A_wp_var">wp_var</code></td>
<td>
<p>A character string specifying the column providing the well positions. Defaults to
&quot;Position&quot;.</p>
</td></tr>
<tr><td><code id="validate_cells_+3A_well_positions">well_positions</code></td>
<td>
<p>The well positions to filter the data on.</p>
</td></tr>
<tr><td><code id="validate_cells_+3A_group_levels">group_levels</code></td>
<td>
<p>A list specifying the combinations of factors A, B, and C to match.
Each element of the list should be a vector of factor levels.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>validate_cells</code> returns a data frame with validity information
</p>
<p><code>apply_validation_method</code> returns logical value indicating whether the value meets the validity criteria.
</p>
<p>The user's validity method preference
</p>
<p><code>ask_threshold</code> returns the user-specified threshold
</p>
<p><code>ask_invalid_samples</code> returns a vector of invalid samples
</p>
<p><code>update_validity</code> returns the updated dataframe with Validity modified accordingly.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+generate_experiment_list">generate_experiment_list</a></code>, <code><a href="#topic+ask_experiment_list">ask_experiment_list</a></code>,
<code><a href="#topic+generate_group_list">generate_group_list</a></code>, <code><a href="#topic+ask_group_list">ask_group_list</a></code>,
<code><a href="#topic+add_treatment">add_treatment</a></code>, <code><a href="#topic+add_concentration">add_concentration</a></code>, <code><a href="#topic+validate_cells">validate_cells</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(Position = c("pos1", "pos2", "pos2", "pos4", "pos4"),
                 Value = c(1, 2, 3, 4, 5),
                 Validity = c("valid", "valid", "valid", "valid", "valid"),
                 A = c("a1", "a2", "a3", "a1", "a2"),
                 B = c("b1", "b2", "b3", "b1", "b2"),
                 C = c("c1", "c2", "c3", "c1", "c2"))
updated_df &lt;- update_validity(df,
                              well_positions = "pos2",
                              group_levels = list(A = c("a2", "a3"), B = c("b2", "b3")))
updated_df
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
