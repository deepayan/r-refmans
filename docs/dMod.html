<!DOCTYPE html><html><head><title>Help for package dMod</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dMod}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#*.fn'><p>Concatenation of functions</p></a></li>
<li><a href='#%.*%'><p>Multiplication of objective functions with scalars</p></a></li>
<li><a href='#+.datalist'><p>Direct sum of datasets</p></a></li>
<li><a href='#+.fn'><p>Direct sum of functions</p></a></li>
<li><a href='#+.objfn'><p>Direct sum of objective functions</p></a></li>
<li><a href='#+.objlist'><p>Add two lists element by element</p></a></li>
<li><a href='#addReaction'><p>Add reaction to reaction table</p></a></li>
<li><a href='#as.data.frame.datalist'><p>Coerce to a Data Frame</p></a></li>
<li><a href='#as.data.frame.eqnlist'><p>Coerce equation list into a data frame</p></a></li>
<li><a href='#as.eqnvec'><p>Coerce to an equation vector</p></a></li>
<li><a href='#as.eventlist'><p>Coerce to eventlist</p></a></li>
<li><a href='#as.objlist'><p>Generate objective list from numeric vector</p></a></li>
<li><a href='#as.parframe.parlist'><p>Coerce object to a parameter frame</p></a></li>
<li><a href='#as.parvec.parframe'><p>Select a parameter vector from a parameter frame.</p></a></li>
<li><a href='#attrs'><p>Select attributes.</p></a></li>
<li><a href='#blockdiagSymb'><p>Embed two matrices into one blockdiagonal matrix</p></a></li>
<li><a href='#combine'><p>Combine several data.frames by rowbind</p></a></li>
<li><a href='#compare'><p>Compare two objects and return differences</p></a></li>
<li><a href='#compile'><p>Compile one or more prdfn, obsfn or parfn objects</p></a></li>
<li><a href='#confint.parframe'><p>Profile uncertainty extraction</p></a></li>
<li><a href='#conservedQuantities'><p>Determine conserved quantites by finding the kernel of the stoichiometric</p>
matrix</a></li>
<li><a href='#constraintExp2'><p>Compute a differentiable box prior</p></a></li>
<li><a href='#constraintL2'><p>Soft L2 constraint on parameters</p></a></li>
<li><a href='#controls'><p>List, get and set controls for different functions</p></a></li>
<li><a href='#coordTransform'><p>Coordinate transformation for data frames</p></a></li>
<li><a href='#covariates'><p>Access the covariates in the data</p></a></li>
<li><a href='#datalist'><p>Generate a datalist object</p></a></li>
<li><a href='#datapointL2'><p>L2 objective function for validation data point</p></a></li>
<li><a href='#define'><p>Define parameter transformations by <code>define()</code>, <code>branch()</code> and <code>insert()</code></p></a></li>
<li><a href='#dot'><p>Symbolic time derivative of equation vector given an equation list</p></a></li>
<li><a href='#eqnlist'><p>Generate eqnlist object</p></a></li>
<li><a href='#eqnvec'><p>Generate equation vector object</p></a></li>
<li><a href='#eventlist'><p>Eventlist</p></a></li>
<li><a href='#expand.grid.alt'><p>Alternative version of expand.grid</p></a></li>
<li><a href='#fitErrorModel'><p>Fit an error model</p></a></li>
<li><a href='#forcingsSymb'><p>Return some useful forcing functions as strings</p></a></li>
<li><a href='#format.eqnvec'><p>Encode equation vector in format with sufficient spaces</p></a></li>
<li><a href='#funC0'><p>Evaluation of algebraic expressions defined by characters</p></a></li>
<li><a href='#getCoefficients'><p>Get coefficients from a character</p></a></li>
<li><a href='#getConditions'><p>Extract the conditions of an object</p></a></li>
<li><a href='#getDerivs'><p>Extract the derivatives of an object</p></a></li>
<li><a href='#getEquations'><p>Extract the equations of an object</p></a></li>
<li><a href='#getFluxes'><p>Generate list of fluxes from equation list</p></a></li>
<li><a href='#getLocalDLLs'><p>Determine loaded DLLs available in working directory</p></a></li>
<li><a href='#getObservables'><p>Extract the observables of an object</p></a></li>
<li><a href='#getParameters'><p>Extract the parameters of an object</p></a></li>
<li><a href='#getReactions'><p>Generate a table of reactions (data.frame) from an equation list</p></a></li>
<li><a href='#ggopen'><p>Open last plot in external pdf viewer</p></a></li>
<li><a href='#Id'><p>An identity function which vanishes upon concatenation of fns</p></a></li>
<li><a href='#jakstat'><p>Time-course data for the JAK-STAT cell signaling pathway</p></a></li>
<li><a href='#lbind'><p>Bind named list of data.frames into one data.frame</p></a></li>
<li><a href='#load.parlist'><p>Construct fitlist from temporary files.</p></a></li>
<li><a href='#loadDLL'><p>Load shared object for a dMod object</p></a></li>
<li><a href='#long2wide'><p>Translate long to wide format (inverse of wide2long.matrix)</p></a></li>
<li><a href='#lsdMod'><p>Print list of dMod objects in .GlobalEnv</p></a></li>
<li><a href='#match.fnargs'><p>dMod match function arguments</p></a></li>
<li><a href='#mname'><p>Get modelname from single object (used internally)</p></a></li>
<li><a href='#modelname'><p>Get and set modelname</p></a></li>
<li><a href='#msParframe'><p>Reproducibly construct &quot;random&quot; parframes</p></a></li>
<li><a href='#mstrust'><p>Non-Linear Optimization, multi start</p></a></li>
<li><a href='#nll'><p>Compute the negative log-likelihood</p></a></li>
<li><a href='#normL2'><p>L2 norm between data and model prediction</p></a></li>
<li><a href='#nullZ'><p>Find integer-null space of matrix A</p></a></li>
<li><a href='#objframe'><p>Objective frame</p></a></li>
<li><a href='#objlist'><p>Generate objective list</p></a></li>
<li><a href='#obsfn'><p>Observation function</p></a></li>
<li><a href='#odemodel'><p>Generate the model objects for use in Xs (models with sensitivities)</p></a></li>
<li><a href='#P'><p>Generate a parameter transformation function</p></a></li>
<li><a href='#parfn'><p>Parameter transformation function</p></a></li>
<li><a href='#parframe'><p>Generate a parameter frame</p></a></li>
<li><a href='#parlist'><p>Parameter list</p></a></li>
<li><a href='#parvec'><p>Parameter vector</p></a></li>
<li><a href='#Pexpl'><p>Parameter transformation</p></a></li>
<li><a href='#Pimpl'><p>Parameter transformation (implicit)</p></a></li>
<li><a href='#plot.datalist'><p>Plot a list data points</p></a></li>
<li><a href='#plot.parlist'><p>Plot a parameter list.</p></a></li>
<li><a href='#plotCombined'><p>Plot a list of model predictions and a list of data points in a combined plot</p></a></li>
<li><a href='#plotData.datalist'><p>Plot a list data points</p></a></li>
<li><a href='#plotFluxes'><p>Plot Fluxes given a list of flux Equations</p></a></li>
<li><a href='#plotPars.parframe'><p>Plot parameter values for a fitlist</p></a></li>
<li><a href='#plotPaths'><p>Profile likelihood: plot of the parameter paths.</p></a></li>
<li><a href='#plotPrediction'><p>Plot a list of model predictions</p></a></li>
<li><a href='#plotProfile.parframe'><p>Profile likelihood plot</p></a></li>
<li><a href='#plotResiduals'><p>Plot residuals for a fitlist</p></a></li>
<li><a href='#plotValues.parframe'><p>Plotting objective values of a collection of fits</p></a></li>
<li><a href='#prdfn'><p>Prediction function</p></a></li>
<li><a href='#prdframe'><p>Prediction frame</p></a></li>
<li><a href='#prdlist'><p>Prediction list</p></a></li>
<li><a href='#predict.prdfn'><p>Model Predictions</p></a></li>
<li><a href='#print.eqnlist'><p>Print or pander equation list</p></a></li>
<li><a href='#print.eqnvec'><p>Print equation vector</p></a></li>
<li><a href='#print.parfn'><p>Pretty printing parameter transformations</p></a></li>
<li><a href='#print.parvec'><p>Pretty printing for a parameter vector</p></a></li>
<li><a href='#print0'><p>Print object and its &quot;default&quot; attributes only.</p></a></li>
<li><a href='#priorL2'><p>L2 objective function for prior value</p></a></li>
<li><a href='#profile'><p>Profile-likelihood (PL) computation</p></a></li>
<li><a href='#progressBar'><p>Progress bar</p></a></li>
<li><a href='#reduceReplicates'><p>Reduce replicated measurements to mean and standard deviation</p></a></li>
<li><a href='#repar'><p>Reparameterization</p></a></li>
<li><a href='#res'><p>Compare data and model prediction by computing residuals</p></a></li>
<li><a href='#resolveRecurrence'><p>Place top elements into bottom elemens</p></a></li>
<li><a href='#rref'><p>Transform matrix A into reduced row echelon form</p>
this function is written along the lines of the rref-matlab function.</a></li>
<li><a href='#scale_color_dMod'><p>Standard dMod color palette</p></a></li>
<li><a href='#scale_fill_dMod'><p>Standard dMod color scheme</p></a></li>
<li><a href='#stat.parlist'><p>Gather statistics of a fitlist</p></a></li>
<li><a href='#steadyStates'><p>Calculate analytical steady states.</p></a></li>
<li><a href='#strelide'><p>Elide character vector</p></a></li>
<li><a href='#strpad'><p>Pad string to desired width</p></a></li>
<li><a href='#submatrix'><p>Submatrix of a matrix returning ALWAYS a matrix</p></a></li>
<li><a href='#subset.eqnlist'><p>subset of an equation list</p></a></li>
<li><a href='#summary.eqnvec'><p>Summary of an equation vector</p></a></li>
<li><a href='#symmetryDetection'><p>Search for symmetries in the loaded model</p></a></li>
<li><a href='#theme_dMod'><p>Standard plotting theme of dMod</p></a></li>
<li><a href='#trust'><p>Non-Linear Optimization</p></a></li>
<li><a href='#unique.parframe'><p>Extract those lines of a parameter frame with unique elements in the value column</p></a></li>
<li><a href='#wide2long'><p>Translate wide output format (e.g. from ode) into long format</p></a></li>
<li><a href='#wide2long.data.frame'><p>Translate wide output format (e.g. from ode) into long format</p></a></li>
<li><a href='#wide2long.list'><p>Translate wide output format (e.g. from ode) into long format</p></a></li>
<li><a href='#wide2long.matrix'><p>Translate wide output format (e.g. from ode) into long format</p></a></li>
<li><a href='#write.eqnlist'><p>Write equation list into a csv file</p></a></li>
<li><a href='#wrss'><p>Compute the weighted residual sum of squares</p></a></li>
<li><a href='#Xd'><p>Model prediction function from data.frame</p></a></li>
<li><a href='#Xf'><p>Model prediction function for ODE models without sensitivities.</p></a></li>
<li><a href='#Xs'><p>Model prediction function for ODE models.</p></a></li>
<li><a href='#Xt'><p>Generate a prediction function that returns times</p></a></li>
<li><a href='#Y'><p>Observation functions.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Dynamic Modeling and Parameter Estimation in ODE Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-01-25</td>
</tr>
<tr>
<td>Author:</td>
<td>Daniel Kaschek</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Daniel Kaschek &lt;daniel.kaschek@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The framework provides functions to generate ODEs of reaction
    networks, parameter transformations, observation functions, residual functions,
    etc. The framework follows the paradigm that derivative information should be
    used for optimization whenever possible. Therefore, all major functions produce
    and can handle expressions for symbolic derivatives. The methods used in dMod
    were published in Kaschek et al, 2019, &lt;<a href="https://doi.org/10.18637%2Fjss.v088.i10">doi:10.18637/jss.v088.i10</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>cOde (&ge; 1.0),</td>
</tr>
<tr>
<td>Imports:</td>
<td>deSolve, rootSolve, ggplot2, parallel, stringr, plyr, dplyr,
foreach, doParallel</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MASS, reticulate, pander, knitr, rmarkdown</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.0.2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-01-26 21:30:28 UTC; kaschek</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-01-27 00:30:13 UTC</td>
</tr>
</table>
<hr>
<h2 id='+2A.fn'>Concatenation of functions</h2><span id='topic++2A.fn'></span><span id='topic+prodfn'></span>

<h3>Description</h3>

<p>Used to concatenate observation functions, prediction functions and parameter transformation functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fn'
p1 * p2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B2A.fn_+3A_p1">p1</code></td>
<td>
<p>function of class <code>obsfn</code>, <code>prdfn</code>, <code>parfn</code> or <code>idfn</code></p>
</td></tr>
<tr><td><code id="+2B2A.fn_+3A_p2">p2</code></td>
<td>
<p>function of class <code>obsfn</code>, <code>prdfn</code>, <code>parfn</code> or <code>idfn</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of the same class as <code>x1</code> and <code>x2</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define a time grid on which to make a prediction by peace-wise linear function.
# Then define a (generic) prediction function based on thid grid.
times &lt;- 0:5
grid &lt;- data.frame(name = "A", time = times, row.names = paste0("p", times))
x &lt;- Xd(grid)

# Define an observable and an observation function
observables &lt;- eqnvec(Aobs = "s*A")
g &lt;- Y(g = observables, f = NULL, states = "A", parameters = "s")

# Collect parameters and define an overarching parameter transformation
# for two "experimental condtions".
dynpars &lt;- attr(x, "parameters")
obspars &lt;- attr(g, "parameters")
innerpars &lt;- c(dynpars, obspars)

trafo &lt;- structure(innerpars, names = innerpars)
trafo_C1 &lt;- replaceSymbols(innerpars, paste(innerpars, "C1", sep = "_"), trafo)
trafo_C2 &lt;- replaceSymbols(innerpars, paste(innerpars, "C2", sep = "_"), trafo)

p &lt;- NULL
p &lt;- p + P(trafo = trafo_C1, condition = "C1")
p &lt;- p + P(trafo = trafo_C2, condition = "C2")

# Collect outer (overarching) parameters and 
# initialize with random values
outerpars &lt;- attr(p, "parameters")
pars &lt;- structure(runif(length(outerpars), 0, 1), names = outerpars)

# Predict internal/unobserved states
out1 &lt;- (x*p)(times, pars)
plot(out1)

# Predict observed states in addition to unobserved
out2 &lt;- (g*x*p)(times, pars)
plot(out2)
</code></pre>

<hr>
<h2 id='+25.+2A+25'>Multiplication of objective functions with scalars</h2><span id='topic++25.+2A+25'></span>

<h3>Description</h3>

<p>The <code>%.*%</code> operator allows to multiply objects of class objlist or objfn with
a scalar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x1 %.*% x2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25.+2B2A+2B25_+3A_x1">x1</code></td>
<td>
<p>object of class objfn or objlist.</p>
</td></tr>
<tr><td><code id="+2B25.+2B2A+2B25_+3A_x2">x2</code></td>
<td>
<p>numeric of length one.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An objective function or objlist object.
</p>

<hr>
<h2 id='+2B.datalist'>Direct sum of datasets</h2><span id='topic++2B.datalist'></span><span id='topic+sumdatalist'></span>

<h3>Description</h3>

<p>Used to merge datasets with overlapping conditions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'datalist'
data1 + data2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B2B.datalist_+3A_data1">data1</code></td>
<td>
<p>dataset of class <code>datalist</code></p>
</td></tr>
<tr><td><code id="+2B2B.datalist_+3A_data2">data2</code></td>
<td>
<p>dataset of class <code>datalist</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each data list contains data frames for a number of conditions.
The direct sum of datalist is meant as merging the two data lists and
returning the overarching datalist.
</p>


<h3>Value</h3>

<p>Object of class <code>datalist</code> for the
union of conditions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
  # Start with two data frames
  mydata1 &lt;- data.frame(
    name = "A",
    time = 0:1,
    value = 1:2,
    sigma = .1,
    compound = c("DEM", "APAP"),
    dose = "0.1"
  )
  
  mydata2 &lt;- data.frame(
    name = "A",
    time = 0:1,
    value = 3:4,
    sigma = .1,
    compound = c("APAP", "DCF"),
    dose = "0.1"
  )
 
  # Create datalists from dataframes
  data1 &lt;- as.datalist(mydata1, split.by = c("compound", "dose")) 
  data2 &lt;- as.datalist(mydata2, split.by = c("compound", "dose")) 
  
  # Direct sum of datalists
   data &lt;- data1 + data2
   print(data)
  
  # Check the condition.grid (if available)
   condition.grid &lt;- attr(data, "condition.grid")
   print(condition.grid)

</code></pre>

<hr>
<h2 id='+2B.fn'>Direct sum of functions</h2><span id='topic++2B.fn'></span><span id='topic+sumfn'></span>

<h3>Description</h3>

<p>Used to add prediction function, parameter transformation functions or observation functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fn'
x1 + x2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B2B.fn_+3A_x1">x1</code></td>
<td>
<p>function of class <code>obsfn</code>, <code>prdfn</code> or <code>parfn</code></p>
</td></tr>
<tr><td><code id="+2B2B.fn_+3A_x2">x2</code></td>
<td>
<p>function of class <code>obsfn</code>, <code>prdfn</code> or <code>parfn</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each prediction function is associated to a number of conditions. Adding functions
means merging or overwriting the set of conditions.
</p>


<h3>Value</h3>

<p>Object of the same class as <code>x1</code> and <code>x2</code> which returns results for the
union of conditions.
</p>


<h3>See Also</h3>

<p><a href="#topic+P">P</a>, <a href="#topic+Y">Y</a>, <a href="#topic+Xs">Xs</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define a time grid on which to make a prediction by peace-wise linear function.
# Then define a (generic) prediction function based on thid grid.
times &lt;- 0:5
grid &lt;- data.frame(name = "A", time = times, row.names = paste0("p", times))
x &lt;- Xd(grid)

# Define an observable and an observation function
observables &lt;- eqnvec(Aobs = "s*A")
g &lt;- Y(g = observables, f = NULL, states = "A", parameters = "s")

# Collect parameters and define an overarching parameter transformation
# for two "experimental condtions".
dynpars &lt;- attr(x, "parameters")
obspars &lt;- attr(g, "parameters")
innerpars &lt;- c(dynpars, obspars)

trafo &lt;- structure(innerpars, names = innerpars)
trafo_C1 &lt;- replaceSymbols(innerpars, paste(innerpars, "C1", sep = "_"), trafo)
trafo_C2 &lt;- replaceSymbols(innerpars, paste(innerpars, "C2", sep = "_"), trafo)

p &lt;- NULL
p &lt;- p + P(trafo = trafo_C1, condition = "C1")
p &lt;- p + P(trafo = trafo_C2, condition = "C2")

# Collect outer (overarching) parameters and 
# initialize with random values
outerpars &lt;- attr(p, "parameters")
pars &lt;- structure(runif(length(outerpars), 0, 1), names = outerpars)

# Predict internal/unobserved states
out1 &lt;- (x*p)(times, pars)
plot(out1)

# Predict observed states in addition to unobserved
out2 &lt;- (g*x*p)(times, pars)
plot(out2)
</code></pre>

<hr>
<h2 id='+2B.objfn'>Direct sum of objective functions</h2><span id='topic++2B.objfn'></span><span id='topic+sumobjfn'></span>

<h3>Description</h3>

<p>Direct sum of objective functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'objfn'
x1 + x2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B2B.objfn_+3A_x1">x1</code></td>
<td>
<p>function of class <code>objfn</code></p>
</td></tr>
<tr><td><code id="+2B2B.objfn_+3A_x2">x2</code></td>
<td>
<p>function of class <code>objfn</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The objective functions are evaluated and their results as added. Sometimes,
the evaluation of an objective function depends on results that have been computed
internally in a preceding objective function. Therefore, environments are forwarded
and all evaluations take place in the same environment. The first objective function
in a sum of functions generates a new environment.
</p>


<h3>Value</h3>

<p>Object of class <code>objfn</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+normL2">normL2</a>, <a href="#topic+constraintL2">constraintL2</a>, <a href="#topic+priorL2">priorL2</a>, <a href="#topic+datapointL2">datapointL2</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Generate three objective functions
  prior &lt;- structure(rep(0, 5), names = letters[1:5])
  
  obj1 &lt;- constraintL2(mu = prior, attr.name = "center")
  obj2 &lt;- constraintL2(mu = prior + 1, attr.name = "right")
  obj3 &lt;- constraintL2(mu = prior - 1, attr.name = "left")
  
  ## Evaluate first objective function on a random vector
  pouter &lt;- prior + rnorm(length(prior))
  print(obj1(pouter))
  
  ## Split into fixed and non-fixed part
  fixed &lt;- pouter[4:5]
  pouter &lt;- pouter[1:3]
  print(obj1(pouter, fixed = fixed))
  
  
  ## Visualize the result by a parameter profile
  myfit &lt;- trust(obj1, pouter, rinit = 1, rmax = 10, fixed = fixed)
  myprof &lt;- profile(obj1, myfit$argument, "a", fixed = fixed)
  plotProfile(myprof)
  
  
  ## Create new objective function by adding the single ones,
  ## then evalue the random vector again
  pouter &lt;- prior + rnorm(length(prior))
  obj &lt;- obj1 + obj2 + obj3
  print(obj(pouter))
</code></pre>

<hr>
<h2 id='+2B.objlist'>Add two lists element by element</h2><span id='topic++2B.objlist'></span><span id='topic+sumobjlist'></span>

<h3>Description</h3>

<p>Add two lists element by element
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'objlist'
out1 + out2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B2B.objlist_+3A_out1">out1</code></td>
<td>
<p>List of numerics or matrices</p>
</td></tr>
<tr><td><code id="+2B2B.objlist_+3A_out2">out2</code></td>
<td>
<p>List with the same structure as out1 (there will be no warning when mismatching)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If out1 has names, out2 is assumed to share these names. Each element of the list out1
is inspected. If it has a <code>names</code> attributed, it is used to do a matching between out1 and out2.
The same holds for the attributed <code>dimnames</code>. In all other cases, the &quot;+&quot; operator is applied
the corresponding elements of out1 and out2 as they are.
</p>


<h3>Value</h3>

<p>List of length of out1.
</p>

<hr>
<h2 id='addReaction'>Add reaction to reaction table</h2><span id='topic+addReaction'></span>

<h3>Description</h3>

<p>Add reaction to reaction table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addReaction(eqnlist, from, to, rate, description = names(rate))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addReaction_+3A_eqnlist">eqnlist</code></td>
<td>
<p>equation list, see <a href="#topic+eqnlist">eqnlist</a></p>
</td></tr>
<tr><td><code id="addReaction_+3A_from">from</code></td>
<td>
<p>character with the left hand side of the reaction, e.g. &quot;2*A + B&quot;</p>
</td></tr>
<tr><td><code id="addReaction_+3A_to">to</code></td>
<td>
<p>character with the right hand side of the reaction, e.g. &quot;C + 2*D&quot;</p>
</td></tr>
<tr><td><code id="addReaction_+3A_rate">rate</code></td>
<td>
<p>character. The rate associated with the reaction. The name is employed as a description
of the reaction.</p>
</td></tr>
<tr><td><code id="addReaction_+3A_description">description</code></td>
<td>
<p>Optional description instead of <code>names(rate)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <a href="#topic+eqnlist">eqnlist</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- eqnlist()
f &lt;- addReaction(f, "2*A+B", "C + 2*D", "k1*B*A^2")
f &lt;- addReaction(f, "C + A", "B + A", "k2*C*A")



  # Write your example here. You can also add more Start..End blocks if needed.
  # Please mask all output such as print() with the special tag
  #    
  # such that the test is not littered. Statements guarded by  are enabled
  # in the example file which is extracted from this test file. To extract the
  # example run
  #    extractExamples()
  # on the R command line.
    
    ## Generate another equation list
    eq &lt;- eqnlist()
    eq &lt;- addReaction(eq, "A", "pA", "act_A * A * stimulus", "Phosphorylation of A")
    eq &lt;- addReaction(eq, "pA", "A", "deact_A * pA", "Deposphorylation of pA")
    eq &lt;- addReaction(eq, "2*pA", "pA_pA", "form_complex_pA * pA^2", "Complex formation of pA")
    eq &lt;- addReaction(eq, "B", "pB", "act_B * B * pA_pA", "Phosphorylation of B")
    eq &lt;- addReaction(eq, "pB", "B", "deact_B * pB", "Deposphorylation of pB")
    
    ## Extract data.frame of reactions
    reactions &lt;- getReactions(eq)
     print(reactions)
    
    ## Get conserved quantities
    cq &lt;- conservedQuantities(eq$smatrix)
     print(cq)
    
    ## Get fluxes
    fluxes &lt;- getFluxes(eq)
     print(fluxes)
    
    ## Subsetting of equation list
    subeq1 &lt;- subset(eq, "pB" %in% Product)
     print(subeq1)
    subeq2 &lt;- subset(eq, grepl("not_available", Description))
     print(subeq2)
    
    ## Time derivatives of observables
    observables &lt;- eqnvec(pA_obs = "s1*pA", tA_obs = "s2*(A + pA)")
    dobs &lt;- dot(observables, eq)
    
    ## Combined equation vector for ODE and observables
    f &lt;- c(as.eqnvec(eq), dobs)
     print(f)
    
    
  
</code></pre>

<hr>
<h2 id='as.data.frame.datalist'>Coerce to a Data Frame</h2><span id='topic+as.data.frame.datalist'></span><span id='topic+as.data.frame.prdlist'></span>

<h3>Description</h3>

<p>Coerce to a Data Frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'datalist'
as.data.frame(x, ...)

## S3 method for class 'prdlist'
as.data.frame(x, ..., data = NULL, errfn = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.datalist_+3A_x">x</code></td>
<td>
<p>any R object</p>
</td></tr>
<tr><td><code id="as.data.frame.datalist_+3A_...">...</code></td>
<td>
<p>not used right now</p>
</td></tr>
<tr><td><code id="as.data.frame.datalist_+3A_data">data</code></td>
<td>
<p>data list oject</p>
</td></tr>
<tr><td><code id="as.data.frame.datalist_+3A_errfn">errfn</code></td>
<td>
<p>obsfn object, the error model function to predict sigma</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame
</p>

<hr>
<h2 id='as.data.frame.eqnlist'>Coerce equation list into a data frame</h2><span id='topic+as.data.frame.eqnlist'></span>

<h3>Description</h3>

<p>Coerce equation list into a data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'eqnlist'
as.data.frame(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.eqnlist_+3A_x">x</code></td>
<td>
<p>object of class <a href="#topic+eqnlist">eqnlist</a></p>
</td></tr>
<tr><td><code id="as.data.frame.eqnlist_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.frame</code> with columns &quot;Description&quot; (character), 
&quot;Rate&quot; (character), and one column per ODE state with the state names. 
The state columns correspond to the stoichiometric matrix.
</p>

<hr>
<h2 id='as.eqnvec'>Coerce to an equation vector</h2><span id='topic+as.eqnvec'></span><span id='topic+as.eqnvec.character'></span><span id='topic+as.eqnvec.eqnlist'></span>

<h3>Description</h3>

<p>An equation list stores an ODE in a list format. The function
translates this list into the right-hand sides of the ODE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.eqnvec(x, ...)

## S3 method for class 'character'
as.eqnvec(x = NULL, names = NULL, ...)

## S3 method for class 'eqnlist'
as.eqnvec(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.eqnvec_+3A_x">x</code></td>
<td>
<p>object of class <code>character</code> or <code>eqnlist</code></p>
</td></tr>
<tr><td><code id="as.eqnvec_+3A_...">...</code></td>
<td>
<p>arguments going to the corresponding methods</p>
</td></tr>
<tr><td><code id="as.eqnvec_+3A_names">names</code></td>
<td>
<p>character, the left-hand sides of the equation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> is of class <code>eqnlist</code>, <a href="#topic+getFluxes">getFluxes</a> is called and coerced
into a vector of equations.
</p>


<h3>Value</h3>

<p>object of class <a href="#topic+eqnvec">eqnvec</a>.
</p>

<hr>
<h2 id='as.eventlist'>Coerce to eventlist</h2><span id='topic+as.eventlist'></span><span id='topic+as.eventlist.list'></span><span id='topic+as.eventlist.data.frame'></span>

<h3>Description</h3>

<p>Coerce to eventlist
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.eventlist(x, ...)

## S3 method for class 'list'
as.eventlist(x, ...)

## S3 method for class 'data.frame'
as.eventlist(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.eventlist_+3A_x">x</code></td>
<td>
<p>list, data.frame</p>
</td></tr>
<tr><td><code id="as.eventlist_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>

<hr>
<h2 id='as.objlist'>Generate objective list from numeric vector</h2><span id='topic+as.objlist'></span>

<h3>Description</h3>

<p>Generate objective list from numeric vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.objlist(p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.objlist_+3A_p">p</code></td>
<td>
<p>Named numeric vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with entries value (<code>0</code>), 
gradient (<code>rep(0, length(p))</code>) and 
hessian (<code>matrix(0, length(p), length(p))</code>) of class <code>obj</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- c(A = 1, B = 2)
as.objlist(p)
</code></pre>

<hr>
<h2 id='as.parframe.parlist'>Coerce object to a parameter frame</h2><span id='topic+as.parframe.parlist'></span><span id='topic+as.parframe'></span>

<h3>Description</h3>

<p>Coerce object to a parameter frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'parlist'
as.parframe(x, sort.by = "value", ...)

as.parframe(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.parframe.parlist_+3A_x">x</code></td>
<td>
<p>object to be coerced</p>
</td></tr>
<tr><td><code id="as.parframe.parlist_+3A_sort.by">sort.by</code></td>
<td>
<p>character indicating by which colum the returned parameter frame
should be sorted. Defaults to <code>"value"</code>.</p>
</td></tr>
<tr><td><code id="as.parframe.parlist_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class <a href="#topic+parframe">parframe</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate a prediction function
regfn &lt;- c(y = "sin(a*time)")

g &lt;- Y(regfn, parameters = "a")
x &lt;- Xt(condition = "C1")

## Generate data
data &lt;- datalist(
  C1 = data.frame(
    name = "y",
    time = 1:5,
    value = sin(1:5) + rnorm(5, 0, .1),
    sigma = .1
  )
)

## Initialize parameters and time 
pars &lt;- c(a = 1)
times &lt;- seq(0, 5, .1)

plot((g*x)(times, pars), data)

## Do many fits from random positions and store them into parlist
out &lt;- as.parlist(lapply(1:50, function(i) {
  trust(normL2(data, g*x), pars + rnorm(length(pars), 0, 1), rinit = 1, rmax = 10)
}))

summary(out)

## Reduce parlist to parframe
parframe &lt;- as.parframe(out)
plotValues(parframe)

## Reduce parframe to best fit
bestfit &lt;- as.parvec(parframe)
plot((g*x)(times, bestfit), data)


</code></pre>

<hr>
<h2 id='as.parvec.parframe'>Select a parameter vector from a parameter frame.</h2><span id='topic+as.parvec.parframe'></span>

<h3>Description</h3>

<p>Obtain a parameter vector from a parameter frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'parframe'
as.parvec(x, index = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.parvec.parframe_+3A_x">x</code></td>
<td>
<p>A parameter frame, e.g., the output of
<code><a href="#topic+as.parframe">as.parframe</a></code>.</p>
</td></tr>
<tr><td><code id="as.parvec.parframe_+3A_index">index</code></td>
<td>
<p>Integer, the parameter vector with the <code>index</code>-th lowest
objective value.</p>
</td></tr>
<tr><td><code id="as.parvec.parframe_+3A_...">...</code></td>
<td>
<p>not used right now</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With this command, additional information included in the parameter
frame as the objective value and the convergence state are removed and a
parameter vector is returned. This parameter vector can be used to e.g.,
evaluate an objective function.
</p>
<p>On selection, the parameters in the parameter frame are ordered such, that
the parameter vector with the lowest objective value is at <span class="option">index</span>
1. Thus, the parameter vector with the <span class="option">index</span>-th lowest objective
value is easily obtained.
</p>


<h3>Value</h3>

<p>The parameter vector with the <span class="option">index</span>-th lowest objective
value.
</p>


<h3>Author(s)</h3>

<p>Wolfgang Mader, <a href="mailto:Wolfgang.Mader@fdm.uni-freiburg.de">Wolfgang.Mader@fdm.uni-freiburg.de</a>
</p>

<hr>
<h2 id='attrs'>Select attributes.</h2><span id='topic+attrs'></span>

<h3>Description</h3>

<p>Select or discard attributes from an object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>attrs(x, atr = NULL, keep = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="attrs_+3A_x">x</code></td>
<td>
<p>The object to work on</p>
</td></tr>
<tr><td><code id="attrs_+3A_atr">atr</code></td>
<td>
<p>An optional list of attributes which are either kept or removed. 
This parameter defaults to dim, dimnames, names,  col.names, and row.names.</p>
</td></tr>
<tr><td><code id="attrs_+3A_keep">keep</code></td>
<td>
<p>For keep = TRUE, atr is a positive list on attributes which are 
kept, for keep = FALSE, <span class="option">atr</span> are removed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x with selected attributes.
</p>


<h3>Author(s)</h3>

<p>Wolfgang Mader, <a href="mailto:Wolfgang.Mader@fdm.uni-freiburg.de">Wolfgang.Mader@fdm.uni-freiburg.de</a>
</p>
<p>Mirjam Fehling-Kaschek, <a href="mailto:mirjam.fehling@physik.uni-freiburg.de">mirjam.fehling@physik.uni-freiburg.de</a>
</p>

<hr>
<h2 id='blockdiagSymb'>Embed two matrices into one blockdiagonal matrix</h2><span id='topic+blockdiagSymb'></span>

<h3>Description</h3>

<p>Embed two matrices into one blockdiagonal matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blockdiagSymb(M, N)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blockdiagSymb_+3A_m">M</code></td>
<td>
<p>matrix of type character</p>
</td></tr>
<tr><td><code id="blockdiagSymb_+3A_n">N</code></td>
<td>
<p>matrix of type character</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of type character containing M and N as upper left and lower right block
</p>


<h3>Examples</h3>

<pre><code class='language-R'>M &lt;- matrix(1:9, 3, 3, dimnames = list(letters[1:3], letters[1:3]))
N &lt;- matrix(1:4, 2, 2, dimnames = list(LETTERS[1:2], LETTERS[1:2]))
blockdiagSymb(M, N)
</code></pre>

<hr>
<h2 id='combine'>Combine several data.frames by rowbind</h2><span id='topic+combine'></span>

<h3>Description</h3>

<p>Combine several data.frames by rowbind
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine_+3A_...">...</code></td>
<td>
<p>data.frames or matrices with not necessarily overlapping colnames</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is useful when separating models into independent csv model files,
e.g.~a receptor model and several downstream pathways. Then, the models can be recombined 
into one model by <code>combine()</code>.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data1 &lt;- data.frame(Description = "reaction 1", Rate = "k1*A", A = -1, B = 1)
data2 &lt;- data.frame(Description = "reaction 2", Rate = "k2*B", B = -1, C = 1)
combine(data1, data2)
</code></pre>

<hr>
<h2 id='compare'>Compare two objects and return differences</h2><span id='topic+compare'></span><span id='topic+compare.list'></span><span id='topic+compare.character'></span><span id='topic+compare.eqnvec'></span><span id='topic+compare.data.frame'></span>

<h3>Description</h3>

<p>Works eigher on a list or on two arguments. In case of a list,
comparison is done with respect to a reference entry. Besides the
objects themselves also some of their attributes are compared,
i.e. &quot;equations&quot;, &quot;parameters&quot; and &quot;events&quot; and &quot;forcings&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare(vec1, ...)

## S3 method for class 'list'
compare(vec1, vec2 = NULL, reference = 1, ...)

## S3 method for class 'character'
compare(vec1, vec2 = NULL, ...)

## S3 method for class 'eqnvec'
compare(vec1, vec2 = NULL, ...)

## S3 method for class 'data.frame'
compare(vec1, vec2 = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_+3A_vec1">vec1</code></td>
<td>
<p>object of class <a href="#topic+eqnvec">eqnvec</a>, <code>character</code> or
<code>data.frame</code>. Alternatively, a list of such objects.</p>
</td></tr>
<tr><td><code id="compare_+3A_...">...</code></td>
<td>
<p>arguments going to the corresponding methods</p>
</td></tr>
<tr><td><code id="compare_+3A_vec2">vec2</code></td>
<td>
<p>same as vec1. Not used if vec1 is a list.</p>
</td></tr>
<tr><td><code id="compare_+3A_reference">reference</code></td>
<td>
<p>numeric of length one, the reference entry.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> or list of data.frames with the differences.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Compare equation vectors
eq1 &lt;- eqnvec(a = "-k1*a + k2*b", b = "k2*a - k2*b")
eq2 &lt;- eqnvec(a = "-k1*a", b = "k2*a - k2*b", c = "k2*b")
compare(eq1, eq2)

## Compare character vectors
c1 &lt;- c("a", "b")
c2 &lt;- c("b", "c")
compare(c1, c2)

## Compare data.frames
d1 &lt;- data.frame(var = "a", time = 1, value = 1:3, method = "replace")
d2 &lt;- data.frame(var = "a", time = 1, value = 2:4, method = "replace")
compare(d1, d2)

## Compare structures like prediction functions
fn1 &lt;- function(x) x^2
attr(fn1, "equations") &lt;- eq1
attr(fn1, "parameters") &lt;- c1
attr(fn1, "events") &lt;- d1

fn2 &lt;- function(x) x^3
attr(fn2, "equations") &lt;- eq2
attr(fn2, "parameters") &lt;- c2
attr(fn2, "events") &lt;- d2

mylist &lt;- list(f1 = fn1, f2 = fn2)
compare(mylist)
</code></pre>

<hr>
<h2 id='compile'>Compile one or more prdfn, obsfn or parfn objects</h2><span id='topic+compile'></span>

<h3>Description</h3>

<p>Compile one or more prdfn, obsfn or parfn objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compile(..., output = NULL, args = NULL, cores = 1, verbose = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compile_+3A_...">...</code></td>
<td>
<p>Objects of class parfn, obsfn or prdfn</p>
</td></tr>
<tr><td><code id="compile_+3A_output">output</code></td>
<td>
<p>Optional character of the file to be produced. If several objects were
passed, the different C files are all compiled into one shared object file.</p>
</td></tr>
<tr><td><code id="compile_+3A_args">args</code></td>
<td>
<p>Additional arguments for the R CMD SHLIB call, e.g. <code>-leinspline</code>.</p>
</td></tr>
<tr><td><code id="compile_+3A_cores">cores</code></td>
<td>
<p>Number of cores used for compilation when several files are compiled.</p>
</td></tr>
<tr><td><code id="compile_+3A_verbose">verbose</code></td>
<td>
<p>Print compiler output to R command line.</p>
</td></tr>
</table>

<hr>
<h2 id='confint.parframe'>Profile uncertainty extraction</h2><span id='topic+confint.parframe'></span>

<h3>Description</h3>

<p>extract parameter uncertainties from profiles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'parframe'
confint(object, parm = NULL, level = 0.95, ..., val.column = "data")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint.parframe_+3A_object">object</code></td>
<td>
<p>object of class <code>parframe</code>, returned from <a href="#topic+profile">profile</a> function.</p>
</td></tr>
<tr><td><code id="confint.parframe_+3A_parm">parm</code></td>
<td>
<p>a specification of which parameters are to be given confidence intervals, 
either a vector of numbers or a vector of names. If missing, all parameters are considered.</p>
</td></tr>
<tr><td><code id="confint.parframe_+3A_level">level</code></td>
<td>
<p>the confidence level required.</p>
</td></tr>
<tr><td><code id="confint.parframe_+3A_...">...</code></td>
<td>
<p>not used right now.</p>
</td></tr>
<tr><td><code id="confint.parframe_+3A_val.column">val.column</code></td>
<td>
<p>the value column used in the parframe, usually 'data'.</p>
</td></tr>
</table>

<hr>
<h2 id='conservedQuantities'>Determine conserved quantites by finding the kernel of the stoichiometric
matrix</h2><span id='topic+conservedQuantities'></span>

<h3>Description</h3>

<p>Determine conserved quantites by finding the kernel of the stoichiometric
matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conservedQuantities(S)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conservedQuantities_+3A_s">S</code></td>
<td>
<p>Stoichiometric matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with conserved quantities carrying an attribute with the
number of conserved quantities.
</p>


<h3>Author(s)</h3>

<p>Malenke Mader, <a href="mailto:Malenka.Mader@fdm.uni-freiburg.de">Malenka.Mader@fdm.uni-freiburg.de</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  # Write your example here. You can also add more Start..End blocks if needed.
  # Please mask all output such as print() with the special tag
  #    
  # such that the test is not littered. Statements guarded by  are enabled
  # in the example file which is extracted from this test file. To extract the
  # example run
  #    extractExamples()
  # on the R command line.
    
    ## Generate another equation list
    eq &lt;- eqnlist()
    eq &lt;- addReaction(eq, "A", "pA", "act_A * A * stimulus", "Phosphorylation of A")
    eq &lt;- addReaction(eq, "pA", "A", "deact_A * pA", "Deposphorylation of pA")
    eq &lt;- addReaction(eq, "2*pA", "pA_pA", "form_complex_pA * pA^2", "Complex formation of pA")
    eq &lt;- addReaction(eq, "B", "pB", "act_B * B * pA_pA", "Phosphorylation of B")
    eq &lt;- addReaction(eq, "pB", "B", "deact_B * pB", "Deposphorylation of pB")
    
    ## Extract data.frame of reactions
    reactions &lt;- getReactions(eq)
     print(reactions)
    
    ## Get conserved quantities
    cq &lt;- conservedQuantities(eq$smatrix)
     print(cq)
    
    ## Get fluxes
    fluxes &lt;- getFluxes(eq)
     print(fluxes)
    
    ## Subsetting of equation list
    subeq1 &lt;- subset(eq, "pB" %in% Product)
     print(subeq1)
    subeq2 &lt;- subset(eq, grepl("not_available", Description))
     print(subeq2)
    
    ## Time derivatives of observables
    observables &lt;- eqnvec(pA_obs = "s1*pA", tA_obs = "s2*(A + pA)")
    dobs &lt;- dot(observables, eq)
    
    ## Combined equation vector for ODE and observables
    f &lt;- c(as.eqnvec(eq), dobs)
     print(f)
    
    
  
</code></pre>

<hr>
<h2 id='constraintExp2'>Compute a differentiable box prior</h2><span id='topic+constraintExp2'></span>

<h3>Description</h3>

<p>Compute a differentiable box prior
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constraintExp2(p, mu, sigma = 1, k = 0.05, fixed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="constraintExp2_+3A_p">p</code></td>
<td>
<p>Named numeric, the parameter value</p>
</td></tr>
<tr><td><code id="constraintExp2_+3A_mu">mu</code></td>
<td>
<p>Named numeric, the prior values, means of boxes</p>
</td></tr>
<tr><td><code id="constraintExp2_+3A_sigma">sigma</code></td>
<td>
<p>Named numeric, half box width</p>
</td></tr>
<tr><td><code id="constraintExp2_+3A_k">k</code></td>
<td>
<p>Named numeric, shape of box; if 0 a quadratic prior is obtained, the higher k the more box shape, gradient at border of the box (-sigma, sigma) is equal to sigma*k</p>
</td></tr>
<tr><td><code id="constraintExp2_+3A_fixed">fixed</code></td>
<td>
<p>Named numeric with fixed parameter values (contribute to the prior value but not to gradient and Hessian)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with entries: value (numeric, the weighted residual sum of squares), 
gradient (numeric, gradient) and 
hessian (matrix of type numeric). Object of class <code>objlist</code>.
</p>

<hr>
<h2 id='constraintL2'>Soft L2 constraint on parameters</h2><span id='topic+constraintL2'></span>

<h3>Description</h3>

<p>Soft L2 constraint on parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constraintL2(mu, sigma = 1, attr.name = "prior", condition = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="constraintL2_+3A_mu">mu</code></td>
<td>
<p>named numeric, the prior values</p>
</td></tr>
<tr><td><code id="constraintL2_+3A_sigma">sigma</code></td>
<td>
<p>named numeric of length of mu or numeric of length one
or character of length of mu or character of length one</p>
</td></tr>
<tr><td><code id="constraintL2_+3A_attr.name">attr.name</code></td>
<td>
<p>character. The constraint value is additionally returned in an 
attributed with this name</p>
</td></tr>
<tr><td><code id="constraintL2_+3A_condition">condition</code></td>
<td>
<p>character, the condition for which the constraint should apply. If
<code>NULL</code>, applies to any condition.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If sigma is numeric, the function computes the constraint value 
</p>
<p style="text-align: center;"><code class="reqn">\left(\frac{p-\mu}{\sigma}\right)^2</code>
</p>

<p>and its derivatives with respect to p. If sigma is a character, the 
function computes
</p>
<p style="text-align: center;"><code class="reqn">\left(\frac{p-\mu}{\sigma}\right)^2 + \log(\sigma^2)</code>
</p>

<p>and its derivatives with respect to p and sigma. Sigma parameters being
passed to the function are ALWAYS assumed to be on a log scale, i.e. internally
sigma parameters are converted by <code>exp()</code>.
</p>


<h3>Value</h3>

<p>object of class <code>objfn</code>
</p>


<h3>See Also</h3>

<p><a href="#topic+wrss">wrss</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mu &lt;- c(A = 0, B = 0)
sigma &lt;- c(A = 0.1, B = 1)
myfn &lt;- constraintL2(mu, sigma)
myfn(pars = c(A = 1, B = -1))

# Introduce sigma parameter but fix them (sigma parameters
# are assumed to be passed on log scale)
mu &lt;- c(A = 0, B = 0)
sigma &lt;- paste("sigma", names(mu), sep = "_")
myfn &lt;- constraintL2(mu, sigma)
pars &lt;- c(A = .8, B = -.3, sigma_A = -1, sigma_B = 1)
myfn(pars = pars[c(1, 3)], fixed = pars[c(2, 4)])

# Assume same sigma parameter for both A and B
# sigma is assumed to be passed on log scale
mu &lt;- c(A = 0, B = 0)
myfn &lt;- constraintL2(mu, sigma = "sigma")
pars &lt;- c(A = .8, B = -.3, sigma = 0)
myfn(pars = pars)

</code></pre>

<hr>
<h2 id='controls'>List, get and set controls for different functions</h2><span id='topic+controls'></span><span id='topic+controls.objfn'></span><span id='topic+controls.fn'></span><span id='topic+controls+3C-'></span><span id='topic+controls+3C-.objfn'></span><span id='topic+controls+3C-.fn'></span>

<h3>Description</h3>

<p>Applies to objects of class <code>objfn</code>,
<code>parfn</code>, <code>prdfn</code> and <code>obsfn</code>. Allows to manipulate
different arguments that have been set when creating the
objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>controls(x, ...)

## S3 method for class 'objfn'
controls(x, name = NULL, ...)

## S3 method for class 'fn'
controls(x, condition = NULL, name = NULL, ...)

controls(x, ...) &lt;- value

## S3 replacement method for class 'objfn'
controls(x, name, ...) &lt;- value

## S3 replacement method for class 'fn'
controls(x, condition = NULL, name, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="controls_+3A_x">x</code></td>
<td>
<p>function</p>
</td></tr>
<tr><td><code id="controls_+3A_...">...</code></td>
<td>
<p>arguments going to the appropriate S3 methods</p>
</td></tr>
<tr><td><code id="controls_+3A_name">name</code></td>
<td>
<p>character, the name of the control</p>
</td></tr>
<tr><td><code id="controls_+3A_condition">condition</code></td>
<td>
<p>character, the condition name</p>
</td></tr>
<tr><td><code id="controls_+3A_value">value</code></td>
<td>
<p>the new value</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If called without further arguments, <code>controls(x)</code> lists the
available controls within an object. Calling <code>controls()</code> with <code>name</code>
and <code>condition</code> returns the control value. The value can be overwritten. If
a list or data.frame ist returned, elements of those can be manipulated by the
<code>$</code>- or <code>[]</code>-operator.
</p>


<h3>Value</h3>

<p>Either a print-out or the values of the control.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## parfn with condition
p &lt;- P(eqnvec(x = "-a*x"), method = "implicit", condition = "C1")
controls(p)
controls(p, "C1", "keep.root")
controls(p, "C1", "keep.root") &lt;- FALSE

## obsfn with NULL condition
g &lt;- Y(g = eqnvec(y = "s*x"), f = NULL, states = "x", parameters = "s")
controls(g)
controls(g, NULL, "attach.input")
controls(g, NULL, "attach.input") &lt;- FALSE
</code></pre>

<hr>
<h2 id='coordTransform'>Coordinate transformation for data frames</h2><span id='topic+coordTransform'></span>

<h3>Description</h3>

<p>Applies a symbolically defined transformation to the <code>value</code>
column of a data frame. Additionally, if a <code>sigma</code> column is
present, those values are transformed according to Gaussian error
propagation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coordTransform(data, transformations)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coordTransform_+3A_data">data</code></td>
<td>
<p>data frame with at least columns &quot;name&quot; (character) and
&quot;value&quot; (numeric). Can optionally contain a column &quot;sigma&quot; (numeric).</p>
</td></tr>
<tr><td><code id="coordTransform_+3A_transformations">transformations</code></td>
<td>
<p>character (the transformation) or named list of
characters. In this case, the list names must be a subset of those 
contained in the &quot;name&quot; column.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The data frame with the transformed values and sigma uncertainties.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mydata1 &lt;- data.frame(name = c("A", "B"), time = 0:5, value = 0:5, sigma = .1)
coordTransform(mydata1, "log(value)")
coordTransform(mydata1, list(A = "exp(value)", B = "sqrt(value)"))
</code></pre>

<hr>
<h2 id='covariates'>Access the covariates in the data</h2><span id='topic+covariates'></span><span id='topic+covariates.datalist'></span><span id='topic+covariates.data.frame'></span>

<h3>Description</h3>

<p>Access the covariates in the data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covariates(x)

## S3 method for class 'datalist'
covariates(x)

## S3 method for class 'data.frame'
covariates(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covariates_+3A_x">x</code></td>
<td>
<p>Either a <a href="#topic+datalist">datalist</a> or a <code>data.frame</code> with mandatory 
columns <code>c("name", "time", "value", "sigma", "lloq")</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>condition.grid</code> of the data
</p>

<hr>
<h2 id='datalist'>Generate a datalist object</h2><span id='topic+datalist'></span><span id='topic+as.datalist'></span><span id='topic+as.datalist.data.frame'></span><span id='topic+as.datalist.list'></span><span id='topic+names+3C-.datalist'></span><span id='topic+is.datalist'></span><span id='topic+c.datalist'></span>

<h3>Description</h3>

<p>The datalist object stores time-course data in a list of data.frames.
The names of the list serve as identifiers, e.g. of an experimental condition, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>datalist(...)

as.datalist(x, ...)

## S3 method for class 'data.frame'
as.datalist(x, split.by = NULL, keep.covariates = NULL, ...)

## S3 method for class 'list'
as.datalist(x, names = NULL, ..., condition.grid = attr(x, "condition.grid"))

## S3 replacement method for class 'datalist'
names(x) &lt;- value

is.datalist(x)

## S3 method for class 'datalist'
c(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="datalist_+3A_...">...</code></td>
<td>
<p>data.frame objects to be coerced into a list and additional arguments</p>
</td></tr>
<tr><td><code id="datalist_+3A_x">x</code></td>
<td>
<p>object of class <code>data.frame</code> or <code>list</code>. Data frames are required to
provide &quot;name&quot;, &quot;time&quot; and &quot;value&quot; as columns. Columns &quot;sigma&quot; and &quot;lloq&quot; can be provided.
If &quot;sigma&quot; and &quot;lloq&quot; are missing, they
are imputed with <code>NA</code> and <code>-Inf</code>, respectively.</p>
</td></tr>
<tr><td><code id="datalist_+3A_split.by">split.by</code></td>
<td>
<p>vector of columns names which yield a unique identifier (conditions). If NULL, all
columns except for the expected standard columns &quot;name&quot;, &quot;time&quot;, &quot;value&quot;, &quot;sigma&quot; and &quot;lloq&quot; will be
selected.</p>
</td></tr>
<tr><td><code id="datalist_+3A_keep.covariates">keep.covariates</code></td>
<td>
<p>vector of additional column names which should be kept in the condition.grid.</p>
</td></tr>
<tr><td><code id="datalist_+3A_names">names</code></td>
<td>
<p>optional names vector, otherwise names are taken from <code>mylist</code></p>
</td></tr>
<tr><td><code id="datalist_+3A_condition.grid">condition.grid</code></td>
<td>
<p>Optionally, to manually specify a condition.grid</p>
</td></tr>
<tr><td><code id="datalist_+3A_value">value</code></td>
<td>
<p>The new condition names of the datalist and its condition.grid</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Datalists can be plotted, see <a href="#topic+plotData">plotData</a> and merged, see <a href="#topic+sumdatalist">sumdatalist</a>.
They are the basic structure when combining model prediction and data via the <a href="#topic+normL2">normL2</a>
objective function.
</p>
<p>The standard columns of the datalist data frames are &quot;name&quot; (observable name), 
&quot;time&quot; (time points), &quot;value&quot; (data value), &quot;sigma&quot; (uncertainty, can be NA), and
&quot;lloq&quot; (lower limit of quantification, <code>-Inf</code> by default).
</p>
<p>Datalists carry the attribute <code>condition.grid</code> which contains additional information about different
conditions, such as dosing information for the experiment. It can be conveniently accessed by the <a href="#topic+covariates">covariates</a>-function.
Reassigning names to a datalist also renames the rows of the <code>condition.grid</code>.
</p>


<h3>Value</h3>

<p>Object of class <code>datalist</code>.
</p>
<p>Object of class <a href="#topic+datalist">datalist</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate datalist from scratch
mydata1 &lt;- data.frame(name = "A",
                      time = 0:5,
                      value = 0:5,
                      sigma = .1,
                      lloq = -0.5)

mydata2 &lt;- data.frame(name = "A",
                      time = 0:5,
                      value = sin(0:5),
                      sigma = .1)

data &lt;- datalist(C1 = mydata1, C2 = mydata2)
print(data)
plot(data)

## Generate datalist from singla data.frame
times &lt;- seq(0, 2*pi, length.out = 20)
mydata &lt;- data.frame(name = "A", 
                     time = times, 
                     value = c(sin(times), 1.5 * sin(times)), 
                     sigma = .1, 
                     stage = rep(c("upper", "lower"), each = 10),
                     phase = rep(c("first", "second"), each = 20),
                     amplitude = rep(c(1,1.5), each = 20))

data &lt;- as.datalist(mydata, split.by = c("stage", "phase"), keep.covariates = "amplitude")
print(data)
plot(data)

condition.grid &lt;- attr(data, "condition.grid")
print(condition.grid)
</code></pre>

<hr>
<h2 id='datapointL2'>L2 objective function for validation data point</h2><span id='topic+datapointL2'></span>

<h3>Description</h3>

<p>L2 objective function for validation data point
</p>


<h3>Usage</h3>

<pre><code class='language-R'>datapointL2(name, time, value, sigma = 1, attr.name = "validation", condition)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="datapointL2_+3A_name">name</code></td>
<td>
<p>character, the name of the prediction, e.g. a state name.</p>
</td></tr>
<tr><td><code id="datapointL2_+3A_time">time</code></td>
<td>
<p>numeric, the time-point associated to the prediction</p>
</td></tr>
<tr><td><code id="datapointL2_+3A_value">value</code></td>
<td>
<p>character, the name of the parameter which contains the
prediction value.</p>
</td></tr>
<tr><td><code id="datapointL2_+3A_sigma">sigma</code></td>
<td>
<p>numeric, the uncertainty of the introduced test data point</p>
</td></tr>
<tr><td><code id="datapointL2_+3A_attr.name">attr.name</code></td>
<td>
<p>character. The constraint value is additionally returned in an 
attributed with this name</p>
</td></tr>
<tr><td><code id="datapointL2_+3A_condition">condition</code></td>
<td>
<p>character, the condition for which the prediction is made.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the constraint value 
</p>
<p style="text-align: center;"><code class="reqn">\left(\frac{x(t)-\mu}{\sigma}\right)^2</code>
</p>

<p>and its derivatives with respect to p.
</p>


<h3>Value</h3>

<p>List of class <code>objlist</code>, i.e. objective value, gradient and Hessian as list.
</p>


<h3>See Also</h3>

<p><a href="#topic+wrss">wrss</a>, <a href="#topic+constraintL2">constraintL2</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>prediction &lt;- list(a = matrix(c(0, 1), nrow = 1, dimnames = list(NULL, c("time", "A"))))
derivs &lt;- matrix(c(0, 1, 0.1), nrow = 1, dimnames = list(NULL, c("time", "A.A", "A.k1")))
attr(prediction$a, "deriv") &lt;- derivs
p0 &lt;- c(A = 1, k1 = 2)

vali &lt;- datapointL2(name = "A", time = 0, value = "newpoint", sigma = 1, condition = "a")
vali(pars = c(p0, newpoint = 1), env = .GlobalEnv)
</code></pre>

<hr>
<h2 id='define'>Define parameter transformations by <code>define()</code>, <code>branch()</code> and <code>insert()</code></h2><span id='topic+define'></span><span id='topic+insert'></span><span id='topic+branch'></span>

<h3>Description</h3>

<p>Define parameter transformations by <code>define()</code>, <code>branch()</code> and <code>insert()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>define(trafo, expr, ..., conditionMatch = NULL)

insert(trafo, expr, ..., conditionMatch = NULL)

branch(trafo, table = NULL, conditions = rownames(table))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="define_+3A_trafo">trafo</code></td>
<td>
<p>named character vector of parametric expressions or object 
of class <code>eqnvec</code></p>
</td></tr>
<tr><td><code id="define_+3A_expr">expr</code></td>
<td>
<p>character of the form <code>"lhs ~ rhs"</code> where both <code>lhs</code>
and <code>rhs</code> can contain a number of symbols for which vaues are passed
by the <code>...</code> argument</p>
</td></tr>
<tr><td><code id="define_+3A_...">...</code></td>
<td>
<p>used to pass values for symbols as named arguments</p>
</td></tr>
<tr><td><code id="define_+3A_conditionmatch">conditionMatch</code></td>
<td>
<p>optional character, Use as regular expression to apply the reparameterization only to conditions containing conditionMatch</p>
</td></tr>
<tr><td><code id="define_+3A_table">table</code></td>
<td>
<p>table of covariates as data frame. Rownames are used as unique identifier,
usually called &quot;conditions&quot;, and columns represent covariates associated with these conditions.</p>
</td></tr>
<tr><td><code id="define_+3A_conditions">conditions</code></td>
<td>
<p>character vector with condition names. Overwrites the rownames of table.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of the same class as trafo or list thereof, if <code>branch()</code> has been
used.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define some parameter names
parameters &lt;- c("A", "B", "k1", "k2")
# Define a covariate table
covtable &lt;- data.frame(dose = c(1, 1, 10), 
                       inhibitor = c("no", "inh", "no"), 
                       row.names = c("Low_noInh", "Low_Inh", "High_noInh"))

# Start with an empty transformation
trans &lt;- NULL

# Generate the identity transformation for parameters
trans &lt;- define(trans, "x ~ x", x = parameters); print(trans)

# Insert exp(x) wherever you find x
trans &lt;- insert(trans, "x ~ exp(x)", x = parameters); print(trans)

# Some new expressions instead of k1 and k2
trans &lt;- insert(trans, "x ~ y", x = c("k1", "k2"), y = c("q1 + q2", "q1 - q2")); print(trans)

# Define some parameters as 0
trans &lt;- define(trans, "x ~ 0", x = "B"); print(trans)

# The parameter name can also be directly used in the formula
trans &lt;- insert(trans, "q1 ~ Q"); print(trans)

# Replicate the transformation 3 times with the rownames of covtable as list names
trans &lt;- branch(trans, table = covtable); print(trans)

# Insert the rhs wherever the lhs is found in the transformation
# column names of covtable can be used to perform specific replacements
# for each transformation
trans &lt;- insert(trans, "x ~ x_inh", x = c("Q", "q2"), inh = inhibitor); print(trans)

# Also numbers can be inserted
trans &lt;- define(trans, "A ~ dose", dose = dose); print(trans)


# Turn that into a parameter transformation function
p &lt;- P(trans)
parnames &lt;- getParameters(p)
pars &lt;- rnorm(length(parnames))
names(pars) &lt;- parnames

p(pars)


# Advanced tricks exploiting the quoting-mechanism when capturing "..."

mydataframe &lt;- data.frame(
  name = rep(letters[1:2], each = 3),
  value = 1:6,
  time = rep(1:3, 2),
  sigma = 0.1,
  par1 = rep(0:1, each = 3),
  par2 = rep(9:10, each = 3),
  par3 = rep(1:3, each = 2),
  stringsAsFactors = FALSE
)

parameters &lt;- c("a", "b", "par1", "par2", "par3")
pars_to_insert &lt;- c("par1", "par2")

# this would be the usual way when setting up a model
# pars_to_insert &lt;- intersect(getParameters(g*x), names(data)) 

trafo &lt;- define(NULL, "x~x", x = parameters) 
trafo &lt;- branch(trafo, covariates(as.datalist(mydataframe)))

# Trick 1: Access values from covariates()-Table with get/mget. 
    # The names of the parameters which are supplied in the covariates()-table 
    # have to be supplied manually.
trafo &lt;- insert(trafo, "name ~ value", value = unlist(mget(pars_to_insert)), name = pars_to_insert)

# Trick 2: Access symbols from current condition-specific trafo with .currentSymbols, access 
    # current condition-specific trafo by .currentTrafo
    # The input passed by the dots is "quoted" (substituted) and eval()'ed in the environment 
    # of the lapply(1:length(conditions), function(i) {})
trafo &lt;- insert(trafo, "x~exp(X)", x = .currentSymbols, X = toupper(.currentSymbols))

# Trick 3: Condition specificity. There are two ways to do this
  # 1. Apply reparametrization only for specific conditions using Regular Expressions for the 
  # conditionMatch argument. This matches the condition name agains a regex
trafo &lt;- define(NULL, "x~x", x = parameters) 
trafo &lt;- branch(trafo, covariates(as.datalist(mydataframe)))

# Conditions starting with 0_9
insert(trafo, "x~x_par3", x = "a", conditionMatch = "^0_9", par3 = par3)  
# Conditions NOT starting with 0_9
insert(trafo, "x~0", x = "a", conditionMatch = "^(?!0_9)")
  # 2. Specify conditions by boolean arguments
  #    Conditions which satisfy par1 == 0
insert(trafo, "x~x_par2", par1 == 0, x = parameters, par2 = par2)       
  # Special case: Pass two arguments with the same name. This is only possible if one of them 
  # is logical and the other is not.
  # Conditions which satisfy par2 == 9
insert(trafo, "x~x_par2", par2 == 9, x = .currentSymbols, par2 = par2)       





</code></pre>

<hr>
<h2 id='dot'>Symbolic time derivative of equation vector given an equation list</h2><span id='topic+dot'></span>

<h3>Description</h3>

<p>The time evolution of the internal states is defined in the equation list.
Time derivatives of observation functions are expressed in terms of the
rates of the internal states.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dot(observable, eqnlist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dot_+3A_observable">observable</code></td>
<td>
<p>named character vector or object of type <a href="#topic+eqnvec">eqnvec</a></p>
</td></tr>
<tr><td><code id="dot_+3A_eqnlist">eqnlist</code></td>
<td>
<p>equation list</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Observables are translated into an ODE
</p>


<h3>Value</h3>

<p>An object of class <a href="#topic+eqnvec">eqnvec</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  # Write your example here. You can also add more Start..End blocks if needed.
  # Please mask all output such as print() with the special tag
  #    
  # such that the test is not littered. Statements guarded by  are enabled
  # in the example file which is extracted from this test file. To extract the
  # example run
  #    extractExamples()
  # on the R command line.
    
    ## Generate another equation list
    eq &lt;- eqnlist()
    eq &lt;- addReaction(eq, "A", "pA", "act_A * A * stimulus", "Phosphorylation of A")
    eq &lt;- addReaction(eq, "pA", "A", "deact_A * pA", "Deposphorylation of pA")
    eq &lt;- addReaction(eq, "2*pA", "pA_pA", "form_complex_pA * pA^2", "Complex formation of pA")
    eq &lt;- addReaction(eq, "B", "pB", "act_B * B * pA_pA", "Phosphorylation of B")
    eq &lt;- addReaction(eq, "pB", "B", "deact_B * pB", "Deposphorylation of pB")
    
    ## Extract data.frame of reactions
    reactions &lt;- getReactions(eq)
     print(reactions)
    
    ## Get conserved quantities
    cq &lt;- conservedQuantities(eq$smatrix)
     print(cq)
    
    ## Get fluxes
    fluxes &lt;- getFluxes(eq)
     print(fluxes)
    
    ## Subsetting of equation list
    subeq1 &lt;- subset(eq, "pB" %in% Product)
     print(subeq1)
    subeq2 &lt;- subset(eq, grepl("not_available", Description))
     print(subeq2)
    
    ## Time derivatives of observables
    observables &lt;- eqnvec(pA_obs = "s1*pA", tA_obs = "s2*(A + pA)")
    dobs &lt;- dot(observables, eq)
    
    ## Combined equation vector for ODE and observables
    f &lt;- c(as.eqnvec(eq), dobs)
     print(f)
    
    
  
</code></pre>

<hr>
<h2 id='eqnlist'>Generate eqnlist object</h2><span id='topic+eqnlist'></span><span id='topic+as.eqnlist'></span><span id='topic+as.eqnlist.data.frame'></span><span id='topic+is.eqnlist'></span>

<h3>Description</h3>

<p>The eqnlist object stores an ODE as a list of stoichiometric matrix,
rate expressions, state names and compartment volumes.
</p>
<p>Translates a reaction network, e.g. defined by a data.frame, into an equation list object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eqnlist(
  smatrix = NULL,
  states = colnames(smatrix),
  rates = NULL,
  volumes = NULL,
  description = NULL
)

as.eqnlist(data, volumes)

## S3 method for class 'data.frame'
as.eqnlist(data, volumes = NULL)

is.eqnlist(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eqnlist_+3A_smatrix">smatrix</code></td>
<td>
<p>Matrix of class numeric. The stoichiometric matrix,
one row per reaction/process and one column per state.</p>
</td></tr>
<tr><td><code id="eqnlist_+3A_states">states</code></td>
<td>
<p>Character vector. Names of the states.</p>
</td></tr>
<tr><td><code id="eqnlist_+3A_rates">rates</code></td>
<td>
<p>Character vector. The rate expressions.</p>
</td></tr>
<tr><td><code id="eqnlist_+3A_volumes">volumes</code></td>
<td>
<p>Named character, volume parameters for states. Names must be a subset of the states.
Values can be either characters, e.g. &quot;V1&quot;, or numeric values for the volume. If <code>volumes</code> is not
<code>NULL</code>, missing entries are treated as 1.</p>
</td></tr>
<tr><td><code id="eqnlist_+3A_description">description</code></td>
<td>
<p>Character vector. Description of the single processes.</p>
</td></tr>
<tr><td><code id="eqnlist_+3A_data">data</code></td>
<td>
<p>data.frame with columns Description, Rate, and one colum for each state
reflecting the stoichiometric matrix</p>
</td></tr>
<tr><td><code id="eqnlist_+3A_x">x</code></td>
<td>
<p>object of class <code>eqnlist</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>data</code> is a <code>data.frame</code>, it must contain columns &quot;Description&quot; (character), 
&quot;Rate&quot; (character), and one column per ODE state with the state names. 
The state columns correspond to the stoichiometric matrix.
</p>


<h3>Value</h3>

<p>An object of class <code>eqnlist</code>, basically a list.
</p>
<p>Object of class <a href="#topic+eqnlist">eqnlist</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate eqnlist from the constructor
S &lt;- matrix(c(-1, 1, 1, -1), 
            nrow = 2, ncol = 2, 
            dimnames = list(NULL, c("A", "B")))

rates &lt;- c("k1*A", "k2*B")
description &lt;- c("forward", "backward")

f &lt;- eqnlist(smatrix = S, rates = rates, description = description)
print(f)

# Convert to data.frame
fdata &lt;- as.data.frame(f)
print(fdata)

# Generate eqnlist from data.frame and add volume parameter
f &lt;- as.eqnlist(fdata, volumes = c(A = "Vcyt", B = "Vnuc"))
print(f)
print(as.eqnvec(f))
print(as.eqnvec(f, type = "amount"))

</code></pre>

<hr>
<h2 id='eqnvec'>Generate equation vector object</h2><span id='topic+eqnvec'></span><span id='topic+is.eqnvec'></span>

<h3>Description</h3>

<p>The eqnvec object stores explicit algebraic equations, like the
right-hand sides of an ODE, observation functions or parameter transformations
as named character vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eqnvec(...)

is.eqnvec(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eqnvec_+3A_...">...</code></td>
<td>
<p>mathematical expressions as characters to be coerced,
the right-hand sides of the equations</p>
</td></tr>
<tr><td><code id="eqnvec_+3A_x">x</code></td>
<td>
<p>obect of any class</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class <code>eqnvec</code>, basically a named character.
</p>


<h3>See Also</h3>

<p><a href="#topic+eqnlist">eqnlist</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>v &lt;- eqnvec(y = "2*x + offset")
print(v)
is.eqnvec(v)

</code></pre>

<hr>
<h2 id='eventlist'>Eventlist</h2><span id='topic+eventlist'></span><span id='topic+addEvent'></span>

<h3>Description</h3>

<p>An eventlist is a data.frame with the necessary parameters to define an event as columns and specific events as rows.
Event time and value can be passed as parameters, which can also be estimated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eventlist(var = NULL, time = NULL, value = NULL, method = NULL)

addEvent(event, var, time = 0, value = 0, method = "replace", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eventlist_+3A_var">var</code></td>
<td>
<p>Character, the state to which the event is applied</p>
</td></tr>
<tr><td><code id="eventlist_+3A_time">time</code></td>
<td>
<p>Character or Numeric, the time at which the event happens</p>
</td></tr>
<tr><td><code id="eventlist_+3A_value">value</code></td>
<td>
<p>Character or Numeric, the value of the event</p>
</td></tr>
<tr><td><code id="eventlist_+3A_method">method</code></td>
<td>
<p>Character, options are &quot;replace&quot;, &quot;add&quot; or &quot;multiply&quot;</p>
</td></tr>
<tr><td><code id="eventlist_+3A_event">event</code></td>
<td>
<p>object of class <code>eventlist</code></p>
</td></tr>
<tr><td><code id="eventlist_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>addEvent</code> is pipe-friendly
</p>


<h3>Value</h3>

<p>data.frame with class eventlist
</p>


<h3>Examples</h3>

<pre><code class='language-R'>eventlist(var = "A", time = "5", value = 1, method = "add")

events &lt;- addEvent(NULL, var = "A", time = "5", value = 1, method = "add")
events &lt;- addEvent(events, var = "A", time = "10", value = 1, method = "add")
</code></pre>

<hr>
<h2 id='expand.grid.alt'>Alternative version of expand.grid</h2><span id='topic+expand.grid.alt'></span>

<h3>Description</h3>

<p>Alternative version of expand.grid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand.grid.alt(seq1, seq2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand.grid.alt_+3A_seq1">seq1</code></td>
<td>
<p>Vector, numeric or character</p>
</td></tr>
<tr><td><code id="expand.grid.alt_+3A_seq2">seq2</code></td>
<td>
<p>Vector, numeric or character</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix ob combinations of elemens of <code>seq1</code> and <code>seq2</code>
</p>

<hr>
<h2 id='fitErrorModel'>Fit an error model</h2><span id='topic+fitErrorModel'></span>

<h3>Description</h3>

<p>Fit an error model to reduced replicate data, see
<code><a href="#topic+reduceReplicates">reduceReplicates</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitErrorModel(
  data,
  factors,
  errorModel = "exp(s0)+exp(srel)*x^2",
  par = c(s0 = 1, srel = 0.1),
  plotting = TRUE,
  blather = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitErrorModel_+3A_data">data</code></td>
<td>
<p>Reduced replicate data, see <code><a href="#topic+reduceReplicates">reduceReplicates</a></code>. Need 
columns &quot;value&quot;, &quot;sigma&quot;, &quot;n&quot;.</p>
</td></tr>
<tr><td><code id="fitErrorModel_+3A_factors">factors</code></td>
<td>
<p><span class="option">data</span> is pooled with respect to the columns named
here, see Details.</p>
</td></tr>
<tr><td><code id="fitErrorModel_+3A_errormodel">errorModel</code></td>
<td>
<p>Character vector defining the error model in terms of the variance. 
Use <kbd>x</kbd> to reference the independend variable, see Details.</p>
</td></tr>
<tr><td><code id="fitErrorModel_+3A_par">par</code></td>
<td>
<p>Inital values for the parameters of the error model.</p>
</td></tr>
<tr><td><code id="fitErrorModel_+3A_plotting">plotting</code></td>
<td>
<p>If TRUE, a plot of the pooled variance together with the fit
of the error model is shown.</p>
</td></tr>
<tr><td><code id="fitErrorModel_+3A_blather">blather</code></td>
<td>
<p>If TRUE, additional information is returned, such as fit parameters 
and sigmaLS (original sigma given in input data).</p>
</td></tr>
<tr><td><code id="fitErrorModel_+3A_...">...</code></td>
<td>
<p>Parameters handed to the optimizer <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The variance estimator using <code class="reqn">n-1</code> data points is <code class="reqn">chi^2</code>
distributed with <code class="reqn">n-1</code> degrees of freedom. Given replicates for
consecutive time points, the sample variance can be assumed a function of
the sample mean. By defining an error model which must hold for all time
points, a maximum likelihood estimator for the parameters of the error
model can be derived. The parameter <span class="option">errorModel</span> takes the error
model as a character vector, where the mean (independent variable) is
refered to as <kbd>x</kbd>.
</p>
<p>It is desireable to estimate the variance from many replicates. The
parameter <span class="option">data</span> must provide one or more columns which define the
pooling of data. In case more than one column is announced by
<span class="option">factors</span>, all combinations are constructed. If, e.g.,
<span class="option">factors = c("condition", "name")</span> is used, where &quot;condition&quot; is
&quot;a&quot;, &quot;b&quot;, &quot;c&quot; and repeating and &quot;name&quot; is &quot;d&quot;, &quot;e&quot; and repeating, the
effective conditions used for pooling are &quot;a d&quot;, &quot;b e&quot;, &quot;c d&quot;, &quot;a e&quot;, &quot;b
d&quot;, and &quot;c e&quot;.
</p>
<p>By default, a plot of the pooled data, sigma and its confidence bound at
68% and 95% is shown.
</p>


<h3>Value</h3>

<p>Returned by default is a data frame with columns as in <span class="option">data</span>, 
but with the sigma values replaced by the derived values, obtained by evaluating 
the error model with the fit parameters. 
</p>
<p>If the blather = TRUE option is chosen, fit values of the parameters of the error
model are appended, with the column names equal to the parameter names. 
The error model is appended as the attribute &quot;errorModel&quot;.
Confidence bounds for sigma at confidence level 68% and 95% are
calculated, their values come next in the returned data frame. Finally, the
effective conditions are appended to easily check how the pooling was done.
</p>


<h3>Author(s)</h3>

<p>Wolfgang Mader, <a href="mailto:Wolfgang.Mader@fdm.uni-freiburg.de">Wolfgang.Mader@fdm.uni-freiburg.de</a>
</p>

<hr>
<h2 id='forcingsSymb'>Return some useful forcing functions as strings</h2><span id='topic+forcingsSymb'></span>

<h3>Description</h3>

<p>Return some useful forcing functions as strings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forcingsSymb(
  type = c("Gauss", "Fermi", "1-Fermi", "MM", "Signal", "Dose"),
  parameters = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forcingsSymb_+3A_type">type</code></td>
<td>
<p>Which function to be returned</p>
</td></tr>
<tr><td><code id="forcingsSymb_+3A_parameters">parameters</code></td>
<td>
<p>Named vector, character or numeric. Replace parameters by the corresponding valus
in <code>parameters</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>String with the function
</p>

<hr>
<h2 id='format.eqnvec'>Encode equation vector in format with sufficient spaces</h2><span id='topic+format.eqnvec'></span>

<h3>Description</h3>

<p>Encode equation vector in format with sufficient spaces
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'eqnvec'
format(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format.eqnvec_+3A_x">x</code></td>
<td>
<p>object of class <a href="#topic+eqnvec">eqnvec</a>. Alternatively, a named parsable character vector.</p>
</td></tr>
<tr><td><code id="format.eqnvec_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named character
</p>

<hr>
<h2 id='funC0'>Evaluation of algebraic expressions defined by characters</h2><span id='topic+funC0'></span>

<h3>Description</h3>

<p>Evaluation of algebraic expressions defined by characters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>funC0(
  x,
  variables = getSymbols(x, exclude = parameters),
  parameters = NULL,
  compile = FALSE,
  modelname = NULL,
  verbose = FALSE,
  convenient = TRUE,
  warnings = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funC0_+3A_x">x</code></td>
<td>
<p>Object of class <code>eqnvec</code> or a
named character vector with the algebraic expressions</p>
</td></tr>
<tr><td><code id="funC0_+3A_variables">variables</code></td>
<td>
<p>character vector, the symbols that should be treated as variables</p>
</td></tr>
<tr><td><code id="funC0_+3A_parameters">parameters</code></td>
<td>
<p>character vector, the symbols that should be treated as parameters</p>
</td></tr>
<tr><td><code id="funC0_+3A_compile">compile</code></td>
<td>
<p>Logical. Directly compile the file. If <code>FALSE</code> and modelname is available,
the C file is written but not compiled. In this case, <a href="#topic+compile">compile</a> has to be called separately
to compile one or more .c-files into one .so-file. 
If modelname is not available, an R function is generated and returned.</p>
</td></tr>
<tr><td><code id="funC0_+3A_modelname">modelname</code></td>
<td>
<p>file name of the generated C file. See description of parameter <code>compile</code>.</p>
</td></tr>
<tr><td><code id="funC0_+3A_verbose">verbose</code></td>
<td>
<p>Print compiler output to R command line.</p>
</td></tr>
<tr><td><code id="funC0_+3A_convenient">convenient</code></td>
<td>
<p>logical, if TRUE return a function with argument <code>...</code> to pass
all variables/parameters as named arguments</p>
</td></tr>
<tr><td><code id="funC0_+3A_warnings">warnings</code></td>
<td>
<p>logical. Suppress warnings about missing variables/parameters that are
automatically replaced by zero values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a prediction function <code>f(..., attach.input = FALSE)</code> where the 
variables/parameters are passed as named arguments or a prediction function 
<code>f(M, p, attach.input = FALSE)</code> where <code>M</code> is the matrix of variable values 
(colums with colnames correspond to different variables) and <code>p</code> is the vector of
parameter values.
The argument <code>attach.input</code> determines whether <code>M</code> is attached to the output.
The function <code>f</code> returns a matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
myfun &lt;- funC0(c(y = "a*x^4 + b*x^2 + c"))
out &lt;- myfun(a = -1, b = 2, c = 3, x = seq(-2, 2, .1), attach.input = TRUE)
qplot(x = x, y = y, data = as.data.frame(out), geom = "line")
</code></pre>

<hr>
<h2 id='getCoefficients'>Get coefficients from a character</h2><span id='topic+getCoefficients'></span>

<h3>Description</h3>

<p>Get coefficients from a character
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCoefficients(char, symbol)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCoefficients_+3A_char">char</code></td>
<td>
<p>character, e.g. &quot;2*x + y&quot;</p>
</td></tr>
<tr><td><code id="getCoefficients_+3A_symbol">symbol</code></td>
<td>
<p>single character, e.g. &quot;x&quot; or &quot;y&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector with the coefficients
</p>

<hr>
<h2 id='getConditions'>Extract the conditions of an object</h2><span id='topic+getConditions'></span><span id='topic+getConditions.list'></span><span id='topic+getConditions.fn'></span>

<h3>Description</h3>

<p>Extract the conditions of an object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getConditions(x, ...)

## S3 method for class 'list'
getConditions(x, ...)

## S3 method for class 'fn'
getConditions(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getConditions_+3A_x">x</code></td>
<td>
<p>object from which the conditions should be extracted</p>
</td></tr>
<tr><td><code id="getConditions_+3A_...">...</code></td>
<td>
<p>additional arguments (not used right now)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The conditions in a format that depends on the class of <code>x</code>.
</p>

<hr>
<h2 id='getDerivs'>Extract the derivatives of an object</h2><span id='topic+getDerivs'></span><span id='topic+getDerivs.parvec'></span><span id='topic+getDerivs.prdframe'></span><span id='topic+getDerivs.prdlist'></span><span id='topic+getDerivs.list'></span><span id='topic+getDerivs.objlist'></span>

<h3>Description</h3>

<p>Extract the derivatives of an object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDerivs(x, ...)

## S3 method for class 'parvec'
getDerivs(x, ...)

## S3 method for class 'prdframe'
getDerivs(x, ...)

## S3 method for class 'prdlist'
getDerivs(x, ...)

## S3 method for class 'list'
getDerivs(x, ...)

## S3 method for class 'objlist'
getDerivs(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getDerivs_+3A_x">x</code></td>
<td>
<p>object from which the derivatives should be extracted</p>
</td></tr>
<tr><td><code id="getDerivs_+3A_...">...</code></td>
<td>
<p>additional arguments (not used right now)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The derivatives in a format that depends on the class of <code>x</code>.
This is
<code>parvec -&gt; matrix</code>,
<code>prdframe -&gt; prdframe</code>,
<code>prdlist -&gt; prdlist</code>,
<code>objlist -&gt; named numeric</code>.
</p>

<hr>
<h2 id='getEquations'>Extract the equations of an object</h2><span id='topic+getEquations'></span><span id='topic+getEquations.odemodel'></span><span id='topic+getEquations.prdfn'></span><span id='topic+getEquations.fn'></span>

<h3>Description</h3>

<p>Extract the equations of an object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getEquations(x, conditions = NULL)

## S3 method for class 'odemodel'
getEquations(x, conditions = NULL)

## S3 method for class 'prdfn'
getEquations(x, conditions = NULL)

## S3 method for class 'fn'
getEquations(x, conditions = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getEquations_+3A_x">x</code></td>
<td>
<p>object from which the equations should be extracted</p>
</td></tr>
<tr><td><code id="getEquations_+3A_conditions">conditions</code></td>
<td>
<p>character or numeric vector specifying the conditions to
which <code>getEquations</code> is restricted. If <code>conditions</code> has length one,
the result is not returned as a list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The equations as list of <code>eqnvec</code> objects.
</p>

<hr>
<h2 id='getFluxes'>Generate list of fluxes from equation list</h2><span id='topic+getFluxes'></span>

<h3>Description</h3>

<p>Generate list of fluxes from equation list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFluxes(eqnlist, type = c("conc", "amount"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getFluxes_+3A_eqnlist">eqnlist</code></td>
<td>
<p>object of class <a href="#topic+eqnlist">eqnlist</a>.</p>
</td></tr>
<tr><td><code id="getFluxes_+3A_type">type</code></td>
<td>
<p>&quot;conc.&quot; or &quot;amount&quot; for fluxes in units of concentrations or
number of molecules.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of named characters, the in- and out-fluxes for each state.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  # Write your example here. You can also add more Start..End blocks if needed.
  # Please mask all output such as print() with the special tag
  #    
  # such that the test is not littered. Statements guarded by  are enabled
  # in the example file which is extracted from this test file. To extract the
  # example run
  #    extractExamples()
  # on the R command line.
    
    ## Generate another equation list
    eq &lt;- eqnlist()
    eq &lt;- addReaction(eq, "A", "pA", "act_A * A * stimulus", "Phosphorylation of A")
    eq &lt;- addReaction(eq, "pA", "A", "deact_A * pA", "Deposphorylation of pA")
    eq &lt;- addReaction(eq, "2*pA", "pA_pA", "form_complex_pA * pA^2", "Complex formation of pA")
    eq &lt;- addReaction(eq, "B", "pB", "act_B * B * pA_pA", "Phosphorylation of B")
    eq &lt;- addReaction(eq, "pB", "B", "deact_B * pB", "Deposphorylation of pB")
    
    ## Extract data.frame of reactions
    reactions &lt;- getReactions(eq)
     print(reactions)
    
    ## Get conserved quantities
    cq &lt;- conservedQuantities(eq$smatrix)
     print(cq)
    
    ## Get fluxes
    fluxes &lt;- getFluxes(eq)
     print(fluxes)
    
    ## Subsetting of equation list
    subeq1 &lt;- subset(eq, "pB" %in% Product)
     print(subeq1)
    subeq2 &lt;- subset(eq, grepl("not_available", Description))
     print(subeq2)
    
    ## Time derivatives of observables
    observables &lt;- eqnvec(pA_obs = "s1*pA", tA_obs = "s2*(A + pA)")
    dobs &lt;- dot(observables, eq)
    
    ## Combined equation vector for ODE and observables
    f &lt;- c(as.eqnvec(eq), dobs)
     print(f)
    
    
  
</code></pre>

<hr>
<h2 id='getLocalDLLs'>Determine loaded DLLs available in working directory</h2><span id='topic+getLocalDLLs'></span>

<h3>Description</h3>

<p>Determine loaded DLLs available in working directory
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLocalDLLs()
</code></pre>


<h3>Value</h3>

<p>Character vector with the names of the loaded DLLs available in the working directory
</p>

<hr>
<h2 id='getObservables'>Extract the observables of an object</h2><span id='topic+getObservables'></span>

<h3>Description</h3>

<p>Extract the observables of an object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getObservables(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getObservables_+3A_x">x</code></td>
<td>
<p>object from which the equations should be extracted</p>
</td></tr>
<tr><td><code id="getObservables_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The equations as a character.
</p>

<hr>
<h2 id='getParameters'>Extract the parameters of an object</h2><span id='topic+getParameters'></span><span id='topic+getParameters.odemodel'></span><span id='topic+getParameters.fn'></span><span id='topic+getParameters.parvec'></span><span id='topic+getParameters.prdframe'></span><span id='topic+getParameters.prdlist'></span><span id='topic+getParameters.eqnlist'></span><span id='topic+getParameters.eventlist'></span>

<h3>Description</h3>

<p>Extract the parameters of an object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getParameters(..., conditions = NULL)

## S3 method for class 'odemodel'
getParameters(x, conditions = NULL)

## S3 method for class 'fn'
getParameters(x, conditions = NULL)

## S3 method for class 'parvec'
getParameters(x, conditions = NULL)

## S3 method for class 'prdframe'
getParameters(x, conditions = NULL)

## S3 method for class 'prdlist'
getParameters(x, conditions = NULL)

## S3 method for class 'eqnlist'
getParameters(x)

## S3 method for class 'eventlist'
getParameters(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getParameters_+3A_...">...</code></td>
<td>
<p>objects from which the parameters should be extracted</p>
</td></tr>
<tr><td><code id="getParameters_+3A_conditions">conditions</code></td>
<td>
<p>character vector specifying the conditions to
which <code>getParameters</code> is restricted</p>
</td></tr>
<tr><td><code id="getParameters_+3A_x">x</code></td>
<td>
<p>object from which the parameters are extracted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The parameters in a format that depends on the class of <code>x</code>.
</p>

<hr>
<h2 id='getReactions'>Generate a table of reactions (data.frame) from an equation list</h2><span id='topic+getReactions'></span>

<h3>Description</h3>

<p>Generate a table of reactions (data.frame) from an equation list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getReactions(eqnlist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getReactions_+3A_eqnlist">eqnlist</code></td>
<td>
<p>object of class <a href="#topic+eqnlist">eqnlist</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> with educts, products, rate and description. The first
column is a check if the reactions comply with reaction kinetics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  # Write your example here. You can also add more Start..End blocks if needed.
  # Please mask all output such as print() with the special tag
  #    
  # such that the test is not littered. Statements guarded by  are enabled
  # in the example file which is extracted from this test file. To extract the
  # example run
  #    extractExamples()
  # on the R command line.
    
    ## Generate another equation list
    eq &lt;- eqnlist()
    eq &lt;- addReaction(eq, "A", "pA", "act_A * A * stimulus", "Phosphorylation of A")
    eq &lt;- addReaction(eq, "pA", "A", "deact_A * pA", "Deposphorylation of pA")
    eq &lt;- addReaction(eq, "2*pA", "pA_pA", "form_complex_pA * pA^2", "Complex formation of pA")
    eq &lt;- addReaction(eq, "B", "pB", "act_B * B * pA_pA", "Phosphorylation of B")
    eq &lt;- addReaction(eq, "pB", "B", "deact_B * pB", "Deposphorylation of pB")
    
    ## Extract data.frame of reactions
    reactions &lt;- getReactions(eq)
     print(reactions)
    
    ## Get conserved quantities
    cq &lt;- conservedQuantities(eq$smatrix)
     print(cq)
    
    ## Get fluxes
    fluxes &lt;- getFluxes(eq)
     print(fluxes)
    
    ## Subsetting of equation list
    subeq1 &lt;- subset(eq, "pB" %in% Product)
     print(subeq1)
    subeq2 &lt;- subset(eq, grepl("not_available", Description))
     print(subeq2)
    
    ## Time derivatives of observables
    observables &lt;- eqnvec(pA_obs = "s1*pA", tA_obs = "s2*(A + pA)")
    dobs &lt;- dot(observables, eq)
    
    ## Combined equation vector for ODE and observables
    f &lt;- c(as.eqnvec(eq), dobs)
     print(f)
    
    
  
</code></pre>

<hr>
<h2 id='ggopen'>Open last plot in external pdf viewer</h2><span id='topic+ggopen'></span>

<h3>Description</h3>

<p>Convenience function to show last plot in an external viewer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggopen(plot = last_plot(), command = "xdg-open", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggopen_+3A_plot">plot</code></td>
<td>
<p><code>ggplot2</code> plot object.</p>
</td></tr>
<tr><td><code id="ggopen_+3A_command">command</code></td>
<td>
<p>character, indicatig which pdf viewer is started.</p>
</td></tr>
<tr><td><code id="ggopen_+3A_...">...</code></td>
<td>
<p>arguments going to <code>ggsave</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='Id'>An identity function which vanishes upon concatenation of fns</h2><span id='topic+Id'></span>

<h3>Description</h3>

<p>An identity function which vanishes upon concatenation of fns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Id()
</code></pre>


<h3>Value</h3>

<p>fn of class idfn
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- Xt()
id &lt;- Id()

(id*x)(1:10, pars = c(a = 1))
(x*id)(1:10, pars = c(a = 1))
str(id*x)
str(x*id)
</code></pre>

<hr>
<h2 id='jakstat'>Time-course data for the JAK-STAT cell signaling pathway</h2><span id='topic+jakstat'></span>

<h3>Description</h3>

<p>Phosphorylated Epo receptor (pEpoR), phosphorylated STAT in the
cytoplasm (tpSTAT) and total STAT (tSTAT) in the cytoplasmhave been 
measured at times 0, ..., 60.
</p>

<hr>
<h2 id='lbind'>Bind named list of data.frames into one data.frame</h2><span id='topic+lbind'></span>

<h3>Description</h3>

<p>Bind named list of data.frames into one data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lbind(mylist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lbind_+3A_mylist">mylist</code></td>
<td>
<p>A named list of data.frame. The data.frames are expected to have the same structure.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each data.frame ist augented by a &quot;condition&quot; column containing the name attributed of
the list entry. Subsequently, the augmented data.frames are bound together by <code>rbind</code>.
</p>


<h3>Value</h3>

<p>data.frame with the originial columns augmented by a &quot;condition&quot; column.
</p>

<hr>
<h2 id='load.parlist'>Construct fitlist from temporary files.</h2><span id='topic+load.parlist'></span>

<h3>Description</h3>

<p>An aborted <code><a href="#topic+mstrust">mstrust</a></code>
leaves behind results of already completed fits. This command loads these
fits into a fitlist.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load.parlist(folder)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load.parlist_+3A_folder">folder</code></td>
<td>
<p>Path to the folder where the fit has left its results.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The command <code><a href="#topic+mstrust">mstrust</a></code> saves
each completed fit along the multi-start sequence such that the results can
be resurected on abortion. This command loads a fitlist from these
intermediate results.
</p>


<h3>Value</h3>

<p>An object of class parlist.
</p>


<h3>Author(s)</h3>

<p>Wolfgang Mader, <a href="mailto:Wolfgang.Mader@fdm.uni-freiburg.de">Wolfgang.Mader@fdm.uni-freiburg.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mstrust">mstrust</a></code>
</p>

<hr>
<h2 id='loadDLL'>Load shared object for a dMod object</h2><span id='topic+loadDLL'></span>

<h3>Description</h3>

<p>Usually when restarting the R session, although all objects are saved in
the workspace, the dynamic libraries are not linked any more. <code>loadDLL</code>
is a wrapper for <code>dyn.load</code> that uses the &quot;modelname&quot; attribute of
dMod objects like prediction functions, observation functions, etc. to
load the corresponding shared object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadDLL(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loadDLL_+3A_...">...</code></td>
<td>
<p>objects of class prdfn, obsfn, parfn, objfn, ...</p>
</td></tr>
</table>

<hr>
<h2 id='long2wide'>Translate long to wide format (inverse of wide2long.matrix)</h2><span id='topic+long2wide'></span>

<h3>Description</h3>

<p>Translate long to wide format (inverse of wide2long.matrix)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>long2wide(out)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="long2wide_+3A_out">out</code></td>
<td>
<p>data.frame in long format</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame in wide format
</p>

<hr>
<h2 id='lsdMod'>Print list of dMod objects in .GlobalEnv</h2><span id='topic+lsdMod'></span>

<h3>Description</h3>

<p>Lists the objects for a set of classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsdMod(
  classlist = c("odemodel", "parfn", "prdfn", "obsfn", "objfn", "datalist"),
  envir = .GlobalEnv
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsdMod_+3A_classlist">classlist</code></td>
<td>
<p>List of object classes to print.</p>
</td></tr>
<tr><td><code id="lsdMod_+3A_envir">envir</code></td>
<td>
<p>Alternative environment to search for objects.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
lsdMod()
lsdMod(classlist = "prdfn", envir = environment(obj)) 

## End(Not run)

</code></pre>

<hr>
<h2 id='match.fnargs'>dMod match function arguments</h2><span id='topic+match.fnargs'></span>

<h3>Description</h3>

<p>The function is exported for dependency reasons
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match.fnargs(arglist, choices)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match.fnargs_+3A_arglist">arglist</code></td>
<td>
<p>list</p>
</td></tr>
<tr><td><code id="match.fnargs_+3A_choices">choices</code></td>
<td>
<p>character</p>
</td></tr>
</table>

<hr>
<h2 id='mname'>Get modelname from single object (used internally)</h2><span id='topic+mname'></span><span id='topic+mname.NULL'></span><span id='topic+mname.character'></span><span id='topic+mname.objfn'></span><span id='topic+mname.fn'></span>

<h3>Description</h3>

<p>Get modelname from single object (used internally)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mname(x, conditions = NULL)

## S3 method for class ''NULL''
mname(x, conditions = NULL)

## S3 method for class 'character'
mname(x, conditions = NULL)

## S3 method for class 'objfn'
mname(x, conditions = NULL)

## S3 method for class 'fn'
mname(x, conditions = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mname_+3A_x">x</code></td>
<td>
<p>dMod object</p>
</td></tr>
<tr><td><code id="mname_+3A_conditions">conditions</code></td>
<td>
<p>character vector of conditions</p>
</td></tr>
</table>

<hr>
<h2 id='modelname'>Get and set modelname</h2><span id='topic+modelname'></span><span id='topic+modelname+3C-'></span><span id='topic+modelname+3C-.fn'></span><span id='topic+modelname+3C-.objfn'></span>

<h3>Description</h3>

<p>The modelname attribute refers to the name of a C file associated with
a dMod function object like prediction-, parameter transformation- or
objective functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modelname(..., conditions = NULL)

modelname(x, ...) &lt;- value

## S3 replacement method for class 'fn'
modelname(x, conditions = NULL, ...) &lt;- value

## S3 replacement method for class 'objfn'
modelname(x, conditions = NULL, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modelname_+3A_...">...</code></td>
<td>
<p>objects of type <code>prdfn</code>, <code>parfn</code>, <code>objfn</code></p>
</td></tr>
<tr><td><code id="modelname_+3A_conditions">conditions</code></td>
<td>
<p>character vector of conditions</p>
</td></tr>
<tr><td><code id="modelname_+3A_x">x</code></td>
<td>
<p>dMod object for which the model name should be set</p>
</td></tr>
<tr><td><code id="modelname_+3A_value">value</code></td>
<td>
<p>character, the new modelname (does not change the C file)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector of model names, corresponding to C files
in the local directory.
</p>

<hr>
<h2 id='msParframe'>Reproducibly construct &quot;random&quot; parframes</h2><span id='topic+msParframe'></span>

<h3>Description</h3>

<p>The output of this function can be used for the <code>center</code> - argument of <code><a href="#topic+mstrust">mstrust</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msParframe(pars, n = 20, seed = 12345, samplefun = stats::rnorm, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="msParframe_+3A_pars">pars</code></td>
<td>
<p>Named vector. If <code>samplefun</code> has a &quot;mean&quot;-argument, values of pars will used as mean</p>
</td></tr>
<tr><td><code id="msParframe_+3A_n">n</code></td>
<td>
<p>Integer how many lines should the parframe have</p>
</td></tr>
<tr><td><code id="msParframe_+3A_seed">seed</code></td>
<td>
<p>Seed for the random number generator</p>
</td></tr>
<tr><td><code id="msParframe_+3A_samplefun">samplefun</code></td>
<td>
<p>random number generator: <code><a href="stats.html#topic+rnorm">rnorm</a></code>, <code><a href="stats.html#topic+runif">runif</a></code>, etc...</p>
</td></tr>
<tr><td><code id="msParframe_+3A_...">...</code></td>
<td>
<p>arguments going to samplefun</p>
</td></tr>
</table>


<h3>Value</h3>

<p>parframe (without metanames)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mstrust">mstrust</a></code> and <code><a href="#topic+parframe">parframe</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>msParframe(c(a = 0, b = 100000), 5)

# Parameter specific sigma
msParframe(c(a = 0, b = 100000), 5, samplefun = rnorm, sd = c(100, 0.5))
</code></pre>

<hr>
<h2 id='mstrust'>Non-Linear Optimization, multi start</h2><span id='topic+mstrust'></span>

<h3>Description</h3>

<p>Wrapper around <code><a href="#topic+trust">trust</a></code> allowing for multiple fits 
from randomly chosen initial values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mstrust(
  objfun,
  center,
  studyname,
  rinit = 0.1,
  rmax = 10,
  fits = 20,
  cores = 1,
  samplefun = "rnorm",
  resultPath = ".",
  stats = FALSE,
  output = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mstrust_+3A_objfun">objfun</code></td>
<td>
<p>Objective function, see <code><a href="#topic+trust">trust</a></code>.</p>
</td></tr>
<tr><td><code id="mstrust_+3A_center">center</code></td>
<td>
<p>Parameter values around which the initial values for each fit 
are randomly sampled. The initial values handed to <a href="#topic+trust">trust</a> are the sum
of center and the output of <span class="option">samplefun</span>, center + 
<span class="option">samplefun</span>. See <code><a href="#topic+trust">trust</a></code>, parinit.
<code>center</code> Can also be a parframe, then the parameter values are taken 
from the parframe. In this case, the <code>fits</code> argument is overwritten.
To use a reproducible set of initial guesses, generate center with 
<code><a href="#topic+msParframe">msParframe</a></code></p>
</td></tr>
<tr><td><code id="mstrust_+3A_studyname">studyname</code></td>
<td>
<p>The names of the study or fit. This name is used to 
determine filenames for interim and final results. See Details.</p>
</td></tr>
<tr><td><code id="mstrust_+3A_rinit">rinit</code></td>
<td>
<p>Starting trust region radius, see <code><a href="#topic+trust">trust</a></code>.</p>
</td></tr>
<tr><td><code id="mstrust_+3A_rmax">rmax</code></td>
<td>
<p>Maximum allowed trust region radius, see <code><a href="#topic+trust">trust</a></code>.</p>
</td></tr>
<tr><td><code id="mstrust_+3A_fits">fits</code></td>
<td>
<p>Number of fits (jobs).</p>
</td></tr>
<tr><td><code id="mstrust_+3A_cores">cores</code></td>
<td>
<p>Number of cores for job parallelization.</p>
</td></tr>
<tr><td><code id="mstrust_+3A_samplefun">samplefun</code></td>
<td>
<p>Function to sample random initial values. It is assumed, 
that <span class="option">samplefun</span> has a named parameter &quot;n&quot; which defines how many 
random numbers are to be returned, such as for <code><a href="stats.html#topic+rnorm">rnorm</a></code> or 
<code><a href="stats.html#topic+runif">runif</a></code>. By default <code><a href="stats.html#topic+rnorm">rnorm</a></code> is used. Parameteres 
for samplefun are simply appended as named parameters to the mstrust call 
and automatically handed to samplefun by matching parameter names.</p>
</td></tr>
<tr><td><code id="mstrust_+3A_resultpath">resultPath</code></td>
<td>
<p>character indicating the folder where the results should 
be stored. Defaults to &quot;.&quot;.</p>
</td></tr>
<tr><td><code id="mstrust_+3A_stats">stats</code></td>
<td>
<p>If true, the same summary statistic as written to the logfile is
printed to command line on mstrust completion.</p>
</td></tr>
<tr><td><code id="mstrust_+3A_output">output</code></td>
<td>
<p>logical. If true, writes output to the disc.</p>
</td></tr>
<tr><td><code id="mstrust_+3A_...">...</code></td>
<td>
<p>Additional parameters handed to trust(), samplefun(), or the 
objective function by matching parameter names. All unmatched parameters 
are handed to the objective function objfun(). The log file starts with a 
table telling which parameter was assigend to which function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By running multiple fits starting at randomly chosen inital 
parameters, the chisquare landscape can be explored using a deterministic 
optimizer. Here, <code><a href="#topic+trust">trust</a></code> is used for optimization. The standard
procedure to obtain random initial values is to sample random variables 
from a uniform distribution (<code><a href="stats.html#topic+rnorm">rnorm</a></code>) and adding these to 
<span class="option">center</span>. It is, however, possible, to employ any other sampling 
strategy by handing the respective function to mstrust(), 
<span class="option">samplefun</span>.
</p>
<p>In case a special sampling is required, a customized sampling function can 
be used. If, e.g., inital values leading to a non-physical systems are to 
be discarded upfront, the objective function can be addapted accordingly.
</p>
<p>All started fits either lead to an error or complete converged or
unconverged. A statistics about the return status of fits can be shown by
setting <span class="option">stats</span> to TRUE.
</p>
<p>Fit final and intermediat results are stored under <span class="option">studyname</span>. For
each run of mstrust for the same study name, a folder under
<span class="option">studyname</span> of the form &quot;trial-x-date&quot; is created. &quot;x&quot; is the number
of the trial, date is the current time stamp. In this folder, the
intermediate results are stored. These intermediate results can be loaded
by <code><a href="#topic+load.parlist">load.parlist</a></code>. These are removed on successfull completion
of mstrust. In this case, the final list of fit parameters
(parameterList.Rda) and the fit log (mstrust.log) are found instead.
</p>


<h3>Value</h3>

<p>A parlist holding errored and converged fits.
</p>


<h3>Author(s)</h3>

<p>Wolfgang Mader, <a href="mailto:Wolfgang.Mader@fdm.uni-freiburg.de">Wolfgang.Mader@fdm.uni-freiburg.de</a>
</p>


<h3>See Also</h3>

<p>1. <code><a href="#topic+trust">trust</a></code>, for the used optimizer,
2. <code><a href="stats.html#topic+rnorm">rnorm</a></code>, <code><a href="stats.html#topic+runif">runif</a></code> for two common sampling functions,
3. <code><a href="#topic+msParframe">msParframe</a></code> for passing a reproducible set of random initial 
guesses to mstrust,
4. <code><a href="#topic+as.parframe">as.parframe</a></code> for formatting the output to a handy table
</p>

<hr>
<h2 id='nll'>Compute the negative log-likelihood</h2><span id='topic+nll'></span>

<h3>Description</h3>

<p>Compute the negative log-likelihood
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nll(nout)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nll_+3A_nout">nout</code></td>
<td>
<p>data.frame (result of <a href="#topic+res">res</a>) or object of class <a href="#topic+objframe">objframe</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with entries value (numeric, the weighted residual sum of squares), 
gradient (numeric, gradient) and 
hessian (matrix of type numeric).
</p>

<hr>
<h2 id='normL2'>L2 norm between data and model prediction</h2><span id='topic+normL2'></span>

<h3>Description</h3>

<p>For parameter estimation and optimization, an objective function
is needed. <code>normL2</code> returns an objective function for the L2 norm of
data and model prediction. The resulting objective function can be used for
optimization with the trust optimizer, see <a href="#topic+mstrust">mstrust</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normL2(data, x, errmodel = NULL, times = NULL, attr.name = "data")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normL2_+3A_data">data</code></td>
<td>
<p>object of class <a href="#topic+datalist">datalist</a></p>
</td></tr>
<tr><td><code id="normL2_+3A_x">x</code></td>
<td>
<p>object of class <a href="#topic+prdfn">prdfn</a></p>
</td></tr>
<tr><td><code id="normL2_+3A_errmodel">errmodel</code></td>
<td>
<p>object of class <a href="#topic+obsfn">obsfn</a>. <code>errmodel</code> does not need to be defined for all conditions.</p>
</td></tr>
<tr><td><code id="normL2_+3A_times">times</code></td>
<td>
<p>numeric vector, additional time points where the prediction function is 
evaluated. If NULL, time points are extacted from the datalist solely. If the prediction
function makes use of events, hand over event <code>times</code> here.</p>
</td></tr>
<tr><td><code id="normL2_+3A_attr.name">attr.name</code></td>
<td>
<p>character. The constraint value is additionally returned in an 
attributed with this name</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Objective functions can be combined by the &quot;+&quot; operator, see <a href="#topic+sumobjfn">sumobjfn</a>.
</p>


<h3>Value</h3>

<p>Object of class <code>obsfn</code>, i.e. a function 
<code>obj(..., fixed, deriv, conditions, env)</code> that returns an objective list,
<a href="#topic+objlist">objlist</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate a prediction function

times &lt;- 0:5
grid &lt;- data.frame(name = "A", time = times, row.names = paste0("p", times))
x &lt;- Xd(grid, condition = "C1")

pars &lt;- structure(rep(0, nrow(grid)), names = row.names(grid))

## Simulate data
data.list &lt;- lapply(1:3, function(i) {
  prediction &lt;- x(times, pars + rnorm(length(pars), 0, 1))
  cbind(wide2long(prediction), sigma = 1)
})

data &lt;- as.datalist(do.call(rbind, data.list))

## Generate objective function based on data and model
## Then fit the data and plot the result
obj &lt;- normL2(data, x)
myfit &lt;- trust(obj, pars, rinit = 1, rmax = 10)
plot(x(times, myfit$argument), data)
</code></pre>

<hr>
<h2 id='nullZ'>Find integer-null space of matrix A</h2><span id='topic+nullZ'></span>

<h3>Description</h3>

<p>Find integer-null space of matrix A
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nullZ(A, tol = sqrt(.Machine$double.eps))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nullZ_+3A_a">A</code></td>
<td>
<p>matrix for which the null space is searched</p>
</td></tr>
<tr><td><code id="nullZ_+3A_tol">tol</code></td>
<td>
<p>tolerance to find pivots in rref-function below</p>
</td></tr>
</table>


<h3>Value</h3>

<p>null space of A with only integers in it
</p>


<h3>Author(s)</h3>

<p>Malenka Mader, <a href="mailto:Malenka.Mader@fdm.uni-freiburg.de">Malenka.Mader@fdm.uni-freiburg.de</a>
</p>

<hr>
<h2 id='objframe'>Objective frame</h2><span id='topic+objframe'></span>

<h3>Description</h3>

<p>An objective frame is supposed to store the residuals of a model prediction
with respect to a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>objframe(mydata, deriv = NULL, deriv.err = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="objframe_+3A_mydata">mydata</code></td>
<td>
<p>data.frame as being generated by <a href="#topic+res">res</a>.</p>
</td></tr>
<tr><td><code id="objframe_+3A_deriv">deriv</code></td>
<td>
<p>matrix of the derivatives of the residuals with respect to parameters.</p>
</td></tr>
<tr><td><code id="objframe_+3A_deriv.err">deriv.err</code></td>
<td>
<p>matrix of the derivatives of the error model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>objframe</code>, i.e. a data frame with attribute &quot;deriv&quot;.
</p>

<hr>
<h2 id='objlist'>Generate objective list</h2><span id='topic+objlist'></span>

<h3>Description</h3>

<p>An objective list contains an objective value, a gradient, and a Hessian matrix.
</p>
<p>Objective lists can contain additional numeric attributes that are preserved or
combined with the corresponding attributes of another objective list when
both are added by the &quot;+&quot; operator, see <a href="#topic+sumobjlist">sumobjlist</a>.
</p>
<p>Objective lists are returned by objective functions as being generated
by <a href="#topic+normL2">normL2</a>, <a href="#topic+constraintL2">constraintL2</a>, <a href="#topic+priorL2">priorL2</a> and <a href="#topic+datapointL2">datapointL2</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>objlist(value, gradient, hessian)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="objlist_+3A_value">value</code></td>
<td>
<p>numeric of length 1</p>
</td></tr>
<tr><td><code id="objlist_+3A_gradient">gradient</code></td>
<td>
<p>named numeric</p>
</td></tr>
<tr><td><code id="objlist_+3A_hessian">hessian</code></td>
<td>
<p>matrix with rownames and colnames according to gradient names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>objlist</code>
</p>

<hr>
<h2 id='obsfn'>Observation function</h2><span id='topic+obsfn'></span>

<h3>Description</h3>

<p>An observation function is a function is that is concatenated
with a prediction function via <a href="#topic+prodfn">prodfn</a> to yield a new prediction function,
see <a href="#topic+prdfn">prdfn</a>. Observation functions are generated by <a href="#topic+Y">Y</a>. Handling
of the conditions is then organized by the <code>obsfn</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obsfn(X2Y, parameters = NULL, condition = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="obsfn_+3A_x2y">X2Y</code></td>
<td>
<p>the low-level observation function generated e.g. by <a href="#topic+Y">Y</a>.</p>
</td></tr>
<tr><td><code id="obsfn_+3A_parameters">parameters</code></td>
<td>
<p>character vector with parameter names</p>
</td></tr>
<tr><td><code id="obsfn_+3A_condition">condition</code></td>
<td>
<p>character, the condition name</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Observation functions can be &quot;added&quot; by the &quot;+&quot; operator, see <a href="#topic+sumfn">sumfn</a>. Thereby,
observations for different conditions are merged or, overwritten. Observation functions can
also be concatenated with other functions, e.g. observation functions (<a href="#topic+obsfn">obsfn</a>) or
prediction functions (<a href="#topic+prdfn">prdfn</a>) by the &quot;*&quot; operator, see <a href="#topic+prodfn">prodfn</a>.
</p>


<h3>Value</h3>

<p>Object of class <code>obsfn</code>, i.e. a function <code>x(..., fixed, deriv, conditions, env)</code>
which returns a <a href="#topic+prdlist">prdlist</a>. The arguments <code>out</code> (prediction) and <code>pars</code> (parameter values)
should be passed via the <code>...</code> argument.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define a time grid on which to make a prediction by peace-wise linear function.
# Then define a (generic) prediction function based on thid grid.
times &lt;- 0:5
grid &lt;- data.frame(name = "A", time = times, row.names = paste0("p", times))
x &lt;- Xd(grid)

# Define an observable and an observation function
observables &lt;- eqnvec(Aobs = "s*A")
g &lt;- Y(g = observables, f = NULL, states = "A", parameters = "s")

# Collect parameters and define an overarching parameter transformation
# for two "experimental condtions".
dynpars &lt;- attr(x, "parameters")
obspars &lt;- attr(g, "parameters")
innerpars &lt;- c(dynpars, obspars)

trafo &lt;- structure(innerpars, names = innerpars)
trafo_C1 &lt;- replaceSymbols(innerpars, paste(innerpars, "C1", sep = "_"), trafo)
trafo_C2 &lt;- replaceSymbols(innerpars, paste(innerpars, "C2", sep = "_"), trafo)

p &lt;- NULL
p &lt;- p + P(trafo = trafo_C1, condition = "C1")
p &lt;- p + P(trafo = trafo_C2, condition = "C2")

# Collect outer (overarching) parameters and 
# initialize with random values
outerpars &lt;- attr(p, "parameters")
pars &lt;- structure(runif(length(outerpars), 0, 1), names = outerpars)

# Predict internal/unobserved states
out1 &lt;- (x*p)(times, pars)
plot(out1)

# Predict observed states in addition to unobserved
out2 &lt;- (g*x*p)(times, pars)
plot(out2)
</code></pre>

<hr>
<h2 id='odemodel'>Generate the model objects for use in Xs (models with sensitivities)</h2><span id='topic+odemodel'></span>

<h3>Description</h3>

<p>Generate the model objects for use in Xs (models with sensitivities)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>odemodel(
  f,
  deriv = TRUE,
  forcings = NULL,
  events = NULL,
  outputs = NULL,
  fixed = NULL,
  estimate = NULL,
  modelname = "odemodel",
  solver = c("deSolve", "Sundials"),
  gridpoints = NULL,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="odemodel_+3A_f">f</code></td>
<td>
<p>Something that can be converted to <a href="#topic+eqnvec">eqnvec</a>,
e.g. a named character vector with the ODE</p>
</td></tr>
<tr><td><code id="odemodel_+3A_deriv">deriv</code></td>
<td>
<p>logical, generate sensitivities or not</p>
</td></tr>
<tr><td><code id="odemodel_+3A_forcings">forcings</code></td>
<td>
<p>Character vector with the names of the forcings</p>
</td></tr>
<tr><td><code id="odemodel_+3A_events">events</code></td>
<td>
<p>data.frame of events with columns &quot;var&quot; (character, the name of the state to be
affected), &quot;time&quot; (character or numeric, time point), &quot;value&quot; (character or numeric, value),
&quot;method&quot; (character, either
&quot;replace&quot; or &quot;add&quot;). See <a href="deSolve.html#topic+events">events</a>. Events need to be defined here if they contain
parameters, like the event time or value. If both, time and value are purely numeric, they
can be specified in <code><a href="#topic+Xs">Xs</a>()</code>, too.</p>
</td></tr>
<tr><td><code id="odemodel_+3A_outputs">outputs</code></td>
<td>
<p>Named character vector for additional output variables.</p>
</td></tr>
<tr><td><code id="odemodel_+3A_fixed">fixed</code></td>
<td>
<p>Character vector with the names of parameters (initial values and dynamic) for which
no sensitivities are required (will speed up the integration).</p>
</td></tr>
<tr><td><code id="odemodel_+3A_estimate">estimate</code></td>
<td>
<p>Character vector specifying parameters (initial values and dynamic) for which
sensitivities are returned. If estimate is specified, it overwrites 'fixed'.</p>
</td></tr>
<tr><td><code id="odemodel_+3A_modelname">modelname</code></td>
<td>
<p>Character, the name of the C file being generated.</p>
</td></tr>
<tr><td><code id="odemodel_+3A_solver">solver</code></td>
<td>
<p>Solver for which the equations are prepared.</p>
</td></tr>
<tr><td><code id="odemodel_+3A_gridpoints">gridpoints</code></td>
<td>
<p>Integer, the minimum number of time points where the ODE is evaluated internally</p>
</td></tr>
<tr><td><code id="odemodel_+3A_verbose">verbose</code></td>
<td>
<p>Print compiler output to R command line.</p>
</td></tr>
<tr><td><code id="odemodel_+3A_...">...</code></td>
<td>
<p>Further arguments being passed to funC.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with <code>func</code> (ODE object) and <code>extended</code> (ODE+Sensitivities object)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

## Generate a compiled ODE model from an equation vector
## The model will not return sensitivities for "switch"
## Files will be generated in your working directory!

f &lt;- eqnvec(A = "-k*A + switch*F")
model &lt;- odemodel(f, forcings = "F", fixed = "switch")
print(model)

## Generate the same model from an equation list
f &lt;- addReaction(NULL, from = "", to = "A", rate = "switch*F", description = "production")
f &lt;- addReaction(f   , from = "A", to = "", rate = "k*A", description = "degradation")
print(f)

model &lt;- odemodel(f, forcings = "F", fixed = "switch")
print(model)


# create forcings
forc1 &lt;- data.frame(name = "F", time = seq(0,5, 0.1), value = sin(seq(0,5,0.1)))
forc2 &lt;- data.frame(name = "F", time = seq(0,5, 0.1), value = exp(-seq(0,5,0.1)))
forc3 &lt;- data.frame(name = "F", time= 0,              value = 0.1)


x &lt;- Xs(model, forc1, condition = "forc1") + 
  Xs(model, forc2, condition = "forc2") + 
  Xs(model, forc3, condition = "forc3")

g &lt;- Y(c(out1 = "F * A", out2 = "F"), x)

times &lt;-  seq(0,5, 0.001)
pars &lt;- setNames(runif(length(getParameters(x))), getParameters(x))

pred &lt;- (g*x)(times, pars)  
plot(pred)



## End(Not run)
</code></pre>

<hr>
<h2 id='P'>Generate a parameter transformation function</h2><span id='topic+P'></span>

<h3>Description</h3>

<p>Generate parameter transformation function from a
named character vector or object of class <a href="#topic+eqnvec">eqnvec</a>. This is a wrapper
function for <a href="#topic+Pexpl">Pexpl</a> and <a href="#topic+Pimpl">Pimpl</a>. See for more details there.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>P(
  trafo = NULL,
  parameters = NULL,
  condition = NULL,
  attach.input = FALSE,
  keep.root = TRUE,
  compile = FALSE,
  modelname = NULL,
  method = c("explicit", "implicit"),
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="P_+3A_trafo">trafo</code></td>
<td>
<p>object of class <code>eqnvec</code> or named character or list thereof. In case,
trafo is a list, <code>P()</code> is called on each element and conditions are assumed to be
the list names.</p>
</td></tr>
<tr><td><code id="P_+3A_parameters">parameters</code></td>
<td>
<p>character vector</p>
</td></tr>
<tr><td><code id="P_+3A_condition">condition</code></td>
<td>
<p>character, the condition for which the transformation is generated</p>
</td></tr>
<tr><td><code id="P_+3A_attach.input">attach.input</code></td>
<td>
<p>attach those incoming parameters to output which are not overwritten by
the parameter transformation.</p>
</td></tr>
<tr><td><code id="P_+3A_keep.root">keep.root</code></td>
<td>
<p>logical, applies for <code>method = "implicit"</code>. The root of the last
evaluation of the parameter transformation function is saved as guess for the next 
evaluation.</p>
</td></tr>
<tr><td><code id="P_+3A_compile">compile</code></td>
<td>
<p>logical, compile the function (see <a href="#topic+funC0">funC0</a>)</p>
</td></tr>
<tr><td><code id="P_+3A_modelname">modelname</code></td>
<td>
<p>character, see <a href="#topic+funC0">funC0</a></p>
</td></tr>
<tr><td><code id="P_+3A_method">method</code></td>
<td>
<p>character, either <code>"explicit"</code> or <code>"implicit"</code></p>
</td></tr>
<tr><td><code id="P_+3A_verbose">verbose</code></td>
<td>
<p>Print out information during compilation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <a href="#topic+parfn">parfn</a>.
</p>

<hr>
<h2 id='parfn'>Parameter transformation function</h2><span id='topic+parfn'></span>

<h3>Description</h3>

<p>Generate functions that transform one parameter vector into another
by means of a transformation, pushing forward the jacobian matrix
of the original parameter.
Usually, this function is called internally, e.g. by <a href="#topic+P">P</a>.
However, you can use it to add your own specialized parameter
transformations to the general framework.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parfn(p2p, parameters = NULL, condition = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parfn_+3A_p2p">p2p</code></td>
<td>
<p>a transformation function for one condition, i.e. a function
<code>p2p(p, fixed, deriv)</code> which translates a parameter vector <code>p</code>
and a vector of fixed parameter values <code>fixed</code> into a new parameter
vector. If <code>deriv = TRUE</code>, the function should return an attribute
<code>deriv</code> with the Jacobian matrix of the parameter transformation.</p>
</td></tr>
<tr><td><code id="parfn_+3A_parameters">parameters</code></td>
<td>
<p>character vector, the parameters accepted by the function</p>
</td></tr>
<tr><td><code id="parfn_+3A_condition">condition</code></td>
<td>
<p>character, the condition for which the transformation is defined</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class <code>parfn</code>, i.e. a function <code>p(..., fixed, deriv,
 conditions, env)</code>. The argument <code>pars</code> should be passed via the <code>...</code>
argument.
</p>
<p>Contains attributes &quot;mappings&quot;, a list of <code>p2p</code>
functions, &quot;parameters&quot;, the union of parameters acceted by the mappings and
&quot;conditions&quot;, the total set of conditions.
</p>


<h3>See Also</h3>

<p><a href="#topic+sumfn">sumfn</a>, <a href="#topic+P">P</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define a time grid on which to make a prediction by peace-wise linear function.
# Then define a (generic) prediction function based on thid grid.
times &lt;- 0:5
grid &lt;- data.frame(name = "A", time = times, row.names = paste0("p", times))
x &lt;- Xd(grid)

# Define an observable and an observation function
observables &lt;- eqnvec(Aobs = "s*A")
g &lt;- Y(g = observables, f = NULL, states = "A", parameters = "s")

# Collect parameters and define an overarching parameter transformation
# for two "experimental condtions".
dynpars &lt;- attr(x, "parameters")
obspars &lt;- attr(g, "parameters")
innerpars &lt;- c(dynpars, obspars)

trafo &lt;- structure(innerpars, names = innerpars)
trafo_C1 &lt;- replaceSymbols(innerpars, paste(innerpars, "C1", sep = "_"), trafo)
trafo_C2 &lt;- replaceSymbols(innerpars, paste(innerpars, "C2", sep = "_"), trafo)

p &lt;- NULL
p &lt;- p + P(trafo = trafo_C1, condition = "C1")
p &lt;- p + P(trafo = trafo_C2, condition = "C2")

# Collect outer (overarching) parameters and 
# initialize with random values
outerpars &lt;- attr(p, "parameters")
pars &lt;- structure(runif(length(outerpars), 0, 1), names = outerpars)

# Predict internal/unobserved states
out1 &lt;- (x*p)(times, pars)
plot(out1)

# Predict observed states in addition to unobserved
out2 &lt;- (g*x*p)(times, pars)
plot(out2)
</code></pre>

<hr>
<h2 id='parframe'>Generate a parameter frame</h2><span id='topic+parframe'></span><span id='topic+is.parframe'></span><span id='topic++5B.parframe'></span><span id='topic+subset.parframe'></span>

<h3>Description</h3>

<p>A parameter frame is a data.frame where the rows correspond to different
parameter specifications. The columns are divided into three parts. (1) the meta-information
columns (e.g. index, value, constraint, etc.), (2) the attributes of an objective function
(e.g. data contribution and prior contribution) and (3) the parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parframe(
  x = NULL,
  parameters = colnames(x),
  metanames = NULL,
  obj.attributes = NULL
)

is.parframe(x)

## S3 method for class 'parframe'
x[i = NULL, j = NULL, drop = FALSE]

## S3 method for class 'parframe'
subset(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parframe_+3A_x">x</code></td>
<td>
<p>data.frame.</p>
</td></tr>
<tr><td><code id="parframe_+3A_parameters">parameters</code></td>
<td>
<p>character vector, the names of the parameter columns.</p>
</td></tr>
<tr><td><code id="parframe_+3A_metanames">metanames</code></td>
<td>
<p>character vector, the names of the meta-information columns.</p>
</td></tr>
<tr><td><code id="parframe_+3A_obj.attributes">obj.attributes</code></td>
<td>
<p>character vector, the names of the objective function attributes.</p>
</td></tr>
<tr><td><code id="parframe_+3A_i">i</code></td>
<td>
<p>row index in any format</p>
</td></tr>
<tr><td><code id="parframe_+3A_j">j</code></td>
<td>
<p>column index in any format</p>
</td></tr>
<tr><td><code id="parframe_+3A_drop">drop</code></td>
<td>
<p>logical. If TRUE the result is coerced to the lowest possible dimension</p>
</td></tr>
<tr><td><code id="parframe_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Parameter frames can be subsetted either by <code>[ , ]</code> or by <code>subset</code>. If
<code>[ , index]</code> is used, the names of the removed columns will also be removed from
the corresponding attributes, i.e. metanames, obj.attributes and parameters.
</p>


<h3>Value</h3>

<p>An object of class <code>parframe</code>, i.e. a data.frame with attributes for the
different names. Inherits from data.frame.
</p>


<h3>See Also</h3>

<p><a href="#topic+profile">profile</a>, <a href="#topic+mstrust">mstrust</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate a prediction function
regfn &lt;- c(y = "sin(a*time)")

g &lt;- Y(regfn, parameters = "a")
x &lt;- Xt(condition = "C1")

## Generate data
data &lt;- datalist(
  C1 = data.frame(
    name = "y",
    time = 1:5,
    value = sin(1:5) + rnorm(5, 0, .1),
    sigma = .1
  )
)

## Initialize parameters and time 
pars &lt;- c(a = 1)
times &lt;- seq(0, 5, .1)

plot((g*x)(times, pars), data)

## Do many fits from random positions and store them into parlist
out &lt;- as.parlist(lapply(1:50, function(i) {
  trust(normL2(data, g*x), pars + rnorm(length(pars), 0, 1), rinit = 1, rmax = 10)
}))

summary(out)

## Reduce parlist to parframe
parframe &lt;- as.parframe(out)
plotValues(parframe)

## Reduce parframe to best fit
bestfit &lt;- as.parvec(parframe)
plot((g*x)(times, bestfit), data)


</code></pre>

<hr>
<h2 id='parlist'>Parameter list</h2><span id='topic+parlist'></span><span id='topic+as.parlist'></span><span id='topic+summary.parlist'></span><span id='topic+c.parlist'></span>

<h3>Description</h3>

<p>The special use of a parameter list is to save
the outcome of multiple optimization runs provided by <a href="#topic+mstrust">mstrust</a>,
into one list.
</p>
<p>Fitlists carry an fit index which must be held unique on merging
multiple fitlists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parlist(...)

as.parlist(x = NULL)

## S3 method for class 'parlist'
summary(object, ...)

## S3 method for class 'parlist'
c(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parlist_+3A_...">...</code></td>
<td>
<p>Objects to be coerced to parameter list.</p>
</td></tr>
<tr><td><code id="parlist_+3A_x">x</code></td>
<td>
<p>list of lists, as returned by <code>trust</code></p>
</td></tr>
<tr><td><code id="parlist_+3A_object">object</code></td>
<td>
<p>a parlist</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Wolfgang Mader, <a href="mailto:Wolfgang.Mader@fdm.uni-freiburg.de">Wolfgang.Mader@fdm.uni-freiburg.de</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+load.parlist">load.parlist</a>, <a href="#topic+plot.parlist">plot.parlist</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate a prediction function
regfn &lt;- c(y = "sin(a*time)")

g &lt;- Y(regfn, parameters = "a")
x &lt;- Xt(condition = "C1")

## Generate data
data &lt;- datalist(
  C1 = data.frame(
    name = "y",
    time = 1:5,
    value = sin(1:5) + rnorm(5, 0, .1),
    sigma = .1
  )
)

## Initialize parameters and time 
pars &lt;- c(a = 1)
times &lt;- seq(0, 5, .1)

plot((g*x)(times, pars), data)

## Do many fits from random positions and store them into parlist
out &lt;- as.parlist(lapply(1:50, function(i) {
  trust(normL2(data, g*x), pars + rnorm(length(pars), 0, 1), rinit = 1, rmax = 10)
}))

summary(out)

## Reduce parlist to parframe
parframe &lt;- as.parframe(out)
plotValues(parframe)

## Reduce parframe to best fit
bestfit &lt;- as.parvec(parframe)
plot((g*x)(times, bestfit), data)


</code></pre>

<hr>
<h2 id='parvec'>Parameter vector</h2><span id='topic+parvec'></span><span id='topic+as.parvec'></span><span id='topic+as.parvec.numeric'></span><span id='topic++5B.parvec'></span><span id='topic+c.parvec'></span>

<h3>Description</h3>

<p>A parameter vector is a named numeric vector (the parameter values)
together with a &quot;deriv&quot; attribute
(the Jacobian of a parameter transformation by which the parameter vector was generated).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parvec(..., deriv = NULL)

as.parvec(x, ...)

## S3 method for class 'numeric'
as.parvec(x, names = NULL, deriv = NULL, ...)

## S3 method for class 'parvec'
x[..., drop = FALSE]

## S3 method for class 'parvec'
c(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parvec_+3A_...">...</code></td>
<td>
<p>objects to be concatenated</p>
</td></tr>
<tr><td><code id="parvec_+3A_deriv">deriv</code></td>
<td>
<p>matrix with rownames (according to names of <code>...</code>) and colnames
according to the names of the parameter by which the parameter vector was generated.</p>
</td></tr>
<tr><td><code id="parvec_+3A_x">x</code></td>
<td>
<p>numeric or named numeric, the parameter values</p>
</td></tr>
<tr><td><code id="parvec_+3A_names">names</code></td>
<td>
<p>optional character vector, the parameter names. Otherwise, names
are taken from <code>x</code>.</p>
</td></tr>
<tr><td><code id="parvec_+3A_drop">drop</code></td>
<td>
<p>logical, drop empty columns in Jacobian after subsetting. 
ATTENTION: Be careful with this option. The default behavior is to keep
the columns in the Jacobian. This can lead to unintended results when
subsetting the parvec and using it e.g. in another parameter
transformation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>parvec</code>, i.e. a named numeric vector with attribute &quot;deriv&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a parameter vector
v &lt;- parvec(a = 2, b = 3)
print(v)
print(getDerivs(v))

# Parameter vector from a named numeric
M &lt;- matrix(c(1, 1, 0, 1), 
	    nrow = 2, ncol = 2, 
	    dimnames = list(c("a", "b"), c("A", "B"))
    )
v &lt;- as.parvec(x = c(a = 2, b = 3), deriv = M)
print(v)
print(getDerivs(v))

# Subsetting of parameter vectors
# Case 1: Dependencies in the Jacobian are maintained
w &lt;- v[1]
print(w)
print(getDerivs(w))

# Case 2: Dependencies are dropped
w &lt;- v[1, drop = TRUE]
print(w)
print(getDerivs(w))

# Concatenating parameter vectors
w &lt;- parvec(c = 4, d = 5)
print(c(v, w))
print(getDerivs(c(v, w)))
</code></pre>

<hr>
<h2 id='Pexpl'>Parameter transformation</h2><span id='topic+Pexpl'></span>

<h3>Description</h3>

<p>Parameter transformation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Pexpl(
  trafo,
  parameters = NULL,
  attach.input = FALSE,
  condition = NULL,
  compile = FALSE,
  modelname = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Pexpl_+3A_trafo">trafo</code></td>
<td>
<p>Named character vector. Names correspond to the parameters being fed into
the model (the inner parameters). The elements of tafo are equations that express 
the inner parameters in terms of other parameters (the outer parameters)</p>
</td></tr>
<tr><td><code id="Pexpl_+3A_parameters">parameters</code></td>
<td>
<p>Character vector. Optional. If given, the generated parameter
transformation returns values for each element in <code>parameters</code>. If elements of
<code>parameters</code> are not in <code>names(trafo)</code> the identity transformation is assumed.</p>
</td></tr>
<tr><td><code id="Pexpl_+3A_attach.input">attach.input</code></td>
<td>
<p>attach those incoming parameters to output which are not overwritten by
the parameter transformation.</p>
</td></tr>
<tr><td><code id="Pexpl_+3A_condition">condition</code></td>
<td>
<p>character, the condition for which the transformation is generated</p>
</td></tr>
<tr><td><code id="Pexpl_+3A_compile">compile</code></td>
<td>
<p>Logical, compile the function (see <a href="#topic+funC0">funC0</a>)</p>
</td></tr>
<tr><td><code id="Pexpl_+3A_modelname">modelname</code></td>
<td>
<p>Character, used if <code>compile = TRUE</code>, sets a fixed filename for the
C file.</p>
</td></tr>
<tr><td><code id="Pexpl_+3A_verbose">verbose</code></td>
<td>
<p>Print compiler output to R command line.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function <code>p2p(p, fixed = NULL, deriv = TRUE)</code> representing the parameter 
transformation. Here, <code>p</code> is a named numeric vector with the values of the outer parameters,
<code>fixed</code> is a named numeric vector with values of the outer parameters being considered
as fixed (no derivatives returned) and <code>deriv</code> is a logical determining whether the Jacobian
of the parameter transformation is returned as attribute &quot;deriv&quot;.
</p>


<h3>See Also</h3>

<p><a href="#topic+Pimpl">Pimpl</a> for implicit parameter transformations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
logtrafo &lt;- c(k1 = "exp(logk1)", k2 = "exp(logk2)", 
              A = "exp(logA)", B = "exp(logB)")
p_log &lt;- P(logtrafo)

pars &lt;- c(logk1 = 1, logk2 = -1, logA = 0, logB = 0)
out &lt;- p_log(pars)
getDerivs(out)
</code></pre>

<hr>
<h2 id='Pimpl'>Parameter transformation (implicit)</h2><span id='topic+Pimpl'></span>

<h3>Description</h3>

<p>Parameter transformation (implicit)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Pimpl(
  trafo,
  parameters = NULL,
  condition = NULL,
  keep.root = TRUE,
  positive = TRUE,
  compile = FALSE,
  modelname = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Pimpl_+3A_trafo">trafo</code></td>
<td>
<p>Named character vector defining the equations to be set to zero. 
Names correspond to dependent variables.</p>
</td></tr>
<tr><td><code id="Pimpl_+3A_parameters">parameters</code></td>
<td>
<p>Character vector, the independent variables.</p>
</td></tr>
<tr><td><code id="Pimpl_+3A_condition">condition</code></td>
<td>
<p>character, the condition for which the transformation is generated</p>
</td></tr>
<tr><td><code id="Pimpl_+3A_keep.root">keep.root</code></td>
<td>
<p>logical, applies for <code>method = "implicit"</code>. The root of the last
evaluation of the parameter transformation function is saved as guess for the next 
evaluation.</p>
</td></tr>
<tr><td><code id="Pimpl_+3A_positive">positive</code></td>
<td>
<p>logical, returns projection to the (semi)positive range. Comes with a warning if
the steady state has been found to be negative.</p>
</td></tr>
<tr><td><code id="Pimpl_+3A_compile">compile</code></td>
<td>
<p>Logical, compile the function (see <a href="#topic+funC0">funC0</a>)</p>
</td></tr>
<tr><td><code id="Pimpl_+3A_modelname">modelname</code></td>
<td>
<p>Character, used if <code>compile = TRUE</code>, sets a fixed filename for the
C file.</p>
</td></tr>
<tr><td><code id="Pimpl_+3A_verbose">verbose</code></td>
<td>
<p>Print compiler output to R command line.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Usually, the equations contain the dependent variables, the independent variables and 
other parameters. The argument <code>p</code> of <code>p2p</code> must provide values for the independent
variables and the parameters but ALSO FOR THE DEPENDENT VARIABLES. Those serve as initial guess
for the dependent variables. The dependent variables are then numerically computed by 
<a href="rootSolve.html#topic+multiroot">multiroot</a>. The Jacobian of the solution with respect to dependent variables
and parameters is computed by the implicit function theorem. The function <code>p2p</code> returns
all parameters as they are with corresponding 1-entries in the Jacobian.
</p>


<h3>Value</h3>

<p>a function <code>p2p(p, fixed = NULL, deriv = TRUE)</code> representing the parameter 
transformation. Here, <code>p</code> is a named numeric vector with the values of the outer parameters,
<code>fixed</code> is a named numeric vector with values of the outer parameters being considered
as fixed (no derivatives returned) and <code>deriv</code> is a logical determining whether the Jacobian
of the parameter transformation is returned as attribute &quot;deriv&quot;.
</p>


<h3>See Also</h3>

<p><a href="#topic+Pexpl">Pexpl</a> for explicit parameter transformations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>########################################################################
## Example 1: Steady-state trafo
########################################################################
f &lt;- c(A = "-k1*A + k2*B",
       B = "k1*A - k2*B")
P.steadyState &lt;- Pimpl(f, "A")

p.outerValues &lt;- c(k1 = 1, k2 = 0.1, A = 10, B = 1)
P.steadyState(p.outerValues)

########################################################################
## Example 2: Steady-state trafo combined with log-transform
########################################################################
f &lt;- c(A = "-k1*A + k2*B",
       B = "k1*A - k2*B")
P.steadyState &lt;- Pimpl(f, "A")

logtrafo &lt;- c(k1 = "exp(logk1)", k2 = "exp(logk2)", A = "exp(logA)", B = "exp(logB)")
P.log &lt;- P(logtrafo)

p.outerValue &lt;- c(logk1 = 1, logk2 = -1, logA = 0, logB = 0)
(P.log)(p.outerValue)
(P.steadyState * P.log)(p.outerValue)

########################################################################
## Example 3: Steady-states with conserved quantitites
########################################################################
f &lt;- c(A = "-k1*A + k2*B", B = "k1*A - k2*B")
replacement &lt;- c(B = "A + B - total")
f[names(replacement)] &lt;- replacement

pSS &lt;- Pimpl(f, "total")
pSS(c(k1 = 1, k2 = 2, A = 5, B = 5, total = 3))
</code></pre>

<hr>
<h2 id='plot.datalist'>Plot a list data points</h2><span id='topic+plot.datalist'></span>

<h3>Description</h3>

<p>Plot a list data points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'datalist'
plot(x, ..., scales = "free", facet = "wrap")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.datalist_+3A_x">x</code></td>
<td>
<p>Named list of data.frames as being used in <a href="#topic+res">res</a>, i.e. with columns <code>name</code>, <code>time</code>,
<code>value</code> and <code>sigma</code>.</p>
</td></tr>
<tr><td><code id="plot.datalist_+3A_...">...</code></td>
<td>
<p>Further arguments going to <code>dplyr::filter</code>.</p>
</td></tr>
<tr><td><code id="plot.datalist_+3A_scales">scales</code></td>
<td>
<p>The scales argument of <code>facet_wrap</code> or <code>facet_grid</code>, i.e. <code>"free"</code>, <code>"fixed"</code>,
<code>"free_x"</code> or <code>"free_y"</code></p>
</td></tr>
<tr><td><code id="plot.datalist_+3A_facet">facet</code></td>
<td>
<p>Either <code>"wrap"</code> or <code>"grid"</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data.frame being plotted has columns <code>time</code>, <code>value</code>, <code>sigma</code>,
<code>name</code> and <code>condition</code>.
</p>


<h3>Value</h3>

<p>A plot object of class <code>ggplot</code>.
</p>

<hr>
<h2 id='plot.parlist'>Plot a parameter list.</h2><span id='topic+plot.parlist'></span>

<h3>Description</h3>

<p>Plot a parameter list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'parlist'
plot(x, path = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.parlist_+3A_x">x</code></td>
<td>
<p>fitlist obtained from mstrust</p>
</td></tr>
<tr><td><code id="plot.parlist_+3A_path">path</code></td>
<td>
<p>print path of parameters from initials to convergence. For this
option to be TRUE <code><a href="#topic+mstrust">mstrust</a></code> must have had the option
<span class="option">blather</span>.</p>
</td></tr>
<tr><td><code id="plot.parlist_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If path=TRUE:
</p>


<h3>Author(s)</h3>

<p>Malenka Mader, <a href="mailto:Malenka.Mader@fdm.uni-freiburg.de">Malenka.Mader@fdm.uni-freiburg.de</a>
</p>

<hr>
<h2 id='plotCombined'>Plot a list of model predictions and a list of data points in a combined plot</h2><span id='topic+plotCombined'></span><span id='topic+plot.prdlist'></span><span id='topic+plotCombined.prdlist'></span><span id='topic+plot.prdframe'></span>

<h3>Description</h3>

<p>Plot a list of model predictions and a list of data points in a combined plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotCombined(prediction, ...)

## S3 method for class 'prdlist'
plot(x, data = NULL, ..., scales = "free", facet = "wrap", transform = NULL)

## S3 method for class 'prdlist'
plotCombined(
  prediction,
  data = NULL,
  ...,
  scales = "free",
  facet = "wrap",
  transform = NULL,
  aesthetics = NULL
)

## S3 method for class 'prdframe'
plot(x, data = NULL, ..., scales = "free", facet = "wrap", transform = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotCombined_+3A_prediction">prediction</code></td>
<td>
<p>Named list of matrices or data.frames, usually the output of a prediction function
as generated by <a href="#topic+Xs">Xs</a>.</p>
</td></tr>
<tr><td><code id="plotCombined_+3A_...">...</code></td>
<td>
<p>Further arguments going to <code>dplyr::filter</code>.</p>
</td></tr>
<tr><td><code id="plotCombined_+3A_x">x</code></td>
<td>
<p>prediction</p>
</td></tr>
<tr><td><code id="plotCombined_+3A_data">data</code></td>
<td>
<p>Named list of data.frames as being used in <a href="#topic+res">res</a>, i.e. with columns <code>name</code>, <code>time</code>, 
<code>value</code> and <code>sigma</code>.</p>
</td></tr>
<tr><td><code id="plotCombined_+3A_scales">scales</code></td>
<td>
<p>The scales argument of <code>facet_wrap</code> or <code>facet_grid</code>, i.e. <code>"free"</code>, <code>"fixed"</code>, 
<code>"free_x"</code> or <code>"free_y"</code></p>
</td></tr>
<tr><td><code id="plotCombined_+3A_facet">facet</code></td>
<td>
<p><code>"wrap"</code> or <code>"grid"</code>. Try <code>"wrap_plain"</code> for high amounts of conditions and low amounts of observables.</p>
</td></tr>
<tr><td><code id="plotCombined_+3A_transform">transform</code></td>
<td>
<p>list of transformation for the states, see <a href="#topic+coordTransform">coordTransform</a>.</p>
</td></tr>
<tr><td><code id="plotCombined_+3A_aesthetics">aesthetics</code></td>
<td>
<p>Named list of aesthetic mappings, specified as character, e.g. <code>list(linetype = "name")</code>. 
Can refer to variables in the condition.grid</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data.frame being plotted has columns <code>time</code>, <code>value</code>, <code>sigma</code>,
<code>name</code> and <code>condition</code>.
</p>


<h3>Value</h3>

<p>A plot object of class <code>ggplot</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    
    ## Observation function
    fn &lt;- eqnvec(
      sine = "1 + sin(6.28*omega*time)",
      cosine = "cos(6.28*omega*time)"
    )
    g &lt;- Y(fn, parameters = "omega")
    
    ## Prediction function for time
    x &lt;- Xt()
    
    ## Parameter transformations to split conditions
    p &lt;- NULL
    for (i in 1:3) {
      p &lt;- p + P(trafo = c(omega = paste0("omega_", i)), condition = paste0("frequency_", i))
    }
    
    ## Evaluate prediction
    times &lt;- seq(0, 1, .01)
    pars &lt;- structure(seq(1, 2, length.out = 3), names = attr(p, "parameters"))
    
    prediction &lt;- (g*x*p)(times, pars)
    
    ## Plotting prediction
    # plot(prediction)
    plotPrediction(prediction)
    plotPrediction(prediction, scales = "fixed")
    plotPrediction(prediction, facet = "grid")
    plotPrediction(prediction, 
                   scales = "fixed",
                   transform = list(sine = "x^2", cosine = "x - 1"))
    
    ## Simulate data
    dataset &lt;- wide2long(prediction)
    dataset &lt;- dataset[seq(1, nrow(dataset), 5),]
    set.seed(1)
    dataset$value &lt;- dataset$value + rnorm(nrow(dataset), 0, .1)
    dataset$sigma &lt;- 0.1
    data &lt;- as.datalist(dataset, split.by = "condition")
    
    ## Plotting data
    # plot(data)
    plot1 &lt;- plotData(data)
     plot1
    ## Plotting data and prediction with subsetting
    # plot(prediction, data)
    plot2 &lt;- plotCombined(prediction, data)
     plot2
    plot3 &lt;- plotCombined(prediction, data, 
                 time &lt;= 0.5 &amp; condition == "frequency_1")
     plot3
    plot4 &lt;- plotCombined(prediction, data, 
                 time &lt;= 0.5 &amp; condition != "frequency_1", 
                 facet = "grid")
     plot4
    plot5 &lt;- plotCombined(prediction, data, aesthetics = list(linetype = "condition"))
     plot5

</code></pre>

<hr>
<h2 id='plotData.datalist'>Plot a list data points</h2><span id='topic+plotData.datalist'></span><span id='topic+plotData'></span><span id='topic+plotData.data.frame'></span>

<h3>Description</h3>

<p>Plot a list data points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'datalist'
plotData(data, ..., scales = "free", facet = "wrap", transform = NULL)

plotData(data, ...)

## S3 method for class 'data.frame'
plotData(data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotData.datalist_+3A_data">data</code></td>
<td>
<p>Named list of data.frames as being used in <a href="#topic+res">res</a>, i.e. with columns <code>name</code>, <code>time</code>, 
<code>value</code> and <code>sigma</code>.</p>
</td></tr>
<tr><td><code id="plotData.datalist_+3A_...">...</code></td>
<td>
<p>Further arguments going to <code>subset</code>.</p>
</td></tr>
<tr><td><code id="plotData.datalist_+3A_scales">scales</code></td>
<td>
<p>The scales argument of <code>facet_wrap</code> or <code>facet_grid</code>, i.e. <code>"free"</code>, <code>"fixed"</code>, 
<code>"free_x"</code> or <code>"free_y"</code></p>
</td></tr>
<tr><td><code id="plotData.datalist_+3A_facet">facet</code></td>
<td>
<p>Either <code>"wrap"</code> or <code>"grid"</code></p>
</td></tr>
<tr><td><code id="plotData.datalist_+3A_transform">transform</code></td>
<td>
<p>list of transformation for the states, see <a href="#topic+coordTransform">coordTransform</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data.frame being plotted has columns <code>time</code>, <code>value</code>, <code>sigma</code>,
<code>name</code> and <code>condition</code>.
</p>


<h3>Value</h3>

<p>A plot object of class <code>ggplot</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    
    ## Observation function
    fn &lt;- eqnvec(
      sine = "1 + sin(6.28*omega*time)",
      cosine = "cos(6.28*omega*time)"
    )
    g &lt;- Y(fn, parameters = "omega")
    
    ## Prediction function for time
    x &lt;- Xt()
    
    ## Parameter transformations to split conditions
    p &lt;- NULL
    for (i in 1:3) {
      p &lt;- p + P(trafo = c(omega = paste0("omega_", i)), condition = paste0("frequency_", i))
    }
    
    ## Evaluate prediction
    times &lt;- seq(0, 1, .01)
    pars &lt;- structure(seq(1, 2, length.out = 3), names = attr(p, "parameters"))
    
    prediction &lt;- (g*x*p)(times, pars)
    
    ## Plotting prediction
    # plot(prediction)
    plotPrediction(prediction)
    plotPrediction(prediction, scales = "fixed")
    plotPrediction(prediction, facet = "grid")
    plotPrediction(prediction, 
                   scales = "fixed",
                   transform = list(sine = "x^2", cosine = "x - 1"))
    
    ## Simulate data
    dataset &lt;- wide2long(prediction)
    dataset &lt;- dataset[seq(1, nrow(dataset), 5),]
    set.seed(1)
    dataset$value &lt;- dataset$value + rnorm(nrow(dataset), 0, .1)
    dataset$sigma &lt;- 0.1
    data &lt;- as.datalist(dataset, split.by = "condition")
    
    ## Plotting data
    # plot(data)
    plot1 &lt;- plotData(data)
     plot1
    ## Plotting data and prediction with subsetting
    # plot(prediction, data)
    plot2 &lt;- plotCombined(prediction, data)
     plot2
    plot3 &lt;- plotCombined(prediction, data, 
                 time &lt;= 0.5 &amp; condition == "frequency_1")
     plot3
    plot4 &lt;- plotCombined(prediction, data, 
                 time &lt;= 0.5 &amp; condition != "frequency_1", 
                 facet = "grid")
     plot4
    plot5 &lt;- plotCombined(prediction, data, aesthetics = list(linetype = "condition"))
     plot5

</code></pre>

<hr>
<h2 id='plotFluxes'>Plot Fluxes given a list of flux Equations</h2><span id='topic+plotFluxes'></span>

<h3>Description</h3>

<p>Plot Fluxes given a list of flux Equations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotFluxes(pouter, x, times, fluxEquations, nameFlux = "Fluxes:", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotFluxes_+3A_pouter">pouter</code></td>
<td>
<p>parameters</p>
</td></tr>
<tr><td><code id="plotFluxes_+3A_x">x</code></td>
<td>
<p>The model prediction function <code>x(times, pouter, fixed, ...)</code></p>
</td></tr>
<tr><td><code id="plotFluxes_+3A_times">times</code></td>
<td>
<p>Numeric vector of time points for the model prediction</p>
</td></tr>
<tr><td><code id="plotFluxes_+3A_fluxequations">fluxEquations</code></td>
<td>
<p>list of chars containing expressions for the fluxes, 
if names are given, they are shown in the legend. Easy to obtain via <a href="#topic+subset.eqnlist">subset.eqnlist</a>, see Examples.</p>
</td></tr>
<tr><td><code id="plotFluxes_+3A_nameflux">nameFlux</code></td>
<td>
<p>character, name of the legend.</p>
</td></tr>
<tr><td><code id="plotFluxes_+3A_...">...</code></td>
<td>
<p>Further arguments going to x, such as <code>fixed</code> or <code>conditions</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot object of class <code>ggplot</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

plotFluxes(bestfit, x, times, subset(f, "B"%in%Product)$rates, nameFlux = "B production")

## End(Not run)
</code></pre>

<hr>
<h2 id='plotPars.parframe'>Plot parameter values for a fitlist</h2><span id='topic+plotPars.parframe'></span><span id='topic+plotPars'></span>

<h3>Description</h3>

<p>Plot parameter values for a fitlist
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'parframe'
plotPars(x, tol = 1, ...)

plotPars(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPars.parframe_+3A_x">x</code></td>
<td>
<p>parameter frame as obtained by as.parframe(mstrust)</p>
</td></tr>
<tr><td><code id="plotPars.parframe_+3A_tol">tol</code></td>
<td>
<p>maximal allowed difference between neighboring objective values
to be recognized as one.</p>
</td></tr>
<tr><td><code id="plotPars.parframe_+3A_...">...</code></td>
<td>
<p>arguments for subsetting of x</p>
</td></tr>
</table>

<hr>
<h2 id='plotPaths'>Profile likelihood: plot of the parameter paths.</h2><span id='topic+plotPaths'></span>

<h3>Description</h3>

<p>Profile likelihood: plot of the parameter paths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPaths(
  profs,
  ...,
  whichPar = NULL,
  sort = FALSE,
  relative = TRUE,
  scales = "fixed"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPaths_+3A_profs">profs</code></td>
<td>
<p>profile or list of profiles as being returned by <a href="#topic+profile">profile</a></p>
</td></tr>
<tr><td><code id="plotPaths_+3A_...">...</code></td>
<td>
<p>arguments going to subset</p>
</td></tr>
<tr><td><code id="plotPaths_+3A_whichpar">whichPar</code></td>
<td>
<p>Character or index vector, indicating the parameters that are taken as possible reference (x-axis)</p>
</td></tr>
<tr><td><code id="plotPaths_+3A_sort">sort</code></td>
<td>
<p>Logical. If paths from different parameter profiles are plotted together, possible
combinations are either sorted or all combinations are taken as they are.</p>
</td></tr>
<tr><td><code id="plotPaths_+3A_relative">relative</code></td>
<td>
<p>logical indicating whether the origin should be shifted.</p>
</td></tr>
<tr><td><code id="plotPaths_+3A_scales">scales</code></td>
<td>
<p>character, either <code>"free"</code> or <code>"fixed"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <a href="#topic+profile">profile</a> for examples.
</p>


<h3>Value</h3>

<p>A plot object of class <code>ggplot</code>.
</p>

<hr>
<h2 id='plotPrediction'>Plot a list of model predictions</h2><span id='topic+plotPrediction'></span><span id='topic+plotPrediction.prdlist'></span>

<h3>Description</h3>

<p>Plot a list of model predictions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPrediction(prediction, ...)

## S3 method for class 'prdlist'
plotPrediction(
  prediction,
  ...,
  errfn = NULL,
  scales = "free",
  facet = "wrap",
  transform = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPrediction_+3A_prediction">prediction</code></td>
<td>
<p>Named list of matrices or data.frames, usually the output of a prediction function
as generated by <a href="#topic+Xs">Xs</a>.</p>
</td></tr>
<tr><td><code id="plotPrediction_+3A_...">...</code></td>
<td>
<p>Further arguments going to <code>dplyr::filter</code>.</p>
</td></tr>
<tr><td><code id="plotPrediction_+3A_errfn">errfn</code></td>
<td>
<p>error model function</p>
</td></tr>
<tr><td><code id="plotPrediction_+3A_scales">scales</code></td>
<td>
<p>The scales argument of <code>facet_wrap</code> or <code>facet_grid</code>, i.e. <code>"free"</code>, <code>"fixed"</code>, 
<code>"free_x"</code> or <code>"free_y"</code></p>
</td></tr>
<tr><td><code id="plotPrediction_+3A_facet">facet</code></td>
<td>
<p>Either <code>"wrap"</code> or <code>"grid"</code></p>
</td></tr>
<tr><td><code id="plotPrediction_+3A_transform">transform</code></td>
<td>
<p>list of transformation for the states, see <a href="#topic+coordTransform">coordTransform</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data.frame being plotted has columns <code>time</code>, <code>value</code>, <code>name</code> and <code>condition</code>.
</p>


<h3>Value</h3>

<p>A plot object of class <code>ggplot</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    
    ## Observation function
    fn &lt;- eqnvec(
      sine = "1 + sin(6.28*omega*time)",
      cosine = "cos(6.28*omega*time)"
    )
    g &lt;- Y(fn, parameters = "omega")
    
    ## Prediction function for time
    x &lt;- Xt()
    
    ## Parameter transformations to split conditions
    p &lt;- NULL
    for (i in 1:3) {
      p &lt;- p + P(trafo = c(omega = paste0("omega_", i)), condition = paste0("frequency_", i))
    }
    
    ## Evaluate prediction
    times &lt;- seq(0, 1, .01)
    pars &lt;- structure(seq(1, 2, length.out = 3), names = attr(p, "parameters"))
    
    prediction &lt;- (g*x*p)(times, pars)
    
    ## Plotting prediction
    # plot(prediction)
    plotPrediction(prediction)
    plotPrediction(prediction, scales = "fixed")
    plotPrediction(prediction, facet = "grid")
    plotPrediction(prediction, 
                   scales = "fixed",
                   transform = list(sine = "x^2", cosine = "x - 1"))
    
    ## Simulate data
    dataset &lt;- wide2long(prediction)
    dataset &lt;- dataset[seq(1, nrow(dataset), 5),]
    set.seed(1)
    dataset$value &lt;- dataset$value + rnorm(nrow(dataset), 0, .1)
    dataset$sigma &lt;- 0.1
    data &lt;- as.datalist(dataset, split.by = "condition")
    
    ## Plotting data
    # plot(data)
    plot1 &lt;- plotData(data)
     plot1
    ## Plotting data and prediction with subsetting
    # plot(prediction, data)
    plot2 &lt;- plotCombined(prediction, data)
     plot2
    plot3 &lt;- plotCombined(prediction, data, 
                 time &lt;= 0.5 &amp; condition == "frequency_1")
     plot3
    plot4 &lt;- plotCombined(prediction, data, 
                 time &lt;= 0.5 &amp; condition != "frequency_1", 
                 facet = "grid")
     plot4
    plot5 &lt;- plotCombined(prediction, data, aesthetics = list(linetype = "condition"))
     plot5

</code></pre>

<hr>
<h2 id='plotProfile.parframe'>Profile likelihood plot</h2><span id='topic+plotProfile.parframe'></span><span id='topic+plotProfile.list'></span><span id='topic+plotProfile'></span>

<h3>Description</h3>

<p>Profile likelihood plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'parframe'
plotProfile(profs, ..., maxvalue = 5, parlist = NULL)

## S3 method for class 'list'
plotProfile(profs, ..., maxvalue = 5, parlist = NULL)

plotProfile(profs, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotProfile.parframe_+3A_profs">profs</code></td>
<td>
<p>Lists of profiles as being returned by <a href="#topic+profile">profile</a>.</p>
</td></tr>
<tr><td><code id="plotProfile.parframe_+3A_...">...</code></td>
<td>
<p>logical going to subset before plotting.</p>
</td></tr>
<tr><td><code id="plotProfile.parframe_+3A_maxvalue">maxvalue</code></td>
<td>
<p>Numeric, the value where profiles are cut off.</p>
</td></tr>
<tr><td><code id="plotProfile.parframe_+3A_parlist">parlist</code></td>
<td>
<p>Matrix or data.frame with columns for the parameters to be added to the plot as points.
If a &quot;value&quot; column is contained, deltas are calculated with respect to lowest chisquare of profiles.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <a href="#topic+profile">profile</a> for examples.
</p>


<h3>Value</h3>

<p>A plot object of class <code>ggplot</code>.
</p>

<hr>
<h2 id='plotResiduals'>Plot residuals for a fitlist</h2><span id='topic+plotResiduals'></span>

<h3>Description</h3>

<p>Plot residuals for a fitlist
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotResiduals(parframe, x, data, split = "condition", errmodel = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotResiduals_+3A_parframe">parframe</code></td>
<td>
<p>Object of class <code>parframe</code>, e.g. returned by <a href="#topic+mstrust">mstrust</a></p>
</td></tr>
<tr><td><code id="plotResiduals_+3A_x">x</code></td>
<td>
<p>Prediction function returning named list of data.frames with names as <code>data</code>.</p>
</td></tr>
<tr><td><code id="plotResiduals_+3A_data">data</code></td>
<td>
<p>Named list of data.frames, i.e. with columns <code>name</code>, <code>time</code>, 
<code>value</code> and <code>sigma</code>.</p>
</td></tr>
<tr><td><code id="plotResiduals_+3A_split">split</code></td>
<td>
<p>List of characters specifying how to summarise the residuals by <code>sqrt(res_i^2)</code>, 
<code>split[1]</code> used for x-axis, <code>split[2]</code> for grouping (color), and any additional for <code>facet_wrap()</code></p>
</td></tr>
<tr><td><code id="plotResiduals_+3A_errmodel">errmodel</code></td>
<td>
<p>object of type prdfn, the error model function.</p>
</td></tr>
<tr><td><code id="plotResiduals_+3A_...">...</code></td>
<td>
<p>Additional arguments for x</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot object of class <code>ggplot</code> with data.frame as attribute <code>attr(P,"out")</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 # time axis:
 plotResiduals(myfitlist, g*x*p, data, 
    c("time","index","condition","name"), 
    conditions = myconditions[1:4])
 # condition axis (residuals summed over time for each observable and condition):
 plotResiduals(myfitlist, g*x*p, data,  c("condition","name","index"))

## End(Not run)
</code></pre>

<hr>
<h2 id='plotValues.parframe'>Plotting objective values of a collection of fits</h2><span id='topic+plotValues.parframe'></span><span id='topic+plotValues'></span>

<h3>Description</h3>

<p>Plotting objective values of a collection of fits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'parframe'
plotValues(x, tol = 1, ...)

plotValues(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotValues.parframe_+3A_x">x</code></td>
<td>
<p>data.frame with columns &quot;value&quot;, &quot;converged&quot; and &quot;iterations&quot;, e.g. 
a <a href="#topic+parframe">parframe</a>.</p>
</td></tr>
<tr><td><code id="plotValues.parframe_+3A_tol">tol</code></td>
<td>
<p>maximal allowed difference between neighboring objective values
to be recognized as one.</p>
</td></tr>
<tr><td><code id="plotValues.parframe_+3A_...">...</code></td>
<td>
<p>arguments for subsetting of x</p>
</td></tr>
</table>

<hr>
<h2 id='prdfn'>Prediction function</h2><span id='topic+prdfn'></span>

<h3>Description</h3>

<p>A prediction function is a function <code>x(..., fixed, deriv, conditions)</code>.
Prediction functions are generated by <a href="#topic+Xs">Xs</a>, <a href="#topic+Xf">Xf</a> or <a href="#topic+Xd">Xd</a>. For an example
see the last one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prdfn(P2X, parameters = NULL, condition = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prdfn_+3A_p2x">P2X</code></td>
<td>
<p>transformation function as being produced by <a href="#topic+Xs">Xs</a>.</p>
</td></tr>
<tr><td><code id="prdfn_+3A_parameters">parameters</code></td>
<td>
<p>character vector with parameter names</p>
</td></tr>
<tr><td><code id="prdfn_+3A_condition">condition</code></td>
<td>
<p>character, the condition name</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prediction functions can be &quot;added&quot; by the &quot;+&quot; operator, see <a href="#topic+sumfn">sumfn</a>. Thereby,
predictions for different conditions are merged or overwritten. Prediction functions can
also be concatenated with other functions, e.g. observation functions (<a href="#topic+obsfn">obsfn</a>) or
parameter transformation functions (<a href="#topic+parfn">parfn</a>) by the &quot;*&quot; operator, see <a href="#topic+prodfn">prodfn</a>.
</p>


<h3>Value</h3>

<p>Object of class <code>prdfn</code>, i.e. a function <code>x(..., fixed, deriv, conditions, env)</code>
which returns a <a href="#topic+prdlist">prdlist</a>. The arguments <code>times</code> and
<code>pars</code> (parameter values) should be passed via the <code>...</code> argument, in this order.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define a time grid on which to make a prediction by peace-wise linear function.
# Then define a (generic) prediction function based on thid grid.
times &lt;- 0:5
grid &lt;- data.frame(name = "A", time = times, row.names = paste0("p", times))
x &lt;- Xd(grid)

# Define an observable and an observation function
observables &lt;- eqnvec(Aobs = "s*A")
g &lt;- Y(g = observables, f = NULL, states = "A", parameters = "s")

# Collect parameters and define an overarching parameter transformation
# for two "experimental condtions".
dynpars &lt;- attr(x, "parameters")
obspars &lt;- attr(g, "parameters")
innerpars &lt;- c(dynpars, obspars)

trafo &lt;- structure(innerpars, names = innerpars)
trafo_C1 &lt;- replaceSymbols(innerpars, paste(innerpars, "C1", sep = "_"), trafo)
trafo_C2 &lt;- replaceSymbols(innerpars, paste(innerpars, "C2", sep = "_"), trafo)

p &lt;- NULL
p &lt;- p + P(trafo = trafo_C1, condition = "C1")
p &lt;- p + P(trafo = trafo_C2, condition = "C2")

# Collect outer (overarching) parameters and 
# initialize with random values
outerpars &lt;- attr(p, "parameters")
pars &lt;- structure(runif(length(outerpars), 0, 1), names = outerpars)

# Predict internal/unobserved states
out1 &lt;- (x*p)(times, pars)
plot(out1)

# Predict observed states in addition to unobserved
out2 &lt;- (g*x*p)(times, pars)
plot(out2)
</code></pre>

<hr>
<h2 id='prdframe'>Prediction frame</h2><span id='topic+prdframe'></span>

<h3>Description</h3>

<p>A prediction frame is used to store a model prediction in a matrix. The columns
of the matrix are &quot;time&quot; and one column per state. The prediction frame has attributes &quot;deriv&quot;,
the matrix of sensitivities with respect to &quot;outer parameters&quot; (see <a href="#topic+P">P</a>), an attribute
&quot;sensitivities&quot;, the matrix of sensitivities with respect to the &quot;inner parameters&quot; (the model
parameters, left-hand-side of the parameter transformation) and an attributes &quot;parameters&quot;, the
parameter vector of inner parameters to produce the prediction frame.
</p>
<p>Prediction frames are usually the constituents of prediction lists (<a href="#topic+prdlist">prdlist</a>). They are
produced by <a href="#topic+Xs">Xs</a>, <a href="#topic+Xd">Xd</a> or <a href="#topic+Xf">Xf</a>. When you define your own prediction functions,
see <code>P2X</code> in <a href="#topic+prdfn">prdfn</a>, the result should be returned as a prediction frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prdframe(
  prediction = NULL,
  deriv = NULL,
  sensitivities = NULL,
  parameters = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prdframe_+3A_prediction">prediction</code></td>
<td>
<p>matrix of model prediction</p>
</td></tr>
<tr><td><code id="prdframe_+3A_deriv">deriv</code></td>
<td>
<p>matrix of sensitivities wrt outer parameters</p>
</td></tr>
<tr><td><code id="prdframe_+3A_sensitivities">sensitivities</code></td>
<td>
<p>matrix of sensitivitie wrt inner parameters</p>
</td></tr>
<tr><td><code id="prdframe_+3A_parameters">parameters</code></td>
<td>
<p>names of the outer paramters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>prdframe</code>, i.e. a matrix with other matrices and vectors as attributes.
</p>

<hr>
<h2 id='prdlist'>Prediction list</h2><span id='topic+prdlist'></span><span id='topic+as.prdlist'></span><span id='topic+as.prdlist.list'></span>

<h3>Description</h3>

<p>A prediction list is used to store a list of model predictions
from different prediction functions or the same prediction function with different
parameter specifications. Each entry of the list is a <a href="#topic+prdframe">prdframe</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prdlist(...)

as.prdlist(x, ...)

## S3 method for class 'list'
as.prdlist(x = NULL, names = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prdlist_+3A_...">...</code></td>
<td>
<p>objects of class <a href="#topic+prdframe">prdframe</a>
conditions.</p>
</td></tr>
<tr><td><code id="prdlist_+3A_x">x</code></td>
<td>
<p>list of prediction frames</p>
</td></tr>
<tr><td><code id="prdlist_+3A_names">names</code></td>
<td>
<p>character vector, the list names, e.g. the names of the experimental</p>
</td></tr>
</table>

<hr>
<h2 id='predict.prdfn'>Model Predictions</h2><span id='topic+predict.prdfn'></span>

<h3>Description</h3>

<p>Make a model prediction for times and a parameter frame. The
function is a generalization of the standard prediction by a
prediction function object in that it allows to pass a parameter
frame instead of a single parameter vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'prdfn'
predict(object, ..., times, pars, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.prdfn_+3A_object">object</code></td>
<td>
<p>prediction function</p>
</td></tr>
<tr><td><code id="predict.prdfn_+3A_...">...</code></td>
<td>
<p>Further arguments goint to the prediction function</p>
</td></tr>
<tr><td><code id="predict.prdfn_+3A_times">times</code></td>
<td>
<p>numeric vector of time points</p>
</td></tr>
<tr><td><code id="predict.prdfn_+3A_pars">pars</code></td>
<td>
<p>parameter frame, e.g. output from <a href="#topic+mstrust">mstrust</a> or 
<a href="#topic+profile">profile</a></p>
</td></tr>
<tr><td><code id="predict.prdfn_+3A_data">data</code></td>
<td>
<p>data list object. If data is passed, its condition.grid
attribute is used to augment the output dataframe by additional 
columns. <code>"data"</code> itself is returned as an attribute.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame
</p>

<hr>
<h2 id='print.eqnlist'>Print or pander equation list</h2><span id='topic+print.eqnlist'></span>

<h3>Description</h3>

<p>Print or pander equation list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'eqnlist'
print(x, pander = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.eqnlist_+3A_x">x</code></td>
<td>
<p>object of class <a href="#topic+eqnlist">eqnlist</a></p>
</td></tr>
<tr><td><code id="print.eqnlist_+3A_pander">pander</code></td>
<td>
<p>logical, use pander for output (used with R markdown)</p>
</td></tr>
<tr><td><code id="print.eqnlist_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Wolfgang Mader, <a href="mailto:Wolfgang.Mader@fdm.uni-freiburg.de">Wolfgang.Mader@fdm.uni-freiburg.de</a>
</p>
<p>Daniel Kaschek, <a href="mailto:daniel.kaschek@physik.uni-freiburg.de">daniel.kaschek@physik.uni-freiburg.de</a>
</p>

<hr>
<h2 id='print.eqnvec'>Print equation vector</h2><span id='topic+print.eqnvec'></span>

<h3>Description</h3>

<p>Print equation vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'eqnvec'
print(x, width = 140, pander = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.eqnvec_+3A_x">x</code></td>
<td>
<p>object of class <a href="#topic+eqnvec">eqnvec</a>.</p>
</td></tr>
<tr><td><code id="print.eqnvec_+3A_width">width</code></td>
<td>
<p>numeric, width of the print-out</p>
</td></tr>
<tr><td><code id="print.eqnvec_+3A_pander">pander</code></td>
<td>
<p>logical, use pander for output (used with R markdown)</p>
</td></tr>
<tr><td><code id="print.eqnvec_+3A_...">...</code></td>
<td>
<p>not used right now</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Wolfgang Mader, <a href="mailto:Wolfgang.Mader@fdm.uni-freiburg.de">Wolfgang.Mader@fdm.uni-freiburg.de</a>
</p>

<hr>
<h2 id='print.parfn'>Pretty printing parameter transformations</h2><span id='topic+print.parfn'></span>

<h3>Description</h3>

<p>Pretty printing parameter transformations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'parfn'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.parfn_+3A_x">x</code></td>
<td>
<p>prediction function</p>
</td></tr>
<tr><td><code id="print.parfn_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Wolfgang Mader, <a href="mailto:Wolfgang.Mader@fdm.uni-freiburg.de">Wolfgang.Mader@fdm.uni-freiburg.de</a>
</p>

<hr>
<h2 id='print.parvec'>Pretty printing for a parameter vector</h2><span id='topic+print.parvec'></span>

<h3>Description</h3>

<p>Pretty printing for a parameter vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'parvec'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.parvec_+3A_x">x</code></td>
<td>
<p>object of class <code>parvec</code></p>
</td></tr>
<tr><td><code id="print.parvec_+3A_...">...</code></td>
<td>
<p>not used yet.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Wolfgang Mader, <a href="mailto:Wolfgang.Mader@fdm.uni-freiburg.de">Wolfgang.Mader@fdm.uni-freiburg.de</a>
</p>

<hr>
<h2 id='print0'>Print object and its &quot;default&quot; attributes only.</h2><span id='topic+print0'></span>

<h3>Description</h3>

<p>Print object and its &quot;default&quot; attributes only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print0(x, list_attributes = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print0_+3A_x">x</code></td>
<td>
<p>Object to be printed</p>
</td></tr>
<tr><td><code id="print0_+3A_list_attributes">list_attributes</code></td>
<td>
<p>Prints the names of all attribute of x, defaults to 
TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Before the <span class="option">x</span> is printed by print.default, all its arguments
not in the default list of <code><a href="#topic+attrs">attrs</a></code> are removed.
</p>


<h3>Author(s)</h3>

<p>Wolfgang Mader, <a href="mailto:Wolfgang.Mader@fdm.uni-freiburg.de">Wolfgang.Mader@fdm.uni-freiburg.de</a>
</p>
<p>Mirjam Fehling-Kaschek, 
<a href="mailto:mirjam.fehling@physik.uni-freiburg.de">mirjam.fehling@physik.uni-freiburg.de</a>
</p>

<hr>
<h2 id='priorL2'>L2 objective function for prior value</h2><span id='topic+priorL2'></span>

<h3>Description</h3>

<p>As a prior function, it returns derivatives with respect to
the penalty parameter in addition to parameter derivatives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>priorL2(mu, lambda = "lambda", attr.name = "prior", condition = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="priorL2_+3A_mu">mu</code></td>
<td>
<p>Named numeric, the prior values</p>
</td></tr>
<tr><td><code id="priorL2_+3A_lambda">lambda</code></td>
<td>
<p>Character of length one. The name of the penalty paramter in <code>p</code>.</p>
</td></tr>
<tr><td><code id="priorL2_+3A_attr.name">attr.name</code></td>
<td>
<p>character. The constraint value is additionally returned in an 
attributed with this name</p>
</td></tr>
<tr><td><code id="priorL2_+3A_condition">condition</code></td>
<td>
<p>character, the condition for which the constraint should apply. If
<code>NULL</code>, applies to any condition.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the constraint value 
</p>
<p style="text-align: center;"><code class="reqn">e^{\lambda} \| p-\mu \|^2</code>
</p>

<p>and its derivatives with respect to p and lambda.
</p>


<h3>Value</h3>

<p>List of class <code>objlist</code>, i.e. objective value, gradient and Hessian as list.
</p>


<h3>See Also</h3>

<p><a href="#topic+wrss">wrss</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- c(A = 1, B = 2, C = 3, lambda = 0)
mu &lt;- c(A = 0, B = 0)
obj &lt;- priorL2(mu = mu, lambda = "lambda")
obj(pars = p + rnorm(length(p), 0, .1))
</code></pre>

<hr>
<h2 id='profile'>Profile-likelihood (PL) computation</h2><span id='topic+profile'></span>

<h3>Description</h3>

<p>Profile-likelihood (PL) computation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>profile(
  obj,
  pars,
  whichPar,
  alpha = 0.05,
  limits = c(lower = -Inf, upper = Inf),
  method = c("integrate", "optimize"),
  stepControl = NULL,
  algoControl = NULL,
  optControl = NULL,
  verbose = FALSE,
  cores = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="profile_+3A_obj">obj</code></td>
<td>
<p>Objective function <code>obj(pars, fixed, ...)</code> returning a list with &quot;value&quot;,
&quot;gradient&quot; and &quot;hessian&quot;. If attribute &quot;valueData&quot; and/or &quot;valuePrior are returned they are attached to the return value.</p>
</td></tr>
<tr><td><code id="profile_+3A_pars">pars</code></td>
<td>
<p>Parameter vector corresponding to the log-liklihood optimum.</p>
</td></tr>
<tr><td><code id="profile_+3A_whichpar">whichPar</code></td>
<td>
<p>Numeric or character vector. The parameters for which the profile is computed.</p>
</td></tr>
<tr><td><code id="profile_+3A_alpha">alpha</code></td>
<td>
<p>Numeric, the significance level based on the chisquare distribution with df=1</p>
</td></tr>
<tr><td><code id="profile_+3A_limits">limits</code></td>
<td>
<p>Numeric vector of length 2, the lower and upper deviance from the original 
value of <code>pars[whichPar]</code></p>
</td></tr>
<tr><td><code id="profile_+3A_method">method</code></td>
<td>
<p>Character, either <code>"integrate"</code> or <code>"optimize"</code>. This is a short-cut for
setting stepControl, algoControl and optControl by hand.</p>
</td></tr>
<tr><td><code id="profile_+3A_stepcontrol">stepControl</code></td>
<td>
<p>List of arguments controlling the step adaption. Defaults to integration set-up, i.e.
<code>list(stepsize = 1e-4, min = 1e-4, max = Inf, atol = 1e-2, rtol = 1e-2, limit = 100)</code></p>
</td></tr>
<tr><td><code id="profile_+3A_algocontrol">algoControl</code></td>
<td>
<p>List of arguments controlling the fast PL algorithm. defaults to
<code>list(gamma = 1, W = "hessian", reoptimize = FALSE, correction = 1, reg = .Machine$double.eps)</code></p>
</td></tr>
<tr><td><code id="profile_+3A_optcontrol">optControl</code></td>
<td>
<p>List of arguments controlling the <code>trust()</code> optimizer. Defaults to
<code>list(rinit = .1, rmax = 10, iterlim = 10, fterm = sqrt(.Machine$double.eps), mterm = sqrt(.Machine$double.eps))</code>.
See <a href="#topic+trust">trust</a> for more details.</p>
</td></tr>
<tr><td><code id="profile_+3A_verbose">verbose</code></td>
<td>
<p>Logical, print verbose messages.</p>
</td></tr>
<tr><td><code id="profile_+3A_cores">cores</code></td>
<td>
<p>number of cores used when computing profiles for several
parameters.</p>
</td></tr>
<tr><td><code id="profile_+3A_...">...</code></td>
<td>
<p>Arguments going to obj()</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computation of the profile likelihood is based on the method of Lagrangian multipliers
and Euler integration of the corresponding differential equation of the profile likelihood paths.
</p>
<p><code>algoControl</code>: Since the Hessian which is needed for the differential equation is frequently misspecified, 
the error in integration needs to be compensated by a correction factor <code>gamma</code>. Instead of the
Hessian, an identity matrix can be used. To guarantee that the profile likelihood path stays on
the true path, each point proposed by the differential equation can be used as starting point for
an optimization run when <code>reoptimize = TRUE</code>. The correction factor <code>gamma</code> is adapted
based on the amount of actual correction. If this exceeds the value <code>correction</code>, <code>gamma</code> is
reduced. In some cases, the Hessian becomes singular. This leads to problems when inverting the
Hessian. To avoid this problem, the pseudoinverse is computed by removing all singular values lower
than <code>reg</code>.
</p>
<p><code>stepControl</code>: The Euler integration starts with <code>stepsize</code>. In each step the predicted change
of the objective function is compared with the actual change. If this is larger than <code>atol</code>, the
stepsize is reduced. For small deviations, either compared the abolute tolerance <code>atol</code> or the
relative tolerance <code>rtol</code>, the stepsize may be increased. <code>max</code> and <code>min</code> are upper and lower
bounds for <code>stepsize</code>. <code>limit</code> is the maximum number of steps that are take for the profile computation.
<code>stop</code> is a character, usually &quot;value&quot; or &quot;data&quot;, for which the significance level <code>alpha</code>
is evaluated.
</p>


<h3>Value</h3>

<p>Named list of length one. The name is the parameter name. The list enty is a
matrix with columns &quot;value&quot; (the objective value), &quot;constraint&quot; (deviation of the profiled paramter from
the original value), &quot;stepsize&quot; (the stepsize take for the iteration), &quot;gamma&quot; (the gamma value employed for the
iteration), &quot;valueData&quot; and &quot;valuePrior&quot; (if specified in obj), one column per parameter (the profile paths).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

## Parameter transformation
trafo &lt;- eqnvec(a = "exp(loga)", 
                b = "exp(logb)", 
                c = "exp(loga)*exp(logb)*exp(logc)")
p &lt;- P(trafo)

## Objective function
obj1 &lt;- constraintL2(mu = c(a = .1, b = 1, c = 10), sigma = .6)
obj2 &lt;- constraintL2(mu = c(loga = 0, logb = 0), sigma = 10)
obj &lt;- obj1*p + obj2

## Initialize parameters and obtain fit
pars &lt;- c(loga = 1, logb = 1, logc = 1)
myfit &lt;- trust(obj, pars, rinit = 1, rmax = 10)
myfit.fixed &lt;- trust(obj, pars[-1], rinit = 1, rmax = 10, fixed = pars[1])

## Compute profiles by integration method
profiles.approx &lt;- do.call(
  rbind, 
  lapply(1:3, function(i) {
    profile(obj, myfit$argument, whichPar = i, limits = c(-3, 3),
            method = "integrate")
  })
)

## Compute profiles by repeated optimization 
profiles.exact &lt;- do.call(
  rbind, 
  lapply(1:3, function(i) {
    profile(obj, myfit$argument, whichPar = i, limits = c(-3, 3),
            method = "optimize")
  })
)

## Compute profiles for fit with fixed element by integration method
profiles.approx.fixed &lt;- do.call(
  rbind, 
  lapply(1:2, function(i) {
    profile(obj, myfit.fixed$argument, whichPar = i, limits = c(-3, 3),
            method = "integrate",
            fixed = pars[1])
  })
)

## Plotting
plotProfile(profiles.approx)
plotProfile(list(profiles.approx, profiles.exact))
plotProfile(list(profiles.approx, profiles.approx.fixed))

plotPaths(profiles.approx, sort = TRUE)
plotPaths(profiles.approx, whichPar = "logc")
plotPaths(list(profiles.approx, profiles.approx.fixed), whichPar = "logc")

## Confidence Intervals
confint(profiles.approx, val.column = "value")


## End(Not run)
</code></pre>

<hr>
<h2 id='progressBar'>Progress bar</h2><span id='topic+progressBar'></span>

<h3>Description</h3>

<p>Progress bar
</p>


<h3>Usage</h3>

<pre><code class='language-R'>progressBar(percentage, size = 50, number = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="progressBar_+3A_percentage">percentage</code></td>
<td>
<p>Numeric between 0 and 100</p>
</td></tr>
<tr><td><code id="progressBar_+3A_size">size</code></td>
<td>
<p>Integer, the size of the bar print-out</p>
</td></tr>
<tr><td><code id="progressBar_+3A_number">number</code></td>
<td>
<p>Logical, Indicates whether the percentage should be printed out.</p>
</td></tr>
</table>

<hr>
<h2 id='reduceReplicates'>Reduce replicated measurements to mean and standard deviation</h2><span id='topic+reduceReplicates'></span>

<h3>Description</h3>

<p>Obtain the mean and standard deviation from replicates per condition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduceReplicates(file, select = "condition", datatrans = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reduceReplicates_+3A_file">file</code></td>
<td>
<p>Data file of csv. See Format for details.</p>
</td></tr>
<tr><td><code id="reduceReplicates_+3A_select">select</code></td>
<td>
<p>Names of the columns in the data file used to define
conditions, see Details.</p>
</td></tr>
<tr><td><code id="reduceReplicates_+3A_datatrans">datatrans</code></td>
<td>
<p>Character vector describing a function to transform data.
Use <kbd>x</kbd> to refere to data.</p>
</td></tr>
</table>


<h3>Format</h3>

<p>The following columns are mandatory for the data file.
</p>

<dl>
<dt>name</dt><dd><p>Name of the observed species.</p>
</dd>
<dt>time</dt><dd><p>Measurement time point.</p>
</dd>
<dt>value</dt><dd><p>Measurement value.</p>
</dd>
<dt>condition</dt><dd><p>The condition under which the observation was made.</p>
</dd>
</dl>

<p>In addition to these columns, any number of columns can follow to allow a
fine grained definition of conditions. The values of all columns named in
<span class="option">select</span> are then merged to get the set of conditions.</p>


<h3>Details</h3>

<p>Experiments are usually repeated multiple times possibly under different
conditions leading to replicted measurements. The column &quot;Condition&quot; in the
data allows to group the data by their condition. However, sometimes, a more
fine grained grouping is desirable. In this case, any number of additional
columns can be append to the data. These columns are referred to as
&quot;condition identifier&quot;. Which of the condition identifiers are used to do the
grouping is user defined by anouncing the to <span class="option">select</span>. The mandatory
column &quot;Condition&quot; is always used. The total set of different conditions is
thus defined by all combinations of values occuring in the selected condition
identifiers. The replicates of each condition are then reduced to mean and
variance.New conditions names are derived by merging all conditions which
were used in mean and std.
</p>


<h3>Value</h3>

<p>A data frame of the following variables
</p>

<dl>
<dt>time</dt><dd><p>Measurement time point.</p>
</dd>
<dt>name</dt><dd><p>Name of the observed species.</p>
</dd>
<dt>value</dt><dd><p>Mean of replicates.</p>
</dd>
<dt>sigma</dt><dd><p>Standard error of the mean, NA for single measurements.</p>
</dd>
<dt>n</dt><dd><p>The number of replicates reduced.</p>
</dd>
<dt>condition</dt><dd><p>The condition for which the value and sigma were calculated. If
more than one column were used to define the condition, this variable
holds the effecive condition which is the combination of all applied
single conditions. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Wolfgang Mader, <a href="mailto:Wolfgang.Mader@fdm.uni-freiburg.de">Wolfgang.Mader@fdm.uni-freiburg.de</a>
</p>

<hr>
<h2 id='repar'>Reparameterization</h2><span id='topic+repar'></span>

<h3>Description</h3>

<p>Reparameterization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repar(expr, trafo = NULL, ..., reset = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="repar_+3A_expr">expr</code></td>
<td>
<p>character of the form <code>"lhs ~ rhs"</code> where <code>rhs</code>
reparameterizes <code>lhs</code>. Both <code>lhs</code> and <code>rhs</code>
can contain a number of symbols whose values need to be passed by the <code>...</code> argument.</p>
</td></tr>
<tr><td><code id="repar_+3A_trafo">trafo</code></td>
<td>
<p>character or equation vector or list thereof. The object where the replacement takes place in</p>
</td></tr>
<tr><td><code id="repar_+3A_...">...</code></td>
<td>
<p>pass symbols as named arguments</p>
</td></tr>
<tr><td><code id="repar_+3A_reset">reset</code></td>
<td>
<p>logical. If true, the trafo element corresponding to lhs is reset according to rhs. 
If false, lhs wherever it occurs in the rhs of trafo is replaced by rhs of the formula.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Left and right-hand side of <code>expr</code> are searched for symbols. If separated by
&quot;_&quot;, symbols are recognized as such, e.g. in <code>Delta_x</code> where the symbols are 
&quot;Delta&quot; and &quot;x&quot;. Each symbol for which values (character or numbers) are passed by the
<code>...</code> argument is replaced.
</p>


<h3>Value</h3>

<p>an equation vector with the reparameterization.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>innerpars &lt;- letters[1:3]
constraints &lt;- c(a = "b + c")
mycondition &lt;- "cond1"

trafo &lt;- repar("x ~ x", x = innerpars)
trafo &lt;- repar("x ~ y", trafo, x = names(constraints), y = constraints)
trafo &lt;- repar("x ~ exp(x)", trafo, x = innerpars)
trafo &lt;- repar("x ~ x + Delta_x_condition", trafo, x = innerpars, condition = mycondition)
</code></pre>

<hr>
<h2 id='res'>Compare data and model prediction by computing residuals</h2><span id='topic+res'></span>

<h3>Description</h3>

<p>Compare data and model prediction by computing residuals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>res(data, out, err = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="res_+3A_data">data</code></td>
<td>
<p>data.frame with name (factor), time (numeric), value (numeric) and sigma (numeric)</p>
</td></tr>
<tr><td><code id="res_+3A_out">out</code></td>
<td>
<p>output of ode(), optionally augmented with attributes 
&quot;deriv&quot; (output of ode() for the sensitivity equations) and
&quot;parameters&quot; (character vector of parameter names, a subsest of those 
contained in the sensitivity equations). If &quot;deriv&quot; is given, also &quot;parameters&quot;
needs to be given.</p>
</td></tr>
<tr><td><code id="res_+3A_err">err</code></td>
<td>
<p>output of the error model function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with the original data augmented by columns &quot;prediction&quot; (
numeric, the model prediction), &quot;residual&quot; (numeric, difference between
prediction and data value), &quot;weighted.residual&quot; (numeric, residual devided
by sigma). If &quot;deriv&quot; was given, the returned data.frame has an 
attribute &quot;deriv&quot; (data.frame with the derivatives of the residuals with 
respect to the parameters).
</p>

<hr>
<h2 id='resolveRecurrence'>Place top elements into bottom elemens</h2><span id='topic+resolveRecurrence'></span>

<h3>Description</h3>

<p>Place top elements into bottom elemens
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resolveRecurrence(variables)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resolveRecurrence_+3A_variables">variables</code></td>
<td>
<p>named character vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the names of top vector elements occur in the bottom of the vector, 
they are replaced by the character of the top entry. Useful for steady state conditions.
</p>


<h3>Value</h3>

<p>named character vector of the same length as <code>variables</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>resolveRecurrence(c(A = "k1*B/k2", C = "A*k3+k4", D="A*C*k5"))
</code></pre>

<hr>
<h2 id='rref'>Transform matrix A into reduced row echelon form 
this function is written along the lines of the rref-matlab function.</h2><span id='topic+rref'></span>

<h3>Description</h3>

<p>Transform matrix A into reduced row echelon form 
this function is written along the lines of the rref-matlab function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rref(A, tol = sqrt(.Machine$double.eps), verbose = FALSE, fractions = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rref_+3A_a">A</code></td>
<td>
<p>matrix for which the reduced row echelon form is searched</p>
</td></tr>
<tr><td><code id="rref_+3A_tol">tol</code></td>
<td>
<p>tolerance to find pivots</p>
</td></tr>
<tr><td><code id="rref_+3A_verbose">verbose</code></td>
<td>
<p>logical, print verbose information</p>
</td></tr>
<tr><td><code id="rref_+3A_fractions">fractions</code></td>
<td>
<p>logical, not used right now.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of two entries is returned; ret[[1]] is the reduced row echelon form of A, ret[[2]] is the index of columns in which a pivot was found
</p>


<h3>Author(s)</h3>

<p>Malenka Mader, <a href="mailto:Malenka.Mader@fdm.uni-freiburg.de">Malenka.Mader@fdm.uni-freiburg.de</a>
</p>

<hr>
<h2 id='scale_color_dMod'>Standard dMod color palette</h2><span id='topic+scale_color_dMod'></span>

<h3>Description</h3>

<p>Standard dMod color palette
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_color_dMod(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_color_dMod_+3A_...">...</code></td>
<td>
<p>arguments goint to codescale_color_manual()</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
times &lt;- seq(0, 2*pi, 0.1)
values &lt;- sin(times)
data &lt;- data.frame(
   time = times, 
   value = c(values, 1.2*values, 1.4*values, 1.6*values), 
   group = rep(c("C1", "C2", "C3", "C4"), each = length(times))
)
qplot(time, value, data = data, color = group, geom = "line") + 
   theme_dMod() + scale_color_dMod()
</code></pre>

<hr>
<h2 id='scale_fill_dMod'>Standard dMod color scheme</h2><span id='topic+scale_fill_dMod'></span>

<h3>Description</h3>

<p>Standard dMod color scheme
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_fill_dMod(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_fill_dMod_+3A_...">...</code></td>
<td>
<p>arguments goint to codescale_color_manual()</p>
</td></tr>
</table>

<hr>
<h2 id='stat.parlist'>Gather statistics of a fitlist</h2><span id='topic+stat.parlist'></span>

<h3>Description</h3>

<p>Gather statistics of a fitlist
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat.parlist(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat.parlist_+3A_x">x</code></td>
<td>
<p>The fitlist</p>
</td></tr>
</table>

<hr>
<h2 id='steadyStates'>Calculate analytical steady states.</h2><span id='topic+steadyStates'></span>

<h3>Description</h3>

<p>This function follows the method published in [1]. The determined steady-state solution is tailored to parameter estimation. Please note that kinetic parameters might be fixed for solution of steady-state equations. Note that additional parameters might be introduced to ensure positivity of the solution.
</p>
<p>The function calls a python script via rPython. Usage problems might occur when different python versions are used. The script was written and tested for python 2.7.12, sympy 0.7.6 and numpy 1.8.2.
</p>
<p>Recently, users went into problems with RJSONIO when rPython was used. Unless a sound solution is available, please try to reinstall RJSONIO in these cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>steadyStates(
  model,
  file = NULL,
  smatrix = NULL,
  states = NULL,
  rates = NULL,
  forcings = NULL,
  givenCQs = NULL,
  neglect = NULL,
  sparsifyLevel = 2,
  outputFormat = "R"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="steadyStates_+3A_model">model</code></td>
<td>
<p>Either name of the csv-file or the eqnlist of the model. If NULL, specify smatrix, states and rates by hand.</p>
</td></tr>
<tr><td><code id="steadyStates_+3A_file">file</code></td>
<td>
<p>Name of the file to which the steady-state equations are saved.
Read this file with <code><a href="base.html#topic+readRDS">readRDS</a></code>.</p>
</td></tr>
<tr><td><code id="steadyStates_+3A_smatrix">smatrix</code></td>
<td>
<p>Numeric matrix, stiochiometry matrix of the system</p>
</td></tr>
<tr><td><code id="steadyStates_+3A_states">states</code></td>
<td>
<p>Character vector, state vector of the system</p>
</td></tr>
<tr><td><code id="steadyStates_+3A_rates">rates</code></td>
<td>
<p>Character vector, flux vector of the system</p>
</td></tr>
<tr><td><code id="steadyStates_+3A_forcings">forcings</code></td>
<td>
<p>Character vector with the names of the forcings</p>
</td></tr>
<tr><td><code id="steadyStates_+3A_givencqs">givenCQs</code></td>
<td>
<p>Character vector with conserved quantities. Use the format c(&quot;A + pA = totA&quot;, &quot;B + pB = totB&quot;). If NULL, conserved quantities are automatically calculated.</p>
</td></tr>
<tr><td><code id="steadyStates_+3A_neglect">neglect</code></td>
<td>
<p>Character vector with names of states and parameters that must not be used for solving the steady-state equations</p>
</td></tr>
<tr><td><code id="steadyStates_+3A_sparsifylevel">sparsifyLevel</code></td>
<td>
<p>numeric, Upper bound for length of linear combinations used for simplifying the stoichiometric matrix</p>
</td></tr>
<tr><td><code id="steadyStates_+3A_outputformat">outputFormat</code></td>
<td>
<p>Define the output format. By default &quot;R&quot; generating dMod 
compatible output. To obtain an output appropriate for d2d [2] &quot;M&quot; must be 
selected.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector of steady-state equations.
</p>


<h3>Author(s)</h3>

<p>Marcus Rosenblatt, <a href="mailto:marcus.rosenblatt@fdm.uni-freiburg.de">marcus.rosenblatt@fdm.uni-freiburg.de</a>
</p>


<h3>References</h3>

<p>[1]
<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4863410/">https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4863410/</a>
</p>
<p>[2]
<a href="https://github.com/Data2Dynamics/d2d">https://github.com/Data2Dynamics/d2d</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
reactions &lt;- eqnlist()
reactions &lt;- addReaction(reactions, "Tca_buffer", "Tca_cyto", 
                         "import_Tca*Tca_buffer", "Basolateral uptake")
reactions &lt;- addReaction(reactions, "Tca_cyto", "Tca_buffer", 
                         "export_Tca_baso*Tca_cyto", "Basolateral efflux")
reactions &lt;- addReaction(reactions, "Tca_cyto", "Tca_canalicular", 
                         "export_Tca_cana*Tca_cyto", "Canalicular efflux")
reactions &lt;- addReaction(reactions, "Tca_canalicular", "Tca_buffer", 
                         "transport_Tca*Tca_canalicular", "Transport bile")

mysteadies &lt;- steadyStates(reactions)
print(mysteadies)

## End(Not run)
</code></pre>

<hr>
<h2 id='strelide'>Elide character vector</h2><span id='topic+strelide'></span>

<h3>Description</h3>

<p>Elide character vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strelide(string, width, where = "right", force = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strelide_+3A_string">string</code></td>
<td>
<p>String subject to eliding</p>
</td></tr>
<tr><td><code id="strelide_+3A_width">width</code></td>
<td>
<p>Width including eliding ... of return string</p>
</td></tr>
<tr><td><code id="strelide_+3A_where">where</code></td>
<td>
<p>Eliding can happen at 'left', 'middel', or 'right'. Defaults to
'right'.</p>
</td></tr>
<tr><td><code id="strelide_+3A_force">force</code></td>
<td>
<p>Elide, even is &lt;string&gt; is shorter than &lt;width&gt;. Default to
'FALSE'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Elide a string to &lt;width&gt;. Eliding can happen at 'left', 'middle', or
'right'. #' If forcing = FALSE, which is the default, strings shorten than
&lt;width&gt; are returend unaltered; forcing = TRUE inserts eliding symbols (...)
in any case.
</p>


<h3>Value</h3>

<p>Elided string of length &lt;width&gt;.
</p>


<h3>Author(s)</h3>

<p>Wolfgang Mader, <a href="mailto:Wolfgang.Mader@fdm.uni-freiburg.de">Wolfgang.Mader@fdm.uni-freiburg.de</a>
</p>

<hr>
<h2 id='strpad'>Pad string to desired width</h2><span id='topic+strpad'></span>

<h3>Description</h3>

<p>Pad string to desired width
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strpad(string, width, where = "right", padding = " ", autoelide = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strpad_+3A_string">string</code></td>
<td>
<p>String to pad</p>
</td></tr>
<tr><td><code id="strpad_+3A_width">width</code></td>
<td>
<p>Desired width of padded string</p>
</td></tr>
<tr><td><code id="strpad_+3A_where">where</code></td>
<td>
<p>Padding can be inserted to the right or left of &lt;string&gt;.
Default to 'right'.</p>
</td></tr>
<tr><td><code id="strpad_+3A_padding">padding</code></td>
<td>
<p>A single character with with the padding space is filled.
Defaults to blank ' ' yielding invisible padding.</p>
</td></tr>
<tr><td><code id="strpad_+3A_autoelide">autoelide</code></td>
<td>
<p>If TRUE, &lt;string&gt; is elided if it is wider than &lt;width&gt;. The
position of eliding follows &lt;where&gt;. Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Padded string of length &lt;width&gt;.
</p>


<h3>Author(s)</h3>

<p>Wolfgang Mader, <a href="mailto:Wolfgang.Mader@fdm.uni-freiburg.de">Wolfgang.Mader@fdm.uni-freiburg.de</a>
</p>

<hr>
<h2 id='submatrix'>Submatrix of a matrix returning ALWAYS a matrix</h2><span id='topic+submatrix'></span>

<h3>Description</h3>

<p>Submatrix of a matrix returning ALWAYS a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>submatrix(M, rows = 1:nrow(M), cols = 1:ncol(M))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="submatrix_+3A_m">M</code></td>
<td>
<p>matrix</p>
</td></tr>
<tr><td><code id="submatrix_+3A_rows">rows</code></td>
<td>
<p>Index vector</p>
</td></tr>
<tr><td><code id="submatrix_+3A_cols">cols</code></td>
<td>
<p>Index vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matrix <code>M[rows, cols]</code>, keeping/adjusting attributes like ncol nrow and dimnames.
</p>

<hr>
<h2 id='subset.eqnlist'>subset of an equation list</h2><span id='topic+subset.eqnlist'></span>

<h3>Description</h3>

<p>subset of an equation list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'eqnlist'
subset(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset.eqnlist_+3A_x">x</code></td>
<td>
<p>the equation list</p>
</td></tr>
<tr><td><code id="subset.eqnlist_+3A_...">...</code></td>
<td>
<p>logical expression for subsetting</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>...</code> can contain &quot;Educt&quot;, &quot;Product&quot;, &quot;Rate&quot; and &quot;Description&quot;.
The &quot;
</p>


<h3>Value</h3>

<p>An object of class <a href="#topic+eqnlist">eqnlist</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>reactions &lt;- data.frame(Description = c("Activation", "Deactivation"), 
                        Rate = c("act*A", "deact*pA"), A=c(-1,1), pA=c(1, -1) )
f &lt;- as.eqnlist(reactions)
subset(f, "A" %in% Educt)
subset(f, "pA" %in% Product)
subset(f, grepl("act", Rate))
</code></pre>

<hr>
<h2 id='summary.eqnvec'>Summary of an equation vector</h2><span id='topic+summary.eqnvec'></span>

<h3>Description</h3>

<p>Summary of an equation vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'eqnvec'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.eqnvec_+3A_object">object</code></td>
<td>
<p>of class <a href="#topic+eqnvec">eqnvec</a>.</p>
</td></tr>
<tr><td><code id="summary.eqnvec_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Wolfgang Mader, <a href="mailto:Wolfgang.Mader@fdm.uni-freiburg.de">Wolfgang.Mader@fdm.uni-freiburg.de</a>
</p>

<hr>
<h2 id='symmetryDetection'>Search for symmetries in the loaded model</h2><span id='topic+symmetryDetection'></span>

<h3>Description</h3>

<p>This function follows the method published in [1].
</p>
<p>The function calls a python script via rPython. Usage problems might occur when different python versions are used. The script was written and tested for python 2.7.12, sympy 0.7.6.
</p>
<p>Recently, users went into problems with RJSONIO when rPython was used. Unless a sound solution is available, please try to reinstall RJSONIO in these cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>symmetryDetection(
  f,
  obsvect = NULL,
  prediction = NULL,
  initial = NULL,
  ansatz = "uni",
  pMax = 2,
  inputs = NULL,
  fixed = NULL,
  cores = 1,
  allTrafos = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="symmetryDetection_+3A_f">f</code></td>
<td>
<p>object containing the ODE for which <code>as.eqnvec()</code> is defined</p>
</td></tr>
<tr><td><code id="symmetryDetection_+3A_obsvect">obsvect</code></td>
<td>
<p>vector of observation functions</p>
</td></tr>
<tr><td><code id="symmetryDetection_+3A_prediction">prediction</code></td>
<td>
<p>vector containing prediction to be tested</p>
</td></tr>
<tr><td><code id="symmetryDetection_+3A_initial">initial</code></td>
<td>
<p>vector containing initial values</p>
</td></tr>
<tr><td><code id="symmetryDetection_+3A_ansatz">ansatz</code></td>
<td>
<p>type of infinitesimal ansatz used for the analysis (uni, par, multi)</p>
</td></tr>
<tr><td><code id="symmetryDetection_+3A_pmax">pMax</code></td>
<td>
<p>maximal degree of infinitesimal ansatz</p>
</td></tr>
<tr><td><code id="symmetryDetection_+3A_inputs">inputs</code></td>
<td>
<p>specify the input variables</p>
</td></tr>
<tr><td><code id="symmetryDetection_+3A_fixed">fixed</code></td>
<td>
<p>variables to concider fixed</p>
</td></tr>
<tr><td><code id="symmetryDetection_+3A_cores">cores</code></td>
<td>
<p>maximal number of cores used for the analysis</p>
</td></tr>
<tr><td><code id="symmetryDetection_+3A_alltrafos">allTrafos</code></td>
<td>
<p>do not remove transformations with a common parameter factor</p>
</td></tr>
</table>


<h3>References</h3>

<p>[1]
<a href="https://journals.aps.org/pre/abstract/10.1103/PhysRevE.92.012920">https://journals.aps.org/pre/abstract/10.1103/PhysRevE.92.012920</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
eq &lt;- NULL
eq &lt;- addReaction(eq, "A", "B", "k1*A")
eq &lt;- addReaction(eq, "B", "A", "k2*B")

observables &lt;- eqnvec(Aobs = "alpha * A")

symmetryDetection(eq, observables)


## End(Not run)
</code></pre>

<hr>
<h2 id='theme_dMod'>Standard plotting theme of dMod</h2><span id='topic+theme_dMod'></span>

<h3>Description</h3>

<p>Standard plotting theme of dMod
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theme_dMod(base_size = 11, base_family = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="theme_dMod_+3A_base_size">base_size</code></td>
<td>
<p>numeric, font-size</p>
</td></tr>
<tr><td><code id="theme_dMod_+3A_base_family">base_family</code></td>
<td>
<p>character, font-name</p>
</td></tr>
</table>

<hr>
<h2 id='trust'>Non-Linear Optimization</h2><span id='topic+trust'></span><span id='topic+trustL1'></span>

<h3>Description</h3>

<p>This function carries out a minimization or maximization of a function 
using a trust region algorithm. See the references for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trust(
  objfun,
  parinit,
  rinit,
  rmax,
  parscale,
  iterlim = 100,
  fterm = sqrt(.Machine$double.eps),
  mterm = sqrt(.Machine$double.eps),
  minimize = TRUE,
  blather = FALSE,
  parupper = Inf,
  parlower = -Inf,
  printIter = FALSE,
  ...
)

trustL1(
  objfun,
  parinit,
  mu = 0 * parinit,
  one.sided = FALSE,
  lambda = 1,
  rinit,
  rmax,
  parscale,
  iterlim = 100,
  fterm = sqrt(.Machine$double.eps),
  mterm = sqrt(.Machine$double.eps),
  minimize = TRUE,
  blather = FALSE,
  blather2 = FALSE,
  parupper = Inf,
  parlower = -Inf,
  printIter = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trust_+3A_objfun">objfun</code></td>
<td>
<p>an R function that computes value, gradient, and Hessian of the 
function to be minimized or maximized and returns them as a list with 
components value, gradient, and hessian. Its first argument should be a 
vector of the length of parinit followed by any other arguments specified 
by the <code>...</code> argument.</p>
</td></tr>
<tr><td><code id="trust_+3A_parinit">parinit</code></td>
<td>
<p>starting parameter values for the optimization. Must be 
feasible (in the domain).</p>
</td></tr>
<tr><td><code id="trust_+3A_rinit">rinit</code></td>
<td>
<p>starting trust region radius. The trust region radius 
(see details below) is adjusted as the algorithm proceeds. A bad initial 
value wastes a few steps while the radius is adjusted, but does not keep 
the algorithm from working properly.</p>
</td></tr>
<tr><td><code id="trust_+3A_rmax">rmax</code></td>
<td>
<p>maximum allowed trust region radius. This may be set very large. 
If set small, the algorithm traces a steepest descent path (steepest ascent, 
when minimize = FALSE).</p>
</td></tr>
<tr><td><code id="trust_+3A_parscale">parscale</code></td>
<td>
<p>an estimate of the size of each parameter at the minimum. 
The algorithm operates as if optimizing function(x, ...) objfun(x / parscale, ...). 
May be missing in which case no rescaling is done. See also the details section below.</p>
</td></tr>
<tr><td><code id="trust_+3A_iterlim">iterlim</code></td>
<td>
<p>a positive integer specifying the maximum number of iterations 
to be performed before the program is terminated.</p>
</td></tr>
<tr><td><code id="trust_+3A_fterm">fterm</code></td>
<td>
<p>a positive scalar giving the tolerance at which the difference 
in objective function values in a step is considered close enough to zero to 
terminate the algorithm.</p>
</td></tr>
<tr><td><code id="trust_+3A_mterm">mterm</code></td>
<td>
<p>a positive scalar giving the tolerance at which the two-term 
Taylor-series approximation to the difference in objective function values in 
a step is considered close enough to zero to terminate the algorithm.</p>
</td></tr>
<tr><td><code id="trust_+3A_minimize">minimize</code></td>
<td>
<p>If TRUE minimize. If FALSE maximize.</p>
</td></tr>
<tr><td><code id="trust_+3A_blather">blather</code></td>
<td>
<p>If TRUE return extra info.</p>
</td></tr>
<tr><td><code id="trust_+3A_parupper">parupper</code></td>
<td>
<p>named numeric vector of upper bounds.</p>
</td></tr>
<tr><td><code id="trust_+3A_parlower">parlower</code></td>
<td>
<p>named numeric vector of lower bounds.</p>
</td></tr>
<tr><td><code id="trust_+3A_printiter">printIter</code></td>
<td>
<p>print iteration information to R console</p>
</td></tr>
<tr><td><code id="trust_+3A_...">...</code></td>
<td>
<p>additional argument to objfun</p>
</td></tr>
<tr><td><code id="trust_+3A_mu">mu</code></td>
<td>
<p>named numeric value. The reference value for L1 penalized parameters.</p>
</td></tr>
<tr><td><code id="trust_+3A_one.sided">one.sided</code></td>
<td>
<p>logical. One-sided penalization.</p>
</td></tr>
<tr><td><code id="trust_+3A_lambda">lambda</code></td>
<td>
<p>strength of the L1 penalty</p>
</td></tr>
<tr><td><code id="trust_+3A_blather2">blather2</code></td>
<td>
<p>even more information</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Fletcher (1987, Section 5.1) or Nocedal and Wright (1999, Section 4.2) 
for detailed expositions.
</p>


<h3>Value</h3>

<p>A list containing the following components:
</p>

<ul>
<li><p>value: the value returned by objfun at the final iterate.
</p>
</li>
<li><p>gradient: the gradient returned by objfun at the final iterate.
</p>
</li>
<li><p>hessian: the Hessian returned by objfun at the final iterate.
</p>
</li>
<li><p>argument: the final iterate
</p>
</li>
<li><p>converged: if TRUE the final iterate was deemed optimal by the 
specified termination criteria.
</p>
</li>
<li><p>iterations: number of trust region subproblems done (including those 
whose solutions are not accepted).
</p>
</li>
<li><p>argpath: (if blather == TRUE) the sequence of iterates, not including 
the final iterate.
</p>
</li>
<li><p>argtry: (if blather == TRUE) the sequence of solutions of the trust 
region subproblem.
</p>
</li>
<li><p>steptype: (if blather == TRUE) the sequence of cases that arise in 
solutions of the trust region subproblem. &quot;Newton&quot; means the Newton step 
solves the subproblem (lies within the trust region). Other values mean the 
subproblem solution is constrained. &quot;easy-easy&quot; means the eigenvectors 
corresponding to the minimal eigenvalue of the rescaled Hessian are not all 
orthogonal to the gradient. The other cases are rarely seen. &quot;hard-hard&quot; means 
the Lagrange multiplier for the trust region constraint is minus the minimal 
eigenvalue of the rescaled Hessian; &quot;hard-easy&quot; means it isn't.
</p>
</li>
<li><p>accept: (if blather == TRUE) indicates which of the sequence of 
solutions of the trust region subproblem were accepted as the next iterate. 
(When not accepted the trust region radius is reduced, and the previous iterate 
is kept.)
</p>
</li>
<li><p>r: (if blather == TRUE) the sequence of trust region radii.
</p>
</li>
<li><p>rho: (if blather == TRUE) the sequence of ratios of actual over 
predicted decrease in the objective function in the trust region subproblem, 
where predicted means the predicted decrease in the two-term Taylor series model 
used in the subproblem.
</p>
</li>
<li><p>valpath: (if blather == TRUE) the sequence of objective function values 
at the iterates.
</p>
</li>
<li><p>valtry: (if blather == TRUE) the sequence of objective function values 
at the solutions of the trust region subproblem.
</p>
</li>
<li><p>preddiff: (if blather == TRUE) the sequence of predicted differences using 
the two-term Taylor-series model between the function values at the current iterate 
and at the solution of the trust region subproblem.
</p>
</li>
<li><p>stepnorm: (if blather == TRUE) the sequence of norms of steps, that is 
distance between current iterate and proposed new iterate found in the trust region 
subproblem.
</p>
</li></ul>


<hr>
<h2 id='unique.parframe'>Extract those lines of a parameter frame with unique elements in the value column</h2><span id='topic+unique.parframe'></span>

<h3>Description</h3>

<p>Extract those lines of a parameter frame with unique elements in the value column
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'parframe'
unique(x, incomparables = FALSE, tol = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unique.parframe_+3A_x">x</code></td>
<td>
<p>parameter frame</p>
</td></tr>
<tr><td><code id="unique.parframe_+3A_incomparables">incomparables</code></td>
<td>
<p>not used. Argument exists for compatibility with S3 generic.</p>
</td></tr>
<tr><td><code id="unique.parframe_+3A_tol">tol</code></td>
<td>
<p>tolerance to decide when values are assumed to be equal, see <code><a href="#topic+plotValues">plotValues</a>()</code>.</p>
</td></tr>
<tr><td><code id="unique.parframe_+3A_...">...</code></td>
<td>
<p>additional arguments being passed to <code><a href="#topic+plotValues">plotValues</a>()</code>, e.g. for subsetting.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A subset of the parameter frame <code>x</code>.
</p>

<hr>
<h2 id='wide2long'>Translate wide output format (e.g. from ode) into long format</h2><span id='topic+wide2long'></span>

<h3>Description</h3>

<p>Translate wide output format (e.g. from ode) into long format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wide2long(out, keep = 1, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wide2long_+3A_out">out</code></td>
<td>
<p>data.frame or matrix or list of matrices in wide format</p>
</td></tr>
<tr><td><code id="wide2long_+3A_keep">keep</code></td>
<td>
<p>Index vector, the columns to keep</p>
</td></tr>
<tr><td><code id="wide2long_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical, if <code>TRUE</code>, missing values are removed in the long format.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function assumes that out[,1] represents a time-like vector
whereas out[,-1] represents the values. Useful for plotting with ggplot. If 
a list is supplied, the names of the list are added as extra column names &quot;condition&quot;
</p>


<h3>Value</h3>

<p>data.frame in long format, i.e. columns &quot;time&quot; (out[,1]), &quot;name&quot; (colnames(out[,-1])), 
&quot;value&quot; (out[,-1]) and, if out was a list, &quot;condition&quot; (names(out))
</p>

<hr>
<h2 id='wide2long.data.frame'>Translate wide output format (e.g. from ode) into long format</h2><span id='topic+wide2long.data.frame'></span>

<h3>Description</h3>

<p>Translate wide output format (e.g. from ode) into long format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.frame'
wide2long(out, keep = 1, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wide2long.data.frame_+3A_out">out</code></td>
<td>
<p>data.frame or matrix or list of matrices in wide format</p>
</td></tr>
<tr><td><code id="wide2long.data.frame_+3A_keep">keep</code></td>
<td>
<p>Index vector, the columns to keep</p>
</td></tr>
<tr><td><code id="wide2long.data.frame_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical, if <code>TRUE</code>, missing values are removed in the long format.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function assumes that out[,1] represents a time-like vector
whereas out[,-1] represents the values. Useful for plotting with ggplot. If 
a list is supplied, the names of the list are added as extra column names &quot;condition&quot;
</p>


<h3>Value</h3>

<p>data.frame in long format, i.e. columns &quot;time&quot; (out[,1]), &quot;name&quot; (colnames(out[,-1])), 
&quot;value&quot; (out[,-1]) and, if out was a list, &quot;condition&quot; (names(out))
</p>

<hr>
<h2 id='wide2long.list'>Translate wide output format (e.g. from ode) into long format</h2><span id='topic+wide2long.list'></span>

<h3>Description</h3>

<p>Translate wide output format (e.g. from ode) into long format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'list'
wide2long(out, keep = 1, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wide2long.list_+3A_out">out</code></td>
<td>
<p>list of matrices in wide format</p>
</td></tr>
<tr><td><code id="wide2long.list_+3A_keep">keep</code></td>
<td>
<p>Index vector, the columns to keep</p>
</td></tr>
<tr><td><code id="wide2long.list_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical, if <code>TRUE</code>, missing values are removed in the long format.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function assumes that out[,1] represents a time-like vector
whereas out[,-1] represents the values. Useful for plotting with ggplot. If 
a list is supplied, the names of the list are added as extra column names &quot;condition&quot;
</p>


<h3>Value</h3>

<p>data.frame in long format, i.e. columns &quot;time&quot; (out[,1]), &quot;name&quot; (colnames(out[,-1])), 
&quot;value&quot; (out[,-1]) and, if out was a list, &quot;condition&quot; (names(out))
</p>

<hr>
<h2 id='wide2long.matrix'>Translate wide output format (e.g. from ode) into long format</h2><span id='topic+wide2long.matrix'></span>

<h3>Description</h3>

<p>Translate wide output format (e.g. from ode) into long format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matrix'
wide2long(out, keep = 1, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wide2long.matrix_+3A_out">out</code></td>
<td>
<p>data.frame or matrix or list of matrices in wide format</p>
</td></tr>
<tr><td><code id="wide2long.matrix_+3A_keep">keep</code></td>
<td>
<p>Index vector, the columns to keep</p>
</td></tr>
<tr><td><code id="wide2long.matrix_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical, if <code>TRUE</code>, missing values are removed in the long format.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function assumes that out[,1] represents a time-like vector
whereas out[,-1] represents the values. Useful for plotting with ggplot. If 
a list is supplied, the names of the list are added as extra column names &quot;condition&quot;
</p>


<h3>Value</h3>

<p>data.frame in long format, i.e. columns &quot;time&quot; (out[,1]), &quot;name&quot; (colnames(out[,-1])), 
&quot;value&quot; (out[,-1]) and, if out was a list, &quot;condition&quot; (names(out))
</p>

<hr>
<h2 id='write.eqnlist'>Write equation list into a csv file</h2><span id='topic+write.eqnlist'></span>

<h3>Description</h3>

<p>Write equation list into a csv file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.eqnlist(eqnlist, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.eqnlist_+3A_eqnlist">eqnlist</code></td>
<td>
<p>object of class <a href="#topic+eqnlist">eqnlist</a></p>
</td></tr>
<tr><td><code id="write.eqnlist_+3A_...">...</code></td>
<td>
<p>Arguments going to <a href="utils.html#topic+write.table">write.table</a></p>
</td></tr>
</table>

<hr>
<h2 id='wrss'>Compute the weighted residual sum of squares</h2><span id='topic+wrss'></span>

<h3>Description</h3>

<p>Compute the weighted residual sum of squares
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wrss(nout)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wrss_+3A_nout">nout</code></td>
<td>
<p>data.frame (result of <a href="#topic+res">res</a>) or object of class <a href="#topic+objframe">objframe</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with entries value (numeric, the weighted residual sum of squares), 
gradient (numeric, gradient) and 
hessian (matrix of type numeric).
</p>

<hr>
<h2 id='Xd'>Model prediction function from data.frame</h2><span id='topic+Xd'></span>

<h3>Description</h3>

<p>Model prediction function from data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Xd(data, condition = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Xd_+3A_data">data</code></td>
<td>
<p>data.frame with columns &quot;name&quot;, &quot;time&quot;, and row names that 
are taken as parameter names. The data frame can contain a column &quot;value&quot;
to initialize the parameters.</p>
</td></tr>
<tr><td><code id="Xd_+3A_condition">condition</code></td>
<td>
<p>either NULL (generic prediction for any condition) or a character, denoting
the condition for which the function makes a prediction.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <a href="#topic+prdfn">prdfn</a>, i.e. 
a function <code>x(times pars, deriv = TRUE, conditions = NULL)</code>, 
see also <a href="#topic+Xs">Xs</a>. Attributes are &quot;parameters&quot;, the parameter names (row names of
the data frame), and possibly &quot;pouter&quot;, a named numeric vector which is generated
from <code>data$value</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a data.frame and corresponding prediction function
timesD &lt;- seq(0, 2*pi, 0.5)
mydata &lt;- data.frame(name = "A", time = timesD, value = sin(timesD), 
                     row.names = paste0("par", 1:length(timesD)))
x &lt;- Xd(mydata)

# Evaluate the prediction function at different time points
times &lt;- seq(0, 2*pi, 0.01)
pouter &lt;- structure(mydata$value, names = rownames(mydata))
prediction &lt;- x(times, pouter)
plot(prediction)

</code></pre>

<hr>
<h2 id='Xf'>Model prediction function for ODE models without sensitivities.</h2><span id='topic+Xf'></span>

<h3>Description</h3>

<p>Interface to get an ODE 
into a model function <code>x(times, pars, forcings, events)</code> returning ODE output.
It is a reduced version of <a href="#topic+Xs">Xs</a>, missing the sensitivities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Xf(
  odemodel,
  forcings = NULL,
  events = NULL,
  condition = NULL,
  optionsOde = list(method = "lsoda")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Xf_+3A_odemodel">odemodel</code></td>
<td>
<p>Object of class <a href="#topic+odemodel">odemodel</a>.</p>
</td></tr>
<tr><td><code id="Xf_+3A_forcings">forcings</code></td>
<td>
<p>see <a href="#topic+Xs">Xs</a></p>
</td></tr>
<tr><td><code id="Xf_+3A_events">events</code></td>
<td>
<p>see <a href="#topic+Xs">Xs</a></p>
</td></tr>
<tr><td><code id="Xf_+3A_condition">condition</code></td>
<td>
<p>either NULL (generic prediction for any condition) or a character, denoting
the condition for which the function makes a prediction.</p>
</td></tr>
<tr><td><code id="Xf_+3A_optionsode">optionsOde</code></td>
<td>
<p>list with arguments to be passed to odeC() for the ODE integration.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Can be used to integrate additional quantities, e.g. fluxes, by adding them to <code>f</code>. 
All quantities that are not initialised by pars 
in <code>x(..., forcings, events)</code> are initialized with 0. For more details and
the return value see <a href="#topic+Xs">Xs</a>.
</p>

<hr>
<h2 id='Xs'>Model prediction function for ODE models.</h2><span id='topic+Xs'></span>

<h3>Description</h3>

<p>Interface to combine an ODE and its sensitivity equations
into one model function <code>x(times, pars, deriv = TRUE)</code> returning ODE output and sensitivities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Xs(
  odemodel,
  forcings = NULL,
  events = NULL,
  names = NULL,
  condition = NULL,
  optionsOde = list(method = "lsoda"),
  optionsSens = list(method = "lsodes")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Xs_+3A_odemodel">odemodel</code></td>
<td>
<p>object of class <a href="#topic+odemodel">odemodel</a></p>
</td></tr>
<tr><td><code id="Xs_+3A_forcings">forcings</code></td>
<td>
<p>data.frame with columns name (factor), time (numeric) and value (numeric).
The ODE forcings.</p>
</td></tr>
<tr><td><code id="Xs_+3A_events">events</code></td>
<td>
<p>data.frame of events with columns &quot;var&quot; (character, the name of the state to be
affected), &quot;time&quot; (numeric, time point), &quot;value&quot; (numeric, value), &quot;method&quot; (character, either
&quot;replace&quot;, &quot;add&quot; or &quot;multiply&quot;). See <a href="deSolve.html#topic+events">events</a>.
ATTENTION: Sensitivities for event states will only be correctly computed if defined within
<code><a href="#topic+odemodel">odemodel</a>()</code>. Specify events within <code>Xs()</code> only for forward simulation.</p>
</td></tr>
<tr><td><code id="Xs_+3A_names">names</code></td>
<td>
<p>character vector with the states to be returned. If NULL, all states are returned.</p>
</td></tr>
<tr><td><code id="Xs_+3A_condition">condition</code></td>
<td>
<p>either NULL (generic prediction for any condition) or a character, denoting
the condition for which the function makes a prediction.</p>
</td></tr>
<tr><td><code id="Xs_+3A_optionsode">optionsOde</code></td>
<td>
<p>list with arguments to be passed to odeC() for the ODE integration.</p>
</td></tr>
<tr><td><code id="Xs_+3A_optionssens">optionsSens</code></td>
<td>
<p>list with arguments to be passed to odeC() for integration of the extended system</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <a href="#topic+prdfn">prdfn</a>. If the function is called with parameters that
result from a parameter transformation (see <a href="#topic+P">P</a>), the Jacobian of the parameter transformation
and the sensitivities of the ODE are multiplied according to the chain rule for
differentiation. The result is saved in the attributed &quot;deriv&quot;, 
i.e. in this case the attibutes &quot;deriv&quot; and &quot;sensitivities&quot; do not coincide.
</p>

<hr>
<h2 id='Xt'>Generate a prediction function that returns times</h2><span id='topic+Xt'></span>

<h3>Description</h3>

<p>Function to deal with non-ODE models within the framework of dMod. See example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Xt(condition = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Xt_+3A_condition">condition</code></td>
<td>
<p>either NULL (generic prediction for any condition) or a character, denoting
the condition for which the function makes a prediction.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <a href="#topic+prdfn">prdfn</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- Xt()
g &lt;- Y(c(y = "a*time^2+b"), f = NULL, parameters = c("a", "b"))

times &lt;- seq(-1, 1, by = .05)
pars &lt;- c(a = .1, b = 1)

plot((g*x)(times, pars))
</code></pre>

<hr>
<h2 id='Y'>Observation functions.</h2><span id='topic+Y'></span>

<h3>Description</h3>

<p>Creates an object of type <a href="#topic+obsfn">obsfn</a> that evaluates an observation function
and its derivatives based on the output of a model prediction function, see <a href="#topic+prdfn">prdfn</a>, 
as e.g. produced by <a href="#topic+Xs">Xs</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Y(
  g,
  f = NULL,
  states = NULL,
  parameters = NULL,
  condition = NULL,
  attach.input = TRUE,
  deriv = TRUE,
  compile = FALSE,
  modelname = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Y_+3A_g">g</code></td>
<td>
<p>Named character vector or equation vector defining the observation function</p>
</td></tr>
<tr><td><code id="Y_+3A_f">f</code></td>
<td>
<p>Named character of equations or object that can be converted to eqnvec or object of class fn.
If f is provided, states and parameters are guessed from f.</p>
</td></tr>
<tr><td><code id="Y_+3A_states">states</code></td>
<td>
<p>character vector, alternative definition of &quot;states&quot;, usually the names of <code>f</code>. If both,
f and states are provided, the states argument overwrites the states derived from f.</p>
</td></tr>
<tr><td><code id="Y_+3A_parameters">parameters</code></td>
<td>
<p>character vector, alternative definition of the &quot;parameters&quot;,
usually the symbols contained in &quot;g&quot; and &quot;f&quot; except for <code>states</code> and the code word <code>time</code>. If both,
f and parameters are provided, the parameters argument overwrites the parameters derived from f and g.</p>
</td></tr>
<tr><td><code id="Y_+3A_condition">condition</code></td>
<td>
<p>either NULL (generic prediction for any condition) or a character, denoting
the condition for which the function makes a prediction.</p>
</td></tr>
<tr><td><code id="Y_+3A_attach.input">attach.input</code></td>
<td>
<p>logical, indiating whether the original input should be
returned with the output.</p>
</td></tr>
<tr><td><code id="Y_+3A_deriv">deriv</code></td>
<td>
<p>logical, generate function to evaluate derivatives of observables. Necessary for parameter estimation.</p>
</td></tr>
<tr><td><code id="Y_+3A_compile">compile</code></td>
<td>
<p>Logical, compile the function (see <a href="#topic+funC0">funC0</a>)</p>
</td></tr>
<tr><td><code id="Y_+3A_modelname">modelname</code></td>
<td>
<p>Character, used if <code>compile = TRUE</code>, sets a fixed filename for the
C file.</p>
</td></tr>
<tr><td><code id="Y_+3A_verbose">verbose</code></td>
<td>
<p>Print compiler output to R command line.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <a href="#topic+odemodel">odemodel</a>s with forcings, it is best, to pass the prediction function <code>x</code> to the &quot;f&quot;-argument 
instead of the equations themselves. If an eqnvec is passed to &quot;f&quot; in this case, the forcings and states
have to be specified manually via the &quot;states&quot;-argument.
</p>


<h3>Value</h3>

<p>Object of class <a href="#topic+obsfn">obsfn</a>, i.e.
a function <code>y(..., deriv = TRUE, conditions = NULL)</code> representing the evaluation of the 
observation function. Arguments <code>out</code> (model prediction) and <code>pars</code> (parameter values)
shoudl be passed by the <code>...</code> argument.
If <code>out</code> has the attribute  &quot;sensitivities&quot;, the result of
<code>y(out, pars)</code>, will have an attributed &quot;deriv&quot; which reflecs the sensitivities of 
the observation with respect to the parameters.
If <code>pars</code> is the result of a parameter transformation <code>p(pars)</code> (see <a href="#topic+P">P</a>), 
the Jacobian 
of the parameter transformation and the sensitivities of the observation function
are multiplied according to the chain rule for differentiation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define a time grid on which to make a prediction by peace-wise linear function.
# Then define a (generic) prediction function based on thid grid.
times &lt;- 0:5
grid &lt;- data.frame(name = "A", time = times, row.names = paste0("p", times))
x &lt;- Xd(grid)

# Define an observable and an observation function
observables &lt;- eqnvec(Aobs = "s*A")
g &lt;- Y(g = observables, f = NULL, states = "A", parameters = "s")

# Collect parameters and define an overarching parameter transformation
# for two "experimental condtions".
dynpars &lt;- attr(x, "parameters")
obspars &lt;- attr(g, "parameters")
innerpars &lt;- c(dynpars, obspars)

trafo &lt;- structure(innerpars, names = innerpars)
trafo_C1 &lt;- replaceSymbols(innerpars, paste(innerpars, "C1", sep = "_"), trafo)
trafo_C2 &lt;- replaceSymbols(innerpars, paste(innerpars, "C2", sep = "_"), trafo)

p &lt;- NULL
p &lt;- p + P(trafo = trafo_C1, condition = "C1")
p &lt;- p + P(trafo = trafo_C2, condition = "C2")

# Collect outer (overarching) parameters and 
# initialize with random values
outerpars &lt;- attr(p, "parameters")
pars &lt;- structure(runif(length(outerpars), 0, 1), names = outerpars)

# Predict internal/unobserved states
out1 &lt;- (x*p)(times, pars)
plot(out1)

# Predict observed states in addition to unobserved
out2 &lt;- (g*x*p)(times, pars)
plot(out2)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
