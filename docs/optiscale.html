<!DOCTYPE html><html lang="en"><head><title>Help for package optiscale</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {optiscale}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#optiscale-package'><p>Optimal Scaling of a Data Vector</p></a></li>
<li><a href='#elec92'>
<p>Public Opinion During the 1992 U.S. Presidential Election</p></a></li>
<li><a href='#Methods'>
<p>S3 methods for opscale</p></a></li>
<li><a href='#opscale'>
<p>Optimal scaling of a data vector</p></a></li>
<li><a href='#os.plot'>
<p>Graph of optimal scaling transformation</p></a></li>
<li><a href='#shepard'>
<p>Shepard diagram for opscale</p></a></li>
<li><a href='#stress'>
<p>Stress coefficients for <code>opscale</code></p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Optimal Scaling</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-05-15</td>
</tr>
<tr>
<td>Description:</td>
<td>Optimal scaling of a data vector, relative to a set of targets, is
    obtained through a least-squares transformation subject to appropriate measurement
    constraints. The targets are usually predicted values from a statistical
    model. If the data are nominal level, then the transformation must be
    identity-preserving. If the data are ordinal level, then the
    transformation must be monotonic. If the data are discrete, then tied data
    values must remain tied in the optimal transformation. If the data are
    continuous, then tied data values can be untied in the optimal
    transformation.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>lattice</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-15 18:04:19 UTC; david</td>
</tr>
<tr>
<td>Author:</td>
<td>Dave Armstrong [aut, cre],
  William Jacoby [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dave Armstrong &lt;davearmstrong.ps@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-16 07:30:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='optiscale-package'>Optimal Scaling of a Data Vector</h2><span id='topic+optiscale-package'></span><span id='topic+optiscale'></span>

<h3>Description</h3>

<p>This package provides tools to perform an optimal scaling analysis
on a data vector.
The main result of the optimal scaling is a vector of scores which
are a least-squares approximation to a vector of quantitative
values, subject to measurement constraints based upon a vector
of qualitative data values.
See Young (1981) for details.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> optiscale</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.2.2</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2021-02-02</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2 </td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The function that performs the optimal scaling is <code>opscale()</code>.
It produces an object of class &quot;opscale&quot;.
Generic methods are defined for <code>print</code>, <code>summary</code>, and
<code>plot</code> (graphing optimally-scaled values versus
original data values).
</p>


<h3>Author(s)</h3>

<p>William G. Jacoby
</p>
<p>Maintainer: 
William G. Jacoby &lt;<a href="mailto:wm.g.jacoby@gmail.com">wm.g.jacoby@gmail.com</a>&gt;
</p>


<h3>References</h3>

<p>Young, Forrest W. (1981) &ldquo;Quantitative Analysis of
Qualitative Data.&rdquo; <em>Psychometrika</em> 46: 357-388.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+opscale">opscale</a>,<a href="#topic+plot.opscale">plot.opscale</a>, <a href="#topic+print.opscale">print.opscale</a>,
   <a href="#topic+summary.opscale">summary.opscale</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ###   x1 is vector of qualitative data
  ###   x2 is vector of quantitative values
            x1 &lt;- c(1,1,1,1,2,2,2,3,3,3,3,3,3)     
            x2 &lt;- c(3,2,2,2,1,2,3,4,5,2,6,6,4)     
  ###   Optimal scaling, specifying that x1
  ###   is ordinal-discrete
     op.scaled &lt;- opscale(x.qual=x1, x.quant=x2,   
                  level=2, process=1)              
     print(op.scaled)
     summary(op.scaled)
</code></pre>

<hr>
<h2 id='elec92'>
Public Opinion During the 1992 U.S. Presidential Election
</h2><span id='topic+elec92'></span>

<h3>Description</h3>

<p>This data set contains several variables from the Center for
Political Studies 1992 National Election Study.
Observations with missing values on any of the variables have
been deleted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(elec92)</code></pre>


<h3>Format</h3>

<p>A data frame with 1653 observations on the following 7 variables.
</p>

<dl>
<dt><code>caseid</code></dt><dd><p>NES case identification number</p>
</dd>
<dt><code>bush</code></dt><dd><p> Respondents feeling thermometer rating of George H. W. Bush</p>
</dd>
<dt><code>ideol</code></dt><dd><p>Respondents ideological self-placement, seven-point scale
ranging from 1=extremely liberal to 7=extremely conservative</p>
</dd>
<dt><code>econ4yr</code></dt><dd><p>Respondents judgment whether national economy has gotten 
better or worse over preceding four years, 
five-point scale ranging from 1=much better to 5=much worse</p>
</dd>
<dt><code>party</code></dt><dd><p>Respondents party identification, seven-point scale ranging
from 0=strong Democrat to 6=strong Republican</p>
</dd>
<dt><code>choice</code></dt><dd><p>Difference in respondents feeling thermometer ratings of
Bush and Clinton</p>
</dd>
<dt><code>clinton</code></dt><dd><p>Respondent&rdquo;s feeling thermometer rating of Bill Clinton</p>
</dd>
</dl>



<h3>Source</h3>

<p>The full data set from which these observations and variables were extracted is
available on the Study Page for the American National Election Studies
1992 Time Series Study, at 
<a href="https://electionstudies.org/data-center/1992-time-series-study/">https://electionstudies.org/data-center/1992-time-series-study/</a>.
</p>


<h3>References</h3>

<p>Jacoby, William G. (1999) &ldquo;Levels of Measurement and Political Research: An Optimistic View.&rdquo;
<em>American Journal of Political Science</em> 43: 271-301.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(optiscale)
data(elec92)
summary(lm(choice ~ party + ideol + econ4yr, data = elec92))
</code></pre>

<hr>
<h2 id='Methods'>
S3 methods for opscale
</h2><span id='topic+Methods'></span><span id='topic+plot.opscale'></span><span id='topic+print.opscale'></span><span id='topic+print.summary.opscale'></span><span id='topic+summary.opscale'></span>

<h3>Description</h3>

<p>Plot, print, shepard, stress, and summary methods for objects of class <code>opscale</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'opscale'
plot(x, ...)
## S3 method for class 'opscale'
print(x, ...)
## S3 method for class 'opscale'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Methods_+3A_object">object</code></td>
<td>
<p>Object of class <code>opscale</code></p>
</td></tr>
<tr><td><code id="Methods_+3A_x">x</code></td>
<td>
<p>Object of class <code>opscale</code></p>
</td></tr>
<tr><td><code id="Methods_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Method <code>print</code> returns a listing of the data. 
<code>summary</code> describes the optimal scale transformation. 
<code>plot</code> calls <code>os.plot</code> and returns an object of class <code>trellis</code> that 
graphs optimally-scaled values against the original (qualitative)
data values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+os.plot">os.plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ###   x1 is vector of qualitative data
  ###   x2 is vector of quantitative values
            x1 &lt;- c(1,1,1,1,2,2,2,3,3,3,3,3,3)     
            x2 &lt;- c(3,2,2,2,1,2,3,4,5,2,6,6,4)     
  ###   Optimal scaling, specifying that x1
  ###   is ordinal-discrete
     op.scaled &lt;- opscale(x.qual=x1, x.quant=x2,   
                  level=2, process=1)              
     print(op.scaled)
     summary(op.scaled)
     plot(op.scaled)
</code></pre>

<hr>
<h2 id='opscale'>
Optimal scaling of a data vector
</h2><span id='topic+opscale'></span>

<h3>Description</h3>

<p>This function produces an object of class &quot;opscale&quot;, containing a
vector that is a least-squares approximation
to a vector of quantitative values, subject to measurement constraints
based upon a vector of qualitative data values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opscale(x.qual, x.quant = seq(1:length(x.qual)), level = 1,
   process = 1, na.impute = FALSE,
   na.assign = TRUE, rescale = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opscale_+3A_x.qual">x.qual</code></td>
<td>

<p>A vector of data values, assumed to be qualitative.
</p>
</td></tr>
<tr><td><code id="opscale_+3A_x.quant">x.quant</code></td>
<td>

<p>A vector of quantitative values.
</p>
</td></tr>
<tr><td><code id="opscale_+3A_level">level</code></td>
<td>

<p>Measurement level of <code>x.qual</code>. 1=nominal, 2=ordinal.
</p>
</td></tr>
<tr><td><code id="opscale_+3A_process">process</code></td>
<td>

<p>Measurement process of <code>x.qual</code>. 1=discrete, 2=continuous.
</p>
</td></tr>
<tr><td><code id="opscale_+3A_na.impute">na.impute</code></td>
<td>

<p>If <code>TRUE</code>, then assign <code>x.quant</code> values to optimally
scaled vector for missing entries in <code>x.qual</code>.
of <code>FALSE</code> then assign <code>NA</code> to entries in optimally scaled
vector corresponding to missing entries in <code>x.qual</code>.
</p>
</td></tr>
<tr><td><code id="opscale_+3A_na.assign">na.assign</code></td>
<td>

<p>If <code>TRUE</code>, then if <code>x.quant</code> is missing, assign
mean of optimally scaled values for the corresponding
<code>x.qual</code> value to the optimally scaled vector.
If <code>FALSE</code>, then leave optimally
scaled value missing, even if <code>x.qual</code> value is present.
</p>
</td></tr>
<tr><td><code id="opscale_+3A_rescale">rescale</code></td>
<td>

<p>If <code>TRUE</code> then rescale optimally scaled vector
to same mean and standard deviation as <code>x.qual</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>opscale()</code> function operationalizes a measurement theory
proposed by Young (1981) in order to facilitate an analysis strategy
called &ldquo;Alternating Least Squares, Optimal Scaling&rdquo;.
The optimal scaling transformation produces a vector (say, <code>OS</code>)
that is a least-squares approximation to <code>x.quant</code>, subject to
measurement constraints based upon <code>x.qual</code>.
If <code>x.qual</code> is nominal level, then the values in <code>OS</code> are
the conditional means of <code>x.quant</code>, within distinct categories
of <code>x.qual</code>. If <code>x.qual</code> is ordinal level, then the values in
<code>OS</code> are the conditional means of <code>x.quant</code>, adjusted to be
weakly monotonic to the values in <code>x.qual</code>, using Kruskals (1964b)
monotonic transformation.
If <code>x.qual</code> is discrete, then all data objects sharing a common value
in <code>x.qual</code> must be assigned the same value in <code>OS</code>.
If <code>x.qual</code> is continuous, then data objects sharing a common value
in <code>x.qual</code> can fall within a closed interval of values in <code>OS</code>.
The continuous-discrete measurement process distinction corresponds to
Kruskals (1964a) primary and secondary approaches to ties.
</p>


<h3>Value</h3>

<p>The <code>opscale()</code> function returns an object of class &quot;opscale&quot;
containing a list with the following components:
</p>
<table role = "presentation">
<tr><td><code>qual</code></td>
<td>
<p>The qualitative data vector, <code>x.qual</code></p>
</td></tr>
<tr><td><code>quant</code></td>
<td>
<p>The vector of quantitative values, <code>x.quant</code></p>
</td></tr>
<tr><td><code>os</code></td>
<td>
<p>The vector of optimally scaled values</p>
</td></tr>
<tr><td><code>varname</code></td>
<td>
<p>The name of the qualitative data vector, <code>x.qual</code></p>
</td></tr>
<tr><td><code>measlev</code></td>
<td>
<p>The measurement level of the qualitative data vector specified
in the <code>level</code> argument to <code>opscale</code></p>
</td></tr>
<tr><td><code>measproc</code></td>
<td>
<p>The measurement process of the qualitative data vector specified
in the <code>process</code> argument to <code>opscale</code></p>
</td></tr>
<tr><td><code>rescale</code></td>
<td>
<p>Value of the <code>rescale</code> argument to <code>opscale</code></p>
</td></tr>
<tr><td><code>os.raw.mean</code></td>
<td>
<p>Mean of optimally scaled values before rescaling</p>
</td></tr>
<tr><td><code>os.raw.sd</code></td>
<td>
<p>Standard deviation of optimally scaled values before rescaling</p>
</td></tr>
</table>


<h3>References</h3>

<p>Kruskal, Joseph B. (1964a) &ldquo;Multidimensional Scaling by Optimizing
Goodness of Fit to a Nonmetric Hypothesis.&rdquo; <em>Psychometrika</em> 29: 1-27.
</p>
<p>Kruskal, Joseph B. (1964b) &ldquo;Nonmetric Multidimensional Scaling:
A Numerical Method.&rdquo; <em>Psychometrika</em> 29: 115-129.
</p>
<p>Young, Forrest W. (1981) &ldquo;Quantitative Analysis of
Qualitative Data.&rdquo; <em>Psychometrika</em> 46: 357-388.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.opscale">plot.opscale</a>, <a href="#topic+print.opscale">print.opscale</a>,
   <a href="#topic+summary.opscale">summary.opscale</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ###   x1 is vector of qualitative data
  ###   x2 is vector of quantitative values
            x1 &lt;- c(1,1,1,1,2,2,2,3,3,3,3,3,3)
            x2 &lt;- c(3,2,2,2,1,2,3,4,5,2,6,6,4)
  ###   Optimal scaling, specifying that x1
  ###   is ordinal-discrete
     op.scaled &lt;- opscale(x.qual=x1, x.quant=x2,
                  level=2, process=1)
     print(op.scaled)
     summary(op.scaled)
</code></pre>

<hr>
<h2 id='os.plot'>
Graph of optimal scaling transformation
</h2><span id='topic+os.plot'></span>

<h3>Description</h3>

<p>Line and point plot showing optimally-scaled values on the 
vertical axis, original data values (assumed to be qualitative)
on the horizontal axis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   os.plot(x.qual, os.data, 
      main.title = "Plot of optimal transformation")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="os.plot_+3A_x.qual">x.qual</code></td>
<td>
<p>Vector of data values, assumed to be qualitative.
</p>
</td></tr>
<tr><td><code id="os.plot_+3A_os.data">os.data</code></td>
<td>

<p>Vector of optimally-scaled data values.
</p>
</td></tr>
<tr><td><code id="os.plot_+3A_main.title">main.title</code></td>
<td>

<p>Main title for plot.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>trellis</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.opscale">plot.opscale</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ###   x1 is vector of qualitative data
  ###   x2 is vector of quantitative values
            x1 &lt;- c(1,1,1,1,2,2,2,3,3,3,3,3,3)     
            x2 &lt;- c(3,2,2,2,1,2,3,4,5,2,6,6,4)     
  ###   Optimal scaling, specifying that x1
  ###   is ordinal-discrete
     op.scaled &lt;- opscale(x.qual=x1, x.quant=x2,   
                  level=2, process=1)              
  ###   Plot of optimal scaling transformation
     os.plot(op.scaled$qual, op.scaled$os)         
</code></pre>

<hr>
<h2 id='shepard'>
Shepard diagram for opscale
</h2><span id='topic+shepard'></span><span id='topic+shep.plot'></span>

<h3>Description</h3>

<p>Graph showing data (assumed quantitative) on vertical axis, optimally-scaled
data on horizontal axis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shepard(x, ...)

shep.plot(x.quant, os.data, main.title = "Shepard Diagram")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shepard_+3A_x">x</code></td>
<td>

<p>An object of class <code>opscale</code>
</p>
</td></tr>
<tr><td><code id="shepard_+3A_x.quant">x.quant</code></td>
<td>

<p>Data vector, assumed to be quantitative.
</p>
</td></tr>
<tr><td><code id="shepard_+3A_os.data">os.data</code></td>
<td>

<p>Optimally-scaled data.
</p>
</td></tr>
<tr><td><code id="shepard_+3A_main.title">main.title</code></td>
<td>

<p>Main title for graph.
</p>
</td></tr>
<tr><td><code id="shepard_+3A_...">...</code></td>
<td>

<p>Ignored
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>shepard()</code> and <code>shep.plot()</code> both
produce an object of class <code>trellis</code>
</p>


<h3>Warning </h3>

<p>If using <code>shep.plot()</code>,
the Shepard diagram should be created using &quot;raw&quot; optimally scaled values.
That is, the OS values should NOT be rescaled to the mean and standard
deviation of the original qualitative data.</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ###   x1 is vector of qualitative data
  ###   x2 is vector of quantitative values
            x1 &lt;- c(1,1,1,1,2,2,2,3,3,3,3,3,3)     
            x2 &lt;- c(3,2,2,2,1,2,3,4,5,2,6,6,4)     
  ###   Optimal scaling, specifying that x1
  ###   is ordinal-discrete, optimally scaled
  ###   values are not rescaled
     op.scaled &lt;- opscale(x.qual=x1, x.quant=x2,   
                  level=2, process=1,
                  rescale=FALSE)              
  ###   Create Shepard diagram
     shepard(op.scaled)
  ###   Same results are produced by:
     shep.plot(op.scaled$quant, op.scaled$os)       
</code></pre>

<hr>
<h2 id='stress'>
Stress coefficients for <code>opscale</code>
</h2><span id='topic+stress'></span><span id='topic+calc.stress'></span>

<h3>Description</h3>

<p>Calculates stress coefficients summarizing lack of fit between two vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stress(x, ...)

calc.stress(quant, os, rescale = FALSE, 
   os.raw.mean = mean(os, na.rm = TRUE), 
   os.raw.sd = sd(os, na.rm = TRUE))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stress_+3A_x">x</code></td>
<td>

<p>Object of class <code>opscale</code>
</p>
</td></tr>
<tr><td><code id="stress_+3A_quant">quant</code></td>
<td>

<p>Data vector.
</p>
</td></tr>
<tr><td><code id="stress_+3A_os">os</code></td>
<td>

<p>Vector of optimally-scaled data
</p>
</td></tr>
<tr><td><code id="stress_+3A_rescale">rescale</code></td>
<td>

<p>If TRUE, the optimally-scaled data have been rescaled to the mean and standard deviation of
the original qualitative data vector that was used in the optimal scaling transformation.
</p>
</td></tr>
<tr><td><code id="stress_+3A_os.raw.mean">os.raw.mean</code></td>
<td>

<p>User-specified mean for optimally-scaled data, defaults to mean of <code>os</code>. 
Only needed if <code>rescale = TRUE</code>.
</p>
</td></tr>
<tr><td><code id="stress_+3A_os.raw.sd">os.raw.sd</code></td>
<td>

<p>User-specified standard deviation for optimally-scaled data, defaults to
standard deviation of <code>os</code>. 
Only needed if <code>rescale = TRUE</code>.
</p>
</td></tr>
<tr><td><code id="stress_+3A_...">...</code></td>
<td>

<p>Ignored
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>stress()</code> and <code>calc.stress()</code> both
produce a vector with three elements:
</p>
<table role = "presentation">
<tr><td><code>stress1</code></td>
<td>
<p>Kruskals Stress 1 coefficient</p>
</td></tr>
<tr><td><code>stress2</code></td>
<td>
<p>Kruskals Stress 2 coefficient</p>
</td></tr>
<tr><td><code>raw.stress</code></td>
<td>
<p>Sum of squared residuals between <code>quant</code> and <code>os</code></p>
</td></tr>
</table>


<h3>Warning </h3>

<p>If using <code>calc.stress()</code>, the
stress coefficients must be created using &quot;raw&quot; optimally scaled values.
That is, the OS values should NOT be rescaled to the mean and standard
deviation of the original qualitative data.</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ###   x1 is vector of qualitative data
  ###   x2 is vector of quantitative values
            x1 &lt;- c(1,1,1,1,2,2,2,3,3,3,3,3,3)     
            x2 &lt;- c(3,2,2,2,1,2,3,4,5,2,6,6,4)     
  ###   Optimal scaling, specifying that x1
  ###   is ordinal-discrete, optimally scaled 
  ###   values are not rescaled
     op.scaled &lt;- opscale(x.qual=x1, x.quant=x2,   
                  level=2, process=1,
                  rescale=FALSE)              
  ###  Calculate stress coefficients
    stress(op.scaled)
  ###   Same results can be obtained with:
    calc.stress(op.scaled$quant, op.scaled$os)                               
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
