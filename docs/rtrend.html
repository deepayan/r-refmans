<!DOCTYPE html><html lang="en"><head><title>Help for package rtrend</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rtrend}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#rtrend-package'><p>rtrend: Trend Estimating Tools</p></a></li>
<li><a href='#acf.fft'><p>faster autocorrelation based on ffw</p></a></li>
<li><a href='#apply_3d'><p>apply function for 3d array</p></a></li>
<li><a href='#apply_col'><p>apply_col</p></a></li>
<li><a href='#array_3dTo2d'><p>array_3dTo2d</p></a></li>
<li><a href='#chunk'><p>chunk</p></a></li>
<li><a href='#llply_par'><p>parallel apply and llply</p></a></li>
<li><a href='#mkTrend_r'><p>Modified Mann Kendall</p></a></li>
<li><a href='#movmean'><p>movmean</p></a></li>
<li><a href='#set_dim'><p>Set dimensions of an Object</p></a></li>
<li><a href='#slope_arr'><p>slope_arr</p></a></li>
<li><a href='#slope_rast'><p>calculate slope of rast object</p></a></li>
<li><a href='#slope_sen'><p>slope</p></a></li>
<li><a href='#smooth_wSG'><p>Weighted Savitzky-Golay</p></a></li>
<li><a href='#split_data'><p>split_data</p></a></li>
<li><a href='#summary_lm'><p>summary_lm</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Trend Estimating Tools</td>
</tr>
<tr>
<td>Description:</td>
<td>The traditional linear regression trend, Modified Mann-Kendall (MK)
    non-parameter trend and bootstrap trend are included in this package. Linear 
    regression trend is rewritten by '.lm.fit'. MK trend is rewritten by 'Rcpp'.
    Finally, those functions are about 10 times faster than previous version 
    in R.
    Reference:
    Hamed, K. H., &amp; Rao, A. R. (1998). A modified Mann-Kendall trend test for 
    autocorrelated data. Journal of hydrology, 204(1-4), 182-196. 
    &lt;<a href="https://doi.org/10.1016%2FS0022-1694%2897%2900125-X">doi:10.1016/S0022-1694(97)00125-X</a>&gt;.</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.5</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, fftwtools, boot, magrittr, matrixStats, lubridate,
terra, plyr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/rpkgs/rtrend">https://github.com/rpkgs/rtrend</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/rpkgs/rtrend/issues">https://github.com/rpkgs/rtrend/issues</a></td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-11 01:58:18 UTC; kongdd</td>
</tr>
<tr>
<td>Author:</td>
<td>Dongdong Kong <a href="https://orcid.org/0000-0003-1836-8172"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Heyang Song <a href="https://orcid.org/0000-0002-4192-5603"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dongdong Kong &lt;kongdd.sysu@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-11 03:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='rtrend-package'>rtrend: Trend Estimating Tools</h2><span id='topic+rtrend'></span><span id='topic+rtrend-package'></span>

<h3>Description</h3>

<p>The traditional linear regression trend, Modified Mann-Kendall (MK) non-parameter trend and bootstrap trend are included in this package. Linear regression trend is rewritten by '.lm.fit'. MK trend is rewritten by 'Rcpp'. Finally, those functions are about 10 times faster than previous version in R. Reference: Hamed, K. H., &amp; Rao, A. R. (1998). A modified Mann-Kendall trend test for autocorrelated data. Journal of hydrology, 204(1-4), 182-196. <a href="https://doi.org/10.1016/S0022-1694%2897%2900125-X">doi:10.1016/S0022-1694(97)00125-X</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Dongdong Kong <a href="mailto:kongdd.sysu@gmail.com">kongdd.sysu@gmail.com</a> (<a href="https://orcid.org/0000-0003-1836-8172">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Heyang Song <a href="mailto:7800556@gmail.com">7800556@gmail.com</a> (<a href="https://orcid.org/0000-0002-4192-5603">ORCID</a>)
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/rpkgs/rtrend">https://github.com/rpkgs/rtrend</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/rpkgs/rtrend/issues">https://github.com/rpkgs/rtrend/issues</a>
</p>
</li></ul>


<hr>
<h2 id='acf.fft'>faster autocorrelation based on ffw</h2><span id='topic+acf.fft'></span>

<h3>Description</h3>

<p>This function is 4-times faster than <code><a href="stats.html#topic+acf">stats::acf()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>acf.fft(x, lag.max = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="acf.fft_+3A_lag.max">lag.max</code></td>
<td>
<p>maximum lag at which to calculate the acf.
Default is <code class="reqn">10\log_{10}(N/m)</code> where <code class="reqn">N</code> is the
number of observations and <code class="reqn">m</code> the number of series.  Will
be automatically limited to one less than the number of observations
in the series.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array with the same dimensions as x containing the estimated autocorrelation.
</p>


<h3>References</h3>


<ol>
<li><p> https://github.com/santiagobarreda/phonTools/blob/main/R/fastacf.R
</p>
</li>
<li><p> https://gist.github.com/FHedin/05d4d6d74e67922dfad88038b04f621c
</p>
</li>
<li><p> https://gist.github.com/ajkluber/f293eefba2f946f47bfa
</p>
</li>
<li><p> http://www.tibonihoo.net/literate_musing/autocorrelations.html#wikispecd
</p>
</li>
<li><p> https://lingpipe-blog.com/2012/06/08/autocorrelation-fft-kiss-eigen
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
x &lt;- rnorm(100)
r_fast &lt;- acf.fft(x)
r &lt;- acf(x, plot=FALSE, lag.max=100)$acf[,,1]
</code></pre>

<hr>
<h2 id='apply_3d'>apply function for 3d array</h2><span id='topic+apply_3d'></span>

<h3>Description</h3>

<p>NA values will be removed automatically
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_3d(
  array,
  dim = 3,
  FUN = rowMeans2,
  by = NULL,
  scale = 1,
  na.rm = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apply_3d_+3A_array">array</code></td>
<td>
<p>A 3d array</p>
</td></tr>
<tr><td><code id="apply_3d_+3A_dim">dim</code></td>
<td>
<p>giving the subscripts to split up data by.</p>
</td></tr>
<tr><td><code id="apply_3d_+3A_fun">FUN</code></td>
<td>
<p>function, should only be row applied function, e.g. <code>matrixStats::rowMeans2</code>,
<code>matrixStats::rowMins</code>, <code>matrixStats::rowRanges</code>.
Because 3d array will be convert to matrix first, with the aggregated dim in
the last dimension.</p>
</td></tr>
<tr><td><code id="apply_3d_+3A_by">by</code></td>
<td>

<ul>
<li><p> If not provided (<code>NULL</code>), the aggregated dim will be disappear.
For example, daily precipitation <code style="white-space: pre;">&#8288;[nrow, ncol, 31-days]&#8288;</code> aggregate into
monthly <code style="white-space: pre;">&#8288;[nrow, ncol]&#8288;</code>.
</p>
</li>
<li><p> If provided, <code>by</code> should be equal to the aggregated <code>dim</code>.
For example, daily precipitation <code style="white-space: pre;">&#8288;[nrow, ncol, 365-days]&#8288;</code> aggregate into
monthly <code style="white-space: pre;">&#8288;[nrow, ncol, 12-months]&#8288;</code>. In that situation, <code>by</code> should be equal
to 365, and be <code>format(date, '%Y%m')</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="apply_3d_+3A_scale">scale</code></td>
<td>
<p>in the same length of <code>by</code>, or a const value,
<code>value_returned</code> = <code>FUN(x)*scale</code>. This parameter is designed for converting
monthly to yearly, meanwhile multiply days in month.
Currently, same group should have the same scale factor. Otherwise, only the
first is used.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+apply_row">apply_row</a> <a href="matrixStats.html#topic+rowRanges">matrixStats::rowRanges</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
size &lt;- c(10, 8, 31)
arr &lt;- array(rnorm(10 * 8 * 31), dim = size)

by &lt;- c(rep(1, 10), rep(2, 21))
r2 &lt;- apply_3d(arr, 3, by = by, FUN = rowMeans)

## Not run: 
arr_yearly &lt;- apply_3d(arr, by = year(dates), scale = days_in_month(dates))

## End(Not run)
</code></pre>

<hr>
<h2 id='apply_col'>apply_col</h2><span id='topic+apply_col'></span><span id='topic+apply_row'></span>

<h3>Description</h3>


<ul>
<li> <p><code>apply_col</code>: aggregate by col, return a <code style="white-space: pre;">&#8288;[ngrp, ncol]&#8288;</code> matrix
</p>
</li>
<li> <p><code>apply_row</code>: aggregate by row, return a <code style="white-space: pre;">&#8288;[nrow, ngrp]&#8288;</code> matrix
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>apply_col(mat, by, FUN = colMeans2, scale = 1, ...)

apply_row(mat, by, FUN = rowMeans2, scale = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apply_col_+3A_mat">mat</code></td>
<td>
<p>matrix, <code style="white-space: pre;">&#8288;[nrow, ncol]&#8288;</code></p>
</td></tr>
<tr><td><code id="apply_col_+3A_by">by</code></td>
<td>
<p>integer vector, with the dim of <code style="white-space: pre;">&#8288;[ntime]&#8288;</code></p>
</td></tr>
<tr><td><code id="apply_col_+3A_scale">scale</code></td>
<td>
<p>in the same length of <code>by</code>, or a const value,
<code>value_returned</code> = <code>FUN(x)*scale</code>. This parameter is designed for converting
monthly to yearly, meanwhile multiply days in month.
Currently, same group should have the same scale factor. Otherwise, only the
first is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For example, setting the dimension of <code>mat</code> is <code style="white-space: pre;">&#8288;[ngrid, ntime]&#8288;</code>,
if you want to aggregate by time, <code>apply_row</code> should be used here;
if you want to aggregate by region (grids), <code>apply_col</code> should be used.
</p>


<h3>Note</h3>

<p>This function also suits for big.matrix object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat &lt;- matrix(rnorm(4 * 6), 4, 6)
mat_bycol &lt;- apply_col(mat, c(1, 1, 2, 2), colMeans)
mat_byrow &lt;- apply_row(mat, c(1, 1, 2, 2, 3, 3), rowMeans)

</code></pre>

<hr>
<h2 id='array_3dTo2d'>array_3dTo2d</h2><span id='topic+array_3dTo2d'></span><span id='topic+array_2dTo3d'></span>

<h3>Description</h3>

<p>array_3dTo2d
</p>


<h3>Usage</h3>

<pre><code class='language-R'>array_3dTo2d(array, I_grid = NULL)

array_2dTo3d(array, I_grid = NULL, dim)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="array_3dTo2d_+3A_array">array</code></td>
<td>
<p>array with the dimension of <code style="white-space: pre;">&#8288;[nlon, nlat, ntime]&#8288;</code></p>
</td></tr>
<tr><td><code id="array_3dTo2d_+3A_i_grid">I_grid</code></td>
<td>
<p>subindex of <code style="white-space: pre;">&#8288;[nrow, ncol]&#8288;</code></p>
</td></tr>
<tr><td><code id="array_3dTo2d_+3A_dim">dim</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[nrow, ncol]&#8288;</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code style="white-space: pre;">&#8288;[nlat*nlon, ntime]&#8288;</code>
</p>

<hr>
<h2 id='chunk'>chunk</h2><span id='topic+chunk'></span>

<h3>Description</h3>

<p>chunk
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chunk(x, nchunk = 6)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chunk_+3A_x">x</code></td>
<td>
<p>a vector or list</p>
</td></tr>
<tr><td><code id="chunk_+3A_nchunk">nchunk</code></td>
<td>
<p>the number of chunks to be splitted</p>
</td></tr>
</table>


<h3>References</h3>

<p>https://stackoverflow.com/questions/3318333/split-a-vector-into-chunks-in-r
</p>

<hr>
<h2 id='llply_par'>parallel apply and llply</h2><span id='topic+llply_par'></span><span id='topic+parLapply2'></span><span id='topic+apply_par'></span>

<h3>Description</h3>

<p>parallel apply and llply
</p>


<h3>Usage</h3>

<pre><code class='language-R'>llply_par(X, FUN, ..., byrow = TRUE, .combine = c)

parLapply2(X, FUN, ..., byrow = TRUE, .combine = c)

apply_par(X, .margins = 1, FUN, ..., .progress = "text")
</code></pre>

<hr>
<h2 id='mkTrend_r'>Modified Mann Kendall</h2><span id='topic+mkTrend_r'></span><span id='topic+mkTrend'></span>

<h3>Description</h3>

<p>If valid observations &lt;= 5, NA will be returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mkTrend_r(y, ci = 0.95, IsPlot = FALSE)

mkTrend(y, x = seq_along(y), ci = 0.95, IsPlot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mkTrend_r_+3A_y">y</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="mkTrend_r_+3A_ci">ci</code></td>
<td>
<p>critical value of autocorrelation</p>
</td></tr>
<tr><td><code id="mkTrend_r_+3A_isplot">IsPlot</code></td>
<td>
<p>boolean</p>
</td></tr>
<tr><td><code id="mkTrend_r_+3A_x">x</code></td>
<td>
<p>(optional) numeric vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>mkTrend is 4-fold faster with <code>.lm.fit</code>.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>Z0</code>   : The original (non corrected) Mann-Kendall test Z statistic.
</p>
</li>
<li> <p><code>pval0</code>: The original (non corrected) Mann-Kendall test p-value
</p>
</li>
<li> <p><code>Z</code>    : The new Z statistic after applying the correction
</p>
</li>
<li> <p><code>pval</code> : Corrected p-value after accounting for serial autocorrelation
<code>N/n*s</code> Value of the correction factor, representing the quotient of the number
of samples N divided by the effective sample size <code>n*s</code>
</p>
</li>
<li> <p><code>slp</code>  : Sen slope, The slope of the (linear) trend according to Sen test
</p>
</li></ul>



<h3>Note</h3>

<p>slp is significant, if pval &lt; alpha.
</p>


<h3>Author(s)</h3>

<p>Dongdong Kong
</p>


<h3>References</h3>

<p>Hipel, K.W. and McLeod, A.I. (1994),
<em>Time Series Modelling of Water Resources and Environmental Systems</em>.
New York: Elsevier Science.
</p>
<p>Libiseller, C. and Grimvall, A., (2002), Performance of partial
Mann-Kendall tests for trend detection in the presence of covariates.
<em>Environmetrics</em> 13, 71&ndash;84, <a href="https://doi.org/10.1002/env.507">doi:10.1002/env.507</a>.
</p>


<h3>See Also</h3>

<p><code>fume::mktrend</code> and <code>trend::mk.test</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(4.81, 4.17, 4.41, 3.59, 5.87, 3.83, 6.03, 4.89, 4.32, 4.69)
r &lt;- mkTrend(x)
r_cpp &lt;- mkTrend(x, IsPlot = TRUE)
</code></pre>

<hr>
<h2 id='movmean'>movmean</h2><span id='topic+movmean'></span><span id='topic+movmean2'></span><span id='topic+movmean_2d'></span>

<h3>Description</h3>

<p>NA and Inf values in the y will be ignored automatically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>movmean(y, halfwin = 1L, SG_style = FALSE, w = NULL)

movmean2(y, win_left = 1L, win_right = 0L, w = NULL)

movmean_2d(mat, win_left = 3L, win_right = 0L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="movmean_+3A_y">y</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="movmean_+3A_halfwin">halfwin</code></td>
<td>
<p>Integer, half of moving window size</p>
</td></tr>
<tr><td><code id="movmean_+3A_sg_style">SG_style</code></td>
<td>
<p>If true, head and tail values will be in the style of SG
(more weights on the center point), else traditional moving mean style.</p>
</td></tr>
<tr><td><code id="movmean_+3A_w">w</code></td>
<td>
<p>Corresponding weights of y, with the same length.</p>
</td></tr>
<tr><td><code id="movmean_+3A_win_left">win_left</code>, <code id="movmean_+3A_win_right">win_right</code></td>
<td>
<p>windows size in the left and right</p>
</td></tr>
<tr><td><code id="movmean_+3A_mat">mat</code></td>
<td>
<p>numeric matrix</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:100
x[50] &lt;- NA; x[80] &lt;- Inf
s1 &lt;- movmean(x, 2, SG_style = TRUE)
s2 &lt;- movmean(x, 2, SG_style = FALSE)
movmean2(c(4, 8, 6, -1, -2, -3, -1), 2, 0)
movmean2(c(4, 8, NA, -1, -2, Inf, -1), 2, 0)
</code></pre>

<hr>
<h2 id='set_dim'>Set dimensions of an Object</h2><span id='topic+set_dim'></span><span id='topic+set_dimnames'></span>

<h3>Description</h3>

<p>Set dimensions of an Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_dim(x, dim)

set_dimnames(x, value)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_dim_+3A_x">x</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object, for example a matrix, array or data frame.</p>
</td></tr>
<tr><td><code id="set_dim_+3A_dim">dim</code></td>
<td>
<p>integer vector, see also <code><a href="base.html#topic+dim">base::dim()</a></code></p>
</td></tr>
<tr><td><code id="set_dim_+3A_value">value</code></td>
<td>
<p>For the default method, either <code>NULL</code> or
a numeric vector, which is coerced to integer (by truncation).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="base.html#topic+dim">base::dim</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:12
set_dim(x, c(3, 4))
</code></pre>

<hr>
<h2 id='slope_arr'>slope_arr</h2><span id='topic+slope_arr'></span>

<h3>Description</h3>

<p>slope_arr
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slope_arr(
  arr,
  fun = rtrend::slope_mk,
  return.list = FALSE,
  .progress = "text",
  ...
)
</code></pre>


<h3>Value</h3>

<p>t, A 3d array, with the dim of <code style="white-space: pre;">&#8288;[nx, ny, 2]&#8288;</code>.
</p>

<ul>
<li> <p><code>t[,,1]</code>: slope
</p>
</li>
<li> <p><code>t[,,2]</code>: pvalue
</p>
</li></ul>


<hr>
<h2 id='slope_rast'>calculate slope of rast object</h2><span id='topic+slope_rast'></span><span id='topic+rast_filter_time'></span>

<h3>Description</h3>

<p>calculate slope of rast object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slope_rast(
  r,
  period = c(2001, 2020),
  outfile = NULL,
  fun = rtrend::slope_mk,
  ...,
  overwrite = FALSE,
  .progress = "text"
)

rast_filter_time(r, period = c(2001, 2020))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="slope_rast_+3A_r">r</code></td>
<td>
<p>A yearly rast object, which should have time attribute</p>
</td></tr>
<tr><td><code id="slope_rast_+3A_period">period</code></td>
<td>
<p><code>c(year_begin, year_end)</code></p>
</td></tr>
<tr><td><code id="slope_rast_+3A_outfile">outfile</code></td>
<td>
<p>The path of outputed tiff file. If specified, <code>slope</code> and
<code>pvalue</code> will be written into <code>outfile</code>.</p>
</td></tr>
<tr><td><code id="slope_rast_+3A_fun">fun</code></td>
<td>
<p>the function used to calculate slope, see <code><a href="#topic+slope">slope()</a></code> for details.</p>
</td></tr>
<tr><td><code id="slope_rast_+3A_...">...</code></td>
<td>
<p>other parameters ignored</p>
</td></tr>
<tr><td><code id="slope_rast_+3A_overwrite">overwrite</code></td>
<td>
<p>logical. If <code>TRUE</code>, <code>outfile</code> is overwritten.</p>
</td></tr>
<tr><td><code id="slope_rast_+3A_.progress">.progress</code></td>
<td>
<p>name of the progress bar to use, see
<code><a href="plyr.html#topic+create_progress_bar">create_progress_bar</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A terra rast object, with bands of <code>slope</code> and <code>pvalue</code>.
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+rast">terra::rast()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(rtrend)
library(terra)

f &lt;- system.file("rast/MOD15A2_LAI_China_G050_2001-2020.tif", package = "rtrend")
r &lt;- rast(f)
r
time(r)

slp &lt;- slope_rast(r,
  period = c(2001, 2020), 
  outfile = "LAI_trend.tif", overwrite = TRUE,
  fun = rtrend::slope_mk, .progress = "none"
)
# if you want to show progress, set `.progress = "text"`
slp
plot(slp)

file.remove("LAI_trend.tif")
</code></pre>

<hr>
<h2 id='slope_sen'>slope</h2><span id='topic+slope_sen'></span><span id='topic+slope'></span><span id='topic+slope_p'></span><span id='topic+slope_sen_r'></span><span id='topic+slope_mk'></span><span id='topic+slope_boot'></span>

<h3>Description</h3>


<ul>
<li> <p><code>slope</code>     : linear regression slope
</p>
</li>
<li> <p><code>slope_p</code>   : linear regression slope and p-value
</p>
</li>
<li> <p><code>slope_mk</code>  : mann kendall Sen's slope and p-value
</p>
</li>
<li> <p><code>slope_sen</code> : same as <code>slope_mk</code>, but with no p-value
</p>
</li>
<li> <p><code>slope_boot</code>: bootstrap slope and p-value
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>slope_sen(y, x = NULL)

slope(y, x, ...)

slope_p(y, x, fast = TRUE)

slope_sen_r(y, x = seq_along(y), ...)

slope_mk(y, x = NULL, ...)

slope_boot(y, x = NULL, slope_FUN = slope, times = 100, alpha = 0.1, seed, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="slope_sen_+3A_y">y</code></td>
<td>
<p>vector of observations of length n, or a matrix with n rows.</p>
</td></tr>
<tr><td><code id="slope_sen_+3A_x">x</code></td>
<td>
<p>vector of predictor of length n, or a matrix with n rows.</p>
</td></tr>
<tr><td><code id="slope_sen_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
<tr><td><code id="slope_sen_+3A_fast">fast</code></td>
<td>
<p>Boolean. If true, <code><a href="stats.html#topic+lmfit">stats::.lm.fit()</a></code> will be used, which is 10x
faster than <code><a href="stats.html#topic+lm">stats::lm()</a></code>.</p>
</td></tr>
<tr><td><code id="slope_sen_+3A_slope_fun">slope_FUN</code></td>
<td>
<p>one of <code><a href="#topic+slope">slope()</a></code>, <code><a href="#topic+slope_p">slope_p()</a></code>, <code><a href="#topic+slope_mk">slope_mk()</a></code></p>
</td></tr>
<tr><td><code id="slope_sen_+3A_times">times</code></td>
<td>
<p>The number of bootstrap replicates.</p>
</td></tr>
<tr><td><code id="slope_sen_+3A_alpha">alpha</code></td>
<td>
<p>significant level, defalt 0.1</p>
</td></tr>
<tr><td><code id="slope_sen_+3A_seed">seed</code></td>
<td>
<p>a single value, interpreted as an integer, or <code>NULL</code>
(see &lsquo;Details&rsquo;).</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>slope</code>  : linear regression coefficient
</p>
</li>
<li> <p><code>pvalue</code> : <code style="white-space: pre;">&#8288;p-value &lt;= 0.05`` means that corresponding &#8288;</code>slope' is significant.
</p>
</li>
<li> <p><code>sd</code>     : <code style="white-space: pre;">&#8288;Std. Error&#8288;</code>
</p>
</li></ul>

<p>For <code>slope_boot</code>, slope is estimated in many times. The lower, mean, upper
and standard deviation (sd) are returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- c(4.81, 4.17, 4.41, 3.59, 5.87, 3.83, 6.03, 4.89, 4.32, 4.69)
r &lt;- slope(y)
r_p &lt;- slope_p(y)
r_mk &lt;- slope_mk(y)
r_boot &lt;- slope_boot(y)
</code></pre>

<hr>
<h2 id='smooth_wSG'>Weighted Savitzky-Golay</h2><span id='topic+smooth_wSG'></span><span id='topic+smooth_SG'></span>

<h3>Description</h3>

<p>NA and Inf values in the y has been ignored automatically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth_wSG(y, halfwin = 1L, d = 1L, w = NULL)

smooth_SG(y, halfwin = 1L, d = 1L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smooth_wSG_+3A_y">y</code></td>
<td>
<p>colvec</p>
</td></tr>
<tr><td><code id="smooth_wSG_+3A_halfwin">halfwin</code></td>
<td>
<p>halfwin of Savitzky-Golay</p>
</td></tr>
<tr><td><code id="smooth_wSG_+3A_d">d</code></td>
<td>
<p>polynomial of degree. When d = 1, it becomes moving average.</p>
</td></tr>
<tr><td><code id="smooth_wSG_+3A_w">w</code></td>
<td>
<p>colvec of weight</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- c(1, 3, 2, 5, 6, 8, 10, 1)
w &lt;- seq_along(y)/length(y)

halfwin = 2
d = 2
s1 &lt;- smooth_wSG(y, halfwin, d, w)
s2 &lt;- smooth_SG(y, halfwin, d)
</code></pre>

<hr>
<h2 id='split_data'>split_data</h2><span id='topic+split_data'></span>

<h3>Description</h3>

<p>split_data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_data(x, nchunk = 6, byrow = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="split_data_+3A_x">x</code></td>
<td>
<p>a vector, list, or matrix (not support 3d array)</p>
</td></tr>
<tr><td><code id="split_data_+3A_nchunk">nchunk</code></td>
<td>
<p>the number of chunks to be splitted</p>
</td></tr>
<tr><td><code id="split_data_+3A_byrow">byrow</code></td>
<td>
<p>If <code>TRUE</code>, split by row, otherwise by column.</p>
</td></tr>
</table>

<hr>
<h2 id='summary_lm'>summary_lm</h2><span id='topic+summary_lm'></span>

<h3>Description</h3>

<p>summary method for class &quot;.lm.fit&quot;.. It's 200 times faster than traditional <code>lm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summary_lm(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary_lm_+3A_obj">obj</code></td>
<td>
<p>Object returned by <code><a href="stats.html#topic+.lm.fit">.lm.fit</a></code>.</p>
</td></tr>
<tr><td><code id="summary_lm_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a p x 4 matrix with columns for the estimated coefficient, its standard error,
t-statistic and corresponding (two-sided) p-value. Aliased coefficients are omitted.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(129)
n &lt;- 100
p &lt;- 2
X &lt;- matrix(rnorm(n * p), n, p) # no intercept!
y &lt;- rnorm(n)

obj &lt;- .lm.fit (x = cbind(1, X), y = y) 
info &lt;- summary_lm(obj)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
