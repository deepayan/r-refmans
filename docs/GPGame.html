<!DOCTYPE html><html><head><title>Help for package GPGame</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {GPGame}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#crit_PNash'><p>Probability for a strategy of being a Nash Equilibrium</p></a></li>
<li><a href='#crit_SUR_Eq'><p>SUR criterion for equilibria</p></a></li>
<li><a href='#filter_for_Game'><p>All-purpose filter</p></a></li>
<li><a href='#generate_integ_pts'><p>Strategy generation</p></a></li>
<li><a href='#getEquilibrium'><p>Equilibrium computation of a discrete game for a given matrix with objectives values</p></a></li>
<li><a href='#GPGame'><p>Package GPGame</p></a></li>
<li><a href='#nonDom'><p>Generic non-domination computation</p></a></li>
<li><a href='#plotGame'><p>Plot equilibrium search result (2-objectives only)</p></a></li>
<li><a href='#plotGameGrid'><p>Visualisation of equilibrium solution in input/output space</p></a></li>
<li><a href='#restart_sg'><p>Restart existing run</p></a></li>
<li><a href='#solve_game'><p>Main solver</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Solving Complex Game Problems using Gaussian Processes</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-01-21</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Victor Picheny &lt;victor.picheny@inra.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Sequential strategies for finding a game equilibrium are proposed in a black-box setting (expensive pay-off evaluations, no derivatives). The algorithm handles noiseless or noisy evaluations. Two acquisition functions are available. Graphical outputs can be generated automatically. V. Picheny, M. Binois, A. Habbal (2018) &lt;<a href="https://doi.org/10.1007%2Fs10898-018-0688-0">doi:10.1007/s10898-018-0688-0</a>&gt;. M. Binois, V. Picheny, P. Taillandier, A. Habbal (2020) &lt;<a href="https://arxiv.org/abs/1902.06565v2">arXiv:1902.06565v2</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.5), DiceKriging, GPareto, KrigInv, DiceDesign,
MASS, mnormt, mvtnorm, methods, matrixStats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>DiceOptim, testthat</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/vpicheny/GPGame">https://github.com/vpicheny/GPGame</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/vpicheny/GPGame/issues">https://github.com/vpicheny/GPGame/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-01-21 17:38:24 UTC; victor</td>
</tr>
<tr>
<td>Author:</td>
<td>Victor Picheny <a href="https://orcid.org/0000-0002-4948-5542"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Mickael Binois [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-01-23 16:22:45 UTC</td>
</tr>
</table>
<hr>
<h2 id='crit_PNash'>Probability for a strategy of being a Nash Equilibrium</h2><span id='topic+crit_PNash'></span>

<h3>Description</h3>

<p>Acquisition function for solving game problems based on the probability for a strategy of being a Nash Equilibrium.
The probability can be computed exactly using the mutivariate Gaussian CDF (<code>mnormt</code>, <code>pmvnorm</code>) or by Monte Carlo.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crit_PNash(
  idx,
  integcontrol,
  type = "simu",
  model,
  ncores = 1,
  control = list(nsim = 100, eps = 1e-06)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crit_PNash_+3A_idx">idx</code></td>
<td>
<p>is the index on the grid of the strategy evaluated</p>
</td></tr>
<tr><td><code id="crit_PNash_+3A_integcontrol">integcontrol</code></td>
<td>
<p>is a list containing: <code>integ.pts</code>, a [<code>npts x dim</code>] matrix defining the grid,
<code>expanded.indices</code> a matrix containing the indices of the <code>integ.pts</code> on the grid and <code>n.s</code>,
a <code>nobj</code> vector containting the number of strategies per player</p>
</td></tr>
<tr><td><code id="crit_PNash_+3A_type">type</code></td>
<td>
<p>'<code>exact</code>' or '<code>simu</code>'</p>
</td></tr>
<tr><td><code id="crit_PNash_+3A_model">model</code></td>
<td>
<p>is a list of nobj <code><a href="DiceKriging.html#topic+km">km</a></code> models</p>
</td></tr>
<tr><td><code id="crit_PNash_+3A_ncores">ncores</code></td>
<td>
<p><code><a href="parallel.html#topic+mclapply">mclapply</a></code> is used if <code>&gt; 1</code> for parallel evaluation</p>
</td></tr>
<tr><td><code id="crit_PNash_+3A_control">control</code></td>
<td>
<p>list with slots <code>nsim</code> (number of conditional simulations for computation) and <code>eps</code></p>
</td></tr>
<tr><td><code id="crit_PNash_+3A_eps">eps</code></td>
<td>
<p>numerical jitter for stability</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Probability of being a Nash equibrium corrsponding to <code>idx</code>.
</p>


<h3>References</h3>

<p>V. Picheny, M. Binois, A. Habbal (2016+), A Bayesian optimization approach to find Nash equilibria,
<em>https://arxiv.org/abs/1611.02440</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crit_SUR_Eq">crit_SUR_Eq</a></code> for an alternative infill criterion
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##############################################
# Example 1: 2 variables, 2 players, no filter
##############################################
library(DiceKriging)
set.seed(42)

# Define objective function (R^2 -&gt; R^2)
fun &lt;- function (x)
{
  if (is.null(dim(x)))    x &lt;- matrix(x, nrow = 1)
 b1 &lt;- 15 * x[, 1] - 5
 b2 &lt;- 15 * x[, 2]
 return(cbind((b2 - 5.1*(b1/(2*pi))^2 + 5/pi*b1 - 6)^2 + 10*((1 - 1/(8*pi)) * cos(b1) + 1),
               -sqrt((10.5 - b1)*(b1 + 5.5)*(b2 + 0.5)) - 1/30*(b2 - 5.1*(b1/(2*pi))^2 - 6)^2-
                1/3 * ((1 - 1/(8 * pi)) * cos(b1) + 1)))
}

# Grid definition
n.s &lt;- rep(11, 2)
x.to.obj   &lt;- c(1,2)
gridtype &lt;- 'cartesian'
integcontrol &lt;- generate_integ_pts(n.s=n.s, d=2, nobj=2, x.to.obj = x.to.obj, gridtype=gridtype)

test.grid &lt;- integcontrol$integ.pts
expanded.indices &lt;- integcontrol$expanded.indices
n.init &lt;- 11
design &lt;- test.grid[sample.int(n=nrow(test.grid), size=n.init, replace=FALSE),]
response &lt;- t(apply(design, 1, fun))
mf1 &lt;- km(~., design = design, response = response[,1], lower=c(.1,.1))
mf2 &lt;- km(~., design = design, response = response[,2], lower=c(.1,.1))
model &lt;- list(mf1, mf2)

crit_sim &lt;- crit_PNash(idx=1:nrow(test.grid), integcontrol=integcontrol,
                       type = "simu", model=model, control = list(nsim = 100))
crit_ex &lt;- crit_PNash(idx=1:nrow(test.grid), integcontrol=integcontrol, type = "exact", model=model)

filled.contour(seq(0, 1, length.out = n.s[1]), seq(0, 1, length.out = n.s[2]), zlim = c(0, 0.7),
               matrix(pmax(0, crit_sim), n.s[1], n.s[2]), main = "Pnash criterion (MC)",
               xlab = expression(x[1]), ylab = expression(x[2]), color = terrain.colors,
               plot.axes = {axis(1); axis(2);
                            points(design[,1], design[,2], pch = 21, bg = "white")
                           }
)

filled.contour(seq(0, 1, length.out = n.s[1]), seq(0, 1, length.out = n.s[2]), zlim = c(0, 0.7),
               matrix(pmax(0, crit_ex), n.s[1], n.s[2]), main = "Pnash criterion (exact)",
               xlab = expression(x[1]), ylab = expression(x[2]), color = terrain.colors,
               plot.axes = {axis(1); axis(2);
                            points(design[,1], design[,2], pch = 21, bg = "white")
                           }
)

</code></pre>

<hr>
<h2 id='crit_SUR_Eq'>SUR criterion for equilibria</h2><span id='topic+crit_SUR_Eq'></span>

<h3>Description</h3>

<p>Computes the SUR criterion associated to an equilibrium for a given <code>xnew</code> and a set of trajectories of objective functions
on a predefined grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crit_SUR_Eq(
  idx,
  model,
  integcontrol,
  Simu,
  precalc.data = NULL,
  equilibrium,
  n.ynew = NULL,
  cross = FALSE,
  IS = FALSE,
  plot = FALSE,
  kweights = NULL,
  Nadir = NULL,
  Shadow = NULL,
  calibcontrol = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crit_SUR_Eq_+3A_idx">idx</code></td>
<td>
<p>is the index on the grid of the strategy evaluated</p>
</td></tr>
<tr><td><code id="crit_SUR_Eq_+3A_model">model</code></td>
<td>
<p>is a list of <code>nobj</code> <code><a href="DiceKriging.html#topic+km">km</a></code> models</p>
</td></tr>
<tr><td><code id="crit_SUR_Eq_+3A_integcontrol">integcontrol</code></td>
<td>
<p>is a list containing: <code>integ.pts</code>, a [<code>npts x dim</code>] matrix defining the grid,
<code>expanded.indices</code> a matrix containing the indices of the <code>integ.pts</code> on the grid and <code>n.s</code>,
a <code>nobj</code> vector containing the number of strategies per player</p>
</td></tr>
<tr><td><code id="crit_SUR_Eq_+3A_simu">Simu</code></td>
<td>
<p>is a matrix of size [<code>npts x nsim*nobj</code>] containing the trajectories of the
objective functions (one column per trajectory,
first all the trajectories for obj1, then obj2, etc.)</p>
</td></tr>
<tr><td><code id="crit_SUR_Eq_+3A_precalc.data">precalc.data</code></td>
<td>
<p>is a list of length <code>nobj</code> of precalculated data (based on kriging models at integration points)
for faster computation - computed if not provided</p>
</td></tr>
<tr><td><code id="crit_SUR_Eq_+3A_equilibrium">equilibrium</code></td>
<td>
<p>equilibrium type: either &quot;<code>NE</code>&quot;, &quot;<code>KSE</code>&quot;, &quot;<code>CKSE</code>&quot; or &quot;<code>NKSE</code>&quot;</p>
</td></tr>
<tr><td><code id="crit_SUR_Eq_+3A_n.ynew">n.ynew</code></td>
<td>
<p>is the number of <code>ynew</code> simulations (if not provided, equal to the number of trajectories)</p>
</td></tr>
<tr><td><code id="crit_SUR_Eq_+3A_cross">cross</code></td>
<td>
<p>if <code>TRUE</code>, all the combinations of trajectories are used (increases accuracy but also cost)</p>
</td></tr>
<tr><td><code id="crit_SUR_Eq_+3A_is">IS</code></td>
<td>
<p>if <code>TRUE</code>, importance sampling is used for ynew</p>
</td></tr>
<tr><td><code id="crit_SUR_Eq_+3A_plot">plot</code></td>
<td>
<p>if <code>TRUE</code>, draws equilibria samples (should always be turned off)</p>
</td></tr>
<tr><td><code id="crit_SUR_Eq_+3A_kweights">kweights</code></td>
<td>
<p>kriging weights for <code>CKS</code> (TESTING)</p>
</td></tr>
<tr><td><code id="crit_SUR_Eq_+3A_nadir">Nadir</code>, <code id="crit_SUR_Eq_+3A_shadow">Shadow</code></td>
<td>
<p>optional vectors of size <code>nobj</code>. Replaces the nadir or shadow point for <code>KSE</code>. If only a subset of values needs to be defined, 
the other coordinates can be set to <code>Inf</code> (resp. -<code>Inf</code> for the shadow).</p>
</td></tr>
<tr><td><code id="crit_SUR_Eq_+3A_calibcontrol">calibcontrol</code></td>
<td>
<p>an optional list for calibration problems, containing <code>target</code> a vector of target values for the objectives, 
<code>log</code> a Boolean stating if a log transformation should be used or not aand , and <code>offset</code> a (small) scalar so that each objective is log(offset + (y-T^2)).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Criterion value.
</p>


<h3>References</h3>

<p>V. Picheny, M. Binois, A. Habbal (2016+), A Bayesian optimization approach to find Nash equilibria,
<em>https://arxiv.org/abs/1611.02440</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crit_PNash">crit_PNash</a></code> for an alternative infill criterion
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##############################################
# 2 variables, 2 players
##############################################
library(DiceKriging)
set.seed(42)

# Objective function (R^2 -&gt; R^2)
fun &lt;- function (x)
{
  if (is.null(dim(x)))    x &lt;- matrix(x, nrow = 1)
 b1 &lt;- 15 * x[, 1] - 5
 b2 &lt;- 15 * x[, 2]
 return(cbind((b2 - 5.1*(b1/(2*pi))^2 + 5/pi*b1 - 6)^2 + 10*((1 - 1/(8*pi)) * cos(b1) + 1),
               -sqrt((10.5 - b1)*(b1 + 5.5)*(b2 + 0.5)) - 1/30*(b2 - 5.1*(b1/(2*pi))^2 - 6)^2-
                1/3 * ((1 - 1/(8 * pi)) * cos(b1) + 1)))
}

# Grid definition
n.s &lt;- rep(14, 2)
x.to.obj   &lt;- c(1,2)
gridtype &lt;- 'cartesian'
integcontrol &lt;- generate_integ_pts(n.s=n.s, d=4, nobj=2, x.to.obj = x.to.obj, gridtype=gridtype)
integ.pts &lt;- integcontrol$integ.pts
expanded.indices &lt;- integcontrol$expanded.indices

# Kriging models
n.init &lt;- 11
design &lt;- integ.pts[sample.int(n=nrow(integ.pts), size=n.init, replace=FALSE),]
response &lt;- t(apply(design, 1, fun))
mf1 &lt;- km(~., design = design, response = response[,1], lower=c(.1,.1))
mf2 &lt;- km(~., design = design, response = response[,2], lower=c(.1,.1))
model &lt;- list(mf1, mf2)

# Conditional simulations
Simu &lt;- t(Reduce(rbind, lapply(model, simulate, nsim=10, newdata=integ.pts, cond=TRUE,
                                   checkNames=FALSE, nugget.sim = 10^-8)))

# Useful precalculations with the package KrigInv can be reused for computational speed.
# library(KrigInv)
# precalc.data &lt;- lapply(model, FUN=KrigInv:::precomputeUpdateData, integration.points=integ.pts)

# Compute criterion for all points on the grid
crit_grid &lt;- lapply(X=1:prod(n.s), FUN=crit_SUR_Eq, model=model,
                    integcontrol=integcontrol, equilibrium = "NE",
                    # precalc.data=precalc.data, # Uncomment if precalc.data is computed
                    Simu=Simu, n.ynew=10, IS=FALSE, cross=FALSE)
crit_grid &lt;- unlist(crit_grid)

# Draw contour of the criterion
filled.contour(seq(0, 1, length.out = n.s[1]), seq(0, 1, length.out = n.s[2]),
               matrix(pmax(0, crit_grid), n.s[1], n.s[2]), main = "SUR criterion",
               xlab = expression(x[1]), ylab = expression(x[2]), color = terrain.colors,
               plot.axes = {axis(1); axis(2);
                            points(design[,1], design[,2], pch = 21, bg = "white")
                           }
)


</code></pre>

<hr>
<h2 id='filter_for_Game'>All-purpose filter</h2><span id='topic+filter_for_Game'></span>

<h3>Description</h3>

<p>Select candidate points for conditional simulations or for criterion evaluation, based on a &quot;window&quot; or a probability related to the equilibrium at hand.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_for_Game(
  n.s.target,
  model = NULL,
  predictions = NULL,
  type = "window",
  equilibrium = "NE",
  integcontrol,
  options = NULL,
  ncores = 1,
  random = TRUE,
  include.obs = FALSE,
  min.crit = 1e-12,
  nsamp = NULL,
  Nadir = NULL,
  Shadow = NULL,
  target = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_for_Game_+3A_n.s.target">n.s.target</code></td>
<td>
<p>scalar or vector of number of strategies (one value per player) to select. For <code>NE</code>, if <code>n.s.target</code> is a scalar
then each player will have <code>round(n.s.target^(1/nobj)</code> strategies.</p>
</td></tr>
<tr><td><code id="filter_for_Game_+3A_model">model</code></td>
<td>
<p>is a list of <code>nobj</code> <code>nobj</code> <code><a href="DiceKriging.html#topic+km">km</a></code> objects</p>
</td></tr>
<tr><td><code id="filter_for_Game_+3A_predictions">predictions</code></td>
<td>
<p>is a list of size <code>nobj</code></p>
</td></tr>
<tr><td><code id="filter_for_Game_+3A_type">type</code></td>
<td>
<p>either &quot;<code>window</code>&quot;, &quot;<code>PND</code>&quot; or &quot;<code>Pnash</code>&quot;, see details</p>
</td></tr>
<tr><td><code id="filter_for_Game_+3A_equilibrium">equilibrium</code></td>
<td>
<p>either '<code>NE</code>', '<code>KSE</code>' or '<code>NKSE</code>' for Nash/Kalai-Smoridinsky/Nash-Kalai-Smoridinsky equilibria</p>
</td></tr>
<tr><td><code id="filter_for_Game_+3A_integcontrol">integcontrol</code></td>
<td>
<p>is a list containing: <code>integ.pts</code>, a [<code>npts x dim</code>] matrix defining the grid,
<code>expanded.indices</code> a matrix containing the indices of the integ.pts on the grid and <code>n.s</code>,
a <code>nobj</code> vector containting the number of strategies per player</p>
</td></tr>
<tr><td><code id="filter_for_Game_+3A_options">options</code></td>
<td>
<p>a list containing either the window (matrix or target) or the parameters for Pnash: method
(&quot;<code>simu</code>&quot; or &quot;<code>exact</code>&quot;) and <code>nsim</code></p>
</td></tr>
<tr><td><code id="filter_for_Game_+3A_ncores">ncores</code></td>
<td>
<p><code><a href="parallel.html#topic+mclapply">mclapply</a></code> is used if <code>&gt; 1</code> for parallel evaluation</p>
</td></tr>
<tr><td><code id="filter_for_Game_+3A_random">random</code></td>
<td>
<p>Boolean. If <code>FALSE</code>, the best points according to the filter criterion are chosen,
otherwise the points are chosen by random sampling with weights proportional to the criterion.</p>
</td></tr>
<tr><td><code id="filter_for_Game_+3A_include.obs">include.obs</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, the observations are included to the filtered set.</p>
</td></tr>
<tr><td><code id="filter_for_Game_+3A_min.crit">min.crit</code></td>
<td>
<p>Minimal value for the criterion, useful if <code>random = TRUE</code>.</p>
</td></tr>
<tr><td><code id="filter_for_Game_+3A_nsamp">nsamp</code></td>
<td>
<p>number of samples to estimate the probability of non-domination, useful when <code>type=PND</code> and <code>nobj</code>&gt;3.</p>
</td></tr>
<tr><td><code id="filter_for_Game_+3A_nadir">Nadir</code>, <code id="filter_for_Game_+3A_shadow">Shadow</code></td>
<td>
<p>optional vectors of size <code>nobj</code>. Replaces the nadir or shadow point for <code>KSE</code>. If only a subset of values needs to be defined, 
the other coordinates can be set to <code>Inf</code> (resp. -<code>Inf</code>).</p>
</td></tr>
<tr><td><code id="filter_for_Game_+3A_target">target</code></td>
<td>
<p>a vector of target values for the objectives to use the calibration mode</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>type == "windows"</code>, points are ranked based on their distance to <code>option$window</code> (when it is a target vector),
or based on the probability that the response belongs to <code>option$window</code>.
The other options, &quot;<code>PND</code>&quot; (probability of non-domination, i.e., of not being dominated by the current Pareto front)
and &quot;<code>Pnash</code>&quot; (probability of realizing a Nash equilibrium) base the ranking of points on the associated probability.
</p>


<h3>Value</h3>

<p>List with two elements: <code>I</code> indices selected and <code>crit</code> the filter metric at all candidate points
</p>

<hr>
<h2 id='generate_integ_pts'>Strategy generation</h2><span id='topic+generate_integ_pts'></span>

<h3>Description</h3>

<p>Preprocessing to link strategies and designs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_integ_pts(
  n.s,
  d,
  nobj,
  x.to.obj = NULL,
  gridtype = "cartesian",
  equilibrium = "NE",
  lb = rep(0, d),
  ub = rep(1, d),
  include.obs = FALSE,
  model = NULL,
  init_set = NULL,
  include_set = NULL,
  seed = 42
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_integ_pts_+3A_n.s">n.s</code></td>
<td>
<p>scalar or vector. If scalar, total number of strategies (to be divided equally among players),
otherwise number of strategies per player.</p>
</td></tr>
<tr><td><code id="generate_integ_pts_+3A_d">d</code></td>
<td>
<p>number of variables</p>
</td></tr>
<tr><td><code id="generate_integ_pts_+3A_nobj">nobj</code></td>
<td>
<p>number of objectives (or players)</p>
</td></tr>
<tr><td><code id="generate_integ_pts_+3A_x.to.obj">x.to.obj</code></td>
<td>
<p>vector allocating variables to objectives. If not provided, default is <code>1:nobj</code>, assuming that <code>d=nobj</code></p>
</td></tr>
<tr><td><code id="generate_integ_pts_+3A_gridtype">gridtype</code></td>
<td>
<p>either &quot;<code>cartesian</code>&quot; or &quot;<code>lhs</code>&quot;, or a vector to define a different type for each player.</p>
</td></tr>
<tr><td><code id="generate_integ_pts_+3A_equilibrium">equilibrium</code></td>
<td>
<p>either &quot;<code>NE</code>&quot;, &quot;<code>KSE</code>&quot;, &quot;<code>CKSE</code>&quot; or &quot;<code>NKSE</code>&quot;</p>
</td></tr>
<tr><td><code id="generate_integ_pts_+3A_lb">lb</code>, <code id="generate_integ_pts_+3A_ub">ub</code></td>
<td>
<p>vectors specifying the bounds of the design space, by default <code>[0,1]^d</code></p>
</td></tr>
<tr><td><code id="generate_integ_pts_+3A_include.obs">include.obs</code></td>
<td>
<p>Boolean, if TRUE observations given in <code>model@X</code> are added to the integration points (only for <code>KSE</code> and <code>CKSE</code>)</p>
</td></tr>
<tr><td><code id="generate_integ_pts_+3A_model">model</code></td>
<td>
<p>optional list of <code>km</code> models (used if <code>include.obs=TRUE</code>)</p>
</td></tr>
<tr><td><code id="generate_integ_pts_+3A_init_set">init_set</code></td>
<td>
<p>large grid to subsample from</p>
</td></tr>
<tr><td><code id="generate_integ_pts_+3A_include_set">include_set</code></td>
<td>
<p>grid to be included in the larger one generated</p>
</td></tr>
<tr><td><code id="generate_integ_pts_+3A_seed">seed</code></td>
<td>
<p>random seed used by <code><a href="DiceDesign.html#topic+lhsDesign">lhsDesign</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing two matrices, <code>integ.pts</code> the design of experiments and <code>expanded.indices</code>
the corresponding indices (for <code>NE</code>), and the vector <code>n.s</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##############################################
### 4 variables, 2 players, no filter
##############################################

# Create a 11x8 lattice based on 2 LHS designs
n.s &lt;- c(11,8)
gridtype = "lhs"
# 4D space is split in 2
x.to.obj &lt;- c(1,1,2,2)
integcontrol &lt;- generate_integ_pts(n.s=n.s, d=4, nobj=2, x.to.obj = x.to.obj, gridtype=gridtype)
pairs(integcontrol$integ.pts)

# Create a simple 11x11 grid
integcontrol &lt;- generate_integ_pts(n.s=11^2, d=2, nobj=2, gridtype="cartesian")
pairs(integcontrol$integ.pts)

</code></pre>

<hr>
<h2 id='getEquilibrium'>Equilibrium computation of a discrete game for a given matrix with objectives values</h2><span id='topic+getEquilibrium'></span>

<h3>Description</h3>

<p>Computes the equilibrium of three types of games, given a matrix of objectives (or a set of matrices) and the structure of the strategy space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getEquilibrium(
  Z,
  equilibrium = c("NE", "NKSE", "KSE", "CKSE"),
  nobj = 2,
  n.s,
  expanded.indices = NULL,
  return.design = FALSE,
  sorted = FALSE,
  cross = FALSE,
  kweights = NULL,
  Nadir = NULL,
  Shadow = NULL,
  calibcontrol = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getEquilibrium_+3A_z">Z</code></td>
<td>
<p>is a matrix of size [<code>npts x nsim*nobj</code>] of objective values, see details,</p>
</td></tr>
<tr><td><code id="getEquilibrium_+3A_equilibrium">equilibrium</code></td>
<td>
<p>considered type, one of <code>"NE"</code>, <code>"NKSE"</code>, <code>"KSE"</code>, <code>"CKSE"</code></p>
</td></tr>
<tr><td><code id="getEquilibrium_+3A_nobj">nobj</code></td>
<td>
<p>nb of objectives (or players)</p>
</td></tr>
<tr><td><code id="getEquilibrium_+3A_n.s">n.s</code></td>
<td>
<p>scalar of vector. If scalar, total number of strategies (to be divided equally among players),
otherwise number of strategies per player.</p>
</td></tr>
<tr><td><code id="getEquilibrium_+3A_expanded.indices">expanded.indices</code></td>
<td>
<p>is a matrix containing the indices of the <code>integ.pts</code> on the grid, see <code><a href="#topic+generate_integ_pts">generate_integ_pts</a></code></p>
</td></tr>
<tr><td><code id="getEquilibrium_+3A_return.design">return.design</code></td>
<td>
<p>Boolean; if <code>TRUE</code>, the index of the optimal strategy is returned (otherwise only the pay-off is returned)</p>
</td></tr>
<tr><td><code id="getEquilibrium_+3A_sorted">sorted</code></td>
<td>
<p>Boolean; if <code>TRUE</code>, the last column of expanded.indices is assumed to be sorted in increasing order. This provides a substantial efficiency gain.</p>
</td></tr>
<tr><td><code id="getEquilibrium_+3A_cross">cross</code></td>
<td>
<p>Should the simulation be crossed? (For &quot;NE&quot; only - may be dropped in future versions)</p>
</td></tr>
<tr><td><code id="getEquilibrium_+3A_kweights">kweights</code></td>
<td>
<p>kriging weights for <code>CKS</code> (TESTING)</p>
</td></tr>
<tr><td><code id="getEquilibrium_+3A_nadir">Nadir</code>, <code id="getEquilibrium_+3A_shadow">Shadow</code></td>
<td>
<p>optional vectors of size <code>nobj</code>. Replaces the nadir and/or shadow point for <code>KSE</code>. Some coordinates can be set to <code>Inf</code> (resp. -<code>Inf</code>).</p>
</td></tr>
<tr><td><code id="getEquilibrium_+3A_calibcontrol">calibcontrol</code></td>
<td>
<p>an optional list for calibration problems, containing <code>target</code> a vector of target values for the objectives, 
<code>log</code> a Boolean stating if a log transformation should be used or not and 
<code>offset</code> a (small) scalar so that each objective is log(offset + (y-T^2)).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>nsim=1</code>, each line of <code>Z</code> contains the pay-offs of the different players for a given strategy s: [obj1(s), obj2(s), ...].
The position of the strategy <code>s</code> in the grid is given by the corresponding line of <code>expanded.indices</code>. If <code>nsim&gt;1</code>, (vectorized call) <code>Z</code> contains
different trajectories for each pay-off: each line is [obj1_1(x), obj1_2(x), ... obj2_1(x), obj2_2(x), ...].
</p>


<h3>Value</h3>

<p>A list with elements:
</p>

<ul>
<li> <p><code>NEPoff</code> vector of pay-offs at the equilibrium or matrix of pay-offs at the equilibria;
</p>
</li>
<li> <p><code>NE</code> the corresponding design(s), if <code>return.design</code> is <code>TRUE</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
## Setup
fun &lt;- function (x)
{
  if (is.null(dim(x)))    x &lt;- matrix(x, nrow = 1)
  b1 &lt;- 15 * x[, 1] - 5
  b2 &lt;- 15 * x[, 2]
  return(cbind((b2 - 5.1*(b1/(2*pi))^2 + 5/pi*b1 - 6)^2 + 10*((1 - 1/(8*pi)) * cos(b1) + 1),
               -sqrt((10.5 - b1)*(b1 + 5.5)*(b2 + 0.5)) - 1/30*(b2 - 5.1*(b1/(2*pi))^2 - 6)^2-
                1/3 * ((1 - 1/(8 * pi)) * cos(b1) + 1)))
}

d &lt;- nobj &lt;- 2

# Generate grid of strategies for Nash and Nash-Kalai-Smorodinsky
n.s &lt;- c(11,11) # number of strategies per player
x.to.obj &lt;- 1:2 # allocate objectives to players
integcontrol &lt;- generate_integ_pts(n.s=n.s,d=d,nobj=nobj,x.to.obj=x.to.obj,gridtype="cartesian")
integ.pts &lt;- integcontrol$integ.pts
expanded.indices &lt;- integcontrol$expanded.indices

# Compute the pay-off on the grid
response.grid &lt;- t(apply(integ.pts, 1, fun))

# Compute the Nash equilibrium (NE)
trueEq &lt;- getEquilibrium(Z = response.grid, equilibrium = "NE", nobj = nobj, n.s = n.s,
                         return.design = TRUE, expanded.indices = expanded.indices,
                         sorted = !is.unsorted(expanded.indices[,2]))

# Pay-off at equilibrium
print(trueEq$NEPoff)

# Optimal strategy
print(integ.pts[trueEq$NE,])

# Index of the optimal strategy in the grid
print(expanded.indices[trueEq$NE,])

# Plots
oldpar &lt;- par(mfrow = c(1,2))
plotGameGrid(fun = fun, n.grid = n.s, x.to.obj = x.to.obj, integcontrol=integcontrol,
             equilibrium = "NE")

# Compute KS equilibrium (KSE)
trueKSEq &lt;- getEquilibrium(Z = response.grid, equilibrium = "KSE", nobj = nobj,
                         return.design = TRUE, sorted = !is.unsorted(expanded.indices[,2]))

# Pay-off at equilibrium
print(trueKSEq$NEPoff)

# Optimal strategy
print(integ.pts[trueKSEq$NE,])

plotGameGrid(fun = fun, n.grid = n.s, integcontrol=integcontrol,
             equilibrium = "KSE", fun.grid = response.grid)

# Compute the Nash equilibrium (NE)
trueNKSEq &lt;- getEquilibrium(Z = response.grid, equilibrium = "NKSE", nobj = nobj, n.s = n.s,
                         return.design = TRUE, expanded.indices = expanded.indices,
                         sorted = !is.unsorted(expanded.indices[,2]))

# Pay-off at equilibrium
print(trueNKSEq$NEPoff)

# Optimal strategy
print(integ.pts[trueNKSEq$NE,])

# Index of the optimal strategy in the grid
print(expanded.indices[trueNKSEq$NE,])

# Plots
plotGameGrid(fun = fun, n.grid = n.s, x.to.obj = x.to.obj, integcontrol=integcontrol,
             equilibrium = "NKSE")
par(oldpar)

</code></pre>

<hr>
<h2 id='GPGame'>Package GPGame</h2><span id='topic+GPGame'></span>

<h3>Description</h3>

<p>Sequential strategies for finding game equilibria in a black-box setting (expensive pay-off evaluations, no derivatives).
Handles noiseless or noisy evaluations. Two acquisition functions are available. Graphical outputs can be generated automatically.
</p>


<h3>Details</h3>

<p>Important functions: <br />
<code><a href="#topic+solve_game">solve_game</a></code> <br />
<code><a href="#topic+plotGame">plotGame</a></code> <br />
</p>


<h3>Author(s)</h3>

<p>Victor Picheny, Mickael Binois
</p>


<h3>References</h3>

<p>V. Picheny, M. Binois, A. Habbal (2016+), A Bayesian Optimization approach to find Nash equilibria,
<em>https://arxiv.org/abs/1611.02440</em>.
</p>
<p>M. Binois, V. Picheny, A. Habbal, &quot;The Kalai-Smorodinski solution for many-objective Bayesian optimization&quot;, 
NIPS BayesOpt workshop, December 2017, Long Beach, USA,
<em>https://bayesopt.github.io/papers/2017/28.pdf</em>.
</p>


<h3>See Also</h3>

<p><code><a href="DiceKriging.html#topic+DiceKriging-package">DiceKriging-package</a></code>, <code><a href="DiceOptim.html#topic+DiceOptim-package">DiceOptim-package</a></code>, <code><a href="KrigInv.html#topic+KrigInv-package">KrigInv-package</a></code>, <code><a href="GPareto.html#topic+GPareto-package">GPareto-package</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# To use parallel computation (turn off on Windows)
library(parallel)
parallel &lt;- FALSE # TRUE # 
if(parallel) ncores &lt;- detectCores() else ncores &lt;- 1

##############################################
# 2 variables, 2 players, Nash equilibrium
# Player 1 (P1) wants to minimize fun1 and player 2 (P2) fun2
# P1 chooses x2 and P2 x2

##############################################
# First, define objective function fun: (x1,x2) -&gt; (fun1,fun2)
fun &lt;- function (x)
{
  if (is.null(dim(x)))    x &lt;- matrix(x, nrow = 1)
  b1 &lt;- 15 * x[, 1] - 5
  b2 &lt;- 15 * x[, 2]
  return(cbind((b2 - 5.1*(b1/(2*pi))^2 + 5/pi*b1 - 6)^2 + 10*((1 - 1/(8*pi)) * cos(b1) + 1),
               -sqrt((10.5 - b1)*(b1 + 5.5)*(b2 + 0.5)) - 1/30*(b2 - 5.1*(b1/(2*pi))^2 - 6)^2-
                1/3 * ((1 - 1/(8 * pi)) * cos(b1) + 1)))
}

##############################################
# x.to.obj indicates that P1 chooses x1 and P2 chooses x2
x.to.obj   &lt;- c(1,2)

##############################################
# Define a discretization of the problem: each player can choose between 21 strategies
# The ensemble of combined strategies is a 21x21 cartesian grid

# n.s is the number of strategies (vector)
n.s &lt;- rep(21, 2)
# gridtype is the type of discretization
gridtype &lt;- 'cartesian'

integcontrol &lt;- list(n.s=n.s, gridtype=gridtype)

##############################################
# Run solver with 6 initial points, 14 iterations
n.init &lt;- 6 # number of initial points (space-filling)
n.ite &lt;- 14 # number of iterations (sequential infill points)

res &lt;- solve_game(fun, equilibrium = "NE", crit = "sur", n.init=n.init, n.ite=n.ite,
                  d = 2, nobj=2, x.to.obj = x.to.obj, integcontrol=integcontrol,
                  ncores = ncores, trace=1, seed=1)

##############################################
# Get estimated equilibrium and corresponding pay-off
NE &lt;- res$Eq.design
Poff &lt;- res$Eq.poff

##############################################
# Draw results
plotGame(res)

##############################################
# See solve_game for other examples
##############################################

</code></pre>

<hr>
<h2 id='nonDom'>Generic non-domination computation</h2><span id='topic+nonDom'></span>

<h3>Description</h3>

<p>Extract non-dominated points from a set, or with respect to a reference Pareto front
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nonDom(points, ref = NULL, return.idx = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nonDom_+3A_points">points</code></td>
<td>
<p>matrix (one point per row) from which to extract non-dominated points, or,
if a reference <code>ref</code> is provided, non-dominated points with respect to  <code>ref</code></p>
</td></tr>
<tr><td><code id="nonDom_+3A_ref">ref</code></td>
<td>
<p>matrix (one point per row) of reference (faster if they are already Pareto optimal)</p>
</td></tr>
<tr><td><code id="nonDom_+3A_return.idx">return.idx</code></td>
<td>
<p>if <code>TRUE</code>, return indices instead of points</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use Kung non-domination sorting
</p>


<h3>Value</h3>

<p>Non-dominated points from <code>points</code>, unless a <code>ref</code> is provided, in which case return points from <code>points</code> non-dominated by <code>ref</code>.
If <code>return.idx</code> is <code>TRUE</code>, only returns indices
</p>


<h3>References</h3>

<p>Kung, H. T., Luccio, F., &amp; Preparata, F. P. (1975). On finding the maxima of a set of vectors. Journal of the ACM (JACM), 22(4), 469-476.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- 6
n &lt;- 1000
n2 &lt;- 1000

test &lt;- matrix(runif(d * n), n)
ref &lt;- matrix(runif(d * n), n)
indPF &lt;- nonDom(ref, return.idx = TRUE)
all(nonDom(ref) == ref[indPF,])

system.time(res &lt;- nonDom(test, ref[indPF,,drop = FALSE], return.idx = TRUE))
</code></pre>

<hr>
<h2 id='plotGame'>Plot equilibrium search result (2-objectives only)</h2><span id='topic+plotGame'></span>

<h3>Description</h3>

<p>Plot equilibrium search result (2-objectives only)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotGame(
  res,
  equilibrium = "NE",
  add = FALSE,
  UQ_eq = TRUE,
  simus = NULL,
  integcontrol = NULL,
  simucontrol = NULL,
  Nadir = NULL,
  Shadow = NULL,
  ncores = 1,
  calibcontrol = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotGame_+3A_res">res</code></td>
<td>
<p>list returned by <code><a href="#topic+solve_game">solve_game</a></code></p>
</td></tr>
<tr><td><code id="plotGame_+3A_equilibrium">equilibrium</code></td>
<td>
<p>either &quot;<code>NE</code>&quot; for Nash, &quot;<code>KSE</code>&quot; for Kalai-Smoridinsky and &quot;<code>NKSE</code>&quot; for Nash-Kalai-Smoridinsky</p>
</td></tr>
<tr><td><code id="plotGame_+3A_add">add</code></td>
<td>
<p>logical; if <code>TRUE</code> adds the first graphical output to an already existing plot; if <code>FALSE</code>, (default) starts a new plot</p>
</td></tr>
<tr><td><code id="plotGame_+3A_uq_eq">UQ_eq</code></td>
<td>
<p>logical; should simulations of the equilibrium be displayed?</p>
</td></tr>
<tr><td><code id="plotGame_+3A_simus">simus</code></td>
<td>
<p>optional matrix of conditional simulation if <code>UQ_Eq</code> is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="plotGame_+3A_integcontrol">integcontrol</code></td>
<td>
<p>list with <code>n.s</code> element (maybe n.s should be returned by solve_game). See <code><a href="#topic+solve_game">solve_game</a></code>.</p>
</td></tr>
<tr><td><code id="plotGame_+3A_simucontrol">simucontrol</code></td>
<td>
<p>optional list for handling conditional simulations. See <code><a href="#topic+solve_game">solve_game</a></code>.</p>
</td></tr>
<tr><td><code id="plotGame_+3A_nadir">Nadir</code>, <code id="plotGame_+3A_shadow">Shadow</code></td>
<td>
<p>optional vectors of size <code>nobj</code>. Replaces the nadir point for <code>KSE</code>. If only a subset of values needs to be defined, 
the other coordinates can be set to <code>Inf</code> (resp. <code>-Inf</code>).</p>
</td></tr>
<tr><td><code id="plotGame_+3A_ncores">ncores</code></td>
<td>
<p>number of CPU available (&gt; 1 makes mean parallel <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="plotGame_+3A_calibcontrol">calibcontrol</code></td>
<td>
<p>an optional list for calibration problems, containing <code>target</code> a vector of target values for the objectives and 
<code>log</code> a Boolean stating if a log transformation should be used or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value returned, called for visualization.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(GPareto)
library(parallel)

# Turn off on Windows
parallel &lt;- FALSE # TRUE
ncores &lt;- 1
if(parallel) ncores &lt;- detectCores()
cov.reestim &lt;- TRUE
n.sim &lt;- 20
n.ynew &lt;- 20
IS &lt;- TRUE
set.seed(1)

pb &lt;- "P1" # 'P1' 'PDE' 'Diff'
fun &lt;- P1

equilibrium = "NE"

d &lt;- 2
nobj &lt;- 2
n.init &lt;- 20
n.ite &lt;- 4
model.trend &lt;- ~1
n.s &lt;- rep(31, 2) #31
x.to.obj   &lt;- c(1,2)
gridtype &lt;- 'cartesian'
nsimPoints &lt;- 800
ncandPoints &lt;- 200
sur_window_filter &lt;- NULL
sur_pnash_filter  &lt;- NULL
Pnash_only_filter &lt;- NULL
res &lt;- solve_game(fun, equilibrium = equilibrium, crit = "sur", model = NULL, n.init=n.init,
  n.ite = n.ite, nobj=nobj, x.to.obj = x.to.obj, integcontrol=list(n.s=n.s, gridtype=gridtype),
  simucontrol=list(n.ynew=n.ynew, n.sim=n.sim, IS=IS), ncores = ncores, d = d,
  filtercontrol=list(filter=sur_window_filter, nsimPoints=nsimPoints, ncandPoints=ncandPoints),
  kmcontrol=list(model.trend=model.trend), trace=3,
  seed=1)
plotGame(res, equilibrium = equilibrium)

dom &lt;- matrix(c(0,0,1,1),2)
plotGameGrid("P1", graphs = "objective", domain = dom, n.grid = 51, equilibrium = equilibrium)
plotGame(res, equilibrium = equilibrium, add = TRUE)



</code></pre>

<hr>
<h2 id='plotGameGrid'>Visualisation of equilibrium solution in input/output space</h2><span id='topic+plotGameGrid'></span>

<h3>Description</h3>

<p>Plot equilibrium for 2 objectives test problems with evaluations on a grid. The number of variables is not limited.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotGameGrid(
  fun = NULL,
  domain = NULL,
  n.grid,
  graphs = c("both", "design", "objective"),
  x.to.obj = NULL,
  integcontrol = NULL,
  equilibrium = c("NE", "KSE", "CKSE", "NKSE"),
  fun.grid = NULL,
  Nadir = NULL,
  Shadow = NULL,
  calibcontrol = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotGameGrid_+3A_fun">fun</code></td>
<td>
<p>name of the function considered</p>
</td></tr>
<tr><td><code id="plotGameGrid_+3A_domain">domain</code></td>
<td>
<p>optional matrix for the bounds of the domain (for now [0,1]^d only), (two columns matrix with min and max)</p>
</td></tr>
<tr><td><code id="plotGameGrid_+3A_n.grid">n.grid</code></td>
<td>
<p>number of divisions of the grid in each dimension (must correspond to <code>n.s</code> for Nash equilibriums)</p>
</td></tr>
<tr><td><code id="plotGameGrid_+3A_graphs">graphs</code></td>
<td>
<p>either <code>"design"</code>, <code>"objective"</code> or <code>"both"</code> (default) for which graph to display</p>
</td></tr>
<tr><td><code id="plotGameGrid_+3A_x.to.obj">x.to.obj</code>, <code id="plotGameGrid_+3A_integcontrol">integcontrol</code></td>
<td>
<p>see <code><a href="#topic+solve_game">solve_game</a></code> (for Nash equilibrium only)</p>
</td></tr>
<tr><td><code id="plotGameGrid_+3A_equilibrium">equilibrium</code></td>
<td>
<p>either &quot;<code>NE</code>&quot; for Nash, &quot;<code>KSE</code>&quot; for Kalai-Smoridinsky and &quot;<code>NKSE</code>&quot; for Nash-Kalai-Smoridinsky</p>
</td></tr>
<tr><td><code id="plotGameGrid_+3A_fun.grid">fun.grid</code></td>
<td>
<p>optional matrix containing the values of <code>fun</code> at <code>integ.pts</code>. Computed if not provided.</p>
</td></tr>
<tr><td><code id="plotGameGrid_+3A_nadir">Nadir</code>, <code id="plotGameGrid_+3A_shadow">Shadow</code></td>
<td>
<p>optional vectors of size <code>nobj</code>. Replaces the nadir point for <code>KSE</code>. If only a subset of values needs to be defined, 
the other coordinates can be set to <code>Inf</code> (resp. <code>-Inf</code>.</p>
</td></tr>
<tr><td><code id="plotGameGrid_+3A_calibcontrol">calibcontrol</code></td>
<td>
<p>an optional list for calibration problems, containing <code>target</code> a vector of target values for the objectives, 
<code>log</code> a Boolean stating if a log transformation should be used or not and 
<code>offset</code> a (small) scalar so that each objective is log(offset + (y-T^2)).</p>
</td></tr>
<tr><td><code id="plotGameGrid_+3A_...">...</code></td>
<td>
<p>further arguments to <code>fun</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>list returned by invisible() with elements:
</p>

<ul>
<li> <p><code>trueEqdesign</code> design corresponding to equilibrium value <code>trueEq</code>
</p>
</li>
<li> <p><code>trueEqPoff</code> corresponding values of the objective
</p>
</li>
<li> <p><code>trueParetoFront</code> Pareto front
</p>
</li>
<li> <p><code>response.grid</code>
</p>
</li>
<li> <p><code>integ.pts, expanded.indices</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
library(GPareto)

## 2 variables
dom &lt;- matrix(c(0,0,1,1),2)

plotGameGrid("P1", domain = dom, n.grid = 51, equilibrium = "NE")
plotGameGrid("P1", domain = dom, n.grid = rep(31,2), equilibrium = "NE") ## As in the tests
plotGameGrid("P1", domain = dom, n.grid = 51, equilibrium = "KSE")
plotGameGrid("P1", domain = dom, n.grid = rep(31,2), equilibrium = "NKSE")
plotGameGrid("P1", graphs = "design", domain = dom, n.grid = rep(31,2), equilibrium = "NKSE")

## 4 variables
dom &lt;- matrix(rep(c(0,1), each = 4), 4)
plotGameGrid("ZDT3", domain = dom, n.grid = 25, equilibrium = "NE", x.to.obj = c(1,1,2,2))



</code></pre>

<hr>
<h2 id='restart_sg'>Restart existing run</h2><span id='topic+restart_sg'></span>

<h3>Description</h3>

<p>Wrapper around <code><a href="#topic+solve_game">solve_game</a></code> to add iterations to an existing run
</p>


<h3>Usage</h3>

<pre><code class='language-R'>restart_sg(
  results,
  fun,
  ...,
  equilibrium = "NE",
  crit = "sur",
  n.ite,
  x.to.obj = NULL,
  noise.var = NULL,
  Nadir = NULL,
  Shadow = NULL,
  integcontrol = NULL,
  simucontrol = NULL,
  filtercontrol = NULL,
  kmcontrol = NULL,
  returncontrol = NULL,
  ncores = 1,
  trace = 1,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="restart_sg_+3A_results">results</code></td>
<td>
<p>output of <code><a href="#topic+solve_game">solve_game</a></code> that is to be continued</p>
</td></tr>
<tr><td><code id="restart_sg_+3A_fun">fun</code></td>
<td>
<p>fonction with vectorial output</p>
</td></tr>
<tr><td><code id="restart_sg_+3A_...">...</code></td>
<td>
<p>additional parameter to be passed to fun</p>
</td></tr>
<tr><td><code id="restart_sg_+3A_equilibrium">equilibrium</code></td>
<td>
<p>either '<code>NE</code>', '<code>KSE</code>', '<code>CKSE</code>' or '<code>NKSE</code>' for Nash / Kalai-Smorodinsky / Copula-Kalai-Smorodinsky / Nash-Kalai-Smorodinsky equilibria</p>
</td></tr>
<tr><td><code id="restart_sg_+3A_crit">crit</code></td>
<td>
<p>'<code>sur</code>' (default) is available for all equilibria, '<code>psim</code>' and '<code>pex</code>' are available for Nash</p>
</td></tr>
<tr><td><code id="restart_sg_+3A_n.ite">n.ite</code></td>
<td>
<p>number of additional iterations of sequential optimization</p>
</td></tr>
<tr><td><code id="restart_sg_+3A_x.to.obj">x.to.obj</code></td>
<td>
<p>for NE and NKSE, which variables for which objective</p>
</td></tr>
<tr><td><code id="restart_sg_+3A_noise.var">noise.var</code></td>
<td>
<p>noise variance. Either a scalar (same noise for all objectives), a vector (constant noise, different for each objective), a function (type closure) with vectorial output (variable noise, different for each objective) or &quot;given_by_fn&quot;, see Details. If not provided, noise.var is taken as the average of model@noise.var.</p>
</td></tr>
<tr><td><code id="restart_sg_+3A_nadir">Nadir</code>, <code id="restart_sg_+3A_shadow">Shadow</code></td>
<td>
<p>optional vectors of size nobj. Replaces the nadir or shadow point for KSE. If only a subset of values needs to be defined, the other coordinates can be set to Inf (resp. -Inf for the shadow).</p>
</td></tr>
<tr><td><code id="restart_sg_+3A_integcontrol">integcontrol</code></td>
<td>
<p>optional list for handling integration points. See Details.</p>
</td></tr>
<tr><td><code id="restart_sg_+3A_simucontrol">simucontrol</code>, <code id="restart_sg_+3A_filtercontrol">filtercontrol</code>, <code id="restart_sg_+3A_kmcontrol">kmcontrol</code>, <code id="restart_sg_+3A_returncontrol">returncontrol</code></td>
<td>
<p>see <code><a href="#topic+solve_game">solve_game</a></code></p>
</td></tr>
<tr><td><code id="restart_sg_+3A_ncores">ncores</code></td>
<td>
<p>number of CPU available (&gt; 1 makes mean parallel TRUE)</p>
</td></tr>
<tr><td><code id="restart_sg_+3A_trace">trace</code></td>
<td>
<p>controls the level of printing: 0 (no printing), 1 (minimal printing), 3 (detailed printing)</p>
</td></tr>
<tr><td><code id="restart_sg_+3A_seed">seed</code></td>
<td>
<p>to fix the random variable generator</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unless given new values, restart_sg reuses values stored in results (e.g., <code>integcontrol</code>).
</p>


<h3>Value</h3>

<p>See <code><a href="#topic+solve_game">solve_game</a></code>.
</p>


<h3>Note</h3>

<p>For beta testing, this function could evolve.
</p>

<hr>
<h2 id='solve_game'>Main solver</h2><span id='topic+solve_game'></span>

<h3>Description</h3>

<p>Main function to solve games.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solve_game(
  fun,
  ...,
  equilibrium = "NE",
  crit = "sur",
  model = NULL,
  n.init = NULL,
  n.ite,
  d,
  nobj,
  x.to.obj = NULL,
  noise.var = NULL,
  Nadir = NULL,
  Shadow = NULL,
  integcontrol = NULL,
  simucontrol = NULL,
  filtercontrol = NULL,
  kmcontrol = NULL,
  returncontrol = NULL,
  ncores = 1,
  trace = 1,
  seed = NULL,
  calibcontrol = NULL,
  freq.exploit = 1000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solve_game_+3A_fun">fun</code></td>
<td>
<p>fonction with vectorial output</p>
</td></tr>
<tr><td><code id="solve_game_+3A_...">...</code></td>
<td>
<p>additional parameter to be passed to <code>fun</code></p>
</td></tr>
<tr><td><code id="solve_game_+3A_equilibrium">equilibrium</code></td>
<td>
<p>either '<code>NE</code>', '<code>KSE</code>', '<code>CKSE</code>' or '<code>NKSE</code>' for Nash / Kalai-Smorodinsky / Copula-Kalai-Smorodinsky
/ Nash-Kalai-Smorodinsky equilibria</p>
</td></tr>
<tr><td><code id="solve_game_+3A_crit">crit</code></td>
<td>
<p>'<code>sur</code>' (default) is available for all equilibria, '<code>psim</code>' and '<code>pex</code>' are available for Nash</p>
</td></tr>
<tr><td><code id="solve_game_+3A_model">model</code></td>
<td>
<p>list of <code><a href="DiceKriging.html#topic+km">km</a></code> models</p>
</td></tr>
<tr><td><code id="solve_game_+3A_n.init">n.init</code></td>
<td>
<p>number of points of the initial design of experiments if no model is given</p>
</td></tr>
<tr><td><code id="solve_game_+3A_n.ite">n.ite</code></td>
<td>
<p>number of iterations of sequential optimization</p>
</td></tr>
<tr><td><code id="solve_game_+3A_d">d</code></td>
<td>
<p>variable dimension</p>
</td></tr>
<tr><td><code id="solve_game_+3A_nobj">nobj</code></td>
<td>
<p>number of objectives (players)</p>
</td></tr>
<tr><td><code id="solve_game_+3A_x.to.obj">x.to.obj</code></td>
<td>
<p>for <code>NE</code> and <code>NKSE</code>, which variables for which objective</p>
</td></tr>
<tr><td><code id="solve_game_+3A_noise.var">noise.var</code></td>
<td>
<p>noise variance. Either a scalar (same noise for all objectives), a vector (constant noise, different for each objective),
a function (type closure) with vectorial output (variable noise, different for each objective) or <code>"given_by_fn"</code>, see Details.
If not provided, <code>noise.var</code> is taken as the average of <code>model@noise.var</code>.</p>
</td></tr>
<tr><td><code id="solve_game_+3A_nadir">Nadir</code>, <code id="solve_game_+3A_shadow">Shadow</code></td>
<td>
<p>optional vectors of size <code>nobj</code>. Replaces the nadir or shadow point for <code>KSE</code>. If only a subset of values needs to be defined, 
the other coordinates can be set to <code>Inf</code> (resp. -<code>Inf</code> for the shadow).</p>
</td></tr>
<tr><td><code id="solve_game_+3A_integcontrol">integcontrol</code></td>
<td>
<p>optional list for handling integration points. See Details.</p>
</td></tr>
<tr><td><code id="solve_game_+3A_simucontrol">simucontrol</code></td>
<td>
<p>optional list for handling conditional simulations. See Details.</p>
</td></tr>
<tr><td><code id="solve_game_+3A_filtercontrol">filtercontrol</code></td>
<td>
<p>optional list for handling filters. See Details.</p>
</td></tr>
<tr><td><code id="solve_game_+3A_kmcontrol">kmcontrol</code></td>
<td>
<p>optional list for handling <code><a href="DiceKriging.html#topic+km">km</a></code> models. See Details.</p>
</td></tr>
<tr><td><code id="solve_game_+3A_returncontrol">returncontrol</code></td>
<td>
<p>optional list for choosing return options. See Details.</p>
</td></tr>
<tr><td><code id="solve_game_+3A_ncores">ncores</code></td>
<td>
<p>number of CPU available (&gt; 1 makes mean parallel <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="solve_game_+3A_trace">trace</code></td>
<td>
<p>controls the level of printing: <code>0</code> (no printing), <code>1</code> (minimal printing), <code>3</code> (detailed printing)</p>
</td></tr>
<tr><td><code id="solve_game_+3A_seed">seed</code></td>
<td>
<p>to fix the random variable generator</p>
</td></tr>
<tr><td><code id="solve_game_+3A_calibcontrol">calibcontrol</code></td>
<td>
<p>an optional list for calibration problems, containing <code>target</code> a vector of target values for the objectives, 
<code>log</code> a Boolean stating if a log transformation should be used or not, and <code>offset</code> a (small) scalar so that each objective is log(offset + (y-T^2)).</p>
</td></tr>
<tr><td><code id="solve_game_+3A_freq.exploit">freq.exploit</code></td>
<td>
<p>an optional integer to force exploitation (i.e. evaluation of the predicted equilibrium) every <code>freq.exploit</code> iterations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>noise.var="given_by_fn"</code>, <code>fn</code> returns a list of two vectors, the first being the objective functions and the second
the corresponding noise variances.
</p>
<p><code>integcontrol</code> controls the way the design space is discretized. One can directly provide a set of points <code>integ.pts</code> with
corresponding indices <code>expanded.indices</code> (for <code>NE</code>). Otherwise, the points are generated according to the number of strategies <code>n.s</code>.
If <code>n.s</code> is a scalar, it corresponds to the total number of strategies (to be divided equally among players),
otherwise it corresponds to the nb of strategies per player. In addition, one may choose the type of discretization with <code>gridtype</code>.
Options are '<code>lhs</code>' or '<code>cartesian</code>'. Finally, <code>lb</code> and <code>ub</code> are vectors specifying the bounds for the design variables.
By default the design space is <code>[0,1]^d</code>.
A <code>renew</code> slot is available, if <code>TRUE</code>, then <code>integ.pts</code> are changed at each iteration. Available only for <code>KSE</code> and <code>CKSE</code>.
For <code>CKSE</code>, setting the slot <code>kweights=TRUE</code> allows to increase the number of integration points, with <code>nsamp</code> 
(default to <code>1e4</code>) virtual simulation points.
</p>
<p><code>simucontrol</code> controls options on conditional GP simulations. Options are <code>IS</code>: if <code>TRUE</code>, importance sampling is used for <code>ynew</code>;
<code>n.ynew</code> number of samples of <code>Y(x_{n+1})</code> and <code>n.sim</code> number of sample path generated.
</p>
<p><code>filtercontrol</code> controls filtering options. <code>filter</code> sets how to select a subset of simulation and candidate points,
either either a single value or a vector of two to use different filters for simulation and candidate points.
Possible values are '<code>window</code>', '<code>Pnash</code>' (for <code>NE</code>), '<code>PND</code>' (probability of non domination), '<code>none</code>'.
<code>nsimPoints</code> and <code>ncandPoints</code> set the maximum number of simulation/candidate points wanted
(use with filter '<code>Pnash</code>' for now). Default values are <code>800</code> and <code>200</code>, resp.
<code>randomFilter</code> (<code>TRUE</code> by default except for filter <code>window</code>) sets whereas the filter acts randomly or deterministically.
For more than 3 objectives, <code>PND</code> is estimated by sampling; the number of samples is controled by <code>nsamp</code> (default to <code>max(20, 5 * nobj)</code>).
</p>
<p><code>kmcontrol</code> Options for handling <code>nobj</code> <code><a href="DiceKriging.html#topic+km">km</a></code> models.
<code>cov.reestim</code> (Boolean, <code>TRUE</code> by default) specifies if the kriging hyperparameters
should be re-estimated at each iteration,
</p>
<p><code>returncontrol</code> sets options for the last iterations and what is returned by the algorithm.
<code>track.Eq</code> allows to estimate the equilibrium at each iteration; options are '<code>none</code>' to do nothing,
&quot;<code>mean</code>&quot; (default) to compute the equilibrium of the prediction mean (all candidates),
&quot;<code>empirical</code>&quot; (for <code>KSE</code>) and &quot;<code>pex</code>&quot;/&quot;<code>psim</code>&quot; (<code>NE</code> only)
for using <code>Pnash</code> estimate (along with mean estimate, on integ.pts only, NOT reestimated if <code>filter.simu</code> or <code>crit</code> is <code>Pnash</code>).
The boolean <code>force.exploit.last</code> (default to <code>TRUE</code>) allows to evaluate the equilibrium on the predictive mean - if not already evaluated -
instead of using <code>crit</code> (i.e., <code>sur</code>) for <code>KSE</code> and <code>CKSE</code>.
</p>


<h3>Value</h3>

<p>A list with components:
</p>

<ul>
<li><p><code>model</code>: a list of objects of class <code><a href="DiceKriging.html#topic+km">km</a></code> corresponding to the last kriging models fitted.
</p>
</li>
<li><p><code>Jplus</code>: recorded values of the acquisition function maximizer
</p>
</li>
<li><p><code>integ.pts</code> and  <code>expanded.indices</code>: the discrete space used,
</p>
</li>
<li><p><code>predEq</code>: a list containing the recorded values of the estimated best solution,
</p>
</li>
<li><p><code>Eq.design, Eq.poff</code>: estimated equilibrium and corresponding pay-off
</p>
</li></ul>

<p>Note: with CKSE, kweights are not used when the mean on integ.pts is used. Also, CKSE does not support non-constant mean at this stage.
</p>


<h3>References</h3>

<p>V. Picheny, M. Binois, A. Habbal (2016+), A Bayesian optimization approach to find Nash equilibria,
<em>https://arxiv.org/abs/1611.02440</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

################################################################
# Example 1: Nash equilibrium, 2 variables, 2 players, no filter
################################################################
# Define objective function (R^2 -&gt; R^2)
fun1 &lt;- function (x)
{
  if (is.null(dim(x)))    x &lt;- matrix(x, nrow = 1)
  b1 &lt;- 15 * x[, 1] - 5
  b2 &lt;- 15 * x[, 2]
  return(cbind((b2 - 5.1*(b1/(2*pi))^2 + 5/pi*b1 - 6)^2 + 10*((1 - 1/(8*pi)) * cos(b1) + 1),
               -sqrt((10.5 - b1)*(b1 + 5.5)*(b2 + 0.5)) - 1/30*(b2 - 5.1*(b1/(2*pi))^2 - 6)^2-
                1/3 * ((1 - 1/(8 * pi)) * cos(b1) + 1)))
}

# To use parallel computation (turn off on Windows)
library(parallel)
parallel &lt;- FALSE #TRUE #
if(parallel) ncores &lt;- detectCores() else ncores &lt;- 1

# Simple configuration: no filter, discretization is a 21x21 grid

# Grid definition
n.s &lt;- rep(21, 2)
x.to.obj   &lt;- c(1,2)
gridtype &lt;- 'cartesian'

# Run solver with 6 initial points, 4 iterations
# Increase n.ite to at least 10 for better results
res &lt;- solve_game(fun1, equilibrium = "NE", crit = "sur", n.init=6, n.ite=4,
                  d = 2, nobj=2, x.to.obj = x.to.obj,
                  integcontrol=list(n.s=n.s, gridtype=gridtype),
                  ncores = ncores, trace=1, seed=1)

# Get estimated equilibrium and corresponding pay-off
NE &lt;- res$Eq.design
Poff &lt;- res$Eq.poff

# Draw results
plotGame(res)

################################################################
# Example 2: same example, KS equilibrium with given Nadir
################################################################
# Run solver with 6 initial points, 4 iterations
# Increase n.ite to at least 10 for better results
res &lt;- solve_game(fun1, equilibrium = "KSE", crit = "sur", n.init=6, n.ite=4,
                  d = 2, nobj=2, x.to.obj = x.to.obj,
                  integcontrol=list(n.s=400, gridtype="lhs"),
                  ncores = ncores, trace=1, seed=1, Nadir=c(Inf, -20))

# Get estimated equilibrium and corresponding pay-off
NE &lt;- res$Eq.design
Poff &lt;- res$Eq.poff

# Draw results
plotGame(res, equilibrium = "KSE", Nadir=c(Inf, -20))

################################################################
# Example 3: Nash equilibrium, 4 variables, 2 players, filtering
################################################################
fun2 &lt;- function(x, nobj = 2){
  if (is.null(dim(x)))     x &lt;- matrix(x, 1)
  y &lt;- matrix(x[, 1:(nobj - 1)], nrow(x))
  z &lt;- matrix(x[, nobj:ncol(x)], nrow(x))
  g &lt;- rowSums((z - 0.5)^2)
  tmp &lt;- t(apply(cos(y * pi/2), 1, cumprod))
  tmp &lt;- cbind(t(apply(tmp, 1, rev)), 1)
  tmp2 &lt;- cbind(1, t(apply(sin(y * pi/2), 1, rev)))
  return(tmp * tmp2 * (1 + g))
}

# Grid definition: player 1 plays x1 and x2, player 2 x3 and x4
# The grid is a lattice made of two LHS designs of different sizes
n.s &lt;- c(44, 43)
x.to.obj   &lt;- c(1,1,2,2)
gridtype &lt;- 'lhs'

# Set filtercontrol: window filter applied for integration and candidate points
# 500 simulation and 200 candidate points are retained.
filtercontrol &lt;- list(nsimPoints=500, ncandPoints=200,
                   filter=c("window", "window"))

# Set km control: lower bound is specified for the covariance range
# Covariance type and model trend are specified
kmcontrol &lt;- list(lb=rep(.2,4), model.trend=~1, covtype="matern3_2")

# Run solver with 20 initial points, 4 iterations
# Increase n.ite to at least 20 for better results
res &lt;- solve_game(fun2, equilibrium = "NE", crit = "psim", n.init=20, n.ite=2,
                  d = 4, nobj=2, x.to.obj = x.to.obj,
                  integcontrol=list(n.s=n.s, gridtype=gridtype),
                  filtercontrol=filtercontrol,
                  kmcontrol=kmcontrol,
                  ncores = 1, trace=1, seed=1)

# Get estimated equilibrium and corresponding pay-off
NE &lt;- res$Eq.design
Poff &lt;- res$Eq.poff

# Draw results
plotGame(res)

################################################################
# Example 4: same example, KS equilibrium
################################################################

# Grid definition: simple lhs
integcontrol=list(n.s=1e4, gridtype='lhs')

# Run solver with 20 initial points, 4 iterations
# Increase n.ite to at least 20 for better results
res &lt;- solve_game(fun2, equilibrium = "KSE", crit = "sur", n.init=20, n.ite=2,
                  d = 4, nobj=2,
                  integcontrol=integcontrol,
                  filtercontrol=filtercontrol,
                  kmcontrol=kmcontrol,
                  ncores = 1, trace=1, seed=1)

# Get estimated equilibrium and corresponding pay-off
NE &lt;- res$Eq.design
Poff &lt;- res$Eq.poff

# Draw results
plotGame(res, equilibrium = "KSE")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
