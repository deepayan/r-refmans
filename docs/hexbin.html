<!DOCTYPE html><html lang="en"><head><title>Help for package hexbin</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {hexbin}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ColorRamps'><p>Color Ramps on Perceptually Linear Scales</p></a></li>
<li><a href='#erode.hexbin'><p>Erosion of a Hexagon Count Image</p></a></li>
<li><a href='#getHMedian'><p>Get coordiantes of the median cell after the erode operation</p></a></li>
<li><a href='#gplot.hexbin'><p>Plotting Hexagon Cells with a Legend</p></a></li>
<li><a href='#grid.hexagons'><p>Add Hexagon Cells to Plot</p></a></li>
<li><a href='#grid.hexlegend'><p>Add a Legend to a Hexbin Plot</p></a></li>
<li><a href='#hboxplot'><p>2-D Generalization of Boxplot</p></a></li>
<li><a href='#hcell2xy'><p>Compute X and Y Coordinates for Hexagon Cells</p></a></li>
<li><a href='#hcell2xyInt'><p>Change cell ids to 2d integer coordinate system</p></a></li>
<li><a href='#hdiffplot'><p>Plot of Domain and Median Differences of Two &quot;hexbin&quot; Objects</p></a></li>
<li><a href='#hexbin'><p>Bivariate Binning into Hexagon Cells</p></a></li>
<li><a href='#hexbinplot'><p>Trellis Hexbin Displays</p></a></li>
<li><a href='#hexGraphPaper'><p>Create a Hexgon Grid</p></a></li>
<li><a href='#hexList'><p>Conditional Bivariate Binning into Hexagon Cells</p></a></li>
<li><a href='#hexMA.loess'><p>Add Loess Fit to Hexplot</p></a></li>
<li><a href='#hexplom'><p>Hexbin Plot Matrices</p></a></li>
<li><a href='#hexpolygon'><p>Hexagon Coordinates and Polygon Drawing</p></a></li>
<li><a href='#hexTapply'><p>Apply function to data from each hexagon bin.</p></a></li>
<li><a href='#hexViewport'><p>Compute a Grid Viewport for Hexagon / Hexbin Graphics</p></a></li>
<li><a href='#hexVP-class'><p>Formal class &quot;hexVP&quot; of a Hexagon Viewport</p></a></li>
<li><a href='#hexVP.abline'><p>Add a Straight Line to a HexPlot</p></a></li>
<li><a href='#hsmooth-methods'><p>Hexagon Bin Smoothing: Generic hsmooth() and Methods</p></a></li>
<li><a href='#inout.hex'><p>Check points for inclusion</p></a></li>
<li><a href='#list2hexList'><p>Convert list to hexList</p></a></li>
<li><a href='#NHANES'><p>NHANES Data : National Health and Nutrition Examination Survey</p></a></li>
<li><a href='#old-classes'><p>Class &quot;unit&quot; and &quot;viewport&quot; as S4 classes</p></a></li>
<li><a href='#optShape'><p>Optimal Shape Parameter for Hexbin Viewport</p></a></li>
<li><a href='#panel.hexboxplot'><p>Boxplot for hexbin lattice plot</p></a></li>
<li><a href='#panel.hexgrid'><p>Hexagonal grid for a lattice plot</p></a></li>
<li><a href='#panel.hexloess'><p>Loess line for hexbin lattice plot</p></a></li>
<li><a href='#plotMAhex'><p>MA-plot using hexagon bins</p></a></li>
<li><a href='#pushHexport'><p>Push a Hexagon Viewport (&quot;hexVP&quot;)</p></a></li>
<li><a href='#smooth.hexbin'><p>Hexagon Bin Smoothing</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.28.5</td>
</tr>
<tr>
<td>Title:</td>
<td>Hexagonal Binning Routines</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.0.1), methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>lattice, grid, graphics, grDevices, stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>marray, affy, Biobase, limma, knitr</td>
</tr>
<tr>
<td>Description:</td>
<td>Binning and plotting functions for hexagonal bins.</td>
</tr>
<tr>
<td>Collate:</td>
<td>lattice.R BTC.R BTY.R grid.hexagons.R grid.hexlegend.R hbox.R
hdiffplot.R hexbinList.R hexbinplot.R hexbin.s4.R hexpanel.R
hexplom.R hexPlotMA.R hexutil.R hexViewport.R HO.R LINGRAY.R
LOCS.R MAG.R RB.R smoothHexbin.R</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/edzer/hexbin">https://github.com/edzer/hexbin</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-11-13 17:43:55 UTC; edzer</td>
</tr>
<tr>
<td>Author:</td>
<td>Dan Carr [aut],
  Nicholas Lewin-Koh [aut],
  Martin Maechler [aut],
  Deepayan Sarkar [aut],
  Edzer Pebesma <a href="https://orcid.org/0000-0001-8049-7069"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Edzer Pebesma &lt;edzer.pebesma@uni-muenster.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-11-13 19:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ColorRamps'>Color Ramps on Perceptually Linear Scales</h2><span id='topic+ColorRamps'></span><span id='topic+LinGray'></span><span id='topic+BTC'></span><span id='topic+BTY'></span><span id='topic+LinOCS'></span><span id='topic+heat.ob'></span><span id='topic+magent'></span><span id='topic+plinrain'></span>

<h3>Description</h3>

<p>Functions for returning colors on perceptually linear scales,
where steps correspond to &lsquo;just detectable differences&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LinGray (n, beg=1, end=92)
BTC     (n, beg=1, end=256)
LinOCS  (n, beg=1, end=256)
heat.ob (n, beg=1, end=256)
magent  (n, beg=1, end=256)
plinrain(n, beg=1, end=256)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ColorRamps_+3A_n">n</code></td>
<td>
<p>number of colors to return from the ramp</p>
</td></tr>
<tr><td><code id="ColorRamps_+3A_beg">beg</code></td>
<td>
<p>begining of ramp, integer from 1-255</p>
</td></tr>
<tr><td><code id="ColorRamps_+3A_end">end</code></td>
<td>
<p>end of ramp, integer from 1-255</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Several precalulated color ramps, that are on a perceptually linear
color scale.  A perceptually linear color scale is a scale where each
jump corresponds to a &ldquo;just detectable difference&rdquo; in color and the
scale is percieved as linear by the human eye (emprically determined).
</p>
<p>When using the ramps, if <code>beg</code> is less than <code>end</code> the ramp
will be reversed.
</p>


<h3>Value</h3>

<p>returns an array of colors
</p>


<h3>Author(s)</h3>

<p>Nicholas Lewin-Koh</p>


<h3>References</h3>

<p>Haim Levkowitz (1997)
<em>Color Theory and Modeling for Computer Graphics,
Visualization, and Multimedia Applications</em>.
Kluwer Academic Publishers, Boston/London/Dordrecht.
</p>


<h3>See Also</h3>

<p><code><a href="grDevices.html#topic+palettes">rainbow</a></code>,
<code><a href="grDevices.html#topic+palettes">terrain.colors</a></code>,
<code><a href="grDevices.html#topic+rgb">rgb</a></code>,  
<code><a href="grDevices.html#topic+hsv">hsv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>h &lt;- hexbin(rnorm(10000),rnorm(10000))
plot(h, colramp= BTY)
## looks better if you shave the tails:
plot(h, colramp= function(n){LinOCS(n,beg=15,end=225)})
</code></pre>

<hr>
<h2 id='erode.hexbin'>Erosion of a Hexagon Count Image</h2><span id='topic+erode'></span><span id='topic+erode.hexbin'></span><span id='topic+erode+2Chexbin-method'></span><span id='topic+erodebin-class'></span>

<h3>Description</h3>

<p>This erosion algorithm removes counts from hexagon cells at a rate
proportional to the cells' exposed surface area.  When a cell becomes
empty,  algorithm removes the emptied cell and notes the removal
order.  Cell removal increases the exposure of any neighboring cells.
The last cell removed is a type of bivariate median.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>erode(hbin, cdfcut = 0.5)
erode.hexbin(hbin, cdfcut = 0.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="erode.hexbin_+3A_hbin">hbin</code></td>
<td>
<p>an object of class <code><a href="#topic+hexbin">hexbin</a></code>.</p>
</td></tr>
<tr><td><code id="erode.hexbin_+3A_cdfcut">cdfcut</code></td>
<td>
<p>number in (0,1) indicating the confidence level for the
limits.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm extracts  high count cells with containing a given
fraction (cdfcut) of the total counts.  The algorithm extracts all
cells if cdfcut=0.  The algorithm performs gray-level erosion on the
extracted cells.  Each erosion cycle removes counts from cells.  The
counts removed for each cell are a multiple of the cell's exposed-face
count.  The algorithm choses the multiple so at least one cell will be
empty or have a count deficit on each erosion cycle.  The erode vector
contain an erosion number for each cell.   The value of  erode is
</p>
<p>6*erosion_cycle_at_cell_removal - cell_deficit_at_removal
</p>
<p>Cells with low values are eroded first.   The cell with the highest
erosion number is a candidate bivariate median.  A few ties in erode
are common.
</p>


<h3>Value</h3>

<p>An <code>"erodebin"</code> object (with all the slots from <code>hbin</code>) and
additionally with
high count cells and a component  <code>erode</code> that gives the erosion order.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hexbin">hexbin</a></code>, <code><a href="#topic+smooth.hexbin">smooth.hexbin</a></code>,
<code><a href="#topic+hcell2xy">hcell2xy</a></code>, 


<code><a href="#topic+gplot.hexbin">gplot.hexbin</a></code>,
<code><a href="#topic+grid.hexagons">grid.hexagons</a></code>, <code><a href="#topic+grid.hexlegend">grid.hexlegend</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(153)
x &lt;- rnorm(10000)
y &lt;- rnorm(10000)
bin &lt;- hexbin(x,y)

smbin  &lt;- smooth.hexbin(bin)
erodebin &lt;- erode.hexbin(smbin, cdfcut=.5)
plot(erodebin)

## bivariate boxplot
hboxplot(erodebin, main = "hboxplot(erodebin)")


# show erosion order
plot(bin,style= "lat", minarea=1, maxarea=1,
     legend=FALSE, border=gray(.7))

grid.hexagons(erodebin,style= "lat", minarea=1, maxarea=1,pen="green")
xy &lt;- hcell2xy(erodebin)
library("grid")
grid.text(lab = as.character(erodebin@erode), xy$x, xy$y,
          gp = gpar(col="white", cex=0.65))

</code></pre>

<hr>
<h2 id='getHMedian'>Get coordiantes of the median cell after the erode operation</h2><span id='topic+getHMedian'></span><span id='topic+getHMedian+2Cerodebin-method'></span>

<h3>Description</h3>

<p>A method for a eroded hexbin object to extract the coordinates of the
median cell.  The median is simply the cell with the highest erosion
number or the last cell to be eroded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getHMedian(ebin)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getHMedian_+3A_ebin">ebin</code></td>
<td>
<p>result of <code><a href="#topic+erode.hexbin">erode.hexbin</a>()</code>.</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>ebin = &quot;erodebin&quot;</dt><dd><p>...</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+erode.hexbin">erode.hexbin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(153)
x &lt;- rnorm(10000)
y &lt;- rnorm(10000)
bin &lt;- hexbin(x,y)

smbin  &lt;- smooth.hexbin(bin)
erodebin &lt;- erode.hexbin(smbin, cdfcut=.5)
getHMedian(erodebin)
</code></pre>

<hr>
<h2 id='gplot.hexbin'>Plotting Hexagon Cells with a Legend</h2><span id='topic+gplot.hexbin'></span><span id='topic+plot+2Chexbin+2Cmissing-method'></span>

<h3>Description</h3>

<p>Plots Hexagons visualizing the counts in an hexbin object.  Different
styles are availables.  Provides a legend indicating the count
representations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gplot.hexbin(x, style = "colorscale", legend = 1.2, lcex = 1,
      minarea = 0.04, maxarea = 0.8, mincnt = 1, maxcnt = max(x@count),
      trans = NULL, inv = NULL, colorcut = seq(0, 1, length = min(17, maxcnt)),
      border = NULL, density = NULL, pen = NULL,
      colramp = function(n) LinGray(n,beg = 90,end = 15),
      xlab = "", ylab = "", main = "", newpage = TRUE,
      type = c("p", "l", "n"), xaxt = c("s", "n"), yaxt = c("s", "n"),
      clip = "on", verbose = getOption("verbose"))
## S4 method for signature 'hexbin,missing'
plot(x, style = "colorscale", legend = 1.2, lcex = 1,
      minarea = 0.04, maxarea = 0.8, mincnt = 1, maxcnt = max(x@count),
      trans = NULL, inv = NULL, colorcut = seq(0, 1, length = min(17, maxcnt)),
      border = NULL, density = NULL, pen = NULL,
      colramp = function(n) LinGray(n,beg = 90,end = 15),
      xlab = "", ylab = "", main = "", newpage = TRUE,
      type = c("p", "l", "n"), xaxt = c("s", "n"), yaxt = c("s", "n"),
      clip = "on", verbose = getOption("verbose"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gplot.hexbin_+3A_x">x</code></td>
<td>
<p>an object of class <code><a href="#topic+hexbin">hexbin</a></code>.</p>
</td></tr>
<tr><td><code id="gplot.hexbin_+3A_style">style</code></td>
<td>
<p>string specifying the style of hexagon plot,
see <code><a href="#topic+grid.hexagons">grid.hexagons</a></code> for the possibilities.</p>
</td></tr>
<tr><td><code id="gplot.hexbin_+3A_legend">legend</code></td>
<td>
<p>numeric width of the legend in inches of <code>FALSE</code>.
In the latter case, or when <code>0</code>, no legend is not produced.</p>
</td></tr>
<tr><td><code id="gplot.hexbin_+3A_lcex">lcex</code></td>
<td>
<p>characters  expansion size for the text in the legend</p>
</td></tr>
<tr><td><code id="gplot.hexbin_+3A_minarea">minarea</code></td>
<td>
<p>fraction of cell area for the lowest count</p>
</td></tr>
<tr><td><code id="gplot.hexbin_+3A_maxarea">maxarea</code></td>
<td>
<p>fraction of the cell area for the largest count</p>
</td></tr>
<tr><td><code id="gplot.hexbin_+3A_mincnt">mincnt</code></td>
<td>
<p>cells with fewer counts are ignored.</p>
</td></tr>
<tr><td><code id="gplot.hexbin_+3A_maxcnt">maxcnt</code></td>
<td>
<p>cells with more counts are ignored.</p>
</td></tr>
<tr><td><code id="gplot.hexbin_+3A_trans">trans</code></td>
<td>
<p><code><a href="base.html#topic+function">function</a></code> specifying a transformation for
the counts such as <code>sqrt</code>.</p>
</td></tr>
<tr><td><code id="gplot.hexbin_+3A_inv">inv</code></td>
<td>
<p>the inverse transformation of <code>trans</code>.</p>
</td></tr>
<tr><td><code id="gplot.hexbin_+3A_colorcut">colorcut</code></td>
<td>
<p>vector of values covering [0, 1] that determine
hexagon color class boundaries and hexagon legend size boundaries.
Alternatively, an integer (<code>&lt;= maxcnt</code>) specifying the
<em>number</em> of equispaced colorcut values in [0,1].</p>
</td></tr>
<tr><td><code id="gplot.hexbin_+3A_border">border</code>, <code id="gplot.hexbin_+3A_density">density</code>, <code id="gplot.hexbin_+3A_pen">pen</code></td>
<td>
<p>color for polygon borders and filling of
each hexagon drawn, passed to <code><a href="#topic+grid.hexagons">grid.hexagons</a></code>.</p>
</td></tr>
<tr><td><code id="gplot.hexbin_+3A_colramp">colramp</code></td>
<td>
<p>function accepting an integer <code>n</code> as an argument and
returning n colors.</p>
</td></tr>
<tr><td><code id="gplot.hexbin_+3A_xlab">xlab</code>, <code id="gplot.hexbin_+3A_ylab">ylab</code></td>
<td>
<p>x- and y-axis label.</p>
</td></tr>
<tr><td><code id="gplot.hexbin_+3A_main">main</code></td>
<td>
<p>main title.</p>
</td></tr>
<tr><td><code id="gplot.hexbin_+3A_newpage">newpage</code></td>
<td>
<p>should a new page start?.</p>
</td></tr>
<tr><td><code id="gplot.hexbin_+3A_type">type</code>, <code id="gplot.hexbin_+3A_xaxt">xaxt</code>, <code id="gplot.hexbin_+3A_yaxt">yaxt</code></td>
<td>
<p>strings to be used (when set to <code>"n"</code>) for
suppressing the plotting of hexagon symbols, or the x- or y-axis,
respectively.</p>
</td></tr>
<tr><td><code id="gplot.hexbin_+3A_clip">clip</code></td>
<td>
<p>either 'on' or 'off' are the allowed arguments, when on
everything is clipped to the plotting region.</p>
</td></tr>
<tr><td><code id="gplot.hexbin_+3A_verbose">verbose</code></td>
<td>
<p>logical indicating if some diagnostic output should happen.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the (S4) <code><a href="base.html#topic+plot">plot</a></code> method for <code><a href="#topic+hexbin">hexbin</a></code> (and
<code>erodebin</code>) objects (<a href="#topic+erodebin-class">erodebin-class</a>).
</p>
<p>To use the standalone function
<code>gplot.hexbin()</code> is <b><em>deprecated</em></b>.
For <code>style</code>, <code>minarea</code> etc, see the <b>Details</b> section of
<code><a href="#topic+grid.hexagons">grid.hexagons</a></code>'s help page.
</p>
<p>The legend functionality is somewhat preliminary.  Later versions may
include refinements and handle extreme cases (small and large) for
cell size and counts.
</p>
<p>All arguments of <code>gplot.hexbin</code> can also be used for the S4 
<code><a href="base.html#topic+plot">plot</a></code> method.
</p>


<h3>Value</h3>

<p>invisibly, a list with components
</p>
<table role = "presentation">
<tr><td><code>plot.vp</code></td>
<td>
<p>the <code><a href="#topic+hexViewport">hexViewport</a></code> constructed and used.</p>
</td></tr>
<tr><td><code>legend.vp</code></td>
<td>
<p>if a legend has been produced, its
<code><a href="grid.html#topic+viewport">viewport</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dan Carr <a href="mailto:dcarr@voxel.galaxy.gmu.edu">dcarr@voxel.galaxy.gmu.edu</a>,
ported by Nicholas Lewin-Koh <a href="mailto:kohnicho@comp.nus.edu.sg">kohnicho@comp.nus.edu.sg</a> and
Martin Maechler.
</p>


<h3>References</h3>

<p> see in <code><a href="#topic+grid.hexagons">grid.hexagons</a></code>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+hexbin">hexbin</a></code>, <code><a href="#topic+hexViewport">hexViewport</a></code>,
<code><a href="#topic+smooth.hexbin">smooth.hexbin</a></code>,
<code><a href="#topic+erode.hexbin">erode.hexbin</a></code>,
<code><a href="#topic+hcell2xy">hcell2xy</a></code>, <code><a href="#topic+hboxplot">hboxplot</a></code>,
<code><a href="#topic+hdiffplot">hdiffplot</a></code>.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 1) simple binning of spherical normal:
x &lt;- rnorm(10000)
y &lt;- rnorm(10000)
bin &lt;- hexbin(x,y)

## Plot method for hexbin !
## ---- ------     --------
plot(bin)
# nested lattice
plot(bin, style= "nested.lattice")

# controlling the colorscheme
plot(bin, colramp=BTY, colorcut=c(0,.1,.2,.3,.4,.6,1))

## 2) A mixture distribution
x &lt;- c(rnorm(5000),rnorm(5000,4,1.5))
y &lt;- c(rnorm(5000),rnorm(5000,2,3))
bin &lt;- hexbin(x,y)

pens &lt;- cbind(c("#ECE2F0","#A6BDDB","#1C9099"),
              c("#FFF7BC","#FEC44F","#D95F0E"))
plot(bin, style = "nested.lattice", pen=pens)
# now really crazy
plot(bin, style = "nested.lattice", pen=pens,border=2,density=35)

# lower resolution binning and overplotting with counts
bin &lt;- hexbin(x,y,xbins=25)
P &lt;- plot(bin, style="lattice", legend=FALSE,
          minarea=1, maxarea=1, border="white")
##
library("grid")
pushHexport(P$plot.vp)
xy &lt;- hcell2xy(bin)
  # to show points rather than counts :
grid.points(x,y,pch=18,gp=gpar(cex=.3,col="green"))
grid.text(as.character(bin@count), xy$x,xy$y,
          gp=gpar(cex=0.3, col="red"),default.units="native")
popViewport()

# Be creative, have fun!
</code></pre>

<hr>
<h2 id='grid.hexagons'>Add Hexagon Cells to Plot</h2><span id='topic+grid.hexagons'></span>

<h3>Description</h3>

<p>Plots cells in an hexbin object.  The function distinquishes among
counts using 5 different styles.  This function is the hexagon
plotting engine from the <code>plot</code> method for <code><a href="#topic+hexbin">hexbin</a></code>
objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.hexagons(dat, style = c("colorscale", "centroids", "lattice",
	      "nested.lattice", "nested.centroids", "constant.col"),
         use.count=TRUE, cell.at=NULL,
	 minarea = 0.05, maxarea = 0.8, check.erosion = TRUE,
	 mincnt = 1, maxcnt = max(dat@count), trans = NULL,
	 colorcut = seq(0, 1, length = 17),
	 density = NULL, border = NULL, pen = NULL,
	 colramp = function(n){ LinGray(n,beg = 90, end = 15) },
	 def.unit=  "native",
	 verbose = getOption("verbose"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grid.hexagons_+3A_dat">dat</code></td>
<td>
<p>an object of class <code>hexbin</code>, see <code><a href="#topic+hexbin">hexbin</a></code>.</p>
</td></tr>
<tr><td><code id="grid.hexagons_+3A_style">style</code></td>
<td>
<p>character string specifying the type of plotting; must be (a
unique abbrevation) of the values given in &lsquo;Usage&rsquo; above.</p>
</td></tr>
<tr><td><code id="grid.hexagons_+3A_use.count">use.count</code></td>
<td>
<p>logical specifying if counts should be used.</p>
</td></tr>
<tr><td><code id="grid.hexagons_+3A_cell.at">cell.at</code></td>
<td>
<p>numeric vector to be plotted instead of counts, must
besame length as the number of cells.</p>
</td></tr>
<tr><td><code id="grid.hexagons_+3A_minarea">minarea</code></td>
<td>
<p>numeric, the fraction of cell area for the lowest count.</p>
</td></tr>
<tr><td><code id="grid.hexagons_+3A_maxarea">maxarea</code></td>
<td>
<p>the fraction of the cell area for the largest count.</p>
</td></tr>
<tr><td><code id="grid.hexagons_+3A_check.erosion">check.erosion</code></td>
<td>
<p>logical indicating only eroded points should be
used for <code>"erodebin"</code> objects; simply passed to
<code><a href="#topic+hcell2xy">hcell2xy</a></code>, see its documentation.</p>
</td></tr>
<tr><td><code id="grid.hexagons_+3A_mincnt">mincnt</code></td>
<td>
<p>numeric; cells with counts smaller than <code>mincnt</code>
are not shown.</p>
</td></tr>
<tr><td><code id="grid.hexagons_+3A_maxcnt">maxcnt</code></td>
<td>
<p>cells with counts larger than this are not shown.</p>
</td></tr>
<tr><td><code id="grid.hexagons_+3A_trans">trans</code></td>
<td>
<p>a transformation function (or <code>NULL</code>) for the counts,
e.g., <code><a href="base.html#topic+sqrt">sqrt</a></code>.</p>
</td></tr>
<tr><td><code id="grid.hexagons_+3A_colorcut">colorcut</code></td>
<td>
<p>a vector of values covering [0, 1] which determine
hexagon color class boundaries or hexagon size boundaries &ndash; for
<code>style = "colorscale"</code> only.</p>
</td></tr>
<tr><td><code id="grid.hexagons_+3A_density">density</code></td>
<td>
<p><code><a href="grid.html#topic+grid.polygon">grid.polygon</a></code> argument for shading.  0 causes
the polygon not to be filled. <em>This is not implemented (for
<code><a href="grid.html#topic+grid.polygon">grid.polygon</a></code>) yet</em>.</p>
</td></tr>
<tr><td><code id="grid.hexagons_+3A_border">border</code></td>
<td>
<p><code><a href="grid.html#topic+grid.polygon">grid.polygon</a>()</code> argument.  Draw the border for
each hexagon.</p>
</td></tr>
<tr><td><code id="grid.hexagons_+3A_pen">pen</code></td>
<td>
<p>colors for <code><a href="grid.html#topic+grid.polygon">grid.polygon</a>()</code>.  Determines the color
with which the polygon will be filled.</p>
</td></tr>
<tr><td><code id="grid.hexagons_+3A_colramp">colramp</code></td>
<td>
<p>function of an integer argument <code>n</code> returning n
colors. <code>n</code> is determined </p>
</td></tr>
<tr><td><code id="grid.hexagons_+3A_def.unit">def.unit</code></td>
<td>
<p>default <code><a href="grid.html#topic+unit">unit</a></code> to be used.</p>
</td></tr>
<tr><td><code id="grid.hexagons_+3A_verbose">verbose</code></td>
<td>
<p>logical indicating if some diagnostic output should happen.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The six plotting styles have the following effect:
</p>

<dl>
<dt><code>style="lattice"</code> or <code>"centroids"</code>:</dt><dd>
<p>Plots the hexagons in different sizes based on counts.  The
<code>"lattice"</code> version centers the hexagons at the cell centers
whereas <code>"centroids"</code> moves the hexagon centers close to the
center of mass for the cells.  In all cases the hexagons will not
plot outside the cell unless <code>maxarea &gt; 1</code>.  Counts are rescaled
into the interval [0,1] and colorcuts determine the class
boundaries for sizes and counts. The pen argument for this style
should be a single color or a vector of colors of
<code>length(bin@count)</code>.</p>
</dd>
<dt><code>style="colorscale"</code>:</dt><dd>
<p>Counts are rescaled into the interval [0,1] and colorcuts determines
the class boundaries for the color classes.  For this style, the
function passed as <code>colramp</code> is used to define the n colors for
the n+1 color cuts. The pen argument is ignored.

See <code><a href="#topic+LinGray">LinGray</a></code> for the default <code>colramp</code> and
alternative &ldquo;color ramp&rdquo; functions.
</p>
</dd>
<dt><code>style="constant.col"</code>:</dt><dd>
<p>This is an even simpler alternative to <code>"colorscale"</code>,
using constant colors (determined <code>pen</code> optionally).
</p>
</dd>
<dt><code>style="nested.lattice"</code> and <code>"nested.centroids"</code>:</dt><dd>
<p>Counts are partitioned into classes by power of 10.  The encoding
nests hexagon size within powers of 10 color contours.
</p>
<p>If the pen argument is used it should be a matrix of colors with 2
columns and either <code>ceiling(log10(max(bin@count)))</code> or
<code>length(bin@count)</code> rows.  The default uses the <span class="rlang"><b>R</b></span> color palatte
so that pens numbers 2-11 determine colors for completely filled
cell Pen 2 is the color for 1's, Pen 3 is the color for 10's, etc.
Pens numbers 12-21 determine the color of the foreground hexagons. The
hexagon size shows the relative count for the power of 10. Different
color schemes give different effects including 3-D illusions






</p>
</dd>
</dl>

<p><em>Hexagon size encoding <code>minarea</code> and <code>maxarea</code></em>
determine the area of the smallest and largest hexagons
plotted.  Both are expressed fractions of the bin cell size.  Typical
values might be .04 and 1.  When both values are 1, all plotted
hexagons are bin cell size, if <code>maxarea</code> is greater than 1 than
hexagons will overlap. This is sometimes interesting with the lattice
and centroid styles.
</p>
<p><em>Count scaling</em>
</p>
<p><code>relcnt &lt;- (trans(cnt)-trans(mincnt)) / (trans(maxcnt)-trans(mincnt))</code>
<br />
<code>area &lt;- minarea + relcnt*maxarea</code>
</p>
<p>By default the transformation <code>trans()</code> is the identity
function.  The legend routine requires the transformation inverse
for some options.
</p>
<p><em>Count windowing <code>mincnt</code> and <code>maxcnt</code></em>
Only routine only plots cells with cnts in [mincnts,   maxcnts]
</p>


<h3>SIDE EFFECTS</h3>

<p>Adds hexagons to the plot.</p>


<h3>Author(s)</h3>

<p>Dan Carr &lt;dcarr@voxel.galaxy.gmu.edu&gt;;
ported and extended by Nicholas Lewin-Koh <a href="mailto:nikko@hailmail.net">nikko@hailmail.net</a>.
</p>


<h3>References</h3>

<p>Carr, D. B. (1991)
Looking at Large Data Sets Using Binned Data Plots,
pp. 7&ndash;39 in <em>Computing and Graphics in Statistics</em>;
Eds. A. Buja and P. Tukey, Springer-Verlag, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hexbin">hexbin</a></code>, <code><a href="#topic+smooth.hexbin">smooth.hexbin</a></code>,
<code><a href="#topic+erode.hexbin">erode.hexbin</a></code>, <code><a href="#topic+hcell2xy">hcell2xy</a></code>,
<code><a href="#topic+gplot.hexbin">gplot.hexbin</a></code>, <code><a href="#topic+hboxplot">hboxplot</a></code>, <code><a href="#topic+hdiffplot">hdiffplot</a></code>,
<code><a href="#topic+grid.hexlegend">grid.hexlegend</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(506)
x &lt;- rnorm(10000)
y &lt;- rnorm(10000)

# bin the points
bin &lt;- hexbin(x,y)

# Typical approach uses plot( &lt;hexbin&gt; ) which controls the plot shape :
plot(bin, main = "Bivariate rnorm(10000)")

## but we can have more manual control:

# A mixture distribution
x &lt;- c(rnorm(5000),rnorm(5000,4,1.5))
y &lt;- c(rnorm(5000),rnorm(5000,2,3))
hb2 &lt;- hexbin(x,y)

# Show color control and overplotting of hexagons
## 1) setup coordinate system:
P &lt;- plot(hb2, type="n", main = "Bivariate mixture (10000)")# asp=1

## 2) add hexagons (in the proper viewport):
pushHexport(P$plot.vp)
grid.hexagons(hb2, style= "lattice", border = gray(.1), pen = gray(.6),
              minarea = .1, maxarea = 1.5)
library("grid")
popViewport()

## How to treat 'singletons' specially:
P &lt;- plot(hb2, type="n", main = "Bivariate mixture (10000)")# asp=1
pushHexport(P$plot.vp)
grid.hexagons(hb2, style= "nested.centroids", mincnt = 2)# not the single ones
grid.hexagons(hb2, style= "centroids", maxcnt = 1, maxarea=0.04)# single points
popViewport()



</code></pre>

<hr>
<h2 id='grid.hexlegend'>Add a Legend to a Hexbin Plot</h2><span id='topic+grid.hexlegend'></span>

<h3>Description</h3>

<p>Plots the legend for the <code>plot</code> method of <code><a href="#topic+hexbin">hexbin</a></code>.
Provides a legend indicating the count representations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.hexlegend(legend, ysize, lcex, inner, style = ,
  	   minarea = 0.05, maxarea = 0.8, mincnt = 1, maxcnt, trans = NULL,
	   inv = NULL, colorcut, density = NULL, border = NULL, pen = NULL,
	   colramp = function(n) { LinGray(n,beg = 90,end = 15) },
           leg.unit = "native")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grid.hexlegend_+3A_legend">legend</code></td>
<td>
<p>positive number giving width of the legend in inches.</p>
</td></tr>
<tr><td><code id="grid.hexlegend_+3A_ysize">ysize</code></td>
<td>
<p>height of legend in inches</p>
</td></tr>
<tr><td><code id="grid.hexlegend_+3A_lcex">lcex</code></td>
<td>
<p>the characters expansion size for the text in the legend,
see <code><a href="graphics.html#topic+par">par</a>(cex=)</code>.</p>
</td></tr>
<tr><td><code id="grid.hexlegend_+3A_inner">inner</code></td>
<td>
<p>the inner diameter of a hexagon in inches.</p>
</td></tr>
<tr><td><code id="grid.hexlegend_+3A_style">style</code></td>
<td>
<p>the hexagon style; see <code><a href="#topic+grid.hexagons">grid.hexagons</a></code>.</p>
</td></tr>
<tr><td><code id="grid.hexlegend_+3A_minarea">minarea</code>, <code id="grid.hexlegend_+3A_maxarea">maxarea</code></td>
<td>
<p>fraction of the cell area for the lowest and largest
count, respectively.</p>
</td></tr>
<tr><td><code id="grid.hexlegend_+3A_mincnt">mincnt</code>, <code id="grid.hexlegend_+3A_maxcnt">maxcnt</code></td>
<td>
<p>minimum and maximum count accepted in <code>plot</code>.</p>
</td></tr>
<tr><td><code id="grid.hexlegend_+3A_trans">trans</code></td>
<td>
<p>a transformation function for the counts such as
<code><a href="base.html#topic+sqrt">sqrt</a></code>.</p>
</td></tr>
<tr><td><code id="grid.hexlegend_+3A_inv">inv</code></td>
<td>
<p>the inverse transformation function.</p>
</td></tr>
<tr><td><code id="grid.hexlegend_+3A_colorcut">colorcut</code></td>
<td>
<p>numeric vector of values covering [0, 1] the determine
hexagon color classes boundaries and hexagon legend size boundaries.</p>
</td></tr>
<tr><td><code id="grid.hexlegend_+3A_border">border</code></td>
<td>
<p>argument for <code><a href="graphics.html#topic+polygon">polygon</a>()</code>.  Draw the border
for each hexagon.</p>
</td></tr>
<tr><td><code id="grid.hexlegend_+3A_density">density</code></td>
<td>
<p>argument for <code><a href="graphics.html#topic+polygon">polygon</a>()</code> filling.  A
<code>0</code> causes the polygon not to be filled.</p>
</td></tr>
<tr><td><code id="grid.hexlegend_+3A_pen">pen</code></td>
<td>
<p>color argument used for <code><a href="graphics.html#topic+polygon">polygon</a>(col = .)</code>.
Determines the color with which the polygon will be filled.</p>
</td></tr>
<tr><td><code id="grid.hexlegend_+3A_colramp">colramp</code></td>
<td>
<p>function accepting an integer <code>n</code> as an argument and
returning n colors.</p>
</td></tr>
<tr><td><code id="grid.hexlegend_+3A_leg.unit">leg.unit</code></td>
<td>
<p>unit to use</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>plot</code> method for <code><a href="#topic+hexbin">hexbin</a></code> objects calls this function
to produce a legend
by setting the graphics parameters, so <code>hex.legend</code> itself is not a
standalone function.
</p>
<p>The legend function is <b>preliminary</b>.  Later version will include
refinements and handle extreme cases (small and large) for cell size
and counts.
</p>
<p>See the <b>Details</b> section of <code><a href="#topic+grid.hexagons">grid.hexagons</a></code>'s help page.
</p>


<h3>Value</h3>

<p>This function does not return any value.
</p>


<h3>Author(s)</h3>

<p>Dan Carr &lt;dcarr@voxel.galaxy.gmu.edu&gt;
</p>
<p>ported by Nicholas Lewin-Koh &lt;kohnicho@comp.nus.edu.sg&gt;
</p>


<h3>References</h3>

<p> see in <code><a href="#topic+grid.hexagons">grid.hexagons</a></code>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+hexbin">hexbin</a></code>, <code><a href="#topic+grid.hexagons">grid.hexagons</a></code>,
<code><a href="#topic+smooth.hexbin">smooth.hexbin</a></code>, <code><a href="#topic+erode.hexbin">erode.hexbin</a></code>,
<code><a href="#topic+hcell2xy">hcell2xy</a></code>,
<code><a href="#topic+gplot.hexbin">gplot.hexbin</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not a stand alone function; typically only called from plot.hexbin()
## Not run: 
  grid.hexlegend(legend = 2, ysize = 1,lcex=8,inner=0.2,
                 maxcnt = 100, colorcut = c(0.5,0.5))

## End(Not run)
</code></pre>

<hr>
<h2 id='hboxplot'>2-D Generalization of Boxplot</h2><span id='topic+hboxplot'></span>

<h3>Description</h3>

<p>If <code>bin</code> is an <em>eroded</em> <code><a href="#topic+hexbin">hexbin</a></code> object, i.e.,
an <code>erodebin</code> object, <code>hboxplot()</code> plots the high counts cells
selected by <code><a href="#topic+erode">erode</a>()</code>.  By default, the high counts
cells contain 50 percent of the counts so analagous to the
interquartile &ldquo;range&rdquo;.  The function distinguishes the last
cells eroded using color.  These cells correspond to one definition of the
bivariate median.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hboxplot(bin, xbnds = NULL, ybnds = NULL,
         density, border = c(0, grey(0.7)), pen = c(2, 3),
         unzoom = 1.1, clip ="off", reshape = FALSE,
         xlab = NULL, ylab = NULL, main = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hboxplot_+3A_bin">bin</code></td>
<td>
<p>an object of class <code><a href="#topic+hexbin">hexbin</a></code>.</p>
</td></tr>
<tr><td><code id="hboxplot_+3A_xbnds">xbnds</code>, <code id="hboxplot_+3A_ybnds">ybnds</code></td>
<td>
<p>global x- and y-axis plotting limits for multiple
plots.</p>
</td></tr>
<tr><td><code id="hboxplot_+3A_density">density</code>, <code id="hboxplot_+3A_border">border</code></td>
<td>
<p>arguments for <code><a href="graphics.html#topic+polygon">polygon</a>()</code> each of
length two, the first for the median, the second for the other cells.</p>
</td></tr>
<tr><td><code id="hboxplot_+3A_pen">pen</code></td>
<td>
<p>colors (&ldquo;pen numbers&rdquo;) for <code>polygon()</code>.</p>
</td></tr>
<tr><td><code id="hboxplot_+3A_unzoom">unzoom</code></td>
<td>
<p>plot limit expansion factor when <code>xbnds</code> is
missing.</p>
</td></tr>
<tr><td><code id="hboxplot_+3A_clip">clip</code></td>
<td>
<p>either 'on' or 'off' are the allowed arguments, when on
everything is clipped to the plotting region.</p>
</td></tr>
<tr><td><code id="hboxplot_+3A_reshape">reshape</code></td>
<td>
<p>logical value to reshape the plot although <code>xbnds</code>
and <code>ybnds</code> are present.</p>
</td></tr>
<tr><td><code id="hboxplot_+3A_xlab">xlab</code>, <code id="hboxplot_+3A_ylab">ylab</code>, <code id="hboxplot_+3A_main">main</code></td>
<td>
<p>x- and y- axis labels and main title</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>density</code>, <code>border</code>, and <code>pen</code> arguments correspond
to the <code><a href="graphics.html#topic+polygon">polygon</a></code> function calls for plotting two types of
cells.  The cell types, pen numbers and suggested colors are<br />
</p>

<table>
<tr>
 <td style="text-align: left;">
    TYPE				   </td><td style="text-align: left;"> PEN </td><td style="text-align: left;"> COLOR </td>
</tr>
<tr>
 <td style="text-align: left;">
    cells of bin                           </td><td style="text-align: left;"> 2  </td><td style="text-align: left;"> light gray </td>
</tr>
<tr>
 <td style="text-align: left;">
    last eroded cells of bin (median cells)</td><td style="text-align: left;"> 1  </td><td style="text-align: left;"> black </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p>The erode components of the hexbin objects must be present for the
medians cells to plot.
</p>
<p>When <code>xbnds</code> is missing or <code>reshape</code> is true, the plot
changes graphics parameters and resets them.   When <code>xbnds</code> is
missing the function also zooms in based on the available data to
provide increased resolution.
</p>
<p>The zoom used the hexagon cell centers.  The unzoom argument backs off
a bit so the whole hexagon will fit in the plot.
</p>
<p><code>Hboxplot()</code> is used as a stand alone function, for producing separate
legends .....

</p>


<h3>Value</h3>

<p>invisibly, the <code><a href="#topic+hexViewport">hexViewport</a>()</code> used internally.
Used to add to the plot afterwards.
</p>


<h3>References</h3>

<p> see in <code><a href="#topic+grid.hexagons">grid.hexagons</a></code>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+hexbin">hexbin</a></code>, <code><a href="#topic+erode">erode</a></code>,

<code><a href="#topic+hcell2xy">hcell2xy</a></code>,
<code><a href="#topic+gplot.hexbin">gplot.hexbin</a></code>,
<code><a href="#topic+grid.hexagons">grid.hexagons</a></code>, <code><a href="#topic+grid.hexlegend">grid.hexlegend</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##  boxplot of smoothed counts
x &lt;- rnorm(10000)
y &lt;- rnorm(10000)

bin &lt;- hexbin(x,y)
erodebin &lt;- erode(smooth.hexbin(bin))

hboxplot(erodebin)
hboxplot(erodebin, density = c(32,7), border = c(2,4))
hp &lt;- hboxplot(erodebin, density = c(-1,17),
               main = "hboxplot(erode*(smooth*(.)))")
pushHexport(hp)
library("grid")
grid.points(x[1:10], y[1:10])# just non-sense to show the principle
popViewport()
</code></pre>

<hr>
<h2 id='hcell2xy'>Compute X and Y Coordinates for Hexagon Cells</h2><span id='topic+hcell2xy'></span><span id='topic+hcell2xy+2Chexbin-method'></span>

<h3>Description</h3>

<p>Computes x and y coordinates from hexagon cell id's.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hcell2xy(hbin, check.erosion = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hcell2xy_+3A_hbin">hbin</code></td>
<td>
<p>a object of class <code>"hexbin"</code>, typically produced by
<code><a href="#topic+hexbin">hexbin</a>(*)</code>.</p>
</td></tr>
<tr><td><code id="hcell2xy_+3A_check.erosion">check.erosion</code></td>
<td>
<p>logical indicating if only the eroded points
should be returned in the case where <code>hbin</code> inherits from
<code>"erodebin"</code> (see <code><a href="#topic+erodebin-class">erodebin-class</a></code>); is <code>TRUE</code>
by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The hexbin object <code>hbin</code> contains all the needed information.
The purpose of this function is to reduce storage.  The cost is
additional calculation.
</p>


<h3>Value</h3>

<p>A list with two components of the same length as <code>bin$cell</code>,
</p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
</td></tr>
<tr><td><code>y</code></td>
<td>
</td></tr>
</table>


<h3>See Also</h3>


<p><code><a href="#topic+hexbin">hexbin</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(10000)
y &lt;- rnorm(10000)
plot(x,y, pch=".")
hbin &lt;- hexbin(x,y)
str(xys &lt;- hcell2xy(hbin))
points(xys, cex=1.5, col=2) ; title("hcell2xy( hexbin(..) )", col.main=2)


</code></pre>

<hr>
<h2 id='hcell2xyInt'>Change cell ids to 2d integer coordinate system</h2><span id='topic+hcell2xyInt'></span>

<h3>Description</h3>

<p>Transforms the cell representation of a a lattice into a 2d integer
coordinate system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  hcell2xyInt(hbin, xbins=NULL, xbnds=NULL, ybnds=NULL, shape=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hcell2xyInt_+3A_hbin">hbin</code></td>
<td>
<p>a object of class <code>"hexbin"</code>, typically produced by
<code><a href="#topic+hexbin">hexbin</a>(*)</code>.</p>
</td></tr>
<tr><td><code id="hcell2xyInt_+3A_xbins">xbins</code></td>
<td>
<p>the number of bins partitioning the range of xbnds.</p>
</td></tr>
<tr><td><code id="hcell2xyInt_+3A_xbnds">xbnds</code>, <code id="hcell2xyInt_+3A_ybnds">ybnds</code></td>
<td>
<p>horizontal and vertical limits of the binning
region in x or y units respectively; must be numeric vector of
length 2.</p>
</td></tr>
<tr><td><code id="hcell2xyInt_+3A_shape">shape</code></td>
<td>
<p>the <em>shape</em> = yheight/xwidth of the plotting regions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Takes a grid defined by either the hexbin parameters or dimen in a
hexbin object and translates the cell ids for the grid into 2d integer
coordinates. 
</p>


<h3>Value</h3>

<p>An integer matrix with two columns, i and j representing the integer
xy coordinates of the hexagon grid.
</p>
<table role = "presentation">
<tr><td><code>i</code></td>
<td>
<p>Integer coordiante of the rows, increases from bottom to top</p>
</td></tr>
<tr><td><code>j</code></td>
<td>
<p>Integer coordiante of the columns, increases from left to right</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nicholas Lewin-Koh </p>


<h3>See Also</h3>

<p><code><a href="#topic+hcell2xy">hcell2xy</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'> x&lt;-rnorm(10000)
 y&lt;-rnorm(10000)
 hbin&lt;-hexbin(x,y)
 ijInt&lt;-hcell2xyInt(hbin)
</code></pre>

<hr>
<h2 id='hdiffplot'>Plot of Domain and Median Differences of Two &quot;hexbin&quot; Objects</h2><span id='topic+hdiffplot'></span>

<h3>Description</h3>

<p>Let <code>bin1</code> and <code>bin2</code> represent two <code><a href="#topic+hexbin">hexbin</a></code>
objects with scaling, plot shapes, and bin sizes.  This plot
distinguishes cells unique to <code>bin1</code>, cells in common, and cells
unique to <code>bin2</code> using color.  When the erode components are
present, color also distinguishes the two erosion medians.  An arrow
shows the vector from the median of <code>bin1</code> to the median of
<code>bin2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hdiffplot(bin1, bin2 = NULL, xbnds, ybnds,
          focus = NULL,
          col.control = list(medhex = "white", med.bord = "black",
          focus = NULL, focus.border = NULL, back.col = "grey"),
          arrows = TRUE, size = unit(0.1, "inches"), lwd = 2,
          eps = 1e-6, unzoom = 1.08, clip="off", xlab = "", ylab = "",
          main = deparse(mycall), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hdiffplot_+3A_bin1">bin1</code>, <code id="hdiffplot_+3A_bin2">bin2</code></td>
<td>
<p>two objects of class <code><a href="#topic+hexbin">hexbin</a></code>.</p>
</td></tr>
<tr><td><code id="hdiffplot_+3A_xbnds">xbnds</code>, <code id="hdiffplot_+3A_ybnds">ybnds</code></td>
<td>
<p>global x- and y-axis plotting limits.  Used
primarily for multiple comparison plots.</p>
</td></tr>
<tr><td><code id="hdiffplot_+3A_focus">focus</code></td>
<td>
<p>a vector of integers specifying which hexbin objects
should be treated as focal. Excluded hexbins are treated as background.</p>
</td></tr>
<tr><td><code id="hdiffplot_+3A_col.control">col.control</code></td>
<td>
<p>a list for detailed color control.</p>
</td></tr>
<tr><td><code id="hdiffplot_+3A_arrows">arrows</code></td>
<td>
<p>a logical indicating wheter or not to draw arrows
between the focal hexbin objects median cells.</p>
</td></tr>
<tr><td><code id="hdiffplot_+3A_border">border</code></td>
<td>
<p>border arguments to polygon</p>
</td></tr>
<tr><td><code id="hdiffplot_+3A_size">size</code></td>
<td>
<p>arrow type size in inches.</p>
</td></tr>
<tr><td><code id="hdiffplot_+3A_eps">eps</code></td>
<td>
<p>distance criteria for distinct medians</p>
</td></tr>
<tr><td><code id="hdiffplot_+3A_unzoom">unzoom</code></td>
<td>
<p>plot limit expansion factor when xbnds is missing</p>
</td></tr>
<tr><td><code id="hdiffplot_+3A_clip">clip</code></td>
<td>
<p>either 'on' or 'off' are the allowed arguments, when on
everything is clipped to the plotting region.</p>
</td></tr>
<tr><td><code id="hdiffplot_+3A_lwd">lwd</code></td>
<td>
<p>Line width for arrows, ignored when <code>arrows=FALSE</code> or
when bins have no erosion component</p>
</td></tr>
<tr><td><code id="hdiffplot_+3A_xlab">xlab</code></td>
<td>
<p>label for x-axis</p>
</td></tr>
<tr><td><code id="hdiffplot_+3A_ylab">ylab</code></td>
<td>
<p>label for y-axis</p>
</td></tr>
<tr><td><code id="hdiffplot_+3A_main">main</code></td>
<td>
<p>main title for the plot; automatically constructed by default.</p>
</td></tr>
<tr><td><code id="hdiffplot_+3A_...">...</code></td>
<td>
<p>...............</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The hexbin objects for comparison, <code>bin1</code> and <code>bin2</code>, must
have the same plotting limits and cell size.  The plot produces a
comparison overlay of the cells in the two objects.  If external
global scaling is not supplied, the algorithm determines plotting
limits to increase resolution.  For example, the objects may be the
result of the <code><a href="#topic+erode.hexbin">erode.hexbin</a>()</code> and include only high count cells
containing 50 of the counts.  The density, border, and pen arguments
correspond to the polygon function calls for plotting six types of
cells.  The cell types are respectively:
</p>

<table>
<tr>
 <td style="text-align: left;">
    unique cells of bin1,</td>
</tr>
<tr>
 <td style="text-align: left;">
    joint cells,</td>
</tr>
<tr>
 <td style="text-align: left;">
    unique cells of bin2,</td>
</tr>
<tr>
 <td style="text-align: left;">
    median cell of bin1,</td>
</tr>
<tr>
 <td style="text-align: left;">
    median cell of bin2,</td>
</tr>
<tr>
 <td style="text-align: left;">
    median cell if identical.</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p>The <code>erode</code> components of the hexbin objects must be present for the
medians to plot.  The algorithm select a single cell for the median if
there are algorithmic ties.
</p>
<p>The <code>pen</code> numbers for types of cells start at Pen 2.  Pen 1 is
presumed black.  The suggested six additional colors are light blue,
light gray, light red, blue, red, and black.  Carr (1991) shows an
example for black and white printing.  That plot changes the six
colors to light gray, dark gray, white, black, black, and black.  It
changes the 4th, 5th, and 6th argument of border to TRUE.  It also
changes 4th, 5th and 6th argument of density to 0.  In other words
cells in common do not show and medians cells appear as outlines.
</p>
<p>When <code>xbnds</code> is missing, the plot changes graphics parameters and
resets them.  The function also zooms in based on the available data
to provide increased resolution.
</p>


<h3>References</h3>

<p> see in <code><a href="#topic+grid.hexagons">grid.hexagons</a></code>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+hexbin">hexbin</a></code>, <code><a href="#topic+smooth.hexbin">smooth.hexbin</a></code>, <code><a href="#topic+erode.hexbin">erode.hexbin</a></code>,

<code><a href="#topic+hcell2xy">hcell2xy</a></code>, 
<code><a href="#topic+gplot.hexbin">gplot.hexbin</a></code>,
<code><a href="#topic+hboxplot">hboxplot</a></code>, 
<code><a href="#topic+grid.hexagons">grid.hexagons</a></code>, <code><a href="#topic+grid.hexlegend">grid.hexlegend</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Comparison of two bivariate boxplots
x1 &lt;- rnorm(10000)
y1 &lt;- rnorm(10000)
x2 &lt;- rnorm(10000,mean=.5)
y2 &lt;- rnorm(10000,mean=.5)
xbnds &lt;- range(x1,x2)
ybnds &lt;- range(y1,y2)

bin1 &lt;- hexbin(x1,y1,xbnds=xbnds,ybnds=ybnds)
bin2 &lt;- hexbin(x2,y2,xbnds=xbnds,ybnds=ybnds)
erodebin1 &lt;- erode.hexbin(smooth.hexbin(bin1))
erodebin2 &lt;- erode.hexbin(smooth.hexbin(bin2))

hdiffplot(erodebin1,erodebin2)

## Compare  *three* of them: --------------------

x3 &lt;- rnorm(10000,mean=-1)
y3 &lt;- rnorm(10000,mean=-.5)
xbnds &lt;- range(x1,x2,x3)
ybnds &lt;- range(y1,y2,y3)

bin1 &lt;- hexbin(x1,y1,xbnds=xbnds,ybnds=ybnds)
bin2 &lt;- hexbin(x2,y2,xbnds=xbnds,ybnds=ybnds)
bin3 &lt;- hexbin(x3,y3,xbnds=xbnds,ybnds=ybnds)
erodebin1 &lt;- erode.hexbin(smooth.hexbin(bin1))
erodebin2 &lt;- erode.hexbin(smooth.hexbin(bin2))
erodebin3 &lt;- erode.hexbin(smooth.hexbin(bin3))

bnlst &lt;- list(b1=erodebin1, b2=erodebin2, b3=erodebin3)
hdiffplot(bnlst)
</code></pre>

<hr>
<h2 id='hexbin'>Bivariate Binning into Hexagon Cells</h2><span id='topic+hexbin'></span><span id='topic+hexbin-class'></span><span id='topic+integer+20or+20NULL-class'></span><span id='topic+show+2Chexbin-method'></span><span id='topic+summary+2Chexbin-method'></span>

<h3>Description</h3>

<p>Creates a <code>"hexbin"</code> object.  Basic components are a cell id and
a count of points falling in each occupied cell.
</p>
<p>Basic methods are <code><a href="methods.html#topic+show">show</a>()</code>, <code>plot()</code> 
and <code><a href="base.html#topic+summary">summary</a>()</code>, but also <code><a href="#topic+erode">erode</a></code>.

</p>


<h3>Usage</h3>

<pre><code class='language-R'>hexbin(x, y, xbins = 30, shape = 1,
       xbnds = range(x), ybnds = range(y),
       xlab = NULL, ylab = NULL, IDs = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hexbin_+3A_x">x</code>, <code id="hexbin_+3A_y">y</code></td>
<td>
<p>vectors giving the coordinates of the bivariate data
points to be binned.  Alternatively a single plotting structure can
be specified: see <code><a href="grDevices.html#topic+xy.coords">xy.coords</a></code>.  <code><a href="base.html#topic+NA">NA</a></code>'s are
allowed and silently omitted.</p>
</td></tr>
<tr><td><code id="hexbin_+3A_xbins">xbins</code></td>
<td>
<p>the number of bins partitioning the range of xbnds.</p>
</td></tr>
<tr><td><code id="hexbin_+3A_shape">shape</code></td>
<td>
<p>the <em>shape</em> = yheight/xwidth of the plotting regions.</p>
</td></tr>
<tr><td><code id="hexbin_+3A_xbnds">xbnds</code>, <code id="hexbin_+3A_ybnds">ybnds</code></td>
<td>
<p>horizontal and vertical limits of the binning
region in x or y units respectively; must be numeric vector of length 2.</p>
</td></tr>
<tr><td><code id="hexbin_+3A_xlab">xlab</code>, <code id="hexbin_+3A_ylab">ylab</code></td>
<td>
<p>optional character strings used as labels for
<code>x</code> and <code>y</code>.  If <code>NULL</code>, sensible defaults are used.</p>
</td></tr>
<tr><td><code id="hexbin_+3A_ids">IDs</code></td>
<td>
<p>logical indicating if the individual cell &ldquo;IDs&rdquo;
should be returned, see also below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns counts for non-empty cells only.  The plot shape must be maintained for
hexagons to appear with equal sides.  Some calculations are in single
precision.
</p>
<p>Note that when plotting a <code>hexbin</code> object, the
<span class="pkg">grid</span> package is used.
You must use its graphics (or those from package <span class="pkg">lattice</span> if you
know how) to add to such plots.
</p>


<h3>Value</h3>

<p>an S4 object of class <code>"hexbin"</code>.
It has the following slots:
</p>
<table role = "presentation">
<tr><td><code>cell</code></td>
<td>
<p>vector of cell ids that can be mapped into the (x,y)
bin centers in data units.</p>
</td></tr>
<tr><td><code>count</code></td>
<td>
<p>vector of counts in the cells.</p>
</td></tr>
<tr><td><code>xcm</code></td>
<td>
<p>The x center of mass (average of x values) for the cell.</p>
</td></tr>
<tr><td><code>ycm</code></td>
<td>
<p>The y center of mass (average of y values) for the cell.</p>
</td></tr>
<tr><td><code>xbins</code></td>
<td>
<p> number of hexagons across the x axis. hexagon inner
diameter =diff(xbnds)/xbins in x units</p>
</td></tr>
<tr><td><code>shape</code></td>
<td>
<p>plot shape which is yheight(inches) / xwidth(inches)</p>
</td></tr>
<tr><td><code>xbnds</code></td>
<td>
<p>x coordinate bounds for binning and plotting</p>
</td></tr>
<tr><td><code>ybnds</code></td>
<td>
<p>y coordinate bounds for binning and plotting</p>
</td></tr>
<tr><td><code>dimen</code></td>
<td>
<p>The i and j limits of cnt treated as a matrix cnt[i,j]</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>number of (non NA) (x,y) points, i.e., <code>sum(* @count)</code>.</p>
</td></tr>
<tr><td><code>ncells</code></td>
<td>
<p>number of cells, i.e., <code>length(* @count)</code>, etc</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the function call.</p>
</td></tr>
<tr><td><code>xlab</code>, <code>ylab</code></td>
<td>
<p>character strings to be used as axis labels.</p>
</td></tr>
<tr><td><code>cID</code></td>
<td>
<p>of class, <code>"integer or NULL"</code>, only if <code>IDs</code>
was true, an integer vector of length <code>n</code> where
<code>cID[i]</code> is the cell number of the i-th original point
<code>(x[i], y[i])</code>.  Consequently, the <code>cell</code> and <code>count</code>
slots are the same as the <code><a href="base.html#topic+names">names</a></code> and entries of
<code>table(cID)</code>, see the example.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Carr, D. B. et al. (1987)
Scatterplot Matrix Techniques for Large <code class="reqn">N</code>.
<em>JASA</em> <b>83</b>, 398, 424&ndash;436.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hcell2xy">hcell2xy</a></code>
<code><a href="#topic+gplot.hexbin">gplot.hexbin</a></code>,
<code><a href="#topic+grid.hexagons">grid.hexagons</a></code>, <code><a href="#topic+grid.hexlegend">grid.hexlegend</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(101)
x &lt;- rnorm(10000)
y &lt;- rnorm(10000)
(bin &lt;- hexbin(x, y))
## or
plot(hexbin(x, y + x*(x+1)/4),
     main = "(X, X(X+1)/4 + Y)  where X,Y ~ rnorm(10000)")

## Using plot method for hexbin objects:
plot(bin, style = "nested.lattice")

hbi &lt;- hexbin(y ~ x, xbins = 80, IDs= TRUE)
str(hbi)
tI &lt;- table(hbi@cID)
stopifnot(names(tI) == hbi@cell,
                tI  == hbi@count)

## NA's now work too:
x[runif(6, 0, length(x))] &lt;- NA
y[runif(7, 0, length(y))] &lt;- NA
hbN &lt;- hexbin(x,y)
summary(hbN)
</code></pre>

<hr>
<h2 id='hexbinplot'>Trellis Hexbin Displays</h2><span id='topic+hexbinplot'></span><span id='topic+hexbinplot.formula'></span><span id='topic+panel.hexbinplot'></span><span id='topic+prepanel.hexbinplot'></span><span id='topic+hexlegendGrob'></span>

<h3>Description</h3>

<p>Display of hexagonally binned data, as implemented in the
<code>hexbin</code> packge, under the Trellis framework, with associated
utilities.  <code>hexbinplot</code> is the high level generic function, with
the <code>"formula"</code> method doing the actual work.
<code>prepanel.hexbinplot</code> and <code>panel.hexbinplot</code> are associated
prepanel and panel functions.  <code>hexlegendGrob</code> produces a
suitable legend.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
hexbinplot(x, data, ...)

## S3 method for class 'formula'
hexbinplot(x, data = NULL,
           prepanel = prepanel.hexbinplot,
           panel = panel.hexbinplot,
	   groups = NULL,
           aspect = "xy",
           trans = NULL,
           inv = NULL,
           colorkey = TRUE,
           ...,
           maxcnt,
           legend = NULL,
           legend.width = TRUE,
           subset)

prepanel.hexbinplot(x, y, type = character(0), ...)

panel.hexbinplot(x, y, ..., groups = NULL)

hexlegendGrob(legend = 1.2,
              inner = legend / 5,
              cex.labels = 1,
              cex.title = 1.2,
              style = "colorscale",
              minarea = 0.05, maxarea = 0.8,
              mincnt = 1, maxcnt,
              trans = NULL, inv = NULL,
              colorcut = seq(0, 1, length = 17),
              density = NULL, border = NULL, pen = NULL,
              colramp = function(n) { LinGray(n,beg = 90,end = 15) },
              ...,
              vp = NULL,
              draw = FALSE)


</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hexbinplot_+3A_x">x</code></td>
<td>
<p> For <code>hexbinplot</code>, the object on which method dispatch
is carried out.
</p>
<p>For the <code>"formula"</code> methods, a formula describing the form of
conditioning plot.  Formulas that are valid for <code>xyplot</code> are
acceptable.
</p>
<p>In <code>panel.hexbinplot</code>, the x variable.
</p>
</td></tr>
<tr><td><code id="hexbinplot_+3A_y">y</code></td>
<td>
<p> In <code>panel.hexbinplot</code>, the y variable. </p>
</td></tr> 
<tr><td><code id="hexbinplot_+3A_data">data</code></td>
<td>
<p>For the <code>formula</code> method, a data frame containing
values for any variables in the formula, as well as <code>groups</code>
and <code>subset</code> if applicable (using <code>groups</code> currently
causes an error with the default panel function).  By default, the
environment where the function was called from is used.  </p>
</td></tr>
<tr><td><code id="hexbinplot_+3A_minarea">minarea</code>, <code id="hexbinplot_+3A_maxarea">maxarea</code>, <code id="hexbinplot_+3A_mincnt">mincnt</code>, <code id="hexbinplot_+3A_maxcnt">maxcnt</code>, <code id="hexbinplot_+3A_trans">trans</code>, <code id="hexbinplot_+3A_inv">inv</code>, <code id="hexbinplot_+3A_colorcut">colorcut</code>, <code id="hexbinplot_+3A_density">density</code>, <code id="hexbinplot_+3A_border">border</code>, <code id="hexbinplot_+3A_pen">pen</code>, <code id="hexbinplot_+3A_colramp">colramp</code>, <code id="hexbinplot_+3A_style">style</code></td>
<td>
<p> see
<code><a href="#topic+gplot.hexbin">gplot.hexbin</a></code> </p>
</td></tr>
<tr><td><code id="hexbinplot_+3A_prepanel">prepanel</code>, <code id="hexbinplot_+3A_panel">panel</code>, <code id="hexbinplot_+3A_aspect">aspect</code></td>
<td>
<p> See
<code><a href="lattice.html#topic+xyplot">xyplot</a></code>.  <code>aspect="fill"</code> is not
allowed.  The current default of <code>"xy"</code> may not always be the
best choice, often <code>aspect=1</code> will be more reasonable.  </p>
</td></tr>
<tr><td><code id="hexbinplot_+3A_colorkey">colorkey</code></td>
<td>
<p>logical, whether a legend should be drawn.  Currently
a legend can be drawn only on the right. </p>
</td></tr>
<tr><td><code id="hexbinplot_+3A_legend.width">legend.width</code>, <code id="hexbinplot_+3A_legend">legend</code></td>
<td>
<p> width of the legend in inches when
<code>style</code> is <code>"nested.lattice"</code> or
<code>"nested.centroids"</code>.  The name <code>legend.width</code> is used to
avoid conflict with the standard trellis argument <code>legend</code>.  It
is possible to specify additional legends using the <code>legend</code> or
<code>key</code> arguments as long as they do not conflict with the
hexbin legend (i.e., are not on the right).  </p>
</td></tr>
<tr><td><code id="hexbinplot_+3A_inner">inner</code></td>
<td>
<p> Inner radius in inches of hexagons in the legend when
<code>style</code> is <code>"nested.lattice"</code> or
<code>"nested.centroids"</code>.  </p>
</td></tr>
<tr><td><code id="hexbinplot_+3A_cex.labels">cex.labels</code>, <code id="hexbinplot_+3A_cex.title">cex.title</code></td>
<td>
<p> in the legend, multiplier for numeric
labels and text annotation respectively </p>
</td></tr>
<tr><td><code id="hexbinplot_+3A_type">type</code></td>
<td>
<p> character vector controlling additional augmentation of
the display.  A <code>"g"</code> in <code>type</code> adds a reference grid,
<code>"r"</code> adds a regression line (y on x), <code>"smooth"</code> adds a
loess smooth </p>
</td></tr>
<tr><td><code id="hexbinplot_+3A_draw">draw</code></td>
<td>
<p> logical, whether to draw the legend grob.  Useful when
<code>hexlegendGrob</code> is used separately  </p>
</td></tr>
<tr><td><code id="hexbinplot_+3A_vp">vp</code></td>
<td>
<p> grid viewport to draw the legend in </p>
</td></tr>
<tr><td><code id="hexbinplot_+3A_...">...</code></td>
<td>
<p> extra arguments, passed on as appropriate.  Arguments to
<code><a href="#topic+gplot.hexbin">gplot.hexbin</a></code>,
<code><a href="lattice.html#topic+xyplot">xyplot</a></code>, <code>panel.hexbinplot</code> and
<code>hexlegendGrob</code> can be supplied to the high level
<code>hexbinplot</code> call.
</p>
<p><code>panel.hexbinplot</code> calls one of two (unexported) low-level
functions depending on whether <code>groups</code> is supplied (although
specifying <code>groups</code> currently leads to an error).  Arguments of
the appropriate function can be supplied; some important ones are
</p>

<dl>
<dt><code>xbins</code>:</dt><dd><p> number of hexagons covering x values.  The
number of y-bins depends on this, the aspect ratio, and
<code>xbnds</code> and <code>ybnds</code></p>
</dd>
<dt><code>xbnds, ybnds</code>:</dt><dd><p> Numeric vector specifying range of
values that should be covered by the binning.  In a multi-panel
display, it is not necessarily a good idea to use the same
bounds (which along with <code>xbins</code> and the aspect ratio
determine the size of the hexagons) for all panels.  For
example, when data is concentrated in small subregions of
different panels, more detail will be shown by using smaller
hexagons covering those regions.  To control this, <code>xbnds</code>
and <code>ybnds</code> can also be character strings <code>"panel"</code> or
<code>"data"</code> (which are not very good names and may be changed
in future).  In the first case, the bounds are taken to be the
limits of the panel, in the second case, the limits of the data
(packet) in that panel.  Note that all panels will have the same
limits (enough to cover all the data) by default if
<code>relation="free"</code> in the standard trellis argument
<code>scales</code>, but not otherwise.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="hexbinplot_+3A_groups">groups</code></td>
<td>
<p> in <code>hexbinplot</code>, a grouping variable that is
evaluated in <code>data</code>, and passed on to the panel function.  </p>
</td></tr>
<tr><td><code id="hexbinplot_+3A_subset">subset</code></td>
<td>
<p> an expression that is evaluated in evaluated in
<code>data</code> to produce a logical vector that is used to subset the
data before being used in the plot. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The panel function <code>panel.hexbinplot</code> creates a hexbin object
from data supplied to it and plots it using
<code><a href="#topic+grid.hexagons">grid.hexagons</a></code>.  To make panels
comparable, all panels have the same <code>maxcnt</code> value, by default
the maximum count over all panels.  This default value can be
calculated only if the aspect ratio is known, and so
<code>aspect="fill"</code> is not allowed.  The default choice of aspect
ratio is different from the choice in <code>hexbin</code> (namely,
<code>1</code>), which may sometimes give better results for multi-panel
displays.  <code>xbnds</code> and <code>ybnds</code> can be numeric range vectors
as in <code>hexbin</code>, but they can also be character strings specifying
whether all panels should have the same bins.  If they are not, then
bins in different panels could be of different sizes, in which case
<code>style="lattice"</code> and <code>style="centroids"</code> should be
interpreted carefully.
</p>
<p>The dimensions of the legend and the size of the hexagons therein are
given in absolute units (inches) by <code>legend.width</code> and
<code>inner</code> only when <code>style</code> is <code>"nested.lattice"</code> or
<code>"nested.centroids"</code>.  For other styles, the dimensions of the
legend are determined relative to the plot.  Specifically, the height
of the legend is the same as the height of the plot (the panel and
strip regions combined), and the width is the minimum required to fit
the legend in the display.  This is different in some ways from the
<code>hexbin</code> implementation.  In particular, the size of the hexagons
in the legend are completely unrelated to the sizes in the panels,
which is pretty much unavoidable because the sizes need not be the
same across panels if <code>xbnds</code> or <code>ybnds</code> is <code>"data"</code>.
The size of the hexagons encode information when <code>style</code> is
<code>"lattice"</code> or <code>"centroids"</code>, consequently a warning is
issued when a legend is drawn with wither of these styles.
</p>


<h3>Value</h3>

<p><code>hexbinplot</code> produces an object of class <code>"trellis"</code>. The
<code>update</code> method can be used to update components of the object and
the <code>print</code> method (usually called by default) will plot it on an
appropriate plotting device.  <code>hexlegendGrob</code> produces a
<code>"grob"</code> (grid object).
</p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:deepayan.sarkar@r-project.org">deepayan.sarkar@r-project.org</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+hexbin">hexbin</a></code>, <code><a href="lattice.html#topic+xyplot">xyplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mixdata &lt;-
    data.frame(x = c(rnorm(5000),rnorm(5000,4,1.5)),
               y = c(rnorm(5000),rnorm(5000,2,3)),
               a = gl(2, 5000))
hexbinplot(y ~ x, mixdata, aspect = 1,
           trans = sqrt, inv = function(x) x^2)
hexbinplot(y ~ x | a, mixdata)
hexbinplot(y ~ x | a, mixdata, style = "lattice",
           xbnds = "data", ybnds = "data")
hexbinplot(y ~ x | a, mixdata, style = "nested.centroids")
hexbinplot(y ~ x | a, mixdata, style = "nested.centroids",
           border = FALSE, type = c("g", "smooth"))
</code></pre>

<hr>
<h2 id='hexGraphPaper'>Create a Hexgon Grid</h2><span id='topic+hexGraphPaper'></span><span id='topic+hgridcent'></span>

<h3>Description</h3>

<p>Creates a hexagon grid that can be added to a plot created with grid
graphics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hexGraphPaper(hb, xbnds = NULL, ybnds = NULL, xbins = 30, shape = 1,
              add = TRUE, fill.edges = 1, fill = 0, border = 1)

hgridcent(xbins, xbnds, ybnds, shape, edge.add = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hexGraphPaper_+3A_hb">hb</code></td>
<td>
<p>a object of class <code>"hexbin"</code>, typically produced by
<code><a href="#topic+hexbin">hexbin</a>(*)</code>.</p>
</td></tr>
<tr><td><code id="hexGraphPaper_+3A_xbnds">xbnds</code>, <code id="hexGraphPaper_+3A_ybnds">ybnds</code></td>
<td>
<p>horizontal and vertical limits of the binning
region in x or y units respectively; must be numeric vector of
length 2.</p>
</td></tr>
<tr><td><code id="hexGraphPaper_+3A_xbins">xbins</code></td>
<td>
<p>the number of bins partitioning the range of xbnds.</p>
</td></tr>
<tr><td><code id="hexGraphPaper_+3A_shape">shape</code></td>
<td>
<p>the <em>shape</em> = yheight/xwidth of the plotting regions.</p>
</td></tr>
<tr><td><code id="hexGraphPaper_+3A_add">add</code></td>
<td>
<p>a logical value indicating whether or not to add the grid
to the current plot.</p>
</td></tr>
<tr><td><code id="hexGraphPaper_+3A_fill.edges">fill.edges</code></td>
<td>
<p>integer number of hexagons to add around the border</p>
</td></tr>
<tr><td><code id="hexGraphPaper_+3A_fill">fill</code></td>
<td>
<p>the fill color for the hexagons</p>
</td></tr>
<tr><td><code id="hexGraphPaper_+3A_border">border</code></td>
<td>
<p>the color of the border of the hexagons</p>
</td></tr>
<tr><td><code id="hexGraphPaper_+3A_edge.add">edge.add</code></td>
<td>
<p>offset (typically <code>fill.edges</code> above) used in
<code>hgridcent</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a hexbin object is given then the parameters xbins and shape are
ignored. Different bounds can still be specified. The <code>fill.edges</code>
parameter should be an integer. <code>fill.edges</code> takes the current
grid and adds a layer of hexagons around the grid for each level of
fill. So for example if <code>fill.edges= 2</code> than the dimensions of
the grid would be <code>(i,j)+4</code>.
</p>
<p><code>hgridcent()</code> is the utility function computing the resulting
list (see section &ldquo;Value&rdquo;).
</p>
<p><strong>WARNING! If using a hexVP be sure to set clip to &quot;on&quot;, otherwise the
hexagon grid will bleed over the plot edges.</strong>
</p>


<h3>Value</h3>

<p>Invisibly returns a list with th following components
</p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>The x coordinates of the grid</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the y coordinates of the grid</p>
</td></tr>
<tr><td><code>dimen</code></td>
<td>
<p>a vector of length 2 gining the rows and columns of the grid</p>
</td></tr>
<tr><td><code>dx</code></td>
<td>
<p>the horizontal diameter of the hexagons</p>
</td></tr>
<tr><td><code>dy</code></td>
<td>
<p>the vertical diameter of the hexagons</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nicholas Lewin-Koh</p>


<h3>See Also</h3>

<p><code><a href="#topic+hcell2xy">hcell2xy</a></code>, <code><a href="#topic+hexpolygon">hexpolygon</a></code>,
<code><a href="#topic+grid.hexagons">grid.hexagons</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'> x &lt;- rnorm(10000)
 y &lt;- rnorm(10000,x,x)
 hbin &lt;- hexbin(x,y)
 hvp &lt;- plot(hbin,type="n")
 pushHexport(hvp$plot,clip="on")
 hexGraphPaper(hbin,border=grey(.8))
 grid.hexagons(hbin)
</code></pre>

<hr>
<h2 id='hexList'>Conditional Bivariate Binning into Hexagon Cells </h2><span id='topic+hexList'></span><span id='topic+hexbinList-class'></span><span id='topic+coerce+2Clist+2ChexbinList-method'></span>

<h3>Description</h3>

<p>Creates a list of <code><a href="#topic+hexbin">hexbin</a></code> objects.  Basic components are
a cell id and a count of points falling in each occupied cell.
Basic methods are <code><a href="methods.html#topic+show">show</a>()</code>, <code>plot()</code> 
and <code><a href="base.html#topic+summary">summary</a>()</code>, but also <code><a href="#topic+erode">erode</a></code>.

</p>


<h3>Usage</h3>

<pre><code class='language-R'>hexList(x, y = NULL, given = NULL, xbins = 30, shape = 1,
        xbnds = NULL, ybnds = NULL, xlab = NULL, ylab = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hexList_+3A_x">x</code></td>
<td>
<p> x coordinate to be binned </p>
</td></tr>
<tr><td><code id="hexList_+3A_y">y</code></td>
<td>
<p> y coordinate to be binned </p>
</td></tr>
<tr><td><code id="hexList_+3A_given">given</code></td>
<td>
<p> ..</p>
</td></tr>
<tr><td><code id="hexList_+3A_xbins">xbins</code></td>
<td>
<p> number of bins partitioning the range of xbnds</p>
</td></tr>
<tr><td><code id="hexList_+3A_shape">shape</code></td>
<td>
<p> the <em>shape</em> = yheight/xwidth of the plotting regions </p>
</td></tr>
<tr><td><code id="hexList_+3A_xbnds">xbnds</code></td>
<td>
<p> horizontal limits of binning </p>
</td></tr>
<tr><td><code id="hexList_+3A_ybnds">ybnds</code></td>
<td>
<p> vertical limits of binning </p>
</td></tr>
<tr><td><code id="hexList_+3A_xlab">xlab</code></td>
<td>
<p> character strings used as labels for <code>x</code> </p>
</td></tr>
<tr><td><code id="hexList_+3A_ylab">ylab</code></td>
<td>
<p> character strings used as labels for <code>y</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>There is also a <code><a href="methods.html#topic+as">coerce</a></code> method to produce
<code>hexbinList</code> objects from <code><a href="base.html#topic+list">list</a></code>s.

</p>


<h3>Value</h3>

<p>If it is a LIST, use
</p>
<table role = "presentation">
<tr><td><code>comp1</code></td>
<td>
<p>Description of 'comp1'</p>
</td></tr>
<tr><td><code>comp2</code></td>
<td>
<p>Description of 'comp2'</p>
</td></tr>
</table>
<p>...
</p>


<h3>Author(s)</h3>

<p>Nicholas Lewin-Koh</p>


<h3>See Also</h3>

<p><code><a href="#topic+hexbin">hexbin</a></code>, <code><a href="#topic+hdiffplot">hdiffplot</a></code> </p>

<hr>
<h2 id='hexMA.loess'>Add Loess Fit to Hexplot </h2><span id='topic+hexVP.loess'></span><span id='topic+hexMA.loess'></span>

<h3>Description</h3>

<p>Fit a loess line using the hexagon centers of mass as the x and y
coordinates and the cell counts as weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hexMA.loess(pMA, span = 0.4, col = "red", n = 200, ...)
hexVP.loess(hbin, hvp = NULL, span = 0.4, col = "red", n = 200, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hexMA.loess_+3A_hbin">hbin</code></td>
<td>
<p>an object of class <code>hexbin</code>, see <code><a href="#topic+hexbin">hexbin</a></code>.</p>
</td></tr>
<tr><td><code id="hexMA.loess_+3A_hvp">hvp</code></td>
<td>
<p>A <code>hexViewport</code> object.</p>
</td></tr>
<tr><td><code id="hexMA.loess_+3A_pma">pMA</code></td>
<td>
<p>the list returned by <code><a href="#topic+plotMAhex">plotMAhex</a></code>.</p>
</td></tr>
<tr><td><code id="hexMA.loess_+3A_span">span</code></td>
<td>
<p>the parameter alpha which controls the degree of smoothing.</p>
</td></tr>
<tr><td><code id="hexMA.loess_+3A_col">col</code></td>
<td>
<p>line color for the loess fit.</p>
</td></tr>
<tr><td><code id="hexMA.loess_+3A_n">n</code></td>
<td>
<p>number of points at which the fit should be evaluated.</p>
</td></tr>
<tr><td><code id="hexMA.loess_+3A_...">...</code></td>
<td>
<p>Additional graphical parameter settings for the <code>loess</code> line fit; see <code><a href="grid.html#topic+gpar">gpar</a></code>.</p>
</td></tr></table>


<h3>Value</h3>

<p>Returns invisibly the object associated with the loess fit.
</p>


<h3>Author(s)</h3>

<p>Nicholas Lewin-Koh </p>


<h3>See Also</h3>

 <p><code><a href="#topic+hexVP.abline">hexVP.abline</a></code>, <code><a href="#topic+plotMAhex">plotMAhex</a></code>,
<code><a href="#topic+gplot.hexbin">gplot.hexbin</a></code>, <code><a href="#topic+hexViewport">hexViewport</a></code>;
<code><a href="stats.html#topic+loess">loess</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  if(require(marray)){
    data(swirl)
    
    hb &lt;- plotMAhex(swirl[,1], main = "M vs A plot with hexagons", legend=0)
    hexVP.abline(hb$plot, h=0, col= gray(.6))
    hexMA.loess(hb)
  } 
  
  dat &lt;- data.frame(x=rnorm(1000), y=rnorm(1000))
  bin &lt;- hexbin(dat$x, dat$y)
  hb &lt;- plot(bin)
  hexVP.loess(bin, hvp = hb$plot.vp, span = 0.4, n = 200, col = "blue", lwd = 3, lty = "dashed")
</code></pre>

<hr>
<h2 id='hexplom'>Hexbin Plot Matrices</h2><span id='topic+hexplom'></span><span id='topic+hexplom.formula'></span><span id='topic+hexplom.data.frame'></span><span id='topic+hexplom.matrix'></span><span id='topic+panel.hexplom'></span>

<h3>Description</h3>

<p><code>hexplom</code> draws Conditional Hexbin Plot Matrices.  It is similar
to <code>splom</code>, expect that the default display is different.
Specifically, the default display is created using
<code>panel.hexplom</code>, which is an alias for <code>panel.hexbinplot</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hexplom(x, data, ...)

## S3 method for class 'formula'
hexplom(x, data = NULL, ...)

## S3 method for class 'data.frame'
hexplom(x, data = NULL, ..., groups = NULL,
   subset = TRUE) 

## S3 method for class 'matrix'
hexplom(x, data = NULL, ..., groups = NULL, subset = TRUE)

panel.hexplom(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hexplom_+3A_x">x</code></td>
<td>

<p>The object on which method dispatch is carried out.
</p>
<p>For the <code>"formula"</code> method, a formula describing the structure
of the plot, which should be of the form <code>~ x | g1 * g2 *
    ...</code>, where <code>x</code> is a data frame or matrix.  Each of <code>g1,
    g2, ...</code> must be either factors or shingles. The conditioning
variables <code>g1, g2, ...</code> may be omitted.
</p>
<p>For the <code>data.frame</code> and <code>matrix</code> methods, a data frame or
matrix as appropriate.
</p>
</td></tr>
<tr><td><code id="hexplom_+3A_data">data</code></td>
<td>

<p>For the <code>formula</code> method, an optional data frame in which
variables in the formula (as well as <code>groups</code> and
<code>subset</code>, if any) are to be evaluated.  By default, the
environment where the function was called from is used.
</p>
</td></tr>
<tr><td><code id="hexplom_+3A_groups">groups</code>, <code id="hexplom_+3A_subset">subset</code>, <code id="hexplom_+3A_...">...</code></td>
<td>
<p> see <code><a href="lattice.html#topic+splom">splom</a></code>.  The
non-standard evaluation of <code>groups</code> and <code>subset</code> only
applies in the <code>formula</code> method.  Apart from arguments that
apply to <code>splom</code> (many of which are only documented in
<code><a href="lattice.html#topic+xyplot">xyplot</a></code>), additional arguments meant for
<code>panel.hexplom</code> (which is an alias for
<code><a href="#topic+panel.hexbinplot">panel.hexbinplot</a></code>) may also be supplied.  Such
arguments may include ones that control details of the hexbin
calculations, documented in <code><a href="#topic+gplot.hexbin">gplot.hexbin</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"trellis"</code>. The
<code><a href="lattice.html#topic+update.trellis">update</a></code> method can be used to
update components of the object and the
<code><a href="lattice.html#topic+print.trellis">print</a></code> method (usually called by
default) will plot it on an appropriate plotting device.
</p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:Deepayan.Sarkar@R-project.org">Deepayan.Sarkar@R-project.org</a>,
Nicholas Lewin-Koh <a href="mailto:nikko@hailmail.net">nikko@hailmail.net</a></p>


<h3>See Also</h3>

<p><code><a href="lattice.html#topic+splom">splom</a></code>, <code><a href="lattice.html#topic+xyplot">xyplot</a></code>,
<code><a href="#topic+hexbinplot">hexbinplot</a></code>,
<code><a href="lattice.html#topic+Lattice">Lattice</a></code>, <code><a href="lattice.html#topic+panel.pairs">panel.pairs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Simple hexplom
data(NHANES)
hexplom(~NHANES[,7:14], xbins=15)

## With colors and conditioning
hexplom(~NHANES[,9:13] | Sex, data = NHANES,
        xbins = 15, colramp = magent)

## With custom panel function
hexplom(NHANES[,9:13], xbins = 20,colramp = BTY, 
        upper.panel = panel.hexboxplot)

  
</code></pre>

<hr>
<h2 id='hexpolygon'>Hexagon Coordinates and Polygon Drawing</h2><span id='topic+hexpolygon'></span><span id='topic+hexcoords'></span>

<h3>Description</h3>

<p>Simple &lsquo;low-level&rsquo; function for computing and drawing hexagons.
Can be used for &lsquo;grid&rsquo; (package <span class="pkg">grid</span>) or
&lsquo;traditional&rsquo; (package <span class="pkg">graphics</span>) graphics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hexcoords(dx, dy = NULL, n = 1, sep = NULL)

hexpolygon(x, y, hexC = hexcoords(dx, dy, n = 1), dx, dy = NULL,
           fill = 1, border = 0, hUnit = "native", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hexpolygon_+3A_dx">dx</code>, <code id="hexpolygon_+3A_dy">dy</code></td>
<td>
<p>horizontal and vertical width of the hexagon(s).</p>
</td></tr>
<tr><td><code id="hexpolygon_+3A_n">n</code></td>
<td>
<p>number of hexagon &ldquo;repeats&rdquo;.</p>
</td></tr>
<tr><td><code id="hexpolygon_+3A_sep">sep</code></td>
<td>
<p>separator value to be put between coordinates of different
hexagons. The default, <code>NULL</code> doesn't use a separator.</p>
</td></tr>
<tr><td><code id="hexpolygon_+3A_x">x</code>, <code id="hexpolygon_+3A_y">y</code></td>
<td>
<p>numeric vectors of the same length specifying the hexagon
<em>centers</em> around which to draw.</p>
</td></tr>
<tr><td><code id="hexpolygon_+3A_hexc">hexC</code></td>
<td>
<p>a list as returned from <code>hexcoords()</code>.
Its component <code>no.sep</code> determines if grid or traditional
graphics are used. The default (via default of <code>hexcoords</code>) is
now to use grid graphics.</p>
</td></tr>
<tr><td><code id="hexpolygon_+3A_fill">fill</code>, <code id="hexpolygon_+3A_border">border</code></td>
<td>
<p>passed to <code><a href="grid.html#topic+grid.polygon">grid.polygon</a></code> (for <span class="pkg">grid</span>).</p>
</td></tr>
<tr><td><code id="hexpolygon_+3A_hunit">hUnit</code></td>
<td>
<p>string or <code>NULL</code> determining in which units (x,y)
values are.</p>
</td></tr>
<tr><td><code id="hexpolygon_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="graphics.html#topic+polygon">polygon</a></code> (for
<span class="pkg">graphics</span>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>hexcoords()</code> returns a list with components
</p>
<table role = "presentation">
<tr><td><code>x</code>, <code>y</code></td>
<td>
<p>numeric vectors of length <code class="reqn">n \times 6</code> (or
<code class="reqn">n \times 7</code> if <code>sep</code> is not NULL)
specifying the hexagon polygon coordinates (with <code>sep</code> appended
to each 6-tuple).</p>
</td></tr>
<tr><td><code>no.sep</code></td>
<td>
<p>a logical indicating if <code>sep</code> was <code>NULL</code>.</p>
</td></tr>
</table>
<p><code>hexpolygon</code> returns what its last <code><a href="grid.html#topic+grid.polygon">grid.polygon</a>(.)</code>
or <code><a href="graphics.html#topic+polygon">polygon</a>(.)</code> call returns.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler, originally.</p>


<h3>See Also</h3>

<p><code><a href="#topic+grid.hexagons">grid.hexagons</a></code> which builds on these.</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(hexcoords(1, sep = NA))  # multiple of (6 + 1)
str(hexcoords(1, sep = NULL))# no separator -&gt; multiple of 6


## hexpolygon()s:
x &lt;- runif(20, -2, 2)
y &lt;- x + rnorm(20)

## 1) traditional 'graphics'
plot(x,y, asp = 1, "plot() + hexpolygon()")
hexpolygon(x,y, dx = 0.1, density = 25, col = 2, lwd = 1.5)

## 2) "grid" :

addBit &lt;- function(bnds, f = 0.05) bnds + c(-f, f) * diff(bnds)
sc &lt;- addBit(rxy &lt;- range(x,y))# same extents (cheating asp=1)
library("grid")
grid.newpage()
pushViewport(plotViewport(.1+c(4,4,2,1), xscale = sc, yscale = sc))
grid.rect()
grid.xaxis()
grid.yaxis()
grid.points(x,y)
hexpolygon(x,y, hexcoords(dx = 0.1, sep=NULL), border = "blue", fill=NA)
popViewport()
</code></pre>

<hr>
<h2 id='hexTapply'>Apply function to data from each hexagon bin.</h2><span id='topic+hexTapply'></span>

<h3>Description</h3>

<p>A wrapper for tapply except that it operates with each hexagon bin
being the category. The function operates on the data associated on
the points from each bin. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hexTapply(hbin, dat, FUN = sum, ..., simplify=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hexTapply_+3A_hbin">hbin</code></td>
<td>
<p>a object of class <code>"hexbin"</code>, typically produced by
<code><a href="#topic+hexbin">hexbin</a>(*)</code>.</p>
</td></tr>
<tr><td><code id="hexTapply_+3A_dat">dat</code></td>
<td>
<p>A vector of data the same length as <code>hbin@cID</code></p>
</td></tr>
<tr><td><code id="hexTapply_+3A_fun">FUN</code></td>
<td>
<p>the function to be applied.  In the case of functions like
<code>+</code>, <code>%*%</code>, etc., the function name must be quoted.  If
<code>FUN</code> is <code>NULL</code>, tapply returns a vector which can be used
to subscript the multi-way array <code>tapply</code> normally produces.</p>
</td></tr>
<tr><td><code id="hexTapply_+3A_...">...</code></td>
<td>
<p>optional arguments to <code>FUN</code>.</p>
</td></tr>
<tr><td><code id="hexTapply_+3A_simplify">simplify</code></td>
<td>
<p>If <code>FALSE</code>, <code>tapply</code> always returns an array
of mode <code>"list"</code>.  If <code>TRUE</code> (the default), then if
<code>FUN</code> always returns a scalar, <code>tapply</code> returns an array
with the mode of the scalar.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper for tapply, except that the cell id is
always the categorical variable. This function is specifically good for
adding variables to the cAtt slot of a hexbin object or for plotting
a third variable in a hexagon plot. See below for examples.
</p>


<h3>Value</h3>

<p>Returns a vector of the result of 'FUN' as in
<code><a href="base.html#topic+tapply">tapply</a></code>. See <code><a href="base.html#topic+tapply">tapply</a></code> for detailed
description of output.
</p>


<h3>Author(s)</h3>

<p>Nicholas Lewin-Koh</p>


<h3>See Also</h3>

 <p><code><a href="base.html#topic+tapply">tapply</a></code>,<code><a href="#topic+hexbin">hexbin</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(NHANES)
  hbin&lt;-hexbin(log(NHANES$Diet.Iron+1),log(NHANES$BMI),xbins=25,IDs=TRUE)
  hvp&lt;-plot(hbin)
  mtrans&lt;-hexTapply(hbin,NHANES$Transferin,median,na.rm=TRUE)
  pushHexport(hvp$plot.vp)
  grid.hexagons(hbin,style='lattice',pen=0,border='red',use.count=FALSE,
cell.at=mtrans)

  
  
</code></pre>

<hr>
<h2 id='hexViewport'>Compute a Grid Viewport for Hexagon / Hexbin Graphics</h2><span id='topic+hexViewport'></span>

<h3>Description</h3>

<p>Builds a <code>grid</code> viewport for hexagon or <code><a href="#topic+hexbin">hexbin</a></code>
graphics.  This builds on the concepts of the <span class="pkg">grid</span> package,
see <code><a href="grid.html#topic+viewport">viewport</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
hexViewport(x, offset = unit(0,"inches"), mar = NULL,
	    xbnds = NULL, ybnds = NULL, newpage = FALSE,
            clip = "off", vp.name = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hexViewport_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+hexbin">hexbin</a></code> object.</p>
</td></tr>
<tr><td><code id="hexViewport_+3A_offset">offset</code></td>
<td>
<p>a <code><a href="grid.html#topic+unit">unit</a></code> object.</p>
</td></tr>
<tr><td><code id="hexViewport_+3A_mar">mar</code></td>
<td>
<p>margins as <code><a href="grid.html#topic+unit">unit</a></code>s, of length 4 or 1.</p>
</td></tr>
<tr><td><code id="hexViewport_+3A_xbnds">xbnds</code>, <code id="hexViewport_+3A_ybnds">ybnds</code></td>
<td>
<p>bounds for x- and y- plotting range; these default
to the corresponding slots of <code>x</code>.</p>
</td></tr>
<tr><td><code id="hexViewport_+3A_newpage">newpage</code></td>
<td>
<p>logical indicating if a new graphics page should be
openend, i.e., <code><a href="grid.html#topic+grid.newpage">grid.newpage</a>()</code>.</p>
</td></tr>
<tr><td><code id="hexViewport_+3A_clip">clip</code></td>
<td>
<p>simply passed to <code><a href="grid.html#topic+viewport">viewport</a>()</code>.</p>
</td></tr>
<tr><td><code id="hexViewport_+3A_vp.name">vp.name</code></td>
<td>
<p>name of viewport; defaults to random name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an S4 object of class <code>"hexVP"</code>, see <a href="#topic+hexVP-class">hexVP-class</a> for more,
with its main slot <code>hexVp</code> a <code><a href="grid.html#topic+viewport">viewport</a></code> for
grid graphics. 
</p>


<h3>See Also</h3>

<p><code><a href="grid.html#topic+viewport">viewport</a></code> and the main
<em>&ldquo;handlers&rdquo;</em> <code><a href="#topic+pushHexport">pushHexport</a></code> and
<code><a href="grid.html#topic+viewports">popViewport</a></code>; further
<code><a href="#topic+gplot.hexbin">gplot.hexbin</a></code> and <code><a href="#topic+hboxplot">hboxplot</a></code> which build on
<code>hexViewport</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(131)
x &lt;- rnorm(7777)
y &lt;- rt   (7777, df=3)

## lower resolution binning and overplotting with counts
bin &lt;- hexbin(x,y,xbins=25)
P &lt;- plot(bin)
xy &lt;- hcell2xy(bin)
pushHexport(P$plot.vp)
i &lt;- bin@count &lt;= 3
library("grid")
grid.text(as.character(bin@count[i]), xy$x[i], xy$y[i],
          default.units = "native")
grid.points(x[1:20],y[1:20]) # to show some points rather than counts
popViewport()
</code></pre>

<hr>
<h2 id='hexVP-class'>Formal class &quot;hexVP&quot; of a Hexagon Viewport</h2><span id='topic+hexVP-class'></span><span id='topic+getFig+2ChexVP-method'></span><span id='topic+getMargins+2ChexVP-method'></span><span id='topic+getPlt+2ChexVP-method'></span><span id='topic+getXscale+2ChexVP-method'></span><span id='topic+getYscale+2ChexVP-method'></span>

<h3>Description</h3>

<p>Hexagon Viewports are &ldquo;value-added&rdquo; grid viewports (see
<code><a href="grid.html#topic+viewport">viewport</a></code>) where the extra slots contain scaling and
&ldquo;embedding&rdquo; information. A hexViewport is created my taking the
available area in the cuurent viewport on the graphics device and
maximizing the amount of area with a fied aspect ratio. The default
when the shape parameter is 1, is a 1:1 aspect ratio in terms of the
size of the viewport, not the scale of the x and y axis. The plotting
area is centered within the existing margins and the maximum size
determined. Extra area is then allocated to the margins. This viewport
is replicated twice, once with clipping set to &quot;on&quot; and once with
clipping &quot;off&quot;. This feature can be used for toggling clipping on and
off while editing the plot.
</p>


<h3>Objects from the Class</h3>

<p>Objects are typically created by calls to <code><a href="#topic+hexViewport">hexViewport</a>()</code>
or by low level calls of the form <code>new("hexVP", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>hexVp.off</code>:</dt><dd><p>Object of class <code>"viewport"</code> with
clipping set to off, see <code><a href="grid.html#topic+viewport">viewport</a></code>.</p>
</dd>
<dt><code>hexVp.on</code>:</dt><dd><p>Object of class <code>"viewport"</code>, with the same
dimensions and parameters as hexVp.off, but with
clipping set to on, see <code><a href="grid.html#topic+viewport">viewport</a></code>.</p>
</dd>
<dt><code>hp.name</code>:</dt><dd><p>The name of the viewport for searching a vptree</p>
</dd></dl>
<p>.
</p>
<dl>
<dt><code>mar</code>:</dt><dd><p><code><a href="grid.html#topic+unit">unit</a></code> vector of four margins
(typically in <code>"lines"</code>).</p>
</dd>
<dt><code>fig</code>:</dt><dd><p><code><a href="grid.html#topic+unit">unit</a></code> vector of two figure sizes
(typically in <code>"npc"</code>).</p>
</dd>
<dt><code>plt</code>:</dt><dd><p><code><a href="grid.html#topic+unit">unit</a></code> vector of two figure sizes
(typically in <code>"npc"</code>).</p>
</dd>



<dt><code>shape</code>:</dt><dd><p>The shape parameter from the plotted
<code><a href="#topic+hexbin">hexbin</a></code> object.</p>
</dd>
<dt><code>xscale</code>:</dt><dd><p>numeric of length two specifying x-range.</p>
</dd>
<dt><code>yscale</code>:</dt><dd><p>numeric of length two specifying y-range.</p>
</dd>
</dl>



<h3>Methods</h3>

<p>These are methods accessing the slots of corresponding name.
</p>

<dl>
<dt>getFig</dt><dd><p><code>signature(hvp = "hexVP")</code>: ... </p>
</dd>
<dt>getMargins</dt><dd><p><code>signature(hvp = "hexVP")</code>: ... </p>
</dd>
<dt>getPlt</dt><dd><p><code>signature(hvp = "hexVP")</code>: ... </p>
</dd>
<dt>getXscale</dt><dd><p><code>signature(hvp = "hexVP")</code>: ... </p>
</dd>
<dt>getYscale</dt><dd><p><code>signature(hvp = "hexVP")</code>: ... </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Nicholas Lewin-Koh <a href="mailto:kohnicho@comp.nus.edu.sg">kohnicho@comp.nus.edu.sg</a>.
</p>


<h3>See Also</h3>

<p>The constructor function <code><a href="#topic+hexViewport">hexViewport</a></code>.
<code><a href="#topic+hexbin">hexbin</a></code>, and its S4 plotting method,
<code><a href="#topic+gplot.hexbin">gplot.hexbin</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> library("grid")
 example(hexViewport, echo=FALSE)
 ## continued:
 str(P$plot.vp)
</code></pre>

<hr>
<h2 id='hexVP.abline'>Add a Straight Line to a HexPlot</h2><span id='topic+hexVP.abline'></span>

<h3>Description</h3>

<p>This function adds one or more straight lines through the current
plot; it is the hexbin version of <code><a href="graphics.html#topic+abline">abline</a>()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hexVP.abline(hvp, a = NULL, b = NULL, h = numeric(0), v = numeric(0),
             col = "black", lty = 1, lwd = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hexVP.abline_+3A_hvp">hvp</code></td>
<td>
<p>A hexViewport object that is currently on the active device</p>
</td></tr>
<tr><td><code id="hexVP.abline_+3A_a">a</code>, <code id="hexVP.abline_+3A_b">b</code></td>
<td>
<p>the intercept and slope or if <code>b</code> is <code>NULL</code>,
an <code>lm</code> object or a vector of length 2 with
<code>c(intercept,slope)</code></p>
</td></tr>
<tr><td><code id="hexVP.abline_+3A_h">h</code></td>
<td>
<p>the y-value for a horizontal line.</p>
</td></tr>
<tr><td><code id="hexVP.abline_+3A_v">v</code></td>
<td>
<p>the x-value for a vertical line.</p>
</td></tr>
<tr><td><code id="hexVP.abline_+3A_col">col</code>, <code id="hexVP.abline_+3A_lty">lty</code>, <code id="hexVP.abline_+3A_lwd">lwd</code></td>
<td>
<p>line color, type and width.</p>
</td></tr>
<tr><td><code id="hexVP.abline_+3A_...">...</code></td>
<td>
<p>further graphical parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first form specifies the line in intercept/slope form
(alternatively <code>a</code> can be specified on its own and is taken to
contain the slope and intercept in vector form).
</p>
<p>The <code>h=</code> and <code>v=</code> forms draw horizontal and vertical
lines at the specified coordinates.
</p>
<p>The <code>coef</code> form specifies the line by a vector containing the
slope and intercept.
</p>
<p><code>lm</code> is a regression object which contains <code>reg$coef</code>.  If it is
of length 1 then the value is taken to be the slope of a line
through the origin, otherwise, the first 2 values are taken to be
the intercept and slope.
</p>


<h3>Author(s)</h3>

<p>Nicholas Lewin-Koh</p>


<h3>See Also</h3>

<p><code><a href="#topic+gplot.hexbin">gplot.hexbin</a></code>, <code><a href="#topic+hexViewport">hexViewport</a></code>,
<code><a href="#topic+hexMA.loess">hexMA.loess</a></code>
</p>

<hr>
<h2 id='hsmooth-methods'>Hexagon Bin Smoothing: Generic hsmooth() and Methods</h2><span id='topic+hsmooth'></span><span id='topic+hsmooth-methods'></span><span id='topic+hsmooth+2Chexbin-method'></span>

<h3>Description</h3>

<p>Methods for the generic function <code>hsmooth</code> in package
<span class="pkg">hexbin</span>:
There is currently only the one for <code><a href="#topic+hexbin">hexbin</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'hexbin'
hsmooth(bin, wts)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hsmooth-methods_+3A_bin">bin</code></td>
<td>
<p>a <code><a href="#topic+hexbin">hexbin</a></code> object, or an extension such as
<code><a href="#topic+erodebin-class">erodebin-class</a></code>.</p>
</td></tr>
<tr><td><code id="hsmooth-methods_+3A_wts">wts</code></td>
<td>
<p>weights vector, see <code><a href="#topic+smooth.hexbin">smooth.hexbin</a></code></p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>bin = &quot;hexbin&quot;</dt><dd><p>is just the <code><a href="#topic+smooth.hexbin">smooth.hexbin</a></code>
function (for back compatibility); see its documentation, also for
examples.</p>
</dd>
</dl>


<hr>
<h2 id='inout.hex'>Check points for inclusion</h2><span id='topic+inout.hex'></span>

<h3>Description</h3>

<p>Check which points are in hexagons with <code>count</code> &lt;= mincnt.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inout.hex(hbin, mincnt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inout.hex_+3A_hbin">hbin</code></td>
<td>
<p>an object of class <code><a href="#topic+hexbin">hexbin</a></code>.</p>
</td></tr>
<tr><td><code id="inout.hex_+3A_mincnt">mincnt</code></td>
<td>
<p>Cutoff, id's for counts less than mincnt are returned</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Check which points are in hexagons with <code>count</code> &lt;= mincnt and
returns the row ids for those points. One can use the ids to plot low
ount hexagons as points instead.  
</p>


<h3>Value</h3>

<p>A vector with the row ids of points which fall in hexagons with
<code>count</code> less than or equal to mincnt
</p>


<h3>Author(s)</h3>

<p>Nicholas Lewin-Koh</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotMAhex">plotMAhex</a></code></p>

<hr>
<h2 id='list2hexList'>Convert list to hexList</h2><span id='topic+list2hexList'></span>

<h3>Description</h3>

<p>Converts a list of hexbin objects with same xbnds, ybnds, shape and
xbins to a <code><a href="#topic+hexList">hexList</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list2hexList(binlst)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="list2hexList_+3A_binlst">binlst</code></td>
<td>
<p>A list of hexbin objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="#topic+hexList">hexList</a></code> object
</p>


<h3>Author(s)</h3>

<p>Nicholas Lewin-Koh</p>


<h3>See Also</h3>

<p><code><a href="#topic+hexList">hexList</a></code>,<code><a href="#topic+hdiffplot">hdiffplot</a></code> </p>

<hr>
<h2 id='NHANES'>NHANES Data : National Health and Nutrition Examination Survey</h2><span id='topic+NHANES'></span>

<h3>Description</h3>

<p>This is a somewhat large interesting dataset, a data frame of 15
variables (columns) on 9575 persons (rows).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(NHANES)</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>Cancer.Incidence</dt><dd><p>binary factor with levels <code>No</code> and <code>Yes</code>.</p>
</dd>
<dt>Cancer.Death</dt><dd><p>binary factor with levels <code>No</code> and <code>Yes</code>.</p>
</dd>
<dt>Age</dt><dd><p>numeric vector giving age of the person in years.</p>
</dd>
<dt>Smoke</dt><dd><p>a factor with levels <code>Current</code>, <code>Past</code>,
<code>Nonsmoker</code>, and <code>Unknown</code>.</p>
</dd>
<dt>Ed</dt><dd><p>numeric vector of <code class="reqn">\{0,1\}</code> codes giving the education level.</p>
</dd>
<dt>Race</dt><dd><p>numeric vector of <code class="reqn">\{0,1\}</code> codes giving the
person's race.
</p>
</dd>
<dt>Weight</dt><dd><p>numeric vector giving the weight in kilograms</p>
</dd>
<dt>BMI</dt><dd><p>numeric vector giving Body Mass Index, i.e.,
<code>Weight/Height^2</code> where Height is in meters, and missings
(61% !) are coded as <code>0</code> originally.</p>
</dd>
<dt>Diet.Iron</dt><dd><p>numeric giving Dietary iron.</p>
</dd>
<dt>Albumin</dt><dd><p>numeric giving albumin level in g/l.</p>
</dd>
<dt>Serum.Iron</dt><dd><p>numeric giving Serum iron in <code class="reqn">\mu</code>g/l.</p>
</dd>
<dt>TIBC</dt><dd><p>numeric giving Total Iron Binding Capacity in <code class="reqn">\mu</code>g/l.</p>
</dd>
<dt>Transferin</dt><dd><p>numeric giving Transferin Saturation which is just
<code>100*serum.iron/TIBC</code>.</p>
</dd>
<dt>Hemoglobin</dt><dd><p>numeric giving Hemoglobin level.</p>
</dd>
<dt>Sex</dt><dd><p>a factor with levels <code>F</code> (female) and <code>M</code> (male).</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(NHANES)
summary(NHANES)
## Missing Data overview :
nNA &lt;- sapply(NHANES, function(x)sum(is.na(x)))
cbind(nNA[nNA &gt; 0])
# Which are just these 6 :
## Not run: 
Diet.Iron         141
Albumin           252
Serum.Iron       1008
TIBC              853
Transferin       1019
Hemoglobin        759

## End(Not run)
</code></pre>

<hr>
<h2 id='old-classes'>Class &quot;unit&quot; and &quot;viewport&quot; as S4 classes</h2><span id='topic+unit-class'></span><span id='topic+viewport-class'></span>

<h3>Description</h3>

<p>Package &quot;hexbin&quot; now uses S4 classes throughout and hence
needs to <code><a href="methods.html#topic+setOldClass">setOldClass</a></code> both <code>"unit"</code> and
<code>"viewport"</code> (which are S3 classes from the <span class="pkg">grid</span> package),
in order to be able to use those in slots of its own classes.
</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be
created from it.</p>


<h3>Extends</h3>

<p>Class <code>"oldClass"</code>, directly.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;unit&quot; in the signature.
</p>

<hr>
<h2 id='optShape'>Optimal Shape Parameter for Hexbin Viewport</h2><span id='topic+optShape'></span>

<h3>Description</h3>

<p>Takes a viewport or a given height and width and returns the shape
parameter that will fill the specified plotting region with the
appropriately shaped hexagons.  If margins are specified the margins
are subtracted from height and width before the shape parameter is
specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optShape(vp, height = NULL, width = NULL, mar = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="optShape_+3A_vp">vp</code></td>
<td>
<p>a <code>viewport</code> object, optional see details</p>
</td></tr>
<tr><td><code id="optShape_+3A_height">height</code></td>
<td>
<p>the height of the plotting region, can be numeric or units</p>
</td></tr>
<tr><td><code id="optShape_+3A_width">width</code></td>
<td>
<p>The width of the plotting region, can be numeric or units</p>
</td></tr>
<tr><td><code id="optShape_+3A_mar">mar</code></td>
<td>
<p>A four element numeric or units vector describing the
margins in the order <code>c(bottom, left, top, right)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar numeric value specifiyng <code>shape</code>.
</p>


<h3>Warning</h3>

<p>If a viewport is given as an argument it should
already be pushed on the graphics device or it will have null units
and a meaningless shape parameter will be returned.
</p>


<h3>Author(s)</h3>

<p>Nicholas Lewin-Koh</p>


<h3>See Also</h3>

<p><code><a href="#topic+hexViewport">hexViewport</a></code>, <code><a href="#topic+hexVP-class">hexVP-class</a></code>,
<code><a href="#topic+hexbin">hexbin</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rgamma(10000,.9)
m &lt;- as.logical(rbinom(10000,1,.17))
x[m] &lt;- -x[m]
y &lt;- rnorm(x,abs(x))
library("grid")
vp &lt;- plotViewport(xscale= range(x)+c(-.5,.5),
                   yscale= range(y)+c(-.5,.5),
             default.units = "native")
grid.newpage()
pushViewport(vp)
grid.rect()
shape &lt;- optShape(vp)
shape
hb &lt;- hexbin(x,y,xbins=40,shape=shape)
grid.hexagons(hb,colramp=BTY)
</code></pre>

<hr>
<h2 id='panel.hexboxplot'>Boxplot for hexbin lattice plot</h2><span id='topic+panel.hexboxplot'></span>

<h3>Description</h3>

<p>A panel function to add a boxplot to a hexbin lattice plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.hexboxplot(x, y, xbins = 30,
                 xbnds = c("data", "panel"), ybnds = c("data", "panel"),
                 .prelim = FALSE, .cpl = current.panel.limits(),
                 .xlim = .cpl$xlim, .ylim = .cpl$ylim,
                 .aspect.ratio, type = character(0), cdfcut = 0.25,
                 shadow = 0.05, ..., check.erosion = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="panel.hexboxplot_+3A_x">x</code>, <code id="panel.hexboxplot_+3A_y">y</code></td>
<td>
<p>numeric vector or factor.</p>
</td></tr>
<tr><td><code id="panel.hexboxplot_+3A_xbins">xbins</code></td>
<td>
<p>the number of bins partitioning the range of xbnds.</p>
</td></tr>
<tr><td><code id="panel.hexboxplot_+3A_xbnds">xbnds</code>, <code id="panel.hexboxplot_+3A_ybnds">ybnds</code></td>
<td>
<p>horizontal and vertical limits of the binning
region in x or y units respectively; must be numeric vector of
length 2.</p>
</td></tr>
<tr><td><code id="panel.hexboxplot_+3A_.prelim">.prelim</code>, <code id="panel.hexboxplot_+3A_.cpl">.cpl</code>, <code id="panel.hexboxplot_+3A_.xlim">.xlim</code>, <code id="panel.hexboxplot_+3A_.ylim">.ylim</code>, <code id="panel.hexboxplot_+3A_.aspect.ratio">.aspect.ratio</code></td>
<td>
<p>for internal use.</p>
</td></tr>
<tr><td><code id="panel.hexboxplot_+3A_type">type</code></td>
<td>
<p>character vector controlling additional augmentation of
the display. A <code>"g"</code> in <code>type</code> adds a reference grid, an
<code>"hg"</code> adds a hexagonal grid.</p>
</td></tr>
<tr><td><code id="panel.hexboxplot_+3A_cdfcut">cdfcut</code></td>
<td>
<p>number in (0,1) indicating the confidence level for the
erosion limits.  See <code><a href="#topic+erode.hexbin">erode.hexbin</a></code> for more information.</p>
</td></tr>
<tr><td><code id="panel.hexboxplot_+3A_shadow">shadow</code></td>
<td>
<p>number in (0,1) indicating the confidence level for the
erosion limits of a boxplot shadow.  See <code><a href="#topic+erode.hexbin">erode.hexbin</a></code>
for more information.</p>
</td></tr>
<tr><td><code id="panel.hexboxplot_+3A_...">...</code></td>
<td>
<p>potential further arguments passed on.</p>
</td></tr>
<tr><td><code id="panel.hexboxplot_+3A_check.erosion">check.erosion</code></td>
<td>
<p>logical indicating only eroded points should be
used for <code>"erodebin"</code> objects; simply passed to
<code><a href="#topic+hcell2xy">hcell2xy</a></code>, see its documentation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>There is no return value from this function. The results are plotted on
the current active device.
</p>


<h3>Author(s)</h3>

<p>Nicholas Lewin-Koh <a href="mailto:nikko@hailmail.net">nikko@hailmail.net</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+hexbinplot">hexbinplot</a></code>, <code><a href="#topic+panel.hexgrid">panel.hexgrid</a></code>,
<code><a href="lattice.html#topic+panel.bwplot">panel.bwplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mixdata &lt;-
    data.frame(x = c(rnorm(5000),rnorm(5000,4,1.5)),
               y = rep(1:2, 5000))
hexbinplot(y ~ x, mixdata, panel = panel.hexboxplot)
</code></pre>

<hr>
<h2 id='panel.hexgrid'>Hexagonal grid for a lattice plot</h2><span id='topic+panel.hexgrid'></span>

<h3>Description</h3>

<p>A panel function to add a hexagonal grid to a lattice plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.hexgrid(h, border = grey(0.85))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="panel.hexgrid_+3A_h">h</code></td>
<td>
<p>an object of class <code>hexbin</code>.</p>
</td></tr>
<tr><td><code id="panel.hexgrid_+3A_border">border</code></td>
<td>
<p>a color for the hexagon border colors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>There is no return value from this function. The results are plotted on
the current active device.
</p>


<h3>Author(s)</h3>

<p>Nicholas Lewin-Koh <a href="mailto:nikko@hailmail.net">nikko@hailmail.net</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+hexbinplot">hexbinplot</a></code>, <code><a href="#topic+hexGraphPaper">hexGraphPaper</a></code></p>

<hr>
<h2 id='panel.hexloess'>Loess line for hexbin lattice plot</h2><span id='topic+panel.hexloess'></span>

<h3>Description</h3>

<p>A panel function to add a loess line to a hexbin lattice plot.
</p>
<p>This function contravened CRAN policy and is no longer available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.hexloess(bin, w = NULL, span = 2/3, degree = 1,
               family = c("symmetric", "gaussian"), evaluation = 50, 
               lwd = add.line$lwd, lty = add.line$lty,
               col, col.line = add.line$col, ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="panel.hexloess_+3A_bin">bin</code></td>
<td>
<p>an object of class <code>hexbin</code>.</p>
</td></tr>
<tr><td><code id="panel.hexloess_+3A_w">w</code></td>
<td>
<p>optional counts for object <code>bin</code>.</p>
</td></tr>
<tr><td><code id="panel.hexloess_+3A_span">span</code></td>
<td>
<p>smoothness parameter for <code>loess</code>.</p>
</td></tr>
<tr><td><code id="panel.hexloess_+3A_degree">degree</code></td>
<td>
<p>degree of local polynomial used.</p>
</td></tr>
<tr><td><code id="panel.hexloess_+3A_family">family</code></td>
<td>
<p>if <code>"gaussian"</code> fitting is by least-squares, and
if <code>"symmetric"</code> a re-descending M-estimator is used.</p>
</td></tr>
<tr><td><code id="panel.hexloess_+3A_evaluation">evaluation</code></td>
<td>
<p>number of points at which to evaluate the smooth curve.</p>
</td></tr>
<tr><td><code id="panel.hexloess_+3A_lwd">lwd</code></td>
<td>
<p>line weight graphical parameter.</p>
</td></tr>
<tr><td><code id="panel.hexloess_+3A_lty">lty</code></td>
<td>
<p>line type graphical parameter.</p>
</td></tr>
<tr><td><code id="panel.hexloess_+3A_col">col</code></td>
<td>
<p>same as <code>col.line</code>.</p>
</td></tr>
<tr><td><code id="panel.hexloess_+3A_col.line">col.line</code></td>
<td>
<p>line color graphical parameter.</p>
</td></tr>
<tr><td><code id="panel.hexloess_+3A_...">...</code></td>
<td>
<p>optional arguments to <code><a href="stats.html#topic+loess.control">loess.control</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>There is no return value from this function. The results are plotted on
the current active device.
</p>


<h3>Author(s)</h3>

<p>Nicholas Lewin-Koh <a href="mailto:nikko@hailmail.net">nikko@hailmail.net</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+hexbinplot">hexbinplot</a></code>, <code><a href="#topic+panel.hexgrid">panel.hexgrid</a></code>,
<code><a href="stats.html#topic+loess.smooth">loess.smooth</a></code>,
<code><a href="stats.html#topic+loess.control">loess.control</a></code>, 
<code><a href="lattice.html#topic+panel.functions">panel.loess</a></code>
</p>

<hr>
<h2 id='plotMAhex'>MA-plot using hexagon bins</h2><span id='topic+plotMAhex'></span>

<h3>Description</h3>

<p>Creates an MA-plot using hexagons with color/glyph coding for control spots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotMAhex(MA, array = 1, xlab = "A", ylab = "M",
          main = colnames(MA)[array], xlim = NULL, ylim = NULL,
          status = NULL, values, pch, col, cex, nbin = 40,
          zero.weights = FALSE, style = "colorscale", legend = 1.2,
          lcex = 1, minarea = 0.04, maxarea = 0.8, mincnt = 2,
          maxcnt = NULL, trans = NULL, inv = NULL, colorcut = NULL,
          border = NULL, density = NULL, pen = NULL,
          colramp = function(n) { LinGray(n, beg = 90, end = 15) },
          newpage = TRUE, type = c("p", "l", "n"),
          xaxt = c("s", "n"), yaxt = c("s", "n"),
          verbose = getOption("verbose"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotMAhex_+3A_ma">MA</code></td>
<td>
<p>an <code>RGList</code>, <code>MAList</code> or <code>MArrayLM</code> object,
or any list with components <code>M</code> containing log-ratios and
<code>A</code> containing average intensities. Alternatively a
<code>matrix</code>, <code>Affybatch</code> or <code>ExpressionSet</code> object.</p>
</td></tr>
<tr><td><code id="plotMAhex_+3A_array">array</code></td>
<td>
<p>integer giving the array to be plotted. Corresponds to
columns of <code>M</code> and <code>A</code>.</p>
</td></tr>
<tr><td><code id="plotMAhex_+3A_xlab">xlab</code>, <code id="plotMAhex_+3A_ylab">ylab</code>, <code id="plotMAhex_+3A_main">main</code></td>
<td>
<p>character strings giving label for x-axis,
y-axis or main tile of the plot.</p>
</td></tr>
<tr><td><code id="plotMAhex_+3A_xlim">xlim</code>, <code id="plotMAhex_+3A_ylim">ylim</code></td>
<td>
<p>numeric vectors of length 2 giving limits for x-axis
(or y-axis respectively), defaulting to min and max of the data.</p>
</td></tr>
<tr><td><code id="plotMAhex_+3A_status">status</code></td>
<td>
<p>character vector giving the control status of each spot
on the array, of same length as the number of rows of <code>MA$M</code>.
If omitted, all points are plotted in the default color, symbol and size.</p>
</td></tr>
<tr><td><code id="plotMAhex_+3A_values">values</code></td>
<td>
<p>character vector giving values of <code>status</code> to be
highlighted on the plot. Defaults to unique values of <code>status</code>.
Ignored if there is no <code>status</code> vector.</p>
</td></tr>
<tr><td><code id="plotMAhex_+3A_pch">pch</code></td>
<td>
<p>vector or list of plotting characters. Default to integer code 16.
Ignored is there is no <code>status</code> vector.</p>
</td></tr>
<tr><td><code id="plotMAhex_+3A_col">col</code></td>
<td>
<p>numeric or character vector of colors, of the same length
as <code>values</code>. Defaults to <code>1:length(values)</code>.  Ignored if
there is no <code>status</code> vector.</p>
</td></tr>
<tr><td><code id="plotMAhex_+3A_cex">cex</code></td>
<td>
<p>numeric vector of plot symbol expansions, of the the same
length as <code>values</code>.  Defaults to 0.2 for the most common status
value and 1 for the others. Ignored if there is no <code>status</code> vector.</p>
</td></tr>
<tr><td><code id="plotMAhex_+3A_nbin">nbin</code></td>
<td>
<p> Number of bins </p>
</td></tr>  
<tr><td><code id="plotMAhex_+3A_zero.weights">zero.weights</code></td>
<td>
<p>logical, should spots with zero or negative
weights be plotted?</p>
</td></tr>
<tr><td><code id="plotMAhex_+3A_style">style</code></td>
<td>
<p>string specifying the style of hexagon plot,
see <code><a href="#topic+grid.hexagons">grid.hexagons</a></code> for the possibilities.</p>
</td></tr>
<tr><td><code id="plotMAhex_+3A_legend">legend</code></td>
<td>
<p>numeric width of the legend in inches of <code>FALSE</code>.
In the latter case, or when <code>0</code>, no legend is not produced.</p>
</td></tr>
<tr><td><code id="plotMAhex_+3A_lcex">lcex</code></td>
<td>
<p>characters  expansion size for the text in the legend.</p>
</td></tr>
<tr><td><code id="plotMAhex_+3A_minarea">minarea</code></td>
<td>
<p>fraction of cell area for the lowest count.</p>
</td></tr>
<tr><td><code id="plotMAhex_+3A_maxarea">maxarea</code></td>
<td>
<p>fraction of the cell area for the largest count.</p>
</td></tr>
<tr><td><code id="plotMAhex_+3A_mincnt">mincnt</code></td>
<td>
<p>cells with fewer counts are ignored.</p>
</td></tr>
<tr><td><code id="plotMAhex_+3A_maxcnt">maxcnt</code></td>
<td>
<p>cells with more counts are ignored.</p>
</td></tr>
<tr><td><code id="plotMAhex_+3A_trans">trans</code></td>
<td>
<p><code><a href="base.html#topic+function">function</a></code> specifying a transformation for
the counts such as <code>sqrt</code>.</p>
</td></tr>
<tr><td><code id="plotMAhex_+3A_inv">inv</code></td>
<td>
<p>the inverse transformation of <code>trans</code>.</p>
</td></tr>
<tr><td><code id="plotMAhex_+3A_colorcut">colorcut</code></td>
<td>
<p>vector of values covering [0, 1] that determine
hexagon color class boundaries and hexagon legend size boundaries.
Alternatively, an integer (<code>&lt;= maxcnt</code>) specifying the
<em>number</em> of equispaced colorcut values in [0,1].</p>
</td></tr>
<tr><td><code id="plotMAhex_+3A_border">border</code>, <code id="plotMAhex_+3A_density">density</code>, <code id="plotMAhex_+3A_pen">pen</code></td>
<td>
<p>color for polygon borders and filling of
each hexagon drawn, passed to <code><a href="#topic+grid.hexagons">grid.hexagons</a></code>.</p>
</td></tr>
<tr><td><code id="plotMAhex_+3A_colramp">colramp</code></td>
<td>
<p>function accepting an integer <code>n</code> as an argument and
returning n colors.</p>
</td></tr>
<tr><td><code id="plotMAhex_+3A_newpage">newpage</code></td>
<td>
<p>should a new page start?</p>
</td></tr>
<tr><td><code id="plotMAhex_+3A_type">type</code>, <code id="plotMAhex_+3A_xaxt">xaxt</code>, <code id="plotMAhex_+3A_yaxt">yaxt</code></td>
<td>
<p>strings to be used (when set to <code>"n"</code>) for
suppressing the plotting of hexagon symbols, or the x- or y-axis,
respectively.</p>
</td></tr>
<tr><td><code id="plotMAhex_+3A_verbose">verbose</code></td>
<td>
<p>logical indicating if some diagnostic output should happen.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An MA-plot is a plot of log-intensity ratios (M-values) versus
log-intensity averages (A-values). If <code>MA</code> is an <code>RGList</code> or
<code>MAList</code> then this function produces an ordinary within-array
MA-plot. If <code>MA</code> is an <code>MArrayLM</code> object, then the plot is an
fitted model MA-plot in which the estimated coefficient is on the y-axis
and the average A-value is on the x-axis.
</p>
<p>If <code>MA</code> is a <code>matrix</code> or <code>ExpressionSet</code> object, then this
function produces a between-array MA-plot. In this case the A-values in
the plot are the average log-intensities across the arrays and the
M-values are the deviations of the log-intensities for the specified
array from the average. If there are more than five arrays, then the
average is computed robustly using medians. With five or fewer arrays,
it is computed by means.
</p>
<p>The <code>status</code> vector is intended to specify the control status of
each spot, for example &quot;gene&quot;, &quot;ratio control&quot;, &quot;house keeping gene&quot;,
&quot;buffer&quot; and so on. The vector is usually computed using the function
<code><a href="limma.html#topic+controlStatus">controlStatus</a></code> from package <span class="pkg">limma</span> and a
spot-types file.  However the function may be used to highlight any
subset of spots.
</p>
<p>The arguments <code>values</code>, <code>pch</code>, <code>col</code> and <code>cex</code>
can be included as attributes to <code>status</code> instead of being
passed as arguments to <code>plotMA</code>.
</p>
<p>See <code><a href="graphics.html#topic+points">points</a></code> for possible values for <code>pch</code>,
<code>col</code> and <code>cex</code>.
</p>


<h3>Value</h3>

<p>A plot is created on the current graphics device.
and a list with the following items is returned invisibly:
</p>
<table role = "presentation">
<tr><td><code>plot.vp</code></td>
<td>
<p>the <code><a href="#topic+hexViewport">hexViewport</a></code> constructed and used.</p>
</td></tr>
<tr><td><code>legend.vp</code></td>
<td>
<p>if a legend has been produced, its
<code><a href="grid.html#topic+viewport">viewport</a></code>.</p>
</td></tr>
<tr><td><code>hbin</code></td>
<td>
<p>a <code>hexbin</code> object built with A as the x coordinate
and M as the y coordinate.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nicholas Lewin-Koh, adapted from code by Gordon Smyth</p>


<h3>References</h3>

<p>See <a href="http://www.statsci.org/micrarra/refs/maplots.html">http://www.statsci.org/micrarra/refs/maplots.html</a></p>


<h3>See Also</h3>

<p><code><a href="limma.html#topic+plotma">plotMA</a></code> from package <span class="pkg">limma</span>,
and <code><a href="#topic+gplot.hexbin">gplot.hexbin</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  if(require(marray)){ 
    data(swirl)
    hb &lt;- plotMAhex(swirl[,1],newpage=FALSE,
                    main = "M vs A plot with hexagons", legend=0)
    hexVP.abline(hb$plot.vp,h=0,col=gray(.6))
    hexMA.loess(hb)
  }
</code></pre>

<hr>
<h2 id='pushHexport'>Push a Hexagon Viewport (&quot;hexVP&quot;)</h2><span id='topic+pushHexport'></span>

<h3>Description</h3>

<p>Push a Hexagon Viewport (<code>"hexVP"</code>, see <a href="#topic+hexVP-class">hexVP-class</a>) on to
the tree of (grid) viewports, calling
<code><a href="grid.html#topic+viewports">pushViewport</a></code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pushHexport(hvp, clip = "off")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pushHexport_+3A_hvp">hvp</code></td>
<td>
<p>a hexagon viewport, i.e., an object of class
<code>"hexVP"</code>, see <a href="#topic+hexVP-class">hexVP-class</a>, typically produced by
<code><a href="#topic+hexViewport">hexViewport</a>(..)</code>.</p>
</td></tr>
<tr><td><code id="pushHexport_+3A_clip">clip</code></td>
<td>
<p>which viewport to push, either 'on' or 'off' are the
allowed arguments, see details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A hexagon viewport (<code>"hexVP"</code>) object has slots for two replicate
viewports one with clipping turned on and one with clipping off.  This
allows toggling the clipping option.
</p>


<h3>See Also</h3>

<p>the underlying <code><a href="grid.html#topic+viewports">pushViewport</a></code> from the
<span class="pkg">grid</span> package.
</p>

<hr>
<h2 id='smooth.hexbin'>Hexagon Bin Smoothing</h2><span id='topic+smooth.hexbin'></span><span id='topic+smoothbin-class'></span>

<h3>Description</h3>

<p>Given a <code>"hexbin"</code> (hexagon bin) object, compute a discrete
kernel smoother that covers seven cells, namely a center cell and its
six neighbors.  With two iterations the kernel effectively covers
1+6+12=19 cells.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth.hexbin(bin, wts=c(48,4,1))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smooth.hexbin_+3A_bin">bin</code></td>
<td>
<p>object of class <code>"hexbin"</code>, typically resulting from
<code><a href="#topic+hexbin">hexbin</a>()</code> or <code><a href="#topic+erode+2Chexbin-method">erode,hexbin-method</a></code>.</p>
</td></tr>
<tr><td><code id="smooth.hexbin_+3A_wts">wts</code></td>
<td>
<p>numeric vector of length 3 for relative weights of the
center, the six neighbor cells, and twelve second neighbors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This discrete kernel smoother uses the center cell, immediate
neighbors and second neighbors to smooth the counts.  The counts for
each resulting cell is a linear combination of previous cell counts
and weights. The weights are
</p>

<table>
<tr>
 <td style="text-align: left;">
    1 center cell,       </td><td style="text-align: left;"> weight = wts[1]</td>
</tr>
<tr>
 <td style="text-align: left;">
    6 immediate neighbors</td><td style="text-align: left;"> weight = wts[2]</td>
</tr>
<tr>
 <td style="text-align: left;">
    12 second neighbors  </td><td style="text-align: left;">  weight =wts[3]</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p>If a cell, its immediate and second neighbors all have a value of
<code>max(cnt)</code>, the new maximum count would be
<code>max(cnt)*sum(wts)</code>.  It is possible for the counts to overflow.
</p>
<p>The domain for cells with positive counts increases.  The hexbin
slots  <code>xbins</code>, <code>xbnds</code>, <code>ybnds</code>, and <code>dimen</code> all
reflect this increase.
Note that usually <code>dimen[2] = xbins+1</code>.
</p>
<p>The intent was to provide a fast, iterated, immediate neighbor smoother.
However, the current hexbin plotting routines only support shifting 
even numbered rows to the right.  Future work can
</p>
<p>(1) add a shift indicator to hexbin objects that indicates left or
right shifting.<br />
(2) generalize plot.hexbin() and hexagons()<br />
(3) provide an iterated kernel.<br />
</p>
<p>With <code>wts[3]=0</code>, the smoother only uses the immediate neighbors.
With a shift indicator the domain could increase by 2 rows (one bottom
and on top) and 2 columns (one left and one right).  However the current
implementation increases the domain by 4 rows and 4 columns, thus
reducing plotting resolution.
</p>


<h3>Value</h3>

<p>an object of class <code>"smoothbin"</code>, extending class
<code>"hexbin"</code>, see <code><a href="#topic+hexbin">hexbin</a></code>.
The object includes the additional slot <code>wts</code>.
</p>


<h3>References</h3>

<p>see <code><a href="#topic+grid.hexagons">grid.hexagons</a></code> and <code><a href="#topic+hexbin">hexbin</a></code>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+hexbin">hexbin</a></code>, <code><a href="#topic+erode.hexbin">erode.hexbin</a></code>, 
<code><a href="#topic+hcell2xy">hcell2xy</a></code>,
<code><a href="#topic+gplot.hexbin">gplot.hexbin</a></code>, <code><a href="#topic+hboxplot">hboxplot</a></code>,

<code><a href="#topic+grid.hexagons">grid.hexagons</a></code>, <code><a href="#topic+grid.hexlegend">grid.hexlegend</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(10000)
y &lt;- rnorm(10000)
bin &lt;- hexbin(x,y)
# show the smooth counts in gray level
smbin  &lt;- smooth.hexbin(bin)
plot(smbin, main = "smooth.hexbin(.)")

# Compare the smooth and the origin
smbin1 &lt;- smbin
smbin1@count &lt;- as.integer(ceiling(smbin@count/sum(smbin@wts)))
plot(smbin1)
smbin2 &lt;- smooth.hexbin(bin,wts=c(1,0,0))  # expand the domain for comparability
plot(smbin2)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
