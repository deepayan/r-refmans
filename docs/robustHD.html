<!DOCTYPE html><html lang="en"><head><title>Help for package robustHD</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {robustHD}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#robustHD-package'><p>Robust Methods for High-Dimensional Data</p></a></li>
<li><a href='#AIC.seqModel'><p>Information criteria for a sequence of regression models</p></a></li>
<li><a href='#coef.seqModel'><p>Extract coefficients from a sequence of regression models</p></a></li>
<li><a href='#coefPlot'><p>Coefficient plot of a sequence of regression models</p></a></li>
<li><a href='#corHuber'><p>Robust correlation based on winsorization</p></a></li>
<li><a href='#critPlot'><p>Optimality criterion plot of a sequence of regression models</p></a></li>
<li><a href='#diagnosticPlot'><p>Diagnostic plots for a sequence of regression models</p></a></li>
<li><a href='#fitted.seqModel'><p>Extract fitted values from a sequence of regression models</p></a></li>
<li><a href='#getScale'><p>Extract the residual scale of a robust regression model</p></a></li>
<li><a href='#grplars'><p>(Robust) groupwise least angle regression</p></a></li>
<li><a href='#lambda0'><p>Penalty parameter for sparse LTS regression</p></a></li>
<li><a href='#nci60'><p>NCI-60 cancer cell panel</p></a></li>
<li><a href='#partialOrder'><p>Find partial order of smallest or largest values</p></a></li>
<li><a href='#perry.seqModel'><p>Resampling-based prediction error for a sequential regression model</p></a></li>
<li><a href='#plot.seqModel'><p>Plot a sequence of regression models</p></a></li>
<li><a href='#predict.seqModel'><p>Predict from a sequence of regression models</p></a></li>
<li><a href='#residuals.seqModel'><p>Extract residuals from a sequence of regression models</p></a></li>
<li><a href='#rlars'><p>Robust least angle regression</p></a></li>
<li><a href='#rstandard.seqModel'><p>Extract standardized residuals from a sequence of regression models</p></a></li>
<li><a href='#setupCoefPlot'><p>Set up a coefficient plot of a sequence of regression models</p></a></li>
<li><a href='#setupCritPlot'><p>Set up an optimality criterion plot of a sequence of regression models</p></a></li>
<li><a href='#setupDiagnosticPlot'><p>Set up a diagnostic plot for a sequence of regression models</p></a></li>
<li><a href='#sparseLTS'><p>Sparse least trimmed squares regression</p></a></li>
<li><a href='#standardize'><p>Data standardization</p></a></li>
<li><a href='#TopGear'><p>Top Gear car data</p></a></li>
<li><a href='#tsBlocks'><p>Construct predictor blocks for time series models</p></a></li>
<li><a href='#tslars'><p>(Robust) least angle regression for time series data</p></a></li>
<li><a href='#tslarsP'><p>(Robust) least angle regression for time series data with fixed lag length</p></a></li>
<li><a href='#weights.sparseLTS'><p>Extract outlier weights from sparse LTS regression models</p></a></li>
<li><a href='#winsorize'><p>Data cleaning by winsorization</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Robust Methods for High-Dimensional Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.8.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-06-30</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), ggplot2 (&ge; 0.9.2), perry (&ge; 0.3.0), robustbase
(&ge; 0.9-5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, Rcpp (&ge; 0.9.10), grDevices, parallel, stats, utils</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp (&ge; 0.9.10), RcppArmadillo (&ge; 0.3.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>lars, mvtnorm, testthat</td>
</tr>
<tr>
<td>Description:</td>
<td>Robust methods for high-dimensional data, in particular linear
    model selection techniques based on least angle regression and sparse
    regression. Specifically, the package implements robust least angle 
    regression (Khan, Van Aelst &amp; Zamar, 2007; &lt;<a href="https://doi.org/10.1198%2F016214507000000950">doi:10.1198/016214507000000950</a>&gt;), 
    (robust) groupwise least angle regression (Alfons, Croux &amp; Gelper, 2016; 
    &lt;<a href="https://doi.org/10.1016%2Fj.csda.2015.02.007">doi:10.1016/j.csda.2015.02.007</a>&gt;), and sparse least trimmed squares 
    regression (Alfons, Croux &amp; Gelper, 2013; &lt;<a href="https://doi.org/10.1214%2F12-AOAS575">doi:10.1214/12-AOAS575</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/aalfons/robustHD">https://github.com/aalfons/robustHD</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/aalfons/robustHD/issues">https://github.com/aalfons/robustHD/issues</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Author:</td>
<td>Andreas Alfons <a href="https://orcid.org/0000-0002-2513-3788"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Dirk Eddelbuettel [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andreas Alfons &lt;alfons@ese.eur.nl&gt;</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-30 19:56:06 UTC; alfons</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-30 20:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='robustHD-package'>Robust Methods for High-Dimensional Data</h2><span id='topic+robustHD'></span><span id='topic+robustHD-package'></span>

<h3>Description</h3>

<p>Robust methods for high-dimensional data, in particular linear
    model selection techniques based on least angle regression and sparse
    regression. Specifically, the package implements robust least angle 
    regression (Khan, Van Aelst &amp; Zamar, 2007; &lt;doi:10.1198/016214507000000950&gt;), 
    (robust) groupwise least angle regression (Alfons, Croux &amp; Gelper, 2016; 
    &lt;doi:10.1016/j.csda.2015.02.007&gt;), and sparse least trimmed squares 
    regression (Alfons, Croux &amp; Gelper, 2013; &lt;doi:10.1214/12-AOAS575&gt;).
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> robustHD</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Robust Methods for High-Dimensional Data</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.8.1</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-06-30</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 3.5.0),
ggplot2 (&gt;= 0.9.2),
perry (&gt;= 0.3.0),
robustbase (&gt;= 0.9-5)</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> MASS,
Rcpp (&gt;= 0.9.10),
grDevices,
parallel,
stats,
utils</td>
</tr>
<tr>
 <td style="text-align: left;">
LinkingTo: </td><td style="text-align: left;"> Rcpp (&gt;= 0.9.10), RcppArmadillo (&gt;= 0.3.0)</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> lars,
mvtnorm,
testthat</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Robust methods for high-dimensional data, in particular linear
    model selection techniques based on least angle regression and sparse
    regression. Specifically, the package implements robust least angle 
    regression (Khan, Van Aelst &amp; Zamar, 2007; &lt;doi:10.1198/016214507000000950&gt;), 
    (robust) groupwise least angle regression (Alfons, Croux &amp; Gelper, 2016; 
    &lt;doi:10.1016/j.csda.2015.02.007&gt;), and sparse least trimmed squares 
    regression (Alfons, Croux &amp; Gelper, 2013; &lt;doi:10.1214/12-AOAS575&gt;).</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://github.com/aalfons/robustHD</td>
</tr>
<tr>
 <td style="text-align: left;">
BugReports: </td><td style="text-align: left;"> https://github.com/aalfons/robustHD/issues</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> 
    c(person("Andreas", "Alfons",
             email = "alfons@ese.eur.nl",
             role = c("aut", "cre"),
             comment = c(ORCID = "0000-0002-2513-3788")),
      person("Dirk", "Eddelbuettel", role = "ctb"))</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Andreas Alfons [aut, cre] (&lt;https://orcid.org/0000-0002-2513-3788&gt;), Dirk Eddelbuettel [ctb]</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Andreas Alfons &lt;alfons@ese.eur.nl&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Encoding: </td><td style="text-align: left;"> UTF-8</td>
</tr>
<tr>
 <td style="text-align: left;">
RoxygenNote: </td><td style="text-align: left;"> 7.3.1</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
AIC.seqModel            Information criteria for a sequence of
                        regression models
TopGear                 Top Gear car data
coef.seqModel           Extract coefficients from a sequence of
                        regression models
coefPlot                Coefficient plot of a sequence of regression
                        models
corHuber                Robust correlation based on winsorization
critPlot                Optimality criterion plot of a sequence of
                        regression models
diagnosticPlot          Diagnostic plots for a sequence of regression
                        models
fitted.seqModel         Extract fitted values from a sequence of
                        regression models
getScale                Extract the residual scale of a robust
                        regression model
grplars                 (Robust) groupwise least angle regression
lambda0                 Penalty parameter for sparse LTS regression
nci60                   NCI-60 cancer cell panel
partialOrder            Find partial order of smallest or largest
                        values
perry.seqModel          Resampling-based prediction error for a
                        sequential regression model
plot.seqModel           Plot a sequence of regression models
predict.seqModel        Predict from a sequence of regression models
residuals.seqModel      Extract residuals from a sequence of regression
                        models
rlars                   Robust least angle regression
robustHD-package        Robust Methods for High-Dimensional Data
rstandard.seqModel      Extract standardized residuals from a sequence
                        of regression models
setupCoefPlot           Set up a coefficient plot of a sequence of
                        regression models
setupCritPlot           Set up an optimality criterion plot of a
                        sequence of regression models
setupDiagnosticPlot     Set up a diagnostic plot for a sequence of
                        regression models
sparseLTS               Sparse least trimmed squares regression
standardize             Data standardization
tsBlocks                Construct predictor blocks for time series
                        models
tslars                  (Robust) least angle regression for time series
                        data
tslarsP                 (Robust) least angle regression for time series
                        data with fixed lag length
weights.sparseLTS       Extract outlier weights from sparse LTS
                        regression models
winsorize               Data cleaning by winsorization
</pre>


<h3>Author(s)</h3>

<p>Andreas Alfons [aut, cre] (&lt;https://orcid.org/0000-0002-2513-3788&gt;), Dirk Eddelbuettel [ctb]
</p>
<p>Maintainer: Andreas Alfons &lt;alfons@ese.eur.nl&gt;
</p>


<h3>References</h3>

<p>Alfons (2021) <span class="pkg">robustHD</span>: An <span class="rlang"><b>R</b></span> package for robust regression with
high-dimensional data. <em>Journal of Open Source Software</em>, <b>6</b>(67),
3786. <a href="https://doi.org/10.21105/joss.03786">doi:10.21105/joss.03786</a>.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/aalfons/robustHD">https://github.com/aalfons/robustHD</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/aalfons/robustHD/issues">https://github.com/aalfons/robustHD/issues</a>
</p>
</li></ul>


<hr>
<h2 id='AIC.seqModel'>Information criteria for a sequence of regression models</h2><span id='topic+AIC.seqModel'></span><span id='topic+AIC.sparseLTS'></span><span id='topic+BIC.seqModel'></span><span id='topic+BIC.sparseLTS'></span>

<h3>Description</h3>

<p>Compute the Akaike or Bayes information criterion for for a sequence of
regression models, such as submodels along a robust least angle regression
sequence, or sparse least trimmed squares regression models for a grid of
values for the penalty parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'seqModel'
AIC(object, ..., k = 2)

## S3 method for class 'sparseLTS'
AIC(object, ..., fit = c("reweighted", "raw", "both"), k = 2)

## S3 method for class 'seqModel'
BIC(object, ...)

## S3 method for class 'sparseLTS'
BIC(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AIC.seqModel_+3A_object">object</code></td>
<td>
<p>the model fit for which to compute the information criterion.</p>
</td></tr>
<tr><td><code id="AIC.seqModel_+3A_...">...</code></td>
<td>
<p>for the <code>BIC</code> method, additional arguments to be passed
down to the <code>AIC</code> method.  For the <code>AIC</code> method, additional
arguments are currently ignored.</p>
</td></tr>
<tr><td><code id="AIC.seqModel_+3A_k">k</code></td>
<td>
<p>a numeric value giving the penalty per parameter to be used.  The
default is to use <code class="reqn">2</code> as in the classical definition of the AIC.</p>
</td></tr>
<tr><td><code id="AIC.seqModel_+3A_fit">fit</code></td>
<td>
<p>a character string specifying for which fit to compute the
information criterion.  Possible values are <code>"reweighted"</code> (the
default) for the information criterion of the reweighted fit, <code>"raw"</code>
for the information criterion of the raw fit, or <code>"both"</code> for the
information criteria of both fits.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The information criteria are computed as
<code class="reqn">n (\log(2 \pi) + 1 + \log(\hat{\sigma}^2)) + df k</code>,
where <code class="reqn">n</code> denotes the number of observations, <code class="reqn">\hat{\sigma}</code>
is the robust residual scale estimate, <code class="reqn">df</code> is the number of nonzero
coefficient estimates, and <code class="reqn">k</code> is penalty per parameter.  The usual
definition of the AIC uses <code class="reqn">k = 2</code>, whereas the BIC uses
<code class="reqn">k = \log(n)</code>.  Consequently, the former is used as the
default penalty of the <code>AIC</code> method, whereas the <code>BIC</code> method calls
the <code>AIC</code> method with the latter penalty.
</p>


<h3>Value</h3>

<p>A numeric vector or matrix giving the information criteria for the requested
model fits.
</p>


<h3>Note</h3>

<p>Computing information criteria for several objects supplied via the
<code>...</code> argument (as for the default methods of <code><a href="stats.html#topic+AIC">AIC</a></code>
and <code>BIC</code>) is currently not implemented.
</p>


<h3>Author(s)</h3>

<p>Andreas Alfons
</p>


<h3>References</h3>

<p>Akaike, H. (1970) Statistical predictor identification. <em>Annals of the
Institute of Statistical Mathematics</em>, <b>22</b>(2), 203&ndash;217.
</p>
<p>Schwarz, G. (1978) Estimating the dimension of a model. <em>The Annals of
Statistics</em>, <b>6</b>(2), 461&ndash;464.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+AIC">AIC</a></code>, <code><a href="#topic+rlars">rlars</a></code>,
<code><a href="#topic+sparseLTS">sparseLTS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate data
# example is not high-dimensional to keep computation time low
library("mvtnorm")
set.seed(1234)  # for reproducibility
n &lt;- 100  # number of observations
p &lt;- 25   # number of variables
beta &lt;- rep.int(c(1, 0), c(5, p-5))  # coefficients
sigma &lt;- 0.5      # controls signal-to-noise ratio
epsilon &lt;- 0.1    # contamination level
Sigma &lt;- 0.5^t(sapply(1:p, function(i, j) abs(i-j), 1:p))
x &lt;- rmvnorm(n, sigma=Sigma)    # predictor matrix
e &lt;- rnorm(n)                   # error terms
i &lt;- 1:ceiling(epsilon*n)       # observations to be contaminated
e[i] &lt;- e[i] + 5                # vertical outliers
y &lt;- c(x %*% beta + sigma * e)  # response
x[i,] &lt;- x[i,] + 5              # bad leverage points


## robust LARS
# fit model
fitRlars &lt;- rlars(x, y, sMax = 10)
# compute AIC and BIC
AIC(fitRlars)
BIC(fitRlars)


## fit sparse LTS model over a grid of values for lambda
frac &lt;- seq(0.2, 0.05, by = -0.05)
fitSparseLTS &lt;- sparseLTS(x, y, lambda = frac, mode = "fraction")
# compute AIC and BIC
AIC(fitSparseLTS)
BIC(fitSparseLTS)
</code></pre>

<hr>
<h2 id='coef.seqModel'>Extract coefficients from a sequence of regression models</h2><span id='topic+coef.seqModel'></span><span id='topic+coef.rlars'></span><span id='topic+coef.grplars'></span><span id='topic+coef.tslarsP'></span><span id='topic+coef.tslars'></span><span id='topic+coef.perrySeqModel'></span><span id='topic+coef.sparseLTS'></span>

<h3>Description</h3>

<p>Extract coefficients from a sequence of regression models, such as submodels
along a robust or groupwise least angle regression sequence, or sparse least
trimmed squares regression models for a grid of values for the penalty
parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'seqModel'
coef(object, s = NA, zeros = TRUE, drop = !is.null(s), ...)

## S3 method for class 'tslars'
coef(object, p, ...)

## S3 method for class 'perrySeqModel'
coef(object, ...)

## S3 method for class 'sparseLTS'
coef(
  object,
  s = NA,
  fit = c("reweighted", "raw", "both"),
  zeros = TRUE,
  drop = !is.null(s),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.seqModel_+3A_object">object</code></td>
<td>
<p>the model fit from which to extract coefficients.</p>
</td></tr>
<tr><td><code id="coef.seqModel_+3A_s">s</code></td>
<td>
<p>for the <code>"seqModel"</code> method, an integer vector giving
the steps of the submodels for which to extract coefficients (the default
is to use the optimal submodel).  For the <code>"sparseLTS"</code> method, an
integer vector giving the indices of the models for which to extract
coefficients.  If <code>fit</code> is <code>"both"</code>, this can be a list with two
components, with the first component giving the indices of the reweighted
fits and the second the indices of the raw fits.  The default is to use the
optimal model for each of the requested estimators.  Note that the optimal
models may not correspond to the same value of the penalty parameter for the
reweighted and the raw estimator.</p>
</td></tr>
<tr><td><code id="coef.seqModel_+3A_zeros">zeros</code></td>
<td>
<p>a logical indicating whether to keep zero coefficients
(<code>TRUE</code>, the default) or to omit them (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="coef.seqModel_+3A_drop">drop</code></td>
<td>
<p>a logical indicating whether to reduce the dimension to a
vector in case of only one submodel.</p>
</td></tr>
<tr><td><code id="coef.seqModel_+3A_...">...</code></td>
<td>
<p>for the <code>"tslars"</code> method, additional arguments to be
passed down to the <code>"seqModel"</code> method.  For the other methods,
additional arguments are currently ignored.</p>
</td></tr>
<tr><td><code id="coef.seqModel_+3A_p">p</code></td>
<td>
<p>an integer giving the lag length for which to extract coefficients
(the default is to use the optimal lag length).</p>
</td></tr>
<tr><td><code id="coef.seqModel_+3A_fit">fit</code></td>
<td>
<p>a character string specifying which coefficients to extract.
Possible values are <code>"reweighted"</code> (the default) for the coefficients
from the reweighted estimator, <code>"raw"</code> for the coefficients from the
raw estimator, or <code>"both"</code> for the coefficients from both estimators.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector or matrix containing the requested regression coefficients.
</p>


<h3>Author(s)</h3>

<p>Andreas Alfons
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+coef">coef</a></code>, <code><a href="#topic+rlars">rlars</a></code>,
<code><a href="#topic+grplars">grplars</a></code>, <code><a href="#topic+rgrplars">rgrplars</a></code>, <code><a href="#topic+tslarsP">tslarsP</a></code>,
<code><a href="#topic+rtslarsP">rtslarsP</a></code>, <code><a href="#topic+tslars">tslars</a></code>, <code><a href="#topic+rtslars">rtslars</a></code>,
<code><a href="#topic+sparseLTS">sparseLTS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate data
# example is not high-dimensional to keep computation time low
library("mvtnorm")
set.seed(1234)  # for reproducibility
n &lt;- 100  # number of observations
p &lt;- 25   # number of variables
beta &lt;- rep.int(c(1, 0), c(5, p-5))  # coefficients
sigma &lt;- 0.5      # controls signal-to-noise ratio
epsilon &lt;- 0.1    # contamination level
Sigma &lt;- 0.5^t(sapply(1:p, function(i, j) abs(i-j), 1:p))
x &lt;- rmvnorm(n, sigma=Sigma)    # predictor matrix
e &lt;- rnorm(n)                   # error terms
i &lt;- 1:ceiling(epsilon*n)       # observations to be contaminated
e[i] &lt;- e[i] + 5                # vertical outliers
y &lt;- c(x %*% beta + sigma * e)  # response
x[i,] &lt;- x[i,] + 5              # bad leverage points


## robust LARS
# fit model
fitRlars &lt;- rlars(x, y, sMax = 10)
# extract coefficients
coef(fitRlars, zeros = FALSE)
coef(fitRlars, s = 1:5, zeros = FALSE)


## sparse LTS over a grid of values for lambda
# fit model
frac &lt;- seq(0.2, 0.05, by = -0.05)
fitSparseLTS &lt;- sparseLTS(x, y, lambda = frac, mode = "fraction")
# extract coefficients
coef(fitSparseLTS, zeros = FALSE)
coef(fitSparseLTS, fit = "both", zeros = FALSE)
coef(fitSparseLTS, s = NULL, zeros = FALSE)
coef(fitSparseLTS, fit = "both", s = NULL, zeros = FALSE)
</code></pre>

<hr>
<h2 id='coefPlot'>Coefficient plot of a sequence of regression models</h2><span id='topic+coefPlot'></span><span id='topic+coefPlot.rlars'></span><span id='topic+coefPlot.grplars'></span><span id='topic+coefPlot.tslarsP'></span><span id='topic+coefPlot.seqModel'></span><span id='topic+coefPlot.tslars'></span><span id='topic+coefPlot.sparseLTS'></span><span id='topic+coefPlot.setupCoefPlot'></span>

<h3>Description</h3>

<p>Produce a plot of the coefficients from a sequence of regression models,
such as submodels along a robust or groupwise least angle regression
sequence, or sparse least trimmed squares regression models for a grid of
values for the penalty parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coefPlot(object, ...)

## S3 method for class 'seqModel'
coefPlot(object, zeros = FALSE, labels = NULL, ...)

## S3 method for class 'tslars'
coefPlot(object, p, zeros = FALSE, labels = NULL, ...)

## S3 method for class 'sparseLTS'
coefPlot(
  object,
  fit = c("reweighted", "raw", "both"),
  zeros = FALSE,
  labels = NULL,
  ...
)

## S3 method for class 'setupCoefPlot'
coefPlot(
  object,
  abscissa = NULL,
  size = c(0.5, 2, 4),
  offset = 1,
  facets = object$facets,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coefPlot_+3A_object">object</code></td>
<td>
<p>the model fit to be plotted.</p>
</td></tr>
<tr><td><code id="coefPlot_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed down, eventually to
<code><a href="ggplot2.html#topic+geom_line">geom_line</a></code> and <code><a href="ggplot2.html#topic+geom_point">geom_point</a></code>.</p>
</td></tr>
<tr><td><code id="coefPlot_+3A_zeros">zeros</code></td>
<td>
<p>a logical indicating whether predictors that never enter the
model and thus have zero coefficients should be included in the plot
(<code>TRUE</code>) or omitted (<code>FALSE</code>, the default).  This is useful if the
number of predictors is much larger than the number of observations, in
which case many coefficients are never nonzero.</p>
</td></tr>
<tr><td><code id="coefPlot_+3A_labels">labels</code></td>
<td>
<p>an optional character vector containing labels for the
predictors.  Plotting labels can be suppressed by setting this to
<code>NA</code>.</p>
</td></tr>
<tr><td><code id="coefPlot_+3A_p">p</code></td>
<td>
<p>an integer giving the lag length for which to produce the plot
(the default is to use the optimal lag length).</p>
</td></tr>
<tr><td><code id="coefPlot_+3A_fit">fit</code></td>
<td>
<p>a character string specifying for which estimator to produce the
plot.  Possible values are <code>"reweighted"</code> (the default) for the
reweighted fits, <code>"raw"</code> for the raw fits, or <code>"both"</code> for both
estimators.</p>
</td></tr>
<tr><td><code id="coefPlot_+3A_abscissa">abscissa</code></td>
<td>
<p>a character string specifying what to plot on the
<code class="reqn">x</code>-axis.  For objects inheriting from class <code>"seqModel"</code>, possible
values are <code>"step"</code> for the step number (the default), or <code>"df"</code>
for the degrees of freedom.  For <code>"sparseLTS"</code> objects, possible values
are <code>"lambda"</code> for the value of the penalty parameter (the default), or
<code>"step"</code> for the step number.</p>
</td></tr>
<tr><td><code id="coefPlot_+3A_size">size</code></td>
<td>
<p>a numeric vector of length three giving the line width, the
point size and the label size, respectively.</p>
</td></tr>
<tr><td><code id="coefPlot_+3A_offset">offset</code></td>
<td>
<p>an integer giving the offset of the labels from the
corresponding coefficient values from the last step (i.e., the number of
blank characters to be prepended to the label).</p>
</td></tr>
<tr><td><code id="coefPlot_+3A_facets">facets</code></td>
<td>
<p>a faceting formula to override the default behavior.  If
supplied, <code><a href="ggplot2.html#topic+facet_wrap">facet_wrap</a></code> or
<code><a href="ggplot2.html#topic+facet_grid">facet_grid</a></code> is called depending on whether the formula
is one-sided or two-sided.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"ggplot"</code> (see <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>).
</p>


<h3>Author(s)</h3>

<p>Andreas Alfons
</p>


<h3>See Also</h3>

<p><code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>, <code><a href="#topic+rlars">rlars</a></code>,
<code><a href="#topic+grplars">grplars</a></code>, <code><a href="#topic+rgrplars">rgrplars</a></code>, <code><a href="#topic+tslarsP">tslarsP</a></code>,
<code><a href="#topic+rtslarsP">rtslarsP</a></code>, <code><a href="#topic+tslars">tslars</a></code>, <code><a href="#topic+rtslars">rtslars</a></code>,
<code><a href="#topic+sparseLTS">sparseLTS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate data
# example is not high-dimensional to keep computation time low
library("mvtnorm")
set.seed(1234)  # for reproducibility
n &lt;- 100  # number of observations
p &lt;- 25   # number of variables
beta &lt;- rep.int(c(1, 0), c(5, p-5))  # coefficients
sigma &lt;- 0.5      # controls signal-to-noise ratio
epsilon &lt;- 0.1    # contamination level
Sigma &lt;- 0.5^t(sapply(1:p, function(i, j) abs(i-j), 1:p))
x &lt;- rmvnorm(n, sigma=Sigma)    # predictor matrix
e &lt;- rnorm(n)                   # error terms
i &lt;- 1:ceiling(epsilon*n)       # observations to be contaminated
e[i] &lt;- e[i] + 5                # vertical outliers
y &lt;- c(x %*% beta + sigma * e)  # response
x[i,] &lt;- x[i,] + 5              # bad leverage points


## robust LARS
# fit model
fitRlars &lt;- rlars(x, y, sMax = 10)
# create plot
coefPlot(fitRlars)


## sparse LTS over a grid of values for lambda
# fit model
frac &lt;- seq(0.2, 0.05, by = -0.05)
fitSparseLTS &lt;- sparseLTS(x, y, lambda = frac, mode = "fraction")
# create plot
coefPlot(fitSparseLTS)
coefPlot(fitSparseLTS, fit = "both")
</code></pre>

<hr>
<h2 id='corHuber'>Robust correlation based on winsorization</h2><span id='topic+corHuber'></span>

<h3>Description</h3>

<p>Compute a robust correlation estimate based on winsorization, i.e., by
shrinking outlying observations to the border of the main part of the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corHuber(
  x,
  y,
  type = c("bivariate", "adjusted", "univariate"),
  standardized = FALSE,
  centerFun = median,
  scaleFun = mad,
  const = 2,
  prob = 0.95,
  tol = .Machine$double.eps^0.5,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="corHuber_+3A_x">x</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
<tr><td><code id="corHuber_+3A_y">y</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
<tr><td><code id="corHuber_+3A_type">type</code></td>
<td>
<p>a character string specifying the type of winsorization to be
used.  Possible values are <code>"univariate"</code> for univariate winsorization,
<code>"adjusted"</code> for adjusted univariate winsorization, or
<code>"bivariate"</code> for bivariate winsorization.</p>
</td></tr>
<tr><td><code id="corHuber_+3A_standardized">standardized</code></td>
<td>
<p>a logical indicating whether the data are already
robustly standardized.</p>
</td></tr>
<tr><td><code id="corHuber_+3A_centerfun">centerFun</code></td>
<td>
<p>a function to compute a robust estimate for the center to
be used for robust standardization (defaults to
<code><a href="stats.html#topic+median">median</a></code>).  Ignored if <code>standardized</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="corHuber_+3A_scalefun">scaleFun</code></td>
<td>
<p>a function to compute a robust estimate for the scale to
be used for robust standardization (defaults to <code><a href="stats.html#topic+mad">mad</a></code>).
Ignored if <code>standardized</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="corHuber_+3A_const">const</code></td>
<td>
<p>numeric; tuning constant to be used in univariate or adjusted
univariate winsorization (defaults to 2).</p>
</td></tr>
<tr><td><code id="corHuber_+3A_prob">prob</code></td>
<td>
<p>numeric; probability for the quantile of the
<code class="reqn">\chi^{2}</code> distribution to be used in bivariate
winsorization (defaults to 0.95).</p>
</td></tr>
<tr><td><code id="corHuber_+3A_tol">tol</code></td>
<td>
<p>a small positive numeric value.  This is used in bivariate
winsorization to determine whether the initial estimate from adjusted
univariate winsorization is close to 1 in absolute value.  In this case,
bivariate winsorization would fail since the points form almost a straight
line, and the initial estimate is returned.</p>
</td></tr>
<tr><td><code id="corHuber_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to
<code><a href="#topic+standardize">robStandardize</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The borders of the main part of the data are defined on the scale of the
robustly standardized data.  In univariate winsorization, the borders for
each variable are given by <code class="reqn">+/-</code><code>const</code>, thus a symmetric
distribution is assumed.  In adjusted univariate winsorization, the borders
for the two diagonally opposing quadrants containing the minority of the
data are shrunken by a factor that depends on the ratio between the number of
observations in the major and minor quadrants.  It is thus possible to
better account for the bivariate structure of the data while maintaining
fast computation.  In bivariate winsorization, a bivariate normal
distribution is assumed and the data are shrunken towards the boundary of a
tolerance ellipse with coverage probability <code>prob</code>.  The boundary of
this ellipse is thereby given by all points that have a squared Mahalanobis
distance equal to the quantile of the <code class="reqn">\chi^{2}</code>
distribution given by <code>prob</code>.  Furthermore, the initial correlation
matrix required for the Mahalanobis distances is computed based on adjusted
univariate winsorization.
</p>


<h3>Value</h3>

<p>The robust correlation estimate.
</p>


<h3>Author(s)</h3>

<p>Andreas Alfons, based on code by Jafar A. Khan, Stefan Van Aelst and
Ruben H. Zamar
</p>


<h3>References</h3>

<p>Khan, J.A., Van Aelst, S. and Zamar, R.H. (2007) Robust linear model
selection based on least angle regression. <em>Journal of the American
Statistical Association</em>, <b>102</b>(480), 1289&ndash;1299.
<a href="https://doi.org/10.1198/016214507000000950">doi:10.1198/016214507000000950</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+winsorize">winsorize</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate data
library("mvtnorm")
set.seed(1234)  # for reproducibility
Sigma &lt;- matrix(c(1, 0.6, 0.6, 1), 2, 2)
xy &lt;- rmvnorm(100, sigma=Sigma)
x &lt;- xy[, 1]
y &lt;- xy[, 2]

## introduce outlier
x[1] &lt;- x[1] * 10
y[1] &lt;- y[1] * (-5)

## compute correlation
cor(x, y)
corHuber(x, y)

</code></pre>

<hr>
<h2 id='critPlot'>Optimality criterion plot of a sequence of regression models</h2><span id='topic+critPlot'></span><span id='topic+critPlot.rlars'></span><span id='topic+critPlot.grplars'></span><span id='topic+critPlot.tslarsP'></span><span id='topic+critPlot.seqModel'></span><span id='topic+critPlot.tslars'></span><span id='topic+critPlot.sparseLTS'></span><span id='topic+critPlot.perrySeqModel'></span><span id='topic+critPlot.perrySparseLTS'></span><span id='topic+critPlot.setupCritPlot'></span>

<h3>Description</h3>

<p>Produce a plot of the values of the optimality criterion for a sequence of
regression models, such as submodels along a robust or groupwise least angle
regression sequence, or sparse least trimmed squares regression models for
a grid of values for the penalty parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>critPlot(object, ...)

## S3 method for class 'seqModel'
critPlot(object, which = c("line", "dot"), ...)

## S3 method for class 'tslars'
critPlot(object, p, which = c("line", "dot"), ...)

## S3 method for class 'sparseLTS'
critPlot(
  object,
  which = c("line", "dot"),
  fit = c("reweighted", "raw", "both"),
  ...
)

## S3 method for class 'perrySeqModel'
critPlot(object, which = c("line", "dot", "box", "density"), ...)

## S3 method for class 'perrySparseLTS'
critPlot(
  object,
  which = c("line", "dot", "box", "density"),
  fit = c("reweighted", "raw", "both"),
  ...
)

## S3 method for class 'setupCritPlot'
critPlot(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="critPlot_+3A_object">object</code></td>
<td>
<p>the model fit to be plotted, , or an object containing
all necessary information for plotting (as generated by
<code><a href="#topic+setupCritPlot">setupCritPlot</a></code>).</p>
</td></tr>
<tr><td><code id="critPlot_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed down, eventually to
<code><a href="ggplot2.html#topic+geom_line">geom_line</a></code>, <code><a href="ggplot2.html#topic+geom_pointrange">geom_pointrange</a></code>,
<code><a href="ggplot2.html#topic+geom_boxplot">geom_boxplot</a></code>, or <code><a href="ggplot2.html#topic+geom_density">geom_density</a></code>.</p>
</td></tr>
<tr><td><code id="critPlot_+3A_which">which</code></td>
<td>
<p>a character string specifying the type of plot.  Possible
values are <code>"line"</code> (the default) to plot the (average) results for
each model as a connected line, <code>"dot"</code> to create a dot plot,
<code>"box"</code> to create a box plot, or <code>"density"</code> to create a smooth
density plot.  Note that the last two plots are only available in case of
prediction error estimation via repeated resampling.</p>
</td></tr>
<tr><td><code id="critPlot_+3A_p">p</code></td>
<td>
<p>an integer giving the lag length for which to produce the plot
(the default is to use the optimal lag length).</p>
</td></tr>
<tr><td><code id="critPlot_+3A_fit">fit</code></td>
<td>
<p>a character string specifying for which estimator to produce the
plot.  Possible values are <code>"reweighted"</code> (the default) for the
reweighted fits, <code>"raw"</code> for the raw fits, or <code>"both"</code> for both
estimators.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"ggplot"</code> (see <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>).
</p>


<h3>Note</h3>

<p>Function <code><a href="perry.html#topic+perryPlot">perryPlot</a></code> is used to create the plot,
even if the optimality criterion does not correspond to resampling-based p
rediction error estimation.  While this can be seen as as a misuse of its
functionality, it ensures that all optimality criteria are displayed in the
same way.
</p>


<h3>Author(s)</h3>

<p>Andreas Alfons
</p>


<h3>See Also</h3>

<p><code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>, <code><a href="perry.html#topic+perryPlot">perryPlot</a></code>,
<code><a href="#topic+rlars">rlars</a></code>, <code><a href="#topic+grplars">grplars</a></code>, <code><a href="#topic+rgrplars">rgrplars</a></code>,
<code><a href="#topic+tslarsP">tslarsP</a></code>, <code><a href="#topic+rtslarsP">rtslarsP</a></code>, <code><a href="#topic+tslars">tslars</a></code>,
<code><a href="#topic+rtslars">rtslars</a></code>, <code><a href="#topic+sparseLTS">sparseLTS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate data
# example is not high-dimensional to keep computation time low
library("mvtnorm")
set.seed(1234)  # for reproducibility
n &lt;- 100  # number of observations
p &lt;- 25   # number of variables
beta &lt;- rep.int(c(1, 0), c(5, p-5))  # coefficients
sigma &lt;- 0.5      # controls signal-to-noise ratio
epsilon &lt;- 0.1    # contamination level
Sigma &lt;- 0.5^t(sapply(1:p, function(i, j) abs(i-j), 1:p))
x &lt;- rmvnorm(n, sigma=Sigma)    # predictor matrix
e &lt;- rnorm(n)                   # error terms
i &lt;- 1:ceiling(epsilon*n)       # observations to be contaminated
e[i] &lt;- e[i] + 5                # vertical outliers
y &lt;- c(x %*% beta + sigma * e)  # response
x[i,] &lt;- x[i,] + 5              # bad leverage points


## robust LARS
# fit model
fitRlars &lt;- rlars(x, y, sMax = 10)
# create plot
critPlot(fitRlars)


## sparse LTS over a grid of values for lambda
# fit model
frac &lt;- seq(0.2, 0.05, by = -0.05)
fitSparseLTS &lt;- sparseLTS(x, y, lambda = frac, mode = "fraction")
# create plot
critPlot(fitSparseLTS)
critPlot(fitSparseLTS, fit = "both")
</code></pre>

<hr>
<h2 id='diagnosticPlot'>Diagnostic plots for a sequence of regression models</h2><span id='topic+diagnosticPlot'></span><span id='topic+diagnosticPlot.rlars'></span><span id='topic+diagnosticPlot.grplars'></span><span id='topic+diagnosticPlot.tslarsP'></span><span id='topic+diagnosticPlot.seqModel'></span><span id='topic+diagnosticPlot.perrySeqModel'></span><span id='topic+diagnosticPlot.tslars'></span><span id='topic+diagnosticPlot.sparseLTS'></span><span id='topic+diagnosticPlot.perrySparseLTS'></span><span id='topic+diagnosticPlot.setupDiagnosticPlot'></span>

<h3>Description</h3>

<p>Produce diagnostic plots for a sequence of regression models, such as
submodels along a robust least angle regression sequence, or sparse least
trimmed squares regression models for a grid of values for the penalty
parameter.  Four plots are currently implemented.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagnosticPlot(object, ...)

## S3 method for class 'seqModel'
diagnosticPlot(object, s = NA, covArgs = list(), ...)

## S3 method for class 'perrySeqModel'
diagnosticPlot(object, covArgs = list(), ...)

## S3 method for class 'tslars'
diagnosticPlot(object, p, s = NA, covArgs = list(), ...)

## S3 method for class 'sparseLTS'
diagnosticPlot(
  object,
  s = NA,
  fit = c("reweighted", "raw", "both"),
  covArgs = list(),
  ...
)

## S3 method for class 'perrySparseLTS'
diagnosticPlot(
  object,
  fit = c("reweighted", "raw", "both"),
  covArgs = list(),
  ...
)

## S3 method for class 'setupDiagnosticPlot'
diagnosticPlot(
  object,
  which = c("all", "rqq", "rindex", "rfit", "rdiag"),
  ask = (which == "all"),
  facets = object$facets,
  size = c(2, 4),
  id.n = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="diagnosticPlot_+3A_object">object</code></td>
<td>
<p>the model fit for which to produce diagnostic plots, or an
object containing all necessary information for plotting (as generated
by <code><a href="#topic+setupDiagnosticPlot">setupDiagnosticPlot</a></code>).</p>
</td></tr>
<tr><td><code id="diagnosticPlot_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed down, eventually to
<code><a href="ggplot2.html#topic+geom_point">geom_point</a></code>.</p>
</td></tr>
<tr><td><code id="diagnosticPlot_+3A_s">s</code></td>
<td>
<p>for the <code>"seqModel"</code> method, an integer vector giving
the steps of the submodels  for which to produce diagnostic plots (the
default is to use the optimal submodel).  For the <code>"sparseLTS"</code> method,
an integer vector giving the indices of the models for which to produce
diagnostic plots (the default is to use the optimal model for each of the
requested fits).</p>
</td></tr>
<tr><td><code id="diagnosticPlot_+3A_covargs">covArgs</code></td>
<td>
<p>a list of arguments to be passed to
<code><a href="robustbase.html#topic+covMcd">covMcd</a></code> for the regression diagnostic plot (see</p>
</td></tr>
<tr><td><code id="diagnosticPlot_+3A_p">p</code></td>
<td>
<p>an integer giving the lag length for which to produce the plot
(the default is to use the optimal lag length).</p>
</td></tr>
<tr><td><code id="diagnosticPlot_+3A_fit">fit</code></td>
<td>
<p>a character string specifying for which fit to produce
diagnostic plots.  Possible values are <code>"reweighted"</code> (the default) for
diagnostic plots for the reweighted fit, <code>"raw"</code> for diagnostic plots
for the raw fit, or <code>"both"</code> for diagnostic plots for both fits.
&ldquo;Details&rdquo;).</p>
</td></tr>
<tr><td><code id="diagnosticPlot_+3A_which">which</code></td>
<td>
<p>a character string indicating which plot to show.  Possible
values are <code>"all"</code> (the default) for all of the following, <code>"rqq"</code>
for a normal Q-Q plot of the standardized residuals, <code>"rindex"</code> for a
plot of the standardized residuals versus their index, <code>"rfit"</code> for a
plot of the standardized residuals versus the fitted values, or
<code>"rdiag"</code> for a regression diagnostic plot  (standardized residuals
versus robust Mahalanobis distances of the predictor variables).</p>
</td></tr>
<tr><td><code id="diagnosticPlot_+3A_ask">ask</code></td>
<td>
<p>a logical indicating whether the user should be asked before
each plot (see <code><a href="grDevices.html#topic+devAskNewPage">devAskNewPage</a></code>). The default is to
ask if all plots are requested and not ask otherwise.</p>
</td></tr>
<tr><td><code id="diagnosticPlot_+3A_facets">facets</code></td>
<td>
<p>a faceting formula to override the default behavior.  If
supplied, <code><a href="ggplot2.html#topic+facet_wrap">facet_wrap</a></code> or
<code><a href="ggplot2.html#topic+facet_grid">facet_grid</a></code> is called depending on whether the formula
is one-sided or two-sided.</p>
</td></tr>
<tr><td><code id="diagnosticPlot_+3A_size">size</code></td>
<td>
<p>a numeric vector of length two giving the point and label size,
respectively.</p>
</td></tr>
<tr><td><code id="diagnosticPlot_+3A_id.n">id.n</code></td>
<td>
<p>an integer giving the number of the most extreme observations
to be identified by a label.  The default is to use the number of identified
outliers, which can be different for the different plots.  See
&ldquo;Details&rdquo; for more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the normal Q-Q plot of the standardized residuals, a reference line is
drawn through the first and third quartile.  The <code>id.n</code> observations
with the largest distances from that line are identified by a label (the
observation number).  The default for <code>id.n</code> is the number of
regression outliers, i.e., the number of observations whose residuals are
too large (cf. <code><a href="#topic+weights.sparseLTS">weights</a></code>).
</p>
<p>In the plots of the standardized residuals versus their index or the fitted
values, horizontal reference lines are drawn at 0 and +/-2.5.  The
<code>id.n</code> observations with the largest absolute values of the
standardized residuals are identified by a label (the observation
number).  The default for <code>id.n</code> is the number of regression outliers,
i.e., the number of observations whose absolute residuals are too large (cf.
<code><a href="#topic+weights.sparseLTS">weights</a></code>).
</p>
<p>For the regression diagnostic plot, the robust Mahalanobis distances of the
predictor variables are computed via the minimum covariance determinant
(MCD) estimator based on only those predictors with non-zero coefficients
(see <code><a href="robustbase.html#topic+covMcd">covMcd</a></code>).  Horizontal reference lines are
drawn at +/-2.5 and a vertical reference line is drawn at the upper 97.5%
quantile of the <code class="reqn">\chi^{2}</code> distribution with <code class="reqn">p</code>
degrees of freedom, where <code class="reqn">p</code> denotes the number of predictors with
non-zero coefficients.  The <code>id.n</code> observations with the largest
absolute values of the standardized residuals and/or largest robust
Mahalanobis distances are identified by a label (the observation number).
The default for <code>id.n</code> is the number of all outliers: regression
outliers (i.e., observations whose absolute residuals are too large, cf.
<code><a href="#topic+weights.sparseLTS">weights</a></code>) and leverage points (i.e.,
observations with robust Mahalanobis distance larger than the 97.5%
quantile of the <code class="reqn">\chi^{2}</code> distribution with <code class="reqn">p</code>
degrees of freedom).
</p>
<p>Note that the argument <code>alpha</code> for controlling the subset size
behaves differently for <code><a href="#topic+sparseLTS">sparseLTS</a></code> than for
<code><a href="robustbase.html#topic+covMcd">covMcd</a></code>.  For <code><a href="#topic+sparseLTS">sparseLTS</a></code>, the subset
size <code class="reqn">h</code> is determined by the fraction <code>alpha</code> of the number of
observations <code class="reqn">n</code>.  For <code><a href="robustbase.html#topic+covMcd">covMcd</a></code>, on the other
hand, the subset size also depends on the number of variables <code class="reqn">p</code> (see
<code><a href="robustbase.html#topic+h.alpha.n">h.alpha.n</a></code>).  However, the <code>"sparseLTS"</code> and
<code>"perrySparseLTS"</code> methods attempt to compute the MCD using the same
subset size that is used to compute the sparse least trimmed squares
regressions.  This may not be possible if the number of selected variables
is large compared to the number of observations. In such cases,
<code><a href="#topic+setupDiagnosticPlot">setupDiagnosticPlot</a></code> returns <code>NA</code>s for the robust
Mahalanobis distances, and the regression diagnostic plot fails.
</p>


<h3>Value</h3>

<p>If only one plot is requested, an object of class <code>"ggplot"</code> (see
<code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>), otherwise a list of such objects.
</p>


<h3>Author(s)</h3>

<p>Andreas Alfons
</p>


<h3>See Also</h3>

<p><code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>, <code><a href="#topic+rlars">rlars</a></code>,
<code><a href="#topic+grplars">grplars</a></code>, <code><a href="#topic+rgrplars">rgrplars</a></code>, <code><a href="#topic+tslarsP">tslarsP</a></code>,
<code><a href="#topic+rtslarsP">rtslarsP</a></code>, <code><a href="#topic+tslars">tslars</a></code>, <code><a href="#topic+rtslars">rtslars</a></code>,
<code><a href="#topic+sparseLTS">sparseLTS</a></code>, <code><a href="robustbase.html#topic+ltsPlot">plot.lts</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate data
# example is not high-dimensional to keep computation time low
library("mvtnorm")
set.seed(1234)  # for reproducibility
n &lt;- 100  # number of observations
p &lt;- 25   # number of variables
beta &lt;- rep.int(c(1, 0), c(5, p-5))  # coefficients
sigma &lt;- 0.5      # controls signal-to-noise ratio
epsilon &lt;- 0.1    # contamination level
Sigma &lt;- 0.5^t(sapply(1:p, function(i, j) abs(i-j), 1:p))
x &lt;- rmvnorm(n, sigma=Sigma)    # predictor matrix
e &lt;- rnorm(n)                   # error terms
i &lt;- 1:ceiling(epsilon*n)       # observations to be contaminated
e[i] &lt;- e[i] + 5                # vertical outliers
y &lt;- c(x %*% beta + sigma * e)  # response
x[i,] &lt;- x[i,] + 5              # bad leverage points


## robust LARS
# fit model
fitRlars &lt;- rlars(x, y, sMax = 10)
# create plot
diagnosticPlot(fitRlars)


## sparse LTS
# fit model
fitSparseLTS &lt;- sparseLTS(x, y, lambda = 0.05, mode = "fraction")
# create plot
diagnosticPlot(fitSparseLTS)
diagnosticPlot(fitSparseLTS, fit = "both")
</code></pre>

<hr>
<h2 id='fitted.seqModel'>Extract fitted values from a sequence of regression models</h2><span id='topic+fitted.seqModel'></span><span id='topic+fitted.rlars'></span><span id='topic+fitted.grplars'></span><span id='topic+fitted.tslarsP'></span><span id='topic+fitted.tslars'></span><span id='topic+fitted.perrySeqModel'></span><span id='topic+fitted.sparseLTS'></span>

<h3>Description</h3>

<p>Extract fitted values from a sequence of regression models, such as submodels
along a robust or groupwise least angle regression sequence, or sparse least
trimmed squares regression models for a grid of values for the penalty
parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'seqModel'
fitted(object, s = NA, drop = !is.null(s), ...)

## S3 method for class 'tslars'
fitted(object, p, ...)

## S3 method for class 'perrySeqModel'
fitted(object, ...)

## S3 method for class 'sparseLTS'
fitted(
  object,
  s = NA,
  fit = c("reweighted", "raw", "both"),
  drop = !is.null(s),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitted.seqModel_+3A_object">object</code></td>
<td>
<p>the model fit from which to extract fitted values.</p>
</td></tr>
<tr><td><code id="fitted.seqModel_+3A_s">s</code></td>
<td>
<p>for the <code>"seqModel"</code> method, an integer vector giving the
steps of the submodels for which to extract the fitted values (the default
is to use the optimal submodel).  For the <code>"sparseLTS"</code> method, an
integer vector giving the indices of the models for which to extract fitted
values.  If <code>fit</code> is <code>"both"</code>, this can be a list with two
components, with the first component giving the indices of the reweighted
fits and the second the indices of the raw fits.  The default is to use the
optimal model for each of the requested estimators.  Note that the optimal
models may not correspond to the same value of the penalty parameter for the
reweighted and the raw estimator.</p>
</td></tr>
<tr><td><code id="fitted.seqModel_+3A_drop">drop</code></td>
<td>
<p>a logical indicating whether to reduce the dimension to a
vector in case of only one step.</p>
</td></tr>
<tr><td><code id="fitted.seqModel_+3A_...">...</code></td>
<td>
<p>for the <code>"tslars"</code> method, additional arguments to be
passed down to the <code>"seqModel"</code> method.  For the other methods,
additional arguments are currently ignored.</p>
</td></tr>
<tr><td><code id="fitted.seqModel_+3A_p">p</code></td>
<td>
<p>an integer giving the lag length for which to extract fitted
values (the default is to use the optimal lag length).</p>
</td></tr>
<tr><td><code id="fitted.seqModel_+3A_fit">fit</code></td>
<td>
<p>a character string specifying which fitted values to extract.
Possible values are <code>"reweighted"</code> (the default) for the fitted values
from the reweighted estimator, <code>"raw"</code> for the fitted values from the
raw estimator, or <code>"both"</code> for the fitted values from both estimators.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector or matrix containing the requested fitted values.
</p>


<h3>Author(s)</h3>

<p>Andreas Alfons
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+fitted">fitted</a></code>, <code><a href="#topic+rlars">rlars</a></code>,
<code><a href="#topic+grplars">grplars</a></code>, <code><a href="#topic+rgrplars">rgrplars</a></code>, <code><a href="#topic+tslarsP">tslarsP</a></code>,
<code><a href="#topic+rtslarsP">rtslarsP</a></code>, <code><a href="#topic+tslars">tslars</a></code>, <code><a href="#topic+rtslars">rtslars</a></code>,
<code><a href="#topic+sparseLTS">sparseLTS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate data
# example is not high-dimensional to keep computation time low
library("mvtnorm")
set.seed(1234)  # for reproducibility
n &lt;- 100  # number of observations
p &lt;- 25   # number of variables
beta &lt;- rep.int(c(1, 0), c(5, p-5))  # coefficients
sigma &lt;- 0.5      # controls signal-to-noise ratio
epsilon &lt;- 0.1    # contamination level
Sigma &lt;- 0.5^t(sapply(1:p, function(i, j) abs(i-j), 1:p))
x &lt;- rmvnorm(n, sigma=Sigma)    # predictor matrix
e &lt;- rnorm(n)                   # error terms
i &lt;- 1:ceiling(epsilon*n)       # observations to be contaminated
e[i] &lt;- e[i] + 5                # vertical outliers
y &lt;- c(x %*% beta + sigma * e)  # response
x[i,] &lt;- x[i,] + 5              # bad leverage points


## robust LARS
# fit model
fitRlars &lt;- rlars(x, y, sMax = 10)
# extract fitted values
fitted(fitRlars)
head(fitted(fitRlars, s = 1:5))


## sparse LTS over a grid of values for lambda
# fit model
frac &lt;- seq(0.2, 0.05, by = -0.05)
fitSparseLTS &lt;- sparseLTS(x, y, lambda = frac, mode = "fraction")
# extract fitted values
fitted(fitSparseLTS)
head(fitted(fitSparseLTS, fit = "both"))
head(fitted(fitSparseLTS, s = NULL))
head(fitted(fitSparseLTS, fit = "both", s = NULL))
</code></pre>

<hr>
<h2 id='getScale'>Extract the residual scale of a robust regression model</h2><span id='topic+getScale'></span><span id='topic+getScale.seqModel'></span><span id='topic+getScale.sparseLTS'></span>

<h3>Description</h3>

<p>Extract the robust scale estimate of the residuals from a robust regression
model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getScale(x, ...)

## S3 method for class 'seqModel'
getScale(x, s = NA, ...)

## S3 method for class 'sparseLTS'
getScale(x, s = NA, fit = c("reweighted", "raw", "both"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getScale_+3A_x">x</code></td>
<td>
<p>the model fit from which to extract the robust residual scale
estimate.</p>
</td></tr>
<tr><td><code id="getScale_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed down to methods.</p>
</td></tr>
<tr><td><code id="getScale_+3A_s">s</code></td>
<td>
<p>for the <code>"seqModel"</code> method, an integer vector giving
the steps of the submodels for which to extract the robust residual scale
estimate (the default is to use the optimal submodel).  For the
<code>"sparseLTS"</code> method, an integer vector giving the indices of the
models from which to extract the robust residual scale estimate.  If
<code>fit</code> is <code>"both"</code>, this can be a list with two components, with
the first component giving the indices of the reweighted fits and the second
the indices of the raw fits.  The default is to use the optimal model for
each of the requested estimators.  Note that the optimal models may not
correspond to the same value of the penalty parameter for the reweighted
and the raw estimator.</p>
</td></tr>
<tr><td><code id="getScale_+3A_fit">fit</code></td>
<td>
<p>a character string specifying from which fit to extract the
robust residual scale estimate.  Possible values are <code>"reweighted"</code>
(the default) for the residual scale of the reweighted fit, <code>"raw"</code> for
the residual scale of the raw fit, or <code>"both"</code> for the residual scale
of both fits.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Methods are implemented for models of class <code>"lmrob"</code> (see
<code><a href="robustbase.html#topic+lmrob">lmrob</a></code>), <code>"lts"</code> (see
<code><a href="robustbase.html#topic+ltsReg">ltsReg</a></code>), <code>"rlm"</code> (see
<code><a href="MASS.html#topic+rlm">rlm</a></code>), <code>"seqModel"</code> (see <code><a href="#topic+rlars">rlars</a></code>) and
<code>"sparseLTS"</code> (see <code><a href="#topic+sparseLTS">sparseLTS</a></code>).  The default method
computes the MAD of the residuals.
</p>


<h3>Value</h3>

<p>A numeric vector or matrix giving the robust residual scale estimates for
the requested model fits.
</p>


<h3>Author(s)</h3>

<p>Andreas Alfons
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AIC.seqModel">AIC</a></code>, <code><a href="robustbase.html#topic+lmrob">lmrob</a></code>,
<code><a href="robustbase.html#topic+ltsReg">ltsReg</a></code>, <code><a href="MASS.html#topic+rlm">rlm</a></code>,
<code><a href="#topic+rlars">rlars</a></code>, <code><a href="#topic+sparseLTS">sparseLTS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("coleman")
fit &lt;- lmrob(Y ~ ., data=coleman)
getScale(fit)

</code></pre>

<hr>
<h2 id='grplars'>(Robust) groupwise least angle regression</h2><span id='topic+grplars'></span><span id='topic+print.grplars'></span><span id='topic+grplars.formula'></span><span id='topic+grplars.data.frame'></span><span id='topic+grplars.default'></span><span id='topic+rgrplars'></span><span id='topic+rgrplars.formula'></span><span id='topic+rgrplars.data.frame'></span><span id='topic+rgrplars.default'></span>

<h3>Description</h3>

<p>(Robustly) sequence groups of candidate predictors according to their
predictive content and find the optimal model along the sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grplars(x, ...)

## S3 method for class 'formula'
grplars(formula, data, ...)

## S3 method for class 'data.frame'
grplars(x, y, ...)

## Default S3 method:
grplars(
  x,
  y,
  sMax = NA,
  assign,
  fit = TRUE,
  s = c(0, sMax),
  crit = c("BIC", "PE"),
  splits = foldControl(),
  cost = rmspe,
  costArgs = list(),
  selectBest = c("hastie", "min"),
  seFactor = 1,
  ncores = 1,
  cl = NULL,
  seed = NULL,
  model = TRUE,
  ...
)

rgrplars(x, ...)

## S3 method for class 'formula'
rgrplars(formula, data, ...)

## S3 method for class 'data.frame'
rgrplars(x, y, ...)

## Default S3 method:
rgrplars(
  x,
  y,
  sMax = NA,
  assign,
  centerFun = median,
  scaleFun = mad,
  regFun = lmrob,
  regArgs = list(),
  combine = c("min", "euclidean", "mahalanobis"),
  const = 2,
  prob = 0.95,
  fit = TRUE,
  s = c(0, sMax),
  crit = c("BIC", "PE"),
  splits = foldControl(),
  cost = rtmspe,
  costArgs = list(),
  selectBest = c("hastie", "min"),
  seFactor = 1,
  ncores = 1,
  cl = NULL,
  seed = NULL,
  model = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grplars_+3A_x">x</code></td>
<td>
<p>a matrix or data frame containing the candidate predictors.</p>
</td></tr>
<tr><td><code id="grplars_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed down.</p>
</td></tr>
<tr><td><code id="grplars_+3A_formula">formula</code></td>
<td>
<p>a formula describing the full model.</p>
</td></tr>
<tr><td><code id="grplars_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible
to a data frame by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code>) containing the variables in
the model.  If not found in data, the variables are taken from
<code>environment(formula)</code>, typically the environment from which
<code>grplars</code> or <code>rgrplars</code> is called.</p>
</td></tr>
<tr><td><code id="grplars_+3A_y">y</code></td>
<td>
<p>a numeric vector containing the response.</p>
</td></tr>
<tr><td><code id="grplars_+3A_smax">sMax</code></td>
<td>
<p>an integer giving the number of predictor groups to be
sequenced.  If it is <code>NA</code> (the default), predictor groups are sequenced
as long as there are twice as many observations as expected predictor
variables (number of predictor groups times the average number of predictor
variables per group).</p>
</td></tr>
<tr><td><code id="grplars_+3A_assign">assign</code></td>
<td>
<p>an integer vector giving the predictor group to which
each predictor variable belongs.</p>
</td></tr>
<tr><td><code id="grplars_+3A_fit">fit</code></td>
<td>
<p>a logical indicating whether to fit submodels along the sequence
(<code>TRUE</code>, the default) or to simply return the sequence (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="grplars_+3A_s">s</code></td>
<td>
<p>an integer vector of length two giving the first and last
step along the sequence for which to compute submodels.  The default
is to start with a model containing only an intercept (step 0) and
iteratively add all groups along the sequence (step <code>sMax</code>).  If
the second element is <code>NA</code>, predictor groups are added to the
model as long as there are twice as many observations as predictor
variables.  If only one value is supplied, it is recycled.</p>
</td></tr>
<tr><td><code id="grplars_+3A_crit">crit</code></td>
<td>
<p>a character string specifying the optimality criterion to be
used for selecting the final model.  Possible values are <code>"BIC"</code> for
the Bayes information criterion and <code>"PE"</code> for resampling-based
prediction error estimation.</p>
</td></tr>
<tr><td><code id="grplars_+3A_splits">splits</code></td>
<td>
<p>an object giving data splits to be used for prediction error
estimation (see <code><a href="perry.html#topic+perry">perry</a></code>).</p>
</td></tr>
<tr><td><code id="grplars_+3A_cost">cost</code></td>
<td>
<p>a cost function measuring prediction loss (see
<code><a href="perry.html#topic+perry">perry</a></code> for some requirements).  The
default is to use the root trimmed mean squared prediction error for a
robust fit and the root mean squared prediction error otherwise (see
<code><a href="perry.html#topic+cost">cost</a></code>).</p>
</td></tr>
<tr><td><code id="grplars_+3A_costargs">costArgs</code></td>
<td>
<p>a list of additional arguments to be passed to the
prediction loss function <code>cost</code>.</p>
</td></tr>
<tr><td><code id="grplars_+3A_selectbest">selectBest</code>, <code id="grplars_+3A_sefactor">seFactor</code></td>
<td>
<p>arguments specifying a criterion for selecting
the best model (see <code><a href="perry.html#topic+perrySelect">perrySelect</a></code>).  The default is to
use a one-standard-error rule.</p>
</td></tr>
<tr><td><code id="grplars_+3A_ncores">ncores</code></td>
<td>
<p>a positive integer giving the number of processor cores to be
used for parallel computing (the default is 1 for no parallelization).  If
this is set to <code>NA</code>, all available processor cores are used.  For
obtaining the data cleaning weights, for fitting models along the sequence
and for prediction error estimation, parallel computing is implemented on
the <span class="rlang"><b>R</b></span> level using package <span class="pkg">parallel</span>.  Otherwise parallel computing for
some of of the more computer-intensive computations in the sequencing step
is implemented on the C++ level via OpenMP (<a href="https://www.openmp.org/">https://www.openmp.org/</a>).</p>
</td></tr>
<tr><td><code id="grplars_+3A_cl">cl</code></td>
<td>
<p>a <span class="pkg">parallel</span> cluster for parallel computing as generated by
<code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>.  This is preferred over <code>ncores</code>
for tasks that are parallelized on the <span class="rlang"><b>R</b></span> level, in which case <code>ncores</code>
is only used for tasks that are parallelized on the C++ level.</p>
</td></tr>
<tr><td><code id="grplars_+3A_seed">seed</code></td>
<td>
<p>optional initial seed for the random number generator (see
<code><a href="base.html#topic+.Random.seed">.Random.seed</a></code>).  This is useful because many robust regression
functions (including <code><a href="robustbase.html#topic+lmrob">lmrob</a></code>) involve randomness,
or for prediction error estimation.  On parallel <span class="rlang"><b>R</b></span> worker processes, random
number streams are used and the seed is set via
<code><a href="parallel.html#topic+clusterSetRNGStream">clusterSetRNGStream</a></code>.</p>
</td></tr>
<tr><td><code id="grplars_+3A_model">model</code></td>
<td>
<p>a logical indicating whether the model data should be included
in the returned object.</p>
</td></tr>
<tr><td><code id="grplars_+3A_centerfun">centerFun</code></td>
<td>
<p>a function to compute a robust estimate for the center
(defaults to <code><a href="stats.html#topic+median">median</a></code>).</p>
</td></tr>
<tr><td><code id="grplars_+3A_scalefun">scaleFun</code></td>
<td>
<p>a function to compute a robust estimate for the scale
(defaults to <code><a href="stats.html#topic+mad">mad</a></code>).</p>
</td></tr>
<tr><td><code id="grplars_+3A_regfun">regFun</code></td>
<td>
<p>a function to compute robust linear regressions that can be
interpreted as weighted least squares (defaults to
<code><a href="robustbase.html#topic+lmrob">lmrob</a></code>).</p>
</td></tr>
<tr><td><code id="grplars_+3A_regargs">regArgs</code></td>
<td>
<p>a list of arguments to be passed to <code>regFun</code>.</p>
</td></tr>
<tr><td><code id="grplars_+3A_combine">combine</code></td>
<td>
<p>a character string specifying how to combine the data
cleaning weights from the robust regressions with each predictor group.
Possible values are <code>"min"</code> for taking the minimum weight for each
observation, <code>"euclidean"</code> for weights based on Euclidean distances
of the multivariate set of standardized residuals (i.e., multivariate
winsorization of the standardized residuals assuming independence), or
<code>"mahalanobis"</code> for weights based on Mahalanobis distances of the
multivariate set of standardized residuals (i.e., multivariate winsorization
of the standardized residuals).</p>
</td></tr>
<tr><td><code id="grplars_+3A_const">const</code></td>
<td>
<p>numeric; tuning constant for multivariate winsorization to be
used in the initial corralation estimates based on adjusted univariate
winsorization (defaults to 2).</p>
</td></tr>
<tr><td><code id="grplars_+3A_prob">prob</code></td>
<td>
<p>numeric; probability for the quantile of the
<code class="reqn">\chi^{2}</code> distribution to be used in multivariate
winsorization (defaults to 0.95).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>fit</code> is <code>FALSE</code>, an integer vector containing the indices of
the sequenced predictor groups.
</p>
<p>Else if <code>crit</code> is <code>"PE"</code>, an object of class
<code>"perrySeqModel"</code> (inheriting from classes <code>"perryTuning"</code>,
see <code><a href="perry.html#topic+perryTuning">perryTuning</a></code>).  It contains information on the
prediction error criterion, and includes the final model as component
<code>finalModel</code>.
</p>
<p>Otherwise an object of class <code>"grplars"</code> (inheriting from class
<code>"seqModel"</code>) with the following components:
</p>

<dl>
<dt><code>active</code></dt><dd><p>an integer vector containing the sequence of
predictor groups.</p>
</dd>
<dt><code>s</code></dt><dd><p>an integer vector containing the steps for which submodels
along the sequence have been computed.</p>
</dd>
<dt><code>coefficients</code></dt><dd><p>a numeric matrix in which each column contains
the regression coefficients of the corresponding submodel along the
sequence.</p>
</dd>
<dt><code>fitted.values</code></dt><dd><p>a numeric matrix in which each column contains
the fitted values of the corresponding submodel along the sequence.</p>
</dd>
<dt><code>residuals</code></dt><dd><p>a numeric matrix in which each column contains
the residuals of the corresponding submodel along the sequence.</p>
</dd>
<dt><code>df</code></dt><dd><p>an integer vector containing the degrees of freedom of
the submodels along the sequence (i.e., the number of estimated
coefficients).</p>
</dd>
<dt><code>robust</code></dt><dd><p>a logical indicating whether a robust fit was
computed.</p>
</dd>
<dt><code>scale</code></dt><dd><p>a numeric vector giving the robust residual scale
estimates for the submodels along the sequence (only returned for a robust
fit).</p>
</dd>
<dt><code>crit</code></dt><dd><p>an object of class <code>"bicSelect"</code> containing the
BIC values and indicating the final model (only returned if argument
<code>crit</code> is <code>"BIC"</code> and argument <code>s</code> indicates more than one
step along the sequence).</p>
</dd>
<dt><code>muX</code></dt><dd><p>a numeric vector containing the center estimates of the
predictor variables.</p>
</dd>
<dt><code>sigmaX</code></dt><dd><p>a numeric vector containing the scale estimates of
the predictor variables.</p>
</dd>
<dt><code>muY</code></dt><dd><p>numeric; the center estimate of the response.</p>
</dd>
<dt><code>sigmaY</code></dt><dd><p>numeric; the scale estimate of the response.</p>
</dd>
<dt><code>x</code></dt><dd><p>the matrix of candidate predictors (if <code>model</code> is
<code>TRUE</code>).</p>
</dd>
<dt><code>y</code></dt><dd><p>the response (if <code>model</code> is <code>TRUE</code>).</p>
</dd>
<dt><code>assign</code></dt><dd><p>an integer vector giving the predictor group to which
each predictor variable belongs.</p>
</dd>
<dt><code>w</code></dt><dd><p>a numeric vector giving the data cleaning weights (only
returned for a robust fit).</p>
</dd>
<dt><code>call</code></dt><dd><p>the matched function call.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Andreas Alfons
</p>


<h3>References</h3>

<p>Alfons, A., Croux, C. and Gelper, S. (2016) Robust groupwise least angle
regression. <em>Computational Statistics &amp; Data Analysis</em>, <b>93</b>,
421&ndash;435. <a href="https://doi.org/10.1016/j.csda.2015.02.007">doi:10.1016/j.csda.2015.02.007</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coef.seqModel">coef</a></code>,
<code><a href="#topic+fitted.seqModel">fitted</a></code>,
<code><a href="#topic+plot.seqModel">plot</a></code>,
<code><a href="#topic+predict.seqModel">predict</a></code>,
<code><a href="#topic+residuals.seqModel">residuals</a></code>,
<code><a href="#topic+rstandard.seqModel">rstandard</a></code>,
<code><a href="robustbase.html#topic+lmrob">lmrob</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("TopGear")
# keep complete observations
keep &lt;- complete.cases(TopGear)
TopGear &lt;- TopGear[keep, ]
# remove information on car model
info &lt;- TopGear[, 1:3]
TopGear &lt;- TopGear[, -(1:3)]
# log-transform price
TopGear$Price &lt;- log(TopGear$Price)

# robust groupwise LARS
rgrplars(MPG ~ ., data = TopGear, sMax = 15)
</code></pre>

<hr>
<h2 id='lambda0'>Penalty parameter for sparse LTS regression</h2><span id='topic+lambda0'></span>

<h3>Description</h3>

<p>Use bivariate winsorization to estimate the smallest value of the penalty
parameter for sparse least trimmed squares regression that sets all
coefficients to zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lambda0(
  x,
  y,
  normalize = TRUE,
  intercept = TRUE,
  const = 2,
  prob = 0.95,
  tol = .Machine$double.eps^0.5,
  eps = .Machine$double.eps,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lambda0_+3A_x">x</code></td>
<td>
<p>a numeric matrix containing the predictor variables.</p>
</td></tr>
<tr><td><code id="lambda0_+3A_y">y</code></td>
<td>
<p>a numeric vector containing the response variable.</p>
</td></tr>
<tr><td><code id="lambda0_+3A_normalize">normalize</code></td>
<td>
<p>a logical indicating whether the winsorized predictor
variables should be normalized to have unit <code class="reqn">L_{2}</code> norm (the
default is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="lambda0_+3A_intercept">intercept</code></td>
<td>
<p>a logical indicating whether a constant term should be
included in the model (the default is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="lambda0_+3A_const">const</code></td>
<td>
<p>numeric; tuning constant to be used in univariate
winsorization (defaults to 2).</p>
</td></tr>
<tr><td><code id="lambda0_+3A_prob">prob</code></td>
<td>
<p>numeric; probability for the quantile of the
<code class="reqn">\chi^{2}</code> distribution to be used in bivariate
winsorization (defaults to 0.95).</p>
</td></tr>
<tr><td><code id="lambda0_+3A_tol">tol</code></td>
<td>
<p>a small positive numeric value used to determine singularity
issues in the computation of correlation estimates for bivariate
winsorization (see <code><a href="#topic+corHuber">corHuber</a></code>).</p>
</td></tr>
<tr><td><code id="lambda0_+3A_eps">eps</code></td>
<td>
<p>a small positive numeric value used to determine whether the
robust scale estimate of a variable is too small (an effective zero).</p>
</td></tr>
<tr><td><code id="lambda0_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to
<code><a href="#topic+standardize">robStandardize</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The estimation procedure is inspired by the calculation of the respective
penalty parameter in the first step of the classical LARS algorithm.
First, two-dimensional data blocks consisting of the response with each
predictor variable are cleaned via bivariate winsorization.  For each block,
the following computations are then performed.  If an intercept is included
in the model, the cleaned response is centered and the corresponding cleaned
predictor is centered and scaled to have unit norm.  Otherwise the variables
are not centered, but the predictor is scaled to have unit norm.  Finally,
the dot product of the response and the corresponding predictor is
computed.  The largest absolute value of those dot products, rescaled to fit
the parametrization of the sparse LTS definition, yields the estimate of the
smallest penalty parameter that sets all coefficients to zero.
</p>


<h3>Value</h3>

<p>A robust estimate of the smallest value of the penalty parameter for
sparse LTS regression that sets all coefficients to zero.
</p>


<h3>Author(s)</h3>

<p>Andreas Alfons
</p>


<h3>References</h3>

<p>Alfons, A., Croux, C. and Gelper, S. (2013) Sparse least trimmed squares
regression for analyzing high-dimensional large data sets. <em>The Annals
of Applied Statistics</em>, <b>7</b>(1), 226&ndash;248. <a href="https://doi.org/10.1214/12-AOAS575">doi:10.1214/12-AOAS575</a>
</p>
<p>Efron, B., Hastie, T., Johnstone, I. and Tibshirani, R. (2004) Least angle
regression. <em>The Annals of Statistics</em>, <b>32</b>(2), 407&ndash;499.
<a href="https://doi.org/10.1214/009053604000000067">doi:10.1214/009053604000000067</a>
</p>
<p>Khan, J.A., Van Aelst, S. and Zamar, R.H. (2007) Robust linear model
selection based on least angle regression. <em>Journal of the American
Statistical Association</em>, <b>102</b>(480), 1289&ndash;1299.
<a href="https://doi.org/10.1198/016214507000000950">doi:10.1198/016214507000000950</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sparseLTS">sparseLTS</a></code>, <code><a href="#topic+winsorize">winsorize</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate data
# example is not high-dimensional to keep computation time low
library("mvtnorm")
set.seed(1234)  # for reproducibility
n &lt;- 100  # number of observations
p &lt;- 25   # number of variables
beta &lt;- rep.int(c(1, 0), c(5, p-5))  # coefficients
sigma &lt;- 0.5      # controls signal-to-noise ratio
epsilon &lt;- 0.1    # contamination level
Sigma &lt;- 0.5^t(sapply(1:p, function(i, j) abs(i-j), 1:p))
x &lt;- rmvnorm(n, sigma=Sigma)    # predictor matrix
e &lt;- rnorm(n)                   # error terms
i &lt;- 1:ceiling(epsilon*n)       # observations to be contaminated
e[i] &lt;- e[i] + 5                # vertical outliers
y &lt;- c(x %*% beta + sigma * e)  # response
x[i,] &lt;- x[i,] + 5              # bad leverage points

## estimate smallest value of the penalty parameter 
## that sets all coefficients to 0
lambda0(x, y)
</code></pre>

<hr>
<h2 id='nci60'>NCI-60 cancer cell panel</h2><span id='topic+nci60'></span><span id='topic+protein'></span><span id='topic+gene'></span><span id='topic+proteinInfo'></span><span id='topic+geneInfo'></span><span id='topic+cellLineInfo'></span>

<h3>Description</h3>

<p>The data set is a pre-processed version of the NCI-60 cancer cell panel as
used in Alfons, Croux &amp; Gelper (2013).  One observation was removed since
all values in the gene expression data were missing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("nci60")
</code></pre>


<h3>Format</h3>

<p>Protein and gene expression data on 59 observations are stored in two
separate matrices:
</p>

<dl>
<dt><code>protein</code></dt><dd><p>a matrix containing protein expressions based on
antibodies (162 columns), acquired via reverse-phase protein lysate
arrays and log2 transformed.</p>
</dd>
<dt><code>gene</code></dt><dd><p>a matrix containing gene expression data (22283
columns), obtained with an Affymetrix HG-U133A chip and normalized
with the GCRMA method.</p>
</dd>
</dl>

<p>In addition, meta information on the proteins, genes, and cancer cell lines
is stored in three separate data frames:
</p>

<dl>
<dt><code>proteinInfo</code></dt><dd><p>a data frame with 162 rows and the following 4
columns: <code>Experiment</code> (the name of the experiment for collecting
the data), <code>Probe</code> (the name of the individual probe), <code>Symbol</code>
(the symbol of the protein in Human Genome Organisation (HUGO)
nomenclature), and <code>ID</code> (identifier of the protein per the National
Center for Biotechnology Information (NCBI) Entrez database).  The rows of
this data frame correspond to the columns of the matrix <code>protein</code>.</p>
</dd>
<dt><code>geneInfo</code></dt><dd><p>a data frame with 22283 rows and the following 4
columns: <code>Experiment</code> (the name of the experiment for collecting
the data), <code>Probe</code> (the name of the individual probe), <code>Symbol</code>
(the symbol of the gene in Human Genome Organisation (HUGO) nomenclature),
and <code>ID</code> (identifier of the gene per the National Center for
Biotechnology Information (NCBI) Entrez database).  The rows of this
data frame correspond to the columns of the matrix <code>gene</code>.</p>
</dd>
<dt><code>cellLineInfo</code></dt><dd><p>a data frame with 59 rows and 15 columns
containing various information on the cancer cell lines, such as tissue of
origin and histology, or age and sex of the patient. The rows of this data
frame correspond to the rows of the matrices <code>protein</code> and
<code>gene</code>.</p>
</dd>
</dl>



<h3>Source</h3>

<p>The original data were downloaded from
<a href="https://discover.nci.nih.gov/cellminer/">https://discover.nci.nih.gov/cellminer/</a> on 2012-01-27.
</p>
<p>The exact version of the data used in Alfons, Croux &amp; Gelper (2013) can be
obtained from <a href="https://github.com/aalfons/nci60">https://github.com/aalfons/nci60</a>, together with the
script for pre-processing.  The data in package <span class="pkg">robustHD</span> differ in
that the matrix of the gene expressions is called <code>gene</code> and that they
include the three data frames with meta information on proteins, genes, and
cancer cell lines.
</p>


<h3>References</h3>

<p>Reinhold, W.C., Sunshine, M., Liu, H., Varma, S., Kohn, K.W., Morris, J.,
Doroshow, J. and Pommier, Y. (2012) CellMiner: A Web-Based Suite of Genomic
and Pharmacologic Tools to Explore Transcript and Drug Patterns in the
NCI-60 Cell Line Set. <em>Cancer Research</em>, <b>72</b>(14), 3499&ndash;3511.
<a href="https://doi.org/10.1158/0008-5472.CAN-12-1370">doi:10.1158/0008-5472.CAN-12-1370</a>
</p>
<p>Alfons, A., Croux, C. and Gelper, S. (2013) Sparse least trimmed squares
regression for analyzing high-dimensional large data sets. <em>The Annals
of Applied Statistics</em>, <b>7</b>(1), 226&ndash;248. <a href="https://doi.org/10.1214/12-AOAS575">doi:10.1214/12-AOAS575</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# load data
data("nci60")
# define response variable
y &lt;- protein[, 92]
# screen most correlated predictor variables
correlations &lt;- apply(gene, 2, corHuber, y)
keep &lt;- partialOrder(abs(correlations), 100, decreasing = TRUE)
X &lt;- gene[, keep]

</code></pre>

<hr>
<h2 id='partialOrder'>Find partial order of smallest or largest values</h2><span id='topic+partialOrder'></span>

<h3>Description</h3>

<p>Obtain a partial permutation that rearranges the smallest (largest) elements
of a vector into ascending (descending) order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partialOrder(x, h, decreasing = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="partialOrder_+3A_x">x</code></td>
<td>
<p>a numeric vector of which to find the order of the smallest or
largest elements.</p>
</td></tr>
<tr><td><code id="partialOrder_+3A_h">h</code></td>
<td>
<p>an integer specifying how many (smallest or largest) elements to
order.</p>
</td></tr>
<tr><td><code id="partialOrder_+3A_decreasing">decreasing</code></td>
<td>
<p>a logical indicating whether the sort order should be
increasing (<code>FALSE</code>; the default) or decreasing (<code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector containing the indices of the <code>h</code> smallest or
largest elements of <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Andreas Alfons
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+order">order</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># randomly draw some values
values &lt;- rnorm(10)
values

# find largest observations
partialOrder(values, 5, decreasing = TRUE)

</code></pre>

<hr>
<h2 id='perry.seqModel'>Resampling-based prediction error for a sequential regression model</h2><span id='topic+perry.seqModel'></span><span id='topic+perry.rlars'></span><span id='topic+perry.sparseLTS'></span>

<h3>Description</h3>

<p>Estimate the prediction error of a previously fit sequential regression
model such as a robust least angle regression model or a sparse least
trimmed squares regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'seqModel'
perry(
  object,
  splits = foldControl(),
  cost,
  ncores = 1,
  cl = NULL,
  seed = NULL,
  ...
)

## S3 method for class 'sparseLTS'
perry(
  object,
  splits = foldControl(),
  fit = c("reweighted", "raw", "both"),
  cost = rtmspe,
  ncores = 1,
  cl = NULL,
  seed = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="perry.seqModel_+3A_object">object</code></td>
<td>
<p>the model fit for which to estimate the prediction error.</p>
</td></tr>
<tr><td><code id="perry.seqModel_+3A_splits">splits</code></td>
<td>
<p>an object of class <code>"cvFolds"</code> (as returned by
<code><a href="perry.html#topic+cvFolds">cvFolds</a></code>) or a control object of class
<code>"foldControl"</code> (see <code><a href="perry.html#topic+foldControl">foldControl</a></code>) defining the
folds of the data for (repeated) <code class="reqn">K</code>-fold cross-validation, an object of
class <code>"randomSplits"</code> (as returned by
<code><a href="perry.html#topic+randomSplits">randomSplits</a></code>) or a control object of class
<code>"splitControl"</code> (see <code><a href="perry.html#topic+splitControl">splitControl</a></code>) defining
random data splits, or an object of class <code>"bootSamples"</code> (as returned
by <code><a href="perry.html#topic+bootSamples">bootSamples</a></code>) or a control object of class
<code>"bootControl"</code> (see <code><a href="perry.html#topic+bootControl">bootControl</a></code>) defining
bootstrap samples.</p>
</td></tr>
<tr><td><code id="perry.seqModel_+3A_cost">cost</code></td>
<td>
<p>a cost function measuring prediction loss.  It should expect
vectors to be passed as its first two arguments, the first corresponding to
the observed values of the response and the second to the predicted values,
and must return a non-negative scalar value.  The default is to use the root
mean squared prediction error for non-robust models and the root trimmed
mean squared prediction error for robust models (see
<code><a href="perry.html#topic+cost">cost</a></code>).</p>
</td></tr>
<tr><td><code id="perry.seqModel_+3A_ncores">ncores</code></td>
<td>
<p>a positive integer giving the number of processor cores to be
used for parallel computing (the default is 1 for no parallelization).  If
this is set to <code>NA</code>, all available processor cores are used.</p>
</td></tr>
<tr><td><code id="perry.seqModel_+3A_cl">cl</code></td>
<td>
<p>a <span class="pkg">parallel</span> cluster for parallel computing as generated by
<code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>.  If supplied, this is preferred over
<code>ncores</code>.</p>
</td></tr>
<tr><td><code id="perry.seqModel_+3A_seed">seed</code></td>
<td>
<p>optional initial seed for the random number generator (see
<code><a href="base.html#topic+.Random.seed">.Random.seed</a></code>).  Note that also in case of parallel computing,
resampling is performed on the manager process rather than the worker
processes. On the parallel worker processes, random number streams are
used and the seed is set via <code><a href="parallel.html#topic+clusterSetRNGStream">clusterSetRNGStream</a></code>.</p>
</td></tr>
<tr><td><code id="perry.seqModel_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the prediction loss
function <code>cost</code>.</p>
</td></tr>
<tr><td><code id="perry.seqModel_+3A_fit">fit</code></td>
<td>
<p>a character string specifying for which fit to estimate the
prediction error.  Possible values are <code>"reweighted"</code> (the default) for
the prediction error of the reweighted fit, <code>"raw"</code> for the prediction
error of the raw fit, or <code>"both"</code> for the prediction error of both
fits.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The prediction error can be estimated via (repeated) <code class="reqn">K</code>-fold
cross-validation, (repeated) random splitting (also known as random
subsampling or Monte Carlo cross-validation), or the bootstrap.  In
each iteration, the optimal model is thereby selected from the training
data and used to make predictions for the test data.
</p>


<h3>Value</h3>

<p>An object of class <code>"perry"</code> with the following components:
</p>

<dl>
<dt><code>pe</code></dt><dd><p>a numeric vector containing the estimated prediction
errors for the requested model fits.  In case of more than one replication,
this gives the average value over all replications.</p>
</dd>
<dt><code>se</code></dt><dd><p>a numeric vector containing the estimated standard errors
of the prediction loss for the requested model fits.</p>
</dd>
<dt><code>reps</code></dt><dd><p>a numeric matrix in which each column contains the
estimated prediction errors from all replications for the requested model
fits.  This is only returned in case of more than one replication.</p>
</dd>
<dt><code>splits</code></dt><dd><p>an object giving the data splits used to estimate the
prediction error.</p>
</dd>
<dt><code>y</code></dt><dd><p>the response.</p>
</dd>
<dt><code>yHat</code></dt><dd><p>a list containing the predicted values from all
replications.</p>
</dd>
<dt><code>call</code></dt><dd><p>the matched function call.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Andreas Alfons
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rlars">rlars</a></code>, <code><a href="#topic+sparseLTS">sparseLTS</a></code>,
<code><a href="#topic+predict.seqModel">predict</a></code>, <code><a href="perry.html#topic+perry">perry</a></code>,
<code><a href="perry.html#topic+cost">cost</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate data
# example is not high-dimensional to keep computation time low
library("mvtnorm")
set.seed(1234)  # for reproducibility
n &lt;- 100  # number of observations
p &lt;- 25   # number of variables
beta &lt;- rep.int(c(1, 0), c(5, p-5))  # coefficients
sigma &lt;- 0.5      # controls signal-to-noise ratio
epsilon &lt;- 0.1    # contamination level
Sigma &lt;- 0.5^t(sapply(1:p, function(i, j) abs(i-j), 1:p))
x &lt;- rmvnorm(n, sigma=Sigma)    # predictor matrix
e &lt;- rnorm(n)                   # error terms
i &lt;- 1:ceiling(epsilon*n)       # observations to be contaminated
e[i] &lt;- e[i] + 5                # vertical outliers
y &lt;- c(x %*% beta + sigma * e)  # response
x[i,] &lt;- x[i,] + 5              # bad leverage points


## fit and evaluate robust LARS model
fitRlars &lt;- rlars(x, y, sMax = 10)
perry(fitRlars)

## fit and evaluate sparse LTS model
frac &lt;- seq(0.2, 0.05, by = -0.05)
fitSparseLTS &lt;- sparseLTS(x, y, lambda = frac, mode = "fraction")
perry(fitSparseLTS)
</code></pre>

<hr>
<h2 id='plot.seqModel'>Plot a sequence of regression models</h2><span id='topic+plot.seqModel'></span><span id='topic+plot.rlars'></span><span id='topic+plot.grplars'></span><span id='topic+plot.tslarsP'></span><span id='topic+plot.perrySeqModel'></span><span id='topic+plot.tslars'></span><span id='topic+plot.sparseLTS'></span><span id='topic+plot.perrySparseLTS'></span>

<h3>Description</h3>

<p>Produce a plot of the coefficients, the values of the optimality criterion,
or diagnostic plots for a sequence of regression models, such as submodels
along a robust or groupwise least angle regression sequence, or sparse least
trimmed squares regression models for a grid of values for the penalty
parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'seqModel'
plot(x, method = c("coefficients", "crit", "diagnostic"), ...)

## S3 method for class 'perrySeqModel'
plot(x, method = c("crit", "diagnostic"), ...)

## S3 method for class 'tslars'
plot(x, p, method = c("coefficients", "crit", "diagnostic"), ...)

## S3 method for class 'sparseLTS'
plot(x, method = c("coefficients", "crit", "diagnostic"), ...)

## S3 method for class 'perrySparseLTS'
plot(x, method = c("crit", "diagnostic"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.seqModel_+3A_x">x</code></td>
<td>
<p>the model fit to be plotted.</p>
</td></tr>
<tr><td><code id="plot.seqModel_+3A_method">method</code></td>
<td>
<p>a character string specifying the type of plot.  Possible
values are <code>"coefficients"</code> to plot the coefficients from the submodels
via <code><a href="#topic+coefPlot">coefPlot</a></code> (only for the <code>"seqModel"</code> and
<code>"sparseLTS"</code> methods), <code>"crit"</code> to plot the values of the
optimality criterion for the submodels via <code><a href="#topic+critPlot">critPlot</a></code>, or
<code>"diagnostic"</code> for diagnostic plots via <code><a href="#topic+diagnosticPlot">diagnosticPlot</a></code>.</p>
</td></tr>
<tr><td><code id="plot.seqModel_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed down.</p>
</td></tr>
<tr><td><code id="plot.seqModel_+3A_p">p</code></td>
<td>
<p>an integer giving the lag length for which to produce the plot
(the default is to use the optimal lag length).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"ggplot"</code> (see <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>).
</p>


<h3>Author(s)</h3>

<p>Andreas Alfons
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coefPlot">coefPlot</a></code>, <code><a href="#topic+critPlot">critPlot</a></code>,
<code><a href="#topic+diagnosticPlot">diagnosticPlot</a></code>, <code><a href="#topic+rlars">rlars</a></code>, <code><a href="#topic+grplars">grplars</a></code>,
<code><a href="#topic+rgrplars">rgrplars</a></code>, <code><a href="#topic+tslarsP">tslarsP</a></code>, <code><a href="#topic+rtslarsP">rtslarsP</a></code>,
<code><a href="#topic+tslars">tslars</a></code>, <code><a href="#topic+rtslars">rtslars</a></code>, <code><a href="#topic+sparseLTS">sparseLTS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate data
# example is not high-dimensional to keep computation time low
library("mvtnorm")
set.seed(1234)  # for reproducibility
n &lt;- 100  # number of observations
p &lt;- 25   # number of variables
beta &lt;- rep.int(c(1, 0), c(5, p-5))  # coefficients
sigma &lt;- 0.5      # controls signal-to-noise ratio
epsilon &lt;- 0.1    # contamination level
Sigma &lt;- 0.5^t(sapply(1:p, function(i, j) abs(i-j), 1:p))
x &lt;- rmvnorm(n, sigma=Sigma)    # predictor matrix
e &lt;- rnorm(n)                   # error terms
i &lt;- 1:ceiling(epsilon*n)       # observations to be contaminated
e[i] &lt;- e[i] + 5                # vertical outliers
y &lt;- c(x %*% beta + sigma * e)  # response
x[i,] &lt;- x[i,] + 5              # bad leverage points


## robust LARS
# fit model
fitRlars &lt;- rlars(x, y, sMax = 10)
# create plots
plot(fitRlars, method = "coef")
plot(fitRlars, method = "crit")
plot(fitRlars, method = "diagnostic")


## sparse LTS over a grid of values for lambda
# fit model
frac &lt;- seq(0.2, 0.05, by = -0.05)
fitSparseLTS &lt;- sparseLTS(x, y, lambda = frac, mode = "fraction")
# create plots
plot(fitSparseLTS, method = "coef")
plot(fitSparseLTS, method = "crit")
plot(fitSparseLTS, method = "diagnostic")
</code></pre>

<hr>
<h2 id='predict.seqModel'>Predict from a sequence of regression models</h2><span id='topic+predict.seqModel'></span><span id='topic+predict.rlars'></span><span id='topic+predict.grplars'></span><span id='topic+predict.tslarsP'></span><span id='topic+predict.tslars'></span><span id='topic+predict.sparseLTS'></span>

<h3>Description</h3>

<p>Make predictions from a sequence of regression models, such as submodels
along a robust or groupwise least angle regression sequence, or sparse least
trimmed squares regression models for a grid of values for the penalty
parameter.  For autoregressive time series models with exogenous inputs,
<code class="reqn">h</code>-step ahead forecasts are performed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'seqModel'
predict(object, newdata, s = NA, ...)

## S3 method for class 'tslarsP'
predict(object, newdata, ...)

## S3 method for class 'tslars'
predict(object, newdata, p, ...)

## S3 method for class 'sparseLTS'
predict(object, newdata, s = NA, fit = c("reweighted", "raw", "both"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.seqModel_+3A_object">object</code></td>
<td>
<p>the model fit from which to make predictions.</p>
</td></tr>
<tr><td><code id="predict.seqModel_+3A_newdata">newdata</code></td>
<td>
<p>new data for the predictors.  If the model fit was computed
with the formula method, this should be a data frame from which to extract
the predictor variables.  Otherwise this should be a matrix containing the
same variables as the predictor matrix used to fit the model (including a
column of ones to account for the intercept).</p>
</td></tr>
<tr><td><code id="predict.seqModel_+3A_s">s</code></td>
<td>
<p>for the <code>"seqModel"</code> method, an integer vector giving the
steps of the submodels for which to make predictions (the default is to use
the optimal submodel).  For the <code>"sparseLTS"</code> method, an integer vector
giving the indices of the models for which to make predictions.  If
<code>fit</code> is <code>"both"</code>, this can be a list with two components, with
the first component giving the indices of the reweighted fits and the second
the indices of the raw fits.  The default is to use the optimal model for
each of the requested estimators.  Note that the optimal models may not
correspond to the same value of the penalty parameter for the reweighted and
the raw estimator.</p>
</td></tr>
<tr><td><code id="predict.seqModel_+3A_...">...</code></td>
<td>
<p>for the <code>"tslars"</code> method, additional arguments to be
passed down to the <code>"tslarsP"</code> method.  For the other methods,
additional arguments to be passed down to the respective method of
<code><a href="#topic+coef.seqModel">coef</a></code>.</p>
</td></tr>
<tr><td><code id="predict.seqModel_+3A_p">p</code></td>
<td>
<p>an integer giving the lag length for which to make predictions
(the default is to use the optimal lag length).</p>
</td></tr>
<tr><td><code id="predict.seqModel_+3A_fit">fit</code></td>
<td>
<p>a character string specifying for which fit to make
predictions.  Possible values are <code>"reweighted"</code> (the default) for
predicting values from the reweighted fit, <code>"raw"</code> for predicting
values from the raw fit, or <code>"both"</code> for predicting values from both
fits.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>newdata</code> argument defaults to the matrix of predictors used to fit
the model such that the fitted values are computed.
</p>
<p>For autoregressive time series models with exogenous inputs with forecast
horizon <code class="reqn">h</code>, the <code class="reqn">h</code> most recent observations of the predictors are
omitted from fitting the model since there are no corresponding values for
the response.  Hence the <code>newdata</code> argument for <code>predict.tslarsP</code>
and <code>predict.tslars</code> defaults to those <code class="reqn">h</code> observations of the
predictors.
</p>


<h3>Value</h3>

<p>A numeric vector or matrix containing the requested predicted values.
</p>


<h3>Author(s)</h3>

<p>Andreas Alfons
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+predict">predict</a></code>, <code><a href="#topic+rlars">rlars</a></code>,
<code><a href="#topic+grplars">grplars</a></code>, <code><a href="#topic+rgrplars">rgrplars</a></code>, <code><a href="#topic+tslarsP">tslarsP</a></code>,
<code><a href="#topic+rtslarsP">rtslarsP</a></code>, <code><a href="#topic+tslars">tslars</a></code>, <code><a href="#topic+rtslars">rtslars</a></code>,
<code><a href="#topic+sparseLTS">sparseLTS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate data
# example is not high-dimensional to keep computation time low
library("mvtnorm")
set.seed(1234)  # for reproducibility
n &lt;- 100  # number of observations
p &lt;- 25   # number of variables
beta &lt;- rep.int(c(1, 0), c(5, p-5))  # coefficients
sigma &lt;- 0.5      # controls signal-to-noise ratio
epsilon &lt;- 0.1    # contamination level
Sigma &lt;- 0.5^t(sapply(1:p, function(i, j) abs(i-j), 1:p))
x &lt;- rmvnorm(n, sigma=Sigma)    # predictor matrix
e &lt;- rnorm(n)                   # error terms
i &lt;- 1:ceiling(epsilon*n)       # observations to be contaminated
e[i] &lt;- e[i] + 5                # vertical outliers
y &lt;- c(x %*% beta + sigma * e)  # response
x[i,] &lt;- x[i,] + 5              # bad leverage points


## robust LARS
# fit model
fitRlars &lt;- rlars(x, y, sMax = 10)
# compute fitted values via predict method
predict(fitRlars)
head(predict(fitRlars, s = 1:5))


## sparse LTS over a grid of values for lambda
# fit model
frac &lt;- seq(0.2, 0.05, by = -0.05)
fitSparseLTS &lt;- sparseLTS(x, y, lambda = frac, mode = "fraction")
# compute fitted values via predict method
predict(fitSparseLTS)
head(predict(fitSparseLTS, fit = "both"))
head(predict(fitSparseLTS, s = NULL))
head(predict(fitSparseLTS, fit = "both", s = NULL))
</code></pre>

<hr>
<h2 id='residuals.seqModel'>Extract residuals from a sequence of regression models</h2><span id='topic+residuals.seqModel'></span><span id='topic+residuals.rlars'></span><span id='topic+residuals.grplars'></span><span id='topic+residuals.tslarsP'></span><span id='topic+residuals.tslars'></span><span id='topic+residuals.perrySeqModel'></span><span id='topic+residuals.sparseLTS'></span>

<h3>Description</h3>

<p>Extract residuals from a sequence of regression models, such as submodels
along a robust or groupwise least angle regression sequence, or sparse least
trimmed squares regression models for a grid of values for the penalty
parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'seqModel'
residuals(object, s = NA, standardized = FALSE, drop = !is.null(s), ...)

## S3 method for class 'tslars'
residuals(object, p, ...)

## S3 method for class 'perrySeqModel'
residuals(object, ...)

## S3 method for class 'sparseLTS'
residuals(
  object,
  s = NA,
  fit = c("reweighted", "raw", "both"),
  standardized = FALSE,
  drop = !is.null(s),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residuals.seqModel_+3A_object">object</code></td>
<td>
<p>the model fit from which to extract residuals.</p>
</td></tr>
<tr><td><code id="residuals.seqModel_+3A_s">s</code></td>
<td>
<p>for the <code>"seqModel"</code> method, an integer vector giving the
steps of the submodels for which to extract the residuals (the default is to
use the optimal submodel).  For the <code>"sparseLTS"</code> method, an integer
vector giving the indices of the models for which to extract residuals.  If
<code>fit</code> is <code>"both"</code>, this can be a list with two components, with
the first component giving the indices of the reweighted fits and the second
the indices of the raw fits.  The default is to use the optimal model for
each of the requested estimators.  Note that the optimal models may not
correspond to the same value of the penalty parameter for the reweighted and
the raw estimator.</p>
</td></tr>
<tr><td><code id="residuals.seqModel_+3A_standardized">standardized</code></td>
<td>
<p>a logical indicating whether the residuals should be
standardized (the default is <code>FALSE</code>). Note that this argument is
<b>deprecated</b> and may be removed as soon as the next version. Use
<code><a href="#topic+rstandard.seqModel">rstandard</a></code> instead to extract standardized
residuals.</p>
</td></tr>
<tr><td><code id="residuals.seqModel_+3A_drop">drop</code></td>
<td>
<p>a logical indicating whether to reduce the dimension to a
vector in case of only one step.</p>
</td></tr>
<tr><td><code id="residuals.seqModel_+3A_...">...</code></td>
<td>
<p>for the <code>"tslars"</code> method, additional arguments to be
passed down to the <code>"seqModel"</code> method.  For the other methods,
additional arguments are currently ignored.</p>
</td></tr>
<tr><td><code id="residuals.seqModel_+3A_p">p</code></td>
<td>
<p>an integer giving the lag length for which to extract residuals
(the default is to use the optimal lag length).</p>
</td></tr>
<tr><td><code id="residuals.seqModel_+3A_fit">fit</code></td>
<td>
<p>a character string specifying which residuals to extract.
Possible values are <code>"reweighted"</code> (the default) for the residuals
from the reweighted estimator, <code>"raw"</code> for the residuals from the raw
estimator, or <code>"both"</code> for the residuals from both estimators.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector or matrix containing the requested residuals.
</p>


<h3>Author(s)</h3>

<p>Andreas Alfons
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+residuals">residuals</a></code>, <code><a href="#topic+rstandard.seqModel">rstandard</a></code>
</p>
<p><code><a href="#topic+rlars">rlars</a></code>, <code><a href="#topic+grplars">grplars</a></code>, <code><a href="#topic+rgrplars">rgrplars</a></code>,
<code><a href="#topic+tslarsP">tslarsP</a></code>, <code><a href="#topic+rtslarsP">rtslarsP</a></code>, <code><a href="#topic+tslars">tslars</a></code>,
<code><a href="#topic+rtslars">rtslars</a></code>, <code><a href="#topic+sparseLTS">sparseLTS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate data
# example is not high-dimensional to keep computation time low
library("mvtnorm")
set.seed(1234)  # for reproducibility
n &lt;- 100  # number of observations
p &lt;- 25   # number of variables
beta &lt;- rep.int(c(1, 0), c(5, p-5))  # coefficients
sigma &lt;- 0.5      # controls signal-to-noise ratio
epsilon &lt;- 0.1    # contamination level
Sigma &lt;- 0.5^t(sapply(1:p, function(i, j) abs(i-j), 1:p))
x &lt;- rmvnorm(n, sigma=Sigma)    # predictor matrix
e &lt;- rnorm(n)                   # error terms
i &lt;- 1:ceiling(epsilon*n)       # observations to be contaminated
e[i] &lt;- e[i] + 5                # vertical outliers
y &lt;- c(x %*% beta + sigma * e)  # response
x[i,] &lt;- x[i,] + 5              # bad leverage points


## robust LARS
# fit model
fitRlars &lt;- rlars(x, y, sMax = 10)
# extract residuals
residuals(fitRlars)
head(residuals(fitRlars, s = 1:5))


## sparse LTS over a grid of values for lambda
# fit model
frac &lt;- seq(0.2, 0.05, by = -0.05)
fitSparseLTS &lt;- sparseLTS(x, y, lambda = frac, mode = "fraction")
# extract residuals
residuals(fitSparseLTS)
head(residuals(fitSparseLTS, fit = "both"))
head(residuals(fitSparseLTS, s = NULL))
head(residuals(fitSparseLTS, fit = "both", s = NULL))
</code></pre>

<hr>
<h2 id='rlars'>Robust least angle regression</h2><span id='topic+rlars'></span><span id='topic+print.rlars'></span><span id='topic+rlars.formula'></span><span id='topic+rlars.default'></span>

<h3>Description</h3>

<p>Robustly sequence candidate predictors according to their predictive content
and find the optimal model along the sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rlars(x, ...)

## S3 method for class 'formula'
rlars(formula, data, ...)

## Default S3 method:
rlars(
  x,
  y,
  sMax = NA,
  centerFun = median,
  scaleFun = mad,
  winsorize = FALSE,
  const = 2,
  prob = 0.95,
  fit = TRUE,
  s = c(0, sMax),
  regFun = lmrob,
  regArgs = list(),
  crit = c("BIC", "PE"),
  splits = foldControl(),
  cost = rtmspe,
  costArgs = list(),
  selectBest = c("hastie", "min"),
  seFactor = 1,
  ncores = 1,
  cl = NULL,
  seed = NULL,
  model = TRUE,
  tol = .Machine$double.eps^0.5,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rlars_+3A_x">x</code></td>
<td>
<p>a matrix or data frame containing the candidate predictors.</p>
</td></tr>
<tr><td><code id="rlars_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed down.  For the default
method, additional arguments to be passed down to
<code><a href="#topic+standardize">robStandardize</a></code>.</p>
</td></tr>
<tr><td><code id="rlars_+3A_formula">formula</code></td>
<td>
<p>a formula describing the full model.</p>
</td></tr>
<tr><td><code id="rlars_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible
to a data frame by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code>) containing the variables in
the model.  If not found in data, the variables are taken from
<code>environment(formula)</code>, typically the environment from which
<code>rlars</code> is called.</p>
</td></tr>
<tr><td><code id="rlars_+3A_y">y</code></td>
<td>
<p>a numeric vector containing the response.</p>
</td></tr>
<tr><td><code id="rlars_+3A_smax">sMax</code></td>
<td>
<p>an integer giving the number of predictors to be sequenced.  If
it is <code>NA</code> (the default), predictors are sequenced as long as there are
twice as many observations as predictors.</p>
</td></tr>
<tr><td><code id="rlars_+3A_centerfun">centerFun</code></td>
<td>
<p>a function to compute a robust estimate for the center
(defaults to <code><a href="stats.html#topic+median">median</a></code>).</p>
</td></tr>
<tr><td><code id="rlars_+3A_scalefun">scaleFun</code></td>
<td>
<p>a function to compute a robust estimate for the scale
(defaults to <code><a href="stats.html#topic+mad">mad</a></code>).</p>
</td></tr>
<tr><td><code id="rlars_+3A_winsorize">winsorize</code></td>
<td>
<p>a logical indicating whether to clean the full data set by
multivariate winsorization, i.e., to perform data cleaning RLARS instead of
plug-in RLARS (defaults to <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="rlars_+3A_const">const</code></td>
<td>
<p>numeric; tuning constant to be used in the initial corralation
estimates based on adjusted univariate winsorization (defaults to 2).</p>
</td></tr>
<tr><td><code id="rlars_+3A_prob">prob</code></td>
<td>
<p>numeric; probability for the quantile of the
<code class="reqn">\chi^{2}</code> distribution to be used in bivariate or
multivariate winsorization (defaults to 0.95).</p>
</td></tr>
<tr><td><code id="rlars_+3A_fit">fit</code></td>
<td>
<p>a logical indicating whether to fit submodels along the sequence
(<code>TRUE</code>, the default) or to simply return the sequence (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="rlars_+3A_s">s</code></td>
<td>
<p>an integer vector of length two giving the first and last step
along the sequence for which to compute submodels.  The default is to start
with a model containing only an intercept (step 0) and iteratively add all
variables along the sequence (step <code>sMax</code>).  If the second element is
<code>NA</code>, predictors are added to the model as long as there are twice
as many observations as predictors.  If only one value is supplied, it is
recycled.</p>
</td></tr>
<tr><td><code id="rlars_+3A_regfun">regFun</code></td>
<td>
<p>a function to compute robust linear regressions along the
sequence (defaults to <code><a href="robustbase.html#topic+lmrob">lmrob</a></code>).</p>
</td></tr>
<tr><td><code id="rlars_+3A_regargs">regArgs</code></td>
<td>
<p>a list of arguments to be passed to <code>regFun</code>.</p>
</td></tr>
<tr><td><code id="rlars_+3A_crit">crit</code></td>
<td>
<p>a character string specifying the optimality criterion to be
used for selecting the final model.  Possible values are <code>"BIC"</code> for
the Bayes information criterion and <code>"PE"</code> for resampling-based
prediction error estimation.</p>
</td></tr>
<tr><td><code id="rlars_+3A_splits">splits</code></td>
<td>
<p>an object giving data splits to be used for prediction error
estimation (see <code><a href="perry.html#topic+perry">perry</a></code>).</p>
</td></tr>
<tr><td><code id="rlars_+3A_cost">cost</code></td>
<td>
<p>a cost function measuring prediction loss (see
<code><a href="perry.html#topic+perry">perry</a></code> for some requirements).  The
default is to use the root trimmed mean squared prediction error
(see <code><a href="perry.html#topic+cost">cost</a></code>).</p>
</td></tr>
<tr><td><code id="rlars_+3A_costargs">costArgs</code></td>
<td>
<p>a list of additional arguments to be passed to the
prediction loss function <code>cost</code>.</p>
</td></tr>
<tr><td><code id="rlars_+3A_selectbest">selectBest</code>, <code id="rlars_+3A_sefactor">seFactor</code></td>
<td>
<p>arguments specifying a criterion for selecting
the best model (see <code><a href="perry.html#topic+perrySelect">perrySelect</a></code>).  The default is to
use a one-standard-error rule.</p>
</td></tr>
<tr><td><code id="rlars_+3A_ncores">ncores</code></td>
<td>
<p>a positive integer giving the number of processor cores to be
used for parallel computing (the default is 1 for no parallelization).  If
this is set to <code>NA</code>, all available processor cores are used.  For
fitting models along the sequence and for prediction error estimation,
parallel computing is implemented on the <span class="rlang"><b>R</b></span> level using package
<span class="pkg">parallel</span>.  Otherwise parallel computing for some of of the more
computer-intensive computations in the sequencing step is implemented on the
C++ level via OpenMP (<a href="https://www.openmp.org/">https://www.openmp.org/</a>).</p>
</td></tr>
<tr><td><code id="rlars_+3A_cl">cl</code></td>
<td>
<p>a <span class="pkg">parallel</span> cluster for parallel computing as generated by
<code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>.  This is preferred over <code>ncores</code>
for tasks that are parallelized on the <span class="rlang"><b>R</b></span> level, in which case <code>ncores</code>
is only used for tasks that are parallelized on the C++ level.</p>
</td></tr>
<tr><td><code id="rlars_+3A_seed">seed</code></td>
<td>
<p>optional initial seed for the random number generator (see
<code><a href="base.html#topic+.Random.seed">.Random.seed</a></code>).  This is useful because many robust regression
functions (including <code><a href="robustbase.html#topic+lmrob">lmrob</a></code>) involve randomness,
or for prediction error estimation.  On parallel <span class="rlang"><b>R</b></span> worker processes, random
number streams are used and the seed is set via
<code><a href="parallel.html#topic+clusterSetRNGStream">clusterSetRNGStream</a></code>.</p>
</td></tr>
<tr><td><code id="rlars_+3A_model">model</code></td>
<td>
<p>a logical indicating whether the model data should be included
in the returned object.</p>
</td></tr>
<tr><td><code id="rlars_+3A_tol">tol</code></td>
<td>
<p>a small positive numeric value.  This is used in bivariate
winsorization to determine whether the initial estimate from adjusted
univariate winsorization is close to 1 in absolute value.  In this case,
bivariate winsorization would fail since the points form almost a straight
line, and the initial estimate is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>fit</code> is <code>FALSE</code>, an integer vector containing the indices of
the sequenced predictors.
</p>
<p>Else if <code>crit</code> is <code>"PE"</code>, an object of class
<code>"perrySeqModel"</code> (inheriting from class <code>"perrySelect"</code>,
see <code><a href="perry.html#topic+perrySelect">perrySelect</a></code>).  It contains information on the
prediction error criterion, and includes the final model as component
<code>finalModel</code>.
</p>
<p>Otherwise an object of class <code>"rlars"</code> (inheriting from class
<code>"seqModel"</code>) with the following components:
</p>

<dl>
<dt><code>active</code></dt><dd><p>an integer vector containing the indices of the
sequenced predictors.</p>
</dd>
<dt><code>s</code></dt><dd><p>an integer vector containing the steps for which submodels
along the sequence have been computed.</p>
</dd>
<dt><code>coefficients</code></dt><dd><p>a numeric matrix in which each column contains
the regression coefficients of the corresponding submodel along the
sequence.</p>
</dd>
<dt><code>fitted.values</code></dt><dd><p>a numeric matrix in which each column contains
the fitted values of the corresponding submodel along the sequence.</p>
</dd>
<dt><code>residuals</code></dt><dd><p>a numeric matrix in which each column contains
the residuals of the corresponding submodel along the sequence.</p>
</dd>
<dt><code>df</code></dt><dd><p>an integer vector containing the degrees of freedom of
the submodels along the sequence (i.e., the number of estimated
coefficients).</p>
</dd>
<dt><code>robust</code></dt><dd><p>a logical indicating whether a robust fit was
computed (<code>TRUE</code> for <code>"rlars"</code> models).</p>
</dd>
<dt><code>scale</code></dt><dd><p>a numeric vector giving the robust residual scale
estimates for the submodels along the sequence.</p>
</dd>
<dt><code>crit</code></dt><dd><p>an object of class <code>"bicSelect"</code> containing the
BIC values and indicating the final model (only returned if argument
<code>crit</code> is <code>"BIC"</code> and argument <code>s</code> indicates more than one
step along the sequence).</p>
</dd>
<dt><code>muX</code></dt><dd><p>a numeric vector containing the center estimates of the
predictors.</p>
</dd>
<dt><code>sigmaX</code></dt><dd><p>a numeric vector containing the scale estimates of
the predictors.</p>
</dd>
<dt><code>muY</code></dt><dd><p>numeric; the center estimate of the response.</p>
</dd>
<dt><code>sigmaY</code></dt><dd><p>numeric; the scale estimate of the response.</p>
</dd>
<dt><code>x</code></dt><dd><p>the matrix of candidate predictors (if <code>model</code> is
<code>TRUE</code>).</p>
</dd>
<dt><code>y</code></dt><dd><p>the response (if <code>model</code> is <code>TRUE</code>).</p>
</dd>
<dt><code>w</code></dt><dd><p>a numeric vector giving the data cleaning weights (if
<code>winsorize</code> is <code>TRUE</code>).</p>
</dd>
<dt><code>call</code></dt><dd><p>the matched function call.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Andreas Alfons, based on code by Jafar A. Khan, Stefan Van Aelst and
Ruben H. Zamar
</p>


<h3>References</h3>

<p>Khan, J.A., Van Aelst, S. and Zamar, R.H. (2007) Robust linear model
selection based on least angle regression. <em>Journal of the American
Statistical Association</em>, <b>102</b>(480), 1289&ndash;1299.
<a href="https://doi.org/10.1198/016214507000000950">doi:10.1198/016214507000000950</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coef.seqModel">coef</a></code>,
<code><a href="#topic+fitted.seqModel">fitted</a></code>,
<code><a href="#topic+plot.seqModel">plot</a></code>,
<code><a href="#topic+predict.seqModel">predict</a></code>,
<code><a href="#topic+residuals.seqModel">residuals</a></code>,
<code><a href="#topic+rstandard.seqModel">rstandard</a></code>,
<code><a href="robustbase.html#topic+lmrob">lmrob</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate data
# example is not high-dimensional to keep computation time low
library("mvtnorm")
set.seed(1234)  # for reproducibility
n &lt;- 100  # number of observations
p &lt;- 25   # number of variables
beta &lt;- rep.int(c(1, 0), c(5, p-5))  # coefficients
sigma &lt;- 0.5      # controls signal-to-noise ratio
epsilon &lt;- 0.1    # contamination level
Sigma &lt;- 0.5^t(sapply(1:p, function(i, j) abs(i-j), 1:p))
x &lt;- rmvnorm(n, sigma=Sigma)    # predictor matrix
e &lt;- rnorm(n)                   # error terms
i &lt;- 1:ceiling(epsilon*n)       # observations to be contaminated
e[i] &lt;- e[i] + 5                # vertical outliers
y &lt;- c(x %*% beta + sigma * e)  # response
x[i,] &lt;- x[i,] + 5              # bad leverage points

## fit robust LARS model
rlars(x, y, sMax = 10)
</code></pre>

<hr>
<h2 id='rstandard.seqModel'>Extract standardized residuals from a sequence of regression models</h2><span id='topic+rstandard.seqModel'></span><span id='topic+rstandard.rlars'></span><span id='topic+rstandard.grplars'></span><span id='topic+rstandard.tslarsP'></span><span id='topic+rstandard.tslars'></span><span id='topic+rstandard.perrySeqModel'></span><span id='topic+rstandard.sparseLTS'></span>

<h3>Description</h3>

<p>Extract standardized residuals from a sequence of regression models, such as
submodels along a robust or groupwise least angle regression sequence, or
sparse least trimmed squares regression models for a grid of values for the
penalty parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'seqModel'
rstandard(model, s = NA, drop = !is.null(s), ...)

## S3 method for class 'tslars'
rstandard(model, p, ...)

## S3 method for class 'perrySeqModel'
rstandard(model, ...)

## S3 method for class 'sparseLTS'
rstandard(
  model,
  s = NA,
  fit = c("reweighted", "raw", "both"),
  drop = !is.null(s),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rstandard.seqModel_+3A_model">model</code></td>
<td>
<p>the model fit from which to extract standardize residuals.</p>
</td></tr>
<tr><td><code id="rstandard.seqModel_+3A_s">s</code></td>
<td>
<p>for the <code>"seqModel"</code> method, an integer vector giving the
steps of the submodels for which to extract the standardized residuals (the
default is to use the optimal submodel).  For the <code>"sparseLTS"</code> method,
an integer vector giving the indices of the models for which to extract
standardized residuals.  If <code>fit</code> is <code>"both"</code>, this can be a list
with two components, with the first component giving the indices of the
reweighted fits and the second the indices of the raw fits.  The default is
to use the optimal model for each of the requested estimators.  Note that
the optimal models may not correspond to the same value of the penalty
parameter for the reweighted and the raw estimator.</p>
</td></tr>
<tr><td><code id="rstandard.seqModel_+3A_drop">drop</code></td>
<td>
<p>a logical indicating whether to reduce the dimension to a
vector in case of only one step.</p>
</td></tr>
<tr><td><code id="rstandard.seqModel_+3A_...">...</code></td>
<td>
<p>for the <code>"tslars"</code> method, additional arguments to be
passed down to the <code>"seqModel"</code> method.  For the other methods,
additional arguments are currently ignored.</p>
</td></tr>
<tr><td><code id="rstandard.seqModel_+3A_p">p</code></td>
<td>
<p>an integer giving the lag length for which to extract standardized
residuals (the default is to use the optimal lag length).</p>
</td></tr>
<tr><td><code id="rstandard.seqModel_+3A_fit">fit</code></td>
<td>
<p>a character string specifying which standardized residuals to
extract.  Possible values are <code>"reweighted"</code> (the default) for the
standardized residuals from the reweighted estimator, <code>"raw"</code> for the
standardized residuals from the raw estimator, or <code>"both"</code> for the
standardized residuals from both estimators.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector or matrix containing the requested standardized residuals.
</p>


<h3>Author(s)</h3>

<p>Andreas Alfons
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+rstandard">rstandard</a></code>, <code><a href="#topic+residuals.seqModel">residuals</a></code>
</p>
<p><code><a href="#topic+rlars">rlars</a></code>, <code><a href="#topic+grplars">grplars</a></code>, <code><a href="#topic+rgrplars">rgrplars</a></code>,
<code><a href="#topic+tslarsP">tslarsP</a></code>, <code><a href="#topic+rtslarsP">rtslarsP</a></code>, <code><a href="#topic+tslars">tslars</a></code>,
<code><a href="#topic+rtslars">rtslars</a></code>, <code><a href="#topic+sparseLTS">sparseLTS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate data
# example is not high-dimensional to keep computation time low
library("mvtnorm")
set.seed(1234)  # for reproducibility
n &lt;- 100  # number of observations
p &lt;- 25   # number of variables
beta &lt;- rep.int(c(1, 0), c(5, p-5))  # coefficients
sigma &lt;- 0.5      # controls signal-to-noise ratio
epsilon &lt;- 0.1    # contamination level
Sigma &lt;- 0.5^t(sapply(1:p, function(i, j) abs(i-j), 1:p))
x &lt;- rmvnorm(n, sigma=Sigma)    # predictor matrix
e &lt;- rnorm(n)                   # error terms
i &lt;- 1:ceiling(epsilon*n)       # observations to be contaminated
e[i] &lt;- e[i] + 5                # vertical outliers
y &lt;- c(x %*% beta + sigma * e)  # response
x[i,] &lt;- x[i,] + 5              # bad leverage points


## robust LARS
# fit model
fitRlars &lt;- rlars(x, y, sMax = 10)
# extract standardized residuals
rstandard(fitRlars)
head(rstandard(fitRlars, s = 1:5))


## sparse LTS over a grid of values for lambda
# fit model
frac &lt;- seq(0.2, 0.05, by = -0.05)
fitSparseLTS &lt;- sparseLTS(x, y, lambda = frac, mode = "fraction")
# extract standardized residuals
rstandard(fitSparseLTS)
head(rstandard(fitSparseLTS, fit = "both"))
head(rstandard(fitSparseLTS, s = NULL))
head(rstandard(fitSparseLTS, fit = "both", s = NULL))
</code></pre>

<hr>
<h2 id='setupCoefPlot'>Set up a coefficient plot of a sequence of regression models</h2><span id='topic+setupCoefPlot'></span><span id='topic+setupCoefPlot.rlars'></span><span id='topic+setupCoefPlot.grplars'></span><span id='topic+setupCoefPlot.tslarsP'></span><span id='topic+setupCoefPlot.seqModel'></span><span id='topic+setupCoefPlot.tslars'></span><span id='topic+setupCoefPlot.sparseLTS'></span>

<h3>Description</h3>

<p>Extract the relevent information for a plot of the coefficients for a
sequence of regression models, such as submodels along a robust or groupwise
least angle regression sequence, or sparse least trimmed squares regression
models for a grid of values for the penalty parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setupCoefPlot(object, ...)

## S3 method for class 'seqModel'
setupCoefPlot(object, zeros = FALSE, labels = NULL, ...)

## S3 method for class 'tslars'
setupCoefPlot(object, p, ...)

## S3 method for class 'sparseLTS'
setupCoefPlot(
  object,
  fit = c("reweighted", "raw", "both"),
  zeros = FALSE,
  labels = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setupCoefPlot_+3A_object">object</code></td>
<td>
<p>the model fit from which to extract information.</p>
</td></tr>
<tr><td><code id="setupCoefPlot_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed down.</p>
</td></tr>
<tr><td><code id="setupCoefPlot_+3A_zeros">zeros</code></td>
<td>
<p>a logical indicating whether predictors that never enter the
model and thus have zero coefficients should be included in the plot
(<code>TRUE</code>) or omitted (<code>FALSE</code>, the default).  This is useful if the
number of predictors is much larger than the number of observations, in
which case many coefficients are never nonzero.</p>
</td></tr>
<tr><td><code id="setupCoefPlot_+3A_labels">labels</code></td>
<td>
<p>an optional character vector containing labels for the
predictors.  Information on labels can be suppressed by setting this to
<code>NA</code>.</p>
</td></tr>
<tr><td><code id="setupCoefPlot_+3A_p">p</code></td>
<td>
<p>an integer giving the lag length for which to extract information
(the default is to use the optimal lag length).</p>
</td></tr>
<tr><td><code id="setupCoefPlot_+3A_fit">fit</code></td>
<td>
<p>a character string specifying for which estimator to extract
information.  Possible values are <code>"reweighted"</code> (the default) for
the reweighted fits, <code>"raw"</code> for the raw fits, or <code>"both"</code> for
both estimators.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object inheriting from class <code>"setupCoefPlot"</code> with the
following components:
</p>

<dl>
<dt><code>coefficients</code></dt><dd><p>a data frame containing the following columns:
</p>

<dl>
<dt><code>fit</code></dt><dd><p>the model fit for which the coefficient is computed
(only returned if both the reweighted and raw fit are requested in the
<code>"sparseLTS"</code> method).</p>
</dd>
<dt><code>lambda</code></dt><dd><p>the value of the penalty parameter for which the
coefficient is computed (only returned for the <code>"sparseLTS"</code>
method).</p>
</dd>
<dt><code>step</code></dt><dd><p>the step along the sequence for which the coefficient
is computed.</p>
</dd>
<dt><code>df</code></dt><dd><p>the degrees of freedom of the submodel along the
sequence for which the coefficient is computed.</p>
</dd>
<dt><code>coefficient</code></dt><dd><p>the value of the coefficient.</p>
</dd>
<dt><code>variable</code></dt><dd><p>a character string specifying to which variable
the coefficient belongs.</p>
</dd>
</dl>

</dd>
<dt><code>abscissa</code></dt><dd><p>a character string specifying available options for
what to plot on the <code class="reqn">x</code>-axis</p>
</dd>
<dt><code>lambda</code></dt><dd><p>a numeric vector giving the values of the penalty
parameter. (only returned for the <code>"sparseLTS"</code> method).</p>
</dd>
<dt><code>step</code></dt><dd><p>an integer vector containing the steps for which
submodels along the sequence have been computed.</p>
</dd>
<dt><code>df</code></dt><dd><p>an integer vector containing the degrees of freedom of
the submodels along the sequence (i.e., the number of estimated
coefficients; only returned for the <code>"seqModel"</code> method).</p>
</dd>
<dt><code>includeLabels</code></dt><dd><p>a logical indicating whether information on
labels for the variables should be included in the plot.</p>
</dd>
<dt><code>labels</code></dt><dd><p>a data frame containing the following columns (not
returned if information on labels is suppressed):
</p>

<dl>
<dt><code>fit</code></dt><dd><p>the model fit for which the coefficient is computed
(only returned if both the reweighted and raw fit are requested in the
<code>"sparseLTS"</code> method).</p>
</dd>
<dt><code>lambda</code></dt><dd><p>the smallest value of the penalty parameter
(only returned for the <code>"sparseLTS"</code>
method).</p>
</dd>
<dt><code>step</code></dt><dd><p>the last step along the sequence.</p>
</dd>
<dt><code>df</code></dt><dd><p>the degrees of freedom of the last submodel along the
sequence.</p>
</dd>
<dt><code>coefficient</code></dt><dd><p>the value of the coefficient.</p>
</dd>
<dt><code>label</code></dt><dd><p>the label of the corresponding variable to be
displayed in the plot.</p>
</dd>
</dl>

</dd>
<dt><code>facets</code></dt><dd><p>default faceting formula for the plots (only
returned if both estimators are requested in the <code>"sparseLTS"</code>
method).</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Andreas Alfons
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coefPlot">coefPlot</a></code>, <code><a href="#topic+rlars">rlars</a></code>,
<code><a href="#topic+grplars">grplars</a></code>, <code><a href="#topic+rgrplars">rgrplars</a></code>, <code><a href="#topic+tslarsP">tslarsP</a></code>,
<code><a href="#topic+rtslarsP">rtslarsP</a></code>, <code><a href="#topic+tslars">tslars</a></code>, <code><a href="#topic+rtslars">rtslars</a></code>,
<code><a href="#topic+sparseLTS">sparseLTS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate data
# example is not high-dimensional to keep computation time low
library("mvtnorm")
set.seed(1234)  # for reproducibility
n &lt;- 100  # number of observations
p &lt;- 25   # number of variables
beta &lt;- rep.int(c(1, 0), c(5, p-5))  # coefficients
sigma &lt;- 0.5      # controls signal-to-noise ratio
epsilon &lt;- 0.1    # contamination level
Sigma &lt;- 0.5^t(sapply(1:p, function(i, j) abs(i-j), 1:p))
x &lt;- rmvnorm(n, sigma=Sigma)    # predictor matrix
e &lt;- rnorm(n)                   # error terms
i &lt;- 1:ceiling(epsilon*n)       # observations to be contaminated
e[i] &lt;- e[i] + 5                # vertical outliers
y &lt;- c(x %*% beta + sigma * e)  # response
x[i,] &lt;- x[i,] + 5              # bad leverage points


## robust LARS
# fit model
fitRlars &lt;- rlars(x, y, sMax = 10)
# extract information for plotting
setup &lt;- setupCoefPlot(fitRlars)
coefPlot(setup)


## sparse LTS over a grid of values for lambda
# fit model
frac &lt;- seq(0.2, 0.05, by = -0.05)
fitSparseLTS &lt;- sparseLTS(x, y, lambda = frac, mode = "fraction")
# extract information for plotting
setup1 &lt;- setupCoefPlot(fitSparseLTS)
coefPlot(setup1)
setup2 &lt;- setupCoefPlot(fitSparseLTS, fit = "both")
coefPlot(setup2)
</code></pre>

<hr>
<h2 id='setupCritPlot'>Set up an optimality criterion plot of a sequence of regression models</h2><span id='topic+setupCritPlot'></span><span id='topic+setupCritPlot.rlars'></span><span id='topic+setupCritPlot.grplars'></span><span id='topic+setupCritPlot.tslarsP'></span><span id='topic+setupCritPlot.seqModel'></span><span id='topic+setupCritPlot.tslars'></span><span id='topic+setupCritPlot.sparseLTS'></span><span id='topic+setupCritPlot.perrySeqModel'></span><span id='topic+setupCritPlot.perrySparseLTS'></span>

<h3>Description</h3>

<p>Extract the relevent information for a plot of the values of the optimality
criterion for a sequence of regression models, such as submodels along a
robust or groupwise least angle regression sequence, or sparse least trimmed
squares regression models for a grid of values for the penalty parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setupCritPlot(object, ...)

## S3 method for class 'seqModel'
setupCritPlot(object, which = c("line", "dot"), ...)

## S3 method for class 'tslars'
setupCritPlot(object, p, ...)

## S3 method for class 'sparseLTS'
setupCritPlot(
  object,
  which = c("line", "dot"),
  fit = c("reweighted", "raw", "both"),
  ...
)

## S3 method for class 'perrySeqModel'
setupCritPlot(object, which = c("line", "dot", "box", "density"), ...)

## S3 method for class 'perrySparseLTS'
setupCritPlot(
  object,
  which = c("line", "dot", "box", "density"),
  fit = c("reweighted", "raw", "both"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setupCritPlot_+3A_object">object</code></td>
<td>
<p>the model fit from which to extract information.</p>
</td></tr>
<tr><td><code id="setupCritPlot_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed down.</p>
</td></tr>
<tr><td><code id="setupCritPlot_+3A_which">which</code></td>
<td>
<p>a character string specifying the type of plot.  Possible
values are <code>"line"</code> (the default) to plot the (average) results for
each model as a connected line, <code>"dot"</code> to create a dot plot,
<code>"box"</code> to create a box plot, or <code>"density"</code> to create a smooth
density plot.  Note that the last two plots are only available in case of
prediction error estimation via repeated resampling.</p>
</td></tr>
<tr><td><code id="setupCritPlot_+3A_p">p</code></td>
<td>
<p>an integer giving the lag length for which to extract information
(the default is to use the optimal lag length).</p>
</td></tr>
<tr><td><code id="setupCritPlot_+3A_fit">fit</code></td>
<td>
<p>a character string specifying for which estimator to extract
information.  Possible values are <code>"reweighted"</code> (the default) for
the reweighted fits, <code>"raw"</code> for the raw fits, or <code>"both"</code> for
both estimators.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object inheriting from class <code>"setupCritPlot"</code> with the
following components:
</p>

<dl>
<dt><code>data</code></dt><dd><p>a data frame containing the following columns:
</p>

<dl>
<dt><code>Fit</code></dt><dd><p>a vector or factor containing the identifiers of the
models along the sequence.</p>
</dd>
<dt><code>Name</code></dt><dd><p>a factor specifying the estimator for which the
optimality criterion was estimated (<code>"reweighted"</code> or <code>"raw"</code>;
only returned if both are requested in the <code>"sparseLTS"</code> or
<code>"perrySparseLTS"</code> methods).</p>
</dd>
<dt><code>PE</code></dt><dd><p>the estimated prediction errors (only returned if
applicable).</p>
</dd>
<dt><code>BIC</code></dt><dd><p>the estimated values of the Bayesian information
criterion (only returned if applicable).</p>
</dd>
<dt><code>Lower</code></dt><dd><p>the lower end points of the error bars (only
returned if possible to compute).</p>
</dd>
<dt><code>Upper</code></dt><dd><p>the upper end points of the error bars (only
returned if possible to compute).</p>
</dd>
</dl>

</dd>
<dt><code>which</code></dt><dd><p>a character string specifying the type of plot.</p>
</dd>
<dt><code>grouped</code></dt><dd><p>a logical indicating whether density plots should
be grouped due to multiple model fits along the sequence (only returned
in case of density plots for the <code>"perrySeqModel"</code> and
<code>"perrySparseLTS"</code> methods).</p>
</dd>
<dt><code>includeSE</code></dt><dd><p>a logical indicating whether error bars based on
standard errors are available (only returned in case of line plots or dot
plots).</p>
</dd>
<dt><code>mapping</code></dt><dd><p>default aesthetic mapping for the plots.</p>
</dd>
<dt><code>facets</code></dt><dd><p>default faceting formula for the plots (only
returned if both estimators are requested in the <code>"sparseLTS"</code>
or <code>"perrySparseLTS"</code> methods).</p>
</dd>
<dt><code>tuning</code></dt><dd><p>a data frame containing the grid of tuning parameter
values for which the optimality criterion was estimated (only returned for
the <code>"sparseLTS"</code> and <code>"perrySparseLTS"</code> methods).</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Andreas Alfons
</p>


<h3>See Also</h3>

<p><code><a href="#topic+critPlot">critPlot</a></code>, <code><a href="#topic+rlars">rlars</a></code>,
<code><a href="#topic+grplars">grplars</a></code>, <code><a href="#topic+rgrplars">rgrplars</a></code>, <code><a href="#topic+tslarsP">tslarsP</a></code>,
<code><a href="#topic+rtslarsP">rtslarsP</a></code>, <code><a href="#topic+tslars">tslars</a></code>, <code><a href="#topic+rtslars">rtslars</a></code>,
<code><a href="#topic+sparseLTS">sparseLTS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate data
# example is not high-dimensional to keep computation time low
library("mvtnorm")
set.seed(1234)  # for reproducibility
n &lt;- 100  # number of observations
p &lt;- 25   # number of variables
beta &lt;- rep.int(c(1, 0), c(5, p-5))  # coefficients
sigma &lt;- 0.5      # controls signal-to-noise ratio
epsilon &lt;- 0.1    # contamination level
Sigma &lt;- 0.5^t(sapply(1:p, function(i, j) abs(i-j), 1:p))
x &lt;- rmvnorm(n, sigma=Sigma)    # predictor matrix
e &lt;- rnorm(n)                   # error terms
i &lt;- 1:ceiling(epsilon*n)       # observations to be contaminated
e[i] &lt;- e[i] + 5                # vertical outliers
y &lt;- c(x %*% beta + sigma * e)  # response
x[i,] &lt;- x[i,] + 5              # bad leverage points


## robust LARS
# fit model
fitRlars &lt;- rlars(x, y, sMax = 10)
# extract information for plotting
setup &lt;- setupCritPlot(fitRlars)
critPlot(setup)


## sparse LTS over a grid of values for lambda
# fit model
frac &lt;- seq(0.2, 0.05, by = -0.05)
fitSparseLTS &lt;- sparseLTS(x, y, lambda = frac, mode = "fraction")
# extract information for plotting
setup1 &lt;- setupCritPlot(fitSparseLTS)
critPlot(setup1)
setup2 &lt;- setupCritPlot(fitSparseLTS, fit = "both")
critPlot(setup2)
</code></pre>

<hr>
<h2 id='setupDiagnosticPlot'>Set up a diagnostic plot for a sequence of regression models</h2><span id='topic+setupDiagnosticPlot'></span><span id='topic+setupDiagnosticPlot.rlars'></span><span id='topic+setupDiagnosticPlot.grplars'></span><span id='topic+setupDiagnosticPlot.tslarsP'></span><span id='topic+setupDiagnosticPlot.seqModel'></span><span id='topic+setupDiagnosticPlot.perrySeqModel'></span><span id='topic+setupDiagnosticPlot.tslars'></span><span id='topic+setupDiagnosticPlot.sparseLTS'></span><span id='topic+setupDiagnosticPlot.perrySparseLTS'></span>

<h3>Description</h3>

<p>Extract the fitted values and residuals of a sequence of regression models
(such as robust least angle regression models or sparse least trimmed
squares regression models) and other useful information for diagnostic
plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setupDiagnosticPlot(object, ...)

## S3 method for class 'seqModel'
setupDiagnosticPlot(object, s = NA, covArgs = list(...), ...)

## S3 method for class 'perrySeqModel'
setupDiagnosticPlot(object, ...)

## S3 method for class 'tslars'
setupDiagnosticPlot(object, p, ...)

## S3 method for class 'sparseLTS'
setupDiagnosticPlot(
  object,
  s = NA,
  fit = c("reweighted", "raw", "both"),
  covArgs = list(...),
  ...
)

## S3 method for class 'perrySparseLTS'
setupDiagnosticPlot(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setupDiagnosticPlot_+3A_object">object</code></td>
<td>
<p>the model fit from which to extract information.</p>
</td></tr>
<tr><td><code id="setupDiagnosticPlot_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to
<code><a href="robustbase.html#topic+covMcd">covMcd</a></code> can be specified directly instead of via
<code>covArgs</code>.</p>
</td></tr>
<tr><td><code id="setupDiagnosticPlot_+3A_s">s</code></td>
<td>
<p>for the <code>"seqModel"</code> method, an integer vector giving the
steps of the submodels from which to extract information (the default is to
use the optimal submodel).  For the <code>"sparseLTS"</code> method, an integer
vector giving the indices of the models from which to extract information
(the default is to use the optimal model for each of the requested fits).</p>
</td></tr>
<tr><td><code id="setupDiagnosticPlot_+3A_covargs">covArgs</code></td>
<td>
<p>a list of arguments to be passed to
<code><a href="robustbase.html#topic+covMcd">covMcd</a></code> for computing robust Mahalanobis distances.</p>
</td></tr>
<tr><td><code id="setupDiagnosticPlot_+3A_p">p</code></td>
<td>
<p>an integer giving the lag length for which to extract information
(the default is to use the optimal lag length).</p>
</td></tr>
<tr><td><code id="setupDiagnosticPlot_+3A_fit">fit</code></td>
<td>
<p>a character string specifying from which fit to extract
information.  Possible values are <code>"reweighted"</code> (the default) to
convert the reweighted fit, <code>"raw"</code> to convert the raw fit, or
<code>"both"</code> to convert both fits.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the argument <code>alpha</code> for controlling the subset size
behaves differently for <code><a href="#topic+sparseLTS">sparseLTS</a></code> than for
<code><a href="robustbase.html#topic+covMcd">covMcd</a></code>.  For <code><a href="#topic+sparseLTS">sparseLTS</a></code>, the subset
size <code class="reqn">h</code> is determined by the fraction <code>alpha</code> of the number of
observations <code class="reqn">n</code>.  For <code><a href="robustbase.html#topic+covMcd">covMcd</a></code>, on the other
hand, the subset size also depends on the number of variables <code class="reqn">p</code> (see
<code><a href="robustbase.html#topic+h.alpha.n">h.alpha.n</a></code>).  However, the <code>"sparseLTS"</code> and
<code>"perrySparseLTS"</code> methods attempt to compute the MCD using the same
subset size that is used to compute the sparse least trimmed squares
regressions.  This may not be possible if the number of selected variables
is large compared to the number of observations, in which case a warning is
given and <code>NA</code>s are returned for the robust Mahalanobis distances.
</p>


<h3>Value</h3>

<p>An object of class <code>"setupDiagnosticPlot"</code> with the following
components:
</p>

<dl>
<dt><code>data</code></dt><dd><p>a data frame containing the columns listed below.
</p>

<dl>
<dt><code>step</code></dt><dd><p>the steps (for the <code>"seqModel"</code> method) or
indices (for the <code>"sparseLTS"</code> method) of the models (only returned
if more than one model is requested).</p>
</dd>
<dt><code>fit</code></dt><dd><p>the model fits (only returned if both the reweighted
and raw fit are requested in the <code>"sparseLTS"</code> method).</p>
</dd>
<dt><code>index</code></dt><dd><p>the indices of the observations.</p>
</dd>
<dt><code>fitted</code></dt><dd><p>the fitted values.</p>
</dd>
<dt><code>residual</code></dt><dd><p>the standardized residuals.</p>
</dd>
<dt><code>theoretical</code></dt><dd><p>the corresponding theoretical quantiles from
the standard normal distribution.</p>
</dd>
<dt><code>qqd</code></dt><dd><p>the absolute distances from a reference line through
the first and third sample and theoretical quartiles.</p>
</dd>
<dt><code>rd</code></dt><dd><p>the robust Mahalanobis distances computed via the
minimum covariance determinant (MCD) estimator (see
<code><a href="robustbase.html#topic+covMcd">covMcd</a></code>).</p>
</dd>
<dt><code>xyd</code></dt><dd><p>the pairwise maxima of the absolute values of the
standardized residuals and the robust Mahalanobis distances, divided by
the respective other outlier detection cutoff point.</p>
</dd>
<dt><code>weight</code></dt><dd><p>the weights indicating regression outliers.</p>
</dd>
<dt><code>leverage</code></dt><dd><p>logicals indicating leverage points (i.e.,
outliers in the predictor space).</p>
</dd>
<dt><code>Diagnostics</code></dt><dd><p>a factor with levels <code>"Potential outlier"</code>
(potential regression outliers) and <code>"Regular observation"</code> (data
points following the model).</p>
</dd>
</dl>
</dd>
<dt><code>qqLine</code></dt><dd><p>a data frame containing the intercepts and slopes of
the respective reference lines to be displayed in residual Q-Q plots.</p>
</dd>
<dt><code>q</code></dt><dd><p>a data frame containing the quantiles of the Mahalanobis
distribution used as cutoff points for detecting leverage points.</p>
</dd>
<dt><code>facets</code></dt><dd><p>default faceting formula for the diagnostic plots
(only returned where applicable).</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Andreas Alfons
</p>


<h3>See Also</h3>

<p><code><a href="#topic+diagnosticPlot">diagnosticPlot</a></code>, <code><a href="#topic+rlars">rlars</a></code>,
<code><a href="#topic+grplars">grplars</a></code>, <code><a href="#topic+rgrplars">rgrplars</a></code>, <code><a href="#topic+tslarsP">tslarsP</a></code>,
<code><a href="#topic+rtslarsP">rtslarsP</a></code>, <code><a href="#topic+tslars">tslars</a></code>, <code><a href="#topic+rtslars">rtslars</a></code>,
<code><a href="#topic+sparseLTS">sparseLTS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate data
# example is not high-dimensional to keep computation time low
library("mvtnorm")
set.seed(1234)  # for reproducibility
n &lt;- 100  # number of observations
p &lt;- 25   # number of variables
beta &lt;- rep.int(c(1, 0), c(5, p-5))  # coefficients
sigma &lt;- 0.5      # controls signal-to-noise ratio
epsilon &lt;- 0.1    # contamination level
Sigma &lt;- 0.5^t(sapply(1:p, function(i, j) abs(i-j), 1:p))
x &lt;- rmvnorm(n, sigma=Sigma)    # predictor matrix
e &lt;- rnorm(n)                   # error terms
i &lt;- 1:ceiling(epsilon*n)       # observations to be contaminated
e[i] &lt;- e[i] + 5                # vertical outliers
y &lt;- c(x %*% beta + sigma * e)  # response
x[i,] &lt;- x[i,] + 5              # bad leverage points


## robust LARS
# fit model
fitRlars &lt;- rlars(x, y, sMax = 10)
# extract information for plotting
setup &lt;- setupDiagnosticPlot(fitRlars)
diagnosticPlot(setup)


## sparse LTS
# fit model
fitSparseLTS &lt;- sparseLTS(x, y, lambda = 0.05, mode = "fraction")
# extract information for plotting
setup1 &lt;- setupDiagnosticPlot(fitSparseLTS)
diagnosticPlot(setup1)
setup2 &lt;- setupDiagnosticPlot(fitSparseLTS, fit = "both")
diagnosticPlot(setup2)
</code></pre>

<hr>
<h2 id='sparseLTS'>Sparse least trimmed squares regression</h2><span id='topic+sparseLTS'></span><span id='topic+print.sparseLTS'></span><span id='topic+sparseLTS.formula'></span><span id='topic+sparseLTS.default'></span>

<h3>Description</h3>

<p>Compute least trimmed squares regression with an <code class="reqn">L_{1}</code> penalty on
the regression coefficients, which allows for sparse model estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparseLTS(x, ...)

## S3 method for class 'formula'
sparseLTS(formula, data, ...)

## Default S3 method:
sparseLTS(
  x,
  y,
  lambda,
  mode = c("lambda", "fraction"),
  alpha = 0.75,
  normalize = TRUE,
  intercept = TRUE,
  nsamp = c(500, 10),
  initial = c("sparse", "hyperplane", "random"),
  ncstep = 2,
  use.correction = TRUE,
  tol = .Machine$double.eps^0.5,
  eps = .Machine$double.eps,
  use.Gram,
  crit = c("BIC", "PE"),
  splits = foldControl(),
  cost = rtmspe,
  costArgs = list(),
  selectBest = c("hastie", "min"),
  seFactor = 1,
  ncores = 1,
  cl = NULL,
  seed = NULL,
  model = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sparseLTS_+3A_x">x</code></td>
<td>
<p>a numeric matrix containing the predictor variables.</p>
</td></tr>
<tr><td><code id="sparseLTS_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed down.</p>
</td></tr>
<tr><td><code id="sparseLTS_+3A_formula">formula</code></td>
<td>
<p>a formula describing the model.</p>
</td></tr>
<tr><td><code id="sparseLTS_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible
to a data frame by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code>) containing the variables in
the model.  If not found in data, the variables are taken from
<code>environment(formula)</code>, typically the environment from which
<code>sparseLTS</code> is called.</p>
</td></tr>
<tr><td><code id="sparseLTS_+3A_y">y</code></td>
<td>
<p>a numeric vector containing the response variable.</p>
</td></tr>
<tr><td><code id="sparseLTS_+3A_lambda">lambda</code></td>
<td>
<p>a numeric vector of non-negative values to be used as penalty
parameter.</p>
</td></tr>
<tr><td><code id="sparseLTS_+3A_mode">mode</code></td>
<td>
<p>a character string specifying the type of penalty parameter.  If
<code>"lambda"</code>, <code>lambda</code> gives the grid of values for the penalty
parameter directly.  If <code>"fraction"</code>, the smallest value of the penalty
parameter that sets all coefficients to 0 is first estimated based on
bivariate winsorization, then <code>lambda</code> gives the fractions of that
estimate to be used (hence all values of <code>lambda</code> should be in the
interval [0,1] in that case).</p>
</td></tr>
<tr><td><code id="sparseLTS_+3A_alpha">alpha</code></td>
<td>
<p>a numeric value giving the percentage of the residuals for
which the <code class="reqn">L_{1}</code> penalized sum of squares should be minimized (the
default is 0.75).</p>
</td></tr>
<tr><td><code id="sparseLTS_+3A_normalize">normalize</code></td>
<td>
<p>a logical indicating whether the predictor variables
should be normalized to have unit <code class="reqn">L_{2}</code> norm (the default is
<code>TRUE</code>).  Note that normalization is performed on the subsamples
rather than the full data set.</p>
</td></tr>
<tr><td><code id="sparseLTS_+3A_intercept">intercept</code></td>
<td>
<p>a logical indicating whether a constant term should be
included in the model (the default is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="sparseLTS_+3A_nsamp">nsamp</code></td>
<td>
<p>a numeric vector giving the number of subsamples to be used in
the two phases of the algorithm.  The first element gives the number of
initial subsamples to be used.  The second element gives the number of
subsamples to keep after the first phase of <code>ncstep</code> C-steps.  For
those remaining subsets, additional C-steps are performed until
convergence.  The default is to first perform <code>ncstep</code> C-steps on 500
initial subsamples, and then to keep the 10 subsamples with the lowest value
of the objective function for additional C-steps until convergence.</p>
</td></tr>
<tr><td><code id="sparseLTS_+3A_initial">initial</code></td>
<td>
<p>a character string specifying the type of initial subsamples
to be used.  If <code>"sparse"</code>, the lasso fit given by three randomly
selected data points is first computed.  The corresponding initial subsample
is then formed by the fraction <code>alpha</code> of data points with the smallest
squared residuals.  Note that this is optimal from a robustness point of
view, as the probability of including an outlier in the initial lasso fit is
minimized.  If <code>"hyperplane"</code>, a hyperplane through <code class="reqn">p</code> randomly
selected data points is first computed, where <code class="reqn">p</code> denotes the number of
variables.  The corresponding initial subsample is then again formed by the
fraction <code>alpha</code> of data points with the smallest squared residuals.
Note that this cannot be applied if <code class="reqn">p</code> is larger than the number of
observations.  Nevertheless, the probability of including an outlier
increases with increasing dimension <code class="reqn">p</code>.  If <code>"random"</code>, the
initial subsamples are given by a fraction <code>alpha</code> of randomly
selected data points.  Note that this leads to the largest probability of
including an outlier.</p>
</td></tr>
<tr><td><code id="sparseLTS_+3A_ncstep">ncstep</code></td>
<td>
<p>a positive integer giving the number of C-steps to perform on
all subsamples in the first phase of the algorithm (the default is to
perform two C-steps).</p>
</td></tr>
<tr><td><code id="sparseLTS_+3A_use.correction">use.correction</code></td>
<td>
<p>currently ignored.  Small sample correction factors
may be added in the future.</p>
</td></tr>
<tr><td><code id="sparseLTS_+3A_tol">tol</code></td>
<td>
<p>a small positive numeric value giving the tolerance for
convergence.</p>
</td></tr>
<tr><td><code id="sparseLTS_+3A_eps">eps</code></td>
<td>
<p>a small positive numeric value used to determine whether the
variability within a variable is too small (an effective zero).</p>
</td></tr>
<tr><td><code id="sparseLTS_+3A_use.gram">use.Gram</code></td>
<td>
<p>a logical indicating whether the Gram matrix of the
explanatory variables should be precomputed in the lasso fits on the
subsamples.  If the number of variables is large, computation may be faster
when this is set to <code>FALSE</code>.  The default is to use <code>TRUE</code> if the
number of variables is smaller than the number of observations in the
subsamples and smaller than 100, and <code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="sparseLTS_+3A_crit">crit</code></td>
<td>
<p>a character string specifying the optimality criterion to be
used for selecting the final model.  Possible values are <code>"BIC"</code> for
the Bayes information criterion and <code>"PE"</code> for resampling-based
prediction error estimation.  This is ignored if <code>lambda</code> contains
only one value of the penalty parameter, as selecting the optimal value
is trivial in that case.</p>
</td></tr>
<tr><td><code id="sparseLTS_+3A_splits">splits</code></td>
<td>
<p>an object giving data splits to be used for prediction error
estimation (see <code><a href="perry.html#topic+perryTuning">perryTuning</a></code>).  This is only relevant
if selecting the optimal <code>lambda</code> via prediction error estimation.</p>
</td></tr>
<tr><td><code id="sparseLTS_+3A_cost">cost</code></td>
<td>
<p>a cost function measuring prediction loss (see
<code><a href="perry.html#topic+perryTuning">perryTuning</a></code> for some requirements).  The
default is to use the root trimmed mean squared prediction error
(see <code><a href="perry.html#topic+cost">cost</a></code>).  This is only relevant if selecting
the optimal <code>lambda</code> via prediction error estimation.</p>
</td></tr>
<tr><td><code id="sparseLTS_+3A_costargs">costArgs</code></td>
<td>
<p>a list of additional arguments to be passed to the
prediction loss function <code>cost</code>.  This is only relevant if
selecting the optimal <code>lambda</code> via prediction error estimation.</p>
</td></tr>
<tr><td><code id="sparseLTS_+3A_selectbest">selectBest</code>, <code id="sparseLTS_+3A_sefactor">seFactor</code></td>
<td>
<p>arguments specifying a criterion for selecting
the best model (see <code><a href="perry.html#topic+perryTuning">perryTuning</a></code>).  The default is to
use a one-standard-error rule.  This is only relevant if selecting the
optimal <code>lambda</code> via prediction error estimation.</p>
</td></tr>
<tr><td><code id="sparseLTS_+3A_ncores">ncores</code></td>
<td>
<p>a positive integer giving the number of processor cores to be
used for parallel computing (the default is 1 for no parallelization).  If
this is set to <code>NA</code>, all available processor cores are used.  For
prediction error estimation, parallel computing is implemented on the <span class="rlang"><b>R</b></span>
level using package <span class="pkg">parallel</span>.  Otherwise parallel computing is
implemented on the C++ level  via OpenMP (<a href="https://www.openmp.org/">https://www.openmp.org/</a>).</p>
</td></tr>
<tr><td><code id="sparseLTS_+3A_cl">cl</code></td>
<td>
<p>a <span class="pkg">parallel</span> cluster for parallel computing as generated by
<code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>.  This is preferred over <code>ncores</code>
for prediction error estimation, in which case <code>ncores</code> is only used on
the C++ level for computing the final model.</p>
</td></tr>
<tr><td><code id="sparseLTS_+3A_seed">seed</code></td>
<td>
<p>optional initial seed for the random number generator (see
<code><a href="base.html#topic+.Random.seed">.Random.seed</a></code>).  On parallel <span class="rlang"><b>R</b></span> worker processes for prediction
error estimation, random number streams are used and the seed is set via
<code><a href="parallel.html#topic+clusterSetRNGStream">clusterSetRNGStream</a></code>.</p>
</td></tr>
<tr><td><code id="sparseLTS_+3A_model">model</code></td>
<td>
<p>a logical indicating whether the data <code>x</code> and <code>y</code>
should be added to the return object.  If <code>intercept</code> is <code>TRUE</code>,
a column of ones is added to <code>x</code> to account for the intercept.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>crit</code> is <code>"PE"</code> and <code>lambda</code> contains more than one
value of the penalty parameter, an object of class <code>"perrySparseLTS"</code>
(inheriting from class <code>"perryTuning"</code>, see
<code><a href="perry.html#topic+perryTuning">perryTuning</a></code>).  It contains information on the
prediction error criterion, and includes the final model with the optimal
tuning paramter as component <code>finalModel</code>.
</p>
<p>Otherwise an object of class <code>"sparseLTS"</code> with the following
components:
</p>

<dl>
<dt><code>lambda</code></dt><dd><p>a numeric vector giving the values of the penalty
parameter.</p>
</dd>
<dt><code>best</code></dt><dd><p>an integer vector or matrix containing the respective
best subsets of <code class="reqn">h</code> observations found and used for computing the raw
estimates.</p>
</dd>
<dt><code>objective</code></dt><dd><p>a numeric vector giving the respective values of
the sparse LTS objective function, i.e., the <code class="reqn">L_{1}</code> penalized
sums of the <code class="reqn">h</code> smallest squared residuals from the raw fits.</p>
</dd>
<dt><code>coefficients</code></dt><dd><p>a numeric vector or matrix containing the
respective coefficient estimates from the reweighted fits.</p>
</dd>
<dt><code>fitted.values</code></dt><dd><p>a numeric vector or matrix containing the
respective fitted values of the response from the reweighted fits.</p>
</dd>
<dt><code>residuals</code></dt><dd><p>a numeric vector or matrix containing the
respective residuals from the reweighted fits.</p>
</dd>
<dt><code>center</code></dt><dd><p>a numeric vector giving the robust center estimates
of the corresponding reweighted residuals.</p>
</dd>
<dt><code>scale</code></dt><dd><p>a numeric vector giving the robust scale estimates of
the corresponding reweighted residuals.</p>
</dd>
<dt><code>cnp2</code></dt><dd><p>a numeric vector giving the respective consistency
factors applied to the scale estimates of the reweighted residuals.</p>
</dd>
<dt><code>wt</code></dt><dd><p>an integer vector or matrix containing binary weights
that indicate outliers from the respective reweighted fits, i.e., the
weights are <code class="reqn">1</code> for observations with reasonably small reweighted
residuals and <code class="reqn">0</code> for observations with large reweighted residuals.</p>
</dd>
<dt><code>df</code></dt><dd><p>an integer vector giving the respective degrees of
freedom of the obtained reweighted model fits, i.e., the number of
nonzero coefficient estimates.</p>
</dd>
<dt><code>intercept</code></dt><dd><p>a logical indicating whether the model includes a
constant term.</p>
</dd>
<dt><code>alpha</code></dt><dd><p>a numeric value giving the percentage of the residuals
for which the <code class="reqn">L_{1}</code> penalized sum of squares was minimized.</p>
</dd>
<dt><code>quan</code></dt><dd><p>the number <code class="reqn">h</code> of observations used to compute the
raw estimates.</p>
</dd>
<dt><code>raw.coefficients</code></dt><dd><p>a numeric vector or matrix containing the
respective coefficient estimates from the raw fits.</p>
</dd>
<dt><code>raw.fitted.values</code></dt><dd><p>a numeric vector or matrix containing the
respective fitted values of the response from the raw fits.</p>
</dd>
<dt><code>raw.residuals</code></dt><dd><p>a numeric vector or matrix containing the
respective residuals from the raw fits.</p>
</dd>
<dt><code>raw.center</code></dt><dd><p>a numeric vector giving the robust center
estimates of the corresponding raw residuals.</p>
</dd>
<dt><code>raw.scale</code></dt><dd><p>a numeric vector giving the robust scale estimates
of the corresponding raw residuals.</p>
</dd>
<dt><code>raw.cnp2</code></dt><dd><p>a numeric value giving the consistency factor
applied to the scale estimate of the raw residuals.</p>
</dd>
<dt><code>raw.wt</code></dt><dd><p>an integer vector or matrix containing binary weights
that indicate outliers from the respective raw fits, i.e., the weights
used for the reweighted fits.</p>
</dd>
<dt><code>crit</code></dt><dd><p>an object of class <code>"bicSelect"</code> containing the
BIC values and indicating the final model (only returned if argument
<code>crit</code> is <code>"BIC"</code> and argument <code>lambda</code> contains more
than one value for the penalty parameter).</p>
</dd>
<dt><code>x</code></dt><dd><p>the predictor matrix (if <code>model</code> is <code>TRUE</code>).</p>
</dd>
<dt><code>y</code></dt><dd><p>the response variable (if <code>model</code> is <code>TRUE</code>).</p>
</dd>
<dt><code>call</code></dt><dd><p>the matched function call.</p>
</dd>
</dl>



<h3>Note</h3>

<p>The underlying C++ code uses the C++ library Armadillo.  From package
version 0.6.0, the back end for sparse least trimmed squares from package
<span class="pkg">sparseLTSEigen</span>, which uses the C++ library Eigen, is no longer
supported and can no longer be used.
</p>
<p>Parallel computing is implemented via OpenMP (<a href="https://www.openmp.org/">https://www.openmp.org/</a>).
</p>


<h3>Author(s)</h3>

<p>Andreas Alfons
</p>


<h3>References</h3>

<p>Alfons, A., Croux, C. and Gelper, S. (2013) Sparse least trimmed squares
regression for analyzing high-dimensional large data sets. <em>The Annals
of Applied Statistics</em>, <b>7</b>(1), 226&ndash;248. <a href="https://doi.org/10.1214/12-AOAS575">doi:10.1214/12-AOAS575</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coef.sparseLTS">coef</a></code>,
<code><a href="#topic+fitted.sparseLTS">fitted</a></code>,
<code><a href="#topic+plot.sparseLTS">plot</a></code>,
<code><a href="#topic+predict.sparseLTS">predict</a></code>,
<code><a href="#topic+residuals.sparseLTS">residuals</a></code>,
<code><a href="#topic+rstandard.sparseLTS">rstandard</a></code>,
<code><a href="#topic+weights.sparseLTS">weights</a></code>,
<code><a href="robustbase.html#topic+ltsReg">ltsReg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate data
# example is not high-dimensional to keep computation time low
library("mvtnorm")
set.seed(1234)  # for reproducibility
n &lt;- 100  # number of observations
p &lt;- 25   # number of variables
beta &lt;- rep.int(c(1, 0), c(5, p-5))  # coefficients
sigma &lt;- 0.5      # controls signal-to-noise ratio
epsilon &lt;- 0.1    # contamination level
Sigma &lt;- 0.5^t(sapply(1:p, function(i, j) abs(i-j), 1:p))
x &lt;- rmvnorm(n, sigma=Sigma)    # predictor matrix
e &lt;- rnorm(n)                   # error terms
i &lt;- 1:ceiling(epsilon*n)       # observations to be contaminated
e[i] &lt;- e[i] + 5                # vertical outliers
y &lt;- c(x %*% beta + sigma * e)  # response
x[i,] &lt;- x[i,] + 5              # bad leverage points

## fit sparse LTS model for one value of lambda
sparseLTS(x, y, lambda = 0.05, mode = "fraction")

## fit sparse LTS models over a grid of values for lambda
frac &lt;- seq(0.2, 0.05, by = -0.05)
sparseLTS(x, y, lambda = frac, mode = "fraction")
</code></pre>

<hr>
<h2 id='standardize'>Data standardization</h2><span id='topic+standardize'></span><span id='topic+robStandardize'></span>

<h3>Description</h3>

<p>Standardize data with given functions for computing center and scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardize(x, centerFun = mean, scaleFun = sd)

robStandardize(
  x,
  centerFun = median,
  scaleFun = mad,
  fallback = FALSE,
  eps = .Machine$double.eps,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="standardize_+3A_x">x</code></td>
<td>
<p>a numeric vector, matrix or data frame to be standardized.</p>
</td></tr>
<tr><td><code id="standardize_+3A_centerfun">centerFun</code></td>
<td>
<p>a function to compute an estimate of the center of a
variable (defaults to <code><a href="base.html#topic+mean">mean</a></code>).</p>
</td></tr>
<tr><td><code id="standardize_+3A_scalefun">scaleFun</code></td>
<td>
<p>a function to compute an estimate of the scale of a
variable (defaults to <code><a href="stats.html#topic+sd">sd</a></code>).</p>
</td></tr>
<tr><td><code id="standardize_+3A_fallback">fallback</code></td>
<td>
<p>a logical indicating whether standardization with
<code><a href="base.html#topic+mean">mean</a></code> and <code><a href="stats.html#topic+sd">sd</a></code> should be performed as a
fallback mode for variables whose robust scale estimate is too small.  This
is useful, e.g., for data containing dummy variables.</p>
</td></tr>
<tr><td><code id="standardize_+3A_eps">eps</code></td>
<td>
<p>a small positive numeric value used to determine whether the
robust scale estimate of a variable is too small (an effective zero).</p>
</td></tr>
<tr><td><code id="standardize_+3A_...">...</code></td>
<td>
<p>currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>robStandardize</code> is a wrapper function for robust standardization,
hence the default is to use <code><a href="stats.html#topic+median">median</a></code> and
<code><a href="stats.html#topic+mad">mad</a></code>.
</p>


<h3>Value</h3>

<p>An object of the same type as the original data <code>x</code> containing
the centered and scaled data.  The center and scale estimates of the
original data are returned as attributes <code>"center"</code> and <code>"scale"</code>,
respectively.
</p>


<h3>Note</h3>

<p>The implementation contains special cases for the typically used
combinations <code><a href="base.html#topic+mean">mean</a></code>/<code><a href="stats.html#topic+sd">sd</a></code> and
<code><a href="stats.html#topic+median">median</a></code>/<code><a href="stats.html#topic+mad">mad</a></code> in order to reduce
computation time.
</p>


<h3>Author(s)</h3>

<p>Andreas Alfons
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+scale">scale</a></code>, <code><a href="base.html#topic+sweep">sweep</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate data
set.seed(1234)     # for reproducibility
x &lt;- rnorm(10)     # standard normal
x[1] &lt;- x[1] * 10  # introduce outlier

## standardize data
x
standardize(x)     # mean and sd
robStandardize(x)  # median and MAD

</code></pre>

<hr>
<h2 id='TopGear'>Top Gear car data</h2><span id='topic+TopGear'></span>

<h3>Description</h3>

<p>The data set contains information on cars featured on the website of the
popular BBC television show <em>Top Gear</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("TopGear")
</code></pre>


<h3>Format</h3>

<p>A data frame with 297 observations on the following 32 variables.
</p>

<dl>
<dt><code>Maker</code></dt><dd><p>factor; the car maker.</p>
</dd>
<dt><code>Model</code></dt><dd><p>factor; the car model.</p>
</dd>
<dt><code>Type</code></dt><dd><p>factor; the exact model type.</p>
</dd>
<dt><code>Fuel</code></dt><dd><p>factor; the type of fuel (<code>"Diesel"</code> or
<code>"Petrol"</code>).</p>
</dd>
<dt><code>Price</code></dt><dd><p>numeric; the list price (in UK pounds)</p>
</dd>
<dt><code>Cylinders</code></dt><dd><p>numeric; the number of cylinders in the engine.</p>
</dd>
<dt><code>Displacement</code></dt><dd><p>numeric; the displacement of the engine (in
cc).</p>
</dd>
<dt><code>DriveWheel</code></dt><dd><p>factor; the type of drive wheel (<code>"4WD"</code>,
<code>"Front"</code> or <code>"Rear"</code>).</p>
</dd>
<dt><code>BHP</code></dt><dd><p>numeric; the power of the engine (in bhp).</p>
</dd>
<dt><code>Torque</code></dt><dd><p>numeric; the torque of the engine (in lb/ft).</p>
</dd>
<dt><code>Acceleration</code></dt><dd><p>numeric; the time it takes the car to get from
0 to 62 mph (in seconds).</p>
</dd>
<dt><code>TopSpeed</code></dt><dd><p>numeric; the car's top speed (in mph).</p>
</dd>
<dt><code>MPG</code></dt><dd><p>numeric; the combined fuel consuption (urban + extra
urban; in miles per gallon).</p>
</dd>
<dt><code>Weight</code></dt><dd><p>numeric; the car's curb weight (in kg).</p>
</dd>
<dt><code>Length</code></dt><dd><p>numeric; the car's length (in mm).</p>
</dd>
<dt><code>Width</code></dt><dd><p>numeric; the car's width (in mm).</p>
</dd>
<dt><code>Height</code></dt><dd><p>numeric; the car's height (in mm).</p>
</dd>
<dt><code>AdaptiveHeadlights</code></dt><dd><p>factor; whether the car has adaptive
headlights (<code>"no"</code>, <code>"optional"</code> or <code>"standard"</code>).</p>
</dd>
<dt><code>AdjustableSteering</code></dt><dd><p>factor; whether the car has adjustable
steering (<code>"no"</code> or <code>"standard"</code>).</p>
</dd>
<dt><code>AlarmSystem</code></dt><dd><p>factor; whether the car has an alarm system
(<code>"no/optional"</code> or <code>"standard"</code>).</p>
</dd>
<dt><code>Automatic</code></dt><dd><p>factor; whether the car has an automatic
transmission (<code>"no"</code>, <code>"optional"</code> or <code>"standard"</code>).</p>
</dd>
<dt><code>Bluetooth</code></dt><dd><p>factor; whether the car has bluetooth
(<code>"no"</code>, <code>"optional"</code> or <code>"standard"</code>).</p>
</dd>
<dt><code>ClimateControl</code></dt><dd><p>factor; whether the car has climate control
(<code>"no"</code>, <code>"optional"</code> or <code>"standard"</code>).</p>
</dd>
<dt><code>CruiseControl</code></dt><dd><p>factor; whether the car has cruise control
(<code>"no"</code>, <code>"optional"</code> or <code>"standard"</code>).</p>
</dd>
<dt><code>ElectricSeats</code></dt><dd><p>factor; whether the car has electric seats
(<code>"no"</code>, <code>"optional"</code> or <code>"standard"</code>).</p>
</dd>
<dt><code>Leather</code></dt><dd><p>factor; whether the car has a leather interior
(<code>"no"</code>, <code>"optional"</code> or <code>"standard"</code>).</p>
</dd>
<dt><code>ParkingSensors</code></dt><dd><p>factor; whether the car has parking sensors
(<code>"no"</code>, <code>"optional"</code> or <code>"standard"</code>).</p>
</dd>
<dt><code>PowerSteering</code></dt><dd><p>factor; whether the car has power steering
(<code>"no"</code> or <code>"standard"</code>).</p>
</dd>
<dt><code>SatNav</code></dt><dd><p>factor; whether the car has a satellite navigation
system (<code>"no"</code>, <code>"optional"</code> or <code>"standard"</code>).</p>
</dd>
<dt><code>ESP</code></dt><dd><p>factor; whether the car has ESP (<code>"no"</code>,
<code>"optional"</code> or <code>"standard"</code>).</p>
</dd>
<dt><code>Verdict</code></dt><dd><p>numeric; review score between 1 (lowest) and 10
(highest).</p>
</dd>
<dt><code>Origin</code></dt><dd><p>factor; the origin of the car maker (<code>"Asia"</code>,
<code>"Europe"</code> or <code>"USA"</code>).</p>
</dd>
</dl>



<h3>Source</h3>

<p>The data were scraped from <code>http://www.topgear.com/uk/</code> on 2014-02-24.
Variable <code>Origin</code> was added based on the car maker information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("TopGear")
summary(TopGear)
</code></pre>

<hr>
<h2 id='tsBlocks'>Construct predictor blocks for time series models</h2><span id='topic+tsBlocks'></span>

<h3>Description</h3>

<p>Construct blocks of original and lagged values for autoregressive time
series models with exogenous inputs.  The typical use case is to supply the
output as <code>newdata</code> argument to the
<code><a href="#topic+predict.tslars">predict</a></code> method of robust groupwise least
angle regression models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsBlocks(x, y, p = 2, subset = NULL, intercept = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tsBlocks_+3A_x">x</code></td>
<td>
<p>a numeric matrix or data frame containing the exogenous predictor
series.</p>
</td></tr>
<tr><td><code id="tsBlocks_+3A_y">y</code></td>
<td>
<p>a numeric vector containing the response series.</p>
</td></tr>
<tr><td><code id="tsBlocks_+3A_p">p</code></td>
<td>
<p>an integer giving the number of lags to include (defaults to 2).</p>
</td></tr>
<tr><td><code id="tsBlocks_+3A_subset">subset</code></td>
<td>
<p>a logical or integer vector defining a subset of observations
from which to construct the matrix of predictor blocks.</p>
</td></tr>
<tr><td><code id="tsBlocks_+3A_intercept">intercept</code></td>
<td>
<p>a logical indicating whether a column of ones should be
added to the matrix of predictor blocks to account for the intercept.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing blocks of original and lagged values of the
time series <code>y</code> and <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Andreas Alfons
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.tslars">predict.tslars</a></code>, <code><a href="#topic+tslars">tslars</a></code>,
<code><a href="#topic+predict.tslarsP">predict.tslarsP</a></code>, <code><a href="#topic+tslarsP">tslarsP</a></code>
</p>

<hr>
<h2 id='tslars'>(Robust) least angle regression for time series data</h2><span id='topic+tslars'></span><span id='topic+print.tslars'></span><span id='topic+tslars.formula'></span><span id='topic+tslars.default'></span><span id='topic+rtslars'></span><span id='topic+rtslars.formula'></span><span id='topic+rtslars.default'></span>

<h3>Description</h3>

<p>(Robustly) sequence groups of candidate predictors and their respective
lagged values according to their predictive content and find the optimal
model along the sequence.  Note that lagged values of the response are
included as a predictor group as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tslars(x, ...)

## S3 method for class 'formula'
tslars(formula, data, ...)

## Default S3 method:
tslars(
  x,
  y,
  h = 1,
  pMax = 3,
  sMax = NA,
  fit = TRUE,
  s = c(0, sMax),
  crit = "BIC",
  ncores = 1,
  cl = NULL,
  model = TRUE,
  ...
)

rtslars(x, ...)

## S3 method for class 'formula'
rtslars(formula, data, ...)

## Default S3 method:
rtslars(
  x,
  y,
  h = 1,
  pMax = 3,
  sMax = NA,
  centerFun = median,
  scaleFun = mad,
  regFun = lmrob,
  regArgs = list(),
  combine = c("min", "euclidean", "mahalanobis"),
  winsorize = FALSE,
  const = 2,
  prob = 0.95,
  fit = TRUE,
  s = c(0, sMax),
  crit = "BIC",
  ncores = 1,
  cl = NULL,
  seed = NULL,
  model = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tslars_+3A_x">x</code></td>
<td>
<p>a numeric matrix or data frame containing the candidate predictor
series.</p>
</td></tr>
<tr><td><code id="tslars_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed down.</p>
</td></tr>
<tr><td><code id="tslars_+3A_formula">formula</code></td>
<td>
<p>a formula describing the full model.</p>
</td></tr>
<tr><td><code id="tslars_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible
to a data frame by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code>) containing the variables in
the model.  If not found in data, the variables are taken from
<code>environment(formula)</code>, typically the environment from which
<code>tslars</code> or <code>rtslars</code> is called.</p>
</td></tr>
<tr><td><code id="tslars_+3A_y">y</code></td>
<td>
<p>a numeric vector containing the response series.</p>
</td></tr>
<tr><td><code id="tslars_+3A_h">h</code></td>
<td>
<p>an integer giving the forecast horizon (defaults to 1).</p>
</td></tr>
<tr><td><code id="tslars_+3A_pmax">pMax</code></td>
<td>
<p>an integer giving the maximum number of lags in the model
(defaults to 3).</p>
</td></tr>
<tr><td><code id="tslars_+3A_smax">sMax</code></td>
<td>
<p>an integer giving the number of predictor series to be
sequenced.  If it is <code>NA</code> (the default), predictor groups are sequenced
as long as there are twice as many observations as predictor variables.</p>
</td></tr>
<tr><td><code id="tslars_+3A_fit">fit</code></td>
<td>
<p>a logical indicating whether to fit submodels along the sequence
(<code>TRUE</code>, the default) or to simply return the sequence (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="tslars_+3A_s">s</code></td>
<td>
<p>an integer vector of length two giving the first and last
step along the sequence for which to compute submodels.  The default
is to start with a model containing only an intercept (step 0) and
iteratively add all series along the sequence (step <code>sMax</code>).  If
the second element is <code>NA</code>, predictor groups are added to the
model as long as there are twice as many observations as predictor
variables.  If only one value is supplied, it is recycled.</p>
</td></tr>
<tr><td><code id="tslars_+3A_crit">crit</code></td>
<td>
<p>a character string specifying the optimality criterion to be
used for selecting the final model.  Currently, only <code>"BIC"</code> for the
Bayes information criterion is implemented.</p>
</td></tr>
<tr><td><code id="tslars_+3A_ncores">ncores</code></td>
<td>
<p>a positive integer giving the number of processor cores to be
used for parallel computing (the default is 1 for no parallelization).  If
this is set to <code>NA</code>, all available processor cores are used.  For
each lag length, parallel computing for obtaining the data cleaning weights
and for fitting models along the sequence is implemented on the <span class="rlang"><b>R</b></span> level
using package <span class="pkg">parallel</span>.  Otherwise parallel computing for some of of
the more computer-intensive computations in the sequencing step is
implemented on the C++ level via OpenMP (<a href="https://www.openmp.org/">https://www.openmp.org/</a>).</p>
</td></tr>
<tr><td><code id="tslars_+3A_cl">cl</code></td>
<td>
<p>a <span class="pkg">parallel</span> cluster for parallel computing as generated by
<code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>.  This is preferred over <code>ncores</code>
for tasks that are parallelized on the <span class="rlang"><b>R</b></span> level, in which case <code>ncores</code>
is only used for tasks that are parallelized on the C++ level.</p>
</td></tr>
<tr><td><code id="tslars_+3A_model">model</code></td>
<td>
<p>a logical indicating whether the model data should be included
in the returned object.</p>
</td></tr>
<tr><td><code id="tslars_+3A_centerfun">centerFun</code></td>
<td>
<p>a function to compute a robust estimate for the center
(defaults to <code><a href="stats.html#topic+median">median</a></code>).</p>
</td></tr>
<tr><td><code id="tslars_+3A_scalefun">scaleFun</code></td>
<td>
<p>a function to compute a robust estimate for the scale
(defaults to <code><a href="stats.html#topic+mad">mad</a></code>).</p>
</td></tr>
<tr><td><code id="tslars_+3A_regfun">regFun</code></td>
<td>
<p>a function to compute robust linear regressions that can be
interpreted as weighted least squares (defaults to
<code><a href="robustbase.html#topic+lmrob">lmrob</a></code>).</p>
</td></tr>
<tr><td><code id="tslars_+3A_regargs">regArgs</code></td>
<td>
<p>a list of arguments to be passed to <code>regFun</code>.</p>
</td></tr>
<tr><td><code id="tslars_+3A_combine">combine</code></td>
<td>
<p>a character string specifying how to combine the data
cleaning weights from the robust regressions with each predictor group.
Possible values are <code>"min"</code> for taking the minimum weight for each
observation, <code>"euclidean"</code> for weights based on Euclidean distances
of the multivariate set of standardized residuals (i.e., multivariate
winsorization of the standardized residuals assuming independence), or
<code>"mahalanobis"</code> for weights based on Mahalanobis distances of the
multivariate set of standardized residuals (i.e., multivariate winsorization
of the standardized residuals).</p>
</td></tr>
<tr><td><code id="tslars_+3A_winsorize">winsorize</code></td>
<td>
<p>a logical indicating whether to clean the data by
multivariate winsorization.</p>
</td></tr>
<tr><td><code id="tslars_+3A_const">const</code></td>
<td>
<p>numeric; tuning constant for multivariate winsorization to be
used in the initial corralation estimates based on adjusted univariate
winsorization (defaults to 2).</p>
</td></tr>
<tr><td><code id="tslars_+3A_prob">prob</code></td>
<td>
<p>numeric; probability for the quantile of the
<code class="reqn">\chi^{2}</code> distribution to be used in multivariate
winsorization (defaults to 0.95).</p>
</td></tr>
<tr><td><code id="tslars_+3A_seed">seed</code></td>
<td>
<p>optional initial seed for the random number generator
(see <code><a href="base.html#topic+.Random.seed">.Random.seed</a></code>), which is useful because many robust
regression functions (including <code><a href="robustbase.html#topic+lmrob">lmrob</a></code>) involve
randomness.  On parallel <span class="rlang"><b>R</b></span> worker processes, random number streams are
used and the seed is set via <code><a href="parallel.html#topic+clusterSetRNGStream">clusterSetRNGStream</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>fit</code> is <code>FALSE</code>, an integer matrix in which each column
contains the indices of the sequenced predictor series for the corresponding
lag length.
</p>
<p>Otherwise an object of class <code>"tslars"</code> with the following components:
</p>

<dl>
<dt><code>pFit</code></dt><dd><p>a list containing the fits for the respective lag
lengths (see <code><a href="#topic+tslarsP">tslarsP</a></code>).</p>
</dd>
<dt><code>pOpt</code></dt><dd><p>an integer giving the optimal number of lags.</p>
</dd>
<dt><code>pMax</code></dt><dd><p>the maximum number of lags considered.</p>
</dd>
<dt><code>x</code></dt><dd><p>the matrix of candidate predictor series (if <code>model</code>
is <code>TRUE</code>).</p>
</dd>
<dt><code>y</code></dt><dd><p>the response series (if <code>model</code> is <code>TRUE</code>).</p>
</dd>
<dt><code>call</code></dt><dd><p>the matched function call.</p>
</dd>
</dl>



<h3>Note</h3>

<p>The predictor group of lagged values of the response is indicated by
the index 0.
</p>


<h3>Author(s)</h3>

<p>Andreas Alfons, based on code by Sarah Gelper
</p>


<h3>References</h3>

<p>Alfons, A., Croux, C. and Gelper, S. (2016) Robust groupwise least angle
regression. <em>Computational Statistics &amp; Data Analysis</em>, <b>93</b>,
421&ndash;435. <a href="https://doi.org/10.1016/j.csda.2015.02.007">doi:10.1016/j.csda.2015.02.007</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coef.tslars">coef</a></code>,
<code><a href="#topic+fitted.tslars">fitted</a></code>,
<code><a href="#topic+plot.tslars">plot</a></code>,
<code><a href="#topic+predict.tslars">predict</a></code>,
<code><a href="#topic+residuals.tslars">residuals</a></code>,
<code><a href="#topic+tslarsP">tslarsP</a></code>, <code><a href="robustbase.html#topic+lmrob">lmrob</a></code>
</p>

<hr>
<h2 id='tslarsP'>(Robust) least angle regression for time series data with fixed lag length</h2><span id='topic+tslarsP'></span><span id='topic+print.tslarsP'></span><span id='topic+tslarsP.formula'></span><span id='topic+tslarsP.default'></span><span id='topic+rtslarsP'></span><span id='topic+rtslarsP.formula'></span><span id='topic+rtslarsP.default'></span>

<h3>Description</h3>

<p>(Robustly) sequence groups of candidate predictors and their respective
lagged values according to their predictive content and find the optimal
model along the sequence.  Note that lagged values of the response are
included as a predictor group as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tslarsP(x, ...)

## S3 method for class 'formula'
tslarsP(formula, data, ...)

## Default S3 method:
tslarsP(
  x,
  y,
  h = 1,
  p = 2,
  sMax = NA,
  fit = TRUE,
  s = c(0, sMax),
  crit = "BIC",
  ncores = 1,
  cl = NULL,
  model = TRUE,
  ...
)

rtslarsP(x, ...)

## S3 method for class 'formula'
rtslarsP(formula, data, ...)

## Default S3 method:
rtslarsP(
  x,
  y,
  h = 1,
  p = 2,
  sMax = NA,
  centerFun = median,
  scaleFun = mad,
  regFun = lmrob,
  regArgs = list(),
  combine = c("min", "euclidean", "mahalanobis"),
  winsorize = FALSE,
  const = 2,
  prob = 0.95,
  fit = TRUE,
  s = c(0, sMax),
  crit = "BIC",
  ncores = 1,
  cl = NULL,
  seed = NULL,
  model = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tslarsP_+3A_x">x</code></td>
<td>
<p>a numeric matrix or data frame containing the candidate predictor
series.</p>
</td></tr>
<tr><td><code id="tslarsP_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed down.</p>
</td></tr>
<tr><td><code id="tslarsP_+3A_formula">formula</code></td>
<td>
<p>a formula describing the full model.</p>
</td></tr>
<tr><td><code id="tslarsP_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible
to a data frame by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code>) containing the variables in
the model.  If not found in data, the variables are taken from
<code>environment(formula)</code>, typically the environment from which
<code>tslarsP</code> or <code>rtslarsP</code> is called.</p>
</td></tr>
<tr><td><code id="tslarsP_+3A_y">y</code></td>
<td>
<p>a numeric vector containing the response series.</p>
</td></tr>
<tr><td><code id="tslarsP_+3A_h">h</code></td>
<td>
<p>an integer giving the forecast horizon (defaults to 1).</p>
</td></tr>
<tr><td><code id="tslarsP_+3A_p">p</code></td>
<td>
<p>an integer giving the number of lags in the model (defaults to 2).</p>
</td></tr>
<tr><td><code id="tslarsP_+3A_smax">sMax</code></td>
<td>
<p>an integer giving the number of predictor series to be
sequenced.  If it is <code>NA</code> (the default), predictor groups are sequenced
as long as there are twice as many observations as predictor variables.</p>
</td></tr>
<tr><td><code id="tslarsP_+3A_fit">fit</code></td>
<td>
<p>a logical indicating whether to fit submodels along the sequence
(<code>TRUE</code>, the default) or to simply return the sequence (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="tslarsP_+3A_s">s</code></td>
<td>
<p>an integer vector of length two giving the first and last
step along the sequence for which to compute submodels.  The default
is to start with a model containing only an intercept (step 0) and
iteratively add all series along the sequence (step <code>sMax</code>).  If
the second element is <code>NA</code>, predictor groups are added to the
model as long as there are twice as many observations as predictor
variables.  If only one value is supplied, it is recycled.</p>
</td></tr>
<tr><td><code id="tslarsP_+3A_crit">crit</code></td>
<td>
<p>a character string specifying the optimality criterion to be
used for selecting the final model.  Currently, only <code>"BIC"</code> for the
Bayes information criterion is implemented.</p>
</td></tr>
<tr><td><code id="tslarsP_+3A_ncores">ncores</code></td>
<td>
<p>a positive integer giving the number of processor cores to be
used for parallel computing (the default is 1 for no parallelization).  If
this is set to <code>NA</code>, all available processor cores are used.  For
obtaining the data cleaning weights and for fitting models along the
sequence, parallel computing is implemented on the <span class="rlang"><b>R</b></span> level using package
<span class="pkg">parallel</span>.  Otherwise parallel computing for some of of the more
computer-intensive computations in the sequencing step is implemented on the
C++ level via OpenMP (<a href="https://www.openmp.org/">https://www.openmp.org/</a>).</p>
</td></tr>
<tr><td><code id="tslarsP_+3A_cl">cl</code></td>
<td>
<p>a <span class="pkg">parallel</span> cluster for parallel computing as generated by
<code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>.  This is preferred over <code>ncores</code>
for tasks that are parallelized on the <span class="rlang"><b>R</b></span> level, in which case <code>ncores</code>
is only used for tasks that are parallelized on the C++ level.</p>
</td></tr>
<tr><td><code id="tslarsP_+3A_model">model</code></td>
<td>
<p>a logical indicating whether the model data should be included
in the returned object.</p>
</td></tr>
<tr><td><code id="tslarsP_+3A_centerfun">centerFun</code></td>
<td>
<p>a function to compute a robust estimate for the center
(defaults to <code><a href="stats.html#topic+median">median</a></code>).</p>
</td></tr>
<tr><td><code id="tslarsP_+3A_scalefun">scaleFun</code></td>
<td>
<p>a function to compute a robust estimate for the scale
(defaults to <code><a href="stats.html#topic+mad">mad</a></code>).</p>
</td></tr>
<tr><td><code id="tslarsP_+3A_regfun">regFun</code></td>
<td>
<p>a function to compute robust linear regressions that can be
interpreted as weighted least squares (defaults to
<code><a href="robustbase.html#topic+lmrob">lmrob</a></code>).</p>
</td></tr>
<tr><td><code id="tslarsP_+3A_regargs">regArgs</code></td>
<td>
<p>a list of arguments to be passed to <code>regFun</code>.</p>
</td></tr>
<tr><td><code id="tslarsP_+3A_combine">combine</code></td>
<td>
<p>a character string specifying how to combine the data
cleaning weights from the robust regressions with each predictor group.
Possible values are <code>"min"</code> for taking the minimum weight for each
observation, <code>"euclidean"</code> for weights based on Euclidean distances
of the multivariate set of standardized residuals (i.e., multivariate
winsorization of the standardized residuals assuming independence), or
<code>"mahalanobis"</code> for weights based on Mahalanobis distances of the
multivariate set of standardized residuals (i.e., multivariate winsorization
of the standardized residuals).</p>
</td></tr>
<tr><td><code id="tslarsP_+3A_winsorize">winsorize</code></td>
<td>
<p>a logical indicating whether to clean the data by
multivariate winsorization.</p>
</td></tr>
<tr><td><code id="tslarsP_+3A_const">const</code></td>
<td>
<p>numeric; tuning constant for multivariate winsorization to be
used in the initial corralation estimates based on adjusted univariate
winsorization (defaults to 2).</p>
</td></tr>
<tr><td><code id="tslarsP_+3A_prob">prob</code></td>
<td>
<p>numeric; probability for the quantile of the
<code class="reqn">\chi^{2}</code> distribution to be used in multivariate
winsorization (defaults to 0.95).</p>
</td></tr>
<tr><td><code id="tslarsP_+3A_seed">seed</code></td>
<td>
<p>optional initial seed for the random number generator
(see <code><a href="base.html#topic+.Random.seed">.Random.seed</a></code>), which is useful because many robust
regression functions (including <code><a href="robustbase.html#topic+lmrob">lmrob</a></code>) involve
randomness.  On parallel <span class="rlang"><b>R</b></span> worker processes, random number streams are
used and the seed is set via <code><a href="parallel.html#topic+clusterSetRNGStream">clusterSetRNGStream</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>fit</code> is <code>FALSE</code>, an integer vector containing the indices of
the sequenced predictor series.
</p>
<p>Otherwise an object of class <code>"tslarsP"</code> (inheriting from classes
<code>"grplars"</code> and <code>"seqModel"</code>) with the following components:
</p>

<dl>
<dt><code>active</code></dt><dd><p>an integer vector containing the sequence of predictor
series.</p>
</dd>
<dt><code>s</code></dt><dd><p>an integer vector containing the steps for which submodels
along the sequence have been computed.</p>
</dd>
<dt><code>coefficients</code></dt><dd><p>a numeric matrix in which each column contains the
regression coefficients of the corresponding submodel along the sequence.</p>
</dd>
<dt><code>fitted.values</code></dt><dd><p>a numeric matrix in which each column contains
the fitted values of the corresponding submodel along the sequence.</p>
</dd>
<dt><code>residuals</code></dt><dd><p>a numeric matrix in which each column contains
the residuals of the corresponding submodel along the sequence.</p>
</dd>
<dt><code>df</code></dt><dd><p>an integer vector containing the degrees of freedom of the
submodels along the sequence (i.e., the number of estimated coefficients).</p>
</dd>
<dt><code>robust</code></dt><dd><p>a logical indicating whether a robust fit was computed.</p>
</dd>
<dt><code>scale</code></dt><dd><p>a numeric vector giving the robust residual scale
estimates for the submodels along the sequence (only returned for a robust
fit).</p>
</dd>
<dt><code>crit</code></dt><dd><p>an object of class <code>"bicSelect"</code> containing the BIC
values and indicating the final model (only returned if argument <code>crit</code>
is <code>"BIC"</code> and argument <code>s</code> indicates more than one step along the
sequence).</p>
</dd>
<dt><code>muX</code></dt><dd><p>a numeric vector containing the center estimates of the
predictor variables.</p>
</dd>
<dt><code>sigmaX</code></dt><dd><p>a numeric vector containing the scale estimates of the
predictor variables.</p>
</dd>
<dt><code>muY</code></dt><dd><p>numeric; the center estimate of the response.</p>
</dd>
<dt><code>sigmaY</code></dt><dd><p>numeric; the scale estimate of the response.</p>
</dd>
<dt><code>x</code></dt><dd><p>the matrix of candidate predictor series (if <code>model</code> is
<code>TRUE</code>).</p>
</dd>
<dt><code>y</code></dt><dd><p>the response series (if <code>model</code> is <code>TRUE</code>).</p>
</dd>
<dt><code>assign</code></dt><dd><p>an integer vector giving the predictor group to which
each predictor variable belongs.</p>
</dd>
<dt><code>w</code></dt><dd><p>a numeric vector giving the data cleaning weights (only
returned for a robust fit).</p>
</dd>
<dt><code>h</code></dt><dd><p>the forecast horizon.</p>
</dd>
<dt><code>p</code></dt><dd><p>the number of lags in the model.</p>
</dd>
<dt><code>call</code></dt><dd><p>the matched function call.</p>
</dd>
</dl>



<h3>Note</h3>

<p>The predictor group of lagged values of the response is indicated by
the index 0.
</p>


<h3>Author(s)</h3>

<p>Andreas Alfons, based on code by Sarah Gelper
</p>


<h3>References</h3>

<p>Alfons, A., Croux, C. and Gelper, S. (2016) Robust groupwise least angle
regression. <em>Computational Statistics &amp; Data Analysis</em>, <b>93</b>,
421&ndash;435. <a href="https://doi.org/10.1016/j.csda.2015.02.007">doi:10.1016/j.csda.2015.02.007</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coef.seqModel">coef</a></code>,
<code><a href="#topic+fitted.seqModel">fitted</a></code>,
<code><a href="#topic+plot.seqModel">plot</a></code>,
<code><a href="#topic+predict.seqModel">predict</a></code>,
<code><a href="#topic+residuals.seqModel">residuals</a></code>,
<code><a href="#topic+rstandard.seqModel">rstandard</a></code>,
<code><a href="#topic+tslars">tslars</a></code>, <code><a href="robustbase.html#topic+lmrob">lmrob</a></code>
</p>

<hr>
<h2 id='weights.sparseLTS'>Extract outlier weights from sparse LTS regression models</h2><span id='topic+weights.sparseLTS'></span>

<h3>Description</h3>

<p>Extract binary weights that indicate outliers from sparse least trimmed
squares regression models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sparseLTS'
weights(
  object,
  type = "robustness",
  s = NA,
  fit = c("reweighted", "raw", "both"),
  drop = !is.null(s),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weights.sparseLTS_+3A_object">object</code></td>
<td>
<p>the model fit from which to extract outlier weights.</p>
</td></tr>
<tr><td><code id="weights.sparseLTS_+3A_type">type</code></td>
<td>
<p>the type of weights to be returned.  Currently only robustness
weights are implemented (<code>"robustness"</code>).</p>
</td></tr>
<tr><td><code id="weights.sparseLTS_+3A_s">s</code></td>
<td>
<p>an integer vector giving the indices of the models for which to
extract outlier weights.  If <code>fit</code> is <code>"both"</code>, this can be a list
with two components, with the first component giving the indices of the
reweighted fits and the second the indices of the raw fits.  The default is
to use the optimal model for each of the requested estimators.  Note that
the optimal models may not correspond to the same value of the penalty
parameter for the reweighted and the raw estimator.</p>
</td></tr>
<tr><td><code id="weights.sparseLTS_+3A_fit">fit</code></td>
<td>
<p>a character string specifying for which estimator to extract
outlier weights.  Possible values are <code>"reweighted"</code> (the default) for
weights indicating outliers from the reweighted fit, <code>"raw"</code> for
weights indicating outliers from the raw fit, or <code>"both"</code> for the
outlier weights from both estimators.</p>
</td></tr>
<tr><td><code id="weights.sparseLTS_+3A_drop">drop</code></td>
<td>
<p>a logical indicating whether to reduce the dimension to a
vector in case of only one model.</p>
</td></tr>
<tr><td><code id="weights.sparseLTS_+3A_...">...</code></td>
<td>
<p>currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector or matrix containing the requested outlier weights.
</p>


<h3>Note</h3>

<p>The weights are <code class="reqn">1</code> for observations with reasonably small
residuals and <code class="reqn">0</code> for observations with large residuals.
</p>


<h3>Author(s)</h3>

<p>Andreas Alfons
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sparseLTS">sparseLTS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate data
# example is not high-dimensional to keep computation time low
library("mvtnorm")
set.seed(1234)  # for reproducibility
n &lt;- 100  # number of observations
p &lt;- 25   # number of variables
beta &lt;- rep.int(c(1, 0), c(5, p-5))  # coefficients
sigma &lt;- 0.5      # controls signal-to-noise ratio
epsilon &lt;- 0.1    # contamination level
Sigma &lt;- 0.5^t(sapply(1:p, function(i, j) abs(i-j), 1:p))
x &lt;- rmvnorm(n, sigma=Sigma)    # predictor matrix
e &lt;- rnorm(n)                   # error terms
i &lt;- 1:ceiling(epsilon*n)       # observations to be contaminated
e[i] &lt;- e[i] + 5                # vertical outliers
y &lt;- c(x %*% beta + sigma * e)  # response
x[i,] &lt;- x[i,] + 5              # bad leverage points

## sparse LTS over a grid of values for lambda
# fit model
frac &lt;- seq(0.2, 0.05, by = -0.05)
fitGrid &lt;- sparseLTS(x, y, lambda = frac, mode = "fraction")
# extract outlier weights
weights(fitGrid)
head(weights(fitGrid, fit = "both"))
head(weights(fitGrid, s = NULL))
head(weights(fitGrid, fit = "both", s = NULL))
</code></pre>

<hr>
<h2 id='winsorize'>Data cleaning by winsorization</h2><span id='topic+winsorize'></span><span id='topic+winsorize.default'></span><span id='topic+winsorize.matrix'></span><span id='topic+winsorize.data.frame'></span>

<h3>Description</h3>

<p>Clean data by means of winsorization, i.e., by shrinking outlying
observations to the border of the main part of the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>winsorize(x, ...)

## Default S3 method:
winsorize(
  x,
  standardized = FALSE,
  centerFun = median,
  scaleFun = mad,
  const = 2,
  return = c("data", "weights"),
  ...
)

## S3 method for class 'matrix'
winsorize(
  x,
  standardized = FALSE,
  centerFun = median,
  scaleFun = mad,
  const = 2,
  prob = 0.95,
  tol = .Machine$double.eps^0.5,
  return = c("data", "weights"),
  ...
)

## S3 method for class 'data.frame'
winsorize(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="winsorize_+3A_x">x</code></td>
<td>
<p>a numeric vector, matrix or data frame to be cleaned.</p>
</td></tr>
<tr><td><code id="winsorize_+3A_...">...</code></td>
<td>
<p>for the generic function, additional arguments to be passed
down to methods.  For the <code>"data.frame"</code> method, additional arguments
to be passed down to the <code>"matrix"</code> method.  For the other methods,
additional arguments to be passed down to
<code><a href="#topic+standardize">robStandardize</a></code>.</p>
</td></tr>
<tr><td><code id="winsorize_+3A_standardized">standardized</code></td>
<td>
<p>a logical indicating whether the data are already
robustly standardized.</p>
</td></tr>
<tr><td><code id="winsorize_+3A_centerfun">centerFun</code></td>
<td>
<p>a function to compute a robust estimate for the center to
be used for robust standardization (defaults to
<code><a href="stats.html#topic+median">median</a></code>).  Ignored if <code>standardized</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="winsorize_+3A_scalefun">scaleFun</code></td>
<td>
<p>a function to compute a robust estimate for the scale to
be used for robust standardization (defaults to <code><a href="stats.html#topic+mad">mad</a></code>).
Ignored if <code>standardized</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="winsorize_+3A_const">const</code></td>
<td>
<p>numeric; tuning constant to be used in univariate
winsorization (defaults to 2).</p>
</td></tr>
<tr><td><code id="winsorize_+3A_return">return</code></td>
<td>
<p>character string; if <code>standardized</code> is <code>TRUE</code>,
this specifies the type of return value.  Possible values are <code>"data"</code>
for returning the cleaned data, or <code>"weights"</code> for returning data
cleaning weights.</p>
</td></tr>
<tr><td><code id="winsorize_+3A_prob">prob</code></td>
<td>
<p>numeric; probability for the quantile of the
<code class="reqn">\chi^{2}</code> distribution to be used in multivariate
winsorization (defaults to 0.95).</p>
</td></tr>
<tr><td><code id="winsorize_+3A_tol">tol</code></td>
<td>
<p>a small positive numeric value used to determine singularity
issues in the computation of correlation estimates based on bivariate
winsorization (see <code><a href="#topic+corHuber">corHuber</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The borders of the main part of the data are defined on the scale of the
robustly standardized data.  In the univariate case, the borders are given
by <code class="reqn">+/-</code><code>const</code>, thus a symmetric distribution is assumed.  In the
multivariate case, a normal distribution is assumed and the data are
shrunken towards the boundary of a tolerance ellipse with coverage
probability <code>prob</code>.  The boundary of this ellipse is thereby given by
all points that have a squared Mahalanobis distance equal to the quantile of
the <code class="reqn">\chi^{2}</code> distribution given by <code>prob</code>.
</p>


<h3>Value</h3>

<p>If <code>standardize</code> is <code>TRUE</code> and <code>return</code> is <code>"weights"</code>,
a set of data cleaning weights.  Multiplying each observation of the
standardized data by the corresponding weight yields the cleaned
standardized data.
</p>
<p>Otherwise an object of the same type as the original data <code>x</code>
containing the cleaned data is returned.
</p>


<h3>Note</h3>

<p>Data cleaning weights are only meaningful for standardized data.  In
the general case, the data need to be standardized first, then the data
cleaning weights can be computed and applied to the standardized data, after
which the cleaned standardized data need to be backtransformed to the
original scale.
</p>


<h3>Author(s)</h3>

<p>Andreas Alfons, based on code by Jafar A. Khan, Stefan Van Aelst and
Ruben H. Zamar
</p>


<h3>References</h3>

<p>Khan, J.A., Van Aelst, S. and Zamar, R.H. (2007) Robust linear model
selection based on least angle regression. <em>Journal of the American
Statistical Association</em>, <b>102</b>(480), 1289&ndash;1299.
<a href="https://doi.org/10.1198/016214507000000950">doi:10.1198/016214507000000950</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+corHuber">corHuber</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate data
set.seed(1234)     # for reproducibility
x &lt;- rnorm(10)     # standard normal
x[1] &lt;- x[1] * 10  # introduce outlier

## winsorize data
x
winsorize(x)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
