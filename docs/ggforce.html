<!DOCTYPE html><html><head><title>Help for package ggforce</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ggforce}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ggforce-package'><p>ggforce: Accelerating 'ggplot2'</p></a></li>
<li><a href='#facet_grid_paginate'><p>Split facet_grid over multiple plots</p></a></li>
<li><a href='#facet_matrix'><p>Facet by different data columns</p></a></li>
<li><a href='#facet_row'><p>One-dimensional facets</p></a></li>
<li><a href='#facet_stereo'><p>Create a stereogram plot</p></a></li>
<li><a href='#facet_wrap_paginate'><p>Split facet_wrap over multiple plots</p></a></li>
<li><a href='#facet_zoom'><p>Facet data for zoom with context</p></a></li>
<li><a href='#gather_set_data'><p>Tidy data for use with geom_parallel_sets</p></a></li>
<li><a href='#geom_arc'><p>Arcs based on radius and radians</p></a></li>
<li><a href='#geom_arc_bar'><p>Arcs and wedges as polygons</p></a></li>
<li><a href='#geom_autodensity'><p>A distribution geoms that fills the panel and works with discrete and continuous data</p></a></li>
<li><a href='#geom_autopoint'><p>A point geom specialised for scatterplot matrices</p></a></li>
<li><a href='#geom_bezier'><p>Create quadratic or cubic bezier curves</p></a></li>
<li><a href='#geom_bspline'><p>B-splines based on control points</p></a></li>
<li><a href='#geom_bspline_closed'><p>Create closed b-spline shapes</p></a></li>
<li><a href='#geom_circle'><p>Circles based on center and radius</p></a></li>
<li><a href='#geom_diagonal'><p>Draw horizontal diagonals</p></a></li>
<li><a href='#geom_diagonal_wide'><p>Draw an area defined by an upper and lower diagonal</p></a></li>
<li><a href='#geom_ellipse'><p>Draw (super)ellipses based on the coordinate system scale</p></a></li>
<li><a href='#geom_link'><p>Link points with paths</p></a></li>
<li><a href='#geom_mark_circle'><p>Annotate areas with circles</p></a></li>
<li><a href='#geom_mark_ellipse'><p>Annotate areas with ellipses</p></a></li>
<li><a href='#geom_mark_hull'><p>Annotate areas with hulls</p></a></li>
<li><a href='#geom_mark_rect'><p>Annotate areas with rectangles</p></a></li>
<li><a href='#geom_parallel_sets'><p>Create Parallel Sets diagrams</p></a></li>
<li><a href='#geom_regon'><p>Draw regular polygons by specifying number of sides</p></a></li>
<li><a href='#geom_shape'><p>Draw polygons with expansion/contraction and/or rounded corners</p></a></li>
<li><a href='#geom_sina'><p>Sina plot</p></a></li>
<li><a href='#geom_spiro'><p>Draw spirograms based on the radii of the different &quot;wheels&quot; involved</p></a></li>
<li><a href='#geom_voronoi'><p>Voronoi tesselation and delaunay triangulation</p></a></li>
<li><a href='#GeomShape'><p>ggforce extensions to ggplot2</p></a></li>
<li><a href='#interpolateDataFrame'><p>Interpolate layer data</p></a></li>
<li><a href='#label_tex'><p>A labeller function to parse TeX syntax</p></a></li>
<li><a href='#linear_trans'><p>Create a custom linear transformation</p></a></li>
<li><a href='#n_pages'><p>Determine the number of pages in a paginated facet plot</p></a></li>
<li><a href='#position_auto'><p>Jitter based on scale types</p></a></li>
<li><a href='#position_jitternormal'><p>Jitter points with normally distributed random noise</p></a></li>
<li><a href='#power_trans'><p>Create a power transformation object</p></a></li>
<li><a href='#radial_trans'><p>Create radial data in a cartesian coordinate system</p></a></li>
<li><a href='#scale_depth'><p>Scales for depth perception</p></a></li>
<li><a href='#scale_unit'><p>Position scales for units data</p></a></li>
<li><a href='#stat_err'><p>Intervals in vertical and horizontal directions</p></a></li>
<li><a href='#theme_no_axes'><p>Theme without axes and gridlines</p></a></li>
<li><a href='#trans_reverser'><p>Reverse a transformation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Accelerating 'ggplot2'</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.2</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas Lin Pedersen &lt;thomasp85@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The aim of 'ggplot2' is to aid in visual data investigations. This
    focus has led to a lack of facilities for composing specialised plots.
    'ggforce' aims to be a collection of mainly new stats and geoms that fills
    this gap. All additional functionality is aimed to come through the official
    extension system so using 'ggforce' should be a stable experience.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://ggforce.data-imaginist.com">https://ggforce.data-imaginist.com</a>,
<a href="https://github.com/thomasp85/ggforce">https://github.com/thomasp85/ggforce</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/thomasp85/ggforce/issues">https://github.com/thomasp85/ggforce/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>ggplot2 (&ge; 3.3.6), R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.2), grid, scales, MASS, tweenr (&ge; 0.1.5),
gtable, rlang, polyclip, stats, grDevices, tidyselect, withr,
utils, lifecycle, cli, vctrs, systemfonts</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>sessioninfo, concaveman, deldir, latex2exp, reshape2, units
(&ge; 0.4-6), covr</td>
</tr>
<tr>
<td>Collate:</td>
<td>'RcppExports.R' 'aaa.R' 'shape.R' 'arc_bar.R' 'arc.R'
'autodensity.R' 'autohistogram.R' 'autopoint.R' 'bezier.R'
'bspline.R' 'bspline_closed.R' 'circle.R' 'diagonal.R'
'diagonal_wide.R' 'ellipse.R' 'errorbar.R'
'facet_grid_paginate.R' 'facet_matrix.R' 'facet_row.R'
'facet_stereo.R' 'facet_wrap_paginate.R' 'facet_zoom.R'
'ggforce-package.R' 'ggproto-classes.R' 'interpolate.R'
'labeller.R' 'link.R' 'mark_circle.R' 'mark_ellipse.R'
'mark_hull.R' 'mark_label.R' 'mark_rect.R' 'parallel_sets.R'
'position-jitternormal.R' 'position_auto.R'
'position_floatstack.R' 'regon.R' 'scale-depth.R'
'scale-unit.R' 'sina.R' 'spiro.R' 'themes.R' 'trans.R'
'trans_linear.R' 'utilities.R' 'voronoi.R' 'zzz.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-19 08:06:23 UTC; thomas</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas Lin Pedersen
    <a href="https://orcid.org/0000-0002-5147-4711"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [cre, aut],
  RStudio [cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-19 11:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ggforce-package'>ggforce: Accelerating 'ggplot2'</h2><span id='topic+ggforce'></span><span id='topic+ggforce-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>The aim of 'ggplot2' is to aid in visual data investigations. This focus has led to a lack of facilities for composing specialised plots. 'ggforce' aims to be a collection of mainly new stats and geoms that fills this gap. All additional functionality is aimed to come through the official extension system so using 'ggforce' should be a stable experience.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Thomas Lin Pedersen <a href="mailto:thomasp85@gmail.com">thomasp85@gmail.com</a> (<a href="https://orcid.org/0000-0002-5147-4711">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> RStudio [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://ggforce.data-imaginist.com">https://ggforce.data-imaginist.com</a>
</p>
</li>
<li> <p><a href="https://github.com/thomasp85/ggforce">https://github.com/thomasp85/ggforce</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/thomasp85/ggforce/issues">https://github.com/thomasp85/ggforce/issues</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>rocketData &lt;- data.frame(
  x = c(1, 1, 2, 2),
  y = c(1, 2, 2, 3)
)
rocketData &lt;- do.call(rbind, lapply(seq_len(500) - 1, function(i) {
  rocketData$y &lt;- rocketData$y - c(0, i / 500)
  rocketData$group &lt;- i + 1
  rocketData
}))
rocketData2 &lt;- data.frame(
  x = c(2, 2.25, 2),
  y = c(2, 2.5, 3)
)
rocketData2 &lt;- do.call(rbind, lapply(seq_len(500) - 1, function(i) {
  rocketData2$x[2] &lt;- rocketData2$x[2] - i * 0.25 / 500
  rocketData2$group &lt;- i + 1 + 500
  rocketData2
}))

ggplot() + geom_link(aes(
  x = 2, y = 2, xend = 3, yend = 3, alpha = after_stat(index),
  size = after_stat(index)
), colour = 'goldenrod', n = 500) +
  geom_bezier(aes(x = x, y = y, group = group, colour = after_stat(index)),
    data = rocketData
  ) +
  geom_bezier(aes(x = y, y = x, group = group, colour = after_stat(index)),
    data = rocketData
  ) +
  geom_bezier(aes(x = x, y = y, group = group, colour = 1),
    data = rocketData2
  ) +
  geom_bezier(aes(x = y, y = x, group = group, colour = 1),
    data = rocketData2
  ) +
  geom_text(aes(x = 1.65, y = 1.65, label = 'ggplot2', angle = 45),
    colour = 'white', size = 15
  ) +
  coord_fixed() +
  scale_x_reverse() +
  scale_y_reverse() +
  scale_alpha(range = c(1, 0), guide = 'none') +
  scale_size_continuous(
    range = c(20, 0.1), trans = 'exp',
    guide = 'none'
  ) +
  scale_color_continuous(guide = 'none') +
  xlab('') + ylab('') +
  ggtitle('ggforce: Accelerating ggplot2') +
  theme(plot.title = element_text(size = 20))
</code></pre>

<hr>
<h2 id='facet_grid_paginate'>Split facet_grid over multiple plots</h2><span id='topic+facet_grid_paginate'></span>

<h3>Description</h3>

<p>This extension to <code><a href="ggplot2.html#topic+facet_grid">ggplot2::facet_grid()</a></code> will allow you to split
a facetted plot over multiple pages. You define a number of rows and columns
per page as well as the page number to plot, and the function will
automatically only plot the correct panels. Usually this will be put in a
loop to render all pages one by one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>facet_grid_paginate(
  facets,
  margins = FALSE,
  scales = "fixed",
  space = "fixed",
  shrink = TRUE,
  labeller = "label_value",
  as.table = TRUE,
  switch = NULL,
  drop = TRUE,
  ncol = NULL,
  nrow = NULL,
  page = 1,
  byrow = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="facet_grid_paginate_+3A_facets">facets</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Please use <code>rows</code>
and <code>cols</code> instead.</p>
</td></tr>
<tr><td><code id="facet_grid_paginate_+3A_margins">margins</code></td>
<td>
<p>Either a logical value or a character
vector. Margins are additional facets which contain all the data
for each of the possible values of the faceting variables. If
<code>FALSE</code>, no additional facets are included (the
default). If <code>TRUE</code>, margins are included for all faceting
variables. If specified as a character vector, it is the names of
variables for which margins are to be created.</p>
</td></tr>
<tr><td><code id="facet_grid_paginate_+3A_scales">scales</code></td>
<td>
<p>Are scales shared across all facets (the default,
<code>"fixed"</code>), or do they vary across rows (<code>"free_x"</code>),
columns (<code>"free_y"</code>), or both rows and columns (<code>"free"</code>)?</p>
</td></tr>
<tr><td><code id="facet_grid_paginate_+3A_space">space</code></td>
<td>
<p>If <code>"fixed"</code>, the default, all panels have the same size.
If <code>"free_y"</code> their height will be proportional to the length of the
y scale; if <code>"free_x"</code> their width will be proportional to the
length of the x scale; or if <code>"free"</code> both height and width will
vary.  This setting has no effect unless the appropriate scales also vary.</p>
</td></tr>
<tr><td><code id="facet_grid_paginate_+3A_shrink">shrink</code></td>
<td>
<p>If <code>TRUE</code>, will shrink scales to fit output of
statistics, not raw data. If <code>FALSE</code>, will be range of raw data
before statistical summary.</p>
</td></tr>
<tr><td><code id="facet_grid_paginate_+3A_labeller">labeller</code></td>
<td>
<p>A function that takes one data frame of labels and
returns a list or data frame of character vectors. Each input
column corresponds to one factor. Thus there will be more than
one with <code>vars(cyl, am)</code>. Each output
column gets displayed as one separate line in the strip
label. This function should inherit from the &quot;labeller&quot; S3 class
for compatibility with <code><a href="ggplot2.html#topic+labeller">labeller()</a></code>. You can use different labeling
functions for different kind of labels, for example use <code><a href="ggplot2.html#topic+label_parsed">label_parsed()</a></code> for
formatting facet labels. <code><a href="ggplot2.html#topic+label_value">label_value()</a></code> is used by default,
check it for more details and pointers to other options.</p>
</td></tr>
<tr><td><code id="facet_grid_paginate_+3A_as.table">as.table</code></td>
<td>
<p>If <code>TRUE</code>, the default, the facets are laid out like
a table with highest values at the bottom-right. If <code>FALSE</code>, the
facets are laid out like a plot with the highest value at the top-right.</p>
</td></tr>
<tr><td><code id="facet_grid_paginate_+3A_switch">switch</code></td>
<td>
<p>By default, the labels are displayed on the top and
right of the plot. If <code>"x"</code>, the top labels will be
displayed to the bottom. If <code>"y"</code>, the right-hand side
labels will be displayed to the left. Can also be set to
<code>"both"</code>.</p>
</td></tr>
<tr><td><code id="facet_grid_paginate_+3A_drop">drop</code></td>
<td>
<p>If <code>TRUE</code>, the default, all factor levels not used in the
data will automatically be dropped. If <code>FALSE</code>, all factor levels
will be shown, regardless of whether or not they appear in the data.</p>
</td></tr>
<tr><td><code id="facet_grid_paginate_+3A_ncol">ncol</code></td>
<td>
<p>Number of columns per page</p>
</td></tr>
<tr><td><code id="facet_grid_paginate_+3A_nrow">nrow</code></td>
<td>
<p>Number of rows per page</p>
</td></tr>
<tr><td><code id="facet_grid_paginate_+3A_page">page</code></td>
<td>
<p>The page to draw</p>
</td></tr>
<tr><td><code id="facet_grid_paginate_+3A_byrow">byrow</code></td>
<td>
<p>Should the pages be created row-wise or column wise</p>
</td></tr>
</table>


<h3>Note</h3>

<p>If either <code>ncol</code> or <code>nrow</code> is <code>NULL</code> this function will
fall back to the standard <code>facet_grid</code> functionality.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+n_pages">n_pages()</a></code> to compute the total number of pages in a paginated
faceted plot
</p>
<p>Other ggforce facets: 
<code><a href="#topic+facet_stereo">facet_stereo</a>()</code>,
<code><a href="#topic+facet_wrap_paginate">facet_wrap_paginate</a>()</code>,
<code><a href="#topic+facet_zoom">facet_zoom</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Draw a small section of the grid
ggplot(diamonds) +
  geom_point(aes(carat, price), alpha = 0.1) +
  facet_grid_paginate(color ~ cut:clarity, ncol = 3, nrow = 3, page = 4)
</code></pre>

<hr>
<h2 id='facet_matrix'>Facet by different data columns</h2><span id='topic+facet_matrix'></span>

<h3>Description</h3>

<p>The <code>facet_matrix()</code> facet allows you to put different data columns into
different rows and columns in a grid of panels. If the same data columns are
present in both the rows and the columns of the grid, and used together with
<code><a href="ggplot2.html#topic+geom_point">ggplot2::geom_point()</a></code> it is also known as a scatterplot matrix, and if
other geoms are used it is sometimes referred to as a pairs plot.
<code>facet_matrix</code> is so flexible that these types are simply a subset of its
capabilities, as any combination of data columns can be plotted against each
other using any type of geom. Layers should use the <code>.panel_x</code> and <code>.panel_y</code>
placeholders to map aesthetics to, in order to access the row and column
data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>facet_matrix(
  rows,
  cols = rows,
  shrink = TRUE,
  switch = NULL,
  labeller = "label_value",
  flip.rows = FALSE,
  alternate.axes = FALSE,
  layer.lower = NULL,
  layer.diag = NULL,
  layer.upper = NULL,
  layer.continuous = NULL,
  layer.discrete = NULL,
  layer.mixed = NULL,
  grid.y.diag = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="facet_matrix_+3A_rows">rows</code>, <code id="facet_matrix_+3A_cols">cols</code></td>
<td>
<p>A specification of the data columns to put in the rows and
columns of the facet grid. They are specified using the <code><a href="ggplot2.html#topic+vars">ggplot2::vars()</a></code>
function wherein you can use standard tidyselect syntax as known from e.g.
<code>dplyr::select()</code>. These data values will be made available to the different
layers through the <code>.panel_x</code> and <code>.panel_y</code> variables.</p>
</td></tr>
<tr><td><code id="facet_matrix_+3A_shrink">shrink</code></td>
<td>
<p>If <code>TRUE</code>, will shrink scales to fit output of
statistics, not raw data. If <code>FALSE</code>, will be range of raw data
before statistical summary.</p>
</td></tr>
<tr><td><code id="facet_matrix_+3A_switch">switch</code></td>
<td>
<p>By default, the labels are displayed on the top and
right of the plot. If <code>"x"</code>, the top labels will be
displayed to the bottom. If <code>"y"</code>, the right-hand side
labels will be displayed to the left. Can also be set to
<code>"both"</code>.</p>
</td></tr>
<tr><td><code id="facet_matrix_+3A_labeller">labeller</code></td>
<td>
<p>A function that takes one data frame of labels and
returns a list or data frame of character vectors. Each input
column corresponds to one factor. Thus there will be more than
one with <code>vars(cyl, am)</code>. Each output
column gets displayed as one separate line in the strip
label. This function should inherit from the &quot;labeller&quot; S3 class
for compatibility with <code><a href="ggplot2.html#topic+labeller">labeller()</a></code>. You can use different labeling
functions for different kind of labels, for example use <code><a href="ggplot2.html#topic+label_parsed">label_parsed()</a></code> for
formatting facet labels. <code><a href="ggplot2.html#topic+label_value">label_value()</a></code> is used by default,
check it for more details and pointers to other options.</p>
</td></tr>
<tr><td><code id="facet_matrix_+3A_flip.rows">flip.rows</code></td>
<td>
<p>Should the order of the rows be reversed so that, if the
rows and columns are equal, the diagonal goes from bottom-left to top-right
instead of top-left to bottom-right.</p>
</td></tr>
<tr><td><code id="facet_matrix_+3A_alternate.axes">alternate.axes</code></td>
<td>
<p>Should axes be drawn at alternating positions.</p>
</td></tr>
<tr><td><code id="facet_matrix_+3A_layer.lower">layer.lower</code>, <code id="facet_matrix_+3A_layer.diag">layer.diag</code>, <code id="facet_matrix_+3A_layer.upper">layer.upper</code></td>
<td>
<p>Specification for where each layer
should appear. The default (<code>NULL</code>) will allow any layer that has not been
specified directly to appear at that position. Putting e.g. <code>layer.diag = 2</code>
will make the second layer appear on the diagonal as well as remove that
layer from any position that has <code>NULL</code>. Using <code>TRUE</code> will put all layers at
that position, and using <code>FALSE</code> will conversely remove all layers. These
settings will only have an effect if the grid is symmetric.</p>
</td></tr>
<tr><td><code id="facet_matrix_+3A_layer.continuous">layer.continuous</code>, <code id="facet_matrix_+3A_layer.discrete">layer.discrete</code>, <code id="facet_matrix_+3A_layer.mixed">layer.mixed</code></td>
<td>
<p>As above, but instead of
referencing panel positions it references the combination of position scales
in the panel. Continuous panels have both a continuous x and y axis, discrete
panels have both a discrete x and y axis, and mixed panels have one of each.
Unlike the position based specifications above these also have an effect in
non-symmetric grids.</p>
</td></tr>
<tr><td><code id="facet_matrix_+3A_grid.y.diag">grid.y.diag</code></td>
<td>
<p>Should the y grid be removed from the diagonal? In certain
situations the diagonal are used to plot the distribution of the column data
and will thus not use the y-scale. Removing the y gridlines can indicate
this.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Due to the special nature of this faceting it slightly breaks the
ggplot2 API, in that any positional scale settings are ignored. This is
because each row and column in the grid will potentially have very different
scale types and it is not currently possible to have multiple different scale
specifications in the same plot object.
</p>


<h3>See Also</h3>

<p><a href="#topic+geom_autopoint">geom_autopoint</a>, <a href="#topic+geom_autohistogram">geom_autohistogram</a>, <a href="#topic+geom_autodensity">geom_autodensity</a>, and
<a href="#topic+position_auto">position_auto</a> for geoms and positions that adapts to different positional
scale types
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Standard use:
ggplot(mpg) +
  geom_point(aes(x = .panel_x, y = .panel_y)) +
  facet_matrix(vars(displ, cty, hwy))

# Switch the diagonal, alternate the axes and style strips as axis labels
ggplot(mpg) +
  geom_point(aes(x = .panel_x, y = .panel_y)) +
  facet_matrix(vars(displ, cty, hwy), flip.rows = TRUE,
               alternate.axes = TRUE, switch = 'both') +
  theme(strip.background = element_blank(),
        strip.placement = 'outside',
        strip.text = element_text(size = 12))

# Mix discrete and continuous columns. Use geom_autopoint for scale-based jitter
ggplot(mpg) +
  geom_autopoint() +
  facet_matrix(vars(drv:fl))

# Have a special diagonal layer
ggplot(mpg) +
  geom_autopoint() +
  geom_autodensity() +
  facet_matrix(vars(drv:fl), layer.diag = 2)


# Show continuous panels in upper triangle as contours and rest as binned
ggplot(mpg) +
  geom_autopoint() +
  geom_autodensity() +
  geom_density2d(aes(x = .panel_x, y = .panel_y)) +
  geom_bin2d(aes(x = .panel_x, y = .panel_y)) +
  facet_matrix(vars(drv:fl), layer.lower = 1, layer.diag = 2,
               layer.continuous = -4, layer.discrete = -3, layer.mixed = -3)


# Make asymmetric grid
ggplot(mpg) +
  geom_boxplot(aes(x = .panel_x, y = .panel_y, group = .panel_x)) +
  facet_matrix(rows = vars(cty, hwy), cols = vars(drv, fl))

</code></pre>

<hr>
<h2 id='facet_row'>One-dimensional facets</h2><span id='topic+facet_row'></span><span id='topic+facet_col'></span>

<h3>Description</h3>

<p>These facets are one-dimensional versions of <code><a href="ggplot2.html#topic+facet_wrap">ggplot2::facet_wrap()</a></code>,
arranging the panels in either a single row or a single column. This
restriction makes it possible to support a <code>space</code> argument as seen in
<code><a href="ggplot2.html#topic+facet_grid">ggplot2::facet_grid()</a></code> which, if set to <code>"free"</code> will allow the panels to be
sized based on the relative range of their scales. Another way of thinking
about them are one-dimensional versions of <code><a href="ggplot2.html#topic+facet_grid">ggplot2::facet_grid()</a></code> (ie.
<code>. ~ {var}</code> or <code>{var} ~ .</code>), but with the ability to position the strip at
either side of the panel. However you look at it it is the best of both world
if you just need one dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>facet_row(
  facets,
  scales = "fixed",
  space = "fixed",
  shrink = TRUE,
  labeller = "label_value",
  drop = TRUE,
  strip.position = "top"
)

facet_col(
  facets,
  scales = "fixed",
  space = "fixed",
  shrink = TRUE,
  labeller = "label_value",
  drop = TRUE,
  strip.position = "top"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="facet_row_+3A_facets">facets</code></td>
<td>
<p>A set of variables or expressions quoted by <code><a href="ggplot2.html#topic+vars">vars()</a></code>
and defining faceting groups on the rows or columns dimension.
The variables can be named (the names are passed to <code>labeller</code>).
</p>
<p>For compatibility with the classic interface, can also be a
formula or character vector. Use either a one sided formula, <code>~a + b</code>,
or a character vector, <code>c("a", "b")</code>.</p>
</td></tr>
<tr><td><code id="facet_row_+3A_scales">scales</code></td>
<td>
<p>Should scales be fixed (<code>"fixed"</code>, the default),
free (<code>"free"</code>), or free in one dimension (<code>"free_x"</code>,
<code>"free_y"</code>)?</p>
</td></tr>
<tr><td><code id="facet_row_+3A_space">space</code></td>
<td>
<p>Should the size of the panels be fixed or relative to the range
of the respective position scales</p>
</td></tr>
<tr><td><code id="facet_row_+3A_shrink">shrink</code></td>
<td>
<p>If <code>TRUE</code>, will shrink scales to fit output of
statistics, not raw data. If <code>FALSE</code>, will be range of raw data
before statistical summary.</p>
</td></tr>
<tr><td><code id="facet_row_+3A_labeller">labeller</code></td>
<td>
<p>A function that takes one data frame of labels and
returns a list or data frame of character vectors. Each input
column corresponds to one factor. Thus there will be more than
one with <code>vars(cyl, am)</code>. Each output
column gets displayed as one separate line in the strip
label. This function should inherit from the &quot;labeller&quot; S3 class
for compatibility with <code><a href="ggplot2.html#topic+labeller">labeller()</a></code>. You can use different labeling
functions for different kind of labels, for example use <code><a href="ggplot2.html#topic+label_parsed">label_parsed()</a></code> for
formatting facet labels. <code><a href="ggplot2.html#topic+label_value">label_value()</a></code> is used by default,
check it for more details and pointers to other options.</p>
</td></tr>
<tr><td><code id="facet_row_+3A_drop">drop</code></td>
<td>
<p>If <code>TRUE</code>, the default, all factor levels not used in the
data will automatically be dropped. If <code>FALSE</code>, all factor levels
will be shown, regardless of whether or not they appear in the data.</p>
</td></tr>
<tr><td><code id="facet_row_+3A_strip.position">strip.position</code></td>
<td>
<p>By default, the labels are displayed on the top of
the plot. Using <code>strip.position</code> it is possible to place the labels on
either of the four sides by setting <code>strip.position = c("top",
  "bottom", "left", "right")</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Standard use
ggplot(mtcars) +
  geom_point(aes(disp, mpg)) +
  facet_col(~gear)
# It retains the ability to have unique scales for each panel
ggplot(mtcars) +
  geom_point(aes(disp, mpg)) +
  facet_col(~gear, scales = 'free')

# But can have free sizing along the stacking dimension
ggplot(mtcars) +
  geom_point(aes(disp, mpg)) +
  facet_col(~gear, scales = 'free', space = 'free')

# And you can position the strip where-ever you like
ggplot(mtcars) +
  geom_point(aes(disp, mpg)) +
  facet_col(~gear, scales = 'free', space = 'free', strip.position = 'bottom')

</code></pre>

<hr>
<h2 id='facet_stereo'>Create a stereogram plot</h2><span id='topic+facet_stereo'></span>

<h3>Description</h3>

<p>This, arguably pretty useless function, lets you create plots with a sense of
depth by creating two slightly different versions of the plot that
corresponds to how the eyes would see it if the plot was 3 dimensional. To
experience the effect look at the plots through 3D hardware such as Google
Cardboard or by relaxing the eyes and focusing into the distance. The
depth of a point is calculated for layers having a depth aesthetic supplied.
The scaling of the depth can be controlled with <code><a href="#topic+scale_depth">scale_depth()</a></code> as
you would control any aesthetic. Negative values will result in features
placed behind the paper plane, while positive values will result in
features hovering in front of the paper. While features within each layer is
sorted so those closest to you are plotted on top of those more distant, this
cannot be done between layers. Thus, layers are always plotted on top of
each others, even if the features in one layer lies behind features in a
layer behind it. The depth experience is inaccurate and should not be used
for conveying important data. Regard this more as a party-trick...
</p>


<h3>Usage</h3>

<pre><code class='language-R'>facet_stereo(IPD = 63.5, panel.size = 200, shrink = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="facet_stereo_+3A_ipd">IPD</code></td>
<td>
<p>The interpupillary distance (in mm) used for calculating point
displacement. The default value is an average of both genders</p>
</td></tr>
<tr><td><code id="facet_stereo_+3A_panel.size">panel.size</code></td>
<td>
<p>The final plot size in mm. As IPD this is used to calculate
point displacement. Don't take this value too literal but experiment until
you get a nice effect. Lower values gives higher displacement and thus
require the plots to be observed from a closer distance</p>
</td></tr>
<tr><td><code id="facet_stereo_+3A_shrink">shrink</code></td>
<td>
<p>If <code>TRUE</code>, will shrink scales to fit output of
statistics, not raw data. If <code>FALSE</code>, will be range of raw data
before statistical summary.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other ggforce facets: 
<code><a href="#topic+facet_grid_paginate">facet_grid_paginate</a>()</code>,
<code><a href="#topic+facet_wrap_paginate">facet_wrap_paginate</a>()</code>,
<code><a href="#topic+facet_zoom">facet_zoom</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># You'll have to accept a warning about depth being an unknown aesthetic
ggplot(mtcars) +
  geom_point(aes(mpg, disp, depth = cyl)) +
  facet_stereo()
</code></pre>

<hr>
<h2 id='facet_wrap_paginate'>Split facet_wrap over multiple plots</h2><span id='topic+facet_wrap_paginate'></span>

<h3>Description</h3>

<p>This extension to <code><a href="ggplot2.html#topic+facet_wrap">ggplot2::facet_wrap()</a></code> will allow you to split
a facetted plot over multiple pages. You define a number of rows and columns
per page as well as the page number to plot, and the function will
automatically only plot the correct panels. Usually this will be put in a
loop to render all pages one by one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>facet_wrap_paginate(
  facets,
  nrow = NULL,
  ncol = NULL,
  scales = "fixed",
  shrink = TRUE,
  labeller = "label_value",
  as.table = TRUE,
  switch = deprecated(),
  drop = TRUE,
  dir = "h",
  strip.position = "top",
  page = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="facet_wrap_paginate_+3A_facets">facets</code></td>
<td>
<p>A set of variables or expressions quoted by <code><a href="ggplot2.html#topic+vars">vars()</a></code>
and defining faceting groups on the rows or columns dimension.
The variables can be named (the names are passed to <code>labeller</code>).
</p>
<p>For compatibility with the classic interface, can also be a
formula or character vector. Use either a one sided formula, <code>~a + b</code>,
or a character vector, <code>c("a", "b")</code>.</p>
</td></tr>
<tr><td><code id="facet_wrap_paginate_+3A_nrow">nrow</code>, <code id="facet_wrap_paginate_+3A_ncol">ncol</code></td>
<td>
<p>Number of rows and columns</p>
</td></tr>
<tr><td><code id="facet_wrap_paginate_+3A_scales">scales</code></td>
<td>
<p>Should scales be fixed (<code>"fixed"</code>, the default),
free (<code>"free"</code>), or free in one dimension (<code>"free_x"</code>,
<code>"free_y"</code>)?</p>
</td></tr>
<tr><td><code id="facet_wrap_paginate_+3A_shrink">shrink</code></td>
<td>
<p>If <code>TRUE</code>, will shrink scales to fit output of
statistics, not raw data. If <code>FALSE</code>, will be range of raw data
before statistical summary.</p>
</td></tr>
<tr><td><code id="facet_wrap_paginate_+3A_labeller">labeller</code></td>
<td>
<p>A function that takes one data frame of labels and
returns a list or data frame of character vectors. Each input
column corresponds to one factor. Thus there will be more than
one with <code>vars(cyl, am)</code>. Each output
column gets displayed as one separate line in the strip
label. This function should inherit from the &quot;labeller&quot; S3 class
for compatibility with <code><a href="ggplot2.html#topic+labeller">labeller()</a></code>. You can use different labeling
functions for different kind of labels, for example use <code><a href="ggplot2.html#topic+label_parsed">label_parsed()</a></code> for
formatting facet labels. <code><a href="ggplot2.html#topic+label_value">label_value()</a></code> is used by default,
check it for more details and pointers to other options.</p>
</td></tr>
<tr><td><code id="facet_wrap_paginate_+3A_as.table">as.table</code></td>
<td>
<p>If <code>TRUE</code>, the default, the facets are laid out like
a table with highest values at the bottom-right. If <code>FALSE</code>, the
facets are laid out like a plot with the highest value at the top-right.</p>
</td></tr>
<tr><td><code id="facet_wrap_paginate_+3A_switch">switch</code></td>
<td>
<p>By default, the labels are displayed on the top and
right of the plot. If <code>"x"</code>, the top labels will be
displayed to the bottom. If <code>"y"</code>, the right-hand side
labels will be displayed to the left. Can also be set to
<code>"both"</code>.</p>
</td></tr>
<tr><td><code id="facet_wrap_paginate_+3A_drop">drop</code></td>
<td>
<p>If <code>TRUE</code>, the default, all factor levels not used in the
data will automatically be dropped. If <code>FALSE</code>, all factor levels
will be shown, regardless of whether or not they appear in the data.</p>
</td></tr>
<tr><td><code id="facet_wrap_paginate_+3A_dir">dir</code></td>
<td>
<p>Direction: either <code>"h"</code> for horizontal, the default, or <code>"v"</code>,
for vertical.</p>
</td></tr>
<tr><td><code id="facet_wrap_paginate_+3A_strip.position">strip.position</code></td>
<td>
<p>By default, the labels are displayed on the top of
the plot. Using <code>strip.position</code> it is possible to place the labels on
either of the four sides by setting <code>strip.position = c("top",
  "bottom", "left", "right")</code></p>
</td></tr>
<tr><td><code id="facet_wrap_paginate_+3A_page">page</code></td>
<td>
<p>The page to draw</p>
</td></tr>
</table>


<h3>Note</h3>

<p>If either <code>ncol</code> or <code>nrow</code> is <code>NULL</code> this function will
fall back to the standard <code>facet_wrap</code> functionality.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+n_pages">n_pages()</a></code> to compute the total number of pages in a paginated
faceted plot
</p>
<p>Other ggforce facets: 
<code><a href="#topic+facet_grid_paginate">facet_grid_paginate</a>()</code>,
<code><a href="#topic+facet_stereo">facet_stereo</a>()</code>,
<code><a href="#topic+facet_zoom">facet_zoom</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ggplot(diamonds) +
    geom_point(aes(carat, price), alpha = 0.1) +
    facet_wrap_paginate(~ cut:clarity, ncol = 3, nrow = 3, page = 4)

</code></pre>

<hr>
<h2 id='facet_zoom'>Facet data for zoom with context</h2><span id='topic+facet_zoom'></span>

<h3>Description</h3>

<p>This facetting provides the means to zoom in on a subset of the data, while
keeping the view of the full dataset as a separate panel. The zoomed-in area
will be indicated on the full dataset panel for reference. It is possible to
zoom in on both the x and y axis at the same time. If this is done it is
possible to both get each zoom separately and combined or just combined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>facet_zoom(
  x,
  y,
  xy,
  zoom.data,
  xlim = NULL,
  ylim = NULL,
  split = FALSE,
  horizontal = TRUE,
  zoom.size = 2,
  show.area = TRUE,
  shrink = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="facet_zoom_+3A_x">x</code>, <code id="facet_zoom_+3A_y">y</code>, <code id="facet_zoom_+3A_xy">xy</code></td>
<td>
<p>An expression evaluating to a logical vector that determines
the subset of data to zoom in on</p>
</td></tr>
<tr><td><code id="facet_zoom_+3A_zoom.data">zoom.data</code></td>
<td>
<p>An expression evaluating to a logical vector. If <code>TRUE</code>
the data only shows in the zoom panels. If <code>FALSE</code> the data only show in
the context panel. If <code>NA</code> the data will show in all panels.</p>
</td></tr>
<tr><td><code id="facet_zoom_+3A_xlim">xlim</code>, <code id="facet_zoom_+3A_ylim">ylim</code></td>
<td>
<p>Specific zoom ranges for each axis. If present they will
override <code>x</code>, <code>y</code>, and/or <code>xy</code>.</p>
</td></tr>
<tr><td><code id="facet_zoom_+3A_split">split</code></td>
<td>
<p>If both <code>x</code> and <code>y</code> is given, should each axis zoom
be shown separately as well? Defaults to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="facet_zoom_+3A_horizontal">horizontal</code></td>
<td>
<p>If both <code>x</code> and <code>y</code> is given and
<code>split = FALSE</code> How should the zoom panel be positioned relative to the
full data panel? Defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="facet_zoom_+3A_zoom.size">zoom.size</code></td>
<td>
<p>Sets the relative size of the zoom panel to the full data
panel. The default (<code>2</code>) makes the zoom panel twice the size of the full
data panel.</p>
</td></tr>
<tr><td><code id="facet_zoom_+3A_show.area">show.area</code></td>
<td>
<p>Should the zoom area be drawn below the data points on the
full data panel? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="facet_zoom_+3A_shrink">shrink</code></td>
<td>
<p>If <code>TRUE</code>, will shrink scales to fit output of
statistics, not raw data. If <code>FALSE</code>, will be range of raw data
before statistical summary.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other ggforce facets: 
<code><a href="#topic+facet_grid_paginate">facet_grid_paginate</a>()</code>,
<code><a href="#topic+facet_stereo">facet_stereo</a>()</code>,
<code><a href="#topic+facet_wrap_paginate">facet_wrap_paginate</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Zoom in on the versicolor species on the x-axis
ggplot(iris, aes(Petal.Length, Petal.Width, colour = Species)) +
  geom_point() +
  facet_zoom(x = Species == 'versicolor')

# Zoom in on versicolor on both axes
ggplot(iris, aes(Petal.Length, Petal.Width, colour = Species)) +
  geom_point() +
  facet_zoom(xy = Species == 'versicolor')

# Use different zoom criteria on each axis
ggplot(iris, aes(Petal.Length, Petal.Width, colour = Species)) +
  geom_point() +
  facet_zoom(x = Species != 'setosa', y = Species == 'versicolor')

# Get each axis zoom separately as well
ggplot(iris, aes(Petal.Length, Petal.Width, colour = Species)) +
  geom_point() +
  facet_zoom(xy = Species == 'versicolor', split = TRUE)

# Define the zoom area directly
ggplot(iris, aes(Petal.Length, Petal.Width, colour = Species)) +
  geom_point() +
  facet_zoom(xlim = c(2, 4))

# Selectively show data in the zoom panel
ggplot(iris, aes(Petal.Length, Petal.Width, colour = Species)) +
  geom_point() +
  facet_zoom(x = Species == 'versicolor', zoom.data = Species == 'versicolor')
</code></pre>

<hr>
<h2 id='gather_set_data'>Tidy data for use with geom_parallel_sets</h2><span id='topic+gather_set_data'></span>

<h3>Description</h3>

<p>This helper function makes it easy to change tidy data into a tidy(er) format
that can be used by geom_parallel_sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gather_set_data(data, x, id_name = "id")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gather_set_data_+3A_data">data</code></td>
<td>
<p>A tidy dataframe with some categorical columns</p>
</td></tr>
<tr><td><code id="gather_set_data_+3A_x">x</code></td>
<td>
<p>The columns to use for axes in the parallel sets diagram</p>
</td></tr>
<tr><td><code id="gather_set_data_+3A_id_name">id_name</code></td>
<td>
<p>The name of the column that will contain the original index of
the row.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- reshape2::melt(Titanic)
head(gather_set_data(data, 1:4))
</code></pre>

<hr>
<h2 id='geom_arc'>Arcs based on radius and radians</h2><span id='topic+geom_arc'></span><span id='topic+stat_arc'></span><span id='topic+stat_arc2'></span><span id='topic+geom_arc2'></span><span id='topic+stat_arc0'></span><span id='topic+geom_arc0'></span>

<h3>Description</h3>

<p>This set of stats and geoms makes it possible to draw circle segments based
on a center point, a radius and a start and end angle (in radians). These
functions are intended for cartesian coordinate systems and makes it possible
to create circular plot types without using the
<code><a href="ggplot2.html#topic+coord_polar">ggplot2::coord_polar()</a></code> coordinate system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_arc(
  mapping = NULL,
  data = NULL,
  geom = "arc",
  position = "identity",
  na.rm = FALSE,
  show.legend = NA,
  n = 360,
  inherit.aes = TRUE,
  ...
)

geom_arc(
  mapping = NULL,
  data = NULL,
  stat = "arc",
  position = "identity",
  n = 360,
  arrow = NULL,
  lineend = "butt",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)

stat_arc2(
  mapping = NULL,
  data = NULL,
  geom = "path_interpolate",
  position = "identity",
  na.rm = FALSE,
  show.legend = NA,
  n = 360,
  inherit.aes = TRUE,
  ...
)

geom_arc2(
  mapping = NULL,
  data = NULL,
  stat = "arc2",
  position = "identity",
  n = 360,
  arrow = NULL,
  lineend = "butt",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)

stat_arc0(
  mapping = NULL,
  data = NULL,
  geom = "arc0",
  position = "identity",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)

geom_arc0(
  mapping = NULL,
  data = NULL,
  stat = "arc0",
  position = "identity",
  ncp = 5,
  arrow = NULL,
  lineend = "butt",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_arc_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_arc_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_arc_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data, either as a
<code>ggproto</code> <code>Geom</code> subclass or as a string naming the geom stripped of the
<code>geom_</code> prefix (e.g. <code>"point"</code> rather than <code>"geom_point"</code>)</p>
</td></tr>
<tr><td><code id="geom_arc_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_arc_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_arc_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_arc_+3A_n">n</code></td>
<td>
<p>the smoothness of the arc. Sets the number of points to use if the
arc would cover a full circle</p>
</td></tr>
<tr><td><code id="geom_arc_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_arc_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_arc_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_arc_+3A_arrow">arrow</code></td>
<td>
<p>Arrow specification, as created by <code><a href="grid.html#topic+arrow">grid::arrow()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_arc_+3A_lineend">lineend</code></td>
<td>
<p>Line end style (round, butt, square).</p>
</td></tr>
<tr><td><code id="geom_arc_+3A_ncp">ncp</code></td>
<td>
<p>the number of control points used to draw the arc with curveGrob.
Determines how well the arc approximates a circle section</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An arc is a segment of a line describing a circle. It is the
fundamental visual element in donut charts where the length of the segment
(and conversely the angular span of the segment) describes the proportion of
an entety.
</p>


<h3>Aesthetics</h3>

<p>geom_arc understand the following aesthetics (required aesthetics are in
bold):
</p>

<ul>
<li> <p><strong>x0</strong>
</p>
</li>
<li> <p><strong>y0</strong>
</p>
</li>
<li> <p><strong>r</strong>
</p>
</li>
<li> <p><strong>start</strong>
</p>
</li>
<li> <p><strong>end</strong>
</p>
</li>
<li><p> color
</p>
</li>
<li><p> linewidth
</p>
</li>
<li><p> linetype
</p>
</li>
<li><p> alpha
</p>
</li>
<li><p> lineend
</p>
</li></ul>



<h3>Computed variables</h3>


<dl>
<dt>x, y</dt><dd><p>The start coordinates for the segment</p>
</dd>
<dt>xend, yend</dt><dd><p>The end coordinates for the segment</p>
</dd>
<dt>curvature</dt><dd><p>The curvature of the curveGrob to match a circle</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+geom_arc_bar">geom_arc_bar()</a></code> for drawing arcs with fill
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Lets make some data
arcs &lt;- data.frame(
  start = seq(0, 2 * pi, length.out = 11)[-11],
  end = seq(0, 2 * pi, length.out = 11)[-1],
  r = rep(1:2, 5)
)

# Behold the arcs
ggplot(arcs) +
  geom_arc(aes(x0 = 0, y0 = 0, r = r, start = start, end = end,
               linetype = factor(r)))

# Use the calculated index to map values to position on the arc
ggplot(arcs) +
  geom_arc(aes(x0 = 0, y0 = 0, r = r, start = start, end = end,
               size = after_stat(index)), lineend = 'round')

# The 0 version maps directly to curveGrob instead of calculating the points
# itself
ggplot(arcs) +
  geom_arc0(aes(x0 = 0, y0 = 0, r = r, start = start, end = end,
                linetype = factor(r)))

# The 2 version allows interpolation of aesthetics between the start and end
# points
arcs2 &lt;- data.frame(
  angle = c(arcs$start, arcs$end),
  r = rep(arcs$r, 2),
  group = rep(1:10, 2),
  colour = sample(letters[1:5], 20, TRUE)
)

ggplot(arcs2) +
  geom_arc2(aes(x0 = 0, y0 = 0, r = r, end = angle, group = group,
                colour = colour), size = 2)

</code></pre>

<hr>
<h2 id='geom_arc_bar'>Arcs and wedges as polygons</h2><span id='topic+geom_arc_bar'></span><span id='topic+stat_arc_bar'></span><span id='topic+stat_pie'></span>

<h3>Description</h3>

<p>This set of stats and geoms makes it possible to draw arcs and wedges as
known from pie and donut charts as well as more specialized plottypes such as
sunburst plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_arc_bar(
  mapping = NULL,
  data = NULL,
  geom = "arc_bar",
  position = "identity",
  n = 360,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)

stat_pie(
  mapping = NULL,
  data = NULL,
  geom = "arc_bar",
  position = "identity",
  n = 360,
  sep = 0,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)

geom_arc_bar(
  mapping = NULL,
  data = NULL,
  stat = "arc_bar",
  position = "identity",
  n = 360,
  expand = 0,
  radius = 0,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_arc_bar_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_arc_bar_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_arc_bar_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data, either as a
<code>ggproto</code> <code>Geom</code> subclass or as a string naming the geom stripped of the
<code>geom_</code> prefix (e.g. <code>"point"</code> rather than <code>"geom_point"</code>)</p>
</td></tr>
<tr><td><code id="geom_arc_bar_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_arc_bar_+3A_n">n</code></td>
<td>
<p>The number of points used to draw a full circle. The number of
points on each arc will then be calculated as n / span-of-arc</p>
</td></tr>
<tr><td><code id="geom_arc_bar_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_arc_bar_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_arc_bar_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_arc_bar_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_arc_bar_+3A_sep">sep</code></td>
<td>
<p>The separation between arcs in pie/donut charts</p>
</td></tr>
<tr><td><code id="geom_arc_bar_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_arc_bar_+3A_expand">expand</code></td>
<td>
<p>A numeric or unit vector of length one, specifying the
expansion amount. Negative values will result in contraction instead. If the
value is given as a numeric it will be understood as a proportion of the
plot area width.</p>
</td></tr>
<tr><td><code id="geom_arc_bar_+3A_radius">radius</code></td>
<td>
<p>As <code>expand</code> but specifying the corner radius.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An arc bar is the thick version of an arc; that is, a circle segment
drawn as a polygon in the same way as a rectangle is a thick version of a
line. A wedge is a special case of an arc where the inner radius is 0. As
opposed to applying coord_polar to a stacked bar chart, these layers are
drawn in cartesian space, which allows for transformations not possible with
the native ggplot2 approach. Most notable of these are the option to explode
arcs and wedgets away from their center point, thus detaching it from the
main pie/donut.
</p>


<h3>Aesthetics</h3>

<p>geom_arc_bar understand the following aesthetics (required aesthetics are in
bold):
</p>

<ul>
<li> <p><strong>x0</strong>
</p>
</li>
<li> <p><strong>y0</strong>
</p>
</li>
<li> <p><strong>r0</strong>
</p>
</li>
<li> <p><strong>r</strong>
</p>
</li>
<li> <p><strong>start</strong> - when using stat_arc_bar
</p>
</li>
<li> <p><strong>end</strong> - when using stat_arc_bar
</p>
</li>
<li> <p><strong>amount</strong> - when using stat_pie
</p>
</li>
<li><p> explode
</p>
</li>
<li><p> color
</p>
</li>
<li><p> fill
</p>
</li>
<li><p> linewidth
</p>
</li>
<li><p> linetype
</p>
</li>
<li><p> alpha
</p>
</li></ul>



<h3>Computed variables</h3>


<dl>
<dt>x, y</dt><dd><p>x and y coordinates for the polygon</p>
</dd>
</dl>


<dl>
<dt>x, y</dt><dd><p>The start coordinates for the segment</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+geom_arc">geom_arc()</a></code> for drawing arcs as lines
</p>


<h3>Examples</h3>

<pre><code class='language-R'># If you know the angle spans to plot it is easy
arcs &lt;- data.frame(
  start = seq(0, 2 * pi, length.out = 11)[-11],
  end = seq(0, 2 * pi, length.out = 11)[-1],
  r = rep(1:2, 5)
)

# Behold the arcs
ggplot(arcs) +
  geom_arc_bar(aes(x0 = 0, y0 = 0, r0 = r - 1, r = r, start = start,
                   end = end, fill = r))

# geom_arc_bar uses geom_shape to draw the arcs, so you have all the
# possibilities of that as well, e.g. rounding of corners
ggplot(arcs) +
  geom_arc_bar(aes(x0 = 0, y0 = 0, r0 = r - 1, r = r, start = start,
                   end = end, fill = r), radius = unit(4, 'mm'))

# If you got values for a pie chart, use stat_pie
states &lt;- c(
  'eaten', "eaten but said you didn\'t", 'cat took it', 'for tonight',
  'will decompose slowly'
)
pie &lt;- data.frame(
  state = factor(rep(states, 2), levels = states),
  type = rep(c('Pie', 'Donut'), each = 5),
  r0 = rep(c(0, 0.8), each = 5),
  focus = rep(c(0.2, 0, 0, 0, 0), 2),
  amount = c(4, 3, 1, 1.5, 6, 6, 1, 2, 3, 2)
)

# Look at the cakes
ggplot() + geom_arc_bar(aes(
  x0 = 0, y0 = 0, r0 = r0, r = 1, amount = amount,
  fill = state, explode = focus
),
data = pie, stat = 'pie'
) +
  facet_wrap(~type, ncol = 1) +
  coord_fixed() +
  theme_no_axes() +
  scale_fill_brewer('', type = 'qual')

</code></pre>

<hr>
<h2 id='geom_autodensity'>A distribution geoms that fills the panel and works with discrete and continuous data</h2><span id='topic+geom_autodensity'></span><span id='topic+geom_autohistogram'></span>

<h3>Description</h3>

<p>These versions of the histogram and density geoms have been designed
specifically for diagonal plotting with <code><a href="#topic+facet_matrix">facet_matrix()</a></code>. They differ from
<code><a href="ggplot2.html#topic+geom_histogram">ggplot2::geom_histogram()</a></code> and <code><a href="ggplot2.html#topic+geom_density">ggplot2::geom_density()</a></code> in that they
defaults to mapping <code>x</code> and <code>y</code> to <code>.panel_x</code> and <code>.panel_y</code> respectively,
they ignore the y scale of the panel and fills it out, and they work for both
continuous and discrete x scales.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_autodensity(
  mapping = NULL,
  data = NULL,
  stat = "autodensity",
  position = "floatstack",
  ...,
  bw = "nrd0",
  adjust = 1,
  kernel = "gaussian",
  n = 512,
  trim = FALSE,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  outline.type = "upper"
)

geom_autohistogram(
  mapping = NULL,
  data = NULL,
  stat = "autobin",
  position = "floatstack",
  ...,
  bins = NULL,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_autodensity_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_autodensity_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_autodensity_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_autodensity_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_autodensity_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_autodensity_+3A_bw">bw</code></td>
<td>
<p>The smoothing bandwidth to be used.
If numeric, the standard deviation of the smoothing kernel.
If character, a rule to choose the bandwidth, as listed in
<code><a href="stats.html#topic+bandwidth">stats::bw.nrd()</a></code>. Note that automatic calculation of the bandwidth does
not take weights into account.</p>
</td></tr>
<tr><td><code id="geom_autodensity_+3A_adjust">adjust</code></td>
<td>
<p>A multiplicate bandwidth adjustment. This makes it possible
to adjust the bandwidth while still using the a bandwidth estimator.
For example, <code>adjust = 1/2</code> means use half of the default bandwidth.</p>
</td></tr>
<tr><td><code id="geom_autodensity_+3A_kernel">kernel</code></td>
<td>
<p>Kernel. See list of available kernels in <code><a href="stats.html#topic+density">density()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_autodensity_+3A_n">n</code></td>
<td>
<p>number of equally spaced points at which the density is to be
estimated, should be a power of two, see <code><a href="stats.html#topic+density">density()</a></code> for
details</p>
</td></tr>
<tr><td><code id="geom_autodensity_+3A_trim">trim</code></td>
<td>
<p>If <code>FALSE</code>, the default, each density is computed on the
full range of the data. If <code>TRUE</code>, each density is computed over the
range of that group: this typically means the estimated x values will
not line-up, and hence you won't be able to stack density values.
This parameter only matters if you are displaying multiple densities in
one plot or if you are manually adjusting the scale limits.</p>
</td></tr>
<tr><td><code id="geom_autodensity_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_autodensity_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_autodensity_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_autodensity_+3A_outline.type">outline.type</code></td>
<td>
<p>Type of the outline of the area; <code>"both"</code> draws both the
upper and lower lines, <code>"upper"</code>/<code>"lower"</code> draws the respective lines only.
<code>"full"</code> draws a closed polygon around the area.</p>
</td></tr>
<tr><td><code id="geom_autodensity_+3A_bins">bins</code></td>
<td>
<p>Number of bins. Overridden by <code>binwidth</code>. Defaults to 30.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+facet_matrix">facet_matrix</a> for creating matrix grids
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A matrix plot with a mix of discrete and continuous variables
p &lt;- ggplot(mpg) +
  geom_autopoint() +
  facet_matrix(vars(drv:fl), layer.diag = 2, grid.y.diag = FALSE)
p

# Diagonal histograms
p + geom_autohistogram()

# Diagonal density distributions
p + geom_autodensity()

# You can use them like regular layers with groupings etc
p + geom_autodensity(aes(colour = drv, fill = drv),
                     alpha = 0.4)
</code></pre>

<hr>
<h2 id='geom_autopoint'>A point geom specialised for scatterplot matrices</h2><span id='topic+geom_autopoint'></span>

<h3>Description</h3>

<p>This geom is a specialisation of <code><a href="ggplot2.html#topic+geom_point">ggplot2::geom_point()</a></code> with two changes. It
defaults to mapping <code>x</code> and <code>y</code> to <code>.panel_x</code> and <code>.panel_y</code> respectively,
and it defaults to using <code><a href="#topic+position_auto">position_auto()</a></code> to jitter the points based on the
combination of position scale types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_autopoint(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "auto",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_autopoint_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_autopoint_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_autopoint_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_autopoint_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_autopoint_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_autopoint_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_autopoint_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_autopoint_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+facet_matrix">facet_matrix</a> for how to lay out scatterplot matrices and
<a href="#topic+position_auto">position_auto</a> for information about the position adjustments
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Continuous vs continuous: No jitter
ggplot(mpg) + geom_autopoint(aes(cty, hwy))

# Continuous vs discrete: sina jitter
ggplot(mpg) + geom_autopoint(aes(cty, drv))

# Discrete vs discrete: disc-jitter
ggplot(mpg) + geom_autopoint(aes(fl, drv))

# Used with facet_matrix (x and y are automatically mapped)
ggplot(mpg) +
  geom_autopoint() +
  facet_matrix(vars(drv:fl))

</code></pre>

<hr>
<h2 id='geom_bezier'>Create quadratic or cubic bezier curves</h2><span id='topic+geom_bezier'></span><span id='topic+stat_bezier'></span><span id='topic+stat_bezier2'></span><span id='topic+geom_bezier2'></span><span id='topic+stat_bezier0'></span><span id='topic+geom_bezier0'></span>

<h3>Description</h3>

<p>This set of geoms makes it possible to connect points creating either
quadratic or cubic beziers. bezier and bezier2 both work by calculating
points along the bezier and connecting these to draw the curve. bezier0
directly draws the bezier using bezierGrob. In line with the <code><a href="#topic+geom_link">geom_link()</a></code> and
<code><a href="#topic+geom_link2">geom_link2()</a></code> differences geom_bezier creates the points, assign
an index to each interpolated point and repeat the aesthetics for the start
point, while geom_bezier2 interpolates the aesthetics between the start and
end points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_bezier(
  mapping = NULL,
  data = NULL,
  geom = "path",
  position = "identity",
  na.rm = FALSE,
  show.legend = NA,
  n = 100,
  inherit.aes = TRUE,
  ...
)

geom_bezier(
  mapping = NULL,
  data = NULL,
  stat = "bezier",
  position = "identity",
  arrow = NULL,
  lineend = "butt",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  n = 100,
  ...
)

stat_bezier2(
  mapping = NULL,
  data = NULL,
  geom = "path_interpolate",
  position = "identity",
  na.rm = FALSE,
  show.legend = NA,
  n = 100,
  inherit.aes = TRUE,
  ...
)

geom_bezier2(
  mapping = NULL,
  data = NULL,
  stat = "bezier2",
  position = "identity",
  arrow = NULL,
  lineend = "butt",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  n = 100,
  ...
)

stat_bezier0(
  mapping = NULL,
  data = NULL,
  geom = "bezier0",
  position = "identity",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)

geom_bezier0(
  mapping = NULL,
  data = NULL,
  stat = "bezier0",
  position = "identity",
  arrow = NULL,
  lineend = "butt",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_bezier_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_bezier_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_bezier_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data, either as a
<code>ggproto</code> <code>Geom</code> subclass or as a string naming the geom stripped of the
<code>geom_</code> prefix (e.g. <code>"point"</code> rather than <code>"geom_point"</code>)</p>
</td></tr>
<tr><td><code id="geom_bezier_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_bezier_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_bezier_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_bezier_+3A_n">n</code></td>
<td>
<p>The number of points to create for each segment</p>
</td></tr>
<tr><td><code id="geom_bezier_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_bezier_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_bezier_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_bezier_+3A_arrow">arrow</code></td>
<td>
<p>Arrow specification, as created by <code><a href="grid.html#topic+arrow">grid::arrow()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_bezier_+3A_lineend">lineend</code></td>
<td>
<p>Line end style (round, butt, square).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Input data is understood as a sequence of data points the first being the
start point, then followed by one or two control points and then the end
point. More than 4 and less than 3 points per group will throw an error.
<code><a href="grid.html#topic+grid.bezier">grid::bezierGrob()</a></code> only takes cubic beziers so if three points are
supplied the middle one as duplicated. This, along with the fact that
<code><a href="grid.html#topic+grid.bezier">grid::bezierGrob()</a></code> estimates the curve using an x-spline means
that the curves produced by geom_bezier and geom_bezier2 deviates from those
produced by geom_bezier0. If you want true bezier paths use geom_bezier or
geom_bezier2.
</p>


<h3>Aesthetics</h3>

<p>geom_bezier, geom_bezier2 and geom_bezier0 understand the following aesthetics
(required aesthetics are in bold):
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li><p> color
</p>
</li>
<li><p> linewidth
</p>
</li>
<li><p> linetype
</p>
</li>
<li><p> alpha
</p>
</li>
<li><p> lineend
</p>
</li></ul>



<h3>Computed variables</h3>


<dl>
<dt>x, y</dt><dd><p>The interpolated point coordinates</p>
</dd>
<dt>index</dt><dd><p>The progression along the interpolation mapped between 0 and 1</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>beziers &lt;- data.frame(
  x = c(1, 2, 3, 4, 4, 6, 6),
  y = c(0, 2, 0, 0, 2, 2, 0),
  type = rep(c('cubic', 'quadratic'), c(3, 4)),
  point = c('end', 'control', 'end', 'end', 'control', 'control', 'end'),
  colour = letters[1:7]
)
help_lines &lt;- data.frame(
  x = c(1, 3, 4, 6),
  xend = c(2, 2, 4, 6),
  y = 0,
  yend = 2
)

# See how control points affect the bezier
ggplot() +
  geom_segment(aes(x = x, xend = xend, y = y, yend = yend),
               data = help_lines,
               arrow = arrow(length = unit(c(0, 0, 0.5, 0.5), 'cm')),
               colour = 'grey') +
  geom_bezier(aes(x = x, y = y, group = type, linetype = type),
              data = beziers) +
  geom_point(aes(x = x, y = y, colour = point),
             data = beziers)

# geom_bezier0 is less exact
ggplot() +
  geom_segment(aes(x = x, xend = xend, y = y, yend = yend),
               data = help_lines,
               arrow = arrow(length = unit(c(0, 0, 0.5, 0.5), 'cm')),
               colour = 'grey') +
  geom_bezier0(aes(x = x, y = y, group = type, linetype = type),
               data = beziers) +
  geom_point(aes(x = x, y = y, colour = point),
             data = beziers)

# Use geom_bezier2 to interpolate between endpoint aesthetics
ggplot(beziers) +
  geom_bezier2(aes(x = x, y = y, group = type, colour = colour))

</code></pre>

<hr>
<h2 id='geom_bspline'>B-splines based on control points</h2><span id='topic+geom_bspline'></span><span id='topic+stat_bspline'></span><span id='topic+stat_bspline2'></span><span id='topic+geom_bspline2'></span><span id='topic+stat_bspline0'></span><span id='topic+geom_bspline0'></span>

<h3>Description</h3>

<p>This set of stats and geoms makes it possible to draw b-splines based on a
set of control points. As with <code><a href="#topic+geom_bezier">geom_bezier()</a></code> there exists several
versions each having there own strengths. The base version calculates the
b-spline as a number of points along the spline and connects these with a
path. The *2 version does the same but in addition interpolates aesthetics
between each control point. This makes the *2 version considerably slower
so it shouldn't be used unless needed. The *0 version uses
<code><a href="grid.html#topic+grid.xspline">grid::xsplineGrob()</a></code> with <code>shape = 1</code> to approximate a b-spline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_bspline(
  mapping = NULL,
  data = NULL,
  geom = "path",
  position = "identity",
  na.rm = FALSE,
  n = 100,
  type = "clamped",
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)

geom_bspline(
  mapping = NULL,
  data = NULL,
  stat = "bspline",
  position = "identity",
  arrow = NULL,
  n = 100,
  type = "clamped",
  lineend = "butt",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)

stat_bspline2(
  mapping = NULL,
  data = NULL,
  geom = "path_interpolate",
  position = "identity",
  na.rm = FALSE,
  n = 100,
  type = "clamped",
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)

geom_bspline2(
  mapping = NULL,
  data = NULL,
  stat = "bspline2",
  position = "identity",
  arrow = NULL,
  n = 100,
  type = "clamped",
  lineend = "butt",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)

stat_bspline0(
  mapping = NULL,
  data = NULL,
  geom = "bspline0",
  position = "identity",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  type = "clamped",
  ...
)

geom_bspline0(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  arrow = NULL,
  lineend = "butt",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  type = "clamped",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_bspline_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_bspline_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_bspline_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data, either as a
<code>ggproto</code> <code>Geom</code> subclass or as a string naming the geom stripped of the
<code>geom_</code> prefix (e.g. <code>"point"</code> rather than <code>"geom_point"</code>)</p>
</td></tr>
<tr><td><code id="geom_bspline_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_bspline_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_bspline_+3A_n">n</code></td>
<td>
<p>The number of points generated for each spline</p>
</td></tr>
<tr><td><code id="geom_bspline_+3A_type">type</code></td>
<td>
<p>Either <code>'clamped'</code> (default) or <code>'open'</code>. The former creates a
knot sequence that ensures the splines starts and ends at the terminal
control points.</p>
</td></tr>
<tr><td><code id="geom_bspline_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_bspline_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_bspline_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_bspline_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_bspline_+3A_arrow">arrow</code></td>
<td>
<p>Arrow specification, as created by <code><a href="grid.html#topic+arrow">grid::arrow()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_bspline_+3A_lineend">lineend</code></td>
<td>
<p>Line end style (round, butt, square).</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p>geom_bspline understand the following aesthetics (required aesthetics are in
bold):
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li><p> color
</p>
</li>
<li><p> linewidth
</p>
</li>
<li><p> linetype
</p>
</li>
<li><p> alpha
</p>
</li>
<li><p> lineend
</p>
</li></ul>



<h3>Computed variables</h3>


<dl>
<dt>x, y</dt><dd><p>The coordinates for the path describing the spline</p>
</dd>
<dt>index</dt><dd><p>The progression along the interpolation mapped between 0 and 1</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Thomas Lin Pedersen. The C++ code for De Boor's algorithm has been
adapted from
<a href="https://chi3x10.wordpress.com/2009/10/18/de-boor-algorithm-in-c/">Jason Yu-Tseh Chi implementation</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define some control points
cp &lt;- data.frame(
  x = c(
    0, -5, -5, 5, 5, 2.5, 5, 7.5, 5, 2.5, 5, 7.5, 5, -2.5, -5, -7.5, -5,
    -2.5, -5, -7.5, -5
  ),
  y = c(
    0, -5, 5, -5, 5, 5, 7.5, 5, 2.5, -5, -7.5, -5, -2.5, 5, 7.5, 5, 2.5,
    -5, -7.5, -5, -2.5
  ),
  class = sample(letters[1:3], 21, replace = TRUE)
)

# Now create some paths between them
paths &lt;- data.frame(
  ind = c(
    7, 5, 8, 8, 5, 9, 9, 5, 6, 6, 5, 7, 7, 5, 1, 3, 15, 8, 5, 1, 3, 17, 9, 5,
    1, 2, 19, 6, 5, 1, 4, 12, 7, 5, 1, 4, 10, 6, 5, 1, 2, 20
  ),
  group = c(
    1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 7, 7,
    7, 7, 7, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10
  )
)
paths$x &lt;- cp$x[paths$ind]
paths$y &lt;- cp$y[paths$ind]
paths$class &lt;- cp$class[paths$ind]

ggplot(paths) +
  geom_bspline(aes(x = x, y = y, group = group, colour = after_stat(index))) +
  geom_point(aes(x = x, y = y), data = cp, color = 'steelblue')

ggplot(paths) +
  geom_bspline2(aes(x = x, y = y, group = group, colour = class)) +
  geom_point(aes(x = x, y = y), data = cp, color = 'steelblue')

ggplot(paths) +
  geom_bspline0(aes(x = x, y = y, group = group)) +
  geom_point(aes(x = x, y = y), data = cp, color = 'steelblue')

</code></pre>

<hr>
<h2 id='geom_bspline_closed'>Create closed b-spline shapes</h2><span id='topic+geom_bspline_closed'></span><span id='topic+stat_bspline_closed'></span><span id='topic+geom_bspline_closed0'></span>

<h3>Description</h3>

<p>This geom creates closed b-spline curves and draws them as shapes. The
closed b-spline is achieved by wrapping the control points rather than the
knots. The *0 version uses the <code><a href="grid.html#topic+grid.xspline">grid::xsplineGrob()</a></code> function with
<code>open = FALSE</code> and can thus not be manipulated as a shape geom in the same
way as the base version (expand, contract, etc).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_bspline_closed(
  mapping = NULL,
  data = NULL,
  geom = "shape",
  position = "identity",
  na.rm = FALSE,
  n = 100,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)

geom_bspline_closed(
  mapping = NULL,
  data = NULL,
  stat = "bspline",
  position = "identity",
  n = 100,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)

geom_bspline_closed0(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_bspline_closed_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_bspline_closed_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_bspline_closed_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data, either as a
<code>ggproto</code> <code>Geom</code> subclass or as a string naming the geom stripped of the
<code>geom_</code> prefix (e.g. <code>"point"</code> rather than <code>"geom_point"</code>)</p>
</td></tr>
<tr><td><code id="geom_bspline_closed_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_bspline_closed_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_bspline_closed_+3A_n">n</code></td>
<td>
<p>The number of points generated for each spline</p>
</td></tr>
<tr><td><code id="geom_bspline_closed_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_bspline_closed_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_bspline_closed_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_bspline_closed_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p>geom_bspline_closed understand the following aesthetics (required aesthetics
are in bold):
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li><p> color
</p>
</li>
<li><p> fill
</p>
</li>
<li><p> linewidth
</p>
</li>
<li><p> linetype
</p>
</li>
<li><p> alpha
</p>
</li></ul>



<h3>Computed variables</h3>


<dl>
<dt>x, y</dt><dd><p>The coordinates for the path describing the spline</p>
</dd>
<dt>index</dt><dd><p>The progression along the interpolation mapped between 0 and 1</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Thomas Lin Pedersen. The C++ code for De Boor's algorithm has been
adapted from
<a href="https://chi3x10.wordpress.com/2009/10/18/de-boor-algorithm-in-c/">Jason Yu-Tseh Chi implementation</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create 6 random control points
controls &lt;- data.frame(
  x = runif(6),
  y = runif(6)
)

ggplot(controls, aes(x, y)) +
  geom_polygon(fill = NA, colour = 'grey') +
  geom_point(colour = 'red') +
  geom_bspline_closed(alpha = 0.5)

# The 0 version approximates the correct shape
ggplot(controls, aes(x, y)) +
  geom_polygon(fill = NA, colour = 'grey') +
  geom_point(colour = 'red') +
  geom_bspline_closed0(alpha = 0.5)

# But only the standard version supports geom_shape operations
# Be aware of self-intersections though
ggplot(controls, aes(x, y)) +
  geom_polygon(fill = NA, colour = 'grey') +
  geom_point(colour = 'red') +
  geom_bspline_closed(alpha = 0.5, expand = unit(2, 'cm'))
</code></pre>

<hr>
<h2 id='geom_circle'>Circles based on center and radius</h2><span id='topic+geom_circle'></span><span id='topic+stat_circle'></span>

<h3>Description</h3>

<p>This set of stats and geoms makes it possible to draw circles based on a
center point and a radius. In contrast to using
<code><a href="ggplot2.html#topic+geom_point">ggplot2::geom_point()</a></code>, the size of the circles are related to the
coordinate system and not to a separate scale. These functions are intended
for cartesian coordinate systems and will only produce a true circle if
<code><a href="ggplot2.html#topic+coord_fixed">ggplot2::coord_fixed()</a></code> is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_circle(
  mapping = NULL,
  data = NULL,
  geom = "circle",
  position = "identity",
  n = 360,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)

geom_circle(
  mapping = NULL,
  data = NULL,
  stat = "circle",
  position = "identity",
  n = 360,
  expand = 0,
  radius = 0,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_circle_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_circle_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_circle_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data, either as a
<code>ggproto</code> <code>Geom</code> subclass or as a string naming the geom stripped of the
<code>geom_</code> prefix (e.g. <code>"point"</code> rather than <code>"geom_point"</code>)</p>
</td></tr>
<tr><td><code id="geom_circle_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_circle_+3A_n">n</code></td>
<td>
<p>The number of points on the generated path per full circle.</p>
</td></tr>
<tr><td><code id="geom_circle_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_circle_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_circle_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_circle_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_circle_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_circle_+3A_expand">expand</code></td>
<td>
<p>A numeric or unit vector of length one, specifying the
expansion amount. Negative values will result in contraction instead. If the
value is given as a numeric it will be understood as a proportion of the
plot area width.</p>
</td></tr>
<tr><td><code id="geom_circle_+3A_radius">radius</code></td>
<td>
<p>As <code>expand</code> but specifying the corner radius.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p>geom_circle understand the following aesthetics (required aesthetics are in
bold):
</p>

<ul>
<li> <p><strong>x0</strong>
</p>
</li>
<li> <p><strong>y0</strong>
</p>
</li>
<li> <p><strong>r</strong>
</p>
</li>
<li><p> color
</p>
</li>
<li><p> fill
</p>
</li>
<li><p> linewidth
</p>
</li>
<li><p> linetype
</p>
</li>
<li><p> alpha
</p>
</li>
<li><p> lineend
</p>
</li></ul>



<h3>Computed variables</h3>


<dl>
<dt>x, y</dt><dd><p>The start coordinates for the segment</p>
</dd>
</dl>



<h3>Note</h3>

<p>If the intend is to draw a bubble chart then use
<code><a href="ggplot2.html#topic+geom_point">ggplot2::geom_point()</a></code> and map a variable to the size scale
</p>


<h3>See Also</h3>

<p><code><a href="#topic+geom_arc_bar">geom_arc_bar()</a></code> for drawing arcs with fill
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Lets make some data
circles &lt;- data.frame(
  x0 = rep(1:3, 3),
  y0 = rep(1:3, each = 3),
  r = seq(0.1, 1, length.out = 9)
)

# Behold some circles
ggplot() +
  geom_circle(aes(x0 = x0, y0 = y0, r = r, fill = r), data = circles)

# Use coord_fixed to ensure true circularity
ggplot() +
  geom_circle(aes(x0 = x0, y0 = y0, r = r, fill = r), data = circles) +
  coord_fixed()

</code></pre>

<hr>
<h2 id='geom_diagonal'>Draw horizontal diagonals</h2><span id='topic+geom_diagonal'></span><span id='topic+stat_diagonal'></span><span id='topic+stat_diagonal2'></span><span id='topic+geom_diagonal2'></span><span id='topic+stat_diagonal0'></span><span id='topic+geom_diagonal0'></span>

<h3>Description</h3>

<p>A diagonal is a bezier curve where the control points are moved
perpendicularly towards the center in either the x or y direction a fixed
amount. The versions provided here calculates horizontal diagonals meaning
that the x coordinate is moved to achieve the control point. The
<code>geom_diagonal()</code> and <code>stat_diagonal()</code> functions are simply helpers that
takes care of calculating the position of the control points and then
forwards the actual bezier calculations to <code><a href="#topic+geom_bezier">geom_bezier()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_diagonal(
  mapping = NULL,
  data = NULL,
  geom = "path",
  position = "identity",
  n = 100,
  strength = 0.5,
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)

geom_diagonal(
  mapping = NULL,
  data = NULL,
  stat = "diagonal",
  position = "identity",
  n = 100,
  na.rm = FALSE,
  orientation = NA,
  strength = 0.5,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)

stat_diagonal2(
  mapping = NULL,
  data = NULL,
  geom = "path_interpolate",
  position = "identity",
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  n = 100,
  strength = 0.5,
  inherit.aes = TRUE,
  ...
)

geom_diagonal2(
  mapping = NULL,
  data = NULL,
  stat = "diagonal2",
  position = "identity",
  arrow = NULL,
  lineend = "butt",
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE,
  n = 100,
  strength = 0.5,
  ...
)

stat_diagonal0(
  mapping = NULL,
  data = NULL,
  geom = "bezier0",
  position = "identity",
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE,
  strength = 0.5,
  ...
)

geom_diagonal0(
  mapping = NULL,
  data = NULL,
  stat = "diagonal0",
  position = "identity",
  arrow = NULL,
  lineend = "butt",
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE,
  strength = 0.5,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_diagonal_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_diagonal_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_diagonal_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data, either as a
<code>ggproto</code> <code>Geom</code> subclass or as a string naming the geom stripped of the
<code>geom_</code> prefix (e.g. <code>"point"</code> rather than <code>"geom_point"</code>)</p>
</td></tr>
<tr><td><code id="geom_diagonal_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_diagonal_+3A_n">n</code></td>
<td>
<p>The number of points to create for each segment</p>
</td></tr>
<tr><td><code id="geom_diagonal_+3A_strength">strength</code></td>
<td>
<p>The proportion to move the control point along the x-axis
towards the other end of the bezier curve</p>
</td></tr>
<tr><td><code id="geom_diagonal_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_diagonal_+3A_orientation">orientation</code></td>
<td>
<p>The orientation of the layer. The default (<code>NA</code>)
automatically determines the orientation from the aesthetic mapping. In the
rare event that this fails it can be given explicitly by setting <code>orientation</code>
to either <code>"x"</code> or <code>"y"</code>. See the <em>Orientation</em> section for more detail.</p>
</td></tr>
<tr><td><code id="geom_diagonal_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_diagonal_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_diagonal_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_diagonal_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_diagonal_+3A_arrow">arrow</code></td>
<td>
<p>Arrow specification, as created by <code><a href="grid.html#topic+arrow">grid::arrow()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_diagonal_+3A_lineend">lineend</code></td>
<td>
<p>Line end style (round, butt, square).</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p>geom_diagonal and geom_diagonal0 understand the following aesthetics
(required aesthetics are in bold):
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li> <p><strong>xend</strong>
</p>
</li>
<li> <p><strong>yend</strong>
</p>
</li>
<li><p> color
</p>
</li>
<li><p> linewidth
</p>
</li>
<li><p> linetype
</p>
</li>
<li><p> alpha
</p>
</li>
<li><p> lineend
</p>
</li></ul>

<p>geom_diagonal2 understand the following aesthetics
(required aesthetics are in bold):
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li> <p><strong>group</strong>
</p>
</li>
<li><p> color
</p>
</li>
<li><p> linewidth
</p>
</li>
<li><p> linetype
</p>
</li>
<li><p> alpha
</p>
</li>
<li><p> lineend
</p>
</li></ul>



<h3>Computed variables</h3>


<dl>
<dt>x, y</dt><dd><p>The interpolated point coordinates</p>
</dd>
<dt>index</dt><dd><p>The progression along the interpolation mapped between 0 and 1</p>
</dd>
</dl>



<h3>Orientation</h3>

<p>This geom treats each axis differently and, thus, can thus have two orientations. Often the orientation is easy to deduce from a combination of the given mappings and the types of positional scales in use. Thus, ggplot2 will by default try to guess which orientation the layer should have. Under rare circumstances, the orientation is ambiguous and guessing may fail. In that case the orientation can be specified directly using the <code>orientation</code> parameter, which can be either <code>"x"</code> or <code>"y"</code>. The value gives the axis that the geom should run along, <code>"x"</code> being the default orientation you would expect for the geom.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- data.frame(
  x = rep(0, 10),
  y = 1:10,
  xend = 1:10,
  yend = 2:11
)

ggplot(data) +
  geom_diagonal(aes(x, y, xend = xend, yend = yend))

# The standard version provides an index to create gradients
ggplot(data) +
  geom_diagonal(aes(x, y, xend = xend, yend = yend, alpha = after_stat(index)))

# The 0 version uses bezierGrob under the hood for an approximation
ggplot(data) +
  geom_diagonal0(aes(x, y, xend = xend, yend = yend))

# The 2 version allows you to interpolate between endpoint aesthetics
data2 &lt;- data.frame(
  x = c(data$x, data$xend),
  y = c(data$y, data$yend),
  group = rep(1:10, 2),
  colour = sample(letters[1:5], 20, TRUE)
)
ggplot(data2) +
  geom_diagonal2(aes(x, y, group = group, colour = colour))

# Use strength to control the steepness of the central region
ggplot(data, aes(x, y, xend = xend, yend = yend)) +
  geom_diagonal(strength = 0.75, colour = 'red') +
  geom_diagonal(strength = 0.25, colour = 'blue')

</code></pre>

<hr>
<h2 id='geom_diagonal_wide'>Draw an area defined by an upper and lower diagonal</h2><span id='topic+geom_diagonal_wide'></span><span id='topic+stat_diagonal_wide'></span>

<h3>Description</h3>

<p>The <code>geom_diagonal_wide()</code> function draws a <em>thick</em> diagonal, that is, a
polygon confined between a lower and upper <a href="#topic+geom_diagonal">diagonal</a>. This
geom is bidirectional and the direction can be controlled with the
<code>orientation</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_diagonal_wide(
  mapping = NULL,
  data = NULL,
  geom = "shape",
  position = "identity",
  n = 100,
  strength = 0.5,
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)

geom_diagonal_wide(
  mapping = NULL,
  data = NULL,
  stat = "diagonal_wide",
  position = "identity",
  n = 100,
  na.rm = FALSE,
  orientation = NA,
  strength = 0.5,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_diagonal_wide_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_diagonal_wide_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_diagonal_wide_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data, either as a
<code>ggproto</code> <code>Geom</code> subclass or as a string naming the geom stripped of the
<code>geom_</code> prefix (e.g. <code>"point"</code> rather than <code>"geom_point"</code>)</p>
</td></tr>
<tr><td><code id="geom_diagonal_wide_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_diagonal_wide_+3A_n">n</code></td>
<td>
<p>The number of points to create for each of the bounding diagonals</p>
</td></tr>
<tr><td><code id="geom_diagonal_wide_+3A_strength">strength</code></td>
<td>
<p>The proportion to move the control point along the x-axis
towards the other end of the bezier curve</p>
</td></tr>
<tr><td><code id="geom_diagonal_wide_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_diagonal_wide_+3A_orientation">orientation</code></td>
<td>
<p>The orientation of the layer. The default (<code>NA</code>)
automatically determines the orientation from the aesthetic mapping. In the
rare event that this fails it can be given explicitly by setting <code>orientation</code>
to either <code>"x"</code> or <code>"y"</code>. See the <em>Orientation</em> section for more detail.</p>
</td></tr>
<tr><td><code id="geom_diagonal_wide_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_diagonal_wide_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_diagonal_wide_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_diagonal_wide_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p>geom_diagonal_wide understand the following aesthetics
(required aesthetics are in bold):
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li> <p><strong>group</strong>
</p>
</li>
<li><p> color
</p>
</li>
<li><p> linewidth
</p>
</li>
<li><p> linetype
</p>
</li>
<li><p> alpha
</p>
</li>
<li><p> lineend
</p>
</li></ul>



<h3>Orientation</h3>

<p>This geom treats each axis differently and, thus, can thus have two orientations. Often the orientation is easy to deduce from a combination of the given mappings and the types of positional scales in use. Thus, ggplot2 will by default try to guess which orientation the layer should have. Under rare circumstances, the orientation is ambiguous and guessing may fail. In that case the orientation can be specified directly using the <code>orientation</code> parameter, which can be either <code>"x"</code> or <code>"y"</code>. The value gives the axis that the geom should run along, <code>"x"</code> being the default orientation you would expect for the geom.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- data.frame(
  x = c(1, 2, 2, 1, 2, 3, 3, 2),
  y = c(1, 2, 3, 2, 3, 1, 2, 5),
  group = c(1, 1, 1, 1, 2, 2, 2, 2)
)

ggplot(data) +
  geom_diagonal_wide(aes(x, y, group = group))

# The strength control the steepness
ggplot(data, aes(x, y, group = group)) +
  geom_diagonal_wide(strength = 0.75, alpha = 0.5, fill = 'red') +
  geom_diagonal_wide(strength = 0.25, alpha = 0.5, fill = 'blue')

# The diagonal_wide geom uses geom_shape under the hood, so corner rounding
# etc are all there
ggplot(data) +
  geom_diagonal_wide(aes(x, y, group = group), radius = unit(5, 'mm'))

</code></pre>

<hr>
<h2 id='geom_ellipse'>Draw (super)ellipses based on the coordinate system scale</h2><span id='topic+geom_ellipse'></span><span id='topic+stat_ellip'></span>

<h3>Description</h3>

<p>This is a generalisation of <code><a href="#topic+geom_circle">geom_circle()</a></code> that allows you to draw
ellipses at a specified angle and center relative to the coordinate system.
Apart from letting you draw regular ellipsis, the stat is using the
generalised formula for superellipses which can be utilised by setting the
<code>m1</code> and <code>m2</code> aesthetics. If you only set the m1 the m2 value will follow
that to ensure a symmetric appearance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_ellip(
  mapping = NULL,
  data = NULL,
  geom = "circle",
  position = "identity",
  n = 360,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)

geom_ellipse(
  mapping = NULL,
  data = NULL,
  stat = "ellip",
  position = "identity",
  n = 360,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_ellipse_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_ellipse_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_ellipse_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data, either as a
<code>ggproto</code> <code>Geom</code> subclass or as a string naming the geom stripped of the
<code>geom_</code> prefix (e.g. <code>"point"</code> rather than <code>"geom_point"</code>)</p>
</td></tr>
<tr><td><code id="geom_ellipse_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_ellipse_+3A_n">n</code></td>
<td>
<p>The number of points to sample along the ellipse.</p>
</td></tr>
<tr><td><code id="geom_ellipse_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_ellipse_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_ellipse_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_ellipse_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_ellipse_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p>geom_arc understand the following aesthetics (required aesthetics are in
bold):
</p>

<ul>
<li> <p><strong>x0</strong>
</p>
</li>
<li> <p><strong>y0</strong>
</p>
</li>
<li> <p><strong>a</strong>
</p>
</li>
<li> <p><strong>b</strong>
</p>
</li>
<li> <p><strong>angle</strong>
</p>
</li>
<li><p> m1
</p>
</li>
<li><p> m2
</p>
</li>
<li><p> color
</p>
</li>
<li><p> fill
</p>
</li>
<li><p> linewidth
</p>
</li>
<li><p> linetype
</p>
</li>
<li><p> alpha
</p>
</li>
<li><p> lineend
</p>
</li></ul>



<h3>Computed variables</h3>


<dl>
<dt>x, y</dt><dd><p>The coordinates for the points along the ellipse</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># Basic usage
ggplot() +
  geom_ellipse(aes(x0 = 0, y0 = 0, a = 10, b = 3, angle = 0)) +
  coord_fixed()

# Rotation
# Note that it expects radians and rotates the ellipse counter-clockwise
ggplot() +
  geom_ellipse(aes(x0 = 0, y0 = 0, a = 10, b = 3, angle = pi / 4)) +
  coord_fixed()

# Draw a super ellipse
ggplot() +
  geom_ellipse(aes(x0 = 0, y0 = 0, a = 6, b = 3, angle = -pi / 3, m1 = 3)) +
  coord_fixed()
</code></pre>

<hr>
<h2 id='geom_link'>Link points with paths</h2><span id='topic+geom_link'></span><span id='topic+stat_link'></span><span id='topic+stat_link2'></span><span id='topic+geom_link2'></span><span id='topic+geom_link0'></span>

<h3>Description</h3>

<p>This set of geoms makes it possible to connect points using straight lines.
Before you think <code><a href="ggplot2.html#topic+geom_segment">ggplot2::geom_segment()</a></code> and
<code><a href="ggplot2.html#topic+geom_path">ggplot2::geom_path()</a></code>, these functions have some additional tricks
up their sleeves. geom_link connects two points in the same way as
<code><a href="ggplot2.html#topic+geom_segment">ggplot2::geom_segment()</a></code> but does so by interpolating multiple
points between the two. An additional column called index is added to the
data with a sequential progression of the interpolated points. This can be
used to map color or size to the direction of the link. geom_link2 uses the
same syntax as <code><a href="ggplot2.html#topic+geom_path">ggplot2::geom_path()</a></code> but interpolates between the
aesthetics given by each row in the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_link(
  mapping = NULL,
  data = NULL,
  geom = "path",
  position = "identity",
  na.rm = FALSE,
  show.legend = NA,
  n = 100,
  inherit.aes = TRUE,
  ...
)

stat_link2(
  mapping = NULL,
  data = NULL,
  geom = "path_interpolate",
  position = "identity",
  na.rm = FALSE,
  show.legend = NA,
  n = 100,
  inherit.aes = TRUE,
  ...
)

geom_link(
  mapping = NULL,
  data = NULL,
  stat = "link",
  position = "identity",
  arrow = NULL,
  lineend = "butt",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  n = 100,
  ...
)

geom_link2(
  mapping = NULL,
  data = NULL,
  stat = "link2",
  position = "identity",
  arrow = NULL,
  lineend = "butt",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  n = 100,
  ...
)

geom_link0(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  arrow = NULL,
  arrow.fill = NULL,
  lineend = "butt",
  linejoin = "round",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_link_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_link_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_link_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data, either as a
<code>ggproto</code> <code>Geom</code> subclass or as a string naming the geom stripped of the
<code>geom_</code> prefix (e.g. <code>"point"</code> rather than <code>"geom_point"</code>)</p>
</td></tr>
<tr><td><code id="geom_link_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_link_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_link_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_link_+3A_n">n</code></td>
<td>
<p>The number of points to create for each segment</p>
</td></tr>
<tr><td><code id="geom_link_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_link_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_link_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_link_+3A_arrow">arrow</code></td>
<td>
<p>Arrow specification, as created by <code><a href="grid.html#topic+arrow">grid::arrow()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_link_+3A_lineend">lineend</code></td>
<td>
<p>Line end style (round, butt, square).</p>
</td></tr>
<tr><td><code id="geom_link_+3A_arrow.fill">arrow.fill</code></td>
<td>
<p>fill colour to use for the arrow head (if closed). <code>NULL</code>
means use <code>colour</code> aesthetic.</p>
</td></tr>
<tr><td><code id="geom_link_+3A_linejoin">linejoin</code></td>
<td>
<p>Line join style (round, mitre, bevel).</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p>geom_link understand the following aesthetics (required aesthetics are in
bold):
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li> <p><strong>xend</strong>
</p>
</li>
<li> <p><strong>yend</strong>
</p>
</li>
<li><p> color
</p>
</li>
<li><p> size
</p>
</li>
<li><p> linetype
</p>
</li>
<li><p> alpha
</p>
</li>
<li><p> lineend
</p>
</li></ul>

<p>geom_link2 understand the following aesthetics (required aesthetics are in
bold):
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li><p> color
</p>
</li>
<li><p> size
</p>
</li>
<li><p> linetype
</p>
</li>
<li><p> alpha
</p>
</li>
<li><p> lineend
</p>
</li></ul>



<h3>Computed variables</h3>


<dl>
<dt>x, y</dt><dd><p>The interpolated point coordinates</p>
</dd>
<dt>index</dt><dd><p>The progression along the interpolation mapped between 0 and 1</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># Lets make some data
lines &lt;- data.frame(
  x = c(5, 12, 15, 9, 6),
  y = c(17, 20, 4, 15, 5),
  xend = c(19, 17, 2, 9, 5),
  yend = c(10, 18, 7, 12, 1),
  width = c(1, 10, 6, 2, 3),
  colour = letters[1:5]
)

ggplot(lines) +
  geom_link(aes(x = x, y = y, xend = xend, yend = yend, colour = colour,
                alpha = stat(index), size = after_stat(index)))

ggplot(lines) +
  geom_link2(aes(x = x, y = y, colour = colour, size = width, group = 1),
             lineend = 'round', n = 500)

# geom_link0 is simply an alias for geom_segment to put the link geoms in
# line with the other line geoms with multiple versions. `index` is not
# available here
ggplot(lines) +
  geom_link0(aes(x = x, y = y, xend = xend, yend = yend, colour = colour))
</code></pre>

<hr>
<h2 id='geom_mark_circle'>Annotate areas with circles</h2><span id='topic+geom_mark_circle'></span>

<h3>Description</h3>

<p>This geom lets you annotate sets of points via circles. The enclosing circles
are calculated at draw time and the most optimal enclosure at the given
aspect ratio is thus guaranteed. As with the other <code style="white-space: pre;">&#8288;geom_mark_*&#8288;</code> geoms the
enclosure inherits from <code><a href="#topic+geom_shape">geom_shape()</a></code> and defaults to be expanded slightly
to better enclose the points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_mark_circle(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  expand = unit(5, "mm"),
  radius = expand,
  n = 100,
  label.margin = margin(2, 2, 2, 2, "mm"),
  label.width = NULL,
  label.minwidth = unit(50, "mm"),
  label.hjust = 0,
  label.fontsize = 12,
  label.family = "",
  label.lineheight = 1,
  label.fontface = c("bold", "plain"),
  label.fill = "white",
  label.colour = "black",
  label.buffer = unit(10, "mm"),
  con.colour = "black",
  con.size = 0.5,
  con.type = "elbow",
  con.linetype = 1,
  con.border = "one",
  con.cap = unit(3, "mm"),
  con.arrow = NULL,
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_mark_circle_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_mark_circle_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_mark_circle_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_mark_circle_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_mark_circle_+3A_expand">expand</code></td>
<td>
<p>A numeric or unit vector of length one, specifying the
expansion amount. Negative values will result in contraction instead. If the
value is given as a numeric it will be understood as a proportion of the
plot area width.</p>
</td></tr>
<tr><td><code id="geom_mark_circle_+3A_radius">radius</code></td>
<td>
<p>As <code>expand</code> but specifying the corner radius.</p>
</td></tr>
<tr><td><code id="geom_mark_circle_+3A_n">n</code></td>
<td>
<p>The number of points used to draw each circle. Defaults to <code>100</code>.</p>
</td></tr>
<tr><td><code id="geom_mark_circle_+3A_label.margin">label.margin</code></td>
<td>
<p>The margin around the annotation boxes, given by a call
to <code><a href="ggplot2.html#topic+element">ggplot2::margin()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_mark_circle_+3A_label.width">label.width</code></td>
<td>
<p>A fixed width for the label. Set to <code>NULL</code> to let the text
or <code>label.minwidth</code> decide.</p>
</td></tr>
<tr><td><code id="geom_mark_circle_+3A_label.minwidth">label.minwidth</code></td>
<td>
<p>The minimum width to provide for the description. If
the size of the label exceeds this, the description is allowed to fill as
much as the label.</p>
</td></tr>
<tr><td><code id="geom_mark_circle_+3A_label.hjust">label.hjust</code></td>
<td>
<p>The horizontal justification for the annotation. If it
contains two elements the first will be used for the label and the second for
the description.</p>
</td></tr>
<tr><td><code id="geom_mark_circle_+3A_label.fontsize">label.fontsize</code></td>
<td>
<p>The size of the text for the annotation. If it contains
two elements the first will be used for the label and the second for the
description.</p>
</td></tr>
<tr><td><code id="geom_mark_circle_+3A_label.family">label.family</code></td>
<td>
<p>The font family used for the annotation. If it contains
two elements the first will be used for the label and the second for the
description.</p>
</td></tr>
<tr><td><code id="geom_mark_circle_+3A_label.lineheight">label.lineheight</code></td>
<td>
<p>The height of a line as a multipler of the fontsize.
If it contains two elements the first will be used for the label and the
second for the description.</p>
</td></tr>
<tr><td><code id="geom_mark_circle_+3A_label.fontface">label.fontface</code></td>
<td>
<p>The font face used for the annotation. If it contains
two elements the first will be used for the label and the second for the
description.</p>
</td></tr>
<tr><td><code id="geom_mark_circle_+3A_label.fill">label.fill</code></td>
<td>
<p>The fill colour for the annotation box.</p>
</td></tr>
<tr><td><code id="geom_mark_circle_+3A_label.colour">label.colour</code></td>
<td>
<p>The text colour for the annotation. If it contains
two elements the first will be used for the label and the second for the
description.</p>
</td></tr>
<tr><td><code id="geom_mark_circle_+3A_label.buffer">label.buffer</code></td>
<td>
<p>The size of the region around the mark where labels
cannot be placed.</p>
</td></tr>
<tr><td><code id="geom_mark_circle_+3A_con.colour">con.colour</code></td>
<td>
<p>The colour for the line connecting the annotation to the
mark.</p>
</td></tr>
<tr><td><code id="geom_mark_circle_+3A_con.size">con.size</code></td>
<td>
<p>The width of the connector.</p>
</td></tr>
<tr><td><code id="geom_mark_circle_+3A_con.type">con.type</code></td>
<td>
<p>The type of the connector. Either <code>"elbow"</code>, <code>"straight"</code>, or
<code>"none"</code>.</p>
</td></tr>
<tr><td><code id="geom_mark_circle_+3A_con.linetype">con.linetype</code></td>
<td>
<p>The linetype of the connector.</p>
</td></tr>
<tr><td><code id="geom_mark_circle_+3A_con.border">con.border</code></td>
<td>
<p>The bordertype of the connector. Either <code>"one"</code> (to draw a
line on the horizontal side closest to the mark), <code>"all"</code> (to draw a border
on all sides), or <code>"none"</code> (not going to explain that one).</p>
</td></tr>
<tr><td><code id="geom_mark_circle_+3A_con.cap">con.cap</code></td>
<td>
<p>The distance before the mark that the line should stop at.</p>
</td></tr>
<tr><td><code id="geom_mark_circle_+3A_con.arrow">con.arrow</code></td>
<td>
<p>An arrow specification for the connection using
<code><a href="grid.html#topic+arrow">grid::arrow()</a></code> for the end pointing towards the mark.</p>
</td></tr>
<tr><td><code id="geom_mark_circle_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_mark_circle_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_mark_circle_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_mark_circle_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Annotation</h3>

<p>All <code style="white-space: pre;">&#8288;geom_mark_*&#8288;</code> allow you to put descriptive textboxes connected to the
mark on the plot, using the <code>label</code> and <code>description</code> aesthetics. The
textboxes are automatically placed close to the mark, but without obscuring
any of the datapoints in the layer. The placement is dynamic so if you resize
the plot you'll see that the annotation might move around as areas become big
enough or too small to fit the annotation. If there's not enough space for
the annotation without overlapping data it will not get drawn. In these cases
try resizing the plot, change the size of the annotation, or decrease the
buffer region around the marks.
</p>


<h3>Filtering</h3>

<p>Often marks are used to draw attention to, or annotate specific features of
the plot and it is thus not desirable to have marks around everything. While
it is possible to simply pre-filter the data used for the mark layer, the
<code style="white-space: pre;">&#8288;geom_mark_*&#8288;</code> geoms also comes with a dedicated <code>filter</code> aesthetic that, if
set, will remove all rows where it evalutates to <code>FALSE</code>. There are
multiple benefits of using this instead of prefiltering. First, you don't
have to change your data source, making your code more adaptable for
exploration. Second, the data removed by the filter aesthetic is remembered
by the geom, and any annotation will take care not to overlap with the
removed data.
</p>


<h3>Aesthetics</h3>

<p>geom_mark_circle understand the following aesthetics (required aesthetics are
in bold):
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li><p> x0 <em>(used to anchor the label)</em>
</p>
</li>
<li><p> y0 <em>(used to anchor the label)</em>
</p>
</li>
<li><p> filter
</p>
</li>
<li><p> label
</p>
</li>
<li><p> description
</p>
</li>
<li><p> color
</p>
</li>
<li><p> fill
</p>
</li>
<li><p> group
</p>
</li>
<li><p> size
</p>
</li>
<li><p> linetype
</p>
</li>
<li><p> alpha
</p>
</li></ul>



<h3>See Also</h3>

<p>Other mark geoms: 
<code><a href="#topic+geom_mark_ellipse">geom_mark_ellipse</a>()</code>,
<code><a href="#topic+geom_mark_hull">geom_mark_hull</a>()</code>,
<code><a href="#topic+geom_mark_rect">geom_mark_rect</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ggplot(iris, aes(Petal.Length, Petal.Width)) +
  geom_mark_circle(aes(fill = Species, filter = Species != 'versicolor')) +
  geom_point()

# Add annotation
ggplot(iris, aes(Petal.Length, Petal.Width)) +
  geom_mark_circle(aes(fill = Species, label = Species)) +
  geom_point()

# Long descriptions are automatically wrapped to fit into the width
iris$desc &lt;- c(
  'A super Iris - and it knows it',
  'Pretty mediocre Iris, but give it a couple of years and it might surprise you',
  "You'll never guess what this Iris does every Sunday"
)[iris$Species]

ggplot(iris, aes(Petal.Length, Petal.Width)) +
  geom_mark_circle(aes(fill = Species, label = Species, description = desc,
                       filter = Species == 'setosa')) +
  geom_point()

# Change the buffer size to move labels farther away (or closer) from the
# marks
ggplot(iris, aes(Petal.Length, Petal.Width)) +
  geom_mark_circle(aes(fill = Species, label = Species),
                   label.buffer = unit(30, 'mm')) +
  geom_point()

# The connector is capped a bit before it reaches the mark, but this can be
# controlled
ggplot(iris, aes(Petal.Length, Petal.Width)) +
  geom_mark_circle(aes(fill = Species, label = Species),
                   con.cap = 0) +
  geom_point()
</code></pre>

<hr>
<h2 id='geom_mark_ellipse'>Annotate areas with ellipses</h2><span id='topic+geom_mark_ellipse'></span>

<h3>Description</h3>

<p>This geom lets you annotate sets of points via ellipses. The enclosing
ellipses are estimated using the Khachiyan algorithm which guarantees an
optimal solution within the given tolerance level. As this geom is often
expanded it is of lesser concern that some points are slightly outside the
ellipsis. The Khachiyan algorithm has polynomial complexity and can thus
suffer from scaling issues. Still, it is only calculated on the convex hull
of the groups, so performance issues should be rare (it can easily handle a
hull consisting of 1000 points).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_mark_ellipse(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  expand = unit(5, "mm"),
  radius = expand,
  n = 100,
  tol = 0.01,
  label.margin = margin(2, 2, 2, 2, "mm"),
  label.width = NULL,
  label.minwidth = unit(50, "mm"),
  label.hjust = 0,
  label.fontsize = 12,
  label.family = "",
  label.lineheight = 1,
  label.fontface = c("bold", "plain"),
  label.fill = "white",
  label.colour = "black",
  label.buffer = unit(10, "mm"),
  con.colour = "black",
  con.size = 0.5,
  con.type = "elbow",
  con.linetype = 1,
  con.border = "one",
  con.cap = unit(3, "mm"),
  con.arrow = NULL,
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_mark_ellipse_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_mark_ellipse_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_mark_ellipse_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_mark_ellipse_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_mark_ellipse_+3A_expand">expand</code></td>
<td>
<p>A numeric or unit vector of length one, specifying the
expansion amount. Negative values will result in contraction instead. If the
value is given as a numeric it will be understood as a proportion of the
plot area width.</p>
</td></tr>
<tr><td><code id="geom_mark_ellipse_+3A_radius">radius</code></td>
<td>
<p>As <code>expand</code> but specifying the corner radius.</p>
</td></tr>
<tr><td><code id="geom_mark_ellipse_+3A_n">n</code></td>
<td>
<p>The number of points used to draw each ellipse. Defaults to <code>100</code>.</p>
</td></tr>
<tr><td><code id="geom_mark_ellipse_+3A_tol">tol</code></td>
<td>
<p>The tolerance cutoff. Lower values will result in ellipses closer
to the optimal solution. Defaults to <code>0.01</code>.</p>
</td></tr>
<tr><td><code id="geom_mark_ellipse_+3A_label.margin">label.margin</code></td>
<td>
<p>The margin around the annotation boxes, given by a call
to <code><a href="ggplot2.html#topic+element">ggplot2::margin()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_mark_ellipse_+3A_label.width">label.width</code></td>
<td>
<p>A fixed width for the label. Set to <code>NULL</code> to let the text
or <code>label.minwidth</code> decide.</p>
</td></tr>
<tr><td><code id="geom_mark_ellipse_+3A_label.minwidth">label.minwidth</code></td>
<td>
<p>The minimum width to provide for the description. If
the size of the label exceeds this, the description is allowed to fill as
much as the label.</p>
</td></tr>
<tr><td><code id="geom_mark_ellipse_+3A_label.hjust">label.hjust</code></td>
<td>
<p>The horizontal justification for the annotation. If it
contains two elements the first will be used for the label and the second for
the description.</p>
</td></tr>
<tr><td><code id="geom_mark_ellipse_+3A_label.fontsize">label.fontsize</code></td>
<td>
<p>The size of the text for the annotation. If it contains
two elements the first will be used for the label and the second for the
description.</p>
</td></tr>
<tr><td><code id="geom_mark_ellipse_+3A_label.family">label.family</code></td>
<td>
<p>The font family used for the annotation. If it contains
two elements the first will be used for the label and the second for the
description.</p>
</td></tr>
<tr><td><code id="geom_mark_ellipse_+3A_label.lineheight">label.lineheight</code></td>
<td>
<p>The height of a line as a multipler of the fontsize.
If it contains two elements the first will be used for the label and the
second for the description.</p>
</td></tr>
<tr><td><code id="geom_mark_ellipse_+3A_label.fontface">label.fontface</code></td>
<td>
<p>The font face used for the annotation. If it contains
two elements the first will be used for the label and the second for the
description.</p>
</td></tr>
<tr><td><code id="geom_mark_ellipse_+3A_label.fill">label.fill</code></td>
<td>
<p>The fill colour for the annotation box.</p>
</td></tr>
<tr><td><code id="geom_mark_ellipse_+3A_label.colour">label.colour</code></td>
<td>
<p>The text colour for the annotation. If it contains
two elements the first will be used for the label and the second for the
description.</p>
</td></tr>
<tr><td><code id="geom_mark_ellipse_+3A_label.buffer">label.buffer</code></td>
<td>
<p>The size of the region around the mark where labels
cannot be placed.</p>
</td></tr>
<tr><td><code id="geom_mark_ellipse_+3A_con.colour">con.colour</code></td>
<td>
<p>The colour for the line connecting the annotation to the
mark.</p>
</td></tr>
<tr><td><code id="geom_mark_ellipse_+3A_con.size">con.size</code></td>
<td>
<p>The width of the connector.</p>
</td></tr>
<tr><td><code id="geom_mark_ellipse_+3A_con.type">con.type</code></td>
<td>
<p>The type of the connector. Either <code>"elbow"</code>, <code>"straight"</code>, or
<code>"none"</code>.</p>
</td></tr>
<tr><td><code id="geom_mark_ellipse_+3A_con.linetype">con.linetype</code></td>
<td>
<p>The linetype of the connector.</p>
</td></tr>
<tr><td><code id="geom_mark_ellipse_+3A_con.border">con.border</code></td>
<td>
<p>The bordertype of the connector. Either <code>"one"</code> (to draw a
line on the horizontal side closest to the mark), <code>"all"</code> (to draw a border
on all sides), or <code>"none"</code> (not going to explain that one).</p>
</td></tr>
<tr><td><code id="geom_mark_ellipse_+3A_con.cap">con.cap</code></td>
<td>
<p>The distance before the mark that the line should stop at.</p>
</td></tr>
<tr><td><code id="geom_mark_ellipse_+3A_con.arrow">con.arrow</code></td>
<td>
<p>An arrow specification for the connection using
<code><a href="grid.html#topic+arrow">grid::arrow()</a></code> for the end pointing towards the mark.</p>
</td></tr>
<tr><td><code id="geom_mark_ellipse_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_mark_ellipse_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_mark_ellipse_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_mark_ellipse_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_mark_ellipse</code> understands the following aesthetics (required aesthetics are
in bold):
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li><p> x0 <em>(used to anchor the label)</em>
</p>
</li>
<li><p> y0 <em>(used to anchor the label)</em>
</p>
</li>
<li><p> filter
</p>
</li>
<li><p> label
</p>
</li>
<li><p> description
</p>
</li>
<li><p> color
</p>
</li>
<li><p> fill
</p>
</li>
<li><p> group
</p>
</li>
<li><p> size
</p>
</li>
<li><p> linetype
</p>
</li>
<li><p> alpha
</p>
</li></ul>



<h3>Annotation</h3>

<p>All <code style="white-space: pre;">&#8288;geom_mark_*&#8288;</code> allow you to put descriptive textboxes connected to the
mark on the plot, using the <code>label</code> and <code>description</code> aesthetics. The
textboxes are automatically placed close to the mark, but without obscuring
any of the datapoints in the layer. The placement is dynamic so if you resize
the plot you'll see that the annotation might move around as areas become big
enough or too small to fit the annotation. If there's not enough space for
the annotation without overlapping data it will not get drawn. In these cases
try resizing the plot, change the size of the annotation, or decrease the
buffer region around the marks.
</p>


<h3>Filtering</h3>

<p>Often marks are used to draw attention to, or annotate specific features of
the plot and it is thus not desirable to have marks around everything. While
it is possible to simply pre-filter the data used for the mark layer, the
<code style="white-space: pre;">&#8288;geom_mark_*&#8288;</code> geoms also comes with a dedicated <code>filter</code> aesthetic that, if
set, will remove all rows where it evalutates to <code>FALSE</code>. There are
multiple benefits of using this instead of prefiltering. First, you don't
have to change your data source, making your code more adaptable for
exploration. Second, the data removed by the filter aesthetic is remembered
by the geom, and any annotation will take care not to overlap with the
removed data.
</p>


<h3>See Also</h3>

<p>Other mark geoms: 
<code><a href="#topic+geom_mark_circle">geom_mark_circle</a>()</code>,
<code><a href="#topic+geom_mark_hull">geom_mark_hull</a>()</code>,
<code><a href="#topic+geom_mark_rect">geom_mark_rect</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ggplot(iris, aes(Petal.Length, Petal.Width)) +
  geom_mark_ellipse(aes(fill = Species, filter = Species != 'versicolor')) +
  geom_point()

# Add annotation
ggplot(iris, aes(Petal.Length, Petal.Width)) +
  geom_mark_ellipse(aes(fill = Species, label = Species)) +
  geom_point()

# Long descriptions are automatically wrapped to fit into the width
iris$desc &lt;- c(
  'A super Iris - and it knows it',
  'Pretty mediocre Iris, but give it a couple of years and it might surprise you',
  "You'll never guess what this Iris does every Sunday"
)[iris$Species]

ggplot(iris, aes(Petal.Length, Petal.Width)) +
  geom_mark_ellipse(aes(fill = Species, label = Species, description = desc,
                        filter = Species == 'setosa')) +
  geom_point()

# Change the buffer size to move labels farther away (or closer) from the
# marks
ggplot(iris, aes(Petal.Length, Petal.Width)) +
  geom_mark_ellipse(aes(fill = Species, label = Species),
                    label.buffer = unit(40, 'mm')) +
  geom_point()

# The connector is capped a bit before it reaches the mark, but this can be
# controlled
ggplot(iris, aes(Petal.Length, Petal.Width)) +
  geom_mark_ellipse(aes(fill = Species, label = Species),
                    con.cap = 0) +
  geom_point()
</code></pre>

<hr>
<h2 id='geom_mark_hull'>Annotate areas with hulls</h2><span id='topic+geom_mark_hull'></span>

<h3>Description</h3>

<p>This geom lets you annotate sets of points via hulls. While convex hulls are
most common due to their clear definition, they can lead to large areas
covered that does not contain points. Due to this <code>geom_mark_hull</code> uses
concaveman which lets you adjust concavity of the resulting hull. The hull is
calculated at draw time, and can thus change as you resize the plot. In order
to clearly contain all points, and for aesthetic purpose the resulting hull
is expanded 5mm and rounded on the corners. This can be adjusted with the
<code>expand</code> and <code>radius</code> parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_mark_hull(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  expand = unit(5, "mm"),
  radius = unit(2.5, "mm"),
  concavity = 2,
  label.margin = margin(2, 2, 2, 2, "mm"),
  label.width = NULL,
  label.minwidth = unit(50, "mm"),
  label.hjust = 0,
  label.fontsize = 12,
  label.family = "",
  label.lineheight = 1,
  label.fontface = c("bold", "plain"),
  label.fill = "white",
  label.colour = "black",
  label.buffer = unit(10, "mm"),
  con.colour = "black",
  con.size = 0.5,
  con.type = "elbow",
  con.linetype = 1,
  con.border = "one",
  con.cap = unit(3, "mm"),
  con.arrow = NULL,
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_mark_hull_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_mark_hull_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_mark_hull_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_mark_hull_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_mark_hull_+3A_expand">expand</code></td>
<td>
<p>A numeric or unit vector of length one, specifying the
expansion amount. Negative values will result in contraction instead. If the
value is given as a numeric it will be understood as a proportion of the
plot area width.</p>
</td></tr>
<tr><td><code id="geom_mark_hull_+3A_radius">radius</code></td>
<td>
<p>As <code>expand</code> but specifying the corner radius.</p>
</td></tr>
<tr><td><code id="geom_mark_hull_+3A_concavity">concavity</code></td>
<td>
<p>A measure of the concavity of the hull. <code>1</code> is very concave
while it approaches convex as it grows. Defaults to <code>2</code>.</p>
</td></tr>
<tr><td><code id="geom_mark_hull_+3A_label.margin">label.margin</code></td>
<td>
<p>The margin around the annotation boxes, given by a call
to <code><a href="ggplot2.html#topic+element">ggplot2::margin()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_mark_hull_+3A_label.width">label.width</code></td>
<td>
<p>A fixed width for the label. Set to <code>NULL</code> to let the text
or <code>label.minwidth</code> decide.</p>
</td></tr>
<tr><td><code id="geom_mark_hull_+3A_label.minwidth">label.minwidth</code></td>
<td>
<p>The minimum width to provide for the description. If
the size of the label exceeds this, the description is allowed to fill as
much as the label.</p>
</td></tr>
<tr><td><code id="geom_mark_hull_+3A_label.hjust">label.hjust</code></td>
<td>
<p>The horizontal justification for the annotation. If it
contains two elements the first will be used for the label and the second for
the description.</p>
</td></tr>
<tr><td><code id="geom_mark_hull_+3A_label.fontsize">label.fontsize</code></td>
<td>
<p>The size of the text for the annotation. If it contains
two elements the first will be used for the label and the second for the
description.</p>
</td></tr>
<tr><td><code id="geom_mark_hull_+3A_label.family">label.family</code></td>
<td>
<p>The font family used for the annotation. If it contains
two elements the first will be used for the label and the second for the
description.</p>
</td></tr>
<tr><td><code id="geom_mark_hull_+3A_label.lineheight">label.lineheight</code></td>
<td>
<p>The height of a line as a multipler of the fontsize.
If it contains two elements the first will be used for the label and the
second for the description.</p>
</td></tr>
<tr><td><code id="geom_mark_hull_+3A_label.fontface">label.fontface</code></td>
<td>
<p>The font face used for the annotation. If it contains
two elements the first will be used for the label and the second for the
description.</p>
</td></tr>
<tr><td><code id="geom_mark_hull_+3A_label.fill">label.fill</code></td>
<td>
<p>The fill colour for the annotation box.</p>
</td></tr>
<tr><td><code id="geom_mark_hull_+3A_label.colour">label.colour</code></td>
<td>
<p>The text colour for the annotation. If it contains
two elements the first will be used for the label and the second for the
description.</p>
</td></tr>
<tr><td><code id="geom_mark_hull_+3A_label.buffer">label.buffer</code></td>
<td>
<p>The size of the region around the mark where labels
cannot be placed.</p>
</td></tr>
<tr><td><code id="geom_mark_hull_+3A_con.colour">con.colour</code></td>
<td>
<p>The colour for the line connecting the annotation to the
mark.</p>
</td></tr>
<tr><td><code id="geom_mark_hull_+3A_con.size">con.size</code></td>
<td>
<p>The width of the connector.</p>
</td></tr>
<tr><td><code id="geom_mark_hull_+3A_con.type">con.type</code></td>
<td>
<p>The type of the connector. Either <code>"elbow"</code>, <code>"straight"</code>, or
<code>"none"</code>.</p>
</td></tr>
<tr><td><code id="geom_mark_hull_+3A_con.linetype">con.linetype</code></td>
<td>
<p>The linetype of the connector.</p>
</td></tr>
<tr><td><code id="geom_mark_hull_+3A_con.border">con.border</code></td>
<td>
<p>The bordertype of the connector. Either <code>"one"</code> (to draw a
line on the horizontal side closest to the mark), <code>"all"</code> (to draw a border
on all sides), or <code>"none"</code> (not going to explain that one).</p>
</td></tr>
<tr><td><code id="geom_mark_hull_+3A_con.cap">con.cap</code></td>
<td>
<p>The distance before the mark that the line should stop at.</p>
</td></tr>
<tr><td><code id="geom_mark_hull_+3A_con.arrow">con.arrow</code></td>
<td>
<p>An arrow specification for the connection using
<code><a href="grid.html#topic+arrow">grid::arrow()</a></code> for the end pointing towards the mark.</p>
</td></tr>
<tr><td><code id="geom_mark_hull_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_mark_hull_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_mark_hull_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_mark_hull_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_mark_hull</code> understand the following aesthetics (required aesthetics are
in bold):
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li><p> x0 <em>(used to anchor the label)</em>
</p>
</li>
<li><p> y0 <em>(used to anchor the label)</em>
</p>
</li>
<li><p> filter
</p>
</li>
<li><p> label
</p>
</li>
<li><p> description
</p>
</li>
<li><p> color
</p>
</li>
<li><p> fill
</p>
</li>
<li><p> group
</p>
</li>
<li><p> size
</p>
</li>
<li><p> linetype
</p>
</li>
<li><p> alpha
</p>
</li></ul>



<h3>Annotation</h3>

<p>All <code style="white-space: pre;">&#8288;geom_mark_*&#8288;</code> allow you to put descriptive textboxes connected to the
mark on the plot, using the <code>label</code> and <code>description</code> aesthetics. The
textboxes are automatically placed close to the mark, but without obscuring
any of the datapoints in the layer. The placement is dynamic so if you resize
the plot you'll see that the annotation might move around as areas become big
enough or too small to fit the annotation. If there's not enough space for
the annotation without overlapping data it will not get drawn. In these cases
try resizing the plot, change the size of the annotation, or decrease the
buffer region around the marks.
</p>


<h3>Filtering</h3>

<p>Often marks are used to draw attention to, or annotate specific features of
the plot and it is thus not desirable to have marks around everything. While
it is possible to simply pre-filter the data used for the mark layer, the
<code style="white-space: pre;">&#8288;geom_mark_*&#8288;</code> geoms also comes with a dedicated <code>filter</code> aesthetic that, if
set, will remove all rows where it evalutates to <code>FALSE</code>. There are
multiple benefits of using this instead of prefiltering. First, you don't
have to change your data source, making your code more adaptable for
exploration. Second, the data removed by the filter aesthetic is remembered
by the geom, and any annotation will take care not to overlap with the
removed data.
</p>


<h3>See Also</h3>

<p>Other mark geoms: 
<code><a href="#topic+geom_mark_circle">geom_mark_circle</a>()</code>,
<code><a href="#topic+geom_mark_ellipse">geom_mark_ellipse</a>()</code>,
<code><a href="#topic+geom_mark_rect">geom_mark_rect</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## requires the concaveman packages
ggplot(iris, aes(Petal.Length, Petal.Width)) +
  geom_mark_hull(aes(fill = Species, filter = Species != 'versicolor')) +
  geom_point()

# Adjusting the concavity lets you change the shape of the hull
ggplot(iris, aes(Petal.Length, Petal.Width)) +
  geom_mark_hull(aes(fill = Species, filter = Species != 'versicolor'),
    concavity = 1
  ) +
  geom_point()

ggplot(iris, aes(Petal.Length, Petal.Width)) +
  geom_mark_hull(aes(fill = Species, filter = Species != 'versicolor'),
    concavity = 10
  ) +
  geom_point()

# Add annotation
ggplot(iris, aes(Petal.Length, Petal.Width)) +
  geom_mark_hull(aes(fill = Species, label = Species)) +
  geom_point()

# Long descriptions are automatically wrapped to fit into the width
iris$desc &lt;- c(
  'A super Iris - and it knows it',
  'Pretty mediocre Iris, but give it a couple of years and it might surprise you',
  "You'll never guess what this Iris does every Sunday"
)[iris$Species]

ggplot(iris, aes(Petal.Length, Petal.Width)) +
  geom_mark_hull(aes(fill = Species, label = Species, description = desc,
                     filter = Species == 'setosa')) +
  geom_point()

# Change the buffer size to move labels farther away (or closer) from the
# marks
ggplot(iris, aes(Petal.Length, Petal.Width)) +
  geom_mark_hull(aes(fill = Species, label = Species),
                 label.buffer = unit(40, 'mm')) +
  geom_point()

# The connector is capped a bit before it reaches the mark, but this can be
# controlled
ggplot(iris, aes(Petal.Length, Petal.Width)) +
  geom_mark_hull(aes(fill = Species, label = Species),
                 con.cap = 0) +
  geom_point()
</code></pre>

<hr>
<h2 id='geom_mark_rect'>Annotate areas with rectangles</h2><span id='topic+geom_mark_rect'></span>

<h3>Description</h3>

<p>This geom lets you annotate sets of points via rectangles. The rectangles are
simply scaled to the range of the data and as with the other
<code style="white-space: pre;">&#8288;geom_mark_*()&#8288;</code> geoms expanded and have rounded corners.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_mark_rect(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  expand = unit(5, "mm"),
  radius = unit(2.5, "mm"),
  label.margin = margin(2, 2, 2, 2, "mm"),
  label.width = NULL,
  label.minwidth = unit(50, "mm"),
  label.hjust = 0,
  label.fontsize = 12,
  label.family = "",
  label.lineheight = 1,
  label.fontface = c("bold", "plain"),
  label.fill = "white",
  label.colour = "black",
  label.buffer = unit(10, "mm"),
  con.colour = "black",
  con.size = 0.5,
  con.type = "elbow",
  con.linetype = 1,
  con.border = "one",
  con.cap = unit(3, "mm"),
  con.arrow = NULL,
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_mark_rect_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_mark_rect_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_mark_rect_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_mark_rect_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_mark_rect_+3A_expand">expand</code></td>
<td>
<p>A numeric or unit vector of length one, specifying the
expansion amount. Negative values will result in contraction instead. If the
value is given as a numeric it will be understood as a proportion of the
plot area width.</p>
</td></tr>
<tr><td><code id="geom_mark_rect_+3A_radius">radius</code></td>
<td>
<p>As <code>expand</code> but specifying the corner radius.</p>
</td></tr>
<tr><td><code id="geom_mark_rect_+3A_label.margin">label.margin</code></td>
<td>
<p>The margin around the annotation boxes, given by a call
to <code><a href="ggplot2.html#topic+element">ggplot2::margin()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_mark_rect_+3A_label.width">label.width</code></td>
<td>
<p>A fixed width for the label. Set to <code>NULL</code> to let the text
or <code>label.minwidth</code> decide.</p>
</td></tr>
<tr><td><code id="geom_mark_rect_+3A_label.minwidth">label.minwidth</code></td>
<td>
<p>The minimum width to provide for the description. If
the size of the label exceeds this, the description is allowed to fill as
much as the label.</p>
</td></tr>
<tr><td><code id="geom_mark_rect_+3A_label.hjust">label.hjust</code></td>
<td>
<p>The horizontal justification for the annotation. If it
contains two elements the first will be used for the label and the second for
the description.</p>
</td></tr>
<tr><td><code id="geom_mark_rect_+3A_label.fontsize">label.fontsize</code></td>
<td>
<p>The size of the text for the annotation. If it contains
two elements the first will be used for the label and the second for the
description.</p>
</td></tr>
<tr><td><code id="geom_mark_rect_+3A_label.family">label.family</code></td>
<td>
<p>The font family used for the annotation. If it contains
two elements the first will be used for the label and the second for the
description.</p>
</td></tr>
<tr><td><code id="geom_mark_rect_+3A_label.lineheight">label.lineheight</code></td>
<td>
<p>The height of a line as a multipler of the fontsize.
If it contains two elements the first will be used for the label and the
second for the description.</p>
</td></tr>
<tr><td><code id="geom_mark_rect_+3A_label.fontface">label.fontface</code></td>
<td>
<p>The font face used for the annotation. If it contains
two elements the first will be used for the label and the second for the
description.</p>
</td></tr>
<tr><td><code id="geom_mark_rect_+3A_label.fill">label.fill</code></td>
<td>
<p>The fill colour for the annotation box.</p>
</td></tr>
<tr><td><code id="geom_mark_rect_+3A_label.colour">label.colour</code></td>
<td>
<p>The text colour for the annotation. If it contains
two elements the first will be used for the label and the second for the
description.</p>
</td></tr>
<tr><td><code id="geom_mark_rect_+3A_label.buffer">label.buffer</code></td>
<td>
<p>The size of the region around the mark where labels
cannot be placed.</p>
</td></tr>
<tr><td><code id="geom_mark_rect_+3A_con.colour">con.colour</code></td>
<td>
<p>The colour for the line connecting the annotation to the
mark.</p>
</td></tr>
<tr><td><code id="geom_mark_rect_+3A_con.size">con.size</code></td>
<td>
<p>The width of the connector.</p>
</td></tr>
<tr><td><code id="geom_mark_rect_+3A_con.type">con.type</code></td>
<td>
<p>The type of the connector. Either <code>"elbow"</code>, <code>"straight"</code>, or
<code>"none"</code>.</p>
</td></tr>
<tr><td><code id="geom_mark_rect_+3A_con.linetype">con.linetype</code></td>
<td>
<p>The linetype of the connector.</p>
</td></tr>
<tr><td><code id="geom_mark_rect_+3A_con.border">con.border</code></td>
<td>
<p>The bordertype of the connector. Either <code>"one"</code> (to draw a
line on the horizontal side closest to the mark), <code>"all"</code> (to draw a border
on all sides), or <code>"none"</code> (not going to explain that one).</p>
</td></tr>
<tr><td><code id="geom_mark_rect_+3A_con.cap">con.cap</code></td>
<td>
<p>The distance before the mark that the line should stop at.</p>
</td></tr>
<tr><td><code id="geom_mark_rect_+3A_con.arrow">con.arrow</code></td>
<td>
<p>An arrow specification for the connection using
<code><a href="grid.html#topic+arrow">grid::arrow()</a></code> for the end pointing towards the mark.</p>
</td></tr>
<tr><td><code id="geom_mark_rect_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_mark_rect_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_mark_rect_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_mark_rect_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_mark_rect</code> understands the following aesthetics (required aesthetics are
in bold):
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li><p> x0 <em>(used to anchor the label)</em>
</p>
</li>
<li><p> y0 <em>(used to anchor the label)</em>
</p>
</li>
<li><p> filter
</p>
</li>
<li><p> label
</p>
</li>
<li><p> description
</p>
</li>
<li><p> color
</p>
</li>
<li><p> fill
</p>
</li>
<li><p> group
</p>
</li>
<li><p> size
</p>
</li>
<li><p> linetype
</p>
</li>
<li><p> alpha
</p>
</li></ul>



<h3>Annotation</h3>

<p>All <code style="white-space: pre;">&#8288;geom_mark_*&#8288;</code> allow you to put descriptive textboxes connected to the
mark on the plot, using the <code>label</code> and <code>description</code> aesthetics. The
textboxes are automatically placed close to the mark, but without obscuring
any of the datapoints in the layer. The placement is dynamic so if you resize
the plot you'll see that the annotation might move around as areas become big
enough or too small to fit the annotation. If there's not enough space for
the annotation without overlapping data it will not get drawn. In these cases
try resizing the plot, change the size of the annotation, or decrease the
buffer region around the marks.
</p>


<h3>Filtering</h3>

<p>Often marks are used to draw attention to, or annotate specific features of
the plot and it is thus not desirable to have marks around everything. While
it is possible to simply pre-filter the data used for the mark layer, the
<code style="white-space: pre;">&#8288;geom_mark_*&#8288;</code> geoms also comes with a dedicated <code>filter</code> aesthetic that, if
set, will remove all rows where it evalutates to <code>FALSE</code>. There are
multiple benefits of using this instead of prefiltering. First, you don't
have to change your data source, making your code more adaptable for
exploration. Second, the data removed by the filter aesthetic is remembered
by the geom, and any annotation will take care not to overlap with the
removed data.
</p>


<h3>See Also</h3>

<p>Other mark geoms: 
<code><a href="#topic+geom_mark_circle">geom_mark_circle</a>()</code>,
<code><a href="#topic+geom_mark_ellipse">geom_mark_ellipse</a>()</code>,
<code><a href="#topic+geom_mark_hull">geom_mark_hull</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ggplot(iris, aes(Petal.Length, Petal.Width)) +
  geom_mark_rect(aes(fill = Species, filter = Species != 'versicolor')) +
  geom_point()

# Add annotation
ggplot(iris, aes(Petal.Length, Petal.Width)) +
  geom_mark_rect(aes(fill = Species, label = Species)) +
  geom_point()

# Long descriptions are automatically wrapped to fit into the width
iris$desc &lt;- c(
  'A super Iris - and it knows it',
  'Pretty mediocre Iris, but give it a couple of years and it might surprise you',
  "You'll never guess what this Iris does every Sunday"
)[iris$Species]

ggplot(iris, aes(Petal.Length, Petal.Width)) +
  geom_mark_rect(aes(fill = Species, label = Species, description = desc,
                     filter = Species == 'setosa')) +
  geom_point()

# Change the buffer size to move labels farther away (or closer) from the
# marks
ggplot(iris, aes(Petal.Length, Petal.Width)) +
  geom_mark_rect(aes(fill = Species, label = Species),
                 label.buffer = unit(30, 'mm')) +
  geom_point()

# The connector is capped a bit before it reaches the mark, but this can be
# controlled
ggplot(iris, aes(Petal.Length, Petal.Width)) +
  geom_mark_rect(aes(fill = Species, label = Species),
                 con.cap = 0) +
  geom_point()
</code></pre>

<hr>
<h2 id='geom_parallel_sets'>Create Parallel Sets diagrams</h2><span id='topic+geom_parallel_sets'></span><span id='topic+stat_parallel_sets'></span><span id='topic+stat_parallel_sets_axes'></span><span id='topic+geom_parallel_sets_axes'></span><span id='topic+geom_parallel_sets_labels'></span>

<h3>Description</h3>

<p>A parallel sets diagram is a type of visualisation showing the interaction
between multiple categorical variables. If the variables has an intrinsic
order the representation can be thought of as a Sankey Diagram. If each
variable is a point in time it will resemble an alluvial diagram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_parallel_sets(
  mapping = NULL,
  data = NULL,
  geom = "shape",
  position = "identity",
  n = 100,
  strength = 0.5,
  sep = 0.05,
  axis.width = 0,
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)

geom_parallel_sets(
  mapping = NULL,
  data = NULL,
  stat = "parallel_sets",
  position = "identity",
  n = 100,
  na.rm = FALSE,
  orientation = NA,
  sep = 0.05,
  strength = 0.5,
  axis.width = 0,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)

stat_parallel_sets_axes(
  mapping = NULL,
  data = NULL,
  geom = "parallel_sets_axes",
  position = "identity",
  sep = 0.05,
  axis.width = 0,
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)

geom_parallel_sets_axes(
  mapping = NULL,
  data = NULL,
  stat = "parallel_sets_axes",
  position = "identity",
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)

geom_parallel_sets_labels(
  mapping = NULL,
  data = NULL,
  stat = "parallel_sets_axes",
  angle = -90,
  nudge_x = 0,
  nudge_y = 0,
  position = "identity",
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_parallel_sets_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_parallel_sets_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_parallel_sets_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data, either as a
<code>ggproto</code> <code>Geom</code> subclass or as a string naming the geom stripped of the
<code>geom_</code> prefix (e.g. <code>"point"</code> rather than <code>"geom_point"</code>)</p>
</td></tr>
<tr><td><code id="geom_parallel_sets_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_parallel_sets_+3A_n">n</code></td>
<td>
<p>The number of points to create for each of the bounding diagonals</p>
</td></tr>
<tr><td><code id="geom_parallel_sets_+3A_strength">strength</code></td>
<td>
<p>The proportion to move the control point along the x-axis
towards the other end of the bezier curve</p>
</td></tr>
<tr><td><code id="geom_parallel_sets_+3A_sep">sep</code></td>
<td>
<p>The proportional separation between categories within a variable</p>
</td></tr>
<tr><td><code id="geom_parallel_sets_+3A_axis.width">axis.width</code></td>
<td>
<p>The width of the area around each variable axis</p>
</td></tr>
<tr><td><code id="geom_parallel_sets_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_parallel_sets_+3A_orientation">orientation</code></td>
<td>
<p>The orientation of the layer. The default (<code>NA</code>)
automatically determines the orientation from the aesthetic mapping. In the
rare event that this fails it can be given explicitly by setting <code>orientation</code>
to either <code>"x"</code> or <code>"y"</code>. See the <em>Orientation</em> section for more detail.</p>
</td></tr>
<tr><td><code id="geom_parallel_sets_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_parallel_sets_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_parallel_sets_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_parallel_sets_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_parallel_sets_+3A_angle">angle</code></td>
<td>
<p>The angle of the axis label text</p>
</td></tr>
<tr><td><code id="geom_parallel_sets_+3A_nudge_x">nudge_x</code>, <code id="geom_parallel_sets_+3A_nudge_y">nudge_y</code></td>
<td>
<p>Horizontal and vertical adjustment to nudge labels by.
Useful for offsetting text from the category segments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In a parallel sets visualization each categorical variable will be assigned
a position on the x-axis. The size of the intersection of categories from
neighboring variables are then shown as thick diagonals, scaled by the sum of
elements shared between the two categories. The natural data representation
for such as plot is to have each categorical variable in a separate column
and then have a column giving the amount/magnitude of the combination of
levels in the row. This representation is unfortunately not fitting for the
<code>ggplot2</code> API which needs every position encoding in the same column. To make
it easier to work with <code>ggforce</code> provides a helper <code><a href="#topic+gather_set_data">gather_set_data()</a></code>, which
takes care of the transformation.
</p>


<h3>Aesthetics</h3>

<p>geom_parallel_sets understand the following aesthetics
(required aesthetics are in bold):
</p>

<ul>
<li> <p><strong>x|y</strong>
</p>
</li>
<li> <p><strong>id</strong>
</p>
</li>
<li> <p><strong>split</strong>
</p>
</li>
<li> <p><strong>value</strong>
</p>
</li>
<li><p> color
</p>
</li>
<li><p> fill
</p>
</li>
<li><p> size
</p>
</li>
<li><p> linetype
</p>
</li>
<li><p> alpha
</p>
</li>
<li><p> lineend
</p>
</li></ul>



<h3>Orientation</h3>

<p>This geom treats each axis differently and, thus, can thus have two orientations. Often the orientation is easy to deduce from a combination of the given mappings and the types of positional scales in use. Thus, ggplot2 will by default try to guess which orientation the layer should have. Under rare circumstances, the orientation is ambiguous and guessing may fail. In that case the orientation can be specified directly using the <code>orientation</code> parameter, which can be either <code>"x"</code> or <code>"y"</code>. The value gives the axis that the geom should run along, <code>"x"</code> being the default orientation you would expect for the geom.
</p>


<h3>Author(s)</h3>

<p>Thomas Lin Pedersen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- reshape2::melt(Titanic)
data &lt;- gather_set_data(data, 1:4)

ggplot(data, aes(x, id = id, split = y, value = value)) +
  geom_parallel_sets(aes(fill = Sex), alpha = 0.3, axis.width = 0.1) +
  geom_parallel_sets_axes(axis.width = 0.1) +
  geom_parallel_sets_labels(colour = 'white')

# Use nudge_x to offset and hjust = 0 to left-justify label
ggplot(data, aes(x, id = id, split = y, value = value)) +
  geom_parallel_sets(aes(fill = Sex), alpha = 0.3, axis.width = 0.1) +
  geom_parallel_sets_axes(axis.width = 0.1) +
  geom_parallel_sets_labels(colour = 'red', angle = 0, nudge_x = 0.1, hjust = 0)
</code></pre>

<hr>
<h2 id='geom_regon'>Draw regular polygons by specifying number of sides</h2><span id='topic+geom_regon'></span><span id='topic+stat_regon'></span>

<h3>Description</h3>

<p>This geom makes it easy to construct regular polygons (polygons where all
sides and angles are equal) by specifying the number of sides, position, and
size. The polygons are always rotated so that they &quot;rest&quot; on a flat side, but
this can be changed with the angle aesthetic. The size is based on the radius
of their circumcircle and is thus not proportional to their area.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_regon(
  mapping = NULL,
  data = NULL,
  geom = "shape",
  position = "identity",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)

geom_regon(
  mapping = NULL,
  data = NULL,
  stat = "regon",
  position = "identity",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_regon_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_regon_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_regon_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data, either as a
<code>ggproto</code> <code>Geom</code> subclass or as a string naming the geom stripped of the
<code>geom_</code> prefix (e.g. <code>"point"</code> rather than <code>"geom_point"</code>)</p>
</td></tr>
<tr><td><code id="geom_regon_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_regon_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_regon_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_regon_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_regon_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_regon_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p>geom_regon understand the following aesthetics (required aesthetics are in
bold):
</p>

<ul>
<li> <p><strong>x0</strong> x coordinate
</p>
</li>
<li> <p><strong>y0</strong> y coordinate
</p>
</li>
<li> <p><strong>sides</strong> the number of sides for regon
</p>
</li>
<li> <p><strong>r</strong> the ratio of regon with respect to plot
</p>
</li>
<li> <p><strong>angle</strong> regon rotation angle (unit is radian)
</p>
</li>
<li><p> color
</p>
</li>
<li><p> fill
</p>
</li>
<li><p> size
</p>
</li>
<li><p> linetype
</p>
</li>
<li><p> alpha
</p>
</li>
<li><p> lineend
</p>
</li></ul>



<h3>Computed variables</h3>


<dl>
<dt>x, y</dt><dd><p>The coordinates for the corners of the polygon</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>ggplot() +
  geom_regon(aes(x0 = runif(8), y0 = runif(8), sides = sample(3:10, 8),
                 angle = 0, r = runif(8) / 10)) +
  coord_fixed()

# The polygons are drawn with geom_shape, so can be manipulated as such
ggplot() +
  geom_regon(aes(x0 = runif(8), y0 = runif(8), sides = sample(3:10, 8),
                 angle = 0, r = runif(8) / 10),
             expand = unit(1, 'cm'), radius = unit(1, 'cm')) +
  coord_fixed()
</code></pre>

<hr>
<h2 id='geom_shape'>Draw polygons with expansion/contraction and/or rounded corners</h2><span id='topic+geom_shape'></span>

<h3>Description</h3>

<p>This geom is a cousin of <code><a href="ggplot2.html#topic+geom_polygon">ggplot2::geom_polygon()</a></code> with the added
possibility of expanding or contracting the polygon by an absolute amount
(e.g. 1 cm). Furthermore, it is possible to round the corners of the polygon,
again by an absolute amount. The resulting geom reacts to resizing of the
plot, so the expansion/contraction and corner radius will not get distorted.
If no expansion/contraction or corner radius is specified, the geom falls
back to <code>geom_polygon</code> so there is no performance penality in using this
instead of <code>geom_polygon</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_shape(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  expand = 0,
  radius = 0,
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_shape_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_shape_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_shape_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_shape_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_shape_+3A_expand">expand</code></td>
<td>
<p>A numeric or unit vector of length one, specifying the
expansion amount. Negative values will result in contraction instead. If the
value is given as a numeric it will be understood as a proportion of the
plot area width.</p>
</td></tr>
<tr><td><code id="geom_shape_+3A_radius">radius</code></td>
<td>
<p>As <code>expand</code> but specifying the corner radius.</p>
</td></tr>
<tr><td><code id="geom_shape_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_shape_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_shape_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_shape_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p>geom_shape understand the following aesthetics (required aesthetics are in
bold):
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li><p> color
</p>
</li>
<li><p> fill
</p>
</li>
<li><p> group
</p>
</li>
<li><p> size
</p>
</li>
<li><p> linetype
</p>
</li>
<li><p> alpha
</p>
</li></ul>



<h3>Note</h3>

<p>Some settings can result in the dissappearance of polygons,
specifically when contracting or rounding corners with a relatively large
amount. Also note that x and y scale limits does not take expansion into
account and the resulting polygon might thus not fit into the plot.
</p>


<h3>Author(s)</h3>

<p>Thomas Lin Pedersen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>shape &lt;- data.frame(
  x = c(0.5, 1, 0.75, 0.25, 0),
  y = c(0, 0.5, 1, 0.75, 0.25)
)
# Expand and round
ggplot(shape, aes(x = x, y = y)) +
  geom_shape(expand = unit(1, 'cm'), radius = unit(0.5, 'cm')) +
  geom_polygon(fill = 'red')

# Contract
ggplot(shape, aes(x = x, y = y)) +
  geom_polygon(fill = 'red') +
  geom_shape(expand = unit(-1, 'cm'))

# Only round corners
ggplot(shape, aes(x = x, y = y)) +
  geom_polygon(fill = 'red') +
  geom_shape(radius = unit(1, 'cm'))
</code></pre>

<hr>
<h2 id='geom_sina'>Sina plot</h2><span id='topic+geom_sina'></span><span id='topic+stat_sina'></span>

<h3>Description</h3>

<p>The sina plot is a data visualization chart suitable for plotting any single
variable in a multiclass dataset. It is an enhanced jitter strip chart,
where the width of the jitter is controlled by the density distribution of
the data within each class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_sina(
  mapping = NULL,
  data = NULL,
  geom = "point",
  position = "dodge",
  scale = "area",
  method = "density",
  bw = "nrd0",
  kernel = "gaussian",
  maxwidth = NULL,
  adjust = 1,
  bin_limit = 1,
  binwidth = NULL,
  bins = NULL,
  seed = NA,
  jitter_y = TRUE,
  ...,
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_sina(
  mapping = NULL,
  data = NULL,
  stat = "sina",
  position = "dodge",
  ...,
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_sina_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_sina_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_sina_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data, either as a
<code>ggproto</code> <code>Geom</code> subclass or as a string naming the geom stripped of the
<code>geom_</code> prefix (e.g. <code>"point"</code> rather than <code>"geom_point"</code>)</p>
</td></tr>
<tr><td><code id="geom_sina_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_sina_+3A_scale">scale</code></td>
<td>
<p>How should each sina be scaled. Corresponds to the <code>scale</code>
parameter in <code><a href="ggplot2.html#topic+geom_violin">ggplot2::geom_violin()</a></code>? Available are:
</p>

<ul>
<li> <p><code>'area'</code> for scaling by the largest density/bin among the different sinas
</p>
</li>
<li> <p><code>'count'</code> as above, but in addition scales by the maximum number of points
in the different sinas.
</p>
</li>
<li> <p><code>'width'</code> Only scale according to the <code>maxwidth</code> parameter
</p>
</li></ul>

<p>For backwards compatibility it can also be a logical with <code>TRUE</code> meaning
<code>area</code> and <code>FALSE</code> meaning <code>width</code></p>
</td></tr>
<tr><td><code id="geom_sina_+3A_method">method</code></td>
<td>
<p>Choose the method to spread the samples within the same
bin along the x-axis. Available methods: &quot;density&quot;, &quot;counts&quot; (can be
abbreviated, e.g. &quot;d&quot;). See <code>Details</code>.</p>
</td></tr>
<tr><td><code id="geom_sina_+3A_bw">bw</code></td>
<td>
<p>The smoothing bandwidth to be used.
If numeric, the standard deviation of the smoothing kernel.
If character, a rule to choose the bandwidth, as listed in
<code><a href="stats.html#topic+bandwidth">stats::bw.nrd()</a></code>. Note that automatic calculation of the bandwidth does
not take weights into account.</p>
</td></tr>
<tr><td><code id="geom_sina_+3A_kernel">kernel</code></td>
<td>
<p>Kernel. See list of available kernels in <code><a href="stats.html#topic+density">density()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_sina_+3A_maxwidth">maxwidth</code></td>
<td>
<p>Control the maximum width the points can spread into. Values
between 0 and 1.</p>
</td></tr>
<tr><td><code id="geom_sina_+3A_adjust">adjust</code></td>
<td>
<p>A multiplicate bandwidth adjustment. This makes it possible
to adjust the bandwidth while still using the a bandwidth estimator.
For example, <code>adjust = 1/2</code> means use half of the default bandwidth.</p>
</td></tr>
<tr><td><code id="geom_sina_+3A_bin_limit">bin_limit</code></td>
<td>
<p>If the samples within the same y-axis bin are more
than <code>bin_limit</code>, the samples's X coordinates will be adjusted.</p>
</td></tr>
<tr><td><code id="geom_sina_+3A_binwidth">binwidth</code></td>
<td>
<p>The width of the bins. The default is to use <code>bins</code>
bins that cover the range of the data. You should always override
this value, exploring multiple widths to find the best to illustrate the
stories in your data.</p>
</td></tr>
<tr><td><code id="geom_sina_+3A_bins">bins</code></td>
<td>
<p>Number of bins. Overridden by binwidth. Defaults to 50.</p>
</td></tr>
<tr><td><code id="geom_sina_+3A_seed">seed</code></td>
<td>
<p>A seed to set for the jitter to ensure a reproducible plot</p>
</td></tr>
<tr><td><code id="geom_sina_+3A_jitter_y">jitter_y</code></td>
<td>
<p>If y is integerish banding can occur and the default is to
jitter the values slightly to make them better distributed. Setting
<code>jitter_y = FALSE</code> turns off this behaviour</p>
</td></tr>
<tr><td><code id="geom_sina_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_sina_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_sina_+3A_orientation">orientation</code></td>
<td>
<p>The orientation of the layer. The default (<code>NA</code>)
automatically determines the orientation from the aesthetic mapping. In the
rare event that this fails it can be given explicitly by setting <code>orientation</code>
to either <code>"x"</code> or <code>"y"</code>. See the <em>Orientation</em> section for more detail.</p>
</td></tr>
<tr><td><code id="geom_sina_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_sina_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_sina_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are two available ways to define the x-axis borders for the
samples to spread within:
</p>

<ul>
<li><p><code>method == "density"</code>
</p>
<p>A density kernel is estimated along the y-axis for every sample group, and
the samples are spread within that curve. In effect this means that points
will be positioned randomly within a violin plot with the same parameters.

</p>
</li>
<li><p><code>method == "counts"</code>:
</p>
<p>The borders are defined by the number of samples that occupy the same bin.
</p>

</li></ul>



<h3>Aesthetics</h3>

<p>geom_sina understand the following aesthetics (required aesthetics are in
bold):
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li><p> color
</p>
</li>
<li><p> group
</p>
</li>
<li><p> size
</p>
</li>
<li><p> alpha
</p>
</li></ul>



<h3>Computed variables</h3>


<dl>
<dt>density</dt><dd><p>The density or sample counts per bin for each point</p>
</dd>
<dt>scaled</dt><dd><p><code>density</code> scaled by the maximum density in each group</p>
</dd>
<dt>n</dt><dd><p>The number of points in the group the point belong to</p>
</dd>
</dl>



<h3>Orientation</h3>

<p>This geom treats each axis differently and, thus, can thus have two orientations. Often the orientation is easy to deduce from a combination of the given mappings and the types of positional scales in use. Thus, ggplot2 will by default try to guess which orientation the layer should have. Under rare circumstances, the orientation is ambiguous and guessing may fail. In that case the orientation can be specified directly using the <code>orientation</code> parameter, which can be either <code>"x"</code> or <code>"y"</code>. The value gives the axis that the geom should run along, <code>"x"</code> being the default orientation you would expect for the geom.
</p>


<h3>Author(s)</h3>

<p>Nikos Sidiropoulos, Claus Wilke, and Thomas Lin Pedersen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ggplot(midwest, aes(state, area)) + geom_point()

# Boxplot and Violin plots convey information on the distribution but not the
# number of samples, while Jitter does the opposite.
ggplot(midwest, aes(state, area)) +
  geom_violin()

ggplot(midwest, aes(state, area)) +
  geom_jitter()

# Sina does both!
ggplot(midwest, aes(state, area)) +
  geom_violin() +
  geom_sina()

p &lt;- ggplot(midwest, aes(state, popdensity)) +
  scale_y_log10()

p + geom_sina()

# Colour the points based on the data set's columns
p + geom_sina(aes(colour = inmetro))

# Or any other way
cols &lt;- midwest$popdensity &gt; 10000
p + geom_sina(colour = cols + 1L)

# Sina plots with continuous x:
ggplot(midwest, aes(cut_width(area, 0.02), popdensity)) +
  geom_sina() +
  scale_y_log10()


### Sample gaussian distributions
# Unimodal
a &lt;- rnorm(500, 6, 1)
b &lt;- rnorm(400, 5, 1.5)

# Bimodal
c &lt;- c(rnorm(200, 3, .7), rnorm(50, 7, 0.4))

# Trimodal
d &lt;- c(rnorm(200, 2, 0.7), rnorm(300, 5.5, 0.4), rnorm(100, 8, 0.4))

df &lt;- data.frame(
  'Distribution' = c(
    rep('Unimodal 1', length(a)),
    rep('Unimodal 2', length(b)),
    rep('Bimodal', length(c)),
    rep('Trimodal', length(d))
  ),
  'Value' = c(a, b, c, d)
)

# Reorder levels
df$Distribution &lt;- factor(
  df$Distribution,
  levels(df$Distribution)[c(3, 4, 1, 2)]
)

p &lt;- ggplot(df, aes(Distribution, Value))
p + geom_boxplot()
p + geom_violin() +
  geom_sina()

# By default, Sina plot scales the width of the class according to the width
# of the class with the highest density. Turn group-wise scaling off with:
p +
  geom_violin() +
  geom_sina(scale = FALSE)
</code></pre>

<hr>
<h2 id='geom_spiro'>Draw spirograms based on the radii of the different &quot;wheels&quot; involved</h2><span id='topic+geom_spiro'></span><span id='topic+stat_spiro'></span>

<h3>Description</h3>

<p>This, rather pointless, geom allows you to draw spirograms, as known from the
popular drawing toy where lines were traced by inserting a pencil into a hole
in a small gear that would then trace around inside another gear. The
potential practicality of this geom is slim and it excists mainly for fun and
art.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_spiro(
  mapping = NULL,
  data = NULL,
  geom = "path",
  position = "identity",
  na.rm = FALSE,
  n = 500,
  revolutions = NULL,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)

geom_spiro(
  mapping = NULL,
  data = NULL,
  stat = "spiro",
  position = "identity",
  arrow = NULL,
  n = 500,
  lineend = "butt",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_spiro_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_spiro_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_spiro_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data, either as a
<code>ggproto</code> <code>Geom</code> subclass or as a string naming the geom stripped of the
<code>geom_</code> prefix (e.g. <code>"point"</code> rather than <code>"geom_point"</code>)</p>
</td></tr>
<tr><td><code id="geom_spiro_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_spiro_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_spiro_+3A_n">n</code></td>
<td>
<p>The number of points that should be used to draw a fully closed
spirogram. If <code>revolutions &lt; 1</code> the actual number of points will be less
than this.</p>
</td></tr>
<tr><td><code id="geom_spiro_+3A_revolutions">revolutions</code></td>
<td>
<p>The number of times the inner gear should revolve around
inside the outer gear. If <code>NULL</code> the number of revolutions to reach the
starting position is calculated and used.</p>
</td></tr>
<tr><td><code id="geom_spiro_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_spiro_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_spiro_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_spiro_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_spiro_+3A_arrow">arrow</code></td>
<td>
<p>Arrow specification, as created by <code><a href="grid.html#topic+arrow">grid::arrow()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_spiro_+3A_lineend">lineend</code></td>
<td>
<p>Line end style (round, butt, square).</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p>stat_spiro and geom_spiro understand the following aesthetics (required
aesthetics are in bold):
</p>

<ul>
<li> <p><strong>R</strong>
</p>
</li>
<li> <p><strong>r</strong>
</p>
</li>
<li> <p><strong>d</strong>
</p>
</li>
<li><p> x0
</p>
</li>
<li><p> y0
</p>
</li>
<li><p> outer
</p>
</li>
<li><p> color
</p>
</li>
<li><p> size
</p>
</li>
<li><p> linetype
</p>
</li>
<li><p> alpha
</p>
</li></ul>



<h3>Computed variables</h3>


<dl>
<dt>x, y</dt><dd><p>The coordinates for the path describing the spirogram</p>
</dd>
<dt>index</dt><dd><p>The progression along the spirogram mapped between 0 and 1</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># Basic usage
ggplot() +
  geom_spiro(aes(R = 10, r = 3, d = 5))

# Only draw a portion
ggplot() +
  geom_spiro(aes(R = 10, r = 3, d = 5), revolutions = 1.2)

# Let the inner gear circle the outside of the outer gear
ggplot() +
  geom_spiro(aes(R = 10, r = 3, d = 5, outer = TRUE))
</code></pre>

<hr>
<h2 id='geom_voronoi'>Voronoi tesselation and delaunay triangulation</h2><span id='topic+geom_voronoi'></span><span id='topic+geom_delaunay'></span><span id='topic+geom_voronoi_tile'></span><span id='topic+geom_voronoi_segment'></span><span id='topic+geom_delaunay_tile'></span><span id='topic+geom_delaunay_segment'></span><span id='topic+geom_delaunay_segment2'></span><span id='topic+stat_delvor_summary'></span>

<h3>Description</h3>

<p>This set of geoms and stats allows you to display voronoi tesselation and
delaunay triangulation, both as polygons and as line segments. Furthermore
it lets you augment your point data with related summary statistics. The
computations are based on the <code><a href="deldir.html#topic+deldir">deldir::deldir()</a></code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_voronoi_tile(
  mapping = NULL,
  data = NULL,
  stat = "voronoi_tile",
  position = "identity",
  na.rm = FALSE,
  bound = NULL,
  eps = 1e-09,
  max.radius = NULL,
  normalize = FALSE,
  asp.ratio = 1,
  expand = 0,
  radius = 0,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)

geom_voronoi_segment(
  mapping = NULL,
  data = NULL,
  stat = "voronoi_segment",
  position = "identity",
  na.rm = FALSE,
  bound = NULL,
  eps = 1e-09,
  normalize = FALSE,
  asp.ratio = 1,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)

geom_delaunay_tile(
  mapping = NULL,
  data = NULL,
  stat = "delaunay_tile",
  position = "identity",
  na.rm = FALSE,
  bound = NULL,
  eps = 1e-09,
  normalize = FALSE,
  asp.ratio = 1,
  expand = 0,
  radius = 0,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)

geom_delaunay_segment(
  mapping = NULL,
  data = NULL,
  stat = "delaunay_segment",
  position = "identity",
  na.rm = FALSE,
  bound = NULL,
  eps = 1e-09,
  normalize = FALSE,
  asp.ratio = 1,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)

geom_delaunay_segment2(
  mapping = NULL,
  data = NULL,
  stat = "delaunay_segment2",
  position = "identity",
  na.rm = FALSE,
  bound = NULL,
  eps = 1e-09,
  normalize = FALSE,
  asp.ratio = 1,
  n = 100,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)

stat_delvor_summary(
  mapping = NULL,
  data = NULL,
  geom = "point",
  position = "identity",
  na.rm = FALSE,
  bound = NULL,
  eps = 1e-09,
  normalize = FALSE,
  asp.ratio = 1,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_voronoi_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_voronoi_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_voronoi_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_voronoi_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_voronoi_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_voronoi_+3A_bound">bound</code></td>
<td>
<p>The bounding rectangle for the tesselation or a custom polygon
to clip the tesselation to. Defaults to <code>NULL</code> which creates a rectangle
expanded 10\
vector giving the bounds in the following order: xmin, xmax, ymin, ymax. If
supplied as a polygon it should either be a 2-column matrix or a data.frame
containing an <code>x</code> and <code>y</code> column.</p>
</td></tr>
<tr><td><code id="geom_voronoi_+3A_eps">eps</code></td>
<td>
<p>A value of epsilon used in testing whether a quantity is zero,
mainly in the context of whether points are collinear. If anomalous errors
arise, it is possible that these may averted by adjusting the value of eps
upward or downward.</p>
</td></tr>
<tr><td><code id="geom_voronoi_+3A_max.radius">max.radius</code></td>
<td>
<p>The maximum distance a tile can extend from the point of
origin. Will in effect clip each tile to a circle centered at the point with
the given radius. If <code>normalize = TRUE</code> the radius will be given relative to
the normalized values</p>
</td></tr>
<tr><td><code id="geom_voronoi_+3A_normalize">normalize</code></td>
<td>
<p>Should coordinates be normalized prior to calculations. If
<code>x</code> and <code>y</code> are in wildly different ranges it can lead to
tesselation and triangulation that seems off when plotted without
<code><a href="ggplot2.html#topic+coord_fixed">ggplot2::coord_fixed()</a></code>. Normalization of coordinates solves this.
The coordinates are transformed back after calculations.</p>
</td></tr>
<tr><td><code id="geom_voronoi_+3A_asp.ratio">asp.ratio</code></td>
<td>
<p>If <code>normalize = TRUE</code> the x values will be multiplied by this
amount after normalization.</p>
</td></tr>
<tr><td><code id="geom_voronoi_+3A_expand">expand</code></td>
<td>
<p>A numeric or unit vector of length one, specifying the
expansion amount. Negative values will result in contraction instead. If the
value is given as a numeric it will be understood as a proportion of the
plot area width.</p>
</td></tr>
<tr><td><code id="geom_voronoi_+3A_radius">radius</code></td>
<td>
<p>As <code>expand</code> but specifying the corner radius.</p>
</td></tr>
<tr><td><code id="geom_voronoi_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_voronoi_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_voronoi_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_voronoi_+3A_n">n</code></td>
<td>
<p>The number of points to create for each segment</p>
</td></tr>
<tr><td><code id="geom_voronoi_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data, either as a
<code>ggproto</code> <code>Geom</code> subclass or as a string naming the geom stripped of the
<code>geom_</code> prefix (e.g. <code>"point"</code> rather than <code>"geom_point"</code>)</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p>geom_voronoi_tile and geom_delaunay_tile understand the following aesthetics
(required aesthetics are in bold):
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li><p> alpha
</p>
</li>
<li><p> color
</p>
</li>
<li><p> fill
</p>
</li>
<li><p> linetype
</p>
</li>
<li><p> size
</p>
</li></ul>

<p>geom_voronoi_segment, geom_delaunay_segment, and geom_delaunay_segment2
understand the following aesthetics (required aesthetics are in bold):
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li><p> alpha
</p>
</li>
<li><p> color
</p>
</li>
<li><p> linetype
</p>
</li>
<li><p> size
</p>
</li></ul>



<h3>Computed variables</h3>

<p>stat_delvor_summary computes the following variables:
</p>

<dl>
<dt>x, y</dt><dd><p>If <code>switch.centroid = TRUE</code> this will be the coordinates for
the voronoi tile centroid, otherwise it is the original point</p>
</dd>
<dt>xcent, ycent</dt><dd><p>If <code>switch.centroid = FALSE</code> this will be the
coordinates for the voronoi tile centroid, otherwise it will be <code>NULL</code></p>
</dd>
<dt>xorig, yorig</dt><dd><p>If <code>switch.centroid = TRUE</code> this will be the
coordinates for the original point, otherwise it will be <code>NULL</code></p>
</dd>
<dt>ntri</dt><dd><p>Number of triangles emanating from the point</p>
</dd>
<dt>triarea</dt><dd><p>The total area of triangles emanating from the point divided
by 3</p>
</dd>
<dt>triprop</dt><dd><p><code>triarea</code> divided by the sum of the area of all
triangles</p>
</dd>
<dt>nsides</dt><dd><p>Number of sides on the voronoi tile associated with the point</p>
</dd>
<dt>nedges</dt><dd><p>Number of sides of the associated voronoi tile that is part of
the bounding box</p>
</dd>
<dt>vorarea</dt><dd><p>The area of the voronoi tile associated with the point</p>
</dd>
<dt>vorprop</dt><dd><p><code>vorarea</code> divided by the sum of all voronoi tiles</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># Voronoi
# You usually wants all points to take part in the same tesselation so set
# the group aesthetic to a constant (-1L is just a convention)
ggplot(iris, aes(Sepal.Length, Sepal.Width, group = -1L)) +
  geom_voronoi_tile(aes(fill = Species)) +
  geom_voronoi_segment() +
  geom_text(aes(label = after_stat(nsides), size = after_stat(vorarea)),
    stat = 'delvor_summary', switch.centroid = TRUE
  )

# Difference of normalize = TRUE (segment layer is calculated without
# normalisation)
ggplot(iris, aes(Sepal.Length, Sepal.Width, group = -1L)) +
  geom_voronoi_tile(aes(fill = Species), normalize = TRUE) +
  geom_voronoi_segment()

# Set a max radius
ggplot(iris, aes(Sepal.Length, Sepal.Width, group = -1L)) +
  geom_voronoi_tile(aes(fill = Species), colour = 'black', max.radius = 0.25)

# Set custom bounding polygon
triangle &lt;- cbind(c(3, 9, 6), c(1, 1, 6))
ggplot(iris, aes(Sepal.Length, Sepal.Width, group = -1L)) +
  geom_voronoi_tile(aes(fill = Species), colour = 'black', bound = triangle)

# Use geom_shape functionality to round corners etc
ggplot(iris, aes(Sepal.Length, Sepal.Width, group = -1L)) +
  geom_voronoi_tile(aes(fill = Species), colour = 'black',
                    expand = unit(-.5, 'mm'), radius = unit(2, 'mm'))

# Delaunay triangles
ggplot(iris, aes(Sepal.Length, Sepal.Width)) +
  geom_delaunay_tile(alpha = 0.3, colour = 'black')

# Use geom_delauney_segment2 to interpolate aestetics between end points
ggplot(iris, aes(Sepal.Length, Sepal.Width)) +
  geom_delaunay_segment2(aes(colour = Species, group = -1), size = 2,
                         lineend = 'round')
</code></pre>

<hr>
<h2 id='GeomShape'>ggforce extensions to ggplot2</h2><span id='topic+GeomShape'></span><span id='topic+StatArcBar'></span><span id='topic+StatPie'></span><span id='topic+GeomArcBar'></span><span id='topic+StatArc'></span><span id='topic+GeomArc'></span><span id='topic+StatArc2'></span><span id='topic+StatArc0'></span><span id='topic+GeomArc0'></span><span id='topic+StatAutodensity'></span><span id='topic+GeomAutoarea'></span><span id='topic+StatAutobin'></span><span id='topic+GeomAutorect'></span><span id='topic+StatBezier'></span><span id='topic+StatBezier2'></span><span id='topic+StatBezier0'></span><span id='topic+GeomBezier0'></span><span id='topic+StatBspline'></span><span id='topic+StatBspline2'></span><span id='topic+GeomBspline0'></span><span id='topic+GeomBsplineClosed0'></span><span id='topic+StatCircle'></span><span id='topic+GeomCircle'></span><span id='topic+StatDiagonal'></span><span id='topic+StatDiagonal2'></span><span id='topic+StatDiagonal0'></span><span id='topic+StatDiagonalWide'></span><span id='topic+StatEllip'></span><span id='topic+StatErr'></span><span id='topic+FacetGridPaginate'></span><span id='topic+FacetMatrix'></span><span id='topic+FacetRow'></span><span id='topic+FacetCol'></span><span id='topic+FacetStereo'></span><span id='topic+FacetWrapPaginate'></span><span id='topic+FacetZoom'></span><span id='topic+ggforce-extensions'></span><span id='topic+GeomPathInterpolate'></span><span id='topic+StatLink'></span><span id='topic+StatLink2'></span><span id='topic+GeomMarkCircle'></span><span id='topic+GeomMarkEllipse'></span><span id='topic+GeomMarkHull'></span><span id='topic+GeomMarkRect'></span><span id='topic+StatParallelSets'></span><span id='topic+StatParallelSetsAxes'></span><span id='topic+GeomParallelSetsAxes'></span><span id='topic+PositionJitterNormal'></span><span id='topic+PositionAuto'></span><span id='topic+PositionFloatstack'></span><span id='topic+StatRegon'></span><span id='topic+StatSina'></span><span id='topic+StatSpiro'></span><span id='topic+StatVoronoiTile'></span><span id='topic+StatVoronoiSegment'></span><span id='topic+StatDelaunayTile'></span><span id='topic+StatDelaunaySegment'></span><span id='topic+StatDelaunaySegment2'></span><span id='topic+StatDelvorSummary'></span>

<h3>Description</h3>

<p>ggforce makes heavy use of the ggproto class system to extend the
functionality of ggplot2. In general the actual classes should be of little
interest to users as the standard ggplot2 api of using geom_* and stat_*
functions for building up the plot is encouraged.
</p>

<hr>
<h2 id='interpolateDataFrame'>Interpolate layer data</h2><span id='topic+interpolateDataFrame'></span>

<h3>Description</h3>

<p>Interpolate layer data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interpolateDataFrame(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interpolateDataFrame_+3A_data">data</code></td>
<td>
<p>A data.frame with data for a layer</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A similar data.frame with NA values interpolated
</p>

<hr>
<h2 id='label_tex'>A labeller function to parse TeX syntax</h2><span id='topic+label_tex'></span>

<h3>Description</h3>

<p>This function formats the strip labels of facet grids and wraps that contains
TeX expressions. The latex2exp package must be installed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>label_tex(labels, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="label_tex_+3A_labels">labels</code></td>
<td>
<p>Data frame of labels. Usually contains only one
element, but faceting over multiple factors entails multiple
label variables.</p>
</td></tr>
<tr><td><code id="label_tex_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="ggplot2.html#topic+labellers">ggplot2::label_parsed</a></code>
</p>

<dl>
<dt><code>multi_line</code></dt><dd><p>Whether to display the labels of multiple factors
on separate lines.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="ggplot2.html#topic+labeller">ggplot2::labeller</a>, <code><a href="latex2exp.html#topic+TeX">latex2exp::TeX()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># requires latex2exp package be installed
if (requireNamespace("latex2exp", quietly = TRUE)) {
  library(ggplot2)
  d &lt;- data.frame(x = 1, y = 1, facet = "$\\beta$")
  ggplot(d, aes(x, y)) +
    geom_point() +
    facet_wrap(~ facet, labeller = label_tex)
}
</code></pre>

<hr>
<h2 id='linear_trans'>Create a custom linear transformation</h2><span id='topic+linear_trans'></span><span id='topic+rotate'></span><span id='topic+stretch'></span><span id='topic+shear'></span><span id='topic+translate'></span><span id='topic+reflect'></span>

<h3>Description</h3>

<p>This function lets you compose transformations based on a sequence of linear
transformations. If the transformations are parameterised the parameters will
become arguments in the transformation function. The transformations are
one of <code>rotate</code>, <code>shear</code>, <code>stretch</code>, <code>translate</code>, and
<code>reflect</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linear_trans(...)

rotate(angle)

stretch(x, y)

shear(x, y)

translate(x, y)

reflect(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linear_trans_+3A_...">...</code></td>
<td>
<p>A number of transformation functions.</p>
</td></tr>
<tr><td><code id="linear_trans_+3A_angle">angle</code></td>
<td>
<p>An angle in radians</p>
</td></tr>
<tr><td><code id="linear_trans_+3A_x">x</code></td>
<td>
<p>the transformation magnitude in the x-direction</p>
</td></tr>
<tr><td><code id="linear_trans_+3A_y">y</code></td>
<td>
<p>the transformation magnitude in the x-direction</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>linear_trans</code> creates a trans object. The other functions
return a 3x3 transformation matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trans &lt;- linear_trans(rotate(a), shear(1, 0), translate(x1, y1))
square &lt;- data.frame(x = c(0, 0, 1, 1), y = c(0, 1, 1, 0))
square2 &lt;- trans$transform(square$x, square$y, a = pi / 3, x1 = 4, y1 = 8)
square3 &lt;- trans$transform(square$x, square$y, a = pi / 1.5, x1 = 2, y1 = -6)
square &lt;- rbind(square, square2, square3)
square$group &lt;- rep(1:3, each = 4)
ggplot(square, aes(x, y, group = group)) +
  geom_polygon(aes(fill = factor(group)), colour = 'black')
</code></pre>

<hr>
<h2 id='n_pages'>Determine the number of pages in a paginated facet plot</h2><span id='topic+n_pages'></span>

<h3>Description</h3>

<p>This is a simple helper that returns the number of pages it takes to plot all
panels when using <code><a href="#topic+facet_wrap_paginate">facet_wrap_paginate()</a></code> and
<code><a href="#topic+facet_grid_paginate">facet_grid_paginate()</a></code>. It partially builds the plot so depending
on the complexity of your plot it might take some time to calculate...
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_pages(plot)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n_pages_+3A_plot">plot</code></td>
<td>
<p>A ggplot object using either facet_wrap_paginate or
facet_grid_paginate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the plot uses  using either facet_wrap_paginate or
facet_grid_paginate it returns the total number of pages. Otherwise it
returns NULL
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- ggplot(diamonds) +
  geom_point(aes(carat, price), alpha = 0.1) +
  facet_wrap_paginate(~ cut:clarity, ncol = 3, nrow = 3, page = 1)
n_pages(p)
</code></pre>

<hr>
<h2 id='position_auto'>Jitter based on scale types</h2><span id='topic+position_auto'></span>

<h3>Description</h3>

<p>This position adjustment is able to select a meaningful jitter of the data
based on the combination of positional scale types. IT behaves differently
depending on if none, one, or both the x and y scales are discrete. If both
are discrete it will jitter the datapoints evenly inside a disc, if one of
them is discrete it will jitter the discrete dimension to follow the density
along the other dimension (like a sina plot). If neither are discrete it will
not do any jittering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>position_auto(jitter.width = 0.75, bw = "nrd0", scale = TRUE, seed = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="position_auto_+3A_jitter.width">jitter.width</code></td>
<td>
<p>The maximal width of the jitter</p>
</td></tr>
<tr><td><code id="position_auto_+3A_bw">bw</code></td>
<td>
<p>The smoothing bandwidth to use in the case of sina jittering. See
the <code>bw</code> argument in <a href="stats.html#topic+density">stats::density</a></p>
</td></tr>
<tr><td><code id="position_auto_+3A_scale">scale</code></td>
<td>
<p>Should the width of jittering be scaled based on the number of
points in the group</p>
</td></tr>
<tr><td><code id="position_auto_+3A_seed">seed</code></td>
<td>
<p>A seed to supply to make the jittering reproducible across layers</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+geom_autopoint">geom_autopoint</a> for a point geom that uses auto-position by default
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Continuous vs continuous: No jitter
ggplot(mpg) + geom_point(aes(cty, hwy), position = 'auto')

# Continuous vs discrete: sina jitter
ggplot(mpg) + geom_point(aes(cty, drv), position = 'auto')

# Discrete vs discrete: disc-jitter
ggplot(mpg) + geom_point(aes(fl, drv), position = 'auto')

# Don't scale the jitter based on group size
ggplot(mpg) + geom_point(aes(cty, drv), position = position_auto(scale = FALSE))
ggplot(mpg) + geom_point(aes(fl, drv), position = position_auto(scale = FALSE))

</code></pre>

<hr>
<h2 id='position_jitternormal'>Jitter points with normally distributed random noise</h2><span id='topic+position_jitternormal'></span>

<h3>Description</h3>

<p><code><a href="ggplot2.html#topic+geom_jitter">ggplot2::geom_jitter()</a></code> adds random noise to points using a uniform
distribution. When many points are plotted, they appear in a rectangle. This
position jitters points using a normal distribution instead, resulting in
more circular clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>position_jitternormal(sd_x = NULL, sd_y = NULL, seed = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="position_jitternormal_+3A_sd_x">sd_x</code>, <code id="position_jitternormal_+3A_sd_y">sd_y</code></td>
<td>
<p>Standard deviation to add along the x and y axes. The
function uses <code><a href="stats.html#topic+Normal">stats::rnorm()</a></code> with <code>mean = 0</code> behind the scenes.
</p>
<p>If omitted, defaults to 0.15. As with <code><a href="ggplot2.html#topic+geom_jitter">ggplot2::geom_jitter()</a></code>, categorical
data is aligned on the integers, so a standard deviation of more than 0.2
will spread the data so it's not possible to see the distinction between
the categories.</p>
</td></tr>
<tr><td><code id="position_jitternormal_+3A_seed">seed</code></td>
<td>
<p>A random seed to make the jitter reproducible.
Useful if you need to apply the same jitter twice, e.g., for a point and
a corresponding label.
The random seed is reset after jittering.
If <code>NA</code> (the default value), the seed is initialised with a random value;
this makes sure that two subsequent calls start with a different seed.
Use <code>NULL</code> to use the current random seed and also avoid resetting
(the behaviour of <span class="pkg">ggplot</span> 2.2.1 and earlier).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Example data
df &lt;- data.frame(
  x = sample(1:3, 1500, TRUE),
  y = sample(1:3, 1500, TRUE)
)

# position_jitter results in rectangular clusters
ggplot(df, aes(x = x, y = y)) +
  geom_point(position = position_jitter())

# geom_jitternormal results in more circular clusters
ggplot(df, aes(x = x, y = y)) +
  geom_point(position = position_jitternormal())

# You can adjust the standard deviations along both axes
# Tighter circles
ggplot(df, aes(x = x, y = y)) +
  geom_point(position = position_jitternormal(sd_x = 0.08, sd_y = 0.08))

# Oblong shapes
ggplot(df, aes(x = x, y = y)) +
  geom_point(position = position_jitternormal(sd_x = 0.2, sd_y = 0.08))

# Only add random noise to one dimension
ggplot(df, aes(x = x, y = y)) +
  geom_point(
    position = position_jitternormal(sd_x = 0.15, sd_y = 0),
    alpha = 0.1
  )
</code></pre>

<hr>
<h2 id='power_trans'>Create a power transformation object</h2><span id='topic+power_trans'></span>

<h3>Description</h3>

<p>This function can be used to create a proper trans object that encapsulates
a power transformation (x^n).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>power_trans(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="power_trans_+3A_n">n</code></td>
<td>
<p>The degree of the power transformation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A trans object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Power of 2 transformations
trans &lt;- power_trans(2)
trans$transform(1:10)

# Cubic root transformation
trans &lt;- power_trans(1 / 3)
trans$transform(1:10)

# Use it in a plot
ggplot() +
  geom_line(aes(x = 1:10, y = 1:10)) +
  scale_x_continuous(trans = power_trans(2),
                     expand = c(0, 1))
</code></pre>

<hr>
<h2 id='radial_trans'>Create radial data in a cartesian coordinate system</h2><span id='topic+radial_trans'></span>

<h3>Description</h3>

<p>This function creates a trans object that converts radial data to their
corresponding coordinates in cartesian space. The trans object is created for
a specific radius and angle range that will be mapped to the unit circle so
data doesn't have to be normalized to 0-1 and 0-2*pi in advance. While there
exists a clear mapping from radial to cartesian, the inverse is not true as
radial representation is periodic. It is impossible to know how many
revolutions around the unit circle a point has taken from reading its
coordinates. The inverse function will always assume that coordinates are in
their first revolution i.e. map them back within the range of a.range.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>radial_trans(r.range, a.range, offset = pi/2, pad = 0.5, clip = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="radial_trans_+3A_r.range">r.range</code></td>
<td>
<p>The range in radius that correspond to 0 - 1 in the unit
circle.</p>
</td></tr>
<tr><td><code id="radial_trans_+3A_a.range">a.range</code></td>
<td>
<p>The range in angles that correspond to 2*pi - 0. As radians
are normally measured counterclockwise while radial displays are read
clockwise it's an inverse mapping</p>
</td></tr>
<tr><td><code id="radial_trans_+3A_offset">offset</code></td>
<td>
<p>The offset in angles to apply. Determines that start position
on the circle. pi/2 (the default) corresponds to 12 o'clock.</p>
</td></tr>
<tr><td><code id="radial_trans_+3A_pad">pad</code></td>
<td>
<p>Adds to the end points of the angle range in order to separate the
start and end point. Defaults to 0.5</p>
</td></tr>
<tr><td><code id="radial_trans_+3A_clip">clip</code></td>
<td>
<p>Should input data be clipped to r.range and a.range or be allowed
to extend beyond. Defaults to FALSE (no clipping)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A trans object. The transform method for the object takes an r
(radius) and a (angle) argument and returns a data.frame with x and y columns
with rows for each element in r/a. The inverse method takes an x and y
argument and returns a data.frame with r and a columns and rows for each
element in x/y.
</p>


<h3>Note</h3>

<p>While trans objects are often used to modify scales in ggplot2, radial
transformation is different as it is a coordinate transformation and takes
two arguments. Consider it a trans version of coord_polar and use it to
transform your data prior to plotting.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Some data in radial form
rad &lt;- data.frame(r = seq(1, 10, by = 0.1), a = seq(1, 10, by = 0.1))

# Create a transformation
radial &lt;- radial_trans(c(0, 1), c(0, 5))

# Get data in x, y
cart &lt;- radial$transform(rad$r, rad$a)

# Have a look
ggplot() +
  geom_path(aes(x = x, y = y), data = cart, color = 'forestgreen') +
  geom_path(aes(x = r, y = a), data = rad, color = 'firebrick')
</code></pre>

<hr>
<h2 id='scale_depth'>Scales for depth perception</h2><span id='topic+scale_depth'></span><span id='topic+scale_depth_continuous'></span><span id='topic+scale_depth_discrete'></span>

<h3>Description</h3>

<p>These scales serve to scale the depth aesthetic when creating stereographic
plots. The range specifies the relative distance between the points and the
paper plane in relation to the distance between the eyes and the paper plane
i.e. a range of c(-0.5, 0.5) would put the highest values midways between
the eyes and the image plane and the lowest values the same distance behind
the image plane. To ensure a nice viewing experience these values should not
exceed ~0.3 as it would get hard for the eyes to consolidate the two
pictures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_depth(..., range = c(0, 0.3))

scale_depth_continuous(..., range = c(0, 0.3))

scale_depth_discrete(..., range = c(0, 0.3))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_depth_+3A_...">...</code></td>
<td>
<p>arguments passed on to continuous_scale or discrete_scale</p>
</td></tr>
<tr><td><code id="scale_depth_+3A_range">range</code></td>
<td>
<p>The relative range as related to the distance between the eyes
and the paper plane.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>ggplot(mtcars) +
  geom_point(aes(mpg, disp, depth = cyl)) +
  scale_depth(range = c(-0.1, 0.25)) +
  facet_stereo()
</code></pre>

<hr>
<h2 id='scale_unit'>Position scales for units data</h2><span id='topic+scale_x_unit'></span><span id='topic+scale_y_unit'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> These are the default scales for the units
class. These will usually be added automatically. To override manually, use
<code style="white-space: pre;">&#8288;scale_*_unit&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_x_unit(...)

scale_y_unit(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_unit_+3A_...">...</code></td>
<td>
<p>Passed on to <code>units::scale_x_unit()</code> or <code>units::scale_y_unit()</code></p>
</td></tr>
</table>

<hr>
<h2 id='stat_err'>Intervals in vertical and horizontal directions</h2><span id='topic+stat_err'></span>

<h3>Description</h3>

<p><code>stat_err</code> draws intervals of points (<code>x</code>, <code>y</code>) in vertical (<code>ymin</code>, <code>ymax</code>)
and horizontal (<code>xmin</code>, <code>xmax</code>) directions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_err(
  mapping = NULL,
  data = NULL,
  geom = "segment",
  position = "identity",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_err_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="stat_err_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="stat_err_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data, either as a
<code>ggproto</code> <code>Geom</code> subclass or as a string naming the geom stripped of the
<code>geom_</code> prefix (e.g. <code>"point"</code> rather than <code>"geom_point"</code>)</p>
</td></tr>
<tr><td><code id="stat_err_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="stat_err_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="stat_err_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="stat_err_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="stat_err_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>stat_err()</code> understands the following aesthetics (required aesthetics are in
bold):
</p>

<ul>
<li> <p><strong>x</strong>
</p>
</li>
<li> <p><strong>xmin</strong>
</p>
</li>
<li> <p><strong>xmax</strong>
</p>
</li>
<li> <p><strong>y</strong>
</p>
</li>
<li> <p><strong>ymin</strong>
</p>
</li>
<li> <p><strong>ymax</strong>
</p>
</li>
<li><p> alpha
</p>
</li>
<li><p> color
</p>
</li>
<li><p> group
</p>
</li>
<li><p> linetype
</p>
</li>
<li><p> linewidth
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)

x &lt;- 1:3
xmin &lt;- x - 2.5
xmax &lt;- x + 2.5
d &lt;- data.frame(
  x = x, y = x, xmin = xmin, ymin = xmin, xmax = xmax, ymax = xmax,
  color = as.factor(x)
)
ggplot(
  d,
  aes(x = x, y = y, xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax, color = color)
) +
  stat_err(size = 2)

</code></pre>

<hr>
<h2 id='theme_no_axes'>Theme without axes and gridlines</h2><span id='topic+theme_no_axes'></span>

<h3>Description</h3>

<p>This theme is a simple wrapper around any complete theme that removes the
axis text, title and ticks as well as the grid lines for plots where these
have little meaning.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theme_no_axes(base.theme = theme_bw())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="theme_no_axes_+3A_base.theme">base.theme</code></td>
<td>
<p>The theme to use as a base for the new theme. Defaults to
<code><a href="ggplot2.html#topic+ggtheme">ggplot2::theme_bw()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified version of base.theme
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- ggplot() + geom_point(aes(x = wt, y = qsec), data = mtcars)

p + theme_no_axes()
p + theme_no_axes(theme_grey())

</code></pre>

<hr>
<h2 id='trans_reverser'>Reverse a transformation</h2><span id='topic+trans_reverser'></span>

<h3>Description</h3>

<p>While the scales package export a reverse_trans object it does not allow for
reversing of already transformed ranged - e.g. a reverse exp transformation
is not possible. trans_reverser takes a trans object or something coercible
to one and creates a reverse version of it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trans_reverser(trans)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trans_reverser_+3A_trans">trans</code></td>
<td>
<p>A trans object or an object that can be converted to one using
<code><a href="scales.html#topic+new_transform">scales::as.trans()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A trans object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Lets make a plot
p &lt;- ggplot() +
  geom_line(aes(x = 1:10, y = 1:10))

# scales already have a reverse trans
p + scale_x_continuous(trans = 'reverse')

# But what if you wanted to reverse an already log transformed scale?
p + scale_x_continuous(trans = trans_reverser('log'))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
