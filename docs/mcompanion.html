<!DOCTYPE html><html><head><title>Help for package mcompanion</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mcompanion}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#mcompanion-package'>






<p>Objects and Methods for Multi-Companion Matrices</p></a></li>
<li><a href='#jordan'><p> Utilities for Jordan matrices</p></a></li>
<li><a href='#JordanDecomposition'><p>Create objects representing Jordan decompositions</p></a></li>
<li><a href='#JordanDecompositionDefault-class'><p>A basic class for Jordan decompositions</p></a></li>
<li><a href='#make_mcev'><p>Create a multi-companion eigenvector</p></a></li>
<li><a href='#make_mcmatrix'><p> Generate a multi-companion matrix from spectral description</p></a></li>
<li><a href='#mc_0chains'><p> Generate eigenchains for zero eigenvalues</p></a></li>
<li><a href='#mc_chain_extend'><p> Extend multi-companion eigenvectors</p></a></li>
<li><a href='#mc_chain_scale'><p>Scale vectors in eigenchains of multi-companion matrices</p></a></li>
<li><a href='#mc_chain_subset'><p>Internal utilities for mc eigenvectors</p></a></li>
<li><a href='#mc_chains_triangulate'><p>Triangulate a system of 0eigenvectors</p></a></li>
<li><a href='#mc_eigen'><p>The eigen decomposition of a multi-companion matrix</p></a></li>
<li><a href='#mc_factorize'><p> Factorise multi-companion matrices</p></a></li>
<li><a href='#mc_factors'><p> Factors of multi-companion matrices</p></a></li>
<li><a href='#mc_from_factors'><p> Multi-companion matrix from factors</p></a></li>
<li><a href='#mc_matrix'><p> Basic utilities for multi-companion matrices</p></a></li>
<li><a href='#mc.0chain.complete'><p> Extend or shrink eigenchains of 0 eigenvalues</p></a></li>
<li><a href='#mc.0chain.dx'><p>Extend chains for the top</p></a></li>
<li><a href='#mc.0chain.struct'><p> Compute structural Jordan chains for zero eigenvalues</p></a></li>
<li><a href='#mc.0chain.structfill'><p>Add structural vectors to a 0eigenchain, internal function</p></a></li>
<li><a href='#mC.non0chain.extend'><p> Extend multi-companion eigenvectors(non0)</p></a></li>
<li><a href='#mCompanion'><p> Create objects from class MultiCompanion</p></a></li>
<li><a href='#mcSpec'><p>Generate objects of class mcSpec</p></a></li>
<li><a href='#mcSpec-class'><p>A class for spectral specifications of multi-companion matrices</p></a></li>
<li><a href='#mcStable'><p> Check if an object is stable</p></a></li>
<li><a href='#mf_VSform'><p> Extract properties of multi-filters</p></a></li>
<li><a href='#MultiCompanion-class'><p>Class &quot;MultiCompanion&quot;</p></a></li>
<li><a href='#MultiFilter-class'><p>Class &quot;MultiFilter&quot;</p></a></li>
<li><a href='#null_complement'><p>Compute the orthogonal complement of a subspace</p></a></li>
<li><a href='#optionalMatrix-class'><p>Class optionalMatrix</p></a></li>
<li><a href='#permute_var'><p>Permute rows and columns of matrices</p></a></li>
<li><a href='#rblockmult'><p> Right-multiply a matrix by a block</p></a></li>
<li><a href='#reduce_chains_simple'><p>Transform a chain and drop excess, internal function</p></a></li>
<li><a href='#sim_chains'><p>Simulate Jordan chains</p></a></li>
<li><a href='#sim_mc'><p> Simulate a multi-companion matrix</p></a></li>
<li><a href='#sim_pcfilter'><p> Generate periodic filters</p></a></li>
<li><a href='#SmallMultiCompanion-class'><p>A class for small multi-companion matrices</p></a></li>
<li><a href='#spec_core'>
<p>Parameterise Jordan chains of multi-companion matrices</p></a></li>
<li><a href='#spec_root0'><p>Give the spectral parameters for zero eigenvalues of mc-matrices</p></a></li>
<li><a href='#spec_root1'><p>Give the spectral parameters for eigenvalues  of mc-matrices</p>
equal to one</a></li>
<li><a href='#spec_seeds1'>
<p>Generate seed parameters for unit mc-eigenvectors</p></a></li>
<li><a href='#VAR2pcfilter'><p>PAR representations of VAR models</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Objects and Methods for Multi-Companion Matrices</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6</td>
</tr>
<tr>
<td>Description:</td>
<td>
    Provides a class for multi-companion matrices with methods for
    arithmetic and factorization.  A method for generation of
    multi-companion matrices with prespecified spectral properties is
    provided, as well as some utilities for periodically correlated and
    multivariate time series models. See Boshnakov (2002)
    &lt;<a href="https://doi.org/10.1016%2FS0024-3795%2801%2900475-X">doi:10.1016/S0024-3795(01)00475-X</a>&gt; and Boshnakov &amp; Iqelan (2009)
    &lt;<a href="https://doi.org/10.1111%2Fj.1467-9892.2009.00617.x">doi:10.1111/j.1467-9892.2009.00617.x</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://geobosh.github.io/mcompanion/">https://geobosh.github.io/mcompanion/</a> (doc),
<a href="https://github.com/GeoBosh/mcompanion">https://github.com/GeoBosh/mcompanion</a> (devel)</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/GeoBosh/mcompanion/issues">https://github.com/GeoBosh/mcompanion/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix (&ge; 1.5-0), gbutils, MASS, Rdpack</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, lagged</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Collate:</td>
<td>mc.R mcompanion.R utils_Jordan.R mat.R sim.R class_MC.R
class_MF.R class_Jordan.R chains_smc.R class_SMC.R
class_mcSpec.R</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-03 19:26:29 UTC; georgi</td>
</tr>
<tr>
<td>Author:</td>
<td>Georgi N. Boshnakov [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Georgi N. Boshnakov &lt;georgi.boshnakov@manchester.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-03 19:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='mcompanion-package'>






Objects and Methods for Multi-Companion Matrices
</h2><span id='topic+mcompanion-package'></span><span id='topic+mcompanion'></span>

<h3>Description</h3>

<p>
    Provides a class for multi-companion matrices with methods for
    arithmetic and factorization.  A method for generation of
    multi-companion matrices with prespecified spectral properties is
    provided, as well as some utilities for periodically correlated and
    multivariate time series models. See Boshnakov (2002)
    &lt;doi:10.1016/S0024-3795(01)00475-X&gt; and Boshnakov &amp; Iqelan (2009)
    &lt;doi:10.1111/j.1467-9892.2009.00617.x&gt;.
</p>


<h3>Details</h3>












<p><strong>Index of the main exported objects, classes and methods:</strong>
</p>






<h4>Classes and generators</h4>

<pre>MultiCompanion-class    Class "MultiCompanion"
MultiFilter-class       Class "MultiFilter"
VAR2pcfilter            PAR representations of VAR models
mCompanion              Create objects from class MultiCompanion
mcSpec                  Generate objects of class mcSpec
mcSpec-class            A class for spectral specifications of
                        multi-companion matrices
mf_VSform               Extract properties of multi-filters</pre>



<h4>Utilities for multi-companion matrices</h4>

<pre>mc_eigen                The eigen decomposition of a multi-companion
                        matrix
mc_factorize            Factorise multi-companion matrices
mc_factors              Factors of multi-companion matrices
mc_from_factors         Multi-companion matrix from factors</pre>










<h4>Simulation</h4>

<pre>sim_mc                  Simulate a multi-companion matrix
sim_pcfilter            Generate periodic filters</pre>



<h4>Generic matrix utilities</h4>

<pre>Jordan_matrix           Utilities for Jordan matrices
mcStable                Check if an object is stable
rblockmult              Right-multiply a matrix by a block</pre>



<h4>Spectral description of mc-matrices</h4>

<pre>spec_core               Parameterise Jordan chains of multi-companion
                        matrices
spec_root0              Give the spectral parameters for zero
                        eigenvalues of mc-matrices
spec_root1              Give the spectral parameters for eigenvalues of
                        mc-matrices equal to one
spec_seeds1             Generate seed parameters for unit
                        mc-eigenvectors</pre>



<h4>Low-level functions</h4>

   
<pre>mc_chain_extend         Extend multi-companion eigenvectors</pre>

<p><strong>Overview of the package</strong>
</p>
<p>Package &quot;mcompanion&quot; implements multi-companion matrices as discussed by
Boshnakov (2002) and Boshnakov and Iqelan (2009). The main feature is
the provided parsimonious parameterisation of such matrices based on
their eigenvalues and the seeds for their eigenvectors.  This can be
used for specification and parameterisation of models for time
series and dynamical systems in terms of spectral characteristics, such
as the poles of the associated filters or transition matrices.
</p>
<p>A multi-companion matrix of order k is a square <code class="reqn">n\times n</code>
matrix with arbitrary k rows put on top of an identity
<code class="reqn">(n-k)\times(n-k)</code> matrix and a zero <code class="reqn">(n-k)\times
k</code> matrix. The number <code class="reqn">k</code> is the multi-companion order of
the matrix.  It may happen that the top <code class="reqn">k \times n</code> block,
say T, of an mc-matrix has columns of zeroes at its end.  In this
documentation we say that an <code class="reqn">n\times n</code> matrix has dimension
<code class="reqn">n</code> and size <code class="reqn">n\times n</code>.
</p>
<p>Multi-companion matrices can be created by the functions <code>new</code> and
<code><a href="#topic+mCompanion">mCompanion</a></code>, the latter being more versatile. Some of the other
functions  in this package return such objects, as well.
</p>
<p><code><a href="#topic+sim_mc">sim_mc</a></code> generates a multi-companion matrix with partially or fully
specified spectral properties. If the specification is incomplete, it
completes it with simulated values.
</p>
<p><code><a href="#topic+sim_pcfilter">sim_pcfilter</a></code> is a convenience function (it uses <code>sim_mc</code>)
for generation of filters for periodically correlated models.  These can
be converted to various multivariate models, such as VAR, most
conveniently using class <code><a href="#topic+MultiFilter-class">MultiFilter</a></code>, see
below.
</p>
<p>Class &quot;MultiFilter&quot; is a formal representation of periodic
filters with methods for conversion between periodic and (non-periodic)
multivariate filters. Several forms of VAR models are provided, see
<code><a href="#topic+mf_VSform">mf_VSform</a></code>,
<code><a href="#topic+VAR2pcfilter">VAR2pcfilter</a></code>,
<code><a href="#topic+MultiFilter-class">MultiFilter</a></code>,
and the examples there.
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov [aut, cre]
</p>
<p>Maintainer: Georgi N. Boshnakov &lt;georgi.boshnakov@manchester.ac.uk&gt;
</p>


<h3>References</h3>


<p>Boshnakov GN (2002).
&ldquo;Multi-companion matrices.&rdquo;
<em>Linear Algebra Appl.</em>, <b>354</b>, 53&ndash;83.
ISSN 0024-3795, <a href="https://doi.org/10.1016/S0024-3795%2801%2900475-X">doi:10.1016/S0024-3795(01)00475-X</a>.
</p>
<p>Boshnakov GN (2007).
&ldquo;Singular value decomposition of multi-companion matrices.&rdquo;
<em>Linear Algebra Appl.</em>, <b>424</b>(2-3), 393&ndash;404.
ISSN 0024-3795, <a href="https://doi.org/10.1016/j.laa.2007.02.010">doi:10.1016/j.laa.2007.02.010</a>.
</p>
<p>Boshnakov GN, Iqelan BM (2009).
&ldquo;Generation of time series models with given spectral properties.&rdquo;
<em>J. Time Series Anal.</em>, <b>30</b>(3), 349&ndash;368.
ISSN 0143-9782, <a href="https://doi.org/10.1111/j.1467-9892.2009.00617.x">doi:10.1111/j.1467-9892.2009.00617.x</a>.
</p>


<h3>See Also</h3>

<p>for examples, see
<code><a href="#topic+mCompanion">mCompanion</a></code>,
<code><a href="#topic+sim_mc">sim_mc</a></code>,
<code><a href="#topic+sim_pcfilter">sim_pcfilter</a></code>,
<code><a href="#topic+mf_VSform">mf_VSform</a></code>,
<code><a href="#topic+VAR2pcfilter">VAR2pcfilter</a></code>,<br />
<code><a href="#topic+MultiFilter-class">MultiFilter</a></code>,
<code><a href="#topic+MultiCompanion-class">MultiCompanion</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## see the examples in the links in section 'See Also' above.
</code></pre>

<hr>
<h2 id='jordan'> Utilities for Jordan matrices </h2><span id='topic+Jordan_matrix'></span><span id='topic+from_Jordan'></span><span id='topic+chain_ind'></span><span id='topic+chains_to_list'></span>

<h3>Description</h3>

<p>Utility functions for work with the Jordan decompositions of matrices:
create a block diagonal matrix of Jordan blocks,
restore a matrix from its Jordan decomposition,
locate specific chains.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Jordan_matrix(eigval, len.block)
from_Jordan(x, jmat, ...)
chain_ind(chainno, len.block)
chains_to_list(vectors, heights)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jordan_+3A_eigval">eigval</code></td>
<td>
<p> eigenvalues, a numeric or complex vector. </p>
</td></tr>
<tr><td><code id="jordan_+3A_len.block">len.block</code></td>
<td>

<p>lengths of Jordan chains, a vector of positive integers.
</p>
</td></tr>
<tr><td><code id="jordan_+3A_x">x</code></td>
<td>

<p>generalised eigenvectors, a matrix with one column for each
(generalised) eigenvector.
</p>
</td></tr>
<tr><td><code id="jordan_+3A_jmat">jmat</code></td>
<td>
<p> a Jordan matrix. </p>
</td></tr>
<tr><td><code id="jordan_+3A_chainno">chainno</code></td>
<td>

<p>a vector of positive integers between 1 and <code>length(eigval)</code>
specifying which Jordan chains to locate, see Details.
</p>
</td></tr>
<tr><td><code id="jordan_+3A_...">...</code></td>
<td>
<p>further arguments to pass on to <code>solve</code>.</p>
</td></tr>
<tr><td><code id="jordan_+3A_vectors">vectors</code></td>
<td>
<p>a matrix of generalised eigenvectors of a matrix.</p>
</td></tr>
<tr><td><code id="jordan_+3A_heights">heights</code></td>
<td>

<p>a vector of chain lengths, <code>heights[i]</code> is the length of the
i-th chain.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>Jordan_matrix</code> creates a Jordan matrix (block-diagonal matrix
with Jordan blocks on the diagonal) whose i-th diagonal block
corresponds to <code>eigval[i]</code> and is of size <code>len.block[i]</code>.
If <code>len.block</code> is missing, <code>Jordan_matrix</code> returns
<code>diag(eigenvalues)</code>.
</p>
<p><code>from_Jordan</code> computes the matrix whose Jordan decomposition is
represented by arguments <code>X</code> (chains) and <code>J</code> (Jordan
matrix). Conceptually, the result is equivalent to <code class="reqn">XJX^{-1}</code> but
without explicitly inverting matrices (currently the result is the
transpose of <code>solve(t(x), t(x %*% jmat), ...)</code>).
</p>
<p><code>chain_ind</code> computes the columns of specified Jordan chains in a
matrix of generalised eigenvectors. It is mostly internal function.
If <code>x</code> is a matrix whose columns are generalised eigenvectors and
the i-th Jordan chain is of length <code>len.block[i]</code>, then this
function gives the column numbers of <code>x</code> containing the specified
chains.
Note that <code>chain_ind</code> is not able to deduce the total number of
eigenvalues. It is therefore an error to omit argument
<code>len.block</code> when calling it.
</p>
<p><code>chains_to_list</code> converts the matrix <code>vectors</code> into a list
of matrices. The i-th element of this list is a matrix whose columns
are the vectors in the i-th chain.
</p>


<h3>Value</h3>

<p>for <code>Jordan_matrix</code>, a matrix with the specified Jordan blocks on
its diagonal.
</p>
<p>for <code>from_Jordan</code>, the matrix with the specified Jordan
decomposition.
</p>
<p>for <code>chain_ind</code>, a vector of positive integers giving the columns
of the requested chains.
</p>
<p>for <code>chains_to_list</code>, a list of matrices.
</p>


<h3>Level</h3>

<p>0</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>Examples</h3>

<pre><code class='language-R'>## single Jordan blocks
Jordan_matrix(4, 2) 
Jordan_matrix(5, 3)
Jordan_matrix(6, 1)
## a matrix with the above 3 blocks
Jordan_matrix(c(4, 5, 6), c(2, 3, 1))

## a matrix with a 2x2 Jordan block for eval 1 and two simple 0 eval's
m &lt;- make_mcmatrix(eigval = c(1), co = cbind(c(1,1,1,1), c(0,1,0,0)),
                     dim = 4, len.block = c(2))
m
m.X &lt;- cbind(c(1,1,1,1), c(0,1,0,0), c(0,0,1,0), c(0,0,0,1))
m.X
m.J &lt;- cbind(c(1,0,0,0), c(1,1,0,0), rep(0,4), rep(0,4))
m.J

from_Jordan(m.X, m.J)          # == m
m.X %*% m.J %*% solve(m.X) # == m
all(m == from_Jordan(m.X, m.J)) &amp;&amp; all(m == m.X %*% m.J %*% solve(m.X))
## TRUE

## which column(s) in m.X correspond to 1st Jordan block?
chain_ind(1, c(2,1,1)) # c(1, 2) since 2x2 Jordan block
    
## which column(s) in m.X correspond to 2nd Jordan block?
chain_ind(2, c(2,1,1)) # 3, simple eval

## which column(s) in m.X correspond to 1st and 2nd Jordan blocks?
chain_ind(c(1, 2), c(2,1,1)) # c(1,2,3)
## non-contiguous subset are ok:
chain_ind(c(1, 3), c(2,1,1)) # c(1,2,4)

## split the chains into a list of matrices
chains_to_list(m.X, c(2,1,1))
    
m.X %*% m.J
m %*% m.X    # same
all(m.X %*% m.J == m %*% m.X)    # TRUE
        
m %*% c(1,1,1,1)    # = c(1,1,1,1),  evec for eigenvalue 1
m %*% c(0,1,0,0)    # gen.e.v. for eigenvalue 1
## indeed:
all( m %*% c(0,1,0,0) == c(0,1,0,0) + c(1,1,1,1) ) # TRUE    

## m X = X jordan.block
cbind(c(1,1,1,1), c(0,1,0,0)) %*% cbind(c(1,0), c(1,1))
m %*% cbind(c(1,1,1,1), c(0,1,0,0))
</code></pre>

<hr>
<h2 id='JordanDecomposition'>Create objects representing Jordan decompositions</h2><span id='topic+JordanDecomposition'></span><span id='topic+JordanDecomposition-methods'></span><span id='topic+JordanDecomposition+2CANY+2CANY-method'></span><span id='topic+JordanDecomposition+2CJordanDecomposition+2Cmissing-method'></span><span id='topic+JordanDecomposition+2Clist+2Cmissing-method'></span><span id='topic+JordanDecomposition+2Cmissing+2Cmatrix-method'></span><span id='topic+JordanDecomposition+2Cmissing+2Cmissing-method'></span><span id='topic+JordanDecomposition+2Cnumber+2Cmatrix-method'></span><span id='topic+JordanDecomposition+2Cnumber+2Cmissing-method'></span><span id='topic+JordanDecomposition+2CSmallMultiCompanion+2Cmissing-method'></span>

<h3>Description</h3>

<p>Create objects representing Jordan decompositions.</p>


<h3>Usage</h3>

<pre><code class='language-R'>JordanDecomposition(values, vectors, heights, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="JordanDecomposition_+3A_values">values</code></td>
<td>

<p>eigenvalues, a vector of length equal to the number of Jordan chains.
</p>
</td></tr>
<tr><td><code id="JordanDecomposition_+3A_vectors">vectors</code></td>
<td>

<p>the (generalised) eigenvectors, a matrix.
</p>
</td></tr>
<tr><td><code id="JordanDecomposition_+3A_heights">heights</code></td>
<td>

<p>a vector of positive integers, <code>heights[i]</code> is the height of
<code>values[i]</code>.
</p>
</td></tr>
<tr><td><code id="JordanDecomposition_+3A_...">...</code></td>
<td>

<p>further arguments that may be needed by methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>JordanDecomposition</code> is an S4 generic function. It creates
objects representing Jordan decompositions. Dispatch is on the first
two arguments, <code>values</code> and <code>vectors</code>.
</p>
<p>The names of the arguments correspond to slots in class
&quot;JordanDecompositionDefault&quot;, which is the class of the objects
created by methods in package <span class="pkg">mcompanion</span> and inherits from the
virtual class &quot;JordanDecomposition&quot;.
</p>


<h3>Value</h3>

<p>an object inheriting from &quot;JordanDecomposition&quot;
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(values = "ANY", vectors = "ANY")</code></dt><dd>
<p>the default method; currently raises an error.
</p>
</dd>
<dt><code>signature(values = "JordanDecomposition", vectors = "missing")</code></dt><dd>
<p>simply returns <code>values</code>.
</p>
</dd>
<dt><code>signature(values = "list", vectors = "missing")</code></dt><dd>
<p>In this case <code>values</code> can be a list with components <code>"values"</code>,
<code>"vectors"</code> and <code>"heights"</code>. This method has an additional
argument <code>"names"</code> which can be used when the components of the
list are different, e.g.
</p>
<p><code>names = c(values = "eigval", vectors = "eigvec", heights = "len.block")</code>.
</p>
</dd>
<dt><code>signature(values = "missing", vectors = "matrix")</code></dt><dd>
<p>This is equivalent to the case <code>values = "number"</code> with <code>values</code>
set to a vector of missing values.
</p>
</dd>
<dt><code>signature(values = "missing", vectors = "missing")</code></dt><dd>
<p><code>values</code> (<code>vectors</code>) is set to a vector (matrix) of missing
values. The dimensions are deduced from argument <code>heights</code>, so
<code>heights</code> cannot be missing for this signature.
</p>
</dd>
<dt><code>signature(values = "number", vectors = "matrix")</code></dt><dd>
<p>This is equivalent to calling <code>new</code> for class
<code>"JordanDecompositionDefault"</code> with arguments <code>values</code>,
<code>vectors</code> and <code>heights</code>.
</p>
</dd>
<dt><code>signature(values = "number", vectors = "missing")</code></dt><dd>
<p>This is equivalent to the case <code>vectors = "matrix"</code> with <code>vectors</code>
set to a matrix of missing values.
</p>
</dd>
<dt><code>signature(values = "SmallMultiCompanion", vectors = "missing")</code></dt><dd>
<p>This computes the Jordan decomposition of an object from class
&quot;SmallMultiCompanion&quot;.
</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- matrix(c(1,2,4,10), nrow = 2)
m &lt;- matrix(c(1,2,4,10), nrow = 2)
m &lt;- matrix(c(5, 12, 3, 4), nrow = 2)

JordanDecomposition(values = rep(0,2), vectors = m)
jd &lt;- JordanDecomposition(values = c(0.9, 0.3), vectors = m)
as(jd, "matrix")
eigen(jd)
## the eigenvectors are scaled versions of m's columns:
eigen(jd)$vectors %*% diag(c(5 / eigen(jd)$vectors[1,1], -5))
## == m

## eigenvalues are not supplied, so set to  NA's here:
JordanDecomposition(vectors = m)

## eigenvectors are set to vectors of NA's here:
JordanDecomposition(values = rep(0,2), height = c(1,1))
</code></pre>

<hr>
<h2 id='JordanDecompositionDefault-class'>A basic class for Jordan decompositions</h2><span id='topic+JordanDecompositionDefault-class'></span><span id='topic+JordanDecomposition-class'></span><span id='topic+coerce+2CJordanDecompositionDefault+2Cmatrix-method'></span><span id='topic+initialize+2CJordanDecompositionDefault-method'></span>

<h3>Description</h3>

<p>A basic class for Jordan decompositions.</p>


<h3>Details</h3>

<p>Class <code>"JordanDecompositionDefault"</code> represents Jordan
decompositions. It inherits from the virtual class
&quot;JordanDecomposition&quot;, which serves as a base class for Jordan
decompositions. These classes should be considered internal.
</p>


<h3>Objects from the Class</h3>

<p>Objects from class <code>"JordanDecompositionDefault"</code> can be created
by  a call to  <code>JordanDecomposition()</code>.
</p>
<p>Objects can be created by calls of the form
<code>new("JordanDecompositionDefault", heights, ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>values</code>:</dt><dd><p>Object of class <code>"number"</code>,
vector of eigenvalues (one value for each Jordan chain).
</p>
</dd>
<dt><code>heights</code>:</dt><dd><p>Object of class <code>"integer"</code>,
the heights of the Jordan chains.
</p>
</dd>
<dt><code>vectors</code>:</dt><dd><p>Object of class <code>"matrix"</code>,
the (generalised) eigenvectors (similarity matrix).
</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+JordanDecomposition-class">JordanDecomposition</a>"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>coerce</dt><dd><p><code>signature(from = "JordanDecompositionDefault",
	to = "matrix")</code>:
</p>
<p>gives the matrix represented by the Jordan decomposition, i.e.
<code class="reqn">XJX^{-1}</code>. As with other coerce methods, use
<code>as(obj, "matrix")</code>, where <code>obj</code> is the Jordan
decomposition object.
</p>
</dd>
<dt>initialize</dt><dd><p><code>signature(.Object = "JordanDecompositionDefault")</code>: ... </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Georgi N. Boshnakov
</p>


<h3>See Also</h3>

<p><code><a href="#topic+JordanDecomposition">JordanDecomposition</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("JordanDecompositionDefault")

m &lt;- matrix(c(1,2,4,3), nrow = 2)
new("JordanDecompositionDefault", values = rep(0,2), vectors = m)
</code></pre>

<hr>
<h2 id='make_mcev'>Create a multi-companion eigenvector</h2><span id='topic+make_mcev'></span><span id='topic+make_mcgev'></span>

<h3>Description</h3>

<p>Creates an eigenvector of a multicompanion matrix from the eigenvalue
and the seed parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_mcev(eigval, co, dim, what.co = "bottom")
make_mcgev(eigval, co, v, what.co = "bottom")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_mcev_+3A_eigval">eigval</code></td>
<td>
<p> the eigenvalue. </p>
</td></tr>
<tr><td><code id="make_mcev_+3A_co">co</code></td>
<td>

<p>the bottom (default) or the top seed elements of the vector.
</p>
</td></tr>
<tr><td><code id="make_mcev_+3A_dim">dim</code></td>
<td>
<p>the size of the matrix. </p>
</td></tr>
<tr><td><code id="make_mcev_+3A_what.co">what.co</code></td>
<td>
<p> type of <code>co</code>: &quot;bottom&quot; or &quot;top&quot;.  </p>
</td></tr>
<tr><td><code id="make_mcev_+3A_v">v</code></td>
<td>
<p> the previous vector in the chain.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>make_mcev</code> computes an eigenvector for a multi-companion
<code>dim x dim</code> matrix by filling its top or bottom part with
<code>co</code> and completing the remaining elements using the general
pattern of eigenvectors of such matrices
(Boshnakov 2002).
</p>
<p>Similarly, <code>make_mcgev</code> computes the next generalised
eigenvector in a chain whose previous element is <code>v</code>.
</p>
<p><code>what.co</code> cannot be <code>"top"</code> if the eigenvalue is
0. Generalised eigenvectors corresponding to the zero eigenvalue have
some specifics, so it is better to use the specialised functions in
that case.
</p>


<h3>Value</h3>

<p><code>make_mcev</code> returns the required eigenvector.
</p>
<p><code>make_mcgev</code> returns the required generalised eigenvector.
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>References</h3>

<p>Boshnakov GN (2002).
&ldquo;Multi-companion matrices.&rdquo;
<em>Linear Algebra Appl.</em>, <b>354</b>, 53&ndash;83.
ISSN 0024-3795, <a href="https://doi.org/10.1016/S0024-3795%2801%2900475-X">doi:10.1016/S0024-3795(01)00475-X</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>v1 &lt;- make_mcev(0.5, c(1, 1), dim = 4)
v1
make_mcev(0.5, c(1, 1), dim = 4, what.co = "top")

v2 &lt;- make_mcgev(0.5, c(0, 1), v = v1, what.co = "top")
v2
make_mcgev(0.5, c(0, 1), v = v2, what.co = "top")
</code></pre>

<hr>
<h2 id='make_mcmatrix'> Generate a multi-companion matrix from spectral description</h2><span id='topic+make_mcmatrix'></span><span id='topic+make_mcchains'></span>

<h3>Description</h3>

<p>Generate a multi-companion matrix or its Jordan decomposition from
spectral parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_mcmatrix(type = "real", what.res = "matrix", ..., eigval0)

make_mcchains(eigval, co, dim, len.block, eigval0 = FALSE,
              mo.col = NULL, what.co = "bottom", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_mcmatrix_+3A_eigval">eigval</code></td>
<td>
<p> the eigenvalues, a numeric vector </p>
</td></tr>
<tr><td><code id="make_mcmatrix_+3A_co">co</code></td>
<td>
<p> the seeding parameters for the eigenvectors, a matrix</p>
</td></tr>
<tr><td><code id="make_mcmatrix_+3A_dim">dim</code></td>
<td>
<p> the dimension of the matrix, a positive integer </p>
</td></tr>
<tr><td><code id="make_mcmatrix_+3A_len.block">len.block</code></td>
<td>
<p> lengths of Jordan chains,
<code>len.block[i]</code> is for <code>eigval[i]</code> </p>
</td></tr>

<tr><td><code id="make_mcmatrix_+3A_type">type</code></td>
<td>
<p> mode of the matrix, real or complex </p>
</td></tr>
<tr><td><code id="make_mcmatrix_+3A_what.res">what.res</code></td>
<td>
<p> format of the result, see details </p>
</td></tr>
<tr><td><code id="make_mcmatrix_+3A_eigval0">eigval0</code></td>
<td>
<p> If TRUE completes the matrix to a square matrix, see
details. <code>eigval0</code> is ignored by <code>make_mcmatrix</code> (it
always sets it to <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="make_mcmatrix_+3A_...">...</code></td>
<td>

<p>for <code>make_mcmatrix</code>, these are additional arguments to be passed
to  <code>make_mcchains</code>. For <code>make_mcchains</code>, arguments in
<code>"..."</code> are passed on to  <code>mc_0chains</code>.
</p>
</td></tr>
<tr><td><code id="make_mcmatrix_+3A_mo.col">mo.col</code></td>
<td>

<p>the last non-zero column in the top of the mc-matrix. The default is
<code>dim</code>.
</p>
</td></tr>
<tr><td><code id="make_mcmatrix_+3A_what.co">what.co</code></td>
<td>

<p>a character string equal to <code>"bottom"</code> (default) or
<code>"top"</code>, specifying whether the 'co' parameters give the last
or the first few elements of the (generalised) eigenvectors.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>make_mcmatrix</code> creates a multi-companion matrix specified by
spectral parameters. <code>make_mcchains</code> creates a matrix of
eigenvectors and generalised eigenvectors from the given spectral
parameters.
</p>
<p><code>make_mcmatrix</code> passes the spectral parameters to
<code>make_mcchains</code> to generate the (generalised) eigenvectors. It
then calls <code>Jordan_matrix</code> to create the corresponding Jordan
matrix.  The results are combined to produce the multicompanion
matrix.  By default, the real part is returned, which is appropriate
if all complex spectral parameters come in complex conjugate
pairs. This may be changed by argument <code>type</code>. A list containing
the matrix and the Jordan factors is returned if <code>what.res =
  "list"</code>.
</p>
<p>The closely related function <code><a href="#topic+sim_mc">sim_mc</a></code> is like
<code>make_mcmatrix</code> but it does not need complete specification of
the matrix - it completes
any missing information (eigenvalues, co) with randomly generated
entries. The result of both functions is a list or ordinary matrix,
use <code><a href="#topic+mCompanion">mCompanion</a></code> to obtain a <code>MultiCompanion</code> object
directly.
</p>
<p><code>make_mcchains</code> constructs the eigensystem, <code>make_mcmatrix</code>
calls <code>make_mcchains</code> (passing the <code>...</code> arguments to it)
and forms the matrix. <code>make_mcchains</code> passes the <code>...</code>
arguments to <code>mc_0chains</code>.



</p>
<p><code>make_mcchains</code> creates the full eigenvectors from the <code>co</code>
parameters. If the number of vectors is smaller then <code>dim</code> and
<code>eigval0</code> is TRUE  it then completes the system with chains for
the zero eigenvalue. More specifically, it assumes that the number of
the given chains is <code>mo.col</code>,  takes chains corresponding
to the zero eigenvalue, if any, and adds additional eigenvectors
and/or generalised eigenvectors to construct the complete system.
</p>
<p>The mc-order is determined from the dimension of the 'co'
parameters. If that is equal to <code>dim</code>, the mc-matrix is actually a
general matrix.
</p>
<p><strong>TODO:</strong> cover the case <code>mo &lt; mo.col</code>?
</p>


<h3>Value</h3>

<p><code>make_mcmatrix</code> normally returns the multi-companion matrix (as an
ordinary matrix) having the given spectral properties but if
<code>what.res = "list"</code>, it returns a list containing the matrix and
the spectral information:
</p>
<table>
<tr><td><code>eigval</code></td>
<td>
<p>eigenvalues, a vector</p>
</td></tr>
<tr><td><code>len.block</code></td>
<td>
<p>lengths of Jordan chains, a vector</p>
</td></tr>
<tr><td><code>mo</code></td>
<td>
<p>multi-companion order, positive integer</p>
</td></tr>
<tr><td><code>eigvec</code></td>
<td>
<p>generalied eigenvectors, a matrix</p>
</td></tr>
<tr><td><code>co</code></td>
<td>
<p>seeding parameters</p>
</td></tr>
<tr><td><code>mo.col</code></td>
<td>
<p>top order</p>
</td></tr>
<tr><td><code>mat</code></td>
<td>
<p>the multi-companion matrix, a matrix</p>
</td></tr>
</table>
<p><code>make_mcchains</code> returns a similar list without the component
<code>mat</code>.
</p>


<h3>Note</h3>

<p>The result is an ordinary matrix. Also, some entries that should
be 0 may be non-zero due to numerical error.
</p>
<p>To get a MultiCompanion object use <code><a href="#topic+mCompanion">mCompanion</a></code>.
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>References</h3>


<p>Boshnakov GN (2002).
&ldquo;Multi-companion matrices.&rdquo;
<em>Linear Algebra Appl.</em>, <b>354</b>, 53&ndash;83.
ISSN 0024-3795, <a href="https://doi.org/10.1016/S0024-3795%2801%2900475-X">doi:10.1016/S0024-3795(01)00475-X</a>.
</p>
<p>Boshnakov GN, Iqelan BM (2009).
&ldquo;Generation of time series models with given spectral properties.&rdquo;
<em>J. Time Series Anal.</em>, <b>30</b>(3), 349&ndash;368.
ISSN 0143-9782, <a href="https://doi.org/10.1111/j.1467-9892.2009.00617.x">doi:10.1111/j.1467-9892.2009.00617.x</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make_mcev">make_mcev</a></code>,
<code><a href="#topic+make_mcgev">make_mcgev</a></code>,
<code><a href="#topic+sim_mc">sim_mc</a></code>,
<code><a href="#topic+mCompanion">mCompanion</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>make_mcmatrix(eigval = c(1, 0.5), co = cbind(c(1,1), c(1, -1)), dim = 4,
              mo.col = 2,
              len.block = c(1, 1))

## one unit root, one root = 0.5
make_mcmatrix(eigval = c(1, 0.5), co = cbind(c(1,1), c(1, -1)), dim = 6,
              mo.col = 2,
              len.block = c(1, 1))

## two simple unit roots, one root = 0.5
make_mcmatrix(eigval = c(1, 1, 0.5), co = cbind(c(1,1), c(1, -1), c(1, 1)), dim = 6,
              mo.col = 3,
              len.block = c(1, 1, 1))

## two unit roots with a single Jordan chain, one root = 0.5
make_mcmatrix(eigval = c(1, 0.5), co = cbind(c(1,1), c(0, 1), c(1, 1)), dim = 6,
              len.block = c(2, 1))


## make_mcchains
make_mcchains(c(1, 0.5), co = cbind(c(1,1), c(1, 1)), dim = 4,
              len.block = c(1, 1), eigval0 = TRUE)

## one unit root, one root = 0.5
make_mcchains(c(1, 0.5), co = cbind(c(1,1), c(1, 1)), dim = 6,
              len.block = c(1, 1), eigval0 = TRUE)

## two simple unit roots, one root = 0.5
make_mcchains(c(1, 1, 0.5), co = cbind(c(1,1), c(1, -1), c(1, 1)), dim = 6,
              len.block = c(1, 1, 1), eigval0 = TRUE)

## two unit roots with a single Jordan chain, one root = 0.5
make_mcchains(c(1, 0.5), co = cbind(c(1,1), c(1, -1), c(1, 1)), dim = 6,
              len.block = c(2, 1), eigval0 = TRUE)



## examples with mc-order = dim
make_mcchains(c(1), co = cbind(c(1,1,1,1), c(1,2,1,1)), dim = 4,
              len.block = c(2), eigval0 = TRUE)
## do not complete with chians for the 0 eigval:
make_mcchains(c(1), co = cbind(c(1,1,1,1), c(1,2,1,1)), dim = 4,
              len.block = c(2), eigval0 = FALSE)

make_mcmatrix(eigval = c(1), co = cbind(c(1,1,1,1), c(1,2,1,1)), dim = 4,
              len.block = c(2))
make_mcmatrix(eigval = c(1), co = cbind(c(1,1,1,1), c(1,2,3,4)), dim = 4,
              len.block = c(2))
</code></pre>

<hr>
<h2 id='mc_0chains'> Generate eigenchains for zero eigenvalues </h2><span id='topic+mc_0chains'></span>

<h3>Description</h3>

<p>Generate eigenchains for zero eigenvalues of multi-companion matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_0chains(dim, mo, mo.col, vec0, flagtriang = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_0chains_+3A_dim">dim</code></td>
<td>
<p> dimension of the matrix </p>
</td></tr>
<tr><td><code id="mc_0chains_+3A_mo">mo</code></td>
<td>
<p> multi-companion order </p>
</td></tr>
<tr><td><code id="mc_0chains_+3A_mo.col">mo.col</code></td>
<td>
<p> number of (non-zero) structural columns </p>
</td></tr>
<tr><td><code id="mc_0chains_+3A_vec0">vec0</code></td>
<td>
<p> a list of Jordan chains for non-structural zero
eigenvalues, see details </p>
</td></tr>
<tr><td><code id="mc_0chains_+3A_flagtriang">flagtriang</code></td>
<td>
<p>triangulase the vectors?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Non-structural eigenvectors for zero eigenvalues may be specified with the
<code>vec0</code> argument. It is a list with one element for each
non-structural 0 eigenvalue. This element is a matrix with the seeding
chain for the corresponding chain (!!! edit this !!!) with enough
number of rows (at least the multi-companion order). This is often a
zero chain for a mc matrix of smaller or larger size. In that case the
vectors in the chain are extended or shrinked, respectively. However,
extending and shrinking of 0-chains is different from the ordinary
case of non-zero eigenvalues and involves increasing or decreasing the
number of vectors in the chain.
</p>
<p>If <code>vec0</code> is missing or equal to <code>list()</code> the function
assumes that the only 0 eigenvalues are the structural ones, i.e. that
there are no 0 eigenvalues among the remaining eigenvalues.
</p>


<h3>Value</h3>

<p>A list with elements <code>eigval</code>, <code>len.block</code>, <code>eigvec</code>,
and <code>chains</code>. These may be easily merged with the output from
<code>make_mcev</code>.
</p>


<h3>Note</h3>

<p>This function covers all possibilities but has not been tested
properly in the case when non-structural 0 eigenvalues are present.
</p>
<p><strong>TODO:</strong> Prepare meaningful examples and tests.
</p>
<p>2015-12-27: dropped argument F0bot. The old signature was
<code>mc_0chains(dim, mo, mo.col, vec0, F0bot = NULL, flagtriang = TRUE)</code>.
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

 <p><code><a href="#topic+make_mcev">make_mcev</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>mc_0chains(6, 4, 1)
mc_0chains(6, 4, 2)
mc_0chains(6, 4, 3)
mc_0chains(6, 4, 4)

mc_0chains(6, 2, 2)
mc_0chains(6, 2, 4)
mc_0chains(6, 2, 3)
mc_0chains(6, 2, 3, list(matrix(1,              ncol=1, nrow=6)))
mc_0chains(6, 2, 3, list(matrix(c(1,0,0,0,0,0), ncol=1, nrow=6)))
mc_0chains(6, 2, 3, list(matrix(c(0,1,0,0,0,0), ncol=1, nrow=6)))
mc_0chains(6, 2, 3, list(matrix(c(0,0,0,0,0,1), ncol=1, nrow=6)))
mc_0chains(6, 2, 3, list(matrix(c(0,0,0,0,1,0), ncol=1, nrow=6)))

mc_0chains(2, 2, 2,list(matrix(c(0,1),ncol=1,nrow=2)))

mc_0chains(12,4,2)
</code></pre>

<hr>
<h2 id='mc_chain_extend'> Extend multi-companion eigenvectors </h2><span id='topic+mc_chain_extend'></span>

<h3>Description</h3>

<p>Extend Jordan chains of a multi-companion matrix to higher dimension
and complete them to a full system by adding eigenchains for zero
eigenvalues.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_chain_extend(ev, newdim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_chain_extend_+3A_ev">ev</code></td>
<td>

<p>eigenvalues and eigenvectors, a list with components <code>values</code>
and <code>vectors</code>.
</p>
</td></tr>
<tr><td><code id="mc_chain_extend_+3A_newdim">newdim</code></td>
<td>
<p> the new dimension of the vectors. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The eigenvectors of a multi-companion  matrix have a special
structure. This function extends the supplied eigenvectors to be
eigenvectors of a higher-dimensional multi-companion matrix of the
same multi-companion order with the same top rows extended with zeroes.
</p>
<p><code>ev</code> is a list with components <code>values</code>, <code>vectors</code> and
possibly others. In particular, <code>ev</code> may be the value returned by
a call to the base function <code>eigen()</code>.  A component
<code>len.block</code> may be used to specify the lengths of the Jordan
chains, by default all are of length one.
</p>
<p>The function handles also the case when only the first <code>mo.col</code>
columns of the top of the original multi-companion matrix are
non-zero. This may be specified by a component <code>mo.col</code> in
<code>ev</code>, otherwise <code>mo.col</code> is set to the dimension of the
space spanned by the non-zero eigenvalues.
</p>
<p>When <code>mo.col</code> is smaller than the multi-companion order, the
information in the eigenvectors is not sufficient to extend them. The
missing entries are supplied via the argument <code>F0bot</code>
(<strong>TODO: describe!</strong>).
</p>
<p>Chains corresponding to zero eigenvalues come last in the result.
</p>


<h3>Value</h3>

<p>The eigenvectors extended to the new dimension.
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>References</h3>


<p>Boshnakov GN (2002).
&ldquo;Multi-companion matrices.&rdquo;
<em>Linear Algebra Appl.</em>, <b>354</b>, 53&ndash;83.
ISSN 0024-3795, <a href="https://doi.org/10.1016/S0024-3795%2801%2900475-X">doi:10.1016/S0024-3795(01)00475-X</a>.
</p>
<p>Boshnakov GN, Iqelan BM (2009).
&ldquo;Generation of time series models with given spectral properties.&rdquo;
<em>J. Time Series Anal.</em>, <b>30</b>(3), 349&ndash;368.
ISSN 0143-9782, <a href="https://doi.org/10.1111/j.1467-9892.2009.00617.x">doi:10.1111/j.1467-9892.2009.00617.x</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mc_eigen">mc_eigen</a></code>;
</p>
<p>the main work is done by <code><a href="#topic+mC.non0chain.extend">mC.non0chain.extend</a></code> and
<code><a href="#topic+mc_0chains">mc_0chains</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ev &lt;- make_mcchains(eigval = c(1, 0.5), co = cbind(c(1,1), c(1, -1)), dim = 4,
              mo.col = 2,
              len.block = c(1, 1))
ev
## extend evecs in ev to the requested dim and complete with chains for eval 0.
mc_chain_extend(ev = ev, newdim = 6)
mc_chain_extend(ev = ev, newdim = 7)
</code></pre>

<hr>
<h2 id='mc_chain_scale'>Scale vectors in eigenchains of multi-companion matrices</h2><span id='topic+mc_chain_scale'></span>

<h3>Description</h3>

<p>Scale vectors in an eigenchain of a multi-companion matrix. Currently
the factor is determined so that the seeding coefficient with the
maximal value becomes equal to one. By default the seeding
coefficients at the bottom are examined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_chain_scale(ev, subset = NULL, fvec = NULL, fchain = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_chain_scale_+3A_ev">ev</code></td>
<td>

<p>the eigenvectors, a list with elements <code>"eigvec"</code>,
<code>"len.block"</code>.
</p>
</td></tr>


<tr><td><code id="mc_chain_scale_+3A_subset">subset</code></td>
<td>
<p>subset of the eigenvectors to examine, a string or a
vector of integers suitable for indexing.</p>
</td></tr>
<tr><td><code id="mc_chain_scale_+3A_fvec">fvec</code></td>
<td>
<p>a function for the computation of the normailising factor,
see Details.</p>
</td></tr>
<tr><td><code id="mc_chain_scale_+3A_fchain">fchain</code></td>
<td>
<p>can be used to specify a more general transformation, a
function, see Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All vectors in the chain are scaled by the same factor.
</p>
<p>The factor is determined so that the seeding coefficient with the
maximal modulus becomes equal to one. By default the seeding
coefficients at the bottom of the eigenvector are examined but if
argument <code>subset</code> is equal to &quot;top&quot; the tops are checked
instead. <code>subset</code> may also be a vector of integers to be used as
an index to select the desired subset.
</p>
<p>Argument <code>fvec</code> may be used to specify a method other than
modulus for the normalising factor. <code>fvec</code> is a function with two
arguments, the first being the eigenvector and the second the index
vector.
</p>
<p>Argument <code>fchain</code> may be used to specify a completely different
way to normailse the chain. <code>fchain</code> is a function with one
argument, <code>chain</code>, which can do any transformation of the chain.
</p>


<h3>Value</h3>

<p>a list as <code>ev</code> with the desired transformations done.
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>

<hr>
<h2 id='mc_chain_subset'>Internal utilities for mc eigenvectors</h2><span id='topic+mc_chain_subset'></span><span id='topic+mc_chain_merge'></span>

<h3>Description</h3>

<p>Utilities for manipulation of mc eigenchains:
subset, merge.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_chain_subset(ev, chainno)
mc_chain_merge(ev1, ev2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_chain_subset_+3A_ev">ev</code></td>
<td>
<p>eigensystem, a list, see details.</p>
</td></tr>
<tr><td><code id="mc_chain_subset_+3A_ev1">ev1</code></td>
<td>
<p>chain, a list.</p>
</td></tr>
<tr><td><code id="mc_chain_subset_+3A_ev2">ev2</code></td>
<td>
<p>chain, a list.</p>
</td></tr>
<tr><td><code id="mc_chain_subset_+3A_chainno">chainno</code></td>
<td>
<p>chains to extract, integer vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The lists representing eigensystems (<code>ev</code>, <code>ev1</code>,
<code>ev2</code>)  have the following structure:
</p>

<table>
<tr>
 <td style="text-align: left;">
    </td>
</tr>
<tr>
 <td style="text-align: left;"> 
        
    <code>mo</code> </td><td style="text-align: left;">  the multi-companion order,</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>mo.col</code> </td><td style="text-align: left;">  the mc column order,</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>eigval</code> </td><td style="text-align: left;">  a vector of eigenvalues containing one
                        entry for each chain,</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>len.block</code> </td><td style="text-align: left;">  a vector of chain lengths, <code>len.block[i]</code>
                           is the length of the chain </td>
</tr>
<tr>
 <td style="text-align: left;">
                     </td><td style="text-align: left;">  corresponding to <code>eigval[i]</code>,</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>eigvec</code> </td><td style="text-align: left;">  a matrix of generalised eigenvectors,</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>co</code> </td><td style="text-align: left;">  the seed parameters (always bottom?), a matrix.
  </td>
</tr>

</table>

<p>A chain with no elements is represented  by the empty list.
</p>
<p>If component <code>co</code> is non-NULL, it is processed as expected.  It
may also be NULL or absent. In that case it will be NULL in the result
returned by <code>mc_chain_subset</code>, similarly for <code>mc_chain_merge</code> but
since it has two arguments, see the details below.
</p>
<p><code>mc_chain_subset</code> takes a subsystem of <code>ev</code>, basically
<code>ev$eigval[chaino]</code>, etc, but catering also for the possibility
that some chains have length greater than one. <code>chainno</code> specifies
which chains to take (or omit) with the usual <span class="rlang"><b>R</b></span> index syntax.
</p>
<p><code>mc_chain_merge</code> concatenates the two chains.  If <code>co</code> is
NULL in both arguments, it is NULL in the result. Otherwise <code>co</code>
is set to the bottom parts of the vectors. Components <code>mo</code> and
<code>mo.col</code> in the two chains should be the same but currently this
is not checked.
</p>


<h3>Value</h3>

<p>for <code>mc_chain_subset</code> and <code>mc_chain_merge</code>, a list having
the same format as <code>ev1</code> and <code>ev2</code>
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+mc_chain_extend">mc_chain_extend</a></code>
</p>

<hr>
<h2 id='mc_chains_triangulate'>Triangulate a system of 0eigenvectors</h2><span id='topic+mc_chains_triangulate'></span>

<h3>Description</h3>

<p>Triangulate a system of 0eigenchains.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_chains_triangulate(chains, mo, mo.col)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_chains_triangulate_+3A_chains">chains</code></td>
<td>
<p> chains, see details </p>
</td></tr>
<tr><td><code id="mc_chains_triangulate_+3A_mo">mo</code></td>
<td>
<p> mc order </p>
</td></tr>
<tr><td><code id="mc_chains_triangulate_+3A_mo.col">mo.col</code></td>
<td>
<p> mc column order </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mc_chains_triangulate</code> triangulates a set of chains to make it easier
to extend 0chains.
</p>
<p><code>chains</code> is a  list of chains for the 0 eigenvalue of
an mcmatrix. Each chain is represented by a matrix with the eigenvector
in the first column.
</p>
<p>For a multi-companion matrix the maximum number of chains for an
eigenvalue  is <code>mo</code>.
</p>
<p>Only the last <code>mo</code> elements of eigenvectors of mc matrices
corresponding to the zero eigenvalue may be non-zero.
</p>
<p><code>mc_chains_triangulate</code> triangulates the eigenvectors in the following
sense. Let <code class="reqn">i_1</code> be the first non-zero element of the first
eigenvector. Then the elements in position <code class="reqn">i_1</code> of the remaining
eigenvectors are made equal to zero by adding to them a multiple of
the first eigenvector. The corresponding transformation is done on
the remaining elements of the chains so that they remain proper
chains. Then the position, <code class="reqn">i_2</code>, of the first non-zero element of
the second eigenvector is found and the elements of the third and the
following eigenvectors at that position are made zero by adding to them a
multiple of the second eigenvector. The process is repeated until the
last eigenvector is reached.
</p>
<p>If <code>mo</code> is 4 and there are 4 chains, for example, then the above
procedure will typically transform the bottom <code class="reqn">4\times4</code> block of the
matrix obtained from the 4 eigenvectors into a lower triangular
matrix. If there are zero elements in the original bottom
<code class="reqn">4\times4</code> block, then the result will not be a lower triangular
matrix but the shape will be equivalent for the purposes of extending
the eigenvectors.
</p>
<p>todo: describe the above precisely in a separate document,
vzh. rakopisnite belezhki za izpolzvaniya algoritam.
</p>
<p>todo: it is probably worth to do this somewhat more elaborately for
numerical stability.
</p>
<p>todo: This function is not specific to zero eigenchains.
It can be used to put in canonic order any other eigenchain (but
check).
Change the name?
</p>
<p>todo: strictly speaking, for canonical order more is needed when there
are chains with the same heights.
</p>


<h3>Value</h3>

<p>the  modified chains, a list
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+mc_0chains">mc_0chains</a></code> which call this function.
</p>

<hr>
<h2 id='mc_eigen'>The eigen decomposition of a multi-companion matrix</h2><span id='topic+mc_eigen'></span><span id='topic+mc_eigenvalues'></span>

<h3>Description</h3>

<p>Give the eigenvalues or the entire eigen decomposition of a
multi-companion matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_eigen(x, ...)
mc_eigenvalues(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_eigen_+3A_x">x</code></td>
<td>

<p>a multi-companion matrix, an object of class MultiCompanion.
</p>
</td></tr>
<tr><td><code id="mc_eigen_+3A_...">...</code></td>
<td>
<p>additional arguments, currently not used. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both functions first check if the decomposition is stored in
<code>x</code> and, if that is the case, return the result without
computations. This is particularly useful when the matrix is created
from its spectral decomposition in the first place. The only
restrictions on the result in this case come from the structure of
multi-companion matrices.
</p>
<p>Otherwise they use <code>eigen</code> to do the main computation. In
addition, if the top of the matrix has structural columns of zeroes,
<code>mc_eigen</code> takes care to call <code>eigen</code> with a sub-matrix
whose last column is not zero, and handles the zero eigenvalues
separately.
</p>
<p>Note that <code>x@mo.col</code> is the last column containing nonzero
elements in the top of the matrix. By calling <code>eigen</code> on the top
left <code>x@mo.col</code> square block, rather than on the entire matrix,
we achieve several things. Firstly, this block may turn out to be
non-singular. In that case, the chains corresponding to zero
eigenvalues, if any, are structural and straightforward. Secondly, if
this block turns out to be singular, we know that by reducing the
dimension we have left out only elements corresponding to zero
eigenvalues. The vectors associated with zero eigenvalues are somewhat
tricky in this case, but manageable.
</p>
<p>The net effect is that the only restriction comes from the use of
<code>eigen</code>, which does not handle Jordan chains of length larger
than one.  In general, this is not a problem, since chains with more
than one vector are not likely to occur numerically. In particular, it
is relatively safe to assume that the space spanned by the non-zero
eigenvalues of the multicompanion matrix has a basis of
eigenvectors. However, when <code>x@mo.col</code> is smaller than the
dimension of the matrix, eigenchains associated with the zero value
can easily occur, due to the structure of the matrix.  That is why we
pay special attention to them.
</p>
<p>In <code>mc_eigen</code> the handling of the zero eigenvalues is based on
<code><a href="#topic+mc_chain_extend">mc_chain_extend</a></code>.  The latter takes care also of zero
eigenvalues whose Jordan blocks are of size larger than one.
</p>


<h3>Value</h3>

<p>For <code>mc_eigenvalues</code>, the eigenvalues as a vector.
</p>
<p>For <code>mc_eigen</code>, the eigenvalues and eigenvectors as a list with
components <code>values</code> and <code>vectors</code>. In addition the list
contains a component <code>len.block</code> with the lengths of the Jordan
chains.
</p>


<h3>Note</h3>

<p><code>mc_eigenvalues</code> currently simply calls <code>eigen</code> if the
eigenvalues are not stored in the object. It is probably mostly useful
when the interest is in the nonzero eigenvalues.
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>References</h3>


<p>Boshnakov GN (2002).
&ldquo;Multi-companion matrices.&rdquo;
<em>Linear Algebra Appl.</em>, <b>354</b>, 53&ndash;83.
ISSN 0024-3795, <a href="https://doi.org/10.1016/S0024-3795%2801%2900475-X">doi:10.1016/S0024-3795(01)00475-X</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sim_mc(6,4,mo.col=2)
x
y &lt;- mCompanion(x,detect="gen")
y
z &lt;- as.matrix(y)
xx &lt;- mCompanion(x=z,mo.col=2)
mc_eigen(xx)
</code></pre>

<hr>
<h2 id='mc_factorize'> Factorise multi-companion matrices </h2><span id='topic+mc_factorize'></span><span id='topic+mc_leftc'></span>

<h3>Description</h3>

<p>Companion factorization of multi-companion matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_factorize(x, mo, mo.col)
mc_leftc(x, mo, mo.col)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_factorize_+3A_x">x</code></td>
<td>
<p> a multi-companion matrix or its top. </p>
</td></tr>
<tr><td><code id="mc_factorize_+3A_mo">mo</code></td>
<td>
<p> multi-companion order, number of structural top rows. </p>
</td></tr>
<tr><td><code id="mc_factorize_+3A_mo.col">mo.col</code></td>
<td>
<p> number of non-trivial columns in the top of the matrix. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The companion factorization of a multi-companion matrix, <code class="reqn">X</code>, of
(multi-companion) order <code class="reqn">p</code> is
<code class="reqn">X=A_1\times\cdots\times A_p</code>,
where <code class="reqn">A_i</code>, <code class="reqn">i=1,\dots,p</code>, are companion
matrices.
</p>
<p><code>mc_leftc</code> factorises a multi-companion matrix into a product
of companion times multi-companion.
</p>
<p><code>mc_factorize</code> calls <code>mc_leftc</code> a number of times to compute
the full factorisation.
</p>
<p>If <code>x</code> is not a matrix an attempt is made to convert it to
matrix. If <code>x</code> is a vector it is converted to a matrix with 1 row.
</p>
<p><code>x</code> may be the whole matrix or its top.
If <code>mo</code> is missing <code>x</code> is assumed to be the top of the
matrix and the multi-companion order is set to its number of rows.
</p>
<p><code>mo.col</code> defaults to the number of columns of <code>x</code>.
It is important to specify <code>mo.col</code> if there are columns of
zeroes in the top of the matrix. Otherwise the factorisation usually
fails with a message (from <code>solve</code>) that the system is exactly
singular. Note however that for objects of class MultiCompanion this
situation is handled automatically (unless the user overwrites the
default behaviour).
</p>


<h3>Value</h3>

<p>for <code>mc_factorize</code>, a matrix whose i-th row is the first row of
the i-th companion factor.
</p>
<p>for <code>mc_leftc</code>, a numeric vector containing the first row of the
companion factor. 
</p>


<h3>Level</h3>

<p>0</p>


<h3>Note</h3>

<p>The companion factorisation does not always exist but currently this
possibility is not handled. Even if it exists, it may be numerically
unstable.
</p>
<p>Also, if <code>mo.col</code> is smaller than the number of columns, then the
factorisation is not unique, the one having <code>mo.col</code> non-zero
entries is computed.   The existence is not treated.
</p>
<p><code>mc_leftc</code> is probably the first function I wrote for
multi-companion matrices. It does not do checks consistently. The
MultiCompanion class can be used here.
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>References</h3>


<p>Boshnakov GN (2002).
&ldquo;Multi-companion matrices.&rdquo;
<em>Linear Algebra Appl.</em>, <b>354</b>, 53&ndash;83.
ISSN 0024-3795, <a href="https://doi.org/10.1016/S0024-3795%2801%2900475-X">doi:10.1016/S0024-3795(01)00475-X</a>.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+mc_from_factors">mc_from_factors</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>mat2 &lt;- make_mcmatrix(eigval = c(1), co = cbind(c(1,1,1,1), c(0,1,0,0)), dim = 4, len.block = c(2))
mat2
eigen(mat2)
mc_leftc(mat2, mo = 4, mo.col = 2)
mCompanion(mat2)
mCompanion(mat2, mo=4, mo.col=2)
mc_leftc(mCompanion(mat2), mo = 4, mo.col = 2)
mc_eigen(mCompanion(mat2), mo = 4, mo.col = 2)
mc_eigen(mCompanion(mat2, mo=4, mo.col=2), mo = 4, mo.col = 2)
</code></pre>

<hr>
<h2 id='mc_factors'> Factors of multi-companion matrices </h2><span id='topic+mc_factors'></span>

<h3>Description</h3>

<p>Gives the factors comprising the companion factorisation of a
multi-companion matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_factors(x, what = "mc")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_factors_+3A_x">x</code></td>
<td>

<p>a multi-companion matrix, an object of class <code>MultiCompanion</code>.
</p>
</td></tr>
<tr><td><code id="mc_factors_+3A_what">what</code></td>
<td>
<p>format of the result, see below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the factors are available in the object's pad in the requested
format, they are returned without further processing.
The factors may be available if they have been previously computed or
if the matrix has been created from the factors.
</p>
<p>If the factors are available, but not in the requested format, they are
converted to it. Otherwise the factors are computed.
</p>
<p>The factors are stored in the object's pad under the name &quot;mC.factors&quot;
when <code>what == "mc"</code>, and in &quot;mC.factorsmat&quot; otherwise.
</p>


<h3>Value</h3>

<p>If <code>what == "mc"</code> the companion factors of <code>x</code> as a list of
<code>MultiCompanion</code> objects.
</p>
<p>Otherwise a matrix with i-th row representing the i-th factor.
</p>
<p>As a side effect, the factors are stored in the object's pad, see
&lsquo;Details&rsquo;.
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>References</h3>


<p>Boshnakov GN (2002).
&ldquo;Multi-companion matrices.&rdquo;
<em>Linear Algebra Appl.</em>, <b>354</b>, 53&ndash;83.
ISSN 0024-3795, <a href="https://doi.org/10.1016/S0024-3795%2801%2900475-X">doi:10.1016/S0024-3795(01)00475-X</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- mCompanion(matrix(1:8, nrow = 2))
mc_factors(m)
</code></pre>

<hr>
<h2 id='mc_from_factors'> Multi-companion matrix from factors </h2><span id='topic+mc_from_factors'></span><span id='topic+mc_from_filter'></span>

<h3>Description</h3>

<p>Compute a multi-companion matrix from its companion factors or from a
periodic filter. Create the multi-companion matrix corresponding to a
periodic filter by multiplying the relevant companion matrices in
reverse order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_from_factors(x)
mc_from_filter(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_from_factors_+3A_x">x</code></td>
<td>
<p> a matrix with a row for each companion factor, see details. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>x</code> is a matrix whose i-th row is the top row of the i-th
companion factor (for <code>mc_from_factors</code>) or the filter
coefficients for the i-th season (for <code>mc_from_filter</code>).
</p>
<p><code>mc_from_factors</code> is, effectively, the inverse of <code><a href="#topic+mc_factorize">mc_factorize</a></code>.
The companion matrices specified by the argument are multiplied.
</p>
<p><code>mc_from_filter</code> is similar except that the relevant companion
matrices are multiplied in reverse order. After all, it is natural to
have the coefficients for the i-th season in the i-th row!
</p>
<p>todo: add an argument to specify the &quot;first&quot; season.
</p>


<h3>Value</h3>

<p>The top of the resulting multi-companion matrix.
</p>


<h3>Level</h3>

<p>Currently <code>mc_from_factors</code> calls <code>mCompanion</code>, which it probably
should not do.</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>References</h3>


<p>Boshnakov GN (2002).
&ldquo;Multi-companion matrices.&rdquo;
<em>Linear Algebra Appl.</em>, <b>354</b>, 53&ndash;83.
ISSN 0024-3795, <a href="https://doi.org/10.1016/S0024-3795%2801%2900475-X">doi:10.1016/S0024-3795(01)00475-X</a>.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+mc_factorize">mc_factorize</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(1:8, nrow = 2)
mc_from_factors(x)
mCompanion(mc_from_factors(x))

mc_from_filter(x)
mCompanion(mc_from_filter(x))
</code></pre>

<hr>
<h2 id='mc_matrix'> Basic utilities for multi-companion matrices </h2><span id='topic+mc_matrix'></span><span id='topic+mc_full'></span><span id='topic+mc_order'></span><span id='topic+is_mc_bottom'></span>

<h3>Description</h3>

<p>Compute the dense matrix representation of a multi-companion matrix or
convert the argument to an ordinary matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_full(x)
mc_matrix(x)
mc_order(x)
is_mc_bottom(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_matrix_+3A_x">x</code></td>
<td>

<p>the top part of the multi-companion matrix or the whole matrix, see
Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mc_matrix</code> returns an ordinary matrix. It returns <code>x</code> if
<code>x</code> is an ordinary matrix (<code>is.matrix(x) == TRUE</code>), converts
<code>x</code> to a matrix with one row if <code>x</code> is a vector, and returns
<code>as.matrix(x)</code> otherwise. <code>mc_matrix</code> is used by some
functions in package <code>mcompanion</code> that want to allow flexible
format for the top of a multicompanion matrix or even the whole matrix
(e.g. <code>x</code> may be a <code>MultiCompanion</code> object) but are not
really multi-companion aware.
</p>
<p>For <code>mc_full</code>, <code>x</code> is normally the top part of a
multi-companion matrix. Rows are appended as necessary to obtain the
dense representation of the matrix and the result is guaranteed to be
a multi-companion matrix.  It is an error to have more rows than
columns.  If the number of rows is equal to the number of columns,
i.e. <code>x</code> is the whole matrix, the effect is that <code>x</code> is
converted to an ordinary matrix but no check is made to see if the
result is indeed a multi-companion matrix.
<code>x</code> may be a vector if the multi-companion order is 1.
</p>
<p>Give the multi-companion order of a square matrix
</p>
<p>Determine the multi-companion order of a square matrix or check if a
matrix may be the bottom part of a multi-companion matrix.
</p>
<p>In <code>mc_order(x)</code> should be a square matrix, while in
<code>is_mc_bottom(x)</code> the matrix is usually rectangular.
</p>
<p>The bottom part of a multi-companion matrix is of the form [I 0],
where I is an identity matrix and 0 is a matrix of zeroes. The top
consists of the rows above the bottom part.
The multi-companion order is the number of rows in the top of a
multi-companion matrix.
</p>
<p>Identity matrices have <code>mc_order</code> zero.
Other general matrices have <code>mc_order</code> equal to the number of
rows. In particular, an <code class="reqn">1\times1</code> matrix has <code>mc_order</code>
zero, if its only element is equal to one, and <code>mc_order</code> one
otherwise.
</p>
<p>Acordingly, <code>is_mc_bottom(x)</code> returns TRUE if <code>x</code> is the
identity matrix or a matrix with zero rows.  This is consistent with
the treatment of the identity matrix as multi-companion of multi order
0 and a general matrix as multi-companion of multi-companion order
equal to the number of its rows.
</p>


<h3>Value</h3>

<p>for <code>mc_full</code>, the multi-companion matrix as an ordinary dense
matrix object.
</p>
<p>For <code>mc_matrix</code>, an ordinary matrix.
</p>
<p>for <code>mc_order</code>, the multi-companion order of <code>x</code>, a
non-negative integer
</p>
<p>for <code>is_mc_bottom</code>, TRUE if <code>x</code> may be the bottom part of a
multi-companion matrix and FALSE otherwise.
</p>


<h3>Note</h3>

<p><code>mc_matrix</code> is not multi-companion specific, except that it
converts a vector to a matrix with one row (not column).  For square
matrices these functions are not really multi-companion specific.
</p>
<p>It may make sense to allow non-square matrices also for <code>mc_order</code>.
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>References</h3>


<p>Boshnakov GN (2002).
&ldquo;Multi-companion matrices.&rdquo;
<em>Linear Algebra Appl.</em>, <b>354</b>, 53&ndash;83.
ISSN 0024-3795, <a href="https://doi.org/10.1016/S0024-3795%2801%2900475-X">doi:10.1016/S0024-3795(01)00475-X</a>.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+mcStable">mcStable</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>mc &lt;- mCompanion("sim", dim = 4, mo = 2)
mc
mc_order(mc)
x &lt;- mc[1:2, ]   # the top of mc
x
x2 &lt;- mc[]      # whole mc as ordinary matrix
x2

mc_matrix(mc)
mc_matrix(x2)
## mc_matrix() doesn't append rows to its argument
mc_matrix(x)

## mc_full() appends rows, to make the matrix square multicompanion
mc_full(x)
## mc and x2 are square, so not amended:
mc_full(mc)
mc_full(x2)

## a vector argument is treated as a matrix with 1 row:
mc_matrix(1:4)
mc_full(1:4)
## mc_order(1:4) # not by mc_order


m &lt;- mCompanion(matrix(1:8, nrow = 2))
mc_matrix(m)
mc_order(m)

m[-c(1,2), ]
is_mc_bottom(m[-c(1,2), ]) # TRUE

## TRUE for reactangular diagonal matrix with nrow &lt; ncol
is_mc_bottom(diag(1, nrow = 3, ncol = 5))
## border cases
is_mc_bottom(matrix(0, nrow = 0, ncol = 4)) # TRUE, 0 rows
is_mc_bottom(diag(4))                       # TRUE, square diagonal matrix
</code></pre>

<hr>
<h2 id='mc.0chain.complete'> Extend or shrink eigenchains of 0 eigenvalues </h2><span id='topic+mc.0chain.complete'></span>

<h3>Description</h3>

<p>Takes a Jordan chain of the 0 eigenvalue of a multi-companion
matrix and modifies it to be a Jordan chain of a larger or smaller
multi-companion matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc.0chain.complete(dim, mo, chain, alt0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc.0chain.complete_+3A_dim">dim</code></td>
<td>
<p> the size of the new matrix, a number. </p>
</td></tr>
<tr><td><code id="mc.0chain.complete_+3A_mo">mo</code></td>
<td>
<p> the multi-companion order of the matrix.</p>
</td></tr>
<tr><td><code id="mc.0chain.complete_+3A_chain">chain</code></td>
<td>
<p> the chain from which the new chain is to be derived. </p>
</td></tr>
<tr><td><code id="mc.0chain.complete_+3A_alt0">alt0</code></td>
<td>
<p> optional alternative initialisation for the free
elements, see Details. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the number of rows of <code>chain</code> is larger than or equal to
<code>mo</code>, then <code>chain</code> represents a Jordan chain of the source
mc-matrix with the eigenvector is in the first column.
</p>
<p>Otherwise (if <code>nrow(chain) &lt; mo</code>) the number of rows is taken to
be <code>mo.col</code> and the Jordan chain is that of the top <code>mo.col
  x mo.col</code> corner. In this case, the chain is extended first to a chain
for the top left <code>mo x mo</code> corner. Argument <code>F0bot</code> allows
this to be accomplished. It provides the <code>[(mo.col+1):mo, 1:mo]</code>
block of the mc-matrix.
</p>
<p><code>dim</code> specifies the dimension of the modified matrix.
</p>
<p>The number of elements in the new chain may be different from the
original and the eigenvector may not be a shrunk version of the
original eigenvector.
</p>
<p>The new Jordan chain is returned as a matrix of <code>dim</code> rows and
number of columns determined automatically.
</p>
<p>When the new matrix is larger than the original, some of the elements
of the last vector in the new chain are arbitrary. By default these
elements are set to zero. Argument <code>alt0</code> can be used to change
this. It should be a vector of length <code>dim - nrow(chain)</code>.
</p>


<h3>Value</h3>

<p>a matrix
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- cbind(c(1,1), c(1,2))
j1 &lt;- diag(c(0.8, 0.5))
m1 &lt;- x1 %*% j1 %*% solve(x1)
bo1 &lt;- rbind(c(0.5, 0.8), c(0.256, 0.512))

j1a &lt;- diag(c(0, 0.5))
m1a &lt;- x1 %*% j1a %*% solve(x1)
f1a &lt;- cbind( rbind(m1a, bo1), 0, 0 )
</code></pre>

<hr>
<h2 id='mc.0chain.dx'>Extend chains for the top</h2><span id='topic+mc.0chain.dx'></span>

<h3>Description</h3>

<p>Extend 0chains of the top left corner to chains for the top left square
corner, internal function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc.0chain.dx(mo, mo.col, chF0top, F0bot, tol0 = 1e-12)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc.0chain.dx_+3A_mo">mo</code></td>
<td>
<p> mc order </p>
</td></tr>
<tr><td><code id="mc.0chain.dx_+3A_mo.col">mo.col</code></td>
<td>
<p> mc column order, must be less than <code>mo</code> </p>
</td></tr>
<tr><td><code id="mc.0chain.dx_+3A_chf0top">chF0top</code></td>
<td>
<p> 0chains of the top of the mc matrix, a list with one
matrix for each chain</p>
</td></tr>
<tr><td><code id="mc.0chain.dx_+3A_f0bot">F0bot</code></td>
<td>
<p> bottom of the top of the mc matrix, a matrix</p>
</td></tr>
<tr><td><code id="mc.0chain.dx_+3A_tol0">tol0</code></td>
<td>
<p> tolerance for declaring a vector to be 0 </p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each chain in <code>chF0top</code> there are two possibilities.  Let
<code class="reqn">v</code> be the eigenvector in the chain, i.e. <code>F0top</code> <code class="reqn">\times
  v=0</code>.  If <code>F0bot</code> <code class="reqn">\times v</code> is the zero vector,
then the corresponding chain for the larger matrix is obtained by
extending the vector to size <code>mo x mo</code> arbitrarily, most
naturally with 0s.  Otherwise, if <code>F0bot</code> <code class="reqn">\times v</code> is
not the zero vector, a new eigenvector is (0,...,0,<code>F0bot</code>
<code class="reqn">\times v</code>) (there are mo.col zeroes here) and the remaining
members of the chain are obtained from the given chain by
<code>...</code>. Notice that the eigenvector in <code>chF0top</code> (after
extension) becomes the second member of the resulting chain, etc.
</p>
<p>If the eigenvectors (0,...0,<code>F0bot</code> <code class="reqn">\times v_i</code>) are
linearly independent the job is done. But they may be linearly
dependent. If this is the case some of them need to be dropped and a
transformation is performed to obtain proper Jordan chains.
</p>


<h3>Value</h3>

<p>0chains for the top left <code>mo x mo</code> corner derived from <code>chF0top</code>
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+reduce_chains_simple">reduce_chains_simple</a></code>
</p>

<hr>
<h2 id='mc.0chain.struct'> Compute structural Jordan chains for zero eigenvalues </h2><span id='topic+mc.0chain.struct'></span>

<h3>Description</h3>

<p>Compute structural Jordan chains for zero eigenvalues,
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc.0chain.struct(dim, mo, mo.col, chains = list(), sort = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc.0chain.struct_+3A_dim">dim</code></td>
<td>
<p> dimension of the mc-matrix, a positive integer </p>
</td></tr>
<tr><td><code id="mc.0chain.struct_+3A_mo">mo</code></td>
<td>
<p> multi-companion order</p>
</td></tr>
<tr><td><code id="mc.0chain.struct_+3A_mo.col">mo.col</code></td>
<td>
<p> top order </p>
</td></tr>
<tr><td><code id="mc.0chain.struct_+3A_chains">chains</code></td>
<td>
<p>a list of Jordan chains for zero eigenvalues</p>
</td></tr>
<tr><td><code id="mc.0chain.struct_+3A_sort">sort</code></td>
<td>

<p>if TRUE sort the chains in descending order of their lengths.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Structural Jordan chains for 0 eigenvalues are present when
<code>mo.col &lt; dim</code>.
</p>
<p>If <code>chains</code> is empty, then this function assumes that the
structural chains span the space corresponding to 0 eigenvalues
(equivalently, the <code>mo.col x mo.col</code> principal submatrix is of
full rank).
</p>
<p>Otherwise, the chains given by <code>chains</code> are amended with the
structural chains. The given chains are usually changed in the
process. (Actually, <code>mc.0chain.struct</code> doesn't change existing
chains. It only adds new ones if needed, since it assumes that
triangulation has already been done.)
</p>
<p>Note that a multi-companion matrix cannot have more than <code>mo</code>
chains corresponding to an eigenvalue. In particular, it is not
appropriate to ignore the possibility for chains of length larger than
1, as is normal in numerical computations, see the references for
details.
</p>


<h3>Value</h3>

<p>a list with with the following components:
</p>
<table>
<tr><td><code>eigval</code></td>
<td>
<p>the eigenvalues (all 0 here), one for each chain</p>
</td></tr>
<tr><td><code>len.block</code></td>
<td>
<p>the lengths of the  chains</p>
</td></tr>
<tr><td><code>chains</code></td>
<td>
<p> a list with one element (a matrix) for each Jordan chain</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The more obscure particular cases need testing.
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+mc_0chains">mc_0chains</a></code> which calls this function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y742t &lt;- mc.0chain.struct(7, 4, 2) # sort = TRUE is default
y742f&lt;- mc.0chain.struct(7, 4, 2, sort = FALSE)

o &lt;- order(y742f[[2]], decreasing = TRUE)
y742fa &lt;- lapply(y742f, function(x) x[o])
stopifnot(identical(y742t, y742fa))
</code></pre>

<hr>
<h2 id='mc.0chain.structfill'>Add structural vectors to a 0eigenchain, internal function</h2><span id='topic+mc.0chain.structfill'></span>

<h3>Description</h3>

<p>Add structural (generalised) eigenvectors to a 0eigenchain, if possible.
These are vectors that do not depend on the  elements in the
non-trivial part of the mc matrix. In particular, their first mo.col
elements are zeroes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc.0chain.structfill(mo, mo.col, chain, v0 = rep(0, mo))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc.0chain.structfill_+3A_mo">mo</code></td>
<td>
<p> mc order</p>
</td></tr>
<tr><td><code id="mc.0chain.structfill_+3A_mo.col">mo.col</code></td>
<td>
<p> mc column order</p>
</td></tr>
<tr><td><code id="mc.0chain.structfill_+3A_chain">chain</code></td>
<td>

<p>a matrix with the eigenvector in the first column and successive
generalised eigenvectors in the following columns.  A vector may
stand for a matrix with one column.
</p>
</td></tr>
<tr><td><code id="mc.0chain.structfill_+3A_v0">v0</code></td>
<td>
<p> vector to use as bottom of  the new vectors</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The size of the matrix is deduced from the length of the vector(s) in
<code>chain</code>.
</p>
<p>Structural chains associated with the zero eigenvalue appear when
<code>mo.col</code> is smaller than the dimension of the matrix. Such chains
do not depend on the actual values in the non-structural part of the
matrix. As such they are the same when the size, multi-companion order
and <code>mo.col</code> are fixed. If the  core of the matrix is singular
the structural chains do not describe  completely the space
associated with the zero eigenvalue.
</p>
<p>It is quite straight-forward to generate a structural chain associated
with a given eigenvector or to complete a partially given
chain. However, no attempt is made to check if the supplied chain may
indeed be the beginning of a structural chain.  Such a check is
straightforward but is not implemented since the function is internal
and is called  only by functions that know (hopefully) what they are
doing.
</p>


<h3>Value</h3>

<p>the  chain, possibly appended with additional vectors
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>

<hr>
<h2 id='mC.non0chain.extend'> Extend multi-companion eigenvectors(non0) </h2><span id='topic+mC.non0chain.extend'></span>

<h3>Description</h3>

<p>Extend eigenchains corresponding to non-zero eigenvalues
of a multi-companion matrix to higher dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mC.non0chain.extend(ev, newdim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mC.non0chain.extend_+3A_ev">ev</code></td>
<td>
<p> eigenvalues and eigenvectors, a list with components ???
(as in <code>mc_chain_subset</code>, etc)  </p>
</td></tr>
<tr><td><code id="mC.non0chain.extend_+3A_newdim">newdim</code></td>
<td>
<p> the new dimension of the vectors</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The eigenvectors of a multi-companion  matrix have a special
structure. This function extends the supplied eigenvectors to be
eigenvectors of a higher-dimensional multi-companion matrix of the
same multi-companion order with the same top rows extended with zeroes.
</p>
<p>The function handles also the case when only the first <code>mo.col</code>
columns of the top of the original multi-companion matrix are
non-zero. This may be specified by a component <code>mo.col</code> in
<code>ev</code> (otherwise <code>mo.col</code> is set to the number of
eigenvalues).
</p>
<p>A component <code>len.block</code> of <code>ev</code> may be used to specify
lengths of the Jordan chains, the default is 1.
</p>
<p>When <code>mo.col</code> is smaller than the multi-companion order, the
information in the eigenvectors is not sufficient to extend them. The
missing entries must  be supplied via the argument <code>x0</code>.
</p>


<h3>Value</h3>

<p>The eigenvectors extended to the new dimension.
</p>


<h3>Note</h3>

<p>This is mostly internal function. The user function is <code>mc_chain_extend</code>.</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

 <p><code><a href="#topic+mc_chain_extend">mc_chain_extend</a></code></p>

<hr>
<h2 id='mCompanion'> Create objects from class MultiCompanion </h2><span id='topic+mCompanion'></span><span id='topic+initialize+2CMultiCompanion-method'></span>

<h3>Description</h3>

<p>Create, generate, or simulate objects from class <code>"MultiCompanion"</code> by
specifying the matrix in several ways.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mCompanion(x, detect = "nothing", misc = list(), ...)

## S4 method for signature 'MultiCompanion'
initialize(.Object, xtop, mo, n, mo.col, ido, x, dimnames,
           detect = "nothing", misc = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mCompanion_+3A_x">x</code></td>
<td>

<p>the matrix or, for <code>mCompanion</code> only, the top of the
matrix or a character string, see section &lsquo;Details&rsquo;.
</p>
</td></tr>
<tr><td><code id="mCompanion_+3A_misc">misc</code></td>
<td>

<p>information to be stored in the object's pad.
</p>
</td></tr>
<tr><td><code id="mCompanion_+3A_...">...</code></td>
<td>

<p>other arguments to be passed down to generator functions, see
section &lsquo;Details&rsquo;.
</p>
</td></tr>
<tr><td><code id="mCompanion_+3A_xtop">xtop</code></td>
<td>
<p> the top of the matrix. </p>
</td></tr>
<tr><td><code id="mCompanion_+3A_mo">mo</code></td>
<td>
<p> the multi-companion order of the matrix. </p>
</td></tr>
<tr><td><code id="mCompanion_+3A_n">n</code></td>
<td>
<p> the dimension. </p>
</td></tr>
<tr><td><code id="mCompanion_+3A_mo.col">mo.col</code></td>
<td>

<p>the top order, meaniing that columns mo.col+1,...,n of the top of
the matrix are zeros. <code>mo.col</code> may also be set to &quot;detect&quot;, in
which case it is determined by scanning <code>xtop</code> or <code>x</code>.
</p>
</td></tr>
<tr><td><code id="mCompanion_+3A_ido">ido</code></td>
<td>
<p> the dimension of the identity sub-matrix. </p>
</td></tr>
<tr><td><code id="mCompanion_+3A_dimnames">dimnames</code></td>
<td>
<p> is not used currently. </p>
</td></tr>
<tr><td><code id="mCompanion_+3A_detect">detect</code></td>
<td>

<p>controls whether automatic detection of <code>mo</code> and <code>mo.col</code>
should be attempted. The values tested are &quot;mo&quot;, &quot;mo.col&quot;, &quot;all&quot;,
and &quot;nothing&quot; with obvious meanings.
</p>
</td></tr>
<tr><td><code id="mCompanion_+3A_.object">.Object</code></td>
<td>
<p>this is set implicitly by package &quot;methods&quot;. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Objects from class <code>"MultiCompanion"</code> can be created by calling
<code>mCompanion()</code> or <code>new("MultiCompanion", ...)</code>. In the
latter case the &ldquo;...&rdquo; arguments are as for the
<code>initialize</code> method, except <code>.Object</code>. Do not call
<code>initialize</code> directly.
</p>
<p><code>mCompanion</code> can generate multi-companion matrices from spectral
information, full or partial, using the methodology developed by
Boshnakov and Iqelan (2009). If the
specification is not given in full, the missing information is filled
with suitably simulated values. For example, unspecifies eigenvalues
are generated inside the unit circle, <code><a href="#topic+sim_mc">sim_mc</a></code>.
</p>
<p>If argument <code>x</code> is the string &quot;sim&quot; or &quot;gen&quot;, then
<code>mCompanion</code> calls <code><a href="#topic+sim_mc">sim_mc</a></code> or
<code><a href="#topic+make_mcmatrix">make_mcmatrix</a></code>, respectively, with the arguments
<code>...</code> and converts the result to class MultiCompanion.  See the
documentation of those functions for further details and examples.
The conversion may be the main reason to use <code>mCompanion</code> in this
way rather than call <code>sim_mc</code> and <code>make_mcmatrix</code> directly.
</p>
<p>Otherwise, if <code>x</code> is numeric it is taken to specify the top of
the matrix unless <code>detect="mo"</code> in which case it is the whole
matrix.  In both cases all arguments are passed down to <code>new</code>, the
only (more or less) change being that <code>x</code> is passed down as
<code>xtop=x</code> and <code>x=x</code>, respectively, see
<code><a href="#topic+MultiCompanion-class">MultiCompanion</a></code>.

</p>
<p><code>detect=="gen"</code> signifies that <code>x</code> has the format of the
output from <code>sim_mc</code> or <code>make_mcmatrix</code>, so that <code>mCompanion</code>
may use the additional information in such objects.
</p>
<p>The multi-companion order is determined automatically from the content
of the matrix if <code>detect=="mo"</code>.
</p>


<h3>Value</h3>

<p>a multi-companion matrix, an object of class <code>"MultiCompanion"</code>
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>References</h3>


<p>Boshnakov GN (2002).
&ldquo;Multi-companion matrices.&rdquo;
<em>Linear Algebra Appl.</em>, <b>354</b>, 53&ndash;83.
ISSN 0024-3795, <a href="https://doi.org/10.1016/S0024-3795%2801%2900475-X">doi:10.1016/S0024-3795(01)00475-X</a>.
</p>
<p>Boshnakov GN (2007).
&ldquo;Singular value decomposition of multi-companion matrices.&rdquo;
<em>Linear Algebra Appl.</em>, <b>424</b>(2-3), 393&ndash;404.
ISSN 0024-3795, <a href="https://doi.org/10.1016/j.laa.2007.02.010">doi:10.1016/j.laa.2007.02.010</a>.
</p>
<p>Boshnakov GN, Iqelan BM (2009).
&ldquo;Generation of time series models with given spectral properties.&rdquo;
<em>J. Time Series Anal.</em>, <b>30</b>(3), 349&ndash;368.
ISSN 0143-9782, <a href="https://doi.org/10.1111/j.1467-9892.2009.00617.x">doi:10.1111/j.1467-9892.2009.00617.x</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim_mc">sim_mc</a></code>,
<code><a href="#topic+make_mcmatrix">make_mcmatrix</a></code>,
<code><a href="#topic+MultiCompanion-class">MultiCompanion</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate a 6x6 mc matrix with 2 non-trivial rows
mCompanion("sim", dim = 4, mo = 2)
# simulate a 6x6 mc matrix with 4 non-trivial rows
mCompanion("sim", dim = 6, mo = 4)
# similar to above but top rows with 2 non-zero columns
mCompanion("sim", dim = 6, mo = 4, mo.col = 2)

## specify the non-trivial top rows (as a matrix):
m1 &lt;- matrix(1:24, nrow = 4)
mCompanion(m1)            # mc matrix with m1 on top

m2 &lt;- rbind(c(1, 2, 0, 0), c(3, 4, 0, 0))
x2a &lt;- mCompanion(m2)     # mc matrix with m2 on top
x2a@mo.col                #  = 4

x2 &lt;- mCompanion(m2, mo.col = "detect")
x2@mo.col                #  = 2,  detects the 0 columns in m2
mCompanion(m2, mo.col = 2)  # same

# create manually an mc matrix
(m3 &lt;- rbind(m1, c(1, rep(0, 5)), c(0, 1, rep(0, 4))))
# turn it into a MultiCompanion object
x3 &lt;- mCompanion(x = m3, detect = "mo")
x3@mo
x3 &lt;- mCompanion(m3)
x3@mo

m4 &lt;- rbind(c(1, 2, rep(0, 4)), c(3, 4, rep(0, 4)))

x4 &lt;- mCompanion(m4, mo = 2)
x4@mo.col    #  = 6,
## special structure not incorporated in x4,
##   eigen and mc_eigen are equiv. in this case
eigen(x4)
mc_eigen(x4)

x4a &lt;- mCompanion(m4, mo = 2, mo.col = 2)
x4a@mo.col    #  = 2,  has Jordan blocks of size &gt; 1
## the eigenvectors do not span the space:
eigen(x4a)
## mc_eigen exploits the Jordan structure, e.g.2x2 Jordan blocks,
## and gives the generalised eigenvectors:
(ev &lt;- mc_eigen(x4a))

x4a %*% ev$vectors

## construct the Jordan matrix of x4a from eigenvalues and eigenvectors
(x4a.j &lt;- Jordan_matrix(ev$values,  ev$len.block))

## check that AX = XJ and A = XJX^-1, up to numerical precision:
x4a %*% ev$vectors  -  ev$vectors %*% x4a.j
x4a  -  ev$vectors %*% x4a.j %*% solve(ev$vectors)
</code></pre>

<hr>
<h2 id='mcSpec'>Generate objects of class mcSpec</h2><span id='topic+mcSpec'></span><span id='topic+initialize+2CmcSpec-method'></span>

<h3>Description</h3>

<p>Generate objects of class mcSpec.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcSpec(...)

## S4 method for signature 'mcSpec'
initialize(.Object, dim, mo, root1 = numeric(0), iorder = 0,
           siorder = 0, order = rep(dim, mo), evtypes = NULL,
           mo.col = NULL, n.roots = mo.col, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcSpec_+3A_dim">dim</code></td>
<td>
<p>the dimension, a positive integer.</p>
</td></tr>
<tr><td><code id="mcSpec_+3A_mo">mo</code></td>
<td>
<p>multi-companion order, a.k.a. number of seasons.</p>
</td></tr>
<tr><td><code id="mcSpec_+3A_root1">root1</code></td>
<td>
<p>roots equal to one, a vector of positive integers of
length at most <code>mo</code>.</p>
</td></tr>
<tr><td><code id="mcSpec_+3A_iorder">iorder</code></td>
<td>
<p>integration order, a non-negative integer.</p>
</td></tr>
<tr><td><code id="mcSpec_+3A_siorder">siorder</code></td>
<td>
<p>seasonal integration order, a non-negative integer.</p>
</td></tr>
<tr><td><code id="mcSpec_+3A_order">order</code></td>
<td>
<p>order of the periodic filter, a vector of length
<code>mo</code>.</p>
</td></tr>
<tr><td><code id="mcSpec_+3A_evtypes">evtypes</code></td>
<td>
<p>types of additional eigenvalues, see Details.</p>
</td></tr>
<tr><td><code id="mcSpec_+3A_mo.col">mo.col</code></td>
<td>
<p>number of non-zero columns in the top part of the
multicompanion matrix, see Details.</p>
</td></tr>
<tr><td><code id="mcSpec_+3A_n.roots">n.roots</code></td>
<td>
<p>number of non-zero roots</p>
</td></tr>
<tr><td><code id="mcSpec_+3A_...">...</code></td>
<td>
<p>further arguments to be passed on.</p>
</td></tr>
<tr><td><code id="mcSpec_+3A_.object">.Object</code></td>
<td>
<p>An object. This argument is not used in calls of
<code>mcSpec</code> and <code>new</code>, see the details section.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mcSpec(...)</code> and <code>new("mcSpec", ...)</code> create objects from
class <code>mcSpec</code>. The two calls are equivalent and may contain any
of the arguments of the initialize method described here, except
<code>.Object</code> which is generated automatically.
In both cases the initialize method is called and passed all the
arguments.
</p>
<p>Several ways are provided for the specification of unit roots and they
may be combined, as long as the specification is consistent.
</p>
<p><code>roots1</code> specifies eigenvalues equal to 1 and the size of their
Jordan chains. <code>iorder</code> and <code>siorder</code> provide convenient
shortcuts for the special cases which they cover.
</p>
<p><code>iorder</code> specifies the integration order. This corresponds to
operator <code class="reqn">(1-B)</code> applied <code>iorder</code> times.
</p>
<p>Similarly, <code>siorder</code> specifies the seasonal integration order,
which corresponds to the operator <code class="reqn">(1-B^s)</code> applied <code>siorder</code>
times, where <code class="reqn">s</code> is equal to <code>mo</code>. This argument generates
<code>mo</code> unit roots, each of height (dimension of its Jordan chain)
<code>siorder</code>.
</p>
<p>It is possible to use combinations of these arguments to specify the
unit roots and all specifications are combined. Care must be taken not
to exceed <code>dim</code>.
</p>
<p>If <code>mo.col</code> is missing, it is set to <code>max(order)</code>.
<code>mo.col</code> may also be the character string &quot;+ones&quot;. In this case
the dimension of the unit roots is added to <code>max(order)</code>.
<code>mo.col</code> may also be set directly by giving it an appropriate
integer value. <strong>TODO: Need more checks for consistency here!</strong>
</p>
<p><strong>TODO:</strong> describe other roots and eigenvectors!
</p>
<p>After all specified quantities are prepared, the rest are set to NA's.
</p>
<p>If not all eigenvalues are specified, additional eigenvalues are
introduced to reach dimension <code>dim</code>. By default, if an even
number of eigenvalues is needed, all of them are specified as complex
pairs, &quot;cp&quot;. If the number is odd, one real eigenvalue is specified
and the rest are set again to &quot;cp&quot;.
</p>
<p>Argument <code>evtypes</code> can be used to select a different setting for
the additional eigenvalues.  It is a character vector in which &quot;r&quot;
stands for real eigenavalues and &quot;cp&quot; stands for a complex pair. For
example, if there are two &quot;free&quot; eigenvalues, the automatic choice
would be a complex pair, &quot;cp&quot;. If two real eigenvalues are desired set
<code>evtypes</code> to <code>c("r","r")</code>.
</p>
<p>Note: <code>evtypes</code> is for types of additional eigenvalues. Do not
specify types for eigenvalues equal to one or zero.
</p>


<h3>Value</h3>

<p>an object of class <code>mcSpec</code>
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>References</h3>

<p>Boshnakov GN (2002).
&ldquo;Multi-companion matrices.&rdquo;
<em>Linear Algebra Appl.</em>, <b>354</b>, 53&ndash;83.
ISSN 0024-3795, <a href="https://doi.org/10.1016/S0024-3795%2801%2900475-X">doi:10.1016/S0024-3795(01)00475-X</a>.
</p>
<p>Boshnakov GN, Iqelan BM (2009).
&ldquo;Generation of time series models with given spectral properties.&rdquo;
<em>J. Time Series Anal.</em>, <b>30</b>(3), 349&ndash;368.
ISSN 0143-9782, <a href="https://doi.org/10.1111/j.1467-9892.2009.00617.x">doi:10.1111/j.1467-9892.2009.00617.x</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcSpec-class">mcSpec-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spec2 &lt;- mcSpec(21, 4, siorder=2, iorder=1)
spec4 &lt;- mcSpec(11, 4, siorder=1, iorder=1)
spec.co2 &lt;- mcSpec(dim = 5, mo = 4, siorder = 1)
spec.co2new &lt;- mcSpec(dim = 5, mo = 4, siorder = 1) # after correcting ev.arg
spec.co2alt &lt;- mcSpec(dim = 6, mo = 4, siorder = 1)

spec.co3 &lt;- mcSpec(dim = 5, mo = 4, root1 = c(1,1,1))

spec.coz1 &lt;- mcSpec(dim = 4, mo = 4, root1 = c(1,1), order = rep(2,4)) # test0 roots
spec.coz2 &lt;- mcSpec(dim = 5, mo = 4, root1 = c(1,1), order = rep(2,4)) # test0 roots
spec.coz3 &lt;- mcSpec(dim = 4, mo = 4, root1 = c(1), order = rep(2,4)) # test0 roots
spec.co4 &lt;- mcSpec(dim = 4, mo = 4, root1 = c(1,1,1))
</code></pre>

<hr>
<h2 id='mcSpec-class'>A class for spectral specifications of multi-companion matrices</h2><span id='topic+mcSpec-class'></span>

<h3>Description</h3>

<p>A class for spectral specifications of multi-companion matrices.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of one of the following equivalent
forms:
</p>

<ul>
<li>
<p><code>mcSpec(dim, mo, root1, iorder, siorder, order, evtypes, ...)</code>,
</p>
</li>
<li>
<p><code>new("mcSpec", dim, mo, root1, iorder, siorder, order, evtypes, ...)</code>.
</p>
</li></ul>


<p>An object of class &quot;mcSpec&quot; holds a spectral specification of a square
multi-companion matrix. The specification may be only partial. In that
case unspecified components are set to <code>NA</code>.
</p>
<p>Eigenvalues are represented by their modulus and complex argument. The
argument is in cycles per unit time. So, a negative real number has
argument 0.5.
</p>
<p>The complex eigenvalues come in pairs and only one needs to be
specified. If an eigenvalue is not simple, it should not be
repeated. Rather, the size of the corresponding Jordan
block should be specified.
</p>
<p>The types of the eigenvalues may be &quot;r&quot; (real) or &quot;cp&quot; (complex
pair).
</p>
<p>See <code><a href="#topic+mcSpec">mcSpec</a></code> for full details about the initialization
function for class <code>mcSpec</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>dim</code>:</dt><dd><p>dimension of the matrix, a positive integer.</p>
</dd>
<dt><code>mo</code>:</dt><dd><p>multi-companion order, a positive integer.</p>
</dd>
<dt><code>ev.type</code>:</dt><dd><p>Types of eigenvalues, &quot;r&quot; or &quot;cp&quot;, a
character vector.
</p>
</dd>
<dt><code>co.type</code>:</dt><dd><p>Types of the <code>co</code> parameters, a
character vector.
</p>
</dd>
<dt><code>order</code>:</dt><dd><p>orders of the factors, the default is
<code>rep(dim,mo)</code>.
</p>
</dd>
<dt><code>n.root</code>:</dt><dd><p>number of nonzero roots.</p>
</dd>
<dt><code>ev.abs</code>:</dt><dd><p>absolute values (moduli) of the roots.</p>
</dd>
<dt><code>ev.arg</code>:</dt><dd><p>complex arguments of the roots (cycles per
unit time). In particular, zero for positive reals, 0.5 for
negative reals. (<strong>TODO:</strong> check that functions that use this
specification know that!)
</p>
</dd>
<dt><code>block.length</code>:</dt><dd><p>sizes of Jordan blocks corresponding to
the eigenvalues, a vector of positive integers. By default the
eigenvalues are simple.
</p>
</dd>
<dt><code>co.abs</code>:</dt><dd><p>moduli of the <code>co</code> parameters, a matrix.</p>
</dd>
<dt><code>co.arg</code>:</dt><dd><p>arguments of the <code>co</code> parameters, a
matrix.
</p>
</dd>
<dt><code>mo.col</code>:</dt><dd>
<p>Object of class <code>"numeric"</code>.
</p>
</dd>
<dt><code>F0bot</code>:</dt><dd>
<p>Object of class <code>"optionalMatrix"</code>.
</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>initialize</dt><dd><p><code>signature(.Object = "mcSpec")</code>:
see <code><a href="#topic+mcSpec">mcSpec</a></code>.
</p>
</dd>
</dl>



<h3>Note</h3>

<p>The initialization function for <code>mcSpec</code> class is incomplete, in
the sense that it does not cover all cases.
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcSpec">mcSpec</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mcSpec(dim = 5, mo = 4, root1 = c(1,1), order = rep(3,4))
mcSpec(dim = 5, mo = 4, root1 = c(1,1,1), order = rep(5,4))
mcSpec(dim = 5, mo = 4, root1 = c(1,1,1,1), order = rep(5,4))
</code></pre>

<hr>
<h2 id='mcStable'> Check if an object is stable </h2><span id='topic+mcStable'></span><span id='topic+mcStable-methods'></span>

<h3>Description</h3>

<p>Check if an object is stable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcStable(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcStable_+3A_x">x</code></td>
<td>
<p> the object to be checked </p>
</td></tr>
</table>


<h3>Details</h3>

<p>A stable matrix is a matrix all of whose eigenvalues have moduli less
than one. Other objects are stable if the associated matrix is
stable.
</p>
<p>This is a generic function. The default method works as follows.
<code>x</code> is a square matrix, the method checks if its eigenvalues
satisfy the stability condition and returns the result.
</p>
<p>Otherwise, if <code>x</code> is a rectangular matrix with more columns than
rows, it is assumed to be the top of a multi-companion matrix. If
<code>x</code> is a vector, it is assumed to represent the top row of a
companion matrix. In all other cases <code>x</code> is converted to matrix
with <code>as.matrix(x)</code>. The result should be a square matrix whose
eigenvalues are checked.
It is an error for the matrix to have more rows than columns.
</p>


<h3>Value</h3>

<p>TRUE if the object is stable and  FALSE otherwise
</p>


<h3>Note</h3>

<p>An argument <code>...</code> may be a good idea since methods may wish to
provide options. For example, for continuous
time systems, the stability condition is that the real parts of the
eigenvalues are negative.
</p>
<p>For example, an option to choose the left half-plane for the stable
region, instead of the unit circle, would handle stability for
continuous time systems.
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a simulated matrix (it is stable by default)
mc &lt;- mCompanion("sim", dim=4, mo=2)
mcStable(mc)

## a square matrix
m &lt;- matrix(1:9, nrow=3)
eigen(m)$values
mcStable(m)

## a 2x4 matrix, taken to be the top of an mc matrix
m &lt;- matrix(1:8, nrow=2)
mcStable(m)
mCompanion(m)

## a vector, taken to be the top row of an mc matrix
v &lt;- 1:4
mcStable(v)
mCompanion(v)
abs(mc_eigen(mCompanion(v))$values)

co1 &lt;- cbind(c(1,1,1,1), c(0,1,0,0))

## a matrix with eigenvalues equal to 1
mat2 &lt;- make_mcmatrix(eigval = c(1), co = co1, dim = 4, len.block = c(2))
## mat2 is ordinary matrix, eigenvalues are computed numerically
eigen(mat2)
mcStable(mat2)  # FALSE but in general depends on floating point arithmetic

mat2a &lt;- mCompanion(x="gen", eigval = c(1), co = co1, dim = 4, len.block = c(2), what.res = "list")
mc_eigen(mat2a)
mcStable(mat2a)


mat2b0 &lt;- make_mcmatrix(eigval = c(1), co = co1, dim = 4, len.block = c(2), what = "list")
mat2b &lt;- mCompanion(mat2b0, "gen")
mc_eigen(mat2b)
mcStable(mat2b)

## mat2c is a MultiCompanion object with the eigenvalues stored in it
mat2c &lt;- mCompanion(x="sim", eigval = c(1,0,0), co = cbind(co1, c(0,0,1,0), c(0,0,0,1)),
                    dim = 4, len.block = c(2,1,1))
mat2c
## since the eigenvalues are directly available here, no need to compute them
mc_eigen(mat2c) # contains a 2x2 Jordan block.
mcStable(mat2c)
</code></pre>

<hr>
<h2 id='mf_VSform'> Extract properties of multi-filters </h2><span id='topic+mf_order'></span><span id='topic+mf_period'></span><span id='topic+mf_poles'></span><span id='topic+mf_VSform'></span>

<h3>Description</h3>

<p>Extract properties for scalar and vector of seasons forms of multi-filters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mf_order(x, i = "max", form = "pc", perm)
mf_period(x)
mf_poles(x, blocks = FALSE)
mf_VSform(x, first = 1, form = "U", perm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mf_VSform_+3A_x">x</code></td>
<td>
<p> the filter, an object of class  <code>"MultiFilter"</code>.</p>
</td></tr>
<tr><td><code id="mf_VSform_+3A_i">i</code></td>
<td>
<p> index, integer vector or a string. </p>
</td></tr>
<tr><td><code id="mf_VSform_+3A_first">first</code></td>
<td>
<p>the first season of the year.</p>
</td></tr>
<tr><td><code id="mf_VSform_+3A_form">form</code></td>
<td>

<p>the form of the filter to which the result refers,
one of &quot;pc&quot;, &quot;I&quot;, &quot;U&quot;, or &quot;L&quot;, see Details.
</p>
</td></tr>
<tr><td><code id="mf_VSform_+3A_perm">perm</code></td>
<td>
<p>permutation of the seasons within the year.</p>
</td></tr>
<tr><td><code id="mf_VSform_+3A_blocks">blocks</code></td>
<td>
<p> request lengths of Jordan chains.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With the default <code>i=="max"</code> the function <code>mf_order</code> returns
a single number, the order of the filter in the representation
requested by <code>form</code>.
The orders of the components may be obtained with the setting
<code>i=="all"</code> which gives a vector whose j-th element is the order
of the j-th component of the filter. A subset of these may be obtained
with numeric <code>i</code> which is treated as standard index vector.
Values for <code>i</code> other than the default are meaningful mainly for
<code>form="pc"</code>.
</p>
<p><code>mf_VSform</code> arranges the filter coefficients in one of the vector
of seasons forms (todo: cite me). The component <code>Phi</code> of the
result is a matrix obtained by putting the coefficient matrices next
to each other, [A1 ... Ad].  If <code>perm</code> is provided, then the
result is the same for &quot;U&quot; and &quot;L&quot;.
</p>
<p><code>mf_VSform</code> is called implicitly by the subscripting operation
(&quot;[&quot;) when needed, it is more flexible and is recommended for general
use.
</p>
<p>For the vector forms (&quot;I&quot;, &quot;U&quot;, and &quot;L&quot;) the argument <code>perm</code>
specifies the arrangement of the components of the filter in that
form. For the I- and U-forms the default is <code>mf_period(x):1</code>, for
the L-form it is <code>1:mf_period(x)</code>.
</p>
<p>Currently <code>perm</code> may take on
values that can  be obtained from the default by rotation, e.g. if the
period is 4,  <code>perm</code> may be one of
(4,3,2,1), (1,4,3,2), (2,1,4,3), (3,2,1,4) for the U-form,
and
(1,2,3,4), (4,1,2,3), (3,4,1,2), (2,3,4,1) for the L-form.
Other permutations may be usefull in some situations but may not
result in U- or L- forms (without further transformations).
For I-form any permutation should be permissible when implemented
(todo:).
</p>
<p>For <code>mf_order</code> the argument <code>perm</code> affects the computation
only, not the ordering in the result.  The result (if vector) is not
permuted unless the argument <code>i</code> asks for this.
For <code>mf_VSform</code> however such a behaviour would be very peculiar
and the rows of the result are for the permuted seasons.
In short, the i-th element of the result of <code>mf_order</code> (if
vector) gives the order (in the requested form) of the i-th season
but the i-th row of any of the matrices returned by  <code>mf_VSform</code>
depends on <code>perm</code> and <code>form</code>.
</p>
<p>Note: the terminology here reflects application to pc processes,
probably should be made more neutral in this respect.
</p>
<p>todo: (2013-03-26) <code>mf_order</code> seems unfinished.
</p>


<h3>Value</h3>

<p>For <code>mf_order</code>,
if <code>i = "max"</code> a positive integer,
otherwise a vector  of positive integers.
</p>
<p>For <code>mf_period</code> the period of the filter, a positive integer.
</p>
<p>For <code>mf_poles</code>,
if <code>blocks = FALSE</code>, a vector of the eigenvalues of the associated
multi-companion matrix, each eigenvalue repeated according to its
algebraic multiplicity.
If <code>blocks = TRUE</code>, a 2-column matrix with the eigenvalues in the
first column and the lengths of the  Jordan chains in the second.
There is one row  for each  chain (i.e. multiple eigenvalues are
repeated according to their geometric multiplicity).
</p>
<p>For <code>mf_VSform</code> a list with components:
</p>
<table>
<tr><td><code>Phi0</code></td>
<td>
<p>the zero lag coefficient, a matrix,</p>
</td></tr>
<tr><td><code>Phi</code></td>
<td>
<p>the remaining coefficients, a matrix,</p>
</td></tr>
<tr><td><code>Phi0inv</code></td>
<td>

<p>(<code>form=="I"</code> only) the inverse of the zero lag coefficient
matrix of the vs-form, a matrix. (<strong>TODO:</strong> the name of this
component is misleading since in the case <code>form = "I"</code> Phi0 is
the identity matrix and <code>Phi0inv</code> is not equal to the inverse
of Phi0.)
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>References</h3>


<p>Boshnakov GN (2002).
&ldquo;Multi-companion matrices.&rdquo;
<em>Linear Algebra Appl.</em>, <b>354</b>, 53&ndash;83.
ISSN 0024-3795, <a href="https://doi.org/10.1016/S0024-3795%2801%2900475-X">doi:10.1016/S0024-3795(01)00475-X</a>.
</p>
<p>Boshnakov GN, Iqelan BM (2009).
&ldquo;Generation of time series models with given spectral properties.&rdquo;
<em>J. Time Series Anal.</em>, <b>30</b>(3), 349&ndash;368.
ISSN 0143-9782, <a href="https://doi.org/10.1111/j.1467-9892.2009.00617.x">doi:10.1111/j.1467-9892.2009.00617.x</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MultiFilter-class">MultiFilter</a></code> and the examples there,
<code><a href="#topic+mcStable">mcStable</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## simulate a 3x3 2-companion matrix
##  and turn it into a multi-filter
(m &lt;- mCompanion("sim", dim=3, mo=2))
(flt &lt;- new("MultiFilter", mc = m ))
mf_period(flt)
mf_poles(flt)
abs(mf_poles(flt))
mf_VSform(flt,form="U")
mf_VSform(flt,form="L")
mf_VSform(flt,form="I")

## simulate a pc filter (2 seasons)
## and turn it into a multi-filter object
(rfi &lt;- sim_pcfilter(2, 3))
(flt &lt;- new("MultiFilter", coef = rfi$pcfilter))
mf_period(flt)
mf_poles(flt)
abs(mf_poles(flt))
mf_VSform(flt, form="U")
mf_VSform(flt, form="I")
mf_VSform(flt, form="L")

## indexing can be used  to extract filter coefficients
flt[]
flt[1,]
## the rest are some checks of numerical performance.
rfi
rfi$mat==0

zapsmall(rfi$mat)
mCompanion(zapsmall(rfi$mat))
unclass(mCompanion(zapsmall(rfi$mat)))
unclass(mCompanion(rfi$mat))

flt1 &lt;- new("MultiFilter", mc = mCompanion(zapsmall(rfi$mat)))
flt2 &lt;- flt

flt1[]
flt2[]
flt1[] - flt2[]
rfi$pcfilter - rfi$mat[1:2,]

mf_poles(flt1)
abs(mf_poles(flt1))

svd(rfi$mat)
rcond(rfi$mat)
Matrix::rcond(Matrix::Matrix(rfi$mat),"O")
1/Matrix::rcond(Matrix::Matrix(rfi$mat),"O")
</code></pre>

<hr>
<h2 id='MultiCompanion-class'>Class &quot;MultiCompanion&quot;</h2><span id='topic+MultiCompanion-class'></span><span id='topic++25+2A+25+2CMultiCompanion+2CANY-method'></span><span id='topic++25+2A+25+2CANY+2CMultiCompanion-method'></span><span id='topic++25+2A+25+2CMultiCompanion+2Cvector-method'></span><span id='topic++25+2A+25+2Cvector+2CMultiCompanion-method'></span><span id='topic++25+2A+25+2CMultiCompanion+2CMultiCompanion-method'></span><span id='topic++25+2A+25+2CMultiCompanion+2Cmatrix-method'></span><span id='topic++25+2A+25+2Cmatrix+2CMultiCompanion-method'></span><span id='topic++5B+2CMultiCompanion+2Cindex+2Cmissing+2Clogical-method'></span><span id='topic++5B+2CMultiCompanion+2Cindex+2Cindex+2Clogical-method'></span><span id='topic++5B+2CMultiCompanion+2Cmissing+2Cindex+2Clogical-method'></span><span id='topic+coerce+2CdgeMatrix+2CMultiCompanion-method'></span><span id='topic+coerce+2Cmatrix+2CMultiCompanion-method'></span><span id='topic+coerce+2CMultiCompanion+2Cmatrix-method'></span><span id='topic+coerce+2CMultiCompanion+2CMatrix-method'></span><span id='topic+coerce+2CMultiCompanion+2CdgeMatrix-method'></span><span id='topic+mcStable+2CMultiCompanion-method'></span><span id='topic+t+2CMultiCompanion-method'></span><span id='topic++5B+2CMultiCompanion+2Cindex+2Cindex+2Cmissing-method'></span><span id='topic++5B+2CMultiCompanion+2Cindex+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2CMultiCompanion+2Cmissing+2Cindex+2Cmissing-method'></span>

<h3>Description</h3>

<p>Objects and methods for multi-companion matrices</p>


<h3>Objects from the Class</h3>

<p>For ordinary usage objects from this class should behave as matrices
and there should be no need to access the slots directly.
</p>
<p>Objects can be created with the function <code><a href="#topic+mCompanion">mCompanion</a></code>.
Other functions in the mcompanion package also produce
<code>MultiCompanion</code> objects.
</p>
<p>It is possible also to call <code>new()</code> directly:
</p>
<pre>
    new("MultiCompanion", xtop, mo, n, mo.col, ido, x, dimnames,
        detect, misc)
  </pre>
<p>Arguments:
</p>

<dl>
<dt><code>xtop</code></dt><dd><p> is the top of the matrix. </p>
</dd>
<dt><code>mo</code></dt><dd><p> is the multi-companion order of the matrix. </p>
</dd>
<dt><code>n</code></dt><dd><p> is the dimension. </p>
</dd>
<dt><code>mo.col</code></dt><dd><p> is the top order, meaniing that columns
mo.col+1,...,n of the top of the matrix are zeros. <code>mo.col</code>
may also be set to &quot;detect&quot;, in which case it is determined by
scanning <code>xtop</code> or <code>x</code>. </p>
</dd>
<dt><code>ido</code></dt><dd><p> the dimension of the identity sub-matrix. </p>
</dd>
<dt><code>x</code></dt><dd><p> the whole matrix. </p>
</dd>
<dt><code>dimnames</code></dt><dd><p> is not used currently. </p>
</dd>
<dt><code>detect</code></dt><dd><p> controls whether automatic detection of
<code>mo</code> and <code>mo.col</code> should be attempted. The values tested
are &quot;mo&quot;, &quot;mo.col&quot;, &quot;all&quot;, and &quot;nothing&quot; with obvious meanings. </p>
</dd>
<dt><code>misc</code></dt><dd><p> todo: describe this argument! </p>
</dd>
</dl>

<p>Normally one of <code>xtop</code> and <code>x</code> is supplied but if both are,
they are checked for consistency, including the elements of the matrix
(equality is tested with <code>==</code>).  To facilitate calls with one
unnamed argument, when <code>xtop</code> is a square matrix it is taken
to be the entire matrix (provided that <code>x</code> is missing).
</p>
<p>Aside from <code>xtop</code> (or <code>x</code>), most of the remaining arguments
can be deduced automatically.  The number of rows and columns of
<code>xtop</code> give the multi-companion order and the dimension of the
matrix, respectively. A vector <code>xtop</code> is taken to stand for a
matrix with one row. <code>x</code> needs to be square or a vector of length
equal to exact square. <code>mo</code> and <code>mo.col</code> may be determined
from the contents of <code>x</code> and <code>xtop</code>. There is no harm in
ignoring <code>mo.col</code> but it is useful for our applications. Note
that by default it is to set to the number of columns and not
determined by scanning the matrix.
</p>
<p>The contents of the  <code>misc</code> argument are  stored in the pad of
the new object.
</p>


<h3>Slots</h3>


<dl>
<dt><code>xtop</code>:</dt><dd><p>The top of the matrix, an object of class <code>"matrix"</code> </p>
</dd>
<dt><code>mo</code>:</dt><dd><p>Multi-companion order, an object of class <code>"numeric"</code> </p>
</dd>
<dt><code>ido</code>:</dt><dd><p>dimension of the identity submatrix, object of class <code>"numeric"</code></p>
</dd>
<dt><code>mo.col</code>:</dt><dd><p>number of non-zero columns in top rows, object of class <code>"numeric"</code></p>
</dd>
<dt><code>pad</code>:</dt><dd><p>storage for additional info, object of class <code>"objectPad"</code> </p>
</dd>
<dt><code>x</code>:</dt><dd><p>inherited, object of class <code>"numeric"</code> </p>
</dd>
<dt><code>Dim</code>:</dt><dd><p>inherited, object of class <code>"integer"</code> </p>
</dd>
<dt><code>Dimnames</code>:</dt><dd><p>inherited, object of class <code>"list"</code> </p>
</dd>
<dt><code>factors</code>:</dt><dd><p>inherited, object of class <code>"list"</code> </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"ddenseMatrix"</code>, directly.
Class <code>"generalMatrix"</code>, directly.
Class <code>"dMatrix"</code>, by class <code>"ddenseMatrix"</code>.
Class <code>"denseMatrix"</code>, by class <code>"ddenseMatrix"</code>.
Class <code>"Matrix"</code>, by class <code>"ddenseMatrix"</code>.
Class <code>"Matrix"</code>, by class <code>"ddenseMatrix"</code>.
Class <code>"compMatrix"</code>, by class <code>"generalMatrix"</code>.
Class <code>"Matrix"</code>, by class <code>"generalMatrix"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>%*%</dt><dd><p><code>signature(x = "ANY", y = "MultiCompanion")</code>: ... </p>
</dd>
<dt>%*%</dt><dd><p><code>signature(x = "MultiCompanion", y = "MultiCompanion")</code>: ... </p>
</dd>
<dt>%*%</dt><dd><p><code>signature(x = "MultiCompanion", y = "ANY")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "MultiCompanion", i = "index", j = "index",
        drop = "logical")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "MultiCompanion", i = "index", j = "missing", drop = "logical")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "MultiCompanion", i = "missing", j =
        "index", drop = "logical")</code>: ... </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "dgeMatrix", to = "MultiCompanion")</code>: ... </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "matrix", to = "MultiCompanion")</code>: ... </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "MultiCompanion", to = "matrix")</code>: ... </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "MultiCompanion", to = "dgeMatrix")</code>: ... </p>
</dd>
<dt>initialize</dt><dd><p><code>signature(.Object = "MultiCompanion")</code>:
This method is called implicitly when the user calls
<code>new("MultiCompanion",...)</code>.
</p>
</dd>
<dt>mcStable</dt><dd><p><code>signature(x = "MultiCompanion")</code>: ... </p>
</dd>
<dt>t</dt><dd><p><code>signature(x = "MultiCompanion")</code>: ... </p>
</dd>
<dt>%*%</dt><dd><p><code>signature(x = "matrix", y = "MultiCompanion")</code>: ... </p>
</dd>
<dt>%*%</dt><dd><p><code>signature(x = "MultiCompanion", y = "matrix")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "MultiCompanion", i = "index", j = "index", drop = "missing")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "MultiCompanion", i = "index", j = "missing", drop = "missing")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "MultiCompanion", i = "missing", j = "index", drop = "missing")</code>: ... </p>
</dd>
<dt>%*%</dt><dd><p><code>signature(x = "MultiCompanion", y = "vector")</code>: ... </p>
</dd>
<dt>%*%</dt><dd><p><code>signature(x = "vector", y = "MultiCompanion")</code>: ... </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "MultiCompanion", to = "Matrix")</code>: ... </p>
</dd>
<dt>coerce&lt;-</dt><dd><p><code>signature(from = "MultiCompanion", to = "Matrix")</code>: ... </p>
</dd>
<dt>Math</dt><dd><p><code>signature(x = "MultiCompanion")</code>: ... </p>
</dd>
<dt>Math2</dt><dd><p><code>signature(x = "MultiCompanion")</code>: ... </p>
</dd>
<dt>Ops</dt><dd><p><code>signature(e1 = "ANY", e2 = "MultiCompanion")</code>: ... </p>
</dd>
<dt>Ops</dt><dd><p><code>signature(e1 = "complex", e2 = "MultiCompanion")</code>: ... </p>
</dd>
<dt>Ops</dt><dd><p><code>signature(e1 = "logical", e2 = "MultiCompanion")</code>: ... </p>
</dd>
<dt>Ops</dt><dd><p><code>signature(e1 = "matrix", e2 = "MultiCompanion")</code>: ... </p>
</dd>
<dt>Ops</dt><dd><p><code>signature(e1 = "MultiCompanion", e2 = "ANY")</code>: ... </p>
</dd>
<dt>Ops</dt><dd><p><code>signature(e1 = "MultiCompanion", e2 = "complex")</code>: ... </p>
</dd>
<dt>Ops</dt><dd><p><code>signature(e1 = "MultiCompanion", e2 = "logical")</code>: ... </p>
</dd>
<dt>Ops</dt><dd><p><code>signature(e1 = "MultiCompanion", e2 = "matrix")</code>: ... </p>
</dd>
<dt>Ops</dt><dd><p><code>signature(e1 = "MultiCompanion", e2 = "Matrix")</code>: ... </p>
</dd>
<dt>Ops</dt><dd><p><code>signature(e1 = "MultiCompanion", e2 = "MultiCompanion")</code>: ... </p>
</dd>
<dt>Ops</dt><dd><p><code>signature(e1 = "MultiCompanion", e2 = "numeric")</code>: ... </p>
</dd>
<dt>Ops</dt><dd><p><code>signature(e1 = "MultiCompanion", e2 = "vector")</code>: ... </p>
</dd>
<dt>Ops</dt><dd><p><code>signature(e1 = "numeric", e2 = "MultiCompanion")</code>: ... </p>
</dd>
<dt>Ops</dt><dd><p><code>signature(e1 = "vector", e2 = "MultiCompanion")</code>: ... </p>
</dd>
<dt>Summary</dt><dd><p><code>signature(x = "MultiCompanion")</code>: ... </p>
</dd></dl>



<h3>Note</h3>

<p>The implementation is rather redundant, this class probably should
inherit in a different way from classes in Matrix package or may be
not inherit at all.
</p>
<p>Methods to get the multi-order, mo.col, and others, would be useful
but first the terminology needs to be made consistent.
</p>
<p>Other matrix arithmetic operations?
</p>
<p>Argument <code>n</code> is called <code>dim</code> in other functions.
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>References</h3>


<p>Boshnakov GN (2002).
&ldquo;Multi-companion matrices.&rdquo;
<em>Linear Algebra Appl.</em>, <b>354</b>, 53&ndash;83.
ISSN 0024-3795, <a href="https://doi.org/10.1016/S0024-3795%2801%2900475-X">doi:10.1016/S0024-3795(01)00475-X</a>.
</p>
<p>Boshnakov GN, Iqelan BM (2009).
&ldquo;Generation of time series models with given spectral properties.&rdquo;
<em>J. Time Series Anal.</em>, <b>30</b>(3), 349&ndash;368.
ISSN 0143-9782, <a href="https://doi.org/10.1111/j.1467-9892.2009.00617.x">doi:10.1111/j.1467-9892.2009.00617.x</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mCompanion">mCompanion</a></code> and  the examples there;
the following functions produce multi-companion matrices but do not
return <code>MultiCompanion</code> objects:
</p>
<p><code><a href="#topic+sim_mc">sim_mc</a></code>, <code><a href="#topic+make_mcmatrix">make_mcmatrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a1 &lt;- matrix(1:12, nrow = 2)
mc1 &lt;- new("MultiCompanion", xtop = a1)
new("MultiCompanion", a1)   # same

a2 &lt;- matrix(c(1:6, rep(0, 4)), nrow = 2)   # 1st 3 columns of a2 are non-zero
mc2 &lt;- new("MultiCompanion", a2)
mc2
mc2@mo.col     # =5, because the default is to set mo.col to ncol

mc2a &lt;- new("MultiCompanion", a2, detect = "mo.col")
mc2a@mo.col   # =3, compare with above

b &lt;- as(mc2, "matrix")  # b is ordinary R matrix
mcb &lt;- new("MultiCompanion", x = b)
       new("MultiCompanion", b)   # same as mcb

mcb@mo        # 2 (mo detected)
mcb@mo.col    # 5 (no attempt to detect mo.col)

mcba &lt;- new("MultiCompanion", b, detect = "all")
mcba@mo        # 2 (mo detected)
mcba@mo.col    # 3 (mo.col detected)
</code></pre>

<hr>
<h2 id='MultiFilter-class'>Class &quot;MultiFilter&quot; </h2><span id='topic+MultiFilter-class'></span><span id='topic++5B+2CMultiFilter+2CANY+2CANY+2CANY-method'></span><span id='topic+initialize+2CMultiFilter-method'></span><span id='topic+mcStable+2CMultiFilter-method'></span>

<h3>Description</h3>

<p>Objects and methods  for filters with more than one set of
coefficients.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form
<code>new("MultiFilter", coef, mc, order, sign)</code>.
</p>
<p>Objects from this class represent periodic filters. A
<code class="reqn">d</code>-periodic filter relates an input series
<code class="reqn">\varepsilon_{t}</code> to an output series
<code class="reqn">y_t</code> by the following formula:
</p>
<p style="text-align: center;"><code class="reqn"> y_t
    =   \sum_{i=1}^{p_t} \phi  _t(i)y          _{t-i}
      % + \sum_{i=1}^{q_t} \theta_t(i)\varepsilon_{t-i}
      + \varepsilon_t
      ,
    </code>
</p>

<p>where the coefficients <code class="reqn">\phi_t(i)</code> are <code class="reqn">d</code>-periodic in
<code class="reqn">t</code>, i.e. <code class="reqn">\phi_{t+d}(i)=\phi_t(i)</code> and
<code class="reqn">p_{t+d} = p_{t}</code>.
</p>
<p>The periodicity means that it is sufficient to store the coefficients
in a <code class="reqn">d \times p</code> matrix, where
<code class="reqn">p=\max(p_1,\dots,p_t)</code>.
Slot <code>coef</code> contains such a matrix.
</p>
<p>The filter may be specified either by its coefficients or by its
multi-companion form.
</p>


<h3>Slots</h3>


<dl>
<dt><code>mc</code>:</dt><dd><p>the multi-companion form of the filter, an object
of class <code>"MultiCompanion"</code>
</p>
</dd>
<dt><code>coef</code>:</dt><dd><p>the coefficients of the filter, an object of
class <code>"matrix"</code>, whose <code class="reqn">s</code>th row contains the
coefficients for <code class="reqn">t=k \times d +s</code>.
</p>
</dd>
<dt><code>order</code>:</dt><dd><p>the periodic order of the filter,
a numeric vector giving the orders of the individual seasons.
</p>
</dd>
<dt><code>sign</code>:</dt><dd><p>1 or -1. The default value, 1, corresponds to
the formula given in section &quot;Objects from the Class&quot;. It can also
be -1, if the sum on the right-hand side of that formula is
preceded by a minus (usual convention in signal processing).
</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>[</dt><dd><p><code>signature(x = "MultiFilter", i = "ANY", j = "ANY",
	drop = "ANY")</code>:
take subset of the coefficients of the filter in various forms.
</p>
<p>To do: the function needs more work! Document the function and the
additional arguments!
</p>
</dd>
<dt>initialize</dt><dd><p><code>signature(.Object = "MultiFilter")</code>:
This function is called implicitly by <code>new</code>, see the
signature for <code>new</code> above.
One of <code>mc</code> and  <code>coef</code> must be supplied, the other
arguments are optional.
</p>
<p>If <code>mc</code> is missing it is computed from <code>coef</code>.
In this case, component <code>mC.factorsmat</code> of slot <code>misc</code>
of <code>mc</code> is set to the companion factorisation of <code>mc</code>
(essentially the reversed rows of <code>coef</code>).
</p>
<p>If <code>coef</code> is missing it is computed from <code>mc</code>, see
<code><a href="#topic+mc_factors">mc_factors</a></code>.
</p>
</dd>
<dt>mcStable</dt><dd><p><code>signature(x = "MultiFilter")</code>:
Check if the filter is stable.
</p>
</dd>
</dl>
<p>See also the documentation for the following functions which are
effectively methods for class &quot;MuliFilter&quot; but are not defined as
formal methods:
</p>
<p><code>mf_period</code>, <code>mf_order</code>, <code>mf_poles</code>,
<code>mf_VSform</code>.

</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>References</h3>


<p>Boshnakov GN (2002).
&ldquo;Multi-companion matrices.&rdquo;
<em>Linear Algebra Appl.</em>, <b>354</b>, 53&ndash;83.
ISSN 0024-3795, <a href="https://doi.org/10.1016/S0024-3795%2801%2900475-X">doi:10.1016/S0024-3795(01)00475-X</a>.
</p>
<p>Boshnakov GN, Iqelan BM (2009).
&ldquo;Generation of time series models with given spectral properties.&rdquo;
<em>J. Time Series Anal.</em>, <b>30</b>(3), 349&ndash;368.
ISSN 0143-9782, <a href="https://doi.org/10.1111/j.1467-9892.2009.00617.x">doi:10.1111/j.1467-9892.2009.00617.x</a>.
</p>


<h3>See Also</h3>


<p><code><a href="#topic+MultiCompanion-class">MultiCompanion</a></code>,
<code><a href="#topic+mf_period">mf_period</a></code>, <code><a href="#topic+mf_order">mf_order</a></code>,
<code><a href="#topic+mf_poles">mf_poles</a></code>,
<code><a href="#topic+mf_VSform">mf_VSform</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("MultiFilter")

m &lt;- mCompanion("sim",dim=3,mo=2)   # simulate a 3x3 2-comp. matrix
flt &lt;- new("MultiFilter", mc = m )
flt[]
mf_period(flt)
mf_poles(flt)
abs(mf_poles(flt))

mf_VSform(flt,form="U")
mf_VSform(flt,form="L")
mf_VSform(flt,form="I")


# try arguments "coef" and "mc", for comparison
rfi &lt;- sim_pcfilter(2,3) # period=2, order=c(3,3)
# per. filter from a multi-companion matrix
flt1 &lt;- new("MultiFilter",mc=  mCompanion(zapsmall(rfi$mat)) )
flt1[]
mf_period(flt1)
mf_poles(flt1)
abs(mf_poles(flt1))

mf_VSform(flt1,form="U")
mf_VSform(flt1,form="L")
mf_VSform(flt1,form="I")

# per. filter from coefficients, should be the same (numerically)
flt2 &lt;- new("MultiFilter",coef=rfi$pcfilter)
flt2[]
mf_period(flt2)
mf_poles(flt2)
abs(mf_poles(flt2))

mf_VSform(flt2,form="U")
mf_VSform(flt2,form="L")
mf_VSform(flt2,form="I")

</code></pre>

<hr>
<h2 id='null_complement'>Compute the orthogonal complement of a subspace</h2><span id='topic+null_complement'></span>

<h3>Description</h3>

<p>Computes the orthogonal complement of a subspace relative
to a universe.</p>


<h3>Usage</h3>

<pre><code class='language-R'>null_complement(m, universe = NULL, na.allow = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="null_complement_+3A_m">m</code></td>
<td>

<p>NA or a matrix whose columns define the subspace, a vector is
treated as a matrix with one column.
</p>
</td></tr>
<tr><td><code id="null_complement_+3A_universe">universe</code></td>
<td>

<p>a matrix whose columns specify the subspace relative to
which to compute the complement, the default is the full space.
</p>
</td></tr>
<tr><td><code id="null_complement_+3A_na.allow">na.allow</code></td>
<td>

<p>if <code>TRUE</code>, default, treat NA's specially, see Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>null_complement</code> computes the orthogonal complement of a
subspace (spanned by the columns of <code>m</code>) relative to a universe.
</p>
<p>Argument <code>universe</code> can be used to specify a subspace w.r.t.
which to compute the complement.  If <code>universe</code> is <code>NULL</code>
(the default), the complement w.r.t. the full space is computed. The
full space is the <code class="reqn">n</code>-dimensional space, where <code class="reqn">n</code> is the
number of rows of argument <code>m</code>.
</p>
<p><code>null_complement</code> returns a matrix whose columns give a basis of
the required subspace.
</p>
<p><code>null_complement</code> uses <code>Null()</code> from package MASS for the
actual computation. <code>null_complement(m, na.allow = FALSE)</code> is
equivalent to <code>Null(m)</code>.
</p>
<p><code>m</code> is typically a matrix whose columns represent the subspace
w.r.t. which to compute the complement.
<code>null_complement</code> can also deal with NA's in <code>m</code>. This
facility can be turned off by specifying <code>na.allow = FALSE</code>.
</p>
<p>If <code>na.allow = TRUE</code>, the default, and <code>m</code> is identical to
<code>NA</code>, <code>universe</code> is returned (i.e. <code>m = NA</code> represents
the empty subspace). Note that in this case <code>universe</code> cannot be
NULL, since there is no way to determine the dimension of the full
space.
</p>
<p>Otherwise, <code>m</code> is a matrix. If all elements of <code>m</code> are
<code>NA</code>, a matrix of NA's is returned with number of columns equal
to <code>ncol(universe) - ncol(m)</code>.
</p>


<h3>Value</h3>

<p>a matrix representing a basis of the requested subspace
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>Examples</h3>

<pre><code class='language-R'>m1 &lt;- diag(1, nrow = 3, ncol = 2)
null_complement(m1)

null_complement(c(1,1,0))
null_complement(c(1,1,0), m1)

## the columns of the result from null_complement() are orthogonal
## to  the 1st argument:
t(c(1,1,0)) %*% null_complement(c(1,1,0))
t(c(1,1,0)) %*% null_complement(c(1,1,0), m1)

null_complement(rep(NA_real_, 3), m1)
null_complement(NA, m1)
</code></pre>

<hr>
<h2 id='optionalMatrix-class'>Class optionalMatrix</h2><span id='topic+optionalMatrix-class'></span>

<h3>Description</h3>

<p>Class optionalMatrix.</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;optionalMatrix&quot; in the signature.
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("optionalMatrix")
</code></pre>

<hr>
<h2 id='permute_var'>Permute rows and columns of matrices</h2><span id='topic+permute_var'></span><span id='topic+permute_synch'></span>

<h3>Description</h3>

<p>Permute rows and columns of matrices.</p>


<h3>Usage</h3>

<pre><code class='language-R'>permute_var(mat, perm = nrow(mat):1)
permute_synch(param, perm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permute_var_+3A_mat">mat</code></td>
<td>
<p>a matrix.</p>
</td></tr>
<tr><td><code id="permute_var_+3A_param">param</code></td>
<td>
<p>a matrix or list, see Details.</p>
</td></tr>
<tr><td><code id="permute_var_+3A_perm">perm</code></td>
<td>
<p>permutation, defaults to <code>nrow:1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a permutation, <code>permute_var</code> permutes the rows and columns
of a matrix in such a way that if <code>mat</code> is the covariance matrix
of a vector <code>x</code>, then the rearranged matrix is the covariance
matrix of <code>x[perm]</code>. If <code>P</code> is the permutation matrix
corresponding to <code>perm</code>, then the computed value is
<code>P %*% mat %*% t(P)</code>.
</p>
<p><code>permute_synch</code> performs the above transformation on all matrices
found in <code>param</code>. More precisely, if <code>param</code> is a matrix,
then the result is the same as for <code>permute_var</code>. Otherwise
<code>param</code> should be a list and, conceptually, <code>permute_synch</code> is
applied recursively on each element of this list. The net result is
that each matrix, say <code class="reqn">M</code>, in <code>param</code> is replaced by
<code class="reqn">PMP'</code> and each vector, say <code class="reqn">v</code>, by <code class="reqn">Pv</code>. The idea is that
<code>param</code> may contain specification of a VAR model, all components
of which need to be reshuffled if the components of the multivariate
vector are permuted.
</p>
<p>All matrices in <code>param</code> must have the same number of rows, say
<code>d</code>, but this is not checked. <code>perm</code> should be a permutation
of <code>1:d</code>.
</p>


<h3>Value</h3>

<p>for <code>permute_var</code>, a matrix,
</p>
<p>for <code>permute_synch</code>, a matrix or list of the same shape as
<code>param</code> in which each matrix is transformed as described in
Details.
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>Examples</h3>

<pre><code class='language-R'>Cl &lt;- cor(longley) # from example for 'cor()'
nc &lt;- ncol(Cl)
v &lt;- 1:nc
names(v) &lt;- colnames(Cl)

permute_var(Cl)
all(permute_var(Cl) == Cl[ncol(Cl):1, ncol(Cl):1])
</code></pre>

<hr>
<h2 id='rblockmult'> Right-multiply a matrix by a block </h2><span id='topic+rblockmult'></span>

<h3>Description</h3>

<p>Treats a matrix as a block matrix and multiplies each block by a given
block.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rblockmult(x, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rblockmult_+3A_x">x</code></td>
<td>
<p> the matrix. </p>
</td></tr>
<tr><td><code id="rblockmult_+3A_b">b</code></td>
<td>
<p> the block. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>x</code> is split into blocks [x1 ... xn] so that
<code>ncol(xi)==nrow(b)</code> and each block is multiplied by <code>b</code>.
The result is the matrix [x1 b ... xn b].
</p>


<h3>Value</h3>

<p>the matrix obtained as described above
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- matrix(1:12, nrow = 2)
b &lt;- matrix(c(0, 1, 1, 0), nrow = 2)
rblockmult(m,b)
</code></pre>

<hr>
<h2 id='reduce_chains_simple'>Transform a chain and drop excess, internal function</h2><span id='topic+reduce_chains_simple'></span>

<h3>Description</h3>

<p>Transform a chain and drop excess, internal function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduce_chains_simple(chains, sort = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reduce_chains_simple_+3A_chains">chains</code></td>
<td>
<p> list of 0chains </p>
</td></tr>
<tr><td><code id="reduce_chains_simple_+3A_sort">sort</code></td>
<td>
<p> flag for sorting, see details </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given one or more chains corresponding to a common eigenvalue,
<code>reduce_chains_simple</code> transforms the chains so that redundant
eigenvectors are removed. In the process, the heights of some chains
may decrease and the number of chains may be reduced, too.
</p>
<p>If <code>sort == TRUE</code> the function reorders the chains so that their
lengths are in decreasing order.  However, the algorithm depends on
this being done, so this argument should be used when the chains are
known to be already sorted.
</p>
<p>I wrote this function as part of the support for chains of
multi-companion matrices associated with the 0 eigenvalue.  When
chains specified via the top left <code>mo.col x mo.col</code> subchains are
extended to chains of the top left <code>mo x mo</code> corner the
(extended) eigenvectors may not be linearly independent.
</p>


<h3>Value</h3>

<p>list  of chains
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+mc.0chain.dx">mc.0chain.dx</a></code></p>

<hr>
<h2 id='sim_chains'>Simulate Jordan chains</h2><span id='topic+sim_chains'></span>

<h3>Description</h3>

<p>Simulate Jordan chains.</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_chains(dim = nrow(vectors), type = NULL, heights = NULL,
           vectors = NULL, argarg = list(0, pi), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_chains_+3A_dim">dim</code></td>
<td>
<p>dimension of the matrix, a positive integer.</p>
</td></tr>
<tr><td><code id="sim_chains_+3A_type">type</code></td>
<td>

<p>types of the eigenvalues, a character vector containing
<code>"r"</code> and <code>"cp"</code>.
</p>
</td></tr>
<tr><td><code id="sim_chains_+3A_heights">heights</code></td>
<td>

<p>heights of the eigenvalues, a vector of positive integers.
</p>
</td></tr>
<tr><td><code id="sim_chains_+3A_vectors">vectors</code></td>
<td>
<p>a matrix containing chains.</p>
</td></tr>
<tr><td><code id="sim_chains_+3A_argarg">argarg</code></td>
<td>
<p>TODO: describe.</p>
</td></tr>
<tr><td><code id="sim_chains_+3A_...">...</code></td>
<td>

<p>additional arguments to be passed on to <code>sim_numbers</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sim_chains</code> prepares the arguments and calls <code>sim_numbers</code>
to fill the NA entries in <code>vectors</code> with simulated values.
</p>


<h3>Value</h3>

<p>a matrix
</p>


<h3>Author(s)</h3>

<p>Georgi N, Boshnakov</p>

<hr>
<h2 id='sim_mc'> Simulate a multi-companion matrix </h2><span id='topic+sim_mc'></span>

<h3>Description</h3>

<p>Simulate a multi-companion matrix with partially or  fully specified spectral
properties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_mc(dim, mo, mo.col = dim, eigval, len.block, type.eigval = NULL,
       co, eigabs, eigsign, type = "real",
       value = "real", value.type = "", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_mc_+3A_dim">dim</code></td>
<td>
<p> dimension of the matrix. </p>
</td></tr>
<tr><td><code id="sim_mc_+3A_mo">mo</code></td>
<td>
<p> multi-companion order. </p>
</td></tr>
<tr><td><code id="sim_mc_+3A_mo.col">mo.col</code></td>
<td>
<p> number of structural columns. </p>
</td></tr>
<tr><td><code id="sim_mc_+3A_eigval">eigval</code></td>
<td>
<p> eigenvalues, one for each Jordan block. </p>
</td></tr>
<tr><td><code id="sim_mc_+3A_len.block">len.block</code></td>
<td>

<p>lengths of the Jordan blocks corresponding to <code>eigval</code>.
</p>
</td></tr> 
<tr><td><code id="sim_mc_+3A_type.eigval">type.eigval</code></td>
<td>
<p> types of the eigenvalues, a character vector </p>
</td></tr>
<tr><td><code id="sim_mc_+3A_co">co</code></td>
<td>
 <p><code>co</code> parameters, see Details.</p>
</td></tr>
<tr><td><code id="sim_mc_+3A_eigabs">eigabs</code></td>
<td>
<p> moduli (absolute values) of eigenvalues, see Details.</p>
</td></tr>
<tr><td><code id="sim_mc_+3A_eigsign">eigsign</code></td>
<td>
<p>signs or complex arguments of eigenvalues, see Details.</p>
</td></tr>
<tr><td><code id="sim_mc_+3A_type">type</code></td>
<td>
<p> passed down to generators (???) </p>
</td></tr>
<tr><td><code id="sim_mc_+3A_value">value</code></td>
<td>
<p> what to return </p>
</td></tr>
<tr><td><code id="sim_mc_+3A_value.type">value.type</code></td>
<td>
<p>  type of the value (???)</p>
</td></tr>
<tr><td><code id="sim_mc_+3A_...">...</code></td>
<td>

<p>further arguments to passed on to <code>sim_chains</code> and
<code>sim_numbers</code>, see Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sim_mc</code> generates a multi-companion matrix of dimension
<code>dim x dim</code> and multi-companion order <code>mo</code>. The matrix has
the spectral properties specified by the arguments. Values that cannot
be inferred from the arguments are simulated.
</p>
<p>Arguments <code>dim</code>, <code>mo</code>, and <code>mo.col</code> define the
structure of the matrix. The first two are compulsory but the last
one, <code>mo.col</code>, is optional. If no other arguments are supplied
<code>sim_mc</code> produces a matrix with all spectral parameters
simulated.
</p>
<p>The number of non-zero eigenvalues is at most <code>mo.col</code>.
If <code>mo.col &lt; dim</code> the multi-companion matrix has structural
eigenvectors/chains corresponding to the zero eigenvalue(s), see
the references. These chains are generated automatically.
</p>
<p>Arguments <code>type.eigval</code>, <code>eigabs</code>, <code>eigsign</code> and
<code>eigval</code> are vectors used to specify the types and the values of
the eigenvalues. Any or all of them may be missing or NULL. Those
present must have the same length.
</p>
<p>It is not necessary to specify eigenvalues and eigenvectors
corresponding to eigenvalues equal to zero, since the structural
eigenchains needed when <code>mo.col &lt; dim</code> are created automatically.
In practice, the number of the non-zero eigenvalues is usually equal
to <code>mo.col</code>.  The net effect is that the arguments specifying the
spectral structure of the matrix normally need to specify the spectral
information about the non-zero <code>eigval</code> only.
</p>
<p>Some or all of the eigenvalues may be specified partially or fully
using arguments <code>eigabs</code>, <code>eigsign</code>, and
<code>eigval</code>. Non-NA entries in <code>eigval</code> specify complete
eigenvalues. Non-NA entries in <code>eigabs</code> specify absolute values
of eigenvalues. Non-NA entries in <code>eigsign</code> specify signs of real
eigenvalues or complex arguments of complex eigenvalues. Generally, if
the entry for an eigenvalue in <code>eigval</code> is a number (not
<code>NA</code>), then the corresponding entries in <code>eigabs</code> and
<code>eigsign</code> will be <code>NA</code>. This is not enforced and a limited
check for consistency is made in case of redundant information.
</p>
<p><code>type.eigval</code> is a character vector describing the types of the
eigenvalues, where &quot;r&quot;, &quot;c&quot;, and &quot;cp&quot; stand for real, complex, and
complex pair, respectively. It is best to have one entry only for each
complex pair (specified by &quot;cp&quot;), rather than two &quot;c&quot; entries.
</p>
<p>If <code>type.eigval</code> is NULL (default) and <code>eigval</code> is supplied,
then <code>type.eigval</code> is inferred from the imaginary part of
<code>eigval</code> (&quot;r&quot; or &quot;cp&quot;), if it is complex.
</p>
<p>For compatibility with older versions of this function <code>eigval</code>
may be a character vector in which case it is simply assigned to
<code>type.eigval</code>.
</p>
<p>If both, <code>type.eigval</code> and <code>eigval</code>, are missing a default
allocation of the types of the eigenvalues is chosen.
</p>
<p><strong>TODO: complete the description below.</strong>
</p>
<p>The remaining spectral parameters may be specified with the argument
<code>co</code> with missing entries for the &quot;free&quot; entries. (!!! This is not
complete, it may be better to have separate arguments for the absolute
value and the angle, as for eigenvalues, and an option for
normalisation of these coefficients. ???)
</p>
<p>Generators other than the default ones may be specified in the
<code>...</code>  argument. These are passed to <code>sim_numbers</code> and
<code>sim_chains</code>.  Again, for the &quot;co&quot; arguments the support
is not finished.
</p>


<h3>Value</h3>

<p>if <code>value.type</code> is the character string <code>"matrix"</code>, the
required multi-companion matrix. Otherwise, if
<code>value.type=="list"</code>, a list containing also the spectral
information (this list is the same as the one from
<code><a href="#topic+make_mcmatrix">make_mcmatrix</a></code>)).
</p>


<h3>Note</h3>

<p>A canonical form is needed, especially when there are repeated
eigenvalues whose eigenvectors may be chosen to be orthogonal, at
least. (nyakade v zapiskite mi tryabva da ima kanonichna forma!)
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>References</h3>


<p>Boshnakov GN (2002).
&ldquo;Multi-companion matrices.&rdquo;
<em>Linear Algebra Appl.</em>, <b>354</b>, 53&ndash;83.
ISSN 0024-3795, <a href="https://doi.org/10.1016/S0024-3795%2801%2900475-X">doi:10.1016/S0024-3795(01)00475-X</a>.
</p>
<p>Boshnakov GN, Iqelan BM (2009).
&ldquo;Generation of time series models with given spectral properties.&rdquo;
<em>J. Time Series Anal.</em>, <b>30</b>(3), 349&ndash;368.
ISSN 0143-9782, <a href="https://doi.org/10.1111/j.1467-9892.2009.00617.x">doi:10.1111/j.1467-9892.2009.00617.x</a>.
</p>


<h3>See Also</h3>

<p><code>gbutils::sim_numbers</code> and
<code><a href="#topic+sim_chains">sim_chains</a></code> for arguments that control the
distributions of the random numbers.
</p>
<p><code><a href="#topic+make_mcmatrix">make_mcmatrix</a></code> creates the matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m0 &lt;- sim_mc(3,2)   # simulate 3x3 2-companion matrix
abs(m0$eigval)      # eigval random, so their abs values

# now fix moduli of eigenvalues, and
# ask for one real ev and one complex pair of ev's
m1 &lt;- sim_mc(3,2,eigabs=c(0.25,0.5), type.eigval=c("r","cp"))
m1$eigval
abs(m1$eigval)

# same as above, since type.eigval happens to be the default
# dim is odd, by default first ev is real, rest are complex pairs
m1a &lt;- sim_mc(3,2,eigabs=c(0.25,0.5))
m1a$eigval
abs(m1a$eigval)

# simulate 6x6 4-companion matrix
# with ev's at the seasonal frequencies (1.57 3.141593 -1.57)
# and random moduli. 3 complex pairs of ev's
m2 &lt;- sim_mc(6,4, eigsign = pi*c(1/2,1,-1/2) )
Arg(m2$eigval)
</code></pre>

<hr>
<h2 id='sim_pcfilter'> Generate periodic filters </h2><span id='topic+sim_pcfilter'></span>

<h3>Description</h3>

<p>Generates periodic filters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_pcfilter(period, n.root, order = n.root, mo.col, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_pcfilter_+3A_period">period</code></td>
<td>
<p> the period. </p>
</td></tr>
<tr><td><code id="sim_pcfilter_+3A_n.root">n.root</code></td>
<td>
<p> number of non-zero roots (poles). </p>
</td></tr>
<tr><td><code id="sim_pcfilter_+3A_order">order</code></td>
<td>
<p> order of the  filter. </p>
</td></tr>
<tr><td><code id="sim_pcfilter_+3A_...">...</code></td>
<td>

<p>additional parameters to be passed down to <code>sim_mc</code>.
</p>
</td></tr>
<tr><td><code id="sim_pcfilter_+3A_mo.col">mo.col</code></td>
<td>

<p>the last non-zero column in the top of the mc-matrix. The default is
<code>dim</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generates periodic filters using the multicompanion approach
(Boshnakov and Iqelan 2009).
</p>
<p>By default the generated filter is stable and may be used as the
autoregressive or moving average part of a periodic autoregressive
moving average model. The filter is generated from the specified
spectral information by factoring a multi-companion matrix. Any
non-specified quantities are generated randomly. Randomly generated
eigenvalues correspond to stable filter. The user may specify
non-stable roots, unit roots in particular, see <code>sim_mc</code>.
</p>


<h3>Value</h3>

<p>A list as obtained from <code><a href="#topic+sim_mc">sim_mc</a></code> with an addtional
component for the filter.
</p>
<table>
<tr><td><code>pcfilter</code></td>
<td>
<p> a matrix with the filter coefficients for the i-th
season in the i-th row.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>todo: a) Allow different orders for the individual seasons. This is
not  trivial and maybe not natural for this method. In the singular
case it may make sense to implement different strategies for choosing
the factorization (when it is not unique) and to choose more carefully
the order of the filter to ensure existence of factorization, see my
paper.
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>References</h3>


<p>Boshnakov GN (2002).
&ldquo;Multi-companion matrices.&rdquo;
<em>Linear Algebra Appl.</em>, <b>354</b>, 53&ndash;83.
ISSN 0024-3795, <a href="https://doi.org/10.1016/S0024-3795%2801%2900475-X">doi:10.1016/S0024-3795(01)00475-X</a>.
</p>
<p>Boshnakov GN, Iqelan BM (2009).
&ldquo;Generation of time series models with given spectral properties.&rdquo;
<em>J. Time Series Anal.</em>, <b>30</b>(3), 349&ndash;368.
ISSN 0143-9782, <a href="https://doi.org/10.1111/j.1467-9892.2009.00617.x">doi:10.1111/j.1467-9892.2009.00617.x</a>.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+sim_mc">sim_mc</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>rfi &lt;- sim_pcfilter(2,3)
rfi
mo &lt;- cbind(c(1,1),rfi$pcfilter)
mo
</code></pre>

<hr>
<h2 id='SmallMultiCompanion-class'>A class for small multi-companion matrices</h2><span id='topic+SmallMultiCompanion-class'></span><span id='topic+coerce+2CSmallMultiCompanion+2Cmatrix-method'></span><span id='topic+initialize+2CSmallMultiCompanion-method'></span>

<h3>Description</h3>

<p>A class for internal use for work with small
multi-companion matrices.
</p>


<h3>Objects from the Class</h3>

<p>This class is for internal use.
</p>
<p>Objects can be created by calls of the form
<code>new("SmallMultiCompanion", Mtop, Mbot, jdMtop, MbotXtop)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>jdMtop</code>:</dt><dd><p>Object of class <code>"JordanDecomposition"</code> ~~ </p>
</dd>
<dt><code>Mtop</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>Mbot</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>MbotXtop</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>coerce</dt><dd><p><code>signature(from = "SmallMultiCompanion", to = "matrix")</code>: ... </p>
</dd>
<dt>initialize</dt><dd><p><code>signature(.Object = "SmallMultiCompanion")</code>: ... </p>
</dd>
<dt>JordanDecomposition</dt><dd><p><code>signature(values = "SmallMultiCompanion", vectors = "missing")</code>: ... </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Georgi N. Boshnakov
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MultiCompanion-class">MultiCompanion</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat2 &lt;- make_mcmatrix(eigval = c(1), co = cbind(c(1,1,1,1), c(0,1,0,0)), dim = 4,
len.block = c(2))
mat2
## Jordan decomp. of mat2[1:2,1:2]:
x2 &lt;- matrix(c(1,1,-1,0), ncol =2)
jd &lt;- matrix(c(1,0,1,1), ncol = 2)
mat2[1:2,1:2] - x2 %*% jd %*% solve(x2)
jdobj &lt;- JordanDecomposition(values = 1, vectors = x2, heights = 2)

m1 &lt;- new("SmallMultiCompanion", mat2[1:2, 1:2], Mbot = mat2[3:4, 1:2], jdMtop = jdobj)
m1a &lt;- new("SmallMultiCompanion", Mbot = mat2[3:4, 1:2], jdMtop = jdobj)
as.matrix(m1) - as.matrix(m1a)  # (approx.) 0's
</code></pre>

<hr>
<h2 id='spec_core'>
Parameterise Jordan chains of multi-companion matrices
</h2><span id='topic+spec_core'></span>

<h3>Description</h3>

<p>Parameterise the Jordan chains corresponding to a given eigenvalue of
a multi-companion matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spec_core(mo, evalue, heights, ubasis = NULL, uorth = NULL, evspace = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spec_core_+3A_mo">mo</code></td>
<td>
<p>multi-companion order, a positive integer.</p>
</td></tr>
<tr><td><code id="spec_core_+3A_evalue">evalue</code></td>
<td>
<p>eigenvalue, a real or complex number.</p>
</td></tr>
<tr><td><code id="spec_core_+3A_heights">heights</code></td>
<td>

<p>dimensions of Jordan blocks of <code>evalue</code>, a vector of positive
integers.
</p>
</td></tr>
<tr><td><code id="spec_core_+3A_ubasis">ubasis</code></td>
<td>
<p>basis of the universe, a matrix.</p>
</td></tr>
<tr><td><code id="spec_core_+3A_uorth">uorth</code></td>
<td>

<p>orthogonal complement of <code>ubasis</code> w.r.t. the full core basis,
see Details.
</p>
</td></tr>
<tr><td><code id="spec_core_+3A_evspace">evspace</code></td>
<td>
<p>The space spanned by the eigenvectors, see Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>spec_core</code> prepares a canonical representation of the parameters
of a multi-companion matrix coresponding to an eigenvalue. Roughly
speaking, free parameters are represented by NA's in the returned
object. For no-repeated eigenvalues the parameterisation consists of
the eigenvalue and the seed parameters of the eigenvector. Even then,
for uniqueness some convention needs to be adopted.
</p>
<p>So, in general the  parameterisation is effectively in terms of
subspaces.
</p>
<p><strong>TODO:</strong> Currently this is not documented and is work in
progress, there are only some working notes (rakopis:
&quot;Some technical details about the parameterisation of mc-matrices&quot;).
</p>


<h3>Value</h3>

<p>a list representing the parameterised chains corresponding to the
eigenvalue. Currently it contains the following elements:
</p>
<table>
<tr><td><code>evalue</code></td>
<td>
</td></tr>
<tr><td><code>heights</code></td>
<td>
</td></tr>
<tr><td><code>co</code></td>
<td>
</td></tr>
<tr><td><code>core.vectors</code></td>
<td>
</td></tr>
<tr><td><code>param.tall</code></td>
<td>
</td></tr>
<tr><td><code>param.hang</code></td>
<td>
</td></tr>
<tr><td><code>generators</code></td>
<td>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>Examples</h3>

<pre><code class='language-R'>spec_core(4, 1, c(1,1,1,1))

spec_core(4, 1, c(2,1,1,1))
spec_seeds1(c(2,2,2,2), 4)
spec_seeds1(c(2,1,1,1), 4)
spec_core(4, 1, c(2,1,1,1))$co
spec_core(4, 1, c(2,1,1,1))$generators
</code></pre>

<hr>
<h2 id='spec_root0'>Give the spectral parameters for zero eigenvalues of mc-matrices</h2><span id='topic+spec_root0'></span>

<h3>Description</h3>

<p>Give the spectral parameters for zero eigenvalues of
mc-matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spec_root0(dim, mo, mo.col)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spec_root0_+3A_dim">dim</code></td>
<td>
<p>dimension of the matrix, a positive integer.</p>
</td></tr>
<tr><td><code id="spec_root0_+3A_mo">mo</code></td>
<td>
<p>multi-companion order, a positive integer.</p>
</td></tr>
<tr><td><code id="spec_root0_+3A_mo.col">mo.col</code></td>
<td>
<p>last non-zero column in the top of the mc-matrix, a
non-negative integer.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>spec_root0</code> prepares a structure for the zero roots of an
mc-matrix.
</p>


<h3>Value</h3>

<p>a list with the following components:
</p>
<table>
<tr><td><code>mo</code></td>
<td>
<p>multi-companion order</p>
</td></tr>
<tr><td><code>ev.type</code></td>
<td>
<p>type of the eigenvalues</p>
</td></tr>
<tr><td><code>co.type</code></td>
<td>
<p>not used currently (<strong>:todo:</strong>)</p>
</td></tr>
<tr><td><code>n.root</code></td>
<td>
<p>number of non-zero roots</p>
</td></tr>
<tr><td><code>ev.abs</code></td>
<td>
<p>absolute values of roots</p>
</td></tr>
<tr><td><code>ev.arg</code></td>
<td>
<p>arguments of eigenvalues (0 for positive ev)</p>
</td></tr>
<tr><td><code>block.length</code></td>
<td>
<p>lengths of Jordan blocks</p>
</td></tr>
<tr><td><code>co.abs</code></td>
<td>
<p>absolute values of seed parameters</p>
</td></tr>
<tr><td><code>co.arg</code></td>
<td>
<p>arguments of seed parameters (Hz: 0 for positive; 1/2 for negative)</p>
</td></tr>
<tr><td><code>co0</code></td>
<td>
<p>redundant but keep it for now.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+spec_root1">spec_root1</a></code>,
<code><a href="#topic+mcSpec">mcSpec</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spec_root0(4,2,3)
spec_root0(4,2,2)
spec_root0(4,2,1)
spec_root0(5,2,3)
spec_root1(4,2,2)

spec_root0(6,4,2)
spec_root0(6,4,4)
spec_root0(10,4,8)
</code></pre>

<hr>
<h2 id='spec_root1'>Give the spectral parameters for eigenvalues  of mc-matrices
equal to one
</h2><span id='topic+spec_root1'></span>

<h3>Description</h3>

<p>Give the spectral parameters for eigenvalues  of
mc-matrices equal to one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spec_root1(mo, root1 = numeric(0), iorder = 0, siorder = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spec_root1_+3A_mo">mo</code></td>
<td>
<p>mc order.</p>
</td></tr>
<tr><td><code id="spec_root1_+3A_root1">root1</code></td>
<td>
<p>Jordan block lengths for the unit roots, a vector of
positive integer numbers.
</p>
</td></tr>
<tr><td><code id="spec_root1_+3A_iorder">iorder</code></td>
<td>
<p>order of integration, a non-negative integer.</p>
</td></tr>
<tr><td><code id="spec_root1_+3A_siorder">siorder</code></td>
<td>
<p>order of seasonal integration, a non-negative integer.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The specifications given by <code>root1</code>, <code>iorder</code> and
<code>siorder</code> are combined and the spectral parameters prepared.
</p>
<p>In principle, argument <code>root1</code> is sufficient, the other two
are for convenient specification of integration and seasonal
integration.
</p>
<p><strong>TODO:</strong> rename argument <code>root1</code>!
</p>


<h3>Value</h3>

<p>a list with the following components:
</p>
<table>
<tr><td><code>mo</code></td>
<td>
<p>multi-companion order</p>
</td></tr>
<tr><td><code>ev.type</code></td>
<td>
<p>type of the eigenvalues</p>
</td></tr>
<tr><td><code>co.type</code></td>
<td>
<p>not used currently (<strong>:todo:</strong>)</p>
</td></tr>
<tr><td><code>n.root</code></td>
<td>
<p>number of non-zero roots</p>
</td></tr>
<tr><td><code>ev.abs</code></td>
<td>
<p>absolute values of roots</p>
</td></tr>
<tr><td><code>ev.arg</code></td>
<td>
<p>arguments of eigenvalues (0 for positive ev)</p>
</td></tr>
<tr><td><code>block.length</code></td>
<td>
<p>lengths of Jordan blocks</p>
</td></tr>
<tr><td><code>co.abs</code></td>
<td>
<p>absolute values of seed parameters</p>
</td></tr>
<tr><td><code>co.arg</code></td>
<td>
<p>arguments of seed parameters (Hz: 0 for positive; 1/2 for negative)</p>
</td></tr>
<tr><td><code>co1</code></td>
<td>
<p>temporary hack; <strong>TODO:</strong> check the calling code and
remove it!</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcSpec">mcSpec</a></code>,
<code><a href="#topic+spec_root0">spec_root0</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spec_root1(4, root1 = 1)
spec_root1(4, root1 = c(1,0,0,0))  # same
spec_root1(4, iorder = 1)          # same

spec_root1(4, root1 = 2)
spec_root1(4, root1 = c(2,0,0,0))  # same
spec_root1(4, iorder = 2)          # same

spec_root1(4, root1 = c(1,1,1,1))
spec_root1(4, siorder = 1)          # same

spec_root1(4, root1 = c(2,2,2,2))
spec_root1(4, siorder = 2)          # same


spec_root1(4, root1 = c(2,1,1,1))
spec_root1(4, iorder = 1, siorder = 1) # same


spec_root1(4, root1 = c(2,1))
spec_root1(4, root1 = c(2,1,1))

</code></pre>

<hr>
<h2 id='spec_seeds1'>
Generate seed parameters for unit mc-eigenvectors
</h2><span id='topic+spec_seeds1'></span>

<h3>Description</h3>

<p>Generates seed parameters for mc-eigenvectors corresponding to unit
roots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spec_seeds1(len.block, mo)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spec_seeds1_+3A_len.block">len.block</code></td>
<td>

<p>lengths of Jordan blocks, a vector of positive integers.
</p>
</td></tr>
<tr><td><code id="spec_seeds1_+3A_mo">mo</code></td>
<td>
<p>multi-companion order.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates a matrix of seed parameters corresponding to unit eigenvalues
of a multi-companion matrix of multi-companion order <code>mo</code>.
<code>len.block</code> gives the sizes of the Jordan blocks corresponding to
eigenvalues equal to one.
</p>
<p>In general, the entries are filled with NA's but for some
configurations some (or even all) of the entries are uniquely
determined up to a linear transformation. In such cases a
&ldquo;canonical&rdquo; choice is made.
</p>
<p>The generated seed parameters can be considered to be <code>"top"</code> or
<code>"bottom"</code>, as needed. (<strong>TODO:</strong> check this claim, I have
forgotten the details but think that this is the reason that it is not
necessary to have an argument for the dimension of the matrix).
</p>
<p><code>spec_seeds1</code> can be used by model fitting functions to prepare
parameters for estimation but see <code><a href="#topic+spec_root1">spec_root1</a></code> and
<code><a href="#topic+mcSpec">mcSpec</a></code> for a more comprehensive treatment.
</p>


<h3>Value</h3>

<p>a matrix with <code>mo</code> rows and <code>sum(len.block)</code> columns
</p>


<h3>Note</h3>

<p>TODO: the treatment of &ldquo;canonical&rdquo; cases is incomplete, see also the
comments in the source code of the function.
</p>
<p>TODO: explain the <code>Inf</code> and <code>-Inf</code> output entries for some
configurations (e.g. the last example below).
</p>
<p>&quot;co&quot; in the name of <code>spec_seeds1</code> is short for coefficient.
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+spec_root1">spec_root1</a></code>,
<code><a href="#topic+mcSpec">mcSpec</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spec_seeds1(c(1), mo = 4)       # NA's
spec_seeds1(c(1,1), mo = 4)     # NA's
spec_seeds1(c(1,1,1), mo = 4)   # NA's (but for parameterisation
                            #     a different approach is used)
spec_seeds1(c(1,1,1,1), mo = 4) # identity matrix but other bases are good too
spec_seeds1(c(2,2,2,2), mo = 4) # no NA's, tops of gen.evecs can be chosen 0
spec_seeds1(c(2,1,1,1), mo = 4) # (can be improved)
spec_seeds1(c(2,1), mo = 4)     # NA's
</code></pre>

<hr>
<h2 id='VAR2pcfilter'>PAR representations of VAR models</h2><span id='topic+VAR2pcfilter'></span>

<h3>Description</h3>

<p>Give the univariate periodic autoregression representation of a VAR
model. Several arrangements are supported as discussed by
Boshnakov and Iqelan (2009). If the VAR model
contains unit roots on the unit circle, then the univariate model is
periodically integrated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VAR2pcfilter(phi, ..., Sigma, Phi0, Phi0inv, D, what = "coef", perm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VAR2pcfilter_+3A_phi">phi</code></td>
<td>
<p>VAR coefficients, a matrix, see Details.</p>
</td></tr>
<tr><td><code id="VAR2pcfilter_+3A_...">...</code></td>
<td>

<p>alternative way to specify the VAR coefficients by giving a matrix
for each lag in separate arguments, see section &lsquo;Details&rsquo;.
</p>
</td></tr>
<tr><td><code id="VAR2pcfilter_+3A_sigma">Sigma</code></td>
<td>
<p>covariance matrix of innovations.</p>
</td></tr>
<tr><td><code id="VAR2pcfilter_+3A_phi0">Phi0</code></td>
<td>
<p>coefficient matrix at lag 0 (alternative to <code>Sigma</code>).</p>
</td></tr>
<tr><td><code id="VAR2pcfilter_+3A_phi0inv">Phi0inv</code></td>
<td>
<p>inverse of <code>Phi0</code> (alternative to <code>Sigma</code> and
<code>Phi0</code>). If <code>Phi0inv</code> is lower triangular, then it is the
Cholesky factor of Sigma (in Sigma<code class="reqn">{} = LDL'</code>).</p>
</td></tr>
<tr><td><code id="VAR2pcfilter_+3A_d">D</code></td>
<td>
<p>the diagonal matrix corresponding to <code>Phi0</code>, not used if
<code>Sigma</code> is specified.
</p>
</td></tr>
<tr><td><code id="VAR2pcfilter_+3A_what">what</code></td>
<td>
<p>what to return, a string. If equal to <code>"coef"</code>,
return the PAR coefficients only (as a matrix with one row for each
&ldquo;season&rdquo;); if equal to <code>"coef.and.var"</code> return also the
innovation variances. Otherwise return additional quantities (useful
for exploration).
</p>
</td></tr>
<tr><td><code id="VAR2pcfilter_+3A_perm">perm</code></td>
<td>

<p>a permutation specifying the ordering of the variables when treated
as &ldquo;seasons&rdquo;. The default, <code>d:1</code>, corresponds to the U-form,
see section &lsquo;Details&rsquo;.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>VAR2pcfilter</code> converts a VAR model to a scalar periodic
autoregressive (PAR) model. There are various ways to specify a VAR
model and associate its variables with seasons of the scalar
representation, see Boshnakov and Iqelan (2009)
for a detailed discussion and the terminology used here.
</p>

<p>The VAR coefficients <code>phi,...</code> are those in the standard form of
the VAR model (e.g., see Boshnakov and Iqelan 2009).
There are two ways to specify them. The first is to put them side by
side in a matrix <code class="reqn">[\Phi_1, \ldots, \Phi_p]</code> and give this matrix
as argument <code>phi</code>. Alternatively, the matrices <code class="reqn">\Phi_i</code> may
be given directly as arguments to <code>VAR2pcfilter</code>, as in
<code>VAR2pcfilter(Phi1, Phi2, Phi3, Sigma = Sigma)</code>.
</p>
<p>The specification of the model can be completed by giving the
covariance matrix, <code>Sigma</code>, of the innovations.  Alternatively,
it is possible to give the components of the <code class="reqn">UDU'</code> decomposition
of <code>Sigma</code>. In this case argument <code>D</code> is a vector giving the
diagonal of the matrix <code class="reqn">D</code>, while <code>Phi0inv</code> represents the
upper triangular matrix <code class="reqn">U</code>. A further option is to use argument
<code>Phi0</code> to specify the inverse of <code class="reqn">U</code>. In summary, give either
<code>Sigma</code> or <code>D</code> and one of <code>Phi0inv</code> and <code>Phi0</code>.
</p>
<p><code>Phi0</code> can e interpreted as the coefficient at lag zero in the
U-form (Boshnakov and Iqelan 2009) of the VAR model.
<code>diag(D)</code> is the variance matrix of the innovations in that
form. <code>D</code> also gives the variances of the innovations in the PAR
(periodic autoregression) form.
</p>
<p>By default, <code>VAR2pcfilter</code> constructs the U-form of the VAR model
and extracts the coefficients of the PAR filter from it. This means
that the variables in the multivariate vector are given &ldquo;seasons&rdquo; in
reverse order (the first variable takes the last season, and so on).
For the reasons behind this default, see
Boshnakov and Iqelan (2009).  Another
arrangement can be chosen with the help of argument
<code>perm</code>. <code>perm</code> should be a permutation specifying the
desired allocation of variables to seasons. The default corresponds to
<code>perm=d:1</code>, where <code>d</code> is the number of
seasons. <code>perm=1:d</code> could be used to request the &ldquo;natural&rdquo;
order.
</p>
<p>When <code>D</code> and <code>Phi0inv</code> (or <code>Phi0</code>) are given, the
matrix <code>Sigma</code> is not computed if argument <code>perm</code> is missing
but it is if <code>perm</code> is present. This means that <code>perm = d:1</code>
may be used to force the formation of <code>Sigma</code> and recomputation
of <code>Phi0</code> and <code>Phi0inv</code>. This is redundant if the latter two
are unit upper-triangular (which is assumed but not checked) but may
be handy if, for example, the Cholesky decomposition with a lower
triangular matrix is available.
</p>


<h3>Value</h3>

<p>If <code>what="coef"</code>, a matrix containing the periodic model
coefficients (one row for each season).
</p>
<p>If <code>what="coef.and.var"</code>, a list containing the coefficients and
the innovations' variances:
</p>
<table>
<tr><td><code>pcfilter</code></td>
<td>
<p>PAR coefficients, a matrix</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>innovation variances, a vector</p>
</td></tr>
</table>
<p>Otherwise the returned list contains an additional component,
<code>Uform</code>, which is itself a list with components:
</p>
<table>
<tr><td><code>Sigma</code></td>
<td>
<p>covariance matrix of innovations,</p>
</td></tr>
<tr><td><code>U0</code></td>
<td>
<p>coefficient for lag zero,</p>
</td></tr>
<tr><td><code>U</code></td>
<td>
<p>the remaining AR coefficients,</p>
</td></tr>
<tr><td><code>U0inv</code></td>
<td>
<p>the inverse of <code>U0</code>,</p>
</td></tr>
<tr><td><code>perm</code></td>
<td>
<p>permutation giving the season of each variable.</p>
</td></tr>
</table>
<p>Note: <code>U0</code> and <code>U</code> correspond to <code class="reqn">A0</code> and <code class="reqn">A</code> in the
reference (Boshnakov and Iqelan 2009).
</p>


<h3>Note</h3>

<p>This function uses some non-exported internal functions:
</p>

<dl>
<dt>.ldl</dt><dd>
<p>Computes the LDL' Cholesky decomposition with unit
lower-triangular matrix L,
</p>
</dd>
<dt>.udu</dt><dd>
<p>Computes the UDU' Cholesky decomposition with unit
upper-triangular matrix U.
</p>
</dd>
</dl>

<p>Could export these if they are deemed more widely useful.
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>References</h3>

<p>Boshnakov GN, Iqelan BM (2009).
&ldquo;Generation of time series models with given spectral properties.&rdquo;
<em>J. Time Series Anal.</em>, <b>30</b>(3), 349&ndash;368.
ISSN 0143-9782, <a href="https://doi.org/10.1111/j.1467-9892.2009.00617.x">doi:10.1111/j.1467-9892.2009.00617.x</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mf_VSform">mf_VSform</a></code>,
<code><a href="#topic+sim_pcfilter">sim_pcfilter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## create a pc filter
rfi &lt;- sim_pcfilter(2,3)
rfi$pcfilter

## turn it into VAR form
flt &lt;- new("MultiFilter", coef = rfi$pcfilter)
I1 &lt;- mf_VSform(flt, form="I")
I1

## from VAR to scalar form
flt2 &lt;- VAR2pcfilter(I1$Phi, Sigma = I1$Phi0inv %*% t(I1$Phi0inv))
flt2

## confirm that we are back to the original
##   (VAR2pcfilter doesn't drop redundant zeroes, so we do it manually)
    all.equal(flt2[ , 1:3], rfi$pcfilter) ## TRUE
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
