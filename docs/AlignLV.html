<!DOCTYPE html><html lang="en"><head><title>Help for package AlignLV</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {AlignLV}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AlignLV-package'><p>AlignLV: Multiple Group Item Response Theory Alignment Helpers for 'lavaan' and 'mirt'</p></a></li>
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#align.optim'><p>Runs alignment optimizer</p></a></li>
<li><a href='#Alignment'><p>Multiple-Group Factor Analysis Alignment from <code>mirt</code> or <code>lavaan</code></p></a></li>
<li><a href='#getEstimates.lavaan'><p>Prepare <code>lavaan</code> estimates for alignment</p></a></li>
<li><a href='#getEstimates.mirt'><p>Prepare <code>mirt</code> estimates for alignment</p></a></li>
<li><a href='#loadEstimates.lavaan.ordered'><p>Estimate <code>lavaan</code> models using aligned parameter estimates</p></a></li>
<li><a href='#loadEstimates.mirt.grm'><p>Estimate <code>mirt</code> models using aligned parameter estimates</p></a></li>
<li><a href='#SF.mplus3D'><p>Simplicity function for alignment</p></a></li>
<li><a href='#stackEstimates'><p>Stack estimates for optimization</p></a></li>
<li><a href='#transformEstimates.lavaan.ordered'><p>Transform <code>lavaan</code> estimates using aligned estimates of latent</p>
mean and variance</a></li>
<li><a href='#transformEstimates.mirt.grm'><p>Transform <code>mirt</code> estimates using aligned estimates of latent mean</p>
and variance</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Multiple Group Item Response Theory Alignment Helpers for
'lavaan' and 'mirt'</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Allows for multiple group item response theory alignment a la 'Mplus' to be applied to lists of single-group models estimated in 'lavaan' or 'mirt'. Allows item sets that are overlapping but not identical, facilitating alignment in secondary data analysis where not all items may be shared across assessments.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>abind, mirt, lavaan, magrittr, purrr, stats, dplyr, tibble,
tidyr, rlang</td>
</tr>
<tr>
<td>Suggests:</td>
<td>doRNG, doParallel, foreach, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-10-03 18:51:44 UTC; Max</td>
</tr>
<tr>
<td>Author:</td>
<td>Maxwell Mansolf <a href="https://orcid.org/0000-0001-6861-8657"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Maxwell Mansolf &lt;maxwell.mansolf@northwestern.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-10-04 10:00:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='AlignLV-package'>AlignLV: Multiple Group Item Response Theory Alignment Helpers for 'lavaan' and 'mirt'</h2><span id='topic+AlignLV'></span><span id='topic+AlignLV-package'></span>

<h3>Description</h3>

<p>Allows for multiple group item response theory alignment a la 'Mplus' to be applied to lists of single-group models estimated in 'lavaan' or 'mirt'. Allows item sets that are overlapping but not identical, facilitating alignment in secondary data analysis where not all items may be shared across assessments.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Maxwell Mansolf <a href="mailto:maxwell.mansolf@northwestern.edu">maxwell.mansolf@northwestern.edu</a> (<a href="https://orcid.org/0000-0001-6861-8657">ORCID</a>)
</p>

<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling <code>rhs(lhs)</code>.
</p>

<hr>
<h2 id='align.optim'>Runs alignment optimizer</h2><span id='topic+align.optim'></span>

<h3>Description</h3>

<p>Not generally intended to be used on its own, but exported anyway
for didactic purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>align.optim(
  stacked,
  n,
  estimator,
  nstarts = 50,
  ncores = 3,
  hyper.first,
  center.means,
  eps.alignment,
  clf.ignore.quantile,
  verbose
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="align.optim_+3A_stacked">stacked</code></td>
<td>
<p>Stacked parameter estimates from <code><a href="#topic+stackEstimates">stackEstimates</a></code></p>
</td></tr>
<tr><td><code id="align.optim_+3A_n">n</code></td>
<td>
<p>Sample size in each group</p>
</td></tr>
<tr><td><code id="align.optim_+3A_estimator">estimator</code></td>
<td>
<p>See <code><a href="#topic+Alignment">Alignment</a></code> documentation.</p>
</td></tr>
<tr><td><code id="align.optim_+3A_nstarts">nstarts</code></td>
<td>
<p>Number of starting values for alignment; default is 10</p>
</td></tr>
<tr><td><code id="align.optim_+3A_ncores">ncores</code></td>
<td>
<p>See <code><a href="#topic+Alignment">Alignment</a></code> documentation.</p>
</td></tr>
<tr><td><code id="align.optim_+3A_hyper.first">hyper.first</code></td>
<td>
<p>See <code><a href="#topic+Alignment">Alignment</a></code> documentation.</p>
</td></tr>
<tr><td><code id="align.optim_+3A_center.means">center.means</code></td>
<td>
<p>See <code><a href="#topic+Alignment">Alignment</a></code> documentation.</p>
</td></tr>
<tr><td><code id="align.optim_+3A_eps.alignment">eps.alignment</code></td>
<td>
<p>See <code><a href="#topic+Alignment">Alignment</a></code> documentation.</p>
</td></tr>
<tr><td><code id="align.optim_+3A_clf.ignore.quantile">clf.ignore.quantile</code></td>
<td>
<p>See <code><a href="#topic+Alignment">Alignment</a></code> documentation.</p>
</td></tr>
<tr><td><code id="align.optim_+3A_verbose">verbose</code></td>
<td>
<p>See <code><a href="#topic+Alignment">Alignment</a></code> documentation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See example for <code><a href="#topic+Alignment">Alignment</a></code> for examples
</p>


<h3>Value</h3>

<p>A <code>list</code> of results from multiple runs of the alignment optimizer:
</p>

<ul>
<li> <p><code>mv</code> Means and variances from each alignment run.
</p>
</li>
<li> <p><code>parout</code> A table of outputs from <code>link[stats]{optim}</code> containing the
function values, convergence information, and resulting estimates of means
and variances from each run.
</p>
</li>
<li> <p><code>nFailedRuns</code> The number of runs that failed to complete. An error is
returned if no runs fail.
</p>
</li></ul>


<hr>
<h2 id='Alignment'>Multiple-Group Factor Analysis Alignment from <code>mirt</code> or <code>lavaan</code></h2><span id='topic+Alignment'></span>

<h3>Description</h3>

<p>Performs alignment (<a href="https://www.statmodel.com/Alignment.shtml">https://www.statmodel.com/Alignment.shtml</a>) using
single-group models estimated in mirt or lavaan.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Alignment(
  fitList,
  estimator,
  SE = FALSE,
  eps.alignment = 0.01,
  clf.ignore.quantile = 0.1,
  bifactor.marginal = FALSE,
  hyper.first = "variances",
  center.means = TRUE,
  nstarts = 10,
  ncores = 1,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Alignment_+3A_fitlist">fitList</code></td>
<td>
<p>A <code>list</code> of fitted model objects. Currently only works
for single-group, unidimensional or bifactor models with no covariates
estimated in <code>mirt</code> or <code>lavaan</code>.</p>
</td></tr>
<tr><td><code id="Alignment_+3A_estimator">estimator</code></td>
<td>
<p>The model type used, either <code>'mirt.grm'</code> for the graded
response model estimated in <code>mirt</code> or <code>'lavaan.ordered'</code> for the
categorical factor analysis model applied by <code>lavaan</code> when the
<code>ordered</code> input includes all variables in the model.</p>
</td></tr>
<tr><td><code id="Alignment_+3A_se">SE</code></td>
<td>
<p>Whether to also return standard errors from parameter estimates
after alignment. SE's are transformed using the delta method from those
provided in the original model objects, which must (for <code>mirt</code>), have
been fitted with standard errors estimated (<code>SE=TRUE</code>).</p>
</td></tr>
<tr><td><code id="Alignment_+3A_eps.alignment">eps.alignment</code></td>
<td>
<p>A numeric scalar for the alignment simplicity function,
given by (Asparouhov &amp; Muthén, 2014, <em>Structural Equation Modeling</em>):
</p>
<p style="text-align: center;"><code class="reqn">\sqrt{\sqrt{x^2+\epsilon}}</code>
</p>

<p>where $x$ is the difference between corresponding estimates in each pair of
aligned models. Lower values may cause numerical instability; default 0.01</p>
</td></tr>
<tr><td><code id="Alignment_+3A_clf.ignore.quantile">clf.ignore.quantile</code></td>
<td>
<p>Another protection from numerical instability;
CLF values less than the <code>clf.ignore.quantile</code> of the full set of CLF
values are ignored when calculating the complexity function at each step.
Default 0.1 for removing the lowest 10% of CLF values.</p>
</td></tr>
<tr><td><code id="Alignment_+3A_bifactor.marginal">bifactor.marginal</code></td>
<td>
<p>A logical scalar indicating whether, for bifactor
models, alignment should take place on the marginal, rather than conditional,
metric for slopes (Ip, 2010, <em>Applied Psychological Measurement</em>).</p>
</td></tr>
<tr><td><code id="Alignment_+3A_hyper.first">hyper.first</code></td>
<td>
<p>A string scalar denoting which hyperparameter to align
first. Asparouhov &amp; Muthén (2014) align all parameters simultaneously
(<code>'no'</code>); <code>'variances'</code> (default) performs a two-step process,
first aligning variances, then aligning means conditional on variance
estimates from the first step. <code>'means'</code> does the reverse.</p>
</td></tr>
<tr><td><code id="Alignment_+3A_center.means">center.means</code></td>
<td>
<p>A logical scalar. Alignment fixes the first group's mean
to zero to estimate the others. If <code>center.means</code> is <code>TRUE</code>
(default), aligned means and models are returned after subtracting the
weighted mean <code><a href="stats.html#topic+weighted.mean">weighted.mean</a></code> from all mean estimates,
yielding
a (weighted) grand mean of zero. Variances are automatically rescaled such
that their weighted product (i.e., log of weighted mean of
<code>e^(variance)</code>) is 1.</p>
</td></tr>
<tr><td><code id="Alignment_+3A_nstarts">nstarts</code></td>
<td>
<p>Number of starting values for alignment; default is 10</p>
</td></tr>
<tr><td><code id="Alignment_+3A_ncores">ncores</code></td>
<td>
<p>Number of processor cores to distribute alignment starts
across; on systems that support multicore processing, using additional cores
can speed up the alignment step by roughly a factor of the number of cores.
Defaults to 1 for no parallel processing. Requires the <code>doRNG</code>
package and defaults to sequential processing if not installed.</p>
</td></tr>
<tr><td><code id="Alignment_+3A_verbose">verbose</code></td>
<td>
<p>Whether stuff gets printed to the console. May
help with debugging.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, no automated process provides statistical tests for DIF.
Instead, I recommend interpreting the DIF impact directly by comparing
scores obtained from a single-group model combining all groups, and the
multiple models produced by <code>Alignment</code>. If standard errors
are requested from <code><a href="#topic+getEstimates.mirt">getEstimates.mirt</a></code>, or
<code><a href="#topic+getEstimates.lavaan">getEstimates.lavaan</a></code>, and then the corresponding
<code><a href="#topic+transformEstimates.mirt.grm">transformEstimates.mirt.grm</a></code> or
<code><a href="#topic+transformEstimates.lavaan.ordered">transformEstimates.lavaan.ordered</a></code> is applied, SE's after
alignment can be
obtained and used for multiple comparison testing, but this is not yet
automated. Alternatively, consider re-fitting models with means and
variances fixed to those obtained from alignment to obtain these standard
errors. In the latter case, especially when priors are used as in
<code>mirt</code>, your estimates may not match those from <code>Alignment</code>
exactly.
</p>
<p>For <code>lavaan</code>, the metric for alignment must be the &quot;theta&quot;
parameterization, which is not the default, in order to properly search for
latent means and variances, because only then do the transformations apply.
My current thinking: under the delta parameterization, the transformed
estimates (calculate delta, incorporate it into parameters, then
transform parameters, BUT don't reverse the delta transformation) do NOT
yield an equivalent model, but DO yield a model that can be compared
across groups. In order to get an equivalent model, you also need to
reverse the delta transformation at the end. To account for this, if
the the extra argument toCompare should be turned on <code>TRUE</code> if
transformed parameters are to be compared for equivalence across groups.
Turning it off results in NOT applying the reverse of the delta
transformation at the end. This currently is fixed to TRUE and cannot
be modified, but you can access
<code><a href="#topic+transformEstimates.lavaan.ordered">transformEstimates.lavaan.ordered</a></code>
directly if you want to play around.
</p>
<p>If <code>parallel==TRUE</code>, a parallel backend with the <code>doParallel</code> package
leverages multi-core processing if the number of cores specified in
<code>ncores</code> is greater than one. Uses <code><a href="doRNG.html#topic++25dorng+25">%dorng%</a></code> to pass the
R session's seed to the alignment optimizer, such that you can replicate
random starts with <code>set.seed</code> (see example).
</p>
<p>This program was designed based on the published work of Asparouhov &amp; Muthen,
and was not intended to match Mplus exactly, and may not.
</p>


<h3>Value</h3>

<p>A <code>list</code> with the following elements:
</p>

<ul>
<li> <p><code>fit</code> A <code>list</code> of fitted objects of type <code>mirt</code> or <code>lavaan</code>,
depending
on the estimator, where models were re-estimated with means and variances
set to those obtained from alignment.
</p>
</li>
<li> <p><code>est.og</code> A nested <code>list</code> of parameter estimates and standard errors
provided to
the alignment optimizer from the provided models. Each element corresponds
to a provided model, and each element thereof corresponds to a parameter
name (e.g., <code>a</code> and <code>d</code> parameters from <code>mirt.grm</code>) and contains a matrix of
the corresponding estimates.
</p>
</li>
<li> <p><code>est</code> The estimates from <code>est.og</code>, transformed after alignment using the
obtained mean and variance estimates therefrom.
</p>
</li>
<li> <p><code>hypers</code> A <code>list</code> of two-element numeric vectors, where <code>mean</code> gives the
estimated mean from alignment in the corresponding group, and <code>var</code> the
estimated variance.
</p>
</li>
<li> <p><code>parout</code> Optimizer output for the alignment step, used to examine
convergence. Contains the following columns:
</p>

<ul>
<li> <p><code>f</code> The final complexity function value from alignment.
</p>
</li>
<li> <p><code>convergence</code> The <code>convergence</code> output from <code><a href="stats.html#topic+optim">optim</a></code>
</p>
</li>
<li> <p><code>M.2</code> to <code>M.</code>(number of groups minus 2) The estimated means from
alignment
</p>
</li>
<li> <p><code>V.2</code> to <code>M.</code>(number of groups minus 2) The estimated variances from
alignment
</p>
</li></ul>

</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>#load data
library(mirt)
library(lavaan)
library(purrr)
library(tibble)
library(magrittr)
dat=expand.table(Bock1997)
#fit configural models
fit.mirt=mirt(dat,1,SE=TRUE)
fit.lavaan=cfa(model='G =~ Item.1+Item.2+Item.3',data=dat,
               ordered=c('Item.1','Item.2','Item.3'),
               std.lv=TRUE,parameterization='delta')
(fit.lavaan@ParTable)%&gt;%tibble::as_tibble()%&gt;%print(n=Inf)
#test stuff
tab=fit.lavaan@ParTable
tab$start[23]=3
tab$est[23]=3
fit.lavaan2=lavaan(tab,data=fit.lavaan@Data)

#get estimates
est.mirt=getEstimates.mirt(fit.mirt,SE=TRUE,bifactor.marginal=FALSE)
est.lavaan=getEstimates.lavaan(fit.lavaan,SE=TRUE)

#test transformations
newMean=10
newVar=2
test.mirt=transformEstimates.mirt.grm(newMean,newVar,est.mirt)
test.lavaan=transformEstimates.lavaan.ordered(
              newMean,newVar,est.lavaan,toCompare=TRUE)
#load and test equivalence
tfit.mirt=loadEstimates.mirt.grm(fit.mirt,newMean,newVar,newpars=test.mirt,
                                 verbose=TRUE)
test.mirt=mirt::coef(fit.mirt)
test.mirt
tfit.lavaan=loadEstimates.lavaan.ordered(
              fit.lavaan,newMean,newVar,newpars=test.lavaan,
              verbose=TRUE)
tfit.lavaan@ParTable%&gt;%tibble::as_tibble()%&gt;%print(n=Inf)
test.lavaan

#now on stacked estimates
estList=list(est.mirt%&gt;%purrr::imap(function(x,n){
  rownames(x)[2]=paste0(rownames(x)[2],'_ho')
  if(!n%in%c('a','se.a'))colnames(x)[2]=paste0(colnames(x)[2],'_ho')
  x
}),est.mirt%&gt;%purrr::imap(function(x,n){
  rownames(x)[1]=paste0(rownames(x)[1],'_hi')
  if(!n%in%c('a','se.a'))colnames(x)[1]=paste0(colnames(x)[1],'_hi')
  x
}))
stack=stackEstimates(estList)
test.stack=transformEstimates.mirt.grm(c(0,0),c(1,1),stack)
sf.stack=SF.mplus3D(c(0,1),stack,combn(1:2,2),c(100,200),'mirt.grm',
                                       eps.alignment=0.01,
                                       clf.ignore.quantile=0.1)
test.stack2=transformEstimates.mirt.grm(c(0,1),c(1,1/2),stack)

#try align?
#lavaan
set.seed(0)
sim.base=list(simdata(a=as.numeric(est.mirt$a),d=est.mirt$d,N=5000,
                      itemtype='graded',sigma=matrix(1),mu=0),
              simdata(a=as.numeric(est.mirt$a),d=est.mirt$d,N=5000,
                      itemtype='graded',sigma=matrix(2),mu=1))
fit.base=sim.base%&gt;%purrr::map(~cfa(model="G =~ Item_1 + Item_2 + Item_3",
                             data=as.data.frame(.),
                             ordered=paste0('Item_',1:3),std.lv=TRUE,
                             parameterization='delta'))
fit.base%&gt;%purrr::map(lavInspect,'est')%&gt;%purrr::transpose()
est.base=purrr::map(fit.base,getEstimates.lavaan,SE=TRUE)
#not run: using parallel processes with ncores=3
set.seed(1)
# align.stack=align.optim(stackEstimates(est.base),c(100,200),nstarts=3,
#                         hyper.first='variances',ncores=3,
#                         eps.alignment=0.01,clf.ignore.quantile=0.1,
#                        estimator='lavaan.ordered',center.means=FALSE,
#                        verbose=TRUE)
# #same seed
# set.seed(1)
# align.stack=align.optim(stackEstimates(est.base),c(100,200),nstarts=3,
#                         hyper.first='variances',ncores=3,
#                         eps.alignment=0.01,clf.ignore.quantile=0.1,
#                         estimator='lavaan.ordered',center.means=FALSE,
#                         verbose=TRUE)
#sequential
align.stack=align.optim(stackEstimates(est.base),c(100,200),nstarts=3,
                        hyper.first='variances',ncores=1,
                        eps.alignment=0.01,clf.ignore.quantile=0.1,
                        estimator='lavaan.ordered',center.means=FALSE,
                        verbose=TRUE)
align.stack
fit.align=Alignment(fit.base,'lavaan.ordered',center.means=FALSE,SE=TRUE,
            verbose=TRUE)

#mirt
fit.base2=list()
for(i in 1:length(sim.base)){
  fit.base2[[i]]=mirt(sim.base[[i]],1,'graded',SE=TRUE)
}
est.base2=purrr::map(fit.base2,getEstimates.mirt,SE=TRUE,
bifactor.marginal=FALSE)
#not run: using parallel processes with ncores=3
# align.stack2=align.optim(stackEstimates(est.base2),c(100,200),nstarts=3,
#                          hyper.first='variances',ncores=3,
#                          eps.alignment=0.01,clf.ignore.quantile=0.1,
#                          estimator='mirt.grm',center.means=FALSE)
align.stack2=align.optim(stackEstimates(est.base2),c(100,200),nstarts=3,
                         hyper.first='variances',ncores=1,
                         eps.alignment=0.01,clf.ignore.quantile=0.1,
                         estimator='mirt.grm',center.means=FALSE,
                         verbose=TRUE)
align.stack2
fit.align2=Alignment(fit.base2,'mirt.grm',center.means=FALSE,SE=TRUE)

#did it work?
fit.align$hypers
fit.align2$hypers
fit.align$est%&gt;%purrr::transpose()%&gt;%purrr::map(~mean(.[[1]]-.[[2]]))
fit.align2$est%&gt;%purrr::transpose()%&gt;%purrr::map(~mean(.[[1]]-.[[2]]))
fit.align$fit
fit.align2$fit
(fit.align$fit%&gt;%purrr::map(~.@ParTable%&gt;%
tibble::as_tibble()%&gt;%dplyr::filter(free!=0))%&gt;%
  purrr::transpose())[c('start','est')]%&gt;%purrr::map(~mean(.[[1]]-.[[2]]))
(fit.align2$fit%&gt;%purrr::map(coef)%&gt;%
    purrr::transpose())[paste0('Item_',1:3)]%&gt;%
    purrr::map(~mean(.[[1]]-.[[2]]))
#appears so!

</code></pre>

<hr>
<h2 id='getEstimates.lavaan'>Prepare <code>lavaan</code> estimates for alignment</h2><span id='topic+getEstimates.lavaan'></span>

<h3>Description</h3>

<p>Not generally intended to be used on its own, but exported anyway for
didactic purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getEstimates.lavaan(fit, SE = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getEstimates.lavaan_+3A_fit">fit</code></td>
<td>
<p>A <code>lavaan</code> object compatible with <code><a href="#topic+Alignment">Alignment</a></code></p>
</td></tr>
<tr><td><code id="getEstimates.lavaan_+3A_se">SE</code></td>
<td>
<p>logical; whether to also obtain standard errors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See example for <code><a href="#topic+Alignment">Alignment</a></code> for examples
</p>
<p>This program was designed based on the published work of Asparouhov &amp;
Muthen, and was not intended to match Mplus exactly, and may not.
</p>


<h3>Value</h3>

<p>A <code>list</code> of estimates in a format amenable to subsequent alignment
</p>

<hr>
<h2 id='getEstimates.mirt'>Prepare <code>mirt</code> estimates for alignment</h2><span id='topic+getEstimates.mirt'></span>

<h3>Description</h3>

<p>Not generally intended to be used on its own, but exported anyway for
didactic purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getEstimates.mirt(fit, SE = FALSE, bifactor.marginal = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getEstimates.mirt_+3A_fit">fit</code></td>
<td>
<p>A <code>mirt</code> object compatible with <code><a href="#topic+Alignment">Alignment</a></code></p>
</td></tr>
<tr><td><code id="getEstimates.mirt_+3A_se">SE</code></td>
<td>
<p>logical; whether to also obtain standard errors.</p>
</td></tr>
<tr><td><code id="getEstimates.mirt_+3A_bifactor.marginal">bifactor.marginal</code></td>
<td>
<p>See <code><a href="#topic+Alignment">Alignment</a></code> documentation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See example for <code><a href="#topic+Alignment">Alignment</a></code> for examples
</p>
<p>This program was designed based on the published work of Asparouhov &amp; Muthen,
and was not intended to match Mplus exactly, and may not.
</p>


<h3>Value</h3>

<p>A <code>list</code> of estimates in a format amenable to subsequent alignment
</p>

<hr>
<h2 id='loadEstimates.lavaan.ordered'>Estimate <code>lavaan</code> models using aligned parameter estimates</h2><span id='topic+loadEstimates.lavaan.ordered'></span>

<h3>Description</h3>

<p>Not generally intended to be used on its own, but exported anyway for
didactic purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadEstimates.lavaan.ordered(
  fit,
  align.mean,
  align.variance,
  newpars,
  do.fit = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loadEstimates.lavaan.ordered_+3A_fit">fit</code></td>
<td>
<p>A <code>mirt</code> object compatible with <code><a href="#topic+Alignment">Alignment</a></code></p>
</td></tr>
<tr><td><code id="loadEstimates.lavaan.ordered_+3A_align.mean">align.mean</code></td>
<td>
<p>Mean to transform model to.</p>
</td></tr>
<tr><td><code id="loadEstimates.lavaan.ordered_+3A_align.variance">align.variance</code></td>
<td>
<p>Variance to transform model to.</p>
</td></tr>
<tr><td><code id="loadEstimates.lavaan.ordered_+3A_newpars">newpars</code></td>
<td>
<p>New (transformed) estimates to load into model object.</p>
</td></tr>
<tr><td><code id="loadEstimates.lavaan.ordered_+3A_do.fit">do.fit</code></td>
<td>
<p>Whether to re-fit the model after loading and fixing estimates.</p>
</td></tr>
<tr><td><code id="loadEstimates.lavaan.ordered_+3A_verbose">verbose</code></td>
<td>
<p>See <code><a href="#topic+Alignment">Alignment</a></code> documentation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See example for <code><a href="#topic+Alignment">Alignment</a></code> for examples
</p>
<p>This program was designed based on the published work of Asparouhov &amp; Muthen,
and was not intended to match Mplus exactly, and may not.
</p>


<h3>Value</h3>

<p>A <code>lavaan</code> object, based on <code>fit</code> but with modified
parameters.
</p>

<hr>
<h2 id='loadEstimates.mirt.grm'>Estimate <code>mirt</code> models using aligned parameter estimates</h2><span id='topic+loadEstimates.mirt.grm'></span>

<h3>Description</h3>

<p>Not generally intended to be used on its own, but exported anyway for
didactic purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadEstimates.mirt.grm(
  fit,
  align.mean,
  align.variance,
  newpars,
  do.fit = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loadEstimates.mirt.grm_+3A_fit">fit</code></td>
<td>
<p>A <code>mirt</code> object compatible with <code><a href="#topic+Alignment">Alignment</a></code></p>
</td></tr>
<tr><td><code id="loadEstimates.mirt.grm_+3A_align.mean">align.mean</code></td>
<td>
<p>Mean to transform model to.</p>
</td></tr>
<tr><td><code id="loadEstimates.mirt.grm_+3A_align.variance">align.variance</code></td>
<td>
<p>Variance to transform model to.</p>
</td></tr>
<tr><td><code id="loadEstimates.mirt.grm_+3A_newpars">newpars</code></td>
<td>
<p>New (transformed) estimates to load into model object.</p>
</td></tr>
<tr><td><code id="loadEstimates.mirt.grm_+3A_do.fit">do.fit</code></td>
<td>
<p>Whether to re-fit the model after loading and fixing estimates.</p>
</td></tr>
<tr><td><code id="loadEstimates.mirt.grm_+3A_verbose">verbose</code></td>
<td>
<p>See <code><a href="#topic+Alignment">Alignment</a></code> documentation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See example for <code><a href="#topic+Alignment">Alignment</a></code> for examples
</p>
<p>This program was designed based on the published work of Asparouhov &amp; Muthen,
and was not intended to match Mplus exactly, and may not.
</p>


<h3>Value</h3>

<p>A <code>mirt</code>, object based on <code>fit</code> but with modified
parameters.
</p>

<hr>
<h2 id='SF.mplus3D'>Simplicity function for alignment</h2><span id='topic+SF.mplus3D'></span>

<h3>Description</h3>

<p>Not generally intended to be used on its own, but exported anyway for
didactic purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SF.mplus3D(
  pars,
  est,
  comb,
  nobs,
  estimator,
  eps.alignment,
  clf.ignore.quantile,
  hyper = "all",
  otherHyper = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SF.mplus3D_+3A_pars">pars</code></td>
<td>
<p>Hyperparameters to feed into optimizer</p>
</td></tr>
<tr><td><code id="SF.mplus3D_+3A_est">est</code></td>
<td>
<p>Estimates to transform, from <code><a href="#topic+getEstimates.mirt">getEstimates.mirt</a></code> or
<code><a href="#topic+getEstimates.lavaan">getEstimates.lavaan</a></code></p>
</td></tr>
<tr><td><code id="SF.mplus3D_+3A_comb">comb</code></td>
<td>
<p>All combinations of groups from <code><a href="utils.html#topic+combn">combn</a></code></p>
</td></tr>
<tr><td><code id="SF.mplus3D_+3A_nobs">nobs</code></td>
<td>
<p>Sample size in each group</p>
</td></tr>
<tr><td><code id="SF.mplus3D_+3A_estimator">estimator</code></td>
<td>
<p>See <code><a href="#topic+Alignment">Alignment</a></code> documentation.</p>
</td></tr>
<tr><td><code id="SF.mplus3D_+3A_eps.alignment">eps.alignment</code></td>
<td>
<p>See <code><a href="#topic+Alignment">Alignment</a></code> documentation.</p>
</td></tr>
<tr><td><code id="SF.mplus3D_+3A_clf.ignore.quantile">clf.ignore.quantile</code></td>
<td>
<p>See <code><a href="#topic+Alignment">Alignment</a></code> documentation.</p>
</td></tr>
<tr><td><code id="SF.mplus3D_+3A_hyper">hyper</code></td>
<td>
<p>Hyperparameter to calculate simplicity function for; see
<code><a href="#topic+Alignment">Alignment</a></code> documentation.</p>
</td></tr>
<tr><td><code id="SF.mplus3D_+3A_otherhyper">otherHyper</code></td>
<td>
<p>Non-included hyperparameter</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See example for <code><a href="#topic+Alignment">Alignment</a></code> for examples
</p>
<p>This program was designed based on the published work of Asparouhov &amp; Muthen,
and was not intended to match Mplus exactly, and may not.
</p>


<h3>Value</h3>

<p>A value of the simplicity function from Asparouhuv &amp; Muthen, 2014.
</p>

<hr>
<h2 id='stackEstimates'>Stack estimates for optimization</h2><span id='topic+stackEstimates'></span>

<h3>Description</h3>

<p>Not generally intended to be used on its own, but exported anyway for
didactic purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stackEstimates(estList)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stackEstimates_+3A_estlist">estList</code></td>
<td>
<p>List of estimates from <code><a href="#topic+getEstimates.lavaan">getEstimates.lavaan</a></code> or
<code><a href="#topic+getEstimates.mirt">getEstimates.mirt</a></code> to stack to feed into
<code><a href="#topic+SF.mplus3D">SF.mplus3D</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>See example for <code><a href="#topic+Alignment">Alignment</a></code> for examples
</p>


<h3>Value</h3>

<p>A set of estimates prepared for efficient use with
<code><a href="#topic+SF.mplus3D">SF.mplus3D</a></code>
</p>

<hr>
<h2 id='transformEstimates.lavaan.ordered'>Transform <code>lavaan</code> estimates using aligned estimates of latent
mean and variance</h2><span id='topic+transformEstimates.lavaan.ordered'></span>

<h3>Description</h3>

<p>Not generally intended to be used on its own, but exported anyway for
didactic purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transformEstimates.lavaan.ordered(
  align.mean,
  align.variance,
  est,
  toCompare = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transformEstimates.lavaan.ordered_+3A_align.mean">align.mean</code></td>
<td>
<p>Mean to transform model to.</p>
</td></tr>
<tr><td><code id="transformEstimates.lavaan.ordered_+3A_align.variance">align.variance</code></td>
<td>
<p>Variance to transform model to.</p>
</td></tr>
<tr><td><code id="transformEstimates.lavaan.ordered_+3A_est">est</code></td>
<td>
<p>Estimates to transform, from <code><a href="#topic+getEstimates.lavaan">getEstimates.lavaan</a></code></p>
</td></tr>
<tr><td><code id="transformEstimates.lavaan.ordered_+3A_tocompare">toCompare</code></td>
<td>
<p>Accounts for discrepancies between delta and theta
parameterizations; see <code><a href="#topic+Alignment">Alignment</a></code> documentation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See example for <code><a href="#topic+Alignment">Alignment</a></code> for examples
</p>
<p>This program was designed based on the published work of Asparouhov &amp; Muthen,
and was not intended to match Mplus exactly, and may not.
</p>


<h3>Value</h3>

<p>Estimates in the same structure as from
<code><a href="#topic+getEstimates.lavaan">getEstimates.lavaan</a></code>, but transformed from (assumed) mean 0 and
variance 1 to the metric specified by <code>align.mean</code> and <code>align.variance</code>.
</p>

<hr>
<h2 id='transformEstimates.mirt.grm'>Transform <code>mirt</code> estimates using aligned estimates of latent mean
and variance</h2><span id='topic+transformEstimates.mirt.grm'></span>

<h3>Description</h3>

<p>Not generally intended to be used on its own, but exported anyway for
didactic purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transformEstimates.mirt.grm(align.mean, align.variance, est)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transformEstimates.mirt.grm_+3A_align.mean">align.mean</code></td>
<td>
<p>Mean to transform model to.</p>
</td></tr>
<tr><td><code id="transformEstimates.mirt.grm_+3A_align.variance">align.variance</code></td>
<td>
<p>Variance to transform model to.</p>
</td></tr>
<tr><td><code id="transformEstimates.mirt.grm_+3A_est">est</code></td>
<td>
<p>Estimates to transform, from <code><a href="#topic+getEstimates.mirt">getEstimates.mirt</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>See example for <code><a href="#topic+Alignment">Alignment</a></code> for examples
</p>
<p>This program was designed based on the published work of Asparouhov &amp; Muthen,
and was not intended to match Mplus exactly, and may not.
</p>


<h3>Value</h3>

<p>Estimates in the same structure as from
<code><a href="#topic+getEstimates.mirt">getEstimates.mirt</a></code>, but transformed from (assumed) mean 0 and
variance 1 to the metric specified by <code>align.mean</code> and <code>align.variance</code>.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
