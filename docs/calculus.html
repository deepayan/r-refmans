<!DOCTYPE html><html><head><title>Help for package calculus</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {calculus}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#calculus-package'><p>calculus: High Dimensional Numerical and Symbolic Calculus</p></a></li>
<li><a href='#+25diff+25'><p>Numerical and Symbolic Difference</p></a></li>
<li><a href='#+25div+25'><p>Numerical and Symbolic Division</p></a></li>
<li><a href='#+25dot+25'><p>Numerical and Symbolic Dot Product</p></a></li>
<li><a href='#+25inner+25'><p>Numerical and Symbolic Inner Product</p></a></li>
<li><a href='#+25kronecker+25'><p>Numerical and Symbolic Kronecker Product</p></a></li>
<li><a href='#+25outer+25'><p>Numerical and Symbolic Outer Product</p></a></li>
<li><a href='#+25prod+25'><p>Numerical and Symbolic Product</p></a></li>
<li><a href='#+25sum+25'><p>Numerical and Symbolic Sum</p></a></li>
<li><a href='#c2e'><p>Characters to Expressions</p></a></li>
<li><a href='#contraction'><p>Numerical and Symbolic Tensor Contraction</p></a></li>
<li><a href='#cross'><p>Numerical and Symbolic Cross Product</p></a></li>
<li><a href='#curl'><p>Numerical and Symbolic Curl</p></a></li>
<li><a href='#delta'><p>Generalized Kronecker Delta</p></a></li>
<li><a href='#derivative'><p>Numerical and Symbolic Derivatives</p></a></li>
<li><a href='#diagonal'><p>Tensor Diagonals</p></a></li>
<li><a href='#divergence'><p>Numerical and Symbolic Divergence</p></a></li>
<li><a href='#e2c'><p>Expressions to Characters</p></a></li>
<li><a href='#einstein'><p>Numerical and Symbolic Einstein Summation</p></a></li>
<li><a href='#epsilon'><p>Levi-Civita Symbol</p></a></li>
<li><a href='#evaluate'><p>Evaluate Characters and Expressions</p></a></li>
<li><a href='#gradient'><p>Numerical and Symbolic Gradient</p></a></li>
<li><a href='#hermite'><p>Hermite Polynomials</p></a></li>
<li><a href='#hessian'><p>Numerical and Symbolic Hessian</p></a></li>
<li><a href='#index'><p>Tensor Indices</p></a></li>
<li><a href='#integral'><p>Numerical Integration</p></a></li>
<li><a href='#jacobian'><p>Numerical and Symbolic Jacobian</p></a></li>
<li><a href='#laplacian'><p>Numerical and Symbolic Laplacian</p></a></li>
<li><a href='#mx'><p>Numerical and Symbolic Matrix Product</p></a></li>
<li><a href='#mxdet'><p>Numerical and Symbolic Determinant</p></a></li>
<li><a href='#mxinv'><p>Numerical and Symbolic Matrix Inverse</p></a></li>
<li><a href='#mxtr'><p>Numerical and Symbolic Matrix Trace</p></a></li>
<li><a href='#ode'><p>Ordinary Differential Equations</p></a></li>
<li><a href='#partitions'><p>Integer Partitions</p></a></li>
<li><a href='#taylor'><p>Taylor Series Expansion</p></a></li>
<li><a href='#wrap'><p>Wrap Characters in Parentheses</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>High Dimensional Numerical and Symbolic Calculus</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Efficient C++ optimized functions for numerical and symbolic calculus as described in Guidotti (2022) &lt;<a href="https://doi.org/10.18637%2Fjss.v104.i05">doi:10.18637/jss.v104.i05</a>&gt;. It includes basic arithmetic, tensor calculus, Einstein summing convention, fast computation of the Levi-Civita symbol and generalized Kronecker delta, Taylor series expansion, multivariate Hermite polynomials, high-order derivatives, ordinary differential equations, differential operators (Gradient, Jacobian, Hessian, Divergence, Curl, Laplacian) and numerical integration in arbitrary orthogonal coordinate systems: cartesian, polar, spherical, cylindrical, parabolic or user defined by custom scale factors. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://calculus.eguidotti.com">https://calculus.eguidotti.com</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/eguidotti/calculus/issues">https://github.com/eguidotti/calculus/issues</a></td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.1)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>cubature, testthat, knitr, rmarkdown</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-09 22:28:41 UTC; eguidotti</td>
</tr>
<tr>
<td>Author:</td>
<td>Emanuele Guidotti <a href="https://orcid.org/0000-0002-8961-6623"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Emanuele Guidotti &lt;emanuele.guidotti@unine.ch&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-09 23:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='calculus-package'>calculus: High Dimensional Numerical and Symbolic Calculus</h2><span id='topic+calculus'></span><span id='topic+calculus-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Efficient C++ optimized functions for numerical and symbolic calculus as described in Guidotti (2022) <a href="https://doi.org/10.18637/jss.v104.i05">doi:10.18637/jss.v104.i05</a>. It includes basic arithmetic, tensor calculus, Einstein summing convention, fast computation of the Levi-Civita symbol and generalized Kronecker delta, Taylor series expansion, multivariate Hermite polynomials, high-order derivatives, ordinary differential equations, differential operators (Gradient, Jacobian, Hessian, Divergence, Curl, Laplacian) and numerical integration in arbitrary orthogonal coordinate systems: cartesian, polar, spherical, cylindrical, parabolic or user defined by custom scale factors.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Emanuele Guidotti <a href="mailto:emanuele.guidotti@unine.ch">emanuele.guidotti@unine.ch</a> (<a href="https://orcid.org/0000-0002-8961-6623">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://calculus.eguidotti.com">https://calculus.eguidotti.com</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/eguidotti/calculus/issues">https://github.com/eguidotti/calculus/issues</a>
</p>
</li></ul>


<hr>
<h2 id='+25diff+25'>Numerical and Symbolic Difference</h2><span id='topic++25diff+25'></span>

<h3>Description</h3>

<p>Elementwise difference of <code>numeric</code> or <code>character</code> arrays.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %diff% y
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25diff+2B25_+3A_x">x</code></td>
<td>
<p><code>numeric</code> or <code>character</code> array.</p>
</td></tr>
<tr><td><code id="+2B25diff+2B25_+3A_y">y</code></td>
<td>
<p><code>numeric</code> or <code>character</code> array.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>array</code>.
</p>


<h3>References</h3>

<p>Guidotti E (2022). &quot;calculus: High-Dimensional Numerical and Symbolic Calculus in R.&quot; Journal of Statistical Software, 104(5), 1-37. <a href="https://doi.org/10.18637/jss.v104.i05">doi:10.18637/jss.v104.i05</a>
</p>


<h3>See Also</h3>

<p>Other basic arithmetic: 
<code><a href="#topic++25div+25">%div%</a>()</code>,
<code><a href="#topic++25dot+25">%dot%</a>()</code>,
<code><a href="#topic++25inner+25">%inner%</a>()</code>,
<code><a href="#topic++25kronecker+25">%kronecker%</a>()</code>,
<code><a href="#topic++25outer+25">%outer%</a>()</code>,
<code><a href="#topic++25prod+25">%prod%</a>()</code>,
<code><a href="#topic++25sum+25">%sum%</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### vector 
x &lt;- c("a+1","b+2")
x %diff% x

### matrix 
x &lt;- matrix(letters[1:4], ncol = 2)
x %diff% x

### array
x &lt;- array(letters[1:12], dim = c(2,2,3))
y &lt;- array(1:12, dim = c(2,2,3))
x %diff% y

</code></pre>

<hr>
<h2 id='+25div+25'>Numerical and Symbolic Division</h2><span id='topic++25div+25'></span>

<h3>Description</h3>

<p>Elementwise division of <code>numeric</code> or <code>character</code> arrays.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %div% y
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25div+2B25_+3A_x">x</code></td>
<td>
<p><code>numeric</code> or <code>character</code> array.</p>
</td></tr>
<tr><td><code id="+2B25div+2B25_+3A_y">y</code></td>
<td>
<p><code>numeric</code> or <code>character</code> array.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>array</code>.
</p>


<h3>References</h3>

<p>Guidotti E (2022). &quot;calculus: High-Dimensional Numerical and Symbolic Calculus in R.&quot; Journal of Statistical Software, 104(5), 1-37. <a href="https://doi.org/10.18637/jss.v104.i05">doi:10.18637/jss.v104.i05</a>
</p>


<h3>See Also</h3>

<p>Other basic arithmetic: 
<code><a href="#topic++25diff+25">%diff%</a>()</code>,
<code><a href="#topic++25dot+25">%dot%</a>()</code>,
<code><a href="#topic++25inner+25">%inner%</a>()</code>,
<code><a href="#topic++25kronecker+25">%kronecker%</a>()</code>,
<code><a href="#topic++25outer+25">%outer%</a>()</code>,
<code><a href="#topic++25prod+25">%prod%</a>()</code>,
<code><a href="#topic++25sum+25">%sum%</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### vector 
x &lt;- c("a+1","b+2")
x %div% x

### matrix 
x &lt;- matrix(letters[1:4], ncol = 2)
x %div% x

### array
x &lt;- array(letters[1:12], dim = c(2,2,3))
y &lt;- array(1:12, dim = c(2,2,3))
x %div% y 

</code></pre>

<hr>
<h2 id='+25dot+25'>Numerical and Symbolic Dot Product</h2><span id='topic++25dot+25'></span>

<h3>Description</h3>

<p>The dot product between arrays with different dimensions is computed by taking the inner product on the last dimensions of the two arrays.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %dot% y
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25dot+2B25_+3A_x">x</code></td>
<td>
<p><code>numeric</code> or <code>character</code> array.</p>
</td></tr>
<tr><td><code id="+2B25dot+2B25_+3A_y">y</code></td>
<td>
<p><code>numeric</code> or <code>character</code> array.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The dot product between two arrays <code>A</code> and <code>B</code> is computed as:
</p>
<p style="text-align: center;"><code class="reqn">C_{i_1\dots i_m} = \sum_{j_1\dots j_n} A_{i_1\dots i_mj_1\dots j_n}B_{j_1\dots j_n}</code>
</p>



<h3>Value</h3>

<p><code>array</code>.
</p>


<h3>References</h3>

<p>Guidotti E (2022). &quot;calculus: High-Dimensional Numerical and Symbolic Calculus in R.&quot; Journal of Statistical Software, 104(5), 1-37. <a href="https://doi.org/10.18637/jss.v104.i05">doi:10.18637/jss.v104.i05</a>
</p>


<h3>See Also</h3>

<p>Other basic arithmetic: 
<code><a href="#topic++25diff+25">%diff%</a>()</code>,
<code><a href="#topic++25div+25">%div%</a>()</code>,
<code><a href="#topic++25inner+25">%inner%</a>()</code>,
<code><a href="#topic++25kronecker+25">%kronecker%</a>()</code>,
<code><a href="#topic++25outer+25">%outer%</a>()</code>,
<code><a href="#topic++25prod+25">%prod%</a>()</code>,
<code><a href="#topic++25sum+25">%sum%</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### inner product 
x &lt;- array(1:12, dim = c(3,4))
x %dot% x

### dot product 
x &lt;- array(1:24, dim = c(3,2,4))
y &lt;- array(letters[1:8], dim = c(2,4))
x %dot% y

</code></pre>

<hr>
<h2 id='+25inner+25'>Numerical and Symbolic Inner Product</h2><span id='topic++25inner+25'></span>

<h3>Description</h3>

<p>Computes the inner product of two <code>numeric</code> or <code>character</code> arrays.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %inner% y
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25inner+2B25_+3A_x">x</code></td>
<td>
<p><code>numeric</code> or <code>character</code> array.</p>
</td></tr>
<tr><td><code id="+2B25inner+2B25_+3A_y">y</code></td>
<td>
<p><code>numeric</code> or <code>character</code> array.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The inner product between two arrays <code>A</code> and <code>B</code> is computed as:
</p>
<p style="text-align: center;"><code class="reqn">C = \sum_{j_1\dots j_n} A_{j_1\dots j_n}B_{j_1\dots j_n}</code>
</p>



<h3>Value</h3>

<p><code>numeric</code> or <code>character</code>.
</p>


<h3>References</h3>

<p>Guidotti E (2022). &quot;calculus: High-Dimensional Numerical and Symbolic Calculus in R.&quot; Journal of Statistical Software, 104(5), 1-37. <a href="https://doi.org/10.18637/jss.v104.i05">doi:10.18637/jss.v104.i05</a>
</p>


<h3>See Also</h3>

<p>Other basic arithmetic: 
<code><a href="#topic++25diff+25">%diff%</a>()</code>,
<code><a href="#topic++25div+25">%div%</a>()</code>,
<code><a href="#topic++25dot+25">%dot%</a>()</code>,
<code><a href="#topic++25kronecker+25">%kronecker%</a>()</code>,
<code><a href="#topic++25outer+25">%outer%</a>()</code>,
<code><a href="#topic++25prod+25">%prod%</a>()</code>,
<code><a href="#topic++25sum+25">%sum%</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### numeric inner product 
x &lt;- array(1:4, dim = c(2,2))
x %inner% x

### symbolic inner product 
x &lt;- array(letters[1:4], dim = c(2,2))
x %inner% x

</code></pre>

<hr>
<h2 id='+25kronecker+25'>Numerical and Symbolic Kronecker Product</h2><span id='topic++25kronecker+25'></span>

<h3>Description</h3>

<p>Computes the generalised Kronecker product of two <code>numeric</code> or <code>character</code> arrays.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %kronecker% y
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25kronecker+2B25_+3A_x">x</code></td>
<td>
<p><code>numeric</code> or <code>character</code> array.</p>
</td></tr>
<tr><td><code id="+2B25kronecker+2B25_+3A_y">y</code></td>
<td>
<p><code>numeric</code> or <code>character</code> array.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>array</code>.
</p>


<h3>References</h3>

<p>Guidotti E (2022). &quot;calculus: High-Dimensional Numerical and Symbolic Calculus in R.&quot; Journal of Statistical Software, 104(5), 1-37. <a href="https://doi.org/10.18637/jss.v104.i05">doi:10.18637/jss.v104.i05</a>
</p>


<h3>See Also</h3>

<p>Other basic arithmetic: 
<code><a href="#topic++25diff+25">%diff%</a>()</code>,
<code><a href="#topic++25div+25">%div%</a>()</code>,
<code><a href="#topic++25dot+25">%dot%</a>()</code>,
<code><a href="#topic++25inner+25">%inner%</a>()</code>,
<code><a href="#topic++25outer+25">%outer%</a>()</code>,
<code><a href="#topic++25prod+25">%prod%</a>()</code>,
<code><a href="#topic++25sum+25">%sum%</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### numeric Kronecker product 
c(1,2) %kronecker% c(2,3)

### symbolic Kronecker product 
array(1:4, dim = c(2,2)) %kronecker% c("a","b")

</code></pre>

<hr>
<h2 id='+25outer+25'>Numerical and Symbolic Outer Product</h2><span id='topic++25outer+25'></span>

<h3>Description</h3>

<p>Computes the outer product of two <code>numeric</code> or <code>character</code> arrays.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %outer% y
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25outer+2B25_+3A_x">x</code></td>
<td>
<p><code>numeric</code> or <code>character</code> array.</p>
</td></tr>
<tr><td><code id="+2B25outer+2B25_+3A_y">y</code></td>
<td>
<p><code>numeric</code> or <code>character</code> array.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The outer product between two arrays <code>A</code> and <code>B</code> is computed as:
</p>
<p style="text-align: center;"><code class="reqn">C_{i_1\dots i_mj_1\dots j_n} = A_{i_1\dots i_m}B_{j_1\dots j_n}</code>
</p>



<h3>Value</h3>

<p><code>array</code>.
</p>


<h3>References</h3>

<p>Guidotti E (2022). &quot;calculus: High-Dimensional Numerical and Symbolic Calculus in R.&quot; Journal of Statistical Software, 104(5), 1-37. <a href="https://doi.org/10.18637/jss.v104.i05">doi:10.18637/jss.v104.i05</a>
</p>


<h3>See Also</h3>

<p>Other basic arithmetic: 
<code><a href="#topic++25diff+25">%diff%</a>()</code>,
<code><a href="#topic++25div+25">%div%</a>()</code>,
<code><a href="#topic++25dot+25">%dot%</a>()</code>,
<code><a href="#topic++25inner+25">%inner%</a>()</code>,
<code><a href="#topic++25kronecker+25">%kronecker%</a>()</code>,
<code><a href="#topic++25prod+25">%prod%</a>()</code>,
<code><a href="#topic++25sum+25">%sum%</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### numeric outer product 
c(1,2) %outer% c(2,3)

### symbolic outer product 
c("a","b") %outer% c("c","d")

</code></pre>

<hr>
<h2 id='+25prod+25'>Numerical and Symbolic Product</h2><span id='topic++25prod+25'></span>

<h3>Description</h3>

<p>Elementwise product of <code>numeric</code> or <code>character</code> arrays.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %prod% y
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25prod+2B25_+3A_x">x</code></td>
<td>
<p><code>numeric</code> or <code>character</code> array.</p>
</td></tr>
<tr><td><code id="+2B25prod+2B25_+3A_y">y</code></td>
<td>
<p><code>numeric</code> or <code>character</code> array.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>array</code>.
</p>


<h3>References</h3>

<p>Guidotti E (2022). &quot;calculus: High-Dimensional Numerical and Symbolic Calculus in R.&quot; Journal of Statistical Software, 104(5), 1-37. <a href="https://doi.org/10.18637/jss.v104.i05">doi:10.18637/jss.v104.i05</a>
</p>


<h3>See Also</h3>

<p>Other basic arithmetic: 
<code><a href="#topic++25diff+25">%diff%</a>()</code>,
<code><a href="#topic++25div+25">%div%</a>()</code>,
<code><a href="#topic++25dot+25">%dot%</a>()</code>,
<code><a href="#topic++25inner+25">%inner%</a>()</code>,
<code><a href="#topic++25kronecker+25">%kronecker%</a>()</code>,
<code><a href="#topic++25outer+25">%outer%</a>()</code>,
<code><a href="#topic++25sum+25">%sum%</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### vector 
x &lt;- c("a+1","b+2")
x %prod% x

### matrix 
x &lt;- matrix(letters[1:4], ncol = 2)
x %prod% x

### array
x &lt;- array(letters[1:12], dim = c(2,2,3))
y &lt;- array(1:12, dim = c(2,2,3))
x %prod% y

</code></pre>

<hr>
<h2 id='+25sum+25'>Numerical and Symbolic Sum</h2><span id='topic++25sum+25'></span>

<h3>Description</h3>

<p>Elementwise sum of <code>numeric</code> or <code>character</code> arrays.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %sum% y
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25sum+2B25_+3A_x">x</code></td>
<td>
<p><code>numeric</code> or <code>character</code> array.</p>
</td></tr>
<tr><td><code id="+2B25sum+2B25_+3A_y">y</code></td>
<td>
<p><code>numeric</code> or <code>character</code> array.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>array</code>.
</p>


<h3>References</h3>

<p>Guidotti E (2022). &quot;calculus: High-Dimensional Numerical and Symbolic Calculus in R.&quot; Journal of Statistical Software, 104(5), 1-37. <a href="https://doi.org/10.18637/jss.v104.i05">doi:10.18637/jss.v104.i05</a>
</p>


<h3>See Also</h3>

<p>Other basic arithmetic: 
<code><a href="#topic++25diff+25">%diff%</a>()</code>,
<code><a href="#topic++25div+25">%div%</a>()</code>,
<code><a href="#topic++25dot+25">%dot%</a>()</code>,
<code><a href="#topic++25inner+25">%inner%</a>()</code>,
<code><a href="#topic++25kronecker+25">%kronecker%</a>()</code>,
<code><a href="#topic++25outer+25">%outer%</a>()</code>,
<code><a href="#topic++25prod+25">%prod%</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### vector 
x &lt;- c("a+1","b+2")
x %sum% x

### matrix 
x &lt;- matrix(letters[1:4], ncol = 2)
x %sum% x

### array
x &lt;- array(letters[1:12], dim = c(2,2,3))
y &lt;- array(1:12, dim = c(2,2,3))
x %sum% y

</code></pre>

<hr>
<h2 id='c2e'>Characters to Expressions</h2><span id='topic+c2e'></span>

<h3>Description</h3>

<p>Converts <code>characters</code> to <code>expressions</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c2e(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c2e_+3A_x">x</code></td>
<td>
<p><code>character</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>expression</code>.
</p>


<h3>References</h3>

<p>Guidotti E (2022). &quot;calculus: High-Dimensional Numerical and Symbolic Calculus in R.&quot; Journal of Statistical Software, 104(5), 1-37. <a href="https://doi.org/10.18637/jss.v104.i05">doi:10.18637/jss.v104.i05</a>
</p>


<h3>See Also</h3>

<p>Other utilities: 
<code><a href="#topic+e2c">e2c</a>()</code>,
<code><a href="#topic+evaluate">evaluate</a>()</code>,
<code><a href="#topic+wrap">wrap</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### convert characters
c2e("a")

### convert array of characters
c2e(array("a", dim = c(2,2)))

</code></pre>

<hr>
<h2 id='contraction'>Numerical and Symbolic Tensor Contraction</h2><span id='topic+contraction'></span>

<h3>Description</h3>

<p>Sums over repeated indices in an <code>array</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contraction(x, i = NULL, drop = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contraction_+3A_x">x</code></td>
<td>
<p>indexed <code>array</code>. See <code><a href="#topic+index">index</a></code>.</p>
</td></tr>
<tr><td><code id="contraction_+3A_i">i</code></td>
<td>
<p>subset of repeated indices to sum up. If <code>NULL</code>, the summation takes place on all the repeated indices.</p>
</td></tr>
<tr><td><code id="contraction_+3A_drop">drop</code></td>
<td>
<p><code>logical</code>. Drop summation indices? If <code>FALSE</code>, keep dummy dimensions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>array</code>.
</p>


<h3>References</h3>

<p>Guidotti E (2022). &quot;calculus: High-Dimensional Numerical and Symbolic Calculus in R.&quot; Journal of Statistical Software, 104(5), 1-37. <a href="https://doi.org/10.18637/jss.v104.i05">doi:10.18637/jss.v104.i05</a>
</p>


<h3>See Also</h3>

<p>Other tensor algebra: 
<code><a href="#topic+delta">delta</a>()</code>,
<code><a href="#topic+diagonal">diagonal</a>()</code>,
<code><a href="#topic+einstein">einstein</a>()</code>,
<code><a href="#topic+epsilon">epsilon</a>()</code>,
<code><a href="#topic+index">index</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### matrix trace
x &lt;- matrix(letters[1:4], nrow = 2)
contraction(x)

### tensor trace
x &lt;- array(1:27, dim = c(3,3,3))
contraction(x)

#### tensor contraction over repeated indices
x &lt;- array(1:27, dim = c(3,3,3))
index(x) &lt;- c("i","i","j")
contraction(x)

#### tensor contraction over specific repeated indices only
x &lt;- array(1:16, dim = c(2,2,2,2))
index(x) &lt;- c("i","i","k","k")
contraction(x, i = "k")

#### tensor contraction keeping dummy dimensions
x &lt;- array(letters[1:16], dim = c(2,2,2,2))
index(x) &lt;- c("i","i","k","k")
contraction(x, drop = FALSE)

</code></pre>

<hr>
<h2 id='cross'>Numerical and Symbolic Cross Product</h2><span id='topic+cross'></span><span id='topic++25cross+25'></span>

<h3>Description</h3>

<p>Computes the cross product of <code class="reqn">n-1</code> vectors of length <code class="reqn">n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cross(...)

x %cross% y
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cross_+3A_...">...</code></td>
<td>
<p><code class="reqn">n-1</code> vectors of length <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="cross_+3A_x">x</code></td>
<td>
<p><code>numeric</code> or <code>character</code> vector of length 3.</p>
</td></tr>
<tr><td><code id="cross_+3A_y">y</code></td>
<td>
<p><code>numeric</code> or <code>character</code> vector of length 3.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code class="reqn">n</code>-dimensional vector orthogonal to the <code class="reqn">n-1</code> vectors.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>x %cross% y</code>: binary operator for 3-dimensional cross products.
</p>
</li></ul>


<h3>References</h3>

<p>Guidotti E (2022). &quot;calculus: High-Dimensional Numerical and Symbolic Calculus in R.&quot; Journal of Statistical Software, 104(5), 1-37. <a href="https://doi.org/10.18637/jss.v104.i05">doi:10.18637/jss.v104.i05</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### canonical basis 4-d
cross(c(1,0,0,0), c(0,1,0,0), c(0,0,0,1))

### canonical basis 3-d
cross(c(1,0,0), c(0,1,0))

### symbolic cross product 3-d
c(1,0,0) %cross% c(0,1,0)

### symbolic cross product 3-d
c("a","b","c") %cross% c(0,0,1)

</code></pre>

<hr>
<h2 id='curl'>Numerical and Symbolic Curl</h2><span id='topic+curl'></span><span id='topic++25curl+25'></span>

<h3>Description</h3>

<p>Computes the numerical curl of <code>functions</code> or the symbolic curl of <code>characters</code>
in arbitrary <a href="https://en.wikipedia.org/wiki/Orthogonal_coordinates#Table_of_orthogonal_coordinates">orthogonal coordinate systems</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>curl(
  f,
  var,
  params = list(),
  coordinates = "cartesian",
  accuracy = 4,
  stepsize = NULL,
  drop = TRUE
)

f %curl% var
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="curl_+3A_f">f</code></td>
<td>
<p>array of <code>characters</code> or a <code>function</code> returning a <code>numeric</code> array.</p>
</td></tr>
<tr><td><code id="curl_+3A_var">var</code></td>
<td>
<p>vector giving the variable names with respect to which the derivatives are to be computed and/or the point where the derivatives are to be evaluated. See <code><a href="#topic+derivative">derivative</a></code>.</p>
</td></tr>
<tr><td><code id="curl_+3A_params">params</code></td>
<td>
<p><code>list</code> of additional parameters passed to <code>f</code>.</p>
</td></tr>
<tr><td><code id="curl_+3A_coordinates">coordinates</code></td>
<td>
<p>coordinate system to use. One of: <code>cartesian</code>, <code>polar</code>, <code>spherical</code>, <code>cylindrical</code>, <code>parabolic</code>, <code>parabolic-cylindrical</code> or a vector of scale factors for each varibale.</p>
</td></tr>
<tr><td><code id="curl_+3A_accuracy">accuracy</code></td>
<td>
<p>degree of accuracy for numerical derivatives.</p>
</td></tr>
<tr><td><code id="curl_+3A_stepsize">stepsize</code></td>
<td>
<p>finite differences stepsize for numerical derivatives. It is based on the precision of the machine by default.</p>
</td></tr>
<tr><td><code id="curl_+3A_drop">drop</code></td>
<td>
<p>if <code>TRUE</code>, return the curl as a vector and not as an <code>array</code> for vector-valued functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The curl of a vector-valued function <code class="reqn">F_i</code> at a point is represented by a 
vector whose length and direction denote the magnitude and axis of the maximum 
circulation. 
In 2 dimensions, the <code>curl</code> is computed in arbitrary orthogonal coordinate 
systems using the scale factors <code class="reqn">h_i</code> and the Levi-Civita symbol <code><a href="#topic+epsilon">epsilon</a></code>:
</p>
<p style="text-align: center;"><code class="reqn">\nabla \times F = \frac{1}{h_1h_2}\sum_{ij}\epsilon_{ij}\partial_i\Bigl(h_jF_j\Bigl)= \frac{1}{h_1h_2}\Biggl(\partial_1\Bigl(h_2F_2\Bigl)-\partial_2\Bigl(h_1F_1\Bigl)\Biggl)</code>
</p>

<p>In 3 dimensions:
</p>
<p style="text-align: center;"><code class="reqn">(\nabla \times F)_k = \frac{h_k}{J}\sum_{ij}\epsilon_{ijk}\partial_i\Bigl(h_jF_j\Bigl)</code>
</p>

<p>where <code class="reqn">J=\prod_i h_i</code>. In <code class="reqn">m+2</code> dimensions, the <code>curl</code> is implemented in such
a way that the formula reduces correctly to the previous cases for <code class="reqn">m=0</code> and <code class="reqn">m=1</code>:
</p>
<p style="text-align: center;"><code class="reqn">(\nabla \times F)_{k_1\dots k_m} = \frac{h_{k_1}\cdots h_{k_m}}{J}\sum_{ij}\epsilon_{ijk_1\dots k_m}\partial_i\Bigl(h_jF_j\Bigl)</code>
</p>

<p>When <code class="reqn">F</code> is an <code>array</code> of vector-valued functions <code class="reqn">F_{d_1,\dots,d_n,j}</code> the <code>curl</code> 
is computed for each vector:
</p>
<p style="text-align: center;"><code class="reqn">(\nabla \times F)_{d_1\dots d_n,k_1\dots k_m} = \frac{h_{k_1}\cdots h_{k_m}}{J}\sum_{ij}\epsilon_{ijk_1\dots k_m}\partial_i\Bigl(h_jF_{d_1\dots d_n,j}\Bigl)</code>
</p>



<h3>Value</h3>

<p>Vector for vector-valued functions when <code>drop=TRUE</code>, <code>array</code> otherwise.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>f %curl% var</code>: binary operator with default parameters.
</p>
</li></ul>


<h3>References</h3>

<p>Guidotti E (2022). &quot;calculus: High-Dimensional Numerical and Symbolic Calculus in R.&quot; Journal of Statistical Software, 104(5), 1-37. <a href="https://doi.org/10.18637/jss.v104.i05">doi:10.18637/jss.v104.i05</a>
</p>


<h3>See Also</h3>

<p>Other differential operators: 
<code><a href="#topic+derivative">derivative</a>()</code>,
<code><a href="#topic+divergence">divergence</a>()</code>,
<code><a href="#topic+gradient">gradient</a>()</code>,
<code><a href="#topic+hessian">hessian</a>()</code>,
<code><a href="#topic+jacobian">jacobian</a>()</code>,
<code><a href="#topic+laplacian">laplacian</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### symbolic curl of a 2-d vector field
f &lt;- c("x^3*y^2","x")
curl(f, var = c("x","y"))

### numerical curl of a 2-d vector field in (x=1, y=1)
f &lt;- function(x,y) c(x^3*y^2, x)
curl(f, var = c(x=1, y=1))

### numerical curl of a 3-d vector field in (x=1, y=1, z=1)
f &lt;- function(x,y,z) c(x^3*y^2, x, z)
curl(f, var = c(x=1, y=1, z=1))

### vectorized interface
f &lt;- function(x) c(x[1]^3*x[2]^2, x[1], x[3])
curl(f, var = c(1,1,1)) 

### symbolic array of vector-valued 3-d functions
f &lt;- array(c("x*y","x","y*z","y","x*z","z"), dim = c(2,3))
curl(f, var = c("x","y","z"))

### numeric array of vector-valued 3-d functions in (x=1, y=1, z=1)
f &lt;- function(x,y,z) array(c(x*y,x,y*z,y,x*z,z), dim = c(2,3))
curl(f, var = c(x=1, y=1, z=1))

### binary operator
c("x*y","y*z","x*z") %curl% c("x","y","z")

</code></pre>

<hr>
<h2 id='delta'>Generalized Kronecker Delta</h2><span id='topic+delta'></span>

<h3>Description</h3>

<p>Computes the Generalized Kronecker Delta.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delta(n, p = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delta_+3A_n">n</code></td>
<td>
<p>number of elements for each dimension.</p>
</td></tr>
<tr><td><code id="delta_+3A_p">p</code></td>
<td>
<p>order of the generalized Kronecker delta, <code>p=1</code> for the standard Kronecker delta.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>array</code> representing the generalized Kronecker delta tensor.
</p>


<h3>References</h3>

<p>Guidotti E (2022). &quot;calculus: High-Dimensional Numerical and Symbolic Calculus in R.&quot; Journal of Statistical Software, 104(5), 1-37. <a href="https://doi.org/10.18637/jss.v104.i05">doi:10.18637/jss.v104.i05</a>
</p>


<h3>See Also</h3>

<p>Other tensor algebra: 
<code><a href="#topic+contraction">contraction</a>()</code>,
<code><a href="#topic+diagonal">diagonal</a>()</code>,
<code><a href="#topic+einstein">einstein</a>()</code>,
<code><a href="#topic+epsilon">epsilon</a>()</code>,
<code><a href="#topic+index">index</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Kronecker delta 3x3
delta(3)

### generalized Kronecker delta 3x3 of order 2
delta(3, p = 2)  

</code></pre>

<hr>
<h2 id='derivative'>Numerical and Symbolic Derivatives</h2><span id='topic+derivative'></span>

<h3>Description</h3>

<p>Computes symbolic derivatives based on the <code><a href="stats.html#topic+D">D</a></code> function, or numerical derivatives based on finite differences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derivative(
  f,
  var,
  params = list(),
  order = 1,
  accuracy = 4,
  stepsize = NULL,
  drop = TRUE,
  deparse = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derivative_+3A_f">f</code></td>
<td>
<p>array of <code>characters</code> or a <code>function</code> returning a <code>numeric</code> array.</p>
</td></tr>
<tr><td><code id="derivative_+3A_var">var</code></td>
<td>
<p>vector giving the variable names with respect to which the derivatives are to be computed and/or the point where the derivatives are to be evaluated. See details.</p>
</td></tr>
<tr><td><code id="derivative_+3A_params">params</code></td>
<td>
<p><code>list</code> of additional parameters passed to <code>f</code>.</p>
</td></tr>
<tr><td><code id="derivative_+3A_order">order</code></td>
<td>
<p>integer vector, giving the differentiation order for each variable. See details.</p>
</td></tr>
<tr><td><code id="derivative_+3A_accuracy">accuracy</code></td>
<td>
<p>degree of accuracy for numerical derivatives.</p>
</td></tr>
<tr><td><code id="derivative_+3A_stepsize">stepsize</code></td>
<td>
<p>finite differences stepsize for numerical derivatives. It is based on the precision of the machine by default.</p>
</td></tr>
<tr><td><code id="derivative_+3A_drop">drop</code></td>
<td>
<p>if <code>TRUE</code>, return the array of derivatives without adding a dummy dimension when <code>order</code> is of length 1.</p>
</td></tr>
<tr><td><code id="derivative_+3A_deparse">deparse</code></td>
<td>
<p>if <code>TRUE</code>, return <code>character</code> instead of <code>expression</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function behaves differently depending on the arguents <code>order</code>, 
the order of differentiation, and <code>var</code>, the variable names with respect to 
which the derivatives are computed.
</p>
<p>When multiple variables are provided and <code>order</code> is a single integer <code class="reqn">n</code>, 
then the <code class="reqn">n</code>-th order derivative is computed for each element of <code>f</code> 
with respect to each variable:
</p>
<p style="text-align: center;"><code class="reqn">D = \partial^{(n)} \otimes F</code>
</p>

<p>that is:
</p>
<p style="text-align: center;"><code class="reqn">D_{i,\dots,j,k} = \partial^{(n)}_{k} F_{i,\dots,j}</code>
</p>

<p>where <code class="reqn">F</code> is the array of functions and <code class="reqn">\partial_k^{(n)}</code> denotes the 
<code class="reqn">n</code>-th order partial derivative with respect to the <code class="reqn">k</code>-th variable.
</p>
<p>When <code>order</code> matches the length of <code>var</code>, it is assumed that the 
differentiation order is provided for each variable. In this case, each element 
is derived <code class="reqn">n_k</code> times with respect to the <code class="reqn">k</code>-th variable, for each 
of the <code class="reqn">m</code> variables.
</p>
<p style="text-align: center;"><code class="reqn">D_{i,\dots,j} = \partial^{(n_1)}_1\cdots\partial^{(n_m)}_m F_{i,\dots,j}</code>
</p>

<p>The same applies when <code>order</code> is a named vector giving the differentiation 
order for each variable. For example, <code>order = c(x=1, y=2)</code> differentiates 
once with respect to <code class="reqn">x</code> and twice with respect to <code class="reqn">y</code>. A call with 
<code>order = c(x=1, y=0)</code> is equivalent to <code>order = c(x=1)</code>. 
</p>
<p>To compute numerical derivatives or to evaluate symbolic derivatives at a point, 
the function accepts a named vector for the argument <code>var</code>; e.g. 
<code>var = c(x=1, y=2)</code> evaluates the derivatives in <code class="reqn">x=1</code> and <code class="reqn">y=2</code>. 
For <code>functions</code> where the first argument is used as a parameter vector, 
<code>var</code> should be a <code>numeric</code> vector indicating the point at which the 
derivatives are to be calculated.
</p>


<h3>Value</h3>

<p><code>array</code>.
</p>


<h3>References</h3>

<p>Guidotti E (2022). &quot;calculus: High-Dimensional Numerical and Symbolic Calculus in R.&quot; Journal of Statistical Software, 104(5), 1-37. <a href="https://doi.org/10.18637/jss.v104.i05">doi:10.18637/jss.v104.i05</a>
</p>


<h3>See Also</h3>

<p>Other derivatives: 
<code><a href="#topic+taylor">taylor</a>()</code>
</p>
<p>Other differential operators: 
<code><a href="#topic+curl">curl</a>()</code>,
<code><a href="#topic+divergence">divergence</a>()</code>,
<code><a href="#topic+gradient">gradient</a>()</code>,
<code><a href="#topic+hessian">hessian</a>()</code>,
<code><a href="#topic+jacobian">jacobian</a>()</code>,
<code><a href="#topic+laplacian">laplacian</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### symbolic derivatives
derivative(f = "sin(x)", var = "x")

### numerical derivatives
f &lt;- function(x) sin(x)
derivative(f = f, var = c(x=0))

### higher order derivatives
f &lt;- function(x) sin(x)
derivative(f = f, var = c(x=0), order = 3)

### multivariate functions 
##  - derive once with respect to x
##  - derive twice with respect to y
##  - evaluate in x=0 and y=0
f &lt;- function(x, y) y^2*sin(x)
derivative(f = f, var = c(x=0, y=0), order = c(1,2))

### vector-valued functions
##  - derive each element twice with respect to each variable
##  - evaluate in x=0 and y=0
f &lt;- function(x, y) c(x^2, y^2)
derivative(f, var = c(x=0, y=0), order = 2)

### vectorized interface
f &lt;- function(x) c(sum(x), prod(x))
derivative(f, var = c(0,0,0), order = 1)

</code></pre>

<hr>
<h2 id='diagonal'>Tensor Diagonals</h2><span id='topic+diagonal'></span><span id='topic+diagonal+3C-'></span>

<h3>Description</h3>

<p>Functions to extract or replace the diagonals of an <code>array</code>, or construct a diagonal <code>array</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagonal(x = 1, dim = rep(2, 2))

diagonal(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diagonal_+3A_x">x</code></td>
<td>
<p>an <code>array</code> from which to extract the diagonals, or a vector giving the diagonal values to construct the <code>array</code>.</p>
</td></tr>
<tr><td><code id="diagonal_+3A_dim">dim</code></td>
<td>
<p>the dimensions of the (square) <code>array</code> to construct when <code>x</code> is a vector.</p>
</td></tr>
<tr><td><code id="diagonal_+3A_value">value</code></td>
<td>
<p>vector giving the values of the diagonal entries.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of the diagonal entries of <code>x</code> if <code>x</code> is an <code>array</code>. 
If <code>x</code> is a vector, returns the diagonal <code>array</code> with the 
entries given by <code>x</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>diagonal(x) &lt;- value</code>: set diagonals.
</p>
</li></ul>


<h3>References</h3>

<p>Guidotti E (2022). &quot;calculus: High-Dimensional Numerical and Symbolic Calculus in R.&quot; Journal of Statistical Software, 104(5), 1-37. <a href="https://doi.org/10.18637/jss.v104.i05">doi:10.18637/jss.v104.i05</a>
</p>


<h3>See Also</h3>

<p>Other tensor algebra: 
<code><a href="#topic+contraction">contraction</a>()</code>,
<code><a href="#topic+delta">delta</a>()</code>,
<code><a href="#topic+einstein">einstein</a>()</code>,
<code><a href="#topic+epsilon">epsilon</a>()</code>,
<code><a href="#topic+index">index</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### 3x3 matrix
diagonal(x = 1, dim = c(3,3))

### 2x2x2 array
diagonal(x = 1:2, dim = c(2,2,2))

### extract diagonals 
x &lt;- diagonal(1:5, dim = c(5,5,5))
diagonal(x)

### set diagonals
x &lt;- array(0, dim = c(2,2,2))
diagonal(x) &lt;- 1:2
x

</code></pre>

<hr>
<h2 id='divergence'>Numerical and Symbolic Divergence</h2><span id='topic+divergence'></span><span id='topic++25divergence+25'></span>

<h3>Description</h3>

<p>Computes the numerical divergence of <code>functions</code> or the symbolic divergence of <code>characters</code>
in arbitrary <a href="https://en.wikipedia.org/wiki/Orthogonal_coordinates#Table_of_orthogonal_coordinates">orthogonal coordinate systems</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>divergence(
  f,
  var,
  params = list(),
  coordinates = "cartesian",
  accuracy = 4,
  stepsize = NULL,
  drop = TRUE
)

f %divergence% var
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="divergence_+3A_f">f</code></td>
<td>
<p>array of <code>characters</code> or a <code>function</code> returning a <code>numeric</code> array.</p>
</td></tr>
<tr><td><code id="divergence_+3A_var">var</code></td>
<td>
<p>vector giving the variable names with respect to which the derivatives are to be computed and/or the point where the derivatives are to be evaluated. See <code><a href="#topic+derivative">derivative</a></code>.</p>
</td></tr>
<tr><td><code id="divergence_+3A_params">params</code></td>
<td>
<p><code>list</code> of additional parameters passed to <code>f</code>.</p>
</td></tr>
<tr><td><code id="divergence_+3A_coordinates">coordinates</code></td>
<td>
<p>coordinate system to use. One of: <code>cartesian</code>, <code>polar</code>, <code>spherical</code>, <code>cylindrical</code>, <code>parabolic</code>, <code>parabolic-cylindrical</code> or a vector of scale factors for each varibale.</p>
</td></tr>
<tr><td><code id="divergence_+3A_accuracy">accuracy</code></td>
<td>
<p>degree of accuracy for numerical derivatives.</p>
</td></tr>
<tr><td><code id="divergence_+3A_stepsize">stepsize</code></td>
<td>
<p>finite differences stepsize for numerical derivatives. It is based on the precision of the machine by default.</p>
</td></tr>
<tr><td><code id="divergence_+3A_drop">drop</code></td>
<td>
<p>if <code>TRUE</code>, return the divergence as a scalar and not as an <code>array</code> for vector-valued functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The divergence of a vector-valued function <code class="reqn">F_i</code> produces a scalar value 
<code class="reqn">\nabla \cdot F</code> representing the volume density of the outward flux of the 
vector field from an infinitesimal volume around a given point. 
The <code>divergence</code> is computed in arbitrary orthogonal coordinate systems using the 
scale factors <code class="reqn">h_i</code>:
</p>
<p style="text-align: center;"><code class="reqn">\nabla \cdot F = \frac{1}{J}\sum_i\partial_i\Biggl(\frac{J}{h_i}F_i\Biggl)</code>
</p>

<p>where <code class="reqn">J=\prod_ih_i</code>. When <code class="reqn">F</code> is an <code>array</code> of vector-valued functions 
<code class="reqn">F_{d_1\dots d_n,i}</code>, the <code>divergence</code> is computed for each vector:
</p>
<p style="text-align: center;"><code class="reqn">(\nabla \cdot F)_{d_1\dots d_n} = \frac{1}{J}\sum_i\partial_i\Biggl(\frac{J}{h_i}F_{d_1\dots d_n,i}\Biggl)</code>
</p>



<h3>Value</h3>

<p>Scalar for vector-valued functions when <code>drop=TRUE</code>, <code>array</code> otherwise.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>f %divergence% var</code>: binary operator with default parameters.
</p>
</li></ul>


<h3>References</h3>

<p>Guidotti E (2022). &quot;calculus: High-Dimensional Numerical and Symbolic Calculus in R.&quot; Journal of Statistical Software, 104(5), 1-37. <a href="https://doi.org/10.18637/jss.v104.i05">doi:10.18637/jss.v104.i05</a>
</p>


<h3>See Also</h3>

<p>Other differential operators: 
<code><a href="#topic+curl">curl</a>()</code>,
<code><a href="#topic+derivative">derivative</a>()</code>,
<code><a href="#topic+gradient">gradient</a>()</code>,
<code><a href="#topic+hessian">hessian</a>()</code>,
<code><a href="#topic+jacobian">jacobian</a>()</code>,
<code><a href="#topic+laplacian">laplacian</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### symbolic divergence of a vector field
f &lt;- c("x^2","y^3","z^4")
divergence(f, var = c("x","y","z"))

### numerical divergence of a vector field in (x=1, y=1, z=1)
f &lt;- function(x,y,z) c(x^2, y^3, z^4)
divergence(f, var = c(x=1, y=1, z=1))

### vectorized interface
f &lt;- function(x) c(x[1]^2, x[2]^3, x[3]^4)
divergence(f, var = c(1,1,1)) 

### symbolic array of vector-valued 3-d functions
f &lt;- array(c("x^2","x","y^2","y","z^2","z"), dim = c(2,3))
divergence(f, var = c("x","y","z"))

### numeric array of vector-valued 3-d functions in (x=0, y=0, z=0)
f &lt;- function(x,y,z) array(c(x^2,x,y^2,y,z^2,z), dim = c(2,3))
divergence(f, var = c(x=0, y=0, z=0))
 
### binary operator
c("x^2","y^3","z^4") %divergence% c("x","y","z")

</code></pre>

<hr>
<h2 id='e2c'>Expressions to Characters</h2><span id='topic+e2c'></span>

<h3>Description</h3>

<p>Converts <code>expressions</code> to <code>characters</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>e2c(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="e2c_+3A_x">x</code></td>
<td>
<p><code>expression</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>character</code>.
</p>


<h3>References</h3>

<p>Guidotti E (2022). &quot;calculus: High-Dimensional Numerical and Symbolic Calculus in R.&quot; Journal of Statistical Software, 104(5), 1-37. <a href="https://doi.org/10.18637/jss.v104.i05">doi:10.18637/jss.v104.i05</a>
</p>


<h3>See Also</h3>

<p>Other utilities: 
<code><a href="#topic+c2e">c2e</a>()</code>,
<code><a href="#topic+evaluate">evaluate</a>()</code>,
<code><a href="#topic+wrap">wrap</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### convert expressions
expr &lt;- parse(text = "a")
e2c(expr)

### convert array of expressions
expr &lt;- array(parse(text = "a"), dim = c(2,2))
e2c(expr)

</code></pre>

<hr>
<h2 id='einstein'>Numerical and Symbolic Einstein Summation</h2><span id='topic+einstein'></span>

<h3>Description</h3>

<p>Implements the Einstein notation for summation over repeated indices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>einstein(..., drop = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="einstein_+3A_...">...</code></td>
<td>
<p>arbitrary number of indexed <code>arrays</code>. See <code><a href="#topic+index">index</a></code>.</p>
</td></tr>
<tr><td><code id="einstein_+3A_drop">drop</code></td>
<td>
<p><code>logical</code>. Drop summation indices? If <code>FALSE</code>, keep dummy dimensions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>array</code>.
</p>


<h3>References</h3>

<p>Guidotti E (2022). &quot;calculus: High-Dimensional Numerical and Symbolic Calculus in R.&quot; Journal of Statistical Software, 104(5), 1-37. <a href="https://doi.org/10.18637/jss.v104.i05">doi:10.18637/jss.v104.i05</a>
</p>


<h3>See Also</h3>

<p>Other tensor algebra: 
<code><a href="#topic+contraction">contraction</a>()</code>,
<code><a href="#topic+delta">delta</a>()</code>,
<code><a href="#topic+diagonal">diagonal</a>()</code>,
<code><a href="#topic+epsilon">epsilon</a>()</code>,
<code><a href="#topic+index">index</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### A{i,j} B{j,k}
a &lt;- array(letters[1:6], dim = c(i=2, j=3))
b &lt;- array(letters[1:3], dim = c(j=3, k=1))
einstein(a,b)

### A{i,j} B{j,k,k} C{k,l} D{j,k}
a &lt;- array(1:10, dim = c(i=2, j=5))
b &lt;- array(1:45, dim = c(j=5, k=3, k=3))
c &lt;- array(1:12, dim = c(k=3, l=4))
d &lt;- array(1:15, dim = c(j=5, k=3))
einstein(a,b,c,d)

</code></pre>

<hr>
<h2 id='epsilon'>Levi-Civita Symbol</h2><span id='topic+epsilon'></span>

<h3>Description</h3>

<p>Computes the Levi-Civita totally antisymmetric tensor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>epsilon(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="epsilon_+3A_n">n</code></td>
<td>
<p>number of dimensions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>array</code> representing the Levi-Civita symbol.
</p>


<h3>References</h3>

<p>Guidotti E (2022). &quot;calculus: High-Dimensional Numerical and Symbolic Calculus in R.&quot; Journal of Statistical Software, 104(5), 1-37. <a href="https://doi.org/10.18637/jss.v104.i05">doi:10.18637/jss.v104.i05</a>
</p>


<h3>See Also</h3>

<p>Other tensor algebra: 
<code><a href="#topic+contraction">contraction</a>()</code>,
<code><a href="#topic+delta">delta</a>()</code>,
<code><a href="#topic+diagonal">diagonal</a>()</code>,
<code><a href="#topic+einstein">einstein</a>()</code>,
<code><a href="#topic+index">index</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Levi-Civita symbol in 2 dimensions
epsilon(2)

### Levi-Civita symbol in 3 dimensions
epsilon(3)

</code></pre>

<hr>
<h2 id='evaluate'>Evaluate Characters and Expressions</h2><span id='topic+evaluate'></span>

<h3>Description</h3>

<p>Evaluates an array of <code>characters</code> or <code>expressions</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate(f, var, params = list(), vectorize = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate_+3A_f">f</code></td>
<td>
<p>array of <code>characters</code> or <code>expressions</code> to be evaluated.</p>
</td></tr>
<tr><td><code id="evaluate_+3A_var">var</code></td>
<td>
<p>named vector or <code>data.frame</code> in which <code>f</code> is to be evaluated.</p>
</td></tr>
<tr><td><code id="evaluate_+3A_params">params</code></td>
<td>
<p><code>list</code> of additional parameters passed to <code>f</code>.</p>
</td></tr>
<tr><td><code id="evaluate_+3A_vectorize">vectorize</code></td>
<td>
<p><code>logical</code>. Use vectorization? If <code>TRUE</code>, it can significantly boost performance but <code>f</code> needs to handle the vector of inputs appropriately.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Evaluated object. When <code>var</code> is a named vector, the return is an array 
with the same dimensions of <code>f</code>. When <code>var</code> is a <code>data.frame</code>, the
return is a <code>matrix</code> with columns corresponding to the entries of <code>f</code> and 
rows corresponding to the rows of <code>var</code>.
</p>


<h3>References</h3>

<p>Guidotti E (2022). &quot;calculus: High-Dimensional Numerical and Symbolic Calculus in R.&quot; Journal of Statistical Software, 104(5), 1-37. <a href="https://doi.org/10.18637/jss.v104.i05">doi:10.18637/jss.v104.i05</a>
</p>


<h3>See Also</h3>

<p>Other utilities: 
<code><a href="#topic+c2e">c2e</a>()</code>,
<code><a href="#topic+e2c">e2c</a>()</code>,
<code><a href="#topic+wrap">wrap</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### single evaluation
f &lt;- array(letters[1:4], dim = c(2,2))
var &lt;- c(a = 1, b = 2, c = 3, d = 4)
evaluate(f, var)

### multiple evaluation
f &lt;- array(letters[1:4], dim = c(2,2))
var &lt;- data.frame(a = 1:3, b = 2:4, c = 3:5, d = 4:6)
evaluate(f, var)

### multiple evaluation with additional parameters
f &lt;- "a*sum(x)"
var &lt;- data.frame(a = 1:3)
params &lt;- list(x = 1:3)
evaluate(f, var, params)

### multiple evaluation of non-vectorized expressions
f &lt;- "a*myf(x)"
myf &lt;- function(x) if(x&gt;0) 1 else -1
var &lt;- data.frame(a = 1:3, x = -1:1)
evaluate(f, var, params = list(myf = myf), vectorize = FALSE)

</code></pre>

<hr>
<h2 id='gradient'>Numerical and Symbolic Gradient</h2><span id='topic+gradient'></span><span id='topic++25gradient+25'></span>

<h3>Description</h3>

<p>Computes the numerical gradient of <code>functions</code> or the symbolic gradient of <code>characters</code> 
in arbitrary <a href="https://en.wikipedia.org/wiki/Orthogonal_coordinates#Table_of_orthogonal_coordinates">orthogonal coordinate systems</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gradient(
  f,
  var,
  params = list(),
  coordinates = "cartesian",
  accuracy = 4,
  stepsize = NULL,
  drop = TRUE
)

f %gradient% var
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gradient_+3A_f">f</code></td>
<td>
<p>array of <code>characters</code> or a <code>function</code> returning a <code>numeric</code> array.</p>
</td></tr>
<tr><td><code id="gradient_+3A_var">var</code></td>
<td>
<p>vector giving the variable names with respect to which the derivatives are to be computed and/or the point where the derivatives are to be evaluated. See <code><a href="#topic+derivative">derivative</a></code>.</p>
</td></tr>
<tr><td><code id="gradient_+3A_params">params</code></td>
<td>
<p><code>list</code> of additional parameters passed to <code>f</code>.</p>
</td></tr>
<tr><td><code id="gradient_+3A_coordinates">coordinates</code></td>
<td>
<p>coordinate system to use. One of: <code>cartesian</code>, <code>polar</code>, <code>spherical</code>, <code>cylindrical</code>, <code>parabolic</code>, <code>parabolic-cylindrical</code> or a vector of scale factors for each varibale.</p>
</td></tr>
<tr><td><code id="gradient_+3A_accuracy">accuracy</code></td>
<td>
<p>degree of accuracy for numerical derivatives.</p>
</td></tr>
<tr><td><code id="gradient_+3A_stepsize">stepsize</code></td>
<td>
<p>finite differences stepsize for numerical derivatives. It is based on the precision of the machine by default.</p>
</td></tr>
<tr><td><code id="gradient_+3A_drop">drop</code></td>
<td>
<p>if <code>TRUE</code>, return the gradient as a vector and not as an <code>array</code> for scalar-valued functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The gradient of a scalar-valued function <code class="reqn">F</code> is the vector 
<code class="reqn">(\nabla F)_i</code> whose components are the partial derivatives of <code class="reqn">F</code> 
with respect to each variable <code class="reqn">i</code>. 
The <code>gradient</code> is computed in arbitrary orthogonal coordinate systems using the 
scale factors <code class="reqn">h_i</code>:
</p>
<p style="text-align: center;"><code class="reqn">(\nabla F)_i = \frac{1}{h_i}\partial_iF</code>
</p>

<p>When the function <code class="reqn">F</code> is a tensor-valued function <code class="reqn">F_{d_1,\dots,d_n}</code>, 
the <code>gradient</code> is computed for each scalar component. In particular, it becomes
the Jacobian matrix for vector-valued function.
</p>
<p style="text-align: center;"><code class="reqn">(\nabla F_{d_1,\dots,d_n})_i = \frac{1}{h_i}\partial_iF_{d_1,\dots,d_n}</code>
</p>



<h3>Value</h3>

<p>Gradient vector for scalar-valued functions when <code>drop=TRUE</code>, <code>array</code> otherwise.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>f %gradient% var</code>: binary operator with default parameters.
</p>
</li></ul>


<h3>References</h3>

<p>Guidotti E (2022). &quot;calculus: High-Dimensional Numerical and Symbolic Calculus in R.&quot; Journal of Statistical Software, 104(5), 1-37. <a href="https://doi.org/10.18637/jss.v104.i05">doi:10.18637/jss.v104.i05</a>
</p>


<h3>See Also</h3>

<p>Other differential operators: 
<code><a href="#topic+curl">curl</a>()</code>,
<code><a href="#topic+derivative">derivative</a>()</code>,
<code><a href="#topic+divergence">divergence</a>()</code>,
<code><a href="#topic+hessian">hessian</a>()</code>,
<code><a href="#topic+jacobian">jacobian</a>()</code>,
<code><a href="#topic+laplacian">laplacian</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### symbolic gradient 
gradient("x*y*z", var = c("x", "y", "z"))

### numerical gradient in (x=1, y=2, z=3)
f &lt;- function(x, y, z) x*y*z
gradient(f = f, var = c(x=1, y=2, z=3))

### vectorized interface
f &lt;- function(x) x[1]*x[2]*x[3]
gradient(f = f, var = c(1, 2, 3))

### symbolic vector-valued functions
f &lt;- c("y*sin(x)", "x*cos(y)")
gradient(f = f, var = c("x","y"))

### numerical vector-valued functions
f &lt;- function(x) c(sum(x), prod(x))
gradient(f = f, var = c(0,0,0))

### binary operator
"x*y^2" %gradient% c(x=1, y=3)

</code></pre>

<hr>
<h2 id='hermite'>Hermite Polynomials</h2><span id='topic+hermite'></span>

<h3>Description</h3>

<p>Computes univariate and multivariate Hermite polynomials.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hermite(order, sigma = 1, var = "x", transform = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hermite_+3A_order">order</code></td>
<td>
<p>the order of the Hermite polynomial.</p>
</td></tr>
<tr><td><code id="hermite_+3A_sigma">sigma</code></td>
<td>
<p>the covariance <code>matrix</code> of the Gaussian kernel.</p>
</td></tr>
<tr><td><code id="hermite_+3A_var">var</code></td>
<td>
<p><code>character</code> vector giving the variables of the polynomial.</p>
</td></tr>
<tr><td><code id="hermite_+3A_transform">transform</code></td>
<td>
<p><code>character</code> vector representing a change of variables. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Hermite polynomials are obtained by differentiation of the Gaussian kernel:
</p>
<p style="text-align: center;"><code class="reqn">H_{\nu}(x,\Sigma) = exp \Bigl( \frac{1}{2} x_i \Sigma_{ij} x_j \Bigl) (- \partial_x )^\nu exp \Bigl( -\frac{1}{2} x_i \Sigma_{ij} x_j \Bigl)</code>
</p>

<p>where <code class="reqn">\Sigma</code> is a <code class="reqn">d</code>-dimensional square matrix and 
<code class="reqn">\nu=(\nu_1 \dots \nu_d)</code> is the vector representing the order of 
differentiation for each variable <code class="reqn">x = (x_1\dots x_d)</code>. 
In the case where <code class="reqn">\Sigma=1</code> and <code class="reqn">x=x_1</code> the formula reduces to the 
standard univariate Hermite polynomials:
</p>
<p style="text-align: center;"><code class="reqn">H_{\nu}(x) = e^{\frac{x^2}{2}}(-1)^\nu \frac{d^\nu}{dx^\nu}e^{-\frac{x^2}{2}}</code>
</p>

<p>If <code>transform</code> is not <code>NULL</code>, the variables <code>var</code> <code class="reqn">x</code> are replaced with
<code>transform</code> <code class="reqn">f(x)</code> to compute the polynomials <code class="reqn">H_{\nu}(f(x),\Sigma)</code>
</p>


<h3>Value</h3>

<p><code>list</code> of Hermite polynomials with components:
</p>

<dl>
<dt>f</dt><dd><p>the Hermite polynomial.</p>
</dd>
<dt>order</dt><dd><p>the order of the Hermite polynomial.</p>
</dd>
<dt>terms</dt><dd><p><code>data.frame</code> containing the variables, coefficients and degrees of each term in the Hermite polynomial.</p>
</dd>
</dl>



<h3>References</h3>

<p>Guidotti E (2022). &quot;calculus: High-Dimensional Numerical and Symbolic Calculus in R.&quot; Journal of Statistical Software, 104(5), 1-37. <a href="https://doi.org/10.18637/jss.v104.i05">doi:10.18637/jss.v104.i05</a>
</p>


<h3>See Also</h3>

<p>Other polynomials: 
<code><a href="#topic+taylor">taylor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### univariate Hermite polynomials up to order 3
hermite(3)

### multivariate Hermite polynomials up to order 2
hermite(order = 2, 
        sigma = matrix(c(1,0,0,1), nrow = 2), 
        var = c('z1', 'z2'))
        
### multivariate Hermite polynomials with transformation of variables
hermite(order = 2, 
        sigma = matrix(c(1,0,0,1), nrow = 2), 
        var = c('z1', 'z2'),
        transform = c('z1+z2','z1-z2'))
        
</code></pre>

<hr>
<h2 id='hessian'>Numerical and Symbolic Hessian</h2><span id='topic+hessian'></span><span id='topic++25hessian+25'></span>

<h3>Description</h3>

<p>Computes the numerical Hessian of <code>functions</code> or the symbolic Hessian of <code>characters</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hessian(f, var, params = list(), accuracy = 4, stepsize = NULL, drop = TRUE)

f %hessian% var
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hessian_+3A_f">f</code></td>
<td>
<p>array of <code>characters</code> or a <code>function</code> returning a <code>numeric</code> array.</p>
</td></tr>
<tr><td><code id="hessian_+3A_var">var</code></td>
<td>
<p>vector giving the variable names with respect to which the derivatives are to be computed and/or the point where the derivatives are to be evaluated. See <code><a href="#topic+derivative">derivative</a></code>.</p>
</td></tr>
<tr><td><code id="hessian_+3A_params">params</code></td>
<td>
<p><code>list</code> of additional parameters passed to <code>f</code>.</p>
</td></tr>
<tr><td><code id="hessian_+3A_accuracy">accuracy</code></td>
<td>
<p>degree of accuracy for numerical derivatives.</p>
</td></tr>
<tr><td><code id="hessian_+3A_stepsize">stepsize</code></td>
<td>
<p>finite differences stepsize for numerical derivatives. It is based on the precision of the machine by default.</p>
</td></tr>
<tr><td><code id="hessian_+3A_drop">drop</code></td>
<td>
<p>if <code>TRUE</code>, return the Hessian as a matrix and not as an <code>array</code> for scalar-valued functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In Cartesian coordinates, the Hessian of a scalar-valued function <code class="reqn">F</code> is the 
square matrix of second-order partial derivatives:
</p>
<p style="text-align: center;"><code class="reqn">(H(F))_{ij} = \partial_{ij}F</code>
</p>

<p>When the function <code class="reqn">F</code> is a tensor-valued function <code class="reqn">F_{d_1,\dots,d_n}</code>, 
the <code>hessian</code> is computed for each scalar component.
</p>
<p style="text-align: center;"><code class="reqn">(H(F))_{d_1\dots d_n,ij} = \partial_{ij}F_{d_1\dots d_n}</code>
</p>

<p>It might be tempting to apply the definition of the Hessian as the Jacobian of the 
gradient to write it in arbitrary orthogonal coordinate systems. However, this results in a 
Hessian matrix that is not symmetric and ignores the distinction between vector 
and covectors in tensor analysis. The generalization to arbitrary coordinate system 
is not currently supported.
</p>


<h3>Value</h3>

<p>Hessian matrix for scalar-valued functions when <code>drop=TRUE</code>, <code>array</code> otherwise.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>f %hessian% var</code>: binary operator with default parameters.
</p>
</li></ul>


<h3>References</h3>

<p>Guidotti E (2022). &quot;calculus: High-Dimensional Numerical and Symbolic Calculus in R.&quot; Journal of Statistical Software, 104(5), 1-37. <a href="https://doi.org/10.18637/jss.v104.i05">doi:10.18637/jss.v104.i05</a>
</p>


<h3>See Also</h3>

<p>Other differential operators: 
<code><a href="#topic+curl">curl</a>()</code>,
<code><a href="#topic+derivative">derivative</a>()</code>,
<code><a href="#topic+divergence">divergence</a>()</code>,
<code><a href="#topic+gradient">gradient</a>()</code>,
<code><a href="#topic+jacobian">jacobian</a>()</code>,
<code><a href="#topic+laplacian">laplacian</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### symbolic Hessian 
hessian("x*y*z", var = c("x", "y", "z"))

### numerical Hessian in (x=1, y=2, z=3)
f &lt;- function(x, y, z) x*y*z
hessian(f = f, var = c(x=1, y=2, z=3))

### vectorized interface
f &lt;- function(x) x[1]*x[2]*x[3]
hessian(f = f, var = c(1, 2, 3))

### symbolic vector-valued functions
f &lt;- c("y*sin(x)", "x*cos(y)")
hessian(f = f, var = c("x","y"))

### numerical vector-valued functions
f &lt;- function(x) c(sum(x), prod(x))
hessian(f = f, var = c(0,0,0))

### binary operator
"x*y^2" %hessian% c(x=1, y=3)

</code></pre>

<hr>
<h2 id='index'>Tensor Indices</h2><span id='topic+index'></span><span id='topic+index+3C-'></span>

<h3>Description</h3>

<p>Functions to get or set the names of the dimensions of an <code>array</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>index(x)

index(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="index_+3A_x">x</code></td>
<td>
<p><code>array</code>.</p>
</td></tr>
<tr><td><code id="index_+3A_value">value</code></td>
<td>
<p>vector of indices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of indices.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>index(x) &lt;- value</code>: set indices.
</p>
</li></ul>


<h3>References</h3>

<p>Guidotti E (2022). &quot;calculus: High-Dimensional Numerical and Symbolic Calculus in R.&quot; Journal of Statistical Software, 104(5), 1-37. <a href="https://doi.org/10.18637/jss.v104.i05">doi:10.18637/jss.v104.i05</a>
</p>


<h3>See Also</h3>

<p>Other tensor algebra: 
<code><a href="#topic+contraction">contraction</a>()</code>,
<code><a href="#topic+delta">delta</a>()</code>,
<code><a href="#topic+diagonal">diagonal</a>()</code>,
<code><a href="#topic+einstein">einstein</a>()</code>,
<code><a href="#topic+epsilon">epsilon</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### array with no indices
x &lt;- array(1, dim = c(1, 3, 2))
index(x)

### indices on initialization
x &lt;- array(1, dim = c(i=1, j=3, k=2))
index(x)

### set indices on the fly
x &lt;- array(1, dim = c(1, 3, 2))
index(x) &lt;- c("i", "j", "k")
index(x)

</code></pre>

<hr>
<h2 id='integral'>Numerical Integration</h2><span id='topic+integral'></span>

<h3>Description</h3>

<p>Computes the integrals of <code>functions</code> or <code>characters</code> in arbitrary 
<a href="https://en.wikipedia.org/wiki/Orthogonal_coordinates#Table_of_orthogonal_coordinates">orthogonal coordinate systems</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>integral(
  f,
  bounds,
  params = list(),
  coordinates = "cartesian",
  relTol = 0.001,
  absTol = 1e-12,
  method = NULL,
  vectorize = NULL,
  drop = TRUE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="integral_+3A_f">f</code></td>
<td>
<p>array of <code>characters</code> or a <code>function</code> returning a <code>numeric</code> array.</p>
</td></tr>
<tr><td><code id="integral_+3A_bounds">bounds</code></td>
<td>
<p><code>list</code> containing the lower and upper bounds for each variable. If the two bounds coincide, or if a single number is specified, the corresponding variable is not integrated and its value is fixed.</p>
</td></tr>
<tr><td><code id="integral_+3A_params">params</code></td>
<td>
<p><code>list</code> of additional parameters passed to <code>f</code>.</p>
</td></tr>
<tr><td><code id="integral_+3A_coordinates">coordinates</code></td>
<td>
<p>coordinate system to use. One of: <code>cartesian</code>, <code>polar</code>, <code>spherical</code>, <code>cylindrical</code>, <code>parabolic</code>, <code>parabolic-cylindrical</code> or a character vector of scale factors for each variable.</p>
</td></tr>
<tr><td><code id="integral_+3A_reltol">relTol</code></td>
<td>
<p>the maximum relative tolerance.</p>
</td></tr>
<tr><td><code id="integral_+3A_abstol">absTol</code></td>
<td>
<p>the absolute tolerance.</p>
</td></tr>
<tr><td><code id="integral_+3A_method">method</code></td>
<td>
<p>the method to use. One of <code>"mc"</code>, <code>"hcubature"</code>, <code>"pcubature"</code>, <code>"cuhre"</code>, <code>"divonne"</code>, <code>"suave"</code> or <code>"vegas"</code>. Methods other than <code>"mc"</code> (naive Monte Carlo) require the <span class="pkg">cubature</span> package to be installed (efficient integration in C). The defaul uses <code>"hcubature"</code> if <span class="pkg">cubature</span> is installed or <code>"mc"</code> otherwise.</p>
</td></tr>
<tr><td><code id="integral_+3A_vectorize">vectorize</code></td>
<td>
<p><code>logical</code>. Use vectorization? If <code>TRUE</code>, it can significantly boost performance but <code>f</code> needs to handle the vector of inputs appropriately. The default uses <code>FALSE</code> if <code>f</code> is a <code>function</code>, <code>TRUE</code> otherwise.</p>
</td></tr>
<tr><td><code id="integral_+3A_drop">drop</code></td>
<td>
<p>if <code>TRUE</code>, return the integral as a vector and not as an <code>array</code> for vector-valued functions.</p>
</td></tr>
<tr><td><code id="integral_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code>. Print on progress?</p>
</td></tr>
<tr><td><code id="integral_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="cubature.html#topic+cubintegrate">cubintegrate</a></code>, when method <code>"hcubature"</code>, <code>"pcubature"</code>, <code>"cuhre"</code>, <code>"divonne"</code>, <code>"suave"</code> or <code>"vegas"</code> is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function integrates seamlessly with <span class="pkg">cubature</span> for efficient 
numerical integration in C. If the package <span class="pkg">cubature</span> is not 
installed, the function implements a naive Monte Carlo integration by default.
For arbitrary orthogonal coordinates <code class="reqn">q_1\dots q_n</code> the integral is computed as:
</p>
<p style="text-align: center;"><code class="reqn">\int J\cdot f(q_1\dots q_n) dq_1\dots dq_n</code>
</p>

<p>where <code class="reqn">J=\prod_i h_i</code> is the Jacobian determinant of the transformation 
and is equal to the product of the scale factors <code class="reqn">h_1\dots h_n</code>.
</p>


<h3>Value</h3>

<p>list with components
</p>

<dl>
<dt>value</dt><dd><p>the final estimate of the integral.</p>
</dd>
<dt>error</dt><dd><p>estimate of the modulus of the absolute error.</p>
</dd>
<dt>cuba</dt><dd><p><span class="pkg">cubature</span> output when method <code>"hcubature"</code>, <code>"pcubature"</code>, <code>"cuhre"</code>, <code>"divonne"</code>, <code>"suave"</code> or <code>"vegas"</code> is used.</p>
</dd>
</dl>



<h3>References</h3>

<p>Guidotti E (2022). &quot;calculus: High-Dimensional Numerical and Symbolic Calculus in R.&quot; Journal of Statistical Software, 104(5), 1-37. <a href="https://doi.org/10.18637/jss.v104.i05">doi:10.18637/jss.v104.i05</a>
</p>


<h3>See Also</h3>

<p>Other integrals: 
<code><a href="#topic+ode">ode</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### unidimensional integral
i &lt;- integral("sin(x)", bounds = list(x = c(0,pi)))
i$value

### multidimensional integral
f &lt;- function(x,y) x*y
i &lt;- integral(f, bounds = list(x = c(0,1), y = c(0,1)))
i$value

### vector-valued integrals
f &lt;- function(x,y) c(x, y, x*y)
i &lt;- integral(f, bounds = list(x = c(0,1), y = c(0,1)))
i$value

### tensor-valued integrals
f &lt;- function(x,y) array(c(x^2, x*y, x*y, y^2), dim = c(2,2))
i &lt;- integral(f, bounds = list(x = c(0,1), y = c(0,1)))
i$value

### area of a circle
i &lt;- integral(1, 
              bounds = list(r = c(0,1), theta = c(0,2*pi)), 
              coordinates = "polar")
i$value

### surface of a sphere
i &lt;- integral(1, 
              bounds = list(r = 1, theta = c(0,pi), phi = c(0,2*pi)), 
              coordinates = "spherical")
i$value

### volume of a sphere
i &lt;- integral(1, 
         bounds = list(r = c(0,1), theta = c(0,pi), phi = c(0,2*pi)), 
         coordinates = "spherical")
i$value

</code></pre>

<hr>
<h2 id='jacobian'>Numerical and Symbolic Jacobian</h2><span id='topic+jacobian'></span><span id='topic++25jacobian+25'></span>

<h3>Description</h3>

<p>Computes the numerical Jacobian of <code>functions</code> or the symbolic Jacobian of <code>characters</code>
in arbitrary <a href="https://en.wikipedia.org/wiki/Orthogonal_coordinates#Table_of_orthogonal_coordinates">orthogonal coordinate systems</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jacobian(
  f,
  var,
  params = list(),
  coordinates = "cartesian",
  accuracy = 4,
  stepsize = NULL
)

f %jacobian% var
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jacobian_+3A_f">f</code></td>
<td>
<p>array of <code>characters</code> or a <code>function</code> returning a <code>numeric</code> array.</p>
</td></tr>
<tr><td><code id="jacobian_+3A_var">var</code></td>
<td>
<p>vector giving the variable names with respect to which the derivatives are to be computed and/or the point where the derivatives are to be evaluated. See <code><a href="#topic+derivative">derivative</a></code>.</p>
</td></tr>
<tr><td><code id="jacobian_+3A_params">params</code></td>
<td>
<p><code>list</code> of additional parameters passed to <code>f</code>.</p>
</td></tr>
<tr><td><code id="jacobian_+3A_coordinates">coordinates</code></td>
<td>
<p>coordinate system to use. One of: <code>cartesian</code>, <code>polar</code>, <code>spherical</code>, <code>cylindrical</code>, <code>parabolic</code>, <code>parabolic-cylindrical</code> or a vector of scale factors for each varibale.</p>
</td></tr>
<tr><td><code id="jacobian_+3A_accuracy">accuracy</code></td>
<td>
<p>degree of accuracy for numerical derivatives.</p>
</td></tr>
<tr><td><code id="jacobian_+3A_stepsize">stepsize</code></td>
<td>
<p>finite differences stepsize for numerical derivatives. It is based on the precision of the machine by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is basically a wrapper for <code><a href="#topic+gradient">gradient</a></code> with <code>drop=FALSE</code>.
</p>


<h3>Value</h3>

<p><code>array</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>f %jacobian% var</code>: binary operator with default parameters.
</p>
</li></ul>


<h3>References</h3>

<p>Guidotti E (2022). &quot;calculus: High-Dimensional Numerical and Symbolic Calculus in R.&quot; Journal of Statistical Software, 104(5), 1-37. <a href="https://doi.org/10.18637/jss.v104.i05">doi:10.18637/jss.v104.i05</a>
</p>


<h3>See Also</h3>

<p>Other differential operators: 
<code><a href="#topic+curl">curl</a>()</code>,
<code><a href="#topic+derivative">derivative</a>()</code>,
<code><a href="#topic+divergence">divergence</a>()</code>,
<code><a href="#topic+gradient">gradient</a>()</code>,
<code><a href="#topic+hessian">hessian</a>()</code>,
<code><a href="#topic+laplacian">laplacian</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### symbolic Jacobian 
jacobian("x*y*z", var = c("x", "y", "z"))

### numerical Jacobian in (x=1, y=2, z=3)
f &lt;- function(x, y, z) x*y*z
jacobian(f = f, var = c(x=1, y=2, z=3))

### vectorized interface
f &lt;- function(x) x[1]*x[2]*x[3]
jacobian(f = f, var = c(1, 2, 3))

### symbolic vector-valued functions
f &lt;- c("y*sin(x)", "x*cos(y)")
jacobian(f = f, var = c("x","y"))

### numerical vector-valued functions
f &lt;- function(x) c(sum(x), prod(x))
jacobian(f = f, var = c(0,0,0))

### binary operator
"x*y^2" %jacobian% c(x=1, y=3)

</code></pre>

<hr>
<h2 id='laplacian'>Numerical and Symbolic Laplacian</h2><span id='topic+laplacian'></span><span id='topic++25laplacian+25'></span>

<h3>Description</h3>

<p>Computes the numerical Laplacian of <code>functions</code> or the symbolic Laplacian of <code>characters</code> 
in arbitrary <a href="https://en.wikipedia.org/wiki/Orthogonal_coordinates#Table_of_orthogonal_coordinates">orthogonal coordinate systems</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>laplacian(
  f,
  var,
  params = list(),
  coordinates = "cartesian",
  accuracy = 4,
  stepsize = NULL,
  drop = TRUE
)

f %laplacian% var
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="laplacian_+3A_f">f</code></td>
<td>
<p>array of <code>characters</code> or a <code>function</code> returning a <code>numeric</code> array.</p>
</td></tr>
<tr><td><code id="laplacian_+3A_var">var</code></td>
<td>
<p>vector giving the variable names with respect to which the derivatives are to be computed and/or the point where the derivatives are to be evaluated. See <code><a href="#topic+derivative">derivative</a></code>.</p>
</td></tr>
<tr><td><code id="laplacian_+3A_params">params</code></td>
<td>
<p><code>list</code> of additional parameters passed to <code>f</code>.</p>
</td></tr>
<tr><td><code id="laplacian_+3A_coordinates">coordinates</code></td>
<td>
<p>coordinate system to use. One of: <code>cartesian</code>, <code>polar</code>, <code>spherical</code>, <code>cylindrical</code>, <code>parabolic</code>, <code>parabolic-cylindrical</code> or a vector of scale factors for each varibale.</p>
</td></tr>
<tr><td><code id="laplacian_+3A_accuracy">accuracy</code></td>
<td>
<p>degree of accuracy for numerical derivatives.</p>
</td></tr>
<tr><td><code id="laplacian_+3A_stepsize">stepsize</code></td>
<td>
<p>finite differences stepsize for numerical derivatives. It is based on the precision of the machine by default.</p>
</td></tr>
<tr><td><code id="laplacian_+3A_drop">drop</code></td>
<td>
<p>if <code>TRUE</code>, return the Laplacian as a scalar and not as an <code>array</code> for scalar-valued functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Laplacian is a differential operator given by the divergence of the 
gradient of a scalar-valued function <code class="reqn">F</code>, resulting in a scalar value giving 
the flux density of the gradient flow of a function. 
The <code>laplacian</code> is computed in arbitrary orthogonal coordinate systems using 
the scale factors <code class="reqn">h_i</code>:
</p>
<p style="text-align: center;"><code class="reqn">\nabla^2F = \frac{1}{J}\sum_i\partial_i\Biggl(\frac{J}{h_i^2}\partial_iF\Biggl)</code>
</p>

<p>where <code class="reqn">J=\prod_ih_i</code>. When the function <code class="reqn">F</code> is a tensor-valued function 
<code class="reqn">F_{d_1\dots d_n}</code>, the <code>laplacian</code> is computed for each scalar component:
</p>
<p style="text-align: center;"><code class="reqn">(\nabla^2F)_{d_1\dots d_n} = \frac{1}{J}\sum_i\partial_i\Biggl(\frac{J}{h_i^2}\partial_iF_{d_1\dots d_n}\Biggl)</code>
</p>



<h3>Value</h3>

<p>Scalar for scalar-valued functions when <code>drop=TRUE</code>, <code>array</code> otherwise.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>f %laplacian% var</code>: binary operator with default parameters.
</p>
</li></ul>


<h3>References</h3>

<p>Guidotti E (2022). &quot;calculus: High-Dimensional Numerical and Symbolic Calculus in R.&quot; Journal of Statistical Software, 104(5), 1-37. <a href="https://doi.org/10.18637/jss.v104.i05">doi:10.18637/jss.v104.i05</a>
</p>


<h3>See Also</h3>

<p>Other differential operators: 
<code><a href="#topic+curl">curl</a>()</code>,
<code><a href="#topic+derivative">derivative</a>()</code>,
<code><a href="#topic+divergence">divergence</a>()</code>,
<code><a href="#topic+gradient">gradient</a>()</code>,
<code><a href="#topic+hessian">hessian</a>()</code>,
<code><a href="#topic+jacobian">jacobian</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### symbolic Laplacian 
laplacian("x^3+y^3+z^3", var = c("x","y","z"))

### numerical Laplacian in (x=1, y=1, z=1)
f &lt;- function(x, y, z) x^3+y^3+z^3
laplacian(f = f, var = c(x=1, y=1, z=1))

### vectorized interface
f &lt;- function(x) sum(x^3)
laplacian(f = f, var = c(1, 1, 1))

### symbolic vector-valued functions
f &lt;- array(c("x^2","x*y","x*y","y^2"), dim = c(2,2))
laplacian(f = f, var = c("x","y"))

### numerical vector-valued functions
f &lt;- function(x, y) array(c(x^2,x*y,x*y,y^2), dim = c(2,2))
laplacian(f = f, var = c(x=0,y=0))

### binary operator
"x^3+y^3+z^3" %laplacian% c("x","y","z")

</code></pre>

<hr>
<h2 id='mx'>Numerical and Symbolic Matrix Product</h2><span id='topic+mx'></span><span id='topic++25mx+25'></span>

<h3>Description</h3>

<p>Multiplies two <code>numeric</code> or <code>character</code> matrices, if they are conformable. If one argument is a vector, it will be promoted to either a row or column matrix to make the two arguments conformable. If both are vectors of the same length, it will return the inner product (as a <code>matrix</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mx(x, y)

x %mx% y
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mx_+3A_x">x</code></td>
<td>
<p><code>numeric</code> or <code>character</code> matrix.</p>
</td></tr>
<tr><td><code id="mx_+3A_y">y</code></td>
<td>
<p><code>numeric</code> or <code>character</code> matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>matrix</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>x %mx% y</code>: binary operator.
</p>
</li></ul>


<h3>References</h3>

<p>Guidotti E (2022). &quot;calculus: High-Dimensional Numerical and Symbolic Calculus in R.&quot; Journal of Statistical Software, 104(5), 1-37. <a href="https://doi.org/10.18637/jss.v104.i05">doi:10.18637/jss.v104.i05</a>
</p>


<h3>See Also</h3>

<p>Other matrix algebra: 
<code><a href="#topic+mxdet">mxdet</a>()</code>,
<code><a href="#topic+mxinv">mxinv</a>()</code>,
<code><a href="#topic+mxtr">mxtr</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### numeric inner product 
x &lt;- 1:4
mx(x, x)

### symbolic inner product 
x &lt;- letters[1:4]
mx(x, x)

### numeric matrix product
x &lt;- letters[1:4]
y &lt;- diag(4)
mx(x, y)

### symbolic matrix product
x &lt;- array(1:12, dim = c(3,4))
y &lt;- letters[1:4]
mx(x, y)

### binary operator
x &lt;- array(1:12, dim = c(3,4))
y &lt;- letters[1:4]
x %mx% y

</code></pre>

<hr>
<h2 id='mxdet'>Numerical and Symbolic Determinant</h2><span id='topic+mxdet'></span>

<h3>Description</h3>

<p>Computes the determinant of a <code>numeric</code> or <code>character</code> matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxdet(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxdet_+3A_x">x</code></td>
<td>
<p><code>numeric</code> or <code>character</code> matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>numeric</code> or <code>character</code>.
</p>


<h3>References</h3>

<p>Guidotti E (2022). &quot;calculus: High-Dimensional Numerical and Symbolic Calculus in R.&quot; Journal of Statistical Software, 104(5), 1-37. <a href="https://doi.org/10.18637/jss.v104.i05">doi:10.18637/jss.v104.i05</a>
</p>


<h3>See Also</h3>

<p>Other matrix algebra: 
<code><a href="#topic+mxinv">mxinv</a>()</code>,
<code><a href="#topic+mxtr">mxtr</a>()</code>,
<code><a href="#topic+mx">mx</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### numeric matrix
x &lt;- matrix(1:4, nrow = 2)
mxdet(x)

### symbolic matrix
x &lt;- matrix(letters[1:4], nrow = 2)
mxdet(x)

</code></pre>

<hr>
<h2 id='mxinv'>Numerical and Symbolic Matrix Inverse</h2><span id='topic+mxinv'></span>

<h3>Description</h3>

<p>Computes the inverse of a <code>numeric</code> or <code>character</code> matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxinv(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxinv_+3A_x">x</code></td>
<td>
<p><code>numeric</code> or <code>character</code> matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>numeric</code> or <code>character</code> matrix.
</p>


<h3>References</h3>

<p>Guidotti E (2022). &quot;calculus: High-Dimensional Numerical and Symbolic Calculus in R.&quot; Journal of Statistical Software, 104(5), 1-37. <a href="https://doi.org/10.18637/jss.v104.i05">doi:10.18637/jss.v104.i05</a>
</p>


<h3>See Also</h3>

<p>Other matrix algebra: 
<code><a href="#topic+mxdet">mxdet</a>()</code>,
<code><a href="#topic+mxtr">mxtr</a>()</code>,
<code><a href="#topic+mx">mx</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### numeric matrix
x &lt;- matrix(1:4, nrow = 2, byrow = TRUE)
mxinv(x)

### symbolic matrix
x &lt;- matrix(letters[1:4], nrow = 2, byrow = TRUE)
mxinv(x)

</code></pre>

<hr>
<h2 id='mxtr'>Numerical and Symbolic Matrix Trace</h2><span id='topic+mxtr'></span>

<h3>Description</h3>

<p>Computes the trace of a <code>numeric</code> or <code>character</code> matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxtr(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxtr_+3A_x">x</code></td>
<td>
<p><code>numeric</code> or <code>character</code> matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>numeric</code> or <code>character</code>.
</p>


<h3>References</h3>

<p>Guidotti E (2022). &quot;calculus: High-Dimensional Numerical and Symbolic Calculus in R.&quot; Journal of Statistical Software, 104(5), 1-37. <a href="https://doi.org/10.18637/jss.v104.i05">doi:10.18637/jss.v104.i05</a>
</p>


<h3>See Also</h3>

<p>Other matrix algebra: 
<code><a href="#topic+mxdet">mxdet</a>()</code>,
<code><a href="#topic+mxinv">mxinv</a>()</code>,
<code><a href="#topic+mx">mx</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### numeric matrix
x &lt;- matrix(1:4, nrow = 2)
mxtr(x)

### character matrix
x &lt;- matrix(letters[1:4], nrow = 2)
mxtr(x)

</code></pre>

<hr>
<h2 id='ode'>Ordinary Differential Equations</h2><span id='topic+ode'></span>

<h3>Description</h3>

<p>Solves a numerical or symbolic system of ordinary differential equations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ode(
  f,
  var,
  times,
  timevar = NULL,
  params = list(),
  method = "rk4",
  drop = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ode_+3A_f">f</code></td>
<td>
<p>vector of <code>characters</code>, or a <code>function</code> returning a numeric vector, giving the values of the derivatives in the ODE system at time <code>timevar</code>. See examples.</p>
</td></tr>
<tr><td><code id="ode_+3A_var">var</code></td>
<td>
<p>vector giving the initial conditions. See examples.</p>
</td></tr>
<tr><td><code id="ode_+3A_times">times</code></td>
<td>
<p>discretization sequence, the first value represents the initial time.</p>
</td></tr>
<tr><td><code id="ode_+3A_timevar">timevar</code></td>
<td>
<p>the time variable used by <code>f</code>, if any.</p>
</td></tr>
<tr><td><code id="ode_+3A_params">params</code></td>
<td>
<p><code>list</code> of additional parameters passed to <code>f</code>.</p>
</td></tr>
<tr><td><code id="ode_+3A_method">method</code></td>
<td>
<p>the solver to use. One of <code>"rk4"</code> (Runge-Kutta) or <code>"euler"</code> (Euler).</p>
</td></tr>
<tr><td><code id="ode_+3A_drop">drop</code></td>
<td>
<p>if <code>TRUE</code>, return only the final solution instead of the whole trajectory.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of final solutions if <code>drop=TRUE</code>, otherwise a <code>matrix</code> with as many 
rows as elements in <code>times</code> and as many columns as elements in <code>var</code>.
</p>


<h3>References</h3>

<p>Guidotti E (2022). &quot;calculus: High-Dimensional Numerical and Symbolic Calculus in R.&quot; Journal of Statistical Software, 104(5), 1-37. <a href="https://doi.org/10.18637/jss.v104.i05">doi:10.18637/jss.v104.i05</a>
</p>


<h3>See Also</h3>

<p>Other integrals: 
<code><a href="#topic+integral">integral</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## ==================================================
## Example: symbolic system 
## System:  dx = x dt
## Initial: x0 = 1
## ==================================================
f &lt;- "x"
var &lt;- c(x=1)
times &lt;- seq(0, 2*pi, by=0.001)
x &lt;- ode(f, var, times)
plot(times, x, type = "l")

## ==================================================
## Example: time dependent system
## System:  dx = cos(t) dt
## Initial: x0 = 0
## ==================================================
f &lt;- "cos(t)"
var &lt;- c(x=0)
times &lt;- seq(0, 2*pi, by=0.001)
x &lt;- ode(f, var, times, timevar = "t")
plot(times, x, type = "l")

## ==================================================
## Example: multivariate time dependent system
## System:  dx = x dt 
##          dy = x*(1+cos(10*t)) dt
## Initial: x0 = 1
##          y0 = 1
## ==================================================
f &lt;- c("x", "x*(1+cos(10*t))")
var &lt;- c(x=1, y=1)
times &lt;- seq(0, 2*pi, by=0.001)
x &lt;- ode(f, var, times, timevar = "t")
matplot(times, x, type = "l", lty = 1, col = 1:2)

## ==================================================
## Example: numerical system
## System:  dx = x dt 
##          dy = y dt 
## Initial: x0 = 1
##          y0 = 2
## ==================================================
f &lt;- function(x, y) c(x, y)
var &lt;- c(x=1, y=2)
times &lt;- seq(0, 2*pi, by=0.001)
x &lt;- ode(f, var, times)
matplot(times, x, type = "l", lty = 1, col = 1:2)

## ==================================================
## Example: vectorized interface
## System:  dx = x dt 
##          dy = y dt 
##          dz = y*(1+cos(10*t)) dt  
## Initial: x0 = 1
##          y0 = 2
##          z0 = 2
## ==================================================
f &lt;- function(x, t) c(x[1], x[2], x[2]*(1+cos(10*t)))
var &lt;- c(1,2,2)
times &lt;- seq(0, 2*pi, by=0.001)
x &lt;- ode(f, var, times, timevar = "t")
matplot(times, x, type = "l", lty = 1, col = 1:3)

</code></pre>

<hr>
<h2 id='partitions'>Integer Partitions</h2><span id='topic+partitions'></span>

<h3>Description</h3>

<p>Provides fast algorithms for generating integer partitions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partitions(n, max = 0, length = 0, perm = FALSE, fill = FALSE, equal = T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partitions_+3A_n">n</code></td>
<td>
<p>positive integer.</p>
</td></tr>
<tr><td><code id="partitions_+3A_max">max</code></td>
<td>
<p>maximum integer in the partitions.</p>
</td></tr>
<tr><td><code id="partitions_+3A_length">length</code></td>
<td>
<p>maximum number of elements in the partitions.</p>
</td></tr>
<tr><td><code id="partitions_+3A_perm">perm</code></td>
<td>
<p>logical. Permute partitions?</p>
</td></tr>
<tr><td><code id="partitions_+3A_fill">fill</code></td>
<td>
<p>logical. Fill partitions with zeros to match <code>length</code>?</p>
</td></tr>
<tr><td><code id="partitions_+3A_equal">equal</code></td>
<td>
<p>logical. Return only partition of <code>n</code>? If <code>FALSE</code>, partitions of all integers less or equal to <code>n</code> are returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>list</code> of partitions, or <code>matrix</code> if <code>length&gt;0</code> and <code>fill=TRUE</code>.
</p>


<h3>References</h3>

<p>Guidotti E (2022). &quot;calculus: High-Dimensional Numerical and Symbolic Calculus in R.&quot; Journal of Statistical Software, 104(5), 1-37. <a href="https://doi.org/10.18637/jss.v104.i05">doi:10.18637/jss.v104.i05</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### partitions of 4
partitions(4)

### partitions of 4 and permute
partitions(4, perm = TRUE)

### partitions of 4 with max element equal to 2
partitions(4, max = 2)

### partitions of 4 with 2 elements
partitions(4, length = 2)

### partitions of 4 with 3 elements, fill with zeros
partitions(4, length = 3, fill = TRUE)

### partitions of 4 with 2 elements, fill with zeros and permute
partitions(4, length = 2, fill = TRUE, perm = TRUE)

### partitions of all integers less or equal to 3 
partitions(3, equal = FALSE) 

### partitions of all integers less or equal to 3, fill to 2 elements and permute
partitions(3, equal = FALSE, length = 2, fill = TRUE, perm = TRUE) 

</code></pre>

<hr>
<h2 id='taylor'>Taylor Series Expansion</h2><span id='topic+taylor'></span>

<h3>Description</h3>

<p>Computes the Taylor series of <code>functions</code> or <code>characters</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>taylor(
  f,
  var,
  params = list(),
  order = 1,
  accuracy = 4,
  stepsize = NULL,
  zero = 1e-07
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="taylor_+3A_f">f</code></td>
<td>
<p><code>character</code>, or <code>function</code> returning a <code>numeric</code> scalar value.</p>
</td></tr>
<tr><td><code id="taylor_+3A_var">var</code></td>
<td>
<p>vector giving the variable names with respect to which the derivatives are to be computed and/or the point where the derivatives are to be evaluated (the center of the Taylor series). See <code><a href="#topic+derivative">derivative</a></code>.</p>
</td></tr>
<tr><td><code id="taylor_+3A_params">params</code></td>
<td>
<p><code>list</code> of additional parameters passed to <code>f</code>.</p>
</td></tr>
<tr><td><code id="taylor_+3A_order">order</code></td>
<td>
<p>the order of the Taylor approximation.</p>
</td></tr>
<tr><td><code id="taylor_+3A_accuracy">accuracy</code></td>
<td>
<p>degree of accuracy for numerical derivatives.</p>
</td></tr>
<tr><td><code id="taylor_+3A_stepsize">stepsize</code></td>
<td>
<p>finite differences stepsize for numerical derivatives. It is based on the precision of the machine by default.</p>
</td></tr>
<tr><td><code id="taylor_+3A_zero">zero</code></td>
<td>
<p>tolerance used for deciding which derivatives are zero. Absolute values less than this number are set to zero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>list</code> with components:
</p>

<dl>
<dt>f</dt><dd><p>the Taylor series.</p>
</dd>
<dt>order</dt><dd><p>the approximation order.</p>
</dd>
<dt>terms</dt><dd><p><code>data.frame</code> containing the variables, coefficients and degrees of each term in the Taylor series.</p>
</dd>
</dl>



<h3>References</h3>

<p>Guidotti E (2022). &quot;calculus: High-Dimensional Numerical and Symbolic Calculus in R.&quot; Journal of Statistical Software, 104(5), 1-37. <a href="https://doi.org/10.18637/jss.v104.i05">doi:10.18637/jss.v104.i05</a>
</p>


<h3>See Also</h3>

<p>Other polynomials: 
<code><a href="#topic+hermite">hermite</a>()</code>
</p>
<p>Other derivatives: 
<code><a href="#topic+derivative">derivative</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### univariate taylor series (in x=0)
taylor("exp(x)", var = "x", order = 2)

### univariate taylor series of user-defined functions (in x=0)
f &lt;- function(x) exp(x)
taylor(f = f, var = c(x=0), order = 2)

### multivariate taylor series (in x=0 and y=1)
taylor("x*(y-1)", var = c(x=0, y=1), order = 4)

### multivariate taylor series of user-defined functions (in x=0 and y=1)
f &lt;- function(x,y) x*(y-1)
taylor(f, var = c(x=0, y=1), order = 4)

### vectorized interface
f &lt;- function(x) prod(x)
taylor(f, var = c(0,0,0), order = 3)

</code></pre>

<hr>
<h2 id='wrap'>Wrap Characters in Parentheses</h2><span id='topic+wrap'></span>

<h3>Description</h3>

<p>Wraps <code>characters</code> in round brackets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wrap(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wrap_+3A_x">x</code></td>
<td>
<p><code>character</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Characters are automatically wrapped when performing basic symbolic operations to prevent unwanted results. E.g.: 
</p>
<p style="text-align: center;"><code class="reqn">a+b * c+d</code>
</p>
 
<p>instead of 
</p>
<p style="text-align: center;"><code class="reqn">(a+b) * (c+d)</code>
</p>

<p>To disable this behaviour run <code>options(calculus.auto.wrap = FALSE)</code>.
</p>


<h3>Value</h3>

<p><code>character</code>.
</p>


<h3>References</h3>

<p>Guidotti E (2022). &quot;calculus: High-Dimensional Numerical and Symbolic Calculus in R.&quot; Journal of Statistical Software, 104(5), 1-37. <a href="https://doi.org/10.18637/jss.v104.i05">doi:10.18637/jss.v104.i05</a>
</p>


<h3>See Also</h3>

<p>Other utilities: 
<code><a href="#topic+c2e">c2e</a>()</code>,
<code><a href="#topic+e2c">e2c</a>()</code>,
<code><a href="#topic+evaluate">evaluate</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### wrap characters
wrap("a+b")

### wrap array of characters
wrap(array(letters[1:9], dim = c(3,3)))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
