<!DOCTYPE html><html lang="en"><head><title>Help for package micEconCES</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {micEconCES}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cesCalc'><p>Calculate CES function</p></a></li>
<li><a href='#cesEst'><p>Estimate a CES function</p></a></li>
<li><a href='#cesEst-methods'><p>Methods for Estimated CES Functions</p></a></li>
<li><a href='#durbinWatsonTest.cesEst'><p>Durbin Watson Test for Estimated CES Functions</p></a></li>
<li><a href='#GermanIndustry'><p>Aggregated Time Series Data for the West German Industry</p></a></li>
<li><a href='#MishraCES'><p>Mishra's (2006) CES data</p></a></li>
<li><a href='#plot.cesEst'><p>Plot RSSs of a CES Function Estimated by Grid Search</p></a></li>
<li><a href='#summary.cesEst'><p>Summarize Estimation of a CES Function</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.0-2</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-12-23</td>
</tr>
<tr>
<td>Title:</td>
<td>Analysis with the Constant Elasticity of Substitution (CES)
Function</td>
</tr>
<tr>
<td>Author:</td>
<td>Arne Henningsen and Geraldine Henningsen</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Arne Henningsen &lt;arne.henningsen@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.4.0), minpack.lm (&ge; 1.1-4), DEoptim (&ge; 2.0-4), car
(&ge; 2.0-0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>maxLik (&ge; 0.8-0), xtable (&ge; 1.5-6), AER (&ge; 1.1-9)</td>
</tr>
<tr>
<td>Imports:</td>
<td>systemfit (&ge; 1.0-0), micEcon (&ge; 0.6-1), miscTools (&ge; 0.6-1)</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for econometric analysis and economic modelling
   with the traditional two-input Constant Elasticity of Substitution (CES) function
   and with nested CES functions with three and four inputs.
   The econometric estimation can be done by the Kmenta approximation,
   or non-linear least-squares
   using various gradient-based or global optimisation algorithms.
   Some of these algorithms can constrain the parameters to certain ranges,
   e.g. economically meaningful values.
   Furthermore, the non-linear least-squares estimation
   can be combined with a grid-search for the rho-parameter(s).
   The estimation methods are described in Henningsen et al. (2021)
   &lt;<a href="https://doi.org/10.4337%2F9781788976480.00030">doi:10.4337/9781788976480.00030</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/micEcon/micEconCES">https://github.com/micEcon/micEconCES</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.micEcon.org">http://www.micEcon.org</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-12-23 08:36:23 UTC; gsl324</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-06 13:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='cesCalc'>Calculate CES function</h2><span id='topic+cesCalc'></span>

<h3>Description</h3>

<p>Calculate the endogenous variable
of a &lsquo;Constant Elasticity of Substitution&rsquo; (CES)
function.
</p>
<p>The original CES function with two explanatory variables is
</p>
<p style="text-align: center;"><code class="reqn">y = \gamma \: \exp ( \lambda \: t ) \: 
      ( \delta \: x_1^{-\rho} + ( 1 - \delta ) \: x_2^{-\rho} )
      ^{-\frac{\nu}{\rho}}</code>
</p>

<p>and the non-nested CES function with <code class="reqn">N</code> explanatory variables is
</p>
<p style="text-align: center;"><code class="reqn">y = \gamma \: \exp ( \lambda \: t ) \: 
      \left( \sum_{i=1}^N \delta_i \: x_i^{-\rho} \right)
      ^{-\frac{\nu}{\rho}}</code>
</p>

<p>where in the latter case
<code class="reqn">\sum_{i=1}^N \delta_i = 1</code>.
</p>
<p>In both cases, the elesticity of substitution is
<code class="reqn">s = \frac{1}{ 1 + \rho }</code>.
</p>
<p>The <em>nested</em> CES function with 3 explanatory variables 
proposed by Sato (1967) is
</p>
<p style="text-align: center;"><code class="reqn">y = \gamma \: \exp ( \lambda \: t ) \: \left[
      \delta \:
      \left( \delta_1 \: x_1^{-\rho_1} +
      ( 1 - \delta_1 ) x_2^{-\rho_1} \right)^{\frac{\rho}{\rho_1}} +
      ( 1 - \delta ) x_3^{-\rho}
      \right]^{-\frac{\nu}{\rho}}</code>
</p>

<p>and the <em>nested</em> CES function with 4 explanatory variables 
(a generalisation of the version proposed by Sato, 1967) is
</p>
<p style="text-align: center;"><code class="reqn">y = \gamma \: \exp ( \lambda \: t ) \: \left[ \delta \cdot
      \left( \delta_1 \: x_1^{-\rho_1} +
      ( 1 - \delta_1 ) x_2^{-\rho_1} \right)^{\frac{\rho}{\rho_1}} +
      ( 1 - \delta ) \cdot
      \left( \delta_2 \: x_3^{-\rho_2} +
      ( 1 - \delta_2 ) x_4^{-\rho_2} \right)^{\frac{\rho}{\rho_2}}
      \right]^{-\frac{\nu}{\rho}}</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>cesCalc( xNames, data, coef, tName = NULL, nested = FALSE, rhoApprox = 5e-6 )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cesCalc_+3A_xnames">xNames</code></td>
<td>
<p>a vector of strings containing the names of the
explanatory variables.</p>
</td></tr>
<tr><td><code id="cesCalc_+3A_data">data</code></td>
<td>
<p>data frame containing the explanatory variables.</p>
</td></tr>
<tr><td><code id="cesCalc_+3A_coef">coef</code></td>
<td>
<p>numeric vector containing the coefficients of the CES:
if the vector is unnamed,
the order of the coefficients must be
<code class="reqn">\gamma</code>, eventuelly <code class="reqn">\lambda</code>, 
<code class="reqn">\delta</code>, <code class="reqn">\rho</code>, 
and eventually <code class="reqn">\nu</code>
in case of two expanatory variables,
<code class="reqn">\gamma</code>, eventuelly <code class="reqn">\lambda</code>, 
<code class="reqn">\delta_1</code>, ...,
<code class="reqn">\delta_N</code>, <code class="reqn">\rho</code>, and eventually <code class="reqn">\nu</code>
in case of the non-nested CES with <code class="reqn">N&gt;2</code> explanatory variables,
<code class="reqn">\gamma</code>, eventuelly <code class="reqn">\lambda</code>, 
<code class="reqn">\delta_1</code>, <code class="reqn">\delta</code>, 
<code class="reqn">\rho_1</code>, <code class="reqn">\rho</code>, and eventually <code class="reqn">\nu</code>
in case of the nested CES with 3 explanatory variables,
and <code class="reqn">\gamma</code>, eventuelly <code class="reqn">\lambda</code>, 
<code class="reqn">\delta_1</code>, <code class="reqn">\delta_2</code>, 
<code class="reqn">\delta</code>, <code class="reqn">\rho_1</code>, <code class="reqn">\rho_2</code>, 
<code class="reqn">\rho</code>, and eventually <code class="reqn">\nu</code>
in case of the nested CES with 4 explanatory variables,
where in all cases the <code class="reqn">\nu</code> is only required if the model
has variable returns to scale.
If the vector is named, the names must be <code>"gamma"</code>,
<code>"delta"</code>, <code>"rho"</code>, and eventually <code>"nu"</code>
in case of two expanatory variables,
<code>"gamma"</code>, <code>"delta_1"</code>, ..., <code>"delta_N"</code>,
<code>"rho"</code>, and eventually <code>"nu"</code>
in case of the non-nested CES with <code class="reqn">N&gt;2</code> explanatory variables,
and <code>"gamma"</code>, <code>"delta_1"</code>, <code>"delta_2"</code>,
<code>"rho_1"</code>, <code>"rho_2"</code>, <code>"rho"</code>, and eventually <code>"nu"</code>
in case of the nested CES with 4 explanatory variables,
where the order is irrelevant in all cases.</p>
</td></tr>
<tr><td><code id="cesCalc_+3A_tname">tName</code></td>
<td>
<p>optional character string specifying the name of the 
time variable (<code class="reqn">t</code>).</p>
</td></tr>
<tr><td><code id="cesCalc_+3A_nested">nested</code></td>
<td>
<p>logical. ;
if <code>FALSE</code> (the default), the original CES for <code class="reqn">n</code> inputs 
proposed by Kmenta (1967) is used;
if <code>TRUE</code>, the nested version of the CES
for 3 or 4 inputs proposed by Sato (1967) is used.</p>
</td></tr> 
<tr><td><code id="cesCalc_+3A_rhoapprox">rhoApprox</code></td>
<td>
<p>if the absolute value of the coefficient <code class="reqn">\rho</code>,
<code class="reqn">\rho_1</code>, or <code class="reqn">\rho_2</code> 
is smaller than or equal to this argument,
the endogenous variable is calculated
using a first-order Taylor series approximation 
at the point <code class="reqn">\rho</code> = 0 (for non-nested CES functions)
or a linear interpolation (for nested CES functions),
because this avoids large numerical inaccuracies
that frequently occur in calculations with non-linear CES functions
if <code class="reqn">\rho</code>, <code class="reqn">\rho_1</code>, or <code class="reqn">\rho_2</code>
have very small values (in absolute terms).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with length equal to the number of rows of the data set
specified in argument <code>data</code>.
</p>


<h3>Author(s)</h3>

<p>Arne Henningsen and Geraldine Henningsen</p>


<h3>References</h3>

<p>Kmenta, J. (1967):
On Estimation of the CES Production Function.
International Economic Review 8, p. 180-189.
</p>
<p>Sato, K. (1967): 
A Two-Level Constant-Elasticity-of-Substitution Production Function.
Review of Economic Studies 43, p. 201-218.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cesEst">cesEst</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>   data( germanFarms, package = "micEcon" )
   # output quantity:
   germanFarms$qOutput &lt;- germanFarms$vOutput / germanFarms$pOutput
   # quantity of intermediate inputs
   germanFarms$qVarInput &lt;- germanFarms$vVarInput / germanFarms$pVarInput


   ## Estimate CES: Land &amp; Labor with fixed returns to scale
   cesLandLabor &lt;- cesEst( "qOutput", c( "land", "qLabor" ), germanFarms )

   ## Calculate fitted values
   cesCalc( c( "land", "qLabor" ), germanFarms, coef( cesLandLabor ) )


   # variable returns to scale
   cesLandLaborVrs &lt;- cesEst( "qOutput", c( "land", "qLabor" ), germanFarms,
      vrs = TRUE )

   ## Calculate fitted values
   cesCalc( c( "land", "qLabor" ), germanFarms, coef( cesLandLaborVrs ) )
</code></pre>

<hr>
<h2 id='cesEst'>Estimate a CES function</h2><span id='topic+cesEst'></span><span id='topic+print.cesEst'></span>

<h3>Description</h3>

<p>Estimate a Constant-Elasticity-of-Substitution (CES) function
with two exogenous variables
or a nested Constant-Elasticity-of-Substitution (CES) function
proposed by Sato (1967) with three or four exogenous variables
by Least Squares.
The functional forms are shown in the documentation of
function <code><a href="#topic+cesCalc">cesCalc</a></code>.
</p>
<p>Warning: The econometric estimation of a CES function is (almost)
always very problematic,
because very different parameter vectors could result in very similar
values of the objective function (sum of squared residuals).
Hence, even if the optimizer reports
that the nonlinear minimization has converged,
there might be another rather different parameter vector
that results in a lower sum of squared residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cesEst( yName, xNames, data, tName = NULL, vrs = FALSE, method = "LM",
   start = NULL, lower = NULL, upper = NULL, multErr = FALSE,
   rho1 = NULL, rho2, rho = NULL, returnGridAll = FALSE, 
   returnGrad = FALSE, random.seed = 123,
   rhoApprox = c( y = 5e-6, gamma = 5e-6, delta = 5e-6, 
      rho = 1e-3, nu = 5e-6 ),
   checkStart = TRUE, ... )

## S3 method for class 'cesEst'
print( x, digits = max(3, getOption("digits") - 3),
   ... )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cesEst_+3A_yname">yName</code></td>
<td>
<p>a string containing the name of the dependent
variable.</p>
</td></tr>
<tr><td><code id="cesEst_+3A_xnames">xNames</code></td>
<td>
<p>a vector of two, three or four character strings containing 
the names of the independent variables.</p>
</td></tr>
<tr><td><code id="cesEst_+3A_data">data</code></td>
<td>
<p>data frame containing the data.</p>
</td></tr>
<tr><td><code id="cesEst_+3A_tname">tName</code></td>
<td>
<p>optional character string specifying the name of the 
time variable (<code class="reqn">t</code>).</p>
</td></tr>
<tr><td><code id="cesEst_+3A_vrs">vrs</code></td>
<td>
<p>logical. Allow for variable returns to scale?</p>
</td></tr>
<tr><td><code id="cesEst_+3A_method">method</code></td>
<td>
<p>character string indicationg the estimation method:
either <code>"Kmenta"</code> for the Kmenta approximation
or <code>"LM"</code>, <code>"NM"</code>, <code>"Nelder-Mead"</code>, <code>"BFGS"</code>,
<code>"CG"</code>, <code>"L-BFGS-B"</code>, <code>"SANN"</code>,
<code>"Newton"</code>, <code>"PORT"</code>, or <code>"DE"</code>
for non-linear least-squares (see section &lsquo;Details&rsquo;).</p>
</td></tr>
<tr><td><code id="cesEst_+3A_start">start</code></td>
<td>
<p>optional numeric vector giving the starting values
of the parameters in the non-linear estimations
(see section &lsquo;Details&rsquo;).</p>
</td></tr>
<tr><td><code id="cesEst_+3A_lower">lower</code></td>
<td>
<p>lower bounds of the parameters
(see section &lsquo;Details&rsquo;).</p>
</td></tr>
<tr><td><code id="cesEst_+3A_upper">upper</code></td>
<td>
<p>upper bounds of the parameters
(see section &lsquo;Details&rsquo;).</p>
</td></tr>
<tr><td><code id="cesEst_+3A_multerr">multErr</code></td>
<td>
<p>logical. If <code>TRUE</code>, 
the error term is assumed to be multiplicative, 
i.e. <code class="reqn">y = \hat{y} \cdot exp( \epsilon )</code>.
If <code>FALSE</code> (the default), 
the error term is assumed to be additive, 
i.e. <code class="reqn">y = \hat{y} + \epsilon</code>.</p>
</td></tr>
<tr><td><code id="cesEst_+3A_rho1">rho1</code>, <code id="cesEst_+3A_rho2">rho2</code>, <code id="cesEst_+3A_rho">rho</code></td>
<td>
<p>numeric scalar or vector at which the coefficients 
<code class="reqn">\rho_1</code>, <code class="reqn">\rho_2</code>, and/or <code class="reqn">\rho</code>
should be fixed;
if argument <code>rho1</code>, <code>rho2</code>, or <code>rho</code> is <code>NULL</code> (default), 
this coefficient is estimated together
with the other parameters;
if these arguments have more than one element,
a grid search for <code class="reqn">\rho_1</code>, <code class="reqn">\rho_2</code>, 
and/or <code class="reqn">\rho</code> is performed
(see section &lsquo;Details&rsquo;).</p>
</td></tr>
<tr><td><code id="cesEst_+3A_returngridall">returnGridAll</code></td>
<td>
<p>logical value that indicates
whether the estimates for all values of <code class="reqn">\rho</code>
obtained during the grid search
(not just the estimations with the &lsquo;best&rsquo; <code class="reqn">\rho</code>)
should be returned
(ignored if argument <code>rho</code> is <code>NULL</code>
or has only a single element).</p>
</td></tr>
<tr><td><code id="cesEst_+3A_returngrad">returnGrad</code></td>
<td>
<p>logical value that indicates
whether a matrix with the gradients of the dependent variable
(i.e., <code class="reqn">y</code> if argument <code>multErr</code> is <code>FALSE</code>
and <code class="reqn">\log(y)</code> if argument <code>multErr</code> is <code>TRUE</code>)
with respect to the parameters (evaluated at the estimated parameters)
should be returned.</p>
</td></tr>
<tr><td><code id="cesEst_+3A_random.seed">random.seed</code></td>
<td>
<p>an integer used to seed R's random number generator.
This is to ensure replicability when the <code>"SANN"</code>
or <code>"DE"</code> method is used. Defaults to 123.</p>
</td></tr>
<tr><td><code id="cesEst_+3A_rhoapprox">rhoApprox</code></td>
<td>
<p>numeric vector with exactly 5 elements;
the endogenous variable of the CES
and the derivatives with respect to its coefficients
are calculated using a first-order Taylor series approximation
at <code class="reqn">\rho=0</code> (non-nested CES)
or by interpolation between <code class="reqn">\rho</code>, <code class="reqn">\rho_1</code>, 
or <code class="reqn">\rho_2</code> equal to zero 
and <code class="reqn">\rho</code>, <code class="reqn">\rho_1</code>, or <code class="reqn">\rho_2</code> 
equal to <code class="reqn">\pm</code><code>rhoApprox</code>
(nested CES),
if the absolute value of the coefficients <code class="reqn">\rho</code>, 
<code class="reqn">\rho_1</code>, or <code class="reqn">\rho_2</code>
is smaller than or equal to the corresponding element of this argument
(see also argument <code>rhoApprox</code> of <code><a href="#topic+cesCalc">cesCalc</a></code>);
the first element determines the threshold for calculating
the endogenous variable; 
the second element determines the threshold for calculating
the derivatives with respect to <code class="reqn">\gamma</code>;
the third element determines the threshold for calculating
the derivatives with respect to <code class="reqn">\delta_1</code>,
<code class="reqn">\delta_2</code>, and <code class="reqn">\delta</code>;
the fourth element determines the threshold for calculating
the derivatives with respect to <code class="reqn">\rho</code>,
<code class="reqn">\rho_1</code>, and <code class="reqn">\rho_2</code>;
the fifth element determines the threshold for calculating
the derivatives with respect to <code class="reqn">\nu</code>.</p>
</td></tr>
<tr><td><code id="cesEst_+3A_checkstart">checkStart</code></td>
<td>
<p>logical. If <code>TRUE</code> (the default),
it is checked whether the starting values are in the expected ranges
for a production function.</p>
</td></tr>
<tr><td><code id="cesEst_+3A_x">x</code></td>
<td>
<p>an object of class <code>cesEst</code>.</p>
</td></tr>
<tr><td><code id="cesEst_+3A_digits">digits</code></td>
<td>
<p>number of digits.</p>
</td></tr>
<tr><td><code id="cesEst_+3A_...">...</code></td>
<td>
<p>further arguments to <code>cesEst</code> are passed to
<code><a href="stats.html#topic+optim">optim</a></code>, <code><a href="minpack.lm.html#topic+nls.lm">nls.lm</a></code>,
<code><a href="stats.html#topic+nlm">nlm</a></code>, <code><a href="stats.html#topic+nlminb">nlminb</a></code>,
or <code><a href="DEoptim.html#topic+DEoptim">DEoptim</a></code>;
further arguments to <code>print.cesEst</code> are currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><b>Estimation method</b><br />
Argument <code>method</code> determines the estimation method.
If it is <code>"Kmenta"</code>,
the CES is estimated by ordinary least squares using the Kmenta
approximation;
otherwise, it is estimated by non-linear least-squares.
Several different optimizers can be used for the non-linear estimation.
The optimization method
<code>LM</code> (Levenberg-Marquardt, see Moré 1978)
uses <code><a href="minpack.lm.html#topic+nls.lm">nls.lm</a></code> for the optimization.
The optimization methods
<code>NM</code> or <code>Nelder-Mead</code> (Nelder and Mead 1965),
<code>BFGS</code> (Broyden 1970, Fletcher 1970, Goldfarb 1970, Shanno 1970),
<code>CG</code> (Conjugate Gradients based on Fletcher and Reeves 1964),
<code>L-BFGS-B</code> (with box-constraints, Byrd, Lu, Nocedal, and Zhu 1995), and
<code>SANN</code> (Simulated Annealing, Bélisle 1992)
use <code><a href="stats.html#topic+optim">optim</a></code> for the optimization.
The optimization method
<code>Newton</code> (Newton-type, see Dennis and Schnabel 1983
and Schnabel, Koontz, and Weiss 1985)
uses <code><a href="stats.html#topic+nlm">nlm</a></code> for the optimization.
The optimization method
<code>PORT</code> (PORT routines, see Gay 1990)
uses <code><a href="stats.html#topic+nlminb">nlminb</a></code> for the optimization.
The optimization method
<code>DE</code> (Differential Evolution, see Storn and Price 1997)
uses <code><a href="DEoptim.html#topic+DEoptim">DEoptim</a></code> for the optimization.
Analytical gradients are used in the <code>LM</code>, <code>BFGS</code>, <code>CG</code>,
<code>L-BFGS-B</code>, <code>Newton</code>, and <code>PORT</code> method.<br />
</p>
<p><b>Starting values</b><br />
Argument <code>start</code> should be a numeric vector.
The order must be as described in the documentation of argument <code>coef</code>
of function <code><a href="#topic+cesCalc">cesCalc</a></code>.
However, names of the elements are ignored.
If argument <code>start</code> is <code>NULL</code>,
pre-defined starting values are used.
The starting value of <code class="reqn">\lambda</code> (if present) is set to 0.015;
the starting values of <code class="reqn">\delta_1</code>, <code class="reqn">\delta_2</code>, 
and <code class="reqn">\delta</code> (if present) are set to 0.5,
the starting values of <code class="reqn">\rho_1</code>, <code class="reqn">\rho_2</code>, and
<code class="reqn">\rho</code> (if present and required) are set to 0.25
(i.e.\ elasticity of substitution = 0.8 in the two-input case),
the starting value of <code class="reqn">\nu</code> (if present) is set to 1,
and the starting value of <code class="reqn">\gamma</code>
is set to a value
so that the mean of the error term is zero.
Hence, in case of an additive error term
(i.e. argument <code>multErr</code> is set to <code>FALSE</code>, the default) 
<code class="reqn">\gamma</code> is set to 
<code>mean( y ) / mean( CES( X, start1 ) )</code>
and in case of a multiplicative error term
(i.e. argument <code>multErr</code> is set to <code>TRUE</code>) 
<code class="reqn">\gamma</code> is set to 
<code>mean( log( y ) ) - mean( log( CES( X, start1 ) ) )</code>,
where <code>y</code> is the dependent variable (defined by argument <code>yName</code>),
<code>X</code> is the set of covariates 
(defined by arguments <code>xNames</code> and <code>tName</code>),
<code>CES()</code> defines the (nested) CES function,
and <code>start1</code> is a coefficient vector 
with <code class="reqn">\gamma = 1</code> and all other coefficients 
having the starting values described above.<br />
</p>
<p><b>Lower and upper bounds</b><br />
Arguments <code>lower</code> and <code>upper</code> can be used
to set lower and upper bounds for the estimated parameters.
If these arguments are <code>-Inf</code> and <code>Inf</code>, respectively,
the parameters are estimated without unconstraints.
By default, arguments <code>lower</code> and <code>upper</code> are both <code>NULL</code>,
which means that the bounds are set automatically
depending on the estimation method:
In case of the <code>L-BFGS-B</code>, <code>PORT</code>, and <code>DE</code> method,
the lower bound is <code>0</code> for <code class="reqn">\gamma</code>,
<code class="reqn">\delta_1</code>, <code class="reqn">\delta_2</code>, 
and <code class="reqn">\delta</code> (if present), 
<code>-1</code> for <code class="reqn">\rho_1</code>, <code class="reqn">\rho_2</code>, and <code class="reqn">\rho</code>
(if present),
and eventually <code>0</code> for <code class="reqn">\nu</code>.
In case of the <code>L-BFGS-B</code> and <code>PORT</code> method,
the upper bound is infinity for <code class="reqn">\gamma</code>,
<code>1</code> for <code class="reqn">\delta_1</code>, <code class="reqn">\delta_2</code>, and
<code class="reqn">\delta</code> (if present),
infinity for <code class="reqn">\rho_1</code>, <code class="reqn">\rho_2</code>, and <code class="reqn">\rho</code>
(if present),
and eventually infinity for <code class="reqn">\nu</code>.
Since the &lsquo;Differential Evulation&rsquo; algorithm requires finit bounds,
the upper bounds for the <code>DE</code> method are set
to <code>1e10</code> for <code class="reqn">\gamma</code>,
<code>1</code> for <code class="reqn">\delta_1</code>, <code class="reqn">\delta_2</code>, and 
<code class="reqn">\delta</code> (if present),
<code>10</code> for <code class="reqn">\rho_1</code>, <code class="reqn">\rho_2</code>, and <code class="reqn">\rho</code>
(if present),
and eventually <code>10</code> for <code class="reqn">\nu</code>.
In case of all other estimation methods,
the lower and upper bounds are set to <code>-Inf</code> and <code>Inf</code>, respectively,
because these methods do not support parameter constraints.
Of course, the user can specify own lower and upper bounds
by setting arguments <code>lower</code> and <code>upper</code> to numeric vectors
that should have the same format as argument <code>start</code>
(see above).<br />
</p>
<p><b>Grid search for <code class="reqn">\rho</code></b><br />
If arguments <code>rho1</code>, <code>rho2</code>, and/or <code>rho</code> have more than one element,
a one-dimensional, two-dimensional, or three-dimensionsl grid search 
for <code class="reqn">\rho_1</code>, <code class="reqn">\rho_2</code>, and/or <code class="reqn">\rho</code> is performed.
The remaining (free) parameters of the CES are estimated by least-squares,
where <code class="reqn">\rho_1</code>, <code class="reqn">\rho_2</code>, and/or <code class="reqn">\rho</code> are fixed 
consecutively at each value defined in arguments <code>rho1</code>, <code>rho2</code>,
and <code>rho</code>, respectively.
Finally the estimation with the <code class="reqn">\rho_1</code>, <code class="reqn">\rho_2</code>,
and/or <code class="reqn">\rho</code>
that results in the smallest sum of squared residuals is chosen
(and returned).<br />
</p>
<p><b>Random numbers</b><br />
The &lsquo;state&rsquo; (or &lsquo;seed&rsquo;) of R's random number generator
is saved at the beginning of the <code>cesEst</code> function
and restored at the end of this function
so that this function does <em>not</em> affect the generation of random numbers
although the random seed is set to argument <code>random.seed</code>
and the &lsquo;SANN&rsquo; and &lsquo;DE&rsquo; algorithms use random numbers.
</p>


<h3>Value</h3>

<p><code>cesEst</code> returns a list of class <code>cesEst</code>
that has following components:
</p>
<table role = "presentation">
<tr><td><code>coefficients</code></td>
<td>
<p>estimated coefficients/parameters of the CES
(including a possible fixed <code class="reqn">\rho</code>).</p>
</td></tr>
<tr><td><code>ela</code></td>
<td>
<p>constant elasticity/elasticities of substitution.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>number of iterations
(only for non-linear least-squares estimations).</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>logical value indicating if the non-linear estimation
has converged (only for non-linear least-squares estimations
with solvers that have a convergence criterion).</p>
</td></tr>
<tr><td><code>message</code></td>
<td>
<p>additional information from the optimizer
(only if a message was returned by <code><a href="stats.html#topic+optim">optim</a></code> or
<code><a href="minpack.lm.html#topic+nls.lm">nls.lm</a></code>.</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p>approximate covariance matrix of the estimated parameters
calculated from the parameters of the linearized model by the Delta method
(only if argument <code>method</code> is <code>"Kmenta"</code>).</p>
</td></tr>
<tr><td><code>cov.unscaled</code></td>
<td>
<p>unscaled covariance matrix of the estimated parameters
(including a possible fixed <code class="reqn">\rho</code>),
i.e. the inverse of the cross-product of the gradient matrix
evaluated at the estimated parameters.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>the fitted values (<code class="reqn">\hat{y}</code>).</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>the residuals 
(i.e. <code class="reqn">y - \hat{y}</code> 
if argument <code>multErr</code> is <code>FALSE</code> (the default),
and <code class="reqn">log( y ) - log( \hat{y} )</code>
if argument <code>multErr</code> is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code>rss</code></td>
<td>
<p>the sum of the squared residuals 
(i.e. the value of the objective function of the non-linear 
least-squares estimation evaluated at the estimated parameters).</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>argument <code>method</code>.</p>
</td></tr>
<tr><td><code>multErr</code></td>
<td>
<p>argument <code>multErr</code>.</p>
</td></tr>
<tr><td><code>start</code></td>
<td>
<p>starting values for the non-linear estimation
(not for the <code>Kmenta</code> and <code>DE</code> method).</p>
</td></tr>
<tr><td><code>lower</code></td>
<td>
<p>lower bounds of the parameters.</p>
</td></tr>
<tr><td><code>upper</code></td>
<td>
<p>upper bounds of the parameters.</p>
</td></tr>
<tr><td><code>rho</code></td>
<td>
<p>argument <code>rho</code>.</p>
</td></tr>
<tr><td><code>nls.lm</code></td>
<td>
<p>object returned by <code><a href="minpack.lm.html#topic+nls.lm">nls.lm</a></code>
(only if argument <code>method</code> is <code>"LM"</code>).</p>
</td></tr>
<tr><td><code>optim</code></td>
<td>
<p>object returned by <code><a href="stats.html#topic+optim">optim</a></code>
(only if argument <code>method</code> is <code>"NM"</code>, <code>"Nelder-Mead"</code>,
<code>"BFGS"</code>, <code>"CG"</code>, <code>"L-BFGS-B"</code>, or <code>"SANN"</code>)).</p>
</td></tr>
<tr><td><code>nlm</code></td>
<td>
<p>object returned by <code><a href="stats.html#topic+nlm">nlm</a></code>
(only if argument <code>method</code> is <code>"Newton"</code>).</p>
</td></tr>
<tr><td><code>nlminb</code></td>
<td>
<p>object returned by <code><a href="stats.html#topic+nlminb">nlminb</a></code>
(only if argument <code>method</code> is <code>"PORT"</code>).</p>
</td></tr>
<tr><td><code>DEoptim</code></td>
<td>
<p>object returned by <code><a href="DEoptim.html#topic+DEoptim">DEoptim</a></code>
(only if argument <code>method</code> is <code>"DE"</code>).</p>
</td></tr>
<tr><td><code>translog</code></td>
<td>
<p>estimation results of the (unrestricted) translog model
returned by <code><a href="micEcon.html#topic+translogEst">translogEst</a></code>
(only if argument <code>method</code> is <code>"Kmenta"</code>).</p>
</td></tr>
<tr><td><code>kmenta</code></td>
<td>
<p>estimation results of the Kmenta approximation
(a restricted translog model)
returned by <code><a href="systemfit.html#topic+systemfit">systemfit</a></code>
(only if argument <code>method</code> is <code>"Kmenta"</code>).</p>
</td></tr>
<tr><td><code>testKmenta</code></td>
<td>
<p>test of the restrictions implied
by the Kmenta approximation
(including constant returns to scale
if argument <code>vrs</code> is <code>FALSE</code>)
in the unrestricted translog model
returned by <code><a href="car.html#topic+linear.hypothesis">linear.hypothesis</a></code>
(only if argument <code>method</code> is <code>"Kmenta"</code>).</p>
</td></tr>
<tr><td><code>allRhoSum</code></td>
<td>
<p>data frame with summary results of the estimations
with all values of <code class="reqn">\rho</code> used in the grid search
(only if a grid search was performed);
this data frame has follwing columns:
<code>rho</code> = the value of <code class="reqn">\rho</code>,
<code>rss</code> = the corresponding sum of squared residuals, and
(if appropriate for the method used for the estimation)
<code>convergence</code> = logical value indicating whether the estimation
converged.</p>
</td></tr>
<tr><td><code>allRhoFull</code></td>
<td>
<p>list of estimation results returned by <code><a href="#topic+cesEst">cesEst</a></code>
for all values of <code class="reqn">\rho</code> used in the grid search
(only if a grid search was performed and
argument <code>returnGridAll</code> is set to <code>TRUE</code>).</p>
</td></tr>
<tr><td><code>rho1Values</code>, <code>rho2Values</code>, <code>rhoValues</code></td>
<td>
<p>numeric vectors giving the values
that are used in the grid search
for the coefficients <code class="reqn">\rho_1</code> and <code class="reqn">\rho</code>,
respectively (only if a grid search was performed).</p>
</td></tr>
<tr><td><code>rssArray</code></td>
<td>
<p>matrix or array of the RSS values obtained
by a two-dimensional or three-dimensional grid search 
for the coefficients <code class="reqn">\rho_1</code> (first dimension, e.g. rows of a matrix),
<code class="reqn">\rho_2</code>, and <code class="reqn">\rho</code> (last dimension, e.g. columns of a matrix)
(only if a two-dimensional or threedimensional grid search was performed).</p>
</td></tr>
<tr><td><code>grad</code></td>
<td>
<p>matrix with the gradients of the dependent variable
(i.e., <code class="reqn">y</code> if argument <code>multErr</code> is <code>FALSE</code>
and <code class="reqn">\log(y)</code> if argument <code>multErr</code> is <code>TRUE</code>)
with respect to the parameters evaluated at the estimated parameters
(only if argument <code>returnGrad</code> is set to <code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arne Henningsen and Geraldine Henningsen</p>


<h3>References</h3>

<p>Bélisle, C.J.P. (1992):
Convergence theorems for a class of simulated annealing algorithms on Rd,
Journal of Applied Probability 29, p. 885-895.
</p>
<p>Broyden, C.G. (1970):
The Convergence of a Class of Double-rank Minimization Algorithms,
Journal of the Institute of Mathematics and Its Applications 6, p. 76-90.
</p>
<p>Byrd, R.H., Lu, P., Nocedal, J. and Zhu, C. (1995):
A limited memory algorithm for bound constrained optimization,
SIAM J. Scientific Computing 16, p. 1190-1208.
</p>
<p>Dennis, J.E. and Schnabel, R.B. (1983):
Numerical Methods for Unconstrained Optimization and Nonlinear Equations,
Prentice-Hall, Englewood Cliffs, NJ.
</p>
<p>Fletcher, R. (1970):
A New Approach to Variable Metric Algorithms,
Computer Journal 13, p. 317-322.
</p>
<p>Fletcher, R. and Reeves, C.M. (1964):
Function minimization by conjugate gradients,
Computer Journal 7, p. 148-154.
</p>
<p>Gay, D.M. (1990):
Usage Summary for Selected Optimization Routines,
Computing Science Technical Report No. 153,
AT&amp;T Bell Laboratories, Murray Hill NJ.
</p>
<p>Goldfarb, D. (1970):
A Family of Variable Metric Updates Derived by Variational Means,
Mathematics of Computation 24, p. 23-26.
</p>
<p>Moré, J.J. (1978):
The Levenberg-Marquardt algorithm: implementation and theory,
in G.A. Watson (Ed.), Lecture Notes in Mathematics 630: Numerical Analysis,
pp. 105-116, Springer-Verlag: Berlin.
</p>
<p>Nelder, J.A. and Mead, R. (1965):
A simplex algorithm for function minimization,
Computer Journal 7, p. 308-313.
</p>
<p>Schnabel, R.B., Koontz, J.E. and Weiss, B.E. (1985):
A modular system of algorithms for unconstrained minimization,
ACM Trans. Math. Software, 11, pp. 419-440.
</p>
<p>Shanno, D.F. (1970):
Conditioning of Quasi-Newton Methods for Function Minimization,
Mathematics of Computation 24, p. 647-656.
</p>
<p>Storn, R. and Price, K. (1997):
Differential Evolution - A Simple and Efficient Heuristic
for Global Optimization over Continuous Spaces,
Journal of Global Optimization, 11(4), p. 341-359.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.cesEst">summary.cesEst</a></code> for the <code>summary</code> method,
<code><a href="#topic+plot.cesEst">plot.cesEst</a></code> for plotting the results
of the grid search for <code class="reqn">\rho</code>,
<code><a href="#topic+coef.cesEst">coef.cesEst</a></code> for several further methods,
<code><a href="#topic+cesCalc">cesCalc</a></code> for calculations or simulations with the CES,
<code><a href="micEcon.html#topic+translogEst">translogEst</a></code> for estimating translog functions, and
<code><a href="micEcon.html#topic+quadFuncEst">quadFuncEst</a></code> for estimating quadratic functions.</p>


<h3>Examples</h3>

<pre><code class='language-R'>   data( germanFarms, package = "micEcon" )
   # output quantity:
   germanFarms$qOutput &lt;- germanFarms$vOutput / germanFarms$pOutput
   # quantity of intermediate inputs
   germanFarms$qVarInput &lt;- germanFarms$vVarInput / germanFarms$pVarInput


   ## CES: Land &amp; Labor (Levenberg-Marquardt algorithm)
   cesLandLabor &lt;- cesEst( "qOutput", c( "land", "qLabor" ), germanFarms )

   # variable returns to scale, increased max. number of iter. (LM algorithm)
   cesLandLaborVrs &lt;- cesEst( "qOutput", c( "land", "qLabor" ), germanFarms,
      vrs = TRUE, control = nls.lm.control( maxiter = 1000 ) )

   # using the Nelder-Mead optimization method
   cesLandLaborNm &lt;- cesEst( "qOutput", c( "land", "qLabor" ), germanFarms,
      method = "NM" )

   # using the BFGS optimization method
   cesLandLaborBfgs &lt;- cesEst( "qOutput", c( "land", "qLabor" ), germanFarms,
      method = "BFGS" )

   # using the L-BFGS-B optimization method with constrained parameters
   cesLandLaborBfgsCon &lt;- cesEst( "qOutput", c( "land", "qLabor" ),
      germanFarms, method = "L-BFGS-B" )

   # using the CG optimization method
   cesLandLaborSann &lt;- cesEst( "qOutput", c( "land", "qLabor" ), germanFarms,
      method = "CG" )

   # using the SANN optimization method
   # (with decreased number of iteration to decrease execution time)
   cesLandLaborSann &lt;- cesEst( "qOutput", c( "land", "qLabor" ), germanFarms,
      method = "SANN", control = list( maxit = 1000 ) )

   # using the Kmenta approximation
   cesLandLaborKmenta &lt;- cesEst( "qOutput", c( "land", "qLabor" ), germanFarms,
      method = "Kmenta" )

   # using the PORT optimization routine with unconstrained parameters
   cesLandLaborPortCon &lt;- cesEst( "qOutput", c( "land", "qLabor" ),
      germanFarms, vrs = TRUE, method = "PORT", lower = -Inf, upper = Inf )

   # using the PORT optimization routine with constrained parameters and VRS
   cesLandLaborPortCon &lt;- cesEst( "qOutput", c( "land", "qLabor" ),
      germanFarms, vrs = TRUE, method = "PORT" )

   # using the Differential Evolution optimization method
   # (with decreased number of iteration to decrease execution time)
   cesLandLaborDe &lt;- cesEst( "qOutput", c( "land", "qLabor" ), germanFarms,
      method = "DE", control = DEoptim.control( itermax = 50 ) )

   ## estimation with a grid search for rho (using the LM algorithm)
   cesLandInt &lt;- cesEst( "qOutput", c( "land", "qLabor" ),
      data = germanFarms, rho = seq( from = -0.6, to = 0.9, by = 0.3 ) )
</code></pre>

<hr>
<h2 id='cesEst-methods'>Methods for Estimated CES Functions</h2><span id='topic+coef.cesEst'></span><span id='topic+coef.summary.cesEst'></span><span id='topic+fitted.cesEst'></span><span id='topic+residuals.cesEst'></span><span id='topic+vcov.cesEst'></span>

<h3>Description</h3>

<p>Methods for Objects of Class <code>cesEst</code> and <code>cesEst</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cesEst'
coef( object, ... )
## S3 method for class 'summary.cesEst'
coef( object, ... )
## S3 method for class 'cesEst'
fitted( object, ... )
## S3 method for class 'cesEst'
residuals( object, ... )
## S3 method for class 'cesEst'
vcov( object, ... )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cesEst-methods_+3A_object">object</code></td>
<td>
<p>an object of class <code><a href="#topic+cesEst">cesEst</a></code>
or <code><a href="#topic+summary.cesEst">summary.cesEst</a></code>.</p>
</td></tr>
<tr><td><code id="cesEst-methods_+3A_...">...</code></td>
<td>
<p>further arguments are currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>coef.cesEst</code> returns a vector of the estimated coefficients.
</p>
<p><code>coef.summary.cesEst</code> returns a matrix with four columns:
the estimated coefficients/parameters of the CES,
their standard errors, the t-statistic,
and corresponding (two-sided) P-values.
</p>
<p><code>fitted.cesEst</code> returns a vector of the fitted values.
</p>
<p><code>residuals.cesEst</code> returns a vector of the residuals.
</p>
<p><code>vcov.cesEst</code> returns the variance covariance matrix
of the estimated coefficients.
</p>


<h3>Author(s)</h3>

<p>Arne Henningsen and Geraldine Henningsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+cesEst">cesEst</a></code> and <code><a href="#topic+summary.cesEst">summary.cesEst</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>   data( germanFarms, package = "micEcon" )
   # output quantity:
   germanFarms$qOutput &lt;- germanFarms$vOutput / germanFarms$pOutput
   # quantity of intermediate inputs
   germanFarms$qVarInput &lt;- germanFarms$vVarInput / germanFarms$pVarInput


   ## CES: Land &amp; Labor
   cesLandLabor &lt;- cesEst( "qOutput", c( "land", "qLabor" ), germanFarms )

   # estimated coefficients
   coef( cesLandLabor )

   # estimated coefficients, their standard errors, t-statistic, P-values
   coef( summary( cesLandLabor ) )

   # fitted values of the estimated model
   fitted( cesLandLabor )

   # residuals of the estimated model
   residuals( cesLandLabor )

   # covariance matrix of the estimated coefficients
   vcov( cesLandLabor )
</code></pre>

<hr>
<h2 id='durbinWatsonTest.cesEst'>Durbin Watson Test for Estimated CES Functions</h2><span id='topic+durbinWatsonTest.cesEst'></span><span id='topic+dwt.cesEst'></span>

<h3>Description</h3>

<p>Conduct a generalized Durbin-Watson-Test
as suggested by White (1992)
to test for serial correlation of the residuals.
<code>dwt</code> is an abbreviation for <code>durbinWatsonTest</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cesEst'
durbinWatsonTest( model, ... )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="durbinWatsonTest.cesEst_+3A_model">model</code></td>
<td>
<p>object returned by <code>cesEst</code>;
in the call to <code>cesEst</code>,
argument <code>returnGrad</code> must be set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="durbinWatsonTest.cesEst_+3A_...">...</code></td>
<td>
<p>further arguments are passed
to <code><a href="car.html#topic+durbinWatsonTest.lm">durbinWatsonTest.lm</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>References</h3>

<p>White, K.J. (1992):
The Durbin-Watson Test for Autocorrelation in Nonlinear Models.
The Review of Economics and Statistics 74(2), p. 370-373.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cesEst">cesEst</a></code>, <code><a href="car.html#topic+durbinWatsonTest">durbinWatsonTest</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   data( germanFarms, package = "micEcon" )
   # output quantity:
   germanFarms$qOutput &lt;- germanFarms$vOutput / germanFarms$pOutput
   # quantity of intermediate inputs
   germanFarms$qVarInput &lt;- germanFarms$vVarInput / germanFarms$pVarInput

   ## CES: Land &amp; Intermediate Inputs
   cesLandInt &lt;- cesEst( yName = "qOutput",
      xNames = c( "land", "qVarInput" ), data = germanFarms,
      returnGrad = TRUE )

   # conduct the generalized Durbin-Watson test
   dwt( cesLandInt ) 
</code></pre>

<hr>
<h2 id='GermanIndustry'>Aggregated Time Series Data for the West German Industry</h2><span id='topic+GermanIndustry'></span>

<h3>Description</h3>

<p>The data frame <code>GermanIndustry</code> contains annual aggregated data
of the entire West German industry from 1960 until 1993
as well as data of seven industrial sectors from 1970 to 1988/1992.
This data set has been used by Kemfert (1998).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(GermanIndustry)</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns/variables:
</p>

<dl>
<dt>year</dt><dd><p>the year.</p>
</dd>
<dt>Y</dt><dd><p>output: gross value added of the West German industrial sector
(in billion Deutsche Mark at prices of 1991).</p>
</dd>
<dt>K</dt><dd><p>capital: gross stock of fixed assets of the West German 
industrial sector (in billion Deutsche Mark at prices of 1991).</p>
</dd>
<dt>A</dt><dd><p>labor: total number of persons employed in the West German 
industrial sector (in million).</p>
</dd>
<dt>E</dt><dd><p>energy: final energy consumption in the West German 
industrial sector (in GWh).</p>
</dd>
<dt>C_Y</dt><dd><p>gross value added of the West German
chemical industry (in billion Deutsche Mark at prices of 1991).</p>
</dd>
<dt>C_K</dt><dd><p>capital: gross stock of fixed assets of the West German 
chemical industry (in billion Deutsche Mark at prices of 1991).</p>
</dd>
<dt>C_A</dt><dd><p>labor: total number of persons employed in the West German 
chemical industry (in thouands).</p>
</dd>
<dt>C_E</dt><dd><p>final energy consumption in the West German 
chemical industry (in GWh).</p>
</dd>
<dt>S_Y</dt><dd><p>gross value added of the West German
stone and earth industry (in billion Deutsche Mark at prices of 1991).</p>
</dd>
<dt>S_K</dt><dd><p>capital: gross stock of fixed assets of the West German 
stone and earth industry (in billion Deutsche Mark at prices of 1991).</p>
</dd>
<dt>S_A</dt><dd><p>labor: total number of persons employed in the West German 
stone and earth industry (in thouands).</p>
</dd>
<dt>S_E</dt><dd><p>final energy consumption in the West German 
stone and earth industry (in GWh).</p>
</dd>
<dt>I_Y</dt><dd><p>gross value added of the West German
iron industry (in billion Deutsche Mark at prices of 1991).</p>
</dd>
<dt>I_K</dt><dd><p>capital: gross stock of fixed assets of the West German 
iron industry (in billion Deutsche Mark at prices of 1991).</p>
</dd>
<dt>I_A</dt><dd><p>labor: total number of persons employed in the West German 
iron industry (in thouands).</p>
</dd>
<dt>I_E</dt><dd><p>final energy consumption in the West German 
iron industry (in GWh).</p>
</dd>
<dt>N_Y</dt><dd><p>gross value added of the West German
non-ferrous industry (in billion Deutsche Mark at prices of 1991).</p>
</dd>
<dt>N_K</dt><dd><p>capital: gross stock of fixed assets of the West German 
non-ferrous industry (in billion Deutsche Mark at prices of 1991).</p>
</dd>
<dt>N_A</dt><dd><p>labor: total number of persons employed in the West German 
non-ferrous industry (in thouands).</p>
</dd>
<dt>N_E</dt><dd><p>final energy consumption in the West German 
non-ferrous industry (in GWh).</p>
</dd>
<dt>V_Y</dt><dd><p>gross value added of the West German
vehicle industry (in billion Deutsche Mark at prices of 1991).</p>
</dd>
<dt>V_K</dt><dd><p>capital: gross stock of fixed assets of the West German 
vehicle industry (in billion Deutsche Mark at prices of 1991).</p>
</dd>
<dt>V_A</dt><dd><p>labor: total number of persons employed in the West German 
vehicle industry (in thouands).</p>
</dd>
<dt>V_E</dt><dd><p>final energy consumption in the West German 
vehicle industry (in GWh).</p>
</dd>
<dt>P_Y</dt><dd><p>gross value added of the West German
paper industry (in billion Deutsche Mark at prices of 1991).</p>
</dd>
<dt>P_K</dt><dd><p>capital: gross stock of fixed assets of the West German 
paper industry (in billion Deutsche Mark at prices of 1991).</p>
</dd>
<dt>P_A</dt><dd><p>labor: total number of persons employed in the West German 
paper industry (in thouands).</p>
</dd>
<dt>P_E</dt><dd><p>final energy consumption in the West German 
paper industry (in GWh).</p>
</dd>
<dt>F_Y</dt><dd><p>gross value added of the West German
food industry (in billion Deutsche Mark at prices of 1991).</p>
</dd>
<dt>F_K</dt><dd><p>capital: gross stock of fixed assets of the West German 
food industry (in billion Deutsche Mark at prices of 1991).</p>
</dd>
<dt>F_A</dt><dd><p>labor: total number of persons employed in the West German 
food industry (in thouands).</p>
</dd>
<dt>F_E</dt><dd><p>final energy consumption in the West German 
food industry (in GWh).</p>
</dd>
</dl>



<h3>Note</h3>

<p>Please note that Kemfert (1998) disregards the years 1973-1975
in her estimations due to economic disruptions.
</p>


<h3>Source</h3>

<p>German Federal Statistical Office (Statistisches Bundesamt), 
data taken from Kemfert (1998).
</p>


<h3>References</h3>

<p>Kemfert, Claudia (1998): 
Estimated Substitution Elasticities of a Nested CES Production Funktion 
Approach for Germany, 
Energy Economics 20: 249-264
(doi:10.1016/S0140-9883(97)00014-5)
</p>

<hr>
<h2 id='MishraCES'>Mishra's (2006) CES data</h2><span id='topic+MishraCES'></span>

<h3>Description</h3>

<p>The <code>MishraCES</code> data set contains artificial production data.
It has 50 observations (e.g. firms, sectors, or countries).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(MishraCES)</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>No</dt><dd><p>Firm number.</p>
</dd>
<dt>Y</dt><dd><p>Output quantity.</p>
</dd>
<dt>X1</dt><dd><p>Quantity of first input.</p>
</dd>
<dt>X2</dt><dd><p>Quantity of second input.</p>
</dd>
<dt>X3</dt><dd><p>Quantity of third input.</p>
</dd>
<dt>X4</dt><dd><p>Quantity of fouth input.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Mishra, SK (2006):
A Note on Numerical Estimation of Sato's Two-Level CES Production Function
MPRA Working Paper No. 1019,
<a href="https://mpra.ub.uni-muenchen.de/1019/">https://mpra.ub.uni-muenchen.de/1019/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   # load the data set
   data( "MishraCES" )
   
   # show mean values of all variables
   colMeans( MishraCES )

   # re-calculate the endogenous variable (see Mishra 2006)
   # coefficients of the nested CES function with 4 inputs
   b &lt;- c( "gamma" = 200 * 0.5^(1/0.6), "delta_1" = 0.6, "delta_2" = 0.3, 
      "delta" = 0.5, "rho_1" = 0.5, "rho_2" = -0.17, "rho" = 0.6 )
   MishraCES$Y2 &lt;- cesCalc( xNames = c( "X1", "X2", "X3", "X4" ), 
      data = MishraCES, coef = b, nested = TRUE )
   all.equal( MishraCES$Y, MishraCES$Y2 )
</code></pre>

<hr>
<h2 id='plot.cesEst'>Plot RSSs of a CES Function Estimated by Grid Search</h2><span id='topic+plot.cesEst'></span>

<h3>Description</h3>

<p>Plot a scatter plot,
where the values of <code class="reqn">\rho</code> are on the x axis
and the corresponding sums of the squared residuals
obtained by a grid search for <code class="reqn">\rho</code>
are on the y axis.
Estimations that did not converge are marked with red.
</p>
<p>Note that this method can be applied
only if the model was estimated by a grid search for <code class="reqn">\rho</code>,
i.e.\ <code><a href="#topic+cesEst">cesEst</a></code> was called with argument <code>rho</code>
set to a vector of more than one values for <code class="reqn">\rho</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cesEst'
plot( x, negRss = TRUE, bw = FALSE, ... )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.cesEst_+3A_x">x</code></td>
<td>
<p>object returned by <code>cesEst</code>
if it was called with argument <code>rho</code> set a vector
containing more than one value for <code class="reqn">\rho</code>
so that a grid search was performed.</p>
</td></tr>
<tr><td><code id="plot.cesEst_+3A_negrss">negRss</code></td>
<td>
<p>logical. Indicates whether the <em>negative</em>
sum of squared residuals should be plotted in 3D plots 
(ignored in 2D plots).</p>
</td></tr>
<tr><td><code id="plot.cesEst_+3A_bw">bw</code></td>
<td>
<p>logical. Indicates whether 3D plots should be in black-and-white
or colored.</p>
</td></tr>
<tr><td><code id="plot.cesEst_+3A_...">...</code></td>
<td>
<p>All further arguments are passed
to <code><a href="graphics.html#topic+plot.default">plot.default</a></code>
or <code><a href="graphics.html#topic+persp">persp</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arne Henningsen and Geraldine Henningsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+cesEst">cesEst</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   data( germanFarms, package = "micEcon" )
   # output quantity:
   germanFarms$qOutput &lt;- germanFarms$vOutput / germanFarms$pOutput
   # quantity of intermediate inputs
   germanFarms$qVarInput &lt;- germanFarms$vVarInput / germanFarms$pVarInput

   ## CES: Land &amp; Intermediate Inputs
   cesLandInt &lt;- cesEst( yName = "qOutput",
      xNames = c( "land", "qVarInput" ), data = germanFarms,
      rho = seq( from = -0.6, to = 0.9, by = 0.3 ) )

   # plot the rhos against the sum of squared residuals
   plot( cesLandInt ) 
</code></pre>

<hr>
<h2 id='summary.cesEst'>Summarize Estimation of a CES Function</h2><span id='topic+summary.cesEst'></span><span id='topic+print.summary.cesEst'></span>

<h3>Description</h3>

<p><code>summary</code> method for objects of class <code><a href="#topic+cesEst">cesEst</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cesEst'
summary( object, rSquaredLog = object$multErr, ela = TRUE, ... )
## S3 method for class 'summary.cesEst'
print( x, ela = TRUE, digits = max(3, getOption("digits") - 3),
   ... )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.cesEst_+3A_object">object</code></td>
<td>
<p>an object returned by <code><a href="#topic+cesEst">cesEst</a></code>.</p>
</td></tr>
<tr><td><code id="summary.cesEst_+3A_rsquaredlog">rSquaredLog</code></td>
<td>
<p>logical.
If <code>FALSE</code> (the default for models with additive error term),
the returned <code class="reqn">R^2</code>-value measures the fraction of the explained
variance of the dependent variable in natural units.
If <code>TRUE</code> (the default for models with multiplicative error term),
the returned <code class="reqn">R^2</code>-value measures the fraction of the explained
variance of the <em>logarithmized</em> dependent variable.</p>
</td></tr>
<tr><td><code id="summary.cesEst_+3A_ela">ela</code></td>
<td>
<p>logical. If <code>TRUE</code> (the default), 
the <code>summary</code> method calculates 
the (co)variances of the constant elasticities of substitution
and the <code>print</code> method prints these elasticities 
together with corresponding summary statistics.
If <code>FALSE</code>, 
the <code>summary</code> method does not 
calculate the (co)variances of the constant elasticities of substitution
and the <code>print</code> method does not print these elasticities.</p>
</td></tr>
<tr><td><code id="summary.cesEst_+3A_x">x</code></td>
<td>
<p>an object returned by <code>summary.cesEst</code>.</p>
</td></tr>
<tr><td><code id="summary.cesEst_+3A_digits">digits</code></td>
<td>
<p>number of digits.</p>
</td></tr>
<tr><td><code id="summary.cesEst_+3A_...">...</code></td>
<td>
<p>further arguments are currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>summary.cesEst</code> returns a list of class <code>summary.cesEst</code>
that contains the elements of the provided <code>object</code> with with
following changes or additions:
</p>
<table role = "presentation">
<tr><td><code>coefficients</code></td>
<td>
<p>a matrix with four columns:
the estimated coefficients/parameters of the CES
(including a possible fixed <code class="reqn">\rho</code>),
their standard errors, the t-statistic,
and corresponding (two-sided) P-values.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>square root of the estimated (asymptotic) variance
of the random error
(calculated without correcting for degrees of freedom).</p>
</td></tr>
<tr><td><code>r.squared</code></td>
<td>
<p><code class="reqn">R^2</code>-value, i.e. the
&lsquo;fraction of variance explained by the model&rsquo;.
If argument <code>rSquaredLog</code> is <code>TRUE</code>,
the <code class="reqn">R^2</code>-value measures the fraction of the explained
variance of the <em>logarithmized</em> dependent variable.</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p>covariance matrix of the estimated parameters
(including a possible fixed <code class="reqn">\rho</code>).</p>
</td></tr>
<tr><td><code>ela</code></td>
<td>
<p>a matrix with four columns:
the estimated elasticities of substitution,
their standard errors, the t-statistic,
and corresponding (two-sided) P-values
(only if argument <code>ela</code> is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code>elaCov</code></td>
<td>
<p>covariance matrix of the estimated 
elasticities of substitution
(only if argument <code>ela</code> is <code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+cesEst">cesEst</a></code> and <code><a href="#topic+cesCalc">cesCalc</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>   data( germanFarms, package = "micEcon" )
   # output quantity:
   germanFarms$qOutput &lt;- germanFarms$vOutput / germanFarms$pOutput
   # quantity of intermediate inputs
   germanFarms$qVarInput &lt;- germanFarms$vVarInput / germanFarms$pVarInput


   ## CES: Land &amp; Labor
   cesLandLabor &lt;- cesEst( "qOutput", c( "land", "qLabor" ), germanFarms )

   # print summary results
   summary( cesLandLabor )
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
