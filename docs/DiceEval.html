<!DOCTYPE html><html><head><title>Help for package DiceEval</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DiceEval}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#crossValidation'><p>K-fold Cross Validation</p></a></li>
<li><a href='#dataIRSN5D'><p>5D benchmark from nuclear criticality safety assessments</p></a></li>
<li><a href='#DiceEval-package'><p>Metamodels</p></a></li>
<li><a href='#foldsComposition'><p>Setting up the Cross Validation</p></a></li>
<li><a href='#formulaAm'><p>Construction of a formula Y~s(X1)+...+s(Xp)</p></a></li>
<li><a href='#formulaLm'><p>Construction of a formula Y ~ X1+...+Xp</p></a></li>
<li><a href='#MAE'><p>Mean Absolute Error</p></a></li>
<li><a href='#modelComparison'><p>Comparison of different types of metamodels</p></a></li>
<li><a href='#modelFit'><p>Fitting metamodels</p></a></li>
<li><a href='#modelPredict'><p>Prediction at newdata for a fitted metamodel</p></a></li>
<li><a href='#penaltyPolyMARS'><p>Choice of the penalty parameter for a PolyMARS model</p></a></li>
<li><a href='#R2'><p>Multiple R-Squared</p></a></li>
<li><a href='#residualsStudy'><p>Plot residuals</p></a></li>
<li><a href='#RMA'><p>Relative Maximal Absolute Error</p></a></li>
<li><a href='#RMSE'><p>Root Mean Squared Error</p></a></li>
<li><a href='#stepEvolution'><p>Evolution of the stepwise model</p></a></li>
<li><a href='#testCrossValidation'><p>Test the robustess of the cross-validation procedure</p></a></li>
<li><a href='#testIRSN5D'><p>A set of test data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Construction and Evaluation of Metamodels</td>
</tr>
<tr>
<td>Version:</td>
<td>1.6.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-30</td>
</tr>
<tr>
<td>Author:</td>
<td>D. Dupuy and C. Helbert</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>C. Helbert &lt;Celine.Helbert@ec-lyon.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimation, validation and prediction of models of different types : linear models, additive models, MARS,PolyMARS and Kriging.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>DiceKriging</td>
</tr>
<tr>
<td>Suggests:</td>
<td>gam, mda, polspline</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-01 08:42:08 UTC; chelbert</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-04 15:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='crossValidation'>K-fold Cross Validation</h2><span id='topic+crossValidation'></span>

<h3>Description</h3>

<p>This function calculates the predicted values at each point of the design and gives an estimation of criterion using K-fold cross-validation.</p>


<h3>Usage</h3>

<pre><code class='language-R'>crossValidation(model, K)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crossValidation_+3A_model">model</code></td>
<td>
<p>an output of the <code>modelFit</code> function. This argument is the initial model fitted with all the data.</p>
</td></tr>
<tr><td><code id="crossValidation_+3A_k">K</code></td>
<td>
<p>the number of groups into which the data should be split to apply cross-validation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components: 
</p>
<table>
<tr><td><code>Ypred</code></td>
<td>
<p>a vector of predicted values obtained using K-fold cross-validation at the points of the design</p>
</td></tr>
<tr><td><code>Q2</code></td>
<td>
<p>a real which is the estimation of the criterion <code>R2</code> obtained by cross-validation</p>
</td></tr>
<tr><td><code>folds</code></td>
<td>
<p>a list which indicates the partitioning of the data into the folds</p>
</td></tr>
<tr><td><code>RMSE_CV</code></td>
<td>
<p><code><a href="#topic+RMSE">RMSE</a></code> by K-fold cross-validation (see more details below)</p>
</td></tr>
<tr><td><code>MAE_CV</code></td>
<td>
<p><code><a href="#topic+MAE">MAE</a></code>  by K-fold cross-validation (see more details below)</p>
</td></tr>
</table>
<p>In the case of a Kriging model, other components to test the robustess of the procedure are proposed: 
</p>
<table>
<tr><td><code>theta</code></td>
<td>
<p>the range parameter theta estimated for each fold,</p>
</td></tr>
<tr><td><code>trend</code></td>
<td>
<p>the trend parameter estimated for each fold,</p>
</td></tr>
<tr><td><code>shape</code></td>
<td>
<p>the estimated shape parameter if the covariance structure is of type <code>powerexp</code>.</p>
</td></tr>
</table>
<p>The principle of cross-validation is to split the data into <code class="reqn">K</code> folds of approximately equal size <code class="reqn">A_{1}{A1}, ..., A_{K}{AK}</code>. For <code class="reqn">k=1</code> to <code class="reqn">K</code>, a model <code class="reqn">\hat{Y}^{(-k)}</code> is fitted from the data <code class="reqn">\cup_{j \neq k} A_{k}</code> and this model is validated on the fold <code class="reqn">A_{k}</code>. Given a criterion of quality <code class="reqn">L</code> (here, <code class="reqn">L</code> could be the <code>RMSE</code> or the <code>MAE</code> criterion), the &quot;evaluation&quot; of the model consists in computing :
</p>
<p style="text-align: center;"><code class="reqn">L_{k} = \frac{1}{n/K} \sum_{i \in A_{k}} L \left( y_{i}, Y^{(-k)} (x_{i} )\right).</code>
</p>

<p>The cross-validation criterion is the mean of the <code class="reqn">K</code> criterion: <code class="reqn">L</code>_CV<code class="reqn">=\frac{1}{K} \sum_{k=1}^{K} L_{k}.</code>
</p>
<p>The <code>Q2</code> criterion is defined as: <code>Q2</code><code class="reqn">=\code{R2}(\code{Y},\code{Ypred})</code> with <code>Y</code> the response value and <code>Ypred</code> the value fit by cross-validation.
</p>


<h3>Note</h3>

<p>When <code>K</code> is equal to the number of observations, <em>leave-one-out</em> cross-validation
is performed.</p>


<h3>Author(s)</h3>

<p>D. Dupuy</p>


<h3>See Also</h3>

<p><code><a href="#topic+R2">R2</a></code>, <code><a href="#topic+modelFit">modelFit</a></code>, <code><a href="#topic+MAE">MAE</a></code>, <code><a href="#topic+RMSE">RMSE</a></code>, <code><a href="#topic+foldsComposition">foldsComposition</a></code>, <code><a href="#topic+testCrossValidation">testCrossValidation</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
rm(list=ls())
# A 2D example
Branin &lt;- function(x1,x2) {
  x1 &lt;- x1*15-5   
  x2 &lt;- x2*15
  (x2 - 5/(4*pi^2)*(x1^2) + 5/pi*x1 - 6)^2 + 10*(1 - 1/(8*pi))*cos(x1) + 10
}

# Linear model on 50 points
n &lt;- 50
X &lt;- matrix(runif(n*2),ncol=2,nrow=n)
Y &lt;- Branin(X[,1],X[,2])
modLm &lt;- modelFit(X,Y,type = "Linear",formula=Y~X1+X2+X1:X2+I(X1^2)+I(X2^2))
R2(Y,modLm$model$fitted.values)
crossValidation(modLm,K=10)$Q2


# kriging model : gaussian covariance structure, no trend, no nugget effect
# on 16 points 
n &lt;- 16
X &lt;- data.frame(x1=runif(n),x2=runif(n))
Y &lt;- Branin(X[,1],X[,2])
mKm &lt;- modelFit(X,Y,type="Kriging",formula=~1, covtype="powexp")
K &lt;- 10
out   &lt;- crossValidation(mKm, K)
par(mfrow=c(2,2))
plot(c(0,1:K),c(mKm$model@covariance@range.val[1],out$theta[,1]),
 	xlab='',ylab='Theta1')
 plot(c(0,1:K),c(mKm$model@covariance@range.val[2],out$theta[,2]),
 	xlab='',ylab='Theta2')
 plot(c(0,1:K),c(mKm$model@covariance@shape.val[1],out$shape[,1]),
 	xlab='',ylab='p1',ylim=c(0,2))
 plot(c(0,1:K),c(mKm$model@covariance@shape.val[2],out$shape[,2]),
 	xlab='',ylab='p2',ylim=c(0,2))
par(mfrow=c(1,1))

## End(Not run)
</code></pre>

<hr>
<h2 id='dataIRSN5D'>5D benchmark from nuclear criticality safety assessments</h2><span id='topic+dataIRSN5D'></span>

<h3>Description</h3>

<p>Nuclear criticality safety assessments are based on an optimization process to search for safety-penalizing physical conditions in a given range of parameters of a system involving fissile materials.
</p>
<p>In the following examples, the criticality coefficient (namely k-effective or keff) models the nuclear chain reaction trend:
</p>
<p>- keff &gt; 1 is an increasing neutrons production leading to an uncontrolled chain reaction potentially having deep consequences on safety,
</p>
<p>- keff = 1 means a stable neutrons population as required in nuclear reactors,
</p>
<p>- keff &lt; 1 is the safety state required for all unused fissile materials, like for fuel storage.
</p>
<p>Besides its fissile materials geometry and composition, the criticality of a system is widely sensitive to physical parameters like water density, geometrical perturbations or structure materials (like concrete) characteristics. Thereby, a typical criticality safety assessment is supposed to verify that k-effective cannot reach the critical value of 1.0 (in practice the limit value used is 0.95) for given hypothesis on these parameters.
</p>
<p>The benchmark system is an assembly of four fuel rods contained in a reflecting hull. Regarding criticality safety hypothesis, the main parameters are the uranium enrichment of fuel (namely &quot;e&quot;, U235 enrichment, varying in [0.03, 0.07]), the rods assembly geometrical characteristics (namely &quot;p&quot;, the pitch between rods, varying in [1.0, 2.0] cm and &quot;l&quot;, the length of fuel rods, varying in [10, 60] cm), the water density inside the assembly (namely &quot;b&quot;, varying in [0.1, 0.9]) , and the hull reflection characteristics (namely &quot;r&quot;, reflection coefficient, varying in [0.75, 0.95]).
</p>
<p>In this criticality assessment, the MORET (Fernex et al., 2005) Monte Carlo simulator is used to estimate the criticality coefficient of the fuel storage system using these parameters (among other) as numerical input,. The output k-effective is returned as a Gaussian density which standard deviation is setup to be negligible regarding input parameters sensitivity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dataIRSN5D)</code></pre>


<h3>Format</h3>

<p>a data frame with 50 observations (lines) and 6 columns. Columns 1 to 5 correspond to the design of experiments for the input variables (&quot;b&quot;,&quot;e&quot;,&quot;p&quot;,&quot;r&quot; and &quot;l&quot;) and the last column the value of the output &quot;keff&quot;.</p>


<h3>Author(s)</h3>

<p>Y. Richet</p>


<h3>Source</h3>

<p>IRSN (Institut de Radioprotection et de Sûreté Nucléaire)</p>


<h3>References</h3>

<p>Fernex F., Heulers L, Jacquet O., Miss J. and Richet Y. (2005) <em>The MORET 4B Monte Carlo code - New features to treat complex criticality systems</em>, M&amp;C International Conference on Mathematics and Computation Supercomputing, Reactor Physics and Nuclear and Biological Application, Avignon, 12/09/2005
</p>

<hr>
<h2 id='DiceEval-package'>Metamodels</h2><span id='topic+DiceEval-package'></span><span id='topic+DiceEval'></span>

<h3>Description</h3>

<p>Construction and evaluation of metamodels.
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> DiceEval</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.4</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2015-06-15</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Details</h3>

<p>This package is dedicated to the construction of metamodels. A validation procedure is also proposed using usual criteria (RMSE, MAE etc.) and cross-validation procedure. Moreover, graphical tools help to choose the best value for the penalty parameter of a stepwise or a PolyMARS model. Another routine is dedicated to the comparison of metamodels.
</p>


<h3>Note</h3>

<p>This work was conducted within the frame of the DICE (Deep Inside Computer Experiments) Consortium between ARMINES, Renault, EDF, IRSN, ONERA and TOTAL S.A. (http://emse.dice.fr/).
</p>
<p>Functions <code><a href="gam.html#topic+gam">gam</a></code>, <code><a href="mda.html#topic+mars">mars</a></code> and <code><a href="polspline.html#topic+polymars">polymars</a></code> are required for the construction of metamodels. <code><a href="DiceKriging.html#topic+km">km</a></code> provides Kriging models.
</p>


<h3>Author(s)</h3>

<p>D. Dupuy &amp; C. Helbert
</p>


<h3>References</h3>

<p>Dupuy D., Helbert C., Franco J. (2015), DiceDesign and DiceEval: Two R-Packages for Design and Analysis of Computer Experiments, <em>Journal of Statistical Software</em>, <b>65</b>(11), 1&ndash;38, <a href="https://www.jstatsoft.org/v65/i11/">https://www.jstatsoft.org/v65/i11/</a>.
</p>
<p>Friedman J. (1991), Multivariate Adaptative Regression Splines (invited paper),
<em>Annals of Statistics</em>, <b>10</b>/1, 1-141.
</p>
<p>Hastie T. and Tibshirani R. (1990), Generalized Additive Models, <em>Chapman and Hall, London</em>. 
</p>
<p>Hastie T., Tibshirani R. and Friedman J. (2001), The Elements of Statistical Learning : Data Mining, Inference and Prediction, <em>Springer</em>.
</p>
<p>Helbert C. and Dupuy D. (2007-09-26), Retour d'exp?riences sur m?tamod?les : partie th?orique, <em>Livrable r?dig? dans le cadre du Consortium DICE</em>.
</p>
<p>Kooperberg C., Bose S. and Stone C.J. (1997), Polychotomous Regression, <em>Journal of the American Statistical Association</em>, <b>92</b> Issue 437, 117-127.
</p>
<p>Rasmussen C.E. and Williams C.K.I. (2006), Gaussian Processes for Machine Learning, <em>the MIT Press</em>, www.GaussianProcess.org/gpml.
</p>
<p>Stones C., Hansen M.H., Kooperberg C. and Truong Y.K. (1997), Polynomial Splines and their Tensor Products in Extended Linear Modeling, <em>Annals of Statistics</em>, <b>25</b>/4, 1371-1470.</p>


<h3>See Also</h3>

<p><code><a href="#topic+modelFit">modelFit</a></code>, <code><a href="#topic+modelPredict">modelPredict</a></code>,
<code><a href="#topic+crossValidation">crossValidation</a></code> and <code><a href="#topic+modelComparison">modelComparison</a></code>
</p>
<p>Different space-filling designs can be found in the <code>DiceDesign</code> package and we refer to the <code>DiceKriging</code> package for the construction of kriging models. This package takes part of a toolbox inplemented during the Dice consortium.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
rm(list=ls())
# A 2D example
Branin	&lt;- function(x1,x2) {
x1	&lt;- 1/2*(15*x1+5)   
x2	&lt;- 15/2*(x2+1)
(x2 - 5.1/(4*pi^2)*(x1^2) + 5/pi*x1 - 6)^2 + 10*(1 - 1/(8*pi))*cos(x1) + 10
}
# A 2D uniform design with n points in [-1,1]^2
n	&lt;- 50
X	&lt;- matrix(runif(n*2,-1,1),ncol=2,nrow=n)
Y	&lt;- Branin(X[,1],X[,2])
Z	&lt;- (Y-mean(Y))/sd(Y)

# Construction of a PolyMARS model with a penalty parameter equal to 2
library(polspline)
modPolyMARS	&lt;- modelFit(X,Z,type = "PolyMARS",gcv=2.2)

# Prediction and comparison between the exact function and the predicted one
xtest	&lt;- seq(-1, 1, length= 21) 
ytest	&lt;- seq(-1, 1, length= 21)
Zreal	&lt;- outer(xtest, ytest, Branin)
Zreal	&lt;- (Zreal-mean(Y))/sd(Y)
Zpredict	&lt;- modelPredict(modPolyMARS,expand.grid(xtest,ytest))
m	&lt;- min(floor(Zreal),floor(Zpredict))
M	&lt;- max(ceiling(Zreal),ceiling(Zpredict))
persp(xtest, ytest, Zreal, theta = 30, phi = 30, expand = 0.5,
	col = "lightblue",main="Branin function",zlim=c(m,M),
	ticktype = "detailed")

persp(xtest, ytest, matrix(Zpredict,nrow=length(xtest),
	ncol=length(ytest)), theta = 30, phi = 30, expand = 0.5,
	col = "lightblue",main="PolyMARS Model",zlab="Ypredict",zlim=c(m,M),
	ticktype = "detailed")

# Comparison of models
modelComparison(X,Y,type=c("Linear", "StepLinear","PolyMARS","Kriging"),
	formula=Y~X1+X2+X1:X2+I(X1^2)+I(X2^2),penalty=log(dim(X)[1]), gcv=4)

# see also the demonstration example in dimension 5 (source: IRSN)
demo(IRSN5D)

## End(Not run)
</code></pre>

<hr>
<h2 id='foldsComposition'>Setting up the Cross Validation</h2><span id='topic+foldsComposition'></span>

<h3>Description</h3>

<p>Randomly partitioning the data into folders
</p>


<h3>Usage</h3>

<pre><code class='language-R'>foldsComposition(n, K)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="foldsComposition_+3A_n">n</code></td>
<td>
<p>number of observations</p>
</td></tr>
<tr><td><code id="foldsComposition_+3A_k">K</code></td>
<td>
<p>number of classes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector <code>v</code> of length <code>n</code> with <code>v[i]</code> = the class of observation
<code>i</code>.
</p>


<h3>Author(s)</h3>

<p>D. Dupuy</p>


<h3>See Also</h3>

<p><code><a href="#topic+crossValidation">crossValidation</a></code></p>

<hr>
<h2 id='formulaAm'>Construction of a formula Y~s(X1)+...+s(Xp)</h2><span id='topic+formulaAm'></span>

<h3>Description</h3>

<p>This function constructs a formula based on splines for additive models. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formulaAm(X,Y)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formulaAm_+3A_x">X</code></td>
<td>
<p>a data.frame containing the design of experiments</p>
</td></tr>
<tr><td><code id="formulaAm_+3A_y">Y</code></td>
<td>
<p>a vector containing the associated response</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>formula</code>.</p>


<h3>Note</h3>

<p>The names of input variables are used to build the appropriate formula.</p>


<h3>Author(s)</h3>

<p>D. Dupuy</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dataIRSN5D)
X &lt;- dataIRSN5D[,1:5]
Y &lt;- dataIRSN5D[,6]
formulaAm(X,Y)
</code></pre>

<hr>
<h2 id='formulaLm'>Construction of a formula Y ~ X1+...+Xp</h2><span id='topic+formulaLm'></span>

<h3>Description</h3>

<p>This function constructs a formula containing only the principal factors. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formulaLm(X,Y)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formulaLm_+3A_x">X</code></td>
<td>
<p>a data.frame containing the design of experiments</p>
</td></tr>
<tr><td><code id="formulaLm_+3A_y">Y</code></td>
<td>
<p>a vector containing the associated response</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>formula</code>.</p>


<h3>Note</h3>

<p>The names of input variables are used to build the appropriate formula.</p>


<h3>Author(s)</h3>

<p>D. Dupuy</p>

<hr>
<h2 id='MAE'>Mean Absolute Error</h2><span id='topic+MAE'></span>

<h3>Description</h3>

<p>The mean of absolute errors between real values and predictions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MAE(Y, Ypred)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MAE_+3A_y">Y</code></td>
<td>
<p>a real vector with the values of the output</p>
</td></tr>
<tr><td><code id="MAE_+3A_ypred">Ypred</code></td>
<td>
<p>a real vector with the predicted values at the same inputs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a real which represents the mean of the absolute errors between the real and the predicted values:
</p>
<p style="text-align: center;"><code class="reqn">MAE = \frac{1}{n} \sum_{i=1}^{n} | Y \left( x_{i}\right)-\hat{Y} \left( x_{i}\right)|</code>
</p>

<p>where <code class="reqn">x_{i}</code> denotes the points of the experimental design, <code class="reqn">Y</code> the output of the computer code and <code class="reqn">\hat{Y}</code> the fitted model.
</p>


<h3>Author(s)</h3>

<p>D. Dupuy</p>


<h3>See Also</h3>

<p>other quality criteia as <code><a href="#topic+RMSE">RMSE</a></code> and <code><a href="#topic+RMA">RMA</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>X	&lt;- seq(-1,1,0.1)
Y	&lt;- 3*X + rnorm(length(X),0,0.5)
Ypred	&lt;- 3*X
MAE(Y,Ypred)
</code></pre>

<hr>
<h2 id='modelComparison'>Comparison of different types of metamodels</h2><span id='topic+modelComparison'></span>

<h3>Description</h3>

<p>modelComparison fits different metamodels and returns <code>R2</code> and <code>RMSE</code> criteria relating to each.</p>


<h3>Usage</h3>

<pre><code class='language-R'>modelComparison(X,Y, type="all",K=10,test=NULL,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modelComparison_+3A_x">X</code></td>
<td>
<p>a data.frame containing the design of experiments</p>
</td></tr>
<tr><td><code id="modelComparison_+3A_y">Y</code></td>
<td>
<p>a vector containing the response variable</p>
</td></tr>
<tr><td><code id="modelComparison_+3A_type">type</code></td>
<td>
<p>a vector containing the type of models to compare. 
</p>
<p>The default value is <code>"all"=c("Linear", "StepLinear","Additive", "PolyMARS", "MARS","Kriging")</code></p>
</td></tr>
<tr><td><code id="modelComparison_+3A_k">K</code></td>
<td>
<p>the number of folds for cross-validation (default value is set at 10)</p>
</td></tr>
<tr><td><code id="modelComparison_+3A_test">test</code></td>
<td>
<p>a data.frame containing the design and the response of a test set when available, the prediction criteria will be evaluated on the test design (default corresponds to no test set)</p>
</td></tr>
<tr><td><code id="modelComparison_+3A_...">...</code></td>
<td>
<p>according to the <code>type</code> argument, parameters can be specified (for example, <code>formula</code> and <code>penalty</code> for a stepwise procedure)</p>
</td></tr>
</table>


<h3>Value</h3>

<p> A list containing two fields if the argument <code>test</code> equal <code>NULL</code> and three fields otherwise :
</p>
<table>
<tr><td><code>Learning</code></td>
<td>
<p><code>R2</code> and <code>RMSE</code> criteria evaluated from learning set,</p>
</td></tr>
<tr><td><code>CV</code></td>
<td>
<p><code>Q2</code> and <code>RMSE_CV</code> criteria using K-fold cross-validation,</p>
</td></tr>
<tr><td><code>Test</code></td>
<td>
<p><code>R2</code> and <code>RMSE</code> criteria on the test set.</p>
</td></tr>
</table>
<p>A graphical tool to compare the value of the criteria is proposed.
</p>


<h3>Author(s)</h3>

<p>D. Dupuy</p>


<h3>See Also</h3>

<p><code><a href="#topic+modelFit">modelFit</a></code> and <code><a href="#topic+crossValidation">crossValidation</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(dataIRSN5D)
X &lt;- dataIRSN5D[,1:5]
Y &lt;- dataIRSN5D[,6]
data(testIRSN5D)
library(gam)
library(mda)
library(polspline)
crit  &lt;- modelComparison(X,Y, type="all",test=testIRSN5D)

crit2 &lt;- modelComparison(X,Y, type=rep("StepLinear",5),test=testIRSN5D,
		penalty=c(1,2,5,10,20),formula=Y~.^2)
    
## End(Not run)
</code></pre>

<hr>
<h2 id='modelFit'>Fitting metamodels</h2><span id='topic+modelFit'></span>

<h3>Description</h3>

<p><code>modelFit</code> is used to fit a metamodel of class <code>lm</code>, <code>gam</code>,
<code>mars</code>, <code>polymars</code> or <code>km</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modelFit (X,Y, type, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modelFit_+3A_x">X</code></td>
<td>
<p>a data.frame containing the design of experiments</p>
</td></tr>
<tr><td><code id="modelFit_+3A_y">Y</code></td>
<td>
<p>a vector containing the response variable</p>
</td></tr>
<tr><td><code id="modelFit_+3A_type">type</code></td>
<td>
<p>represents the method used to fit the model: 
</p>

<table>
<tr>
 <td style="text-align: left;">
	<code>"Linear"</code> 	  </td><td style="text-align: left;"> linear model, </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>"StepLinear"</code> </td><td style="text-align: left;"> stepwise, </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>"Additive"</code>	  </td><td style="text-align: left;"> gam, </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>"MARS"</code> 	  </td><td style="text-align: left;"> mars </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>"PolyMARS"</code>	  </td><td style="text-align: left;"> polymars </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>"Kriging"</code>	</td><td style="text-align: left;"> kriging model. </td>
</tr>
<tr>
 <td style="text-align: left;">
	</td>
</tr>

</table>
</td></tr>
<tr><td><code id="modelFit_+3A_...">...</code></td>
<td>
<p>corresponds to the parameter(s) of the model. The list of the needed arguments for each type of models is given below:
</p>

<table>
<tr>
 <td style="text-align: left;">
	<code>"Linear"</code> 	  </td><td style="text-align: left;"> <code>formula</code> (see <code><a href="#topic+formulaLm">formulaLm</a></code>), </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>"StepLinear"</code> </td><td style="text-align: left;"> <code>formula</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
				  </td><td style="text-align: left;"> <code>penalty</code> parameter, </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>"Additive"</code>	  </td><td style="text-align: left;"> <code>formula</code> (see <code><a href="#topic+formulaAm">formulaAm</a></code>), </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>"MARS"</code> 	  </td><td style="text-align: left;"> <code>degree</code>, </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>"PolyMARS"</code>	  </td><td style="text-align: left;"> <code>gcv</code> criteria. </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>"Kriging"</code> </td><td style="text-align: left;"> <code>formula</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
	</td><td style="text-align: left;"> <code>covtype</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
	</td>
</tr>

</table>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components: 
</p>
<table>
<tr><td><code>X</code></td>
<td>
<p>a data frame representing the design of experiments</p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p>a vector representing the response</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>the type of metamodel</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>a fitted model of the specified class</p>
</td></tr></table>
<p> and the value of the parameter(s) depending on the fitted model.
</p>


<h3>Author(s)</h3>

<p>D. Dupuy</p>


<h3>See Also</h3>

 <p><code><a href="#topic+modelPredict">modelPredict</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># A 2D example
Branin &lt;- function(x1,x2) {
  x1 &lt;- x1*15-5   
  x2 &lt;- x2*15
  (x2 - 5/(4*pi^2)*(x1^2) + 5/pi*x1 - 6)^2 + 10*(1 - 1/(8*pi))*cos(x1) + 10
}
# a 2D uniform design and the value of the response at these points
X &lt;- matrix(runif(24),ncol=2,nrow=12)
Z &lt;- Branin(X[,1],X[,2])
Y &lt;- (Z-mean(Z))/sd(Z)

# construction of a linear model
modLm &lt;- modelFit(X,Y,type = "Linear",formula=Y~X1+X2+X1:X2+I(X1^2)+I(X2^2))
summary(modLm$model)

## Not run: 
# construction of a stepwise-selected model 
modStep &lt;- modelFit(X,Y,type = "StepLinear",penalty=log(dim(X)[1]),
		formula=Y~X1+X2+X1:X2+I(X1^2)+I(X2^2))
summary(modStep$model)

# construction of an additive model
library(gam)
modAm &lt;- modelFit(X,Y,type = "Additive",formula=Y~s(X1)+s(X2))
summary(modAm$model)

# construction of a MARS model of degree 2
library(mda)
modMARS &lt;- modelFit(X,Y,type = "MARS",degree=2)
print(modMARS$model)

# construction of a PolyMARS model with a penalty parameter equal to 1
library(polspline)
modPolyMARS &lt;- modelFit(X,Y,type = "PolyMARS",gcv=1)
summary(modPolyMARS$model)

# construction of a Kriging model
modKm &lt;- modelFit(X,Y,type = "Kriging")
str(modKm$model)

## End(Not run)
</code></pre>

<hr>
<h2 id='modelPredict'>Prediction at newdata for a fitted metamodel</h2><span id='topic+modelPredict'></span>

<h3>Description</h3>

<p><code>modelPredict</code> computes predicted values based on the model given in argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modelPredict(model,newdata)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modelPredict_+3A_model">model</code></td>
<td>
<p>a fitted model obtained from <code>modelFit</code></p>
</td></tr>
<tr><td><code id="modelPredict_+3A_newdata">newdata</code></td>
<td>
<p>a matrix (or a data frame) which represents the predictor values at which the fitted values will be computed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of predicted values, obtained by evaluating the model at <code>newdata</code>.
</p>


<h3>Author(s)</h3>

<p>D. Dupuy</p>


<h3>See Also</h3>

<p><code><a href="#topic+modelFit">modelFit</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>X  &lt;- seq(-1,1,l=21)
Y  &lt;- 3*X + rnorm(21,0,0.5)
# construction of a linear model
modLm &lt;- modelFit(X,Y,type = "Linear",formula="Y~.")
print(modLm$model$coefficient)

## Not run: 
# illustration on a 2-dimensional example
Branin	&lt;- function(x1,x2) {
x1	&lt;- 1/2*(15*x1+5)   
x2	&lt;- 15/2*(x2+1)
(x2 - 5.1/(4*pi^2)*(x1^2) + 5/pi*x1 - 6)^2 + 10*(1 - 1/(8*pi))*cos(x1) + 10
}
# A 2D uniform design with 20 points in [-1,1]^2
n	&lt;- 20
X	&lt;- matrix(runif(n*2,-1,1),ncol=2,nrow=n)
Y	&lt;- Branin(X[,1],X[,2])
Z	&lt;- (Y-mean(Y))/sd(Y)

# Construction of a Kriging model
mKm	&lt;- modelFit(X,Z,type = "Kriging")

# Prediction and comparison between the exact function and the predicted one
xtest	&lt;- seq(-1, 1, length= 21) 
ytest	&lt;- seq(-1, 1, length= 21)
Zreal	&lt;- outer(xtest, ytest, Branin)
Zreal	&lt;- (Zreal-mean(Y))/sd(Y)
Zpredict	&lt;- modelPredict(mKm,expand.grid(xtest,ytest))

z &lt;- abs(Zreal-matrix(Zpredict,nrow=length(xtest),ncol=length(ytest)))
contour(xtest, xtest, z,30)
points(X,pch=19)

## End(Not run)
</code></pre>

<hr>
<h2 id='penaltyPolyMARS'>Choice of the penalty parameter for a PolyMARS model</h2><span id='topic+penaltyPolyMARS'></span>

<h3>Description</h3>

<p>This function fits a PolyMARS model for different values of the penalty parameter
and compute criteria.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>penaltyPolyMARS(X,Y,test=NULL,graphic=FALSE,K=10,
		Penalty=seq(0,5,by=0.2))</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="penaltyPolyMARS_+3A_x">X</code></td>
<td>
<p>a data.frame containing the design of experiments</p>
</td></tr>
<tr><td><code id="penaltyPolyMARS_+3A_y">Y</code></td>
<td>
<p>a vector containing the response variable</p>
</td></tr>
<tr><td><code id="penaltyPolyMARS_+3A_test">test</code></td>
<td>
<p>a data.frame containing the design and the response of a test set when available, the prediction criteria will be computed for the test data (default corresponds to no test set)</p>
</td></tr>
<tr><td><code id="penaltyPolyMARS_+3A_graphic">graphic</code></td>
<td>
<p>if TRUE the values of the criteria are represented</p>
</td></tr>
<tr><td><code id="penaltyPolyMARS_+3A_k">K</code></td>
<td>
<p>the number of folds for cross-validation (by default, K=10)</p>
</td></tr>
<tr><td><code id="penaltyPolyMARS_+3A_penalty">Penalty</code></td>
<td>
<p>a vector containing the values of the penalty parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p> A data frame containing
</p>
<table>
<tr><td><code>a</code></td>
<td>
<p>the values of the penalty parameter</p>
</td></tr>
<tr><td><code>R2</code></td>
<td>
<p>the <code>R2</code> criterion evaluted on the learning set</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>the size of the selected model</p>
</td></tr>
</table>
<p>If a test set is available the last row is
</p>
<table>
<tr><td><code>R2test</code></td>
<td>
<p>the <code>R2</code> criterion evaluated on the test set</p>
</td></tr>
</table>
<p>If no test set is available, criteria computed by K-corss-validation are provided:
</p>
<table>
<tr><td><code>Q2</code></td>
<td>
<p>the <code>Q2</code> evaluated by cross-validation (by default, K=10)</p>
</td></tr>
<tr><td><code>RMSE CV</code></td>
<td>
<p><code>RMSE</code> computed by cross-validation</p>
</td></tr>
</table>
<p>Note that the penalty parameter could be chosen by minimizing the value of the <code>RMSE</code> by cross-validation.
</p>


<h3>Author(s)</h3>

<p>D. Dupuy</p>


<h3>See Also</h3>

<p><code><a href="#topic+modelFit">modelFit</a></code>, <code><a href="#topic+R2">R2</a></code> and <code><a href="#topic+crossValidation">crossValidation</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dataIRSN5D)
X	&lt;- dataIRSN5D[,1:5]
Y	&lt;- dataIRSN5D[,6]
data(testIRSN5D)
library(polspline)
Crit	&lt;- penaltyPolyMARS(X,Y,test=testIRSN5D[,-7],graphic=TRUE)
</code></pre>

<hr>
<h2 id='R2'>Multiple R-Squared</h2><span id='topic+R2'></span>

<h3>Description</h3>

<p>Coefficient of determination <code class="reqn">R^{2}</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>R2(Y, Ypred)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="R2_+3A_y">Y</code></td>
<td>
<p>a real vector with the values of the output</p>
</td></tr>
<tr><td><code id="R2_+3A_ypred">Ypred</code></td>
<td>
<p>a real vector with the predicted values at the same inputs</p>
</td></tr>
</table>


<h3>Value</h3>

<p style="text-align: center;"><code class="reqn">\code{R2}= 1 - \frac{SSE}{SST}</code>
</p>

<p>where <code class="reqn">SSE= \sum_{i=1}^{n} (Y(x_{i}) - \hat{Y}(x_{i})^{2}</code> is the residual sum of squares 
</p>
<p>and <code class="reqn">SST= \sum_{i=1}^{n} (Y(x_{i}) - \bar{Y} )^{2}</code> is the total sum of squares. 
</p>
<p>Note that the order of the input argument is important.
</p>


<h3>Author(s)</h3>

<p>D. Dupuy</p>


<h3>Examples</h3>

<pre><code class='language-R'>X	&lt;- seq(-1,1,0.1)
Y	&lt;- 3*X + rnorm(length(X),0,0.5)
Ypred	&lt;- 3*X
print(R2(Y,Ypred))
</code></pre>

<hr>
<h2 id='residualsStudy'>Plot residuals</h2><span id='topic+residualsStudy'></span>

<h3>Description</h3>

<p>residualsStudy analyzes the residuals of a model: a plot of the residuals against the index, a plot
of the residuals against the fitted values, the representation of the
density and a normal Q-Q plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>residualsStudy(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residualsStudy_+3A_model">model</code></td>
<td>
<p>a fitted model obtained from <code>modelFit</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>D. Dupuy</p>


<h3>See Also</h3>

 <p><code><a href="#topic+modelFit">modelFit</a></code> and <code><a href="#topic+modelPredict">modelPredict</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dataIRSN5D)
X &lt;- dataIRSN5D[,1:5]
Y &lt;- dataIRSN5D[,6]
library(gam)
modAm &lt;- modelFit(X,Y,type = "Additive",formula=formulaAm(X,Y))
residualsStudy(modAm)
</code></pre>

<hr>
<h2 id='RMA'>Relative Maximal Absolute Error</h2><span id='topic+RMA'></span>

<h3>Description</h3>

<p>Relative Maximal Absolute Error
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RMA(Y, Ypred)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RMA_+3A_y">Y</code></td>
<td>
<p>a real vector with the values of the output</p>
</td></tr>
<tr><td><code id="RMA_+3A_ypred">Ypred</code></td>
<td>
<p>a real vector with the predicted values at the same inputs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>RMA</code> criterion represents the maximum of errors between exact values and predicted one:
</p>
<p style="text-align: center;"><code class="reqn">RMA = \max_{1\leq i\leq n} \frac{| Y \left( x_{i}\right)-\hat{Y} \left( x_{i}\right)|}
{\sigma_{Y}}</code>
</p>

<p>where <code class="reqn">Y</code> is the output variable, <code class="reqn">\hat{Y}</code> is the fitted model and
<code class="reqn">\sigma_Y</code> denotes the standard deviation of <code class="reqn">Y</code>.
</p>
<p>The output of this function is a list with the following components: 
</p>
<table>
<tr><td><code>max.value</code></td>
<td>
<p>the value of the <code>RMA</code> criterion</p>
</td></tr>
<tr><td><code>max.data</code></td>
<td>
<p>an integer <code class="reqn">i</code> indicating the data <code class="reqn">x^{i}</code> for which the <code>RMA</code> is reached</p>
</td></tr>
<tr><td><code>index</code></td>
<td>
<p>a vector containing the data sorted according to the value of the errors</p>
</td></tr>
<tr><td><code>error</code></td>
<td>
<p>a vector containing the corresponding value of the errors</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>D. Dupuy</p>


<h3>See Also</h3>

<p>other validation criteria as <code><a href="#topic+MAE">MAE</a></code> or <code><a href="#topic+RMSE">RMSE</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>X     &lt;- seq(-1,1,0.1)
Y     &lt;- 3*X + rnorm(length(X),0,0.5)
Ypred &lt;- 3*X
print(RMA(Y,Ypred))

# Illustration on Branin function
Branin &lt;- function(x1,x2) {
   x1 &lt;- x1*15-5   
   x2 &lt;- x2*15
   (x2 - 5/(4*pi^2)*(x1^2) + 5/pi*x1 - 6)^2 + 10*(1 - 1/(8*pi))*cos(x1) + 10
}
X &lt;- matrix(runif(24),ncol=2,nrow=12)
Z &lt;- Branin(X[,1],X[,2])
Y &lt;- (Z-mean(Z))/sd(Z)

# Fitting of a Linear model on the data (X,Y)
modLm &lt;- modelFit(X,Y,type = "Linear",formula=Y~X1+X2+X1:X2+I(X1^2)+I(X2^2))

# Prediction on a grid
u &lt;- seq(0,1,0.1)
Y_test_real &lt;- Branin(expand.grid(u,u)[,1],expand.grid(u,u)[,2])
Y_test_pred &lt;- modelPredict(modLm,expand.grid(u,u))
Y_error &lt;- matrix(abs(Y_test_pred-(Y_test_real-mean(Z))/sd(Z)),length(u),length(u))
contour(u, u, Y_error,45)
Y_pred &lt;- modelPredict(modLm,X)
out &lt;- RMA(Y,Y_pred)
for (i in 1:dim(X)[1]){
    points(X[out$index[i],1],X[out$index[i],2],pch=19,col='red',cex=out$error[i]*10)
}
</code></pre>

<hr>
<h2 id='RMSE'>Root Mean Squared Error</h2><span id='topic+RMSE'></span>

<h3>Description</h3>

<p>The root of the Mean Squared Error between the exact value and the predicted one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RMSE(Y, Ypred)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RMSE_+3A_y">Y</code></td>
<td>
<p>a real vector with the values of the output</p>
</td></tr>
<tr><td><code id="RMSE_+3A_ypred">Ypred</code></td>
<td>
<p>a real vector with the predicted values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a real which represents the root of the mean squared error between the target response <code class="reqn">Y</code>
and the fitted one <code class="reqn">\hat{Y}</code>:
</p>
<p style="text-align: center;"><code class="reqn">\code{RMSE} = \sqrt{\frac{1}{n} \sum_{i=1}^{n} \left( Y \left( x_{i}\right)-\hat{Y}
		\left( x_{i}\right)\right)^2}.</code>
</p>



<h3>Author(s)</h3>

<p>D. Dupuy</p>


<h3>See Also</h3>

<p>other validation criteria as <code><a href="#topic+MAE">MAE</a></code> or <code><a href="#topic+RMA">RMA</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>X    &lt;- seq(-1,1,0.1)
Y    &lt;- 3*X + rnorm(length(X),0,0.5)
Ypred &lt;- 3*X
print(RMSE(Y,Ypred))
</code></pre>

<hr>
<h2 id='stepEvolution'>Evolution of the stepwise model</h2><span id='topic+stepEvolution'></span>

<h3>Description</h3>

<p>Graphical representation of the selected terms using stepwise
procedure for different values of the penalty parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepEvolution(X,Y,formula,P=1:7,K=10,test=NULL,graphic=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stepEvolution_+3A_x">X</code></td>
<td>
<p>a data.frame containing the design of experiments</p>
</td></tr>
<tr><td><code id="stepEvolution_+3A_y">Y</code></td>
<td>
<p>a vector containing the response variable</p>
</td></tr>
<tr><td><code id="stepEvolution_+3A_formula">formula</code></td>
<td>
<p>a formula for the initial model</p>
</td></tr>
<tr><td><code id="stepEvolution_+3A_p">P</code></td>
<td>
<p>a vector containing different values of the penalty
parameter for which a stepwise selected model is fitted</p>
</td></tr>
<tr><td><code id="stepEvolution_+3A_k">K</code></td>
<td>
<p>the number of folds for the cross-validation procedure</p>
</td></tr>
<tr><td><code id="stepEvolution_+3A_test">test</code></td>
<td>
<p>an additional data set on which the prediction criteria are evaluated (default corresponds to no test data set)</p>
</td></tr>
<tr><td><code id="stepEvolution_+3A_graphic">graphic</code></td>
<td>
<p>if <code>TRUE</code> the values of the criteria are represented</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the different criteria for different values of the
penalty parameter. This list contains:
</p>
<table>
<tr><td><code>penalty</code></td>
<td>
<p>the values for the penalty parameter</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>size <code>m</code> of the selected model for each value in <code>P</code></p>
</td></tr>
<tr><td><code>R2</code></td>
<td>
<p>the value of the <code>R2</code> criterion for each model</p>
</td></tr>
</table>
<p>According to the value of the <code>test</code> argument, other criteria are calculated:
</p>

<table>
<tr>
 <td style="text-align: left;">
a. </td><td style="text-align: left;"> If a test set is available, <code>R2test</code> contains the value of the <code>R2</code> 
criterion on the test set  </td>
</tr>
<tr>
 <td style="text-align: left;">
b. </td><td style="text-align: left;"> If no test set is available, the <code>Q2</code> and the <code>RMSE</code> computed by
cross-validation are done.
</td>
</tr>

</table>


<h3>Note</h3>

<p>Plots are also available. 
A tabular represents the selected terms for each value in <code>P</code>.
</p>
<p>The evolution of the <code>R2</code> criterion, the evolution of the size <code>m</code> of the selected
model and criteria on the test set or by K-folds cross-validation are represented.
</p>
<p>These graphical tools can be used to select the best value for the penalty parameter.
</p>


<h3>Author(s)</h3>

<p>D. Dupuy</p>


<h3>See Also</h3>

<p><code>step</code> procedure for linear models.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(dataIRSN5D)
design &lt;- dataIRSN5D[,1:5]
Y	   &lt;- dataIRSN5D[,6]
out	   &lt;- stepEvolution(design,Y,formulaLm(design,Y),P=c(1,2,5,10,20,30))

## End(Not run)
</code></pre>

<hr>
<h2 id='testCrossValidation'>Test the robustess of the cross-validation procedure</h2><span id='topic+testCrossValidation'></span>

<h3>Description</h3>

<p>This function calculates the estimated K-fold cross-validation for different
values of <code>K</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testCrossValidation(model,Kfold=c(2,5,10,20,30,40,dim(model$data$X)[1]),N=10)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testCrossValidation_+3A_model">model</code></td>
<td>
<p>a fitted model from <code>modelFit</code></p>
</td></tr>
<tr><td><code id="testCrossValidation_+3A_kfold">Kfold</code></td>
<td>
<p>a vector containing the values to test (default corresponds to 2,5,10,20,30,40 and the number of observations for leave-one-out procedure)</p>
</td></tr>
<tr><td><code id="testCrossValidation_+3A_n">N</code></td>
<td>
<p>an integer given the number of times the K-fold cross-validation is performed for each value of K</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of all the values obtained by K-fold cross-validation</p>


<h3>Note</h3>

<p>For each value of K, the cross-validation procedure is repeated <code>N</code> times in
order to get an idea of the dispersion of the <code>Q2</code> criterion and of the <code>RMSE</code> by K-fold cross-validation.</p>


<h3>Author(s)</h3>

<p>D. Dupuy</p>


<h3>See Also</h3>

<p><code><a href="#topic+crossValidation">crossValidation</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
rm(list=ls())
# A 2D example
Branin &lt;- function(x1,x2) {
  x1 &lt;- x1*15-5   
  x2 &lt;- x2*15
  (x2 - 5/(4*pi^2)*(x1^2) + 5/pi*x1 - 6)^2 + 10*(1 - 1/(8*pi))*cos(x1) + 10
}
# a 2D uniform design and the value of the response at these points
n &lt;- 50
X &lt;- matrix(runif(n*2),ncol=2,nrow=n)
Y &lt;- Branin(X[,1],X[,2])

mod &lt;- modelFit(X,Y,type="Linear",formula=formulaLm(X,Y))
out &lt;- testCrossValidation(mod,N=20)

## End(Not run)
</code></pre>

<hr>
<h2 id='testIRSN5D'>A set of test data</h2><span id='topic+testIRSN5D'></span>

<h3>Description</h3>

<p>These test data correspond to the five-dimensional case provided by the IRSN
detailed in <code><a href="#topic+dataIRSN5D">dataIRSN5D</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(testIRSN5D)</code></pre>


<h3>Format</h3>

<p>A data frame with 324 rows representing the number of observations and 6 columns:
the first five corresponding to the input variables (&quot;b&quot;,&quot;e&quot;,&quot;p&quot;,&quot;r&quot; and &quot;l&quot;) and the last to the response
<code>Keff</code>.
</p>


<h3>Source</h3>

<p>IRSN (Institut de Radioprotection et de Sûreté Nucléaire)</p>


<h3>See Also</h3>

<p><code><a href="#topic+dataIRSN5D">dataIRSN5D</a></code></p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
