<!DOCTYPE html><html><head><title>Help for package sf</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sf}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.stop_geos'><p>Internal functions</p></a></li>
<li><a href='#aggregate.sf'><p>aggregate an <code>sf</code> object</p></a></li>
<li><a href='#as'><p>Methods to coerce simple features to <code style="white-space: pre;">&#8288;Spatial*&#8288;</code> and <code>Spatial*DataFrame</code> objects</p></a></li>
<li><a href='#bind'><p>Bind rows (features) of sf objects</p></a></li>
<li><a href='#db_drivers'><p>Drivers for which update should be <code>TRUE</code> by default</p></a></li>
<li><a href='#dbDataType,PostgreSQLConnection,sf-method'><p>Determine database type for R vector</p></a></li>
<li><a href='#dbWriteTable,PostgreSQLConnection,character,sf-method'><p>Write <code>sf</code> object to Database</p></a></li>
<li><a href='#extension_map'><p>Map extension to driver</p></a></li>
<li><a href='#gdal'><p>functions to interact with gdal not meant to be called directly by users (but e.g. by stars::read_stars)</p></a></li>
<li><a href='#gdal_addo'><p>Add or remove overviews to/from a raster image</p></a></li>
<li><a href='#gdal_utils'><p>Native interface to gdal utils</p></a></li>
<li><a href='#geos_binary_ops'><p>Geometric operations on pairs of simple feature geometry sets</p></a></li>
<li><a href='#geos_binary_pred'><p>Geometric binary predicates on pairs of simple feature geometry sets</p></a></li>
<li><a href='#geos_combine'><p>Combine or union feature geometries</p></a></li>
<li><a href='#geos_measures'><p>Compute geometric measurements</p></a></li>
<li><a href='#geos_query'><p>Dimension, simplicity, validity or is_empty queries on simple feature geometries</p></a></li>
<li><a href='#geos_unary'><p>Geometric unary operations on simple feature geometry sets</p></a></li>
<li><a href='#interpolate_aw'><p>Areal-weighted interpolation of polygon data</p></a></li>
<li><a href='#is_driver_available'><p>Check if driver is available</p></a></li>
<li><a href='#is_driver_can'><p>Check if a driver can perform an action</p></a></li>
<li><a href='#is_geometry_column'><p>Check if the columns could be of a coercable type for sf</p></a></li>
<li><a href='#merge.sf'><p>merge method for sf and data.frame object</p></a></li>
<li><a href='#nc'><p>North Carolina SIDS data</p></a></li>
<li><a href='#Ops'><p>Arithmetic operators for simple feature geometries</p></a></li>
<li><a href='#plot'><p>plot sf object</p></a></li>
<li><a href='#prefix_map'><p>Map prefix to driver</p></a></li>
<li><a href='#proj_tools'><p>Manage PROJ settings</p></a></li>
<li><a href='#rawToHex'><p>Convert raw vector(s) into hexadecimal character string(s)</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#s2'><p>functions for spherical geometry, using s2 package</p></a></li>
<li><a href='#sf'><p>Create sf object</p></a></li>
<li><a href='#sf_extSoftVersion'><p>Provide the external dependencies versions of the libraries linked to sf</p></a></li>
<li><a href='#sf_project'><p>directly transform a set of coordinates</p></a></li>
<li><a href='#sf-defunct'><p>Deprecated functions in <code>sf</code></p></a></li>
<li><a href='#sf-package'><p>sf: Simple Features for R</p></a></li>
<li><a href='#sfc'><p>Create simple feature geometry list column</p></a></li>
<li><a href='#sgbp'><p>Methods for dealing with sparse geometry binary predicate lists</p></a></li>
<li><a href='#st'><p>Create simple feature from a numeric vector, matrix or list</p></a></li>
<li><a href='#st_agr'><p>get or set relation_to_geometry attribute of an <code>sf</code> object</p></a></li>
<li><a href='#st_as_binary'><p>Convert sfc object to an WKB object</p></a></li>
<li><a href='#st_as_grob'><p>Convert sf* object to a grob</p></a></li>
<li><a href='#st_as_sf'><p>Convert foreign object to an sf object</p></a></li>
<li><a href='#st_as_sfc'><p>Convert foreign geometry object to an sfc object</p></a></li>
<li><a href='#st_as_text'><p>Return Well-known Text representation of simple feature geometry or coordinate reference system</p></a></li>
<li><a href='#st_bbox'><p>Return bounding of a simple feature or simple feature set</p></a></li>
<li><a href='#st_break_antimeridian'><p>Break antimeridian for plotting not centred on Greenwich</p></a></li>
<li><a href='#st_cast'><p>Cast geometry to another type: either simplify, or cast explicitly</p></a></li>
<li><a href='#st_cast_sfc_default'><p>Coerce geometry to MULTI* geometry</p></a></li>
<li><a href='#st_collection_extract'><p>Given an object with geometries of type <code>GEOMETRY</code> or <code>GEOMETRYCOLLECTION</code>,</p>
return an object consisting only of elements of the specified type.</a></li>
<li><a href='#st_coordinates'><p>retrieve coordinates in matrix form</p></a></li>
<li><a href='#st_crop'><p>crop an sf object to a specific rectangle</p></a></li>
<li><a href='#st_crs'><p>Retrieve coordinate reference system from object</p></a></li>
<li><a href='#st_drivers'><p>Get GDAL drivers</p></a></li>
<li><a href='#st_geometry'><p>Get, set, replace or rename geometry from an sf object</p></a></li>
<li><a href='#st_geometry_type'><p>Return geometry type of an object</p></a></li>
<li><a href='#st_graticule'><p>Compute graticules and their parameters</p></a></li>
<li><a href='#st_is'><p>test equality between the geometry type and a class or set of classes</p></a></li>
<li><a href='#st_is_longlat'><p>Assert whether simple feature coordinates are longlat degrees</p></a></li>
<li><a href='#st_jitter'><p>jitter geometries</p></a></li>
<li><a href='#st_join'><p>spatial join, spatial filter</p></a></li>
<li><a href='#st_layers'><p>Return properties of layers in a datasource</p></a></li>
<li><a href='#st_line_project_point'><p>Project point on linestring, interpolate along a linestring</p></a></li>
<li><a href='#st_line_sample'><p>Sample points on a linear geometry</p></a></li>
<li><a href='#st_m_range'><p>Return 'm' range of a simple feature or simple feature set</p></a></li>
<li><a href='#st_make_grid'><p>Create a regular tesselation over the bounding box of an sf or sfc object</p></a></li>
<li><a href='#st_nearest_feature'><p>get index of nearest feature</p></a></li>
<li><a href='#st_nearest_points'><p>get nearest points between pairs of geometries</p></a></li>
<li><a href='#st_normalize'><p>Normalize simple features</p></a></li>
<li><a href='#st_precision'><p>Get precision</p></a></li>
<li><a href='#st_read'><p>Read simple features or layers from file or database</p></a></li>
<li><a href='#st_relate'><p>Compute DE9-IM relation between pairs of geometries, or match it to a given pattern</p></a></li>
<li><a href='#st_sample'><p>sample points on or in (sets of) spatial features</p></a></li>
<li><a href='#st_shift_longitude'><p>Shift or re-center geographical coordinates for a Pacific view</p></a></li>
<li><a href='#st_transform'><p>Transform or convert coordinates of simple feature</p></a></li>
<li><a href='#st_viewport'><p>Create viewport from sf, sfc or sfg object</p></a></li>
<li><a href='#st_write'><p>Write simple features object to file or database</p></a></li>
<li><a href='#st_z_range'><p>Return 'z' range of a simple feature or simple feature set</p></a></li>
<li><a href='#st_zm'><p>Drop or add Z and/or M dimensions from feature geometries</p></a></li>
<li><a href='#stars'><p>functions only exported to be used internally by stars</p></a></li>
<li><a href='#summary.sfc'><p>Summarize simple feature column</p></a></li>
<li><a href='#tibble'><p>Summarize simple feature type for tibble</p></a></li>
<li><a href='#tidyverse'><p>Tidyverse methods for sf objects</p></a></li>
<li><a href='#transform.sf'><p>transform method for sf objects</p></a></li>
<li><a href='#valid'><p>Check validity or make an invalid geometry valid</p></a></li>
<li><a href='#vctrs'><p>vctrs methods for sf objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.0-16</td>
</tr>
<tr>
<td>Title:</td>
<td>Simple Features for R</td>
</tr>
<tr>
<td>Description:</td>
<td>Support for simple features, a standardized way to
    encode spatial vector data. Binds to 'GDAL' for reading and writing
    data, to 'GEOS' for geometrical operations, and to 'PROJ' for
    projection conversions and datum transformations. Uses by default the 's2'
    package for spherical geometry operations on ellipsoidal (long/lat) coordinates.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://r-spatial.github.io/sf/">https://r-spatial.github.io/sf/</a>, <a href="https://github.com/r-spatial/sf">https://github.com/r-spatial/sf</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/r-spatial/sf/issues">https://github.com/r-spatial/sf/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>methods, R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>classInt (&ge; 0.4-1), DBI (&ge; 0.8), graphics, grDevices, grid,
magrittr, Rcpp (&ge; 0.12.18), s2 (&ge; 1.1.0), stats, tools, units
(&ge; 0.7-0), utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>blob, nanoarrow, covr, dplyr (&ge; 1.0.0), ggplot2, knitr,
lwgeom (&ge; 0.2-14), maps, mapview, Matrix, microbenchmark,
odbc, pbapply, pillar, pool, raster, rlang, rmarkdown,
RPostgres (&ge; 1.1.0), RPostgreSQL, RSQLite, sp (&ge; 1.2-4),
spatstat (&ge; 2.0-1), spatstat.geom, spatstat.random,
spatstat.linnet, spatstat.utils, stars (&ge; 0.2-0), terra,
testthat (&ge; 3.0.0), tibble (&ge; 1.4.1), tidyr (&ge; 1.2.0),
tidyselect (&ge; 1.0.0), tmap (&ge; 2.0), vctrs, wk (&ge; 0.9.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>2</td>
</tr>
<tr>
<td>Config/needs/coverage:</td>
<td>XML</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GDAL (&gt;= 2.0.1), GEOS (&gt;= 3.4.0), PROJ (&gt;= 4.8.0),
sqlite3</td>
</tr>
<tr>
<td>Collate:</td>
<td>'RcppExports.R' 'init.R' 'import-standalone-s3-register.R'
'crs.R' 'bbox.R' 'read.R' 'db.R' 'sfc.R' 'sfg.R' 'sf.R'
'bind.R' 'wkb.R' 'wkt.R' 'plot.R' 'geom-measures.R'
'geom-predicates.R' 'geom-transformers.R' 'transform.R'
'proj.R' 'sp.R' 'grid.R' 'arith.R' 'tidyverse.R'
'tidyverse-vctrs.R' 'cast_sfg.R' 'cast_sfc.R' 'graticule.R'
'datasets.R' 'aggregate.R' 'agr.R' 'maps.R' 'join.R' 'sample.R'
'valid.R' 'collection_extract.R' 'jitter.R' 'sgbp.R'
'spatstat.R' 'stars.R' 'crop.R' 'gdal_utils.R' 'nearest.R'
'normalize.R' 'sf-package.R' 'defunct.R' 'z_range.R'
'm_range.R' 'shift_longitude.R' 'make_grid.R' 's2.R' 'terra.R'
'geos-overlayng.R' 'break_antimeridian.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-20 22:16:20 UTC; edzer</td>
</tr>
<tr>
<td>Author:</td>
<td>Edzer Pebesma <a href="https://orcid.org/0000-0001-8049-7069"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Roger Bivand <a href="https://orcid.org/0000-0003-2392-6140"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Etienne Racine [ctb],
  Michael Sumner [ctb],
  Ian Cook [ctb],
  Tim Keitt [ctb],
  Robin Lovelace [ctb],
  Hadley Wickham [ctb],
  Jeroen Ooms <a href="https://orcid.org/0000-0002-4035-0289"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Kirill MÃ¼ller [ctb],
  Thomas Lin Pedersen [ctb],
  Dan Baston [ctb],
  Dewey Dunnington <a href="https://orcid.org/0000-0002-9415-4582"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Edzer Pebesma &lt;edzer.pebesma@uni-muenster.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-24 23:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='.stop_geos'>Internal functions</h2><span id='topic+.stop_geos'></span>

<h3>Description</h3>

<p>Internal functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.stop_geos(msg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".stop_geos_+3A_msg">msg</code></td>
<td>
<p>error message</p>
</td></tr>
</table>

<hr>
<h2 id='aggregate.sf'>aggregate an <code>sf</code> object</h2><span id='topic+aggregate.sf'></span><span id='topic+aggregate'></span>

<h3>Description</h3>

<p>aggregate an <code>sf</code> object, possibly union-ing geometries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sf'
aggregate(
  x,
  by,
  FUN,
  ...,
  do_union = TRUE,
  simplify = TRUE,
  join = st_intersects
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggregate.sf_+3A_x">x</code></td>
<td>
<p>object of class <a href="#topic+sf">sf</a></p>
</td></tr>
<tr><td><code id="aggregate.sf_+3A_by">by</code></td>
<td>
<p>either a list of grouping vectors with length equal to <code>nrow(x)</code> (see <a href="stats.html#topic+aggregate">aggregate</a>), or an object of class <code>sf</code> or <code>sfc</code> with geometries that are used to generate groupings, using the binary predicate specified by the argument <code>join</code></p>
</td></tr>
<tr><td><code id="aggregate.sf_+3A_fun">FUN</code></td>
<td>
<p>function passed on to <a href="stats.html#topic+aggregate">aggregate</a>, in case <code>ids</code> was specified and attributes need to be grouped</p>
</td></tr>
<tr><td><code id="aggregate.sf_+3A_...">...</code></td>
<td>
<p>arguments passed on to <code>FUN</code></p>
</td></tr>
<tr><td><code id="aggregate.sf_+3A_do_union">do_union</code></td>
<td>
<p>logical; should grouped geometries be unioned using <a href="#topic+st_union">st_union</a>? See details.</p>
</td></tr>
<tr><td><code id="aggregate.sf_+3A_simplify">simplify</code></td>
<td>
<p>logical; see <a href="stats.html#topic+aggregate">aggregate</a></p>
</td></tr>
<tr><td><code id="aggregate.sf_+3A_join">join</code></td>
<td>
<p>logical spatial predicate function to use if <code>by</code> is a simple features object or geometry; see <a href="#topic+st_join">st_join</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>In case <code>do_union</code> is <code>FALSE</code>, <code>aggregate</code> will simply combine geometries using <a href="#topic+c.sfg">c.sfg</a>. When polygons sharing a boundary are combined, this leads to geometries that are invalid; see <a href="https://github.com/r-spatial/sf/issues/681">https://github.com/r-spatial/sf/issues/681</a>.
</p>


<h3>Value</h3>

<p>an <code>sf</code> object with aggregated attributes and geometries; additional grouping variables having the names of <code>names(ids)</code> or are named <code>Group.i</code> for <code>ids[[i]]</code>; see <a href="stats.html#topic+aggregate">aggregate</a>.
</p>


<h3>Note</h3>

<p>Does not work using the formula notation involving <code>~</code> defined in <a href="stats.html#topic+aggregate">aggregate</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m1 = cbind(c(0, 0, 1, 0), c(0, 1, 1, 0))
m2 = cbind(c(0, 1, 1, 0), c(0, 0, 1, 0))
pol = st_sfc(st_polygon(list(m1)), st_polygon(list(m2)))
set.seed(1985)
d = data.frame(matrix(runif(15), ncol = 3))
p = st_as_sf(x = d, coords = 1:2)
plot(pol)
plot(p, add = TRUE)
(p_ag1 = aggregate(p, pol, mean))
plot(p_ag1) # geometry same as pol
# works when x overlaps multiple objects in 'by':
p_buff = st_buffer(p, 0.2)
plot(p_buff, add = TRUE)
(p_ag2 = aggregate(p_buff, pol, mean)) # increased mean of second
# with non-matching features
m3 = cbind(c(0, 0, -0.1, 0), c(0, 0.1, 0.1, 0))
pol = st_sfc(st_polygon(list(m3)), st_polygon(list(m1)), st_polygon(list(m2)))
(p_ag3 = aggregate(p, pol, mean))
plot(p_ag3)
# In case we need to pass an argument to the join function:
(p_ag4 = aggregate(p, pol, mean, 
     join = function(x, y) st_is_within_distance(x, y, dist = 0.3)))
</code></pre>

<hr>
<h2 id='as'>Methods to coerce simple features to <code style="white-space: pre;">&#8288;Spatial*&#8288;</code> and <code>Spatial*DataFrame</code> objects</h2><span id='topic+as'></span><span id='topic+Spatial'></span><span id='topic+sf-method'></span><span id='topic+coerce'></span><span id='topic+sfc-method'></span><span id='topic+Spatial-method'></span><span id='topic+as_Spatial'></span><span id='topic+crs'></span><span id='topic+CRS-method'></span>

<h3>Description</h3>

<p><code><a href="#topic+as_Spatial">as_Spatial()</a></code> allows to convert <code>sf</code> and <code>sfc</code> to <code>Spatial*DataFrame</code> and
<code style="white-space: pre;">&#8288;Spatial*&#8288;</code> for <code>sp</code> compatibility. You can also use <code>as(x, "Spatial")</code> To transform
<code>sp</code> objects to <code>sf</code> and <code>sfc</code> with <code>as(x, "sf")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_Spatial(from, cast = TRUE, IDs = paste0("ID", seq_along(from)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_+3A_from">from</code></td>
<td>
<p>object of class <code>sf</code>, <code>sfc_POINT</code>, <code>sfc_MULTIPOINT</code>, <code>sfc_LINESTRING</code>,
<code>sfc_MULTILINESTRING</code>, <code>sfc_POLYGON</code>, or <code>sfc_MULTIPOLYGON</code>.</p>
</td></tr>
<tr><td><code id="as_+3A_cast">cast</code></td>
<td>
<p>logical; if <code>TRUE</code>, <code><a href="#topic+st_cast">st_cast()</a></code> <code>from</code> before converting, so that e.g.
<code>GEOMETRY</code> objects with a mix of <code>POLYGON</code> and <code>MULTIPOLYGON</code> are cast to <code>MULTIPOLYGON</code>.</p>
</td></tr>
<tr><td><code id="as_+3A_ids">IDs</code></td>
<td>
<p>character vector with IDs for the <code style="white-space: pre;">&#8288;Spatial*&#8288;</code> geometries</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Package <code>sp</code> supports three dimensions for <code>POINT</code> and <code>MULTIPOINT</code> (<code style="white-space: pre;">&#8288;SpatialPoint*&#8288;</code>).
Other geometries must be two-dimensional (<code>XY</code>). Dimensions can be dropped using
<code><a href="#topic+st_zm">st_zm()</a></code> with <code>what = "M"</code> or <code>what = "ZM"</code>.
</p>
<p>For converting simple features (i.e., <code>sf</code> objects) to their <code>Spatial</code> counterpart, use <code>as(obj, "Spatial")</code>
</p>


<h3>Value</h3>

<p>geometry-only object deriving from <code>Spatial</code>, of the appropriate class
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nc &lt;- st_read(system.file("shape/nc.shp", package="sf"))
if (require(sp, quietly = TRUE)) {
# convert to SpatialPolygonsDataFrame
spdf &lt;- as_Spatial(nc)
# identical to
spdf &lt;- as(nc, "Spatial")
# convert to SpatialPolygons
as(st_geometry(nc), "Spatial")
# back to sf
as(spdf, "sf")
}
</code></pre>

<hr>
<h2 id='bind'>Bind rows (features) of sf objects</h2><span id='topic+bind'></span><span id='topic+rbind.sf'></span><span id='topic+cbind.sf'></span><span id='topic+st_bind_cols'></span>

<h3>Description</h3>

<p>Bind rows (features) of sf objects
</p>
<p>Bind columns (variables) of sf objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sf'
rbind(..., deparse.level = 1)

## S3 method for class 'sf'
cbind(..., deparse.level = 1, sf_column_name = NULL)

st_bind_cols(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bind_+3A_...">...</code></td>
<td>
<p>objects to bind; note that for the rbind and cbind methods, all objects have to be of class <code>sf</code>; see <a href="methods.html#topic+dotsMethods">dotsMethods</a></p>
</td></tr>
<tr><td><code id="bind_+3A_deparse.level">deparse.level</code></td>
<td>
<p>integer; see <a href="base.html#topic+rbind">rbind</a></p>
</td></tr>
<tr><td><code id="bind_+3A_sf_column_name">sf_column_name</code></td>
<td>
<p>character; specifies active geometry; passed on to <a href="#topic+st_sf">st_sf</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>both <code>rbind</code> and <code>cbind</code> have non-standard method dispatch (see <a href="base.html#topic+cbind">cbind</a>): the <code>rbind</code> or <code>cbind</code> method for <code>sf</code> objects is only called when all arguments to be binded are of class <code>sf</code>.
</p>
<p>If you need to <code>cbind</code> e.g. a <code>data.frame</code> to an <code>sf</code>, use <a href="base.html#topic+data.frame">data.frame</a> directly and use <a href="#topic+st_sf">st_sf</a> on its result, or use <a href="dplyr.html#topic+bind">bind_cols</a>; see examples.
</p>
<p><code>st_bind_cols</code> is deprecated; use <code>cbind</code> instead.
</p>


<h3>Value</h3>

<p><code>cbind</code> called with multiple <code>sf</code> objects warns about multiple geometry columns present when the geometry column to use is not specified by using argument <code>sf_column_name</code>; see also <a href="#topic+st_sf">st_sf</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>crs = st_crs(3857)
a = st_sf(a=1, geom = st_sfc(st_point(0:1)), crs = crs)
b = st_sf(a=1, geom = st_sfc(st_linestring(matrix(1:4,2))), crs = crs)
c = st_sf(a=4, geom = st_sfc(st_multilinestring(list(matrix(1:4,2)))), crs = crs)
rbind(a,b,c)
rbind(a,b)
rbind(a,b)
rbind(b,c)
cbind(a,b,c) # warns
if (require(dplyr, quietly = TRUE))
  dplyr::bind_cols(a,b)
c = st_sf(a=4, geomc = st_sfc(st_multilinestring(list(matrix(1:4,2)))), crs = crs)
cbind(a,b,c, sf_column_name = "geomc")
df = data.frame(x=3)
st_sf(data.frame(c, df))
if (require(dplyr, quietly = TRUE))
  dplyr::bind_cols(c, df)
</code></pre>

<hr>
<h2 id='db_drivers'>Drivers for which update should be <code>TRUE</code> by default</h2><span id='topic+db_drivers'></span>

<h3>Description</h3>

<p>Drivers for which update should be <code>TRUE</code> by default
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_drivers
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 12.
</p>

<hr>
<h2 id='dbDataType+2CPostgreSQLConnection+2Csf-method'>Determine database type for R vector</h2><span id='topic+dbDataType+2CPostgreSQLConnection+2Csf-method'></span><span id='topic+dbDataType+2CDBIObject+2Csf-method'></span>

<h3>Description</h3>

<p>Determine database type for R vector
</p>
<p>Determine database type for R vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PostgreSQLConnection,sf'
dbDataType(dbObj, obj)

## S4 method for signature 'DBIObject,sf'
dbDataType(dbObj, obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbDataType+2B2CPostgreSQLConnection+2B2Csf-method_+3A_dbobj">dbObj</code></td>
<td>
<p>DBIObject driver or connection.</p>
</td></tr>
<tr><td><code id="dbDataType+2B2CPostgreSQLConnection+2B2Csf-method_+3A_obj">obj</code></td>
<td>
<p>Object to convert</p>
</td></tr>
</table>

<hr>
<h2 id='dbWriteTable+2CPostgreSQLConnection+2Ccharacter+2Csf-method'>Write <code>sf</code> object to Database</h2><span id='topic+dbWriteTable+2CPostgreSQLConnection+2Ccharacter+2Csf-method'></span><span id='topic+dbWriteTable+2CDBIObject+2Ccharacter+2Csf-method'></span>

<h3>Description</h3>

<p>Write <code>sf</code> object to Database
</p>
<p>Write <code>sf</code> object to Database
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PostgreSQLConnection,character,sf'
dbWriteTable(
  conn,
  name,
  value,
  ...,
  row.names = FALSE,
  overwrite = FALSE,
  append = FALSE,
  field.types = NULL,
  binary = TRUE
)

## S4 method for signature 'DBIObject,character,sf'
dbWriteTable(
  conn,
  name,
  value,
  ...,
  row.names = FALSE,
  overwrite = FALSE,
  append = FALSE,
  field.types = NULL,
  binary = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbWriteTable+2B2CPostgreSQLConnection+2B2Ccharacter+2B2Csf-method_+3A_conn">conn</code></td>
<td>
<p>DBIObject</p>
</td></tr>
<tr><td><code id="dbWriteTable+2B2CPostgreSQLConnection+2B2Ccharacter+2B2Csf-method_+3A_name">name</code></td>
<td>

<p>character vector of names (table names, fields, keywords).
</p>
</td></tr>
<tr><td><code id="dbWriteTable+2B2CPostgreSQLConnection+2B2Ccharacter+2B2Csf-method_+3A_value">value</code></td>
<td>

<p>a data.frame.
</p>
</td></tr>
<tr><td><code id="dbWriteTable+2B2CPostgreSQLConnection+2B2Ccharacter+2B2Csf-method_+3A_...">...</code></td>
<td>

<p>placeholder for future use.
</p>
</td></tr>
<tr><td><code id="dbWriteTable+2B2CPostgreSQLConnection+2B2Ccharacter+2B2Csf-method_+3A_row.names">row.names</code></td>
<td>
<p>Add a <code>row.name</code> column, or a vector of length <code>nrow(obj)</code>
containing row.names; default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="dbWriteTable+2B2CPostgreSQLConnection+2B2Ccharacter+2B2Csf-method_+3A_overwrite">overwrite</code></td>
<td>
<p>Will try to <code>drop</code> table before writing; default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="dbWriteTable+2B2CPostgreSQLConnection+2B2Ccharacter+2B2Csf-method_+3A_append">append</code></td>
<td>
<p>Append rows to existing table; default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="dbWriteTable+2B2CPostgreSQLConnection+2B2Ccharacter+2B2Csf-method_+3A_field.types">field.types</code></td>
<td>
<p>default <code>NULL</code>. Allows to override type conversion from R
to PostgreSQL. See <code>dbDataType()</code> for details.</p>
</td></tr>
<tr><td><code id="dbWriteTable+2B2CPostgreSQLConnection+2B2Ccharacter+2B2Csf-method_+3A_binary">binary</code></td>
<td>
<p>Send geometries serialized as Well-Known Binary (WKB);
if <code>FALSE</code>, uses Well-Known Text (WKT). Defaults to <code>TRUE</code> (WKB).</p>
</td></tr>
</table>

<hr>
<h2 id='extension_map'>Map extension to driver</h2><span id='topic+extension_map'></span>

<h3>Description</h3>

<p>Map extension to driver
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extension_map
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 26.
</p>

<hr>
<h2 id='gdal'>functions to interact with gdal not meant to be called directly by users (but e.g. by stars::read_stars)</h2><span id='topic+gdal'></span><span id='topic+gdal_read'></span><span id='topic+gdal_write'></span><span id='topic+gdal_inv_geotransform'></span><span id='topic+gdal_crs'></span><span id='topic+gdal_metadata'></span><span id='topic+gdal_subdatasets'></span><span id='topic+gdal_polygonize'></span><span id='topic+gdal_rasterize'></span><span id='topic+gdal_extract'></span><span id='topic+gdal_read_mdim'></span><span id='topic+gdal_write_mdim'></span><span id='topic+gdal_create'></span>

<h3>Description</h3>

<p>functions to interact with gdal not meant to be called directly by users (but e.g. by stars::read_stars)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gdal_read(
  x,
  ...,
  options = character(0),
  driver = character(0),
  read_data = TRUE,
  NA_value = NA_real_,
  RasterIO_parameters = list()
)

gdal_write(
  x,
  ...,
  file,
  driver = "GTiff",
  options = character(0),
  type = "Float32",
  NA_value = NA_real_,
  geotransform,
  update = FALSE,
  scale_offset = c(1, 0)
)

gdal_inv_geotransform(gt)

gdal_crs(file, options = character(0))

gdal_metadata(
  file,
  domain_item = character(0),
  options = character(0),
  parse = TRUE
)

gdal_subdatasets(file, options = character(0), name = TRUE)

gdal_polygonize(
  x,
  mask = NULL,
  file = tempfile(),
  driver = "GTiff",
  use_integer = TRUE,
  geotransform,
  breaks = classInt::classIntervals(na.omit(as.vector(x[[1]])))$brks,
  use_contours = FALSE,
  contour_lines = FALSE,
  connect8 = FALSE,
  ...
)

gdal_rasterize(sf, x, gt, file, driver = "GTiff", options = character())

gdal_extract(f, pts, bilinear = FALSE)

gdal_read_mdim(
  file,
  array_name = character(0),
  options = character(0),
  offset = integer(0),
  count = integer(0),
  step = integer(0),
  proxy = FALSE,
  debug = FALSE
)

gdal_write_mdim(
  file,
  driver,
  dimx,
  cdl,
  wkt,
  xy,
  ...,
  root_group_options = character(0),
  options = character(0),
  as_float = TRUE
)

gdal_create(f, nxy, values, crs, xlim, ylim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gdal_+3A_x">x</code></td>
<td>
<p>character vector, possibly of length larger than 1 when more than one raster is read</p>
</td></tr>
<tr><td><code id="gdal_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="gdal_+3A_options">options</code></td>
<td>
<p>character; driver specific options regarding reading or creating the dataset</p>
</td></tr>
<tr><td><code id="gdal_+3A_driver">driver</code></td>
<td>
<p>character; driver short name; when empty vector, driver is auto-detected.</p>
</td></tr>
<tr><td><code id="gdal_+3A_read_data">read_data</code></td>
<td>
<p>logical; if <code>FALSE</code>, only the imagery metadata is returned</p>
</td></tr>
<tr><td><code id="gdal_+3A_na_value">NA_value</code></td>
<td>
<p>(double) non-NA value to use for missing values; if <code>NA</code>, when writing missing values are not specially flagged in output dataset, when reading the default (dataset) missing values are used (if present / set).</p>
</td></tr>
<tr><td><code id="gdal_+3A_rasterio_parameters">RasterIO_parameters</code></td>
<td>
<p>list with named parameters to GDAL's RasterIO; see the stars::read_stars documentation.</p>
</td></tr>
<tr><td><code id="gdal_+3A_file">file</code></td>
<td>
<p>file name</p>
</td></tr>
<tr><td><code id="gdal_+3A_type">type</code></td>
<td>
<p>gdal write type</p>
</td></tr>
<tr><td><code id="gdal_+3A_geotransform">geotransform</code></td>
<td>
<p>length 6 numeric vector with GDAL geotransform parameters.</p>
</td></tr>
<tr><td><code id="gdal_+3A_update">update</code></td>
<td>
<p>logical; <code>TRUE</code> if in an existing raster file pixel values shall be updated.</p>
</td></tr>
<tr><td><code id="gdal_+3A_scale_offset">scale_offset</code></td>
<td>
<p>length 2 numeric; contains scale and offset values</p>
</td></tr>
<tr><td><code id="gdal_+3A_gt">gt</code></td>
<td>
<p>double vector of length 6</p>
</td></tr>
<tr><td><code id="gdal_+3A_domain_item">domain_item</code></td>
<td>
<p>character vector of length 0, 1 (with domain), or 2 (with domain and item); use <code>""</code> for the default domain, use <code>NA_character_</code> to query the domain names.</p>
</td></tr>
<tr><td><code id="gdal_+3A_parse">parse</code></td>
<td>
<p>logical; should metadata be parsed into a named list (<code>TRUE</code>) or returned as character data?</p>
</td></tr>
<tr><td><code id="gdal_+3A_name">name</code></td>
<td>
<p>logical; retrieve name of subdataset? If <code>FALSE</code>, retrieve description</p>
</td></tr>
<tr><td><code id="gdal_+3A_mask">mask</code></td>
<td>
<p>stars object with NA mask (0 where NA), or NULL</p>
</td></tr>
<tr><td><code id="gdal_+3A_use_integer">use_integer</code></td>
<td>
<p>boolean; if <code>TRUE</code>, raster values are read as (and rounded to) unsigned 32-bit integers values; if <code>FALSE</code> they are read as 32-bit floating points numbers. The former is supposedly faster.</p>
</td></tr>
<tr><td><code id="gdal_+3A_breaks">breaks</code></td>
<td>
<p>numeric vector with break values for contour polygons (or lines)</p>
</td></tr>
<tr><td><code id="gdal_+3A_use_contours">use_contours</code></td>
<td>
<p>logical;</p>
</td></tr>
<tr><td><code id="gdal_+3A_contour_lines">contour_lines</code></td>
<td>
<p>logical;</p>
</td></tr>
<tr><td><code id="gdal_+3A_connect8">connect8</code></td>
<td>
<p>logical; if <code>TRUE</code> use 8 connection algorithm, rather than 4</p>
</td></tr>
<tr><td><code id="gdal_+3A_sf">sf</code></td>
<td>
<p>object of class <code>sf</code></p>
</td></tr>
<tr><td><code id="gdal_+3A_f">f</code></td>
<td>
<p>character; file name</p>
</td></tr>
<tr><td><code id="gdal_+3A_pts">pts</code></td>
<td>
<p>points matrix</p>
</td></tr>
<tr><td><code id="gdal_+3A_bilinear">bilinear</code></td>
<td>
<p>logical; use bilinear interpolation, rather than nearest neighbor?</p>
</td></tr>
<tr><td><code id="gdal_+3A_array_name">array_name</code></td>
<td>
<p>array name</p>
</td></tr>
<tr><td><code id="gdal_+3A_offset">offset</code></td>
<td>
<p>offset (pixels)</p>
</td></tr>
<tr><td><code id="gdal_+3A_count">count</code></td>
<td>
<p>number of pixels to read</p>
</td></tr>
<tr><td><code id="gdal_+3A_step">step</code></td>
<td>
<p>step size (pixels)</p>
</td></tr>
<tr><td><code id="gdal_+3A_proxy">proxy</code></td>
<td>
<p>logical; return proxy object?</p>
</td></tr>
<tr><td><code id="gdal_+3A_debug">debug</code></td>
<td>
<p>logical; print debug messages?</p>
</td></tr>
<tr><td><code id="gdal_+3A_dimx">dimx</code></td>
<td>
<p>integer named vector with dimensions of object</p>
</td></tr>
<tr><td><code id="gdal_+3A_cdl">cdl</code></td>
<td>
<p>list with variables, each having a named dim attribute</p>
</td></tr>
<tr><td><code id="gdal_+3A_wkt">wkt</code></td>
<td>
<p>character; WKT of crs</p>
</td></tr>
<tr><td><code id="gdal_+3A_xy">xy</code></td>
<td>
<p>character; names of the spatial x and y dimension</p>
</td></tr>
<tr><td><code id="gdal_+3A_root_group_options">root_group_options</code></td>
<td>
<p>character; driver specific options regarding the creation of the root group</p>
</td></tr>
<tr><td><code id="gdal_+3A_as_float">as_float</code></td>
<td>
<p>logical; when <code>TRUE</code> write 4-byte floating point numbers, when <code>FALSE</code> write 8-byte doubles.</p>
</td></tr>
<tr><td><code id="gdal_+3A_nxy">nxy</code></td>
<td>
<p>integer vector of length 2</p>
</td></tr>
<tr><td><code id="gdal_+3A_values">values</code></td>
<td>
<p>fill value</p>
</td></tr>
<tr><td><code id="gdal_+3A_crs">crs</code></td>
<td>
<p>object of class <code>crs</code></p>
</td></tr>
<tr><td><code id="gdal_+3A_xlim">xlim</code></td>
<td>
<p>numeric</p>
</td></tr>
<tr><td><code id="gdal_+3A_ylim">ylim</code></td>
<td>
<p>numeric</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are exported for the single purpose of being used by package stars, they are not meant to be used directly and may change or disappear without prior notice or deprecation warnings.
</p>
<p>gdal_inv_geotransform returns the inverse geotransform
</p>
<p>gdal_crs reads coordinate reference system from GDAL data set
</p>
<p>get_metadata gets metadata of a raster layer
</p>
<p>gdal_subdatasets returns the subdatasets of a gdal dataset
</p>


<h3>Value</h3>

<p>object of class <code>crs</code>, see <a href="#topic+st_crs">st_crs</a>.
</p>
<p>named list with metadata items
</p>
<p><code>gdal_subdatasets</code> returns a zero-length list if <code>file</code> does not have subdatasets, and else a named list with subdatasets.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  f = system.file("tif/L7_ETMs.tif", package="stars")
  f = system.file("nc/avhrr-only-v2.19810901.nc", package = "stars")
  gdal_metadata(f)
  gdal_metadata(f, NA_character_)
  try(gdal_metadata(f, "wrongDomain"))
  gdal_metadata(f, c("", "AREA_OR_POINT"))

## End(Not run)
</code></pre>

<hr>
<h2 id='gdal_addo'>Add or remove overviews to/from a raster image</h2><span id='topic+gdal_addo'></span>

<h3>Description</h3>

<p>add or remove overviews to/from a raster image
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gdal_addo(
  file,
  overviews = c(2, 4, 8, 16),
  method = "NEAREST",
  layers = integer(0),
  options = character(0),
  config_options = character(0),
  clean = FALSE,
  read_only = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gdal_addo_+3A_file">file</code></td>
<td>
<p>character; file name</p>
</td></tr>
<tr><td><code id="gdal_addo_+3A_overviews">overviews</code></td>
<td>
<p>integer; overview levels</p>
</td></tr>
<tr><td><code id="gdal_addo_+3A_method">method</code></td>
<td>
<p>character; method to create overview; one of: nearest, average, rms, gauss, cubic, cubicspline, lanczos, average_mp, average_magphase, mode</p>
</td></tr>
<tr><td><code id="gdal_addo_+3A_layers">layers</code></td>
<td>
<p>integer; layers to create overviews for (default: all)</p>
</td></tr>
<tr><td><code id="gdal_addo_+3A_options">options</code></td>
<td>
<p>character; dataset opening options</p>
</td></tr>
<tr><td><code id="gdal_addo_+3A_config_options">config_options</code></td>
<td>
<p>named character vector with GDAL config options, like <code>c(option1=value1, option2=value2)</code></p>
</td></tr>
<tr><td><code id="gdal_addo_+3A_clean">clean</code></td>
<td>
<p>logical; if <code>TRUE</code> only remove overviews, do not add</p>
</td></tr>
<tr><td><code id="gdal_addo_+3A_read_only">read_only</code></td>
<td>
<p>logical; if <code>TRUE</code>, add overviews to another file with extension <code>.ovr</code> added to <code>file</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code>, invisibly, on success
</p>


<h3>See Also</h3>

<p><a href="#topic+gdal_utils">gdal_utils</a> for access to other gdal utilities that have a C API
</p>

<hr>
<h2 id='gdal_utils'>Native interface to gdal utils</h2><span id='topic+gdal_utils'></span>

<h3>Description</h3>

<p>Native interface to gdal utils
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gdal_utils(
  util = "info",
  source,
  destination,
  options = character(0),
  quiet = !(util %in% c("info", "gdalinfo", "ogrinfo", "vectorinfo", "mdiminfo")) ||
    ("-multi" %in% options),
  processing = character(0),
  colorfilename = character(0),
  config_options = character(0)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gdal_utils_+3A_util">util</code></td>
<td>
<p>character; one of <code>info</code>, <code>warp</code>, <code>rasterize</code>, <code>translate</code>, <code>vectortranslate</code> (for ogr2ogr), <code>buildvrt</code>, <code>demprocessing</code>, <code>nearblack</code>, <code>grid</code>, <code>mdiminfo</code> and <code>mdimtranslate</code> (the last two requiring GDAL 3.1), <code>ogrinfo</code> (requiring GDAL 3.7), <code>footprint</code> (requiring GDAL 3.8)</p>
</td></tr>
<tr><td><code id="gdal_utils_+3A_source">source</code></td>
<td>
<p>character; name of input layer(s); for <code>warp</code>, <code>buidvrt</code> or <code>mdimtranslate</code> this can be more than one</p>
</td></tr>
<tr><td><code id="gdal_utils_+3A_destination">destination</code></td>
<td>
<p>character; name of output layer</p>
</td></tr>
<tr><td><code id="gdal_utils_+3A_options">options</code></td>
<td>
<p>character; options for the utility</p>
</td></tr>
<tr><td><code id="gdal_utils_+3A_quiet">quiet</code></td>
<td>
<p>logical; if <code>TRUE</code>, suppress printing the output for <code>info</code> and <code>mdiminfo</code>, and suppress printing progress</p>
</td></tr>
<tr><td><code id="gdal_utils_+3A_processing">processing</code></td>
<td>
<p>character; processing options for <code>demprocessing</code></p>
</td></tr>
<tr><td><code id="gdal_utils_+3A_colorfilename">colorfilename</code></td>
<td>
<p>character; name of color file for <code>demprocessing</code> (mandatory if <code>processing="color-relief"</code>)</p>
</td></tr>
<tr><td><code id="gdal_utils_+3A_config_options">config_options</code></td>
<td>
<p>named character vector with GDAL config options, like <code>c(option1=value1, option2=value2)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>info</code> returns a character vector with the raster metadata; all other utils return (invisibly) a logical indicating success (i.e., <code>TRUE</code>); in case of failure, an error is raised.
</p>


<h3>See Also</h3>

<p><a href="#topic+gdal_addo">gdal_addo</a> for adding overlays to a raste file; <a href="#topic+st_layers">st_layers</a> to query geometry type(s) and crs from layers in a (vector) data source
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (sf_extSoftVersion()["GDAL"] &gt; "2.1.0") {
# info utils can be used to list information about about a raster
# dataset. More info: https://gdal.org/programs/ngdalinfo.html
in_file &lt;- system.file("tif/geomatrix.tif", package = "sf")
gdal_utils("info", in_file, options = c("-mm", "-proj4"))

# vectortranslate utils can be used to convert simple features data between
# file formats. More info: https://gdal.org/programs/ogr2ogr.html
in_file &lt;- system.file("shape/storms_xyz.shp", package="sf")
out_file &lt;- paste0(tempfile(), ".gpkg")
gdal_utils(
  util = "vectortranslate",
  source = in_file,
  destination = out_file, # output format must be specified for GDAL &lt; 2.3
  options = c("-f", "GPKG")
)
# The parameters can be specified as c("name") or c("name", "value"). The
# vectortranslate utils can perform also various operations during the
# conversion process. For example we can reproject the features during the
# translation.
gdal_utils(
  util = "vectortranslate",
  source = in_file,
  destination = out_file,
  options = c(
  "-f", "GPKG", # output file format for GDAL &lt; 2.3
  "-s_srs", "EPSG:4326", # input file SRS
  "-t_srs", "EPSG:2264", # output file SRS
  "-overwrite"
  )
)
st_read(out_file)
# The parameter s_srs had to be specified because, in this case, the in_file
# has no associated SRS.
st_read(in_file)
}
</code></pre>

<hr>
<h2 id='geos_binary_ops'>Geometric operations on pairs of simple feature geometry sets</h2><span id='topic+geos_binary_ops'></span><span id='topic+st_intersection'></span><span id='topic+st_intersection.sfc'></span><span id='topic+st_intersection.sf'></span><span id='topic+st_difference'></span><span id='topic+st_difference.sfc'></span><span id='topic+st_sym_difference'></span><span id='topic+st_snap'></span>

<h3>Description</h3>

<p>Perform geometric set operations with simple feature geometry collections
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_intersection(x, y, ...)

## S3 method for class 'sfc'
st_intersection(x, y, ...)

## S3 method for class 'sf'
st_intersection(x, y, ...)

st_difference(x, y, ...)

## S3 method for class 'sfc'
st_difference(x, y, ...)

st_sym_difference(x, y, ...)

st_snap(x, y, tolerance)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geos_binary_ops_+3A_x">x</code></td>
<td>
<p>object of class <code>sf</code>, <code>sfc</code> or <code>sfg</code></p>
</td></tr>
<tr><td><code id="geos_binary_ops_+3A_y">y</code></td>
<td>
<p>object of class <code>sf</code>, <code>sfc</code> or <code>sfg</code></p>
</td></tr>
<tr><td><code id="geos_binary_ops_+3A_...">...</code></td>
<td>
<p>arguments passed on to <a href="s2.html#topic+s2_options">s2_options</a></p>
</td></tr>
<tr><td><code id="geos_binary_ops_+3A_tolerance">tolerance</code></td>
<td>
<p>tolerance values used for <code>st_snap</code>; numeric value or object of class <code>units</code>; may have tolerance values for each feature in <code>x</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>When using GEOS and not using s2, a spatial index is built on argument <code>x</code>; see <a href="https://r-spatial.org/r/2017/06/22/spatial-index.html">https://r-spatial.org/r/2017/06/22/spatial-index.html</a>. The reference for the STR tree algorithm is: Leutenegger, Scott T., Mario A. Lopez, and Jeffrey Edgington. &quot;STR: A simple and efficient algorithm for R-tree packing.&quot; Data Engineering, 1997. Proceedings. 13th international conference on. IEEE, 1997. For the pdf, search Google Scholar.
</p>
<p>When called with missing <code>y</code>, the <code>sfc</code> method for <code>st_intersection</code> returns all non-empty intersections of the geometries of <code>x</code>; an attribute <code>idx</code> contains a list-column with the indexes of contributing geometries.
</p>
<p>when called with a missing <code>y</code>, the <code>sf</code> method for <code>st_intersection</code> returns an <code>sf</code> object with attributes taken from the contributing feature with lowest index; two fields are added: <code>n.overlaps</code> with the number of overlapping features in <code>x</code>, and a list-column <code>origins</code> with indexes of all overlapping features.
</p>
<p>When <code>st_difference</code> is called with a single argument,
overlapping areas are erased from geometries that are indexed at greater
numbers in the argument to <code>x</code>; geometries that are empty
or contained fully inside geometries with higher priority are removed entirely.
The <code>st_difference.sfc</code> method with a single argument returns an object with
an <code>"idx"</code> attribute with the original index for returned geometries.
</p>
<p><code>st_snap</code> snaps the vertices and segments of a geometry to another geometry's vertices. If <code>y</code> contains more than one geometry, its geometries are merged into a collection before snapping to that collection.
</p>
<p>(from the GEOS docs:) &quot;A snap distance tolerance is used to control where snapping is performed. Snapping one geometry to another can improve robustness for overlay operations by eliminating nearly-coincident edges (which cause problems during noding and intersection calculation). Too much snapping can result in invalid topology being created, so the number and location of snapped vertices is decided using heuristics to determine when it is safe to snap. This can result in some potential snaps being omitted, however.&quot;
</p>


<h3>Value</h3>

<p>The intersection, difference or symmetric difference between two sets of geometries.
The returned object has the same class as that of the first argument (<code>x</code>) with the non-empty geometries resulting from applying the operation to all geometry pairs in <code>x</code> and <code>y</code>. In case <code>x</code> is of class <code>sf</code>, the matching attributes of the original object(s) are added. The <code>sfc</code> geometry list-column returned carries an attribute <code>idx</code>, which is an <code>n</code>-by-2 matrix with every row the index of the corresponding entries of <code>x</code> and <code>y</code>, respectively.
</p>


<h3>Note</h3>

<p>To find whether pairs of simple feature geometries intersect, use
the function <code><a href="#topic+st_intersects">st_intersects</a></code> instead of <code>st_intersection</code>.
</p>
<p>When using GEOS and not using s2 polygons contain their boundary. When using s2 this is determined by the <code>model</code> defaults of <a href="s2.html#topic+s2_options">s2_options</a>, which can be overridden via the ... argument, e.g. <code>model = "closed"</code> to force DE-9IM compliant behaviour of polygons (and reproduce GEOS results).
</p>


<h3>See Also</h3>

<p><a href="#topic+st_union">st_union</a> for the union of simple features collections; <a href="base.html#topic+intersect">intersect</a> and <a href="base.html#topic+setdiff">setdiff</a> for the base R set operations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(131)
library(sf)
m = rbind(c(0,0), c(1,0), c(1,1), c(0,1), c(0,0))
p = st_polygon(list(m))
n = 100
l = vector("list", n)
for (i in 1:n)
  l[[i]] = p + 10 * runif(2)
s = st_sfc(l)
plot(s, col = sf.colors(categorical = TRUE, alpha = .5))
title("overlapping squares")
d = st_difference(s) # sequential differences: s1, s2-s1, s3-s2-s1, ...
plot(d, col = sf.colors(categorical = TRUE, alpha = .5))
title("non-overlapping differences")
i = st_intersection(s) # all intersections
plot(i, col = sf.colors(categorical = TRUE, alpha = .5))
title("non-overlapping intersections")
summary(lengths(st_overlaps(s, s))) # includes self-counts!
summary(lengths(st_overlaps(d, d)))
summary(lengths(st_overlaps(i, i)))
sf = st_sf(s)
i = st_intersection(sf) # all intersections
plot(i["n.overlaps"])
summary(i$n.overlaps - lengths(i$origins))
# A helper function that erases all of y from x:
st_erase = function(x, y) st_difference(x, st_union(st_combine(y)))
poly = st_polygon(list(cbind(c(0, 0, 1, 1, 0), c(0, 1, 1, 0, 0))))
lines = st_multilinestring(list(
 cbind(c(0, 1), c(1, 1.05)),
 cbind(c(0, 1), c(0, -.05)),
 cbind(c(1, .95, 1), c(1.05, .5, -.05))
))
snapped = st_snap(poly, lines, tolerance=.1)
plot(snapped, col='red')
plot(poly, border='green', add=TRUE)
plot(lines, lwd=2, col='blue', add=TRUE)
</code></pre>

<hr>
<h2 id='geos_binary_pred'>Geometric binary predicates on pairs of simple feature geometry sets</h2><span id='topic+geos_binary_pred'></span><span id='topic+st_intersects'></span><span id='topic+st_disjoint'></span><span id='topic+st_touches'></span><span id='topic+st_crosses'></span><span id='topic+st_within'></span><span id='topic+st_contains'></span><span id='topic+st_contains_properly'></span><span id='topic+st_overlaps'></span><span id='topic+st_equals'></span><span id='topic+st_covers'></span><span id='topic+st_covered_by'></span><span id='topic+st_equals_exact'></span><span id='topic+st_is_within_distance'></span>

<h3>Description</h3>

<p>Geometric binary predicates on pairs of simple feature geometry sets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_intersects(x, y, sparse = TRUE, ...)

st_disjoint(x, y = x, sparse = TRUE, prepared = TRUE)

st_touches(x, y, sparse = TRUE, prepared = TRUE, ...)

st_crosses(x, y, sparse = TRUE, prepared = TRUE, ...)

st_within(x, y, sparse = TRUE, prepared = TRUE, ...)

st_contains(x, y, sparse = TRUE, prepared = TRUE, ..., model = "open")

st_contains_properly(x, y, sparse = TRUE, prepared = TRUE, ...)

st_overlaps(x, y, sparse = TRUE, prepared = TRUE, ...)

st_equals(
  x,
  y,
  sparse = TRUE,
  prepared = FALSE,
  ...,
  retain_unique = FALSE,
  remove_self = FALSE
)

st_covers(x, y, sparse = TRUE, prepared = TRUE, ..., model = "closed")

st_covered_by(x, y = x, sparse = TRUE, prepared = TRUE, ..., model = "closed")

st_equals_exact(x, y, par, sparse = TRUE, prepared = FALSE, ...)

st_is_within_distance(x, y = x, dist, sparse = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geos_binary_pred_+3A_x">x</code></td>
<td>
<p>object of class <code>sf</code>, <code>sfc</code> or <code>sfg</code></p>
</td></tr>
<tr><td><code id="geos_binary_pred_+3A_y">y</code></td>
<td>
<p>object of class <code>sf</code>, <code>sfc</code> or <code>sfg</code>; if missing, <code>x</code> is used</p>
</td></tr>
<tr><td><code id="geos_binary_pred_+3A_sparse">sparse</code></td>
<td>
<p>logical; should a sparse index list be returned (<code>TRUE</code>) or a dense logical matrix? See below.</p>
</td></tr>
<tr><td><code id="geos_binary_pred_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="s2.html#topic+s2_options">s2::s2_options</a></code>
</p>

<dl>
<dt><code>snap</code></dt><dd><p>Use <code>s2_snap_identity()</code>, <code>s2_snap_distance()</code>, <code>s2_snap_level()</code>,
or <code>s2_snap_precision()</code> to specify how or if coordinate rounding should
occur.</p>
</dd>
<dt><code>snap_radius</code></dt><dd><p>As opposed to the snap function, which specifies
the maximum distance a vertex should move, the snap radius (in radians) sets
the minimum distance between vertices of the output that don't cause vertices
to move more than the distance specified by the snap function. This can be used
to simplify the result of a boolean operation. Use -1 to specify that any
minimum distance is acceptable.</p>
</dd>
<dt><code>duplicate_edges</code></dt><dd><p>Use <code>TRUE</code> to keep duplicate edges (e.g., duplicate
points).</p>
</dd>
<dt><code>edge_type</code></dt><dd><p>One of 'directed' (default) or 'undirected'.</p>
</dd>
<dt><code>validate</code></dt><dd><p>Use <code>TRUE</code> to validate the result from the builder.</p>
</dd>
<dt><code>polyline_type</code></dt><dd><p>One of 'path' (default) or 'walk'. If 'walk',
polylines that backtrack are preserved.</p>
</dd>
<dt><code>polyline_sibling_pairs</code></dt><dd><p>One of 'discard' (default) or 'keep'.</p>
</dd>
<dt><code>simplify_edge_chains</code></dt><dd><p>Use <code>TRUE</code> to remove vertices that are within
<code>snap_radius</code> of the original vertex.</p>
</dd>
<dt><code>split_crossing_edges</code></dt><dd><p>Use <code>TRUE</code> to split crossing polyline edges
when creating geometries.</p>
</dd>
<dt><code>idempotent</code></dt><dd><p>Use <code>FALSE</code> to apply snap even if snapping is not necessary
to satisfy vertex constraints.</p>
</dd>
<dt><code>dimensions</code></dt><dd><p>A combination of 'point', 'polyline', and/or 'polygon'
that can used to constrain the output of <code><a href="s2.html#topic+s2_rebuild">s2_rebuild()</a></code> or a
boolean operation.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="geos_binary_pred_+3A_prepared">prepared</code></td>
<td>
<p>logical; prepare geometry for <code>x</code>, before looping over <code>y</code>? See Details.</p>
</td></tr>
<tr><td><code id="geos_binary_pred_+3A_model">model</code></td>
<td>
<p>character; polygon/polyline model; one of
&quot;open&quot;, &quot;semi-open&quot; or &quot;closed&quot;; see Details.</p>
</td></tr>
<tr><td><code id="geos_binary_pred_+3A_retain_unique">retain_unique</code></td>
<td>
<p>logical; if <code>TRUE</code> (and <code>y</code> is missing) return only indexes of points larger than the current index; this can be used to select unique geometries, see examples. This argument can be used for all geometry predicates; see also <a href="#topic+distinct.sf">distinct.sf</a> to find records where geometries AND attributes are distinct.</p>
</td></tr>
<tr><td><code id="geos_binary_pred_+3A_remove_self">remove_self</code></td>
<td>
<p>logical; if <code>TRUE</code> (and <code>y</code> is missing) return only indexes of geometries different from the current index; this can be used to omit self-intersections; see examples. This argument can be used for all geometry predicates</p>
</td></tr>
<tr><td><code id="geos_binary_pred_+3A_par">par</code></td>
<td>
<p>numeric; parameter used for &quot;equals_exact&quot; (margin);</p>
</td></tr>
<tr><td><code id="geos_binary_pred_+3A_dist">dist</code></td>
<td>
<p>distance threshold; geometry indexes with distances smaller or equal to this value are returned; numeric value or units value having distance units.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>prepared</code> is <code>TRUE</code>, and <code>x</code> contains POINT geometries and <code>y</code> contains polygons, then the polygon geometries are prepared, rather than the points.
</p>
<p>For most predicates, a spatial index is built on argument <code>x</code>; see <a href="https://r-spatial.org/r/2017/06/22/spatial-index.html">https://r-spatial.org/r/2017/06/22/spatial-index.html</a>.
Specifically, <code>st_intersects</code>, <code>st_disjoint</code>, <code>st_touches</code> <code>st_crosses</code>, <code>st_within</code>, <code>st_contains</code>, <code>st_contains_properly</code>, <code>st_overlaps</code>, <code>st_equals</code>, <code>st_covers</code> and <code>st_covered_by</code> all build spatial indexes for more efficient geometry calculations. <code>st_relate</code>, <code>st_equals_exact</code>, and do not; <code>st_is_within_distance</code> uses a spatial index for geographic coordinates when <code>sf_use_s2()</code> is true.
</p>
<p>If <code>y</code> is missing, <code>st_predicate(x, x)</code> is effectively called, and a square matrix is returned with diagonal elements <code>st_predicate(x[i], x[i])</code>.
</p>
<p>Sparse geometry binary predicate (<code><a href="#topic+sgbp">sgbp</a></code>) lists have the following attributes: <code>region.id</code> with the <code>row.names</code> of <code>x</code> (if any, else <code>1:n</code>), <code>ncol</code> with the number of features in <code>y</code>, and <code>predicate</code> with the name of the predicate used.
</p>
<p>for <code>model</code>, see https://github.com/r-spatial/s2/issues/32
</p>
<p><code>st_contains_properly(A,B)</code> is true if A intersects B's interior, but not its edges or exterior; A contains A, but A does not properly contain A.
</p>
<p>See also <a href="#topic+st_relate">st_relate</a> and <a href="https://en.wikipedia.org/wiki/DE-9IM">https://en.wikipedia.org/wiki/DE-9IM</a> for a more detailed description of the underlying algorithms.
</p>
<p><code>st_equals_exact</code> returns true for two geometries of the same type and their vertices corresponding by index are equal up to a specified tolerance.
</p>


<h3>Value</h3>

<p>If <code>sparse=FALSE</code>, <code>st_predicate</code> (with <code>predicate</code> e.g. &quot;intersects&quot;) returns a dense logical matrix with element <code>i,j</code> <code>TRUE</code> when <code>predicate(x[i], y[j])</code> (e.g., when geometry of feature i and j intersect); if <code>sparse=TRUE</code>, an object of class <code><a href="#topic+sgbp">sgbp</a></code> with a sparse list representation of the same matrix, with list element <code>i</code> an integer vector with all indices j for which <code>predicate(x[i],y[j])</code> is <code>TRUE</code> (and hence a zero-length integer vector if none of them is <code>TRUE</code>). From the dense matrix, one can find out if one or more elements intersect by <code>apply(mat, 1, any)</code>, and from the sparse list by <code>lengths(lst) &gt; 0</code>, see examples below.
</p>


<h3>Note</h3>

<p>For intersection on pairs of simple feature geometries, use
the function <code><a href="#topic+st_intersection">st_intersection</a></code> instead of <code>st_intersects</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pts = st_sfc(st_point(c(.5,.5)), st_point(c(1.5, 1.5)), st_point(c(2.5, 2.5)))
pol = st_polygon(list(rbind(c(0,0), c(2,0), c(2,2), c(0,2), c(0,0))))
(lst = st_intersects(pts, pol))
(mat = st_intersects(pts, pol, sparse = FALSE))
# which points fall inside a polygon?
apply(mat, 1, any)
lengths(lst) &gt; 0
# which points fall inside the first polygon?
st_intersects(pol, pts)[[1]]
# remove duplicate geometries:
p1 = st_point(0:1)
p2 = st_point(2:1)
p = st_sf(a = letters[1:8], geom = st_sfc(p1, p1, p2, p1, p1, p2, p2, p1))
st_equals(p)
st_equals(p, remove_self = TRUE)
(u = st_equals(p, retain_unique = TRUE))
# retain the records with unique geometries:
p[-unlist(u),]
</code></pre>

<hr>
<h2 id='geos_combine'>Combine or union feature geometries</h2><span id='topic+geos_combine'></span><span id='topic+st_combine'></span><span id='topic+st_union'></span>

<h3>Description</h3>

<p>Combine several feature geometries into one, without unioning or resolving internal boundaries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_combine(x)

st_union(x, y, ..., by_feature = FALSE, is_coverage = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geos_combine_+3A_x">x</code></td>
<td>
<p>object of class <code>sf</code>, <code>sfc</code> or <code>sfg</code></p>
</td></tr>
<tr><td><code id="geos_combine_+3A_y">y</code></td>
<td>
<p>object of class <code>sf</code>, <code>sfc</code> or <code>sfg</code> (optional)</p>
</td></tr>
<tr><td><code id="geos_combine_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="geos_combine_+3A_by_feature">by_feature</code></td>
<td>
<p>logical; if <code>TRUE</code>, union each feature if <code>y</code> is missing or else each pair of features; if <code>FALSE</code> return a single feature that is the geometric union of the set of features in <code>x</code> if <code>y</code> is missing, or else the unions of each of the elements of the Cartesian product of both sets</p>
</td></tr>
<tr><td><code id="geos_combine_+3A_is_coverage">is_coverage</code></td>
<td>
<p>logical; if <code>TRUE</code>, use an optimized algorithm for features that form a polygonal coverage (have no overlaps)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>st_combine</code> combines geometries without resolving borders, using <a href="#topic+c.sfg">c.sfg</a> (analogous to <a href="base.html#topic+c">c</a> for ordinary vectors).
</p>
<p>If <code>st_union</code> is called with a single argument, <code>x</code>, (with <code>y</code> missing) and <code>by_feature</code> is <code>FALSE</code> all geometries are unioned together and an <code>sfg</code> or single-geometry <code>sfc</code> object is returned.
If <code>by_feature</code> is <code>TRUE</code> each feature geometry is unioned individually.
This can for instance be used to resolve internal boundaries after polygons were combined using <code>st_combine</code>.
If <code>y</code> is provided, all elements of <code>x</code> and <code>y</code> are unioned, pairwise if <code>by_feature</code> is TRUE, or else as the Cartesian product of both sets.
</p>
<p>Unioning a set of overlapping polygons has the effect of merging the areas (i.e. the same effect as iteratively unioning all individual polygons together).
Unioning a set of LineStrings has the effect of fully noding and dissolving the input linework. In this context &quot;fully noded&quot; means that there will be a node or endpoint in the output for every endpoint or line segment crossing in the input.
&quot;Dissolved&quot; means that any duplicate (e.g. coincident) line segments or portions of line segments will be reduced to a single line segment in the output.	Unioning a set of Points has the effect of merging all identical points (producing a set with no duplicates).
</p>


<h3>Value</h3>

<p><code>st_combine</code> returns a single, combined geometry, with no resolved boundaries; returned geometries may well be invalid.
</p>
<p>If <code>y</code> is missing, <code>st_union(x)</code> returns a single geometry with resolved boundaries, else the geometries for all unioned pairs of <code>x[i]</code> and <code>y[j]</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+st_intersection">st_intersection</a>, <a href="#topic+st_difference">st_difference</a>, <a href="#topic+st_sym_difference">st_sym_difference</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nc = st_read(system.file("shape/nc.shp", package="sf"))
st_combine(nc)
plot(st_union(nc))
</code></pre>

<hr>
<h2 id='geos_measures'>Compute geometric measurements</h2><span id='topic+geos_measures'></span><span id='topic+st_area'></span><span id='topic+st_area.sfc'></span><span id='topic+st_length'></span><span id='topic+st_perimeter'></span><span id='topic+st_distance'></span>

<h3>Description</h3>

<p>Compute Euclidean or great circle distance between pairs of geometries; compute, the area or the length of a set of geometries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_area(x, ...)

## S3 method for class 'sfc'
st_area(x, ...)

st_length(x, ...)

st_perimeter(x, ...)

st_distance(
  x,
  y,
  ...,
  dist_fun,
  by_element = FALSE,
  which = ifelse(isTRUE(st_is_longlat(x)), "Great Circle", "Euclidean"),
  par = 0,
  tolerance = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geos_measures_+3A_x">x</code></td>
<td>
<p>object of class <code>sf</code>, <code>sfc</code> or <code>sfg</code></p>
</td></tr>
<tr><td><code id="geos_measures_+3A_...">...</code></td>
<td>
<p>passed on to <a href="s2.html#topic+s2_distance">s2_distance</a>, <a href="s2.html#topic+s2_distance_matrix">s2_distance_matrix</a>, or <a href="s2.html#topic+s2_perimeter">s2_perimeter</a></p>
</td></tr>
<tr><td><code id="geos_measures_+3A_y">y</code></td>
<td>
<p>object of class <code>sf</code>, <code>sfc</code> or <code>sfg</code>, defaults to <code>x</code></p>
</td></tr>
<tr><td><code id="geos_measures_+3A_dist_fun">dist_fun</code></td>
<td>
<p>deprecated</p>
</td></tr>
<tr><td><code id="geos_measures_+3A_by_element">by_element</code></td>
<td>
<p>logical; if <code>TRUE</code>, return a vector with distance between the first elements of <code>x</code> and <code>y</code>, the second, etc; an error is raised if <code>x</code> and <code>y</code> are not the same length. If <code>FALSE</code>, return the dense matrix with all pairwise distances.</p>
</td></tr>
<tr><td><code id="geos_measures_+3A_which">which</code></td>
<td>
<p>character; for Cartesian coordinates only: one of <code>Euclidean</code>, <code>Hausdorff</code> or <code>Frechet</code>; for geodetic coordinates, great circle distances are computed; see details</p>
</td></tr>
<tr><td><code id="geos_measures_+3A_par">par</code></td>
<td>
<p>for <code>which</code> equal to <code>Hausdorff</code> or <code>Frechet</code>, optionally use a value between 0 and 1 to densify the geometry</p>
</td></tr>
<tr><td><code id="geos_measures_+3A_tolerance">tolerance</code></td>
<td>
<p>ignored if <code>st_is_longlat(x)</code> is <code>FALSE</code>; otherwise, if set to a positive value, the first distance smaller than <code>tolerance</code> will be returned, and true distance may be smaller; this may speed up computation. In meters, or a <code>units</code> object convertible to meters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>great circle distance calculations use by default spherical distances (<a href="s2.html#topic+s2_distance">s2_distance</a> or <a href="s2.html#topic+s2_distance_matrix">s2_distance_matrix</a>); if <code>sf_use_s2()</code> is <code>FALSE</code>, ellipsoidal distances are computed using <a href="lwgeom.html#topic+st_geod_distance">st_geod_distance</a> which uses function <code>geod_inverse</code> from GeographicLib (part of PROJ); see Karney, Charles FF, 2013, Algorithms for geodesics, Journal of Geodesy 87(1), 43&ndash;55
</p>


<h3>Value</h3>

<p>If the coordinate reference system of <code>x</code> was set, these functions return values with unit of measurement; see <a href="units.html#topic+set_units">set_units</a>.
</p>
<p>st_area returns the area of a geometry, in the coordinate reference system used; in case <code>x</code> is in degrees longitude/latitude, <a href="lwgeom.html#topic+geod">st_geod_area</a> is used for area calculation.
</p>
<p>st_length returns the length of a <code>LINESTRING</code> or <code>MULTILINESTRING</code> geometry, using the coordinate reference system.  <code>POINT</code>, <code>MULTIPOINT</code>, <code>POLYGON</code> or <code>MULTIPOLYGON</code> geometries return zero.
</p>
<p>If <code>by_element</code> is <code>FALSE</code> <code>st_distance</code> returns a dense numeric matrix of dimension length(x) by length(y); otherwise it returns a numeric vector the same length as <code>x</code> and <code>y</code> with an error raised if the lengths of <code>x</code> and <code>y</code> are unequal. Distances involving empty geometries are <code>NA</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+st_dimension">st_dimension</a>, <a href="#topic+st_cast">st_cast</a> to convert geometry types
</p>


<h3>Examples</h3>

<pre><code class='language-R'>b0 = st_polygon(list(rbind(c(-1,-1), c(1,-1), c(1,1), c(-1,1), c(-1,-1))))
b1 = b0 + 2
b2 = b0 + c(-0.2, 2)
x = st_sfc(b0, b1, b2)
st_area(x)
line = st_sfc(st_linestring(rbind(c(30,30), c(40,40))), crs = 4326)
st_length(line)

outer = matrix(c(0,0,10,0,10,10,0,10,0,0),ncol=2, byrow=TRUE)
hole1 = matrix(c(1,1,1,2,2,2,2,1,1,1),ncol=2, byrow=TRUE)
hole2 = matrix(c(5,5,5,6,6,6,6,5,5,5),ncol=2, byrow=TRUE)

poly = st_polygon(list(outer, hole1, hole2))
mpoly = st_multipolygon(list(
	list(outer, hole1, hole2),
	list(outer + 12, hole1 + 12)
))

st_length(st_sfc(poly, mpoly))
st_perimeter(poly)
st_perimeter(mpoly)
p = st_sfc(st_point(c(0,0)), st_point(c(0,1)), st_point(c(0,2)))
st_distance(p, p)
st_distance(p, p, by_element = TRUE)
</code></pre>

<hr>
<h2 id='geos_query'>Dimension, simplicity, validity or is_empty queries on simple feature geometries</h2><span id='topic+geos_query'></span><span id='topic+st_dimension'></span><span id='topic+st_is_simple'></span><span id='topic+st_is_empty'></span>

<h3>Description</h3>

<p>Dimension, simplicity, validity or is_empty queries on simple feature geometries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_dimension(x, NA_if_empty = TRUE)

st_is_simple(x)

st_is_empty(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geos_query_+3A_x">x</code></td>
<td>
<p>object of class <code>sf</code>, <code>sfc</code> or <code>sfg</code></p>
</td></tr>
<tr><td><code id="geos_query_+3A_na_if_empty">NA_if_empty</code></td>
<td>
<p>logical; if TRUE, return NA for empty geometries</p>
</td></tr>
</table>


<h3>Value</h3>

<p>st_dimension returns a numeric vector with 0 for points, 1 for lines, 2 for surfaces, and, if <code>NA_if_empty</code> is <code>TRUE</code>, <code>NA</code> for empty geometries.
</p>
<p>st_is_simple returns a logical vector, indicating for each geometry whether it is simple (e.g., not self-intersecting)
</p>
<p>st_is_empty returns for each geometry whether it is empty
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = st_sfc(
	st_point(0:1),
	st_linestring(rbind(c(0,0),c(1,1))),
	st_polygon(list(rbind(c(0,0),c(1,0),c(0,1),c(0,0)))),
	st_multipoint(),
	st_linestring(),
	st_geometrycollection())
st_dimension(x)
st_dimension(x, FALSE)
ls = st_linestring(rbind(c(0,0), c(1,1), c(1,0), c(0,1)))
st_is_simple(st_sfc(ls, st_point(c(0,0))))
ls = st_linestring(rbind(c(0,0), c(1,1), c(1,0), c(0,1)))
st_is_empty(st_sfc(ls, st_point(), st_linestring()))
</code></pre>

<hr>
<h2 id='geos_unary'>Geometric unary operations on simple feature geometry sets</h2><span id='topic+geos_unary'></span><span id='topic+st_buffer'></span><span id='topic+st_boundary'></span><span id='topic+st_convex_hull'></span><span id='topic+st_concave_hull'></span><span id='topic+st_simplify'></span><span id='topic+st_triangulate'></span><span id='topic+st_triangulate_constrained'></span><span id='topic+st_inscribed_circle'></span><span id='topic+st_minimum_rotated_rectangle'></span><span id='topic+st_voronoi'></span><span id='topic+st_polygonize'></span><span id='topic+st_line_merge'></span><span id='topic+st_centroid'></span><span id='topic+st_point_on_surface'></span><span id='topic+st_reverse'></span><span id='topic+st_node'></span><span id='topic+st_segmentize'></span>

<h3>Description</h3>

<p>Geometric unary operations on simple feature geometries. These are all generics, with methods for <code>sfg</code>, <code>sfc</code> and <code>sf</code> objects, returning an object of the same class. All operations work on a per-feature basis, ignoring all other features.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_buffer(
  x,
  dist,
  nQuadSegs = 30,
  endCapStyle = "ROUND",
  joinStyle = "ROUND",
  mitreLimit = 1,
  singleSide = FALSE,
  ...
)

st_boundary(x)

st_convex_hull(x)

st_concave_hull(x, ratio, ..., allow_holes)

st_simplify(x, preserveTopology, dTolerance = 0)

st_triangulate(x, dTolerance = 0, bOnlyEdges = FALSE)

st_triangulate_constrained(x)

st_inscribed_circle(x, dTolerance, ...)

st_minimum_rotated_rectangle(x, ...)

st_voronoi(x, envelope, dTolerance = 0, bOnlyEdges = FALSE)

st_polygonize(x)

st_line_merge(x, ..., directed = FALSE)

st_centroid(x, ..., of_largest_polygon = FALSE)

st_point_on_surface(x)

st_reverse(x)

st_node(x)

st_segmentize(x, dfMaxLength, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geos_unary_+3A_x">x</code></td>
<td>
<p>object of class <code>sfg</code>, <code>sfc</code> or <code>sf</code></p>
</td></tr>
<tr><td><code id="geos_unary_+3A_dist">dist</code></td>
<td>
<p>numeric; buffer distance for all, or for each of the elements in <code>x</code>; in case
<code>dist</code> is a <code>units</code> object, it should be convertible to <code>arc_degree</code> if
<code>x</code> has geographic coordinates, and to <code>st_crs(x)$units</code> otherwise</p>
</td></tr>
<tr><td><code id="geos_unary_+3A_nquadsegs">nQuadSegs</code></td>
<td>
<p>integer; number of segments per quadrant (fourth of a circle), for all or per-feature; see details</p>
</td></tr>
<tr><td><code id="geos_unary_+3A_endcapstyle">endCapStyle</code></td>
<td>
<p>character; style of line ends, one of 'ROUND', 'FLAT', 'SQUARE'; see details</p>
</td></tr>
<tr><td><code id="geos_unary_+3A_joinstyle">joinStyle</code></td>
<td>
<p>character; style of line joins, one of 'ROUND', 'MITRE', 'BEVEL'; see details</p>
</td></tr>
<tr><td><code id="geos_unary_+3A_mitrelimit">mitreLimit</code></td>
<td>
<p>numeric; limit of extension for a join if <code>joinStyle</code> 'MITRE' is used (default 1.0, minimum 0.0); see details</p>
</td></tr>
<tr><td><code id="geos_unary_+3A_singleside">singleSide</code></td>
<td>
<p>logical; if <code>TRUE</code>, single-sided buffers are returned for linear geometries,
in which case negative <code>dist</code> values give buffers on the right-hand side, positive on the left; see details</p>
</td></tr>
<tr><td><code id="geos_unary_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="geos_unary_+3A_ratio">ratio</code></td>
<td>
<p>numeric; fraction convex: 1 returns the convex hulls, 0 maximally concave hulls</p>
</td></tr>
<tr><td><code id="geos_unary_+3A_allow_holes">allow_holes</code></td>
<td>
<p>logical; if <code>TRUE</code>, the resulting concave hull may have holes</p>
</td></tr>
<tr><td><code id="geos_unary_+3A_preservetopology">preserveTopology</code></td>
<td>
<p>logical; carry out topology preserving
simplification? May be specified for each, or for all feature geometries.
Note that topology is preserved only for single feature geometries, not for
sets of them. If not specified (i.e. the default), then it is internally
set equal to <code>FALSE</code> when the input data is specified with projected
coordinates or <code>sf_use_s2()</code> returns <code>FALSE</code>. Ignored in all the
other cases (with a warning when set equal to <code>FALSE</code>) since the
function implicitly calls <code>s2::s2_simplify</code> which always preserve
topological relationships (per single feature).</p>
</td></tr>
<tr><td><code id="geos_unary_+3A_dtolerance">dTolerance</code></td>
<td>
<p>numeric; tolerance parameter, specified for all or for each
feature geometry. If you run <code>st_simplify</code>, the input data is
specified with long-lat coordinates and <code>sf_use_s2()</code> returns
<code>TRUE</code>, then the value of <code>dTolerance</code> must be specified in
meters.</p>
</td></tr>
<tr><td><code id="geos_unary_+3A_bonlyedges">bOnlyEdges</code></td>
<td>
<p>logical; if TRUE, return lines, else return polygons</p>
</td></tr>
<tr><td><code id="geos_unary_+3A_envelope">envelope</code></td>
<td>
<p>object of class <code>sfc</code> or <code>sfg</code> containing a <code>POLYGON</code> with the envelope for a voronoi diagram; this only takes effect when it is larger than the default envelope, chosen when <code>envelope</code> is an empty polygon</p>
</td></tr>
<tr><td><code id="geos_unary_+3A_directed">directed</code></td>
<td>
<p>logical; if <code>TRUE</code>, lines with opposite directions will not be merged</p>
</td></tr>
<tr><td><code id="geos_unary_+3A_of_largest_polygon">of_largest_polygon</code></td>
<td>
<p>logical; for <code>st_centroid</code>: if <code>TRUE</code>, return centroid of the largest (sub)polygon of a <code>MULTIPOLYGON</code> rather than of the whole <code>MULTIPOLYGON</code></p>
</td></tr>
<tr><td><code id="geos_unary_+3A_dfmaxlength">dfMaxLength</code></td>
<td>
<p>maximum length of a line segment. If <code>x</code> has geographical coordinates (long/lat), <code>dfMaxLength</code> is either a numeric expressed in meter, or an object of class <code>units</code> with length units <code>rad</code> or <code>degree</code>; segmentation in the long/lat case takes place along the great circle, using <a href="lwgeom.html#topic+geod">st_geod_segmentize</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>st_buffer</code> computes a buffer around this geometry/each geometry. If any of <code>endCapStyle</code>,
<code>joinStyle</code>, or <code>mitreLimit</code> are set to non-default values ('ROUND', 'ROUND', 1.0 respectively) then
the underlying 'buffer with style' GEOS function is used.
If a negative buffer returns empty polygons instead of shrinking, set sf_use_s2() to FALSE
See <a href="https://postgis.net/docs/ST_Buffer.html">postgis.net/docs/ST_Buffer.html</a> for details.
</p>
<p><code>nQuadSegs</code>, <code>endCapsStyle</code>, <code>joinStyle</code>, <code>mitreLimit</code> and <code>singleSide</code> only
work when the GEOS back-end is used: for projected coordinates or when <code>sf_use_s2()</code> is set
to <code>FALSE</code>.
</p>
<p><code>st_boundary</code> returns the boundary of a geometry
</p>
<p><code>st_convex_hull</code> creates the convex hull of a set of points
</p>
<p><code>st_concave_hull</code> creates the concave hull of a geometry
</p>
<p><code>st_simplify</code> simplifies lines by removing vertices.
</p>
<p><code>st_triangulate</code> triangulates set of points (not constrained). <code>st_triangulate</code> requires GEOS version 3.4 or above
</p>
<p><code>st_triangulate_constrained</code> returns the constrained delaunay triangulation of polygons; requires GEOS version 3.10 or above
</p>
<p><code>st_inscribed_circle</code> returns the maximum inscribed circle for polygon geometries.
For <code>st_inscribed_circle</code>, if <code>nQuadSegs</code> is 0 a 2-point LINESTRING is returned with the
center point and a boundary point of every circle, otherwise a circle (buffer) is returned where
<code>nQuadSegs</code> controls the number of points per quadrant to approximate the circle.
<code>st_inscribed_circle</code> requires GEOS version 3.9 or above
</p>
<p><code>st_minimum_rotated_rectangle</code> returns the minimum
rotated rectangular POLYGON which encloses the input geometry. The
rectangle has width equal to the minimum diameter, and a longer
length. If the convex hill of the input is degenerate (a line or
point) a linestring or point is returned.
</p>
<p><code>st_voronoi</code> creates voronoi tesselation. <code>st_voronoi</code> requires GEOS version 3.5 or above
</p>
<p><code>st_polygonize</code> creates polygon from lines that form a closed ring. In case of <code>st_polygonize</code>, <code>x</code> must be an object of class <code>LINESTRING</code> or <code>MULTILINESTRING</code>, or an <code>sfc</code> geometry list-column object containing these
</p>
<p><code>st_line_merge</code> merges lines. In case of <code>st_line_merge</code>, <code>x</code> must be an object of class <code>MULTILINESTRING</code>, or an <code>sfc</code> geometry list-column object containing these
</p>
<p><code>st_centroid</code> gives the centroid of a geometry
</p>
<p><code>st_point_on_surface</code> returns a point guaranteed to be on the (multi)surface.
</p>
<p><code>st_reverse</code> reverses the nodes in a line
</p>
<p><code>st_node</code> adds nodes to linear geometries at intersections without a node, and only works on individual linear geometries
</p>
<p><code>st_segmentize</code> adds points to straight lines
</p>


<h3>Value</h3>

<p>an object of the same class of <code>x</code>, with manipulated geometry.
</p>


<h3>See Also</h3>

<p><a href="grDevices.html#topic+chull">chull</a> for a more efficient algorithm for calculating the convex hull
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## st_buffer, style options (taken from rgeos gBuffer)
l1 = st_as_sfc("LINESTRING(0 0,1 5,4 5,5 2,8 2,9 4,4 6.5)")
op = par(mfrow=c(2,3))
plot(st_buffer(l1, dist = 1, endCapStyle="ROUND"), reset = FALSE, main = "endCapStyle: ROUND")
plot(l1,col='blue',add=TRUE)
plot(st_buffer(l1, dist = 1, endCapStyle="FLAT"), reset = FALSE, main = "endCapStyle: FLAT")
plot(l1,col='blue',add=TRUE)
plot(st_buffer(l1, dist = 1, endCapStyle="SQUARE"), reset = FALSE, main = "endCapStyle: SQUARE")
plot(l1,col='blue',add=TRUE)
plot(st_buffer(l1, dist = 1, nQuadSegs=1), reset = FALSE, main = "nQuadSegs: 1")
plot(l1,col='blue',add=TRUE)
plot(st_buffer(l1, dist = 1, nQuadSegs=2), reset = FALSE, main = "nQuadSegs: 2")
plot(l1,col='blue',add=TRUE)
plot(st_buffer(l1, dist = 1, nQuadSegs= 5), reset = FALSE, main = "nQuadSegs: 5")
plot(l1,col='blue',add=TRUE)
par(op)


l2 = st_as_sfc("LINESTRING(0 0,1 5,3 2)")
op = par(mfrow = c(2, 3))
plot(st_buffer(l2, dist = 1, joinStyle="ROUND"), reset = FALSE, main = "joinStyle: ROUND")
plot(l2, col = 'blue', add = TRUE)
plot(st_buffer(l2, dist = 1, joinStyle="MITRE"), reset = FALSE, main = "joinStyle: MITRE")
plot(l2, col= 'blue', add = TRUE)
plot(st_buffer(l2, dist = 1, joinStyle="BEVEL"), reset = FALSE, main = "joinStyle: BEVEL")
plot(l2, col= 'blue', add=TRUE)
plot(st_buffer(l2, dist = 1, joinStyle="MITRE" , mitreLimit=0.5), reset = FALSE,
   main = "mitreLimit: 0.5")
plot(l2, col = 'blue', add = TRUE)
plot(st_buffer(l2, dist = 1, joinStyle="MITRE",mitreLimit=1), reset = FALSE,
   main = "mitreLimit: 1")
plot(l2, col = 'blue', add = TRUE)
plot(st_buffer(l2, dist = 1, joinStyle="MITRE",mitreLimit=3), reset = FALSE,
   main = "mitreLimit: 3")
plot(l2, col = 'blue', add = TRUE)
par(op)
nc = st_read(system.file("shape/nc.shp", package="sf"))
nc_g = st_geometry(nc)
plot(st_convex_hull(nc_g))
plot(nc_g, border = grey(.5), add = TRUE)
pt = st_combine(st_sfc(st_point(c(0,80)), st_point(c(120,80)), st_point(c(240,80))))
st_convex_hull(pt) # R2
st_convex_hull(st_set_crs(pt, 'OGC:CRS84')) # S2
set.seed(131)
if (compareVersion(sf_extSoftVersion()[["GEOS"]], "3.11.0") &gt; -1) {
 pts = cbind(runif(100), runif(100))
 m = st_multipoint(pts)
 co = sf:::st_concave_hull(m, 0.3)
 coh = sf:::st_concave_hull(m, 0.3, allow_holes = TRUE)
 plot(co, col = 'grey')
 plot(coh, add = TRUE, border = 'red')
 plot(m, add = TRUE)
}

# st_simplify examples:
op = par(mfrow = c(2, 3), mar = rep(0, 4))
plot(nc_g[1])
plot(st_simplify(nc_g[1], dTolerance = 1e3)) # 1000m
plot(st_simplify(nc_g[1], dTolerance = 5e3)) # 5000m
nc_g_planar = st_transform(nc_g, 2264) # planar coordinates, US foot
plot(nc_g_planar[1])
plot(st_simplify(nc_g_planar[1], dTolerance = 1e3)) # 1000 foot
plot(st_simplify(nc_g_planar[1], dTolerance = 5e3)) # 5000 foot
par(op)

if (compareVersion(sf_extSoftVersion()[["GEOS"]], "3.10.0") &gt; -1) {
 pts = rbind(c(0,0), c(1,0), c(1,1), c(.5,.5), c(0,1), c(0,0))
 po = st_polygon(list(pts))
 co = st_triangulate_constrained(po)
 tr = st_triangulate(po)
 plot(po, col = NA, border = 'grey', lwd = 15)
 plot(tr, border = 'green', col = NA, lwd = 5, add = TRUE)
 plot(co, border = 'red', col = 'NA', add = TRUE)
}
if (compareVersion(sf_extSoftVersion()[["GEOS"]], "3.9.0") &gt; -1) {
  nc_t = st_transform(nc, 'EPSG:2264')
  x = st_inscribed_circle(st_geometry(nc_t))
  plot(st_geometry(nc_t), asp = 1, col = grey(.9))
  plot(x, add = TRUE, col = '#ff9999')
}
set.seed(1)
x = st_multipoint(matrix(runif(10),,2))
box = st_polygon(list(rbind(c(0,0),c(1,0),c(1,1),c(0,1),c(0,0))))
if (compareVersion(sf_extSoftVersion()[["GEOS"]], "3.5.0") &gt; -1) {
 v = st_sfc(st_voronoi(x, st_sfc(box)))
 plot(v, col = 0, border = 1, axes = TRUE)
 plot(box, add = TRUE, col = 0, border = 1) # a larger box is returned, as documented
 plot(x, add = TRUE, col = 'red', cex=2, pch=16)
 plot(st_intersection(st_cast(v), box)) # clip to smaller box
 plot(x, add = TRUE, col = 'red', cex=2, pch=16)
 # matching Voronoi polygons to data points:
 # https://github.com/r-spatial/sf/issues/1030
 # generate 50 random unif points:
 n = 100
 pts = st_as_sf(data.frame(matrix(runif(n), , 2), id = 1:(n/2)), coords = c("X1", "X2"))
 # compute Voronoi polygons:
 pols = st_collection_extract(st_voronoi(do.call(c, st_geometry(pts))))
 # match them to points:
 pts$pols = pols[unlist(st_intersects(pts, pols))]
 plot(pts["id"], pch = 16) # ID is color
 plot(st_set_geometry(pts, "pols")["id"], xlim = c(0,1), ylim = c(0,1), reset = FALSE)
 plot(st_geometry(pts), add = TRUE)
 layout(matrix(1)) # reset plot layout
}
mls = st_multilinestring(list(matrix(c(0,0,0,1,1,1,0,0),,2,byrow=TRUE)))
st_polygonize(st_sfc(mls))
mls = st_multilinestring(list(rbind(c(0,0), c(1,1)), rbind(c(2,0), c(1,1))))
st_line_merge(st_sfc(mls))
plot(nc_g, axes = TRUE)
plot(st_centroid(nc_g), add = TRUE, pch = 3, col = 'red')
mp = st_combine(st_buffer(st_sfc(lapply(1:3, function(x) st_point(c(x,x)))), 0.2 * 1:3))
plot(mp)
plot(st_centroid(mp), add = TRUE, col = 'red') # centroid of combined geometry
plot(st_centroid(mp, of_largest_polygon = TRUE), add = TRUE, col = 'blue', pch = 3)
plot(nc_g, axes = TRUE)
plot(st_point_on_surface(nc_g), add = TRUE, pch = 3, col = 'red')
if (compareVersion(sf_extSoftVersion()[["GEOS"]], "3.7.0") &gt; -1) {
  st_reverse(st_linestring(rbind(c(1,1), c(2,2), c(3,3))))
}
(l = st_linestring(rbind(c(0,0), c(1,1), c(0,1), c(1,0), c(0,0))))
st_polygonize(st_node(l))
st_node(st_multilinestring(list(rbind(c(0,0), c(1,1), c(0,1), c(1,0), c(0,0)))))
sf = st_sf(a=1, geom=st_sfc(st_linestring(rbind(c(0,0),c(1,1)))), crs = 4326)
if (require(lwgeom, quietly = TRUE)) {
 seg = st_segmentize(sf, units::set_units(100, km))
 seg = st_segmentize(sf, units::set_units(0.01, rad))
 nrow(seg$geom[[1]])
}
</code></pre>

<hr>
<h2 id='interpolate_aw'>Areal-weighted interpolation of polygon data</h2><span id='topic+interpolate_aw'></span><span id='topic+st_interpolate_aw'></span><span id='topic+st_interpolate_aw.sf'></span>

<h3>Description</h3>

<p>Areal-weighted interpolation of polygon data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_interpolate_aw(x, to, extensive, ...)

## S3 method for class 'sf'
st_interpolate_aw(x, to, extensive, ..., keep_NA = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interpolate_aw_+3A_x">x</code></td>
<td>
<p>object of class <code>sf</code>, for which we want to aggregate attributes</p>
</td></tr>
<tr><td><code id="interpolate_aw_+3A_to">to</code></td>
<td>
<p>object of class <code>sf</code> or <code>sfc</code>, with the target geometries</p>
</td></tr>
<tr><td><code id="interpolate_aw_+3A_extensive">extensive</code></td>
<td>
<p>logical; if TRUE, the attribute variables are assumed to be spatially extensive (like population) and the sum is preserved, otherwise, spatially intensive (like population density) and the mean is preserved.</p>
</td></tr>
<tr><td><code id="interpolate_aw_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="interpolate_aw_+3A_keep_na">keep_NA</code></td>
<td>
<p>logical; if <code>TRUE</code>, return all features in <code>to</code>, if <code>FALSE</code> return only those with non-NA values (but with <code>row.names</code> the index corresponding to the feature in <code>to</code>)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>nc = st_read(system.file("shape/nc.shp", package="sf"))
g = st_make_grid(nc, n = c(10, 5))
a1 = st_interpolate_aw(nc["BIR74"], g, extensive = FALSE)
sum(a1$BIR74) / sum(nc$BIR74) # not close to one: property is assumed spatially intensive
a2 = st_interpolate_aw(nc["BIR74"], g, extensive = TRUE)
# verify mass preservation (pycnophylactic) property:
sum(a2$BIR74) / sum(nc$BIR74)
a1$intensive = a1$BIR74
a1$extensive = a2$BIR74
plot(a1[c("intensive", "extensive")], key.pos = 4)
</code></pre>

<hr>
<h2 id='is_driver_available'>Check if driver is available</h2><span id='topic+is_driver_available'></span>

<h3>Description</h3>

<p>Search through the driver table if driver is listed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_driver_available(drv, drivers = st_drivers())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_driver_available_+3A_drv">drv</code></td>
<td>
<p>character. Name of driver</p>
</td></tr>
<tr><td><code id="is_driver_available_+3A_drivers">drivers</code></td>
<td>
<p>data.frame. Table containing driver names and support. Default
is from <code><a href="#topic+st_drivers">st_drivers</a></code></p>
</td></tr>
</table>

<hr>
<h2 id='is_driver_can'>Check if a driver can perform an action</h2><span id='topic+is_driver_can'></span>

<h3>Description</h3>

<p>Search through the driver table to match a driver name with
an action (e.g. <code>"write"</code>) and check if the action is supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_driver_can(drv, drivers = st_drivers(), operation = "write")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_driver_can_+3A_drv">drv</code></td>
<td>
<p>character. Name of driver</p>
</td></tr>
<tr><td><code id="is_driver_can_+3A_drivers">drivers</code></td>
<td>
<p>data.frame. Table containing driver names and support. Default
is from <code><a href="#topic+st_drivers">st_drivers</a></code></p>
</td></tr>
<tr><td><code id="is_driver_can_+3A_operation">operation</code></td>
<td>
<p>character. What action to check</p>
</td></tr>
</table>

<hr>
<h2 id='is_geometry_column'>Check if the columns could be of a coercable type for sf</h2><span id='topic+is_geometry_column'></span>

<h3>Description</h3>

<p>Check if the columns could be of a coercable type for sf
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_geometry_column(con, x, classes = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_geometry_column_+3A_con">con</code></td>
<td>
<p>database connection</p>
</td></tr>
<tr><td><code id="is_geometry_column_+3A_x">x</code></td>
<td>
<p>inherits data.frame</p>
</td></tr>
<tr><td><code id="is_geometry_column_+3A_classes">classes</code></td>
<td>
<p>classes inherited</p>
</td></tr>
</table>

<hr>
<h2 id='merge.sf'>merge method for sf and data.frame object</h2><span id='topic+merge.sf'></span>

<h3>Description</h3>

<p>merge method for sf and data.frame object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sf'
merge(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge.sf_+3A_x">x</code></td>
<td>
<p>object of class <code>sf</code></p>
</td></tr>
<tr><td><code id="merge.sf_+3A_y">y</code></td>
<td>
<p>object of class <code>data.frame</code></p>
</td></tr>
<tr><td><code id="merge.sf_+3A_...">...</code></td>
<td>
<p>arguments passed on to <code>merge.data.frame</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>a = data.frame(a = 1:3, b = 5:7)
st_geometry(a) = st_sfc(st_point(c(0,0)), st_point(c(1,1)), st_point(c(2,2)))
b = data.frame(x = c("a", "b", "c"), b = c(2,5,6))
merge(a, b)
merge(a, b, all = TRUE)
</code></pre>

<hr>
<h2 id='nc'>North Carolina SIDS data</h2><span id='topic+nc'></span>

<h3>Description</h3>

<p>Sudden Infant Death Syndrome (SIDS) sample data for North Carolina counties,
two time periods (1974-78 and 1979-84). The details of the columns can be
found in a <a href="https://r-spatial.github.io/spdep/articles/sids.html">spdep package vignette</a>.
Please note that, though this is basically the same as <code>nc.sids</code> dataset in spData
package, <code>nc</code> only contains a subset of variables. The differences are
also discussed on the vignette.
</p>


<h3>Format</h3>

<p>A <code>sf</code> object
</p>


<h3>See Also</h3>

<p><a href="https://r-spatial.github.io/spdep/articles/sids.html">https://r-spatial.github.io/spdep/articles/sids.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
nc &lt;- st_read(system.file("shape/nc.shp", package="sf"))

</code></pre>

<hr>
<h2 id='Ops'>Arithmetic operators for simple feature geometries</h2><span id='topic+Ops'></span><span id='topic+Ops.sfg'></span><span id='topic+Ops.sfc'></span>

<h3>Description</h3>

<p>Arithmetic operators for simple feature geometries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sfg'
Ops(e1, e2)

## S3 method for class 'sfc'
Ops(e1, e2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ops_+3A_e1">e1</code></td>
<td>
<p>object of class <code>sfg</code> or <code>sfc</code></p>
</td></tr>
<tr><td><code id="Ops_+3A_e2">e2</code></td>
<td>
<p>numeric, or object of class <code>sfg</code>; in case <code>e1</code> is of class <code>sfc</code> also an object of class <code>sfc</code> is allowed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>in case <code>e2</code> is numeric, +, -, *, /, %% and %/% add, subtract, multiply, divide, modulo, or integer-divide by <code>e2</code>. In case <code>e2</code> is an n x n matrix, * matrix-multiplies and / multiplies by its inverse. If <code>e2</code> is an <code>sfg</code> object, |, /, &amp; and %/% result in the geometric union, difference, intersection and symmetric difference respectively, and <code>==</code> and <code>!=</code> return geometric (in)equality, using <a href="#topic+st_equals">st_equals</a>. If <code>e2</code> is an <code>sfg</code> or <code>sfc</code> object, for operations <code>+</code> and <code>-</code> it has to have <code>POINT</code> geometries.
</p>
<p>If <code>e1</code> is of class <code>sfc</code>, and <code>e2</code> is a length 2 numeric, then it is considered a two-dimensional point (and if needed repeated as such) only for operations <code>+</code> and <code>-</code>, in other cases the individual numbers are repeated; see commented examples.
</p>
<p>It has been reported (https://github.com/r-spatial/sf/issues/2067) that
certain ATLAS versions result in invalid polygons, where the final point
in a ring is no longer equal to the first point. In that case, setting
the precisions with <a href="#topic+st_set_precision">st_set_precision</a> may help.
</p>


<h3>Value</h3>

<p>object of class <code>sfg</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>st_point(c(1,2,3)) + 4
st_point(c(1,2,3)) * 3 + 4
m = matrix(0, 2, 2)
diag(m) = c(1, 3)
# affine:
st_point(c(1,2)) * m + c(2,5)
# world in 0-360 range:
if (require(maps, quietly = TRUE)) {
 w = st_as_sf(map('world', plot = FALSE, fill = TRUE))
 w2 = (st_geometry(w) + c(360,90)) %% c(360) - c(0,90)
 w3 = st_wrap_dateline(st_set_crs(w2 - c(180,0), 4326)) + c(180,0)
 plot(st_set_crs(w3, 4326), axes = TRUE)
}
(mp &lt;- st_point(c(1,2)) + st_point(c(3,4))) # MULTIPOINT (1 2, 3 4)
mp - st_point(c(3,4)) # POINT (1 2)
opar = par(mfrow = c(2,2), mar = c(0, 0, 1, 0))
a = st_buffer(st_point(c(0,0)), 2)
b = a + c(2, 0)
p = function(m) { plot(c(a,b)); plot(eval(parse(text=m)), col=grey(.9), add = TRUE); title(m) }
o = lapply(c('a | b', 'a / b', 'a &amp; b', 'a %/% b'), p)
par(opar)
sfc = st_sfc(st_point(0:1), st_point(2:3))
sfc + c(2,3) # added to EACH geometry
sfc * c(2,3) # first geometry multiplied by 2, second by 3
nc = st_transform(st_read(system.file("gpkg/nc.gpkg", package="sf")), 32119) # nc state plane, m
b = st_buffer(st_centroid(st_union(nc)), units::set_units(50, km)) # shoot a hole in nc:
plot(st_geometry(nc) / b, col = grey(.9))
</code></pre>

<hr>
<h2 id='plot'>plot sf object</h2><span id='topic+plot'></span><span id='topic+plot.sf'></span><span id='topic+get_key_pos'></span><span id='topic+plot.sfc_POINT'></span><span id='topic+plot.sfc_MULTIPOINT'></span><span id='topic+plot.sfc_LINESTRING'></span><span id='topic+plot.sfc_CIRCULARSTRING'></span><span id='topic+plot.sfc_MULTILINESTRING'></span><span id='topic+plot.sfc_POLYGON'></span><span id='topic+plot.sfc_MULTIPOLYGON'></span><span id='topic+plot.sfc_GEOMETRYCOLLECTION'></span><span id='topic+plot.sfc_GEOMETRY'></span><span id='topic+plot.sfg'></span><span id='topic+plot_sf'></span><span id='topic+sf.colors'></span>

<h3>Description</h3>

<p>plot one or more attributes of an sf object on a map
Plot sf object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sf'
plot(
  x,
  y,
  ...,
  main,
  pal = NULL,
  nbreaks = 10,
  breaks = "pretty",
  max.plot = getOption("sf_max.plot", default = 9),
  key.pos = get_key_pos(x, ...),
  key.length = 0.618,
  key.width = kw_dflt(x, key.pos),
  reset = TRUE,
  logz = FALSE,
  extent = x,
  xlim = st_bbox(extent)[c(1, 3)],
  ylim = st_bbox(extent)[c(2, 4)],
  compact = FALSE
)

get_key_pos(x, ...)

## S3 method for class 'sfc_POINT'
plot(
  x,
  y,
  ...,
  pch = 1,
  cex = 1,
  col = 1,
  bg = 0,
  lwd = 1,
  lty = 1,
  type = "p",
  add = FALSE
)

## S3 method for class 'sfc_MULTIPOINT'
plot(
  x,
  y,
  ...,
  pch = 1,
  cex = 1,
  col = 1,
  bg = 0,
  lwd = 1,
  lty = 1,
  type = "p",
  add = FALSE
)

## S3 method for class 'sfc_LINESTRING'
plot(x, y, ..., lty = 1, lwd = 1, col = 1, pch = 1, type = "l", add = FALSE)

## S3 method for class 'sfc_CIRCULARSTRING'
plot(x, y, ...)

## S3 method for class 'sfc_MULTILINESTRING'
plot(x, y, ..., lty = 1, lwd = 1, col = 1, pch = 1, type = "l", add = FALSE)

## S3 method for class 'sfc_POLYGON'
plot(
  x,
  y,
  ...,
  lty = 1,
  lwd = 1,
  col = NA,
  cex = 1,
  pch = NA,
  border = 1,
  add = FALSE,
  rule = "evenodd",
  xpd = par("xpd")
)

## S3 method for class 'sfc_MULTIPOLYGON'
plot(
  x,
  y,
  ...,
  lty = 1,
  lwd = 1,
  col = NA,
  border = 1,
  add = FALSE,
  rule = "evenodd",
  xpd = par("xpd")
)

## S3 method for class 'sfc_GEOMETRYCOLLECTION'
plot(
  x,
  y,
  ...,
  pch = 1,
  cex = 1,
  bg = 0,
  lty = 1,
  lwd = 1,
  col = 1,
  border = 1,
  add = FALSE
)

## S3 method for class 'sfc_GEOMETRY'
plot(
  x,
  y,
  ...,
  pch = 1,
  cex = 1,
  bg = 0,
  lty = 1,
  lwd = 1,
  col = ifelse(st_dimension(x) == 2, NA, 1),
  border = 1,
  add = FALSE
)

## S3 method for class 'sfg'
plot(x, ...)

plot_sf(
  x,
  xlim = NULL,
  ylim = NULL,
  asp = NA,
  axes = FALSE,
  bgc = par("bg"),
  ...,
  xaxs,
  yaxs,
  lab,
  setParUsrBB = FALSE,
  bgMap = NULL,
  expandBB = c(0, 0, 0, 0),
  graticule = NA_crs_,
  col_graticule = "grey",
  border,
  extent = x
)

sf.colors(n = 10, cutoff.tails = c(0.35, 0.2), alpha = 1, categorical = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_+3A_x">x</code></td>
<td>
<p>object of class sf</p>
</td></tr>
<tr><td><code id="plot_+3A_y">y</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="plot_+3A_...">...</code></td>
<td>
<p>further specifications, see <a href="#topic+plot_sf">plot_sf</a> and <a href="#topic+plot">plot</a> and details.</p>
</td></tr>
<tr><td><code id="plot_+3A_main">main</code></td>
<td>
<p>title for plot (<code>NULL</code> to remove)</p>
</td></tr>
<tr><td><code id="plot_+3A_pal">pal</code></td>
<td>
<p>palette function, similar to <a href="grDevices.html#topic+rainbow">rainbow</a>, or palette values; if omitted, <code>sf.colors</code> is used</p>
</td></tr>
<tr><td><code id="plot_+3A_nbreaks">nbreaks</code></td>
<td>
<p>number of colors breaks (ignored for <code>factor</code> or <code>character</code> variables)</p>
</td></tr>
<tr><td><code id="plot_+3A_breaks">breaks</code></td>
<td>
<p>either a numeric vector with the actual breaks, or a name of a method accepted by the <code>style</code> argument of <a href="classInt.html#topic+classIntervals">classIntervals</a></p>
</td></tr>
<tr><td><code id="plot_+3A_max.plot">max.plot</code></td>
<td>
<p>integer; lower boundary to maximum number of attributes to plot; the default value (9) can be overridden by setting the global option <code>sf_max.plot</code>, e.g. <code>options(sf_max.plot=2)</code></p>
</td></tr>
<tr><td><code id="plot_+3A_key.pos">key.pos</code></td>
<td>
<p>numeric; side to plot a color key: 1 bottom, 2 left, 3 top, 4 right; set to <code>NULL</code> to omit key completely, 0 to only not plot the key, or -1 to select automatically. If multiple columns are plotted in a single function call by default no key is plotted and every submap is stretched individually; if a key is requested (and <code>col</code> is missing) all maps are colored according to a single key. Auto select depends on plot size, map aspect, and, if set, parameter <code>asp</code>. If it has lenght 2, the second value, ranging from 0 to 1, determines where the key is placed in the available space (default: 0.5, center).</p>
</td></tr>
<tr><td><code id="plot_+3A_key.length">key.length</code></td>
<td>
<p>amount of space reserved for the key along its axis, length of the scale bar</p>
</td></tr>
<tr><td><code id="plot_+3A_key.width">key.width</code></td>
<td>
<p>amount of space reserved for the key (incl. labels), thickness/width of the scale bar</p>
</td></tr>
<tr><td><code id="plot_+3A_reset">reset</code></td>
<td>
<p>logical; if <code>FALSE</code>, keep the plot in a mode that allows adding further map elements; if <code>TRUE</code> restore original mode after plotting <code>sf</code> objects with attributes; see details.</p>
</td></tr>
<tr><td><code id="plot_+3A_logz">logz</code></td>
<td>
<p>logical; if <code>TRUE</code>, use log10-scale for the attribute variable. In that case, <code>breaks</code> and <code>at</code> need to be given as log10-values; see examples.</p>
</td></tr>
<tr><td><code id="plot_+3A_extent">extent</code></td>
<td>
<p>object with an <code>st_bbox</code> method to define plot extent; defaults to <code>x</code></p>
</td></tr>
<tr><td><code id="plot_+3A_xlim">xlim</code></td>
<td>
<p>see <a href="graphics.html#topic+plot.window">plot.window</a></p>
</td></tr>
<tr><td><code id="plot_+3A_ylim">ylim</code></td>
<td>
<p>see <a href="graphics.html#topic+plot.window">plot.window</a></p>
</td></tr>
<tr><td><code id="plot_+3A_compact">compact</code></td>
<td>
<p>logical; compact sub-plots over plotting space?</p>
</td></tr>
<tr><td><code id="plot_+3A_pch">pch</code></td>
<td>
<p>plotting symbol</p>
</td></tr>
<tr><td><code id="plot_+3A_cex">cex</code></td>
<td>
<p>symbol size</p>
</td></tr>
<tr><td><code id="plot_+3A_col">col</code></td>
<td>
<p>color for plotting features; if <code>length(col)</code> does not equal 1 or <code>nrow(x)</code>, a warning is emitted that colors will be recycled. Specifying <code>col</code> suppresses plotting the legend key.</p>
</td></tr>
<tr><td><code id="plot_+3A_bg">bg</code></td>
<td>
<p>symbol background color</p>
</td></tr>
<tr><td><code id="plot_+3A_lwd">lwd</code></td>
<td>
<p>line width</p>
</td></tr>
<tr><td><code id="plot_+3A_lty">lty</code></td>
<td>
<p>line type</p>
</td></tr>
<tr><td><code id="plot_+3A_type">type</code></td>
<td>
<p>plot type: 'p' for points, 'l' for lines, 'b' for both</p>
</td></tr>
<tr><td><code id="plot_+3A_add">add</code></td>
<td>
<p>logical; add to current plot? Note that when using <code>add=TRUE</code>, you may have to set <code>reset=FALSE</code> in the first plot command.</p>
</td></tr>
<tr><td><code id="plot_+3A_border">border</code></td>
<td>
<p>color of polygon border(s); using <code>NA</code> hides them</p>
</td></tr>
<tr><td><code id="plot_+3A_rule">rule</code></td>
<td>
<p>see <a href="graphics.html#topic+polypath">polypath</a>; for <code>winding</code>, exterior ring direction should be opposite that of the holes; with <code>evenodd</code>, plotting is robust against misspecified ring directions</p>
</td></tr>
<tr><td><code id="plot_+3A_xpd">xpd</code></td>
<td>
<p>see <a href="graphics.html#topic+par">par</a>; sets polygon clipping strategy; only implemented for POLYGON and MULTIPOLYGON</p>
</td></tr>
<tr><td><code id="plot_+3A_asp">asp</code></td>
<td>
<p>see below, and see <a href="graphics.html#topic+par">par</a></p>
</td></tr>
<tr><td><code id="plot_+3A_axes">axes</code></td>
<td>
<p>logical; should axes be plotted? (default FALSE)</p>
</td></tr>
<tr><td><code id="plot_+3A_bgc">bgc</code></td>
<td>
<p>background color</p>
</td></tr>
<tr><td><code id="plot_+3A_xaxs">xaxs</code></td>
<td>
<p>see <a href="graphics.html#topic+par">par</a></p>
</td></tr>
<tr><td><code id="plot_+3A_yaxs">yaxs</code></td>
<td>
<p>see <a href="graphics.html#topic+par">par</a></p>
</td></tr>
<tr><td><code id="plot_+3A_lab">lab</code></td>
<td>
<p>see <a href="graphics.html#topic+par">par</a></p>
</td></tr>
<tr><td><code id="plot_+3A_setparusrbb">setParUsrBB</code></td>
<td>
<p>default FALSE; set the <code>par</code> &ldquo;usr&rdquo; bounding box; see below</p>
</td></tr>
<tr><td><code id="plot_+3A_bgmap">bgMap</code></td>
<td>
<p>object of class <code>ggmap</code>, or returned by function <code>RgoogleMaps::GetMap</code></p>
</td></tr>
<tr><td><code id="plot_+3A_expandbb">expandBB</code></td>
<td>
<p>numeric; fractional values to expand the bounding box with,
in each direction (bottom, left, top, right)</p>
</td></tr>
<tr><td><code id="plot_+3A_graticule">graticule</code></td>
<td>
<p>logical, or object of class <code>crs</code> (e.g., <code>st_crs(4326)</code> for a WGS84 graticule), or object created by <a href="#topic+st_graticule">st_graticule</a>; <code>TRUE</code> will give the WGS84 graticule
or object returned by <a href="#topic+st_graticule">st_graticule</a></p>
</td></tr>
<tr><td><code id="plot_+3A_col_graticule">col_graticule</code></td>
<td>
<p>color to used for the graticule (if present)</p>
</td></tr>
<tr><td><code id="plot_+3A_n">n</code></td>
<td>
<p>integer; number of colors</p>
</td></tr>
<tr><td><code id="plot_+3A_cutoff.tails">cutoff.tails</code></td>
<td>
<p>numeric, in <code style="white-space: pre;">&#8288;[0,0.5]&#8288;</code> start and end values</p>
</td></tr>
<tr><td><code id="plot_+3A_alpha">alpha</code></td>
<td>
<p>numeric, in <code style="white-space: pre;">&#8288;[0,1]&#8288;</code>, transparency</p>
</td></tr>
<tr><td><code id="plot_+3A_categorical">categorical</code></td>
<td>
<p>logical; do we want colors for a categorical variable? (see details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plot.sf</code> maximally plots <code>max.plot</code> maps with colors following from attribute columns,
one map per attribute. It uses <code>sf.colors</code> for default colors. For more control over placement of individual maps,
set parameter <code>mfrow</code> with <a href="graphics.html#topic+par">par</a> prior to plotting, and plot single maps one by one; note that this only works
in combination with setting parameters <code>key.pos=NULL</code> (no legend) and <code>reset=FALSE</code>.
</p>
<p><code>plot.sfc</code> plots the geometry, additional parameters can be passed on
to control color, lines or symbols.
</p>
<p>When setting <code>reset</code> to <code>FALSE</code>, the original device parameters are lost, and the device must be reset using <code>dev.off()</code> in order to reset it.
</p>
<p>parameter <code>at</code> can be set to specify where labels are placed along the key; see examples.
</p>
<p>The features are plotted in the order as they apppear in the sf object. See examples for when a different plotting order is wanted.
</p>
<p><code>plot_sf</code> sets up the plotting area, axes, graticule, or webmap background; it
is called by all <code>plot</code> methods before anything is drawn.
</p>
<p>The argument <code>setParUsrBB</code> may be used to pass the logical value <code>TRUE</code> to functions within <code>plot.Spatial</code>. When set to <code>TRUE</code>, par(&ldquo;usr&rdquo;) will be overwritten with <code>c(xlim, ylim)</code>, which defaults to the bounding box of the spatial object. This is only needed in the particular context of graphic output to a specified device with given width and height, to be matched to the spatial object, when using par(&ldquo;xaxs&rdquo;) and par(&ldquo;yaxs&rdquo;) in addition to <code>par(mar=c(0,0,0,0))</code>.
</p>
<p>The default aspect for map plots is 1; if however data are not
projected (coordinates are long/lat), the aspect is by default set to
1/cos(My * pi/180) with My the y coordinate of the middle of the map
(the mean of <code>ylim</code>, which defaults to the y range of bounding box). This
implies an <a href="https://en.wikipedia.org/wiki/Equirectangular_projection">Equirectangular projection</a>.
</p>
<p>non-categorical colors from <code>sf.colors</code> were taken from <a href="sp.html#topic+bpy.colors">bpy.colors</a>, with modified <code>cutoff.tails</code> defaults
If categorical is <code>TRUE</code>, default colors are from <a href="https://colorbrewer2.org/">https://colorbrewer2.org/</a> (if n &lt; 9, Set2, else Set3).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nc = st_read(system.file("gpkg/nc.gpkg", package="sf"), quiet = TRUE)
# plot single attribute, auto-legend:
plot(nc["SID74"])
# plot multiple:
plot(nc[c("SID74", "SID79")]) # better use ggplot2::geom_sf to facet and get a single legend!
# adding to a plot of an sf object only works when using reset=FALSE in the first plot:
plot(nc["SID74"], reset = FALSE)
plot(st_centroid(st_geometry(nc)), add = TRUE)
# log10 z-scale:
plot(nc["SID74"], logz = TRUE, breaks = c(0,.5,1,1.5,2), at = c(0,.5,1,1.5,2))
# and we need to reset the plotting device after that, e.g. by
layout(1)
# when plotting only geometries, the reset=FALSE is not needed:
plot(st_geometry(nc))
plot(st_geometry(nc)[1], col = 'red', add = TRUE)
# add a custom legend to an arbitray plot:
layout(matrix(1:2, ncol = 2), widths = c(1, lcm(2)))
plot(1)
.image_scale(1:10, col = sf.colors(9), key.length = lcm(8), key.pos = 4, at = 1:10)
# manipulate plotting order, plot largest polygons first:
p = st_polygon(list(rbind(c(0,0), c(1,0), c(1,1), c(0,1), c(0,0))))
x = st_sf(a=1:4, st_sfc(p, p * 2, p * 3, p * 4)) # plot(x, col=2:5) only shows the largest polygon!
plot(x[order(st_area(x), decreasing = TRUE),], col = 2:5) # plot largest polygons first

sf.colors(10)
</code></pre>

<hr>
<h2 id='prefix_map'>Map prefix to driver</h2><span id='topic+prefix_map'></span>

<h3>Description</h3>

<p>Map prefix to driver
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prefix_map
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 10.
</p>

<hr>
<h2 id='proj_tools'>Manage PROJ settings</h2><span id='topic+proj_tools'></span><span id='topic+sf_proj_search_paths'></span><span id='topic+sf_proj_network'></span><span id='topic+sf_proj_pipelines'></span>

<h3>Description</h3>

<p>Query or manage PROJ search path and network settings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf_proj_search_paths(paths = character(0), with_proj = NA)

sf_proj_network(enable = FALSE, url = character(0))

sf_proj_pipelines(
  source_crs,
  target_crs,
  authority = character(0),
  AOI = numeric(0),
  Use = "NONE",
  grid_availability = "USED",
  desired_accuracy = -1,
  strict_containment = FALSE,
  axis_order_authority_compliant = st_axis_order()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="proj_tools_+3A_paths">paths</code></td>
<td>
<p>the search path to be set; omit if paths need to be queried</p>
</td></tr>
<tr><td><code id="proj_tools_+3A_with_proj">with_proj</code></td>
<td>
<p>logical; if <code>NA</code> set for both GDAL and PROJ, otherwise set either for PROJ (<code>TRUE</code>) or GDAL (<code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="proj_tools_+3A_enable">enable</code></td>
<td>
<p>logical; set this to enable (<code>TRUE</code>) or disable (<code>FALSE</code>) the proj network search facility</p>
</td></tr>
<tr><td><code id="proj_tools_+3A_url">url</code></td>
<td>
<p>character; use this to specify and override the default proj network CDN</p>
</td></tr>
<tr><td><code id="proj_tools_+3A_source_crs">source_crs</code>, <code id="proj_tools_+3A_target_crs">target_crs</code></td>
<td>
<p>object of class <code>crs</code> or character</p>
</td></tr>
<tr><td><code id="proj_tools_+3A_authority">authority</code></td>
<td>
<p>character; constrain output pipelines to those of authority</p>
</td></tr>
<tr><td><code id="proj_tools_+3A_aoi">AOI</code></td>
<td>
<p>length four numeric; desired area of interest for the resulting
coordinate transformations (west, south, east, north, in degrees).
For an area of interest crossing the anti-meridian, west will be greater than east.</p>
</td></tr>
<tr><td><code id="proj_tools_+3A_use">Use</code></td>
<td>
<p>one of &quot;NONE&quot;, &quot;BOTH&quot;, &quot;INTERSECTION&quot;, &quot;SMALLEST&quot;, indicating how AOI's
of source_crs and target_crs are being used</p>
</td></tr>
<tr><td><code id="proj_tools_+3A_grid_availability">grid_availability</code></td>
<td>
<p>character; one of &quot;USED&quot; (Grid availability is only used for sorting
results. Operations where some grids are missing will be sorted last), &quot;DISCARD&quot;
(Completely discard an operation if a required grid is missing)
, &quot;IGNORED&quot; (Ignore grid availability at all. Results will be presented as if all grids were
available.), or &quot;AVAILABLE&quot; (Results will be presented as if grids known to PROJ (that is
registered in the grid_alternatives table of its database) were available. Used typically when
networking is enabled.)</p>
</td></tr>
<tr><td><code id="proj_tools_+3A_desired_accuracy">desired_accuracy</code></td>
<td>
<p>numeric; only return pipelines with at least this accuracy</p>
</td></tr>
<tr><td><code id="proj_tools_+3A_strict_containment">strict_containment</code></td>
<td>
<p>logical; default <code>FALSE</code>; permit partial matching of the area
of interest; if <code>TRUE</code> strictly contain the area of interest.
The area of interest is either as given in AOI, or as implied by the
source/target coordinate reference systems</p>
</td></tr>
<tr><td><code id="proj_tools_+3A_axis_order_authority_compliant">axis_order_authority_compliant</code></td>
<td>
<p>logical; if <code>FALSE</code> always
choose âxâ or longitude for the first
axis; if TRUE, follow the axis orders given by the coordinate reference systems when
constructing the for the first axis; if <code>FALSE</code>, follow the axis orders given by</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>sf_proj_search_paths()</code> returns the search path (possibly after setting it)
</p>
<p><code>sf_proj_network</code> when called without arguments returns a logical indicating whether
network search of datum grids is enabled, when called with arguments it returns a character
vector with the URL of the CDN used (or specified with <code>url</code>).
</p>
<p><code>sf_proj_pipelines()</code> returns a table with candidate coordinate transformation
pipelines along with their accuracy; <code>NA</code> accuracy indicates ballpark accuracy.
</p>

<hr>
<h2 id='rawToHex'>Convert raw vector(s) into hexadecimal character string(s)</h2><span id='topic+rawToHex'></span>

<h3>Description</h3>

<p>Convert raw vector(s) into hexadecimal character string(s)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rawToHex(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rawToHex_+3A_x">x</code></td>
<td>
<p>raw vector, or list with raw vectors</p>
</td></tr>
</table>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>magrittr</dt><dd><p><code><a href="magrittr.html#topic+pipe">%&gt;%</a></code></p>
</dd>
</dl>

<hr>
<h2 id='s2'>functions for spherical geometry, using s2 package</h2><span id='topic+s2'></span><span id='topic+sf_use_s2'></span><span id='topic+st_as_s2'></span><span id='topic+st_as_s2.sf'></span><span id='topic+st_as_s2.sfc'></span>

<h3>Description</h3>

<p>functions for spherical geometry, using the s2 package based on the google s2geometry.io library
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf_use_s2(use_s2)

st_as_s2(x, ...)

## S3 method for class 'sf'
st_as_s2(x, ...)

## S3 method for class 'sfc'
st_as_s2(x, ..., oriented = getOption("s2_oriented", FALSE), rebuild = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s2_+3A_use_s2">use_s2</code></td>
<td>
<p>logical; if <code>TRUE</code>, use the s2 spherical geometry package
for geographical coordinate operations</p>
</td></tr>
<tr><td><code id="s2_+3A_x">x</code></td>
<td>
<p>object of class <code>sf</code>, <code>sfc</code> or <code>sfg</code></p>
</td></tr>
<tr><td><code id="s2_+3A_...">...</code></td>
<td>
<p>passed on</p>
</td></tr>
<tr><td><code id="s2_+3A_oriented">oriented</code></td>
<td>
<p>logical; if <code>FALSE</code>, polygons that
cover more than half of the globe are inverted; if <code>TRUE</code>, no reversal
takes place and it is assumed that the inside of the polygon is to the
left of the polygon's path.</p>
</td></tr>
<tr><td><code id="s2_+3A_rebuild">rebuild</code></td>
<td>
<p>logical; call <a href="s2.html#topic+s2_rebuild">s2_rebuild</a> on the geometry (think of this as a <code>st_make_valid</code> on the sphere)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>st_as_s2</code> converts an <code>sf</code> POLYGON object into a form readable by <code>s2</code>.
</p>


<h3>Value</h3>

<p><code>sf_use_s2</code> returns the value of this variable before (re)setting it,
invisibly if <code>use_s2</code> is not missing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m = rbind(c(-1,-1), c(1,-1), c(1,1), c(-1,1), c(-1,-1))
m1 = rbind(c(-1,-1), c(1,-1), c(1,1), c(-1,1), c(-1,0), c(-1,-1))
m0 = m[5:1,]
mp = st_multipolygon(list(
list(m, 0.8 * m0, 0.01 * m1 + 0.9),
list(0.7* m, 0.6*m0),
list(0.5 * m0),
list(m+2),
list(m+4,(.9*m0)+4)
))
sf = st_sfc(mp, mp, crs = 'EPSG:4326')
s2 = st_as_s2(sf)
</code></pre>

<hr>
<h2 id='sf'>Create sf object</h2><span id='topic+sf'></span><span id='topic+st_sf'></span><span id='topic++5B.sf'></span><span id='topic+print.sf'></span>

<h3>Description</h3>

<p>Create sf, which extends data.frame-like objects with a simple feature list column.
To convert a data frame object to <code>sf</code>, use <code><a href="#topic+st_as_sf">st_as_sf()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_sf(
  ...,
  agr = NA_agr_,
  row.names,
  stringsAsFactors = sf_stringsAsFactors(),
  crs,
  precision,
  sf_column_name = NULL,
  check_ring_dir = FALSE,
  sfc_last = TRUE
)

## S3 method for class 'sf'
x[i, j, ..., drop = FALSE, op = st_intersects]

## S3 method for class 'sf'
print(x, ..., n = getOption("sf_max_print", default = 10))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sf_+3A_...">...</code></td>
<td>
<p>column elements to be binded into an <code>sf</code> object or a single <code>list</code> or <code>data.frame</code> with such columns; at least one of these columns shall be a geometry list-column of class <code>sfc</code> or be a list-column that can be converted into an <code>sfc</code> by <a href="#topic+st_as_sfc">st_as_sfc</a>.</p>
</td></tr>
<tr><td><code id="sf_+3A_agr">agr</code></td>
<td>
<p>character vector; see details below.</p>
</td></tr>
<tr><td><code id="sf_+3A_row.names">row.names</code></td>
<td>
<p>row.names for the created <code>sf</code> object</p>
</td></tr>
<tr><td><code id="sf_+3A_stringsasfactors">stringsAsFactors</code></td>
<td>
<p>logical; see <a href="#topic+st_read">st_read</a></p>
</td></tr>
<tr><td><code id="sf_+3A_crs">crs</code></td>
<td>
<p>coordinate reference system, something suitable as input to <a href="#topic+st_crs">st_crs</a></p>
</td></tr>
<tr><td><code id="sf_+3A_precision">precision</code></td>
<td>
<p>numeric; see <a href="#topic+st_as_binary">st_as_binary</a></p>
</td></tr>
<tr><td><code id="sf_+3A_sf_column_name">sf_column_name</code></td>
<td>
<p>character; name of the active list-column with simple feature geometries; in case
there is more than one and <code>sf_column_name</code> is <code>NULL</code>, the first one is taken.</p>
</td></tr>
<tr><td><code id="sf_+3A_check_ring_dir">check_ring_dir</code></td>
<td>
<p>see <a href="#topic+st_read">st_read</a></p>
</td></tr>
<tr><td><code id="sf_+3A_sfc_last">sfc_last</code></td>
<td>
<p>logical; if <code>TRUE</code>, <code>sfc</code> columns are always put last, otherwise column order is left unmodified.</p>
</td></tr>
<tr><td><code id="sf_+3A_x">x</code></td>
<td>
<p>object of class <code>sf</code></p>
</td></tr>
<tr><td><code id="sf_+3A_i">i</code></td>
<td>
<p>record selection, see <a href="base.html#topic++5B.data.frame">[.data.frame</a>, or a <code>sf</code> object to work with the <code>op</code> argument</p>
</td></tr>
<tr><td><code id="sf_+3A_j">j</code></td>
<td>
<p>variable selection, see <a href="base.html#topic++5B.data.frame">[.data.frame</a></p>
</td></tr>
<tr><td><code id="sf_+3A_drop">drop</code></td>
<td>
<p>logical, default <code>FALSE</code>; if <code>TRUE</code> drop the geometry column and return a <code>data.frame</code>, else make the geometry sticky and return a <code>sf</code> object.</p>
</td></tr>
<tr><td><code id="sf_+3A_op">op</code></td>
<td>
<p>function; geometrical binary predicate function to apply when <code>i</code> is a simple feature object</p>
</td></tr>
<tr><td><code id="sf_+3A_n">n</code></td>
<td>
<p>maximum number of features to print; can be set globally by <code>options(sf_max_print=...)</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>agr</code>, attribute-geometry-relationship, specifies for each non-geometry attribute column how it relates to the geometry, and can have one of following values: &quot;constant&quot;, &quot;aggregate&quot;, &quot;identity&quot;. &quot;constant&quot; is used for attributes that are constant throughout the geometry (e.g. land use), &quot;aggregate&quot; where the attribute is an aggregate value over the geometry (e.g. population density or population count), &quot;identity&quot; when the attributes uniquely identifies the geometry of particular &quot;thing&quot;, such as a building ID or a city name. The default value, <code>NA_agr_</code>, implies we don't know.
</p>
<p>When a single value is provided to <code>agr</code>, it is cascaded across all input columns; otherwise, a named vector like <code>c(feature1='constant', ...)</code> will set <code>agr</code> value to <code>'constant'</code> for the input column named <code>feature1</code>. See <code>demo(nc)</code> for a worked example of this.
</p>
<p>When confronted with a data.frame-like object, <code>st_sf</code> will try to find a geometry column of class <code>sfc</code>, and otherwise try to convert list-columns when available into a geometry column, using <a href="#topic+st_as_sfc">st_as_sfc</a>.
</p>
<p><code>[.sf</code> will return a <code>data.frame</code> or vector if the geometry column (of class <code>sfc</code>) is dropped (<code>drop=TRUE</code>), an <code>sfc</code> object if only the geometry column is selected, and otherwise return an <code>sf</code> object; see also <a href="base.html#topic++5B.data.frame">[.data.frame</a>; for <code>[.sf</code> <code>...</code> arguments are passed to <code>op</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g = st_sfc(st_point(1:2))
st_sf(a=3,g)
st_sf(g, a=3)
st_sf(a=3, st_sfc(st_point(1:2))) # better to name it!
# create empty structure with preallocated empty geometries:
nrows &lt;- 10
geometry = st_sfc(lapply(1:nrows, function(x) st_geometrycollection()))
df &lt;- st_sf(id = 1:nrows, geometry = geometry)
g = st_sfc(st_point(1:2), st_point(3:4))
s = st_sf(a=3:4, g)
s[1,]
class(s[1,])
s[,1]
class(s[,1])
s[,2]
class(s[,2])
g = st_sf(a=2:3, g)
pol = st_sfc(st_polygon(list(cbind(c(0,3,3,0,0),c(0,0,3,3,0)))))
h = st_sf(r = 5, pol)
g[h,]
h[g,]
</code></pre>

<hr>
<h2 id='sf_extSoftVersion'>Provide the external dependencies versions of the libraries linked to sf</h2><span id='topic+sf_extSoftVersion'></span>

<h3>Description</h3>

<p>Provide the external dependencies versions of the libraries linked to sf
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf_extSoftVersion()
</code></pre>

<hr>
<h2 id='sf_project'>directly transform a set of coordinates</h2><span id='topic+sf_project'></span><span id='topic+sf_add_proj_units'></span>

<h3>Description</h3>

<p>directly transform a set of coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf_add_proj_units()

sf_project(
  from = character(0),
  to = character(0),
  pts,
  keep = FALSE,
  warn = TRUE,
  authority_compliant = st_axis_order()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sf_project_+3A_from">from</code></td>
<td>
<p>character description of source CRS, or object of class <code>crs</code>,
or pipeline describing a transformation</p>
</td></tr>
<tr><td><code id="sf_project_+3A_to">to</code></td>
<td>
<p>character description of target CRS, or object of class <code>crs</code></p>
</td></tr>
<tr><td><code id="sf_project_+3A_pts">pts</code></td>
<td>
<p>two-, three- or four-column numeric matrix, or object that can be coerced into a matrix; columns 3 and 4 contain z and t values.</p>
</td></tr>
<tr><td><code id="sf_project_+3A_keep">keep</code></td>
<td>
<p>logical value controlling the handling of unprojectable points. If
<code>keep</code> is <code>TRUE</code>, then such points will yield <code>Inf</code> or <code>-Inf</code> in the
return value; otherwise an error is reported and nothing is returned.</p>
</td></tr>
<tr><td><code id="sf_project_+3A_warn">warn</code></td>
<td>
<p>logical; if <code>TRUE</code>, warn when non-finite values are generated</p>
</td></tr>
<tr><td><code id="sf_project_+3A_authority_compliant">authority_compliant</code></td>
<td>
<p>logical; <code>TRUE</code> means handle axis order authority compliant (e.g. EPSG:4326 implying x=lat, y=lon), <code>FALSE</code> means use visualisation order (i.e. always x=lon, y=lat)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sf_add_proj_units</code> loads the PROJ units <code>link</code>, <code>us_in</code>, <code>ind_yd</code>, <code>ind_ft</code>, and <code>ind_ch</code> into the udunits database, and returns <code>TRUE</code> invisibly on success.
</p>


<h3>Value</h3>

<p>two-column numeric matrix with transformed/converted coordinates, returning invalid values as <code>Inf</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sf_add_proj_units()
</code></pre>

<hr>
<h2 id='sf-defunct'>Deprecated functions in <code>sf</code></h2><span id='topic+sf-defunct'></span><span id='topic+st_read_db'></span><span id='topic+st_write_db'></span>

<h3>Description</h3>

<p>These functions are provided for compatibility with older version of <code>sf</code>.
They will eventually be completely removed.
</p>

<ul>
<li><p> Use <code><a href="#topic+st_read">st_read()</a></code> instead of <code>st_read_db()</code>.
</p>
</li>
<li><p> Use <code><a href="#topic+st_write">st_write()</a></code> instead_of <code>st_write_db()</code>
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>st_read_db(
  conn = NULL,
  table = NULL,
  query = NULL,
  geom_column = NULL,
  EWKB = TRUE,
  ...
)

st_write_db(
  conn = NULL,
  obj,
  table = deparse(substitute(obj)),
  ...,
  drop = FALSE,
  append = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sf-defunct_+3A_conn">conn</code></td>
<td>
<p>open database connection</p>
</td></tr>
<tr><td><code id="sf-defunct_+3A_table">table</code></td>
<td>
<p>table name</p>
</td></tr>
<tr><td><code id="sf-defunct_+3A_query">query</code></td>
<td>
<p>SQL query to select records; see details</p>
</td></tr>
<tr><td><code id="sf-defunct_+3A_geom_column">geom_column</code></td>
<td>
<p>deprecated. Geometry column name</p>
</td></tr>
<tr><td><code id="sf-defunct_+3A_ewkb">EWKB</code></td>
<td>
<p>logical; is the WKB of type EWKB? if missing, defaults to
<code>TRUE</code></p>
</td></tr>
<tr><td><code id="sf-defunct_+3A_...">...</code></td>
<td>
<p>parameter(s) passed on to <a href="#topic+st_as_sf">st_as_sf</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>geom_column</code> argument is deprecated. The function will
automatically find the <code>geometry</code> type columns. For the <code>RPostgreSQL</code> drivers
it will try to cast all the character columns, which can be long for very wide
tables.
</p>

<hr>
<h2 id='sf-package'>sf: Simple Features for R</h2><span id='topic+sf-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Support for simple features, a standardized way to encode spatial vector data. Binds to 'GDAL' for reading and writing data, to 'GEOS' for geometrical operations, and to 'PROJ' for projection conversions and datum transformations. Uses by default the 's2' package for spherical geometry operations on ellipsoidal (long/lat) coordinates.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Edzer Pebesma <a href="mailto:edzer.pebesma@uni-muenster.de">edzer.pebesma@uni-muenster.de</a> (<a href="https://orcid.org/0000-0001-8049-7069">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Roger Bivand (<a href="https://orcid.org/0000-0003-2392-6140">ORCID</a>) [contributor]
</p>
</li>
<li><p> Etienne Racine [contributor]
</p>
</li>
<li><p> Michael Sumner [contributor]
</p>
</li>
<li><p> Ian Cook [contributor]
</p>
</li>
<li><p> Tim Keitt [contributor]
</p>
</li>
<li><p> Robin Lovelace [contributor]
</p>
</li>
<li><p> Hadley Wickham [contributor]
</p>
</li>
<li><p> Jeroen Ooms (<a href="https://orcid.org/0000-0002-4035-0289">ORCID</a>) [contributor]
</p>
</li>
<li><p> Kirill MÃ¼ller [contributor]
</p>
</li>
<li><p> Thomas Lin Pedersen [contributor]
</p>
</li>
<li><p> Dan Baston [contributor]
</p>
</li>
<li><p> Dewey Dunnington (<a href="https://orcid.org/0000-0002-9415-4582">ORCID</a>) [contributor]
</p>
</li></ul>



<h3>References</h3>

<p>Pebesma, E. and Bivand, R. (2023). Spatial Data
Science: With Applications in R. Chapman and Hall/CRC.
<a href="https://doi.org/10.1201/9780429459016">doi:10.1201/9780429459016</a> which is also found freely
online at <a href="https://r-spatial.org/book/">https://r-spatial.org/book/</a>
</p>
<p>Pebesma, E., 2018. Simple Features for R: Standardized Support
for Spatial Vector Data. The R Journal 10 (1), 439-446,
<a href="https://doi.org/10.32614/RJ-2018-009">doi:10.32614/RJ-2018-009</a> (open access)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://r-spatial.github.io/sf/">https://r-spatial.github.io/sf/</a>
</p>
</li>
<li> <p><a href="https://github.com/r-spatial/sf">https://github.com/r-spatial/sf</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/r-spatial/sf/issues">https://github.com/r-spatial/sf/issues</a>
</p>
</li></ul>


<hr>
<h2 id='sfc'>Create simple feature geometry list column</h2><span id='topic+sfc'></span><span id='topic+st_sfc'></span><span id='topic+sfc_POINT'></span><span id='topic+sfc_LINESTRING'></span><span id='topic+sfc_POLYGON'></span><span id='topic+sfc_MULTIPOINT'></span><span id='topic+sfc_MULTILINESTRING'></span><span id='topic+sfc_MULTIPOLYGON'></span><span id='topic+sfc_GEOMETRYCOLLECTION'></span><span id='topic++5B.sfc'></span>

<h3>Description</h3>

<p>Create simple feature geometry list column, set class, and add coordinate reference system and precision.
For data.frame alternatives see <code><a href="#topic+st_sf">st_sf()</a></code>. To convert a foreign object to <code>sfc</code>, see <code><a href="#topic+st_as_sfc">st_as_sfc()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_sfc(
  ...,
  crs = NA_crs_,
  precision = 0,
  check_ring_dir = FALSE,
  dim,
  recompute_bbox = FALSE
)

## S3 method for class 'sfc'
x[i, j, ..., op = st_intersects]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfc_+3A_...">...</code></td>
<td>
<p>zero or more simple feature geometries (objects of class <code>sfg</code>), or a single list of such objects; <code>NULL</code> values will get replaced by empty geometries.</p>
</td></tr>
<tr><td><code id="sfc_+3A_crs">crs</code></td>
<td>
<p>coordinate reference system: integer with the EPSG code, or character with proj4string</p>
</td></tr>
<tr><td><code id="sfc_+3A_precision">precision</code></td>
<td>
<p>numeric; see <a href="#topic+st_as_binary">st_as_binary</a></p>
</td></tr>
<tr><td><code id="sfc_+3A_check_ring_dir">check_ring_dir</code></td>
<td>
<p>see <a href="#topic+st_read">st_read</a></p>
</td></tr>
<tr><td><code id="sfc_+3A_dim">dim</code></td>
<td>
<p>character; if this function is called without valid geometries, this argument may carry the right dimension to set empty geometries</p>
</td></tr>
<tr><td><code id="sfc_+3A_recompute_bbox">recompute_bbox</code></td>
<td>
<p>logical; use <code>TRUE</code> to force recomputation of the bounding box</p>
</td></tr>
<tr><td><code id="sfc_+3A_x">x</code></td>
<td>
<p>object of class <code>sfc</code></p>
</td></tr>
<tr><td><code id="sfc_+3A_i">i</code></td>
<td>
<p>record selection. Might also be an <code>sfc</code>/<code>sf</code> object to work with the <code>op</code> argument</p>
</td></tr>
<tr><td><code id="sfc_+3A_j">j</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="sfc_+3A_op">op</code></td>
<td>
<p>function, geometrical binary predicate function to apply when
<code>i</code> is a <code>sf</code>/<code>sfc</code> object. Additional arguments can be
specified using <code>...</code>, see examples.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A simple feature geometry list-column is a list of class
<code>c("stc_TYPE", "sfc")</code> which most often contains objects of identical type;
in case of a mix of types or an empty set, <code>TYPE</code> is set to the
superclass <code>GEOMETRY</code>.
</p>


<h3>Value</h3>

<p>an object of class <code>sfc</code>, which is a classed list-column with simple feature geometries.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pt1 = st_point(c(0,1))
pt2 = st_point(c(1,1))
(sfc = st_sfc(pt1, pt2))
sfc[sfc[1], op = st_is_within_distance, dist = 0.5]
d = st_sf(data.frame(a=1:2, geom=sfc))
</code></pre>

<hr>
<h2 id='sgbp'>Methods for dealing with sparse geometry binary predicate lists</h2><span id='topic+sgbp'></span><span id='topic+print.sgbp'></span><span id='topic+t.sgbp'></span><span id='topic+as.matrix.sgbp'></span><span id='topic+dim.sgbp'></span>

<h3>Description</h3>

<p>Methods for dealing with sparse geometry binary predicate lists
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sgbp'
print(x, ..., n = 10, max_nb = 10)

## S3 method for class 'sgbp'
t(x)

## S3 method for class 'sgbp'
as.matrix(x, ...)

## S3 method for class 'sgbp'
dim(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sgbp_+3A_x">x</code></td>
<td>
<p>object of class <code>sgbp</code></p>
</td></tr>
<tr><td><code id="sgbp_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="sgbp_+3A_n">n</code></td>
<td>
<p>integer; maximum number of items to print</p>
</td></tr>
<tr><td><code id="sgbp_+3A_max_nb">max_nb</code></td>
<td>
<p>integer; maximum number of neighbours to print for each item</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sgbp</code> are sparse matrices, stored as a list with integer vectors holding the ordered <code>TRUE</code> indices of each row. This means that for a dense, <code class="reqn">m \times n</code> matrix <code>Q</code> and a list <code>L</code>, if <code>Q[i,j]</code> is <code>TRUE</code> then <code class="reqn">j</code> is an element of <code>L[[i]]</code>. Reversed: when <code class="reqn">k</code> is the value of <code>L[[i]][j]</code>, then <code>Q[i,k]</code> is <code>TRUE</code>.
</p>

<hr>
<h2 id='st'>Create simple feature from a numeric vector, matrix or list</h2><span id='topic+st'></span><span id='topic+st_point'></span><span id='topic+st_multipoint'></span><span id='topic+st_linestring'></span><span id='topic+st_polygon'></span><span id='topic+st_multilinestring'></span><span id='topic+st_multipolygon'></span><span id='topic+st_geometrycollection'></span><span id='topic+print.sfg'></span><span id='topic+head.sfg'></span><span id='topic+format.sfg'></span><span id='topic+c.sfg'></span><span id='topic+as.matrix.sfg'></span>

<h3>Description</h3>

<p>Create simple feature from a numeric vector, matrix or list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_point(x = c(NA_real_, NA_real_), dim = "XYZ")

st_multipoint(x = matrix(numeric(0), 0, 2), dim = "XYZ")

st_linestring(x = matrix(numeric(0), 0, 2), dim = "XYZ")

st_polygon(x = list(), dim = if (length(x)) "XYZ" else "XY")

st_multilinestring(x = list(), dim = if (length(x)) "XYZ" else "XY")

st_multipolygon(x = list(), dim = if (length(x)) "XYZ" else "XY")

st_geometrycollection(x = list(), dims = "XY")

## S3 method for class 'sfg'
print(x, ..., width = 0)

## S3 method for class 'sfg'
head(x, n = 10L, ...)

## S3 method for class 'sfg'
format(x, ..., width = 30)

## S3 method for class 'sfg'
c(..., recursive = FALSE, flatten = TRUE)

## S3 method for class 'sfg'
as.matrix(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_+3A_x">x</code></td>
<td>
<p>for <code>st_point</code>, numeric vector (or one-row-matrix) of length 2, 3 or 4; for <code>st_linestring</code> and <code>st_multipoint</code>, numeric matrix with points in rows; for <code>st_polygon</code> and <code>st_multilinestring</code>, list with numeric matrices with points in rows; for <code>st_multipolygon</code>, list of lists with numeric matrices; for <code>st_geometrycollection</code> list with (non-geometrycollection) simple feature geometry (sfg) objects; see examples below</p>
</td></tr>
<tr><td><code id="st_+3A_dim">dim</code></td>
<td>
<p>character, indicating dimensions: &quot;XY&quot;, &quot;XYZ&quot;, &quot;XYM&quot;, or &quot;XYZM&quot;; only really needed for three-dimensional points (which can be either XYZ or XYM) or empty geometries; see details</p>
</td></tr>
<tr><td><code id="st_+3A_dims">dims</code></td>
<td>
<p>character; specify dimensionality in case of an empty (NULL) geometrycollection, in which case <code>x</code> is the empty <code>list()</code>.</p>
</td></tr>
<tr><td><code id="st_+3A_...">...</code></td>
<td>
<p>objects to be pasted together into a single simple feature</p>
</td></tr>
<tr><td><code id="st_+3A_width">width</code></td>
<td>
<p>integer; number of characters to be printed (max 30; 0 means print everything)</p>
</td></tr>
<tr><td><code id="st_+3A_n">n</code></td>
<td>
<p>integer; number of elements to be selected</p>
</td></tr>
<tr><td><code id="st_+3A_recursive">recursive</code></td>
<td>
<p>logical; ignored</p>
</td></tr>
<tr><td><code id="st_+3A_flatten">flatten</code></td>
<td>
<p>logical; if <code>TRUE</code>, try to simplify results; if <code>FALSE</code>, return geometrycollection containing all objects</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&quot;XYZ&quot; refers to coordinates where the third dimension represents altitude, &quot;XYM&quot; refers to three-dimensional coordinates where the third dimension refers to something else (&quot;M&quot; for measure); checking of the sanity of <code>x</code> may be only partial.
</p>
<p>When <code>flatten=TRUE</code>, this method may merge points into a multipoint structure, and may not preserve order, and hence cannot be reverted. When given fish, it returns fish soup.
</p>


<h3>Value</h3>

<p>object of the same nature as <code>x</code>, but with appropriate class attribute set
</p>
<p>as.matrix returns the set of points that form a geometry as a single matrix, where each point is a row; use <code>unlist(x, recursive = FALSE)</code> to get sets of matrices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(p1 = st_point(c(1,2)))
class(p1)
st_bbox(p1)
(p2 = st_point(c(1,2,3)))
class(p2)
(p3 = st_point(c(1,2,3), "XYM"))
pts = matrix(1:10, , 2)
(mp1 = st_multipoint(pts))
pts = matrix(1:15, , 3)
(mp2 = st_multipoint(pts))
(mp3 = st_multipoint(pts, "XYM"))
pts = matrix(1:20, , 4)
(mp4 = st_multipoint(pts))
pts = matrix(1:10, , 2)
(ls1 = st_linestring(pts))
pts = matrix(1:15, , 3)
(ls2 = st_linestring(pts))
(ls3 = st_linestring(pts, "XYM"))
pts = matrix(1:20, , 4)
(ls4 = st_linestring(pts))
outer = matrix(c(0,0,10,0,10,10,0,10,0,0),ncol=2, byrow=TRUE)
hole1 = matrix(c(1,1,1,2,2,2,2,1,1,1),ncol=2, byrow=TRUE)
hole2 = matrix(c(5,5,5,6,6,6,6,5,5,5),ncol=2, byrow=TRUE)
pts = list(outer, hole1, hole2)
(ml1 = st_multilinestring(pts))
pts3 = lapply(pts, function(x) cbind(x, 0))
(ml2 = st_multilinestring(pts3))
(ml3 = st_multilinestring(pts3, "XYM"))
pts4 = lapply(pts3, function(x) cbind(x, 0))
(ml4 = st_multilinestring(pts4))
outer = matrix(c(0,0,10,0,10,10,0,10,0,0),ncol=2, byrow=TRUE)
hole1 = matrix(c(1,1,1,2,2,2,2,1,1,1),ncol=2, byrow=TRUE)
hole2 = matrix(c(5,5,5,6,6,6,6,5,5,5),ncol=2, byrow=TRUE)
pts = list(outer, hole1, hole2)
(pl1 = st_polygon(pts))
pts3 = lapply(pts, function(x) cbind(x, 0))
(pl2 = st_polygon(pts3))
(pl3 = st_polygon(pts3, "XYM"))
pts4 = lapply(pts3, function(x) cbind(x, 0))
(pl4 = st_polygon(pts4))
pol1 = list(outer, hole1, hole2)
pol2 = list(outer + 12, hole1 + 12)
pol3 = list(outer + 24)
mp = list(pol1,pol2,pol3)
(mp1 = st_multipolygon(mp))
pts3 = lapply(mp, function(x) lapply(x, function(y) cbind(y, 0)))
(mp2 = st_multipolygon(pts3))
(mp3 = st_multipolygon(pts3, "XYM"))
pts4 = lapply(mp2, function(x) lapply(x, function(y) cbind(y, 0)))
(mp4 = st_multipolygon(pts4))
(gc = st_geometrycollection(list(p1, ls1, pl1, mp1)))
st_geometrycollection() # empty geometry
c(st_point(1:2), st_point(5:6))
c(st_point(1:2), st_multipoint(matrix(5:8,2)))
c(st_multipoint(matrix(1:4,2)), st_multipoint(matrix(5:8,2)))
c(st_linestring(matrix(1:6,3)), st_linestring(matrix(11:16,3)))
c(st_multilinestring(list(matrix(1:6,3))), st_multilinestring(list(matrix(11:16,3))))
pl = list(rbind(c(0,0), c(1,0), c(1,1), c(0,1), c(0,0)))
c(st_polygon(pl), st_polygon(pl))
c(st_polygon(pl), st_multipolygon(list(pl)))
c(st_linestring(matrix(1:6,3)), st_point(1:2))
c(st_geometrycollection(list(st_point(1:2), st_linestring(matrix(1:6,3)))),
  st_geometrycollection(list(st_multilinestring(list(matrix(11:16,3))))))
c(st_geometrycollection(list(st_point(1:2), st_linestring(matrix(1:6,3)))),
  st_multilinestring(list(matrix(11:16,3))), st_point(5:6),
  st_geometrycollection(list(st_point(10:11))))
</code></pre>

<hr>
<h2 id='st_agr'>get or set relation_to_geometry attribute of an <code>sf</code> object</h2><span id='topic+st_agr'></span><span id='topic+NA_agr_'></span><span id='topic+st_agr+3C-'></span><span id='topic+st_set_agr'></span>

<h3>Description</h3>

<p>get or set relation_to_geometry attribute of an <code>sf</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NA_agr_

st_agr(x, ...)

st_agr(x) &lt;- value

st_set_agr(x, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_agr_+3A_x">x</code></td>
<td>
<p>object of class <code>sf</code></p>
</td></tr>
<tr><td><code id="st_agr_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="st_agr_+3A_value">value</code></td>
<td>
<p>character, or factor with appropriate levels; if named, names should correspond to the non-geometry list-column columns of <code>x</code></p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>factor</code> of length 1.
</p>


<h3>Details</h3>

<p><code>NA_agr_</code> is the <code>agr</code> object with a missing value.
</p>

<hr>
<h2 id='st_as_binary'>Convert sfc object to an WKB object</h2><span id='topic+st_as_binary'></span><span id='topic+st_as_binary.sfc'></span><span id='topic+st_as_binary.sfg'></span>

<h3>Description</h3>

<p>Convert sfc object to an WKB object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_as_binary(x, ...)

## S3 method for class 'sfc'
st_as_binary(
  x,
  ...,
  EWKB = FALSE,
  endian = .Platform$endian,
  pureR = FALSE,
  precision = attr(x, "precision"),
  hex = FALSE
)

## S3 method for class 'sfg'
st_as_binary(
  x,
  ...,
  endian = .Platform$endian,
  EWKB = FALSE,
  pureR = FALSE,
  hex = FALSE,
  srid = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_as_binary_+3A_x">x</code></td>
<td>
<p>object to convert</p>
</td></tr>
<tr><td><code id="st_as_binary_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="st_as_binary_+3A_ewkb">EWKB</code></td>
<td>
<p>logical; use EWKB (PostGIS), or (default) ISO-WKB?</p>
</td></tr>
<tr><td><code id="st_as_binary_+3A_endian">endian</code></td>
<td>
<p>character; either &quot;big&quot; or &quot;little&quot;; default: use that of platform</p>
</td></tr>
<tr><td><code id="st_as_binary_+3A_purer">pureR</code></td>
<td>
<p>logical; use pure R solution, or C++?</p>
</td></tr>
<tr><td><code id="st_as_binary_+3A_precision">precision</code></td>
<td>
<p>numeric; if zero, do not modify; to reduce precision: negative values convert to float (4-byte real); positive values convert to round(x*precision)/precision. See details.</p>
</td></tr>
<tr><td><code id="st_as_binary_+3A_hex">hex</code></td>
<td>
<p>logical; return as (unclassed) hexadecimal encoded character vector?</p>
</td></tr>
<tr><td><code id="st_as_binary_+3A_srid">srid</code></td>
<td>
<p>integer; override srid (can be used when the srid is unavailable locally).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>st_as_binary</code> is called on sfc objects on their way to the GDAL or GEOS libraries, and hence does rounding (if requested) on the fly before e.g. computing spatial predicates like <a href="#topic+st_intersects">st_intersects</a>. The examples show a round-trip of an <code>sfc</code> to and from binary.
</p>
<p>For the precision model used, see also <a href="https://locationtech.github.io/jts/javadoc/org/locationtech/jts/geom/PrecisionModel.html">https://locationtech.github.io/jts/javadoc/org/locationtech/jts/geom/PrecisionModel.html</a>. There, it is written that: &ldquo;... to specify 3 decimal places of precision, use a scale factor of 1000. To specify -3 decimal places of precision (i.e. rounding to the nearest 1000), use a scale factor of 0.001.&rdquo;. Note that ALL coordinates, so also Z or M values (if present) are affected.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># examples of setting precision:
st_point(c(1/3, 1/6)) %&gt;% st_sfc(precision = 1000) %&gt;% st_as_binary %&gt;% st_as_sfc
st_point(c(1/3, 1/6)) %&gt;% st_sfc(precision =  100) %&gt;% st_as_binary %&gt;% st_as_sfc
st_point(1e6 * c(1/3, 1/6)) %&gt;% st_sfc(precision = 0.01) %&gt;% st_as_binary %&gt;% st_as_sfc
st_point(1e6 * c(1/3, 1/6)) %&gt;% st_sfc(precision = 0.001) %&gt;% st_as_binary %&gt;% st_as_sfc
</code></pre>

<hr>
<h2 id='st_as_grob'>Convert sf* object to a grob</h2><span id='topic+st_as_grob'></span>

<h3>Description</h3>

<p>Convert sf* object to an grid graphics object (grob)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_as_grob(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_as_grob_+3A_x">x</code></td>
<td>
<p>object to be converted into an object class <code>grob</code></p>
</td></tr>
<tr><td><code id="st_as_grob_+3A_...">...</code></td>
<td>
<p>passed on to the xxxGrob function, e.g. <code>gp = gpar(col = 'red')</code></p>
</td></tr>
</table>

<hr>
<h2 id='st_as_sf'>Convert foreign object to an sf object</h2><span id='topic+st_as_sf'></span><span id='topic+st_as_sf.data.frame'></span><span id='topic+st_as_sf.sf'></span><span id='topic+st_as_sf.sfc'></span><span id='topic+st_as_sf.Spatial'></span><span id='topic+st_as_sf.map'></span><span id='topic+st_as_sf.ppp'></span><span id='topic+st_as_sf.psp'></span><span id='topic+st_as_sf.lpp'></span><span id='topic+st_as_sf.s2_geography'></span>

<h3>Description</h3>

<p>Convert foreign object to an sf object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_as_sf(x, ...)

## S3 method for class 'data.frame'
st_as_sf(
  x,
  ...,
  agr = NA_agr_,
  coords,
  wkt,
  dim = "XYZ",
  remove = TRUE,
  na.fail = TRUE,
  sf_column_name = NULL
)

## S3 method for class 'sf'
st_as_sf(x, ...)

## S3 method for class 'sfc'
st_as_sf(x, ...)

## S3 method for class 'Spatial'
st_as_sf(x, ...)

## S3 method for class 'map'
st_as_sf(x, ..., fill = TRUE, group = TRUE)

## S3 method for class 'ppp'
st_as_sf(x, ...)

## S3 method for class 'psp'
st_as_sf(x, ...)

## S3 method for class 'lpp'
st_as_sf(x, ...)

## S3 method for class 's2_geography'
st_as_sf(x, ..., crs = st_crs(4326))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_as_sf_+3A_x">x</code></td>
<td>
<p>object to be converted into an object class <code>sf</code></p>
</td></tr>
<tr><td><code id="st_as_sf_+3A_...">...</code></td>
<td>
<p>passed on to <a href="#topic+st_sf">st_sf</a>, might included named arguments <code>crs</code> or <code>precision</code></p>
</td></tr>
<tr><td><code id="st_as_sf_+3A_agr">agr</code></td>
<td>
<p>character vector; see details section of <a href="#topic+st_sf">st_sf</a></p>
</td></tr>
<tr><td><code id="st_as_sf_+3A_coords">coords</code></td>
<td>
<p>in case of point data: names or numbers of the numeric columns holding coordinates</p>
</td></tr>
<tr><td><code id="st_as_sf_+3A_wkt">wkt</code></td>
<td>
<p>name or number of the character column that holds WKT encoded geometries</p>
</td></tr>
<tr><td><code id="st_as_sf_+3A_dim">dim</code></td>
<td>
<p>passed on to <a href="#topic+st_point">st_point</a> (only when argument coords is given)</p>
</td></tr>
<tr><td><code id="st_as_sf_+3A_remove">remove</code></td>
<td>
<p>logical; when coords or wkt is given, remove these columns from data.frame?</p>
</td></tr>
<tr><td><code id="st_as_sf_+3A_na.fail">na.fail</code></td>
<td>
<p>logical; if <code>TRUE</code>, raise an error if coordinates contain missing values</p>
</td></tr>
<tr><td><code id="st_as_sf_+3A_sf_column_name">sf_column_name</code></td>
<td>
<p>character; name of the active list-column with simple feature geometries; in case
there is more than one and <code>sf_column_name</code> is <code>NULL</code>, the first one is taken.</p>
</td></tr>
<tr><td><code id="st_as_sf_+3A_fill">fill</code></td>
<td>
<p>logical; the value for <code>fill</code> that was used in the call to <a href="maps.html#topic+map">map</a>.</p>
</td></tr>
<tr><td><code id="st_as_sf_+3A_group">group</code></td>
<td>
<p>logical; if <code>TRUE</code>, group id labels from <a href="maps.html#topic+map">map</a> by their prefix before <code>:</code></p>
</td></tr>
<tr><td><code id="st_as_sf_+3A_crs">crs</code></td>
<td>
<p>coordinate reference system to be assigned; object of class <code>crs</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>setting argument <code>wkt</code> annihilates the use of argument <code>coords</code>. If <code>x</code> contains a column called &quot;geometry&quot;, <code>coords</code> will result in overwriting of this column by the <a href="#topic+sfc">sfc</a> geometry list-column.  Setting <code>wkt</code> will replace this column with the geometry list-column, unless <code>remove</code> is <code>FALSE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pt1 = st_point(c(0,1))
pt2 = st_point(c(1,1))
st_sfc(pt1, pt2)
d = data.frame(a = 1:2)
d$geom = st_sfc(pt1, pt2)
df = st_as_sf(d)
d$geom = c("POINT(0 0)", "POINT(0 1)")
df = st_as_sf(d, wkt = "geom")
d$geom2 = st_sfc(pt1, pt2)
st_as_sf(d) # should warn
if (require(sp, quietly = TRUE)) {
 data(meuse, package = "sp")
 meuse_sf = st_as_sf(meuse, coords = c("x", "y"), crs = 28992, agr = "constant")
 meuse_sf[1:3,]
 summary(meuse_sf)
}
if (require(sp, quietly = TRUE)) {
x = rbind(c(-1,-1), c(1,-1), c(1,1), c(-1,1), c(-1,-1))
x1 = 0.1 * x + 0.1
x2 = 0.1 * x + 0.4
x3 = 0.1 * x + 0.7
y = x + 3
y1 = x1 + 3
y3 = x3 + 3
m = matrix(c(3, 0), 5, 2, byrow = TRUE)
z = x + m
z1 = x1 + m
z2 = x2 + m
z3 = x3 + m
p1 = Polygons(list( Polygon(x[5:1,]), Polygon(x2), Polygon(x3),
   Polygon(y[5:1,]), Polygon(y1), Polygon(x1), Polygon(y3)), "ID1")
p2 = Polygons(list( Polygon(z[5:1,]), Polygon(z2), Polygon(z3), Polygon(z1)),
  "ID2")
r = SpatialPolygons(list(p1,p2))
a = suppressWarnings(st_as_sf(r))
summary(a)
demo(meuse, ask = FALSE, echo = FALSE)
summary(st_as_sf(meuse))
summary(st_as_sf(meuse.grid))
summary(st_as_sf(meuse.area))
summary(st_as_sf(meuse.riv))
summary(st_as_sf(as(meuse.riv, "SpatialLines")))
pol.grd = as(meuse.grid, "SpatialPolygonsDataFrame")
# summary(st_as_sf(pol.grd))
# summary(st_as_sf(as(pol.grd, "SpatialLinesDataFrame")))
}
if (require(spatstat.geom)) {
  g = st_as_sf(gorillas)
  # select only the points:
  g[st_is(g, "POINT"),]
}
if (require(spatstat.linnet)) {
 data(chicago)
 plot(st_as_sf(chicago)["label"])
 plot(st_as_sf(chicago)[-1,"label"])
}
</code></pre>

<hr>
<h2 id='st_as_sfc'>Convert foreign geometry object to an sfc object</h2><span id='topic+st_as_sfc'></span><span id='topic+st_as_sfc.pq_geometry'></span><span id='topic+st_as_sfc.list'></span><span id='topic+st_as_sfc.blob'></span><span id='topic+st_as_sfc.bbox'></span><span id='topic+st_as_sfc.WKB'></span><span id='topic+st_as_sfc.raw'></span><span id='topic+st_as_sfc.character'></span><span id='topic+st_as_sfc.factor'></span><span id='topic+st_as_sfc.SpatialPoints'></span><span id='topic+st_as_sfc.SpatialPixels'></span><span id='topic+st_as_sfc.SpatialMultiPoints'></span><span id='topic+st_as_sfc.SpatialLines'></span><span id='topic+st_as_sfc.SpatialPolygons'></span><span id='topic+st_as_sfc.map'></span><span id='topic+st_as_sfc.s2_geography'></span>

<h3>Description</h3>

<p>Convert foreign geometry object to an sfc object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pq_geometry'
st_as_sfc(
  x,
  ...,
  EWKB = TRUE,
  spatialite = FALSE,
  pureR = FALSE,
  crs = NA_crs_
)

## S3 method for class 'list'
st_as_sfc(x, ..., crs = NA_crs_)

## S3 method for class 'blob'
st_as_sfc(x, ...)

## S3 method for class 'bbox'
st_as_sfc(x, ...)

## S3 method for class 'WKB'
st_as_sfc(
  x,
  ...,
  EWKB = FALSE,
  spatialite = FALSE,
  pureR = FALSE,
  crs = NA_crs_
)

## S3 method for class 'raw'
st_as_sfc(x, ...)

## S3 method for class 'character'
st_as_sfc(x, crs = NA_integer_, ..., GeoJSON = FALSE)

## S3 method for class 'factor'
st_as_sfc(x, ...)

st_as_sfc(x, ...)

## S3 method for class 'SpatialPoints'
st_as_sfc(x, ..., precision = 0)

## S3 method for class 'SpatialPixels'
st_as_sfc(x, ..., precision = 0)

## S3 method for class 'SpatialMultiPoints'
st_as_sfc(x, ..., precision = 0)

## S3 method for class 'SpatialLines'
st_as_sfc(x, ..., precision = 0, forceMulti = FALSE)

## S3 method for class 'SpatialPolygons'
st_as_sfc(x, ..., precision = 0, forceMulti = FALSE)

## S3 method for class 'map'
st_as_sfc(x, ...)

## S3 method for class 's2_geography'
st_as_sfc(
  x,
  ...,
  crs = st_crs(4326),
  endian = match(.Platform$endian, c("big", "little")) - 1L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_as_sfc_+3A_x">x</code></td>
<td>
<p>object to convert</p>
</td></tr>
<tr><td><code id="st_as_sfc_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
<tr><td><code id="st_as_sfc_+3A_ewkb">EWKB</code></td>
<td>
<p>logical; if <code>TRUE</code>, parse as EWKB (extended WKB; PostGIS: ST_AsEWKB), otherwise as ISO WKB (PostGIS: ST_AsBinary)</p>
</td></tr>
<tr><td><code id="st_as_sfc_+3A_spatialite">spatialite</code></td>
<td>
<p>logical; if <code>TRUE</code>, WKB is assumed to be in the spatialite dialect, see <a href="https://www.gaia-gis.it/gaia-sins/BLOB-Geometry.html">https://www.gaia-gis.it/gaia-sins/BLOB-Geometry.html</a>; this is only supported in native endian-ness (i.e., files written on system with the same endian-ness as that on which it is being read).</p>
</td></tr>
<tr><td><code id="st_as_sfc_+3A_purer">pureR</code></td>
<td>
<p>logical; if <code>TRUE</code>, use only R code, if <code>FALSE</code>, use compiled (C++) code; use <code>TRUE</code> when the endian-ness of the binary differs from the host machine (<code>.Platform$endian</code>).</p>
</td></tr>
<tr><td><code id="st_as_sfc_+3A_crs">crs</code></td>
<td>
<p>coordinate reference system to be assigned; object of class <code>crs</code></p>
</td></tr>
<tr><td><code id="st_as_sfc_+3A_geojson">GeoJSON</code></td>
<td>
<p>logical; if <code>TRUE</code>, try to read geometries from GeoJSON text strings
geometry, see <code><a href="#topic+st_crs">st_crs()</a></code></p>
</td></tr>
<tr><td><code id="st_as_sfc_+3A_precision">precision</code></td>
<td>
<p>precision value; see <a href="#topic+st_as_binary">st_as_binary</a></p>
</td></tr>
<tr><td><code id="st_as_sfc_+3A_forcemulti">forceMulti</code></td>
<td>
<p>logical; if <code>TRUE</code>, force coercion into <code>MULTIPOLYGON</code> or <code>MULTILINE</code> objects, else autodetect</p>
</td></tr>
<tr><td><code id="st_as_sfc_+3A_endian">endian</code></td>
<td>
<p>integer; 0 or 1: defaults to the endian of the native machine</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When converting from WKB, the object <code>x</code> is either a character vector such as typically obtained from PostGIS (either with leading &quot;0x&quot; or without), or a list with raw vectors representing the features in binary (raw) form.
</p>
<p>If <code>x</code> is a character vector, it should be a vector containing
<a href="https://www.ogc.org/standard/wkt-crs/">well-known-text</a>, or
Postgis EWKT or GeoJSON representations of a single geometry for each vector element.
</p>
<p>If <code>x</code> is a <code>factor</code>, it is converted to <code>character</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wkb = structure(list("01010000204071000000000000801A064100000000AC5C1441"), class = "WKB")
st_as_sfc(wkb, EWKB = TRUE)
wkb = structure(list("0x01010000204071000000000000801A064100000000AC5C1441"), class = "WKB")
st_as_sfc(wkb, EWKB = TRUE)
st_as_sfc(st_as_binary(st_sfc(st_point(0:1)))[[1]], crs = 4326)
st_as_sfc("SRID=3978;LINESTRING(1663106 -105415,1664320 -104617)")
</code></pre>

<hr>
<h2 id='st_as_text'>Return Well-known Text representation of simple feature geometry or coordinate reference system</h2><span id='topic+st_as_text'></span><span id='topic+st_as_text.crs'></span><span id='topic+st_as_text.sfg'></span><span id='topic+st_as_text.sfc'></span>

<h3>Description</h3>

<p>Return Well-known Text representation of simple feature geometry or coordinate reference system
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'crs'
st_as_text(x, ..., projjson = FALSE, pretty = FALSE)

st_as_text(x, ...)

## S3 method for class 'sfg'
st_as_text(x, ...)

## S3 method for class 'sfc'
st_as_text(x, ..., EWKT = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_as_text_+3A_x">x</code></td>
<td>
<p>object of class <code>sfg</code>, <code>sfc</code> or <code>crs</code></p>
</td></tr>
<tr><td><code id="st_as_text_+3A_...">...</code></td>
<td>
<p>modifiers; in particular <code>digits</code> can be passed to control the number of digits used</p>
</td></tr>
<tr><td><code id="st_as_text_+3A_projjson">projjson</code></td>
<td>
<p>logical; if TRUE, return projjson form (requires GDAL 3.1 and PROJ 6.2), else return well-known-text form</p>
</td></tr>
<tr><td><code id="st_as_text_+3A_pretty">pretty</code></td>
<td>
<p>logical; if TRUE, print human-readable well-known-text representation of a coordinate reference system</p>
</td></tr>
<tr><td><code id="st_as_text_+3A_ewkt">EWKT</code></td>
<td>
<p>logical; if TRUE, print SRID=xxx; before the WKT string if <code>epsg</code> is available</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The returned WKT representation of simple feature geometry conforms to the
<a href="https://www.ogc.org/standard/sfa/">simple features access</a> specification and extensions
(known as EWKT, supported by PostGIS and other simple features implementations for addition of
a SRID to a WKT string).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>st_as_text(st_point(1:2))
st_as_text(st_sfc(st_point(c(-90,40)), crs = 4326), EWKT = TRUE)
</code></pre>

<hr>
<h2 id='st_bbox'>Return bounding of a simple feature or simple feature set</h2><span id='topic+st_bbox'></span><span id='topic+is.na.bbox'></span><span id='topic+st_bbox.POINT'></span><span id='topic+st_bbox.MULTIPOINT'></span><span id='topic+st_bbox.LINESTRING'></span><span id='topic+st_bbox.POLYGON'></span><span id='topic+st_bbox.MULTILINESTRING'></span><span id='topic+st_bbox.MULTIPOLYGON'></span><span id='topic+st_bbox.GEOMETRYCOLLECTION'></span><span id='topic+st_bbox.MULTISURFACE'></span><span id='topic+st_bbox.MULTICURVE'></span><span id='topic+st_bbox.CURVEPOLYGON'></span><span id='topic+st_bbox.COMPOUNDCURVE'></span><span id='topic+st_bbox.POLYHEDRALSURFACE'></span><span id='topic+st_bbox.TIN'></span><span id='topic+st_bbox.TRIANGLE'></span><span id='topic+st_bbox.CIRCULARSTRING'></span><span id='topic+st_bbox.sfc'></span><span id='topic+st_bbox.sf'></span><span id='topic+st_bbox.Spatial'></span><span id='topic+st_bbox.Raster'></span><span id='topic+st_bbox.Extent'></span><span id='topic+st_bbox.numeric'></span><span id='topic+NA_bbox_'></span><span id='topic+format.bbox'></span>

<h3>Description</h3>

<p>Return bounding of a simple feature or simple feature set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bbox'
is.na(x)

st_bbox(obj, ...)

## S3 method for class 'POINT'
st_bbox(obj, ...)

## S3 method for class 'MULTIPOINT'
st_bbox(obj, ...)

## S3 method for class 'LINESTRING'
st_bbox(obj, ...)

## S3 method for class 'POLYGON'
st_bbox(obj, ...)

## S3 method for class 'MULTILINESTRING'
st_bbox(obj, ...)

## S3 method for class 'MULTIPOLYGON'
st_bbox(obj, ...)

## S3 method for class 'GEOMETRYCOLLECTION'
st_bbox(obj, ...)

## S3 method for class 'MULTISURFACE'
st_bbox(obj, ...)

## S3 method for class 'MULTICURVE'
st_bbox(obj, ...)

## S3 method for class 'CURVEPOLYGON'
st_bbox(obj, ...)

## S3 method for class 'COMPOUNDCURVE'
st_bbox(obj, ...)

## S3 method for class 'POLYHEDRALSURFACE'
st_bbox(obj, ...)

## S3 method for class 'TIN'
st_bbox(obj, ...)

## S3 method for class 'TRIANGLE'
st_bbox(obj, ...)

## S3 method for class 'CIRCULARSTRING'
st_bbox(obj, ...)

## S3 method for class 'sfc'
st_bbox(obj, ...)

## S3 method for class 'sf'
st_bbox(obj, ...)

## S3 method for class 'Spatial'
st_bbox(obj, ...)

## S3 method for class 'Raster'
st_bbox(obj, ...)

## S3 method for class 'Extent'
st_bbox(obj, ..., crs = NA_crs_)

## S3 method for class 'numeric'
st_bbox(obj, ..., crs = NA_crs_)

NA_bbox_

## S3 method for class 'bbox'
format(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_bbox_+3A_x">x</code></td>
<td>
<p>object of class <code>bbox</code></p>
</td></tr>
<tr><td><code id="st_bbox_+3A_obj">obj</code></td>
<td>
<p>object to compute the bounding box from</p>
</td></tr>
<tr><td><code id="st_bbox_+3A_...">...</code></td>
<td>
<p>for format.bbox, passed on to <a href="base.html#topic+format">format</a> to format individual numbers</p>
</td></tr>
<tr><td><code id="st_bbox_+3A_crs">crs</code></td>
<td>
<p>object of class <code>crs</code>, or argument to <a href="#topic+st_crs">st_crs</a>, specifying the CRS of this bounding box.</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>bbox</code> of length 4.
</p>


<h3>Details</h3>

<p><code>NA_bbox_</code> represents the missing value for a <code>bbox</code> object
</p>


<h3>Value</h3>

<p>a numeric vector of length four, with <code>xmin</code>, <code>ymin</code>, <code>xmax</code>
and <code>ymax</code> values; if <code>obj</code> is of class <code>sf</code>, <code>sfc</code>, <code>Spatial</code> or <code>Raster</code>, the object
returned has a class <code>bbox</code>, an attribute <code>crs</code> and a method to print the
bbox and an <code>st_crs</code> method to retrieve the coordinate reference system
corresponding to <code>obj</code> (and hence the bounding box). <a href="#topic+st_as_sfc">st_as_sfc</a> has a
methods for <code>bbox</code> objects to generate a polygon around the four bounding box points.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a = st_sf(a = 1:2, geom = st_sfc(st_point(0:1), st_point(1:2)), crs = 4326)
st_bbox(a)
st_as_sfc(st_bbox(a))
st_bbox(c(xmin = 16.1, xmax = 16.6, ymax = 48.6, ymin = 47.9), crs = st_crs(4326))
</code></pre>

<hr>
<h2 id='st_break_antimeridian'>Break antimeridian for plotting not centred on Greenwich</h2><span id='topic+st_break_antimeridian'></span><span id='topic+st_break_antimeridian.sf'></span><span id='topic+st_break_antimeridian.sfc'></span>

<h3>Description</h3>

<p>Longitudes can be broken at the antimeridian of a target central longitude
to permit plotting of (usually world) line or polygon objects centred
on the chosen central longitude. The method may only be used with
non-projected, geographical coordinates and linestring or polygon objects.
s2 is turned off internally to permit the use of a rectangular bounding
box. If the input geometries go outside <code style="white-space: pre;">&#8288;[-180, 180]&#8288;</code> degrees longitude,
the protruding geometries will also be split using the same <code>tol=</code>
values; in this case empty geometries will be dropped first.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_break_antimeridian(x, lon_0 = 0, tol = 1e-04, ...)

## S3 method for class 'sf'
st_break_antimeridian(x, lon_0 = 0, tol = 1e-04, ...)

## S3 method for class 'sfc'
st_break_antimeridian(x, lon_0 = 0, tol = 1e-04, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_break_antimeridian_+3A_x">x</code></td>
<td>
<p>object of class <code>sf</code> or <code>sfc</code></p>
</td></tr>
<tr><td><code id="st_break_antimeridian_+3A_lon_0">lon_0</code></td>
<td>
<p>target central longitude (degrees)</p>
</td></tr>
<tr><td><code id="st_break_antimeridian_+3A_tol">tol</code></td>
<td>
<p>half of break width (degrees, default 0.0001)</p>
</td></tr>
<tr><td><code id="st_break_antimeridian_+3A_...">...</code></td>
<td>
<p>ignored here</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
if (require("maps", quietly=TRUE)) {
 opar = par(mfrow=c(3, 2))
 wld = st_as_sf(map(fill=FALSE, interior=FALSE, plot=FALSE), fill=FALSE)
 for (lon_0 in c(-170, -90, -10, 10, 90, 170)) {
  wld |&gt; st_break_antimeridian(lon_0=lon_0) |&gt;
   st_transform(paste0("+proj=natearth +lon_0=", lon_0)) |&gt;
   st_geometry() |&gt; plot(main=lon_0)
 }
 par(opar)
}

</code></pre>

<hr>
<h2 id='st_cast'>Cast geometry to another type: either simplify, or cast explicitly</h2><span id='topic+st_cast'></span><span id='topic+st_cast.MULTIPOLYGON'></span><span id='topic+st_cast.MULTILINESTRING'></span><span id='topic+st_cast.MULTIPOINT'></span><span id='topic+st_cast.POLYGON'></span><span id='topic+st_cast.LINESTRING'></span><span id='topic+st_cast.POINT'></span><span id='topic+st_cast.GEOMETRYCOLLECTION'></span><span id='topic+st_cast.CIRCULARSTRING'></span><span id='topic+st_cast.MULTISURFACE'></span><span id='topic+st_cast.COMPOUNDCURVE'></span><span id='topic+st_cast.MULTICURVE'></span><span id='topic+st_cast.CURVE'></span><span id='topic+st_cast.sfc'></span><span id='topic+st_cast.sf'></span><span id='topic+st_cast.sfc_CIRCULARSTRING'></span>

<h3>Description</h3>

<p>Cast geometry to another type: either simplify, or cast explicitly
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MULTIPOLYGON'
st_cast(x, to, ...)

## S3 method for class 'MULTILINESTRING'
st_cast(x, to, ...)

## S3 method for class 'MULTIPOINT'
st_cast(x, to, ...)

## S3 method for class 'POLYGON'
st_cast(x, to, ...)

## S3 method for class 'LINESTRING'
st_cast(x, to, ...)

## S3 method for class 'POINT'
st_cast(x, to, ...)

## S3 method for class 'GEOMETRYCOLLECTION'
st_cast(x, to, ...)

## S3 method for class 'CIRCULARSTRING'
st_cast(x, to, ...)

## S3 method for class 'MULTISURFACE'
st_cast(x, to, ...)

## S3 method for class 'COMPOUNDCURVE'
st_cast(x, to, ...)

## S3 method for class 'MULTICURVE'
st_cast(x, to, ...)

## S3 method for class 'CURVE'
st_cast(x, to, ...)

st_cast(x, to, ...)

## S3 method for class 'sfc'
st_cast(x, to, ..., ids = seq_along(x), group_or_split = TRUE)

## S3 method for class 'sf'
st_cast(x, to, ..., warn = TRUE, do_split = TRUE)

## S3 method for class 'sfc_CIRCULARSTRING'
st_cast(x, to, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_cast_+3A_x">x</code></td>
<td>
<p>object of class <code>sfg</code>, <code>sfc</code> or <code>sf</code></p>
</td></tr>
<tr><td><code id="st_cast_+3A_to">to</code></td>
<td>
<p>character; target type, if missing, simplification is tried; when <code>x</code> is of type <code>sfg</code> (i.e., a single geometry) then <code>to</code> needs to be specified.</p>
</td></tr>
<tr><td><code id="st_cast_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="st_cast_+3A_ids">ids</code></td>
<td>
<p>integer vector, denoting how geometries should be grouped (default: no grouping)</p>
</td></tr>
<tr><td><code id="st_cast_+3A_group_or_split">group_or_split</code></td>
<td>
<p>logical; if TRUE, group or split geometries; if FALSE, carry out a 1-1 per-geometry conversion.</p>
</td></tr>
<tr><td><code id="st_cast_+3A_warn">warn</code></td>
<td>
<p>logical; if <code>TRUE</code>, warn if attributes are assigned to sub-geometries</p>
</td></tr>
<tr><td><code id="st_cast_+3A_do_split">do_split</code></td>
<td>
<p>logical; if <code>TRUE</code>, allow splitting of geometries in sub-geometries</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When converting a GEOMETRYCOLLECTION to COMPOUNDCURVE, MULTISURFACE or CURVEPOLYGON, the user is responsible for the validity of the resulting object: no checks are being carried out by the software.
</p>
<p>When converting mixed, GEOMETRY sets, it may help to first convert to the MULTI-type, see examples
</p>
<p>the <code>st_cast</code> method for <code>sf</code> objects can only split geometries, e.g. cast <code>MULTIPOINT</code> into multiple <code>POINT</code> features.  In case of splitting, attributes are repeated and a warning is issued when non-constant attributes are assigned to sub-geometries. To merge feature geometries and attribute values, use <a href="#topic+aggregate.sf">aggregate</a> or <a href="#topic+tidyverse">summarise</a>.
</p>


<h3>Value</h3>

<p>object of class <code>to</code> if successful, or unmodified object if unsuccessful. If information gets lost while type casting, a warning is raised.
</p>
<p>In case <code>to</code> is missing, <code>st_cast.sfc</code> will coerce combinations of &quot;POINT&quot; and &quot;MULTIPOINT&quot;, &quot;LINESTRING&quot; and &quot;MULTILINESTRING&quot;, &quot;POLYGON&quot; and &quot;MULTIPOLYGON&quot; into their &quot;MULTI...&quot; form, or in case all geometries are &quot;GEOMETRYCOLLECTION&quot; will return a list of all the contents of the &quot;GEOMETRYCOLLECTION&quot; objects, or else do nothing. In case <code>to</code> is specified, if <code>to</code> is &quot;GEOMETRY&quot;, geometries are not converted, else, <code>st_cast</code> will try to coerce all elements into <code>to</code>; <code>ids</code> may be specified to group e.g. &quot;POINT&quot; objects into a &quot;MULTIPOINT&quot;, if not specified no grouping takes place. If e.g. a &quot;sfc_MULTIPOINT&quot; is cast to a &quot;sfc_POINT&quot;, the objects are split, so no information gets lost, unless <code>group_or_split</code> is <code>FALSE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># example(st_read)
nc = st_read(system.file("shape/nc.shp", package="sf"))
mpl &lt;- st_geometry(nc)[[4]]
#st_cast(x) ## error 'argument "to" is missing, with no default'
cast_all &lt;- function(xg) {
  lapply(c("MULTIPOLYGON", "MULTILINESTRING", "MULTIPOINT", "POLYGON", "LINESTRING", "POINT"), 
      function(x) st_cast(xg, x))
}
st_sfc(cast_all(mpl))
## no closing coordinates should remain for multipoint
any(duplicated(unclass(st_cast(mpl, "MULTIPOINT"))))  ## should be FALSE
## number of duplicated coordinates in the linestrings should equal the number of polygon rings 
## (... in this case, won't always be true)
sum(duplicated(do.call(rbind, unclass(st_cast(mpl, "MULTILINESTRING"))))
     ) == sum(unlist(lapply(mpl, length)))  ## should be TRUE

p1 &lt;- structure(c(0, 1, 3, 2, 1, 0, 0, 0, 2, 4, 4, 0), .Dim = c(6L, 2L))
p2 &lt;- structure(c(1, 1, 2, 1, 1, 2, 2, 1), .Dim = c(4L, 2L))
st_polygon(list(p1, p2))
mls &lt;- st_cast(st_geometry(nc)[[4]], "MULTILINESTRING")
st_sfc(cast_all(mls))
mpt &lt;- st_cast(st_geometry(nc)[[4]], "MULTIPOINT")
st_sfc(cast_all(mpt))
pl &lt;- st_cast(st_geometry(nc)[[4]], "POLYGON")
st_sfc(cast_all(pl))
ls &lt;- st_cast(st_geometry(nc)[[4]], "LINESTRING")
st_sfc(cast_all(ls))
pt &lt;- st_cast(st_geometry(nc)[[4]], "POINT")
## st_sfc(cast_all(pt))  ## Error: cannot create MULTIPOLYGON from POINT 
st_sfc(lapply(c("POINT", "MULTIPOINT"), function(x) st_cast(pt, x)))
s = st_multipoint(rbind(c(1,0)))
st_cast(s, "POINT")
# https://github.com/r-spatial/sf/issues/1930:
pt1 &lt;- st_point(c(0,1))
pt23 &lt;- st_multipoint(matrix(c(1,2,3,4), ncol = 2, byrow = TRUE))
d &lt;- st_sf(geom = st_sfc(pt1, pt23))
st_cast(d, "POINT") # will not convert the entire MULTIPOINT, and warns
st_cast(d, "MULTIPOINT") %&gt;% st_cast("POINT")
</code></pre>

<hr>
<h2 id='st_cast_sfc_default'>Coerce geometry to MULTI* geometry</h2><span id='topic+st_cast_sfc_default'></span>

<h3>Description</h3>

<p>Mixes of POINTS and MULTIPOINTS, LINESTRING and MULTILINESTRING,
POLYGON and MULTIPOLYGON are returned as MULTIPOINTS, MULTILINESTRING and MULTIPOLYGONS respectively
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_cast_sfc_default(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_cast_sfc_default_+3A_x">x</code></td>
<td>
<p>list of geometries or simple features</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Geometries that are already MULTI* are left unchanged.
Features that can't be cast to a single  MULTI* geometry are return as a
GEOMETRYCOLLECTION
</p>

<hr>
<h2 id='st_collection_extract'>Given an object with geometries of type <code>GEOMETRY</code> or <code>GEOMETRYCOLLECTION</code>,
return an object consisting only of elements of the specified type.</h2><span id='topic+st_collection_extract'></span><span id='topic+st_collection_extract.sfg'></span><span id='topic+st_collection_extract.sfc'></span><span id='topic+st_collection_extract.sf'></span>

<h3>Description</h3>

<p>Similar to ST_CollectionExtract in PostGIS. If there are no sub-geometries
of the specified type, an empty geometry is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_collection_extract(
  x,
  type = c("POLYGON", "POINT", "LINESTRING"),
  warn = FALSE
)

## S3 method for class 'sfg'
st_collection_extract(
  x,
  type = c("POLYGON", "POINT", "LINESTRING"),
  warn = FALSE
)

## S3 method for class 'sfc'
st_collection_extract(
  x,
  type = c("POLYGON", "POINT", "LINESTRING"),
  warn = FALSE
)

## S3 method for class 'sf'
st_collection_extract(
  x,
  type = c("POLYGON", "POINT", "LINESTRING"),
  warn = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_collection_extract_+3A_x">x</code></td>
<td>
<p>an object of class <code>sf</code>, <code>sfc</code> or <code>sfg</code> that has
mixed geometry (<code>GEOMETRY</code> or <code>GEOMETRYCOLLECTION</code>).</p>
</td></tr>
<tr><td><code id="st_collection_extract_+3A_type">type</code></td>
<td>
<p>character; one of &quot;POLYGON&quot;, &quot;POINT&quot;, &quot;LINESTRING&quot;</p>
</td></tr>
<tr><td><code id="st_collection_extract_+3A_warn">warn</code></td>
<td>
<p>logical; if <code>TRUE</code>, warn if attributes are assigned to
sub-geometries when casting (see <code><a href="#topic+st_cast">st_cast</a></code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object having the same class as <code>x</code>, with geometries
consisting only of elements of the specified type.
For <code>sfg</code> objects, an <code>sfg</code> object is returned if there is only
one geometry of the specified type, otherwise the geometries are combined
into an <code>sfc</code> object of the relevant type. If any subgeometries in the
input are MULTI, then all of the subgeometries in the output will be MULTI.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pt &lt;- st_point(c(1, 0))
ls &lt;- st_linestring(matrix(c(4, 3, 0, 0), ncol = 2))
poly1 &lt;- st_polygon(list(matrix(c(5.5, 7, 7, 6, 5.5, 0, 0, -0.5, -0.5, 0), ncol = 2)))
poly2 &lt;- st_polygon(list(matrix(c(6.6, 8, 8, 7, 6.6, 1, 1, 1.5, 1.5, 1), ncol = 2)))
multipoly &lt;- st_multipolygon(list(poly1, poly2))

i &lt;- st_geometrycollection(list(pt, ls, poly1, poly2))
j &lt;- st_geometrycollection(list(pt, ls, poly1, poly2, multipoly))

st_collection_extract(i, "POLYGON")
st_collection_extract(i, "POINT")
st_collection_extract(i, "LINESTRING")

## A GEOMETRYCOLLECTION
aa &lt;- rbind(st_sf(a=1, geom = st_sfc(i)),
			st_sf(a=2, geom = st_sfc(j)))

## With sf objects
st_collection_extract(aa, "POLYGON")
st_collection_extract(aa, "LINESTRING")
st_collection_extract(aa, "POINT")

## With sfc objects
st_collection_extract(st_geometry(aa), "POLYGON")
st_collection_extract(st_geometry(aa), "LINESTRING")
st_collection_extract(st_geometry(aa), "POINT")

## A GEOMETRY of single types
bb &lt;- rbind(
	st_sf(a = 1, geom = st_sfc(pt)),
	st_sf(a = 2, geom = st_sfc(ls)),
	st_sf(a = 3, geom = st_sfc(poly1)),
	st_sf(a = 4, geom = st_sfc(multipoly))
)

st_collection_extract(bb, "POLYGON")

## A GEOMETRY of mixed single types and GEOMETRYCOLLECTIONS
cc &lt;- rbind(aa, bb)

st_collection_extract(cc, "POLYGON")

</code></pre>

<hr>
<h2 id='st_coordinates'>retrieve coordinates in matrix form</h2><span id='topic+st_coordinates'></span>

<h3>Description</h3>

<p>retrieve coordinates in matrix form
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_coordinates(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_coordinates_+3A_x">x</code></td>
<td>
<p>object of class sf, sfc or sfg</p>
</td></tr>
<tr><td><code id="st_coordinates_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with coordinates (X, Y, possibly Z and/or M) in rows, possibly followed by integer indicators <code>L1</code>,...,<code>L3</code> that point out to which structure the coordinate belongs; for <code>POINT</code> this is absent (each coordinate is a feature), for <code>LINESTRING</code> <code>L1</code> refers to the feature, for <code>MULTILINESTRING</code> <code>L1</code> refers to the part and <code>L2</code> to the simple feature, for <code>POLYGON</code> <code>L1</code> refers to the main ring or holes and <code>L2</code> to the simple feature, for <code>MULTIPOLYGON</code> <code>L1</code> refers to the main ring or holes, <code>L2</code> to the ring id in the <code>MULTIPOLYGON</code>, and <code>L3</code> to the simple feature.
</p>
<p>For <code>POLYGONS</code>, <code>L1</code> can be used to identify exterior rings and inner holes.
The exterior ring is when <code>L1</code> is equal to 1. Interior rings are identified
when <code>L1</code> is greater than 1. <code>L2</code> can be used to differentiate between the
feature. Whereas for <code>MULTIPOLYGON</code>, <code>L3</code> refers to the <code>MULTIPOLYGON</code>
feature and <code>L2</code> refers to the component <code>POLYGON</code>.
</p>

<hr>
<h2 id='st_crop'>crop an sf object to a specific rectangle</h2><span id='topic+st_crop'></span><span id='topic+st_crop.sfc'></span><span id='topic+st_crop.sf'></span>

<h3>Description</h3>

<p>crop an sf object to a specific rectangle
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_crop(x, y, ...)

## S3 method for class 'sfc'
st_crop(x, y, ..., xmin, ymin, xmax, ymax)

## S3 method for class 'sf'
st_crop(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_crop_+3A_x">x</code></td>
<td>
<p>object of class <code>sf</code> or <code>sfc</code></p>
</td></tr>
<tr><td><code id="st_crop_+3A_y">y</code></td>
<td>
<p>numeric vector with named elements <code>xmin</code>, <code>ymin</code>, <code>xmax</code> and <code>ymax</code>, or object of class <code>bbox</code>, or object for which there is an <a href="#topic+st_bbox">st_bbox</a> method to convert it to a <code>bbox</code> object</p>
</td></tr>
<tr><td><code id="st_crop_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="st_crop_+3A_xmin">xmin</code></td>
<td>
<p>minimum x extent of cropping area</p>
</td></tr>
<tr><td><code id="st_crop_+3A_ymin">ymin</code></td>
<td>
<p>minimum y extent of cropping area</p>
</td></tr>
<tr><td><code id="st_crop_+3A_xmax">xmax</code></td>
<td>
<p>maximum x extent of cropping area</p>
</td></tr>
<tr><td><code id="st_crop_+3A_ymax">ymax</code></td>
<td>
<p>maximum y extent of cropping area</p>
</td></tr>
</table>


<h3>Details</h3>

<p>setting arguments <code>xmin</code>, <code>ymin</code>, <code>xmax</code> and <code>ymax</code> implies that argument <code>y</code> gets ignored.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>box = c(xmin = 0, ymin = 0, xmax = 1, ymax = 1)
pol = st_sfc(st_buffer(st_point(c(.5, .5)), .6))
pol_sf = st_sf(a=1, geom=pol)
plot(st_crop(pol, box))
plot(st_crop(pol_sf, st_bbox(box)))
# alternative:
plot(st_crop(pol, xmin = 0, ymin = 0, xmax = 1, ymax = 1))
</code></pre>

<hr>
<h2 id='st_crs'>Retrieve coordinate reference system from object</h2><span id='topic+st_crs'></span><span id='topic+st_crs.sf'></span><span id='topic+st_crs.numeric'></span><span id='topic+st_crs.character'></span><span id='topic+st_crs.sfc'></span><span id='topic+st_crs.bbox'></span><span id='topic+st_crs.CRS'></span><span id='topic+st_crs.crs'></span><span id='topic+st_crs+3C-'></span><span id='topic+st_crs+3C-.sf'></span><span id='topic+st_crs+3C-.sfc'></span><span id='topic+st_set_crs'></span><span id='topic+NA_crs_'></span><span id='topic+is.na.crs'></span><span id='topic++24.crs'></span><span id='topic+format.crs'></span><span id='topic+st_axis_order'></span>

<h3>Description</h3>

<p>Retrieve coordinate reference system from sf or sfc object
</p>
<p>Set or replace retrieve coordinate reference system from object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_crs(x, ...)

## S3 method for class 'sf'
st_crs(x, ...)

## S3 method for class 'numeric'
st_crs(x, ...)

## S3 method for class 'character'
st_crs(x, ...)

## S3 method for class 'sfc'
st_crs(x, ..., parameters = FALSE)

## S3 method for class 'bbox'
st_crs(x, ...)

## S3 method for class 'CRS'
st_crs(x, ...)

## S3 method for class 'crs'
st_crs(x, ...)

st_crs(x) &lt;- value

## S3 replacement method for class 'sf'
st_crs(x) &lt;- value

## S3 replacement method for class 'sfc'
st_crs(x) &lt;- value

st_set_crs(x, value)

NA_crs_

## S3 method for class 'crs'
is.na(x)

## S3 method for class 'crs'
x$name

## S3 method for class 'crs'
format(x, ...)

st_axis_order(authority_compliant = logical(0))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_crs_+3A_x">x</code></td>
<td>
<p>numeric, character, or object of class <a href="#topic+sf">sf</a> or <a href="#topic+sfc">sfc</a></p>
</td></tr>
<tr><td><code id="st_crs_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="st_crs_+3A_parameters">parameters</code></td>
<td>
<p>logical; <code>FALSE</code> by default; if <code>TRUE</code> return a list of coordinate reference system parameters, with named elements <code>SemiMajor</code>, <code>InvFlattening</code>, <code>units_gdal</code>, <code>IsVertical</code>, <code>WktPretty</code>, and <code>Wkt</code></p>
</td></tr>
<tr><td><code id="st_crs_+3A_value">value</code></td>
<td>
<p>one of (i) character: a string accepted by GDAL, (ii) integer, a valid EPSG value (numeric), or (iii) an object of class <code>crs</code>.</p>
</td></tr>
<tr><td><code id="st_crs_+3A_name">name</code></td>
<td>
<p>element name</p>
</td></tr>
<tr><td><code id="st_crs_+3A_authority_compliant">authority_compliant</code></td>
<td>
<p>logical; specify whether axis order should be
handled compliant to the authority; if omitted, the current value is printed.</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>crs</code> of length 2.
</p>


<h3>Details</h3>

<p>The *crs functions create, get, set or replace the <code>crs</code> attribute
of a simple feature geometry list-column. This attribute is of class <code>crs</code>,
and is a list consisting of <code>input</code> (user input, e.g. &quot;EPSG:4326&quot; or &quot;WGS84&quot;
or a proj4string), and <code>wkt</code>, an automatically generated wkt2 representation of the crs.
If <code>x</code> is identical to the wkt2 representation, and the CRS has a name, this name
is used for the <code>input</code> field.
</p>
<p>Comparison of two objects of class <code>crs</code> uses the GDAL function
<code>OGRSpatialReference::IsSame</code>.
</p>
<p>In case a coordinate reference system is replaced, no transformation takes
place and a warning is raised to stress this.
</p>
<p><code>NA_crs_</code> is the <code>crs</code> object with missing values for <code>input</code> and <code>wkt</code>.
</p>
<p>the <code>$</code> method for <code>crs</code> objects retrieves named elements
using the GDAL interface; named elements include
<code>SemiMajor</code>, <code>SemiMinor</code>, <code>InvFlattening</code>, <code>IsGeographic</code>,
<code>units_gdal</code>, <code>IsVertical</code>, <code>WktPretty</code>, <code>Wkt</code>,
<code>Name</code>, <code>proj4string</code>, <code>epsg</code>, <code>yx</code>,
<code>ud_unit</code>, and <code>axes</code> (this may be subject to changes in future GDAL versions).
</p>
<p>Note that not all valid CRS have a corresponding <code>proj4string</code>.
</p>
<p><code>ud_unit</code> returns a valid <a href="units.html#topic+units">units</a> object or <code>NULL</code> if units are missing.
</p>
<p>format.crs returns NA if the crs is missing valued, or else
the name of a crs if it is different from &quot;unknown&quot;, or
else the user input if it was set, or else its &quot;proj4string&quot; representation;
</p>
<p><code>st_axis_order</code> can be used to get and set the axis order: <code>TRUE</code>
indicates axes order according to the authority
(e.g. EPSG:4326 defining coordinates to be latitude,longitude pairs), <code>FALSE</code>
indicates the usual GIS (display) order (longitude,latitude). This can be useful
when data are read, or have to be written, with coordinates in authority compliant order.
The return value is the current state of this (<code>FALSE</code>, by default).
</p>


<h3>Value</h3>

<p>If <code>x</code> is numeric, return <code>crs</code> object for EPSG:<code>x</code>;
if <code>x</code> is character, return <code>crs</code> object for <code>x</code>;
if <code>x</code> is of class <code>sf</code> or <code>sfc</code>, return its <code>crs</code> object.
</p>
<p>Object of class <code>crs</code>, which is a list with elements <code>input</code> (length-1 character)
and <code>wkt</code> (length-1 character).
Elements may be <code>NA</code> valued; if all elements are <code>NA</code> the CRS is missing valued, and coordinates are
assumed to relate to an arbitrary Cartesian coordinate system.
</p>
<p><code>st_axis_order</code> returns the (logical) current value if called without
argument, or (invisibly) the previous value if it is being set.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sfc = st_sfc(st_point(c(0,0)), st_point(c(1,1)))
sf = st_sf(a = 1:2, geom = sfc)
st_crs(sf) = 4326
st_geometry(sf)
sfc = st_sfc(st_point(c(0,0)), st_point(c(1,1)))
st_crs(sfc) = 4326
sfc
sfc = st_sfc(st_point(c(0,0)), st_point(c(1,1)))
sfc %&gt;% st_set_crs(4326) %&gt;% st_transform(3857)
st_crs("EPSG:3857")$input
st_crs(3857)$proj4string
pt = st_sfc(st_point(c(0, 60)), crs = 4326)
# st_axis_order() only has effect in GDAL &gt;= 2.5.0:
st_axis_order() # query default: FALSE means interpret pt as (longitude latitude)
st_transform(pt, 3857)[[1]]
old_value = FALSE
if (sf_extSoftVersion()["GDAL"] &gt;= "2.5.0")
   (old_value = st_axis_order(TRUE))
# now interpret pt as (latitude longitude), as EPSG:4326 prescribes:
st_axis_order() # query current value
st_transform(pt, 3857)[[1]]
st_axis_order(old_value) # set back to old value
</code></pre>

<hr>
<h2 id='st_drivers'>Get GDAL drivers</h2><span id='topic+st_drivers'></span>

<h3>Description</h3>

<p>Get a list of the available GDAL drivers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_drivers(what = "vector", regex)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_drivers_+3A_what">what</code></td>
<td>
<p>character: <code>"vector"</code> or <code>"raster"</code>, anything else will return all
drivers.</p>
</td></tr>
<tr><td><code id="st_drivers_+3A_regex">regex</code></td>
<td>
<p>character; regular expression to filter the <code>name</code> and <code>long_name</code>
fields on</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The drivers available will depend on the installation of GDAL/OGR,
and can vary; the <code>st_drivers()</code> function shows all the drivers that are
readable, and which may be written. The field <code>vsi</code> refers to the driver's
capability to read/create datasets through the VSI*L API. <a href="https://gdal.org/drivers/vector/index.html">See GDAL website for additional details on driver support</a>.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with driver metadata.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The following driver lists depend on the GDAL setup and platform used:
st_drivers()
st_drivers("raster", "GeoT")
</code></pre>

<hr>
<h2 id='st_geometry'>Get, set, replace or rename geometry from an sf object</h2><span id='topic+st_geometry'></span><span id='topic+st_geometry.sfc'></span><span id='topic+st_geometry.sf'></span><span id='topic+st_geometry.sfg'></span><span id='topic+st_geometry+3C-'></span><span id='topic+st_set_geometry'></span><span id='topic+st_drop_geometry'></span><span id='topic+st_drop_geometry.sf'></span><span id='topic+st_drop_geometry.default'></span>

<h3>Description</h3>

<p>Get, set, replace or rename geometry from an sf object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sfc'
st_geometry(obj, ...)

st_geometry(obj, ...)

## S3 method for class 'sf'
st_geometry(obj, ...)

## S3 method for class 'sfc'
st_geometry(obj, ...)

## S3 method for class 'sfg'
st_geometry(obj, ...)

st_geometry(x) &lt;- value

st_set_geometry(x, value)

st_drop_geometry(x, ...)

## S3 method for class 'sf'
st_drop_geometry(x, ...)

## Default S3 method:
st_drop_geometry(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_geometry_+3A_obj">obj</code></td>
<td>
<p>object of class <code>sf</code> or <code>sfc</code></p>
</td></tr>
<tr><td><code id="st_geometry_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="st_geometry_+3A_x">x</code></td>
<td>
<p>object of class <code>data.frame</code> or <code>sf</code></p>
</td></tr>
<tr><td><code id="st_geometry_+3A_value">value</code></td>
<td>
<p>object of class <code>sfc</code>, or <code>character</code> to set, replace, or rename the geometry of <code>x</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>when applied to a <code>data.frame</code> and when <code>value</code> is an object of class <code>sfc</code>, <code>st_set_geometry</code> and <code>st_geometry&lt;-</code> will first check for the existence of an attribute <code>sf_column</code> and overwrite that, or else look for list-columns of class <code>sfc</code> and overwrite the first of that, or else write the geometry list-column to a column named <code>geometry</code>.  In case <code>value</code> is character and <code>x</code> is of class <code>sf</code>, the &quot;active&quot; geometry column is set to <code>x[[value]]</code>.
</p>
<p>the replacement function applied to <code>sf</code> objects will overwrite the geometry list-column, if <code>value</code> is <code>NULL</code>, it will remove it and coerce <code>x</code> to a <code>data.frame</code>.
</p>
<p>if <code>x</code> is of class <code>sf</code>, <code>st_drop_geometry</code> drops the geometry of its argument, and reclasses it accordingly; otherwise it returns <code>x</code> unmodified.
</p>


<h3>Value</h3>

<p>st_geometry returns an object of class <a href="#topic+sfc">sfc</a>, a list-column with geometries
</p>
<p><code>st_geometry</code> returns an object of class <a href="#topic+sfc">sfc</a>. Assigning geometry to a <code>data.frame</code> creates an <a href="#topic+sf">sf</a> object, assigning it to an <a href="#topic+sf">sf</a> object replaces the geometry list-column.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df = data.frame(a = 1:2)
sfc = st_sfc(st_point(c(3,4)), st_point(c(10,11)))
st_geometry(sfc)
st_geometry(df) &lt;- sfc
class(df)
st_geometry(df)
st_geometry(df) &lt;- sfc # replaces
st_geometry(df) &lt;- NULL # remove geometry, coerce to data.frame
sf &lt;- st_set_geometry(df, sfc) # set geometry, return sf
st_set_geometry(sf, NULL) # remove geometry, coerce to data.frame
</code></pre>

<hr>
<h2 id='st_geometry_type'>Return geometry type of an object</h2><span id='topic+st_geometry_type'></span>

<h3>Description</h3>

<p>Return geometry type of an object, as a factor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_geometry_type(x, by_geometry = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_geometry_type_+3A_x">x</code></td>
<td>
<p>object of class <a href="#topic+sf">sf</a> or <a href="#topic+sfc">sfc</a></p>
</td></tr>
<tr><td><code id="st_geometry_type_+3A_by_geometry">by_geometry</code></td>
<td>
<p>logical; if <code>TRUE</code>, return geometry type of each geometry,
else return geometry type of the set</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a factor with the geometry type of each simple feature geometry
in <code>x</code>, or that of the whole set
</p>

<hr>
<h2 id='st_graticule'>Compute graticules and their parameters</h2><span id='topic+st_graticule'></span>

<h3>Description</h3>

<p>Compute graticules and their parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_graticule(
  x = c(-180, -90, 180, 90),
  crs = st_crs(x),
  datum = st_crs(4326),
  ...,
  lon = NULL,
  lat = NULL,
  ndiscr = 100,
  margin = 0.001
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_graticule_+3A_x">x</code></td>
<td>
<p>object of class <code>sf</code>, <code>sfc</code> or <code>sfg</code> or numeric vector with bounding box given as (minx, miny, maxx, maxy).</p>
</td></tr>
<tr><td><code id="st_graticule_+3A_crs">crs</code></td>
<td>
<p>object of class <code>crs</code>, with the display coordinate reference system</p>
</td></tr>
<tr><td><code id="st_graticule_+3A_datum">datum</code></td>
<td>
<p>either an object of class <code>crs</code> with the coordinate reference system for the graticules, or <code>NULL</code> in which case a grid in the coordinate system of <code>x</code> is drawn, or <code>NA</code>, in which case an empty <code>sf</code> object is returned.</p>
</td></tr>
<tr><td><code id="st_graticule_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="st_graticule_+3A_lon">lon</code></td>
<td>
<p>numeric; values in degrees East for the meridians, associated with <code>datum</code></p>
</td></tr>
<tr><td><code id="st_graticule_+3A_lat">lat</code></td>
<td>
<p>numeric; values in degrees North for the parallels, associated with <code>datum</code></p>
</td></tr>
<tr><td><code id="st_graticule_+3A_ndiscr">ndiscr</code></td>
<td>
<p>integer; number of points to discretize a parallel or meridian</p>
</td></tr>
<tr><td><code id="st_graticule_+3A_margin">margin</code></td>
<td>
<p>numeric; small number to trim a longlat bounding box that touches or
crosses +/-180 long or +/-90 latitude.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>sf</code> with additional attributes describing the type
(E: meridian, N: parallel) degree value, label, start and end coordinates and angle;
see example.
</p>


<h3>Use of graticules</h3>

<p>In cartographic visualization, the use of graticules is not advised, unless
the graphical output will be used for measurement or navigation, or the
direction of North is important for the interpretation of the content, or
the content is intended to display distortions and artifacts created by
projection. Unnecessary use of graticules only adds visual clutter but
little relevant information. Use of coastlines, administrative boundaries
or place names permits most viewers of the output to orient themselves
better than a graticule.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
if (require(maps, quietly = TRUE)) {

usa = st_as_sf(map('usa', plot = FALSE, fill = TRUE))
laea = st_crs("+proj=laea +lat_0=30 +lon_0=-95") # Lambert equal area
usa &lt;- st_transform(usa, laea)

bb = st_bbox(usa)
bbox = st_linestring(rbind(c( bb[1],bb[2]),c( bb[3],bb[2]),
   c( bb[3],bb[4]),c( bb[1],bb[4]),c( bb[1],bb[2])))

g = st_graticule(usa)
plot(usa, xlim = 1.2 * c(-2450853.4, 2186391.9), reset = FALSE)
plot(g[1], add = TRUE, col = 'grey')
plot(bbox, add = TRUE)
points(g$x_start, g$y_start, col = 'red')
points(g$x_end, g$y_end, col = 'blue')

invisible(lapply(seq_len(nrow(g)), function(i) {
if (g$type[i] == "N" &amp;&amp; g$x_start[i] - min(g$x_start) &lt; 1000)
	text(g[i,"x_start"], g[i,"y_start"], labels = parse(text = g[i,"degree_label"]),
		srt = g$angle_start[i], pos = 2, cex = .7)
if (g$type[i] == "E" &amp;&amp; g$y_start[i] - min(g$y_start) &lt; 1000)
	text(g[i,"x_start"], g[i,"y_start"], labels = parse(text = g[i,"degree_label"]),
		srt = g$angle_start[i] - 90, pos = 1, cex = .7)
if (g$type[i] == "N" &amp;&amp; g$x_end[i] - max(g$x_end) &gt; -1000)
	text(g[i,"x_end"], g[i,"y_end"], labels = parse(text = g[i,"degree_label"]),
		srt = g$angle_end[i], pos = 4, cex = .7)
if (g$type[i] == "E" &amp;&amp; g$y_end[i] - max(g$y_end) &gt; -1000)
	text(g[i,"x_end"], g[i,"y_end"], labels = parse(text = g[i,"degree_label"]),
		srt = g$angle_end[i] - 90, pos = 3, cex = .7)
}))
plot(usa, graticule = st_crs(4326), axes = TRUE, lon = seq(-60,-130,by=-10))
}
</code></pre>

<hr>
<h2 id='st_is'>test equality between the geometry type and a class or set of classes</h2><span id='topic+st_is'></span>

<h3>Description</h3>

<p>test equality between the geometry type and a class or set of classes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_is(x, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_is_+3A_x">x</code></td>
<td>
<p>object of class <code>sf</code>, <code>sfc</code> or <code>sfg</code></p>
</td></tr>
<tr><td><code id="st_is_+3A_type">type</code></td>
<td>
<p>character; class, or set of classes, to test against</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>st_is(st_point(0:1), "POINT")
sfc = st_sfc(st_point(0:1), st_linestring(matrix(1:6,,2)))
st_is(sfc, "POINT")
st_is(sfc, "POLYGON")
st_is(sfc, "LINESTRING")
st_is(st_sf(a = 1:2, sfc), "LINESTRING")
st_is(sfc, c("POINT", "LINESTRING"))
</code></pre>

<hr>
<h2 id='st_is_longlat'>Assert whether simple feature coordinates are longlat degrees</h2><span id='topic+st_is_longlat'></span>

<h3>Description</h3>

<p>Assert whether simple feature coordinates are longlat degrees
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_is_longlat(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_is_longlat_+3A_x">x</code></td>
<td>
<p>object of class <a href="#topic+sf">sf</a> or <a href="#topic+sfc">sfc</a>, or otherwise an object of a class that has an <a href="#topic+st_crs">st_crs</a> method returning a <code>crs</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if <code>x</code> has geographic coordinates, <code>FALSE</code> if it has projected coordinates, or <code>NA</code> if <code>is.na(st_crs(x))</code>.
</p>

<hr>
<h2 id='st_jitter'>jitter geometries</h2><span id='topic+st_jitter'></span>

<h3>Description</h3>

<p>jitter geometries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_jitter(x, amount, factor = 0.002)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_jitter_+3A_x">x</code></td>
<td>
<p>object of class <code>sf</code> or <code>sfc</code></p>
</td></tr>
<tr><td><code id="st_jitter_+3A_amount">amount</code></td>
<td>
<p>numeric; amount of jittering applied; if missing, the amount is set to factor * the bounding box diagonal; units of coordinates.</p>
</td></tr>
<tr><td><code id="st_jitter_+3A_factor">factor</code></td>
<td>
<p>numeric; fractional amount of jittering to be applied</p>
</td></tr>
</table>


<h3>Details</h3>

<p>jitters coordinates with an amount such that <code>runif(1, -amount, amount)</code> is added to the coordinates. x- and y-coordinates are jittered independently but all coordinates of a single geometry are jittered with the same amount, meaning that the geometry shape does not change. For longlat data, a latitude correction is made such that jittering in East and North directions are identical in distance in the center of the bounding box of <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nc = st_read(system.file("gpkg/nc.gpkg", package="sf"))
pts = st_centroid(st_geometry(nc))
plot(pts)
plot(st_jitter(pts, .05), add = TRUE, col = 'red')
plot(st_geometry(nc))
plot(st_jitter(st_geometry(nc), factor = .01), add = TRUE, col = '#ff8888')
</code></pre>

<hr>
<h2 id='st_join'>spatial join, spatial filter</h2><span id='topic+st_join'></span><span id='topic+st_join.sf'></span><span id='topic+st_filter'></span><span id='topic+st_filter.sf'></span>

<h3>Description</h3>

<p>spatial join, spatial filter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_join(x, y, join, ...)

## S3 method for class 'sf'
st_join(
  x,
  y,
  join = st_intersects,
  ...,
  suffix = c(".x", ".y"),
  left = TRUE,
  largest = FALSE
)

st_filter(x, y, ...)

## S3 method for class 'sf'
st_filter(x, y, ..., .predicate = st_intersects)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_join_+3A_x">x</code></td>
<td>
<p>object of class <code>sf</code></p>
</td></tr>
<tr><td><code id="st_join_+3A_y">y</code></td>
<td>
<p>object of class <code>sf</code></p>
</td></tr>
<tr><td><code id="st_join_+3A_join">join</code></td>
<td>
<p>geometry predicate function with the same profile as <a href="#topic+st_intersects">st_intersects</a>; see details</p>
</td></tr>
<tr><td><code id="st_join_+3A_...">...</code></td>
<td>
<p>for <code>st_join</code>: arguments passed on to the <code>join</code> function or to <code>st_intersection</code> when <code>largest</code> is <code>TRUE</code>; for <code>st_filter</code> arguments passed on to the <code>.predicate</code> function, e.g. <code>prepared</code>, or a pattern for <a href="#topic+st_relate">st_relate</a></p>
</td></tr>
<tr><td><code id="st_join_+3A_suffix">suffix</code></td>
<td>
<p>length 2 character vector; see <a href="base.html#topic+merge">merge</a></p>
</td></tr>
<tr><td><code id="st_join_+3A_left">left</code></td>
<td>
<p>logical; if <code>TRUE</code> return the left join, otherwise an inner join; see details.
see also <a href="dplyr.html#topic+mutate-joins">left_join</a></p>
</td></tr>
<tr><td><code id="st_join_+3A_largest">largest</code></td>
<td>
<p>logical; if <code>TRUE</code>, return <code>x</code> features augmented with the fields of <code>y</code> that have the largest overlap with each of the features of <code>x</code>; see https://github.com/r-spatial/sf/issues/578</p>
</td></tr>
<tr><td><code id="st_join_+3A_.predicate">.predicate</code></td>
<td>
<p>geometry predicate function with the same profile as <a href="#topic+st_intersects">st_intersects</a>; see details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>alternative values for argument <code>join</code> are:
</p>

<ul>
<li> <p><a href="#topic+st_contains_properly">st_contains_properly</a>
</p>
</li>
<li> <p><a href="#topic+st_contains">st_contains</a>
</p>
</li>
<li> <p><a href="#topic+st_covered_by">st_covered_by</a>
</p>
</li>
<li> <p><a href="#topic+st_covers">st_covers</a>
</p>
</li>
<li> <p><a href="#topic+st_crosses">st_crosses</a>
</p>
</li>
<li> <p><a href="#topic+st_disjoint">st_disjoint</a>
</p>
</li>
<li> <p><a href="#topic+st_equals_exact">st_equals_exact</a>
</p>
</li>
<li> <p><a href="#topic+st_equals">st_equals</a>
</p>
</li>
<li> <p><a href="#topic+st_is_within_distance">st_is_within_distance</a>
</p>
</li>
<li> <p><a href="#topic+st_nearest_feature">st_nearest_feature</a>
</p>
</li>
<li> <p><a href="#topic+st_overlaps">st_overlaps</a>
</p>
</li>
<li> <p><a href="#topic+st_touches">st_touches</a>
</p>
</li>
<li> <p><a href="#topic+st_within">st_within</a>
</p>
</li>
<li><p> any user-defined function of the same profile as the above
</p>
</li></ul>

<p>A left join returns all records of the <code>x</code> object with <code>y</code> fields for non-matched records filled with <code>NA</code> values; an inner join returns only records that spatially match.
</p>
<p>To replicate the results of <code>st_within(x, y)</code> you will need to use <code>st_join(x, y, join = "st_within", left = FALSE)</code>.
</p>


<h3>Value</h3>

<p>an object of class <code>sf</code>, joined based on geometry
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a = st_sf(a = 1:3,
 geom = st_sfc(st_point(c(1,1)), st_point(c(2,2)), st_point(c(3,3))))
b = st_sf(a = 11:14,
 geom = st_sfc(st_point(c(10,10)), st_point(c(2,2)), st_point(c(2,2)), st_point(c(3,3))))
st_join(a, b)
st_join(a, b, left = FALSE)
# two ways to aggregate y's attribute values outcome over x's geometries:
st_join(a, b) %&gt;% aggregate(list(.$a.x), mean)
if (require(dplyr, quietly = TRUE)) {
 st_join(a, b) %&gt;% group_by(a.x) %&gt;% summarise(mean(a.y))
}
# example of largest = TRUE:
nc &lt;- st_transform(st_read(system.file("shape/nc.shp", package="sf")), 2264)                
gr = st_sf(
    label = apply(expand.grid(1:10, LETTERS[10:1])[,2:1], 1, paste0, collapse = " "),
    geom = st_make_grid(st_as_sfc(st_bbox(nc))))
gr$col = sf.colors(10, categorical = TRUE, alpha = .3)
# cut, to check, NA's work out:
gr = gr[-(1:30),]
nc_j &lt;- st_join(nc, gr, largest = TRUE)
# the two datasets:
opar = par(mfrow = c(2,1), mar = rep(0,4))
plot(st_geometry(nc_j))
plot(st_geometry(gr), add = TRUE, col = gr$col)
text(st_coordinates(st_centroid(gr)), labels = gr$label)
# the joined dataset:
plot(st_geometry(nc_j), border = 'black', col = nc_j$col)
text(st_coordinates(st_centroid(nc_j)), labels = nc_j$label, cex = .8)
plot(st_geometry(gr), border = 'green', add = TRUE)
par(opar)
# st_filter keeps the geometries in x where .predicate(x,y) returns any match in y for x
st_filter(a, b)
# for an anti-join, use the union of y
st_filter(a, st_union(b), .predicate = st_disjoint)
</code></pre>

<hr>
<h2 id='st_layers'>Return properties of layers in a datasource</h2><span id='topic+st_layers'></span>

<h3>Description</h3>

<p>Return properties of layers in a datasource
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_layers(dsn, options = character(0), do_count = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_layers_+3A_dsn">dsn</code></td>
<td>
<p>data source name (interpretation varies by driver - for some drivers, <code>dsn</code> is a file name, but may also be a
folder, or contain the name and access credentials of a database)</p>
</td></tr>
<tr><td><code id="st_layers_+3A_options">options</code></td>
<td>
<p>character; driver dependent dataset open options, multiple options supported.</p>
</td></tr>
<tr><td><code id="st_layers_+3A_do_count">do_count</code></td>
<td>
<p>logical; if TRUE, count the features by reading them, even if their count is not reported by the driver</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list object of class <code>sf_layers</code> with elements
</p>

<dl>
<dt>name</dt><dd><p>name of the layer</p>
</dd>
<dt>geomtype</dt><dd><p>list with for each layer the geometry types</p>
</dd>
<dt>features</dt><dd><p>number of features (if reported; see <code>do_count</code>)</p>
</dd>
<dt>fields</dt><dd><p>number of fields</p>
</dd>
<dt>crs</dt><dd><p>list with for each layer the <code>crs</code> object</p>
</dd>
</dl>


<hr>
<h2 id='st_line_project_point'>Project point on linestring, interpolate along a linestring</h2><span id='topic+st_line_project_point'></span><span id='topic+st_line_project'></span><span id='topic+st_line_interpolate'></span>

<h3>Description</h3>

<p>Project point on linestring, interpolate along a linestring
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_line_project(line, point, normalized = FALSE)

st_line_interpolate(line, dist, normalized = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_line_project_point_+3A_line">line</code></td>
<td>
<p>object of class <code>sfc</code> with <code>LINESTRING</code> geometry</p>
</td></tr>
<tr><td><code id="st_line_project_point_+3A_point">point</code></td>
<td>
<p>object of class <code>sfc</code> with <code>POINT</code> geometry</p>
</td></tr>
<tr><td><code id="st_line_project_point_+3A_normalized">normalized</code></td>
<td>
<p>logical; if <code>TRUE</code>, use or return distance normalised to 0-1</p>
</td></tr>
<tr><td><code id="st_line_project_point_+3A_dist">dist</code></td>
<td>
<p>numeric, vector with distance value(s)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>arguments <code>line</code>, <code>point</code> and <code>dist</code> are recycled to common length when needed
</p>


<h3>Value</h3>

<p><code>st_line_project</code> returns the distance(s) of point(s) along line(s), when projected on the line(s)
</p>
<p><code>st_line_interpolate</code> returns the point(s) at dist(s), when measured along (interpolated on) the line(s)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>st_line_project(st_as_sfc("LINESTRING (0 0, 10 10)"), st_as_sfc(c("POINT (0 0)", "POINT (5 5)")))
st_line_project(st_as_sfc("LINESTRING (0 0, 10 10)"), st_as_sfc("POINT (5 5)"), TRUE)
st_line_interpolate(st_as_sfc("LINESTRING (0 0, 1 1)"), 1)
st_line_interpolate(st_as_sfc("LINESTRING (0 0, 1 1)"), 1, TRUE)
</code></pre>

<hr>
<h2 id='st_line_sample'>Sample points on a linear geometry</h2><span id='topic+st_line_sample'></span>

<h3>Description</h3>

<p>Sample points on a linear geometry
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_line_sample(x, n, density, type = "regular", sample = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_line_sample_+3A_x">x</code></td>
<td>
<p>object of class <code>sf</code>, <code>sfc</code> or <code>sfg</code></p>
</td></tr>
<tr><td><code id="st_line_sample_+3A_n">n</code></td>
<td>
<p>integer; number of points to choose per geometry; if missing, n will be computed as <code>round(density * st_length(geom))</code>.</p>
</td></tr>
<tr><td><code id="st_line_sample_+3A_density">density</code></td>
<td>
<p>numeric; density (points per distance unit) of the sampling, possibly a vector of length equal to the number of features (otherwise recycled); <code>density</code> may be of class <code>units</code>.</p>
</td></tr>
<tr><td><code id="st_line_sample_+3A_type">type</code></td>
<td>
<p>character; indicate the sampling type, either &quot;regular&quot; or &quot;random&quot;</p>
</td></tr>
<tr><td><code id="st_line_sample_+3A_sample">sample</code></td>
<td>
<p>numeric; a vector of numbers between 0 and 1 indicating the points to sample - if defined sample overrules n, density and type.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>ls = st_sfc(st_linestring(rbind(c(0,0),c(0,1))),
	st_linestring(rbind(c(0,0),c(10,0))))
st_line_sample(ls, density = 1)
ls = st_sfc(st_linestring(rbind(c(0,0),c(0,1))),
 st_linestring(rbind(c(0,0),c(.1,0))), crs = 4326)
try(st_line_sample(ls, density = 1/1000)) # error
st_line_sample(st_transform(ls, 3857), n = 5) # five points for each line
st_line_sample(st_transform(ls, 3857), n = c(1, 3)) # one and three points
st_line_sample(st_transform(ls, 3857), density = 1/1000) # one per km
st_line_sample(st_transform(ls, 3857), density = c(1/1000, 1/10000)) # one per km, one per 10 km
st_line_sample(st_transform(ls, 3857), density = units::set_units(1, 1/km)) # one per km
# five equidistant points including start and end:
st_line_sample(st_transform(ls, 3857), sample = c(0, 0.25, 0.5, 0.75, 1))
</code></pre>

<hr>
<h2 id='st_m_range'>Return 'm' range of a simple feature or simple feature set</h2><span id='topic+st_m_range'></span><span id='topic+is.na.m_range'></span><span id='topic+st_m_range.POINT'></span><span id='topic+st_m_range.MULTIPOINT'></span><span id='topic+st_m_range.LINESTRING'></span><span id='topic+st_m_range.POLYGON'></span><span id='topic+st_m_range.MULTILINESTRING'></span><span id='topic+st_m_range.MULTIPOLYGON'></span><span id='topic+st_m_range.GEOMETRYCOLLECTION'></span><span id='topic+st_m_range.MULTISURFACE'></span><span id='topic+st_m_range.MULTICURVE'></span><span id='topic+st_m_range.CURVEPOLYGON'></span><span id='topic+st_m_range.COMPOUNDCURVE'></span><span id='topic+st_m_range.POLYHEDRALSURFACE'></span><span id='topic+st_m_range.TIN'></span><span id='topic+st_m_range.TRIANGLE'></span><span id='topic+st_m_range.CIRCULARSTRING'></span><span id='topic+st_m_range.sfc'></span><span id='topic+st_m_range.sf'></span><span id='topic+st_m_range.numeric'></span><span id='topic+NA_m_range_'></span>

<h3>Description</h3>

<p>Return 'm' range of a simple feature or simple feature set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'm_range'
is.na(x)

st_m_range(obj, ...)

## S3 method for class 'POINT'
st_m_range(obj, ...)

## S3 method for class 'MULTIPOINT'
st_m_range(obj, ...)

## S3 method for class 'LINESTRING'
st_m_range(obj, ...)

## S3 method for class 'POLYGON'
st_m_range(obj, ...)

## S3 method for class 'MULTILINESTRING'
st_m_range(obj, ...)

## S3 method for class 'MULTIPOLYGON'
st_m_range(obj, ...)

## S3 method for class 'GEOMETRYCOLLECTION'
st_m_range(obj, ...)

## S3 method for class 'MULTISURFACE'
st_m_range(obj, ...)

## S3 method for class 'MULTICURVE'
st_m_range(obj, ...)

## S3 method for class 'CURVEPOLYGON'
st_m_range(obj, ...)

## S3 method for class 'COMPOUNDCURVE'
st_m_range(obj, ...)

## S3 method for class 'POLYHEDRALSURFACE'
st_m_range(obj, ...)

## S3 method for class 'TIN'
st_m_range(obj, ...)

## S3 method for class 'TRIANGLE'
st_m_range(obj, ...)

## S3 method for class 'CIRCULARSTRING'
st_m_range(obj, ...)

## S3 method for class 'sfc'
st_m_range(obj, ...)

## S3 method for class 'sf'
st_m_range(obj, ...)

## S3 method for class 'numeric'
st_m_range(obj, ..., crs = NA_crs_)

NA_m_range_
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_m_range_+3A_x">x</code></td>
<td>
<p>object of class <code>m_range</code></p>
</td></tr>
<tr><td><code id="st_m_range_+3A_obj">obj</code></td>
<td>
<p>object to compute the m range from</p>
</td></tr>
<tr><td><code id="st_m_range_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="st_m_range_+3A_crs">crs</code></td>
<td>
<p>object of class <code>crs</code>, or argument to <a href="#topic+st_crs">st_crs</a>, specifying the CRS of this bounding box.</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>m_range</code> of length 2.
</p>


<h3>Details</h3>

<p><code>NA_m_range_</code> represents the missing value for a <code>m_range</code> object
</p>


<h3>Value</h3>

<p>a numeric vector of length two, with <code>mmin</code> and <code>mmax</code> values;
if <code>obj</code> is of class <code>sf</code> or <code>sfc</code> the object
if <code>obj</code> is of class <code>sf</code> or <code>sfc</code> the object
returned has a class <code>m_range</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a = st_sf(a = 1:2, geom = st_sfc(st_point(0:3), st_point(1:4)), crs = 4326)
st_m_range(a)
st_m_range(c(mmin = 16.1, mmax = 16.6), crs = st_crs(4326))
</code></pre>

<hr>
<h2 id='st_make_grid'>Create a regular tesselation over the bounding box of an sf or sfc object</h2><span id='topic+st_make_grid'></span>

<h3>Description</h3>

<p>Create a square or hexagonal grid covering the bounding box of the geometry of an sf or sfc object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_make_grid(
  x,
  cellsize = c(diff(st_bbox(x)[c(1, 3)]), diff(st_bbox(x)[c(2, 4)]))/n,
  offset = st_bbox(x)[c("xmin", "ymin")],
  n = c(10, 10),
  crs = if (missing(x)) NA_crs_ else st_crs(x),
  what = "polygons",
  square = TRUE,
  flat_topped = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_make_grid_+3A_x">x</code></td>
<td>
<p>object of class <a href="#topic+sf">sf</a> or <a href="#topic+sfc">sfc</a></p>
</td></tr>
<tr><td><code id="st_make_grid_+3A_cellsize">cellsize</code></td>
<td>
<p>numeric of length 1 or 2 with target cellsize: for square or rectangular cells the width and height, for hexagonal cells the distance between opposite edges (edge length is cellsize/sqrt(3)). A length units object can be passed, or an area unit object with area size of the square or hexagonal cell.</p>
</td></tr>
<tr><td><code id="st_make_grid_+3A_offset">offset</code></td>
<td>
<p>numeric of length 2; lower left corner coordinates (x, y) of the grid</p>
</td></tr>
<tr><td><code id="st_make_grid_+3A_n">n</code></td>
<td>
<p>integer of length 1 or 2, number of grid cells in x and y direction (columns, rows)</p>
</td></tr>
<tr><td><code id="st_make_grid_+3A_crs">crs</code></td>
<td>
<p>object of class <code>crs</code>; coordinate reference system of the target of the target grid in case argument <code>x</code> is missing, if <code>x</code> is not missing, its crs is inherited.</p>
</td></tr>
<tr><td><code id="st_make_grid_+3A_what">what</code></td>
<td>
<p>character; one of: <code>"polygons"</code>, <code>"corners"</code>, or <code>"centers"</code></p>
</td></tr>
<tr><td><code id="st_make_grid_+3A_square">square</code></td>
<td>
<p>logical; if <code>FALSE</code>, create hexagonal grid</p>
</td></tr>
<tr><td><code id="st_make_grid_+3A_flat_topped">flat_topped</code></td>
<td>
<p>logical; if <code>TRUE</code> generate flat topped hexagons, else generate pointy topped</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>sfc</code> (simple feature geometry list column) with, depending on <code>what</code> and <code>square</code>,
square or hexagonal polygons, corner points of these polygons, or center points of these polygons.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(st_make_grid(what = "centers"), axes = TRUE)
plot(st_make_grid(what = "corners"), add = TRUE, col = 'green', pch=3)
sfc = st_sfc(st_polygon(list(rbind(c(0,0), c(1,0), c(1,1), c(0,0)))))
plot(st_make_grid(sfc, cellsize = .1, square = FALSE))
plot(sfc, add = TRUE)
# non-default offset:
plot(st_make_grid(sfc, cellsize = .1, square = FALSE, offset = c(0, .05 / (sqrt(3)/2))))
plot(sfc, add = TRUE)
nc = st_read(system.file("shape/nc.shp", package="sf"))
g = st_make_grid(nc)
plot(g)
plot(st_geometry(nc), add = TRUE)
# g[nc] selects cells that intersect with nc:
plot(g[nc], col = '#ff000088', add = TRUE)
</code></pre>

<hr>
<h2 id='st_nearest_feature'>get index of nearest feature</h2><span id='topic+st_nearest_feature'></span>

<h3>Description</h3>

<p>get index of nearest feature
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_nearest_feature(
  x,
  y,
  ...,
  check_crs = TRUE,
  longlat = isTRUE(st_is_longlat(x))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_nearest_feature_+3A_x">x</code></td>
<td>
<p>object of class <code>sfg</code>, <code>sfc</code> or <code>sf</code></p>
</td></tr>
<tr><td><code id="st_nearest_feature_+3A_y">y</code></td>
<td>
<p>object of class <code>sfg</code>, <code>sfc</code> or <code>sf</code>; if missing, features in <code>x</code> will be compared to all remaining features in <code>x</code>.</p>
</td></tr>
<tr><td><code id="st_nearest_feature_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="st_nearest_feature_+3A_check_crs">check_crs</code></td>
<td>
<p>logical; should <code>x</code> and <code>y</code> be checked for CRS equality?</p>
</td></tr>
<tr><td><code id="st_nearest_feature_+3A_longlat">longlat</code></td>
<td>
<p>logical; does <code>x</code> have ellipsoidal coordinates?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>for each feature (geometry) in <code>x</code> the index of the nearest feature (geometry) in
set <code>y</code>, or in the remaining set of <code>x</code> if <code>y</code> is missing;
empty geometries result in <code>NA</code> indexes
</p>


<h3>See Also</h3>

<p><a href="#topic+st_nearest_points">st_nearest_points</a> for finding the nearest points for pairs of feature geometries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ls1 = st_linestring(rbind(c(0,0), c(1,0)))
ls2 = st_linestring(rbind(c(0,0.1), c(1,0.1)))
ls3 = st_linestring(rbind(c(0,1), c(1,1)))
(l = st_sfc(ls1, ls2, ls3))

p1 = st_point(c(0.1, -0.1))
p2 = st_point(c(0.1, 0.11))
p3 = st_point(c(0.1, 0.09))
p4 = st_point(c(0.1, 0.9))

(p = st_sfc(p1, p2, p3, p4))
try(st_nearest_feature(p, l))
try(st_nearest_points(p, l[st_nearest_feature(p,l)], pairwise = TRUE))

r = sqrt(2)/10
b1 = st_buffer(st_point(c(.1,.1)), r)
b2 = st_buffer(st_point(c(.9,.9)), r)
b3 = st_buffer(st_point(c(.9,.1)), r)
circles = st_sfc(b1, b2, b3)
plot(circles, col = NA, border = 2:4)
pts = st_sfc(st_point(c(.3,.1)), st_point(c(.6,.2)), st_point(c(.6,.6)), st_point(c(.4,.8)))
plot(pts, add = TRUE, col = 1)
# draw points to nearest circle:
nearest = try(st_nearest_feature(pts, circles))
if (inherits(nearest, "try-error")) # GEOS 3.6.1 not available
  nearest = c(1, 3, 2, 2)
ls = st_nearest_points(pts, circles[nearest], pairwise = TRUE)
plot(ls, col = 5:8, add = TRUE)
# compute distance between pairs of nearest features:
st_distance(pts, circles[nearest], by_element = TRUE)
</code></pre>

<hr>
<h2 id='st_nearest_points'>get nearest points between pairs of geometries</h2><span id='topic+st_nearest_points'></span><span id='topic+st_nearest_points.sfc'></span><span id='topic+st_nearest_points.sfg'></span><span id='topic+st_nearest_points.sf'></span>

<h3>Description</h3>

<p>get nearest points between pairs of geometries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_nearest_points(x, y, ...)

## S3 method for class 'sfc'
st_nearest_points(x, y, ..., pairwise = FALSE)

## S3 method for class 'sfg'
st_nearest_points(x, y, ...)

## S3 method for class 'sf'
st_nearest_points(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_nearest_points_+3A_x">x</code></td>
<td>
<p>object of class <code>sfg</code>, <code>sfc</code> or <code>sf</code></p>
</td></tr>
<tr><td><code id="st_nearest_points_+3A_y">y</code></td>
<td>
<p>object of class <code>sfg</code>, <code>sfc</code> or <code>sf</code></p>
</td></tr>
<tr><td><code id="st_nearest_points_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="st_nearest_points_+3A_pairwise">pairwise</code></td>
<td>
<p>logical; if <code>FALSE</code> (default) return nearest points between all pairs, if <code>TRUE</code>, return nearest points between subsequent pairs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>in case <code>x</code> lies inside <code>y</code>, when using S2, the end points
are on polygon boundaries, when using GEOS the end point are identical to <code>x</code>.
</p>


<h3>Value</h3>

<p>an <a href="#topic+sfc">sfc</a> object with all two-point <code>LINESTRING</code> geometries of point pairs from the first to the second geometry, of length x * y, with y cycling fastest. See examples for ideas how to convert these to <code>POINT</code> geometries.
</p>


<h3>See Also</h3>

<p><a href="#topic+st_nearest_feature">st_nearest_feature</a> for finding the nearest feature
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r = sqrt(2)/10
pt1 = st_point(c(.1,.1))
pt2 = st_point(c(.9,.9))
pt3 = st_point(c(.9,.1))
b1 = st_buffer(pt1, r)
b2 = st_buffer(pt2, r)
b3 = st_buffer(pt3, r)
(ls0 = st_nearest_points(b1, b2)) # sfg
(ls = st_nearest_points(st_sfc(b1), st_sfc(b2, b3))) # sfc
plot(b1, xlim = c(-.2,1.2), ylim = c(-.2,1.2), col = NA, border = 'green')
plot(st_sfc(b2, b3), add = TRUE, col = NA, border = 'blue')
plot(ls, add = TRUE, col = 'red')

nc = st_read(system.file("gpkg/nc.gpkg", package="sf"))
plot(st_geometry(nc))
ls = st_nearest_points(nc[1,], nc)
plot(ls, col = 'red', add = TRUE)
pts = st_cast(ls, "POINT") # gives all start &amp; end points
# starting, "from" points, corresponding to x:
plot(pts[seq(1, 200, 2)], add = TRUE, col = 'blue')
# ending, "to" points, corresponding to y:
plot(pts[seq(2, 200, 2)], add = TRUE, col = 'green')

</code></pre>

<hr>
<h2 id='st_normalize'>Normalize simple features</h2><span id='topic+st_normalize'></span>

<h3>Description</h3>

<p><code>st_normalize</code> transforms the coordinates in the input feature to fall
between 0 and 1. By default the current domain is set to the bounding box of
the input, but other domains can be used as well
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_normalize(x, domain = st_bbox(x), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_normalize_+3A_x">x</code></td>
<td>
<p>object of class sf, sfc or sfg</p>
</td></tr>
<tr><td><code id="st_normalize_+3A_domain">domain</code></td>
<td>
<p>The domain <code>x</code> should be normalized from as a length 4
vector of the form <code>c(xmin, ymin, xmax, ymax)</code>. Defaults to the
bounding box of <code>x</code></p>
</td></tr>
<tr><td><code id="st_normalize_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>p1 = st_point(c(7,52))
st_normalize(p1, domain = c(0, 0, 10, 100))

p2 = st_point(c(-30,20))
sfc = st_sfc(p1, p2, crs = 4326)
sfc
sfc_norm &lt;- st_normalize(sfc)
st_bbox(sfc_norm)

</code></pre>

<hr>
<h2 id='st_precision'>Get precision</h2><span id='topic+st_precision'></span><span id='topic+st_set_precision'></span><span id='topic+st_precision+3C-'></span>

<h3>Description</h3>

<p>Get precision
</p>
<p>Set precision
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_precision(x)

st_set_precision(x, precision)

st_precision(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_precision_+3A_x">x</code></td>
<td>
<p>object of class <code>sfc</code> or <code>sf</code></p>
</td></tr>
<tr><td><code id="st_precision_+3A_precision">precision</code></td>
<td>
<p>numeric, or object of class <code>units</code> with distance units (but see details); see <a href="#topic+st_as_binary">st_as_binary</a> for how to do this.</p>
</td></tr>
<tr><td><code id="st_precision_+3A_value">value</code></td>
<td>
<p>precision value</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>precision</code> is a <code>units</code> object, the object on which we set precision must have a coordinate reference system with compatible distance units.
</p>
<p>Setting a <code>precision</code> has no direct effect on coordinates of geometries, but merely set an attribute tag to an <code>sfc</code> object.
The effect takes place in <a href="#topic+st_as_binary">st_as_binary</a> or, more precise, in the C++ function <code>CPL_write_wkb</code>, where simple feature geometries are being serialized to well-known-binary (WKB).
This happens always when routines are called in GEOS library (geometrical operations or predicates), for writing geometries using <a href="#topic+st_write">st_write</a> or <a href="#topic+write_sf">write_sf</a>, <code>st_make_valid</code> in package <code>lwgeom</code>; also <a href="#topic+aggregate">aggregate</a> and <a href="#topic+summarise">summarise</a> by default union geometries, which calls a GEOS library function.
Routines in these libraries receive rounded coordinates, and possibly return results based on them. <a href="#topic+st_as_binary">st_as_binary</a> contains an example of a roundtrip of <code>sfc</code> geometries through WKB, in order to see the rounding happening to R data.
</p>
<p>The reason to support precision is that geometrical operations in GEOS or liblwgeom may work better at reduced precision. For writing data from R to external resources it is harder to think of a good reason to limiting precision.
</p>


<h3>See Also</h3>

<p><a href="#topic+st_as_binary">st_as_binary</a> for an explanation of what setting precision does, and the examples therein.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- st_sfc(st_point(c(pi, pi)))
st_precision(x)
st_precision(x) &lt;- 0.01
st_precision(x)
</code></pre>

<hr>
<h2 id='st_read'>Read simple features or layers from file or database</h2><span id='topic+st_read'></span><span id='topic+st_read.character'></span><span id='topic+read_sf'></span><span id='topic+st_read.DBIObject'></span>

<h3>Description</h3>

<p>Read simple features from file or database, or retrieve layer names and their
geometry type(s)
</p>
<p>Read PostGIS table directly through DBI and RPostgreSQL interface, converting
Well-Know Binary geometries to sfc
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_read(dsn, layer, ...)

## S3 method for class 'character'
st_read(
  dsn,
  layer,
  ...,
  query = NA,
  options = NULL,
  quiet = FALSE,
  geometry_column = 1L,
  type = 0,
  promote_to_multi = TRUE,
  stringsAsFactors = sf_stringsAsFactors(),
  int64_as_string = FALSE,
  check_ring_dir = FALSE,
  fid_column_name = character(0),
  drivers = character(0),
  wkt_filter = character(0),
  optional = FALSE,
  use_stream = default_st_read_use_stream()
)

read_sf(..., quiet = TRUE, stringsAsFactors = FALSE, as_tibble = TRUE)

## S3 method for class 'DBIObject'
st_read(
  dsn = NULL,
  layer = NULL,
  query = NULL,
  EWKB = TRUE,
  quiet = TRUE,
  as_tibble = FALSE,
  geometry_column = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_read_+3A_dsn">dsn</code></td>
<td>
<p>data source name (interpretation varies by driver - for some
drivers, <code>dsn</code> is a file name, but may also be a folder, or contain
the name and access credentials of a database); in case of GeoJSON,
<code>dsn</code> may be the character string holding the geojson data. It can
also be an open database connection.</p>
</td></tr>
<tr><td><code id="st_read_+3A_layer">layer</code></td>
<td>
<p>layer name (varies by driver, may be a file name without
extension); in case <code>layer</code> is missing, <code>st_read</code> will read the
first layer of <code>dsn</code>, give a warning and (unless <code>quiet = TRUE</code>)
print a message when there are multiple layers, or give an error if there
are no layers in <code>dsn</code>. If <code>dsn</code> is a database connection, then
<code>layer</code> can be a table name or a database identifier (see
<code><a href="DBI.html#topic+Id">Id</a></code>). It is also possible to omit <code>layer</code> and rather
use the <code>query</code> argument.</p>
</td></tr>
<tr><td><code id="st_read_+3A_...">...</code></td>
<td>
<p>parameter(s) passed on to <a href="#topic+st_as_sf">st_as_sf</a></p>
</td></tr>
<tr><td><code id="st_read_+3A_query">query</code></td>
<td>
<p>SQL query to select records; see details</p>
</td></tr>
<tr><td><code id="st_read_+3A_options">options</code></td>
<td>
<p>character; driver dependent dataset open options, multiple
options supported. For possible values, see the &quot;Open options&quot; section
of the GDAL documentation of the corresponding driver, and
<a href="https://github.com/r-spatial/sf/issues/1157">https://github.com/r-spatial/sf/issues/1157</a> for an example.</p>
</td></tr>
<tr><td><code id="st_read_+3A_quiet">quiet</code></td>
<td>
<p>logical; suppress info on name, driver, size and spatial
reference, or signaling no or multiple layers</p>
</td></tr>
<tr><td><code id="st_read_+3A_geometry_column">geometry_column</code></td>
<td>
<p>integer or character; in case of multiple geometry
fields, which one to take?</p>
</td></tr>
<tr><td><code id="st_read_+3A_type">type</code></td>
<td>
<p>integer; ISO number of desired simple feature type; see details.
If left zero, and <code>promote_to_multi</code> is <code>TRUE</code>, in case of mixed
feature geometry types, conversion to the highest numeric type value found
will be attempted. A vector with different values for each geometry column
can be given.</p>
</td></tr>
<tr><td><code id="st_read_+3A_promote_to_multi">promote_to_multi</code></td>
<td>
<p>logical; in case of a mix of Point and MultiPoint, or
of LineString and MultiLineString, or of Polygon and MultiPolygon, convert
all to the Multi variety; defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="st_read_+3A_stringsasfactors">stringsAsFactors</code></td>
<td>
<p>logical; logical: should character vectors be
converted to factors?  Default for <code>read_sf</code> or R version &gt;= 4.1.0 is
<code>FALSE</code>, for <code>st_read</code> and R version &lt; 4.1.0 equal to
<code>default.stringsAsFactors()</code></p>
</td></tr>
<tr><td><code id="st_read_+3A_int64_as_string">int64_as_string</code></td>
<td>
<p>logical; if <code>TRUE</code>, Int64 attributes are returned as
string; if <code>FALSE</code>, they are returned as double and a warning is given when
precision is lost (i.e., values are larger than 2^53).</p>
</td></tr>
<tr><td><code id="st_read_+3A_check_ring_dir">check_ring_dir</code></td>
<td>
<p>logical; if <code>TRUE</code>, polygon ring directions are checked
and if necessary corrected (when seen from above: exterior ring counter
clockwise, holes clockwise)</p>
</td></tr>
<tr><td><code id="st_read_+3A_fid_column_name">fid_column_name</code></td>
<td>
<p>character; name of column to write feature IDs to; defaults to not doing this</p>
</td></tr>
<tr><td><code id="st_read_+3A_drivers">drivers</code></td>
<td>
<p>character; limited set of driver short names to be tried (default: try all)</p>
</td></tr>
<tr><td><code id="st_read_+3A_wkt_filter">wkt_filter</code></td>
<td>
<p>character; WKT representation of a spatial filter (may be used as bounding box, selecting overlapping geometries); see examples</p>
</td></tr>
<tr><td><code id="st_read_+3A_optional">optional</code></td>
<td>
<p>logical; passed to <a href="base.html#topic+as.data.frame">as.data.frame</a>; always <code>TRUE</code> when <code>as_tibble</code> is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="st_read_+3A_use_stream">use_stream</code></td>
<td>
<p>Use <code>TRUE</code> to use the experimental columnar interface introduced in GDAL 3.6.</p>
</td></tr>
<tr><td><code id="st_read_+3A_as_tibble">as_tibble</code></td>
<td>
<p>logical; should the returned table be of class tibble or data.frame?</p>
</td></tr>
<tr><td><code id="st_read_+3A_ewkb">EWKB</code></td>
<td>
<p>logical; is the WKB of type EWKB? if missing, defaults to
<code>TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>for <code>geometry_column</code>, see also
<a href="https://trac.osgeo.org/gdal/wiki/rfc41_multiple_geometry_fields">https://trac.osgeo.org/gdal/wiki/rfc41_multiple_geometry_fields</a>
</p>
<p>for values for <code>type</code> see
<a href="https://en.wikipedia.org/wiki/Well-known_text#Well-known_binary">https://en.wikipedia.org/wiki/Well-known_text#Well-known_binary</a>, but
note that not every target value may lead to successful conversion. The
typical conversion from POLYGON (3) to MULTIPOLYGON (6) should work; the
other way around (type=3), secondary rings from MULTIPOLYGONS may be dropped
without warnings. <code>promote_to_multi</code> is handled on a per-geometry column
basis; <code>type</code> may be specified for each geometry column.
</p>
<p>Note that stray files in data source directories (such as <code>*.dbf</code>) may
lead to spurious errors that accompanying <code>*.shp</code> are missing.
</p>
<p>In case of problems reading shapefiles from USB drives on OSX, please see
<a href="https://github.com/r-spatial/sf/issues/252">https://github.com/r-spatial/sf/issues/252</a>. Reading shapefiles (or other
data sources) directly from zip files can be done by prepending the path
with <code>/vsizip/</code>. This is part of the GDAL Virtual File Systems interface
that also supports .gz, curl, and other operations, including chaining; see
<a href="https://gdal.org/user/virtual_file_systems.html">https://gdal.org/user/virtual_file_systems.html</a> for a complete
description and examples.
</p>
<p>For <code>query</code> with a character <code>dsn</code> the query text is handed to
'ExecuteSQL' on the GDAL/OGR data set and will result in the creation of a
new layer (and <code>layer</code> is ignored). See 'OGRSQL'
<a href="https://gdal.org/user/ogr_sql_dialect.html">https://gdal.org/user/ogr_sql_dialect.html</a> for details. Please note that the
'FID' special field is driver-dependent, and may be either 0-based (e.g. ESRI
Shapefile), 1-based (e.g. MapInfo) or arbitrary (e.g. OSM). Other features of
OGRSQL are also likely to be driver dependent. The available layer names may
be obtained with
<a href="#topic+st_layers">st_layers</a>. Care will be required to properly escape the use of some layer names.
</p>
<p><code>read_sf</code> and <code>write_sf</code> are aliases for <code>st_read</code> and <code>st_write</code>, respectively, with some
modified default arguments.
<code>read_sf</code> and <code>write_sf</code> are quiet by default: they do not print information
about the data source. <code>read_sf</code> returns an sf-tibble rather than an sf-data.frame.
<code>write_sf</code> delete layers by default: it overwrites existing files without asking or warning.
</p>
<p>if <code>table</code> is not given but <code>query</code> is, the spatial
reference system (crs) of the table queried is only available in case it
has been stored into each geometry record (e.g., by PostGIS, when using
EWKB)
</p>
<p>The function will automatically find the <code>geometry</code> type columns for
drivers that support it. For the other drivers, it will try to cast all the
character columns, which can be slow for very wide tables.
</p>


<h3>Value</h3>

<p>object of class <a href="#topic+sf">sf</a> when a layer was successfully read; in case
argument <code>layer</code> is missing and data source <code>dsn</code> does not
contain a single layer, an object of class <code>sf_layers</code> is returned
with the layer names, each with their geometry type(s). Note that the
number of layers may also be zero.
</p>


<h3>Note</h3>

<p>The use of <code>system.file</code> in examples make sure that examples run regardless where R is installed:
typical users will not use <code>system.file</code> but give the file name directly, either with full path or relative
to the current working directory (see <a href="base.html#topic+getwd">getwd</a>). &quot;Shapefiles&quot; consist of several files with the same basename
that reside in the same directory, only one of them having extension <code>.shp</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+st_layers">st_layers</a>, <a href="#topic+st_drivers">st_drivers</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nc = st_read(system.file("shape/nc.shp", package="sf"))
summary(nc) # note that AREA was computed using Euclidian area on lon/lat degrees

## only three fields by select clause
## only two features by where clause
nc_sql = st_read(system.file("shape/nc.shp", package="sf"),
                     query = "SELECT NAME, SID74, FIPS FROM \"nc\" WHERE BIR74 &gt; 20000")
## Not run: 
  library(sp)
  example(meuse, ask = FALSE, echo = FALSE)
  try(st_write(st_as_sf(meuse), "PG:dbname=postgis", "meuse",
       layer_options = "OVERWRITE=true"))
  try(st_meuse &lt;- st_read("PG:dbname=postgis", "meuse"))
  if (exists("st_meuse"))
    summary(st_meuse)

## End(Not run)

## Not run: 
## note that we need special escaping of layer  within single quotes (nc.gpkg)
## and that geom needs to be included in the select, otherwise we don't detect it
layer &lt;- st_layers(system.file("gpkg/nc.gpkg", package = "sf"))$name[1]
nc_gpkg_sql = st_read(system.file("gpkg/nc.gpkg", package = "sf"),
   query = sprintf("SELECT NAME, SID74, FIPS, geom  FROM \"%s\" WHERE BIR74 &gt; 20000", layer))

## End(Not run)
# spatial filter, as wkt:
wkt = st_as_text(st_geometry(nc[1,]))
# filter by (bbox overlaps of) first feature geometry:
st_read(system.file("gpkg/nc.gpkg", package="sf"), wkt_filter = wkt)
# read geojson from string:
geojson_txt &lt;- paste("{\"type\":\"MultiPoint\",\"coordinates\":",
   "[[3.2,4],[3,4.6],[3.8,4.4],[3.5,3.8],[3.4,3.6],[3.9,4.5]]}")
x = st_read(geojson_txt)
x
## Not run: 
library(RPostgreSQL)
try(conn &lt;- dbConnect(PostgreSQL(), dbname = "postgis"))
if (exists("conn") &amp;&amp; !inherits(conn, "try-error")) {
  x = st_read(conn, "meuse", query = "select * from meuse limit 3;")
  x = st_read(conn, table = "public.meuse")
  print(st_crs(x)) # SRID resolved by the database, not by GDAL!
  dbDisconnect(conn)
 }

## End(Not run)
</code></pre>

<hr>
<h2 id='st_relate'>Compute DE9-IM relation between pairs of geometries, or match it to a given pattern</h2><span id='topic+st_relate'></span>

<h3>Description</h3>

<p>Compute DE9-IM relation between pairs of geometries, or match it to a given pattern
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_relate(x, y, pattern = NA_character_, sparse = !is.na(pattern))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_relate_+3A_x">x</code></td>
<td>
<p>object of class <code>sf</code>, <code>sfc</code> or <code>sfg</code></p>
</td></tr>
<tr><td><code id="st_relate_+3A_y">y</code></td>
<td>
<p>object of class <code>sf</code>, <code>sfc</code> or <code>sfg</code></p>
</td></tr>
<tr><td><code id="st_relate_+3A_pattern">pattern</code></td>
<td>
<p>character; define the pattern to match to, see details.</p>
</td></tr>
<tr><td><code id="st_relate_+3A_sparse">sparse</code></td>
<td>
<p>logical; should a sparse matrix be returned (<code>TRUE</code>) or a dense matrix?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case <code>pattern</code> is not given, <code>st_relate</code> returns a dense <code>character</code> matrix; element <code style="white-space: pre;">&#8288;[i,j]&#8288;</code> has nine characters, referring to the DE9-IM relationship between <code>x[i]</code> and <code>y[j]</code>, encoded as IxIy,IxBy,IxEy,BxIy,BxBy,BxEy,ExIy,ExBy,ExEy where I refers to interior, B to boundary, and E to exterior, and e.g. BxIy the dimensionality of the intersection of the the boundary of <code>x[i]</code> and the interior of <code>y[j]</code>, which is one of: 0, 1, 2, or F; digits denoting dimensionality of intersection, F denoting no intersection. When <code>pattern</code> is given, a dense logical matrix or sparse index list returned with matches to the given pattern; see <a href="#topic+st_intersection">st_intersection</a> for a description of the returned matrix or list. See also <a href="https://en.wikipedia.org/wiki/DE-9IM">https://en.wikipedia.org/wiki/DE-9IM</a> for further explanation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p1 = st_point(c(0,0))
p2 = st_point(c(2,2))
pol1 = st_polygon(list(rbind(c(0,0),c(1,0),c(1,1),c(0,1),c(0,0)))) - 0.5
pol2 = pol1 + 1
pol3 = pol1 + 2
st_relate(st_sfc(p1, p2), st_sfc(pol1, pol2, pol3))
sfc = st_sfc(st_point(c(0,0)), st_point(c(3,3)))
grd = st_make_grid(sfc, n = c(3,3))
st_intersects(grd)
st_relate(grd, pattern = "****1****") # sides, not corners, internals
st_relate(grd, pattern = "****0****") # only corners touch
st_rook = function(a, b = a) st_relate(a, b, pattern = "F***1****")
st_rook(grd)
# queen neighbours, see \url{https://github.com/r-spatial/sf/issues/234#issuecomment-300511129}
st_queen &lt;- function(a, b = a) st_relate(a, b, pattern = "F***T****")
</code></pre>

<hr>
<h2 id='st_sample'>sample points on or in (sets of) spatial features</h2><span id='topic+st_sample'></span><span id='topic+st_sample.sf'></span><span id='topic+st_sample.sfc'></span><span id='topic+st_sample.sfg'></span><span id='topic+st_sample.bbox'></span>

<h3>Description</h3>

<p>Sample points on or in (sets of) spatial features.
By default, returns a pre-specified number of points that is equal to
<code>size</code> (if <code>type = "random"</code> and <code>exact = TRUE</code>) or an approximation of
<code>size</code> otherwise. <code>spatstat</code> methods are
interfaced and do not use the <code>size</code> argument, see examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_sample(x, size, ...)

## S3 method for class 'sf'
st_sample(x, size, ...)

## S3 method for class 'sfc'
st_sample(
  x,
  size,
  ...,
  type = "random",
  exact = TRUE,
  warn_if_not_integer = TRUE,
  by_polygon = FALSE,
  progress = FALSE,
  force = FALSE
)

## S3 method for class 'sfg'
st_sample(x, size, ...)

## S3 method for class 'bbox'
st_sample(
  x,
  size,
  ...,
  great_circles = FALSE,
  segments = units::set_units(2, "degree", mode = "standard")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_sample_+3A_x">x</code></td>
<td>
<p>object of class <code>sf</code> or <code>sfc</code></p>
</td></tr>
<tr><td><code id="st_sample_+3A_size">size</code></td>
<td>
<p>sample size(s) requested; either total size, or a numeric vector with sample sizes for each feature geometry. When sampling polygons, the returned sampling size may differ from the requested size, as the bounding box is sampled, and sampled points intersecting the polygon are returned.</p>
</td></tr>
<tr><td><code id="st_sample_+3A_...">...</code></td>
<td>
<p>passed on to <a href="base.html#topic+sample">sample</a> for <code>multipoint</code> sampling, or to <code>spatstat</code> functions for spatstat sampling types (see details)</p>
</td></tr>
<tr><td><code id="st_sample_+3A_type">type</code></td>
<td>
<p>character; indicates the spatial sampling type; one of <code>random</code>, <code>hexagonal</code> (triangular really), <code>regular</code>, <code>Fibonacci</code>,
or one of the <code>spatstat</code> methods such as <code>Thomas</code> for calling <code>spatstat.random::rThomas</code> (see Details).</p>
</td></tr>
<tr><td><code id="st_sample_+3A_exact">exact</code></td>
<td>
<p>logical; should the length of output be exactly</p>
</td></tr>
<tr><td><code id="st_sample_+3A_warn_if_not_integer">warn_if_not_integer</code></td>
<td>
<p>logical; if <code>FALSE</code> then no warning is emitted if <code>size</code> is not an integer</p>
</td></tr>
<tr><td><code id="st_sample_+3A_by_polygon">by_polygon</code></td>
<td>
<p>logical; for <code>MULTIPOLYGON</code> geometries, should the effort be split by <code>POLYGON</code>? See https://github.com/r-spatial/sf/issues/1480
the same as specified by <code>size</code>? <code>TRUE</code> by default. Only applies to polygons, and
when <code>type = "random"</code>.</p>
</td></tr>
<tr><td><code id="st_sample_+3A_progress">progress</code></td>
<td>
<p>logical; if <code>TRUE</code> show progress bar (only if <code>size</code> is a vector).</p>
</td></tr>
<tr><td><code id="st_sample_+3A_force">force</code></td>
<td>
<p>logical; if <code>TRUE</code> continue when the sampled bounding box area is more than 1e4 times the area of interest, else (default) stop with an error. If this error is not justified, try setting <code>oriented=TRUE</code>, see details.</p>
</td></tr>
<tr><td><code id="st_sample_+3A_great_circles">great_circles</code></td>
<td>
<p>logical; if <code>TRUE</code>, great circle arcs are used to connect the bounding box vertices, if <code>FALSE</code> parallels (graticules)</p>
</td></tr>
<tr><td><code id="st_sample_+3A_segments">segments</code></td>
<td>
<p>units, or numeric (degrees); segment sizes for segmenting a bounding box polygon if <code>great_circles</code> is <code>FALSE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is vectorised: it samples <code>size</code> points across all geometries in
the object if <code>size</code> is a single number, or the specified number of points
in each feature if <code>size</code> is a vector of integers equal in length to the geometry
of <code>x</code>.
</p>
<p>if <code>x</code> has dimension 2 (polygons) and geographical coordinates (long/lat), uniform random sampling on the sphere is applied, see e.g. <a href="https://mathworld.wolfram.com/SpherePointPicking.html">https://mathworld.wolfram.com/SpherePointPicking.html</a>.
</p>
<p>For <code>regular</code> or <code>hexagonal</code> sampling of polygons, the resulting size is only an approximation.
</p>
<p>As parameter called <code>offset</code> can be passed to control (&quot;fix&quot;) regular or hexagonal sampling: for polygons a length 2 numeric vector (by default: a random point from <code>st_bbox(x)</code>); for lines use a number like <code>runif(1)</code>.
</p>
<p>Fibonacci sampling see: Alvaro Gonzalez, 2010. Measurement of Areas on a Sphere Using Fibonacci and Latitude-Longitude Lattices.
Mathematical Geosciences 42(1), p. 49-64
</p>
<p>For regular sampling on the sphere, see also <code>geosphere::regularCoordinates</code>.
</p>
<p>Sampling methods from package <code>spatstat</code> are interfaced (see examples), and need their own parameters to be set.
For instance, to use <code>spatstat.random::rThomas()</code>, set <code>type = "Thomas"</code>.
</p>
<p>For sampling polygons one can specify <code>oriented=TRUE</code> to make sure that polygons larger than half the globe are not reverted, e.g. when specifying a polygon from a bounding box of a global dataset. The <code>st_sample</code> method for <code>bbox</code> does this by default.
</p>


<h3>Value</h3>

<p>an <code>sfc</code> object containing the sampled <code>POINT</code> geometries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nc = st_read(system.file("shape/nc.shp", package="sf"))
p1 = st_sample(nc[1:3, ], 6)
p2 = st_sample(nc[1:3, ], 1:3)
plot(st_geometry(nc)[1:3])
plot(p1, add = TRUE)
plot(p2, add = TRUE, pch = 2)
x = st_sfc(st_polygon(list(rbind(c(0,0),c(90,0),c(90,90),c(0,90),c(0,0)))), crs = st_crs(4326))
plot(x, axes = TRUE, graticule = TRUE)
if (sf_extSoftVersion()["proj.4"] &gt;= "4.9.0")
  plot(p &lt;- st_sample(x, 1000), add = TRUE)
if (require(lwgeom, quietly = TRUE)) { # for st_segmentize()
  x2 = st_transform(st_segmentize(x, 1e4), st_crs("+proj=ortho +lat_0=30 +lon_0=45"))
  g = st_transform(st_graticule(), st_crs("+proj=ortho +lat_0=30 +lon_0=45"))
  plot(x2, graticule = g)
  if (sf_extSoftVersion()["proj.4"] &gt;= "4.9.0") {
    p2 = st_transform(p, st_crs("+proj=ortho +lat_0=30 +lon_0=45"))
    plot(p2, add = TRUE)
  }
}
x = st_sfc(st_polygon(list(rbind(c(0,0),c(90,0),c(90,10),c(0,90),c(0,0))))) # NOT long/lat:
plot(x)
p_exact = st_sample(x, 1000, exact = TRUE)
p_not_exact = st_sample(x, 1000, exact = FALSE)
length(p_exact); length(p_not_exact)
plot(st_sample(x, 1000), add = TRUE)
x = st_sfc(st_polygon(list(rbind(c(-180,-90),c(180,-90),c(180,90),c(-180,90),c(-180,-90)))),
 crs=st_crs(4326))
# FIXME:
#if (sf_extSoftVersion()["proj.4"] &gt;= "4.9.0") {
#  p = st_sample(x, 1000)
#  st_sample(p, 3)
#}
# hexagonal:
sfc = st_sfc(st_polygon(list(rbind(c(0,0), c(1,0), c(1,1), c(0,0)))))
plot(sfc)
h = st_sample(sfc, 100, type = "hexagonal")
h1 = st_sample(sfc, 100, type = "hexagonal")
plot(h, add = TRUE)
plot(h1, col = 'red', add = TRUE)
c(length(h), length(h1)) # approximate!
pt = st_multipoint(matrix(1:20,,2))
ls = st_sfc(st_linestring(rbind(c(0,0),c(0,1))),
 st_linestring(rbind(c(0,0),c(.1,0))),
 st_linestring(rbind(c(0,1),c(.1,1))),
 st_linestring(rbind(c(2,2),c(2,2.00001))))
st_sample(ls, 80)
plot(st_sample(ls, 80))
# spatstat example:
if (require(spatstat.random)) {
  x &lt;- sf::st_sfc(sf::st_polygon(list(rbind(c(0, 0), c(10, 0), c(10, 10), c(0, 0)))))
  # for spatstat.random::rThomas(), set type = "Thomas":
  pts &lt;- st_sample(x, kappa = 1, mu = 10, scale = 0.1, type = "Thomas") 
}
bbox = st_bbox(
c(xmin = 0, xmax = 40, ymax = 70, ymin = 60),
	crs = st_crs('OGC:CRS84')
)
set.seed(13531)
s1 = st_sample(bbox, 400)
st_bbox(s1) # within bbox
s2 = st_sample(bbox, 400, great_circles = TRUE)
st_bbox(s2) # outside bbox
</code></pre>

<hr>
<h2 id='st_shift_longitude'>Shift or re-center geographical coordinates for a Pacific view</h2><span id='topic+st_shift_longitude'></span><span id='topic+st_shift_longitude.sfc'></span><span id='topic+st_shift_longitude.sf'></span>

<h3>Description</h3>

<p>All longitudes &lt; 0 are added to 360, to avoid for instance parts of Alaska
being represented on the far left and right of a plot because they have
values straddling 180 degrees. In general, using a projected
coordinate reference system is to be preferred, but this method permits a
geographical coordinate reference system to be used. This is the sf
equivalent of <a href="sp.html#topic+recenter-methods">recenter</a> in the sp package and
<code>ST_ShiftLongitude</code> in PostGIS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_shift_longitude(x)

## S3 method for class 'sfc'
st_shift_longitude(x, ...)

## S3 method for class 'sf'
st_shift_longitude(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_shift_longitude_+3A_x">x</code></td>
<td>
<p>object of class <code>sf</code> or <code>sfc</code></p>
</td></tr>
<tr><td><code id="st_shift_longitude_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## sfc
pt1 = st_point(c(-170, 50))
pt2 = st_point(c(170, 50))
(sfc = st_sfc(pt1, pt2))
sfc = st_set_crs(sfc, 4326)
st_shift_longitude(sfc)

## sf
d = st_as_sf(data.frame(id = 1:2, geometry = sfc))
st_shift_longitude(d)
</code></pre>

<hr>
<h2 id='st_transform'>Transform or convert coordinates of simple feature</h2><span id='topic+st_transform'></span><span id='topic+st_can_transform'></span><span id='topic+st_transform.sfc'></span><span id='topic+st_transform.sf'></span><span id='topic+st_transform.sfg'></span><span id='topic+st_wrap_dateline'></span><span id='topic+st_wrap_dateline.sfc'></span><span id='topic+st_wrap_dateline.sf'></span><span id='topic+st_wrap_dateline.sfg'></span><span id='topic+sf_proj_info'></span>

<h3>Description</h3>

<p>Transform or convert coordinates of simple feature
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_can_transform(src, dst)

st_transform(x, crs, ...)

## S3 method for class 'sfc'
st_transform(
  x,
  crs = st_crs(x),
  ...,
  aoi = numeric(0),
  pipeline = character(0),
  reverse = FALSE,
  desired_accuracy = -1,
  allow_ballpark = TRUE,
  partial = TRUE,
  check = FALSE
)

## S3 method for class 'sf'
st_transform(x, crs = st_crs(x), ...)

## S3 method for class 'sfg'
st_transform(x, crs = st_crs(x), ...)

st_wrap_dateline(x, options, quiet)

## S3 method for class 'sfc'
st_wrap_dateline(x, options = "WRAPDATELINE=YES", quiet = TRUE)

## S3 method for class 'sf'
st_wrap_dateline(x, options = "WRAPDATELINE=YES", quiet = TRUE)

## S3 method for class 'sfg'
st_wrap_dateline(x, options = "WRAPDATELINE=YES", quiet = TRUE)

sf_proj_info(type = "proj", path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_transform_+3A_src">src</code></td>
<td>
<p>source crs</p>
</td></tr>
<tr><td><code id="st_transform_+3A_dst">dst</code></td>
<td>
<p>destination crs</p>
</td></tr>
<tr><td><code id="st_transform_+3A_x">x</code></td>
<td>
<p>object of class sf, sfc or sfg</p>
</td></tr>
<tr><td><code id="st_transform_+3A_crs">crs</code></td>
<td>
<p>target coordinate reference system: object of class <code>crs</code>, or input string for <a href="#topic+st_crs">st_crs</a></p>
</td></tr>
<tr><td><code id="st_transform_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="st_transform_+3A_aoi">aoi</code></td>
<td>
<p>area of interest, in degrees:
WestLongitude, SouthLatitude, EastLongitude, NorthLatitude</p>
</td></tr>
<tr><td><code id="st_transform_+3A_pipeline">pipeline</code></td>
<td>
<p>character; coordinate operation pipeline, for overriding the default operation</p>
</td></tr>
<tr><td><code id="st_transform_+3A_reverse">reverse</code></td>
<td>
<p>boolean; has only an effect when <code>pipeline</code> is defined:
if <code>TRUE</code>, the inverse operation of the pipeline is applied</p>
</td></tr>
<tr><td><code id="st_transform_+3A_desired_accuracy">desired_accuracy</code></td>
<td>
<p>numeric; Only coordinate operations that offer an accuracy of
at least the one specified will be considered; a negative value disables this feature
(requires GDAL &gt;= 3.3)</p>
</td></tr>
<tr><td><code id="st_transform_+3A_allow_ballpark">allow_ballpark</code></td>
<td>
<p>logical; are ballpark (low accuracy) transformations allowed?
(requires GDAL &gt;= 3.3)</p>
</td></tr>
<tr><td><code id="st_transform_+3A_partial">partial</code></td>
<td>
<p>logical; allow for partial projection, if not all points of a geometry can be projected (corresponds to setting environment variable <code>OGR_ENABLE_PARTIAL_REPROJECTION</code> to <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="st_transform_+3A_check">check</code></td>
<td>
<p>logical; if <code>TRUE</code>, perform a sanity check on resulting polygons</p>
</td></tr>
<tr><td><code id="st_transform_+3A_options">options</code></td>
<td>
<p>character; should have &quot;WRAPDATELINE=YES&quot; to function; another parameter that is used is &quot;DATELINEOFFSET=10&quot; (where 10 is the default value)</p>
</td></tr>
<tr><td><code id="st_transform_+3A_quiet">quiet</code></td>
<td>
<p>logical; print options after they have been parsed?</p>
</td></tr>
<tr><td><code id="st_transform_+3A_type">type</code></td>
<td>
<p>character; one of <code>have_datum_files</code>, <code>proj</code>, <code>ellps</code>, <code>datum</code>, <code>units</code>, <code>path</code>, or <code>prime_meridians</code>; see Details.</p>
</td></tr>
<tr><td><code id="st_transform_+3A_path">path</code></td>
<td>
<p>character; PROJ search path to be set</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>st_can_transform</code> returns a boolean indicating whether
coordinates with CRS src can be transformed into CRS dst
</p>
<p>Transforms coordinates of object to new projection.
Features that cannot be transformed are returned as empty geometries.
Transforms using the <code>pipeline=</code> argument may fail if there is
ambiguity in the axis order of the specified coordinate reference system;
if you need the traditional GIS order, use <code>"OGC:CRS84"</code>, not
<code>"EPSG:4326"</code>. Extra care is needed with the ESRI Shapefile format,
because WKT1 does not store axis order unambiguously.
</p>
<p>The <code>st_transform</code> method for <code>sfg</code> objects assumes that the CRS of the object is available as an attribute of that name.
</p>
<p>For a discussion of using <code>options</code>, see <a href="https://github.com/r-spatial/sf/issues/280">https://github.com/r-spatial/sf/issues/280</a> and <a href="https://github.com/r-spatial/sf/issues/1983">https://github.com/r-spatial/sf/issues/1983</a>
</p>
<p><code>sf_proj_info</code> lists the available projections, ellipses, datums, units, or data search path of the PROJ library when <code>type</code> is equal to proj, ellps, datum, units or path; when <code>type</code> equals <code>have_datum_files</code> a boolean is returned indicating whether datum files are installed and accessible (checking for <code>conus</code>). <code>path</code> returns the <code>PROJ_INFO.searchpath</code> field directly, as a single string with path separaters (<code>:</code>  or <code style="white-space: pre;">&#8288;;&#8288;</code>).
</p>
<p>for PROJ &gt;= 6, <code>sf_proj_info</code> does not provide option <code>type = "datums"</code>.
PROJ &lt; 6 does not provide the option <code>type = "prime_meridians"</code>.
</p>
<p>for PROJ &gt;= 7.1.0, the &quot;units&quot; query of <code>sf_proj_info</code> returns the <code>to_meter</code>
variable as numeric, previous versions return a character vector containing a numeric expression.
</p>


<h3>See Also</h3>

<p><a href="lwgeom.html#topic+st_transform_proj">st_transform_proj</a>, part of package lwgeom.
</p>
<p><a href="#topic+sf_project">sf_project</a> projects a matrix of coordinates, bypassing GDAL altogether
</p>
<p><a href="#topic+st_break_antimeridian">st_break_antimeridian</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p1 = st_point(c(7,52))
p2 = st_point(c(-30,20))
sfc = st_sfc(p1, p2, crs = 4326)
sfc
st_transform(sfc, 3857)
st_transform(st_sf(a=2:1, geom=sfc), "+init=epsg:3857")
if (sf_extSoftVersion()["GDAL"] &gt;= "3.0.0") {
  st_transform(sfc, pipeline =
	  "+proj=pipeline +step +proj=axisswap +order=2,1") # reverse axes
  st_transform(sfc, pipeline =
	  "+proj=pipeline +step +proj=axisswap +order=2,1", reverse = TRUE) # also reverse axes
}
nc = st_read(system.file("shape/nc.shp", package="sf"))
st_area(nc[1,]) # area from long/lat
st_area(st_transform(nc[1,], 32119)) # NC state plane, m
st_area(st_transform(nc[1,], 2264)) # NC state plane, US foot
library(units)
set_units(st_area(st_transform(nc[1,], 2264)), m^2)
st_transform(structure(p1, proj4string = "+init=epsg:4326"), "+init=epsg:3857")
st_wrap_dateline(st_sfc(st_linestring(rbind(c(-179,0),c(179,0))), crs = 4326))
sf_proj_info("datum")
</code></pre>

<hr>
<h2 id='st_viewport'>Create viewport from sf, sfc or sfg object</h2><span id='topic+st_viewport'></span>

<h3>Description</h3>

<p>Create viewport from sf, sfc or sfg object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_viewport(x, ..., bbox = st_bbox(x), asp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_viewport_+3A_x">x</code></td>
<td>
<p>object of class sf, sfc or sfg object</p>
</td></tr>
<tr><td><code id="st_viewport_+3A_...">...</code></td>
<td>
<p>parameters passed on to <a href="grid.html#topic+viewport">viewport</a></p>
</td></tr>
<tr><td><code id="st_viewport_+3A_bbox">bbox</code></td>
<td>
<p>the bounding box used for aspect ratio</p>
</td></tr>
<tr><td><code id="st_viewport_+3A_asp">asp</code></td>
<td>
<p>numeric; target aspect ratio (y/x), see Details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>parameters <code>width</code>, <code>height</code>, <code>xscale</code> and <code>yscale</code> are set such that aspect ratio is honoured and plot size is maximized in the current viewport; others can be passed as <code>...</code>
</p>
<p>If <code>asp</code> is missing, it is taken as 1, except when <code>isTRUE(st_is_longlat(x))</code>, in which case it is set to <code>1.0 /cos(y)</code>, with <code>y</code> the middle of the latitude bounding box.
</p>


<h3>Value</h3>

<p>The output of the call to <a href="grid.html#topic+viewport">viewport</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(grid)
nc = st_read(system.file("shape/nc.shp", package="sf"))
grid.newpage()
pushViewport(viewport(width = 0.8, height = 0.8))
pushViewport(st_viewport(nc))
invisible(lapply(st_geometry(nc), function(x) grid.draw(st_as_grob(x, gp = gpar(fill = 'red')))))
</code></pre>

<hr>
<h2 id='st_write'>Write simple features object to file or database</h2><span id='topic+st_write'></span><span id='topic+st_write.sfc'></span><span id='topic+st_write.sf'></span><span id='topic+st_write.data.frame'></span><span id='topic+write_sf'></span><span id='topic+st_delete'></span>

<h3>Description</h3>

<p>Write simple features object to file or database
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_write(obj, dsn, layer, ...)

## S3 method for class 'sfc'
st_write(obj, dsn, layer, ...)

## S3 method for class 'sf'
st_write(
  obj,
  dsn,
  layer = NULL,
  ...,
  driver = guess_driver_can_write(dsn),
  dataset_options = NULL,
  layer_options = NULL,
  quiet = FALSE,
  factorsAsCharacter = TRUE,
  append = NA,
  delete_dsn = FALSE,
  delete_layer = !is.na(append) &amp;&amp; !append,
  fid_column_name = NULL,
  config_options = character(0)
)

## S3 method for class 'data.frame'
st_write(obj, dsn, layer = NULL, ...)

write_sf(..., quiet = TRUE, append = FALSE, delete_layer = !append)

st_delete(
  dsn,
  layer = character(0),
  driver = guess_driver_can_write(dsn),
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_write_+3A_obj">obj</code></td>
<td>
<p>object of class <code>sf</code> or <code>sfc</code></p>
</td></tr>
<tr><td><code id="st_write_+3A_dsn">dsn</code></td>
<td>
<p>data source name. Interpretation varies by driver: can be
a filename, a folder, a database name, or a Database Connection
(we officially test support for
<code><a href="RPostgres.html#topic+Postgres">RPostgres::Postgres()</a></code> connections).</p>
</td></tr>
<tr><td><code id="st_write_+3A_layer">layer</code></td>
<td>
<p>layer name. Varies by driver, may be a file name without
extension; for database connection, it is the name of the table. If layer
is missing, the <code>basename</code> of <code>dsn</code> is taken.</p>
</td></tr>
<tr><td><code id="st_write_+3A_...">...</code></td>
<td>
<p>other arguments passed to <a href="DBI.html#topic+dbWriteTable">dbWriteTable</a> when <code>dsn</code> is a
Database Connection</p>
</td></tr>
<tr><td><code id="st_write_+3A_driver">driver</code></td>
<td>
<p>character; name of driver to be used; if missing and <code>dsn</code> is not a Database Connection, a driver name is guessed from <code>dsn</code>;
<code>st_drivers()</code> returns the drivers that are available with their properties; links to full driver documentation
are found at <a href="https://gdal.org/drivers/vector/index.html">https://gdal.org/drivers/vector/index.html</a></p>
</td></tr>
<tr><td><code id="st_write_+3A_dataset_options">dataset_options</code></td>
<td>
<p>character; driver dependent dataset creation options;
multiple options supported.</p>
</td></tr>
<tr><td><code id="st_write_+3A_layer_options">layer_options</code></td>
<td>
<p>character; driver dependent layer creation options;
multiple options supported.</p>
</td></tr>
<tr><td><code id="st_write_+3A_quiet">quiet</code></td>
<td>
<p>logical; suppress info on name, driver, size and spatial
reference</p>
</td></tr>
<tr><td><code id="st_write_+3A_factorsascharacter">factorsAsCharacter</code></td>
<td>
<p>logical; convert <code>factor</code> levels to character
strings (<code>TRUE</code>, default), otherwise into numbers when
factorsAsCharacter is <code>FALSE</code>. For database connections,
<code>factorsAsCharacter</code> is always <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="st_write_+3A_append">append</code></td>
<td>
<p>logical; should we append to an existing layer, or replace it?
if <code>TRUE</code> append, if <code>FALSE</code> replace.
The default for <code>st_write</code> is <code>NA</code> which raises an error if the layer exists.
The default for <code>write_sf</code> is <code>FALSE</code>, which overwrites any existing data.
See also next two arguments for more control on overwrite behavior.</p>
</td></tr>
<tr><td><code id="st_write_+3A_delete_dsn">delete_dsn</code></td>
<td>
<p>logical; delete data source <code>dsn</code> before attempting
to write?</p>
</td></tr>
<tr><td><code id="st_write_+3A_delete_layer">delete_layer</code></td>
<td>
<p>logical; delete layer <code>layer</code> before attempting to
write?
The default for <code>st_write</code> is <code>FALSE</code> which raises an error if the layer exists.
The default for <code>write_sf</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="st_write_+3A_fid_column_name">fid_column_name</code></td>
<td>
<p>character, name of column with feature IDs; if
specified, this column is no longer written as feature attribute.</p>
</td></tr>
<tr><td><code id="st_write_+3A_config_options">config_options</code></td>
<td>
<p>character, named vector with GDAL config options</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Columns (variables) of a class not supported are dropped with a warning.
</p>
<p>When updating an existing layer, records are appended to it if the updating
object has the right variable names and types. If names don't match an
error is raised. If types don't match, behaviour is undefined: GDAL may
raise warnings or errors or fail silently.
</p>
<p>When deleting layers or data sources is not successful, no error is emitted.
<code>delete_dsn</code> and <code>delete_layer</code> should be
handled with care; the former may erase complete directories or databases.
</p>
<p><code>st_delete()</code> deletes layer(s) in a data source, or a data source if layers are
omitted; it returns <code>TRUE</code> on success, <code>FALSE</code> on failure, invisibly.
</p>


<h3>Value</h3>

<p><code>obj</code>, invisibly
</p>


<h3>See Also</h3>

<p><a href="#topic+st_drivers">st_drivers</a>, <a href="DBI.html#topic+dbWriteTable">dbWriteTable</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nc = st_read(system.file("shape/nc.shp", package="sf"))
st_write(nc, paste0(tempdir(), "/", "nc.shp"))
st_write(nc, paste0(tempdir(), "/", "nc.shp"), delete_layer = TRUE) # overwrites
if (require(sp, quietly = TRUE)) {
 data(meuse, package = "sp") # loads data.frame from sp
 meuse_sf = st_as_sf(meuse, coords = c("x", "y"), crs = 28992)
 # writes X and Y as columns:
 st_write(meuse_sf, paste0(tempdir(), "/", "meuse.csv"), layer_options = "GEOMETRY=AS_XY")
 st_write(meuse_sf, paste0(tempdir(), "/", "meuse.csv"), layer_options = "GEOMETRY=AS_WKT",
   delete_dsn=TRUE) # overwrites
## Not run: 
 library(sp)
 example(meuse, ask = FALSE, echo = FALSE)
 try(st_write(st_as_sf(meuse), "PG:dbname=postgis", "meuse_sf",
     layer_options = c("OVERWRITE=yes", "LAUNDER=true")))
 demo(nc, ask = FALSE)
 try(st_write(nc, "PG:dbname=postgis", "sids", layer_options = "OVERWRITE=true"))

## End(Not run)
}
</code></pre>

<hr>
<h2 id='st_z_range'>Return 'z' range of a simple feature or simple feature set</h2><span id='topic+st_z_range'></span><span id='topic+is.na.z_range'></span><span id='topic+st_z_range.POINT'></span><span id='topic+st_z_range.MULTIPOINT'></span><span id='topic+st_z_range.LINESTRING'></span><span id='topic+st_z_range.POLYGON'></span><span id='topic+st_z_range.MULTILINESTRING'></span><span id='topic+st_z_range.MULTIPOLYGON'></span><span id='topic+st_z_range.GEOMETRYCOLLECTION'></span><span id='topic+st_z_range.MULTISURFACE'></span><span id='topic+st_z_range.MULTICURVE'></span><span id='topic+st_z_range.CURVEPOLYGON'></span><span id='topic+st_z_range.COMPOUNDCURVE'></span><span id='topic+st_z_range.POLYHEDRALSURFACE'></span><span id='topic+st_z_range.TIN'></span><span id='topic+st_z_range.TRIANGLE'></span><span id='topic+st_z_range.CIRCULARSTRING'></span><span id='topic+st_z_range.sfc'></span><span id='topic+st_z_range.sf'></span><span id='topic+st_z_range.numeric'></span><span id='topic+NA_z_range_'></span>

<h3>Description</h3>

<p>Return 'z' range of a simple feature or simple feature set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'z_range'
is.na(x)

st_z_range(obj, ...)

## S3 method for class 'POINT'
st_z_range(obj, ...)

## S3 method for class 'MULTIPOINT'
st_z_range(obj, ...)

## S3 method for class 'LINESTRING'
st_z_range(obj, ...)

## S3 method for class 'POLYGON'
st_z_range(obj, ...)

## S3 method for class 'MULTILINESTRING'
st_z_range(obj, ...)

## S3 method for class 'MULTIPOLYGON'
st_z_range(obj, ...)

## S3 method for class 'GEOMETRYCOLLECTION'
st_z_range(obj, ...)

## S3 method for class 'MULTISURFACE'
st_z_range(obj, ...)

## S3 method for class 'MULTICURVE'
st_z_range(obj, ...)

## S3 method for class 'CURVEPOLYGON'
st_z_range(obj, ...)

## S3 method for class 'COMPOUNDCURVE'
st_z_range(obj, ...)

## S3 method for class 'POLYHEDRALSURFACE'
st_z_range(obj, ...)

## S3 method for class 'TIN'
st_z_range(obj, ...)

## S3 method for class 'TRIANGLE'
st_z_range(obj, ...)

## S3 method for class 'CIRCULARSTRING'
st_z_range(obj, ...)

## S3 method for class 'sfc'
st_z_range(obj, ...)

## S3 method for class 'sf'
st_z_range(obj, ...)

## S3 method for class 'numeric'
st_z_range(obj, ..., crs = NA_crs_)

NA_z_range_
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_z_range_+3A_x">x</code></td>
<td>
<p>object of class <code>z_range</code></p>
</td></tr>
<tr><td><code id="st_z_range_+3A_obj">obj</code></td>
<td>
<p>object to compute the z range from</p>
</td></tr>
<tr><td><code id="st_z_range_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="st_z_range_+3A_crs">crs</code></td>
<td>
<p>object of class <code>crs</code>, or argument to <a href="#topic+st_crs">st_crs</a>, specifying the CRS of this bounding box.</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>z_range</code> of length 2.
</p>


<h3>Details</h3>

<p><code>NA_z_range_</code> represents the missing value for a <code>z_range</code> object
</p>


<h3>Value</h3>

<p>a numeric vector of length two, with <code>zmin</code> and <code>zmax</code> values;
if <code>obj</code> is of class <code>sf</code> or <code>sfc</code> the object
returned has a class <code>z_range</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a = st_sf(a = 1:2, geom = st_sfc(st_point(0:2), st_point(1:3)), crs = 4326)
st_z_range(a)
st_z_range(c(zmin = 16.1, zmax = 16.6), crs = st_crs(4326))
</code></pre>

<hr>
<h2 id='st_zm'>Drop or add Z and/or M dimensions from feature geometries</h2><span id='topic+st_zm'></span>

<h3>Description</h3>

<p>Drop Z and/or M dimensions from feature geometries, resetting classes appropriately
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_zm(x, ..., drop = TRUE, what = "ZM")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_zm_+3A_x">x</code></td>
<td>
<p>object of class <code>sfg</code>, <code>sfc</code> or <code>sf</code></p>
</td></tr>
<tr><td><code id="st_zm_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="st_zm_+3A_drop">drop</code></td>
<td>
<p>logical; drop, or (<code>FALSE</code>) add?</p>
</td></tr>
<tr><td><code id="st_zm_+3A_what">what</code></td>
<td>
<p>character which dimensions to drop or add</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only combinations <code>drop=TRUE</code>, <code>what = "ZM"</code>, and <code>drop=FALSE</code>, <code>what="Z"</code> are supported so far.
In case <code>add=TRUE</code>, <code>x</code> should have <code>XY</code> geometry, and zero values are added for <code>Z</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>st_zm(st_linestring(matrix(1:32,8)))
x = st_sfc(st_linestring(matrix(1:32,8)), st_linestring(matrix(1:8,2)))
st_zm(x)
a = st_sf(a = 1:2, geom=x)
st_zm(a)
</code></pre>

<hr>
<h2 id='stars'>functions only exported to be used internally by stars</h2><span id='topic+stars'></span><span id='topic+.get_layout'></span><span id='topic+.degAxis'></span><span id='topic+.image_scale'></span><span id='topic+.image_scale_factor'></span>

<h3>Description</h3>

<p>functions only exported to be used internally by stars
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.get_layout(bb, n, total_size, key.pos, key.width, mfrow = NULL, main = NULL)

.degAxis(side, at, labels, ..., lon, lat, ndiscr, reset)

.image_scale(
  z,
  col,
  breaks = NULL,
  key.pos,
  add.axis = TRUE,
  at = NULL,
  ...,
  axes = FALSE,
  key.length,
  logz = FALSE,
  lab = "",
  cex.axis = par("cex.axis")
)

.image_scale_factor(
  z,
  col,
  key.pos,
  add.axis = TRUE,
  ...,
  axes = FALSE,
  key.width,
  key.length,
  cex.axis = par("cex.axis")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stars_+3A_bb">bb</code></td>
<td>
<p>ignore</p>
</td></tr>
<tr><td><code id="stars_+3A_n">n</code></td>
<td>
<p>ignore</p>
</td></tr>
<tr><td><code id="stars_+3A_total_size">total_size</code></td>
<td>
<p>ignore</p>
</td></tr>
<tr><td><code id="stars_+3A_key.pos">key.pos</code></td>
<td>
<p>ignore</p>
</td></tr>
<tr><td><code id="stars_+3A_key.width">key.width</code></td>
<td>
<p>ignore</p>
</td></tr>
<tr><td><code id="stars_+3A_mfrow">mfrow</code></td>
<td>
<p>length-2 integer vector with number of rows, columns</p>
</td></tr>
<tr><td><code id="stars_+3A_main">main</code></td>
<td>
<p>main or sub title</p>
</td></tr>
<tr><td><code id="stars_+3A_side">side</code></td>
<td>
<p>ignore</p>
</td></tr>
<tr><td><code id="stars_+3A_at">at</code></td>
<td>
<p>ignore</p>
</td></tr>
<tr><td><code id="stars_+3A_labels">labels</code></td>
<td>
<p>ignore</p>
</td></tr>
<tr><td><code id="stars_+3A_...">...</code></td>
<td>
<p>ignore</p>
</td></tr>
<tr><td><code id="stars_+3A_lon">lon</code></td>
<td>
<p>ignore</p>
</td></tr>
<tr><td><code id="stars_+3A_lat">lat</code></td>
<td>
<p>ignore</p>
</td></tr>
<tr><td><code id="stars_+3A_ndiscr">ndiscr</code></td>
<td>
<p>ignore</p>
</td></tr>
<tr><td><code id="stars_+3A_reset">reset</code></td>
<td>
<p>ignore</p>
</td></tr>
<tr><td><code id="stars_+3A_z">z</code></td>
<td>
<p>ignore</p>
</td></tr>
<tr><td><code id="stars_+3A_col">col</code></td>
<td>
<p>ignore</p>
</td></tr>
<tr><td><code id="stars_+3A_breaks">breaks</code></td>
<td>
<p>ignore</p>
</td></tr>
<tr><td><code id="stars_+3A_add.axis">add.axis</code></td>
<td>
<p>ignore</p>
</td></tr>
<tr><td><code id="stars_+3A_axes">axes</code></td>
<td>
<p>ignore</p>
</td></tr>
<tr><td><code id="stars_+3A_key.length">key.length</code></td>
<td>
<p>ignore</p>
</td></tr>
<tr><td><code id="stars_+3A_logz">logz</code></td>
<td>
<p>ignore</p>
</td></tr>
<tr><td><code id="stars_+3A_lab">lab</code></td>
<td>
<p>ignore</p>
</td></tr>
<tr><td><code id="stars_+3A_cex.axis">cex.axis</code></td>
<td>
<p>see <a href="graphics.html#topic+par">par</a></p>
</td></tr>
</table>

<hr>
<h2 id='summary.sfc'>Summarize simple feature column</h2><span id='topic+summary.sfc'></span>

<h3>Description</h3>

<p>Summarize simple feature column
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sfc'
summary(object, ..., maxsum = 7L, maxp4s = 10L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.sfc_+3A_object">object</code></td>
<td>
<p>object of class <code>sfc</code></p>
</td></tr>
<tr><td><code id="summary.sfc_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="summary.sfc_+3A_maxsum">maxsum</code></td>
<td>
<p>maximum number of classes to summarize the simple feature column to</p>
</td></tr>
<tr><td><code id="summary.sfc_+3A_maxp4s">maxp4s</code></td>
<td>
<p>maximum number of characters to print from the PROJ string</p>
</td></tr>
</table>

<hr>
<h2 id='tibble'>Summarize simple feature type for tibble</h2><span id='topic+tibble'></span><span id='topic+type_sum.sfc'></span><span id='topic+obj_sum.sfc'></span><span id='topic+pillar_shaft.sfc'></span>

<h3>Description</h3>

<p>Summarize simple feature type / item for tibble
</p>


<h3>Usage</h3>

<pre><code class='language-R'>type_sum.sfc(x, ...)

obj_sum.sfc(x)

pillar_shaft.sfc(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tibble_+3A_x">x</code></td>
<td>
<p>object of class <code>sfc</code></p>
</td></tr>
<tr><td><code id="tibble_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>see <a href="pillar.html#topic+type_sum">type_sum</a>
</p>

<hr>
<h2 id='tidyverse'>Tidyverse methods for sf objects</h2><span id='topic+tidyverse'></span><span id='topic+filter.sf'></span><span id='topic+arrange.sf'></span><span id='topic+group_by.sf'></span><span id='topic+ungroup.sf'></span><span id='topic+rowwise.sf'></span><span id='topic+mutate.sf'></span><span id='topic+transmute.sf'></span><span id='topic+select.sf'></span><span id='topic+rename.sf'></span><span id='topic+rename_with.sf'></span><span id='topic+slice.sf'></span><span id='topic+summarise.sf'></span><span id='topic+summarise'></span><span id='topic+distinct.sf'></span><span id='topic+gather.sf'></span><span id='topic+pivot_longer.sf'></span><span id='topic+pivot_wider.sf'></span><span id='topic+spread.sf'></span><span id='topic+sample_n.sf'></span><span id='topic+sample_frac.sf'></span><span id='topic+group_split.sf'></span><span id='topic+nest.sf'></span><span id='topic+separate.sf'></span><span id='topic+separate_rows.sf'></span><span id='topic+unite.sf'></span><span id='topic+unnest.sf'></span><span id='topic+drop_na.sf'></span><span id='topic+inner_join.sf'></span><span id='topic+left_join.sf'></span><span id='topic+right_join.sf'></span><span id='topic+full_join.sf'></span><span id='topic+semi_join.sf'></span><span id='topic+anti_join.sf'></span>

<h3>Description</h3>

<p>Tidyverse methods for sf objects. Geometries are sticky, use <a href="base.html#topic+as.data.frame">as.data.frame</a> to let <code>dplyr</code>'s own methods drop them.
Use these methods after loading the tidyverse package with the generic (or after loading package tidyverse).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter.sf(.data, ..., .dots)

arrange.sf(.data, ..., .dots)

group_by.sf(.data, ..., add = FALSE)

ungroup.sf(x, ...)

rowwise.sf(x, ...)

mutate.sf(.data, ..., .dots)

transmute.sf(.data, ..., .dots)

select.sf(.data, ...)

rename.sf(.data, ...)

rename_with.sf(.data, .fn, .cols, ...)

slice.sf(.data, ..., .dots)

summarise.sf(.data, ..., .dots, do_union = TRUE, is_coverage = FALSE)

distinct.sf(.data, ..., .keep_all = FALSE)

gather.sf(
  data,
  key,
  value,
  ...,
  na.rm = FALSE,
  convert = FALSE,
  factor_key = FALSE
)

pivot_longer.sf(
  data,
  cols,
  names_to = "name",
  names_prefix = NULL,
  names_sep = NULL,
  names_pattern = NULL,
  names_ptypes = NULL,
  names_transform = NULL,
  names_repair = "check_unique",
  values_to = "value",
  values_drop_na = FALSE,
  values_ptypes = NULL,
  values_transform = NULL,
  ...
)

pivot_wider.sf(
  data,
  ...,
  id_cols = NULL,
  id_expand = FALSE,
  names_from = name,
  names_prefix = "",
  names_sep = "_",
  names_glue = NULL,
  names_sort = FALSE,
  names_vary = "fastest",
  names_expand = FALSE,
  names_repair = "check_unique",
  values_from = value,
  values_fill = NULL,
  values_fn = NULL,
  unused_fn = NULL
)

spread.sf(
  data,
  key,
  value,
  fill = NA,
  convert = FALSE,
  drop = TRUE,
  sep = NULL
)

sample_n.sf(tbl, size, replace = FALSE, weight = NULL, .env = parent.frame())

sample_frac.sf(
  tbl,
  size = 1,
  replace = FALSE,
  weight = NULL,
  .env = parent.frame()
)

group_split.sf(.tbl, ..., .keep = TRUE)

nest.sf(.data, ...)

separate.sf(
  data,
  col,
  into,
  sep = "[^[:alnum:]]+",
  remove = TRUE,
  convert = FALSE,
  extra = "warn",
  fill = "warn",
  ...
)

separate_rows.sf(data, ..., sep = "[^[:alnum:]]+", convert = FALSE)

unite.sf(data, col, ..., sep = "_", remove = TRUE)

unnest.sf(data, ..., .preserve = NULL)

drop_na.sf(x, ...)

inner_join.sf(x, y, by = NULL, copy = FALSE, suffix = c(".x", ".y"), ...)

left_join.sf(x, y, by = NULL, copy = FALSE, suffix = c(".x", ".y"), ...)

right_join.sf(x, y, by = NULL, copy = FALSE, suffix = c(".x", ".y"), ...)

full_join.sf(x, y, by = NULL, copy = FALSE, suffix = c(".x", ".y"), ...)

semi_join.sf(x, y, by = NULL, copy = FALSE, suffix = c(".x", ".y"), ...)

anti_join.sf(x, y, by = NULL, copy = FALSE, suffix = c(".x", ".y"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidyverse_+3A_.data">.data</code></td>
<td>
<p>data object of class <a href="#topic+sf">sf</a></p>
</td></tr>
<tr><td><code id="tidyverse_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
<tr><td><code id="tidyverse_+3A_.dots">.dots</code></td>
<td>
<p>see corresponding function in package <code>dplyr</code></p>
</td></tr>
<tr><td><code id="tidyverse_+3A_add">add</code></td>
<td>
<p>see corresponding function in dplyr</p>
</td></tr>
<tr><td><code id="tidyverse_+3A_x">x</code>, <code id="tidyverse_+3A_y">y</code></td>
<td>
<p>A pair of data frames, data frame extensions (e.g. a tibble), or
lazy data frames (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="tidyverse_+3A_.fn">.fn</code>, <code id="tidyverse_+3A_.cols">.cols</code></td>
<td>
<p>see original docs</p>
</td></tr>
<tr><td><code id="tidyverse_+3A_do_union">do_union</code></td>
<td>
<p>logical; in case <code>summary</code> does not create a geometry column, should geometries be created by unioning using <a href="#topic+st_union">st_union</a>, or simply by combining using <a href="#topic+st_combine">st_combine</a>? Using <a href="#topic+st_union">st_union</a> resolves internal boundaries, but in case of unioning points, this will likely change the order of the points; see Details.</p>
</td></tr>
<tr><td><code id="tidyverse_+3A_is_coverage">is_coverage</code></td>
<td>
<p>logical; if <code>do_union</code> is <code>TRUE</code>, use an optimized algorithm for features that form a polygonal coverage (have no overlaps)</p>
</td></tr>
<tr><td><code id="tidyverse_+3A_.keep_all">.keep_all</code></td>
<td>
<p>see corresponding function in dplyr</p>
</td></tr>
<tr><td><code id="tidyverse_+3A_data">data</code></td>
<td>
<p>see original function docs</p>
</td></tr>
<tr><td><code id="tidyverse_+3A_key">key</code></td>
<td>
<p>see original function docs</p>
</td></tr>
<tr><td><code id="tidyverse_+3A_value">value</code></td>
<td>
<p>see original function docs</p>
</td></tr>
<tr><td><code id="tidyverse_+3A_na.rm">na.rm</code></td>
<td>
<p>see original function docs</p>
</td></tr>
<tr><td><code id="tidyverse_+3A_convert">convert</code></td>
<td>
<p>see <a href="tidyr.html#topic+separate_rows">separate_rows</a></p>
</td></tr>
<tr><td><code id="tidyverse_+3A_factor_key">factor_key</code></td>
<td>
<p>see original function docs</p>
</td></tr>
<tr><td><code id="tidyverse_+3A_cols">cols</code></td>
<td>
<p>see original function docs</p>
</td></tr>
<tr><td><code id="tidyverse_+3A_names_to">names_to</code>, <code id="tidyverse_+3A_names_pattern">names_pattern</code>, <code id="tidyverse_+3A_names_ptypes">names_ptypes</code>, <code id="tidyverse_+3A_names_transform">names_transform</code></td>
<td>
<p>see <code><a href="tidyr.html#topic+pivot_longer">tidyr::pivot_longer()</a></code></p>
</td></tr>
<tr><td><code id="tidyverse_+3A_names_prefix">names_prefix</code>, <code id="tidyverse_+3A_names_sep">names_sep</code>, <code id="tidyverse_+3A_names_repair">names_repair</code></td>
<td>
<p>see original function docs.</p>
</td></tr>
<tr><td><code id="tidyverse_+3A_values_to">values_to</code>, <code id="tidyverse_+3A_values_drop_na">values_drop_na</code>, <code id="tidyverse_+3A_values_ptypes">values_ptypes</code>, <code id="tidyverse_+3A_values_transform">values_transform</code></td>
<td>
<p>See <code><a href="tidyr.html#topic+pivot_longer">tidyr::pivot_longer()</a></code></p>
</td></tr>
<tr><td><code id="tidyverse_+3A_id_cols">id_cols</code>, <code id="tidyverse_+3A_id_expand">id_expand</code>, <code id="tidyverse_+3A_names_from">names_from</code>, <code id="tidyverse_+3A_names_sort">names_sort</code>, <code id="tidyverse_+3A_names_glue">names_glue</code>, <code id="tidyverse_+3A_names_vary">names_vary</code>, <code id="tidyverse_+3A_names_expand">names_expand</code></td>
<td>
<p>see <code><a href="tidyr.html#topic+pivot_wider">tidyr::pivot_wider()</a></code></p>
</td></tr>
<tr><td><code id="tidyverse_+3A_values_from">values_from</code>, <code id="tidyverse_+3A_values_fill">values_fill</code>, <code id="tidyverse_+3A_values_fn">values_fn</code>, <code id="tidyverse_+3A_unused_fn">unused_fn</code></td>
<td>
<p>see <code><a href="tidyr.html#topic+pivot_wider">tidyr::pivot_wider()</a></code></p>
</td></tr>
<tr><td><code id="tidyverse_+3A_fill">fill</code></td>
<td>
<p>see original function docs</p>
</td></tr>
<tr><td><code id="tidyverse_+3A_drop">drop</code></td>
<td>
<p>see original function docs</p>
</td></tr>
<tr><td><code id="tidyverse_+3A_sep">sep</code></td>
<td>
<p>see <a href="tidyr.html#topic+separate_rows">separate_rows</a></p>
</td></tr>
<tr><td><code id="tidyverse_+3A_tbl">tbl</code></td>
<td>
<p>see original function docs</p>
</td></tr>
<tr><td><code id="tidyverse_+3A_size">size</code></td>
<td>
<p>see original function docs</p>
</td></tr>
<tr><td><code id="tidyverse_+3A_replace">replace</code></td>
<td>
<p>see original function docs</p>
</td></tr>
<tr><td><code id="tidyverse_+3A_weight">weight</code></td>
<td>
<p>see original function docs</p>
</td></tr>
<tr><td><code id="tidyverse_+3A_.env">.env</code></td>
<td>
<p>see original function docs</p>
</td></tr>
<tr><td><code id="tidyverse_+3A_.tbl">.tbl</code></td>
<td>
<p>see original function docs</p>
</td></tr>
<tr><td><code id="tidyverse_+3A_.keep">.keep</code></td>
<td>
<p>see original function docs</p>
</td></tr>
<tr><td><code id="tidyverse_+3A_col">col</code></td>
<td>
<p>see <a href="tidyr.html#topic+separate">separate</a></p>
</td></tr>
<tr><td><code id="tidyverse_+3A_into">into</code></td>
<td>
<p>see <a href="tidyr.html#topic+separate">separate</a></p>
</td></tr>
<tr><td><code id="tidyverse_+3A_remove">remove</code></td>
<td>
<p>see <a href="tidyr.html#topic+separate">separate</a></p>
</td></tr>
<tr><td><code id="tidyverse_+3A_extra">extra</code></td>
<td>
<p>see <a href="tidyr.html#topic+separate">separate</a></p>
</td></tr>
<tr><td><code id="tidyverse_+3A_.preserve">.preserve</code></td>
<td>
<p>see <a href="tidyr.html#topic+nest">unnest</a></p>
</td></tr>
<tr><td><code id="tidyverse_+3A_by">by</code></td>
<td>
<p>A join specification created with <code><a href="dplyr.html#topic+join_by">join_by()</a></code>, or a character
vector of variables to join by.
</p>
<p>If <code>NULL</code>, the default, <code style="white-space: pre;">&#8288;*_join()&#8288;</code> will perform a natural join, using all
variables in common across <code>x</code> and <code>y</code>. A message lists the variables so
that you can check they're correct; suppress the message by supplying <code>by</code>
explicitly.
</p>
<p>To join on different variables between <code>x</code> and <code>y</code>, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code>
specification. For example, <code>join_by(a == b)</code> will match <code>x$a</code> to <code>y$b</code>.
</p>
<p>To join by multiple variables, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code> specification with
multiple expressions. For example, <code>join_by(a == b, c == d)</code> will match
<code>x$a</code> to <code>y$b</code> and <code>x$c</code> to <code>y$d</code>. If the column names are the same between
<code>x</code> and <code>y</code>, you can shorten this by listing only the variable names, like
<code>join_by(a, c)</code>.
</p>
<p><code><a href="dplyr.html#topic+join_by">join_by()</a></code> can also be used to perform inequality, rolling, and overlap
joins. See the documentation at <a href="dplyr.html#topic+join_by">?join_by</a> for details on
these types of joins.
</p>
<p>For simple equality joins, you can alternatively specify a character vector
of variable names to join by. For example, <code>by = c("a", "b")</code> joins <code>x$a</code>
to <code>y$a</code> and <code>x$b</code> to <code>y$b</code>. If variable names differ between <code>x</code> and <code>y</code>,
use a named character vector like <code>by = c("x_a" = "y_a", "x_b" = "y_b")</code>.
</p>
<p>To perform a cross-join, generating all combinations of <code>x</code> and <code>y</code>, see
<code><a href="dplyr.html#topic+cross_join">cross_join()</a></code>.</p>
</td></tr>
<tr><td><code id="tidyverse_+3A_copy">copy</code></td>
<td>
<p>If <code>x</code> and <code>y</code> are not from the same data source,
and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the
same src as <code>x</code>.  This allows you to join tables across srcs, but
it is a potentially expensive operation so you must opt into it.</p>
</td></tr>
<tr><td><code id="tidyverse_+3A_suffix">suffix</code></td>
<td>
<p>If there are non-joined duplicate variables in <code>x</code> and
<code>y</code>, these suffixes will be added to the output to disambiguate them.
Should be a character vector of length 2.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>select</code> keeps the geometry regardless whether it is selected or not; to deselect it, first pipe through <code>as.data.frame</code> to let dplyr's own <code>select</code> drop it.
</p>
<p>In case one or more of the arguments (expressions) in the <code>summarise</code> call creates a geometry list-column, the first of these will be the (active) geometry of the returned object. If this is not the case, a geometry column is created, depending on the value of <code>do_union</code>.
</p>
<p>In case <code>do_union</code> is <code>FALSE</code>, <code>summarise</code> will simply combine geometries using <a href="#topic+c.sfg">c.sfg</a>. When polygons sharing a boundary are combined, this leads to geometries that are invalid; see for instance <a href="https://github.com/r-spatial/sf/issues/681">https://github.com/r-spatial/sf/issues/681</a>.
</p>
<p><code>distinct</code> gives distinct records for which all attributes and geometries are distinct; <a href="#topic+st_equals">st_equals</a> is used to find out which geometries are distinct.
</p>
<p><code>nest</code> assumes that a simple feature geometry list-column was among the columns that were nested.
</p>


<h3>Value</h3>

<p>an object of class <a href="#topic+sf">sf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(dplyr, quietly = TRUE)) {
 nc = read_sf(system.file("shape/nc.shp", package="sf"))
 nc %&gt;% filter(AREA &gt; .1) %&gt;% plot()
 # plot 10 smallest counties in grey:
 st_geometry(nc) %&gt;% plot()
 nc %&gt;% select(AREA) %&gt;% arrange(AREA) %&gt;% slice(1:10) %&gt;% plot(add = TRUE, col = 'grey')
 title("the ten counties with smallest area")
 nc2 &lt;- nc %&gt;% mutate(area10 = AREA/10)
 nc %&gt;% slice(1:2)
}
# plot 10 smallest counties in grey:
if (require(dplyr, quietly = TRUE)) {
 st_geometry(nc) %&gt;% plot()
 nc %&gt;% select(AREA) %&gt;% arrange(AREA) %&gt;% slice(1:10) %&gt;% plot(add = TRUE, col = 'grey')
 title("the ten counties with smallest area")
}
if (require(dplyr, quietly = TRUE)) {
 nc$area_cl = cut(nc$AREA, c(0, .1, .12, .15, .25))
 nc %&gt;% group_by(area_cl) %&gt;% class()
}
if (require(dplyr, quietly = TRUE)) {
 nc2 &lt;- nc %&gt;% mutate(area10 = AREA/10)
}
if (require(dplyr, quietly = TRUE)) {
 nc %&gt;% transmute(AREA = AREA/10) %&gt;% class()
}
if (require(dplyr, quietly = TRUE)) {
 nc %&gt;% select(SID74, SID79) %&gt;% names()
 nc %&gt;% select(SID74, SID79) %&gt;% class()
}
if (require(dplyr, quietly = TRUE)) {
 nc2 &lt;- nc %&gt;% rename(area = AREA)
}
if (require(dplyr, quietly = TRUE)) {
 nc %&gt;% slice(1:2)
}
if (require(dplyr, quietly = TRUE)) {
 nc$area_cl = cut(nc$AREA, c(0, .1, .12, .15, .25))
 nc.g &lt;- nc %&gt;% group_by(area_cl)
 nc.g %&gt;% summarise(mean(AREA))
 nc.g %&gt;% summarise(mean(AREA)) %&gt;% plot(col = grey(3:6 / 7))
 nc %&gt;% as.data.frame %&gt;% summarise(mean(AREA))
}
if (require(dplyr, quietly = TRUE)) {
 nc[c(1:100, 1:10), ] %&gt;% distinct() %&gt;% nrow()
}
if (require(tidyr, quietly = TRUE) &amp;&amp; require(dplyr, quietly = TRUE) &amp;&amp; "geometry" %in% names(nc)) {
 nc %&gt;% select(SID74, SID79) %&gt;% gather("VAR", "SID", -geometry) %&gt;% summary()
}
if (require(tidyr, quietly = TRUE) &amp;&amp; require(dplyr, quietly = TRUE) &amp;&amp; "geometry" %in% names(nc)) {
 nc$row = 1:100 # needed for spread to work
 nc %&gt;% select(SID74, SID79, geometry, row) %&gt;%
	gather("VAR", "SID", -geometry, -row) %&gt;%
	spread(VAR, SID) %&gt;% head()
}
if (require(tidyr, quietly = TRUE) &amp;&amp; require(dplyr, quietly = TRUE)) {
 storms.sf = st_as_sf(storms, coords = c("long", "lat"), crs = 4326)
 x &lt;- storms.sf %&gt;% group_by(name, year) %&gt;% nest
 trs = lapply(x$data, function(tr) st_cast(st_combine(tr), "LINESTRING")[[1]]) %&gt;%
    st_sfc(crs = 4326)
 trs.sf = st_sf(x[,1:2], trs)
 plot(trs.sf["year"], axes = TRUE)
}
</code></pre>

<hr>
<h2 id='transform.sf'>transform method for sf objects</h2><span id='topic+transform.sf'></span>

<h3>Description</h3>

<p>Can be used to create or modify attribute variables; for transforming geometries see
<a href="#topic+st_transform">st_transform</a>, and all other functions starting with <code>st_</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sf'
transform(`_data`, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transform.sf_+3A__data">_data</code></td>
<td>
<p>object of class <code>sf</code></p>
</td></tr>
<tr><td><code id="transform.sf_+3A_...">...</code></td>
<td>
<p>Further arguments of the form <code>new_variable = expression</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>a = data.frame(x1 = 1:3, x2 = 5:7)
st_geometry(a) = st_sfc(st_point(c(0,0)), st_point(c(1,1)), st_point(c(2,2)))
transform(a, x1_sq = x1^2)
transform(a, x1_x2 = x1*x2)
</code></pre>

<hr>
<h2 id='valid'>Check validity or make an invalid geometry valid</h2><span id='topic+valid'></span><span id='topic+st_is_valid'></span><span id='topic+st_is_valid.sfc'></span><span id='topic+st_is_valid.sf'></span><span id='topic+st_is_valid.sfg'></span><span id='topic+st_make_valid'></span><span id='topic+st_make_valid.sfg'></span><span id='topic+st_make_valid.sfc'></span>

<h3>Description</h3>

<p>Checks whether a geometry is valid, or makes an invalid geometry valid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_is_valid(x, ...)

## S3 method for class 'sfc'
st_is_valid(x, ..., NA_on_exception = TRUE, reason = FALSE)

## S3 method for class 'sf'
st_is_valid(x, ...)

## S3 method for class 'sfg'
st_is_valid(x, ...)

st_make_valid(x, ...)

## S3 method for class 'sfg'
st_make_valid(x, ...)

## S3 method for class 'sfc'
st_make_valid(
  x,
  ...,
  oriented = FALSE,
  s2_options = s2::s2_options(snap = s2::s2_snap_precision(1e+07), ...),
  geos_method = "valid_structure",
  geos_keep_collapsed = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="valid_+3A_x">x</code></td>
<td>
<p>object of class <code>sfg</code>, <code>sfc</code> or <code>sf</code></p>
</td></tr>
<tr><td><code id="valid_+3A_...">...</code></td>
<td>
<p>passed on to <a href="s2.html#topic+s2_options">s2_options</a></p>
</td></tr>
<tr><td><code id="valid_+3A_na_on_exception">NA_on_exception</code></td>
<td>
<p>logical; if TRUE, for polygons that would otherwise raise a GEOS error (exception, e.g. for a POLYGON having more than zero but less than 4 points, or a LINESTRING having one point) return an <code>NA</code> rather than raising an error, and suppress warning messages (e.g. about self-intersection); if FALSE, regular GEOS errors and warnings will be emitted.</p>
</td></tr>
<tr><td><code id="valid_+3A_reason">reason</code></td>
<td>
<p>logical; if <code>TRUE</code>, return a character with, for each geometry, the reason for invalidity, <code>NA</code> on exception, or <code>"Valid Geometry"</code> otherwise.</p>
</td></tr>
<tr><td><code id="valid_+3A_oriented">oriented</code></td>
<td>
<p>logical; only relevant if <code>st_is_longlat(x)</code> is <code>TRUE</code>; see <a href="#topic+s2">s2</a></p>
</td></tr>
<tr><td><code id="valid_+3A_s2_options">s2_options</code></td>
<td>
<p>only relevant if <code>st_is_longlat(x)</code> is <code>TRUE</code>; options for <a href="s2.html#topic+s2_rebuild">s2_rebuild</a>, see <a href="s2.html#topic+s2_options">s2_options</a> and Details.</p>
</td></tr>
<tr><td><code id="valid_+3A_geos_method">geos_method</code></td>
<td>
<p>character; either &quot;valid_linework&quot; (Original method, combines all rings into a set of noded lines and then extracts valid polygons from that linework) or &quot;valid_structure&quot; (Structured method, first makes all rings valid then merges shells and subtracts holes from shells to generate valid result. Assumes that holes and shells are correctly categorized.) (requires GEOS &gt;= 3.10.1)</p>
</td></tr>
<tr><td><code id="valid_+3A_geos_keep_collapsed">geos_keep_collapsed</code></td>
<td>
<p>logical; When this parameter is not set to <code>FALSE</code>, the &quot;valid_structure&quot; method will keep any component that has collapsed into a lower dimensionality. For example, a ring collapsing to a line, or a line collapsing to a point (requires GEOS &gt;= 3.10.1)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For projected geometries, <code>st_make_valid</code> uses the <code>lwgeom_makevalid</code> method also used by the PostGIS command <code>ST_makevalid</code> if the GEOS version linked to is smaller than 3.8.0, and otherwise the version shipped in GEOS; for geometries having ellipsoidal coordinates <code>s2::s2_rebuild</code> is being used.
</p>
<p>if <code>s2_options</code> is not specified and <code>x</code> has a non-zero precision set, then this precision value will be used as the value in <code>s2_snap_precision</code>, passed on to <code>s2_options</code>, rather than the 1e7 default.
</p>


<h3>Value</h3>

<p><code>st_is_valid</code> returns a logical vector indicating for each geometries of <code>x</code> whether it is valid. <code>st_make_valid</code> returns an object with a topologically valid geometry.
</p>
<p>Object of the same class as <code>x</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p1 = st_as_sfc("POLYGON((0 0, 0 10, 10 0, 10 10, 0 0))")
st_is_valid(p1)
st_is_valid(st_sfc(st_point(0:1), p1[[1]]), reason = TRUE)
library(sf)
x = st_sfc(st_polygon(list(rbind(c(0,0),c(0.5,0),c(0.5,0.5),c(0.5,0),c(1,0),c(1,1),c(0,1),c(0,0)))))
suppressWarnings(st_is_valid(x))
y = st_make_valid(x)
st_is_valid(y)
y %&gt;% st_cast()
</code></pre>

<hr>
<h2 id='vctrs'>vctrs methods for sf objects</h2><span id='topic+vctrs'></span><span id='topic+vec_ptype2.sfc'></span><span id='topic+vec_ptype2.sfc.default'></span><span id='topic+vec_ptype2.sfc.sfc'></span><span id='topic+vec_cast.sfc'></span><span id='topic+vec_cast.sfc.sfc'></span><span id='topic+vec_cast.sfc.default'></span>

<h3>Description</h3>

<p>vctrs methods for sf objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec_ptype2.sfc(x, y, ...)

## Default S3 method:
vec_ptype2.sfc(x, y, ..., x_arg = "x", y_arg = "y")

## S3 method for class 'sfc'
vec_ptype2.sfc(x, y, ...)

vec_cast.sfc(x, to, ...)

## S3 method for class 'sfc'
vec_cast.sfc(x, to, ...)

## Default S3 method:
vec_cast.sfc(x, to, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vctrs_+3A_x">x</code>, <code id="vctrs_+3A_y">y</code></td>
<td>
<p>Vector types.</p>
</td></tr>
<tr><td><code id="vctrs_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="vctrs_+3A_x_arg">x_arg</code>, <code id="vctrs_+3A_y_arg">y_arg</code></td>
<td>
<p>Argument names for <code>x</code> and <code>y</code>.</p>
</td></tr>
<tr><td><code id="vctrs_+3A_to">to</code></td>
<td>
<p>Type to cast to. If <code>NULL</code>, <code>x</code> will be returned as is.</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
