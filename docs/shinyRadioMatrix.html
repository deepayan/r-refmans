<!DOCTYPE html><html><head><title>Help for package shinyRadioMatrix</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {shinyRadioMatrix}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#exPftList'><p>PFT List</p></a></li>
<li><a href='#exTaxonList'><p>Taxon List</p></a></li>
<li><a href='#radioMatrixInput'><p>Create radioMatrixInput</p></a></li>
<li><a href='#shinyRadioMatrix-internal'><p>Internal shinyRadioMatrix Functions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Create a Matrix with Radio Buttons</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Zsolt Szelepcsényi &lt;szelepcsenyi.zsolt@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>An input controller for R Shiny: a matrix with radio buttons, 
    where only one option per row can be selected.</td>
</tr>
<tr>
<td>Imports:</td>
<td>shiny</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-06-07 20:54:52 UTC; evista</td>
</tr>
<tr>
<td>Author:</td>
<td>Zsolt Szelepcsényi [aut, cre],
  Zoltán Szelepcsényi [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-06-07 21:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='exPftList'>PFT List</h2><span id='topic+exPftList'></span>

<h3>Description</h3>

<p>A PFT list, which gives the column names in a taxon-PFT matrix.
</p>


<h3>Format</h3>

<p>A data frame with 31 rows and 2 columns:
</p>

<dl>
<dt>ID</dt><dd><p>Unique identifier for the plant functional types (PFTs).</p>
</dd>
<dt>Name</dt><dd><p>Name of the PFT.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(exPftList)
str(exPftList)

</code></pre>

<hr>
<h2 id='exTaxonList'>Taxon List</h2><span id='topic+exTaxonList'></span>

<h3>Description</h3>

<p>A taxon list, which gives the row names in a taxon-PFT matrix.
</p>


<h3>Format</h3>

<p>A data frame with 31 rows and 2 columns:
</p>

<dl>
<dt>Var</dt><dd><p>Unique identifier for the variable.</p>
</dd>
<dt>VarName</dt><dd><p>Name of the pollen type or variable, including Linnean and
non-Linnean names (Acer saccharum-type, Cerealea, Avena/Triticum).</p>
</dd>
<dt>DefPFT</dt><dd><p>Default PFT assignment for the variable.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(exTaxonList)
str(exTaxonList)

</code></pre>

<hr>
<h2 id='radioMatrixInput'>Create radioMatrixInput</h2><span id='topic+radioMatrixInput'></span>

<h3>Description</h3>

<p>Create radioMatrixInput
</p>


<h3>Usage</h3>

<pre><code class='language-R'>radioMatrixInput(
  inputId,
  rowIDs,
  rowLLabels,
  rowRLabels = NULL,
  choices = NULL,
  selected = NULL,
  choiceNames = NULL,
  choiceValues = NULL,
  rowIDsName = "ID",
  labelsWidth = list(NULL, NULL)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="radioMatrixInput_+3A_inputid">inputId</code></td>
<td>
<p>The input slot that will be used to access the value.</p>
</td></tr>
<tr><td><code id="radioMatrixInput_+3A_rowids">rowIDs</code></td>
<td>
<p>character. Vector of row identifiers that will be used to find
values that the user has selected. In the output, the component will return
a named list of values, each name corresponding to the row id, and the
value - to the value user has selected in this row.</p>
</td></tr>
<tr><td><code id="radioMatrixInput_+3A_rowllabels">rowLLabels</code></td>
<td>
<p>character. Vector (or a matrix with one column) of labels that 
displayed in the leftmost point of each row. The column name of the matrix 
could be displayed in the header of the assignment matrix.</p>
</td></tr>
<tr><td><code id="radioMatrixInput_+3A_rowrlabels">rowRLabels</code></td>
<td>
<p>character. Vector (or a matrix with one column) of labels that 
displayed in the rightmost point of each row. The column name of the matrix 
could be displayed in the header of the assignment matrix. Using this argument 
is optional. But it allows to create Likert scales, potentially with several 
scales arranged in a matrix.</p>
</td></tr>
<tr><td><code id="radioMatrixInput_+3A_choices">choices</code></td>
<td>
<p>List of values to select from (if elements of the list are
named then that name rather than the value is displayed to the user). If
this argument is provided, then choiceNames and choiceValues must not be
provided, and vice-versa. The values should be strings; other types (such
as logicals and numbers) will be coerced to strings.</p>
</td></tr>
<tr><td><code id="radioMatrixInput_+3A_selected">selected</code></td>
<td>
<p>Vector of the initially selected values (if not specified then 
defaults to <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="radioMatrixInput_+3A_choicenames">choiceNames</code>, <code id="radioMatrixInput_+3A_choicevalues">choiceValues</code></td>
<td>
<p>List of names and values, respectively, that 
are displayed to the user in the app and correspond to the each choice (for 
this reason, the objects 'choiceNames' and 'choiceValues' must have the 
same length). If either of these arguments is provided, then the other must 
be provided and choices must not be provided. The advantage of using both of 
these over a named list for choices is that the object 'choiceNames' allows 
any type of UI object to be passed through (tag objects, icons, HTML code, 
...), instead of just simple text.</p>
</td></tr>
<tr><td><code id="radioMatrixInput_+3A_rowidsname">rowIDsName</code></td>
<td>
<p>single character that defines the header of the ID column in the
input matrix.</p>
</td></tr>
<tr><td><code id="radioMatrixInput_+3A_labelswidth">labelsWidth</code></td>
<td>
<p>List of two valid values of CSS length unit. Each element 
has to be a properly formatted CSS unit of length (e.g., <code>'10%'</code>,
<code>'40px'</code>, <code>'auto'</code>), specifying the minimum (first value) and 
maximum (second value) width of the labels columns. The valid elements will 
be written to the <code>style</code> attribute of the labels <code>td</code> tags.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>HTML markup for radioMatrixInput
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(shiny)
library(shinyRadioMatrix)


## Only run examples in interactive R sessions
if (interactive()) {

  data(exTaxonList)
  data(exPftList)

  ui &lt;- fluidPage(
    radioMatrixInput(inputId = "rmi01", rowIDs = head(exTaxonList$Var),
           rowLLabels = head(as.matrix(subset(exTaxonList, select = "VarName"))),
           choices = exPftList$ID,
           selected = head(exTaxonList$DefPFT)),
    verbatimTextOutput('debug01')
  )

  server &lt;- function(input, output, session) {
    output$debug01 &lt;- renderPrint({input$rmi01})
  }

  shinyApp(ui, server)
}

if (interactive()) {

  ui &lt;- fluidPage(

    radioMatrixInput(inputId = "rmi02", rowIDs = c("Performance", "Statement A"),
                     rowLLabels = c("Poor", "Agree"),
                     rowRLabels = c("Excellent", "Disagree"),
                     choices = 1:5,
                     selected = rep(3, 2),
                     rowIDsName = "Grade",
                     labelsWidth = list("100px", "100px")),
    verbatimTextOutput('debug02')
  )

  server &lt;- function(input, output, session) {
    output$debug02 &lt;- renderPrint({input$rmi02})
  }

  shinyApp(ui, server)

}

</code></pre>

<hr>
<h2 id='shinyRadioMatrix-internal'>Internal shinyRadioMatrix Functions</h2><span id='topic+generateRadioRow'></span><span id='topic+generateRadioMatrixHeader'></span><span id='topic+generateRadioMatrix'></span><span id='topic+validateParams'></span>

<h3>Description</h3>

<p>Internal shinyRadioMatrix functions
</p>


<h3>Details</h3>

<p>These are not to be called by the user (or in some cases are just
waiting for proper documentation to be written :).
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
