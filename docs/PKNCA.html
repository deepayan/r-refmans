<!DOCTYPE html><html lang="en-US"><head><title>Help for package PKNCA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PKNCA}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#PKNCA'><p>Compute noncompartmental pharmacokinetics</p></a></li>
<li><a href='#add_impute_to_intervals'><p>Add the imputation column to the intervals, if it is not already there</p></a></li>
<li><a href='#add.interval.col'><p>Add columns for calculations within PKNCA intervals</p></a></li>
<li><a href='#addProvenance'><p>Add a hash and associated information to enable checking object provenance.</p></a></li>
<li><a href='#adj.r.squared'><p>Calculate the adjusted r-squared value</p></a></li>
<li><a href='#any_sparse_dense_in_interval'><p>Determine if there are any sparse or dense calculations requested within an interval</p></a></li>
<li><a href='#as_PKNCAconc'><p>Convert an object into a PKNCAconc object</p></a></li>
<li><a href='#as_sparse_pk'><p>Generate a sparse_pk object</p></a></li>
<li><a href='#as.data.frame.PKNCAresults'><p>Extract the parameter results from a PKNCAresults and return them as a</p>
data.frame.</a></li>
<li><a href='#assert_aucmethod'><p>Assert that a value is a valid AUC method</p></a></li>
<li><a href='#assert_conc'><p>Verify that concentration measurements are valid</p></a></li>
<li><a href='#assert_dosetau'><p>Assert that a value is a dosing interval</p></a></li>
<li><a href='#assert_intervaltime_single'><p>Assert that an interval is accurately defined as an interval, and return the</p>
interval</a></li>
<li><a href='#assert_lambdaz'><p>Assert that a lambda.z value is valid</p></a></li>
<li><a href='#assert_number_between'><p>Confirm that a value is greater than another value</p></a></li>
<li><a href='#assert_numeric_between'><p>Confirm that a value is greater than another value</p></a></li>
<li><a href='#assert_PKNCAdata'><p>Assert that an object is a PKNCAdata object</p></a></li>
<li><a href='#auc_integrate'><p>Support function for AUC integration</p></a></li>
<li><a href='#business.mean'><p>Generate functions to do the named function (e.g. mean) applying</p>
the business rules.</a></li>
<li><a href='#check.conversion'><p>Check that the conversion to a data type does not change the number</p>
of NA values</a></li>
<li><a href='#check.interval.deps'><p>Take in a single row of an interval specification and return that row updated</p>
with any additional calculations that must be done to fulfill all
dependencies.</a></li>
<li><a href='#check.interval.specification'><p>Check the formatting of a calculation interval specification data frame.</p></a></li>
<li><a href='#checkProvenance'><p>Check the hash of an object to confirm its provenance.</p></a></li>
<li><a href='#choose_interval_method'><p>Choose how to interpolate, extrapolate, or integrate data in each</p>
concentration interval</a></li>
<li><a href='#choose.auc.intervals'><p>Choose intervals to compute AUCs from time and dosing information</p></a></li>
<li><a href='#clean.conc.blq'><p>Handle BLQ values in the concentration measurements as requested by the user.</p></a></li>
<li><a href='#clean.conc.na'><p>Handle NA values in the concentration measurements as requested by the user.</p></a></li>
<li><a href='#cov_holder'><p>Calculate the covariance for two time points with sparse sampling</p></a></li>
<li><a href='#defunct'><p>The following functions are defunct</p></a></li>
<li><a href='#exclude'><p>Exclude data points or results from calculations or summarization.</p></a></li>
<li><a href='#exclude_nca'><p>Exclude NCA parameters based on examining the parameter set.</p></a></li>
<li><a href='#filter.PKNCAresults'><p>dplyr filtering for PKNCA</p></a></li>
<li><a href='#find.tau'><p>Find the repeating interval within a vector of doses</p></a></li>
<li><a href='#findOperator'><p>Find the first occurrence of an operator in a formula and return</p>
the left, right, or both sides of the operator.</a></li>
<li><a href='#fit_half_life'><p>Perform the half-life fit given the data.  The function simply fits</p>
the data without any validation.  No selection of points or any other
components are done.</a></li>
<li><a href='#formula.PKNCAconc'><p>Extract the formula from a PKNCAconc object.</p></a></li>
<li><a href='#geomean'><p>Compute the geometric mean, sd, and CV</p></a></li>
<li><a href='#get_impute_method'><p>Get the impute function from either the intervals column or from the method</p></a></li>
<li><a href='#get.best.model'><p>Extract the best model from a list of models using the AIC.</p></a></li>
<li><a href='#get.first.model'><p>Get the first model from a list of models</p></a></li>
<li><a href='#get.interval.cols'><p>Get the columns that can be used in an interval specification</p></a></li>
<li><a href='#get.parameter.deps'><p>Get all columns that depend on a parameter</p></a></li>
<li><a href='#getAttributeColumn'><p>Retrieve the value of an attribute column.</p></a></li>
<li><a href='#getColumnValueOrNot'><p>Get the value from a column in a data frame if the value is a column</p>
there, otherwise, the value should be a scalar or the length of the
data.</a></li>
<li><a href='#getDataName.PKNCAconc'><p>Get the name of the element containing the data for the current</p>
object.</a></li>
<li><a href='#getDepVar'><p>Get the dependent variable (left hand side of the formula) from a</p>
PKNCA object.</a></li>
<li><a href='#getGroups.PKNCAconc'><p>Get the groups (right hand side after the <code>|</code> from a PKNCA</p>
object).</a></li>
<li><a href='#getIndepVar'><p>Get the independent variable (right hand side of the formula) from</p>
a PKNCA object.</a></li>
<li><a href='#group_by.PKNCAresults'><p>dplyr grouping for PKNCA</p></a></li>
<li><a href='#group_vars.PKNCAconc'><p>Get grouping variables for a PKNCA object</p></a></li>
<li><a href='#inner_join.PKNCAresults'><p>dplyr joins for PKNCA</p></a></li>
<li><a href='#interp_extrap_conc_method'><p>Interpolate or extrapolate concentrations using the provided method</p></a></li>
<li><a href='#interp.extrap.conc'><p>Interpolate concentrations between measurements or extrapolate concentrations</p>
after the last measurement.</a></li>
<li><a href='#is_sparse_pk.PKNCAconc'><p>Is a PKNCA object used for sparse PK?</p></a></li>
<li><a href='#model.frame.PKNCAconc'><p>Extract the columns used in the formula (in order) from a PKNCAconc</p>
or PKNCAdose object.</a></li>
<li><a href='#mutate.PKNCAresults'><p>dplyr mutate-based modification for PKNCA</p></a></li>
<li><a href='#normalize_exclude'><p>Normalize the exclude column by setting blanks to NA</p></a></li>
<li><a href='#parse_formula_to_cols'><p>Convert a formula representation to the columns for input data</p></a></li>
<li><a href='#pk_nca_result_to_df'><p>Convert the grouping info and list of results for each group into a results</p>
data.frame</a></li>
<li><a href='#pk.business'><p>Run any function with a maximum missing fraction of X and 0s possibly</p>
counting as missing.  The maximum fraction missing comes from
<code>PKNCA.options("max.missing")</code>.</a></li>
<li><a href='#pk.calc.ae'><p>Calculate amount excreted (typically in urine or feces)</p></a></li>
<li><a href='#pk.calc.aucabove'><p>Calculate the AUC above a given concentration</p></a></li>
<li><a href='#pk.calc.aucint'><p>Calculate the AUC over an interval with interpolation and/or</p>
extrapolation of concentrations for the beginning and end of the
interval.</a></li>
<li><a href='#pk.calc.auciv'><p>Calculate AUC for intravenous dosing</p></a></li>
<li><a href='#pk.calc.aucpext'><p>Calculate the AUC percent extrapolated</p></a></li>
<li><a href='#pk.calc.auxc'><p>A compute the Area Under the (Moment) Curve</p></a></li>
<li><a href='#pk.calc.c0'><p>Estimate the concentration at dosing time for an IV bolus dose.</p></a></li>
<li><a href='#pk.calc.cav'><p>Calculate the average concentration during an interval.</p></a></li>
<li><a href='#pk.calc.ceoi'><p>Determine the concentration at the end of infusion</p></a></li>
<li><a href='#pk.calc.cl'><p>Calculate the (observed oral) clearance</p></a></li>
<li><a href='#pk.calc.clast.obs'><p>Determine the last observed concentration above the limit of quantification</p>
(LOQ).</a></li>
<li><a href='#pk.calc.clr'><p>Calculate renal clearance</p></a></li>
<li><a href='#pk.calc.cmax'><p>Determine maximum observed PK concentration</p></a></li>
<li><a href='#pk.calc.count_conc'><p>Count the number of concentration measurements in an interval</p></a></li>
<li><a href='#pk.calc.cstart'><p>Determine the concentration at the beginning of the interval</p></a></li>
<li><a href='#pk.calc.ctrough'><p>Determine the trough (end of interval) concentration</p></a></li>
<li><a href='#pk.calc.deg.fluc'><p>Determine the degree of fluctuation</p></a></li>
<li><a href='#pk.calc.dn'><p>Determine dose normalized NCA parameter</p></a></li>
<li><a href='#pk.calc.f'><p>Calculate the absolute (or relative) bioavailability</p></a></li>
<li><a href='#pk.calc.fe'><p>Calculate fraction excreted (typically in urine or feces)</p></a></li>
<li><a href='#pk.calc.half.life'><p>Compute the half-life and associated parameters</p></a></li>
<li><a href='#pk.calc.kel'><p>Calculate the elimination rate (Kel)</p></a></li>
<li><a href='#pk.calc.mrt'><p>Calculate the mean residence time (MRT) for single-dose data or linear</p>
multiple-dose data.</a></li>
<li><a href='#pk.calc.mrt.md'><p>Calculate the mean residence time (MRT) for multiple-dose data with nonlinear</p>
kinetics.</a></li>
<li><a href='#pk.calc.ptr'><p>Determine the peak-to-trough ratio</p></a></li>
<li><a href='#pk.calc.sparse_auc'><p>Calculate AUC and related parameters using sparse NCA methods</p></a></li>
<li><a href='#pk.calc.swing'><p>Determine the PK swing</p></a></li>
<li><a href='#pk.calc.thalf.eff'><p>Calculate the effective half-life</p></a></li>
<li><a href='#pk.calc.time_above'><p>Determine time at or above a set value</p></a></li>
<li><a href='#pk.calc.tlag'><p>Determine the observed lag time (time before the first</p>
concentration above the limit of quantification or above the first
concentration in the interval)</a></li>
<li><a href='#pk.calc.tlast'><p>Determine time of last observed concentration above the limit of</p>
quantification.</a></li>
<li><a href='#pk.calc.tmax'><p>Determine time of maximum observed PK concentration</p></a></li>
<li><a href='#pk.calc.totdose'><p>Extract the dose used for calculations</p></a></li>
<li><a href='#pk.calc.vss'><p>Calculate the steady-state volume of distribution (Vss)</p></a></li>
<li><a href='#pk.calc.vz'><p>Calculate the terminal volume of distribution (Vz)</p></a></li>
<li><a href='#pk.nca'><p>Compute NCA parameters for each interval for each subject.</p></a></li>
<li><a href='#pk.nca.interval'><p>Compute all PK parameters for a single concentration-time data set</p></a></li>
<li><a href='#pk.nca.intervals'><p>Compute NCA for multiple intervals</p></a></li>
<li><a href='#pk.tss'><p>Compute the time to steady-state (tss)</p></a></li>
<li><a href='#pk.tss.data.prep'><p>Clean up the time to steady-state parameters and return a data frame for use</p>
by the tss calculators.</a></li>
<li><a href='#pk.tss.monoexponential'><p>Compute the time to steady state using nonlinear, mixed-effects modeling of</p>
trough concentrations.</a></li>
<li><a href='#pk.tss.monoexponential.individual'><p>A helper function to estimate individual and single outputs for</p>
monoexponential time to steady-state.</a></li>
<li><a href='#pk.tss.monoexponential.population'><p>A helper function to estimate population and popind outputs for</p>
monoexponential time to steady-state.</a></li>
<li><a href='#pk.tss.stepwise.linear'><p>Compute the time to steady state using stepwise test of linear trend</p></a></li>
<li><a href='#pknca_find_units_param'><p>Find NCA parameters with a given unit type</p></a></li>
<li><a href='#PKNCA_impute_fun_list'><p>Separate out a vector of PKNCA imputation methods into a list of functions</p></a></li>
<li><a href='#PKNCA_impute_method'><p>Methods for imputation of data with PKNCA</p></a></li>
<li><a href='#pknca_unit_conversion'><p>Perform unit conversion (if possible) on PKNCA results</p></a></li>
<li><a href='#pknca_units_add_paren'><p>Add parentheses to a unit value, if needed</p></a></li>
<li><a href='#pknca_units_table'><p>Create a unit assignment and conversion table</p></a></li>
<li><a href='#PKNCA.choose.option'><p>Choose either the value from an option list or the current set value for an</p>
option.</a></li>
<li><a href='#PKNCA.options'><p>Set default options for PKNCA functions</p></a></li>
<li><a href='#PKNCA.options.describe'><p>Describe a PKNCA.options option by name.</p></a></li>
<li><a href='#PKNCA.set.summary'><p>Define how NCA parameters are summarized.</p></a></li>
<li><a href='#PKNCAconc'><p>Create a PKNCAconc object</p></a></li>
<li><a href='#PKNCAdata'><p>Create a PKNCAdata object.</p></a></li>
<li><a href='#PKNCAdose'><p>Create a PKNCAdose object</p></a></li>
<li><a href='#PKNCAresults'><p>Generate a PKNCAresults object</p></a></li>
<li><a href='#print.PKNCAconc'><p>Print and/or summarize a PKNCAconc or PKNCAdose object.</p></a></li>
<li><a href='#print.PKNCAdata'><p>Print a PKNCAdata object</p></a></li>
<li><a href='#print.provenance'><p>Print the summary of a provenance object</p></a></li>
<li><a href='#print.summary_PKNCAresults'><p>Print the results summary</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#roundingSummarize'><p>During the summarization of PKNCAresults, do the rounding of values</p>
based on the instructions given.</a></li>
<li><a href='#roundString'><p>Round a value to a defined number of digits printing out trailing zeros, if</p>
applicable.</a></li>
<li><a href='#setAttributeColumn'><p>Add an attribute to an object where the attribute is added as a name</p>
to the names of the object.</a></li>
<li><a href='#setDuration.PKNCAconc'><p>Set the duration of dosing or measurement</p></a></li>
<li><a href='#setExcludeColumn'><p>Set the exclude parameter on an object</p></a></li>
<li><a href='#setRoute'><p>Set the dosing route</p></a></li>
<li><a href='#signifString'><p>Round a value to a defined number of significant digits printing out trailing</p>
zeros, if applicable.</a></li>
<li><a href='#sort.interval.cols'><p>Sort the interval columns by dependencies.</p></a></li>
<li><a href='#sparse_auc_weight_linear'><p>Calculate the weight for sparse AUC calculation with the linear-trapezoidal</p>
rule</a></li>
<li><a href='#sparse_mean'><p>Calculate the mean concentration at all time points for use in sparse NCA</p>
calculations</a></li>
<li><a href='#sparse_pk_attribute'><p>Set or get a sparse_pk object attribute</p></a></li>
<li><a href='#sparse_to_dense_pk'><p>Extract the mean concentration-time profile as a data.frame</p></a></li>
<li><a href='#summary.PKNCAdata'><p>Summarize a PKNCAdata object showing important details about the</p>
concentration, dosing, and interval information.</a></li>
<li><a href='#summary.PKNCAresults'><p>Summarize PKNCA results</p></a></li>
<li><a href='#superposition'><p>Compute noncompartmental superposition for repeated dosing</p></a></li>
<li><a href='#time_calc'><p>Times relative to an event (typically dosing)</p></a></li>
<li><a href='#tss.monoexponential.generate.formula'><p>A helper function to generate the formula and starting values for the</p>
parameters in monoexponential models.</a></li>
<li><a href='#var_sparse_auc'><p>Calculate the variance for the AUC of sparsely sampled PK</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Perform Pharmacokinetic Non-Compartmental Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>0.11.0</td>
</tr>
<tr>
<td>Imports:</td>
<td>checkmate, dplyr (&ge; 0.5.0), digest, nlme, purrr, rlang,
stats, tidyr, tibble, utils, lifecycle</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, cowplot, ggplot2, knitr, labeling, pander, pmxTools,
rmarkdown, spelling, testthat (&ge; 3.0.0), units, withr</td>
</tr>
<tr>
<td>Description:</td>
<td>Compute standard Non-Compartmental Analysis (NCA) parameters for
    typical pharmacokinetic analyses and summarize them.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/AGPL-3">AGPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://billdenney.github.io/pknca/">https://billdenney.github.io/pknca/</a>,
<a href="https://github.com/billdenney/pknca">https://github.com/billdenney/pknca</a>,
<a href="http://billdenney.github.io/pknca/">http://billdenney.github.io/pknca/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/billdenney/pknca/issues">https://github.com/billdenney/pknca/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-19 12:11:59 UTC; bill</td>
</tr>
<tr>
<td>Author:</td>
<td>Bill Denney <a href="https://orcid.org/0000-0002-5759-428X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Clare Buckeridge [aut],
  Sridhar Duvvuri [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Bill Denney &lt;wdenney@humanpredictions.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-19 13:00:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='PKNCA'>Compute noncompartmental pharmacokinetics</h2><span id='topic+PKNCA-package'></span><span id='topic+PKNCA'></span>

<h3>Description</h3>

<p>Compute pharmacokinetic (PK) noncompartmental analysis (NCA)
parameters.
</p>


<h3>Details</h3>

<p>PKNCA has been cross-validated with both Phoenix WinNonlin(R) and Pumas
(click here for the
<a href="http://www.humanpredictions.com/wp-content/uploads/2020/01/ACOP_2019_T102_NCA_performance_evaluation_Yingbo_revised.pdf">cross-validation article</a>)
</p>
<p>A common workflow would load data from a file or database into a
data.frame then run the following code.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Bill Denney <a href="mailto:wdenney@humanpredictions.com">wdenney@humanpredictions.com</a> (<a href="https://orcid.org/0000-0002-5759-428X">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Clare Buckeridge <a href="mailto:clare.buckeridge@pfizer.com">clare.buckeridge@pfizer.com</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Sridhar Duvvuri [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://billdenney.github.io/pknca/">https://billdenney.github.io/pknca/</a>
</p>
</li>
<li> <p><a href="https://github.com/billdenney/pknca">https://github.com/billdenney/pknca</a>
</p>
</li>
<li> <p><a href="http://billdenney.github.io/pknca/">http://billdenney.github.io/pknca/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/billdenney/pknca/issues">https://github.com/billdenney/pknca/issues</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Load concentration-time data into a data.frame called d.conc
# with columns named "conc", "time", and "subject".
my.conc &lt;- PKNCAconc(d.conc, conc~time|subject)
# Load dose-time data into a data.frame called d.dose
# with columns named "dose", "time", and "subject".
my.dose &lt;- PKNCAdose(d.dose, dose~time|subject)
# Combine the concentration-time and dose-time data into an object
# ready for calculations.
my.data &lt;- PKNCAdata(my.conc, my.dose)
# Perform the calculations
my.results &lt;- pk.nca(my.data)
# Look at summary results
summary(my.results)
# Look at a listing of results
as.data.frame(my.results)

## End(Not run)
</code></pre>

<hr>
<h2 id='add_impute_to_intervals'>Add the imputation column to the intervals, if it is not already there</h2><span id='topic+add_impute_to_intervals'></span>

<h3>Description</h3>

<p>Add the imputation column to the intervals, if it is not already there
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_impute_to_intervals(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_impute_to_intervals_+3A_object">object</code></td>
<td>
<p>The PKNCAdata object to impute data within</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The PKNCAdata object with an impute column added to the intervals (if
it is not already there) and the object$impute set to that column name
</p>

<hr>
<h2 id='add.interval.col'>Add columns for calculations within PKNCA intervals</h2><span id='topic+add.interval.col'></span>

<h3>Description</h3>

<p>Add columns for calculations within PKNCA intervals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.interval.col(
  name,
  FUN,
  values = c(FALSE, TRUE),
  unit_type,
  pretty_name,
  depends = NULL,
  desc = "",
  sparse = FALSE,
  formalsmap = list(),
  datatype = c("interval", "individual", "population")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add.interval.col_+3A_name">name</code></td>
<td>
<p>The column name as a character string</p>
</td></tr>
<tr><td><code id="add.interval.col_+3A_fun">FUN</code></td>
<td>
<p>The function to run (as a character string) or <code>NA</code> if the
parameter is automatically calculated when calculating another parameter.</p>
</td></tr>
<tr><td><code id="add.interval.col_+3A_values">values</code></td>
<td>
<p>Valid values for the column</p>
</td></tr>
<tr><td><code id="add.interval.col_+3A_unit_type">unit_type</code></td>
<td>
<p>The type of units to use for assigning and converting units.</p>
</td></tr>
<tr><td><code id="add.interval.col_+3A_pretty_name">pretty_name</code></td>
<td>
<p>The name of the parameter to use for printing in summary
tables with units.  (If an analysis does not include units, then the normal
name is used.)</p>
</td></tr>
<tr><td><code id="add.interval.col_+3A_depends">depends</code></td>
<td>
<p>Character vector of columns that must be run before this
column.</p>
</td></tr>
<tr><td><code id="add.interval.col_+3A_desc">desc</code></td>
<td>
<p>A human-readable description of the parameter (&lt;=40 characters to
comply with SDTM)</p>
</td></tr>
<tr><td><code id="add.interval.col_+3A_sparse">sparse</code></td>
<td>
<p>Is the calculation for sparse PK?</p>
</td></tr>
<tr><td><code id="add.interval.col_+3A_formalsmap">formalsmap</code></td>
<td>
<p>A named list mapping parameter names in the function call
to NCA parameter names.  See the details for information on use of
<code>formalsmap</code>.</p>
</td></tr>
<tr><td><code id="add.interval.col_+3A_datatype">datatype</code></td>
<td>
<p>The type of data used for the calculation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>formalsmap</code> argument enables mapping some alternate formal
argument names to parameters.  It is used to generalize functions that may
use multiple similar arguments (such as the variants of mean residence time).
The names of the list should correspond to function formal parameter names
and the values should be one of the following:
</p>

<ul>
<li><p>For the current interval:
</p>

<dl>
<dt>character strings of NCA parameter name</dt><dd><p>The value of the parameter calculated for the current interval.</p>
</dd>
<dt>&quot;conc&quot;</dt><dd><p>Concentration measurements for the current interval.</p>
</dd>
<dt>&quot;time&quot;</dt><dd><p>Times associated with concentration measurements for the current interval (values start at 0 at the beginning of the current interval).</p>
</dd>
<dt>&quot;volume&quot;</dt><dd><p>Volume associated with concentration measurements for the current interval (typically applies for excretion parameters like urine).</p>
</dd>
<dt>&quot;duration.conc&quot;</dt><dd><p>Durations associated with concentration measurements for the current interval.</p>
</dd>
<dt>&quot;dose&quot;</dt><dd><p>Dose amounts assocuated with the current interval.</p>
</dd>
<dt>&quot;time.dose&quot;</dt><dd><p>Time of dose start associated with the current interval (values start at 0 at the beginning of the current interval).</p>
</dd>
<dt>&quot;duration.dose&quot;</dt><dd><p>Duration of dose (typically infusion duration) for doses in the current interval.</p>
</dd>
<dt>&quot;route&quot;</dt><dd><p>Route of dosing for the current interval.</p>
</dd>
<dt>&quot;start&quot;</dt><dd><p>Time of interval start.</p>
</dd>
<dt>&quot;end&quot;</dt><dd><p>Time of interval end.</p>
</dd>
<dt>&quot;options&quot;</dt><dd><p>PKNCA.options governing calculations.</p>
</dd>
</dl>

</li>
<li><p>For the current group:
</p>

<dl>
<dt>&quot;conc.group&quot;</dt><dd><p>Concentration measurements for the current group.</p>
</dd>
<dt>&quot;time.group&quot;</dt><dd><p>Times associated with concentration measurements for the current group (values start at 0 at the beginning of the current interval).</p>
</dd>
<dt>&quot;volume.group&quot;</dt><dd><p>Volume associated with concentration measurements for the current interval (typically applies for excretion parameters like urine).</p>
</dd>
<dt>&quot;duration.conc.group&quot;</dt><dd><p>Durations assocuated with concentration measurements for the current group.</p>
</dd>
<dt>&quot;dose.group&quot;</dt><dd><p>Dose amounts assocuated with the current group.</p>
</dd>
<dt>&quot;time.dose.group&quot;</dt><dd><p>Time of dose start associated with the current group (values start at 0 at the beginning of the current interval).</p>
</dd>
<dt>&quot;duration.dose.group&quot;</dt><dd><p>Duration of dose (typically infusion duration) for doses in the current group.</p>
</dd>
<dt>&quot;route.group&quot;</dt><dd><p>Route of dosing for the current group.</p>
</dd>
</dl>

</li></ul>



<h3>Value</h3>

<p>NULL (Calling this function has a side effect of changing the
available intervals for calculations)
</p>


<h3>See Also</h3>

<p>Other Interval specifications: 
<code><a href="#topic+check.interval.deps">check.interval.deps</a>()</code>,
<code><a href="#topic+check.interval.specification">check.interval.specification</a>()</code>,
<code><a href="#topic+choose.auc.intervals">choose.auc.intervals</a>()</code>,
<code><a href="#topic+get.interval.cols">get.interval.cols</a>()</code>,
<code><a href="#topic+get.parameter.deps">get.parameter.deps</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
add.interval.col("cmax",
                 FUN="pk.calc.cmax",
                 values=c(FALSE, TRUE),
                 unit_type="conc",
                 pretty_name="Cmax",
                 desc="Maximum observed concentration")
add.interval.col("cmax.dn",
                 FUN="pk.calc.dn",
                 values=c(FALSE, TRUE),
                 unit_type="conc_dosenorm",
                 pretty_name="Cmax (dose-normalized)",
                 desc="Maximum observed concentration, dose normalized",
                 formalsmap=list(parameter="cmax"),
                 depends="cmax")

## End(Not run)
</code></pre>

<hr>
<h2 id='addProvenance'>Add a hash and associated information to enable checking object provenance.</h2><span id='topic+addProvenance'></span>

<h3>Description</h3>

<p>Add a hash and associated information to enable checking object provenance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addProvenance(object, replace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addProvenance_+3A_object">object</code></td>
<td>
<p>The object to add provenance</p>
</td></tr>
<tr><td><code id="addProvenance_+3A_replace">replace</code></td>
<td>
<p>Replace provenance if the object already has a provenance
attribute.  (If the object already has provenance and <code>replace</code> is <code>FALSE</code>,
then an error will be raised.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The object with provenance as an added item
</p>


<h3>See Also</h3>

<p><code><a href="#topic+checkProvenance">checkProvenance()</a></code>
</p>

<hr>
<h2 id='adj.r.squared'>Calculate the adjusted r-squared value</h2><span id='topic+adj.r.squared'></span>

<h3>Description</h3>

<p>Calculate the adjusted r-squared value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adj.r.squared(r.sq, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adj.r.squared_+3A_r.sq">r.sq</code></td>
<td>
<p>The r-squared value</p>
</td></tr>
<tr><td><code id="adj.r.squared_+3A_n">n</code></td>
<td>
<p>The number of points</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The numeric adjusted r-squared value
</p>

<hr>
<h2 id='any_sparse_dense_in_interval'>Determine if there are any sparse or dense calculations requested within an interval</h2><span id='topic+any_sparse_dense_in_interval'></span>

<h3>Description</h3>

<p>Determine if there are any sparse or dense calculations requested within an interval
</p>


<h3>Usage</h3>

<pre><code class='language-R'>any_sparse_dense_in_interval(interval, sparse)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="any_sparse_dense_in_interval_+3A_interval">interval</code></td>
<td>
<p>An interval specification</p>
</td></tr>
<tr><td><code id="any_sparse_dense_in_interval_+3A_sparse">sparse</code></td>
<td>
<p>Are the concentration-time data sparse PK (commonly used in
small nonclinical species or with terminal or difficult sampling) or dense
PK (commonly used in clinical studies or larger nonclinical species)?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value indicating if the interval requests any sparse (if
<code>sparse=TRUE</code>) or dense (if <code>sparse=FALSE</code>) calculations.
</p>

<hr>
<h2 id='as_PKNCAconc'>Convert an object into a PKNCAconc object</h2><span id='topic+as_PKNCAconc'></span><span id='topic+as_PKNCAdose'></span><span id='topic+as_PKNCAdata'></span><span id='topic+as_PKNCAresults'></span>

<h3>Description</h3>

<p>Convert an object into a PKNCAconc object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_PKNCAconc(x, ...)

as_PKNCAdose(x, ...)

as_PKNCAdata(x, ...)

as_PKNCAresults(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_PKNCAconc_+3A_x">x</code></td>
<td>
<p>The object to convert</p>
</td></tr>
<tr><td><code id="as_PKNCAconc_+3A_...">...</code></td>
<td>
<p>Passed to subsequent methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A converted object
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>as_PKNCAdose()</code>: Convert an object into a PKNCAdose object
</p>
</li>
<li> <p><code>as_PKNCAdata()</code>: Convert an object into a PKNCAdata object
</p>
</li>
<li> <p><code>as_PKNCAresults()</code>: Convert an object into a PKNCAresults object
</p>
</li></ul>

<hr>
<h2 id='as_sparse_pk'>Generate a sparse_pk object</h2><span id='topic+as_sparse_pk'></span>

<h3>Description</h3>

<p>Generate a sparse_pk object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_sparse_pk(conc, time, subject)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_sparse_pk_+3A_conc">conc</code></td>
<td>
<p>Measured concentrations</p>
</td></tr>
<tr><td><code id="as_sparse_pk_+3A_time">time</code></td>
<td>
<p>Time of the measurement of the concentrations</p>
</td></tr>
<tr><td><code id="as_sparse_pk_+3A_subject">subject</code></td>
<td>
<p>Subject identifiers (may be any class; may not be null)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sparse_pk object which is a list of lists.  The inner lists have
elements named: &quot;time&quot;, The time of measurement; &quot;conc&quot;, The concentration
measured; &quot;subject&quot;, The subject identifiers.  The object will usually be
modified by future functions to add more named elements to the inner list.
</p>


<h3>See Also</h3>

<p>Other Sparse Methods: 
<code><a href="#topic+pk.calc.sparse_auc">pk.calc.sparse_auc</a>()</code>,
<code><a href="#topic+sparse_auc_weight_linear">sparse_auc_weight_linear</a>()</code>,
<code><a href="#topic+sparse_mean">sparse_mean</a>()</code>
</p>

<hr>
<h2 id='as.data.frame.PKNCAresults'>Extract the parameter results from a PKNCAresults and return them as a
data.frame.</h2><span id='topic+as.data.frame.PKNCAresults'></span>

<h3>Description</h3>

<p>Extract the parameter results from a PKNCAresults and return them as a
data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PKNCAresults'
as.data.frame(
  x,
  ...,
  out_format = c("long", "wide"),
  filter_requested = FALSE,
  filter_excluded = FALSE,
  out.format = deprecated()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.data.frame.PKNCAresults_+3A_x">x</code></td>
<td>
<p>The object to extract results from</p>
</td></tr>
<tr><td><code id="as.data.frame.PKNCAresults_+3A_...">...</code></td>
<td>
<p>Ignored (for compatibility with generic <code><a href="base.html#topic+as.data.frame">as.data.frame()</a></code>)</p>
</td></tr>
<tr><td><code id="as.data.frame.PKNCAresults_+3A_out_format">out_format</code></td>
<td>
<p>Should the output be 'long' (default) or 'wide'?</p>
</td></tr>
<tr><td><code id="as.data.frame.PKNCAresults_+3A_filter_requested">filter_requested</code></td>
<td>
<p>Only return rows with parameters that were
specifically requested?</p>
</td></tr>
<tr><td><code id="as.data.frame.PKNCAresults_+3A_filter_excluded">filter_excluded</code></td>
<td>
<p>Should excluded values be removed?</p>
</td></tr>
<tr><td><code id="as.data.frame.PKNCAresults_+3A_out.format">out.format</code></td>
<td>
<p>Deprecated in favor of <code>out_format</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame (or usually a tibble) of results
</p>

<hr>
<h2 id='assert_aucmethod'>Assert that a value is a valid AUC method</h2><span id='topic+assert_aucmethod'></span>

<h3>Description</h3>

<p>Assert that a value is a valid AUC method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assert_aucmethod(method = c("lin up/log down", "linear", "lin-log"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assert_aucmethod_+3A_method">method</code></td>
<td>
<p>The method for integration (one of 'lin up/log down',
'lin-log', or 'linear')</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>method</code> or an informative error
</p>

<hr>
<h2 id='assert_conc'>Verify that concentration measurements are valid</h2><span id='topic+assert_conc'></span><span id='topic+assert_time'></span><span id='topic+assert_conc_time'></span>

<h3>Description</h3>

<p>If the concentrations or times are invalid, will provide an error.
Reasons for being invalid are
</p>

<ul>
<li> <p><code>time</code> is not a number
</p>
</li>
<li> <p><code>conc</code> is not a number
</p>
</li>
<li><p> Any <code>time</code> value is NA
</p>
</li>
<li> <p><code>time</code> is not monotonically increasing
</p>
</li>
<li> <p><code>conc</code> and <code>time</code> are not the same length
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>assert_conc(conc, any_missing_conc = TRUE)

assert_time(time, sorted_time = TRUE)

assert_conc_time(conc, time, any_missing_conc = TRUE, sorted_time = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assert_conc_+3A_conc">conc</code></td>
<td>
<p>Measured concentrations</p>
</td></tr>
<tr><td><code id="assert_conc_+3A_any_missing_conc">any_missing_conc</code></td>
<td>
<p>Are any concentration values allowed to be <code>NA</code>?</p>
</td></tr>
<tr><td><code id="assert_conc_+3A_time">time</code></td>
<td>
<p>Time of the measurement of the concentrations</p>
</td></tr>
<tr><td><code id="assert_conc_+3A_sorted_time">sorted_time</code></td>
<td>
<p>Must the time be unique and monotonically increasing?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Some cases may generate warnings but allow the data to proceed.
</p>

<ul>
<li><p> A negative concentration is often but not always an
error; it will generate a warning.
</p>
</li></ul>



<h3>Value</h3>

<p><code>conc</code> or give an informative error
</p>
<p><code>time</code> or give an informative error
</p>
<p>A data.frame with columns named &quot;conc&quot; and &quot;time&quot; or an informative
error
</p>

<hr>
<h2 id='assert_dosetau'>Assert that a value is a dosing interval</h2><span id='topic+assert_dosetau'></span>

<h3>Description</h3>

<p>Assert that a value is a dosing interval
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assert_dosetau(tau)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assert_dosetau_+3A_tau">tau</code></td>
<td>
<p>The dosing interval</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>tau</code> or an informative error
</p>

<hr>
<h2 id='assert_intervaltime_single'>Assert that an interval is accurately defined as an interval, and return the
interval</h2><span id='topic+assert_intervaltime_single'></span>

<h3>Description</h3>

<p>Assert that an interval is accurately defined as an interval, and return the
interval
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assert_intervaltime_single(interval = NULL, start = NULL, end = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assert_intervaltime_single_+3A_interval">interval</code></td>
<td>
<p>Numeric vector of two numbers for the start and end time of
integration</p>
</td></tr>
<tr><td><code id="assert_intervaltime_single_+3A_start">start</code></td>
<td>
<p>The start time of the interval</p>
</td></tr>
<tr><td><code id="assert_intervaltime_single_+3A_end">end</code></td>
<td>
<p>The end time of the interval</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>interval</code> (or <code>c(start, end)</code>)
</p>

<hr>
<h2 id='assert_lambdaz'>Assert that a lambda.z value is valid</h2><span id='topic+assert_lambdaz'></span>

<h3>Description</h3>

<p>Assert that a lambda.z value is valid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assert_lambdaz(
  lambda.z,
  any.missing = TRUE,
  .var.name = checkmate::vname(lambda.z)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assert_lambdaz_+3A_lambda.z">lambda.z</code></td>
<td>
<p>The elimination rate (in units of inverse time) for
extrapolation</p>
</td></tr>
<tr><td><code id="assert_lambdaz_+3A_any.missing">any.missing</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Are vectors with missing values allowed? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="assert_lambdaz_+3A_.var.name">.var.name</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Name of the checked object to print in assertions. Defaults to
the heuristic implemented in <code><a href="checkmate.html#topic+vname">vname</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>lambda.z</code> or an informative error
</p>

<hr>
<h2 id='assert_number_between'>Confirm that a value is greater than another value</h2><span id='topic+assert_number_between'></span>

<h3>Description</h3>

<p>Confirm that a value is greater than another value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assert_number_between(
  x,
  ...,
  na.ok = FALSE,
  len = 1,
  .var.name = checkmate::vname(x)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assert_number_between_+3A_x">x</code></td>
<td>
<p>[any]<br />
Object to check.</p>
</td></tr>
<tr><td><code id="assert_number_between_+3A_...">...</code></td>
<td>
<p>Passed to <code>assert_numeric_between()</code></p>
</td></tr>
<tr><td><code id="assert_number_between_+3A_na.ok">na.ok</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Are missing values allowed? Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="assert_number_between_+3A_len">len</code></td>
<td>
<p>Ignored (must be 1)</p>
</td></tr>
<tr><td><code id="assert_number_between_+3A_.var.name">.var.name</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Name of the checked object to print in assertions. Defaults to
the heuristic implemented in <code><a href="checkmate.html#topic+vname">vname</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> or an informative error
</p>

<hr>
<h2 id='assert_numeric_between'>Confirm that a value is greater than another value</h2><span id='topic+assert_numeric_between'></span>

<h3>Description</h3>

<p>Confirm that a value is greater than another value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assert_numeric_between(
  x,
  any.missing = FALSE,
  null.ok = FALSE,
  lower_eq = -Inf,
  lower = -Inf,
  upper = Inf,
  upper_eq = Inf,
  ...,
  .var.name = checkmate::vname(x)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assert_numeric_between_+3A_x">x</code></td>
<td>
<p>[any]<br />
Object to check.</p>
</td></tr>
<tr><td><code id="assert_numeric_between_+3A_any.missing">any.missing</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Are vectors with missing values allowed? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="assert_numeric_between_+3A_null.ok">null.ok</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
If set to <code>TRUE</code>, <code>x</code> may also be <code>NULL</code>.
In this case only a type check of <code>x</code> is performed, all additional checks are disabled.</p>
</td></tr>
<tr><td><code id="assert_numeric_between_+3A_lower_eq">lower_eq</code>, <code id="assert_numeric_between_+3A_upper_eq">upper_eq</code></td>
<td>
<p>Values where equality is not allowed</p>
</td></tr>
<tr><td><code id="assert_numeric_between_+3A_lower">lower</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Lower value all elements of <code>x</code> must be greater than or equal to.</p>
</td></tr>
<tr><td><code id="assert_numeric_between_+3A_upper">upper</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Upper value all elements of <code>x</code> must be lower than or equal to.</p>
</td></tr>
<tr><td><code id="assert_numeric_between_+3A_...">...</code></td>
<td>
<p>Passed to <code>checkmate::assert_numeric()</code></p>
</td></tr>
<tr><td><code id="assert_numeric_between_+3A_.var.name">.var.name</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Name of the checked object to print in assertions. Defaults to
the heuristic implemented in <code><a href="checkmate.html#topic+vname">vname</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code>
</p>

<hr>
<h2 id='assert_PKNCAdata'>Assert that an object is a PKNCAdata object</h2><span id='topic+assert_PKNCAdata'></span>

<h3>Description</h3>

<p>Assert that an object is a PKNCAdata object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assert_PKNCAdata(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assert_PKNCAdata_+3A_object">object</code></td>
<td>
<p>The PKNCAdata object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The PKNCAdata object (confirmed to be usable)
</p>

<hr>
<h2 id='auc_integrate'>Support function for AUC integration</h2><span id='topic+auc_integrate'></span>

<h3>Description</h3>

<p>Support function for AUC integration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auc_integrate(
  conc,
  time,
  clast,
  tlast,
  lambda.z,
  interval_method,
  fun_linear,
  fun_log,
  fun_inf
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="auc_integrate_+3A_conc">conc</code></td>
<td>
<p>Measured concentrations</p>
</td></tr>
<tr><td><code id="auc_integrate_+3A_time">time</code></td>
<td>
<p>Time of the measurement of the concentrations</p>
</td></tr>
<tr><td><code id="auc_integrate_+3A_clast">clast</code></td>
<td>
<p>The last concentration above the limit of quantification</p>
</td></tr>
<tr><td><code id="auc_integrate_+3A_tlast">tlast</code></td>
<td>
<p>Time of last concentration above the limit of quantification
(will be calculated, if not provided)</p>
</td></tr>
<tr><td><code id="auc_integrate_+3A_lambda.z">lambda.z</code></td>
<td>
<p>The elimination rate (in units of inverse time) for
extrapolation</p>
</td></tr>
<tr><td><code id="auc_integrate_+3A_interval_method">interval_method</code></td>
<td>
<p>The method for integrating each interval of <code>conc</code></p>
</td></tr>
<tr><td><code id="auc_integrate_+3A_fun_linear">fun_linear</code></td>
<td>
<p>The function to use for integration of the linear part of
the curve (not required for AUC or AUMC functions)</p>
</td></tr>
<tr><td><code id="auc_integrate_+3A_fun_log">fun_log</code></td>
<td>
<p>The function to use for integration of the logarithmic part of
the curve (if log integration is used; not required for AUC or AUMC
functions)</p>
</td></tr>
<tr><td><code id="auc_integrate_+3A_fun_inf">fun_inf</code></td>
<td>
<p>The function to use for extrapolation from the final
measurement to infinite time (not required for AUC or AUMC functions.</p>
</td></tr>
</table>

<hr>
<h2 id='business.mean'>Generate functions to do the named function (e.g. mean) applying
the business rules.</h2><span id='topic+business.mean'></span><span id='topic+business.sd'></span><span id='topic+business.cv'></span><span id='topic+business.geomean'></span><span id='topic+business.geocv'></span><span id='topic+business.min'></span><span id='topic+business.max'></span><span id='topic+business.median'></span><span id='topic+business.range'></span>

<h3>Description</h3>

<p>Generate functions to do the named function (e.g. mean) applying
the business rules.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>business.mean(x, ...)

business.sd(x, ...)

business.cv(x, ...)

business.geomean(x, ...)

business.geocv(x, ...)

business.min(x, ...)

business.max(x, ...)

business.median(x, ...)

business.range(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="business.mean_+3A_x">x</code></td>
<td>
<p>vector to be passed to the various functions</p>
</td></tr>
<tr><td><code id="business.mean_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the underlying function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the various functions or NA if too many values are
missing
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>business.sd()</code>: Compute the standard deviation with business rules.
</p>
</li>
<li> <p><code>business.cv()</code>: Compute the coefficient of variation with business rules.
</p>
</li>
<li> <p><code>business.geomean()</code>: Compute the geometric mean with business rules.
</p>
</li>
<li> <p><code>business.geocv()</code>: Compute the geometric coefficient of variation with business rules.
</p>
</li>
<li> <p><code>business.min()</code>: Compute the minimum with business rules.
</p>
</li>
<li> <p><code>business.max()</code>: Compute the maximum with business rules.
</p>
</li>
<li> <p><code>business.median()</code>: Compute the median with business rules.
</p>
</li>
<li> <p><code>business.range()</code>: Compute the range with business rules.
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+pk.business">pk.business()</a></code>
</p>

<hr>
<h2 id='check.conversion'>Check that the conversion to a data type does not change the number
of NA values</h2><span id='topic+check.conversion'></span>

<h3>Description</h3>

<p>Check that the conversion to a data type does not change the number
of NA values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.conversion(x, FUN, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check.conversion_+3A_x">x</code></td>
<td>
<p>the value to convert</p>
</td></tr>
<tr><td><code id="check.conversion_+3A_fun">FUN</code></td>
<td>
<p>the function to use for conversion</p>
</td></tr>
<tr><td><code id="check.conversion_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>FUN</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>FUN(x, ...)</code> or an error if the set of NAs change.
</p>

<hr>
<h2 id='check.interval.deps'>Take in a single row of an interval specification and return that row updated
with any additional calculations that must be done to fulfill all
dependencies.</h2><span id='topic+check.interval.deps'></span>

<h3>Description</h3>

<p>Take in a single row of an interval specification and return that row updated
with any additional calculations that must be done to fulfill all
dependencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.interval.deps(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check.interval.deps_+3A_x">x</code></td>
<td>
<p>A data frame with one or more rows of the PKNCA interval</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The interval specification with additional calculations added where
requested outputs require them.
</p>


<h3>See Also</h3>

<p>Other Interval specifications: 
<code><a href="#topic+add.interval.col">add.interval.col</a>()</code>,
<code><a href="#topic+check.interval.specification">check.interval.specification</a>()</code>,
<code><a href="#topic+choose.auc.intervals">choose.auc.intervals</a>()</code>,
<code><a href="#topic+get.interval.cols">get.interval.cols</a>()</code>,
<code><a href="#topic+get.parameter.deps">get.parameter.deps</a>()</code>
</p>

<hr>
<h2 id='check.interval.specification'>Check the formatting of a calculation interval specification data frame.</h2><span id='topic+check.interval.specification'></span>

<h3>Description</h3>

<p>Calculation interval specifications are data frames defining what
calculations will be required and summarized from all time intervals. Note:
parameters which are not requested may be calculated if it is required for
(or computed at the same time as) a requested parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.interval.specification(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check.interval.specification_+3A_x">x</code></td>
<td>
<p>The data frame specifying what to calculate during each time
interval</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>start</code> and <code>end</code> time must always be given as columns, and the <code>start</code> must
be before the <code>end</code>.  Other columns define the parameters to be calculated
and the groupings to apply the intervals to.
</p>


<h3>Value</h3>

<p>x The potentially updated data frame with the interval calculation
specification.
</p>


<h3>See Also</h3>

<p>The vignette &quot;Selection of Calculation Intervals&quot;
</p>
<p>Other Interval specifications: 
<code><a href="#topic+add.interval.col">add.interval.col</a>()</code>,
<code><a href="#topic+check.interval.deps">check.interval.deps</a>()</code>,
<code><a href="#topic+choose.auc.intervals">choose.auc.intervals</a>()</code>,
<code><a href="#topic+get.interval.cols">get.interval.cols</a>()</code>,
<code><a href="#topic+get.parameter.deps">get.parameter.deps</a>()</code>
</p>

<hr>
<h2 id='checkProvenance'>Check the hash of an object to confirm its provenance.</h2><span id='topic+checkProvenance'></span>

<h3>Description</h3>

<p>Check the hash of an object to confirm its provenance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkProvenance(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkProvenance_+3A_object">object</code></td>
<td>
<p>The object to check provenance for</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if the provenance is confirmed to be consistent, <code>FALSE</code> if
the provenance is not consistent, or <code>NA</code> if provenance is not present.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+addProvenance">addProvenance()</a></code>
</p>

<hr>
<h2 id='choose_interval_method'>Choose how to interpolate, extrapolate, or integrate data in each
concentration interval</h2><span id='topic+choose_interval_method'></span>

<h3>Description</h3>

<p>Choose how to interpolate, extrapolate, or integrate data in each
concentration interval
</p>


<h3>Usage</h3>

<pre><code class='language-R'>choose_interval_method(conc, time, tlast, method, auc.type, options)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="choose_interval_method_+3A_conc">conc</code></td>
<td>
<p>Measured concentrations</p>
</td></tr>
<tr><td><code id="choose_interval_method_+3A_time">time</code></td>
<td>
<p>Time of the measurement of the concentrations</p>
</td></tr>
<tr><td><code id="choose_interval_method_+3A_tlast">tlast</code></td>
<td>
<p>Time of last concentration above the limit of quantification
(will be calculated, if not provided)</p>
</td></tr>
<tr><td><code id="choose_interval_method_+3A_method">method</code></td>
<td>
<p>The method for integration (one of 'lin up/log down',
'lin-log', or 'linear')</p>
</td></tr>
<tr><td><code id="choose_interval_method_+3A_auc.type">auc.type</code></td>
<td>
<p>The type of AUC to compute.  Choices are 'AUCinf', 'AUClast',
and 'AUCall'.</p>
</td></tr>
<tr><td><code id="choose_interval_method_+3A_options">options</code></td>
<td>
<p>List of changes to the default PKNCA options (see
<code>PKNCA.options()</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of methods for interpolation/extrapolation
methods that is the same length as <code>conc</code> which indicates how to
interpolate/integrate between each of the concentrations (all but the last
value in the vector) and how to extrapolate after <code>tlast</code> (the last item in
the vector).  Possible values in the vector are: 'zero', 'linear', 'log',
and 'extrap_log'
</p>

<hr>
<h2 id='choose.auc.intervals'>Choose intervals to compute AUCs from time and dosing information</h2><span id='topic+choose.auc.intervals'></span>

<h3>Description</h3>

<p>Intervals for AUC are selected by the following metrics:
</p>

<ol>
<li><p> If only one dose is administered, use the
<code>PKNCA.options("single.dose.aucs")</code>
</p>
</li>
<li><p> If more than one dose is administered, estimate the AUC
between any two doses that have PK taken at both of the
dosing times and at least one time  between the doses.
</p>
</li>
<li><p> For the final dose of multiple doses, try to determine the
dosing interval (<code class="reqn">\tau</code>) and estimate the AUC in that
interval if multiple samples are taken in the interval.
</p>
</li>
<li><p> If there are samples <code class="reqn">&gt; \tau</code> after the last dose,
calculate the half life after the last dose.
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>choose.auc.intervals(
  time.conc,
  time.dosing,
  options = list(),
  single.dose.aucs = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="choose.auc.intervals_+3A_time.conc">time.conc</code></td>
<td>
<p>Time of concentration measurement</p>
</td></tr>
<tr><td><code id="choose.auc.intervals_+3A_time.dosing">time.dosing</code></td>
<td>
<p>Time of dosing</p>
</td></tr>
<tr><td><code id="choose.auc.intervals_+3A_options">options</code></td>
<td>
<p>List of changes to the default PKNCA options (see
<code>PKNCA.options()</code>)</p>
</td></tr>
<tr><td><code id="choose.auc.intervals_+3A_single.dose.aucs">single.dose.aucs</code></td>
<td>
<p>The AUC specification for single dosing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with columns for <code>start</code>, <code>end</code>, <code>auc.type</code>, and
<code>half.life</code>.  See <code><a href="#topic+check.interval.specification">check.interval.specification()</a></code> for column definitions.
The data frame may have zero rows if no intervals could be found.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pk.calc.auc">pk.calc.auc()</a></code>, <code><a href="#topic+pk.calc.aumc">pk.calc.aumc()</a></code>, <code><a href="#topic+pk.calc.half.life">pk.calc.half.life()</a></code>,
<code><a href="#topic+PKNCA.options">PKNCA.options()</a></code>
</p>
<p>Other Interval specifications: 
<code><a href="#topic+add.interval.col">add.interval.col</a>()</code>,
<code><a href="#topic+check.interval.deps">check.interval.deps</a>()</code>,
<code><a href="#topic+check.interval.specification">check.interval.specification</a>()</code>,
<code><a href="#topic+get.interval.cols">get.interval.cols</a>()</code>,
<code><a href="#topic+get.parameter.deps">get.parameter.deps</a>()</code>
</p>
<p>Other Interval determination: 
<code><a href="#topic+find.tau">find.tau</a>()</code>
</p>

<hr>
<h2 id='clean.conc.blq'>Handle BLQ values in the concentration measurements as requested by the user.</h2><span id='topic+clean.conc.blq'></span>

<h3>Description</h3>

<p>Handle BLQ values in the concentration measurements as requested by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean.conc.blq(
  conc,
  time,
  ...,
  options = list(),
  conc.blq = NULL,
  conc.na = NULL,
  check = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clean.conc.blq_+3A_conc">conc</code></td>
<td>
<p>Measured concentrations</p>
</td></tr>
<tr><td><code id="clean.conc.blq_+3A_time">time</code></td>
<td>
<p>Time of the measurement of the concentrations</p>
</td></tr>
<tr><td><code id="clean.conc.blq_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to clean.conc.na</p>
</td></tr>
<tr><td><code id="clean.conc.blq_+3A_options">options</code></td>
<td>
<p>List of changes to the default PKNCA options (see
<code>PKNCA.options()</code>)</p>
</td></tr>
<tr><td><code id="clean.conc.blq_+3A_conc.blq">conc.blq</code></td>
<td>
<p>How to handle a BLQ value that is between above LOQ values?
See details for description.</p>
</td></tr>
<tr><td><code id="clean.conc.blq_+3A_conc.na">conc.na</code></td>
<td>
<p>How to handle NA concentrations.  (See <code><a href="#topic+clean.conc.na">clean.conc.na()</a></code>)</p>
</td></tr>
<tr><td><code id="clean.conc.blq_+3A_check">check</code></td>
<td>
<p>Run <code><a href="#topic+assert_conc_time">assert_conc_time()</a></code>?</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>NA</code> concentrations (and their associated times) will be handled as
described in <code><a href="#topic+clean.conc.na">clean.conc.na()</a></code> before working with the BLQ values.  The
method for handling NA concentrations can affect the output of which points
are considered BLQ and which are considered &quot;middle&quot;.  Values are
considered BLQ if they are 0.
</p>
<p><code>conc.blq</code> can be set either a scalar indicating what should be done for
all BLQ values or a list with elements named &quot;first&quot;, &quot;middle&quot;, and &quot;last&quot;
each set to a scalar.
</p>
<p>The meaning of each of the list elements is:
</p>

<dl>
<dt>first</dt><dd><p>Values up to the first non-BLQ value.  Note
that if all values are BLQ, this includes all values.</p>
</dd>
<dt>middle</dt><dd><p>Values that are BLQ between the first and last
non-BLQ values.</p>
</dd>
<dt>last</dt><dd><p>Values that are BLQ after the last non-BLQ value</p>
</dd>
</dl>

<p>The valid settings for each are:
</p>

<dl>
<dt>&quot;drop&quot;</dt><dd><p>Drop the BLQ values</p>
</dd>
<dt>&quot;keep&quot;</dt><dd><p>Keep the BLQ values</p>
</dd>
<dt>a number</dt><dd><p>Set the BLQ values to that number</p>
</dd>
</dl>



<h3>Value</h3>

<p>The concentration and time measurements (data frame) filtered and
cleaned as requested relative to BLQ in the middle.
</p>


<h3>See Also</h3>

<p>Other Data cleaners: 
<code><a href="#topic+clean.conc.na">clean.conc.na</a>()</code>
</p>

<hr>
<h2 id='clean.conc.na'>Handle NA values in the concentration measurements as requested by the user.</h2><span id='topic+clean.conc.na'></span>

<h3>Description</h3>

<p>NA concentrations (and their associated times) will be removed then the BLQ
values in the middle
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean.conc.na(conc, time, ..., options = list(), conc.na = NULL, check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clean.conc.na_+3A_conc">conc</code></td>
<td>
<p>Measured concentrations</p>
</td></tr>
<tr><td><code id="clean.conc.na_+3A_time">time</code></td>
<td>
<p>Time of the measurement of the concentrations</p>
</td></tr>
<tr><td><code id="clean.conc.na_+3A_...">...</code></td>
<td>
<p>Additional items to add to the data frame</p>
</td></tr>
<tr><td><code id="clean.conc.na_+3A_options">options</code></td>
<td>
<p>List of changes to the default PKNCA options (see
<code>PKNCA.options()</code>)</p>
</td></tr>
<tr><td><code id="clean.conc.na_+3A_conc.na">conc.na</code></td>
<td>
<p>How to handle NA concentrations?  Either 'drop' or a number to
impute.</p>
</td></tr>
<tr><td><code id="clean.conc.na_+3A_check">check</code></td>
<td>
<p>Run <code><a href="#topic+assert_conc_time">assert_conc_time()</a></code>?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The concentration and time measurements (data frame) filtered
and cleaned as requested relative to NA in the concentration.
</p>


<h3>See Also</h3>

<p>Other Data cleaners: 
<code><a href="#topic+clean.conc.blq">clean.conc.blq</a>()</code>
</p>

<hr>
<h2 id='cov_holder'>Calculate the covariance for two time points with sparse sampling</h2><span id='topic+cov_holder'></span>

<h3>Description</h3>

<p>The calculation follows equation A3 in Holder 2001 (see references below):
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov_holder(sparse_pk)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cov_holder_+3A_sparse_pk">sparse_pk</code></td>
<td>
<p>A sparse_pk object from <code><a href="#topic+as_sparse_pk">as_sparse_pk()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">\hat{\sigma}_{ij} = \sum\limits_{k=1}^{r_{ij}}{\frac{\left(x_{ik} - \bar{x}_i\right)\left(x_{jk} - \bar{x}_j\right)}{\left(r_{ij} - 1\right) + \left(1 - \frac{r_{ij}}{r_i}\right)\left(1 - \frac{r_{ij}}{r_j}\right)}}</code>
</p>

<p>If <code class="reqn">r_{ij} = 0</code>, then <code class="reqn">\hat{\sigma}_{ij}</code> is
defined as zero (rather than dividing by zero).
</p>
<p>Where:
</p>

<dl>
<dt><code class="reqn">\hat{\sigma}_{ij}</code></dt><dd><p>The covariance of times i and j</p>
</dd>
<dt><code class="reqn">r_i</code> and <code class="reqn">r_j</code></dt><dd><p>The number of subjects (usually animals) at times i and j, respectively</p>
</dd>
<dt><code class="reqn">r_{ij}{r_ij}</code></dt><dd><p>The number of subjects (usually animals) at both times i and j</p>
</dd>
<dt><code class="reqn">x_{ik}</code> and <code class="reqn">x_{jk}</code></dt><dd><p>The concentration measured for animal k at times i and j, respectively</p>
</dd>
<dt><code class="reqn">\bar{x}_i</code> and <code class="reqn">\bar{x}_j</code></dt><dd><p>The mean of the concentrations at times i and j, respectively</p>
</dd>
</dl>

<p>The Cauchy-Schwartz inequality is enforced for covariances to keep
correlation coefficients between -1 and 1, inclusive, as described in
equations 8 and 9 of Nedelman and Jia 1998.
</p>


<h3>Value</h3>

<p>A matrix with one row and one column for each element of
<code>sparse_pk_attribute</code>.  The covariances are on the off diagonals, and for
simplicity of use, it also calculates the variance on the diagonal
elements.
</p>


<h3>References</h3>

<p>Holder DJ. Comments on Nedelman and Jias Extension of Satterthwaites
Approximation Applied to Pharmacokinetics. Journal of Biopharmaceutical
Statistics. 2001;11(1-2):75-79. doi:10.1081/BIP-100104199
</p>
<p>Nedelman JR, Jia X. An extension of Satterthwaites approximation applied to
pharmacokinetics. Journal of Biopharmaceutical Statistics. 1998;8(2):317-328.
doi:10.1080/10543409808835241
</p>

<hr>
<h2 id='defunct'>The following functions are defunct</h2><span id='topic+defunct'></span><span id='topic+check.conc.time'></span>

<h3>Description</h3>

<p>The following functions are defunct
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.conc.time(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="defunct_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>check.conc.time()</code>: Defunct as of version 0.11
</p>
</li></ul>

<hr>
<h2 id='exclude'>Exclude data points or results from calculations or summarization.</h2><span id='topic+exclude'></span><span id='topic+exclude.default'></span>

<h3>Description</h3>

<p>Exclude data points or results from calculations or summarization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exclude(object, reason, mask, FUN)

## Default S3 method:
exclude(object, reason, mask, FUN)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="exclude_+3A_object">object</code></td>
<td>
<p>The object to exclude data from.</p>
</td></tr>
<tr><td><code id="exclude_+3A_reason">reason</code></td>
<td>
<p>The reason to add as a reason for exclusion.</p>
</td></tr>
<tr><td><code id="exclude_+3A_mask">mask</code></td>
<td>
<p>A logical vector or numeric index of values to exclude (see
details).</p>
</td></tr>
<tr><td><code id="exclude_+3A_fun">FUN</code></td>
<td>
<p>A function to operate on the data (one group at a time) to select
reasons for exclusions (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only one of <code>mask</code> or <code>FUN</code> may be given.  If <code>FUN</code> is given, it
will be called with two arguments:  a data.frame (or similar object) that
consists of a single group of the data and the full object (e.g. the
PKNCAconc object), <code>FUN(current_group, object)</code>, and it must return a
logical vector equivalent to <code>mask</code> or a character vector with the reason
text given when data should be excluded or <code>NA_character_</code> when the data
should be included (for the current exclusion test).
</p>


<h3>Value</h3>

<p>The object with updated information in the exclude column. The
exclude column will contain the <code>reason</code> if <code>mask</code> or <code>FUN</code> indicate.  If a
previous reason for exclusion was given, then subsequent reasons for
exclusion will be added to the first with a semicolon space (&quot;; &quot;)
separator.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>exclude(default)</code>: The general case for data exclusion
</p>
</li></ul>


<h3>See Also</h3>

<p>Other Result exclusions: 
<code><a href="#topic+exclude_nca">exclude_nca</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>myconc &lt;- PKNCAconc(data.frame(subject=1,
                               time=0:6,
                               conc=c(1, 2, 3, 2, 1, 0.5, 0.25)),
                    conc~time|subject)
exclude(myconc,
        reason="Carryover",
        mask=c(TRUE, rep(FALSE, 6)))
</code></pre>

<hr>
<h2 id='exclude_nca'>Exclude NCA parameters based on examining the parameter set.</h2><span id='topic+exclude_nca'></span><span id='topic+exclude_nca_span.ratio'></span><span id='topic+exclude_nca_max.aucinf.pext'></span><span id='topic+exclude_nca_min.hl.r.squared'></span>

<h3>Description</h3>

<p>Exclude NCA parameters based on examining the parameter set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exclude_nca_span.ratio(min.span.ratio)

exclude_nca_max.aucinf.pext(max.aucinf.pext)

exclude_nca_min.hl.r.squared(min.hl.r.squared)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="exclude_nca_+3A_min.span.ratio">min.span.ratio</code></td>
<td>
<p>The minimum acceptable span ratio (uses
<code>PKNCA.options("min.span.ratio")</code> if not provided).</p>
</td></tr>
<tr><td><code id="exclude_nca_+3A_max.aucinf.pext">max.aucinf.pext</code></td>
<td>
<p>The maximum acceptable percent AUC extrapolation (uses
<code>PKNCA.options("max.aucinf.pext")</code> if not provided).</p>
</td></tr>
<tr><td><code id="exclude_nca_+3A_min.hl.r.squared">min.hl.r.squared</code></td>
<td>
<p>The minimum acceptable r-squared value for half-life
(uses <code>PKNCA.options("min.hl.r.squared")</code> if not provided).</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>exclude_nca_span.ratio()</code>: Exclude based on span.ratio
</p>
</li>
<li> <p><code>exclude_nca_max.aucinf.pext()</code>: Exclude based on AUC percent extrapolated (both
observed and predicted)
</p>
</li>
<li> <p><code>exclude_nca_min.hl.r.squared()</code>: Exclude based on half-life r-squared
</p>
</li></ul>


<h3>See Also</h3>

<p>Other Result exclusions: 
<code><a href="#topic+exclude">exclude</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>my_conc &lt;- PKNCAconc(data.frame(conc=1.1^(3:0),
                                time=0:3,
                                subject=1),
                     conc~time|subject)
my_data &lt;- PKNCAdata(my_conc,
                     intervals=data.frame(start=0, end=Inf,
                                          aucinf.obs=TRUE,
                                          aucpext.obs=TRUE))
my_result &lt;- pk.nca(my_data)
my_result_excluded &lt;- exclude(my_result,
                              FUN=exclude_nca_max.aucinf.pext())
as.data.frame(my_result_excluded)
</code></pre>

<hr>
<h2 id='filter.PKNCAresults'>dplyr filtering for PKNCA</h2><span id='topic+filter.PKNCAresults'></span><span id='topic+filter.PKNCAconc'></span><span id='topic+filter.PKNCAdose'></span>

<h3>Description</h3>

<p>dplyr filtering for PKNCA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PKNCAresults'
filter(.data, ..., .preserve = FALSE)

## S3 method for class 'PKNCAconc'
filter(.data, ..., .preserve = FALSE)

## S3 method for class 'PKNCAdose'
filter(.data, ..., .preserve = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filter.PKNCAresults_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="filter.PKNCAresults_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Expressions that
return a logical value, and are defined in terms of the variables in
<code>.data</code>. If multiple expressions are included, they are combined with the
<code>&amp;</code> operator. Only rows for which all conditions evaluate to <code>TRUE</code> are
kept.</p>
</td></tr>
<tr><td><code id="filter.PKNCAresults_+3A_.preserve">.preserve</code></td>
<td>
<p>Relevant when the <code>.data</code> input is grouped.
If <code>.preserve = FALSE</code> (the default), the grouping structure
is recalculated based on the resulting data, otherwise the grouping is kept as is.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other dplyr verbs: 
<code><a href="#topic+group_by.PKNCAresults">group_by.PKNCAresults</a>()</code>,
<code><a href="#topic+inner_join.PKNCAresults">inner_join.PKNCAresults</a>()</code>,
<code><a href="#topic+mutate.PKNCAresults">mutate.PKNCAresults</a>()</code>
</p>

<hr>
<h2 id='find.tau'>Find the repeating interval within a vector of doses</h2><span id='topic+find.tau'></span>

<h3>Description</h3>

<p>This is intended to find the interval over which x repeats by the rule
<code>unique(mod(x, interval))</code> is minimized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find.tau(x, na.action = stats::na.omit, options = list(), tau.choices = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find.tau_+3A_x">x</code></td>
<td>
<p>the vector to find the interval within</p>
</td></tr>
<tr><td><code id="find.tau_+3A_na.action">na.action</code></td>
<td>
<p>What to do with NAs in <code>x</code></p>
</td></tr>
<tr><td><code id="find.tau_+3A_options">options</code></td>
<td>
<p>List of changes to the default PKNCA options (see
<code>PKNCA.options()</code>)</p>
</td></tr>
<tr><td><code id="find.tau_+3A_tau.choices">tau.choices</code></td>
<td>
<p>the intervals to look for if the doses are not all equally
spaced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar indicating the repeating interval with the most repetition.
</p>

<ol>
<li><p> If all values are <code>NA</code> then NA is returned.
</p>
</li>
<li><p> If all values are the same, then 0 is returned.
</p>
</li>
<li><p> If all values are equally spaced, then that spacing is
returned.
</p>
</li>
<li><p> If one of the <code>choices</code> can minimize the number of
unique values, then that is returned.
</p>
</li>
<li><p> If none of the <code>choices</code> can minimize the number of
unique values, then -1 is returned.
</p>
</li></ol>



<h3>See Also</h3>

<p>Other Interval determination: 
<code><a href="#topic+choose.auc.intervals">choose.auc.intervals</a>()</code>
</p>

<hr>
<h2 id='findOperator'>Find the first occurrence of an operator in a formula and return
the left, right, or both sides of the operator.</h2><span id='topic+findOperator'></span>

<h3>Description</h3>

<p>Find the first occurrence of an operator in a formula and return
the left, right, or both sides of the operator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findOperator(x, op, side)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="findOperator_+3A_x">x</code></td>
<td>
<p>The formula to parse</p>
</td></tr>
<tr><td><code id="findOperator_+3A_op">op</code></td>
<td>
<p>The operator to search for (e.g. <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, ...)</p>
</td></tr>
<tr><td><code id="findOperator_+3A_side">side</code></td>
<td>
<p>Which side of the operator would you like to see: 'left',
'right', or 'both'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The side of the operator requested, NA if requesting the left side
of a unary operator, and NULL if the operator is not found.
</p>


<h3>See Also</h3>

<p>Other Formula parsing: 
<code><a href="#topic+parse_formula_to_cols">parse_formula_to_cols</a>()</code>
</p>

<hr>
<h2 id='fit_half_life'>Perform the half-life fit given the data.  The function simply fits
the data without any validation.  No selection of points or any other
components are done.</h2><span id='topic+fit_half_life'></span>

<h3>Description</h3>

<p>Perform the half-life fit given the data.  The function simply fits
the data without any validation.  No selection of points or any other
components are done.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_half_life(data, tlast, conc_units)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit_half_life_+3A_data">data</code></td>
<td>
<p>The data to fit.  Must have two columns named &quot;log_conc&quot;
and &quot;time&quot;</p>
</td></tr>
<tr><td><code id="fit_half_life_+3A_tlast">tlast</code></td>
<td>
<p>The time of last observed concentration above the limit
of quantification.</p>
</td></tr>
<tr><td><code id="fit_half_life_+3A_conc_units">conc_units</code></td>
<td>
<p>NULL or the units to set for concentration measures</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with one row and columns named &quot;r.squared&quot;,
&quot;adj.r.squared&quot;, &quot;PROB&quot;, &quot;lambda.z&quot;, &quot;clast.pred&quot;,
&quot;lambda.z.n.points&quot;, &quot;half.life&quot;, &quot;span.ratio&quot;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pk.calc.half.life">pk.calc.half.life()</a></code>
</p>

<hr>
<h2 id='formula.PKNCAconc'>Extract the formula from a PKNCAconc object.</h2><span id='topic+formula.PKNCAconc'></span><span id='topic+formula.PKNCAdose'></span>

<h3>Description</h3>

<p>Extract the formula from a PKNCAconc object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PKNCAconc'
formula(x, ...)

## S3 method for class 'PKNCAdose'
formula(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="formula.PKNCAconc_+3A_x">x</code></td>
<td>
<p>The object to extract the formula from.</p>
</td></tr>
<tr><td><code id="formula.PKNCAconc_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A formula object
</p>

<hr>
<h2 id='geomean'>Compute the geometric mean, sd, and CV</h2><span id='topic+geomean'></span><span id='topic+geosd'></span><span id='topic+geocv'></span>

<h3>Description</h3>

<p>Compute the geometric mean, sd, and CV
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geomean(x, na.rm = FALSE)

geosd(x, na.rm = FALSE)

geocv(x, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geomean_+3A_x">x</code></td>
<td>
<p>A vector to compute the geometric mean of</p>
</td></tr>
<tr><td><code id="geomean_+3A_na.rm">na.rm</code></td>
<td>
<p>Should missing values be removed?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The scalar value of the geometric mean, geometric standard deviation,
or geometric coefficient of variation.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>geosd()</code>: Compute the geometric standard deviation, <code>exp(sd(log(x)))</code>.
</p>
</li>
<li> <p><code>geocv()</code>: Compute the geometric coefficient of variation,
<code>sqrt(exp(sd(log(x))^2)-1)*100</code>.
</p>
</li></ul>


<h3>References</h3>

<p>Kirkwood T. B.L. Geometric means and measures of dispersion.
Biometrics 1979; 35: 908-909
</p>


<h3>Examples</h3>

<pre><code class='language-R'>geomean(1:3)
geosd(1:3)
geocv(1:3)
</code></pre>

<hr>
<h2 id='get_impute_method'>Get the impute function from either the intervals column or from the method</h2><span id='topic+get_impute_method'></span>

<h3>Description</h3>

<p>Get the impute function from either the intervals column or from the method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_impute_method(intervals, impute)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_impute_method_+3A_intervals">intervals</code></td>
<td>
<p>the data.frame of intervals</p>
</td></tr>
<tr><td><code id="get_impute_method_+3A_impute">impute</code></td>
<td>
<p>the imputation definition</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The imputation function vector
</p>

<hr>
<h2 id='get.best.model'>Extract the best model from a list of models using the AIC.</h2><span id='topic+get.best.model'></span>

<h3>Description</h3>

<p>Extract the best model from a list of models using the AIC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.best.model(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.best.model_+3A_object">object</code></td>
<td>
<p>the list of models</p>
</td></tr>
<tr><td><code id="get.best.model_+3A_...">...</code></td>
<td>
<p>Parameters passed to AIC.list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The model which is assessed as best.  If more than one are equal,
the first is chosen.
</p>

<hr>
<h2 id='get.first.model'>Get the first model from a list of models</h2><span id='topic+get.first.model'></span>

<h3>Description</h3>

<p>Get the first model from a list of models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.first.model(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.first.model_+3A_object">object</code></td>
<td>
<p>the list of (lists of, ...) models</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The first item in the <code>object</code> that is not a list or <code>NA</code>.  If <code>NA</code>
is passed in or the list (of lists) is all <code>NA</code>, then <code>NA</code> is returned.
</p>

<hr>
<h2 id='get.interval.cols'>Get the columns that can be used in an interval specification</h2><span id='topic+get.interval.cols'></span>

<h3>Description</h3>

<p>Get the columns that can be used in an interval specification
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.interval.cols()
</code></pre>


<h3>Value</h3>

<p>A list with named elements for each parameter.  Each list element
contains the parameter definition.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+check.interval.specification">check.interval.specification()</a></code> and the vignette &quot;Selection of
Calculation Intervals&quot;
</p>
<p>Other Interval specifications: 
<code><a href="#topic+add.interval.col">add.interval.col</a>()</code>,
<code><a href="#topic+check.interval.deps">check.interval.deps</a>()</code>,
<code><a href="#topic+check.interval.specification">check.interval.specification</a>()</code>,
<code><a href="#topic+choose.auc.intervals">choose.auc.intervals</a>()</code>,
<code><a href="#topic+get.parameter.deps">get.parameter.deps</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get.interval.cols()
</code></pre>

<hr>
<h2 id='get.parameter.deps'>Get all columns that depend on a parameter</h2><span id='topic+get.parameter.deps'></span>

<h3>Description</h3>

<p>Get all columns that depend on a parameter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.parameter.deps(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.parameter.deps_+3A_x">x</code></td>
<td>
<p>The parameter name (as a character string)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of parameter names that depend on the parameter
<code>x</code>.  If none depend on <code>x</code>, then the result will be an empty vector.
</p>


<h3>See Also</h3>

<p>Other Interval specifications: 
<code><a href="#topic+add.interval.col">add.interval.col</a>()</code>,
<code><a href="#topic+check.interval.deps">check.interval.deps</a>()</code>,
<code><a href="#topic+check.interval.specification">check.interval.specification</a>()</code>,
<code><a href="#topic+choose.auc.intervals">choose.auc.intervals</a>()</code>,
<code><a href="#topic+get.interval.cols">get.interval.cols</a>()</code>
</p>

<hr>
<h2 id='getAttributeColumn'>Retrieve the value of an attribute column.</h2><span id='topic+getAttributeColumn'></span>

<h3>Description</h3>

<p>Retrieve the value of an attribute column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAttributeColumn(object, attr_name, warn_missing = c("attr", "column"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getAttributeColumn_+3A_object">object</code></td>
<td>
<p>The object to extract the attribute value from.</p>
</td></tr>
<tr><td><code id="getAttributeColumn_+3A_attr_name">attr_name</code></td>
<td>
<p>The name of the attribute to extract</p>
</td></tr>
<tr><td><code id="getAttributeColumn_+3A_warn_missing">warn_missing</code></td>
<td>
<p>Give a warning if the &quot;attr&quot;ibute or &quot;column&quot; is missing.
Character vector with zero, one, or both of &quot;attr&quot; and &quot;column&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the attribute (or <code>NULL</code> if the attribute is not set or
the column does not exist)
</p>

<hr>
<h2 id='getColumnValueOrNot'>Get the value from a column in a data frame if the value is a column
there, otherwise, the value should be a scalar or the length of the
data.</h2><span id='topic+getColumnValueOrNot'></span>

<h3>Description</h3>

<p>Get the value from a column in a data frame if the value is a column
there, otherwise, the value should be a scalar or the length of the
data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getColumnValueOrNot(data, value, prefix = "X")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getColumnValueOrNot_+3A_data">data</code></td>
<td>
<p>A data.frame or similar object</p>
</td></tr>
<tr><td><code id="getColumnValueOrNot_+3A_value">value</code></td>
<td>
<p>A character string giving the name of a column in the <code>data</code>, a
scalar, or a vector the same length as the <code>data</code></p>
</td></tr>
<tr><td><code id="getColumnValueOrNot_+3A_prefix">prefix</code></td>
<td>
<p>The prefix to use if a column must be added (it will be used as
the full column name if it is not already in the dataset or it will be
prepended to the maximum column name if not.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements named &quot;data&quot;, &quot;name&quot; giving the <code>data</code> with a
column named &quot;name&quot; with the value in that column.
</p>

<hr>
<h2 id='getDataName.PKNCAconc'>Get the name of the element containing the data for the current
object.</h2><span id='topic+getDataName.PKNCAconc'></span><span id='topic+getDataName.PKNCAdose'></span><span id='topic+getDataName.PKNCAresults'></span><span id='topic+getDataName'></span><span id='topic+getDataName.default'></span>

<h3>Description</h3>

<p>Get the name of the element containing the data for the current
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PKNCAconc'
getDataName(object)

## S3 method for class 'PKNCAdose'
getDataName(object)

## S3 method for class 'PKNCAresults'
getDataName(object)

getDataName(object)

## Default S3 method:
getDataName(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getDataName.PKNCAconc_+3A_object">object</code></td>
<td>
<p>The object to get the data name from.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character scalar with the name of the data object (or <code>NULL</code> if the
method does not apply).
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>getDataName(default)</code>: If no data name exists, returns NULL.
</p>
</li></ul>


<h3>See Also</h3>

<p>Other PKNCA object extractors: 
<code><a href="#topic+getDepVar">getDepVar</a>()</code>,
<code><a href="#topic+getIndepVar">getIndepVar</a>()</code>
</p>

<hr>
<h2 id='getDepVar'>Get the dependent variable (left hand side of the formula) from a
PKNCA object.</h2><span id='topic+getDepVar'></span>

<h3>Description</h3>

<p>Get the dependent variable (left hand side of the formula) from a
PKNCA object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDepVar(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getDepVar_+3A_x">x</code></td>
<td>
<p>The object to extract the formula from</p>
</td></tr>
<tr><td><code id="getDepVar_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The vector of the dependent variable from the object.
</p>


<h3>See Also</h3>

<p>Other PKNCA object extractors: 
<code><a href="#topic+getDataName.PKNCAconc">getDataName.PKNCAconc</a>()</code>,
<code><a href="#topic+getIndepVar">getIndepVar</a>()</code>
</p>

<hr>
<h2 id='getGroups.PKNCAconc'>Get the groups (right hand side after the <code>|</code> from a PKNCA
object).</h2><span id='topic+getGroups.PKNCAconc'></span><span id='topic+getGroups.PKNCAdose'></span><span id='topic+getGroups.PKNCAresults'></span>

<h3>Description</h3>

<p>Get the groups (right hand side after the <code>|</code> from a PKNCA
object).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PKNCAconc'
getGroups(
  object,
  form = stats::formula(object),
  level,
  data = as.data.frame(object),
  sep
)

## S3 method for class 'PKNCAdose'
getGroups(...)

## S3 method for class 'PKNCAresults'
getGroups(
  object,
  form = formula(object$data$conc),
  level,
  data = object$result,
  sep
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getGroups.PKNCAconc_+3A_object">object</code></td>
<td>
<p>The object to extract the data from</p>
</td></tr>
<tr><td><code id="getGroups.PKNCAconc_+3A_form">form</code></td>
<td>
<p>The formula to extract the data from (defaults to the formula
from <code>object</code>)</p>
</td></tr>
<tr><td><code id="getGroups.PKNCAconc_+3A_level">level</code></td>
<td>
<p>optional.  If included, this specifies the level(s) of the
groups to include.  If a numeric scalar, include the first <code>level</code> number
of groups.  If a numeric vector, include each of the groups specified by
the number.  If a character vector, include the named group levels.</p>
</td></tr>
<tr><td><code id="getGroups.PKNCAconc_+3A_data">data</code></td>
<td>
<p>The data to extract the groups from (defaults to the data from
<code>object</code>)</p>
</td></tr>
<tr><td><code id="getGroups.PKNCAconc_+3A_sep">sep</code></td>
<td>
<p>Unused (kept for compatibility with the nlme package)</p>
</td></tr>
<tr><td><code id="getGroups.PKNCAconc_+3A_...">...</code></td>
<td>
<p>Arguments passed to other getGroups functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the (selected) group columns.
</p>

<hr>
<h2 id='getIndepVar'>Get the independent variable (right hand side of the formula) from
a PKNCA object.</h2><span id='topic+getIndepVar'></span>

<h3>Description</h3>

<p>Get the independent variable (right hand side of the formula) from
a PKNCA object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getIndepVar(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getIndepVar_+3A_x">x</code></td>
<td>
<p>The object to extract the formula from</p>
</td></tr>
<tr><td><code id="getIndepVar_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The vector of the independent variable from the object.
</p>


<h3>See Also</h3>

<p>Other PKNCA object extractors: 
<code><a href="#topic+getDataName.PKNCAconc">getDataName.PKNCAconc</a>()</code>,
<code><a href="#topic+getDepVar">getDepVar</a>()</code>
</p>

<hr>
<h2 id='group_by.PKNCAresults'>dplyr grouping for PKNCA</h2><span id='topic+group_by.PKNCAresults'></span><span id='topic+group_by.PKNCAconc'></span><span id='topic+group_by.PKNCAdose'></span><span id='topic+ungroup.PKNCAresults'></span><span id='topic+ungroup.PKNCAconc'></span><span id='topic+ungroup.PKNCAdose'></span>

<h3>Description</h3>

<p>dplyr grouping for PKNCA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PKNCAresults'
group_by(.data, ..., .add = FALSE, .drop = dplyr::group_by_drop_default(.data))

## S3 method for class 'PKNCAconc'
group_by(.data, ..., .add = FALSE, .drop = dplyr::group_by_drop_default(.data))

## S3 method for class 'PKNCAdose'
group_by(.data, ..., .add = FALSE, .drop = dplyr::group_by_drop_default(.data))

## S3 method for class 'PKNCAresults'
ungroup(x, ...)

## S3 method for class 'PKNCAconc'
ungroup(x, ...)

## S3 method for class 'PKNCAdose'
ungroup(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="group_by.PKNCAresults_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="group_by.PKNCAresults_+3A_...">...</code></td>
<td>
<p>In <code>group_by()</code>, variables or computations to group by.
Computations are always done on the ungrouped data frame.
To perform computations on the grouped data, you need to use
a separate <code>mutate()</code> step before the <code>group_by()</code>.
Computations are not allowed in <code>nest_by()</code>.
In <code>ungroup()</code>, variables to remove from the grouping.</p>
</td></tr>
<tr><td><code id="group_by.PKNCAresults_+3A_.add">.add</code></td>
<td>
<p>When <code>FALSE</code>, the default, <code>group_by()</code> will
override existing groups. To add to the existing groups, use
<code>.add = TRUE</code>.
</p>
<p>This argument was previously called <code>add</code>, but that prevented
creating a new grouping variable called <code>add</code>, and conflicts with
our naming conventions.</p>
</td></tr>
<tr><td><code id="group_by.PKNCAresults_+3A_.drop">.drop</code></td>
<td>
<p>Drop groups formed by factor levels that don't appear in the
data? The default is <code>TRUE</code> except when <code>.data</code> has been previously
grouped with <code>.drop = FALSE</code>. See <code><a href="dplyr.html#topic+group_by_drop_default">group_by_drop_default()</a></code> for details.</p>
</td></tr>
<tr><td><code id="group_by.PKNCAresults_+3A_x">x</code></td>
<td>
<p>A <code><a href="dplyr.html#topic+tbl">tbl()</a></code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other dplyr verbs: 
<code><a href="#topic+filter.PKNCAresults">filter.PKNCAresults</a>()</code>,
<code><a href="#topic+inner_join.PKNCAresults">inner_join.PKNCAresults</a>()</code>,
<code><a href="#topic+mutate.PKNCAresults">mutate.PKNCAresults</a>()</code>
</p>

<hr>
<h2 id='group_vars.PKNCAconc'>Get grouping variables for a PKNCA object</h2><span id='topic+group_vars.PKNCAconc'></span><span id='topic+group_vars.PKNCAdose'></span>

<h3>Description</h3>

<p>Get grouping variables for a PKNCA object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PKNCAconc'
group_vars(x)

## S3 method for class 'PKNCAdose'
group_vars(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="group_vars.PKNCAconc_+3A_x">x</code></td>
<td>
<p>The PKNCA object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector (possibly empty) of the grouping variables
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>group_vars(PKNCAdose)</code>: Get group_vars for a PKNCAdose object
</p>
</li></ul>

<hr>
<h2 id='inner_join.PKNCAresults'>dplyr joins for PKNCA</h2><span id='topic+inner_join.PKNCAresults'></span><span id='topic+left_join.PKNCAresults'></span><span id='topic+right_join.PKNCAresults'></span><span id='topic+full_join.PKNCAresults'></span><span id='topic+inner_join.PKNCAconc'></span><span id='topic+left_join.PKNCAconc'></span><span id='topic+right_join.PKNCAconc'></span><span id='topic+full_join.PKNCAconc'></span><span id='topic+inner_join.PKNCAdose'></span><span id='topic+left_join.PKNCAdose'></span><span id='topic+right_join.PKNCAdose'></span><span id='topic+full_join.PKNCAdose'></span>

<h3>Description</h3>

<p>dplyr joins for PKNCA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PKNCAresults'
inner_join(
  x,
  y,
  by = NULL,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  keep = FALSE
)

## S3 method for class 'PKNCAresults'
left_join(
  x,
  y,
  by = NULL,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  keep = FALSE
)

## S3 method for class 'PKNCAresults'
right_join(
  x,
  y,
  by = NULL,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  keep = FALSE
)

## S3 method for class 'PKNCAresults'
full_join(
  x,
  y,
  by = NULL,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  keep = FALSE
)

## S3 method for class 'PKNCAconc'
inner_join(
  x,
  y,
  by = NULL,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  keep = FALSE
)

## S3 method for class 'PKNCAconc'
left_join(
  x,
  y,
  by = NULL,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  keep = FALSE
)

## S3 method for class 'PKNCAconc'
right_join(
  x,
  y,
  by = NULL,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  keep = FALSE
)

## S3 method for class 'PKNCAconc'
full_join(
  x,
  y,
  by = NULL,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  keep = FALSE
)

## S3 method for class 'PKNCAdose'
inner_join(
  x,
  y,
  by = NULL,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  keep = FALSE
)

## S3 method for class 'PKNCAdose'
left_join(
  x,
  y,
  by = NULL,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  keep = FALSE
)

## S3 method for class 'PKNCAdose'
right_join(
  x,
  y,
  by = NULL,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  keep = FALSE
)

## S3 method for class 'PKNCAdose'
full_join(
  x,
  y,
  by = NULL,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  keep = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inner_join.PKNCAresults_+3A_x">x</code>, <code id="inner_join.PKNCAresults_+3A_y">y</code></td>
<td>
<p>A pair of data frames, data frame extensions (e.g. a tibble), or
lazy data frames (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="inner_join.PKNCAresults_+3A_by">by</code></td>
<td>
<p>A join specification created with <code><a href="dplyr.html#topic+join_by">join_by()</a></code>, or a character
vector of variables to join by.
</p>
<p>If <code>NULL</code>, the default, <code style="white-space: pre;">&#8288;*_join()&#8288;</code> will perform a natural join, using all
variables in common across <code>x</code> and <code>y</code>. A message lists the variables so
that you can check they're correct; suppress the message by supplying <code>by</code>
explicitly.
</p>
<p>To join on different variables between <code>x</code> and <code>y</code>, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code>
specification. For example, <code>join_by(a == b)</code> will match <code>x$a</code> to <code>y$b</code>.
</p>
<p>To join by multiple variables, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code> specification with
multiple expressions. For example, <code>join_by(a == b, c == d)</code> will match
<code>x$a</code> to <code>y$b</code> and <code>x$c</code> to <code>y$d</code>. If the column names are the same between
<code>x</code> and <code>y</code>, you can shorten this by listing only the variable names, like
<code>join_by(a, c)</code>.
</p>
<p><code><a href="dplyr.html#topic+join_by">join_by()</a></code> can also be used to perform inequality, rolling, and overlap
joins. See the documentation at <a href="dplyr.html#topic+join_by">?join_by</a> for details on
these types of joins.
</p>
<p>For simple equality joins, you can alternatively specify a character vector
of variable names to join by. For example, <code>by = c("a", "b")</code> joins <code>x$a</code>
to <code>y$a</code> and <code>x$b</code> to <code>y$b</code>. If variable names differ between <code>x</code> and <code>y</code>,
use a named character vector like <code>by = c("x_a" = "y_a", "x_b" = "y_b")</code>.
</p>
<p>To perform a cross-join, generating all combinations of <code>x</code> and <code>y</code>, see
<code><a href="dplyr.html#topic+cross_join">cross_join()</a></code>.</p>
</td></tr>
<tr><td><code id="inner_join.PKNCAresults_+3A_copy">copy</code></td>
<td>
<p>If <code>x</code> and <code>y</code> are not from the same data source,
and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the
same src as <code>x</code>.  This allows you to join tables across srcs, but
it is a potentially expensive operation so you must opt into it.</p>
</td></tr>
<tr><td><code id="inner_join.PKNCAresults_+3A_suffix">suffix</code></td>
<td>
<p>If there are non-joined duplicate variables in <code>x</code> and
<code>y</code>, these suffixes will be added to the output to disambiguate them.
Should be a character vector of length 2.</p>
</td></tr>
<tr><td><code id="inner_join.PKNCAresults_+3A_...">...</code></td>
<td>
<p>Other parameters passed onto methods.</p>
</td></tr>
<tr><td><code id="inner_join.PKNCAresults_+3A_keep">keep</code></td>
<td>
<p>Should the join keys from both <code>x</code> and <code>y</code> be preserved in the
output?
</p>

<ul>
<li><p> If <code>NULL</code>, the default, joins on equality retain only the keys from <code>x</code>,
while joins on inequality retain the keys from both inputs.
</p>
</li>
<li><p> If <code>TRUE</code>, all keys from both inputs are retained.
</p>
</li>
<li><p> If <code>FALSE</code>, only keys from <code>x</code> are retained. For right and full joins,
the data in key columns corresponding to rows that only exist in <code>y</code> are
merged into the key columns from <code>x</code>. Can't be used when joining on
inequality conditions.
</p>
</li></ul>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other dplyr verbs: 
<code><a href="#topic+filter.PKNCAresults">filter.PKNCAresults</a>()</code>,
<code><a href="#topic+group_by.PKNCAresults">group_by.PKNCAresults</a>()</code>,
<code><a href="#topic+mutate.PKNCAresults">mutate.PKNCAresults</a>()</code>
</p>

<hr>
<h2 id='interp_extrap_conc_method'>Interpolate or extrapolate concentrations using the provided method</h2><span id='topic+interp_extrap_conc_method'></span><span id='topic+interpolate_conc_linear'></span><span id='topic+interpolate_conc_log'></span><span id='topic+extrapolate_conc_lambdaz'></span>

<h3>Description</h3>

<p>Interpolate or extrapolate concentrations using the provided method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interpolate_conc_linear(conc_1, conc_2, time_1, time_2, time_out)

interpolate_conc_log(conc_1, conc_2, time_1, time_2, time_out)

extrapolate_conc_lambdaz(clast, lambda.z, tlast, time_out)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interp_extrap_conc_method_+3A_conc_1">conc_1</code>, <code id="interp_extrap_conc_method_+3A_conc_2">conc_2</code></td>
<td>
<p>The concentration at time1 and time2</p>
</td></tr>
<tr><td><code id="interp_extrap_conc_method_+3A_time_1">time_1</code>, <code id="interp_extrap_conc_method_+3A_time_2">time_2</code></td>
<td>
<p>The time value associated with conc1 and conc2</p>
</td></tr>
<tr><td><code id="interp_extrap_conc_method_+3A_time_out">time_out</code></td>
<td>
<p>Time when interpolation is requested</p>
</td></tr>
<tr><td><code id="interp_extrap_conc_method_+3A_clast">clast</code></td>
<td>
<p>The concentration at the last time above the lower LOQ</p>
</td></tr>
<tr><td><code id="interp_extrap_conc_method_+3A_lambda.z">lambda.z</code></td>
<td>
<p>The elimination rate (in units of inverse time) for
extrapolation</p>
</td></tr>
<tr><td><code id="interp_extrap_conc_method_+3A_tlast">tlast</code></td>
<td>
<p>The time of the last concentration above the lower limit of
quantification (LOQ)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The interpolated or extrapolated value using the correct method
</p>

<hr>
<h2 id='interp.extrap.conc'>Interpolate concentrations between measurements or extrapolate concentrations
after the last measurement.</h2><span id='topic+interp.extrap.conc'></span><span id='topic+interpolate.conc'></span><span id='topic+extrapolate.conc'></span><span id='topic+interp.extrap.conc.dose'></span>

<h3>Description</h3>

<p><code>interpolate.conc()</code> and <code>extrapolate.conc()</code> returns an interpolated (or
extrapolated) concentration. <code>interp.extrap.conc()</code> will choose whether
interpolation or extrapolation is required and will also operate on many
concentrations.  These will typically be used to estimate the concentration
between two measured concentrations or after the last measured concentration.
Of note, these functions will not extrapolate prior to the first point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interp.extrap.conc(
  conc,
  time,
  time.out,
  lambda.z = NA,
  clast = pk.calc.clast.obs(conc, time),
  options = list(),
  method = NULL,
  auc.type = "AUCinf",
  interp.method,
  extrap.method,
  ...,
  conc.blq = NULL,
  conc.na = NULL,
  check = TRUE
)

interpolate.conc(
  conc,
  time,
  time.out,
  options = list(),
  method = NULL,
  interp.method,
  conc.blq = NULL,
  conc.na = NULL,
  conc.origin = 0,
  ...,
  check = TRUE
)

extrapolate.conc(
  conc,
  time,
  time.out,
  lambda.z = NA,
  clast = pk.calc.clast.obs(conc, time),
  auc.type = "AUCinf",
  extrap.method,
  options = list(),
  conc.na = NULL,
  conc.blq = NULL,
  ...,
  check = TRUE
)

interp.extrap.conc.dose(
  conc,
  time,
  time.dose,
  route.dose = "extravascular",
  duration.dose = NA,
  time.out,
  out.after = FALSE,
  options = list(),
  conc.blq = NULL,
  conc.na = NULL,
  ...,
  check = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interp.extrap.conc_+3A_conc">conc</code></td>
<td>
<p>Measured concentrations</p>
</td></tr>
<tr><td><code id="interp.extrap.conc_+3A_time">time</code></td>
<td>
<p>Time of the measurement of the concentrations</p>
</td></tr>
<tr><td><code id="interp.extrap.conc_+3A_time.out">time.out</code></td>
<td>
<p>Time when interpolation is requested (vector for
<code>interp.extrap.conc()</code>, scalar otherwise)</p>
</td></tr>
<tr><td><code id="interp.extrap.conc_+3A_lambda.z">lambda.z</code></td>
<td>
<p>The elimination rate (in units of inverse time) for
extrapolation</p>
</td></tr>
<tr><td><code id="interp.extrap.conc_+3A_clast">clast</code></td>
<td>
<p>The last observed concentration above the limit of
quantification.  If not given, <code>clast</code> is calculated from
<code><a href="#topic+pk.calc.clast.obs">pk.calc.clast.obs()</a></code></p>
</td></tr>
<tr><td><code id="interp.extrap.conc_+3A_options">options</code></td>
<td>
<p>List of changes to the default PKNCA options (see
<code>PKNCA.options()</code>)</p>
</td></tr>
<tr><td><code id="interp.extrap.conc_+3A_method">method</code></td>
<td>
<p>The method for integration (one of 'lin up/log down',
'lin-log', or 'linear')</p>
</td></tr>
<tr><td><code id="interp.extrap.conc_+3A_auc.type">auc.type</code></td>
<td>
<p>The type of AUC to compute.  Choices are 'AUCinf', 'AUClast',
and 'AUCall'.</p>
</td></tr>
<tr><td><code id="interp.extrap.conc_+3A_interp.method">interp.method</code>, <code id="interp.extrap.conc_+3A_extrap.method">extrap.method</code></td>
<td>
<p>deprecated in favor of method and auc.type</p>
</td></tr>
<tr><td><code id="interp.extrap.conc_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>interpolate.conc()</code> or
<code>extrapolate.conc()</code>.</p>
</td></tr>
<tr><td><code id="interp.extrap.conc_+3A_conc.blq">conc.blq</code></td>
<td>
<p>How to handle BLQ values. (See <code><a href="#topic+clean.conc.blq">clean.conc.blq()</a></code> for usage
instructions.)</p>
</td></tr>
<tr><td><code id="interp.extrap.conc_+3A_conc.na">conc.na</code></td>
<td>
<p>How to handle NA concentrations.  (See <code><a href="#topic+clean.conc.na">clean.conc.na()</a></code>)</p>
</td></tr>
<tr><td><code id="interp.extrap.conc_+3A_check">check</code></td>
<td>
<p>Run <code><a href="#topic+assert_conc_time">assert_conc_time()</a></code>, <code><a href="#topic+clean.conc.blq">clean.conc.blq()</a></code>, and
<code><a href="#topic+clean.conc.na">clean.conc.na()</a></code>?</p>
</td></tr>
<tr><td><code id="interp.extrap.conc_+3A_conc.origin">conc.origin</code></td>
<td>
<p>The concentration before the first measurement.
<code>conc.origin</code> is typically used to set predose values to zero (default),
set a predose concentration for endogenous compounds, or set predose
concentrations to <code>NA</code> if otherwise unknown.</p>
</td></tr>
<tr><td><code id="interp.extrap.conc_+3A_time.dose">time.dose</code></td>
<td>
<p>Time of the dose</p>
</td></tr>
<tr><td><code id="interp.extrap.conc_+3A_route.dose">route.dose</code></td>
<td>
<p>What is the route of administration (&quot;intravascular&quot; or
&quot;extravascular&quot;).  See the details for how this parameter is used.</p>
</td></tr>
<tr><td><code id="interp.extrap.conc_+3A_duration.dose">duration.dose</code></td>
<td>
<p>What is the duration of administration? See the details
for how this parameter is used.</p>
</td></tr>
<tr><td><code id="interp.extrap.conc_+3A_out.after">out.after</code></td>
<td>
<p>Should interpolation occur from the data before (<code>FALSE</code>) or
after (<code>TRUE</code>) the interpolated point?  See the details for how this
parameter is used.  It only has a meaningful effect at the instant of an IV
bolus dose.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An <code>NA</code> value for the <code>lambda.z</code> parameter will prevent extrapolation.
</p>

<dl>
<dt>extrap.method</dt><dd>

<dl>
<dt>'AUCinf'</dt><dd><p>Use lambda.z to extrapolate beyond the last point with the half-life.</p>
</dd>
<dt>'AUCall'</dt><dd><p>If the last point is above the limit of quantification or missing, this is identical to 'AUCinf'. If the last point is below the limit of quantification, then linear interpolation between the Clast and the next BLQ is used for that  interval and all additional points are extrapolated as 0.</p>
</dd>
<dt>'AUClast'</dt><dd><p>Extrapolates all points after the last above the  limit of quantification as 0.</p>
</dd>
</dl>

</dd>
</dl>

<p><code>duration.dose</code> and <code>direction.out</code> are ignored if <code>route.dose == "extravascular"</code>.  <code>direction.out</code> is ignored if <code>duration.dose &gt; 0</code>.
</p>
<p><code>route.dose</code> and <code>duration.dose</code> affect how interpolation/extrapolation of
the concentration occurs at the time of dosing.  If <code>route.dose == "intravascular"</code> and <code>duration.dose == 0</code> then extrapolation occurs for an IV
bolus using <code><a href="#topic+pk.calc.c0">pk.calc.c0()</a></code> with the data after dosing.  Otherwise (either
<code>route.dose == "extravascular"</code> or <code>duration.dose &gt; 0</code>), extrapolation occurs
using the concentrations before dosing and estimating the half-life (or more
precisely, estimating <code>lambda.z</code>).  Finally, <code>direction.out</code> can change the
direction of interpolation in cases with <code>route.dose == "intravascular"</code> and
<code>duration.dose == 0</code>.  When <code>direction.out == "before"</code> interpolation occurs
only with data before the dose (as is the case for <code>route.dose == "extravascular"</code>), but if <code>direction.out == "after"</code> interpolation occurs
from the data after dosing.
</p>


<h3>Value</h3>

<p>The interpolated or extrapolated concentration value as a scalar
double (or vector for <code>interp.extrap.conc()</code>).
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>interpolate.conc()</code>: Interpolate concentrations through Tlast (inclusive)
</p>
</li>
<li> <p><code>extrapolate.conc()</code>: Extrapolate concentrations after Tlast
</p>
</li>
<li> <p><code>interp.extrap.conc.dose()</code>: Interpolate and extrapolate concentrations
without interpolating or extrapolating beyond doses.
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+pk.calc.clast.obs">pk.calc.clast.obs()</a></code>, <code><a href="#topic+pk.calc.half.life">pk.calc.half.life()</a></code>, <code><a href="#topic+pk.calc.c0">pk.calc.c0()</a></code>
</p>

<hr>
<h2 id='is_sparse_pk.PKNCAconc'>Is a PKNCA object used for sparse PK?</h2><span id='topic+is_sparse_pk.PKNCAconc'></span><span id='topic+is_sparse_pk.PKNCAdata'></span><span id='topic+is_sparse_pk.PKNCAresults'></span><span id='topic+is_sparse_pk'></span>

<h3>Description</h3>

<p>Is a PKNCA object used for sparse PK?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PKNCAconc'
is_sparse_pk(object)

## S3 method for class 'PKNCAdata'
is_sparse_pk(object)

## S3 method for class 'PKNCAresults'
is_sparse_pk(object)

is_sparse_pk(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_sparse_pk.PKNCAconc_+3A_object">object</code></td>
<td>
<p>The object to see if it includes sparse PK</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if sparse and <code>FALSE</code> if dense (not sparse)
</p>

<hr>
<h2 id='model.frame.PKNCAconc'>Extract the columns used in the formula (in order) from a PKNCAconc
or PKNCAdose object.</h2><span id='topic+model.frame.PKNCAconc'></span><span id='topic+model.frame.PKNCAdose'></span>

<h3>Description</h3>

<p>Extract the columns used in the formula (in order) from a PKNCAconc
or PKNCAdose object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PKNCAconc'
model.frame(formula, ...)

## S3 method for class 'PKNCAdose'
model.frame(formula, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="model.frame.PKNCAconc_+3A_formula">formula</code></td>
<td>
<p>The object to use (parameter name is <code>formula</code> to use the
generic function)</p>
</td></tr>
<tr><td><code id="model.frame.PKNCAconc_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the columns from the object in formula order.
</p>

<hr>
<h2 id='mutate.PKNCAresults'>dplyr mutate-based modification for PKNCA</h2><span id='topic+mutate.PKNCAresults'></span><span id='topic+mutate.PKNCAconc'></span><span id='topic+mutate.PKNCAdose'></span>

<h3>Description</h3>

<p>dplyr mutate-based modification for PKNCA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PKNCAresults'
mutate(.data, ...)

## S3 method for class 'PKNCAconc'
mutate(.data, ...)

## S3 method for class 'PKNCAdose'
mutate(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mutate.PKNCAresults_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="mutate.PKNCAresults_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Name-value pairs.
The name gives the name of the column in the output.
</p>
<p>The value can be:
</p>

<ul>
<li><p> A vector of length 1, which will be recycled to the correct length.
</p>
</li>
<li><p> A vector the same length as the current group (or the whole data frame
if ungrouped).
</p>
</li>
<li> <p><code>NULL</code>, to remove the column.
</p>
</li>
<li><p> A data frame or tibble, to create multiple columns in the output.
</p>
</li></ul>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other dplyr verbs: 
<code><a href="#topic+filter.PKNCAresults">filter.PKNCAresults</a>()</code>,
<code><a href="#topic+group_by.PKNCAresults">group_by.PKNCAresults</a>()</code>,
<code><a href="#topic+inner_join.PKNCAresults">inner_join.PKNCAresults</a>()</code>
</p>

<hr>
<h2 id='normalize_exclude'>Normalize the exclude column by setting blanks to NA</h2><span id='topic+normalize_exclude'></span>

<h3>Description</h3>

<p>Normalize the exclude column by setting blanks to NA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize_exclude(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normalize_exclude_+3A_object">object</code></td>
<td>
<p>The object to extract the exclude column from</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The exclude vector where <code>NA</code> indicates not to exclude and anything
else indicates to exclude.
</p>

<hr>
<h2 id='parse_formula_to_cols'>Convert a formula representation to the columns for input data</h2><span id='topic+parse_formula_to_cols'></span>

<h3>Description</h3>

<p>Convert a formula representation to the columns for input data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_formula_to_cols(form)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parse_formula_to_cols_+3A_form">form</code></td>
<td>
<p>the formula (or something coercible into a formula) to extract
into its parts</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of column names for various formula parts
</p>


<h3>See Also</h3>

<p>Other Formula parsing: 
<code><a href="#topic+findOperator">findOperator</a>()</code>
</p>

<hr>
<h2 id='pk_nca_result_to_df'>Convert the grouping info and list of results for each group into a results
data.frame</h2><span id='topic+pk_nca_result_to_df'></span>

<h3>Description</h3>

<p>Convert the grouping info and list of results for each group into a results
data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pk_nca_result_to_df(group_info, result)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pk_nca_result_to_df_+3A_group_info">group_info</code></td>
<td>
<p>A data.frame of grouping columns</p>
</td></tr>
<tr><td><code id="pk_nca_result_to_df_+3A_result">result</code></td>
<td>
<p>A list of data.frames with the results from NCA parameter
calculations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with group_info and result combined, warnings filtered
out, and results unnested.
</p>

<hr>
<h2 id='pk.business'>Run any function with a maximum missing fraction of X and 0s possibly
counting as missing.  The maximum fraction missing comes from
<code>PKNCA.options("max.missing")</code>.</h2><span id='topic+pk.business'></span>

<h3>Description</h3>

<p>Note that all missing values are removed prior to calling the function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pk.business(FUN, zero.missing = FALSE, max.missing)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pk.business_+3A_fun">FUN</code></td>
<td>
<p>function to run.  The function is called as <code>FUN(x, ...)</code> with
missing values removed.</p>
</td></tr>
<tr><td><code id="pk.business_+3A_zero.missing">zero.missing</code></td>
<td>
<p>Are zeros counted as missing?  If <code>TRUE</code> then include
them in the missing count.</p>
</td></tr>
<tr><td><code id="pk.business_+3A_max.missing">max.missing</code></td>
<td>
<p>The maximum fraction of the data allowed to be missing (a
number between 0 and 1, inclusive).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A version of FUN that can be called with parameters that are checked
for missingness (and zeros) with missing (and zeros) removed before the
call.  If <code>max.missing</code> is exceeded, then NA is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>my_mean &lt;- pk.business(FUN=mean)
mean(c(1:3, NA))
# Less than half missing results in the summary statistic of the available
# values.
my_mean(c(1:3, NA))
# More than half missing results in a missing value
my_mean(c(1:3, rep(NA, 4)))
</code></pre>

<hr>
<h2 id='pk.calc.ae'>Calculate amount excreted (typically in urine or feces)</h2><span id='topic+pk.calc.ae'></span>

<h3>Description</h3>

<p>Calculate amount excreted (typically in urine or feces)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pk.calc.ae(conc, volume, check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pk.calc.ae_+3A_conc">conc</code></td>
<td>
<p>Measured concentrations</p>
</td></tr>
<tr><td><code id="pk.calc.ae_+3A_volume">volume</code></td>
<td>
<p>The volume (or mass) of the sample</p>
</td></tr>
<tr><td><code id="pk.calc.ae_+3A_check">check</code></td>
<td>
<p>Should the concentration and volume data be checked?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>ae is <code>sum(conc*volume)</code>.
</p>
<p>The units for the concentration and volume should match such that
<code>sum(conc*volume)</code> has units of mass or moles.
</p>


<h3>Value</h3>

<p>The amount excreted during the interval
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pk.calc.clr">pk.calc.clr()</a></code>, <code><a href="#topic+pk.calc.fe">pk.calc.fe()</a></code>
</p>

<hr>
<h2 id='pk.calc.aucabove'>Calculate the AUC above a given concentration</h2><span id='topic+pk.calc.aucabove'></span>

<h3>Description</h3>

<p>Concentrations below the given concentration (<code>conc_above</code>) will be set
to zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pk.calc.aucabove(conc, time, conc_above = NA_real_, ..., options = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pk.calc.aucabove_+3A_conc">conc</code></td>
<td>
<p>Measured concentrations</p>
</td></tr>
<tr><td><code id="pk.calc.aucabove_+3A_time">time</code></td>
<td>
<p>Time of the measurement of the concentrations</p>
</td></tr>
<tr><td><code id="pk.calc.aucabove_+3A_conc_above">conc_above</code></td>
<td>
<p>The concentration to be above</p>
</td></tr>
<tr><td><code id="pk.calc.aucabove_+3A_...">...</code></td>
<td>
<p>Extra arguments.  Currently, the only extra argument that is used
is <code>method</code> as described in the details section.</p>
</td></tr>
<tr><td><code id="pk.calc.aucabove_+3A_options">options</code></td>
<td>
<p>List of changes to the default PKNCA options (see
<code>PKNCA.options()</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The AUC of the concentration above the limit
</p>

<hr>
<h2 id='pk.calc.aucint'>Calculate the AUC over an interval with interpolation and/or
extrapolation of concentrations for the beginning and end of the
interval.</h2><span id='topic+pk.calc.aucint'></span><span id='topic+pk.calc.aucint.last'></span><span id='topic+pk.calc.aucint.all'></span><span id='topic+pk.calc.aucint.inf.obs'></span><span id='topic+pk.calc.aucint.inf.pred'></span>

<h3>Description</h3>

<p>Calculate the AUC over an interval with interpolation and/or
extrapolation of concentrations for the beginning and end of the
interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pk.calc.aucint(
  conc,
  time,
  interval = NULL,
  start = NULL,
  end = NULL,
  clast = pk.calc.clast.obs(conc, time),
  lambda.z = NA,
  time.dose = NULL,
  route = "extravascular",
  duration.dose = 0,
  method = NULL,
  auc.type = "AUClast",
  conc.blq = NULL,
  conc.na = NULL,
  check = TRUE,
  ...,
  options = list()
)

pk.calc.aucint.last(
  conc,
  time,
  start = NULL,
  end = NULL,
  time.dose,
  ...,
  options = list()
)

pk.calc.aucint.all(
  conc,
  time,
  start = NULL,
  end = NULL,
  time.dose,
  ...,
  options = list()
)

pk.calc.aucint.inf.obs(
  conc,
  time,
  start = NULL,
  end = NULL,
  time.dose,
  lambda.z,
  clast.obs,
  ...,
  options = list()
)

pk.calc.aucint.inf.pred(
  conc,
  time,
  start = NULL,
  end = NULL,
  time.dose,
  lambda.z,
  clast.pred,
  ...,
  options = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pk.calc.aucint_+3A_conc">conc</code></td>
<td>
<p>Measured concentrations</p>
</td></tr>
<tr><td><code id="pk.calc.aucint_+3A_time">time</code></td>
<td>
<p>Time of the measurement of the concentrations</p>
</td></tr>
<tr><td><code id="pk.calc.aucint_+3A_interval">interval</code></td>
<td>
<p>Numeric vector of two numbers for the start and end time of
integration</p>
</td></tr>
<tr><td><code id="pk.calc.aucint_+3A_start">start</code></td>
<td>
<p>The start time of the interval</p>
</td></tr>
<tr><td><code id="pk.calc.aucint_+3A_end">end</code></td>
<td>
<p>The end time of the interval</p>
</td></tr>
<tr><td><code id="pk.calc.aucint_+3A_clast">clast</code>, <code id="pk.calc.aucint_+3A_clast.obs">clast.obs</code>, <code id="pk.calc.aucint_+3A_clast.pred">clast.pred</code></td>
<td>
<p>The last concentration above the limit of
quantification; this is used for AUCinf calculations.  If provided as
clast.obs (observed clast value, default), AUCinf is AUCinf,obs. If
provided as clast.pred, AUCinf is AUCinf,pred.</p>
</td></tr>
<tr><td><code id="pk.calc.aucint_+3A_lambda.z">lambda.z</code></td>
<td>
<p>The elimination rate (in units of inverse time) for
extrapolation</p>
</td></tr>
<tr><td><code id="pk.calc.aucint_+3A_time.dose">time.dose</code>, <code id="pk.calc.aucint_+3A_route">route</code>, <code id="pk.calc.aucint_+3A_duration.dose">duration.dose</code></td>
<td>
<p>The time of doses, route of
administration, and duration of dose used with interpolation and
extrapolation of concentration data (see <code><a href="#topic+interp.extrap.conc.dose">interp.extrap.conc.dose()</a></code>).  If
<code>NULL</code>, <code><a href="#topic+interp.extrap.conc">interp.extrap.conc()</a></code> will be used instead (assuming that no doses
affecting concentrations are in the interval).</p>
</td></tr>
<tr><td><code id="pk.calc.aucint_+3A_method">method</code></td>
<td>
<p>The method for integration (one of 'lin up/log down',
'lin-log', or 'linear')</p>
</td></tr>
<tr><td><code id="pk.calc.aucint_+3A_auc.type">auc.type</code></td>
<td>
<p>The type of AUC to compute.  Choices are 'AUCinf', 'AUClast',
and 'AUCall'.</p>
</td></tr>
<tr><td><code id="pk.calc.aucint_+3A_conc.blq">conc.blq</code></td>
<td>
<p>How to handle BLQ values in between the first and last above
LOQ concentrations. (See <code><a href="#topic+clean.conc.blq">clean.conc.blq()</a></code> for usage instructions.)</p>
</td></tr>
<tr><td><code id="pk.calc.aucint_+3A_conc.na">conc.na</code></td>
<td>
<p>How to handle missing concentration values.  (See
<code><a href="#topic+clean.conc.na">clean.conc.na()</a></code> for usage instructions.)</p>
</td></tr>
<tr><td><code id="pk.calc.aucint_+3A_check">check</code></td>
<td>
<p>Run <code><a href="#topic+assert_conc_time">assert_conc_time()</a></code>, <code><a href="#topic+clean.conc.blq">clean.conc.blq()</a></code>, and
<code><a href="#topic+clean.conc.na">clean.conc.na()</a></code>?</p>
</td></tr>
<tr><td><code id="pk.calc.aucint_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>pk.calc.auxc</code> and
<code>interp.extrap.conc</code></p>
</td></tr>
<tr><td><code id="pk.calc.aucint_+3A_options">options</code></td>
<td>
<p>List of changes to the default PKNCA options (see
<code>PKNCA.options()</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>pk.calc.aucint()</code> needs to extrapolate using <code>lambda.z</code> (in other
words, using the half-life), it will always extrapolate using the logarithmic
trapezoidal rule to align with using a half-life calculation for the
extrapolation.
</p>


<h3>Value</h3>

<p>The AUC for an interval of time as a number
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>pk.calc.aucint.last()</code>: Interpolate or extrapolate concentrations for
AUClast
</p>
</li>
<li> <p><code>pk.calc.aucint.all()</code>: Interpolate or extrapolate concentrations for
AUCall
</p>
</li>
<li> <p><code>pk.calc.aucint.inf.obs()</code>: Interpolate or extrapolate concentrations for
AUCinf.obs
</p>
</li>
<li> <p><code>pk.calc.aucint.inf.pred()</code>: Interpolate or extrapolate concentrations for
AUCinf.pred
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+PKNCA.options">PKNCA.options()</a></code>, <code><a href="#topic+interp.extrap.conc.dose">interp.extrap.conc.dose()</a></code>
</p>
<p>Other AUC calculations: 
<code><a href="#topic+pk.calc.auxc">pk.calc.auxc</a>()</code>
</p>

<hr>
<h2 id='pk.calc.auciv'>Calculate AUC for intravenous dosing</h2><span id='topic+pk.calc.auciv'></span><span id='topic+pk.calc.auciv_pbext'></span>

<h3>Description</h3>

<p>Calculate AUC for intravenous dosing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pk.calc.auciv(conc, time, c0, auc, ..., check = TRUE)

pk.calc.auciv_pbext(auc, auciv)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pk.calc.auciv_+3A_conc">conc</code></td>
<td>
<p>Measured concentrations</p>
</td></tr>
<tr><td><code id="pk.calc.auciv_+3A_time">time</code></td>
<td>
<p>Time of the measurement of the concentrations</p>
</td></tr>
<tr><td><code id="pk.calc.auciv_+3A_c0">c0</code></td>
<td>
<p>The concentration at time 0, typically calculated using
<code>pk.calc.c0()</code></p>
</td></tr>
<tr><td><code id="pk.calc.auciv_+3A_auc">auc</code></td>
<td>
<p>The AUC calculated using <code>conc</code> and <code>time</code> without <code>c0</code> (it may be
calculated using any method)</p>
</td></tr>
<tr><td><code id="pk.calc.auciv_+3A_...">...</code></td>
<td>
<p>For functions other than <code>pk.calc.auxc</code>, these values are passed
to <code>pk.calc.auxc</code></p>
</td></tr>
<tr><td><code id="pk.calc.auciv_+3A_check">check</code></td>
<td>
<p>Run <code><a href="#topic+assert_conc_time">assert_conc_time()</a></code>, <code><a href="#topic+clean.conc.blq">clean.conc.blq()</a></code>, and
<code><a href="#topic+clean.conc.na">clean.conc.na()</a></code>?</p>
</td></tr>
<tr><td><code id="pk.calc.auciv_+3A_auciv">auciv</code></td>
<td>
<p>The AUC calculated using <code>c0</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The AUC for intravenous (IV) dosing extrapolates the AUC back from
the first measurement to time 0 using c0 and the AUC calculated by another
method (for example the auclast).
</p>
<p>The calculation method takes the following steps:
</p>

<ul>
<li><p><code>time = 0</code> must be present in the data with a measured concentration.
</p>
</li>
<li><p>The AUC between <code>time = 0</code> and the next time point is calculated (<code>auc_first</code>).
</p>
</li>
<li><p>The AUC between <code>time = 0</code> with <code>c0</code> and the next time point is calculated (<code>auc_second</code>).
</p>
</li>
<li><p>The final AUC is the initial AUC plus the difference between the two AUCs (<code>auc_final &lt;- auc + auc_second - auc_first</code>).
</p>
</li></ul>

<p>The calculation for back-extrapolation is <code>100*(1 - auc/auciv)</code>.
</p>


<h3>Value</h3>

<p><code>pk.calc.auciv</code>: The AUC calculated using <code>c0</code>
</p>
<p><code>pk.calc.auciv_pctbackextrap</code>: The AUC percent back-extrapolated
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>pk.calc.auciv_pbext()</code>: Calculate the percent back-extrapolated AUC for IV
administration
</p>
</li></ul>

<hr>
<h2 id='pk.calc.aucpext'>Calculate the AUC percent extrapolated</h2><span id='topic+pk.calc.aucpext'></span>

<h3>Description</h3>

<p>Calculate the AUC percent extrapolated
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pk.calc.aucpext(auclast, aucinf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pk.calc.aucpext_+3A_auclast">auclast</code></td>
<td>
<p>the area under the curve from time 0 to the last measurement
above the limit of quantification</p>
</td></tr>
<tr><td><code id="pk.calc.aucpext_+3A_aucinf">aucinf</code></td>
<td>
<p>the area under the curve from time 0 to infinity</p>
</td></tr>
</table>


<h3>Details</h3>

<p>aucpext is <code>100*(1-auclast/aucinf)</code>.
</p>


<h3>Value</h3>

<p>The numeric value of the AUC percent extrapolated or <code>NA_real_</code> if
any of the following are true <code>is.na(aucinf)</code>, <code>is.na(auclast)</code>,
<code>aucinf &lt;= 0</code>, or <code>auclast &lt;= 0</code>.
</p>

<hr>
<h2 id='pk.calc.auxc'>A compute the Area Under the (Moment) Curve</h2><span id='topic+pk.calc.auxc'></span><span id='topic+pk.calc.auc'></span><span id='topic+pk.calc.aumc'></span><span id='topic+pk.calc.auc.last'></span><span id='topic+pk.calc.auc.inf'></span><span id='topic+pk.calc.auc.inf.obs'></span><span id='topic+pk.calc.auc.inf.pred'></span><span id='topic+pk.calc.auc.all'></span><span id='topic+pk.calc.aumc.last'></span><span id='topic+pk.calc.aumc.inf'></span><span id='topic+pk.calc.aumc.inf.obs'></span><span id='topic+pk.calc.aumc.inf.pred'></span><span id='topic+pk.calc.aumc.all'></span>

<h3>Description</h3>

<p>Compute the area under the curve (AUC) and the area under the moment curve
(AUMC) for pharmacokinetic (PK) data.  AUC and AUMC are used for many
purposes when analyzing PK in drug development.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pk.calc.auxc(
  conc,
  time,
  interval = c(0, Inf),
  clast = pk.calc.clast.obs(conc, time, check = FALSE),
  lambda.z = NA,
  auc.type = c("AUClast", "AUCinf", "AUCall"),
  options = list(),
  method = NULL,
  conc.blq = NULL,
  conc.na = NULL,
  check = TRUE,
  fun_linear,
  fun_log,
  fun_inf
)

pk.calc.auc(conc, time, ..., options = list())

pk.calc.auc.last(conc, time, ..., options = list())

pk.calc.auc.inf(conc, time, ..., options = list(), lambda.z)

pk.calc.auc.inf.obs(conc, time, clast.obs, ..., options = list(), lambda.z)

pk.calc.auc.inf.pred(conc, time, clast.pred, ..., options = list(), lambda.z)

pk.calc.auc.all(conc, time, ..., options = list())

pk.calc.aumc(conc, time, ..., options = list())

pk.calc.aumc.last(conc, time, ..., options = list())

pk.calc.aumc.inf(conc, time, ..., options = list(), lambda.z)

pk.calc.aumc.inf.obs(conc, time, clast.obs, ..., options = list(), lambda.z)

pk.calc.aumc.inf.pred(conc, time, clast.pred, ..., options = list(), lambda.z)

pk.calc.aumc.all(conc, time, ..., options = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pk.calc.auxc_+3A_conc">conc</code></td>
<td>
<p>Measured concentrations</p>
</td></tr>
<tr><td><code id="pk.calc.auxc_+3A_time">time</code></td>
<td>
<p>Time of the measurement of the concentrations</p>
</td></tr>
<tr><td><code id="pk.calc.auxc_+3A_interval">interval</code></td>
<td>
<p>Numeric vector of two numbers for the start and end time of
integration</p>
</td></tr>
<tr><td><code id="pk.calc.auxc_+3A_clast">clast</code>, <code id="pk.calc.auxc_+3A_clast.obs">clast.obs</code>, <code id="pk.calc.auxc_+3A_clast.pred">clast.pred</code></td>
<td>
<p>The last concentration above the limit of
quantification; this is used for AUCinf calculations.  If provided as
clast.obs (observed clast value, default), AUCinf is AUCinf,obs. If
provided as clast.pred, AUCinf is AUCinf,pred.</p>
</td></tr>
<tr><td><code id="pk.calc.auxc_+3A_lambda.z">lambda.z</code></td>
<td>
<p>The elimination rate (in units of inverse time) for
extrapolation</p>
</td></tr>
<tr><td><code id="pk.calc.auxc_+3A_auc.type">auc.type</code></td>
<td>
<p>The type of AUC to compute.  Choices are 'AUCinf', 'AUClast',
and 'AUCall'.</p>
</td></tr>
<tr><td><code id="pk.calc.auxc_+3A_options">options</code></td>
<td>
<p>List of changes to the default PKNCA options (see
<code>PKNCA.options()</code>)</p>
</td></tr>
<tr><td><code id="pk.calc.auxc_+3A_method">method</code></td>
<td>
<p>The method for integration (one of 'lin up/log down',
'lin-log', or 'linear')</p>
</td></tr>
<tr><td><code id="pk.calc.auxc_+3A_conc.blq">conc.blq</code></td>
<td>
<p>How to handle BLQ values in between the first and last above
LOQ concentrations. (See <code><a href="#topic+clean.conc.blq">clean.conc.blq()</a></code> for usage instructions.)</p>
</td></tr>
<tr><td><code id="pk.calc.auxc_+3A_conc.na">conc.na</code></td>
<td>
<p>How to handle missing concentration values.  (See
<code><a href="#topic+clean.conc.na">clean.conc.na()</a></code> for usage instructions.)</p>
</td></tr>
<tr><td><code id="pk.calc.auxc_+3A_check">check</code></td>
<td>
<p>Run <code><a href="#topic+assert_conc_time">assert_conc_time()</a></code>, <code><a href="#topic+clean.conc.blq">clean.conc.blq()</a></code>, and
<code><a href="#topic+clean.conc.na">clean.conc.na()</a></code>?</p>
</td></tr>
<tr><td><code id="pk.calc.auxc_+3A_fun_linear">fun_linear</code></td>
<td>
<p>The function to use for integration of the linear part of
the curve (not required for AUC or AUMC functions)</p>
</td></tr>
<tr><td><code id="pk.calc.auxc_+3A_fun_log">fun_log</code></td>
<td>
<p>The function to use for integration of the logarithmic part of
the curve (if log integration is used; not required for AUC or AUMC
functions)</p>
</td></tr>
<tr><td><code id="pk.calc.auxc_+3A_fun_inf">fun_inf</code></td>
<td>
<p>The function to use for extrapolation from the final
measurement to infinite time (not required for AUC or AUMC functions.</p>
</td></tr>
<tr><td><code id="pk.calc.auxc_+3A_...">...</code></td>
<td>
<p>For functions other than <code>pk.calc.auxc</code>, these values are passed
to <code>pk.calc.auxc</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pk.calc.auc.last</code> is simply a shortcut setting the <code>interval</code>
parameter to <code>c(0, "last")</code>.
</p>
<p>Extrapolation beyond Clast occurs using the half-life and Clast,obs;
Clast,pred is not yet supported.
</p>
<p>If all conc input are zero, then the AU(M)C is zero.
</p>


<h3>Value</h3>

<p>A numeric value for the AU(M)C.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>pk.calc.auc()</code>: Compute the area under the curve
</p>
</li>
<li> <p><code>pk.calc.auc.last()</code>: Compute the AUClast.
</p>
</li>
<li> <p><code>pk.calc.auc.inf()</code>: Compute the AUCinf
</p>
</li>
<li> <p><code>pk.calc.auc.inf.obs()</code>: Compute the AUCinf with the observed Clast.
</p>
</li>
<li> <p><code>pk.calc.auc.inf.pred()</code>: Compute the AUCinf with the predicted Clast.
</p>
</li>
<li> <p><code>pk.calc.auc.all()</code>: Compute the AUCall.
</p>
</li>
<li> <p><code>pk.calc.aumc()</code>: Compute the area under the moment curve
</p>
</li>
<li> <p><code>pk.calc.aumc.last()</code>: Compute the AUMClast.
</p>
</li>
<li> <p><code>pk.calc.aumc.inf()</code>: Compute the AUMCinf
</p>
</li>
<li> <p><code>pk.calc.aumc.inf.obs()</code>: Compute the AUMCinf with the observed Clast.
</p>
</li>
<li> <p><code>pk.calc.aumc.inf.pred()</code>: Compute the AUMCinf with the predicted Clast.
</p>
</li>
<li> <p><code>pk.calc.aumc.all()</code>: Compute the AUMCall.
</p>
</li></ul>


<h3>References</h3>

<p>Gabrielsson J, Weiner D.  &quot;Section 2.8.1 Computation methods - Linear
trapezoidal rule.&quot;  Pharmacokinetic &amp; Pharmacodynamic Data Analysis: Concepts
and Applications, 4th Edition.  Stockholm, Sweden: Swedish Pharmaceutical
Press, 2000.  162-4.
</p>
<p>Gabrielsson J, Weiner D.  &quot;Section 2.8.3 Computation methods - Log-linear
trapezoidal rule.&quot;  Pharmacokinetic &amp; Pharmacodynamic Data Analysis: Concepts
and Applications, 4th Edition.  Stockholm, Sweden: Swedish Pharmaceutical
Press, 2000.  164-7.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clean.conc.blq">clean.conc.blq()</a></code>
</p>
<p>Other AUC calculations: 
<code><a href="#topic+pk.calc.aucint">pk.calc.aucint</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>myconc &lt;- c(0, 1, 2, 1, 0.5, 0.25, 0)
mytime &lt;- c(0, 1, 2, 3, 4,   5,    6)
pk.calc.auc(myconc, mytime, interval=c(0, 6))
pk.calc.auc(myconc, mytime, interval=c(0, Inf))
</code></pre>

<hr>
<h2 id='pk.calc.c0'>Estimate the concentration at dosing time for an IV bolus dose.</h2><span id='topic+pk.calc.c0'></span><span id='topic+pk.calc.c0.method.logslope'></span><span id='topic+pk.calc.c0.method.c0'></span><span id='topic+pk.calc.c0.method.c1'></span><span id='topic+pk.calc.c0.method.set0'></span><span id='topic+pk.calc.c0.method.cmin'></span>

<h3>Description</h3>

<p>Estimate the concentration at dosing time for an IV bolus dose.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pk.calc.c0(
  conc,
  time,
  time.dose = 0,
  method = c("c0", "logslope", "c1", "cmin", "set0"),
  check = TRUE
)

pk.calc.c0.method.logslope(conc, time, time.dose = 0, check = TRUE)

pk.calc.c0.method.c0(conc, time, time.dose = 0, check = TRUE)

pk.calc.c0.method.c1(conc, time, time.dose = 0, check = TRUE)

pk.calc.c0.method.set0(conc, time, time.dose = 0, check = TRUE)

pk.calc.c0.method.cmin(conc, time, time.dose = 0, check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pk.calc.c0_+3A_conc">conc</code></td>
<td>
<p>Measured concentrations</p>
</td></tr>
<tr><td><code id="pk.calc.c0_+3A_time">time</code></td>
<td>
<p>Time of the measurement of the concentrations</p>
</td></tr>
<tr><td><code id="pk.calc.c0_+3A_time.dose">time.dose</code></td>
<td>
<p>The time when dosing occurred</p>
</td></tr>
<tr><td><code id="pk.calc.c0_+3A_method">method</code></td>
<td>
<p>The order of methods to test (see details)</p>
</td></tr>
<tr><td><code id="pk.calc.c0_+3A_check">check</code></td>
<td>
<p>Check the <code>conc</code> and <code>time</code> inputs</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Methods available for interpolation are below, and each
has its own specific function.
</p>

<dl>
<dt><code>c0</code></dt><dd><p>If the observed <code>conc</code> at <code>time.dose</code> is nonzero, return that.  This method should usually be used first for single-dose IV bolus data in case nominal time zero is measured.</p>
</dd>
<dt><code>logslope</code></dt><dd><p>Compute the semilog line between the first two measured times, and use that line to extrapolate backward to <code>time.dose</code></p>
</dd>
<dt><code>c1</code></dt><dd><p>Use the first point after <code>time.dose</code></p>
</dd>
<dt><code>cmin</code></dt><dd><p>Set c0 to cmin during the interval.  This method should usually be used for multiple-dose oral data and IV infusion data.</p>
</dd>
<dt><code>set0</code></dt><dd><p>Set c0 to zero (regardless of any other data).  This method should usually be used first for single-dose oral data.</p>
</dd>
</dl>



<h3>Value</h3>

<p>The estimated concentration at time 0.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>pk.calc.c0.method.logslope()</code>: Semilog regress the first and second points
after time.dose.  This method will return <code>NA</code> if the second
<code>conc</code> after <code>time.dose</code> is 0 or greater than the first.
</p>
</li>
<li> <p><code>pk.calc.c0.method.c0()</code>: Use <code>C0</code> = <code>conc[time %in% time.dose]</code> if it is
nonzero.
</p>
</li>
<li> <p><code>pk.calc.c0.method.c1()</code>: Use <code>C0</code> = <code>C1</code>.
</p>
</li>
<li> <p><code>pk.calc.c0.method.set0()</code>: Use <code>C0</code> = 0 (typically used for single dose oral and
IV infusion)
</p>
</li>
<li> <p><code>pk.calc.c0.method.cmin()</code>: Use <code>C0</code> = Cmin (typically used for multiple dose oral
and IV infusion but not IV bolus)
</p>
</li></ul>

<hr>
<h2 id='pk.calc.cav'>Calculate the average concentration during an interval.</h2><span id='topic+pk.calc.cav'></span>

<h3>Description</h3>

<p>Calculate the average concentration during an interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pk.calc.cav(auc, start, end)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pk.calc.cav_+3A_auc">auc</code></td>
<td>
<p>The area under the curve during the interval</p>
</td></tr>
<tr><td><code id="pk.calc.cav_+3A_start">start</code></td>
<td>
<p>The start time of the interval</p>
</td></tr>
<tr><td><code id="pk.calc.cav_+3A_end">end</code></td>
<td>
<p>The end time of the interval</p>
</td></tr>
</table>


<h3>Details</h3>

<p>cav is <code>auc/(end-start)</code>.
</p>


<h3>Value</h3>

<p>The Cav (average concentration during the interval)
</p>

<hr>
<h2 id='pk.calc.ceoi'>Determine the concentration at the end of infusion</h2><span id='topic+pk.calc.ceoi'></span>

<h3>Description</h3>

<p>Determine the concentration at the end of infusion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pk.calc.ceoi(conc, time, duration.dose = NA, check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pk.calc.ceoi_+3A_conc">conc</code></td>
<td>
<p>Measured concentrations</p>
</td></tr>
<tr><td><code id="pk.calc.ceoi_+3A_time">time</code></td>
<td>
<p>Time of the measurement of the concentrations</p>
</td></tr>
<tr><td><code id="pk.calc.ceoi_+3A_duration.dose">duration.dose</code></td>
<td>
<p>The duration for the dosing administration (typically
from IV infusion)</p>
</td></tr>
<tr><td><code id="pk.calc.ceoi_+3A_check">check</code></td>
<td>
<p>Run <code><a href="#topic+assert_conc_time">assert_conc_time()</a></code>?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The concentration at the end of the infusion, <code>NA</code> if
<code>duration.dose</code> is <code>NA</code>, or <code>NA</code> if all <code>time != duration.dose</code>
</p>

<hr>
<h2 id='pk.calc.cl'>Calculate the (observed oral) clearance</h2><span id='topic+pk.calc.cl'></span>

<h3>Description</h3>

<p>Calculate the (observed oral) clearance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pk.calc.cl(dose, auc)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pk.calc.cl_+3A_dose">dose</code></td>
<td>
<p>the dose administered</p>
</td></tr>
<tr><td><code id="pk.calc.cl_+3A_auc">auc</code></td>
<td>
<p>The area under the concentration-time curve.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>cl is <code>dose/auc</code>.
</p>
<p>If <code>dose</code> is the same length as the other inputs, then the output
will be the same length as all of the inputs; the function assumes that you
are calculating for multiple intervals simultaneously.  If the inputs other
than <code>dose</code> are scalars and <code>dose</code> is a vector, then the function assumes
multiple doses were given in a single interval, and the sum of the <code>dose</code>s
will be used for the calculation.
</p>


<h3>Value</h3>

<p>the numeric value of the total (CL) or observed oral clearance
(CL/F)
</p>


<h3>References</h3>

<p>Gabrielsson J, Weiner D. &quot;Section 2.5.1 Derivation of clearance.&quot;
Pharmacokinetic &amp; Pharmacodynamic Data Analysis: Concepts and Applications,
4th Edition.  Stockholm, Sweden: Swedish Pharmaceutical Press, 2000. 86-7.
</p>

<hr>
<h2 id='pk.calc.clast.obs'>Determine the last observed concentration above the limit of quantification
(LOQ).</h2><span id='topic+pk.calc.clast.obs'></span>

<h3>Description</h3>

<p>If all concentrations are missing, <code>NA_real_</code> is returned.  If all
concentrations are zero (below the limit of quantification) or missing, zero
is returned.  If Tlast is NA (due to no non-missing above LOQ measurements),
this will return <code>NA_real_</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pk.calc.clast.obs(conc, time, check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pk.calc.clast.obs_+3A_conc">conc</code></td>
<td>
<p>Measured concentrations</p>
</td></tr>
<tr><td><code id="pk.calc.clast.obs_+3A_time">time</code></td>
<td>
<p>Time of the measurement of the concentrations</p>
</td></tr>
<tr><td><code id="pk.calc.clast.obs_+3A_check">check</code></td>
<td>
<p>Run <code><a href="#topic+assert_conc_time">assert_conc_time()</a></code>?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The last observed concentration above the LOQ
</p>


<h3>See Also</h3>

<p>Other NCA parameters for concentrations during the intervals: 
<code><a href="#topic+pk.calc.cmax">pk.calc.cmax</a>()</code>,
<code><a href="#topic+pk.calc.count_conc">pk.calc.count_conc</a>()</code>,
<code><a href="#topic+pk.calc.cstart">pk.calc.cstart</a>()</code>,
<code><a href="#topic+pk.calc.ctrough">pk.calc.ctrough</a>()</code>
</p>

<hr>
<h2 id='pk.calc.clr'>Calculate renal clearance</h2><span id='topic+pk.calc.clr'></span>

<h3>Description</h3>

<p>Calculate renal clearance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pk.calc.clr(ae, auc)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pk.calc.clr_+3A_ae">ae</code></td>
<td>
<p>The amount excreted in urine (as a numeric scalar or vector)</p>
</td></tr>
<tr><td><code id="pk.calc.clr_+3A_auc">auc</code></td>
<td>
<p>The area under the curve (as a numeric scalar or vector)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>clr is <code>sum(ae)/auc</code>.
</p>
<p>The units for the <code>ae</code> and <code>auc</code> should match such that <code>ae/auc</code> has
units of volume/time.
</p>


<h3>Value</h3>

<p>The renal clearance as a number
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pk.calc.ae">pk.calc.ae()</a></code>, <code><a href="#topic+pk.calc.fe">pk.calc.fe()</a></code>
</p>

<hr>
<h2 id='pk.calc.cmax'>Determine maximum observed PK concentration</h2><span id='topic+pk.calc.cmax'></span><span id='topic+pk.calc.cmin'></span>

<h3>Description</h3>

<p>Determine maximum observed PK concentration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pk.calc.cmax(conc, check = TRUE)

pk.calc.cmin(conc, check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pk.calc.cmax_+3A_conc">conc</code></td>
<td>
<p>Measured concentrations</p>
</td></tr>
<tr><td><code id="pk.calc.cmax_+3A_check">check</code></td>
<td>
<p>Run <code><a href="#topic+assert_conc">assert_conc()</a></code>?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a number for the maximum concentration or NA if all concentrations
are missing
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>pk.calc.cmin()</code>: Determine the minimum observed PK
concentration
</p>
</li></ul>


<h3>See Also</h3>

<p>Other NCA parameters for concentrations during the intervals: 
<code><a href="#topic+pk.calc.clast.obs">pk.calc.clast.obs</a>()</code>,
<code><a href="#topic+pk.calc.count_conc">pk.calc.count_conc</a>()</code>,
<code><a href="#topic+pk.calc.cstart">pk.calc.cstart</a>()</code>,
<code><a href="#topic+pk.calc.ctrough">pk.calc.ctrough</a>()</code>
</p>
<p>Other NCA parameters for concentrations during the intervals: 
<code><a href="#topic+pk.calc.clast.obs">pk.calc.clast.obs</a>()</code>,
<code><a href="#topic+pk.calc.count_conc">pk.calc.count_conc</a>()</code>,
<code><a href="#topic+pk.calc.cstart">pk.calc.cstart</a>()</code>,
<code><a href="#topic+pk.calc.ctrough">pk.calc.ctrough</a>()</code>
</p>

<hr>
<h2 id='pk.calc.count_conc'>Count the number of concentration measurements in an interval</h2><span id='topic+pk.calc.count_conc'></span>

<h3>Description</h3>

<p><code>count_conc</code> is typically used for quality control on the data to ensure that
there are a sufficient number of non-missing samples for a calculation and to
ensure that data are consistent between individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pk.calc.count_conc(conc, check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pk.calc.count_conc_+3A_conc">conc</code></td>
<td>
<p>Measured concentrations</p>
</td></tr>
<tr><td><code id="pk.calc.count_conc_+3A_check">check</code></td>
<td>
<p>Run <code><a href="#topic+assert_conc">assert_conc()</a></code>?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a count of the non-missing concentrations (0 if all concentrations
are missing)
</p>


<h3>See Also</h3>

<p>Other NCA parameters for concentrations during the intervals: 
<code><a href="#topic+pk.calc.clast.obs">pk.calc.clast.obs</a>()</code>,
<code><a href="#topic+pk.calc.cmax">pk.calc.cmax</a>()</code>,
<code><a href="#topic+pk.calc.cstart">pk.calc.cstart</a>()</code>,
<code><a href="#topic+pk.calc.ctrough">pk.calc.ctrough</a>()</code>
</p>

<hr>
<h2 id='pk.calc.cstart'>Determine the concentration at the beginning of the interval</h2><span id='topic+pk.calc.cstart'></span>

<h3>Description</h3>

<p>Determine the concentration at the beginning of the interval
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pk.calc.cstart(conc, time, start)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pk.calc.cstart_+3A_conc">conc</code></td>
<td>
<p>Measured concentrations</p>
</td></tr>
<tr><td><code id="pk.calc.cstart_+3A_time">time</code></td>
<td>
<p>Time of the measurement of the concentrations</p>
</td></tr>
<tr><td><code id="pk.calc.cstart_+3A_start">start</code></td>
<td>
<p>The start time of the interval</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The concentration when <code>time == end</code>.  If none match, then <code>NA</code>
</p>


<h3>See Also</h3>

<p>Other NCA parameters for concentrations during the intervals: 
<code><a href="#topic+pk.calc.clast.obs">pk.calc.clast.obs</a>()</code>,
<code><a href="#topic+pk.calc.cmax">pk.calc.cmax</a>()</code>,
<code><a href="#topic+pk.calc.count_conc">pk.calc.count_conc</a>()</code>,
<code><a href="#topic+pk.calc.ctrough">pk.calc.ctrough</a>()</code>
</p>

<hr>
<h2 id='pk.calc.ctrough'>Determine the trough (end of interval) concentration</h2><span id='topic+pk.calc.ctrough'></span>

<h3>Description</h3>

<p>Determine the trough (end of interval) concentration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pk.calc.ctrough(conc, time, end)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pk.calc.ctrough_+3A_conc">conc</code></td>
<td>
<p>Measured concentrations</p>
</td></tr>
<tr><td><code id="pk.calc.ctrough_+3A_time">time</code></td>
<td>
<p>Time of the measurement of the concentrations</p>
</td></tr>
<tr><td><code id="pk.calc.ctrough_+3A_end">end</code></td>
<td>
<p>The end time of the interval</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The concentration when <code>time == end</code>.  If none match, then <code>NA</code>
</p>


<h3>See Also</h3>

<p>Other NCA parameters for concentrations during the intervals: 
<code><a href="#topic+pk.calc.clast.obs">pk.calc.clast.obs</a>()</code>,
<code><a href="#topic+pk.calc.cmax">pk.calc.cmax</a>()</code>,
<code><a href="#topic+pk.calc.count_conc">pk.calc.count_conc</a>()</code>,
<code><a href="#topic+pk.calc.cstart">pk.calc.cstart</a>()</code>
</p>

<hr>
<h2 id='pk.calc.deg.fluc'>Determine the degree of fluctuation</h2><span id='topic+pk.calc.deg.fluc'></span>

<h3>Description</h3>

<p>Determine the degree of fluctuation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pk.calc.deg.fluc(cmax, cmin, cav)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pk.calc.deg.fluc_+3A_cmax">cmax</code></td>
<td>
<p>The maximum observed concentration</p>
</td></tr>
<tr><td><code id="pk.calc.deg.fluc_+3A_cmin">cmin</code></td>
<td>
<p>The minimum observed concentration</p>
</td></tr>
<tr><td><code id="pk.calc.deg.fluc_+3A_cav">cav</code></td>
<td>
<p>The average concentration in the interval</p>
</td></tr>
</table>


<h3>Details</h3>

<p>deg.fluc is <code>100*(cmax - cmin)/cav</code>.
</p>


<h3>Value</h3>

<p>The degree of fluctuation around the average concentration.
</p>

<hr>
<h2 id='pk.calc.dn'>Determine dose normalized NCA parameter</h2><span id='topic+pk.calc.dn'></span>

<h3>Description</h3>

<p>Determine dose normalized NCA parameter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pk.calc.dn(parameter, dose)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pk.calc.dn_+3A_parameter">parameter</code></td>
<td>
<p>Parameter to dose normalize</p>
</td></tr>
<tr><td><code id="pk.calc.dn_+3A_dose">dose</code></td>
<td>
<p>Dose in units compatible with the area under the curve</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a number for dose normalized AUC
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pk.calc.dn(90, 10)
</code></pre>

<hr>
<h2 id='pk.calc.f'>Calculate the absolute (or relative) bioavailability</h2><span id='topic+pk.calc.f'></span>

<h3>Description</h3>

<p>Calculate the absolute (or relative) bioavailability
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pk.calc.f(dose1, auc1, dose2, auc2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pk.calc.f_+3A_dose1">dose1</code></td>
<td>
<p>The dose administered in route or method 1</p>
</td></tr>
<tr><td><code id="pk.calc.f_+3A_auc1">auc1</code></td>
<td>
<p>The AUC from 0 to infinity or 0 to tau administered in route or
method 1</p>
</td></tr>
<tr><td><code id="pk.calc.f_+3A_dose2">dose2</code></td>
<td>
<p>The dose administered in route or method 2</p>
</td></tr>
<tr><td><code id="pk.calc.f_+3A_auc2">auc2</code></td>
<td>
<p>The AUC from 0 to infinity or 0 to tau administered in route or
method 2</p>
</td></tr>
</table>


<h3>Details</h3>

<p>f is <code>(auc2/dose2)/(auc1/dose1)</code>.
</p>

<hr>
<h2 id='pk.calc.fe'>Calculate fraction excreted (typically in urine or feces)</h2><span id='topic+pk.calc.fe'></span>

<h3>Description</h3>

<p>Calculate fraction excreted (typically in urine or feces)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pk.calc.fe(ae, dose)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pk.calc.fe_+3A_ae">ae</code></td>
<td>
<p>The amount excreted (as a numeric scalar or vector)</p>
</td></tr>
<tr><td><code id="pk.calc.fe_+3A_dose">dose</code></td>
<td>
<p>The dose (as a numeric scalar or vector)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>fe is <code>sum(ae)/dose</code>
</p>
<p>The units for <code>ae</code> and <code>dose</code> should be the same so that <code>ae/dose</code>
is a unitless fraction.
</p>


<h3>Value</h3>

<p>The fraction of dose excreted
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pk.calc.ae">pk.calc.ae()</a></code>, <code><a href="#topic+pk.calc.clr">pk.calc.clr()</a></code>
</p>

<hr>
<h2 id='pk.calc.half.life'>Compute the half-life and associated parameters</h2><span id='topic+pk.calc.half.life'></span>

<h3>Description</h3>

<p>The terminal elimination half-life is estimated from the final points in the
concentration-time curve using semi-log regression (<code>log(conc)~time</code>)
with automated selection of the points for calculation (unless
<code>manually.selected.points</code> is <code>TRUE</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pk.calc.half.life(
  conc,
  time,
  tmax,
  tlast,
  manually.selected.points = FALSE,
  options = list(),
  min.hl.points = NULL,
  adj.r.squared.factor = NULL,
  conc.blq = NULL,
  conc.na = NULL,
  first.tmax = NULL,
  allow.tmax.in.half.life = NULL,
  check = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pk.calc.half.life_+3A_conc">conc</code></td>
<td>
<p>Measured concentrations</p>
</td></tr>
<tr><td><code id="pk.calc.half.life_+3A_time">time</code></td>
<td>
<p>Time of the measurement of the concentrations</p>
</td></tr>
<tr><td><code id="pk.calc.half.life_+3A_tmax">tmax</code></td>
<td>
<p>Time of maximum concentration (will be calculated and
included in the return data frame if not given)</p>
</td></tr>
<tr><td><code id="pk.calc.half.life_+3A_tlast">tlast</code></td>
<td>
<p>Time of last concentration above the limit of
quantification (will be calculated and included in the return data
frame if not given)</p>
</td></tr>
<tr><td><code id="pk.calc.half.life_+3A_manually.selected.points">manually.selected.points</code></td>
<td>
<p>Have the input points (<code>conc</code> and
<code>time</code>) been manually selected?  The impact of setting this to
<code>TRUE</code> is that no selection for the best points will be done.  When
<code>TRUE</code>, this option causes the options of <code>adj.r.squared.factor</code>,
<code>min.hl.points</code>, and <code>allow.tmax.in.half.life</code> to be ignored.</p>
</td></tr>
<tr><td><code id="pk.calc.half.life_+3A_options">options</code></td>
<td>
<p>List of changes to the default PKNCA options (see
<code>PKNCA.options()</code>)</p>
</td></tr>
<tr><td><code id="pk.calc.half.life_+3A_min.hl.points">min.hl.points</code></td>
<td>
<p>The minimum number of points that must be
included to calculate the half-life</p>
</td></tr>
<tr><td><code id="pk.calc.half.life_+3A_adj.r.squared.factor">adj.r.squared.factor</code></td>
<td>
<p>The allowance in adjusted r-squared for
adding another point.</p>
</td></tr>
<tr><td><code id="pk.calc.half.life_+3A_conc.blq">conc.blq</code></td>
<td>
<p>See <code><a href="#topic+clean.conc.blq">clean.conc.blq()</a></code></p>
</td></tr>
<tr><td><code id="pk.calc.half.life_+3A_conc.na">conc.na</code></td>
<td>
<p>See <code><a href="#topic+clean.conc.na">clean.conc.na()</a></code></p>
</td></tr>
<tr><td><code id="pk.calc.half.life_+3A_first.tmax">first.tmax</code></td>
<td>
<p>See <code><a href="#topic+pk.calc.tmax">pk.calc.tmax()</a></code>.</p>
</td></tr>
<tr><td><code id="pk.calc.half.life_+3A_allow.tmax.in.half.life">allow.tmax.in.half.life</code></td>
<td>
<p>Allow the concentration point for tmax
to be included in the half-life slope calculation.</p>
</td></tr>
<tr><td><code id="pk.calc.half.life_+3A_check">check</code></td>
<td>
<p>Run <code><a href="#topic+assert_conc_time">assert_conc_time()</a></code>,
<code><a href="#topic+clean.conc.blq">clean.conc.blq()</a></code>, and <code><a href="#topic+clean.conc.na">clean.conc.na()</a></code>?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the &quot;Half-Life Calculation&quot; vignette for more details on the calculation
methods used.
</p>
<p>If <code>manually.selected.points</code> is <code>FALSE</code> (default), the
half-life is calculated by computing the best fit line for all points at or
after tmax (based on the value of <code>allow.tmax.in.half.life</code>).  The best
half-life is chosen by the following rules in order:
</p>

<ul>
<li><p>At least <code>min.hl.points</code> points included
</p>
</li>
<li><p>A <code>lambda.z</code> &gt; 0 and at the same time the best adjusted r-squared
(within <code>adj.r.squared.factor</code>)
</p>
</li>
<li><p>The one with the most points included
</p>
</li></ul>

<p>If <code>manually.selected.points</code> is <code>TRUE</code>, the <code>conc</code>
and <code>time</code> data are used as-is without any form of selection for
the best-fit half-life.
</p>


<h3>Value</h3>

<p>A data frame with one row and columns for
</p>

<dl>
<dt>tmax</dt><dd><p>Time of maximum observed concentration (only included
if not given as an input)</p>
</dd>
<dt>tlast</dt><dd><p>Time of last observed concentration above the LOQ (only
included if not given as an input)</p>
</dd>
<dt>r.squared</dt><dd><p>coefficient of determination</p>
</dd>
<dt>adj.r.squared</dt><dd><p>adjusted coefficient of determination</p>
</dd>
<dt>lambda.z</dt><dd><p>elimination rate</p>
</dd>
<dt>lambda.z.time.first</dt><dd><p>first time for half-life calculation</p>
</dd>
<dt>lambda.z.n.points</dt><dd><p>number of points in half-life calculation</p>
</dd>
<dt>clast.pred</dt><dd><p>Concentration at tlast as predicted by the half-life
line</p>
</dd>
<dt>half.life</dt><dd><p>half-life</p>
</dd>
<dt>span.ratio</dt><dd><p>span ratio [ratio of half-life to time used for
half-life calculation</p>
</dd>
</dl>



<h3>References</h3>

<p>Gabrielsson J, Weiner D.  &quot;Section 2.8.4 Strategies for estimation of
lambda-z.&quot;  Pharmacokinetic &amp; Pharmacodynamic Data Analysis: Concepts
and Applications, 4th Edition.  Stockholm, Sweden: Swedish
Pharmaceutical Press, 2000.  167-9.
</p>

<hr>
<h2 id='pk.calc.kel'>Calculate the elimination rate (Kel)</h2><span id='topic+pk.calc.kel'></span>

<h3>Description</h3>

<p>Calculate the elimination rate (Kel)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pk.calc.kel(mrt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pk.calc.kel_+3A_mrt">mrt</code></td>
<td>
<p>the mean residence time</p>
</td></tr>
<tr><td><code id="pk.calc.kel_+3A_kel">kel</code></td>
<td>
<p>is <code>1/mrt</code>, not to be confused with lambda.z.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the numeric value of the elimination rate
</p>

<hr>
<h2 id='pk.calc.mrt'>Calculate the mean residence time (MRT) for single-dose data or linear
multiple-dose data.</h2><span id='topic+pk.calc.mrt'></span><span id='topic+pk.calc.mrt.iv'></span>

<h3>Description</h3>

<p>Calculate the mean residence time (MRT) for single-dose data or linear
multiple-dose data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pk.calc.mrt(auc, aumc)

pk.calc.mrt.iv(auc, aumc, duration.dose)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pk.calc.mrt_+3A_auc">auc</code></td>
<td>
<p>the AUC from 0 to infinity or 0 to tau</p>
</td></tr>
<tr><td><code id="pk.calc.mrt_+3A_aumc">aumc</code></td>
<td>
<p>the AUMC from 0 to infinity or 0 to tau</p>
</td></tr>
<tr><td><code id="pk.calc.mrt_+3A_duration.dose">duration.dose</code></td>
<td>
<p>The duration of the dose (usually an infusion duration
for an IV infusion)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>mrt is <code>aumc/auc - duration.dose/2</code> where <code>duration.dose = 0</code> for oral administration.
</p>


<h3>Value</h3>

<p>the numeric value of the mean residence time
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>pk.calc.mrt.iv()</code>: MRT for an IV infusion
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+pk.calc.mrt.md">pk.calc.mrt.md()</a></code>
</p>

<hr>
<h2 id='pk.calc.mrt.md'>Calculate the mean residence time (MRT) for multiple-dose data with nonlinear
kinetics.</h2><span id='topic+pk.calc.mrt.md'></span>

<h3>Description</h3>

<p>Calculate the mean residence time (MRT) for multiple-dose data with nonlinear
kinetics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pk.calc.mrt.md(auctau, aumctau, aucinf, tau)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pk.calc.mrt.md_+3A_auctau">auctau</code></td>
<td>
<p>the AUC from time 0 to the end of the dosing interval (tau).</p>
</td></tr>
<tr><td><code id="pk.calc.mrt.md_+3A_aumctau">aumctau</code></td>
<td>
<p>the AUMC from time 0 to the end of the dosing interval (tau).</p>
</td></tr>
<tr><td><code id="pk.calc.mrt.md_+3A_aucinf">aucinf</code></td>
<td>
<p>the AUC from time 0 to infinity (typically using single-dose
data)</p>
</td></tr>
<tr><td><code id="pk.calc.mrt.md_+3A_tau">tau</code></td>
<td>
<p>The dosing interval</p>
</td></tr>
</table>


<h3>Details</h3>

<p>mrt.md is <code>aumctau/auctau + tau*(aucinf-auctau)/auctau</code> and should
only be used for multiple dosing with equal intervals between doses.
</p>
<p>Note that if <code>aucinf == auctau</code> (as would be the assumption with
linear kinetics), the equation becomes the same as the single-dose MRT.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pk.calc.mrt">pk.calc.mrt()</a></code>
</p>

<hr>
<h2 id='pk.calc.ptr'>Determine the peak-to-trough ratio</h2><span id='topic+pk.calc.ptr'></span>

<h3>Description</h3>

<p>Determine the peak-to-trough ratio
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pk.calc.ptr(cmax, ctrough)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pk.calc.ptr_+3A_cmax">cmax</code></td>
<td>
<p>The maximum observed concentration</p>
</td></tr>
<tr><td><code id="pk.calc.ptr_+3A_ctrough">ctrough</code></td>
<td>
<p>The last concentration in an interval</p>
</td></tr>
</table>


<h3>Details</h3>

<p>ptr is <code>cmax/ctrough</code>.
</p>


<h3>Value</h3>

<p>The ratio of cmax to ctrough (if ctrough == 0, NA)
</p>

<hr>
<h2 id='pk.calc.sparse_auc'>Calculate AUC and related parameters using sparse NCA methods</h2><span id='topic+pk.calc.sparse_auc'></span><span id='topic+pk.calc.sparse_auclast'></span>

<h3>Description</h3>

<p>The AUC is calculated as:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pk.calc.sparse_auc(
  conc,
  time,
  subject,
  method = NULL,
  auc.type = "AUClast",
  ...,
  options = list()
)

pk.calc.sparse_auclast(conc, time, subject, ..., options = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pk.calc.sparse_auc_+3A_conc">conc</code></td>
<td>
<p>Measured concentrations</p>
</td></tr>
<tr><td><code id="pk.calc.sparse_auc_+3A_time">time</code></td>
<td>
<p>Time of the measurement of the concentrations</p>
</td></tr>
<tr><td><code id="pk.calc.sparse_auc_+3A_subject">subject</code></td>
<td>
<p>Subject identifiers (may be any class; may not be null)</p>
</td></tr>
<tr><td><code id="pk.calc.sparse_auc_+3A_method">method</code></td>
<td>
<p>The method for integration (one of 'lin up/log down',
'lin-log', or 'linear')</p>
</td></tr>
<tr><td><code id="pk.calc.sparse_auc_+3A_auc.type">auc.type</code></td>
<td>
<p>The type of AUC to compute.  Choices are 'AUCinf', 'AUClast',
and 'AUCall'.</p>
</td></tr>
<tr><td><code id="pk.calc.sparse_auc_+3A_...">...</code></td>
<td>
<p>For functions other than <code>pk.calc.auxc</code>, these values are passed
to <code>pk.calc.auxc</code></p>
</td></tr>
<tr><td><code id="pk.calc.sparse_auc_+3A_options">options</code></td>
<td>
<p>List of changes to the default PKNCA options (see
<code>PKNCA.options()</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">AUC=\sum\limits_{i} w_i \bar{C}_i</code>
</p>

<p>Where:
</p>

<dl>
<dt><code class="reqn">AUC</code></dt><dd><p>is the estimated area under the concentration-time curve</p>
</dd>
<dt><code class="reqn">w_i</code></dt><dd><p>is the weight applied to the concentration at time i (related to the time which it affects, see <code><a href="#topic+sparse_auc_weight_linear">sparse_auc_weight_linear()</a></code>)</p>
</dd>
<dt><code class="reqn">\bar{C}_i</code></dt><dd><p>is the average concentration at time i</p>
</dd>
</dl>



<h3>Functions</h3>


<ul>
<li> <p><code>pk.calc.sparse_auclast()</code>: Compute the AUClast for sparse PK
</p>
</li></ul>


<h3>See Also</h3>

<p>Other Sparse Methods: 
<code><a href="#topic+as_sparse_pk">as_sparse_pk</a>()</code>,
<code><a href="#topic+sparse_auc_weight_linear">sparse_auc_weight_linear</a>()</code>,
<code><a href="#topic+sparse_mean">sparse_mean</a>()</code>
</p>

<hr>
<h2 id='pk.calc.swing'>Determine the PK swing</h2><span id='topic+pk.calc.swing'></span>

<h3>Description</h3>

<p>Determine the PK swing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pk.calc.swing(cmax, cmin)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pk.calc.swing_+3A_cmax">cmax</code></td>
<td>
<p>The maximum observed concentration</p>
</td></tr>
<tr><td><code id="pk.calc.swing_+3A_cmin">cmin</code></td>
<td>
<p>The minimum observed concentration</p>
</td></tr>
</table>


<h3>Details</h3>

<p>swing is <code>100*(cmax - cmin)/cmin</code>.
</p>


<h3>Value</h3>

<p>The swing above the minimum concentration.  If <code>cmin</code> is zero, then
the result is infinity.
</p>

<hr>
<h2 id='pk.calc.thalf.eff'>Calculate the effective half-life</h2><span id='topic+pk.calc.thalf.eff'></span>

<h3>Description</h3>

<p>Calculate the effective half-life
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pk.calc.thalf.eff(mrt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pk.calc.thalf.eff_+3A_mrt">mrt</code></td>
<td>
<p>the mean residence time to infinity</p>
</td></tr>
</table>


<h3>Details</h3>

<p>thalf.eff is <code>log(2)*mrt</code>.
</p>


<h3>Value</h3>

<p>the numeric value of the effective half-life
</p>

<hr>
<h2 id='pk.calc.time_above'>Determine time at or above a set value</h2><span id='topic+pk.calc.time_above'></span>

<h3>Description</h3>

<p>Interpolation is performed aligning with <code>PKNCA.options("auc.method")</code>.
Extrapolation outside of the measured times is not yet implemented.  The
<code>method</code> may be changed by giving a named <code>method</code> argument, as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pk.calc.time_above(conc, time, conc_above, ..., options = list(), check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pk.calc.time_above_+3A_conc">conc</code></td>
<td>
<p>Measured concentrations</p>
</td></tr>
<tr><td><code id="pk.calc.time_above_+3A_time">time</code></td>
<td>
<p>Time of the measurement of the concentrations</p>
</td></tr>
<tr><td><code id="pk.calc.time_above_+3A_conc_above">conc_above</code></td>
<td>
<p>The concentration to be above</p>
</td></tr>
<tr><td><code id="pk.calc.time_above_+3A_...">...</code></td>
<td>
<p>Extra arguments.  Currently, the only extra argument that is used
is <code>method</code> as described in the details section.</p>
</td></tr>
<tr><td><code id="pk.calc.time_above_+3A_options">options</code></td>
<td>
<p>List of changes to the default PKNCA options (see
<code>PKNCA.options()</code>)</p>
</td></tr>
<tr><td><code id="pk.calc.time_above_+3A_check">check</code></td>
<td>
<p>Run <code><a href="#topic+assert_conc_time">assert_conc_time()</a></code>, <code><a href="#topic+clean.conc.blq">clean.conc.blq()</a></code>, and
<code><a href="#topic+clean.conc.na">clean.conc.na()</a></code>?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>'lin up/log down'</code>, if <code>clast</code> is above <code>conc_above</code> and there are
concentrations BLQ after that, linear down is used to extrapolate to the BLQ
concentration (equivalent to AUCall).
</p>


<h3>Value</h3>

<p>the time above the given concentration
</p>

<hr>
<h2 id='pk.calc.tlag'>Determine the observed lag time (time before the first
concentration above the limit of quantification or above the first
concentration in the interval)</h2><span id='topic+pk.calc.tlag'></span>

<h3>Description</h3>

<p>Determine the observed lag time (time before the first
concentration above the limit of quantification or above the first
concentration in the interval)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pk.calc.tlag(conc, time)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pk.calc.tlag_+3A_conc">conc</code></td>
<td>
<p>Measured concentrations</p>
</td></tr>
<tr><td><code id="pk.calc.tlag_+3A_time">time</code></td>
<td>
<p>Time of the measurement of the concentrations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The time associated with the first increasing concentration
</p>

<hr>
<h2 id='pk.calc.tlast'>Determine time of last observed concentration above the limit of
quantification.</h2><span id='topic+pk.calc.tlast'></span><span id='topic+pk.calc.tfirst'></span>

<h3>Description</h3>

<p><code>NA</code> will be returned if all <code>conc</code> are <code>NA</code> or 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pk.calc.tlast(conc, time, check = TRUE)

pk.calc.tfirst(conc, time, check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pk.calc.tlast_+3A_conc">conc</code></td>
<td>
<p>Measured concentrations</p>
</td></tr>
<tr><td><code id="pk.calc.tlast_+3A_time">time</code></td>
<td>
<p>Time of the measurement of the concentrations</p>
</td></tr>
<tr><td><code id="pk.calc.tlast_+3A_check">check</code></td>
<td>
<p>Run <code><a href="#topic+assert_conc_time">assert_conc_time()</a></code>?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The time of the last observed concentration measurement
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>pk.calc.tfirst()</code>: Determine the first concentration above
the limit of quantification.
</p>
</li></ul>

<hr>
<h2 id='pk.calc.tmax'>Determine time of maximum observed PK concentration</h2><span id='topic+pk.calc.tmax'></span>

<h3>Description</h3>

<p>Input restrictions are:
</p>

<ol>
<li><p> the <code>conc</code> and <code>time</code> must be the same length,
</p>
</li>
<li><p> the <code>time</code> may have no NAs,
</p>
</li></ol>

<p><code>NA</code> will be returned if:
</p>

<ol>
<li><p> the length of <code>conc</code> and <code>time</code> is 0
</p>
</li>
<li><p> all <code>conc</code> is 0 or <code>NA</code>
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>pk.calc.tmax(conc, time, options = list(), first.tmax = NULL, check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pk.calc.tmax_+3A_conc">conc</code></td>
<td>
<p>Measured concentrations</p>
</td></tr>
<tr><td><code id="pk.calc.tmax_+3A_time">time</code></td>
<td>
<p>Time of the measurement of the concentrations</p>
</td></tr>
<tr><td><code id="pk.calc.tmax_+3A_options">options</code></td>
<td>
<p>List of changes to the default PKNCA options (see
<code>PKNCA.options()</code>)</p>
</td></tr>
<tr><td><code id="pk.calc.tmax_+3A_first.tmax">first.tmax</code></td>
<td>
<p>If there is more than time that matches the maximum
concentration, should the first be considered as Tmax?  If not, then the
last is considered Tmax.</p>
</td></tr>
<tr><td><code id="pk.calc.tmax_+3A_check">check</code></td>
<td>
<p>Run <code><a href="#topic+assert_conc_time">assert_conc_time()</a></code>?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The time of the maximum concentration
</p>

<hr>
<h2 id='pk.calc.totdose'>Extract the dose used for calculations</h2><span id='topic+pk.calc.totdose'></span>

<h3>Description</h3>

<p>Extract the dose used for calculations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pk.calc.totdose(dose)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pk.calc.totdose_+3A_dose">dose</code></td>
<td>
<p>the dose administered</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The total dose for an interval
</p>

<hr>
<h2 id='pk.calc.vss'>Calculate the steady-state volume of distribution (Vss)</h2><span id='topic+pk.calc.vss'></span>

<h3>Description</h3>

<p>Calculate the steady-state volume of distribution (Vss)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pk.calc.vss(cl, mrt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pk.calc.vss_+3A_cl">cl</code></td>
<td>
<p>the clearance</p>
</td></tr>
<tr><td><code id="pk.calc.vss_+3A_mrt">mrt</code></td>
<td>
<p>the mean residence time</p>
</td></tr>
</table>


<h3>Details</h3>

<p>vss is <code>cl*mrt</code>.
</p>


<h3>Value</h3>

<p>the volume of distribution at steady-state
</p>

<hr>
<h2 id='pk.calc.vz'>Calculate the terminal volume of distribution (Vz)</h2><span id='topic+pk.calc.vz'></span>

<h3>Description</h3>

<p>Calculate the terminal volume of distribution (Vz)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pk.calc.vz(cl, lambda.z)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pk.calc.vz_+3A_cl">cl</code></td>
<td>
<p>the clearance (or apparent observed clearance)</p>
</td></tr>
<tr><td><code id="pk.calc.vz_+3A_lambda.z">lambda.z</code></td>
<td>
<p>The elimination rate (in units of inverse time) for
extrapolation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>vz is <code>cl/lambda.z</code>.
</p>

<hr>
<h2 id='pk.nca'>Compute NCA parameters for each interval for each subject.</h2><span id='topic+pk.nca'></span>

<h3>Description</h3>

<p>The <code>pk.nca</code> function computes the NCA parameters from a <code>PKNCAdata</code> object.
All options for the calculation and input data are set in prior functions
(<code>PKNCAconc</code>, <code>PKNCAdose</code>, and <code>PKNCAdata</code>).  Options for calculations are
set either in <code>PKNCAdata</code> or with the current default options in
<code>PKNCA.options</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pk.nca(data, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pk.nca_+3A_data">data</code></td>
<td>
<p>A PKNCAdata object</p>
</td></tr>
<tr><td><code id="pk.nca_+3A_verbose">verbose</code></td>
<td>
<p>Indicate, by <code>message()</code>, the current state of calculation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When performing calculations, all time results are relative to the start of
the interval.  For example, if an interval starts at 168 hours, ends at 192
hours, and and the maximum concentration is at 169 hours, <code>tmax=169-168=1</code>.
</p>


<h3>Value</h3>

<p>A <code>PKNCAresults</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PKNCAdata">PKNCAdata()</a></code>, <code><a href="#topic+PKNCA.options">PKNCA.options()</a></code>, <code><a href="#topic+summary.PKNCAresults">summary.PKNCAresults()</a></code>,
<code><a href="#topic+as.data.frame.PKNCAresults">as.data.frame.PKNCAresults()</a></code>, <code><a href="#topic+exclude">exclude()</a></code>
</p>

<hr>
<h2 id='pk.nca.interval'>Compute all PK parameters for a single concentration-time data set</h2><span id='topic+pk.nca.interval'></span>

<h3>Description</h3>

<p>For one subject/time range, compute all available PK parameters. All the
internal options should be set by <code><a href="#topic+PKNCA.options">PKNCA.options()</a></code> prior to running.  The
only part that changes with a call to this function is the <code>conc</code>entration
and <code>time</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pk.nca.interval(
  conc,
  time,
  volume,
  duration.conc,
  dose,
  time.dose,
  duration.dose,
  route,
  conc.group = NULL,
  time.group = NULL,
  volume.group = NULL,
  duration.conc.group = NULL,
  dose.group = NULL,
  time.dose.group = NULL,
  duration.dose.group = NULL,
  route.group = NULL,
  impute_method = NA_character_,
  include_half.life = NULL,
  exclude_half.life = NULL,
  subject,
  sparse,
  interval,
  options = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pk.nca.interval_+3A_conc">conc</code></td>
<td>
<p>Measured concentrations</p>
</td></tr>
<tr><td><code id="pk.nca.interval_+3A_time">time</code></td>
<td>
<p>Time of the measurement of the concentrations</p>
</td></tr>
<tr><td><code id="pk.nca.interval_+3A_volume">volume</code>, <code id="pk.nca.interval_+3A_volume.group">volume.group</code></td>
<td>
<p>The volume (or mass) of the concentration
measurement for the current interval or all data for the group (typically
for urine and fecal measurements)</p>
</td></tr>
<tr><td><code id="pk.nca.interval_+3A_duration.conc">duration.conc</code>, <code id="pk.nca.interval_+3A_duration.conc.group">duration.conc.group</code></td>
<td>
<p>The duration of the concentration
measurement for the current interval or all data for the group (typically
for urine and fecal measurements)</p>
</td></tr>
<tr><td><code id="pk.nca.interval_+3A_dose">dose</code>, <code id="pk.nca.interval_+3A_dose.group">dose.group</code></td>
<td>
<p>Dose amount (may be a scalar or vector) for the
current interval or all data for the group</p>
</td></tr>
<tr><td><code id="pk.nca.interval_+3A_time.dose">time.dose</code>, <code id="pk.nca.interval_+3A_time.dose.group">time.dose.group</code></td>
<td>
<p>Time of the dose for the current interval or
all data for the group (must be the same length as <code>dose</code> or <code>dose.group</code>)</p>
</td></tr>
<tr><td><code id="pk.nca.interval_+3A_duration.dose">duration.dose</code>, <code id="pk.nca.interval_+3A_duration.dose.group">duration.dose.group</code></td>
<td>
<p>The duration of the dose
administration for the current interval or all data for the group
(typically zero for extravascular and intravascular bolus and nonzero for
intravascular infusion)</p>
</td></tr>
<tr><td><code id="pk.nca.interval_+3A_route">route</code>, <code id="pk.nca.interval_+3A_route.group">route.group</code></td>
<td>
<p>The route of dosing for the current interval or all
data for the group</p>
</td></tr>
<tr><td><code id="pk.nca.interval_+3A_conc.group">conc.group</code></td>
<td>
<p>All concentrations measured for the group</p>
</td></tr>
<tr><td><code id="pk.nca.interval_+3A_time.group">time.group</code></td>
<td>
<p>Time of all concentrations measured for the group</p>
</td></tr>
<tr><td><code id="pk.nca.interval_+3A_impute_method">impute_method</code></td>
<td>
<p>The method to use for imputation as a character string</p>
</td></tr>
<tr><td><code id="pk.nca.interval_+3A_include_half.life">include_half.life</code></td>
<td>
<p>An optional boolean vector of the concentration
measurements to include in the half-life calculation. If given, no
half-life point selection will occur.</p>
</td></tr>
<tr><td><code id="pk.nca.interval_+3A_exclude_half.life">exclude_half.life</code></td>
<td>
<p>An optional boolean vector of the concentration
measurements to exclude from the half-life calculation.</p>
</td></tr>
<tr><td><code id="pk.nca.interval_+3A_subject">subject</code></td>
<td>
<p>Subject identifiers (used for sparse calculations)</p>
</td></tr>
<tr><td><code id="pk.nca.interval_+3A_sparse">sparse</code></td>
<td>
<p>Should only sparse calculations be performed (TRUE) or only
dense calculations (FALSE)?</p>
</td></tr>
<tr><td><code id="pk.nca.interval_+3A_interval">interval</code></td>
<td>
<p>One row of an interval definition (see
<code><a href="#topic+check.interval.specification">check.interval.specification()</a></code> for how to define the interval.</p>
</td></tr>
<tr><td><code id="pk.nca.interval_+3A_options">options</code></td>
<td>
<p>List of changes to the default PKNCA options (see
<code>PKNCA.options()</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the start and end time along with all PK
parameters for the <code>interval</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+check.interval.specification">check.interval.specification()</a></code>
</p>

<hr>
<h2 id='pk.nca.intervals'>Compute NCA for multiple intervals</h2><span id='topic+pk.nca.intervals'></span>

<h3>Description</h3>

<p>Compute NCA for multiple intervals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pk.nca.intervals(
  data_conc,
  data_dose,
  data_intervals,
  sparse,
  options,
  impute,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pk.nca.intervals_+3A_data_conc">data_conc</code></td>
<td>
<p>A data.frame or tibble with standardized column names as
output from <code>prepare_PKNCAconc()</code></p>
</td></tr>
<tr><td><code id="pk.nca.intervals_+3A_data_dose">data_dose</code></td>
<td>
<p>A data.frame or tibble with standardized column names as
output from <code>prepare_PKNCAdose()</code></p>
</td></tr>
<tr><td><code id="pk.nca.intervals_+3A_data_intervals">data_intervals</code></td>
<td>
<p>A data.frame or tibble with standardized column names
as output from <code>prepare_PKNCAintervals()</code></p>
</td></tr>
<tr><td><code id="pk.nca.intervals_+3A_sparse">sparse</code></td>
<td>
<p>Should only sparse calculations be performed (TRUE) or only
dense calculations (FALSE)?</p>
</td></tr>
<tr><td><code id="pk.nca.intervals_+3A_options">options</code></td>
<td>
<p>List of changes to the default PKNCA options (see
<code>PKNCA.options()</code>)</p>
</td></tr>
<tr><td><code id="pk.nca.intervals_+3A_impute">impute</code></td>
<td>
<p>The column name in <code>data_intervals</code> to use for imputation</p>
</td></tr>
<tr><td><code id="pk.nca.intervals_+3A_verbose">verbose</code></td>
<td>
<p>Indicate, by <code>message()</code>, the current state of calculation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with all NCA results
</p>

<hr>
<h2 id='pk.tss'>Compute the time to steady-state (tss)</h2><span id='topic+pk.tss'></span>

<h3>Description</h3>

<p>Compute the time to steady-state (tss)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pk.tss(..., type = c("monoexponential", "stepwise.linear"), check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pk.tss_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="#topic+pk.tss.monoexponential">pk.tss.monoexponential()</a></code> or
<code><a href="#topic+pk.tss.stepwise.linear">pk.tss.stepwise.linear()</a></code>.</p>
</td></tr>
<tr><td><code id="pk.tss_+3A_type">type</code></td>
<td>
<p>The type of Tss to calculate, either <code>stepwise.linear</code> or
<code>monoexponential</code></p>
</td></tr>
<tr><td><code id="pk.tss_+3A_check">check</code></td>
<td>
<p>See <code><a href="#topic+pk.tss.data.prep">pk.tss.data.prep()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with columns as defined from <code>pk.tss.monoexponential</code>
and/or <code>pk.tss.stepwise.linear</code>.
</p>


<h3>See Also</h3>

<p>Other Time to steady-state calculations: 
<code><a href="#topic+pk.tss.monoexponential">pk.tss.monoexponential</a>()</code>,
<code><a href="#topic+pk.tss.stepwise.linear">pk.tss.stepwise.linear</a>()</code>
</p>

<hr>
<h2 id='pk.tss.data.prep'>Clean up the time to steady-state parameters and return a data frame for use
by the tss calculators.</h2><span id='topic+pk.tss.data.prep'></span>

<h3>Description</h3>

<p>Clean up the time to steady-state parameters and return a data frame for use
by the tss calculators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pk.tss.data.prep(
  conc,
  time,
  subject,
  treatment,
  subject.dosing,
  time.dosing,
  options = list(),
  conc.blq = NULL,
  conc.na = NULL,
  check = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pk.tss.data.prep_+3A_conc">conc</code></td>
<td>
<p>Measured concentrations</p>
</td></tr>
<tr><td><code id="pk.tss.data.prep_+3A_time">time</code></td>
<td>
<p>Time of the measurement of the concentrations</p>
</td></tr>
<tr><td><code id="pk.tss.data.prep_+3A_subject">subject</code></td>
<td>
<p>Subject identifiers (used as a random effect in the model)</p>
</td></tr>
<tr><td><code id="pk.tss.data.prep_+3A_treatment">treatment</code></td>
<td>
<p>Treatment description (if missing, all subjects are assumed
to be on the same treatment)</p>
</td></tr>
<tr><td><code id="pk.tss.data.prep_+3A_subject.dosing">subject.dosing</code></td>
<td>
<p>Subject number for dosing</p>
</td></tr>
<tr><td><code id="pk.tss.data.prep_+3A_time.dosing">time.dosing</code></td>
<td>
<p>Time of dosing</p>
</td></tr>
<tr><td><code id="pk.tss.data.prep_+3A_options">options</code></td>
<td>
<p>List of changes to the default PKNCA options (see
<code>PKNCA.options()</code>)</p>
</td></tr>
<tr><td><code id="pk.tss.data.prep_+3A_conc.blq">conc.blq</code></td>
<td>
<p>See <code><a href="#topic+clean.conc.blq">clean.conc.blq()</a></code></p>
</td></tr>
<tr><td><code id="pk.tss.data.prep_+3A_conc.na">conc.na</code></td>
<td>
<p>See <code><a href="#topic+clean.conc.na">clean.conc.na()</a></code></p>
</td></tr>
<tr><td><code id="pk.tss.data.prep_+3A_check">check</code></td>
<td>
<p>Run <code><a href="#topic+assert_conc_time">assert_conc_time()</a></code>?</p>
</td></tr>
<tr><td><code id="pk.tss.data.prep_+3A_...">...</code></td>
<td>
<p>Discarded inputs to allow generic calls between tss methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with columns for <code>conc</code>entration, <code>time</code>, <code>subject</code>,
and <code>treatment</code>.
</p>

<hr>
<h2 id='pk.tss.monoexponential'>Compute the time to steady state using nonlinear, mixed-effects modeling of
trough concentrations.</h2><span id='topic+pk.tss.monoexponential'></span>

<h3>Description</h3>

<p>Trough concentrations are selected as concentrations at the time of dosing.
An exponential curve is then fit through the data with a different magnitude
by treatment (as a factor) and a random steady-state concentration and time
to stead-state by subject (see <code>random.effects</code> argument).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pk.tss.monoexponential(
  ...,
  tss.fraction = 0.9,
  output = c("population", "popind", "individual", "single"),
  check = TRUE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pk.tss.monoexponential_+3A_...">...</code></td>
<td>
<p>See <code><a href="#topic+pk.tss.data.prep">pk.tss.data.prep()</a></code></p>
</td></tr>
<tr><td><code id="pk.tss.monoexponential_+3A_tss.fraction">tss.fraction</code></td>
<td>
<p>The fraction of steady-state required for calling
steady-state</p>
</td></tr>
<tr><td><code id="pk.tss.monoexponential_+3A_output">output</code></td>
<td>
<p>Which types of outputs should be produced? <code>population</code> is the
population estimate for time to steady-state (from an nlme model), <code>popind</code>
is the individual estimate (from an nlme model), <code>individual</code> fits each
individual separately with a gnls model (requires more than one individual;
use <code>single</code> for one individual), and <code>single</code> fits all the data to a
single gnls model.</p>
</td></tr>
<tr><td><code id="pk.tss.monoexponential_+3A_check">check</code></td>
<td>
<p>See <code><a href="#topic+pk.tss.data.prep">pk.tss.data.prep()</a></code>.</p>
</td></tr>
<tr><td><code id="pk.tss.monoexponential_+3A_verbose">verbose</code></td>
<td>
<p>Describe models as they are run, show convergence of the model
(passed to the nlme function), and additional details while running.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar float for the first time when steady-state is achieved or
<code>NA</code> if it is not observed.
</p>


<h3>References</h3>

<p>Maganti, L., Panebianco, D.L. &amp; Maes, A.L. Evaluation of Methods for
Estimating Time to Steady State with Examples from Phase 1 Studies. AAPS J
10, 141147 (2008). https://doi.org/10.1208/s12248-008-9014-y
</p>


<h3>See Also</h3>

<p>Other Time to steady-state calculations: 
<code><a href="#topic+pk.tss">pk.tss</a>()</code>,
<code><a href="#topic+pk.tss.stepwise.linear">pk.tss.stepwise.linear</a>()</code>
</p>

<hr>
<h2 id='pk.tss.monoexponential.individual'>A helper function to estimate individual and single outputs for
monoexponential time to steady-state.</h2><span id='topic+pk.tss.monoexponential.individual'></span>

<h3>Description</h3>

<p>This function is not intended to be called directly.  Please use
<code>pk.tss.monoexponential</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pk.tss.monoexponential.individual(
  data,
  output = c("individual", "single"),
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pk.tss.monoexponential.individual_+3A_data">data</code></td>
<td>
<p>a data frame as prepared by <code><a href="#topic+pk.tss.data.prep">pk.tss.data.prep()</a></code>.  It must
contain at least columns for <code>subject</code>, <code>time</code>, <code>conc</code>, and <code>tss.constant</code>.</p>
</td></tr>
<tr><td><code id="pk.tss.monoexponential.individual_+3A_output">output</code></td>
<td>
<p>a character vector requesting the output types.</p>
</td></tr>
<tr><td><code id="pk.tss.monoexponential.individual_+3A_verbose">verbose</code></td>
<td>
<p>Show verbose output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no model converges, then the <code>tss.monoexponential.single</code> and/or
<code>tss.monoexponential.individual</code> column will be set to NA.
</p>


<h3>Value</h3>

<p>A data frame with either one row (if <code>population</code> output is
provided) or one row per subject (if <code>popind</code> is provided).  The columns
will be named <code>tss.monoexponential.population</code> and/or
<code>tss.monoexponential.popind</code>.
</p>

<hr>
<h2 id='pk.tss.monoexponential.population'>A helper function to estimate population and popind outputs for
monoexponential time to steady-state.</h2><span id='topic+pk.tss.monoexponential.population'></span>

<h3>Description</h3>

<p>This function is not intended to be called directly.  Please use
<code>pk.tss.monoexponential</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pk.tss.monoexponential.population(
  data,
  output = c("population", "popind"),
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pk.tss.monoexponential.population_+3A_data">data</code></td>
<td>
<p>a data frame as prepared by <code><a href="#topic+pk.tss.data.prep">pk.tss.data.prep()</a></code>.  It must
contain at least columns for <code>subject</code>, <code>time</code>, <code>conc</code>, and <code>tss.constant</code>.</p>
</td></tr>
<tr><td><code id="pk.tss.monoexponential.population_+3A_output">output</code></td>
<td>
<p>a character vector requesting the output types.</p>
</td></tr>
<tr><td><code id="pk.tss.monoexponential.population_+3A_verbose">verbose</code></td>
<td>
<p>Show verbose output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no model converges, then the <code>tss.monoexponential.population</code> column will
be set to NA. If the best model does not include a random effect for subject
on Tss then the <code>tss.monoexponential.popind</code> column of the output will be set
to NA.
</p>


<h3>Value</h3>

<p>A data frame with either one row (if <code>population</code> output is
provided) or one row per subject (if <code>popind</code> is provided).  The columns
will be named <code>tss.monoexponential.population</code> and/or
<code>tss.monoexponential.popind</code>.
</p>

<hr>
<h2 id='pk.tss.stepwise.linear'>Compute the time to steady state using stepwise test of linear trend</h2><span id='topic+pk.tss.stepwise.linear'></span>

<h3>Description</h3>

<p>A linear slope is fit through the data to find when it becomes
non-significant.  Note that this is less preferred than the
<code>pk.tss.monoexponential</code> due to the fact that with more time or more subjects
the performance of the test changes (see reference).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pk.tss.stepwise.linear(
  ...,
  min.points = 3,
  level = 0.95,
  verbose = FALSE,
  check = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pk.tss.stepwise.linear_+3A_...">...</code></td>
<td>
<p>See <code><a href="#topic+pk.tss.data.prep">pk.tss.data.prep()</a></code></p>
</td></tr>
<tr><td><code id="pk.tss.stepwise.linear_+3A_min.points">min.points</code></td>
<td>
<p>The minimum number of points required for the fit</p>
</td></tr>
<tr><td><code id="pk.tss.stepwise.linear_+3A_level">level</code></td>
<td>
<p>The confidence level required for assessment of steady-state</p>
</td></tr>
<tr><td><code id="pk.tss.stepwise.linear_+3A_verbose">verbose</code></td>
<td>
<p>Describe models as they are run, show convergence of the model
(passed to the nlme function), and additional details while running.</p>
</td></tr>
<tr><td><code id="pk.tss.stepwise.linear_+3A_check">check</code></td>
<td>
<p>See <code><a href="#topic+pk.tss.data.prep">pk.tss.data.prep()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model is fit with a different magnitude by treatment (as a factor, if
given) and a random slope by subject (if given).  A minimum of <code>min.points</code>
is required to fit the model.
</p>


<h3>Value</h3>

<p>A scalar float for the first time when steady-state is achieved or
<code>NA</code> if it is not observed.
</p>


<h3>References</h3>

<p>Maganti L, Panebianco DL, Maes AL.  Evaluation of Methods for
Estimating Time to Steady State with Examples from Phase 1 Studies. AAPS
Journal 10(1):141-7. doi:10.1208/s12248-008-9014-y
</p>


<h3>See Also</h3>

<p>Other Time to steady-state calculations: 
<code><a href="#topic+pk.tss">pk.tss</a>()</code>,
<code><a href="#topic+pk.tss.monoexponential">pk.tss.monoexponential</a>()</code>
</p>

<hr>
<h2 id='pknca_find_units_param'>Find NCA parameters with a given unit type</h2><span id='topic+pknca_find_units_param'></span>

<h3>Description</h3>

<p>Find NCA parameters with a given unit type
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pknca_find_units_param(unit_type)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pknca_find_units_param_+3A_unit_type">unit_type</code></td>
<td>
<p>The type of unit as assigned with <code>add.interval.col</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of parameters with a given unit type
</p>

<hr>
<h2 id='PKNCA_impute_fun_list'>Separate out a vector of PKNCA imputation methods into a list of functions</h2><span id='topic+PKNCA_impute_fun_list'></span>

<h3>Description</h3>

<p>An error will be raised if the functions are not found.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PKNCA_impute_fun_list(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PKNCA_impute_fun_list_+3A_x">x</code></td>
<td>
<p>The character vector of PKNCA imputation method functions (without
the <code>PKNCA_impute_method_</code> part)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is not for use by users of PKNCA.
</p>


<h3>Value</h3>

<p>A list of character vectors of functions to run.
</p>

<hr>
<h2 id='PKNCA_impute_method'>Methods for imputation of data with PKNCA</h2><span id='topic+PKNCA_impute_method'></span><span id='topic+PKNCA_impute_method_start_conc0'></span><span id='topic+PKNCA_impute_method_start_cmin'></span><span id='topic+PKNCA_impute_method_start_predose'></span>

<h3>Description</h3>

<p>Methods for imputation of data with PKNCA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PKNCA_impute_method_start_conc0(conc, time, start = 0, ..., options = list())

PKNCA_impute_method_start_cmin(conc, time, start, end, ..., options = list())

PKNCA_impute_method_start_predose(
  conc,
  time,
  start,
  end,
  conc.group,
  time.group,
  ...,
  max_shift = NA_real_,
  options = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PKNCA_impute_method_+3A_conc">conc</code></td>
<td>
<p>Measured concentrations</p>
</td></tr>
<tr><td><code id="PKNCA_impute_method_+3A_time">time</code></td>
<td>
<p>Time of the measurement of the concentrations</p>
</td></tr>
<tr><td><code id="PKNCA_impute_method_+3A_start">start</code></td>
<td>
<p>The start time of the interval</p>
</td></tr>
<tr><td><code id="PKNCA_impute_method_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="PKNCA_impute_method_+3A_options">options</code></td>
<td>
<p>List of changes to the default PKNCA options (see
<code>PKNCA.options()</code>)</p>
</td></tr>
<tr><td><code id="PKNCA_impute_method_+3A_end">end</code></td>
<td>
<p>The end time of the interval</p>
</td></tr>
<tr><td><code id="PKNCA_impute_method_+3A_conc.group">conc.group</code></td>
<td>
<p>All concentrations measured for the group</p>
</td></tr>
<tr><td><code id="PKNCA_impute_method_+3A_time.group">time.group</code></td>
<td>
<p>Time of all concentrations measured for the group</p>
</td></tr>
<tr><td><code id="PKNCA_impute_method_+3A_max_shift">max_shift</code></td>
<td>
<p>The maximum amount of time to shift a concentration forward
(defaults to 5% of the interval duration, i.e. <code>0.05*(end - start)</code>, if
<code>is.finite(end)</code>, and when <code>is.infinite(end)</code>, defaults to 5% of the time
from start to <code>max(time)</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with one column named conc with imputed concentrations
and one column named time with the times.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>PKNCA_impute_method_start_conc0()</code>: Add a new concentration of 0 at the start
time, even if a nonzero concentration exists at that time (usually used
with single-dose data)
</p>
</li>
<li> <p><code>PKNCA_impute_method_start_cmin()</code>: Add a new concentration of the minimum during
the interval at the start time (usually used with multiple-dose data)
</p>
</li>
<li> <p><code>PKNCA_impute_method_start_predose()</code>: Shift a predose concentration to become the
time zero concentration (only if a time zero concentration does not exist)
</p>
</li></ul>

<hr>
<h2 id='pknca_unit_conversion'>Perform unit conversion (if possible) on PKNCA results</h2><span id='topic+pknca_unit_conversion'></span>

<h3>Description</h3>

<p>Perform unit conversion (if possible) on PKNCA results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pknca_unit_conversion(result, units)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pknca_unit_conversion_+3A_result">result</code></td>
<td>
<p>The results data.frame</p>
</td></tr>
<tr><td><code id="pknca_unit_conversion_+3A_units">units</code></td>
<td>
<p>The unit conversion table</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result table with units converted
</p>

<hr>
<h2 id='pknca_units_add_paren'>Add parentheses to a unit value, if needed</h2><span id='topic+pknca_units_add_paren'></span>

<h3>Description</h3>

<p>Add parentheses to a unit value, if needed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pknca_units_add_paren(unit)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pknca_units_add_paren_+3A_unit">unit</code></td>
<td>
<p>The text of the unit</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The unit with parentheses around it, if needed
</p>

<hr>
<h2 id='pknca_units_table'>Create a unit assignment and conversion table</h2><span id='topic+pknca_units_table'></span>

<h3>Description</h3>

<p>This data.frame is typically used for the <code>units</code> argument for <code><a href="#topic+PKNCAdata">PKNCAdata()</a></code>.
If a unit is not given, then all of the units derived from that unit will be
<code>NA</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pknca_units_table(
  concu,
  doseu,
  amountu,
  timeu,
  concu_pref = NULL,
  doseu_pref = NULL,
  amountu_pref = NULL,
  timeu_pref = NULL,
  conversions = data.frame()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pknca_units_table_+3A_concu">concu</code>, <code id="pknca_units_table_+3A_doseu">doseu</code>, <code id="pknca_units_table_+3A_amountu">amountu</code>, <code id="pknca_units_table_+3A_timeu">timeu</code></td>
<td>
<p>Units for concentration, dose, amount, and
time in the source data</p>
</td></tr>
<tr><td><code id="pknca_units_table_+3A_concu_pref">concu_pref</code>, <code id="pknca_units_table_+3A_doseu_pref">doseu_pref</code>, <code id="pknca_units_table_+3A_amountu_pref">amountu_pref</code>, <code id="pknca_units_table_+3A_timeu_pref">timeu_pref</code></td>
<td>
<p>Preferred units for
reporting; <code>conversions</code> will be automatically.</p>
</td></tr>
<tr><td><code id="pknca_units_table_+3A_conversions">conversions</code></td>
<td>
<p>An optional data.frame with columns of c(&quot;PPORRESU&quot;,
&quot;PPSTRESU&quot;, &quot;conversion_factor&quot;) for the original calculation units, the
standardized units, and a conversion factor to multiply the initial value
by to get a standardized value.  This argument overrides any preferred unit
conversions from <code>concu_pref</code>, <code>doseu_pref</code>, <code>amountu_pref</code>, or
<code>timeu_pref</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A unit conversion table with columns for &quot;PPTESTCD&quot; and &quot;PPORRESU&quot;
if <code>conversions</code> is not given, and adding &quot;PPSTRESU&quot; and
&quot;conversion_factor&quot; if <code>conversions</code> is given.
</p>


<h3>See Also</h3>

<p>The <code>units</code> argument for <code><a href="#topic+PKNCAdata">PKNCAdata()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pknca_units_table() # only parameters that are unitless
pknca_units_table(
  concu="ng/mL", doseu="mg/kg", amountu="mg", timeu="hr"
)
pknca_units_table(
  concu="ng/mL", doseu="mg/kg", amountu="mg", timeu="hr",
  # Convert clearance and volume units to more understandable units with
  # automatic unit conversion
  conversions=data.frame(
    PPORRESU=c("(mg/kg)/(hr*ng/mL)", "(mg/kg)/(ng/mL)"),
    PPSTRESU=c("mL/hr/kg", "mL/kg")
  )
)
pknca_units_table(
  concu="mg/L", doseu="mg/kg", amountu="mg", timeu="hr",
  # Convert clearance and volume units to molar units (assuming
  conversions=data.frame(
    PPORRESU=c("mg/L", "(mg/kg)/(hr*ng/mL)", "(mg/kg)/(ng/mL)"),
    PPSTRESU=c("mmol/L", "mL/hr/kg", "mL/kg"),
    # Manual conversion of concentration units from ng/mL to mmol/L (assuming
    # a molecular weight of 138.121 g/mol)
    conversion_factor=c(1/138.121, NA, NA)
  )
)

# This will make all time-related parameters use "day" even though the
# original units are "hr"
pknca_units_table(
  concu = "ng/mL", doseu = "mg/kg", timeu = "hr", amountu = "mg",
  timeu_pref = "day"
)
</code></pre>

<hr>
<h2 id='PKNCA.choose.option'>Choose either the value from an option list or the current set value for an
option.</h2><span id='topic+PKNCA.choose.option'></span>

<h3>Description</h3>

<p>Choose either the value from an option list or the current set value for an
option.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PKNCA.choose.option(name, value = NULL, options = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PKNCA.choose.option_+3A_name">name</code></td>
<td>
<p>The option name requested.</p>
</td></tr>
<tr><td><code id="PKNCA.choose.option_+3A_value">value</code></td>
<td>
<p>A value to check for the option (<code>NULL</code> to choose not to check
the value).</p>
</td></tr>
<tr><td><code id="PKNCA.choose.option_+3A_options">options</code></td>
<td>
<p>List of changes to the default PKNCA options (see
<code>PKNCA.options()</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the option first from the <code>options</code> list and if it is
not there then from the current settings.
</p>


<h3>See Also</h3>

<p>Other PKNCA calculation and summary settings: 
<code><a href="#topic+PKNCA.options">PKNCA.options</a>()</code>,
<code><a href="#topic+PKNCA.set.summary">PKNCA.set.summary</a>()</code>
</p>

<hr>
<h2 id='PKNCA.options'>Set default options for PKNCA functions</h2><span id='topic+PKNCA.options'></span>

<h3>Description</h3>

<p>This function will set the default PKNCA options.  If given no inputs, it
will provide the current option set.  If given name/value pairs, it will set
the option (as in the <code><a href="base.html#topic+options">options()</a></code> function).  If given a name, it will return
the value for the parameter.  If given the <code>default</code> option as true, it will
provide the default options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PKNCA.options(..., default = FALSE, check = FALSE, name, value)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PKNCA.options_+3A_...">...</code></td>
<td>
<p>options to set or get the value for</p>
</td></tr>
<tr><td><code id="PKNCA.options_+3A_default">default</code></td>
<td>
<p>(re)sets all default options</p>
</td></tr>
<tr><td><code id="PKNCA.options_+3A_check">check</code></td>
<td>
<p>check a single option given, but do not set it (for validation
of the values when used in another function)</p>
</td></tr>
<tr><td><code id="PKNCA.options_+3A_name">name</code></td>
<td>
<p>An option name to use with the <code>value</code>.</p>
</td></tr>
<tr><td><code id="PKNCA.options_+3A_value">value</code></td>
<td>
<p>An option value (paired with the <code>name</code>) to set or check (if
<code>NULL</code>, ).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Options are either for calculation or summary functions. Calculation options
are required for a calculation function to report a result (otherwise the
reported value will be <code>NA</code>). Summary options are used during summarization
and are used for assessing what values are included in the summary.
</p>
<p>See the vignette 'Options for Controlling PKNCA' for a current list of
options (<code>vignette("Options-for-Controlling-PKNCA", package="PKNCA")</code>).
</p>


<h3>Value</h3>

<p>If...
</p>

<dl>
<dt>no arguments are given</dt><dd><p>returns the current options.</p>
</dd>
<dt>a value is set (including the defaults)</dt><dd><p>returns <code>NULL</code></p>
</dd>
<dt>a single value is requested</dt><dd><p>the current value of that option is returned as a scalar</p>
</dd>
<dt>multiple values are requested</dt><dd><p>the current values of those options are returned as a list</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+PKNCA.options.describe">PKNCA.options.describe()</a></code>
</p>
<p>Other PKNCA calculation and summary settings: 
<code><a href="#topic+PKNCA.choose.option">PKNCA.choose.option</a>()</code>,
<code><a href="#topic+PKNCA.set.summary">PKNCA.set.summary</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
PKNCA.options()
PKNCA.options(default=TRUE)
PKNCA.options("auc.method")
PKNCA.options(name="auc.method")
PKNCA.options(auc.method="lin up/log down", min.hl.points=3)
</code></pre>

<hr>
<h2 id='PKNCA.options.describe'>Describe a PKNCA.options option by name.</h2><span id='topic+PKNCA.options.describe'></span>

<h3>Description</h3>

<p>Describe a PKNCA.options option by name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PKNCA.options.describe(name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PKNCA.options.describe_+3A_name">name</code></td>
<td>
<p>The option name requested.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string of the description.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PKNCA.options">PKNCA.options()</a></code>
</p>

<hr>
<h2 id='PKNCA.set.summary'>Define how NCA parameters are summarized.</h2><span id='topic+PKNCA.set.summary'></span>

<h3>Description</h3>

<p>Define how NCA parameters are summarized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PKNCA.set.summary(
  name,
  description,
  point,
  spread,
  rounding = list(signif = 3),
  reset = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PKNCA.set.summary_+3A_name">name</code></td>
<td>
<p>The parameter name or a vector of parameter names.  It must have
already been defined (see <code><a href="#topic+add.interval.col">add.interval.col()</a></code>).</p>
</td></tr>
<tr><td><code id="PKNCA.set.summary_+3A_description">description</code></td>
<td>
<p>A single-line description of the summary</p>
</td></tr>
<tr><td><code id="PKNCA.set.summary_+3A_point">point</code></td>
<td>
<p>The function to calculate the point estimate for the summary.
The function will be called as <code>point(x)</code> and must return a scalar value
(typically a number, NA, or a string).</p>
</td></tr>
<tr><td><code id="PKNCA.set.summary_+3A_spread">spread</code></td>
<td>
<p>Optional.  The function to calculate the spread (or
variability).  The function will be called as <code>spread(x)</code> and must return a
scalar or two-long vector (typically a number, NA, or a string).</p>
</td></tr>
<tr><td><code id="PKNCA.set.summary_+3A_rounding">rounding</code></td>
<td>
<p>Instructions for how to round the value of point and spread.
It may either be a list or a function.  If it is a list, then it must have
a single entry with a name of either &quot;signif&quot; or &quot;round&quot; and a value of the
digits to round.  If a function, it is expected to return a scalar number
or character string with the correct results for an input of either a
scalar or a two-long vector.</p>
</td></tr>
<tr><td><code id="PKNCA.set.summary_+3A_reset">reset</code></td>
<td>
<p>Reset all the summary instructions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>All current summary settings (invisibly)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.PKNCAresults">summary.PKNCAresults()</a></code>
</p>
<p>Other PKNCA calculation and summary settings: 
<code><a href="#topic+PKNCA.choose.option">PKNCA.choose.option</a>()</code>,
<code><a href="#topic+PKNCA.options">PKNCA.options</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
PKNCA.set.summary(
  name="half.life",
  description="arithmetic mean and standard deviation",
  point=business.mean,
  spread=business.sd,
  rounding=list(signif=3)
)

## End(Not run)
</code></pre>

<hr>
<h2 id='PKNCAconc'>Create a PKNCAconc object</h2><span id='topic+PKNCAconc'></span><span id='topic+PKNCAconc.default'></span><span id='topic+PKNCAconc.tbl_df'></span><span id='topic+PKNCAconc.data.frame'></span>

<h3>Description</h3>

<p>Create a PKNCAconc object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PKNCAconc(data, ...)

## Default S3 method:
PKNCAconc(data, ...)

## S3 method for class 'tbl_df'
PKNCAconc(data, ...)

## S3 method for class 'data.frame'
PKNCAconc(
  data,
  formula,
  subject,
  time.nominal,
  exclude,
  duration,
  volume,
  exclude_half.life,
  include_half.life,
  sparse = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PKNCAconc_+3A_data">data</code></td>
<td>
<p>A data frame with concentration (or amount for urine/feces),
time, and the groups defined in <code>formula</code>.</p>
</td></tr>
<tr><td><code id="PKNCAconc_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="PKNCAconc_+3A_formula">formula</code></td>
<td>
<p>The formula defining the <code>concentration~time|groups</code> or
<code>amount~time|groups</code> for urine/feces (In the remainder of the
documentation, &quot;concentration&quot; will be used to describe concentration or
amount.)  One special aspect of the <code>groups</code> part of the formula is that
the last group is typically assumed to be the <code>subject</code>; see the
documentation for the <code>subject</code> argument for exceptions to this assumption.</p>
</td></tr>
<tr><td><code id="PKNCAconc_+3A_subject">subject</code></td>
<td>
<p>The column indicating the subject number.  If not provided,
this defaults to the beginning of the inner groups: For example with
<code>concentration~time|Study+Subject/Analyte</code>, the inner groups start with the
first grouping variable before a <code>/</code>, <code>Subject</code>.  If there is only one
grouping variable, it is assumed to be the subject (e.g.
<code>concentration~time|Subject</code>), and if there are multiple grouping variables
without a <code>/</code>, subject is assumed to be the last one.  For single-subject
data, it is assigned as <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="PKNCAconc_+3A_time.nominal">time.nominal</code></td>
<td>
<p>(optional) The name of the nominal time column (if the
main time variable is actual time.  The <code>time.nominal</code> is not used during
calculations; it is available to assist with data summary and checking.</p>
</td></tr>
<tr><td><code id="PKNCAconc_+3A_exclude">exclude</code></td>
<td>
<p>(optional) The name of a column with concentrations to exclude
from calculations and summarization.  If given, the column should have
values of <code>NA</code> or <code>""</code> for concentrations to include and non-empty text for
concentrations to exclude.</p>
</td></tr>
<tr><td><code id="PKNCAconc_+3A_duration">duration</code></td>
<td>
<p>(optional) The duration of collection as is typically used
for concentration measurements in urine or feces.</p>
</td></tr>
<tr><td><code id="PKNCAconc_+3A_volume">volume</code></td>
<td>
<p>(optional) The volume (or mass) of collection as is typically
used for urine or feces measurements.</p>
</td></tr>
<tr><td><code id="PKNCAconc_+3A_exclude_half.life">exclude_half.life</code>, <code id="PKNCAconc_+3A_include_half.life">include_half.life</code></td>
<td>
<p>A character scalar for the column
name in the dataset of the points to exclude from the half-life calculation
(still using normal curve-stripping selection rules for the other points)
or to include for the half-life (using specifically those points and
bypassing automatic curve-stripping point selection).  See the &quot;Half-Life
Calculation&quot; vignette for more details on the use of these arguments.</p>
</td></tr>
<tr><td><code id="PKNCAconc_+3A_sparse">sparse</code></td>
<td>
<p>Are the concentration-time data sparse PK (commonly used in
small nonclinical species or with terminal or difficult sampling) or dense
PK (commonly used in clinical studies or larger nonclinical species)?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A PKNCAconc object that can be used for automated NCA.
</p>


<h3>See Also</h3>

<p>Other PKNCA objects: 
<code><a href="#topic+PKNCAdata">PKNCAdata</a>()</code>,
<code><a href="#topic+PKNCAdose">PKNCAdose</a>()</code>,
<code><a href="#topic+PKNCAresults">PKNCAresults</a>()</code>
</p>

<hr>
<h2 id='PKNCAdata'>Create a PKNCAdata object.</h2><span id='topic+PKNCAdata'></span><span id='topic+PKNCAdata.PKNCAconc'></span><span id='topic+PKNCAdata.PKNCAdose'></span><span id='topic+PKNCAdata.default'></span>

<h3>Description</h3>

<p><code>PKNCAdata()</code> combines <code>PKNCAconc</code> and <code>PKNCAdose</code> objects and adds in the
intervals for PK calculations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PKNCAdata(data.conc, data.dose, ...)

## S3 method for class 'PKNCAconc'
PKNCAdata(data.conc, data.dose, ...)

## S3 method for class 'PKNCAdose'
PKNCAdata(data.conc, data.dose, ...)

## Default S3 method:
PKNCAdata(
  data.conc,
  data.dose,
  ...,
  formula.conc,
  formula.dose,
  impute = NA_character_,
  intervals,
  units,
  options = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PKNCAdata_+3A_data.conc">data.conc</code></td>
<td>
<p>Concentration data as a <code>PKNCAconc</code> object or a data frame</p>
</td></tr>
<tr><td><code id="PKNCAdata_+3A_data.dose">data.dose</code></td>
<td>
<p>Dosing data as a <code>PKNCAdose</code> object (see details)</p>
</td></tr>
<tr><td><code id="PKNCAdata_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>PKNCAdata.default</code></p>
</td></tr>
<tr><td><code id="PKNCAdata_+3A_formula.conc">formula.conc</code></td>
<td>
<p>Formula for making a <code>PKNCAconc</code> object with <code>data.conc</code>.
This must be given if <code>data.conc</code> is a data.frame, and it must not be given
if <code>data.conc</code> is a <code>PKNCAconc</code> object.</p>
</td></tr>
<tr><td><code id="PKNCAdata_+3A_formula.dose">formula.dose</code></td>
<td>
<p>Formula for making a <code>PKNCAdose</code> object with <code>data.dose</code>.
This must be given if <code>data.dose</code> is a data.frame, and it must not be given
if <code>data.dose</code> is a <code>PKNCAdose</code> object.</p>
</td></tr>
<tr><td><code id="PKNCAdata_+3A_impute">impute</code></td>
<td>
<p>Methods for imputation.  <code>NA</code> for to search for the column
named &quot;impute&quot; in the intervals or no imputation if that column does not
exist, a comma-or space-separated list of names, or the name of a column in
the <code>intervals</code> data.frame.  See
<code>vignette("v08-data-imputation", package="PKNCA")</code> for more details.</p>
</td></tr>
<tr><td><code id="PKNCAdata_+3A_intervals">intervals</code></td>
<td>
<p>A data frame with the AUC interval specifications as defined
in <code><a href="#topic+check.interval.specification">check.interval.specification()</a></code>.  If missing, this will be
automatically chosen by <code><a href="#topic+choose.auc.intervals">choose.auc.intervals()</a></code>. (see details)</p>
</td></tr>
<tr><td><code id="PKNCAdata_+3A_units">units</code></td>
<td>
<p>A data.frame of unit assignments and conversions as created by
<code><a href="#topic+pknca_units_table">pknca_units_table()</a></code></p>
</td></tr>
<tr><td><code id="PKNCAdata_+3A_options">options</code></td>
<td>
<p>List of changes to the default PKNCA options (see
<code>PKNCA.options()</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>data.dose</code> is not given or is <code>NA</code>, then the <code>intervals</code> must be
given.  At least one of <code>data.dose</code> and <code>intervals</code> must be given.
</p>


<h3>Value</h3>

<p>A PKNCAdata object with concentration, dose, interval, and
calculation options stored (note that PKNCAdata objects can also have
results after a NCA calculations are done to the data).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+choose.auc.intervals">choose.auc.intervals()</a></code>, <code><a href="#topic+pk.nca">pk.nca()</a></code>, <code><a href="#topic+pknca_units_table">pknca_units_table()</a></code>
</p>
<p>Other PKNCA objects: 
<code><a href="#topic+PKNCAconc">PKNCAconc</a>()</code>,
<code><a href="#topic+PKNCAdose">PKNCAdose</a>()</code>,
<code><a href="#topic+PKNCAresults">PKNCAresults</a>()</code>
</p>

<hr>
<h2 id='PKNCAdose'>Create a PKNCAdose object</h2><span id='topic+PKNCAdose'></span><span id='topic+PKNCAdose.default'></span><span id='topic+PKNCAdose.tbl_df'></span><span id='topic+PKNCAdose.data.frame'></span>

<h3>Description</h3>

<p>Create a PKNCAdose object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PKNCAdose(data, ...)

## Default S3 method:
PKNCAdose(data, ...)

## S3 method for class 'tbl_df'
PKNCAdose(data, ...)

## S3 method for class 'data.frame'
PKNCAdose(data, formula, route, rate, duration, time.nominal, exclude, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PKNCAdose_+3A_data">data</code></td>
<td>
<p>A data frame with time and the groups defined in <code>formula</code>.</p>
</td></tr>
<tr><td><code id="PKNCAdose_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="PKNCAdose_+3A_formula">formula</code></td>
<td>
<p>The formula defining the <code>dose.amount~time|groups</code> where
<code>time</code> is the time of the dosing and <code>dose.amount</code> is the amount
administered at that time (see Details).</p>
</td></tr>
<tr><td><code id="PKNCAdose_+3A_route">route</code></td>
<td>
<p>Define the route of administration.  The value may be either a
column name from the <code>data</code> (checked first) or a character string of either
<code>"extravascular"</code> or <code>"intravascular"</code> (checked second).  If given as a
column name, then every value of the column must be either
<code>"extravascular"</code> or <code>"intravascular"</code>.</p>
</td></tr>
<tr><td><code id="PKNCAdose_+3A_rate">rate</code>, <code id="PKNCAdose_+3A_duration">duration</code></td>
<td>
<p>(optional) for <code>"intravascular"</code> dosing, the rate or
duration of dosing.  If given as a character string, it is the name of a
column from the <code>data</code>, and if given as a number, it is the value for all
doses.  Only one may be given, and if neither is given, then the dose is
assumed to be a bolus (<code>duration=0</code>).  If <code>rate</code> is given, then the dose
amount must be given (the left hand side of the <code>formula</code>).</p>
</td></tr>
<tr><td><code id="PKNCAdose_+3A_time.nominal">time.nominal</code></td>
<td>
<p>(optional) The name of the nominal time column (if the
main time variable is actual time.  The <code>time.nominal</code> is not used during
calculations; it is available to assist with data summary and checking.</p>
</td></tr>
<tr><td><code id="PKNCAdose_+3A_exclude">exclude</code></td>
<td>
<p>(optional) The name of a column with concentrations to exclude
from calculations and summarization.  If given, the column should have
values of <code>NA</code> or <code>""</code> for concentrations to include and non-empty text for
concentrations to exclude.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>formula</code> for a <code>PKNCAdose</code> object can be
given three ways: one-sided (missing left side), one-sided (missing
right side), or two-sided.  Each of the three ways can be given
with or without groups.  When given one-sided missing the left
side, the left side can either be omitted or can be given as a
period (<code>.</code>): <code>~time|treatment+subject</code> and
<code>.~time|treatment+subject</code> are identical, and dose-related NCA
parameters will all be reported as not calculable (for example,
clearance).  When given one-sided missing the right side, the right
side must be specified as a period (<code>.</code>):
<code>dose~.|treatment+subject</code>, and only a single row may be given
per group.  When the right side is missing, PKNCA assumes that the
same dose is given in every interval.  When given as a two-sided
formula
</p>


<h3>Value</h3>

<p>A PKNCAconc object that can be used for automated NCA.
</p>


<h3>See Also</h3>

<p>Other PKNCA objects: 
<code><a href="#topic+PKNCAconc">PKNCAconc</a>()</code>,
<code><a href="#topic+PKNCAdata">PKNCAdata</a>()</code>,
<code><a href="#topic+PKNCAresults">PKNCAresults</a>()</code>
</p>

<hr>
<h2 id='PKNCAresults'>Generate a PKNCAresults object</h2><span id='topic+PKNCAresults'></span>

<h3>Description</h3>

<p>This function should not be run directly.  The object is created for
summarization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PKNCAresults(result, data, exclude)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PKNCAresults_+3A_result">result</code></td>
<td>
<p>a data frame with NCA calculation results and groups. Each row
is one interval and each column is a group name or the name of an NCA
parameter.</p>
</td></tr>
<tr><td><code id="PKNCAresults_+3A_data">data</code></td>
<td>
<p>The PKNCAdata used to generate the result</p>
</td></tr>
<tr><td><code id="PKNCAresults_+3A_exclude">exclude</code></td>
<td>
<p>(optional) The name of a column with concentrations to exclude
from calculations and summarization.  If given, the column should have
values of <code>NA</code> or <code>""</code> for concentrations to include and non-empty text for
concentrations to exclude.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A PKNCAresults object with each of the above within.
</p>


<h3>See Also</h3>

<p>Other PKNCA objects: 
<code><a href="#topic+PKNCAconc">PKNCAconc</a>()</code>,
<code><a href="#topic+PKNCAdata">PKNCAdata</a>()</code>,
<code><a href="#topic+PKNCAdose">PKNCAdose</a>()</code>
</p>

<hr>
<h2 id='print.PKNCAconc'>Print and/or summarize a PKNCAconc or PKNCAdose object.</h2><span id='topic+print.PKNCAconc'></span><span id='topic+summary.PKNCAconc'></span><span id='topic+print.PKNCAdose'></span><span id='topic+summary.PKNCAdose'></span>

<h3>Description</h3>

<p>Print and/or summarize a PKNCAconc or PKNCAdose object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PKNCAconc'
print(x, n = 6, summarize = FALSE, ...)

## S3 method for class 'PKNCAconc'
summary(object, n = 0, summarize = TRUE, ...)

## S3 method for class 'PKNCAdose'
print(x, n = 6, summarize = FALSE, ...)

## S3 method for class 'PKNCAdose'
summary(object, n = 0, summarize = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.PKNCAconc_+3A_x">x</code></td>
<td>
<p>The object to print</p>
</td></tr>
<tr><td><code id="print.PKNCAconc_+3A_n">n</code></td>
<td>
<p>The number of rows of data to show (see
<code><a href="utils.html#topic+head">head()</a></code>)</p>
</td></tr>
<tr><td><code id="print.PKNCAconc_+3A_summarize">summarize</code></td>
<td>
<p>Summarize the nested number of groups</p>
</td></tr>
<tr><td><code id="print.PKNCAconc_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>print.formula</code> and
<code>print.data.frame</code></p>
</td></tr>
<tr><td><code id="print.PKNCAconc_+3A_object">object</code></td>
<td>
<p>The object to summarize</p>
</td></tr>
</table>

<hr>
<h2 id='print.PKNCAdata'>Print a PKNCAdata object</h2><span id='topic+print.PKNCAdata'></span>

<h3>Description</h3>

<p>Print a PKNCAdata object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PKNCAdata'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.PKNCAdata_+3A_x">x</code></td>
<td>
<p>The object to print</p>
</td></tr>
<tr><td><code id="print.PKNCAdata_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code><a href="#topic+print.PKNCAconc">print.PKNCAconc()</a></code> and <code><a href="#topic+print.PKNCAdose">print.PKNCAdose()</a></code></p>
</td></tr>
</table>

<hr>
<h2 id='print.provenance'>Print the summary of a provenance object</h2><span id='topic+print.provenance'></span>

<h3>Description</h3>

<p>Print the summary of a provenance object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'provenance'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.provenance_+3A_x">x</code></td>
<td>
<p>The object to be printed</p>
</td></tr>
<tr><td><code id="print.provenance_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisible text of the printed information
</p>

<hr>
<h2 id='print.summary_PKNCAresults'>Print the results summary</h2><span id='topic+print.summary_PKNCAresults'></span>

<h3>Description</h3>

<p>Print the results summary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary_PKNCAresults'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.summary_PKNCAresults_+3A_x">x</code></td>
<td>
<p>A summary_PKNCAresults object</p>
</td></tr>
<tr><td><code id="print.summary_PKNCAresults_+3A_...">...</code></td>
<td>
<p>passed to print.data.frame (<code>row.names</code> is always set to <code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> invisibly
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.PKNCAresults">summary.PKNCAresults()</a></code>
</p>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+getGroups'></span><span id='topic+inner_join'></span><span id='topic+left_join'></span><span id='topic+right_join'></span><span id='topic+full_join'></span><span id='topic+filter'></span><span id='topic+group_by'></span><span id='topic+ungroup'></span><span id='topic+mutate'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>dplyr</dt><dd><p><code><a href="dplyr.html#topic+filter">filter</a></code>, <code><a href="dplyr.html#topic+mutate-joins">full_join</a></code>, <code><a href="dplyr.html#topic+group_by">group_by</a></code>, <code><a href="dplyr.html#topic+mutate-joins">inner_join</a></code>, <code><a href="dplyr.html#topic+mutate-joins">left_join</a></code>, <code><a href="dplyr.html#topic+mutate">mutate</a></code>, <code><a href="dplyr.html#topic+mutate-joins">right_join</a></code>, <code><a href="dplyr.html#topic+group_by">ungroup</a></code></p>
</dd>
<dt>nlme</dt><dd><p><code><a href="nlme.html#topic+getGroups">getGroups</a></code></p>
</dd>
</dl>

<hr>
<h2 id='roundingSummarize'>During the summarization of PKNCAresults, do the rounding of values
based on the instructions given.</h2><span id='topic+roundingSummarize'></span>

<h3>Description</h3>

<p>During the summarization of PKNCAresults, do the rounding of values
based on the instructions given.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roundingSummarize(x, name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="roundingSummarize_+3A_x">x</code></td>
<td>
<p>The values to summarize</p>
</td></tr>
<tr><td><code id="roundingSummarize_+3A_name">name</code></td>
<td>
<p>The NCA parameter name (matching a parameter name in
<code><a href="#topic+PKNCA.set.summary">PKNCA.set.summary()</a></code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string of the rounded value
</p>

<hr>
<h2 id='roundString'>Round a value to a defined number of digits printing out trailing zeros, if
applicable.</h2><span id='topic+roundString'></span>

<h3>Description</h3>

<p>Round a value to a defined number of digits printing out trailing zeros, if
applicable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roundString(x, digits = 0, sci_range = Inf, sci_sep = "e", si_range)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="roundString_+3A_x">x</code></td>
<td>
<p>The number to round</p>
</td></tr>
<tr><td><code id="roundString_+3A_digits">digits</code></td>
<td>
<p>integer indicating the number of decimal places</p>
</td></tr>
<tr><td><code id="roundString_+3A_sci_range">sci_range</code></td>
<td>
<p>See help for <code><a href="#topic+signifString">signifString()</a></code> (and you likely want
to round with <code>signifString</code> if you want to use this argument)</p>
</td></tr>
<tr><td><code id="roundString_+3A_sci_sep">sci_sep</code></td>
<td>
<p>The separator to use for scientific notation strings
(typically this will be either &quot;e&quot; or &quot;x10^&quot; for computer- or
human-readable output).</p>
</td></tr>
<tr><td><code id="roundString_+3A_si_range">si_range</code></td>
<td>
<p>Deprecated, please use <code>sci_range</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Values that are not standard numbers like <code>Inf</code>, <code>NA</code>, and
<code>NaN</code> are returned as <code>"Inf"</code>, <code>"NA"</code>, and <code>NaN</code>.
</p>


<h3>Value</h3>

<p>A string with the value
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+round">round()</a></code>, <code><a href="#topic+signifString">signifString()</a></code>
</p>

<hr>
<h2 id='setAttributeColumn'>Add an attribute to an object where the attribute is added as a name
to the names of the object.</h2><span id='topic+setAttributeColumn'></span>

<h3>Description</h3>

<p>Add an attribute to an object where the attribute is added as a name
to the names of the object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setAttributeColumn(
  object,
  attr_name,
  col_or_value,
  col_name,
  default_value,
  stop_if_default,
  warn_if_default,
  message_if_default
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setAttributeColumn_+3A_object">object</code></td>
<td>
<p>The object to set the attribute column on.</p>
</td></tr>
<tr><td><code id="setAttributeColumn_+3A_attr_name">attr_name</code></td>
<td>
<p>The attribute name to set</p>
</td></tr>
<tr><td><code id="setAttributeColumn_+3A_col_or_value">col_or_value</code></td>
<td>
<p>If this exists as a column in the data, it is used as the
<code>col_name</code>.  If not, this becomes the <code>default_value</code>.</p>
</td></tr>
<tr><td><code id="setAttributeColumn_+3A_col_name">col_name</code></td>
<td>
<p>The name of the column within the dataset to use (if missing,
uses <code>attr_name</code>)</p>
</td></tr>
<tr><td><code id="setAttributeColumn_+3A_default_value">default_value</code></td>
<td>
<p>The value to fill in the column if the column does not
exist (the column is filled with <code>NA</code> if it does not exist and no value is
provided).</p>
</td></tr>
<tr><td><code id="setAttributeColumn_+3A_stop_if_default">stop_if_default</code>, <code id="setAttributeColumn_+3A_warn_if_default">warn_if_default</code>, <code id="setAttributeColumn_+3A_message_if_default">message_if_default</code></td>
<td>
<p>A character string
to provide as an error, a warning, or a message to the user if the
<code>default_value</code> is used.  They are tested in order (if stop, the code
stops; if warning, the message is ignored; and message last).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The object with the attribute column added to the data.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getAttributeColumn">getAttributeColumn()</a></code>
</p>

<hr>
<h2 id='setDuration.PKNCAconc'>Set the duration of dosing or measurement</h2><span id='topic+setDuration.PKNCAconc'></span><span id='topic+setDuration'></span><span id='topic+setDuration.PKNCAdose'></span>

<h3>Description</h3>

<p>Set the duration of dosing or measurement
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PKNCAconc'
setDuration(object, duration, ...)

setDuration(object, ...)

## S3 method for class 'PKNCAdose'
setDuration(object, duration, rate, dose, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setDuration.PKNCAconc_+3A_object">object</code></td>
<td>
<p>An object to set a duration on</p>
</td></tr>
<tr><td><code id="setDuration.PKNCAconc_+3A_duration">duration</code></td>
<td>
<p>The value to set for the duration or the name of the column
in the data to use for the duration.</p>
</td></tr>
<tr><td><code id="setDuration.PKNCAconc_+3A_...">...</code></td>
<td>
<p>Arguments passed to another setDuration function</p>
</td></tr>
<tr><td><code id="setDuration.PKNCAconc_+3A_rate">rate</code></td>
<td>
<p>(for PKNCAdose objects only) The rate of infusion</p>
</td></tr>
<tr><td><code id="setDuration.PKNCAconc_+3A_dose">dose</code></td>
<td>
<p>(for PKNCAdose objects only) The dose amount</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The object with duration set
</p>

<hr>
<h2 id='setExcludeColumn'>Set the exclude parameter on an object</h2><span id='topic+setExcludeColumn'></span>

<h3>Description</h3>

<p>This function adds the exclude column to an object.  To change the
exclude value, use the <code><a href="#topic+exclude">exclude()</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setExcludeColumn(object, exclude, dataname = "data")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setExcludeColumn_+3A_object">object</code></td>
<td>
<p>The object to set the exclude column on.</p>
</td></tr>
<tr><td><code id="setExcludeColumn_+3A_exclude">exclude</code></td>
<td>
<p>The column name to set as the exclude value.</p>
</td></tr>
<tr><td><code id="setExcludeColumn_+3A_dataname">dataname</code></td>
<td>
<p>The name of the data.frame within the object to add the
exclude column to.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The object with an exclude column and attribute
</p>

<hr>
<h2 id='setRoute'>Set the dosing route</h2><span id='topic+setRoute'></span><span id='topic+setRoute.PKNCAdose'></span>

<h3>Description</h3>

<p>Set the dosing route
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setRoute(object, ...)

## S3 method for class 'PKNCAdose'
setRoute(object, route, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setRoute_+3A_object">object</code></td>
<td>
<p>A PKNCAdose object</p>
</td></tr>
<tr><td><code id="setRoute_+3A_...">...</code></td>
<td>
<p>Arguments passed to another setRoute function</p>
</td></tr>
<tr><td><code id="setRoute_+3A_route">route</code></td>
<td>
<p>A character string indicating one of the following:  the column
from the data which indicates the route of administration, a scalar
indicating the route of administration for all subjects, or a vector
indicating the route of administration for each dose in the dataset.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The object with an updated route
</p>

<hr>
<h2 id='signifString'>Round a value to a defined number of significant digits printing out trailing
zeros, if applicable.</h2><span id='topic+signifString'></span><span id='topic+signifString.data.frame'></span><span id='topic+signifString.default'></span>

<h3>Description</h3>

<p>Round a value to a defined number of significant digits printing out trailing
zeros, if applicable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signifString(x, ...)

## S3 method for class 'data.frame'
signifString(x, ...)

## Default S3 method:
signifString(x, digits = 6, sci_range = 6, sci_sep = "e", si_range, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="signifString_+3A_x">x</code></td>
<td>
<p>The number to round</p>
</td></tr>
<tr><td><code id="signifString_+3A_...">...</code></td>
<td>
<p>Arguments passed to methods.</p>
</td></tr>
<tr><td><code id="signifString_+3A_digits">digits</code></td>
<td>
<p>integer indicating the number of significant digits</p>
</td></tr>
<tr><td><code id="signifString_+3A_sci_range">sci_range</code></td>
<td>
<p>integer (or <code>Inf</code>) indicating when to switch to
scientific notation instead of floating point. Zero indicates always use
scientific; <code>Inf</code> indicates to never use scientific notation;
otherwise, scientific notation is used when <code>abs(log10(x)) &gt; si_range</code>.</p>
</td></tr>
<tr><td><code id="signifString_+3A_sci_sep">sci_sep</code></td>
<td>
<p>The separator to use for scientific notation strings
(typically this will be either &quot;e&quot; or &quot;x10^&quot; for computer- or
human-readable output).</p>
</td></tr>
<tr><td><code id="signifString_+3A_si_range">si_range</code></td>
<td>
<p>Deprecated, please use <code>sci_range</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Values that are not standard numbers like <code>Inf</code>, <code>NA</code>, and
<code>NaN</code> are returned as <code>"Inf"</code>, <code>"NA"</code>, and <code>NaN</code>.
</p>


<h3>Value</h3>

<p>A string with the value
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+signif">signif()</a></code>, <code><a href="#topic+roundString">roundString()</a></code>
</p>

<hr>
<h2 id='sort.interval.cols'>Sort the interval columns by dependencies.</h2><span id='topic+sort.interval.cols'></span>

<h3>Description</h3>

<p>Columns are always to the right of columns that they depend on.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'interval.cols'
sort()
</code></pre>

<hr>
<h2 id='sparse_auc_weight_linear'>Calculate the weight for sparse AUC calculation with the linear-trapezoidal
rule</h2><span id='topic+sparse_auc_weight_linear'></span>

<h3>Description</h3>

<p>The weight is used as the <code class="reqn">w_i</code> parameter in <code><a href="#topic+pk.calc.sparse_auc">pk.calc.sparse_auc()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparse_auc_weight_linear(sparse_pk)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sparse_auc_weight_linear_+3A_sparse_pk">sparse_pk</code></td>
<td>
<p>A sparse_pk object from <code><a href="#topic+as_sparse_pk">as_sparse_pk()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">w_i = \frac{\delta_{time,i-1,i} + \delta_{time,i,i+1}}{2}</code>
</p>

<p style="text-align: center;"><code class="reqn">\delta_{time,i,i+1} = t_{i+1} - t_i</code>
</p>

<p>Where:
</p>

<dl>
<dt><code class="reqn">w_i</code></dt><dd><p>is the weight at time i</p>
</dd>
<dt><code class="reqn">\delta_{time,i-1,i}</code> and <code class="reqn">\delta_{time,i,i+1}</code></dt><dd><p>are the changes between time i-1 and i or i and i+1 (zero outside of the time range)</p>
</dd>
<dt><code class="reqn">t_i</code></dt><dd><p>is the time at time i</p>
</dd>
</dl>



<h3>Value</h3>

<p>A numeric vector of weights for sparse AUC calculations the same
length as <code>sparse_pk</code>
</p>


<h3>See Also</h3>

<p>Other Sparse Methods: 
<code><a href="#topic+as_sparse_pk">as_sparse_pk</a>()</code>,
<code><a href="#topic+pk.calc.sparse_auc">pk.calc.sparse_auc</a>()</code>,
<code><a href="#topic+sparse_mean">sparse_mean</a>()</code>
</p>

<hr>
<h2 id='sparse_mean'>Calculate the mean concentration at all time points for use in sparse NCA
calculations</h2><span id='topic+sparse_mean'></span>

<h3>Description</h3>

<p>Choices for the method of calculation (the argument <code>sparse_mean_method</code>)
are:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparse_mean(
  sparse_pk,
  sparse_mean_method = c("arithmetic mean, &lt;=50% BLQ", "arithmetic mean")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sparse_mean_+3A_sparse_pk">sparse_pk</code></td>
<td>
<p>A sparse_pk object from <code><a href="#topic+as_sparse_pk">as_sparse_pk()</a></code></p>
</td></tr>
<tr><td><code id="sparse_mean_+3A_sparse_mean_method">sparse_mean_method</code></td>
<td>
<p>The method used to calculate the sparse mean (see
details)</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt>&quot;arithmetic mean&quot;</dt><dd><p>Arithmetic mean (ignoring number of BLQ samples)</p>
</dd>
<dt>&quot;arithmetic mean, &lt;=50% BLQ&quot;</dt><dd><p>If &gt;= 50% of the measurements are BLQ, zero.  Otherwise, the arithmetic mean of all samples (including the BLQ as zero).</p>
</dd>
</dl>



<h3>Value</h3>

<p>A vector the same length as <code>sparse_pk</code> with the mean concentration
at each of those times.
</p>


<h3>See Also</h3>

<p>Other Sparse Methods: 
<code><a href="#topic+as_sparse_pk">as_sparse_pk</a>()</code>,
<code><a href="#topic+pk.calc.sparse_auc">pk.calc.sparse_auc</a>()</code>,
<code><a href="#topic+sparse_auc_weight_linear">sparse_auc_weight_linear</a>()</code>
</p>

<hr>
<h2 id='sparse_pk_attribute'>Set or get a sparse_pk object attribute</h2><span id='topic+sparse_pk_attribute'></span>

<h3>Description</h3>

<p>Set or get a sparse_pk object attribute
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparse_pk_attribute(sparse_pk, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sparse_pk_attribute_+3A_sparse_pk">sparse_pk</code></td>
<td>
<p>A sparse_pk object from <code><a href="#topic+as_sparse_pk">as_sparse_pk()</a></code></p>
</td></tr>
<tr><td><code id="sparse_pk_attribute_+3A_...">...</code></td>
<td>
<p>Either a character string (to get that value) or a named vector
the same length as <code>sparse_pk</code> to set the value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either the attribute value or an updated <code>sparse_pk</code> object
</p>

<hr>
<h2 id='sparse_to_dense_pk'>Extract the mean concentration-time profile as a data.frame</h2><span id='topic+sparse_to_dense_pk'></span>

<h3>Description</h3>

<p>Extract the mean concentration-time profile as a data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparse_to_dense_pk(sparse_pk)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sparse_to_dense_pk_+3A_sparse_pk">sparse_pk</code></td>
<td>
<p>A sparse_pk object from <code><a href="#topic+as_sparse_pk">as_sparse_pk()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with names of &quot;conc&quot; and &quot;time&quot;
</p>

<hr>
<h2 id='summary.PKNCAdata'>Summarize a PKNCAdata object showing important details about the
concentration, dosing, and interval information.</h2><span id='topic+summary.PKNCAdata'></span>

<h3>Description</h3>

<p>Summarize a PKNCAdata object showing important details about the
concentration, dosing, and interval information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PKNCAdata'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.PKNCAdata_+3A_object">object</code></td>
<td>
<p>The PKNCAdata object to summarize.</p>
</td></tr>
<tr><td><code id="summary.PKNCAdata_+3A_...">...</code></td>
<td>
<p>arguments passed on to <code><a href="#topic+print.PKNCAdata">print.PKNCAdata()</a></code></p>
</td></tr>
</table>

<hr>
<h2 id='summary.PKNCAresults'>Summarize PKNCA results</h2><span id='topic+summary.PKNCAresults'></span>

<h3>Description</h3>

<p>Summarize PKNCA results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PKNCAresults'
summary(
  object,
  ...,
  drop_group = object$data$conc$columns$subject,
  drop_param = character(),
  summarize_n = NA,
  not_requested = ".",
  not_calculated = "NC",
  drop.group = deprecated(),
  summarize.n.per.group = deprecated(),
  not.requested.string = deprecated(),
  not.calculated.string = deprecated(),
  pretty_names = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.PKNCAresults_+3A_object">object</code></td>
<td>
<p>The results to summarize</p>
</td></tr>
<tr><td><code id="summary.PKNCAresults_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="summary.PKNCAresults_+3A_drop_group">drop_group</code></td>
<td>
<p>Which group(s) should be dropped from the formula?</p>
</td></tr>
<tr><td><code id="summary.PKNCAresults_+3A_drop_param">drop_param</code></td>
<td>
<p>Which parameters should be excluded from the summary?</p>
</td></tr>
<tr><td><code id="summary.PKNCAresults_+3A_summarize_n">summarize_n</code></td>
<td>
<p>Should a column for <code>N</code> be added (<code>TRUE</code> or <code>FALSE</code>)?
<code>NA</code> means to automatically detect adding <code>N</code> if the data has a subject
column indicated.  Note that <code>N</code> is maximum number of parameter results for
any parameter; if no parameters are requested for a group, then <code>N</code> will be
<code>NA</code>.</p>
</td></tr>
<tr><td><code id="summary.PKNCAresults_+3A_not_requested">not_requested</code></td>
<td>
<p>A character string to use when a parameter summary was
not requested for a parameter within an interval.</p>
</td></tr>
<tr><td><code id="summary.PKNCAresults_+3A_not_calculated">not_calculated</code></td>
<td>
<p>A character string to use when a parameter summary was
requested, but the point estimate AND spread calculations (if applicable)
returned <code>NA</code>.</p>
</td></tr>
<tr><td><code id="summary.PKNCAresults_+3A_drop.group">drop.group</code>, <code id="summary.PKNCAresults_+3A_summarize.n.per.group">summarize.n.per.group</code>, <code id="summary.PKNCAresults_+3A_not.requested.string">not.requested.string</code>, <code id="summary.PKNCAresults_+3A_not.calculated.string">not.calculated.string</code></td>
<td>
<p>Deprecated use <code>drop_group</code>, <code>not_requested</code>, <code>not_calculated</code>, or
<code>summarize_n</code>, instead</p>
</td></tr>
<tr><td><code id="summary.PKNCAresults_+3A_pretty_names">pretty_names</code></td>
<td>
<p>Should pretty names (easier to understand in a report) be
used?  <code>TRUE</code> is yes, <code>FALSE</code> is no, and <code>NULL</code> is yes if units are used
and no if units are not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Excluded results will not be included in the summary.
</p>


<h3>Value</h3>

<p>A data frame of NCA parameter results summarized according to the
summarization settings.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PKNCA.set.summary">PKNCA.set.summary()</a></code>, <code><a href="#topic+print.summary_PKNCAresults">print.summary_PKNCAresults()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>conc_obj &lt;- PKNCAconc(as.data.frame(datasets::Theoph), conc ~ Time | Subject)
d_dose &lt;-
  unique(datasets::Theoph[
    datasets::Theoph$Time == 0,
    c("Dose", "Time", "Subject")
  ])
dose_obj &lt;- PKNCAdose(d_dose, Dose ~ Time | Subject)
data_obj_automatic &lt;- PKNCAdata(conc_obj, dose_obj)
results_obj_automatic &lt;- pk.nca(data_obj_automatic)
# To get standard results run summary
summary(results_obj_automatic)
# To enable numeric conversion and extraction, do not give a spread function
# and subsequently run as.numeric on the result columns.
PKNCA.set.summary(
  name = c("auclast", "cmax", "half.life", "aucinf.obs"),
  point = business.geomean,
  description = "geometric mean"
)
PKNCA.set.summary(
  name = c("tmax"),
  point = business.median,
  description = "median"
)
summary(results_obj_automatic, not_requested = "NA")
</code></pre>

<hr>
<h2 id='superposition'>Compute noncompartmental superposition for repeated dosing</h2><span id='topic+superposition'></span><span id='topic+superposition.PKNCAconc'></span><span id='topic+superposition.numeric'></span>

<h3>Description</h3>

<p>Compute noncompartmental superposition for repeated dosing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>superposition(conc, ...)

## S3 method for class 'PKNCAconc'
superposition(conc, ...)

## S3 method for class 'numeric'
superposition(
  conc,
  time,
  dose.input = NULL,
  tau,
  dose.times = 0,
  dose.amount,
  n.tau = Inf,
  options = list(),
  lambda.z,
  clast.pred = FALSE,
  tlast,
  additional.times = numeric(),
  check.blq = TRUE,
  method = NULL,
  auc.type = "AUCinf",
  steady.state.tol = 0.001,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="superposition_+3A_conc">conc</code></td>
<td>
<p>Measured concentrations</p>
</td></tr>
<tr><td><code id="superposition_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the <code>half.life</code> function if
required to compute <code>lambda.z</code>.</p>
</td></tr>
<tr><td><code id="superposition_+3A_time">time</code></td>
<td>
<p>Time of the measurement of the concentrations</p>
</td></tr>
<tr><td><code id="superposition_+3A_dose.input">dose.input</code></td>
<td>
<p>The dose given to generate the <code>conc</code> and <code>time</code> inputs. If
missing, output doses will be assumed to be equal to the input dose.</p>
</td></tr>
<tr><td><code id="superposition_+3A_tau">tau</code></td>
<td>
<p>The dosing interval</p>
</td></tr>
<tr><td><code id="superposition_+3A_dose.times">dose.times</code></td>
<td>
<p>The time of dosing within the dosing interval. The
<code>min(dose.times)</code> must be &gt;= 0, and the <code>max(dose.times)</code> must be &lt; <code>tau</code>.
There may be more than one dose times given as a vector.</p>
</td></tr>
<tr><td><code id="superposition_+3A_dose.amount">dose.amount</code></td>
<td>
<p>The doses given for the output.  Linear proportionality
will be used from the input to output if they are not equal.  The length of
dose.amount must be either 1 or matching the length of <code>dose.times</code>.</p>
</td></tr>
<tr><td><code id="superposition_+3A_n.tau">n.tau</code></td>
<td>
<p>The number of tau dosing intervals to simulate or <code>Inf</code> for
steady-state.</p>
</td></tr>
<tr><td><code id="superposition_+3A_options">options</code></td>
<td>
<p>List of changes to the default PKNCA options (see
<code>PKNCA.options()</code>)</p>
</td></tr>
<tr><td><code id="superposition_+3A_lambda.z">lambda.z</code></td>
<td>
<p>The elimination rate (in units of inverse time) for
extrapolation</p>
</td></tr>
<tr><td><code id="superposition_+3A_clast.pred">clast.pred</code></td>
<td>
<p>To use predicted as opposed to observed Clast, either give
the value for clast.pred here or set it to true (for automatic calculation
from the half-life).</p>
</td></tr>
<tr><td><code id="superposition_+3A_tlast">tlast</code></td>
<td>
<p>The time of last observed concentration above the limit of
quantification.  This is calculated if not provided.</p>
</td></tr>
<tr><td><code id="superposition_+3A_additional.times">additional.times</code></td>
<td>
<p>Times to include in the final outputs in addition to
the standard times (see details).  All <code>min(additional.times)</code> must be &gt;=
0, and the <code>max(additional.times)</code> must be &lt;= <code>tau</code>.</p>
</td></tr>
<tr><td><code id="superposition_+3A_check.blq">check.blq</code></td>
<td>
<p>Must the first concentration measurement be below the limit
of quantification?</p>
</td></tr>
<tr><td><code id="superposition_+3A_method">method</code></td>
<td>
<p>The method for integration (one of 'lin up/log down',
'lin-log', or 'linear')</p>
</td></tr>
<tr><td><code id="superposition_+3A_auc.type">auc.type</code></td>
<td>
<p>The type of AUC to compute.  Choices are 'AUCinf', 'AUClast',
and 'AUCall'.</p>
</td></tr>
<tr><td><code id="superposition_+3A_steady.state.tol">steady.state.tol</code></td>
<td>
<p>The tolerance for assessing if steady-state has been
achieved (between 0 and 1, exclusive).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The returned superposition times will include all of the following
times: 0 (zero), <code>dose.times</code>, <code style="white-space: pre;">&#8288;time modulo tau&#8288;</code> (shifting <code>time</code> for each
dose time as well), <code>additional.times</code>, and <code>tau</code>.
</p>


<h3>Value</h3>

<p>A data frame with columns named &quot;conc&quot; and &quot;time&quot;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+interp.extrap.conc">interp.extrap.conc()</a></code>
</p>

<hr>
<h2 id='time_calc'>Times relative to an event (typically dosing)</h2><span id='topic+time_calc'></span>

<h3>Description</h3>

<p>Times relative to an event (typically dosing)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_calc(time_event, time_obs, units = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="time_calc_+3A_time_event">time_event</code></td>
<td>
<p>A vector of times for events</p>
</td></tr>
<tr><td><code id="time_calc_+3A_time_obs">time_obs</code></td>
<td>
<p>A vector of times for observations</p>
</td></tr>
<tr><td><code id="time_calc_+3A_units">units</code></td>
<td>
<p>Passed to <code>base::as.numeric.difftime()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with columns for:
</p>

<dl>
<dt>event_number_before</dt><dd><p>The index of <code>time_event</code> that is the last one before <code>time_obs</code> or <code>NA</code> if none are before.</p>
</dd>
<dt>event_number_after</dt><dd><p>The index of <code>time_event</code> that is the first one after <code>time_obs</code> or <code>NA</code> if none are after.</p>
</dd>
<dt>time_before</dt><dd><p>The minimum time that the current <code>time_obs</code> is before a <code>time_event</code>, 0 if at least one <code>time_obs == time_event</code>.</p>
</dd>
<dt>time_after</dt><dd><p>The minimum time that the current <code>time_obs</code> is after a <code>time_event</code>, 0 if at least one <code>time_obs == time_event</code>.</p>
</dd>
<dt>time_after_first</dt><dd><p>The time after the first event (may be negative or positive).</p>
</dd>
</dl>

<p><code>time_after</code> and <code>time_before</code> are calculated if they are at the same time as
a dose, they equal zero, and otherwise, they are calculated relative to the
dose number in the <code style="white-space: pre;">&#8288;event_number_*&#8288;</code> columns.
</p>

<hr>
<h2 id='tss.monoexponential.generate.formula'>A helper function to generate the formula and starting values for the
parameters in monoexponential models.</h2><span id='topic+tss.monoexponential.generate.formula'></span>

<h3>Description</h3>

<p>A helper function to generate the formula and starting values for the
parameters in monoexponential models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tss.monoexponential.generate.formula(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tss.monoexponential.generate.formula_+3A_data">data</code></td>
<td>
<p>The data used for the model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with elements for each of the variables
</p>

<hr>
<h2 id='var_sparse_auc'>Calculate the variance for the AUC of sparsely sampled PK</h2><span id='topic+var_sparse_auc'></span>

<h3>Description</h3>

<p>Equation 7.vii in Nedelman and Jia, 1998 is used for this calculation:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var_sparse_auc(sparse_pk)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="var_sparse_auc_+3A_sparse_pk">sparse_pk</code></td>
<td>
<p>A sparse_pk object from <code><a href="#topic+as_sparse_pk">as_sparse_pk()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">var\left(\hat{AUC}\right) = \sum\limits_{i=0}^m\left(\frac{w_i^2 s_i^2}{r_i}\right) + 2\sum\limits_{i&lt;j}\left(\frac{w_i w_j r_{ij} s_{ij}}{r_i r_j}\right)</code>
</p>

<p>The degrees of freedom are calculated as described in equation 6 of the same
paper.
</p>


<h3>References</h3>

<p>Nedelman JR, Jia X. An extension of Satterthwaites approximation applied to
pharmacokinetics. Journal of Biopharmaceutical Statistics. 1998;8(2):317-328.
doi:10.1080/10543409808835241
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
