<!DOCTYPE html><html><head><title>Help for package frailtyMMpen</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {frailtyMMpen}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cluster'><p>cluster function</p></a></li>
<li><a href='#coef.fpen'><p>retrieve the coefficients under given tuning parameter</p></a></li>
<li><a href='#event'><p>event function</p></a></li>
<li><a href='#frailtyMM'><p>Fitting frailty models with clustered, multi-event and recurrent data using MM algorithm</p></a></li>
<li><a href='#frailtyMMpen'><p>Fitting penalized frailty models with clustered, multi-event and recurrent data using MM algorithm</p></a></li>
<li><a href='#hdCLdata'><p>Simulated High-dimensional Clustered data</p></a></li>
<li><a href='#plot.fmm'><p>Plot the baseline hazard or the predicted hazard based on the new data</p></a></li>
<li><a href='#plot.fpen'><p>Plot the regularization path</p></a></li>
<li><a href='#predict.fmm'><p>Estimate the baseline hazard or the predict hazard rate based on the new data for non-penalized regression</p></a></li>
<li><a href='#predict.fpen'><p>Estimate the baseline hazard or the predict hazard rate based on the new data for penalized regression</p></a></li>
<li><a href='#print.fmm'><p>print a non-penalized regression object</p></a></li>
<li><a href='#print.fpen'><p>print a penalized regression object</p></a></li>
<li><a href='#simdataCL'><p>Simulated Clustered data</p></a></li>
<li><a href='#simdataME'><p>Simulated Multiple Event data</p></a></li>
<li><a href='#simdataRE'><p>Simulated Recurrent Event data</p></a></li>
<li><a href='#summary.fmm'><p>Provide the summary for the model fitting</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Efficient Algorithm for High-Dimensional Frailty Model</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yunpeng Zhou &lt;u3514104@connect.hku.hk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The penalized and non-penalized Minorize-Maximization (MM) method for frailty models to fit the clustered data, multi-event data and recurrent data. Least absolute shrinkage and selection operator (LASSO), minimax concave penalty (MCP) and smoothly clipped absolute deviation (SCAD) penalized functions are implemented. All the methods are computationally efficient. These general methods are proposed based on the following papers,
    Huang, Xu and Zhou (2022) &lt;<a href="https://doi.org/10.3390%2Fmath10040538">doi:10.3390/math10040538</a>&gt;,
    Huang, Xu and Zhou (2023) &lt;<a href="https://doi.org/10.1177%2F09622802221133554">doi:10.1177/09622802221133554</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>false</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), survival, numDeriv, mgcv</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.8), utils, graphics, stats</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppGSL</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-08 07:51:11 UTC; micha</td>
</tr>
<tr>
<td>Author:</td>
<td>Xifen Huang [aut],
  Yunpeng Zhou [aut, cre],
  Jinfeng Xu [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-08 09:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='cluster'>cluster function</h2><span id='topic+cluster'></span>

<h3>Description</h3>

<p>Specify cluster id for clustered data or object id for recurrent data in the input <code>formula</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluster_+3A_x">x</code></td>
<td>
<p>name from original dataframe which specifies the cluster or object id.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called to construct <code>formula</code>.
</p>

<hr>
<h2 id='coef.fpen'>retrieve the coefficients under given tuning parameter</h2><span id='topic+coef.fpen'></span>

<h3>Description</h3>

<p>retrieve the coefficients under given tuning parameter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fpen'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.fpen_+3A_object">object</code></td>
<td>
<p>Object with class &quot;fpen&quot;, generated from <code>frailtyMMpen</code>.</p>
</td></tr>
<tr><td><code id="coef.fpen_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Without given a specific tune value, the coefficients with minimum BIC is returned. If <code>tune=a</code>,
the coefficient is computed using linear interpolation of the result from the coefficients estimated from the run of regularization path.
Thus, <code>a</code> should between the minimum and maximum value of the tuning parameter sequences used for the model fitting.
</p>


<h3>Value</h3>

<p>A vector of estimated parameters.
</p>

<hr>
<h2 id='event'>event function</h2><span id='topic+event'></span>

<h3>Description</h3>

<p>Specify event id for multi-event data in the input <code>formula</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>event(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="event_+3A_x">x</code></td>
<td>
<p>name from original dataframe which specifies the event id.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called to construct <code>formula</code>.
</p>

<hr>
<h2 id='frailtyMM'>Fitting frailty models with clustered, multi-event and recurrent data using MM algorithm</h2><span id='topic+frailtyMM'></span>

<h3>Description</h3>


<p>This formula is used to fit the non-penalized regression. 3 types of the models can be fitted, shared frailty model where
hazard rate of <code class="reqn">j^{th}</code> object in <code class="reqn">i^{th}</code> cluster is
</p>
<p style="text-align: center;"><code class="reqn">\lambda_{ij}(t|\omega_i) = \lambda_0(t) \omega_i \exp(\boldsymbol{\beta}' \mathbf{X_{ij}}).</code>
</p>

<p>The multi-event frailty model with different baseline hazard of different event and the hazard rate of <code class="reqn">j^{th}</code> event for individual <code class="reqn">i^{th}</code> is 
</p>
<p style="text-align: center;"><code class="reqn">\lambda_{ij}(t|\omega_i) = \lambda_{0j}(t) \omega_i \exp(\boldsymbol{\beta}' \mathbf{X_{ij}}).</code>
</p>

<p>The recurrent event model where the <code class="reqn">j^{th}</code> event of individual <code class="reqn">i</code> has observed feature <code class="reqn">\mathbf{X_{ij}}</code>,
</p>
<p style="text-align: center;"><code class="reqn">\lambda_{ij}(t|\omega_i) = \lambda_0(t) \omega_i \exp(\boldsymbol{\beta}' \mathbf{X_{ij}}).</code>
</p>

<p>For the  clustered type of data, we further assume that cluster <code class="reqn">i</code> has <code class="reqn">n_i</code> with <code class="reqn">j=1,...,n_{i}</code> number 
of objects where they share the common frailty parameter <code class="reqn">\omega_i</code>. For simplicity, we let <code class="reqn">\boldsymbol{\alpha}</code> 
be the collection of all parameters and baseline hazard function. Then, the marginal likelihood is as follows,
</p>
<p><img src="../help/figures/fig1.png" style="width:750px;max-width:75%;" alt="fig1.png" />

</p>
<p>Given the objective functions above, we take the clustered data as an example to illustrate the application of MM algorithm in optimizing the observed likelihood function,
the observed log-likelihood function is, 
</p>
<p><img src="../help/figures/fig4.png" style="width:750px;max-width:75%;" alt="fig4.png" />

</p>
<p>where,
</p>
<p><img src="../help/figures/fig5.png" style="width:750px;max-width:75%;" alt="fig5.png" />

</p>
<p>In order to formulate the iterative algorithm to optimize the observed log likelihood, we further define density function <code class="reqn">g_i(\cdot)</code> 
based on the estimates of the parameters in <code class="reqn">k^{th}</code> iteration <code class="reqn">\boldsymbol{\alpha}^{(k)}</code>
</p>
<p><img src="../help/figures/fig6.png" style="width:750px;max-width:75%;" alt="fig6.png" />

</p>
<p>Then, we construct the surrogate function to minimize the mariginal log-likelihood using the Jensen's inequality,
</p>
<p><img src="../help/figures/fig7.png" style="width:750px;max-width:75%;" alt="fig7.png" />

</p>
<p>which successfully separated <code class="reqn">\boldsymbol{\alpha}</code> into <code class="reqn">\boldsymbol{\theta}</code> and <code class="reqn">(\boldsymbol{\beta}, \Lambda_{0})</code> where,
</p>
<p><img src="../help/figures/fig8.png" style="width:750px;max-width:75%;" alt="fig8.png" />

</p>
<p>and let <img src="../help/figures/fig91.png" width=200 alt="fig91.png" />, 
</p>
<p><img src="../help/figures/fig9.png" style="width:750px;max-width:75%;" alt="fig9.png" />

</p>
<p>And then we estimate <code class="reqn">\Lambda_{0}</code> by,
</p>
<p><img src="../help/figures/fig10.png" style="width:750px;max-width:75%;" alt="fig10.png" />

</p>
<p>Then, we have, 
</p>
<p><img src="../help/figures/fig11.png" style="width:750px;max-width:75%;" alt="fig11.png" />

</p>
<p>Further more, we apply hyperplane inequality to construct surrogate function for <code class="reqn">\boldsymbol{\beta}</code> where we can update the its estimates coordinate wise,
</p>
<p><img src="../help/figures/fig12.png" style="width:750px;max-width:75%;" alt="fig12.png" />

</p>
<p>By applying Jensen's inequality, 
</p>
<p><img src="../help/figures/fig13.png" style="width:750px;max-width:75%;" alt="fig13.png" />

</p>
<p>Finally, 
</p>
<p><img src="../help/figures/fig14.png" style="width:750px;max-width:75%;" alt="fig14.png" />


</p>


<h3>Usage</h3>

<pre><code class='language-R'>frailtyMM(
  formula,
  data,
  frailty = "gamma",
  power = NULL,
  tol = 1e-05,
  maxit = 200,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frailtyMM_+3A_formula">formula</code></td>
<td>
<p>Formula where the left hand side is an object of the type <code>Surv</code>
and the right hand side contains the variables and additional specifications. 
<code>+cluster()</code> function specify the group id for clustered data or individual id for recurrent data.
<code>+event()</code> function specify the event id for multi-event data (only two events are allowed).</p>
</td></tr>
<tr><td><code id="frailtyMM_+3A_data">data</code></td>
<td>
<p>The <code>data.frame</code> where the formula argument can be evaluated.</p>
</td></tr>
<tr><td><code id="frailtyMM_+3A_frailty">frailty</code></td>
<td>
<p>The frailty used for model fitting. The default is &quot;lognormal&quot;, other choices are
&quot;invgauss&quot;, &quot;gamma&quot; and &quot;pvf&quot;. (Note that the computation time for PVF family will be slow 
due to the non-explicit expression of likelihood function)</p>
</td></tr>
<tr><td><code id="frailtyMM_+3A_power">power</code></td>
<td>
<p>The power used if PVF frailty is applied.</p>
</td></tr>
<tr><td><code id="frailtyMM_+3A_tol">tol</code></td>
<td>
<p>The tolerance level for convergence.</p>
</td></tr>
<tr><td><code id="frailtyMM_+3A_maxit">maxit</code></td>
<td>
<p>Maximum iterations for MM algorithm.</p>
</td></tr>
<tr><td><code id="frailtyMM_+3A_...">...</code></td>
<td>
<p>additional arguments pass to the function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To run the shared frailty model, <code>Surv(tstop, status)</code> formula should be applied along with <code>+cluster()</code> to specify the
corresponding clusters, if you want to run the simple frailty model without shared frailty, you do not need to use <code>+cluster()</code> and the
formula only contains the name of the covariates. To run the multi-event model, 
<code>Surv(tstop, status)</code> formula should be applied along with <code>+event()</code> to specify the corresponding events. If multi-event data
is fitted, please use 1,2...,K to denote the event id from the input data. To run the recurrent event model, 
<code>Surv(tstart, tstop, status)</code> formula should be applied along with <code>+cluster()</code> where the cluster here denotes the individual id and
each individual may have many observed events at different time points.
</p>
<p>The default frailty will be log-normal frailty, in order to fit other frailty models, simply set parameter <code>frailty</code> as &quot;InvGauss&quot;, &quot;Gamma&quot; or &quot;PVF&quot;,
the parameter <code>power</code> is only used when <code>frailty</code>=PVF and since the likelihood of PVF (tweedie) distribution is approximated using 
<code>Tweedie</code> function from package mgcv, 1&lt;<code>power</code>&lt;2.
</p>


<h3>Value</h3>

<p>An object of class <code>fmm</code> that contains the following fields:
</p>
<table>
<tr><td><code>coef</code></td>
<td>
<p>coefficient estimated from a specific model.</p>
</td></tr>
<tr><td><code>est.tht</code></td>
<td>
<p>frailty parameter estimated from a specific model.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>frailty for each observation estimated from a specific model.</p>
</td></tr>
<tr><td><code>likelihood</code></td>
<td>
<p>The observed log-likelihood given estimated parameters.</p>
</td></tr>
<tr><td><code>input</code></td>
<td>
<p>The input data re-ordered by cluster id. <code>y</code> is the event time, <code>X</code> is covariate matrix and <code>d</code> is the status while 0 indicates censoring.</p>
</td></tr>
<tr><td><code>frailty</code></td>
<td>
<p>frailty used for model fitting.</p>
</td></tr>
<tr><td><code>power</code></td>
<td>
<p>power used for model fitting is PVF frailty is applied.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>total number of iterations.</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>convergence threshold.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>formula applied as input.</p>
</td></tr>
<tr><td><code>coefname</code></td>
<td>
<p>name of each coefficient from input.</p>
</td></tr>
<tr><td><code>id</code></td>
<td>
<p>id for individuals or clusters, 1,2...,a. Note that, since the original id may not be the sequence starting from 1, this output
id may not be identical to the original id. Also, the order of id is corresponding to the returned <code>input</code>.</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>total number of observations.</p>
</td></tr>
<tr><td><code>a</code></td>
<td>
<p>total number of individuals or clusters.</p>
</td></tr>
<tr><td><code>datatype</code></td>
<td>
<p>model used for fitting.</p>
</td></tr>
</table>


<h3>References</h3>


<ul>
<li><p> Huang, X., Xu, J. and Zhou, Y. (2022). Profile and Non-Profile MM Modeling of Cluster Failure Time and Analysis of ADNI Data. <em>Mathematics</em>, 10(4), 538.
</p>
</li>
<li><p> Huang, X., Xu, J. and Zhou, Y. (2023). Efficient algorithms for survival data with multiple outcomes using the frailty model. <em>Statistical Methods in Medical Research</em>, 32(1), 118-132.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# Kidney data fitted by Clustered Inverse Gaussian Frailty Model


InvG_real_cl = frailtyMM(Surv(time, status) ~ age + sex + cluster(id),
                         kidney, frailty = "invgauss")
InvG_real_cl

# Cgd data fitted by Recurrent Log-Normal Frailty Model

logN_real_re = frailtyMM(Surv(tstart, tstop, status) ~ sex + treat + cluster(id),
                         cgd, frailty = "gamma")
logN_real_re


# Simulated data example

data(simdataCL)

# Parameter estimation under different model structure and frailties

# Clustered Gamma Frailty Model
gam_cl = frailtyMM(Surv(time, status) ~ . + cluster(id), 
                   simdataCL, frailty = "gamma")


# Clustered Log-Normal Frailty Model
logn_cl = frailtyMM(Surv(time, status) ~ . + cluster(id), 
                    simdataCL, frailty = "lognormal")

# Clustered Inverse Gaussian Frailty Model
invg_cl = frailtyMM(Surv(time, status) ~ . + cluster(id), 
                    simdataCL, frailty = "invgauss")
                   
data(simdataME)

# Multi-event Gamma Frailty Model
gam_me = frailtyMM(Surv(time, status) ~ . + cluster(id), 
                   simdataCL, frailty = "gamma")


# Multi-event Log-Normal Frailty Model
logn_me = frailtyMM(Surv(time, status) ~ . + event(id), 
                    simdataME, frailty = "lognormal")

# Multi-event Inverse Gaussian Frailty Model
invg_me = frailtyMM(Surv(time, status) ~ . + event(id),
                    simdataME, frailty = "invgauss")

data(simdataRE)

# Recurrent event Gamma Frailty Model
gam_re = frailtyMM(Surv(start, end, status) ~ . + cluster(id),
                   simdataRE, frailty = "gamma")

# Recurrent event Log-Normal Frailty Model
logn_re = frailtyMM(Surv(start, end, status) ~ . + cluster(id),
                   simdataRE, frailty = "lognormal")

# Recurrent event Inverse Gaussian Frailty Model
invg_re = frailtyMM(Surv(start, end, status) ~ . + cluster(id), 
                    simdataRE, frailty = "invgauss")


# Obtain the summary statistics under fitted model

coef(gam_cl)
summary(gam_cl)

</code></pre>

<hr>
<h2 id='frailtyMMpen'>Fitting penalized frailty models with clustered, multi-event and recurrent data using MM algorithm</h2><span id='topic+frailtyMMpen'></span>

<h3>Description</h3>

<p>This formula is used to fit the penalized regression. 3 types of the models can be fitted similar to the function
<code>frailtyMM</code>. In addition, variable selection can be done by three types of penalty, LASSO, MCP and SCAD with the following
objective function where <code class="reqn">\lambda</code> is the tuning parameter and <code class="reqn">q</code> is the dimension of <code class="reqn">\boldsymbol{\beta}</code>,
</p>
<p style="text-align: center;"><code class="reqn">l(\boldsymbol{\beta},\Lambda_0|Y_{obs}) - n\sum_{p=1}^{q} p(|\beta_p|, \lambda).</code>
</p>

<p>The BIC is computed using the following equation,
</p>
<p style="text-align: center;"><code class="reqn">-2l(\hat{\boldsymbol{\beta}}, \hat{\Lambda}_0) + G_n(\hat{S}+1)\log(n),</code>
</p>

<p>where <code class="reqn">G_n=\max\{1, \log(\log(q+1))\}</code> and <code class="reqn">\hat{S}</code> is the degree of freedom.
</p>
<p>Surrogate function is also derived for penalty part for efficient estimation of penalized regression, similar to the notation used
in <code><a href="#topic+frailtyMM">frailtyMM</a></code>, we let <code class="reqn">\boldsymbol{\alpha}</code> be the collection of all parameters and baseline hazard function. Given that,
</p>
<p><img src="../help/figures/fig15.png" style="width:750px;max-width:75%;" alt="fig15.png" />

</p>
<p>by local quadratic approximation,
</p>
<p><img src="../help/figures/fig16.png" style="width:750px;max-width:75%;" alt="fig16.png" />

</p>
<p>And thus, the surrogate function given <code class="reqn">k^{th}</code> iteration result is as follows,
</p>
<p><img src="../help/figures/fig17.png" style="width:750px;max-width:75%;" alt="fig17.png" />


</p>


<h3>Usage</h3>

<pre><code class='language-R'>frailtyMMpen(
  formula,
  data,
  frailty = "gamma",
  power = NULL,
  penalty = "LASSO",
  gam = NULL,
  tune = NULL,
  tol = 1e-05,
  maxit = 200,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frailtyMMpen_+3A_formula">formula</code></td>
<td>
<p>Formula where the left hand side is an object of the type <code>Surv</code>
and the right hand side contains the variables and additional specifications. 
<code>+cluster()</code> function specify the group id for clustered data or individual id for recurrent data.
<code>+event()</code> function specify the event id for multi-event data (only two events are allowed).</p>
</td></tr>
<tr><td><code id="frailtyMMpen_+3A_data">data</code></td>
<td>
<p>The <code>data.frame</code> where the formula argument can be evaluated.</p>
</td></tr>
<tr><td><code id="frailtyMMpen_+3A_frailty">frailty</code></td>
<td>
<p>The frailty used for model fitting. The default is &quot;lognormal&quot;, other choices are
&quot;invgauss&quot;, &quot;gamma&quot; and &quot;pvf&quot;. (Note that the computation time for PVF family will be slow 
due to the non-explicit expression of likelihood function)</p>
</td></tr>
<tr><td><code id="frailtyMMpen_+3A_power">power</code></td>
<td>
<p>The power used if PVF frailty is applied.</p>
</td></tr>
<tr><td><code id="frailtyMMpen_+3A_penalty">penalty</code></td>
<td>
<p>The penalty used for regularization, the default is &quot;LASSO&quot;, other choices are &quot;MCP&quot; and &quot;SCAD&quot;.</p>
</td></tr>
<tr><td><code id="frailtyMMpen_+3A_gam">gam</code></td>
<td>
<p>The tuning parameter for MCP and SCAD which controls the concavity of the penalty. For MCP, 
</p>
<p style="text-align: center;"><code class="reqn">p^{\prime}(\beta, \lambda)=sign(\beta)(\lambda - \frac{|\beta|}{\gamma})</code>
</p>
<p> and for &quot;SCAD&quot;,
</p>
<p style="text-align: center;"><code class="reqn">p^{\prime}(\beta, \lambda)=\lambda\{I(|\beta| \leq \lambda)+\frac{(\gamma \lambda-|\beta|)_{+}}{(\gamma-1) \lambda} I(|\beta|&gt;\lambda)\}.</code>
</p>

<p>The default value of <code class="reqn">\gamma</code> for MCP is 3 and SCAD is 3.7.</p>
</td></tr>
<tr><td><code id="frailtyMMpen_+3A_tune">tune</code></td>
<td>
<p>The sequence of tuning parameters provided by user. If not provided, the default grid will be applied.</p>
</td></tr>
<tr><td><code id="frailtyMMpen_+3A_tol">tol</code></td>
<td>
<p>The tolerance level for convergence.</p>
</td></tr>
<tr><td><code id="frailtyMMpen_+3A_maxit">maxit</code></td>
<td>
<p>Maximum iterations for MM algorithm.</p>
</td></tr>
<tr><td><code id="frailtyMMpen_+3A_...">...</code></td>
<td>
<p>additional arguments pass to the function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Without a given <code>tune</code>, the default sequence of tuning parameters are used to provide the regularization path.
The formula is same as the input for function <code>frailtyMM</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>fmm</code> that contains the following fields:
</p>
<table>
<tr><td><code>coef</code></td>
<td>
<p>matrix of coefficient estimated from a specific model where each column correponds to an input tuning parameter.</p>
</td></tr>
<tr><td><code>est.tht</code></td>
<td>
<p>vector of frailty parameters estimated from a specific model with respect to each tuning parameter.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>list of frailty for each observation estimated from a specific model with respect to each tuning parameter.</p>
</td></tr>
<tr><td><code>likelihood</code></td>
<td>
<p>vector of the observed log-likelihood given estimated parameters with respect to each tuning parameter.</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>vector of the BIC given estimated parameters with respect to each tuning parameter.</p>
</td></tr>
<tr><td><code>tune</code></td>
<td>
<p>vector of tuning parameters used for penalized regression.</p>
</td></tr>
<tr><td><code>tune.min</code></td>
<td>
<p>tuning parameter where minimal of BIC is obtained.</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>convergence threshold.</p>
</td></tr>
<tr><td><code>input</code></td>
<td>
<p>The input data re-ordered by cluster id. <code>y</code> is the event time, <code>X</code> is covariate matrix and <code>d</code> is the status while 0 indicates censoring.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>input stopping time.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>input covariate matrix.</p>
</td></tr>
<tr><td><code>d</code></td>
<td>
<p>input censoring indicator.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>formula applied as input.</p>
</td></tr>
<tr><td><code>coefname</code></td>
<td>
<p>name of each coefficient from input.</p>
</td></tr>
<tr><td><code>id</code></td>
<td>
<p>id for individuals or clusters, 1,2...,a. Note that, since the original id may not be the sequence starting from 1, this output
id may not be identical to the original id. Also, the order of id is corresponding to the returned <code>input</code>.</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>total number of observations.</p>
</td></tr>
<tr><td><code>a</code></td>
<td>
<p>total number of individuals or clusters.</p>
</td></tr>
<tr><td><code>datatype</code></td>
<td>
<p>model used for fitting.</p>
</td></tr>
</table>


<h3>References</h3>


<ul>
<li><p> Huang, X., Xu, J. and Zhou, Y. (2022). Profile and Non-Profile MM Modeling of Cluster Failure Time and Analysis of ADNI Data. <em>Mathematics</em>, 10(4), 538.
</p>
</li>
<li><p> Huang, X., Xu, J. and Zhou, Y. (2023). Efficient algorithms for survival data with multiple outcomes using the frailty model. <em>Statistical Methods in Medical Research</em>, 32(1), 118-132.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+frailtyMM">frailtyMM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(simdataCL)

# Penalized regression under clustered frailty model

# Clustered Gamma Frailty Model

# Using default tuning parameter sequence
gam_cl1 = frailtyMMpen(Surv(time, status) ~ . + cluster(id),
                       simdataCL, frailty = "gamma")


# Using given tuning parameter sequence
gam_cl2 = frailtyMMpen(Surv(time, status) ~ . + cluster(id), 
                       simdataCL, frailty = "gamma", tune = 0.1)

# Obtain the coefficient where minimum BIC is obtained
coef(gam_cl1)

# Obtain the coefficient with tune = 0.2.
coef(gam_cl1, tune = 0.2)

# Plot the regularization path
plot(gam_cl1)

# Get the degree of freedom and BIC for the sequence of tuning parameters provided
print(gam_cl1)



</code></pre>

<hr>
<h2 id='hdCLdata'>Simulated High-dimensional Clustered data</h2><span id='topic+hdCLdata'></span>

<h3>Description</h3>

<p>This data include 50 clusters with 4 objects, a total of 200 events are recorded.
500 covariates can be used for model fitting. The data is generated from a
gamma frailty model with coefficients (5,5,5,5,...,0) and frailty variance 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(hdCLdata)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 200 rows and 503 columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hdCLdata)
</code></pre>

<hr>
<h2 id='plot.fmm'>Plot the baseline hazard or the predicted hazard based on the new data</h2><span id='topic+plot.fmm'></span>

<h3>Description</h3>

<p>Both the cumulative hazard and the survival curves can be plotted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>##S3 method for class "fmm"
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.fmm_+3A_newdata">newdata</code></td>
<td>
<p>The new data for prediction of hazard</p>
</td></tr>
<tr><td><code id="plot.fmm_+3A_surv">surv</code></td>
<td>
<p>Plot survival curve instead of cumulative hazard, the default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="plot.fmm_+3A_...">...</code></td>
<td>
<p>Further arguments pass to or from other methods</p>
</td></tr>
<tr><td><code id="plot.fmm_+3A_object">object</code></td>
<td>
<p>Object with class &quot;fmm&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If parameter <code>newdata</code> is given, the plot is based on the predicted hazard while if it is not given,
the plot is based on the baseline hazard. To construct the new data, please refer to the detailed description from 
function <code>predict.fmm</code> and the following example.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.fmm">predict.fmm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gam_re = frailtyMM(Surv(tstart, tstop, status) ~  sex + treat + cluster(id), cgd, frailty = "gamma")

# Plot the survival curve based on baseline hazard
plot(gam_re, surv = TRUE)

# Construct new data and plot the cumulative hazard based on new data
newre = c(1, 1, 2)
names(newre) = c(gam_re$coefname, "id")
plot(gam_re, newdata = newre)

</code></pre>

<hr>
<h2 id='plot.fpen'>Plot the regularization path</h2><span id='topic+plot.fpen'></span>

<h3>Description</h3>

<p>Plot the whole regularization path run by frailtyMMpen
</p>


<h3>Usage</h3>

<pre><code class='language-R'>##S3 method for class "fpen"
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.fpen_+3A_x">x</code></td>
<td>
<p>Object with class &quot;fpen&quot;</p>
</td></tr>
<tr><td><code id="plot.fpen_+3A_...">...</code></td>
<td>
<p>Further arguments pass to or from other methods</p>
</td></tr>
</table>

<hr>
<h2 id='predict.fmm'>Estimate the baseline hazard or the predict hazard rate based on the new data for non-penalized regression</h2><span id='topic+predict.fmm'></span>

<h3>Description</h3>

<p>This function is used to estimate the baseline hazard or to predict the hazard rate of a specific individual
given result from model fitting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>##S3 method for class "fmm"
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.fmm_+3A_object">object</code></td>
<td>
<p>Object with class &quot;fmm&quot;</p>
</td></tr>
<tr><td><code id="predict.fmm_+3A_newdata">newdata</code></td>
<td>
<p>The new data for prediction of hazard, categorical data has to be transformed to 0 and 1</p>
</td></tr>
<tr><td><code id="predict.fmm_+3A_surv">surv</code></td>
<td>
<p>Plot survival curve instead of cumulative hazard, the default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="predict.fmm_+3A_...">...</code></td>
<td>
<p>Further arguments pass to or from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If parameter <code>newdata</code> is given, the predicted hazard is calculated based on the given data.
If parameter <code>newdata</code> is not given, the estimation of baseline hazard will be returned. 
The confidence band is calculated based on the delta method. Please insure that the input of new data
should be of the same coefficient name as <code>object$coefname</code>. Note that if original data contains categorical data, you could check
<code>object$coefname</code> to input the corresponding 0 or 1 and name of coefficient for the <code>newdata</code>. 
For example, if the coefficient name is &quot;sexfemale&quot;, then 1 denotes female while 0 denotes male. You may refer to the
example below to construct the new data.
</p>


<h3>Value</h3>

<table>
<tr><td><code>output</code></td>
<td>
<p>A dataframe that the first column is the evaluated time point, the second column is the estimated cumulative
hazard or survival curve, the third column is the standard error of the estimation result and the fourth and fifth column
are the lower bound and upper bound based on 95 percent confidence interval.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>

gam_re = frailtyMM(Surv(tstart, tstop, status) ~  sex + treat + cluster(id), cgd, frailty = "Gamma")

# Calculate the survival curve based on baseline hazard
predict(gam_re, surv = TRUE)

# Construct new data and calculate the cumulative hazard based on new data
newre = c(1, 1, 2)
names(newre) = c(gam_re$coefname, "id")
predict(gam_re, newdata = newre)


</code></pre>

<hr>
<h2 id='predict.fpen'>Estimate the baseline hazard or the predict hazard rate based on the new data for penalized regression</h2><span id='topic+predict.fpen'></span>

<h3>Description</h3>

<p>This function is used to estimate the baseline hazard or to predict the hazard rate of a specific individual
given result from model fitting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>##S3 method for class "fpen"
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.fpen_+3A_object">object</code></td>
<td>
<p>Object with class &quot;fpen&quot;</p>
</td></tr>
<tr><td><code id="predict.fpen_+3A_tune">tune</code></td>
<td>
<p>The tuning parameter for estimating coefficients</p>
</td></tr>
<tr><td><code id="predict.fpen_+3A_coef">coef</code></td>
<td>
<p>Instead of providing tuning parameter, you can directly provide the coefficients for prediction</p>
</td></tr>
<tr><td><code id="predict.fpen_+3A_newdata">newdata</code></td>
<td>
<p>The new data for prediction of hazard, categorical data has to be transformed to 0 and 1</p>
</td></tr>
<tr><td><code id="predict.fpen_+3A_surv">surv</code></td>
<td>
<p>Plot survival curve instead of cumulative hazard, the default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="predict.fpen_+3A_...">...</code></td>
<td>
<p>Further arguments pass to or from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If parameter <code>newdata</code> is given, the predicted hazard is calculated based on the given data.
If parameter <code>newdata</code> is not given, the estimation of baseline hazard will be returned. 
Since the covariance of estimated parameters for penalized regression cannot be obtained from MLE theorem, we
only provide the estimation without confidence band. For the formulation of new data, you may refer to
function <code>predict.fmm</code> for detailed description.
</p>


<h3>Value</h3>

<table>
<tr><td><code>output</code></td>
<td>
<p>A dataframe that the first column is the evaluated time point and the second column is the estimated cumulative
hazard or survival curve.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'> 
data(simdataCL)


gam_cl = frailtyMMpen(Surv(time, status) ~  . + cluster(id), simdataCL, frailty = "Gamma")

# Calculate the survival curve based on baseline hazard
predict(gam_cl, surv = TRUE)

# Construct new data and calculate the cumulative hazard based on new data
newcl = c(gam_cl$X[1,], 2)
names(newcl) = c(gam_cl$coefname, "id")
predict(gam_cl, newdata = newcl)

</code></pre>

<hr>
<h2 id='print.fmm'>print a non-penalized regression object</h2><span id='topic+print.fmm'></span>

<h3>Description</h3>

<p>Print the summary of a non-penalized regression fitted by any model with function <code>frailtyMM</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fmm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.fmm_+3A_x">x</code></td>
<td>
<p>Object with class &quot;fmm&quot; fitted by function <code>frailtyMM</code>.</p>
</td></tr>
<tr><td><code id="print.fmm_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called to print the summary for non-penalized regression.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+frailtyMM">frailtyMM</a></code>
</p>

<hr>
<h2 id='print.fpen'>print a penalized regression object</h2><span id='topic+print.fpen'></span>

<h3>Description</h3>

<p>Print the summary of a non-penalized regression fitted by any model with function <code>frailtyMMpen</code>.
The first column is the tuning parameter sequence, the second column is the degree of freedom and the third column is the BIC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fpen'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.fpen_+3A_x">x</code></td>
<td>
<p>Object with class &quot;fpen&quot; fitted by function <code>frailtyMMpen</code>.</p>
</td></tr>
<tr><td><code id="print.fpen_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called to print the summary for penalized regression.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+frailtyMMpen">frailtyMMpen</a></code>
</p>

<hr>
<h2 id='simdataCL'>Simulated Clustered data</h2><span id='topic+simdataCL'></span>

<h3>Description</h3>

<p>This data include 50 clusters with 10 objects, a total of 100 events are recorded.
30 temporal covariates can be used for model fitting. The data is generated from a
gamma frailty model with coefficients (1,2,3,4,0,...,0) and frailty variance 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(simdataCL)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 500 rows and 33 columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(simdataCL)
</code></pre>

<hr>
<h2 id='simdataME'>Simulated Multiple Event data</h2><span id='topic+simdataME'></span>

<h3>Description</h3>

<p>This data include 50 individuals with 2 events, a total of 100 events are recorded.
30 temporal covariates can be used for model fitting. The data is generated from a
gamma frailty model with coefficients (1,2,3,4,0,...,0) and frailty variance 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(simdataME)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 100 rows and 33 columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(simdataME)
</code></pre>

<hr>
<h2 id='simdataRE'>Simulated Recurrent Event data</h2><span id='topic+simdataRE'></span>

<h3>Description</h3>

<p>This data include 50 individuals with recurrent observation of events, a total of 706 events are recorded.
30 temporal covariates can be used for model fitting. The data is generated from a
gamma frailty model with coefficients (1,2,3,4,0,...,0) and frailty variance 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(simdataRE)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 706 rows and 34 columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(simdataRE)
</code></pre>

<hr>
<h2 id='summary.fmm'>Provide the summary for the model fitting</h2><span id='topic+summary.fmm'></span>

<h3>Description</h3>

<p>Provide the summary for the model fitting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>##S3 method for class "fmm"
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.fmm_+3A_object">object</code></td>
<td>
<p>Object with class &quot;fmm&quot;, generated from <code>frailtyMM</code>.</p>
</td></tr>
<tr><td><code id="summary.fmm_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>the summary for the model of frailtyMM.
The standard error and p-value of estimated parameters are based on Fisher Information matrix.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
