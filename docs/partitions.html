<!DOCTYPE html><html lang="en"><head><title>Help for package partitions</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<script type="text/javascript" src="mathjax-config.js"></script>
<script type="text/javascript" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {partitions}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#partitions-package'>
<p>Integer partitions</p></a></li>
<li><a href='#as.matrix.partition'><p>Coerce partitions to matrices and vice versa</p></a></li>
<li><a href='#bin'><p>Sundry binary functionality</p></a></li>
<li><a href='#conjugate'><p>Conjugate partitions and Durfee squares</p></a></li>
<li><a href='#nextpart'><p>Next partition</p></a></li>
<li><a href='#P'><p>Number of partitions of an integer</p></a></li>
<li><a href='#parts'><p>Enumerate the partitions of an integer</p>
</a></li>
<li><a href='#perms'><p>Enumerate the permutations of a vector</p></a></li>
<li><a href='#print.partition'><p>Print methods for partition objects and equivalence objects</p></a></li>
<li><a href='#riffle'><p>Riffle shuffles</p></a></li>
<li><a href='#setparts'><p>Set partitions</p></a></li>
<li><a href='#summary.partition'><p>Provides a summary of a partition</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Additive Partitions of Integers</td>
</tr>
<tr>
<td>Version:</td>
<td>1.10-7</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;</td>
</tr>
<tr>
<td>Imports:</td>
<td>gmp, polynom, sets, mathjaxr, Rdpack</td>
</tr>
<tr>
<td>Description:</td>
<td>Additive partitions of integers.  Enumerates the
  partitions, unequal partitions, and restricted partitions of an
  integer; the three corresponding partition functions are also given.
  Set partitions and now compositions and riffle shuffles are
  included.</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/RobinHankin/partitions">https://github.com/RobinHankin/partitions</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/RobinHankin/partitions/issues">https://github.com/RobinHankin/partitions/issues</a></td>
</tr>
<tr>
<td>RdMacros:</td>
<td>mathjaxr,Rdpack</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-07-21 02:28:18 UTC; rhankin</td>
</tr>
<tr>
<td>Author:</td>
<td>Robin K. S. Hankin
    <a href="https://orcid.org/0000-0001-5982-0415"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Paul Egeler <a href="https://orcid.org/0000-0001-6948-9498"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-07-21 03:00:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='partitions-package'>
Integer partitions
</h2><span id='topic+partitions-package'></span><span id='topic+partitions'></span>

<h3>Description</h3>

<p>Routines to enumerate all partitions of an integer; includes restricted
and unequal partitions.
</p>


<h3>Details</h3>

<p>This package comprises eight functions: <code>P()</code>, <code>Q()</code>,
<code>R()</code>, and <code>S()</code> give the number of partitions, unequal
partitions, restricted partitions, and block partitions of an integer.
</p>
<p>Functions <code>parts()</code>, <code>diffparts()</code>, <code>restrictedparts()</code>,
and <code>blockparts()</code> enumerate these partitions.
</p>
<p>Function <code>conjugate()</code> gives the conjugate of a partition and
function <code>durfee()</code> gives the size of the Durfee square.  
</p>
<p><strong>NB</strong> the emphasis in this package is terse, efficient C code.
This means that there is a minimum of argument checking.  For example,
function <code>conjugate()</code> assumes that the partition is in standard
form (i.e. nonincreasing); supplying a vector in nonstandard form will
result in garbage being returned silently.  Note that a block partition
is not necessarily in standard form.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>


<ul>
<li><p> G. E. Andrews 1998 <em>The Theory of Partitions</em>,
Cambridge University Press
</p>
</li>
<li><p> M. Abramowitz and I. A. Stegun 1965.  <em>Handbook of
Mathematical Functions</em>, New York: Dover
</p>
</li>
<li><p> G. H. Hardy and E. M. Wright 1985 <em>An introduction to
the theory of numbers</em>, Clarendon Press: Oxford (fifth edition)
</p>
</li>
<li><p> R. K. S. Hankin 2006.  &ldquo;Additive integer partitions in
<span class="rlang"><b>R</b></span>&rdquo;. <em>Journal of Statistical Software</em>, Volume 16, code
snippet 1 
</p>
</li>
<li><p> R. K. S. Hankin 2007.  &ldquo;Urn sampling without
replacement: enumerative combinatorics in <span class="rlang"><b>R</b></span>&rdquo;. <em>Journal of
Statistical Software</em>, Volume 17, code snippet 1
</p>
</li>
<li><p> R. K. S. Hankin 2007.  &ldquo;Set partitions in
<span class="rlang"><b>R</b></span>&rdquo;. <em>Journal of Statistical Software</em>, Volume
23, code snippet 2
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'> parts(5)
 diffparts(9)
 restrictedparts(15,10)
 P(10,give=TRUE)
 Q(10,give=TRUE)
 R(5,10)
</code></pre>

<hr>
<h2 id='as.matrix.partition'>Coerce partitions to matrices and vice versa</h2><span id='topic+as.matrix.partition'></span><span id='topic+as.partition'></span>

<h3>Description</h3>

<p>Coercion to and from partitions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'partition'
as.matrix(x, ...)
as.partition(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.matrix.partition_+3A_x">x</code></td>
<td>
<p>Object to be coerced</p>
</td></tr>
<tr><td><code id="as.matrix.partition_+3A_...">...</code></td>
<td>
<p>Further arguments</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>as.matrix(parts(5))
</code></pre>

<hr>
<h2 id='bin'>Sundry binary functionality</h2><span id='topic+bin'></span><span id='topic+tobin'></span><span id='topic+todec'></span><span id='topic+comptobin'></span><span id='topic+bintocomp'></span>

<h3>Description</h3>

<p>Utilities to convert things to binary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tobin(n, len, check=TRUE)
todec(bin)
comptobin(comp, check=TRUE)
bintocomp(bin,  use.C=TRUE, check=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bin_+3A_n">n</code></td>
<td>
<p>Integer, to be converted to binary by function <code>tobin()</code></p>
</td></tr>
<tr><td><code id="bin_+3A_len">len</code></td>
<td>
<p>Length of the binary vector returned by function
<code>tobin()</code></p>
</td></tr>
<tr><td><code id="bin_+3A_bin">bin</code></td>
<td>
<p>Binary: a vector of <code>0</code>s and <code>1</code>s</p>
</td></tr>
<tr><td><code id="bin_+3A_comp">comp</code></td>
<td>
<p>A composition</p>
</td></tr>
<tr><td><code id="bin_+3A_check">check</code></td>
<td>
<p>Boolean, with default <code>TRUE</code> meaning to perform
various checks</p>
</td></tr>
<tr><td><code id="bin_+3A_use.c">use.C</code></td>
<td>
<p>Boolean, with default <code>TRUE</code> meaning to use
<code>C</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are not really intended for the end user; they are
used in <code>nextcomposition()</code>.
</p>

<ul>
<li><p> Function <code>tobin()</code> converts integer <code>n</code> to a binary
string of length <code>len</code>
</p>
</li>
<li><p> Function <code>todec()</code> converts a binary string to decimal,
so <code>todec(tobin(n,i))==n</code>, provided <code>i</code> is big enough
</p>
</li>
<li><p> Function <code>comptobin()</code> converts a composition to binary
</p>
</li>
<li><p> Function <code>bintocomp()</code> converts a binary string to a
composition
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>Wikipedia contributors, 2020. &ldquo;Composition (combinatorics) &mdash; Wikipedia, The Free Encyclopedia&rdquo;,
<a href="https://en.wikipedia.org/w/index.php?title=Composition_(combinatorics)&amp;oldid=944285378">https://en.wikipedia.org/w/index.php?title=Composition_(combinatorics)&amp;oldid=944285378</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tobin(10,5)
todec(tobin(10,5))
comptobin(c(1,1,4))
bintocomp(c(1,1,0,0,1,1,1,1))
</code></pre>

<hr>
<h2 id='conjugate'>Conjugate partitions and Durfee squares</h2><span id='topic+conjugate'></span><span id='topic+durfee'></span><span id='topic+durfee_sorted'></span><span id='topic+Durfee'></span>

<h3>Description</h3>

<p>Given a partition, provide its conjugate or Durfee square
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conjugate(x, sorted = TRUE)
durfee(x, sorted = TRUE)
durfee_sorted(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="conjugate_+3A_x">x</code></td>
<td>
<p>Either a vector describing a partition or a matrix whose
columns are partitions</p>
</td></tr>
<tr><td><code id="conjugate_+3A_sorted">sorted</code></td>
<td>
<p>A logical indicating whether the data is already in
standard form.  That is to say, are the data within each column
sorted in decreasing order?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Conjugation is described in Andrews, and (e.g.) Hardy and Wright.
</p>
<p>The <dfn>conjugate</dfn> of a partition may be calculated by taking its
Ferrers diagram and considering the partition defined by columns
instead of rows.  This may be visualised by flipping the Ferrers
diagram about the leading diagonal.
</p>
<p>Essentially, <code>conjugate()</code> carries out <span class="rlang"><b>R</b></span> idiom
</p>
<p><code>rev(cumsum(table(factor(a[a&gt;0],levels=max(a):1))))</code>
</p>
<p>but is faster.
</p>
<p>The &ldquo;Durfee square&rdquo; of a partition is defined on page 281 of
Hardy and Wright.  It is the largest square of nodes contained in the
partition's Ferrers graph.  Function <code>durfee()</code> returns the
length of the side
of the Durfee square, which Andrews denotes
<code class="reqn">d(\lambda)</code>.  It is equivalent to <span class="rlang"><b>R</b></span> idiom
</p>
<p><code>function(a){sum(a&gt;=1:length(a))}</code>
</p>
<p>but is faster.
</p>


<h3>Value</h3>

<p>Returns either a partition in standard form, or a matrix whose
columns are partitions in standard form.
</p>


<h3>Note</h3>

<p>If argument <code>x</code> is not non-increasing, you must use the
<code>sorted = FALSE</code> flag. Otherwise, these functions will not work and will
silently return garbage.  Caveat emptor!  (output from <code>blockparts()</code>
is not necessarily non-increasing)
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>parts(5)
conjugate(parts(5))

restrictedparts(6,4)
conjugate(restrictedparts(6,4))

durfee(10:1)

# A partition in nonstandard form --- use `sorted = FALSE`
x &lt;- parts(5)[sample(5),]
durfee(x, sorted = FALSE)
conjugate(x, sorted = FALSE)

# Suppose one wanted partitions of 8 with no part larger than 3:

conjugate(restrictedparts(8,3))

# (restrictedparts(8,3) splits 8 into at most 3 parts;
# so no part of the conjugate partition is larger than 3).
</code></pre>

<hr>
<h2 id='nextpart'>Next partition</h2><span id='topic+nextpart'></span><span id='topic+islastpart'></span><span id='topic+firstpart'></span><span id='topic+nextdiffpart'></span><span id='topic+islastdiffpart'></span><span id='topic+firstdiffpart'></span><span id='topic+nextrestrictedpart'></span><span id='topic+islastrestrictedpart'></span><span id='topic+firstrestrictedpart'></span><span id='topic+nextblockpart'></span><span id='topic+islastblockpart'></span><span id='topic+firstblockpart'></span><span id='topic+nextcomposition'></span><span id='topic+islastcomposition'></span><span id='topic+firstcomposition'></span>

<h3>Description</h3>

<p>Given a partition, return the &ldquo;next&rdquo; one; or determine whether
it is the last one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  nextpart(part, check=TRUE)
islastpart(part)
 firstpart(n)
  nextdiffpart(part, check=TRUE)
islastdiffpart(part)
 firstdiffpart(n)
  nextrestrictedpart(part, check=TRUE)
islastrestrictedpart(part)
 firstrestrictedpart(n, m, include.zero=TRUE)
  nextblockpart(part, f, n=sum(part), include.fewer=FALSE, check=TRUE)
islastblockpart(part, f, n=NULL     , include.fewer=FALSE)
 firstblockpart(      f, n=NULL     , include.fewer=FALSE)
  nextcomposition(comp, restricted, include.zero=TRUE, check=TRUE)
islastcomposition(comp, restricted, include.zero=TRUE)
 firstcomposition(n,    m=NULL    , include.zero=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nextpart_+3A_part">part</code>, <code id="nextpart_+3A_comp">comp</code></td>
<td>
<p>A partition or composition</p>
</td></tr>
<tr><td><code id="nextpart_+3A_check">check</code></td>
<td>
<p>Boolean, with default <code>TRUE</code> meaning to carry out
various safety checks; the <code>next()</code> functions use <code>C</code>
calls which might crash the session with some inputs</p>
</td></tr>
<tr><td><code id="nextpart_+3A_f">f</code>, <code id="nextpart_+3A_n">n</code>, <code id="nextpart_+3A_include.fewer">include.fewer</code>, <code id="nextpart_+3A_m">m</code>, <code id="nextpart_+3A_include.zero">include.zero</code></td>
<td>
<p>Other arguments as per the
vectorized version</p>
</td></tr>
<tr><td><code id="nextpart_+3A_restricted">restricted</code></td>
<td>
<p>In function <code>nextcomposition()</code> and
<code>islastcomposition()</code>, Boolean, with <code>TRUE</code> meaning to
consider compositions of fixed length [eg, to iterate through the
columns of <code>compositions(6,3)</code>],  and
<code>FALSE</code> meaning to consider compositions of any length [eg to
iterate through the columns of <code>compositions(6)</code>]</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are intended to enumerate partitions one at a time,
eliminating the need to store a huge matrix.  This is useful for
optimization over large domains and makes it possible to investigate
larger partitions than is possible with the vectorized codes.
</p>
<p>The idea is to use a <code>first...()</code> function to generate the first
partition, then iterate using a <code>next...()</code> function, stopping when
the <code>islast...()</code> function returns <code>TRUE</code>.
</p>
<p>An example is given below, in which the &ldquo;scrabble&rdquo; problem is
solved;  note the small size of the sample space.   More examples are
given in the <code>tests/aab.R</code> file.
</p>


<h3>Note</h3>

<p>Functions <code>nextpart()</code> and <code>nextdiffpart()</code> require a vector
of the right length: they require and return a partition padded with
zeros.  Functions <code>nextrestrictedpart()</code> and
<code>nextblockpart()</code> work with partitions of the specified length.
Function <code>nextcomposition()</code> truncates any zeros at the end of
the composition.  This behaviour is inherited from the <code>C</code> code.
</p>
<p>In functions <code>nextcomposition()</code> and <code>firstcomposition()</code>,
argument <code>include.zero</code> is ignored if <code>restricted</code> is
<code>FALSE</code>.
</p>
<p>I must say that the performance of these functions is terrible;
they are much much slower than their vectorized equivalents.  The
magnitude of the difference is much larger than I expected.  Heigh
ho.  Frankly you would better off working directly in <code>C</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+parts">parts</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Do the optimization in scrabble vignette, one partition at a time:
# (but with a smaller letter bag)
scrabble &lt;- c(a=9 , b=2 , c=2 , d=4 , e=12 , f=2 , g=3)

f &lt;- function(a){prod(choose(scrabble,a))/choose(sum(scrabble),7)}
bestsofar &lt;- 0
a &lt;- firstblockpart(scrabble,7)
while(!islastpart(a)){
  jj &lt;- f(a)
  if(jj&gt;bestsofar){
    bestsofar &lt;- jj
    bestpart &lt;- a
  }
  a &lt;- nextblockpart(a,scrabble) 
}


</code></pre>

<hr>
<h2 id='P'>Number of partitions of an integer</h2><span id='topic+P'></span><span id='topic+Q'></span><span id='topic+R'></span><span id='topic+S'></span>

<h3>Description</h3>

<p>Given an integer, <code>P()</code> returns the number of additive
partitions, <code>Q()</code> returns the  number of unequal
partitions, and <code>R()</code> returns the number of
restricted partitions.  Function <code>S()</code> returns the number of
block partitions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>P(n, give = FALSE)
Q(n, give = FALSE)
R(m, n, include.zero = FALSE)
S(f, n = NULL, include.fewer = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="P_+3A_n">n</code></td>
<td>
<p>Integer whose partition number is desired.  In function
<code>S()</code>, the default of <code>NULL</code> means to return the number of
partitions of any size</p>
</td></tr>
<tr><td><code id="P_+3A_m">m</code></td>
<td>
<p>In function <code>R()</code>, the order of the
decomposition</p>
</td></tr>
<tr><td><code id="P_+3A_give">give</code></td>
<td>
<p>Boolean, with default <code>FALSE</code> meaning to return just
<code>P(n)</code> or <code>Q(n)</code> and <code>TRUE</code> meaning to return
<code>P(1:n)</code> or <code>Q(1:n)</code> (this option takes no extra
computation)</p>
</td></tr>
<tr><td><code id="P_+3A_include.zero">include.zero</code></td>
<td>
<p>In <code>restrictedparts()</code>, Boolean with
default <code>FALSE</code> meaning to count only partitions of <code class="reqn">n</code>
into <em>exactly</em> <code class="reqn">m</code> parts; and <code>TRUE</code> meaning to
include partitions of <code class="reqn">n</code> into <em>at most</em> <code class="reqn">m</code> parts
(because parts of zero are included)</p>
</td></tr>
<tr><td><code id="P_+3A_include.fewer">include.fewer</code></td>
<td>
<p>In function <code>blockparts()</code>, Boolean
with default <code>FALSE</code> meaning to return partitions into
<em>exactly</em> <code>n</code> and <code>TRUE</code> meaning to return partitions
into <em>at most</em> <code>n</code></p>
</td></tr>
<tr><td><code id="P_+3A_f">f</code></td>
<td>
<p>In function <code>S()</code>, the stack vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functions <code>P()</code> and <code>Q()</code> use Euler's
recursion formula.  Function <code>R()</code> enumerates the partitions 
using Hindenburg's method (see Andrews) and counts them until the
recursion bottoms out.
</p>
<p>Function <code>S()</code> finds the coefficient of <code class="reqn">x^n</code> in the
generating function <code class="reqn">\prod_{i=1}^L\sum_{j=0}^{f_i}
    x^j</code>, where <code class="reqn">L</code> is the
length of <code>f</code>, using the <span class="pkg">polynom</span> package.
</p>
<p>All these functions return a double.
</p>


<h3>Note</h3>

<p>Functions <code>P()</code> and <code>Q()</code> use <code>unsigned long long</code>
integers, a type which is system-dependent.  For me, <code>P()</code> works
for <code class="reqn">n</code> equal to or less than 416, and <code>Q()</code> works for
<code class="reqn">n</code> less than or equal to 792.  <abbr><span class="acronym">YMMV</span></abbr>; none of the
methods test for overflow, so use with care!
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin; <code>S()</code> is due to an anonymous JSS referee</p>


<h3>Examples</h3>

<pre><code class='language-R'>P(10,give=TRUE)
Q(10,give=TRUE)
R(10,20,include.zero=FALSE)
R(10,20,include.zero=TRUE)

S(1:4,5)

</code></pre>

<hr>
<h2 id='parts'>Enumerate the partitions of an integer

</h2><span id='topic+parts'></span><span id='topic+diffparts'></span><span id='topic+restrictedparts'></span><span id='topic+blockparts'></span><span id='topic+compositions'></span><span id='topic+multiset'></span><span id='topic+multinomial'></span><span id='topic+allbinom'></span><span id='topic+mset'></span><span id='topic+c_allblockparts'></span><span id='topic+c_alldiffparts'></span><span id='topic+c_allparts'></span><span id='topic+c_allperms'></span><span id='topic+c_allrestrictedparts'></span><span id='topic+c_bintocomp'></span><span id='topic+c_comptobin'></span><span id='topic+c_conjugate'></span><span id='topic+c_durfee'></span><span id='topic+c_nextblockpart'></span><span id='topic+c_nextdiffpart'></span><span id='topic+c_nextpart'></span><span id='topic+c_nextrestrictedpart'></span><span id='topic+c_plainperms'></span><span id='topic+c_multiset'></span><span id='topic+c_tobin'></span><span id='topic+c_wrap'></span><span id='topic+c_numbdiffparts'></span><span id='topic+c_numbparts'></span><span id='topic+numbrestrictedparts_R'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Given an integer, return a matrix whose columns enumerate various
partitions.
</p>
<p>Function <code>parts()</code> returns the unrestricted partitions; function
<code>diffparts()</code> returns the unequal partitions; function
<code>restrictedparts()</code> returns the restricted partitions; function
<code>blockparts()</code> returns the partitions subject to specified
maxima; and function <code>compositions()</code> returns all compositions
of the argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parts(n)
diffparts(n)
restrictedparts(n, m, include.zero=TRUE, decreasing=TRUE)
blockparts(f, n=NULL, include.fewer=FALSE)
compositions(n, m=NULL, include.zero=TRUE)
multiset(v,n=length(v))
mset(v)
multinomial(v)
allbinom(n,k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parts_+3A_n">n</code></td>
<td>
<p>Integer to be partitioned.  In function <code>blockparts()</code>,
the default of <code>NULL</code> means to return all partitions of any size</p>
</td></tr>
<tr><td><code id="parts_+3A_m">m</code></td>
<td>
<p>In functions <code>restrictedparts()</code> and
<code>compositions()</code>, the order of the partition</p>
</td></tr>
<tr><td><code id="parts_+3A_include.zero">include.zero</code></td>
<td>
<p>In functions <code>restrictedparts()</code> and
<code>compositions()</code>, Boolean with default <code>FALSE</code> meaning to
include only partitions of <i>n</i> into <em>exactly</em> <i>m</i>
parts; and <code>TRUE</code> meaning to include partitions of <i>n</i> into
<em>at most</em> <i>m</i> parts (because zero parts are included)</p>
</td></tr>
<tr><td><code id="parts_+3A_include.fewer">include.fewer</code></td>
<td>
<p>In function <code>blockparts()</code>, Boolean with
default <code>FALSE</code> meaning to return vectors whose sum is
<em>exactly</em> <code>n</code> and <code>TRUE</code> meaning to return partitions
whose sum is <em>at most</em> <code>n</code></p>
</td></tr>
<tr><td><code id="parts_+3A_decreasing">decreasing</code></td>
<td>
<p>In <code>restrictedparts()</code>, Boolean with default
<code>TRUE</code> meaning to return partitions whose parts are in
decreasing order and <code>FALSE</code> meaning to return partitions in
lexicographical order, as appearing in Hindenburg's
algorithm.   Note that setting to <code>decreasing</code> to <code>FALSE</code>
has the effect of making <code>conjugate()</code> return garbage</p>
</td></tr>
<tr><td><code id="parts_+3A_f">f</code></td>
<td>
<p>In function <code>blockparts()</code>, a vector of strictly
positive integers that gives the maximal number of blocks; see
details</p>
</td></tr>
<tr><td><code id="parts_+3A_v">v</code></td>
<td>
<p>In function <code>multiset()</code>, an integer vector representing
a multiset.  Argument <code>n</code> is the size of the sample to be
taken</p>
</td></tr>
<tr><td><code id="parts_+3A_k">k</code></td>
<td>
<p>In function <code>allbinom()</code>, the size of the set to be
chosen; arguments match those of <code>choose()</code></p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> Function <code>parts()</code> uses the algorithm in Andrews.
Function <code>diffparts()</code> uses a very similar algorithm that I
have not seen elsewhere.  These functions behave strangely if given
an argument of zero.
</p>
</li>
<li><p> Function <code>restrictedparts()</code> uses the algorithm in
Andrews, originally due to Hindenburg.  For partitions into at most
<i>m</i> parts, the same Hindenburg's algorithm is used but with a
start vector of <code>c(rep(0,m-1),n)</code>.
</p>
<p>Functions <code>parts()</code> and <code>restrictedparts()</code> overlap in
functionality.  Note, however, that they can return identical
partitions but in a different order: <code>parts(6)</code> and
<code>restrictedparts(6,6)</code> for example.
</p>
<p>If \(m>n\), the partitions are padded with zeros.
</p>
</li>
<li><p> Function <code>blockparts()</code> enumerates the compositions of an
integer subject to a maximum criterion: given vector
\(y=(y_1,\ldots,y_n)\) all sets of
\(a=(a_1,\ldots,a_n)\) satisfying
\(\sum_{i=1}^pa_i=n\) subject to \(0\leq a_i\leq
    y_i\) for all <i>i</i> are given in lexicographical
order.  If argument <code>y</code> includes zero elements, these are
treated consistently (ie a position with zero capacity).
</p>
<p>If <code>n</code> takes its default value of <code>NULL</code>, then the
restriction \(\sum_{i=1}^pa_i=n\) is relaxed (so that
the numbers may sum to anything).  Note that these solutions are not
necessarily in standard form, so functions <code>durfee()</code> and
<code>conjugate()</code> may fail.
</p>
</li>
<li><p> With a single argument, <code>compositions(n)</code> returns
all \(2^{n-1}\) ways of partitioning an integer; thus
<code>4+1+1</code> is distinct from <code>1+4+1</code> or <code>1+1+4</code>.
</p>
<p>With two arguments, <code>compositions(n,m)</code> returns all
nonnegative solutions to \(x_1+\cdots+x_m=n\).
</p>
<p>This function is different from all the others in the package in
that it is written in <span class="rlang"><b>R</b></span>; it is not clear that C would be any
faster.
</p>
</li>
<li><p> Function <code>multiset()</code> returns all ways of ordering a
multiset (<code>mset()</code> is a low-level helper function).
</p>
</li>
<li><p> Function <code>multinomial(v)</code> returns all ways of
partitioning a set into <em>distinguishable</em> boxes of capacities
<code>v[1], v[2],...,v[n]</code>.  The number of columns is given by the
multinomial coefficient \({\sum v_i\choose
	v_1\,v_2\,\ldots\,v_n}\).
</p>
</li>
<li><p> Function <code>allbinom(n,k)</code> is provided for convenience; it
enumerates the ways of choosing <i>k</i> objects from <code>n</code>.
</p>
</li></ul>



<h3>Note</h3>

<p>These vectorized functions return a matrix whose columns are the
partitions.  If this matrix is too large, consider enumerating the
partitions individually using the functionality documented in
<code>nextpart.Rd</code>.
</p>
<p>One commonly encountered idiom is <code>blockparts(rep(n,n),n)</code>, which
is equivalent to <code>compositions(n,n)</code> [Sloane's <code>A001700</code>].
</p>
<p>If you have a <em>minimum</em> number of balls in each block, a
construction like
</p>
<pre>x &lt;- c(1, 1, 2, 1)
y &lt;- c(2, 3, 4, 5)
sweep(blockparts(y - x, 7 - sum(x)), 1, x, "+")
                      
##: [1,] 2 1 2 1 1 2 1 1 1
##: [2,] 2 3 1 2 1 1 2 1 1
##: [3,] 2 2 3 3 4 2 2 3 2
##: [4,] 1 1 1 1 1 2 2 2 3
</pre>

<p>can be helpful (that is, subtract off the minimum number of balls and
add them back again at the end).
</p>
<pre>
    blockparts(c(4,3,3,2),5)  # Knuth's example, pre-fascicle 3a, p16
    multiset(c(1,2,2,3))      # also Knuth
  </pre>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>


<ul>
<li><p> G. E. Andrews. &ldquo;The theory of partitions&rdquo;,
Cambridge University Press, 1998
</p>
</li>
<li><p> R. K. S. Hankin 2006.  &ldquo;Additive integer partitions in
<span class="rlang"><b>R</b></span>&rdquo;. <em>Journal of Statistical Software</em>, Volume 16, code
snippet 1 
</p>
</li>
<li><p> R. K. S. Hankin 2007.  &ldquo;Urn sampling without
replacement: enumerative combinatorics in <span class="rlang"><b>R</b></span>&rdquo;. <em>Journal of
Statistical Software</em>, Volume 17, code snippet 1
</p>
</li>
<li><p> R. K. S. Hankin 2007.  &ldquo;Set partitions in
<span class="rlang"><b>R</b></span>&rdquo;. <em>Journal of Statistical Software</em>, Volume
23, code snippet 2
</p>
</li>
<li><p> N. J. A. Sloane, 2008, The On-Line Encyclopedia of Integer
Sequences.  Sequence A001700
</p>
</li>
<li><p> D. Knuth, 2004.  The art of computer programming, pre-fascicle
2B &ldquo;Generating all permutations&rdquo;
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+nextpart">nextpart</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>parts(7)
                                  
##: [1,] 7 6 5 5 4 4 4 3 3 3 3 2 2 2 1
##: [2,] 0 1 2 1 3 2 1 3 2 2 1 2 2 1 1
##: [3,] 0 0 0 1 0 1 1 1 2 1 1 2 1 1 1
##: [4,] 0 0 0 0 0 0 1 0 0 1 1 1 1 1 1
##: [5,] 0 0 0 0 0 0 0 0 0 0 1 0 1 1 1
##: [6,] 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1
##: [7,] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1
P(7)
##: [1] 15
diffparts(9)
                    
##: [1,] 9 8 7 6 6 5 5 4
##: [2,] 0 1 2 3 2 4 3 3
##: [3,] 0 0 0 0 1 0 1 2
Q(9)
##: [1] 8
restrictedparts(9, 4)
                                        
##: [1,] 9 8 7 6 5 7 6 5 4 5 4 3 6 5 4 4 3 3
##: [2,] 0 1 2 3 4 1 2 3 4 2 3 3 1 2 3 2 3 2
##: [3,] 0 0 0 0 0 1 1 1 1 2 2 3 1 1 1 2 2 2
##: [4,] 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 2
R(4, 9, include.zero = TRUE)
##: [1] 18
blockparts(1:4, 5)
                                                
##: [1,] 1 1 0 1 1 0 1 0 1 1 0 1 0 0 1 0 1 0 0 1 0 0
##: [2,] 2 1 2 2 1 2 0 1 2 1 2 0 1 0 1 2 0 1 0 0 1 0
##: [3,] 2 3 3 1 2 2 3 3 0 1 1 2 2 3 0 0 1 1 2 0 0 1
##: [4,] 0 0 0 1 1 1 1 1 2 2 2 2 2 2 3 3 3 3 3 4 4 4
S(1:4, 5)
##: [1] 22
compositions(5, 3)
                                              
##: [1,] 5 4 3 2 1 0 4 3 2 1 0 3 2 1 0 2 1 0 1 0 0
##: [2,] 0 1 2 3 4 5 0 1 2 3 4 0 1 2 3 0 1 2 0 1 0
##: [3,] 0 0 0 0 0 0 1 1 1 1 1 2 2 2 2 3 3 3 4 4 5
S(rep(5, 3), 5)
##: [1] 21
setparts(4)
                                  
##: [1,] 1 1 1 1 2 1 1 1 1 1 1 2 2 2 1
##: [2,] 1 1 1 2 1 2 1 2 2 1 2 1 1 3 2
##: [3,] 1 2 1 1 1 2 2 1 3 2 1 3 1 1 3
##: [4,] 1 1 2 1 1 1 2 2 1 3 3 1 3 1 4
setparts(c(1, 2, 2))
                                  
##: [1,] 1 1 1 1 1 1 1 1 1 1 1 1 3 3 3
##: [2,] 2 2 3 1 1 1 2 2 3 2 2 3 1 1 1
##: [3,] 3 2 2 3 2 2 1 1 1 3 2 2 2 1 2
##: [4,] 2 3 2 2 3 2 3 2 2 1 1 1 2 2 1
##: [5,] 1 1 1 2 2 3 2 3 2 2 3 2 1 2 2
multinomial(c(a = 1, b = 2, c = 1))
                         
##: a 1 1 1 2 2 3 4 3 4 2 3 4
##: b 2 2 3 1 1 1 1 1 1 3 2 2
##: b 3 4 4 3 4 2 2 4 3 4 4 3
##: c 4 3 2 4 3 4 3 2 2 1 1 1
</code></pre>

<hr>
<h2 id='perms'>Enumerate the permutations of a vector</h2><span id='topic+perms'></span><span id='topic+plainperms'></span>

<h3>Description</h3>

<p>Given an integer <code>n</code>, return a matrix whose columns enumerate various
permutations of <code>1:n</code>.
</p>
<p>Function <code>perms()</code> returns all permutations in lexicographic
order; function <code>plainperms()</code> returns all permutations by
repeatedly exchanging adjacent pairs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perms(n)
plainperms(n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="perms_+3A_n">n</code></td>
<td>
<p>Integer argument; permutations of <code>1:n</code> returned</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Comments in the <code>C</code> code; algorithm lifted from
&lsquo;<span class="file">fasc2b.pdf</span>&rsquo;.
</p>


<h3>Author(s)</h3>

<p>D. E. Knuth; <code>C</code> and <span class="rlang"><b>R</b></span> transliteration by Robin K. S. Hankin</p>


<h3>References</h3>


<ul>
<li><p> D. E. Knuth 2004.  &ldquo;The art of computer programming,
pre-fascicle 2B.  A draft of section 7.2.1.2: Generating all
permutations&rdquo;.
<code>https://www-cs-faculty.stanford.edu/~knuth/taocp.html</code></p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+parts">parts</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>perms(4)
summary(perms(5))

# Knuth's Figure 18:
matplot(t(apply(plainperms(4),2,order)),
        type='l', lty=1, lwd=5, asp=1,
        frame=FALSE, axes=FALSE, ylab="", col=gray((1:5)/5))

</code></pre>

<hr>
<h2 id='print.partition'>Print methods for partition objects and equivalence objects</h2><span id='topic+print.partition'></span><span id='topic+print.equivalence'></span><span id='topic+print.summary.partition'></span><span id='topic+print'></span>

<h3>Description</h3>

<p>A print method for partition objects, summary partition objects, and
equivalence classes.  Includes various configurable options
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'partition'
print(x, mat = getOption("matrixlike"), h = getOption("horiz"), ...)
## S3 method for class 'summary.partition'
print(x, ...)
## S3 method for class 'equivalence'
print(x, sep = getOption("separator"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.partition_+3A_x">x</code></td>
<td>
<p>Object to be printed: an object of class either
<code>partition</code> or <code>summary.partition</code></p>
</td></tr>
<tr><td><code id="print.partition_+3A_mat">mat</code></td>
<td>
<p>Boolean, with <code>TRUE</code> meaning to print like a matrix,
and any other value meaning to print without column names (which
usually results in more compact appearance)</p>
</td></tr>
<tr><td><code id="print.partition_+3A_h">h</code></td>
<td>
<p>Boolean governing the orientation of the printed matrix, with
<code>TRUE</code> meaning to print with the rows being the partitions and 
any other value (the default) meaning to print the transpose</p>
</td></tr>
<tr><td><code id="print.partition_+3A_sep">sep</code></td>
<td>
<p>Character vector, with special value of <code>NULL</code>
interpreted as a comma; see examples section</p>
</td></tr>
<tr><td><code id="print.partition_+3A_...">...</code></td>
<td>
<p>Further arguments provided for compatibility</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>print(parts(5))

summary(parts(7))

listParts(3)
options(separator="")
listParts(5)

</code></pre>

<hr>
<h2 id='riffle'>Riffle shuffles</h2><span id='topic+riffle'></span><span id='topic+genrif'></span><span id='topic+allriffles'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Enumeration of riffle shuffles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genrif(v)
riffle(p,q=p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="riffle_+3A_p">p</code>, <code id="riffle_+3A_q">q</code>, <code id="riffle_+3A_v">v</code></td>
<td>
<p>In function <code>riffle()</code>, integers <code>p</code>,<code>q</code>
specify the length of the two increasing sequences.  In function
<code>genrif()</code>, the elements of <code>v</code> specify the lengths of all
the increasing sequences: there are <code>sum(v)</code> cards in the pack</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <dfn>riffle shuffle</dfn> is a permutation of integers
\(1,2,\ldots,n\) containing one or two rising
sequences.
</p>
<p>A <dfn>generalized riffle shuffle</dfn>, or <dfn>\(r\)-riffle
shuffle</dfn>, contains at most \(r\) rising sequences.  This is not
implemented in the package (earlier versions included a buggy
version; the difficulty is ensuring that sequences do not appear
more than once).
</p>

<ul>
<li><p><code>riffle(p,q)</code> returns all riffle shuffles with rising
sequences of <code>1:p</code> and <code>(p+1):q</code>
</p>
</li>
<li><p><code>genrif(v)</code> returns all riffle shuffles with rising
sequences having lengths the entries of <code>v</code>, the deck being
numbered consecutively
</p>
</li></ul>



<h3>Value</h3>

<p>Returns a matrix of class <code>partition</code> with columns being 
riffle shuffles
</p>


<h3>Note</h3>

<p>When we say &ldquo;contains \(r\) rising sequences&rdquo; we generally
mean &ldquo;contains <em>at most</em> \(r\) rising sequences&rdquo;
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+parts">parts</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>riffle(3, 4)
                                                                          
##: [1,] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
##: [2,] 2 2 2 2 2 4 4 4 4 4 4 4 4 4 4 1 1 1 1 1 1 1 1 1 1 5 5 5 5 5 5 5 5 5 5
##: [3,] 3 4 4 4 4 2 2 2 2 5 5 5 5 5 5 2 2 2 2 5 5 5 5 5 5 1 1 1 1 1 1 6 6 6 6
##: [4,] 4 3 5 5 5 3 5 5 5 2 2 2 6 6 6 3 5 5 5 2 2 2 6 6 6 2 2 2 6 6 6 1 1 1 7
##: [5,] 5 5 3 6 6 5 3 6 6 3 6 6 2 2 7 5 3 6 6 3 6 6 2 2 7 3 6 6 2 2 7 2 2 7 1
##: [6,] 6 6 6 3 7 6 6 3 7 6 3 7 3 7 2 6 6 3 7 6 3 7 3 7 2 6 3 7 3 7 2 3 7 2 2
##: [7,] 7 7 7 7 3 7 7 7 3 7 7 3 7 3 3 7 7 7 3 7 7 3 7 3 3 7 7 3 7 3 3 7 3 3 3
genrif(1:3)
                                                                              
##: [1,] 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4 4 4 4 4 4 4
##: [2,] 2 2 2 2 4 4 4 4 4 4 1 1 1 1 3 3 3 3 4 4 4 4 4 4 4 4 4 4 4 4 1 1 1 1 1 1 2
##: [3,] 3 4 4 4 2 2 2 5 5 5 3 4 4 4 1 4 4 4 1 1 1 3 3 3 5 5 5 5 5 5 2 2 2 5 5 5 1
##: [4,] 4 3 5 5 3 5 5 2 2 6 4 3 5 5 4 1 5 5 3 5 5 1 5 5 1 1 3 3 6 6 3 5 5 2 2 6 3
##: [5,] 5 5 3 6 5 3 6 3 6 2 5 5 3 6 5 5 1 6 5 3 6 5 1 6 3 6 1 6 1 3 5 3 6 3 6 2 5
##: [6,] 6 6 6 3 6 6 3 6 3 3 6 6 6 3 6 6 6 1 6 6 3 6 6 1 6 3 6 1 3 1 6 6 3 6 3 3 6
                                                  
##: [1,] 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
##: [2,] 2 2 2 2 2 2 2 2 2 2 2 5 5 5 5 5 5 5 5 5 5 5 5
##: [3,] 1 1 3 3 3 5 5 5 5 5 5 1 1 1 2 2 2 2 2 2 6 6 6
##: [4,] 5 5 1 5 5 1 1 3 3 6 6 2 2 6 1 1 3 3 6 6 1 2 2
##: [5,] 3 6 5 1 6 3 6 1 6 1 3 3 6 2 3 6 1 6 1 3 2 1 3
##: [6,] 6 3 6 6 1 6 3 6 1 3 1 6 3 3 6 3 6 1 3 1 3 3 1
</code></pre>

<hr>
<h2 id='setparts'>Set partitions</h2><span id='topic+setparts'></span><span id='topic+listParts'></span><span id='topic+vec_to_set'></span><span id='topic+vec_to_eq'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Enumeration of set partitions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setparts(x)
listParts(x,do.set=FALSE)
vec_to_set(vec)
vec_to_eq(vec)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setparts_+3A_x">x</code></td>
<td>
<p>If a vector of length 1, the size of the set to be
partitioned.  If a vector of length greater than 1, return all
equivalence relations with equivalence classes with sizes of the
elements of <code>x</code>.  If a matrix, return all equivalence classes
with sizes of the columns of <code>x</code></p>
</td></tr>
<tr><td><code id="setparts_+3A_do.set">do.set</code></td>
<td>
<p>Boolean, with <code>TRUE</code> meaning to return  the set
partitions in terms of sets (as per <span class="pkg">sets</span> package) and default
<code>FALSE</code> meaning to present the result in terms of equivalence
classes</p>
</td></tr>
<tr><td><code id="setparts_+3A_vec">vec</code></td>
<td>
<p>An integer vector representing a set partition</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <dfn>partition</dfn> of a set
\(S=\left\lbrace 1,\ldots,n\right\rbrace\) is a family of
sets \(T_1,\ldots,T_k\) satisfying
</p>

<ul>
<li> <p>\(i\neq j\longrightarrow T_i\cap
      T_j=\emptyset\)
</p>
</li>
<li> <p>\(\cup_{i=1}^kT_k=S\)
</p>
</li>
<li> <p>\(T_i\neq\emptyset\) for \(i=1,\ldots,
      k\) 
</p>
</li></ul>

<p>The induced <dfn>equivalence relation</dfn> has \(i\sim j\) if and
only if <i>i</i> and <i>j</i> belong to the same partition.  Equivalence
classes of \(S=\left\lbrace 1,\ldots,n\right\rbrace\)
may be listed using <code>listParts()</code>.  Thus
</p>
<p>There are exactly fifteen ways to partition a set of four
elements:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <i>(1234)</i></td>
</tr>
<tr>
 <td style="text-align: left;">
    <i>(123)(4), (124)(3), (134)(2), (234)(1)</i></td>
</tr>
<tr>
 <td style="text-align: left;">
    <i>(12)(34), (13)(24), (14)(23)</i></td>
</tr>
<tr>
 <td style="text-align: left;">
    <i>(12)(3)(4), (13)(2)(4), (23)(1)(4), (24)(1)(3),
      (34)(1)(2)</i></td>
</tr>
<tr>
 <td style="text-align: left;">
    <i>(1)(2)(3)(4)</i>
  </td>
</tr>

</table>

<p>Note that <i>(12)(3)(4)</i> is the same partition as, for example,
<i>(3)(4)(21)</i> as the equivalence relation is the same.
</p>
<p>Consider partitions of a set <i>S</i> of five elements (named
<i>1,2,3,4,5</i>) with sizes 2,2,1.  These may be enumerated as
follows:
</p>
<pre>
&gt; u &lt;- c(2,2,1)
&gt; setparts(u)
                                  
[1,] 1 1 1 1 1 1 1 1 1 1 1 1 3 3 3
[2,] 2 2 3 1 1 1 2 2 3 2 2 3 1 1 1
[3,] 3 2 2 3 2 2 1 1 1 3 2 2 2 1 2
[4,] 2 3 2 2 3 2 3 2 2 1 1 1 2 2 1
[5,] 1 1 1 2 2 3 2 3 2 2 3 2 1 2 2

</pre>
<p>See how each column has two 1s, two 2s and one 3.  This is because the
first and second classes have size two, and the third has size one.
</p>
<p>The first partition, <code>x=c(1,2,3,2,1)</code>, is read &ldquo;class 1
contains elements 1 and 5 (because the first and fifth element of
<code>x</code> is 1); class 2 contains elements 2 and 4 (because the second
and fourth element of <code>x</code> is 2); and class 3 contains element 3
(because the third element of <code>x</code> is 3)&rdquo;.  Formally, class
<code>i</code> has elements <code>which(x==u[i])</code>.
</p>
<p>You can change the print method by setting, eg,
<code>option(separator="")</code>.
</p>
<p>Functions <code>vec_to_set()</code> and <code>vec_to_eq()</code> are low-level
helper functions.  These take an integer vector, typically a column of a
matrix produced by <code>setparts()</code> and return their set
representation.
</p>


<h3>Value</h3>

<p>Returns a matrix each of whose columns show a set partition; an object
of class <code>"partition"</code>.  Type <code>?print.partition</code> to see how
to change the options for printing.
</p>


<h3>Note</h3>

<p>The <span class="pkg">clue</span> package  by Kurt Hornik contains functionality for
partitions (specifically <code>cl_meet()</code> and <code>cl_join()</code>) which
might be useful.  Option <code>do.set</code> invokes functionality from the
<span class="pkg">sets</span> package by Meyer et al.
</p>
<p>Note carefully that <code>setparts(c(2,1,1))</code> does <em>not</em>
enumerate the ways of placing four numbered balls in three boxes of
capacities 2,1,1.  This is because there are two boxes of capacity 1,
and swapping the balls between these boxes gives the same set
partition (because sets are unordered).  To do this, use
<code>multinomial(c(a=2,b=1,c=1))</code>.  See the <code>setparts</code> vignette
for more details.
</p>


<h3>Author(s)</h3>

<p>Luke G. West (<code>C++</code>) and Robin K. S. Hankin (<span class="rlang"><b>R</b></span>);
<code>listParts()</code> provided by Diana Tichy
</p>


<h3>References</h3>


<ul>
<li><p> R. K. S. Hankin 2006.  <em>Additive integer partitions in
<span class="rlang"><b>R</b></span></em>.  Journal of Statistical Software, Code Snippets 16(1)
</p>
</li>
<li><p> R. K. S. Hankin 2007.  &ldquo;Set partitions in
<span class="rlang"><b>R</b></span>&rdquo;. <em>Journal of Statistical Software</em>, Volume
23, code snippet 2
</p>
</li>
<li><p>  Kurt Hornik (2017).  <em>clue: Cluster ensembles</em>.  R
package version 0.3-53. <a href="https://CRAN.R-project.org/package=clue">https://CRAN.R-project.org/package=clue</a>
</p>
</li>
<li><p>  Kurt Hornik (2005).  <em>A CLUE for Cluster Ensembles</em>.
Journal of Statistical Software 14/12.
<a href="https://doi.org/10.18637/jss.v014.i12">doi:10.18637/jss.v014.i12</a>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+parts">parts</a></code>, <code><a href="#topic+print.partition">print.partition</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>setparts(4)                # all partitions of a set of 4 elements

setparts(c(3,3,2))         # all partitions of a set of 8 elements
                           # into sets of sizes 3,3,2.


listParts(c(2,2,1))        # all 15 ways of defining subsets of
                           # {1,2,3,4,5} with sizes 2,2,1

jj &lt;- restrictedparts(5,3)
setparts(jj)               # partitions of a set of 5 elements into
                           # at most 3 sets

listParts(jj)              # The induced equivalence classes




jj &lt;- restrictedparts(6,3,TRUE)
setparts(jj)               # partitions of a set of 6 elements into
ncol(setparts(jj))         # _exactly_ 3 sets; cf StirlingS2[6,3]==90


setparts(conjugate(jj))    # partitions of a set of 5 elements into
                           # sets not exceeding 3 elements


setparts(diffparts(5))     # partitions of a set of 5 elements into
                           # sets of different sizes


</code></pre>

<hr>
<h2 id='summary.partition'>Provides a summary of a partition</h2><span id='topic+summary.partition'></span>

<h3>Description</h3>

<p>Provides a summary of an object of class <code>partition</code>: usually  the
first and last few partitions (columns)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'partition'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.partition_+3A_object">object</code></td>
<td>
<p>Partition</p>
</td></tr>
<tr><td><code id="summary.partition_+3A_...">...</code></td>
<td>
<p>Further arguments; see details section below</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ellipsis arguments are used to pass how many columns at the start
and the end of the matrix are selected; this defaults to 10.
</p>
<p>The function is designed to behave as expected: if there is an
argument named &ldquo;<code>n</code>&rdquo;, then this is used.  If there is no
such argument, the first one is used.
</p>


<h3>Value</h3>

<p>A summary object is a list, comprising three elements:
</p>
<table role = "presentation">
<tr><td><code>shortened</code></td>
<td>
<p>Boolean, with <code>TRUE</code> meaning that the middle
section of the matrix is omitted, and <code>FALSE</code> meaning that the
entire matrix is returned because <code>n</code> is too big</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>Number of columns to return at the start and the end of the matrix</p>
</td></tr>
<tr><td><code>out</code></td>
<td>
<p>Matrix returned: just the first and last <code>n</code> columns
(if <code>shortened</code> is <code>TRUE</code>), or the whole matrix if not</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(parts(7))

summary(parts(11),3)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
