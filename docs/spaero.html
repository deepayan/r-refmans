<!DOCTYPE html><html><head><title>Help for package spaero</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {spaero}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#create_simulator'><p>Create surveillance data simulator.</p></a></li>
<li><a href='#get_stats'><p>Get estimates of time-dependent properties of models.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Software for Project AERO</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements methods for anticipating the emergence and eradication
    of infectious diseases from surveillance time series. Also provides support
    for computational experiments testing the performance of such methods.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, utils</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | file LICENSE [expanded from: GPL (&ge; 2) | file LICENSE]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr (&ge; 3.0.0), earlywarnings (&ge; 1.0.59), knitr (&ge; 1.11),
moments (&ge; 0.14), np (&ge; 0.60.2), pomp (&ge; 2.1), rmarkdown (&ge;
0.9.2), testthat (&ge; 0.11.0)</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/e3bo/spaero/issues/">https://github.com/e3bo/spaero/issues/</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-09-26 01:35:35 UTC; rstudio</td>
</tr>
<tr>
<td>Author:</td>
<td>Eamon O'Dea [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Eamon O'Dea &lt;odea35@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-09-26 23:50:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='create_simulator'>Create surveillance data simulator.</h2><span id='topic+create_simulator'></span>

<h3>Description</h3>

<p><code>create_simulator</code> creates a pomp object that will run
simulations of an SIR or SIS model according to Gillespie's direct
method and generate simulated observations of the process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_simulator(
  times = seq(0, 9),
  t0 = min(times),
  process_model = c("SIR", "SIS"),
  transmission = c("density-dependent", "frequency-dependent"),
  params = c(gamma = 24, mu = 1/70, d = 1/70, eta = 1e-05, beta_par = 1e-04, rho = 0.1,
    S_0 = 1, I_0 = 0, R_0 = 0, N_0 = 1e+05, p = 0),
  covar = data.frame(gamma_t = c(0, 0), mu_t = c(0, 0), d_t = c(0, 0), eta_t = c(0, 0),
    beta_par_t = c(0, 0), p_t = c(0, 0), time = c(0, 1e+06))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_simulator_+3A_times">times</code></td>
<td>
<p>A numeric vector of increasing times at which the
state of the simulation will be sampled.</p>
</td></tr>
<tr><td><code id="create_simulator_+3A_t0">t0</code></td>
<td>
<p>The time at which the simulation is started with state
variable set to the initial conditions specified via params.</p>
</td></tr>
<tr><td><code id="create_simulator_+3A_process_model">process_model</code></td>
<td>
<p>Character string giving the process
model. Allowed values are '&quot;SIR&quot;' and '&quot;SIS&quot;'.</p>
</td></tr>
<tr><td><code id="create_simulator_+3A_transmission">transmission</code></td>
<td>
<p>Character string describing the transmission
model. Allowed values are '&quot;density-dependent&quot;' and
'&quot;frequency-dependent&quot;'.</p>
</td></tr>
<tr><td><code id="create_simulator_+3A_params">params</code></td>
<td>
<p>A named numeric vector of parameter values and
initial conditions.</p>
</td></tr>
<tr><td><code id="create_simulator_+3A_covar">covar</code></td>
<td>
<p>A data frame containing values of the time-dependent
components of the parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the vignette &quot;Getting Started with spaero&quot; for a description of
the model. The &quot;params&quot; argument must include all model
parameters. These will become the default parameters for the model
object. They can be overridden when the simulation is run via the
&quot;params&quot; argument of <code>pomp::simulate</code>. The case is the same
for the &quot;times&quot; argument. The &quot;covar&quot; argument should be a data
frame with a column named for each of the time-dependent parameters
and a column named time. This data frame describes the time series
of each of the time-dependent parameters. In the simulation,
interpolation based on this data frame determines the value of
these parameters at specific instants in time. The user must ensure
that these values result in the parameters remaining non-negative
for the course of the simulation.
</p>


<h3>Value</h3>

<p>A pomp object with which simulations can be run via
<code>pomp::simulate</code>.
</p>


<h3>See Also</h3>

<p><code><a href="pomp.html#topic+pomp">pomp</a></code> for documentation of pomp objects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
foo &lt;- create_simulator()
out &lt;- pomp::simulate(foo, times = seq(0, 20, by = 1/26))
out &lt;- as(out, "data.frame")
head(out)

opar &lt;- par(mfrow = c(2, 1))
plot((S/N)~time, data = out, type = "l")
plot(cases~time, data = out, type = "l")
par(opar)

</code></pre>

<hr>
<h2 id='get_stats'>Get estimates of time-dependent properties of models.</h2><span id='topic+get_stats'></span>

<h3>Description</h3>

<p><code>get_stats</code> estimates time-dependent properties of models
(e.g., variance) from ensemble time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_stats(
  x,
  center_trend = "grand_mean",
  center_kernel = c("gaussian", "uniform"),
  center_bandwidth = NULL,
  stat_trend = c("local_constant", "local_linear"),
  stat_kernel = c("uniform", "gaussian"),
  stat_bandwidth = NULL,
  lag = 1,
  backward_only = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_stats_+3A_x">x</code></td>
<td>
<p>A univariate or multivariate numeric time series object or
a numeric vector or matrix.</p>
</td></tr>
<tr><td><code id="get_stats_+3A_center_trend">center_trend</code></td>
<td>
<p>Character string giving method of calculating
the trend to subtract. Allowed values are '&quot;assume_zero&quot;',
'&quot;grand_mean&quot;', '&quot;ensemble_means&quot;', '&quot;local_constant&quot;', and
'&quot;local_linear&quot;'. Will be partially matched.</p>
</td></tr>
<tr><td><code id="get_stats_+3A_center_kernel">center_kernel</code></td>
<td>
<p>Character string giving the kernel for any
local detrending. Allowed values are '&quot;gaussian&quot;' and
'&quot;uniform&quot;'.</p>
</td></tr>
<tr><td><code id="get_stats_+3A_center_bandwidth">center_bandwidth</code></td>
<td>
<p>Bandwidth of kernel for any local detrending
done. A numeric value &gt;= 1.</p>
</td></tr>
<tr><td><code id="get_stats_+3A_stat_trend">stat_trend</code></td>
<td>
<p>Character string giving method of smoothing
estimates. Allowed values are '&quot;local_constant&quot;', and
'&quot;local_linear&quot;'. Will be partially matched.</p>
</td></tr>
<tr><td><code id="get_stats_+3A_stat_kernel">stat_kernel</code></td>
<td>
<p>Character string giving the kernel for local
smoothing of estimates. Allowed values are '&quot;gaussian&quot;' and
'&quot;uniform&quot;'.</p>
</td></tr>
<tr><td><code id="get_stats_+3A_stat_bandwidth">stat_bandwidth</code></td>
<td>
<p>Bandwidth of kernel for local smoothing of
estimates.  A numeric value &gt;= 1.</p>
</td></tr>
<tr><td><code id="get_stats_+3A_lag">lag</code></td>
<td>
<p>Integer lag at which to calculate the acf. This lag is
in terms of the index of <code>x</code> and does not account for the
frequency of <code>x</code> if <code>x</code> is a time series. It should
be non-negative.</p>
</td></tr>
<tr><td><code id="get_stats_+3A_backward_only">backward_only</code></td>
<td>
<p>Logical value (defaulting to 'FALSE') that
determines whether any uniform smoothing kernels are restricted
to using data before the index of the smoothed estimate.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Any missing values in 'x' will cause an error.
</p>
<p>Bandwidths affect weights in local smoothers as follows. To get the
local estimate corresponding to index i, the distance to each other
index j is calculated as (i - j) / h, where h is the
bandwidth. Then that distance is plugged into the kernel function
to obtain a weight. The weights are normalized to sum to one for
each index.
</p>
<p>The gaussian kernel is equivalent to a standard Gaussian density
function. The uniform kernel is an indicator function of whether
the distance is less than 1. Thus selecting a uniform kernel with a
bandwidth of 2 is equivalent to a sliding window of length 3 that
is centered on the focal index. In general, if n is the greatest
integer that is less than the value of the bandwidth h, the window
includes the n nearest values on each side of the focal index.
</p>
<p>'&quot;local_constant&quot;' smoothers are local means computed with the
kernel weights. '&quot;local_linear&quot;' smoothers are the fitted values of
local linear regressions with the kernel weights. The linear
smoothers avoid biases that the one-sided kernels at the ends of
the time series can create for the local constant smoothers.
</p>
<p>See the vignette &quot;Getting Started with spaero&quot; for the formulas
used for each estimate.
</p>


<h3>Value</h3>

<p>A list with elements '&quot;stats&quot;', '&quot;taus&quot;', '&quot;centered&quot;',
'&quot;stat_trend&quot;', '&quot;stat_kernel&quot;', '&quot;stat_bandwidth&quot;', and
'&quot;lag&quot;'. &quot;stats&quot; is a list containing vectors of the
estimates. '&quot;taus&quot;' is a list containing Kendall's correlation
coefficient of each element of '&quot;stats&quot;' with
time. '&quot;centered&quot;' is a list of the detrended time series, the
trend subtracted, and the bandwidth used in the detrending. The
other elements record the parameters provided to this function
for future reference.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+acf">acf</a></code>, <code><a href="stats.html#topic+var">var</a></code>,
<code><a href="moments.html#topic+kurtosis">kurtosis</a></code>, and
<code><a href="moments.html#topic+skewness">skewness</a></code> for estimation of properties that
are not time-dependent. See
<code><a href="earlywarnings.html#topic+generic_ews">generic_ews</a></code> for another approach to
estimation of time-dependent properties.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# A highly autocorrelated time series
x &lt;- 1:10
get_stats(x, stat_bandwidth = 3)$stats

# Plot log of acf
plot(log(get_stats(x, stat_bandwidth = 3)$stats$autocor))

# Check estimates with AR1 simulations with lag-1 core 0.1
w &lt;- rnorm(1000)
xnext &lt;- function(xlast, w) 0.1 * xlast + w
x &lt;- Reduce(xnext, x = w, init = 0, accumulate = TRUE)
acf(x, lag.max = 1, plot = FALSE)
head(get_stats(x, stat_bandwidth = length(x))$stats$autocor)

# Check detrending ability
x2 &lt;- x + seq(1, 10, len = length(x))
ans &lt;- get_stats(x2, center_trend = "local_linear",
                  center_bandwidth = length(x),
                   stat_bandwidth = length(x))$stats
head(ans$autocor)

# The simple acf estimate is inflated by the trend
acf(x2, lag.max = 1, plot = FALSE)

# Check ability to estimate time-dependent autocorrelation
xnext &lt;- function(xlast, w) 0.8 * xlast + w
xhi &lt;- Reduce(xnext, x = w, init = 0, accumulate = TRUE)
acf(xhi, lag.max = 1, plot = FALSE)
wt &lt;- seq(0, 1, len = length(x))
xdynamic &lt;- wt * xhi + (1 - wt) * x
get_stats(xdynamic, stat_bandwidth = 100)$stats$autocor
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
