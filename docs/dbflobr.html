<!DOCTYPE html><html><head><title>Help for package dbflobr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dbflobr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#dbflobr-package'><p>dbflobr: Read and Write Files to SQLite Databases</p></a></li>
<li><a href='#add_blob_column'><p>Add blob column</p></a></li>
<li><a href='#delete_flob'><p>Delete flob</p></a></li>
<li><a href='#import_all_flobs'><p>Import all flobs.</p></a></li>
<li><a href='#import_flobs'><p>Import flobs.</p></a></li>
<li><a href='#read_flob'><p>Read flob</p></a></li>
<li><a href='#save_all_flobs'><p>Save all flobs.</p></a></li>
<li><a href='#save_flobs'><p>Save flobs.</p></a></li>
<li><a href='#write_flob'><p>Write flob</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Read and Write Files to SQLite Databases</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Reads and writes files to SQLite databases
    <a href="https://www.sqlite.org/index.html">https://www.sqlite.org/index.html</a> as flobs (a flob is a blob that
    preserves the file extension).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/poissonconsulting/dbflobr">https://github.com/poissonconsulting/dbflobr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/poissonconsulting/dbflobr/issues">https://github.com/poissonconsulting/dbflobr/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>blob, chk, clisymbols, crayon, DBI, flobr, glue, rlang,
RSQLite</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, knitr, rmarkdown, testthat, withr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-19 21:55:02 UTC; evanamies-galonski</td>
</tr>
<tr>
<td>Author:</td>
<td>Sebastian Dalgarno
    <a href="https://orcid.org/0000-0002-3658-4517"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Joe Thorley <a href="https://orcid.org/0000-0002-7683-4592"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Evan Amies-Galonski
    <a href="https://orcid.org/0000-0003-1096-2089"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Poisson Consulting [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Evan Amies-Galonski &lt;evan@poissonconsulting.ca&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-19 22:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='dbflobr-package'>dbflobr: Read and Write Files to SQLite Databases</h2><span id='topic+dbflobr'></span><span id='topic+dbflobr-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Reads and writes files to SQLite databases <a href="https://www.sqlite.org/index.html">https://www.sqlite.org/index.html</a> as flobs (a flob is a blob that preserves the file extension).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Evan Amies-Galonski <a href="mailto:evan@poissonconsulting.ca">evan@poissonconsulting.ca</a> (<a href="https://orcid.org/0000-0003-1096-2089">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Sebastian Dalgarno <a href="mailto:seb@northbeachconsulting.ca">seb@northbeachconsulting.ca</a> (<a href="https://orcid.org/0000-0002-3658-4517">ORCID</a>)
</p>
</li>
<li><p> Joe Thorley <a href="mailto:joe@poissonconsulting.ca">joe@poissonconsulting.ca</a> (<a href="https://orcid.org/0000-0002-7683-4592">ORCID</a>)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Poisson Consulting [copyright holder, funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/poissonconsulting/dbflobr">https://github.com/poissonconsulting/dbflobr</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/poissonconsulting/dbflobr/issues">https://github.com/poissonconsulting/dbflobr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='add_blob_column'>Add blob column</h2><span id='topic+add_blob_column'></span>

<h3>Description</h3>

<p>Add named empty blob column to SQLite database
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_blob_column(column_name, table_name, conn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_blob_column_+3A_column_name">column_name</code></td>
<td>
<p>A string of the name of the BLOB column.</p>
</td></tr>
<tr><td><code id="add_blob_column_+3A_table_name">table_name</code></td>
<td>
<p>A string of the name of the existing table.</p>
</td></tr>
<tr><td><code id="add_blob_column_+3A_conn">conn</code></td>
<td>
<p>A SQLite connection object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Modified SQLite database.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>conn &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
DBI::dbWriteTable(conn, "Table1", data.frame(IntColumn = c(1L, 2L)))
DBI::dbReadTable(conn, "Table1")
add_blob_column("BlobColumn", "Table1", conn)
DBI::dbReadTable(conn, "Table1")
DBI::dbDisconnect(conn)
</code></pre>

<hr>
<h2 id='delete_flob'>Delete flob</h2><span id='topic+delete_flob'></span>

<h3>Description</h3>

<p>Delete a flob from a SQLite database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delete_flob(column_name, table_name, key, conn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delete_flob_+3A_column_name">column_name</code></td>
<td>
<p>A string of the name of the BLOB column.</p>
</td></tr>
<tr><td><code id="delete_flob_+3A_table_name">table_name</code></td>
<td>
<p>A string of the name of the existing table.</p>
</td></tr>
<tr><td><code id="delete_flob_+3A_key">key</code></td>
<td>
<p>A data.frame whose columns and values are used to filter the
table to a single row (this in combination with the <code>column_name</code>
argument are used to target a single cell within the table to modify).</p>
</td></tr>
<tr><td><code id="delete_flob_+3A_conn">conn</code></td>
<td>
<p>A SQLite connection object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An invisible copy of the deleted flob.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>flob &lt;- flobr::flob_obj
conn &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
DBI::dbWriteTable(conn, "Table1", data.frame(IntColumn = c(1L, 2L)))
key &lt;- data.frame(IntColumn = 2L)
write_flob(flob, "BlobColumn", "Table1", key, conn, exists = FALSE)
DBI::dbReadTable(conn, "Table1")
delete_flob("BlobColumn", "Table1", key, conn)
DBI::dbReadTable(conn, "Table1")
DBI::dbDisconnect(conn)
</code></pre>

<hr>
<h2 id='import_all_flobs'>Import all flobs.</h2><span id='topic+import_all_flobs'></span>

<h3>Description</h3>

<p>Import <code><a href="flobr.html#topic+flob">flob</a></code>s to SQLite database from directory.
Table and column names are matched to directory names within main directory.
Values in file names are matched to table primary key to determine where to write flob.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import_all_flobs(
  conn,
  dir = ".",
  sep = "_-_",
  pattern = ".*",
  sub = FALSE,
  exists = FALSE,
  replace = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="import_all_flobs_+3A_conn">conn</code></td>
<td>
<p>A SQLite connection object.</p>
</td></tr>
<tr><td><code id="import_all_flobs_+3A_dir">dir</code></td>
<td>
<p>A string of the path to the directory to import the files from.
Files need to be within nested folders like 'table1/column1/a.csv'.
This structure is created automatically if save_all_flobs() function is used.</p>
</td></tr>
<tr><td><code id="import_all_flobs_+3A_sep">sep</code></td>
<td>
<p>A string of the separator between values in file names.</p>
</td></tr>
<tr><td><code id="import_all_flobs_+3A_pattern">pattern</code></td>
<td>
<p>A regular expression specifying the pattern file names must match.</p>
</td></tr>
<tr><td><code id="import_all_flobs_+3A_sub">sub</code></td>
<td>
<p>A logical scalar specifying whether to import flobs based on their filename (sub = FALSE)
or the name of their subdirectory (sub = TRUE) which must only contain 1 file.
If sub = NA and replace = TRUE then the names of the
subdirectories are used irrespective of whether they include files and existing
flobs are deleted if the corresponding subdirectory is empty.
If sub = TRUE or sub = NA then recursion is just one subfolder deep.</p>
</td></tr>
<tr><td><code id="import_all_flobs_+3A_exists">exists</code></td>
<td>
<p>A logical scalar specifying whether the column must (TRUE) or
mustn't (FALSE) already exist or whether it doesn't matter (NA).
IF FALSE, a new BLOB column is created.</p>
</td></tr>
<tr><td><code id="import_all_flobs_+3A_replace">replace</code></td>
<td>
<p>A flag indicating whether to replace existing flobs (TRUE) or not (FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An invisible named list indicating directory path,
file names and whether files were successfully written to database.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>conn &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
DBI::dbGetQuery(conn, "CREATE TABLE Table1 (CharColumn TEXT PRIMARY KEY NOT NULL)")
DBI::dbWriteTable(conn, "Table1", data.frame(CharColumn = c("a", "b")), append = TRUE)
flob &lt;- flobr::flob_obj
write_flob(flob, "BlobColumn", "Table1", data.frame(CharColumn = "a"), conn)
dir &lt;- file.path(tempdir(), "import_all")
save_all_flobs(conn = conn, dir = dir)
import_all_flobs(conn, dir, exists = TRUE, replace = TRUE)
DBI::dbDisconnect(conn)
</code></pre>

<hr>
<h2 id='import_flobs'>Import flobs.</h2><span id='topic+import_flobs'></span>

<h3>Description</h3>

<p>Import <code><a href="flobr.html#topic+flob">flob</a></code>s to SQLite database column from directory.
Values in file name are matched to table primary key to determine where to write flob.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import_flobs(
  column_name,
  table_name,
  conn,
  dir = ".",
  sep = "_-_",
  pattern = ".*",
  sub = FALSE,
  exists = FALSE,
  recursive = FALSE,
  replace = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="import_flobs_+3A_column_name">column_name</code></td>
<td>
<p>A string of the name of the BLOB column.</p>
</td></tr>
<tr><td><code id="import_flobs_+3A_table_name">table_name</code></td>
<td>
<p>A string of the name of the existing table.</p>
</td></tr>
<tr><td><code id="import_flobs_+3A_conn">conn</code></td>
<td>
<p>A SQLite connection object.</p>
</td></tr>
<tr><td><code id="import_flobs_+3A_dir">dir</code></td>
<td>
<p>A string of the path to the directory to import files from.</p>
</td></tr>
<tr><td><code id="import_flobs_+3A_sep">sep</code></td>
<td>
<p>A string of the separator between values in file names.</p>
</td></tr>
<tr><td><code id="import_flobs_+3A_pattern">pattern</code></td>
<td>
<p>A regular expression specifying the pattern file names must match.</p>
</td></tr>
<tr><td><code id="import_flobs_+3A_sub">sub</code></td>
<td>
<p>A logical scalar specifying whether to import flobs based on their filename (sub = FALSE)
or the name of their subdirectory (sub = TRUE) which must only contain 1 file.
If sub = NA and replace = TRUE then the names of the
subdirectories are used irrespective of whether they include files and existing
flobs are deleted if the corresponding subdirectory is empty.
If sub = TRUE or sub = NA then recursion is just one subfolder deep.</p>
</td></tr>
<tr><td><code id="import_flobs_+3A_exists">exists</code></td>
<td>
<p>A logical scalar specifying whether the column must (TRUE) or
mustn't (FALSE) already exist or whether it doesn't matter (NA).
IF FALSE, a new BLOB column is created.</p>
</td></tr>
<tr><td><code id="import_flobs_+3A_recursive">recursive</code></td>
<td>
<p>A flag indicating whether to recurse into file directory (TRUE) or not (FALSE).</p>
</td></tr>
<tr><td><code id="import_flobs_+3A_replace">replace</code></td>
<td>
<p>A flag indicating whether to replace existing flobs (TRUE) or not (FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An invisible named vector indicating file name and whether the file was
successfully written to database.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>conn &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
DBI::dbGetQuery(conn, "CREATE TABLE Table1 (CharColumn TEXT PRIMARY KEY NOT NULL)")
DBI::dbWriteTable(conn, "Table1", data.frame(CharColumn = c("a", "b")), append = TRUE)
key &lt;- data.frame(CharColumn = "a", stringsAsFactors = FALSE)[0,,drop = FALSE]
dir &lt;- tempdir()
write.csv(key, file.path(dir, "a.csv"))
import_flobs("BlobColumn", "Table1", conn, dir)
DBI::dbDisconnect(conn)
</code></pre>

<hr>
<h2 id='read_flob'>Read flob</h2><span id='topic+read_flob'></span>

<h3>Description</h3>

<p>Read a <code><a href="flobr.html#topic+flob">flob</a></code> from a SQLite database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_flob(column_name, table_name, key, conn, slob = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_flob_+3A_column_name">column_name</code></td>
<td>
<p>A string of the name of the BLOB column.</p>
</td></tr>
<tr><td><code id="read_flob_+3A_table_name">table_name</code></td>
<td>
<p>A string of the name of the existing table.</p>
</td></tr>
<tr><td><code id="read_flob_+3A_key">key</code></td>
<td>
<p>A data.frame whose columns and values are used to filter the
table to a single row (this in combination with the <code>column_name</code>
argument are used to target a single cell within the table to modify).</p>
</td></tr>
<tr><td><code id="read_flob_+3A_conn">conn</code></td>
<td>
<p>A SQLite connection object.</p>
</td></tr>
<tr><td><code id="read_flob_+3A_slob">slob</code></td>
<td>
<p>A logical scalar specifying whether to process as slobs (serialized blobs) instead of flobs.
If NA, the function will adapt accordingly.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A flob or blob.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>flob &lt;- flobr::flob_obj
conn &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
DBI::dbWriteTable(conn, "Table1", data.frame(IntColumn = c(1L, 2L)))
key &lt;- data.frame(IntColumn = 2L)
write_flob(flob, "BlobColumn", "Table1", key, conn, exists = FALSE)
read_flob("BlobColumn", "Table1", key, conn)
DBI::dbDisconnect(conn)
</code></pre>

<hr>
<h2 id='save_all_flobs'>Save all flobs.</h2><span id='topic+save_all_flobs'></span>

<h3>Description</h3>

<p>Rename <code><a href="flobr.html#topic+flob">flob</a></code>s from a SQLite database and save to directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save_all_flobs(
  table_name = NULL,
  conn,
  dir = ".",
  sep = "_-_",
  sub = FALSE,
  replace = FALSE,
  geometry = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="save_all_flobs_+3A_table_name">table_name</code></td>
<td>
<p>A vector of character strings indicating names of tables to save flobs from.
By default all tables are included.</p>
</td></tr>
<tr><td><code id="save_all_flobs_+3A_conn">conn</code></td>
<td>
<p>A SQLite connection object.</p>
</td></tr>
<tr><td><code id="save_all_flobs_+3A_dir">dir</code></td>
<td>
<p>A string of the path to the directory to save the files in.</p>
</td></tr>
<tr><td><code id="save_all_flobs_+3A_sep">sep</code></td>
<td>
<p>A string of the separator used to construct file names from values.</p>
</td></tr>
<tr><td><code id="save_all_flobs_+3A_sub">sub</code></td>
<td>
<p>A logical scalar specifying whether to save all existing files in a subdirectory
of the same name (sub = TRUE) or all possible files in a subdirectory
of the same name (sub = NA) or not nest files within a subdirectory (sub = FALSE).</p>
</td></tr>
<tr><td><code id="save_all_flobs_+3A_replace">replace</code></td>
<td>
<p>A flag specifying whether to replace existing files.
If sub = TRUE (or sub = NA) and replace = TRUE then all existing files
within a subdirectory are deleted.</p>
</td></tr>
<tr><td><code id="save_all_flobs_+3A_geometry">geometry</code></td>
<td>
<p>A flag specifying whether to search columns named geometry for flobs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An invisible named list of named vectors of the file names and new file names saved.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>flob &lt;- flobr::flob_obj
conn &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
DBI::dbGetQuery(conn, "CREATE TABLE Table1 (IntColumn INTEGER PRIMARY KEY NOT NULL)")
DBI::dbWriteTable(conn, "Table1", data.frame(IntColumn = c(1L, 2L)), append = TRUE)
key &lt;- data.frame(IntColumn = 2L)
write_flob(flob, "BlobColumn", "Table1", key, conn, exists = FALSE)
dir &lt;- tempdir()
save_all_flobs(conn = conn, dir = dir)
DBI::dbDisconnect(conn)
</code></pre>

<hr>
<h2 id='save_flobs'>Save flobs.</h2><span id='topic+save_flobs'></span>

<h3>Description</h3>

<p>Rename <code><a href="flobr.html#topic+flob">flob</a></code>s from a SQLite database BLOB column and save to directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save_flobs(
  column_name,
  table_name,
  conn,
  dir = ".",
  sep = "_-_",
  sub = FALSE,
  replace = FALSE,
  slob_ext = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="save_flobs_+3A_column_name">column_name</code></td>
<td>
<p>A string of the name of the BLOB column.</p>
</td></tr>
<tr><td><code id="save_flobs_+3A_table_name">table_name</code></td>
<td>
<p>A string of the name of the existing table.</p>
</td></tr>
<tr><td><code id="save_flobs_+3A_conn">conn</code></td>
<td>
<p>A SQLite connection object.</p>
</td></tr>
<tr><td><code id="save_flobs_+3A_dir">dir</code></td>
<td>
<p>A string of the path to the directory to save the files in.</p>
</td></tr>
<tr><td><code id="save_flobs_+3A_sep">sep</code></td>
<td>
<p>A string of the separator used to construct file names from values.</p>
</td></tr>
<tr><td><code id="save_flobs_+3A_sub">sub</code></td>
<td>
<p>A logical scalar specifying whether to save all existing files in a subdirectory
of the same name (sub = TRUE) or all possible files in a subdirectory
of the same name (sub = NA) or not nest files within a subdirectory (sub = FALSE).</p>
</td></tr>
<tr><td><code id="save_flobs_+3A_replace">replace</code></td>
<td>
<p>A flag specifying whether to replace existing files.
If sub = TRUE (or sub = NA) and replace = TRUE then all existing files
within a subdirectory are deleted.</p>
</td></tr>
<tr><td><code id="save_flobs_+3A_slob_ext">slob_ext</code></td>
<td>
<p>A string of the file extension to use if slobs (serialized blobs) are encountered.
If slob_ext = NULL slobs will be ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An invisible named vector of the file names and new file names saved.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>flob &lt;- flobr::flob_obj
conn &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
DBI::dbGetQuery(conn, "CREATE TABLE Table1 (IntColumn INTEGER PRIMARY KEY NOT NULL)")
DBI::dbWriteTable(conn, "Table1", data.frame(IntColumn = c(1L, 2L)), append = TRUE)
key &lt;- data.frame(IntColumn = 2L)
write_flob(flob, "BlobColumn", "Table1", key, conn, exists = FALSE)
dir &lt;- tempdir()
save_flobs("BlobColumn", "Table1", conn, dir)
DBI::dbDisconnect(conn)
</code></pre>

<hr>
<h2 id='write_flob'>Write flob</h2><span id='topic+write_flob'></span>

<h3>Description</h3>

<p>Write a <code><a href="flobr.html#topic+flob">flob</a></code> to a SQLite database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_flob(flob, column_name, table_name, key, conn, exists = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_flob_+3A_flob">flob</code></td>
<td>
<p>A flob.</p>
</td></tr>
<tr><td><code id="write_flob_+3A_column_name">column_name</code></td>
<td>
<p>A string of the name of the BLOB column.</p>
</td></tr>
<tr><td><code id="write_flob_+3A_table_name">table_name</code></td>
<td>
<p>A string of the name of the existing table.</p>
</td></tr>
<tr><td><code id="write_flob_+3A_key">key</code></td>
<td>
<p>A data.frame whose columns and values are used to filter the
table to a single row (this in combination with the <code>column_name</code>
argument are used to target a single cell within the table to modify).</p>
</td></tr>
<tr><td><code id="write_flob_+3A_conn">conn</code></td>
<td>
<p>A SQLite connection object.</p>
</td></tr>
<tr><td><code id="write_flob_+3A_exists">exists</code></td>
<td>
<p>A logical scalar specifying whether the column must (TRUE) or
mustn't (FALSE) already exist or whether it doesn't matter (NA).
IF FALSE, a new BLOB column is created.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An invisible copy of flob.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>flob &lt;- flobr::flob_obj
conn &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
DBI::dbWriteTable(conn, "Table1", data.frame(IntColumn = c(1L, 2L)))
DBI::dbReadTable(conn, "Table1")
key &lt;- data.frame(IntColumn = 2L)
write_flob(flob, "BlobColumn", "Table1", key, conn, exists = FALSE)
DBI::dbReadTable(conn, "Table1")
DBI::dbDisconnect(conn)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
