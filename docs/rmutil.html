<!DOCTYPE html><html lang="en"><head><title>Help for package rmutil</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rmutil}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Beta+20Binomial'><p>Beta Binomial Distribution</p></a></li>
<li><a href='#Box-Cox'><p>Box-Cox Distribution</p></a></li>
<li><a href='#Burr'><p>Burr Distribution</p></a></li>
<li><a href='#capply'><p>A Fast Simplified Version of <code>tapply</code></p></a></li>
<li><a href='#Consul'><p>Consul Distribution</p></a></li>
<li><a href='#contrast'><p>Contrast Matrix for Constraints about the Mean</p></a></li>
<li><a href='#DataMethods'><p>Methods for response, tccov, tvcov, and repeated Data Objects</p></a></li>
<li><a href='#dftorep'><p>Transform a Dataframe to a repeated Object</p></a></li>
<li><a href='#Double+20Binomial'><p>Double Binomial Distribution</p></a></li>
<li><a href='#DoublePoisson'><p>Double Poisson Distribution</p></a></li>
<li><a href='#finterp'><p>Formula Interpreter</p></a></li>
<li><a href='#fmobj'><p>Object Finder</p></a></li>
<li><a href='#fnenvir'><p>Check Covariates and Parameters of a Function</p></a></li>
<li><a href='#FormulaMethods'><p>Methods for formulafn Functions</p></a></li>
<li><a href='#Gamma+20Count'><p>Gamma Count Distribution</p></a></li>
<li><a href='#gauss.hermite'><p>Calculate Gauss-Hermite Quadrature Points</p></a></li>
<li><a href='#Generalized+20Extreme+20Value'><p>Generalized Extreme Value Distribution</p></a></li>
<li><a href='#Generalized+20Gamma'><p>Generalized Gamma Distribution</p></a></li>
<li><a href='#Generalized+20Inverse+20Gaussian'><p>Generalized Inverse Gaussian Distribution</p></a></li>
<li><a href='#Generalized+20Logistic'><p>Generalized Logistic Distribution</p></a></li>
<li><a href='#Generalized+20Weibull'><p>Generalized Weibull Distribution</p></a></li>
<li><a href='#gettvc'><p>Find the Most Recent Value of a Time-varying Covariate</p>
Before Each Observed Response</a></li>
<li><a href='#Hjorth'><p>Hjorth Distribution</p></a></li>
<li><a href='#int'><p>Vectorized Numerical Integration</p></a></li>
<li><a href='#int2'><p>Vectorized Two-dimensional Numerical Integration</p></a></li>
<li><a href='#Inverse+20Gaussian'><p>Inverse Gaussian Distribution</p></a></li>
<li><a href='#iprofile'><p>Produce Individual Time Profiles for Plotting</p></a></li>
<li><a href='#Laplace'><p>Laplace Distribution</p></a></li>
<li><a href='#Levy'><p>Levy Distribution</p></a></li>
<li><a href='#lin.diff.eqn'><p>Solution of Autonomous Linear Differential Equations</p></a></li>
<li><a href='#lvna'><p>Create a repeated Object, Leaving NAs</p></a></li>
<li><a href='#mexp'><p>Matrix Exponentiation</p></a></li>
<li><a href='#mpower'><p>Power of a Matrix</p></a></li>
<li><a href='#mprofile'><p>Produce Marginal Time Profiles for Plotting</p></a></li>
<li><a href='#Multiplicative+20Binomial'><p>Multiplicative Binomial Distribution</p></a></li>
<li><a href='#MultPoisson'><p>Multiplicative Poisson Distribution</p></a></li>
<li><a href='#Pareto'><p>Pareto Distribution</p></a></li>
<li><a href='#pkpd'><p>Pharmacokinetic Compartment Models</p></a></li>
<li><a href='#plot.residuals'><p>Plot Residuals</p></a></li>
<li><a href='#PowerExponential'><p>Power Exponential Distribution</p></a></li>
<li><a href='#PvfPoisson'><p>Power Variance Function Poisson Distribution</p></a></li>
<li><a href='#read.list'><p>Read a List of Matrices from a File for Unbalanced Repeated</p>
Measurements</a></li>
<li><a href='#read.rep'><p>Read a Rectangular Data Set from a File to Create a repeated Object</p></a></li>
<li><a href='#read.surv'><p>Read a List of Matrices from a File for Repeated Times to Events</p></a></li>
<li><a href='#restovec'><p>Create a response Object</p></a></li>
<li><a href='#rmna'><p>Create a repeated Object, Removing NAs</p></a></li>
<li><a href='#rmutil'><p>Utilities for Repeated Measurements Library</p></a></li>
<li><a href='#runge.kutta'><p>Runge-Kutta Method for Solving Differential Equations</p></a></li>
<li><a href='#Simplex'><p>Simplex Distribution</p></a></li>
<li><a href='#SkewLaplace'><p>Skew Laplace Distribution</p></a></li>
<li><a href='#tcctomat'><p>Create a Time-constant, Inter-individual Covariate (tccov) Object</p></a></li>
<li><a href='#tvctomat'><p>Create a Time-varying, Intra-individual Covariate (tvcov) Object</p></a></li>
<li><a href='#Two-Sided+20Power'><p>Two-Sided Power Distribution</p></a></li>
<li><a href='#wr'><p>Find the Response Vector and Design Matrix for a W&amp;R Model Formula</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.1.10</td>
</tr>
<tr>
<td>Title:</td>
<td>Utilities for Nonlinear Regression and Repeated Measurements
Models</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 1.4)</td>
</tr>
<tr>
<td>Description:</td>
<td>A toolkit of functions for nonlinear regression and repeated
    measurements not to be used by itself but called by other Lindsey packages such
    as 'gnlm', 'stable', 'growth', 'repeated', and 'event' 
    (available at <a href="https://www.commanster.eu/rcode.html">https://www.commanster.eu/rcode.html</a>).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.commanster.eu/rcode.html">https://www.commanster.eu/rcode.html</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/swihart/rmutil/issues">https://github.com/swihart/rmutil/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-10-26 22:48:02 UTC; swihartbj</td>
</tr>
<tr>
<td>Author:</td>
<td>Bruce Swihart [cre, aut],
  Jim Lindsey [aut] (Jim created this package, Bruce is maintaining the
    CRAN version),
  K. Sikorski [ctb, cph] (Wrote TOMS614/INTHP, https://calgo.acm.org/),
  F. Stenger [ctb, cph] (Wrote TOMS614/INTHP, https://calgo.acm.org/),
  J. Schwing [ctb, cph] (Wrote TOMS614/INTHP, https://calgo.acm.org/)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Bruce Swihart &lt;bruce.swihart@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-10-27 04:32:35 UTC</td>
</tr>
</table>
<hr>
<h2 id='Beta+20Binomial'>Beta Binomial Distribution</h2><span id='topic+dbetabinom'></span><span id='topic+pbetabinom'></span><span id='topic+qbetabinom'></span><span id='topic+rbetabinom'></span>

<h3>Description</h3>

<p>These functions provide information about the beta binomial
distribution with parameters <code>m</code> and <code>s</code>: density,
cumulative distribution, quantiles, and random generation.
Compared to the parameterization of 'VGAM::pbetabinom.ab',
<code>m = alpha/(alpha+beta)</code> and <code>s = (alpha+beta)</code>.
See examples.
</p>
<p>The beta binomial distribution with total <code class="reqn">= n</code> and
<code>prob</code> <code class="reqn">= m</code> has density
</p>
<p style="text-align: center;"><code class="reqn">p(y) = \frac{B(y+\sigma \mu, n-y+\sigma*(1-\mu)) {n \choose y}
}{B(s m,s (1-m))}%
</code>
</p>

<p>for <code class="reqn">y = 0, \ldots, n</code> where <code class="reqn">B()</code> is the beta function.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbetabinom(y, size, m, s, log=FALSE)
pbetabinom(q, size, m, s)
qbetabinom(p, size, m, s)
rbetabinom(n, size, m, s)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Beta+2B20Binomial_+3A_y">y</code></td>
<td>
<p>vector of frequencies</p>
</td></tr>
<tr><td><code id="Beta+2B20Binomial_+3A_q">q</code></td>
<td>
<p>vector of quantiles</p>
</td></tr>
<tr><td><code id="Beta+2B20Binomial_+3A_p">p</code></td>
<td>
<p>vector of probabilities</p>
</td></tr>
<tr><td><code id="Beta+2B20Binomial_+3A_n">n</code></td>
<td>
<p>number of values to generate</p>
</td></tr>
<tr><td><code id="Beta+2B20Binomial_+3A_size">size</code></td>
<td>
<p>vector of totals</p>
</td></tr>
<tr><td><code id="Beta+2B20Binomial_+3A_m">m</code></td>
<td>
<p>vector of probabilities of success; Compared to the parameterization of 'VGAM::pbetabinom.ab',
<code>m = alpha/(alpha+beta)</code> where <code>shape1=alpha</code> and <code>shape2=beta</code>. See examples.</p>
</td></tr>
<tr><td><code id="Beta+2B20Binomial_+3A_s">s</code></td>
<td>
<p>vector of overdispersion parameters; Compared to the parameterization of 'VGAM::pbetabinom.ab', <code>s = (alpha+beta)</code> where <code>shape1=alpha</code> and <code>shape2=beta</code>. See examples.</p>
</td></tr>
<tr><td><code id="Beta+2B20Binomial_+3A_log">log</code></td>
<td>
<p>if TRUE, log probabilities are supplied.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J.K. Lindsey</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dbinom">dbinom</a></code> for the binomial, <code><a href="#topic+ddoublebinom">ddoublebinom</a></code> for
the double binomial, and <code><a href="#topic+dmultbinom">dmultbinom</a></code>
for the multiplicative binomial distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># compute P(45 &lt; y &lt; 55) for y beta binomial(100,0.5,1.1)
sum(dbetabinom(46:54, 100, 0.5, 1.1))
pbetabinom(54,100,0.5,1.1)-pbetabinom(45,100,0.5,1.1)
pbetabinom(2,10,0.5,1.1)
qbetabinom(0.33,10,0.5,1.1)
rbetabinom(10,10,0.5,1.1)
## compare to VGAM
## Not run: 
# The beta binomial distribution with total = n and prob = m has density
# 
# p(y) = B(y+s m,n-y+s (1-m)) Choose(n,y) / B(s m,s (1-m))
# 
# for y = 0, …, n where B() is the beta function.

## in `rmutil` from the .Rd file (excerpt above), the "alpha" is s*m
## in `rmutil` from the .Rd file (excerpt above), the "beta"  is s*(1-m)

## in `VGAM`, rho is 1/(1+alpha+beta)

qq = 2.2
zz = 100

alpha = 1.1
beta  = 2
VGAM::pbetabinom.ab(q=qq, size=zz, shape1=alpha, shape2=beta)

## for VGAM `rho`
rr = 1/(1+alpha+beta)
VGAM::pbetabinom   (q=qq, size=zz, prob=mm, rho = rr)

## for rmutil `m` and `s`:
mm = alpha / (alpha+beta)
ss = (alpha+beta)
rmutil::pbetabinom(q=qq, size=zz, m=mm, s=ss )

## End(Not run)
</code></pre>

<hr>
<h2 id='Box-Cox'>Box-Cox Distribution</h2><span id='topic+dboxcox'></span><span id='topic+pboxcox'></span><span id='topic+qboxcox'></span><span id='topic+rboxcox'></span>

<h3>Description</h3>

<p>These functions provide information about the Box-Cox
distribution with location parameter equal to <code>m</code>, dispersion
equal to <code>s</code>, and power transformation equal to <code>f</code>: density,
cumulative distribution, quantiles, log hazard, and random generation.
</p>
<p>The Box-Cox distribution has density
</p>
<p style="text-align: center;"><code class="reqn">
f(y) =
\frac{1}{\sqrt{2 \pi \sigma^2}} \exp(-((y^\nu/\nu-\mu)^2/(2 \sigma^2)))/
(1-I(\nu&lt;0)-sign(\nu)*pnorm(0,\mu,sqrt(\sigma)))</code>
</p>

<p>where <code class="reqn">\mu</code> is the location parameter of the distribution,
<code class="reqn">\sigma</code> is the dispersion, <code class="reqn">\nu</code> is the family
parameter, <code class="reqn">I()</code> is the indicator function, and <code class="reqn">y&gt;0</code>.
</p>
<p><code class="reqn">\nu=1</code> gives a truncated normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dboxcox(y, m, s=1, f=1, log=FALSE)
pboxcox(q, m, s=1, f=1)
qboxcox(p, m, s=1, f=1)
rboxcox(n, m, s=1, f=1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Box-Cox_+3A_y">y</code></td>
<td>
<p>vector of responses.</p>
</td></tr>
<tr><td><code id="Box-Cox_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Box-Cox_+3A_p">p</code></td>
<td>
<p>vector of probabilities</p>
</td></tr>
<tr><td><code id="Box-Cox_+3A_n">n</code></td>
<td>
<p>number of values to generate</p>
</td></tr>
<tr><td><code id="Box-Cox_+3A_m">m</code></td>
<td>
<p>vector of location parameters.</p>
</td></tr>
<tr><td><code id="Box-Cox_+3A_s">s</code></td>
<td>
<p>vector of dispersion parameters.</p>
</td></tr>
<tr><td><code id="Box-Cox_+3A_f">f</code></td>
<td>
<p>vector of power parameters.</p>
</td></tr>
<tr><td><code id="Box-Cox_+3A_log">log</code></td>
<td>
<p>if TRUE, log probabilities are supplied.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J.K. Lindsey</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dnorm">dnorm</a></code> for the normal or Gaussian distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dboxcox(2, 5, 5, 2)
pboxcox(2, 5, 5, 2)
qboxcox(0.1, 5, 5, 2)
rboxcox(10, 5, 5, 2)
</code></pre>

<hr>
<h2 id='Burr'>Burr Distribution</h2><span id='topic+dburr'></span><span id='topic+pburr'></span><span id='topic+qburr'></span><span id='topic+rburr'></span>

<h3>Description</h3>

<p>These functions provide information about the Burr distribution with
location parameter equal to <code>m</code>, dispersion equal to
<code>s</code>, and family parameter equal to <code>f</code>: density,
cumulative distribution, quantiles, log hazard, and random generation.
</p>
<p>The Burr distribution has density
</p>
<p style="text-align: center;"><code class="reqn">
f(y) = \frac{\nu \sigma (y / \mu)^{\sigma-1}}
{\mu (1+(y/\mu)^\sigma)^{\nu+1}}</code>
</p>

<p>where <code class="reqn">\mu</code> is the location parameter of the distribution,
<code class="reqn">\sigma</code> is the dispersion, and <code class="reqn">\nu</code> is the family
parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dburr(y, m, s, f, log=FALSE)
pburr(q, m, s, f)
qburr(p, m, s, f)
rburr(n, m, s, f)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Burr_+3A_y">y</code></td>
<td>
<p>vector of responses.</p>
</td></tr>
<tr><td><code id="Burr_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Burr_+3A_p">p</code></td>
<td>
<p>vector of probabilities</p>
</td></tr>
<tr><td><code id="Burr_+3A_n">n</code></td>
<td>
<p>number of values to generate</p>
</td></tr>
<tr><td><code id="Burr_+3A_m">m</code></td>
<td>
<p>vector of location parameters.</p>
</td></tr>
<tr><td><code id="Burr_+3A_s">s</code></td>
<td>
<p>vector of dispersion parameters.</p>
</td></tr>
<tr><td><code id="Burr_+3A_f">f</code></td>
<td>
<p>vector of family parameters.</p>
</td></tr>
<tr><td><code id="Burr_+3A_log">log</code></td>
<td>
<p>if TRUE, log probabilities are supplied.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J.K. Lindsey</p>


<h3>Examples</h3>

<pre><code class='language-R'>dburr(2, 5, 1, 2)
pburr(2, 5, 1, 2)
qburr(0.3, 5, 1, 2)
rburr(10, 5, 1, 2)
</code></pre>

<hr>
<h2 id='capply'>A Fast Simplified Version of <code>tapply</code></h2><span id='topic+capply'></span>

<h3>Description</h3>

<p>a fast simplified version of <code>tapply</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>capply(x, index, fcn=sum)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="capply_+3A_x">x</code></td>
<td>
<p>x</p>
</td></tr>
<tr><td><code id="capply_+3A_index">index</code></td>
<td>
<p>index</p>
</td></tr>
<tr><td><code id="capply_+3A_fcn">fcn</code></td>
<td>
<p>default sum</p>
</td></tr>
</table>


<h3>Details</h3>

<p>a fast simplified version of tapply
</p>


<h3>Value</h3>

<p>Returns <code>ans</code> where <code>for(i in split(x,index))ans &lt;- c(ans,fcn(i))</code>.
</p>

<hr>
<h2 id='Consul'>Consul Distribution</h2><span id='topic+dconsul'></span><span id='topic+pconsul'></span><span id='topic+qconsul'></span><span id='topic+rconsul'></span>

<h3>Description</h3>

<p>These functions provide information about the Consul
distribution with parameters <code>m</code> and <code>s</code>: density,
cumulative distribution, quantiles, and random generation.
</p>
<p>The Consul distribution with <code>mu</code> <code class="reqn">= m</code> has density
</p>
<p style="text-align: center;"><code class="reqn">p(y) = \mu \exp(-(\mu+y(\lambda-1))/\lambda) (\mu+y(\lambda-1))^(y-1)/(\lambda^y y!)%
</code>
</p>

<p>for <code class="reqn">y = 0, \ldots</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dconsul(y, m, s, log=FALSE)
pconsul(q, m, s)
qconsul(p, m, s)
rconsul(n, m, s)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Consul_+3A_y">y</code></td>
<td>
<p>vector of counts</p>
</td></tr>
<tr><td><code id="Consul_+3A_q">q</code></td>
<td>
<p>vector of quantiles</p>
</td></tr>
<tr><td><code id="Consul_+3A_p">p</code></td>
<td>
<p>vector of probabilities</p>
</td></tr>
<tr><td><code id="Consul_+3A_n">n</code></td>
<td>
<p>number of values to generate</p>
</td></tr>
<tr><td><code id="Consul_+3A_m">m</code></td>
<td>
<p>vector of means</p>
</td></tr>
<tr><td><code id="Consul_+3A_s">s</code></td>
<td>
<p>vector of overdispersion parameters</p>
</td></tr>
<tr><td><code id="Consul_+3A_log">log</code></td>
<td>
<p>if TRUE, log probabilities are supplied.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dpois">dpois</a></code> for the Poisson, <code><a href="#topic+ddoublepois">ddoublepois</a></code> for
the double Poisson, <code><a href="#topic+dmultpois">dmultpois</a></code> for
the multiplicative Poisson, and <code><a href="#topic+dpvfpois">dpvfpois</a></code> for the power
variance function Poisson.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dconsul(5,10,0.9)
pconsul(5,10,0.9)
qconsul(0.08,10,0.9)
rconsul(10,10,0.9)
</code></pre>

<hr>
<h2 id='contrast'>Contrast Matrix for Constraints about the Mean</h2><span id='topic+contr.mean'></span>

<h3>Description</h3>

<p>Return a matrix of contrasts for constraints about the mean.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contr.mean(n, contrasts = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="contrast_+3A_n">n</code></td>
<td>
<p>A vector of levels for a factor or the number of levels.</p>
</td></tr>
<tr><td><code id="contrast_+3A_contrasts">contrasts</code></td>
<td>
<p>A logical value indicating whether or not contrasts
should be computed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function corrects <code><a href="stats.html#topic+contr.sum">contr.sum</a></code> to display labels properly.
</p>


<h3>Value</h3>

<p>A matrix of computed contrasts with <code>n</code> rows and <code>k</code>
columns, with <code>k=n-1</code> if <code>contrasts</code> is <code>TRUE</code> and
<code>k=n</code> if <code>contrasts</code> is <code>FALSE</code>. The columns of the
resulting matrices contain contrasts which can be used for coding a
factor with <code>n</code> levels.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+contrasts">contrasts</a></code>, <code><a href="stats.html#topic+C">C</a></code>,
and <code><a href="stats.html#topic+contr.sum">contr.sum</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oldop &lt;- options(contrasts=c("contr.sum","contra.poly"))
y &lt;- rnorm(30)
x &lt;- gl(3,10,labels=c("First","Second","Third"))
glm(y~x)
options(contrasts=c("contr.mean","contra.poly"))
x &lt;- gl(3,10,labels=c("First","Second","Third"))
glm(y~x)
options(oldop)
</code></pre>

<hr>
<h2 id='DataMethods'>Methods for response, tccov, tvcov, and repeated Data Objects</h2><span id='topic+DataMethods'></span><span id='topic+as.data.frame'></span><span id='topic+as.data.frame.repeated'></span><span id='topic+as.data.frame.response'></span><span id='topic+as.data.frame.tccov'></span><span id='topic+as.data.frame.tvcov'></span><span id='topic+as.matrix'></span><span id='topic+as.matrix.repeated'></span><span id='topic+as.matrix.response'></span><span id='topic+as.matrix.tccov'></span><span id='topic+as.matrix.tvcov'></span><span id='topic+coef.gnlm'></span><span id='topic+covariates'></span><span id='topic+covariates.tccov'></span><span id='topic+covariates.tvcov'></span><span id='topic+covariates.repeated'></span><span id='topic+covind'></span><span id='topic+covind.default'></span><span id='topic+delta'></span><span id='topic+delta.response'></span><span id='topic+delta.repeated'></span><span id='topic+description'></span><span id='topic+description.default'></span><span id='topic+description.repeated'></span><span id='topic+deviance.gnlm'></span><span id='topic+df.residual.gnlm'></span><span id='topic+formula'></span><span id='topic+formula.tccov'></span><span id='topic+formula.repeated'></span><span id='topic+names'></span><span id='topic+names.response'></span><span id='topic+names.tccov'></span><span id='topic+names.tvcov'></span><span id='topic+names.repeated'></span><span id='topic+nesting'></span><span id='topic+nesting.response'></span><span id='topic+nesting.repeated'></span><span id='topic+nobs'></span><span id='topic+nobs.default'></span><span id='topic+nobs.response'></span><span id='topic+nobs.tvcov'></span><span id='topic+nobs.data.frame'></span><span id='topic+plot.response'></span><span id='topic+plot.repeated'></span><span id='topic+print.response'></span><span id='topic+print.tccov'></span><span id='topic+print.tvcov'></span><span id='topic+print.repeated'></span><span id='topic+print.fmobj'></span><span id='topic+print.gnlm'></span><span id='topic+response'></span><span id='topic+response.response'></span><span id='topic+response.repeated'></span><span id='topic+resptype'></span><span id='topic+resptype.response'></span><span id='topic+resptype.repeated'></span><span id='topic+times'></span><span id='topic+times.default'></span><span id='topic+times.response'></span><span id='topic+transform'></span><span id='topic+transform.response'></span><span id='topic+transform.tccov'></span><span id='topic+transform.tvcov'></span><span id='topic+transform.repeated'></span><span id='topic+units'></span><span id='topic+units.default'></span><span id='topic+units.repeated'></span><span id='topic+vcov.gnlm'></span><span id='topic+weights'></span><span id='topic+weights.response'></span><span id='topic+weights.repeated'></span><span id='topic+weights.gnlm'></span>

<h3>Description</h3>

<p>Objects of class, <code>response</code>, contain response values, and possibly
the corresponding times, binomial totals, nesting categories, censor
indicators, and/or units of precision/Jacobian. Objects of class,
<code>tccov</code>, contain time-constant or inter-individual, baseline
covariates. Objects of class, <code>tvcov</code>, contain time-varying or
intra-individual covariates. Objects of class, <code>repeated</code>,
contain a <code>response</code> object and possibly <code>tccov</code> and
<code>tvcov</code> objects.
</p>
<p>In formula and functions, the key words, <code>times</code> can be used to
refer to the response times from the data object as a covariate,
<code>individuals</code> to the index for individuals as a factor covariate,
and <code>nesting</code> the index for nesting as a factor covariate. The
latter two only work for W&amp;R notation.
</p>
<p>The following methods are available for accessing the contents of such
data objects.
</p>
<p><code>as.data.frame</code>: places all of the variables in the data object
in one dataframe, extending time-constant covariates to the length of
the others unless the object has class, <code>tccov</code>. Binomial and
censored response variables have two columns, respectively &lsquo;yes&rsquo; and
&lsquo;no&rsquo; and response and censoring indicator, with the name given to the
response.
</p>
<p><code>as.matrix</code>: places all of the variables in the data object
in one matrix, extending time-constant covariates to the length of
the others unless the object has class, <code>tccov</code>. If any
covariates are factor variables (instead of the corresponding sets of
indicator variables), the matrix will be character instead of numeric.
</p>
<p><code>covariates</code>: extracts covariate matrices from a data object (for
formulae and functions, possibly for selected individuals. See
<code><a href="#topic+covariates.formulafn">covariates.formulafn</a></code>).
</p>
<p><code>covind</code>: gives the indexing of the response by individual (that
is, the nesting indicator for observations within individuals). It can
be used to expand time-constant covariates to the size of the repeated
measurements response.
</p>
<p><code>delta</code>: extracts the units of measurement vector and Jacobian of
any transformation of the response, possibly for selected individuals.
Note that, if the unit of measurement/Jacobian is available in the
<code>response</code> object, this is automatically included in the
calculation of the likelihood function in all library model functions.
</p>
<p><code>units</code>: prints the variable names and their description
and returns the latter.
</p>
<p><code>formula</code>: gives the formula used to create the time-constant
covariate matrix of a data object (for formulae and functions, see
<code><a href="#topic+formula.formulafn">formula.formulafn</a></code>).
</p>
<p><code>names</code>: extracts the names of the response and/or covariates.
</p>
<p><code>nesting</code>: gives the coding variable(s) for individuals (same as
<code>covind</code>) and also for nesting within individuals if available,
possibly for selected individuals.
</p>
<p><code>nobs</code>: gives the number of observations per individual.
</p>
<p><code>plot</code>: plots the variables in the data object in various ways.
For <code>repeated</code> objects, <code>name</code> can be a response or a
time-varying covariate.
</p>
<p><code>print</code>: prints summary information about the variables in a data object.
</p>
<p><code>response</code>: extracts the response vector, possibly for selected
individuals. If there are censored observations, this is a two-column
matrix, with the censor indicator in the second column. For binomial
data, it is a two-column matrix with &quot;positive&quot; (y) and &quot;negative&quot;
(totals-y) frequencies.
</p>
<p><code>resptype</code>: extracts the type of each response.
</p>
<p><code>times</code>: extracts the times vector, possibly for selected
individuals.
</p>
<p><code>transform</code>: transforms variables. For example,
<code>transform(z, y=fcn1(y), times=fcn2(times))</code> where <code>fcn1</code>
and <code>fcn2</code> are transformation functions. When the response is
transformed, the Jacobian is automatically calculated. New response
variables and covariates can be created in this way, if the left hand
side is a new name (<code>ynew=fcn3(y)</code>), as well as replacing an old
variable with the transformed one. If the transformation reverses the
order of the responses, use its negative to keep the ordering and have
a positive Jacobian; for example, <code>ry=-1/y</code>. For <code>repeated</code>
objects, only the response and the times can be transformed.
</p>
<p><code>units</code>: prints the variable names and their units of measurement
and returns the latter.
</p>
<p><code>weights</code>: extracts the weight vector, possibly for selected
individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.data.frame(x, ...)
as.matrix(x, ...)
covariates(z, ...)
covind(z, ...)
delta(z, ...)
## S3 method for class 'tccov'
formula(x, ...)
## S3 method for class 'repeated'
formula(x, ...)
## S3 method for class 'tccov'
names(x, ...)
## S3 method for class 'repeated'
names(x, ...)
nesting(z, ...)
nobs(z, ...)
## S3 method for class 'response'
plot(x, name=NULL, nind=NULL, nest=1, ccov=NULL, add=FALSE, lty=NULL, pch=NULL,
	main=NULL, ylim=NULL, xlim=NULL, xlab=NULL, ylab=NULL, ...)
## S3 method for class 'repeated'
plot(x, name=NULL, nind=NULL, nest=1, ccov=NULL, add=FALSE, lty=NULL, pch=NULL,
	main=NULL, ylim=NULL, xlim=NULL, xlab=NULL, ylab=NULL, ...)
## S3 method for class 'tccov'
print(x, ...)
## S3 method for class 'repeated'
print(x, nindmax=50, ...)
response(z, ...)
resptype(z, ...)
times(z, ...)
## S3 method for class 'response'
transform(`_data`, times=NULL, units=NULL, ...)
## S3 method for class 'repeated'
transform(`_data`, times=NULL, ...)
units(x, ...)
## S3 method for class 'gnlm'
weights(object, ...)
## S3 method for class 'repeated'
weights(object, nind=NULL, ...)
## S3 method for class 'response'
weights(object, nind=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DataMethods_+3A_x">x</code>, <code id="DataMethods_+3A_z">z</code></td>
<td>
<p>A <code>response</code>, <code>tccov</code>, <code>tvcov</code>, or
<code>repeated</code> data object. For <code>covind</code> and <code>nobs</code>, this
may also be a model.</p>
</td></tr>
<tr><td><code id="DataMethods_+3A_times">times</code></td>
<td>
<p>The function, when the times are to be transformed.</p>
</td></tr>
<tr><td><code id="DataMethods_+3A_names">names</code></td>
<td>
<p>The names of the response variable(s) or covariate(s).</p>
</td></tr>
<tr><td><code id="DataMethods_+3A_nind">nind</code></td>
<td>
<p>The numbers of individuals to be used. (For plotting,
cannot be used simultaneously with <code>ccov</code>.)</p>
</td></tr>
<tr><td><code id="DataMethods_+3A_ccov">ccov</code></td>
<td>
<p>For plotting: If a vector of values for the time-constant
covariates is supplied, only individuals having that set of values
will have profiles plotted. These values must be in the order in which
the covariates appear when the data object is printed. For factor
variables, the codes must be given. If the name of a covariate is
supplied, a set of graphs is plotted, one for each covariate value,
showing profiles of all individuals having that value. (The covariate
can have a maximum of six values.) Cannot be used simultaneously with
<code>nind</code>.</p>
</td></tr> 
<tr><td><code id="DataMethods_+3A_nest">nest</code></td>
<td>
<p>For plotting: nesting category to plot.</p>
</td></tr>
<tr><td><code id="DataMethods_+3A_add">add</code></td>
<td>
<p>For plotting: add to previous plot.</p>
</td></tr>
<tr><td><code id="DataMethods_+3A_nindmax">nindmax</code></td>
<td>
<p>For printing a <code>response</code>, <code>tvcov</code>, or
<code>repeated</code> object, if the number of individuals is greater than
<code>nindmax</code>, the range of numbers of observations per individual is
printed instead of the vector of numbers.</p>
</td></tr>
<tr><td><code id="DataMethods_+3A_name">name</code>, <code id="DataMethods_+3A_lty">lty</code>, <code id="DataMethods_+3A_pch">pch</code>, <code id="DataMethods_+3A_main">main</code>, <code id="DataMethods_+3A_ylim">ylim</code>, <code id="DataMethods_+3A_xlim">xlim</code>, <code id="DataMethods_+3A_xlab">xlab</code>, <code id="DataMethods_+3A_ylab">ylab</code></td>
<td>
<p> See base plot.</p>
</td></tr>
<tr><td><code id="DataMethods_+3A__data">_data</code>, <code id="DataMethods_+3A_units">units</code>, <code id="DataMethods_+3A_object">object</code></td>
<td>
<p> TBD.</p>
</td></tr>
<tr><td><code id="DataMethods_+3A_...">...</code></td>
<td>
<p> Arguments to other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>These methods extract information stored in <code>response</code>,
<code>tccov</code>, <code>tvcov</code>, and <code>repeated</code> data objects created
respectively by <code><a href="#topic+restovec">restovec</a></code>, <code><a href="#topic+tcctomat">tcctomat</a></code>,
<code><a href="#topic+tvctomat">tvctomat</a></code>, and <code><a href="#topic+rmna">rmna</a></code>.
</p>
<p>Note that if a vector of binomial totals or a censoring indicator is
present, this is extract as the second column of the matrix produced
by the <code>response</code> method.
</p>


<h3>Author(s)</h3>

<p>J.K. Lindsey</p>


<h3>See Also</h3>

<p><code><a href="#topic+restovec">restovec</a></code>, <code><a href="#topic+rmna">rmna</a></code>,
<code><a href="#topic+tcctomat">tcctomat</a></code>, <code><a href="#topic+tvctomat">tvctomat</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># set up some data and create the objects
#
y &lt;- matrix(rnorm(20),ncol=5)
tt &lt;- c(1,3,6,10,15)
print(resp &lt;- restovec(y, times=tt, units="m", type="duration"))
x &lt;- c(0,0,1,1)
x2 &lt;- as.factor(c("a","b","a","b"))
tcc &lt;- tcctomat(data.frame(x=x,x2=x2))
z &lt;- matrix(rpois(20,5),ncol=5)
tvc &lt;- tvctomat(z)
print(reps &lt;- rmna(resp, tvcov=tvc, ccov=tcc))
#
plot(resp)
plot(reps)
plot(reps, nind=1:2)
plot(reps, ccov=c(0,1))
plot(reps, ccov="x2")
plot(reps, name="z", nind=3:4, pch=1:2)
plot(reps, name="z", ccov="x2")
#
response(resp)
response(transform(resp, y=1/y))
response(reps)
response(reps, nind=2:3)
response(transform(reps,y=1/y))
#
times(resp)
times(transform(resp,times=times-6))
times(reps)
#
delta(resp)
delta(reps)
delta(transform(reps,y=1/y))
delta(transform(reps,y=1/y), nind=3)
#
nobs(resp)
nobs(tvc)
nobs(reps)
#
units(resp)
units(reps)
#
resptype(resp)
resptype(reps)
#
weights(resp)
weights(reps)
#
covariates(tcc)
covariates(tcc, nind=2:3)
covariates(tvc)
covariates(tvc, nind=3)
covariates(reps)
covariates(reps, nind=3)
covariates(reps,names="x")
covariates(reps,names="z")
#
names(tcc)
names(tvc)
names(reps)
#
nesting(resp)
nesting(reps)
#
# because individuals are the only nesting, this is the same as
covind(resp)
covind(reps)
#
as.data.frame(resp)
as.data.frame(tcc)
as.data.frame(tvc)
as.data.frame(reps)
#
# use in glm
rm(y,x,z)
glm(y~x+z, data=as.data.frame(reps))
</code></pre>

<hr>
<h2 id='dftorep'>Transform a Dataframe to a repeated Object</h2><span id='topic+dftorep'></span>

<h3>Description</h3>

<p><code>dftorep</code> forms an object of class, <code>repeated</code>, from a
dataframe with the option of removing any observations where response
and covariate values have NAs. For repeated measurements, observations
on the same individual must be together in the table. A number of
validity checks are performed on the data.
</p>
<p>Such objects can be printed and plotted. Methods are available for
extracting the response, the numbers of observations per individual,
the times, the weights, the units of measurement/Jacobian, the nesting
variable, the covariates, and their names: <code><a href="#topic+response">response</a></code>,
<code><a href="#topic+nobs">nobs</a></code>, <code><a href="#topic+times">times</a></code>,
<code><a href="#topic+weights">weights</a></code>, <code><a href="#topic+delta">delta</a></code>,
<code><a href="#topic+nesting">nesting</a></code>, <code><a href="#topic+covariates">covariates</a></code>, and
<code><a href="#topic+names">names</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dftorep(dataframe, response, id=NULL, times=NULL, censor=NULL,
	totals=NULL, weights=NULL, nest=NULL, delta=NULL,
	coordinates=NULL, type=NULL, ccov=NULL, tvcov=NULL, na.rm=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dftorep_+3A_dataframe">dataframe</code></td>
<td>
<p>A dataframe.</p>
</td></tr>
<tr><td><code id="dftorep_+3A_response">response</code></td>
<td>
<p>A character vector giving the column name(s) of the
dataframe for the response variable(s).</p>
</td></tr>
<tr><td><code id="dftorep_+3A_id">id</code></td>
<td>
<p>A character vector giving the column name of the
dataframe for the identification numbers of the individuals. If the
numbers are not consecutive integers, a warning is given.
</p>
<p>If NULL, one observation per individual is assumed if <code>times</code> is
also NULL, other time series is assumed.</p>
</td></tr>
<tr><td><code id="dftorep_+3A_times">times</code></td>
<td>
<p>An optional character vector giving the column name of the
dataframe for the times vector.</p>
</td></tr>
<tr><td><code id="dftorep_+3A_censor">censor</code></td>
<td>
<p>An optional character vector giving the column name(s)
of the dataframe for the censor indicator(s). This must be the same
length as <code>response</code>. Responses without censor indicator can have
a column either of all NAs or all 1s.</p>
</td></tr>
<tr><td><code id="dftorep_+3A_totals">totals</code></td>
<td>
<p>An optional character vector giving the column name(s)
of the dataframe for the totals for binomial data. This must be the same
length as <code>response</code>. Responses without censor indicator can have
a column all NAs.</p>
</td></tr>
<tr><td><code id="dftorep_+3A_weights">weights</code></td>
<td>
<p>An optional character vector giving the column name of
the dataframe for the weights vector.</p>
</td></tr>
<tr><td><code id="dftorep_+3A_nest">nest</code></td>
<td>
<p>An optional character vector giving the column name of
the dataframe for the nesting vector within individuals.
</p>
<p>This is the second level of nesting for repeated measurements, with
the individual being the first level. Values for an individual must be
consecutive increasing integers.</p>
</td></tr>
<tr><td><code id="dftorep_+3A_delta">delta</code></td>
<td>
<p>An optional character vector giving the column name(s)
of the dataframe for the units of measurement/Jacobian(s) of the
response(s). This must be the same length as <code>response</code>.
Responses without units of measurement/Jacobian can have a column all
NAs.
</p>
<p>If all response variables have the same unit of measurement, this can
be that one number. If each response variable has the same unit of
measurement for all its values, this can be a numeric vector of length
the number of response variables.</p>
</td></tr>
<tr><td><code id="dftorep_+3A_coordinates">coordinates</code></td>
<td>
<p>An optional character vector giving the two or
three column name(s) of the dataframe for the spatial coordinates.</p>
</td></tr>
<tr><td><code id="dftorep_+3A_type">type</code></td>
<td>
<p>An optional character vector giving the types of response
variables: nominal, ordinal, discrete, duration, continuous,
multivariate, or unknown.</p>
</td></tr>
<tr><td><code id="dftorep_+3A_ccov">ccov</code></td>
<td>
<p>An optional character vector giving the column names of
the dataframe for the time-constant or inter-individual covariates.
For repeated measurements, if the value is not constant for all
observations on an individual, an error is produced.</p>
</td></tr>
<tr><td><code id="dftorep_+3A_tvcov">tvcov</code></td>
<td>
<p>An optional character vector giving the column names of
the dataframe for the time-varying or intra-individual covariates.</p>
</td></tr>
<tr><td><code id="dftorep_+3A_na.rm">na.rm</code></td>
<td>
<p>If TRUE, observations with NAs in any variables selected
are removed in the object returned. Otherwise, the corresponding
indicator variable is returned in a slot in the object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class, <code>repeated</code>, containing a list of the
response object (<code>z$response</code>, so that, for example, the response vector
is <code>z$response$y</code>; see <code><a href="#topic+restovec">restovec</a></code>), and
possibly the two classes of covariate objects (<code>z$ccov</code> and
<code>z$tvcov</code>; see <code><a href="#topic+tcctomat">tcctomat</a></code> and
<code><a href="#topic+tvctomat">tvctomat</a></code>).
</p>


<h3>Author(s)</h3>

<p>J.K. Lindsey</p>


<h3>See Also</h3>

<p><code><a href="#topic+lvna">lvna</a></code>, <code><a href="#topic+read.list">read.list</a></code>,
<code><a href="#topic+read.rep">read.rep</a></code>, <code><a href="#topic+restovec">restovec</a></code>,
<code><a href="#topic+rmna">rmna</a></code>, <code><a href="#topic+tcctomat">tcctomat</a></code>,
<code><a href="#topic+tvctomat">tvctomat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- data.frame(y1=rpois(20,5),y2=rpois(20,5))
y[2,2] &lt;- NA
idd &lt;- c(rep(1,5),rep(2,10),rep(3,5))
tt &lt;- c(1:5,1:10,1:5)
totals &lt;- data.frame(tot1=rep(12,20),tot2=rep(12,20))
x2 &lt;- c(rep(1,5),rep(2,10),rep(3,5))
df &lt;- data.frame(y,id=idd,tt=tt,totals,x1=rnorm(20),x2=x2)
df
dftorep(df,resp=c("y1","y2"),times="tt",id="id",totals=c("tot1","tot2"),
	tvcov="x1",ccov="x2")
dftorep(df,resp=c("y1","y2"),times="tt",id="id",totals=c("tot1","tot2"),
	tvcov="x1",ccov="x2",na.rm=FALSE)
# x1 is not a time-constant covariate
#dftorep(df,resp=c("y1","y2"),times="tt",id="id",ccov="x1",na.rm=FALSE)
</code></pre>

<hr>
<h2 id='Double+20Binomial'>Double Binomial Distribution</h2><span id='topic+ddoublebinom'></span><span id='topic+pdoublebinom'></span><span id='topic+qdoublebinom'></span><span id='topic+rdoublebinom'></span>

<h3>Description</h3>

<p>These functions provide information about the double binomial
distribution with parameters <code>m</code> and <code>s</code>: density,
cumulative distribution, quantiles, and random generation.
</p>
<p>The double binomial distribution with total <code class="reqn">= n</code> and
<code>prob</code> <code class="reqn">= m</code> has density
</p>
<p style="text-align: center;"><code class="reqn">p(y) = c({n}, {m}, {s}){n \choose y} {n}^{{n}{s}} ({m}/{y})^({y}{s}) {((1-m)/(n-y))}^(({n-y})s y) {y}^{y} {(n-y)}^{(n-y)})%
</code>
</p>

<p>for <code class="reqn">y = 0, \ldots, n</code>, where c(.) is a normalizing constant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddoublebinom(y, size, m, s, log=FALSE)
pdoublebinom(q, size, m, s)
qdoublebinom(p, size, m, s)
rdoublebinom(n, size, m, s)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Double+2B20Binomial_+3A_y">y</code></td>
<td>
<p>vector of frequencies</p>
</td></tr>
<tr><td><code id="Double+2B20Binomial_+3A_q">q</code></td>
<td>
<p>vector of quantiles</p>
</td></tr>
<tr><td><code id="Double+2B20Binomial_+3A_p">p</code></td>
<td>
<p>vector of probabilities</p>
</td></tr>
<tr><td><code id="Double+2B20Binomial_+3A_n">n</code></td>
<td>
<p>number of values to generate</p>
</td></tr>
<tr><td><code id="Double+2B20Binomial_+3A_size">size</code></td>
<td>
<p>vector of totals</p>
</td></tr>
<tr><td><code id="Double+2B20Binomial_+3A_m">m</code></td>
<td>
<p>vector of probabilities of success</p>
</td></tr>
<tr><td><code id="Double+2B20Binomial_+3A_s">s</code></td>
<td>
<p>vector of overdispersion parameters</p>
</td></tr>
<tr><td><code id="Double+2B20Binomial_+3A_log">log</code></td>
<td>
<p>if TRUE, log probabilities are supplied.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J.K. Lindsey</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dbinom">dbinom</a></code> for the binomial, <code><a href="#topic+dmultbinom">dmultbinom</a></code> for
the multiplicative binomial, and <code><a href="#topic+dbetabinom">dbetabinom</a></code>
for the beta binomial distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># compute P(45 &lt; y &lt; 55) for y double binomial(100,0.5,1.1)
sum(ddoublebinom(46:54, 100, 0.5, 1.1))
pdoublebinom(54, 100, 0.5, 1.1)-pdoublebinom(45, 100, 0.5, 1.1)
pdoublebinom(2,10,0.5,1.1)
qdoublebinom(0.05,10,0.5,1.1)
rdoublebinom(10,10,0.5,1.1)
</code></pre>

<hr>
<h2 id='DoublePoisson'>Double Poisson Distribution</h2><span id='topic+ddoublepois'></span><span id='topic+pdoublepois'></span><span id='topic+qdoublepois'></span><span id='topic+rdoublepois'></span>

<h3>Description</h3>

<p>These functions provide information about the double Poisson
distribution with parameters <code>m</code> and <code>s</code>: density,
cumulative distribution, quantiles, and random generation.
</p>
<p>The double Poisson distribution with <code>mu</code> <code class="reqn">= m</code> has density
</p>
<p style="text-align: center;"><code class="reqn">p(y) = c({\mu}, {\lambda}) {\lambda}^({y}/{\mu}) ({\mu}/{y})^(y\log({\lambda})) {y}^{(y-1)} / {y!}%
</code>
</p>

<p>for <code class="reqn">y = 0, \ldots</code>, where c(.) is a normalizing constant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddoublepois(y, m, s, log=FALSE)
pdoublepois(q, m, s)
qdoublepois(p, m, s)
rdoublepois(n, m, s)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DoublePoisson_+3A_y">y</code></td>
<td>
<p>vector of counts</p>
</td></tr>
<tr><td><code id="DoublePoisson_+3A_q">q</code></td>
<td>
<p>vector of quantiles</p>
</td></tr>
<tr><td><code id="DoublePoisson_+3A_p">p</code></td>
<td>
<p>vector of probabilities</p>
</td></tr>
<tr><td><code id="DoublePoisson_+3A_n">n</code></td>
<td>
<p>number of values to generate</p>
</td></tr>
<tr><td><code id="DoublePoisson_+3A_m">m</code></td>
<td>
<p>vector of means</p>
</td></tr>
<tr><td><code id="DoublePoisson_+3A_s">s</code></td>
<td>
<p>vector of overdispersion parameters</p>
</td></tr>
<tr><td><code id="DoublePoisson_+3A_log">log</code></td>
<td>
<p>if TRUE, log probabilities are supplied.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dpois">dpois</a></code> for the Poisson, <code><a href="#topic+dconsul">dconsul</a></code> for
the Consul generalized Poisson, <code><a href="#topic+dgammacount">dgammacount</a></code> for
the gamma count, <code><a href="#topic+dmultpois">dmultpois</a></code> for the
multiplicative Poisson, <code><a href="#topic+dpvfpois">dpvfpois</a></code> for the power
variance function Poisson, and <code><a href="stats.html#topic+dnbinom">dnbinom</a></code> for the negative
binomial distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ddoublepois(5,10,0.9)
pdoublepois(5,10,0.9)
qdoublepois(0.08,10,0.9)
rdoublepois(10,10,0.9)
</code></pre>

<hr>
<h2 id='finterp'>Formula Interpreter</h2><span id='topic+finterp'></span><span id='topic+finterp.data.frame'></span><span id='topic+finterp.default'></span><span id='topic+finterp.repeated'></span><span id='topic+finterp.tccov'></span><span id='topic+finterp.tvcov'></span>

<h3>Description</h3>

<p><code>finterp</code> translates a model formula into a function of the
unknown parameters or of a vector of them. Such language formulae can
either be in Wilkinson and Rogers notation or be expressions
containing both known (existing) covariates and unknown (not existing)
parameters. In the latter, factor variables cannot be used and
parameters must be scalars.
</p>
<p>The covariates in the formula are sought in the environment or in the
data object provided. If the data object has class, <code>repeated</code> or
<code>response</code>, then the key words, <code>times</code> will use the
response times from the data object as a covariate, <code>individuals</code>
will use the index for individuals as a factor covariate, and
<code>nesting</code> the index for nesting as a factor covariate. The latter
two only work for W&amp;R notation.
</p>
<p>Note that, in parameter displays, formulae in Wilkinson and Rogers
notation use variable names whereas those with unknowns use the names
of these parameters, as given in the formulae, and that the meaning of
operators (*, /, :, etc.) is different in the two cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>finterp(.z, ...)
## Default S3 method:
finterp(.z, .envir=parent.frame(), .formula=FALSE, .vector=TRUE,
	.args=NULL, .start=1, .name=NULL, .expand=TRUE, .intercept=TRUE,
	.old=NULL, .response=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="finterp_+3A_.z">.z</code></td>
<td>
<p>A model formula beginning with ~, either in Wilkinson and
Rogers notation or containing unknown parameters. If it contains
unknown parameters, it can have several lines so that, for example,
local variables can be assigned temporary values. In this case,
enclose the formula in curly brackets.</p>
</td></tr>
<tr><td><code id="finterp_+3A_.envir">.envir</code></td>
<td>
<p>The environment in which the formula is to be
interpreted or a data object of class, <code>repeated</code>, <code>tccov</code>,
or <code>tvcov</code>.</p>
</td></tr>
<tr><td><code id="finterp_+3A_.formula">.formula</code></td>
<td>
<p>If TRUE and the formula is in Wilkinson and Rogers
notation, just returns the formula.</p>
</td></tr>
<tr><td><code id="finterp_+3A_.vector">.vector</code></td>
<td>
<p>If FALSE and the formula contains unknown parameters,
the function returned has them as separate arguments. If TRUE, it has
one argument, the unknowns as a vector, unless certain parameter names
are specified in <code>.args</code>. Always TRUE if <code>.envir</code> is
a data object.</p>
</td></tr>
<tr><td><code id="finterp_+3A_.args">.args</code></td>
<td>
<p>If <code>.vector</code> is TRUE, names of parameters that are to
be function arguments and not included in the vector.</p>
</td></tr>
<tr><td><code id="finterp_+3A_.start">.start</code></td>
<td>
<p>The starting index value of the parameter vector in the
function returned when <code>.vector</code> is TRUE.</p>
</td></tr>
<tr><td><code id="finterp_+3A_.name">.name</code></td>
<td>
<p>Character string giving the name of the data object
specified by <code>.envir</code>. Ignored unless the latter is such an
object and only necessary when <code>finterp</code> is called within other
functions.</p>
</td></tr>
<tr><td><code id="finterp_+3A_.expand">.expand</code></td>
<td>
<p>If TRUE, expand functions with only time-constant
covariates to return one value per observation instead of one value
per individual. Ignored unless <code>.envir</code> is an object of class,
<code>repeated</code>.</p>
</td></tr>
<tr><td><code id="finterp_+3A_.intercept">.intercept</code></td>
<td>
<p>If W&amp;R notation is supplied and <code>.intercept=F</code>,
a model function without intercept is returned.</p>
</td></tr>
<tr><td><code id="finterp_+3A_.old">.old</code></td>
<td>
<p>The name of an existing object of class <code>formulafn</code>
which has common parameters with the one being created, or a list of
such objects. Only used if <code>.vector</code>=TRUE. The value of
<code>.start</code> should ensure that there is no conflict in indexing the
vector.</p>
</td></tr>
<tr><td><code id="finterp_+3A_.response">.response</code></td>
<td>
<p>If TRUE, any response variable can be used in the
function. If FALSE, checks are made that the response is not also used
as a covariate.</p>
</td></tr>
<tr><td><code id="finterp_+3A_...">...</code></td>
<td>
<p>Arguments passed to other functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function, of class <code>formulafn</code>, of the unknown parameters or of a
vector of them is returned. Its attributes give the formula supplied,
the model function produced, the covariate names, the parameter names,
and the range of values of the index of the parameter vector. If
<code>formula</code> is TRUE and a Wilkinson and Rogers formula was
supplied, it is simply returned instead of creating a function.
</p>


<h3>Author(s)</h3>

<p>J.K. Lindsey</p>


<h3>See Also</h3>

<p><code><a href="#topic+FormulaMethods">FormulaMethods</a></code>, <code><a href="#topic+covariates">covariates</a></code>,
<code><a href="#topic+fnenvir">fnenvir</a></code>, <code><a href="#topic+formula">formula</a></code>,
<code><a href="#topic+model">model</a></code>, <code><a href="#topic+parameters">parameters</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- rpois(20,2)
x2 &lt;- rnorm(20)
#
# Wilkinson and Rogers formula with three parameters
fn1 &lt;- finterp(~x1+x2)
fn1
fn1(rep(2,3))
# the same formula with unknowns
fn2 &lt;- finterp(~b0+b1*x1+b2*x2)
fn2
fn2(rep(2,3))
#
# nonlinear formulae with unknowns
# log link
fn2a &lt;- finterp(~exp(b0+b1*x1+b2*x2))
fn2a
fn2a(rep(0.2,3))
# parameters common to two functions
fn2b &lt;- finterp(~c0+c1*exp(b0+b1*x1+b2*x2), .old=fn2a, .start=4)
fn2b
# function returned also depends on values of another function
fn2c &lt;- finterp(~fn2+c1*exp(b0+b1*x1+b2*x2), .old=fn2a,
	.start=4, .args="fn2")
fn2c
args(fn2c)
fn2c(rep(0.2,4),fn2(rep(2,3)))
#
# compartment model
times &lt;- 1:20
# exp() parameters to ensure that they are positive
fn3 &lt;- finterp(~exp(absorption-volume)/(exp(absorption)-
	exp(elimination))*(exp(-exp(elimination)*times)-
	exp(-exp(absorption)*times)))
fn3
fn3(log(c(0.3,3,0.2)))
# a more efficient way
# (note that parameters do not appear in the same order)
form &lt;- ~{
	ka &lt;- exp(absorption)
	ke &lt;- exp(elimination)
	ka*exp(-volume)/(ka-ke)*(exp(-ke*times)-exp(-ka*times))}
fn3a &lt;- finterp(form)
fn3a(log(c(0.3,0.2,3)))
#
# Poisson density
y &lt;- rpois(20,5)
fn4 &lt;- finterp(~mu^y*exp(-mu)/gamma(y+1))
fn4
fn4(5)
dpois(y,5)
#
# Poisson likelihood
# mean parameter
fn5 &lt;- finterp(~-y*log(mu)+mu+lgamma(y+1),.vector=FALSE)
fn5
likefn1 &lt;- function(p) sum(fn5(mu=p))
nlm(likefn1,p=1)
mean(y)
# canonical parameter
fn5a &lt;- finterp(~-y*theta+exp(theta)+lgamma(y+1),.vector=FALSE)
fn5a
likefn1a &lt;- function(p) sum(fn5a(theta=p))
nlm(likefn1a,p=1)
#
# likelihood for Poisson log linear regression
y &lt;- rpois(20,fn2a(c(0.2,1,0.4)))
nlm(likefn1,p=1)
mean(y)
likefn2 &lt;- function(p) sum(fn5(mu=fn2a(p)))
nlm(likefn2,p=c(1,0,0))
# or
likefn2a &lt;- function(p) sum(fn5a(theta=fn2(p)))
nlm(likefn2a,p=c(1,0,0))
#
# likelihood for Poisson nonlinear regression
y &lt;- rpois(20,fn3(log(c(3,0.3,0.2))))
nlm(likefn1,p=1)
mean(y)
likefn3 &lt;- function(p) sum(fn5(mu=fn3(p)))
nlm(likefn3,p=log(c(1,0.4,0.1)))
#
# envir as data objects
y &lt;- matrix(rnorm(20),ncol=5)
y[3,3] &lt;- y[2,2] &lt;- NA
x1 &lt;- 1:4
x2 &lt;- c("a","b","c","d")
resp &lt;- restovec(y)
xx &lt;- tcctomat(x1)
xx2 &lt;- tcctomat(data.frame(x1,x2))
z1 &lt;- matrix(rnorm(20),ncol=5)
z2 &lt;- matrix(rnorm(20),ncol=5)
z3 &lt;- matrix(rnorm(20),ncol=5)
zz &lt;- tvctomat(z1)
zz &lt;- tvctomat(z2,old=zz)
reps &lt;- rmna(resp, ccov=xx, tvcov=zz)
reps2 &lt;- rmna(resp, ccov=xx2, tvcov=zz)
rm(y, x1, x2 , z1, z2)
#
# repeated objects
#
# time-constant covariates
# Wilkinson and Rogers notation
form1 &lt;- ~x1
print(fn1 &lt;- finterp(form1, .envir=reps))
fn1(2:3)
print(fn1a &lt;- finterp(form1, .envir=xx))
fn1a(2:3)
form1b &lt;- ~x1+x2
print(fn1b &lt;- finterp(form1b, .envir=reps2))
fn1b(2:6)
print(fn1c &lt;- finterp(form1b, .envir=xx2))
fn1c(2:6)
# with unknown parameters
form2 &lt;- ~a+b*x1
print(fn2 &lt;- finterp(form2, .envir=reps))
fn2(2:3)
print(fn2a &lt;- finterp(form2, .envir=xx))
fn2a(2:3)
#
# time-varying covariates
# Wilkinson and Rogers notation
form3 &lt;- ~z1+z2
print(fn3 &lt;- finterp(form3, .envir=reps))
fn3(2:4)
print(fn3a &lt;- finterp(form3, .envir=zz))
fn3a(2:4)
# with unknown parameters
form4 &lt;- ~a+b*z1+c*z2
print(fn4 &lt;- finterp(form4, .envir=reps))
fn4(2:4)
print(fn4a &lt;- finterp(form4, .envir=zz))
fn4a(2:4)
#
# note: lengths of x1 and z2 differ
# Wilkinson and Rogers notation
form5 &lt;- ~x1+z2
print(fn5 &lt;- finterp(form5, .envir=reps))
fn5(2:4)
# with unknown parameters
form6 &lt;- ~a+b*x1+c*z2
print(fn6 &lt;- finterp(form6, .envir=reps))
fn6(2:4)
#
# with times
# Wilkinson and Rogers notation
form7 &lt;- ~x1+z2+times
print(fn7 &lt;- finterp(form7, .envir=reps))
fn7(2:5)
form7a &lt;- ~x1+x2+z2+times
print(fn7a &lt;- finterp(form7a, .envir=reps2))
fn7a(2:8)
# with unknown parameters
form8 &lt;- ~a+b*x1+c*z2+e*times
print(fn8 &lt;- finterp(form8, .envir=reps))
fn8(2:5)
#
# with a variable not in the data object
form9 &lt;- ~a+b*z1+c*z2+e*z3
print(fn9 &lt;- finterp(form9, .envir=reps))
fn9(2:5)
# z3 assumed to be an unknown parameter:
fn9(2:6)
#
# multiline formula
form10 &lt;- ~{
	tmp &lt;- exp(b)
	a+tmp*z1+c*z2+d*times}
print(fn10 &lt;- finterp(form10, .envir=reps))
fn10(2:5)
</code></pre>

<hr>
<h2 id='fmobj'>Object Finder</h2><span id='topic+fmobj'></span>

<h3>Description</h3>

<p><code>fmobj</code> inspects a formula and returns a list containing the
objects referred to, with indicators as to which are unknown parameters,
covariates, factor variables, and functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmobj(z, envir=parent.frame())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fmobj_+3A_z">z</code></td>
<td>
<p>A model formula beginning with ~, either in Wilkinson and
Rogers notation or containing unknown parameters.</p>
</td></tr>
<tr><td><code id="fmobj_+3A_envir">envir</code></td>
<td>
<p>The environment in which the formula is to be
interpreted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list, of class <code>fmobj</code>, containing a character vector
(<code>objects</code>) with the names of the objects used in a formula, and
logical vectors indicating which are unknown parameters
(<code>parameters</code>), covariates (<code>covariates</code>), factor variables
(<code>factors</code>), and functions (<code>functions</code>).
</p>


<h3>Author(s)</h3>

<p>J.K. Lindsey</p>


<h3>See Also</h3>

<p><code><a href="#topic+finterp">finterp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- rpois(20,2)
x2 &lt;- rnorm(20)
x3 &lt;- gl(2,10)
#
# W&amp;R formula
fmobj(~x1+x2+x3)
#
# formula with unknowns
fmobj(~b0+b1*x1+b2*x2)
#
# nonlinear formulae with unknowns
# log link
fmobj(~exp(b0+b1*x1+b2*x2))
</code></pre>

<hr>
<h2 id='fnenvir'>Check Covariates and Parameters of a Function</h2><span id='topic+fnenvir'></span><span id='topic+fnenvir.data.frame'></span><span id='topic+fnenvir.default'></span><span id='topic+fnenvir.repeated'></span><span id='topic+fnenvir.tccov'></span><span id='topic+fnenvir.tvcov'></span>

<h3>Description</h3>

<p><code>fnenvir</code> finds the covariates and parameters in a function and
can modify it so that the covariates used in it are found in the data
object specified by <code>.envir</code>.
</p>
<p>If the data object has class, <code>repeated</code>, the key word
<code>times</code> in a function will use the response times from the data
object as a covariate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fnenvir(.z, ...)
## Default S3 method:
fnenvir(.z, .envir=parent.frame(), .name=NULL, .expand=TRUE,
	.response=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fnenvir_+3A_.z">.z</code></td>
<td>
<p>A function.</p>
</td></tr>
<tr><td><code id="fnenvir_+3A_.envir">.envir</code></td>
<td>
<p>The environment or data object of class,
<code>repeated</code>, <code>tccov</code>, or <code>tvcov</code>, in which the function
is to be interpreted.</p>
</td></tr>
<tr><td><code id="fnenvir_+3A_.name">.name</code></td>
<td>
<p>Character string giving the name of the data object
specified by <code>.envir</code>. Ignored unless the latter is such an
object and only necessary when <code>fnenvir</code> is called within other
functions.</p>
</td></tr>
<tr><td><code id="fnenvir_+3A_.expand">.expand</code></td>
<td>
<p>If TRUE, expand functions with only time-constant
covariates to return one value per observation instead of one value
per individual. Ignored unless <code>.envir</code> is an object of class,
<code>repeated</code>.</p>
</td></tr>
<tr><td><code id="fnenvir_+3A_.response">.response</code></td>
<td>
<p>If TRUE, any response variable can be used in the
function. If FALSE, checks are made that the response is not also used
as a covariate.</p>
</td></tr>
<tr><td><code id="fnenvir_+3A_...">...</code></td>
<td>
<p>Arguments passed to other functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The (modified) function, of class <code>formulafn</code>, is returned with its
attributes giving the (new) model function, the covariate names, and
the parameter names.</p>


<h3>Author(s)</h3>

<p>J.K. Lindsey</p>


<h3>See Also</h3>

<p><code><a href="#topic+FormulaMethods">FormulaMethods</a></code>,<code><a href="#topic+covariates">covariates</a></code>,
<code><a href="#topic+finterp">finterp</a></code>, <code><a href="#topic+model">model</a></code>,
<code><a href="#topic+parameters">parameters</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fn &lt;- function(p) a+b*x
fnenvir(fn)
fn &lt;- function(p) a+p*x
fnenvir(fn)
x &lt;- 1:4
fnenvir(fn)
fn &lt;- function(p) p[1]+exp(p[2]*x)
fnenvir(fn)
#
y &lt;- matrix(rnorm(20),ncol=5)
y[3,3] &lt;- y[2,2] &lt;- NA
resp &lt;- restovec(y)
xx &lt;- tcctomat(x)
z1 &lt;- matrix(rnorm(20),ncol=5)
z2 &lt;- matrix(rnorm(20),ncol=5)
z3 &lt;- matrix(rnorm(20),ncol=5)
zz &lt;- tvctomat(z1)
zz &lt;- tvctomat(z2,old=zz)
reps &lt;- rmna(resp, ccov=xx, tvcov=zz)
rm(y, x, z1, z2)
#
# repeated objects
func1 &lt;- function(p) p[1]+p[2]*x+p[3]*z2
print(fn1 &lt;- fnenvir(func1, .envir=reps))
fn1(2:4)
#
# time-constant covariates
func2 &lt;- function(p) p[1]+p[2]*x
print(fn2 &lt;- fnenvir(func2, .envir=reps))
fn2(2:3)
print(fn2a &lt;- fnenvir(func2, .envir=xx))
fn2a(2:3)
#
# time-varying covariates
func3 &lt;- function(p) p[1]+p[2]*z1+p[3]*z2
print(fn3 &lt;- fnenvir(func3, .envir=reps))
fn3(2:4)
print(fn3a &lt;- fnenvir(func3, .envir=zz))
fn3a(2:4)
# including times
func3b &lt;- function(p) p[1]+p[2]*z1+p[3]*z2+p[4]*times
print(fn3b &lt;- fnenvir(func3b, .envir=reps))
fn3b(2:5)
#
# with typing error and a variable not in the data object
func4 &lt;- function(p) p[1]+p2[2]*z1+p[3]*z2+p[4]*z3
print(fn4 &lt;- fnenvir(func4, .envir=reps))
#
# first-order one-compartment model
# data objects for formulae
dose &lt;- c(2,5)
dd &lt;- tcctomat(dose)
times &lt;- matrix(rep(1:20,2), nrow=2, byrow=TRUE)
tt &lt;- tvctomat(times)
# vector covariates for functions
dose &lt;- c(rep(2,20),rep(5,20))
times &lt;- rep(1:20,2)
# functions
mu &lt;- function(p) {
	absorption &lt;- exp(p[1])
	elimination &lt;- exp(p[2])
	absorption*exp(-p[3])*dose/(absorption-elimination)*
		(exp(-elimination*times)-exp(-absorption*times))}
shape &lt;- function(p) exp(p[1]-p[2])*times*dose*exp(-exp(p[1])*times)
# response
conc &lt;- matrix(rgamma(40,shape(log(c(0.1,0.4))),
	scale=mu(log(c(1,0.3,0.2))))/shape(log(c(0.1,0.4))),ncol=20,byrow=TRUE)
conc[,2:20] &lt;- conc[,2:20]+0.5*(conc[,1:19]-matrix(mu(log(c(1,0.3,0.2))),
	ncol=20,byrow=TRUE)[,1:19])
conc &lt;- restovec(ifelse(conc&gt;0,conc,0.01))
reps &lt;- rmna(conc, ccov=dd, tvcov=tt)
#
print(fn5 &lt;- fnenvir(mu,.envir=reps))
fn5(c(0,-1.2,-1.6))
</code></pre>

<hr>
<h2 id='FormulaMethods'>Methods for formulafn Functions</h2><span id='topic+covariates.formulafn'></span><span id='topic+formula.formulafn'></span><span id='topic+model'></span><span id='topic+model.formulafn'></span><span id='topic+parameters'></span><span id='topic+parameters.formulafn'></span><span id='topic+print.formulafn'></span>

<h3>Description</h3>

<p>Methods for accessing the contents of a function created from formula
produced by <code><a href="#topic+finterp">finterp</a></code> or a function modified by
<code><a href="#topic+fnenvir">fnenvir</a></code>.
</p>
<p><code>covariates</code>: extract the names of the covariates.
</p>
<p><code>formula</code>: extract the formula used to produce the function
(<code><a href="#topic+finterp">finterp</a></code> only).
</p>
<p><code>model</code>: extract the model function or model matrix if W&amp;R
notation was used.
</p>
<p><code>parameters</code>: extract the names of the parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'formulafn'
covariates(z, ...)
## S3 method for class 'formulafn'
formula(x, ...)
model(z, ...)
parameters(z, ...)
## S3 method for class 'formulafn'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FormulaMethods_+3A_x">x</code>, <code id="FormulaMethods_+3A_z">z</code></td>
<td>
<p>A function of class, <code>formulafn</code>.</p>
</td></tr>
<tr><td><code id="FormulaMethods_+3A_...">...</code></td>
<td>
<p>Arguments to other functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>These methods extract information about functions of class, <code>formulafn</code>,
created by <code><a href="#topic+finterp">finterp</a></code> or <code><a href="#topic+fnenvir">fnenvir</a></code>.
</p>


<h3>Author(s)</h3>

<p>J.K. Lindsey</p>


<h3>See Also</h3>

<p><code><a href="#topic+finterp">finterp</a></code>, <code><a href="#topic+fnenvir">fnenvir</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- rpois(20,2)
x2 &lt;- rnorm(20)
#
# Wilkinson and Rogers formula with three parameters
fn1 &lt;- finterp(~x1+x2)
fn1
covariates(fn1)
formula(fn1)
model(fn1)
parameters(fn1)
#
# nonlinear formula with unknowns
fn2 &lt;- finterp(~exp(b0+b1*x1+b2*x2))
fn2
covariates(fn2)
formula(fn2)
model(fn2)
parameters(fn2)
#
# function transformed by fnenvir
fn3 &lt;- fnenvir(function(p) p[1]+p[2]*x1)
covariates(fn3)
formula(fn3)
model(fn3)
parameters(fn3)
</code></pre>

<hr>
<h2 id='Gamma+20Count'>Gamma Count Distribution</h2><span id='topic+dgammacount'></span><span id='topic+pgammacount'></span><span id='topic+qgammacount'></span><span id='topic+rgammacount'></span>

<h3>Description</h3>

<p>These functions provide information about the gamma count
distribution with parameters <code>m</code> and <code>s</code>: density,
cumulative distribution, quantiles, and random generation.
</p>
<p>The gamma count distribution with <code>prob</code> <code class="reqn">= m</code> has density
</p>
<p style="text-align: center;"><code class="reqn">p(y) = pgamma(\mu \sigma,y \sigma,1)-pgamma(\mu \sigma,(y+1) \sigma,1)
</code>
</p>

<p>for <code class="reqn">y = 0, \ldots, n</code> where
<code class="reqn">pgamma(\mu \sigma,0,1)=1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgammacount(y, m, s, log=FALSE)
pgammacount(q, m, s)
qgammacount(p, m, s)
rgammacount(n, m, s)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Gamma+2B20Count_+3A_y">y</code></td>
<td>
<p>vector of frequencies</p>
</td></tr>
<tr><td><code id="Gamma+2B20Count_+3A_q">q</code></td>
<td>
<p>vector of quantiles</p>
</td></tr>
<tr><td><code id="Gamma+2B20Count_+3A_p">p</code></td>
<td>
<p>vector of probabilities</p>
</td></tr>
<tr><td><code id="Gamma+2B20Count_+3A_n">n</code></td>
<td>
<p>number of values to generate</p>
</td></tr>
<tr><td><code id="Gamma+2B20Count_+3A_m">m</code></td>
<td>
<p>vector of probabilities</p>
</td></tr>
<tr><td><code id="Gamma+2B20Count_+3A_s">s</code></td>
<td>
<p>vector of overdispersion parameters</p>
</td></tr>
<tr><td><code id="Gamma+2B20Count_+3A_log">log</code></td>
<td>
<p>if TRUE, log probabilities are supplied.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J.K. Lindsey</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dpois">dpois</a></code> for the Poisson, <code><a href="#topic+dconsul">dconsul</a></code> for
the Consul generalized Poisson, <code><a href="#topic+ddoublepois">ddoublepois</a></code> for
the double Poisson, <code><a href="#topic+dmultpois">dmultpois</a></code>
for the multiplicative Poisson distributions, and <code><a href="stats.html#topic+dnbinom">dnbinom</a></code>
for the negative binomial distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dgammacount(5,10,0.9)
pgammacount(5,10,0.9)
qgammacount(0.08,10,0.9)
rgammacount(10,10,0.9)
</code></pre>

<hr>
<h2 id='gauss.hermite'>Calculate Gauss-Hermite Quadrature Points</h2><span id='topic+gauss.hermite'></span>

<h3>Description</h3>

<p><code>gauss.hermite</code> calculates the Gauss-Hermite quadrature values
for a specified number of points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gauss.hermite(points, iterlim=10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gauss.hermite_+3A_points">points</code></td>
<td>
<p>The number of points.</p>
</td></tr>
<tr><td><code id="gauss.hermite_+3A_iterlim">iterlim</code></td>
<td>
<p>Maximum number of iterations in Newton-Raphson.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>gauss.hermite</code> returns a two-column matrix containing the points
and their corresponding weights.
</p>


<h3>Author(s)</h3>

<p>J.K. Lindsey</p>


<h3>Examples</h3>

<pre><code class='language-R'>gauss.hermite(10)
</code></pre>

<hr>
<h2 id='Generalized+20Extreme+20Value'>Generalized Extreme Value Distribution</h2><span id='topic+dgextval'></span><span id='topic+pgextval'></span><span id='topic+qgextval'></span><span id='topic+rgextval'></span>

<h3>Description</h3>

<p>These functions provide information about the generalized extreme
value distribution with location parameter equal to <code>m</code>, dispersion
equal to <code>s</code>, and family parameter equal to <code>f</code>: density,
cumulative distribution, quantiles, log hazard, and random generation.
</p>
<p>The generalized extreme value distribution has density
</p>
<p style="text-align: center;"><code class="reqn">
  f(y) =
  y^{\nu-1} \exp(y^\nu/\nu) \frac{\sigma}{\mu}
  \frac{\exp(y^\nu/\nu)}{\mu^{\sigma-1}/(1-I(\nu&gt;0)+sign(\nu)
  exp(-\mu^-\sigma))}\exp(-(\exp(y^\nu\nu)/\mu)^\sigma)</code>
</p>

<p>where <code class="reqn">\mu</code> is the location parameter of the distribution,
<code class="reqn">\sigma</code> is the dispersion, <code class="reqn">\nu</code> is the family
parameter, <code class="reqn">I()</code> is the indicator function, and <code class="reqn">y&gt;0</code>.
</p>
<p><code class="reqn">\nu=1</code> a truncated extreme value distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgextval(y, s, m, f, log=FALSE)
pgextval(q, s, m, f)
qgextval(p, s, m, f)
rgextval(n, s, m, f)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Generalized+2B20Extreme+2B20Value_+3A_y">y</code></td>
<td>
<p>vector of responses.</p>
</td></tr>
<tr><td><code id="Generalized+2B20Extreme+2B20Value_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Generalized+2B20Extreme+2B20Value_+3A_p">p</code></td>
<td>
<p>vector of probabilities</p>
</td></tr>
<tr><td><code id="Generalized+2B20Extreme+2B20Value_+3A_n">n</code></td>
<td>
<p>number of values to generate</p>
</td></tr>
<tr><td><code id="Generalized+2B20Extreme+2B20Value_+3A_m">m</code></td>
<td>
<p>vector of location parameters.</p>
</td></tr>
<tr><td><code id="Generalized+2B20Extreme+2B20Value_+3A_s">s</code></td>
<td>
<p>vector of dispersion parameters.</p>
</td></tr>
<tr><td><code id="Generalized+2B20Extreme+2B20Value_+3A_f">f</code></td>
<td>
<p>vector of family parameters.</p>
</td></tr>
<tr><td><code id="Generalized+2B20Extreme+2B20Value_+3A_log">log</code></td>
<td>
<p>if TRUE, log probabilities are supplied.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J.K. Lindsey</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dweibull">dweibull</a></code> for the Weibull distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dgextval(1, 2, 1, 2)
pgextval(1, 2, 1, 2)
qgextval(0.82, 2, 1, 2)
rgextval(10, 2, 1, 2)
</code></pre>

<hr>
<h2 id='Generalized+20Gamma'>Generalized Gamma Distribution</h2><span id='topic+dggamma'></span><span id='topic+pggamma'></span><span id='topic+qggamma'></span><span id='topic+rggamma'></span>

<h3>Description</h3>

<p>These functions provide information about the generalized gamma
distribution with scale parameter equal to <code>m</code>, shape equal
to <code>s</code>, and family parameter equal to <code>f</code>: density,
cumulative distribution, quantiles, log hazard, and random generation.
</p>
<p>The generalized gamma distribution has density
</p>
<p style="text-align: center;"><code class="reqn">
  f(y) = \frac{\nu y^{\nu-1}}
  {(\mu/\sigma)^{\nu\sigma} Gamma(\sigma)} y^{\nu(\sigma-1)}
  \exp(-(y \sigma/\mu)^\nu)</code>
</p>

<p>where <code class="reqn">\mu</code> is the scale parameter of the distribution,
<code class="reqn">\sigma</code> is the shape, and <code class="reqn">\nu</code> is the family
parameter.
</p>
<p><code class="reqn">\nu=1</code> yields a gamma distribution, <code class="reqn">\sigma=1</code> a
Weibull distribution, and <code class="reqn">\sigma=\infty</code> a
log normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dggamma(y, s, m, f, log=FALSE)
pggamma(q, s, m, f)
qggamma(p, s, m, f)
rggamma(n, s, m, f)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Generalized+2B20Gamma_+3A_y">y</code></td>
<td>
<p>vector of responses.</p>
</td></tr>
<tr><td><code id="Generalized+2B20Gamma_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Generalized+2B20Gamma_+3A_p">p</code></td>
<td>
<p>vector of probabilities</p>
</td></tr>
<tr><td><code id="Generalized+2B20Gamma_+3A_n">n</code></td>
<td>
<p>number of values to generate</p>
</td></tr>
<tr><td><code id="Generalized+2B20Gamma_+3A_m">m</code></td>
<td>
<p>vector of location parameters.</p>
</td></tr>
<tr><td><code id="Generalized+2B20Gamma_+3A_s">s</code></td>
<td>
<p>vector of dispersion parameters.</p>
</td></tr>
<tr><td><code id="Generalized+2B20Gamma_+3A_f">f</code></td>
<td>
<p>vector of family parameters.</p>
</td></tr>
<tr><td><code id="Generalized+2B20Gamma_+3A_log">log</code></td>
<td>
<p>if TRUE, log probabilities are supplied.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J.K. Lindsey</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dgamma">dgamma</a></code> for the gamma distribution,
<code><a href="stats.html#topic+dweibull">dweibull</a></code> for the Weibull distribution, <code><a href="stats.html#topic+dlnorm">dlnorm</a></code>
for the log normal distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dggamma(2, 5, 4, 2)
pggamma(2, 5, 4, 2)
qggamma(0.75, 5, 4, 2)
rggamma(10, 5, 4, 2)
</code></pre>

<hr>
<h2 id='Generalized+20Inverse+20Gaussian'>Generalized Inverse Gaussian Distribution</h2><span id='topic+dginvgauss'></span><span id='topic+pginvgauss'></span><span id='topic+qginvgauss'></span><span id='topic+rginvgauss'></span>

<h3>Description</h3>

<p>These functions provide information about the generalized inverse
Gaussian distribution with mean equal to <code>m</code>, dispersion equal to
<code>s</code>, and family parameter equal to <code>f</code>: density,
cumulative distribution, quantiles, log hazard, and random generation.
</p>
<p>The generalized inverse Gaussian distribution has density
</p>
<p style="text-align: center;"><code class="reqn">
f(y) =
\frac{y^{\nu-1}}{2 \mu^\nu K(1/(\sigma \mu),abs(\nu))}
	\exp(-(1/y+y/\mu^2)/(2*\sigma))</code>
</p>

<p>where <code class="reqn">\mu</code> is the mean of the distribution,
<code class="reqn">\sigma</code> the dispersion, <code class="reqn">\nu</code> is the family
parameter, and <code class="reqn">K()</code> is the fractional Bessel function of
the third kind.
</p>
<p><code class="reqn">\nu=-1/2</code> yields an inverse Gaussian distribution,
<code class="reqn">\sigma=\infty</code>, <code class="reqn">\nu&gt;0</code> a gamma
distribution, and <code class="reqn">\nu=0</code> a hyperbola distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dginvgauss(y, m, s, f, log=FALSE)
pginvgauss(q, m, s, f)
qginvgauss(p, m, s, f)
rginvgauss(n, m, s, f)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Generalized+2B20Inverse+2B20Gaussian_+3A_y">y</code></td>
<td>
<p>vector of responses.</p>
</td></tr>
<tr><td><code id="Generalized+2B20Inverse+2B20Gaussian_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Generalized+2B20Inverse+2B20Gaussian_+3A_p">p</code></td>
<td>
<p>vector of probabilities</p>
</td></tr>
<tr><td><code id="Generalized+2B20Inverse+2B20Gaussian_+3A_n">n</code></td>
<td>
<p>number of values to generate</p>
</td></tr>
<tr><td><code id="Generalized+2B20Inverse+2B20Gaussian_+3A_m">m</code></td>
<td>
<p>vector of means.</p>
</td></tr>
<tr><td><code id="Generalized+2B20Inverse+2B20Gaussian_+3A_s">s</code></td>
<td>
<p>vector of dispersion parameters.</p>
</td></tr>
<tr><td><code id="Generalized+2B20Inverse+2B20Gaussian_+3A_f">f</code></td>
<td>
<p>vector of family parameters.</p>
</td></tr>
<tr><td><code id="Generalized+2B20Inverse+2B20Gaussian_+3A_log">log</code></td>
<td>
<p>if TRUE, log probabilities are supplied.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J.K. Lindsey</p>


<h3>See Also</h3>

<p><code><a href="#topic+dinvgauss">dinvgauss</a></code> for the inverse Gaussian distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dginvgauss(10, 3, 1, 1)
pginvgauss(10, 3, 1, 1)
qginvgauss(0.4, 3, 1, 1)
rginvgauss(10, 3, 1, 1)
</code></pre>

<hr>
<h2 id='Generalized+20Logistic'>Generalized Logistic Distribution</h2><span id='topic+dglogis'></span><span id='topic+pglogis'></span><span id='topic+qglogis'></span><span id='topic+rglogis'></span>

<h3>Description</h3>

<p>These functions provide information about the generalized logistic
distribution with location parameter equal to <code>m</code>, dispersion equal
to <code>s</code>, and family parameter equal to <code>f</code>: density,
cumulative distribution, quantiles, log hazard, and random generation.
</p>
<p>The generalized logistic distribution has density
</p>
<p style="text-align: center;"><code class="reqn">
f(y) =
\frac{\nu \sqrt{3} \exp(-\sqrt{3} (y-\mu)/(\sigma \pi))}{
\sigma \pi (1+\exp(-\sqrt{3} (y-\mu)/(\sigma \pi)))^{\nu+1}}</code>
</p>

<p>where <code class="reqn">\mu</code> is the location parameter of the distribution,
<code class="reqn">\sigma</code> is the dispersion, and <code class="reqn">\nu</code> is the family
parameter.
</p>
<p><code class="reqn">\nu=1</code> gives a logistic distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dglogis(y, m=0, s=1, f=1, log=FALSE)
pglogis(q, m=0, s=1, f=1)
qglogis(p, m=0, s=1, f=1)
rglogis(n, m=0, s=1, f=1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Generalized+2B20Logistic_+3A_y">y</code></td>
<td>
<p>vector of responses.</p>
</td></tr>
<tr><td><code id="Generalized+2B20Logistic_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Generalized+2B20Logistic_+3A_p">p</code></td>
<td>
<p>vector of probabilities</p>
</td></tr>
<tr><td><code id="Generalized+2B20Logistic_+3A_n">n</code></td>
<td>
<p>number of values to generate</p>
</td></tr>
<tr><td><code id="Generalized+2B20Logistic_+3A_m">m</code></td>
<td>
<p>vector of location parameters.</p>
</td></tr>
<tr><td><code id="Generalized+2B20Logistic_+3A_s">s</code></td>
<td>
<p>vector of dispersion parameters.</p>
</td></tr>
<tr><td><code id="Generalized+2B20Logistic_+3A_f">f</code></td>
<td>
<p>vector of family parameters.</p>
</td></tr>
<tr><td><code id="Generalized+2B20Logistic_+3A_log">log</code></td>
<td>
<p>if TRUE, log probabilities are supplied.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J.K. Lindsey</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dlogis">dlogis</a></code> for the logistic distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dglogis(5, 5, 1, 2)
pglogis(5, 5, 1, 2)
qglogis(0.25, 5, 1, 2)
rglogis(10, 5, 1, 2)
</code></pre>

<hr>
<h2 id='Generalized+20Weibull'>Generalized Weibull Distribution</h2><span id='topic+dgweibull'></span><span id='topic+pgweibull'></span><span id='topic+qgweibull'></span><span id='topic+rgweibull'></span>

<h3>Description</h3>

<p>These functions provide information about the generalized Weibull
distribution, also called the exponentiated Weibull, with scale
parameter equal to <code>m</code>, shape equal to <code>s</code>, and family
parameter equal to <code>f</code>: density, cumulative distribution,
quantiles, log hazard, and random generation.
</p>
<p>The generalized Weibull distribution has density
</p>
<p style="text-align: center;"><code class="reqn">
f(y) = \frac{\sigma \nu y^{\sigma-1} (1-\exp(-(y/\mu)^\sigma))^{\nu-1}
\exp(-(y/\mu)^\sigma)}{\mu^\sigma}</code>
</p>

<p>where <code class="reqn">\mu</code> is the scale parameter of the distribution,
<code class="reqn">\sigma</code> is the shape, and <code class="reqn">\nu</code> is the family
parameter.
</p>
<p><code class="reqn">\nu=1</code> gives a Weibull distribution, for
<code class="reqn">\sigma=1</code>, <code class="reqn">\nu&lt;0</code> a generalized F distribution,
and for <code class="reqn">\sigma&gt;0</code>, <code class="reqn">\nu\leq0</code> a Burr type XII distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgweibull(y, s, m, f, log=FALSE)
pgweibull(q, s, m, f)
qgweibull(p, s, m, f)
rgweibull(n, s, m, f)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Generalized+2B20Weibull_+3A_y">y</code></td>
<td>
<p>vector of responses.</p>
</td></tr>
<tr><td><code id="Generalized+2B20Weibull_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Generalized+2B20Weibull_+3A_p">p</code></td>
<td>
<p>vector of probabilities</p>
</td></tr>
<tr><td><code id="Generalized+2B20Weibull_+3A_n">n</code></td>
<td>
<p>number of values to generate</p>
</td></tr>
<tr><td><code id="Generalized+2B20Weibull_+3A_m">m</code></td>
<td>
<p>vector of location parameters.</p>
</td></tr>
<tr><td><code id="Generalized+2B20Weibull_+3A_s">s</code></td>
<td>
<p>vector of dispersion parameters.</p>
</td></tr>
<tr><td><code id="Generalized+2B20Weibull_+3A_f">f</code></td>
<td>
<p>vector of family parameters.</p>
</td></tr>
<tr><td><code id="Generalized+2B20Weibull_+3A_log">log</code></td>
<td>
<p>if TRUE, log probabilities are supplied.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J.K. Lindsey</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dweibull">dweibull</a></code> for the Weibull distribution,
<code><a href="stats.html#topic+df">df</a></code> for the F distribution,
<code><a href="#topic+dburr">dburr</a></code> for the Burr distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dgweibull(5, 1, 3, 2)
pgweibull(5, 1, 3, 2)
qgweibull(0.65, 1, 3, 2)
rgweibull(10, 1, 3, 2)
</code></pre>

<hr>
<h2 id='gettvc'>Find the Most Recent Value of a Time-varying Covariate
Before Each Observed Response</h2><span id='topic+gettvc'></span>

<h3>Description</h3>

<p><code>gettvc</code> finds the most recent value of a time-varying covariate
before each observed response and possibly adds them to a list of other
time-varying covariates.
It compares the times of response observations with those of
time-varying covariates to find the most recent observed time-varying
covariate for each response. These are either placed in a new object of
class, <code>tvcov</code>, added to an already existing list of matrices containing
other time-varying covariates and a new object of class, <code>tvcov</code>,
created, or added to an existing object of class, <code>tvcov</code>.
</p>
<p>If there are response observation times before the first covariate
time, the covariate for these times is set to zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gettvc(response, times=NULL, tvcov=NULL, tvctimes=NULL,
	oldtvcov=NULL, ties=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gettvc_+3A_response">response</code></td>
<td>
<p>A list of two column matrices with response values and
times for each individual, one matrix or dataframe of response
values, or an object of class, <code>response</code> (created by
<code><a href="#topic+restovec">restovec</a></code>).</p>
</td></tr>
<tr><td><code id="gettvc_+3A_times">times</code></td>
<td>
<p>When <code>response</code> is a matrix, a vector of possibly
unequally spaced times for the response, when they are the same for
all individuals or a matrix of times. Not necessary if equally spaced.</p>
</td></tr>
<tr><td><code id="gettvc_+3A_tvcov">tvcov</code></td>
<td>
<p>A list of two column matrices with time-varying covariate
values and corresponding times for each individual or one matrix or
dataframe of such covariate values. Times need not be the same as for
responses.</p>
</td></tr>
<tr><td><code id="gettvc_+3A_tvctimes">tvctimes</code></td>
<td>
<p>When the time-varying covariate is a matrix, a vector
of possibly unequally spaced times for the covariate, when they are
the same for all individuals or a matrix of times. Not necessary if
equally spaced.</p>
</td></tr>
<tr><td><code id="gettvc_+3A_oldtvcov">oldtvcov</code></td>
<td>
<p>A list of matrices with time-varying covariate values,
observed at the event times in <code>response</code>, for each individual,
or an object of class, <code>tvcov</code>. If not provided, a new object is
created.</p>
</td></tr>
<tr><td><code id="gettvc_+3A_ties">ties</code></td>
<td>
<p>If TRUE, when the response and covariate times are
identical, the response depends on that new value (as in observational
studies); if FALSE, only the next response depends on that value (for
example, if the covariate is a new treatment just applied at that time).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class, <code>tvcov</code>, is returned containing the new time-varying
covariate and, possibly, those in <code>oldtvcov</code>.
</p>


<h3>Author(s)</h3>

<p>J.K. Lindsey and D.F. Heitjan</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.list">read.list</a></code>, <code><a href="#topic+restovec">restovec</a></code>,
<code><a href="#topic+tvctomat">tvctomat</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
y &lt;- matrix(rnorm(20), ncol=5)
resp &lt;- restovec(y, times=c(1,3,6,10,15))
z &lt;- matrix(rpois(20,5),ncol=5)
z
# create a new time-varying covariate object for the response
newtvc &lt;- gettvc(resp, tvcov=z, tvctimes=c(1,2,5,12,14))
covariates(newtvc)
# add another time-varying covariate to the object
z2 &lt;- matrix(rpois(20,5),ncol=5)
z2
newtvc2 &lt;- gettvc(resp, tvcov=z2, tvctimes=c(0,4,5,12,16), oldtvc=newtvc)
covariates(newtvc2)

## End(Not run)
</code></pre>

<hr>
<h2 id='Hjorth'>Hjorth Distribution</h2><span id='topic+dhjorth'></span><span id='topic+phjorth'></span><span id='topic+qhjorth'></span><span id='topic+rhjorth'></span>

<h3>Description</h3>

<p>These functions provide information about the Hjorth
distribution with location parameter equal to <code>m</code>, dispersion equal
to <code>s</code>, and family parameter equal to <code>f</code>: density,
cumulative distribution, quantiles, log hazard, and random generation.
</p>
<p>The Hjorth distribution has density
</p>
<p style="text-align: center;"><code class="reqn">
f(y) = (1+\sigma y)^{-\nu/\sigma} \exp(-(y/\mu)^2/2)
(\frac{y}{\mu^2}+\frac{\nu}{1+\sigma y})</code>
</p>

<p>where <code class="reqn">\mu</code> is the location parameter of the distribution,
<code class="reqn">\sigma</code> is the dispersion, and <code class="reqn">\nu</code> is the family
parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dhjorth(y, m, s, f, log=FALSE)
phjorth(q, m, s, f)
qhjorth(p, m, s, f)
rhjorth(n, m, s, f)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Hjorth_+3A_y">y</code></td>
<td>
<p>vector of responses.</p>
</td></tr>
<tr><td><code id="Hjorth_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Hjorth_+3A_p">p</code></td>
<td>
<p>vector of probabilities</p>
</td></tr>
<tr><td><code id="Hjorth_+3A_n">n</code></td>
<td>
<p>number of values to generate</p>
</td></tr>
<tr><td><code id="Hjorth_+3A_m">m</code></td>
<td>
<p>vector of location parameters.</p>
</td></tr>
<tr><td><code id="Hjorth_+3A_s">s</code></td>
<td>
<p>vector of dispersion parameters.</p>
</td></tr>
<tr><td><code id="Hjorth_+3A_f">f</code></td>
<td>
<p>vector of family parameters.</p>
</td></tr>
<tr><td><code id="Hjorth_+3A_log">log</code></td>
<td>
<p>if TRUE, log probabilities are supplied.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J.K. Lindsey</p>


<h3>Examples</h3>

<pre><code class='language-R'>dhjorth(5, 5, 5, 2)
phjorth(5, 5, 5, 2)
qhjorth(0.8, 5, 5, 2)
rhjorth(10, 5, 5, 2)
</code></pre>

<hr>
<h2 id='int'>Vectorized Numerical Integration</h2><span id='topic+int'></span>

<h3>Description</h3>

<p><code>int</code> performs numerical integration of a given function using
either Romberg integration or algorithm 614 of the collected
algorithms from ACM. Only the former is vectorized. The latter uses
formulae optimal in certain Hardy spaces h(p,d).
</p>
<p>Functions may have singularities at one or both end-points of the
interval (a,b).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>int(f, a=-Inf, b=Inf, type="Romberg", eps=0.0001, max=NULL, d=NULL, p=0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="int_+3A_f">f</code></td>
<td>
<p>The function (of one variable) to integrate, returning either
a scalar or a vector.</p>
</td></tr>
<tr><td><code id="int_+3A_a">a</code></td>
<td>
<p>A scalar or vector (only Romberg) giving the lower bound(s).
A vector cannot contain both -Inf and finite values.</p>
</td></tr>
<tr><td><code id="int_+3A_b">b</code></td>
<td>
<p>A scalar or vector (only Romberg) giving the upper bound(s).
A vector cannot contain both Inf and finite values.</p>
</td></tr>
<tr><td><code id="int_+3A_type">type</code></td>
<td>
<p>The algorithm to be used, by default Romberg integration.
Otherwise, it uses the TOMS614 algorithm.</p>
</td></tr>
<tr><td><code id="int_+3A_eps">eps</code></td>
<td>
<p>Precision.</p>
</td></tr>
<tr><td><code id="int_+3A_max">max</code></td>
<td>
<p>For Romberg, the maximum number of steps, by default set
to 16. For TOMS614, the maximum number of function evaluations, by
default set to 100.</p>
</td></tr>
<tr><td><code id="int_+3A_d">d</code></td>
<td>
<p>For Romberg, the number of extrapolation points so that
2d is the order of integration, by default set to 5; d=2 is Simpson's
rule. For TOMS614, heuristic termination = any real number;
deterministic termination = a number in the range 0 &lt; d &lt; pi/2
by default, set to 1.</p>
</td></tr>
<tr><td><code id="int_+3A_p">p</code></td>
<td>
<p>For TOMS614, p = 0: heuristic termination, p = 1:
deterministic termination with the infinity norm, p &gt; 1: deterministic
termination with the p-th norm.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The vector of values of the integrals of the function supplied.
</p>


<h3>Author(s)</h3>

<p>J.K. Lindsey</p>


<h3>References</h3>

<p>ACM algorithm 614 appeared in
</p>
<p>ACM-Trans. Math. Software, Vol.10, No. 2, Jun., 1984, p. 152-160.
</p>
<p>See also
</p>
<p>Sikorski,K., Optimal quadrature algorithms in HP spaces, Num. Math.,
39, 405-410 (1982).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) sin(x)+cos(x)-x^2
int(f, a=0, b=2)
int(f, a=0, b=2, type="TOMS614")
#
f &lt;- function(x) exp(-(x-2)^2/2)/sqrt(2*pi)
int(f, a=0:3)
int(f, a=0:3, d=2)
1-pnorm(0:3, 2)
#
f &lt;- function(x) dnorm(x)
int(f, a=-Inf, b=qnorm(0.975))
int(f, a=-Inf, b=qnorm(0.975), type="TOMS614", max=1e2)
</code></pre>

<hr>
<h2 id='int2'>Vectorized Two-dimensional Numerical Integration</h2><span id='topic+int2'></span>

<h3>Description</h3>

<p><code>int</code> performs vectorized numerical integration of a given
two-dimensional function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>int2(f, a=c(-Inf,-Inf), b=c(Inf,Inf), eps=1.0e-6, max=16, d=5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="int2_+3A_f">f</code></td>
<td>
<p>The function (of two variables) to integrate, returning either
a scalar or a vector.</p>
</td></tr>
<tr><td><code id="int2_+3A_a">a</code></td>
<td>
<p>A two-element vector or a two-column matrix giving the lower
bounds. It cannot contain both -Inf and finite values.</p>
</td></tr>
<tr><td><code id="int2_+3A_b">b</code></td>
<td>
<p>A two-element vector or a two-column matrix giving the upper
bounds. It cannot contain both Inf and finite values.</p>
</td></tr>
<tr><td><code id="int2_+3A_eps">eps</code></td>
<td>
<p>Precision.</p>
</td></tr>
<tr><td><code id="int2_+3A_max">max</code></td>
<td>
<p>The maximum number of steps, by default set to 16.</p>
</td></tr>
<tr><td><code id="int2_+3A_d">d</code></td>
<td>
<p>The number of extrapolation points so that 2k is the order of
integration, by default set to 5; d=2 is Simpson's rule.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The vector of values of the integrals of the function supplied.
</p>


<h3>Author(s)</h3>

<p>J.K. Lindsey</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x,y) sin(x)+cos(y)-x^2
int2(f, a=c(0,1), b=c(2,4))
#
fn1 &lt;- function(x, y) x^2+y^2
fn2 &lt;- function(x, y) (1:4)*x^2+(2:5)*y^2
int2(fn1, c(1,2), c(2,4))
int2(fn2, c(1,2), c(2,4))
int2(fn1, matrix(c(1:4,1:4),ncol=2), matrix(c(2:5,2:5),ncol=2))
int2(fn2, matrix(c(1:4,1:4),ncol=2), matrix(c(2:5,2:5),ncol=2))
</code></pre>

<hr>
<h2 id='Inverse+20Gaussian'>Inverse Gaussian Distribution</h2><span id='topic+dinvgauss'></span><span id='topic+pinvgauss'></span><span id='topic+qinvgauss'></span><span id='topic+rinvgauss'></span>

<h3>Description</h3>

<p>These functions provide information about the inverse Gaussian
distribution with mean equal to <code>m</code> and dispersion equal to
<code>s</code>: density, cumulative distribution, quantiles, log hazard, and
random generation.
</p>
<p>The inverse Gaussian distribution has density
</p>
<p style="text-align: center;"><code class="reqn">
f(y) =
\frac{1}{\sqrt{2\pi\sigma y^3}} e^{-(y-\mu)^2/(2 y \sigma m^2)}</code>
</p>

<p>where <code class="reqn">\mu</code> is the mean of the distribution and
<code class="reqn">\sigma</code> is the dispersion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dinvgauss(y, m, s, log=FALSE)
pinvgauss(q, m, s)
qinvgauss(p, m, s)
rinvgauss(n, m, s)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Inverse+2B20Gaussian_+3A_y">y</code></td>
<td>
<p>vector of responses.</p>
</td></tr>
<tr><td><code id="Inverse+2B20Gaussian_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Inverse+2B20Gaussian_+3A_p">p</code></td>
<td>
<p>vector of probabilities</p>
</td></tr>
<tr><td><code id="Inverse+2B20Gaussian_+3A_n">n</code></td>
<td>
<p>number of values to generate</p>
</td></tr>
<tr><td><code id="Inverse+2B20Gaussian_+3A_m">m</code></td>
<td>
<p>vector of means.</p>
</td></tr>
<tr><td><code id="Inverse+2B20Gaussian_+3A_s">s</code></td>
<td>
<p>vector of dispersion parameters.</p>
</td></tr>
<tr><td><code id="Inverse+2B20Gaussian_+3A_log">log</code></td>
<td>
<p>if TRUE, log probabilities are supplied.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J.K. Lindsey</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dnorm">dnorm</a></code> for the normal distribution and
<code><a href="stats.html#topic+dlnorm">dlnorm</a></code> for the <em>Log</em>normal distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dinvgauss(5, 5, 1)
pinvgauss(5, 5, 1)
qinvgauss(0.8, 5, 1)
rinvgauss(10, 5, 1)
</code></pre>

<hr>
<h2 id='iprofile'>Produce Individual Time Profiles for Plotting</h2><span id='topic+iprofile'></span><span id='topic+iprofile.default'></span><span id='topic+plot.iprofile'></span>

<h3>Description</h3>

<p><code>iprofile</code> is used for plotting individual profiles over time
for objects obtained from dynamic models. It produces output for
plotting recursive fitted values for individual time profiles from
such models.
</p>
<p>See <code><a href="#topic+mprofile">mprofile</a></code> for plotting marginal profiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'iprofile'
plot(x, nind=1, observed=TRUE, intensity=FALSE,
	add=FALSE, lty=NULL, pch=NULL, ylab=NULL, xlab=NULL,
	main=NULL, ylim=NULL, xlim=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iprofile_+3A_x">x</code></td>
<td>
<p>An object of class <code>iprofile</code>, e.g. <code>x = iprofile(z, plotsd=FALSE)</code>,
where <code>z</code> is an object of class <code>recursive</code>, from
<code>carma</code>, <code>elliptic</code>,
<code>gar</code>, <code>kalcount</code>,
<code>kalseries</code>, <code>kalsurv</code>, or
<code>nbkal</code>.
If <code>plotsd</code> is If TRUE, plots standard deviations around profile
(<code>carma</code> and <code>elliptic</code> only).</p>
</td></tr>
<tr><td><code id="iprofile_+3A_nind">nind</code></td>
<td>
<p>Observation number(s) of individual(s) to be plotted.</p>
</td></tr>
<tr><td><code id="iprofile_+3A_observed">observed</code></td>
<td>
<p>If TRUE, plots observed responses.</p>
</td></tr>
<tr><td><code id="iprofile_+3A_intensity">intensity</code></td>
<td>
<p>If z has class, <code>kalsurv</code>, and this is TRUE, the
intensity is plotted instead of the time between events.</p>
</td></tr>
<tr><td><code id="iprofile_+3A_add">add</code></td>
<td>
<p>If TRUE, the graph is added to an existing plot.</p>
</td></tr>
<tr><td><code id="iprofile_+3A_lty">lty</code>, <code id="iprofile_+3A_pch">pch</code>, <code id="iprofile_+3A_main">main</code>, <code id="iprofile_+3A_ylim">ylim</code>, <code id="iprofile_+3A_xlim">xlim</code>, <code id="iprofile_+3A_xlab">xlab</code>, <code id="iprofile_+3A_ylab">ylab</code></td>
<td>
<p> See base plot.</p>
</td></tr>
<tr><td><code id="iprofile_+3A_...">...</code></td>
<td>
<p>Arguments passed to other functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>iprofile</code> returns information ready for plotting by
<code>plot.iprofile</code>.
</p>


<h3>Author(s)</h3>

<p>J.K. Lindsey</p>


<h3>See Also</h3>

<p><code><a href="#topic+mprofile">mprofile</a></code>
<code><a href="#topic+plot.residuals">plot.residuals</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## try this after you have repeated package installed
library(repeated)
times &lt;- rep(1:20,2)
dose &lt;- c(rep(2,20),rep(5,20))
mu &lt;- function(p) exp(p[1]-p[3])*(dose/(exp(p[1])-exp(p[2]))*
	(exp(-exp(p[2])*times)-exp(-exp(p[1])*times)))
shape &lt;- function(p) exp(p[1]-p[2])*times*dose*exp(-exp(p[1])*times)
conc &lt;- matrix(rgamma(40,1,scale=mu(log(c(1,0.3,0.2)))),ncol=20,byrow=TRUE)
conc[,2:20] &lt;- conc[,2:20]+0.5*(conc[,1:19]-matrix(mu(log(c(1,0.3,0.2))),
	ncol=20,byrow=TRUE)[,1:19])
conc &lt;- ifelse(conc&gt;0,conc,0.01)
z &lt;- gar(conc, dist="gamma", times=1:20, mu=mu, shape=shape,
	preg=log(c(1,0.4,0.1)), pdepend=0.5, pshape=log(c(1,0.2)))
# plot individual profiles and the average profile
plot(iprofile(z), nind=1:2, pch=c(1,20), lty=3:4)
plot(mprofile(z), nind=1:2, lty=1:2, add=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='Laplace'>Laplace Distribution</h2><span id='topic+dlaplace'></span><span id='topic+plaplace'></span><span id='topic+qlaplace'></span><span id='topic+rlaplace'></span>

<h3>Description</h3>

<p>These functions provide information about the Laplace distribution
with location parameter equal to <code>m</code> and dispersion equal to
<code>s</code>: density, cumulative distribution, quantiles, log hazard, and
random generation.
</p>
<p>The Laplace distribution has density
</p>
<p style="text-align: center;"><code class="reqn">
f(y) = \frac{\exp(-abs(y-\mu)/\sigma)}{(2\sigma)}</code>
</p>

<p>where <code class="reqn">\mu</code> is the location parameter of the distribution and
<code class="reqn">\sigma</code> is the dispersion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlaplace(y, m=0, s=1, log=FALSE)
plaplace(q, m=0, s=1)
qlaplace(p, m=0, s=1)
rlaplace(n=1, m=0, s=1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Laplace_+3A_y">y</code></td>
<td>
<p>vector of responses.</p>
</td></tr>
<tr><td><code id="Laplace_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Laplace_+3A_p">p</code></td>
<td>
<p>vector of probabilities</p>
</td></tr>
<tr><td><code id="Laplace_+3A_n">n</code></td>
<td>
<p>number of values to generate</p>
</td></tr>
<tr><td><code id="Laplace_+3A_m">m</code></td>
<td>
<p>vector of location parameters.</p>
</td></tr>
<tr><td><code id="Laplace_+3A_s">s</code></td>
<td>
<p>vector of dispersion parameters.</p>
</td></tr>
<tr><td><code id="Laplace_+3A_log">log</code></td>
<td>
<p>if TRUE, log probabilities are supplied.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J.K. Lindsey</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dexp">dexp</a></code> for the exponential distribution and
<code><a href="stats.html#topic+dcauchy">dcauchy</a></code> for the Cauchy distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dlaplace(5, 2, 1)
plaplace(5, 2, 1)
qlaplace(0.95, 2, 1)
rlaplace(10, 2, 1)
</code></pre>

<hr>
<h2 id='Levy'>Levy Distribution</h2><span id='topic+dlevy'></span><span id='topic+plevy'></span><span id='topic+qlevy'></span><span id='topic+rlevy'></span>

<h3>Description</h3>

<p>These functions provide information about the Levy distribution
with location parameter equal to <code>m</code> and dispersion equal to
<code>s</code>: density, cumulative distribution, quantiles, and
random generation.
</p>
<p>The Levy distribution has density
</p>
<p style="text-align: center;"><code class="reqn">
f(y) = \sqrt{\frac{\sigma}{2 \pi (y-\mu)^3}} \exp(-\sigma/(2 (y-\mu)))</code>
</p>

<p>where <code class="reqn">\mu</code> is the location parameter of the distribution and
<code class="reqn">\sigma</code> is the dispersion, and <code class="reqn">y&gt;\mu</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlevy(y, m=0, s=1, log=FALSE)
plevy(q, m=0, s=1)
qlevy(p, m=0, s=1)
rlevy(n, m=0, s=1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Levy_+3A_y">y</code></td>
<td>
<p>vector of responses.</p>
</td></tr>
<tr><td><code id="Levy_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Levy_+3A_p">p</code></td>
<td>
<p>vector of probabilities</p>
</td></tr>
<tr><td><code id="Levy_+3A_n">n</code></td>
<td>
<p>number of values to generate</p>
</td></tr>
<tr><td><code id="Levy_+3A_m">m</code></td>
<td>
<p>vector of location parameters.</p>
</td></tr>
<tr><td><code id="Levy_+3A_s">s</code></td>
<td>
<p>vector of dispersion parameters.</p>
</td></tr>
<tr><td><code id="Levy_+3A_log">log</code></td>
<td>
<p>if TRUE, log probabilities are supplied.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J.K. Lindsey</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dnorm">dnorm</a></code> for the normal distribution and
<code><a href="stats.html#topic+dcauchy">dcauchy</a></code> for the Cauchy distribution, two other stable
distributions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dlevy(5, 2, 1)
plevy(5, 2, 1)
qlevy(0.6, 2, 1)
rlevy(10, 2, 1)
</code></pre>

<hr>
<h2 id='lin.diff.eqn'>Solution of Autonomous Linear Differential Equations</h2><span id='topic+lin.diff.eqn'></span>

<h3>Description</h3>

<p><code>lin.diff.eqn</code> numerically solves a system of autonomous linear
differential equations with given initial conditions by matrix
exponentiation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lin.diff.eqn(A, initial, t=1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lin.diff.eqn_+3A_a">A</code></td>
<td>
<p>A square matrix giving the coefficients of the equations.</p>
</td></tr>
<tr><td><code id="lin.diff.eqn_+3A_initial">initial</code></td>
<td>
<p>The vector of initial values of the system.</p>
</td></tr>
<tr><td><code id="lin.diff.eqn_+3A_t">t</code></td>
<td>
<p>A scalar or vector of values of the independent variable for
which solutions are sought.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of solutions with one row for each value of <code>t</code>.
</p>


<h3>Author(s)</h3>

<p>J.K. Lindsey</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- matrix(c(1,0,1,0,0,0,0,0,-1),ncol=3,byrow=TRUE)
x &lt;- c(5,7,6)
lin.diff.eqn(a,x,1)
# function giving the exact solution
exact &lt;- function(t) c(8*exp(t)-3*exp(-t),7,6*exp(-t))
exact(1)
</code></pre>

<hr>
<h2 id='lvna'>Create a repeated Object, Leaving NAs</h2><span id='topic+lvna'></span>

<h3>Description</h3>

<p><code>lvna</code> forms an object of class, <code>repeated</code>, from a response
object and possibly time-varying or intra-individual covariate
(<code>tvcov</code>), and time-constant or inter-individual covariate
(<code>tccov</code>) objects. If there are NAs in any variables, it also
creates a logical vector indicating which observations have NAs either
in the response or the covariate values. Subjects
must be in the same order in all (three) objects to be combined.
</p>
<p>Such objects can be printed and plotted. Methods are available for
extracting the response, the numbers of observations per individual,
the times, the weights, the units of measurement/Jacobian, the nesting
variable, the covariates, and their names: <code><a href="#topic+response">response</a></code>,
<code><a href="#topic+nobs">nobs</a></code>, <code><a href="#topic+times">times</a></code>,
<code><a href="#topic+weights">weights</a></code>, <code><a href="#topic+delta">delta</a></code>,
<code><a href="#topic+nesting">nesting</a></code>, <code><a href="#topic+covariates">covariates</a></code>, and
<code><a href="#topic+names">names</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lvna(response, ccov=NULL, tvcov=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lvna_+3A_response">response</code></td>
<td>
<p>An object of class, <code>response</code> (created by
<code><a href="#topic+restovec">restovec</a></code>), containing the response variable information.</p>
</td></tr>
<tr><td><code id="lvna_+3A_ccov">ccov</code></td>
<td>
<p>An object of class, <code>tccov</code> (created by
<code><a href="#topic+tcctomat">tcctomat</a></code>), containing the time-constant or
inter-individual covariate information.</p>
</td></tr>
<tr><td><code id="lvna_+3A_tvcov">tvcov</code></td>
<td>
<p>An object of class, <code>tvcov</code> (created by
<code><a href="#topic+tvctomat">tvctomat</a></code>), containing the time-varying or
intra-individual covariate information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class, <code>repeated</code>, containing a list of the
response object (<code>z$response</code>, so that, for example, the response vector
is <code>z$response$y</code>; see <code><a href="#topic+restovec">restovec</a></code>), possibly the two
classes of covariate objects (<code>z$ccov</code> and <code>z$tvcov</code>; see
<code><a href="#topic+tcctomat">tcctomat</a></code> and <code><a href="#topic+tvctomat">tvctomat</a></code>),
and a logical vector (<code>z$NAs</code>) indicating which observations have
an NA in the response or some covariate.
</p>


<h3>Author(s)</h3>

<p>J.K. Lindsey</p>


<h3>See Also</h3>

<p><code><a href="#topic+DataMethods">DataMethods</a></code>, <code><a href="#topic+covariates">covariates</a></code>,
<code><a href="#topic+covind">covind</a></code>, <code><a href="#topic+delta">delta</a></code>,
<code><a href="#topic+dftorep">dftorep</a></code>, <code><a href="#topic+names">names</a></code>,
<code><a href="#topic+nesting">nesting</a></code>, <code><a href="#topic+nobs">nobs</a></code>,
<code><a href="#topic+read.list">read.list</a></code>, <code><a href="#topic+read.surv">read.surv</a></code>,
<code><a href="#topic+response">response</a></code>, <code><a href="#topic+resptype">resptype</a></code>,
<code><a href="#topic+restovec">restovec</a></code>, <code><a href="#topic+rmna">rmna</a></code>,
<code><a href="#topic+tcctomat">tcctomat</a></code>, <code><a href="#topic+times">times</a></code>,
<code><a href="#topic+transform">transform</a></code>, <code><a href="#topic+tvctomat">tvctomat</a></code>,
<code><a href="#topic+units">units</a></code>, <code><a href="#topic+weights">weights</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- matrix(rnorm(20),ncol=5)
y[2,3] &lt;- NA
tt &lt;- c(1,3,6,10,15)
print(resp &lt;- restovec(y,times=tt))
x &lt;- c(0,0,1,1)
tcc &lt;- tcctomat(x)
z &lt;- matrix(rpois(20,5),ncol=5)
tvc &lt;- tvctomat(z)
print(reps &lt;- lvna(resp, tvcov=tvc, ccov=tcc))
response(reps)
response(reps, nind=2:3)
times(reps)
nobs(reps)
weights(reps)
covariates(reps)
covariates(reps,names="x")
covariates(reps,names="z")
names(reps)
nesting(reps)
# because individuals are the only nesting, this is the same as
covind(reps)
# binomial
y &lt;- matrix(rpois(20,5),ncol=5)
y[2,3] &lt;- NA
print(respb &lt;- restovec(y,totals=y+matrix(rpois(20,5),ncol=5),times=tt))
print(repsb &lt;- lvna(respb, tvcov=tvc, ccov=tcc))
response(repsb)
# censored data
y &lt;- matrix(rweibull(20,2,5),ncol=5)
print(respc &lt;- restovec(y,censor=matrix(rbinom(20,1,0.9),ncol=5),times=tt))
print(repsc &lt;- lvna(respc, tvcov=tvc, ccov=tcc))
# if there is no censoring, censor indicator is not printed
response(repsc)
# nesting clustered within individuals
nest &lt;- c(1,1,2,2,2)
print(respn &lt;- restovec(y,censor=matrix(rbinom(20,1,0.9),ncol=5),
	times=tt,nest=nest))
print(repsn &lt;- lvna(respn, tvcov=tvc, ccov=tcc))
response(respn)
times(respn)
nesting(respn)
</code></pre>

<hr>
<h2 id='mexp'>Matrix Exponentiation</h2><span id='topic+mexp'></span>

<h3>Description</h3>

<p><code>mexp</code> calculates <code>exp(t*x)</code> for the square matrix, <code>x</code>, by
spectral decomposition or series expansion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mexp(x, t=1, type="spectral decomposition", n=20, k=3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mexp_+3A_x">x</code></td>
<td>
<p>A square matrix.</p>
</td></tr>
<tr><td><code id="mexp_+3A_t">t</code></td>
<td>
<p>Constant multiplying the matrix.</p>
</td></tr>
<tr><td><code id="mexp_+3A_type">type</code></td>
<td>
<p>Algorithm used: spectral decomposition or series approximation.</p>
</td></tr>
<tr><td><code id="mexp_+3A_n">n</code></td>
<td>
<p>Number of terms in the series expansion.</p>
</td></tr>
<tr><td><code id="mexp_+3A_k">k</code></td>
<td>
<p>Constant divisor to avoid over- or underflow (series
approximation only).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>mexp</code> returns the exponential of a matrix.
</p>


<h3>Author(s)</h3>

<p>J.K. Lindsey</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(c(1,2,3,4),nrow=2)
mexp(x)
</code></pre>

<hr>
<h2 id='mpower'>Power of a Matrix</h2><span id='topic++25+5E+25'></span>

<h3>Description</h3>

<p><code>%^%</code> calculates <code>x^p</code> for the square matrix, <code>x</code>, by
spectral decomposition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x%^%p
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mpower_+3A_x">x</code></td>
<td>
<p>A square matrix.</p>
</td></tr>
<tr><td><code id="mpower_+3A_p">p</code></td>
<td>
<p>The power to which the matrix is to be raised.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>%^%</code> returns the power of a matrix.
</p>


<h3>Author(s)</h3>

<p>J.K. Lindsey</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- matrix(c(0.4,0.6,0.6,0.4),nrow=2)
x%^%2
x%^%10
x%^%20

## End(Not run)
</code></pre>

<hr>
<h2 id='mprofile'>Produce Marginal Time Profiles for Plotting</h2><span id='topic+mprofile'></span><span id='topic+mprofile.default'></span><span id='topic+plot.mprofile'></span>

<h3>Description</h3>

<p><code>mprofile</code> is used for plotting marginal profiles over time
for models obtained from dynamic models, for given fixed values of
covariates. These are either obtained from those supplied by the
model, if available, or from a function supplied by the user.
</p>
<p>See <code><a href="#topic+iprofile">iprofile</a></code> for plotting individual profiles from
recursive fitted values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mprofile'
plot(x, nind=1, intensity=FALSE, add=FALSE, ylim=range(z$pred, na.rm = TRUE),
	lty=NULL, ylab=NULL, xlab=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mprofile_+3A_x">x</code></td>
<td>
<p>An object of class <code>mprofile</code>, e.g. <code>x = mprofile(z, times=NULL, mu=NULL, ccov, plotse=TRUE)</code>, where <code>z</code>An object of class <code>recursive</code>, from <code>carma</code>,
<code>elliptic</code>, <code>gar</code>,
<code>kalcount</code>, <code>kalseries</code>,
<code>kalsurv</code>, or <code>nbkal</code>; 
<code>times</code> is a vector of time points at which profiles are to be plotted;
<code>mu</code> is the location regression as a function of the parameters and
the times for the desired covariate values;
<code>ccov</code> is covariate values for the profiles (<code>carma</code>
only); and 
<code>plotse</code> when TRUE plots standard errors
(<code>carma</code> only).</p>
</td></tr>
<tr><td><code id="mprofile_+3A_nind">nind</code></td>
<td>
<p>Observation number(s) of individual(s) to be plotted. (Not
used if <code>mu</code> is supplied.)</p>
</td></tr>
<tr><td><code id="mprofile_+3A_intensity">intensity</code></td>
<td>
<p>If TRUE, the intensity is plotted instead of the time
between events. Only for models produced by <code>kalsurv</code>.</p>
</td></tr>
<tr><td><code id="mprofile_+3A_add">add</code></td>
<td>
<p>If TRUE, add contour to previous plot instead of creating a
new one.</p>
</td></tr>
<tr><td><code id="mprofile_+3A_lty">lty</code>, <code id="mprofile_+3A_ylim">ylim</code>, <code id="mprofile_+3A_xlab">xlab</code>, <code id="mprofile_+3A_ylab">ylab</code></td>
<td>
<p> See base plot.</p>
</td></tr>
<tr><td><code id="mprofile_+3A_...">...</code></td>
<td>
<p>Arguments passed to other functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>mprofile</code>  returns information ready for plotting by
<code>plot.mprofile</code>.
</p>


<h3>Author(s)</h3>

<p>J.K. Lindsey</p>


<h3>See Also</h3>

<p><code><a href="#topic+iprofile">iprofile</a></code>,
<code><a href="#topic+plot.residuals">plot.residuals</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## try after you get the repeated package
library(repeated)
times &lt;- rep(1:20,2)
dose &lt;- c(rep(2,20),rep(5,20))
mu &lt;- function(p) exp(p[1]-p[3])*(dose/(exp(p[1])-exp(p[2]))*
	(exp(-exp(p[2])*times)-exp(-exp(p[1])*times)))
shape &lt;- function(p) exp(p[1]-p[2])*times*dose*exp(-exp(p[1])*times)
conc &lt;- matrix(rgamma(40,1,scale=mu(log(c(1,0.3,0.2)))),ncol=20,byrow=TRUE)
conc[,2:20] &lt;- conc[,2:20]+0.5*(conc[,1:19]-matrix(mu(log(c(1,0.3,0.2))),
	ncol=20,byrow=TRUE)[,1:19])
conc &lt;- ifelse(conc&gt;0,conc,0.01)
z &lt;- gar(conc, dist="gamma", times=1:20, mu=mu, shape=shape,
	preg=log(c(1,0.4,0.1)), pdepend=0.5, pshape=log(c(1,0.2)))
# plot individual profiles and the average profile
plot(iprofile(z), nind=1:2, pch=c(1,20), lty=3:4)
plot(mprofile(z), nind=1:2, lty=1:2, add=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='Multiplicative+20Binomial'>Multiplicative Binomial Distribution</h2><span id='topic+dmultbinom'></span><span id='topic+pmultbinom'></span><span id='topic+qmultbinom'></span><span id='topic+rmultbinom'></span>

<h3>Description</h3>

<p>These functions provide information about the multiplicative binomial
distribution with parameters <code>m</code> and <code>s</code>: density,
cumulative distribution, quantiles, and random generation.
</p>
<p>The multiplicative binomial distribution with total <code class="reqn">= n</code> and
<code>prob</code> <code class="reqn">= m</code> has density
</p>
<p style="text-align: center;"><code class="reqn">p(y) = c({n}, {m}, {s}){n \choose y} {m}^{y} {(1-m)}^{n-y} {s}^{(y(n-y))}
</code>
</p>

<p>for <code class="reqn">y = 0, \ldots, n</code>, where c(.) is a normalizing constant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmultbinom(y, size, m, s, log=FALSE)
pmultbinom(q, size, m, s)
qmultbinom(p, size, m, s)
rmultbinom(n, size, m, s)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Multiplicative+2B20Binomial_+3A_y">y</code></td>
<td>
<p>vector of frequencies</p>
</td></tr>
<tr><td><code id="Multiplicative+2B20Binomial_+3A_q">q</code></td>
<td>
<p>vector of quantiles</p>
</td></tr>
<tr><td><code id="Multiplicative+2B20Binomial_+3A_p">p</code></td>
<td>
<p>vector of probabilities</p>
</td></tr>
<tr><td><code id="Multiplicative+2B20Binomial_+3A_n">n</code></td>
<td>
<p>number of values to generate</p>
</td></tr>
<tr><td><code id="Multiplicative+2B20Binomial_+3A_size">size</code></td>
<td>
<p>vector of totals</p>
</td></tr>
<tr><td><code id="Multiplicative+2B20Binomial_+3A_m">m</code></td>
<td>
<p>vector of probabilities of success</p>
</td></tr>
<tr><td><code id="Multiplicative+2B20Binomial_+3A_s">s</code></td>
<td>
<p>vector of overdispersion parameters</p>
</td></tr>
<tr><td><code id="Multiplicative+2B20Binomial_+3A_log">log</code></td>
<td>
<p>if TRUE, log probabilities are supplied.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J.K. Lindsey</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dbinom">dbinom</a></code> for the binomial, <code><a href="#topic+ddoublebinom">ddoublebinom</a></code> for
the double binomial, and <code><a href="#topic+dbetabinom">dbetabinom</a></code>
for the beta binomial distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># compute P(45 &lt; y &lt; 55) for y multiplicative binomial(100,0.5,1.1)
sum(dmultbinom(46:54, 100, 0.5, 1.1))
pmultbinom(54, 100, 0.5, 1.1)-pmultbinom(45, 100, 0.5, 1.1)
pmultbinom(2,10,0.5,1.1)
qmultbinom(0.025,10,0.5,1.1)
rmultbinom(10,10,0.5,1.1)
</code></pre>

<hr>
<h2 id='MultPoisson'>Multiplicative Poisson Distribution</h2><span id='topic+dmultpois'></span><span id='topic+pmultpois'></span><span id='topic+qmultpois'></span><span id='topic+rmultpois'></span>

<h3>Description</h3>

<p>These functions provide information about the multiplicative Poisson
distribution with parameters <code>m</code> and <code>s</code>: density,
cumulative distribution, quantiles, and random generation.
</p>
<p>The multiplicative Poisson distribution with <code>mu</code> <code class="reqn">= m</code> has density
</p>
<p style="text-align: center;"><code class="reqn">p(y) = c({\mu}, {\lambda})\exp({-\mu}) {\mu}^{y} {\lambda}^({y}^2) / {y!}%
</code>
</p>

<p>with <code class="reqn">s &lt;= 1</code> for <code class="reqn">y = 0, \ldots</code>, where c(.) is a normalizing
constant.
</p>
<p>Note that it only allows for underdispersion, not being defined for
<code class="reqn">s &gt; 1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmultpois(y, m, s, log=FALSE)
pmultpois(q, m, s)
qmultpois(p, m, s)
rmultpois(n, m, s)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MultPoisson_+3A_y">y</code></td>
<td>
<p>vector of counts</p>
</td></tr>
<tr><td><code id="MultPoisson_+3A_q">q</code></td>
<td>
<p>vector of quantiles</p>
</td></tr>
<tr><td><code id="MultPoisson_+3A_p">p</code></td>
<td>
<p>vector of probabilities</p>
</td></tr>
<tr><td><code id="MultPoisson_+3A_n">n</code></td>
<td>
<p>number of values to generate</p>
</td></tr>
<tr><td><code id="MultPoisson_+3A_m">m</code></td>
<td>
<p>scalar or vector of means</p>
</td></tr>
<tr><td><code id="MultPoisson_+3A_s">s</code></td>
<td>
<p>scalar or vector of overdispersion parameters, all of which
must lie in (0,1). </p>
</td></tr>
<tr><td><code id="MultPoisson_+3A_log">log</code></td>
<td>
<p>if TRUE, log probabilities are supplied.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J.K. Lindsey</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dpois">dpois</a></code> for the Poisson, <code><a href="#topic+ddoublepois">ddoublepois</a></code> for
the double Poisson, <code><a href="#topic+dpvfpois">dpvfpois</a></code> for the power variance
function Poisson, <code><a href="#topic+dconsul">dconsul</a></code> for the Consul
generalized Poisson, <code><a href="#topic+dgammacount">dgammacount</a></code> for the gamma count, and
<code><a href="stats.html#topic+dnbinom">dnbinom</a></code> for the negative binomial distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dmultpois(5,10,0.9)
pmultpois(5,10,0.9)
qmultpois(0.85,10,0.9)
rmultpois(10,10,0.9)
</code></pre>

<hr>
<h2 id='Pareto'>Pareto Distribution</h2><span id='topic+dpareto'></span><span id='topic+ppareto'></span><span id='topic+qpareto'></span><span id='topic+rpareto'></span>

<h3>Description</h3>

<p>These functions provide information about the Pareto distribution
with location parameter equal to <code>m</code> and dispersion equal to
<code>s</code>: density, cumulative distribution, quantiles, log hazard, and
random generation.
</p>
<p>The Pareto distribution has density
</p>
<p style="text-align: center;"><code class="reqn">
f(y) = \frac{\sigma }{\mu (\sigma-1)(1 + y/(\mu (\sigma-1)))^{\sigma+1}}</code>
</p>

<p>where <code class="reqn">\mu</code> is the mean parameter of the distribution and
<code class="reqn">\sigma</code> is the dispersion.
</p>
<p>This distribution can be obtained as a mixture distribution from the
exponential distribution using a gamma mixing distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dpareto(y, m, s, log=FALSE)
ppareto(q, m, s)
qpareto(p, m, s)
rpareto(n, m, s)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Pareto_+3A_y">y</code></td>
<td>
<p>vector of responses.</p>
</td></tr>
<tr><td><code id="Pareto_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Pareto_+3A_p">p</code></td>
<td>
<p>vector of probabilities</p>
</td></tr>
<tr><td><code id="Pareto_+3A_n">n</code></td>
<td>
<p>number of values to generate</p>
</td></tr>
<tr><td><code id="Pareto_+3A_m">m</code></td>
<td>
<p>vector of location parameters.</p>
</td></tr>
<tr><td><code id="Pareto_+3A_s">s</code></td>
<td>
<p>vector of dispersion parameters.</p>
</td></tr>
<tr><td><code id="Pareto_+3A_log">log</code></td>
<td>
<p>if TRUE, log probabilities are supplied.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J.K. Lindsey</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dexp">dexp</a></code> for the exponential distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dpareto(5, 2, 2)
ppareto(5, 2, 2)
qpareto(0.9, 2, 2)
rpareto(10, 2, 2)
</code></pre>

<hr>
<h2 id='pkpd'>Pharmacokinetic Compartment Models</h2><span id='topic+pkpd'></span><span id='topic+mu1.0o1c'></span><span id='topic+mu1.1o1c'></span><span id='topic+mu1.1o2c'></span><span id='topic+mu1.1o2cl'></span><span id='topic+mu1.1o2cc'></span><span id='topic+mu2.0o1c'></span><span id='topic+mu2.0o2c1'></span><span id='topic+mu2.0o2c2'></span><span id='topic+mu2.1o1c'></span><span id='topic+mu2.0o1cfp'></span><span id='topic+mu2.0o2c1fp'></span><span id='topic+mu2.0o2c2fp'></span><span id='topic+mu2.1o1cfp'></span>

<h3>Description</h3>

<p>Mean functions for use in fitting pharmacokineticcompartment models models.
</p>
<p><code>mu1.0o1c</code>: open zero-order one-compartment model
</p>
<p><code>mu1.1o1c</code>: open first-order one-compartment model
</p>
<p><code>mu1.1o2c</code>: open first-order two-compartment model (ordered)
</p>
<p><code>mu1.1o2cl</code>: open first-order two-compartment model (ordered,
absorption and transfer equal)
</p>
<p><code>mu1.1o2cc</code>: open first-order two-compartment model (circular)
</p>
<p>Simultaneous models for parent drug and metabolite:
</p>
<p><code>mu2.0o1c</code>: zero-order one-compartment model
</p>
<p><code>mu2.0o2c1</code>: zero-order two-compartment for parent,
one-compartment for metabolite, model
</p>
<p><code>mu2.0o2c2</code>: zero-order two-compartment model for both parent and
metabolite
</p>
<p><code>mu2.1o1c</code>: first-order one-compartment model
</p>
<p><code>mu2.0o1cfp</code>: zero-order one-compartment first-pass model
</p>
<p><code>mu2.0o2c1fp</code>: zero-order two-compartment for parent,
one-compartment for metabolite, model with first-pass
</p>
<p><code>mu2.0o2c2fp</code>: zero-order two-compartment model for both parent and
metabolite with first-pass
</p>
<p><code>mu2.1o1cfp</code>: first-order one-compartment first-pass model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mu1.0o1c(p, times, dose=1, end=0.5)
mu1.1o1c(p, times, dose=1)
mu1.1o2c(p, times, dose=1)
mu1.1o2cl(p, times, dose=1)
mu1.1o2cc(p, times, dose=1)
mu2.0o1c(p, times, dose=1, ind, end=0.5)
mu2.0o2c1(p, times, dose=1, ind, end=0.5)
mu2.0o2c2(p, times, dose=1, ind, end=0.5)
mu2.1o1c(p, times, dose=1, ind)
mu2.0o1cfp(p, times, dose=1, ind, end=0.5)
mu2.0o2c1fp(p, times, dose=1, ind, end=0.5)
mu2.0o2c2fp(p, times, dose=1, ind, end=0.5)
mu2.1o1cfp(p, times, dose=1, ind)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pkpd_+3A_p">p</code></td>
<td>
<p>Vector of parameters. See the source file for details.</p>
</td></tr>
<tr><td><code id="pkpd_+3A_times">times</code></td>
<td>
<p>Vector of times.</p>
</td></tr>
<tr><td><code id="pkpd_+3A_dose">dose</code></td>
<td>
<p>Vector of dose levels.</p>
</td></tr>
<tr><td><code id="pkpd_+3A_ind">ind</code></td>
<td>
<p>Indicator whether parent drug or metabolite.</p>
</td></tr>
<tr><td><code id="pkpd_+3A_end">end</code></td>
<td>
<p>Time infusion ends.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The profile of mean concentrations for the given times and doses is
returned.
</p>


<h3>Author(s)</h3>

<p>J.K. Lindsey</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(repeated)
times &lt;- rep(1:20,2)
dose &lt;- c(rep(2,20),rep(5,20))
# set up a mean function for gar based on mu1.1o1c:
mu &lt;- function(p) {
	ka &lt;- exp(p[2])
	ke &lt;- exp(p[3])
	exp(p[2]-p[1])/(ka-ke)*(exp(-ke*times)-exp(-ka*times))}
conc &lt;- matrix(rgamma(40,2,scale=mu(log(c(1,0.3,0.2)))/2),ncol=20,byrow=TRUE)
conc[,2:20] &lt;- conc[,2:20]+0.5*(conc[,1:19]-matrix(mu(log(c(1,0.3,0.2))),
	ncol=20,byrow=TRUE)[,1:19])
conc &lt;- ifelse(conc&gt;0,conc,0.01)
gar(conc, dist="gamma", times=1:20, mu=mu, preg=log(c(1,0.4,0.1)),
	pdepend=0.1, pshape=1)
# changing variance
shape &lt;- mu
gar(conc, dist="gamma", times=1:20, mu=mu, preg=log(c(0.5,0.4,0.1)),
	pdep=0.1, shape=shape, pshape=log(c(0.5,0.4,0.1)))

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.residuals'>Plot Residuals</h2><span id='topic+plot.residuals'></span>

<h3>Description</h3>

<p><code>plot.residuals</code> is used for plotting residuals from models
obtained from dynamic models for given subsets of the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'residuals'
plot(x, X=NULL, subset=NULL, ccov=NULL, nind=NULL,
	recursive=TRUE, pch=20, ylab="Residual", xlab=NULL,
	main=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.residuals_+3A_x">x</code></td>
<td>
<p>An object of class recursive, from <code>carma</code>,
<code>gar</code>, <code>kalcount</code>,
<code>kalseries</code>, <code>kalsurv</code>, or
<code>nbkal</code>.</p>
</td></tr>
<tr><td><code id="plot.residuals_+3A_x">X</code></td>
<td>
<p>Vector of of values for the x-axis. If missing, time is
used. It can also be specified by the strings &quot;response&quot; or &quot;fitted&quot;.</p>
</td></tr>
<tr><td><code id="plot.residuals_+3A_subset">subset</code></td>
<td>
<p>A logical vector defining which observations are to be
used.</p>
</td></tr>
<tr><td><code id="plot.residuals_+3A_ccov">ccov</code></td>
<td>
<p>If the name of a time-constant covariate is
supplied, separate plots are made for each distinct value of that
covariate.</p>
</td></tr>
<tr><td><code id="plot.residuals_+3A_nind">nind</code></td>
<td>
<p>Observation number(s) of individual(s) to be plotted.</p>
</td></tr>
<tr><td><code id="plot.residuals_+3A_recursive">recursive</code></td>
<td>
<p>If TRUE, plot recursive residuals, otherwise ordinary
residuals.</p>
</td></tr>
<tr><td><code id="plot.residuals_+3A_pch">pch</code>, <code id="plot.residuals_+3A_ylab">ylab</code>, <code id="plot.residuals_+3A_xlab">xlab</code>, <code id="plot.residuals_+3A_main">main</code>, <code id="plot.residuals_+3A_...">...</code></td>
<td>
<p>Plotting control options.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J.K. Lindsey</p>


<h3>See Also</h3>

<p><code>carma</code>, <code>gar</code>,
<code>kalcount</code>, <code>kalseries</code>,
<code>kalsurv</code>, <code>nbkal</code>
<code><a href="#topic+plot.iprofile">plot.iprofile</a></code>, <code><a href="#topic+plot.mprofile">plot.mprofile</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(repeated)
times &lt;- rep(1:20,2)
dose &lt;- c(rep(2,20),rep(5,20))
mu &lt;- function(p) exp(p[1]-p[3])*(dose/(exp(p[1])-exp(p[2]))*
	(exp(-exp(p[2])*times)-exp(-exp(p[1])*times)))
shape &lt;- function(p) exp(p[1]-p[2])*times*dose*exp(-exp(p[1])*times)
conc &lt;- matrix(rgamma(40,2,scale=mu(log(c(1,0.3,0.2)))/2),ncol=20,byrow=TRUE)
conc[,2:20] &lt;- conc[,2:20]+0.5*(conc[,1:19]-matrix(mu(log(c(1,0.3,0.2))),
	ncol=20,byrow=TRUE)[,1:19])
conc &lt;- ifelse(conc&gt;0,conc,0.01)
z &lt;- gar(conc, dist="gamma", times=1:20, mu=mu, shape=shape,
	preg=log(c(1,0.4,0.1)), pdepend=0.1, pshape=log(c(1,0.2)))
plot.residuals(z, subset=1:20, main="Dose 1")
plot.residuals(z, x="fitted", subset=1:20, main="Dose 1")
plot.residuals(z, x="response", subset=1:20, main="Dose 1")

## End(Not run)
</code></pre>

<hr>
<h2 id='PowerExponential'>Power Exponential Distribution</h2><span id='topic+dpowexp'></span><span id='topic+ppowexp'></span><span id='topic+qpowexp'></span><span id='topic+rpowexp'></span>

<h3>Description</h3>

<p>These functions provide information about the power exponential
distribution with mean parameter equal to <code>m</code>, dispersion equal
to <code>s</code>, and family parameter equal to <code>f</code>: density,
cumulative distribution, quantiles, log hazard, and random generation.
</p>
<p>The power exponential distribution has density
</p>
<p style="text-align: center;"><code class="reqn">
f(y) = \frac{\exp(-(abs{y-\mu}/\sqrt{\sigma})^{2 \nu}/2)}{
\sqrt{\sigma} Gamma(1+1/(2 \nu)) 2^{1+1/(2 \nu)}}</code>
</p>

<p>where <code class="reqn">\mu</code> is the mean of the distribution,
<code class="reqn">\sigma</code> is the dispersion, and <code class="reqn">\nu</code> is the family
parameter. <code class="reqn">\nu=1</code> yields a normal distribution,
<code class="reqn">\nu=0.5</code> a Laplace distribution, and
<code class="reqn">\nu=\infty</code>  a uniform distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dpowexp(y, m=0, s=1, f=1, log=FALSE)
ppowexp(q, m=0, s=1, f=1)
qpowexp(p, m=0, s=1, f=1)
rpowexp(n, m=0, s=1, f=1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PowerExponential_+3A_y">y</code></td>
<td>
<p>vector of responses.</p>
</td></tr>
<tr><td><code id="PowerExponential_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="PowerExponential_+3A_p">p</code></td>
<td>
<p>vector of probabilities</p>
</td></tr>
<tr><td><code id="PowerExponential_+3A_n">n</code></td>
<td>
<p>number of values to generate</p>
</td></tr>
<tr><td><code id="PowerExponential_+3A_m">m</code></td>
<td>
<p>vector of means.</p>
</td></tr>
<tr><td><code id="PowerExponential_+3A_s">s</code></td>
<td>
<p>vector of dispersion parameters.</p>
</td></tr>
<tr><td><code id="PowerExponential_+3A_f">f</code></td>
<td>
<p>vector of family parameters.</p>
</td></tr>
<tr><td><code id="PowerExponential_+3A_log">log</code></td>
<td>
<p>if TRUE, log probabilities are supplied.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J.K. Lindsey</p>


<h3>Examples</h3>

<pre><code class='language-R'>dpowexp(5, 5, 1, 2)
ppowexp(5, 5, 1, 2)
qpowexp(0.5, 5, 1, 2)
rpowexp(10, 5, 1, 2)
</code></pre>

<hr>
<h2 id='PvfPoisson'>Power Variance Function Poisson Distribution</h2><span id='topic+dpvfpois'></span><span id='topic+ppvfpois'></span><span id='topic+qpvfpois'></span><span id='topic+rpvfpois'></span>

<h3>Description</h3>

<p>These functions provide information about the overdispersed power
variance function Poisson distribution with parameters <code>m</code>,
<code>s</code>, and <code>f</code>: density, cumulative distribution, quantiles,
and random generation. This function is obtained from a Poisson
distribution as a mixture with a power variance distribution. In the
limit, for <code>f=0</code>, the mixing distribution is gamma so that it is
a negative binomial distribution.  For <code>f=0.5</code>, the mixing
distribution is inverse Gaussian. For <code>f&lt;0</code>, the mixing
distribution is a compound distribution of the sum of a Poisson number
of gamma distributions. For <code>f=1</code>, it is undefined.
</p>
<p>The power variance function Poisson distribution with <code>m</code> <code class="reqn">=
\mu</code>, the mean, <code>s</code> <code class="reqn">= \theta</code>, and <code>f</code> <code class="reqn">= \alpha</code>
has density
</p>
<p style="text-align: center;"><code class="reqn">p(y) =
{\exp(-\mu((\theta+1)^\alpha/\theta^\alpha-\theta)/\alpha)\over y!}
\sum_{i=1}^y c_{yi}(\alpha)\mu^i(\theta+1)^{i\alpha-y}/\theta^{i(\alpha-1)}
</code>
</p>

<p>for <code class="reqn">y = 0, \ldots</code>, where <code>c_{yi}(f)</code> are coefficients
obtained by recursion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dpvfpois(y, m, s, f, log=FALSE)
ppvfpois(q, m, s, f)
qpvfpois(p, m, s, f)
rpvfpois(n, m, s, f)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PvfPoisson_+3A_y">y</code></td>
<td>
<p>vector of counts</p>
</td></tr>
<tr><td><code id="PvfPoisson_+3A_q">q</code></td>
<td>
<p>vector of quantiles</p>
</td></tr>
<tr><td><code id="PvfPoisson_+3A_p">p</code></td>
<td>
<p>vector of probabilities</p>
</td></tr>
<tr><td><code id="PvfPoisson_+3A_n">n</code></td>
<td>
<p>number of values to generate</p>
</td></tr>
<tr><td><code id="PvfPoisson_+3A_m">m</code></td>
<td>
<p>scalar or vector of means</p>
</td></tr>
<tr><td><code id="PvfPoisson_+3A_s">s</code></td>
<td>
<p>scalar or vector of overdispersion parameters</p>
</td></tr>
<tr><td><code id="PvfPoisson_+3A_f">f</code></td>
<td>
<p>scalar or vector of family parameters, all &lt; 1</p>
</td></tr>
<tr><td><code id="PvfPoisson_+3A_log">log</code></td>
<td>
<p>if TRUE, log probabilities are supplied.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J.K. Lindsey</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dpois">dpois</a></code> for the Poisson, <code><a href="#topic+ddoublepois">ddoublepois</a></code> for
the double Poisson, <code><a href="#topic+dmultpois">dmultpois</a></code> for
the multiplicative Poisson, <code><a href="#topic+dconsul">dconsul</a></code> for the Consul
generalized Poisson, <code><a href="#topic+dgammacount">dgammacount</a></code> for the gamma count, and
<code><a href="stats.html#topic+dnbinom">dnbinom</a></code> for the negative binomial distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dpvfpois(5,10,0.9,0.5)
ppvfpois(5,10,0.9,0.5)
qpvfpois(0.85,10,0.9,0.5)
rpvfpois(10,10,0.9,0.5)
</code></pre>

<hr>
<h2 id='read.list'>Read a List of Matrices from a File for Unbalanced Repeated
Measurements</h2><span id='topic+read.list'></span>

<h3>Description</h3>

<p><code>read.list</code> reads sets of lines of data from a file and creates a
list of matrices. Different sets of lines may be have different lengths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.list(file="", skip=0, nlines=2, order=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.list_+3A_file">file</code></td>
<td>
<p>Name of the file to read</p>
</td></tr>
<tr><td><code id="read.list_+3A_skip">skip</code></td>
<td>
<p>Number of lines to skip at the beginning of the file</p>
</td></tr>
<tr><td><code id="read.list_+3A_nlines">nlines</code></td>
<td>
<p>Number of lines per matrix</p>
</td></tr>
<tr><td><code id="read.list_+3A_order">order</code></td>
<td>
<p>Order in which the lines are to be used as columns of the
matrix. If NULL, they are placed in the order read.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The list of matrices, each with <code>nlines</code> columns, is returned.
</p>


<h3>Author(s)</h3>

<p>J.K. Lindsey</p>


<h3>See Also</h3>

<p><code><a href="#topic+lvna">lvna</a></code>, <code><a href="#topic+read.rep">read.rep</a></code>,
<code><a href="#topic+read.surv">read.surv</a></code>, <code><a href="#topic+restovec">restovec</a></code>,
<code><a href="#topic+rmna">rmna</a></code>, <code><a href="#topic+tvctomat">tvctomat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: y &lt;- read.list("test.dat")
</code></pre>

<hr>
<h2 id='read.rep'>Read a Rectangular Data Set from a File to Create a repeated Object</h2><span id='topic+read.rep'></span>

<h3>Description</h3>

<p><code>dftorep</code> forms an object of class, <code>repeated</code>, from data
read from a file with the option of removing any observations where
response and covariate values have NAs. For repeated measurements,
observations on the same individual must be together in the file. A
number of validity checks are performed on the data.
</p>
<p>Such objects can be printed and plotted. Methods are available for
extracting the response, the numbers of observations per individual,
the times, the weights, the units of measurement/Jacobian, the nesting
variable, the covariates, and their names: <code><a href="#topic+response">response</a></code>,
<code><a href="#topic+nobs">nobs</a></code>, <code><a href="#topic+times">times</a></code>,
<code><a href="#topic+weights">weights</a></code>, <code><a href="#topic+delta">delta</a></code>,
<code><a href="#topic+nesting">nesting</a></code>, <code><a href="#topic+covariates">covariates</a></code>, and
<code><a href="#topic+names">names</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.rep(file, header=TRUE, skip=0, sep = "", na.strings="NA",
	response, id=NULL, times=NULL, censor=NULL, totals=NULL,
	weights=NULL, nest=NULL, delta=NULL, coordinates=NULL,
	type=NULL, ccov=NULL, tvcov=NULL, na.rm=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.rep_+3A_file">file</code></td>
<td>
<p>A file name from which to read the data with variables as
columns and observations as rows.</p>
</td></tr>
<tr><td><code id="read.rep_+3A_header">header</code></td>
<td>
<p>A logical value indicating whether the file contains the
names of the variables as the line before the first row of data.</p>
</td></tr>
<tr><td><code id="read.rep_+3A_skip">skip</code></td>
<td>
<p>The number of lines of the file to skip before beginning
to read data.</p>
</td></tr>
<tr><td><code id="read.rep_+3A_sep">sep</code></td>
<td>
<p>The field separator character. Values on each line of the
file are separated by this character.</p>
</td></tr>
<tr><td><code id="read.rep_+3A_na.strings">na.strings</code></td>
<td>
<p>A vector of strings defining what values are to be
assigned NA.</p>
</td></tr>
<tr><td><code id="read.rep_+3A_response">response</code></td>
<td>
<p>A character vector giving the column name(s) of the
dataframe for the response variable(s).</p>
</td></tr>
<tr><td><code id="read.rep_+3A_id">id</code></td>
<td>
<p>A character vector giving the column name of the
dataframe for the identification numbers of the individuals. If the
numbers are not consecutive integers, a warning is given.
</p>
<p>If NULL, one observation per individual is assumed if <code>times</code> is
also NULL, other time series is assumed.</p>
</td></tr>
<tr><td><code id="read.rep_+3A_times">times</code></td>
<td>
<p>An optional character vector giving the column name of the
dataframe for the times vector.</p>
</td></tr>
<tr><td><code id="read.rep_+3A_censor">censor</code></td>
<td>
<p>An optional character vector giving the column name(s)
of the dataframe for the censor indicator(s). This must be the same
length as <code>response</code>. Responses without censor indicator can have
a column either of all NAs or all 1s.</p>
</td></tr>
<tr><td><code id="read.rep_+3A_totals">totals</code></td>
<td>
<p>An optional character vector giving the column name(s)
of the dataframe for the totals for binomial data. This must be the same
length as <code>response</code>. Responses without censor indicator can have
a column all NAs.</p>
</td></tr>
<tr><td><code id="read.rep_+3A_weights">weights</code></td>
<td>
<p>An optional character vector giving the column name of
the dataframe for the weights vector.</p>
</td></tr>
<tr><td><code id="read.rep_+3A_nest">nest</code></td>
<td>
<p>An optional character vector giving the column name of
the dataframe for the nesting vector within individuals.
</p>
<p>This is the second level of nesting for repeated measurements, with
the individual being the first level. Values for an individual must be
consecutive increasing integers.</p>
</td></tr>
<tr><td><code id="read.rep_+3A_delta">delta</code></td>
<td>
<p>An optional character vector giving the column name(s)
of the dataframe for the units of measurement/Jacobian(s) of the
response(s). This must be the same length as <code>response</code>.
Responses without units of measurement/Jacobian can have a column all
NAs.
</p>
<p>If all response variables have the same unit of measurement, this can
be that one number. If each response variable has the same unit of
measurement for all its values, this can be a numeric vector of length
the number of response variables.</p>
</td></tr>
<tr><td><code id="read.rep_+3A_coordinates">coordinates</code></td>
<td>
<p>An optional character vector giving the two or
three column name(s) of the dataframe for the spatial coordinates.</p>
</td></tr>
<tr><td><code id="read.rep_+3A_type">type</code></td>
<td>
<p>An optional character vector giving the types of response
variables: nominal, ordinal, discrete, duration, continuous,
multivariate, or unknown.</p>
</td></tr>
<tr><td><code id="read.rep_+3A_ccov">ccov</code></td>
<td>
<p>An optional character vector giving the column names of
the dataframe for the time-constant or inter-individual covariates.
For repeated measurements, if the value is not constant for all
observations on an individual, an error is produced.</p>
</td></tr>
<tr><td><code id="read.rep_+3A_tvcov">tvcov</code></td>
<td>
<p>An optional character vector giving the column names of
the dataframe for the time-varying or intra-individual covariates.</p>
</td></tr>
<tr><td><code id="read.rep_+3A_na.rm">na.rm</code></td>
<td>
<p>If TRUE, observations with NAs in any variables selected
are removed in the object returned. Otherwise, the corresponding
indicator variable is returned in a slot in the object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class, <code>repeated</code>, containing a list of the
response object (<code>z$response</code>, so that, for example, the response vector
is <code>z$response$y</code>; see <code><a href="#topic+restovec">restovec</a></code>), and
possibly the two classes of covariate objects (<code>z$ccov</code> and
<code>z$tvcov</code>; see <code><a href="#topic+tcctomat">tcctomat</a></code> and
<code><a href="#topic+tvctomat">tvctomat</a></code>).
</p>


<h3>Author(s)</h3>

<p>J.K. Lindsey</p>


<h3>See Also</h3>

<p><code><a href="#topic+dftorep">dftorep</a></code>, <code><a href="#topic+lvna">lvna</a></code>,
<code><a href="#topic+read.list">read.list</a></code>, <code><a href="#topic+restovec">restovec</a></code>,
<code><a href="#topic+rmna">rmna</a></code>, <code><a href="#topic+tcctomat">tcctomat</a></code>,
<code><a href="#topic+tvctomat">tvctomat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: read.rep("test.dat", resp=c("y1","y2"), times="tt", id="id",
## Not run: 	totals=c("tot1","tot2"), tvcov="x",ccov="x2")
</code></pre>

<hr>
<h2 id='read.surv'>Read a List of Matrices from a File for Repeated Times to Events</h2><span id='topic+read.surv'></span>

<h3>Description</h3>

<p><code>read.surv</code> reads sets of lines of data from a file. Each set may
contain a series of duration times followed by a censor indicator for
the last value (<code>all=FALSE</code>) or a series of pairs of times followed by
their censor indicators (<code>all=TRUE</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.surv(file="", skip=0, nlines=1, cumulative=TRUE, all=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.surv_+3A_file">file</code></td>
<td>
<p>Name of the file to read</p>
</td></tr>
<tr><td><code id="read.surv_+3A_skip">skip</code></td>
<td>
<p>Number of lines to skip at the beginning of the file</p>
</td></tr>
<tr><td><code id="read.surv_+3A_nlines">nlines</code></td>
<td>
<p>Number of lines in each series of duration times</p>
</td></tr>
<tr><td><code id="read.surv_+3A_cumulative">cumulative</code></td>
<td>
<p>If TRUE, the times are cumulative and differences
are taken to obtain times between events. Otherwise, the times are
used unchanged.</p>
</td></tr>
<tr><td><code id="read.surv_+3A_all">all</code></td>
<td>
<p>If TRUE, all times have accompanying censor indicators;
otherwise, only the last one does.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing a list of vectors with the series of times and a
vector of censor indicators for the last time of each series is returned.
</p>


<h3>Author(s)</h3>

<p>J.K. Lindsey</p>


<h3>See Also</h3>

<p><code><a href="#topic+lvna">lvna</a></code>, <code><a href="#topic+read.list">read.list</a></code>,
<code><a href="#topic+read.rep">read.rep</a></code>, <code><a href="#topic+restovec">restovec</a></code>,
<code><a href="#topic+rmna">rmna</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: y &lt;- read.surv("test.dat")
</code></pre>

<hr>
<h2 id='restovec'>Create a response Object</h2><span id='topic+restovec'></span>

<h3>Description</h3>

<p><code>restovec</code> can produce an object of class, <code>response</code>, from
a vector of (1) independent univariate responses or (2) a single time
series.
</p>
<p>It can produce such an object from repeated measurements in the form
of (1) a list of vectors of event histories, (2) a list of two or more
column matrices with times, response values, and and other information
or (3) a matrix or dataframe of response values. The first two are for
unbalanced data and the third for balanced data.
</p>
<p>Multivariate responses can be supplied as (1) a three-dimensional
array of balanced repeated measurements, (2) lists of matrices for
unbalanced repeated measurements, or (3) a matrix with either (a)
several time series or (b) single observations per individual on
several variables.
</p>
<p>In formula and functions, the key words, <code>times</code> can be used to
refer to the response times from the data object as a covariate,
<code>individuals</code> to the index for individuals as a factor covariate,
and <code>nesting</code> the index for nesting as a factor covariate. The
latter two only work for W&amp;R notation.
</p>
<p>NAs can be detected with <code><a href="#topic+lvna">lvna</a></code> or removed with
<code><a href="#topic+rmna">rmna</a></code> (where necessary, in coordination with the
appropriate covariates) to create a <code>repeated</code> object.
</p>
<p><code>response</code> objects can be printed and plotted. Methods are
available for extracting the response, the numbers of observations per
individual, the times, the weights, the units of measurement/Jacobian,
and the nesting variable: <code><a href="#topic+response">response</a></code>,
<code><a href="#topic+nobs">nobs</a></code>, <code><a href="#topic+times">times</a></code>,
<code><a href="#topic+weights">weights</a></code>, <code><a href="#topic+delta">delta</a></code>, and
<code><a href="#topic+nesting">nesting</a></code>.
</p>
<p>The response and or the times may be <a href="#topic+transform">transform</a>ed using
<code>transform(z, newy=fcn1(y), times=fcn2(times))</code> where
<code>fcn1</code> and <code>fcn2</code> are transformations and <code>y</code> is the
name of a response variable. When the response is
transformed, the Jacobian is automatically calculated. Note that, if
the unit of precision/Jacobian (<code><a href="#topic+delta">delta</a></code>) is available in
the <code>response</code> object, this is automatically included in the
calculation of the likelihood function in all library model functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>restovec(response=NULL, times=NULL, nest=NULL, coordinates=NULL,
	censor=NULL, totals=NULL, weights=NULL, delta=NULL,
	type=NULL, names=NULL, units=NULL, oldresponse=NULL,
	description=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="restovec_+3A_response">response</code></td>
<td>
<p>For (1) independent univariate responses with one
observation per individual or (2) a single time series, one vector may
be supplied (in the latter case, the times must be given even if
equally spaced).
</p>
<p>Univariate repeated measurements responses can be given (1) if
balanced, as a matrix or dataframe of response values with dimensions:
number of individuals by number of responses/individual, (2) a list of
vectors of event histories, or (3) a list of one or more column
matrices, for each individual, with response values in the first
column and times in the second (if there are no times, set
<code>times</code> to FALSE), possibly followed by columns with nesting
categories, binomial totals, censoring indicators, and/or units of
measurement.
</p>
<p>Multivariate responses can be supplied as (1) a three-dimensional
array of balanced repeated measurements with dimensions: number of
individuals by number of responses/individual by number of variables,
(2) a list of matrices for unbalanced repeated measurements each with
dimensions: number of responses on that individual by number of
variables, plus a column for times if available (otherwise set
<code>times</code> to FALSE), or (3) a matrix with either (a) several time
series, having dimensions: length of time series by by number of times
series, or (b) single observations per individual on several variables
with dimensions: number of individuals by number of variables. In all
but case (1), <code>type</code> must be a character vector with length equal
to the number of responses. In case (2), where applicable, <code>censor</code>,
<code>totals</code>, and <code>delta</code> must be supplied as lists of matrices
of the same size as for <code>response</code>, and <code>nest</code> and
<code>weights</code> as lists of vectors of lengths equal to the number of
observations on each individual.</p>
</td></tr>
<tr><td><code id="restovec_+3A_times">times</code></td>
<td>
<p>When <code>response</code> is a matrix or multivariate array,
these can be (1) a vector when the times are the same for all
individuals, possibly unequally-spaced, or (2) a matrix with
dimensions: number of individuals by number of responses/individual.
Not necessary if times are equally spaced, except if a vector
containing a single time series is supplied (if not given in this
case, it takes the responses to be independent, not a time
series). For clustered data with no time ordering, set to FALSE.</p>
</td></tr>
<tr><td><code id="restovec_+3A_nest">nest</code></td>
<td>
<p>This is the second level of nesting, with the individual
being the first level. Values for an individual must be consecutive
increasing integers with all responses in the same cluster grouped
together. For example, with three clusters of four observations each,
the code would be 1,1,1,1,2,2,2,2,3,3,3,3.
</p>
<p>When <code>response</code> is a matrix or multivariate array, this can be a
vector of length equal to the number of responses/individual
indicating which responses belong to which nesting category.
</p>
<p>If <code>response</code> is a multivariate list, this must also be a list.
</p>
<p>When <code>response</code> is a univariate list of unbalanced repeated
measurements, the nesting indicator may instead be included in that
list but must respect the same ordering as described above.</p>
</td></tr>
<tr><td><code id="restovec_+3A_coordinates">coordinates</code></td>
<td>
<p>When <code>response</code> is a vector, a two-column
matrix giving the coordinates for spatial data.</p>
</td></tr>
<tr><td><code id="restovec_+3A_censor">censor</code></td>
<td>
<p>When <code>response</code> is a matrix, this can be (1) a vector
of the same length as the number of individuals, containing a binary
indicator, with a one indicating that the last time period in the
series terminated with an event and zero that it was censored, or
(2) a matrix of the same size as <code>response</code>.
</p>
<p>When <code>response</code> is a multivariate array, this can be (1) a matrix
with dimensions: number of individuals by number of responses, or (2)
an array of the same size as <code>response</code>. In the first case, for
each column corresponding to a duration response, it should contain a
binary indicator, with a one indicating that the last time period in
the series terminated with an event and zero that it was censored, and
NAs in columns not containing durations. In the second case, layers
not corresponding to duration responses should contain NAs.
</p>
<p>If <code>response</code> is a multivariate list, this must also be a list.
</p>
<p>For event history data, even with no censoring, an appropriate vector
of ones must be supplied.
</p>
<p>When <code>response</code> is a univariate list of unbalanced repeated
measurements, the censoring indicator may instead be included in that
list.</p>
</td></tr>
<tr><td><code id="restovec_+3A_totals">totals</code></td>
<td>
<p>If the response is a matrix of binomial counts, this can
be (1) a corresponding vector (one total per individual) or (2) a
matrix of totals.
</p>
<p>When <code>response</code> is a multivariate array, this can be (1) a matrix
with dimensions: number of individuals by number of responses if all
binomial responses for an individual have the same total, or (2) an
array of the same size as <code>response</code>. In the first case, for each
column corresponding to a binomial response, it should contain the
corresponding totals, with NAs in columns not containing binomial. In
the second case, layers not corresponding to binomial responses should
contain NAs.
</p>
<p>If <code>response</code> is a multivariate list, this must also be a list.
</p>
<p>When <code>response</code> is a univariate list of unbalanced repeated
measurements, the totals may instead be included in that list.</p>
</td></tr>
<tr><td><code id="restovec_+3A_weights">weights</code></td>
<td>
<p>A vector, matrix, array, or list of vectors of
frequencies or weights, with one value per <code>response</code>. In other
words, a multivariate response has only one corresponding weight value.</p>
</td></tr>
<tr><td><code id="restovec_+3A_delta">delta</code></td>
<td>
<p>For continuous measurements, the unit of precision (if
not equal to unity) for each response: a scalar, vector, matrix,
array, or list of the same dimensions as <code>response</code>. For example,
if responses have two decimal places (<code>12.34</code>), <code>delta=0.01</code>.
If the response has been transformed, this should be multiplied by the
numerical values of the Jacobian. When the <code>transform</code> method is
applied to the <code>response</code> object, this is automatically updated.</p>
</td></tr>
<tr><td><code id="restovec_+3A_type">type</code></td>
<td>
<p>The type(s) of observations: nominal, ordinal, discrete,
duration, continuous, or unknown. If not specified otherwise, those
responses with <code>delta</code> and no <code>censor</code> are assumed to be
<code>continuous</code>, those with <code>censor</code> indicator are assumed to
be <code>duration</code>, those with <code>totals</code> are assumed to be
<code>nominal</code>, and all others <code>unknown</code>.</p>
</td></tr>
<tr><td><code id="restovec_+3A_names">names</code></td>
<td>
<p>Optional name(s) of the response variable(s).</p>
</td></tr>
<tr><td><code id="restovec_+3A_units">units</code></td>
<td>
<p>Optional character vector giving units of measurement of
response(s).</p>
</td></tr>
<tr><td><code id="restovec_+3A_oldresponse">oldresponse</code></td>
<td>
<p>An existing <code>response</code> object to which the new
data are to be added.</p>
</td></tr>
<tr><td><code id="restovec_+3A_description">description</code></td>
<td>
<p>An optional named list of character vectors with
names of some or all response variables containing their descriptions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class, <code>response</code>, containing a vector with the
responses (<code>z$y</code>), a corresponding vector of times (<code>z$times</code>) if
applicable, a vector giving the number of observations per individual
(<code>z$nobs</code>, set to a scalar 1 if observations are independent),
type  (<code>z$delta</code>), and possibly binomial totals (<code>z$n</code>),
nesting (clustering, <code>z$nest</code>), censoring (<code>z$censor</code>),
weights (<code>z$wt</code>),  unit of precision/Jacobian (<code>z$delta</code>),
units of measurement (<code>z$units</code>), and description
(<code>z$description</code>) information.
</p>


<h3>Author(s)</h3>

<p>J.K. Lindsey</p>


<h3>See Also</h3>

<p><code><a href="#topic+DataMethods">DataMethods</a></code>, <code><a href="#topic+covind">covind</a></code>,
<code><a href="#topic+delta">delta</a></code>, <code><a href="#topic+description">description</a></code>,
<code><a href="#topic+lvna">lvna</a></code>, <code><a href="#topic+names">names</a></code>,
<code><a href="#topic+nesting">nesting</a></code>, <code><a href="#topic+nobs">nobs</a></code>,
<code><a href="#topic+read.list">read.list</a></code>, <code><a href="#topic+read.surv">read.surv</a></code>,
<code><a href="#topic+response">response</a></code>, <code><a href="#topic+resptype">resptype</a></code>,
<code><a href="#topic+rmna">rmna</a></code>, <code><a href="#topic+tcctomat">tcctomat</a></code>,
<code><a href="#topic+times">times</a></code>, <code><a href="#topic+transform">transform</a></code>,
<code><a href="#topic+tvctomat">tvctomat</a></code>, <code><a href="#topic+units">units</a></code>,
<code><a href="#topic+weights">weights</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
#continuous response
y &lt;- matrix(rnorm(20),ncol=5)
# times assumed to be 1:5
restovec(y, units="m")
#unequally-spaced times
tt &lt;- c(1,3,6,10,15)
print(resp &lt;- restovec(y, times=tt, units="m",
	description=list(y="Response measured in metres")))
response(resp)
response(resp, nind=2:3)
response(transform(resp, y=1/y))
transform(resp, y=1/y, units="1/m")
units(resp)
description(resp)
times(resp)
times(transform(resp, times=times-6))
nobs(resp)
weights(resp)
nesting(resp)
# because individuals are the only nesting, this is the same as
covind(resp)
#
# binomial response
y &lt;- matrix(rpois(20,5),ncol=5)
# responses summarized as relative frequencies
print(respb &lt;- restovec(y, totals=y+matrix(rpois(20,5),ncol=5), times=tt))
response(respb)
#
# censored data
y &lt;- matrix(rweibull(20,2,5),ncol=5)
print(respc &lt;- restovec(y, censor=matrix(rbinom(20,1,0.9),ncol=5), times=tt))
# if there is no censoring, censor indicator is not printed
response(respc)
# nesting clustered within individuals
nest &lt;- c(1,1,2,2,2)
print(respn &lt;- restovec(y, censor=matrix(rbinom(20,1,0.9),ncol=5),
	times=tt,nest=nest))
response(respn)
times(respn)
nesting(respn)
#
# multivariate response
restovec(y, censor=matrix(rbinom(20,1,0.9),ncol=5),
	units=c("m","days","l","cm","mon"),
	type=c("continuous","duration","continuous","continuous","duration"),
	description=list(y1="First continuous variable",
		y2="First duration variable",y3="Second continuous variable",
		y4="Third continuous variable",y5="Second duration variable"))
restovec(y, censor=matrix(rbinom(20,1,0.9),ncol=5), 
	names=c("a","b","c","d","e"), units=c("m","days","l","cm","mon"),
	type=c("continuous","duration","continuous","continuous","duration"),
	description=list(a="First continuous variable",
		b="First duration variable",c="Second continuous variable",
		d="Third continuous variable",e="Second duration variable"))
</code></pre>

<hr>
<h2 id='rmna'>Create a repeated Object, Removing NAs</h2><span id='topic+rmna'></span>

<h3>Description</h3>

<p><code>rmna</code> forms an object of class, <code>repeated</code>, from a
<code>response</code> object and possibly time-varying or
intra-individual covariate (<code>tvcov</code>), and time-constant or
inter-individual covariate (<code>tccov</code>) objects, removing any
observations where response and covariate values have NAs. Subjects
must be in the same order in all (three) objects to be combined.
</p>
<p>Such objects can be printed and plotted. Methods are available for
extracting the response, the numbers of observations per individual,
the times, the weights, the units of measurement/Jacobian, the nesting
variable, the covariates, and their names: <code><a href="#topic+response">response</a></code>,
<code><a href="#topic+nobs">nobs</a></code>, <code><a href="#topic+times">times</a></code>,
<code><a href="#topic+weights">weights</a></code>, <code><a href="#topic+delta">delta</a></code>,
<code><a href="#topic+nesting">nesting</a></code>, <code><a href="#topic+covariates">covariates</a></code>, and
<code><a href="#topic+names">names</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmna(response, ccov=NULL, tvcov=NULL)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rmna_+3A_response">response</code></td>
<td>
<p>An object of class, <code>response</code> (created by
<code><a href="#topic+restovec">restovec</a></code>), containing the response variable information.</p>
</td></tr>
<tr><td><code id="rmna_+3A_ccov">ccov</code></td>
<td>
<p>An object of class, <code>tccov</code> (created by
<code><a href="#topic+tcctomat">tcctomat</a></code>), containing the time-constant or
inter-individual covariate information.</p>
</td></tr>
<tr><td><code id="rmna_+3A_tvcov">tvcov</code></td>
<td>
<p>An object of class, <code>tvcov</code> (created by
<code><a href="#topic+tvctomat">tvctomat</a></code>), containing the time-varying or
intra-individual covariate information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class, <code>repeated</code>, containing a list of the
response object (<code>z$response</code>, so that, for example, the response vector
is <code>z$response$y</code>; see <code><a href="#topic+restovec">restovec</a></code>), and
possibly the two classes of covariate objects (<code>z$ccov</code> and
<code>z$tvcov</code>; see <code><a href="#topic+tcctomat">tcctomat</a></code> and
<code><a href="#topic+tvctomat">tvctomat</a></code>).
</p>


<h3>Author(s)</h3>

<p>J.K. Lindsey</p>


<h3>See Also</h3>

<p><code><a href="#topic+DataMethods">DataMethods</a></code>, <code><a href="#topic+covariates">covariates</a></code>,
<code><a href="#topic+covind">covind</a></code>, <code><a href="#topic+delta">delta</a></code>,
<code><a href="#topic+dftorep">dftorep</a></code>, <code><a href="#topic+lvna">lvna</a></code>,
<code><a href="#topic+names">names</a></code>, <code><a href="#topic+nesting">nesting</a></code>,
<code><a href="#topic+nobs">nobs</a></code>, <code><a href="#topic+read.list">read.list</a></code>,
<code><a href="#topic+read.surv">read.surv</a></code>, <code><a href="#topic+response">response</a></code>,
<code><a href="#topic+resptype">resptype</a></code>, <code><a href="#topic+restovec">restovec</a></code>,
<code><a href="#topic+tcctomat">tcctomat</a></code>, <code><a href="#topic+times">times</a></code>,
<code><a href="#topic+transform">transform</a></code>, <code><a href="#topic+tvctomat">tvctomat</a></code>,
<code><a href="#topic+units">units</a></code>, <code><a href="#topic+weights">weights</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- matrix(rnorm(20),ncol=5)
tt &lt;- c(1,3,6,10,15)
print(resp &lt;- restovec(y,times=tt))
x &lt;- c(0,0,1,1)
tcc &lt;- tcctomat(x)
z &lt;- matrix(rpois(20,5),ncol=5)
tvc &lt;- tvctomat(z)
print(reps &lt;- rmna(resp, tvcov=tvc, ccov=tcc))
response(reps)
response(reps, nind=2:3)
times(reps)
nobs(reps)
weights(reps)
covariates(reps)
covariates(reps,names="x")
covariates(reps,names="z")
names(reps)
nesting(reps)
# because individuals are the only nesting, this is the same as
covind(reps)
#
# use in glm
rm(y,x,z)
glm(y~x+z,data=as.data.frame(reps))
#
# binomial
y &lt;- matrix(rpois(20,5),ncol=5)
print(respb &lt;- restovec(y,totals=y+matrix(rpois(20,5),ncol=5),times=tt))
print(repsb &lt;- rmna(respb, tvcov=tvc, ccov=tcc))
response(repsb)
#
# censored data
y &lt;- matrix(rweibull(20,2,5),ncol=5)
print(respc &lt;- restovec(y,censor=matrix(rbinom(20,1,0.9),ncol=5),times=tt))
print(repsc &lt;- rmna(respc, tvcov=tvc, ccov=tcc))
# if there is no censoring, censor indicator is not printed
response(repsc)
#
# nesting clustered within individuals
nest &lt;- c(1,1,2,2,2)
print(respn &lt;- restovec(y,censor=matrix(rbinom(20,1,0.9),ncol=5),
	times=tt,nest=nest))
print(repsn &lt;- rmna(respn, tvcov=tvc, ccov=tcc))
response(respn)
times(respn)
nesting(respn)
</code></pre>

<hr>
<h2 id='rmutil'>Utilities for Repeated Measurements Library</h2><span id='topic+rmutil'></span>

<h3>Description</h3>

<p><code><a href="#topic++25+5E+25">%^%</a></code>			  Power of a Matrix
</p>
<p><code><a href="#topic+covariates">covariates</a></code>		Extract Covariate Matrices from a Data Object
</p>
<p><code><a href="#topic+covind">covind</a></code>			Nesting Indicator for Observations within Individuals in a Data Object
</p>
<p><code><a href="#topic+dbetabinom">dbetabinom</a></code>		Density of Beta Binomial Distribution
</p>
<p><code><a href="#topic+dboxcox">dboxcox</a></code>			Density of Box-Cox Distribution
</p>
<p><code><a href="#topic+dburr">dburr</a></code>			Density of Burr Distribution
</p>
<p><code><a href="#topic+ddoublebinom">ddoublebinom</a></code>		Density of Double Binomial Distribution
</p>
<p><code><a href="#topic+ddoublepois">ddoublepois</a></code>		Density of Double Poisson Distribution
</p>
<p><code><a href="#topic+delta">delta</a></code>			Extract Units of Measurement Vector from a Data Object
</p>
<p><code><a href="#topic+dftorep">dftorep</a></code>			Transform a Dataframe to a repeated Object
</p>
<p><code><a href="#topic+dgammacount">dgammacount</a></code>		Density of Gamma Count Distribution
</p>
<p><code><a href="#topic+dgextval">dgextval</a></code>			Density of Generalized Extreme Value Distribution
</p>
<p><code><a href="#topic+dggamma">dggamma</a></code>			Density of Generalized Gamma Distribution
</p>
<p><code><a href="#topic+dginvgauss">dginvgauss</a></code>		Density of Generalized Inverse Gaussian Distribution
</p>
<p><code><a href="#topic+dglogis">dglogis</a></code>			Density of Generalized Logistic Distribution
</p>
<p><code><a href="#topic+dgweibull">dgweibull</a></code>			Density of Generalized Weibull Distribution
</p>
<p><code><a href="#topic+dhjorth">dhjorth</a></code>			Density of Hjorth Distribution
</p>
<p><code><a href="#topic+dinvgauss">dinvgauss</a></code>			Density of Inverse Gaussian Distribution
</p>
<p><code><a href="#topic+dlaplace">dlaplace</a></code>			Density of Laplace Distribution
</p>
<p><code><a href="#topic+dlevy">dlevy</a></code>			Density of Levy Distribution
</p>
<p><code><a href="#topic+dmultbinom">dmultbinom</a></code>		Density of Multiplicative Binomial Distribution
</p>
<p><code><a href="#topic+dmultpois">dmultpois</a></code>			Density of Multiplicative Poisson Distribution
</p>
<p><code><a href="#topic+dpareto">dpareto</a></code>			Density of Pareto Distribution
</p>
<p><code><a href="#topic+dpowexp">dpowexp</a></code>			Density of Power Exponential Distribution
</p>
<p><code><a href="#topic+dpvfpois">dpvfpois</a></code>			Density of Power Variance Function Poisson Distribution
</p>
<p><code><a href="#topic+dsimplex">dsimplex</a></code>			Density of Simplex Distribution
</p>
<p><code><a href="#topic+dskewlaplace">dskewlaplace</a></code>		Density of Skew Laplace Distribution
</p>
<p><code><a href="#topic+finterp">finterp</a></code>			Formula Interpreter
</p>
<p><code><a href="#topic+fmobj">fmobj</a></code>			Object Finder in Formulae
</p>
<p><code><a href="#topic+fnenvir">fnenvir</a></code>			Check Covariates and Parameters of a Function
</p>
<p><code><a href="#topic+formula">formula</a></code>			Extract Formula Used to Create Time-constant Covariate Matrix in a Data Object
</p>
<p><code><a href="#topic+gauss.hermite">gauss.hermite</a></code>		Calculate Gauss-Hermite Quadrature Points
</p>
<p><code><a href="#topic+gettvc">gettvc</a></code>			Create Time-varying Covariates
</p>
<p><code><a href="#topic+int">int</a></code>			Vectorized One-dimensional Numerical Integration
</p>
<p><code><a href="#topic+int2">int2</a></code>			Vectorized Two-dimensional Numerical Integration
</p>
<p><code><a href="#topic+iprofile">iprofile</a></code>			Produce Individual Time Profiles for Plotting
</p>
<p><code><a href="#topic+lin.diff.eqn">lin.diff.eqn</a></code>		Solution of Autonomous Linear Differential Equations
</p>
<p><code><a href="#topic+lvna">lvna</a></code>			Create a Repeated Object Leaving NAs
</p>
<p><code><a href="#topic+mexp">mexp</a></code>			Matrix Exponentiation
</p>
<p><code><a href="#topic+mprofile">mprofile</a></code>			Produce Marginal Time Profiles for Plotting
</p>
<p><code><a href="#topic+names">names</a></code>			Extract Names of Covariates from a Data Object
</p>
<p><code><a href="#topic+nesting">nesting</a></code>			Extract Nesting Indicators from a Data Object
</p>
<p><code><a href="#topic+nobs">nobs</a></code>			Extract Number of Observations per Individual from a Data Object
</p>
<p><code><a href="#topic+pbetabinom">pbetabinom</a></code>		Distribution Function of Beta Binomial Distribution
</p>
<p><code><a href="#topic+pboxcox">pboxcox</a></code>			Distribution Function of Box-Cox Distribution
</p>
<p><code><a href="#topic+pburr">pburr</a></code>			Distribution Function of Burr Distribution
</p>
<p><code><a href="#topic+pdoublebinom">pdoublebinom</a></code>		Distribution Function of Double Binomial Distribution
</p>
<p><code><a href="#topic+pdoublepois">pdoublepois</a></code>		Distribution Function of Double Poisson Distribution
</p>
<p><code><a href="#topic+pgammacount">pgammacount</a></code>		Distribution Function of Gamma Count Distribution
</p>
<p><code><a href="#topic+pgextval">pgextval</a></code>			Distribution Function of Generalized Extreme Value Distribution
</p>
<p><code><a href="#topic+pggamma">pggamma</a></code>			Distribution Function of Generalized Gamma Distribution
</p>
<p><code><a href="#topic+pginvgauss">pginvgauss</a></code>		Distribution Function of Generalized Inverse Gaussian Distribution
</p>
<p><code><a href="#topic+pglogis">pglogis</a></code>			Distribution Function of Generalized Logistic Distribution
</p>
<p><code><a href="#topic+pgweibull">pgweibull</a></code>			Distribution Function of Generalized Weibull Distribution
</p>
<p><code><a href="#topic+phjorth">phjorth</a></code>			Distribution Function of Hjorth Distribution
</p>
<p><code><a href="#topic+pinvgauss">pinvgauss</a></code>			Distribution Function of Inverse Gaussian Distribution
</p>
<p><code><a href="#topic+pkpd">pkpd</a></code>			Pharmacokinetic Model Functions
</p>
<p><code><a href="#topic+plaplace">plaplace</a></code>			Distribution Function of Laplace Distribution
</p>
<p><code><a href="#topic+plevy">plevy</a></code>			Distribution Function of Levy Distribution
</p>
<p><code><a href="#topic+plot.residuals">plot.residuals</a></code>		Plot Residuals for Carma
</p>
<p><code><a href="#topic+pmultbinom">pmultbinom</a></code>		Distribution Function of Multiplicative Binomial Distribution
</p>
<p><code><a href="#topic+pmultpois">pmultpois</a></code>			Distribution Function of Multiplicative Poisson Distribution
</p>
<p><code><a href="#topic+ppareto">ppareto</a></code>			Distribution Function of Pareto Distribution
</p>
<p><code><a href="#topic+ppowexp">ppowexp</a></code>			Distribution Function of Power Exponential Distribution
</p>
<p><code><a href="#topic+ppvfpois">ppvfpois</a></code>			Distribution Function of Power Variance Function Poisson Distribution
</p>
<p><code><a href="#topic+psimplex">psimplex</a></code>			Distribution Function of Simplex Distribution
</p>
<p><code><a href="#topic+pskewlaplace">pskewlaplace</a></code>		Distribution Function of Skew Laplace Distribution
</p>
<p><code><a href="#topic+qbetabinom">qbetabinom</a></code>		Quantiles of Beta Binomial Distribution
</p>
<p><code><a href="#topic+qboxcox">qboxcox</a></code>			Quantiles of Box-Cox Distribution
</p>
<p><code><a href="#topic+qburr">qburr</a></code>			Quantiles of Burr Distribution
</p>
<p><code><a href="#topic+qdoublebinom">qdoublebinom</a></code>		Quantiles of Double Binomial Distribution
</p>
<p><code><a href="#topic+qdoublepois">qdoublepois</a></code>		Quantiles of Double Poisson Distribution
</p>
<p><code><a href="#topic+qgammacount">qgammacount</a></code>		Quantiles of Gamma Count Distribution
</p>
<p><code><a href="#topic+qgextval">qgextval</a></code>			Quantiles of Generalized Extreme Value Distribution
</p>
<p><code><a href="#topic+qggamma">qggamma</a></code>			Quantiles of Generalized Gamma Distribution
</p>
<p><code><a href="#topic+qginvgauss">qginvgauss</a></code>		Quantiles of Generalized Inverse Gaussian Distribution
</p>
<p><code><a href="#topic+qglogis">qglogis</a></code>			Quantiles of Generalized Logistic Distribution
</p>
<p><code><a href="#topic+qgweibull">qgweibull</a></code>			Quantiles of Generalized Weibull Distribution
</p>
<p><code><a href="#topic+qhjorth">qhjorth</a></code>			Quantiles of Hjorth Distribution
</p>
<p><code><a href="#topic+qinvgauss">qinvgauss</a></code>			Quantiles of Inverse Gaussian Distribution
</p>
<p><code><a href="#topic+qlaplace">qlaplace</a></code>			Quantiles of Laplace Distribution
</p>
<p><code><a href="#topic+qlevy">qlevy</a></code>			Quantiles of Levy Distribution
</p>
<p><code><a href="#topic+qmultbinom">qmultbinom</a></code>		Quantiles of Multiplicative Binomial Distribution
</p>
<p><code><a href="#topic+qmultpois">qmultpois</a></code>			Quantiles of Multiplicative Poisson Distribution
</p>
<p><code><a href="#topic+qpareto">qpareto</a></code>			Quantiles of Pareto Distribution
</p>
<p><code><a href="#topic+qpowexp">qpowexp</a></code>			Quantiles of Power Exponential Distribution
</p>
<p><code><a href="#topic+qpvfpois">qpvfpois</a></code>			Quantiles of Power Variance Function Poisson Distribution
</p>
<p><code><a href="#topic+qsimplex">qsimplex</a></code>			Quantiles of Simplex Distribution
</p>
<p><code><a href="#topic+qskewlaplace">qskewlaplace</a></code>		Quantiles of Skew Laplace Distribution
</p>
<p><code><a href="#topic+rbetabinom">rbetabinom</a></code>		Random Number Generation for Beta Binomial Distribution
</p>
<p><code><a href="#topic+rboxcox">rboxcox</a></code>			Random Number Generation for Box-Cox Distribution
</p>
<p><code><a href="#topic+rburr">rburr</a></code>			Random Number Generation for Burr Distribution
</p>
<p><code><a href="#topic+rdoublebinom">rdoublebinom</a></code>		Random Number Generation for Double Binomial Distribution
</p>
<p><code><a href="#topic+rdoublepois">rdoublepois</a></code>		Random Number Generation for Double Poisson Distribution
</p>
<p><code><a href="#topic+read.list">read.list</a></code>			Read a List of Matrices of Unbalanced Repeated Measurements from a File
</p>
<p><code><a href="#topic+read.rep">read.rep</a></code>			Read a Rectangular Data Set from a File to Create a repeated Object
</p>
<p><code><a href="#topic+read.surv">read.surv</a></code>			Read a List of Vectors of Event Histories from a File
</p>
<p><code><a href="#topic+response">response</a></code>			Extract Response Vector from a Data Object
</p>
<p><code><a href="#topic+restovec">restovec</a></code>			Create a Response Object
</p>
<p><code><a href="#topic+rgammacount">rgammacount</a></code>		Random Number Generation for Gamma Count Distribution
</p>
<p><code><a href="#topic+rgextval">rgextval</a></code>			Random Number Generation for Generalized Extreme Value Distribution
</p>
<p><code><a href="#topic+rggamma">rggamma</a></code>			Random Number Generation for Generalized Gamma Distribution
</p>
<p><code><a href="#topic+rginvgauss">rginvgauss</a></code>		Random Number Generation for Generalized Inverse Gaussian Distribution
</p>
<p><code><a href="#topic+rglogis">rglogis</a></code>			Random Number Generation for Generalized Logistic Distribution
</p>
<p><code><a href="#topic+rgweibull">rgweibull</a></code>			Random Number Generation for Generalized Weibull Distribution
</p>
<p><code><a href="#topic+rhjorth">rhjorth</a></code>			Random Number Generation for Hjorth Distribution
</p>
<p><code><a href="#topic+rinvgauss">rinvgauss</a></code>			Random Number Generation for Inverse Gaussian Distribution
</p>
<p><code><a href="#topic+rlaplace">rlaplace</a></code>			Random Number Generation for Laplace Distribution
</p>
<p><code><a href="#topic+rlevy">rlevy</a></code>			Random Number Generation for Levy Distribution
</p>
<p><code><a href="#topic+rmna">rmna</a></code>			Create a Repeated Object
</p>
<p><code><a href="#topic+rmultbinom">rmultbinom</a></code>		Random Number Generation for Multiplicative Binomial Distribution
</p>
<p><code><a href="#topic+rmultpois">rmultpois</a></code>			Random Number Generation for Multiplicative Poisson Distribution
</p>
<p><code><a href="#topic+rpareto">rpareto</a></code>			Random Number Generation for Pareto Distribution
</p>
<p><code><a href="#topic+rpowexp">rpowexp</a></code>			Random Number Generation for Power Exponential Distribution
</p>
<p><code><a href="#topic+rpvfpois">rpvfpois</a></code>			Random Number Generation for Power Variance Function Poisson Distribution
</p>
<p><code><a href="#topic+rsimplex">rsimplex</a></code>			Random Number Generation for Simplex Distribution
</p>
<p><code><a href="#topic+rskewlaplace">rskewlaplace</a></code>		Random Number Generation for Skew Laplace Distribution
</p>
<p><code><a href="#topic+runge.kutta">runge.kutta</a></code>		Runge-Kutta Method for Solving Differential Equations
</p>
<p><code><a href="#topic+tcctomat">tcctomat</a></code>			Create a Time-constant Covariate (tccov) Object
</p>
<p><code><a href="#topic+times">times</a></code>			Extract Times Vector from a Data Object
</p>
<p><code><a href="#topic+transform">transform</a></code>			Transform Variables in a Data Object
</p>
<p><code><a href="#topic+tvctomat">tvctomat</a></code>			Create a Time-varying Covariate (tvcov) Object
</p>
<p><code><a href="#topic+wr">wr</a></code>			Find the Response Vector and Design Matrix for a Model Formula
</p>

<hr>
<h2 id='runge.kutta'>Runge-Kutta Method for Solving Differential Equations</h2><span id='topic+runge.kutta'></span>

<h3>Description</h3>

<p><code>runge.kutta</code> numerically solves a differential equation by the
fourth-order Runge-Kutta method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runge.kutta(f, initial, x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="runge.kutta_+3A_f">f</code></td>
<td>
<p>A function <code>dy/dx=func(y,x)</code>.</p>
</td></tr>
<tr><td><code id="runge.kutta_+3A_initial">initial</code></td>
<td>
<p>The initial value of <code>y</code>.</p>
</td></tr>
<tr><td><code id="runge.kutta_+3A_x">x</code></td>
<td>
<p>A vector of values of <code>x</code> for which the values or
<code>y</code> are required.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of values of <code>y</code> as solution of the function <code>f</code>
corresponding to the values in <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>J.K. Lindsey</p>


<h3>Examples</h3>

<pre><code class='language-R'>fn &lt;- function(y,x) (x*y-y^2)/x^2
soln &lt;- runge.kutta(fn,2,seq(1,3,by=1/128))
## exact solution
exact &lt;- seq(1,3,by=1/128)/(0.5+log(seq(1,3,by=1/128)))
rbind(soln, exact)
</code></pre>

<hr>
<h2 id='Simplex'>Simplex Distribution</h2><span id='topic+dsimplex'></span><span id='topic+psimplex'></span><span id='topic+qsimplex'></span><span id='topic+rsimplex'></span>

<h3>Description</h3>

<p>These functions provide information about the simplex distribution
with location parameter equal to <code>m</code> and shape equal to
<code>s</code>: density, cumulative distribution, quantiles, and
random generation.
</p>
<p>The simplex distribution has density
</p>
<p style="text-align: center;"><code class="reqn">
f(y) = \frac{1}{\sqrt(2\pi\sigma(y(1-y))^3)}
     \exp(-((y-\mu)/(\mu(1-\mu)))^2/(2y(1-y)\sigma))</code>
</p>

<p>where <code class="reqn">\mu</code> is the location parameter of the distribution and
<code class="reqn">\sigma</code> is the shape, and <code class="reqn">0&lt;y&lt;1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dsimplex(y, m, s, log=FALSE)
psimplex(q, m, s)
qsimplex(p, m, s)
rsimplex(n, m, s)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Simplex_+3A_y">y</code></td>
<td>
<p>vector of responses.</p>
</td></tr>
<tr><td><code id="Simplex_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Simplex_+3A_p">p</code></td>
<td>
<p>vector of probabilities</p>
</td></tr>
<tr><td><code id="Simplex_+3A_n">n</code></td>
<td>
<p>number of values to generate</p>
</td></tr>
<tr><td><code id="Simplex_+3A_m">m</code></td>
<td>
<p>vector of location parameters.</p>
</td></tr>
<tr><td><code id="Simplex_+3A_s">s</code></td>
<td>
<p>vector of shape parameters.</p>
</td></tr>
<tr><td><code id="Simplex_+3A_log">log</code></td>
<td>
<p>if TRUE, log probabilities are supplied.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J.K. Lindsey</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dbeta">dbeta</a></code> for the beta distribution and
<code><a href="#topic+dtwosidedpower">dtwosidedpower</a></code> for the two-sided power distribution,
other distributions for proportions between zero and one.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dsimplex(0.3, 0.5, 1)
psimplex(0.3, 0.5, 1)
qsimplex(0.1, 0.5, 1)
rsimplex(10, 0.5, 1)
</code></pre>

<hr>
<h2 id='SkewLaplace'>Skew Laplace Distribution</h2><span id='topic+dskewlaplace'></span><span id='topic+pskewlaplace'></span><span id='topic+qskewlaplace'></span><span id='topic+rskewlaplace'></span>

<h3>Description</h3>

<p>These functions provide information about the skew Laplace distribution
with location parameter equal to <code>m</code>, dispersion equal to
<code>s</code>, and skew equal to <code>f</code>: density, cumulative
distribution, quantiles, log hazard, and random generation.
For <code>f=1</code>, this is an ordinary (symmetric) Laplace distribution.
</p>
<p>The skew Laplace distribution has density
</p>
<p style="text-align: center;"><code class="reqn">
f(y) = \frac{\nu\exp(-\nu(y-\mu)/\sigma)}{(1+\nu^2)\sigma}</code>
</p>

<p>if  <code class="reqn">y\ge\mu</code> and else
</p>
<p style="text-align: center;"><code class="reqn">
f(y) = \frac{\nu\exp((y-\mu)/(\nu\sigma))}{(1+\nu^2)\sigma}</code>
</p>

<p>where <code class="reqn">\mu</code> is the location parameter of the distribution,
<code class="reqn">\sigma</code> is the dispersion, and <code class="reqn">\nu</code> is the skew.
</p>
<p>The mean is given by <code class="reqn">\mu+\frac{\sigma(1-\nu^2)}{\sqrt{2}\nu}</code>
and the variance by  <code class="reqn">\frac{\sigma^2(1+\nu^4)}{2\nu^2}</code>.
</p>
<p>Note that this parametrization of the skew (family) parameter is
different than that used for the multivariate skew Laplace
distribution in <code>elliptic</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dskewlaplace(y, m=0, s=1, f=1, log=FALSE)
pskewlaplace(q, m=0, s=1, f=1)
qskewlaplace(p, m=0, s=1, f=1)
rskewlaplace(n, m=0, s=1, f=1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SkewLaplace_+3A_y">y</code></td>
<td>
<p>vector of responses.</p>
</td></tr>
<tr><td><code id="SkewLaplace_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="SkewLaplace_+3A_p">p</code></td>
<td>
<p>vector of probabilities</p>
</td></tr>
<tr><td><code id="SkewLaplace_+3A_n">n</code></td>
<td>
<p>number of values to generate</p>
</td></tr>
<tr><td><code id="SkewLaplace_+3A_m">m</code></td>
<td>
<p>vector of location parameters.</p>
</td></tr>
<tr><td><code id="SkewLaplace_+3A_s">s</code></td>
<td>
<p>vector of dispersion parameters.</p>
</td></tr>
<tr><td><code id="SkewLaplace_+3A_f">f</code></td>
<td>
<p>vector of skew parameters.</p>
</td></tr>
<tr><td><code id="SkewLaplace_+3A_log">log</code></td>
<td>
<p>if TRUE, log probabilities are supplied.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J.K. Lindsey</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dexp">dexp</a></code> for the exponential distribution,
<code><a href="stats.html#topic+dcauchy">dcauchy</a></code> for the Cauchy distribution, and
<code><a href="#topic+dlaplace">dlaplace</a></code> for the Laplace distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dskewlaplace(5, 2, 1, 0.5)
pskewlaplace(5, 2, 1, 0.5)
qskewlaplace(0.95, 2, 1, 0.5)
rskewlaplace(10, 2, 1, 0.5)
</code></pre>

<hr>
<h2 id='tcctomat'>Create a Time-constant, Inter-individual Covariate (tccov) Object</h2><span id='topic+tcctomat'></span>

<h3>Description</h3>

<p><code>tcctomat</code> creates an object of class, <code>tccov</code>, from a
vector or matrix containing time-constant or inter-individual baseline
covariates or a model formula. It can also combine two such objects.
</p>
<p>Such objects can be printed. Methods are available for extracting the
covariates, their names, and the formula: <code><a href="#topic+covariates">covariates</a></code>,
<code><a href="#topic+names">names</a></code>, and <code><a href="#topic+formula">formula</a></code>. The method,
<code><a href="#topic+transform">transform</a></code>, can transform variables in place or by adding
new variables to the object.
</p>
<p>To obtain the indexing to expand time-constant or inter-individual
covariates to the size of a repeated measurements response, use
<code><a href="#topic+covind">covind</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcctomat(ccov, names=NULL, units=NULL, oldccov=NULL, dataframe=TRUE,
	description=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tcctomat_+3A_ccov">ccov</code></td>
<td>
<p>A vector, matrix, or dataframe containing time-constant or
inter-individual baseline covariates with one row per individual, a
model formula using vectors of the same size, or an object of class,
<code>tccov</code>. In the first two cases, the variables may be factors; if
<code>dataframe=FALSE</code>, these are transformed to indicator variables.</p>
</td></tr>
<tr><td><code id="tcctomat_+3A_units">units</code></td>
<td>
<p>Optional character vector specifying units of
measurements of covariates.</p>
</td></tr>
<tr><td><code id="tcctomat_+3A_names">names</code></td>
<td>
<p>The names of the covariates (if the matrix does not have
column names).</p>
</td></tr>
<tr><td><code id="tcctomat_+3A_oldccov">oldccov</code></td>
<td>
<p>An object of class, <code>tccov</code>, to which <code>ccov</code>
is to be added.</p>
</td></tr>
<tr><td><code id="tcctomat_+3A_dataframe">dataframe</code></td>
<td>
<p>If TRUE and factor variables are present, the
covariates are stored as a dataframe; if FALSE, they are expanded to
indicator variables. If no factor variables are present, covariates
are always stored as a matrix.</p>
</td></tr>
<tr><td><code id="tcctomat_+3A_description">description</code></td>
<td>
<p>An optional named list of character vectors with
names of some or all covariates containing their descriptions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class, <code>tccov</code>, containing one matrix or
dataframe for the covariates (<code>z$ccov</code>) with one row per
individual and possibly the model formula (<code>z$linear</code>).
</p>


<h3>Author(s)</h3>

<p>J.K. Lindsey</p>


<h3>See Also</h3>

<p><code><a href="#topic+DataMethods">DataMethods</a></code>, <code><a href="#topic+covariates">covariates</a></code>,
<code><a href="#topic+description">description</a></code>, <code><a href="#topic+formula">formula</a></code>,
<code><a href="#topic+lvna">lvna</a></code>, <code><a href="#topic+names">names</a></code>,
<code><a href="#topic+restovec">restovec</a></code>, <code><a href="#topic+rmna">rmna</a></code>,
<code><a href="#topic+transform">transform</a></code>, <code><a href="#topic+tvctomat">tvctomat</a></code>,
<code><a href="#topic+units">units</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- gl(4,1)
print(tcc1 &lt;- tcctomat(~x1))
covariates(tcc1)
covariates(tcc1, name="x12")
tcctomat(x1)
tcctomat(x1, dataframe=FALSE)
x2 &lt;- c(0,0,1,1)
print(tcc2 &lt;- tcctomat(~x2, units="days"))
covariates(tcc2)
print(tcc3 &lt;- tcctomat(~x1+x2))
covariates(tcc3)
covariates(tcc3, names=c("x12","x2"))
formula(tcc3)
names(tcc3)
print(tcc4 &lt;- tcctomat(data.frame(x1,x2), units=c(NA,"days")))
covariates(tcc4)
print(tcc5 &lt;- tcctomat(data.frame(x1,x2), dataframe=FALSE, units=c(NA,"days")))
covariates(tcc5)
</code></pre>

<hr>
<h2 id='tvctomat'>Create a Time-varying, Intra-individual Covariate (tvcov) Object</h2><span id='topic+tvctomat'></span>

<h3>Description</h3>

<p><code>tvctovmat</code> creates an object of class, <code>tvcov</code>, from a list of
matrices with time-varying or intra-individual covariates for each
individual or one matrix or dataframe of such covariate values. It can
also combine two such objects or add interactions among covariates.
</p>
<p>Such objects can be printed. Methods are available for extracting the
covariates and their names: <code><a href="#topic+covariates">covariates</a></code> and
<code><a href="#topic+names">names</a></code>. The method,
<code><a href="#topic+transform">transform</a></code>, can transform variables in place or
by adding new variables to the object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tvctomat(tvcov, names=NULL, units=NULL, interaction=NULL, ccov=NULL,
	oldtvcov=NULL, dataframe=TRUE, description=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tvctomat_+3A_tvcov">tvcov</code></td>
<td>
<p>Either (1) if unbalanced, a list of matrices or
dataframes with time-varying or intra-individual covariate values for
each individual (one column per variable), (2) if balanced, one matrix
or dataframe of such covariate values (when there is only one such
covariate) with dimensions: number of individuals by number of
observations/individual, or (3) an object of class, <code>tvcov</code>.
In the first two cases, the variables may be factors; if
<code>dataframe=FALSE</code>, these are transformed to indicator variables.</p>
</td></tr>
<tr><td><code id="tvctomat_+3A_names">names</code></td>
<td>
<p>The names of the time-varying or intra-individual
covariates in <code>tvcov</code> (if the matrices do not have column names)
or the names of the time-constant covariates for which interactions
are to be created.</p>
</td></tr>
<tr><td><code id="tvctomat_+3A_units">units</code></td>
<td>
<p>Optional character vector specifying units of
measurements of covariates.</p>
</td></tr>
<tr><td><code id="tvctomat_+3A_interaction">interaction</code></td>
<td>
<p>A pair of index numbers or names of variables in
<code>tvcov</code>, with that class, for which an interaction is to be added
or, if <code>ccov</code> is provided, a set of such names of time-varying or
intra-individual covariates for creating interactions with the
time-constant covariates.</p>
</td></tr>
<tr><td><code id="tvctomat_+3A_ccov">ccov</code></td>
<td>
<p>Time-constant or inter-individual covariates for which an
interaction is to be introduced with time-varying or intra-individual
covariates in <code>tvcov</code>.</p>
</td></tr>
<tr><td><code id="tvctomat_+3A_oldtvcov">oldtvcov</code></td>
<td>
<p>An object of class, <code>tvcov</code>, to which
<code>tvcov</code> is to be added.</p>
</td></tr>
<tr><td><code id="tvctomat_+3A_dataframe">dataframe</code></td>
<td>
<p>If TRUE and factor variables are present, the
covariates are stored as a dataframe; if FALSE, they are expanded to
indicator variables. If no factor variables are present, covariates
are always stored as a matrix.</p>
</td></tr>
<tr><td><code id="tvctomat_+3A_description">description</code></td>
<td>
<p>An optional named list of character vectors with
names of some or all covariates containing their descriptions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class, <code>tvcov</code>, containing a matrix or
dataframe for the covariates (<code>z$tvcov</code>) with one row per
response per individual and a vector giving the number of observations
per individual (<code>z$nobs</code>).
</p>


<h3>Author(s)</h3>

<p>J.K. Lindsey</p>


<h3>See Also</h3>

<p><code><a href="#topic+DataMethods">DataMethods</a></code>, <code><a href="#topic+covariates">covariates</a></code>,
<code><a href="#topic+description">description</a></code>, <code><a href="#topic+formula">formula</a></code>,
<code><a href="#topic+gettvc">gettvc</a></code>, <code><a href="#topic+lvna">lvna</a></code>,
<code><a href="#topic+names">names</a></code>, <code><a href="#topic+restovec">restovec</a></code>,
<code><a href="#topic+rmna">rmna</a></code>, <code><a href="#topic+tcctomat">tcctomat</a></code>,
<code><a href="#topic+transform">transform</a></code>, <code><a href="#topic+units">units</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z &lt;- matrix(rpois(20,5),ncol=5)
print(tvc &lt;- tvctomat(z, units="days"))
covariates(tvc)
names(tvc)
v &lt;- data.frame(matrix(rep(c("a","b","c","d","e"),4),ncol=5),stringsAsFactors=TRUE)
print(tvc2 &lt;- tvctomat(v, oldtvc=tvc, units=NA))
covariates(tvc2)
print(tvc3 &lt;- tvctomat(v, oldtvc=tvc, dataframe=FALSE, units=NA))
covariates(tvc3)
print(tvc4 &lt;- tvctomat(tvc2, interaction=c("z","v")))
covariates(tvc4)
x1 &lt;- 1:4
x2 &lt;- gl(4,1)
xx &lt;- tcctomat(data.frame(x1,x2), dataframe=FALSE)
tvctomat(tvc3, interaction="z", ccov=xx)
tvctomat(tvc3, interaction="z", ccov=xx, names="x1")
tvctomat(tvc3, interaction="z", ccov=xx, names=c("x22","x23","x24"))
xx &lt;- tcctomat(data.frame(x1,x2), dataframe=TRUE)
tvctomat(tvc2, interaction="z", ccov=xx)
tvctomat(tvc2, interaction="z", ccov=xx, names="x1")
tvctomat(tvc2, interaction="z", ccov=xx, names="x2")
</code></pre>

<hr>
<h2 id='Two-Sided+20Power'>Two-Sided Power Distribution</h2><span id='topic+dtwosidedpower'></span><span id='topic+ptwosidedpower'></span><span id='topic+qtwosidedpower'></span><span id='topic+rtwosidedpower'></span>

<h3>Description</h3>

<p>These functions provide information about the two-sided power distribution
with location parameter equal to <code>m</code> and shape equal to
<code>s</code>: density, cumulative distribution, quantiles, and
random generation.
</p>
<p>The two-sided power distribution has density
</p>
<p style="text-align: center;"><code class="reqn">
f(y) = s(\frac{y}{m})^{s-1}, y&lt;=m</code>
</p>

<p style="text-align: center;"><code class="reqn">
f(y) =s(\frac{1-y}{1-m})^{s-1}, y&gt;=m</code>
</p>

<p>where <code class="reqn">\mu</code> is the location parameter of the distribution and
<code class="reqn">\sigma</code> is the shape, and <code class="reqn">0&lt;y&lt;1</code>.
</p>
<p>For <code class="reqn">\sigma=1</code>, this is the uniform distribution and for
<code class="reqn">\sigma=2</code>, it is the triangular distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtwosidedpower(y, m, s=2, log=FALSE)
ptwosidedpower(q, m, s=2)
qtwosidedpower(p, m, s=2)
rtwosidedpower(n, m, s=2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Two-Sided+2B20Power_+3A_y">y</code></td>
<td>
<p>vector of responses.</p>
</td></tr>
<tr><td><code id="Two-Sided+2B20Power_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Two-Sided+2B20Power_+3A_p">p</code></td>
<td>
<p>vector of probabilities</p>
</td></tr>
<tr><td><code id="Two-Sided+2B20Power_+3A_n">n</code></td>
<td>
<p>number of values to generate</p>
</td></tr>
<tr><td><code id="Two-Sided+2B20Power_+3A_m">m</code></td>
<td>
<p>vector of location parameters.</p>
</td></tr>
<tr><td><code id="Two-Sided+2B20Power_+3A_s">s</code></td>
<td>
<p>vector of shape parameters.</p>
</td></tr>
<tr><td><code id="Two-Sided+2B20Power_+3A_log">log</code></td>
<td>
<p>if TRUE, log probabilities are supplied.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J.K. Lindsey</p>


<h3>References</h3>

<p>van Dorp, J.R. and Kotz, S. (2002) A novel extension of the triangular
distribution and its parameter estimation. The Statistician 51, 63-79.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dbeta">dbeta</a></code> for the beta distribution and
<code><a href="#topic+dsimplex">dsimplex</a></code> for the simplex distribution, other
distributions for proportions between zero and one.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dtwosidedpower(0.3, 0.5, 3)
ptwosidedpower(0.3, 0.5, 3)
qtwosidedpower(0.1, 0.5, 3)
rtwosidedpower(10, 0.5, 3)
</code></pre>

<hr>
<h2 id='wr'>Find the Response Vector and Design Matrix for a W&amp;R Model Formula</h2><span id='topic+wr'></span>

<h3>Description</h3>

<p><code>wr</code> gives the response vector and design matrix for a formula in
Wilkinson and Rogers notation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wr(formula, data=NULL, expand=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wr_+3A_formula">formula</code></td>
<td>
<p>A model formula.</p>
</td></tr>
<tr><td><code id="wr_+3A_data">data</code></td>
<td>
<p>A data object or environment.</p>
</td></tr>
<tr><td><code id="wr_+3A_expand">expand</code></td>
<td>
<p>If FALSE, the covariates are read from the <code>tccov</code>
object without expanding to the length of the response variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>wr</code> returns a list containing the response vector
(<code>z$response</code>), if included in the formula, and the design matrix
(<code>z$design</code>) from the data object or environment supplied or from
the global environment for the formula supplied.
</p>


<h3>Author(s)</h3>

<p>J.K. Lindsey</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- rnorm(20)
x &lt;- gl(4,5)
z &lt;- rpois(20,2)
wr(y~x+z)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
