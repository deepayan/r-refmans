<!DOCTYPE html><html lang="en"><head><title>Help for package slm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {slm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#slm-package'><p>slm: A package for stationary linear models</p></a></li>
<li><a href='#confint.slm'><p>Confidence intervals for the Model Parameters</p></a></li>
<li><a href='#cov_AR'><p>Covariance estimation by AR fitting</p></a></li>
<li><a href='#cov_efromovich'><p>Spectral density estimation: Efromovich method</p></a></li>
<li><a href='#cov_kernel'><p>Kernel estimation: bootstrap method</p></a></li>
<li><a href='#cov_matrix_estimator'><p>Covariance matrix estimator for slm object</p></a></li>
<li><a href='#cov_method'><p>Methods to estimate the autocovariances of a process</p></a></li>
<li><a href='#cov_select'><p>Covariances Selection</p></a></li>
<li><a href='#cov_spectralproj'><p>Data-driven spectral density estimation</p></a></li>
<li><a href='#generative_model'><p>Some linear model</p></a></li>
<li><a href='#generative_process'><p>Some stationary processes</p></a></li>
<li><a href='#plot.slm'><p>Plot.slm</p></a></li>
<li><a href='#predict.slm'><p>Predict for slm object</p></a></li>
<li><a href='#Rboot'><p>Risk estimation for a tapered covariance matrix estimator via bootstrap method</p></a></li>
<li><a href='#rectangle'><p>Rectangular kernel</p></a></li>
<li><a href='#shan'><p>PM2.5 Data of Shanghai</p></a></li>
<li><a href='#slm'><p>Fitting Stationary Linear Models</p></a></li>
<li><a href='#slm-class'><p>slm class</p></a></li>
<li><a href='#summary.slm'><p>Summarizing Stationary Linear Model Fits</p></a></li>
<li><a href='#trapeze'><p>Trapeze kernel</p></a></li>
<li><a href='#triangle'><p>Kernel triangle</p></a></li>
<li><a href='#vcov.slm'><p>Calculate Variance-Covariance Matrix for a Fitted Model Object of class slm</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Stationary Linear Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.0</td>
</tr>
<tr>
<td>Author:</td>
<td>Emmanuel Caron, Jérôme Dedecker, Bertrand Michel</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Emmanuel Caron &lt;emmanuelcaron3@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides statistical procedures for linear regression in the general context where the errors are assumed to be correlated. Different ways to estimate the asymptotic covariance matrix of the least squares estimators are available. Starting from this estimation of the covariance matrix, the confidence intervals and the usual tests on the parameters are modified. The functions of this package are very similar to those of 'lm': it contains methods such as summary(), plot(), confint() and predict(). The 'slm' package is described in the paper by E. Caron, J. Dedecker and B. Michel (2019), "Linear regression with stationary errors: the R package slm", arXiv preprint &lt;<a href="https://doi.org/10.48550/arXiv.1906.06583">doi:10.48550/arXiv.1906.06583</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Collate:</td>
<td>'slm-main.R' 'slm.R' 'generative.R' 'auxiliary-fun.R'
'slm-method.R' 'data.R'</td>
</tr>
<tr>
<td>Imports:</td>
<td>ltsa, methods, stats, capushe, sandwich, expm</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-08-31 11:46:03 UTC; emmanuel</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-08-31 12:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='slm-package'>slm: A package for stationary linear models</h2><span id='topic+slm-package'></span>

<h3>Description</h3>

<p>The <code>slm</code> package enables to fit linear models on datasets considering the dependence between the observations.
Most of the functions are based on the functions and methods of <code>lm</code>, with the same arguments and the same format for the outputs.
</p>


<h3><code>slm</code> function, in &quot;slm-main.R&quot;</h3>

<p>The <code>slm</code> function is the main function of this package. Its architecture is the same as the <code>lm</code> function
but it takes into account the possible correlation between the observations. To estimate the asymptotic covariance matrix of
the least squares estimator, several approaches are available: &quot;fitAR&quot; calls the
<code>cov_AR</code> function, &quot;spectralproj&quot; the <code>cov_spectralproj</code> function, &quot;kernel&quot; the <code>cov_kernel</code> function,
&quot;efromovich&quot; the <code>cov_efromovich</code> function and &quot;select&quot; the <code>cov_select</code> function. The &quot;hac&quot; method uses the <code>sandwich</code> package,
and more precisely, the method described by Andrews (1991) and Zeileis (2004).
</p>


<h3>Methods for <code>slm</code>, in &quot;slm-method.R&quot;</h3>

<p>The <code>slm</code> function has several associated methods, which are the same as for the <code>lm</code> function.
The available methods are: <code>summary</code>, <code>confint</code>, <code>predict</code>, <code>plot</code> and <code>vcov</code>.
</p>


<h3>Others functions, in &quot;auxiliary-fun.R&quot;</h3>

<p>The package has some auxiliary functions, in particular some predefined kernels for the kernel method of <code>slm</code> function: the
trapeze kernel, the triangle kernel and the rectangular kernel. The user can also define his own kernel and put it in the argument
<code>kernel_fonc</code> in the <code>slm</code> function.
</p>


<h3>Generative functions, in &quot;generative.R&quot;</h3>

<p>The <code>generative_process</code> function generates some stationary processes.
The <code>generative_model</code> function generates some designs.
</p>


<h3>Data</h3>

<p>The package contains a dataset &quot;shan&quot;. This dataset comes from a study about fine particle pollution in the city of Shanghai. The data are available on the
following website <a href="https://archive.ics.uci.edu/ml/datasets/PM2.5+Data+of+Five+Chinese+Cities#">https://archive.ics.uci.edu/ml/datasets/PM2.5+Data+of+Five+Chinese+Cities#</a>.
</p>


<h3>References</h3>

<p>D. Andrews (1991). Heteroskedasticity and autocorrelation consistent covariant matrix estimation. <em>Econometrica, 59(3), 817-858</em>.
</p>
<p>E. Caron, J. Dedecker and B. Michel (2019). Linear regression with stationary errors: the R package slm. <em>arXiv preprint arXiv:1906.06583</em>.
<a href="https://arxiv.org/abs/1906.06583">https://arxiv.org/abs/1906.06583</a>.
</p>
<p>A. Zeileis (2004). Econometric computing with HC and HAC covariance matrix estimators.
</p>

<hr>
<h2 id='confint.slm'>Confidence intervals for the Model Parameters</h2><span id='topic+confint.slm'></span>

<h3>Description</h3>

<p>Computes confidence intervals for the model parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'slm'
confint(object, parm = NULL, level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="confint.slm_+3A_object">object</code></td>
<td>
<p>a fitted model object of class <code>slm</code>.</p>
</td></tr>
<tr><td><code id="confint.slm_+3A_parm">parm</code></td>
<td>
<p>a vector of integer. Specifies the coordinates of the vector of parameters for which a confidence
interval will be given. If missing, all parameters are considered.</p>
</td></tr>
<tr><td><code id="confint.slm_+3A_level">level</code></td>
<td>
<p>a number between 0 and 1; the confidence level required.</p>
</td></tr>
<tr><td><code id="confint.slm_+3A_...">...</code></td>
<td>
<p>additional argument(s) for methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns the confidence intervals for the parameters of the model.
</p>


<h3>References</h3>

<p>E. Caron, J. Dedecker and B. Michel (2019). Linear regression with stationary errors: the R package slm. <em>arXiv preprint arXiv:1906.06583</em>.
<a href="https://arxiv.org/abs/1906.06583">https://arxiv.org/abs/1906.06583</a>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+confint.lm">confint.lm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("shan")
reg1 = slm(shan$PM_Xuhui ~ . , data = shan, method_cov_st = "fitAR", model_selec = -1)
confint(reg1, level = 0.8)

data("co2")
y = as.vector(co2)
x = as.vector(time(co2)) - 1958
reg2 = slm(y ~ x + I(x^2) + I(x^3) + sin(2*pi*x) + cos(2*pi*x) + sin(4*pi*x) +
 cos(4*pi*x) + sin(6*pi*x) + cos(6*pi*x) + sin(8*pi*x) + cos(8*pi*x),
 method_cov_st = "fitAR", model_selec = -1, plot = TRUE)
confint(reg2, level = 0.9)
</code></pre>

<hr>
<h2 id='cov_AR'>Covariance estimation by AR fitting</h2><span id='topic+cov_AR'></span>

<h3>Description</h3>

<p>Fit an autoregressive model to the process and compute the theoretical autocovariances of the fitted AR process.
By default, the order is chosen by using the AIC criterion (<code>model_selec = -1</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov_AR(epsilon, model_selec = -1, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cov_AR_+3A_epsilon">epsilon</code></td>
<td>
<p>numeric vector. An univariate process.</p>
</td></tr>
<tr><td><code id="cov_AR_+3A_model_selec">model_selec</code></td>
<td>
<p>integer or <code>-1</code>. The order of the method, that is the order of the AR process to be fitted on the residuals.
If <code>model_selec = -1</code>, it is chosen automatically by using the AIC criterion.</p>
</td></tr>
<tr><td><code id="cov_AR_+3A_plot">plot</code></td>
<td>
<p>logical. By default, <code>plot = FALSE</code>. If <code>plot = TRUE</code>, then the ACF and the PACF of the vector <code>epsilon</code> are plotted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns the vector of the theoretical autocovariances of the AR process fitted on the process <code>epsilon</code>.
</p>
<table role = "presentation">
<tr><td><code>model_selec</code></td>
<td>
<p>the order selected.</p>
</td></tr>
<tr><td><code>cov_st</code></td>
<td>
<p>the vector of theoretical autocovariances of the fitted AR process.</p>
</td></tr>
</table>


<h3>References</h3>

<p>P.J. Brockwell and R.A. Davis (1991). Time Series: Theory and Methods. <em>Springer Science &amp; Business Media</em>.
</p>
<p>E. Caron, J. Dedecker and B. Michel (2019). Linear regression with stationary errors: the R package slm. <em>arXiv preprint arXiv:1906.06583</em>.
<a href="https://arxiv.org/abs/1906.06583">https://arxiv.org/abs/1906.06583</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = arima.sim(list(ar=c(0.4,0.2)),1000)
cov_AR(x, model_selec = 2, plot = TRUE)
</code></pre>

<hr>
<h2 id='cov_efromovich'>Spectral density estimation: Efromovich method</h2><span id='topic+cov_efromovich'></span>

<h3>Description</h3>

<p>This method estimates the spectral density and the autocovariances of the error process via a lag-window
estimator based on the rectangular kernel (see P.J. Brockwell and R.A. Davis (1991). Time Series: Theory and Methods.
<em>Springer Science &amp; Business Media</em>, page 330). The lag is computed according to Efromovich's algorithm (Efromovich (1998)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov_efromovich(epsilon, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cov_efromovich_+3A_epsilon">epsilon</code></td>
<td>
<p>numeric vector. An univariate process.</p>
</td></tr>
<tr><td><code id="cov_efromovich_+3A_plot">plot</code></td>
<td>
<p>logical. By default, <code>plot = FALSE</code>. If <code>plot = TRUE</code>, the ACF of the process <code>epsilon</code>
is plotted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns the estimated autocovariances of the process, that is the Fourier coefficients
of the spectral density estimates, and the order chosen by the algorithm.
</p>
<table role = "presentation">
<tr><td><code>model_selec</code></td>
<td>
<p>the number of selected autocovariance terms.</p>
</td></tr>
<tr><td><code>cov_st</code></td>
<td>
<p>the estimated autocovariances.</p>
</td></tr>
</table>


<h3>References</h3>

<p>P.J. Brockwell and R.A. Davis (1991). Time Series: Theory and Methods. <em>Springer Science &amp; Business Media</em>.
</p>
<p>E. Caron, J. Dedecker and B. Michel (2019). Linear regression with stationary errors: the R package slm. <em>arXiv preprint arXiv:1906.06583</em>.
<a href="https://arxiv.org/abs/1906.06583">https://arxiv.org/abs/1906.06583</a>.
</p>
<p>S. Efromovich (1998). Data-driven efficient estimation of the spectral density. <em>Journal of the American Statistical Association</em>, 93(442), 762-769.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = arima.sim(list(ar=c(0.4,0.2)),1000)
cov_efromovich(x)
</code></pre>

<hr>
<h2 id='cov_kernel'>Kernel estimation: bootstrap method</h2><span id='topic+cov_kernel'></span>

<h3>Description</h3>

<p>This method estimates the spectral density and the autocovariances of the error process via a lag-window
(or kernel) estimator (see P.J. Brockwell and R.A. Davis (1991). Time Series: Theory and Methods. <em>Springer Science &amp; Business Media</em>,
page 330). The weights are computed according to a kernel <code class="reqn">K</code> and a bandwidth <code class="reqn">h</code> (or a lag),
to be chosen by the user. The lag can be computed automatically by using a bootstrap technique (as in Wu and Pourahmadi (2009)), via the <code><a href="#topic+Rboot">Rboot</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov_kernel(epsilon, model_selec = -1,
 model_max = min(50,length(epsilon)/2), kernel_fonc = triangle,
 block_size = length(epsilon)/2, block_n = 100, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cov_kernel_+3A_epsilon">epsilon</code></td>
<td>
<p>numeric vector. An univariate process.</p>
</td></tr>
<tr><td><code id="cov_kernel_+3A_model_selec">model_selec</code></td>
<td>
<p>integer or <code>-1</code>. The order of the method. If <code>model_selec = -1</code>, the method chooses
the treshold automatically. If <code>model_selec = k</code>, then only <code>k</code> autocovariance terms are kept
and smoothed by the kernel.</p>
</td></tr>
<tr><td><code id="cov_kernel_+3A_model_max">model_max</code></td>
<td>
<p>integer. The maximal order.</p>
</td></tr>
<tr><td><code id="cov_kernel_+3A_kernel_fonc">kernel_fonc</code></td>
<td>
<p>function. Defines the kernel to use in the method. The user can give his own kernel function.</p>
</td></tr>
<tr><td><code id="cov_kernel_+3A_block_size">block_size</code></td>
<td>
<p>integer. If <code>model_selec = -1</code>, it specifies the size of the bootstrap blocks. <code>block_size</code> must be greater than <code>model_max</code>.</p>
</td></tr>
<tr><td><code id="cov_kernel_+3A_block_n">block_n</code></td>
<td>
<p>integer. If <code>model_selec = -1</code>, blocks number to use for the bootstrap.</p>
</td></tr>
<tr><td><code id="cov_kernel_+3A_plot">plot</code></td>
<td>
<p>logical. By default, <code>plot = FALSE</code>. If <code>plot = TRUE</code>, the risk curve is returned and the
ACF of the process.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The method returns the tapered autocovariance vector with <code>model_selec</code> autocovariance terms.
</p>
<table role = "presentation">
<tr><td><code>model_selec</code></td>
<td>
<p>the number of selected autocovariance terms.</p>
</td></tr>
<tr><td><code>cov_st</code></td>
<td>
<p>the estimated autocovariances.</p>
</td></tr>
</table>


<h3>References</h3>

<p>E. Caron, J. Dedecker and B. Michel (2019). Linear regression with stationary errors: the R package slm. <em>arXiv preprint arXiv:1906.06583</em>.
<a href="https://arxiv.org/abs/1906.06583">https://arxiv.org/abs/1906.06583</a>.
</p>
<p>W.B. Wu, M. Pourahmadi (2009). Banding sample autocovariance matrices of stationary processes. <em>Statistica Sinica</em>, pp. 1755–1768.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = arima.sim(list(ar=c(0.7)),1000)
cov_kernel(x, model_selec = -1, block_n = 10, plot = TRUE)
</code></pre>

<hr>
<h2 id='cov_matrix_estimator'>Covariance matrix estimator for slm object</h2><span id='topic+cov_matrix_estimator'></span>

<h3>Description</h3>

<p>This function gives the estimation of the asymptotic covariance matrix of the normalized least squares estimator in the case of the linear regression
model with strictly stationary errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov_matrix_estimator(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cov_matrix_estimator_+3A_object">object</code></td>
<td>
<p>an object of class <code>slm</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes the covariance matrix estimator of the normalized least squares estimator from the vector <code>cov_st</code>
of a <code>slm</code> object. If the user has given the argument <code>Cov_ST</code> in the <code>slm</code> object, then it is used
to compute the final covariance matrix. If the method used is the &quot;hac&quot; method, then the final covariance matrix is computed via
the <code><a href="sandwich.html#topic+kernHAC">kernHAC</a></code> function of the <code>sandwich</code> package, by using the Quadratic Spectral kernel and the bandwidth described in Andrews (1991).
For the methods &quot;efromovich&quot;, &quot;kernel&quot; and &quot;select&quot;, the covariance matrix estimator may not be positive definite. Then we apply the
&quot;Positive definite projection&quot; algorithm, which consists in replacing all eigenvalues lower or equal to zero with the smallest
positive eigenvalue of the covariance matrix.
</p>


<h3>Value</h3>

<p>This function returns the estimation of the asymptotic covariance matrix of the normalized least squares estimator.
</p>


<h3>References</h3>

<p>D. Andrews (1991). Heteroskedasticity and autocorrelation consistent covariant matrix estimation. <em>Econometrica, 59(3), 817-858</em>.
</p>
<p>E. Caron, J. Dedecker and B. Michel (2019). Linear regression with stationary errors: the R package slm. <em>arXiv preprint arXiv:1906.06583</em>.
<a href="https://arxiv.org/abs/1906.06583">https://arxiv.org/abs/1906.06583</a>.
</p>
<p>A. Zeileis (2004). Econometric computing with HC and HAC covariance matrix estimators.
</p>


<h3>See Also</h3>

<p>The R package <code><a href="sandwich.html#topic+sandwich">sandwich</a></code>.
</p>
<p><code><a href="sandwich.html#topic+kernHAC">kernHAC</a></code> for HAC methods.
</p>

<hr>
<h2 id='cov_method'>Methods to estimate the autocovariances of a process</h2><span id='topic+cov_method'></span>

<h3>Description</h3>

<p>This function gives the estimation of the autocovariances of the error process, with the method chosen by the user.
Five methods are available: &quot;fitAR&quot;, &quot;spectralproj&quot;, &quot;efromovich&quot;, &quot;kernel&quot; and &quot;select&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov_method(epsilon, method_cov_st = "fitAR", model_selec = -1,
  model_max = NULL, kernel_fonc = NULL, block_size = NULL,
  block_n = NULL, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cov_method_+3A_epsilon">epsilon</code></td>
<td>
<p>numeric vector. An univariate process.</p>
</td></tr>
<tr><td><code id="cov_method_+3A_method_cov_st">method_cov_st</code></td>
<td>
<p>the method chosen by the user to estimate the autocovariances of the error process. The user
has the choice between the methods &quot;fitAR&quot;, &quot;spectralproj&quot;, &quot;efromovich&quot;, &quot;kernel&quot;, &quot;select&quot; or &quot;hac&quot;. By default, the
&quot;fitAR&quot; method is used.</p>
</td></tr>
<tr><td><code id="cov_method_+3A_model_selec">model_selec</code></td>
<td>
<p>integer or <code>-1</code>. The order of the method. If <code>model_selec = -1</code>, the method works automatically.</p>
</td></tr>
<tr><td><code id="cov_method_+3A_model_max">model_max</code></td>
<td>
<p>integer. Maximal dimension of the method.</p>
</td></tr>
<tr><td><code id="cov_method_+3A_kernel_fonc">kernel_fonc</code></td>
<td>
<p>function. Use this argument if <code>method_cov_st = kernel</code>. Define the kernel to use in the method. The user can give his own kernel function.</p>
</td></tr>
<tr><td><code id="cov_method_+3A_block_size">block_size</code></td>
<td>
<p>integer. Size of the bootstrap blocks if <code>method_cov_st = kernel</code>. <code>block_size</code> must be greater than <code>model_max</code>.</p>
</td></tr>
<tr><td><code id="cov_method_+3A_block_n">block_n</code></td>
<td>
<p>integer. Blocks number to use for the bootstrap if <code>method_cov_st = kernel</code>.</p>
</td></tr>
<tr><td><code id="cov_method_+3A_plot">plot</code></td>
<td>
<p>logical. By default, <code>plot = FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns the autocovariances computed with the chosen method.
</p>


<h3>References</h3>

<p>E. Caron, J. Dedecker and B. Michel (2019). Linear regression with stationary errors: the R package slm. <em>arXiv preprint arXiv:1906.06583</em>.
<a href="https://arxiv.org/abs/1906.06583">https://arxiv.org/abs/1906.06583</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = arima.sim(list(ar=c(0.4,0.2)),1000)
cov_method(x, method_cov_st = "fitAR", model_selec = -1)
</code></pre>

<hr>
<h2 id='cov_select'>Covariances Selection</h2><span id='topic+cov_select'></span>

<h3>Description</h3>

<p>Allows the user to select the lags of the autocovariance terms of the process to be kept.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov_select(epsilon, model_selec, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cov_select_+3A_epsilon">epsilon</code></td>
<td>
<p>numeric vector. An univariate process.</p>
</td></tr>
<tr><td><code id="cov_select_+3A_model_selec">model_selec</code></td>
<td>
<p>a vector with the positive lags of the selected autocovariance terms. The variance (lag = 0) is automatically selected.</p>
</td></tr>
<tr><td><code id="cov_select_+3A_plot">plot</code></td>
<td>
<p>logical. By default, <code>plot = FALSE</code>. If <code>plot = TRUE</code> the ACF of the process is plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the framework of <code>slm</code>, this is a manual method for estimating the covariance matrix of the error process
by only selecting some autocovariance terms from the residual autocovariances.
</p>


<h3>Value</h3>

<p>This function returns the estimated autocovariance terms.
</p>
<table role = "presentation">
<tr><td><code>model_selec</code></td>
<td>
<p>the vector with the positive lag of the selected autocovariance terms.</p>
</td></tr>
<tr><td><code>cov_st</code></td>
<td>
<p>the vector of the selected autocovariances.</p>
</td></tr>
</table>


<h3>References</h3>

<p>E. Caron, J. Dedecker and B. Michel (2019). Linear regression with stationary errors: the R package slm. <em>arXiv preprint arXiv:1906.06583</em>.
<a href="https://arxiv.org/abs/1906.06583">https://arxiv.org/abs/1906.06583</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = arima.sim(list(ar=c(0.2,0.1,0.25)),1000)
cov_select(x, c(1,3,5))
</code></pre>

<hr>
<h2 id='cov_spectralproj'>Data-driven spectral density estimation</h2><span id='topic+cov_spectralproj'></span>

<h3>Description</h3>

<p>Computes a data-driven histogram estimator of the spectral density of a process and compute its Fourier coefficients,
that is the associated autocovariances. For a dimension <code class="reqn">d</code>, the estimator of the spectral density is an histogram on a regular basis of
size <code class="reqn">d</code>. Then we use a penalized criterion in order to choose the dimension which balance the bias and the variance, as proposed in Comte (2001). The penalty
is of the form <code class="reqn">c*d/n</code>, where <code class="reqn">c</code> is the constant and <code class="reqn">n</code> the sample size. The dimension and the constant of the penalty are
chosen with the slope heuristic method, with the dimension jump algorithm (from package &quot;<code><a href="capushe.html#topic+capushe">capushe</a></code>&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov_spectralproj(epsilon, model_selec = -1,
 model_max = min(100,length(epsilon)/2), plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cov_spectralproj_+3A_epsilon">epsilon</code></td>
<td>
<p>numeric vector. An univariate process.</p>
</td></tr>
<tr><td><code id="cov_spectralproj_+3A_model_selec">model_selec</code></td>
<td>
<p>integer. The dimension of the method. If <code>model_selec = -1</code>, the method works automatically and take a dimension between 1 and <code>model_max</code>.</p>
</td></tr>
<tr><td><code id="cov_spectralproj_+3A_model_max">model_max</code></td>
<td>
<p>integer. The maximal dimension. By default, it is equal to the minimum between 100 and the length of the process divided by 2.</p>
</td></tr>
<tr><td><code id="cov_spectralproj_+3A_plot">plot</code></td>
<td>
<p>logical. By default, <code>plot = FALSE</code>. If <code>plot = TRUE</code>, plot the spectral density estimator of the process.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns the estimated autocovariances of the process, that is the Fourier coefficients
of the spectral density estimate, and the dimension chosen by the algorithm.
</p>
<table role = "presentation">
<tr><td><code>model_selec</code></td>
<td>
<p>the dimension selected.</p>
</td></tr>
<tr><td><code>cov_st</code></td>
<td>
<p>the estimated autocovariances.</p>
</td></tr>
</table>


<h3>References</h3>

<p>J.P. Baudry, C. Maugis B. and Michel (2012). Slope heuristics: overview and implementation. <em>Statistics and Computing</em>, 22(2), 455–470.
</p>
<p>E. Caron, J. Dedecker and B. Michel (2019). Linear regression with stationary errors: the R package slm. <em>arXiv preprint arXiv:1906.06583</em>.
<a href="https://arxiv.org/abs/1906.06583">https://arxiv.org/abs/1906.06583</a>.
</p>
<p>F. Comte (2001). Adaptive estimation of the spectrum of a stationary Gaussian sequence. <em>Bernoulli</em>, 7(2), 267-298.
</p>


<h3>See Also</h3>

<p>The R package <code><a href="capushe.html#topic+capushe">capushe</a></code>.
</p>
<p>Slope heuristic algorithm <code><a href="capushe.html#topic+DDSE">DDSE</a></code>.
</p>
<p>Dimension jump algorithm <code><a href="capushe.html#topic+Djump">Djump</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = arima.sim(list(ar=c(0.2), ma=c(0.3,0.05)), n=100)
cov_spectralproj(x, model_selec = -1)
</code></pre>

<hr>
<h2 id='generative_model'>Some linear model</h2><span id='topic+generative_model'></span>

<h3>Description</h3>

<p>This function returns a design for the regression linear model, without the intercept. The user can choose one of the two models:
&quot;mod1&quot; or &quot;mod2&quot;. The first model &quot;mod1&quot; contains just one column, equal to <code class="reqn">i^2 + X_i</code>, <code class="reqn">i=1,...,n</code>, where <code class="reqn">X</code> is an AR(1)
process with <code>phi_1 = 0.5</code>.
</p>
<p>The second model &quot;mod2&quot; contains two columns, the first equal to <code class="reqn">log(i) + sin(i) + X_i</code> and the second equal to <code class="reqn">i</code>, for <code class="reqn">i=1,...,n</code>.
The process <code class="reqn">X</code> is again an AR(1) process with <code>phi_1 = 0.5</code>. More information about &quot;mod2&quot; is available in the paper of
E. Caron, J. Dedecker and B. Michel (2019). Linear regression with stationary errors: the R package slm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generative_model(n, model = "mod1")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generative_model_+3A_n">n</code></td>
<td>
<p>integer. The sample size.</p>
</td></tr>
<tr><td><code id="generative_model_+3A_model">model</code></td>
<td>
<p>a list of character &quot;mod1&quot; or &quot;mod2&quot; to choose the model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a data-frame which contains a simulated random design.
</p>


<h3>References</h3>

<p>E. Caron, J. Dedecker and B. Michel (2019). Linear regression with stationary errors: the R package slm. <em>arXiv preprint arXiv:1906.06583</em>.
<a href="https://arxiv.org/abs/1906.06583">https://arxiv.org/abs/1906.06583</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>generative_model(500,"mod1")
</code></pre>

<hr>
<h2 id='generative_process'>Some stationary processes</h2><span id='topic+generative_process'></span>

<h3>Description</h3>

<p>This is a generative function. The user chooses one of the <code>process</code>: &quot;iid&quot;, &quot;AR1&quot;, &quot;AR12&quot;, &quot;MA12&quot;, &quot;Nonmixing&quot;, &quot;sysdyn&quot;, and it
generates the chosen process. These processes are fully described in the paper of
E. Caron, J. Dedecker and B. Michel (2019). Linear regression with stationary errors: the R package slm. <em>arXiv preprint arXiv:1906.06583</em>.
<a href="https://arxiv.org/abs/1906.06583">https://arxiv.org/abs/1906.06583</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generative_process(n, process = "AR1", phi = "numeric",
  theta = "numeric")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generative_process_+3A_n">n</code></td>
<td>
<p>integer. The sample size.</p>
</td></tr>
<tr><td><code id="generative_process_+3A_process">process</code></td>
<td>
<p>a list of character to choose the process.</p>
</td></tr>
<tr><td><code id="generative_process_+3A_phi">phi</code></td>
<td>
<p>a numeric vector with AR parameters if the process is &quot;AR1&quot; or &quot;AR12&quot;.</p>
</td></tr>
<tr><td><code id="generative_process_+3A_theta">theta</code></td>
<td>
<p>a numeric vector with MA parameters if the process is &quot;MA12&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a vector of observations drawn according to the selected process.
</p>


<h3>References</h3>

<p>E. Caron, J. Dedecker and B. Michel (2019). Linear regression with stationary errors: the R package slm. <em>arXiv preprint arXiv:1906.06583</em>.
<a href="https://arxiv.org/abs/1906.06583">https://arxiv.org/abs/1906.06583</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>generative_process(200,"Nonmixing")
</code></pre>

<hr>
<h2 id='plot.slm'>Plot.slm</h2><span id='topic+plot.slm'></span>

<h3>Description</h3>

<p>Same function as the <code><a href="stats.html#topic+plot.lm">plot.lm</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'slm'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.slm_+3A_x">x</code></td>
<td>
<p><code>slm</code> object.</p>
</td></tr>
<tr><td><code id="plot.slm_+3A_...">...</code></td>
<td>
<p>other parameters to be passed through to plotting functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns the graphics of <code>plot.lm(x)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("shan")
reg = slm(shan$PM_Xuhui ~ . , data = shan, method_cov_st = "fitAR", model_selec = -1)
plot(reg)
</code></pre>

<hr>
<h2 id='predict.slm'>Predict for slm object</h2><span id='topic+predict.slm'></span>

<h3>Description</h3>

<p>Predicted values based on <code>slm</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'slm'
predict(object, newdata = NULL, interval = "confidence",
  level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.slm_+3A_object">object</code></td>
<td>
<p>an object of class <code>slm</code>.</p>
</td></tr>
<tr><td><code id="predict.slm_+3A_newdata">newdata</code></td>
<td>
<p>an optional data frame in which to look for variables with which to predict.
<code>newdata</code> must contain only variables and not the intercept.
If omitted, the fitted values are used.</p>
</td></tr>
<tr><td><code id="predict.slm_+3A_interval">interval</code></td>
<td>
<p>type of interval calculation. It can be only <code>interval = "confidence"</code>, the default value. It computes
the confidence intervals for <code class="reqn">x' beta</code>, where <code class="reqn">x'</code> is a new observation of the design.</p>
</td></tr>
<tr><td><code id="predict.slm_+3A_level">level</code></td>
<td>
<p>a number between 0 and 1, which indicates the tolerance/confidence level.</p>
</td></tr>
<tr><td><code id="predict.slm_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function produces predicted values, obtained by evaluating the regression function in the frame <code>newdata</code>
(which defaults to <code>model.frame(object)</code>). If <code>newdata</code> is omitted the predictions are based on the data used for the fit.
</p>


<h3>Value</h3>

<p>This function produces a vector of predictions or a matrix of predictions and bounds with column names <code>fit</code>, <code>lwr</code>,
and <code>upr</code> if <code>interval</code> is set.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+predict.lm">predict.lm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("shan")
reg1 = slm(shan$PM_Xuhui ~ . , data = shan, method_cov_st = "fitAR", model_selec = -1)
predict(reg1)

data("co2")
y = as.vector(co2)
x = as.vector(time(co2)) - 1958
reg2 = slm(y ~ x + I(x^2) + I(x^3) + sin(2*pi*x) + cos(2*pi*x) + sin(4*pi*x) +
 cos(4*pi*x) + sin(6*pi*x) + cos(6*pi*x) + sin(8*pi*x) + cos(8*pi*x),
 method_cov_st = "fitAR", model_selec = -1)
predict(reg2)
</code></pre>

<hr>
<h2 id='Rboot'>Risk estimation for a tapered covariance matrix estimator via bootstrap method</h2><span id='topic+Rboot'></span>

<h3>Description</h3>

<p>This function computes an estimation of the risk for the tapered covariance matrix estimator of a process via a bootstrap method,
for a specified treshold and a specified kernel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rboot(epsilon, treshold, block_size, block_n, model_max, kernel_fonc)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Rboot_+3A_epsilon">epsilon</code></td>
<td>
<p>numeric vector. An univariate process.</p>
</td></tr>
<tr><td><code id="Rboot_+3A_treshold">treshold</code></td>
<td>
<p>integer. Number of estimated autocovariance terms that we consider for the estimation of the covariance matrix.</p>
</td></tr>
<tr><td><code id="Rboot_+3A_block_size">block_size</code></td>
<td>
<p>integer. The size of the bootstrap blocks. <code>block_size</code> must be greater than <code>model_max</code>.</p>
</td></tr>
<tr><td><code id="Rboot_+3A_block_n">block_n</code></td>
<td>
<p>integer. Blocks number used for the bootstrap.</p>
</td></tr>
<tr><td><code id="Rboot_+3A_model_max">model_max</code></td>
<td>
<p>integer. The maximal dimension, that is the maximal number of terms available to estimate the covariance matrix.</p>
</td></tr>
<tr><td><code id="Rboot_+3A_kernel_fonc">kernel_fonc</code></td>
<td>
<p>function. The kernel to use. The user can define his own kernel and put it in the argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list with:
</p>
<table role = "presentation">
<tr><td><code>risk</code></td>
<td>
<p>for one treshold, the value of the estimated risk.</p>
</td></tr>
<tr><td><code>SE</code></td>
<td>
<p>the standard-error due to the bootstrap.</p>
</td></tr>
</table>


<h3>References</h3>

<p>E. Caron, J. Dedecker and B. Michel (2019). Linear regression with stationary errors: the R package slm. <em>arXiv preprint arXiv:1906.06583</em>.
<a href="https://arxiv.org/abs/1906.06583">https://arxiv.org/abs/1906.06583</a>.
</p>

<hr>
<h2 id='rectangle'>Rectangular kernel</h2><span id='topic+rectangle'></span>

<h3>Description</h3>

<p>Rectangular kernel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rectangle(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rectangle_+3A_x">x</code></td>
<td>
<p>a vector of real numbers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function computes the values of the rectangular kernel at points <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = seq(-2,2,length=1000)
y = rectangle(x)
plot(x,y)
</code></pre>

<hr>
<h2 id='shan'>PM2.5 Data of Shanghai</h2><span id='topic+shan'></span>

<h3>Description</h3>

<p>This dataset comes from a study about fine particle pollution in five Chinese cities. The data are available on the
following website <a href="https://archive.ics.uci.edu/ml/datasets/PM2.5+Data+of+Five+Chinese+Cities#">https://archive.ics.uci.edu/ml/datasets/PM2.5+Data+of+Five+Chinese+Cities#</a>.
The present dataset concerns the city of Shanghai. From the initial dataset, we have removed the lines that contain
NA observations and we then extract the first 5000 observations. Then we consider only pollution variables and weather variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("shan")
</code></pre>


<h3>Format</h3>

<p>A data frame with 5000 rows and 10 variables:
</p>

<dl>
<dt>PM_Xuhui</dt><dd><p>PM2.5 concentration in the Xuhui district (<code class="reqn">ug/m3</code>).</p>
</dd>
<dt>PM_Jingan</dt><dd><p>PM2.5 concentration in the Jing’an district (<code class="reqn">ug/m3</code>).</p>
</dd>
<dt>PM_US.Post</dt><dd><p>PM2.5 concentration in the U.S diplomatic post (<code class="reqn">ug/m3</code>).</p>
</dd>
<dt>DEWP</dt><dd><p>Dew Point (<code class="reqn">Celsius Degree</code>).</p>
</dd>
<dt>TEMP</dt><dd><p>Temperature (<code class="reqn">Celsius Degree</code>).</p>
</dd>
<dt>HUMI</dt><dd><p>Humidity (%).</p>
</dd>
<dt>PRES</dt><dd><p>Pressure (<code class="reqn">hPa</code>).</p>
</dd>
<dt>Iws</dt><dd><p>Cumulated wind speed (<code class="reqn">m/s</code>).</p>
</dd>
<dt>precipitation</dt><dd><p>hourly precipitation (<code class="reqn">mm</code>).</p>
</dd>
<dt>Iprec</dt><dd><p>Cumulated precipitation (<code class="reqn">mm</code>).</p>
</dd>
</dl>


<h3>References</h3>

<p>E. Caron, J. Dedecker and B. Michel (2019). Linear regression with stationary errors: the R package slm. <em>arXiv preprint arXiv:1906.06583</em>.
<a href="https://arxiv.org/abs/1906.06583">https://arxiv.org/abs/1906.06583</a>.
</p>
<p>X. Liang, S. Li, S. Zhang, H. Huang, S.X. Chen (2016). PM2.5 data reliability, consistency, and air quality assessment in five Chinese cities.
<em>Journal of Geophysical Research: Atmospheres</em>, 121(17), 10–220.
</p>

<hr>
<h2 id='slm'>Fitting Stationary Linear Models</h2><span id='topic+slm'></span>

<h3>Description</h3>

<p><code>slm</code> is used to fit linear models when the error process is assumed to be strictly stationary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slm(myformula, data = NULL, model = TRUE, x = FALSE, y = FALSE,
  qr = TRUE, method_cov_st = "fitAR", cov_st = NULL, Cov_ST = NULL,
  model_selec = -1, model_max = 50, kernel_fonc = NULL,
  block_size = NULL, block_n = NULL, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="slm_+3A_myformula">myformula</code></td>
<td>
<p>an object of class &quot;<code><a href="stats.html#topic+formula">formula</a></code>&quot; (or one that can be coerced to that class):
a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="slm_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a data frame)
containing the variables in the model. If not found in <code>data</code>, the variables are taken from <code>environment(formula)</code>,
typically the environment from which <code>slm</code> is called.</p>
</td></tr>
<tr><td><code id="slm_+3A_model">model</code>, <code id="slm_+3A_x">x</code>, <code id="slm_+3A_y">y</code>, <code id="slm_+3A_qr">qr</code></td>
<td>
<p>logicals. If <code>TRUE</code> the corresponding components of the fit (the model frame, the model matrix, the response, the QR decomposition) are returned.</p>
</td></tr>
<tr><td><code id="slm_+3A_method_cov_st">method_cov_st</code></td>
<td>
<p>the method chosen by the user to estimate the autocovariances of the error process. The user
has the choice between the methods &quot;fitAR&quot;, &quot;spectralproj&quot;, &quot;efromovich&quot;, &quot;kernel&quot;, &quot;select&quot; or &quot;hac&quot;. By default, the
&quot;fitAR&quot; method is used.</p>
</td></tr>
<tr><td><code id="slm_+3A_cov_st">cov_st</code></td>
<td>
<p>numeric vector. The estimated autocovariances of the error process. The user can give his own vector.</p>
</td></tr>
<tr><td><code id="slm_+3A_cov_st">Cov_ST</code></td>
<td>
<p>matrix. It is an argument given by the user if he wants to use his own covariance matrix estimator.</p>
</td></tr>
<tr><td><code id="slm_+3A_model_selec">model_selec</code></td>
<td>
<p>integer or <code>-1</code>. The order of the method. If <code>model_selec = -1</code>, the method works automatically.</p>
</td></tr>
<tr><td><code id="slm_+3A_model_max">model_max</code></td>
<td>
<p>integer. Maximal order of the method.</p>
</td></tr>
<tr><td><code id="slm_+3A_kernel_fonc">kernel_fonc</code></td>
<td>
<p>function. Use this argument if <code>method_cov_st = kernel</code>. Define the kernel to use in the method. The user can give his own kernel function.</p>
</td></tr>
<tr><td><code id="slm_+3A_block_size">block_size</code></td>
<td>
<p>integer. Size of the bootstrap blocks if <code>method_cov_st = kernel</code>. <code>block_size</code> must be greater than <code>model_max</code>.</p>
</td></tr>
<tr><td><code id="slm_+3A_block_n">block_n</code></td>
<td>
<p>integer. Blocks number to use for the bootstrap if <code>method_cov_st = kernel</code>.</p>
</td></tr>
<tr><td><code id="slm_+3A_plot">plot</code></td>
<td>
<p>logical. By default, <code>plot = FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>slm</code> function is based on the architecture of the <code>lm</code> function.
Models for <code>slm</code> are specified symbolically.
A typical model has the form <code>response ~ terms</code> where <code>response</code> is the (numeric)
response vector and <code>terms</code> is a series of terms which specifies a linear predictor for <code>response</code>.
See the documentation of <code><a href="stats.html#topic+lm">lm</a></code> for more details.
</p>


<h3>Value</h3>

<p><code>slm</code> returns an object of <code><a href="base.html#topic+class">class</a></code> &quot;<code>slm</code>&quot;. The function
<code>summary</code> is used to obtain and print a summary of the results. The generic accessor functions
<code>coefficients</code>, <code>effects</code>, <code>fitted.values</code> and <code>residuals</code> extract various
useful features of the value returned by <code>slm</code>.
An object of class &quot;<code>slm</code>&quot; is a list containing at least the following components:
</p>
<table role = "presentation">
<tr><td><code>method_cov_st</code></td>
<td>
<p> print the method chosen.</p>
</td></tr>
<tr><td><code>cov_st</code></td>
<td>
<p> the estimated autocovariances of the error process. NA if &quot;hac&quot; is used.</p>
</td></tr>
<tr><td><code>Cov_ST</code></td>
<td>
<p> if given by the user, the estimated covariance matrix of the error process. NA if &quot;hac&quot; is used.</p>
</td></tr>
<tr><td><code>model_selec</code></td>
<td>
<p> the order of the method.</p>
</td></tr>
<tr><td><code>norm_matrix</code></td>
<td>
<p> the normalization matrix of the least squares estimator.</p>
</td></tr>
<tr><td><code>design_qr</code></td>
<td>
<p> the matrix <code class="reqn">(X^{t} X)^{-1}</code>.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p> a named vector of the estimated coefficients.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p> the residuals, that is response minus fitted values.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p> the fitted values.</p>
</td></tr>
<tr><td><code>rank</code></td>
<td>
<p> the numeric rank of the fitted linear model.</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p> the number of observations minus the number of variables.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p> the matched call.</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p> the <code><a href="stats.html#topic+terms">terms</a></code> object used.</p>
</td></tr>
<tr><td><code>xlevels</code></td>
<td>
<p> (only where relevant) a record of the levels of the factors used in fitting.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p> if requested, the response used.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p> if requested, the model matrix used.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p> if requested (the default), the model frame used.</p>
</td></tr>
</table>


<h3>References</h3>

<p>E. Caron, J. Dedecker and B. Michel (2019). Linear regression with stationary errors: the R package slm. <em>arXiv preprint arXiv:1906.06583</em>.
<a href="https://arxiv.org/abs/1906.06583">https://arxiv.org/abs/1906.06583</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.slm">summary</a></code> for summaries.
</p>
<p>The generic functions <code><a href="stats.html#topic+coef">coef</a></code>, <code><a href="stats.html#topic+effects">effects</a></code>,
<code><a href="stats.html#topic+residuals">residuals</a></code>, <code><a href="stats.html#topic+fitted">fitted</a></code>, <code><a href="stats.html#topic+vcov">vcov</a></code>.
</p>
<p><code><a href="#topic+predict.slm">predict</a></code> for prediction, including confidence intervals for <code class="reqn">x' beta</code>, where <code class="reqn">x'</code> is a new observation of the design.
</p>
<p><code><a href="#topic+confint.slm">confint</a></code> for confidence intervals of <em>parameters</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("shan")
slm(shan$PM_Xuhui ~ . , data = shan, method_cov_st = "fitAR", model_selec = -1)

data("co2")
y = as.vector(co2)
x = as.vector(time(co2)) - 1958
reg1 = slm(y ~ x + I(x^2) + I(x^3) + sin(2*pi*x) + cos(2*pi*x) + sin(4*pi*x) +
 cos(4*pi*x) + sin(6*pi*x) + cos(6*pi*x) + sin(8*pi*x) + cos(8*pi*x),
 method_cov_st = "fitAR", model_selec = -1, plot = TRUE)

reg2 = slm(y ~ x + I(x^2) + I(x^3) + sin(2*pi*x) + cos(2*pi*x) + sin(4*pi*x) +
 cos(4*pi*x) + sin(6*pi*x) + cos(6*pi*x) + sin(8*pi*x) + cos(8*pi*x),
 method_cov_st = "kernel", model_selec = -1, model_max = 50, kernel_fonc = triangle,
 block_size = 100, block_n = 100)
</code></pre>

<hr>
<h2 id='slm-class'>slm class</h2><span id='topic+slm-class'></span><span id='topic+slm.class'></span>

<h3>Description</h3>

<p>An S4 class to create an <code>slm</code> object.
</p>


<h3>Slots</h3>


<dl>
<dt><code>method_cov_st</code></dt><dd><p>the method used to compute the autocovariance vector of the error process. The user
has the choice between the methods &quot;fitAR&quot;, &quot;spectralproj&quot;, &quot;efromovich&quot;, &quot;kernel&quot;, &quot;select&quot; or &quot;hac&quot;. By default, the
&quot;fitAR&quot; method is used.</p>
</dd>
<dt><code>cov_st</code></dt><dd><p>a numeric vector with the estimated autocovariances of the error process, computed from
the <code>method_cov_st</code> method.</p>
</dd>
<dt><code>Cov_ST</code></dt><dd><p>the estimated covariance matrix of the error process, computed from the <code>method_cov_st</code> method.</p>
</dd>
<dt><code>model_selec</code></dt><dd><p>integer. The order of the chosen method. If <code>model_selec = -1</code>, the method works automatically.</p>
</dd>
<dt><code>norm_matrix</code></dt><dd><p>the normalization matrix of the design X.</p>
</dd>
<dt><code>design_qr</code></dt><dd><p>the matrix <code class="reqn">(X^{t} X)^{-1}</code>.</p>
</dd>
</dl>


<h3>References</h3>

<p>E. Caron, J. Dedecker and B. Michel (2019). Linear regression with stationary errors: the R package slm. <em>arXiv preprint arXiv:1906.06583</em>.
<a href="https://arxiv.org/abs/1906.06583">https://arxiv.org/abs/1906.06583</a>.
</p>

<hr>
<h2 id='summary.slm'>Summarizing Stationary Linear Model Fits</h2><span id='topic+summary.slm'></span>

<h3>Description</h3>

<p>Summary method for class &quot;<code>slm</code>&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'slm'
summary(object, correlation = FALSE,
  symbolic.cor = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.slm_+3A_object">object</code></td>
<td>
<p>an object of class &quot;<code>slm</code>&quot;, usually, a result of a call to <code>slm</code>.</p>
</td></tr>
<tr><td><code id="summary.slm_+3A_correlation">correlation</code></td>
<td>
<p>logical. If <code>TRUE</code>, the correlation matrix of the estimated parameters is returned and printed.</p>
</td></tr>
<tr><td><code id="summary.slm_+3A_symbolic.cor">symbolic.cor</code></td>
<td>
<p>logical. If <code>TRUE</code>, print the correlations in a symbolic form (see <code><a href="stats.html#topic+symnum">symnum</a></code>) rather than as numbers.</p>
</td></tr>
<tr><td><code id="summary.slm_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>summary.slm</code> computes and returns a list of summary statistics of the fitted linear model
given in <code>object</code>, using the components (list elements) &quot;<code>call</code>&quot; and &quot;<code>terms</code>&quot; from its argument, plus:
</p>
<table role = "presentation">
<tr><td><code>residuals</code></td>
<td>
<p> the residuals, that is response minus fitted values.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p> a <code class="reqn">p*4</code> matrix with columns for the estimated coefficient, its standard error, z-statistic and corresponding (two-sided) p-value.
Aliased coefficients are omitted.</p>
</td></tr>
<tr><td><code>aliased</code></td>
<td>
<p> named logical vector showing if the original coefficients are aliased.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p> the square root of the estimated variance of the error process.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p> degrees of freedom, a 3-vector <code class="reqn">(p, n-p, p*)</code>, the first being the number of non-aliased coefficients, the last being the total number of coefficients.</p>
</td></tr>
<tr><td><code>chi2statistic</code></td>
<td>
<p> a 2-vector with the value of the chi2-statistic with its degree of freedom.</p>
</td></tr>
<tr><td><code>r.squared</code></td>
<td>
 <p><code class="reqn">R^2</code>, the 'fraction of variance explained by the model'.</p>
</td></tr>
<tr><td><code>cov.unscaled</code></td>
<td>
<p> the matrix <code class="reqn">(X^{t} X)^{-1}</code>.</p>
</td></tr>
<tr><td><code>correlation</code></td>
<td>
<p> the correlation matrix corresponding to the above <code>cov.unscaled</code>, if <code>correlation = TRUE</code> is specified.</p>
</td></tr>
<tr><td><code>symbolic.cor</code></td>
<td>
<p> (only if <code>correlation</code> is true.) The value of the argument <code>symbolic.cor</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>E. Caron, J. Dedecker and B. Michel (2019). Linear regression with stationary errors: the R package slm. <em>arXiv preprint arXiv:1906.06583</em>.
<a href="https://arxiv.org/abs/1906.06583">https://arxiv.org/abs/1906.06583</a>.
</p>


<h3>See Also</h3>

<p>The model fitting function <code><a href="#topic+slm">slm</a></code>, <code><a href="base.html#topic+summary">summary</a></code>.
</p>
<p>The function <code><a href="stats.html#topic+coef">coef</a></code> extracts the matrix of coefficients with standard errors, z-statistics and p-values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("shan")
reg1 = slm(shan$PM_Xuhui ~ . , data = shan, method_cov_st = "fitAR", model_selec = -1)
summary(reg1)

data("co2")
y = as.vector(co2)
x = as.vector(time(co2)) - 1958
reg2 = slm(y ~ x + I(x^2) + I(x^3) + sin(2*pi*x) + cos(2*pi*x) + sin(4*pi*x) +
 cos(4*pi*x) + sin(6*pi*x) + cos(6*pi*x) + sin(8*pi*x) + cos(8*pi*x),
 method_cov_st = "fitAR", model_selec = -1)
summary(reg2)
</code></pre>

<hr>
<h2 id='trapeze'>Trapeze kernel</h2><span id='topic+trapeze'></span>

<h3>Description</h3>

<p>Trapeze kernel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trapeze(x, width = 0.8)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trapeze_+3A_x">x</code></td>
<td>
<p>a vector of real numbers.</p>
</td></tr>
<tr><td><code id="trapeze_+3A_width">width</code></td>
<td>
<p>a number between 0 and 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function computes the values of the trapeze kernel at points <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = seq(-2,2,length=1000)
y = trapeze(x, width=0.5)
plot(x,y)
</code></pre>

<hr>
<h2 id='triangle'>Kernel triangle</h2><span id='topic+triangle'></span>

<h3>Description</h3>

<p>Kernel triangle
</p>


<h3>Usage</h3>

<pre><code class='language-R'>triangle(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="triangle_+3A_x">x</code></td>
<td>
<p>a vector of real numbers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function computes the values of the triangle kernel at points <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = seq(-2,2,length=1000)
y = triangle(x)
plot(x,y)
</code></pre>

<hr>
<h2 id='vcov.slm'>Calculate Variance-Covariance Matrix for a Fitted Model Object of class slm</h2><span id='topic+vcov.slm'></span>

<h3>Description</h3>

<p>Returns the variance-covariance matrix of the (non-normalized) least squares estimators for an object of class slm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'slm'
vcov(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcov.slm_+3A_object">object</code></td>
<td>
<p>a fitted model object of class slm.</p>
</td></tr>
<tr><td><code id="vcov.slm_+3A_...">...</code></td>
<td>
<p>additional arguments for method functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The variance-covariance matrix of the (non-normalized) least squares estimators for an object of class slm.
</p>


<h3>See Also</h3>

<p>The generic function <code><a href="stats.html#topic+vcov">vcov</a></code>.
</p>
<p>The function <code><a href="#topic+cov_matrix_estimator">cov_matrix_estimator</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> n = 500
 eps = generative_process(n,"AR1",c(0.7))
 X = as.matrix(generative_model(n,"mod2"))
 Y = 3 + 2*X[,2] + eps
 reg = slm(Y ~ X, method_cov_st = "fitAR", model_selec = -1)
 vcov(reg)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
