<!DOCTYPE html><html><head><title>Help for package ATAforecasting</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ATAforecasting}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ATA'><p>Automatic Time Series Analysis and Forecasting using Ata Method with Box-Cox Power Transformations Family and Seasonal Decomposition Techniques</p></a></li>
<li><a href='#ATA.Accuracy'><p>Accuracy Measures for The ATAforecasting</p></a></li>
<li><a href='#ATA.BackTransform'><p>Back Transformation Techniques for The ATAforecasting</p></a></li>
<li><a href='#ATA.BoxCoxAttr'><p>The ATA.BoxCoxAttr function works with many different types of inputs.</p></a></li>
<li><a href='#ATA.CI'><p>Confidence Interval function for the ATA Method</p></a></li>
<li><a href='#ATA.Core'><p>The core algorithm of the ATA Method</p></a></li>
<li><a href='#ATA.Decomposition'><p>Seasonal Decomposition for The ATAforecasting</p></a></li>
<li><a href='#ATA.Forecast'><p>Forecasting Method for The ATAforecasting</p></a></li>
<li><a href='#ATA.Plot'><p>Specialized Plot Function of The ATAforecasting</p></a></li>
<li><a href='#ATA.Print'><p>Specialized Screen Print Function of The ATAforecasting</p></a></li>
<li><a href='#ATA.SeasAttr'><p>Attributes Set For Unit Root and Seasonality Tests</p></a></li>
<li><a href='#ATA.Seasonality'><p>Seasonality Tests for The ATAforecasting</p></a></li>
<li><a href='#ATA.Shift'><p>Lag/Lead (Shift) Function for Univariate Series</p></a></li>
<li><a href='#ATA.Shift_Mat'><p>Lag/Lead (Shift) Function for Multivariate Series</p></a></li>
<li><a href='#ATA.Transform'><p>Transformation Techniques for The ATAforecasting</p></a></li>
<li><a href='#ATAforecasting-package'><p>ATAforecasting: Automatic Time Series Analysis and Forecasting using Ata Method with Box-Cox Power Transformations Family and Seasonal Decomposition Techniques</p></a></li>
<li><a href='#find.freq'><p>Find Frequency Using Spectral Density Of A Time Series From AR Fit</p></a></li>
<li><a href='#find.freq.fourier'><p>Find Frequency Using Periodogram</p></a></li>
<li><a href='#find.multi.freq'><p>Find Multi Frequency Using Spectral Density Of A Time Series From AR Fit</p></a></li>
<li><a href='#fundingTR'><p>Weekly Net Funding Level of Central Bank of Republic of Turkey</p></a></li>
<li><a href='#touristTR'><p>Monthly number of tourists arrived in Turkey</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Automatic Time Series Analysis and Forecasting using the Ata
Method</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.60</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-06-12</td>
</tr>
<tr>
<td>Description:</td>
<td>The Ata method (Yapar et al. (2019) &lt;<a href="https://doi.org/10.15672%2Fhujms.461032">doi:10.15672/hujms.461032</a>&gt;), an alternative to exponential smoothing (described in Yapar (2016) &lt;<a href="https://doi.org/10.15672%2FHJMS.201614320580">doi:10.15672/HJMS.201614320580</a>&gt;,
	Yapar et al. (2017) &lt;<a href="https://doi.org/10.15672%2FHJMS.2017.493">doi:10.15672/HJMS.2017.493</a>&gt;), is a new univariate time series forecasting method which provides innovative solutions to issues faced during the
	initialization and optimization stages of existing forecasting methods. Forecasting performance of the Ata method is superior to existing methods both in terms of easy
	implementation and accurate forecasting. It can be applied to non-seasonal or seasonal time series which can be decomposed into four components (remainder, level, trend
	and seasonal). This methodology performed well on the M3 and M4-competition data. This package was written based on Ali Sabri Taylanâ€™s PhD dissertation.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ali Sabri Taylan &lt;alisabritaylan@gmail.com&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/alsabtay/ATAforecasting">https://github.com/alsabtay/ATAforecasting</a>,
<a href="https://atamethod.wordpress.com/">https://atamethod.wordpress.com/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/alsabtay/ATAforecasting/issues">https://github.com/alsabtay/ATAforecasting/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, forecast, Rcpp, Rdpack, seasonal, stats, stlplus,
stR, timeSeries, TSA, tseries, utils, xts</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Author:</td>
<td>Ali Sabri Taylan <a href="https://orcid.org/0000-0001-9514-934X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Hanife Taylan Selamlar
    <a href="https://orcid.org/0000-0002-4091-884X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cph],
  Guckan Yapar <a href="https://orcid.org/0000-0002-0971-6676"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, ths, cph]</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-12 10:20:22 UTC; astaylan</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-12 10:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ATA'>Automatic Time Series Analysis and Forecasting using Ata Method with Box-Cox Power Transformations Family and Seasonal Decomposition Techniques</h2><span id='topic+ATA'></span>

<h3>Description</h3>

<p><code>ATA</code> is a generic function for Ata Method forecasting.
The Ata method based on the modified simple exponential smoothing as described in Yapar, G. (2016) &lt;doi:10.15672/HJMS.201614320580&gt; ,
Yapar G., Capar, S., Selamlar, H. T., Yavuz, I. (2017) &lt;doi:10.15672/HJMS.2017.493&gt; and Yapar G., Selamlar, H. T., Capar, S., Yavuz, I. (2019)
&lt;doi:10.15672/hujms.461032&gt; is a new univariate time series forecasting method which provides innovative solutions to issues faced during
the initialization and optimization stages of existing methods.
Forecasting performance of the Ata method is superior to existing methods both in terms of easy implementation and accurate forecasting.
It can be applied to non-seasonal or seasonal time series which can be decomposed into four components (remainder, level, trend and seasonal).
This methodology performed well on the M3 and M4-competition data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ATA(
  X,
  Y = NULL,
  parP = NULL,
  parQ = NULL,
  parPHI = NULL,
  model.type = NULL,
  seasonal.test = NULL,
  seasonal.model = "decomp",
  seasonal.period = NULL,
  seasonal.type = NULL,
  seasonal.test.attr = NULL,
  find.period = NULL,
  accuracy.type = NULL,
  nmse = 3,
  level.fixed = FALSE,
  trend.opt = "none",
  h = NULL,
  train_test_split = NULL,
  holdout = FALSE,
  holdout.adjustedP = TRUE,
  holdout.set_size = NULL,
  holdout.onestep = FALSE,
  holdin = FALSE,
  transform.order = "before",
  transform.method = NULL,
  transform.attr = NULL,
  lambda = NULL,
  shift = 0,
  initial.level = "none",
  initial.trend = "none",
  ci.level = 95,
  start.phi = NULL,
  end.phi = NULL,
  size.phi = NULL,
  negative.forecast = TRUE,
  onestep = FALSE,
  print.out = TRUE,
  plot.out = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ATA_+3A_x">X</code></td>
<td>
<p>A numeric vector or time series of class <code>ts</code> or <code>msts</code> for in-sample.</p>
</td></tr>
<tr><td><code id="ATA_+3A_y">Y</code></td>
<td>
<p>A numeric vector or time series of class <code>ts</code> or <code>msts</code> for out-sample. If you do not have out-sample data, you can split in-sample data into training and test dataset with <code>train_test_split</code> argument.</p>
</td></tr>
<tr><td><code id="ATA_+3A_parp">parP</code></td>
<td>
<p>Value of Level parameter <code>p</code>. If NULL or &quot;opt&quot;, it is estimated. <code>p</code> has all integer values from 1 to <code>length(X)</code>.</p>
</td></tr>
<tr><td><code id="ATA_+3A_parq">parQ</code></td>
<td>
<p>Value of Trend parameter <code>q</code>. If NULL or &quot;opt&quot;, it is estimated. <code>q</code> has all integer values from 0 to <code>p</code>.</p>
</td></tr>
<tr><td><code id="ATA_+3A_parphi">parPHI</code></td>
<td>
<p>Value of Damping Trend parameter <code>phi</code>. If NULL or &quot;opt&quot;, it is estimated. phi has all values from 0 to 1.</p>
</td></tr>
<tr><td><code id="ATA_+3A_model.type">model.type</code></td>
<td>
<p>An one-character string identifying method using the framework terminology. The letter &quot;A&quot; for additive model, the letter &quot;M&quot; for multiplicative model.
If NULL, both letters will be tried and the best model (according to the accuracy measure <code>accuracy.type</code>) returned.</p>
</td></tr>
<tr><td><code id="ATA_+3A_seasonal.test">seasonal.test</code></td>
<td>
<p>Testing for stationary and seasonality. If TRUE, the method firstly uses <code>test="adf"</code>, Augmented Dickey-Fuller, unit-root test then the test returns the least number of differences required to pass the test at level <code>alpha</code>.
After the unit-root test, seasonal test applies on the stationary <code>X</code>.</p>
</td></tr>
<tr><td><code id="ATA_+3A_seasonal.model">seasonal.model</code></td>
<td>
<p>A string identifying method for seasonal decomposition. If NULL, &quot;decomp&quot; method is default. c(&quot;none&quot;, &quot;decomp&quot;, &quot;stl&quot;, &quot;stlplus&quot;, &quot;tbats&quot;, &quot;stR&quot;) phrases of methods denote
</p>

<ul>
<li><p>none    : seasonal decomposition is not required.
</p>
</li>
<li><p>decomp     : classical seasonal decomposition. If <code>decomp</code>, the <code>stats</code> package will be used.
</p>
</li>
<li><p>stl        : seasonal-trend decomposition procedure based on loess developed by Cleveland et al. (1990). If <code>stl</code>, the <code>stats</code> and <code>forecast</code> packages will be used. Multiple seasonal periods are allowed.
</p>
</li>
<li><p>stlplus    : seasonal-trend decomposition procedure based on loess developed by Cleveland et al. (1990). If <code>stlplus</code>, the <code>stlplus</code> package will be used.
</p>
</li>
<li><p>tbats   : exponential smoothing state space model with Box-Cox transformation, ARMA errors, trend and seasonal components.
as described in De Livera, Hyndman &amp; Snyder (2011). Parallel processing is used by default to speed up the computations. If <code>tbats</code>, the <code>forecast</code> package will be used. Multiple seasonal periods are allowed.
</p>
</li>
<li><p>stR        : seasonal-trend decomposition procedure based on regression developed by Dokumentov and Hyndman (2015). If <code>stR</code>, the <code>stR</code> package will be used. Multiple seasonal periods are allowed.
</p>
</li>
<li><p>x13        : seasonal-trend decomposition procedure based on X13ARIMA/SEATS. If <code>x13</code>, the <code>seasonal</code> package will be used.
</p>
</li>
<li><p>x11        : seasonal-trend decomposition procedure based on X11. If <code>x11</code>, the <code>seasonal</code> package will be used.
</p>
</li></ul>
</td></tr>
<tr><td><code id="ATA_+3A_seasonal.period">seasonal.period</code></td>
<td>
<p>Value(s) of seasonal periodicity. If NULL, <code>frequency</code> of X is default  If <code>seasonal.period</code> is not integer, <code>X</code> must be <code>msts</code> time series object. c(s1,s2,s3,...) for multiple period. If <code>X</code> has multiple periodicity, &quot;tbats&quot; or &quot;stR&quot; seasonal model have to be selected.</p>
</td></tr>
<tr><td><code id="ATA_+3A_seasonal.type">seasonal.type</code></td>
<td>
<p>An one-character string identifying method for the seasonal component framework. The letter &quot;A&quot; for additive model, the letter &quot;M&quot; for multiplicative model.
If NULL, both letters will be tried and the best model (according to the accuracy measure <code>accuracy.type</code>) returned.
If seasonal decomposition methods except <code>decomp</code> with &quot;M&quot;, Box-Cox transformation with <code>lambda</code>=0 is selected.</p>
</td></tr>
<tr><td><code id="ATA_+3A_seasonal.test.attr">seasonal.test.attr</code></td>
<td>
<p>Attributes set for unit root, seasonality tests, X13ARIMA/SEATS and X11. If NULL, corrgram.tcrit=1.28, uroot.test=&quot;adf&quot;, suroot.test=&quot;correlogram&quot;, suroot.uroot=TRUE, uroot.type=&quot;trend&quot;, uroot.alpha=0.05, suroot.alpha=0.05, uroot.maxd=2, suroot.maxD=1, suroot.m=frequency(X), uroot.pkg=&quot;urca&quot;, multi.period=&quot;min&quot;, x13.estimate.maxiter=1500, x13.estimate.tol=1.0e-5, x11.estimate.maxiter=1500, x11.estimate.tol=1.0e-5. If you want to change, please use <code>ATA.SeasAttr</code> function and its output.
For example, you can use <code>seasonal.test.attr = ATA.SeasAttr(corrgram.tcrit=1.65)</code> equation in <code>ATA</code> function.</p>
</td></tr>
<tr><td><code id="ATA_+3A_find.period">find.period</code></td>
<td>
<p>Find seasonal period(s) automatically. If NULL, 0 is default. When <code>find.period</code>,
</p>

<ul>
<li><p>0 : none
</p>
</li>
<li><p>1 : single period with find.freq
</p>
</li>
<li><p>2 : single period with <code>forecast::findfrequency</code>
</p>
</li>
<li><p>3 : multiple period with find.freq &amp; stR
</p>
</li>
<li><p>4 : multiple period with find.freq &amp; tbats
</p>
</li>
<li><p>5 : multiple period with find.freq &amp; stl
</p>
</li></ul>
</td></tr>
<tr><td><code id="ATA_+3A_accuracy.type">accuracy.type</code></td>
<td>
<p>Accuracy measure for optimization of the best ATA Method forecasting. IF NULL, <code>sMAPE</code> is default.
</p>

<ul>
<li><p>lik        : maximum likelihood functions
</p>
</li>
<li><p>sigma    : residual variance.
</p>
</li>
<li><p>MAE        : mean absolute error.
</p>
</li>
<li><p>MSE        : mean square error.
</p>
</li>
<li><p>AMSE    : Average MSE over first 'nmse' forecast horizons using k-step forecast.
</p>
</li>
<li><p>GAMSE    : Average MSE over first 'nmse' forecast horizons using one-step forecast.
</p>
</li>
<li><p>RMSE    : root mean squared error.
</p>
</li>
<li><p>MPE        : mean percentage error.
</p>
</li>
<li><p>MAPE    : mean absolute percentage error.
</p>
</li>
<li><p>sMAPE    : symmetric mean absolute percentage error.
</p>
</li>
<li><p>MASE    : mean absolute scaled error.
</p>
</li>
<li><p>OWA        : overall weighted average of MASE and sMAPE.
</p>
</li>
<li><p>MdAE    : median absolute error.
</p>
</li>
<li><p>MdSE    : median square error.
</p>
</li>
<li><p>RMdSE    : root median squared error.
</p>
</li>
<li><p>MdPE    : median percentage error.
</p>
</li>
<li><p>MdAPE    : median absolute percentage error.
</p>
</li>
<li><p>sMdAPE    : symmetric median absolute percentage error.
</p>
</li></ul>
</td></tr>
<tr><td><code id="ATA_+3A_nmse">nmse</code></td>
<td>
<p>If accuracy.type == &quot;AMSE&quot; or &quot;GAMSE&quot;, nmse provides the number of steps for average multistep MSE ('2&lt;=nmse&lt;=30').</p>
</td></tr>
<tr><td><code id="ATA_+3A_level.fixed">level.fixed</code></td>
<td>
<p>If TRUE, &quot;pStarQ&quot;  &ndash;&gt; First, fits ATA(p,0) where p = p* is optimized for q=0. Then, fits ATA(p*,q) where q is optimized for p = p*.</p>
</td></tr>
<tr><td><code id="ATA_+3A_trend.opt">trend.opt</code></td>
<td>
<p>When <code>trend.opt</code>,
</p>

<ul>
<li><p>none : none
</p>
</li>
<li><p>fixed : &quot;pBullet&quot; &ndash;&gt; Fits ATA(p,1) where p = p* is optimized for q = 1.
</p>
</li>
<li><p>search : &quot;qBullet&quot; &ndash;&gt; Fits ATA(p,q) where p = p* is optimized for q = q* (q &gt; 0). Then, fits ATA(p*,q) where q is optimized for p = p*.
</p>
</li></ul>
</td></tr>
<tr><td><code id="ATA_+3A_h">h</code></td>
<td>
<p>The forecast horizon.
When the parameter is NULL; if the frequency of <code>X</code> is 4, the parameter is set to 8; if the frequency of <code>X</code> is 12, the parameter is set to 18; the parameter is set to 6 for other cases.</p>
</td></tr>
<tr><td><code id="ATA_+3A_train_test_split">train_test_split</code></td>
<td>
<p>If <code>Y</code> is NULL, this parameter divides <code>X</code> into two parts: training set (in-sample) and test set (out-sample). <code>train_test_split</code> is number of periods for forecasting and size of test set.
If the value is between 0 and 1, percentage of length is active.</p>
</td></tr>
<tr><td><code id="ATA_+3A_holdout">holdout</code></td>
<td>
<p>Default is FALSE. If TRUE, ATA Method uses the holdout forecasting for accuracy measure to select the best model. In holdout forecasting, the last few data points are removed from the data series.
The remaining historical data series is called in-sample data (training set), and the holdout data is called validation set (holdout set).
If TRUE, holdout.set_size will used for holdout data.</p>
</td></tr>
<tr><td><code id="ATA_+3A_holdout.adjustedp">holdout.adjustedP</code></td>
<td>
<p>Default is TRUE. If TRUE, parP will be adjusted by length of training - validation sets and in-sample set when the holdout forecasting is active.</p>
</td></tr>
<tr><td><code id="ATA_+3A_holdout.set_size">holdout.set_size</code></td>
<td>
<p>If <code>holdout</code> is TRUE, this parameter will be same as <code>h</code> for defining holdout set.</p>
</td></tr>
<tr><td><code id="ATA_+3A_holdout.onestep">holdout.onestep</code></td>
<td>
<p>Default is FALSE. if TRUE, the dynamic forecast strategy uses a one-step model multiple times (<code>h</code> forecast horizon) where the holdout prediction for the prior time step is used as an input for making a prediction on the following time step.</p>
</td></tr>
<tr><td><code id="ATA_+3A_holdin">holdin</code></td>
<td>
<p>Default is FALSE. If TRUE, ATA Method uses the hold-in forecasting for accuracy measure to select the best model. In hold-in forecasting, the last h-length data points are used for accuracy measure.</p>
</td></tr>
<tr><td><code id="ATA_+3A_transform.order">transform.order</code></td>
<td>
<p>If &quot;before&quot;, Box-Cox transformation family will be applied and then seasonal decomposition techniques will be applied. If &quot;after&quot;, seasonal decomposition techniques will be applied and then Box-Cox transformation family will be applied.</p>
</td></tr>
<tr><td><code id="ATA_+3A_transform.method">transform.method</code></td>
<td>
<p>Transformation method  &ndash;&gt; &quot;Box_Cox&quot;, &quot;Sqrt&quot;, &quot;Reciprocal&quot;, &quot;Log&quot;, &quot;NegLog&quot;, &quot;Modulus&quot;, &quot;BickelDoksum&quot;, &quot;Manly&quot;, &quot;Dual&quot;, &quot;YeoJohnson&quot;, &quot;GPower&quot;, &quot;GLog&quot;. If the transformation process needs shift parameter,
<code>ATA.Transform</code> will calculate required shift parameter automatically.</p>
</td></tr>
<tr><td><code id="ATA_+3A_transform.attr">transform.attr</code></td>
<td>
<p>Attributes set for Box-Cox transformation. If NULL, bcMethod = &quot;loglik&quot;, bcLower = 0, bcUpper = 1, bcBiasAdj = FALSE. If you want to change, please use <code>ATA.BoxCoxAttr</code> function and its output.</p>
</td></tr>
<tr><td><code id="ATA_+3A_lambda">lambda</code></td>
<td>
<p>Box-Cox power transformation family parameter. Default is NULL. When &quot;transform.method&quot; is selected and lambda is set as NULL, required &quot;lambda&quot; parameter will be calculated automatically based on &quot;transform.attr&quot;.</p>
</td></tr>
<tr><td><code id="ATA_+3A_shift">shift</code></td>
<td>
<p>Box-Cox power transformation family shifting parameter. Default is 0. When &quot;transform.method&quot; is selected, required shifting parameter will be calculated automatically according to dataset.</p>
</td></tr>
<tr><td><code id="ATA_+3A_initial.level">initial.level</code></td>
<td>
<p>&quot;none&quot; is default,
</p>

<ul>
<li><p>none    : ATA Method calculates the pth observation in <code>X</code> for level.
</p>
</li>
<li><p>mean     : ATA Method calculates average of first p value in <code>X</code>for level.
</p>
</li>
<li><p>median: ATA Method calculates median of first p value in <code>X</code>for level.
</p>
</li></ul>
</td></tr>
<tr><td><code id="ATA_+3A_initial.trend">initial.trend</code></td>
<td>
<p>&quot;none&quot; is default,
</p>

<ul>
<li><p>none    : ATA Method calculates the qth observation in <code>X</code> for trend.
</p>
</li>
<li><p>mean     : ATA Method calculates average of first q value in <code>X(T)-X(T-1)</code> for trend.
</p>
</li>
<li><p>median: ATA Method calculates median of first q value in <code>X(T)-X(T-1)</code> for trend.
</p>
</li></ul>
</td></tr>
<tr><td><code id="ATA_+3A_ci.level">ci.level</code></td>
<td>
<p>Confidence Interval levels for forecasting.</p>
</td></tr>
<tr><td><code id="ATA_+3A_start.phi">start.phi</code></td>
<td>
<p>Lower boundary for searching <code>parPHI</code>.If NULL, 0 is default.</p>
</td></tr>
<tr><td><code id="ATA_+3A_end.phi">end.phi</code></td>
<td>
<p>Upper boundary for searching <code>parPHI</code>. If NULL, 1 is is default.</p>
</td></tr>
<tr><td><code id="ATA_+3A_size.phi">size.phi</code></td>
<td>
<p>Increment step for searching <code>parPHI</code>. If NULL, the step size will be determined as the value that allows the bounds for the optimised value of <code>parPHI</code> to be divided into 20 equal parts.</p>
</td></tr>
<tr><td><code id="ATA_+3A_negative.forecast">negative.forecast</code></td>
<td>
<p>Negative values are allowed for forecasting. Default value is TRUE. If FALSE, all negative values for forecasting are set to 0.</p>
</td></tr>
<tr><td><code id="ATA_+3A_onestep">onestep</code></td>
<td>
<p>Default is FALSE. if TRUE, the dynamic forecast strategy uses a one-step model multiple times (<code>h</code> forecast horizon) where the prediction for the prior time step is used as an input for making a prediction on the following time step.</p>
</td></tr>
<tr><td><code id="ATA_+3A_print.out">print.out</code></td>
<td>
<p>Default is TRUE. If FALSE, summary of ATA Method is not shown.</p>
</td></tr>
<tr><td><code id="ATA_+3A_plot.out">plot.out</code></td>
<td>
<p>Default is TRUE. If FALSE, graphics of ATA Method are not shown.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns ATA(p,q,phi)(E,T,S) applied to <code>X</code>.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>ata</code>. The generic accessor functions <code>ATA.Forecast</code> and <code>ATA.Accuracy</code> extract useful features of the value returned by <code>ATA</code> and associated functions.
<code>ata</code> object is a list containing at least the following elements
</p>

<ul>
<li><p>actual		: The original time series.
</p>
</li>
<li><p>fitted		: Fitted values (one-step forecasts). The mean is of the fitted values is calculated over the ensemble.
</p>
</li>
<li><p>level		  : Estimated level values.
</p>
</li>
<li><p>trend		  : Estimated trend values.
</p>
</li>
<li><p>residuals	: Original values minus fitted values.
</p>
</li>
<li><p>coefp		  : The weights attached to level observations.
</p>
</li>
<li><p>coefq		  : The weights attached to trend observations.
</p>
</li>
<li><p>p		      : Optimum level parameter.
</p>
</li>
<li><p>q		      : Optimum trend parameter.
</p>
</li>
<li><p>phi		    : Optimum damped trend parameter.
</p>
</li>
<li><p>model.type: Form of trend.
</p>
</li>
<li><p>h		      : The number of steps to forecast ahead.
</p>
</li>
<li><p>forecast	: Point forecasts as a time series.
</p>
</li>
<li><p>out.sample: Test set as a time series.
</p>
</li>
<li><p>method		: The name of the optimum forecasting method as a character string for ATA(P,Q,PHI)(Error,Trend,Season).
</p>
</li>
<li><p>initial.level     : Selected initial level values for the time series forecasting method.
</p>
</li>
<li><p>initial.trend     : Selected initial trend values for the time series forecasting method.
</p>
</li>
<li><p>level.fixed       : A choice of optional level-fixed trended methods.
</p>
</li>
<li><p>trend.opt       : A choice of optional trend and level optimized trended methods (none, trend.fixed or trend.search).
</p>
</li>
<li><p>transform.method  : Box-Cox power transformation family method  &ndash;&gt; Box_Cox, Sqrt, Reciprocal, Log, NegLog, Modulus, BickelDoksum, Manly, Dual, YeoJohnson, GPower, GLog.
</p>
</li>
<li><p>transform.order   : Define how to apply Box-Cox power transformation techniques, before or after seasonal decomposition.
</p>
</li>
<li><p>lambda  	: Box-Cox power transformation family parameter.
</p>
</li>
<li><p>shift		  : Box-Cox power transformation family shifting parameter.
</p>
</li>
<li><p>accuracy.type		  : Accuracy measure that is chosen for model selection.
</p>
</li>
<li><p>nmse		  : The number of steps for average multistep MSE.
</p>
</li>
<li><p>accuracy 	: In and out sample accuracy measures and its descriptives that are calculated for optimum model are given.
</p>
</li>
<li><p>par.specs 	: Parameter sets for Information Criteria.
</p>
</li>
<li><p>holdout		: Holdout forecasting is TRUE or FALSE.
</p>
</li>
<li><p>holdout.training 	: Training set in holdout forecasting.
</p>
</li>
<li><p>holdout.validation: Validation set in holdout forecasting.
</p>
</li>
<li><p>holdout.forecast	: Holdout forecast.
</p>
</li>
<li><p>holdout.accuracy	: Accuracy measure chosen for model selection in holdout forecasting.
</p>
</li>
<li><p>holdin		: Hold-in forecasting is TRUE or FALSE.
</p>
</li>
<li><p>is.season	: Indicates whether it contains seasonal pattern.
</p>
</li>
<li><p>seasonal.model		: The name of the selected decomposition method.
</p>
</li>
<li><p>seasonal.type	  	: Form of seasonality.
</p>
</li>
<li><p>seasonal.period		: The number of seasonality periods.
</p>
</li>
<li><p>seasonal.index		: Weights of seasonality.
</p>
</li>
<li><p>seasonal	: Estimated seasonal values.
</p>
</li>
<li><p>seasonal.adjusted	: Deseasonalized time series values.
</p>
</li>
<li><p>execution.time		: The real and CPU time 'in seconds' spent by the system executing that task, including the time spent executing run-time or system services on its behalf.
</p>
</li>
<li><p>calculation.time	: How much real time 'in seconds' the currently running R process has already taken.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Ali Sabri Taylan and Hanife Taylan Selamlar
</p>


<h3>References</h3>

<p>#'Yapar G, Yavuz I, Selamlar HT (2017).
&ldquo;Why and How Does Exponential Smoothing Fail? An In Depth Comparison of ATA-Simple and Simple Exponential Smoothing.&rdquo;
<em>Turkish Journal of Forecasting</em>, <b>1</b>(1), 30&ndash;39.
</p>
<p>#'Yapar G, Capar S, Selamlar HT, Yavuz I (2018).
&ldquo;Modified Holt's Linear Trend Method.&rdquo;
<em>Hacettepe University Journal of Mathematics and Statistics</em>, <b>47</b>(5), 1394&ndash;1403.
</p>
<p>#'Yapar G (2018).
&ldquo;Modified simple exponential smoothing.&rdquo;
<em>Hacettepe University Journal of Mathematics and Statistics</em>, <b>47</b>(3), 741&ndash;754.
</p>
<p>#'Yapar G, Selamlar HT, Capar S, Yavuz I (2019).
&ldquo;ATA method.&rdquo;
<em>Hacettepe Journal of Mathematics and Statistics</em>, <b>48</b>(6), 1838-1844.
</p>


<h3>See Also</h3>

<p><code>forecast</code>, <code>stlplus</code>, <code>stR</code>, <code><a href="stats.html#topic+stl">stl</a></code>, <code><a href="stats.html#topic+decompose">decompose</a></code>,
<code>tbats</code>, <code>seasadj</code>, <code>seasonal</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trainATA &lt;-  head(touristTR, 84)
testATA &lt;- window(touristTR, start = 2015, end = 2016.917)
ata_fit &lt;- ATA(trainATA, h=24, parQ = 1, seasonal.test = TRUE, seasonal.model = "stl")
ata_fc &lt;- ATA.Forecast(ata_fit, out.sample = testATA)
ata_accry &lt;- ATA.Accuracy(ata_fc)

</code></pre>

<hr>
<h2 id='ATA.Accuracy'>Accuracy Measures for The ATAforecasting</h2><span id='topic+ATA.Accuracy'></span>

<h3>Description</h3>

<p>Returns ATA(p,q,phi)(E,T,S) applied to 'ata' <code>object</code>.
Accuracy measures for a forecast model
Returns range of summary measures of the forecast accuracy. If <code>out.sample</code> is
provided, the function measures test set forecast accuracy.
If <code>out.sample</code> is not provided, the function only produces
training set accuracy measures.
The measures calculated are:
</p>

<ul>
<li><p>lik		: maximum likelihood functions
</p>
</li>
<li><p>sigma	: residual variance.
</p>
</li>
<li><p>MAE		: mean absolute error.
</p>
</li>
<li><p>MSE		: mean square error.
</p>
</li>
<li><p>RMSE	: root mean squared error.
</p>
</li>
<li><p>MPE		: mean percentage error.
</p>
</li>
<li><p>MAPE	: mean absolute percentage error.
</p>
</li>
<li><p>sMAPE	: symmetric mean absolute percentage error.
</p>
</li>
<li><p>MASE	: mean absolute scaled error.
</p>
</li>
<li><p>OWA		: overall weighted average of MASE and sMAPE.
</p>
</li>
<li><p>MdAE	: median absolute error.
</p>
</li>
<li><p>MdSE	: median square error.
</p>
</li>
<li><p>RMdSE	: root median squared error.
</p>
</li>
<li><p>MdPE	: median percentage error.
</p>
</li>
<li><p>MdAPE	: median absolute percentage error.
</p>
</li>
<li><p>sMdAPE	: symmetric median absolute percentage error.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>ATA.Accuracy(object, out.sample = NULL, print.out = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ATA.Accuracy_+3A_object">object</code></td>
<td>
<p>An object of class <code>ata</code> is required.</p>
</td></tr>
<tr><td><code id="ATA.Accuracy_+3A_out.sample">out.sample</code></td>
<td>
<p>A numeric vector or time series of class <code>ts</code> or <code>msts</code> for out-sample.</p>
</td></tr>
<tr><td><code id="ATA.Accuracy_+3A_print.out">print.out</code></td>
<td>
<p>Default is TRUE. If FALSE, summary of ATA Method's accuracy measures is not shown.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix giving forecast accuracy measures.
</p>


<h3>Author(s)</h3>

<p>Ali Sabri Taylan and Hanife Taylan Selamlar
</p>


<h3>References</h3>

<p>#'Hyndman RJ, Koehler AB (2006).
&ldquo;Another look at measures of forecast accuracy.&rdquo;
<em>International Journal of Forecasting</em>, <b>22</b>(4), 679&ndash;688.
</p>
<p>#'Hyndman RJ, Athanasopoulos G (2019).
<em>Forecasting: principles and practice</em>.
OTexts.
<a href="https://otexts.com/fpp3/">https://otexts.com/fpp3/</a>.
</p>


<h3>See Also</h3>

<p><code>forecast</code>, <code>stlplus</code>, <code>stR</code>, <code><a href="stats.html#topic+stl">stl</a></code>, <code><a href="stats.html#topic+decompose">decompose</a></code>, <code>tbats</code>, <code>seasadj</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trainATA &lt;-  head(touristTR, 84)
testATA &lt;- window(touristTR, start = 2015, end = 2016.917)
ata_fit &lt;- ATA(trainATA, h=24, seasonal.test = TRUE, seasonal.model = "decomp")
ata_accuracy &lt;- ATA.Accuracy(ata_fit, testATA)

</code></pre>

<hr>
<h2 id='ATA.BackTransform'>Back Transformation Techniques for The ATAforecasting</h2><span id='topic+ATA.BackTransform'></span>

<h3>Description</h3>

<p>The function provides the applicability of different types of back transformation techniques for the transformed data to which the Ata method will be applied.
The <code>ATA.BackTransform</code> function works with many different types of inputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ATA.BackTransform(X, tMethod, tLambda, tShift, tbiasadj = FALSE, tfvar = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ATA.BackTransform_+3A_x">X</code></td>
<td>
<p>a numeric vector or time series of class <code>ts</code> or <code>msts</code> for in-sample.</p>
</td></tr>
<tr><td><code id="ATA.BackTransform_+3A_tmethod">tMethod</code></td>
<td>
<p>Box-Cox power transformation family is consist of &quot;Box_Cox&quot;, &quot;Sqrt&quot;, &quot;Reciprocal&quot;, &quot;Log&quot;, &quot;NegLog&quot;,
&quot;Modulus&quot;, &quot;BickelDoksum&quot;, &quot;Manly&quot;, &quot;Dual&quot;, &quot;YeoJohnson&quot;, &quot;GPower&quot;, &quot;GLog&quot; in ATAforecasting package.</p>
</td></tr>
<tr><td><code id="ATA.BackTransform_+3A_tlambda">tLambda</code></td>
<td>
<p>Box-Cox power transformation family parameter. If NULL, data transformed before model is estimated.</p>
</td></tr>
<tr><td><code id="ATA.BackTransform_+3A_tshift">tShift</code></td>
<td>
<p>Box-Cox power transformation family shifting parameter. If NULL, data transformed before model is estimated.</p>
</td></tr>
<tr><td><code id="ATA.BackTransform_+3A_tbiasadj">tbiasadj</code></td>
<td>
<p>Use adjusted back-transformed mean for Box-Cox transformations using <code>forecast::BoxCox</code>. If transformed data is used to produce forecasts and fitted values,
a regular back transformation will result in median forecasts. If tbiasadj is TRUE, an adjustment will be made to produce mean forecasts and fitted values.</p>
</td></tr>
<tr><td><code id="ATA.BackTransform_+3A_tfvar">tfvar</code></td>
<td>
<p>Optional parameter required if tbiasadj=TRUE. Can either be the forecast variance, or a list containing the interval <code>level</code>, and the
corresponding <code>upper</code> and <code>lower</code> intervals.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object consists of transformation parameters and transformed data.
<code>ATA.Transform</code> is a list containing at least the following elements:
</p>

<ul>
<li><p>trfmX   : Transformed data
</p>
</li>
<li><p>tLambda : Box-Cox power transformation family parameter
</p>
</li>
<li><p>tShift  : Box-Cox power transformation family shifting parameter
</p>
</li></ul>



<h3>References</h3>

<p>#'Tukey JW (1957).
&ldquo;On the Comparative Anatomy of Transformations.&rdquo;
<em>The Annals of Mathematical Statistics</em>, <b>28</b>(3), 602&ndash;632.
</p>
<p>#'Box GEP, Cox DR (1964).
&ldquo;An Analysis of Transformations.&rdquo;
<em>Journal of the Royal Statistical Society. Series B (Methodological)</em>, <b>26</b>(2), 211&ndash;252.
</p>
<p>#'Manly BFJ (1976).
&ldquo;Exponential data transformations.&rdquo;
<em>Journal of the Royal Statistical Society Series D</em>, <b>25</b>(1), 37&ndash;42.
</p>
<p>#'John JA, Draper NR (1980).
&ldquo;An alternative family of transformations.&rdquo;
<em>Journal of the Royal Statistical Society Series C</em>, <b>29</b>(2), 190&ndash;197.
</p>
<p>#'Bickel PJ, Doksum KA (1982).
&ldquo;An analysis of transformations revisited.&rdquo;
<em>Journal of the American Statistical Association</em>, <b>76</b>(374), 296&ndash;311.
</p>
<p>#'Sakia RM (1992).
&ldquo;The Box-Cox Transformation Technique: A Review.&rdquo;
<em>Journal of the Royal Statistical Society Series D</em>, <b>41</b>(2), 169&ndash;178.
</p>
<p>#'Guerrero VM (1993).
&ldquo;Time-series analysis supported by power transformations.&rdquo;
<em>Journal of Forecasting</em>, <b>12</b>(1), 37&ndash;48.
</p>
<p>#'Yeo I, Johnson RA (2000).
&ldquo;A New Family of Power Transformations to Improve Normality or Symmetry.&rdquo;
<em>Biometrika</em>, <b>87</b>(4), 954&ndash;959.
</p>
<p>#'Durbin BP, Hardin JS, Hawkins DM, Rocke DM (2002).
&ldquo;A variance-stabilizing transformation for gene-expression microarray data.&rdquo;
<em>Bioinformatics</em>, <b>18</b>(1), 105&ndash;110.
</p>
<p>#'Whittaker J, Whitehead C, Somers M (2005).
&ldquo;The neglog transformation and quantile regression for the analysis of a large credit scoring database.&rdquo;
<em>Journal of the Royal Statistical Society Series C</em>, <b>54</b>(4), 863&ndash;878.
</p>
<p>#'Yang Z (2005).
&ldquo;A modified family of power transformations.&rdquo;
<em>Economics Letters</em>, <b>92</b>(1), 14&ndash;19.
</p>
<p>#'Kelmansky DM, Martinez EJ, Leiva V (2013).
&ldquo;A new variance stabilizing transformation for gene expression data analysis.&rdquo;
<em>Statistical Applications in Genetics and Molecular Biology</em>, <b>12</b>(6), 653&ndash;666.
</p>

<hr>
<h2 id='ATA.BoxCoxAttr'>The ATA.BoxCoxAttr function works with many different types of inputs.</h2><span id='topic+ATA.BoxCoxAttr'></span>

<h3>Description</h3>

<p>The ATA.BoxCoxAttr function works with many different types of inputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ATA.BoxCoxAttr(
  bcMethod = "guerrero",
  bcLower = 0,
  bcUpper = 5,
  bcBiasAdj = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ATA.BoxCoxAttr_+3A_bcmethod">bcMethod</code></td>
<td>
<p>Choose method to be used in calculating lambda. &quot;guerrero&quot; (Guerrero, V.M. (1993) is default. Other method is &quot;loglik&quot;).</p>
</td></tr>
<tr><td><code id="ATA.BoxCoxAttr_+3A_bclower">bcLower</code></td>
<td>
<p>Lower limit for possible lambda values. The lower value is limited by -5. Default value is 0.</p>
</td></tr>
<tr><td><code id="ATA.BoxCoxAttr_+3A_bcupper">bcUpper</code></td>
<td>
<p>Upper limit for possible lambda values. The upper value is limited by 5. Default value is 5.</p>
</td></tr>
<tr><td><code id="ATA.BoxCoxAttr_+3A_bcbiasadj">bcBiasAdj</code></td>
<td>
<p>Use adjusted back-transformed mean for Box-Cox transformations.
If transformed data is used to produce forecasts and fitted values, a regular back transformation will result in median forecasts.
If bcBiasAdj is TRUE, an adjustment will be made to produce mean forecasts and fitted values.
If bcBiasAdj=TRUE. Can either be the forecast variance, or a list containing the interval <code>level</code>, the corresponding <code>upper</code> and <code>lower</code> intervals.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>ataoptim</code>.
</p>


<h3>Author(s)</h3>

<p>Ali Sabri Taylan and Hanife Taylan Selamlar
</p>


<h3>References</h3>

<p>#'Box GEP, Cox DR (1964).
&ldquo;An Analysis of Transformations.&rdquo;
<em>Journal of the Royal Statistical Society. Series B (Methodological)</em>, <b>26</b>(2), 211&ndash;252.
</p>
<p>#'Guerrero VM (1993).
&ldquo;Time-series analysis supported by power transformations.&rdquo;
<em>Journal of Forecasting</em>, <b>12</b>(1), 37&ndash;48.
</p>


<h3>See Also</h3>

<p><code><a href="forecast.html#topic+BoxCox">BoxCox</a></code>, <code><a href="forecast.html#topic+InvBoxCox">InvBoxCox</a></code>, <code><a href="forecast.html#topic+BoxCox.lambda">BoxCox.lambda</a></code>
</p>

<hr>
<h2 id='ATA.CI'>Confidence Interval function for the ATA Method</h2><span id='topic+ATA.CI'></span>

<h3>Description</h3>

<p>Confidence Interval function for the ATA Method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ATA.CI(object, ci.level = 95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ATA.CI_+3A_object">object</code></td>
<td>
<p>An <code>ATA</code> object is required.</p>
</td></tr>
<tr><td><code id="ATA.CI_+3A_ci.level">ci.level</code></td>
<td>
<p>Confidence level, for example: 90, 95 or 99.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The confidence interval output for the ATA forecasts
</p>

<hr>
<h2 id='ATA.Core'>The core algorithm of the ATA Method</h2><span id='topic+ATA.Core'></span>

<h3>Description</h3>

<p>The core algorithm of the ATA Method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ATA.Core(X, pk, qk, phik, mdlType, initialLevel, initialTrend)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ATA.Core_+3A_x">X</code></td>
<td>
<p>A numeric vector or time series.</p>
</td></tr>
<tr><td><code id="ATA.Core_+3A_pk">pk</code></td>
<td>
<p>Value of Level parameter.</p>
</td></tr>
<tr><td><code id="ATA.Core_+3A_qk">qk</code></td>
<td>
<p>Value of Trend parameter.</p>
</td></tr>
<tr><td><code id="ATA.Core_+3A_phik">phik</code></td>
<td>
<p>Value of Damping Trend parameter.</p>
</td></tr>
<tr><td><code id="ATA.Core_+3A_mdltype">mdlType</code></td>
<td>
<p>An one-character string identifying method using the framework terminology.</p>
</td></tr>
<tr><td><code id="ATA.Core_+3A_initiallevel">initialLevel</code></td>
<td>
<p>&quot;none&quot; is default,
</p>

<ul>
<li><p>none    : ATA Method calculates the pth observation in <code>X</code> for level.
</p>
</li>
<li><p>mean     : ATA Method calculates average of first p value in <code>X</code>for level.
</p>
</li>
<li><p>median: ATA Method calculates median of first p value in <code>X</code>for level.
</p>
</li></ul>
</td></tr>
<tr><td><code id="ATA.Core_+3A_initialtrend">initialTrend</code></td>
<td>
<p>&quot;none&quot; is default,
</p>

<ul>
<li><p>none    : ATA Method calculates the qth observation in <code>X</code> for trend.
</p>
</li>
<li><p>mean     : ATA Method calculates average of first q value in <code>X(T)-X(T-1)</code> for trend.
</p>
</li>
<li><p>median: ATA Method calculates median of first q value in <code>X(T)-X(T-1)</code> for trend.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class &quot;<code>ATA</code>&quot;
</p>

<hr>
<h2 id='ATA.Decomposition'>Seasonal Decomposition for The ATAforecasting</h2><span id='topic+ATA.Decomposition'></span>

<h3>Description</h3>

<p>Automatic seasonal decomposition for ATA Method is called <code>ATA.Decomposition</code> function in ATAforecasting package.
The function returns seasonally adjusted data constructed by removing the seasonal component. The methodology is fully automatic.
The <code>ATA.Decomposition</code> function works with many different types of inputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ATA.Decomposition(input, s.model, s.type, s.frequency, seas_attr_set)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ATA.Decomposition_+3A_input">input</code></td>
<td>
<p>It must be <code>ts</code> or <code>msts</code> or <code>numeric</code> object. if it is <code>numeric</code> object, <code>findPeriod</code> must be 1 or 2 or 3 or 4. if it is <code>msts</code> object, <code>findPeriod</code> must be 3 or 4.</p>
</td></tr>
<tr><td><code id="ATA.Decomposition_+3A_s.model">s.model</code></td>
<td>
<p>A string identifying method for seasonal decomposition. If NULL, &quot;decomp&quot; method is default. c(&quot;none&quot;, &quot;decomp&quot;, &quot;stl&quot;, &quot;stlplus&quot;, &quot;tbats&quot;, &quot;stR&quot;) phrases of methods denote.
</p>

<ul>
<li><p>none    : seasonal decomposition is not required.
</p>
</li>
<li><p>decomp     : classical seasonal decomposition. If <code>decomp</code>, the <code>stats</code> package will be used.
</p>
</li>
<li><p>stl        : seasonal-trend decomposition procedure based on loess developed by Cleveland et al. (1990). If <code>stl</code>, the <code>stats</code> and <code>forecast</code> packages will be used. Multiple seasonal periods are allowed.
</p>
</li>
<li><p>stlplus    : seasonal-trend decomposition procedure based on loess developed by Cleveland et al. (1990). If <code>stlplus</code>, the <code>stlplus</code> package will be used.
</p>
</li>
<li><p>tbats   : exponential smoothing state space model with Box&ndash;Cox transformation, ARMA errors, trend and seasonal components.
as described in De Livera, Hyndman &amp; Snyder (2011). Parallel processing is used by default to speed up the computations. If <code>tbats</code>, the <code>forecast</code> package will be used. Multiple seasonal periods are allowed.
</p>
</li>
<li><p>stR        : seasonal-trend decomposition procedure based on regression developed by Dokumentov and Hyndman (2015). If <code>stR</code>, the <code>stR</code> package will be used. Multiple seasonal periods are allowed.
</p>
</li>
<li><p>x13        : seasonal-trend decomposition procedure based on X13ARIMA/SEATS. If <code>x13</code>, the <code>seasonal</code> package will be used.
</p>
</li>
<li><p>x11        : seasonal-trend decomposition procedure based on X11. If <code>x11</code>, the <code>seasonal</code> package will be used.
</p>
</li></ul>
</td></tr>
<tr><td><code id="ATA.Decomposition_+3A_s.type">s.type</code></td>
<td>
<p>A one-character string identifying method for the seasonal component framework. If NULL, &quot;M&quot; is default. The letter &quot;A&quot; for additive model, the letter &quot;M&quot; for multiplicative model.</p>
</td></tr>
<tr><td><code id="ATA.Decomposition_+3A_s.frequency">s.frequency</code></td>
<td>
<p>Value(s) of seasonal periodicity. If <code>s.frequency</code> is not integer, <code>X</code> must be <code>msts</code> time series object. c(s1,s2,s3,...) for multiple period. If <code>X</code> has multiple periodicity, &quot;tbats&quot; or &quot;stR&quot; seasonal model have to be selected.</p>
</td></tr>
<tr><td><code id="ATA.Decomposition_+3A_seas_attr_set">seas_attr_set</code></td>
<td>
<p>Assign from <code>ATA.SeasAttr</code> function. Attributes set for unit root and seasonality tests.
For example: period of the input data which have one seasonal pattern &ndash;&gt; 12 for monthly / 4 for quarterly / 7 for daily / 5 for business days. periods of the input data which have complex/multiple seasonal patterns &ndash;&gt; c(7,354.37,365.25).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Seasonal components of the univariate time series.
<code>ATA.Decomposition</code> is a list containing at least the following elements:
</p>
<table>
<tr><td><code>AdjustedX</code></td>
<td>
<p>Deseasonalized data</p>
</td></tr>
<tr><td><code>SeasIndex</code></td>
<td>
<p>Particular weights of seasonality given cycle/frequency</p>
</td></tr>
<tr><td><code>SeasActual</code></td>
<td>
<p>Seasonality given original data</p>
</td></tr>
<tr><td><code>SeasType</code></td>
<td>
<p>Seasonal decomposition technique</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ali Sabri Taylan and Hanife Taylan Selamlar
</p>


<h3>References</h3>

<p>#'Shiskin J, Young AH, Musgrave JC (1967).
&ldquo;The X-11 Variant of the Census-II Method Seasonal Adjustment Program.&rdquo;
Technical Report 15, Bureau of the U.S. Census.
<a href="https://www.census.gov/content/dam/Census/library/working-papers/1967/adrm/shiskinyoungmusgrave1967.pdf">https://www.census.gov/content/dam/Census/library/working-papers/1967/adrm/shiskinyoungmusgrave1967.pdf</a>.
</p>
<p>#'Dagum EB (1999).
<em>X11ARIMA/2000 An Updated of The X11ARIMA/88 Seasonal Adjustment Method - Foundations and Users' Manual</em>.
Statistics Canada.
<a href="https://www.census.gov/content/dam/Census/library/working-papers/1999/adrm/emanual.pdf">https://www.census.gov/content/dam/Census/library/working-papers/1999/adrm/emanual.pdf</a>.
</p>
<p>#'Cleveland RB, Cleveland WS, McRae JE, Terpenning I (1990).
&ldquo;STL: A seasonal-trend decomposition procedure based on loess.&rdquo;
<em>Journal of Official Statistics</em>, <b>6</b>(1), 3&ndash;73.
</p>
<p>#'Hafen RP (2010).
<em>Local regression models: Advancements, applications, and new methods</em>.
Ph.D. thesis, Purdue University.
</p>
<p>#'Livera AMD, Hyndman RJ, Snyder RD (2011).
&ldquo;Forecasting Time Series With Complex Seasonal Patterns Using Exponential Smoothing.&rdquo;
<em>Journal of the American Statistical Association</em>, <b>106</b>(496), 1513&ndash;1527.
</p>
<p>#'Dokumentov A, Hyndman RJ (2015).
&ldquo;STR: A Seasonal-Trend Decomposition Procedure Based on Regression.&rdquo;
Monash Econometrics and Business Statistics Working Papers 13/15, Monash University, Department of Econometrics and Business Statistics.
<a href="https://EconPapers.repec.org/RePEc:msh:ebswps:2015-13">https://EconPapers.repec.org/RePEc:msh:ebswps:2015-13</a>.
</p>
<p>#'Dokumentov A, Hyndman RJ (2020).
&ldquo;STR: A Seasonal-Trend Decomposition Procedure Based on Regression.&rdquo;
2009.05894.
</p>
<p>#'Monsell BC, Aston JAD, Koopman SJ (2003).
&ldquo;Toward X-13?&rdquo;
United States Census Bureau.
<a href="https://www.census.gov/content/dam/Census/library/working-papers/2003/adrm/jsm2003bcm.pdf">https://www.census.gov/content/dam/Census/library/working-papers/2003/adrm/jsm2003bcm.pdf</a>.
</p>
<p>#'Monsell BC (2007).
&ldquo;The X-13A-S seasonal adjustment program.&rdquo;
In <em>Proceedings of the 2007 Federal Committee On Statistical Methodology Research Conference. URL http://www. fcsm. gov/07papers/Monsell. II-B. pdf</em>.
</p>
<p>#'Sax C, Eddelbuettel D (2018).
&ldquo;Seasonal Adjustment by X-13ARIMA-SEATS in R.&rdquo;
<em>Journal of Statistical Software</em>, <b>87</b>(11), 1&ndash;17.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+stl">stl</a></code>, <code><a href="stats.html#topic+decompose">decompose</a></code>, <code><a href="seasonal.html#topic+seas">seas</a></code>,
<code><a href="forecast.html#topic+tbats">tbats</a></code>, <code><a href="stlplus.html#topic+stlplus">stlplus</a></code>, <code><a href="stR.html#topic+AutoSTR">AutoSTR</a></code>.
</p>

<hr>
<h2 id='ATA.Forecast'>Forecasting Method for The ATAforecasting</h2><span id='topic+ATA.Forecast'></span>

<h3>Description</h3>

<p><code>ATA.Forecast</code> is a generic function for forecasting of the ATA Method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ATA.Forecast(
  object,
  h = NULL,
  out.sample = NULL,
  ci.level = 95,
  negative.forecast = TRUE,
  onestep = FALSE,
  print.out = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ATA.Forecast_+3A_object">object</code></td>
<td>
<p>An <code>ata</code> object is required for forecast.</p>
</td></tr>
<tr><td><code id="ATA.Forecast_+3A_h">h</code></td>
<td>
<p>Number of periods for forecasting.</p>
</td></tr>
<tr><td><code id="ATA.Forecast_+3A_out.sample">out.sample</code></td>
<td>
<p>A numeric vector or time series of class <code>ts</code> or <code>msts</code> for out-sample.</p>
</td></tr>
<tr><td><code id="ATA.Forecast_+3A_ci.level">ci.level</code></td>
<td>
<p>Confidence Interval levels for forecasting. Default value is 95.</p>
</td></tr>
<tr><td><code id="ATA.Forecast_+3A_negative.forecast">negative.forecast</code></td>
<td>
<p>Negative values are allowed for forecasting. Default value is TRUE. If FALSE, all negative values for forecasting are set to 0.</p>
</td></tr>
<tr><td><code id="ATA.Forecast_+3A_onestep">onestep</code></td>
<td>
<p>Default is FALSE. if TRUE, the dynamic forecast strategy uses a one-step model multiple times (<code>h</code> forecast horizon) where the prediction for the prior time step is used as an input for making a prediction on the following time step.</p>
</td></tr>
<tr><td><code id="ATA.Forecast_+3A_print.out">print.out</code></td>
<td>
<p>Default is TRUE. If FALSE, forecast summary of ATA Method is not shown.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>ata</code> and forecast values.
</p>


<h3>Author(s)</h3>

<p>Ali Sabri Taylan and Hanife Taylan Selamlar
</p>


<h3>References</h3>

<p>#'Yapar G, Yavuz I, Selamlar HT (2017).
&ldquo;Why and How Does Exponential Smoothing Fail? An In Depth Comparison of ATA-Simple and Simple Exponential Smoothing.&rdquo;
<em>Turkish Journal of Forecasting</em>, <b>1</b>(1), 30&ndash;39.
</p>
<p>#'Yapar G, Capar S, Selamlar HT, Yavuz I (2018).
&ldquo;Modified Holt's Linear Trend Method.&rdquo;
<em>Hacettepe University Journal of Mathematics and Statistics</em>, <b>47</b>(5), 1394&ndash;1403.
</p>
<p>#'Yapar G (2018).
&ldquo;Modified simple exponential smoothing.&rdquo;
<em>Hacettepe University Journal of Mathematics and Statistics</em>, <b>47</b>(3), 741&ndash;754.
</p>
<p>#'Yapar G, Selamlar HT, Capar S, Yavuz I (2019).
&ldquo;ATA method.&rdquo;
<em>Hacettepe Journal of Mathematics and Statistics</em>, <b>48</b>(6), 1838-1844.
</p>


<h3>See Also</h3>

<p><code>forecast</code>, <code>stlplus</code>, <code>stR</code>, <code><a href="stats.html#topic+stl">stl</a></code>, <code><a href="stats.html#topic+decompose">decompose</a></code>,
<code>tbats</code>, <code>seasadj</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trainATA &lt;-  head(touristTR, 84)
ata_fit &lt;- ATA(trainATA, parPHI = 1, seasonal.test = TRUE, seasonal.model = "decomp")
ata_fc &lt;- ATA.Forecast(ata_fit, h=12)

</code></pre>

<hr>
<h2 id='ATA.Plot'>Specialized Plot Function of The ATAforecasting</h2><span id='topic+ATA.Plot'></span>

<h3>Description</h3>

<p>Specialized Plot Function of The ATAforecasting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ATA.Plot(object, fcol = 4, flty = 2, flwd = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ATA.Plot_+3A_object">object</code></td>
<td>
<p>an object of <code>ata</code></p>
</td></tr>
<tr><td><code id="ATA.Plot_+3A_fcol">fcol</code></td>
<td>
<p>line color</p>
</td></tr>
<tr><td><code id="ATA.Plot_+3A_flty">flty</code></td>
<td>
<p>line type</p>
</td></tr>
<tr><td><code id="ATA.Plot_+3A_flwd">flwd</code></td>
<td>
<p>line width</p>
</td></tr>
<tr><td><code id="ATA.Plot_+3A_...">...</code></td>
<td>
<p>other inputs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a graphic output for the components of the ATAforecasting
</p>

<hr>
<h2 id='ATA.Print'>Specialized Screen Print Function of The ATAforecasting</h2><span id='topic+ATA.Print'></span>

<h3>Description</h3>

<p>Specialized Screen Print Function of The ATAforecasting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ATA.Print(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ATA.Print_+3A_object">object</code></td>
<td>
<p>an object of <code>ata</code></p>
</td></tr>
<tr><td><code id="ATA.Print_+3A_...">...</code></td>
<td>
<p>other inputs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a summary for the results of the ATAforecasting
</p>

<hr>
<h2 id='ATA.SeasAttr'>Attributes Set For Unit Root and Seasonality Tests</h2><span id='topic+ATA.SeasAttr'></span>

<h3>Description</h3>

<p>This function is a class of seasonality tests using  <code>corrgram.test</code> from ATAforecasting package, <code>ndiffs</code> and <code>nsdiffs</code> functions from forecast package.
Also, this function is modified version of <code>ndiffs</code> and <code>nsdiffs</code> written by Hyndman et al. <code>forecast</code> package.
Please review manual and vignette documents of latest <code>forecast</code> package. According to <code>forecast</code> package,
<code>ndiffs</code> and <code>nsdiffs</code> functions to estimate the number of differences required to make a given time series stationary.
<code>ndiffs</code> uses unit root tests to determine the number of differences required for time series to be made trend stationary. Several different tests are available:
</p>

<ul>
<li> <p>uroot.test = 'kpss'		: the KPSS test is used with the null hypothesis that <code>x</code> has a stationary root against a unit-root alternative. Then the test returns the least number of differences required to pass the test at the level <code>uroot.alpha</code>.
</p>
</li>
<li> <p>uroot.test = 'adf'		: the Augmented Dickey-Fuller test is used.
</p>
</li>
<li> <p>uroot.test = 'pp'		: the Phillips-Perron test is used. In both of these cases, the null hypothesis is that <code>x</code> has a unit root against a stationary root alternative. Then the test returns the least number of differences required to fail the test at the level <code>alpha</code>.
</p>
</li></ul>

<p><code>nsdiffs</code> uses seasonal unit root tests to determine the number of seasonal differences required for time series to be made stationary. Several different tests are available:
</p>

<ul>
<li> <p>suroot.test = 'seas'		: a measure of seasonal strength is used, where differencing is selected if the seasonal strength (Wang, Smith &amp; Hyndman, 2006) exceeds 0.64 (based on minimizing MASE when forecasting using auto.arima on M3 and M4 data).
</p>
</li>
<li> <p>suroot.test = 'ch'			: the Canova-Hansen (1995) test is used (with null hypothesis of deterministic seasonality)
</p>
</li>
<li> <p>suroot.test = 'hegy'		: the Hylleberg, Engle, Granger &amp; Yoo (1990) test is used.
</p>
</li>
<li> <p>suroot.test = 'ocsb'		: the Osborn-Chui-Smith-Birchenhall (1988) test is used (with null hypothesis that a seasonal unit root exists).
</p>
</li>
<li> <p>suroot.test = 'correlogram'	: this function is written based on M4 Competition Seasonality Test.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>ATA.SeasAttr(
  corrgram.tcrit = 1.28,
  uroot.test = "adf",
  suroot.test = "correlogram",
  suroot.uroot = TRUE,
  uroot.type = "level",
  uroot.alpha = 0.05,
  suroot.alpha = 0.05,
  uroot.maxd = 2,
  suroot.maxD = 1,
  suroot.m = NULL,
  uroot.pkg = "tseries",
  multi.period = "min",
  x13.estimate.maxiter = 1500,
  x13.estimate.tol = 1e-05,
  x11.estimate.maxiter = 1500,
  x11.estimate.tol = 1e-05
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ATA.SeasAttr_+3A_corrgram.tcrit">corrgram.tcrit</code></td>
<td>
<p>t-value for autocorrelogram.</p>
</td></tr>
<tr><td><code id="ATA.SeasAttr_+3A_uroot.test">uroot.test</code></td>
<td>
<p>Type of unit root test before all type seasonality test. Possible values are &quot;adf&quot;, &quot;pp&quot; and &quot;kpss&quot;.</p>
</td></tr>
<tr><td><code id="ATA.SeasAttr_+3A_suroot.test">suroot.test</code></td>
<td>
<p>Type of seasonal unit root test to use. Possible values are &quot;correlogram&quot;, &quot;seas&quot;, &quot;hegy&quot;, &quot;ch&quot; and &quot;ocsb&quot;.</p>
</td></tr>
<tr><td><code id="ATA.SeasAttr_+3A_suroot.uroot">suroot.uroot</code></td>
<td>
<p>If TRUE, unit root test for stationary before seasonal unit root test is allowed.</p>
</td></tr>
<tr><td><code id="ATA.SeasAttr_+3A_uroot.type">uroot.type</code></td>
<td>
<p>Specification of the deterministic component in the regression for unit root test. Possible values are &quot;level&quot; and &quot;trend&quot;.</p>
</td></tr>
<tr><td><code id="ATA.SeasAttr_+3A_uroot.alpha">uroot.alpha</code></td>
<td>
<p>Significant level of the unit root test, possible values range from 0.01 to 0.1.</p>
</td></tr>
<tr><td><code id="ATA.SeasAttr_+3A_suroot.alpha">suroot.alpha</code></td>
<td>
<p>Significant level of the seasonal unit root test, possible values range from 0.01 to 0.1</p>
</td></tr>
<tr><td><code id="ATA.SeasAttr_+3A_uroot.maxd">uroot.maxd</code></td>
<td>
<p>Maximum number of non-seasonal differences allowed.</p>
</td></tr>
<tr><td><code id="ATA.SeasAttr_+3A_suroot.maxd">suroot.maxD</code></td>
<td>
<p>Maximum number of seasonal differences allowed.</p>
</td></tr>
<tr><td><code id="ATA.SeasAttr_+3A_suroot.m">suroot.m</code></td>
<td>
<p>Deprecated. Length of seasonal period: frequency of data for nsdiffs.</p>
</td></tr>
<tr><td><code id="ATA.SeasAttr_+3A_uroot.pkg">uroot.pkg</code></td>
<td>
<p>Using <code>urca</code> or <code>tseries</code> packages for unit root test. The default value is &quot;urca&quot;.</p>
</td></tr>
<tr><td><code id="ATA.SeasAttr_+3A_multi.period">multi.period</code></td>
<td>
<p>Selection type of multi seasonal period. <code>min</code> or <code>max</code> function for selection</p>
</td></tr>
<tr><td><code id="ATA.SeasAttr_+3A_x13.estimate.maxiter">x13.estimate.maxiter</code></td>
<td>
<p>Maximum iteration for X13ARIMA/SEATS estimation</p>
</td></tr>
<tr><td><code id="ATA.SeasAttr_+3A_x13.estimate.tol">x13.estimate.tol</code></td>
<td>
<p>Convergence tolerence for X13ARIMA/SEATS estimation</p>
</td></tr>
<tr><td><code id="ATA.SeasAttr_+3A_x11.estimate.maxiter">x11.estimate.maxiter</code></td>
<td>
<p>Maximum iteration for X11 estimation</p>
</td></tr>
<tr><td><code id="ATA.SeasAttr_+3A_x11.estimate.tol">x11.estimate.tol</code></td>
<td>
<p>Convergence tolerence for X11 estimation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>ataoptim</code>.
</p>


<h3>Author(s)</h3>

<p>Ali Sabri Taylan and Hanife Taylan Selamlar
</p>


<h3>See Also</h3>

<p><code>forecast</code>, <code>stlplus</code>, <code>stR</code>, <code><a href="stats.html#topic+stl">stl</a></code>, <code><a href="stats.html#topic+decompose">decompose</a></code>, <code>tbats</code>, <code>seasadj</code>.
</p>

<hr>
<h2 id='ATA.Seasonality'>Seasonality Tests for The ATAforecasting</h2><span id='topic+ATA.Seasonality'></span>

<h3>Description</h3>

<p>This function is a class of seasonality tests using  <code>corrgram_test</code> from ATAforecasting package, <code>ndiffs</code> and <code>nsdiffs</code> functions from forecast package.
Also, this function is modified version of <code>ndiffs</code> and <code>nsdiffs</code> written by Hyndman et al. <code>forecast</code> package.
Please review manual and vignette documents of latest <code>forecast</code> package. According to <code>forecast</code> package,
<code>ndiffs</code> and <code>nsdiffs</code> functions to estimate the number of differences required to make a given time series stationary.
<code>ndiffs</code> uses unit root tests to determine the number of differences required for time series to be made trend stationary. Several different tests are available:
</p>

<ul>
<li> <p>uroot.test = 'kpss'			: the KPSS test is used with the null hypothesis that <code>x</code> has a stationary root against a unit-root alternative. Then the test returns the least number of differences required to pass the test at the level <code>uroot.alpha</code>.
</p>
</li>
<li> <p>uroot.test = 'adf'			: the Augmented Dickey-Fuller test is used.
</p>
</li>
<li> <p>uroot.test = 'pp'			: the Phillips-Perron test is used. In both of these cases, the null hypothesis is that <code>x</code> has a unit root against a stationary root alternative. Then the test returns the least number of differences required to fail the test at the level <code>uroot.alpha</code>.
</p>
</li></ul>

<p><code>nsdiffs</code> uses seasonal unit root tests to determine the number of seasonal differences required for time series to be made stationary. Several different tests are available:
</p>

<ul>
<li> <p>suroot.test = 'seas'		: a measure of seasonal strength is used, where differencing is selected if the seasonal strength (Wang, Smith &amp; Hyndman, 2006) exceeds 0.64 (based on minimizing MASE when forecasting using auto.arima on M3 and M4 data).
</p>
</li>
<li> <p>suroot.test = 'ch'			: the Canova-Hansen (1995) test is used (with null hypothesis of deterministic seasonality)
</p>
</li>
<li> <p>suroot.test = 'hegy'		: the Hylleberg, Engle, Granger &amp; Yoo (1990) test is used.
</p>
</li>
<li> <p>suroot.test = 'ocsb'		: the Osborn-Chui-Smith-Birchenhall (1988) test is used (with null hypothesis that a seasonal unit root exists).
</p>
</li>
<li> <p>suroot.test = 'correlogram'	: this function is written based on M4 Competition Seasonality Test.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>ATA.Seasonality(input, ppy, attr_set)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ATA.Seasonality_+3A_input">input</code></td>
<td>
<p>The data.</p>
</td></tr>
<tr><td><code id="ATA.Seasonality_+3A_ppy">ppy</code></td>
<td>
<p>Frequency of the data.</p>
</td></tr>
<tr><td><code id="ATA.Seasonality_+3A_attr_set">attr_set</code></td>
<td>
<p>Assign from <code>ATA.SeasAttr</code> function. Attributes set for unit root, seasonality tests.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if the serie has seasonality. Otherwise, <code>FALSE</code>.
</p>


<h3>Author(s)</h3>

<p>Ali Sabri Taylan and Hanife Taylan Selamlar
</p>


<h3>References</h3>

<p>#'Dickey DA, Fuller WA (1979).
&ldquo;Distribution of the Estimators for Autoregressive Time Series With a Unit Root.&rdquo;
<em>Journal of the American Statistical Association</em>, <b>74</b>(366), 427&ndash;431.
</p>
<p>#'Said SE, Dickey DA (1984).
&ldquo;Testing for Unit Roots in Autoregressive-Moving Average Models of Unknown Order.&rdquo;
<em>Biometrika</em>, <b>71</b>(3), 599&ndash;607.
</p>
<p>#'Dickey DA, Hasza DP, Fuller WA (1984).
&ldquo;Testing for Unit Roots in Seasonal Time Series.&rdquo;
<em>Journal of the American Statistical Association</em>, <b>79</b>(386), 355&ndash;367.
</p>
<p>#'Phillips PCB, Perron P (1988).
&ldquo;Testing for a Unit Root in Time Series Regression.&rdquo;
<em>Biometrika</em>, <b>75</b>(2), 335&ndash;346.
</p>
<p>#'Osborn DR, Chui APL, Smith J, Birchenhall CR (1988).
&ldquo;Seasonality and the order of integration for consumption.&rdquo;
<em>Oxford Bulletin of Economics and Statistics</em>, <b>50</b>(4), 361&ndash;377.
</p>
<p>#'Hylleberg S, Engle RF, Granger CWJ, Yoo BS (1990).
&ldquo;Seasonal integration and cointegration.&rdquo;
<em>Journal of Econometrics</em>, <b>1344</b>(1), 215&ndash;238.
</p>
<p>#'Kwiatkowski D, Phillips P, Schmidt P, Shin Y (1992).
&ldquo;Testing the null hypothesis of stationarity against the alternative of a unit root: How sure are we that economic time series have a unit root?&rdquo;
<em>Journal of Econometrics</em>, <b>54</b>(1&ndash;3), 159&ndash;178.
</p>
<p>#'Canova F, Hansen BE (1995).
&ldquo;Are Seasonal Patterns Constant over Time? A Test for Seasonal Stability.&rdquo;
<em>Journal of Business and Economic Statistics</em>, <b>13</b>(3), 237&ndash;252.
</p>
<p>#'Wang X, Smith KA, Hyndman RJ (2006).
&ldquo;Characteristic-based clustering for time series data.&rdquo;
<em>Data Mining and Knowledge Discovery</em>, <b>13</b>(3), 335&ndash;364.
</p>


<h3>See Also</h3>

<p><code>forecast</code>, <code>urca</code>, <code>tseries</code>, <code>uroot</code>, <code>stlplus</code>, <code>stR</code>,
<code><a href="stats.html#topic+stl">stl</a></code>, <code><a href="stats.html#topic+decompose">decompose</a></code>, <code>tbats</code>, <code>seasadj</code>.
</p>

<hr>
<h2 id='ATA.Shift'>Lag/Lead (Shift) Function for Univariate Series</h2><span id='topic+ATA.Shift'></span>

<h3>Description</h3>

<p>Lag/Lead (Shift) Function for Univariate Series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ATA.Shift(x, shift_by, fill = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ATA.Shift_+3A_x">x</code></td>
<td>
<p>given vector</p>
</td></tr>
<tr><td><code id="ATA.Shift_+3A_shift_by">shift_by</code></td>
<td>
<p>lag or lead parameter</p>
</td></tr>
<tr><td><code id="ATA.Shift_+3A_fill">fill</code></td>
<td>
<p>a value to be used to fill the rows</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Generating a lag/lead variables
</p>

<hr>
<h2 id='ATA.Shift_Mat'>Lag/Lead (Shift) Function for Multivariate Series</h2><span id='topic+ATA.Shift_Mat'></span>

<h3>Description</h3>

<p>Lag/Lead (Shift) Function for Multivariate Series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ATA.Shift_Mat(X, direction = "down", shift_by = 1, fill = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ATA.Shift_Mat_+3A_x">X</code></td>
<td>
<p>given matrice</p>
</td></tr>
<tr><td><code id="ATA.Shift_Mat_+3A_direction">direction</code></td>
<td>
<p>direction of shifting. Default is &quot;down&quot;.</p>
</td></tr>
<tr><td><code id="ATA.Shift_Mat_+3A_shift_by">shift_by</code></td>
<td>
<p>number of rows to be shifed upwards/downwards</p>
</td></tr>
<tr><td><code id="ATA.Shift_Mat_+3A_fill">fill</code></td>
<td>
<p>a value to be used to fill the rows</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Generating a lag/lead matrice
</p>

<hr>
<h2 id='ATA.Transform'>Transformation Techniques for The ATAforecasting</h2><span id='topic+ATA.Transform'></span>

<h3>Description</h3>

<p>The function provides the applicability of different types of transformation techniques for the data to which the Ata method will be applied.
The <code>ATA.Transform</code> function works with many different types of inputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ATA.Transform(
  X,
  tMethod = c("Box_Cox", "Sqrt", "Reciprocal", "Log", "NegLog", "Modulus",
    "BickelDoksum", "Manly", "Dual", "YeoJohnson", "GPower", "GLog"),
  tLambda,
  tShift = 0,
  bcMethod = c("loglik", "guerrero"),
  bcLower = 0,
  bcUpper = 5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ATA.Transform_+3A_x">X</code></td>
<td>
<p>a numeric vector or time series of class <code>ts</code> or <code>msts</code> for in-sample.</p>
</td></tr>
<tr><td><code id="ATA.Transform_+3A_tmethod">tMethod</code></td>
<td>
<p>Box-Cox power transformation family is consist of &quot;Box_Cox&quot;, &quot;Sqrt&quot;, &quot;Reciprocal&quot;, &quot;Log&quot;, &quot;NegLog&quot;,
&quot;Modulus&quot;, &quot;BickelDoksum&quot;, &quot;Manly&quot;, &quot;Dual&quot;, &quot;YeoJohnson&quot;, &quot;GPower&quot;, &quot;GLog&quot; in ATAforecasting package. If the transformation process needs shift parameter,
<code>ATA.Transform</code> will calculate required shift parameter automatically.</p>
</td></tr>
<tr><td><code id="ATA.Transform_+3A_tlambda">tLambda</code></td>
<td>
<p>Box-Cox power transformation family parameter. Default is NULL. When lambda is set as NULL, required &quot;lambda&quot; parameter will be calculated automatically based on &quot;bcMethod, bcLower, and bcUpper&quot;.</p>
</td></tr>
<tr><td><code id="ATA.Transform_+3A_tshift">tShift</code></td>
<td>
<p>Box-Cox power transformation family shifting parameter. Default is 0. When &quot;transform.method&quot; is selected, required shifting parameter will be calculated automatically according to dataset.</p>
</td></tr>
<tr><td><code id="ATA.Transform_+3A_bcmethod">bcMethod</code></td>
<td>
<p>Choose method to be used in calculating lambda. &quot;loglik&quot; is default. Other method is &quot;guerrero&quot; (Guerrero, V.M. (1993)).</p>
</td></tr>
<tr><td><code id="ATA.Transform_+3A_bclower">bcLower</code></td>
<td>
<p>Lower limit for possible lambda values. The lower value is limited by -5. Default value is 0.</p>
</td></tr>
<tr><td><code id="ATA.Transform_+3A_bcupper">bcUpper</code></td>
<td>
<p>Upper limit for possible lambda values. The upper value is limited by 5. Default value is 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object consists of transformation parameters and transformed data.
<code>ATA.Transform</code> is a list containing at least the following elements:
</p>

<ul>
<li><p>trfmX   : Transformed data
</p>
</li>
<li><p>tLambda : Box-Cox power transformation family parameter
</p>
</li>
<li><p>tShift  : Box-Cox power transformation family shifting parameter
</p>
</li></ul>



<h3>References</h3>

<p>#'Tukey JW (1957).
&ldquo;On the Comparative Anatomy of Transformations.&rdquo;
<em>The Annals of Mathematical Statistics</em>, <b>28</b>(3), 602&ndash;632.
</p>
<p>#'Box GEP, Cox DR (1964).
&ldquo;An Analysis of Transformations.&rdquo;
<em>Journal of the Royal Statistical Society. Series B (Methodological)</em>, <b>26</b>(2), 211&ndash;252.
</p>
<p>#'Manly BFJ (1976).
&ldquo;Exponential data transformations.&rdquo;
<em>Journal of the Royal Statistical Society Series D</em>, <b>25</b>(1), 37&ndash;42.
</p>
<p>#'John JA, Draper NR (1980).
&ldquo;An alternative family of transformations.&rdquo;
<em>Journal of the Royal Statistical Society Series C</em>, <b>29</b>(2), 190&ndash;197.
</p>
<p>#'Bickel PJ, Doksum KA (1982).
&ldquo;An analysis of transformations revisited.&rdquo;
<em>Journal of the American Statistical Association</em>, <b>76</b>(374), 296&ndash;311.
</p>
<p>#'Sakia RM (1992).
&ldquo;The Box-Cox Transformation Technique: A Review.&rdquo;
<em>Journal of the Royal Statistical Society Series D</em>, <b>41</b>(2), 169&ndash;178.
</p>
<p>#'Guerrero VM (1993).
&ldquo;Time-series analysis supported by power transformations.&rdquo;
<em>Journal of Forecasting</em>, <b>12</b>(1), 37&ndash;48.
</p>
<p>#'Yeo I, Johnson RA (2000).
&ldquo;A New Family of Power Transformations to Improve Normality or Symmetry.&rdquo;
<em>Biometrika</em>, <b>87</b>(4), 954&ndash;959.
</p>
<p>#'Durbin BP, Hardin JS, Hawkins DM, Rocke DM (2002).
&ldquo;A variance-stabilizing transformation for gene-expression microarray data.&rdquo;
<em>Bioinformatics</em>, <b>18</b>(1), 105&ndash;110.
</p>
<p>#'Whittaker J, Whitehead C, Somers M (2005).
&ldquo;The neglog transformation and quantile regression for the analysis of a large credit scoring database.&rdquo;
<em>Journal of the Royal Statistical Society Series C</em>, <b>54</b>(4), 863&ndash;878.
</p>
<p>#'Yang Z (2005).
&ldquo;A modified family of power transformations.&rdquo;
<em>Economics Letters</em>, <b>92</b>(1), 14&ndash;19.
</p>
<p>#'Kelmansky DM, Martinez EJ, Leiva V (2013).
&ldquo;A new variance stabilizing transformation for gene expression data analysis.&rdquo;
<em>Statistical Applications in Genetics and Molecular Biology</em>, <b>12</b>(6), 653&ndash;666.
</p>

<hr>
<h2 id='ATAforecasting-package'>ATAforecasting: Automatic Time Series Analysis and Forecasting using Ata Method with Box-Cox Power Transformations Family and Seasonal Decomposition Techniques</h2><span id='topic+ATAforecasting-package'></span><span id='topic+ATAforecasting'></span>

<h3>Description</h3>

<p>Returns ATA(p,q,phi)(E,T,S) applied to the data.
The Ata method based on the modified simple exponential smoothing as described in Yapar, G. (2016) &lt;doi:10.15672/HJMS.201614320580&gt; ,
Yapar G., Capar, S., Selamlar, H. T., Yavuz, I. (2017) &lt;doi:10.15672/HJMS.2017.493&gt; and Yapar G., Selamlar, H. T., Capar, S., Yavuz, I. (2019)
&lt;doi:10.15672/hujms.461032&gt; is a new univariate time series forecasting method which provides innovative solutions to issues faced during
the initialization and optimization stages of existing methods.
Forecasting performance of the Ata method is superior to existing methods both in terms of easy implementation and accurate forecasting.
It can be applied to non-seasonal or seasonal time series which can be decomposed into four components (remainder, level, trend and seasonal).
This methodology performed well on the M3 and M4-competition data.
Returns ATA(p,q,phi) (E,T,S) applied to the data.
</p>
<p>The Ata method (Yapar et al. (2019) <a href="https://doi.org/10.15672/hujms.461032">doi:10.15672/hujms.461032</a>), an alternative to exponential smoothing (described in Yapar (2016) <a href="https://doi.org/10.15672/HJMS.201614320580">doi:10.15672/HJMS.201614320580</a>, Yapar et al. (2017) <a href="https://doi.org/10.15672/HJMS.2017.493">doi:10.15672/HJMS.2017.493</a>), is a new univariate time series forecasting method which provides innovative solutions to issues faced during the initialization and optimization stages of existing forecasting methods. Forecasting performance of the Ata method is superior to existing methods both in terms of easy implementation and accurate forecasting. It can be applied to non-seasonal or seasonal time series which can be decomposed into four components (remainder, level, trend and seasonal). This methodology performed well on the M3 and M4-competition data. This package was written based on Ali Sabri Taylanâ€™s PhD dissertation.
</p>


<h3>Author(s)</h3>

<p>Ali Sabri Taylan and Hanife Taylan Selamlar
</p>
<p>Maintainer: alisabritaylan@gmail.com
</p>
<p><strong>Maintainer</strong>: Ali Sabri Taylan <a href="mailto:alisabritaylan@gmail.com">alisabritaylan@gmail.com</a> (<a href="https://orcid.org/0000-0001-9514-934X">ORCID</a>) [copyright holder]
</p>
<p>Authors:
</p>

<ul>
<li><p> Hanife Taylan Selamlar (<a href="https://orcid.org/0000-0002-4091-884X">ORCID</a>) [copyright holder]
</p>
</li>
<li><p> Guckan Yapar (<a href="https://orcid.org/0000-0002-0971-6676">ORCID</a>) [thesis advisor, copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/alsabtay/ATAforecasting">https://github.com/alsabtay/ATAforecasting</a>
</p>
</li>
<li> <p><a href="https://atamethod.wordpress.com/">https://atamethod.wordpress.com/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/alsabtay/ATAforecasting/issues">https://github.com/alsabtay/ATAforecasting/issues</a>
</p>
</li></ul>


<hr>
<h2 id='find.freq'>Find Frequency Using Spectral Density Of A Time Series From AR Fit</h2><span id='topic+find.freq'></span>

<h3>Description</h3>

<p>Find Frequency Using Spectral Density Of A Time Series From AR Fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find.freq(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find.freq_+3A_x">x</code></td>
<td>
<p>an univariate time series</p>
</td></tr>
</table>


<h3>Value</h3>

<p>frequency/cycle of the given time data
</p>

<hr>
<h2 id='find.freq.fourier'>Find Frequency Using Periodogram</h2><span id='topic+find.freq.fourier'></span>

<h3>Description</h3>

<p>Find Frequency Using Periodogram
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find.freq.fourier(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find.freq.fourier_+3A_x">x</code></td>
<td>
<p>an univariate time series</p>
</td></tr>
</table>


<h3>Value</h3>

<p>frequency/cycle of the given data
</p>

<hr>
<h2 id='find.multi.freq'>Find Multi Frequency Using Spectral Density Of A Time Series From AR Fit</h2><span id='topic+find.multi.freq'></span>

<h3>Description</h3>

<p>Find Multi Frequency Using Spectral Density Of A Time Series From AR Fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find.multi.freq(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find.multi.freq_+3A_x">x</code></td>
<td>
<p>an univariate time series</p>
</td></tr>
</table>


<h3>Value</h3>

<p>multi frequencies/cycles of the given data
</p>

<hr>
<h2 id='fundingTR'>Weekly Net Funding Level of Central Bank of Republic of Turkey</h2><span id='topic+fundingTR'></span>

<h3>Description</h3>

<p>Weekly Net Funding Level of Central Bank of Republic of Turkey:  from Jan 7, 2011 to Jan 08, 2021.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fundingTR)
</code></pre>


<h3>Format</h3>

<p>Time series data
</p>


<h3>Source</h3>

<p>The Central Bank of the Republic of Turkey &ndash; CBRT.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(fundingTR)

</code></pre>

<hr>
<h2 id='touristTR'>Monthly number of tourists arrived in Turkey</h2><span id='topic+touristTR'></span>

<h3>Description</h3>

<p>Monthly number of tourists arrived in Turkey: from Jan 2008 to Dec 2020.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(touristTR)
</code></pre>


<h3>Format</h3>

<p>Time series data
</p>


<h3>Source</h3>

<p>The Central Bank of the Republic of Turkey &ndash; CBRT.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(touristTR)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
