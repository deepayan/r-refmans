<!DOCTYPE html><html><head><title>Help for package varitas</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {varitas}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add.option'><p>add.option</p></a></li>
<li><a href='#alternate.gene.sort'><p>alternate.gene.sort</p></a></li>
<li><a href='#build.variant.specification'><p>build.variant.specification</p></a></li>
<li><a href='#caller.overlap.venn.diagram'><p>. Make Venn diagram of variant caller overlap</p></a></li>
<li><a href='#capitalize.caller'><p>capitalize.caller</p></a></li>
<li><a href='#classify.variant'><p>classify.variant</p></a></li>
<li><a href='#convert.ides.output'><p>Convert output of iDES step 1 to variant call format</p></a></li>
<li><a href='#create.directories'><p>create.directories</p></a></li>
<li><a href='#date.stamp.file.name'><p>date.stamp.file.name</p></a></li>
<li><a href='#extract.sample.ids'><p>Extract sample IDs from file paths</p></a></li>
<li><a href='#filter.variant.file'><p>Filter variants in file.</p></a></li>
<li><a href='#filter.variants'><p>Filter variant calls</p></a></li>
<li><a href='#fix.lofreq.af'><p>fix.lofreq.af</p></a></li>
<li><a href='#fix.names'><p>Fix variant call column names</p></a></li>
<li><a href='#fix.varscan.af'><p>fix.varscan.af</p></a></li>
<li><a href='#get.base.substitution'><p>Get base substitution</p></a></li>
<li><a href='#get.bed.chromosomes'><p>get.bed.chromosomes</p></a></li>
<li><a href='#get.buildver'><p>get.buildver</p></a></li>
<li><a href='#get.colours'><p>Generate a colour scheme</p></a></li>
<li><a href='#get.coverage.by.amplicon'><p>Process sample coverage per amplicon data</p></a></li>
<li><a href='#get.coverage.by.sample.statistics'><p>Get statistics about coverage per sample</p></a></li>
<li><a href='#get.fasta.chromosomes'><p>get.fasta.chromosomes</p></a></li>
<li><a href='#get.file.path'><p>get.file.path</p></a></li>
<li><a href='#get.filters'><p>get.filters</p></a></li>
<li><a href='#get.gene'><p>get.gene</p></a></li>
<li><a href='#get.miniseq.sample.files'><p>get.miniseq.sample.files</p></a></li>
<li><a href='#get.option'><p>Helper function to recursively get an VariTAS option</p></a></li>
<li><a href='#get.panel.coverage.by.gene'><p>Summarise panel coverage by gene</p></a></li>
<li><a href='#get.pool.from.panel.data'><p>Get pool corresponding to each amplicon</p></a></li>
<li><a href='#get.varitas.options'><p>Return VariTAS settings</p></a></li>
<li><a href='#get.vcf.chromosomes'><p>get.vcf.chromosomes</p></a></li>
<li><a href='#in.varitas.options'><p>Check if a key is in VariTAS options</p></a></li>
<li><a href='#logical.to.character'><p>logical.to.character</p></a></li>
<li><a href='#make.command.line.call'><p>Make string with command line call from its individual components</p></a></li>
<li><a href='#mean.field.value'><p>mean.field.value</p></a></li>
<li><a href='#merge.ides.annotation'><p>Merge potential iDES calls with variant annotation.</p></a></li>
<li><a href='#merge.variants'><p>Merge variants</p></a></li>
<li><a href='#overwrite.varitas.options'><p>overwrite.varitas.options</p></a></li>
<li><a href='#parse.job.dependencies'><p>Parse job dependencies</p></a></li>
<li><a href='#plot.amplicon.coverage.per.sample'><p>plot.amplicon.coverage.per.sample</p></a></li>
<li><a href='#plot.coverage.by.genome.order'><p>Plot amplicon coverage by genome order</p></a></li>
<li><a href='#plot.coverage.by.sample'><p>plot.coverage.by.sample</p></a></li>
<li><a href='#plot.ontarget.percent'><p>plot.ontarget.percent</p></a></li>
<li><a href='#plot.paired.percent'><p>plot.paired.percent</p></a></li>
<li><a href='#post.processing'><p>Post-processing of variants to generate outputs</p></a></li>
<li><a href='#prepare.bam.specification'><p>Prepare BAM specification data frame to standardized format for downstream analyses.</p></a></li>
<li><a href='#prepare.fastq.specification'><p>prepare.fastq.specification</p></a></li>
<li><a href='#prepare.miniseq.specifications'><p>prepare.miniseq.specifications</p></a></li>
<li><a href='#prepare.vcf.specification'><p>prepare.vcf.specification</p></a></li>
<li><a href='#process.coverage.reports'><p>Process coverageBed reports</p></a></li>
<li><a href='#process.sample.contamination.checks'><p>Process sample contamination checks</p></a></li>
<li><a href='#process.total.coverage.statistics'><p>Process total coverage statistics</p></a></li>
<li><a href='#read.all.calls'><p>read.all.calls</p></a></li>
<li><a href='#read.ides.file'><p>Read iDES output</p></a></li>
<li><a href='#read.variant.calls'><p>Read variant calls from file and format for ease of downstream analyses.</p></a></li>
<li><a href='#read.yaml'><p>read.yaml</p></a></li>
<li><a href='#run.alignment'><p>Run alignment</p></a></li>
<li><a href='#run.alignment.sample'><p>Run alignment for a single sample</p></a></li>
<li><a href='#run.all.scripts'><p>Run all the generated bash scripts without HPC commands</p></a></li>
<li><a href='#run.annotation'><p>Run annotation on a set of VCF files</p></a></li>
<li><a href='#run.annovar.vcf'><p>Run ANNOVAR on a VCF file</p></a></li>
<li><a href='#run.filtering.txt'><p>Run filtering on an ANNOVAR-annotated txt file</p></a></li>
<li><a href='#run.ides'><p>Run iDES</p></a></li>
<li><a href='#run.lofreq.sample'><p>Run LoFreq for a sample</p></a></li>
<li><a href='#run.muse.sample'><p>Run MuSE for a sample</p></a></li>
<li><a href='#run.mutect.sample'><p>Run MuTect for a sample</p></a></li>
<li><a href='#run.post.processing'><p>run.post.processing</p></a></li>
<li><a href='#run.target.qc'><p>Perform sample QC by looking at target coverage.</p></a></li>
<li><a href='#run.target.qc.sample'><p>Get ontarget reads and run coverage quality control</p></a></li>
<li><a href='#run.vardict.sample'><p>run.vardict.sample</p></a></li>
<li><a href='#run.variant.calling'><p>run.variant.calling</p></a></li>
<li><a href='#run.varitas.pipeline'><p>Run VariTAS pipeline in full.</p></a></li>
<li><a href='#run.varitas.pipeline.hybrid'><p>run.varitas.pipeline.hybrid</p></a></li>
<li><a href='#run.varscan.sample'><p>Run VarScan for a sample</p></a></li>
<li><a href='#save.config'><p>save.config</p></a></li>
<li><a href='#save.coverage.excel'><p>Save coverage statistics to multi-worksheet Excel file.</p></a></li>
<li><a href='#save.variants.excel'><p>Save variants to Excel.</p></a></li>
<li><a href='#set.varitas.options'><p>Set options for varitas pipeline.</p></a></li>
<li><a href='#split.on.column'><p>split.on.column</p></a></li>
<li><a href='#sum.dp4'><p>sum.dp4</p></a></li>
<li><a href='#system.ls'><p>Run ls command</p></a></li>
<li><a href='#tabular.mean'><p>tabular.mean</p></a></li>
<li><a href='#tabular.median'><p>tabular.median</p></a></li>
<li><a href='#trinucleotide.barplot'><p>Make barplot of trinucleotide substitutions</p></a></li>
<li><a href='#variant.recurrence.barplot'><p>Make barplot of variants per caller</p></a></li>
<li><a href='#variants.caller.barplot'><p>Make barplot of variants per caller</p></a></li>
<li><a href='#variants.sample.barplot'><p>Make barplot of variants per sample</p></a></li>
<li><a href='#verify.bam.specification'><p>Check that sample specification data frame matches expected format, and that all files exist</p></a></li>
<li><a href='#verify.bwa.index'><p>verify.bwa.index</p></a></li>
<li><a href='#verify.fasta.index'><p>verify.fasta.index</p></a></li>
<li><a href='#verify.fastq.specification'><p>Check that FASTQ specification data frame matches expected format, and that all files exist</p></a></li>
<li><a href='#verify.sequence.dictionary'><p>verify.sequence.dictionary</p></a></li>
<li><a href='#verify.varitas.options'><p>Check against common errors in the VariTAS options.</p></a></li>
<li><a href='#verify.vcf.specification'><p>verify.vcf.specification</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Variant Calling in Targeted Analysis Sequencing Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-11-03</td>
</tr>
<tr>
<td>Description:</td>
<td>Multi-caller variant analysis pipeline for targeted analysis sequencing (TAS) data. Features a modular, automated workflow that can start with raw reads and produces a user-friendly PDF summary and a spreadsheet containing consensus variant information.</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>perl, bedtools (&gt;=2.27.1), bwa</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, futile.logger</td>
</tr>
<tr>
<td>Imports:</td>
<td>stringr, dplyr, yaml, openxlsx, VennDiagram, assertthat,
magrittr, tools, utils, tidyr, doParallel, foreach</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-11-03 14:25:11 UTC; amills</td>
</tr>
<tr>
<td>Author:</td>
<td>Adam Mills [aut, cre],
  Erle Holgersen [aut],
  Ros Cutts [aut],
  Syed Haider [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Adam Mills &lt;Adam.Mills@icr.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-11-14 00:30:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='add.option'>add.option</h2><span id='topic+add.option'></span>

<h3>Description</h3>

<p>Add option to nested list of options. Applied recursively
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.option(name, value, old.options, nesting.character = "\\.")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.option_+3A_name">name</code></td>
<td>
<p>Option name. Nesting is indicated by character specified in nesting.character.</p>
</td></tr>
<tr><td><code id="add.option_+3A_value">value</code></td>
<td>
<p>New value of option</p>
</td></tr>
<tr><td><code id="add.option_+3A_old.options">old.options</code></td>
<td>
<p>Nested list the option should be added to</p>
</td></tr>
<tr><td><code id="add.option_+3A_nesting.character">nesting.character</code></td>
<td>
<p>String giving Regex pattern of nesting indication string. Defaults to '\.'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nested list with updated options
</p>

<hr>
<h2 id='alternate.gene.sort'>alternate.gene.sort</h2><span id='topic+alternate.gene.sort'></span>

<h3>Description</h3>

<p>Given a data frame containing coverage statistics and gene information, returns that frame
with the rows sorted by alternating gene size (for plotting)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alternate.gene.sort(coverage.statistics)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alternate.gene.sort_+3A_coverage.statistics">coverage.statistics</code></td>
<td>
<p>Data frame of coverage statistics</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Genes have varying numbers of associated amplicons and when plotting coverage statistics, 
if two genes with very low numbers of amplicons are next to each other, the labels will overlap.
This function sorts the coverage statistics data frame in a way that places the genes
with the most amplicons (largest) next to those with the least (smallest).
</p>


<h3>Value</h3>

<p>Coverage statistics data frame sorted by alternating gene size
</p>

<hr>
<h2 id='build.variant.specification'>build.variant.specification</h2><span id='topic+build.variant.specification'></span>

<h3>Description</h3>

<p>Build data frame with paths to variant files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build.variant.specification(sample.ids, project.directory)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build.variant.specification_+3A_sample.ids">sample.ids</code></td>
<td>
<p>Vector of sample IDs. Must match subdirectories in project.directory.</p>
</td></tr>
<tr><td><code id="build.variant.specification_+3A_project.directory">project.directory</code></td>
<td>
<p>Path to directory where sample subdirectories</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Parses through sample IDs in a project directory and returns paths to variant files based on
(theoretical) file name patterns. Useful for testing, or for entering the pipeline at non-traditional stages.
</p>


<h3>Value</h3>

<p>Data frame with paths to variant files.
</p>

<hr>
<h2 id='caller.overlap.venn.diagram'>. Make Venn diagram of variant caller overlap</h2><span id='topic+caller.overlap.venn.diagram'></span>

<h3>Description</h3>

<p>. Make Venn diagram of variant caller overlap
</p>


<h3>Usage</h3>

<pre><code class='language-R'>caller.overlap.venn.diagram(variants, file.name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="caller.overlap.venn.diagram_+3A_variants">variants</code></td>
<td>
<p>Data frame containing variants, typically from merge.variants function</p>
</td></tr>
<tr><td><code id="caller.overlap.venn.diagram_+3A_file.name">file.name</code></td>
<td>
<p>Name of output file</p>
</td></tr>
</table>

<hr>
<h2 id='capitalize.caller'>capitalize.caller</h2><span id='topic+capitalize.caller'></span><span id='topic+capitalise.caller'></span>

<h3>Description</h3>

<p>Capitalize variant caller name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>capitalize.caller(caller)

capitalise.caller(caller)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="capitalize.caller_+3A_caller">caller</code></td>
<td>
<p>Character vector of callers to be capitalized</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of same length as caller where eligible callers have been capitalized
</p>

<hr>
<h2 id='classify.variant'>classify.variant</h2><span id='topic+classify.variant'></span>

<h3>Description</h3>

<p>Classify a variant as SNV, MNV, or indel based on the reference and alternative alleles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classify.variant(ref, alt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="classify.variant_+3A_ref">ref</code></td>
<td>
<p>Vector of reference bases</p>
</td></tr>
<tr><td><code id="classify.variant_+3A_alt">alt</code></td>
<td>
<p>Vector of alternate bases</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector giving type of variant.
</p>

<hr>
<h2 id='convert.ides.output'>Convert output of iDES step 1 to variant call format</h2><span id='topic+convert.ides.output'></span>

<h3>Description</h3>

<p>Convert output of iDES step 1 to variant call format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert.ides.output(filename, output = TRUE,
  output.suffix = ".calls.txt", minreads = 5, mindepth = 50)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert.ides.output_+3A_filename">filename</code></td>
<td>
<p>Path to file</p>
</td></tr>
<tr><td><code id="convert.ides.output_+3A_output">output</code></td>
<td>
<p>Logical indicating whether output should be saved to file. Defaults to true.</p>
</td></tr>
<tr><td><code id="convert.ides.output_+3A_output.suffix">output.suffix</code></td>
<td>
<p>Suffix to be appended to input filename if saving results to file</p>
</td></tr>
<tr><td><code id="convert.ides.output_+3A_minreads">minreads</code></td>
<td>
<p>Minimum numbers of reads</p>
</td></tr>
<tr><td><code id="convert.ides.output_+3A_mindepth">mindepth</code></td>
<td>
<p>Minimum depth</p>
</td></tr>
</table>


<h3>Value</h3>

<p>potential.calls Data frame of converted iDES calls
</p>

<hr>
<h2 id='create.directories'>create.directories</h2><span id='topic+create.directories'></span>

<h3>Description</h3>

<p>Create directories in a given path
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create.directories(directory.names, path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create.directories_+3A_directory.names">directory.names</code></td>
<td>
<p>Vector of names of directories to be created</p>
</td></tr>
<tr><td><code id="create.directories_+3A_path">path</code></td>
<td>
<p>Path where directories should be created</p>
</td></tr>
</table>

<hr>
<h2 id='date.stamp.file.name'>date.stamp.file.name</h2><span id='topic+date.stamp.file.name'></span><span id='topic+datestamp.file.name'></span><span id='topic+datestamp.filename'></span>

<h3>Description</h3>

<p>Prefix file name with a date-stamp.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date.stamp.file.name(file.name, date = Sys.Date(), separator = "_")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="date.stamp.file.name_+3A_file.name">file.name</code></td>
<td>
<p>File name to be date-stamped</p>
</td></tr>
<tr><td><code id="date.stamp.file.name_+3A_date">date</code></td>
<td>
<p>Date to be added. Defaults to current date.</p>
</td></tr>
<tr><td><code id="date.stamp.file.name_+3A_separator">separator</code></td>
<td>
<p>String that should separate the date from the file name. Defaults to a single underscore.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>String giving the datestamped file name
</p>


<h3>Examples</h3>

<pre><code class='language-R'>date.stamp.file.name('plot.png');
date.stamp.file.name('yesterdays_plot.png', date = Sys.Date() - 1);

</code></pre>

<hr>
<h2 id='extract.sample.ids'>Extract sample IDs from file paths</h2><span id='topic+extract.sample.ids'></span>

<h3>Description</h3>

<p>Extract sample IDs from a set of paths to files in sample-specific subfolders
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract.sample.ids(paths, from.filename = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract.sample.ids_+3A_paths">paths</code></td>
<td>
<p>vector of file paths</p>
</td></tr>
<tr><td><code id="extract.sample.ids_+3A_from.filename">from.filename</code></td>
<td>
<p>Logical indicating whether sample ID should be extracted from filename rather than path</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of extracted sample IDs
</p>

<hr>
<h2 id='filter.variant.file'>Filter variants in file.</h2><span id='topic+filter.variant.file'></span>

<h3>Description</h3>

<p>Filter variants from file, and save to output. Wrapper function that opens the 
variant file, calls filter.variants, and saves the result to file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter.variant.file(variant.file, output.file, config.file = NULL,
  caller = c("vardict", "ides", "mutect", "pgm", "consensus"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter.variant.file_+3A_variant.file">variant.file</code></td>
<td>
<p>Path to variant file</p>
</td></tr>
<tr><td><code id="filter.variant.file_+3A_output.file">output.file</code></td>
<td>
<p>Path to output file</p>
</td></tr>
<tr><td><code id="filter.variant.file_+3A_config.file">config.file</code></td>
<td>
<p>Path to config file to be used. If not supplied, will use the pre-existing VariTAS options.</p>
</td></tr>
<tr><td><code id="filter.variant.file_+3A_caller">caller</code></td>
<td>
<p>Name of caller used (needed to match appropriate filters from settings)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='filter.variants'>Filter variant calls</h2><span id='topic+filter.variants'></span>

<h3>Description</h3>

<p>Filter data frame of variant calls based on thresholds specified in settings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter.variants(variants, caller = c("vardict", "ides", "mutect", "pgm",
  "consensus", "isis", "varscan", "lofreq"), config.file = NULL,
  verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter.variants_+3A_variants">variants</code></td>
<td>
<p>Data frame of variant calls with ANNOVAR annotation, or path to variant file.</p>
</td></tr>
<tr><td><code id="filter.variants_+3A_caller">caller</code></td>
<td>
<p>Name of caller used (needed to match appropriate filters from settings)</p>
</td></tr>
<tr><td><code id="filter.variants_+3A_config.file">config.file</code></td>
<td>
<p>Path to config file to be used. If not supplied, will use the pre-existing VariTAS options.</p>
</td></tr>
<tr><td><code id="filter.variants_+3A_verbose">verbose</code></td>
<td>
<p>Logical indicating whether to output descriptions of filtering steps. Defaults to False, useful for debugging.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>filtered.variants Data frame of filtered variants
</p>

<hr>
<h2 id='fix.lofreq.af'>fix.lofreq.af</h2><span id='topic+fix.lofreq.af'></span>

<h3>Description</h3>

<p>LoFreq also does not output allele frequencies, so this script calculates them from the
DP (depth) and AD (variant allele depth) values&ndash;which are also not output nicely&ndash;
and adds them to the annotated vcf.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fix.lofreq.af(variant.specification)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fix.lofreq.af_+3A_variant.specification">variant.specification</code></td>
<td>
<p>Data frame of variant file information</p>
</td></tr>
</table>

<hr>
<h2 id='fix.names'>Fix variant call column names</h2><span id='topic+fix.names'></span>

<h3>Description</h3>

<p>Fix headers of variant calls to prepare for merging. This mostly 
consists in making sure the column headers will be unique by prefixing
the variant caller in question.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fix.names(column.names, variant.caller, sample.id = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fix.names_+3A_column.names">column.names</code></td>
<td>
<p>Character vector of column names</p>
</td></tr>
<tr><td><code id="fix.names_+3A_variant.caller">variant.caller</code></td>
<td>
<p>String giving name of variant caller</p>
</td></tr>
<tr><td><code id="fix.names_+3A_sample.id">sample.id</code></td>
<td>
<p>Optional sample ID. Used to fix headers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>new.column.names Vector of column names after fixing]
</p>

<hr>
<h2 id='fix.varscan.af'>fix.varscan.af</h2><span id='topic+fix.varscan.af'></span>

<h3>Description</h3>

<p>VarScan does not output allele frequencies, so this script calculates them from the
DP (depth) and AD (variant allele depth) values and adds them to the annotated vcf.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fix.varscan.af(variant.specification)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fix.varscan.af_+3A_variant.specification">variant.specification</code></td>
<td>
<p>Data frame of variant file information</p>
</td></tr>
</table>

<hr>
<h2 id='get.base.substitution'>Get base substitution</h2><span id='topic+get.base.substitution'></span>

<h3>Description</h3>

<p>Get base substitution represented by pyrimidine in base pair. 
If more than one base in REF/ALT (i.e. MNV or indel rather than SNV), NA will be returned
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.base.substitution(ref, alt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.base.substitution_+3A_ref">ref</code></td>
<td>
<p>Vector of reference bases</p>
</td></tr>
<tr><td><code id="get.base.substitution_+3A_alt">alt</code></td>
<td>
<p>Vector of alternate bases</p>
</td></tr>
</table>


<h3>Value</h3>

<p>base.substitutions
</p>

<hr>
<h2 id='get.bed.chromosomes'>get.bed.chromosomes</h2><span id='topic+get.bed.chromosomes'></span>

<h3>Description</h3>

<p>Extract chromosomes from bed file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.bed.chromosomes(bed)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.bed.chromosomes_+3A_bed">bed</code></td>
<td>
<p>Path to BED file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector containing all chromosomes in BED file
</p>

<hr>
<h2 id='get.buildver'>get.buildver</h2><span id='topic+get.buildver'></span>

<h3>Description</h3>

<p>Get build version (hg19/hg38) based on settings.
</p>
<p>Parses VariTAS pipeline settings to get the build version. When this function was first developed, the idea was to
be able to explicitly set ANNOVAR filenames based on the build version.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.buildver()
</code></pre>


<h3>Value</h3>

<p>String giving reference genome build version (hg19 or hg38)
</p>

<hr>
<h2 id='get.colours'>Generate a colour scheme</h2><span id='topic+get.colours'></span>

<h3>Description</h3>

<p>Generate a colour scheme
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.colours(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.colours_+3A_n">n</code></td>
<td>
<p>Number of colours desired</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Colour.scheme generated colours
</p>

<hr>
<h2 id='get.coverage.by.amplicon'>Process sample coverage per amplicon data</h2><span id='topic+get.coverage.by.amplicon'></span>

<h3>Description</h3>

<p>Parse coverageBed output to get coverage by amplicon
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.coverage.by.amplicon(project.directory)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.coverage.by.amplicon_+3A_project.directory">project.directory</code></td>
<td>
<p>Path to project directory. Each sample should have its own subdirectory</p>
</td></tr>
</table>


<h3>Value</h3>

<p>combined.data Data frame giving coverage per amplicon per sample.
</p>


<h3>References</h3>

<p><a href="http://bedtools.readthedocs.io/en/latest/content/tools/coverage.html">http://bedtools.readthedocs.io/en/latest/content/tools/coverage.html</a>
</p>

<hr>
<h2 id='get.coverage.by.sample.statistics'>Get statistics about coverage per sample</h2><span id='topic+get.coverage.by.sample.statistics'></span>

<h3>Description</h3>

<p>Get statistics about coverage per sample
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.coverage.by.sample.statistics(project.directory)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.coverage.by.sample.statistics_+3A_project.directory">project.directory</code></td>
<td>
<p>Path to project directory. Each sample should have its own subdirectory</p>
</td></tr>
</table>


<h3>Value</h3>

<p>coverage.by.sample.statistics Data frame with coverage statistics per sample
</p>

<hr>
<h2 id='get.fasta.chromosomes'>get.fasta.chromosomes</h2><span id='topic+get.fasta.chromosomes'></span>

<h3>Description</h3>

<p>Extract chromosomes from fasta headers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.fasta.chromosomes(fasta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.fasta.chromosomes_+3A_fasta">fasta</code></td>
<td>
<p>Path to reference fasta</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector containing all chromosomes in fasta file.
</p>

<hr>
<h2 id='get.file.path'>get.file.path</h2><span id='topic+get.file.path'></span>

<h3>Description</h3>

<p>Get absolute path to sample-specific file for one or more samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.file.path(sample.ids, directory, extension = NULL,
  allow.multiple = FALSE, allow.none = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.file.path_+3A_sample.ids">sample.ids</code></td>
<td>
<p>Vector of sample IDs to match filename on</p>
</td></tr>
<tr><td><code id="get.file.path_+3A_directory">directory</code></td>
<td>
<p>Path to directory containing files</p>
</td></tr>
<tr><td><code id="get.file.path_+3A_extension">extension</code></td>
<td>
<p>String giving extension of file</p>
</td></tr>
<tr><td><code id="get.file.path_+3A_allow.multiple">allow.multiple</code></td>
<td>
<p>Boolean indicating whether to allow multiple matching files. 
Defaults to false, which throws an error if the query matches more than one file.</p>
</td></tr>
<tr><td><code id="get.file.path_+3A_allow.none">allow.none</code></td>
<td>
<p>Boolean indicating whether to allow no matching files. 
Defaults to false, which throws an error if the query does not match any files.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Paths to matched files
</p>

<hr>
<h2 id='get.filters'>get.filters</h2><span id='topic+get.filters'></span>

<h3>Description</h3>

<p>Determine filters per caller, given default and caller-specific values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.filters(filters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.filters_+3A_filters">filters</code></td>
<td>
<p>List of filter values. These will be updated to use default as the baseline, 
with caller-specific filters taking precedence if supplied.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with updated filters
</p>

<hr>
<h2 id='get.gene'>get.gene</h2><span id='topic+get.gene'></span>

<h3>Description</h3>

<p>Use guesswork to extract gene from data frame of targeted panel data. The panel
designer output can change, so try to guess what the format is.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.gene(bed.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.gene_+3A_bed.data">bed.data</code></td>
<td>
<p>Data frame containing data from bed file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of gene names, one entry for each row of <code>bed.data</code>
</p>

<hr>
<h2 id='get.miniseq.sample.files'>get.miniseq.sample.files</h2><span id='topic+get.miniseq.sample.files'></span>

<h3>Description</h3>

<p>Get files for a sample in a directory, ensuring there's only a single match per sample ID.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.miniseq.sample.files(sample.ids, directory,
  file.suffix = "_S\\d{1,2}_.*")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.miniseq.sample.files_+3A_sample.ids">sample.ids</code></td>
<td>
<p>Vector of sample ids. Should form first part of file name</p>
</td></tr>
<tr><td><code id="get.miniseq.sample.files_+3A_directory">directory</code></td>
<td>
<p>Directory where files can be found</p>
</td></tr>
<tr><td><code id="get.miniseq.sample.files_+3A_file.suffix">file.suffix</code></td>
<td>
<p>Regex expression for end of file name. For example, &lsquo;file.suffix = &rsquo;_S\d1,2_.*_R1_.*'' will match R1 files.1 files.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector of file paths
</p>

<hr>
<h2 id='get.option'>Helper function to recursively get an VariTAS option</h2><span id='topic+get.option'></span>

<h3>Description</h3>

<p>Helper function to recursively get an VariTAS option
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.option(name, varitas.options = NULL, nesting.character = "\\.")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.option_+3A_name">name</code></td>
<td>
<p>Option name</p>
</td></tr>
<tr><td><code id="get.option_+3A_varitas.options">varitas.options</code></td>
<td>
<p>Optional list of options to search in</p>
</td></tr>
<tr><td><code id="get.option_+3A_nesting.character">nesting.character</code></td>
<td>
<p>String giving Regex pattern of nesting indication string. Defaults to '\.'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>value Requested option
</p>

<hr>
<h2 id='get.panel.coverage.by.gene'>Summarise panel coverage by gene</h2><span id='topic+get.panel.coverage.by.gene'></span>

<h3>Description</h3>

<p>Summarise panel coverage by gene
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.panel.coverage.by.gene(panel.file, gene.col = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.panel.coverage.by.gene_+3A_panel.file">panel.file</code></td>
<td>
<p>path to panel</p>
</td></tr>
<tr><td><code id="get.panel.coverage.by.gene_+3A_gene.col">gene.col</code></td>
<td>
<p>index of column containing gene name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>panel.coverage.by.gene data frame giving the number of amplicons and their total length by gene
</p>

<hr>
<h2 id='get.pool.from.panel.data'>Get pool corresponding to each amplicon</h2><span id='topic+get.pool.from.panel.data'></span>

<h3>Description</h3>

<p>The bed files are not consistent, so it's not clear where the pool will appear. 
This function parses through the columns to identify where the pool
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.pool.from.panel.data(panel.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.pool.from.panel.data_+3A_panel.data">panel.data</code></td>
<td>
<p>data frame pool should be extracted from</p>
</td></tr>
</table>


<h3>Value</h3>

<p>pools vector of pool information
</p>

<hr>
<h2 id='get.varitas.options'>Return VariTAS settings</h2><span id='topic+get.varitas.options'></span>

<h3>Description</h3>

<p>Return VariTAS settings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.varitas.options(option.name = NULL, nesting.character = "\\.")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.varitas.options_+3A_option.name">option.name</code></td>
<td>
<p>Optional name of option. If no name is supplied, the full list of VariTAS options will be provided.</p>
</td></tr>
<tr><td><code id="get.varitas.options_+3A_nesting.character">nesting.character</code></td>
<td>
<p>String giving Regex pattern of nesting indication string. Defaults to '\.'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>varitas.options list specifying VariTAS options
</p>


<h3>Examples</h3>

<pre><code class='language-R'>reference.build &lt;- get.varitas.options('reference_build');
mutect.filters &lt;- get.varitas.options('filters.mutect');

</code></pre>

<hr>
<h2 id='get.vcf.chromosomes'>get.vcf.chromosomes</h2><span id='topic+get.vcf.chromosomes'></span>

<h3>Description</h3>

<p>Extract chromosomes from a VCF file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.vcf.chromosomes(vcf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.vcf.chromosomes_+3A_vcf">vcf</code></td>
<td>
<p>Path to VCF file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector containing all chromosomes in VCF
</p>

<hr>
<h2 id='in.varitas.options'>Check if a key is in VariTAS options</h2><span id='topic+in.varitas.options'></span>

<h3>Description</h3>

<p>Check if a key is in VariTAS options
</p>


<h3>Usage</h3>

<pre><code class='language-R'>in.varitas.options(option.name = NULL, varitas.options = NULL,
  nesting.character = "\\.")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="in.varitas.options_+3A_option.name">option.name</code></td>
<td>
<p>String giving name of option (with different levels joined by <code>nesting.character</code>)</p>
</td></tr>
<tr><td><code id="in.varitas.options_+3A_varitas.options">varitas.options</code></td>
<td>
<p>Ampliseq options as a list. If missing, they will be obtained from <code>get.varitas.options()</code></p>
</td></tr>
<tr><td><code id="in.varitas.options_+3A_nesting.character">nesting.character</code></td>
<td>
<p>String giving Regex pattern of nesting indication string. Defaults to '\.'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>in.options Boolean indicating if the option name exists in the current varitas options
</p>

<hr>
<h2 id='logical.to.character'>logical.to.character</h2><span id='topic+logical.to.character'></span>

<h3>Description</h3>

<p>Convert a logical vector to a T/F coded character vector. Useful for preventing unwanted T-&gt;TRUE nucleotide conversions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logical.to.character(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logical.to.character_+3A_x">x</code></td>
<td>
<p>Vector to be converted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector after converting TRUE/FALSE
</p>

<hr>
<h2 id='make.command.line.call'>Make string with command line call from its individual components</h2><span id='topic+make.command.line.call'></span>

<h3>Description</h3>

<p>Make string with command line call from its individual components
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.command.line.call(main.command, options = NULL, flags = NULL,
  option.prefix = "--", option.separator = " ", flag.prefix = "--")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.command.line.call_+3A_main.command">main.command</code></td>
<td>
<p>String or vector of strings giving main part of command (e.g. &quot;python test.py&quot; or c(&quot;python&quot;, &quot;test.py&quot;))</p>
</td></tr>
<tr><td><code id="make.command.line.call_+3A_options">options</code></td>
<td>
<p>Named vector or list giving options</p>
</td></tr>
<tr><td><code id="make.command.line.call_+3A_flags">flags</code></td>
<td>
<p>Vector giving flags to include.</p>
</td></tr>
<tr><td><code id="make.command.line.call_+3A_option.prefix">option.prefix</code></td>
<td>
<p>String to preface all options. Defaults to &quot;&ndash;&quot;</p>
</td></tr>
<tr><td><code id="make.command.line.call_+3A_option.separator">option.separator</code></td>
<td>
<p>String to separate options form their values. Defaults to a single space.</p>
</td></tr>
<tr><td><code id="make.command.line.call_+3A_flag.prefix">flag.prefix</code></td>
<td>
<p>String to preface all flags. Defaults to &quot;&ndash;&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>command string giving command line call
</p>

<hr>
<h2 id='mean.field.value'>mean.field.value</h2><span id='topic+mean.field.value'></span>

<h3>Description</h3>

<p>Get mean value of a variant annotation field
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'field.value'
mean(variants, field = c("TUMOUR.DP", "NORMAL.DP",
  "NORMAL.AF", "TUMOUR.AF", "QUAL"), caller = c("consensus", "vardict",
  "pgm", "mutect", "isis", "varscan", "lofreq"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean.field.value_+3A_variants">variants</code></td>
<td>
<p>Data frame with variants</p>
</td></tr>
<tr><td><code id="mean.field.value_+3A_field">field</code></td>
<td>
<p>String giving field of interest.</p>
</td></tr>
<tr><td><code id="mean.field.value_+3A_caller">caller</code></td>
<td>
<p>String giving caller to calculate values from</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As part of the variant merging process, annotated variant data frames are merged into 
one, with the value from each caller prefixed by CALLER. For example, the VarDict normal allele 
freqeuncy will have header VARDICT.NORMAL.AF. This function takes the average of all callers' value 
for a given field, removing NA's. If only a single caller is present in the data frame, that value is returned.
</p>


<h3>Value</h3>

<p>Vector of mean values.
</p>

<hr>
<h2 id='merge.ides.annotation'>Merge potential iDES calls with variant annotation.</h2><span id='topic+merge.ides.annotation'></span>

<h3>Description</h3>

<p>Merge potential iDES calls with variant annotation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ides.annotation'
merge(ides.filename, output = TRUE,
  output.suffix = ".ann.txt",
  annovar.suffix.pattern = ".annovar.hg(\\d{2})_multianno.txt")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge.ides.annotation_+3A_ides.filename">ides.filename</code></td>
<td>
<p>Path to formatted iDES output (typically from convert.ides.output file)</p>
</td></tr>
<tr><td><code id="merge.ides.annotation_+3A_output">output</code></td>
<td>
<p>Logical indicating whether output should be saved to file. Defaults to true.</p>
</td></tr>
<tr><td><code id="merge.ides.annotation_+3A_output.suffix">output.suffix</code></td>
<td>
<p>Suffix to be appended to input filename if saving results to file</p>
</td></tr>
<tr><td><code id="merge.ides.annotation_+3A_annovar.suffix.pattern">annovar.suffix.pattern</code></td>
<td>
<p>Suffix to match ANNOAR file</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The VarDict variant calling includes a GATK call merging the call vcf file (allele frequency information etc.) with
the ANNOVAR annotation, and saving the result as a table. This function is an attempt to emulate that step 
for the iDES calls.
</p>


<h3>Value</h3>

<p>annotated.calls Data frame of annotations and iDES output.
</p>

<hr>
<h2 id='merge.variants'>Merge variants</h2><span id='topic+merge.variants'></span>

<h3>Description</h3>

<p>Merge variants from multiple callers and return a data frame of merged calls. By default filtering
is also applied, although this behaviour can be turned off by setting apply.filters to FALSE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'variants'
merge(variant.specification, apply.filters = TRUE,
  remove.structural.variants = TRUE,
  separate.consensus.filters = FALSE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge.variants_+3A_variant.specification">variant.specification</code></td>
<td>
<p>Data frame containing details of file paths, sample IDs, and caller.</p>
</td></tr>
<tr><td><code id="merge.variants_+3A_apply.filters">apply.filters</code></td>
<td>
<p>Logical indicating whether to apply filters. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="merge.variants_+3A_remove.structural.variants">remove.structural.variants</code></td>
<td>
<p>Logical indicating whether structural variants (including CNVs) should be removed. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="merge.variants_+3A_separate.consensus.filters">separate.consensus.filters</code></td>
<td>
<p>Logical indicating whether to apply different thresholds to variants called by more than one caller 
(specified under consensus in config file). Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="merge.variants_+3A_verbose">verbose</code></td>
<td>
<p>Logical indicating whether to print information to screen</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame
</p>

<hr>
<h2 id='overwrite.varitas.options'>overwrite.varitas.options</h2><span id='topic+overwrite.varitas.options'></span>

<h3>Description</h3>

<p>Overwrite VariTAS options with options provided in config file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overwrite.varitas.options(config.file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="overwrite.varitas.options_+3A_config.file">config.file</code></td>
<td>
<p>Path to config file that should be used to overwrite options</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
config &lt;- file.path(path.package('varitas'), 'config.yaml')
overwrite.varitas.options(config)

## End(Not run)

</code></pre>

<hr>
<h2 id='parse.job.dependencies'>Parse job dependencies</h2><span id='topic+parse.job.dependencies'></span>

<h3>Description</h3>

<p>Parse job dependencies to make the functions more robust to alternate inputs (e.g. people writing alignment instead of bwa)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse.job.dependencies(dependencies)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse.job.dependencies_+3A_dependencies">dependencies</code></td>
<td>
<p>Job dependency strings to be parsed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>parsed.dependencies Vector of job dependencies after reformatting.
</p>

<hr>
<h2 id='plot.amplicon.coverage.per.sample'>plot.amplicon.coverage.per.sample</h2><span id='topic+plot.amplicon.coverage.per.sample'></span>

<h3>Description</h3>

<p>Create one scatterplot per sample, showing coverage per amplicon, and an additional plot giving the median
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'amplicon.coverage.per.sample'
plot(coverage.statistics,
  output.directory)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.amplicon.coverage.per.sample_+3A_coverage.statistics">coverage.statistics</code></td>
<td>
<p>Data frame containing coverage per amplicon per sample, typically from <code>get.coverage.by.amplicon</code>.</p>
</td></tr>
<tr><td><code id="plot.amplicon.coverage.per.sample_+3A_output.directory">output.directory</code></td>
<td>
<p>Directory where per sample plots should be saved</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='plot.coverage.by.genome.order'>Plot amplicon coverage by genome order</h2><span id='topic+plot.coverage.by.genome.order'></span>

<h3>Description</h3>

<p>Use values obtained by bedtools coverage to make a plot of coverage by genome order
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coverage.by.genome.order'
plot(coverage.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.coverage.by.genome.order_+3A_coverage.data">coverage.data</code></td>
<td>
<p>data frame with results from bedtools coverage command</p>
</td></tr>
</table>

<hr>
<h2 id='plot.coverage.by.sample'>plot.coverage.by.sample</h2><span id='topic+plot.coverage.by.sample'></span>

<h3>Description</h3>

<p>Make a barplot of coverage per sample
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coverage.by.sample'
plot(coverage.sample, file.name,
  statistic = c("mean", "median"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.coverage.by.sample_+3A_coverage.sample">coverage.sample</code></td>
<td>
<p>Data frame of coverage data, typically from <code>get.coverage.by.sample.statistics</code></p>
</td></tr>
<tr><td><code id="plot.coverage.by.sample_+3A_file.name">file.name</code></td>
<td>
<p>Name of output file</p>
</td></tr>
<tr><td><code id="plot.coverage.by.sample_+3A_statistic">statistic</code></td>
<td>
<p>Statistic to be plotted (mean or median)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='plot.ontarget.percent'>plot.ontarget.percent</h2><span id='topic+plot.ontarget.percent'></span>

<h3>Description</h3>

<p>Make a scatterplot of ontarget percent per sample
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ontarget.percent'
plot(coverage.sample, file.name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ontarget.percent_+3A_coverage.sample">coverage.sample</code></td>
<td>
<p>Data frame of coverage data, typically from <code>get.coverage.by.sample.statistics</code></p>
</td></tr>
<tr><td><code id="plot.ontarget.percent_+3A_file.name">file.name</code></td>
<td>
<p>Name of output file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='plot.paired.percent'>plot.paired.percent</h2><span id='topic+plot.paired.percent'></span>

<h3>Description</h3>

<p>Make a barplot of percent paired reads per sample
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'paired.percent'
plot(coverage.sample, file.name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.paired.percent_+3A_coverage.sample">coverage.sample</code></td>
<td>
<p>Data frame of coverage data, typically from <code>get.coverage.by.sample.statistics</code></p>
</td></tr>
<tr><td><code id="plot.paired.percent_+3A_file.name">file.name</code></td>
<td>
<p>Name of output file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='post.processing'>Post-processing of variants to generate outputs</h2><span id='topic+post.processing'></span>

<h3>Description</h3>

<p>Post-processing of variants to generate outputs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>post.processing(variant.specification, project.directory,
  config.file = NULL, variant.callers = NULL,
  remove.structural.variants = TRUE,
  separate.consensus.filters = FALSE, sleep = FALSE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="post.processing_+3A_variant.specification">variant.specification</code></td>
<td>
<p>Data frame specifying variants to be processed, or path to data frame (useful if calling from Perl)</p>
</td></tr>
<tr><td><code id="post.processing_+3A_project.directory">project.directory</code></td>
<td>
<p>Directory where output should be stored. Output files will be saved to a datestamped subdirectory</p>
</td></tr>
<tr><td><code id="post.processing_+3A_config.file">config.file</code></td>
<td>
<p>Path to config file specifying post-processing options. If not provided, the current options are used (i.e. from <code>get.varitas.options()</code>)</p>
</td></tr>
<tr><td><code id="post.processing_+3A_variant.callers">variant.callers</code></td>
<td>
<p>Optional vector of variant callers for which filters should be included in Excel file</p>
</td></tr>
<tr><td><code id="post.processing_+3A_remove.structural.variants">remove.structural.variants</code></td>
<td>
<p>Logical indicating whether structural variants (including CNVs) should be removed. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="post.processing_+3A_separate.consensus.filters">separate.consensus.filters</code></td>
<td>
<p>Logical indicating whether to apply different thresholds to variants called by more than one caller 
(specified under consensus in config file). Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="post.processing_+3A_sleep">sleep</code></td>
<td>
<p>Logical indicating whether script should sleep for 60 seconds before starting.</p>
</td></tr>
<tr><td><code id="post.processing_+3A_verbose">verbose</code></td>
<td>
<p>Logical indicating whether to print verbose output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='prepare.bam.specification'>Prepare BAM specification data frame to standardized format for downstream analyses.</h2><span id='topic+prepare.bam.specification'></span>

<h3>Description</h3>

<p>This function prepares a data frame that can be used to run variant callers. 
For matched normal variant calling, this data frame will contain three columns with names: sample.id, tumour.bam, normal.bam
For unpaired variant calling, the data frame will contain two columns with names: sample.id, tumour.bam
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare.bam.specification(sample.details, paired = TRUE,
  sample.id.column = 1, tumour.bam.column = 2, normal.bam.column = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepare.bam.specification_+3A_sample.details">sample.details</code></td>
<td>
<p>Data frame where each row represents a sample to be run. 
Must contain sample ID, path to tumour BAM, and path to normal BAM.</p>
</td></tr>
<tr><td><code id="prepare.bam.specification_+3A_paired">paired</code></td>
<td>
<p>Logical indicating whether the sample specification is for a paired analysis.</p>
</td></tr>
<tr><td><code id="prepare.bam.specification_+3A_sample.id.column">sample.id.column</code></td>
<td>
<p>Index or string giving column of sample.details that contains the sample ID</p>
</td></tr>
<tr><td><code id="prepare.bam.specification_+3A_tumour.bam.column">tumour.bam.column</code></td>
<td>
<p>Index or string giving column of sample.details that contains the path to the tumour BAM</p>
</td></tr>
<tr><td><code id="prepare.bam.specification_+3A_normal.bam.column">normal.bam.column</code></td>
<td>
<p>Index or string giving column of sample.details that contains the path to the normal BAM</p>
</td></tr>
</table>


<h3>Value</h3>

<p>bam.specification Data frame with one row per sample to be run
</p>

<hr>
<h2 id='prepare.fastq.specification'>prepare.fastq.specification</h2><span id='topic+prepare.fastq.specification'></span>

<h3>Description</h3>

<p>Prepare FASTQ specification data frame to standardized format for downstream analyses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare.fastq.specification(sample.details, sample.id.column = 1,
  fastq.columns = c(2, 3), patient.id.column = NA,
  tissue.column = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepare.fastq.specification_+3A_sample.details">sample.details</code></td>
<td>
<p>Data frame where each row represents a sample to be run. Must contain sample ID, path to tumour BAM, and path to normal BAM.</p>
</td></tr>
<tr><td><code id="prepare.fastq.specification_+3A_sample.id.column">sample.id.column</code></td>
<td>
<p>Index or string giving column of <code>sample.details</code> that contains the sample ID</p>
</td></tr>
<tr><td><code id="prepare.fastq.specification_+3A_fastq.columns">fastq.columns</code></td>
<td>
<p>Index or string giving column(s) of <code>sample.details</code> that contain path to FASTQ files</p>
</td></tr>
<tr><td><code id="prepare.fastq.specification_+3A_patient.id.column">patient.id.column</code></td>
<td>
<p>Index or string giving column of <code>sample.details</code> that contains the patient ID</p>
</td></tr>
<tr><td><code id="prepare.fastq.specification_+3A_tissue.column">tissue.column</code></td>
<td>
<p>Index or string giving column of <code>sample.details</code> that contains information on tissue (tumour/ normal)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function prepares a data frame that can be used to run alignment.
For paired-end reads, this data frame will contain three columns with names: sample.id, reads, mates
For single-end reads, the data frame will contain two columns with names: sample.id, reads
</p>


<h3>Value</h3>

<p>Data frame with one row per sample to be run
</p>

<hr>
<h2 id='prepare.miniseq.specifications'>prepare.miniseq.specifications</h2><span id='topic+prepare.miniseq.specifications'></span>

<h3>Description</h3>

<p>Process a MiniSeq directory and sample sheet to get specification data frames
that can be used to run the VariTAS pipeline.
</p>
<p>Note: This assumes normal samples are not available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare.miniseq.specifications(sample.sheet, miniseq.directory)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepare.miniseq.specifications_+3A_sample.sheet">sample.sheet</code></td>
<td>
<p>Data frame containing sample information, or path to a MiniSeq sample sheet</p>
</td></tr>
<tr><td><code id="prepare.miniseq.specifications_+3A_miniseq.directory">miniseq.directory</code></td>
<td>
<p>Path to directory with MiniSeq files</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with specification data frames 'fastq', 'bam', and 'vcf' (as applicable)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>miniseq.sheet &lt;- file.path(path.package('varitas'), 'extdata/miniseq/Example_template.csv')
miniseq.directory &lt;- file.path(path.package('varitas'), 'extdata/miniseq')
miniseq.info &lt;- prepare.miniseq.specifications(miniseq.sheet, miniseq.directory)


</code></pre>

<hr>
<h2 id='prepare.vcf.specification'>prepare.vcf.specification</h2><span id='topic+prepare.vcf.specification'></span>

<h3>Description</h3>

<p>Prepare VCF specification data frame for annotation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare.vcf.specification(vcf.details, sample.id.column = 1,
  vcf.column = 2, job.dependency.column = NA, caller.column = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepare.vcf.specification_+3A_vcf.details">vcf.details</code></td>
<td>
<p>Data frame containing details of VCF files</p>
</td></tr>
<tr><td><code id="prepare.vcf.specification_+3A_sample.id.column">sample.id.column</code></td>
<td>
<p>Identifier of column in <code>vcf.details</code> containing sample IDs (index or name)</p>
</td></tr>
<tr><td><code id="prepare.vcf.specification_+3A_vcf.column">vcf.column</code></td>
<td>
<p>Identifier of column in <code>vcf.details</code> containing VCF file (index or name)</p>
</td></tr>
<tr><td><code id="prepare.vcf.specification_+3A_job.dependency.column">job.dependency.column</code></td>
<td>
<p>Identifier of column in <code>vcf.details</code> containing job dependency (index or name)</p>
</td></tr>
<tr><td><code id="prepare.vcf.specification_+3A_caller.column">caller.column</code></td>
<td>
<p>Identifier of column in <code>vcf.details</code> containing caller (index or name)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Properly formatted VCF details
</p>

<hr>
<h2 id='process.coverage.reports'>Process coverageBed reports</h2><span id='topic+process.coverage.reports'></span>

<h3>Description</h3>

<p>Process the coverage reports generated by bedtools coverage tool.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process.coverage.reports(project.directory)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="process.coverage.reports_+3A_project.directory">project.directory</code></td>
<td>
<p>Path to project directory. Each sample should have its own subdirectory</p>
</td></tr>
</table>


<h3>Value</h3>

<p>final.statistics data frame of coverage statistics generated by parsing through coverage reports
</p>

<hr>
<h2 id='process.sample.contamination.checks'>Process sample contamination checks</h2><span id='topic+process.sample.contamination.checks'></span>

<h3>Description</h3>

<p>Takes *selfSM reports generated by VerifyBamID during alignment, and returns a vector of freemix scores.
The freemix score is a sequence only estimate of sample contamination that ranges from 0 to 1.
</p>
<p>Note: Targeted panels are often too small for this step to work properly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process.sample.contamination.checks(project.directory)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="process.sample.contamination.checks_+3A_project.directory">project.directory</code></td>
<td>
<p>Path to project directory. Each sample should have its own subdirectory</p>
</td></tr>
</table>


<h3>Value</h3>

<p>freemix.scores Data frame giving sample contamination (column freemix) score per sample.
</p>


<h3>References</h3>

<p><a href="https://genome.sph.umich.edu/wiki/VerifyBamID">https://genome.sph.umich.edu/wiki/VerifyBamID</a>
</p>

<hr>
<h2 id='process.total.coverage.statistics'>Process total coverage statistics</h2><span id='topic+process.total.coverage.statistics'></span>

<h3>Description</h3>

<p>Process reports generated by flagstat. 
Assumes reports for before and after off-target filtering have been written to the same file, with separating headers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process.total.coverage.statistics(project.directory)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="process.total.coverage.statistics_+3A_project.directory">project.directory</code></td>
<td>
<p>Path to project directory. Each sample should have its own subdirectory</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame with extracted statistics
</p>

<hr>
<h2 id='read.all.calls'>read.all.calls</h2><span id='topic+read.all.calls'></span>

<h3>Description</h3>

<p>Read all calls made with a certain caller
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.all.calls(sample.ids, caller = c("vardict", "mutect", "pgm"),
  project.directory, patient.ids = NULL, apply.filters = TRUE,
  variant.file.pattern = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.all.calls_+3A_sample.ids">sample.ids</code></td>
<td>
<p>Vector giving sample IDs to process</p>
</td></tr>
<tr><td><code id="read.all.calls_+3A_caller">caller</code></td>
<td>
<p>String indicating which caller was used</p>
</td></tr>
<tr><td><code id="read.all.calls_+3A_project.directory">project.directory</code></td>
<td>
<p>Path to project directory</p>
</td></tr>
<tr><td><code id="read.all.calls_+3A_patient.ids">patient.ids</code></td>
<td>
<p>Optional vector giving patient ID (or other group) corresponding to each sample</p>
</td></tr>
<tr><td><code id="read.all.calls_+3A_apply.filters">apply.filters</code></td>
<td>
<p>Logical indicating whether filters specified in VariTAS options should be applied. Defaults to TRUE. !</p>
</td></tr>
<tr><td><code id="read.all.calls_+3A_variant.file.pattern">variant.file.pattern</code></td>
<td>
<p>Pattern indicating where the variant file can be found. Sample ID should be indicated by SAMPLE_ID</p>
</td></tr>
</table>


<h3>Value</h3>

<p>combined.variant.calls Data frame with variant calls from all patients
</p>

<hr>
<h2 id='read.ides.file'>Read iDES output</h2><span id='topic+read.ides.file'></span>

<h3>Description</h3>

<p>Read output from iDES_step1.pl and return data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.ides.file(filename)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.ides.file_+3A_filename">filename</code></td>
<td>
<p>path to file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ides.data  data frame read from iDES output
</p>

<hr>
<h2 id='read.variant.calls'>Read variant calls from file and format for ease of downstream analyses.</h2><span id='topic+read.variant.calls'></span>

<h3>Description</h3>

<p>Read variant calls from file and format for ease of downstream analyses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.variant.calls(variant.file, variant.caller)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.variant.calls_+3A_variant.file">variant.file</code></td>
<td>
<p>Path to variant file.</p>
</td></tr>
<tr><td><code id="read.variant.calls_+3A_variant.caller">variant.caller</code></td>
<td>
<p>String indicating which variant caller was used. Needed to format the headers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>variant.calls Data frame of variant calls
</p>

<hr>
<h2 id='read.yaml'>read.yaml</h2><span id='topic+read.yaml'></span>

<h3>Description</h3>

<p>Read a yaml file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.yaml(file.name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.yaml_+3A_file.name">file.name</code></td>
<td>
<p>Path to yaml file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing contents of yaml file
</p>


<h3>Examples</h3>

<pre><code class='language-R'>read.yaml(file.path(path.package('varitas'), 'config.yaml'))

</code></pre>

<hr>
<h2 id='run.alignment'>Run alignment</h2><span id='topic+run.alignment'></span>

<h3>Description</h3>

<p>Run alignment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run.alignment(fastq.specification, output.directory, paired.end = FALSE,
  sample.directories = TRUE, output.subdirectory = FALSE,
  job.name.prefix = NULL, job.group = "alignment", quiet = FALSE,
  verify.options = !quiet)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run.alignment_+3A_fastq.specification">fastq.specification</code></td>
<td>
<p>Data frame detailing FASTQ files to be processed, typically from prepare.fastq.specification</p>
</td></tr>
<tr><td><code id="run.alignment_+3A_output.directory">output.directory</code></td>
<td>
<p>Path to project directory</p>
</td></tr>
<tr><td><code id="run.alignment_+3A_paired.end">paired.end</code></td>
<td>
<p>Logical indicating whether paired-end sequencing was performed</p>
</td></tr>
<tr><td><code id="run.alignment_+3A_sample.directories">sample.directories</code></td>
<td>
<p>Logical indicating whether all sample files should be saved to sample-specific subdirectories (will be created)</p>
</td></tr>
<tr><td><code id="run.alignment_+3A_output.subdirectory">output.subdirectory</code></td>
<td>
<p>If further nesting is required, name of subdirectory. If no further nesting, set to FALSE</p>
</td></tr>
<tr><td><code id="run.alignment_+3A_job.name.prefix">job.name.prefix</code></td>
<td>
<p>Prefix for job names on the cluster</p>
</td></tr>
<tr><td><code id="run.alignment_+3A_job.group">job.group</code></td>
<td>
<p>Group job should be associated with on cluster</p>
</td></tr>
<tr><td><code id="run.alignment_+3A_quiet">quiet</code></td>
<td>
<p>Logical indicating whether to print commands to screen rather than submit them</p>
</td></tr>
<tr><td><code id="run.alignment_+3A_verify.options">verify.options</code></td>
<td>
<p>Logical indicating whether to run verify.varitas.options</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Runs alignment (and related processing steps) on each sample.
</p>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>run.alignment(
  fastq.specification = data.frame(
    sample.id = c('1', '2'),
    reads = c('1-R1.fastq.gz', '2-R1.fastq.gz'),
    mates = c('1-R2.fastq.gz', '2-R2.fastq.gz'),
    patient.id = c('P1', 'P1'),
    tissue = c('tumour', 'normal')
  ),
  output.directory = '.',
  quiet = TRUE,
  paired.end = TRUE
)

</code></pre>

<hr>
<h2 id='run.alignment.sample'>Run alignment for a single sample</h2><span id='topic+run.alignment.sample'></span>

<h3>Description</h3>

<p>Run alignment for a single sample
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run.alignment.sample(fastq.files, sample.id, output.directory = NULL,
  output.filename = NULL, code.directory = NULL,
  log.directory = NULL, config.file = NULL, job.dependencies = NULL,
  job.name = NULL, job.group = NULL, quiet = FALSE,
  verify.options = !quiet)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run.alignment.sample_+3A_fastq.files">fastq.files</code></td>
<td>
<p>Paths to FASTQ files (one file if single-end reads, two files if paired-end)</p>
</td></tr>
<tr><td><code id="run.alignment.sample_+3A_sample.id">sample.id</code></td>
<td>
<p>Sample ID for labelling</p>
</td></tr>
<tr><td><code id="run.alignment.sample_+3A_output.directory">output.directory</code></td>
<td>
<p>Path to output directory</p>
</td></tr>
<tr><td><code id="run.alignment.sample_+3A_output.filename">output.filename</code></td>
<td>
<p>Name of resulting VCF file (defaults to SAMPLE_ID.vcf)</p>
</td></tr>
<tr><td><code id="run.alignment.sample_+3A_code.directory">code.directory</code></td>
<td>
<p>Path to directory where code should be stored</p>
</td></tr>
<tr><td><code id="run.alignment.sample_+3A_log.directory">log.directory</code></td>
<td>
<p>Path to directory where log files should be stored</p>
</td></tr>
<tr><td><code id="run.alignment.sample_+3A_config.file">config.file</code></td>
<td>
<p>Path to config file</p>
</td></tr>
<tr><td><code id="run.alignment.sample_+3A_job.dependencies">job.dependencies</code></td>
<td>
<p>Vector with names of job dependencies</p>
</td></tr>
<tr><td><code id="run.alignment.sample_+3A_job.name">job.name</code></td>
<td>
<p>Name of job to be submitted</p>
</td></tr>
<tr><td><code id="run.alignment.sample_+3A_job.group">job.group</code></td>
<td>
<p>Group job should belong to</p>
</td></tr>
<tr><td><code id="run.alignment.sample_+3A_quiet">quiet</code></td>
<td>
<p>Logical indicating whether to print command to screen rather than submit it to the system. Defaults to false, useful for debugging.</p>
</td></tr>
<tr><td><code id="run.alignment.sample_+3A_verify.options">verify.options</code></td>
<td>
<p>Logical indicating whether to run verify.varitas.options</p>
</td></tr>
</table>

<hr>
<h2 id='run.all.scripts'>Run all the generated bash scripts without HPC commands</h2><span id='topic+run.all.scripts'></span>

<h3>Description</h3>

<p>Run all the scripts generated by previous parts of the pipeline, without using HPC commands
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run.all.scripts(output.directory, stages.to.run = c("alignment", "qc",
  "calling", "annotation", "merging"), variant.callers = NULL,
  quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run.all.scripts_+3A_output.directory">output.directory</code></td>
<td>
<p>Main directory where all files should be saved</p>
</td></tr>
<tr><td><code id="run.all.scripts_+3A_stages.to.run">stages.to.run</code></td>
<td>
<p>A character vector of all stages that need running</p>
</td></tr>
<tr><td><code id="run.all.scripts_+3A_variant.callers">variant.callers</code></td>
<td>
<p>A character vector of variant callers to run</p>
</td></tr>
<tr><td><code id="run.all.scripts_+3A_quiet">quiet</code></td>
<td>
<p>Logical indicating whether to print commands to screen rather than submit jobs. Defaults to FALSE,
can be useful to set to TRUE for testing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='run.annotation'>Run annotation on a set of VCF files</h2><span id='topic+run.annotation'></span>

<h3>Description</h3>

<p>Takes a data frame with paths to VCF files, and runs ANNOVAR annotation on each file.
To allow for smooth connections with downstream pipeline steps, the function returns a variant
specification data frame that can be used as input to merging steps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run.annotation(vcf.specification, output.directory = NULL,
  job.name.prefix = NULL, job.group = NULL, quiet = FALSE,
  verify.options = !quiet)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run.annotation_+3A_vcf.specification">vcf.specification</code></td>
<td>
<p>Data frame detailing VCF files to be processed, from <code>prepare.vcf.specification</code>.</p>
</td></tr>
<tr><td><code id="run.annotation_+3A_output.directory">output.directory</code></td>
<td>
<p>Path to folder where code and log files should be stored in their respective subdirectories. 
If not supplied, code and log files will be stored in the directory with each VCF file.</p>
</td></tr>
<tr><td><code id="run.annotation_+3A_job.name.prefix">job.name.prefix</code></td>
<td>
<p>Prefix to be added before VCF name in job name. Defaults to 'annotate', but should be changed if 
running multiple callers to avoid</p>
</td></tr>
<tr><td><code id="run.annotation_+3A_job.group">job.group</code></td>
<td>
<p>Group job should be associated with on cluster</p>
</td></tr>
<tr><td><code id="run.annotation_+3A_quiet">quiet</code></td>
<td>
<p>Logical indicating whether to print commands to screen rather than submit them</p>
</td></tr>
<tr><td><code id="run.annotation_+3A_verify.options">verify.options</code></td>
<td>
<p>Logical indicating whether to run verify.varitas.options</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with details of variant files
</p>


<h3>Examples</h3>

<pre><code class='language-R'>run.annotation(
  data.frame(
    sample.id = c('a', 'b'),
    vcf = c('a.vcf', 'b.vcf'),
    caller = c('mutect', 'mutect')
  ),
  output.directory = '.',
  quiet = TRUE
)

</code></pre>

<hr>
<h2 id='run.annovar.vcf'>Run ANNOVAR on a VCF file</h2><span id='topic+run.annovar.vcf'></span>

<h3>Description</h3>

<p>Run ANNOVAR on a VCF file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run.annovar.vcf(vcf.file, output.directory = NULL,
  output.filename = NULL, code.directory = NULL,
  log.directory = NULL, config.file = NULL, job.dependencies = NULL,
  job.group = NULL, job.name = NULL, isis = FALSE, quiet = FALSE,
  verify.options = !quiet)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run.annovar.vcf_+3A_vcf.file">vcf.file</code></td>
<td>
<p>Path to VCF file</p>
</td></tr>
<tr><td><code id="run.annovar.vcf_+3A_output.directory">output.directory</code></td>
<td>
<p>Path to output directory</p>
</td></tr>
<tr><td><code id="run.annovar.vcf_+3A_output.filename">output.filename</code></td>
<td>
<p>Name of resulting VCF file (defaults to SAMPLE_ID.vcf)</p>
</td></tr>
<tr><td><code id="run.annovar.vcf_+3A_code.directory">code.directory</code></td>
<td>
<p>Path to directory where code should be stored</p>
</td></tr>
<tr><td><code id="run.annovar.vcf_+3A_log.directory">log.directory</code></td>
<td>
<p>Path to directory where log files should be stored</p>
</td></tr>
<tr><td><code id="run.annovar.vcf_+3A_config.file">config.file</code></td>
<td>
<p>Path to config file</p>
</td></tr>
<tr><td><code id="run.annovar.vcf_+3A_job.dependencies">job.dependencies</code></td>
<td>
<p>Vector with names of job dependencies</p>
</td></tr>
<tr><td><code id="run.annovar.vcf_+3A_job.group">job.group</code></td>
<td>
<p>Group job should belong to</p>
</td></tr>
<tr><td><code id="run.annovar.vcf_+3A_job.name">job.name</code></td>
<td>
<p>Name of job to be submitted</p>
</td></tr>
<tr><td><code id="run.annovar.vcf_+3A_isis">isis</code></td>
<td>
<p>Logical indicating whether VCF files are from the isis (MiniSeq) variant caller</p>
</td></tr>
<tr><td><code id="run.annovar.vcf_+3A_quiet">quiet</code></td>
<td>
<p>Logical indicating whether to print command to screen rather than submit it to the system. Defaults to false, useful for debugging.</p>
</td></tr>
<tr><td><code id="run.annovar.vcf_+3A_verify.options">verify.options</code></td>
<td>
<p>Logical indicating whether to run verify.varitas.options</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='run.filtering.txt'>Run filtering on an ANNOVAR-annotated txt file</h2><span id='topic+run.filtering.txt'></span>

<h3>Description</h3>

<p>Run filtering on an ANNOVAR-annotated txt file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run.filtering.txt(variant.file, caller = c("consensus", "vardict",
  "ides", "mutect"), output.directory = NULL, output.filename = NULL,
  code.directory = NULL, log.directory = NULL, config.file = NULL,
  job.dependencies = NULL, job.group = NULL, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run.filtering.txt_+3A_variant.file">variant.file</code></td>
<td>
<p>Path to variant file</p>
</td></tr>
<tr><td><code id="run.filtering.txt_+3A_caller">caller</code></td>
<td>
<p>String giving variant caller that was used (affects which filters were applied.</p>
</td></tr>
<tr><td><code id="run.filtering.txt_+3A_output.directory">output.directory</code></td>
<td>
<p>Path to output directory</p>
</td></tr>
<tr><td><code id="run.filtering.txt_+3A_output.filename">output.filename</code></td>
<td>
<p>Name of resulting VCF file (defaults to SAMPLE_ID.vcf)</p>
</td></tr>
<tr><td><code id="run.filtering.txt_+3A_code.directory">code.directory</code></td>
<td>
<p>Path to directory where code should be stored</p>
</td></tr>
<tr><td><code id="run.filtering.txt_+3A_log.directory">log.directory</code></td>
<td>
<p>Path to directory where log files should be stored</p>
</td></tr>
<tr><td><code id="run.filtering.txt_+3A_config.file">config.file</code></td>
<td>
<p>Path to config file</p>
</td></tr>
<tr><td><code id="run.filtering.txt_+3A_job.dependencies">job.dependencies</code></td>
<td>
<p>Vector with names of job dependencies</p>
</td></tr>
<tr><td><code id="run.filtering.txt_+3A_job.group">job.group</code></td>
<td>
<p>Group job should belong to</p>
</td></tr>
<tr><td><code id="run.filtering.txt_+3A_quiet">quiet</code></td>
<td>
<p>Logical indicating whether to print command to screen rather than submit it to the system. Defaults to false, useful for debugging.</p>
</td></tr>
</table>

<hr>
<h2 id='run.ides'>Run iDES</h2><span id='topic+run.ides'></span>

<h3>Description</h3>

<p>Run iDES
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run.ides(project.directory, sample.id.pattern = "._S\\d+$",
  sample.ids = NULL, job.dependencies = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run.ides_+3A_project.directory">project.directory</code></td>
<td>
<p>Directory containing files</p>
</td></tr>
<tr><td><code id="run.ides_+3A_sample.id.pattern">sample.id.pattern</code></td>
<td>
<p>Regex pattern to match sample IDs</p>
</td></tr>
<tr><td><code id="run.ides_+3A_sample.ids">sample.ids</code></td>
<td>
<p>Vector of sample IDs</p>
</td></tr>
<tr><td><code id="run.ides_+3A_job.dependencies">job.dependencies</code></td>
<td>
<p>Vector of job dependencies</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Run iDES step 1on each sample, to tally up calls by strand.
Files are output to a the sample subdirectory
</p>


<h3>Value</h3>

<p>None
</p>


<h3>Note</h3>

<p>Deprecated function for running iDES. 
Follows previous development package without specification data frames
</p>


<h3>References</h3>

<p><a href="https://cappseq.stanford.edu/ides/">https://cappseq.stanford.edu/ides/</a>
</p>

<hr>
<h2 id='run.lofreq.sample'>Run LoFreq for a sample</h2><span id='topic+run.lofreq.sample'></span>

<h3>Description</h3>

<p>Run LoFreq for a sample
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run.lofreq.sample(tumour.bam, sample.id, paired, normal.bam = NULL,
  output.directory = NULL, output.filename = NULL,
  code.directory = NULL, log.directory = NULL, config.file = NULL,
  job.dependencies = NULL, quiet = FALSE, job.name = NULL,
  verify.options = !quiet, job.group = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run.lofreq.sample_+3A_tumour.bam">tumour.bam</code></td>
<td>
<p>Path to tumour sample BAM file.</p>
</td></tr>
<tr><td><code id="run.lofreq.sample_+3A_sample.id">sample.id</code></td>
<td>
<p>Sample ID for labelling</p>
</td></tr>
<tr><td><code id="run.lofreq.sample_+3A_paired">paired</code></td>
<td>
<p>Logical indicating whether to do variant calling with a matched normal.</p>
</td></tr>
<tr><td><code id="run.lofreq.sample_+3A_normal.bam">normal.bam</code></td>
<td>
<p>Path to normal BAM file if <code>paired = TRUE</code></p>
</td></tr>
<tr><td><code id="run.lofreq.sample_+3A_output.directory">output.directory</code></td>
<td>
<p>Path to output directory</p>
</td></tr>
<tr><td><code id="run.lofreq.sample_+3A_output.filename">output.filename</code></td>
<td>
<p>Name of resulting VCF file (defaults to SAMPLE_ID.vcf)</p>
</td></tr>
<tr><td><code id="run.lofreq.sample_+3A_code.directory">code.directory</code></td>
<td>
<p>Path to directory where code should be stored</p>
</td></tr>
<tr><td><code id="run.lofreq.sample_+3A_log.directory">log.directory</code></td>
<td>
<p>Path to directory where log files should be stored</p>
</td></tr>
<tr><td><code id="run.lofreq.sample_+3A_config.file">config.file</code></td>
<td>
<p>Path to config file</p>
</td></tr>
<tr><td><code id="run.lofreq.sample_+3A_job.dependencies">job.dependencies</code></td>
<td>
<p>Vector with names of job dependencies</p>
</td></tr>
<tr><td><code id="run.lofreq.sample_+3A_quiet">quiet</code></td>
<td>
<p>Logical indicating whether to print command to screen rather than submit it to the system. Defaults to false, useful for debugging.</p>
</td></tr>
<tr><td><code id="run.lofreq.sample_+3A_job.name">job.name</code></td>
<td>
<p>Name of job to be submitted</p>
</td></tr>
<tr><td><code id="run.lofreq.sample_+3A_verify.options">verify.options</code></td>
<td>
<p>Logical indicating whether to run verify.varitas.options</p>
</td></tr>
<tr><td><code id="run.lofreq.sample_+3A_job.group">job.group</code></td>
<td>
<p>Group job should belong to</p>
</td></tr>
</table>

<hr>
<h2 id='run.muse.sample'>Run MuSE for a sample</h2><span id='topic+run.muse.sample'></span>

<h3>Description</h3>

<p>Run MuSE for a sample
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run.muse.sample(tumour.bam, sample.id, paired, normal.bam = NULL,
  output.directory = NULL, output.filename = NULL,
  code.directory = NULL, log.directory = NULL, config.file = NULL,
  job.dependencies = NULL, quiet = FALSE, job.name = NULL,
  verify.options = !quiet, job.group = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run.muse.sample_+3A_tumour.bam">tumour.bam</code></td>
<td>
<p>Path to tumour sample BAM file.</p>
</td></tr>
<tr><td><code id="run.muse.sample_+3A_sample.id">sample.id</code></td>
<td>
<p>Sample ID for labelling</p>
</td></tr>
<tr><td><code id="run.muse.sample_+3A_paired">paired</code></td>
<td>
<p>Logical indicating whether to do variant calling with a matched normal.</p>
</td></tr>
<tr><td><code id="run.muse.sample_+3A_normal.bam">normal.bam</code></td>
<td>
<p>Path to normal BAM file if <code>paired = TRUE</code></p>
</td></tr>
<tr><td><code id="run.muse.sample_+3A_output.directory">output.directory</code></td>
<td>
<p>Path to output directory</p>
</td></tr>
<tr><td><code id="run.muse.sample_+3A_output.filename">output.filename</code></td>
<td>
<p>Name of resulting VCF file (defaults to SAMPLE_ID.vcf)</p>
</td></tr>
<tr><td><code id="run.muse.sample_+3A_code.directory">code.directory</code></td>
<td>
<p>Path to directory where code should be stored</p>
</td></tr>
<tr><td><code id="run.muse.sample_+3A_log.directory">log.directory</code></td>
<td>
<p>Path to directory where log files should be stored</p>
</td></tr>
<tr><td><code id="run.muse.sample_+3A_config.file">config.file</code></td>
<td>
<p>Path to config file</p>
</td></tr>
<tr><td><code id="run.muse.sample_+3A_job.dependencies">job.dependencies</code></td>
<td>
<p>Vector with names of job dependencies</p>
</td></tr>
<tr><td><code id="run.muse.sample_+3A_quiet">quiet</code></td>
<td>
<p>Logical indicating whether to print command to screen rather than submit it to the system. Defaults to false, useful for debugging.</p>
</td></tr>
<tr><td><code id="run.muse.sample_+3A_job.name">job.name</code></td>
<td>
<p>Name of job to be submitted</p>
</td></tr>
<tr><td><code id="run.muse.sample_+3A_verify.options">verify.options</code></td>
<td>
<p>Logical indicating whether to run verify.varitas.options</p>
</td></tr>
<tr><td><code id="run.muse.sample_+3A_job.group">job.group</code></td>
<td>
<p>Group job should belong to</p>
</td></tr>
</table>

<hr>
<h2 id='run.mutect.sample'>Run MuTect for a sample</h2><span id='topic+run.mutect.sample'></span>

<h3>Description</h3>

<p>Run MuTect for a sample
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run.mutect.sample(tumour.bam, sample.id, paired, normal.bam = NULL,
  output.directory = NULL, output.filename = NULL,
  code.directory = NULL, log.directory = NULL, config.file = NULL,
  job.dependencies = NULL, quiet = FALSE, job.name = NULL,
  verify.options = !quiet, job.group = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run.mutect.sample_+3A_tumour.bam">tumour.bam</code></td>
<td>
<p>Path to tumour sample BAM file.</p>
</td></tr>
<tr><td><code id="run.mutect.sample_+3A_sample.id">sample.id</code></td>
<td>
<p>Sample ID for labelling</p>
</td></tr>
<tr><td><code id="run.mutect.sample_+3A_paired">paired</code></td>
<td>
<p>Logical indicating whether to do variant calling with a matched normal.</p>
</td></tr>
<tr><td><code id="run.mutect.sample_+3A_normal.bam">normal.bam</code></td>
<td>
<p>Path to normal BAM file if <code>paired = TRUE</code></p>
</td></tr>
<tr><td><code id="run.mutect.sample_+3A_output.directory">output.directory</code></td>
<td>
<p>Path to output directory</p>
</td></tr>
<tr><td><code id="run.mutect.sample_+3A_output.filename">output.filename</code></td>
<td>
<p>Name of resulting VCF file (defaults to SAMPLE_ID.vcf)</p>
</td></tr>
<tr><td><code id="run.mutect.sample_+3A_code.directory">code.directory</code></td>
<td>
<p>Path to directory where code should be stored</p>
</td></tr>
<tr><td><code id="run.mutect.sample_+3A_log.directory">log.directory</code></td>
<td>
<p>Path to directory where log files should be stored</p>
</td></tr>
<tr><td><code id="run.mutect.sample_+3A_config.file">config.file</code></td>
<td>
<p>Path to config file</p>
</td></tr>
<tr><td><code id="run.mutect.sample_+3A_job.dependencies">job.dependencies</code></td>
<td>
<p>Vector with names of job dependencies</p>
</td></tr>
<tr><td><code id="run.mutect.sample_+3A_quiet">quiet</code></td>
<td>
<p>Logical indicating whether to print command to screen rather than submit it to the system. Defaults to false, useful for debugging.</p>
</td></tr>
<tr><td><code id="run.mutect.sample_+3A_job.name">job.name</code></td>
<td>
<p>Name of job to be submitted</p>
</td></tr>
<tr><td><code id="run.mutect.sample_+3A_verify.options">verify.options</code></td>
<td>
<p>Logical indicating whether to run verify.varitas.options</p>
</td></tr>
<tr><td><code id="run.mutect.sample_+3A_job.group">job.group</code></td>
<td>
<p>Group job should belong to</p>
</td></tr>
</table>

<hr>
<h2 id='run.post.processing'>run.post.processing</h2><span id='topic+run.post.processing'></span>

<h3>Description</h3>

<p>Submit post-processing job to the cluster with appropriate job dependencies
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run.post.processing(variant.specification, output.directory,
  code.directory = NULL, log.directory = NULL, config.file = NULL,
  job.name.prefix = NULL, quiet = FALSE, email = NULL,
  verify.options = !quiet)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run.post.processing_+3A_variant.specification">variant.specification</code></td>
<td>
<p>Data frame specifying files to be processed</p>
</td></tr>
<tr><td><code id="run.post.processing_+3A_output.directory">output.directory</code></td>
<td>
<p>Path to directory where output should be saved</p>
</td></tr>
<tr><td><code id="run.post.processing_+3A_code.directory">code.directory</code></td>
<td>
<p>Directory where code should be saved</p>
</td></tr>
<tr><td><code id="run.post.processing_+3A_log.directory">log.directory</code></td>
<td>
<p>Directory where log files should be saved</p>
</td></tr>
<tr><td><code id="run.post.processing_+3A_config.file">config.file</code></td>
<td>
<p>Path to config file</p>
</td></tr>
<tr><td><code id="run.post.processing_+3A_job.name.prefix">job.name.prefix</code></td>
<td>
<p>Prefix for job names on the cluster</p>
</td></tr>
<tr><td><code id="run.post.processing_+3A_quiet">quiet</code></td>
<td>
<p>Logical indicating whether to print commands to screen rather than submit the job</p>
</td></tr>
<tr><td><code id="run.post.processing_+3A_email">email</code></td>
<td>
<p>Email address that should be notified when job finishes. If NULL or FALSE, no email is sent</p>
</td></tr>
<tr><td><code id="run.post.processing_+3A_verify.options">verify.options</code></td>
<td>
<p>Logical indicating whether <code>verify.varitas.options()</code> should be run.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>run.post.processing(
  variant.specification = data.frame(
    sample.id = c('a', 'b'),
    vcf = c('a.vcf', 'b.vcf'),
    caller = c('mutect', 'mutect'),
    job.dependency = c('example1', 'example2')
  ),
  output.directory = '.',
  quiet = TRUE
)

</code></pre>

<hr>
<h2 id='run.target.qc'>Perform sample QC by looking at target coverage.</h2><span id='topic+run.target.qc'></span>

<h3>Description</h3>

<p>Perform sample QC by looking at target coverage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run.target.qc(bam.specification, project.directory,
  sample.directories = TRUE, paired = FALSE,
  output.subdirectory = FALSE, quiet = FALSE, job.name.prefix = NULL,
  verify.options = FALSE, job.group = "target_qc")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run.target.qc_+3A_bam.specification">bam.specification</code></td>
<td>
<p>Data frame containing details of BAM files to be processed, typically from <code>prepare.bam.specification</code>.</p>
</td></tr>
<tr><td><code id="run.target.qc_+3A_project.directory">project.directory</code></td>
<td>
<p>Path to project directory where code and log files should be saved</p>
</td></tr>
<tr><td><code id="run.target.qc_+3A_sample.directories">sample.directories</code></td>
<td>
<p>Logical indicating whether output for each sample should be put in its own directory (within output.directory)</p>
</td></tr>
<tr><td><code id="run.target.qc_+3A_paired">paired</code></td>
<td>
<p>Logical indicating whether the analysis is paired. This does not affect QC directly, but means normal samples get nested</p>
</td></tr>
<tr><td><code id="run.target.qc_+3A_output.subdirectory">output.subdirectory</code></td>
<td>
<p>If further nesting is required, name of subdirectory. If no further nesting, set to FALSE</p>
</td></tr>
<tr><td><code id="run.target.qc_+3A_quiet">quiet</code></td>
<td>
<p>Logical indicating whether to print commands to screen rather than submit the job</p>
</td></tr>
<tr><td><code id="run.target.qc_+3A_job.name.prefix">job.name.prefix</code></td>
<td>
<p>Prefix for job names on the cluster</p>
</td></tr>
<tr><td><code id="run.target.qc_+3A_verify.options">verify.options</code></td>
<td>
<p>Logical indicating whether to run verify.varitas.options</p>
</td></tr>
<tr><td><code id="run.target.qc_+3A_job.group">job.group</code></td>
<td>
<p>Group job should be associated with on cluster</p>
</td></tr>
</table>

<hr>
<h2 id='run.target.qc.sample'>Get ontarget reads and run coverage quality control</h2><span id='topic+run.target.qc.sample'></span>

<h3>Description</h3>

<p>Get ontarget reads and run coverage quality control
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run.target.qc.sample(bam.file, sample.id, output.directory = NULL,
  code.directory = NULL, log.directory = NULL, config.file = NULL,
  job.dependencies = NULL, job.name = NULL, job.group = NULL,
  quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run.target.qc.sample_+3A_bam.file">bam.file</code></td>
<td>
<p>Path to BAM file</p>
</td></tr>
<tr><td><code id="run.target.qc.sample_+3A_sample.id">sample.id</code></td>
<td>
<p>Sample ID for labelling</p>
</td></tr>
<tr><td><code id="run.target.qc.sample_+3A_output.directory">output.directory</code></td>
<td>
<p>Path to output directory</p>
</td></tr>
<tr><td><code id="run.target.qc.sample_+3A_code.directory">code.directory</code></td>
<td>
<p>Path to directory where code should be stored</p>
</td></tr>
<tr><td><code id="run.target.qc.sample_+3A_log.directory">log.directory</code></td>
<td>
<p>Path to directory where log files should be stored</p>
</td></tr>
<tr><td><code id="run.target.qc.sample_+3A_config.file">config.file</code></td>
<td>
<p>Path to config file</p>
</td></tr>
<tr><td><code id="run.target.qc.sample_+3A_job.dependencies">job.dependencies</code></td>
<td>
<p>Vector with names of job dependencies</p>
</td></tr>
<tr><td><code id="run.target.qc.sample_+3A_job.name">job.name</code></td>
<td>
<p>Name of job to be submitted</p>
</td></tr>
<tr><td><code id="run.target.qc.sample_+3A_job.group">job.group</code></td>
<td>
<p>Group job should belong to</p>
</td></tr>
<tr><td><code id="run.target.qc.sample_+3A_quiet">quiet</code></td>
<td>
<p>Logical indicating whether to print command to screen rather than submit it to the system. Defaults to false, useful for debugging.</p>
</td></tr>
</table>

<hr>
<h2 id='run.vardict.sample'>run.vardict.sample</h2><span id='topic+run.vardict.sample'></span>

<h3>Description</h3>

<p>Run VarDict on a sample. Idea: have a low-level function that simply submits job to Perl, after BAM paths have been found. 
and output paths already have been decided upon
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run.vardict.sample(tumour.bam, sample.id, paired, proton = FALSE,
  normal.bam = NULL, output.directory = NULL, output.filename = NULL,
  code.directory = NULL, log.directory = NULL, config.file = NULL,
  job.dependencies = NULL, job.name = NULL, job.group = NULL,
  quiet = FALSE, verify.options = !quiet)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run.vardict.sample_+3A_tumour.bam">tumour.bam</code></td>
<td>
<p>Path to tumour sample BAM file.</p>
</td></tr>
<tr><td><code id="run.vardict.sample_+3A_sample.id">sample.id</code></td>
<td>
<p>Sample ID for labelling</p>
</td></tr>
<tr><td><code id="run.vardict.sample_+3A_paired">paired</code></td>
<td>
<p>Logical indicating whether to do variant calling with a matched normal.</p>
</td></tr>
<tr><td><code id="run.vardict.sample_+3A_proton">proton</code></td>
<td>
<p>Logical indicating whether the data was generated by proton sequencing. Defaults to False (i.e. Illumina)</p>
</td></tr>
<tr><td><code id="run.vardict.sample_+3A_normal.bam">normal.bam</code></td>
<td>
<p>Path to normal BAM file if <code>paired = TRUE</code></p>
</td></tr>
<tr><td><code id="run.vardict.sample_+3A_output.directory">output.directory</code></td>
<td>
<p>Path to output directory</p>
</td></tr>
<tr><td><code id="run.vardict.sample_+3A_output.filename">output.filename</code></td>
<td>
<p>Name of resulting VCF file (defaults to SAMPLE_ID.vcf)</p>
</td></tr>
<tr><td><code id="run.vardict.sample_+3A_code.directory">code.directory</code></td>
<td>
<p>Path to directory where code should be stored</p>
</td></tr>
<tr><td><code id="run.vardict.sample_+3A_log.directory">log.directory</code></td>
<td>
<p>Path to directory where log files should be stored</p>
</td></tr>
<tr><td><code id="run.vardict.sample_+3A_config.file">config.file</code></td>
<td>
<p>Path to config file</p>
</td></tr>
<tr><td><code id="run.vardict.sample_+3A_job.dependencies">job.dependencies</code></td>
<td>
<p>Vector with names of job dependencies</p>
</td></tr>
<tr><td><code id="run.vardict.sample_+3A_job.name">job.name</code></td>
<td>
<p>Name of job to be submitted</p>
</td></tr>
<tr><td><code id="run.vardict.sample_+3A_job.group">job.group</code></td>
<td>
<p>Group job should belong to</p>
</td></tr>
<tr><td><code id="run.vardict.sample_+3A_quiet">quiet</code></td>
<td>
<p>Logical indicating whether to print command to screen rather than submit it to the system. Defaults to false, useful for debugging.</p>
</td></tr>
<tr><td><code id="run.vardict.sample_+3A_verify.options">verify.options</code></td>
<td>
<p>Logical indicating whether to run verify.varitas.options</p>
</td></tr>
</table>

<hr>
<h2 id='run.variant.calling'>run.variant.calling</h2><span id='topic+run.variant.calling'></span>

<h3>Description</h3>

<p>Run variant calling for all samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run.variant.calling(bam.specification, output.directory,
  variant.callers = c("vardict", "mutect", "varscan", "lofreq", "muse"),
  paired = TRUE, proton = FALSE, sample.directories = TRUE,
  job.name.prefix = NULL, quiet = FALSE, verify.options = !quiet)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run.variant.calling_+3A_bam.specification">bam.specification</code></td>
<td>
<p>Data frame containing details of BAM files to be processed, typically from <code>prepare.bam.specification</code>.</p>
</td></tr>
<tr><td><code id="run.variant.calling_+3A_output.directory">output.directory</code></td>
<td>
<p>Path to directory where output should be saved</p>
</td></tr>
<tr><td><code id="run.variant.calling_+3A_variant.callers">variant.callers</code></td>
<td>
<p>Character vector of variant callers to be used</p>
</td></tr>
<tr><td><code id="run.variant.calling_+3A_paired">paired</code></td>
<td>
<p>Logical indicating whether to do variant calling with a matched normal</p>
</td></tr>
<tr><td><code id="run.variant.calling_+3A_proton">proton</code></td>
<td>
<p>Logical indicating whether data was generated by proton sequencing (ignored if running MuTect)</p>
</td></tr>
<tr><td><code id="run.variant.calling_+3A_sample.directories">sample.directories</code></td>
<td>
<p>Logical indicating whether output for each sample should be put in its own directory (within output.directory)</p>
</td></tr>
<tr><td><code id="run.variant.calling_+3A_job.name.prefix">job.name.prefix</code></td>
<td>
<p>Prefix for job names on the cluster</p>
</td></tr>
<tr><td><code id="run.variant.calling_+3A_quiet">quiet</code></td>
<td>
<p>Logical indicating whether to print commands to screen rather than submit the job</p>
</td></tr>
<tr><td><code id="run.variant.calling_+3A_verify.options">verify.options</code></td>
<td>
<p>Logical indicating whether to run verify.varitas.options</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Run VarDict on each sample, and annotate the results with ANNOVAR. 
Files are output to a vardict/ subdirectory within each sample directory.
</p>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>run.variant.calling(
  data.frame(sample.id = c('Z', 'Y'), tumour.bam = c('Z.bam', 'Y.bam')),
  output.directory = '.',
  variant.caller = c('lofreq', 'mutect'),
  quiet = TRUE,
  paired = FALSE
)

</code></pre>

<hr>
<h2 id='run.varitas.pipeline'>Run VariTAS pipeline in full.</h2><span id='topic+run.varitas.pipeline'></span>

<h3>Description</h3>

<p>Run all steps in VariTAS processing pipeline, with appropriate dependencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run.varitas.pipeline(file.details, output.directory, run.name = NULL,
  start.stage = c("alignment", "qc", "calling", "annotation", "merging"),
  variant.callers = NULL, proton = FALSE, quiet = FALSE,
  email = NULL, verify.options = !quiet,
  save.specification.files = !quiet)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run.varitas.pipeline_+3A_file.details">file.details</code></td>
<td>
<p>Data frame containing details of files to be used during first processing step.
Depending on what you want to be the first step in the pipeline, this can either be 
FASTQ files, BAM files, VCF files, or variant (txt) files.</p>
</td></tr>
<tr><td><code id="run.varitas.pipeline_+3A_output.directory">output.directory</code></td>
<td>
<p>Main directory where all files should be saved</p>
</td></tr>
<tr><td><code id="run.varitas.pipeline_+3A_run.name">run.name</code></td>
<td>
<p>Name of pipeline run. Will be added as a prefix to all LSF jobs.</p>
</td></tr>
<tr><td><code id="run.varitas.pipeline_+3A_start.stage">start.stage</code></td>
<td>
<p>String indicating which stage pipeline should start at. If starting at a later stage
of the pipeline, appropriate input files must be provided. For example, if starting with annotation, 
VCF files with variant calls must be provided.</p>
</td></tr>
<tr><td><code id="run.varitas.pipeline_+3A_variant.callers">variant.callers</code></td>
<td>
<p>Vector specifying which variant callers should be run.</p>
</td></tr>
<tr><td><code id="run.varitas.pipeline_+3A_proton">proton</code></td>
<td>
<p>Logical indicating if data was generated by proton sequencing. Used to set base quality 
thresholds in variant calling steps.</p>
</td></tr>
<tr><td><code id="run.varitas.pipeline_+3A_quiet">quiet</code></td>
<td>
<p>Logical indicating whether to print commands to screen rather than submit jobs. Defaults to FALSE,
can be useful to set to TRUE for testing.</p>
</td></tr>
<tr><td><code id="run.varitas.pipeline_+3A_email">email</code></td>
<td>
<p>Email address that should be notified when pipeline finishes. If NULL or FALSE, no email is sent.</p>
</td></tr>
<tr><td><code id="run.varitas.pipeline_+3A_verify.options">verify.options</code></td>
<td>
<p>Logical indicating whether to run verify.varitas.options</p>
</td></tr>
<tr><td><code id="run.varitas.pipeline_+3A_save.specification.files">save.specification.files</code></td>
<td>
<p>Logical indicating if specification files should be saved to project directory</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>run.varitas.pipeline(
       file.details = data.frame(
        sample.id = c('1', '2'),
        reads = c('1-R1.fastq.gz', '2-R1.fastq.gz'),
        mates = c('1-R2.fastq.gz', '2-R2.fastq.gz'),
         patient.id = c('P1', 'P1'),
         tissue = c('tumour', 'normal')
       ),
       output.directory = '.',
       quiet = TRUE,
       run.name = "Test", 
       variant.callers = c('mutect', 'varscan')
     )

</code></pre>

<hr>
<h2 id='run.varitas.pipeline.hybrid'>run.varitas.pipeline.hybrid</h2><span id='topic+run.varitas.pipeline.hybrid'></span>

<h3>Description</h3>

<p>Run VariTAS pipeline starting from both VCF files and BAM/ FASTQ files. 
Useful for processing data from the Ion PGM or MiniSeq where variant calling has been done on the machine, 
but you are interested in running more variant callers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run.varitas.pipeline.hybrid(vcf.specification, output.directory,
  run.name = NULL, fastq.specification = NULL,
  bam.specification = NULL, variant.callers = c("mutect", "vardict",
  "varscan", "lofreq", "muse"), proton = FALSE, quiet = FALSE,
  email = NULL, verify.options = !quiet,
  save.specification.files = !quiet)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run.varitas.pipeline.hybrid_+3A_vcf.specification">vcf.specification</code></td>
<td>
<p>Data frame containing details of vcf files to be processed. Must contain columns sample.id, vcf, and caller</p>
</td></tr>
<tr><td><code id="run.varitas.pipeline.hybrid_+3A_output.directory">output.directory</code></td>
<td>
<p>Main directory where all files should be saved</p>
</td></tr>
<tr><td><code id="run.varitas.pipeline.hybrid_+3A_run.name">run.name</code></td>
<td>
<p>Name of pipeline run. Will be added as a prefix to all LSF jobs.</p>
</td></tr>
<tr><td><code id="run.varitas.pipeline.hybrid_+3A_fastq.specification">fastq.specification</code></td>
<td>
<p>Data frame containing details of FASTQ files to be processed</p>
</td></tr>
<tr><td><code id="run.varitas.pipeline.hybrid_+3A_bam.specification">bam.specification</code></td>
<td>
<p>Data frame containing details of BAM files to be processed</p>
</td></tr>
<tr><td><code id="run.varitas.pipeline.hybrid_+3A_variant.callers">variant.callers</code></td>
<td>
<p>Vector specifying which variant callers should be run.</p>
</td></tr>
<tr><td><code id="run.varitas.pipeline.hybrid_+3A_proton">proton</code></td>
<td>
<p>Logical indicating if data was generated by proton sequencing. Used to set base quality 
thresholds in variant calling steps.</p>
</td></tr>
<tr><td><code id="run.varitas.pipeline.hybrid_+3A_quiet">quiet</code></td>
<td>
<p>Logical indicating whether to print commands to screen rather than submit jobs. Defaults to FALSE,
can be useful to set to TRUE for testing.</p>
</td></tr>
<tr><td><code id="run.varitas.pipeline.hybrid_+3A_email">email</code></td>
<td>
<p>Email address that should be notified when pipeline finishes. If NULL or FALSE, no email is sent.</p>
</td></tr>
<tr><td><code id="run.varitas.pipeline.hybrid_+3A_verify.options">verify.options</code></td>
<td>
<p>Logical indicating whether to run verify.varitas.options</p>
</td></tr>
<tr><td><code id="run.varitas.pipeline.hybrid_+3A_save.specification.files">save.specification.files</code></td>
<td>
<p>Logical indicating if specification files should be saved to project directory</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>run.varitas.pipeline.hybrid(
       bam.specification = data.frame(sample.id = c('Z', 'Y'), tumour.bam = c('Z.bam', 'Y.bam')),
       vcf.specification = data.frame(
         sample.id = c('a', 'b'),
         vcf = c('a.vcf', 'b.vcf'),
         caller = c('pgm', 'pgm')
       ),
       output.directory = '.',
       quiet = TRUE,
       run.name = "Test", 
       variant.callers = c('mutect', 'varscan')
     )

</code></pre>

<hr>
<h2 id='run.varscan.sample'>Run VarScan for a sample</h2><span id='topic+run.varscan.sample'></span>

<h3>Description</h3>

<p>Run VarScan for a sample
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run.varscan.sample(tumour.bam, sample.id, paired, normal.bam = NULL,
  output.directory = NULL, output.filename = NULL,
  code.directory = NULL, log.directory = NULL, config.file = NULL,
  job.dependencies = NULL, quiet = FALSE, job.name = NULL,
  verify.options = !quiet, job.group = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run.varscan.sample_+3A_tumour.bam">tumour.bam</code></td>
<td>
<p>Path to tumour sample BAM file.</p>
</td></tr>
<tr><td><code id="run.varscan.sample_+3A_sample.id">sample.id</code></td>
<td>
<p>Sample ID for labelling</p>
</td></tr>
<tr><td><code id="run.varscan.sample_+3A_paired">paired</code></td>
<td>
<p>Logical indicating whether to do variant calling with a matched normal.</p>
</td></tr>
<tr><td><code id="run.varscan.sample_+3A_normal.bam">normal.bam</code></td>
<td>
<p>Path to normal BAM file if <code>paired = TRUE</code></p>
</td></tr>
<tr><td><code id="run.varscan.sample_+3A_output.directory">output.directory</code></td>
<td>
<p>Path to output directory</p>
</td></tr>
<tr><td><code id="run.varscan.sample_+3A_output.filename">output.filename</code></td>
<td>
<p>Name of resulting VCF file (defaults to SAMPLE_ID.vcf)</p>
</td></tr>
<tr><td><code id="run.varscan.sample_+3A_code.directory">code.directory</code></td>
<td>
<p>Path to directory where code should be stored</p>
</td></tr>
<tr><td><code id="run.varscan.sample_+3A_log.directory">log.directory</code></td>
<td>
<p>Path to directory where log files should be stored</p>
</td></tr>
<tr><td><code id="run.varscan.sample_+3A_config.file">config.file</code></td>
<td>
<p>Path to config file</p>
</td></tr>
<tr><td><code id="run.varscan.sample_+3A_job.dependencies">job.dependencies</code></td>
<td>
<p>Vector with names of job dependencies</p>
</td></tr>
<tr><td><code id="run.varscan.sample_+3A_quiet">quiet</code></td>
<td>
<p>Logical indicating whether to print command to screen rather than submit it to the system. Defaults to false, useful for debugging.</p>
</td></tr>
<tr><td><code id="run.varscan.sample_+3A_job.name">job.name</code></td>
<td>
<p>Name of job to be submitted</p>
</td></tr>
<tr><td><code id="run.varscan.sample_+3A_verify.options">verify.options</code></td>
<td>
<p>Logical indicating whether to run verify.varitas.options</p>
</td></tr>
<tr><td><code id="run.varscan.sample_+3A_job.group">job.group</code></td>
<td>
<p>Group job should belong to</p>
</td></tr>
</table>

<hr>
<h2 id='save.config'>save.config</h2><span id='topic+save.config'></span>

<h3>Description</h3>

<p>Save current varitas config options to a temporary file, and return filename.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save.config(output.file = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="save.config_+3A_output.file">output.file</code></td>
<td>
<p>Path to output file. If NULL (default), the config file will be saved as a temporary file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Path to config file
</p>

<hr>
<h2 id='save.coverage.excel'>Save coverage statistics to multi-worksheet Excel file.</h2><span id='topic+save.coverage.excel'></span>

<h3>Description</h3>

<p>Save coverage statistics to multi-worksheet Excel file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save.coverage.excel(project.directory, file.name, overwrite = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="save.coverage.excel_+3A_project.directory">project.directory</code></td>
<td>
<p>Path to project directory</p>
</td></tr>
<tr><td><code id="save.coverage.excel_+3A_file.name">file.name</code></td>
<td>
<p>Name of output file</p>
</td></tr>
<tr><td><code id="save.coverage.excel_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical indicating whether to overwrite existing file if it exists.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='save.variants.excel'>Save variants to Excel.</h2><span id='topic+save.variants.excel'></span>

<h3>Description</h3>

<p>Makes an Excel workbook with variant calls. If filters are provided, these will 
be saved to an additional worksheet within the same file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save.variants.excel(variants, file.name, filters = NULL,
  overwrite = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="save.variants.excel_+3A_variants">variants</code></td>
<td>
<p>Data frame containing variants</p>
</td></tr>
<tr><td><code id="save.variants.excel_+3A_file.name">file.name</code></td>
<td>
<p>Name of output file</p>
</td></tr>
<tr><td><code id="save.variants.excel_+3A_filters">filters</code></td>
<td>
<p>Optional list of filters to be saved</p>
</td></tr>
<tr><td><code id="save.variants.excel_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical indicating whether to overwrite exiting file if it exists. Defaults to TRUE for consistency with other R functions.</p>
</td></tr>
</table>

<hr>
<h2 id='set.varitas.options'>Set options for varitas pipeline.</h2><span id='topic+set.varitas.options'></span>

<h3>Description</h3>

<p>Set or overwrite options for the VariTAS pipeline. Nested options should be separated by a dot. 
For example, to update the reference genome for grch38, use reference_genome.grch38
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.varitas.options(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set.varitas.options_+3A_...">...</code></td>
<td>
<p>options to set</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.varitas.options(reference_build = 'grch38'); 	
	set.varitas.options(
	filters.mutect.min_normal_depth = 10,
	filters.vardict.min_normal_depth = 10
	);

## End(Not run)
</code></pre>

<hr>
<h2 id='split.on.column'>split.on.column</h2><span id='topic+split.on.column'></span>

<h3>Description</h3>

<p>Split data frame on a concatenated column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'on.column'
split(dat, column, split.character)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split.on.column_+3A_dat">dat</code></td>
<td>
<p>Data frame to be processed</p>
</td></tr>
<tr><td><code id="split.on.column_+3A_column">column</code></td>
<td>
<p>Name of column to split on</p>
</td></tr>
<tr><td><code id="split.on.column_+3A_split.character">split.character</code></td>
<td>
<p>Pattern giving character to split column on</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame after splitting on column
</p>

<hr>
<h2 id='sum.dp4'>sum.dp4</h2><span id='topic+sum.dp4'></span>

<h3>Description</h3>

<p>Simply calculates the depth of coverage of the variant allele given a string of
DP4 values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dp4'
sum(dp4.str)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sum.dp4_+3A_dp4.str">dp4.str</code></td>
<td>
<p>String of DP4 values in the form &quot;1234,1234,1234,1234&quot;</p>
</td></tr>
</table>

<hr>
<h2 id='system.ls'>Run ls command</h2><span id='topic+system.ls'></span>

<h3>Description</h3>

<p>Runs ls command on system. This is a workaround since list.files can not match patterns based on subdirectory structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>system.ls(pattern = "", directory = "", error = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="system.ls_+3A_pattern">pattern</code></td>
<td>
<p>pattern to match files</p>
</td></tr>
<tr><td><code id="system.ls_+3A_directory">directory</code></td>
<td>
<p>base directory command should be run from</p>
</td></tr>
<tr><td><code id="system.ls_+3A_error">error</code></td>
<td>
<p>logical indicating whether to throw an error if no matching founds found. Defaults to False.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>paths returned by ls command
</p>

<hr>
<h2 id='tabular.mean'>tabular.mean</h2><span id='topic+tabular.mean'></span>

<h3>Description</h3>

<p>Calculate the mean of data in tabular format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tabular.mean(values, frequencies, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tabular.mean_+3A_values">values</code></td>
<td>
<p>vector of values</p>
</td></tr>
<tr><td><code id="tabular.mean_+3A_frequencies">frequencies</code></td>
<td>
<p>frequency corresponding to each value</p>
</td></tr>
<tr><td><code id="tabular.mean_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to <code>sum</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>calculated mean
</p>

<hr>
<h2 id='tabular.median'>tabular.median</h2><span id='topic+tabular.median'></span>

<h3>Description</h3>

<p>Calculate the median of data in tabular format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tabular.median(values, frequencies, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tabular.median_+3A_values">values</code></td>
<td>
<p>Vector of values</p>
</td></tr>
<tr><td><code id="tabular.median_+3A_frequencies">frequencies</code></td>
<td>
<p>Frequency corresponding to each value</p>
</td></tr>
<tr><td><code id="tabular.median_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to <code>sum</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>calculated median
</p>

<hr>
<h2 id='trinucleotide.barplot'>Make barplot of trinucleotide substitutions</h2><span id='topic+trinucleotide.barplot'></span>

<h3>Description</h3>

<p>Make barplot of trinucleotide substitutions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trinucleotide.barplot(variants, file.name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trinucleotide.barplot_+3A_variants">variants</code></td>
<td>
<p>Data frame with variants</p>
</td></tr>
<tr><td><code id="trinucleotide.barplot_+3A_file.name">file.name</code></td>
<td>
<p>Name of output file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='variant.recurrence.barplot'>Make barplot of variants per caller</h2><span id='topic+variant.recurrence.barplot'></span>

<h3>Description</h3>

<p>Make barplot of variants per caller
</p>


<h3>Usage</h3>

<pre><code class='language-R'>variant.recurrence.barplot(variants, file.name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="variant.recurrence.barplot_+3A_variants">variants</code></td>
<td>
<p>Data frame with variants</p>
</td></tr>
<tr><td><code id="variant.recurrence.barplot_+3A_file.name">file.name</code></td>
<td>
<p>Name of output file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='variants.caller.barplot'>Make barplot of variants per caller</h2><span id='topic+variants.caller.barplot'></span>

<h3>Description</h3>

<p>Make barplot of variants per caller
</p>


<h3>Usage</h3>

<pre><code class='language-R'>variants.caller.barplot(variants, file.name, group.by = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="variants.caller.barplot_+3A_variants">variants</code></td>
<td>
<p>Data frame with variants</p>
</td></tr>
<tr><td><code id="variants.caller.barplot_+3A_file.name">file.name</code></td>
<td>
<p>Name of output file</p>
</td></tr>
<tr><td><code id="variants.caller.barplot_+3A_group.by">group.by</code></td>
<td>
<p>Optional grouping variable for barplot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='variants.sample.barplot'>Make barplot of variants per sample</h2><span id='topic+variants.sample.barplot'></span>

<h3>Description</h3>

<p>Make barplot of variants per sample
</p>


<h3>Usage</h3>

<pre><code class='language-R'>variants.sample.barplot(variants, file.name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="variants.sample.barplot_+3A_variants">variants</code></td>
<td>
<p>Data frame with variants</p>
</td></tr>
<tr><td><code id="variants.sample.barplot_+3A_file.name">file.name</code></td>
<td>
<p>Name of output file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='verify.bam.specification'>Check that sample specification data frame matches expected format, and that all files exist</h2><span id='topic+verify.bam.specification'></span>

<h3>Description</h3>

<p>Check that sample specification data frame matches expected format, and that all files exist
</p>


<h3>Usage</h3>

<pre><code class='language-R'>verify.bam.specification(bam.specification)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="verify.bam.specification_+3A_bam.specification">bam.specification</code></td>
<td>
<p>Data frame containing columns sample.id and tumour.bam, and optionally a column normal.bam.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='verify.bwa.index'>verify.bwa.index</h2><span id='topic+verify.bwa.index'></span>

<h3>Description</h3>

<p>Verify that bwa index files exist for a fasta file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>verify.bwa.index(fasta.file, error = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="verify.bwa.index_+3A_fasta.file">fasta.file</code></td>
<td>
<p>Fasta file to check</p>
</td></tr>
<tr><td><code id="verify.bwa.index_+3A_error">error</code></td>
<td>
<p>Logical indicating whether to throw an (informative) error if verification fails</p>
</td></tr>
</table>


<h3>Value</h3>

<p>index.files.exist Logical indicating if bwa index files were found (only returned if error set to FALSE)
</p>

<hr>
<h2 id='verify.fasta.index'>verify.fasta.index</h2><span id='topic+verify.fasta.index'></span>

<h3>Description</h3>

<p>Verify that fasta index files exist for a given fasta file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>verify.fasta.index(fasta.file, error = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="verify.fasta.index_+3A_fasta.file">fasta.file</code></td>
<td>
<p>Fasta file to check</p>
</td></tr>
<tr><td><code id="verify.fasta.index_+3A_error">error</code></td>
<td>
<p>Logical indicating whether to throw an (informative) error if verification fails</p>
</td></tr>
</table>


<h3>Value</h3>

<p>faidx.exists Logical indicating if fasta index files were found (only returned if error set to FALSE)
</p>

<hr>
<h2 id='verify.fastq.specification'>Check that FASTQ specification data frame matches expected format, and that all files exist</h2><span id='topic+verify.fastq.specification'></span>

<h3>Description</h3>

<p>Check that FASTQ specification data frame matches expected format, and that all files exist
</p>


<h3>Usage</h3>

<pre><code class='language-R'>verify.fastq.specification(fastq.specification, paired.end = FALSE,
  files.ready = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="verify.fastq.specification_+3A_fastq.specification">fastq.specification</code></td>
<td>
<p>Data frame containing columns sample.id and reads, and optionally a column mates</p>
</td></tr>
<tr><td><code id="verify.fastq.specification_+3A_paired.end">paired.end</code></td>
<td>
<p>Logical indicating whether paired end reads are used</p>
</td></tr>
<tr><td><code id="verify.fastq.specification_+3A_files.ready">files.ready</code></td>
<td>
<p>Logical indicating if the files already exist on disk. If there are job dependencies, this should be set to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='verify.sequence.dictionary'>verify.sequence.dictionary</h2><span id='topic+verify.sequence.dictionary'></span>

<h3>Description</h3>

<p>Verify that sequence dictionary exists for a fasta file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>verify.sequence.dictionary(fasta.file, error = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="verify.sequence.dictionary_+3A_fasta.file">fasta.file</code></td>
<td>
<p>Fasta file to check</p>
</td></tr>
<tr><td><code id="verify.sequence.dictionary_+3A_error">error</code></td>
<td>
<p>Logical indicating whether to throw an (informative) error if verification fails</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dict.exists Logical indicating if sequence dictionary files were found (only returned if error set to FALSE)
</p>

<hr>
<h2 id='verify.varitas.options'>Check against common errors in the VariTAS options.</h2><span id='topic+verify.varitas.options'></span>

<h3>Description</h3>

<p>Check against common errors in the VariTAS options before launching into pipeline
</p>


<h3>Usage</h3>

<pre><code class='language-R'>verify.varitas.options(stages.to.run = c("alignment", "qc", "calling",
  "annotation", "merging"), variant.callers = c("mutect", "vardict",
  "ides", "varscan", "lofreq", "muse"), varitas.options = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="verify.varitas.options_+3A_stages.to.run">stages.to.run</code></td>
<td>
<p>Vector indicating which stages should be run. Defaults to all possible stages. 
If only running a subset of stages, only checks corresponding to the desired stages are run</p>
</td></tr>
<tr><td><code id="verify.varitas.options_+3A_variant.callers">variant.callers</code></td>
<td>
<p>Vector indicating which variant callers to run. Only used if calling is in <code>stages.to.run</code>.</p>
</td></tr>
<tr><td><code id="verify.varitas.options_+3A_varitas.options">varitas.options</code></td>
<td>
<p>Optional file path or list of VariTAS options.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='verify.vcf.specification'>verify.vcf.specification</h2><span id='topic+verify.vcf.specification'></span>

<h3>Description</h3>

<p>Verify that VCF specification data frame fits expected format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>verify.vcf.specification(vcf.specification)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="verify.vcf.specification_+3A_vcf.specification">vcf.specification</code></td>
<td>
<p>VCF specification data frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
